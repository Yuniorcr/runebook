<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="78a25e5b990fcd1740e4efa791bdb025c393c864" translate="yes" xml:space="preserve">
          <source>In some situations, some strings that should create a valid float instead return an error. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/31407&quot;&gt;issue #31407&lt;/a&gt; for details.</source>
          <target state="translated">경우에 따라 유효한 부동 소수점을 만들어야하는 일부 문자열은 대신 오류를 반환합니다. 자세한 내용은 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/31407&quot;&gt;이슈 # 31407&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e28b9cfae095cd08e8afd62032026a0b23bc39f7" translate="yes" xml:space="preserve">
          <source>In statements like &lt;code&gt;let x = 5;&lt;/code&gt; with a variable name in the &lt;code&gt;PATTERN&lt;/code&gt; slot, the variable name is just a particularly simple form of a pattern. Rust compares the expression against the pattern and assigns any names it finds. So in the &lt;code&gt;let x = 5;&lt;/code&gt; example, &lt;code&gt;x&lt;/code&gt; is a pattern that means &amp;ldquo;bind what matches here to the variable &lt;code&gt;x&lt;/code&gt;.&amp;rdquo; Because the name &lt;code&gt;x&lt;/code&gt; is the whole pattern, this pattern effectively means &amp;ldquo;bind everything to the variable &lt;code&gt;x&lt;/code&gt;, whatever the value is.&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;let x = 5;&lt;/code&gt; 와 같은 문장에서 ; 의 변수 이름 &lt;code&gt;PATTERN&lt;/code&gt; 의 슬롯 변수 이름은 패턴의 특히 단순한 형태이다. Rust는 표현식을 패턴과 비교하고 찾은 이름을 지정합니다. 따라서 &lt;code&gt;let x = 5;&lt;/code&gt; 예를 들어, &lt;code&gt;x&lt;/code&gt; 는 &quot;여기에 일치하는 것을 변수 &lt;code&gt;x&lt;/code&gt; 에 바인딩&quot;을 의미하는 패턴입니다 . &lt;code&gt;x&lt;/code&gt; 라는 이름 은 전체 패턴이므로이 패턴은 &quot; 값에 관계없이 모든 것을 변수 &lt;code&gt;x&lt;/code&gt; 에 바인딩&quot;을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="ab76c75fb8be2531be195781f70554fa526d2349" translate="yes" xml:space="preserve">
          <source>In such a case, the compiler cannot predict the return type of &lt;code&gt;foo()&lt;/code&gt; in a situation like the following:</source>
          <target state="translated">이 경우 컴파일러는 다음과 같은 상황에서 &lt;code&gt;foo()&lt;/code&gt; 의 반환 유형을 예측할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a84c028b3015af78e467c76bddbf22405a6992e9" translate="yes" xml:space="preserve">
          <source>In sum, here are the steps we took to change the code from Listing 10-2 to Listing 10-3:</source>
          <target state="translated">요약하면 코드를 Listing 10-2에서 Listing 10-3으로 변경하기 위해 취한 단계는 다음과 같다.</target>
        </trans-unit>
        <trans-unit id="b66a6766ec59e5aa720a0c750a221736c0a524da" translate="yes" xml:space="preserve">
          <source>In terms of &lt;a href=&quot;../sync/atomic/index&quot;&gt;atomic memory orderings&lt;/a&gt;, the completion of the associated thread synchronizes with this function returning. In other words, all operations performed by that thread are ordered before all operations that happen after &lt;code&gt;join&lt;/code&gt; returns.</source>
          <target state="translated">면에서는 &lt;a href=&quot;../sync/atomic/index&quot;&gt;원자 메모리 순서화&lt;/a&gt; , 연관된 스레드의 완성이 함수 리턴과 동기화한다. 즉, 해당 스레드가 수행하는 모든 작업은 &lt;code&gt;join&lt;/code&gt; 반환 된 후 발생하는 모든 작업보다 먼저 정렬 됩니다.</target>
        </trans-unit>
        <trans-unit id="49ebdf4d886162df5d53e77b9ab0d51282c8c87c" translate="yes" xml:space="preserve">
          <source>In the 2015 edition parameters pattern where not needed for traits:</source>
          <target state="translated">특성에 필요하지 않은 2015 년 판 매개 변수 패턴 :</target>
        </trans-unit>
        <trans-unit id="4fb4dfd79140995a00d7f2f4a091910c0bb3584f" translate="yes" xml:space="preserve">
          <source>In the 2015 edition, &lt;a href=&quot;types/trait-object&quot;&gt;&lt;code&gt;dyn&lt;/code&gt;&lt;/a&gt; is a keyword when used in a type position followed by a path that does not start with &lt;code&gt;::&lt;/code&gt;.</source>
          <target state="translated">2015 년판에서 &lt;a href=&quot;types/trait-object&quot;&gt; &lt;code&gt;dyn&lt;/code&gt; &lt;/a&gt; 은 유형 위치에 사용될 때 키워드이며 &lt;code&gt;::&lt;/code&gt; 로 시작하지 않는 경로입니다 .</target>
        </trans-unit>
        <trans-unit id="e5c533200fa356e0f6f01942ecd077fd12144d48" translate="yes" xml:space="preserve">
          <source>In the 2015 edition, the pattern for a trait function or method parameter is optional:</source>
          <target state="translated">2015 년판에서 특성 함수 또는 메소드 매개 변수의 패턴은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="ead217a846b182b1c7c3895bb636fcdc53cf3da8" translate="yes" xml:space="preserve">
          <source>In the 2018 edition, if an in-scope item has the same name as an external crate, then &lt;code&gt;use&lt;/code&gt; of that crate name requires a leading &lt;code&gt;::&lt;/code&gt; to unambiguously select the crate name. This is to retain compatibility with potential future changes.</source>
          <target state="translated">2018 년 판에서, 범위 내 아이템이 외부 상자와 이름이 같은 &lt;code&gt;use&lt;/code&gt; , 해당 상자 이름 을 사용 하려면 &lt;code&gt;::&lt;/code&gt; 를 사용하여 상자 이름을 명확하게 선택해야합니다. 이는 잠재적 인 향후 변경 사항과의 호환성을 유지하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a3999cf3a0362f5c3017eea167e996c61b1004cc" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://www.unicode.org/versions/latest/&quot;&gt;Unicode Standard&lt;/a&gt;, Chapter 4 (Character Properties) discusses case mapping in general and Chapter 3 (Conformance) discusses the default algorithm for case conversion.</source>
          <target state="translated">에서 &lt;a href=&quot;https://www.unicode.org/versions/latest/&quot;&gt;유니 코드 표준&lt;/a&gt; , 제 4 장 (문자 속성) 일반적으로 케이스 매핑에 대해 설명하고 3 장 (준수)의 경우 변환을위한 기본 알고리즘에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ac8c3e671a7bc9e2a3ca26713c444ad82025ac40" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;index&quot;&gt;module level docs&lt;/a&gt;, we implemented an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Counter&lt;/code&gt;. Let's implement &lt;code&gt;ExactSizeIterator&lt;/code&gt; for it as well:</source>
          <target state="translated">에서 &lt;a href=&quot;index&quot;&gt;모듈 수준의 문서&lt;/a&gt; , 우리는 구현 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Counter&lt;/code&gt; . &lt;code&gt;ExactSizeIterator&lt;/code&gt; 도 구현해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="542be6c89aa5ea78dd9931c09f1fa338c6d41b0e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;User&lt;/code&gt; struct definition in Listing 5-1, we used the owned &lt;code&gt;String&lt;/code&gt; type rather than the &lt;code&gt;&amp;amp;str&lt;/code&gt; string slice type. This is a deliberate choice because we want instances of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.</source>
          <target state="translated">Listing 5-1 의 &lt;code&gt;User&lt;/code&gt; 구조체 정의에서 &lt;code&gt;&amp;amp;str&lt;/code&gt; 문자열 슬라이스 타입 대신 소유 한 &lt;code&gt;String&lt;/code&gt; 타입을 사용했다 . 이 구조체의 인스턴스가 모든 데이터를 소유하고 전체 구조체가 유효한 한 해당 데이터가 유효하기를 원하기 때문에 이것은 신중한 선택입니다.</target>
        </trans-unit>
        <trans-unit id="86f5e9e4af3e5d42db41973d9449d9469f700ef8" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;handle_connection&lt;/code&gt; function, we&amp;rsquo;ve made the &lt;code&gt;stream&lt;/code&gt; parameter mutable. The reason is that the &lt;code&gt;TcpStream&lt;/code&gt; instance keeps track of what data it returns to us internally. It might read more data than we asked for and save that data for the next time we ask for data. It therefore needs to be &lt;code&gt;mut&lt;/code&gt; because its internal state might change; usually, we think of &amp;ldquo;reading&amp;rdquo; as not needing mutation, but in this case we need the &lt;code&gt;mut&lt;/code&gt; keyword.</source>
          <target state="translated">에서 &lt;code&gt;handle_connection&lt;/code&gt; 의 기능, 우리는했습니다 &lt;code&gt;stream&lt;/code&gt; 변경 가능한 매개 변수입니다. 그 이유는 &lt;code&gt;TcpStream&lt;/code&gt; 인스턴스가 어떤 데이터를 내부적으로 반환했는지 추적하기 때문입니다. 요청한 것보다 많은 데이터를 읽고 다음에 데이터를 요청할 때 해당 데이터를 저장할 수 있습니다. 따라서 내부 상태가 변경 될 수 있으므로 &lt;code&gt;mut&lt;/code&gt; 해야합니다 . 일반적으로&amp;ldquo;읽기&amp;rdquo;는 돌연변이가 필요없는 것으로 생각하지만이 경우에는 &lt;code&gt;mut&lt;/code&gt; 키워드 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="41e5d381e8adcfa53c11fefa07fcde5916d77703" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;Cargo.toml&lt;/em&gt; file, everything that follows a header is part of a section that continues until another section starts. The &lt;code&gt;[dependencies]&lt;/code&gt; section is where you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we&amp;rsquo;ll specify the &lt;code&gt;rand&lt;/code&gt; crate with the semantic version specifier &lt;code&gt;0.3.14&lt;/code&gt;. Cargo understands &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; (sometimes called &lt;em&gt;SemVer&lt;/em&gt;), which is a standard for writing version numbers. The number &lt;code&gt;0.3.14&lt;/code&gt; is actually shorthand for &lt;code&gt;^0.3.14&lt;/code&gt;, which means &amp;ldquo;any version that has a public API compatible with version 0.3.14.&amp;rdquo;</source>
          <target state="translated">에서 &lt;em&gt;Cargo.toml의&lt;/em&gt; 파일 헤더를 다음과 모든 다른 섹션이 시작될 때까지 계속 섹션의 일부입니다. &lt;code&gt;[dependencies]&lt;/code&gt; 섹션은 외부 상자 프로젝트에 의존하고있는화물을 말할 곳이다 당신이 필요로하는 상자의 버전. 이 경우 시맨틱 버전 지정자 &lt;code&gt;0.3.14&lt;/code&gt; 로 &lt;code&gt;rand&lt;/code&gt; 상자를 지정합니다 . Cargo 는 버전 번호 작성 표준 인 &lt;a href=&quot;http://semver.org&quot;&gt;시맨틱 버전 관리&lt;/a&gt; ( &lt;em&gt;SemVer&lt;/em&gt; 라고도 함 )를 이해 합니다. 숫자 &lt;code&gt;0.3.14&lt;/code&gt; 는 실제로 &lt;code&gt;^0.3.14&lt;/code&gt; 약자입니다 . &quot;0.3.14 버전과 호환되는 공개 API가있는 모든 버전&quot;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba414d8766c29269cba8897672efd77d70e901b9" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;Cargo.toml&lt;/em&gt; file, everything that follows a header is part of a section that continues until another section starts. The &lt;code&gt;[dependencies]&lt;/code&gt; section is where you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we&amp;rsquo;ll specify the &lt;code&gt;rand&lt;/code&gt; crate with the semantic version specifier &lt;code&gt;0.5.5&lt;/code&gt;. Cargo understands &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; (sometimes called &lt;em&gt;SemVer&lt;/em&gt;), which is a standard for writing version numbers. The number &lt;code&gt;0.5.5&lt;/code&gt; is actually shorthand for &lt;code&gt;^0.5.5&lt;/code&gt;, which means &amp;ldquo;any version that has a public API compatible with version 0.5.5.&amp;rdquo;</source>
          <target state="translated">에서 &lt;em&gt;Cargo.toml의&lt;/em&gt; 파일 헤더를 다음과 모든 다른 섹션이 시작될 때까지 계속 섹션의 일부입니다. &lt;code&gt;[dependencies]&lt;/code&gt; 섹션은 외부 상자 프로젝트에 의존하고있는화물을 말할 곳이다 당신이 필요로하는 상자의 버전. 이 경우 의미 론적 버전 지정자 &lt;code&gt;0.5.5&lt;/code&gt; 를 사용하여 &lt;code&gt;rand&lt;/code&gt; crate를 지정합니다 . Cargo 는 버전 번호 작성을위한 표준 인 &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; ( &lt;em&gt;SemVer&lt;/em&gt; 라고도 함 )을 이해 합니다. 숫자 &lt;code&gt;0.5.5&lt;/code&gt; 는 실제로 &lt;code&gt;^0.5.5&lt;/code&gt; 약칭 이며 , 이는 '버전 0.5.5와 호환되는 공개 API가있는 모든 버전'을 의미합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b7177f5dba94e8e93990faf2d2454fb646d49847" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;add-one/src/lib.rs&lt;/em&gt; file, let&amp;rsquo;s add an &lt;code&gt;add_one&lt;/code&gt; function:</source>
          <target state="translated">에 &lt;em&gt;추가 한 / SRC / lib.rs의&lt;/em&gt; 파일의는 추가 할 수 &lt;code&gt;add_one&lt;/code&gt; 의 기능 :</target>
        </trans-unit>
        <trans-unit id="3da0b39e8b4dc5e8ab87b83cc0f936c2b1215ca7" translate="yes" xml:space="preserve">
          <source>In the above example &lt;code&gt;T&lt;/code&gt; is unknowable by the compiler. To fix this you must bind &lt;code&gt;T&lt;/code&gt; to a concrete type such as &lt;code&gt;String&lt;/code&gt; so that a generator can then be constructed:</source>
          <target state="translated">위의 예 에서 컴파일러는 &lt;code&gt;T&lt;/code&gt; 를 알 수 없습니다. 이 문제를 해결하려면 생성기를 구성 할 수 있도록 &lt;code&gt;T&lt;/code&gt; 를 &lt;code&gt;String&lt;/code&gt; 과 같은 콘크리트 유형에 바인딩해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dac108bef6e0aa0c5a3c87c1e1dd002eec20cb12" translate="yes" xml:space="preserve">
          <source>In the absolute path, we start with &lt;code&gt;crate&lt;/code&gt;, the root of our crate&amp;rsquo;s module tree. Then the &lt;code&gt;front_of_house&lt;/code&gt; module is defined in the crate root. The &lt;code&gt;front_of_house&lt;/code&gt; module isn&amp;rsquo;t public, but because the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function is defined in the same module as &lt;code&gt;front_of_house&lt;/code&gt; (that is, &lt;code&gt;eat_at_restaurant&lt;/code&gt; and &lt;code&gt;front_of_house&lt;/code&gt; are siblings), we can refer to &lt;code&gt;front_of_house&lt;/code&gt; from &lt;code&gt;eat_at_restaurant&lt;/code&gt;. Next is the &lt;code&gt;hosting&lt;/code&gt; module marked with &lt;code&gt;pub&lt;/code&gt;. We can access the parent module of &lt;code&gt;hosting&lt;/code&gt;, so we can access &lt;code&gt;hosting&lt;/code&gt;. Finally, the &lt;code&gt;add_to_waitlist&lt;/code&gt; function is marked with &lt;code&gt;pub&lt;/code&gt; and we can access its parent module, so this function call works!</source>
          <target state="translated">절대 경로에서 우리는 상자의 모듈 트리의 루트 인 &lt;code&gt;crate&lt;/code&gt; 로 시작 합니다. 그런 다음 &lt;code&gt;front_of_house&lt;/code&gt; 모듈은 크레이트 루트에 정의됩니다. &lt;code&gt;front_of_house&lt;/code&gt; 의 모듈 공개 아니지만 때문에 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 함수와 같은 모듈에 정의 &lt;code&gt;front_of_house&lt;/code&gt; (이라고 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 가 와 &lt;code&gt;front_of_house&lt;/code&gt; 형제이다), 우리는 참조 할 수 &lt;code&gt;front_of_house&lt;/code&gt; 에서 &lt;code&gt;eat_at_restaurant&lt;/code&gt; . 다음은 &lt;code&gt;pub&lt;/code&gt; 으로 표시된 &lt;code&gt;hosting&lt;/code&gt; 모듈 입니다. &lt;code&gt;hosting&lt;/code&gt; 의 상위 모듈에 액세스 할 수 있으므로 액세스 할 수 있습니다 . 마지막으로 &lt;code&gt;hosting&lt;/code&gt; &lt;code&gt;add_to_waitlist&lt;/code&gt; 함수는 &lt;code&gt;pub&lt;/code&gt; 으로 표시되며 부모 모듈에 액세스 할 수 있으므로이 함수 호출이 작동합니다!</target>
        </trans-unit>
        <trans-unit id="e8a74d26ff6bb6812e6769b94696470ac83d32c8" translate="yes" xml:space="preserve">
          <source>In the body of &lt;code&gt;largest&lt;/code&gt; we wanted to compare two values of type &lt;code&gt;T&lt;/code&gt; using the greater than (&lt;code&gt;&amp;gt;&lt;/code&gt;) operator. Because that operator is defined as a default method on the standard library trait &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt;, we need to specify &lt;code&gt;PartialOrd&lt;/code&gt; in the trait bounds for &lt;code&gt;T&lt;/code&gt; so the &lt;code&gt;largest&lt;/code&gt; function can work on slices of any type that we can compare. We don&amp;rsquo;t need to bring &lt;code&gt;PartialOrd&lt;/code&gt; into scope because it&amp;rsquo;s in the prelude. Change the signature of &lt;code&gt;largest&lt;/code&gt; to look like this:</source>
          <target state="translated">&lt;code&gt;largest&lt;/code&gt; 본문 에서보다 큼 ( &lt;code&gt;&amp;gt;&lt;/code&gt; ) 연산자를 사용하여 &lt;code&gt;T&lt;/code&gt; 유형의 두 값을 비교하려고했습니다 . 이 연산자는 표준 라이브러리 특성 &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; 에서 기본 메소드로 정의 되므로 &lt;code&gt;T&lt;/code&gt; 의 특성 경계에 &lt;code&gt;PartialOrd&lt;/code&gt; 를 지정해야 &lt;code&gt;largest&lt;/code&gt; 함수가 비교할 수있는 모든 유형의 슬라이스에서 작동 할 수 있습니다. &lt;code&gt;PartialOrd&lt;/code&gt; 가 서곡에 포함되어 있으므로 범위 내로 가져올 필요가 없습니다 . &lt;code&gt;largest&lt;/code&gt; 서명 을 다음과 같이 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="9eeb876353faccbcba2ce19feeb7d0dafe4faead" translate="yes" xml:space="preserve">
          <source>In the body of &lt;code&gt;shoes_in_my_size&lt;/code&gt;, we call &lt;code&gt;into_iter&lt;/code&gt; to create an iterator that takes ownership of the vector. Then we call &lt;code&gt;filter&lt;/code&gt; to adapt that iterator into a new iterator that only contains elements for which the closure returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">본문에 &lt;code&gt;shoes_in_my_size&lt;/code&gt; , 우리는 전화 &lt;code&gt;into_iter&lt;/code&gt; 벡터의 소유권을 반복자를 만들 수 있습니다. 그런 다음 &lt;code&gt;filter&lt;/code&gt; 를 호출 하여 해당 반복자를 클로저가 &lt;code&gt;true&lt;/code&gt; 를 반환하는 요소 만 포함하는 새 반복기에 적용 합니다 .</target>
        </trans-unit>
        <trans-unit id="ccc28c109f469220d7a0f86ba3d92af7a489d690" translate="yes" xml:space="preserve">
          <source>In the body of a generic function, methods from &lt;code&gt;Trait&lt;/code&gt; can be called on &lt;code&gt;Ty&lt;/code&gt; values. Likewise associated constants on the &lt;code&gt;Trait&lt;/code&gt; can be used.</source>
          <target state="translated">일반 함수의 본문에서 &lt;code&gt;Trait&lt;/code&gt; 의 메소드는 &lt;code&gt;Ty&lt;/code&gt; 값에서 호출 될 수 있습니다 . 마찬가지로 &lt;code&gt;Trait&lt;/code&gt; 의 관련 상수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed9b56a6d3a5e9ebb3e76d9359071c31eee0aecc" translate="yes" xml:space="preserve">
          <source>In the case a &lt;code&gt;loop&lt;/code&gt; has an associated &lt;code&gt;break&lt;/code&gt;, it is not considered diverging, and the &lt;code&gt;loop&lt;/code&gt; must have a type compatible with each &lt;code&gt;break&lt;/code&gt; expression. &lt;code&gt;break&lt;/code&gt; without an expression is considered identical to &lt;code&gt;break&lt;/code&gt; with expression &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 에 연관된 &lt;code&gt;break&lt;/code&gt; 가있는 경우 분기되는 것으로 간주되지 않으며 &lt;code&gt;loop&lt;/code&gt; 는 각 &lt;code&gt;break&lt;/code&gt; 표현식 과 호환되는 유형이어야합니다 . &lt;code&gt;break&lt;/code&gt; 발현없이가 동일 간주 &lt;code&gt;break&lt;/code&gt; 식 &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e9ac885fce76186450b96a37f179bf757255fd6" translate="yes" xml:space="preserve">
          <source>In the case of a &lt;a href=&quot;expressions/block-expr&quot;&gt;block expression&lt;/a&gt;, the scope for the block and the expression are the same scope.</source>
          <target state="translated">&lt;a href=&quot;expressions/block-expr&quot;&gt;블록 표현식&lt;/a&gt; 의 경우 블록과 표현식의 범위는 동일한 범위입니다.</target>
        </trans-unit>
        <trans-unit id="57fe262eb9d9754ab04dac149861a78ef7f9cbdf" translate="yes" xml:space="preserve">
          <source>In the case of a string literal, we know the contents at compile time, so the text is hardcoded directly into the final executable. This is why string literals are fast and efficient. But these properties only come from the string literal&amp;rsquo;s immutability. Unfortunately, we can&amp;rsquo;t put a blob of memory into the binary for each piece of text whose size is unknown at compile time and whose size might change while running the program.</source>
          <target state="translated">문자열 리터럴의 경우 컴파일 타임에 내용을 알고 있으므로 텍스트는 최종 실행 파일에 직접 하드 코딩됩니다. 이것이 문자열 리터럴이 빠르고 효율적인 이유입니다. 그러나 이러한 속성은 문자열 리터럴의 불변성에서만 발생합니다. 불행히도 컴파일 타임에 크기를 알 수없고 프로그램을 실행하는 동안 크기가 변할 수있는 각 텍스트 조각에 대해 바이너리 메모리에 메모리를 넣을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="174ee51902d80b0fa89335cd9be3f224ff39dd4c" translate="yes" xml:space="preserve">
          <source>In the case of implicitly-wrapped overflow, implementations must provide well-defined (even if still considered erroneous) results by using two's complement overflow conventions.</source>
          <target state="translated">내재적으로 랩핑 된 오버 플로우의 경우, 구현은 2의 보수 오버 플로우 규칙을 사용하여 잘 정의 된 (아직 잘못된 것으로 간주 되더라도) 결과를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="ad072c8ebb70bdab55dbb950bf9d58e7b04bb9e3" translate="yes" xml:space="preserve">
          <source>In the case where &lt;code&gt;File::open&lt;/code&gt; succeeds, the value in the variable &lt;code&gt;f&lt;/code&gt; will be an instance of &lt;code&gt;Ok&lt;/code&gt; that contains a file handle. In the case where it fails, the value in &lt;code&gt;f&lt;/code&gt; will be an instance of &lt;code&gt;Err&lt;/code&gt; that contains more information about the kind of error that happened.</source>
          <target state="translated">경우 &lt;code&gt;File::open&lt;/code&gt; 성공의 변수의 값 &lt;code&gt;f&lt;/code&gt; 의 인스턴스가 될 것입니다 &lt;code&gt;Ok&lt;/code&gt; 파일 핸들이 포함되어 있습니다. 실패한 경우 &lt;code&gt;f&lt;/code&gt; 의 값 은 발생한 오류 종류에 대한 자세한 정보가 포함 된 &lt;code&gt;Err&lt;/code&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="98ff22c3c9a8db90c4e7212603caadebf4d948d5" translate="yes" xml:space="preserve">
          <source>In the code above, the function is returning data borrowed from either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;, but the &lt;code&gt;'a&lt;/code&gt; annotation indicates that it is returning data only from &lt;code&gt;x&lt;/code&gt;. To fix the error, the signature and the body must be made to match. Typically, this is done by updating the function signature. So, in this case, we change the type of &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;&amp;amp;'a i32&lt;/code&gt;, like so:</source>
          <target state="translated">위의 코드에서 함수는 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 에서 빌린 데이터를 반환 하지만 &lt;code&gt;'a&lt;/code&gt; 주석은 &lt;code&gt;x&lt;/code&gt; 에서만 데이터를 반환한다는 것을 나타냅니다 . 오류를 해결하려면 서명과 본문이 일치해야합니다. 일반적으로 이것은 기능 서명을 업데이트하여 수행됩니다. 따라서이 경우에는 다음과 같이 &lt;code&gt;y&lt;/code&gt; 유형 을 &lt;code&gt;&amp;amp;'a i32&lt;/code&gt; 로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="47d276ce9763d36114b6391e5e3702972a6d1fd2" translate="yes" xml:space="preserve">
          <source>In the context of Listing 9-7, the &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;File::open&lt;/code&gt; call will return the value inside an &lt;code&gt;Ok&lt;/code&gt; to the variable &lt;code&gt;f&lt;/code&gt;. If an error occurs, the &lt;code&gt;?&lt;/code&gt; operator will return early out of the whole function and give any &lt;code&gt;Err&lt;/code&gt; value to the calling code. The same thing applies to the &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;read_to_string&lt;/code&gt; call.</source>
          <target state="translated">목록 9-7과 관련하여 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;File::open&lt;/code&gt; 호출 의 끝 에서 &lt;code&gt;Ok&lt;/code&gt; 안의 값 을 변수 &lt;code&gt;f&lt;/code&gt; 로 반환합니다 . 오류가 발생하면 &lt;code&gt;?&lt;/code&gt; 연산자는 전체 함수에서 일찍 반환 하고 호출 코드에 &lt;code&gt;Err&lt;/code&gt; 값을 제공합니다 . 같은 것이 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;read_to_string&lt;/code&gt; 호출 끝에 .</target>
        </trans-unit>
        <trans-unit id="c49979de4803e07d7682a6dac88ad65cf9bdcef3" translate="yes" xml:space="preserve">
          <source>In the end, this means that you may need to pair &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; with some sort of &lt;a href=&quot;index&quot;&gt;&lt;code&gt;std::sync&lt;/code&gt;&lt;/a&gt; type, usually &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결국, 이것은 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 를 &lt;a href=&quot;index&quot;&gt; &lt;code&gt;std::sync&lt;/code&gt; &lt;/a&gt; 유형, 일반적으로 &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 와 쌍으로 묶어야 할 수도 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="5a1b716ed41677dd2be556cd6b10193bd9fd8fb5" translate="yes" xml:space="preserve">
          <source>In the erroneous code example above, the wrong name was provided, so changing to a correct one it will fix the error. Example:</source>
          <target state="translated">위의 잘못된 코드 예제에서 잘못된 이름이 제공되었으므로 올바른 이름으로 변경하면 오류가 해결됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="a13ba9220a713242d839758de54b6d6a213f5d7c" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;closure&lt;/code&gt; is an &lt;code&gt;FnOnce&lt;/code&gt; closure whereas the &lt;code&gt;bar&lt;/code&gt; function expected an &lt;code&gt;Fn&lt;/code&gt; closure. In this case, it's simple to fix the issue, you just have to implement &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Clone&lt;/code&gt; traits on &lt;code&gt;struct X&lt;/code&gt; and it'll be ok:</source>
          <target state="translated">위의 예에서 &lt;code&gt;closure&lt;/code&gt; 는 &lt;code&gt;FnOnce&lt;/code&gt; 클로저 인 반면 &lt;code&gt;bar&lt;/code&gt; 함수는 &lt;code&gt;Fn&lt;/code&gt; 클로저를 예상했습니다 . 이 경우 문제를 해결하는 것이 간단합니다 &lt;code&gt;struct X&lt;/code&gt; 에서 &lt;code&gt;Copy&lt;/code&gt; 및 &lt;code&gt;Clone&lt;/code&gt; 특성 을 구현 하면 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="c4e63cece27f012d6cb0c3b410a4800e38cdde84" translate="yes" xml:space="preserve">
          <source>In the example below, we implement a &lt;code&gt;Point&lt;/code&gt; type. Because it only stores two integers, we opt-out of ownership semantics with &lt;code&gt;Copy&lt;/code&gt;. Then we can &lt;code&gt;let p2 = p1&lt;/code&gt; without &lt;code&gt;p1&lt;/code&gt; being moved.</source>
          <target state="translated">아래 예제에서 &lt;code&gt;Point&lt;/code&gt; 유형을 구현합니다 . 두 개의 정수만 저장하기 때문에 우리는 &lt;code&gt;Copy&lt;/code&gt; 의 소유권 의미를 옵트 아웃 합니다. 그런 다음 &lt;code&gt;p1&lt;/code&gt; 을 이동 하지 않고 &lt;code&gt;let p2 = p1&lt;/code&gt; 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1f21adbe43e342921b2cfef575b2b17bbbed822" translate="yes" xml:space="preserve">
          <source>In the example, the type cannot have a well-defined size, because it needs to be arbitrarily large (since we would be able to nest &lt;code&gt;ListNode&lt;/code&gt;s to any depth). Specifically,</source>
          <target state="translated">이 예제에서 유형은 크기를 잘 정의 할 수 없습니다. 왜냐하면 임의적으로 커야하기 때문입니다 ( &lt;code&gt;ListNode&lt;/code&gt; 를 모든 깊이 에 중첩 할 수 있기 때문입니다 ). 구체적으로 특별히,</target>
        </trans-unit>
        <trans-unit id="dce7e71b1b63c6637f941a4911789744e653ecbd" translate="yes" xml:space="preserve">
          <source>In the first case, the output lifetime is inferred to be the same as the unique input lifetime. In the second case, the lifetime is instead inferred to be the same as the lifetime on &lt;code&gt;&amp;amp;self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">첫 번째 경우, 출력 수명은 고유 한 입력 수명과 동일한 것으로 추론됩니다. 두 번째 경우, 수명은 &lt;code&gt;&amp;amp;self&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 의 수명과 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="3fd5720ef4de3e0fbc4e279820c08cbec7f12fa8" translate="yes" xml:space="preserve">
          <source>In the first code example, the compiler cannot infer what the type of &lt;code&gt;x&lt;/code&gt; should be: &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are both suitable candidates. To specify which type to use, you can use a type annotation on &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">첫 번째 코드 예제에서 컴파일러는 &lt;code&gt;x&lt;/code&gt; 의 유형이 무엇인지 추론 할 수 없습니다 . &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; 및 &lt;code&gt;String&lt;/code&gt; 은 모두 적합한 후보입니다. 사용할 유형을 지정하려면 &lt;code&gt;x&lt;/code&gt; 에 유형 주석을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="874b3aefadd7a8d78fd78ecf2f3f7b20564e4f86" translate="yes" xml:space="preserve">
          <source>In the first example, the lowercased string is represented &lt;code&gt;&quot;cafe\u{301}&quot;&lt;/code&gt; (the last character is an acute accent &lt;a href=&quot;https://en.wikipedia.org/wiki/Combining_character&quot;&gt;combining character&lt;/a&gt;). Unlike the other characters in the string, the combining character will not get mapped to an uppercase variant, resulting in &lt;code&gt;&quot;CAFE\u{301}&quot;&lt;/code&gt;. In the second example, the lowercased string is represented &lt;code&gt;&quot;caf\u{e9}&quot;&lt;/code&gt; (the last character is a single Unicode character representing an 'e' with an acute accent). Since the last character is defined outside the scope of ASCII, it will not get mapped to an uppercase variant, resulting in &lt;code&gt;&quot;CAF\u{e9}&quot;&lt;/code&gt;.</source>
          <target state="translated">첫 번째 예에서 소문자 문자열은 &lt;code&gt;&quot;cafe\u{301}&quot;&lt;/code&gt; (마지막 문자는 급성 악센트 &lt;a href=&quot;https://en.wikipedia.org/wiki/Combining_character&quot;&gt;조합 문자&lt;/a&gt; ). 문자열의 다른 문자와 달리 결합 문자는 대문자 변형으로 매핑되지 않으므로 &lt;code&gt;&quot;CAFE\u{301}&quot;&lt;/code&gt; 합니다. 두 번째 예에서 소문자 문자열은 &lt;code&gt;&quot;caf\u{e9}&quot;&lt;/code&gt; (마지막 문자는 'e'를 강조하는 단일 유니 코드 문자입니다). 마지막 문자는 ASCII 범위 밖에서 정의되므로 대문자 변형에 매핑되지 않으므로 &lt;code&gt;&quot;CAF\u{e9}&quot;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7e492b1a4744d12effe76c9a0dc29e53bf345ccf" translate="yes" xml:space="preserve">
          <source>In the first match expression, the value is copied (or moved). In the second match, a reference to the same memory location is bound to the variable value. This syntax is needed because in destructuring subpatterns the &lt;code&gt;&amp;amp;&lt;/code&gt; operator can't be applied to the value's fields. For example, the following is not valid:</source>
          <target state="translated">첫 번째 일치 표현식에서 값이 복사 (또는 이동)됩니다. 두 번째 일치에서는 동일한 메모리 위치에 대한 참조가 변수 값에 바인딩됩니다. 하위 패턴을 파괴 할 때 &lt;code&gt;&amp;amp;&lt;/code&gt; 연산자를 값 필드에 적용 할 수 없으므로이 구문이 필요 합니다. 예를 들어 다음은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="963b4be1c96ed23abf1f14a5ca37f0831c8c64ef" translate="yes" xml:space="preserve">
          <source>In the following example, we make the &lt;code&gt;call_from_c&lt;/code&gt; function accessible from C code, after it&amp;rsquo;s compiled to a shared library and linked from C:</source>
          <target state="translated">다음 예제에서는 &lt;code&gt;call_from_c&lt;/code&gt; 함수를 공유 라이브러리로 컴파일하고 C에서 링크 한 후 C 코드에서 액세스 할 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="ab9b978885ac92b130a921c64c6e0cb297ec938c" translate="yes" xml:space="preserve">
          <source>In the general case, collecting into &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt; is done by first collecting into a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. That is, when writing the following:</source>
          <target state="translated">일반적으로 &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt; 로의 수집은 먼저 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 로 수집하여 수행됩니다 . 즉, 다음을 작성할 때 :</target>
        </trans-unit>
        <trans-unit id="068c8963b2ca078d181d2b0a51e8af10dd52ecbb" translate="yes" xml:space="preserve">
          <source>In the general case, collecting into &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt; is done by first collecting into a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. That is, when writing the following:</source>
          <target state="translated">일반적으로 &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt; 로의 수집은 먼저 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 로 수집하여 수행됩니다 . 즉, 다음을 작성할 때 :</target>
        </trans-unit>
        <trans-unit id="acbd16055f21eb6fdaf455bf26541bd9198ef8ac" translate="yes" xml:space="preserve">
          <source>In the implementation of &lt;code&gt;outline_print&lt;/code&gt;, we want to use the &lt;code&gt;Display&lt;/code&gt; trait&amp;rsquo;s functionality. Therefore, we need to specify that the &lt;code&gt;OutlinePrint&lt;/code&gt; trait will work only for types that also implement &lt;code&gt;Display&lt;/code&gt; and provide the functionality that &lt;code&gt;OutlinePrint&lt;/code&gt; needs. We can do that in the trait definition by specifying &lt;code&gt;OutlinePrint: Display&lt;/code&gt;. This technique is similar to adding a trait bound to the trait. Listing 19-22 shows an implementation of the &lt;code&gt;OutlinePrint&lt;/code&gt; trait.</source>
          <target state="translated">&lt;code&gt;outline_print&lt;/code&gt; 의 구현 에서 &lt;code&gt;Display&lt;/code&gt; 특성의 기능 을 사용하려고 합니다. 따라서 &lt;code&gt;OutlinePrint&lt;/code&gt; 특성이 &lt;code&gt;Display&lt;/code&gt; 를 구현 하고 &lt;code&gt;OutlinePrint&lt;/code&gt; 에 필요한 기능을 제공하는 유형에 대해서만 작동 하도록 지정 해야합니다. 특성 정의에서 &lt;code&gt;OutlinePrint: Display&lt;/code&gt; 를 지정하여 이를 수행 할 수 있습니다 . 이 기법은 특성에 바인딩 된 특성을 추가하는 것과 유사합니다. Listing 19-22는 &lt;code&gt;OutlinePrint&lt;/code&gt; 특성 의 구현을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="81a422714f2fa87b38ce332890d1f64c8678f1a7" translate="yes" xml:space="preserve">
          <source>In the last arm, where we&amp;rsquo;ve specified a variable without a range, we do have the value available to use in the arm&amp;rsquo;s code in a variable named &lt;code&gt;id&lt;/code&gt;. The reason is that we&amp;rsquo;ve used the struct field shorthand syntax. But we haven&amp;rsquo;t applied any test to the value in the &lt;code&gt;id&lt;/code&gt; field in this arm, as we did with the first two arms: any value would match this pattern.</source>
          <target state="translated">범위없이 변수를 지정한 마지막 팔에서 팔의 코드에서 &lt;code&gt;id&lt;/code&gt; 라는 변수에 사용할 수있는 값이 있습니다 . 그 이유는 구조체 필드 속기 구문을 사용했기 때문입니다. 그러나 처음 두 팔과 마찬가지로이 팔 의 &lt;code&gt;id&lt;/code&gt; 필드 값에 대한 테스트를 적용하지 않았습니다 . 모든 값이이 패턴과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8a42fbeac9d5cd28add8db6a4c34d47e67684d80" translate="yes" xml:space="preserve">
          <source>In the main thread, we collect all the join handles. Then, as we did in Listing 16-2, we call &lt;code&gt;join&lt;/code&gt; on each handle to make sure all the threads finish. At that point, the main thread will acquire the lock and print the result of this program.</source>
          <target state="translated">메인 스레드에서 모든 조인 핸들을 수집합니다. 그런 다음 Listing 16-2에서와 같이 각 핸들에서 &lt;code&gt;join&lt;/code&gt; 을 호출 하여 모든 스레드가 완료되도록합니다. 이 시점에서 메인 스레드는 잠금을 획득하고이 프로그램의 결과를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="04da7f268aa71a2c6ae0063d0f79d0cc060f8123" translate="yes" xml:space="preserve">
          <source>In the main thread, we&amp;rsquo;re not calling the &lt;code&gt;recv&lt;/code&gt; function explicitly anymore: instead, we&amp;rsquo;re treating &lt;code&gt;rx&lt;/code&gt; as an iterator. For each value received, we&amp;rsquo;re printing it. When the channel is closed, iteration will end.</source>
          <target state="translated">메인 스레드에서는 더 이상 &lt;code&gt;recv&lt;/code&gt; 함수를 명시 적으로 호출하지 않습니다. 대신 &lt;code&gt;rx&lt;/code&gt; 를 반복자로 취급 합니다. 받은 각 값에 대해 인쇄하고 있습니다. 채널이 닫히면 반복이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="6a6bd022f18026c156e26cea87623c8cec496bfa" translate="yes" xml:space="preserve">
          <source>In the majority of cases, ownership is clear: you know exactly which variable owns a given value. However, there are cases when a single value might have multiple owners. For example, in graph data structures, multiple edges might point to the same node, and that node is conceptually owned by all of the edges that point to it. A node shouldn&amp;rsquo;t be cleaned up unless it doesn&amp;rsquo;t have any edges pointing to it.</source>
          <target state="translated">대부분의 경우 소유권은 분명합니다. 주어진 값을 소유 한 변수를 정확히 알고 있습니다. 그러나 단일 값에 여러 소유자가있을 수 있습니다. 예를 들어, 그래프 데이터 구조에서 여러 모서리는 동일한 노드를 가리키고 해당 노드는 해당 노드를 가리키는 모든 모서리가 개념적으로 소유합니다. 가장자리를 가리 키지 않는 한 노드를 정리해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b4fe9ca25f444c9952c260922e7715e70a50aab9" translate="yes" xml:space="preserve">
          <source>In the match expression for this code, we add a variable called &lt;code&gt;state&lt;/code&gt; to the pattern that matches values of the variant &lt;code&gt;Coin::Quarter&lt;/code&gt;. When a &lt;code&gt;Coin::Quarter&lt;/code&gt; matches, the &lt;code&gt;state&lt;/code&gt; variable will bind to the value of that quarter&amp;rsquo;s state. Then we can use &lt;code&gt;state&lt;/code&gt; in the code for that arm, like so:</source>
          <target state="translated">이 코드의 일치 표현식에서 다음과 같은 변수를 추가합니다 &lt;code&gt;state&lt;/code&gt; 변형 &lt;code&gt;Coin::Quarter&lt;/code&gt; 값과 일치하는 패턴에 . 때 &lt;code&gt;Coin::Quarter&lt;/code&gt; 경기는 &lt;code&gt;state&lt;/code&gt; 변수는 해당 분기의 상태의 값에 바인딩됩니다. 그런 다음 해당 팔의 코드에서 &lt;code&gt;state&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37676c5799bfd02feed7afe648d55c20c391e411" translate="yes" xml:space="preserve">
          <source>In the matcher, &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;&lt;code&gt;:&lt;/code&gt;&lt;em&gt;fragment-specifier&lt;/em&gt; matches a Rust syntax fragment of the kind specified and binds it to the metavariable &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;. Valid fragment specifiers are:</source>
          <target state="translated">매처에서 &lt;code&gt;$&lt;/code&gt; &lt;em&gt; name &lt;/em&gt; &lt;code&gt;:&lt;/code&gt; &lt;em&gt;fragment-specifier&lt;/em&gt; 는 지정된 종류의 Rust 구문 조각과 일치하여 메타 변수 &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name에&lt;/em&gt; 바인딩합니다 . 유효한 조각 지정자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="963b3e8473b4ab06c6410ca4e20e74e946590848" translate="yes" xml:space="preserve">
          <source>In the next chapter, we&amp;rsquo;ll look at some collection data structures in the standard library that you can use in your neatly organized code.</source>
          <target state="translated">다음 장에서는 깔끔하게 정리 된 코드에서 사용할 수있는 표준 라이브러리의 컬렉션 데이터 구조를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="62f755e3daa908e0af290719bd4bb3bcad378eef" translate="yes" xml:space="preserve">
          <source>In the output in Listing 9-2, line 12 of the backtrace points to the line in our project that&amp;rsquo;s causing the problem: line 4 of &lt;em&gt;src/main.rs&lt;/em&gt;. If we don&amp;rsquo;t want our program to panic, the location pointed to by the first line mentioning a file we wrote is where we should start investigating. In Listing 9-1, where we deliberately wrote code that would panic in order to demonstrate how to use backtraces, the way to fix the panic is to not request an element at index 99 from a vector that only contains 3 items. When your code panics in the future, you&amp;rsquo;ll need to figure out what action the code is taking with what values to cause the panic and what the code should do instead.</source>
          <target state="translated">Listing 9-2의 출력에서, 역 추적의 12 번째 줄은 프로젝트에서 &lt;em&gt;src / main.rs의&lt;/em&gt; 4 번째 줄을 &lt;em&gt;가리킨다&lt;/em&gt; . 프로그램이 패닉 상태에 빠지지 않게하려면 첫 번째 줄이 가리키는 파일이 언급 된 위치는 조사를 시작해야하는 위치입니다. 역 추적을 사용하는 방법을 보여주기 위해 공황에 빠질 코드를 작성했던 Listing 9-1에서 공황을 수정하는 방법은 3 개의 항목 만 포함하는 벡터에서 인덱스 99의 요소를 요청하지 않는 것입니다. 미래에 코드 패닉이 발생하면 패닉을 유발하는 값으로 코드가 수행하는 작업과 대신 코드가 수행해야 할 작업을 파악해야합니다.</target>
        </trans-unit>
        <trans-unit id="c97b14b94a5006f9b4ef147bf12f463db5d6141e" translate="yes" xml:space="preserve">
          <source>In the output in Listing 9-2, line 17 of the backtrace points to the line in our project that&amp;rsquo;s causing the problem: line 4 of &lt;em&gt;src/main.rs&lt;/em&gt;. If we don&amp;rsquo;t want our program to panic, the location pointed to by the first line mentioning a file we wrote is where we should start investigating. In Listing 9-1, where we deliberately wrote code that would panic in order to demonstrate how to use backtraces, the way to fix the panic is to not request an element at index 99 from a vector that only contains 3 items. When your code panics in the future, you&amp;rsquo;ll need to figure out what action the code is taking with what values to cause the panic and what the code should do instead.</source>
          <target state="translated">Listing 9-2의 출력에서 ​​역 추적의 17 행은 문제를 일으키는 프로젝트의 라인 ( &lt;em&gt;src / main.rs의&lt;/em&gt; 4 행)을 &lt;em&gt;가리 킵니다&lt;/em&gt; . 프로그램이 당황하지 않도록하려면, 우리가 작성한 파일을 언급하는 첫 번째 줄이 가리키는 위치를 조사를 시작해야합니다. 역 추적을 사용하는 방법을 보여주기 위해 의도적으로 패닉되는 코드를 작성한 목록 9-1에서 패닉을 수정하는 방법은 3 개 항목 만 포함 된 벡터에서 인덱스 99의 요소를 요청하지 않는 것입니다. 나중에 코드가 패닉 상태가되면 코드가 어떤 값을 사용하여 패닉을 유발하고 코드가 대신 수행해야하는 작업을 파악해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff1955a5e30929ce37102fab2f4935897b292825" translate="yes" xml:space="preserve">
          <source>In the previous section, we looked at how the &lt;code&gt;IpAddr&lt;/code&gt; enum let us use Rust&amp;rsquo;s type system to encode more information than just the data into our program. This section explores a case study of &lt;code&gt;Option&lt;/code&gt;, which is another enum defined by the standard library. The &lt;code&gt;Option&lt;/code&gt; type is used in many places because it encodes the very common scenario in which a value could be something or it could be nothing. Expressing this concept in terms of the type system means the compiler can check whether you&amp;rsquo;ve handled all the cases you should be handling; this functionality can prevent bugs that are extremely common in other programming languages.</source>
          <target state="translated">이전 섹션에서 우리는 &lt;code&gt;IpAddr&lt;/code&gt; 열거 형을 사용하여 Rust의 유형 시스템을 사용하여 데이터를 프로그램에 더 많은 정보로 인코딩 . 이 섹션에서는 표준 라이브러리에 의해 정의 된 또 다른 열거 형인 &lt;code&gt;Option&lt;/code&gt; 에 대한 사례 연구를 살펴 봅니다. &lt;code&gt;Option&lt;/code&gt; 은 값이 뭔가 할 수있는 매우 일반적인 시나리오를 암호화하거나 아무 것도 없을 수 있기 때문에 유형은 여러 곳에서 사용된다. 타입 시스템 측면에서이 개념을 표현한다는 것은 컴파일러가 처리해야 할 모든 경우를 처리했는지 여부를 확인할 수 있다는 의미입니다. 이 기능은 다른 프로그래밍 언어에서 매우 일반적인 버그를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7166e371e82ca092dfca006916f5e7d27ed3dcc0" translate="yes" xml:space="preserve">
          <source>In the previous section, we wanted to get the inner &lt;code&gt;T&lt;/code&gt; value out of the &lt;code&gt;Some&lt;/code&gt; case when using &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;; we can also handle &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; using &lt;code&gt;match&lt;/code&gt; as we did with the &lt;code&gt;Coin&lt;/code&gt; enum! Instead of comparing coins, we&amp;rsquo;ll compare the variants of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, but the way that the &lt;code&gt;match&lt;/code&gt; expression works remains the same.</source>
          <target state="translated">이전 섹션에서는 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 사용할 때 &lt;code&gt;Some&lt;/code&gt; 경우 에서 내부 &lt;code&gt;T&lt;/code&gt; 값 을 가져오고 싶었습니다 . &lt;code&gt;Coin&lt;/code&gt; 했던 것처럼 &lt;code&gt;match&lt;/code&gt; 를 사용하여 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 를 처리 할 수도 있습니다 열거 형에서 ! 코인을 비교하는 대신 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 의 변형을 비교 하지만 &lt;code&gt;match&lt;/code&gt; 표현식의 작동 방식은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="021531d5da5d15cfe5b7187998d391941c64c620" translate="yes" xml:space="preserve">
          <source>In the relative path, the logic is the same as the absolute path except for the first step: rather than starting from the crate root, the path starts from &lt;code&gt;front_of_house&lt;/code&gt;. The &lt;code&gt;front_of_house&lt;/code&gt; module is defined within the same module as &lt;code&gt;eat_at_restaurant&lt;/code&gt;, so the relative path starting from the module in which &lt;code&gt;eat_at_restaurant&lt;/code&gt; is defined works. Then, because &lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;add_to_waitlist&lt;/code&gt; are marked with &lt;code&gt;pub&lt;/code&gt;, the rest of the path works, and this function call is valid!</source>
          <target state="translated">상대 경로에서 논리는 첫 번째 단계를 제외하고 절대 경로와 동일합니다. 상자 루트에서 시작하지 않고 경로는 &lt;code&gt;front_of_house&lt;/code&gt; 에서 시작합니다 . &lt;code&gt;front_of_house&lt;/code&gt; 의 모듈과 같은 모듈 내에 정의 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 상대 경로가되는 모듈에서 시작되도록 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 가 작동 정의된다. 그런 다음 &lt;code&gt;hosting&lt;/code&gt; 하고 &lt;code&gt;add_to_waitlist&lt;/code&gt; 가 &lt;code&gt;pub&lt;/code&gt; 로 표시 되므로 나머지 경로가 작동 하며이 함수 호출이 유효합니다!</target>
        </trans-unit>
        <trans-unit id="34eddaeb0b0b8fe0265b13cd54b792a68e5d0a8d" translate="yes" xml:space="preserve">
          <source>In the restaurant industry, some parts of a restaurant are referred to as &lt;em&gt;front of house&lt;/em&gt; and others as &lt;em&gt;back of house&lt;/em&gt;. Front of house is where customers are; this is where hosts seat customers, servers take orders and payment, and bartenders make drinks. Back of house is where the chefs and cooks work in the kitchen, dishwashers clean up, and managers do administrative work.</source>
          <target state="translated">식당 산업에서 식당의 일부는 &lt;em&gt; 는 집 앞&lt;/em&gt; , 다른 곳 &lt;em&gt;은 집 뒤라고&lt;/em&gt; 합니다. 집 앞은 고객이있는 곳입니다. 이곳은 주최자가 고객을 앉히고, 서버가 주문과 지불을하고, 바텐더가 음료를 만드는 곳입니다. 집 뒤는 요리사와 요리사가 주방에서 일하고 식기 세척기를 청소하며 관리자가 관리 작업을 수행하는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="d2fbd57442ab7172a121e226a86228020af2eb14" translate="yes" xml:space="preserve">
          <source>In the second &lt;code&gt;use&lt;/code&gt; statement, we chose the new name &lt;code&gt;IoResult&lt;/code&gt; for the &lt;code&gt;std::io::Result&lt;/code&gt; type, which won&amp;rsquo;t conflict with the &lt;code&gt;Result&lt;/code&gt; from &lt;code&gt;std::fmt&lt;/code&gt; that we&amp;rsquo;ve also brought into scope. Listing 7-15 and Listing 7-16 are considered idiomatic, so the choice is up to you!</source>
          <target state="translated">두 번째에서 &lt;code&gt;use&lt;/code&gt; 문, 우리는 새로운 이름을 선택 &lt;code&gt;IoResult&lt;/code&gt; 에 대한 &lt;code&gt;std::io::Result&lt;/code&gt; 에 입력하는하지 않습니다 충돌 &lt;code&gt;Result&lt;/code&gt; 은 &lt;code&gt;std::fmt&lt;/code&gt; . 리스팅 7-15와 리스팅 7-16은 관용으로 간주되므로 선택은 귀하에게 달려 있습니다!</target>
        </trans-unit>
        <trans-unit id="adc1d9d12c1d2bddf332118061c6c7cd3ce7bb85" translate="yes" xml:space="preserve">
          <source>In the second arm, where we only have a range specified in the pattern, the code associated with the arm doesn&amp;rsquo;t have a variable that contains the actual value of the &lt;code&gt;id&lt;/code&gt; field. The &lt;code&gt;id&lt;/code&gt; field&amp;rsquo;s value could have been 10, 11, or 12, but the code that goes with that pattern doesn&amp;rsquo;t know which it is. The pattern code isn&amp;rsquo;t able to use the value from the &lt;code&gt;id&lt;/code&gt; field, because we haven&amp;rsquo;t saved the &lt;code&gt;id&lt;/code&gt; value in a variable.</source>
          <target state="translated">패턴에 지정된 범위 만있는 두 번째 팔에서 팔과 관련된 코드에는 &lt;code&gt;id&lt;/code&gt; 필드 의 실제 값을 포함하는 변수가 없습니다 . &lt;code&gt;id&lt;/code&gt; 필드의 값은 10, 11, 또는 12 수 있었다,하지만 패턴으로가는 코드는 어떤 알 수 없습니다. 변수에 &lt;code&gt;id&lt;/code&gt; 값을 저장하지 않았기 때문에 패턴 코드는 &lt;code&gt;id&lt;/code&gt; 필드 의 값을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="555ee2d5bf80e581edd3155ac1632a3804b80f34" translate="yes" xml:space="preserve">
          <source>In the second case, it mentions that a private item &quot;can be accessed&quot; by the current module and its descendants, but the exact meaning of accessing an item depends on what the item is. Accessing a module, for example, would mean looking inside of it (to import more items). On the other hand, accessing a function would mean that it is invoked. Additionally, path expressions and import statements are considered to access an item in the sense that the import/expression is only valid if the destination is in the current visibility scope.</source>
          <target state="translated">두 번째 경우, 현재 모듈과 그 하위 항목에 의해 개인 항목에 액세스 할 수 있다고 언급하지만 항목에 액세스하는 정확한 의미는 항목이 무엇인지에 따라 다릅니다. 예를 들어 모듈에 액세스하면 더 많은 항목을 가져 오기 위해 내부를 살펴볼 수 있습니다. 반면에 함수에 액세스하면 함수가 호출됩니다. 또한 경로 표현식 및 가져 오기 명령문은 대상이 현재 가시성 범위에있는 경우에만 가져 오기 / 표현이 유효하다는 의미에서 항목에 액세스하는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="16e34afb2acb9f1c8b1247e4ecd62d975388d5ff" translate="yes" xml:space="preserve">
          <source>In the second error, we tried to bind the &lt;code&gt;Jak&lt;/code&gt; enum directly, which is not possible: you can only bind one of its variants. To do so:</source>
          <target state="translated">두 번째 오류에서는 &lt;code&gt;Jak&lt;/code&gt; 열거 형을 직접 바인딩하려고했지만 불가능합니다. 변형 중 하나만 바인딩 할 수 있습니다. 그렇게하려면 :</target>
        </trans-unit>
        <trans-unit id="75974ca9e444bb30cc1d72502f982a23696566b5" translate="yes" xml:space="preserve">
          <source>In the second error, you can't implement something on an item, only on types. We would need to create a new type if we wanted to do something similar:</source>
          <target state="translated">두 번째 오류에서는 항목에 무언가를 구현할 수없고 유형에만 구현할 수 있습니다. 비슷한 작업을하려면 새 유형을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="b3e1b0f0f7f1d23b0a9789a638c11ce7f83e6698" translate="yes" xml:space="preserve">
          <source>In the second you can do it by simply removing &lt;code&gt;'b&lt;/code&gt; so they both use &lt;code&gt;'a&lt;/code&gt;:</source>
          <target state="translated">두 번째에서는 단순히 &lt;code&gt;'b&lt;/code&gt; 를 제거하여 둘 다 'a &lt;code&gt;'a&lt;/code&gt; 사용하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cde08af4b5bbaaf0718281f4cc2fdcf3ef098583" translate="yes" xml:space="preserve">
          <source>In the signature for &lt;code&gt;area&lt;/code&gt;, we use &lt;code&gt;&amp;amp;self&lt;/code&gt; instead of &lt;code&gt;rectangle: &amp;amp;Rectangle&lt;/code&gt; because Rust knows the type of &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Rectangle&lt;/code&gt; due to this method&amp;rsquo;s being inside the &lt;code&gt;impl Rectangle&lt;/code&gt; context. Note that we still need to use the &lt;code&gt;&amp;amp;&lt;/code&gt; before &lt;code&gt;self&lt;/code&gt;, just as we did in &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt;. Methods can take ownership of &lt;code&gt;self&lt;/code&gt;, borrow &lt;code&gt;self&lt;/code&gt; immutably as we&amp;rsquo;ve done here, or borrow &lt;code&gt;self&lt;/code&gt; mutably, just as they can any other parameter.</source>
          <target state="translated">&lt;code&gt;area&lt;/code&gt; 의 서명에서 &lt;code&gt;rectangle: &amp;amp;Rectangle&lt;/code&gt; 대신 &lt;code&gt;&amp;amp;self&lt;/code&gt; 를 사용합니다 . Rust는 이 메소드가 &lt;code&gt;impl Rectangle&lt;/code&gt; 컨텍스트 안에 있기 때문에 &lt;code&gt;self&lt;/code&gt; 의 유형 이 &lt;code&gt;Rectangle&lt;/code&gt; 임을 알고 있기 때문에 &amp;amp; Rectangle 입니다. &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; 에서 와 마찬가지로 여전히 &lt;code&gt;self&lt;/code&gt; 앞에 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 사용해야합니다 . 방법의 소유권이 걸릴 수 있습니다 &lt;code&gt;self&lt;/code&gt; 빌려 &lt;code&gt;self&lt;/code&gt; 우리가 여기했던대로 변함 또는 차용 &lt;code&gt;self&lt;/code&gt; 단지 그들이 다른 매개 변수를 가능한 한, mutably.</target>
        </trans-unit>
        <trans-unit id="15bf74e663ebaabe244e5b40c6c296178b0d40e8" translate="yes" xml:space="preserve">
          <source>In the standard library, pointer types generally do not have structural pinning, and thus they do not offer pinning projections. This is why &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; holds for all &lt;code&gt;T&lt;/code&gt;. It makes sense to do this for pointer types, because moving the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; does not actually move the &lt;code&gt;T&lt;/code&gt;: the &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; can be freely movable (aka &lt;code&gt;Unpin&lt;/code&gt;) even if the &lt;code&gt;T&lt;/code&gt; is not. In fact, even &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; are always &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; themselves, for the same reason: their contents (the &lt;code&gt;T&lt;/code&gt;) are pinned, but the pointers themselves can be moved without moving the pinned data. For both &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, whether the content is pinned is entirely independent of whether the pointer is pinned, meaning pinning is &lt;em&gt;not&lt;/em&gt; structural.</source>
          <target state="translated">표준 라이브러리에서 포인터 유형은 일반적으로 구조적 고정이 없으므로 고정 투영을 제공하지 않습니다. 이것이 &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; 이 모든 &lt;code&gt;T&lt;/code&gt; 에 대해 유지되는 이유 입니다. 이동 때문에, 포인터 타입에 대해이 작업을 수행하는 것이 합리적 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 실제로 이동하지 않습니다 &lt;code&gt;T&lt;/code&gt; 를 다음 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; (일명 자유롭게 이동 될 수 있습니다 &lt;code&gt;Unpin&lt;/code&gt; 짝수 경우) &lt;code&gt;T&lt;/code&gt; 가 없습니다. 사실, 심지어 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 과 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; 항상 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 같은 이유로, 자신 : 그 내용합니다 ( &lt;code&gt;T&lt;/code&gt; )가 고정되어 있지만 고정 된 데이터를 이동하지 않고도 포인터 자체를 이동할 수 있습니다. 모두 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 콘텐츠가 고정되어 있는지 여부를 피닝하는 의미이고, 포인터가 고정되어 있는지 여부를 완전히 무관 &lt;em&gt;하지&lt;/em&gt; 구조체.</target>
        </trans-unit>
        <trans-unit id="b01eb539066ab2d6a68111a77de7d3391be1abdf" translate="yes" xml:space="preserve">
          <source>In the standard library, pointer types generally do not have structural pinning, and thus they do not offer pinning projections. This is why &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; holds for all &lt;code&gt;T&lt;/code&gt;. It makes sense to do this for pointer types, because moving the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; does not actually move the &lt;code&gt;T&lt;/code&gt;: the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; can be freely movable (aka &lt;code&gt;Unpin&lt;/code&gt;) even if the &lt;code&gt;T&lt;/code&gt; is not. In fact, even &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; are always &lt;code&gt;Unpin&lt;/code&gt; themselves, for the same reason: their contents (the &lt;code&gt;T&lt;/code&gt;) are pinned, but the pointers themselves can be moved without moving the pinned data. For both &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, whether the content is pinned is entirely independent of whether the pointer is pinned, meaning pinning is &lt;em&gt;not&lt;/em&gt; structural.</source>
          <target state="translated">표준 라이브러리에서 포인터 유형에는 일반적으로 구조적 고정이 없으므로 고정 돌출을 제공하지 않습니다. 이것이 &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; 이 모든 &lt;code&gt;T&lt;/code&gt; 에 대해 유지되는 이유 입니다. 이동 때문에, 포인터 타입에 대해이 작업을 수행하는 것이 합리적 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 실제로 이동하지 않습니다 &lt;code&gt;T&lt;/code&gt; 를 다음 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; (일명 자유롭게 이동 될 수 있습니다 &lt;code&gt;Unpin&lt;/code&gt; 짝수 경우) &lt;code&gt;T&lt;/code&gt; 가 없습니다. 실제로 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; 조차도 같은 이유로 항상 &lt;code&gt;Unpin&lt;/code&gt; . 내용 ( &lt;code&gt;T&lt;/code&gt; )은 고정되어 있지만 고정 된 데이터를 이동하지 않고도 포인터 자체를 이동할 수 있습니다. 모두 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 내용이 고정되어 있는지 여부를 나타내는 Box &amp;lt;T&amp;gt; 및 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 는 포인터가 고정되어 있는지 여부와 완전히 독립적이므로 고정이 구조적 &lt;em&gt;이지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="69a1bd27469eb2f59075cae2a36951b2f4c30b0e" translate="yes" xml:space="preserve">
          <source>In the test, we&amp;rsquo;re testing what happens when the &lt;code&gt;LimitTracker&lt;/code&gt; is told to set &lt;code&gt;value&lt;/code&gt; to something that is more than 75 percent of the &lt;code&gt;max&lt;/code&gt; value. First, we create a new &lt;code&gt;MockMessenger&lt;/code&gt;, which will start with an empty list of messages. Then we create a new &lt;code&gt;LimitTracker&lt;/code&gt; and give it a reference to the new &lt;code&gt;MockMessenger&lt;/code&gt; and a &lt;code&gt;max&lt;/code&gt; value of 100. We call the &lt;code&gt;set_value&lt;/code&gt; method on the &lt;code&gt;LimitTracker&lt;/code&gt; with a value of 80, which is more than 75 percent of 100. Then we assert that the list of messages that the &lt;code&gt;MockMessenger&lt;/code&gt; is keeping track of should now have one message in it.</source>
          <target state="translated">이 테스트에서는 &lt;code&gt;LimitTracker&lt;/code&gt; 가 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;max&lt;/code&gt; 값 의 75 % 이상 으로 설정하라는 메시지 가 표시 될 때 발생하는 상황을 테스트하고 있습니다. 먼저 비어있는 메시지 목록으로 시작 하는 새로운 &lt;code&gt;MockMessenger&lt;/code&gt; 를 만듭니다 . 그리고 우리는 새로운 만들 &lt;code&gt;LimitTracker&lt;/code&gt; 을 하고 그것에게 새에 대한 참조를 제공 &lt;code&gt;MockMessenger&lt;/code&gt; 과 &lt;code&gt;max&lt;/code&gt; 우리는 전화 (100)의 값 &lt;code&gt;set_value&lt;/code&gt; 온 방법 &lt;code&gt;LimitTracker&lt;/code&gt; 을 (100)의 75 % 이상이 우리가 주장 그리고 80의 값과를 메시지 목록 &lt;code&gt;MockMessenger&lt;/code&gt; 가 추적 가 하나 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="adba8ce512afb3223e0e44bbc4efd34311d66e90" translate="yes" xml:space="preserve">
          <source>In the third case, we tried to only expect one variant of the &lt;code&gt;Wizard&lt;/code&gt; enum, which is not possible. To make this work, we need to using pattern matching over the &lt;code&gt;Wizard&lt;/code&gt; enum:</source>
          <target state="translated">세 번째 경우 에는 불가능한 &lt;code&gt;Wizard&lt;/code&gt; 열거 형 의 한 가지 변형 만 예상하려고했습니다 . 이 작업을 수행하려면 &lt;code&gt;Wizard&lt;/code&gt; 열거 형에 대해 패턴 일치를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7fe4d3d8b095874ffa846390a6fba933c59176e6" translate="yes" xml:space="preserve">
          <source>In the transcriber, metavariables are referred to simply by &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;, since the fragment kind is specified in the matcher. Metavariables are replaced with the syntax element that matched them. The keyword metavariable &lt;code&gt;$crate&lt;/code&gt; can be used to refer to the current crate; see &lt;a href=&quot;#hygiene&quot;&gt;Hygiene&lt;/a&gt; below. Metavariables can be transcribed more than once or not at all.</source>
          <target state="translated">전 사기에서 metavariables는 조각 종류가 matcher에 지정되어 있으므로 &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name&lt;/em&gt; 으로 간단히 참조됩니다 . 메타 변수는 일치하는 구문 요소로 대체됩니다. 키워드 메타 변수 &lt;code&gt;$crate&lt;/code&gt; 를 사용하여 현재 상자를 참조 할 수 있습니다. 아래의 &lt;a href=&quot;#hygiene&quot;&gt;위생을&lt;/a&gt; 참조하십시오 . Metavariables는 두 번 이상 복사되거나 전혀 복사되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="474cfc53c29ed4a7f5438f6a16ce96a820777966" translate="yes" xml:space="preserve">
          <source>In the transcriber, metavariables are referred to simply by &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;, since the fragment kind is specified in the matcher. Metavariables are replaced with the syntax element that matched them. The keyword metavariable &lt;code&gt;$crate&lt;/code&gt; can be used to refer to the current crate; see &lt;a href=&quot;macros-by-example#hygiene&quot;&gt;Hygiene&lt;/a&gt; below. Metavariables can be transcribed more than once or not at all.</source>
          <target state="translated">transcriber에서 metavariables는 조각 유형이 매처에 지정되어 있기 때문에 간단히 &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name&lt;/em&gt; 으로 참조됩니다 . 메타 변수는 해당 구문 요소로 대체됩니다. 키워드 metavariable &lt;code&gt;$crate&lt;/code&gt; 를 사용하여 현재 상자를 참조 할 수 있습니다. 아래의 &lt;a href=&quot;macros-by-example#hygiene&quot;&gt;위생을&lt;/a&gt; 참조하십시오 . 메타 변수는 두 번 이상 또는 전혀 기록되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc28b1beae2c194779de6e426a53754bfb37f82e" translate="yes" xml:space="preserve">
          <source>In the workout generator example, we only used closures as inline anonymous functions. However, closures have an additional capability that functions don&amp;rsquo;t have: they can capture their environment and access variables from the scope in which they&amp;rsquo;re defined.</source>
          <target state="translated">운동 생성기 예제에서는 클로저를 인라인 익명 함수로 사용했습니다. 그러나 클로저에는 기능에없는 추가 기능이 있습니다. 즉, 환경을 캡처하고 정의 된 범위에서 변수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="402986500120f551bc8e41d90bdabaccacec9185" translate="yes" xml:space="preserve">
          <source>In the worst case, the algorithm allocates temporary storage in a &lt;code&gt;Vec&amp;lt;(K, usize)&amp;gt;&lt;/code&gt; the length of the slice.</source>
          <target state="translated">최악의 경우, 알고리즘 은 슬라이스의 길이를 &lt;code&gt;Vec&amp;lt;(K, usize)&amp;gt;&lt;/code&gt; 임시 스토리지를 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="9bc14d5532165c49508408bd484b7e97e6ac2646" translate="yes" xml:space="preserve">
          <source>In this appendix, we provide a reference of all the traits in the standard library that you can use with &lt;code&gt;derive&lt;/code&gt;. Each section covers:</source>
          <target state="translated">이 부록에서는 표준 라이브러리에서 &lt;code&gt;derive&lt;/code&gt; 하여 사용할 수있는 모든 특성에 대한 참조를 제공합니다. . 각 섹션은 다음을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="0046a6cf07943993e17ce12f3c78298391a2264f" translate="yes" xml:space="preserve">
          <source>In this appendix, we talk about some useful development tools that the Rust project provides. We&amp;rsquo;ll look at automatic formatting, quick ways to apply warning fixes, a linter, and integrating with IDEs.</source>
          <target state="translated">이 부록에서는 Rust 프로젝트가 제공하는 유용한 개발 도구에 대해 설명합니다. 자동 서식, 경고 수정을 적용하는 빠른 방법, 린터 및 IDE와의 통합에 대해 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ac9b1080783742689a97db16c3344339516e90c0" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Foo&lt;/code&gt; is undefined, so it inherently isn't anything, and definitely not a struct.</source>
          <target state="translated">이 경우 &lt;code&gt;Foo&lt;/code&gt; 는 정의되지 않았으므로 본질적으로 아무것도 아니며 구조체가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="afe608724d7fcb6b165ca3da57f4af8c6e2f8834" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Question&lt;/code&gt; would need to implement the &lt;code&gt;std::ops::Not&lt;/code&gt; trait in order to be able to use &lt;code&gt;!&lt;/code&gt; on it. Let's implement it:</source>
          <target state="translated">이 경우, &lt;code&gt;Question&lt;/code&gt; 은 &lt;code&gt;std::ops::Not&lt;/code&gt; 특성 을 구현해야 사용할 수 있습니다 &lt;code&gt;!&lt;/code&gt; 그 위에. 그것을 구현하자 :</target>
        </trans-unit>
        <trans-unit id="4b7473dc279144e44448cca5746abb04e0fa8694" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;c_double&lt;/code&gt; has the same size as &lt;code&gt;f64&lt;/code&gt; so we can use it directly:</source>
          <target state="translated">이 경우, &lt;code&gt;c_double&lt;/code&gt; 는 같은 크기가 &lt;code&gt;f64&lt;/code&gt; 우리가 직접 사용할 수 있도록를 :</target>
        </trans-unit>
        <trans-unit id="f3b4ba6190447ccb2a7d84efd7c0391f36cf1b3c" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;foo&lt;/code&gt; is defined, but is not a struct, so Rust can't use it as one.</source>
          <target state="translated">이 경우 &lt;code&gt;foo&lt;/code&gt; 가 정의되었지만 구조체가 아니므로 Rust에서이를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e3897adfb1b49645b05c0b83e391e1fc19ac894e" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;len&lt;/code&gt; will be 4, which means the vector storing the string &amp;ldquo;Hola&amp;rdquo; is 4 bytes long. Each of these letters takes 1 byte when encoded in UTF-8. But what about the following line? (Note that this string begins with the capital Cyrillic letter Ze, not the Arabic number 3.)</source>
          <target state="translated">이 경우 &lt;code&gt;len&lt;/code&gt; 은 4가되며 문자열 &quot;Hola&quot;를 저장하는 벡터의 길이는 4 바이트입니다. 이러한 문자는 UTF-8로 인코딩 될 때 1 바이트를 사용합니다. 그러나 다음 줄은 어떻습니까? (이 문자열은 아라비아 숫자 3이 아닌 대문자 키릴 문자 Ze로 시작합니다.)</target>
        </trans-unit>
        <trans-unit id="8561b972a9830d06a3e257ff13fef28acb8d1808" translate="yes" xml:space="preserve">
          <source>In this case, borrowing &lt;code&gt;x&lt;/code&gt; mutably is not possible, because &lt;code&gt;x&lt;/code&gt; is not &lt;code&gt;mut&lt;/code&gt;. But at the same time, borrowing &lt;code&gt;x&lt;/code&gt; immutably would make the assignment illegal, because a &lt;code&gt;&amp;amp; &amp;amp;mut&lt;/code&gt; reference may not be unique, so it cannot safely be used to modify a value. So a unique immutable borrow is used: it borrows &lt;code&gt;x&lt;/code&gt; immutably, but like a mutable borrow, it must be unique. In the above example, uncommenting the declaration of &lt;code&gt;y&lt;/code&gt; will produce an error because it would violate the uniqueness of the closure's borrow of &lt;code&gt;x&lt;/code&gt;; the declaration of z is valid because the closure's lifetime has expired at the end of the block, releasing the borrow.</source>
          <target state="translated">이 경우, 대출 &lt;code&gt;x&lt;/code&gt; 때문 mutably 것은 불가능 &lt;code&gt;x&lt;/code&gt; 가 아니다 &lt;code&gt;mut&lt;/code&gt; . 그러나 동시에 &lt;code&gt;x&lt;/code&gt; &lt;code&gt;&amp;amp; &amp;amp;mut&lt;/code&gt; 참조가 고유하지 않을 수 있으므로 x를 불변으로 하면 할당이 불법이 될 수 있으므로 값을 안전하게 수정하는 데 사용할 수 없습니다. 따라서 고유의 불변의 차용이 사용됩니다. &lt;code&gt;x&lt;/code&gt; 를 불변으로 차용 하지만 변경 가능한 차용과 마찬가지로 고유해야합니다. 위의 예에서, &lt;code&gt;y&lt;/code&gt; 의 선언을 주석 해제하면 &lt;code&gt;x&lt;/code&gt; 의 클로저 빌림 고유성을 위반하기 때문에 오류가 발생합니다 . z의 선언은 블록의 끝에서 클로저의 수명이 만료되어 빌려주기 때문에 유효합니다.</target>
        </trans-unit>
        <trans-unit id="bf5da830ba52c31b3f48f71542b74085fca253da" translate="yes" xml:space="preserve">
          <source>In this case, right after we create the reference cycle, the program ends. The consequences of this cycle aren&amp;rsquo;t very dire. However, if a more complex program allocated lots of memory in a cycle and held onto it for a long time, the program would use more memory than it needed and might overwhelm the system, causing it to run out of available memory.</source>
          <target state="translated">이 경우 참조 사이클을 생성 한 직후 프로그램이 종료됩니다. 이주기의 결과는 그리 심각하지 않습니다. 그러나보다 복잡한 프로그램이주기에 많은 양의 메모리를 할당하고 오랫동안 보유한 경우 프로그램은 필요한 것보다 많은 메모리를 사용하고 시스템을 압도하여 사용 가능한 메모리가 부족할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94ade146c6864efc0d837c6a05c5b82eb67849f1" translate="yes" xml:space="preserve">
          <source>In this case, the compiler cannot infer what the type of &lt;code&gt;x&lt;/code&gt; should be: &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are both suitable candidates. To specify which type to use, you can use a type annotation on &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">이 경우 컴파일러는 &lt;code&gt;x&lt;/code&gt; 의 유형을 유추 할 수 없습니다. . &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; 및 &lt;code&gt;String&lt;/code&gt; 이 모두 적합한 후보입니다. 사용할 유형을 지정하기 위해 &lt;code&gt;x&lt;/code&gt; 에 유형 주석을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f275640cc613a55c1aac0d980097965aad345a42" translate="yes" xml:space="preserve">
          <source>In this case, the line indicated is part of our code, and if we go to that line, we see the &lt;code&gt;panic!&lt;/code&gt; macro call. In other cases, the &lt;code&gt;panic!&lt;/code&gt; call might be in code that our code calls, and the filename and line number reported by the error message will be someone else&amp;rsquo;s code where the &lt;code&gt;panic!&lt;/code&gt; macro is called, not the line of our code that eventually led to the &lt;code&gt;panic!&lt;/code&gt; call. We can use the backtrace of the functions the &lt;code&gt;panic!&lt;/code&gt; call came from to figure out the part of our code that is causing the problem. We&amp;rsquo;ll discuss what a backtrace is in more detail next.</source>
          <target state="translated">이 경우 표시된 행은 코드의 일부이며 해당 행으로 이동하면 &lt;code&gt;panic!&lt;/code&gt; 이 발생합니다. 매크로 호출. 다른 경우에, &lt;code&gt;panic!&lt;/code&gt; call은 코드에서 호출하는 코드에있을 수 있으며 오류 메시지에 의해보고 된 파일 이름과 줄 번호는 &lt;code&gt;panic!&lt;/code&gt; 발생하는 다른 사람의 코드입니다 ! 매크로는 코드의 라인이 아니라 결국 &lt;code&gt;panic!&lt;/code&gt; 요구. &lt;code&gt;panic!&lt;/code&gt; 함수의 역 추적을 사용할 수 있습니다 ! 문제의 원인이되는 코드의 일부를 파악하기 위해 전화가 왔습니다. 다음에는 역 추적에 대해 자세히 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="a03c0650d25cf706ca4c711a0b4fa0c7cdd46367" translate="yes" xml:space="preserve">
          <source>In this case, you need to implement the &lt;code&gt;chocolate&lt;/code&gt; method to fix the error:</source>
          <target state="translated">이 경우 오류를 수정하려면 &lt;code&gt;chocolate&lt;/code&gt; 메서드를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8dfdeb564b13d0de24ae4a70c8a6c9f64176934b" translate="yes" xml:space="preserve">
          <source>In this chapter and throughout the book, we&amp;rsquo;ll show some commands used in the terminal. Lines that you should enter in a terminal all start with &lt;code&gt;$&lt;/code&gt;. You don&amp;rsquo;t need to type in the &lt;code&gt;$&lt;/code&gt; character; it indicates the start of each command. Lines that don&amp;rsquo;t start with &lt;code&gt;$&lt;/code&gt; typically show the output of the previous command. Additionally, PowerShell-specific examples will use &lt;code&gt;&amp;gt;&lt;/code&gt; rather than &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">이 장과 책 전체에서 터미널에서 사용되는 몇 가지 명령을 보여줍니다. 터미널에 입력해야하는 줄은 모두 &lt;code&gt;$&lt;/code&gt; 로 시작 합니다. &lt;code&gt;$&lt;/code&gt; 문자 를 입력 할 필요는 없습니다 . 각 명령의 시작을 나타냅니다. 로 시작하지 않는 줄 &lt;code&gt;$&lt;/code&gt; 로 일반적으로 이전 명령의 출력을 보여줍니다. 또한 PowerShell 관련 예제는 &lt;code&gt;$&lt;/code&gt; 대신 &lt;code&gt;&amp;gt;&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="0f1d6f9bd53aa4df418aa201b887fdd6df55aeab" translate="yes" xml:space="preserve">
          <source>In this chapter we&amp;rsquo;ll look at &lt;em&gt;enumerations&lt;/em&gt;, also referred to as &lt;em&gt;enums&lt;/em&gt;. Enums allow you to define a type by enumerating its possible &lt;em&gt;variants&lt;/em&gt;. First, we&amp;rsquo;ll define and use an enum to show how an enum can encode meaning along with data. Next, we&amp;rsquo;ll explore a particularly useful enum, called &lt;code&gt;Option&lt;/code&gt;, which expresses that a value can be either something or nothing. Then we&amp;rsquo;ll look at how pattern matching in the &lt;code&gt;match&lt;/code&gt; expression makes it easy to run different code for different values of an enum. Finally, we&amp;rsquo;ll cover how the &lt;code&gt;if let&lt;/code&gt; construct is another convenient and concise idiom available to you to handle enums in your code.</source>
          <target state="translated">이 장에서 우리는 &lt;em&gt;enums&lt;/em&gt; 라고도하는 &lt;em&gt;enumeration&lt;/em&gt; 을 살펴볼 것 입니다. 열거 형을 사용하면 가능한 &lt;em&gt;변형&lt;/em&gt; 을 열거하여 유형을 정의 할 수 있습니다 . 먼저 열거 형을 정의하고 사용하여 열거 형이 데이터와 함께 의미를 인코딩하는 방법을 보여줍니다. 다음으로, 값이 무언가가 될 수도 있고 없을 수도 있음을 나타내는 &lt;code&gt;Option&lt;/code&gt; 이라는 특히 유용한 열거 형을 살펴 보겠습니다 . 그런 다음 &lt;code&gt;match&lt;/code&gt; 표현식 에서 패턴 일치 를 사용하여 열거 형의 다른 값에 대해 다른 코드를 쉽게 실행할 수 있는 방법을 살펴 보겠습니다 . 마지막으로 &lt;code&gt;if let&lt;/code&gt; 구문이 코드에서 열거 형을 처리하는 데 사용할 수있는 또 다른 편리하고 간결한 관용구 인지 살펴 보겠습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="511940d9b79e52eebc6c566f728bbaeb0dd1dd34" translate="yes" xml:space="preserve">
          <source>In this chapter we&amp;rsquo;ll look at &lt;em&gt;enumerations&lt;/em&gt;, also referred to as &lt;em&gt;enums&lt;/em&gt;. Enums allow you to define a type by enumerating its possible values. First, we&amp;rsquo;ll define and use an enum to show how an enum can encode meaning along with data. Next, we&amp;rsquo;ll explore a particularly useful enum, called &lt;code&gt;Option&lt;/code&gt;, which expresses that a value can be either something or nothing. Then we&amp;rsquo;ll look at how pattern matching in the &lt;code&gt;match&lt;/code&gt; expression makes it easy to run different code for different values of an enum. Finally, we&amp;rsquo;ll cover how the &lt;code&gt;if let&lt;/code&gt; construct is another convenient and concise idiom available to you to handle enums in your code.</source>
          <target state="translated">이 장에서는 &lt;em&gt;enum&lt;/em&gt; 이라고도하는 &lt;em&gt;열거를&lt;/em&gt; 살펴 보겠습니다 . 열거 형을 사용하면 가능한 값을 열거하여 형식을 정의 할 수 있습니다. 먼저 열거 형을 정의하고 사용하여 열거 형이 데이터와 함께 의미를 인코딩하는 방법을 보여줍니다. 다음으로, &lt;code&gt;Option&lt;/code&gt; 이라는 특히 유용한 열거 형을 살펴 보겠습니다.이 열거 형 은 값이 무엇이든 또는 아무것도 아닐 수 있음을 나타냅니다. 그런 다음 &lt;code&gt;match&lt;/code&gt; 표현식 에서 패턴 일치 를 사용하여 열거 형의 다른 값에 대해 다른 코드를 쉽게 실행할 수 있는 방법을 살펴 보겠습니다 . 마지막으로 &lt;code&gt;if let&lt;/code&gt; 구문이 코드에서 열거 형을 처리 할 수있는 또 다른 편리하고 간결한 관용구 인 방법을 다룰 것입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="54bfe40f65e4baf089b3fdf58b27393a8784f4c8" translate="yes" xml:space="preserve">
          <source>In this chapter, we won&amp;rsquo;t debate the issue of what functional programming is or isn&amp;rsquo;t but will instead discuss some features of Rust that are similar to features in many languages often referred to as functional.</source>
          <target state="translated">이 장에서는 함수형 프로그래밍이 무엇인지에 대한 문제를 논의하지 않고, 종종 기능적이라고하는 많은 언어의 기능과 유사한 Rust의 일부 기능에 대해 논의 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="1a7486659e0b2248f370c5b62acbfa92d0246aa8" translate="yes" xml:space="preserve">
          <source>In this chapter, we&amp;rsquo;ll cover all these features, discuss how they interact, and explain how to use them to manage scope. By the end, you should have a solid understanding of the module system and be able to work with scopes like a pro!</source>
          <target state="translated">이 장에서는 이러한 모든 기능을 다루고, 기능이 상호 작용하는 방법에 대해 설명하고, 기능을 사용하여 범위를 관리하는 방법에 대해 설명합니다. 결국, 당신은 모듈 시스템에 대해 잘 이해하고 전문가와 같은 범위에서 일할 수 있어야합니다!</target>
        </trans-unit>
        <trans-unit id="323ae7b14fd96e68551f003142bf4b84170544d5" translate="yes" xml:space="preserve">
          <source>In this chapter, we&amp;rsquo;ll cover:</source>
          <target state="translated">이 장에서는 다음 내용을 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="a4639a7fb71c7cc2724cbe31da70376d99c56baa" translate="yes" xml:space="preserve">
          <source>In this code, the first and last value are matched with &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;. The &lt;code&gt;..&lt;/code&gt; will match and ignore everything in the middle.</source>
          <target state="translated">이 코드에서 첫 번째 값과 마지막 값이 &lt;code&gt;first&lt;/code&gt; 값과 일치합니다 및 &lt;code&gt;last&lt;/code&gt; 합니다. 그만큼 &lt;code&gt;..&lt;/code&gt; 일치 중간에 모든 것을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="145a83e849a55e3baebf66ad497473ddcd7f5f55" translate="yes" xml:space="preserve">
          <source>In this code, the same thing happens as in the &lt;code&gt;match&lt;/code&gt; in Listing 19-26: Rust sees that &lt;code&gt;val&lt;/code&gt; has the type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;panic!&lt;/code&gt; has the type &lt;code&gt;!&lt;/code&gt;, so the result of the overall &lt;code&gt;match&lt;/code&gt; expression is &lt;code&gt;T&lt;/code&gt;. This code works because &lt;code&gt;panic!&lt;/code&gt; doesn&amp;rsquo;t produce a value; it ends the program. In the &lt;code&gt;None&lt;/code&gt; case, we won&amp;rsquo;t be returning a value from &lt;code&gt;unwrap&lt;/code&gt;, so this code is valid.</source>
          <target state="translated">이 코드 에서 Listing 19-26 의 &lt;code&gt;match&lt;/code&gt; 에서 와 같은 일이 발생한다 . Rust는 &lt;code&gt;val&lt;/code&gt; 이 타입 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;panic!&lt;/code&gt; 가지고 있음을 본다 ! 유형이 있습니다 &lt;code&gt;!&lt;/code&gt; 전체 &lt;code&gt;match&lt;/code&gt; 표현식 의 결과 는 &lt;code&gt;T&lt;/code&gt; 입니다. 이 코드는 &lt;code&gt;panic!&lt;/code&gt; 하기 때문에 작동합니다 !가치를 창출하지 않습니다. 프로그램을 종료합니다. 에 &lt;code&gt;None&lt;/code&gt; 경우, 우리는에서 값을 반환하지 않습니다 &lt;code&gt;unwrap&lt;/code&gt; 이 코드가 유효하므로.</target>
        </trans-unit>
        <trans-unit id="844247dc89592da735fc5622f72eb35876e2a2a2" translate="yes" xml:space="preserve">
          <source>In this code, you have two ways to solve this issue:</source>
          <target state="translated">이 코드에는이 문제를 해결하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f5f63902ac52a2fdb77ae9b0aaf168362307239" translate="yes" xml:space="preserve">
          <source>In this context, by &lt;em&gt;runtime&lt;/em&gt; we mean code that is included by the language in every binary. This code can be large or small depending on the language, but every non-assembly language will have some amount of runtime code. For that reason, colloquially when people say a language has &amp;ldquo;no runtime,&amp;rdquo; they often mean &amp;ldquo;small runtime.&amp;rdquo; Smaller runtimes have fewer features but have the advantage of resulting in smaller binaries, which make it easier to combine the language with other languages in more contexts. Although many languages are okay with increasing the runtime size in exchange for more features, Rust needs to have nearly no runtime and cannot compromise on being able to call into C to maintain performance.</source>
          <target state="translated">이러한 맥락에서 &lt;em&gt; 런타임&lt;/em&gt; 이란 언어에 의해 모든 바이너리에 포함 된 코드를 의미합니다. 이 코드는 언어에 따라 크거나 작을 수 있지만 모든 비 조립 언어에는 일정량의 런타임 코드가 있습니다. 이러한 이유로 구어 적으로 사람들이 언어에 &quot;런타임 없음&quot;이 있다고 말하면 종종 &quot;작은 런타임&quot;을 의미합니다. 런타임이 작을수록 기능은 적지 만 바이너리가 작다는 장점이 있으므로 더 많은 컨텍스트에서 언어를 다른 언어와 쉽게 결합 할 수 있습니다. 더 많은 기능을 제공하기 위해 런타임 크기를 늘려서 많은 언어를 사용할 수 있지만 Rust는 런타임이 거의 필요하지 않으며 성능을 유지하기 위해 C를 호출 할 수있는 기능을 손상시킬 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3f10f5106c28699182d72488c5b199580b51f515" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;2&lt;/code&gt; is destroyed right after the assignment, which means that &lt;code&gt;ptr&lt;/code&gt; now points to an unavailable location.</source>
          <target state="translated">이 예에서 &lt;code&gt;2&lt;/code&gt; 는 할당 직후에 삭제 됩니다. 즉, &lt;code&gt;ptr&lt;/code&gt; 은 이제 사용할 수없는 위치를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="16ee00cd14e3198e4bb4ed77351c13a68c4d2964" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;BoxCar&lt;/code&gt; has two super-traits: &lt;code&gt;Vehicle&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt;. Both of these traits define an associated type &lt;code&gt;Color&lt;/code&gt;. &lt;code&gt;BoxCar&lt;/code&gt; inherits two types with that name from both super-traits. Because of this, we need to use the fully qualified path syntax to refer to the appropriate &lt;code&gt;Color&lt;/code&gt; associated type, either &lt;code&gt;&amp;lt;BoxCar as Vehicle&amp;gt;::Color&lt;/code&gt; or &lt;code&gt;&amp;lt;BoxCar as Box&amp;gt;::Color&lt;/code&gt;, but this syntax is not allowed to be used in a function signature.</source>
          <target state="translated">이 예에서 &lt;code&gt;BoxCar&lt;/code&gt; 에는 &lt;code&gt;Vehicle&lt;/code&gt; 과 &lt;code&gt;Box&lt;/code&gt; 라는 두 가지 슈퍼 특성이 있습니다. 이 두 특성 모두 연관된 유형 &lt;code&gt;Color&lt;/code&gt; 를 정의합니다 . &lt;code&gt;BoxCar&lt;/code&gt; 는 두 슈퍼 트레이 트 에서 그 이름을 가진 두 가지 유형을 상속합니다. 이 때문에 &lt;code&gt;&amp;lt;BoxCar as Vehicle&amp;gt;::Color&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;BoxCar as Box&amp;gt;::Color&lt;/code&gt; 중 적절한 &lt;code&gt;Color&lt;/code&gt; 관련 유형 을 참조하기 위해 정규화 된 경로 구문을 사용해야 하지만이 구문은 사용할 수 없습니다. 함수 서명에서.</target>
        </trans-unit>
        <trans-unit id="8e0ee0316ee57e8497270b5ce77464ecb56adca2" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Cat&lt;/code&gt; is a &lt;em&gt;struct-like enum variant&lt;/em&gt;, whereas &lt;code&gt;Dog&lt;/code&gt; is simply called an enum variant. Each enum instance has a &lt;em&gt;discriminant&lt;/em&gt; which is an integer associated to it that is used to determine which variant it holds. An opaque reference to this discriminant can be obtained with the &lt;a href=&quot;../../std/mem/fn.discriminant&quot;&gt;&lt;code&gt;mem::discriminant&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 예에서 &lt;code&gt;Cat&lt;/code&gt; 은 &lt;em&gt;구조체와 유사한 열거 형 변형&lt;/em&gt; 인 반면 &lt;code&gt;Dog&lt;/code&gt; 는 간단히 열거 형 변형이라고합니다. ENUM 각 인스턴스는 보유 &lt;em&gt;판별&lt;/em&gt; 이 보유하는 변이체를 결정하는 데 사용되는 그와 연관된 정수이다. 이 판별에 대한 불투명 한 참조는 &lt;a href=&quot;../../std/mem/fn.discriminant&quot;&gt; &lt;code&gt;mem::discriminant&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7bb9799e70052b9e454a954f47a55d73983d300f" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Foo&lt;/code&gt; defines an associated type &lt;code&gt;A&lt;/code&gt;. &lt;code&gt;Bar&lt;/code&gt; inherits that type from &lt;code&gt;Foo&lt;/code&gt;, and defines another associated type of the same name. As a result, when we attempt to use &lt;code&gt;Self::A&lt;/code&gt;, it's ambiguous whether we mean the &lt;code&gt;A&lt;/code&gt; defined by &lt;code&gt;Foo&lt;/code&gt; or the one defined by &lt;code&gt;Bar&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 &lt;code&gt;Foo&lt;/code&gt; 는 연관된 유형 &lt;code&gt;A&lt;/code&gt; 를 정의합니다 . &lt;code&gt;Bar&lt;/code&gt; 는 &lt;code&gt;Foo&lt;/code&gt; 에서 해당 유형을 상속 하고 동일한 이름의 다른 연관된 유형을 정의합니다. 결과적으로 &lt;code&gt;Self::A&lt;/code&gt; 를 사용하려고 할 때 &lt;code&gt;Foo&lt;/code&gt; 에 의해 정의 된 &lt;code&gt;A&lt;/code&gt; 를 의미하는지 또는에 의해 정의 된 것을 의미하는지는 모호합니다. &lt;code&gt;Bar&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="8cedc14f701bbdf96ac8102b9f064b1dca2f26cb" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Y&lt;/code&gt; cannot refer to &lt;code&gt;X&lt;/code&gt; here. To fix this, the value can be extracted as a const and then used:</source>
          <target state="translated">이 예에서 &lt;code&gt;Y&lt;/code&gt; 는 여기서 &lt;code&gt;X&lt;/code&gt; 를 참조 할 수 없습니다 . 이를 수정하기 위해 값을 const로 추출한 다음 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea4ed47b5eac4878ae970fa360382b182707dcb9" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;string1&lt;/code&gt; is valid until the end of the outer scope, &lt;code&gt;string2&lt;/code&gt; is valid until the end of the inner scope, and &lt;code&gt;result&lt;/code&gt; references something that is valid until the end of the inner scope. Run this code, and you&amp;rsquo;ll see that the borrow checker approves of this code; it will compile and print &lt;code&gt;The longest string is long string is long&lt;/code&gt;.</source>
          <target state="translated">이 예에서 &lt;code&gt;string1&lt;/code&gt; 은 외부 범위 가 끝날 때까지 유효 하고 &lt;code&gt;string2&lt;/code&gt; 는 내부 범위가 끝날 때까지 유효하며 &lt;code&gt;result&lt;/code&gt; 는 내부 범위가 끝날 때까지 유효한 것을 참조합니다. 이 코드를 실행하면 차용 검사기가이 코드를 승인 함을 알 수 있습니다. 그것은 컴파일하고 인쇄 할 &lt;code&gt;The longest string is long string is long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a21a4f7cf44738665bcf722c117e87d97dd2b44" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;value&lt;/code&gt; is mutably borrowed by &lt;code&gt;borrow&lt;/code&gt; and cannot be used to calculate &lt;code&gt;sum&lt;/code&gt;. This is not possible because this would violate Rust's mutability rules.</source>
          <target state="translated">이 예에서, &lt;code&gt;value&lt;/code&gt; 은 차용에 의해 변경 가능하게 &lt;code&gt;borrow&lt;/code&gt; 되며 &lt;code&gt;sum&lt;/code&gt; 계산에 사용될 수 없습니다 . 이것은 Rust의 가변성 규칙을 위반하기 때문에 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="ee5fd415a36736dbb42604438d3e115f3ef63293" translate="yes" xml:space="preserve">
          <source>In this example, if &lt;code&gt;x&lt;/code&gt; matches the pattern &lt;code&gt;(0, _)&lt;/code&gt;, the second field is set to &lt;code&gt;y&lt;/code&gt;. If it matches &lt;code&gt;(_, 0)&lt;/code&gt;, the first field is set to &lt;code&gt;y&lt;/code&gt;; so in all cases &lt;code&gt;y&lt;/code&gt; is set to some value.</source>
          <target state="translated">이 예제에서, &lt;code&gt;x&lt;/code&gt; 가 패턴 &lt;code&gt;(0, _)&lt;/code&gt; 과 일치 하면 두 번째 필드는 &lt;code&gt;y&lt;/code&gt; 로 설정됩니다 . &lt;code&gt;(_, 0)&lt;/code&gt; 과 일치 하면 첫 번째 필드는 &lt;code&gt;y&lt;/code&gt; 로 설정됩니다 . 모든 경우에 &lt;code&gt;y&lt;/code&gt; 는 어떤 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7fe9cc71a505a06c66b5d9f57153a2d3327a9165" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;'SnowWhite&lt;/code&gt; lifetime is supposed to outlive the &lt;code&gt;'kiss&lt;/code&gt; lifetime but the declaration of the &lt;code&gt;Prince&lt;/code&gt; struct doesn't enforce it. To fix this issue, you need to specify it:</source>
          <target state="translated">이 예에서 &lt;code&gt;'SnowWhite&lt;/code&gt; 수명은 &lt;code&gt;'kiss&lt;/code&gt; 수명 보다 오래 지속되지만 &lt;code&gt;Prince&lt;/code&gt; 구조체 의 선언은이를 강제하지 않습니다. 이 문제를 해결하려면 다음을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5793bd2e6d3c5293d83c901c5867d17a61fb1b7b" translate="yes" xml:space="preserve">
          <source>In this example, the closure does not satisfy the &lt;code&gt;'static&lt;/code&gt; lifetime constraint. To fix this error, you need to double check the lifetime of the type. Here, we can fix this problem by giving &lt;code&gt;s&lt;/code&gt; a static lifetime:</source>
          <target state="translated">이 예에서 클로저는 &lt;code&gt;'static&lt;/code&gt; 수명 제약 조건 '을 충족하지 않습니다 . 이 오류를 수정하려면 유형의 수명을 다시 확인해야합니다. 여기에서 &lt;code&gt;s&lt;/code&gt; 에 정적 수명 을 제공하여이 문제를 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c61f98e2cee2baaabf8be1956ffb960bd279fb24" translate="yes" xml:space="preserve">
          <source>In this example, the module &lt;code&gt;quux&lt;/code&gt; re-exports two public names defined in &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">이 예에서 모듈 &lt;code&gt;quux&lt;/code&gt; 는 &lt;code&gt;foo&lt;/code&gt; 에 정의 된 두 개의 공개 이름을 다시 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="4350bf464e116b6d57c761b20a820cb5925c37d3" translate="yes" xml:space="preserve">
          <source>In this example, the spawned thread is &quot;detached&quot; from the current thread. This means that it can outlive its parent (the thread that spawned it), unless this parent is the main thread.</source>
          <target state="translated">이 예에서, 생성 된 스레드는 현재 스레드에서 &quot;분리&quot;됩니다. 이것은이 부모가 메인 스레드가 아니라면 부모 (스폰 한 스레드)보다 오래 지속될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="adb1f627c4f5f533a368664ad1bfd6b52635fef6" translate="yes" xml:space="preserve">
          <source>In this example, the trait &lt;code&gt;Foo&lt;/code&gt; and the trait method &lt;code&gt;do_something_else&lt;/code&gt; both define a type parameter &lt;code&gt;T&lt;/code&gt;. This is not allowed: if the method wishes to define a type parameter, it must use a different name for it.</source>
          <target state="translated">이 예제에서 특성 &lt;code&gt;Foo&lt;/code&gt; 및 특성 메소드 &lt;code&gt;do_something_else&lt;/code&gt; 는 모두 유형 매개 변수 &lt;code&gt;T&lt;/code&gt; 를 정의합니다 . 메소드가 유형 매개 변수를 정의하려면 다른 이름을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5106de7dace445aa59aa82effd4989b6c9358ae0" translate="yes" xml:space="preserve">
          <source>In this example, the trait &lt;code&gt;Printable&lt;/code&gt; occurs as a trait object in both the type signature of &lt;code&gt;print&lt;/code&gt;, and the cast expression in &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">이 예에서 &lt;code&gt;Printable&lt;/code&gt; 특성은 &lt;code&gt;print&lt;/code&gt; 의 유형 서명 과 &lt;code&gt;main&lt;/code&gt; 의 캐스트 표현식 모두에서 특성 오브젝트로 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="2c7b2451157bfe66dfc5ae3bcc7df818cb052f87" translate="yes" xml:space="preserve">
          <source>In this example, the value &lt;code&gt;p&lt;/code&gt; matches the second arm by virtue of &lt;code&gt;x&lt;/code&gt; containing a 0, so this code will print &lt;code&gt;On the y axis at 7&lt;/code&gt;.</source>
          <target state="translated">이 예에서 값 &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 를 0으로 포함 하여 두 번째 팔과 일치하므로이 코드는 &lt;code&gt;On the y axis at 7&lt;/code&gt; 인쇄 합니다 .</target>
        </trans-unit>
        <trans-unit id="76e376bb135f5c25de32c031f91a381023081f30" translate="yes" xml:space="preserve">
          <source>In this example, the variable named &lt;code&gt;first&lt;/code&gt; will get the value &lt;code&gt;1&lt;/code&gt;, because that is the value at index &lt;code&gt;[0]&lt;/code&gt; in the array. The variable named &lt;code&gt;second&lt;/code&gt; will get the value &lt;code&gt;2&lt;/code&gt; from index &lt;code&gt;[1]&lt;/code&gt; in the array.</source>
          <target state="translated">이 예제에서 &lt;code&gt;first&lt;/code&gt; 라는 변수 는 값 &lt;code&gt;1&lt;/code&gt; 을 얻습니다 . 이는 배열의 인덱스 &lt;code&gt;[0]&lt;/code&gt; 에있는 값이기 때문입니다 . &lt;code&gt;second&lt;/code&gt; 라는 변수 는 배열의 인덱스 &lt;code&gt;[1]&lt;/code&gt; 에서 값 &lt;code&gt;2&lt;/code&gt; 를 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="db1c89f552fe6cd5046ff6bd0d230e80deb004f6" translate="yes" xml:space="preserve">
          <source>In this example, we are asserting that the destructor for &lt;code&gt;Foo&lt;/code&gt; will not access any data of type &lt;code&gt;X&lt;/code&gt;, and require this assertion to be true for overall safety in our program. The compiler does not currently attempt to verify this assertion; therefore we must tag this &lt;code&gt;impl&lt;/code&gt; as unsafe.</source>
          <target state="translated">이 예제에서는 &lt;code&gt;Foo&lt;/code&gt; 의 소멸자가 &lt;code&gt;X&lt;/code&gt; 유형의 데이터에 액세스하지 않으며 프로그램의 전반적인 안전을 위해이 어설 션이 참이어야한다고 주장합니다. 컴파일러는 현재이 어설 션을 확인하려고 시도하지 않습니다. 따라서이 &lt;code&gt;impl&lt;/code&gt; 을 안전하지 않은 것으로 태그 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5b639017ef60ffaf0981282e4da6c27fcdd578e1" translate="yes" xml:space="preserve">
          <source>In this example, we define a function &lt;code&gt;ten_times&lt;/code&gt; that takes a higher-order function argument, and we then call it with a closure expression as an argument, followed by a closure expression that moves values from its environment.</source>
          <target state="translated">이 예에서는 상위 함수 인수를 받는 함수 &lt;code&gt;ten_times&lt;/code&gt; 를 정의한 다음 클로저 표현식을 인수로 호출 한 다음 환경에서 값을 이동시키는 클로저 표현식을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="9be8015724a60f5a7de7fc8be3cf3fbc9130aa82" translate="yes" xml:space="preserve">
          <source>In this example, we tried to set a value with an incompatible lifetime to another one (&lt;code&gt;'long&lt;/code&gt; is unrelated to &lt;code&gt;'short&lt;/code&gt;). We can solve this issue in two different ways:</source>
          <target state="translated">이 예에서, 우리는 (또 하나 호환 수명이 값을 설정하려고 &lt;code&gt;'long&lt;/code&gt; 무관 &lt;code&gt;'short&lt;/code&gt; ). 이 문제는 두 가지 방법으로 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8385385b7c5acae88f390fa2486165f8a8931f92" translate="yes" xml:space="preserve">
          <source>In this example, we tried to use the non-existent associated type &lt;code&gt;You&lt;/code&gt; of the &lt;code&gt;Hello&lt;/code&gt; trait. To fix this error, use an existing associated type:</source>
          <target state="translated">이 예에서 우리 는 &lt;code&gt;Hello&lt;/code&gt; 특성 의 존재하지 않는 연관 유형 &lt;code&gt;You&lt;/code&gt; 를 사용하려고했습니다 . 이 오류를 수정하려면 기존 관련 유형을 사용하세요.</target>
        </trans-unit>
        <trans-unit id="0bbce52117883bf5718cfbbb01cfe64f9309a2ae" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ve specified a lifetime parameter &lt;code&gt;'a&lt;/code&gt; for the parameter &lt;code&gt;x&lt;/code&gt; and the return type, but not for the parameter &lt;code&gt;y&lt;/code&gt;, because the lifetime of &lt;code&gt;y&lt;/code&gt; does not have any relationship with the lifetime of &lt;code&gt;x&lt;/code&gt; or the return value.</source>
          <target state="translated">이 예제에서, 우리는 평생 매개 변수를 지정한 &lt;code&gt;'a&lt;/code&gt; 매개 변수에 대한 &lt;code&gt;x&lt;/code&gt; 및 반환 형식,하지만 매개 변수에 대한 &lt;code&gt;y&lt;/code&gt; 로 의 수명 때문에, &lt;code&gt;y&lt;/code&gt; 는 의 수명과 어떤 관계가없는 &lt;code&gt;x&lt;/code&gt; 또는 반환 값을.</target>
        </trans-unit>
        <trans-unit id="2185efdb59ae63a632adf24d45f191ffee2411df" translate="yes" xml:space="preserve">
          <source>In this example, when we assign the integer value 5 to &lt;code&gt;x&lt;/code&gt;, we let the compiler know that the generic type &lt;code&gt;T&lt;/code&gt; will be an integer for this instance of &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;. Then when we specify 4.0 for &lt;code&gt;y&lt;/code&gt;, which we&amp;rsquo;ve defined to have the same type as &lt;code&gt;x&lt;/code&gt;, we&amp;rsquo;ll get a type mismatch error like this:</source>
          <target state="translated">이 예제에서 정수 값 5를 &lt;code&gt;x&lt;/code&gt; 에 할당하면 컴파일러에 일반 유형 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 인스턴스에 대한 정수임을 알립니다 . 그런 다음 &lt;code&gt;x&lt;/code&gt; 와 동일한 유형을 갖도록 정의한 &lt;code&gt;y&lt;/code&gt; 에 4.0을 지정하면 다음 과 같은 유형 불일치 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="af5f4c7efbea71694085e036fb3fca287f7c1342" translate="yes" xml:space="preserve">
          <source>In this example, you can see that &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; enables mutation inside an immutable struct. In other words, it enables &quot;interior mutability&quot;.</source>
          <target state="translated">이 예제에서 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 가 불변 구조체 내부에서 돌연변이를 활성화 한다는 것을 알 수 있습니다 . 즉, &quot;내부 돌연변이&quot;를 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="28ad91d98b4c69b8725ca2927cbfaca53b3c5e8d" translate="yes" xml:space="preserve">
          <source>In this implementation, the &lt;code&gt;to_string&lt;/code&gt; method panics if the &lt;code&gt;Display&lt;/code&gt; implementation returns an error. This indicates an incorrect &lt;code&gt;Display&lt;/code&gt; implementation since &lt;code&gt;fmt::Write for String&lt;/code&gt; never returns an error itself.</source>
          <target state="translated">이 구현 에서 &lt;code&gt;Display&lt;/code&gt; 구현이 오류를 반환 하면 &lt;code&gt;to_string&lt;/code&gt; 메소드가 패닉 상태 가됩니다. &lt;code&gt;fmt::Write for String&lt;/code&gt; 은 오류 자체를 반환하지 않으므로 잘못된 &lt;code&gt;Display&lt;/code&gt; 구현을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="7cf45f5e676953372bb64ede268b0f879c84bec0" translate="yes" xml:space="preserve">
          <source>In this listing, we&amp;rsquo;ve used a method we haven&amp;rsquo;t covered before: &lt;code&gt;unwrap_or_else&lt;/code&gt;, which is defined on &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; by the standard library. Using &lt;code&gt;unwrap_or_else&lt;/code&gt; allows us to define some custom, non-&lt;code&gt;panic!&lt;/code&gt; error handling. If the &lt;code&gt;Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt; value, this method&amp;rsquo;s behavior is similar to &lt;code&gt;unwrap&lt;/code&gt;: it returns the inner value &lt;code&gt;Ok&lt;/code&gt; is wrapping. However, if the value is an &lt;code&gt;Err&lt;/code&gt; value, this method calls the code in the &lt;em&gt;closure&lt;/em&gt;, which is an anonymous function we define and pass as an argument to &lt;code&gt;unwrap_or_else&lt;/code&gt;. We&amp;rsquo;ll cover closures in more detail in &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;. For now, you just need to know that &lt;code&gt;unwrap_or_else&lt;/code&gt; will pass the inner value of the &lt;code&gt;Err&lt;/code&gt;, which in this case is the static string &lt;code&gt;not enough arguments&lt;/code&gt; that we added in Listing 12-9, to our closure in the argument &lt;code&gt;err&lt;/code&gt; that appears between the vertical pipes. The code in the closure can then use the &lt;code&gt;err&lt;/code&gt; value when it runs.</source>
          <target state="translated">이 목록에서는 이전에 다루지 않은 &lt;code&gt;unwrap_or_else&lt;/code&gt; 메소드를 사용 했는데 , 이는 표준 라이브러리에 의해 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 에 정의되어 있습니다. 사용 &lt;code&gt;unwrap_or_else&lt;/code&gt; 것은 우리는 일부 사용자 지정, 비 정의 할 수 있습니다 &lt;code&gt;panic!&lt;/code&gt; 오류 처리. 는 IF &lt;code&gt;Result&lt;/code&gt; 입니다 &lt;code&gt;Ok&lt;/code&gt; 값이이 방법의 행동과 유사한 &lt;code&gt;unwrap&lt;/code&gt; : 그것은 내부 값 반환 &lt;code&gt;Ok&lt;/code&gt; 포장입니다. 그러나 값이 &lt;code&gt;Err&lt;/code&gt; 값인 경우이 메소드는 &lt;em&gt;클로저&lt;/em&gt; 에서 코드를 호출합니다.이 함수는 우리가 &lt;code&gt;unwrap_or_else&lt;/code&gt; 에 인수로 정의하고 전달하는 익명 함수 입니다. 우리는 폐쇄를 더 자세히 다룰 것입니다.&lt;a href=&quot;ch13-00-functional-features&quot;&gt;13 장&lt;/a&gt; . 지금, 당신은 알아야합니다 &lt;code&gt;unwrap_or_else&lt;/code&gt; 가 의 내부 값을 전달합니다 &lt;code&gt;Err&lt;/code&gt; 이 경우에는 정적 문자열, &lt;code&gt;not enough arguments&lt;/code&gt; 우리가 인수에 우리의 폐쇄, 목록 12-9에 추가 한 &lt;code&gt;err&lt;/code&gt; 그 사이에 나타납니다 수직 파이프. 클로저의 코드는 실행될 때 &lt;code&gt;err&lt;/code&gt; 값 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd1efd0f88f5695bb09cde72e8a0904d7ad1c207" translate="yes" xml:space="preserve">
          <source>In this more complex example, we use &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;.debug_set()&lt;/code&gt; to build a list of match arms:</source>
          <target state="translated">이보다 복잡한 예에서는 &lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt; 를 사용합니다 ! 및 &lt;code&gt;.debug_set()&lt;/code&gt; 일치 팔의 목록을 작성합니다 :</target>
        </trans-unit>
        <trans-unit id="b03c6712fd2fec1eec14a91751691024a72c4d16" translate="yes" xml:space="preserve">
          <source>In this next example, &lt;code&gt;init_after_if&lt;/code&gt; is initialized after the &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt;&lt;code&gt;if&lt;/code&gt; expression&lt;/a&gt; while &lt;code&gt;uninit_after_if&lt;/code&gt; is not because it is not initialized in the &lt;code&gt;else&lt;/code&gt; case.</source>
          <target state="translated">다음 예제에서, &lt;code&gt;init_after_if&lt;/code&gt; 는 &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt; &lt;code&gt;if&lt;/code&gt; 표현식&lt;/a&gt; 이후에 초기화 되지만 &lt;code&gt;uninit_after_if&lt;/code&gt; 는 &lt;code&gt;else&lt;/code&gt; 경우에 초기화되지 않기 때문에 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="8c69b4c18cf4fe1c7e28ef21ab7b9243778f0c95" translate="yes" xml:space="preserve">
          <source>In this process, the compiler does the opposite of the steps we used to create the generic function in Listing 10-5: the compiler looks at all the places where generic code is called and generates code for the concrete types the generic code is called with.</source>
          <target state="translated">이 프로세스에서 컴파일러는 Listing 10-5에서 일반 함수를 작성하는 데 사용했던 단계와 반대되는 작업을 수행합니다. 컴파일러는 일반 코드가 호출되는 모든 위치를보고 일반 코드가 호출되는 구체적인 유형에 대한 코드를 생성합니다. .</target>
        </trans-unit>
        <trans-unit id="9b2eecf1196adab0e0b7bc0dd52bfa9ea4118939" translate="yes" xml:space="preserve">
          <source>In this section, we&amp;rsquo;ll add the searching logic to the &lt;code&gt;minigrep&lt;/code&gt; program by using the Test-driven development (TDD) process. This software development technique follows these steps:</source>
          <target state="translated">이 섹션에서는 TDD (Test-driven development) 프로세스를 사용하여 &lt;code&gt;minigrep&lt;/code&gt; 프로그램에 검색 로직을 추가합니다 . 이 소프트웨어 개발 기술은 다음 단계를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="35594ca80fb0c4ca7018f39776903a474d1cfb0f" translate="yes" xml:space="preserve">
          <source>In this section, we&amp;rsquo;ll talk about modules and other parts of the module system, namely &lt;em&gt;paths&lt;/em&gt; that allow you to name items; the &lt;code&gt;use&lt;/code&gt; keyword that brings a path into scope; and the &lt;code&gt;pub&lt;/code&gt; keyword to make items public. We&amp;rsquo;ll also discuss the &lt;code&gt;as&lt;/code&gt; keyword, external packages, and the glob operator. For now, let&amp;rsquo;s focus on modules!</source>
          <target state="translated">이 섹션에서는 모듈 및 모듈 시스템의 다른 부분, 즉 항목 이름을 지정할 수있는 &lt;em&gt;경로에&lt;/em&gt; 대해 설명합니다. &lt;code&gt;use&lt;/code&gt; 범위에 대한 경로를 제공 키워드; 그리고 &lt;code&gt;pub&lt;/code&gt; 키워드는 항목을 공개합니다. 또한 &lt;code&gt;as&lt;/code&gt; 키워드, 외부 패키지 및 glob 연산자에 대해서도 설명합니다 . 지금은 모듈에 집중하자!</target>
        </trans-unit>
        <trans-unit id="b9ddbf2b08f89e10bfeee4884b118c18fb0ff1c3" translate="yes" xml:space="preserve">
          <source>In this situation, even the &lt;code&gt;ref&lt;/code&gt; keyword cannot solve it, since borrowed content cannot be moved. This problem cannot be solved generally. If the value can be cloned, here is a not-so-specific solution:</source>
          <target state="translated">이 경우 빌린 컨텐츠를 이동할 수 없으므로 &lt;code&gt;ref&lt;/code&gt; 키워드로 도 해결할 수 없습니다. 이 문제는 일반적으로 해결할 수 없습니다. 값을 복제 할 수 있으면 다음과 같이 구체적이지 않은 솔루션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="66f6d7f6d5b6dce217f5225ca67e0e2ff88fca0a" translate="yes" xml:space="preserve">
          <source>In this specific case there's a good chance that the transmute is harmless (but this is not guaranteed by Rust). However, when alignment and enum optimizations come into the picture, it's quite likely that the sizes may or may not match with different type parameter substitutions. It's not possible to check this for &lt;em&gt;all&lt;/em&gt; possible types, so &lt;code&gt;transmute()&lt;/code&gt; simply only accepts types without any unsubstituted type parameters.</source>
          <target state="translated">이 특정한 경우에는 변환 음이 무해 할 가능성이 높습니다 (그러나 Rust가이를 보증하지는 않습니다). 그러나 정렬 및 열거 최적화가 그림에 나타날 때 크기가 다른 유형 매개 변수 대체와 일치하거나 일치하지 않을 수 있습니다. 가능한 &lt;em&gt;모든&lt;/em&gt; 유형에 대해 이것을 확인할 수는 없으므로 &lt;code&gt;transmute()&lt;/code&gt; 는 대체 되지 않은 유형 매개 변수가없는 유형 만 허용합니다.</target>
        </trans-unit>
        <trans-unit id="fe9b2052803d3d7b3dd78aa5085c8137d21478b8" translate="yes" xml:space="preserve">
          <source>In this suggestion, &amp;ldquo;indirection&amp;rdquo; means that instead of storing a value directly, we&amp;rsquo;ll change the data structure to store the value indirectly by storing a pointer to the value instead.</source>
          <target state="translated">이 제안에서 &quot;간접&quot;은 값을 직접 저장하는 대신 값에 대한 포인터를 저장하여 값을 간접적으로 저장하도록 데이터 구조를 변경한다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="ace1483441c50f77553551974f43198070533a0e" translate="yes" xml:space="preserve">
          <source>In this way, the structure of expressions dictates the structure of execution. Blocks are just another kind of expression, so blocks, statements, expressions, and blocks again can recursively nest inside each other to an arbitrary depth.</source>
          <target state="translated">이런 식으로 표현 구조는 실행 구조를 나타냅니다. 블록은 또 다른 종류의 표현식이므로 블록, 명령문, 표현식 및 블록은 다시 재귀 적으로 서로 깊이있게 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c64ce605c02c94d28e3d47caa98671818a3b2ae" translate="yes" xml:space="preserve">
          <source>In those cases, you need to provide the type explicitly:</source>
          <target state="translated">이 경우 유형을 명시 적으로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f60575dd030bfd74d0c69219e41591057c41df3" translate="yes" xml:space="preserve">
          <source>In trait declarations as &lt;a href=&quot;items/traits#supertraits&quot;&gt;supertraits&lt;/a&gt;: &lt;code&gt;trait Circle : Shape {}&lt;/code&gt; is equivalent to &lt;code&gt;trait Circle where Self : Shape {}&lt;/code&gt;.</source>
          <target state="translated">특성 선언에서 &lt;a href=&quot;items/traits#supertraits&quot;&gt;수퍼&lt;/a&gt; 특성으로 : &lt;code&gt;trait Circle : Shape {}&lt;/code&gt; 은 &lt;code&gt;trait Circle where Self : Shape {}&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a4f93075a116db72d1570a79e9e24585b192c4ef" translate="yes" xml:space="preserve">
          <source>In trait declarations as bounds on &lt;a href=&quot;items/associated-items#associated-types&quot;&gt;associated types&lt;/a&gt;: &lt;code&gt;trait A { type B: Copy; }&lt;/code&gt; is equivalent to &lt;code&gt;trait A where Self::B: Copy { type B; }&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;items/associated-items#associated-types&quot;&gt;관련 유형&lt;/a&gt; 에 대한 경계로서 특성 선언에서 : &lt;code&gt;trait A { type B: Copy; }&lt;/code&gt; 는 &lt;code&gt;trait A where Self::B: Copy { type B; }&lt;/code&gt; 와 동일합니다 . 여기서 Self :: B : Copy {type B; } .</target>
        </trans-unit>
        <trans-unit id="d593169be70ffe063ab15f461603b04fb19d3943" translate="yes" xml:space="preserve">
          <source>In traits, &lt;code&gt;type&lt;/code&gt; is used to declare an &lt;a href=&quot;../reference/items/associated-items#associated-types&quot;&gt;associated type&lt;/a&gt;:</source>
          <target state="translated">트레이 트에서 &lt;code&gt;type&lt;/code&gt; 은 &lt;a href=&quot;../reference/items/associated-items#associated-types&quot;&gt;연관된 유형&lt;/a&gt; 을 선언하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="31d52c1f8837d60baebd5fe1bd8acd4770d12408" translate="yes" xml:space="preserve">
          <source>In types, the &lt;code&gt;+&lt;/code&gt; type operator has low precedence, so it is often necessary to use parentheses.</source>
          <target state="translated">유형에서 &lt;code&gt;+&lt;/code&gt; 유형 연산자는 우선 순위가 낮으므로 괄호를 사용해야하는 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9490ac1bbc7d37c9f2c0e3e394c8775ef19ff65" translate="yes" xml:space="preserve">
          <source>In types, the &lt;code&gt;+&lt;/code&gt; type operator has low precedence, so it is often necessary to use parentheses:</source>
          <target state="translated">유형에서 &lt;code&gt;+&lt;/code&gt; 유형 연산자는 우선 순위가 낮으므로 종종 괄호를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd1daf40491a926084464e0388144e6ba829d637" translate="yes" xml:space="preserve">
          <source>In various places in the book, we&amp;rsquo;ve discussed the &lt;code&gt;derive&lt;/code&gt; attribute, which you can apply to a struct or enum definition. The &lt;code&gt;derive&lt;/code&gt; attribute generates code that will implement a trait with its own default implementation on the type you&amp;rsquo;ve annotated with the &lt;code&gt;derive&lt;/code&gt; syntax.</source>
          <target state="translated">이 책의 여러 곳에서 &lt;code&gt;derive&lt;/code&gt; 속성을 논의했습니다.이 속성은 구조체 또는 열거 정의에 적용 할 수 있습니다. &lt;code&gt;derive&lt;/code&gt; 속성을 사용하면 주석 한 유형에 대한 자신의 디폴트의 구현과 특성 구현하는 코드 생성 &lt;code&gt;derive&lt;/code&gt; 구문을.</target>
        </trans-unit>
        <trans-unit id="0cebe38e502b4e0d3a49a067f9739636c8c7567e" translate="yes" xml:space="preserve">
          <source>In very rare edge cases, this may happen when loading &lt;code&gt;core&lt;/code&gt; or &lt;code&gt;std&lt;/code&gt; twice, once with &lt;code&gt;check&lt;/code&gt; metadata and once with &lt;code&gt;build&lt;/code&gt; metadata. For more information, see &lt;a href=&quot;https://github.com/rust-lang/rust/pull/75176#issuecomment-683234468&quot;&gt;#75176&lt;/a&gt;.</source>
          <target state="translated">매우 드문 경우에이 문제는 &lt;code&gt;core&lt;/code&gt; 또는 &lt;code&gt;std&lt;/code&gt; 를 두 번 로드 할 때 발생할 수 있습니다 . 한 번은 메타 데이터 를 &lt;code&gt;check&lt;/code&gt; 하고 한 번은 메타 데이터 를 &lt;code&gt;build&lt;/code&gt; 합니다. 자세한 내용은 &lt;a href=&quot;https://github.com/rust-lang/rust/pull/75176#issuecomment-683234468&quot;&gt;# 75176을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fcacf884bdd57e38c179c26c2a445daf0a3b88d" translate="yes" xml:space="preserve">
          <source>In-band lifetimes cannot be mixed with explicit lifetime binders. For example:</source>
          <target state="translated">대역 내 수명은 명시 적 수명 바인더와 혼합 될 수 없습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="2c1253e722ca01693911433634c27b9199fbe1b5" translate="yes" xml:space="preserve">
          <source>In-band lifetimes cannot be used in &lt;code&gt;fn&lt;/code&gt;/&lt;code&gt;Fn&lt;/code&gt; syntax.</source>
          <target state="translated">대역 내 수명은 &lt;code&gt;fn&lt;/code&gt; / &lt;code&gt;Fn&lt;/code&gt; 구문 에서 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a0307fb1316fe032b75c2eab1c02683137e89f74" translate="yes" xml:space="preserve">
          <source>In-band lifetimes were mixed with explicit lifetime binders.</source>
          <target state="translated">대역 내 수명은 명시 적 수명 바인더와 혼합되었습니다.</target>
        </trans-unit>
        <trans-unit id="71195f6d729d094826e987475aa2b83d4c3354c6" translate="yes" xml:space="preserve">
          <source>InPlaceIterable</source>
          <target state="translated">InPlaceIterable</target>
        </trans-unit>
        <trans-unit id="0d84c9de7449d934ab38cca665ee24ab8d418e04" translate="yes" xml:space="preserve">
          <source>Includes a UTF-8 encoded file as a string.</source>
          <target state="translated">UTF-8로 인코딩 된 파일을 문자열로 포함합니다.</target>
        </trans-unit>
        <trans-unit id="42e257e75b3e4fa6d9e9989f973afa801a9a03f0" translate="yes" xml:space="preserve">
          <source>Includes a file as a reference to a byte array.</source>
          <target state="translated">바이트 배열에 대한 참조로 파일을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9c140715e3185328a980b4bc60a18b0febc51520" translate="yes" xml:space="preserve">
          <source>Includes a utf8-encoded file as a string.</source>
          <target state="translated">utf8로 인코딩 된 파일을 문자열로 포함합니다.</target>
        </trans-unit>
        <trans-unit id="0c11e0c644b5890be96bab7620a548663254f1f7" translate="yes" xml:space="preserve">
          <source>Includes all extension traits, and some important type definitions.</source>
          <target state="translated">모든 확장 특성과 일부 중요한 유형 정의가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a9c615b9e833ee226ac08cb33f93df17a615ca30" translate="yes" xml:space="preserve">
          <source>Incoming</source>
          <target state="translated">Incoming</target>
        </trans-unit>
        <trans-unit id="805a014cffe854e2c811b260ab089d2eda0bbeb7" translate="yes" xml:space="preserve">
          <source>Incoming::all</source>
          <target state="translated">Incoming::all</target>
        </trans-unit>
        <trans-unit id="83bd443d175b9e89de0c8b8872961ea2816dcfb6" translate="yes" xml:space="preserve">
          <source>Incoming::any</source>
          <target state="translated">Incoming::any</target>
        </trans-unit>
        <trans-unit id="f9822b9a823019e577bdfe3ac98493f3aa60473c" translate="yes" xml:space="preserve">
          <source>Incoming::borrow</source>
          <target state="translated">Incoming::borrow</target>
        </trans-unit>
        <trans-unit id="db57c16634c0af16618401e02b9b1b14cfb90675" translate="yes" xml:space="preserve">
          <source>Incoming::borrow_mut</source>
          <target state="translated">Incoming::borrow_mut</target>
        </trans-unit>
        <trans-unit id="909a090d9b0ea3ec427658ae73388b50d4bfbc1f" translate="yes" xml:space="preserve">
          <source>Incoming::by_ref</source>
          <target state="translated">Incoming::by_ref</target>
        </trans-unit>
        <trans-unit id="6d7e9108e413d8a837bb790d96b999eaae29b3f2" translate="yes" xml:space="preserve">
          <source>Incoming::chain</source>
          <target state="translated">Incoming::chain</target>
        </trans-unit>
        <trans-unit id="30254dbd6651bc8d2ce9a6489cb59513c462d366" translate="yes" xml:space="preserve">
          <source>Incoming::cloned</source>
          <target state="translated">Incoming::cloned</target>
        </trans-unit>
        <trans-unit id="8a2bf20be5038460f2e5f09718d4cb6a21fb4c03" translate="yes" xml:space="preserve">
          <source>Incoming::cmp</source>
          <target state="translated">Incoming::cmp</target>
        </trans-unit>
        <trans-unit id="5ed0bcc65453a7978586b3e2016dacfbc14352fe" translate="yes" xml:space="preserve">
          <source>Incoming::collect</source>
          <target state="translated">Incoming::collect</target>
        </trans-unit>
        <trans-unit id="e70d0d30256802ac0658826bed8a56d75ffa6c45" translate="yes" xml:space="preserve">
          <source>Incoming::copied</source>
          <target state="translated">Incoming::copied</target>
        </trans-unit>
        <trans-unit id="a1ce4c03ba198d6862609c9bca7b4fdfd0e790c1" translate="yes" xml:space="preserve">
          <source>Incoming::count</source>
          <target state="translated">Incoming::count</target>
        </trans-unit>
        <trans-unit id="445c24f8aeffb804abbe66eac8d728adfa6384c3" translate="yes" xml:space="preserve">
          <source>Incoming::cycle</source>
          <target state="translated">Incoming::cycle</target>
        </trans-unit>
        <trans-unit id="c7373d860bdcd6bd00f58afd7287948921f2cf3d" translate="yes" xml:space="preserve">
          <source>Incoming::enumerate</source>
          <target state="translated">Incoming::enumerate</target>
        </trans-unit>
        <trans-unit id="422e90f2e0427cea81726aa22dde243c959e3442" translate="yes" xml:space="preserve">
          <source>Incoming::eq</source>
          <target state="translated">Incoming::eq</target>
        </trans-unit>
        <trans-unit id="d82ad0962be1b645dba4415057b56c8c71d2db6c" translate="yes" xml:space="preserve">
          <source>Incoming::filter</source>
          <target state="translated">Incoming::filter</target>
        </trans-unit>
        <trans-unit id="f2d060b73d6c431a592011fdcaf80f72c4327ea7" translate="yes" xml:space="preserve">
          <source>Incoming::filter_map</source>
          <target state="translated">Incoming::filter_map</target>
        </trans-unit>
        <trans-unit id="ec24aef48051e0d66dfbf513fbece0b535e8173a" translate="yes" xml:space="preserve">
          <source>Incoming::find</source>
          <target state="translated">Incoming::find</target>
        </trans-unit>
        <trans-unit id="9f1745b317ce967f0969bdd91f79615c9788ba14" translate="yes" xml:space="preserve">
          <source>Incoming::find_map</source>
          <target state="translated">Incoming::find_map</target>
        </trans-unit>
        <trans-unit id="57ed09c2ac8fbae367da14cf88b9a1cf3a0b0f16" translate="yes" xml:space="preserve">
          <source>Incoming::flat_map</source>
          <target state="translated">Incoming::flat_map</target>
        </trans-unit>
        <trans-unit id="aa8cfa9877df81bdf6f3e26ae8c327e4f18e7ca7" translate="yes" xml:space="preserve">
          <source>Incoming::flatten</source>
          <target state="translated">Incoming::flatten</target>
        </trans-unit>
        <trans-unit id="f534c99639d2a7b60622d67e3da268c1b2dbd8a2" translate="yes" xml:space="preserve">
          <source>Incoming::fmt</source>
          <target state="translated">Incoming::fmt</target>
        </trans-unit>
        <trans-unit id="7bf954d9f452b8f0bff229d58d17ebe667b8bdaa" translate="yes" xml:space="preserve">
          <source>Incoming::fold</source>
          <target state="translated">Incoming::fold</target>
        </trans-unit>
        <trans-unit id="f45d04534657562b3b8e1ac8b93f0995c4f52ffc" translate="yes" xml:space="preserve">
          <source>Incoming::for_each</source>
          <target state="translated">Incoming::for_each</target>
        </trans-unit>
        <trans-unit id="146d704978de3d221c4a8b538e653f767ff7d0cc" translate="yes" xml:space="preserve">
          <source>Incoming::from</source>
          <target state="translated">Incoming::from</target>
        </trans-unit>
        <trans-unit id="8d00e730beb7664120c689b2165fe55c7e43696b" translate="yes" xml:space="preserve">
          <source>Incoming::fuse</source>
          <target state="translated">Incoming::fuse</target>
        </trans-unit>
        <trans-unit id="d6f3fa46377ae997728223371f8e2928bbcd46ee" translate="yes" xml:space="preserve">
          <source>Incoming::ge</source>
          <target state="translated">Incoming::ge</target>
        </trans-unit>
        <trans-unit id="ed38c0b5ef84ea5163b2da693e4b72183ddee0ec" translate="yes" xml:space="preserve">
          <source>Incoming::gt</source>
          <target state="translated">Incoming::gt</target>
        </trans-unit>
        <trans-unit id="b1345261a277f185321d6adb9b350bcb58cd599e" translate="yes" xml:space="preserve">
          <source>Incoming::inspect</source>
          <target state="translated">Incoming::inspect</target>
        </trans-unit>
        <trans-unit id="59abb681c116c064869e4b015c6b1cd16fb45598" translate="yes" xml:space="preserve">
          <source>Incoming::into</source>
          <target state="translated">Incoming::into</target>
        </trans-unit>
        <trans-unit id="95a20422d3926772d9c359f121355edbd8f745f9" translate="yes" xml:space="preserve">
          <source>Incoming::into_iter</source>
          <target state="translated">Incoming::into_iter</target>
        </trans-unit>
        <trans-unit id="77b7ce153ce8067d29a7d019ff3fcc043c2fdd8e" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted</source>
          <target state="translated">Incoming::is_sorted</target>
        </trans-unit>
        <trans-unit id="4dfdf545d2798411e8ee50244269b54395d86c9a" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted_by</source>
          <target state="translated">Incoming::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="d90a5dfb897aff5c068a0a4a12a54de5b9bdf1da" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted_by_key</source>
          <target state="translated">Incoming::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="f1c770fca353b885ee610fe1f519139cdebcc0ee" translate="yes" xml:space="preserve">
          <source>Incoming::last</source>
          <target state="translated">Incoming::last</target>
        </trans-unit>
        <trans-unit id="f5c79843bca5e97321f55d85100e1ac93d537dd7" translate="yes" xml:space="preserve">
          <source>Incoming::le</source>
          <target state="translated">Incoming::le</target>
        </trans-unit>
        <trans-unit id="41753aa4086d7645034ac6f543870deca487abbb" translate="yes" xml:space="preserve">
          <source>Incoming::lt</source>
          <target state="translated">Incoming::lt</target>
        </trans-unit>
        <trans-unit id="42262cd6a3c45e0c4ccd2f403ab3dde4f31c999d" translate="yes" xml:space="preserve">
          <source>Incoming::map</source>
          <target state="translated">Incoming::map</target>
        </trans-unit>
        <trans-unit id="b14fbc258acb1391be68964dacf06c868d0223ee" translate="yes" xml:space="preserve">
          <source>Incoming::max</source>
          <target state="translated">Incoming::max</target>
        </trans-unit>
        <trans-unit id="e598cfd5a561805bab3a055536a7ce8d4cbc0d87" translate="yes" xml:space="preserve">
          <source>Incoming::max_by</source>
          <target state="translated">Incoming::max_by</target>
        </trans-unit>
        <trans-unit id="02e8830cd577c40509d7ca817740c861b52c07c0" translate="yes" xml:space="preserve">
          <source>Incoming::max_by_key</source>
          <target state="translated">Incoming::max_by_key</target>
        </trans-unit>
        <trans-unit id="e522553048356a9c7e3aafb53205e73c814823fd" translate="yes" xml:space="preserve">
          <source>Incoming::min</source>
          <target state="translated">Incoming::min</target>
        </trans-unit>
        <trans-unit id="8b1b84ed0cee495bc315c75dc85c4916ce7f680f" translate="yes" xml:space="preserve">
          <source>Incoming::min_by</source>
          <target state="translated">Incoming::min_by</target>
        </trans-unit>
        <trans-unit id="94a6455843a6def08f4247ddbcf5a373aff6a12c" translate="yes" xml:space="preserve">
          <source>Incoming::min_by_key</source>
          <target state="translated">Incoming::min_by_key</target>
        </trans-unit>
        <trans-unit id="af6f0e0d448b8971f8088a94ecfe2c2c28074b20" translate="yes" xml:space="preserve">
          <source>Incoming::ne</source>
          <target state="translated">Incoming::ne</target>
        </trans-unit>
        <trans-unit id="ad9f2df7e05588db669a49fe0bfa35787281e257" translate="yes" xml:space="preserve">
          <source>Incoming::next</source>
          <target state="translated">Incoming::next</target>
        </trans-unit>
        <trans-unit id="15fdadbdf731ff5f14bd01d14581b0031b5aa856" translate="yes" xml:space="preserve">
          <source>Incoming::nth</source>
          <target state="translated">Incoming::nth</target>
        </trans-unit>
        <trans-unit id="f584fdb6a022a6b9c2041ae0049adb844c00af0a" translate="yes" xml:space="preserve">
          <source>Incoming::partial_cmp</source>
          <target state="translated">Incoming::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d6e7347d2f13179a0246ad8c2f8f8c42d5ea1e8b" translate="yes" xml:space="preserve">
          <source>Incoming::partition</source>
          <target state="translated">Incoming::partition</target>
        </trans-unit>
        <trans-unit id="d15dc3a739c395fba4cdef1bb3db41863ef399f5" translate="yes" xml:space="preserve">
          <source>Incoming::peekable</source>
          <target state="translated">Incoming::peekable</target>
        </trans-unit>
        <trans-unit id="cab06ddc3af8abd52b92e45544310b0faa110219" translate="yes" xml:space="preserve">
          <source>Incoming::position</source>
          <target state="translated">Incoming::position</target>
        </trans-unit>
        <trans-unit id="bb23c8eb76a6d68dfc63c6d32849abe960c1b856" translate="yes" xml:space="preserve">
          <source>Incoming::product</source>
          <target state="translated">Incoming::product</target>
        </trans-unit>
        <trans-unit id="b3d90889f7b30454426b3ed4e11228f5d9d8ee9f" translate="yes" xml:space="preserve">
          <source>Incoming::rev</source>
          <target state="translated">Incoming::rev</target>
        </trans-unit>
        <trans-unit id="d662587d11104ca4324befe21e5aaa1cf3ed3fa3" translate="yes" xml:space="preserve">
          <source>Incoming::rposition</source>
          <target state="translated">Incoming::rposition</target>
        </trans-unit>
        <trans-unit id="6b42372525b119239ec4bd20dc7bf69a1a105a08" translate="yes" xml:space="preserve">
          <source>Incoming::scan</source>
          <target state="translated">Incoming::scan</target>
        </trans-unit>
        <trans-unit id="c1399e28a107bc4249663ed0d2b97e798127c9c6" translate="yes" xml:space="preserve">
          <source>Incoming::size_hint</source>
          <target state="translated">Incoming::size_hint</target>
        </trans-unit>
        <trans-unit id="85ee70ca43a998ef206f4a945f59006b6f40ddfa" translate="yes" xml:space="preserve">
          <source>Incoming::skip</source>
          <target state="translated">Incoming::skip</target>
        </trans-unit>
        <trans-unit id="fdd32c3e0206952202e83705e9d627eb48f607e6" translate="yes" xml:space="preserve">
          <source>Incoming::skip_while</source>
          <target state="translated">Incoming::skip_while</target>
        </trans-unit>
        <trans-unit id="5a589e1b9602c4ff48aa22e65968275507ea9485" translate="yes" xml:space="preserve">
          <source>Incoming::step_by</source>
          <target state="translated">Incoming::step_by</target>
        </trans-unit>
        <trans-unit id="d9ed48df44b20a36de8b0990f9b0c9b964475772" translate="yes" xml:space="preserve">
          <source>Incoming::sum</source>
          <target state="translated">Incoming::sum</target>
        </trans-unit>
        <trans-unit id="bcf6381c826c50e1aaea7423243d1529dca214b8" translate="yes" xml:space="preserve">
          <source>Incoming::take</source>
          <target state="translated">Incoming::take</target>
        </trans-unit>
        <trans-unit id="981c1e08f556e3870dd2af3a144f3176473200b7" translate="yes" xml:space="preserve">
          <source>Incoming::take_while</source>
          <target state="translated">Incoming::take_while</target>
        </trans-unit>
        <trans-unit id="2f0356552ebde5f1c3f3f3ad37fa03b3d1bf90bd" translate="yes" xml:space="preserve">
          <source>Incoming::try_fold</source>
          <target state="translated">Incoming::try_fold</target>
        </trans-unit>
        <trans-unit id="5c1f1df01cacdbf861258e63eb2cb8581f88d043" translate="yes" xml:space="preserve">
          <source>Incoming::try_for_each</source>
          <target state="translated">Incoming::try_for_each</target>
        </trans-unit>
        <trans-unit id="9a58299e31b9803379553db37123ab15774b671d" translate="yes" xml:space="preserve">
          <source>Incoming::try_from</source>
          <target state="translated">Incoming::try_from</target>
        </trans-unit>
        <trans-unit id="fff541a38a97a609e5012c516e4164326cfb79eb" translate="yes" xml:space="preserve">
          <source>Incoming::try_into</source>
          <target state="translated">Incoming::try_into</target>
        </trans-unit>
        <trans-unit id="946f55dc3e1af640cd291f2aaa8528234e768102" translate="yes" xml:space="preserve">
          <source>Incoming::type_id</source>
          <target state="translated">Incoming::type_id</target>
        </trans-unit>
        <trans-unit id="bf46b8f3bb432660f79899dee66baf3e9f087f95" translate="yes" xml:space="preserve">
          <source>Incoming::unzip</source>
          <target state="translated">Incoming::unzip</target>
        </trans-unit>
        <trans-unit id="96a8cde7e0e4c52965055072fd39e0d341071072" translate="yes" xml:space="preserve">
          <source>Incoming::zip</source>
          <target state="translated">Incoming::zip</target>
        </trans-unit>
        <trans-unit id="bcbf83cd2f0ed89c4d2689129dde9ed148866efc" translate="yes" xml:space="preserve">
          <source>Incorrect bytes:</source>
          <target state="translated">잘못된 바이트 :</target>
        </trans-unit>
        <trans-unit id="2a70492a6aefdfa404f3b9ac0c6d0448b88be337" translate="yes" xml:space="preserve">
          <source>Incorrect usage</source>
          <target state="translated">잘못된 사용법</target>
        </trans-unit>
        <trans-unit id="6d7c0e61e47d8d76b1fdbcd2b9644ebc448b482b" translate="yes" xml:space="preserve">
          <source>Increments the strong reference count on the &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; associated with the provided pointer by one.</source>
          <target state="translated">제공된 포인터와 연결된 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 의 강력한 참조 수를 1 씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="52cb15ca8d9c1e4b950b26ef1f32246271f50339" translate="yes" xml:space="preserve">
          <source>Index expressions on arrays and slices</source>
          <target state="translated">배열 및 슬라이스의 인덱스 표현식</target>
        </trans-unit>
        <trans-unit id="361d6f89c121ce39bb2ed14f7085cd248645d21b" translate="yes" xml:space="preserve">
          <source>Index expressions, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; or &lt;a href=&quot;types/slice&quot;&gt;slice&lt;/a&gt; with a &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">지수 식, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;배열 인덱싱&lt;/a&gt; 또는 &lt;a href=&quot;types/slice&quot;&gt;슬라이스&lt;/a&gt; A를 &lt;code&gt;usize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="528b0ff12e28b750b5aeda40648664d5f6804c7c" translate="yes" xml:space="preserve">
          <source>Index::index</source>
          <target state="translated">Index::index</target>
        </trans-unit>
        <trans-unit id="21d657443793a7fc6c319cfc186e761fac77191e" translate="yes" xml:space="preserve">
          <source>IndexMut</source>
          <target state="translated">IndexMut</target>
        </trans-unit>
        <trans-unit id="24f9ef47b9bb8985e28653af23b1accbf6cd2d9b" translate="yes" xml:space="preserve">
          <source>IndexMut::index_mut</source>
          <target state="translated">IndexMut::index_mut</target>
        </trans-unit>
        <trans-unit id="bda8e2dcef8324d4ce1ba450c4e2e0cae96a9a4a" translate="yes" xml:space="preserve">
          <source>Indexes must be within bounds of the original slice;</source>
          <target state="translated">인덱스는 원래 슬라이스의 범위 내에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="fa74cb6623de227628f45b4ae93159daddea90b3" translate="yes" xml:space="preserve">
          <source>Indexes must lie on UTF-8 sequence boundaries.</source>
          <target state="translated">인덱스는 UTF-8 시퀀스 경계에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="8e33bba2a2fe8c945dee904cfed37743c8dd2807" translate="yes" xml:space="preserve">
          <source>Indexing into Strings</source>
          <target state="translated">문자열로 인덱싱</target>
        </trans-unit>
        <trans-unit id="bc1a7f445eecf9a21ddaa6928da85497c3f808d7" translate="yes" xml:space="preserve">
          <source>Indexing into a string is often a bad idea because it&amp;rsquo;s not clear what the return type of the string-indexing operation should be: a byte value, a character, a grapheme cluster, or a string slice. Therefore, Rust asks you to be more specific if you really need to use indices to create string slices. To be more specific in your indexing and indicate that you want a string slice, rather than indexing using &lt;code&gt;[]&lt;/code&gt; with a single number, you can use &lt;code&gt;[]&lt;/code&gt; with a range to create a string slice containing particular bytes:</source>
          <target state="translated">문자열 인덱싱 연산의 반환 유형이 바이트 값, 문자, 그래 핀 클러스터 또는 문자열 슬라이스인지 명확하지 않기 때문에 문자열 인덱싱은 종종 나쁜 생각입니다. 따라서 Rust는 인덱스를 사용하여 문자열 슬라이스를 만들어야하는 경우 더 구체적으로 요구합니다. 인덱싱에서보다 구체적 으로 설명하고 단일 숫자로 &lt;code&gt;[]&lt;/code&gt; 를 사용하여 인덱싱하는 대신 문자열 슬라이스를 원한다는 것을 나타내 려면 범위와 함께 &lt;code&gt;[]&lt;/code&gt; 를 사용하여 특정 바이트를 포함하는 문자열 슬라이스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b92d7c5b5fd6e80ddd2c2e71ae6f53dabf14469" translate="yes" xml:space="preserve">
          <source>Indexing is intended to be a constant-time operation, but UTF-8 encoding does not allow us to do this. Furthermore, it's not clear what sort of thing the index should return: a byte, a codepoint, or a grapheme cluster. The &lt;a href=&quot;#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; methods return iterators over the first two, respectively.</source>
          <target state="translated">인덱싱은 상수 시간 작업을위한 것이지만 UTF-8 인코딩을 사용하면이 작업을 수행 할 수 없습니다. 또한 인덱스가 어떤 종류의 바이트, 코드 포인트 또는 grapheme 클러스터를 반환해야하는지 명확하지 않습니다. &lt;a href=&quot;#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#method.chars&quot;&gt; &lt;code&gt;chars&lt;/code&gt; &lt;/a&gt; 방법은 각각 제 1 ~ 2 반복자를 반환한다.</target>
        </trans-unit>
        <trans-unit id="ceeb8ddb5f53fcb5614444876f148bbebee79484" translate="yes" xml:space="preserve">
          <source>Indexing is intended to be a constant-time operation, but UTF-8 encoding does not allow us to do this. Furthermore, it's not clear what sort of thing the index should return: a byte, a codepoint, or a grapheme cluster. The &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; methods return iterators over the first two, respectively.</source>
          <target state="translated">인덱싱은 일정한 시간 작업을위한 것이지만 UTF-8 인코딩은이를 허용하지 않습니다. 게다가 인덱스가 어떤 종류의 것을 반환해야하는지 (바이트, 코드 포인트 또는 자소 클러스터)가 명확하지 않습니다. &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../primitive.str#method.chars&quot;&gt; &lt;code&gt;chars&lt;/code&gt; &lt;/a&gt; 방법은 각각 제 1 ~ 2 반복자를 반환한다.</target>
        </trans-unit>
        <trans-unit id="0aba4d1ffc3e50a35d8e6bb2627a9921d36e96c9" translate="yes" xml:space="preserve">
          <source>Indexing outside of the bounds of an object with &lt;a href=&quot;../std/primitive.pointer#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt; with the exception of one byte past the end of the object.</source>
          <target state="translated">객체 의 끝을지나 1 바이트를 제외 하고 &lt;a href=&quot;../std/primitive.pointer#method.offset&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt; 사용하여 객체의 경계 외부에서 인덱싱 합니다.</target>
        </trans-unit>
        <trans-unit id="27caa1fa7c65a4437e649a4888fe129281a79568" translate="yes" xml:space="preserve">
          <source>Indicates if a buffer should be initialized.</source>
          <target state="translated">버퍼를 초기화해야하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c4c4786e638c55c48e8eb353954207ab6043189e" translate="yes" xml:space="preserve">
          <source>Indicates that directories should be created recursively, creating all parent directories. Parents that do not exist are created with the same security and permissions settings.</source>
          <target state="translated">모든 상위 디렉토리를 작성하여 디렉토리를 반복적으로 작성해야 함을 나타냅니다. 존재하지 않는 부모는 동일한 보안 및 권한 설정으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4856479107baf14ea55cfdf8d4985b8807716a64" translate="yes" xml:space="preserve">
          <source>Indicates the manner in which a thread exited.</source>
          <target state="translated">스레드가 종료 된 방식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="075cfaf01d924967ba4b76beb1cc86c1b8ffbe22" translate="yes" xml:space="preserve">
          <source>Indicates the time-to-live value of outgoing multicast packets for this socket. The default value is 1 which means that multicast packets don't leave the local network unless explicitly requested.</source>
          <target state="translated">이 소켓에 대한 발신 멀티 캐스트 패킷의 유효 기간 값을 나타냅니다. 기본값은 1입니다. 즉, 멀티 캐스트 패킷은 명시 적으로 요청하지 않는 한 로컬 네트워크를 떠나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="888a497d6d0feb54c4bc51c8bbfa14e4db0f048b" translate="yes" xml:space="preserve">
          <source>Indicates unfinished code.</source>
          <target state="translated">완료되지 않은 코드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="35472c24a202b583e18e139d3d561c6674911e84" translate="yes" xml:space="preserve">
          <source>Indicates unimplemented code by panicking with a message of &quot;not implemented&quot;.</source>
          <target state="translated">&quot;구현되지 않음&quot;이라는 메시지와 함께 당황하여 구현되지 않은 코드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4862445239fb7cd37f48e6ace7775dcd354d2d14" translate="yes" xml:space="preserve">
          <source>Indicates unreachable code.</source>
          <target state="translated">연결할 수없는 코드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cd5cea6e94489fba68a0399bcc4d11feffb0cbe4" translate="yes" xml:space="preserve">
          <source>Indicates whether a value is available or if the current task has been scheduled to receive a wakeup instead.</source>
          <target state="translated">값을 사용할 수 있는지 또는 현재 작업이 웨이크 업을 받도록 예약되었는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a5d9b716629f981c5e75c2880c16718258347eb9" translate="yes" xml:space="preserve">
          <source>Indication that contents should be center-aligned.</source>
          <target state="translated">내용이 중앙 정렬되어야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="582259f836deeb40225aa78333ee7027acddbdbe" translate="yes" xml:space="preserve">
          <source>Indication that contents should be left-aligned.</source>
          <target state="translated">내용이 왼쪽 정렬되어야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="30524864694504eb9866802047ab21c114fa2091" translate="yes" xml:space="preserve">
          <source>Indication that contents should be right-aligned.</source>
          <target state="translated">내용이 올바르게 정렬되어야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f2cd68a3153c21de89ed40993772ed6007b02a6f" translate="yes" xml:space="preserve">
          <source>Indices are zero-based for arrays and slices. Array access is a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, so bounds can be checked at compile-time with a constant index value. Otherwise a check will be performed at run-time that will put the thread in a &lt;em&gt;panicked state&lt;/em&gt; if it fails.</source>
          <target state="translated">인덱스는 배열과 슬라이스에 대해 0부터 시작합니다. 배열 액세스는 &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;상수 표현식&lt;/a&gt; 이므로 컴파일 타임에 상수 인덱스 값으로 경계를 확인할 수 있습니다. 그렇지 않으면 스레드 가 실패한 경우 스레드를 &lt;em&gt;패닉 상태로&lt;/em&gt; 만드는 검사가 런타임에 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7d8ee4a5140f0e6e32c94f9ff32453c7e40a4a3" translate="yes" xml:space="preserve">
          <source>Inequality for two &lt;code&gt;Arc&lt;/code&gt;s.</source>
          <target state="translated">두 개의 &lt;code&gt;Arc&lt;/code&gt; 대한 불평등 .</target>
        </trans-unit>
        <trans-unit id="8aa90054db987f32eec9e62690e9b9862d6f642a" translate="yes" xml:space="preserve">
          <source>Inequality for two &lt;code&gt;Rc&lt;/code&gt;s.</source>
          <target state="translated">두 &lt;code&gt;Rc&lt;/code&gt; 에 대한 불평등 .</target>
        </trans-unit>
        <trans-unit id="5d55264281a8b8357477a0b1f6f6a4a72582a08d" translate="yes" xml:space="preserve">
          <source>Inert helper attributes used by procedural macro attributes applied to items are also allowed but be careful to not include these inert attributes in your final &lt;code&gt;TokenStream&lt;/code&gt;.</source>
          <target state="translated">항목에 적용된 절차 적 매크로 속성에서 사용하는 비활성 도우미 속성도 허용되지만 이러한 비활성 속성을 최종 &lt;code&gt;TokenStream&lt;/code&gt; 에 포함하지 않도록주의하세요 .</target>
        </trans-unit>
        <trans-unit id="32565cc43897d204c904c25aeddc29a5a2fe5f4d" translate="yes" xml:space="preserve">
          <source>Infallible</source>
          <target state="translated">Infallible</target>
        </trans-unit>
        <trans-unit id="327440953e8036a6b78b97c190dedc5d1ddc1d6f" translate="yes" xml:space="preserve">
          <source>Infallible errors</source>
          <target state="translated">완벽한 오류</target>
        </trans-unit>
        <trans-unit id="379d563f62e4c026be425a08a60de86e8b28b34e" translate="yes" xml:space="preserve">
          <source>Infallible::borrow</source>
          <target state="translated">Infallible::borrow</target>
        </trans-unit>
        <trans-unit id="ffd9adf91cadc5963cf564501d6440dfcb9953d6" translate="yes" xml:space="preserve">
          <source>Infallible::borrow_mut</source>
          <target state="translated">Infallible::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d5161b5d2a0dd973c7749267f912225db6f86b3c" translate="yes" xml:space="preserve">
          <source>Infallible::clamp</source>
          <target state="translated">Infallible::clamp</target>
        </trans-unit>
        <trans-unit id="f9dfe17efa7693fd64ca4bce650f4693dec46e6a" translate="yes" xml:space="preserve">
          <source>Infallible::clone</source>
          <target state="translated">Infallible::clone</target>
        </trans-unit>
        <trans-unit id="7c7c7505a3bdd3e6bbbfabe3c0aa36eea42c2f97" translate="yes" xml:space="preserve">
          <source>Infallible::clone_from</source>
          <target state="translated">Infallible::clone_from</target>
        </trans-unit>
        <trans-unit id="6af6b86ef345c274a60c49262dbedb50a8323471" translate="yes" xml:space="preserve">
          <source>Infallible::clone_into</source>
          <target state="translated">Infallible::clone_into</target>
        </trans-unit>
        <trans-unit id="3f4e892d27a40b0bfaf9fee7ba4a2719e5f0e03b" translate="yes" xml:space="preserve">
          <source>Infallible::cmp</source>
          <target state="translated">Infallible::cmp</target>
        </trans-unit>
        <trans-unit id="465ca79819acd2f64e9c25bd2a18d141db20f7e4" translate="yes" xml:space="preserve">
          <source>Infallible::eq</source>
          <target state="translated">Infallible::eq</target>
        </trans-unit>
        <trans-unit id="7b0120f9faa0f0e51d2f41f2228ccb58415bb901" translate="yes" xml:space="preserve">
          <source>Infallible::fmt</source>
          <target state="translated">Infallible::fmt</target>
        </trans-unit>
        <trans-unit id="7699715e87167505521e297f0cc5acf9571073ba" translate="yes" xml:space="preserve">
          <source>Infallible::from</source>
          <target state="translated">Infallible::from</target>
        </trans-unit>
        <trans-unit id="9ed64ca1536a61aeb71e791f8b0cd35996768800" translate="yes" xml:space="preserve">
          <source>Infallible::ge</source>
          <target state="translated">Infallible::ge</target>
        </trans-unit>
        <trans-unit id="6bc6944b5c980e7843d508d02dcd2bfaf58a503d" translate="yes" xml:space="preserve">
          <source>Infallible::gt</source>
          <target state="translated">Infallible::gt</target>
        </trans-unit>
        <trans-unit id="be25a1605cddc636f6f076ea8d21d97812f2aa85" translate="yes" xml:space="preserve">
          <source>Infallible::into</source>
          <target state="translated">Infallible::into</target>
        </trans-unit>
        <trans-unit id="acae0cd14002a94fe132d6ca88f1fdd5ca563403" translate="yes" xml:space="preserve">
          <source>Infallible::le</source>
          <target state="translated">Infallible::le</target>
        </trans-unit>
        <trans-unit id="2b7d09de5fbcd932797ca9cc160818ef628164b0" translate="yes" xml:space="preserve">
          <source>Infallible::lt</source>
          <target state="translated">Infallible::lt</target>
        </trans-unit>
        <trans-unit id="d981e531de4db6af3fa624928233a62cc48506b0" translate="yes" xml:space="preserve">
          <source>Infallible::max</source>
          <target state="translated">Infallible::max</target>
        </trans-unit>
        <trans-unit id="4e77b6f968c067dfd00c877ce693a33816232a84" translate="yes" xml:space="preserve">
          <source>Infallible::min</source>
          <target state="translated">Infallible::min</target>
        </trans-unit>
        <trans-unit id="1b9bdf4c04b01562bf66a579b3902b4d24df2814" translate="yes" xml:space="preserve">
          <source>Infallible::ne</source>
          <target state="translated">Infallible::ne</target>
        </trans-unit>
        <trans-unit id="593cf3934010f07d135bbd81984d0e7b07060f05" translate="yes" xml:space="preserve">
          <source>Infallible::partial_cmp</source>
          <target state="translated">Infallible::partial_cmp</target>
        </trans-unit>
        <trans-unit id="171d7fff4d94e2b47d18a78e5a1c94a683078c15" translate="yes" xml:space="preserve">
          <source>Infallible::to_owned</source>
          <target state="translated">Infallible::to_owned</target>
        </trans-unit>
        <trans-unit id="256be91884f5591734d76be10903ead44c9f209f" translate="yes" xml:space="preserve">
          <source>Infallible::to_string</source>
          <target state="translated">Infallible::to_string</target>
        </trans-unit>
        <trans-unit id="c3635403870a783a099eedcae587acfb8a52bc1f" translate="yes" xml:space="preserve">
          <source>Infallible::try_from</source>
          <target state="translated">Infallible::try_from</target>
        </trans-unit>
        <trans-unit id="3c8ee4706115d8499f3abf4d51e35db72e1ffd2e" translate="yes" xml:space="preserve">
          <source>Infallible::try_into</source>
          <target state="translated">Infallible::try_into</target>
        </trans-unit>
        <trans-unit id="9701bd213ca2d8e7962b353284539a737fba44f7" translate="yes" xml:space="preserve">
          <source>Infallible::type_id</source>
          <target state="translated">Infallible::type_id</target>
        </trans-unit>
        <trans-unit id="c548ca9534f0b8a6c18d5933d5460cae1f620bec" translate="yes" xml:space="preserve">
          <source>Inferred type</source>
          <target state="translated">유추 된 유형</target>
        </trans-unit>
        <trans-unit id="85dc47997d86458573535c2b6419f71eaedb8bec" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;Iterator::take()&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">&lt;code&gt;repeat()&lt;/code&gt; 와 같은 무한 반복기 는 종종 &lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;Iterator::take()&lt;/code&gt; &lt;/a&gt; 와 같은 어댑터와 함께 사용되어 유한하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5b827f3090a9999d7251035ec3accdcd8d4fbe7d" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">&lt;code&gt;repeat()&lt;/code&gt; 과 같은 무한 반복자 는 종종이를 한정하기 위해 &lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 와 같은 어댑터와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2872d343e29a3d0faf1e93a846c0ad3b8146eceb" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat_with()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;Iterator::take()&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">&lt;code&gt;repeat_with()&lt;/code&gt; 와 같은 무한 반복자 는 &lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;Iterator::take()&lt;/code&gt; &lt;/a&gt; 와 같은 어댑터와 함께 사용하여 유한하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e414b3978173634ff311532d9eb1dc73109f5119" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat_with()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">&lt;code&gt;repeat_with()&lt;/code&gt; 와 같은 무한 이터레이터 는 종종 그것들을 유한하게 만들기 위해 &lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 와 같은 어댑터와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a2550f47e7bda60f30b73b2126315e72f6a1181f" translate="yes" xml:space="preserve">
          <source>Infinite loops</source>
          <target state="translated">무한 루프</target>
        </trans-unit>
        <trans-unit id="0219fd54bd5841008b18c414a5b2dea331bad1c5" translate="yes" xml:space="preserve">
          <source>Infinity</source>
          <target state="translated">Infinity</target>
        </trans-unit>
        <trans-unit id="2caa9882f0053ecda17ba6be06a5251c1ec2645f" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;).</source>
          <target state="translated">무한대 (&amp;infin;).</target>
        </trans-unit>
        <trans-unit id="87a3bea62fc4aac2370741613d6bad23fc5e7898" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;). Use &lt;a href=&quot;../primitive.f32#associatedconstant.INFINITY&quot;&gt;&lt;code&gt;f32::INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">무한대 (&amp;infin;). 대신 &lt;a href=&quot;../primitive.f32#associatedconstant.INFINITY&quot;&gt; &lt;code&gt;f32::INFINITY&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5889ff563c59beba5ff715c644770f8c520445a" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;). Use &lt;a href=&quot;../primitive.f64#associatedconstant.INFINITY&quot;&gt;&lt;code&gt;f64::INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">무한대 (&amp;infin;). 대신 &lt;a href=&quot;../primitive.f64#associatedconstant.INFINITY&quot;&gt; &lt;code&gt;f64::INFINITY&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="584304393b0ea6955cb4308163835ca022286a68" translate="yes" xml:space="preserve">
          <source>Influences</source>
          <target state="translated">Influences</target>
        </trans-unit>
        <trans-unit id="d42473cc429103c815ee41c99ce227e6800bc064" translate="yes" xml:space="preserve">
          <source>Informally:</source>
          <target state="translated">Informally:</target>
        </trans-unit>
        <trans-unit id="50473fcaee3f0826f522b7d9bde1dee298665a6b" translate="yes" xml:space="preserve">
          <source>Informs the compiler that this point in the code is not reachable, enabling further optimizations.</source>
          <target state="translated">코드에서이 지점에 도달 할 수 없음을 컴파일러에 알리고 추가 최적화를 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="da26edc8a2a6b051f930b8dc35ea3b2d2eb04a3f" translate="yes" xml:space="preserve">
          <source>Informs the optimizer that a condition is always true. If the condition is false, the behavior is undefined.</source>
          <target state="translated">조건이 항상 참임을 옵티 마이저에게 알립니다. 조건이 거짓이면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ae97ac101c4619f2cdd3e3df7584b679394eca7" translate="yes" xml:space="preserve">
          <source>Inhabited</source>
          <target state="translated">Inhabited</target>
        </trans-unit>
        <trans-unit id="b07b5b517980bf88c19321ee29f23f8a21e0b4de" translate="yes" xml:space="preserve">
          <source>Inherent Implementations</source>
          <target state="translated">고유 한 구현</target>
        </trans-unit>
        <trans-unit id="bf73ea65fd18a78a9021507f0c11c78ed2ec5124" translate="yes" xml:space="preserve">
          <source>Inherent associated types were part of &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md&quot;&gt;RFC 195&lt;/a&gt; but are not yet implemented. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/8995&quot;&gt;the tracking issue&lt;/a&gt; for the status of this implementation.</source>
          <target state="translated">고유 한 연관된 ​​유형은 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md&quot;&gt;RFC 195의&lt;/a&gt; 일부 이지만 아직 구현되지 않았습니다. 이 구현 상태에 대한 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/8995&quot;&gt;추적 문제&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f47cc0e78be269b94ff1fbb506eefabb2d14cd1d" translate="yes" xml:space="preserve">
          <source>Inherent implementation</source>
          <target state="translated">고유 구현</target>
        </trans-unit>
        <trans-unit id="89d8c2e2efc6fafd98f5603953f0cb702613d6d3" translate="yes" xml:space="preserve">
          <source>Inherent implementations (one that do not implement a trait but provide methods associated with a type) are always safe because they are not implementing an unsafe trait. Removing the &lt;code&gt;unsafe&lt;/code&gt; keyword from the inherent implementation will resolve this error.</source>
          <target state="translated">고유 한 구현 (특성을 구현하지 않지만 유형과 연관된 메소드를 제공하는 구현)은 안전하지 않은 특성을 구현하지 않기 때문에 항상 안전합니다. 고유 구현에서 &lt;code&gt;unsafe&lt;/code&gt; 키워드를 제거하면 이 오류가 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="02407dbce9ca24cc02710598fc24ae8f49c07a7e" translate="yes" xml:space="preserve">
          <source>Inherent implementations associate the contained items to the implementing type. Inherent implementations can contain &lt;a href=&quot;associated-items#associated-functions-and-methods&quot;&gt;associated functions&lt;/a&gt; (including methods) and &lt;a href=&quot;associated-items#associated-constants&quot;&gt;associated constants&lt;/a&gt;. They cannot contain associated type aliases.</source>
          <target state="translated">고유 구현은 포함 된 항목을 구현 유형에 연관시킵니다. 고유 구현에는 &lt;a href=&quot;associated-items#associated-functions-and-methods&quot;&gt;관련 함수&lt;/a&gt; (메소드 포함) 및 &lt;a href=&quot;associated-items#associated-constants&quot;&gt;관련 상수&lt;/a&gt; 가 포함될 수 있습니다 . 연관된 유형 별명을 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4ccb704ced0ac70357d35287cb1c67388f967d06" translate="yes" xml:space="preserve">
          <source>Inherent method</source>
          <target state="translated">고유 한 방법</target>
        </trans-unit>
        <trans-unit id="c7a774bf3dce2aac99ad48347458653bbd55d325" translate="yes" xml:space="preserve">
          <source>Inherit stdin/stdout/stderr for &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;status&lt;/code&gt;, but create pipes for &lt;code&gt;output&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;spawn&lt;/code&gt; 또는 &lt;code&gt;status&lt;/code&gt; 대해 stdin / stdout / stderr를 상속 하지만 &lt;code&gt;output&lt;/code&gt; 위한 파이프를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="9f4e94fb7b802199fb91e731b50847b79d9607c1" translate="yes" xml:space="preserve">
          <source>Inherit the current process's environment</source>
          <target state="translated">현재 프로세스 환경 상속</target>
        </trans-unit>
        <trans-unit id="44c348c84d3785ac5adb30ee3d2d10f68e971317" translate="yes" xml:space="preserve">
          <source>Inherit the current process's working directory</source>
          <target state="translated">현재 프로세스의 작업 디렉토리 상속</target>
        </trans-unit>
        <trans-unit id="6325b69277e854d2ebda5c6558b946870708063a" translate="yes" xml:space="preserve">
          <source>Inheritance as a Type System and as Code Sharing</source>
          <target state="translated">타입 시스템과 코드 공유로서의 상속</target>
        </trans-unit>
        <trans-unit id="c561edc4e8c488ada0373bbdca70237bf7b2c36a" translate="yes" xml:space="preserve">
          <source>Inheritance has recently fallen out of favor as a programming design solution in many programming languages because it&amp;rsquo;s often at risk of sharing more code than necessary. Subclasses shouldn&amp;rsquo;t always share all characteristics of their parent class but will do so with inheritance. This can make a program&amp;rsquo;s design less flexible. It also introduces the possibility of calling methods on subclasses that don&amp;rsquo;t make sense or that cause errors because the methods don&amp;rsquo;t apply to the subclass. In addition, some languages will only allow a subclass to inherit from one class, further restricting the flexibility of a program&amp;rsquo;s design.</source>
          <target state="translated">상속은 최근에 필요한 것보다 많은 코드를 공유 할 위험이 있기 때문에 많은 프로그래밍 언어에서 프로그래밍 디자인 솔루션으로 선호되지 않습니다. 서브 클래스가 항상 부모 클래스의 모든 특성을 공유하지는 않지만 상속을 통해 그렇게해야합니다. 이로 인해 프로그램 디자인의 유연성이 떨어질 수 있습니다. 또한 이해가되지 않거나 서브 클래스에 적용되지 않기 때문에 오류를 발생시키는 서브 클래스에서 메소드를 호출 할 가능성도 소개합니다. 또한 일부 언어는 서브 클래스가 한 클래스에서만 상속 할 수 있도록하여 프로그램 디자인의 유연성을 더욱 제한합니다.</target>
        </trans-unit>
        <trans-unit id="2e8b04bb573d36dddf2182bf5af08f053f087e52" translate="yes" xml:space="preserve">
          <source>Initial values</source>
          <target state="translated">초기 값</target>
        </trans-unit>
        <trans-unit id="c904b3e1f2d0c5d733b728b7a681f23a1ee75fda" translate="yes" xml:space="preserve">
          <source>Initialization and Destruction</source>
          <target state="translated">초기화와 파괴</target>
        </trans-unit>
        <trans-unit id="13d802cdbafe0031cbe0ff944c50f80b718c2135" translate="yes" xml:space="preserve">
          <source>Initialization invariant</source>
          <target state="translated">불변 초기화</target>
        </trans-unit>
        <trans-unit id="e4de29eb027f99abd844645c1796c2a7a7d72482" translate="yes" xml:space="preserve">
          <source>Initialization is dynamically performed on the first call to &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; within a thread, and values that implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; get destructed when a thread exits. Some caveats apply, which are explained below.</source>
          <target state="translated">초기화 동적으로 최초의 호출시에 수행 &lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 스레드 내에서 구현할 값 &lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt; 할 때 스레드가 종료를 파괴 얻을. 아래에 설명 된 일부 경고가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b12d9d28ca06ab166730d1a0be67505b54f2b263" translate="yes" xml:space="preserve">
          <source>Initialization of a union</source>
          <target state="translated">유니온 초기화</target>
        </trans-unit>
        <trans-unit id="db21316277d9b77e6330bd9b3d2303f36118171f" translate="yes" xml:space="preserve">
          <source>Initialization value for static &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">정적 &lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt; 값의 초기화 값입니다 .</target>
        </trans-unit>
        <trans-unit id="777041461872120636aa50d7bf36c832a7f4df98" translate="yes" xml:space="preserve">
          <source>Initialize a result to &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; before a loop:</source>
          <target state="translated">루프 전에 결과를 &lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="26ac5e37d496de00bf60e19d042275381e3527b3" translate="yes" xml:space="preserve">
          <source>Initialized</source>
          <target state="translated">Initialized</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="cb5407ce66e9cc74c7b9cdad45d317b358a42346" translate="yes" xml:space="preserve">
          <source>Initializer::borrow</source>
          <target state="translated">Initializer::borrow</target>
        </trans-unit>
        <trans-unit id="9329992da7e67d3d87b950443458d66c568d4935" translate="yes" xml:space="preserve">
          <source>Initializer::borrow_mut</source>
          <target state="translated">Initializer::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8b338b461eda8eab3ac52c21c7ba950b55ddab77" translate="yes" xml:space="preserve">
          <source>Initializer::fmt</source>
          <target state="translated">Initializer::fmt</target>
        </trans-unit>
        <trans-unit id="370ad1ce33d717e00bfed251c3d4bf09120c4049" translate="yes" xml:space="preserve">
          <source>Initializer::from</source>
          <target state="translated">Initializer::from</target>
        </trans-unit>
        <trans-unit id="26ef6fd69d6de0da79344847b51c3c8c83e2b8cc" translate="yes" xml:space="preserve">
          <source>Initializer::initialize</source>
          <target state="translated">Initializer::initialize</target>
        </trans-unit>
        <trans-unit id="bdae64fb5268754bb9cc8ae6c8db2ab2a08fdbc3" translate="yes" xml:space="preserve">
          <source>Initializer::into</source>
          <target state="translated">Initializer::into</target>
        </trans-unit>
        <trans-unit id="a79949e93a459b7f8ca5406e877e55f5660e5c75" translate="yes" xml:space="preserve">
          <source>Initializer::nop</source>
          <target state="translated">Initializer::nop</target>
        </trans-unit>
        <trans-unit id="dcb257db32b009bda392da62101575610abd1f91" translate="yes" xml:space="preserve">
          <source>Initializer::should_initialize</source>
          <target state="translated">Initializer::should_initialize</target>
        </trans-unit>
        <trans-unit id="bcab8cf375f63f790f0ce8e05777079bda310ea7" translate="yes" xml:space="preserve">
          <source>Initializer::try_from</source>
          <target state="translated">Initializer::try_from</target>
        </trans-unit>
        <trans-unit id="1ce33c3dc308ea20a9c3e23385d3fd4e6cdbc2f0" translate="yes" xml:space="preserve">
          <source>Initializer::try_into</source>
          <target state="translated">Initializer::try_into</target>
        </trans-unit>
        <trans-unit id="7015bd93154feb364c2957b0fc2cdb3fe5bb0863" translate="yes" xml:space="preserve">
          <source>Initializer::type_id</source>
          <target state="translated">Initializer::type_id</target>
        </trans-unit>
        <trans-unit id="38d15bea38cc632ed42db7368869a2581cd9ac0d" translate="yes" xml:space="preserve">
          <source>Initializer::zeroing</source>
          <target state="translated">Initializer::zeroing</target>
        </trans-unit>
        <trans-unit id="b02eff8ddabee28d5ce99312e8bd3930e76e09a5" translate="yes" xml:space="preserve">
          <source>Initializes a buffer if necessary.</source>
          <target state="translated">필요한 경우 버퍼를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="c1014a628ca9687c4db754c43f3628d84e3050c5" translate="yes" xml:space="preserve">
          <source>Initializing a struct field-by-field</source>
          <target state="translated">필드별로 구조체 초기화</target>
        </trans-unit>
        <trans-unit id="6d9d88d804a2b918f6a240e649b5e1a2aa5a1b6e" translate="yes" xml:space="preserve">
          <source>Initializing an array element-by-element</source>
          <target state="translated">요소별로 배열 초기화</target>
        </trans-unit>
        <trans-unit id="e30e79f506a4a7b48aa6bd2ea1d1c98586736d96" translate="yes" xml:space="preserve">
          <source>Initially, the Rust team thought that ensuring memory safety and preventing concurrency problems were two separate challenges to be solved with different methods. Over time, the team discovered that the ownership and type systems are a powerful set of tools to help manage memory safety &lt;em&gt;and&lt;/em&gt; concurrency problems! By leveraging ownership and type checking, many concurrency errors are compile-time errors in Rust rather than runtime errors. Therefore, rather than making you spend lots of time trying to reproduce the exact circumstances under which a runtime concurrency bug occurs, incorrect code will refuse to compile and present an error explaining the problem. As a result, you can fix your code while you&amp;rsquo;re working on it rather than potentially after it has been shipped to production. We&amp;rsquo;ve nicknamed this aspect of Rust &lt;em&gt;fearless&lt;/em&gt;&lt;em&gt;concurrency&lt;/em&gt;. Fearless concurrency allows you to write code that is free of subtle bugs and is easy to refactor without introducing new bugs.</source>
          <target state="translated">처음에 Rust 팀은 메모리 안전을 보장하고 동시성 문제를 방지하는 것이 서로 다른 방법으로 해결해야 할 두 가지 과제라고 생각했습니다. 시간이 지남에 따라 팀은 소유권 및 유형 시스템이 메모리 안전 &lt;em&gt;및&lt;/em&gt;동시성 문제! 소유권과 유형 검사를 활용함으로써 많은 동시성 오류는 런타임 오류가 아닌 Rust의 컴파일 타임 오류입니다. 따라서 런타임 동시성 버그가 발생하는 정확한 상황을 재현하기 위해 많은 시간을 소비하지 않고 잘못된 코드는 컴파일을 거부하고 문제를 설명하는 오류를 나타냅니다. 결과적으로 코드를 프로덕션에 제공 한 후 작업하지 않고 작업하는 동안 코드를 수정할 수 있습니다. 우리는 Rust &lt;em&gt;fearless &lt;/em&gt;&lt;em&gt;concurrency&lt;/em&gt; 의 이러한 측면을 별명으로 지정했습니다 . Fearless Concurrency를 사용하면 미묘한 버그가없고 새로운 버그를 도입하지 않고 리팩토링하기 쉬운 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="377c3360b199ab4bedae33ce6d834fe07f041fe6" translate="yes" xml:space="preserve">
          <source>Inline assembly.</source>
          <target state="translated">인라인 어셈블리.</target>
        </trans-unit>
        <trans-unit id="b7a13c17feda3ff04e933d53202cd41c94dace05" translate="yes" xml:space="preserve">
          <source>Inner attribute</source>
          <target state="translated">내부 속성</target>
        </trans-unit>
        <trans-unit id="565c802152b12c7dd9aea0fe59ebaacf3d1a82a3" translate="yes" xml:space="preserve">
          <source>Inner block doc comment</source>
          <target state="translated">내부 블록 문서 주석</target>
        </trans-unit>
        <trans-unit id="af507067e5f2cec421f889124df4ee46c1a92bbf" translate="yes" xml:space="preserve">
          <source>Inner document can only be used before items. For example:</source>
          <target state="translated">내부 문서는 항목 앞에만 사용할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="5ca5fb7f033a9d40e84c1a1a0c29b149dc2c2561" translate="yes" xml:space="preserve">
          <source>Inner functions do not have access to their containing environment. To fix this error, you can replace the function with a closure:</source>
          <target state="translated">내부 함수는 포함 된 환경에 액세스 할 수 없습니다. 이 오류를 수정하려면 함수를 클로저로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10264f133a74f365cfab7999c77a7091803d2786" translate="yes" xml:space="preserve">
          <source>Inner items do not inherit type or const parameters from the functions they are embedded in.</source>
          <target state="translated">내부 항목은 포함 된 함수에서 유형 또는 const 매개 변수를 상속하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6909dc9a044dcde9a4fe7603daf0a9a52557aba3" translate="yes" xml:space="preserve">
          <source>Inner line doc comment</source>
          <target state="translated">내부 문서 주석</target>
        </trans-unit>
        <trans-unit id="1b77a7f4983f9ce773f466c761a7f6e9771bf925" translate="yes" xml:space="preserve">
          <source>Input format</source>
          <target state="translated">입력 형식</target>
        </trans-unit>
        <trans-unit id="daf107c7f6d6d3a06676862d762621e314a3de24" translate="yes" xml:space="preserve">
          <source>Insert and complex keys</source>
          <target state="translated">삽입 및 복잡한 키</target>
        </trans-unit>
        <trans-unit id="3d9eeb934e6164d2c24b6394e6758d068509ccb2" translate="yes" xml:space="preserve">
          <source>Insertion and popping the largest element have &lt;code&gt;O(log n)&lt;/code&gt; time complexity. Checking the largest element is &lt;code&gt;O(1)&lt;/code&gt;. Converting a vector to a binary heap can be done in-place, and has &lt;code&gt;O(n)&lt;/code&gt; complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to be used for an &lt;code&gt;O(n log n)&lt;/code&gt; in-place heapsort.</source>
          <target state="translated">가장 큰 원소를 삽입하고 터지는 것은 &lt;code&gt;O(log n)&lt;/code&gt; 시간 복잡성을 갖는다. 가장 큰 요소를 확인하는 것은 &lt;code&gt;O(1)&lt;/code&gt; 입니다. 벡터를 이진 힙으로 변환하는 작업은 제자리에서 수행 할 수 있으며 &lt;code&gt;O(n)&lt;/code&gt; 복잡도를 갖습니다 . 이진 힙을 정렬 된 벡터로 변환하여 &lt;code&gt;O(n log n)&lt;/code&gt; 인플레 이스 힙 정렬에 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3054fc5d210400311e9f74c38361908c7518246" translate="yes" xml:space="preserve">
          <source>Insertion and popping the largest element have &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)) time complexity. Checking the largest element is &lt;em&gt;O&lt;/em&gt;(1). Converting a vector to a binary heap can be done in-place, and has &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to be used for an &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) in-place heapsort.</source>
          <target state="translated">가장 큰 요소를 삽입하고 팝하는 데는 &lt;em&gt;O&lt;/em&gt; (log ( &lt;em&gt;n&lt;/em&gt; )) 시간 복잡도가 있습니다. 가장 큰 요소를 확인하는 것은 &lt;em&gt;O&lt;/em&gt; (1)입니다. 벡터를 이진 힙으로 변환하는 것은 제자리에서 수행 할 수 있으며 복잡성 은 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; )입니다. 바이너리 힙은 내부에서 정렬 된 벡터로 변환되어 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; * log ( &lt;em&gt;n&lt;/em&gt; )) 내부 힙 정렬에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0b51cb1a3f7392b32f519dbb88d97e332d11c69" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; into the option if it is &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">&lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;code&gt;v&lt;/code&gt; 를 옵션에 삽입 한 다음 포함 된 값에 대한 변경 가능한 참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ea064b5e532406cd5efbee55897b1c3c1824866f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; into the option if it is &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">&lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 옵션에 &lt;code&gt;v&lt;/code&gt; 를 삽입 한 다음 포함 된 값에 대한 변경 가능한 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="633ef776ac14fc1a5ba3722ac27ba6e3e9e74927" translate="yes" xml:space="preserve">
          <source>Inserts a character into this &lt;code&gt;String&lt;/code&gt; at a byte position.</source>
          <target state="translated">바이트 위치 에서이 &lt;code&gt;String&lt;/code&gt; 에 문자를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="0a96531a2ad16ab4c68e8dd30a04fcb8b88d0c9e" translate="yes" xml:space="preserve">
          <source>Inserts a key-value pair into the map.</source>
          <target state="translated">키-값 쌍을 맵에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="6f07650e645ae306862b323d418b09fad3b7f7a0" translate="yes" xml:space="preserve">
          <source>Inserts a string slice into this &lt;code&gt;String&lt;/code&gt; at a byte position.</source>
          <target state="translated">바이트 위치 에서이 &lt;code&gt;String&lt;/code&gt; 에 문자열 슬라이스를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="7d8655d30bbaeaee48aa3f55378c0fe2a4d62e4c" translate="yes" xml:space="preserve">
          <source>Inserts a value computed from &lt;code&gt;f&lt;/code&gt; into the option if it is &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">&lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;code&gt;f&lt;/code&gt; 에서 계산 된 값을 옵션에 삽입 한 다음 포함 된 값에 대한 변경 가능한 참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cf859e7e91bd94533ccef650a59dbaf129cf0d1c" translate="yes" xml:space="preserve">
          <source>Inserts a value computed from &lt;code&gt;f&lt;/code&gt; into the option if it is &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">&lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;code&gt;f&lt;/code&gt; 에서 계산 된 값을 옵션에 삽입 한 다음 포함 된 값에 대한 가변 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bd878e1d7609b46228a7e1a93fb6e8fa8ab178e1" translate="yes" xml:space="preserve">
          <source>Inserts a value computed from &lt;code&gt;f&lt;/code&gt; into the set if the given &lt;code&gt;value&lt;/code&gt; is not present, then returns a reference to the value in the set.</source>
          <target state="translated">주어진 &lt;code&gt;value&lt;/code&gt; 이 없으면 &lt;code&gt;f&lt;/code&gt; 에서 계산 된 값을 집합에 삽입 한 다음 집합의 값에 대한 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e4c367e5c15ba31d0f216cb7099e2418408fa476" translate="yes" xml:space="preserve">
          <source>Inserts all new key-values from the iterator and replaces values with existing keys with new values returned from the iterator.</source>
          <target state="translated">반복기에서 모든 새 키-값을 삽입하고 값을 반복기에서 반환 된 새 값으로 기존 키로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="033e5469d3495f120ca34f88432068fa89f314f7" translate="yes" xml:space="preserve">
          <source>Inserts an element at &lt;code&gt;index&lt;/code&gt; within the &lt;code&gt;VecDeque&lt;/code&gt;, shifting all elements with indices greater than or equal to &lt;code&gt;index&lt;/code&gt; towards the back.</source>
          <target state="translated">요소에 삽입 &lt;code&gt;index&lt;/code&gt; 내의 &lt;code&gt;VecDeque&lt;/code&gt; 보다 큰 인덱스 모든 요소를 시프 팅 또는 동일한 &lt;code&gt;index&lt;/code&gt; 뒤쪽.</target>
        </trans-unit>
        <trans-unit id="12d5beb4f208ab2afd01a906d06c0928be9bf9f4" translate="yes" xml:space="preserve">
          <source>Inserts an element at position &lt;code&gt;index&lt;/code&gt; within the vector, shifting all elements after it to the right.</source>
          <target state="translated">벡터 내의 위치 &lt;code&gt;index&lt;/code&gt; 요소를 삽입하고 모든 요소를 ​​오른쪽으로 이동시킵니다.</target>
        </trans-unit>
        <trans-unit id="9bb4759e4324e0dbf38962bc28c2aed1b8022c83" translate="yes" xml:space="preserve">
          <source>Inserts an owned copy of the given &lt;code&gt;value&lt;/code&gt; into the set if it is not present, then returns a reference to the value in the set.</source>
          <target state="translated">주어진 &lt;code&gt;value&lt;/code&gt; 의 소유 된 복사본 이없는 경우 집합에 삽입 한 다음 집합의 값에 대한 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="32004441f1f355a905cf795d20839963739fd9b1" translate="yes" xml:space="preserve">
          <source>Inserts or updates an environment variable mapping.</source>
          <target state="translated">환경 변수 매핑을 삽입하거나 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="ec935fc4eff4c401230b5e9494768220ac04ae85" translate="yes" xml:space="preserve">
          <source>Inserts the given &lt;code&gt;value&lt;/code&gt; into the set if it is not present, then returns a reference to the value in the set.</source>
          <target state="translated">지정된 &lt;code&gt;value&lt;/code&gt; 이없는 경우 세트에 주어진 값 을 삽입 한 다음 세트의 값에 대한 참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="10a95bea4ce01379ab8d7b752bb3fe35f6abf8b1" translate="yes" xml:space="preserve">
          <source>Inserts the given element just after the element most recently returned by &lt;code&gt;.next()&lt;/code&gt;. The inserted element does not appear in the iteration.</source>
          <target state="translated">&lt;code&gt;.next()&lt;/code&gt; 가장 최근에 반환 한 요소 바로 뒤에 주어진 요소를 삽입합니다 . 삽입 된 요소가 반복에 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af470e35471ccbf3c83cd6c715dc2e1540c10617" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;for&lt;/code&gt; loop, we search for the byte that represents the space by using the byte literal syntax. If we find a space, we return the position. Otherwise, we return the length of the string by using &lt;code&gt;s.len()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프 안에서 바이트 리터럴 구문을 사용하여 공백을 나타내는 바이트를 검색합니다. 공간을 찾으면 위치를 반환합니다. 그렇지 않으면 &lt;code&gt;s.len()&lt;/code&gt; 을 사용하여 문자열의 길이를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="49f499d15e7cb0aca0c18bf8de68e4d96c591f23" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;main&lt;/code&gt; function is the following code:</source>
          <target state="translated">내부 &lt;code&gt;main&lt;/code&gt; 기능은 다음 코드는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="743099d758832aebc06d09f96504a2db95574113" translate="yes" xml:space="preserve">
          <source>Inside the function signature and body, the name of the type parameter can be used as a type name. &lt;a href=&quot;traits&quot;&gt;Trait&lt;/a&gt; bounds can be specified for type parameters to allow methods with that trait to be called on values of that type. This is specified using the &lt;code&gt;where&lt;/code&gt; syntax:</source>
          <target state="translated">함수 시그니처 및 본문 내에서 type 매개 변수의 이름을 유형 이름으로 사용할 수 있습니다. 유형 &lt;a href=&quot;traits&quot;&gt;특성에 대해 특성&lt;/a&gt; 한계를 지정하여 해당 특성을 가진 메소드를 해당 유형의 값에서 호출 할 수 있습니다. 이것은 &lt;code&gt;where&lt;/code&gt; 구문을 사용하여 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="18ca87afec4298d9de864e32b4eeb6a31786e496" translate="yes" xml:space="preserve">
          <source>Inspect</source>
          <target state="translated">Inspect</target>
        </trans-unit>
        <trans-unit id="82ab79e7a84c19ee615f55de9576c57f6039cbaf" translate="yes" xml:space="preserve">
          <source>Inspect::all</source>
          <target state="translated">Inspect::all</target>
        </trans-unit>
        <trans-unit id="af62c7ee7c236c7e17a30a78c2b4fcf9f79c0b4b" translate="yes" xml:space="preserve">
          <source>Inspect::any</source>
          <target state="translated">Inspect::any</target>
        </trans-unit>
        <trans-unit id="b077905231123238f4a7bb9fcc60ce75f6089a93" translate="yes" xml:space="preserve">
          <source>Inspect::borrow</source>
          <target state="translated">Inspect::borrow</target>
        </trans-unit>
        <trans-unit id="dac186ed9d0b7d57d599f5ce890d1950aca83d7e" translate="yes" xml:space="preserve">
          <source>Inspect::borrow_mut</source>
          <target state="translated">Inspect::borrow_mut</target>
        </trans-unit>
        <trans-unit id="eff030734cfa782924c1060ba45ae2c9617ddff7" translate="yes" xml:space="preserve">
          <source>Inspect::by_ref</source>
          <target state="translated">Inspect::by_ref</target>
        </trans-unit>
        <trans-unit id="c6e04f66ee740f870c7db51ddce5c394c1f5b366" translate="yes" xml:space="preserve">
          <source>Inspect::chain</source>
          <target state="translated">Inspect::chain</target>
        </trans-unit>
        <trans-unit id="af5a3161569b3cc4b1af16e096368ee36af988fd" translate="yes" xml:space="preserve">
          <source>Inspect::clone</source>
          <target state="translated">Inspect::clone</target>
        </trans-unit>
        <trans-unit id="4b8f1150495fa883babb18b3738d6b381ca35719" translate="yes" xml:space="preserve">
          <source>Inspect::clone_from</source>
          <target state="translated">Inspect::clone_from</target>
        </trans-unit>
        <trans-unit id="f20fee187ea64cd2682fd76ef634f46c65ea7337" translate="yes" xml:space="preserve">
          <source>Inspect::clone_into</source>
          <target state="translated">Inspect::clone_into</target>
        </trans-unit>
        <trans-unit id="91d60f6fbbeb3649b6191055cd46e14268f30490" translate="yes" xml:space="preserve">
          <source>Inspect::cloned</source>
          <target state="translated">Inspect::cloned</target>
        </trans-unit>
        <trans-unit id="85a2573bc9e0fcf94624c4b800d4b5742004e819" translate="yes" xml:space="preserve">
          <source>Inspect::cmp</source>
          <target state="translated">Inspect::cmp</target>
        </trans-unit>
        <trans-unit id="bb80987b9610829409c7cf311bd83c99cafb9358" translate="yes" xml:space="preserve">
          <source>Inspect::collect</source>
          <target state="translated">Inspect::collect</target>
        </trans-unit>
        <trans-unit id="6c4755e22c04a1a561bd40c8f7ed7cc9e14afdd5" translate="yes" xml:space="preserve">
          <source>Inspect::copied</source>
          <target state="translated">Inspect::copied</target>
        </trans-unit>
        <trans-unit id="d91465c1eb8c20ff2aaf256018f191b4b51027db" translate="yes" xml:space="preserve">
          <source>Inspect::count</source>
          <target state="translated">Inspect::count</target>
        </trans-unit>
        <trans-unit id="f6a3530affc366af3c3031653f04c92d94544c6f" translate="yes" xml:space="preserve">
          <source>Inspect::cycle</source>
          <target state="translated">Inspect::cycle</target>
        </trans-unit>
        <trans-unit id="2ef8727649c440036fbfd895887f256337974360" translate="yes" xml:space="preserve">
          <source>Inspect::enumerate</source>
          <target state="translated">Inspect::enumerate</target>
        </trans-unit>
        <trans-unit id="90d29ac40ce8f2f13585d9242b559870d571b0d2" translate="yes" xml:space="preserve">
          <source>Inspect::eq</source>
          <target state="translated">Inspect::eq</target>
        </trans-unit>
        <trans-unit id="3c8af74b0f8d034e93cc2689eb1582aea35cd194" translate="yes" xml:space="preserve">
          <source>Inspect::filter</source>
          <target state="translated">Inspect::filter</target>
        </trans-unit>
        <trans-unit id="0c1d967d962d5542a61729409b6700ebf061e41a" translate="yes" xml:space="preserve">
          <source>Inspect::filter_map</source>
          <target state="translated">Inspect::filter_map</target>
        </trans-unit>
        <trans-unit id="ef11d99b08eee4456cbbcf30c8d5eaf30c8a59bd" translate="yes" xml:space="preserve">
          <source>Inspect::find</source>
          <target state="translated">Inspect::find</target>
        </trans-unit>
        <trans-unit id="de75c9aaf20b405a1c60fd94f4dbe93e04bb79b9" translate="yes" xml:space="preserve">
          <source>Inspect::find_map</source>
          <target state="translated">Inspect::find_map</target>
        </trans-unit>
        <trans-unit id="4bdd706bdfb04e01d1c9af213d5586e2748a2444" translate="yes" xml:space="preserve">
          <source>Inspect::flat_map</source>
          <target state="translated">Inspect::flat_map</target>
        </trans-unit>
        <trans-unit id="adc62575b9ec6c48f327e8e73d67dd12a37fd54f" translate="yes" xml:space="preserve">
          <source>Inspect::flatten</source>
          <target state="translated">Inspect::flatten</target>
        </trans-unit>
        <trans-unit id="bf64f53f8ddafacb88390ac8654fa5e287a73a7c" translate="yes" xml:space="preserve">
          <source>Inspect::fmt</source>
          <target state="translated">Inspect::fmt</target>
        </trans-unit>
        <trans-unit id="e1203b82ecf5e7d86eeb57728448c3072c4d31ca" translate="yes" xml:space="preserve">
          <source>Inspect::fold</source>
          <target state="translated">Inspect::fold</target>
        </trans-unit>
        <trans-unit id="e36f213246f9d2f573670ffad6151bd06e3fa586" translate="yes" xml:space="preserve">
          <source>Inspect::for_each</source>
          <target state="translated">Inspect::for_each</target>
        </trans-unit>
        <trans-unit id="e7c3f5132be9e5287630addcdee29ef7865ef06d" translate="yes" xml:space="preserve">
          <source>Inspect::from</source>
          <target state="translated">Inspect::from</target>
        </trans-unit>
        <trans-unit id="fe4bfacc82f6be56fbd2cbdacbd9f9c98dbeb4d0" translate="yes" xml:space="preserve">
          <source>Inspect::fuse</source>
          <target state="translated">Inspect::fuse</target>
        </trans-unit>
        <trans-unit id="18e6f5734f2efd739f3505c74a0c0d087a45dc44" translate="yes" xml:space="preserve">
          <source>Inspect::ge</source>
          <target state="translated">Inspect::ge</target>
        </trans-unit>
        <trans-unit id="51b9499c2f6bcf728ec327afb3eadb4e80054ef7" translate="yes" xml:space="preserve">
          <source>Inspect::gt</source>
          <target state="translated">Inspect::gt</target>
        </trans-unit>
        <trans-unit id="df78def6e9a15f9326fc866aa7162363317dfe3c" translate="yes" xml:space="preserve">
          <source>Inspect::inspect</source>
          <target state="translated">Inspect::inspect</target>
        </trans-unit>
        <trans-unit id="cde84bc6a1ac6acfa3ca27e39148f1683f7a639a" translate="yes" xml:space="preserve">
          <source>Inspect::into</source>
          <target state="translated">Inspect::into</target>
        </trans-unit>
        <trans-unit id="0c85f8b299a3868a074eadb647478881cca1f5f2" translate="yes" xml:space="preserve">
          <source>Inspect::into_iter</source>
          <target state="translated">Inspect::into_iter</target>
        </trans-unit>
        <trans-unit id="93bdbca2f9e35d0382950f48be8119f4c4cd8c39" translate="yes" xml:space="preserve">
          <source>Inspect::is_empty</source>
          <target state="translated">Inspect::is_empty</target>
        </trans-unit>
        <trans-unit id="6cb061e34832197156e0eae9b796318c52eae21c" translate="yes" xml:space="preserve">
          <source>Inspect::is_sorted</source>
          <target state="translated">Inspect::is_sorted</target>
        </trans-unit>
        <trans-unit id="0b700978aa9715e5aeabd053030f7e06e5dfdbe8" translate="yes" xml:space="preserve">
          <source>Inspect::is_sorted_by</source>
          <target state="translated">Inspect::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="01522e5b03123c9816813cfbecb670d36dcf9bae" translate="yes" xml:space="preserve">
          <source>Inspect::is_sorted_by_key</source>
          <target state="translated">Inspect::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="97c7968340cdbfc55e6279e63210f8319602c3b1" translate="yes" xml:space="preserve">
          <source>Inspect::last</source>
          <target state="translated">Inspect::last</target>
        </trans-unit>
        <trans-unit id="1641c5ab204a86bd76b52647b967fa3844ee555e" translate="yes" xml:space="preserve">
          <source>Inspect::le</source>
          <target state="translated">Inspect::le</target>
        </trans-unit>
        <trans-unit id="8fedbf984d9131a9c32910d0dd8cd507c9ae41f1" translate="yes" xml:space="preserve">
          <source>Inspect::len</source>
          <target state="translated">Inspect::len</target>
        </trans-unit>
        <trans-unit id="2aae13f70bf251eedf4d622e3c8e8d7ebe509466" translate="yes" xml:space="preserve">
          <source>Inspect::lt</source>
          <target state="translated">Inspect::lt</target>
        </trans-unit>
        <trans-unit id="3c10daeba2bb0af4fb652f56b13c4f712081ee60" translate="yes" xml:space="preserve">
          <source>Inspect::map</source>
          <target state="translated">Inspect::map</target>
        </trans-unit>
        <trans-unit id="d7ab985e5175dcb4007a24ad2073cd92e1ee725b" translate="yes" xml:space="preserve">
          <source>Inspect::max</source>
          <target state="translated">Inspect::max</target>
        </trans-unit>
        <trans-unit id="5548cb84f4f36e68e97b0766437c90e71bec388e" translate="yes" xml:space="preserve">
          <source>Inspect::max_by</source>
          <target state="translated">Inspect::max_by</target>
        </trans-unit>
        <trans-unit id="dce539004497e98e80382919f2b44ac4f343a42e" translate="yes" xml:space="preserve">
          <source>Inspect::max_by_key</source>
          <target state="translated">Inspect::max_by_key</target>
        </trans-unit>
        <trans-unit id="588f749d074427554e4d2614e02fff13ad9cd053" translate="yes" xml:space="preserve">
          <source>Inspect::min</source>
          <target state="translated">Inspect::min</target>
        </trans-unit>
        <trans-unit id="60fe678c3fd98d803d7a0a967cf63b451cdaf79c" translate="yes" xml:space="preserve">
          <source>Inspect::min_by</source>
          <target state="translated">Inspect::min_by</target>
        </trans-unit>
        <trans-unit id="2487d43ef493a331b1b717bc22f40361c1ef635a" translate="yes" xml:space="preserve">
          <source>Inspect::min_by_key</source>
          <target state="translated">Inspect::min_by_key</target>
        </trans-unit>
        <trans-unit id="ffc55c77a0a3cf78936319f186df9927df3e0ccd" translate="yes" xml:space="preserve">
          <source>Inspect::ne</source>
          <target state="translated">Inspect::ne</target>
        </trans-unit>
        <trans-unit id="a43fcb5b031c0ce3926f10977d7f6a10a43f6208" translate="yes" xml:space="preserve">
          <source>Inspect::next</source>
          <target state="translated">Inspect::next</target>
        </trans-unit>
        <trans-unit id="6febe3467ee6ea45f701752f64651a80fe8404ab" translate="yes" xml:space="preserve">
          <source>Inspect::next_back</source>
          <target state="translated">Inspect::next_back</target>
        </trans-unit>
        <trans-unit id="0f9d290f3781cb4ac95ed05a1829eb899359b7f9" translate="yes" xml:space="preserve">
          <source>Inspect::nth</source>
          <target state="translated">Inspect::nth</target>
        </trans-unit>
        <trans-unit id="633dbdd78d8cdd2854d53a34adbb447ab4e90331" translate="yes" xml:space="preserve">
          <source>Inspect::nth_back</source>
          <target state="translated">Inspect::nth_back</target>
        </trans-unit>
        <trans-unit id="fc4ec8ac3236397826a770a15ac100842f901223" translate="yes" xml:space="preserve">
          <source>Inspect::partial_cmp</source>
          <target state="translated">Inspect::partial_cmp</target>
        </trans-unit>
        <trans-unit id="40853e163585e56c8285d38aa5808ca70dc06c35" translate="yes" xml:space="preserve">
          <source>Inspect::partition</source>
          <target state="translated">Inspect::partition</target>
        </trans-unit>
        <trans-unit id="9434c28e5a571fffcf6e901ec452b5ae6a98ab38" translate="yes" xml:space="preserve">
          <source>Inspect::peekable</source>
          <target state="translated">Inspect::peekable</target>
        </trans-unit>
        <trans-unit id="43968189a660c3e4fac603b379bde0cd86ad697c" translate="yes" xml:space="preserve">
          <source>Inspect::position</source>
          <target state="translated">Inspect::position</target>
        </trans-unit>
        <trans-unit id="89b4972ffab1f05ea2fbde1d69c01d599123b156" translate="yes" xml:space="preserve">
          <source>Inspect::product</source>
          <target state="translated">Inspect::product</target>
        </trans-unit>
        <trans-unit id="0443653aa8a5d69a1b0d33c9f17e2c9254f5f5d7" translate="yes" xml:space="preserve">
          <source>Inspect::rev</source>
          <target state="translated">Inspect::rev</target>
        </trans-unit>
        <trans-unit id="7cb21ca083cda72535e929cef63f871b4f3cf651" translate="yes" xml:space="preserve">
          <source>Inspect::rfind</source>
          <target state="translated">Inspect::rfind</target>
        </trans-unit>
        <trans-unit id="f79e10ec84996051e8312ada6ac965fccb6846de" translate="yes" xml:space="preserve">
          <source>Inspect::rfold</source>
          <target state="translated">Inspect::rfold</target>
        </trans-unit>
        <trans-unit id="f78976291c9758ab5955ca36b2caedb636e425a2" translate="yes" xml:space="preserve">
          <source>Inspect::rposition</source>
          <target state="translated">Inspect::rposition</target>
        </trans-unit>
        <trans-unit id="2392835414c1e0b5afa2ace3b96de2ef5ff9083c" translate="yes" xml:space="preserve">
          <source>Inspect::scan</source>
          <target state="translated">Inspect::scan</target>
        </trans-unit>
        <trans-unit id="3e468495e996e3f520360765bb1983040761bf4d" translate="yes" xml:space="preserve">
          <source>Inspect::size_hint</source>
          <target state="translated">Inspect::size_hint</target>
        </trans-unit>
        <trans-unit id="65d5d88728cb3772dee70aa6ae26fe906858cdfa" translate="yes" xml:space="preserve">
          <source>Inspect::skip</source>
          <target state="translated">Inspect::skip</target>
        </trans-unit>
        <trans-unit id="e4df02a7fa585f7bf67e2c2e7620ec2b27bf223a" translate="yes" xml:space="preserve">
          <source>Inspect::skip_while</source>
          <target state="translated">Inspect::skip_while</target>
        </trans-unit>
        <trans-unit id="81611aac4ee662fdf8e1bb6309a5396db2852250" translate="yes" xml:space="preserve">
          <source>Inspect::step_by</source>
          <target state="translated">Inspect::step_by</target>
        </trans-unit>
        <trans-unit id="333ad3419c346fac8b8d3c0fd4cc6a07785ed3a9" translate="yes" xml:space="preserve">
          <source>Inspect::sum</source>
          <target state="translated">Inspect::sum</target>
        </trans-unit>
        <trans-unit id="07c4846ffa005c2b497a796ecdc14a564003a4a8" translate="yes" xml:space="preserve">
          <source>Inspect::take</source>
          <target state="translated">Inspect::take</target>
        </trans-unit>
        <trans-unit id="4f28a1534dff8b2e2c944f0bfaafe96286e1baaa" translate="yes" xml:space="preserve">
          <source>Inspect::take_while</source>
          <target state="translated">Inspect::take_while</target>
        </trans-unit>
        <trans-unit id="2a423ad3eae2fec9385b69311ba93e53244f0ad5" translate="yes" xml:space="preserve">
          <source>Inspect::to_owned</source>
          <target state="translated">Inspect::to_owned</target>
        </trans-unit>
        <trans-unit id="a6362c52c757937e435b1eeef2d9ab055596b389" translate="yes" xml:space="preserve">
          <source>Inspect::try_fold</source>
          <target state="translated">Inspect::try_fold</target>
        </trans-unit>
        <trans-unit id="b44f87043be8c6e37fe81b5e52b558de6e2af9af" translate="yes" xml:space="preserve">
          <source>Inspect::try_for_each</source>
          <target state="translated">Inspect::try_for_each</target>
        </trans-unit>
        <trans-unit id="2933e22002dc23a223d51ac3b5541e6507691dd0" translate="yes" xml:space="preserve">
          <source>Inspect::try_from</source>
          <target state="translated">Inspect::try_from</target>
        </trans-unit>
        <trans-unit id="b21cad5abb074d64e5dc5deb026a557335ea6176" translate="yes" xml:space="preserve">
          <source>Inspect::try_into</source>
          <target state="translated">Inspect::try_into</target>
        </trans-unit>
        <trans-unit id="1fd81bf07a71bc1209ac8f8b1e33f27ed1378a45" translate="yes" xml:space="preserve">
          <source>Inspect::try_rfold</source>
          <target state="translated">Inspect::try_rfold</target>
        </trans-unit>
        <trans-unit id="0e9b8b3f317cc849ace42df081dd27ff57c0541e" translate="yes" xml:space="preserve">
          <source>Inspect::type_id</source>
          <target state="translated">Inspect::type_id</target>
        </trans-unit>
        <trans-unit id="41140164c66c290cc48804ad982a4e7115e22da9" translate="yes" xml:space="preserve">
          <source>Inspect::unzip</source>
          <target state="translated">Inspect::unzip</target>
        </trans-unit>
        <trans-unit id="fe0d4b72621d75d8a76f592b0efd07f85c74dca9" translate="yes" xml:space="preserve">
          <source>Inspect::zip</source>
          <target state="translated">Inspect::zip</target>
        </trans-unit>
        <trans-unit id="8a955d8f62cddda7e4b47eb2772b795f5ac4e929" translate="yes" xml:space="preserve">
          <source>Inspecting a foreign C string:</source>
          <target state="translated">외래 C 문자열 검사 :</target>
        </trans-unit>
        <trans-unit id="24c028aad5e4f71eb7323a7fdf907c77523124b6" translate="yes" xml:space="preserve">
          <source>Inspection and manipulation of the process's environment.</source>
          <target state="translated">공정 환경의 점검 및 조작.</target>
        </trans-unit>
        <trans-unit id="2cc2859dfe537be8955a457d12a963c9483cf55a" translate="yes" xml:space="preserve">
          <source>Inspects an environment variable at compile time.</source>
          <target state="translated">컴파일 타임에 환경 변수를 검사합니다.</target>
        </trans-unit>
        <trans-unit id="da805945f5409d032b925fa086323fea9942dc3f" translate="yes" xml:space="preserve">
          <source>Install binaries from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; 에서 바이너리 설치</target>
        </trans-unit>
        <trans-unit id="27807feadc6086bb00cc2f2fc11c34f918ce0b35" translate="yes" xml:space="preserve">
          <source>Install the latest stable version of Rust using &lt;code&gt;rustup&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rustup&lt;/code&gt; 을 사용하여 최신 안정 버전의 Rust 설치</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="8bc95ab544ffc801a72a650102cb1b4b0031b02c" translate="yes" xml:space="preserve">
          <source>Installing &lt;code id=&quot;installing-rustup-on-linux-or-macos&quot;&gt;rustup&lt;/code&gt; on Linux or macOS</source>
          <target state="translated">Linux 또는 macOS에 &lt;code id=&quot;installing-rustup-on-linux-or-macos&quot;&gt;rustup&lt;/code&gt; 설치</target>
        </trans-unit>
        <trans-unit id="d41546865affb2f20149c73fe77f1fc24d402ca2" translate="yes" xml:space="preserve">
          <source>Installing &lt;code id=&quot;installing-rustup-on-windows&quot;&gt;rustup&lt;/code&gt; on Windows</source>
          <target state="translated">Windows에 &lt;code id=&quot;installing-rustup-on-windows&quot;&gt;rustup&lt;/code&gt; 설치</target>
        </trans-unit>
        <trans-unit id="e19f38815d4acff6e4f527222a8aef2789228129" translate="yes" xml:space="preserve">
          <source>Installing Binaries from Crates.io with &lt;code id=&quot;installing-binaries-from-cratesio-with-cargo-install&quot;&gt;cargo install&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;installing-binaries-from-cratesio-with-cargo-install&quot;&gt;cargo install&lt;/code&gt; 와 함께 Crates.io에서 바이너리 설치</target>
        </trans-unit>
        <trans-unit id="b810516d3307cdf27a35ee79c057d48b6aa21230" translate="yes" xml:space="preserve">
          <source>Installing Rust on Linux, macOS, and Windows</source>
          <target state="translated">Linux, macOS 및 Windows에 Rust 설치</target>
        </trans-unit>
        <trans-unit id="2c30b9b10b587e1e4e3853ef85ec4740848abbd7" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Fn&lt;/code&gt; can be called repeatedly without mutating state.</source>
          <target state="translated">상태를 변경하지 않고 &lt;code&gt;Fn&lt;/code&gt; 인스턴스를 반복해서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1322a032825805d3a73d3fe7e3a12985cf1de692" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;FnMut&lt;/code&gt; can be called repeatedly and may mutate state.</source>
          <target state="translated">&lt;code&gt;FnMut&lt;/code&gt; 인스턴스는 반복적으로 호출 될 수 있으며 상태를 변경시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9bc8df98d67671ea9af2ebbd9472094277d62c7" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;FnOnce&lt;/code&gt; can be called, but might not be callable multiple times. Because of this, if the only thing known about a type is that it implements &lt;code&gt;FnOnce&lt;/code&gt;, it can only be called once.</source>
          <target state="translated">&lt;code&gt;FnOnce&lt;/code&gt; 의 인스턴스는 호출 할 수 있지만 여러 번 호출 할 수는 없습니다. 이 때문에 타입에 대해 알려진 유일한 것이 &lt;code&gt;FnOnce&lt;/code&gt; 를 구현 한다는 것이라면 한 번만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b9d31413b772c5dc3e318115ee395c8ad114636" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Hasher&lt;/code&gt; usually represent state that is changed while hashing data.</source>
          <target state="translated">&lt;code&gt;Hasher&lt;/code&gt; 인스턴스는 일반적으로 데이터를 해시하는 동안 변경되는 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="21ec3e515a993282791572f7098d9de91b54a575" translate="yes" xml:space="preserve">
          <source>Instances of this &lt;code&gt;struct&lt;/code&gt; can be obtained by matching against the &lt;a href=&quot;enum.component#variant.Prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt; variant&lt;/a&gt; on &lt;a href=&quot;enum.component&quot;&gt;&lt;code&gt;Component&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 인스턴스 &lt;code&gt;struct&lt;/code&gt; 대해 매칭시킴으로써 얻을 수있다 &lt;a href=&quot;enum.component#variant.Prefix&quot;&gt; &lt;code&gt;Prefix&lt;/code&gt; 변이체&lt;/a&gt; 에 &lt;a href=&quot;enum.component&quot;&gt; &lt;code&gt;Component&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e5dd7083ff5f07cec7b9b34c02884013f777ac05" translate="yes" xml:space="preserve">
          <source>Instant</source>
          <target state="translated">Instant</target>
        </trans-unit>
        <trans-unit id="b5ac78fce22209b999309e8a7436e97b10622104" translate="yes" xml:space="preserve">
          <source>Instant::add</source>
          <target state="translated">Instant::add</target>
        </trans-unit>
        <trans-unit id="e5c83578445bb46f2191fb87fb2e970bfde98993" translate="yes" xml:space="preserve">
          <source>Instant::add_assign</source>
          <target state="translated">Instant::add_assign</target>
        </trans-unit>
        <trans-unit id="0c8c3b63eb155a52c73bfac3155d0197dd1a085d" translate="yes" xml:space="preserve">
          <source>Instant::borrow</source>
          <target state="translated">Instant::borrow</target>
        </trans-unit>
        <trans-unit id="f0f79568d43ec6cff172ef06950242a1e38ab9d4" translate="yes" xml:space="preserve">
          <source>Instant::borrow_mut</source>
          <target state="translated">Instant::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2e29432f378f62b734e945a4acd41b7defd436d4" translate="yes" xml:space="preserve">
          <source>Instant::checked_add</source>
          <target state="translated">Instant::checked_add</target>
        </trans-unit>
        <trans-unit id="eb4f8d11d037399c427f9a46cdb4e74b0b9fb310" translate="yes" xml:space="preserve">
          <source>Instant::checked_duration_since</source>
          <target state="translated">Instant::checked_duration_since</target>
        </trans-unit>
        <trans-unit id="f623e63718dd7f5e08fc4822d3ea1e552e483468" translate="yes" xml:space="preserve">
          <source>Instant::checked_sub</source>
          <target state="translated">Instant::checked_sub</target>
        </trans-unit>
        <trans-unit id="f7961f96937c07d9b42758cbb78758eeb1202726" translate="yes" xml:space="preserve">
          <source>Instant::clamp</source>
          <target state="translated">Instant::clamp</target>
        </trans-unit>
        <trans-unit id="a221c46ded2b61b64dcb1f60bfcb2b2993a3a5c9" translate="yes" xml:space="preserve">
          <source>Instant::clone</source>
          <target state="translated">Instant::clone</target>
        </trans-unit>
        <trans-unit id="0e4e4ec37ffa30c7418b3d4c01f925199339bd78" translate="yes" xml:space="preserve">
          <source>Instant::clone_from</source>
          <target state="translated">Instant::clone_from</target>
        </trans-unit>
        <trans-unit id="8b5bc24c2667bb02ad8d0c988c0c260c44857a92" translate="yes" xml:space="preserve">
          <source>Instant::clone_into</source>
          <target state="translated">Instant::clone_into</target>
        </trans-unit>
        <trans-unit id="e2495f5ad07793d7e77643dd4f486d02627866e1" translate="yes" xml:space="preserve">
          <source>Instant::cmp</source>
          <target state="translated">Instant::cmp</target>
        </trans-unit>
        <trans-unit id="5bb91176ea9d1de93e298e46888f1699788ffa0c" translate="yes" xml:space="preserve">
          <source>Instant::duration_since</source>
          <target state="translated">Instant::duration_since</target>
        </trans-unit>
        <trans-unit id="afcae638aa376f5908f1f30bd28087f8ac6046bd" translate="yes" xml:space="preserve">
          <source>Instant::elapsed</source>
          <target state="translated">Instant::elapsed</target>
        </trans-unit>
        <trans-unit id="243a247fce13eeb9a4a84c1d5fb1dac67574f6d1" translate="yes" xml:space="preserve">
          <source>Instant::eq</source>
          <target state="translated">Instant::eq</target>
        </trans-unit>
        <trans-unit id="c0e9c53ccf6d3d28525b5acc190c32004eb85ec8" translate="yes" xml:space="preserve">
          <source>Instant::fmt</source>
          <target state="translated">Instant::fmt</target>
        </trans-unit>
        <trans-unit id="91e13bb77c7e58f374e2d3daa91a9fc513ccb0bb" translate="yes" xml:space="preserve">
          <source>Instant::from</source>
          <target state="translated">Instant::from</target>
        </trans-unit>
        <trans-unit id="666400c2a2e214fcba1e53bc6d351d576dedbf88" translate="yes" xml:space="preserve">
          <source>Instant::ge</source>
          <target state="translated">Instant::ge</target>
        </trans-unit>
        <trans-unit id="e1545f7a496f8f598ffee1a4b219bdc08ac325eb" translate="yes" xml:space="preserve">
          <source>Instant::gt</source>
          <target state="translated">Instant::gt</target>
        </trans-unit>
        <trans-unit id="41c216d5664a8a7e6d226c8c88076fb379772e86" translate="yes" xml:space="preserve">
          <source>Instant::hash</source>
          <target state="translated">Instant::hash</target>
        </trans-unit>
        <trans-unit id="754e2486a3657aa16f85c8a3399792e46fc3859e" translate="yes" xml:space="preserve">
          <source>Instant::hash_slice</source>
          <target state="translated">Instant::hash_slice</target>
        </trans-unit>
        <trans-unit id="77b8dcf93181fdfb9c2ccd019961362f091bc10d" translate="yes" xml:space="preserve">
          <source>Instant::into</source>
          <target state="translated">Instant::into</target>
        </trans-unit>
        <trans-unit id="27c580d98c20ea09e90f23c4e7129dd284f1e540" translate="yes" xml:space="preserve">
          <source>Instant::le</source>
          <target state="translated">Instant::le</target>
        </trans-unit>
        <trans-unit id="077dca8f66a9fddef8fd3afcd25ba70cba946a7c" translate="yes" xml:space="preserve">
          <source>Instant::lt</source>
          <target state="translated">Instant::lt</target>
        </trans-unit>
        <trans-unit id="5f279b9b945d564222473676176af94a42a66352" translate="yes" xml:space="preserve">
          <source>Instant::max</source>
          <target state="translated">Instant::max</target>
        </trans-unit>
        <trans-unit id="1fef472f05cd2b320ab2c2019b4644689c5cb2f0" translate="yes" xml:space="preserve">
          <source>Instant::min</source>
          <target state="translated">Instant::min</target>
        </trans-unit>
        <trans-unit id="2607167b08c7b923c8543daeccd1a89c638f791c" translate="yes" xml:space="preserve">
          <source>Instant::ne</source>
          <target state="translated">Instant::ne</target>
        </trans-unit>
        <trans-unit id="2e89ed9eeb6e6fedfd76e029598f95d52ac89e9c" translate="yes" xml:space="preserve">
          <source>Instant::now</source>
          <target state="translated">Instant::now</target>
        </trans-unit>
        <trans-unit id="ef217fe283814eb7e0d5fb84203270e40f97b8d2" translate="yes" xml:space="preserve">
          <source>Instant::partial_cmp</source>
          <target state="translated">Instant::partial_cmp</target>
        </trans-unit>
        <trans-unit id="bf1b8520fb2822b3f5cb83bccfd646a516fffcbf" translate="yes" xml:space="preserve">
          <source>Instant::saturating_duration_since</source>
          <target state="translated">Instant::saturating_duration_since</target>
        </trans-unit>
        <trans-unit id="9ed1ccf1a589fe42420c89b940730dc8b7982f7d" translate="yes" xml:space="preserve">
          <source>Instant::sub</source>
          <target state="translated">Instant::sub</target>
        </trans-unit>
        <trans-unit id="57ade0b6d4dcc1517fdb9cf85b73a61857e80559" translate="yes" xml:space="preserve">
          <source>Instant::sub_assign</source>
          <target state="translated">Instant::sub_assign</target>
        </trans-unit>
        <trans-unit id="bdec0c97db20d86ebdd661571569d5a69a65be45" translate="yes" xml:space="preserve">
          <source>Instant::to_owned</source>
          <target state="translated">Instant::to_owned</target>
        </trans-unit>
        <trans-unit id="0901e5a9482040c503269599b849e7e300181ba0" translate="yes" xml:space="preserve">
          <source>Instant::try_from</source>
          <target state="translated">Instant::try_from</target>
        </trans-unit>
        <trans-unit id="5df3e1f653d0b4e8c037a1c9641f59e6a8cbc24c" translate="yes" xml:space="preserve">
          <source>Instant::try_into</source>
          <target state="translated">Instant::try_into</target>
        </trans-unit>
        <trans-unit id="69f76dc23d56db8a52e6e54a74ec2db10116eb78" translate="yes" xml:space="preserve">
          <source>Instant::type_id</source>
          <target state="translated">Instant::type_id</target>
        </trans-unit>
        <trans-unit id="001172aad080d8306d5d4d1b5dc437b8d68f3a48" translate="yes" xml:space="preserve">
          <source>Instantiating enum variants involves explicitly using the enum's name as its namespace, followed by one of its variants. &lt;code&gt;SimpleEnum::SecondVariant&lt;/code&gt; would be an example from above. When data follows along with a variant, such as with rust's built-in &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; type, the data is added as the type describes, for example &lt;code&gt;Option::Some(123)&lt;/code&gt;. The same follows with struct-like variants, with things looking like &lt;code&gt;ComplexEnum::LotsOfThings { usual_struct_stuff: true, blah: &quot;hello!&quot;.to_string(), }&lt;/code&gt;. Empty Enums are similar to () in that they cannot be instantiated at all, and are used mainly to mess with the type system in interesting ways.</source>
          <target state="translated">열거 형 변형 인스턴스화는 열거 형 이름을 네임 스페이스로 명시 적으로 사용하고 변형 중 하나를 사용합니다. &lt;code&gt;SimpleEnum::SecondVariant&lt;/code&gt; 가 위의 예입니다. 데이터가 녹의 내장 &lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 유형 과 같은 변형과 함께 오는 경우, 데이터는 유형이 설명하는대로 추가됩니다 &lt;code&gt;Option::Some(123)&lt;/code&gt; 예 : Option :: Some (123)) . &lt;code&gt;ComplexEnum::LotsOfThings { usual_struct_stuff: true, blah: &quot;hello!&quot;.to_string(), }&lt;/code&gt; 와 같은 구조체 유사 변형이 있습니다. 빈 열거 형은 인스턴스화 할 수 없다는 점에서 ()와 유사하며 주로 흥미로운 방식으로 형식 시스템을 망칠 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="89d417c0066da918ab986006990b8c13e4a1c9d4" translate="yes" xml:space="preserve">
          <source>Instantiation</source>
          <target state="translated">Instantiation</target>
        </trans-unit>
        <trans-unit id="b9d10d744d3b830949e2bf595c80e084be4f440a" translate="yes" xml:space="preserve">
          <source>Instantiations of struct or variant fields</source>
          <target state="translated">구조체 또는 변형 필드의 인스턴스화</target>
        </trans-unit>
        <trans-unit id="052f953d4dc163101293e43033ca426c81cc5b70" translate="yes" xml:space="preserve">
          <source>Instantiations of struct, union, or enum variant fields</source>
          <target state="translated">구조체, 공용체 또는 열거 형 변형 필드의 인스턴스화</target>
        </trans-unit>
        <trans-unit id="f7b4faec33775d5b4afedfc919179e22bbcfd3c9" translate="yes" xml:space="preserve">
          <source>Instants are always guaranteed to be no less than any previously measured instant when created, and are often useful for tasks such as measuring benchmarks or timing how long an operation takes.</source>
          <target state="translated">인스턴트는 항상 생성시 이전에 측정 한 인스턴트보다 항상 보장되며, 벤치 마크 측정 또는 작업 소요 시간 타이밍과 같은 작업에 종종 유용합니다.</target>
        </trans-unit>
        <trans-unit id="283f4073d67eb71b9aee283558af89f84e2066b3" translate="yes" xml:space="preserve">
          <source>Instants are opaque types that can only be compared to one another. There is no method to get &quot;the number of seconds&quot; from an instant. Instead, it only allows measuring the duration between two instants (or comparing two instants).</source>
          <target state="translated">인스턴트는 서로 비교할 수있는 불투명 한 유형입니다. 순간에서 &quot;초 수&quot;를 얻는 방법은 없습니다. 대신 두 순간 사이의 지속 시간 만 측정하거나 두 순간을 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61804bc8442fc7d7bb4e71e306aef5c0aea1b60a" translate="yes" xml:space="preserve">
          <source>Instead it is used to prevent moves through the type system, by controlling the behavior of pointers &lt;code&gt;P&lt;/code&gt; wrapped in the &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; wrapper, which &quot;pin&quot; the type in place by not allowing it to be moved out of them. See the &lt;a href=&quot;../pin/index&quot;&gt;&lt;code&gt;pin module&lt;/code&gt;&lt;/a&gt; documentation for more information on pinning.</source>
          <target state="translated">대신에 포인터 &lt;code&gt;P&lt;/code&gt; 에 포함 된 포인터의 동작을 제어하여 형식 시스템을 통한 이동을 방지하는 데 사용됩니다 .&lt;a href=&quot;../pin/struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt; 래퍼에래퍼는 형식을 이동시킬 수 없도록하여 형식을 &quot;고정&quot;시킵니다. 고정에 대한 자세한내용은&lt;a href=&quot;../pin/index&quot;&gt; &lt;code&gt;pin module&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3589fb3ebd4ad6821bd6d9b7e8dfdf86bb935287" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;ok&lt;/code&gt;, the line &lt;code&gt;test tests::another&lt;/code&gt; shows &lt;code&gt;FAILED&lt;/code&gt;. Two new sections appear between the individual results and the summary: the first section displays the detailed reason for each test failure. In this case, &lt;code&gt;another&lt;/code&gt; failed because it &lt;code&gt;panicked at 'Make this test fail'&lt;/code&gt;, which happened on line 10 in the &lt;em&gt;src/lib.rs&lt;/em&gt; file. The next section lists just the names of all the failing tests, which is useful when there are lots of tests and lots of detailed failing test output. We can use the name of a failing test to run just that test to more easily debug it; we&amp;rsquo;ll talk more about ways to run tests in the &lt;a href=&quot;ch11-02-running-tests#controlling-how-tests-are-run&quot;&gt;&amp;ldquo;Controlling How Tests Are Run&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">&lt;code&gt;ok&lt;/code&gt; 대신 line &lt;code&gt;test tests::another&lt;/code&gt; 는 &lt;code&gt;FAILED&lt;/code&gt; 를 표시 합니다. 개별 결과와 요약 사이에 두 개의 새로운 섹션이 나타납니다. 첫 번째 섹션에는 각 테스트 실패에 대한 자세한 이유가 표시됩니다. 이 경우 &lt;code&gt;another&lt;/code&gt; &lt;code&gt;panicked at 'Make this test fail'&lt;/code&gt; 했기 때문에 실패했습니다.&lt;em&gt; src / lib.rs&lt;/em&gt; 파일의 10 번째 줄 . 다음 섹션에는 모든 실패한 테스트의 이름 만 나열되어 있으며 많은 테스트와 자세한 실패한 테스트 출력이있을 때 유용합니다. 실패한 테스트의 이름을 사용하여 테스트를 더 쉽게 디버그하기 위해 해당 테스트 만 실행할 수 있습니다. &lt;a href=&quot;ch11-02-running-tests#controlling-how-tests-are-run&quot;&gt;&quot;테스트 실행 방법 제어&quot;&lt;/a&gt; 섹션 에서 테스트를 실행하는 방법에 대해 자세히 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="1a520d0103dd9e1e65d5d07eb5562a910a387f00" translate="yes" xml:space="preserve">
          <source>Instead of a concrete type for the &lt;code&gt;item&lt;/code&gt; parameter, we specify the &lt;code&gt;impl&lt;/code&gt; keyword and the trait name. This parameter accepts any type that implements the specified trait. In the body of &lt;code&gt;notify&lt;/code&gt;, we can call any methods on &lt;code&gt;item&lt;/code&gt; that come from the &lt;code&gt;Summary&lt;/code&gt; trait, such as &lt;code&gt;summarize&lt;/code&gt;. We can call &lt;code&gt;notify&lt;/code&gt; and pass in any instance of &lt;code&gt;NewsArticle&lt;/code&gt; or &lt;code&gt;Tweet&lt;/code&gt;. Code that calls the function with any other type, such as a &lt;code&gt;String&lt;/code&gt; or an &lt;code&gt;i32&lt;/code&gt;, won&amp;rsquo;t compile because those types don&amp;rsquo;t implement &lt;code&gt;Summary&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;item&lt;/code&gt; 매개 변수 의 구체적 유형 대신 &lt;code&gt;impl&lt;/code&gt; 키워드와 특성 이름을 지정합니다 . 이 매개 변수는 지정된 특성을 구현하는 모든 유형을 승인합니다. 본문에 &lt;code&gt;notify&lt;/code&gt; , 우리는 어떠한 방법을 호출 할 수 있습니다 &lt;code&gt;item&lt;/code&gt; 으로부터 온 &lt;code&gt;Summary&lt;/code&gt; 과 같은 특성, &lt;code&gt;summarize&lt;/code&gt; . 우리는 &lt;code&gt;NewsArticle&lt;/code&gt; 또는 &lt;code&gt;Tweet&lt;/code&gt; 의 어떤 경우에도 &lt;code&gt;notify&lt;/code&gt; 하고 전달할 수 있습니다 . &lt;code&gt;String&lt;/code&gt; 또는 다른 유형과 같은 다른 유형으로 함수를 호출하는 코드 &lt;code&gt;i32&lt;/code&gt; 해당 유형이 &lt;code&gt;Summary&lt;/code&gt; 를 구현하지 않기 때문에 컴파일되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c586c2da19eaf29595cd7783a0bdd1aaa4af1f4c" translate="yes" xml:space="preserve">
          <source>Instead of adding the &lt;code&gt;assert!&lt;/code&gt; macro as we&amp;rsquo;ve done here, we could make &lt;code&gt;new&lt;/code&gt; return a &lt;code&gt;Result&lt;/code&gt; like we did with &lt;code&gt;Config::new&lt;/code&gt; in the I/O project in Listing 12-9. But we&amp;rsquo;ve decided in this case that trying to create a thread pool without any threads should be an unrecoverable error. If you&amp;rsquo;re feeling ambitious, try to write a version of &lt;code&gt;new&lt;/code&gt; with the following signature to compare both versions:</source>
          <target state="translated">&lt;code&gt;assert!&lt;/code&gt; 을 추가하는 대신 ! 매크로 우리가 여기서했던, 우리가 만들 수있는 &lt;code&gt;new&lt;/code&gt; 수익을 &lt;code&gt;Result&lt;/code&gt; 우리가했던 것처럼 &lt;code&gt;Config::new&lt;/code&gt; 목록 12-9의 I / O 프로젝트이다. 그러나이 경우 스레드없이 스레드 풀을 만들려고하면 복구 할 수없는 오류가되어야한다고 결정했습니다. 야심이 있다면 다음 서명을 사용하여 &lt;code&gt;new&lt;/code&gt; 버전을 작성하여 두 버전을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="9745bfc2f2927dceb9288ed29cf395b852078f44" translate="yes" xml:space="preserve">
          <source>Instead of always calling the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function before the &lt;code&gt;if&lt;/code&gt; blocks, we can define a closure and store the &lt;em&gt;closure&lt;/em&gt; in a variable rather than storing the result of the function call, as shown in Listing 13-5. We can actually move the whole body of &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; within the closure we&amp;rsquo;re introducing here.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 블록 전에 항상 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 함수를 호출하는 대신 , Listing 13-5에 표시된 것처럼 함수 호출의 결과를 저장하는 대신 &lt;em&gt;클로저&lt;/em&gt; 를 정의 하고 변수에 클로저를 저장할 수 있습니다 . 우리는 여기에서 소개하는 클로저 내에서 실제로 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 전신을 옮길 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ae67e98f84394870dad9c2dee4383fa199b41a3d" translate="yes" xml:space="preserve">
          <source>Instead of comparing the iterator's elements directly, this function compares the keys of the elements, as determined by &lt;code&gt;f&lt;/code&gt;. Apart from that, it's equivalent to &lt;a href=&quot;trait.iterator#method.is_sorted&quot;&gt;&lt;code&gt;is_sorted&lt;/code&gt;&lt;/a&gt;; see its documentation for more information.</source>
          <target state="translated">반복자의 요소를 직접 비교하는 대신이 함수는 &lt;code&gt;f&lt;/code&gt; 에 의해 결정된대로 요소의 키를 비교합니다 . 그 외에도 &lt;a href=&quot;trait.iterator#method.is_sorted&quot;&gt; &lt;code&gt;is_sorted&lt;/code&gt; &lt;/a&gt; 와 같습니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3f4a03c266892c8db13bbe1ed2f70b65c01aa093" translate="yes" xml:space="preserve">
          <source>Instead of comparing the slice's elements directly, this function compares the keys of the elements, as determined by &lt;code&gt;f&lt;/code&gt;. Apart from that, it's equivalent to &lt;a href=&quot;#method.is_sorted&quot;&gt;&lt;code&gt;is_sorted&lt;/code&gt;&lt;/a&gt;; see its documentation for more information.</source>
          <target state="translated">슬라이스의 요소를 직접 비교하는 대신이 함수는 &lt;code&gt;f&lt;/code&gt; 에 의해 결정된대로 요소의 키를 비교합니다 . 그 외에는 다음과 같습니다.&lt;a href=&quot;#method.is_sorted&quot;&gt; &lt;code&gt;is_sorted&lt;/code&gt; &lt;/a&gt;. 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ab414c3f0e8d06ac0d388f321dffd0ec64ba1540" translate="yes" xml:space="preserve">
          <source>Instead of defining an inherent implementation on a reference, you could also move the reference inside the implementation:</source>
          <target state="translated">참조에 고유 한 구현을 정의하는 대신 구현 내에서 참조를 이동할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf669630673f131e83096baf2080a7fff2853dbb" translate="yes" xml:space="preserve">
          <source>Instead of saving the closure in a variable directly, we save a new instance of &lt;code&gt;Cacher&lt;/code&gt; that holds the closure. Then, in each place we want the result, we call the &lt;code&gt;value&lt;/code&gt; method on the &lt;code&gt;Cacher&lt;/code&gt; instance. We can call the &lt;code&gt;value&lt;/code&gt; method as many times as we want, or not call it at all, and the expensive calculation will be run a maximum of once.</source>
          <target state="translated">클로저를 변수에 직접 저장하는 대신 클로저 를 보유 하는 새로운 &lt;code&gt;Cacher&lt;/code&gt; 인스턴스를 저장합니다 . 그런 다음 각 위치에서 결과를 원할 때 &lt;code&gt;Cacher&lt;/code&gt; 인스턴스 의 &lt;code&gt;value&lt;/code&gt; 메소드를 호출합니다 . 우리는 &lt;code&gt;value&lt;/code&gt; 원하는만큼 value 메소드를 호출하거나 전혀 호출하지 않을 수 있으며 값 비싼 계산은 최대 한 번 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="007ce9d48190918926ae8e5decfb3ba7fb1ee115" translate="yes" xml:space="preserve">
          <source>Instead of saving the result of the build in the same directory as our code, Cargo stores it in the &lt;em&gt;target/debug&lt;/em&gt; directory.</source>
          <target state="translated">Cargo는 빌드 결과를 코드와 동일한 디렉토리에 저장하는 대신 &lt;em&gt; 대상 / 디버그&lt;/em&gt; 디렉토리 .</target>
        </trans-unit>
        <trans-unit id="12c9e09de719f2e7a3f500e0f9b7335d3a4a658d" translate="yes" xml:space="preserve">
          <source>Instead of stopping at &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the iterator will instead start again, from the beginning. After iterating again, it will start at the beginning again. And again. And again. Forever.</source>
          <target state="translated">에 멈추지 않고 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 에서반복자가 처음부터 다시 시작됩니다. 다시 반복하면 처음부터 다시 시작됩니다. 다시 한번. 다시 한번. 영원히.</target>
        </trans-unit>
        <trans-unit id="57207c003495c85f3158cd50928c0d6b80c8565c" translate="yes" xml:space="preserve">
          <source>Instead of storing a vector of &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances in the thread pool, we&amp;rsquo;ll store instances of the &lt;code&gt;Worker&lt;/code&gt; struct. Each &lt;code&gt;Worker&lt;/code&gt; will store a single &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instance. Then we&amp;rsquo;ll implement a method on &lt;code&gt;Worker&lt;/code&gt; that will take a closure of code to run and send it to the already running thread for execution. We&amp;rsquo;ll also give each worker an &lt;code&gt;id&lt;/code&gt; so we can distinguish between the different workers in the pool when logging or debugging.</source>
          <target state="translated">스레드 풀 에 &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; 인스턴스 의 벡터를 저장하는 대신 &lt;code&gt;Worker&lt;/code&gt; 구조체의 인스턴스를 저장합니다 . 각 &lt;code&gt;Worker&lt;/code&gt; 는 단일 &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; 인스턴스를 저장 합니다. 그런 다음 &lt;code&gt;Worker&lt;/code&gt; 에서 코드를 실행하여 실행을 위해 이미 실행중인 스레드로 전송 하는 메소드를 구현합니다 . 우리는 또한 각 근로자에게 &lt;code&gt;id&lt;/code&gt; 하여 로깅 또는 디버깅시 풀의 여러 작업자를 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e496da216bd15fab37b8868b5d0249983379dbc2" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;PartialOrd::partial_cmp&lt;/code&gt;, this function uses the given &lt;code&gt;compare&lt;/code&gt; function to determine the ordering of two elements. Apart from that, it's equivalent to &lt;a href=&quot;#method.is_sorted&quot;&gt;&lt;code&gt;is_sorted&lt;/code&gt;&lt;/a&gt;; see its documentation for more information.</source>
          <target state="translated">&lt;code&gt;PartialOrd::partial_cmp&lt;/code&gt; 를 사용하는 대신 이 함수는 주어진 &lt;code&gt;compare&lt;/code&gt; 함수를 사용하여 두 요소의 순서를 결정합니다. 그 외에는 다음과 같습니다.&lt;a href=&quot;#method.is_sorted&quot;&gt; &lt;code&gt;is_sorted&lt;/code&gt; &lt;/a&gt;. 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c10b23d92f193b5b7c4a31db6e9dd35bde4c84df" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;PartialOrd::partial_cmp&lt;/code&gt;, this function uses the given &lt;code&gt;compare&lt;/code&gt; function to determine the ordering of two elements. Apart from that, it's equivalent to &lt;a href=&quot;trait.iterator#method.is_sorted&quot;&gt;&lt;code&gt;is_sorted&lt;/code&gt;&lt;/a&gt;; see its documentation for more information.</source>
          <target state="translated">&lt;code&gt;PartialOrd::partial_cmp&lt;/code&gt; 를 사용하는 대신 이 함수는 주어진 &lt;code&gt;compare&lt;/code&gt; 함수를 사용하여 두 요소의 순서를 결정합니다. 그 외에도&lt;a href=&quot;trait.iterator#method.is_sorted&quot;&gt; &lt;code&gt;is_sorted&lt;/code&gt; &lt;/a&gt; 와 같습니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="78836dae939176c5518d6cb16a8bc88f88e60ed0" translate="yes" xml:space="preserve">
          <source>Instead, the &lt;code&gt;get&lt;/code&gt; method is generic over the type of the underlying key data, called &lt;code&gt;Q&lt;/code&gt; in the method signature above. It states that &lt;code&gt;K&lt;/code&gt; borrows as a &lt;code&gt;Q&lt;/code&gt; by requiring that &lt;code&gt;K: Borrow&amp;lt;Q&amp;gt;&lt;/code&gt;. By additionally requiring &lt;code&gt;Q: Hash + Eq&lt;/code&gt;, it signals the requirement that &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;Q&lt;/code&gt; have implementations of the &lt;code&gt;Hash&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt; traits that produce identical results.</source>
          <target state="translated">대신, &lt;code&gt;get&lt;/code&gt; 메소드는 위의 메소드 서명에서 &lt;code&gt;Q&lt;/code&gt; 라고하는 기본 키 데이터 유형에 대해 일반적 입니다. 그것은한다고 &lt;code&gt;K&lt;/code&gt; 가 A와 차용 &lt;code&gt;Q&lt;/code&gt; 것을 요구함으로써 &lt;code&gt;K: Borrow&amp;lt;Q&amp;gt;&lt;/code&gt; . 추가적으로 요구함으로써 &lt;code&gt;Q: Hash + Eq&lt;/code&gt; , 그 요구 신호 &lt;code&gt;K&lt;/code&gt; 와 &lt;code&gt;Q&lt;/code&gt; 가 의 구현이 &lt;code&gt;Hash&lt;/code&gt; 및 &lt;code&gt;Eq&lt;/code&gt; 동일한 결과를 생성 Eq 특성을 .</target>
        </trans-unit>
        <trans-unit id="878f7237ad30bf50b95fb9667897fe778bbcf6bb" translate="yes" xml:space="preserve">
          <source>Instead, we can make a new type and put the validations in a function to create an instance of the type rather than repeating the validations everywhere. That way, it&amp;rsquo;s safe for functions to use the new type in their signatures and confidently use the values they receive. Listing 9-10 shows one way to define a &lt;code&gt;Guess&lt;/code&gt; type that will only create an instance of &lt;code&gt;Guess&lt;/code&gt; if the &lt;code&gt;new&lt;/code&gt; function receives a value between 1 and 100.</source>
          <target state="translated">대신, 우리는 새로운 유형을 만들고 유효성 검사를 함수에 넣어서 모든 곳에서 유효성 검사를 반복하지 않고 유형의 인스턴스를 만들 수 있습니다. 그렇게하면 함수가 서명에서 새 유형을 사용하고 자신이받는 값을 자신있게 사용하는 것이 안전합니다. 리스팅 9-10은 &lt;code&gt;new&lt;/code&gt; 경우 에만 &lt;code&gt;Guess&lt;/code&gt; 인스턴스를 생성하는 &lt;code&gt;Guess&lt;/code&gt; 유형 을 정의하는 한 가지 방법을 보여줍니다. 함수가 1에서 100 사이의 값을 수신하는 .</target>
        </trans-unit>
        <trans-unit id="4262f2636f484912c23478cb754110e371d9c5c5" translate="yes" xml:space="preserve">
          <source>Instead, we can use nested paths to bring the same items into scope in one line. We do this by specifying the common part of the path, followed by two colons, and then curly brackets around a list of the parts of the paths that differ, as shown in Listing 7-18.</source>
          <target state="translated">대신 중첩 된 경로를 사용하여 동일한 항목을 한 줄로 범위 내로 가져올 수 있습니다. 경로의 공통 부분과 두 개의 콜론, 그리고 경로의 부분 목록 주위에 중괄호를 지정하여 목록 7-18에 표시된 것처럼이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="5890f5912d1fb9403515b5a5574c224c2a726c72" translate="yes" xml:space="preserve">
          <source>Instead, we could write this in a shorter way using &lt;code&gt;if let&lt;/code&gt;. The following code behaves the same as the &lt;code&gt;match&lt;/code&gt; in Listing 6-6:</source>
          <target state="translated">대신 &lt;code&gt;if let&lt;/code&gt; 을 사용하여 더 짧은 방법으로 작성할 수 있습니다. 다음 코드는 &lt;code&gt;match&lt;/code&gt; 하는 것과 동일하게 동작합니다 는 Listing 6-6 .</target>
        </trans-unit>
        <trans-unit id="f97c87a1b2b6afb4bd47b58a7850a17ba4dcea9b" translate="yes" xml:space="preserve">
          <source>Instead, we get the following error that talks about lifetimes:</source>
          <target state="translated">대신 수명에 대해 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e71162b50e657665aeaa9b501b8264cb1685df94" translate="yes" xml:space="preserve">
          <source>Instead, we&amp;rsquo;ll change our definition of &lt;code&gt;List&lt;/code&gt; to use &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; in place of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, as shown in Listing 15-18. Each &lt;code&gt;Cons&lt;/code&gt; variant will now hold a value and an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; pointing to a &lt;code&gt;List&lt;/code&gt;. When we create &lt;code&gt;b&lt;/code&gt;, instead of taking ownership of &lt;code&gt;a&lt;/code&gt;, we&amp;rsquo;ll clone the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that &lt;code&gt;a&lt;/code&gt; is holding, thereby increasing the number of references from one to two and letting &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; share ownership of the data in that &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt;. We&amp;rsquo;ll also clone &lt;code&gt;a&lt;/code&gt; when creating &lt;code&gt;c&lt;/code&gt;, increasing the number of references from two to three. Every time we call &lt;code&gt;Rc::clone&lt;/code&gt;, the reference count to the data within the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; will increase, and the data won&amp;rsquo;t be cleaned up unless there are zero references to it.</source>
          <target state="translated">대신 Listing 15-18에 표시된 것처럼 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 대신 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용하도록 &lt;code&gt;List&lt;/code&gt; 정의를 변경한다 . 각 &lt;code&gt;Cons&lt;/code&gt; 변형은 이제 &lt;code&gt;List&lt;/code&gt; 를 가리키는 값과 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 보유합니다 . 우리가 만들 때 &lt;code&gt;b&lt;/code&gt; 대신 소유권 복용, &lt;code&gt;a&lt;/code&gt; , 우리는 복제 할 수 있습니다 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 것을 들고함으로써이 하나에서 참조의 수를 증가시키는되고 와 &lt;code&gt;b&lt;/code&gt; 에서 데이터의 공유 소유권을 것을 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; . 우리는 복제도거야 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; 를 만들 때참조 수를 2 개에서 3 개로 늘 렸습니다. &lt;code&gt;Rc::clone&lt;/code&gt; 을 호출 할 때마다 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 내의 데이터에 대한 참조 횟수 가 증가하며, 참조가없는 경우 데이터가 정리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2890fe24db6f7388a46470ac6834b80784db6337" translate="yes" xml:space="preserve">
          <source>Instructions can execute in a different order from the one we define, due to various reasons:</source>
          <target state="translated">명령어는 다양한 이유로 인해 정의한 것과 다른 순서로 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b74294f827b0d4541ba12662271114a470d6d7a4" translate="yes" xml:space="preserve">
          <source>IntErrorKind</source>
          <target state="translated">IntErrorKind</target>
        </trans-unit>
        <trans-unit id="80fb7220d8146322b259aee21dfef8944e427bb7" translate="yes" xml:space="preserve">
          <source>IntErrorKind::borrow</source>
          <target state="translated">IntErrorKind::borrow</target>
        </trans-unit>
        <trans-unit id="bb7aa40e4b4db6e736d2b09e30f31443f1c9b44c" translate="yes" xml:space="preserve">
          <source>IntErrorKind::borrow_mut</source>
          <target state="translated">IntErrorKind::borrow_mut</target>
        </trans-unit>
        <trans-unit id="86f2a2b8f3ab0b9d3e18ee8e7279ac3646f5e5b6" translate="yes" xml:space="preserve">
          <source>IntErrorKind::clone</source>
          <target state="translated">IntErrorKind::clone</target>
        </trans-unit>
        <trans-unit id="dd987594d4a6731556fb4db2a25b883f8e6e834a" translate="yes" xml:space="preserve">
          <source>IntErrorKind::clone_from</source>
          <target state="translated">IntErrorKind::clone_from</target>
        </trans-unit>
        <trans-unit id="8f1809c6588a2cc665ccd543289e14a938828a70" translate="yes" xml:space="preserve">
          <source>IntErrorKind::clone_into</source>
          <target state="translated">IntErrorKind::clone_into</target>
        </trans-unit>
        <trans-unit id="a5e2ed2cdfa8d2140437ae0a8783a450793b17a2" translate="yes" xml:space="preserve">
          <source>IntErrorKind::eq</source>
          <target state="translated">IntErrorKind::eq</target>
        </trans-unit>
        <trans-unit id="92fce40d27d225b47d39433e8ff156d8c2c93e18" translate="yes" xml:space="preserve">
          <source>IntErrorKind::fmt</source>
          <target state="translated">IntErrorKind::fmt</target>
        </trans-unit>
        <trans-unit id="cd16b5df7c131824209cf18f2e5abfbebb79b75a" translate="yes" xml:space="preserve">
          <source>IntErrorKind::from</source>
          <target state="translated">IntErrorKind::from</target>
        </trans-unit>
        <trans-unit id="e6625420510ba7fab278784b2593fb38c7566390" translate="yes" xml:space="preserve">
          <source>IntErrorKind::into</source>
          <target state="translated">IntErrorKind::into</target>
        </trans-unit>
        <trans-unit id="9d0115c16bd4f87138d516953bbe461d1bf9ec02" translate="yes" xml:space="preserve">
          <source>IntErrorKind::ne</source>
          <target state="translated">IntErrorKind::ne</target>
        </trans-unit>
        <trans-unit id="14958c3a69f5e70cdde8bcf9555c598ab9bb336b" translate="yes" xml:space="preserve">
          <source>IntErrorKind::to_owned</source>
          <target state="translated">IntErrorKind::to_owned</target>
        </trans-unit>
        <trans-unit id="6415d36e18efe91e53b209d52b6293cb58ff6bfa" translate="yes" xml:space="preserve">
          <source>IntErrorKind::try_from</source>
          <target state="translated">IntErrorKind::try_from</target>
        </trans-unit>
        <trans-unit id="03f332b4c41b3659819ff1f646ef37a2e67d10fd" translate="yes" xml:space="preserve">
          <source>IntErrorKind::try_into</source>
          <target state="translated">IntErrorKind::try_into</target>
        </trans-unit>
        <trans-unit id="b726776952bee36d5bafae04149385980bc0b309" translate="yes" xml:space="preserve">
          <source>IntErrorKind::type_id</source>
          <target state="translated">IntErrorKind::type_id</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="65424b5083b7bb599ce3d3b760be23e671c074b2" translate="yes" xml:space="preserve">
          <source>Integer Overflow</source>
          <target state="translated">정수 오버플로</target>
        </trans-unit>
        <trans-unit id="dee2f95e5c81fdaa601cb7ca5b7396c9d7532488" translate="yes" xml:space="preserve">
          <source>Integer Types</source>
          <target state="translated">정수 타입</target>
        </trans-unit>
        <trans-unit id="6977c92d9e82d5b8f471a2623681e1d1d400b4fb" translate="yes" xml:space="preserve">
          <source>Integer and floating point literals are stringified in order to be concatenated.</source>
          <target state="translated">정수 및 부동 소수점 리터럴은 연결하기 위해 문자열 화됩니다.</target>
        </trans-unit>
        <trans-unit id="eea9a8e4af8d6805a657b383a298ba05a67ec8a4" translate="yes" xml:space="preserve">
          <source>Integer is too large to store in target integer type.</source>
          <target state="translated">정수가 너무 커서 대상 정수 유형에 저장할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="25419a68a3cc357926618f13c044ff7b1347aa8b" translate="yes" xml:space="preserve">
          <source>Integer is too small to store in target integer type.</source>
          <target state="translated">정수가 너무 작아 대상 정수 유형에 저장할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="13c9f1f069c2155e025409b7880e9bda6c11b765" translate="yes" xml:space="preserve">
          <source>Integer literals</source>
          <target state="translated">정수 리터럴</target>
        </trans-unit>
        <trans-unit id="f64049bb9bdfd33c50813111908ece46c327c630" translate="yes" xml:space="preserve">
          <source>Integer operators will panic when they overflow when compiled in debug mode. The &lt;code&gt;-C debug-assertions&lt;/code&gt; and &lt;code&gt;-C overflow-checks&lt;/code&gt; compiler flags can be used to control this more directly. The following things are considered to be overflow:</source>
          <target state="translated">정수 연산자는 디버그 모드에서 컴파일 될 때 오버 플로우 될 때 패닉 상태가됩니다. &lt;code&gt;-C debug-assertions&lt;/code&gt; 및 &lt;code&gt;-C overflow-checks&lt;/code&gt; 컴파일러 플래그보다 직접 제어하는데 사용될 수있다. 다음은 오버플로로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="16d3c89b38e84e433e4fbd3b3a5bad55571258af" translate="yes" xml:space="preserve">
          <source>Integer or Float type</source>
          <target state="translated">정수 또는 실수 유형</target>
        </trans-unit>
        <trans-unit id="3a26a4e37ae1b89c4b86a6d96e9ccef63b9ca764" translate="yes" xml:space="preserve">
          <source>Integer overflow</source>
          <target state="translated">정수 오버플로</target>
        </trans-unit>
        <trans-unit id="60c11385ec83a73512788efd527bda9740331202" translate="yes" xml:space="preserve">
          <source>Integer suffixes</source>
          <target state="translated">정수 접미사</target>
        </trans-unit>
        <trans-unit id="f59b20cbbdd5ddf3c9bd85fd552a52f66ae334d9" translate="yes" xml:space="preserve">
          <source>Integer type</source>
          <target state="translated">정수형</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">정수 타입</target>
        </trans-unit>
        <trans-unit id="19f28971f5db0ac7dee3fee9af716d1da8917af3" translate="yes" xml:space="preserve">
          <source>Integer types (u8, i8, u16, i16, usize, isize, etc.).</source>
          <target state="translated">정수 유형 (u8, i8, u16, i16, usize, isize 등).</target>
        </trans-unit>
        <trans-unit id="a83667e8fbc7d07069b4ce287d78c06adec56630" translate="yes" xml:space="preserve">
          <source>Integers and other types implementing &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; are unaffected by &lt;code&gt;drop&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 를 구현하는 정수 및 기타 유형 은 &lt;code&gt;drop&lt;/code&gt; 의 영향을받지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="036a5d47efaf84af91b96bca27d0e3394108b032" translate="yes" xml:space="preserve">
          <source>Integration Tests</source>
          <target state="translated">통합 테스트</target>
        </trans-unit>
        <trans-unit id="d9b3c69227b8b09ee6557a63d6eadc1309909958" translate="yes" xml:space="preserve">
          <source>Integration Tests for Binary Crates</source>
          <target state="translated">이진 상자에 대한 통합 테스트</target>
        </trans-unit>
        <trans-unit id="22d0f1d4f5d8a4b65c3ed4d1e121eaf3dc6e87d2" translate="yes" xml:space="preserve">
          <source>Intended for use for errors not exposed to the user, where allocating onto the heap (for normal construction via Error::new) is too costly.</source>
          <target state="translated">힙에 할당하는 것 (Error :: new를 통한 일반 구성의 경우)이 너무 비싸기 때문에 사용자에게 노출되지 않은 오류에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8b67f9d330a2d3ef64e53c30ab32b2a3ac9f06b6" translate="yes" xml:space="preserve">
          <source>Intense! In effect, this error message means that Rust doesn&amp;rsquo;t understand how to add an &lt;code&gt;i8&lt;/code&gt; and an &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt;, because they&amp;rsquo;re different types. When we have a value of a type like &lt;code&gt;i8&lt;/code&gt; in Rust, the compiler will ensure that we always have a valid value. We can proceed confidently without having to check for null before using that value. Only when we have an &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; (or whatever type of value we&amp;rsquo;re working with) do we have to worry about possibly not having a value, and the compiler will make sure we handle that case before using the value.</source>
          <target state="translated">심한! 실제로이 오류 메시지는 Rust가 유형이 다르기 때문에 &lt;code&gt;i8&lt;/code&gt; 및 &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; 을 추가하는 방법을 이해하지 못했음을 의미합니다 . Rust에 &lt;code&gt;i8&lt;/code&gt; 과 같은 유형의 값이 있으면 컴파일러는 항상 유효한 값을 갖습니다. 해당 값을 사용하기 전에 null을 확인하지 않고도 자신있게 진행할 수 있습니다. &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; (또는 우리가 사용하는 모든 유형의 값)이 있을 때만 값을 가질 가능성에 대해 걱정해야하며 컴파일러는 값을 사용하기 전에 해당 경우를 처리하도록합니다.</target>
        </trans-unit>
        <trans-unit id="ffafe2f71610dfdf28d74f6f54bc9015fbb24203" translate="yes" xml:space="preserve">
          <source>Interestingly, the Rust language has &lt;em&gt;very&lt;/em&gt; few concurrency features. Almost every concurrency feature we&amp;rsquo;ve talked about so far in this chapter has been part of the standard library, not the language. Your options for handling concurrency are not limited to the language or the standard library; you can write your own concurrency features or use those written by others.</source>
          <target state="translated">흥미롭게도 Rust 언어에는 동시성 기능 이 &lt;em&gt;거의&lt;/em&gt; 없습니다. 이 장에서 지금까지 이야기 한 거의 모든 동시성 기능은 언어가 아니라 표준 라이브러리의 일부입니다. 동시성 처리 옵션은 언어 나 표준 라이브러리로 제한되지 않습니다. 자체 동시성 기능을 작성하거나 다른 사람이 작성한 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21bdfe87f76bf3a6413dde02708bb83e04770512" translate="yes" xml:space="preserve">
          <source>Interior Mutability</source>
          <target state="translated">내부 돌연변이</target>
        </trans-unit>
        <trans-unit id="88bf37967a115d0f3e4ede63c58d62ebf4f74d5a" translate="yes" xml:space="preserve">
          <source>Interior Mutability: A Mutable Borrow to an Immutable Value</source>
          <target state="translated">내부 돌연변이 성 : 불변 가치에 대한 가변 차용</target>
        </trans-unit>
        <trans-unit id="bb56d65f2c6cb59165a8429fad875c4b21a44fc9" translate="yes" xml:space="preserve">
          <source>Interior mutability is required.</source>
          <target state="translated">내부 돌연변이가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ca7ba6473fcf9f5318db96e54bb8153323ab66d4" translate="yes" xml:space="preserve">
          <source>Internal Representation</source>
          <target state="translated">내부 대표</target>
        </trans-unit>
        <trans-unit id="951194525a57d9119eb003c4910a0f82fea56f08" translate="yes" xml:space="preserve">
          <source>Internally uses an alias to &lt;a href=&quot;trait.ord#method.max&quot;&gt;&lt;code&gt;Ord::max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">내부적으로 &lt;a href=&quot;trait.ord#method.max&quot;&gt; &lt;code&gt;Ord::max&lt;/code&gt; &lt;/a&gt; 대한 별칭을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="acf9ba348896a745b094371c98fa0f28a4195e87" translate="yes" xml:space="preserve">
          <source>Internally uses an alias to &lt;a href=&quot;trait.ord#method.min&quot;&gt;&lt;code&gt;Ord::min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">내부적으로 &lt;a href=&quot;trait.ord#method.min&quot;&gt; &lt;code&gt;Ord::min&lt;/code&gt; &lt;/a&gt; 대한 별칭을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f8e983bc961f2f79520b6f7bb3705df394320c6d" translate="yes" xml:space="preserve">
          <source>Internally uses an alias to &lt;code&gt;Ord::max&lt;/code&gt;.</source>
          <target state="translated">내부적으로 &lt;code&gt;Ord::max&lt;/code&gt; 대한 별칭을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="944d65bab4f9ee9f9e2c120271148593d01f1819" translate="yes" xml:space="preserve">
          <source>Internally uses an alias to &lt;code&gt;Ord::min&lt;/code&gt;.</source>
          <target state="translated">내부적으로 &lt;code&gt;Ord::min&lt;/code&gt; 대한 별칭을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="068003ac53324bf3f0b64c29929ac10bbe1c05ab" translate="yes" xml:space="preserve">
          <source>Internet socket addresses consist of an &lt;a href=&quot;enum.ipaddr&quot;&gt;IP address&lt;/a&gt;, a 16-bit port number, as well as possibly some version-dependent additional information. See &lt;a href=&quot;struct.socketaddrv4&quot;&gt;&lt;code&gt;SocketAddrV4&lt;/code&gt;&lt;/a&gt;'s and &lt;a href=&quot;struct.socketaddrv6&quot;&gt;&lt;code&gt;SocketAddrV6&lt;/code&gt;&lt;/a&gt;'s respective documentation for more details.</source>
          <target state="translated">인터넷 소켓 주소는 &lt;a href=&quot;enum.ipaddr&quot;&gt;IP 주소&lt;/a&gt; , 16 비트 포트 번호 및 버전 별 추가 정보로 구성됩니다. 자세한 내용은 &lt;a href=&quot;struct.socketaddrv4&quot;&gt; &lt;code&gt;SocketAddrV4&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.socketaddrv6&quot;&gt; &lt;code&gt;SocketAddrV6&lt;/code&gt; &lt;/a&gt; 의 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ff358fd17c71b9310a296d32bf0fad9d3ef93b34" translate="yes" xml:space="preserve">
          <source>Interprets &lt;code&gt;src&lt;/code&gt; as having type &lt;code&gt;&amp;amp;U&lt;/code&gt;, and then reads &lt;code&gt;src&lt;/code&gt; without moving the contained value.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 를 &lt;code&gt;&amp;amp;U&lt;/code&gt; 유형으로 해석 한 다음 포함 된 값을 이동하지 않고 &lt;code&gt;src&lt;/code&gt; 를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="6a36b9396eb19f7860ffbd9cb812832709b1a0ee" translate="yes" xml:space="preserve">
          <source>Interrupted operations can typically be retried.</source>
          <target state="translated">중단 된 작업은 일반적으로 재 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0f596ba112a353008597117b57b10b067fc620b" translate="yes" xml:space="preserve">
          <source>Intersection</source>
          <target state="translated">Intersection</target>
        </trans-unit>
        <trans-unit id="d937d21f811516b74380ee512b99e31251a84531" translate="yes" xml:space="preserve">
          <source>Into</source>
          <target state="translated">Into</target>
        </trans-unit>
        <trans-unit id="5bfe78f7766048c0532cc66994c73d1126acb835" translate="yes" xml:space="preserve">
          <source>Into::into</source>
          <target state="translated">Into::into</target>
        </trans-unit>
        <trans-unit id="44f9db19d74f7cdef0547d820fed0d75c60f0beb" translate="yes" xml:space="preserve">
          <source>IntoFuture</source>
          <target state="translated">IntoFuture</target>
        </trans-unit>
        <trans-unit id="77f5dd8de42c3fb03062223e3c47c92129133f82" translate="yes" xml:space="preserve">
          <source>IntoInnerError</source>
          <target state="translated">IntoInnerError</target>
        </trans-unit>
        <trans-unit id="3f3157b39d55c6291f5fe8213b30cc7d15253d48" translate="yes" xml:space="preserve">
          <source>IntoInnerError::borrow</source>
          <target state="translated">IntoInnerError::borrow</target>
        </trans-unit>
        <trans-unit id="8dfa8d9b4ac06c1a6626ce8031f10e6de0dc0387" translate="yes" xml:space="preserve">
          <source>IntoInnerError::borrow_mut</source>
          <target state="translated">IntoInnerError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="7c332dec4b157cd5d25efcbb73292737fbcafa2a" translate="yes" xml:space="preserve">
          <source>IntoInnerError::cause</source>
          <target state="translated">IntoInnerError::cause</target>
        </trans-unit>
        <trans-unit id="824ab9811aae7de9a48a47b240a825897e788412" translate="yes" xml:space="preserve">
          <source>IntoInnerError::description</source>
          <target state="translated">IntoInnerError::description</target>
        </trans-unit>
        <trans-unit id="83d6a8f5f81bfae0852073773b72a21c220d1541" translate="yes" xml:space="preserve">
          <source>IntoInnerError::error</source>
          <target state="translated">IntoInnerError::error</target>
        </trans-unit>
        <trans-unit id="b1804b3db5a18e0f8ea6f6cff9edd76e45db12ed" translate="yes" xml:space="preserve">
          <source>IntoInnerError::fmt</source>
          <target state="translated">IntoInnerError::fmt</target>
        </trans-unit>
        <trans-unit id="74ec382ed3daa2186fca394930d62ea36a8c17d2" translate="yes" xml:space="preserve">
          <source>IntoInnerError::from</source>
          <target state="translated">IntoInnerError::from</target>
        </trans-unit>
        <trans-unit id="f77ca8c3b2a09378cb7ab11a7034bfe301502366" translate="yes" xml:space="preserve">
          <source>IntoInnerError::into</source>
          <target state="translated">IntoInnerError::into</target>
        </trans-unit>
        <trans-unit id="b64935fe113c6776466d9f925b72b58f10a95d0a" translate="yes" xml:space="preserve">
          <source>IntoInnerError::into_inner</source>
          <target state="translated">IntoInnerError::into_inner</target>
        </trans-unit>
        <trans-unit id="b98cd1e7eff5f2d406e34cac12fb4fec6a0205d4" translate="yes" xml:space="preserve">
          <source>IntoInnerError::source</source>
          <target state="translated">IntoInnerError::source</target>
        </trans-unit>
        <trans-unit id="b27666ff3803b78aee0d747dc0d776b1f36b641a" translate="yes" xml:space="preserve">
          <source>IntoInnerError::to_string</source>
          <target state="translated">IntoInnerError::to_string</target>
        </trans-unit>
        <trans-unit id="0b54c908cc8363881d303f189af2d3a384fbe644" translate="yes" xml:space="preserve">
          <source>IntoInnerError::try_from</source>
          <target state="translated">IntoInnerError::try_from</target>
        </trans-unit>
        <trans-unit id="496358b49c2805d5e6526e43d48129b6eb94e5f4" translate="yes" xml:space="preserve">
          <source>IntoInnerError::try_into</source>
          <target state="translated">IntoInnerError::try_into</target>
        </trans-unit>
        <trans-unit id="b48124715dd42f1aa190750b7aa9535327b5b2db" translate="yes" xml:space="preserve">
          <source>IntoInnerError::type_id</source>
          <target state="translated">IntoInnerError::type_id</target>
        </trans-unit>
        <trans-unit id="d5bc3a63a8bde6cc5fb0c0c11c8f6e6a2d150f75" translate="yes" xml:space="preserve">
          <source>IntoIter</source>
          <target state="translated">IntoIter</target>
        </trans-unit>
        <trans-unit id="169272921e3355905d2215419cf69783d5e1115d" translate="yes" xml:space="preserve">
          <source>IntoIter::all</source>
          <target state="translated">IntoIter::all</target>
        </trans-unit>
        <trans-unit id="a15574f60107e9d0464eff7cacee4bccf74dd72e" translate="yes" xml:space="preserve">
          <source>IntoIter::any</source>
          <target state="translated">IntoIter::any</target>
        </trans-unit>
        <trans-unit id="51c36bf4138559f11f65b74500f686e06c1f07c6" translate="yes" xml:space="preserve">
          <source>IntoIter::as_mut_slice</source>
          <target state="translated">IntoIter::as_mut_slice</target>
        </trans-unit>
        <trans-unit id="375d884ce90ecd76e63b6eebc5d52f38165f98ea" translate="yes" xml:space="preserve">
          <source>IntoIter::as_slice</source>
          <target state="translated">IntoIter::as_slice</target>
        </trans-unit>
        <trans-unit id="945728e84b93878ccde99bc6b6c902e3add25ce9" translate="yes" xml:space="preserve">
          <source>IntoIter::borrow</source>
          <target state="translated">IntoIter::borrow</target>
        </trans-unit>
        <trans-unit id="4db752fa4ec7a9c0d095aaf0baac141df030f531" translate="yes" xml:space="preserve">
          <source>IntoIter::borrow_mut</source>
          <target state="translated">IntoIter::borrow_mut</target>
        </trans-unit>
        <trans-unit id="aaf973384105c3d31f532c4ad4e6dc925ca8038e" translate="yes" xml:space="preserve">
          <source>IntoIter::by_ref</source>
          <target state="translated">IntoIter::by_ref</target>
        </trans-unit>
        <trans-unit id="bcd8f637007c65386e7e2794c338143218170c6f" translate="yes" xml:space="preserve">
          <source>IntoIter::chain</source>
          <target state="translated">IntoIter::chain</target>
        </trans-unit>
        <trans-unit id="4b7971718173fafccbf11a50c2db440035e10f18" translate="yes" xml:space="preserve">
          <source>IntoIter::clone</source>
          <target state="translated">IntoIter::clone</target>
        </trans-unit>
        <trans-unit id="cdb70f02920a7096b80eae8222a39e9acc9946ce" translate="yes" xml:space="preserve">
          <source>IntoIter::clone_from</source>
          <target state="translated">IntoIter::clone_from</target>
        </trans-unit>
        <trans-unit id="a82a0721b8481c0815dcd502e84574a2073e6632" translate="yes" xml:space="preserve">
          <source>IntoIter::clone_into</source>
          <target state="translated">IntoIter::clone_into</target>
        </trans-unit>
        <trans-unit id="50371856061d6c57455d0ce1dfd33e8f9cb33e2b" translate="yes" xml:space="preserve">
          <source>IntoIter::cloned</source>
          <target state="translated">IntoIter::cloned</target>
        </trans-unit>
        <trans-unit id="e8ad516621215eb3804081635021e01bb0d15b51" translate="yes" xml:space="preserve">
          <source>IntoIter::cmp</source>
          <target state="translated">IntoIter::cmp</target>
        </trans-unit>
        <trans-unit id="8fbe1060e2b348d75cd8e260134f4152fb629580" translate="yes" xml:space="preserve">
          <source>IntoIter::collect</source>
          <target state="translated">IntoIter::collect</target>
        </trans-unit>
        <trans-unit id="49b1597675bf50c85b1e156757a3fba15d6379b2" translate="yes" xml:space="preserve">
          <source>IntoIter::copied</source>
          <target state="translated">IntoIter::copied</target>
        </trans-unit>
        <trans-unit id="1b07d7fdfbcbc77dd6f739fc3349c3f2c936082e" translate="yes" xml:space="preserve">
          <source>IntoIter::count</source>
          <target state="translated">IntoIter::count</target>
        </trans-unit>
        <trans-unit id="abc24391b60331e5b16547b639bace5c08a577cf" translate="yes" xml:space="preserve">
          <source>IntoIter::cycle</source>
          <target state="translated">IntoIter::cycle</target>
        </trans-unit>
        <trans-unit id="076c1a1b603e193e4eb4e0757f8c8cf292b8dfb5" translate="yes" xml:space="preserve">
          <source>IntoIter::drop</source>
          <target state="translated">IntoIter::drop</target>
        </trans-unit>
        <trans-unit id="c4d617218636a45df4ca846f67499ffba56d0009" translate="yes" xml:space="preserve">
          <source>IntoIter::enumerate</source>
          <target state="translated">IntoIter::enumerate</target>
        </trans-unit>
        <trans-unit id="203a6dcfb8a13fd0add782bc832058504307c28c" translate="yes" xml:space="preserve">
          <source>IntoIter::eq</source>
          <target state="translated">IntoIter::eq</target>
        </trans-unit>
        <trans-unit id="c908d336a9125db6fbd5e895b62999e14ef83fab" translate="yes" xml:space="preserve">
          <source>IntoIter::filter</source>
          <target state="translated">IntoIter::filter</target>
        </trans-unit>
        <trans-unit id="dffdf83b64aeaec0f8093868f1a7bbb32780e9ca" translate="yes" xml:space="preserve">
          <source>IntoIter::filter_map</source>
          <target state="translated">IntoIter::filter_map</target>
        </trans-unit>
        <trans-unit id="ab410a5d7b7cbc92b7134e524269b1fa848fc30b" translate="yes" xml:space="preserve">
          <source>IntoIter::find</source>
          <target state="translated">IntoIter::find</target>
        </trans-unit>
        <trans-unit id="27ee1265a09c796da003def69a36560ceff2b181" translate="yes" xml:space="preserve">
          <source>IntoIter::find_map</source>
          <target state="translated">IntoIter::find_map</target>
        </trans-unit>
        <trans-unit id="eddd95067e023ebec6158e4fd0749c395bbce3b5" translate="yes" xml:space="preserve">
          <source>IntoIter::flat_map</source>
          <target state="translated">IntoIter::flat_map</target>
        </trans-unit>
        <trans-unit id="24f22711986263a8d0e02c113bb93328c331ce4c" translate="yes" xml:space="preserve">
          <source>IntoIter::flatten</source>
          <target state="translated">IntoIter::flatten</target>
        </trans-unit>
        <trans-unit id="e538b5a92b4ad8916bfeef8710693a5e5266e987" translate="yes" xml:space="preserve">
          <source>IntoIter::fmt</source>
          <target state="translated">IntoIter::fmt</target>
        </trans-unit>
        <trans-unit id="d818332c13e9dac3c39cfd50a50265cfaea983ac" translate="yes" xml:space="preserve">
          <source>IntoIter::fold</source>
          <target state="translated">IntoIter::fold</target>
        </trans-unit>
        <trans-unit id="ebce24dad77f86422316868125c1ce1b1376c47d" translate="yes" xml:space="preserve">
          <source>IntoIter::for_each</source>
          <target state="translated">IntoIter::for_each</target>
        </trans-unit>
        <trans-unit id="63d5fee827e27caa7f9e5b809ff35ace75693193" translate="yes" xml:space="preserve">
          <source>IntoIter::from</source>
          <target state="translated">IntoIter::from</target>
        </trans-unit>
        <trans-unit id="d10213dec7222893569b1e32a4313a41a6aaecb0" translate="yes" xml:space="preserve">
          <source>IntoIter::fuse</source>
          <target state="translated">IntoIter::fuse</target>
        </trans-unit>
        <trans-unit id="2c8a9a1c31b0f9b10030a7c20db1f8dae0614589" translate="yes" xml:space="preserve">
          <source>IntoIter::ge</source>
          <target state="translated">IntoIter::ge</target>
        </trans-unit>
        <trans-unit id="104a30acd770869920244c22e6c1a727cdee6dae" translate="yes" xml:space="preserve">
          <source>IntoIter::gt</source>
          <target state="translated">IntoIter::gt</target>
        </trans-unit>
        <trans-unit id="ab8d2e8c457b63ffae7769711a00e1a87b2a56eb" translate="yes" xml:space="preserve">
          <source>IntoIter::inspect</source>
          <target state="translated">IntoIter::inspect</target>
        </trans-unit>
        <trans-unit id="c0c222348756fc6dca4ff42b109916a4d5aa1041" translate="yes" xml:space="preserve">
          <source>IntoIter::into</source>
          <target state="translated">IntoIter::into</target>
        </trans-unit>
        <trans-unit id="00014741248dda82e6a92af65524e8bc527d5270" translate="yes" xml:space="preserve">
          <source>IntoIter::into_iter</source>
          <target state="translated">IntoIter::into_iter</target>
        </trans-unit>
        <trans-unit id="5136432030a36a1b23033a0d753895604b4149ac" translate="yes" xml:space="preserve">
          <source>IntoIter::is_empty</source>
          <target state="translated">IntoIter::is_empty</target>
        </trans-unit>
        <trans-unit id="cf791dcb18f1b7d93faf9bdd64add013d8076499" translate="yes" xml:space="preserve">
          <source>IntoIter::is_sorted</source>
          <target state="translated">IntoIter::is_sorted</target>
        </trans-unit>
        <trans-unit id="5c6daaffe95fe047d7827bfe50f3fd317d40c563" translate="yes" xml:space="preserve">
          <source>IntoIter::is_sorted_by</source>
          <target state="translated">IntoIter::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="9f7c1ed14fd6d8b0ea5624c99850ff1ba4ac8f4c" translate="yes" xml:space="preserve">
          <source>IntoIter::is_sorted_by_key</source>
          <target state="translated">IntoIter::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="e39349aed40aa6fcfd458252b9c0e111206b7d16" translate="yes" xml:space="preserve">
          <source>IntoIter::last</source>
          <target state="translated">IntoIter::last</target>
        </trans-unit>
        <trans-unit id="965a66efe77546764045f5f96e42028dbb177b19" translate="yes" xml:space="preserve">
          <source>IntoIter::le</source>
          <target state="translated">IntoIter::le</target>
        </trans-unit>
        <trans-unit id="22be990e0e582b87c69cd8c67de2cfd9920d77cd" translate="yes" xml:space="preserve">
          <source>IntoIter::len</source>
          <target state="translated">IntoIter::len</target>
        </trans-unit>
        <trans-unit id="8440a9053eaee6916d3cec75da248b9b8410507f" translate="yes" xml:space="preserve">
          <source>IntoIter::lt</source>
          <target state="translated">IntoIter::lt</target>
        </trans-unit>
        <trans-unit id="e3e2d404675aba8735567f55b57c588d0c0c351a" translate="yes" xml:space="preserve">
          <source>IntoIter::map</source>
          <target state="translated">IntoIter::map</target>
        </trans-unit>
        <trans-unit id="181026e325e14528b026dfe68716b7b26ecd2d2d" translate="yes" xml:space="preserve">
          <source>IntoIter::max</source>
          <target state="translated">IntoIter::max</target>
        </trans-unit>
        <trans-unit id="dd9a47d87f8a0e2db21c65ae146ddcfdf6e0f952" translate="yes" xml:space="preserve">
          <source>IntoIter::max_by</source>
          <target state="translated">IntoIter::max_by</target>
        </trans-unit>
        <trans-unit id="32723c1a1514dde11ed20c922fc56eff6425fcc8" translate="yes" xml:space="preserve">
          <source>IntoIter::max_by_key</source>
          <target state="translated">IntoIter::max_by_key</target>
        </trans-unit>
        <trans-unit id="c528958b5dc23955203383c2f66331a5a91f6f86" translate="yes" xml:space="preserve">
          <source>IntoIter::min</source>
          <target state="translated">IntoIter::min</target>
        </trans-unit>
        <trans-unit id="390fd21e220a5da046b34c827add37c65b895f97" translate="yes" xml:space="preserve">
          <source>IntoIter::min_by</source>
          <target state="translated">IntoIter::min_by</target>
        </trans-unit>
        <trans-unit id="05a738d3c9912a808e8d6c464d2a7c6d5e602efc" translate="yes" xml:space="preserve">
          <source>IntoIter::min_by_key</source>
          <target state="translated">IntoIter::min_by_key</target>
        </trans-unit>
        <trans-unit id="6cc5e0ff9437accb5f5b72fc20bbf3b3985983ae" translate="yes" xml:space="preserve">
          <source>IntoIter::ne</source>
          <target state="translated">IntoIter::ne</target>
        </trans-unit>
        <trans-unit id="95d68245f80704a894c91867b96e64891330dc8f" translate="yes" xml:space="preserve">
          <source>IntoIter::next</source>
          <target state="translated">IntoIter::next</target>
        </trans-unit>
        <trans-unit id="c4df8bce742e0396e8452ed5481fe551b8b2badd" translate="yes" xml:space="preserve">
          <source>IntoIter::next_back</source>
          <target state="translated">IntoIter::next_back</target>
        </trans-unit>
        <trans-unit id="489c39625b1b427238a77aa99c56a91ae04c9c31" translate="yes" xml:space="preserve">
          <source>IntoIter::nth</source>
          <target state="translated">IntoIter::nth</target>
        </trans-unit>
        <trans-unit id="54146217e0f00a76ac06385e197cdac1011f680c" translate="yes" xml:space="preserve">
          <source>IntoIter::nth_back</source>
          <target state="translated">IntoIter::nth_back</target>
        </trans-unit>
        <trans-unit id="2a293f8986446751513826e2a6e67042070d4889" translate="yes" xml:space="preserve">
          <source>IntoIter::partial_cmp</source>
          <target state="translated">IntoIter::partial_cmp</target>
        </trans-unit>
        <trans-unit id="7432ba6416e1cdf63a74ea8f79c2559a3d61d6f5" translate="yes" xml:space="preserve">
          <source>IntoIter::partition</source>
          <target state="translated">IntoIter::partition</target>
        </trans-unit>
        <trans-unit id="a2c1d18ee38c61b94c1e15afa12302f3d7a18c8a" translate="yes" xml:space="preserve">
          <source>IntoIter::peekable</source>
          <target state="translated">IntoIter::peekable</target>
        </trans-unit>
        <trans-unit id="7240e01f5d7115ce4d05e7b2faa4a077b8d81625" translate="yes" xml:space="preserve">
          <source>IntoIter::position</source>
          <target state="translated">IntoIter::position</target>
        </trans-unit>
        <trans-unit id="0fd92308f15c7b0abf6973b7defdbd676ab073f7" translate="yes" xml:space="preserve">
          <source>IntoIter::product</source>
          <target state="translated">IntoIter::product</target>
        </trans-unit>
        <trans-unit id="87be344797cbbbf8b5139732e88f449d1b5cc284" translate="yes" xml:space="preserve">
          <source>IntoIter::rev</source>
          <target state="translated">IntoIter::rev</target>
        </trans-unit>
        <trans-unit id="cb35ac9eaac8868683280e1dd8b84b76dcd5253c" translate="yes" xml:space="preserve">
          <source>IntoIter::rfind</source>
          <target state="translated">IntoIter::rfind</target>
        </trans-unit>
        <trans-unit id="7231cdd22fc5f767b74f59229681b2cb27b3a8a9" translate="yes" xml:space="preserve">
          <source>IntoIter::rfold</source>
          <target state="translated">IntoIter::rfold</target>
        </trans-unit>
        <trans-unit id="fc4f91f7bc50fd166afe9eee868201d382ba4b60" translate="yes" xml:space="preserve">
          <source>IntoIter::rposition</source>
          <target state="translated">IntoIter::rposition</target>
        </trans-unit>
        <trans-unit id="5298f16d195003a5ea725c4a2f787c36fc2ecf95" translate="yes" xml:space="preserve">
          <source>IntoIter::scan</source>
          <target state="translated">IntoIter::scan</target>
        </trans-unit>
        <trans-unit id="e2c872b5440e3714483ceb31004f10b634f3b596" translate="yes" xml:space="preserve">
          <source>IntoIter::size_hint</source>
          <target state="translated">IntoIter::size_hint</target>
        </trans-unit>
        <trans-unit id="8da43de95b9fb617735c0b5f05ce1971df79ae91" translate="yes" xml:space="preserve">
          <source>IntoIter::skip</source>
          <target state="translated">IntoIter::skip</target>
        </trans-unit>
        <trans-unit id="7cdd555373586d1cc526b91787520022c1b5802f" translate="yes" xml:space="preserve">
          <source>IntoIter::skip_while</source>
          <target state="translated">IntoIter::skip_while</target>
        </trans-unit>
        <trans-unit id="661cf4b069d769b36d7e4adf5b8fb0aa4c3dd29f" translate="yes" xml:space="preserve">
          <source>IntoIter::step_by</source>
          <target state="translated">IntoIter::step_by</target>
        </trans-unit>
        <trans-unit id="98bf1ddbdcb82a855ba5cfa0a55bb46fec337f4b" translate="yes" xml:space="preserve">
          <source>IntoIter::sum</source>
          <target state="translated">IntoIter::sum</target>
        </trans-unit>
        <trans-unit id="d4618f74f9d5d75a0acca06e8a09c073539a2aef" translate="yes" xml:space="preserve">
          <source>IntoIter::take</source>
          <target state="translated">IntoIter::take</target>
        </trans-unit>
        <trans-unit id="9fe22ceb1381a9edace4e35f2d28c23142f99a56" translate="yes" xml:space="preserve">
          <source>IntoIter::take_while</source>
          <target state="translated">IntoIter::take_while</target>
        </trans-unit>
        <trans-unit id="2b34db4df91a1ac8be037bcd7eb58942819d00ad" translate="yes" xml:space="preserve">
          <source>IntoIter::to_owned</source>
          <target state="translated">IntoIter::to_owned</target>
        </trans-unit>
        <trans-unit id="772750fa37f6b74b4e6358710cdb957bddeb44ce" translate="yes" xml:space="preserve">
          <source>IntoIter::try_fold</source>
          <target state="translated">IntoIter::try_fold</target>
        </trans-unit>
        <trans-unit id="edf3daf75af0e05f2d21875b7c094720775d11c5" translate="yes" xml:space="preserve">
          <source>IntoIter::try_for_each</source>
          <target state="translated">IntoIter::try_for_each</target>
        </trans-unit>
        <trans-unit id="d6b9806fe0a7d9fecc2d3de823bae6fd8502edb8" translate="yes" xml:space="preserve">
          <source>IntoIter::try_from</source>
          <target state="translated">IntoIter::try_from</target>
        </trans-unit>
        <trans-unit id="c651b804d75adc612d6c4b9e3a2f3139ff83b4ef" translate="yes" xml:space="preserve">
          <source>IntoIter::try_into</source>
          <target state="translated">IntoIter::try_into</target>
        </trans-unit>
        <trans-unit id="0dba2be6b9f4b004d4e321a351df358b821e2637" translate="yes" xml:space="preserve">
          <source>IntoIter::try_rfold</source>
          <target state="translated">IntoIter::try_rfold</target>
        </trans-unit>
        <trans-unit id="b656b4334602090068cb0e3af82bcfe6e99000c6" translate="yes" xml:space="preserve">
          <source>IntoIter::type_id</source>
          <target state="translated">IntoIter::type_id</target>
        </trans-unit>
        <trans-unit id="93d7a5a1be00e631699c6d0e8f2b9a469d7682df" translate="yes" xml:space="preserve">
          <source>IntoIter::unzip</source>
          <target state="translated">IntoIter::unzip</target>
        </trans-unit>
        <trans-unit id="2ead629bd91db49e5e289d4a9d83aa966e2aef76" translate="yes" xml:space="preserve">
          <source>IntoIter::zip</source>
          <target state="translated">IntoIter::zip</target>
        </trans-unit>
        <trans-unit id="5a9e582d9690319d0718e51b09f69686a20f0e41" translate="yes" xml:space="preserve">
          <source>IntoIterSorted</source>
          <target state="translated">IntoIterSorted</target>
        </trans-unit>
        <trans-unit id="7ec61d625cdf338b6e7eefc1b7f35fb136a21981" translate="yes" xml:space="preserve">
          <source>IntoIterator</source>
          <target state="translated">IntoIterator</target>
        </trans-unit>
        <trans-unit id="6c78f7b3978fea56c0f5ff4073e20eca741514bf" translate="yes" xml:space="preserve">
          <source>IntoIterator::into_iter</source>
          <target state="translated">IntoIterator::into_iter</target>
        </trans-unit>
        <trans-unit id="d9576fb0c66590a804264acb28dd47a3fb023c22" translate="yes" xml:space="preserve">
          <source>IntoKeys</source>
          <target state="translated">IntoKeys</target>
        </trans-unit>
        <trans-unit id="16b2c49e47a9cdd1e65117e3f6dfb4bcbee6f387" translate="yes" xml:space="preserve">
          <source>IntoRawFd</source>
          <target state="translated">IntoRawFd</target>
        </trans-unit>
        <trans-unit id="a365631ab12e53b287fe74345a1899c6e331c741" translate="yes" xml:space="preserve">
          <source>IntoRawHandle</source>
          <target state="translated">IntoRawHandle</target>
        </trans-unit>
        <trans-unit id="9d9a97edc4ce8e9862f860071c09a9c14a518af1" translate="yes" xml:space="preserve">
          <source>IntoRawSocket</source>
          <target state="translated">IntoRawSocket</target>
        </trans-unit>
        <trans-unit id="7f11e8cc7632bcc87c94b5a2c9b1b74de01004d8" translate="yes" xml:space="preserve">
          <source>IntoStringError</source>
          <target state="translated">IntoStringError</target>
        </trans-unit>
        <trans-unit id="50d9b93fcfc23141a5ffff21c34c9750d4a3c933" translate="yes" xml:space="preserve">
          <source>IntoStringError::borrow</source>
          <target state="translated">IntoStringError::borrow</target>
        </trans-unit>
        <trans-unit id="1966c3cf239a5f29a297fcc1a9db02fe5893217d" translate="yes" xml:space="preserve">
          <source>IntoStringError::borrow_mut</source>
          <target state="translated">IntoStringError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4452bc0fb43159ff656d4a93c8618a42c0393734" translate="yes" xml:space="preserve">
          <source>IntoStringError::cause</source>
          <target state="translated">IntoStringError::cause</target>
        </trans-unit>
        <trans-unit id="311fc7dd5db9e933c2a85125d79440050ba91ace" translate="yes" xml:space="preserve">
          <source>IntoStringError::clone</source>
          <target state="translated">IntoStringError::clone</target>
        </trans-unit>
        <trans-unit id="170ddc74179150ba05b86b24f4fbc1d6aa2d52e0" translate="yes" xml:space="preserve">
          <source>IntoStringError::clone_from</source>
          <target state="translated">IntoStringError::clone_from</target>
        </trans-unit>
        <trans-unit id="e4500a75c8a08379e11e639eff9a48d27a0ae646" translate="yes" xml:space="preserve">
          <source>IntoStringError::clone_into</source>
          <target state="translated">IntoStringError::clone_into</target>
        </trans-unit>
        <trans-unit id="e6d3177264e5419002ca6b90870d84f6de5318ae" translate="yes" xml:space="preserve">
          <source>IntoStringError::description</source>
          <target state="translated">IntoStringError::description</target>
        </trans-unit>
        <trans-unit id="5bb48ecdc95fe61110fc679d446ff8bfb8efd2a3" translate="yes" xml:space="preserve">
          <source>IntoStringError::eq</source>
          <target state="translated">IntoStringError::eq</target>
        </trans-unit>
        <trans-unit id="2de62132572699348da4c1486645acbfe65816f7" translate="yes" xml:space="preserve">
          <source>IntoStringError::fmt</source>
          <target state="translated">IntoStringError::fmt</target>
        </trans-unit>
        <trans-unit id="371ee3a8925c033093eb47daab1eaf52038293a7" translate="yes" xml:space="preserve">
          <source>IntoStringError::from</source>
          <target state="translated">IntoStringError::from</target>
        </trans-unit>
        <trans-unit id="7701464be4ef893fc2c5c3f4c5145f545fd69bc7" translate="yes" xml:space="preserve">
          <source>IntoStringError::into</source>
          <target state="translated">IntoStringError::into</target>
        </trans-unit>
        <trans-unit id="582c82615bdad453dc78b3b7161f1c2e89500049" translate="yes" xml:space="preserve">
          <source>IntoStringError::into_cstring</source>
          <target state="translated">IntoStringError::into_cstring</target>
        </trans-unit>
        <trans-unit id="72c3a4bc2137cb67b0ad93a2e5391da1fc022c51" translate="yes" xml:space="preserve">
          <source>IntoStringError::ne</source>
          <target state="translated">IntoStringError::ne</target>
        </trans-unit>
        <trans-unit id="44a66cffe02ce75fc4e71dc95ab13d91cdba6c61" translate="yes" xml:space="preserve">
          <source>IntoStringError::source</source>
          <target state="translated">IntoStringError::source</target>
        </trans-unit>
        <trans-unit id="ad03af038caae21639f90297a46d2ffcd2596ee4" translate="yes" xml:space="preserve">
          <source>IntoStringError::to_owned</source>
          <target state="translated">IntoStringError::to_owned</target>
        </trans-unit>
        <trans-unit id="c09f10ab1dd9b0342f7fb1dad4fc7e2096345bb9" translate="yes" xml:space="preserve">
          <source>IntoStringError::to_string</source>
          <target state="translated">IntoStringError::to_string</target>
        </trans-unit>
        <trans-unit id="5c3026fa186ad1f8d938dd92384c9db9e3dc865e" translate="yes" xml:space="preserve">
          <source>IntoStringError::try_from</source>
          <target state="translated">IntoStringError::try_from</target>
        </trans-unit>
        <trans-unit id="9fba74ad721f87d025ad8e718482da5c76958744" translate="yes" xml:space="preserve">
          <source>IntoStringError::try_into</source>
          <target state="translated">IntoStringError::try_into</target>
        </trans-unit>
        <trans-unit id="99cffcb47b8ca60f8f0bb7b29b56b473ac510576" translate="yes" xml:space="preserve">
          <source>IntoStringError::type_id</source>
          <target state="translated">IntoStringError::type_id</target>
        </trans-unit>
        <trans-unit id="0bd993d0b67ac388c683b5e901ee7503442bb940" translate="yes" xml:space="preserve">
          <source>IntoStringError::utf8_error</source>
          <target state="translated">IntoStringError::utf8_error</target>
        </trans-unit>
        <trans-unit id="8c734a51383a161298950f1bdab61a8852ba0f3c" translate="yes" xml:space="preserve">
          <source>IntoValues</source>
          <target state="translated">IntoValues</target>
        </trans-unit>
        <trans-unit id="54ac30147bd72e0bc1ea9316f36c7e85df3ce9ba" translate="yes" xml:space="preserve">
          <source>Introducing mutability 'inside' of something immutable</source>
          <target state="translated">불변의 '내부'가변성을 소개합니다</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="633ae22a8ea65542349f4c6d8bd195a50bd29e7d" translate="yes" xml:space="preserve">
          <source>Invalid ABI (Application Binary Interface) used in the code.</source>
          <target state="translated">코드에 잘못된 ABI (Application Binary Interface)가 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="91f8a82c86c42154fb0095cbe44eb1389b3549a5" translate="yes" xml:space="preserve">
          <source>Invalid Array Element Access</source>
          <target state="translated">잘못된 배열 요소 액세스</target>
        </trans-unit>
        <trans-unit id="b05fe7935b939bfbbf85104eb2c338970f3d02f1" translate="yes" xml:space="preserve">
          <source>Invalid metadata in a wide reference, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, or raw pointer:</source>
          <target state="translated">와이드 참조, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 또는 원시 포인터의 잘못된 메타 데이터 :</target>
        </trans-unit>
        <trans-unit id="d246a9d199c00b56fdfcde8fcd1cd5c6d94b9a1b" translate="yes" xml:space="preserve">
          <source>Invalid monomorphization of an intrinsic function was used.</source>
          <target state="translated">내장 함수의 유효하지 않은 단일 형태가 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="48ebb476b87cd60f48ebf50a0407b351c5107cec" translate="yes" xml:space="preserve">
          <source>Invalid monomorphization of an intrinsic function was used. Erroneous code example:</source>
          <target state="translated">고유 함수의 유효하지 않은 단일 변형이 사용되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="5ede6c63a691e01ee97efae352db5386371736a5" translate="yes" xml:space="preserve">
          <source>Invalid values for a type with a custom definition of invalid values. In the standard library, this affects &lt;a href=&quot;https://doc.rust-lang.org/core/ptr/struct.NonNull.html&quot;&gt;&lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/core/num/index.html&quot;&gt;&lt;code&gt;NonZero*&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">잘못된 값의 사용자 정의 정의가있는 유형의 값이 잘못되었습니다. 표준 라이브러리에서 이는 &lt;a href=&quot;https://doc.rust-lang.org/core/ptr/struct.NonNull.html&quot;&gt; &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://doc.rust-lang.org/core/num/index.html&quot;&gt; &lt;code&gt;NonZero*&lt;/code&gt; &lt;/a&gt; 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="2724bdaef4601c56db3d05244277ab05b35a54b3" translate="yes" xml:space="preserve">
          <source>Invalid values in primitive types, even in private fields and locals:</source>
          <target state="translated">개인 필드 및 로컬에서도 원시 유형의 유효하지 않은 값 :</target>
        </trans-unit>
        <trans-unit id="3390616cafac7ff314d6aadaf20e48034cbb3314" translate="yes" xml:space="preserve">
          <source>Invariants</source>
          <target state="translated">Invariants</target>
        </trans-unit>
        <trans-unit id="556ef6bf1ce64fe45a2cdf7c095ee4ab45ecf2bc" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic cosine function.</source>
          <target state="translated">역 쌍곡 코사인 함수.</target>
        </trans-unit>
        <trans-unit id="6ed8d04de38ff90d141bd8e28a751473d8b5e58a" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic sine function.</source>
          <target state="translated">역 쌍곡 사인 함수.</target>
        </trans-unit>
        <trans-unit id="93d434c1339f113d603c470280ae15d6ba4069dd" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic tangent function.</source>
          <target state="translated">역 쌍곡 탄젠트 함수.</target>
        </trans-unit>
        <trans-unit id="88febe0c5bd47bdcaa24fa407c931736c9254d02" translate="yes" xml:space="preserve">
          <source>Invokes &lt;a href=&quot;../ffi/struct.osstring#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; on the underlying instance of &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 &lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 인스턴스에서 &lt;a href=&quot;../ffi/struct.osstring#method.capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; 을 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="bf466fb0852d7cebcba10b12dd881c0dd0bb5daa" translate="yes" xml:space="preserve">
          <source>Invokes &lt;a href=&quot;../ffi/struct.osstring#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; on the underlying instance of &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 &lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 인스턴스에서 &lt;a href=&quot;../ffi/struct.osstring#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="84ecde704d4d279fa7d2d406323e14c8fdc0fdc9" translate="yes" xml:space="preserve">
          <source>Invokes &lt;a href=&quot;../ffi/struct.osstring#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; on the underlying instance of &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 &lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 인스턴스에서 &lt;a href=&quot;../ffi/struct.osstring#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="19bb4e6602e1786c18a6b52f8a0bcf8a73adf2a7" translate="yes" xml:space="preserve">
          <source>Invokes &lt;a href=&quot;../ffi/struct.osstring#method.reserve_exact&quot;&gt;&lt;code&gt;reserve_exact&lt;/code&gt;&lt;/a&gt; on the underlying instance of &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 &lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 인스턴스에서 &lt;a href=&quot;../ffi/struct.osstring#method.reserve_exact&quot;&gt; &lt;code&gt;reserve_exact&lt;/code&gt; &lt;/a&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="17f17310b62ca98a66dacbef4b44348c04ea8919" translate="yes" xml:space="preserve">
          <source>Invokes &lt;a href=&quot;../ffi/struct.osstring#method.shrink_to&quot;&gt;&lt;code&gt;shrink_to&lt;/code&gt;&lt;/a&gt; on the underlying instance of &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">를 발동은 &lt;a href=&quot;../ffi/struct.osstring#method.shrink_to&quot;&gt; &lt;code&gt;shrink_to&lt;/code&gt; &lt;/a&gt; 의 기본 인스턴스 &lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc1a66892291a57859c285b1511e4adb63b718ef" translate="yes" xml:space="preserve">
          <source>Invokes &lt;a href=&quot;../ffi/struct.osstring#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt; on the underlying instance of &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">를 발동은 &lt;a href=&quot;../ffi/struct.osstring#method.shrink_to_fit&quot;&gt; &lt;code&gt;shrink_to_fit&lt;/code&gt; &lt;/a&gt; 의 기본 인스턴스 &lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33939d473461270530bee40f4613f194eeb624e1" translate="yes" xml:space="preserve">
          <source>Invokes a closure, capturing the cause of an unwinding panic if one occurs.</source>
          <target state="translated">풀림 패닉의 원인을 포착하여 클로저를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="0dc0bc0c16d89f8a26d9f8e8e27b63f4e79127b2" translate="yes" xml:space="preserve">
          <source>Invokes memset on the specified pointer, setting &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes of memory starting at &lt;code&gt;self&lt;/code&gt; to &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">지정된 포인터에서 memset을 호출 하여 &lt;code&gt;self&lt;/code&gt; 에서 &lt;code&gt;val&lt;/code&gt; 로 시작하는 &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 바이트 메모리 를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="7edb4f958e67ccc2ebdef5e59be5a3705d1b5984" translate="yes" xml:space="preserve">
          <source>Invoking the macro on an expression moves and takes ownership of it before returning the evaluated expression unchanged. If the type of the expression does not implement &lt;code&gt;Copy&lt;/code&gt; and you don't want to give up ownership, you can instead borrow with &lt;code&gt;dbg!(&amp;amp;expr)&lt;/code&gt; for some expression &lt;code&gt;expr&lt;/code&gt;.</source>
          <target state="translated">표현식에서 매크로를 호출하면 평가 된 표현식을 변경하지 않고 리턴하기 전에 매크로를 이동하고 소유권을 가져옵니다. 표현식의 유형이 &lt;code&gt;Copy&lt;/code&gt; 구현하지 않고 소유권을 포기하지 않으려면 대신 표현식 &lt;code&gt;expr&lt;/code&gt; 에 대해 &lt;code&gt;dbg!(&amp;amp;expr)&lt;/code&gt; 로 빌릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a14686f3a91a872040e4db2ac1c21bf4f904c92" translate="yes" xml:space="preserve">
          <source>Invoking undefined behavior via compiler intrinsics.</source>
          <target state="translated">컴파일러 내장 함수를 통해 정의되지 않은 동작을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a85319a9242521d1b81154c86dbb76178cda35d2" translate="yes" xml:space="preserve">
          <source>Invoking undefined behavior via compiler intrinsics:</source>
          <target state="translated">컴파일러 내장 함수를 통해 정의되지 않은 동작 호출</target>
        </trans-unit>
        <trans-unit id="8ea7ba835c096df0008ad44cff1240d3b0866ef1" translate="yes" xml:space="preserve">
          <source>IoSlice</source>
          <target state="translated">IoSlice</target>
        </trans-unit>
        <trans-unit id="bf69b8681dc713cd673b4744a6a18884b73addc1" translate="yes" xml:space="preserve">
          <source>IoSlice::align_to</source>
          <target state="translated">IoSlice::align_to</target>
        </trans-unit>
        <trans-unit id="b6ecef449d7c716925f5b7b0b49d082a4bdbc2b8" translate="yes" xml:space="preserve">
          <source>IoSlice::as_ptr</source>
          <target state="translated">IoSlice::as_ptr</target>
        </trans-unit>
        <trans-unit id="77a5c4c2b1cbe6822957872bc631e9dc81a97b7a" translate="yes" xml:space="preserve">
          <source>IoSlice::binary_search</source>
          <target state="translated">IoSlice::binary_search</target>
        </trans-unit>
        <trans-unit id="b99305714a884d4e67d7225ef67c1aaace3a0d2a" translate="yes" xml:space="preserve">
          <source>IoSlice::binary_search_by</source>
          <target state="translated">IoSlice::binary_search_by</target>
        </trans-unit>
        <trans-unit id="b2b7e6c0a986e61ca591420616fe6966a129fdad" translate="yes" xml:space="preserve">
          <source>IoSlice::binary_search_by_key</source>
          <target state="translated">IoSlice::binary_search_by_key</target>
        </trans-unit>
        <trans-unit id="69d111c0972ec5963c7284b91c7aebfcec55891b" translate="yes" xml:space="preserve">
          <source>IoSlice::borrow</source>
          <target state="translated">IoSlice::borrow</target>
        </trans-unit>
        <trans-unit id="e0220b06a9a728a2ee453fdb0bf48c89e6024a6b" translate="yes" xml:space="preserve">
          <source>IoSlice::borrow_mut</source>
          <target state="translated">IoSlice::borrow_mut</target>
        </trans-unit>
        <trans-unit id="67dc23a0402757984c60ce5b402f95252eb22d87" translate="yes" xml:space="preserve">
          <source>IoSlice::chunks</source>
          <target state="translated">IoSlice::chunks</target>
        </trans-unit>
        <trans-unit id="a3056337e95e295361e36fae2d3ac55a93aa581c" translate="yes" xml:space="preserve">
          <source>IoSlice::chunks_exact</source>
          <target state="translated">IoSlice::chunks_exact</target>
        </trans-unit>
        <trans-unit id="911fd13cfc35bda5552744aea0451f85b09933ce" translate="yes" xml:space="preserve">
          <source>IoSlice::contains</source>
          <target state="translated">IoSlice::contains</target>
        </trans-unit>
        <trans-unit id="1bff3dd00133bd3cfb286f3bea310ac0cf1421c3" translate="yes" xml:space="preserve">
          <source>IoSlice::deref</source>
          <target state="translated">IoSlice::deref</target>
        </trans-unit>
        <trans-unit id="48072cbda243e3b9e179d39ee1a7cc128d1a937f" translate="yes" xml:space="preserve">
          <source>IoSlice::ends_with</source>
          <target state="translated">IoSlice::ends_with</target>
        </trans-unit>
        <trans-unit id="12d21cc5f8a9a9ed66a9f121aa2ba7dcd992afa2" translate="yes" xml:space="preserve">
          <source>IoSlice::eq_ignore_ascii_case</source>
          <target state="translated">IoSlice::eq_ignore_ascii_case</target>
        </trans-unit>
        <trans-unit id="cd8d733f91433d04a8ce7781e52e70e7dfffd99f" translate="yes" xml:space="preserve">
          <source>IoSlice::first</source>
          <target state="translated">IoSlice::first</target>
        </trans-unit>
        <trans-unit id="df6126ce38880e35ce060ff0c854c8309a24ac0e" translate="yes" xml:space="preserve">
          <source>IoSlice::fmt</source>
          <target state="translated">IoSlice::fmt</target>
        </trans-unit>
        <trans-unit id="ff7211a4daabf521e93261511880baae217efac4" translate="yes" xml:space="preserve">
          <source>IoSlice::from</source>
          <target state="translated">IoSlice::from</target>
        </trans-unit>
        <trans-unit id="3f81ad3ba2d6f6e75b1565f7d95b6aaa063cf60a" translate="yes" xml:space="preserve">
          <source>IoSlice::get</source>
          <target state="translated">IoSlice::get</target>
        </trans-unit>
        <trans-unit id="ddd8c6f234cd7ab0c552da1f27123df012711db7" translate="yes" xml:space="preserve">
          <source>IoSlice::get_unchecked</source>
          <target state="translated">IoSlice::get_unchecked</target>
        </trans-unit>
        <trans-unit id="fea55d08cc2b49f13f05547189186a4dc8d60ff9" translate="yes" xml:space="preserve">
          <source>IoSlice::into</source>
          <target state="translated">IoSlice::into</target>
        </trans-unit>
        <trans-unit id="fa82db2f2b2c313a4de2311d7bc8d4baf4a421fa" translate="yes" xml:space="preserve">
          <source>IoSlice::is_ascii</source>
          <target state="translated">IoSlice::is_ascii</target>
        </trans-unit>
        <trans-unit id="ff882761d48529351ae9d206494e3bec2c600ee5" translate="yes" xml:space="preserve">
          <source>IoSlice::is_empty</source>
          <target state="translated">IoSlice::is_empty</target>
        </trans-unit>
        <trans-unit id="3545e77f51efa1c6b8286f04bc4e0b2470be417b" translate="yes" xml:space="preserve">
          <source>IoSlice::is_sorted</source>
          <target state="translated">IoSlice::is_sorted</target>
        </trans-unit>
        <trans-unit id="4701fb2e410ad6e71f1f087266f993194c134f7b" translate="yes" xml:space="preserve">
          <source>IoSlice::is_sorted_by</source>
          <target state="translated">IoSlice::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="9472b8d8f8511079fc16e702ed084b2b7f7e6016" translate="yes" xml:space="preserve">
          <source>IoSlice::is_sorted_by_key</source>
          <target state="translated">IoSlice::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="2f0762847dd7e3fd1491b336362b18393b1a6965" translate="yes" xml:space="preserve">
          <source>IoSlice::iter</source>
          <target state="translated">IoSlice::iter</target>
        </trans-unit>
        <trans-unit id="f1c33c515a4f6f2a77787f9f8b1800fc0cb7392a" translate="yes" xml:space="preserve">
          <source>IoSlice::last</source>
          <target state="translated">IoSlice::last</target>
        </trans-unit>
        <trans-unit id="71b526ef1019bf4f73ee807254105381336e4d1c" translate="yes" xml:space="preserve">
          <source>IoSlice::len</source>
          <target state="translated">IoSlice::len</target>
        </trans-unit>
        <trans-unit id="967dd07a6e0c5576e4280dec2d30d45df16ac291" translate="yes" xml:space="preserve">
          <source>IoSlice::new</source>
          <target state="translated">IoSlice::new</target>
        </trans-unit>
        <trans-unit id="e9562dd3a5978f42d06066035675f397acce1c2b" translate="yes" xml:space="preserve">
          <source>IoSlice::rchunks</source>
          <target state="translated">IoSlice::rchunks</target>
        </trans-unit>
        <trans-unit id="af30963d5b4c2c7628a5afb93f5a9d3130eaa545" translate="yes" xml:space="preserve">
          <source>IoSlice::rchunks_exact</source>
          <target state="translated">IoSlice::rchunks_exact</target>
        </trans-unit>
        <trans-unit id="5006a78909ddbf7c8e9227d27186ddd35dae6459" translate="yes" xml:space="preserve">
          <source>IoSlice::repeat</source>
          <target state="translated">IoSlice::repeat</target>
        </trans-unit>
        <trans-unit id="055c2496baa6ae3bd9b33d660b588e6f2ebf5d4c" translate="yes" xml:space="preserve">
          <source>IoSlice::rsplit</source>
          <target state="translated">IoSlice::rsplit</target>
        </trans-unit>
        <trans-unit id="d3df5856ba5180f3260fca40514105630ea1ae9a" translate="yes" xml:space="preserve">
          <source>IoSlice::rsplitn</source>
          <target state="translated">IoSlice::rsplitn</target>
        </trans-unit>
        <trans-unit id="4e9115a3db6b0c099ecf94ffba746840b9b61e39" translate="yes" xml:space="preserve">
          <source>IoSlice::split</source>
          <target state="translated">IoSlice::split</target>
        </trans-unit>
        <trans-unit id="69853953f39b08c8104a39f89f6c888f20cccdf6" translate="yes" xml:space="preserve">
          <source>IoSlice::split_at</source>
          <target state="translated">IoSlice::split_at</target>
        </trans-unit>
        <trans-unit id="49a1324d962da721e4be986803d84827537c7170" translate="yes" xml:space="preserve">
          <source>IoSlice::split_first</source>
          <target state="translated">IoSlice::split_first</target>
        </trans-unit>
        <trans-unit id="05538b404adac2961d7e5bc92bef01b019825cd6" translate="yes" xml:space="preserve">
          <source>IoSlice::split_last</source>
          <target state="translated">IoSlice::split_last</target>
        </trans-unit>
        <trans-unit id="019564e811a7ef239d682e135b0fc68c251b133b" translate="yes" xml:space="preserve">
          <source>IoSlice::splitn</source>
          <target state="translated">IoSlice::splitn</target>
        </trans-unit>
        <trans-unit id="f61e9cda20345736621059e982beaf04c366b19b" translate="yes" xml:space="preserve">
          <source>IoSlice::starts_with</source>
          <target state="translated">IoSlice::starts_with</target>
        </trans-unit>
        <trans-unit id="843f9a3f4aeba9de52f81c21b641623650a4f908" translate="yes" xml:space="preserve">
          <source>IoSlice::to_ascii_lowercase</source>
          <target state="translated">IoSlice::to_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="1000adb40178bc3812fa5c878bdbe59eab225ef9" translate="yes" xml:space="preserve">
          <source>IoSlice::to_ascii_uppercase</source>
          <target state="translated">IoSlice::to_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="8a40698597eb46430e06c8ca37e19cc35bf7670e" translate="yes" xml:space="preserve">
          <source>IoSlice::to_vec</source>
          <target state="translated">IoSlice::to_vec</target>
        </trans-unit>
        <trans-unit id="790cec74306c7f07e3a27b8f7dfb0bbb3794bb65" translate="yes" xml:space="preserve">
          <source>IoSlice::try_from</source>
          <target state="translated">IoSlice::try_from</target>
        </trans-unit>
        <trans-unit id="43f5e13ccc6bae71b7f6204f1727c50f3248e591" translate="yes" xml:space="preserve">
          <source>IoSlice::try_into</source>
          <target state="translated">IoSlice::try_into</target>
        </trans-unit>
        <trans-unit id="ba54fa43762f26b417d2b3603b107780cf506264" translate="yes" xml:space="preserve">
          <source>IoSlice::type_id</source>
          <target state="translated">IoSlice::type_id</target>
        </trans-unit>
        <trans-unit id="4e3b2ad4c2f16ac0767ead9ab2125e9d33ceee8e" translate="yes" xml:space="preserve">
          <source>IoSlice::windows</source>
          <target state="translated">IoSlice::windows</target>
        </trans-unit>
        <trans-unit id="3095e84a9c9bc332f4091ce90417e2f7cc01182f" translate="yes" xml:space="preserve">
          <source>IoSliceMut</source>
          <target state="translated">IoSliceMut</target>
        </trans-unit>
        <trans-unit id="edc61764332d50536dc632bf3e42031b6220229f" translate="yes" xml:space="preserve">
          <source>IoSliceMut::align_to</source>
          <target state="translated">IoSliceMut::align_to</target>
        </trans-unit>
        <trans-unit id="6165ce93f6a343b1b6974bf63a9dc441cfa9b855" translate="yes" xml:space="preserve">
          <source>IoSliceMut::align_to_mut</source>
          <target state="translated">IoSliceMut::align_to_mut</target>
        </trans-unit>
        <trans-unit id="756ce08f67d32fb2870a7d27c2cf0b5d1fdceeda" translate="yes" xml:space="preserve">
          <source>IoSliceMut::as_mut_ptr</source>
          <target state="translated">IoSliceMut::as_mut_ptr</target>
        </trans-unit>
        <trans-unit id="53eec41d853d1cd27e3aa8594d9ca519a6e70256" translate="yes" xml:space="preserve">
          <source>IoSliceMut::as_ptr</source>
          <target state="translated">IoSliceMut::as_ptr</target>
        </trans-unit>
        <trans-unit id="feee017bcb491b872bb0c7e0e011449a0d2fba5b" translate="yes" xml:space="preserve">
          <source>IoSliceMut::binary_search</source>
          <target state="translated">IoSliceMut::binary_search</target>
        </trans-unit>
        <trans-unit id="91d068e145a8703aa2b53040a33e0633d07ae322" translate="yes" xml:space="preserve">
          <source>IoSliceMut::binary_search_by</source>
          <target state="translated">IoSliceMut::binary_search_by</target>
        </trans-unit>
        <trans-unit id="cf8c8086f089d2efa99d956c60331c0cffaba94a" translate="yes" xml:space="preserve">
          <source>IoSliceMut::binary_search_by_key</source>
          <target state="translated">IoSliceMut::binary_search_by_key</target>
        </trans-unit>
        <trans-unit id="814009b2627b9eb1414d1db129d496de87b90dee" translate="yes" xml:space="preserve">
          <source>IoSliceMut::borrow</source>
          <target state="translated">IoSliceMut::borrow</target>
        </trans-unit>
        <trans-unit id="caeb2fb6619a9691d7ba27f727be8e220bf3a927" translate="yes" xml:space="preserve">
          <source>IoSliceMut::borrow_mut</source>
          <target state="translated">IoSliceMut::borrow_mut</target>
        </trans-unit>
        <trans-unit id="b1cb059b24c754db0743f290cc8e416acdc4078d" translate="yes" xml:space="preserve">
          <source>IoSliceMut::chunks</source>
          <target state="translated">IoSliceMut::chunks</target>
        </trans-unit>
        <trans-unit id="4ea089981896b2968abb410d369893430efed500" translate="yes" xml:space="preserve">
          <source>IoSliceMut::chunks_exact</source>
          <target state="translated">IoSliceMut::chunks_exact</target>
        </trans-unit>
        <trans-unit id="f1be8473de9a8d39d4f075d887ea01ff1f9161e0" translate="yes" xml:space="preserve">
          <source>IoSliceMut::chunks_exact_mut</source>
          <target state="translated">IoSliceMut::chunks_exact_mut</target>
        </trans-unit>
        <trans-unit id="767b916694743c2e64a1c234e5dd646ac41ca1fc" translate="yes" xml:space="preserve">
          <source>IoSliceMut::chunks_mut</source>
          <target state="translated">IoSliceMut::chunks_mut</target>
        </trans-unit>
        <trans-unit id="f404069508d8888d6af514f87922bc8d40f10f6c" translate="yes" xml:space="preserve">
          <source>IoSliceMut::clone_from_slice</source>
          <target state="translated">IoSliceMut::clone_from_slice</target>
        </trans-unit>
        <trans-unit id="c7c55fc22e698b053cd4550732c2746b176f44ba" translate="yes" xml:space="preserve">
          <source>IoSliceMut::contains</source>
          <target state="translated">IoSliceMut::contains</target>
        </trans-unit>
        <trans-unit id="dbb130c545841944c9cc0b6c9e692b48dc327a1e" translate="yes" xml:space="preserve">
          <source>IoSliceMut::copy_from_slice</source>
          <target state="translated">IoSliceMut::copy_from_slice</target>
        </trans-unit>
        <trans-unit id="71a3fdfdbafc2bc43ba47f9382fcc293b92c46e3" translate="yes" xml:space="preserve">
          <source>IoSliceMut::copy_within</source>
          <target state="translated">IoSliceMut::copy_within</target>
        </trans-unit>
        <trans-unit id="890c0786efc8a468ffebc08fb5498cda52cf33fb" translate="yes" xml:space="preserve">
          <source>IoSliceMut::deref</source>
          <target state="translated">IoSliceMut::deref</target>
        </trans-unit>
        <trans-unit id="4a7f6590300a48130f1f500865046f4da8307d95" translate="yes" xml:space="preserve">
          <source>IoSliceMut::deref_mut</source>
          <target state="translated">IoSliceMut::deref_mut</target>
        </trans-unit>
        <trans-unit id="4c937a77491635e4e51ece3d6794e05ccebd811b" translate="yes" xml:space="preserve">
          <source>IoSliceMut::ends_with</source>
          <target state="translated">IoSliceMut::ends_with</target>
        </trans-unit>
        <trans-unit id="80baa7923010134c30d45ede26ebcb72f4ec4c94" translate="yes" xml:space="preserve">
          <source>IoSliceMut::eq_ignore_ascii_case</source>
          <target state="translated">IoSliceMut::eq_ignore_ascii_case</target>
        </trans-unit>
        <trans-unit id="00978c0ce0b22335f6482ceca143e772ce778265" translate="yes" xml:space="preserve">
          <source>IoSliceMut::first</source>
          <target state="translated">IoSliceMut::first</target>
        </trans-unit>
        <trans-unit id="efca655b88011a830e591bfe2b1493cadaf05e46" translate="yes" xml:space="preserve">
          <source>IoSliceMut::first_mut</source>
          <target state="translated">IoSliceMut::first_mut</target>
        </trans-unit>
        <trans-unit id="087659858c5fbd32d8ce660c5d447d432b4a58f9" translate="yes" xml:space="preserve">
          <source>IoSliceMut::fmt</source>
          <target state="translated">IoSliceMut::fmt</target>
        </trans-unit>
        <trans-unit id="cb369e3527c8a515f146f114fa20da06fa0105bd" translate="yes" xml:space="preserve">
          <source>IoSliceMut::from</source>
          <target state="translated">IoSliceMut::from</target>
        </trans-unit>
        <trans-unit id="1a4874b1746a7812e40b2ffd5ecaf8ee17040c73" translate="yes" xml:space="preserve">
          <source>IoSliceMut::get</source>
          <target state="translated">IoSliceMut::get</target>
        </trans-unit>
        <trans-unit id="87cf1ba0087efc43ee27e77bd516e6bc62235196" translate="yes" xml:space="preserve">
          <source>IoSliceMut::get_mut</source>
          <target state="translated">IoSliceMut::get_mut</target>
        </trans-unit>
        <trans-unit id="9224459dc771cd1e571acc3f60ac5030d6506ad4" translate="yes" xml:space="preserve">
          <source>IoSliceMut::get_unchecked</source>
          <target state="translated">IoSliceMut::get_unchecked</target>
        </trans-unit>
        <trans-unit id="6c84cb3392dfcb3ebc95e49bec2c9a2caf890b70" translate="yes" xml:space="preserve">
          <source>IoSliceMut::get_unchecked_mut</source>
          <target state="translated">IoSliceMut::get_unchecked_mut</target>
        </trans-unit>
        <trans-unit id="87175e203ab3ff1feb03a30f6abb72b0c78f325f" translate="yes" xml:space="preserve">
          <source>IoSliceMut::into</source>
          <target state="translated">IoSliceMut::into</target>
        </trans-unit>
        <trans-unit id="4501fdbbbb28747f7aaad7c1a5b8a44782077179" translate="yes" xml:space="preserve">
          <source>IoSliceMut::is_ascii</source>
          <target state="translated">IoSliceMut::is_ascii</target>
        </trans-unit>
        <trans-unit id="9838cb25545f83e047044f3c84c1e510152c5e9a" translate="yes" xml:space="preserve">
          <source>IoSliceMut::is_empty</source>
          <target state="translated">IoSliceMut::is_empty</target>
        </trans-unit>
        <trans-unit id="f055a512eb3e13e97c7f4986f75a28be49709162" translate="yes" xml:space="preserve">
          <source>IoSliceMut::is_sorted</source>
          <target state="translated">IoSliceMut::is_sorted</target>
        </trans-unit>
        <trans-unit id="3e5f350240631bbb82c3ccc7b63b75f7ef3cff06" translate="yes" xml:space="preserve">
          <source>IoSliceMut::is_sorted_by</source>
          <target state="translated">IoSliceMut::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="f2e9454f22d864a0c455e41dc7fb5b7ca6dd2c05" translate="yes" xml:space="preserve">
          <source>IoSliceMut::is_sorted_by_key</source>
          <target state="translated">IoSliceMut::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="fb1e214569f94fc95d9751c93230dfe38c28f64d" translate="yes" xml:space="preserve">
          <source>IoSliceMut::iter</source>
          <target state="translated">IoSliceMut::iter</target>
        </trans-unit>
        <trans-unit id="d77e5889908e5866350ffeb826e0ee4b302306d1" translate="yes" xml:space="preserve">
          <source>IoSliceMut::iter_mut</source>
          <target state="translated">IoSliceMut::iter_mut</target>
        </trans-unit>
        <trans-unit id="8934e61161bd86f368fc145fd636e2c155d1529f" translate="yes" xml:space="preserve">
          <source>IoSliceMut::last</source>
          <target state="translated">IoSliceMut::last</target>
        </trans-unit>
        <trans-unit id="e110df4ba897b60ee2d225cbfc465e2c2376e128" translate="yes" xml:space="preserve">
          <source>IoSliceMut::last_mut</source>
          <target state="translated">IoSliceMut::last_mut</target>
        </trans-unit>
        <trans-unit id="2ae8d8c5611aee438f8d894e9883dff2fd658f4e" translate="yes" xml:space="preserve">
          <source>IoSliceMut::len</source>
          <target state="translated">IoSliceMut::len</target>
        </trans-unit>
        <trans-unit id="47113547b6123b6a9b0c2bd9c5c02e4ace6bda06" translate="yes" xml:space="preserve">
          <source>IoSliceMut::make_ascii_lowercase</source>
          <target state="translated">IoSliceMut::make_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="1368789df63815a8365adaaa916b097c47ee6bf0" translate="yes" xml:space="preserve">
          <source>IoSliceMut::make_ascii_uppercase</source>
          <target state="translated">IoSliceMut::make_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="2bfeef33af972135cd4201fd40a799693a598545" translate="yes" xml:space="preserve">
          <source>IoSliceMut::new</source>
          <target state="translated">IoSliceMut::new</target>
        </trans-unit>
        <trans-unit id="d0fc0d6411d4a1c6e3b5edaf08263c19c66688b7" translate="yes" xml:space="preserve">
          <source>IoSliceMut::partition_at_index</source>
          <target state="translated">IoSliceMut::partition_at_index</target>
        </trans-unit>
        <trans-unit id="7e77416a3b99e33c3ca80e12413b2d6db2066eb0" translate="yes" xml:space="preserve">
          <source>IoSliceMut::partition_at_index_by</source>
          <target state="translated">IoSliceMut::partition_at_index_by</target>
        </trans-unit>
        <trans-unit id="9259876e720033ee87d32732200d6400132c625e" translate="yes" xml:space="preserve">
          <source>IoSliceMut::partition_at_index_by_key</source>
          <target state="translated">IoSliceMut::partition_at_index_by_key</target>
        </trans-unit>
        <trans-unit id="d3b05480abbc9116759faebf47e681f0d773c97b" translate="yes" xml:space="preserve">
          <source>IoSliceMut::partition_dedup</source>
          <target state="translated">IoSliceMut::partition_dedup</target>
        </trans-unit>
        <trans-unit id="aa55cd0eb794711175af2dd5d3f07714f2510500" translate="yes" xml:space="preserve">
          <source>IoSliceMut::partition_dedup_by</source>
          <target state="translated">IoSliceMut::partition_dedup_by</target>
        </trans-unit>
        <trans-unit id="c9023248e90bdb829d7846b404b7dd00c8e2f1d8" translate="yes" xml:space="preserve">
          <source>IoSliceMut::partition_dedup_by_key</source>
          <target state="translated">IoSliceMut::partition_dedup_by_key</target>
        </trans-unit>
        <trans-unit id="112858cc757d2ee696d5fd19edd29a07e86a60dd" translate="yes" xml:space="preserve">
          <source>IoSliceMut::rchunks</source>
          <target state="translated">IoSliceMut::rchunks</target>
        </trans-unit>
        <trans-unit id="27c3a585495b862cd5953b14b62627eb2b786e7e" translate="yes" xml:space="preserve">
          <source>IoSliceMut::rchunks_exact</source>
          <target state="translated">IoSliceMut::rchunks_exact</target>
        </trans-unit>
        <trans-unit id="0bbc4b799ee0750c9670f7268648fc24ec698bf5" translate="yes" xml:space="preserve">
          <source>IoSliceMut::rchunks_exact_mut</source>
          <target state="translated">IoSliceMut::rchunks_exact_mut</target>
        </trans-unit>
        <trans-unit id="e0079c5e5007cbcfdd4a4ec3cdc15f0f595b4eb9" translate="yes" xml:space="preserve">
          <source>IoSliceMut::rchunks_mut</source>
          <target state="translated">IoSliceMut::rchunks_mut</target>
        </trans-unit>
        <trans-unit id="5a1db3383ef35f1e9a609af596c49764b468ecc0" translate="yes" xml:space="preserve">
          <source>IoSliceMut::repeat</source>
          <target state="translated">IoSliceMut::repeat</target>
        </trans-unit>
        <trans-unit id="4b00bcb936857777cddfc030b90dd94af33aab6f" translate="yes" xml:space="preserve">
          <source>IoSliceMut::reverse</source>
          <target state="translated">IoSliceMut::reverse</target>
        </trans-unit>
        <trans-unit id="b8383f8b3071a37ca80d4fd630b68ae5d6407f25" translate="yes" xml:space="preserve">
          <source>IoSliceMut::rotate_left</source>
          <target state="translated">IoSliceMut::rotate_left</target>
        </trans-unit>
        <trans-unit id="b81b7fa90aa18a998eac27394adb8adaba8589f1" translate="yes" xml:space="preserve">
          <source>IoSliceMut::rotate_right</source>
          <target state="translated">IoSliceMut::rotate_right</target>
        </trans-unit>
        <trans-unit id="8b5984b3aa27e1db968a75d1458662d4356f394f" translate="yes" xml:space="preserve">
          <source>IoSliceMut::rsplit</source>
          <target state="translated">IoSliceMut::rsplit</target>
        </trans-unit>
        <trans-unit id="7b014f737bfafc775e4b112ac7ec11323e2824e1" translate="yes" xml:space="preserve">
          <source>IoSliceMut::rsplit_mut</source>
          <target state="translated">IoSliceMut::rsplit_mut</target>
        </trans-unit>
        <trans-unit id="79948d326e7daffd00109bebcfe6ec92b09222ad" translate="yes" xml:space="preserve">
          <source>IoSliceMut::rsplitn</source>
          <target state="translated">IoSliceMut::rsplitn</target>
        </trans-unit>
        <trans-unit id="8a0545746595f7e4171cebd930e38c4c6d0fd3e8" translate="yes" xml:space="preserve">
          <source>IoSliceMut::rsplitn_mut</source>
          <target state="translated">IoSliceMut::rsplitn_mut</target>
        </trans-unit>
        <trans-unit id="ddb129b041939c14d352bbf67329eeecf7260e65" translate="yes" xml:space="preserve">
          <source>IoSliceMut::sort</source>
          <target state="translated">IoSliceMut::sort</target>
        </trans-unit>
        <trans-unit id="35ba78eb5cd736c963cfc215217c45c8dda10d3b" translate="yes" xml:space="preserve">
          <source>IoSliceMut::sort_by</source>
          <target state="translated">IoSliceMut::sort_by</target>
        </trans-unit>
        <trans-unit id="aee0fff21b9514e212d22c64b39409165b2cab64" translate="yes" xml:space="preserve">
          <source>IoSliceMut::sort_by_cached_key</source>
          <target state="translated">IoSliceMut::sort_by_cached_key</target>
        </trans-unit>
        <trans-unit id="994f7e09e5d80ef5dd812336bcb0a176a31ef6c1" translate="yes" xml:space="preserve">
          <source>IoSliceMut::sort_by_key</source>
          <target state="translated">IoSliceMut::sort_by_key</target>
        </trans-unit>
        <trans-unit id="69a01417bee9fe016be3925f4d1c6f53bb4316b9" translate="yes" xml:space="preserve">
          <source>IoSliceMut::sort_unstable</source>
          <target state="translated">IoSliceMut::sort_unstable</target>
        </trans-unit>
        <trans-unit id="26d86d6c065cff24f16e866215162e8197db89a2" translate="yes" xml:space="preserve">
          <source>IoSliceMut::sort_unstable_by</source>
          <target state="translated">IoSliceMut::sort_unstable_by</target>
        </trans-unit>
        <trans-unit id="1591d811a42faf0c27290c61c13962a9d52e6883" translate="yes" xml:space="preserve">
          <source>IoSliceMut::sort_unstable_by_key</source>
          <target state="translated">IoSliceMut::sort_unstable_by_key</target>
        </trans-unit>
        <trans-unit id="ca126408cfc67455e487ee1930ca11c397f8f21f" translate="yes" xml:space="preserve">
          <source>IoSliceMut::split</source>
          <target state="translated">IoSliceMut::split</target>
        </trans-unit>
        <trans-unit id="9ce7dd2f993172516d076ad5208aaaaaed4be576" translate="yes" xml:space="preserve">
          <source>IoSliceMut::split_at</source>
          <target state="translated">IoSliceMut::split_at</target>
        </trans-unit>
        <trans-unit id="a9f4775f9c968b1b54abb603239e2832c3960bcd" translate="yes" xml:space="preserve">
          <source>IoSliceMut::split_at_mut</source>
          <target state="translated">IoSliceMut::split_at_mut</target>
        </trans-unit>
        <trans-unit id="04f41bcdd653cbc93653f91796e5a60801b9293d" translate="yes" xml:space="preserve">
          <source>IoSliceMut::split_first</source>
          <target state="translated">IoSliceMut::split_first</target>
        </trans-unit>
        <trans-unit id="d88487ea6f16bda2b38a613374cc839f837e50ee" translate="yes" xml:space="preserve">
          <source>IoSliceMut::split_first_mut</source>
          <target state="translated">IoSliceMut::split_first_mut</target>
        </trans-unit>
        <trans-unit id="e077fdea55bf605bea57cd6afeaf715ca83c0ad3" translate="yes" xml:space="preserve">
          <source>IoSliceMut::split_last</source>
          <target state="translated">IoSliceMut::split_last</target>
        </trans-unit>
        <trans-unit id="c8e20234f7bea859d7664b1b7bb3eed2bc4a51d5" translate="yes" xml:space="preserve">
          <source>IoSliceMut::split_last_mut</source>
          <target state="translated">IoSliceMut::split_last_mut</target>
        </trans-unit>
        <trans-unit id="f6235363d8f27f1e8c28bf4df2329fcbc4ace1a1" translate="yes" xml:space="preserve">
          <source>IoSliceMut::split_mut</source>
          <target state="translated">IoSliceMut::split_mut</target>
        </trans-unit>
        <trans-unit id="9dbada99c8a947eba3daeff4a3521f91bb81bd90" translate="yes" xml:space="preserve">
          <source>IoSliceMut::splitn</source>
          <target state="translated">IoSliceMut::splitn</target>
        </trans-unit>
        <trans-unit id="3cf2674726ff6b7045de0b3e635d0a1f7df50615" translate="yes" xml:space="preserve">
          <source>IoSliceMut::splitn_mut</source>
          <target state="translated">IoSliceMut::splitn_mut</target>
        </trans-unit>
        <trans-unit id="aa18548ad4490c3366a3bab22827f88c2eb93f27" translate="yes" xml:space="preserve">
          <source>IoSliceMut::starts_with</source>
          <target state="translated">IoSliceMut::starts_with</target>
        </trans-unit>
        <trans-unit id="53e5e19d65bb8030c09ed2572e8e551a619bb85a" translate="yes" xml:space="preserve">
          <source>IoSliceMut::swap</source>
          <target state="translated">IoSliceMut::swap</target>
        </trans-unit>
        <trans-unit id="a645fa50fbb5c37388df17709c852c50b89ea8d6" translate="yes" xml:space="preserve">
          <source>IoSliceMut::swap_with_slice</source>
          <target state="translated">IoSliceMut::swap_with_slice</target>
        </trans-unit>
        <trans-unit id="ae3bf6a739be497a693a36ed80d558bbb3918541" translate="yes" xml:space="preserve">
          <source>IoSliceMut::to_ascii_lowercase</source>
          <target state="translated">IoSliceMut::to_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="e376283217440eef63b94cd987da83cb40aede71" translate="yes" xml:space="preserve">
          <source>IoSliceMut::to_ascii_uppercase</source>
          <target state="translated">IoSliceMut::to_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="391fa7871165db3ac0f05870f2a5050056f7916a" translate="yes" xml:space="preserve">
          <source>IoSliceMut::to_vec</source>
          <target state="translated">IoSliceMut::to_vec</target>
        </trans-unit>
        <trans-unit id="8376010efc59358ba141cb428936bf23451c7d6e" translate="yes" xml:space="preserve">
          <source>IoSliceMut::try_from</source>
          <target state="translated">IoSliceMut::try_from</target>
        </trans-unit>
        <trans-unit id="ce50ba5cdfbc273da4c72a3e73ca855ed6cf6df0" translate="yes" xml:space="preserve">
          <source>IoSliceMut::try_into</source>
          <target state="translated">IoSliceMut::try_into</target>
        </trans-unit>
        <trans-unit id="b83dd87d2ec2e898db655ae58a7cd873ea0d8d2e" translate="yes" xml:space="preserve">
          <source>IoSliceMut::type_id</source>
          <target state="translated">IoSliceMut::type_id</target>
        </trans-unit>
        <trans-unit id="0677fc2bcad3ffd6e1f3e2e468b03f8e0639f7c7" translate="yes" xml:space="preserve">
          <source>IoSliceMut::windows</source>
          <target state="translated">IoSliceMut::windows</target>
        </trans-unit>
        <trans-unit id="80c7dd22517caabb4b80ff90fceda4a6879202d3" translate="yes" xml:space="preserve">
          <source>IpAddr</source>
          <target state="translated">IpAddr</target>
        </trans-unit>
        <trans-unit id="18dcf7a25bc74232fd1ef06e66f66a9b58a15594" translate="yes" xml:space="preserve">
          <source>IpAddr::borrow</source>
          <target state="translated">IpAddr::borrow</target>
        </trans-unit>
        <trans-unit id="8ccc863c2cc929b895a9a7a5f36b4ffd6dacfefb" translate="yes" xml:space="preserve">
          <source>IpAddr::borrow_mut</source>
          <target state="translated">IpAddr::borrow_mut</target>
        </trans-unit>
        <trans-unit id="1d22b0fa46381b2fee190440340df7db25bbaab4" translate="yes" xml:space="preserve">
          <source>IpAddr::clamp</source>
          <target state="translated">IpAddr::clamp</target>
        </trans-unit>
        <trans-unit id="c5b49df3db406820aae7446426b53c486eb09ed2" translate="yes" xml:space="preserve">
          <source>IpAddr::clone</source>
          <target state="translated">IpAddr::clone</target>
        </trans-unit>
        <trans-unit id="df8040dfc89ba7aed1f5bb9fb38c981ae8013245" translate="yes" xml:space="preserve">
          <source>IpAddr::clone_from</source>
          <target state="translated">IpAddr::clone_from</target>
        </trans-unit>
        <trans-unit id="2e231a5b1670e66fd9b295e66c9b487760ec0cd5" translate="yes" xml:space="preserve">
          <source>IpAddr::clone_into</source>
          <target state="translated">IpAddr::clone_into</target>
        </trans-unit>
        <trans-unit id="ccf0a20beed4bfb31ab7de41f2fe72887b3afef1" translate="yes" xml:space="preserve">
          <source>IpAddr::cmp</source>
          <target state="translated">IpAddr::cmp</target>
        </trans-unit>
        <trans-unit id="1e451c2048ce103ce5a1fdc80f143226ee3ac738" translate="yes" xml:space="preserve">
          <source>IpAddr::eq</source>
          <target state="translated">IpAddr::eq</target>
        </trans-unit>
        <trans-unit id="de15dc7014bcddec35489eab12ccb7de4e61f814" translate="yes" xml:space="preserve">
          <source>IpAddr::fmt</source>
          <target state="translated">IpAddr::fmt</target>
        </trans-unit>
        <trans-unit id="cd82d20eb5adef0621b03b67c04075c8e8d22c13" translate="yes" xml:space="preserve">
          <source>IpAddr::from</source>
          <target state="translated">IpAddr::from</target>
        </trans-unit>
        <trans-unit id="1b18f811dcd6bd2be2da6af78c6da2512cea431f" translate="yes" xml:space="preserve">
          <source>IpAddr::from_str</source>
          <target state="translated">IpAddr::from_str</target>
        </trans-unit>
        <trans-unit id="fe7270d2fc646cf2e120c74e60b44f6fe3226fb1" translate="yes" xml:space="preserve">
          <source>IpAddr::ge</source>
          <target state="translated">IpAddr::ge</target>
        </trans-unit>
        <trans-unit id="596bc315329df27bdada6bfc4c172ea14c6cc583" translate="yes" xml:space="preserve">
          <source>IpAddr::gt</source>
          <target state="translated">IpAddr::gt</target>
        </trans-unit>
        <trans-unit id="7b43ebda452f32a749f28cf341479b33fad4fd8f" translate="yes" xml:space="preserve">
          <source>IpAddr::hash</source>
          <target state="translated">IpAddr::hash</target>
        </trans-unit>
        <trans-unit id="a6c626e9d203c303fe8bdf8bd02befa7941a60f6" translate="yes" xml:space="preserve">
          <source>IpAddr::hash_slice</source>
          <target state="translated">IpAddr::hash_slice</target>
        </trans-unit>
        <trans-unit id="bc0a2a089760008263e0c7d196dcda76407f2e2f" translate="yes" xml:space="preserve">
          <source>IpAddr::into</source>
          <target state="translated">IpAddr::into</target>
        </trans-unit>
        <trans-unit id="6aea05c2bb7a6ec19799f8ccd09371123895bffd" translate="yes" xml:space="preserve">
          <source>IpAddr::is_documentation</source>
          <target state="translated">IpAddr::is_documentation</target>
        </trans-unit>
        <trans-unit id="35e750aa8facebec148e21174f1b11f8f102ac1e" translate="yes" xml:space="preserve">
          <source>IpAddr::is_global</source>
          <target state="translated">IpAddr::is_global</target>
        </trans-unit>
        <trans-unit id="6d3064eb468b3aa541c1ebcbb93937383d1b5ce2" translate="yes" xml:space="preserve">
          <source>IpAddr::is_ipv4</source>
          <target state="translated">IpAddr::is_ipv4</target>
        </trans-unit>
        <trans-unit id="7cdffbf0a370fd55a0c2a72fa5c73de1a7e9c8ae" translate="yes" xml:space="preserve">
          <source>IpAddr::is_ipv6</source>
          <target state="translated">IpAddr::is_ipv6</target>
        </trans-unit>
        <trans-unit id="f1b5ba9a40c1d77558e70ec390b97ec0113d8759" translate="yes" xml:space="preserve">
          <source>IpAddr::is_loopback</source>
          <target state="translated">IpAddr::is_loopback</target>
        </trans-unit>
        <trans-unit id="e91ac24fb68aad99d2dea251365431ba20a3867b" translate="yes" xml:space="preserve">
          <source>IpAddr::is_multicast</source>
          <target state="translated">IpAddr::is_multicast</target>
        </trans-unit>
        <trans-unit id="a457140fd4bc4739b6888b5fa4fd5a528a1e87d7" translate="yes" xml:space="preserve">
          <source>IpAddr::is_unspecified</source>
          <target state="translated">IpAddr::is_unspecified</target>
        </trans-unit>
        <trans-unit id="075a86319470dde568dd6a068923e786ff41b626" translate="yes" xml:space="preserve">
          <source>IpAddr::le</source>
          <target state="translated">IpAddr::le</target>
        </trans-unit>
        <trans-unit id="2ee565a162a01a379da7271dca98ac34c1b3d062" translate="yes" xml:space="preserve">
          <source>IpAddr::lt</source>
          <target state="translated">IpAddr::lt</target>
        </trans-unit>
        <trans-unit id="21475b86807c525401acbad46b0d285b86f77c6c" translate="yes" xml:space="preserve">
          <source>IpAddr::max</source>
          <target state="translated">IpAddr::max</target>
        </trans-unit>
        <trans-unit id="6c19c9fa1118c738451a2a0ccab1e063e8453279" translate="yes" xml:space="preserve">
          <source>IpAddr::min</source>
          <target state="translated">IpAddr::min</target>
        </trans-unit>
        <trans-unit id="80516dd8787ef4ff1f53fd45e6539ecc0557944c" translate="yes" xml:space="preserve">
          <source>IpAddr::ne</source>
          <target state="translated">IpAddr::ne</target>
        </trans-unit>
        <trans-unit id="5ac433ae6b88b3faf0bab89b49547e507f3c5dbe" translate="yes" xml:space="preserve">
          <source>IpAddr::partial_cmp</source>
          <target state="translated">IpAddr::partial_cmp</target>
        </trans-unit>
        <trans-unit id="a66331ad09004ffc11c6bc336cec3dd2c1058851" translate="yes" xml:space="preserve">
          <source>IpAddr::to_owned</source>
          <target state="translated">IpAddr::to_owned</target>
        </trans-unit>
        <trans-unit id="c266c72106f541c9d079787ece667b3b71aa633c" translate="yes" xml:space="preserve">
          <source>IpAddr::to_string</source>
          <target state="translated">IpAddr::to_string</target>
        </trans-unit>
        <trans-unit id="310b4b19006f132dcc381f1e6408fe062644a5dc" translate="yes" xml:space="preserve">
          <source>IpAddr::try_from</source>
          <target state="translated">IpAddr::try_from</target>
        </trans-unit>
        <trans-unit id="6de54fb276669395f791daae14b60bdb8bb9ecab" translate="yes" xml:space="preserve">
          <source>IpAddr::try_into</source>
          <target state="translated">IpAddr::try_into</target>
        </trans-unit>
        <trans-unit id="76655a5dcdc7c4b7a1f489495625902f75957be4" translate="yes" xml:space="preserve">
          <source>IpAddr::type_id</source>
          <target state="translated">IpAddr::type_id</target>
        </trans-unit>
        <trans-unit id="9576adee9505e0e642c8cf6d8f843a2b00527190" translate="yes" xml:space="preserve">
          <source>Ipv4Addr</source>
          <target state="translated">Ipv4Addr</target>
        </trans-unit>
        <trans-unit id="c0670c429f8a4f4f07ef0b7f2b4e03d5be7cdc5b" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::borrow</source>
          <target state="translated">Ipv4Addr::borrow</target>
        </trans-unit>
        <trans-unit id="66fc34d63836dd285320b9e7805a0993e253d053" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::borrow_mut</source>
          <target state="translated">Ipv4Addr::borrow_mut</target>
        </trans-unit>
        <trans-unit id="87a2ad02487f9ecff09754664875f3fbf92e1aab" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::clamp</source>
          <target state="translated">Ipv4Addr::clamp</target>
        </trans-unit>
        <trans-unit id="86447e7e8694086d5dc29cbcf6bbc43172b77513" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::clone</source>
          <target state="translated">Ipv4Addr::clone</target>
        </trans-unit>
        <trans-unit id="f49b0fda7799a12b9106e653f8817c29e74a2242" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::clone_from</source>
          <target state="translated">Ipv4Addr::clone_from</target>
        </trans-unit>
        <trans-unit id="70d0f414add20ac85a1ac45856f7ef5006e570d8" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::clone_into</source>
          <target state="translated">Ipv4Addr::clone_into</target>
        </trans-unit>
        <trans-unit id="dc9773a4bf1673daf97b49a6b852c1d09da0533a" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::cmp</source>
          <target state="translated">Ipv4Addr::cmp</target>
        </trans-unit>
        <trans-unit id="9e8900c91f9869e1bd25bdeb1f480c627ddad7c1" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::eq</source>
          <target state="translated">Ipv4Addr::eq</target>
        </trans-unit>
        <trans-unit id="4cd7a35503bdc79c8a6d2eb2e96d19bb1d13b386" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::fmt</source>
          <target state="translated">Ipv4Addr::fmt</target>
        </trans-unit>
        <trans-unit id="96f1af7ae9368105392d9cc46e3fcdf5512b5c86" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::from</source>
          <target state="translated">Ipv4Addr::from</target>
        </trans-unit>
        <trans-unit id="c9814a89a183d677ccaba791ca610f1dbd9966e0" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::from_str</source>
          <target state="translated">Ipv4Addr::from_str</target>
        </trans-unit>
        <trans-unit id="a99258bd17a7b9473a9733d0d8cefdf5f6718002" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::ge</source>
          <target state="translated">Ipv4Addr::ge</target>
        </trans-unit>
        <trans-unit id="17edfcb10f49b77c9d0c9872e17c35b5128a4660" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::gt</source>
          <target state="translated">Ipv4Addr::gt</target>
        </trans-unit>
        <trans-unit id="8d9673e9e9140d616d250a1c2fd05b32e727f0bd" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::hash</source>
          <target state="translated">Ipv4Addr::hash</target>
        </trans-unit>
        <trans-unit id="33d72bb730a0f4415706682897a4dbeca937097e" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::hash_slice</source>
          <target state="translated">Ipv4Addr::hash_slice</target>
        </trans-unit>
        <trans-unit id="a0a5624897c7561cf8904fb1069326cac7d4849a" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::into</source>
          <target state="translated">Ipv4Addr::into</target>
        </trans-unit>
        <trans-unit id="a28162edd246e58c591efd6d2f7e0f95677a17b4" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::is_benchmarking</source>
          <target state="translated">Ipv4Addr::is_benchmarking</target>
        </trans-unit>
        <trans-unit id="e6c68f36a0501dd1c101e1de3fe289267ab116d7" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::is_broadcast</source>
          <target state="translated">Ipv4Addr::is_broadcast</target>
        </trans-unit>
        <trans-unit id="d1c44235068a67cbe1de6fa7f1ecd5c62159b7eb" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::is_documentation</source>
          <target state="translated">Ipv4Addr::is_documentation</target>
        </trans-unit>
        <trans-unit id="490980e7baecbdb16df4c536ff701a4b9c6f3a87" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::is_global</source>
          <target state="translated">Ipv4Addr::is_global</target>
        </trans-unit>
        <trans-unit id="7dc9db6b00fed2f3a364f1abbeb6b19c6a865b8c" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::is_ietf_protocol_assignment</source>
          <target state="translated">Ipv4Addr::is_ietf_protocol_assignment</target>
        </trans-unit>
        <trans-unit id="bcc94df664112964d43eabb2d514303df1ec2159" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::is_link_local</source>
          <target state="translated">Ipv4Addr::is_link_local</target>
        </trans-unit>
        <trans-unit id="cfe2080acebd57083f5209b2051ccd19002609f2" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::is_loopback</source>
          <target state="translated">Ipv4Addr::is_loopback</target>
        </trans-unit>
        <trans-unit id="28b9c1629dd15420ecafb39f3dfbae73a4ea518c" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::is_multicast</source>
          <target state="translated">Ipv4Addr::is_multicast</target>
        </trans-unit>
        <trans-unit id="3763f7c2e4d81cf18a61fa9d1039122b09d3f6af" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::is_private</source>
          <target state="translated">Ipv4Addr::is_private</target>
        </trans-unit>
        <trans-unit id="ded22ef0151f56687869efa355fc02ddba31b8da" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::is_reserved</source>
          <target state="translated">Ipv4Addr::is_reserved</target>
        </trans-unit>
        <trans-unit id="af8e482daade31f5216d01b0acb05b1f1a06363a" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::is_shared</source>
          <target state="translated">Ipv4Addr::is_shared</target>
        </trans-unit>
        <trans-unit id="94fd19fb5c77bb66f1dd4e3ea2bd66c0cd328221" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::is_unspecified</source>
          <target state="translated">Ipv4Addr::is_unspecified</target>
        </trans-unit>
        <trans-unit id="6f06522a0d23f3ce3fb7a7bbcf5b64422c03cab1" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::le</source>
          <target state="translated">Ipv4Addr::le</target>
        </trans-unit>
        <trans-unit id="7ddb9be2edc96e85ada95865505918fe2c31c08c" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::lt</source>
          <target state="translated">Ipv4Addr::lt</target>
        </trans-unit>
        <trans-unit id="588e3a62e403b2acaff68c35f34372111ff7475b" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::max</source>
          <target state="translated">Ipv4Addr::max</target>
        </trans-unit>
        <trans-unit id="f0f6703268f715e35b633ffa8e701e62eda903f0" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::min</source>
          <target state="translated">Ipv4Addr::min</target>
        </trans-unit>
        <trans-unit id="8752da42e18e3890559177c1610168a779a113cf" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::ne</source>
          <target state="translated">Ipv4Addr::ne</target>
        </trans-unit>
        <trans-unit id="dda7ca845b881cbb8bdf3787be6ee9ac1fc45b41" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::new</source>
          <target state="translated">Ipv4Addr::new</target>
        </trans-unit>
        <trans-unit id="507f23cd2f1d898fa8d18a4f56faa306c969539d" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::octets</source>
          <target state="translated">Ipv4Addr::octets</target>
        </trans-unit>
        <trans-unit id="ae2ee18a4ab1872b9c91e8a1e83866fd664e6feb" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::partial_cmp</source>
          <target state="translated">Ipv4Addr::partial_cmp</target>
        </trans-unit>
        <trans-unit id="05bbaef82cf48bd89cdb234db3e68e898269d87a" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::to_ipv6_compatible</source>
          <target state="translated">Ipv4Addr::to_ipv6_compatible</target>
        </trans-unit>
        <trans-unit id="2136b09c14369a3b7d334fb003b5f0a2b70ab6f8" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::to_ipv6_mapped</source>
          <target state="translated">Ipv4Addr::to_ipv6_mapped</target>
        </trans-unit>
        <trans-unit id="fdcf5dff54d1f120adbacb5e658048c222d56c54" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::to_owned</source>
          <target state="translated">Ipv4Addr::to_owned</target>
        </trans-unit>
        <trans-unit id="269c08b4181e19fd8b66cea4812bd4bd7ea2af16" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::to_string</source>
          <target state="translated">Ipv4Addr::to_string</target>
        </trans-unit>
        <trans-unit id="412e053ce749bb8025b592e2499a7d73749e6fbe" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::try_from</source>
          <target state="translated">Ipv4Addr::try_from</target>
        </trans-unit>
        <trans-unit id="3e4b53822154707283b1d82871537a4148878b64" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::try_into</source>
          <target state="translated">Ipv4Addr::try_into</target>
        </trans-unit>
        <trans-unit id="29c219582f8e2fb59bc91723bc9968e9e558d78a" translate="yes" xml:space="preserve">
          <source>Ipv4Addr::type_id</source>
          <target state="translated">Ipv4Addr::type_id</target>
        </trans-unit>
        <trans-unit id="0d8606594389e9bf1434e5e041fc45b49d2d89fb" translate="yes" xml:space="preserve">
          <source>Ipv6Addr</source>
          <target state="translated">Ipv6Addr</target>
        </trans-unit>
        <trans-unit id="d70b655b95a966bf32c7e29d4eb302d94d537409" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::borrow</source>
          <target state="translated">Ipv6Addr::borrow</target>
        </trans-unit>
        <trans-unit id="5bcfe843497d7c0d0e1435cd2a4e6d7c081bbbc0" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::borrow_mut</source>
          <target state="translated">Ipv6Addr::borrow_mut</target>
        </trans-unit>
        <trans-unit id="f7dd13e8c27649fb7974784c22309d13f14d3cb8" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::clamp</source>
          <target state="translated">Ipv6Addr::clamp</target>
        </trans-unit>
        <trans-unit id="75d479dee6aa25b111b95de4fe2ff9431fd40236" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::clone</source>
          <target state="translated">Ipv6Addr::clone</target>
        </trans-unit>
        <trans-unit id="23bca06a900c89dfaa4d74bf597a4b4d7db14dd8" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::clone_from</source>
          <target state="translated">Ipv6Addr::clone_from</target>
        </trans-unit>
        <trans-unit id="a1b88b248e8ee4b5b484c234c2ecfbe7dbfdd996" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::clone_into</source>
          <target state="translated">Ipv6Addr::clone_into</target>
        </trans-unit>
        <trans-unit id="dc97ee1fb759cbf2f49863623e2495bd92e0cc2d" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::cmp</source>
          <target state="translated">Ipv6Addr::cmp</target>
        </trans-unit>
        <trans-unit id="92b52ce5c0ec7c8283a07b53ad7860ec0014b4c9" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::eq</source>
          <target state="translated">Ipv6Addr::eq</target>
        </trans-unit>
        <trans-unit id="3b311d466c72a6b513175602e48a797929f3d67d" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::fmt</source>
          <target state="translated">Ipv6Addr::fmt</target>
        </trans-unit>
        <trans-unit id="8026446e621a4f6612c20cfc5e55af6998493a0a" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::from</source>
          <target state="translated">Ipv6Addr::from</target>
        </trans-unit>
        <trans-unit id="3b0a22d0bf352f30e40cf12cf400d0bcc3d4fbeb" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::from_str</source>
          <target state="translated">Ipv6Addr::from_str</target>
        </trans-unit>
        <trans-unit id="1b12986f3c342df0da012478446d35bc1e25adff" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::ge</source>
          <target state="translated">Ipv6Addr::ge</target>
        </trans-unit>
        <trans-unit id="cfefe2f3000d50064ee292bedfc9212d2af9fa6d" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::gt</source>
          <target state="translated">Ipv6Addr::gt</target>
        </trans-unit>
        <trans-unit id="76f36f887e858b436e8356c4db0f8649f4a0fa39" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::hash</source>
          <target state="translated">Ipv6Addr::hash</target>
        </trans-unit>
        <trans-unit id="2266f98ea937ce9e92f9c74b16810ce281c5f688" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::hash_slice</source>
          <target state="translated">Ipv6Addr::hash_slice</target>
        </trans-unit>
        <trans-unit id="45ed8315dcbcb3116b3eb8b57c7b03b534df4ade" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::into</source>
          <target state="translated">Ipv6Addr::into</target>
        </trans-unit>
        <trans-unit id="100022f73659e9325e7ac2e452d9737325bc6205" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::is_documentation</source>
          <target state="translated">Ipv6Addr::is_documentation</target>
        </trans-unit>
        <trans-unit id="779fa2a92533a376818cec5898176281cf38b662" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::is_global</source>
          <target state="translated">Ipv6Addr::is_global</target>
        </trans-unit>
        <trans-unit id="9ea19eb6e650cc597cabc4d80c14f0f132c8c23d" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::is_loopback</source>
          <target state="translated">Ipv6Addr::is_loopback</target>
        </trans-unit>
        <trans-unit id="674f4cff3c09e352444adb1edda7bff67e73c3d6" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::is_multicast</source>
          <target state="translated">Ipv6Addr::is_multicast</target>
        </trans-unit>
        <trans-unit id="53343e7e3d105f1a44ebe32d0eefc791089badc8" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::is_unicast_global</source>
          <target state="translated">Ipv6Addr::is_unicast_global</target>
        </trans-unit>
        <trans-unit id="ef3d5cf9b22cff3832f46ef32799dfbc2d0e5d23" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::is_unicast_link_local</source>
          <target state="translated">Ipv6Addr::is_unicast_link_local</target>
        </trans-unit>
        <trans-unit id="a210d1d3c529f4648ccb8a6d5d259a6a6d471504" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::is_unicast_link_local_strict</source>
          <target state="translated">Ipv6Addr::is_unicast_link_local_strict</target>
        </trans-unit>
        <trans-unit id="fa85561c123be7bf6016020f1992fd1b205fb3ab" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::is_unicast_site_local</source>
          <target state="translated">Ipv6Addr::is_unicast_site_local</target>
        </trans-unit>
        <trans-unit id="f214d60d9ab8bf7117df211486c37f22952d790b" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::is_unique_local</source>
          <target state="translated">Ipv6Addr::is_unique_local</target>
        </trans-unit>
        <trans-unit id="a8d6c989ec571a72320733615b69d2c07fcb0ba9" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::is_unspecified</source>
          <target state="translated">Ipv6Addr::is_unspecified</target>
        </trans-unit>
        <trans-unit id="02c8fce30d5a32465175cbe3879c69259c312ded" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::le</source>
          <target state="translated">Ipv6Addr::le</target>
        </trans-unit>
        <trans-unit id="297e749932b92e4808241fddcb9b960c1bbefb12" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::lt</source>
          <target state="translated">Ipv6Addr::lt</target>
        </trans-unit>
        <trans-unit id="1f93180931140e8587a275013dfcfce7f8b6490e" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::max</source>
          <target state="translated">Ipv6Addr::max</target>
        </trans-unit>
        <trans-unit id="50eb114b333cecae538ca6ad284c88fab52f336e" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::min</source>
          <target state="translated">Ipv6Addr::min</target>
        </trans-unit>
        <trans-unit id="183f35750e05512d0c059a06dbccd93abd3349c7" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::multicast_scope</source>
          <target state="translated">Ipv6Addr::multicast_scope</target>
        </trans-unit>
        <trans-unit id="e51b9303d310ea2cd79b483b6689ac80fe75fbd6" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::ne</source>
          <target state="translated">Ipv6Addr::ne</target>
        </trans-unit>
        <trans-unit id="f1d4f467002e9522e65e198bfa78a0a6829f670e" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::new</source>
          <target state="translated">Ipv6Addr::new</target>
        </trans-unit>
        <trans-unit id="d61c56e79ee209a5c274b6372f7bfb67e409ab7e" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::octets</source>
          <target state="translated">Ipv6Addr::octets</target>
        </trans-unit>
        <trans-unit id="17e1469eab47bf29477cd18cccbbb0cde2f23783" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::partial_cmp</source>
          <target state="translated">Ipv6Addr::partial_cmp</target>
        </trans-unit>
        <trans-unit id="b7b98dc05081d889b0f5f7de6c80a3ae378cf699" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::segments</source>
          <target state="translated">Ipv6Addr::segments</target>
        </trans-unit>
        <trans-unit id="c35cdbb386870b8f97c03a67a421ae849b3268f9" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::to_ipv4</source>
          <target state="translated">Ipv6Addr::to_ipv4</target>
        </trans-unit>
        <trans-unit id="33aea393ab3dab6c3a68e6f00c689810fe9bd799" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::to_owned</source>
          <target state="translated">Ipv6Addr::to_owned</target>
        </trans-unit>
        <trans-unit id="744da9f6f868ba8486c07d001e1497f4af409a6c" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::to_string</source>
          <target state="translated">Ipv6Addr::to_string</target>
        </trans-unit>
        <trans-unit id="e7906ea8de471e39df4e64193a59ad6753c407ea" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::try_from</source>
          <target state="translated">Ipv6Addr::try_from</target>
        </trans-unit>
        <trans-unit id="57e4d786e8cd27bd0e1a73e9af4d39fca767500d" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::try_into</source>
          <target state="translated">Ipv6Addr::try_into</target>
        </trans-unit>
        <trans-unit id="fb2fe802e9fb2190aa9429082c672e39e9fa6875" translate="yes" xml:space="preserve">
          <source>Ipv6Addr::type_id</source>
          <target state="translated">Ipv6Addr::type_id</target>
        </trans-unit>
        <trans-unit id="88a82ca1333481fb3a1f5fa852a0e945500824b1" translate="yes" xml:space="preserve">
          <source>Ipv6MulticastScope</source>
          <target state="translated">Ipv6MulticastScope</target>
        </trans-unit>
        <trans-unit id="e84c27e16f953494b556166d8f312c91254c12d0" translate="yes" xml:space="preserve">
          <source>Ipv6MulticastScope::borrow</source>
          <target state="translated">Ipv6MulticastScope::borrow</target>
        </trans-unit>
        <trans-unit id="677ee6c513806ce0784ec7fe2a00a0d6bca85485" translate="yes" xml:space="preserve">
          <source>Ipv6MulticastScope::borrow_mut</source>
          <target state="translated">Ipv6MulticastScope::borrow_mut</target>
        </trans-unit>
        <trans-unit id="dcf68f3ffbb91cc5040a7613640f04ad758b23a4" translate="yes" xml:space="preserve">
          <source>Ipv6MulticastScope::clone</source>
          <target state="translated">Ipv6MulticastScope::clone</target>
        </trans-unit>
        <trans-unit id="61fd8492371c7f4b111966fae5d5fe08c4b97229" translate="yes" xml:space="preserve">
          <source>Ipv6MulticastScope::clone_from</source>
          <target state="translated">Ipv6MulticastScope::clone_from</target>
        </trans-unit>
        <trans-unit id="134ebe2c42587c3ca82d7925389e251db2163a7b" translate="yes" xml:space="preserve">
          <source>Ipv6MulticastScope::clone_into</source>
          <target state="translated">Ipv6MulticastScope::clone_into</target>
        </trans-unit>
        <trans-unit id="390d22aa747105ced3c5976e7e0b509871c131ca" translate="yes" xml:space="preserve">
          <source>Ipv6MulticastScope::eq</source>
          <target state="translated">Ipv6MulticastScope::eq</target>
        </trans-unit>
        <trans-unit id="608099f9c2565ad9310942c2ab375a0a27d03555" translate="yes" xml:space="preserve">
          <source>Ipv6MulticastScope::fmt</source>
          <target state="translated">Ipv6MulticastScope::fmt</target>
        </trans-unit>
        <trans-unit id="3ba69289a058c4abe74375992c848e97e5c3e1f0" translate="yes" xml:space="preserve">
          <source>Ipv6MulticastScope::from</source>
          <target state="translated">Ipv6MulticastScope::from</target>
        </trans-unit>
        <trans-unit id="50dbeef4e426d6a1662be73f3b710581f45f5726" translate="yes" xml:space="preserve">
          <source>Ipv6MulticastScope::hash</source>
          <target state="translated">Ipv6MulticastScope::hash</target>
        </trans-unit>
        <trans-unit id="d937291039e717d6b72ac61199880b756bb71cc6" translate="yes" xml:space="preserve">
          <source>Ipv6MulticastScope::hash_slice</source>
          <target state="translated">Ipv6MulticastScope::hash_slice</target>
        </trans-unit>
        <trans-unit id="72c69d6697741a6839af11bc528c0219d8f51a86" translate="yes" xml:space="preserve">
          <source>Ipv6MulticastScope::into</source>
          <target state="translated">Ipv6MulticastScope::into</target>
        </trans-unit>
        <trans-unit id="f19d929ae7f3905c1d7f61ba332bba83b3ee1713" translate="yes" xml:space="preserve">
          <source>Ipv6MulticastScope::ne</source>
          <target state="translated">Ipv6MulticastScope::ne</target>
        </trans-unit>
        <trans-unit id="1ae2897866e78e1fede7326722ae13d5ef68df29" translate="yes" xml:space="preserve">
          <source>Ipv6MulticastScope::to_owned</source>
          <target state="translated">Ipv6MulticastScope::to_owned</target>
        </trans-unit>
        <trans-unit id="0446e23a43371fe0f94b03f56d1bb98116018284" translate="yes" xml:space="preserve">
          <source>Ipv6MulticastScope::try_from</source>
          <target state="translated">Ipv6MulticastScope::try_from</target>
        </trans-unit>
        <trans-unit id="f9b3de0a7b333e261fdc7c4ad1a32806dd360521" translate="yes" xml:space="preserve">
          <source>Ipv6MulticastScope::try_into</source>
          <target state="translated">Ipv6MulticastScope::try_into</target>
        </trans-unit>
        <trans-unit id="54bb08375bed2835d5a0ef191ec626eeb541ad77" translate="yes" xml:space="preserve">
          <source>Ipv6MulticastScope::type_id</source>
          <target state="translated">Ipv6MulticastScope::type_id</target>
        </trans-unit>
        <trans-unit id="1ded365c250b74bea186557cb8382c1ec7f7a2ef" translate="yes" xml:space="preserve">
          <source>Is called to get the representation of the value as status code. This status code is returned to the operating system.</source>
          <target state="translated">상태 코드로 값의 표현을 얻기 위해 호출됩니다. 이 상태 코드는 운영 체제로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="59458c2be32dcdeda9fe0621a635d170f4b150d0" translate="yes" xml:space="preserve">
          <source>Is called to get the representation of the value as status code. This status code is returned to the operating system. &lt;a href=&quot;../process/trait.termination#tymethod.report&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">상태 코드로 값의 표현을 얻기 위해 호출됩니다. 이 상태 코드는 운영 체제로 반환됩니다. &lt;a href=&quot;../process/trait.termination#tymethod.report&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5992205e7f17c7190fe09ef40bc9950c869d373e" translate="yes" xml:space="preserve">
          <source>Is called to get the representation of the value as status code. This status code is returned to the operating system. &lt;a href=&quot;process/trait.termination#tymethod.report&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">상태 코드로 값의 표현을 얻기 위해 호출됩니다. 이 상태 코드는 운영 체제로 반환됩니다. &lt;a href=&quot;process/trait.termination#tymethod.report&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="680b4746f2d256076239ed1e9dc02c5c4926c34a" translate="yes" xml:space="preserve">
          <source>Is called to get the representation of the value as status code. This status code is returned to the operating system. &lt;a href=&quot;trait.termination#tymethod.report&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">상태 코드로 값의 표현을 얻기 위해 호출됩니다. 이 상태 코드는 운영 체제로 반환됩니다. &lt;a href=&quot;trait.termination#tymethod.report&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="51ca310768b85e8610e7fa8789046380b05cedd2" translate="yes" xml:space="preserve">
          <source>Isolated CRs (&lt;code&gt;\r&lt;/code&gt;), i.e. not followed by LF (&lt;code&gt;\n&lt;/code&gt;), are not allowed in doc comments.</source>
          <target state="translated">문서 주석에는 분리 된 CR ( &lt;code&gt;\r&lt;/code&gt; ), 즉 LF ( &lt;code&gt;\n&lt;/code&gt; )가 뒤 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21d9ab30a1c1e374b953d4ada2aa7c7ea2c3447d" translate="yes" xml:space="preserve">
          <source>It appears as if some variables stored in memory are changed, an addition is performed, result is stored in &lt;code&gt;A&lt;/code&gt; and the variable &lt;code&gt;C&lt;/code&gt; is modified twice.</source>
          <target state="translated">메모리에 저장된 일부 변수가 변경되고 추가가 수행되고 결과가 &lt;code&gt;A&lt;/code&gt; 에 저장되고 변수 &lt;code&gt;C&lt;/code&gt; 가 두 번 수정 된 것처럼 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="bec31df4330e5539ca332e9180d08b7d0285868d" translate="yes" xml:space="preserve">
          <source>It avoids the need to allocate mutexes and condvars when building new synchronization primitives; the threads already provide basic blocking/signaling.</source>
          <target state="translated">새로운 동기화 프리미티브를 빌드 할 때 뮤텍스와 condvar를 할당 할 필요가 없습니다. 스레드는 이미 기본 차단 / 신호를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="03d3e7d539855e7b059008a40edfba81dc44ce33" translate="yes" xml:space="preserve">
          <source>It can also be fixed by using a type with interior mutability, such as &lt;code&gt;Cell&lt;/code&gt; or &lt;code&gt;RefCell&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Cell&lt;/code&gt; 또는 &lt;code&gt;RefCell&lt;/code&gt; 과 같이 내부 변경 가능성이있는 유형을 사용하여 수정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a8b452f4173e1504b134fc7f377b9484d0800b0" translate="yes" xml:space="preserve">
          <source>It can also be used directly to allocate memory independently of whatever global allocator has been selected for a Rust program. For example if a Rust program opts in to using jemalloc as the global allocator, &lt;code&gt;System&lt;/code&gt; will still allocate memory using &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;HeapAlloc&lt;/code&gt;.</source>
          <target state="translated">또한 Rust 프로그램에 대해 선택된 전역 할당 자에 관계없이 메모리를 직접 할당하는 데 사용할 수도 있습니다. 예를 들어 Rust 프로그램이 jemalloc을 전역 할당 자로 사용하도록 선택한 경우에도 &lt;code&gt;System&lt;/code&gt; 은 &lt;code&gt;malloc&lt;/code&gt; 및 &lt;code&gt;HeapAlloc&lt;/code&gt; 을 사용하여 메모리를 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="00660b666c533a7c559c2ecac031a0dd6fae7e81" translate="yes" xml:space="preserve">
          <source>It can also be useful to check if a pointer to an element refers to an element of this slice:</source>
          <target state="translated">요소에 대한 포인터가이 슬라이스의 요소를 참조하는지 확인하는 것도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="310caca6a04a9d8a72a66083548cffe2c3deb96f" translate="yes" xml:space="preserve">
          <source>It can also initialize each element of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; with a given value. This may be more efficient than performing allocation and initialization in separate steps, especially when initializing a vector of zeros:</source>
          <target state="translated">주어진 값 으로 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 의 각 요소를 초기화 할 수도 있습니다 . 이는 특히 0으로 구성된 벡터를 초기화 할 때 별도의 단계에서 할당 및 초기화를 수행하는 것보다 더 효율적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="190277fdc267c49497782df2cc44dfe65d610086" translate="yes" xml:space="preserve">
          <source>It can be confusing whether or not you should use a constant item or a static item. Constants should, in general, be preferred over statics unless one of the following are true:</source>
          <target state="translated">상수 항목을 사용해야하는지 정적 항목을 사용해야하는지 혼동 될 수 있습니다. 일반적으로 다음 중 하나에 해당하지 않는 한 상수가 정적보다 선호되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0bd32cfa263bd1bf213225174ecd4ec323617bbd" translate="yes" xml:space="preserve">
          <source>It can be excessively inefficient to work directly with a &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; instance. For example, every call to &lt;a href=&quot;../net/struct.tcpstream#method.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; on &lt;a href=&quot;../net/struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; results in a system call. A &lt;code&gt;BufReader&lt;/code&gt; performs large, infrequent reads on the underlying &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and maintains an in-memory buffer of the results.</source>
          <target state="translated">&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; 인스턴스로 직접 작업하는 것은 지나치게 비효율적 일 수 있습니다 . 예를 들어, 모든 호출하는 &lt;a href=&quot;../net/struct.tcpstream#method.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;../net/struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; 의&lt;/a&gt; 시스템 콜의 결과. &lt;code&gt;BufReader&lt;/code&gt; 는 자주는 하부에 판독 큰 수행 &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; 와 결과 메모리 버퍼를 유지한다.</target>
        </trans-unit>
        <trans-unit id="a53c30292449f5c65f658f1ab5f787257b2ab97a" translate="yes" xml:space="preserve">
          <source>It can be excessively inefficient to work directly with a &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; instance. For example, every call to &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; on &lt;a href=&quot;../net/struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; results in a system call. A &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; performs large, infrequent reads on the underlying &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and maintains an in-memory buffer of the results.</source>
          <target state="translated">&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; 인스턴스로 직접 작업하는 것은 지나치게 비효율적 일 수 있습니다 . 예를 들어, &lt;a href=&quot;../net/struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 를 호출 할 때마다 시스템 호출이 발생합니다. &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; 대형 행한다는 자주는 하부에 판독 &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; 와 결과 메모리 버퍼를 유지한다.</target>
        </trans-unit>
        <trans-unit id="c9b4e83780a18771dd321f0082a8c599b84b0325" translate="yes" xml:space="preserve">
          <source>It can be excessively inefficient to work directly with something that implements &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;. For example, every call to &lt;a href=&quot;../net/struct.tcpstream#method.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; on &lt;a href=&quot;../net/struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; results in a system call. A &lt;code&gt;BufWriter&lt;/code&gt; keeps an in-memory buffer of data and writes it to an underlying writer in large, infrequent batches.</source>
          <target state="translated">&lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; 구현하는 무언가로 직접 작업하는 것은 지나치게 비효율적 일 수 있습니다 . 예를 들어, 호출 할 때마다 &lt;a href=&quot;../net/struct.tcpstream#method.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;../net/struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; 는&lt;/a&gt; 시스템 호출을 초래한다. &lt;code&gt;BufWriter&lt;/code&gt; 는 데이터의 메모리 버퍼를 유지하며 큰 드문 배치에 기초 라이터에 쓴다.</target>
        </trans-unit>
        <trans-unit id="c37fef9993e5a7b5cdbbe83955b856b6da5daba4" translate="yes" xml:space="preserve">
          <source>It can be excessively inefficient to work directly with something that implements &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;. For example, every call to &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; on &lt;a href=&quot;../net/struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; results in a system call. A &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt; keeps an in-memory buffer of data and writes it to an underlying writer in large, infrequent batches.</source>
          <target state="translated">&lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; 를 구현하는 무언가로 직접 작업하는 것은 지나치게 비효율적 일 수 있습니다 . 예를 들어, 호출 할 때마다 &lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;../net/struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; 는&lt;/a&gt; 시스템 호출을 초래한다. &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt; 데이터의 메모리 버퍼를 유지하며 큰 드문 배치에 기초 라이터에 쓴다.</target>
        </trans-unit>
        <trans-unit id="9005a41b0a5154d7a83abaf469c6cbf2455196bc" translate="yes" xml:space="preserve">
          <source>It can be fixed by adjusting the trait bound like this:</source>
          <target state="translated">다음과 같이 특성 바인딩을 조정하여 수정할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
