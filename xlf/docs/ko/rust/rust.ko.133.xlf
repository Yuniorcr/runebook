<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="1eb81e5b136891ec83f03fa70901b0982c774c3e" translate="yes" xml:space="preserve">
          <source>The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../fs/struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. New errors may be encountered after an iterator is initially constructed.</source>
          <target state="translated">반복자는 &lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../fs/struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 의 인스턴스를 생성합니다 . 반복자가 처음 구성된 후 새로운 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fea22bab4e7d7d638613556e79b891a323ca2ee5" translate="yes" xml:space="preserve">
          <source>The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../fs/struct.direntry&quot;&gt;&lt;code&gt;fs::DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. New errors may be encountered after an iterator is initially constructed.</source>
          <target state="translated">반복자는 &lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../fs/struct.direntry&quot;&gt; &lt;code&gt;fs::DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 의 인스턴스를 생성합니다 . 반복기가 처음 생성 된 후 새로운 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54667f9a5f59c23223b23e9276c48f67c43aae4e" translate="yes" xml:space="preserve">
          <source>The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. New errors may be encountered after an iterator is initially constructed.</source>
          <target state="translated">반복자는 &lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 의 인스턴스를 생성합니다 . 반복자가 처음 구성된 후 새로운 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6720eac87f145ca4ebd08c14afcbc3e18eb5bc63" translate="yes" xml:space="preserve">
          <source>The iterator will yield the &lt;code&gt;Path&lt;/code&gt; that is returned if the &lt;a href=&quot;struct.path#method.parent&quot;&gt;&lt;code&gt;parent&lt;/code&gt;&lt;/a&gt; method is used zero or more times. That means, the iterator will yield &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self.parent().unwrap()&lt;/code&gt;, &lt;code&gt;&amp;amp;self.parent().unwrap().parent().unwrap()&lt;/code&gt; and so on. If the &lt;a href=&quot;struct.path#method.parent&quot;&gt;&lt;code&gt;parent&lt;/code&gt;&lt;/a&gt; method returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the iterator will do likewise. The iterator will always yield at least one value, namely &lt;code&gt;&amp;amp;self&lt;/code&gt;.</source>
          <target state="translated">반복자는 &lt;a href=&quot;struct.path#method.parent&quot;&gt; &lt;code&gt;parent&lt;/code&gt; &lt;/a&gt; 메소드가 0 회 이상 사용 되면 리턴 되는 &lt;code&gt;Path&lt;/code&gt; 를 생성합니다 . 즉, 반복자는 &lt;code&gt;&amp;amp;self&lt;/code&gt; , &lt;code&gt;&amp;amp;self.parent().unwrap()&lt;/code&gt; , &lt;code&gt;&amp;amp;self.parent().unwrap().parent().unwrap()&lt;/code&gt; 등을 생성합니다. 경우 &lt;a href=&quot;struct.path#method.parent&quot;&gt; &lt;code&gt;parent&lt;/code&gt; &lt;/a&gt; 방법은 반환 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , 반복자 마찬가지로 할 것입니다. 반복자는 항상 하나 이상의 값, 즉 &lt;code&gt;&amp;amp;self&lt;/code&gt; 산출 합니다.</target>
        </trans-unit>
        <trans-unit id="36ed296a3da7075e704c60a55541d4eefcc61a2e" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; 이면 반복자는 하나의 값을 생성 하고 , 그렇지 않으면 값을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="33a7221657feedb4eb9bdbc29b15b1cfdbff0941" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">결과가 &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; 인 경우 반복기는 하나의 값을 생성하고 , 그렇지 않으면 값을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="98fcd488b58bec9ba13c409525786e8e34d2f3d0" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">반복기는 결과가 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; 이면 하나의 값을 생성 하고 그렇지 않으면 아무 것도 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="908b09e4328c560c75c00a1be9bba8fa3c1792fa" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">결과가 &lt;a href=&quot;enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; 인 경우 반복기는 하나의 값을 생성하고 , 그렇지 않으면 값을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="8fd298b9ad5df85747acb6e44bba1366e3481860" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">결과가 &lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 인 경우 반복기는 하나의 값을 생성하고 , 그렇지 않으면 값을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="41c263ba9c3e1377bcbb306e69ddac6adfb8f150" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">반복기는 결과가 &lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; 이면 하나의 값을 생성 하고 그렇지 않으면 아무 것도 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b80110840b4186388c3ebdd6fff4960efb23a3ca" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="translated">반복자는 튜플을 생성합니다. 위치가 첫 번째이고 &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 가 두 번째입니다.</target>
        </trans-unit>
        <trans-unit id="6ec1542f766c1ecbdef3897acebe4cebd30ca6ee" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="translated">반복기는 튜플을 생성합니다. 위치는 첫 번째이고 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 는 두 번째입니다.</target>
        </trans-unit>
        <trans-unit id="787f68c0ad38019edb27d78451a4d5831f65e4ab" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="translated">반복자는 튜플을 생성합니다. 위치가 첫 번째이고 &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 가 두 번째입니다.</target>
        </trans-unit>
        <trans-unit id="10db2a64e13645a875ad4c150b72d85dec4465d0" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="translated">반복기는 튜플을 생성합니다. 위치는 첫 번째이고 &lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 는 두 번째입니다.</target>
        </trans-unit>
        <trans-unit id="6814fb791ef3836a2e395759e70c2ff3a369ee11" translate="yes" xml:space="preserve">
          <source>The job of &lt;code&gt;read_line&lt;/code&gt; is to take whatever the user types into standard input and place that into a string, so it takes that string as an argument. The string argument needs to be mutable so the method can change the string&amp;rsquo;s content by adding the user input.</source>
          <target state="translated">&lt;code&gt;read_line&lt;/code&gt; 의 작업은 사용자가 입력하는 모든 것을 표준 입력으로 가져 와서 문자열에 배치하는 것이므로 해당 문자열을 인수로 사용합니다. 문자열 인수는 변경 가능해야하므로 메소드는 사용자 입력을 추가하여 문자열의 컨텐츠를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41c36730094f242762fc2db352770667844d977d" translate="yes" xml:space="preserve">
          <source>The join handle will implicitly &lt;em&gt;detach&lt;/em&gt; the child thread upon being dropped. In this case, the child thread may outlive the parent (unless the parent thread is the main thread; the whole process is terminated when the main thread finishes). Additionally, the join handle provides a &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; method that can be used to join the child thread. If the child thread panics, &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; will return an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; containing the argument given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">조인 핸들은 삭제 될 때 암시 적 으로 자식 스레드를 &lt;em&gt;분리&lt;/em&gt; 합니다. 이 경우 자식 스레드는 부모보다 오래 지속될 수 있습니다 (부모 스레드가 주 스레드가 아닌 경우, 주 스레드가 완료되면 전체 프로세스가 종료 됨). 또한 조인 핸들은 자식 스레드를 조인하는 데 사용할 수 있는 &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; 메서드를 제공합니다 . 자식 스레드가 패닉하면 &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; 에&lt;/a&gt; 주어진 인수를 포함 하는 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 을 반환합니다 . .</target>
        </trans-unit>
        <trans-unit id="cc7b114b0c6414134b72184594654a5acaffb577" translate="yes" xml:space="preserve">
          <source>The join handle will implicitly &lt;em&gt;detach&lt;/em&gt; the child thread upon being dropped. In this case, the child thread may outlive the parent (unless the parent thread is the main thread; the whole process is terminated when the main thread finishes). Additionally, the join handle provides a &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; method that can be used to join the child thread. If the child thread panics, &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; will return an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; containing the argument given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결합 핸들은 떨어지면 자식 스레드를 내재적으로 &lt;em&gt;분리&lt;/em&gt; 합니다. 이 경우 자식 스레드가 부모 스레드보다 오래 지속될 수 있습니다 (부모 스레드가 기본 스레드가 아닌 경우 기본 스레드가 완료되면 전체 프로세스가 종료 됨). 또한 조인 핸들은 자식 스레드를 조인하는 데 사용할 수 있는 &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; 메서드를 제공합니다 . 자식 스레드 패닉 인 경우 &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic&lt;/code&gt; 에&lt;/a&gt; 제공된 인수를 포함 하는 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="099a2e1e2bdb72897b42735f9f375efdb1e2c049" translate="yes" xml:space="preserve">
          <source>The key line in this error is &lt;code&gt;cannot move out of type [T], a non-copy slice&lt;/code&gt;. With our non-generic versions of the &lt;code&gt;largest&lt;/code&gt; function, we were only trying to find the largest &lt;code&gt;i32&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt;. As discussed in the &lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;&amp;ldquo;Stack-Only Data: Copy&amp;rdquo;&lt;/a&gt; section in Chapter 4, types like &lt;code&gt;i32&lt;/code&gt; and &lt;code&gt;char&lt;/code&gt; that have a known size can be stored on the stack, so they implement the &lt;code&gt;Copy&lt;/code&gt; trait. But when we made the &lt;code&gt;largest&lt;/code&gt; function generic, it became possible for the &lt;code&gt;list&lt;/code&gt; parameter to have types in it that don&amp;rsquo;t implement the &lt;code&gt;Copy&lt;/code&gt; trait. Consequently, we wouldn&amp;rsquo;t be able to move the value out of &lt;code&gt;list[0]&lt;/code&gt; and into the &lt;code&gt;largest&lt;/code&gt; variable, resulting in this error.</source>
          <target state="translated">이 오류의 주요 행은 &lt;code&gt;cannot move out of type [T], a non-copy slice&lt;/code&gt; . &lt;code&gt;largest&lt;/code&gt; 함수 의 제네릭이 아닌 버전으로 가장 큰 &lt;code&gt;i32&lt;/code&gt; 또는 &lt;code&gt;char&lt;/code&gt; 을 찾으려고했습니다 . 4 장의 &lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;&quot;스택 전용 데이터 : 복사&quot;&lt;/a&gt; 섹션에서 설명한 것처럼 알려진 크기의 &lt;code&gt;i32&lt;/code&gt; 및 &lt;code&gt;char&lt;/code&gt; 과 같은 유형을 스택에 저장할 수 있으므로 &lt;code&gt;Copy&lt;/code&gt; 특성 을 구현합니다 . 그러나 &lt;code&gt;largest&lt;/code&gt; 함수를 제네릭으로 만들었을 때 특성을 구현하지 않는 유형을 갖는 &lt;code&gt;list&lt;/code&gt; 매개 변수 가 가능해졌습니다 &lt;code&gt;Copy&lt;/code&gt; . 결과적으로 우리는 가치를 &lt;code&gt;list[0]&lt;/code&gt; 및 &lt;code&gt;largest&lt;/code&gt; 변수에 연결하면이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bceeadadeee15f4a164537fd341fe02f08db51ce" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">열쇠는지도의 주요 유형의 대출 형태가 될 수 있지만, &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 빌린 양식이 &lt;em&gt;있어야합니다&lt;/em&gt; 키 유형과 일치.</target>
        </trans-unit>
        <trans-unit id="1967c0afcde1ba185b21a2a66c76557126c2a896" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">열쇠는지도의 주요 유형의 대출 형태가 될 수 있지만, &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 빌린 양식이 &lt;em&gt;있어야합니다&lt;/em&gt; 키 유형과 일치.</target>
        </trans-unit>
        <trans-unit id="25f3fabcbbf37a65231d46a27fb9b7a82a76e913" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but the ordering on the borrowed form &lt;em&gt;must&lt;/em&gt; match the ordering on the key type.</source>
          <target state="translated">키는지도 키 유형의 빌린 형식 일 수 있지만 빌린 양식 의 순서는 키 유형의 순서와 일치 &lt;em&gt;해야합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5794a7e2452d7c2d7acdcd9ca75f9f681dde7e71" translate="yes" xml:space="preserve">
          <source>The key property of unions is that all fields of a union share common storage. As a result writes to one field of a union can overwrite its other fields, and size of a union is determined by the size of its largest field.</source>
          <target state="translated">공용체의 주요 속성은 공용체의 모든 필드가 공통 스토리지를 공유한다는 것입니다. 결과적으로 Union의 한 필드에 쓰면 다른 필드를 덮어 쓸 수 있으며 Union의 크기는 가장 큰 필드의 크기에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="af36c49ed669c54fb87fd9d4d2b45f5df4d5de97" translate="yes" xml:space="preserve">
          <source>The key property of unions is that all fields of a union share common storage. As a result, writes to one field of a union can overwrite its other fields, and size of a union is determined by the size of its largest field.</source>
          <target state="translated">공용체의 주요 속성은 공용체의 모든 필드가 공통 저장소를 공유한다는 것입니다. 결과적으로 공용체의 한 필드에 대한 쓰기는 다른 필드를 덮어 쓸 수 있으며 공용체의 크기는 가장 큰 필드의 크기에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="730d38429c1bd8714c2ac7995eb67557271f3b30" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;pub&lt;/code&gt; makes any module, function, or data structure accessible from inside of external modules. The &lt;code&gt;pub&lt;/code&gt; keyword may also be used in a &lt;code&gt;use&lt;/code&gt; declaration to re-export an identifier from a namespace.</source>
          <target state="translated">키워드 &lt;code&gt;pub&lt;/code&gt; 는 외부 모듈 내부에서 모든 모듈, 함수 또는 데이터 구조에 액세스 할 수 있도록합니다. &lt;code&gt;pub&lt;/code&gt; 키워드도 사용할 수있다 &lt;code&gt;use&lt;/code&gt; 네임 스페이스에서 식별자를 다시 내보낼 선언.</target>
        </trans-unit>
        <trans-unit id="6097954d2b4ff2c7af7f3ee3f3f7074587267681" translate="yes" xml:space="preserve">
          <source>The kinds of patterns for parameters is limited to one of the following:</source>
          <target state="translated">매개 변수의 패턴 종류는 다음 중 하나로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="9150d911250adb9488a9891d8d1a7dd89c179545" translate="yes" xml:space="preserve">
          <source>The lack of infinite output indicates that this code didn&amp;rsquo;t create a reference cycle. We can also tell this by looking at the values we get from calling &lt;code&gt;Rc::strong_count&lt;/code&gt; and &lt;code&gt;Rc::weak_count&lt;/code&gt;.</source>
          <target state="translated">무한 출력이 없다는 것은이 코드가 참조주기를 생성하지 않았 음을 나타냅니다. 또한 &lt;code&gt;Rc::strong_count&lt;/code&gt; 및 &lt;code&gt;Rc::weak_count&lt;/code&gt; 호출에서 얻은 값을 보면 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f0cd1d95a878dd3fb3eb033669531c63a686db3" translate="yes" xml:space="preserve">
          <source>The lang attribute is intended for marking special items that are built-in to Rust itself. This includes special traits (like &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Sized&lt;/code&gt;) that affect how the compiler behaves, as well as special functions that may be automatically invoked (such as the handler for out-of-bounds accesses when indexing a slice).</source>
          <target state="translated">lang 속성은 Rust 자체에 내장 된 특수 항목을 표시하기위한 것입니다. 여기에는 컴파일러의 작동 방식에 영향을주는 특수 특성 (예 : &lt;code&gt;Copy&lt;/code&gt; 및 &lt;code&gt;Sized&lt;/code&gt; ) 과 자동으로 호출 될 수있는 특수 함수 (예 : 슬라이스를 인덱싱 할 때 범위를 벗어난 액세스를위한 처리기)가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="60e53524d7493db6ac00628d4141587167732e22" translate="yes" xml:space="preserve">
          <source>The lang attribute is intended for marking special items that are built-in to Rust itself. This includes special traits (like &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Sized&lt;/code&gt;) that affect how the compiler behaves, as well as special functions that may be automatically invoked (such as the handler for out-of-bounds accesses when indexing a slice). Erroneous code example:</source>
          <target state="translated">lang 속성은 Rust 자체에 내장 된 특수 항목을 표시하기위한 것입니다. 여기에는 컴파일러의 작동 방식에 영향을주는 특수 특성 (예 : &lt;code&gt;Copy&lt;/code&gt; 및 &lt;code&gt;Sized&lt;/code&gt; ) 과 자동으로 호출 될 수있는 특수 함수 (예 : 슬라이스 인덱싱시 범위를 벗어난 액세스를위한 핸들러)가 포함됩니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="080a1610af4bccfcd8725cb110cddf449fbd60f7" translate="yes" xml:space="preserve">
          <source>The lang attribute was used in an invalid context.</source>
          <target state="translated">lang 속성이 잘못된 컨텍스트에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="d001aa0e948f210ef67db3ed9f1079f66965d658" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type.</source>
          <target state="translated">이 정수 유형으로 표시 할 수있는 가장 큰 값입니다.</target>
        </trans-unit>
        <trans-unit id="55a17e21fb4394b20facf75f686648a8590b11f1" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i128#associatedconstant.MAX&quot;&gt;&lt;code&gt;i128::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 표시 할 수있는 가장 큰 값입니다. 대신 &lt;a href=&quot;../primitive.i128#associatedconstant.MAX&quot;&gt; &lt;code&gt;i128::MAX&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b73325de7bc5986e41ec8d92ed9701ddacd280f3" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i16#associatedconstant.MAX&quot;&gt;&lt;code&gt;i16::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 표시 할 수있는 가장 큰 값입니다. 대신 &lt;a href=&quot;../primitive.i16#associatedconstant.MAX&quot;&gt; &lt;code&gt;i16::MAX&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7bb87b47e7f2c22de123ec199f4be989c0dcaf2" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i32#associatedconstant.MAX&quot;&gt;&lt;code&gt;i32::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 표시 할 수있는 가장 큰 값입니다. 대신 &lt;a href=&quot;../primitive.i32#associatedconstant.MAX&quot;&gt; &lt;code&gt;i32::MAX&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf18dde926e284162a660a1b1a2a30b118d1c49a" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i64#associatedconstant.MAX&quot;&gt;&lt;code&gt;i64::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 표시 할 수있는 가장 큰 값입니다. 대신 &lt;a href=&quot;../primitive.i64#associatedconstant.MAX&quot;&gt; &lt;code&gt;i64::MAX&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b22c4dd542e2ceff2527d706e65d0c5acc6f4d52" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i8#associatedconstant.MAX&quot;&gt;&lt;code&gt;i8::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 표시 할 수있는 가장 큰 값입니다. 대신 &lt;a href=&quot;../primitive.i8#associatedconstant.MAX&quot;&gt; &lt;code&gt;i8::MAX&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a2e67766c1f950d1a3f862bddde0bc78e36aacd" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.isize#associatedconstant.MAX&quot;&gt;&lt;code&gt;isize::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 표시 할 수있는 가장 큰 값입니다. 대신 &lt;a href=&quot;../primitive.isize#associatedconstant.MAX&quot;&gt; &lt;code&gt;isize::MAX&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="697ca9e8dc5fcb1feb5a529df70222ec030c2428" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u128#associatedconstant.MAX&quot;&gt;&lt;code&gt;u128::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 표시 할 수있는 가장 큰 값입니다. 대신 &lt;a href=&quot;../primitive.u128#associatedconstant.MAX&quot;&gt; &lt;code&gt;u128::MAX&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="23128039031afffa375e1d18e6f18c10d1470457" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u16#associatedconstant.MAX&quot;&gt;&lt;code&gt;u16::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 표시 할 수있는 가장 큰 값입니다. 대신 &lt;a href=&quot;../primitive.u16#associatedconstant.MAX&quot;&gt; &lt;code&gt;u16::MAX&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cead8aa8b3423346a603591b8a3bb3bb38de07d" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u32#associatedconstant.MAX&quot;&gt;&lt;code&gt;u32::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 표시 할 수있는 가장 큰 값입니다. 대신 &lt;a href=&quot;../primitive.u32#associatedconstant.MAX&quot;&gt; &lt;code&gt;u32::MAX&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfdca1f692589c69870c6eba29a4be248c639ebc" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u64#associatedconstant.MAX&quot;&gt;&lt;code&gt;u64::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 표시 할 수있는 가장 큰 값입니다. 대신 &lt;a href=&quot;../primitive.u64#associatedconstant.MAX&quot;&gt; &lt;code&gt;u64::MAX&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="de1cfd44e67cca085f5a9478c1e9579b369e52ad" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u8#associatedconstant.MAX&quot;&gt;&lt;code&gt;u8::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 표시 할 수있는 가장 큰 값입니다. 대신 &lt;a href=&quot;../primitive.u8#associatedconstant.MAX&quot;&gt; &lt;code&gt;u8::MAX&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c52af57b6ca83f430b64beb1abd9c9176989341" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.usize#associatedconstant.MAX&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 표시 할 수있는 가장 큰 값입니다. 대신 &lt;a href=&quot;../primitive.usize#associatedconstant.MAX&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5bab83aeec1382113d53e6e7d14863dd49ec843d" translate="yes" xml:space="preserve">
          <source>The last change we have to make is in the assertion: to see how many items are in the inner vector, we call &lt;code&gt;borrow&lt;/code&gt; on the &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; to get an immutable reference to the vector.</source>
          <target state="translated">우리가 마지막으로 변경해야 할 것은 단언입니다. 내부 벡터에 얼마나 많은 항목이 있는지 보려면 &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; 에 대해 &lt;code&gt;borrow&lt;/code&gt; 를 호출 하여 벡터에 대한 불변의 참조를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="b92b068be4c2b594134000422ae50b8df0c8bac3" translate="yes" xml:space="preserve">
          <source>The last difference is that constants may be set only to a constant expression, not the result of a function call or any other value that could only be computed at runtime.</source>
          <target state="translated">마지막 차이점은 상수는 상수 표현식으로 만 설정할 수 있으며 함수 호출의 결과 나 런타임시에만 계산할 수있는 다른 값은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="293474ffe041aff8a994854d8cad3ac993cf31b4" translate="yes" xml:space="preserve">
          <source>The last element returned, if any, will contain the remainder of the slice.</source>
          <target state="translated">반환 된 마지막 요소 (있는 경우)는 나머지 슬라이스를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8d491eebdf550e16362be621e1476cb5ece9206f" translate="yes" xml:space="preserve">
          <source>The last field of &lt;code&gt;Foo&lt;/code&gt; has a type involving &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 의 마지막 필드에는 &lt;code&gt;T&lt;/code&gt; 와 관련된 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf70627b4e81c57a3ddc9f76311bc0b01f381dcd" translate="yes" xml:space="preserve">
          <source>The last line of the output shows the location and the name of the installed binary, which in the case of &lt;code&gt;ripgrep&lt;/code&gt; is &lt;code&gt;rg&lt;/code&gt;. As long as the installation directory is in your &lt;code&gt;$PATH&lt;/code&gt;, as mentioned previously, you can then run &lt;code&gt;rg --help&lt;/code&gt; and start using a faster, rustier tool for searching files!</source>
          <target state="translated">출력 표시 위치의 케이스에 설치된 진의 이름의 마지막 라인 &lt;code&gt;ripgrep&lt;/code&gt; 인 &lt;code&gt;rg&lt;/code&gt; . 앞에서 언급했듯이 설치 디렉토리가 &lt;code&gt;$PATH&lt;/code&gt; 에 있으면 &lt;code&gt;rg --help&lt;/code&gt; 를 실행 하고 파일을 검색하기 위해 더 빠르고 더 견고한 도구를 사용할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="3dc7b6a27a6191be06711a90615e83b643711efc" translate="yes" xml:space="preserve">
          <source>The last line shows that &lt;code&gt;&amp;amp;bar&lt;/code&gt; is not a function pointer either. Rather, it is a reference to the function-specific ZST. &lt;code&gt;&amp;amp;bar&lt;/code&gt; is basically never what you want when &lt;code&gt;bar&lt;/code&gt; is a function.</source>
          <target state="translated">마지막 줄은 &lt;code&gt;&amp;amp;bar&lt;/code&gt; 도 함수 포인터가 아님을 보여줍니다 . 오히려 기능별 ZST에 대한 참조입니다. &lt;code&gt;&amp;amp;bar&lt;/code&gt; 는 기본적으로 &lt;code&gt;bar&lt;/code&gt; 가 함수일 때 원하는 것이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="982060970609630bdcfd3dbdc543a9a98b2de24a" translate="yes" xml:space="preserve">
          <source>The last line, &lt;code&gt;[dependencies]&lt;/code&gt;, is the start of a section for you to list any of your project&amp;rsquo;s dependencies. In Rust, packages of code are referred to as &lt;em&gt;crates&lt;/em&gt;. We won&amp;rsquo;t need any other crates for this project, but we will in the first project in Chapter 2, so we&amp;rsquo;ll use this dependencies section then.</source>
          <target state="translated">마지막 행인 &lt;code&gt;[dependencies]&lt;/code&gt; 는 프로젝트의 종속성을 나열하기위한 섹션의 시작입니다. Rust에서는 코드 패키지를 &lt;em&gt;상자&lt;/em&gt; 라고합니다 . 이 프로젝트에는 다른 상자가 필요하지 않지만 2 장의 첫 번째 프로젝트에서는이 종속성 섹션을 사용할 것입니다.</target>
        </trans-unit>
        <trans-unit id="c8d286da9b3987ef73f4d9e79523c9888a168257" translate="yes" xml:space="preserve">
          <source>The last of our common collections is the &lt;em&gt;hash map&lt;/em&gt;. The type &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; stores a mapping of keys of type &lt;code&gt;K&lt;/code&gt; to values of type &lt;code&gt;V&lt;/code&gt;. It does this via a &lt;em&gt;hashing function&lt;/em&gt;, which determines how it places these keys and values into memory. Many programming languages support this kind of data structure, but they often use a different name, such as hash, map, object, hash table, dictionary, or associative array, just to name a few.</source>
          <target state="translated">우리의 공통 컬렉션의 마지막은 &lt;em&gt;해시 맵&lt;/em&gt; 입니다. 타입 &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 점포 형 키 맵핑 &lt;code&gt;K&lt;/code&gt; 타입의 값 &lt;code&gt;V&lt;/code&gt; . &lt;em&gt;해싱 함수&lt;/em&gt; 를 통해이 키와 값을 메모리에 배치하는 방법을 결정합니다. 많은 프로그래밍 언어는 이러한 종류의 데이터 구조를 지원하지만 해시, 맵, 객체, 해시 테이블, 사전 또는 연관 배열과 같은 다른 이름을 사용하여 이름을 지정하는 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="e50377e1cc3271006121b6b6e503348b95075085" translate="yes" xml:space="preserve">
          <source>The last part is the HTTP version the client uses, and then the request line ends in a &lt;em&gt;CRLF sequence&lt;/em&gt;. (CRLF stands for &lt;em&gt;carriage return&lt;/em&gt; and &lt;em&gt;line feed&lt;/em&gt;, which are terms from the typewriter days!) The CRLF sequence can also be written as &lt;code&gt;\r\n&lt;/code&gt;, where &lt;code&gt;\r&lt;/code&gt; is a carriage return and &lt;code&gt;\n&lt;/code&gt; is a line feed. The CRLF sequence separates the request line from the rest of the request data. Note that when the CRLF is printed, we see a new line start rather than &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">마지막 부분은 클라이언트가 사용하는 HTTP 버전이며 요청 라인은 &lt;em&gt;CRLF 시퀀스로&lt;/em&gt; 끝납니다 . CRLF는 &lt;em&gt;캐리지 리턴&lt;/em&gt; 및 &lt;em&gt;줄 바꿈&lt;/em&gt; 을 의미하며 타자기 일의 용어입니다. CRLF 시퀀스는 &lt;code&gt;\r\n&lt;/code&gt; 으로도 쓸 수 있습니다 . 여기서 &lt;code&gt;\r&lt;/code&gt; 은 캐리지 리턴이고 &lt;code&gt;\n&lt;/code&gt; 은 줄 바꿈입니다. CRLF 시퀀스는 요청 라인을 나머지 요청 데이터와 분리합니다. CRLF가 인쇄되면 &lt;code&gt;\r\n&lt;/code&gt; 대신 새로운 줄이 시작 됩니다.</target>
        </trans-unit>
        <trans-unit id="e7f87628bb5e91d33e6ee47cc631179039d310fa" translate="yes" xml:space="preserve">
          <source>The layout of a type is its size, alignment, and the relative offsets of its fields. For enums, how the discriminant is laid out and interpreted is also part of type layout.</source>
          <target state="translated">유형의 레이아웃은 크기, 정렬 및 필드의 상대적 오프셋입니다. 열거 형의 경우 판별자가 배치되고 해석되는 방식도 유형 레이아웃의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="bb7242c48b73507f4d4792c2cb29fe84ab3a4519" translate="yes" xml:space="preserve">
          <source>The layout of allocation request that failed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d81ce81ead59e71cfd072129a8c87907148c562c" translate="yes" xml:space="preserve">
          <source>The left operand of an &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;assignment&lt;/a&gt; or &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;compound assignment&lt;/a&gt; expression.</source>
          <target state="translated">&lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;대입&lt;/a&gt; 또는 &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;복합 대입&lt;/a&gt; 식 의 왼쪽 피연산자입니다 .</target>
        </trans-unit>
        <trans-unit id="1c0d113ddd28e543817cdc902e3988c72a15e13a" translate="yes" xml:space="preserve">
          <source>The left shift assignment operator &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;.</source>
          <target state="translated">좌측 시프트 할당 연산자 &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="553d8d3f55b49cb8907e0699dd0a3d9c13298c80" translate="yes" xml:space="preserve">
          <source>The left shift operator &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust's type checker has special handling for &lt;code&gt;_ &amp;lt;&amp;lt; _&lt;/code&gt;, setting the result type for integer operations to the type of the left-hand-side operand. This means that though &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; and &lt;code&gt;a.shl(b)&lt;/code&gt; are one and the same from an evaluation standpoint, they are different when it comes to type inference.</source>
          <target state="translated">좌측 시프트 연산자 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; . 이 특성은 여러 오른쪽 유형이있는 모든 정수 유형에 대해 구현되므로 Rust의 유형 검사기는 &lt;code&gt;_ &amp;lt;&amp;lt; _&lt;/code&gt; 대한 특수 처리를 수행하여 정수 연산의 결과 유형을 왼쪽 피연산자의 유형으로 설정합니다. . 이것은 &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; 와 &lt;code&gt;a.shl(b)&lt;/code&gt; 가 하나의 평가 관점에서 동일하지만 형식 유추에 있어서는 다르다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="abb83d0dbf2481e1c0cc0aff75ee4837acd9c8fb" translate="yes" xml:space="preserve">
          <source>The left-hand side of a compound assignment expression must be a place expression. A place expression represents a memory location and includes item paths (ie, namespaced variables), dereferences, indexing expressions, and field references.</source>
          <target state="translated">복합 할당 표현식의 왼쪽은 장소 표현식이어야합니다. 장소 표현식은 메모리 위치를 나타내며 항목 경로 (예 : 네임 스페이스 변수), 역 참조, 색인 표현식 및 필드 참조를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9df6999a3c0f46759818b5fb8abefef29f79e559" translate="yes" xml:space="preserve">
          <source>The left-hand side of an assignment operator must be a place expression. A place expression represents a memory location and can be a variable (with optional namespacing), a dereference, an indexing expression or a field reference.</source>
          <target state="translated">대입 연산자의 왼쪽은 장소 표현식이어야합니다. 장소 표현식은 메모리 위치를 나타내며 변수 (선택적 이름 간격 지정), 역 참조, 색인 표현식 또는 필드 참조 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2c37a7f1d5752be8f4a3cd4c10444c370f709c8" translate="yes" xml:space="preserve">
          <source>The length is how much memory, in bytes, the contents of the &lt;code&gt;String&lt;/code&gt; is currently using. The capacity is the total amount of memory, in bytes, that the &lt;code&gt;String&lt;/code&gt; has received from the allocator. The difference between length and capacity matters, but not in this context, so for now, it&amp;rsquo;s fine to ignore the capacity.</source>
          <target state="translated">길이는 &lt;code&gt;String&lt;/code&gt; 의 내용 이 현재 사용중인 메모리 양 (바이트) 입니다. 용량은 &lt;code&gt;String&lt;/code&gt; 이 할당 자로부터받은 총 메모리 양 (바이트)입니다 . 길이와 용량의 차이는 중요하지만이 맥락에서는 중요하지 않으므로 지금은 용량을 무시하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="583ea3cae577825fe984e0b2dabdc2098e762a9c" translate="yes" xml:space="preserve">
          <source>The length is how much memory, in bytes, the contents of the &lt;code&gt;String&lt;/code&gt; is currently using. The capacity is the total amount of memory, in bytes, that the &lt;code&gt;String&lt;/code&gt; has received from the operating system. The difference between length and capacity matters, but not in this context, so for now, it&amp;rsquo;s fine to ignore the capacity.</source>
          <target state="translated">길이는 &lt;code&gt;String&lt;/code&gt; 의 내용 이 현재 사용중인 메모리 양 (바이트) 입니다. 용량은 &lt;code&gt;String&lt;/code&gt; 이 운영 체제로부터받은 총 메모리 양 (바이트)입니다 . 길이와 용량의 차이는 중요하지만이 상황에서는 중요하지 않으므로 지금은 용량을 무시해도됩니다.</target>
        </trans-unit>
        <trans-unit id="bec01c75ecf9080484e0035ecb4817690e9d17fa" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;other&lt;/code&gt; must be the same as &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; 길이는 &lt;code&gt;self&lt;/code&gt; 와 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="1d3c6c04d874a34e3f73cf44da542c5ee7d39510" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;src&lt;/code&gt; must be the same as &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 의 길이는 &lt;code&gt;self&lt;/code&gt; 와 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="f5ae40e336b72c0149684750f73301547acc7603" translate="yes" xml:space="preserve">
          <source>The length of the platform-intrinsic function &lt;code&gt;simd_shuffle&lt;/code&gt; wasn't specified.</source>
          <target state="translated">플랫폼 내장 함수 &lt;code&gt;simd_shuffle&lt;/code&gt; 의 길이가 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="65b0bfaafe677ff19be99641d06a9d0388b357ef" translate="yes" xml:space="preserve">
          <source>The length of the platform-intrinsic function &lt;code&gt;simd_shuffle&lt;/code&gt; wasn't specified. Erroneous code example:</source>
          <target state="translated">플랫폼 고유 함수 &lt;code&gt;simd_shuffle&lt;/code&gt; 의 길이가 지정되지 않았습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="2e4dc711d20d353ed60fc2eb7d0105870f230a29" translate="yes" xml:space="preserve">
          <source>The length returned is that of the underlying storage used by &lt;code&gt;OsStr&lt;/code&gt;. As discussed in the &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; introduction, &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;OsStr&lt;/code&gt; store strings in a form best suited for cheap inter-conversion between native-platform and Rust string forms, which may differ significantly from both of them, including in storage size and encoding.</source>
          <target state="translated">반환 된 길이는 &lt;code&gt;OsStr&lt;/code&gt; 에서 사용하는 기본 저장소의 길이 입니다. &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 소개 에서 논의했듯이 &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 과 &lt;code&gt;OsStr&lt;/code&gt; 은 네이티브 플랫폼과 Rust 문자열 형식 간의 저렴한 상호 변환에 가장 적합한 형식으로 문자열을 저장합니다.이 형식은 저장소 크기와 인코딩을 포함하여 둘 다 크게 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fe8cad4da628228b8d9a6730b144662e5d5b147" translate="yes" xml:space="preserve">
          <source>The length returned is that of the underlying storage used by &lt;code&gt;OsStr&lt;/code&gt;; As discussed in the &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; introduction, &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;OsStr&lt;/code&gt; store strings in a form best suited for cheap inter-conversion between native-platform and Rust string forms, which may differ significantly from both of them, including in storage size and encoding.</source>
          <target state="translated">반환 된 길이는 &lt;code&gt;OsStr&lt;/code&gt; 이 사용하는 기본 스토리지의 길이입니다 . &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 소개 에서 설명했듯이 &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;OsStr&lt;/code&gt; 은 기본 플랫폼과 Rust 문자열 형식 간의 저렴한 상호 변환에 가장 적합한 형식으로 문자열을 저장합니다.이 형식은 스토리지 크기 및 인코딩을 포함하여 두 형식과 크게 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99a0d51daa7130da604f883d5259ae5835cb10c2" translate="yes" xml:space="preserve">
          <source>The lifetime bound for this object type cannot be deduced from context and must be specified.</source>
          <target state="translated">이 개체 유형에 대한 수명 제한은 컨텍스트에서 추론 할 수 없으며 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="71866b1db7de253967c22f08d6dc545dfcd4182b" translate="yes" xml:space="preserve">
          <source>The lifetime constraint &lt;code&gt;'b&lt;/code&gt; for &lt;code&gt;bar()&lt;/code&gt; implementation does not match the trait declaration. Ensure lifetime declarations match exactly in both trait declaration and implementation. Example:</source>
          <target state="translated">&lt;code&gt;bar()&lt;/code&gt; 구현에 대한 수명 제한 &lt;code&gt;'b&lt;/code&gt; 가 특성 선언과 일치하지 않습니다. 수명 선언이 특성 선언과 구현 모두에서 정확히 일치하는지 확인합니다. 예:</target>
        </trans-unit>
        <trans-unit id="30238ceba60deefc79cfa25b4649d1a595edd0d8" translate="yes" xml:space="preserve">
          <source>The lifetime constraint &lt;code&gt;'b&lt;/code&gt; for bar() implementation does not match the trait declaration. Ensure lifetime declarations match exactly in both trait declaration and implementation. Example:</source>
          <target state="translated">bar () 구현 의 수명 제약 조건 &lt;code&gt;'b&lt;/code&gt; 가 특성 선언과 일치하지 않습니다. 수명 선언이 특성 선언 및 구현에서 정확히 일치하는지 확인하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="61076c57b01b556a6cbf075ae8202a67124b97eb" translate="yes" xml:space="preserve">
          <source>The lifetime elision rules require that any function signature with an elided output lifetime must either have</source>
          <target state="translated">수명 제거 규칙을 사용하려면 출력 수명이 생략 된 함수 시그니처 중 하나에</target>
        </trans-unit>
        <trans-unit id="15fb2549a777717fb62ea70833166d18eb32b15d" translate="yes" xml:space="preserve">
          <source>The lifetime elision rules require that any function signature with an elided output lifetime must either have:</source>
          <target state="translated">수명 제거 규칙에서는 출력 수명이 제거 된 함수 서명이 다음 중 하나를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="7914129f994f43353c3efa7974019d9a960355fb" translate="yes" xml:space="preserve">
          <source>The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse, it's suggested to tie the lifetime to whichever source lifetime is safe in the context, such as by providing a helper function taking the lifetime of a host value for the slice, or by explicit annotation.</source>
          <target state="translated">반환 된 슬라이스의 수명은 사용법에서 유추됩니다. 우발적 인 오용을 방지하기 위해 슬라이스에 대한 호스트 값의 수명을 가져 오는 도우미 기능을 제공하거나 명시적인 주석과 같이 컨텍스트에서 소스 수명이 안전한 소스에 수명을 연결하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="af0f1e1de97ff5087fa423eab95c1e381b7b3ee8" translate="yes" xml:space="preserve">
          <source>The lifetime of the returned &lt;code&gt;Cursor&lt;/code&gt; is bound to that of the &lt;code&gt;CursorMut&lt;/code&gt;, which means it cannot outlive the &lt;code&gt;CursorMut&lt;/code&gt; and that the &lt;code&gt;CursorMut&lt;/code&gt; is frozen for the lifetime of the &lt;code&gt;Cursor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57046a8e7fbf89990ae303fb2235f525d1c99061" translate="yes" xml:space="preserve">
          <source>The lifetime parameter declaration after &lt;code&gt;impl&lt;/code&gt; and its use after the type name are required, but we&amp;rsquo;re not required to annotate the lifetime of the reference to &lt;code&gt;self&lt;/code&gt; because of the first elision rule.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; 이후의 수명 매개 변수 선언 과 형식 이름 다음의 사용이 필요하지만 첫 번째 제거 규칙으로 인해 참조 수명을 &lt;code&gt;self&lt;/code&gt; 에 주석을 달 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="37f7629efc4022ff5cf0b561478f77607b602987" translate="yes" xml:space="preserve">
          <source>The lifetime parameters of the method do not match the trait declaration.</source>
          <target state="translated">메서드의 수명 매개 변수가 특성 선언과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14f07422d02861a626046c58ce643a2a52da0ac8" translate="yes" xml:space="preserve">
          <source>The line &lt;code&gt;index out of bounds: the len is 1 but the index is 1&lt;/code&gt; is an error message intended for programmers. It won&amp;rsquo;t help our end users understand what happened and what they should do instead. Let&amp;rsquo;s fix that now.</source>
          <target state="translated">행 &lt;code&gt;index out of bounds: the len is 1 but the index is 1&lt;/code&gt; 입니다. 프로그래머를위한 오류 메시지입니다. 최종 사용자가 발생한 일과 대신해야 할 일을 이해하는 데 도움이되지 않습니다. 이제 고치겠습니다.</target>
        </trans-unit>
        <trans-unit id="5a0147b8f24f32bab15f7fb8959607d1c4391ac2" translate="yes" xml:space="preserve">
          <source>The line is:</source>
          <target state="translated">라인은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de1c3b88f137cbbbccea4f427174e92d6650dd55" translate="yes" xml:space="preserve">
          <source>The lines execute in the order in which they appear in the &lt;code&gt;main&lt;/code&gt; function. First, the &amp;ldquo;Hello, world!&amp;rdquo; message prints, and then &lt;code&gt;another_function&lt;/code&gt; is called and its message is printed.</source>
          <target state="translated">행은 &lt;code&gt;main&lt;/code&gt; 기능에 나타나는 순서대로 실행됩니다 . 먼저, &quot;Hello, world!&quot; 메시지가 인쇄 된 다음 &lt;code&gt;another_function&lt;/code&gt; 이 호출되고 메시지가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="a2f50a40f788fe52620261459fe43b43f06256a8" translate="yes" xml:space="preserve">
          <source>The linkage of the C runtime is configured to respect the &lt;code&gt;crt-static&lt;/code&gt; target feature. These target features are typically configured from the command line via flags to the compiler itself. For example to enable a static runtime you would execute:</source>
          <target state="translated">C 런타임의 링크는 &lt;code&gt;crt-static&lt;/code&gt; 대상 기능 을 존중하도록 구성되어 있습니다. 이러한 대상 기능은 일반적으로 플래그를 통해 명령 줄에서 컴파일러 자체로 구성됩니다. 예를 들어 정적 런타임을 활성화하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="efca89d0995e1ff0c39cef27089410685b77deb1" translate="yes" xml:space="preserve">
          <source>The list of derivable traits provided in this appendix is not comprehensive: libraries can implement &lt;code&gt;derive&lt;/code&gt; for their own traits, making the list of traits you can use &lt;code&gt;derive&lt;/code&gt; with truly open-ended. Implementing &lt;code&gt;derive&lt;/code&gt; involves using a procedural macro, which is covered in the &lt;a href=&quot;ch19-06-macros#macros&quot;&gt;&amp;ldquo;Macros&amp;rdquo;&lt;/a&gt; section of Chapter 19.</source>
          <target state="translated">이 부록에서 제공되는 파생 가능한 특성 목록은 포괄적이지 않습니다. 라이브러리는 고유 한 특성에 대한 &lt;code&gt;derive&lt;/code&gt; 을 구현할 수 있으므로 사용할 &lt;code&gt;derive&lt;/code&gt; 있는 특성 목록을 실제로 개방형으로 파생 시킬 수 있습니다 . &lt;code&gt;derive&lt;/code&gt; 구현하려면 절차 적 매크로를 사용해야 합니다. 절차 적 매크로는 19 장의 &lt;a href=&quot;ch19-06-macros#macros&quot;&gt;&quot;매크로&quot;&lt;/a&gt; 섹션 에서 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="e9a2965c85bdbd082d28a62c5ab1cef15f730b46" translate="yes" xml:space="preserve">
          <source>The list of types is:</source>
          <target state="translated">유형 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="91f214c30e2ceb29652b72be6f5c77765c1026b7" translate="yes" xml:space="preserve">
          <source>The literal characters &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; may be included in a string by preceding them with the same character. For example, the &lt;code&gt;{&lt;/code&gt; character is escaped with &lt;code&gt;{{&lt;/code&gt; and the &lt;code&gt;}&lt;/code&gt; character is escaped with &lt;code&gt;}}&lt;/code&gt;.</source>
          <target state="translated">리터럴 문자 &lt;code&gt;{&lt;/code&gt; 및 &lt;code&gt;}&lt;/code&gt; 는 동일한 문자로 시작하여 문자열에 포함될 수 있습니다. 예를 들어, &lt;code&gt;{&lt;/code&gt; 문자로 이스케이프 &lt;code&gt;{{&lt;/code&gt; 와 &lt;code&gt;}&lt;/code&gt; 문자로 이스케이프 &lt;code&gt;}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5be7b0512e1a505e9266eb524c4b5165ed24536" translate="yes" xml:space="preserve">
          <source>The lock could not be acquired at this time because the operation would otherwise block.</source>
          <target state="translated">조작이 차단되었으므로 현재 잠금을 획득 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ca27685a95f0186521159c6d95fa9cb158ac3333" translate="yes" xml:space="preserve">
          <source>The lock could not be acquired because another thread failed while holding the lock.</source>
          <target state="translated">잠금을 유지하는 동안 다른 스레드가 실패하여 잠금을 확보 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e835ab2030797bd0af68c5e546090096d0ef15ed" translate="yes" xml:space="preserve">
          <source>The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.bufread&quot;&gt;&lt;code&gt;BufRead&lt;/code&gt;&lt;/a&gt; traits for accessing the underlying data.</source>
          <target state="translated">반환 된 잠금이 범위를 벗어나면 잠금이 해제됩니다. 리턴 된 가드는 또한 기본 데이터에 액세스하기위한 &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;trait.bufread&quot;&gt; &lt;code&gt;BufRead&lt;/code&gt; &lt;/a&gt; 특성을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="ca99507e16c078ed3bf090ad447532972842294c" translate="yes" xml:space="preserve">
          <source>The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; trait for writing data.</source>
          <target state="translated">반환 된 잠금이 범위를 벗어나면 잠금이 해제됩니다. 반환 된 가드는 데이터 &lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; 위한 Write 특성 도 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="95f3d5bdf30a84c247ddb912c9e27503ec850ddb" translate="yes" xml:space="preserve">
          <source>The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;code&gt;Write&lt;/code&gt; trait for writing data.</source>
          <target state="translated">반환 된 잠금이 범위를 벗어나면 잠금이 해제됩니다. 리턴 된 가드는 또한 데이터 &lt;code&gt;Write&lt;/code&gt; 위한 쓰기 특성을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="9fbc8134425c3ce849c012cee6ed6bdb948d21a6" translate="yes" xml:space="preserve">
          <source>The logic around the &lt;code&gt;value&lt;/code&gt; field we&amp;rsquo;ve just described is defined in Listing 13-10.</source>
          <target state="translated">방금 설명한 &lt;code&gt;value&lt;/code&gt; 필드에 대한 논리 는 Listing 13-10에 정의되어있다.</target>
        </trans-unit>
        <trans-unit id="f2cf3737106dde9e749616b8670f272a444680a9" translate="yes" xml:space="preserve">
          <source>The lower bound of the range (inclusive).</source>
          <target state="translated">범위의 하한입니다 (포함).</target>
        </trans-unit>
        <trans-unit id="0766d14228f909fbfdac3f3dca197e2a666359ec" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any.</source>
          <target state="translated">이 오류의 하위 원인 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="4b8803f6ab5b8d7b772e6a580f89ee4b72aef2f4" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;../../error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 오류의 하위 원인 (있는 경우) &lt;a href=&quot;../../error/trait.error#method.cause&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5980cf0091c024091baef1d2b8180b13d7e8fb92" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;../error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 오류의 하위 원인 (있는 경우) &lt;a href=&quot;../error/trait.error#method.cause&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f757a43bf56678673d64a896a7ea59d83e9d1668" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 오류의 하위 원인 (있는 경우) &lt;a href=&quot;error/trait.error#method.cause&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="828185ce8f6bedf0299995b3c4e9cb20b7a41ecd" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any.</source>
          <target state="translated">이 오류의 하위 수준 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="ea0a6930dc7de4d466ce55f6448d31ae162ca38c" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;../../error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 오류의 하위 수준 (있는 경우) &lt;a href=&quot;../../error/trait.error#method.source&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb0a1822fe706b0e16bb4cab78928338d81339e3" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;../error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 오류의 하위 수준 (있는 경우) &lt;a href=&quot;../error/trait.error#method.source&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bccd557ca491cf82db4f740ce89716ec64f4fabf" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 오류의 하위 수준 (있는 경우) &lt;a href=&quot;error/trait.error#method.source&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f6b9226fd8ae01998a5ebc10002aa19b3691743f" translate="yes" xml:space="preserve">
          <source>The machine code for &lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt;, or any other type substitution is different. Hence the compiler generates the implementation on-demand. If you call &lt;code&gt;foo()&lt;/code&gt; with a &lt;code&gt;bool&lt;/code&gt; parameter, the compiler will only generate code for &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;. When we have additional type parameters, the number of monomorphized implementations the compiler generates does not grow drastically, since the compiler will only generate an implementation if the function is called with unparametrized substitutions (i.e., substitutions where none of the substituted types are themselves parameterized).</source>
          <target state="translated">&lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt; , &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt; , &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt; 또는 기타 유형 대체에 대한 기계어 코드 가 다릅니다. 따라서 컴파일러는 주문형 구현을 생성합니다. &lt;code&gt;bool&lt;/code&gt; 매개 변수 와 함께 &lt;code&gt;foo()&lt;/code&gt; 를 호출 하면 컴파일러는 &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt; 대한 코드 만 생성합니다 . 추가 유형 매개 변수가있을 때 컴파일러가 생성하는 단일 형태 구현의 수는 크게 증가하지 않습니다. 컴파일러는 매개 변수화되지 않은 대체 (즉, 대체 된 유형 자체가 매개 변수화되지 않은 대체)로 함수가 호출 된 경우에만 구현을 생성하기 때문입니다. .</target>
        </trans-unit>
        <trans-unit id="9e0846c263b7366386582dfe4d412a3ad4ba7b9f" translate="yes" xml:space="preserve">
          <source>The machine code for &lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt;, or any other type substitution is different. Hence the compiler generates the implementation on-demand. If you call &lt;code&gt;foo()&lt;/code&gt; with a &lt;code&gt;bool&lt;/code&gt; parameter, the compiler will only generate code for &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;. When we have additional type parameters, the number of monomorphized implementations the compiler generates does not grow drastically, since the compiler will only generate an implementation if the function is called with unparametrized substitutions (i.e., substitutions where none of the substituted types are themselves parametrized).</source>
          <target state="translated">&lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt; , &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt; , &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt; 또는 다른 유형 대체에 대한 기계어 코드 가 다릅니다. 따라서 컴파일러는 주문형 구현을 생성합니다. &lt;code&gt;bool&lt;/code&gt; 매개 변수 와 함께 &lt;code&gt;foo()&lt;/code&gt; 를 호출 하면 컴파일러는 &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt; 대한 코드 만 생성합니다 . 추가 유형 매개 변수가있는 경우 함수가 매개 변수화되지 않은 대체 (즉 대체 된 유형이 자체 매개 변수화되지 않은 대체)로 호출되는 경우에만 컴파일러가 구현을 생성하기 때문에 컴파일러가 생성하는 단일 형태 구현의 수가 크게 증가하지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="ec5d54a07ee0f8ac568e82f61b376d035a168bca" translate="yes" xml:space="preserve">
          <source>The macro itself will decide how to interpret such a token and whether to produce an error or not.</source>
          <target state="translated">매크로 자체는 그러한 토큰을 해석하는 방법과 오류 발생 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="8db5958c7dabf9cedcc4db6e6fa16a59d45c2565" translate="yes" xml:space="preserve">
          <source>The macro works by using the &lt;code&gt;Debug&lt;/code&gt; implementation of the type of the given expression to print the value to &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt; along with the source location of the macro invocation as well as the source code of the expression.</source>
          <target state="translated">매크로는 주어진 표현식 유형의 &lt;code&gt;Debug&lt;/code&gt; 구현을 사용하여 매크로 호출의 소스 위치 및 표현식의 소스 코드와 함께 값을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt; 에 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="9498e8eb390e83cb5dbd448b585676f4b5c37123" translate="yes" xml:space="preserve">
          <source>The macro wraps any number of static declarations and makes them thread local. Publicity and attributes for each static are allowed. Example:</source>
          <target state="translated">이 매크로는 많은 수의 정적 선언을 래핑하고 스레드를 로컬로 만듭니다. 각 정적에 대한 홍보 및 속성이 허용됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="2eb59c956ec6e4722a7e8cfdea3a410b913da22e" translate="yes" xml:space="preserve">
          <source>The main aim of lifetimes is to prevent dangling references, which cause a program to reference data other than the data it&amp;rsquo;s intended to reference. Consider the program in Listing 10-17, which has an outer scope and an inner scope.</source>
          <target state="translated">수명의 주요 목표는 댕글 링 참조를 방지하여 프로그램이 참조하려는 데이터 이외의 데이터를 참조하도록하는 것입니다. 외부 범위와 내부 범위가있는 목록 10-17의 프로그램을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c087688652f35bf8ea7f8323996c74d4edfcf197" translate="yes" xml:space="preserve">
          <source>The main benefit of using methods instead of functions, in addition to using method syntax and not having to repeat the type of &lt;code&gt;self&lt;/code&gt; in every method&amp;rsquo;s signature, is for organization. We&amp;rsquo;ve put all the things we can do with an instance of a type in one &lt;code&gt;impl&lt;/code&gt; block rather than making future users of our code search for capabilities of &lt;code&gt;Rectangle&lt;/code&gt; in various places in the library we provide.</source>
          <target state="translated">메소드 대신 구문을 사용 하고 모든 메소드의 서명에서 &lt;code&gt;self&lt;/code&gt; 유형을 반복 할 필요없이 함수 대신 메소드를 사용하면 얻을 수있는 주요 이점은 조직에 있습니다. 우리는 코드의 미래 사용자가 우리 가 제공하는 라이브러리의 다양한 위치에서 &lt;code&gt;Rectangle&lt;/code&gt; 의 기능을 검색하지 않고 유형의 인스턴스로 수행 할 수있는 모든 것을 하나의 &lt;code&gt;impl&lt;/code&gt; 블록에 넣었습니다 .</target>
        </trans-unit>
        <trans-unit id="8008407990a4be341211e8be036085a004b45e43" translate="yes" xml:space="preserve">
          <source>The main error message, &amp;ldquo;mismatched types,&amp;rdquo; reveals the core issue with this code. The definition of the function &lt;code&gt;plus_one&lt;/code&gt; says that it will return an &lt;code&gt;i32&lt;/code&gt;, but statements don&amp;rsquo;t evaluate to a value, which is expressed by &lt;code&gt;()&lt;/code&gt;, an empty tuple. Therefore, nothing is returned, which contradicts the function definition and results in an error. In this output, Rust provides a message to possibly help rectify this issue: it suggests removing the semicolon, which would fix the error.</source>
          <target state="translated">기본 오류 메시지 인 &quot;일치하지 않는 유형&quot;은이 코드의 핵심 문제를 나타냅니다. &lt;code&gt;plus_one&lt;/code&gt; 함수의 정의에 따르면 &lt;code&gt;i32&lt;/code&gt; 를 반환 하지만 명령문은 빈 튜플 &lt;code&gt;()&lt;/code&gt; 로 표현되는 값으로 평가되지 않습니다 . 따라서 아무것도 반환되지 않으므로 함수 정의와 모순되어 오류가 발생합니다. 이 출력에서 ​​Rust는이 문제를 해결하는 데 도움이되는 메시지를 제공합니다. 세미콜론을 제거하면 오류가 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="573ea76510aaa810e82bed4691dcc0e4c2771be9" translate="yes" xml:space="preserve">
          <source>The main place you'll see &lt;code&gt;!&lt;/code&gt; used explicitly is in generic code. Consider the &lt;a href=&quot;str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; trait:</source>
          <target state="translated">당신이 볼 주요 장소 &lt;code&gt;!&lt;/code&gt; 명시 적으로 사용되는 것은 일반 코드입니다. &lt;a href=&quot;str/trait.fromstr&quot;&gt; &lt;code&gt;FromStr&lt;/code&gt; &lt;/a&gt; 특성을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="3347fce894ee36b7a76776d17f6b05d7ee4e0c6f" translate="yes" xml:space="preserve">
          <source>The main thread will wait for the spawned thread to finish and then run its &lt;code&gt;for&lt;/code&gt; loop, so the output won&amp;rsquo;t be interleaved anymore, as shown here:</source>
          <target state="translated">메인 스레드는 스폰 된 스레드가 완료 될 때까지 기다린 다음 &lt;code&gt;for&lt;/code&gt; 루프 를 실행하므로 다음과 같이 출력이 더 이상 인터리브되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7af4b9befadab1a133dab8d7948b44dbc8d708d" translate="yes" xml:space="preserve">
          <source>The main thread will wait with a timeout on the condvar and then leave once the boolean has been updated and notified.</source>
          <target state="translated">메인 스레드는 condvar에서 시간 초과로 기다린 다음 부울이 업데이트되고 알림을 받으면 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="2f4d9785a094ac7050147e12df1b0f82f8cae6fe" translate="yes" xml:space="preserve">
          <source>The main use case for type synonyms is to reduce repetition. For example, we might have a lengthy type like this:</source>
          <target state="translated">유형 동의어의 주요 사용 사례는 반복을 줄이는 것입니다. 예를 들어 다음과 같은 긴 유형이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1aa73c2c8bcfa6f25fb308f2154aee4987ca459" translate="yes" xml:space="preserve">
          <source>The main way to use Boolean values is through conditionals, such as an &lt;code&gt;if&lt;/code&gt; expression. We&amp;rsquo;ll cover how &lt;code&gt;if&lt;/code&gt; expressions work in Rust in the &lt;a href=&quot;ch03-05-control-flow#control-flow&quot;&gt;&amp;ldquo;Control Flow&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">부울 값을 사용하는 주요 방법은 &lt;code&gt;if&lt;/code&gt; 표현식 과 같은 조건을 통하는 것 입니다. 우리는 어떻게 다룰 &lt;code&gt;if&lt;/code&gt; 표현이 녹에서 일 &lt;a href=&quot;ch03-05-control-flow#control-flow&quot;&gt;&quot;제어 흐름&quot;&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="67f97a592dc5c37dc58d2c3fd741d8753b33f60e" translate="yes" xml:space="preserve">
          <source>The mapping to &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;ErrorKind&lt;/code&gt;&lt;/a&gt;s is not part of the compatibility contract of the function, especially the &lt;a href=&quot;../io/enum.errorkind#variant.Other&quot;&gt;&lt;code&gt;Other&lt;/code&gt;&lt;/a&gt; kind might change to more specific kinds in the future.</source>
          <target state="translated">&lt;a href=&quot;../io/enum.errorkind&quot;&gt; &lt;code&gt;ErrorKind&lt;/code&gt; 에&lt;/a&gt; 대한 매핑 은 함수의 호환성 계약의 일부가 아닙니다. 특히 &lt;a href=&quot;../io/enum.errorkind#variant.Other&quot;&gt; &lt;code&gt;Other&lt;/code&gt; &lt;/a&gt; 유형은 향후 더 구체적인 유형으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8fda3a6ce0d45625dd9cd044a1a98a742c97014" translate="yes" xml:space="preserve">
          <source>The match condition states that the arm only matches if the value of &lt;code&gt;x&lt;/code&gt; is equal to &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;, or &lt;code&gt;6&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; if &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. When this code runs, the pattern of the first arm matches because &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt;, but the match guard &lt;code&gt;if y&lt;/code&gt; is false, so the first arm is not chosen. The code moves on to the second arm, which does match, and this program prints &lt;code&gt;no&lt;/code&gt;. The reason is that the &lt;code&gt;if&lt;/code&gt; condition applies to the whole pattern &lt;code&gt;4 | 5 | 6&lt;/code&gt;, not only to the last value &lt;code&gt;6&lt;/code&gt;. In other words, the precedence of a match guard in relation to a pattern behaves like this:</source>
          <target state="translated">값 경우 아암에만 일치하는 정합 조건 상태 &lt;code&gt;x&lt;/code&gt; 같은지 &lt;code&gt;4&lt;/code&gt; , &lt;code&gt;5&lt;/code&gt; 또는 &lt;code&gt;6&lt;/code&gt; &lt;em&gt;과&lt;/em&gt; 만약 &lt;code&gt;y&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; . 이 코드가 실행될 때 &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;4&lt;/code&gt; 이므로 첫 번째 팔의 패턴이 일치 하지만 &lt;code&gt;if y&lt;/code&gt; 가 false 인 경우 일치 가드 가 있으므로 첫 번째 팔이 선택되지 않습니다. 코드가 일치하는 두 번째 팔로 이동하면이 프로그램은 &lt;code&gt;no&lt;/code&gt; 를 인쇄합니다 . 그 이유는 &lt;code&gt;if&lt;/code&gt; 조건이 전체 패턴에 적용되기 때문입니다. &lt;code&gt;4 | 5 | 6&lt;/code&gt; 마지막 값뿐만 아니라 6 &lt;code&gt;6&lt;/code&gt; . 다시 말해, 패턴과 관련하여 매치 가드의 우선 순위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6477b3c15cf1efd2f96aba3a277d7e0dd00d128c" translate="yes" xml:space="preserve">
          <source>The match guard &lt;code&gt;if n == y&lt;/code&gt; is not a pattern and therefore doesn&amp;rsquo;t introduce new variables. This &lt;code&gt;y&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; the outer &lt;code&gt;y&lt;/code&gt; rather than a new shadowed &lt;code&gt;y&lt;/code&gt;, and we can look for a value that has the same value as the outer &lt;code&gt;y&lt;/code&gt; by comparing &lt;code&gt;n&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;if n == y&lt;/code&gt; 매치 가드 는 패턴이 아니므로 새 변수를 도입하지 않습니다. 이 &lt;code&gt;y&lt;/code&gt; &lt;em&gt;이다&lt;/em&gt; 외측 &lt;code&gt;y&lt;/code&gt; 보다 새로운 숨겨진 &lt;code&gt;y&lt;/code&gt; , 우리는 외부와 동일한 값을 가지는 값을 볼 수있다 &lt;code&gt;y&lt;/code&gt; 과 비교하여 &lt;code&gt;n&lt;/code&gt; 에 &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a68bad7489889370013d2c1b380ae26eafd0a34" translate="yes" xml:space="preserve">
          <source>The matched value was assigned in a match guard.</source>
          <target state="translated">일치 된 값은 매치 가드에서 할당되었습니다.</target>
        </trans-unit>
        <trans-unit id="da4a7cee97aca95b9c65ea2bcda5404ae104d4f6" translate="yes" xml:space="preserve">
          <source>The maximum duration.</source>
          <target state="translated">최대 기간입니다.</target>
        </trans-unit>
        <trans-unit id="639334ee92fbc7d55384c7ec82527ac8487a080f" translate="yes" xml:space="preserve">
          <source>The maximum value of an enum was reached, so it cannot be automatically set in the next enum value.</source>
          <target state="translated">열거 형의 최대 값에 도달 했으므로 다음 열거 형 값에서 자동으로 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="444f3162cb088de418eba38f4a421be7235eea6f" translate="yes" xml:space="preserve">
          <source>The maximum value of an enum was reached, so it cannot be automatically set in the next enum value. Erroneous code example:</source>
          <target state="translated">열거 형의 최대 값에 도달하여 다음 열거 형 값에서 자동으로 설정할 수 없습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="69d28668979329993270aea55163f780c2136684" translate="yes" xml:space="preserve">
          <source>The memory allocator returned an error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f691ffd885b1cdd7c3aced4e660ea6b5f2bc5114" translate="yes" xml:space="preserve">
          <source>The memory at &lt;code&gt;buf&lt;/code&gt; needs to have been previously allocated by the same allocator the standard library uses, with a required alignment of exactly 1.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 의 메모리 는 표준 라이브러리가 사용하는 동일한 할당 자에 의해 정확히 1의 필수 정렬로 이전에 할당되어야합니다.</target>
        </trans-unit>
        <trans-unit id="297bebe1d80f3b348c7c8e6094a67afc0f518766" translate="yes" xml:space="preserve">
          <source>The memory at &lt;code&gt;ptr&lt;/code&gt; needs to have been previously allocated by the same allocator the standard library uses.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 의 메모리 는 표준 라이브러리가 사용하는 동일한 할당 자에 의해 이전에 할당되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="533d683a4cce37c267e983c916aea2694b115c42" translate="yes" xml:space="preserve">
          <source>The memory block will contain the following contents after a successful call to &lt;code&gt;grow_zeroed&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f4c6be6867180c56169b0ceb625f117dffee9cb" translate="yes" xml:space="preserve">
          <source>The memory layout of a &lt;code&gt;struct&lt;/code&gt; is undefined by default to allow for compiler optimizations like field reordering, but it can be fixed with the &lt;a href=&quot;../type-layout#representations&quot;&gt;&lt;code&gt;repr&lt;/code&gt; attribute&lt;/a&gt;. In either case, fields may be given in any order in a corresponding struct &lt;em&gt;expression&lt;/em&gt;; the resulting &lt;code&gt;struct&lt;/code&gt; value will always have the same memory layout.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 의 메모리 레이아웃은 기본적으로 필드 재정렬과 같은 컴파일러 최적화를 허용하도록 정의되어 있지 않지만 &lt;a href=&quot;../type-layout#representations&quot;&gt; &lt;code&gt;repr&lt;/code&gt; 속성&lt;/a&gt; 으로 수정할 수 있습니다 . 어느 경우 든, 필드는 대응하는 구조체 &lt;em&gt;표현&lt;/em&gt; 에서 임의의 순서로 주어질 수있다 ; 결과 &lt;code&gt;struct&lt;/code&gt; 값은 항상 동일한 메모리 레이아웃을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="613a15d193cb4b5b9d7d2448a0d26f441bad60d3" translate="yes" xml:space="preserve">
          <source>The memory layout of a &lt;code&gt;union&lt;/code&gt; is undefined by default, but the &lt;code&gt;#[repr(...)]&lt;/code&gt; attribute can be used to fix a layout.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 의 메모리 레이아웃은 기본적으로 정의되어 있지 않지만 &lt;code&gt;#[repr(...)]&lt;/code&gt; 속성을 사용하여 레이아웃을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62988640c5b4ea3199910497b4399a06d9aa4bb8" translate="yes" xml:space="preserve">
          <source>The memory must be requested from the memory allocator at runtime.</source>
          <target state="translated">메모리는 런타임에 메모리 할당 자에서 요청해야합니다.</target>
        </trans-unit>
        <trans-unit id="5158117ae58dde222908d602ad3b6cfbc19fbd1b" translate="yes" xml:space="preserve">
          <source>The memory must be requested from the operating system at runtime.</source>
          <target state="translated">런타임시 운영 체제에서 메모리를 요청해야합니다.</target>
        </trans-unit>
        <trans-unit id="5fb7e987a9654eee8114bb60b92e8b3cf5d47151" translate="yes" xml:space="preserve">
          <source>The memory referenced by the returned slice must not be accessed through any other pointer (not derived from the return value) for the duration of lifetime &lt;code&gt;'a&lt;/code&gt;. Both read and write accesses are forbidden.</source>
          <target state="translated">반환 된 슬라이스가 참조하는 메모리는 &lt;code&gt;'a&lt;/code&gt; 수명 기간 동안 다른 포인터 (반환 값에서 파생되지 않음)를 통해 액세스해서는 안됩니다 . 읽기 및 쓰기 액세스가 모두 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="ff115e1f60568ae547418e535b08f2a38631c573" translate="yes" xml:space="preserve">
          <source>The memory referenced by the returned slice must not be mutated for the duration of lifetime &lt;code&gt;'a&lt;/code&gt;, except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;.</source>
          <target state="translated">반환 된 슬라이스가 참조하는 메모리 는 &lt;code&gt;UnsafeCell&lt;/code&gt; 내부를 제외하고는 &lt;code&gt;'a&lt;/code&gt; 수명 기간 동안 변경되지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="6139b94477b7472bd857c001d753b72d8df9f27e" translate="yes" xml:space="preserve">
          <source>The message can be of any (&lt;code&gt;Any + Send&lt;/code&gt;) type, not just strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d782721b766f719dd5b6d817f0d6bb437eb7d6a" translate="yes" xml:space="preserve">
          <source>The message is wrapped in a &lt;code&gt;Box&amp;lt;'static + Any + Send&amp;gt;&lt;/code&gt;, which can be accessed later using &lt;a href=&quot;struct.panicinfo#method.payload&quot;&gt;&lt;code&gt;PanicInfo::payload&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c86a2a43ba3e98f03e1d643c5eb2cb7bce34d7c4" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so counting elements of an iterator with more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">이 방법은 오버플로를 방지하지 않으므로 &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; 요소 보다 많은 반복자의 요소를 계산 하면 잘못된 결과 또는 패닉이 발생합니다. 디버그 어설 션이 활성화되면 패닉이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="177a5c2ea6344ea77e9ae3a6db8fc74469cc253c" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so enumerating more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">이 방법은 오버플로를 방지하지 않으므로 &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; 요소 이상을 열거 하면 잘못된 결과 또는 패닉이 발생합니다. 디버그 어설 션이 활성화되면 패닉이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="3a1826392947e9b9a700c20663562183cfe20bf1" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so enumerating more than &lt;code&gt;usize::MAX&lt;/code&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">이 방법은 오버플로를 방지하지 않으므로 &lt;code&gt;usize::MAX&lt;/code&gt; 요소 이상을 열거 하면 잘못된 결과 또는 패닉이 발생합니다. 디버그 어설 션이 활성화되면 패닉이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="19d8816b84fe470f79cf77755eeb8ee64e555da5" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so if there are more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; non-matching elements, it either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">이 방법은 오버플로를 방지하지 않으므로 &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; 비 일치 요소 보다 많은 요소가 있으면 잘못된 결과 또는 패닉이 발생합니다. 디버그 어설 션이 활성화되면 패닉이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="1be550addda456adee08f228dc9b4f31db12dda4" translate="yes" xml:space="preserve">
          <source>The method will panic if the given step is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">주어진 단계가 &lt;code&gt;0&lt;/code&gt; 이면 메소드가 패닉 상태가됩니다 .</target>
        </trans-unit>
        <trans-unit id="18a6ab41791924ffc3860ab7c005689a5ace692a" translate="yes" xml:space="preserve">
          <source>The minimum alignment of a type.</source>
          <target state="translated">유형의 최소 정렬입니다.</target>
        </trans-unit>
        <trans-unit id="d61a28fc808f2bb8277ab6d2dda14e2b5dc3214d" translate="yes" xml:space="preserve">
          <source>The minimum byte alignment for a memory block of this layout.</source>
          <target state="translated">이 레이아웃의 메모리 블록에 대한 최소 바이트 정렬입니다.</target>
        </trans-unit>
        <trans-unit id="e621ea6ab30e14c7bfa77e4fee05fb852bfe464d" translate="yes" xml:space="preserve">
          <source>The minimum duration.</source>
          <target state="translated">최소 기간입니다.</target>
        </trans-unit>
        <trans-unit id="5b04e5eee8d92581fabe61b454bd932d16d3b4ee" translate="yes" xml:space="preserve">
          <source>The minimum size in bytes for a memory block of this layout.</source>
          <target state="translated">이 레이아웃의 메모리 블록에 대한 최소 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="4650b1470ff8fe4b9a6a554cb10a84ba4229b041" translate="yes" xml:space="preserve">
          <source>The mirror use case of FFI is also done via the &lt;code&gt;extern&lt;/code&gt; keyword:</source>
          <target state="translated">FFI의 미러 사용 사례는 &lt;code&gt;extern&lt;/code&gt; 키워드 를 통해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="a82559d5a04edc93a72fe140de851778ee358fc2" translate="yes" xml:space="preserve">
          <source>The module tree might remind you of the filesystem&amp;rsquo;s directory tree on your computer; this is a very apt comparison! Just like directories in a filesystem, you use modules to organize your code. And just like files in a directory, we need a way to find our modules.</source>
          <target state="translated">모듈 트리는 컴퓨터에서 파일 시스템의 디렉토리 트리를 상기시킬 수 있습니다. 이것은 매우 적절한 비교입니다! 파일 시스템의 디렉토리와 마찬가지로 모듈을 사용하여 코드를 구성합니다. 디렉토리의 파일과 마찬가지로 모듈을 찾는 방법이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ea4c9b3e2b6f858a3799aa18909b3e42f1061d3e" translate="yes" xml:space="preserve">
          <source>The module tree remains the same, and the function calls in &lt;code&gt;eat_at_restaurant&lt;/code&gt; will work without any modification, even though the definitions live in different files. This technique lets you move modules to new files as they grow in size.</source>
          <target state="translated">모듈 트리는 동일하게 유지되며 , 정의가 다른 파일에 존재하더라도 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 의 함수 호출은 수정없이 작동합니다. 이 기술을 사용하면 크기가 커짐에 따라 모듈을 새 파일로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb5cf295cab45b30e8f8d196e49ec369e86db99a" translate="yes" xml:space="preserve">
          <source>The monomorphized version of the code looks like the following. The generic &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is replaced with the specific definitions created by the compiler:</source>
          <target state="translated">코드의 변형 된 버전은 다음과 같습니다. 일반 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 는 컴파일러가 생성 한 특정 정의로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="75cf509b67ca81925881254de671f6530c684e13" translate="yes" xml:space="preserve">
          <source>The more common inherited mutability, where one must have unique access to mutate a value, is one of the key language elements that enables Rust to reason strongly about pointer aliasing, statically preventing crash bugs. Because of that, inherited mutability is preferred, and interior mutability is something of a last resort. Since cell types enable mutation where it would otherwise be disallowed though, there are occasions when interior mutability might be appropriate, or even &lt;em&gt;must&lt;/em&gt; be used, e.g.</source>
          <target state="translated">값을 변경하기 위해 고유 한 액세스 권한을 가져야하는보다 일반적인 상속 된 변경 가능성은 Rust가 포인터 앨리어싱을 강력하게 추론하여 충돌 버그를 정적으로 방지 할 수있게하는 핵심 언어 요소 중 하나입니다. 그 때문에 상속 된 돌연변이가 선호되며 내부 돌연변이는 최후의 수단입니다. 비록 세포 유형이 그렇지 않으면 허용되지 않는 돌연변이를 가능하게하기 때문에, 내부 돌연변이가 적절하거나 심지어 사용 &lt;em&gt;되어야하는&lt;/em&gt; 경우 &lt;em&gt;가&lt;/em&gt; 있다.</target>
        </trans-unit>
        <trans-unit id="22b87181f4af9bcd4494ede540e86fdd7af786b7" translate="yes" xml:space="preserve">
          <source>The most basic pattern in which &lt;code&gt;collect()&lt;/code&gt; is used is to turn one collection into another. You take a collection, call &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; on it, do a bunch of transformations, and then &lt;code&gt;collect()&lt;/code&gt; at the end.</source>
          <target state="translated">&lt;code&gt;collect()&lt;/code&gt; 가 사용 되는 가장 기본적인 패턴은 한 컬렉션을 다른 컬렉션으로 바꾸는 것입니다. 컬렉션을 가져 와서 &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; 를 호출 하고 많은 변환을 수행 한 다음 마지막에 &lt;code&gt;collect()&lt;/code&gt; 를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8acfa5660545764d445a8a9080882c9972414cad" translate="yes" xml:space="preserve">
          <source>The most basic usage of the keyword is &lt;code&gt;use path::to::item;&lt;/code&gt;, though a number of convenient shortcuts are supported:</source>
          <target state="translated">키워드의 가장 기본적인 사용법은 &lt;code&gt;use path::to::item;&lt;/code&gt; , 여러 가지 편리한 단축키가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="524cfe2dc48693915271c90c3e4b7d15d2163d53" translate="yes" xml:space="preserve">
          <source>The most likely source of this error is using angle-bracket notation without wrapping the function argument type into a tuple, for example:</source>
          <target state="translated">이 오류의 원인은 다음과 같이 함수 인수 유형을 튜플로 래핑하지 않고 꺾쇠 괄호 표기법을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f1fae4bef53f01c296ad8cf52cd2f776bcb2545a" translate="yes" xml:space="preserve">
          <source>The most straightforward smart pointer is a &lt;em&gt;box&lt;/em&gt;, whose type is written &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. Boxes allow you to store data on the heap rather than the stack. What remains on the stack is the pointer to the heap data. Refer to Chapter 4 to review the difference between the stack and the heap.</source>
          <target state="translated">가장 간단한 스마트 포인터는이다 &lt;em&gt;상자&lt;/em&gt; 유형이 기록, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; . 상자를 사용하면 스택이 아닌 힙에 데이터를 저장할 수 있습니다. 스택에 남아있는 것은 힙 데이터에 대한 포인터입니다. 스택과 힙의 차이점을 검토하려면 4 장을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c84503d5e594d47f23b7b930df844dc25ee59200" translate="yes" xml:space="preserve">
          <source>The most surprising behavior occurs when &quot;the same&quot; file is reachable via multiple paths in the module system (usually using the &lt;code&gt;#[path = &quot;...&quot;]&lt;/code&gt; attribute or similar), which can cause what appears to be identical code to return differing values from this function.</source>
          <target state="translated">가장 놀라운 동작은 모듈 시스템의 여러 경로를 통해 &quot;동일한&quot;파일에 도달 할 수있을 때 발생하며 (일반적으로 &lt;code&gt;#[path = &quot;...&quot;]&lt;/code&gt; 속성 또는 이와 유사한 속성을 사용하여) 동일한 코드로 보이는 것을 반환 할 수 있습니다. 이 기능과 다른 값.</target>
        </trans-unit>
        <trans-unit id="224b0446b4293b35c3feb8b386382ff2882bd862" translate="yes" xml:space="preserve">
          <source>The most widely used form of macros in Rust is &lt;em&gt;declarative macros&lt;/em&gt;. These are also sometimes referred to as &amp;ldquo;macros by example,&amp;rdquo; &amp;ldquo;&lt;code&gt;macro_rules!&lt;/code&gt; macros,&amp;rdquo; or just plain &amp;ldquo;macros.&amp;rdquo; At their core, declarative macros allow you to write something similar to a Rust &lt;code&gt;match&lt;/code&gt; expression. As discussed in Chapter 6, &lt;code&gt;match&lt;/code&gt; expressions are control structures that take an expression, compare the resulting value of the expression to patterns, and then run the code associated with the matching pattern. Macros also compare a value to patterns that are associated with particular code: in this situation, the value is the literal Rust source code passed to the macro; the patterns are compared with the structure of that source code; and the code associated with each pattern, when matched, replaces the code passed to the macro. This all happens during compilation.</source>
          <target state="translated">Rust에서 가장 널리 사용되는 매크로는 &lt;em&gt;선언적 매크로&lt;/em&gt; 입니다. 이것들은 때때로&amp;ldquo;매크로 예&amp;rdquo;,&amp;ldquo; &lt;code&gt;macro_rules!&lt;/code&gt; 매크로 '또는 일반'매크로 ' 핵심적으로 선언적 매크로를 사용하면 Rust &lt;code&gt;match&lt;/code&gt; 식과 비슷한 것을 작성할 수 있습니다 . 제 6 장에서 설명하고있는 바와 같이 &lt;code&gt;match&lt;/code&gt; 식은 식을 가져오고 식의 결과 값을 패턴과 비교 한 다음 일치하는 패턴과 관련된 코드를 실행하는 제어 구조입니다. 매크로는 또한 특정 코드와 관련된 패턴과 값을 비교합니다.이 상황에서 값은 매크로에 전달 된 리터럴 Rust 소스 코드입니다. 패턴은 해당 소스 코드의 구조와 비교됩니다. 각 패턴과 관련된 코드는 일치 될 때 매크로에 전달 된 코드를 대체합니다. 이 모든 것은 컴파일 중에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5c8119cbdd49364e9c5037e1b8a03abc1bccdb46" translate="yes" xml:space="preserve">
          <source>The motivation for this design is twofold:</source>
          <target state="translated">이 디자인의 동기는 두 가지입니다.</target>
        </trans-unit>
        <trans-unit id="6fd4e131dbce656fa77aa6dbacb12fee04853072" translate="yes" xml:space="preserve">
          <source>The multi-argument form of this macro panics with a string and has the &lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; syntax for building a string.</source>
          <target state="translated">이 매크로의 다중 인수 형식은 문자열로 패닉되며 &lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;문자열 작성 구문</target>
        </trans-unit>
        <trans-unit id="ff7a3f839c4dac34de65c2bfcbc13d6c2f460e6c" translate="yes" xml:space="preserve">
          <source>The multiplication assignment operator &lt;code&gt;*=&lt;/code&gt;.</source>
          <target state="translated">곱셈 대입 연산자 &lt;code&gt;*=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="945e202ccc3f817f464a16a52710aeff055613cc" translate="yes" xml:space="preserve">
          <source>The multiplication operator &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">곱셈 연산자 &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="395bf55779b3f4b37031c67eb2f13567f6e766a4" translate="yes" xml:space="preserve">
          <source>The mutability of a pointer does not change its size. As such, &lt;code&gt;&amp;amp;T&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; have the same size. Likewise for &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;.</source>
          <target state="translated">포인터의 변경 가능성은 크기를 변경하지 않습니다. 따라서 &lt;code&gt;&amp;amp;T&lt;/code&gt; 와 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 의 크기는 같습니다. &lt;code&gt;*const T&lt;/code&gt; 및 &lt;code&gt;*mut T&lt;/code&gt; 도 마찬가지입니다 .</target>
        </trans-unit>
        <trans-unit id="f42a8b27f0c72155ef0f3b14d7be6cafaaf62841" translate="yes" xml:space="preserve">
          <source>The mutable slice yields mutable references to the elements:</source>
          <target state="translated">변경 가능한 슬라이스는 요소에 대한 변경 가능한 참조를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3c3cbd1ab17a10688ead5cf4d56f2dfc9e512608" translate="yes" xml:space="preserve">
          <source>The mutexes in this module implement a strategy called &quot;poisoning&quot; where a mutex is considered poisoned whenever a thread panics while holding the mutex. Once a mutex is poisoned, all other threads are unable to access the data by default as it is likely tainted (some invariant is not being upheld).</source>
          <target state="translated">이 모듈의 뮤텍스는 뮤텍스를 잡고있는 동안 스레드 패닉이 발생할 때마다 뮤텍스가 중독 된 것으로 간주되는 &quot;poisoning&quot;전략을 구현합니다. 일단 뮤텍스가 감염되면 다른 모든 스레드는 기본적으로 데이터가 오염되었을 가능성이 있으므로 데이터에 액세스 할 수 없습니다 (일부 불변은 유지되지 않음).</target>
        </trans-unit>
        <trans-unit id="d8b50303b0747d7e3abc95898503b5bde7711980" translate="yes" xml:space="preserve">
          <source>The name chosen for an external crate conflicts with another external crate that has been imported into the current module.</source>
          <target state="translated">외부 상자에 선택된 이름이 현재 모듈로 가져온 다른 외부 상자와 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="d94375d609f70bc0ddb2da1f070fd5b681c30cc1" translate="yes" xml:space="preserve">
          <source>The name for an item declaration conflicts with an external crate's name.</source>
          <target state="translated">품목 신고의 이름이 외부 상자의 이름과 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="286d59804da04e407ec36eb2be39e9e0c7ff3343" translate="yes" xml:space="preserve">
          <source>The name must not contain null bytes (&lt;code&gt;\0&lt;/code&gt;).</source>
          <target state="translated">이름에는 널 바이트 ( &lt;code&gt;\0&lt;/code&gt; )가 포함되지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="6584162ced4a99e7d4548e6dfca0a1b5adbdbd8e" translate="yes" xml:space="preserve">
          <source>The need for synchronization</source>
          <target state="translated">동기화의 필요성</target>
        </trans-unit>
        <trans-unit id="9491a60a88ee503552e1418886a35e38dd1f594f" translate="yes" xml:space="preserve">
          <source>The need for this type arises from the fact that:</source>
          <target state="translated">이 유형의 필요성은 다음과 같은 사실에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="3e795b9b16f895fca00c98b1df11fc0d63c7301f" translate="yes" xml:space="preserve">
          <source>The network operation failed because it was not connected yet.</source>
          <target state="translated">아직 연결되지 않았기 때문에 네트워크 작업이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="7c5a2cc50c7976456054417007ed08f73bfd9e80" translate="yes" xml:space="preserve">
          <source>The never type &lt;code&gt;!&lt;/code&gt; is a type with no values, representing the result of computations that never complete. Expressions of type &lt;code&gt;!&lt;/code&gt; can be coerced into any other type.</source>
          <target state="translated">절대 타입 &lt;code&gt;!&lt;/code&gt; 완료되지 않은 계산 결과를 나타내는 값이없는 유형입니다. 타입의 표현 &lt;code&gt;!&lt;/code&gt; 다른 유형으로 강요 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2876200ee40ea0a4251130e3bb42070db01f59e5" translate="yes" xml:space="preserve">
          <source>The never type is useful with the &lt;code&gt;panic!&lt;/code&gt; macro as well. Remember the &lt;code&gt;unwrap&lt;/code&gt; function that we call on &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; values to produce a value or panic? Here is its definition:</source>
          <target state="translated">never type은 &lt;code&gt;panic!&lt;/code&gt; 유용합니다 ! 매크로도 마찬가지입니다. 값 또는 패닉을 생성하기 위해 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 값을 호출 하는 &lt;code&gt;unwrap&lt;/code&gt; 기능을 기억 하십니까? 그 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56b6326e5da7a2c1bad08c52fe9675cb30d6fc5f" translate="yes" xml:space="preserve">
          <source>The new test for the case-&lt;em&gt;insensitive&lt;/em&gt; search uses &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; as its query. In the &lt;code&gt;search_case_insensitive&lt;/code&gt; function we&amp;rsquo;re about to add, the query &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; should match the line containing &lt;code&gt;&quot;Rust:&quot;&lt;/code&gt; with a capital R and match the line &lt;code&gt;&quot;Trust me.&quot;&lt;/code&gt; even though both have different casing from the query. This is our failing test, and it will fail to compile because we haven&amp;rsquo;t yet defined the &lt;code&gt;search_case_insensitive&lt;/code&gt; function. Feel free to add a skeleton implementation that always returns an empty vector, similar to the way we did for the &lt;code&gt;search&lt;/code&gt; function in Listing 12-16 to see the test compile and fail.</source>
          <target state="translated">대소 문자를 &lt;em&gt;구분하지 않는&lt;/em&gt; 검색에 대한 새로운 테스트 는 &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; 를 쿼리로 사용합니다. 우리가 추가 하려는 &lt;code&gt;search_case_insensitive&lt;/code&gt; 함수에서 쿼리 &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; 는 &lt;code&gt;&quot;Rust:&quot;&lt;/code&gt; 를 포함하는 행 과 대문자 R을 일치시키고 &lt;code&gt;&quot;Trust me.&quot;&lt;/code&gt; 와 일치해야합니다 . 둘 다 쿼리와 다른 케이싱을 가지고 있지만. 이것은 실패한 테스트이며 &lt;code&gt;search_case_insensitive&lt;/code&gt; 함수를 아직 정의하지 않았으므로 컴파일에 실패 합니다. Listing 12-16 의 &lt;code&gt;search&lt;/code&gt; 함수에서 테스트 컴파일 및 실패를 확인하는 방식과 유사하게 항상 빈 벡터를 반환하는 스켈레톤 구현을 자유롭게 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="9a3696a40107bd6d0870f3607ce5d6e5073b6d6b" translate="yes" xml:space="preserve">
          <source>The newtype pattern is useful for tasks beyond those we&amp;rsquo;ve discussed so far, including statically enforcing that values are never confused and indicating the units of a value. You saw an example of using newtypes to indicate units in Listing 19-15: recall that the &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt; structs wrapped &lt;code&gt;u32&lt;/code&gt; values in a newtype. If we wrote a function with a parameter of type &lt;code&gt;Millimeters&lt;/code&gt;, we couldn&amp;rsquo;t compile a program that accidentally tried to call that function with a value of type &lt;code&gt;Meters&lt;/code&gt; or a plain &lt;code&gt;u32&lt;/code&gt;.</source>
          <target state="translated">새 유형 패턴은 값이 혼동되지 않도록 정적으로 시행하고 값의 단위를 나타내는 것을 포함하여 지금까지 설명한 작업 이외의 작업에 유용합니다. Listing 19-15에서 단위를 나타 내기 위해 newtypes를 사용하는 예제를 보았다 : &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt; 는 &lt;code&gt;u32&lt;/code&gt; 값을 새로운 타입으로 감싼다 는 것을 상기하자 . 만약 우리가 &lt;code&gt;Millimeters&lt;/code&gt; 타입의 파라미터를 가진 함수를 작성했다면 우연히 &lt;code&gt;Meters&lt;/code&gt; 타입 이나 평범한 &lt;code&gt;u32&lt;/code&gt; 타입의 함수를 호출하려고 시도한 프로그램을 컴파일 할 수 없었습니다 .</target>
        </trans-unit>
        <trans-unit id="b591edfc8b3d018e277499297a4856c76a36dc2a" translate="yes" xml:space="preserve">
          <source>The next four lines set the configuration information Cargo needs to compile your program: the name, the version, who wrote it, and the edition of Rust to use. Cargo gets your name and email information from your environment, so if that information is not correct, fix the information now and then save the file. We&amp;rsquo;ll talk about the &lt;code&gt;edition&lt;/code&gt; key in Appendix E.</source>
          <target state="translated">다음 네 줄은 카고가 프로그램을 컴파일하는 데 필요한 구성 정보, 이름, 버전, 작성한 사람 및 사용할 Rust 버전을 설정합니다. 화물은 환경에서 이름과 이메일 정보를 얻으므로 해당 정보가 정확하지 않은 경우 지금 정보를 수정 한 다음 파일을 저장하십시오. 부록 E 의 &lt;code&gt;edition&lt;/code&gt; 키에 대해 이야기하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="6a7a2603b03740bcea191aea3d000fd9f48ffbb9" translate="yes" xml:space="preserve">
          <source>The next logical question is which style you should choose in your own code and why: the original implementation in Listing 13-28 or the version using iterators in Listing 13-29. Most Rust programmers prefer to use the iterator style. It&amp;rsquo;s a bit tougher to get the hang of at first, but once you get a feel for the various iterator adaptors and what they do, iterators can be easier to understand. Instead of fiddling with the various bits of looping and building new vectors, the code focuses on the high-level objective of the loop. This abstracts away some of the commonplace code so it&amp;rsquo;s easier to see the concepts that are unique to this code, such as the filtering condition each element in the iterator must pass.</source>
          <target state="translated">다음 논리적 인 질문은 자신의 코드에서 어떤 스타일을 선택해야하며 그 이유는 Listing 13-28의 원래 구현 또는 Listing 13-29의 반복자를 사용하는 버전이다. 대부분의 Rust 프로그래머는 반복자 스타일을 선호합니다. 처음에는 다루기가 더 힘들지만 다양한 반복기 어댑터와 그 기능에 대한 느낌을 얻으면 반복자를 이해하기가 더 쉬울 수 있습니다. 코드는 다양한 비트 반복 및 새로운 벡터 생성 대신에 루프의 높은 수준의 목표에 중점을 둡니다. 이것은 일반적인 코드 중 일부를 추상화하여 이터레이터의 각 요소가 통과해야하는 필터링 조건과 같이이 코드에 고유 한 개념을보다 쉽게 ​​볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57f6548988daa34617ffdf2e9ca86d7e443df79f" translate="yes" xml:space="preserve">
          <source>The next note line tells us that we can set the &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; environment variable to get a backtrace of exactly what happened to cause the error. A &lt;em&gt;backtrace&lt;/em&gt; is a list of all the functions that have been called to get to this point. Backtraces in Rust work as they do in other languages: the key to reading the backtrace is to start from the top and read until you see files you wrote. That&amp;rsquo;s the spot where the problem originated. The lines above the lines mentioning your files are code that your code called; the lines below are code that called your code. These lines might include core Rust code, standard library code, or crates that you&amp;rsquo;re using. Let&amp;rsquo;s try getting a backtrace by setting the &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; environment variable to any value except 0. Listing 9-2 shows output similar to what you&amp;rsquo;ll see.</source>
          <target state="translated">다음 노트 라인은 &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; 환경 변수를 설정 하여 오류를 일으킨 정확한 원인의 역 추적을 얻을 수 있음을 알려줍니다 . &lt;em&gt;역 추적은&lt;/em&gt; 이 지점에 도착하기 위해 호출 된 모든 기능의 목록입니다. Rust의 역 추적은 다른 언어와 마찬가지로 작동합니다. 역 추적을 읽는 열쇠는 위에서부터 시작하여 작성한 파일을 볼 때까지 읽는 것입니다. 그것이 문제가 시작된 지점입니다. 파일을 언급하는 행 위의 행은 코드에서 호출 한 코드입니다. 아래 줄은 코드라는 코드입니다. 이 줄에는 핵심 Rust 코드, 표준 라이브러리 코드 또는 사용중인 상자가 포함될 수 있습니다. &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; 를 설정하여 역 추적을 시도해 봅시다. 환경 변수는 0을 제외한 모든 값으로 설정합니다. 목록 9-2는 표시되는 것과 유사한 출력을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="771993487043dfd3c7aa5a2390e7d9f0063dbedb" translate="yes" xml:space="preserve">
          <source>The next part of the code, &lt;code&gt;.read_line(&amp;amp;mut guess)&lt;/code&gt;, calls the &lt;a href=&quot;../std/io/struct.stdin#method.read_line&quot;&gt;&lt;code&gt;read_line&lt;/code&gt;&lt;/a&gt; method on the standard input handle to get input from the user. We&amp;rsquo;re also passing one argument to &lt;code&gt;read_line&lt;/code&gt;: &lt;code&gt;&amp;amp;mut guess&lt;/code&gt;.</source>
          <target state="translated">코드의 다음 부분 인 &lt;code&gt;.read_line(&amp;amp;mut guess)&lt;/code&gt; 는 표준 입력 핸들 에서 &lt;a href=&quot;../std/io/struct.stdin#method.read_line&quot;&gt; &lt;code&gt;read_line&lt;/code&gt; &lt;/a&gt; 메서드를 호출 하여 사용자로부터 입력을받습니다. 또한 &lt;code&gt;read_line&lt;/code&gt; 에 인수 하나를 전달하고 있습니다 : &lt;code&gt;&amp;amp;mut guess&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f3a0383282eca508bd91153f03681dc6f1973f4" translate="yes" xml:space="preserve">
          <source>The next part of the request line is &lt;em&gt;/&lt;/em&gt;, which indicates the &lt;em&gt;Uniform Resource Identifier&lt;/em&gt;&lt;em&gt;(URI)&lt;/em&gt; the client is requesting: a URI is almost, but not quite, the same as a &lt;em&gt;Uniform Resource Locator&lt;/em&gt;&lt;em&gt;(URL)&lt;/em&gt;. The difference between URIs and URLs isn&amp;rsquo;t important for our purposes in this chapter, but the HTTP spec uses the term URI, so we can just mentally substitute URL for URI here.</source>
          <target state="translated">요청 라인의 다음 부분은 &lt;em&gt;/입니다&lt;/em&gt; . 이는 클라이언트가 요청하는 &lt;em&gt;URI ( &lt;/em&gt;&lt;em&gt;Uniform Resource Identifier)&lt;/em&gt; 를 나타냅니다 . URI는 &lt;em&gt;URL ( &lt;/em&gt;&lt;em&gt;Uniform Resource Locator)&lt;/em&gt; 과 거의 동일하지만 완전히 동일하지는 않습니다 . URI와 URL의 차이는이 장에서 우리의 목적에 중요하지 않지만 HTTP 사양은 URI라는 용어를 사용하므로 여기서 URL을 정신적으로 대체 할 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="504232041214e8dae75346e3d17c4c0bf4814b9b" translate="yes" xml:space="preserve">
          <source>The next part of the test output, which starts with &lt;code&gt;Doc-tests adder&lt;/code&gt;, is for the results of any documentation tests. We don&amp;rsquo;t have any documentation tests yet, but Rust can compile any code examples that appear in our API documentation. This feature helps us keep our docs and our code in sync! We&amp;rsquo;ll discuss how to write documentation tests in the &lt;a href=&quot;ch14-02-publishing-to-crates-io#documentation-comments-as-tests&quot;&gt;&amp;ldquo;Documentation Comments as Tests&amp;rdquo;&lt;/a&gt; section of Chapter 14. For now, we&amp;rsquo;ll ignore the &lt;code&gt;Doc-tests&lt;/code&gt; output.</source>
          <target state="translated">&lt;code&gt;Doc-tests adder&lt;/code&gt; 로 시작하는 테스트 출력의 다음 부분 은 모든 문서 테스트 결과입니다. 아직 문서화 테스트는 없지만 Rust는 API 문서에 나오는 코드 예제를 컴파일 할 수 있습니다. 이 기능은 문서와 코드를 동기화하는 데 도움이됩니다! 14 장의 &lt;a href=&quot;ch14-02-publishing-to-crates-io#documentation-comments-as-tests&quot;&gt;&quot;문서로 테스트 주석&quot;&lt;/a&gt; 섹션 에서 문서 테스트를 작성하는 방법에 대해 설명합니다 . 지금은 &lt;code&gt;Doc-tests&lt;/code&gt; 출력을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="1ac4585430b879637fa9bf73df289a63ff5c8c8c" translate="yes" xml:space="preserve">
          <source>The next step is to define the procedural macro. At the time of this writing, procedural macros need to be in their own crate. Eventually, this restriction might be lifted. The convention for structuring crates and macro crates is as follows: for a crate named &lt;code&gt;foo&lt;/code&gt;, a custom derive procedural macro crate is called &lt;code&gt;foo_derive&lt;/code&gt;. Let&amp;rsquo;s start a new crate called &lt;code&gt;hello_macro_derive&lt;/code&gt; inside our &lt;code&gt;hello_macro&lt;/code&gt; project:</source>
          <target state="translated">다음 단계는 절차 적 매크로를 정의하는 것입니다. 이 글을 쓰는 시점에서 절차 적 매크로는 자체 상자에 있어야합니다. 결국이 제한이 해제 될 수 있습니다. 크레이트와 매크로 크레이트를 구성하는 규칙은 다음과 같습니다. &lt;code&gt;foo&lt;/code&gt; 라는 상자의 경우, 사용자 지정 파생 절차 매크로 크레이트를 &lt;code&gt;foo_derive&lt;/code&gt; 라고 합니다 . 의 새로운 상자라고 시작하자 &lt;code&gt;hello_macro_derive&lt;/code&gt; 우리의 내부 &lt;code&gt;hello_macro&lt;/code&gt; 프로젝트를 :</target>
        </trans-unit>
        <trans-unit id="86c376c4d2f9126074dd6023a007174609449704" translate="yes" xml:space="preserve">
          <source>The next time you run &lt;code&gt;cargo build&lt;/code&gt;, Cargo will update the registry of crates available and reevaluate your &lt;code&gt;rand&lt;/code&gt; requirements according to the new version you have specified.</source>
          <target state="translated">다음에 &lt;code&gt;cargo build&lt;/code&gt; 를 실행하면 Cargo는 사용 가능한 상자의 레지스트리를 업데이트하고 지정한 새 버전에 따라 &lt;code&gt;rand&lt;/code&gt; 요구 사항을 재평가 합니다.</target>
        </trans-unit>
        <trans-unit id="14f1a8115e3ecc473c296ccb90a19424fd7f3781" translate="yes" xml:space="preserve">
          <source>The nightly feature &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/language-features/arbitrary-self-types.html&quot;&gt;Arbitrary self types&lt;/a&gt; extends the accepted set of receiver types to also include any type that can dereference to &lt;code&gt;Self&lt;/code&gt;:</source>
          <target state="translated">야간 기능인 &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/language-features/arbitrary-self-types.html&quot;&gt;임의 자체 유형&lt;/a&gt; 은 수용된 수신자 유형 집합을 확장하여 &lt;code&gt;Self&lt;/code&gt; 를 역 참조 할 수있는 모든 유형도 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="b3e15e37e03d384e681f27ce15aeb9d3bb4095a8" translate="yes" xml:space="preserve">
          <source>The node that was removed is returned as a new &lt;code&gt;LinkedList&lt;/code&gt; containing only this node. The cursor is moved to point to the next element in the current &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="145ccdcfae9c0bd6f7e5de42ea443500c786c639" translate="yes" xml:space="preserve">
          <source>The nominal type is called the &lt;em&gt;implementing type&lt;/em&gt; and the associable items are the &lt;em&gt;associated items&lt;/em&gt; to the implementing type.</source>
          <target state="translated">공칭 유형을 &lt;em&gt;구현 유형&lt;/em&gt; 이라고 하며 &lt;em&gt;연관 가능한 항목&lt;/em&gt; 은 구현 유형 &lt;em&gt;과 연관된 항목&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a450d39487d717bce9613fc2953a92eb80b07994" translate="yes" xml:space="preserve">
          <source>The note mentions &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt;, which is a &lt;em&gt;trait&lt;/em&gt;. We&amp;rsquo;ll talk about traits in the next section. For now, this error states that the body of &lt;code&gt;largest&lt;/code&gt; won&amp;rsquo;t work for all possible types that &lt;code&gt;T&lt;/code&gt; could be. Because we want to compare values of type &lt;code&gt;T&lt;/code&gt; in the body, we can only use types whose values can be ordered. To enable comparisons, the standard library has the &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; trait that you can implement on types (see Appendix C for more on this trait). You&amp;rsquo;ll learn how to specify that a generic type has a particular trait in the &lt;a href=&quot;ch10-02-traits#traits-as-parameters&quot;&gt;&amp;ldquo;Traits as Parameters&amp;rdquo;&lt;/a&gt; section, but let&amp;rsquo;s first explore other ways of using generic type parameters.</source>
          <target state="translated">노트는 언급 &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; A는, &lt;em&gt;특성을&lt;/em&gt; . 다음 섹션에서 특성에 대해 이야기하겠습니다. 현재이 오류는 &lt;code&gt;largest&lt;/code&gt; 몸체 가 &lt;code&gt;T&lt;/code&gt; 가 가능한 모든 유형에서 작동하지 않는다는 것을 나타냅니다. 본문에서 유형 &lt;code&gt;T&lt;/code&gt; 의 값을 비교하려고하기 때문에 값을 정렬 할 수있는 유형 만 사용할 수 있습니다. 비교를 가능하게하기 위해 표준 라이브러리에는 유형에 구현할 수 있는 &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; 특성이 있습니다 (이 특성에 대한 자세한 내용은 부록 C 참조). &lt;a href=&quot;ch10-02-traits#traits-as-parameters&quot;&gt;&quot;매개 변수로 처리&quot;&lt;/a&gt; 섹션 에서 일반 형식에 특정 특성이 있음을 지정하는 방법을 배우지 만 먼저 일반 형식 매개 변수를 사용하는 다른 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="39a86e3fff1f9b2a932559db164eca88c47636bb" translate="yes" xml:space="preserve">
          <source>The number of arguments passed to a function must match the number of arguments specified in the function signature.</source>
          <target state="translated">함수에 전달 된 인수의 수는 함수 서명에 지정된 인수의 수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="1499b95664ab693551effdfbf1800a214feda909" translate="yes" xml:space="preserve">
          <source>The number of elements determines the arity of the tuple. A tuple with &lt;code&gt;n&lt;/code&gt; elements is called an &lt;code&gt;n-ary tuple&lt;/code&gt;. For example, a tuple with 2 elements is a 2-ary tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c5008d92a3f283390aac2066e3363b4399cff1" translate="yes" xml:space="preserve">
          <source>The number of elements in an array or slice pattern differed from the number of elements in the array being matched.</source>
          <target state="translated">배열 또는 슬라이스 패턴의 요소 수가 일치하는 배열의 요소 수와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="110544a8e2a789b8a0779516d37df0cd0dba8ad5" translate="yes" xml:space="preserve">
          <source>The number of operands is the arity of the constructed tuple. Tuple expressions without operands produce the unit tuple. For other tuple expressions, the first written operand initializes the 0th element and subsequent operands initializes the next highest element. For example, in the tuple expression &lt;code&gt;('a', 'b', 'c')&lt;/code&gt;, &lt;code&gt;'a'&lt;/code&gt; initializes the value of the 0th element, &lt;code&gt;'b'&lt;/code&gt; the 1st, and &lt;code&gt;'c'&lt;/code&gt; the 2nd.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7202e21ed0c94540f8855e2b43b5089a13dd9685" translate="yes" xml:space="preserve">
          <source>The number of supplied arguments must exactly match the number of defined type parameters.</source>
          <target state="translated">제공된 인수의 수는 정의 된 유형 매개 변수의 수와 정확히 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="1505278c99d9fb45d4f4157fc24b25e9be942498" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum must fit in a &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">경계에있는 오프셋은 주소 공간 &quot;래핑&quot;에 의존 할 수 없습니다. 즉, 무한 정밀도 합계는 &lt;code&gt;usize&lt;/code&gt; 에 맞아야 합니다.</target>
        </trans-unit>
        <trans-unit id="eb0b1c110f4f91ff6afa42a1772303d08fd7f686" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum must fit in a usize.</source>
          <target state="translated">경계에있는 오프셋은 주소 공간 &quot;래핑&quot;에 의존 할 수 없습니다. 즉, 무한 정밀도 합계는 사용에 적합해야합니다.</target>
        </trans-unit>
        <trans-unit id="dec85f2a58c1002de0f34de579c15b9ae5dcc5c3" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum, &lt;strong&gt;in bytes&lt;/strong&gt; must fit in a usize.</source>
          <target state="translated">경계에있는 오프셋은 주소 공간 &quot;래핑&quot;에 의존 할 수 없습니다. 즉, &lt;strong&gt;바이트 단위&lt;/strong&gt; 의 무한 정밀도 합계 는 usize에 맞아야합니다.</target>
        </trans-unit>
        <trans-unit id="b405bb6eb2033937b629bd683503a6e77a48009c" translate="yes" xml:space="preserve">
          <source>The offset is expressed in number of &lt;code&gt;T&lt;/code&gt; elements, and not bytes. The value returned can be used with the &lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;offset_to&lt;/code&gt; methods.</source>
          <target state="translated">오프셋은 바이트가 아닌 &lt;code&gt;T&lt;/code&gt; 요소 수로 표시 됩니다. 반환 된 값은 &lt;code&gt;offset&lt;/code&gt; 또는 &lt;code&gt;offset_to&lt;/code&gt; 메서드 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85ba9b2d34ef606ffd767c5e393592519fd3aa95" translate="yes" xml:space="preserve">
          <source>The offset is expressed in number of &lt;code&gt;T&lt;/code&gt; elements, and not bytes. The value returned can be used with the &lt;code&gt;wrapping_add&lt;/code&gt; method.</source>
          <target state="translated">오프셋은 바이트가 아닌 &lt;code&gt;T&lt;/code&gt; 요소의 수로 표현 됩니다. 반환 된 값은 &lt;code&gt;wrapping_add&lt;/code&gt; 메서드 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1be821c2089924c0d18d107c2c27f16675f5ac1c" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor.</source>
          <target state="translated">오프셋은 파일의 시작에 상대적이므로 현재 커서와 독립적입니다.</target>
        </trans-unit>
        <trans-unit id="084e82e27a45f945c98a971924845d2bbfc865a4" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor. The current cursor &lt;strong&gt;is&lt;/strong&gt; affected by this function, it is set to the end of the read.</source>
          <target state="translated">오프셋은 파일의 시작에 상대적이므로 현재 커서와 독립적입니다. 현재 커서 &lt;strong&gt;는&lt;/strong&gt; 이 기능의 영향을받으며 읽기 끝으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="caf802013d8abd4267e3b977c2a718d4ec2a76b7" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor. The current cursor &lt;strong&gt;is&lt;/strong&gt; affected by this function, it is set to the end of the write.</source>
          <target state="translated">오프셋은 파일의 시작에 상대적이므로 현재 커서와 독립적입니다. 현재 커서 &lt;strong&gt;는&lt;/strong&gt; 이 기능의 영향을받으며 쓰기 끝으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e661f5d3042445d2052a045a18f9872b66b5bc29" translate="yes" xml:space="preserve">
          <source>The old borrow checker has known soundness issues that are basically impossible to fix. The new NLL-based borrow checker is the fix.</source>
          <target state="translated">구 빌려 오기 체커는 기본적으로 고칠 수없는 건전성 문제를 알고 있습니다. 새로운 NLL 기반 차용 검사기가 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="ff9f5d5ca24724dc4d44a56e5f4a630aa34c4326" translate="yes" xml:space="preserve">
          <source>The one exception is the implicit &lt;code&gt;Self&lt;/code&gt; type of a trait. A trait does not have an implicit &lt;code&gt;Sized&lt;/code&gt; bound as this is incompatible with &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;trait object&lt;/a&gt;s where, by definition, the trait needs to work with all possible implementors, and thus could be any size.</source>
          <target state="translated">한 가지 예외는 특성 의 내재적 &lt;code&gt;Self&lt;/code&gt; 유형입니다. 특성은 정의에 따라 특성이 가능한 모든 구현 자와 작동해야하므로 임의의 크기 일 수있는 &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;특성 오브젝트&lt;/a&gt; 와 호환 되지 않기 때문에 암시 적 &lt;code&gt;Sized&lt;/code&gt; 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="251eb8c6b3ec1dc5000df1aa3f1d9769e8fc67e3" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one divides &lt;code&gt;MIN / -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type); this is equivalent to &lt;code&gt;-MIN&lt;/code&gt;, a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">이러한 랩핑이 발생할 수있는 유일한 경우 는 서명 된 유형에서 &lt;code&gt;MIN / -1&lt;/code&gt; 을 나누는 경우입니다 (여기서 &lt;code&gt;MIN&lt;/code&gt; 은 유형 의 음의 최소값 입니다). 이는 유형으로 표현하기에는 너무 큰 양수 값인 &lt;code&gt;-MIN&lt;/code&gt; 과 같습니다 . 이 경우이 함수는 &lt;code&gt;MIN&lt;/code&gt; 자체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="76c053c143fda09cee97a50ed7a5afba7b9b021c" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one negates &lt;code&gt;MIN&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type); this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">이러한 랩핑이 발생할 수있는 유일한 경우 는 서명 된 유형에서 &lt;code&gt;MIN&lt;/code&gt; 을 부정 하는 경우입니다 (여기서 &lt;code&gt;MIN&lt;/code&gt; 은 유형 의 음의 최소값 입니다). 유형에 표현하기에는 너무 큰 양수 값입니다. 이 경우이 함수는 &lt;code&gt;MIN&lt;/code&gt; 자체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4f6de3ab26de46b22b8646658bc86041ba8f3d5e" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one takes the absolute value of the negative minimal value for the type this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">이러한 랩핑이 발생할 수있는 유일한 경우는 유형에 대해 음의 최소값의 절대 값을 취할 때 이것은 유형에 표현하기에는 너무 큰 양의 값입니다. 이 경우이 함수는 &lt;code&gt;MIN&lt;/code&gt; 자체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="45d6aabe4740755ea8f6332847150daa44a43b07" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one takes the absolute value of the negative minimal value for the type; this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">이러한 랩핑이 발생할 수있는 유일한 경우는 유형에 대해 음의 최소값의 절대 값을 취하는 경우입니다. 이것은 유형으로 표현하기에는 너무 큰 양수 값입니다. 이 경우이 함수는 &lt;code&gt;MIN&lt;/code&gt; 자체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="63e8e964be307b9ddc1a920575e78207b9d44077" translate="yes" xml:space="preserve">
          <source>The only difference between Listing 15-7 and Listing 15-6 is that here we set &lt;code&gt;y&lt;/code&gt; to be an instance of a box pointing to a copied value of &lt;code&gt;x&lt;/code&gt; rather than a reference pointing to the value of &lt;code&gt;x&lt;/code&gt;. In the last assertion, we can use the dereference operator to follow the box&amp;rsquo;s pointer in the same way that we did when &lt;code&gt;y&lt;/code&gt; was a reference. Next, we&amp;rsquo;ll explore what is special about &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that enables us to use the dereference operator by defining our own box type.</source>
          <target state="translated">리스팅 15-7 및 15-6리스트 사이의 유일한 차이점은 여기에 설정 인 &lt;code&gt;y&lt;/code&gt; 로 의 복사 값을 가리키는 박스의 인스턴스로 &lt;code&gt;x&lt;/code&gt; 가 아닌 값으로하는 기준 좌표 &lt;code&gt;x&lt;/code&gt; . 마지막 주장에서 우리는 &lt;code&gt;y&lt;/code&gt; 가 참조 일 때와 같은 방식으로 상자의 포인터를 따라 가기 위해 역 참조 연산자를 사용할 수 있습니다 . 다음으로 자체 상자 유형을 정의하여 역 참조 연산자를 사용할 수있는 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 특별한 점을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="51b5a7f2069f2def348d2148cbc38445c3e27f4c" translate="yes" xml:space="preserve">
          <source>The only difference between Listing 15-7 and Listing 15-6 is that here we set &lt;code&gt;y&lt;/code&gt; to be an instance of a box pointing to the value in &lt;code&gt;x&lt;/code&gt; rather than a reference pointing to the value of &lt;code&gt;x&lt;/code&gt;. In the last assertion, we can use the dereference operator to follow the box&amp;rsquo;s pointer in the same way that we did when &lt;code&gt;y&lt;/code&gt; was a reference. Next, we&amp;rsquo;ll explore what is special about &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that enables us to use the dereference operator by defining our own box type.</source>
          <target state="translated">리스팅 15-7 및 15-6리스트 사이의 유일한 차이점은 여기에 설정 인 &lt;code&gt;y&lt;/code&gt; 내의 값으로 가리키는 박스의 인스턴스로 &lt;code&gt;x&lt;/code&gt; 가 아닌 값으로하는 기준 좌표 &lt;code&gt;x&lt;/code&gt; . 마지막 어설 션에서 역 참조 연산자를 사용하여 &lt;code&gt;y&lt;/code&gt; 가 참조 일 때와 같은 방식으로 상자의 포인터를 따를 수 있습니다 . 다음으로 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 특별한 점을 살펴보고 자체 상자 유형을 정의하여 역 참조 연산자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7b8368bfb1b8c79cdb7d78152517d184d409bdd" translate="yes" xml:space="preserve">
          <source>The only functions that can be called in static or constant expressions are &lt;code&gt;const&lt;/code&gt; functions, and struct/enum constructors.</source>
          <target state="translated">정적 또는 상수 식에서 호출 할 수있는 유일한 함수는 &lt;code&gt;const&lt;/code&gt; 함수와 struct / enum 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="aa7a3f715132d2845165ebc499ef1753bb78d047" translate="yes" xml:space="preserve">
          <source>The only functions that can be called in static or constant expressions are &lt;code&gt;const&lt;/code&gt; functions, and struct/enum constructors. &lt;code&gt;const&lt;/code&gt; functions are only available on a nightly compiler. Rust currently does not support more general compile-time function execution.</source>
          <target state="translated">정적 또는 상수 표현식에서 호출 할 수있는 유일한 함수는 &lt;code&gt;const&lt;/code&gt; 함수 및 struct / enum 생성자입니다. &lt;code&gt;const&lt;/code&gt; 함수는 야간 컴파일러에서만 사용할 수 있습니다. Rust는 현재보다 일반적인 컴파일 타임 함수 실행을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7c42c506a124c9ffe70241d1844e481774b0efe" translate="yes" xml:space="preserve">
          <source>The only lifetime allowed in a constant is &lt;code&gt;'static&lt;/code&gt;, which is the lifetime that encompasses all others in a Rust program. For example, if you wanted to define a constant string, it would look like this:</source>
          <target state="translated">상수에서 허용되는 유일한 수명은 &lt;code&gt;'static&lt;/code&gt; ' 이며, 이는 Rust 프로그램의 다른 모든 것을 포함하는 수명입니다. 예를 들어 상수 문자열을 정의하려는 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c90e7627a1475de1daf664c395cb8fc220c2a179" translate="yes" xml:space="preserve">
          <source>The operand of a field expression.</source>
          <target state="translated">필드 표현식의 피연산자</target>
        </trans-unit>
        <trans-unit id="c815094584bba28655815f7e3484796d5b4ac295" translate="yes" xml:space="preserve">
          <source>The operand of a unary &lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;borrow&lt;/a&gt; or &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference&lt;/a&gt; operator.</source>
          <target state="translated">단항 &lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;차용&lt;/a&gt; 또는 &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;역 참조&lt;/a&gt; 연산자 의 피연산자입니다 .</target>
        </trans-unit>
        <trans-unit id="cfdf71c707b06cc703ce65b9173f06d5346346a9" translate="yes" xml:space="preserve">
          <source>The operand of an extending &lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;borrow expression&lt;/a&gt;.</source>
          <target state="translated">확장 &lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;차용 식&lt;/a&gt; 의 피연산자입니다 .</target>
        </trans-unit>
        <trans-unit id="93f114bcdcaebb0db94cec84309f6c6e9289e758" translate="yes" xml:space="preserve">
          <source>The operand of any &lt;a href=&quot;#implicit-borrows&quot;&gt;implicit borrow&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#implicit-borrows&quot;&gt;암시 적 차용&lt;/a&gt; 의 피연산자입니다 .</target>
        </trans-unit>
        <trans-unit id="8300616806da6883f068d3a939bb5817283d75af" translate="yes" xml:space="preserve">
          <source>The operand of any &lt;a href=&quot;expressions#implicit-borrows&quot;&gt;implicit borrow&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expressions#implicit-borrows&quot;&gt;암시 적 차용&lt;/a&gt; 의 피연산자 .</target>
        </trans-unit>
        <trans-unit id="13205f7dcdf1bb624db42e4217ccc5c5fe9a6c93" translate="yes" xml:space="preserve">
          <source>The operand of any extending borrow expression has its temporary scope extended.</source>
          <target state="translated">확장 차용 표현식의 피연산자는 확장 된 임시 범위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="0018d918b5db8fa5a5c40594da4082243e89b941" translate="yes" xml:space="preserve">
          <source>The operand(s) of an extending &lt;a href=&quot;expressions/array-expr#array-expressions&quot;&gt;array&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;cast&lt;/a&gt;, &lt;a href=&quot;expressions/struct-expr&quot;&gt;braced struct&lt;/a&gt;, or &lt;a href=&quot;expressions/tuple-expr#tuple-expressions&quot;&gt;tuple&lt;/a&gt; expression.</source>
          <target state="translated">확장 &lt;a href=&quot;expressions/array-expr#array-expressions&quot;&gt;배열&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;캐스트&lt;/a&gt; , &lt;a href=&quot;expressions/struct-expr&quot;&gt;중괄호 구조&lt;/a&gt; 또는 &lt;a href=&quot;expressions/tuple-expr#tuple-expressions&quot;&gt;튜플&lt;/a&gt; 식 의 피연산자 입니다.</target>
        </trans-unit>
        <trans-unit id="02413f33b0997a467453e2cc175754042613115c" translate="yes" xml:space="preserve">
          <source>The operation failed because a pipe was closed.</source>
          <target state="translated">파이프가 닫혀서 작업이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="e0b6b6bb05edcbe700535a8a02fd6257faeb1085" translate="yes" xml:space="preserve">
          <source>The operation lacked the necessary privileges to complete.</source>
          <target state="translated">작업을 완료하는 데 필요한 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d56bd5ac430688946f617fddd5ff8737ea77aabc" translate="yes" xml:space="preserve">
          <source>The operation needs to block to complete, but the blocking operation was requested to not occur.</source>
          <target state="translated">작업을 완료하려면 차단해야하지만 차단 작업이 발생하지 않도록 요청했습니다.</target>
        </trans-unit>
        <trans-unit id="554600e43876fa49fe1808261768a1599008a1a5" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; may be applied to operands of boolean type. The &lt;code&gt;||&lt;/code&gt; operator denotes logical 'or', and the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator denotes logical 'and'. They differ from &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in that the right-hand operand is only evaluated when the left-hand operand does not already determine the result of the expression. That is, &lt;code&gt;||&lt;/code&gt; only evaluates its right-hand operand when the left-hand operand evaluates to &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; only when it evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">연산자 &lt;code&gt;||&lt;/code&gt; 및 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 는 부울 타입의 피연산자에 적용될 수있다. &lt;code&gt;||&lt;/code&gt; 연산자는 논리 'or'를 나타내고 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 연산자는 논리 'and'를 나타냅니다. 그들은 다른 &lt;code&gt;|&lt;/code&gt; 및 &lt;code&gt;&amp;amp;&lt;/code&gt; 좌측 이미 식의 결과를 결정하지 않는 경우 피연산자 오른쪽 피연산자만을 평가하는 것이있다. 즉, &lt;code&gt;||&lt;/code&gt; 단지의 오른쪽을 평가 피연산자 때 왼쪽 피연산자로 평가 &lt;code&gt;false&lt;/code&gt; , 그리고 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 만가 평가할 때 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94a90205d7a5e5f5664d5fdcbd09052010d467f6" translate="yes" xml:space="preserve">
          <source>The optional &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8&quot;&gt;&lt;em&gt;UTF8 byte order mark&lt;/em&gt;&lt;/a&gt; (UTF8BOM production) indicates that the file is encoded in UTF8. It can only occur at the beginning of the file and is ignored by the compiler.</source>
          <target state="translated">선택적 &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8&quot;&gt;&lt;em&gt;UTF8 바이트 순서 표시&lt;/em&gt;&lt;/a&gt; (UTF8BOM 프로덕션)는 파일이 UTF8로 인코딩되었음을 나타냅니다. 파일의 시작 부분에서만 발생할 수 있으며 컴파일러에서 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="22d7081f01819ecc0a53443b4c5e3e1a4e2c048a" translate="yes" xml:space="preserve">
          <source>The optional fill character and alignment is provided normally in conjunction with the &lt;a href=&quot;#width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; parameter. It must be defined before &lt;code&gt;width&lt;/code&gt;, right after the &lt;code&gt;:&lt;/code&gt;. This indicates that if the value being formatted is smaller than &lt;code&gt;width&lt;/code&gt; some extra characters will be printed around it. Filling comes in the following variants for different alignments:</source>
          <target state="translated">선택적 채우기 문자 및 정렬은 일반적으로 &lt;a href=&quot;#width&quot;&gt; &lt;code&gt;width&lt;/code&gt; &lt;/a&gt; 매개 변수 와 함께 제공됩니다 . 그것은 전에 정의되어야 &lt;code&gt;width&lt;/code&gt; 바로 후 &lt;code&gt;:&lt;/code&gt; . 이는 형식화되는 값이 &lt;code&gt;width&lt;/code&gt; 보다 작 으면 그 주위에 추가 문자가 인쇄 됨을 나타냅니다 . 채우기는 다양한 정렬에 대해 다음과 같은 변형으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1ef92817d2fa5638a8f8e4bfed63d30ce997249b" translate="yes" xml:space="preserve">
          <source>The order in which this iterator returns entries is platform and filesystem dependent.</source>
          <target state="translated">이 반복기가 항목을 반환하는 순서는 플랫폼 및 파일 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="60297fe01f4f2a21350a894e6ee139ac8e93f1b8" translate="yes" xml:space="preserve">
          <source>The order in which to evaluate the sub-expressions</source>
          <target state="translated">하위 표현식을 평가하는 순서</target>
        </trans-unit>
        <trans-unit id="61bedc7c16635e05c26ee08451d7e761461ef5bb" translate="yes" xml:space="preserve">
          <source>The organizational problem of allocating responsibility for multiple tasks to the &lt;code&gt;main&lt;/code&gt; function is common to many binary projects. As a result, the Rust community has developed a process to use as a guideline for splitting the separate concerns of a binary program when &lt;code&gt;main&lt;/code&gt; starts getting large. The process has the following steps:</source>
          <target state="translated">여러 작업에 대한 책임을 &lt;code&gt;main&lt;/code&gt; 기능 에 할당하는 조직적인 문제는 많은 이진 프로젝트에서 공통적입니다. 그 결과, Rust 커뮤니티는 &lt;code&gt;main&lt;/code&gt; 이 커지기 시작할 때 바이너리 프로그램의 개별 문제를 분리하기위한 지침으로 사용할 프로세스를 개발했습니다 . 이 프로세스에는 다음 단계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="41be0c260fec224b2719e05df384f73991bede1b" translate="yes" xml:space="preserve">
          <source>The other arm of the &lt;code&gt;match&lt;/code&gt; handles the case where we get an &lt;code&gt;Err&lt;/code&gt; value from &lt;code&gt;File::open&lt;/code&gt;. In this example, we&amp;rsquo;ve chosen to call the &lt;code&gt;panic!&lt;/code&gt; macro. If there&amp;rsquo;s no file named &lt;em&gt;hello.txt&lt;/em&gt; in our current directory and we run this code, we&amp;rsquo;ll see the following output from the &lt;code&gt;panic!&lt;/code&gt; macro:</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 하는 다른 팔은 &lt;code&gt;File::open&lt;/code&gt; 에서 &lt;code&gt;Err&lt;/code&gt; 값을 얻는 경우를 처리합니다 . 이 예에서는 &lt;code&gt;panic!&lt;/code&gt; 선택했습니다 ! 매크로. 현재 디렉토리에 &lt;em&gt;hello.txt&lt;/em&gt; 라는 파일이 &lt;em&gt;없고이&lt;/em&gt; 코드를 실행하면 다음과 같은 결과가 나타납니다 &lt;code&gt;panic!&lt;/code&gt; 매크로 :&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a7bf4938ef9d644fa6590a14199d49f21d906882" translate="yes" xml:space="preserve">
          <source>The other difference between &lt;code&gt;mut&lt;/code&gt; and shadowing is that because we&amp;rsquo;re effectively creating a new variable when we use the &lt;code&gt;let&lt;/code&gt; keyword again, we can change the type of the value but reuse the same name. For example, say our program asks a user to show how many spaces they want between some text by inputting space characters, but we really want to store that input as a number:</source>
          <target state="translated">&lt;code&gt;mut&lt;/code&gt; 와 shadowing의 또 다른 차이점 은 &lt;code&gt;let&lt;/code&gt; 키워드를 다시 사용할 때 새 변수를 효과적으로 작성하기 때문에 값의 유형을 변경하고 동일한 이름을 재사용 할 수 있다는 것입니다. 예를 들어, 프로그램이 사용자에게 공백 문자를 입력하여 일부 텍스트 사이에 원하는 공백 수를 표시하도록 요청하지만 실제로 해당 입력을 숫자로 저장하려고합니다.</target>
        </trans-unit>
        <trans-unit id="df7669a1bf85d9740015e4131e57d2cd1eb9d9d3" translate="yes" xml:space="preserve">
          <source>The other main use of the &lt;code&gt;const&lt;/code&gt; keyword is in &lt;code&gt;const fn&lt;/code&gt;. This marks a function as being callable in the body of a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; item and in array initializers (commonly called &quot;const contexts&quot;). &lt;code&gt;const fn&lt;/code&gt; are restricted in the set of operations they can perform, to ensure that they can be evaluated at compile-time. See the &lt;a href=&quot;../reference/const_eval&quot;&gt;Reference&lt;/a&gt; for more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a27877809931e30e4d816c929aaf44550dc13948" translate="yes" xml:space="preserve">
          <source>The other option is to decide that pinning is &quot;structural&quot; for &lt;code&gt;field&lt;/code&gt;, meaning that if the struct is pinned then so is the field.</source>
          <target state="translated">다른 옵션은 피닝이 &lt;code&gt;field&lt;/code&gt; 에 대해 &quot;구조적&quot;인지 결정하는 것 입니다. 즉, 구조체가 고정되면 필드도 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="0642ecd58583a2694ae6dacfe0a415f63c694440" translate="yes" xml:space="preserve">
          <source>The other reason to use inheritance relates to the type system: to enable a child type to be used in the same places as the parent type. This is also called &lt;em&gt;polymorphism&lt;/em&gt;, which means that you can substitute multiple objects for each other at runtime if they share certain characteristics.</source>
          <target state="translated">상속을 사용하는 다른 이유는 유형 시스템과 관련이 있습니다. 하위 유형을 상위 유형과 동일한 위치에서 사용할 수 있도록하기위한 것입니다. 이를 &lt;em&gt;다형성&lt;/em&gt; 이라고도합니다. 즉, 특정 특성을 공유하는 경우 런타임에 여러 오브젝트를 서로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89dc389d4ca8b1b17999395cda6f46045ddfd179" translate="yes" xml:space="preserve">
          <source>The other use of the &lt;code&gt;impl&lt;/code&gt; keyword is in &lt;code&gt;impl Trait&lt;/code&gt; syntax, which can be seen as a shorthand for &quot;a concrete type that implements this trait&quot;. Its primary use is working with closures, which have type definitions generated at compile time that can't be simply typed out.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; 키워드 의 다른 용도는 &lt;code&gt;impl Trait&lt;/code&gt; 구문에 있으며 &quot;이 특성을 구현하는 구체적 유형&quot;의 약어로 볼 수 있습니다. 그것의 주요 용도는 클로저를 사용하는 것인데, 클로저는 컴파일 타임에 생성되어 단순히 타이핑 할 수없는 타입 정의가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fa7bdd2f67d8992d16557677350c79fe148aa6f" translate="yes" xml:space="preserve">
          <source>The other way to solve this error is to make the private type public. Example:</source>
          <target state="translated">이 오류를 해결하는 다른 방법은 개인 유형을 공개하는 것입니다. 예:</target>
        </trans-unit>
        <trans-unit id="69b16008db0e7fefb3576376fa59c7cdb24bc4ca" translate="yes" xml:space="preserve">
          <source>The outer scope declares a variable named &lt;code&gt;r&lt;/code&gt; with no initial value, and the inner scope declares a variable named &lt;code&gt;x&lt;/code&gt; with the initial value of 5. Inside the inner scope, we attempt to set the value of &lt;code&gt;r&lt;/code&gt; as a reference to &lt;code&gt;x&lt;/code&gt;. Then the inner scope ends, and we attempt to print the value in &lt;code&gt;r&lt;/code&gt;. This code won&amp;rsquo;t compile because the value &lt;code&gt;r&lt;/code&gt; is referring to has gone out of scope before we try to use it. Here is the error message:</source>
          <target state="translated">외부 범위는 초기 값이없는 &lt;code&gt;r&lt;/code&gt; 이라는 변수를 선언 하고 내부 범위는 초기 값이 5 인 &lt;code&gt;x&lt;/code&gt; 라는 변수를 선언합니다 . 내부 범위 내에서 &lt;code&gt;r&lt;/code&gt; 의 값 을 &lt;code&gt;x&lt;/code&gt; 에 대한 참조로 설정하려고합니다 . 그런 다음 내부 범위가 끝나고 &lt;code&gt;r&lt;/code&gt; 에 값을 인쇄하려고 시도합니다 . &lt;code&gt;r&lt;/code&gt; 이 참조 하는 값 이 범위를 벗어 났기 때문에이 코드는 컴파일되지 않습니다 . 오류 메시지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ee4813584901b6edf7255c9100533eb924eb1e04" translate="yes" xml:space="preserve">
          <source>The output of a finished process.</source>
          <target state="translated">완료된 프로세스의 출력</target>
        </trans-unit>
        <trans-unit id="7091d6ad7f032d028b64c465cb0226168ae0e89e" translate="yes" xml:space="preserve">
          <source>The output of this function should not be used in anything that might have security implications. For example:</source>
          <target state="translated">이 기능의 출력은 보안에 영향을 줄 수있는 어떤 것도 사용해서는 안됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c978821bc364ab92333f8a77fd4cf50814193dc4" translate="yes" xml:space="preserve">
          <source>The output that the future will produce on completion.</source>
          <target state="translated">미래가 완료되면 생산할 출력.</target>
        </trans-unit>
        <trans-unit id="4e5a226f1cb2eaa0ff96072c4caeb2fee856332d" translate="yes" xml:space="preserve">
          <source>The output type returned by methods.</source>
          <target state="translated">메소드가 리턴 한 출력 유형.</target>
        </trans-unit>
        <trans-unit id="b3fedfd8280044a357b6d9f266e6194249a97d9a" translate="yes" xml:space="preserve">
          <source>The output will be the recommended workout plan. Listing 13-2 shows the &lt;code&gt;main&lt;/code&gt; function we&amp;rsquo;ll use.</source>
          <target state="translated">출력은 권장 운동 계획이됩니다. Listing 13-2는 우리가 사용할 &lt;code&gt;main&lt;/code&gt; 기능을 보여준다 .</target>
        </trans-unit>
        <trans-unit id="884c1b47c0faf2e5f38e29c6c1a9622d7629d70c" translate="yes" xml:space="preserve">
          <source>The overall goal of these requirements is to let the consumer of a pipeline use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c750221db5bde24f0432e5395fa0e7d6b2249e8f" translate="yes" xml:space="preserve">
          <source>The ownership of &lt;code&gt;buf&lt;/code&gt; is effectively transferred to the &lt;code&gt;String&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 의 소유권 은 효과적으로 &lt;code&gt;String&lt;/code&gt; 으로 전송되어 포인터가 가리키는 메모리의 내용을 마음대로 할당 해제, 재 할당 또는 변경할 수 있습니다. 이 함수를 호출 한 후에는 다른 포인터가 포인터를 사용하지 않는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b39c88ef6b933b61e4ea4a039f34870326ac716b" translate="yes" xml:space="preserve">
          <source>The ownership of &lt;code&gt;ptr&lt;/code&gt; is effectively transferred to the &lt;code&gt;String&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 의 소유권 은 효과적으로 &lt;code&gt;String&lt;/code&gt; 으로 전송되며, 이는 마음대로 포인터가 가리키는 메모리의 내용을 할당 해제, 재 할당 또는 변경할 수 있습니다. 이 함수를 호출 한 후 다른 포인터를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0c5ac2aeb05d71a34b822c034365a66e97f5d90e" translate="yes" xml:space="preserve">
          <source>The ownership of &lt;code&gt;ptr&lt;/code&gt; is effectively transferred to the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 의 소유권은 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 로 효과적으로 전달 되며,이 포인터는 마음대로 포인터가 가리키는 메모리의 내용을 할당 해제, 재 할당 또는 변경할 수 있습니다. 이 함수를 호출 한 후 다른 포인터를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="459d615a7b443b2b18398d7b4e4094d21aa9904a" translate="yes" xml:space="preserve">
          <source>The ownership of a variable follows the same pattern every time: assigning a value to another variable moves it. When a variable that includes data on the heap goes out of scope, the value will be cleaned up by &lt;code&gt;drop&lt;/code&gt; unless the data has been moved to be owned by another variable.</source>
          <target state="translated">변수의 소유권은 매번 같은 패턴을 따릅니다. 다른 변수에 값을 할당하면 변수가 이동합니다. 힙에 데이터를 포함하는 변수가 범위를 벗어나면 다른 변수가 소유하도록 데이터를 이동하지 않은 경우 값이 &lt;code&gt;drop&lt;/code&gt; 되어 정리됩니다 .</target>
        </trans-unit>
        <trans-unit id="8158170312c35ad0b4ff632e830474174c9789f6" translate="yes" xml:space="preserve">
          <source>The ownership rules play a vital role in message sending because they help you write safe, concurrent code. Preventing errors in concurrent programming is the advantage of thinking about ownership throughout your Rust programs. Let&amp;rsquo;s do an experiment to show how channels and ownership work together to prevent problems: we&amp;rsquo;ll try to use a &lt;code&gt;val&lt;/code&gt; value in the spawned thread &lt;em&gt;after&lt;/em&gt; we&amp;rsquo;ve sent it down the channel. Try compiling the code in Listing 16-9 to see why this code isn&amp;rsquo;t allowed:</source>
          <target state="translated">소유권 규칙은 안전한 동시 코드 작성을 도와주기 때문에 메시지 전송에 중요한 역할을합니다. 동시 프로그래밍에서 오류를 방지하는 것은 Rust 프로그램의 소유권에 대해 생각할 때 유리합니다. 문제를 방지하기 위해 채널과 소유권이 함께 작동하는 방법을 보여주는 실험을 해봅 &lt;code&gt;val&lt;/code&gt; . 채널 아래로 보낸 &lt;em&gt;후&lt;/em&gt; 생성 된 스레드에서 val 값 을 사용하려고합니다 . 이 코드가 허용되지 않는 이유를 보려면 Listing 16-9의 코드를 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="58f56a016b810f8287c744364955b1ffc32f9240" translate="yes" xml:space="preserve">
          <source>The panic hook is a global resource.</source>
          <target state="translated">패닉 훅은 글로벌 리소스입니다.</target>
        </trans-unit>
        <trans-unit id="684aef30b999855f4bf1399a43d22fd82b7e6c9d" translate="yes" xml:space="preserve">
          <source>The panic hook is invoked when a thread panics, but before the panic runtime is invoked. As such, the hook will run with both the aborting and unwinding runtimes. The default hook prints a message to standard error and generates a backtrace if requested, but this behavior can be customized with the &lt;code&gt;set_hook&lt;/code&gt; and &lt;a href=&quot;fn.take_hook&quot;&gt;&lt;code&gt;take_hook&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">패닉 후크는 스레드 패닉이 발생하지만 패닉 런타임이 호출되기 전에 호출됩니다. 따라서 후크는 중단 및 해제 런타임 모두에서 실행됩니다. 기본 후크는 메시지를 표준 오류로 인쇄하고 요청시 역 추적을 생성하지만이 동작은 &lt;code&gt;set_hook&lt;/code&gt; 및 &lt;a href=&quot;fn.take_hook&quot;&gt; &lt;code&gt;take_hook&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="563c97e45aeee516b45222324d4cc368e8c084ba" translate="yes" xml:space="preserve">
          <source>The parameters given to &lt;code&gt;Layout::from_size_align&lt;/code&gt; or some other &lt;code&gt;Layout&lt;/code&gt; constructor do not satisfy its documented constraints.</source>
          <target state="translated">&lt;code&gt;Layout::from_size_align&lt;/code&gt; 또는 다른 &lt;code&gt;Layout&lt;/code&gt; 생성자에 지정된 매개 변수 가 문서화 된 제약 조건을 충족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c2a54faaf19386dc2b06158bf3003e146fc0f45" translate="yes" xml:space="preserve">
          <source>The parameters of any trait method must match between a trait implementation and the trait definition.</source>
          <target state="translated">특성 메소드의 매개 변수는 특성 구현과 특성 정의간에 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="df3b8f99f35d92ad550b740bf7dc9171d35b97ed" translate="yes" xml:space="preserve">
          <source>The parent of a statement scope is the scope of the block that contains the statement.</source>
          <target state="translated">명령문 범위의 부모는 명령문을 포함하는 블록의 범위입니다.</target>
        </trans-unit>
        <trans-unit id="c46091b9f972d668faf65caa23b2e09a8a170568" translate="yes" xml:space="preserve">
          <source>The parent of all other scopes is the scope of the immediately enclosing expression.</source>
          <target state="translated">다른 모든 범위의 부모는 바로 둘러싸는 식의 범위입니다.</target>
        </trans-unit>
        <trans-unit id="e04065a98d4b38354b6e3e4d4abb130f6c621783" translate="yes" xml:space="preserve">
          <source>The parent of the arm scope is the scope of the &lt;code&gt;match&lt;/code&gt; expression that it belongs to.</source>
          <target state="translated">arm 범위의 부모는 그것이 속한 &lt;code&gt;match&lt;/code&gt; 표현식 의 범위입니다 .</target>
        </trans-unit>
        <trans-unit id="09a327800a21f08b5d4e1948e88aac172c2121be" translate="yes" xml:space="preserve">
          <source>The parent of the current &lt;a href=&quot;../reference/items/modules&quot;&gt;module&lt;/a&gt;.</source>
          <target state="translated">현재 &lt;a href=&quot;../reference/items/modules&quot;&gt;모듈&lt;/a&gt; 의 부모입니다 .</target>
        </trans-unit>
        <trans-unit id="529eb4e30d49293a9076afc4b5e1cde599b49562" translate="yes" xml:space="preserve">
          <source>The parent of the expression after the &lt;code&gt;=&amp;gt;&lt;/code&gt; in a &lt;code&gt;match&lt;/code&gt; expression is the scope of the arm that it's in.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 표현식 에서 &lt;code&gt;=&amp;gt;&lt;/code&gt; 뒤에 오는 표현식의 부모는 그것이있는 팔의 범위입니다.</target>
        </trans-unit>
        <trans-unit id="7bf69b726f2264b18f25a14f0c4351943f8d4d50" translate="yes" xml:space="preserve">
          <source>The parent of the expression for a &lt;code&gt;match&lt;/code&gt; guard is the scope of the arm that the guard is for.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 가드 에 대한 표현식의 부모는 가드가 사용하는 팔의 범위입니다.</target>
        </trans-unit>
        <trans-unit id="10e7154b1118c2abd23aedcc36e2f4febf44487b" translate="yes" xml:space="preserve">
          <source>The parent of the expression in an expression statement is the scope of the statement.</source>
          <target state="translated">식 문에서 식의 부모는 문의 범위입니다.</target>
        </trans-unit>
        <trans-unit id="bf1edfebb91e8c5be33d3f8d00037717971d53a2" translate="yes" xml:space="preserve">
          <source>The parent of the initializer of a &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/a&gt; is the &lt;code&gt;let&lt;/code&gt; statement's scope.</source>
          <target state="translated">&lt;a href=&quot;statements#let-statements&quot;&gt; &lt;code&gt;let&lt;/code&gt; 문의&lt;/a&gt; 이니셜 라이저의 부모 는 &lt;code&gt;let&lt;/code&gt; 문의 범위입니다.</target>
        </trans-unit>
        <trans-unit id="f7896dc490ba78587890c7c602aaea52ff1e61a5" translate="yes" xml:space="preserve">
          <source>The parent thread can also wait on the completion of the child thread; a call to &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; produces a &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;, which provides a &lt;code&gt;join&lt;/code&gt; method for waiting:</source>
          <target state="translated">부모 스레드는 자식 스레드가 완료 될 때까지 기다릴 수도 있습니다. &lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt; 호출 하면 &lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; 이&lt;/a&gt; 생성 되어 대기 하는 &lt;code&gt;join&lt;/code&gt; 메소드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="46e80e0e5a125dc6b093687f5b3dfa680a2d94d7" translate="yes" xml:space="preserve">
          <source>The parenthesized &lt;code&gt;inline&lt;/code&gt; attribute requires the parameter to be specified:</source>
          <target state="translated">괄호 안에있는 &lt;code&gt;inline&lt;/code&gt; 속성에는 매개 변수를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="15c1964228f17e3bf48dc3c0a27f630dfed2aef1" translate="yes" xml:space="preserve">
          <source>The parenthesized &lt;code&gt;instruction_set&lt;/code&gt; attribute requires the parameter to be specified:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2172d9db47abf995cf78b6d1056e43a62f663b4" translate="yes" xml:space="preserve">
          <source>The parser used by the macro system is reasonably powerful, but it is limited in order to prevent ambiguity in current or future versions of the language. In particular, in addition to the rule about ambiguous expansions, a nonterminal matched by a metavariable must be followed by a token which has been decided can be safely used after that kind of match.</source>
          <target state="translated">매크로 시스템에서 사용하는 파서는 상당히 강력하지만 현재 또는 향후 버전의 언어에서 모호성을 방지하기 위해 제한됩니다. 특히, 모호한 확장에 대한 규칙 외에도 메타 변수와 일치하는 비 터미널 뒤에는 이러한 종류의 일치 후에 안전하게 사용할 수있는 결정된 토큰이 따라 와야합니다.</target>
        </trans-unit>
        <trans-unit id="72524139620fe5680057ec138f1bc4009c442555" translate="yes" xml:space="preserve">
          <source>The path prefix for modules is the canonical path to that module. For bare implementations, it is the canonical path of the item being implemented surrounded by angle (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) brackets. For &lt;a href=&quot;items/implementations#trait-implementations&quot;&gt;trait implementations&lt;/a&gt;, it is the canonical path of the item being implemented followed by &lt;code&gt;as&lt;/code&gt; followed by the canonical path to the trait all surrounded in angle (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) brackets.</source>
          <target state="translated">모듈의 경로 접두사는 해당 모듈의 정식 경로입니다. 베어 구현의 경우 앵글 ( &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ) 괄호로 둘러싸인 구현중인 항목의 정식 경로입니다 . 들면 &lt;a href=&quot;items/implementations#trait-implementations&quot;&gt;형질 구현&lt;/a&gt; , 그 항목의 표준 경로는 다음 시행되고 &lt;code&gt;as&lt;/code&gt; 모든 각도 (에 둘러싸인 형질 정규 경로 다음 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ) 브래킷.</target>
        </trans-unit>
        <trans-unit id="c6a4fb9e71adbfcd1bb4598c90adf218d993dcba" translate="yes" xml:space="preserve">
          <source>The path to the associated items is &lt;code&gt;&amp;lt;&lt;/code&gt; followed by a path to the implementing type followed by &lt;code&gt;as&lt;/code&gt; followed by a path to the trait followed by &lt;code&gt;&amp;gt;&lt;/code&gt; as a path component followed by the associated item's path component.</source>
          <target state="translated">관련 항목 경로는 &lt;code&gt;&amp;lt;&lt;/code&gt; 뒤에 구현 형 경로 다음 &lt;code&gt;as&lt;/code&gt; 다음 형질 경로이어서 &lt;code&gt;&amp;gt;&lt;/code&gt; 경로 성분이 연관된 항목의 경로로 구성 하였다.</target>
        </trans-unit>
        <trans-unit id="e791bfe4c14128fe94a9448b536323c040235679" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; or a closure that determines if a character matches.</source>
          <target state="translated">패턴은 &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 또는 문자가 일치하는지 판별하는 클로저 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b997b2f72267455f266b90593be72c411299620" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; or a closure that determines if a character matches.</source>
          <target state="translated">패턴은 &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 또는 문자가 일치하는지 판별하는 클로저 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7a545179141a5b3642800fa8e44597af1f79a17" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">패턴은 &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 또는 문자가 일치하는지 판별하는 클로저 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eab1bd44108e3c6ec8d1d8c6acc9fac3b5f45a9e" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">패턴은 &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 또는 문자가 일치하는지 판별하는 클로저 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3313c804137756973c3dae6df1f5d957a288624" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">패턴은 &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 또는 문자가 일치하는지 판별하는 클로저 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bfcc6e07c89f929bc9a9b9157ac58712686768e0" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split.</source>
          <target state="translated">패턴은 패턴 특성을 구현하는 모든 유형이 될 수 있습니다. 주목할만한 예로는 분할을 결정하는 &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 및 클로저가 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb766e07c7ab39fe3b62bc217205480afe2f8cd2" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split. Additional libraries might provide more complex patterns like regular expressions.</source>
          <target state="translated">패턴은 패턴 특성을 구현하는 모든 유형이 될 수 있습니다. 주목할만한 예로는 분할을 결정하는 &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 및 클로저가 있습니다. 추가 라이브러리는 정규식과 같은보다 복잡한 패턴을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53665fb10463c2a5a8c8a6c23b4c3d2013b572a7" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split.</source>
          <target state="translated">패턴은 패턴 특성을 구현하는 모든 유형이 될 수 있습니다. 주목할만한 예로는 분할을 결정하는 &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 및 클로저가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8059c918e0a15a39f2f09be5faf1d4cb011e74e6" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split. Additional libraries might provide more complex patterns like regular expressions.</source>
          <target state="translated">패턴은 패턴 특성을 구현하는 모든 유형이 될 수 있습니다. 주목할만한 예로는 분할을 결정하는 &lt;code&gt;&amp;amp;str&lt;/code&gt; , &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 및 클로저가 있습니다. 추가 라이브러리는 정규식과 같은보다 복잡한 패턴을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70fe7a4be65487325b69a6e9166bdb513323e0b5" translate="yes" xml:space="preserve">
          <source>The pattern in the following example does four things:</source>
          <target state="translated">다음 예제의 패턴은 네 가지 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="5a181811e45dbf2fc9dddcbe8e2017ec7127d78e" translate="yes" xml:space="preserve">
          <source>The pattern in the second match arm introduces a new variable named &lt;code&gt;y&lt;/code&gt; that will match any value inside a &lt;code&gt;Some&lt;/code&gt; value. Because we&amp;rsquo;re in a new scope inside the &lt;code&gt;match&lt;/code&gt; expression, this is a new &lt;code&gt;y&lt;/code&gt; variable, not the &lt;code&gt;y&lt;/code&gt; we declared at the beginning with the value 10. This new &lt;code&gt;y&lt;/code&gt; binding will match any value inside a &lt;code&gt;Some&lt;/code&gt;, which is what we have in &lt;code&gt;x&lt;/code&gt;. Therefore, this new &lt;code&gt;y&lt;/code&gt; binds to the inner value of the &lt;code&gt;Some&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;. That value is &lt;code&gt;5&lt;/code&gt;, so the expression for that arm executes and prints &lt;code&gt;Matched, y = 5&lt;/code&gt;.</source>
          <target state="translated">두 번째 일치 암의 패턴은 &lt;code&gt;Some&lt;/code&gt; 값 내부의 모든 값과 일치하는 &lt;code&gt;y&lt;/code&gt; 라는 새 변수를 도입 합니다. 우리는 내부의 새로운 범위에있어 때문에 &lt;code&gt;match&lt;/code&gt; 표현, 이것은 새로운 &lt;code&gt;y&lt;/code&gt; 를 변수가 아닌 &lt;code&gt;y&lt;/code&gt; 를 우리가 값 10과 함께 시작 부분에 선언이 새로운 &lt;code&gt;y&lt;/code&gt; , 안쪽의 값과 일치합니다 바인딩 &lt;code&gt;Some&lt;/code&gt; 우리가 무엇 인 에 &lt;code&gt;x&lt;/code&gt; . 따라서이 새로운 &lt;code&gt;y&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 에서 &lt;code&gt;Some&lt;/code&gt; 의 내부 값에 바인딩됩니다 . 이 값은 &lt;code&gt;5&lt;/code&gt; 이므로 해당 팔에 대한 표현식이 실행되고 &lt;code&gt;Matched, y = 5&lt;/code&gt; 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="fd1b310fb5c60706a33dc63407dcff2f0de81ecd" translate="yes" xml:space="preserve">
          <source>The pattern is most commonly a single variable, which means no pattern matching is done and the expression given is bound to the variable. Apart from that, patterns used in &lt;code&gt;let&lt;/code&gt; bindings can be as complicated as needed, given that the pattern is exhaustive. See the &lt;a href=&quot;../book/ch06-02-match&quot;&gt;Rust book&lt;/a&gt; for more information on pattern matching. The type of the pattern is optionally given afterwards, but if left blank is automatically inferred by the compiler if possible.</source>
          <target state="translated">패턴은 가장 일반적으로 단일 변수이므로 패턴 일치가 수행되지 않고 주어진 표현식이 변수에 바인딩됩니다. 그 외에도에서 사용 패턴 &lt;code&gt;let&lt;/code&gt; 바인딩은 같은 패턴이 완전한 것을 주어, 필요에 따라 복잡 할 수 있습니다. 패턴 일치에 대한 자세한 정보 는 &lt;a href=&quot;../book/ch06-02-match&quot;&gt;Rust 책&lt;/a&gt; 을 참조하십시오. 패턴의 유형은 나중에 선택적으로 제공되지만, 비워두면 가능하면 컴파일러가 자동으로 유추합니다.</target>
        </trans-unit>
        <trans-unit id="c2459ac3b35f7ffa8e048896d3c16ca10cfe1608" translate="yes" xml:space="preserve">
          <source>The pattern of the first arm in the &lt;code&gt;match&lt;/code&gt; expression matches a &lt;code&gt;Message::ChangeColor&lt;/code&gt; enum variant that contains a &lt;code&gt;Color::Rgb&lt;/code&gt; variant; then the pattern binds to the three inner &lt;code&gt;i32&lt;/code&gt; values. The pattern of the second arm also matches a &lt;code&gt;Message::ChangeColor&lt;/code&gt; enum variant, but the inner enum matches the &lt;code&gt;Color::Hsv&lt;/code&gt; variant instead. We can specify these complex conditions in one &lt;code&gt;match&lt;/code&gt; expression, even though two enums are involved.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 표현식 의 첫 번째 팔 패턴은 &lt;code&gt;Color::Rgb&lt;/code&gt; 변형 을 포함하는 &lt;code&gt;Message::ChangeColor&lt;/code&gt; 열거 형 변형 과 일치합니다 . 패턴은 세 개의 내부 &lt;code&gt;i32&lt;/code&gt; 값에 바인딩 됩니다. 두 번째 암의 패턴도 &lt;code&gt;Message::ChangeColor&lt;/code&gt; 열거 형 변형과 일치하지만 내부 열거 형은 대신 &lt;code&gt;Color::Hsv&lt;/code&gt; 변형 과 일치합니다 . 두 개의 열거 형이 포함되어 있어도 이러한 복잡한 조건을 하나의 &lt;code&gt;match&lt;/code&gt; 식으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a42d62f0f2bbc370e10f35406b8b10d13fb51143" translate="yes" xml:space="preserve">
          <source>The patterns programmed into Rust&amp;rsquo;s analysis of references are called the &lt;em&gt;lifetime elision rules&lt;/em&gt;. These aren&amp;rsquo;t rules for programmers to follow; they&amp;rsquo;re a set of particular cases that the compiler will consider, and if your code fits these cases, you don&amp;rsquo;t need to write the lifetimes explicitly.</source>
          <target state="translated">Rust의 기준 분석에 프로그래밍 된 패턴을 &lt;em&gt;수명 제거 규칙&lt;/em&gt; 이라고합니다 . 프로그래머가 따라야 할 규칙은 아닙니다. 그것들은 컴파일러가 고려할 특정 사례 세트이며, 코드가 이러한 경우에 적합하면 수명을 명시 적으로 작성할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="012a0566d4550e7174697625c83965140d98cc31" translate="yes" xml:space="preserve">
          <source>The peer address may be set by the &lt;code&gt;connect&lt;/code&gt; method, and this method will return an error if the socket has not already been connected.</source>
          <target state="translated">피어 주소는 &lt;code&gt;connect&lt;/code&gt; 메소드에 있으며이 메소드는 소켓이 아직 연결되지 않은 경우 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c7338ebe0eb2e257ec72f81d23df2b1d8ecc7ce7" translate="yes" xml:space="preserve">
          <source>The performance of these two features (Spoiler alert: they&amp;rsquo;re faster than you might think!)</source>
          <target state="translated">이 두 기능의 성능 (스포일러 경고 : 생각보다 빠릅니다!)</target>
        </trans-unit>
        <trans-unit id="b42828007b197505190540700b376ffcea8793e7" translate="yes" xml:space="preserve">
          <source>The pointer is valid only if there are some strong references. The pointer may be dangling, unaligned or even &lt;a href=&quot;../ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">포인터는 강력한 참조가있는 경우에만 유효합니다. 포인터는 매달려 있거나 정렬되지 않았거나 아니면 &lt;a href=&quot;../ptr/fn.null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c13daf063b9e605b83028dc0feae2167ff80511" translate="yes" xml:space="preserve">
          <source>The pointer may be &lt;a href=&quot;../ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; or be dangling in case the object has already been destroyed.</source>
          <target state="translated">포인터가 &lt;a href=&quot;../ptr/fn.null&quot;&gt; &lt;code&gt;null&lt;/code&gt; 인 경우&lt;/a&gt;객체가 이미 파괴 된 경우 이거나 매달려 .</target>
        </trans-unit>
        <trans-unit id="c51f7cfe5691f3edc0397a76000e0e31815c58dc" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="translated">포인터는 &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 많은 바이트에 대한 읽기 및 쓰기에 &lt;a href=&quot;index#safety&quot;&gt;유효&lt;/a&gt; 해야하며 올바르게 정렬되어야합니다. 이것은 특히 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2d6cc95e7b609b2c158e2115aa97ef7549141c5d" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="translated">포인터는 &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 많은 바이트에 대한 읽기에 &lt;a href=&quot;index#safety&quot;&gt;유효&lt;/a&gt; 해야하며 올바르게 정렬되어야합니다. 이것은 특히 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="eab75a519555d7d953b751dc8250587661100bb4" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;ptr/index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="translated">포인터는 &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 많은 바이트에 대한 읽기 및 쓰기에 &lt;a href=&quot;ptr/index#safety&quot;&gt;유효&lt;/a&gt; 해야하며 올바르게 정렬되어야합니다. 이것은 특히 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="032bd62f596d84915c186de815c7e316435955e0" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;ptr/index#safety&quot;&gt;valid&lt;/a&gt; for reads for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="translated">포인터는 &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 많은 바이트에 대한 읽기에 &lt;a href=&quot;ptr/index#safety&quot;&gt;유효&lt;/a&gt; 해야하며 올바르게 정렬되어야합니다. 이것은 특히 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ada677800eded9f5bb09a12d4c9272e1a48a79a4" translate="yes" xml:space="preserve">
          <source>The pointer must be aligned even for zero-length slices. One reason for this is that enum layout optimizations may rely on references (including slices of any length) being aligned and non-null to distinguish them from other data. You can obtain a pointer that is usable as &lt;code&gt;data&lt;/code&gt; for zero-length slices using &lt;a href=&quot;ptr/struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">길이가 0 인 슬라이스의 경우에도 포인터를 정렬해야합니다. 한 가지 이유는 열거 형 레이아웃 최적화가 다른 데이터와 구별하기 위해 정렬되고 널이 아닌 참조 (모든 길이의 슬라이스 포함)에 의존 할 수 있기 때문입니다. &lt;a href=&quot;ptr/struct.nonnull#method.dangling&quot;&gt; &lt;code&gt;NonNull::dangling()&lt;/code&gt; &lt;/a&gt; 사용하여 길이가 0 인 슬라이스에 대한 &lt;code&gt;data&lt;/code&gt; 로 사용할 수있는 포인터를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f6efbb545be55e13f893ac7dc6eaebbf999874a" translate="yes" xml:space="preserve">
          <source>The pointer must be aligned even for zero-length slices. One reason for this is that enum layout optimizations may rely on references (including slices of any length) being aligned and non-null to distinguish them from other data. You can obtain a pointer that is usable as &lt;code&gt;data&lt;/code&gt; for zero-length slices using &lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">길이가 0 인 슬라이스의 경우에도 포인터를 정렬해야합니다. 한 가지 이유는 열거 형 레이아웃 최적화가 다른 데이터와 구별하기 위해 정렬되고 널이 아닌 참조 (모든 길이의 슬라이스 포함)에 의존 할 수 있기 때문입니다. &lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt; &lt;code&gt;NonNull::dangling()&lt;/code&gt; &lt;/a&gt; 사용하여 길이가 0 인 슬라이스에 대한 &lt;code&gt;data&lt;/code&gt; 로 사용할 수있는 포인터를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7882f94a6f87dc84506e67cf6e6f86cd53b02982" translate="yes" xml:space="preserve">
          <source>The pointer must be properly aligned.</source>
          <target state="translated">포인터가 제대로 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e3de011a05d32ff014b1d75b10f32cd8a5ceea0c" translate="yes" xml:space="preserve">
          <source>The pointer must have been obtained through &lt;code&gt;Arc::into_raw&lt;/code&gt;, and the associated &lt;code&gt;Arc&lt;/code&gt; instance must be valid (i.e. the strong count must be at least 1) for the duration of this method.</source>
          <target state="translated">포인터는 &lt;code&gt;Arc::into_raw&lt;/code&gt; 를 통해 얻어야 하며 연결된 &lt;code&gt;Arc&lt;/code&gt; 인스턴스는이 메서드 기간 동안 유효해야합니다 (즉, strong count는 1 이상이어야 함).</target>
        </trans-unit>
        <trans-unit id="d97c31e45ac08eaf340466af2855c1d69a8c822f" translate="yes" xml:space="preserve">
          <source>The pointer must have been obtained through &lt;code&gt;Arc::into_raw&lt;/code&gt;, and the associated &lt;code&gt;Arc&lt;/code&gt; instance must be valid (i.e. the strong count must be at least 1) when invoking this method. This method can be used to release the final &lt;code&gt;Arc&lt;/code&gt; and backing storage, but &lt;strong&gt;should not&lt;/strong&gt; be called after the final &lt;code&gt;Arc&lt;/code&gt; has been released.</source>
          <target state="translated">포인터는 &lt;code&gt;Arc::into_raw&lt;/code&gt; 를 통해 얻어야하며이 메서드를 호출 할 때 연결된 &lt;code&gt;Arc&lt;/code&gt; 인스턴스가 유효해야합니다 (즉, 강력한 카운트가 1 이상이어야 함). 이 메서드는 최종 &lt;code&gt;Arc&lt;/code&gt; 및 백업 저장소 를 해제하는 데 사용할 수 있지만 최종 &lt;code&gt;Arc&lt;/code&gt; 가 해제 된 후에는 호출 &lt;strong&gt;하면 안됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="15b7d63adfc51a7db20582294688b5c6c47a0e5f" translate="yes" xml:space="preserve">
          <source>The pointer must have originated from the &lt;a href=&quot;struct.weak#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt; and must still own its potential weak reference.</source>
          <target state="translated">포인터는 &lt;a href=&quot;struct.weak#method.into_raw&quot;&gt; &lt;code&gt;into_raw&lt;/code&gt; &lt;/a&gt; 에서 시작 되어야하며 여전히 잠재적 약한 참조를 소유해야합니다.</target>
        </trans-unit>
        <trans-unit id="561496e3426c59f66cb3091efa83ade648ff436f" translate="yes" xml:space="preserve">
          <source>The pointer must point to an initialized instance of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">포인터는 &lt;code&gt;T&lt;/code&gt; 의 초기화 된 인스턴스를 가리켜 야합니다 .</target>
        </trans-unit>
        <trans-unit id="d562cc44e11330190c6c67edae5c28019986b445" translate="yes" xml:space="preserve">
          <source>The pointer must represent one valid weak count. In other words, it must point to &lt;code&gt;T&lt;/code&gt; which is or &lt;em&gt;was&lt;/em&gt; managed by an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; and the weak count of that &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; must not have reached 0. It is allowed for the strong count to be 0.</source>
          <target state="translated">포인터는 하나의 유효한 약한 카운트를 나타내야합니다. 즉, 가리켜 야 &lt;code&gt;T&lt;/code&gt; 또는 어느 &lt;em&gt;한&lt;/em&gt; 의해 관리 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 그 약한 카운트 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 0으로 강한 카운트 허용 0에 도달 안된다.</target>
        </trans-unit>
        <trans-unit id="20794b93602408cab637197663bf6c675231f221" translate="yes" xml:space="preserve">
          <source>The pointer must represent one valid weak count. In other words, it must point to &lt;code&gt;T&lt;/code&gt; which is or &lt;em&gt;was&lt;/em&gt; managed by an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; and the weak count of that &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; must not have reached 0. It is allowed for the strong count to be 0.</source>
          <target state="translated">포인터는 하나의 유효한 약한 카운트를 나타내야합니다. 즉, 가리켜 야 &lt;code&gt;T&lt;/code&gt; 또는 어느 &lt;em&gt;한&lt;/em&gt; 의해 관리 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; 를&lt;/a&gt; 그 약한 카운트 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; 를&lt;/a&gt; 만약 0으로 강한 카운트 허용 0에 도달 안된다.</target>
        </trans-unit>
        <trans-unit id="d6200eb92cc97fc1d9fec6dde1612acc6fca320f" translate="yes" xml:space="preserve">
          <source>The pointer passed to all functions inside the vtable is the &lt;code&gt;data&lt;/code&gt; pointer from the enclosing &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">vtable 내부의 모든 함수에 전달되는 포인터는 둘러싸는 &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;code&gt;data&lt;/code&gt; 포인터입니다 .</target>
        </trans-unit>
        <trans-unit id="1edb65c05d4061d65ef7c599b48750ef7ff50704" translate="yes" xml:space="preserve">
          <source>The pointer which this function returns must be returned to Rust and reconstituted using &lt;a href=&quot;#method.from_raw&quot;&gt;&lt;code&gt;from_raw&lt;/code&gt;&lt;/a&gt; to be properly deallocated. Specifically, one should &lt;em&gt;not&lt;/em&gt; use the standard C &lt;code&gt;free()&lt;/code&gt; function to deallocate this string.</source>
          <target state="translated">이 함수가 리턴하는 포인터는 Rust로 리턴되고 &lt;a href=&quot;#method.from_raw&quot;&gt; &lt;code&gt;from_raw&lt;/code&gt; &lt;/a&gt; 를 사용하여 올바르게 할당 해제되어야합니다. 특히, 이 문자열을 할당 해제 하기 위해 표준 C &lt;code&gt;free()&lt;/code&gt; 함수를 사용 해서는 &lt;em&gt;안됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="80c5d8a7d931f08c90875d736c69378d02a8b64f" translate="yes" xml:space="preserve">
          <source>The pointer which this function returns must be returned to Rust and reconstituted using &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt; to be properly deallocated. Specifically, one should &lt;em&gt;not&lt;/em&gt; use the standard C &lt;code&gt;free()&lt;/code&gt; function to deallocate this string.</source>
          <target state="translated">이 함수가 반환하는 포인터는 Rust로 반환되어야하고 &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt; &lt;code&gt;CString::from_raw&lt;/code&gt; &lt;/a&gt; 를 사용하여 재구성 되어야 적절하게 할당 해제됩니다. 특히이 문자열을 할당 해제 하기 위해 표준 C &lt;code&gt;free()&lt;/code&gt; 함수를 사용 해서는 &lt;em&gt;안됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="33be8edf304b61e5005625c2c6aab855fc0ce0b3" translate="yes" xml:space="preserve">
          <source>The pointer will be properly aligned and non-null.</source>
          <target state="translated">포인터가 올바르게 정렬되고 널이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0c49a977fe21d66debc9a4c8b7d4cbbf312c9ff9" translate="yes" xml:space="preserve">
          <source>The pointer-sized signed integer type.</source>
          <target state="translated">포인터 크기의 부호있는 정수 유형.</target>
        </trans-unit>
        <trans-unit id="aebc6996cd3e6c3ef507e0e5f263e13ad4dcb04b" translate="yes" xml:space="preserve">
          <source>The pointer-sized unsigned integer type.</source>
          <target state="translated">포인터 크기의 부호없는 정수 유형.</target>
        </trans-unit>
        <trans-unit id="589a00e779c762d350b4058d583ec6c935c455c7" translate="yes" xml:space="preserve">
          <source>The position used for seeking with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(_)&lt;/code&gt; is the position the underlying reader would be at if the &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; had no internal buffer.</source>
          <target state="translated">&lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;SeekFrom::Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(_)&lt;/code&gt; 로 검색하는 데 사용되는 위치는 &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; 내부 버퍼가없는 경우 기본 판독기가있을 위치 입니다.</target>
        </trans-unit>
        <trans-unit id="4aef48aecfebe1bd9e6f96a0939bb1d8fec84054" translate="yes" xml:space="preserve">
          <source>The position used for seeking with &lt;code&gt;SeekFrom::Current(_)&lt;/code&gt; is the position the underlying reader would be at if the &lt;code&gt;BufReader&lt;/code&gt; had no internal buffer.</source>
          <target state="translated">&lt;code&gt;SeekFrom::Current(_)&lt;/code&gt; 로 탐색하는 데 사용되는 위치는 &lt;code&gt;BufReader&lt;/code&gt; 에 내부 버퍼가없는 경우 기본 판독기가있는 위치 입니다.</target>
        </trans-unit>
        <trans-unit id="6f1678b0e093177e7620807a9112f4ef7365e563" translate="yes" xml:space="preserve">
          <source>The positive difference of two numbers.</source>
          <target state="translated">두 숫자의 양의 차이.</target>
        </trans-unit>
        <trans-unit id="e0a83025808dfefbef9f39106ce5fafd89bb2f1c" translate="yes" xml:space="preserve">
          <source>The practical use cases for &lt;code&gt;forget&lt;/code&gt; are rather specialized and mainly come up in unsafe or FFI code.</source>
          <target state="translated">&lt;code&gt;forget&lt;/code&gt; 위한 실제 사용 사례 는 다소 전문적이고 주로 안전하지 않은 코드 나 FFI 코드로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="fb2efbc552f75b7ae8fe422ecdae2c87a030f044" translate="yes" xml:space="preserve">
          <source>The precedence of Rust operators and expressions is ordered as follows, going from strong to weak. Binary Operators at the same precedence level are grouped in the order given by their associativity.</source>
          <target state="translated">Rust 연산자와 표현식의 우선 순위는 다음과 같이 순서가 매겨집니다. 우선 순위가 같은 이진 연산자는 연관성에 따라 순서대로 그룹화됩니다.</target>
        </trans-unit>
        <trans-unit id="5ed57a298428ca0f7395d0616c5eb17f0804c549" translate="yes" xml:space="preserve">
          <source>The precise Rust aliasing rules are somewhat in flux, but the main points are not contentious:</source>
          <target state="translated">정확한 녹 앨리어싱 규칙은 다소 유동적이지만 요점은 논쟁의 여지가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b19f5cee233892caf5ddceb163f25862486da448" translate="yes" xml:space="preserve">
          <source>The precise definition is: a type &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if and only if &lt;code&gt;&amp;amp;T&lt;/code&gt; is &lt;a href=&quot;trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;. In other words, if there is no possibility of &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; (including data races) when passing &lt;code&gt;&amp;amp;T&lt;/code&gt; references between threads.</source>
          <target state="translated">정확한 정의는 다음과 같습니다. 유형 &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;&amp;amp;T&lt;/code&gt; 가 &lt;a href=&quot;trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; 경우에만 &lt;a href=&quot;trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 입니다. 즉, 스레드간에 &lt;code&gt;&amp;amp;T&lt;/code&gt; 참조를 전달할 때 &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;정의되지 않은 동작&lt;/a&gt; (데이터 경합 포함)의 가능성이없는 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="d40bd8a03d88e20d491263cadc1752cd72c99258" translate="yes" xml:space="preserve">
          <source>The precise definition is: a type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; if and only if &lt;code&gt;&amp;amp;T&lt;/code&gt; is &lt;a href=&quot;trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;. In other words, if there is no possibility of &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; (including data races) when passing &lt;code&gt;&amp;amp;T&lt;/code&gt; references between threads.</source>
          <target state="translated">정확한 정의는 다음과 같습니다 . &lt;code&gt;&amp;amp;T&lt;/code&gt; 가 &lt;a href=&quot;trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; 인&lt;/a&gt; 경우에만 유형 &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;Sync&lt;/code&gt; 입니다. 즉, 스레드간에 &lt;code&gt;&amp;amp;T&lt;/code&gt; 참조를 전달할 때 &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;정의되지 않은 동작&lt;/a&gt; (데이터 레이스 포함)이 없을 경우 .</target>
        </trans-unit>
        <trans-unit id="f47fdb8c6eff67732e48f22a8373d2422de700a9" translate="yes" xml:space="preserve">
          <source>The precise memory layout of a struct is not specified. One can specify a particular layout using the &lt;a href=&quot;../type-layout#representations&quot;&gt;&lt;code&gt;repr&lt;/code&gt; attribute&lt;/a&gt;.</source>
          <target state="translated">구조체의 정확한 메모리 레이아웃이 지정되지 않았습니다. &lt;a href=&quot;../type-layout#representations&quot;&gt; &lt;code&gt;repr&lt;/code&gt; 속성을&lt;/a&gt; 사용하여 특정 레이아웃을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18073d476ac74d19109a41401163857e8cd5056d" translate="yes" xml:space="preserve">
          <source>The precise rules for validity are not determined yet. The guarantees that are provided at this point are very minimal:</source>
          <target state="translated">유효성에 대한 정확한 규칙은 아직 결정되지 않았습니다. 이 시점에서 제공되는 보증은 매우 작습니다.</target>
        </trans-unit>
        <trans-unit id="4933f50236b0c7e48edc0beedb70199f13c5e285" translate="yes" xml:space="preserve">
          <source>The predicate passed to &lt;code&gt;partition()&lt;/code&gt; can return &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;partition()&lt;/code&gt; returns a pair, all of the elements for which it returned &lt;code&gt;true&lt;/code&gt;, and all of the elements for which it returned &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;partition()&lt;/code&gt; 전달 된 술어는 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 를 리턴 할 수 있습니다 . &lt;code&gt;partition()&lt;/code&gt; 은 쌍, &lt;code&gt;true&lt;/code&gt; 를 반환 한 모든 요소 및 &lt;code&gt;false&lt;/code&gt; 를 반환 한 모든 요소를 ​​반환합니다. 합니다.</target>
        </trans-unit>
        <trans-unit id="7fb4a93626b0bdb54fdbc20512bf4f76ed5cc7cd" translate="yes" xml:space="preserve">
          <source>The preferred alignment of a type.</source>
          <target state="translated">유형의 기본 정렬입니다.</target>
        </trans-unit>
        <trans-unit id="dbc19e95dcebc744b29e267ad8d2ebfde2e212c0" translate="yes" xml:space="preserve">
          <source>The prelude can be changed to the &lt;em&gt;core prelude&lt;/em&gt; by using the &lt;code&gt;no_std&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; on the root crate module. The linked crate is &lt;a href=&quot;https://doc.rust-lang.org/core/index.html&quot;&gt;&lt;code&gt;core&lt;/code&gt;&lt;/a&gt; and the prelude module is &lt;a href=&quot;https://doc.rust-lang.org/core/prelude/index.html&quot;&gt;&lt;code&gt;core::prelude::v1&lt;/code&gt;&lt;/a&gt;. Using the core prelude over the standard prelude is useful when either the crate is targeting a platform that does not support the standard library or is purposefully not using the capabilities of the standard library. Those capabilities are mainly dynamic memory allocation (e.g. &lt;code&gt;Box&lt;/code&gt; and &lt;code&gt;Vec&lt;/code&gt;) and file and network capabilities (e.g. &lt;code&gt;std::fs&lt;/code&gt; and &lt;code&gt;std::io&lt;/code&gt;).</source>
          <target state="translated">루트 크레이트 모듈 에서 &lt;code&gt;no_std&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 을 사용하여 &lt;em&gt;prelude&lt;/em&gt; 를 &lt;em&gt;코어 prelude&lt;/em&gt; 로 변경할 수 있습니다 . 연결된 크레이트는 &lt;a href=&quot;https://doc.rust-lang.org/core/index.html&quot;&gt; &lt;code&gt;core&lt;/code&gt; &lt;/a&gt; 이고 prelude 모듈은 &lt;a href=&quot;https://doc.rust-lang.org/core/prelude/index.html&quot;&gt; &lt;code&gt;core::prelude::v1&lt;/code&gt; &lt;/a&gt; 입니다. 크레이트가 표준 라이브러리를 지원하지 않는 플랫폼을 목표로하거나 의도적으로 표준 라이브러리의 기능을 사용하지 않는 경우 표준 전주보다 핵심 전주를 사용하는 것이 유용합니다. 이러한 기능은 주로 동적 메모리 할당 (예 : &lt;code&gt;Box&lt;/code&gt; 및 &lt;code&gt;Vec&lt;/code&gt; ) 및 파일 및 네트워크 기능 (예 : &lt;code&gt;std::fs&lt;/code&gt; 및 &lt;code&gt;std::io&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="97af9d37776d235cea4e5a19d84cc2b3492bd088" translate="yes" xml:space="preserve">
          <source>The previous Appendix D, &amp;ldquo;Macros,&amp;rdquo; has been expanded to include procedural macros and was moved to the &amp;ldquo;Macros&amp;rdquo; section in Chapter 19.</source>
          <target state="translated">이전 부록 D, &quot;매크로&quot;는 절차 적 매크로를 포함하도록 확장되었으며 19 장의 &quot;매크로&quot;섹션으로 이동되었습니다.</target>
        </trans-unit>
        <trans-unit id="757bcf5f0a1b2e7c263eb1294cae88079f56068e" translate="yes" xml:space="preserve">
          <source>The previous code example fixed:</source>
          <target state="translated">이전 코드 예제가 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="3f0414a5a5139b7f4e08b6a8b19dea661159e39f" translate="yes" xml:space="preserve">
          <source>The previous example contains a circular dependency between two traits: &lt;code&gt;FirstTrait&lt;/code&gt; depends on &lt;code&gt;SecondTrait&lt;/code&gt; which itself depends on &lt;code&gt;FirstTrait&lt;/code&gt;.</source>
          <target state="translated">위의 예에서는 두 특성 간의 순환 종속성을 포함 &lt;code&gt;FirstTrait&lt;/code&gt; 가 에 달려 &lt;code&gt;SecondTrait&lt;/code&gt; 자체에 의존 &lt;code&gt;FirstTrait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74a02be48083e6dc1dccc9a7d07cadacc4a53e7c" translate="yes" xml:space="preserve">
          <source>The previously duplicated code is now outside the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks and uses the &lt;code&gt;status_line&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables. This makes it easier to see the difference between the two cases, and it means we have only one place to update the code if we want to change how the file reading and response writing work. The behavior of the code in Listing 20-9 will be the same as that in Listing 20-8.</source>
          <target state="translated">이전에 복제 된 코드는 이제 &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 외부에 있으며 &lt;code&gt;status_line&lt;/code&gt; 및 &lt;code&gt;filename&lt;/code&gt; 변수를 차단하고 사용합니다 . 이를 통해 두 경우의 차이점을보다 쉽게 ​​확인할 수 있으며 파일 읽기 및 응답 쓰기 작동 방식을 변경하려는 경우 코드를 업데이트 할 곳이 한 곳뿐입니다. Listing 20-9의 코드 동작은 Listing 20-8의 코드 동작과 동일하다.</target>
        </trans-unit>
        <trans-unit id="3c5b34498a69e2cebc3edcacf3022a159fa0d3cf" translate="yes" xml:space="preserve">
          <source>The primary separator of path components for the current platform.</source>
          <target state="translated">현재 플랫폼에 대한 경로 구성 요소의 기본 구분자입니다.</target>
        </trans-unit>
        <trans-unit id="d6d94c1dd4c2a4fb7b30d949d7313e70926e43b0" translate="yes" xml:space="preserve">
          <source>The primary use for the &lt;code&gt;let&lt;/code&gt; keyword is in &lt;code&gt;let&lt;/code&gt; statements, which are used to introduce a new set of variables into the current scope, as given by a pattern.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 키워드 의 기본 용도 는 &lt;code&gt;let&lt;/code&gt; 문에서 사용됩니다. let 문은 패턴으로 지정된대로 현재 범위에 새로운 변수 세트를 도입하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="14d97c2e9b793134fb211ba0f8484d81636a707d" translate="yes" xml:space="preserve">
          <source>The primary use of the &lt;code&gt;crate&lt;/code&gt; keyword is as a part of &lt;code&gt;extern crate&lt;/code&gt; declarations, which are used to specify a dependency on a crate external to the one it's declared in. Crates are the fundamental compilation unit of Rust code, and can be seen as libraries or projects. More can be read about crates in the &lt;a href=&quot;../reference/items/extern-crates&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;crate&lt;/code&gt; 키워드 의 주요 용도는 &lt;code&gt;extern crate&lt;/code&gt; 선언 의 일부로 사용되며, 외부에서 크레이트에 선언 된 외부 크레이트에 대한 종속성을 지정하는 데 사용됩니다. 크레이트는 Rust 코드의 기본 컴파일 단위이며 라이브러리로 볼 수 있습니다 또는 프로젝트. 더의 상자에 대해 읽을 수 있습니다 &lt;a href=&quot;../reference/items/extern-crates&quot;&gt;참조&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="229057a153cb547539a5140063be86de4fd5f109" translate="yes" xml:space="preserve">
          <source>The priority policy of the lock is dependent on the underlying operating system's implementation, and this type does not guarantee that any particular policy will be used.</source>
          <target state="translated">잠금의 우선 순위 정책은 기본 운영 체제의 구현에 따라 다르며이 유형은 특정 정책의 사용을 보증하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa4bf60f4fab6128150a2cced20eb507a73f2223" translate="yes" xml:space="preserve">
          <source>The private address ranges are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1918&quot;&gt;IETF RFC 1918&lt;/a&gt; and include:</source>
          <target state="translated">개인 주소 범위는 &lt;a href=&quot;https://tools.ietf.org/html/rfc1918&quot;&gt;IETF RFC 1918에&lt;/a&gt; 정의되어 있으며 다음을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="66e536d148965eb5f5f66293b59e6e08d6c64117" translate="yes" xml:space="preserve">
          <source>The problem above can be solved by using the &lt;code&gt;ref&lt;/code&gt; keyword.</source>
          <target state="translated">위의 문제는 &lt;code&gt;ref&lt;/code&gt; 키워드 를 사용하여 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6b09f11dabd510af2bfd7f547ade1211b4999bd" translate="yes" xml:space="preserve">
          <source>The problem here is that foo is defined as accepting a parameter of type &lt;code&gt;Fn&lt;/code&gt;. Closures passed into foo will thus be inferred to be of type &lt;code&gt;Fn&lt;/code&gt;, meaning that they capture their context immutably.</source>
          <target state="translated">여기서 문제는 foo가 &lt;code&gt;Fn&lt;/code&gt; 유형의 매개 변수를 허용하는 것으로 정의된다는 것 입니다. 따라서 foo에 전달 된 클로저는 &lt;code&gt;Fn&lt;/code&gt; 유형 인 것으로 추론됩니다 . 즉, 컨텍스트를 불변으로 캡처합니다.</target>
        </trans-unit>
        <trans-unit id="31cdd55efce31c6be1cacdfc4b62449817b4add1" translate="yes" xml:space="preserve">
          <source>The problem here is that if the given type or one of its fields implements the &lt;code&gt;Drop&lt;/code&gt; trait, this &lt;code&gt;Drop&lt;/code&gt; implementation cannot be called within a const context since it may run arbitrary, non-const-checked code. To prevent this issue, ensure all values with custom a custom &lt;code&gt;Drop&lt;/code&gt; implementation escape the initializer.</source>
          <target state="translated">여기서 문제는 주어진 유형 또는 필드 중 하나가 &lt;code&gt;Drop&lt;/code&gt; 특성을 구현하는 경우 상수가 아닌 임의의 코드를 실행할 수 있으므로이 &lt;code&gt;Drop&lt;/code&gt; 구현을 const 컨텍스트 내에서 호출 할 수 없다는 것입니다. 이 문제를 방지하려면 사용자 정의 &lt;code&gt;Drop&lt;/code&gt; 구현이 있는 모든 값 이 이니셜 라이저를 이스케이프해야합니다.</target>
        </trans-unit>
        <trans-unit id="2c0a1b6d65ca057a3fdc49e919abfbdd1b60d9bd" translate="yes" xml:space="preserve">
          <source>The problem here is that the lifetime isn't contrained by any of the arguments, making it impossible to determine how long it's supposed to live.</source>
          <target state="translated">여기서 문제는 수명이 어떤 논증에도 구속되지 않기 때문에 얼마나 오래 살아야하는지 결정할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fe892e0206a6e32b9668f223826cd09ae2236ca9" translate="yes" xml:space="preserve">
          <source>The problem here is that we're attempting to take the type of X from MyTrait. Unfortunately, the type of X is not defined, because it's only made concrete in implementations of the trait. A working version of this code might look like:</source>
          <target state="translated">여기서 문제는 MyTrait에서 X 유형을 가져 오려고한다는 것입니다. 불행히도, X의 유형은 특성의 구현에서 구체적으로 만들어지기 때문에 정의되지 않습니다. 이 코드의 작동 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5cbbff1b6bec23be456b36b8e81795c5a5d74a0" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;result&lt;/code&gt; goes out of scope and gets cleaned up at the end of the &lt;code&gt;longest&lt;/code&gt; function. We&amp;rsquo;re also trying to return a reference to &lt;code&gt;result&lt;/code&gt; from the function. There is no way we can specify lifetime parameters that would change the dangling reference, and Rust won&amp;rsquo;t let us create a dangling reference. In this case, the best fix would be to return an owned data type rather than a reference so the calling function is then responsible for cleaning up the value.</source>
          <target state="translated">문제는 &lt;code&gt;result&lt;/code&gt; 가 범위를 벗어나서 &lt;code&gt;longest&lt;/code&gt; 기능 의 끝에서 정리 된다는 것입니다 . 또한 함수의 &lt;code&gt;result&lt;/code&gt; 대한 참조를 반환하려고 합니다. 매달려있는 참조를 변경하는 수명 매개 변수를 지정할 수있는 방법이 없으며 Rust는 매달려있는 참조를 만들 수 없습니다. 이 경우 가장 좋은 수정 방법은 참조가 아닌 소유 한 데이터 형식을 반환하여 호출 함수가 값을 정리하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="967a587dbf080c4427ca5b25acc74fdfbb85e443" translate="yes" xml:space="preserve">
          <source>The problem is that the first time we called &lt;code&gt;c.value&lt;/code&gt; with 1, the &lt;code&gt;Cacher&lt;/code&gt; instance saved &lt;code&gt;Some(1)&lt;/code&gt; in &lt;code&gt;self.value&lt;/code&gt;. Thereafter, no matter what we pass in to the &lt;code&gt;value&lt;/code&gt; method, it will always return 1.</source>
          <target state="translated">문제는 &lt;code&gt;c.value&lt;/code&gt; 를 1로 처음 호출 했을 때 &lt;code&gt;Cacher&lt;/code&gt; 인스턴스 가 &lt;code&gt;self.value&lt;/code&gt; 에 &lt;code&gt;Some(1)&lt;/code&gt; 을 저장 했다는 것 입니다. 그 후, &lt;code&gt;value&lt;/code&gt; 메소드 에 무엇을 전달하든 항상 1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="833738d2692abe453105a9ed609d8a8bc820fa2a" translate="yes" xml:space="preserve">
          <source>The problem is that the parameter &lt;code&gt;T&lt;/code&gt; does not appear in the implementing type (&lt;code&gt;Foo&lt;/code&gt;) of the impl. In this case, we can fix the error by moving the type parameter from the &lt;code&gt;impl&lt;/code&gt; to the method &lt;code&gt;get&lt;/code&gt;:</source>
          <target state="translated">문제는 매개 변수 &lt;code&gt;T&lt;/code&gt; 가 impl 의 구현 유형 ( &lt;code&gt;Foo&lt;/code&gt; )에 나타나지 않는다는 것입니다 . 이 경우 type 매개 변수를 &lt;code&gt;impl&lt;/code&gt; 에서 &lt;code&gt;get&lt;/code&gt; 메소드 로 이동하여 오류를 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="457d0fe3119f86c660d95b413dfdd79fba1ea792" translate="yes" xml:space="preserve">
          <source>The problem isn&amp;rsquo;t really with the concept but with the particular implementation. As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum is &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, and it is &lt;a href=&quot;../std/option/enum.option&quot;&gt;defined by the standard library&lt;/a&gt; as follows:</source>
          <target state="translated">문제는 실제로 개념이 아니라 특정 구현에 있습니다. 따라서 Rust에는 null이 없지만 존재하거나 존재하지 않는 값의 개념을 인코딩 할 수있는 열거 형이 있습니다. 이 열거 형은 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 이며 &lt;a href=&quot;../std/option/enum.option&quot;&gt;표준 라이브러리에&lt;/a&gt; 의해 다음과 같이 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="11afe9c5b7d3b341c43395982cbb657bcfedf0f3" translate="yes" xml:space="preserve">
          <source>The problem with null values is that if you try to use a null value as a not-null value, you&amp;rsquo;ll get an error of some kind. Because this null or not-null property is pervasive, it&amp;rsquo;s extremely easy to make this kind of error.</source>
          <target state="translated">널값의 문제점은 널값을 널이 아닌 값으로 사용하려고하면 어떤 종류의 오류가 발생한다는 것입니다. 이 null 속성 또는 null이 아닌 속성은 광범위하기 때문에 이런 종류의 오류를 만드는 것은 매우 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="c7ffb82b1f0d51caf9c86374d324e2fb9ccac1dd" translate="yes" xml:space="preserve">
          <source>The process lacks permissions to view the contents.</source>
          <target state="translated">프로세스에 내용을 볼 수있는 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="475777e2dbe3eb987a1fdf9f7258e8744d697a33" translate="yes" xml:space="preserve">
          <source>The process lacks permissions to view the number of hardware threads available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a1f341aa82ec15ad62b2ae6744edcef123d4a7" translate="yes" xml:space="preserve">
          <source>The process may be in a &quot;broken state&quot; if this function returns in error. For example the working directory, environment variables, signal handling settings, various user/group information, or aspects of stdio file descriptors may have changed. If a &quot;transactional spawn&quot; is required to gracefully handle errors it is recommended to use the cross-platform &lt;code&gt;spawn&lt;/code&gt; instead.</source>
          <target state="translated">이 함수가 오류를 반환하면 프로세스가 &quot;깨진 상태&quot;일 수 있습니다. 예를 들어 작업 디렉토리, 환경 변수, 신호 처리 설정, 다양한 사용자 / 그룹 정보 또는 stdio 파일 디스크립터의 측면이 변경되었을 수 있습니다. 오류를 정상적으로 처리하기 위해 &quot;트랜잭션 스폰&quot;이 필요한 경우 크로스 플랫폼 &lt;code&gt;spawn&lt;/code&gt; 대신 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="68c2b04d8256c338d13f147c4eb19b87b45d4040" translate="yes" xml:space="preserve">
          <source>The programs we&amp;rsquo;ve written so far have been in one module in one file. As a project grows, you can organize code by splitting it into multiple modules and then multiple files. A package can contain multiple binary crates and optionally one library crate. As a package grows, you can extract parts into separate crates that become external dependencies. This chapter covers all these techniques. For very large projects of a set of interrelated packages that evolve together, Cargo provides workspaces, which we&amp;rsquo;ll cover in the &lt;a href=&quot;ch14-03-cargo-workspaces&quot;&gt;&amp;ldquo;Cargo Workspaces&amp;rdquo;&lt;/a&gt; section in Chapter 14.</source>
          <target state="translated">지금까지 작성한 프로그램은 하나의 파일에 하나의 모듈에 있습니다. 프로젝트가 성장함에 따라 코드를 여러 모듈로 분할 한 다음 여러 파일로 나누어 코드를 구성 할 수 있습니다. 패키지는 여러 바이너리 상자와 선택적으로 하나의 라이브러리 상자를 포함 할 수 있습니다. 패키지가 커짐에 따라 외부 의존성이되는 별도의 상자로 부품을 추출 할 수 있습니다. 이 장에서는 이러한 모든 기술을 다룹니다. 함께 진화하는 상호 관련 패키지 세트의 대규모 프로젝트를 위해 Cargo는 작업 공간을 제공합니다. 작업 공간은 14 장의 &lt;a href=&quot;ch14-03-cargo-workspaces&quot;&gt;&quot;화물 작업 공간&quot;&lt;/a&gt; 섹션에서 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="5cc2497d5ed1d06060f022ff65bd8b3ff66c60a9" translate="yes" xml:space="preserve">
          <source>The provided &lt;a href=&quot;struct.layout#method.size&quot;&gt;&lt;code&gt;layout.size()&lt;/code&gt;&lt;/a&gt; must fall in the range &lt;code&gt;min ..= max&lt;/code&gt;, where:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be1cd28ce339784f890d38adb07a623811959d09" translate="yes" xml:space="preserve">
          <source>The provided &lt;code&gt;path&lt;/code&gt; doesn't exist.</source>
          <target state="translated">제공된 &lt;code&gt;path&lt;/code&gt; 가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a99e10f876c8ad74bd47e22ac1f9e01fe1760d28" translate="yes" xml:space="preserve">
          <source>The public methods &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;average&lt;/code&gt; are the only ways to access or modify data in an instance of &lt;code&gt;AveragedCollection&lt;/code&gt;. When an item is added to &lt;code&gt;list&lt;/code&gt; using the &lt;code&gt;add&lt;/code&gt; method or removed using the &lt;code&gt;remove&lt;/code&gt; method, the implementations of each call the private &lt;code&gt;update_average&lt;/code&gt; method that handles updating the &lt;code&gt;average&lt;/code&gt; field as well.</source>
          <target state="translated">공용 메소드 &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; 및 &lt;code&gt;average&lt;/code&gt; 는 &lt;code&gt;AveragedCollection&lt;/code&gt; 인스턴스에서 데이터에 액세스하거나 수정하는 유일한 방법 입니다. &lt;code&gt;add&lt;/code&gt; 메소드를 사용하여 항목을 &lt;code&gt;list&lt;/code&gt; 에 추가 하거나 &lt;code&gt;remove&lt;/code&gt; 메소드를 사용하여 제거 할 때 각 구현은 &lt;code&gt;average&lt;/code&gt; 필드 업데이트를 처리하는 private &lt;code&gt;update_average&lt;/code&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c64a2ba34c09d4f2e756bf0b0db2bf928ce82f04" translate="yes" xml:space="preserve">
          <source>The purpose of pinning is to be able to rely on the placement of some data in memory. To make this work, not just moving the data is restricted; deallocating, repurposing, or otherwise invalidating the memory used to store the data is restricted, too. Concretely, for pinned data you have to maintain the invariant that &lt;em&gt;its memory will not get invalidated or repurposed from the moment it gets pinned until when &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; is called&lt;/em&gt;. Only once &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; returns or panics, the memory may be reused.</source>
          <target state="translated">고정의 목적은 메모리의 일부 데이터 배치에 의존 할 수 있도록하는 것입니다. 이 작업을 수행하려면 데이터 이동이 제한되는 것이 아닙니다. 데이터를 저장하는 데 사용되는 메모리의 할당 해제, 용도 변경 또는 무효화도 제한됩니다. 구체적으로 고정 된 데이터의 경우 고정 된 &lt;em&gt;순간부터 &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; 이 호출 될 때까지 해당 메모리가 무효화되거나 용도가 변경되지 않는다는&lt;/em&gt; 불변성을 유지해야합니다 . 한 번만 &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; 반환 또는 패닉, 메모리는 재사용 할 수있다.</target>
        </trans-unit>
        <trans-unit id="4a93f31254516d6844f82cc6e94b5893fc7d6231" translate="yes" xml:space="preserve">
          <source>The purpose of pinning is to be able to rely on the placement of some data in memory. To make this work, not just moving the data is restricted; deallocating, repurposing, or otherwise invalidating the memory used to store the data is restricted, too. Concretely, for pinned data you have to maintain the invariant that &lt;em&gt;its memory will not get invalidated or repurposed from the moment it gets pinned until when &lt;code&gt;drop&lt;/code&gt; is called&lt;/em&gt;. Memory can be invalidated by deallocation, but also by replacing a &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(v)&lt;/code&gt;&lt;/a&gt; by &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, or calling &lt;a href=&quot;../vec/struct.vec#method.set_len&quot;&gt;&lt;code&gt;Vec::set_len&lt;/code&gt;&lt;/a&gt; to &quot;kill&quot; some elements off of a vector. It can be repurposed by using &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;ptr::write&lt;/code&gt;&lt;/a&gt; to overwrite it without calling the destructor first.</source>
          <target state="translated">고정의 목적은 일부 데이터를 메모리에 배치하는 데 의존 할 수 있도록하는 것입니다. 이 작업을 수행하려면 데이터 이동 만이 제한됩니다. 데이터 저장에 사용 된 메모리의 할당 해제, 용도 변경 또는 무효화도 제한됩니다. 구체적으로 고정 된 데이터의 &lt;em&gt;경우 고정이 시작된 시점부터 &lt;code&gt;drop&lt;/code&gt; 이 호출 될 때까지 메모리가 무효화되거나 용도가 변경되지 않는&lt;/em&gt; 불변성을 유지해야합니다 . 할당 해제를 통해 메모리를 무효화 할 수 있지만 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(v)&lt;/code&gt; &lt;/a&gt; 를 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 으로 바꾸 거나 &lt;a href=&quot;../vec/struct.vec#method.set_len&quot;&gt; &lt;code&gt;Vec::set_len&lt;/code&gt; &lt;/a&gt; 을 호출 하여 벡터에서 일부 요소를 &quot;kill&quot;할 수 있습니다. 소멸자를 먼저 호출하지 않고 &lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;ptr::write&lt;/code&gt; &lt;/a&gt; 를 사용하여 덮어 쓰면 용도를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dadde1acddaa4f2663e0f0f8fe2f53b8bd256d16" translate="yes" xml:space="preserve">
          <source>The purpose of these &lt;code&gt;Result&lt;/code&gt; types is to encode error-handling information. Values of the &lt;code&gt;Result&lt;/code&gt; type, like values of any type, have methods defined on them. An instance of &lt;code&gt;io::Result&lt;/code&gt; has an &lt;a href=&quot;../std/result/enum.result#method.expect&quot;&gt;&lt;code&gt;expect&lt;/code&gt; method&lt;/a&gt; that you can call. If this instance of &lt;code&gt;io::Result&lt;/code&gt; is an &lt;code&gt;Err&lt;/code&gt; value, &lt;code&gt;expect&lt;/code&gt; will cause the program to crash and display the message that you passed as an argument to &lt;code&gt;expect&lt;/code&gt;. If the &lt;code&gt;read_line&lt;/code&gt; method returns an &lt;code&gt;Err&lt;/code&gt;, it would likely be the result of an error coming from the underlying operating system. If this instance of &lt;code&gt;io::Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt; value, &lt;code&gt;expect&lt;/code&gt; will take the return value that &lt;code&gt;Ok&lt;/code&gt; is holding and return just that value to you so you can use it. In this case, that value is the number of bytes in what the user entered into standard input.</source>
          <target state="translated">이러한 &lt;code&gt;Result&lt;/code&gt; 유형 의 목적은 오류 처리 정보를 인코딩하는 것입니다. 의 값 &lt;code&gt;Result&lt;/code&gt; 유형은 모든 유형의 값처럼, 방법은 그들에 정의했습니다. &lt;code&gt;io::Result&lt;/code&gt; 의 인스턴스에는 호출 할 수 있는 &lt;a href=&quot;../std/result/enum.result#method.expect&quot;&gt; &lt;code&gt;expect&lt;/code&gt; 메소드&lt;/a&gt; 가 있습니다. 의 인스턴스 경우 &lt;code&gt;io::Result&lt;/code&gt; 입니다 &lt;code&gt;Err&lt;/code&gt; 값이 &lt;code&gt;expect&lt;/code&gt; 충돌하고 인수로 전달하는 메시지를 표시 할 수있는 프로그램의 원인이됩니다 &lt;code&gt;expect&lt;/code&gt; . 는 IF &lt;code&gt;read_line&lt;/code&gt; 의 메소드가 리턴 &lt;code&gt;Err&lt;/code&gt; , 그것은 가능성이 기본 운영 체제에서 오는 오류의 결과 일 것이다. 이 &lt;code&gt;io::Result&lt;/code&gt; 인스턴스가 가 &lt;code&gt;Ok&lt;/code&gt; 값, &lt;code&gt;expect&lt;/code&gt; 하는 반환 값 소요됩니다 &lt;code&gt;Ok&lt;/code&gt; 보유하고 당신이 그것을 사용할 수 있도록 당신에게 그냥 값을 반환합니다. 이 경우 해당 값은 사용자가 표준 입력에 입력 한 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="17a957e4dd15537d9df26e9cd567ee8ac4ab9c24" translate="yes" xml:space="preserve">
          <source>The purpose of this example is to demonstrate a situation in which some generic parameters are declared with &lt;code&gt;impl&lt;/code&gt; and some are declared with the method definition. Here, the generic parameters &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; are declared after &lt;code&gt;impl&lt;/code&gt;, because they go with the struct definition. The generic parameters &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;W&lt;/code&gt; are declared after &lt;code&gt;fn mixup&lt;/code&gt;, because they&amp;rsquo;re only relevant to the method.</source>
          <target state="translated">이 예제의 목적은 일부 일반 매개 변수가 &lt;code&gt;impl&lt;/code&gt; 로 선언되고 일부는 메소드 정의로 선언 되는 상황을 설명하기위한 것 입니다. 여기서 일반 매개 변수 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; 는 구조체 정의와 함께 사용되므로 &lt;code&gt;impl&lt;/code&gt; 뒤에 선언 됩니다. 일반 매개 변수 &lt;code&gt;V&lt;/code&gt; 와 &lt;code&gt;W&lt;/code&gt; 는 메소드에만 관련되어 있기 때문에 &lt;code&gt;fn mixup&lt;/code&gt; 후에 선언 됩니다.</target>
        </trans-unit>
        <trans-unit id="83464f6d897f3cf3890af3a243744932372ed118" translate="yes" xml:space="preserve">
          <source>The purpose of this module is to alleviate imports of many common I/O traits by adding a glob import to the top of I/O heavy modules:</source>
          <target state="translated">이 모듈의 목적은 I / O 무거운 모듈의 맨 위에 glob 가져 오기를 추가하여 많은 일반적인 I / O 특성의 가져 오기를 완화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c5176304cb4e1480563977bff5f9fc8f29f52bf7" translate="yes" xml:space="preserve">
          <source>The purpose of trait objects is to permit &quot;late binding&quot; of methods. Calling a method on a trait object results in virtual dispatch at runtime: that is, a function pointer is loaded from the trait object vtable and invoked indirectly. The actual implementation for each vtable entry can vary on an object-by-object basis.</source>
          <target state="translated">특성 객체의 목적은 메소드의 &quot;늦은 바인딩&quot;을 허용하는 것입니다. 특성 오브젝트에서 메소드를 호출하면 런타임시 가상 디스패치가 발생합니다. 즉, 특성 포인터가 특성 오브젝트 vtable에서로드되고 간접적으로 호출됩니다. 각 vtable 항목의 실제 구현은 개체별로 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f15fea39e76fdfafefd43bfce074d20361154e36" translate="yes" xml:space="preserve">
          <source>The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isn&amp;rsquo;t working as expected. You&amp;rsquo;ll put unit tests in the &lt;em&gt;src&lt;/em&gt; directory in each file with the code that they&amp;rsquo;re testing. The convention is to create a module named &lt;code&gt;tests&lt;/code&gt; in each file to contain the test functions and to annotate the module with &lt;code&gt;cfg(test)&lt;/code&gt;.</source>
          <target state="translated">단위 테스트의 목적은 나머지 코드와는 별도로 각 코드 단위를 테스트하여 코드가 예상대로 작동하지 않는 위치를 신속하게 찾아내는 것입니다. 테스트 할 코드와 함께 각 파일 의 &lt;em&gt;src&lt;/em&gt; 디렉토리에 단위 테스트를 배치합니다 . 규칙은 테스트 기능을 포함하고 &lt;code&gt;cfg(test)&lt;/code&gt; 모듈에 주석을 달기 위해 각 파일에 &lt;code&gt;tests&lt;/code&gt; 라는 모듈을 작성하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="60cba1f37e61726b832a14d7f1500e4426e9a5cc" translate="yes" xml:space="preserve">
          <source>The question mark operator</source>
          <target state="translated">물음표 연산자</target>
        </trans-unit>
        <trans-unit id="018537889ded2ab112f094946b8612c9a86b99ba" translate="yes" xml:space="preserve">
          <source>The question mark operator (&lt;code&gt;?&lt;/code&gt;) unwraps valid values or returns erroneous values, propagating them to the calling function. It is a unary postfix operator that can only be applied to the types &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; and &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">물음표 연산자 ( &lt;code&gt;?&lt;/code&gt; )는 유효한 값을 풀거나 잘못된 값을 반환하여 호출 함수로 전파합니다. 단항 접미사 연산자는 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 유형에만 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ea5d63d0d5a319dd6d9072a4460aea03a494584" translate="yes" xml:space="preserve">
          <source>The question mark operator, &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">물음표 연산자 &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61208bdae8b221a09aba4f839d74c11c2925c51c" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f32&lt;/code&gt; 의 내부 표현의 기수 또는 밑변입니다 .</target>
        </trans-unit>
        <trans-unit id="ea313a35fa236b37b46428fb2657491b2e33dea3" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f32&lt;/code&gt;. Use &lt;a href=&quot;../primitive.f32#associatedconstant.RADIX&quot;&gt;&lt;code&gt;f32::RADIX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;f32&lt;/code&gt; 내부 표현의 기수 또는 밑입니다 . 대신 &lt;a href=&quot;../primitive.f32#associatedconstant.RADIX&quot;&gt; &lt;code&gt;f32::RADIX&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc170d8fddda3392ca3bbfeb02d09cfb7f6a80ce" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f64&lt;/code&gt; 의 내부 표현의 기수 또는 밑변입니다 .</target>
        </trans-unit>
        <trans-unit id="eb77af93de4b13de0ebcbd9266a033e54a3960fe" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f64&lt;/code&gt;. Use &lt;a href=&quot;../primitive.f64#associatedconstant.RADIX&quot;&gt;&lt;code&gt;f64::RADIX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;f64&lt;/code&gt; 내부 표현의 기수 또는 밑입니다 . 대신 &lt;a href=&quot;../primitive.f64#associatedconstant.RADIX&quot;&gt; &lt;code&gt;f64::RADIX&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b9457bd197a286afc52dbcebb942e61605b222d" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;start..end&lt;/code&gt; contains all values with &lt;code&gt;start &amp;lt;= x &amp;lt; end&lt;/code&gt;. It is empty if &lt;code&gt;start &amp;gt;= end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510a943d569cb4f1080072d01ababcb91699bcc6" translate="yes" xml:space="preserve">
          <source>The range is empty if either side is incomparable:</source>
          <target state="translated">어느 쪽도 비교할 수 없으면 범위가 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7d43b8cf204eefd21645fceff96d69cfb297982" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to &lt;a href=&quot;struct.arc#method.into_raw&quot;&gt;&lt;code&gt;Arc&amp;lt;U&amp;gt;::into_raw&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;U&lt;/code&gt; must have the same size and alignment as &lt;code&gt;T&lt;/code&gt;. This is trivially true if &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;. Note that if &lt;code&gt;U&lt;/code&gt; is not &lt;code&gt;T&lt;/code&gt; but has the same size and alignment, this is basically like transmuting references of different types. See &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;mem::transmute&lt;/code&gt;&lt;/a&gt; for more information on what restrictions apply in this case.</source>
          <target state="translated">원시 포인터는 &lt;a href=&quot;struct.arc#method.into_raw&quot;&gt; &lt;code&gt;Arc&amp;lt;U&amp;gt;::into_raw&lt;/code&gt; &lt;/a&gt; 에 대한 호출에 의해 이전에 반환 되었어야합니다. 여기서 &lt;code&gt;U&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 와 크기 및 정렬이 동일해야합니다 . &lt;code&gt;U&lt;/code&gt; 가 &lt;code&gt;T&lt;/code&gt; 인 경우 이는 사소한 사실 입니다. 경우 참고 &lt;code&gt;U&lt;/code&gt; 가 아닌 &lt;code&gt;T&lt;/code&gt; 하지만 같은 크기와 정렬을 가지고,이 서로 다른 유형의 변형의 참조처럼 기본적이다. 이 경우에 적용되는 제한 사항에 대한 자세한 내용 은 &lt;a href=&quot;../mem/fn.transmute&quot;&gt; &lt;code&gt;mem::transmute&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7a2067413bc1879d44bf7542436c24e1555ca1bc" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to &lt;a href=&quot;struct.rc#method.into_raw&quot;&gt;&lt;code&gt;Rc&amp;lt;U&amp;gt;::into_raw&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;U&lt;/code&gt; must have the same size and alignment as &lt;code&gt;T&lt;/code&gt;. This is trivially true if &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;. Note that if &lt;code&gt;U&lt;/code&gt; is not &lt;code&gt;T&lt;/code&gt; but has the same size and alignment, this is basically like transmuting references of different types. See &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;mem::transmute&lt;/code&gt;&lt;/a&gt; for more information on what restrictions apply in this case.</source>
          <target state="translated">원시 포인터는 &lt;a href=&quot;struct.rc#method.into_raw&quot;&gt; &lt;code&gt;Rc&amp;lt;U&amp;gt;::into_raw&lt;/code&gt; &lt;/a&gt; 에 대한 호출에 의해 이전에 반환 되었어야합니다. 여기서 &lt;code&gt;U&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 와 크기와 정렬이 동일해야합니다 . &lt;code&gt;U&lt;/code&gt; 가 &lt;code&gt;T&lt;/code&gt; 인 경우 이는 사소한 사실 입니다. 경우 참고 &lt;code&gt;U&lt;/code&gt; 가 아닌 &lt;code&gt;T&lt;/code&gt; 하지만 같은 크기와 정렬을 가지고,이 서로 다른 유형의 변형의 참조처럼 기본적이다. 이 경우에 적용되는 제한 사항에 대한 자세한 내용 은 &lt;a href=&quot;../mem/fn.transmute&quot;&gt; &lt;code&gt;mem::transmute&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9cc134868dea70688318900dea4fb56c096c2fce" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to a &lt;a href=&quot;struct.arc#method.into_raw&quot;&gt;&lt;code&gt;Arc::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">원시 포인터는 &lt;a href=&quot;struct.arc#method.into_raw&quot;&gt; &lt;code&gt;Arc::into_raw&lt;/code&gt; &lt;/a&gt; 호출에 의해 이전에 반환되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cb442a6e9f4c3ea3ad88f7d20cbb90e50f086583" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to a &lt;a href=&quot;struct.rc#method.into_raw&quot;&gt;&lt;code&gt;Rc::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">원시 포인터는 이전에 &lt;a href=&quot;struct.rc#method.into_raw&quot;&gt; &lt;code&gt;Rc::into_raw&lt;/code&gt; &lt;/a&gt; 호출에 의해 리턴되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="61edb86c6e775bcbcc090bf0b2354d8086752aee" translate="yes" xml:space="preserve">
          <source>The re-ordering prevented by the different ordering semantics are:</source>
          <target state="translated">다른 순서 의미론에 의해 방지되는 재정렬은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db75fd7d163698847a2930407a821664ef9dc7a1" translate="yes" xml:space="preserve">
          <source>The reading portion of the &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; should be shut down.</source>
          <target state="translated">&lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; 의 읽기 부분을 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb2e18a8faa1f91810d19956a7143af41d8b7e9f" translate="yes" xml:space="preserve">
          <source>The reason for deprecation is that the function basically cannot be used correctly: &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;the Rust compiler assumes&lt;/a&gt; that values are properly initialized. As a consequence, calling e.g. &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; causes immediate undefined behavior for returning a &lt;code&gt;bool&lt;/code&gt; that is not definitely either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Worse, truly uninitialized memory like what gets returned here is special in that the compiler knows that it does not have a fixed value. This makes it undefined behavior to have uninitialized data in a variable even if that variable has an integer type. (Notice that the rules around uninitialized integers are not finalized yet, but until they are, it is advisable to avoid them.)</source>
          <target state="translated">더 이상 사용되지 않는 이유는 기본적으로 함수를 올바르게 사용할 수 없기 때문입니다. &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;Rust 컴파일러는&lt;/a&gt; 값이 올바르게 초기화되었다고 가정 합니다. 결과적으로, 예를 들어 &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; 호출 하면 확실히 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 가 아닌 &lt;code&gt;bool&lt;/code&gt; 을 반환하기 위해 즉시 정의되지 않은 동작이 발생합니다 . 더 나쁜 것은, 여기에 반환되는 것과 같이 초기화되지 않은 메모리는 컴파일러가 고정 값이 없다는 것을 알고 있다는 점에서 특별합니다. 따라서 변수에 정수 유형이 있더라도 변수에 초기화되지 않은 데이터가있는 정의되지 않은 동작이 발생합니다. (초기화되지 않은 정수에 관한 규칙은 아직 확정되지 않았지만 그 때까지는 피하는 것이 좋습니다.)</target>
        </trans-unit>
        <trans-unit id="0a840dd2de2cd2ee34a26f979453151250b4e843" translate="yes" xml:space="preserve">
          <source>The reason for deprecation is that the function basically cannot be used correctly: it has the same effect as &lt;a href=&quot;union.maybeuninit#method.uninit&quot;&gt;&lt;code&gt;MaybeUninit::uninit().assume_init()&lt;/code&gt;&lt;/a&gt;. As the &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt; documentation&lt;/a&gt; explains, &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;the Rust compiler assumes&lt;/a&gt; that values are properly initialized. As a consequence, calling e.g. &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; causes immediate undefined behavior for returning a &lt;code&gt;bool&lt;/code&gt; that is not definitely either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Worse, truly uninitialized memory like what gets returned here is special in that the compiler knows that it does not have a fixed value. This makes it undefined behavior to have uninitialized data in a variable even if that variable has an integer type. (Notice that the rules around uninitialized integers are not finalized yet, but until they are, it is advisable to avoid them.)</source>
          <target state="translated">지원 중단 이유는 기본적으로 함수를 올바르게 사용할 수 없기 때문 &lt;a href=&quot;union.maybeuninit#method.uninit&quot;&gt; &lt;code&gt;MaybeUninit::uninit().assume_init()&lt;/code&gt; &lt;/a&gt; 와 동일한 효과가 있습니다. &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;assume_init&lt;/code&gt; 문서에서&lt;/a&gt; 설명 하는 것처럼 &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;Rust 컴파일러는&lt;/a&gt; 값이 적절하게 초기화되었다고 가정 합니다. 결과적으로, 예를 들어 &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; 호출 하면 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 가 아닌 &lt;code&gt;bool&lt;/code&gt; 을 반환하는 즉시 정의되지 않은 동작이 발생합니다.. 더 나쁜 것은 여기에 반환되는 것과 같이 실제로 초기화되지 않은 메모리는 컴파일러가 고정 값이 없다는 것을 알고 있다는 점에서 특별합니다. 따라서 해당 변수에 정수 유형이 있더라도 변수에 초기화되지 않은 데이터가있는 정의되지 않은 동작이 있습니다. (초기화되지 않은 정수에 대한 규칙은 아직 확정되지 않았지만 완료되기 전까지는이를 피하는 것이 좋습니다.)</target>
        </trans-unit>
        <trans-unit id="d5d0c9e3177e947296d0e4cad464419f6391db88" translate="yes" xml:space="preserve">
          <source>The reason for this is that &lt;code&gt;rlib&lt;/code&gt; files do not contain any of their upstream dependencies. It wouldn't be very efficient for all &lt;code&gt;rlib&lt;/code&gt; files to contain a copy of &lt;code&gt;libstd.rlib&lt;/code&gt;!</source>
          <target state="translated">그 이유는 &lt;code&gt;rlib&lt;/code&gt; 파일에 업스트림 종속성이 포함되어 있지 않기 때문입니다 . 모든 &lt;code&gt;rlib&lt;/code&gt; 파일이 &lt;code&gt;libstd.rlib&lt;/code&gt; 의 사본을 포함하는 것은 그리 효율적이지 않습니다 !</target>
        </trans-unit>
        <trans-unit id="f95aa7105ee4000143fc92462b837053383a52a0" translate="yes" xml:space="preserve">
          <source>The reason for this is that there are two appearances of type parameter &lt;code&gt;T&lt;/code&gt; in the &lt;code&gt;impl&lt;/code&gt; header, both as parameters for &lt;code&gt;ForeignTrait2&lt;/code&gt;. The first appearance is uncovered, and so runs afoul of the orphan rule.</source>
          <target state="translated">그 이유 는 &lt;code&gt;impl&lt;/code&gt; 헤더에 &lt;code&gt;ForeignTrait2&lt;/code&gt; 에 대한 매개 변수로 두 개의 매개 변수 &lt;code&gt;T&lt;/code&gt; 유형이 모두 있기 때문 입니다. 첫 등장은 밝혀지지 않았으므로 고아 규칙을 어기 게됩니다.</target>
        </trans-unit>
        <trans-unit id="ef37c27a4f0dd2645ce86c85a75eac6a77fa29d9" translate="yes" xml:space="preserve">
          <source>The reason is that types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make. That means there&amp;rsquo;s no reason we would want to prevent &lt;code&gt;x&lt;/code&gt; from being valid after we create the variable &lt;code&gt;y&lt;/code&gt;. In other words, there&amp;rsquo;s no difference between deep and shallow copying here, so calling &lt;code&gt;clone&lt;/code&gt; wouldn&amp;rsquo;t do anything different from the usual shallow copying and we can leave it out.</source>
          <target state="translated">그 이유는 컴파일 타임에 알려진 크기를 가진 정수와 같은 유형이 스택에 완전히 저장되므로 실제 값의 사본을 빠르게 작성할 수 있기 때문입니다. 이것은 변수 &lt;code&gt;y&lt;/code&gt; 를 만든 후에 &lt;code&gt;x&lt;/code&gt; 가 유효 하지 않게 할 이유가 없다는 것을 의미 합니다 . 즉, 여기서는 딥 복사와 얕게 복사간에 차이 가 없으므로 &lt;code&gt;clone&lt;/code&gt; 호출 은 일반적인 얕은 복사와 다른 작업을 수행하지 않고 그대로 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c1ca57165d895e7b5a9a07fb8f81dd8e653560f" translate="yes" xml:space="preserve">
          <source>The reason is that you&amp;rsquo;re missing some crucial information: a description and license are required so people will know what your crate does and under what terms they can use it. To rectify this error, you need to include this information in the &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">그 이유는 중요한 정보가 누락 되었기 때문입니다. 설명과 라이센스가 필요하므로 사람들이 상자의 기능과 사용 가능한 용어를 알 수 있습니다. 이 오류를 해결하려면 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일 에이 정보를 포함 &lt;em&gt;시켜야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="87dec969a1d8a7fd52229930c681793b58499b7c" translate="yes" xml:space="preserve">
          <source>The reason is that, in the first example, there are many possible types that &lt;code&gt;!&lt;/code&gt; could coerce to, because many types implement &lt;code&gt;Add&amp;lt;u32&amp;gt;&lt;/code&gt;. However, in the second example, the &lt;code&gt;else&lt;/code&gt; branch returns a &lt;code&gt;0&lt;/code&gt;, which the compiler infers from the return type to be of type &lt;code&gt;u32&lt;/code&gt;. Since &lt;code&gt;u32&lt;/code&gt; is a concrete type, &lt;code&gt;!&lt;/code&gt; can and will be coerced to it. See issue &lt;a href=&quot;https://github.com/rust-lang/rust/issues/36375&quot;&gt;#36375&lt;/a&gt; for more information on this quirk of &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">그 이유는 첫 번째 예에서 &lt;code&gt;!&lt;/code&gt; 많은 유형이 &lt;code&gt;Add&amp;lt;u32&amp;gt;&lt;/code&gt; 구현하기 때문에 강제 할 수 있습니다. 그러나 두 번째 예제에서 &lt;code&gt;else&lt;/code&gt; 분기는 &lt;code&gt;0&lt;/code&gt; 을 반환하며 , 컴파일러는 반환 유형에서 &lt;code&gt;u32&lt;/code&gt; 유형으로 추론합니다 . 이후 &lt;code&gt;u32&lt;/code&gt; 구체적인 유형입니다 &lt;code&gt;!&lt;/code&gt; 강요 될 수 있습니다. 이 특성에 대한 자세한 내용 은 문제 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/36375&quot;&gt;# 36375&lt;/a&gt; 를 참조하십시오 &lt;code&gt;!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="725753993f38910ecfb713203cf3afe96ff590f2" translate="yes" xml:space="preserve">
          <source>The reason that this matter is that the type &lt;code&gt;fn(S)&lt;/code&gt; is not specific to any particular function: it's a function &lt;em&gt;pointer&lt;/em&gt;. So calling &lt;code&gt;x()&lt;/code&gt; results in a virtual call, whereas &lt;code&gt;foo()&lt;/code&gt; is statically dispatched, because the type of &lt;code&gt;foo&lt;/code&gt; tells us precisely what function is being called.</source>
          <target state="translated">이 문제가 발생하는 이유는 &lt;code&gt;fn(S)&lt;/code&gt; 유형 이 특정 함수에 고유하지 않기 때문 입니다. 함수 &lt;em&gt;포인터&lt;/em&gt; 입니다. 따라서 &lt;code&gt;x()&lt;/code&gt; 호출 하면 가상 호출이 발생하지만 &lt;code&gt;foo()&lt;/code&gt; 는 정적으로 전달됩니다. &lt;code&gt;foo&lt;/code&gt; 의 유형은 어떤 함수가 호출되는지를 정확하게 알려주기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="2f71ddaa6e32a7d6efaff9da8a4ddd4766615cbe" translate="yes" xml:space="preserve">
          <source>The reason the &lt;code&gt;deref&lt;/code&gt; method returns a reference to a value, and that the plain dereference outside the parentheses in &lt;code&gt;*(y.deref())&lt;/code&gt; is still necessary, is the ownership system. If the &lt;code&gt;deref&lt;/code&gt; method returned the value directly instead of a reference to the value, the value would be moved out of &lt;code&gt;self&lt;/code&gt;. We don&amp;rsquo;t want to take ownership of the inner value inside &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; in this case or in most cases where we use the dereference operator.</source>
          <target state="translated">그 이유는 &lt;code&gt;deref&lt;/code&gt; 있어서의 값에 대한 참조를 반환하고있는 괄호 밖의 일반한다는 간접 참조 &lt;code&gt;*(y.deref())&lt;/code&gt; 여전히 필요하다 소유권 시스템이다. 경우] &lt;code&gt;deref&lt;/code&gt; 있어서의 값에 대한 언급 대신 직접 값을 리턴 값은 외부로 이동 될 &lt;code&gt;self&lt;/code&gt; . 이 경우 또는 역 참조 연산자를 사용하는 대부분의 경우 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 내부의 내부 값을 소유하고 싶지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1d62bb1a32655921533dae07c7931836afe25a19" translate="yes" xml:space="preserve">
          <source>The reason this function compiles without lifetime annotations is historical: in early versions (pre-1.0) of Rust, this code wouldn&amp;rsquo;t have compiled because every reference needed an explicit lifetime. At that time, the function signature would have been written like this:</source>
          <target state="translated">이 함수가 수명 주석없이 컴파일되는 이유는 역사적입니다. Rust의 초기 버전 (1.0 이전)에서는 모든 참조에 명시적인 수명이 필요했기 때문에이 코드는 컴파일되지 않았습니다. 당시 함수 서명은 다음과 같이 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="bedb5e3116e5d92919b43a452878e5db1b96099b" translate="yes" xml:space="preserve">
          <source>The reason we&amp;rsquo;re able to use &lt;code&gt;&amp;amp;s2&lt;/code&gt; in the call to &lt;code&gt;add&lt;/code&gt; is that the compiler can &lt;em&gt;coerce&lt;/em&gt; the &lt;code&gt;&amp;amp;String&lt;/code&gt; argument into a &lt;code&gt;&amp;amp;str&lt;/code&gt;. When we call the &lt;code&gt;add&lt;/code&gt; method, Rust uses a &lt;em&gt;deref coercion&lt;/em&gt;, which here turns &lt;code&gt;&amp;amp;s2&lt;/code&gt; into &lt;code&gt;&amp;amp;s2[..]&lt;/code&gt;. We&amp;rsquo;ll discuss deref coercion in more depth in Chapter 15. Because &lt;code&gt;add&lt;/code&gt; does not take ownership of the &lt;code&gt;s&lt;/code&gt; parameter, &lt;code&gt;s2&lt;/code&gt; will still be a valid &lt;code&gt;String&lt;/code&gt; after this operation.</source>
          <target state="translated">우리가 사용할 수있는 이유 &lt;code&gt;&amp;amp;s2&lt;/code&gt; 호출에 &lt;code&gt;add&lt;/code&gt; 컴파일러 수 있다는 것입니다 &lt;em&gt;강요 &lt;/em&gt; &lt;code&gt;&amp;amp;String&lt;/code&gt; 에 인수 &lt;code&gt;&amp;amp;str&lt;/code&gt; . &lt;code&gt;add&lt;/code&gt; 메소드를 호출 할 때 Rust는 &lt;em&gt;deref coercion을&lt;/em&gt; 사용하는데 , 여기서 &lt;code&gt;&amp;amp;s2&lt;/code&gt; 는 &lt;code&gt;&amp;amp;s2[..]&lt;/code&gt; 로 바뀝니다 . 때문에 우리는 제 15 장에서 더 깊이 DEREF 강제 논의 할 것이다 &lt;code&gt;add&lt;/code&gt; 의 소유권을지지 않습니다 &lt;code&gt;s&lt;/code&gt; 매개 변수를, &lt;code&gt;s2&lt;/code&gt; 여전히 유효합니다 &lt;code&gt;String&lt;/code&gt; 이 작업 후.</target>
        </trans-unit>
        <trans-unit id="f3cfdfa90a10325648e4c2eb952b413419929140" translate="yes" xml:space="preserve">
          <source>The receiver of a method, or the current module.</source>
          <target state="translated">메소드의 수신자 또는 현재 모듈</target>
        </trans-unit>
        <trans-unit id="d73164a885c270ed79f7ee9c783984160bde564d" translate="yes" xml:space="preserve">
          <source>The receiving end of a channel has two useful methods: &lt;code&gt;recv&lt;/code&gt; and &lt;code&gt;try_recv&lt;/code&gt;. We&amp;rsquo;re using &lt;code&gt;recv&lt;/code&gt;, short for &lt;em&gt;receive&lt;/em&gt;, which will block the main thread&amp;rsquo;s execution and wait until a value is sent down the channel. Once a value is sent, &lt;code&gt;recv&lt;/code&gt; will return it in a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. When the sending end of the channel closes, &lt;code&gt;recv&lt;/code&gt; will return an error to signal that no more values will be coming.</source>
          <target state="translated">채널의 수신 &lt;code&gt;try_recv&lt;/code&gt; &lt;code&gt;recv&lt;/code&gt; 및 try_recv의 두 가지 유용한 방법이 있습니다. &lt;em&gt;receive&lt;/em&gt; , short의 &lt;code&gt;recv&lt;/code&gt; 를 사용 하여 메인 스레드의 실행을 차단하고 값이 채널로 전송 될 때까지 기다립니다. 값이 전송되면 &lt;code&gt;recv&lt;/code&gt; 는 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 반환합니다 . 채널의 &lt;code&gt;recv&lt;/code&gt; 이 닫히면 recv 는 더 이상 값이 오지 않을 것이라는 신호를 보내기 위해 오류를 반환합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb4caae3b66529c5330d18c3a08329f2bc2f3deb" translate="yes" xml:space="preserve">
          <source>The receiving half of Rust's &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;) type. This half can only be owned by one thread.</source>
          <target state="translated">Rust &lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt; ) 유형 의 수신 절반입니다 . 이 절반은 하나의 스레드 만 소유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b2bfb185407e4c60c25d227a4ff77b2cda29f86" translate="yes" xml:space="preserve">
          <source>The reference count of the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instances in both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 2 after we change the list in &lt;code&gt;a&lt;/code&gt; to point to &lt;code&gt;b&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, Rust will try to drop &lt;code&gt;b&lt;/code&gt; first, which will decrease the count of the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance in &lt;code&gt;b&lt;/code&gt; by 1.</source>
          <target state="translated">의 레퍼런스 카운트 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 모두 인스턴스 및 &lt;code&gt;b&lt;/code&gt; 우리의 목록을 변경 한 후 2이다 에 지점 &lt;code&gt;b&lt;/code&gt; . 의 마지막 &lt;code&gt;main&lt;/code&gt; , 녹 드롭하려고 할 &lt;code&gt;b&lt;/code&gt; 의 카운트 감소하는 제 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 에서 예를 &lt;code&gt;b&lt;/code&gt; 1. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0309be91bd54044d4044342a0389163de0a934e4" translate="yes" xml:space="preserve">
          <source>The region of memory beginning at &lt;code&gt;src&lt;/code&gt; with a size of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes must &lt;em&gt;not&lt;/em&gt; overlap with the region of memory beginning at &lt;code&gt;dst&lt;/code&gt; with the same size.</source>
          <target state="translated">처음에, 메모리의 영역 &lt;code&gt;src&lt;/code&gt; 의 크기와 &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 바이트해야 &lt;em&gt;하지&lt;/em&gt; 오버랩에서 시작하는 메모리의 영역과 &lt;code&gt;dst&lt;/code&gt; 동일한 크기.</target>
        </trans-unit>
        <trans-unit id="5dcc17f2dc1b8084d38071ff6ddcb2865d4ada36" translate="yes" xml:space="preserve">
          <source>The region of memory beginning at &lt;code&gt;x&lt;/code&gt; with a size of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes must &lt;em&gt;not&lt;/em&gt; overlap with the region of memory beginning at &lt;code&gt;y&lt;/code&gt; with the same size.</source>
          <target state="translated">처음에, 메모리의 영역 &lt;code&gt;x&lt;/code&gt; 의 크기와 &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 되어야하는 바이트 &lt;em&gt;하지&lt;/em&gt; 오버랩에서 시작하는 메모리의 영역으로 &lt;code&gt;y&lt;/code&gt; 와 동일한 크기.</target>
        </trans-unit>
        <trans-unit id="6e24cbd3ed4b7a19863f8c010bc7cecf513544b8" translate="yes" xml:space="preserve">
          <source>The relative order of partitioned items is not maintained.</source>
          <target state="translated">분할 된 항목의 상대적 순서는 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="27d262cc92a6d55445ae1cc06ba8d24d6a4bfc8a" translate="yes" xml:space="preserve">
          <source>The relevant &lt;code&gt;use&lt;/code&gt; statements</source>
          <target state="translated">관련 &lt;code&gt;use&lt;/code&gt; 진술</target>
        </trans-unit>
        <trans-unit id="92055677c3977ae45c2e91b99d3cb2b7bc2e7a00" translate="yes" xml:space="preserve">
          <source>The remainder assignment operator &lt;code&gt;%=&lt;/code&gt;.</source>
          <target state="translated">나머지 할당 연산자 &lt;code&gt;%=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e1e6181542061352f1920b8d99d81207a670f7f" translate="yes" xml:space="preserve">
          <source>The remainder from the division of two floats.</source>
          <target state="translated">두 개의 수레를 나눈 나머지.</target>
        </trans-unit>
        <trans-unit id="054039eee5819e5face98778f38bf1e0291c343e" translate="yes" xml:space="preserve">
          <source>The remainder has the same sign as the dividend and is computed as: &lt;code&gt;x - (x / y).trunc() * y&lt;/code&gt;.</source>
          <target state="translated">나머지는 피제수와 같은 부호를 가지며 &lt;code&gt;x - (x / y).trunc() * y&lt;/code&gt; 로 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="5654d619adf6380504b572e1ea12d7691a4525f9" translate="yes" xml:space="preserve">
          <source>The remainder operator &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="translated">나머지 연산자 &lt;code&gt;%&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b313ceee14929f12b1b754da920f2c480594a9a" translate="yes" xml:space="preserve">
          <source>The remaining characters are alphanumeric or &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">나머지 문자는 영숫자 또는 &lt;code&gt;_&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="db31fc17b3b16891bdde4b2e11c17a8b55001a20" translate="yes" xml:space="preserve">
          <source>The removed element is replaced by the last element of the vector.</source>
          <target state="translated">제거 된 요소는 벡터의 마지막 요소로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="bdcb1bbcfc5506185f4dcdac6bb92b93d0ea27b3" translate="yes" xml:space="preserve">
          <source>The repeated fragment both matches and transcribes to the specified number of the fragment, separated by the separator token. Metavariables are matched to every repetition of their corresponding fragment. For instance, the &lt;code&gt;$( $i:ident ),*&lt;/code&gt; example above matches &lt;code&gt;$i&lt;/code&gt; to all of the identifiers in the list.</source>
          <target state="translated">반복되는 프래그먼트는 구분자 토큰으로 분리 된 지정된 수의 프래그먼트와 일치하고 기록합니다. 메타 변수는 해당 단편의 모든 반복과 일치합니다. 예를 들어, 위의 &lt;code&gt;$( $i:ident ),*&lt;/code&gt; 예제는 &lt;code&gt;$i&lt;/code&gt; 를 목록의 모든 식별자 와 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="12103d0e7fb92d8d3b9ddae239cdf39dea7eeb65" translate="yes" xml:space="preserve">
          <source>The repetition operators are:</source>
          <target state="translated">반복 연산자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bfcbf2851f89edd4f300f9b36ba95aadb203f98e" translate="yes" xml:space="preserve">
          <source>The representation does &lt;em&gt;not&lt;/em&gt; look like Figure 4-3, which is what memory would look like if Rust instead copied the heap data as well. If Rust did this, the operation &lt;code&gt;s2 = s1&lt;/code&gt; could be very expensive in terms of runtime performance if the data on the heap were large.</source>
          <target state="translated">이 표현은 그림 4-3과 같지 &lt;em&gt;않습니다&lt;/em&gt; . 이는 Rust가 힙 데이터를 대신 복사 한 경우의 메모리 모양입니다. Rust에서이 작업을 수행 한 경우 힙의 데이터가 큰 경우 &lt;code&gt;s2 = s1&lt;/code&gt; 작업 은 런타임 성능 측면에서 매우 비쌀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b1df299f3611946c8ad866e3a9d4772fabb543c" translate="yes" xml:space="preserve">
          <source>The representation of a &lt;code&gt;repr(C)&lt;/code&gt; enum with fields is a &lt;code&gt;repr(C)&lt;/code&gt; struct with two fields, also called a &quot;tagged union&quot; in C:</source>
          <target state="translated">필드가 있는 &lt;code&gt;repr(C)&lt;/code&gt; 열거 형 의 표현은 두 개의 필드 가있는 &lt;code&gt;repr(C)&lt;/code&gt; 구조체이며 C 에서는 &quot;태그 된 유니온&quot;이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="a3948c1d71b2273d20d352ff100e99a529e9f18b" translate="yes" xml:space="preserve">
          <source>The representation of a primitive representation enum is a &lt;code&gt;repr(C)&lt;/code&gt; union of &lt;code&gt;repr(C)&lt;/code&gt; structs for each variant with a field. The first field of each struct in the union is the primitive representation version of the enum with all fields removed (&quot;the tag&quot;) and the remaining fields are the fields of that variant.</source>
          <target state="translated">기본 표현 열거 형의 표현은 필드가있는 각 변형에 대한 &lt;code&gt;repr(C)&lt;/code&gt; 구조체 의 &lt;code&gt;repr(C)&lt;/code&gt; 결합입니다 . 공용체의 각 구조체의 첫 번째 필드는 모든 필드가 제거 된 ( &quot;태그&quot;) 열거 형의 기본 표현 버전이며 나머지 필드는 해당 변형의 필드입니다.</target>
        </trans-unit>
        <trans-unit id="ef3b4092c2efea2b55e7548a736c3333a566aec1" translate="yes" xml:space="preserve">
          <source>The representation of a trait object like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; 과 같은 특성 오브젝트의 표현 .</target>
        </trans-unit>
        <trans-unit id="4110c125de481ad527206c93b01dbedc11c02bc7" translate="yes" xml:space="preserve">
          <source>The representation of a trait object like &lt;code&gt;&amp;amp;dyn SomeTrait&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;dyn SomeTrait&lt;/code&gt; 과 같은 특성 객체의 표현 .</target>
        </trans-unit>
        <trans-unit id="84fd9c512efc7dcedf9b018795fbba5c08fc5ad5" translate="yes" xml:space="preserve">
          <source>The representation of a type can be changed by applying the &lt;code&gt;repr&lt;/code&gt; attribute to it. The following example shows a struct with a &lt;code&gt;C&lt;/code&gt; representation.</source>
          <target state="translated">&lt;code&gt;repr&lt;/code&gt; 속성을 적용하여 유형 표현을 변경할 수 있습니다 . 다음 예제는 &lt;code&gt;C&lt;/code&gt; 표현을 가진 구조체를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="5a8aa6aa295a219e257360fdb9ca2113bb7bc323" translate="yes" xml:space="preserve">
          <source>The representation of a type can change the padding between fields, but does not change the layout of the fields themselves. For example, a struct with a &lt;code&gt;C&lt;/code&gt; representation that contains a struct &lt;code&gt;Inner&lt;/code&gt; with the default representation will not change the layout of &lt;code&gt;Inner&lt;/code&gt;.</source>
          <target state="translated">유형 표현은 필드 사이의 패딩을 변경할 수 있지만 필드 자체의 레이아웃은 변경하지 않습니다. 예를 들어,와 구조체 &lt;code&gt;C&lt;/code&gt; 의 구조체 포함 표현 &lt;code&gt;Inner&lt;/code&gt; 기본 표현과는 레이아웃이 변경되지 않습니다 &lt;code&gt;Inner&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8de668564b1808c69c7a252869635782239a849b" translate="yes" xml:space="preserve">
          <source>The representation semantics of floating-point numbers are described in &lt;a href=&quot;types/numeric&quot;&gt;&quot;Machine Types&quot;&lt;/a&gt;.</source>
          <target state="translated">부동 소수점 숫자의 표현 의미는 &lt;a href=&quot;types/numeric&quot;&gt;&quot;기계 유형&quot;에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="568b4d39b3d684710e1069cdb58107435b4ee105" translate="yes" xml:space="preserve">
          <source>The requested ABI is unsupported by the current target.</source>
          <target state="translated">요청한 ABI가 현재 대상에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6079a0a7d416189b9655a6ad531ff1787c361185" translate="yes" xml:space="preserve">
          <source>The required alignment of the referenced value.</source>
          <target state="translated">참조 된 값의 필수 정렬입니다.</target>
        </trans-unit>
        <trans-unit id="48f41ba31da382f1ab342b312f6ebecf708e0a4f" translate="yes" xml:space="preserve">
          <source>The required inputs are these:</source>
          <target state="translated">필요한 입력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f6ffffcc1dc56ad2b07c96ba04b8dfcf628fd050" translate="yes" xml:space="preserve">
          <source>The requirements for this program haven&amp;rsquo;t been agreed upon yet, and we&amp;rsquo;re pretty sure the &lt;code&gt;Hello&lt;/code&gt; text at the beginning of the greeting will change. We decided we don&amp;rsquo;t want to have to update the test when the requirements change, so instead of checking for exact equality to the value returned from the &lt;code&gt;greeting&lt;/code&gt; function, we&amp;rsquo;ll just assert that the output contains the text of the input parameter.</source>
          <target state="translated">이 프로그램의 요구 사항은 아직 합의되지 않았 으며 인사말 시작 부분의 &lt;code&gt;Hello&lt;/code&gt; 텍스트가 변경 될 것입니다. 요구 사항이 변경 될 때 테스트를 업데이트하지 않기로 결정했기 때문에 &lt;code&gt;greeting&lt;/code&gt; 함수 에서 반환 된 값과 정확히 같은지 확인하는 대신 출력에 입력 매개 변수의 텍스트가 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="0cbf837e1937a12c606036644e82391851dc8756" translate="yes" xml:space="preserve">
          <source>The responsibilities that remain in the &lt;code&gt;main&lt;/code&gt; function after this process should be limited to the following:</source>
          <target state="translated">이 프로세스 후에 &lt;code&gt;main&lt;/code&gt; 기능에 남아있는 책임 은 다음으로 제한되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fb88378aaf4cdd384feeec625a8c476a227f1fe6" translate="yes" xml:space="preserve">
          <source>The rest of the traits defined in the standard library can&amp;rsquo;t be implemented on your types using &lt;code&gt;derive&lt;/code&gt;. These traits don&amp;rsquo;t have sensible default behavior, so it&amp;rsquo;s up to you to implement them in the way that makes sense for what you&amp;rsquo;re trying to accomplish.</source>
          <target state="translated">표준 라이브러리에 정의 된 나머지 특성 &lt;code&gt;derive&lt;/code&gt; 사용하여 유형에 구현할 수 없습니다 . 이러한 특성은 합리적인 기본 동작을 갖지 않으므로 달성하려는 작업에 적합한 방식으로 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a3c86e891d6ad8a6d17dd1936fd9bfccb1b62f4" translate="yes" xml:space="preserve">
          <source>The rest of this book uses commands that work in both &lt;em&gt;cmd.exe&lt;/em&gt; and PowerShell. If there are specific differences, we&amp;rsquo;ll explain which to use.</source>
          <target state="translated">이 설명서의 나머지 부분에서는 &lt;em&gt;cmd.exe&lt;/em&gt; 와 PowerShell 에서 작동하는 명령을 사용합니다 . 구체적인 차이점이 있으면 사용할 것을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="00dd9e9169ec993decc3de54bbe98c364e0e7806" translate="yes" xml:space="preserve">
          <source>The rest of this crate documentation is dedicated to pointing out notable features of The Rust Standard Library.</source>
          <target state="translated">이 크레이트 문서의 나머지 부분은 Rust 표준 라이브러리의 주목할만한 기능을 지적하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="ac1c550b13307d7f1181fa4746cc5e5943901d94" translate="yes" xml:space="preserve">
          <source>The rest pattern is always irrefutable.</source>
          <target state="translated">나머지 패턴은 항상 반박 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b0cd0ab16fb284f9bcdd09aeae886a98592a2f2d" translate="yes" xml:space="preserve">
          <source>The result can be cast to a pointer of any kind. Ensure that the access is unique (no active references, mutable or not) when casting to &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, and ensure that there are no mutations or mutable aliases going on when casting to &lt;code&gt;&amp;amp;T&lt;/code&gt;.</source>
          <target state="translated">결과는 모든 종류의 포인터로 캐스트 될 수 있습니다. &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 캐스팅 할 때 액세스가 고유한지 (활성 참조 없음, 변경 가능 여부) 확인하고 &lt;code&gt;&amp;amp;T&lt;/code&gt; 캐스팅 할 때 진행되는 변경 또는 변경 가능한 별칭이 없는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="c54e546283bfd6f5bb35e08c8e91500e43fa3efb" translate="yes" xml:space="preserve">
          <source>The result is allocated on the heap.</source>
          <target state="translated">결과는 힙에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="9f60835a1f670fd1068b73e7310483f7414303f8" translate="yes" xml:space="preserve">
          <source>The result may not be correctly rounded owing to implementation details; &lt;code&gt;self.log2()&lt;/code&gt; can produce more accurate results for base 2, and &lt;code&gt;self.log10()&lt;/code&gt; can produce more accurate results for base 10.</source>
          <target state="translated">구현 세부 사항으로 인해 결과가 올바르게 반올림되지 않을 수 있습니다. &lt;code&gt;self.log2()&lt;/code&gt; 는 기수 2에 대해보다 정확한 결과를 생성 할 수 있고 &lt;code&gt;self.log10()&lt;/code&gt; 은 기수 10에 대해보다 정확한 결과를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4dbebfb961a1bddcfad953b06a027b749fbba28" translate="yes" xml:space="preserve">
          <source>The result of &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereferencing&lt;/a&gt; an expression with type &lt;a href=&quot;../std/boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and that can also be moved out of.</source>
          <target state="translated">유형이 &lt;a href=&quot;../std/boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 인 표현식 을 &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;역 참조한&lt;/a&gt; 결과 도 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe2526308745be82b19ed557143eb06c9172e9c2" translate="yes" xml:space="preserve">
          <source>The result of a generator resumption.</source>
          <target state="translated">발전기 재개 결과입니다.</target>
        </trans-unit>
        <trans-unit id="d471d20c06ef14c004fab8262f7528514deaa1c4" translate="yes" xml:space="preserve">
          <source>The result of casting a reference to a pointer is valid for as long as the underlying object is live and no reference (just raw pointers) is used to access the same memory.</source>
          <target state="translated">포인터에 대한 참조를 캐스트 한 결과는 기본 객체가 존재하고 동일한 메모리에 액세스하는 데 참조 (원시 포인터)가 사용되지 않는 한 유효합니다.</target>
        </trans-unit>
        <trans-unit id="ac56fae426229e4d543dba38661557fbee8bb52d" translate="yes" xml:space="preserve">
          <source>The result of the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro is a value of type &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This structure can then be passed to the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; functions inside this module in order to process the format string. The goal of this macro is to even further prevent intermediate allocations when dealing with formatting strings.</source>
          <target state="translated">&lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt; 의 결과 macro는 &lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt; 유형의 값입니다 . 그런 다음이 구조는 형식 문자열을 처리하기 위해이 모듈 내의 &lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt; 함수에 전달 될 수 있습니다 . 이 매크로의 목표는 형식화 문자열을 처리 할 때 중간 할당을 더욱 방지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="31cd246d6c4827dc128a4e9ac189ceccd07f4e85" translate="yes" xml:space="preserve">
          <source>The result of the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro is a value of type &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This structure can then be passed to the &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; functions inside this module in order to process the format string. The goal of this macro is to even further prevent intermediate allocations when dealing formatting strings.</source>
          <target state="translated">&lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt; 의 결과 ! 매크로는 &lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt; 유형의 값입니다 . 그런 다음이 구조를 형식 문자열을 처리하기 위해이 모듈 내의 &lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fn.format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt; 함수에 전달할 수 있습니다 . 이 매크로의 목표는 형식화 문자열을 처리 할 때 중간 할당을 추가로 방지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1c32345d3d6f612f235d03a8cd84044465cbfeea" translate="yes" xml:space="preserve">
          <source>The result will represent the IP address &lt;code&gt;a:b:c:d:e:f:g:h&lt;/code&gt;.</source>
          <target state="translated">결과는 IP 주소 &lt;code&gt;a:b:c:d:e:f:g:h&lt;/code&gt; 를 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="99c7c63b15fc6ea4f165265a5fd114fc5db86d31" translate="yes" xml:space="preserve">
          <source>The result will represent the IP address &lt;code&gt;a&lt;/code&gt;.&lt;code&gt;b&lt;/code&gt;.&lt;code&gt;c&lt;/code&gt;.&lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">결과는 IP 주소 &lt;code&gt;a&lt;/code&gt; 를 나타냅니다 . &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;c&lt;/code&gt; . &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7373e6f7caa0a9dff8d78cf60558cf221157bd80" translate="yes" xml:space="preserve">
          <source>The resulting layout will be the same as that of a C struct containing two fields with the layouts of &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;, in that order.</source>
          <target state="translated">결과 레이아웃은 &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;next&lt;/code&gt; 레이아웃 이 순서대로 있는 두 개의 필드를 포함하는 C 구조체의 레이아웃과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="99a0997f56bdadd8bd20428a4a2ef3bbae789fac" translate="yes" xml:space="preserve">
          <source>The resulting lifetime is bound to self so this behaves &quot;as if&quot; it were actually an instance of T that is getting borrowed. If a longer (unbound) lifetime is needed, use &lt;code&gt;&amp;amp;*my_ptr.as_ptr()&lt;/code&gt;.</source>
          <target state="translated">그 결과로 생기는 수명은 자기 자신에 묶여 있기 때문에 실제로 &quot;빌려 오는&quot;T의 인스턴스 인 것처럼 &quot;있는 것처럼&quot;동작합니다. 더 긴 (바운드되지 않은) 수명이 필요한 경우 &lt;code&gt;&amp;amp;*my_ptr.as_ptr()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f78e2e736259493757a0ced96e6b992b486267c6" translate="yes" xml:space="preserve">
          <source>The resulting lifetime is bound to self so this behaves &quot;as if&quot; it were actually an instance of T that is getting borrowed. If a longer (unbound) lifetime is needed, use &lt;code&gt;&amp;amp;mut *my_ptr.as_ptr()&lt;/code&gt;.</source>
          <target state="translated">그 결과로 생기는 수명은 자기 자신에 묶여 있기 때문에 실제로 &quot;빌려 오는&quot;T의 인스턴스 인 것처럼 &quot;있는 것처럼&quot;동작합니다. 더 긴 (바운드되지 않은) 수명이 필요한 경우 &lt;code&gt;&amp;amp;mut *my_ptr.as_ptr()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9220ca335fae6d1972b4901944a1126d0f38ae8e" translate="yes" xml:space="preserve">
          <source>The resulting pointer does not need to be in bounds, but it is potentially hazardous to dereference (which requires &lt;code&gt;unsafe&lt;/code&gt;).</source>
          <target state="translated">결과 포인터는 경계에있을 필요는 없지만 역 참조에 위험 할 수 있습니다 ( &lt;code&gt;unsafe&lt;/code&gt; 필요 ).</target>
        </trans-unit>
        <trans-unit id="81b4f59283eb3ce773831a86dd58d26e19da85b4" translate="yes" xml:space="preserve">
          <source>The resulting pointer does not need to be in bounds, but it is potentially hazardous to dereference (which requires &lt;code&gt;unsafe&lt;/code&gt;). In particular, the resulting pointer may &lt;em&gt;not&lt;/em&gt; be used to access a different allocated object than the one &lt;code&gt;self&lt;/code&gt; points to. In other words, &lt;code&gt;x.wrapping_offset(y.wrapping_offset_from(x))&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; the same as &lt;code&gt;y&lt;/code&gt;, and dereferencing it is undefined behavior unless &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; point into the same allocated object.</source>
          <target state="translated">결과 포인터는 경계에있을 필요는 없지만 역 참조에 위험 할 수 있습니다 ( &lt;code&gt;unsafe&lt;/code&gt; 필요 ). 특히, 결과 포인터는 &lt;code&gt;self&lt;/code&gt; 가리키는 것과 다른 할당 된 객체에 액세스하는 데 사용 &lt;em&gt;되지 않을&lt;/em&gt; 수 있습니다 . 즉, &lt;code&gt;x.wrapping_offset(y.wrapping_offset_from(x))&lt;/code&gt; 는 &lt;code&gt;y&lt;/code&gt; 와 같지 &lt;em&gt;않으며&lt;/em&gt; , &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 동일한 할당 된 객체를 가리 키지 않으면이를 정의하지 않은 동작 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="52dcba8fc55d983793d49be111c09fcb50eb3b76" translate="yes" xml:space="preserve">
          <source>The resulting pointer will have provenance of &lt;code&gt;val&lt;/code&gt;, i.e., for a fat pointer, this operation is semantically the same as creating a new fat pointer with the data pointer value of &lt;code&gt;val&lt;/code&gt; but the metadata of &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">결과 포인터는 &lt;code&gt;val&lt;/code&gt; 의 출처를 가질 것입니다 . 즉, fat 포인터의 경우이 작업은 데이터 포인터 값이 &lt;code&gt;val&lt;/code&gt; 이지만 &lt;code&gt;self&lt;/code&gt; 의 메타 데이터를 사용하여 새 fat 포인터를 만드는 것과 의미 상 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="277fa9ca5234a7d85c4310d360b586b5679536d7" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;!&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; 를 적용한 후 결과 유형 운영자.</target>
        </trans-unit>
        <trans-unit id="e0fff7e85f4e0422c5e3edd89994815fd0fa33fe" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; 연산자를 적용한 후 결과 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="bb2df529c05fcb3e3ae1db4ab5bf5c9f054fbf92" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;amp;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; 를 적용한 후 결과 유형 연산자를 입니다.</target>
        </trans-unit>
        <trans-unit id="36522abccd158f4a83c30f6cbe7b1f733a467a76" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 연산자를 적용한 후 결과 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="1fe31e03010cc02b7a70dec74838acc1bf92f653" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 연산자를 적용한 후 결과 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="49f0b7e4d4d9571dc029b144b407d2d00db70bde" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;*&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 연산자를 적용한 후 결과 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="5440b4202f92f92a6ad5f44ab02bb1836dc990f2" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;+&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 연산자를 적용한 후 결과 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="4a8bf360ec637ebc225332beb0f574739bca97a7" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;-&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 연산자를 적용한 후 결과 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="541f705e1fd40afef0d79bd7f0f4268fa7398a27" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;/&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; 연산자를 적용한 후 결과 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="5fff5e225b75cdf382af9bb7542d50be9c4363ed" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;^&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; 연산자를 적용한 후 결과 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="fee8ba95ad793c2c7dda2e8911dcb02800ab8ed4" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;|&lt;/code&gt; operator.</source>
          <target state="translated">적용 후 결과 유형 &lt;code&gt;|&lt;/code&gt; 운영자.</target>
        </trans-unit>
        <trans-unit id="0473503cf115b2a975e15da3f35244db7bce3d66" translate="yes" xml:space="preserve">
          <source>The resulting type after concatenation</source>
          <target state="translated">연결 후 결과 유형</target>
        </trans-unit>
        <trans-unit id="dbf5bd29abfe066aae072317675dfaca543c15fe" translate="yes" xml:space="preserve">
          <source>The resulting type after dereferencing.</source>
          <target state="translated">역 참조 후 결과 유형.</target>
        </trans-unit>
        <trans-unit id="76a4c8bb9eba17c026c554fa00db407a4ed92a09" translate="yes" xml:space="preserve">
          <source>The resulting type after obtaining ownership.</source>
          <target state="translated">소유권을 얻은 후 결과 유형.</target>
        </trans-unit>
        <trans-unit id="04c53e531d342d2fc7cb2f6812bb0980d9b695cc" translate="yes" xml:space="preserve">
          <source>The resulting vector can be converted back into a box via &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;'s &lt;code&gt;into_boxed_slice&lt;/code&gt; method.</source>
          <target state="translated">결과 벡터는 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 의 &lt;code&gt;into_boxed_slice&lt;/code&gt; 메소드 를 통해 상자로 다시 변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c631dfaa5b94e5b7afa0d3baba880ecf32c3c788" translate="yes" xml:space="preserve">
          <source>The return type in the desugaring is assumed to capture all lifetime parameters from the &lt;code&gt;async fn&lt;/code&gt; declaration. This can be seen in the desugared example above, which explicitly outlives, and hence captures, &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">desugaring의 반환 유형은 &lt;code&gt;async fn&lt;/code&gt; 선언 에서 모든 수명 매개 변수를 캡처하는 것으로 가정합니다 . 이것은 위의 desugared 예제에서 볼 수 있으며, 명시 적으로 수명이 연장되어 &lt;code&gt;'a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b3c91f66fb428df18fd8a3b968cf270fb22e4f6" translate="yes" xml:space="preserve">
          <source>The return type isn&amp;rsquo;t &lt;code&gt;Self&lt;/code&gt;.</source>
          <target state="translated">반환 유형은 &lt;code&gt;Self&lt;/code&gt; 가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="87f17fcd6dd95b0936e246de85107f7f76aa4067" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_debug&quot;&gt;&lt;code&gt;str::escape_debug&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.str#method.escape_debug&quot;&gt; &lt;code&gt;str::escape_debug&lt;/code&gt; &lt;/a&gt; 의 반환 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="db39743b7e18afb4b0cbc402d05c64c31d6c2284" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_default&quot;&gt;&lt;code&gt;str::escape_default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.str#method.escape_default&quot;&gt; &lt;code&gt;str::escape_default&lt;/code&gt; &lt;/a&gt; 의 반환 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="0d7f1d5c28f55e7c46b28c80bf7c947a04177ba0" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_unicode&quot;&gt;&lt;code&gt;str::escape_unicode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.str#method.escape_unicode&quot;&gt; &lt;code&gt;str::escape_unicode&lt;/code&gt; &lt;/a&gt; 의 반환 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="46984a9d3d93237d6af0b4171b9091187f1fd40f" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;read_input()&lt;/code&gt;, &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&amp;lt;()&amp;gt;&lt;/code&gt;&lt;/a&gt;, is a very common type for functions which don't have a 'real' return value, but do want to return errors if they happen. In this case, the only purpose of this function is to read the line and print it, so we use &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">의 반환 형식 &lt;code&gt;read_input()&lt;/code&gt; , &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&amp;lt;()&amp;gt;&lt;/code&gt; &lt;/a&gt; ,는 '진짜'리턴 값을 가지고 있지만이 일어날 경우 오류를 반환 싶어하지 않는 기능에 대한 매우 일반적인 유형입니다. 이 경우이 함수의 유일한 목적은 행을 읽고 인쇄하는 것이므로 &lt;code&gt;()&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="dc8688a274902ed01a0ecc5033bf35069d5bb391" translate="yes" xml:space="preserve">
          <source>The return value is a result indicating whether the new value was written and containing the previous value. On success this value is guaranteed to be equal to &lt;code&gt;current&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 새 값이 작성되었으며 이전 값을 포함하는지 여부를 나타내는 결과입니다. 성공하면이 값은 &lt;code&gt;current&lt;/code&gt; 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="6b1ea39b856b2d5fee30e6b97044d7752b536c14" translate="yes" xml:space="preserve">
          <source>The return value is always the previous value. If it is equal to &lt;code&gt;current&lt;/code&gt;, then the value was updated.</source>
          <target state="translated">반환 값은 항상 이전 값입니다. &lt;code&gt;current&lt;/code&gt; 와 같으면 값이 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="fc0a38af017feefeb9d3ecc2b64620f7588f7e32" translate="yes" xml:space="preserve">
          <source>The return value may change depending on the compiler version and unsafe code may not rely on the result of this function for soundness. It is suggested to only use this function for performance optimizations where spurious &lt;code&gt;false&lt;/code&gt; return values by this function do not affect the outcome, but just the performance. The consequences of using this method to make runtime and compile-time code behave differently have not been explored. This method should not be used to introduce such differences, and it should also not be stabilized before we have a better understanding of this issue.</source>
          <target state="translated">반환 값은 컴파일러 버전에 따라 변경 될 수 있으며 안전하지 않은 코드는 건전성을 위해이 함수의 결과에 의존하지 않을 수 있습니다. 이 함수에 의한 가짜 &lt;code&gt;false&lt;/code&gt; 반환 값이 결과에 영향을 미치지 않고 성능에만 영향을 미치는 성능 최적화에만이 함수를 사용하는 것이 좋습니다 . 이 메서드를 사용하여 런타임 및 컴파일 타임 코드가 다르게 동작하도록하는 결과는 탐색되지 않았습니다. 이 방법은 이러한 차이점을 도입하는 데 사용되어서는 안되며,이 문제를 더 잘 이해하기 전에 안정화되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="8bec0cf03017a322224afce0dc723c8da3b1c3f8" translate="yes" xml:space="preserve">
          <source>The return value of this function has no meaning if &lt;code&gt;align&lt;/code&gt; is not a power-of-two.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; 이 2의 거듭 제곱이 아닌 경우이 함수의 반환 값은 의미 가 없습니다.</target>
        </trans-unit>
        <trans-unit id="60b397a9e27c756600834e9e8bc999da0f2e38e6" translate="yes" xml:space="preserve">
          <source>The returned 64-bit value is equivalent to a &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-filetime&quot;&gt;&lt;code&gt;FILETIME&lt;/code&gt;&lt;/a&gt; struct, which represents the number of 100-nanosecond intervals since January 1, 1601 (UTC). The struct is automatically converted to a &lt;code&gt;u64&lt;/code&gt; value, as that is the recommended way to use it.</source>
          <target state="translated">반환 된 64 비트 값은 1601 년 1 월 1 일 (UTC) 이후 100 나노초 간격의 수를 나타내는 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-filetime&quot;&gt; &lt;code&gt;FILETIME&lt;/code&gt; &lt;/a&gt; 구조체 와 동일합니다 . 구조체는 자동으로 &lt;code&gt;u64&lt;/code&gt; 값 으로 변환 되므로 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9b9e4888166c03a2354c980d922cf25c13eb44d0" translate="yes" xml:space="preserve">
          <source>The returned 64-bit value is equivalent to a &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284.aspx&quot;&gt;&lt;code&gt;FILETIME&lt;/code&gt;&lt;/a&gt; struct, which represents the number of 100-nanosecond intervals since January 1, 1601 (UTC). The struct is automatically converted to a &lt;code&gt;u64&lt;/code&gt; value, as that is the recommended way to use it.</source>
          <target state="translated">리턴 된 64 비트 값은 1601 년 1 월 1 일 (UTC) 이후 100 나노초 간격의 수를 나타내는 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284.aspx&quot;&gt; &lt;code&gt;FILETIME&lt;/code&gt; &lt;/a&gt; 구조체 와 같습니다 . 구조체는 사용하는 것이 권장되는 방법 &lt;code&gt;u64&lt;/code&gt; 값 으로 자동 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="f17e579c0925b04170923132b19bbc2e328718e7" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; is safe to pass to &lt;a href=&quot;../primitive.slice#method.get_unchecked&quot;&gt;&lt;code&gt;slice::get_unchecked&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.slice#method.get_unchecked_mut&quot;&gt;&lt;code&gt;slice::get_unchecked_mut&lt;/code&gt;&lt;/a&gt; for slices of the given length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e9caf07f01ab2822f3d6ed99758b9360c5c26af" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one listener will affect the other.</source>
          <target state="translated">리턴 된 &lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt; 는이 오브젝트가 참조하는 동일한 소켓에 대한 참조입니다. 두 핸들 모두 수신 연결을 수락하는 데 사용할 수 있으며 한 리스너에 설정된 옵션은 다른 리스너에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="ded74a0ee30df2ab90178bc7d8c79f6560c92452" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.waittimeoutresult&quot;&gt;&lt;code&gt;WaitTimeoutResult&lt;/code&gt;&lt;/a&gt; value indicates if the timeout is known to have elapsed without the condition being met.</source>
          <target state="translated">반환 된 &lt;a href=&quot;struct.waittimeoutresult&quot;&gt; &lt;code&gt;WaitTimeoutResult&lt;/code&gt; &lt;/a&gt; 값은 조건이 충족되지 않은 상태에서 시간 초과가 경과 한 것으로 알려진 경우를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="38736111afdf682fcdb07c273e755038e1599f59" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.waittimeoutresult&quot;&gt;&lt;code&gt;WaitTimeoutResult&lt;/code&gt;&lt;/a&gt; value indicates if the timeout is known to have elapsed.</source>
          <target state="translated">반환 된 &lt;a href=&quot;struct.waittimeoutresult&quot;&gt; &lt;code&gt;WaitTimeoutResult&lt;/code&gt; &lt;/a&gt; 값은 시간 초과가 경과 한 것으로 알려진 경우를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a4d3afc22fc51194d42ebf97c4d4c71d6cf8d193" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Read&lt;/code&gt; instance will first read all bytes from this object until EOF is encountered. Afterwards the output is equivalent to the output of &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">반환 된 &lt;code&gt;Read&lt;/code&gt; 인스턴스는 EOF가 발생할 때까지이 객체에서 모든 바이트를 먼저 읽습니다. 이후 출력은 &lt;code&gt;next&lt;/code&gt; 출력과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c46cae45e911aa3ffb2e82c2b8df4d3f09691f8b" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;TcpStream&lt;/code&gt; is a reference to the same stream that this object references. Both handles will read and write the same stream of data, and options set on one stream will be propagated to the other stream.</source>
          <target state="translated">리턴 된 &lt;code&gt;TcpStream&lt;/code&gt; 은이 오브젝트가 참조하는 동일한 스트림에 대한 참조입니다. 두 핸들 모두 동일한 데이터 스트림을 읽고 쓰며, 한 스트림에 설정된 옵션은 다른 스트림으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="f1bab9e66e16ee3bc6f8eaaaaca9a4320b7da4d4" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UdpSocket&lt;/code&gt; is a reference to the same socket that this object references. Both handles will read and write the same port, and options set on one socket will be propagated to the other.</source>
          <target state="translated">리턴 된 &lt;code&gt;UdpSocket&lt;/code&gt; 은이 오브젝트가 참조하는 동일한 소켓에 대한 참조입니다. 두 핸들 모두 같은 포트를 읽고 쓰며 한 소켓에 설정된 옵션이 다른 소켓으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="c1a563924be47f2135363b13913bddb8d81845c6" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixDatagram&lt;/code&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one side will affect the other.</source>
          <target state="translated">반환 된 &lt;code&gt;UnixDatagram&lt;/code&gt; 은이 객체가 참조하는 것과 동일한 소켓에 대한 참조입니다. 두 핸들을 모두 사용하여 들어오는 연결을 수락 할 수 있으며 한쪽에 설정된 옵션이 다른쪽에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="3a69722b38c150ace8c17a0ad6c7500758c624a4" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixListener&lt;/code&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one listener will affect the other.</source>
          <target state="translated">반환 된 &lt;code&gt;UnixListener&lt;/code&gt; 는이 객체가 참조하는 동일한 소켓에 대한 참조입니다. 두 핸들 모두 수신 연결을 수락하는 데 사용할 수 있으며 한 리스너에 설정된 옵션은 다른 리스너에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="144b7ef360f6249426bb7be199321625b6985707" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixStream&lt;/code&gt; is a reference to the same stream that this object references. Both handles will read and write the same stream of data, and options set on one stream will be propagated to the other stream.</source>
          <target state="translated">반환 된 &lt;code&gt;UnixStream&lt;/code&gt; 은이 객체가 참조하는 것과 동일한 스트림에 대한 참조입니다. 두 핸들 모두 동일한 데이터 스트림을 읽고 쓰며, 한 스트림에 설정된 옵션은 다른 스트림으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="cb880b11df63d1e3077076bea22bb8b51ec8054d" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;AllocRef&lt;/code&gt; and will simply borrow this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3560a746a4c0e2ffb1141c7abaa941ae137d7b4" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;Read&lt;/code&gt; and will simply borrow this current reader.</source>
          <target state="translated">반환 된 어댑터는 또한 &lt;code&gt;Read&lt;/code&gt; 를 구현 하며이 현재 리더를 빌려옵니다.</target>
        </trans-unit>
        <trans-unit id="facac298df7b4792f8b8fe4cbcbc0a4967c70852" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;Write&lt;/code&gt; and will simply borrow this current writer.</source>
          <target state="translated">반환 된 어댑터는 &lt;code&gt;Write&lt;/code&gt; 를 구현 하며이 현재 기록기를 빌려줍니다.</target>
        </trans-unit>
        <trans-unit id="e389b4884c363b3fc760ebd7d93cdcb95de946c0" translate="yes" xml:space="preserve">
          <source>The returned block is suitable for passing to the &lt;code&gt;alloc&lt;/code&gt;/&lt;code&gt;realloc&lt;/code&gt; methods of this allocator.</source>
          <target state="translated">리턴 된 블록은 이 할당 자의 &lt;code&gt;alloc&lt;/code&gt; / &lt;code&gt;realloc&lt;/code&gt; 메소드로 전달하는 데 적합합니다 .</target>
        </trans-unit>
        <trans-unit id="c91d87a8c74843f84b212121082c194e485a54b8" translate="yes" xml:space="preserve">
          <source>The returned block may have a larger size than specified by &lt;code&gt;layout.size()&lt;/code&gt;, and may or may not have its contents initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d367aab1faeec6de58c9c9955a240781bdbe40" translate="yes" xml:space="preserve">
          <source>The returned block of storage may or may not have its contents initialized. (Extension subtraits might restrict this behavior, e.g., to ensure initialization to particular sets of bit patterns.)</source>
          <target state="translated">반환 된 스토리지 블록의 내용이 초기화되었거나 초기화되지 않았을 수 있습니다. (확장 하위 특성은 특정 비트 패턴 세트로 초기화하기 위해이 동작을 제한 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="ba2ebcfc4f605284f02edd68881e9753988594f5" translate="yes" xml:space="preserve">
          <source>The returned boolean is &lt;code&gt;false&lt;/code&gt; only if the timeout is known to have elapsed.</source>
          <target state="translated">시간 초과가 경과 한 것으로 알려진 경우에만 반환 된 부울 값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ef190a0092cd801a89bd32ca6438155668c7c711" translate="yes" xml:space="preserve">
          <source>The returned buffer does &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes.</source>
          <target state="translated">반환 된 버퍼는 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 후행 NUL 종료를 포함, 인테리어 NUL 바이트를 가지고 있지 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="c21f9df3ca074ffdfcc498df18bd9b3644edeb21" translate="yes" xml:space="preserve">
          <source>The returned iterator contains a snapshot of the process's environment variables at the time of this invocation. Modifications to environment variables afterwards will not be reflected in the returned iterator.</source>
          <target state="translated">리턴 된 반복자에는이 호출시 프로세스 환경 변수의 스냅 샷이 포함됩니다. 나중에 환경 변수에 대한 수정 내용은 반환 된 반복자에 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94742684e4e1a0a940d70b49afd50e4db443fbed" translate="yes" xml:space="preserve">
          <source>The returned iterator may not actually yield any values depending on the outcome of any resolution performed.</source>
          <target state="translated">반환 된 반복자는 실제로 수행 된 해상도의 결과에 따라 어떤 값도 생성하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2aad97e80249c67281fd50b9abdb7bf4c0bc39de" translate="yes" xml:space="preserve">
          <source>The returned iterator might panic if the to-be-returned index would overflow a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 될 인덱스가 &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; 오버플로되면 반환 된 반복자가 패닉 상태에 빠질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f6e0a2276ef2ac22ba60fa606f31e8d0538ab17" translate="yes" xml:space="preserve">
          <source>The returned iterator requires that the pattern supports a reverse search, and it will be a &lt;a href=&quot;../iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if a forward/reverse search yields the same elements.</source>
          <target state="translated">반환 된 반복기는 패턴이 역방향 검색을 지원 해야하며 정방향 / 역방향 검색이 동일한 요소를 생성하는 경우 &lt;a href=&quot;../iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; 가&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="212e83558d8f38fe873f76d6ab8c409b36c6c1ca" translate="yes" xml:space="preserve">
          <source>The returned iterator requires that the pattern supports a reverse search, and it will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if a forward/reverse search yields the same elements.</source>
          <target state="translated">리턴 된 반복자는 패턴이 역방향 검색을 지원 해야하며 정방향 / 역방향 검색이 동일한 요소를 생성하는 경우 &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; 가&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="0a192fbaedef699058263c6cf3d017b9555c1581" translate="yes" xml:space="preserve">
          <source>The returned iterator requires that the pattern supports a reverse search, and it will be double ended if a forward/reverse search yields the same elements.</source>
          <target state="translated">리턴 된 반복자는 패턴이 리버스 검색을 지원해야하며 정방향 / 역방향 검색이 동일한 요소를 생성하면 이중으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="31cf06022e130c2b8e694b6f17ab8cbe9626501c" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;../iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">패턴이 역방향 검색을 허용하고 정방향 / 역방향 검색이 동일한 요소를 생성하는 경우 반환 된 반복기는 &lt;a href=&quot;../iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; 가&lt;/a&gt; 됩니다. 예를 들어 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; 의 경우&lt;/a&gt; 에는 해당되지만 &lt;code&gt;&amp;amp;str&lt;/code&gt; 경우에는 해당되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4543e6c97747a65b55c800608ca5f7c928ee84b5" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">패턴이 역방향 검색을 허용하고 정방향 / 역방향 검색이 동일한 요소를 생성하는 경우 반환 된 반복자는 &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; 가&lt;/a&gt; 됩니다. 예를 들어 &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 에는 적용되지만 &lt;code&gt;&amp;amp;str&lt;/code&gt; 에는 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fcd14ee368ff1244ad97f001dc72e74042b0095f" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">패턴이 역방향 검색을 허용하고 정방향 / 역방향 검색이 동일한 요소를 생성하는 경우 반환 된 반복자는 &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; 가&lt;/a&gt; 됩니다. 예를 들어 &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 에는 적용되지만 &lt;code&gt;&amp;amp;str&lt;/code&gt; 에는 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fb1179f626056fe35d781c0e7e7072fe8a2697c8" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">패턴이 역방향 검색을 허용하고 정방향 / 역방향 검색이 동일한 요소를 생성하는 경우 반환 된 반복기는 &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; 가&lt;/a&gt; 됩니다. 예를 들어 &lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; 의 경우&lt;/a&gt; 에는 해당되지만 &lt;code&gt;&amp;amp;str&lt;/code&gt; 경우에는 해당되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="45e7ec844babb660dc32f9f713ab552f258e8f9a" translate="yes" xml:space="preserve">
          <source>The returned iterator will never return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure. Iterating over it is equivalent to calling &lt;a href=&quot;#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; in a loop.</source>
          <target state="translated">반환 된 반복자는 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환 하지 않으며 피어의 &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; 구조 도 생성하지 않습니다 . 그것을 반복하는 것은 루프에서 &lt;a href=&quot;#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="40daaaf435dcc6bfd52a2f60c0016a88fb0c4d52" translate="yes" xml:space="preserve">
          <source>The returned iterator will never return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure. Iterating over it is equivalent to calling &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;TcpListener::accept&lt;/code&gt;&lt;/a&gt; in a loop.</source>
          <target state="translated">반환 된 이터레이터는 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환 하지 않으며 피어의 &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; 구조 도 생성하지 않습니다 . 반복하는 것은 루프에서 &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt; &lt;code&gt;TcpListener::accept&lt;/code&gt; &lt;/a&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3cacc276ab85a92453bcb875fe7d5c79fd6233ed" translate="yes" xml:space="preserve">
          <source>The returned iterator will not be double ended, because it is not efficient to support.</source>
          <target state="translated">반환 된 이터레이터는 지원이 효율적이지 않기 때문에 이중으로 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6626efd84bc65ae6d8cabe4bc5b2e309e23cd9ee" translate="yes" xml:space="preserve">
          <source>The returned iterator will panic during iteration if any argument to the process is not valid unicode. If this is not desired, use the &lt;a href=&quot;fn.args_os&quot;&gt;&lt;code&gt;args_os&lt;/code&gt;&lt;/a&gt; function instead.</source>
          <target state="translated">프로세스에 대한 인수가 유효한 유니 코드가 아닌 경우 반복되는 동안 리턴 된 반복자가 패닉 상태가됩니다. 이것이 바람직하지 않으면, 대신 &lt;a href=&quot;fn.args_os&quot;&gt; &lt;code&gt;args_os&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="48642a85c9b9785eaffc2d69f306f5a44a684795" translate="yes" xml:space="preserve">
          <source>The returned iterator yields only the &lt;code&gt;value&lt;/code&gt;s for which the supplied closure returns &lt;code&gt;Some(value)&lt;/code&gt;.</source>
          <target state="translated">반환 된 반복기 는 제공된 클로저가 &lt;code&gt;Some(value)&lt;/code&gt; 반환 하는 &lt;code&gt;value&lt;/code&gt; s 만 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="8c4abf6a88076e830a1096ad48a0fcbdcd010f5d" translate="yes" xml:space="preserve">
          <source>The returned lifetime is not guaranteed to be the actual lifetime of &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="translated">반환 된 수명은 실제 &lt;code&gt;ptr&lt;/code&gt; 수명이 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="dd646ddea405b753233bb6eb50b8340613c5b51f" translate="yes" xml:space="preserve">
          <source>The returned listener is ready for accepting connections.</source>
          <target state="translated">리턴 된 리스너는 연결을 승인 할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="32a2e5d176a9d291f17213749b86ae928f9a79fd" translate="yes" xml:space="preserve">
          <source>The returned name refers to a source path on the compiling system, but it isn't valid to represent this directly as a &lt;code&gt;&amp;amp;Path&lt;/code&gt;. The compiled code may run on a different system with a different &lt;code&gt;Path&lt;/code&gt; implementation than the system providing the contents and this library does not currently have a different &quot;host path&quot; type.</source>
          <target state="translated">반환 된 이름은 컴파일 시스템의 소스 경로를 참조하지만이를 &lt;code&gt;&amp;amp;Path&lt;/code&gt; 로 직접 나타내는 것은 유효하지 않습니다 . 컴파일 된 코드는 내용을 제공하는 시스템과 다른 &lt;code&gt;Path&lt;/code&gt; 구현 을 사용하여 다른 시스템에서 실행될 수 있으며이 라이브러리에는 현재 다른 &quot;호스트 경로&quot;유형이 없습니다.</target>
        </trans-unit>
        <trans-unit id="bd3776d88d1ca8845ec6b1038a3cef52ddd6c1ee" translate="yes" xml:space="preserve">
          <source>The returned object can be used for error recovery, such as re-inspecting the buffer.</source>
          <target state="translated">리턴 된 오브젝트는 버퍼 재검사와 같은 오류 복구에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d094ca8efdcd1c477cd38db568c96ab96a8083f1" translate="yes" xml:space="preserve">
          <source>The returned pointer is read-only; writing to it (including passing it to C code that writes to it) causes undefined behavior.</source>
          <target state="translated">반환 된 포인터는 읽기 전용입니다. 쓰기 (C 코드에 쓰기 포함)는 정의되지 않은 동작을 유발합니다.</target>
        </trans-unit>
        <trans-unit id="9b9b68320305244b712b6eba3fb78b4a32d8f345" translate="yes" xml:space="preserve">
          <source>The returned pointer will be valid for as long as &lt;code&gt;self&lt;/code&gt; is, and points to a contiguous region of memory terminated with a 0 byte to represent the end of the string.</source>
          <target state="translated">반환 된 포인터는 &lt;code&gt;self&lt;/code&gt; 가 있는 한 유효 하며 문자열의 끝을 나타 내기 위해 0 바이트로 끝나는 연속 된 메모리 영역을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="d1d3044eae78ae415d38e3ebb8ef901b44a28df4" translate="yes" xml:space="preserve">
          <source>The returned range is half-open, which means that the end pointer points &lt;em&gt;one past&lt;/em&gt; the last element of the slice. This way, an empty slice is represented by two equal pointers, and the difference between the two pointers represents the size of the slice.</source>
          <target state="translated">반환 된 범위는 반쯤 열려 있습니다. 즉, 끝 포인터 가 슬라이스의 마지막 요소를 &lt;em&gt;하나 지나서&lt;/em&gt; 가리 킵니다 . 이런 식으로 빈 슬라이스는 두 개의 동일한 포인터로 표시되고 두 포인터의 차이는 슬라이스의 크기를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1c27af8743c2ff7ed690feb622313cb681b2d0e2" translate="yes" xml:space="preserve">
          <source>The returned slice can be used to fill the vector with data (e.g. by reading from a file) before marking the data as initialized using the &lt;a href=&quot;struct.vec#method.set_len&quot;&gt;&lt;code&gt;set_len&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">반환 된 슬라이스는 &lt;a href=&quot;struct.vec#method.set_len&quot;&gt; &lt;code&gt;set_len&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 데이터를 초기화 된 것으로 표시하기 전에 데이터로 벡터를 채우는 데 사용할 수 있습니다 (예 : 파일에서 읽기) .</target>
        </trans-unit>
        <trans-unit id="bf0c4a80af7569dc2827892f37e1cf7abb925f27" translate="yes" xml:space="preserve">
          <source>The returned slice does &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes. If you need the nul terminator, use &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">리턴 된 슬라이스 에는 후미 널 종결자가 포함 되지 &lt;strong&gt;않으며&lt;/strong&gt; 내부 널 바이트가없는 것이 보장됩니다. 널 종결자가 필요한 경우 대신 &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;as_bytes_with_nul&lt;/code&gt; 을&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0a368474e9b2e8c2f52646dd2d7918f986464f59" translate="yes" xml:space="preserve">
          <source>The returned slice does &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes. If you need the nul terminator, use &lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">반환 슬라이스는 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 후행 NUL 종료를 포함, 인테리어 NUL 바이트를 가지고 있지 보장됩니다. nul 종결자가 필요한 경우 대신 &lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="23c2a4410e35e072d95d91733db13ddd5bf58ad1" translate="yes" xml:space="preserve">
          <source>The returned slice will &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator that this C string has.</source>
          <target state="translated">반환 된 슬라이스 에는이 C 문자열의 마지막 널 종료자가 포함 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a46b9c2f552385dbbfeb1cece6cdbcca5271f43e" translate="yes" xml:space="preserve">
          <source>The returned string must not be considered to be a unique identifier of a type as multiple types may map to the same type name. Similarly, there is no guarantee that all parts of a type will appear in the returned string: for example, lifetime specifiers are currently not included. In addition, the output may change between versions of the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6695d62fb3138a05ebea6941a15916ea38fd70" translate="yes" xml:space="preserve">
          <source>The returned type after indexing.</source>
          <target state="translated">인덱싱 후 반환 된 형식입니다.</target>
        </trans-unit>
        <trans-unit id="323e9e5f7457b4d404421a53102d137f9784ffb2" translate="yes" xml:space="preserve">
          <source>The returned type after the call operator is used.</source>
          <target state="translated">호출 연산자가 사용 된 후 리턴 된 유형입니다.</target>
        </trans-unit>
        <trans-unit id="2d5978ed3eb5e45dd0ed7362549dedf897ab386a" translate="yes" xml:space="preserve">
          <source>The returned type implements &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; where the &lt;code&gt;Item&lt;/code&gt; is &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;, &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. The yielded item is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; if a byte was successfully read and &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; otherwise. EOF is mapped to returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from this iterator.</source>
          <target state="translated">리턴 된 유형 은 &lt;code&gt;Item&lt;/code&gt; 이 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;, &lt;/code&gt; &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;io::Error&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 인&lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; 를&lt;/a&gt; 구현 합니다. 바이트를 성공적으로 읽은 경우 생성 된 항목은 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 이고 그렇지 않으면 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 입니다. EOF는 이 반복자에서 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 반환하도록 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="94490bb5f034be81aa72ad51da07b198637a8c28" translate="yes" xml:space="preserve">
          <source>The returned type implements &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; where the &lt;code&gt;Item&lt;/code&gt; is &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;, &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. The yielded item is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; if a byte was successfully read and &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; otherwise. EOF is mapped to returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from this iterator.</source>
          <target state="translated">반환 된 유형 은 &lt;code&gt;Item&lt;/code&gt; 이 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;, &lt;/code&gt; &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;io::Error&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 인&lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; 를&lt;/a&gt; 구현 합니다. 산출 된 항목은 바이트가 성공적으로 읽혔 으면 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 이고 그렇지 않으면 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 입니다. EOF는 이 반복기에서 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 반환하도록 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="a0b4fa361f895a3f7a940a0df4cc75d5065e98e6" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;atime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftLastAccessTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">리턴 된 값 은 Unix 플랫폼 에서 &lt;code&gt;stat&lt;/code&gt; 의 &lt;code&gt;atime&lt;/code&gt; 필드 와 Windows 플랫폼 에서 &lt;code&gt;ftLastAccessTime&lt;/code&gt; 필드에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="ab7615b505b03838f921f8936a1701e974958831" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;birthtime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftCreationTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">반환 값에 해당하는 &lt;code&gt;birthtime&lt;/code&gt; 의 의 필드 &lt;code&gt;stat&lt;/code&gt; 유닉스 플랫폼과 &lt;code&gt;ftCreationTime&lt;/code&gt; 의 Windows 플랫폼에서 필드.</target>
        </trans-unit>
        <trans-unit id="2eef349b822dea9863943a97049788d8df72cce1" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;btime&lt;/code&gt; field of &lt;code&gt;statx&lt;/code&gt; on Linux kernel starting from to 4.11, the &lt;code&gt;birthtime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on other Unix platforms, and the &lt;code&gt;ftCreationTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">받는 반환 값에 대응 &lt;code&gt;btime&lt;/code&gt; 분야 &lt;code&gt;statx&lt;/code&gt; 리눅스는 4.11의로부터 커널 &lt;code&gt;birthtime&lt;/code&gt; 의 분야 &lt;code&gt;stat&lt;/code&gt; 다른 유닉스 플랫폼에서, 그리고 &lt;code&gt;ftCreationTime&lt;/code&gt; 의 Windows 플랫폼에서 필드.</target>
        </trans-unit>
        <trans-unit id="c5896159de75927b2d1b622cfd587f254e9fed43" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;mtime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftLastWriteTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">리턴 된 값 은 Unix 플랫폼 에서 &lt;code&gt;stat&lt;/code&gt; 의 &lt;code&gt;mtime&lt;/code&gt; 필드 와 Windows 플랫폼 에서 &lt;code&gt;ftLastWriteTime&lt;/code&gt; 필드에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="a0ea9c14c32dc6d6e0d323b13279abc6935b1d15" translate="yes" xml:space="preserve">
          <source>The returned value does include the fractional (nanosecond) part of the duration.</source>
          <target state="translated">반환 된 값에는 지속 시간의 분수 (나노초) 부분이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ff15d0950ff1afde3f0762acc64a9f002a6a04c1" translate="yes" xml:space="preserve">
          <source>The returned value does not have meaning for directories.</source>
          <target state="translated">리턴 된 값은 디렉토리에 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e8c08d63d79b2a138a0f12bb7a91ea3ec23dcec7" translate="yes" xml:space="preserve">
          <source>The returned value does not include the fractional (nanosecond) part of the duration, which can be obtained using &lt;a href=&quot;#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 값은 기간의 소수 (nanosecond) 부분을 포함하지 않으며 &lt;a href=&quot;#method.subsec_nanos&quot;&gt; &lt;code&gt;subsec_nanos&lt;/code&gt; &lt;/a&gt; 를 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bfa4d7247e116de4261b1e09435dc9dcadacc45" translate="yes" xml:space="preserve">
          <source>The returned value does not include the fractional (nanosecond) part of the duration, which can be obtained using &lt;a href=&quot;struct.duration#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 값은 &lt;a href=&quot;struct.duration#method.subsec_nanos&quot;&gt; &lt;code&gt;subsec_nanos&lt;/code&gt; &lt;/a&gt; 를 사용하여 얻을 수있는 기간의 분수 (나노초) 부분을 포함하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1e5135e5751b93b5d235f37608301c3018208e63" translate="yes" xml:space="preserve">
          <source>The returned value is the number of &lt;strong&gt;elements&lt;/strong&gt;, not the number of bytes.</source>
          <target state="translated">반환 된 값은 바이트 수가 아니라 &lt;strong&gt;요소&lt;/strong&gt; 수입니다.</target>
        </trans-unit>
        <trans-unit id="70d2d5505f46c3741e892512e8371427a53745d7" translate="yes" xml:space="preserve">
          <source>The right shift assignment operator &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">오른쪽 교대 할당 연산자 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e00fa6358174afd137529285f589695abe7555ab" translate="yes" xml:space="preserve">
          <source>The right shift operator &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust's type checker has special handling for &lt;code&gt;_ &amp;gt;&amp;gt; _&lt;/code&gt;, setting the result type for integer operations to the type of the left-hand-side operand. This means that though &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; and &lt;code&gt;a.shr(b)&lt;/code&gt; are one and the same from an evaluation standpoint, they are different when it comes to type inference.</source>
          <target state="translated">오른쪽 시프트 연산자 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; . 이 특성은 여러 오른쪽 유형이있는 모든 정수 유형에 대해 구현되므로 Rust의 유형 검사기는 &lt;code&gt;_ &amp;gt;&amp;gt; _&lt;/code&gt; 대한 특수 처리를 수행하여 정수 연산의 결과 유형을 왼쪽 피연산자의 유형으로 설정합니다. . 이는 &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; 와 &lt;code&gt;a.shr(b)&lt;/code&gt; 가 평가 관점에서 하나 이지만 동일하지만 형식 유추와 관련하여 서로 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4bed85e5cf48df182fbdc5f50e1999ffc9d50cbb" translate="yes" xml:space="preserve">
          <source>The right way to suppress the warning is to actually write error handling, but because you just want to crash this program when a problem occurs, you can use &lt;code&gt;expect&lt;/code&gt;. You&amp;rsquo;ll learn about recovering from errors in Chapter 9.</source>
          <target state="translated">경고를 표시하지 않는 올바른 방법은 실제로 오류 처리를 작성하는 것이지만 문제가 발생할 때이 프로그램을 중단시키고 싶기 때문에 &lt;code&gt;expect&lt;/code&gt; 를 사용할 수 있습니다. 9 장의 오류 복구에 대해 배웁니다.</target>
        </trans-unit>
        <trans-unit id="93b14b29a7aed966fc23a390a9832d3b882cc69b" translate="yes" xml:space="preserve">
          <source>The root directory component, appears after any prefix and before anything else.</source>
          <target state="translated">루트 디렉토리 구성 요소는 접 두부 뒤에 그리고 다른 것 앞에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a168d72d668df499616b725b5ca80c1ff007a04a" translate="yes" xml:space="preserve">
          <source>The rules for &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; match those for normal struct types, while &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; behave as if &lt;a href=&quot;../attributes/derive&quot;&gt;derived&lt;/a&gt;. For &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, the order of cloning of the captured variables is left unspecified.</source>
          <target state="translated">&lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 규칙은 일반 구조체 유형 의 규칙 과 일치하지만 &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;../attributes/derive&quot;&gt;파생 된&lt;/a&gt; 것처럼 동작합니다 . 들면 &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 캡처 된 변수의 클로닝의 순서가 지정되지 않은 상태이다.</target>
        </trans-unit>
        <trans-unit id="3563595879dbbd21c6c2906f7bd54a9b3679529d" translate="yes" xml:space="preserve">
          <source>The rust compiler cannot link to an external library if you don't give it its name. Example:</source>
          <target state="translated">rust 컴파일러는 이름을 지정하지 않으면 외부 라이브러리에 연결할 수 없습니다. 예:</target>
        </trans-unit>
        <trans-unit id="54065002f88e1cb544dc442e2b3686e62225bf94" translate="yes" xml:space="preserve">
          <source>The rust compiler maintains for each target a blacklist of ABIs unsupported on that target. If an ABI is present in such a list this usually means that the target / ABI combination is currently unsupported by llvm.</source>
          <target state="translated">rust 컴파일러는 각 대상에 대해 해당 대상에서 지원되지 않는 ABI의 블랙리스트를 유지 관리합니다. ABI가 이러한 목록에있는 경우 이는 일반적으로 대상 / ABI 조합이 현재 llvm에서 지원되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e602506551cf00543c3919704a07e8c114c13f33" translate="yes" xml:space="preserve">
          <source>The rust compiler maintains for each target a list of unsupported ABIs on that target. If an ABI is present in such a list this usually means that the target / ABI combination is currently unsupported by llvm.</source>
          <target state="translated">rust 컴파일러는 각 타겟에 대해 해당 타겟에서 지원되지 않는 ABI 목록을 유지합니다. 이러한 목록에 ABI가있는 경우 이는 일반적으로 대상 / ABI 조합이 현재 llvm에서 지원되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d8dcfff8659995d9c806c4ff5bfe72343be6d124" translate="yes" xml:space="preserve">
          <source>The rustfix tool is included with Rust installations and can automatically fix some compiler warnings. If you&amp;rsquo;ve written code in Rust, you&amp;rsquo;ve probably seen compiler warnings. For example, consider this code:</source>
          <target state="translated">rustfix 도구는 Rust 설치에 포함되어 있으며 일부 컴파일러 경고를 자동으로 수정할 수 있습니다. Rust에서 코드를 작성했다면 아마도 컴파일러 경고가 표시되었을 것입니다. 예를 들어 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d95e676c8653714db7acc846f5781f129f187994" translate="yes" xml:space="preserve">
          <source>The safety and conciseness of &lt;code&gt;for&lt;/code&gt; loops make them the most commonly used loop construct in Rust. Even in situations in which you want to run some code a certain number of times, as in the countdown example that used a &lt;code&gt;while&lt;/code&gt; loop in Listing 3-3, most Rustaceans would use a &lt;code&gt;for&lt;/code&gt; loop. The way to do that would be to use a &lt;code&gt;Range&lt;/code&gt;, which is a type provided by the standard library that generates all numbers in sequence starting from one number and ending before another number.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프 의 안전과 간결함은 Rust에서 가장 일반적으로 사용되는 루프 구조입니다. 목록 3-3에서 &lt;code&gt;while&lt;/code&gt; 루프 를 사용한 카운트 다운 예제 에서처럼 일부 코드를 특정 횟수만큼 실행하려는 경우에도 대부분의 Rustaceans는 &lt;code&gt;for&lt;/code&gt; 루프를 사용합니다 . 이를 수행하는 방법 은 표준 라이브러리에서 제공하는 유형 인 &lt;code&gt;Range&lt;/code&gt; 를 사용하여 한 숫자에서 시작하여 다른 숫자보다 먼저 끝나는 모든 숫자를 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="34c5f02c44747e09b58d1ec500165079e9867619" translate="yes" xml:space="preserve">
          <source>The same applies to transmutes to &lt;code&gt;*mut fn()&lt;/code&gt;, which were observed in practice. Note though that use of this type is generally incorrect. The intention is typically to describe a function pointer, but just &lt;code&gt;fn()&lt;/code&gt; alone suffices for that. &lt;code&gt;*mut fn()&lt;/code&gt; is a pointer to a fn pointer. (Since these values are typically just passed to C code, however, this rarely makes a difference in practice.)</source>
          <target state="translated">실제로 관찰 된 &lt;code&gt;*mut fn()&lt;/code&gt; 로의 변환에 적용됩니다 . 이 유형의 사용은 일반적으로 올바르지 않습니다. 의도는 일반적으로 함수 포인터를 설명하는 것이지만 &lt;code&gt;fn()&lt;/code&gt; 만으로도 충분합니다. &lt;code&gt;*mut fn()&lt;/code&gt; 은 fn 포인터에 대한 포인터입니다. (이러한 값은 일반적으로 C 코드로 전달되기 때문에 실제로 차이가 거의 없습니다.)</target>
        </trans-unit>
        <trans-unit id="a7f4b342720ddcec9a49dfb2ca6daf016843320d" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../../../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../../../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../../iter/trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 반복기의 첫 번째 요소를 초기 값으로 사용하여 모든 후속 요소를 그 안에 접습니다. 반복기가 비어 있으면 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . 그렇지 않으면 접기 결과를 반환합니다. &lt;a href=&quot;../../../iter/trait.iterator#method.fold_first&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c676ce454b9f3ef8b4d42559af1943bf2b7913d9" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../iter/trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 반복기의 첫 번째 요소를 초기 값으로 사용하여 모든 후속 요소를 그 안에 접습니다. 반복기가 비어 있으면 &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . 그렇지 않으면 접기 결과를 반환합니다. &lt;a href=&quot;../../iter/trait.iterator#method.fold_first&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb7e4f0db03c726bc5bd7452fa0f56591b66e33d" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 반복기의 첫 번째 요소를 초기 값으로 사용하여 모든 후속 요소를 그 안에 접습니다. 반복기가 비어 있으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . 그렇지 않으면 접기 결과를 반환합니다. &lt;a href=&quot;../iter/trait.iterator#method.fold_first&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dcf7a6ad9f8fb40e4ba7caca628efe6809216b4f" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 반복기의 첫 번째 요소를 초기 값으로 사용하여 모든 후속 요소를 그 안에 접습니다. 반복기가 비어 있으면 &lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . 그렇지 않으면 접기 결과를 반환합니다. &lt;a href=&quot;../iter/trait.iterator#method.fold_first&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f1ae9b3d116905ba91635f77fa80dd3badbdd424" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;iter/trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 반복기의 첫 번째 요소를 초기 값으로 사용하여 모든 후속 요소를 그 안에 접습니다. 반복기가 비어 있으면 &lt;a href=&quot;option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . 그렇지 않으면 접기 결과를 반환합니다. &lt;a href=&quot;iter/trait.iterator#method.fold_first&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3f595892b4fea20450f05cddbe7763f0e003caa0" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold.</source>
          <target state="translated">&lt;a href=&quot;trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 반복기의 첫 번째 요소를 초기 값으로 사용하여 모든 후속 요소를 그 안에 접습니다. 반복기가 비어 있으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . 그렇지 않으면 접기 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f5b129096713d6e93f0f6771f5a02e553c2efcf3" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 반복기의 첫 번째 요소를 초기 값으로 사용하여 모든 후속 요소를 그 안에 접습니다. 반복기가 비어 있으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . 그렇지 않으면 접기 결과를 반환합니다. &lt;a href=&quot;trait.iterator#method.fold_first&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="902a2b25118315948a58ef98f0d17bd457899153" translate="yes" xml:space="preserve">
          <source>The same goes for doc comments:</source>
          <target state="translated">문서 주석도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="2e8159833047b3772ef09e1ff09bc6721b1345cc" translate="yes" xml:space="preserve">
          <source>The same restrictions of accessing the target of the pointer as with &lt;a href=&quot;struct.weak#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; apply.</source>
          <target state="translated">&lt;a href=&quot;struct.weak#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; &lt;/a&gt; 에서와 마찬가지로 포인터의 대상에 액세스하는 것과 동일한 제한이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2bc57fcef5c1050ba1f9373a34844306a6911e2e" translate="yes" xml:space="preserve">
          <source>The same restrictions of accessing the target of the pointer as with &lt;a href=&quot;struct.weak#method.as_raw&quot;&gt;&lt;code&gt;as_raw&lt;/code&gt;&lt;/a&gt; apply.</source>
          <target state="translated">&lt;a href=&quot;struct.weak#method.as_raw&quot;&gt; &lt;code&gt;as_raw&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 포인터의 대상에 액세스하는 것과 동일한 제한 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e53c2cdb1077121198b1a8746e267d3b3a805b0e" translate="yes" xml:space="preserve">
          <source>The scope in which the variable &lt;code&gt;s&lt;/code&gt; is valid is the same as any function parameter&amp;rsquo;s scope, but we don&amp;rsquo;t drop what the reference points to when it goes out of scope because we don&amp;rsquo;t have ownership. When functions have references as parameters instead of the actual values, we won&amp;rsquo;t need to return the values in order to give back ownership, because we never had ownership.</source>
          <target state="translated">변수 &lt;code&gt;s&lt;/code&gt; 가 유효한 범위는 함수 매개 변수의 범위와 동일하지만 소유권이 없기 때문에 범위를 벗어날 때 참조가 가리키는 것을 삭제하지 않습니다. 함수에 실제 값 대신 매개 변수로 참조가있는 경우 소유권이 없기 때문에 소유권을 돌려주기 위해 값을 반환 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2c0f9db762db77543e23786689d772ed7e180cf6" translate="yes" xml:space="preserve">
          <source>The scopes of the immutable references &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; end after the &lt;code&gt;println!&lt;/code&gt; where they are last used, which is before the mutable reference &lt;code&gt;r3&lt;/code&gt; is created. These scopes don&amp;rsquo;t overlap, so this code is allowed.</source>
          <target state="translated">불변의 참조 &lt;code&gt;r1&lt;/code&gt; 및 &lt;code&gt;r2&lt;/code&gt; 의 범위 는 &lt;code&gt;println!&lt;/code&gt; 변경 가능한 참조 &lt;code&gt;r3&lt;/code&gt; 이 작성 되기 전의 마지막 사용 위치 . 이러한 범위는 겹치지 않으므로이 코드가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="547c47e37f57601f738482d42256219a9633dd7e" translate="yes" xml:space="preserve">
          <source>The search path to be used may be controlled by setting the &lt;code&gt;PATH&lt;/code&gt; environment variable on the Command, but this has some implementation limitations on Windows (see issue #37519).</source>
          <target state="translated">사용할 검색 경로 는 Command 에서 &lt;code&gt;PATH&lt;/code&gt; 환경 변수를 설정하여 제어 할 수 있지만 Windows에는 구현 제한이 있습니다 (문제 # 37519 참조).</target>
        </trans-unit>
        <trans-unit id="3a555019f8dcc01c39b7fc4a4df1fa78e901c698" translate="yes" xml:space="preserve">
          <source>The second case example is a bit particular: the main function must always have this definition:</source>
          <target state="translated">두 번째 사례의 예는 약간 특별합니다. 주 함수에는 항상 다음 정의가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="02a1a4dab2732977e1598d466f79a0132530331a" translate="yes" xml:space="preserve">
          <source>The second form of macros is &lt;em&gt;procedural macros&lt;/em&gt;, which act more like functions (and are a type of procedure). Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do.</source>
          <target state="translated">매크로의 두 번째 형태는 &lt;em&gt;절차 적 매크로로&lt;/em&gt; , 함수와 비슷하게 작동하며 프로 시저 유형입니다. 절차 매크로는 일부 코드를 입력으로 받아들이고 해당 코드에서 작동하며 패턴과 일치하지 않고 선언적 매크로처럼 코드를 다른 코드로 바꾸지 않고 출력으로 일부 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="014f5e70707fe70de5f920ceaf6bbf6f00b7acd7" translate="yes" xml:space="preserve">
          <source>The second half of the tuple that is returned is an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. A &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; here means that either there is no known upper bound, or the upper bound is larger than &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환되는 튜플의 후반은 &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 여기 없음이 알려져있다 어느 것이 수단은 상한 없거나 상부보다 큰 결합 &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4961749eb1f24345f8436cc7b35d0ebccb81384a" translate="yes" xml:space="preserve">
          <source>The second invariant says that a separated complex NT must use a separator token that is part of the predetermined follow set for the internal contents of the NT. This ensures that a legal macro definition will continue to parse an input fragment into the same delimited sequence of &lt;code&gt;tt ...&lt;/code&gt;'s, even as new syntactic forms are added to the language.</source>
          <target state="translated">두 번째 불변은 분리 된 복합 NT가 NT의 내부 내용에 대해 사전 결정된 후속 세트의 일부인 분리기 토큰을 사용해야한다고 말합니다. 이렇게하면 새로운 구문 형식이 언어에 추가 되더라도 유효한 매크로 정의가 입력 조각을 동일한 구분 된 &lt;code&gt;tt ...&lt;/code&gt; 시퀀스로 계속 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3069a4f51af6a3b6633b4d681ece722a85d63fa2" translate="yes" xml:space="preserve">
          <source>The second is mutable references. They can be created from &lt;code&gt;mut&lt;/code&gt; variables and must be unique: no other variables can have a mutable reference, nor a shared reference.</source>
          <target state="translated">두 번째는 가변 참조입니다. &lt;code&gt;mut&lt;/code&gt; 변수 에서 만들 수 있으며 고유해야합니다. 다른 변수는 가변 참조 나 공유 참조를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3f2dca747a6f3fa79f2291ae843df5963e36bbc5" translate="yes" xml:space="preserve">
          <source>The second is that it is the offset in bytes between successive elements in an array with that item type.</source>
          <target state="translated">두 번째는 해당 항목 유형이있는 배열의 연속 요소 간 오프셋 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="a1e02e9dcee081f5b8c19c27d767e65c0ff37f76" translate="yes" xml:space="preserve">
          <source>The second is to generally improve your knowledge of a facet of the language. In that case, just browse the table of contents until you see something you want to know more about, and just start reading. If a link looks interesting, click it, and read about that section.</source>
          <target state="translated">두 번째는 일반적으로 언어의 측면에 대한 지식을 향상시키는 것입니다. 이 경우, 더 알고 싶은 것이 보일 때까지 목차를 탐색하고 읽기를 시작하십시오. 링크가 흥미로워지면 클릭하여 해당 섹션에 대해 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="df5949936d6a2cd7eaf61fe27eb1fac54cf960fb" translate="yes" xml:space="preserve">
          <source>The second line that we added to the middle of the code prints the secret number. This is useful while we&amp;rsquo;re developing the program to be able to test it, but we&amp;rsquo;ll delete it from the final version. It&amp;rsquo;s not much of a game if the program prints the answer as soon as it starts!</source>
          <target state="translated">코드 중간에 추가 한 두 번째 줄은 비밀 번호를 인쇄합니다. 테스트 할 수 있도록 프로그램을 개발하는 동안 유용하지만 최종 버전에서 삭제합니다. 프로그램이 시작하자마자 답을 인쇄하면 그리 큰 게임이 아닙니다!</target>
        </trans-unit>
        <trans-unit id="c1f82d829df68033c418a80c29f6453df31bb3f7" translate="yes" xml:space="preserve">
          <source>The second operand of a &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean expression&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;지연 부울 표현식&lt;/a&gt; 의 두 번째 피연산자입니다 .</target>
        </trans-unit>
        <trans-unit id="57bb822113e197cd1e10145a43fbd748bc848a6a" translate="yes" xml:space="preserve">
          <source>The second problem with the current &lt;code&gt;Cacher&lt;/code&gt; implementation is that it only accepts closures that take one parameter of type &lt;code&gt;u32&lt;/code&gt; and return a &lt;code&gt;u32&lt;/code&gt;. We might want to cache the results of closures that take a string slice and return &lt;code&gt;usize&lt;/code&gt; values, for example. To fix this issue, try introducing more generic parameters to increase the flexibility of the &lt;code&gt;Cacher&lt;/code&gt; functionality.</source>
          <target state="translated">현재와 두 번째 문제 &lt;code&gt;Cacher&lt;/code&gt; 구현은 단지 형식의 하나 개의 매개 변수 걸릴 폐쇄 받아들이는 것입니다 &lt;code&gt;u32&lt;/code&gt; 하고 돌아 &lt;code&gt;u32&lt;/code&gt; . 예를 들어 문자열 슬라이스를 사용하여 &lt;code&gt;usize&lt;/code&gt; 값을 반환하는 클로저 결과를 캐시하려고 할 수 있습니다 . 이 문제를 해결하려면보다 일반적인 매개 변수를 도입하여 &lt;code&gt;Cacher&lt;/code&gt; 기능 의 유연성을 높이십시오 .</target>
        </trans-unit>
        <trans-unit id="92462e612674a20cc7e3c63f701740ce5bea5c75" translate="yes" xml:space="preserve">
          <source>The second rule applies because there is exactly one input lifetime. The second rule specifies that the lifetime of the one input parameter gets assigned to the output lifetime, so the signature is now this:</source>
          <target state="translated">정확히 하나의 입력 수명이 있기 때문에 두 번째 규칙이 적용됩니다. 두 번째 규칙은 하나의 입력 매개 변수의 수명이 출력 수명에 할당되도록 지정하므로 서명은 이제 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66815e0776a29457690bd505c60d2e19937fa654" translate="yes" xml:space="preserve">
          <source>The second rule is if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32) -&amp;gt; &amp;amp;'a i32&lt;/code&gt;.</source>
          <target state="translated">두 번째 규칙은 정확히 하나의 입력 수명 매개 변수가있는 경우 해당 수명이 모든 출력 수명 매개 변수에 지정됩니다. &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32) -&amp;gt; &amp;amp;'a i32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aedd96f8435bb44ce30001804fbe27f5473ed0ee" translate="yes" xml:space="preserve">
          <source>The second time we call &lt;code&gt;add_to_waitlist&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt;, we use a relative path. The path starts with &lt;code&gt;front_of_house&lt;/code&gt;, the name of the module defined at the same level of the module tree as &lt;code&gt;eat_at_restaurant&lt;/code&gt;. Here the filesystem equivalent would be using the path &lt;code&gt;front_of_house/hosting/add_to_waitlist&lt;/code&gt;. Starting with a name means that the path is relative.</source>
          <target state="translated">&lt;code&gt;add_to_waitlist&lt;/code&gt; 에서 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 두 번째 호출 할 때는 상대 경로를 사용합니다. 경로는 시작 &lt;code&gt;front_of_house&lt;/code&gt; , 같은 모듈 트리의 같은 수준에서 정의 된 모듈의 이름 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 을 . 여기서 파일 시스템에 상응하는 것은 &lt;code&gt;front_of_house/hosting/add_to_waitlist&lt;/code&gt; 경로를 사용하는 것 입니다. 이름으로 시작하면 경로가 상대적임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6719785aa3871b4c2a2d425aeb686279358fe018" translate="yes" xml:space="preserve">
          <source>The second trait important to the smart pointer pattern is &lt;code&gt;Drop&lt;/code&gt;, which lets you customize what happens when a value is about to go out of scope. You can provide an implementation for the &lt;code&gt;Drop&lt;/code&gt; trait on any type, and the code you specify can be used to release resources like files or network connections. We&amp;rsquo;re introducing &lt;code&gt;Drop&lt;/code&gt; in the context of smart pointers because the functionality of the &lt;code&gt;Drop&lt;/code&gt; trait is almost always used when implementing a smart pointer. For example, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; customizes &lt;code&gt;Drop&lt;/code&gt; to deallocate the space on the heap that the box points to.</source>
          <target state="translated">스마트 포인터 패턴에 중요한 두 번째 특성은 &lt;code&gt;Drop&lt;/code&gt; 이며, 값이 범위를 벗어나려고 할 때 발생하는 동작을 사용자 지정할 수 있습니다. 모든 유형 의 &lt;code&gt;Drop&lt;/code&gt; 특성에 대한 구현을 제공 할 수 있으며 지정한 코드를 사용하여 파일 또는 네트워크 연결과 같은 리소스를 해제 할 수 있습니다. 우리는 도입하고 &lt;code&gt;Drop&lt;/code&gt; 의 기능 때문에 스마트 포인터의 맥락에서 &lt;code&gt;Drop&lt;/code&gt; 스마트 포인터를 구현할 때 특성이 거의 항상 사용됩니다. 예를 들어 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;code&gt;Drop&lt;/code&gt; 이 사용자 지정 하여 상자가 가리키는 힙의 공간을 할당 해제합니다.</target>
        </trans-unit>
        <trans-unit id="445effcb8001016422ef7635d91738ff3683b61e" translate="yes" xml:space="preserve">
          <source>The second trait important to the smart pointer pattern is &lt;code&gt;Drop&lt;/code&gt;, which lets you customize what happens when a value is about to go out of scope. You can provide an implementation for the &lt;code&gt;Drop&lt;/code&gt; trait on any type, and the code you specify can be used to release resources like files or network connections. We&amp;rsquo;re introducing &lt;code&gt;Drop&lt;/code&gt; in the context of smart pointers because the functionality of the &lt;code&gt;Drop&lt;/code&gt; trait is almost always used when implementing a smart pointer. For example, when a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is dropped it will deallocate the space on the heap that the box points to.</source>
          <target state="translated">스마트 포인터 패턴에 중요한 두 번째 특성 은 값이 범위를 벗어나려고 할 때 발생하는 상황을 사용자 지정할 수있는 &lt;code&gt;Drop&lt;/code&gt; 입니다. 모든 유형 에서 &lt;code&gt;Drop&lt;/code&gt; 특성에 대한 구현을 제공 할 수 있으며 지정한 코드를 사용하여 파일 또는 네트워크 연결과 같은 리소스를 해제 할 수 있습니다. &lt;code&gt;Drop&lt;/code&gt; 특성 의 기능은 스마트 포인터를 구현할 때 거의 항상 사용 되기 때문에 우리는 스마트 포인터의 맥락에서 &lt;code&gt;Drop&lt;/code&gt; 을 도입했습니다 . 예를 들어 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 를 삭제하면 상자가 가리키는 힙의 공간이 할당 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="b9253951b95bdbecdb3d6ee784fab1524db5c9af" translate="yes" xml:space="preserve">
          <source>The second type of operation that requires an unsafe block is calls to unsafe functions. Unsafe functions and methods look exactly like regular functions and methods, but they have an extra &lt;code&gt;unsafe&lt;/code&gt; before the rest of the definition. The &lt;code&gt;unsafe&lt;/code&gt; keyword in this context indicates the function has requirements we need to uphold when we call this function, because Rust can&amp;rsquo;t guarantee we&amp;rsquo;ve met these requirements. By calling an unsafe function within an &lt;code&gt;unsafe&lt;/code&gt; block, we&amp;rsquo;re saying that we&amp;rsquo;ve read this function&amp;rsquo;s documentation and take responsibility for upholding the function&amp;rsquo;s contracts.</source>
          <target state="translated">안전하지 않은 블록이 필요한 두 번째 유형의 작업은 안전하지 않은 기능에 대한 호출입니다. 안전하지 않은 함수 및 메소드는 일반 함수 및 메소드와 똑같이 보이지만 나머지 정의 전에 &lt;code&gt;unsafe&lt;/code&gt; 추가 기능 이 있습니다. &lt;code&gt;unsafe&lt;/code&gt; 녹 우리가 이러한 요구 사항을 충족 한 보장 할 수 없기 때문에 이러한 맥락에서 키워드, 함수가 우리가이 함수를 호출 할 때 유지하기 위해 필요한 요구 사항을 나타냅니다. &lt;code&gt;unsafe&lt;/code&gt; 블록 내에서 안전 하지 않은 기능을 호출함으로써이 기능 의 설명서를 읽었으며 기능 계약을 유지하는 책임을지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b5790cbd3c99b8bfcd34f57b9dbfe5e2b8bc741" translate="yes" xml:space="preserve">
          <source>The second-to-last line of the output shows the location and the name of the installed binary, which in the case of &lt;code&gt;ripgrep&lt;/code&gt; is &lt;code&gt;rg&lt;/code&gt;. As long as the installation directory is in your &lt;code&gt;$PATH&lt;/code&gt;, as mentioned previously, you can then run &lt;code&gt;rg --help&lt;/code&gt; and start using a faster, rustier tool for searching files!</source>
          <target state="translated">출력 표시 위치의 케이스에 설치된 진, 이름의 마지막에서 두 번째 행 &lt;code&gt;ripgrep&lt;/code&gt; 인 &lt;code&gt;rg&lt;/code&gt; . 설치 디렉토리가 &lt;code&gt;$PATH&lt;/code&gt; 에있는 한 앞서 언급했듯이 &lt;code&gt;rg --help&lt;/code&gt; 를 실행 하고 파일 검색을 위해 더 빠르고 녹슨 도구를 사용할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="599ddbb55a436b4b2320e8d917bb378c0d788288" translate="yes" xml:space="preserve">
          <source>The semantics for passing a value to a function are similar to those for assigning a value to a variable. Passing a variable to a function will move or copy, just as assignment does. Listing 4-3 has an example with some annotations showing where variables go into and out of scope.</source>
          <target state="translated">함수에 값을 전달하는 의미는 변수에 값을 지정하는 의미와 유사합니다. 할당과 마찬가지로 변수를 함수에 전달하면 이동 또는 복사됩니다. Listing 4-3에는 변수가 범위 내외로 이동하는 위치를 보여주는 주석이 포함 된 예가있다.</target>
        </trans-unit>
        <trans-unit id="0ebf78e0ec598941096cd9f3613dea835a20177d" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="translated">이 함수의 의미는 스레드가 대략 &lt;code&gt;dur&lt;/code&gt; 보다 크지 않도록 차단된다는 점을 제외하고 &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 와 동일합니다 . 이 방법 때문에 이러한 최대 시간 량을 일으키지 않으며 선점 또는 플랫폼의 차이 등의 이상으로 정확한 타이밍을 정확하게 사용할 수 기다린다 안 &lt;code&gt;dur&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f8ab2e3b0b43343b07ba616db0d9b83ddc1ec9a" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;ms&lt;/code&gt; milliseconds. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;ms&lt;/code&gt;.</source>
          <target state="translated">이 함수의 의미는 스레드가 대략 &lt;code&gt;ms&lt;/code&gt; 밀리 초 이하로 차단된다는 점을 제외하고 &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 와 동일합니다 . 이 방법은 선점 또는 플랫폼 차이와 같은 대기 시간으로 인해 최대 대기 시간이 정확히 &lt;code&gt;ms&lt;/code&gt; 가되지 않는 정확한 타이밍에 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="10369644dc806ec3584f4bc1cd00c1b37924dd8f" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait_until&quot;&gt;&lt;code&gt;wait_until&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="translated">이 함수의 의미는 스레드가 대략 &lt;code&gt;dur&lt;/code&gt; 보다 크지 않도록 차단 &lt;a href=&quot;#method.wait_until&quot;&gt; &lt;code&gt;wait_until&lt;/code&gt; &lt;/a&gt; 점을 제외하고 wait_until 과 같습니다 . 이 방법 때문에 이러한 최대 시간 량을 일으키지 않으며 선점 또는 플랫폼의 차이 등의 이상으로 정확한 타이밍을 정확하게 사용할 수 기다린다 안 &lt;code&gt;dur&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="599bdbbdba24d3dd39b2e820e78610be901175cf" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt; long.</source>
          <target state="translated">이 함수의 의미는 동등 &lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; &lt;/a&gt; 스레드가 대략 더 이상 차단되지 않습니다 것을 제외하고 &lt;code&gt;dur&lt;/code&gt; . 이 방법은 이로 인해 시간이 정확하게되도록 기다린의 최대 양을 일으키지 않을 수 선점 또는 플랫폼의 차이 등의 이상으로 정확한 타이밍을 위해 사용되지 않아야 &lt;code&gt;dur&lt;/code&gt; 긴.</target>
        </trans-unit>
        <trans-unit id="9563714599dd3161cea050e5c59d88f3adc62446" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;ms&lt;/code&gt; long.</source>
          <target state="translated">이 함수의 의미는 동등 &lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; &lt;/a&gt; 스레드가 대략 더 이상 차단되지 않습니다 것을 제외하고 &lt;code&gt;dur&lt;/code&gt; . 이 방법은 선점 또는 플랫폼 차이와 같은 대기 시간으로 인해 최대 대기 시간이 정확히 &lt;code&gt;ms&lt;/code&gt; 를 초과하지 않을 수 있으므로 정확한 타이밍에 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="8ace657d10944a484e642331ec94fc1a6e6161be" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="translated">이 함수의 의미는 스레드가 대략 &lt;code&gt;dur&lt;/code&gt; 이하로 차단된다는 점을 제외 하면 &lt;a href=&quot;struct.condvar#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 와 동일합니다 . 이 방법 때문에 이러한 최대 시간 량을 일으키지 않으며 선점 또는 플랫폼의 차이 등의 이상으로 정확한 타이밍을 정확하게 사용할 수 기다린다 안 &lt;code&gt;dur&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3371efd221cedf557721fc9ee15bda8759a39a9" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;ms&lt;/code&gt; milliseconds. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;ms&lt;/code&gt;.</source>
          <target state="translated">이 함수의 의미는 스레드가 약 &lt;code&gt;ms&lt;/code&gt; 밀리 초 동안 차단된다는 점을 제외 하면 &lt;a href=&quot;struct.condvar#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 와 동일합니다 . 이 방법은 최대 대기 시간이 정확히 &lt;code&gt;ms&lt;/code&gt; 가되지 않는 선점 또는 플랫폼 차이와 같은 이상으로 인해 정확한 타이밍에 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="6e595d1de9f2e3618f10b608ff234b6ad2944f66" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;struct.condvar#method.wait_while&quot;&gt;&lt;code&gt;wait_while&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="translated">이 함수의 의미는 스레드가 대략 &lt;code&gt;dur&lt;/code&gt; 이하로 차단 &lt;a href=&quot;struct.condvar#method.wait_while&quot;&gt; &lt;code&gt;wait_while&lt;/code&gt; &lt;/a&gt; 점을 제외 하면 wait_while과 동일합니다 . 이 방법 때문에 이러한 최대 시간 량을 일으키지 않으며 선점 또는 플랫폼의 차이 등의 이상으로 정확한 타이밍을 정확하게 사용할 수 기다린다 안 &lt;code&gt;dur&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ce3d66bfcd3164df001d8c8d3ea53b374782f46" translate="yes" xml:space="preserve">
          <source>The semicolon &lt;code&gt;;&lt;/code&gt; can be used to discard the result of an expression at the end of a block, making the expression (and thus the block) evaluate to &lt;code&gt;()&lt;/code&gt;. For example,</source>
          <target state="translated">세미콜론 &lt;code&gt;;&lt;/code&gt; 블록의 끝에서 표현식의 결과를 버리고 표현식 (및 블록)을 &lt;code&gt;()&lt;/code&gt; 로 평가하는 데 사용할 수 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="bb5601bddd79e71c2b7b66e9a5ead92eff60bcdd" translate="yes" xml:space="preserve">
          <source>The send and receive operations on channels will all return a &lt;a href=&quot;../../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; indicating whether the operation succeeded or not. An unsuccessful operation is normally indicative of the other half of a channel having &quot;hung up&quot; by being dropped in its corresponding thread.</source>
          <target state="translated">채널에서의 송수신 작업은 모두 작업의 성공 여부를 나타내는 &lt;a href=&quot;../../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 를 반환합니다 . 실패한 작업은 일반적으로 해당 스레드에서 드롭되어 &quot;끊어진&quot;채널의 나머지 절반을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ea8d26ff0d36fb568a938927807eafbc1ae6f29d" translate="yes" xml:space="preserve">
          <source>The sending-half of Rust's asynchronous &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; type. This half can only be owned by one thread, but it can be cloned to send to other threads.</source>
          <target state="translated">Rust의 비동기 &lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; 유형 의 절반을 전송 합니다. 이 절반은 하나의 스레드 만 소유 할 수 있지만 다른 스레드로 보내도록 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52ce535fefd9bc68502a1a5978b6409a82fd1bcb" translate="yes" xml:space="preserve">
          <source>The sending-half of Rust's synchronous &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">Rust의 동기 &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt; 유형 의 절반을 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="937e495e6de5b225295fc788a2b8a9723c5d12e3" translate="yes" xml:space="preserve">
          <source>The sequential nature of the tuple applies to its implementations of various traits. For example, in &lt;code&gt;PartialOrd&lt;/code&gt; and &lt;code&gt;Ord&lt;/code&gt;, the elements are compared sequentially until the first non-equal set is found.</source>
          <target state="translated">튜플의 순차적 특성은 다양한 특성의 구현에 적용됩니다. 예를 들어 &lt;code&gt;PartialOrd&lt;/code&gt; 및 &lt;code&gt;Ord&lt;/code&gt; 에서 요소는 첫 번째 같지 않은 세트가 발견 될 때까지 순차적으로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="faf864ad82a0182728e07d76ebfb5f1fdf6dc8f4" translate="yes" xml:space="preserve">
          <source>The signed two's complement integer types consist of:</source>
          <target state="translated">부호있는 2의 보수 정수 유형은 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="0a593fcbffb90fbe9434a8bd0cd231a38381ce34" translate="yes" xml:space="preserve">
          <source>The simplest Rust programs, like the one we&amp;rsquo;ve written so far, don&amp;rsquo;t have any dependencies. So if we had built the &amp;ldquo;Hello, world!&amp;rdquo; project with Cargo, it would only use the part of Cargo that handles building your code. As you write more complex Rust programs, you&amp;rsquo;ll add dependencies, and if you start a project using Cargo, adding dependencies will be much easier to do.</source>
          <target state="translated">지금까지 작성한 것과 같은 가장 간단한 Rust 프로그램은 의존성이 없습니다. 그래서 우리가&amp;ldquo;Hello, world!&amp;rdquo;를 만들었다면 Cargo로 프로젝트를 진행하는 경우 코드 작성을 처리하는 Cargo의 일부만 사용합니다. 더 복잡한 Rust 프로그램을 작성할 때 종속성을 추가하고 Cargo를 사용하여 프로젝트를 시작하면 종속성을 추가하는 것이 훨씬 쉬워집니다.</target>
        </trans-unit>
        <trans-unit id="0dca1ad1ce59bbb51cae453b849e2d3bd139c7cf" translate="yes" xml:space="preserve">
          <source>The simplest Rust programs, like the one we&amp;rsquo;ve written so far, don&amp;rsquo;t have any dependencies. So if we had built the Hello, world! project with Cargo, it would only use the part of Cargo that handles building your code. As you write more complex Rust programs, you&amp;rsquo;ll add dependencies, and if you start a project using Cargo, adding dependencies will be much easier to do.</source>
          <target state="translated">지금까지 작성한 프로그램과 같은 가장 간단한 Rust 프로그램에는 종속성이 없습니다. 우리가 Hello, world를 만들었다면! Cargo를 사용하면 코드 작성을 처리하는 Cargo 부분 만 사용합니다. 더 복잡한 Rust 프로그램을 작성할 때 종속성을 추가하게되며 Cargo를 사용하여 프로젝트를 시작하면 종속성을 추가하는 것이 훨씬 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="cc9fb663ff26b10b3b0480942ea72891d7b9e8a8" translate="yes" xml:space="preserve">
          <source>The single-address property of statics is required.</source>
          <target state="translated">스태틱의 단일 주소 속성이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="019cb91a15aad53bc6628eee08e1df33b769b170" translate="yes" xml:space="preserve">
          <source>The size and offset of fields is determined by the following algorithm.</source>
          <target state="translated">필드의 크기와 오프셋은 다음 알고리즘에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="cd076db2ed4f4f71100b51cbd80768553b1f9904" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddr&lt;/code&gt; instance may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;SocketAddr&lt;/code&gt; 인스턴스 의 크기 는 대상 운영 체제에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36d5ae29044e3939345f3681fd2eee4951ec1d94" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddrV4&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;SocketAddrV4&lt;/code&gt; 구조체 의 크기 는 대상 운영 체제에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa0a80c41eafe63e764438582cea6579e34fa99a" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddrV6&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;SocketAddrV6&lt;/code&gt; 구조체 의 크기 는 대상 운영 체제에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8de810002bae6a69cc3fd5fc7b805d907b3e5fa" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SystemTime&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;SystemTime&lt;/code&gt; 구조체 의 크기 는 대상 운영 체제에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b0dd86b903ec8c3b54b21a61cbefcfccd34c7a3" translate="yes" xml:space="preserve">
          <source>The size of a recursive type must be finite; in other words the recursive fields of the type must be &lt;a href=&quot;types/pointer&quot;&gt;pointer types&lt;/a&gt;.</source>
          <target state="translated">재귀 유형의 크기는 유한해야합니다. 다시 말해, 유형의 재귀 필드는 &lt;a href=&quot;types/pointer&quot;&gt;포인터 유형&lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c26f5c42f6a164861e02ed67750e160fcf8f0712" translate="yes" xml:space="preserve">
          <source>The size of a symbolic link is the length of the pathname it contains, without a terminating null byte.</source>
          <target state="translated">기호 링크의 크기는 종료 널 바이트가없는 경로 이름의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="e1eaacf69ef80cbba3a3f01cf2e10bd4a9a5fca5" translate="yes" xml:space="preserve">
          <source>The size of a type in bytes.</source>
          <target state="translated">유형의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="96cd8943bd738b362434700faacd7dc900194564" translate="yes" xml:space="preserve">
          <source>The size of a union is the size of its largest field.</source>
          <target state="translated">공용체의 크기는 가장 큰 필드의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="b7e7e7e0bae0750a49867bf9a72696378b080c09" translate="yes" xml:space="preserve">
          <source>The size of a value has two definitions.</source>
          <target state="translated">값의 크기에는 두 가지 정의가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e402a67efb4a62fa553a5f1394c869ac08acac0" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Instant&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;Instant&lt;/code&gt; 구조체 의 크기 는 대상 운영 체제에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba89d7b73eb9567f0b0c3196e6cf2e84c9f4c35c" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;IpAddr&lt;/code&gt; instance may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;IpAddr&lt;/code&gt; 인스턴스 의 크기 는 대상 운영 체제에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64ef5aa718e0f2a4fb9998a036169d75f54db6df" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Ipv4Addr&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;Ipv4Addr&lt;/code&gt; 의 크기 구조체 는 대상 운영 체제에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b28d6468d140c4a12bab4e35b4415d244e5f859a" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Ipv6Addr&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;Ipv6Addr&lt;/code&gt; 구조체 의 크기 는 대상 운영 체제에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a01d57dab257711e2df9579c72d88d59028c40dc" translate="yes" xml:space="preserve">
          <source>The size of most primitives is given in this table.</source>
          <target state="translated">대부분의 기본 요소의 크기가이 표에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a098a792b06569a6bb6f2b7d98cf8797dcd4ec6" translate="yes" xml:space="preserve">
          <source>The size of the referenced value in bytes.</source>
          <target state="translated">참조 된 값의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="62333b23a5b2b89de3b055144daa334820b9c575" translate="yes" xml:space="preserve">
          <source>The size of this integer type in bits.</source>
          <target state="translated">이 정수 유형의 크기 (비트)입니다.</target>
        </trans-unit>
        <trans-unit id="7c1fbeb1b5be430f1bc9e3a92e1dadba4b4fdb71" translate="yes" xml:space="preserve">
          <source>The size of this primitive is how many bytes it takes to reference any location in memory. For example, on a 32 bit target, this is 4 bytes and on a 64 bit target, this is 8 bytes.</source>
          <target state="translated">이 프리미티브의 크기는 메모리의 모든 위치를 참조하는 데 걸리는 바이트 수입니다. 예를 들어, 32 비트 대상에서는 4 바이트이고 64 비트 대상에서는 8 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="eaea58fd5debec4469854dd4c0d7e96ee309fa5f" translate="yes" xml:space="preserve">
          <source>The slice is assumed to be partitioned according to the given predicate. This means that all elements for which the predicate returns true are at the start of the slice and all elements for which the predicate returns false are at the end. For example, [7, 15, 3, 5, 4, 12, 6] is a partitioned under the predicate x % 2 != 0 (all odd numbers are at the start, all even at the end).</source>
          <target state="translated">슬라이스는 주어진 술어에 따라 분할 된 것으로 간주됩니다. 이는 술어가 true를 리턴하는 모든 요소가 슬라이스의 시작에 있고 술어가 false를 리턴하는 모든 요소가 끝에 있음을 의미합니다. 예를 들어, [7, 15, 3, 5, 4, 12, 6]은 술어 x % 2! = 0으로 분할됩니다 (모든 홀수는 시작에 있고 모두 끝에도 있음).</target>
        </trans-unit>
        <trans-unit id="8e51743ff7cd79535af677e289113dcff07dbe9c" translate="yes" xml:space="preserve">
          <source>The slice used to create a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; must have one and only one nul byte at the end of the slice.</source>
          <target state="translated">&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt; 을 만드는 데 사용되는 슬라이스 는 슬라이스 끝에 하나의 널 바이트 만 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="06c3ab06faa47dfc08256f59e9e6b62a827af728" translate="yes" xml:space="preserve">
          <source>The slice used to create a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; must have one and only one nul byte, positioned at the end.</source>
          <target state="translated">&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt; 을 만드는 데 사용되는 슬라이스 에는 끝에 위치하는 하나의 nul 바이트 만 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ad56ccc65a97d6c0192795237bde8dc8a187bcc7" translate="yes" xml:space="preserve">
          <source>The slices implement &lt;code&gt;IntoIterator&lt;/code&gt;. The iterator yields references to the slice elements.</source>
          <target state="translated">슬라이스는 &lt;code&gt;IntoIterator&lt;/code&gt; 를 구현 합니다 . 반복자는 슬라이스 요소에 대한 참조를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4d54f29cfdc5fb0b14c6bc3d825908235a2d1e62" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type.</source>
          <target state="translated">이 정수 유형으로 표시 할 수있는 가장 작은 값입니다.</target>
        </trans-unit>
        <trans-unit id="2ed21758c259b01204be09a1e5a970a7587f0275" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i128#associatedconstant.MIN&quot;&gt;&lt;code&gt;i128::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 나타낼 수있는 가장 작은 값입니다. 대신 &lt;a href=&quot;../primitive.i128#associatedconstant.MIN&quot;&gt; &lt;code&gt;i128::MIN&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5a50b28fc392edeb96ae6e8bbc1f3f65f1879e9" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i16#associatedconstant.MIN&quot;&gt;&lt;code&gt;i16::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 나타낼 수있는 가장 작은 값입니다. 대신 &lt;a href=&quot;../primitive.i16#associatedconstant.MIN&quot;&gt; &lt;code&gt;i16::MIN&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fab5eaa27a5d1f357d4d2bc91b9af02383caede4" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i32#associatedconstant.MIN&quot;&gt;&lt;code&gt;i32::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 나타낼 수있는 가장 작은 값입니다. 대신 &lt;a href=&quot;../primitive.i32#associatedconstant.MIN&quot;&gt; &lt;code&gt;i32::MIN&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc283863a8f984dedbdb2f90ee6338a2b682ff86" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i64#associatedconstant.MIN&quot;&gt;&lt;code&gt;i64::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 나타낼 수있는 가장 작은 값입니다. 대신 &lt;a href=&quot;../primitive.i64#associatedconstant.MIN&quot;&gt; &lt;code&gt;i64::MIN&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="da8fcd8d47309d686d033e491c707f9a8e4582c1" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i8#associatedconstant.MIN&quot;&gt;&lt;code&gt;i8::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 나타낼 수있는 가장 작은 값입니다. 대신 &lt;a href=&quot;../primitive.i8#associatedconstant.MIN&quot;&gt; &lt;code&gt;i8::MIN&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="124d5af779df7e9ad406378d4ae95baeff0f8e12" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.isize#associatedconstant.MIN&quot;&gt;&lt;code&gt;isize::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 나타낼 수있는 가장 작은 값입니다. 대신 &lt;a href=&quot;../primitive.isize#associatedconstant.MIN&quot;&gt; &lt;code&gt;isize::MIN&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d7283dc0e8aef63acf9dd8ecc15410819b62a917" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u128#associatedconstant.MIN&quot;&gt;&lt;code&gt;u128::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 나타낼 수있는 가장 작은 값입니다. 대신 &lt;a href=&quot;../primitive.u128#associatedconstant.MIN&quot;&gt; &lt;code&gt;u128::MIN&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4e1d26d88d80abad9936f065a519a8e6dae555c2" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u16#associatedconstant.MIN&quot;&gt;&lt;code&gt;u16::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 나타낼 수있는 가장 작은 값입니다. 대신 &lt;a href=&quot;../primitive.u16#associatedconstant.MIN&quot;&gt; &lt;code&gt;u16::MIN&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c5170dcabff61b3cd439cd574c1475742baecf6" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u32#associatedconstant.MIN&quot;&gt;&lt;code&gt;u32::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 나타낼 수있는 가장 작은 값입니다. 대신 &lt;a href=&quot;../primitive.u32#associatedconstant.MIN&quot;&gt; &lt;code&gt;u32::MIN&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0709e957f7976c853e280aae68478111e39066d5" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u64#associatedconstant.MIN&quot;&gt;&lt;code&gt;u64::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 나타낼 수있는 가장 작은 값입니다. 대신 &lt;a href=&quot;../primitive.u64#associatedconstant.MIN&quot;&gt; &lt;code&gt;u64::MIN&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa14915f9b53a3b041d9be135f24e5f469a12ccc" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u8#associatedconstant.MIN&quot;&gt;&lt;code&gt;u8::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 나타낼 수있는 가장 작은 값입니다. 대신 &lt;a href=&quot;../primitive.u8#associatedconstant.MIN&quot;&gt; &lt;code&gt;u8::MIN&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="275bb49ca6506b300934116c83ccd1ff11d81477" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.usize#associatedconstant.MIN&quot;&gt;&lt;code&gt;usize::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 정수 유형으로 나타낼 수있는 가장 작은 값입니다. 대신 &lt;a href=&quot;../primitive.usize#associatedconstant.MIN&quot;&gt; &lt;code&gt;usize::MIN&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c371b87930b46855075594aef0b191a2dcbb6afc" translate="yes" xml:space="preserve">
          <source>The smart pointer &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is also not &lt;code&gt;Sync&lt;/code&gt; for the same reasons that it&amp;rsquo;s not &lt;code&gt;Send&lt;/code&gt;. The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type (which we talked about in Chapter 15) and the family of related &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; types are not &lt;code&gt;Sync&lt;/code&gt;. The implementation of borrow checking that &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; does at runtime is not thread-safe. The smart pointer &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; and can be used to share access with multiple threads as you saw in the &lt;a href=&quot;ch16-03-shared-state#sharing-a-mutext-between-multiple-threads&quot;&gt;&amp;ldquo;Sharing a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; Between Multiple Threads&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">스마트 포인터 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 도 &lt;code&gt;Send&lt;/code&gt; 가 아닌 것과 같은 이유로 &lt;code&gt;Sync&lt;/code&gt; 되지 않습니다 . &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; (우리는 15 장에서 이야기) 유형 및 관련 가족 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 유형이 없습니다 &lt;code&gt;Sync&lt;/code&gt; . &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 이 런타임에 수행하는 빌리 검사의 구현은 스레드 안전하지 않습니다. 스마트 포인터 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 는 &lt;code&gt;Sync&lt;/code&gt; 이며 &lt;a href=&quot;ch16-03-shared-state#sharing-a-mutext-between-multiple-threads&quot;&gt;&amp;ldquo; &lt;/a&gt;여러 스레드 간 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 공유&amp;rdquo; 에서 볼 수 있듯이 여러 스레드와 액세스를 공유하는 데 사용할 수 있습니다 섹션 .</target>
        </trans-unit>
        <trans-unit id="348ea7c78b50388dc12ad8afa807cfbceb141e14" translate="yes" xml:space="preserve">
          <source>The socket will be closed when the value is dropped.</source>
          <target state="translated">값이 떨어지면 소켓이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="26c3406d4e79e978c77c7f71fb4706519f7ecd96" translate="yes" xml:space="preserve">
          <source>The solution here is to return the &lt;code&gt;String&lt;/code&gt; directly:</source>
          <target state="translated">여기서 해결책은 &lt;code&gt;String&lt;/code&gt; 을 반환하는 것입니다 직접 .</target>
        </trans-unit>
        <trans-unit id="b153caaa35f5e55b36f6162bb71df5061ac16716" translate="yes" xml:space="preserve">
          <source>The solution is to choose a different name that doesn't conflict with any external crate imported into the current module.</source>
          <target state="translated">해결책은 현재 모듈로 가져온 외부 상자와 충돌하지 않는 다른 이름을 선택하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="184f5f1102022e13bc531fc4c3a2f314884b9200" translate="yes" xml:space="preserve">
          <source>The solution is to coerce the array to a slice by calling a slice method:</source>
          <target state="translated">해결책은 slice 메소드를 호출하여 배열을 슬라이스로 강제 변환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4b8f691075403fc3cc04a12f17630d0a22222627" translate="yes" xml:space="preserve">
          <source>The solution is to declare the imports at the top of the block, function, or file.</source>
          <target state="translated">해결책은 블록, 함수 또는 파일 맨 위에 가져 오기를 선언하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6d341bfc87265fdb3200162c1071f84eb34afeb9" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to ensure that the items that you are re-exporting are themselves marked with &lt;code&gt;pub&lt;/code&gt;:</source>
          <target state="translated">이 문제에 대한 해결책은 다시 내보내는 항목이 자체적으로 &lt;code&gt;pub&lt;/code&gt; 표시되도록하는 것입니다. .</target>
        </trans-unit>
        <trans-unit id="ca1c4540563346f3ae5ba53810b40773e7e12128" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to ensure that the module that you are re-exporting is itself marked with &lt;code&gt;pub&lt;/code&gt;:</source>
          <target state="translated">이 문제에 대한 해결책은 다시 내보내는 모듈 자체가 &lt;code&gt;pub&lt;/code&gt; 으로 표시되어 있는지 확인하는 것입니다. .</target>
        </trans-unit>
        <trans-unit id="ca9d7e79f3cd051af83e1b93c6feb0514cb1adc8" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to remove the extraneous associated constant:</source>
          <target state="translated">이 문제에 대한 해결책은 관련없는 상수를 제거하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b66ecfc5844845f6ce826665530fcbac23beb458" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to remove the extraneous associated type:</source>
          <target state="translated">이 문제에 대한 해결책은 관련없는 유형을 제거하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f5e669f80a825dd22d2d4e3f89464bdf72e0692e" translate="yes" xml:space="preserve">
          <source>The solution to this problem is usually to switch to using a &lt;code&gt;move&lt;/code&gt; closure. This approach moves (or copies, where possible) data into the closure, rather than taking references to it. For example:</source>
          <target state="translated">이 문제에 대한 해결책은 일반적으로 &lt;code&gt;move&lt;/code&gt; 을 사용하도록 전환하는 것입니다 클로저 입니다. 이 방법은 데이터를 참조하지 않고 클로저로 데이터를 이동 (또는 가능한 경우 복사)합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4bc18e7ccda6a6b48c7507cdd496e8030bd28ca8" translate="yes" xml:space="preserve">
          <source>The source files from which this book is generated can be found on &lt;a href=&quot;https://github.com/rust-lang/book/tree/master/src&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">이 책이 생성 된 소스 파일은 &lt;a href=&quot;https://github.com/rust-lang/book/tree/master/src&quot;&gt;GitHub&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a49d6b47901cd19039274da891afacb7623398fb" translate="yes" xml:space="preserve">
          <source>The spawned thread may outlive the caller (unless the caller thread is the main thread; the whole process is terminated when the main thread finishes). The join handle can be used to block on termination of the child thread, including recovering its panics.</source>
          <target state="translated">생성 된 스레드는 호출자보다 오래 지속될 수 있습니다 (호출자 스레드가 기본 스레드가 아닌 경우 전체 프로세스는 기본 스레드가 완료되면 종료됩니다). 결합 핸들을 사용하여 패닉 복구를 포함하여 하위 스레드 종료시 차단할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3de206631f62d211730a1cc35e89663e7062bcfa" translate="yes" xml:space="preserve">
          <source>The specified environment variable was found, but it did not contain valid unicode data. The found data is returned as a payload of this variant.</source>
          <target state="translated">지정된 환경 변수를 찾았지만 유효한 유니 코드 데이터가 없습니다. 찾은 데이터는이 변형의 페이로드로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ea36c8e1fa9f0022c16977222444b4a3c0ab84f9" translate="yes" xml:space="preserve">
          <source>The specified environment variable was not present in the current process's environment.</source>
          <target state="translated">지정된 환경 변수가 현재 프로세스 환경에 없습니다.</target>
        </trans-unit>
        <trans-unit id="9c4c268712a390c3c5b86d16dfd79086d462c7e5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../any/fn.type_name&quot;&gt;&lt;code&gt;core::any::type_name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45eb3e7f185d35fea76d0fcc8feefcf81bfa67b6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../any/fn.type_name&quot;&gt;&lt;code&gt;crate::any::type_name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../any/fn.type_name&quot;&gt; &lt;code&gt;crate::any::type_name&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="89d879802905e96d1dbbee3b2bc193bcd1e8d256" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../any/struct.typeid#method.of&quot;&gt;&lt;code&gt;core::any::TypeId::of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9900dab1e575f89f6a70cab38ccde57d12f174" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../any/struct.typeid#method.of&quot;&gt;&lt;code&gt;crate::any::TypeId::of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../any/struct.typeid#method.of&quot;&gt; &lt;code&gt;crate::any::TypeId::of&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="57f913c926721dcfb858ba0f49073ea9578b8b3f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;core::hint::unreachable_unchecked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="176610383e559ab75c30b3e60918dcf39baa4491" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;crate::hint::unreachable_unchecked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt; &lt;code&gt;crate::hint::unreachable_unchecked&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="769e7a49a82fbc73600ab216f157a9a4edfed6d2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;std::hint::unreachable_unchecked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt; &lt;code&gt;std::hint::unreachable_unchecked&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="68bf1becb5538df04aef3bc27ba3a8fc1c5f4d80" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.align_of&quot;&gt;&lt;code&gt;core::mem::align_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f707ad710f27d4a519df162d93207b489b43663" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.align_of&quot;&gt;&lt;code&gt;crate::mem::align_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../mem/fn.align_of&quot;&gt; &lt;code&gt;crate::mem::align_of&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bb235568e3ec680a5ddbb056614a4544c534c3b1" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.align_of_val&quot;&gt;&lt;code&gt;core::mem::align_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb92f5b8279175442866093e128f5cb80c5d7d4" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.align_of_val&quot;&gt;&lt;code&gt;crate::mem::align_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../mem/fn.align_of_val&quot;&gt; &lt;code&gt;crate::mem::align_of_val&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5b63712fb966ee55e431373c44ee70e5bdcc0d5f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.discriminant&quot;&gt;&lt;code&gt;core::mem::discriminant&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a9a6b3a12732480c74ccdbdd6c6cd441416852" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.discriminant&quot;&gt;&lt;code&gt;crate::mem::discriminant&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../mem/fn.discriminant&quot;&gt; &lt;code&gt;crate::mem::discriminant&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2f183bce94483cede38b2e29f8c8da04b39e389f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.needs_drop&quot;&gt;&lt;code&gt;mem::needs_drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626a03e32989e459202fcca2e29d114287d2e779" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.needs_drop&quot;&gt;&lt;code&gt;std::mem::needs_drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../mem/fn.needs_drop&quot;&gt; &lt;code&gt;std::mem::needs_drop&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cf0f4e1682c5598721794a53177e6ce27697d607" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.size_of&quot;&gt;&lt;code&gt;core::mem::size_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b581000bfc2472e309baf4b78516cb35a337926" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.size_of&quot;&gt;&lt;code&gt;std::mem::size_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../mem/fn.size_of&quot;&gt; &lt;code&gt;std::mem::size_of&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4df5be2153e7097fd8b00742eff3c445821681d5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.size_of_val&quot;&gt;&lt;code&gt;mem::size_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5867b1e1c4944c1f7ed32488f5be2fa294b4986f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.size_of_val&quot;&gt;&lt;code&gt;std::mem::size_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../mem/fn.size_of_val&quot;&gt; &lt;code&gt;std::mem::size_of_val&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1746aa772dc9c98fd4e848556bc017af5d5a5814" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.abs&quot;&gt;&lt;code&gt;std::f32::abs&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.abs&quot;&gt; &lt;code&gt;std::f32::abs&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd019f674bd918f6d03e4b0946395283db961b78" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.ceil&quot;&gt;&lt;code&gt;std::f32::ceil&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.ceil&quot;&gt; &lt;code&gt;std::f32::ceil&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="26bbd19c72d02740271e9c35e7a28be8dc08d048" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.copysign&quot;&gt;&lt;code&gt;std::f32::copysign&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.copysign&quot;&gt; &lt;code&gt;std::f32::copysign&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="61c494ecc8ddd36d321a87c24568cbae459fddb9" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.cos&quot;&gt;&lt;code&gt;std::f32::cos&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.cos&quot;&gt; &lt;code&gt;std::f32::cos&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94b0a8ab3fca707be3b5a4c013197b6ace7d6752" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.exp&quot;&gt;&lt;code&gt;std::f32::exp&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.exp&quot;&gt; &lt;code&gt;std::f32::exp&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="336a8852727ebc5c24637be3db7e37b682324956" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.exp2&quot;&gt;&lt;code&gt;std::f32::exp2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.exp2&quot;&gt; &lt;code&gt;std::f32::exp2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="46e4b0f6edf39422d28e3db71bd5ccc4aa08c8f3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.floor&quot;&gt;&lt;code&gt;std::f32::floor&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.floor&quot;&gt; &lt;code&gt;std::f32::floor&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c54f6e18bc6b7c8320c4a68ccd5c641025d11b6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.ln&quot;&gt;&lt;code&gt;std::f32::ln&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.ln&quot;&gt; &lt;code&gt;std::f32::ln&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d8fbd8555b23fb5da5a31c3691aceae539093012" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.log10&quot;&gt;&lt;code&gt;std::f32::log10&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.log10&quot;&gt; &lt;code&gt;std::f32::log10&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="163981a463a3f186e653d8b1d906aacc60bb507a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.log2&quot;&gt;&lt;code&gt;std::f32::log2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.log2&quot;&gt; &lt;code&gt;std::f32::log2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aad71542a1a997b3c3c61f5ecfa210cbb95931d8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.max&quot;&gt;&lt;code&gt;f32::max&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.max&quot;&gt; &lt;code&gt;f32::max&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="275c6f9b837c44f59265b27a725f706ea01e4d88" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.min&quot;&gt;&lt;code&gt;f32::min&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.min&quot;&gt; &lt;code&gt;f32::min&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="37a1adc351bf8541ff50457503f42947d2223aa1" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.mul_add&quot;&gt;&lt;code&gt;std::f32::mul_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.mul_add&quot;&gt; &lt;code&gt;std::f32::mul_add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="824767dc22e0a666300f3bbc86838e9e982d5929" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.powf&quot;&gt;&lt;code&gt;std::f32::powf&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.powf&quot;&gt; &lt;code&gt;std::f32::powf&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a9c8c235c9463f3bd3c7f8d97084f0aa09a4e6b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.powi&quot;&gt;&lt;code&gt;std::f32::powi&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.powi&quot;&gt; &lt;code&gt;std::f32::powi&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f7c21362121499d029cb16e6e1a0c1b3f1e8a1a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.round&quot;&gt;&lt;code&gt;std::f32::round&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.round&quot;&gt; &lt;code&gt;std::f32::round&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4af107006e6e31e8e831e5d5f7bf515b2e1cc7d" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.sin&quot;&gt;&lt;code&gt;std::f32::sin&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.sin&quot;&gt; &lt;code&gt;std::f32::sin&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34b79ebb4c8dc7ee3e2e853d2ae83194460b52cd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.sqrt&quot;&gt;&lt;code&gt;std::f32::sqrt&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.sqrt&quot;&gt; &lt;code&gt;std::f32::sqrt&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c2f3efeb8ac74af1f762963525599c78dfb84b4" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.trunc&quot;&gt;&lt;code&gt;std::f32::trunc&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.trunc&quot;&gt; &lt;code&gt;std::f32::trunc&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f50e2d709a0ab57a5af9a3d0b85809c7253cdbbe" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.abs&quot;&gt;&lt;code&gt;std::f64::abs&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.abs&quot;&gt; &lt;code&gt;std::f64::abs&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b8077c0447a55f70ad3a41280e7cdad8b5a596e3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.ceil&quot;&gt;&lt;code&gt;std::f64::ceil&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.ceil&quot;&gt; &lt;code&gt;std::f64::ceil&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0c784852d478dc5b87ed608a83b4485e61ffaa08" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.copysign&quot;&gt;&lt;code&gt;std::f64::copysign&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.copysign&quot;&gt; &lt;code&gt;std::f64::copysign&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3706879950fc2f859ec3405d83c39468b3d127b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.cos&quot;&gt;&lt;code&gt;std::f64::cos&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.cos&quot;&gt; &lt;code&gt;std::f64::cos&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3fe60787bdb5a14582899986ea8a8eb5151f047a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.exp&quot;&gt;&lt;code&gt;std::f64::exp&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.exp&quot;&gt; &lt;code&gt;std::f64::exp&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d57c3217aae4fa0b39647c7df0a1a27ba3ce04c" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.exp2&quot;&gt;&lt;code&gt;std::f64::exp2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.exp2&quot;&gt; &lt;code&gt;std::f64::exp2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06ec2f6c9475943bd6d7a554d14049a4e570f218" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.floor&quot;&gt;&lt;code&gt;std::f64::floor&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.floor&quot;&gt; &lt;code&gt;std::f64::floor&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95c322d0525dc747c93c991f848c51c52ac90096" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.ln&quot;&gt;&lt;code&gt;std::f64::ln&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.ln&quot;&gt; &lt;code&gt;std::f64::ln&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="85342dac467b551f64948da385b26bae5ec304e2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.log10&quot;&gt;&lt;code&gt;std::f64::log10&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.log10&quot;&gt; &lt;code&gt;std::f64::log10&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1fcf5615e4f3f284291f587c194c0ee80f02e1b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.log2&quot;&gt;&lt;code&gt;std::f64::log2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.log2&quot;&gt; &lt;code&gt;std::f64::log2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a33d40ec03fc6fd7670da5d91bb3dff1514508d8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.max&quot;&gt;&lt;code&gt;f64::max&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.max&quot;&gt; &lt;code&gt;f64::max&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c5caceb4a4959b387b99fbf4eb4112cfa719de9" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.min&quot;&gt;&lt;code&gt;f64::min&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.min&quot;&gt; &lt;code&gt;f64::min&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="184af9c54cafa84b2f1da9d8430a1cc45e2501b8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.mul_add&quot;&gt;&lt;code&gt;std::f64::mul_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.mul_add&quot;&gt; &lt;code&gt;std::f64::mul_add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f8a62ab1447e5a688dfc2804caf90414ec922c3e" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.powf&quot;&gt;&lt;code&gt;std::f64::powf&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.powf&quot;&gt; &lt;code&gt;std::f64::powf&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53fa85dcefba2eba944e099df5e0b7568320b594" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.powi&quot;&gt;&lt;code&gt;std::f64::powi&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.powi&quot;&gt; &lt;code&gt;std::f64::powi&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab11dcc6899cdf3c196ec2500a4f98d80cd92c0f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.round&quot;&gt;&lt;code&gt;std::f64::round&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.round&quot;&gt; &lt;code&gt;std::f64::round&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cbc17db1c9e9aeccadbae543736abc641bf19581" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.sin&quot;&gt;&lt;code&gt;std::f64::sin&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.sin&quot;&gt; &lt;code&gt;std::f64::sin&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9259a474b9633d2c178bcfa8945b9cf932f9b62" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.sqrt&quot;&gt;&lt;code&gt;std::f64::sqrt&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.sqrt&quot;&gt; &lt;code&gt;std::f64::sqrt&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09d46fbb4d6dd94cb20b274b64fb45bedd897ee1" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.trunc&quot;&gt;&lt;code&gt;std::f64::trunc&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.trunc&quot;&gt; &lt;code&gt;std::f64::trunc&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e24ba042f8ed9a32e5152ef40108b6331e9ff075" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;std::pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;std::pointer::offset&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a8ef8497ee38f892bb72694c3c391e01cf452f3c" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.pointer#method.wrapping_offset&quot;&gt;&lt;code&gt;std::pointer::wrapping_offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.pointer#method.wrapping_offset&quot;&gt; &lt;code&gt;std::pointer::wrapping_offset&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="93a878abfa4b4b05965b5ed62c9134a4b23816af" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../process/fn.abort&quot;&gt;&lt;code&gt;std::process::abort&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../process/fn.abort&quot;&gt; &lt;code&gt;std::process::abort&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f777a2d25d61f2a8a030aed5ab4e20e176d153a8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.read_volatile&quot;&gt;&lt;code&gt;core::ptr::read_volatile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc0344746e9b397b268af814908260e075e04e91" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.read_volatile&quot;&gt;&lt;code&gt;crate::ptr::read_volatile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../ptr/fn.read_volatile&quot;&gt; &lt;code&gt;crate::ptr::read_volatile&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="05ad03e9160cb2408f7bd5aa45c03727935da29f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;core::ptr::write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="118ab008d64be2589235ff02dc721d1434d90f79" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;crate::ptr::write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;crate::ptr::write&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aac108773792d7b27741d0ad608d7eda680fdf09" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.write_volatile&quot;&gt;&lt;code&gt;core::ptr::write_volatile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70902b9a0728e1e3dbaf882574f3b031e91654e0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.write_volatile&quot;&gt;&lt;code&gt;crate::ptr::write_volatile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../ptr/fn.write_volatile&quot;&gt; &lt;code&gt;crate::ptr::write_volatile&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="625b254ad12639bd7cf3b4b8d18b0e6a86ce6669" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;fn.needs_drop&quot;&gt;&lt;code&gt;needs_drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;fn.needs_drop&quot;&gt; &lt;code&gt;needs_drop&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4decf20d903cd057fdbbe638ed8d8e3f26c756a4" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;fn.size_of&quot;&gt;&lt;code&gt;size_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;fn.size_of&quot;&gt; &lt;code&gt;size_of&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e4c9dc52f1e3d1631dde7d53032bcc39a6df9f72" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;fn.size_of_val&quot;&gt;&lt;code&gt;size_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;fn.size_of_val&quot;&gt; &lt;code&gt;size_of_val&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="58429d40c9c7f24b0a6d088073711682d0c11242" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt;&lt;code&gt;atomic::compiler_fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt; &lt;code&gt;atomic::compiler_fence&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5311916c06b10b8c928d0abda98be268ace4e6d6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt;&lt;code&gt;atomic::compiler_fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt; &lt;code&gt;atomic::compiler_fence&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3081645830dba10410e4d31cc6a792e5fa76abfc" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt;&lt;code&gt;atomic::compiler_fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt; &lt;code&gt;atomic::compiler_fence&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e8d39a214853d9287e37063d7cab0006a733cdd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt;&lt;code&gt;atomic::compiler_fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt; &lt;code&gt;atomic::compiler_fence&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2cb2b502c2611a7e2eb731a194ab104f5f862370" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt;&lt;code&gt;atomic::fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt; &lt;code&gt;atomic::fence&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="365e7e84eb752771b266d7d9e0c92f84d3398fe0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt;&lt;code&gt;atomic::fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt; &lt;code&gt;atomic::fence&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f323b62e22f70b85a5b00e81ad1dd75f18bb93e" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt;&lt;code&gt;atomic::fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt; &lt;code&gt;atomic::fence&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1bdf72440b67a4b60d0cb051b353e1a1e5f17d8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt;&lt;code&gt;atomic::fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt; &lt;code&gt;atomic::fence&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfb231858cd4689ec5627a23d29186ff8d439dec" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_max&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 부호있는 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicI32::fetch_max&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ba45a4ad89ca37d142fe08556abef04250897691" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_max&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 부호있는 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicI32::fetch_max&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f793986afe8163ac71ccb416509b9ce1b93b28a7" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_max&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 부호있는 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicI32::fetch_max&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="11f793b659028e7642830af52530c7830ca89493" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_max&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 부호있는 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicI32::fetch_max&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="49aafe40a8bc9c4c0d4799be407063a6be2f80b8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_max&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 부호있는 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicI32::fetch_max&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d1036b996bdd682cf46fc64099bdeb270500f551" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_min&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 부호있는 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicI32::fetch_min&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cb8002438bcf3c0d48b47c6879f85d416ab04436" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_min&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 부호있는 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicI32::fetch_min&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0a7b18952940b9b8182e6a6746cc4d6878e30de3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_min&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 부호있는 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicI32::fetch_min&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b2bf12a3e1dda34bbe1170fb23b2c7e3980fa2e2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_min&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 부호있는 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicI32::fetch_min&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e9e3416a187e1174aeae58104e7efc1c7ee03ff6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_min&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 부호있는 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicI32::fetch_min&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="17459feca9539df018355d8750621e9dbfee25c8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange&lt;/code&gt; 메소드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="84bb6ebc113b49007d6fcfdfafa151470c4d97fb" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange&lt;/code&gt; 메소드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b287de0c6ccb4c255ae592a699ddf51d510069e0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;success&lt;/code&gt; 및 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 전달 하여 &lt;code&gt;compare_exchange&lt;/code&gt; 메소드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dc152c646978658d528a198a309e91d74e54a326" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2c1db276c3b3b4fd7ceb4e380bed1da5745f7ffc" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;success&lt;/code&gt; 및 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 전달 하여 &lt;code&gt;compare_exchange&lt;/code&gt; 메소드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="951c50a3c5ccad37a2e3fca1e84b631f4373b483" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange&lt;/code&gt; 메소드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="128d2037df6a05cf07d2834b7655c68820b3bd26" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;success&lt;/code&gt; 및 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 전달 하여 &lt;code&gt;compare_exchange&lt;/code&gt; 메소드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0ab03d58d5f671c0a0db830b6b05ae77f18309c3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange&lt;/code&gt; 메소드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="88060a6c5fb7a5ab11e95c384921daa2c4d4f5bf" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange&lt;/code&gt; 메소드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bd12eff27bb275374d877eb262054ae1c853f908" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="af1fc10d6447bc6c5afd961766bf358a30dcbdba" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="00f0f125817ae56a57898beaed413be79b5a5f7f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;success&lt;/code&gt; 및 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5a4f22637924c144abe1815857665dade4d3c51b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="862ae83bdd80acbffd544e29d0952bfef39ef310" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;success&lt;/code&gt; 및 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 전달 하여 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 메소드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="301da9988d8a43a17c9bdfe746d0d24a87f91ac5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e408b07db98e8ee6804e680f2894d658fb2f63fb" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;success&lt;/code&gt; 및 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 전달 하여 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 메소드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4d2ce54b599780814ddae4cc41ff6842ce0dffc8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c3c44a7a6b16b40cf235a33892e670e0a8bc5178" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eae6f5127b74d22ebf6510c20a59c81a3de0cdfc" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_add&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="695ca0d01b208d0e14efcb78593ea9daca909ab8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_add&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e4a2657e5f8e4cdd6d19f74f32446cf634f2c708" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_add&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b27a067a3ca05d7ed184ca857f007a3ba758dcd5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_add&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6f042c7aafd7bdff469934311d53691a7a1a1045" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_add&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="91da36591ebb40c0553e91c9f934d905043cb8a9" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_and&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8e00a651851675118139e87206d58986105c4eb0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_and&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="18a857da52573d4e17b52a7e7c33c2b45cbcba5f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_and&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="af7b5f35485a9f9923b0a484a1951a30bb3a1887" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_and&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="993970aa50aa2516408dfe30230dc45762d3f244" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_and&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="460da953958feb4d29ef7b565f8bb84fe0c27874" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_or&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fe64adf45d801b3817879d281caf34973915fca3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_or&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="30017d261ccaa47677175bc1d115dd370a15f192" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_or&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6b88f8c0000bb8e04847190fb1bea4c60b0d2d4b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_or&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5515cfd3dce0baaa5d0933d153812410aa18e81b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_or&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="94f2a12d751dc3a744709ca812719eed5be6639d" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_sub&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt; &lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a7b08115a886002f8e0b6d94070bb4e793dcb17c" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_sub&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt; &lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="65021746bc3a29e483b54a665e8fe3993f3b7531" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_sub&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt; &lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9074d1309228123f0a179daab86adda956d06578" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_sub&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt; &lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bf31a4dfb044ce9c3c11fede562f450062e8cb70" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_sub&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt; &lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0a08ca4aeb864c545fa763c7c1bc0c6adeca1e10" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_xor&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="23e04028b595d303c299af1a09560b78dc738b23" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_xor&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d03d95dd3b76208c05df63103f2a4773075d06c7" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_xor&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="527ff76b4c308bdfc8590a98e3e2f36b010f0a65" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_xor&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2ecf9233457e6140afc96f591e6de39578ed746f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_xor&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b72330976c1ede5cb1f5f36f1315049842fbbb63" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;load&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt;&lt;code&gt;AtomicBool::load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;load&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt; &lt;code&gt;AtomicBool::load&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="07780502f5ae712c09c48bfbf053afbea4b8cc74" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;load&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt;&lt;code&gt;AtomicBool::load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;load&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt; &lt;code&gt;AtomicBool::load&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="61ddb64e96ce0f4ae971acf4e42bb38eda10bc9a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;load&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt;&lt;code&gt;AtomicBool::load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;load&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt; &lt;code&gt;AtomicBool::load&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dd50153000fdd2e98065597c848234d48c5ae7ef" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;store&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt;&lt;code&gt;AtomicBool::store&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;store&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt; &lt;code&gt;AtomicBool::store&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3a6dbd5587aa433e73f8c34d35d442568a18d942" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;store&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt;&lt;code&gt;AtomicBool::store&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;store&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt; &lt;code&gt;AtomicBool::store&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="83f72e56df4940284d7926cf923d2abdf7ea9bb4" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;store&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt;&lt;code&gt;AtomicBool::store&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;store&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt; &lt;code&gt;AtomicBool::store&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="52da2c5cb5cf0d647cd3855825f192673441bdbd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;swap&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt; &lt;code&gt;AtomicBool::swap&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1b30bfb1f2876b5af31915eef811a342ebcdd3b6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;swap&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt; &lt;code&gt;AtomicBool::swap&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4382bd14df2effe7e74aa90568e6832848eea4e2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;swap&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt; &lt;code&gt;AtomicBool::swap&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c61255cb553ed1c231e1f72bb0423d91f01ae315" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;swap&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt; &lt;code&gt;AtomicBool::swap&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a69be96162b6a1c17ecee094d784c23706a36adc" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;swap&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt; &lt;code&gt;AtomicBool::swap&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f289d7def13530cb2e5c5d7eaa967ea0cbc29ea7" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_max&lt;/code&gt; 메서드 를 통해 부호없는 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicU32::fetch_max&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4eb5f9b2cac38e545e679417e0916b9477cb828c" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_max&lt;/code&gt; 메서드 를 통해 부호없는 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicU32::fetch_max&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aedb9c670fb8b498f17ad50461be8607159cf171" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_max&lt;/code&gt; 메서드 를 통해 부호없는 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicU32::fetch_max&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="044d7d27fe09f49e2ad99740d35c149e3d409936" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_max&lt;/code&gt; 메서드 를 통해 부호없는 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicU32::fetch_max&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0c22889aedce154435ee258d0c40e6448efdbc64" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_max&lt;/code&gt; 메소드 를 통해 부호없는 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicU32::fetch_max&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9a58dd280c30118ad91cca00ca18fbb4a646d3fb" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_min&lt;/code&gt; 메서드 를 통해 부호없는 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicU32::fetch_min&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="89f1a35ffbfc66293f3ecb009316545b57e972fd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_min&lt;/code&gt; 메서드 를 통해 부호없는 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicU32::fetch_min&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6f36baf03828badd5e395776499479459fdf74dd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_min&lt;/code&gt; 메서드 를 통해 부호없는 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicU32::fetch_min&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d7b26c022d9640d58bf0ee1df55fea1127cc8b08" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_min&lt;/code&gt; 메서드 를 통해 부호없는 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicU32::fetch_min&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b715010a7a857987bd13e4e2c7860444d5f72aff" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_min&lt;/code&gt; 메서드 를 통해 부호없는 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicU32::fetch_min&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5f8d269b525f2aa0c49880dc3986476498a5a32" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_nand&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="45b7d1ba04947e0d60fd8323f25d9cb851df4d45" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_nand&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f0f46b18b5f9509f4b838f2cd1cc47b1cca4ac44" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_nand&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6eee377d6930faac324afa2f516a7fca7070547e" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_nand&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c150f5488b1c18a2f570344ce5e7e4fbf333ebdf" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_nand&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4467e4d025c942d0e46a8d42d28e9cb70772aadf" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;count_ones&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.count_ones&quot;&gt;&lt;code&gt;u32::count_ones&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;count_ones&lt;/code&gt; 메소드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.count_ones&quot;&gt; &lt;code&gt;u32::count_ones&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f49764c7bf099d11524ff3ae31ea8122bd687603" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;leading_zeros&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.leading_zeros&quot;&gt;&lt;code&gt;u32::leading_zeros&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;leading_zeros&lt;/code&gt; 메서드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.leading_zeros&quot;&gt; &lt;code&gt;u32::leading_zeros&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94453dce8a2a385d273d4c54481b7123c231b9e1" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;overflowing_add&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.overflowing_add&quot;&gt;&lt;code&gt;u32::overflowing_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;overflowing_add&lt;/code&gt; 메소드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.overflowing_add&quot;&gt; &lt;code&gt;u32::overflowing_add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="975a6bc8f0eb314f9e1b240024dd857b1481fb4f" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;overflowing_mul&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.overflowing_mul&quot;&gt;&lt;code&gt;u32::overflowing_mul&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;overflowing_mul&lt;/code&gt; 메소드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.overflowing_mul&quot;&gt; &lt;code&gt;u32::overflowing_mul&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05ac2c8d4649564823e71195e6e1991816e3c134" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;overflowing_sub&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.overflowing_sub&quot;&gt;&lt;code&gt;u32::overflowing_sub&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;overflowing_sub&lt;/code&gt; 메소드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.overflowing_sub&quot;&gt; &lt;code&gt;u32::overflowing_sub&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cea1555efef9a893424297cca53eccdff2cb4c12" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;reverse_bits&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.reverse_bits&quot;&gt;&lt;code&gt;u32::reverse_bits&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;reverse_bits&lt;/code&gt; 메서드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.reverse_bits&quot;&gt; &lt;code&gt;u32::reverse_bits&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="02b9a60eaad995a8b508e08e5f720afcfb3cdf4f" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;rotate_left&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.rotate_left&quot;&gt;&lt;code&gt;u32::rotate_left&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;rotate_left&lt;/code&gt; 메서드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.rotate_left&quot;&gt; &lt;code&gt;u32::rotate_left&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a39d8d5e922a37bc7cb7a4273c351e3237285524" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;rotate_right&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.rotate_right&quot;&gt;&lt;code&gt;u32::rotate_right&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;rotate_right&lt;/code&gt; 메서드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.rotate_right&quot;&gt; &lt;code&gt;u32::rotate_right&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1c9cb80ab093ca12a015c158de3a354687ef2774" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;saturating_add&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.saturating_add&quot;&gt;&lt;code&gt;u32::saturating_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;saturating_add&lt;/code&gt; 메소드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.saturating_add&quot;&gt; &lt;code&gt;u32::saturating_add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0dfb3fdba827a384aada0939a551d1f733164685" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;saturating_sub&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.saturating_sub&quot;&gt;&lt;code&gt;u32::saturating_sub&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;saturating_sub&lt;/code&gt; 메소드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.saturating_sub&quot;&gt; &lt;code&gt;u32::saturating_sub&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7476e3eb126b1478bcad495831ba6637eb3d2b14" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;swap_bytes&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.swap_bytes&quot;&gt;&lt;code&gt;u32::swap_bytes&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;swap_bytes&lt;/code&gt; 메서드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.swap_bytes&quot;&gt; &lt;code&gt;u32::swap_bytes&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e398694f9fea1333665249a1e9c25a4d94f59367" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;trailing_zeros&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.trailing_zeros&quot;&gt;&lt;code&gt;u32::trailing_zeros&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;trailing_zeros&lt;/code&gt; 메서드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.trailing_zeros&quot;&gt; &lt;code&gt;u32::trailing_zeros&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c77154ad25fdd3e2bc406487defdcb53ca75726" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;wrapping_add&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.wrapping_add&quot;&gt;&lt;code&gt;u32::wrapping_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc2b20ca06dc1c8110b4d0397b1994d813ffed56" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;wrapping_mul&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.wrapping_mul&quot;&gt;&lt;code&gt;u32::wrapping_mul&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00df89161b3ee01f6671c6eedc0e25647116beb0" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;wrapping_sub&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.wrapping_sub&quot;&gt;&lt;code&gt;u32::wrapping_sub&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07e69ca4af06caf0678a0eb7f58dbb4160ebfce9" translate="yes" xml:space="preserve">
          <source>The standard library API documentation describes methods that vectors, strings, and hash maps have that will be helpful for these exercises!</source>
          <target state="translated">표준 라이브러리 API 설명서에는 벡터, 문자열 및 해시 맵이 이러한 연습에 도움이되는 메소드가 설명되어 있습니다!</target>
        </trans-unit>
        <trans-unit id="ecfac3d3b7b498f942f6cc167a3014bcca50e8db" translate="yes" xml:space="preserve">
          <source>The standard library also provides a &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; newtype which ensures all standard arithmetic operations for &lt;code&gt;T&lt;/code&gt; have wrapping semantics.</source>
          <target state="translated">표준 라이브러리는 또한 &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; newtype을 제공하여 &lt;code&gt;T&lt;/code&gt; 에 대한 모든 표준 산술 연산에 랩핑 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e62bb358494cb55da1b597b5302098f7179da4a8" translate="yes" xml:space="preserve">
          <source>The standard library contains additional 'smart pointer' types beyond references and raw pointers.</source>
          <target state="translated">표준 라이브러리에는 참조 및 원시 포인터 이외의 추가 '스마트 포인터'유형이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aeb001acf27f60d5c3f4949174f0ea7b98815a0" translate="yes" xml:space="preserve">
          <source>The standard library documentation for the &lt;code&gt;env::args&lt;/code&gt; function shows that the type of the iterator it returns is &lt;code&gt;std::env::Args&lt;/code&gt;. We&amp;rsquo;ve updated the signature of the &lt;code&gt;Config::new&lt;/code&gt; function so the parameter &lt;code&gt;args&lt;/code&gt; has the type &lt;code&gt;std::env::Args&lt;/code&gt; instead of &lt;code&gt;&amp;amp;[String]&lt;/code&gt;. Because we&amp;rsquo;re taking ownership of &lt;code&gt;args&lt;/code&gt; and we&amp;rsquo;ll be mutating &lt;code&gt;args&lt;/code&gt; by iterating over it, we can add the &lt;code&gt;mut&lt;/code&gt; keyword into the specification of the &lt;code&gt;args&lt;/code&gt; parameter to make it mutable.</source>
          <target state="translated">&lt;code&gt;env::args&lt;/code&gt; 함수 의 표준 라이브러리 문서는 리턴하는 반복자의 유형이 &lt;code&gt;std::env::Args&lt;/code&gt; 임을 보여줍니다 . &lt;code&gt;args&lt;/code&gt; 매개 변수 의 유형 이 &lt;code&gt;&amp;amp;[String]&lt;/code&gt; 대신 &lt;code&gt;std::env::Args&lt;/code&gt; 형식이 되도록 &lt;code&gt;Config::new&lt;/code&gt; 함수 의 서명을 업데이트했습니다 . 우리는 &lt;code&gt;args&lt;/code&gt; 의 소유권을 취하고 그것을 반복함으로써 &lt;code&gt;args&lt;/code&gt; 를 변경 시킬 것이기 때문에, &lt;code&gt;mut&lt;/code&gt; 키워드를 &lt;code&gt;args&lt;/code&gt; 매개 변수 의 사양에 추가하여 변경 가능하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ac01984afb710ebee7af9fdef959461335b5771" translate="yes" xml:space="preserve">
          <source>The standard library does &lt;em&gt;not&lt;/em&gt; automatically wait on child processes (not even if the &lt;code&gt;Child&lt;/code&gt; is dropped), it is up to the application developer to do so. As a consequence, dropping &lt;code&gt;Child&lt;/code&gt; handles without waiting on them first is not recommended in long-running applications.</source>
          <target state="translated">표준 라이브러리는 자식 프로세스를 자동으로 기다리지 &lt;em&gt;않으며&lt;/em&gt; ( &lt;code&gt;Child&lt;/code&gt; 이 삭제 된 경우에도 ) 응용 프로그램 개발자의 책임입니다. 따라서 장시간 실행되는 응용 프로그램에서는 먼저 핸들을 기다리지 않고 &lt;code&gt;Child&lt;/code&gt; 핸들을 삭제 하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c3da8861a8cd359749d019429f14004546548517" translate="yes" xml:space="preserve">
          <source>The standard library exports many modules &lt;em&gt;with the same name as primitive types&lt;/em&gt;. These define additional items related to the primitive type, but not the all-important methods.</source>
          <target state="translated">표준 라이브러리 &lt;em&gt;는 기본 유형과 이름이 같은&lt;/em&gt; 많은 모듈 &lt;em&gt;을&lt;/em&gt; 내 보냅니다 . 이것들은 기본 유형과 관련된 추가 항목을 정의하지만 모든 중요한 방법은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="be570bfc11d12183d4ccfc099e5e91a1312fadce" translate="yes" xml:space="preserve">
          <source>The standard library exposes three common ways to deal with contiguous regions of memory:</source>
          <target state="translated">표준 라이브러리는 인접한 메모리 영역을 처리하는 세 가지 일반적인 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d66210e7b423f4f4e31543419e308e2c95ac4c07" translate="yes" xml:space="preserve">
          <source>The standard library has other types that provide interior mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;, which is similar except that instead of giving references to the inner value, the value is copied in and out of the &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;. There&amp;rsquo;s also &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;, which offers interior mutability that&amp;rsquo;s safe to use across threads; we&amp;rsquo;ll discuss its use in Chapter 16. Check out the standard library docs for more details on the differences between these types.</source>
          <target state="translated">표준 라이브러리에는 내부 변이성을 제공하는 다른 유형 (예 : &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; )이 있습니다. 이는 내부 값에 대한 참조를 제공하는 대신 값이 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 안팎으로 복사되는 것을 제외하고는 비슷 합니다. 도 있습니다 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 스레드는 스레드간에 안전하게 사용할 수있는 내부 변경 성을 제공합니다. 이러한 유형의 차이점에 대한 자세한 내용은 표준 라이브러리 문서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a3eb5ea324c5e016fa7225e0db42ddd0287496a0" translate="yes" xml:space="preserve">
          <source>The standard library implements some I/O traits on various types which are commonly used as a buffer, like &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;Cursor&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Cursor&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 와 같이 일반적으로 버퍼로 사용되는 다양한 유형의 일부 I / O 특성을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="bac69e8dd1e3e493ce33a798e654cad2d62974e3" translate="yes" xml:space="preserve">
          <source>The standard library implements some I/O traits on various types which are commonly used as a buffer, like &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../slice/index&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;Cursor&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Cursor&amp;lt;&lt;/code&gt; &lt;a href=&quot;../slice/index&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 와 같이 일반적으로 버퍼로 사용되는 다양한 유형에 대한 몇 가지 I / O 특성을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="cd43fc91f30c20105f33015f4862eaa4ba469ffd" translate="yes" xml:space="preserve">
          <source>The standard library in general strives to support both statically linked and dynamically linked C runtimes for targets as appropriate. For example the &lt;code&gt;x86_64-pc-windows-msvc&lt;/code&gt; and &lt;code&gt;x86_64-unknown-linux-musl&lt;/code&gt; targets typically come with both runtimes and the user selects which one they'd like. All targets in the compiler have a default mode of linking to the C runtime. Typically targets are linked dynamically by default, but there are exceptions which are static by default such as:</source>
          <target state="translated">표준 라이브러리는 일반적으로 대상에 대해 정적으로 링크 된 C 런타임과 동적으로 링크 된 C 런타임을 모두 지원하기 위해 노력합니다. 예를 들어 &lt;code&gt;x86_64-pc-windows-msvc&lt;/code&gt; 및 &lt;code&gt;x86_64-unknown-linux-musl&lt;/code&gt; 대상은 일반적으로 런타임과 함께 제공되며 사용자는 원하는 것을 선택합니다. 컴파일러의 모든 대상에는 C 런타임에 연결하는 기본 모드가 있습니다. 일반적으로 대상은 기본적으로 동적으로 연결되지만 기본적으로 정적 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e62009a1ff01cf79d8a5846c788aa68bf271141c" translate="yes" xml:space="preserve">
          <source>The standard library provides an implementation of &lt;code&gt;panic_handler&lt;/code&gt; that defaults to unwinding the stack but that can be &lt;a href=&quot;../book/ch09-01-unrecoverable-errors-with-panic&quot;&gt;changed to abort the process&lt;/a&gt;. The standard library's panic behavior can be modified at runtime with the &lt;a href=&quot;../std/panic/fn.set_hook&quot;&gt;set_hook&lt;/a&gt; function.</source>
          <target state="translated">표준 라이브러리는 스택 해제를 기본으로 설정하지만 &lt;a href=&quot;../book/ch09-01-unrecoverable-errors-with-panic&quot;&gt;프로세스를 중단&lt;/a&gt; 하도록 변경할 수있는 &lt;code&gt;panic_handler&lt;/code&gt; 의 구현을 제공합니다 . 표준 라이브러리의 패닉 동작은 런타임에 &lt;a href=&quot;../std/panic/fn.set_hook&quot;&gt;set_hook&lt;/a&gt; 함수를 사용하여 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6bfe00112d50ce1df3b69fa8e0f97c99e921c7e" translate="yes" xml:space="preserve">
          <source>The standard library&amp;rsquo;s &lt;code&gt;Add&lt;/code&gt; trait is an example of the second purpose: usually, you&amp;rsquo;ll add two like types, but the &lt;code&gt;Add&lt;/code&gt; trait provides the ability to customize beyond that. Using a default type parameter in the &lt;code&gt;Add&lt;/code&gt; trait definition means you don&amp;rsquo;t have to specify the extra parameter most of the time. In other words, a bit of implementation boilerplate isn&amp;rsquo;t needed, making it easier to use the trait.</source>
          <target state="translated">표준 라이브러리의 &lt;code&gt;Add&lt;/code&gt; 특성은 두 번째 목적의 예입니다. 일반적으로 두 가지 유형을 &lt;code&gt;Add&lt;/code&gt; 하지만 Add 특성은 그 이상으로 사용자 정의 할 수있는 기능을 제공합니다. 특성 정의 &lt;code&gt;Add&lt;/code&gt; 에 기본 유형 매개 변수 를 사용하면 추가 매개 변수를 대부분 지정할 필요가 없습니다. 다시 말해, 약간의 구현 상용구가 필요하지 않으므로 특성을보다 쉽게 ​​사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0eb239c2b2b429ca2fb24dfb5a68ef2028451c54" translate="yes" xml:space="preserve">
          <source>The start and end of the string (when &lt;code&gt;index == self.len()&lt;/code&gt;) are considered to be boundaries.</source>
          <target state="translated">문자열의 시작과 끝 ( &lt;code&gt;index == self.len()&lt;/code&gt; )은 경계로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="cc00d65ec1e11702c522241a5699948a50675d34" translate="yes" xml:space="preserve">
          <source>The starting index must come before the ending index;</source>
          <target state="translated">시작 색인은 종료 색인 앞에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="7d09dcb9f35a47d4d0374a51c368ed9570b886f1" translate="yes" xml:space="preserve">
          <source>The starting index must not exceed the ending index;</source>
          <target state="translated">시작 색인은 종료 색인을 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="71f319cd135ed3830fb0df0009e873ba0d9d3bd8" translate="yes" xml:space="preserve">
          <source>The static initializer is a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt; evaluated at compile time. Static initializers may refer to other statics.</source>
          <target state="translated">정적 이니셜 라이저는 컴파일 타임에 평가 되는 &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;상수 식&lt;/a&gt; 입니다. 정적 이니셜 라이저는 다른 정적을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37ec0e6627e56520c118b2a4c9fe270333b4a9ac" translate="yes" xml:space="preserve">
          <source>The status (exit code) of the process.</source>
          <target state="translated">프로세스의 상태 (종료 코드)</target>
        </trans-unit>
        <trans-unit id="2deb263189905df596d3c94b6a6e46fb7fad91f4" translate="yes" xml:space="preserve">
          <source>The status code 200 is the standard success response. The text is a tiny successful HTTP response. Let&amp;rsquo;s write this to the stream as our response to a successful request! From the &lt;code&gt;handle_connection&lt;/code&gt; function, remove the &lt;code&gt;println!&lt;/code&gt; that was printing the request data and replace it with the code in Listing 20-3.</source>
          <target state="translated">상태 코드 200은 표준 성공 응답입니다. 텍스트는 아주 성공적인 HTTP 응답입니다. 성공적인 요청에 대한 응답으로 이것을 스트림에 씁시다! 로부터 &lt;code&gt;handle_connection&lt;/code&gt; 의 기능의 제거 &lt;code&gt;println!&lt;/code&gt; 요청 데이터를 인쇄하고이를 목록 20-3의 코드로 대체했습니다.</target>
        </trans-unit>
        <trans-unit id="121dc7dfe8e1f05a50f59cc42ea3919e004fbd87" translate="yes" xml:space="preserve">
          <source>The stdin handle to the child process, if any, will be closed before waiting. This helps avoid deadlock: it ensures that the child does not block waiting for input from the parent, while the parent waits for the child to exit.</source>
          <target state="translated">자식 프로세스에 대한 stdin 핸들 (있는 경우)은 대기하기 전에 닫힙니다. 교착 상태를 피하는 데 도움이됩니다. 즉, 부모가 자식의 종료를 기다리지 않고 자식이 부모의 입력을 기다리지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="9e925de820aa28eb2278cfb5b172897339fec44e" translate="yes" xml:space="preserve">
          <source>The stem is:</source>
          <target state="translated">줄기는 :</target>
        </trans-unit>
        <trans-unit id="f0b062427634e6f3b4d22b8847d4a85e632115c3" translate="yes" xml:space="preserve">
          <source>The stream of &lt;a href=&quot;enum.searchstep#variant.Match&quot;&gt;&lt;code&gt;Match&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.searchstep#variant.Reject&quot;&gt;&lt;code&gt;Reject&lt;/code&gt;&lt;/a&gt; values up to a &lt;a href=&quot;enum.searchstep#variant.Done&quot;&gt;&lt;code&gt;Done&lt;/code&gt;&lt;/a&gt; will contain index ranges that are adjacent, non-overlapping, covering the whole haystack, and laying on utf8 boundaries.</source>
          <target state="translated">&lt;a href=&quot;enum.searchstep#variant.Done&quot;&gt; &lt;code&gt;Done&lt;/code&gt; &lt;/a&gt; 까지 의 &lt;a href=&quot;enum.searchstep#variant.Match&quot;&gt; &lt;code&gt;Match&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;enum.searchstep#variant.Reject&quot;&gt; &lt;code&gt;Reject&lt;/code&gt; &lt;/a&gt; 값 스트림 에는 인접하고 겹치지 않고 전체 건초 더미를 덮고 utf8 경계에 놓인 인덱스 범위가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="29cd101b0d8222a260b75e7043b8f85140377fdb" translate="yes" xml:space="preserve">
          <source>The stream of &lt;code&gt;Match&lt;/code&gt; and &lt;code&gt;Reject&lt;/code&gt; values up to a &lt;code&gt;Done&lt;/code&gt; will contain index ranges that are adjacent, non-overlapping, covering the whole haystack, and laying on utf8 boundaries.</source>
          <target state="translated">&lt;code&gt;Done&lt;/code&gt; 까지 의 &lt;code&gt;Match&lt;/code&gt; 및 &lt;code&gt;Reject&lt;/code&gt; 값 스트림 에는 인접하고 겹치지 않으며 전체 건초 더미를 덮고 utf8 경계에있는 인덱스 범위가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fe598c8b995968505dc48317e5f0bc507dd1c32a" translate="yes" xml:space="preserve">
          <source>The stream typically has a fixed size, allowing seeking relative to either end or the current offset.</source>
          <target state="translated">스트림은 일반적으로 고정 된 크기를 가지므로 끝 또는 현재 오프셋을 기준으로 탐색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f8a9a233edfd6e32f4b57b8721cdb5b1b1aca0a" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;s3&lt;/code&gt; will contain &lt;code&gt;Hello, world!&lt;/code&gt; as a result of this code. The reason &lt;code&gt;s1&lt;/code&gt; is no longer valid after the addition and the reason we used a reference to &lt;code&gt;s2&lt;/code&gt; has to do with the signature of the method that gets called when we use the &lt;code&gt;+&lt;/code&gt; operator. The &lt;code&gt;+&lt;/code&gt; operator uses the &lt;code&gt;add&lt;/code&gt; method, whose signature looks something like this:</source>
          <target state="translated">문자열 &lt;code&gt;s3&lt;/code&gt; 에는 &lt;code&gt;Hello, world!&lt;/code&gt; 가 포함됩니다 . 이 코드의 결과로. &lt;code&gt;s1&lt;/code&gt; 이유 는 더한 후에 더 이상 유효하지 않으며 &lt;code&gt;s2&lt;/code&gt; 에 대한 참조를 사용한 이유 는 &lt;code&gt;+&lt;/code&gt; 연산자를 사용할 때 호출되는 메소드의 서명과 관련이 있습니다. &lt;code&gt;+&lt;/code&gt; 의 연산자는 사용 &lt;code&gt;add&lt;/code&gt; 누구의 서명과 같은 형태 방법 :</target>
        </trans-unit>
        <trans-unit id="00f2d10e6fe0131d33ac9bca9a600be0160e329e" translate="yes" xml:space="preserve">
          <source>The string Pattern API.</source>
          <target state="translated">문자열 패턴 API</target>
        </trans-unit>
        <trans-unit id="12fed2044893f571a9f644790505d48a15787f1f" translate="yes" xml:space="preserve">
          <source>The string is expected to be an optional &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; sign followed by digits. Leading and trailing whitespace represent an error. Digits are a subset of these characters, depending on &lt;code&gt;radix&lt;/code&gt;:</source>
          <target state="translated">문자열은 선택적인 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 부호와 숫자 가 있어야합니다 . 선행 및 후행 공백은 오류를 나타냅니다. &lt;code&gt;radix&lt;/code&gt; 는 기수 에 따라 이러한 문자의 하위 집합입니다 .</target>
        </trans-unit>
        <trans-unit id="c23316acb8db6205270f951b08328de7cc2d92db" translate="yes" xml:space="preserve">
          <source>The string is expected to be an optional &lt;code&gt;+&lt;/code&gt; sign followed by digits. Leading and trailing whitespace represent an error. Digits are a subset of these characters, depending on &lt;code&gt;radix&lt;/code&gt;:</source>
          <target state="translated">문자열은 선택적인 &lt;code&gt;+&lt;/code&gt; 부호와 숫자 가 있어야합니다 . 선행 및 후행 공백은 오류를 나타냅니다. &lt;code&gt;radix&lt;/code&gt; 는 기수 에 따라 이러한 문자의 하위 집합입니다 .</target>
        </trans-unit>
        <trans-unit id="468f8218bbd425a57c6d5b5fde91fdb78d951a69" translate="yes" xml:space="preserve">
          <source>The string on the right-hand side is only borrowed; its contents are copied into the returned &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">오른쪽의 줄은 빌려온 것입니다. 그 내용은 반환 된 &lt;code&gt;String&lt;/code&gt; 에 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="86da74512bec8006d79316da49e5b54d47ae707d" translate="yes" xml:space="preserve">
          <source>The string will be able to hold exactly &lt;code&gt;capacity&lt;/code&gt; length units of other OS strings without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the string will not allocate.</source>
          <target state="translated">문자열은 재할 당하지 않고 다른 OS 문자열의 &lt;code&gt;capacity&lt;/code&gt; 길이 단위를 정확하게 유지할 수 있습니다 . 경우 &lt;code&gt;capacity&lt;/code&gt; 0 인 문자열이 할당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6f927907143ca3f662c21fec70de91f1f0df225" translate="yes" xml:space="preserve">
          <source>The struct &lt;code&gt;PointList&lt;/code&gt; cannot implement &lt;code&gt;Copy&lt;/code&gt;, because &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is not &lt;code&gt;Copy&lt;/code&gt;. If we attempt to derive a &lt;code&gt;Copy&lt;/code&gt; implementation, we'll get an error:</source>
          <target state="translated">&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;Copy&lt;/code&gt; 가 아니기 때문에 struct &lt;code&gt;PointList&lt;/code&gt; 가 &lt;code&gt;Copy&lt;/code&gt; 를 구현할 수 없습니다 . &lt;code&gt;Copy&lt;/code&gt; 구현 을 시도 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5c8326afa9ea5c7b5b28789d2c040dda354125af" translate="yes" xml:space="preserve">
          <source>The struct is marked &lt;code&gt;pub&lt;/code&gt; so that other code can use it, but the fields within the struct remain private. This is important in this case because we want to ensure that whenever a value is added or removed from the list, the average is also updated. We do this by implementing &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;average&lt;/code&gt; methods on the struct, as shown in Listing 17-2:</source>
          <target state="translated">구조체는 &lt;code&gt;pub&lt;/code&gt; 으로 표시되어 다른 코드에서 사용할 수 있지만 구조체 내의 필드는 비공개로 유지됩니다. 목록에서 값을 추가하거나 제거 할 때마다 평균도 업데이트되도록하려면이 경우 중요합니다. Listing 17-2와 같이 구조체에 &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; 및 &lt;code&gt;average&lt;/code&gt; 메소드를 구현하여이를 수행한다 .</target>
        </trans-unit>
        <trans-unit id="9c1c27f7e80229e155110850a64cfa98b9973379" translate="yes" xml:space="preserve">
          <source>The struct must only be &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; if all the structural fields are &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;. This is the default, but &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; is a safe trait, so as the author of the struct it is your responsibility &lt;em&gt;not&lt;/em&gt; to add something like &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt;. (Notice that adding a projection operation requires unsafe code, so the fact that &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; is a safe trait does not break the principle that you only have to worry about any of this if you use &lt;code&gt;unsafe&lt;/code&gt;.)</source>
          <target state="translated">구조는 모든 구조 필드가 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 경우 에만 고정 해제 여야 합니다 . 이것이 기본값이지만 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 은 안전한 특성이므로 구조체 작성자로서 &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt; 와 같은 것을 추가 &lt;em&gt;하지 않는&lt;/em&gt; 것은 귀하의 책임 입니다. (프로젝션 작업을 추가하려면 안전하지 않은 코드가 필요하므로 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 이 안전한 특성 이라는 사실 은 &lt;code&gt;unsafe&lt;/code&gt; 를 사용하는 경우에만 걱정해야한다는 원칙을 위반하지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="a87dba90688420e84c6cfc3a67588b540866213a" translate="yes" xml:space="preserve">
          <source>The struct must only be &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; if all the structural fields are &lt;code&gt;Unpin&lt;/code&gt;. This is the default, but &lt;code&gt;Unpin&lt;/code&gt; is a safe trait, so as the author of the struct it is your responsibility &lt;em&gt;not&lt;/em&gt; to add something like &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt;. (Notice that adding a projection operation requires unsafe code, so the fact that &lt;code&gt;Unpin&lt;/code&gt; is a safe trait does not break the principle that you only have to worry about any of this if you use &lt;code&gt;unsafe&lt;/code&gt;.)</source>
          <target state="translated">모든 구조 필드가 &lt;code&gt;Unpin&lt;/code&gt; &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 경우 구조체는 고정 해제 여야 합니다 . 이것이 기본값이지만 &lt;code&gt;Unpin&lt;/code&gt; 은 안전한 특성이므로 구조체의 작성자는 &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt; 와 같은 것을 추가 &lt;em&gt;하지 않는&lt;/em&gt; 것은 귀하의 책임 입니다. (주의 투사 작업을 추가하는 것은 안전하지 않은 코드를 필요로한다는 사실 때문에 &lt;code&gt;Unpin&lt;/code&gt; 당신이 사용하는 경우에만이의에 대해 걱정할 필요가 있다는 원칙을 파괴하지 않는 안전 특징이다 &lt;code&gt;unsafe&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="a32a0dfa31f0f0289e823ec593ac2d0e0186cb3f" translate="yes" xml:space="preserve">
          <source>The structure in the &lt;code&gt;vec!&lt;/code&gt; body is similar to the structure of a &lt;code&gt;match&lt;/code&gt; expression. Here we have one arm with the pattern &lt;code&gt;( $( $x:expr ),* )&lt;/code&gt;, followed by &lt;code&gt;=&amp;gt;&lt;/code&gt; and the block of code associated with this pattern. If the pattern matches, the associated block of code will be emitted. Given that this is the only pattern in this macro, there is only one valid way to match; any other pattern will result in an error. More complex macros will have more than one arm.</source>
          <target state="translated">&lt;code&gt;vec!&lt;/code&gt; 의 구조 ! body는 &lt;code&gt;match&lt;/code&gt; 표현식 의 구조와 유사합니다 . 여기서 우리는 패턴이 하나의 아암 &lt;code&gt;( $( $x:expr ),* )&lt;/code&gt; 이어서, &lt;code&gt;=&amp;gt;&lt;/code&gt; 이 패턴과 연관된 코드 블록. 패턴이 일치하면 관련 코드 블록이 생성됩니다. 이것이이 매크로에서 유일한 패턴이라는 것을 감안할 때, 일치하는 유효한 방법은 하나뿐입니다. 다른 패턴은 오류가 발생합니다. 더 복잡한 매크로에는 둘 이상의 팔이 있습니다.</target>
        </trans-unit>
        <trans-unit id="feedd74875f823ef27b80e0ba6fe89baf9a484a0" translate="yes" xml:space="preserve">
          <source>The structure of your public API is a major consideration when publishing a crate. People who use your crate are less familiar with the structure than you are and might have difficulty finding the pieces they want to use if your crate has a large module hierarchy.</source>
          <target state="translated">크레이트를 게시 할 때 퍼블릭 API의 구조를 고려해야합니다. 상자를 사용하는 사람들은 사용자보다 구조에 익숙하지 않으며 상자에 모듈 계층이 큰 경우 사용하려는 조각을 찾기가 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bdec152aa7987052184ceacfeaf61672bfbc336" translate="yes" xml:space="preserve">
          <source>The subtraction assignment operator &lt;code&gt;-=&lt;/code&gt;.</source>
          <target state="translated">감산 대입 연산자 &lt;code&gt;-=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9df0e8a4e443e9ee7a165601e70a6b8ea73f8885" translate="yes" xml:space="preserve">
          <source>The subtraction operator &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">빼기 연산자 &lt;code&gt;-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28fd4d4d9eae938e322b4e3df0e6f419cbd1966d" translate="yes" xml:space="preserve">
          <source>The summary line displays at the end: overall, our test result is &lt;code&gt;FAILED&lt;/code&gt;. We had one test pass and one test fail.</source>
          <target state="translated">마지막 줄에 요약 행이 표시됩니다. 전체적으로 테스트 결과는 &lt;code&gt;FAILED&lt;/code&gt; 입니다. 한 번의 테스트 통과와 한 번의 테스트 실패가있었습니다.</target>
        </trans-unit>
        <trans-unit id="ee42b5387704f2d9fe3e70d6349076680fb579e8" translate="yes" xml:space="preserve">
          <source>The supplied key may be any borrowed form of the map's key type, but &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">제공된 키는지도의 주요 유형의 대출 형태가 될 수 있지만, &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 빌린 양식이 &lt;em&gt;있어야합니다&lt;/em&gt; 키 유형과 일치.</target>
        </trans-unit>
        <trans-unit id="4d0db9da1f6030ddf936168ba198ea7e2ea2a8e7" translate="yes" xml:space="preserve">
          <source>The supplied key may be any borrowed form of the map's key type, but &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">제공된 키는지도의 주요 유형의 대출 형태가 될 수 있지만, &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 빌린 양식이 &lt;em&gt;있어야합니다&lt;/em&gt; 키 유형과 일치.</target>
        </trans-unit>
        <trans-unit id="6157ddf403c8a4c61dced75b578898d85ccde0c2" translate="yes" xml:space="preserve">
          <source>The supplied key may be any borrowed form of the map's key type, but the ordering on the borrowed form &lt;em&gt;must&lt;/em&gt; match the ordering on the key type.</source>
          <target state="translated">제공된 키는지도 키 유형의 빌린 형태 일 수 있지만 빌린 양식 의 순서는 키 유형의 순서와 일치 &lt;em&gt;해야합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9a3120ffbc7b98288aabd741823275a65245701a" translate="yes" xml:space="preserve">
          <source>The symbol &lt;code&gt;^C&lt;/code&gt; represents where you pressed ctrl-c . You may or may not see the word &lt;code&gt;again!&lt;/code&gt; printed after the &lt;code&gt;^C&lt;/code&gt;, depending on where the code was in the loop when it received the interrupt signal.</source>
          <target state="translated">&lt;code&gt;^C&lt;/code&gt; 기호 는 ctrl-c를 누른 위치를 나타냅니다. 단어를 &lt;code&gt;again!&lt;/code&gt; 보거나 보지 못할 수 있습니다 ! 인터럽트 신호를 수신했을 때 코드가 루프에있는 위치에 따라 &lt;code&gt;^C&lt;/code&gt; 뒤에 인쇄 됩니다.</target>
        </trans-unit>
        <trans-unit id="266a6ae6e0b1b671aa6c8cd7616208233ffe3a4b" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;..&lt;/code&gt; will expand to as many values as it needs to be. Listing 18-24 shows how to use &lt;code&gt;..&lt;/code&gt; with a tuple.</source>
          <target state="translated">구문 &lt;code&gt;..&lt;/code&gt; 은 필요한만큼 많은 값으로 확장됩니다. Listing 18-24는 &lt;code&gt;..&lt;/code&gt; 을 튜플과 함께 사용하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="79fc3d3c405b115d38b7334d712d4081f0801fc2" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;if let&lt;/code&gt; takes a pattern and an expression separated by an equal sign. It works the same way as a &lt;code&gt;match&lt;/code&gt;, where the expression is given to the &lt;code&gt;match&lt;/code&gt; and the pattern is its first arm.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 구문 은 등호로 구분 된 패턴과 표현식을 사용합니다. &lt;code&gt;match&lt;/code&gt; 하는 식과 동일한 방식으로 작동합니다 . 여기서 식은 &lt;code&gt;match&lt;/code&gt; 되고 패턴은 첫 번째 팔입니다.</target>
        </trans-unit>
        <trans-unit id="751b24fbac99aa6572c9e1b012dbbe4901f9dd78" translate="yes" xml:space="preserve">
          <source>The syntax and semantics for generators is unstable and will require a further RFC for stabilization. At this time, though, the syntax is closure-like:</source>
          <target state="translated">생성기의 구문과 의미는 불안정하며 안정화를 위해 추가 RFC가 필요합니다. 그러나 현재 구문은 클로저와 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="f94369f4bb8ebdf54603588e1760be815601c761" translate="yes" xml:space="preserve">
          <source>The syntax for the formatting language used is drawn from other languages, so it should not be too alien. Arguments are formatted with Python-like syntax, meaning that arguments are surrounded by &lt;code&gt;{}&lt;/code&gt; instead of the C-like &lt;code&gt;%&lt;/code&gt;. The actual grammar for the formatting syntax is:</source>
          <target state="translated">사용 된 서식 언어의 구문은 다른 언어에서 파생되었으므로 너무 외계인이 아니어야합니다. 인수는 Python과 유사한 구문으로 형식이 지정됩니다. 즉, 인수는 C와 같은 &lt;code&gt;%&lt;/code&gt; 대신 &lt;code&gt;{}&lt;/code&gt; 로 둘러싸여 있습니다. 서식 구문의 실제 문법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b1fb2c0dcb9e4f22d10669f04073e3418ad44567" translate="yes" xml:space="preserve">
          <source>The syntax for using generics in struct definitions is similar to that used in function definitions. First, we declare the name of the type parameter inside angle brackets just after the name of the struct. Then we can use the generic type in the struct definition where we would otherwise specify concrete data types.</source>
          <target state="translated">구조체 정의에서 제네릭을 사용하는 구문은 함수 정의에서 사용되는 구문과 유사합니다. 먼저 구조체 이름 바로 뒤에 꺾쇠 괄호 안에 type 매개 변수의 이름을 선언합니다. 그런 다음 구체적인 데이터 형식을 지정하는 구조체 정의에서 일반 형식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be667267584bb9b3dbb1d7d6c41e7cff90529baf" translate="yes" xml:space="preserve">
          <source>The syntax given to this macro is the same syntax as the &lt;a href=&quot;../reference/conditional-compilation#the-cfg-attribute&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">이 매크로에 제공된 구문은 &lt;a href=&quot;../reference/conditional-compilation#the-cfg-attribute&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; 속성 과 동일한 구문 입니다.</target>
        </trans-unit>
        <trans-unit id="37efe90a09f5adb20955a8d29f6006705ceea1f4" translate="yes" xml:space="preserve">
          <source>The syntax is &lt;code&gt;type Name = ExistingType;&lt;/code&gt;.</source>
          <target state="translated">구문은 &lt;code&gt;type Name = ExistingType;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a952c08ff986f0fd0f90d2e270d99cd3e69c17a4" translate="yes" xml:space="preserve">
          <source>The syntax is the following: &lt;code&gt;dyn BaseTrait + AutoTrait1 + ... AutoTraitN&lt;/code&gt;. Only one &lt;code&gt;BaseTrait&lt;/code&gt; can be used so this will not compile:</source>
          <target state="translated">구문은 다음과 같습니다. &lt;code&gt;dyn BaseTrait + AutoTrait1 + ... AutoTraitN&lt;/code&gt; . &lt;code&gt;BaseTrait&lt;/code&gt; 은 하나만 사용할 수 있으므로 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a5b87227107115d71da53fde65c7898c2f8a55f" translate="yes" xml:space="preserve">
          <source>The tail (elements in the vector after &lt;code&gt;range&lt;/code&gt;) is empty,</source>
          <target state="translated">꼬리 ( &lt;code&gt;range&lt;/code&gt; 후 벡터의 요소 )는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="018e9509238447c67e6197a11d4f5ea0ec53b22e" translate="yes" xml:space="preserve">
          <source>The tail expression of &lt;a href=&quot;expressions/block-expr&quot;&gt;block expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expressions/block-expr&quot;&gt;블록 표현&lt;/a&gt; 의 꼬리 표현 .</target>
        </trans-unit>
        <trans-unit id="73007ab480751859048a54c88693df26b24125bb" translate="yes" xml:space="preserve">
          <source>The task context refers to the &lt;a href=&quot;../../std/task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; which was supplied to the current &lt;a href=&quot;block-expr#async-context&quot;&gt;async context&lt;/a&gt; when the async context itself was polled. Because &lt;code&gt;await&lt;/code&gt; expressions are only legal in an async context, there must be some task context available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8066bd3121283d3517acd4ab40b658c1a009321c" translate="yes" xml:space="preserve">
          <source>The temporary scopes for expressions in &lt;code&gt;let&lt;/code&gt; statements are sometimes &lt;em&gt;extended&lt;/em&gt; to the scope of the block containing the &lt;code&gt;let&lt;/code&gt; statement. This is done when the usual temporary scope would be too small, based on certain syntactic rules. For example:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 문 에있는 식의 임시 범위 는 때때로 &lt;code&gt;let&lt;/code&gt; 문을 포함하는 블록의 범위로 &lt;em&gt;확장&lt;/em&gt; 됩니다 . 특정 구문 규칙에 따라 일반적인 임시 범위가 너무 작을 때 수행됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="c615f1f00b080ca7312a1e8d344f8e1a91bfada3" translate="yes" xml:space="preserve">
          <source>The test shows that when we call &lt;code&gt;shoes_in_my_size&lt;/code&gt;, we get back only shoes that have the same size as the value we specified.</source>
          <target state="translated">테스트 결과 &lt;code&gt;shoes_in_my_size&lt;/code&gt; 를 호출하면 지정한 값과 동일한 크기의 신발 만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6d51660220a74ee89098ef8ef16d38d84170be2b" translate="yes" xml:space="preserve">
          <source>The text &lt;code&gt;Dropping CustomSmartPointer with data `some data`!&lt;/code&gt; is printed between the &lt;code&gt;CustomSmartPointer created.&lt;/code&gt; and &lt;code&gt;CustomSmartPointer dropped before the end of main.&lt;/code&gt; text, showing that the &lt;code&gt;drop&lt;/code&gt; method code is called to drop &lt;code&gt;c&lt;/code&gt; at that point.</source>
          <target state="translated">&lt;code&gt;Dropping CustomSmartPointer with data `some data`!&lt;/code&gt; 텍스트 ! &lt;code&gt;CustomSmartPointer created.&lt;/code&gt; 된 CustomSmartPointer 사이에 인쇄 됩니다. 및 &lt;code&gt;CustomSmartPointer dropped before the end of main.&lt;/code&gt; 텍스트는 것을 보여주는 &lt;code&gt;drop&lt;/code&gt; 방법 코드 드롭이라고 &lt;code&gt;c&lt;/code&gt; 그 시점에서.</target>
        </trans-unit>
        <trans-unit id="c9d885657469b7761a884865d71e05fd15d67a2e" translate="yes" xml:space="preserve">
          <source>The text of this string is stored directly in the program&amp;rsquo;s binary, which is always available. Therefore, the lifetime of all string literals is &lt;code&gt;'static&lt;/code&gt;.</source>
          <target state="translated">이 문자열의 텍스트는 프로그램 바이너리에 직접 저장되며 항상 사용 가능합니다. 따라서 모든 문자열 리터럴의 수명은 &lt;code&gt;'static&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a2418c922b0dbbb7a6749b73d736e8d2a5be9d0c" translate="yes" xml:space="preserve">
          <source>The third argument is a function called if a panic occurs. This function takes the data pointer and a pointer to the target-specific exception object that was caught. For more information see the compiler's source as well as std's catch implementation.</source>
          <target state="translated">세 번째 인수는 패닉이 발생하면 호출되는 함수입니다. 이 함수는 데이터 포인터와 포착 된 대상 특정 예외 개체에 대한 포인터를받습니다. 자세한 내용은 컴파일러의 소스와 std의 catch 구현을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bb9a02cbbbeece965fc06bf102b3dfcc209b80a8" translate="yes" xml:space="preserve">
          <source>The third case is trickier: Rust will also coerce a mutable reference to an immutable one. But the reverse is &lt;em&gt;not&lt;/em&gt; possible: immutable references will never coerce to mutable references. Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn&amp;rsquo;t compile). Converting one mutable reference to one immutable reference will never break the borrowing rules. Converting an immutable reference to a mutable reference would require that the initial immutable reference is the only immutable reference to that data, but the borrowing rules don&amp;rsquo;t guarantee that. Therefore, Rust can&amp;rsquo;t make the assumption that converting an immutable reference to a mutable reference is possible.</source>
          <target state="translated">세 번째 경우는 더 까다 롭습니다. Rust는 또한 변경 불가능한 참조에 대한 변경 가능한 참조를 강제합니다. 그러나 그 반대는 &lt;em&gt;불가능&lt;/em&gt; 합니다. 불변 참조는 절대로 변경 가능한 참조로 강제되지 않습니다. 차용 규칙 때문에 변경 가능한 참조가있는 경우 변경 가능한 참조는 해당 데이터에 대한 유일한 참조 여야합니다 (그렇지 않으면 프로그램이 컴파일되지 않습니다). 하나의 변경 가능한 참조를 하나의 변경 불가능한 참조로 변환하는 것은 차용 규칙을 위반하지 않습니다. 변경 불가능한 참조를 변경 가능한 참조로 변환하려면 초기 변경 불가능한 참조가 해당 데이터에 대한 유일한 변경 불가능한 참조 여야하지만 차용 규칙은이를 보장하지 않습니다. 따라서 Rust는 변경 불가능한 참조를 변경 가능한 참조로 변환하는 것이 가능하다고 가정 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f9782d2dad9c654fee52ed918f0366cbe2abfa6a" translate="yes" xml:space="preserve">
          <source>The third case is trickier: Rust will also coerce a mutable reference to an immutable one. But the reverse is &lt;em&gt;not&lt;/em&gt; possible: immutable references will never coerce to mutable references. Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn&amp;rsquo;t compile). Converting one mutable reference to one immutable reference will never break the borrowing rules. Converting an immutable reference to a mutable reference would require that there is only one immutable reference to that data, and the borrowing rules don&amp;rsquo;t guarantee that. Therefore, Rust can&amp;rsquo;t make the assumption that converting an immutable reference to a mutable reference is possible.</source>
          <target state="translated">세 번째 경우는 더 까다 롭습니다. Rust는 변경 불가능한 참조에 대해 변경 가능한 참조를 강제합니다. 그러나 그 반대는 &lt;em&gt;불가능&lt;/em&gt; 합니다. 불변 참조는 절대 변경 불가능한 참조로 강제되지 않습니다. 차용 규칙으로 인해 변경 가능한 참조가있는 경우 해당 변경 가능한 참조는 해당 데이터에 대한 유일한 참조 여야합니다 (그렇지 않으면 프로그램이 컴파일되지 않음). 하나의 변경 가능한 참조를 하나의 변경 불가능한 참조로 변환해도 절대 차용 규칙을 위반하지 않습니다. 변경 불가능한 참조를 변경 가능한 참조로 변환하려면 해당 데이터에 대한 변경 불가능한 참조가 하나만 있어야하며 차용 규칙은이를 보증하지 않습니다. 따라서 Rust는 불변 참조를 변경 가능한 참조로 변환 할 수 있다고 가정 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="25bc1d6b7d2fd810584a49b63e54dae85fbc7654" translate="yes" xml:space="preserve">
          <source>The third invariant says that when we have a complex NT that can match two or more copies of the same thing with no separation in between, it must be permissible for them to be placed next to each other as per the first invariant. This invariant also requires they be nonempty, which eliminates a possible ambiguity.</source>
          <target state="translated">세 번째 불변은 우리가 분리하지 않고 같은 사물의 둘 이상의 사본과 일치 할 수있는 복잡한 NT를 가질 때, 첫 번째 불변에 따라 서로 옆에 위치하는 것이 허용되어야한다고 말합니다. 이 불변은 또한 비어 있지 않아야하므로 가능한 모호성을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="6858985d6a527c37bd8cd37f82674daea04d146f" translate="yes" xml:space="preserve">
          <source>The third pointer is a target-specific data pointer which is filled in with the specifics of the exception that occurred. For examples on Unix platforms this is a &lt;code&gt;*mut *mut T&lt;/code&gt; which is filled in by the compiler and on MSVC it's &lt;code&gt;*mut [usize; 2]&lt;/code&gt;. For more information see the compiler's source as well as std's catch implementation.</source>
          <target state="translated">세 번째 포인터는 발생한 예외의 세부 사항으로 채워지는 대상별 데이터 포인터입니다. 유닉스 플랫폼에 대한 예제는 &lt;code&gt;*mut *mut T&lt;/code&gt; 이며, 컴파일러에 의해 채워지고 MSVC에서는 &lt;code&gt;*mut [usize; 2]&lt;/code&gt; . 자세한 정보는 컴파일러의 소스와 std의 catch 구현을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="af84a0e541b5cb8aad0df743eb686112ab5e9865" translate="yes" xml:space="preserve">
          <source>The third problem is that we&amp;rsquo;ve used &lt;code&gt;expect&lt;/code&gt; to print an error message when reading the file fails, but the error message just prints &lt;code&gt;Something went wrong reading the file&lt;/code&gt;. Reading a file can fail in a number of ways: for example, the file could be missing, or we might not have permission to open it. Right now, regardless of the situation, we&amp;rsquo;d print the &lt;code&gt;Something went wrong reading the file&lt;/code&gt; error message, which wouldn&amp;rsquo;t give the user any information!</source>
          <target state="translated">세 번째 문제는 우리가 사용했던 것입니다 &lt;code&gt;expect&lt;/code&gt; 파일을 읽는 것은 실패 할 때 오류 메시지를 인쇄 할 수 있지만 오류 메시지가 바로 인쇄 &lt;code&gt;Something went wrong reading the file&lt;/code&gt; . 파일 읽기는 여러 가지 방법으로 실패 할 수 있습니다. 예를 들어 파일이 없거나 파일을 열 수있는 권한이 없을 수 있습니다. 현재 상황에 관계없이 &lt;code&gt;Something went wrong reading the file&lt;/code&gt; 오류 메시지를 읽는 데 오류가 발생하여 사용자에게 정보가 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f9f5c0bd316756e98b375cf7ab85326d6fd86b72" translate="yes" xml:space="preserve">
          <source>The third rule is if there are multiple input lifetime parameters, but one of them is &lt;code&gt;&amp;amp;self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self&lt;/code&gt; because this is a method, the lifetime of &lt;code&gt;self&lt;/code&gt; is assigned to all output lifetime parameters. This third rule makes methods much nicer to read and write because fewer symbols are necessary.</source>
          <target state="translated">세 번째 규칙은 여러 입력 수명 매개 변수가있는 경우 방법 중 하나 이기 때문에이 매개 변수 중 하나는 &lt;code&gt;&amp;amp;self&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 이며, &lt;code&gt;self&lt;/code&gt; 수명은 모든 출력 수명 매개 변수에 지정됩니다. 이 세 번째 규칙은 더 적은 수의 기호가 필요하기 때문에 메소드를 읽고 쓰는 것이 훨씬 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c69636ef08912707db1c3ff91b55a817a8ac72a9" translate="yes" xml:space="preserve">
          <source>The thread may sleep longer than the duration specified due to scheduling specifics or platform-dependent functionality. It will never sleep less.</source>
          <target state="translated">스케줄링 세부 사항 또는 플랫폼 종속 기능으로 인해 스레드가 지정된 지속 시간보다 더 오래 휴면 상태 일 수 있습니다. 결코 잠들지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd58c0bda6dec6815740b7eed1b811cfbd96ccbb" translate="yes" xml:space="preserve">
          <source>The thread name is provided to the OS where applicable (e.g., &lt;code&gt;pthread_setname_np&lt;/code&gt; in unix-like platforms).</source>
          <target state="translated">해당하는 경우 스레드 이름이 OS에 제공됩니다 (예 : 유닉스 계열 플랫폼의 경우 &lt;code&gt;pthread_setname_np&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3218fca211a825167101461324b25d4344214224" translate="yes" xml:space="preserve">
          <source>The threading model</source>
          <target state="translated">스레딩 모델</target>
        </trans-unit>
        <trans-unit id="2518c4f037fbaea8573cb319d8682ea0e18ad153" translate="yes" xml:space="preserve">
          <source>The three forms of iteration</source>
          <target state="translated">세 가지 형태의 반복</target>
        </trans-unit>
        <trans-unit id="6e441e5631d84f73392a981b4df2ae8555997336" translate="yes" xml:space="preserve">
          <source>The three kinds of procedural macros (custom derive, attribute-like, and function-like) all work in a similar fashion.</source>
          <target state="translated">세 가지 종류의 절차 적 매크로 (사용자 지정 파생, 특성 유사 및 기능 유사)는 모두 비슷한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d7a7ac48a6db407723719df4ec95a88c69119a40" translate="yes" xml:space="preserve">
          <source>The three sections of output include the unit tests, the integration test, and the doc tests. The first section for the unit tests is the same as we&amp;rsquo;ve been seeing: one line for each unit test (one named &lt;code&gt;internal&lt;/code&gt; that we added in Listing 11-12) and then a summary line for the unit tests.</source>
          <target state="translated">세 가지 출력 섹션에는 단위 테스트, 통합 테스트 및 문서 테스트가 포함됩니다. 단위 테스트의 첫 번째 섹션 은 살펴본 것과 동일합니다. 각 단위 테스트에 대해 한 줄 ( 목록 11-12에서 추가 한 &lt;code&gt;internal&lt;/code&gt; 이라는 이름의 줄)과 단위 테스트에 대한 요약 줄입니다.</target>
        </trans-unit>
        <trans-unit id="779ae776bee7c2504118b220c1641bc64af7f7ac" translate="yes" xml:space="preserve">
          <source>The time complexity degrades if elements are pushed in predominantly ascending order. In the worst case, elements are pushed in ascending sorted order and the amortized cost per push is &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)) against a heap containing &lt;em&gt;n&lt;/em&gt; elements.</source>
          <target state="translated">요소가 주로 오름차순으로 푸시되면 시간 복잡성이 저하됩니다. 최악의 경우 요소는 오름차순으로 푸시되고 푸시 당 상각 된 비용은 &lt;em&gt;n&lt;/em&gt; 요소를 포함하는 힙에 대해 &lt;em&gt;O&lt;/em&gt; (log ( &lt;em&gt;n&lt;/em&gt; )) 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6df380516e9cdddf51f2d5d2da6e443a2e517824" translate="yes" xml:space="preserve">
          <source>The time complexity degrades if elements are pushed in predominantly ascending order. In the worst case, elements are pushed in ascending sorted order and the amortized cost per push is O(log n) against a heap containing &lt;em&gt;n&lt;/em&gt; elements.</source>
          <target state="translated">요소가 주로 오름차순으로 푸시되면 시간 복잡성이 저하됩니다. 최악의 경우 요소는 오름차순으로 정렬되며 푸시 당 상각 비용은 &lt;em&gt;n 개의&lt;/em&gt; 요소가 포함 된 힙에 대해 O (log n) 입니다.</target>
        </trans-unit>
        <trans-unit id="95e46fd08ac08fd408281a4c8d24f1d26e9263c5" translate="yes" xml:space="preserve">
          <source>The to-be-stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.variant_count&quot;&gt;&lt;code&gt;mem::variant_count&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7075cd0ebc9560a0210fd04b57fb94c1b2316eda" translate="yes" xml:space="preserve">
          <source>The tokens that can begin a type are, as of this writing, {&lt;code&gt;(&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;\*&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, lifetimes, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;::&lt;/code&gt;, any non-keyword identifier, &lt;code&gt;super&lt;/code&gt;, &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;Self&lt;/code&gt;, &lt;code&gt;extern&lt;/code&gt;, &lt;code&gt;crate&lt;/code&gt;, &lt;code&gt;$crate&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;impl&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt;, &lt;code&gt;unsafe&lt;/code&gt;, &lt;code&gt;typeof&lt;/code&gt;, &lt;code&gt;dyn&lt;/code&gt;}, although this list may not be complete because people won't always remember to update the appendix when new ones are added.</source>
          <target state="translated">유형을 시작할 수있는 토큰은이 글을 쓰는 시점에서 { &lt;code&gt;(&lt;/code&gt; , &lt;code&gt;[&lt;/code&gt; , &lt;code&gt;!&lt;/code&gt; , &lt;code&gt;\*&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; , lifes, &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;::&lt;/code&gt; , 키워드가 아닌 식별자, &lt;code&gt;super&lt;/code&gt; , &lt;code&gt;self&lt;/code&gt; , &lt;code&gt;Self&lt;/code&gt; , &lt;code&gt;extern&lt;/code&gt; , &lt;code&gt;crate&lt;/code&gt; , &lt;code&gt;$crate&lt;/code&gt; , &lt;code&gt;_&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;impl&lt;/code&gt; , &lt;code&gt;fn&lt;/code&gt; , &lt;code&gt;unsafe&lt;/code&gt; , &lt;code&gt;typeof&lt;/code&gt; , &lt;code&gt;dyn&lt;/code&gt; } 새 목록이 추가 될 때 항상 부록을 업데이트하는 것을 기억하지 않기 때문에이 목록이 완전하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d918eb4366eadb0401bfe8b5fc6b1b9ce9e5b76" translate="yes" xml:space="preserve">
          <source>The top-level &lt;em&gt;Cargo.lock&lt;/em&gt; now contains information about the dependency of &lt;code&gt;add-one&lt;/code&gt; on &lt;code&gt;rand&lt;/code&gt;. However, even though &lt;code&gt;rand&lt;/code&gt; is used somewhere in the workspace, we can&amp;rsquo;t use it in other crates in the workspace unless we add &lt;code&gt;rand&lt;/code&gt; to their &lt;em&gt;Cargo.toml&lt;/em&gt; files as well. For example, if we add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;adder/src/main.rs&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; crate, we&amp;rsquo;ll get an error:</source>
          <target state="translated">최상위 &lt;em&gt;Cargo.lock&lt;/em&gt; 에는 이제 &lt;code&gt;rand&lt;/code&gt; 에 대한 &lt;code&gt;add-one&lt;/code&gt; 의 종속성에 대한 정보가 포함 됩니다. 그러나 &lt;code&gt;rand&lt;/code&gt; 가 작업 공간 어딘가에 사용 되더라도 &lt;code&gt;rand&lt;/code&gt; 를 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일에 랜드 를 추가하지 않으면 작업 공간의 다른 상자에서 사용할 수 없습니다 . 예를 들어 &lt;code&gt;use rand;&lt;/code&gt; 추가 하면; &lt;code&gt;adder&lt;/code&gt; 상자 의 &lt;em&gt;adder / src / main.rs&lt;/em&gt; 파일에 오류가 발생합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c0d4e33f5ea540060f03c5345b86c179052a0077" translate="yes" xml:space="preserve">
          <source>The top-level &lt;em&gt;Cargo.lock&lt;/em&gt; now contains information about the dependency of &lt;code&gt;add-one&lt;/code&gt; on &lt;code&gt;rand&lt;/code&gt;. However, even though &lt;code&gt;rand&lt;/code&gt; is used somewhere in the workspace, we can&amp;rsquo;t use it in other crates in the workspace unless we add &lt;code&gt;rand&lt;/code&gt; to their &lt;em&gt;Cargo.toml&lt;/em&gt; files as well. For example, if we add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;adder/src/main.rs&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; package, we&amp;rsquo;ll get an error:</source>
          <target state="translated">이제 최상위 &lt;em&gt;Cargo.lock&lt;/em&gt; 에 &lt;code&gt;rand&lt;/code&gt; 에 대한 &lt;code&gt;add-one&lt;/code&gt; 의 종속성에 대한 정보가 포함 됩니다. 그러나 &lt;code&gt;rand&lt;/code&gt; 가 작업 공간의 어딘가에서 사용 되더라도 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일에 &lt;code&gt;rand&lt;/code&gt; 를 추가하지 않는 한 작업 공간의 다른 상자에서 사용할 수 없습니다 . 예를 들어, 우리가 추가하면 &lt;code&gt;use rand;&lt;/code&gt; &lt;code&gt;adder&lt;/code&gt; 패키지 의 &lt;em&gt;adder / src / main.rs&lt;/em&gt; 파일에 오류가 발생합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad3286fb14b7fd80e70223a9fcdf3dbb91a27203" translate="yes" xml:space="preserve">
          <source>The total size &lt;code&gt;len * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;. See the safety documentation of &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">슬라이스 의 총 크기 &lt;code&gt;len * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 는 &lt;code&gt;isize::MAX&lt;/code&gt; 보다 크지 않아야 합니다. &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;pointer::offset&lt;/code&gt; &lt;/a&gt; 의 안전 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb4d3d21f95395d566b73337877fe60f19b91950" translate="yes" xml:space="preserve">
          <source>The total size &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;. See the safety documentation of &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 의 총 크기 ptr.len () * mem :: size_of :: &amp;lt;T&amp;gt; () 는 &lt;code&gt;isize::MAX&lt;/code&gt; 보다 크지 않아야 합니다. &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;pointer::offset&lt;/code&gt; &lt;/a&gt; 의 안전 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f198377d0780cd2ae0fe23c39d58fa6a11c3ce1b" translate="yes" xml:space="preserve">
          <source>The total size &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;. See the safety documentation of &lt;a href=&quot;primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 의 총 크기 ptr.len () * mem :: size_of :: &amp;lt;T&amp;gt; () 는 &lt;code&gt;isize::MAX&lt;/code&gt; 보다 크지 않아야 합니다. &lt;a href=&quot;primitive.pointer#method.offset&quot;&gt; &lt;code&gt;pointer::offset&lt;/code&gt; &lt;/a&gt; 의 안전 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c818e1dc9d477cbb1ce03a32e397d907f841e91" translate="yes" xml:space="preserve">
          <source>The total size of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;&lt;strong&gt;bytes&lt;/strong&gt; in memory. See the safety documentation of &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">슬라이스의 총 크기는 메모리의 &lt;code&gt;isize::MAX&lt;/code&gt; &lt;strong&gt;바이트&lt;/strong&gt; 보다 크지 않아야 합니다. &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;pointer::offset&lt;/code&gt; &lt;/a&gt; 의 안전 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4da1db74e1e609ac8cd961cdfb0fa46bfc3d2c9d" translate="yes" xml:space="preserve">
          <source>The trait also provides convenience methods like &lt;a href=&quot;#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt;, which calls &lt;code&gt;write&lt;/code&gt; in a loop until its entire input has been written.</source>
          <target state="translated">이 특성은 또한 전체 입력이 작성 될 때까지 루프에서 &lt;code&gt;write&lt;/code&gt; 를 호출하는 &lt;a href=&quot;#method.write_all&quot;&gt; &lt;code&gt;write_all&lt;/code&gt; &lt;/a&gt; 과 같은 편리한 메소드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="903fc77fd3444aa853b4918c8904a108213ce8a6" translate="yes" xml:space="preserve">
          <source>The trait also provides convenience methods like &lt;a href=&quot;trait.write#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt;, which calls &lt;code&gt;write&lt;/code&gt; in a loop until its entire input has been written.</source>
          <target state="translated">&lt;a href=&quot;trait.write#method.write_all&quot;&gt; &lt;code&gt;write_all&lt;/code&gt; &lt;/a&gt; 또한 전체 입력이 기록 될 때까지 루프에서 &lt;code&gt;write&lt;/code&gt; 를 호출하는 write_all 과 같은 편리한 메서드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="ddef280ba8303b75d43b99adadcdec8f8b461c8f" translate="yes" xml:space="preserve">
          <source>The trait being implemented is defined in the same crate.</source>
          <target state="translated">구현되는 특성은 동일한 상자에서 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="fe160012593c71ba4d94a64501b55cb584b3c84d" translate="yes" xml:space="preserve">
          <source>The trait cannot contain associated constants</source>
          <target state="translated">특성은 연관된 상수를 포함 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="f49c4617e26c7a90e7ceb5715737675232c71e5c" translate="yes" xml:space="preserve">
          <source>The trait cannot require &lt;code&gt;Self: Sized&lt;/code&gt;</source>
          <target state="translated">특성은 &lt;code&gt;Self: Sized&lt;/code&gt; 요구할 수 없습니다 : 크기</target>
        </trans-unit>
        <trans-unit id="3bbcc07233474a5558580dca4726567afce0f2c1" translate="yes" xml:space="preserve">
          <source>The trait cannot use &lt;code&gt;Self&lt;/code&gt; as a type parameter in the supertrait listing</source>
          <target state="translated">특성은 상위 특성 목록에서 &lt;code&gt;Self&lt;/code&gt; 를 유형 매개 변수로 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="6c46ccc8f602f9dc98f8190aa7e9cb78c7a8a015" translate="yes" xml:space="preserve">
          <source>The trait implemented by builtin generator types.</source>
          <target state="translated">내장 생성기 유형으로 구현 된 특성.</target>
        </trans-unit>
        <trans-unit id="0c6838569af8d3e59a65e8aec127e2d3a1e1e919" translate="yes" xml:space="preserve">
          <source>The trait is known as the &lt;em&gt;implemented trait&lt;/em&gt;. The implementing type implements the implemented trait.</source>
          <target state="translated">이 특성은 &lt;em&gt;구현 된 특성이라고&lt;/em&gt; 합니다. 구현 유형은 구현 된 특성을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="8cf3ab6548fb883dab5c1d88de8c77fdb3ccf054" translate="yes" xml:space="preserve">
          <source>The trait is marked unsafe because the indices returned by the &lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; methods are required to lie on valid utf8 boundaries in the haystack. This enables consumers of this trait to slice the haystack without additional runtime checks.</source>
          <target state="translated">&lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt; 메서드에 의해 반환 된 인덱스 는 건초 더미에서 유효한 utf8 경계에 있어야 하기 때문에 특성은 안전하지 않은 것으로 표시 됩니다. 이를 통해이 특성의 소비자는 추가 런타임 검사없이 건초 더미를 슬라이스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="478884f7bada94b695fbee645bd59c060678235f" translate="yes" xml:space="preserve">
          <source>The trait is marked unsafe because the indices returned by the &lt;code&gt;next()&lt;/code&gt; methods are required to lie on valid utf8 boundaries in the haystack. This enables consumers of this trait to slice the haystack without additional runtime checks.</source>
          <target state="translated">&lt;code&gt;next()&lt;/code&gt; 메소드가 리턴 한 색인 이 건초 더미에서 유효한 utf8 경계에 있어야 하기 때문에 특성이 안전하지 않은 것으로 표시 됩니다. 이를 통해이 특성의 소비자는 추가 런타임 검사없이 건초 더미를 슬라이스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d63a097c314f3198ade51464ed8a948cd1d46d3" translate="yes" xml:space="preserve">
          <source>The trait is marked unsafe in order to restrict implementors to fixed-size arrays. User of this trait can assume that implementors have the exact layout in memory of a fixed size array (for example, for unsafe initialization).</source>
          <target state="translated">특성을 고정 크기 배열로 제한하기 위해 특성이 안전하지 않은 것으로 표시됩니다. 이 특성의 사용자는 구현자가 고정 크기 배열의 메모리에 정확한 레이아웃이 있다고 가정 할 수 있습니다 (예 : 안전하지 않은 초기화).</target>
        </trans-unit>
        <trans-unit id="6234c814e87094f91726f24487a4768fa303bb49" translate="yes" xml:space="preserve">
          <source>The trait is unsafe because implementers must uphold additional safety properties. See &lt;a href=&quot;trait.sourceiter#tymethod.as_inner&quot;&gt;&lt;code&gt;as_inner&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd4884c0b4bf389a086599eb28e009d3c721bad" translate="yes" xml:space="preserve">
          <source>The trait itself acts as a builder for an associated &lt;a href=&quot;trait.searcher&quot;&gt;&lt;code&gt;Searcher&lt;/code&gt;&lt;/a&gt; type, which does the actual work of finding occurrences of the pattern in a string.</source>
          <target state="translated">특성 자체는 연관된 &lt;a href=&quot;trait.searcher&quot;&gt; &lt;code&gt;Searcher&lt;/code&gt; &lt;/a&gt; 유형 의 빌더 역할을 하며 문자열에서 패턴의 발생을 찾는 실제 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="bf58bfdb142c3e3e2fca00b9412242993f764d14" translate="yes" xml:space="preserve">
          <source>The trait itself acts as a builder for an associated &lt;code&gt;Searcher&lt;/code&gt; type, which does the actual work of finding occurrences of the pattern in a string.</source>
          <target state="translated">특성 자체는 문자열에서 패턴의 발생을 찾는 실제 작업을 수행 하는 연관된 &lt;code&gt;Searcher&lt;/code&gt; 유형 의 빌더 역할을 합니다.</target>
        </trans-unit>
        <trans-unit id="4f44d782a6ca223ce6d84156fccfcf74f2f98110" translate="yes" xml:space="preserve">
          <source>The trait with a supertrait is called a &lt;strong&gt;subtrait&lt;/strong&gt; of its supertrait.</source>
          <target state="translated">초 특성이있는 특성을 초 특성의 &lt;strong&gt;하위&lt;/strong&gt; 특성이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="d7357f4482763332c4dcdb5f743346a154d2e9c6" translate="yes" xml:space="preserve">
          <source>The traits in &lt;a href=&quot;../std/ops/index&quot;&gt;&lt;code&gt;std::ops&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/cmp/index&quot;&gt;&lt;code&gt;std::cmp&lt;/code&gt;&lt;/a&gt; are used to overload &lt;a href=&quot;expressions/operator-expr&quot;&gt;operators&lt;/a&gt;, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;indexing expressions&lt;/a&gt; and &lt;a href=&quot;expressions/call-expr&quot;&gt;call expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../std/ops/index&quot;&gt; &lt;code&gt;std::ops&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../std/cmp/index&quot;&gt; &lt;code&gt;std::cmp&lt;/code&gt; &lt;/a&gt; 의 특성은 &lt;a href=&quot;expressions/operator-expr&quot;&gt;연산자&lt;/a&gt; , &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;인덱싱 표현식&lt;/a&gt; 및 &lt;a href=&quot;expressions/call-expr&quot;&gt;호출 표현식&lt;/a&gt; 을 오버로드하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ada4715a52a3666c1e6ea1e317fd6cc2974a5b0" translate="yes" xml:space="preserve">
          <source>The traits in &lt;a href=&quot;../std/ops/index&quot;&gt;&lt;code&gt;std::ops&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/cmp/index&quot;&gt;&lt;code&gt;std::cmp&lt;/code&gt;&lt;/a&gt; are used to overload &lt;a href=&quot;expressions/operator-expr&quot;&gt;operators&lt;/a&gt;, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;indexing expressions&lt;/a&gt;, and &lt;a href=&quot;expressions/call-expr&quot;&gt;call expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../std/ops/index&quot;&gt; &lt;code&gt;std::ops&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../std/cmp/index&quot;&gt; &lt;code&gt;std::cmp&lt;/code&gt; &lt;/a&gt; 의 특성은 &lt;a href=&quot;expressions/operator-expr&quot;&gt;연산자&lt;/a&gt; 오버로드 , &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;식 인덱싱&lt;/a&gt; 및 &lt;a href=&quot;expressions/call-expr&quot;&gt;식 호출에 사용&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="f43292c5d9ba5055790b8cc673c3ce1d90efd4b3" translate="yes" xml:space="preserve">
          <source>The traits in this module are often used as trait bounds for generic functions such that to arguments of multiple types are supported. See the documentation of each trait for examples.</source>
          <target state="translated">이 모듈의 특성은 종종 여러 유형의 인수에 대한 지원이 가능하도록 일반 함수의 특성 경계로 사용됩니다. 예제는 각 특성의 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bbf2160d65d5756f9a6fd20c174d5b77d26006ee" translate="yes" xml:space="preserve">
          <source>The traits in this module provide a way to convert from one type to another type. Each trait serves a different purpose:</source>
          <target state="translated">이 모듈의 특성은 한 유형에서 다른 유형으로 변환하는 방법을 제공합니다. 각 특성은 다른 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="be87d5e421f146f48239b20f0b61521f853fc415" translate="yes" xml:space="preserve">
          <source>The transmitting end has a &lt;code&gt;send&lt;/code&gt; method that takes the value we want to send. The &lt;code&gt;send&lt;/code&gt; method returns a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type, so if the receiving end has already been dropped and there&amp;rsquo;s nowhere to send a value, the send operation will return an error. In this example, we&amp;rsquo;re calling &lt;code&gt;unwrap&lt;/code&gt; to panic in case of an error. But in a real application, we would handle it properly: return to Chapter 9 to review strategies for proper error handling.</source>
          <target state="translated">송신 측에는 송신 하고자하는 값을 취하는 &lt;code&gt;send&lt;/code&gt; 방법이 있습니다. &lt;code&gt;send&lt;/code&gt; 방법의 반환은 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 유형, 수신 측이 이미 삭제 된하고 값을 보낼 곳이 없다했다 그렇다면, 보내기 작업은 오류를 반환합니다. 이 예에서는 오류가 발생하면 &lt;code&gt;unwrap&lt;/code&gt; 을 패닉 상태로 호출 합니다. 그러나 실제 응용 프로그램에서는 제대로 처리합니다. 9 장으로 돌아가서 적절한 오류 처리 전략을 검토하십시오.</target>
        </trans-unit>
        <trans-unit id="358565a5dd8811594d3e7971e93dfbda2791693b" translate="yes" xml:space="preserve">
          <source>The tuple pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">튜플 패턴은 하위 패턴 중 하나가 refutable 일 때 refutable입니다.</target>
        </trans-unit>
        <trans-unit id="8b3273a21950fc06ce8b8962828961e34d0be457" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;gt;&lt;/code&gt; on their inner values.</source>
          <target state="translated">두 값은 내부 값에서 &lt;code&gt;&amp;gt;&lt;/code&gt; 를 호출하여 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="de2c6ddac182efa31cffea571db9b44146fe9838" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;gt;=&lt;/code&gt; on their inner values.</source>
          <target state="translated">두 값은 내부 값에서 &lt;code&gt;&amp;gt;=&lt;/code&gt; 를 호출하여 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c699eaaa968f03f7073bd19cfb4a4bc4c553e9a" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;lt;&lt;/code&gt; on their inner values.</source>
          <target state="translated">두 값은 내부 값에서 &lt;code&gt;&amp;lt;&lt;/code&gt; 를 호출하여 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="169dd7de97da6fed33fb4c7fffa1d0926634fd12" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;lt;=&lt;/code&gt; on their inner values.</source>
          <target state="translated">두 값은 내부 값에서 &lt;code&gt;&amp;lt;=&lt;/code&gt; 를 호출하여 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="4559f811138e10e2014d510114ff2517b250941f" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;cmp()&lt;/code&gt; on their inner values.</source>
          <target state="translated">두 값은 내부 값에서 &lt;code&gt;cmp()&lt;/code&gt; 를 호출하여 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="39163b76dc0823f8bfd4c0f4a8969c804a3f8075" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;partial_cmp()&lt;/code&gt; on their inner values.</source>
          <target state="translated">둘은 내부 값에서 &lt;code&gt;partial_cmp()&lt;/code&gt; 를 호출하여 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="a9f918beee4f5cf9d1253c5c05628d38cf96954a" translate="yes" xml:space="preserve">
          <source>The two configurations available are:</source>
          <target state="translated">사용 가능한 두 가지 구성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="450583e125671dcb6a167d6b29518dd2bf3867fb" translate="yes" xml:space="preserve">
          <source>The two kinds of declaration statements are item declarations and &lt;code&gt;let&lt;/code&gt; statements.</source>
          <target state="translated">두 가지 종류의 선언문은 항목 선언과 &lt;code&gt;let&lt;/code&gt; 문입니다.</target>
        </trans-unit>
        <trans-unit id="29e11129b6c15c504dcd359f5946098de2a818e8" translate="yes" xml:space="preserve">
          <source>The two main protocols involved in web servers are the &lt;em&gt;Hypertext Transfer Protocol&lt;/em&gt;&lt;em&gt;(HTTP)&lt;/em&gt; and the &lt;em&gt;Transmission Control Protocol&lt;/em&gt;&lt;em&gt;(TCP)&lt;/em&gt;. Both protocols are &lt;em&gt;request-response&lt;/em&gt; protocols, meaning a &lt;em&gt;client&lt;/em&gt; initiates requests and a &lt;em&gt;server&lt;/em&gt; listens to the requests and provides a response to the client. The contents of those requests and responses are defined by the protocols.</source>
          <target state="translated">웹 서버와 관련된 두 가지 주요 프로토콜은 &lt;em&gt;HTTP ( &lt;/em&gt;&lt;em&gt;Hypertext Transfer Protocol &lt;/em&gt;&lt;em&gt;)&lt;/em&gt; 와 &lt;em&gt;TCP ( &lt;/em&gt;&lt;em&gt;Transmission Control Protocol &lt;/em&gt;&lt;em&gt;)&lt;/em&gt; 입니다. 두 프로토콜 모두 &lt;em&gt;요청-응답&lt;/em&gt; 프로토콜입니다. 즉, &lt;em&gt;클라이언트&lt;/em&gt; 가 요청을 시작하고 &lt;em&gt;서버&lt;/em&gt; 가 요청을 수신하고 클라이언트에 응답을 제공합니다. 이러한 요청 및 응답의 내용은 프로토콜에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="203df10027d062d490c4fbf35780fe4d1eed13fd" translate="yes" xml:space="preserve">
          <source>The two most common ways to evaluate an iterator are to use a &lt;code&gt;for&lt;/code&gt; loop like this, or using the &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; method to produce a new collection.</source>
          <target state="translated">반복자를 평가하는 가장 일반적인 두 가지 방법은 이와 같은 &lt;code&gt;for&lt;/code&gt; 루프 를 사용 하거나 &lt;a href=&quot;trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 새 콜렉션을 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f0616989ceb9af09d65c6d30395a15645c3fb4ed" translate="yes" xml:space="preserve">
          <source>The two new lines are:</source>
          <target state="translated">새로운 두 줄은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e483fee205c9c53971b14b5a333e04a44a6db99b" translate="yes" xml:space="preserve">
          <source>The two pointed-to values may overlap. If the values do overlap, then the overlapping region of memory from &lt;code&gt;x&lt;/code&gt; will be used. This is demonstrated in the second example below.</source>
          <target state="translated">두 개의 지정된 값이 겹칠 수 있습니다. 값이 겹치면 &lt;code&gt;x&lt;/code&gt; 에서 겹치는 메모리 영역 이 사용됩니다. 아래 두 번째 예에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7540e3538a7ee2b354c6ad5eceba51e063d25c18" translate="yes" xml:space="preserve">
          <source>The two slices returned go from the start of the string slice to &lt;code&gt;mid&lt;/code&gt;, and from &lt;code&gt;mid&lt;/code&gt; to the end of the string slice.</source>
          <target state="translated">두 조각에 문자열 조각의 시작부터 이동 반환 &lt;code&gt;mid&lt;/code&gt; , 그리고에서 &lt;code&gt;mid&lt;/code&gt; 문자열 조각의 끝.</target>
        </trans-unit>
        <trans-unit id="643186e43b6d06589052d125f62e5365b9c9a558" translate="yes" xml:space="preserve">
          <source>The two threads continue alternating, but the main thread waits because of the call to &lt;code&gt;handle.join()&lt;/code&gt; and does not end until the spawned thread is finished.</source>
          <target state="translated">두 스레드는 계속 교대로 나타나지만 기본 스레드는 &lt;code&gt;handle.join()&lt;/code&gt; 호출로 인해 대기 하며 생성 된 스레드가 완료 될 때까지 끝나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6005b5c0e8b9fae85cf0f2f496cddef96188c2e3" translate="yes" xml:space="preserve">
          <source>The two values of the boolean type are written &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">부울 유형의 두 값은 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 로 작성 됩니다.</target>
        </trans-unit>
        <trans-unit id="8b6bd47b4f42af9e321626a41d3ac1a949889256" translate="yes" xml:space="preserve">
          <source>The type &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; produces a new pointer to the same allocation in the heap. When the last &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer to a given allocation is destroyed, the value stored in that allocation (often referred to as &quot;inner value&quot;) is also dropped.</source>
          <target state="translated">유형 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 유형의 값의 소유권 공유 제공 &lt;code&gt;T&lt;/code&gt; 힙 할당을. &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; 에서&lt;/a&gt;&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 을 호출하면 힙의 동일한 할당에 대한 새 포인터가 생성됩니다. 주어진 할당에 대한 마지막 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터가 삭제되면 해당 할당에 저장된 값 ( &quot;내부 값&quot;이라고도 함)도 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="372e682a79086a952e254015d9198d707b3497b2" translate="yes" xml:space="preserve">
          <source>The type &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; produces a new pointer to the same value in the heap. When the last &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer to a given value is destroyed, the pointed-to value is also destroyed.</source>
          <target state="translated">유형 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 유형의 값의 소유권 공유 제공 &lt;code&gt;T&lt;/code&gt; 힙 할당을. &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; 에서&lt;/a&gt;&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 을 호출하면 힙에서 동일한 값에 대한 새로운 포인터가 생성됩니다. 주어진 값에 대한 마지막 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터가 파괴되면 지정된 값도 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="061bd0bf671c2d672c454254d90151c86753f8be" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;code&gt;Arc&lt;/code&gt; produces a new &lt;code&gt;Arc&lt;/code&gt; instance, which points to the same allocation on the heap as the source &lt;code&gt;Arc&lt;/code&gt;, while increasing a reference count. When the last &lt;code&gt;Arc&lt;/code&gt; pointer to a given allocation is destroyed, the value stored in that allocation (often referred to as &quot;inner value&quot;) is also dropped.</source>
          <target state="translated">유형 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 유형의 값의 소유권 공유 제공 &lt;code&gt;T&lt;/code&gt; 힙 할당을. &lt;code&gt;Arc&lt;/code&gt; 에서&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 을 호출하면 참조 횟수를 늘리면서 소스 &lt;code&gt;Arc&lt;/code&gt; 와 동일한 힙 할당을 가리키는 새로운 &lt;code&gt;Arc&lt;/code&gt; 인스턴스가 생성 됩니다. 주어진 할당에 대한 마지막 &lt;code&gt;Arc&lt;/code&gt; 포인터가 삭제되면 해당 할당에 저장된 값 ( &quot;내부 값&quot;이라고도 함)도 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6e13391af6d4685735ce2468fa0b2df950149996" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;code&gt;Arc&lt;/code&gt; produces a new &lt;code&gt;Arc&lt;/code&gt; instance, which points to the same value on the heap as the source &lt;code&gt;Arc&lt;/code&gt;, while increasing a reference count. When the last &lt;code&gt;Arc&lt;/code&gt; pointer to a given value is destroyed, the pointed-to value is also destroyed.</source>
          <target state="translated">유형 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 유형의 값의 소유권 공유 제공 &lt;code&gt;T&lt;/code&gt; 힙 할당을. &lt;code&gt;Arc&lt;/code&gt; 에서&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 을 호출하면 새로운 &lt;code&gt;Arc&lt;/code&gt; 인스턴스가 생성 되는데,이 인스턴스는 힙에서 소스 &lt;code&gt;Arc&lt;/code&gt; 와 동일한 값을 가리키고 참조 횟수는 증가시킵니다. 주어진 값에 대한 마지막 &lt;code&gt;Arc&lt;/code&gt; 포인터가 파괴 될 때, 지정된 값 또한 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="c30f5ce28986d51c472e8b2cb793889a1cf9299e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Cow&lt;/code&gt; is a smart pointer providing clone-on-write functionality: it can enclose and provide immutable access to borrowed data, and clone the data lazily when mutation or ownership is required. The type is designed to work with general borrowed data via the &lt;code&gt;Borrow&lt;/code&gt; trait.</source>
          <target state="translated">&lt;code&gt;Cow&lt;/code&gt; 유형 은 쓰기시 복제 기능을 제공하는 스마트 포인터입니다. 차용 된 데이터에 대한 변경 및 액세스를 제공하고 돌연변이 또는 소유권이 필요한 경우 데이터를 느리게 복제 할 수 있습니다. 이 유형은 &lt;code&gt;Borrow&lt;/code&gt; 특성을 통해 빌린 일반 데이터를 처리하도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="9f7d7514bdc86a24a5ff52dd05fe5c13a9b5c0e6" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Item&lt;/code&gt; is a placeholder type, and the &lt;code&gt;next&lt;/code&gt; method&amp;rsquo;s definition shows that it will return values of type &lt;code&gt;Option&amp;lt;Self::Item&amp;gt;&lt;/code&gt;. Implementors of the &lt;code&gt;Iterator&lt;/code&gt; trait will specify the concrete type for &lt;code&gt;Item&lt;/code&gt;, and the &lt;code&gt;next&lt;/code&gt; method will return an &lt;code&gt;Option&lt;/code&gt; containing a value of that concrete type.</source>
          <target state="translated">&lt;code&gt;Item&lt;/code&gt; 형식 은 자리 표시 자 형식이며 &lt;code&gt;next&lt;/code&gt; 메서드 정의에서는 &lt;code&gt;Option&amp;lt;Self::Item&amp;gt;&lt;/code&gt; 형식의 값을 반환한다는 것을 보여줍니다 . 의 구현 &lt;code&gt;Iterator&lt;/code&gt; 특성은 대한 구체적인 유형을 지정합니다 &lt;code&gt;Item&lt;/code&gt; 하고 &lt;code&gt;next&lt;/code&gt; 방법은 반환 &lt;code&gt;Option&lt;/code&gt; 이 구체적인 유형의 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="b50c152c5140d221fbe925adaec14a20d6c4527c" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Self&lt;/code&gt; acts as an alias to the type of the current trait implementer, or &quot;receiver type&quot;. Besides the already mentioned &lt;code&gt;Self&lt;/code&gt;, &lt;code&gt;&amp;amp;Self&lt;/code&gt; and &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; valid receiver types, the following are also valid: &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;, &lt;code&gt;self: Rc&amp;lt;Self&amp;gt;&lt;/code&gt;, &lt;code&gt;self: Arc&amp;lt;Self&amp;gt;&lt;/code&gt;, and &lt;code&gt;self: Pin&amp;lt;P&amp;gt;&lt;/code&gt; (where P is one of the previous types except &lt;code&gt;Self&lt;/code&gt;). Note that &lt;code&gt;Self&lt;/code&gt; can also be the underlying implementing type, like &lt;code&gt;Foo&lt;/code&gt; in the following example:</source>
          <target state="translated">유형의 &lt;code&gt;Self&lt;/code&gt; 하여 현재 특성의 구현의 종류, 또는 &quot;수신기 유형&quot;에 대한 별칭으로 역할을합니다. 이미 언급 한 &lt;code&gt;Self&lt;/code&gt; , &lt;code&gt;&amp;amp;Self&lt;/code&gt; 및 &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; 유효한 수신자 유형 외에도 다음도 유효합니다. &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; , &lt;code&gt;self: Rc&amp;lt;Self&amp;gt;&lt;/code&gt; , &lt;code&gt;self: Arc&amp;lt;Self&amp;gt;&lt;/code&gt; 및 &lt;code&gt;self: Pin&amp;lt;P&amp;gt;&lt;/code&gt; (여기서 P는 &lt;code&gt;Self&lt;/code&gt; 를 제외한 이전 유형 중 하나입니다 . 참고 것을 &lt;code&gt;Self&lt;/code&gt; 또한 같은 기본 구현 형식이 될 수 있습니다 &lt;code&gt;Foo&lt;/code&gt; 다음 예제 :</target>
        </trans-unit>
        <trans-unit id="86f527297d32ae3d914332f31c2f8f0967b4e336" translate="yes" xml:space="preserve">
          <source>The type alias helps in two ways: it makes code easier to write &lt;em&gt;and&lt;/em&gt; it gives us a consistent interface across all of &lt;code&gt;std::io&lt;/code&gt;. Because it&amp;rsquo;s an alias, it&amp;rsquo;s just another &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, which means we can use any methods that work on &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; with it, as well as special syntax like the &lt;code&gt;?&lt;/code&gt; operator.</source>
          <target state="translated">이 쓰기에 코드를 쉽게 : 유형의 별명은 두 가지 방법으로 도움이 &lt;em&gt;및&lt;/em&gt; 그것은 우리 모두 일관된 인터페이스를 제공합니다 &lt;code&gt;std::io&lt;/code&gt; . 이 별칭이기 때문에, 그것은 또 다른의 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; , 우리가 어떤 방법을 사용할 수있는 수단이 그 일에 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 그뿐만 아니라 같은 특수 구문 &lt;code&gt;?&lt;/code&gt; 운영자.</target>
        </trans-unit>
        <trans-unit id="ea0e2aaa51d45e0a422d27f3c58e30936523ccce" translate="yes" xml:space="preserve">
          <source>The type annotation &lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; is needed here because it&amp;rsquo;s possible to &lt;code&gt;collect&lt;/code&gt; into many different data structures and Rust doesn&amp;rsquo;t know which you want unless you specify. For the parameters for the key and value types, however, we use underscores, and Rust can infer the types that the hash map contains based on the types of the data in the vectors.</source>
          <target state="translated">&lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; 타입 주석은 여기에 필요합니다. 많은 다른 데이터 구조 로 &lt;code&gt;collect&lt;/code&gt; 할 수 있고 Rust는 사용자가 지정하지 않으면 원하는 것을 알 수 없기 때문입니다. 그러나 키 및 값 유형에 대한 매개 변수의 경우 밑줄을 사용하며 Rust는 벡터의 데이터 유형에 따라 해시 맵에 포함 된 유형을 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19887ad86a95d19b831c6b68bb5aee99f3125dcd" translate="yes" xml:space="preserve">
          <source>The type annotation &lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; is needed here because it&amp;rsquo;s possible to &lt;code&gt;collect&lt;/code&gt; into many different data structures and Rust doesn&amp;rsquo;t know which you want unless you specify. For the parameters for the key and value types, however, we use underscores, and Rust can infer the types that the hash map contains based on the types of the data in the vectors. In Listing 8-21, the key type will be &lt;code&gt;String&lt;/code&gt; and the value type will be &lt;code&gt;i32&lt;/code&gt;, just as the types were in Listing 8-20.</source>
          <target state="translated">&lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; 타입 어노테이션 은 여기에 필요합니다. 왜냐하면 다양한 데이터 구조 로 &lt;code&gt;collect&lt;/code&gt; 이 가능 하고 사용자가 지정하지 않는 한 Rust는 원하는 것이 무엇인지 알지 못하기 때문입니다. 그러나 키 및 값 유형에 대한 매개 변수의 경우 밑줄을 사용하고 Rust는 벡터의 데이터 유형에 따라 해시 맵에 포함 된 유형을 추론 할 수 있습니다. 목록 8-21에서 키 유형은 &lt;code&gt;String&lt;/code&gt; 이고 값 유형은 목록 8-20 에서처럼 유형이 &lt;code&gt;i32&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fdf52c33ab9420faf47eea0ae86189b509c83d56" translate="yes" xml:space="preserve">
          <source>The type definition contains some field whose type requires an outlives annotation. Outlives annotations (e.g., &lt;code&gt;T: 'a&lt;/code&gt;) are used to guarantee that all the data in T is valid for at least the lifetime &lt;code&gt;'a&lt;/code&gt;. This scenario most commonly arises when the type contains an associated type reference like &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt;, as shown in the previous code.</source>
          <target state="translated">유형 정의에는 유형이 수명 주석이 필요한 일부 필드가 포함되어 있습니다. Outlives 주석 (예 &lt;code&gt;T: 'a&lt;/code&gt; )은 T의 모든 데이터가 적어도 수명 &lt;code&gt;'a&lt;/code&gt; 동안 유효 함을 보장하는 데 사용됩니다 . 이 시나리오 는 이전 코드에 표시된 것처럼 형식에 &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt; 과 같은 관련 형식 참조가 포함되어있을 때 가장 일반적으로 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="06a3cc90dfa59efcb3be0ad0da5e31c3b001a903" translate="yes" xml:space="preserve">
          <source>The type definition contains some field whose type requires an outlives annotation. Outlives annotations (e.g., &lt;code&gt;T: 'a&lt;/code&gt;) are used to guarantee that all the data in T is valid for at least the lifetime &lt;code&gt;'a&lt;/code&gt;. This scenario most commonly arises when the type contains an associated type reference like &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt;, as shown in this example:</source>
          <target state="translated">유형 정의에는 유형에 수명 주석이 필요한 일부 필드가 포함됩니다. 수명이 다한 주석 (예 &lt;code&gt;T: 'a&lt;/code&gt; )은 T의 모든 데이터가 적어도 수명 &lt;code&gt;'a&lt;/code&gt; 동안 유효하다는 것을 보장하는 데 사용됩니다 . 이 시나리오 는이 예에 표시된 것처럼 유형에 &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt; 과 같은 연관된 유형 참조가 포함 된 경우에 가장 일반적으로 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="fc99bc0924bfaeb5da14796b8d2b7f81fb11367e" translate="yes" xml:space="preserve">
          <source>The type does not fulfill the required lifetime.</source>
          <target state="translated">유형이 필요한 수명을 충족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e9c0bf21d5e45e81b33f072a97367bb2e667f29" translate="yes" xml:space="preserve">
          <source>The type must have the &lt;code&gt;Sync&lt;/code&gt; trait bound to allow thread-safe access.</source>
          <target state="translated">스레드 안전 액세스를 허용 하려면 유형에 &lt;code&gt;Sync&lt;/code&gt; 특성이 바인딩되어 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5761684433f543db118c22f7a347176798eaf3c5" translate="yes" xml:space="preserve">
          <source>The type name should not be considered a unique identifier of a type; multiple types may share the same type name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8abd0fc7da623f26ad9fecceeea94f5bfc1f633a" translate="yes" xml:space="preserve">
          <source>The type name used is not in scope.</source>
          <target state="translated">사용 된 유형 이름이 범위에 없습니다.</target>
        </trans-unit>
        <trans-unit id="89e2360bf1d9e23be29f6ad88e266a77e3f4f82f" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;guess&lt;/code&gt; in this code would have to be an integer &lt;em&gt;and&lt;/em&gt; a string, and Rust requires that &lt;code&gt;guess&lt;/code&gt; have only one type. So what does &lt;code&gt;continue&lt;/code&gt; return? How were we allowed to return a &lt;code&gt;u32&lt;/code&gt; from one arm and have another arm that ends with &lt;code&gt;continue&lt;/code&gt; in Listing 19-26?</source>
          <target state="translated">이 코드에서 &lt;code&gt;guess&lt;/code&gt; 유형은 정수 &lt;em&gt;와&lt;/em&gt; 문자열 이어야 하며 Rust는 &lt;code&gt;guess&lt;/code&gt; 한 유형 만 요구합니다 . 그래서 &lt;code&gt;continue&lt;/code&gt; 돌아 오는 것은 무엇 입니까? 우리는 어떻게 한 팔에서 &lt;code&gt;u32&lt;/code&gt; 를 반환하고 목록 19-26에서 &lt;code&gt;continue&lt;/code&gt; 끝나는 다른 팔을 가질 수 있었습니까?</target>
        </trans-unit>
        <trans-unit id="ae6cd25ffa500de06212f0c2207844d88b02a6be" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;s&lt;/code&gt; here is &lt;code&gt;&amp;amp;str&lt;/code&gt;: it&amp;rsquo;s a slice pointing to that specific point of the binary. This is also why string literals are immutable; &lt;code&gt;&amp;amp;str&lt;/code&gt; is an immutable reference.</source>
          <target state="translated">여기서 &lt;code&gt;s&lt;/code&gt; 의 유형 은 &lt;code&gt;&amp;amp;str&lt;/code&gt; 입니다. 바이너리의 특정 지점을 가리키는 슬라이스입니다. 이것이 바로 문자열 리터럴이 불변 인 이유이기도합니다. &lt;code&gt;&amp;amp;str&lt;/code&gt; 은 불변의 참조입니다.</target>
        </trans-unit>
        <trans-unit id="34ca2b2668ed637a52d925af5ee324f0385b2620" translate="yes" xml:space="preserve">
          <source>The type of a block is the type of the final expression, or &lt;code&gt;()&lt;/code&gt; if the final expression is omitted.</source>
          <target state="translated">블록의 유형은 최종 표현식의 유형이거나 최종 표현식이 생략 된 경우 &lt;code&gt;()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="04575cb944f5ba2523fe623e2ff7231ff81edabc" translate="yes" xml:space="preserve">
          <source>The type of a const parameter references other generic parameters.</source>
          <target state="translated">const 매개 변수의 유형은 다른 일반 매개 변수를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="ed47b86a36c39f67b1e05de4464008d8a1956f2c" translate="yes" xml:space="preserve">
          <source>The type of an &lt;em&gt;unsuffixed&lt;/em&gt; floating-point literal is determined by type inference:</source>
          <target state="translated">의 유형 &lt;em&gt;unsuffixed&lt;/em&gt; 부동 소수점 리터럴 타입 추론에 의해 결정된다 :</target>
        </trans-unit>
        <trans-unit id="6114cd343a30b85f17666d6fd494268587f7b8ea" translate="yes" xml:space="preserve">
          <source>The type of an &lt;em&gt;unsuffixed&lt;/em&gt; integer literal is determined by type inference:</source>
          <target state="translated">&lt;em&gt;접미사가없는&lt;/em&gt; 정수 리터럴 의 유형은 유형 유추에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="89c2fbc4e2ada9abaa3500c6a37ddee8522542e8" translate="yes" xml:space="preserve">
          <source>The type of the discriminant, which must satisfy the trait bounds required by &lt;code&gt;mem::Discriminant&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d869126e3c264254879784374ee68ec03547b9" translate="yes" xml:space="preserve">
          <source>The type of the elements being iterated over.</source>
          <target state="translated">반복되는 요소의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="af8245e533db8494bb30cc9dc28768887bbb8570" translate="yes" xml:space="preserve">
          <source>The type of the value that &lt;code&gt;File::open&lt;/code&gt; returns inside the &lt;code&gt;Err&lt;/code&gt; variant is &lt;code&gt;io::Error&lt;/code&gt;, which is a struct provided by the standard library. This struct has a method &lt;code&gt;kind&lt;/code&gt; that we can call to get an &lt;code&gt;io::ErrorKind&lt;/code&gt; value. The enum &lt;code&gt;io::ErrorKind&lt;/code&gt; is provided by the standard library and has variants representing the different kinds of errors that might result from an &lt;code&gt;io&lt;/code&gt; operation. The variant we want to use is &lt;code&gt;ErrorKind::NotFound&lt;/code&gt;, which indicates the file we&amp;rsquo;re trying to open doesn&amp;rsquo;t exist yet. So we match on &lt;code&gt;f&lt;/code&gt;, but we also have an inner match on &lt;code&gt;error.kind()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;File::open&lt;/code&gt; 이 &lt;code&gt;Err&lt;/code&gt; 변형 내에서 반환 하는 값의 유형은 표준 라이브러리에서 제공하는 구조체 인 &lt;code&gt;io::Error&lt;/code&gt; 입니다. 이 구조체에는 &lt;code&gt;io::ErrorKind&lt;/code&gt; 값 을 얻기 위해 호출 할 수 있는 메서드 &lt;code&gt;kind&lt;/code&gt; 가 있습니다 . 열거 형 &lt;code&gt;io::ErrorKind&lt;/code&gt; 는 표준 라이브러리에서 제공하며 &lt;code&gt;io&lt;/code&gt; 작업으로 인해 발생할 수있는 다양한 종류의 오류를 나타내는 변형이 있습니다 . 우리가 사용하려는 변형은 &lt;code&gt;ErrorKind::NotFound&lt;/code&gt; 이며, 열려고하는 파일이 아직 존재하지 않음을 나타냅니다. 따라서 &lt;code&gt;f&lt;/code&gt; 에 일치 하지만 &lt;code&gt;error.kind()&lt;/code&gt; 에 대한 내부 일치도 있습니다.</target>
        </trans-unit>
        <trans-unit id="545510a669763ef63063641881497bf7dd3f481a" translate="yes" xml:space="preserve">
          <source>The type of this value when viewed as failed.</source>
          <target state="translated">실패한 것으로 볼 때이 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="8b60f120f0bca222851815dfc6ed07a4a0520575" translate="yes" xml:space="preserve">
          <source>The type of this value when viewed as successful.</source>
          <target state="translated">성공한 것으로 볼 때이 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bf039a86046c9f49aceed05895007223ced0c5ff" translate="yes" xml:space="preserve">
          <source>The type of value produced on completion.</source>
          <target state="translated">완료시 생성되는 가치 유형입니다.</target>
        </trans-unit>
        <trans-unit id="16751927675b4a2fde8980932985c3b025559cb0" translate="yes" xml:space="preserve">
          <source>The type of value this generator returns.</source>
          <target state="translated">이 생성기가 반환하는 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bf293514c386bb6e45033b7b50e4549a332b83ad" translate="yes" xml:space="preserve">
          <source>The type of value this generator returns. &lt;a href=&quot;../ops/trait.generator#associatedtype.Return&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 생성기가 반환하는 값의 유형입니다. &lt;a href=&quot;../ops/trait.generator#associatedtype.Return&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fcbd5cd653d3daa61c5d5d30831f8972d04f844c" translate="yes" xml:space="preserve">
          <source>The type of value this generator returns. &lt;a href=&quot;ops/trait.generator#associatedtype.Return&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 생성기가 반환하는 값의 유형입니다. &lt;a href=&quot;ops/trait.generator#associatedtype.Return&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5e0eda41ab22396cfa2f1334045d1746f855426" translate="yes" xml:space="preserve">
          <source>The type of value this generator yields.</source>
          <target state="translated">이 생성기가 산출하는 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b8cb8237cc8b58247dbdfe05ac4618d5ded726d1" translate="yes" xml:space="preserve">
          <source>The type of value this generator yields. &lt;a href=&quot;../ops/trait.generator#associatedtype.Yield&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 생성기가 산출하는 값의 유형입니다. &lt;a href=&quot;../ops/trait.generator#associatedtype.Yield&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="becf5070fa5e52c8db7c1d497d6f97d2d8cc4f48" translate="yes" xml:space="preserve">
          <source>The type of value this generator yields. &lt;a href=&quot;ops/trait.generator#associatedtype.Yield&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 생성기가 산출하는 값의 유형입니다. &lt;a href=&quot;ops/trait.generator#associatedtype.Yield&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="586fe8d7efe2a1acc6c511b646a3a08c88efbb26" translate="yes" xml:space="preserve">
          <source>The type parameter &lt;code&gt;T&lt;/code&gt; represents the data that this lock protects. It is required that &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; to be shared across threads and &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; to allow concurrent access through readers. The RAII guards returned from the locking methods implement &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;../ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;write&lt;/code&gt; methods) to allow access to the content of the lock.</source>
          <target state="translated">유형 매개 변수 &lt;code&gt;T&lt;/code&gt; 는이 잠금이 보호하는 데이터를 나타냅니다. 필요가있다 &lt;code&gt;T&lt;/code&gt; 의 만족을 &lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; 스레드와간에 공유 할 수 &lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 독자를 통해 동시 액세스를 허용 할 수 있습니다. 잠금 메소드에서 리턴 된 RAII 가드는 잠금 의 컨텐츠에 액세스 할 수 있도록 &lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; (및 &lt;code&gt;write&lt;/code&gt; 메소드의 경우 &lt;a href=&quot;../ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; )&lt;/a&gt; 를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="f6f9ae50a3ab94a8cf9005786a7b9af006ffe517" translate="yes" xml:space="preserve">
          <source>The type parameters can also be explicitly supplied in a trailing &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; component after the function name. This might be necessary if there is not sufficient context to determine the type parameters. For example, &lt;code&gt;mem::size_of::&amp;lt;u32&amp;gt;() == 4&lt;/code&gt;.</source>
          <target state="translated">함수 이름 다음에 후행 &lt;a href=&quot;../paths&quot;&gt;경로&lt;/a&gt; 구성 요소 에 유형 매개 변수를 명시 적으로 제공 할 수도 있습니다 . 유형 매개 변수를 판별하기위한 컨텍스트가 충분하지 않은 경우에 필요할 수 있습니다. 예를 들어, &lt;code&gt;mem::size_of::&amp;lt;u32&amp;gt;() == 4&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="618c44497e554625efd295f7702914ef5292c792" translate="yes" xml:space="preserve">
          <source>The type placeholder &lt;code&gt;_&lt;/code&gt; can be used outside item's signature as follows:</source>
          <target state="translated">유형 자리 표시 자 &lt;code&gt;_&lt;/code&gt; 는 다음과 같이 항목의 서명 외부에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba2931173dcc6550d705628d261c402eccc53232" translate="yes" xml:space="preserve">
          <source>The type placeholder &lt;code&gt;_&lt;/code&gt; was used within a type on an item's signature.</source>
          <target state="translated">유형 자리 표시 자 &lt;code&gt;_&lt;/code&gt; 는 항목 서명의 유형 내에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="11d805f97c85ceb05a75d626e5740cb0e2204f44" translate="yes" xml:space="preserve">
          <source>The type returned by formatter methods.</source>
          <target state="translated">포맷터 메소드가 리턴 한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1c16d9adfa415d1c3d1e4550b932c426a82800c2" translate="yes" xml:space="preserve">
          <source>The type returned in the event of a conversion error.</source>
          <target state="translated">변환 오류가 발생하면 반환되는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="2d7863bb088ba575c630ae75df049f3bc518eb6c" translate="yes" xml:space="preserve">
          <source>The type that the &lt;code&gt;else&lt;/code&gt; blocks evaluate to must be compatible with the type that the &lt;code&gt;if&lt;/code&gt; block evaluates to.</source>
          <target state="translated">하는 유형 &lt;code&gt;else&lt;/code&gt; 블록 평가는 그 유형과 호환 가능해야하는 &lt;code&gt;if&lt;/code&gt; 블록들을 평가한다.</target>
        </trans-unit>
        <trans-unit id="f8e8d68133a2235c54df1609c3fa9dc8e972aa60" translate="yes" xml:space="preserve">
          <source>The type to return is inferred from context; this is equivalent to &lt;code&gt;Default::default()&lt;/code&gt; but shorter to type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b611879bfea657d3652c629b736393c4b650211" translate="yes" xml:space="preserve">
          <source>The type you are trying to impl &lt;code&gt;CoerceUnsized&lt;/code&gt; for is not a struct. &lt;code&gt;CoerceUnsized&lt;/code&gt; can only be implemented for a struct. Unsized types are already able to be coerced without an implementation of &lt;code&gt;CoerceUnsized&lt;/code&gt; whereas a struct containing an unsized type needs to know the unsized type field it's containing is able to be coerced. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">&lt;code&gt;CoerceUnsized&lt;/code&gt; 에 영향 을 주려는 유형 은 구조체가 아닙니다. &lt;code&gt;CoerceUnsized&lt;/code&gt; 는 구조체에 대해서만 구현할 수 있습니다. 크기가 조정되지 않은 유형은 &lt;code&gt;CoerceUnsized&lt;/code&gt; 를 구현하지 않고도 이미 강제 변환 할 수 있지만 크기가 조정되지 않은 유형을 포함하는 구조체는 포함 된 크기가 조정되지 않은 유형 필드를 강제 변환 할 수 있어야합니다. &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;크기를 지정하지 않은 타입은&lt;/a&gt; 컴파일러가 컴파일시에 길이 또는 정렬을 알고하지 않습니다 어떤 유형입니다. 크기가 조정되지 않은 유형을 포함하는 모든 구조체도 크기가 조정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63c27305b7150da660772855aa4571d697d89b10" translate="yes" xml:space="preserve">
          <source>The type you can compare with is controlled by &lt;code&gt;PartialEq&lt;/code&gt;'s type parameter. For example, let's tweak our previous code a bit:</source>
          <target state="translated">비교할 수있는 유형은 &lt;code&gt;PartialEq&lt;/code&gt; 의 유형 매개 변수에 의해 제어됩니다 . 예를 들어, 이전 코드를 약간 조정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="93ef2caad28212460c75d9146f8dc4d0899b2d98" translate="yes" xml:space="preserve">
          <source>The type-checker needed to know the type of an expression, but that type had not yet been inferred.</source>
          <target state="translated">형식 검사기는 식의 형식을 알아야하지만 해당 형식은 아직 유추되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="f584bedf990c038f22247101ab8b097fb3a593e8" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;*const T&lt;/code&gt;, &lt;code&gt;&amp;amp;T&lt;/code&gt;, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;Option&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; all have the same size. If &lt;code&gt;T&lt;/code&gt; is Sized, all of those types have the same size as &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;code&gt;*const T&lt;/code&gt; , &lt;code&gt;&amp;amp;T&lt;/code&gt; , &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Option&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 모두 동일한 크기를 갖는다. 경우 &lt;code&gt;T&lt;/code&gt; 가 있는 크기, 그 종류는 모두 같은 크기가 &lt;code&gt;usize&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="5722d857751fd92f7cd76388f248410597abc535" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; hold textual data.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 및 &lt;code&gt;str&lt;/code&gt; 유형 은 텍스트 데이터를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="99894423e354dd0b37e0c9ced81c62b48fcf23b2" translate="yes" xml:space="preserve">
          <source>The types of any associated constants in a trait implementation must match the types in the trait definition.</source>
          <target state="translated">트레이 트 구현의 모든 관련 상수 유형은 트레이 트 정의의 유형과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff52a3715390889940af516c60b08b678feeadf3" translate="yes" xml:space="preserve">
          <source>The types of any associated constants in a trait implementation must match the types in the trait definition. This error indicates that there was a mismatch.</source>
          <target state="translated">특성 구현에서 연관된 상수의 유형은 특성 정의의 유형과 일치해야합니다. 이 오류는 불일치가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2a9653c2b160c32821b432c07707efaa597921f1" translate="yes" xml:space="preserve">
          <source>The typical way to obtain a &lt;code&gt;Weak&lt;/code&gt; pointer is to call &lt;a href=&quot;struct.arc#method.downgrade&quot;&gt;&lt;code&gt;Arc::downgrade&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터 를 얻는 일반적인 방법 은 &lt;a href=&quot;struct.arc#method.downgrade&quot;&gt; &lt;code&gt;Arc::downgrade&lt;/code&gt; &lt;/a&gt; 를 호출하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d7670bf148a2a36a6287e0959f849df36450aeea" translate="yes" xml:space="preserve">
          <source>The typical way to obtain a &lt;code&gt;Weak&lt;/code&gt; pointer is to call &lt;a href=&quot;struct.rc#method.downgrade&quot;&gt;&lt;code&gt;Rc::downgrade&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터 를 얻는 일반적인 방법 은 &lt;a href=&quot;struct.rc#method.downgrade&quot;&gt; &lt;code&gt;Rc::downgrade&lt;/code&gt; &lt;/a&gt; 를 호출하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e38264f429668f9c24babca8440ad652db0e6325" translate="yes" xml:space="preserve">
          <source>The unary logical negation operator &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">단항 논리 부정 연산자 &lt;code&gt;!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6144b29ea1cdce68ecac471463a0fdc0639b34f9" translate="yes" xml:space="preserve">
          <source>The unary negation operator &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">단항 부정 연산자 &lt;code&gt;-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7181a66c31dbb848d4da8d3e96055db8ae78d130" translate="yes" xml:space="preserve">
          <source>The underlying &lt;a href=&quot;struct.metadata&quot;&gt;&lt;code&gt;Metadata&lt;/code&gt;&lt;/a&gt; struct needs to be retrieved with the &lt;a href=&quot;fn.symlink_metadata&quot;&gt;&lt;code&gt;fs::symlink_metadata&lt;/code&gt;&lt;/a&gt; function and not the &lt;a href=&quot;fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; function. The &lt;a href=&quot;fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; function follows symbolic links, so &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt;&lt;code&gt;is_symlink&lt;/code&gt;&lt;/a&gt; would always return &lt;code&gt;false&lt;/code&gt; for the target file.</source>
          <target state="translated">기본 &lt;a href=&quot;struct.metadata&quot;&gt; &lt;code&gt;Metadata&lt;/code&gt; &lt;/a&gt; 구조체 는 &lt;a href=&quot;fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt; 함수가 아니라 &lt;a href=&quot;fn.symlink_metadata&quot;&gt; &lt;code&gt;fs::symlink_metadata&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 검색해야 합니다. &lt;a href=&quot;fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt; 있도록 기능은 심볼릭 링크를 다음과 &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt; &lt;code&gt;is_symlink&lt;/code&gt; 이&lt;/a&gt; 항상 반환 &lt;code&gt;false&lt;/code&gt; 대상 파일.</target>
        </trans-unit>
        <trans-unit id="5ba52bb287979fcbe21a62414e5cba80ede6c6c5" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;RefCell&lt;/code&gt; can never be mutably borrowed from again and will always appear already immutably borrowed. It is not a good idea to leak more than a constant number of references. The &lt;code&gt;RefCell&lt;/code&gt; can be immutably borrowed again if only a smaller number of leaks have occurred in total.</source>
          <target state="translated">기본 &lt;code&gt;RefCell&lt;/code&gt; 은 다시는 변경 불가능하게 빌릴 수 없으며 항상 이미 변경 불가능하게 빌린 것처럼 보입니다. 일정한 수 이상의 참조를 유출하는 것은 좋은 생각이 아닙니다. &lt;code&gt;RefCell&lt;/code&gt; 은 누수의 적은 수의 합계가 발생한 경우 불변 다시 대여 될 수있다.</target>
        </trans-unit>
        <trans-unit id="16573dc48843cb6201240052d6b60dde180482de" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;RefCell&lt;/code&gt; can not be borrowed from again and will always appear already mutably borrowed, making the returned reference the only to the interior.</source>
          <target state="translated">기본 &lt;code&gt;RefCell&lt;/code&gt; 은 다시 빌릴 수 없으며 항상 이미 변경 가능하게 빌려서 표시되므로 반환 된 참조는 내부에 대한 유일한 참조가됩니다.</target>
        </trans-unit>
        <trans-unit id="485a92064bc4fcb63908fa7e1b3b1ad970b9f88b" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;RefCell&lt;/code&gt; will remain mutably borrowed until both returned &lt;code&gt;RefMut&lt;/code&gt;s go out of scope.</source>
          <target state="translated">기본 &lt;code&gt;RefCell&lt;/code&gt; 은 반환 된 &lt;code&gt;RefMut&lt;/code&gt; 이 범위를 벗어날 때까지 변경없이 빌린 상태로 유지 됩니다.</target>
        </trans-unit>
        <trans-unit id="9efa2c9dbfc51e4660e725c77fd7efb185f3f6ff" translate="yes" xml:space="preserve">
          <source>The underlying value can be retrieved through the &lt;code&gt;.0&lt;/code&gt; index of the &lt;code&gt;Wrapping&lt;/code&gt; tuple.</source>
          <target state="translated">&lt;code&gt;Wrapping&lt;/code&gt; 튜플 의 &lt;code&gt;.0&lt;/code&gt; 인덱스를 통해 기본 값을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1be4ec15824529c7ce6527861e8c2980ac38212f" translate="yes" xml:space="preserve">
          <source>The unique, unnameable symbols are created after macro expansion so that macros may safely emit multiple references to &lt;code&gt;_&lt;/code&gt; imports. For example, the following should not produce an error:</source>
          <target state="translated">매크로가 확장 된 후 고유하고 이름이 지정되지 않은 기호가 만들어 지므로 매크로가 &lt;code&gt;_&lt;/code&gt; imports에 대한 여러 참조를 안전하게 방출 할 수 있습니다 . 예를 들어, 다음은 오류가 발생하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="f4f440ca9518cd96f0fe9c31f85a61d77e18e0f3" translate="yes" xml:space="preserve">
          <source>The unsafe counterpart of this macro is the &lt;a href=&quot;hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;unreachable_unchecked&lt;/code&gt;&lt;/a&gt; function, which will cause undefined behavior if the code is reached.</source>
          <target state="translated">이 매크로의 안전하지 않은 부분은 &lt;a href=&quot;hint/fn.unreachable_unchecked&quot;&gt; &lt;code&gt;unreachable_unchecked&lt;/code&gt; &lt;/a&gt; 함수이며, 코드에 도달하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c1a83814a7bcbd2091dc90767bec8f24c5d3f1e3" translate="yes" xml:space="preserve">
          <source>The unsigned integer types consist of:</source>
          <target state="translated">부호없는 정수 유형은 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2d2ce136339d709e77fd2d67b03ff1b69af40d44" translate="yes" xml:space="preserve">
          <source>The upper bound of the range (exclusive).</source>
          <target state="translated">범위의 상한입니다 (제외).</target>
        </trans-unit>
        <trans-unit id="20d82b105410f2577709f06e6539062262a0ca81" translate="yes" xml:space="preserve">
          <source>The upper bound of the range (inclusive)</source>
          <target state="translated">범위의 상한 (포함)</target>
        </trans-unit>
        <trans-unit id="e68185f2e9603472a1563c4f776b66b2c6a3b822" translate="yes" xml:space="preserve">
          <source>The use of the &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; keyword in this position allows the function writer to hide the concrete type as an implementation detail which can change without breaking user's code.</source>
          <target state="translated">의 사용 &lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &lt;/a&gt; 이 위치에있는 키워드는 함수 작가가 사용자의 코드를 깨는없이 변경 될 수 있습니다 구현 세부 사항 등의 구체적인 유형을 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39cef1794b05feb8ec892ea4cd89efe908da35c8" translate="yes" xml:space="preserve">
          <source>The user could always interrupt the program by using the keyboard shortcut ctrl-c. But there&amp;rsquo;s another way to escape this insatiable monster, as mentioned in the &lt;code&gt;parse&lt;/code&gt; discussion in &lt;a href=&quot;#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt;: if the user enters a non-number answer, the program will crash. The user can take advantage of that in order to quit, as shown here:</source>
          <target state="translated">사용자는 키보드 단축키 ctrl-c를 사용하여 항상 프로그램을 중단 할 수 있습니다. 에서 언급하지만,이 탐욕스러운 괴물을 탈출하는 또 다른 방법이 &lt;code&gt;parse&lt;/code&gt; 에 대한 논의 &lt;a href=&quot;#comparing-the-guess-to-the-secret-number&quot;&gt;&quot;비밀 번호에 맞춰 비교&quot;&lt;/a&gt; : 사용자가 아닌 숫자의 답을 입력하면, 프로그램이 충돌합니다. 사용자는 다음과 같이 종료하기 위해이를 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e62c088fdd6cf7f93babb9263d9008d71eaadccf" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to perform &lt;code&gt;metadata&lt;/code&gt; call on &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">사용자에게 &lt;code&gt;path&lt;/code&gt; 에 대한 &lt;code&gt;metadata&lt;/code&gt; 호출 을 수행 할 권한이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0dc65bb53b7876e2a52ec0de6c50b31a471724ba" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to remove the directory at the provided &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">제공된 &lt;code&gt;path&lt;/code&gt; 에서 디렉토리를 제거 할 권한이 사용자에게 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4ed8999bb1ca133f6f343fbba9eb07d31db22560" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to remove the file.</source>
          <target state="translated">사용자에게 파일을 제거 할 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="da243dceea5f741ec03e2474a95470f701358e02" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to view contents.</source>
          <target state="translated">사용자에게 내용을 볼 수있는 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a0ceecf91cf3de088e4866146d667401fc9825c7" translate="yes" xml:space="preserve">
          <source>The user lacks the permission to change attributes of the file.</source>
          <target state="translated">사용자에게 파일 속성을 변경할 수있는 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0728943e3f9e2dd60ac0860b5efc3c86277bbcf8" translate="yes" xml:space="preserve">
          <source>The user of &lt;code&gt;from_raw&lt;/code&gt; has to make sure a specific value of &lt;code&gt;T&lt;/code&gt; is only dropped once.</source>
          <target state="translated">&lt;code&gt;from_raw&lt;/code&gt; 사용자는 &lt;code&gt;T&lt;/code&gt; 의 특정 값이 한 번만 삭제 되었는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8bc0d661ff73b2e7b2da5a4e28c09493dbabbf98" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;to_drop&lt;/code&gt; points to must be valid for dropping, which may mean it must uphold additional invariants - this is type-dependent.</source>
          <target state="translated">&lt;code&gt;to_drop&lt;/code&gt; 포인트 값 은 드롭에 유효해야합니다. 이는 추가 불변을 유지해야 함을 의미 할 수 있습니다. 이는 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9ef61ff6808c20e3aee33111c7be00b7f9eb3ce9" translate="yes" xml:space="preserve">
          <source>The value being coerced is the actual parameter, and it is coerced to the type of the formal parameter.</source>
          <target state="translated">강제되는 값은 실제 매개 변수이며 공식 매개 변수의 유형으로 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="a4543ae96f3c210a98b1abf8fa6e1fffb99a3a60" translate="yes" xml:space="preserve">
          <source>The value contained in the &lt;code&gt;Result::Err&lt;/code&gt; variant is the value the thread panicked with; that is, the argument the &lt;code&gt;panic!&lt;/code&gt; macro was called with. Unlike with normal errors, this value doesn't implement the &lt;a href=&quot;../error/trait.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">에 포함 된 값 &lt;code&gt;Result::Err&lt;/code&gt; 변형 스레드에 당황 값이고; 즉, 논쟁은 &lt;code&gt;panic!&lt;/code&gt; 매크로가 호출되었습니다. 일반 오류와 달리이 값은 &lt;a href=&quot;../error/trait.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 특성을 구현하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3a5a7553814237ff25467a69b929b269b579c5c7" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;push&lt;/code&gt; is an expected cost; the method documentation gives a more detailed analysis.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; 의 가치 는 예상 비용입니다. 분석법 문서는보다 자세한 분석을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7655c33f10da48be510d779b36c1473fc0c444da" translate="yes" xml:space="preserve">
          <source>The value for the width can also be provided as a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; in the list of parameters by adding a postfix &lt;code&gt;$&lt;/code&gt;, indicating that the second argument is a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; specifying the width.</source>
          <target state="translated">폭의 값은 또한 제공 할 수 &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; 후위 가산함으로써 파라미터의 목록 &lt;code&gt;$&lt;/code&gt; 번째 인수는 것을 나타내는, &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; 폭을 지정.</target>
        </trans-unit>
        <trans-unit id="d7971e26c81d228c6b498e7c0267b27f63e3a2f0" translate="yes" xml:space="preserve">
          <source>The value for the width can also be provided as a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; in the list of parameters by using the dollar syntax indicating that the second argument is a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; specifying the width, for example:</source>
          <target state="translated">너비 값 은 두 번째 인수가 너비를 지정 하는 &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; 임을 나타내는 달러 구문을 사용하여 매개 변수 목록에서 &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; 로 제공 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a708656013343fb0ab99fafd8d21e4229d39b962" translate="yes" xml:space="preserve">
          <source>The value may be any borrowed form of the set's value type, but &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the value type.</source>
          <target state="translated">값은 세트의 값 유형의 대출 형태가 될 수 있지만, &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 빌린 양식이 &lt;em&gt;있어야합니다&lt;/em&gt; 값 유형에 대한 일치.</target>
        </trans-unit>
        <trans-unit id="6f10fa6eb368dac898013f2276c185e31dd968d4" translate="yes" xml:space="preserve">
          <source>The value may be any borrowed form of the set's value type, but &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the value type.</source>
          <target state="translated">값은 세트의 값 유형의 대출 형태가 될 수 있지만, &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 빌린 양식이 &lt;em&gt;있어야합니다&lt;/em&gt; 값 유형에 대한 일치.</target>
        </trans-unit>
        <trans-unit id="cc1bf7113b6ffebee8a5cbda9953ce0f46aa8389" translate="yes" xml:space="preserve">
          <source>The value may be any borrowed form of the set's value type, but the ordering on the borrowed form &lt;em&gt;must&lt;/em&gt; match the ordering on the value type.</source>
          <target state="translated">값은 세트 값 유형의 빌린 형식 일 수 있지만 빌린 양식 의 순서는 값 유형의 순서와 일치 &lt;em&gt;해야합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5386004ae808f6aad83668aa6e791c4916959b45" translate="yes" xml:space="preserve">
          <source>The value must not be zero.</source>
          <target state="translated">값은 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="72b7ccc4c541479713442aeb6f9117133107de5e" translate="yes" xml:space="preserve">
          <source>The value must:</source>
          <target state="translated">값은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="fe1619fc66fbf6e80510234756b7616df221cbcc" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;N&lt;/code&gt; that was specified for &lt;code&gt;repr(align(N))&lt;/code&gt; was not a power of two, or was greater than 2^29.</source>
          <target state="translated">&lt;code&gt;repr(align(N))&lt;/code&gt; 에 지정된 &lt;code&gt;N&lt;/code&gt; 값이 2의 거듭 제곱이 아니거나 2 ^ 29보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="744a6000b03885b8f256f7629c96527779c5f909" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;upper_i&lt;/code&gt; here relies on the language of the text: if we're in &lt;code&gt;en-US&lt;/code&gt;, it should be &lt;code&gt;&quot;I&quot;&lt;/code&gt;, but if we're in &lt;code&gt;tr_TR&lt;/code&gt;, it should be &lt;code&gt;&quot;İ&quot;&lt;/code&gt;. &lt;code&gt;to_uppercase()&lt;/code&gt; does not take this into account, and so:</source>
          <target state="translated">&lt;code&gt;upper_i&lt;/code&gt; 의 값은 텍스트 언어에 의존합니다. &lt;code&gt;en-US&lt;/code&gt; 인 경우 &lt;code&gt;&quot;I&quot;&lt;/code&gt; 이어야 하지만 &lt;code&gt;tr_TR&lt;/code&gt; 인 경우 &lt;code&gt;&quot;İ&quot;&lt;/code&gt; 이어야합니다 . &lt;code&gt;to_uppercase()&lt;/code&gt; 는 이것을 고려하지 않으므로 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5ddda6614ea7e3e67438b2aae41a24ac0eb3ff50" translate="yes" xml:space="preserve">
          <source>The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time.</source>
          <target state="translated">정적 및 상수의 값은 컴파일 타임에 알아야하며 프로그램의 전체 수명 동안 유지됩니다. boxed 값을 만들면 런타임에 힙에 메모리가 할당되므로 컴파일 타임에 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b739d6552c67cec966b03a294f348b71a38926c7" translate="yes" xml:space="preserve">
          <source>The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time. Erroneous code example:</source>
          <target state="translated">정적 및 상수의 값은 컴파일 타임에 알고 있어야하며 프로그램의 전체 수명 동안 지속됩니다. 박스형 값을 작성하면 런타임시 힙에 메모리가 할당되므로 컴파일시 수행 할 수 없습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="4b2ff9e347c3c08ba8e806ad69a147ed48871d42" translate="yes" xml:space="preserve">
          <source>The value returned is equivalent to &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt; but does not flush the internal buffer. Due to this optimization the function does not guarantee that calling &lt;code&gt;.into_inner()&lt;/code&gt; immediately afterwards will yield the underlying reader at the same position. Use &lt;a href=&quot;struct.bufreader#method.seek&quot;&gt;&lt;code&gt;BufReader::seek&lt;/code&gt;&lt;/a&gt; instead if you require that guarantee.</source>
          <target state="translated">반환 된 값은 &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt; 동일하지만 내부 버퍼를 플러시하지 않습니다. 이 최적화로 인해 함수는 &lt;code&gt;.into_inner()&lt;/code&gt; 즉시 호출 하면 동일한 위치에있는 기본 판독기가 생성 된다는 것을 보장하지 않습니다 . 보증이 필요한 경우 대신 &lt;a href=&quot;struct.bufreader#method.seek&quot;&gt; &lt;code&gt;BufReader::seek&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="39c061cf746d3ba8e95a5a5598de09efb58fb7b8" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;s&lt;/code&gt; has type &lt;code&gt;String&lt;/code&gt;, and its use in the guard is as a variable of type &lt;code&gt;String&lt;/code&gt;. The guard code effectively executes in a separate scope to the body of the arm, so the value would be moved into this anonymous scope and therefore becomes unavailable in the body of the arm.</source>
          <target state="translated">변수 &lt;code&gt;s&lt;/code&gt; 에는 &lt;code&gt;String&lt;/code&gt; 유형 이 있으며 Guard에서 사용되는 것은 &lt;code&gt;String&lt;/code&gt; 유형의 변수입니다 . 보호 코드는 팔의 몸체에 대해 별도의 범위에서 효과적으로 실행되므로 값이이 익명 범위로 이동되어 팔의 몸체에서 사용할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="8e557a8691f00e33607a16e96773df5a29940a13" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;s&lt;/code&gt; refers to a string literal, where the value of the string is hardcoded into the text of our program. The variable is valid from the point at which it&amp;rsquo;s declared until the end of the current &lt;em&gt;scope&lt;/em&gt;. Listing 4-1 has comments annotating where the variable &lt;code&gt;s&lt;/code&gt; is valid.</source>
          <target state="translated">변수 &lt;code&gt;s&lt;/code&gt; 는 문자열 리터럴을 나타내며, 여기서 문자열 값은 프로그램의 텍스트에 하드 코딩됩니다. 변수는 선언 된 시점부터 현재 &lt;em&gt;범위&lt;/em&gt; 끝까지 유효합니다 . 목록 4-1에는 변수 &lt;code&gt;s&lt;/code&gt; 가 유효한 위치에 주석 이 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e699bc2ac5d00c87b2c7f3b8e3a9da4a553a5d0" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;tup&lt;/code&gt; binds to the entire tuple, because a tuple is considered a single compound element. To get the individual values out of a tuple, we can use pattern matching to destructure a tuple value, like this:</source>
          <target state="translated">튜플은 단일 복합 요소로 간주되므로 변수 &lt;code&gt;tup&lt;/code&gt; 은 전체 튜플에 바인딩됩니다. 튜플에서 개별 값을 가져 오려면 다음과 같이 패턴 일치를 사용하여 튜플 값을 구성 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b81aa2b0402a0e499f7595712bef15edfd23e380" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;x&lt;/code&gt; doesn&amp;rsquo;t &amp;ldquo;live long enough.&amp;rdquo; The reason is that &lt;code&gt;x&lt;/code&gt; will be out of scope when the inner scope ends on line 7. But &lt;code&gt;r&lt;/code&gt; is still valid for the outer scope; because its scope is larger, we say that it &amp;ldquo;lives longer.&amp;rdquo; If Rust allowed this code to work, &lt;code&gt;r&lt;/code&gt; would be referencing memory that was deallocated when &lt;code&gt;x&lt;/code&gt; went out of scope, and anything we tried to do with &lt;code&gt;r&lt;/code&gt; wouldn&amp;rsquo;t work correctly. So how does Rust determine that this code is invalid? It uses a borrow checker.</source>
          <target state="translated">변수 &lt;code&gt;x&lt;/code&gt; 는 &quot;충분히 오래 살지&quot;않습니다. 그 이유는 내부 범위가 라인 7에서 끝날 때 &lt;code&gt;x&lt;/code&gt; 가 범위를 벗어나기 때문입니다 . 그러나 &lt;code&gt;r&lt;/code&gt; 은 여전히 ​​외부 범위에 유효합니다. 그 범위가 더 넓기 때문에&amp;ldquo;더 오래 산다&amp;rdquo;고 말합니다. 녹 작업이 코드를 사용할 경우, &lt;code&gt;r&lt;/code&gt; 은 때 해제 된 메모리를 참조 할 것 &lt;code&gt;x&lt;/code&gt; 가 범위를 벗어나 갔다, 그리고 우리가하려고 노력 아무것도 &lt;code&gt;r&lt;/code&gt; 은 제대로 작동하지 않을 것입니다. 그렇다면 Rust는이 코드가 유효하지 않다고 어떻게 판단합니까? 빌리 체커를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b4588e360f79d1cb0e5f79f31bf6e7bc2ece8336" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;x&lt;/code&gt; holds an &lt;code&gt;i32&lt;/code&gt; value, &lt;code&gt;5&lt;/code&gt;. We set &lt;code&gt;y&lt;/code&gt; equal to a reference to &lt;code&gt;x&lt;/code&gt;. We can assert that &lt;code&gt;x&lt;/code&gt; is equal to &lt;code&gt;5&lt;/code&gt;. However, if we want to make an assertion about the value in &lt;code&gt;y&lt;/code&gt;, we have to use &lt;code&gt;*y&lt;/code&gt; to follow the reference to the value it&amp;rsquo;s pointing to (hence &lt;em&gt;dereference&lt;/em&gt;). Once we dereference &lt;code&gt;y&lt;/code&gt;, we have access to the integer value &lt;code&gt;y&lt;/code&gt; is pointing to that we can compare with &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">변수 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;i32&lt;/code&gt; 값 &lt;code&gt;5&lt;/code&gt; 를 보유합니다 . &lt;code&gt;y&lt;/code&gt; 를 &lt;code&gt;x&lt;/code&gt; 에 대한 참조 와 동일하게 설정 합니다. &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;5&lt;/code&gt; 와 같다고 주장 할 수 있습니다 . 그러나 &lt;code&gt;y&lt;/code&gt; 의 값에 대한 어설 션을 만들려면 &lt;code&gt;*y&lt;/code&gt; 를 사용 하여 가리키는 값에 대한 참조를 따라야합니다 (따라서 &lt;em&gt;dereference&lt;/em&gt; ). &lt;code&gt;y&lt;/code&gt; 를 역 참조 하면 정수 값 &lt;code&gt;y&lt;/code&gt; 에 액세스 할 수 있습니다 . y 는 &lt;code&gt;5&lt;/code&gt; 와 비교할 수 있음을 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="b7511a7213b8989f428e5bec2c5234f95d46bda2" translate="yes" xml:space="preserve">
          <source>The variables that a &lt;a href=&quot;types/closure&quot;&gt;closure&lt;/a&gt; captures by move are dropped in an unspecified order.</source>
          <target state="translated">&lt;a href=&quot;types/closure&quot;&gt;클로저&lt;/a&gt; 가 이동으로 캡처하는 변수 는 지정되지 않은 순서로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f517012aa2f18b099c9314a6c9154f5976be9a45" translate="yes" xml:space="preserve">
          <source>The variance of other &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; and tuple types is decided by looking at the variance of the types of their fields. If the parameter is used in positions with different variances then the parameter is invariant. For example the following struct is covariant in &lt;code&gt;'a&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and invariant in &lt;code&gt;'b&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">다른 &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;enum&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; 및 튜플 유형의 분산은 해당 필드 유형의 분산을보고 결정됩니다. 변수가 분산이 다른 위치에서 사용되면 변수가 변하지 않습니다. 예를 들어 다음 구조체는 &lt;code&gt;'a&lt;/code&gt; 및 &lt;code&gt;T&lt;/code&gt; 에서 공변량 이고 &lt;code&gt;'b&lt;/code&gt; 및 &lt;code&gt;U&lt;/code&gt; 에서 불변량입니다 .</target>
        </trans-unit>
        <trans-unit id="edea3e36560d105a970958779d2fd8e9db94e633" translate="yes" xml:space="preserve">
          <source>The variance of other &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, and tuple types is decided by looking at the variance of the types of their fields. If the parameter is used in positions with different variances then the parameter is invariant. For example the following struct is covariant in &lt;code&gt;'a&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and invariant in &lt;code&gt;'b&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">다른 &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;enum&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; 및 tuple 유형의 분산은 해당 필드 유형의 분산을 살펴봄으로써 결정됩니다. 매개 변수가 분산이 다른 위치에서 사용되는 경우 매개 변수는 불변입니다. 예를 들어 다음 구조체는 &lt;code&gt;'a&lt;/code&gt; 와 &lt;code&gt;T&lt;/code&gt; 에서는 공변 이고 &lt;code&gt;'b&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; 에서는 불변입니다 .</target>
        </trans-unit>
        <trans-unit id="c0eb1ade80b4414ebb3db98e5e4492d2cfa8b829" translate="yes" xml:space="preserve">
          <source>The vector used to create a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; must have one and only one nul byte, positioned at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a9da86bd97667912e395039b2e850ba36a8d1a" translate="yes" xml:space="preserve">
          <source>The vector will be able to hold exactly &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the vector will not allocate.</source>
          <target state="translated">벡터는 재 할당없이 정확히 &lt;code&gt;capacity&lt;/code&gt; 요소 를 보유 할 수 있습니다 . 경우 &lt;code&gt;capacity&lt;/code&gt; 0, 벡터가 할당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a1a063010e523349572dfe2f3d4599fdbf7faf0" translate="yes" xml:space="preserve">
          <source>The vector will not allocate until elements are pushed onto it.</source>
          <target state="translated">벡터는 요소가 푸시 될 때까지 할당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d0b594b3c2a18ead8ab96882d29be04515f3b55" translate="yes" xml:space="preserve">
          <source>The version numbering scheme is explained in &lt;a href=&quot;https://www.unicode.org/versions/Unicode11.0.0/ch03.pdf#page=4&quot;&gt;Unicode 11.0 or later, Section 3.1 Versions of the Unicode Standard&lt;/a&gt;.</source>
          <target state="translated">버전 번호 지정 체계는 &lt;a href=&quot;https://www.unicode.org/versions/Unicode11.0.0/ch03.pdf#page=4&quot;&gt;유니 코드 11.0 이상, 유니 코드 표준의 3.1 버전 섹션에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0be7c75604b320ccdf03b29c2cf5dc9816b16f93" translate="yes" xml:space="preserve">
          <source>The version of &lt;a href=&quot;http://www.unicode.org/&quot;&gt;Unicode&lt;/a&gt; that the Unicode parts of &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; methods are based on.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 및 &lt;code&gt;str&lt;/code&gt; 메서드 의 유니 코드 부분 이 기반으로 하는 유니 &lt;a href=&quot;http://www.unicode.org/&quot;&gt;코드&lt;/a&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="2e7d7937a98ae8b5db75096586d34257981a3b35" translate="yes" xml:space="preserve">
          <source>The version of the call operator that takes a by-value receiver.</source>
          <target state="translated">값별 수신자를 취하는 호출 연산자의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="98bb0c84eb64933810db44150740704106b58e5b" translate="yes" xml:space="preserve">
          <source>The version of the call operator that takes a mutable receiver.</source>
          <target state="translated">변경 가능한 수신자를 취하는 호출 연산자의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="a10ea779af62c4002732377426c5466fd9b100f8" translate="yes" xml:space="preserve">
          <source>The version of the call operator that takes an immutable receiver.</source>
          <target state="translated">변경 불가능한 수신자를 취하는 호출 연산자의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="69df36660018fe57f4bfd6fa17c4ad5d9397540f" translate="yes" xml:space="preserve">
          <source>The volatile intrinsics provide operations intended to act on I/O memory, which are guaranteed to not be reordered by the compiler across other volatile intrinsics. See the LLVM documentation on [&lt;a href=&quot;http://llvm.org/docs/LangRef.html#volatile-memory-accesses&quot;&gt;volatile&lt;/a&gt;].</source>
          <target state="translated">휘발성 내장 함수는 I / O 메모리에서 작동하도록 의도 된 작업을 제공하며 다른 휘발성 내장 함수에서 컴파일러가 순서를 다시 지정할 수는 없습니다. [ &lt;a href=&quot;http://llvm.org/docs/LangRef.html#volatile-memory-accesses&quot;&gt;volatile&lt;/a&gt; ] 에 대한 LLVM 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3879e8ab569a056c97968189092bda667116aee8" translate="yes" xml:space="preserve">
          <source>The volatile parameter is set to &lt;code&gt;true&lt;/code&gt;, so it will not be optimized out unless size is equal to zero.</source>
          <target state="translated">휘발성 매개 변수가 &lt;code&gt;true&lt;/code&gt; 로 설정 되므로 크기가 0이 아닌 한 최적화되지 않습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
