<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="3a4be906ba1df5fea075ac60c84354ab807a7ba2" translate="yes" xml:space="preserve">
          <source>Note: In the edge case where you're seeking with &lt;code&gt;SeekFrom::Current(n)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; minus the internal buffer length overflows an &lt;code&gt;i64&lt;/code&gt;, two seeks will be performed instead of one. If the second seek returns &lt;code&gt;Err&lt;/code&gt;, the underlying reader will be left at the same position it would have if you called &lt;code&gt;seek&lt;/code&gt; with &lt;code&gt;SeekFrom::Current(0)&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;SeekFrom::Current(n)&lt;/code&gt; 하여 찾고있는 가장자리의 경우 &lt;code&gt;n&lt;/code&gt; 에서 내부 버퍼 길이를 뺀 &lt;code&gt;i64&lt;/code&gt; 가 넘치면 하나 대신 두 번의 탐색이 수행됩니다. 두 번째 탐색이 &lt;code&gt;Err&lt;/code&gt; 을 반환 하면 &lt;code&gt;SeekFrom::Current(0)&lt;/code&gt; 하여 &lt;code&gt;seek&lt;/code&gt; 를 호출 한 경우와 동일한 위치에 기본 판독기가 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="ffeb95a03330faff30434eb464fab2ecfe395aa0" translate="yes" xml:space="preserve">
          <source>Note: It is idiomatic to use a &lt;a href=&quot;../statements#let-statements&quot;&gt;let statement&lt;/a&gt; with a pattern of &lt;code&gt;_&lt;/code&gt; when a must-used value is purposely discarded.</source>
          <target state="translated">참고 : 반드시 사용해야하는 값을 의도적으로 버릴 경우 패턴이 &lt;code&gt;_&lt;/code&gt; 인&lt;a href=&quot;../statements#let-statements&quot;&gt;let 문&lt;/a&gt; 을 사용하는 것이 관용적 입니다.</target>
        </trans-unit>
        <trans-unit id="a98353ad4c2ea48db43b41e0a837834f6a8b30a0" translate="yes" xml:space="preserve">
          <source>Note: Lifetimes can be and usually are elided with this shorthand.</source>
          <target state="translated">참고 : 수명은 일반적으로이 속기에서 제외 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9458a465758bdea1aa806edbdf38d0829ff7abbc" translate="yes" xml:space="preserve">
          <source>Note: Multiple matches using the &lt;code&gt;|&lt;/code&gt; operator can cause the pattern guard and the side effects it has to execute multiple times. For example:</source>
          <target state="translated">참고 : &lt;code&gt;|&lt;/code&gt; 작업자는 패턴 가드 및 여러 번 실행해야하는 부작용이 발생할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b48aac9382dceff2ad2732e0844fc1d124e5afbe" translate="yes" xml:space="preserve">
          <source>Note: String slice range indices must occur at valid UTF-8 character boundaries. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error. For the purposes of introducing string slices, we are assuming ASCII only in this section; a more thorough discussion of UTF-8 handling is in the &lt;a href=&quot;ch08-02-strings#storing-utf-8-encoded-text-with-strings&quot;&gt;&amp;ldquo;Storing UTF-8 Encoded Text with Strings&amp;rdquo;&lt;/a&gt; section of Chapter 8.</source>
          <target state="translated">참고 : 문자열 슬라이스 범위 인덱스는 유효한 UTF-8 문자 경계에서 발생해야합니다. 멀티 바이트 문자 중간에 문자열 슬라이스를 만들려고하면 프로그램이 오류와 함께 종료됩니다. 문자열 슬라이스를 도입하기 위해이 섹션에서는 ASCII 만 가정합니다. UTF-8 처리에 대한 자세한 내용은 8 장의 &lt;a href=&quot;ch08-02-strings#storing-utf-8-encoded-text-with-strings&quot;&gt;&quot;문자열과 함께 UTF-8 인코딩 텍스트 저장&quot;&lt;/a&gt; 섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0300d6a8e919cca08e1ab2c8db38b624e4574c2" translate="yes" xml:space="preserve">
          <source>Note: The &lt;a href=&quot;../../std/vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; standard library type provides a heap-allocated resizable array type.</source>
          <target state="translated">참고 : &lt;a href=&quot;../../std/vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 표준 라이브러리 유형은 힙 할당 크기 조정 가능 배열 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="29d2f706dbf0a3794fd072f42986f2a9c440ff62" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;//&lt;/code&gt; syntax starts a comment that continues until the end of the line. Rust ignores everything in comments, which are discussed in more detail in Chapter 3.</source>
          <target state="translated">참고 : &lt;code&gt;//&lt;/code&gt; 구문은 줄 끝까지 계속되는 주석을 시작합니다. Rust는 주석의 모든 내용을 무시합니다.이 내용은 3 장에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="187085942721c7c78a8ec180c1642f4ed13694fc" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;2..=9&lt;/code&gt; is a &lt;a href=&quot;../patterns#range-patterns&quot;&gt;Range Pattern&lt;/a&gt;, not a &lt;a href=&quot;range-expr&quot;&gt;Range Expression&lt;/a&gt;. Thus, only those types of ranges supported by range patterns can be used in match arms.</source>
          <target state="translated">참고 : &lt;code&gt;2..=9&lt;/code&gt; A는 &lt;a href=&quot;../patterns#range-patterns&quot;&gt;범위 패턴&lt;/a&gt; 이 아닌 &lt;a href=&quot;range-expr&quot;&gt;범위 표현&lt;/a&gt; . 따라서, 범위 패턴에 의해 지원되는 이러한 유형의 범위 만 매치 암에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f039047f79b4edcb39be10eb9b4e9a5ff0260001" translate="yes" xml:space="preserve">
          <source>Note: The actual definition of the &lt;code&gt;vec!&lt;/code&gt; macro in the standard library includes code to preallocate the correct amount of memory up front. That code is an optimization that we don&amp;rsquo;t include here to make the example simpler.</source>
          <target state="translated">참고 : &lt;code&gt;vec!&lt;/code&gt; 의 실제 정의 ! 표준 라이브러리의 매크로에는 올바른 양의 메모리를 미리 할당하는 코드가 포함되어 있습니다. 이 코드는 예제를 단순화하기 위해 여기에 포함되지 않은 최적화입니다.</target>
        </trans-unit>
        <trans-unit id="43e1990329df70de099fd02b501085a14776154b" translate="yes" xml:space="preserve">
          <source>Note: The aforementioned shim for function pointers is necessary because &lt;code&gt;rustc&lt;/code&gt; implements &lt;code&gt;track_caller&lt;/code&gt; in a codegen context by appending an implicit parameter to the function ABI, but this would be unsound for an indirect call because the parameter is not a part of the function's type and a given function pointer type may or may not refer to a function with the attribute. The creation of a shim hides the implicit parameter from callers of the function pointer, preserving soundness.</source>
          <target state="translated">참고 : &lt;code&gt;track_caller&lt;/code&gt; 가 함수 ABI에 암시 적 매개 변수를 추가하여 codegen 컨텍스트에서 &lt;code&gt;rustc&lt;/code&gt; 구현 하기 때문에 앞서 언급 한 함수 포인터에 대한 shim이 필요 하지만 매개 변수가 함수 유형의 일부가 아니므로 간접 호출에는 적합하지 않습니다. 주어진 함수 포인터 유형은 속성을 가진 함수를 참조하거나 참조하지 않을 수 있습니다. shim을 만들면 함수 포인터 호출자로부터 암시 적 매개 변수가 숨겨져 서 건전성이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="130fc90f1f7559f295e76dc148708d583a3eb9e9" translate="yes" xml:space="preserve">
          <source>Note: The default in &lt;code&gt;rustc&lt;/code&gt; is 1048576.</source>
          <target state="translated">참고 : &lt;code&gt;rustc&lt;/code&gt; 의 기본값 은 1048576입니다.</target>
        </trans-unit>
        <trans-unit id="26390a0ab47722e2e502de5688756dbd639d3d95" translate="yes" xml:space="preserve">
          <source>Note: The default in &lt;code&gt;rustc&lt;/code&gt; is 128.</source>
          <target state="translated">참고 : &lt;code&gt;rustc&lt;/code&gt; 의 기본값 은 128입니다.</target>
        </trans-unit>
        <trans-unit id="a3d9efde740053cef26656af7a7f6ab7316f24e6" translate="yes" xml:space="preserve">
          <source>Note: The default in &lt;code&gt;rustc&lt;/code&gt; is 64.</source>
          <target state="translated">참고 : &lt;code&gt;rustc&lt;/code&gt; 의 기본값 은 64입니다.</target>
        </trans-unit>
        <trans-unit id="8180c8df8ae11541f19b00a561591d13760a8ee6" translate="yes" xml:space="preserve">
          <source>Note: The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">참고 : 반복자가 끝까지 소비되지 않더라도 요소 범위는 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9f4fea507ec4e68a49f42af2c77e67668a288392" translate="yes" xml:space="preserve">
          <source>Note: The enum representation in C is implementation defined, so this is really a &quot;best guess&quot;. In particular, this may be incorrect when the C code of interest is compiled with certain flags.</source>
          <target state="translated">참고 : C의 열거 형 표현은 구현 정의이므로 실제로는 &quot;최선의 추측&quot;입니다. 특히, 관심있는 C 코드가 특정 플래그로 컴파일 될 때 올바르지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cee4fb70834d29d39a99e3fa46a091ae845a20c" translate="yes" xml:space="preserve">
          <source>Note: The examples above used to be (erroneously) accepted by the compiler, but this was since corrected. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/33685&quot;&gt;issue #33685&lt;/a&gt; for more details.</source>
          <target state="translated">참고 : 위의 예제는 컴파일러에서 잘못 받아 들여졌지만 이후 수정되었습니다. 자세한 내용은 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/33685&quot;&gt;문제 # 33685&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="daadbb2b1b33b48dcd9e6359e7eecc90c0e80c1e" translate="yes" xml:space="preserve">
          <source>Note: The examples in Listings 10-17, 10-18, and 10-24 declare variables without giving them an initial value, so the variable name exists in the outer scope. At first glance, this might appear to be in conflict with Rust&amp;rsquo;s having no null values. However, if we try to use a variable before giving it a value, we&amp;rsquo;ll get a compile-time error, which shows that Rust indeed does not allow null values.</source>
          <target state="translated">참고 : Listing 10-17, 10-18 및 10-24의 예제는 변수에 초기 값을 제공하지 않고 변수를 선언하므로 변수 이름이 외부 범위에 존재합니다. 언뜻보기에 이것은 Rust의 null 값이없는 것과 충돌하는 것처럼 보일 수 있습니다. 그러나 변수에 값을주기 전에 변수를 사용하려고하면 컴파일 타임 오류가 발생하는데, 이는 Rust가 실제로 널값을 허용하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="50e01f1ed4a46f62a5d14f0b5fa9d8b4796d1c64" translate="yes" xml:space="preserve">
          <source>Note: The implementation of which return types are allowed is determined by the unstable &lt;a href=&quot;../../std/process/trait.termination&quot;&gt;&lt;code&gt;Termination&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">참고 : 반환 유형이 허용되는 구현은 불안정한 &lt;a href=&quot;../../std/process/trait.termination&quot;&gt; &lt;code&gt;Termination&lt;/code&gt; &lt;/a&gt; 특성에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="788f6375fff581af876a714c5f38068ea6a94a60" translate="yes" xml:space="preserve">
          <source>Note: The implementation of which return types are allowed is determined by the unstable &lt;a href=&quot;../std/process/trait.termination&quot;&gt;&lt;code&gt;Termination&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">참고 : 반환 유형이 허용되는 구현은 불안정한 &lt;a href=&quot;../std/process/trait.termination&quot;&gt; &lt;code&gt;Termination&lt;/code&gt; &lt;/a&gt; 특성에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="40b1e975f4973c7f7bd859ba82ec6ff70298303a" translate="yes" xml:space="preserve">
          <source>Note: The lint checks supported by &lt;code&gt;rustc&lt;/code&gt; can be found via &lt;code&gt;rustc -W help&lt;/code&gt;, along with their default settings and are documented in the &lt;a href=&quot;https://doc.rust-lang.org/rustc/lints/index.html&quot;&gt;rustc book&lt;/a&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;rustc&lt;/code&gt; 가 지원하는 보푸라기 검사 는 기본 설정과 함께 &lt;code&gt;rustc -W help&lt;/code&gt; 통해 찾을 수 있으며 &lt;a href=&quot;https://doc.rust-lang.org/rustc/lints/index.html&quot;&gt;rustc 서적에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5df3cfb866cdb5ad3722ea9687c561d88d29727a" translate="yes" xml:space="preserve">
          <source>Note: The next section assumes you&amp;rsquo;ve read the earlier section &lt;a href=&quot;ch19-03-advanced-traits#using-the-newtype-pattern-to-implement-external-traits-on-external-types&quot;&gt;&amp;ldquo;Using the Newtype Pattern to Implement External Traits on External Types.&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">참고 : 다음 섹션에서는 &lt;a href=&quot;ch19-03-advanced-traits#using-the-newtype-pattern-to-implement-external-traits-on-external-types&quot;&gt;&quot;새 유형 패턴을 사용하여 외부 유형에 외부 특성 구현&quot;&lt;/a&gt; 섹션을 읽었다 고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="7007864547a1ff842641db1454a617feb860ba4c" translate="yes" xml:space="preserve">
          <source>Note: The opposite of referencing by using &lt;code&gt;&amp;amp;&lt;/code&gt; is &lt;em&gt;dereferencing&lt;/em&gt;, which is accomplished with the dereference operator, &lt;code&gt;*&lt;/code&gt;. We&amp;rsquo;ll see some uses of the dereference operator in Chapter 8 and discuss details of dereferencing in Chapter 15.</source>
          <target state="translated">참고 : &lt;code&gt;&amp;amp;&lt;/code&gt; 를 사용하여 참조하는 것과 반대 인 참조 는 &lt;em&gt;역&lt;/em&gt; 참조 연산자 &lt;code&gt;*&lt;/code&gt; 로 수행 됩니다. 8 장에서 역 참조 연산자를 사용하고 15 장에서 역 참조에 대한 세부 사항을 논의 할 것이다.</target>
        </trans-unit>
        <trans-unit id="a0cacc6a55793cf1996cae56b2d43488d313d554" translate="yes" xml:space="preserve">
          <source>Note: The semicolon following a statement is not a part of the statement itself. They are invalid when using the &lt;code&gt;stmt&lt;/code&gt; macro matcher.</source>
          <target state="translated">참고 : 명령문 뒤의 세미콜론은 명령문 자체의 일부가 아닙니다. &lt;code&gt;stmt&lt;/code&gt; 매크로 매처를 사용할 때 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ebd41440d85e280e6b8e0940e9eb1baf556c6663" translate="yes" xml:space="preserve">
          <source>Note: The test mode is enabled by passing the &lt;code&gt;--test&lt;/code&gt; argument to &lt;code&gt;rustc&lt;/code&gt; or using &lt;code&gt;cargo test&lt;/code&gt;.</source>
          <target state="translated">참고 : 테스트 모드는 &lt;code&gt;--test&lt;/code&gt; 인수를 &lt;code&gt;rustc&lt;/code&gt; 에 전달 하거나 &lt;code&gt;cargo test&lt;/code&gt; 사용하여 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="019655f819e73b6b959d0e74887282806fb3a878" translate="yes" xml:space="preserve">
          <source>Note: This algorithm can produce zero-sized structs. In C, an empty struct declaration like &lt;code&gt;struct Foo { }&lt;/code&gt; is illegal. However, both gcc and clang support options to enable such structs, and assign them size zero. C++, in contrast, gives empty structs a size of 1, unless they are inherited from or they are fields that have the &lt;code&gt;[[no_unique_address]]&lt;/code&gt; attribute, in which case they do not increase the overall size of the struct.</source>
          <target state="translated">참고 :이 알고리즘은 크기가 0 인 구조체를 생성 할 수 있습니다. C에서 &lt;code&gt;struct Foo { }&lt;/code&gt; 와 같은 빈 구조체 선언 은 불법입니다. 그러나 gcc 및 clang 모두 이러한 구조체를 활성화하고 크기를 0으로 할당하는 옵션을 지원합니다. 반대로 C ++는 빈 구조체에 1의 크기를 제공합니다. 단, 상속되지 않거나 &lt;code&gt;[[no_unique_address]]&lt;/code&gt; 속성 이있는 필드 인 경우에는 구조체의 전체 크기가 증가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7281566219ec90e2a7e767d6f73d5379e3c0db2" translate="yes" xml:space="preserve">
          <source>Note: This algorithm can produce zero-sized structs. This differs from C where structs without data still have a size of one byte.</source>
          <target state="translated">참고 :이 알고리즘은 크기가 0 인 구조체를 생성 할 수 있습니다. 이것은 데이터가없는 구조체의 크기가 여전히 1 바이트 인 C와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="84916df8964c95c521b7aa5c595fc0771cbfc9af" translate="yes" xml:space="preserve">
          <source>Note: This book assumes basic familiarity with the command line. Rust makes no specific demands about your editing or tooling or where your code lives, so if you prefer to use an integrated development environment (IDE) instead of the command line, feel free to use your favorite IDE. Many IDEs now have some degree of Rust support; check the IDE&amp;rsquo;s documentation for details. Recently, the Rust team has been focusing on enabling great IDE support, and progress has been made rapidly on that front!</source>
          <target state="translated">참고 :이 책은 명령 행에 대한 기본 지식이 있다고 가정합니다. Rust는 편집 또는 툴링 또는 코드의 위치에 대해 특별한 요구를하지 않으므로 명령 줄 대신 IDE (Integrated Development Environment)를 사용하려면 원하는 IDE를 자유롭게 사용하십시오. 많은 IDE가 이제 어느 정도의 Rust를 지원합니다. 자세한 내용은 IDE 설명서를 확인하십시오. 최근 Rust 팀은 훌륭한 IDE 지원에 초점을 맞추고 있으며 그 진전이 빠르게 진행되고 있습니다!</target>
        </trans-unit>
        <trans-unit id="5ac1eb98b0f589191a31e26db76121648795b41e" translate="yes" xml:space="preserve">
          <source>Note: This edition of the book is the same as &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;The Rust Programming Language&lt;/a&gt; available in print and ebook format from &lt;a href=&quot;https://nostarch.com/&quot;&gt;No Starch Press&lt;/a&gt;.</source>
          <target state="translated">참고 :이 책은 &lt;a href=&quot;https://nostarch.com/&quot;&gt;No Starch Press의&lt;/a&gt; 인쇄 및 전자 책 형식으로 제공 &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;되는 녹 프로그래밍 언어&lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="12f5db48053663ec58249f015893f0934fb3f9cb" translate="yes" xml:space="preserve">
          <source>Note: This example shows the internals of &lt;code&gt;&amp;amp;str&lt;/code&gt;. &lt;code&gt;unsafe&lt;/code&gt; should not be used to get a string slice under normal circumstances. Use &lt;code&gt;as_slice&lt;/code&gt; instead.</source>
          <target state="translated">참고 :이 예는 &lt;code&gt;&amp;amp;str&lt;/code&gt; 의 내부를 보여줍니다 . 정상적인 상황에서는 &lt;code&gt;unsafe&lt;/code&gt; 문자열 슬라이스를 사용해서는 안됩니다. 대신 &lt;code&gt;as_slice&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="98315c88f72bf459de14ba0cdd9324f6a6dfd072" translate="yes" xml:space="preserve">
          <source>Note: This example shows the internals of &lt;code&gt;&amp;amp;str&lt;/code&gt;. &lt;code&gt;unsafe&lt;/code&gt; should not be used to get a string slice under normal circumstances. Use &lt;code&gt;as_str&lt;/code&gt; instead.</source>
          <target state="translated">참고 :이 예는 &lt;code&gt;&amp;amp;str&lt;/code&gt; 의 내부를 보여줍니다 . &lt;code&gt;unsafe&lt;/code&gt; 는 정상적인 상황에서 문자열 조각을 얻는 데 사용해서는 안됩니다. 대신 &lt;code&gt;as_str&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="71c5367b5e1ca4ccf0bf834db2cd4b500fbdeb5c" translate="yes" xml:space="preserve">
          <source>Note: This is about the raw &lt;code&gt;[T]&lt;/code&gt; type, not pointers (&lt;code&gt;&amp;amp;[T]&lt;/code&gt;, &lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;, etc.) to slices.</source>
          <target state="translated">참고 : 이것은 슬라이스에 대한 포인터 ( &lt;code&gt;&amp;amp;[T]&lt;/code&gt; , &lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt; 등)가 아니라 원시 &lt;code&gt;[T]&lt;/code&gt; 유형 에 관한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="53274b0feb8252b3f7e0516cd656e66a12715d39" translate="yes" xml:space="preserve">
          <source>Note: This is about the raw trait object types, not pointers (&lt;code&gt;&amp;amp;Trait&lt;/code&gt;, &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt;, etc.) to trait objects.</source>
          <target state="translated">참고 : 이것은 특성 오브젝트에 대한 포인터 ( &lt;code&gt;&amp;amp;Trait&lt;/code&gt; , &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; 등)가 아닌 원시 특성 오브젝트 유형에 관한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c578bc980d0061348761c9a476bec4981d2bea05" translate="yes" xml:space="preserve">
          <source>Note: This is about the raw trait object types, not pointers (&lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt;, &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt;, etc.) to trait objects.</source>
          <target state="translated">참고 : 이것은 트레이 트 객체에 대한 포인터 ( &lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt; , &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; 등)가 아닌 원시 트레이 트 객체 유형에 관한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3efbe622a99893d160a87ba1b5dbe54cdc04b646" translate="yes" xml:space="preserve">
          <source>Note: This is often called &quot;impl Trait in argument position&quot;.</source>
          <target state="translated">참고 :이를 &quot;인수 위치의 impl Trait&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="ebd18dc0abe826773a124050720a5e27942c51e0" translate="yes" xml:space="preserve">
          <source>Note: This is often called &quot;impl Trait in return position&quot;.</source>
          <target state="translated">참고 :이를 &quot;복귀 위치의 impl Trait&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="dcf4aae415a3e26a6bf431396708d40ea1b5d658" translate="yes" xml:space="preserve">
          <source>Note: This macro can be used in &lt;code&gt;no_std&lt;/code&gt; setups as well. In a &lt;code&gt;no_std&lt;/code&gt; setup you are responsible for the implementation details of the components.</source>
          <target state="translated">참고 :이 매크로는 &lt;code&gt;no_std&lt;/code&gt; 설정 에서도 사용할 수 있습니다 . A의 &lt;code&gt;no_std&lt;/code&gt; 설치하면 구성 요소의 구현 세부 사항에 대한 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ba312fede1a13f53566373763f2cc827d3cc6a0" translate="yes" xml:space="preserve">
          <source>Note: This may call the function multiple times if the value has been changed from other threads in the meantime, as long as the function returns &lt;code&gt;Some(_)&lt;/code&gt;, but the function will have been applied but once to the stored value.</source>
          <target state="translated">참고 : 함수가 &lt;code&gt;Some(_)&lt;/code&gt; 반환하는 한 값이 다른 스레드에서 변경된 경우 함수가 여러 번 호출 될 수 있지만 함수는 저장된 값에 한 번만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="859d3e3283a94e543f2b35839b775cd31f5e0f59" translate="yes" xml:space="preserve">
          <source>Note: This may call the function multiple times if the value has been changed from other threads in the meantime, as long as the function returns &lt;code&gt;Some(_)&lt;/code&gt;, but the function will have been applied only once to the stored value.</source>
          <target state="translated">참고 : 함수가 &lt;code&gt;Some(_)&lt;/code&gt; 반환하는 한 그 동안 다른 스레드에서 값이 변경된 경우 함수를 여러 번 호출 할 수 있지만 함수는 저장된 값에 한 번만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="64c40b5289fbe1388c2536811cdec7566f0df820" translate="yes" xml:space="preserve">
          <source>Note: This representation is unchanged if the tag is given its own member in the union, should that make manipulation more clear for you (although to follow the C++ standard the tag member should be wrapped in a &lt;code&gt;struct&lt;/code&gt;).</source>
          <target state="translated">참고 : 태그에 유니온에서 자체 멤버가 주어지면 조작이 더 명확 해지면이 표현은 변경되지 않습니다 (C ++ 표준을 따르더라도 태그 멤버는 &lt;code&gt;struct&lt;/code&gt; 로 래핑되어야 함 ).</target>
        </trans-unit>
        <trans-unit id="239a5948be38f752de16eb5b0ffe5444c5d1e29d" translate="yes" xml:space="preserve">
          <source>Note: This section is a placeholder for more comprehensive reference material.</source>
          <target state="translated">참고 :이 섹션은보다 포괄적 인 참조 자료의 자리 표시 자입니다.</target>
        </trans-unit>
        <trans-unit id="5b012ed05fd45d1a0619d2a532517a96144ac5c9" translate="yes" xml:space="preserve">
          <source>Note: This section is described more in terms of the compiler than of the language.</source>
          <target state="translated">참고 :이 섹션은 언어보다는 컴파일러 측면에서 더 많이 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="3b7a991aa3513a216522c1b812051b6fd94ca027" translate="yes" xml:space="preserve">
          <source>Note: Though you should not rely on this, all pointers to</source>
          <target state="translated">참고 : 이것에 의존해서는 안되지만 모든 포인터는</target>
        </trans-unit>
        <trans-unit id="ccec92c826b382bbeb8d0f3b3ce8f2aff5320851" translate="yes" xml:space="preserve">
          <source>Note: Traits are similar to a feature often called &lt;em&gt;interfaces&lt;/em&gt; in other languages, although with some differences.</source>
          <target state="translated">참고 : 특성은 약간의 차이가 있지만 다른 언어로 &lt;em&gt;인터페이스&lt;/em&gt; 라고하는 기능과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="0ff8579bff78c963092559227a81a969d9708ad7" translate="yes" xml:space="preserve">
          <source>Note: Trivial no-op expressions containing the value will not violate the lint. Examples include wrapping the value in a type that does not implement &lt;a href=&quot;../special-types-and-traits#drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; and then not using that type and being the final expression of a &lt;a href=&quot;../expressions/block-expr&quot;&gt;block expression&lt;/a&gt; that is not used.</source>
          <target state="translated">참고 : 값을 포함하는 간단한 no-op 식은 보푸라기를 위반하지 않습니다. 예를 들어 &lt;a href=&quot;../special-types-and-traits#drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; 을&lt;/a&gt; 구현하지 않은 유형으로 값을 랩핑 한 다음 해당 유형을 사용하지 않고 사용되지 않는 &lt;a href=&quot;../expressions/block-expr&quot;&gt;블록 표현식&lt;/a&gt; 의 최종 표현식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb186d5904a6ce9b777e0cf94b3203a9889bfac8" translate="yes" xml:space="preserve">
          <source>Note: Using primitive values when a complex type would be more appropriate is an anti-pattern known as &lt;em&gt;primitive obsession&lt;/em&gt;.</source>
          <target state="translated">참고 : 복합 유형이 더 적합 할 때 기본 값을 사용하는 것은 &lt;em&gt;기본 강박&lt;/em&gt; 이라고 알려진 안티 패턴 입니다.</target>
        </trans-unit>
        <trans-unit id="04993cf7d2f50288aed55f19ed2ebc1756b87d27" translate="yes" xml:space="preserve">
          <source>Note: We&amp;rsquo;re implementing a cons list that holds only &lt;code&gt;i32&lt;/code&gt; values for the purposes of this example. We could have implemented it using generics, as we discussed in Chapter 10, to define a cons list type that could store values of any type.</source>
          <target state="translated">참고 : 이 예제에서는 &lt;code&gt;i32&lt;/code&gt; 값만 보유하는 단점 목록을 구현하고 있습니다 . 우리는 10 장에서 논의한 것처럼 어떤 타입의 값을 저장할 수있는 cons list 타입을 정의하기 위해 generics를 사용하여 그것을 구현할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="9a9063f50fe88aae84e6d578aa20b9af4873e66f" translate="yes" xml:space="preserve">
          <source>Note: While the definition of the unsized coercions and their implementation has been stabilized, the traits themselves are not yet stable and therefore can't be used directly in stable Rust.</source>
          <target state="translated">참고 : 크기가 조정되지 않은 강제 변환의 정의와 구현이 안정화되었지만 특성 자체는 아직 안정적이지 않으므로 안정된 Rust에서 직접 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2dfa6e64910004aadc24cb034a538f296b64dc2f" translate="yes" xml:space="preserve">
          <source>Note: Windows Portability Consideration</source>
          <target state="translated">참고 : Windows 이식성 고려 사항</target>
        </trans-unit>
        <trans-unit id="54ec2a3d57d83413137977409179cfe79c9797ac" translate="yes" xml:space="preserve">
          <source>Note: You won&amp;rsquo;t just know which traits to use and which methods and functions to call from a crate. Instructions for using a crate are in each crate&amp;rsquo;s documentation. Another neat feature of Cargo is that you can run the &lt;code&gt;cargo doc --open&lt;/code&gt; command, which will build documentation provided by all of your dependencies locally and open it in your browser. If you&amp;rsquo;re interested in other functionality in the &lt;code&gt;rand&lt;/code&gt; crate, for example, run &lt;code&gt;cargo doc --open&lt;/code&gt; and click &lt;code&gt;rand&lt;/code&gt; in the sidebar on the left.</source>
          <target state="translated">참고 : 상자에서 사용할 특성과 호출 할 메소드와 함수 만 알 수 없습니다. 상자 사용 지침은 각 상자의 설명서에 있습니다. Cargo의 또 다른 멋진 기능은 &lt;code&gt;cargo doc --open&lt;/code&gt; 명령을 실행하여 모든 종속 항목이 로컬로 제공 한 문서를 작성하여 브라우저에서 열 수 있다는 것입니다. &lt;code&gt;rand&lt;/code&gt; 상자의 다른 기능에 관심이있는 경우 , &lt;code&gt;cargo doc --open&lt;/code&gt; 실행 하고 왼쪽의 사이드 바에서 &lt;code&gt;rand&lt;/code&gt; 를 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="8dd21546f26b11f02ddb49b823b4ad3f527dfdac" translate="yes" xml:space="preserve">
          <source>Note: any changes to the constness of intrinsics should be discussed with the language team. This includes changes in the stability of the constness.</source>
          <target state="translated">참고 : 내장 함수의 일관성에 대한 모든 변경 사항은 언어 팀과 논의해야합니다. 여기에는 constness의 안정성 변경이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1377a2c8bb6dcbd807394d1b50fa3eae990de774" translate="yes" xml:space="preserve">
          <source>Note: because the resulting &lt;code&gt;Location&lt;/code&gt; is a hint, an implementation may halt its walk up the stack early. See &lt;a href=&quot;#limitations&quot;&gt;Limitations&lt;/a&gt; for important caveats.</source>
          <target state="translated">참고 : 결과 &lt;code&gt;Location&lt;/code&gt; 가 힌트 이기 때문에 구현시 스택을 조기에 중단 할 수 있습니다. 중요한주의 사항 은 &lt;a href=&quot;#limitations&quot;&gt;제한 사항&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa7e98c548306a32db0bad3d57bbd3a5f699aa40" translate="yes" xml:space="preserve">
          <source>Note: if you open &lt;em&gt;/sleep&lt;/em&gt; in multiple browser windows simultaneously, they might load one at a time in 5 second intervals. Some web browsers execute multiple instances of the same request sequentially for caching reasons. This limitation is not caused by our web server.</source>
          <target state="translated">참고 : 여러 브라우저 창에서 동시에 &lt;em&gt;/ sleep&lt;/em&gt; 을 열면 5 초 간격으로 한 번에 하나씩로드 될 수 있습니다. 일부 웹 브라우저는 캐싱을 위해 동일한 요청의 여러 인스턴스를 순차적으로 실행합니다. 이 제한은 웹 서버에 의한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0f059d54c5a420d80b996d0b044829768d22d426" translate="yes" xml:space="preserve">
          <source>Note: in a future Rust version this method may become unnecessary when array literal syntax allows &lt;a href=&quot;https://github.com/rust-lang/rust/issues/49147&quot;&gt;repeating const expressions&lt;/a&gt;. The example below could then use &lt;code&gt;let mut buf = [MaybeUninit::&amp;lt;u8&amp;gt;::uninit(); 32];&lt;/code&gt;.</source>
          <target state="translated">참고 : 향후 Rust 버전에서는 배열 리터럴 구문이 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/49147&quot;&gt;반복되는 const 표현식을&lt;/a&gt; 허용 할 때이 방법이 불필요해질 수 있습니다 . 아래 예제에서는 &lt;code&gt;let mut buf = [MaybeUninit::&amp;lt;u8&amp;gt;::uninit(); 32];&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a67ae8b5976b293a38b572b260c03db2df6555be" translate="yes" xml:space="preserve">
          <source>Note: mathematical operations like &lt;a href=&quot;struct.instant#method.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; may panic if the underlying structure cannot represent the new point in time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="670b99fc8bc3c4e3e76a24aaf458d8652eb20452" translate="yes" xml:space="preserve">
          <source>Note: mathematical operations like &lt;a href=&quot;struct.systemtime#method.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; may panic if the underlying structure cannot represent the new point in time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94be0b88d71e4f4b09ff423fbdb3966a642ec68a" translate="yes" xml:space="preserve">
          <source>Note: only extended grapheme codepoints that begin the string will be escaped.</source>
          <target state="translated">참고 : 문자열을 시작하는 확장 된 grapheme 코드 포인트 만 이스케이프됩니다.</target>
        </trans-unit>
        <trans-unit id="15aa3f25c0678e364c46087d4cf15cef24972d41" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;Item&lt;/code&gt; type parameter is not used in this trait, but it allows impls to be more generic. Without it, we get this error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ba94b4a0ce80567a5f66bf9563fcdf82240def" translate="yes" xml:space="preserve">
          <source>Note: the lookup is done for each type in order, which can occasionally lead to surprising results. The below code will print &quot;In trait impl!&quot;, because &lt;code&gt;&amp;amp;self&lt;/code&gt; methods are looked up first, the trait method is found before the struct's &lt;code&gt;&amp;amp;mut self&lt;/code&gt; method is found.</source>
          <target state="translated">참고 : 각 유형에 대해 조회가 순서대로 수행되므로 때때로 놀라운 결과가 발생할 수 있습니다. 아래 코드는 &quot;특성 impl!&quot;을 인쇄합니다. 왜냐하면 &lt;code&gt;&amp;amp;self&lt;/code&gt; 메소드가 먼저 조회 되기 때문에 , trait 메소드는 struct의 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 메소드가 발견 되기 전에 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="c7cb38696a69ae9af0ae23e81e9d982ddfe77188" translate="yes" xml:space="preserve">
          <source>Note: the value returned by this method is unspecified after the range has been iterated to exhaustion.</source>
          <target state="translated">참고 :이 방법으로 반환 된 값은 범위가 모두 소진 된 후에 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa3e5b7333a9df0d2dc6ac8acfc43125fde51982" translate="yes" xml:space="preserve">
          <source>Note: there&amp;rsquo;s one big difference between the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; type we&amp;rsquo;re about to build and the real &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;: our version will not store its data on the heap. We are focusing this example on &lt;code&gt;Deref&lt;/code&gt;, so where the data is actually stored is less important than the pointer-like behavior.</source>
          <target state="translated">참고 : 빌드 하려는 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 유형과 실제 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 사이에는 큰 차이 가 있습니다.이 버전에서는 데이터가 힙에 저장되지 않습니다. 이 예제는 &lt;code&gt;Deref&lt;/code&gt; 에 초점을 맞추고 있으므로 데이터가 실제로 저장되는 위치는 포인터와 유사한 동작보다 덜 중요합니다.</target>
        </trans-unit>
        <trans-unit id="07525906ea71db41f7991cef8484c00c750f6dcb" translate="yes" xml:space="preserve">
          <source>Note: this error code is no longer emitted by the compiler</source>
          <target state="translated">참고 :이 오류 코드는 더 이상 컴파일러에서 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c580688b8d6e9090963bfacda97bc90a713c687" translate="yes" xml:space="preserve">
          <source>Note: this error code is no longer emitted by the compiler.</source>
          <target state="translated">참고 :이 오류 코드는 더 이상 컴파일러에서 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82b6db0c7e241e7e5bc0253c1ea4acf7f9b04451" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::alloc_ref(&amp;amp;b)&lt;/code&gt; instead of &lt;code&gt;b.alloc_ref()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de79d60b5ae69ae8de10ccab3addf181d505537b" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">참고 :이 연관된 당신이로 호출해야 함을 의미 기능입니다 &lt;code&gt;Box::into_raw(b)&lt;/code&gt; 대신 &lt;code&gt;b.into_raw()&lt;/code&gt; . 이는 내부 유형의 메소드와 충돌하지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9801006a2ac0b25e680ddaebb4a6a97fc9bd8dc1" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw_non_null(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw_non_null()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">참고 :이 연관된 당신이로 호출해야 함을 의미 기능입니다 &lt;code&gt;Box::into_raw_non_null(b)&lt;/code&gt; 대신 &lt;code&gt;b.into_raw_non_null()&lt;/code&gt; . 이는 내부 유형의 메소드와 충돌하지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="3ad7dd66ed2768898bcd615504f6e1f37abf0500" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw_with_alloc(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw_with_alloc()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61290dcffaed8f71df5ea3435ea91289cbca703" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::leak(b)&lt;/code&gt; instead of &lt;code&gt;b.leak()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">참고 : 이것은 관련 함수이므로 &lt;code&gt;b.leak()&lt;/code&gt; 대신 &lt;code&gt;Box::leak(b)&lt;/code&gt; 로 호출해야합니다 . 이는 내부 유형의 메소드와 충돌하지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="99cc9083edfe04d950b19fddc376275a0d86e32a" translate="yes" xml:space="preserve">
          <source>Note: while this type is unstable, the functionality it provides can be accessed through the &lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/index.html#functions&quot;&gt;free functions in &lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855408558daaf89b8b3b6445b95d7c1b8fc7ac9c" translate="yes" xml:space="preserve">
          <source>Note: while this type is unstable, the functionality it provides can be accessed through the &lt;a href=&quot;index#functions&quot;&gt;free functions in &lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 :이 유형은 불안정하지만 &lt;a href=&quot;index#functions&quot;&gt; &lt;code&gt;alloc&lt;/code&gt; &lt;/a&gt; 의 무료 기능을 통해 제공되는 기능에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="9ea884e20e19e59213993b5d483a5cae6c6deb6b" translate="yes" xml:space="preserve">
          <source>Notes about side effects</source>
          <target state="translated">부작용에 대한 메모</target>
        </trans-unit>
        <trans-unit id="0665801607b97f01a2cf09fef56752d404c94329" translate="yes" xml:space="preserve">
          <source>Notes and Safety</source>
          <target state="translated">참고 및 안전</target>
        </trans-unit>
        <trans-unit id="5367ad0070e3b4dc018a1e98ba396857c9a89c8b" translate="yes" xml:space="preserve">
          <source>Notes that contain useful information about the state of the book or point out useful, but mostly out of scope, information are in blockquotes that start with the word &quot;Note:&quot; in &lt;strong&gt;bold&lt;/strong&gt;.</source>
          <target state="translated">책의 상태에 대한 유용한 정보를 포함하거나 유용하지만 대부분 범위를 벗어난 정보는 &lt;strong&gt;굵은 글씨로&lt;/strong&gt; &quot;Note :&quot;로 시작하는 인용 부호로 &lt;strong&gt;표시&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="343e2ff0e712d5880f73c89d0629c959a0cbc677" translate="yes" xml:space="preserve">
          <source>Nothing in Rust prevents a trait from having a method with the same name as another trait&amp;rsquo;s method, nor does Rust prevent you from implementing both traits on one type. It&amp;rsquo;s also possible to implement a method directly on the type with the same name as methods from traits.</source>
          <target state="translated">Rust의 어떤 것도 특성이 다른 특성의 방법과 동일한 이름을 가진 메소드를 갖는 것을 막지 않으며 Rust가 한 유형에 두 특성을 구현하는 것을 방해하지도 않습니다. 특성의 메소드와 동일한 이름을 가진 유형에 메소드를 직접 구현할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="85a8ab9caff8306933eb7dd48f9cd08900551077" translate="yes" xml:space="preserve">
          <source>Notice in Listing 16-1 that the closure we pass to &lt;code&gt;thread::spawn&lt;/code&gt; takes no arguments: we&amp;rsquo;re not using any data from the main thread in the spawned thread&amp;rsquo;s code. To use data from the main thread in the spawned thread, the spawned thread&amp;rsquo;s closure must capture the values it needs. Listing 16-3 shows an attempt to create a vector in the main thread and use it in the spawned thread. However, this won&amp;rsquo;t yet work, as you&amp;rsquo;ll see in a moment.</source>
          <target state="translated">Listing 16-1에서 우리가 &lt;code&gt;thread::spawn&lt;/code&gt; 전달하는 클로저는 인수를 취하지 않는다는 것을 주목 하라. 스폰 된 스레드 코드에서 메인 스레드의 데이터를 사용하지 않는다. 생성 된 스레드에서 기본 스레드의 데이터를 사용하려면 생성 된 스레드의 클로저가 필요한 값을 캡처해야합니다. Listing 16-3은 메인 스레드에서 벡터를 생성하여 생성 된 스레드에서 사용하려는 시도를 보여줍니다. 그러나 잠시 후에 알 수 있듯이 아직 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="753a2ed5c1b14367e2086b1d9e2763add33258b6" translate="yes" xml:space="preserve">
          <source>Notice one interesting aspect of this particular execution: the &lt;code&gt;ThreadPool&lt;/code&gt; sent the terminate messages down the channel, and before any worker received the messages, we tried to join worker 0. Worker 0 had not yet received the terminate message, so the main thread blocked waiting for worker 0 to finish. In the meantime, each of the workers received the termination messages. When worker 0 finished, the main thread waited for the rest of the workers to finish. At that point, they had all received the termination message and were able to shut down.</source>
          <target state="translated">이 특정 실행의 흥미로운 측면 중 하나는 &lt;code&gt;ThreadPool&lt;/code&gt; 이 채널로 종료 메시지를 보냈고 작업자가 메시지를 받기 전에 작업자 0에 가입하려고 시도한 것입니다. 작업자 0은 아직 종료 메시지를받지 않았으므로 주 스레드는 대기를 차단했습니다. 작업자 0이 완료됩니다. 그 동안 각 작업자는 종료 메시지를 받았습니다. 작업자 0이 완료되면 주 스레드는 나머지 작업자가 완료 될 때까지 기다렸습니다. 이 시점에서 그들은 모두 종료 메시지를 받고 종료 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="d88bd61c5288b6b4a4fab344b4f64355a8809dd2" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; has a &lt;code&gt;From&lt;/code&gt; instance for &lt;code&gt;&amp;amp;T&lt;/code&gt;. However, this does not change the fact that mutating through a (pointer derived from a) shared reference is undefined behavior unless the mutation happens inside an &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt;&lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. The same goes for creating a mutable reference from a shared reference. When using this &lt;code&gt;From&lt;/code&gt; instance without an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;, it is your responsibility to ensure that &lt;code&gt;as_mut&lt;/code&gt; is never called, and &lt;code&gt;as_ptr&lt;/code&gt; is never used for mutation.</source>
          <target state="translated">공지 사항 것을 &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; 가 &lt;code&gt;From&lt;/code&gt; 에 대한 예를 &lt;code&gt;&amp;amp;T&lt;/code&gt; . 그러나 이것은 &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt; &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 내부에서 돌연변이가 발생하지 않는 한 공유 참조 (a에서 파생 된 포인터)를 통한 돌연변이가 정의되지 않은 동작이라는 사실을 변경하지는 않습니다 . 공유 참조에서 변경 가능한 참조를 작성하는 것도 마찬가지입니다. 이를 사용하는 경우 &lt;code&gt;From&lt;/code&gt; 없이 예를 &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; , 그 확인하는 것은 귀하의 책임입니다 &lt;code&gt;as_mut&lt;/code&gt; 가 호출되지 및 &lt;code&gt;as_ptr&lt;/code&gt; 는 돌연변이에 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a4555814d84e265a1a37b6f84e64a162ac1d207e" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;x&lt;/code&gt; is stack-allocated by &lt;code&gt;foo()&lt;/code&gt;. By default, Rust captures closed-over data by reference. This means that once &lt;code&gt;foo()&lt;/code&gt; returns, &lt;code&gt;x&lt;/code&gt; no longer exists. An attempt to access &lt;code&gt;x&lt;/code&gt; within the closure would thus be unsafe.</source>
          <target state="translated">것을 알 수 &lt;code&gt;x&lt;/code&gt; 에 의해 스택 할당 &lt;code&gt;foo()&lt;/code&gt; . 기본적으로 Rust는 참조로 닫힌 데이터를 캡처합니다. 즉, &lt;code&gt;foo()&lt;/code&gt; 반환되면 &lt;code&gt;x&lt;/code&gt; 는 더 이상 존재하지 않습니다. 따라서 클로저 내에서 &lt;code&gt;x&lt;/code&gt; 에 액세스하려는 시도 는 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e90ccdac3be23d4ae5fee41e5c9c069831f7aa8" translate="yes" xml:space="preserve">
          <source>Notice that being unblocked does not imply any synchronization with someone that unparked this thread, it could also be spurious. For example, it would be a valid, but inefficient, implementation to make both &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; return immediately without doing anything.</source>
          <target state="translated">차단이 해제되었다고해서이 스레드를 해제 한 다른 사람과의 동기화를 의미하지는 않으며 가짜 일 수도 있습니다. 예를 들어, 아무 일도하지 않고 바로 &lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt;파크 를 즉시 반환하는 것은 유효하지만 비효율적 인 구현 입니다.</target>
        </trans-unit>
        <trans-unit id="6dc4ada24330684cf56181017076bf6667acd63e" translate="yes" xml:space="preserve">
          <source>Notice that in the case of &lt;code&gt;compare_and_swap&lt;/code&gt;, it is possible that the operation ends up not performing any store and hence it has just &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. However, &lt;code&gt;AcqRel&lt;/code&gt; will never perform &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; accesses.</source>
          <target state="translated">&lt;code&gt;compare_and_swap&lt;/code&gt; 의 경우 작업이 어떤 저장도 수행하지 않고 결국 &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; ordering 만 수행 할 수 있습니다 . 그러나 &lt;code&gt;AcqRel&lt;/code&gt; 은 &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; 액세스를 수행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a7aa95fb880edfba626d059a08ec359fcae43db0" translate="yes" xml:space="preserve">
          <source>Notice that in the case of &lt;code&gt;compare_and_swap&lt;/code&gt;, it is possible that the operation ends up not performing any store and hence it has just &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. However, &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; will never perform &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; accesses.</source>
          <target state="translated">&lt;code&gt;compare_and_swap&lt;/code&gt; 의 경우 , 조작이 상점을 수행하지 않고 결과적으로 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 주문 만있을 수 있습니다 . 그러나 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt; &lt;code&gt;AcqRel&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; 액세스를 수행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d68951af70c1b2b14c8581375aa37ef775c2c882" translate="yes" xml:space="preserve">
          <source>Notice that the code panicked with the message &lt;code&gt;already borrowed: BorrowMutError&lt;/code&gt;. This is how &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; handles violations of the borrowing rules at runtime.</source>
          <target state="translated">메시지와 함께 당황한 코드는 &lt;code&gt;already borrowed: BorrowMutError&lt;/code&gt; 입니다. &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 가 런타임에 차용 규칙 위반을 처리 하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="e6e01b202ce551c042845c38802ff1f31e6bfcd1" translate="yes" xml:space="preserve">
          <source>Notice that the compiler performs this copy automatically when dropping packed structs, i.e., you do not usually have to worry about such issues unless you call &lt;code&gt;drop_in_place&lt;/code&gt; manually.</source>
          <target state="translated">압축 된 구조체를 제거 할 때 컴파일러는이 복사본을 자동으로 수행합니다. 즉, &lt;code&gt;drop_in_place&lt;/code&gt; 를 수동으로 호출하지 않으면 일반적으로 이러한 문제에 대해 걱정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="90e25cc098640b84fbba68a414a9fbb480dff45c" translate="yes" xml:space="preserve">
          <source>Notice that the first value in the vector is &lt;code&gt;&quot;target/debug/minigrep&quot;&lt;/code&gt;, which is the name of our binary. This matches the behavior of the arguments list in C, letting programs use the name by which they were invoked in their execution. It&amp;rsquo;s often convenient to have access to the program name in case you want to print it in messages or change behavior of the program based on what command line alias was used to invoke the program. But for the purposes of this chapter, we&amp;rsquo;ll ignore it and save only the two arguments we need.</source>
          <target state="translated">벡터의 첫 번째 값은 &lt;code&gt;&quot;target/debug/minigrep&quot;&lt;/code&gt; 이며 이진의 이름입니다. 이는 C에서 인수 목록의 동작과 일치하여 프로그램이 실행시 호출 된 이름을 사용할 수 있도록합니다. 메시지를 인쇄하거나 프로그램을 호출하는 데 사용 된 명령 행 별명에 따라 프로그램의 동작을 변경하려는 경우 프로그램 이름에 액세스하는 것이 편리합니다. 그러나이 장의 목적 상이를 무시하고 필요한 두 가지 주장 만 저장합니다.</target>
        </trans-unit>
        <trans-unit id="a69330b1430c6944224f92b74bbe0967131daf2e" translate="yes" xml:space="preserve">
          <source>Notice that the only type we&amp;rsquo;re interacting with from the crate is the &lt;code&gt;Post&lt;/code&gt; type. This type will use the state pattern and will hold a value that will be one of three state objects representing the various states a post can be in&amp;mdash;draft, waiting for review, or published. Changing from one state to another will be managed internally within the &lt;code&gt;Post&lt;/code&gt; type. The states change in response to the methods called by our library&amp;rsquo;s users on the &lt;code&gt;Post&lt;/code&gt; instance, but they don&amp;rsquo;t have to manage the state changes directly. Also, users can&amp;rsquo;t make a mistake with the states, like publishing a post before it&amp;rsquo;s reviewed.</source>
          <target state="translated">상자에서 상호 작용하는 유일한 유형은 &lt;code&gt;Post&lt;/code&gt; 유형입니다. 이 유형은 상태 패턴을 사용하며 게시물이 초안, 검토 대기 또는 게시 될 수있는 다양한 상태를 나타내는 세 가지 상태 객체 중 하나 인 값을 보유합니다. 한 상태에서 다른 상태로 변경하면 &lt;code&gt;Post&lt;/code&gt; 유형 내에서 내부적으로 관리됩니다 . &lt;code&gt;Post&lt;/code&gt; 인스턴스 에서 라이브러리 사용자가 호출 한 메소드에 따라 상태가 변경 되지만 상태 변경을 직접 관리 할 필요는 없습니다. 또한 사용자는 검토하기 전에 게시물을 게시하는 것과 같이 상태에 대해 실수를 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a7d5a7d44a98e57a3adf5c0193845ed9098d4a93" translate="yes" xml:space="preserve">
          <source>Notice that the workspace has only one &lt;em&gt;Cargo.lock&lt;/em&gt; file at the top level of the workspace rather than having a &lt;em&gt;Cargo.lock&lt;/em&gt; in each crate&amp;rsquo;s directory. This ensures that all crates are using the same version of all dependencies. If we add the &lt;code&gt;rand&lt;/code&gt; crate to the &lt;em&gt;adder/Cargo.toml&lt;/em&gt; and &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; files, Cargo will resolve both of those to one version of &lt;code&gt;rand&lt;/code&gt; and record that in the one &lt;em&gt;Cargo.lock&lt;/em&gt;. Making all crates in the workspace use the same dependencies means the crates in the workspace will always be compatible with each other. Let&amp;rsquo;s add the &lt;code&gt;rand&lt;/code&gt; crate to the &lt;code&gt;[dependencies]&lt;/code&gt; section in the &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; file to be able to use the &lt;code&gt;rand&lt;/code&gt; crate in the &lt;code&gt;add-one&lt;/code&gt; crate:</source>
          <target state="translated">작업 공간에는 각 상자의 디렉토리에 &lt;em&gt;Cargo.lock&lt;/em&gt; 이없는 작업 공간의 최상위 레벨에 하나의 &lt;em&gt;Cargo.lock&lt;/em&gt; 파일 만 있습니다. 이렇게하면 모든 상자가 동일한 버전의 모든 종속성을 사용하게됩니다. 우리는 추가하면 &lt;code&gt;rand&lt;/code&gt; 받는 사람 상자를 &lt;em&gt;가산기 / Cargo.toml&lt;/em&gt; 및&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt; 추가 한 / Cargo.toml의&lt;/em&gt; 파일을,화물은 한 버전으로 그 모두를 해결할 &lt;code&gt;rand&lt;/code&gt; 하나에 그 기록 &lt;em&gt;Cargo.lock&lt;/em&gt; . 작업 공간의 모든 상자가 동일한 종속성을 사용하게하면 작업 공간의 상자가 항상 서로 호환됩니다. &lt;code&gt;rand&lt;/code&gt; 상자를 &lt;code&gt;[dependencies]&lt;/code&gt; 섹션에 추가해 보겠습니다 .&lt;em&gt; 추가 한 / Cargo.toml를&lt;/em&gt; 파일을 사용할 수 있도록 &lt;code&gt;rand&lt;/code&gt; 에 상자를 &lt;code&gt;add-one&lt;/code&gt; 상자 :</target>
        </trans-unit>
        <trans-unit id="43f89d0af380f75c1edd764ee3eac2d94a06cd6c" translate="yes" xml:space="preserve">
          <source>Notice that the workspace has only one &lt;em&gt;Cargo.lock&lt;/em&gt; file at the top level of the workspace rather than having a &lt;em&gt;Cargo.lock&lt;/em&gt; in each crate&amp;rsquo;s directory. This ensures that all crates are using the same version of all dependencies. If we add the &lt;code&gt;rand&lt;/code&gt; package to the &lt;em&gt;adder/Cargo.toml&lt;/em&gt; and &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; files, Cargo will resolve both of those to one version of &lt;code&gt;rand&lt;/code&gt; and record that in the one &lt;em&gt;Cargo.lock&lt;/em&gt;. Making all crates in the workspace use the same dependencies means the crates in the workspace will always be compatible with each other. Let&amp;rsquo;s add the &lt;code&gt;rand&lt;/code&gt; crate to the &lt;code&gt;[dependencies]&lt;/code&gt; section in the &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; file to be able to use the &lt;code&gt;rand&lt;/code&gt; crate in the &lt;code&gt;add-one&lt;/code&gt; crate:</source>
          <target state="translated">작업 공간에는 각 상자의 디렉토리에 &lt;em&gt;Cargo.lock&lt;/em&gt; 이있는 것이 아니라 작업 공간의 최상위 수준에 하나의 &lt;em&gt;Cargo.lock&lt;/em&gt; 파일 만 있습니다. 이렇게하면 모든 상자가 모든 종속성의 동일한 버전을 사용하게됩니다. 우리는 추가하면 &lt;code&gt;rand&lt;/code&gt; 받는 패키지를 &lt;em&gt;가산기 / Cargo.toml&lt;/em&gt; 및 &lt;em&gt;추가 한 / Cargo.toml의&lt;/em&gt; 파일을,화물은 한 버전으로 그 모두를 해결할 &lt;code&gt;rand&lt;/code&gt; 사람의 것을 기록 &lt;em&gt;Cargo.lock&lt;/em&gt; . 작업 공간의 모든 상자가 동일한 종속성을 사용하도록한다는 것은 작업 공간의 상자가 항상 서로 호환된다는 것을 의미합니다. &lt;code&gt;rand&lt;/code&gt; 상자를 &lt;code&gt;[dependencies]&lt;/code&gt; 섹션에 추가하겠습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;add-one / Cargo.toml&lt;/em&gt; 파일을 &lt;code&gt;add-one&lt;/code&gt; 하여 추가 상자에서 &lt;code&gt;rand&lt;/code&gt; 상자 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa6a1647ef2a65fa35dd0dfd2179008c8845ec9d" translate="yes" xml:space="preserve">
          <source>Notice that this guarantee does &lt;em&gt;not&lt;/em&gt; mean that memory does not leak! It is still completely okay not ever to call &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; on a pinned element (e.g., you can still call &lt;a href=&quot;../mem/fn.forget&quot;&gt;&lt;code&gt;mem::forget&lt;/code&gt;&lt;/a&gt; on a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;). In the example of the doubly-linked list, that element would just stay in the list. However you may not free or reuse the storage &lt;em&gt;without calling &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">이 보장은 메모리가 누출 되지 &lt;em&gt;않는다는&lt;/em&gt; 것을 의미하지 않습니다! 고정 된 요소에서 &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; 을 호출하지 않는 것은 여전히 ​​완전히 괜찮습니다 (예 : &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 에서 &lt;a href=&quot;../mem/fn.forget&quot;&gt; &lt;code&gt;mem::forget&lt;/code&gt; &lt;/a&gt; 을 호출 할 수 있습니다 ). 이중 연결 목록의 예에서 해당 요소는 목록에 남아 있습니다. 그러나 &lt;em&gt;&lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;&lt;/em&gt;&lt;em&gt; 을 호출하지 않고&lt;/em&gt; 는 저장 공간 &lt;em&gt;을 확보&lt;/em&gt; 하거나 재사용 할 수 없습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d099748c8a2369f6e0484b9fb1916260cb072d44" translate="yes" xml:space="preserve">
          <source>Notice that this guarantee does &lt;em&gt;not&lt;/em&gt; mean that memory does not leak! It is still completely okay not ever to call &lt;code&gt;drop&lt;/code&gt; on a pinned element (e.g., you can still call &lt;a href=&quot;../mem/fn.forget&quot;&gt;&lt;code&gt;mem::forget&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;). In the example of the doubly-linked list, that element would just stay in the list. However you may not free or reuse the storage &lt;em&gt;without calling &lt;code&gt;drop&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">이 보증 않음을주의 &lt;em&gt;하지&lt;/em&gt; 메모리가 누출되지 않는 것을 의미! 고정 된 요소에서 &lt;code&gt;drop&lt;/code&gt; 을 호출하지 않는 것은 여전히 ​​괜찮습니다 (예 : 여전히 &lt;a href=&quot;../mem/fn.forget&quot;&gt; &lt;code&gt;mem::forget&lt;/code&gt; &lt;/a&gt; 호출 가능 A의 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ). 이중 연결 목록의 예에서 해당 요소는 목록에 그대로 있습니다. 그러나 &lt;em&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/em&gt;&lt;em&gt; 을 호출하지 않고&lt;/em&gt; 스토리지 &lt;em&gt;를&lt;/em&gt; 해제하거나 재사용 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e8e96d92ae370594b0a23d663a0a9b44ba5cff77" translate="yes" xml:space="preserve">
          <source>Notice that this time we didn&amp;rsquo;t see output indicating that Cargo was compiling &lt;code&gt;hello_cargo&lt;/code&gt;. Cargo figured out that the files hadn&amp;rsquo;t changed, so it just ran the binary. If you had modified your source code, Cargo would have rebuilt the project before running it, and you would have seen this output:</source>
          <target state="translated">이번에는 Cargo가 &lt;code&gt;hello_cargo&lt;/code&gt; 를 컴파일하고 있음을 나타내는 출력이 표시되지 않았습니다 . 화물은 파일이 변경되지 않았 음을 알았으므로 바이너리를 실행했습니다. 소스 코드를 수정 한 경우, Cargo는 프로젝트를 실행하기 전에 프로젝트를 다시 빌드했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="75afd928e1d9d07e8e8783b4a4c896142a3ef3bd" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; load operation!</source>
          <target state="translated">로드와 저장을 결합하는 작업에이 순서를 사용하면 로드 작업 이 &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; 됩니다!</target>
        </trans-unit>
        <trans-unit id="bc0d2528578bd301fdbec6c6a7d80185cfd20062" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; store operation!</source>
          <target state="translated">로드와 저장을 결합하는 작업에이 순서를 사용하면 &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; 저장 작업이 수행됩니다!</target>
        </trans-unit>
        <trans-unit id="6af1b53e3b0f26b23d98afe8cfa1fff0e78676da" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; load operation!</source>
          <target state="translated">로드와 저장을 결합하는 작업에이 순서를 사용하면 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; 로드 조작으로.</target>
        </trans-unit>
        <trans-unit id="a34cbcc2842b5a9803de21bbd3cea40bd2f9faf2" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; store operation!</source>
          <target state="translated">로드와 저장을 결합하는 작업에이 순서를 사용하면 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; store 조작이됩니다.</target>
        </trans-unit>
        <trans-unit id="1648ed9eef01e81103715c2fb558bce27eedcadf" translate="yes" xml:space="preserve">
          <source>Notice that we don&amp;rsquo;t include the &lt;code&gt;unsafe&lt;/code&gt; keyword in this code. We can create raw pointers in safe code; we just can&amp;rsquo;t dereference raw pointers outside an unsafe block, as you&amp;rsquo;ll see in a bit.</source>
          <target state="translated">이 코드 에는 &lt;code&gt;unsafe&lt;/code&gt; 키워드가 포함되어 있지 않습니다 . 안전한 코드로 원시 포인터를 만들 수 있습니다. 우리는 안전하지 않은 블록 외부에서 원시 포인터를 역 참조 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="111ab81f0256d10482ec4d240e310c1571a40527" translate="yes" xml:space="preserve">
          <source>Notice that we need an explicit lifetime &lt;code&gt;'a&lt;/code&gt; defined in the signature of &lt;code&gt;search&lt;/code&gt; and used with the &lt;code&gt;contents&lt;/code&gt; argument and the return value. Recall in &lt;a href=&quot;ch10-03-lifetime-syntax&quot;&gt;Chapter 10&lt;/a&gt; that the lifetime parameters specify which argument lifetime is connected to the lifetime of the return value. In this case, we indicate that the returned vector should contain string slices that reference slices of the argument &lt;code&gt;contents&lt;/code&gt; (rather than the argument &lt;code&gt;query&lt;/code&gt;).</source>
          <target state="translated">공지 사항 우리가 명시 적으로 수명 필요 &lt;code&gt;'a&lt;/code&gt; 의 서명에 정의 된 &lt;code&gt;search&lt;/code&gt; 및 사용 &lt;code&gt;contents&lt;/code&gt; 인수와 반환 값을. 불러올 &lt;a href=&quot;ch10-03-lifetime-syntax&quot;&gt;10 장&lt;/a&gt; 수명 파라미터는 반환 값의 수명에 접속되는 인수 수명 지정한. 이 경우 반환 된 벡터에는 인수 &lt;code&gt;contents&lt;/code&gt; 의 슬라이스를 참조하는 문자열 슬라이스가 포함되어야 함을 나타냅니다. 인수 &lt;code&gt;query&lt;/code&gt; 가 아닌 .</target>
        </trans-unit>
        <trans-unit id="fd9233164b7146f50abe145b0977e2ddba8ac9ff" translate="yes" xml:space="preserve">
          <source>Notice that we&amp;rsquo;ve split the code into the &lt;code&gt;hello_macro_derive&lt;/code&gt; function, which is responsible for parsing the &lt;code&gt;TokenStream&lt;/code&gt;, and the &lt;code&gt;impl_hello_macro&lt;/code&gt; function, which is responsible for transforming the syntax tree: this makes writing a procedural macro more convenient. The code in the outer function (&lt;code&gt;hello_macro_derive&lt;/code&gt; in this case) will be the same for almost every procedural macro crate you see or create. The code you specify in the body of the inner function (&lt;code&gt;impl_hello_macro&lt;/code&gt; in this case) will be different depending on your procedural macro&amp;rsquo;s purpose.</source>
          <target state="translated">코드를 &lt;code&gt;TokenStream&lt;/code&gt; 파싱을 담당 하는 &lt;code&gt;impl_hello_macro&lt;/code&gt; 함수와 구문 트리 변환을 담당 하는 &lt;code&gt;hello_macro_derive&lt;/code&gt; 함수 로 코드를 분할했습니다 . 이렇게하면 절차 적 매크로 작성이 더 편리해집니다. 외부 함수의 코드 ( &lt;code&gt;hello_macro_derive&lt;/code&gt; 이 경우 )는 보거나 생성하는 거의 모든 절차 적 매크로 상자에 대해 동일합니다. 내부 함수의 본문에 지정하는 코드 ( 이 경우 &lt;code&gt;impl_hello_macro&lt;/code&gt; )는 절차 매크로의 목적에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8966a5e7726edf21a4dc24ce7e3b95ed94980ac9" translate="yes" xml:space="preserve">
          <source>Notice there isn&amp;rsquo;t any code after the last line that begins with &lt;code&gt;//!&lt;/code&gt;. Because we started the comments with &lt;code&gt;//!&lt;/code&gt; instead of &lt;code&gt;///&lt;/code&gt;, we&amp;rsquo;re documenting the item that contains this comment rather than an item that follows this comment. In this case, the item that contains this comment is the &lt;em&gt;src/lib.rs&lt;/em&gt; file, which is the crate root. These comments describe the entire crate.</source>
          <target state="translated">&lt;code&gt;//!&lt;/code&gt; 시작하는 마지막 줄 뒤에는 코드가 없습니다 ! . &lt;code&gt;//!&lt;/code&gt; 주석을 시작했기 때문에 ! &lt;code&gt;///&lt;/code&gt; 대신 이 주석 다음에 나오는 항목이 아니라이 주석이 포함 된 항목을 문서화합니다. 이 경우이 주석이 포함 된 항목 은 크레이트 루트 인 &lt;em&gt;src / lib.rs&lt;/em&gt; 파일입니다. 이 의견은 전체 상자를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fcd0fb110f9fe32ec66824d300336739072d5b34" translate="yes" xml:space="preserve">
          <source>Notice this definition uses some new syntax: &lt;code&gt;type Item&lt;/code&gt; and &lt;code&gt;Self::Item&lt;/code&gt;, which are defining an &lt;em&gt;associated type&lt;/em&gt; with this trait. We&amp;rsquo;ll talk about associated types in depth in Chapter 19. For now, all you need to know is that this code says implementing the &lt;code&gt;Iterator&lt;/code&gt; trait requires that you also define an &lt;code&gt;Item&lt;/code&gt; type, and this &lt;code&gt;Item&lt;/code&gt; type is used in the return type of the &lt;code&gt;next&lt;/code&gt; method. In other words, the &lt;code&gt;Item&lt;/code&gt; type will be the type returned from the iterator.</source>
          <target state="translated">이 정의는 이 특성과 &lt;em&gt;연관된 유형&lt;/em&gt; 을 정의하는 새로운 &lt;code&gt;type Item&lt;/code&gt; : type Item 및 &lt;code&gt;Self::Item&lt;/code&gt; 구문을 사용합니다 . 우리는 19 장에서 연관된 타입들에 대해 깊이 이야기 할 것입니다. 지금, 당신이 알아야 할 것은이 코드는 &lt;code&gt;Iterator&lt;/code&gt; 특성을 구현하기 위해서는 &lt;code&gt;Item&lt;/code&gt; 타입 도 정의해야 하며이 &lt;code&gt;Item&lt;/code&gt; 타입은 반환 타입에 사용 된다는 것 입니다. &lt;code&gt;next&lt;/code&gt; 방법. 즉, &lt;code&gt;Item&lt;/code&gt; 유형은 반복자에서 리턴 된 유형입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0aa323f0e9e9e9d80a8d3d6a7b2a9db9ba76843" translate="yes" xml:space="preserve">
          <source>Now all the instances of &lt;code&gt;Point&lt;/code&gt; shown are allowed! You can use as many generic type parameters in a definition as you want, but using more than a few makes your code hard to read. When you need lots of generic types in your code, it could indicate that your code needs restructuring into smaller pieces.</source>
          <target state="translated">이제 모든 인스턴스 &lt;code&gt;Point&lt;/code&gt; 표시된 Point의 가 허용됩니다! 정의에 원하는만큼 많은 제네릭 형식 매개 변수를 사용할 수 있지만 몇 개 이상을 사용하면 코드를 읽기가 어렵습니다. 코드에 많은 제네릭 형식이 필요한 경우 코드를 더 작은 조각으로 재구성해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="23eaa14436421a3e3cff4560bf4fb71eb52f11da" translate="yes" xml:space="preserve">
          <source>Now all the references in this function signature have lifetimes, and the compiler can continue its analysis without needing the programmer to annotate the lifetimes in this function signature.</source>
          <target state="translated">이제이 함수 시그니처의 모든 참조에는 수명이 있으며 컴파일러는 프로그래머가이 함수 시그니처의 수명에 주석을 달지 않고도 분석을 계속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e1a1d010dc9ab9a0953fedbe299c3c77ffa1062" translate="yes" xml:space="preserve">
          <source>Now an example of &lt;code&gt;bool&lt;/code&gt; cast to integer type:</source>
          <target state="translated">이제 &lt;code&gt;bool&lt;/code&gt; 의 예 을 정수 유형으로 캐스트 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d65b9b0f422f439e94c8e42e9b963ca1e3008607" translate="yes" xml:space="preserve">
          <source>Now consider this twist where we add a call to &lt;code&gt;rev&lt;/code&gt;. This version will print &lt;code&gt;('c', 1), ('b', 2), ('a', 3)&lt;/code&gt;. Note that the letters are reversed, but the values of the counter still go in order. This is because &lt;code&gt;map()&lt;/code&gt; is still being called lazily on each item, but we are popping items off the back of the vector now, instead of shifting them from the front.</source>
          <target state="translated">이제 우리는 &lt;code&gt;rev&lt;/code&gt; 호출을 추가하는이 비틀기를 고려하십시오 . 이 버전은 &lt;code&gt;('c', 1), ('b', 2), ('a', 3)&lt;/code&gt; 합니다. 문자는 반대로되어 있지만 카운터 값은 여전히 ​​순서대로 유지됩니다. &lt;code&gt;map()&lt;/code&gt; 때문입니다 이 여전히 각 항목에서 게으르게 호출 벡터를 앞에서 뒤로 이동하는 대신 벡터 뒷면에서 항목을 팝합니다.</target>
        </trans-unit>
        <trans-unit id="3a875ba4bda66efea86acc1d83b8c4cd40356ff2" translate="yes" xml:space="preserve">
          <source>Now enter the code in Listing 20-1 in &lt;em&gt;src/main.rs&lt;/em&gt; to start. This code will listen at the address &lt;code&gt;127.0.0.1:7878&lt;/code&gt; for incoming TCP streams. When it gets an incoming stream, it will print &lt;code&gt;Connection established!&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;em&gt;src / main.rs&lt;/em&gt; 에 Listing 20-1의 코드를 입력하여 시작 &lt;em&gt;하자&lt;/em&gt; . 이 코드는 들어오는 TCP 스트림에 대해 주소 &lt;code&gt;127.0.0.1:7878&lt;/code&gt; 을 수신합니다. 들어오는 스트림을 받으면 &lt;code&gt;Connection established!&lt;/code&gt; 을 인쇄 합니다!.</target>
        </trans-unit>
        <trans-unit id="dc71b87d7408d245b3b0aa3a92982cb74fc6ac9f" translate="yes" xml:space="preserve">
          <source>Now everything in the program should work as expected. Let&amp;rsquo;s try it:</source>
          <target state="translated">이제 프로그램의 모든 것이 예상대로 작동합니다. 해 봅시다:</target>
        </trans-unit>
        <trans-unit id="d7f4763863038d188ed1914c2142e2e561d22201" translate="yes" xml:space="preserve">
          <source>Now if we change either the function or the example so the &lt;code&gt;assert_eq!&lt;/code&gt; in the example panics and run &lt;code&gt;cargo test&lt;/code&gt; again, we&amp;rsquo;ll see that the doc tests catch that the example and the code are out of sync with each other!</source>
          <target state="translated">이제 함수 또는 예제를 변경하면 &lt;code&gt;assert_eq!&lt;/code&gt; 예에서 패닉과 런 &lt;code&gt;cargo test&lt;/code&gt; 다시 하면 doc 테스트에서 예제와 코드가 서로 맞지 않는다는 것을 알 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="2e5aa4ec7130600ff4ecc4d4f5150848ff00d36e" translate="yes" xml:space="preserve">
          <source>Now it's possible to create at least one instance of &lt;code&gt;Foo&lt;/code&gt;: &lt;code&gt;Foo { x: None }&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;Foo&lt;/code&gt; 의 인스턴스를 하나 이상 만들 수 있습니다 : &lt;code&gt;Foo { x: None }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57dee911ce426e019e30db0fccc486981ac3d8d4" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add the code in Listing 20-7 to the &lt;code&gt;else&lt;/code&gt; block to return a response with the status code 404, which signals that the content for the request was not found. We&amp;rsquo;ll also return some HTML for a page to render in the browser indicating the response to the end user.</source>
          <target state="translated">이제 Listing 20-7의 코드를 &lt;code&gt;else&lt;/code&gt; 블록 에 추가하여 상태 코드가 404 인 응답을 반환하면 요청의 컨텐츠를 찾을 수 없음을 알 수있다. 또한 최종 사용자에 대한 응답을 나타내는 페이지를 브라우저에서 렌더링 할 HTML을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="82511279c647b8b87ee818b8d44458ab76617b1f" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s compile this &amp;ldquo;Hello, world!&amp;rdquo; program and run it in the same step using the &lt;code&gt;cargo run&lt;/code&gt; command:</source>
          <target state="translated">이제이 &quot;Hello, world!&quot;를 컴파일합시다. &lt;code&gt;cargo run&lt;/code&gt; 명령을 사용하여 동일한 단계에서 프로그램을 실행하고 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="8863ee5075a8246e730bfe40012862faba75a02b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s consider the second call of &lt;code&gt;plus_one&lt;/code&gt; in Listing 6-5, where &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;. We enter the &lt;code&gt;match&lt;/code&gt; and compare to the first arm.</source>
          <target state="translated">이제 Listing 6-5에서 &lt;code&gt;plus_one&lt;/code&gt; 의 두 번째 호출을 고려하자 . 여기서 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;None&lt;/code&gt; 이다. 우리는 &lt;code&gt;match&lt;/code&gt; 입력 첫 번째 팔과 비교합니다.</target>
        </trans-unit>
        <trans-unit id="b8300b290a67f9ed128322c21050dab12f2d0aa0" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s examine lifetime annotations in the context of the &lt;code&gt;longest&lt;/code&gt; function. As with generic type parameters, we need to declare generic lifetime parameters inside angle brackets between the function name and the parameter list. The constraint we want to express in this signature is that all the references in the parameters and the return value must have the same lifetime. We&amp;rsquo;ll name the lifetime &lt;code&gt;'a&lt;/code&gt; and then add it to each reference, as shown in Listing 10-22.</source>
          <target state="translated">이제 &lt;code&gt;longest&lt;/code&gt; 함수 의 맥락에서 평생 주석을 살펴 보겠습니다 . 제네릭 형식 매개 변수와 마찬가지로 함수 이름과 매개 변수 목록 사이의 꺾쇠 괄호 안에 일반 수명 매개 변수를 선언해야합니다. 이 서명으로 표현하려는 제약 조건은 매개 변수의 모든 참조와 반환 값의 수명이 같아야한다는 것입니다. 우리는 수명 &lt;code&gt;'a&lt;/code&gt; 이름을 'a'로 지정한 다음 목록 10-22에 표시된 것처럼 각 참조에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4d1d28eae4c7f65ed347f71ad22936c83ed0eb43" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s lean on the compiler to find the other places that need to change. Checking this code, we get two errors:</source>
          <target state="translated">이제 컴파일러에 의지하여 변경해야 할 다른 장소를 찾으십시오. 이 코드를 확인하면 두 가지 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="89a2cc6c6da74e574a540dd470febae8d113a245" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at the &lt;code&gt;String&lt;/code&gt; version:</source>
          <target state="translated">이제 &lt;code&gt;String&lt;/code&gt; 버전을 보자 :</target>
        </trans-unit>
        <trans-unit id="aaee68df203c11b18152dd8afe26709ec73580c1" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at the pattern in the body of the code associated with this arm: &lt;code&gt;temp_vec.push()&lt;/code&gt; within &lt;code&gt;$()*&lt;/code&gt; is generated for each part that matches &lt;code&gt;$()&lt;/code&gt; in the pattern zero or more times depending on how many times the pattern matches. The &lt;code&gt;$x&lt;/code&gt; is replaced with each expression matched. When we call this macro with &lt;code&gt;vec![1, 2, 3];&lt;/code&gt;, the code generated that replaces this macro call will be the following:</source>
          <target state="translated">이제이 암과 관련된 코드의 본문에 패턴에하자보기 : &lt;code&gt;temp_vec.push()&lt;/code&gt; 내에서 &lt;code&gt;$()*&lt;/code&gt; 일치하는 각 부분에 대해 생성됩니다 &lt;code&gt;$()&lt;/code&gt; 횟수에 따라 패턴에서 0 번 이상을 패턴 일치. &lt;code&gt;$x&lt;/code&gt; 유사한 각각의 식으로 대체된다. 우리가 &lt;code&gt;vec![1, 2, 3];&lt;/code&gt; 로이 매크로를 호출 할 때 ! [1, 2, 3]; 이 매크로 호출을 대체하는 생성 된 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c4243cfe8f9ac10ec246b38ad823287bb3f58d73" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at what&amp;rsquo;s different when we build and run the &amp;ldquo;Hello, world!&amp;rdquo; program with Cargo! From your &lt;em&gt;hello_cargo&lt;/em&gt; directory, build your project by entering the following command:</source>
          <target state="translated">이제 &quot;Hello, world!&quot;를 빌드하고 실행할 때 무엇이 ​​다른지 살펴 보겠습니다. Cargo로 프로그램! 당신의에서 &lt;em&gt;hello_cargo의&lt;/em&gt; 디렉토리, 다음 명령을 입력하여 프로젝트를 빌드 :</target>
        </trans-unit>
        <trans-unit id="80b98c3dc4276471e5dedcfc50a6872d575390db" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at what&amp;rsquo;s different when we build and run the Hello, world! program with Cargo! From your &lt;em&gt;hello_cargo&lt;/em&gt; directory, build your project by entering the following command:</source>
          <target state="translated">이제 Hello, world를 빌드하고 실행할 때의 차이점을 살펴 보겠습니다. 화물 프로그램! 당신의&lt;em&gt; hello_cargo에서&lt;/em&gt; 디렉토리, 다음 명령을 입력하여 프로젝트를 빌드 :</target>
        </trans-unit>
        <trans-unit id="5b581411bc505a7c21b9a362d12d054fb0134b63" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s run the test:</source>
          <target state="translated">이제 테스트를 실행 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="f0501637a3932ce5ddf54dd291b5e0f5788b9a63" translate="yes" xml:space="preserve">
          <source>Now open &lt;em&gt;src/main.rs&lt;/em&gt; and take a look:</source>
          <target state="translated">이제 &lt;em&gt;src / main.rs를&lt;/em&gt; 엽니 다&lt;em&gt;&lt;/em&gt; 살펴보십시오 :</target>
        </trans-unit>
        <trans-unit id="b399f29f23b6c286984286dd9b48d3e844228cb4" translate="yes" xml:space="preserve">
          <source>Now open the &lt;em&gt;main.rs&lt;/em&gt; file you just created and enter the code in Listing 1-1.</source>
          <target state="translated">이제 &lt;em&gt;main.rs를&lt;/em&gt; 엽니 다&lt;em&gt;&lt;/em&gt; 방금 만든 파일을 목록 1-1에 코드를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="d981ccfedbc387139591c6429e1ab6bbb51ae547" translate="yes" xml:space="preserve">
          <source>Now our code more clearly conveys that &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; are related and that their purpose is to configure how the program will work. Any code that uses these values knows to find them in the &lt;code&gt;config&lt;/code&gt; instance in the fields named for their purpose.</source>
          <target state="translated">이제 코드는 &lt;code&gt;query&lt;/code&gt; 와 &lt;code&gt;filename&lt;/code&gt; 이 관련되어 있으며 프로그램의 작동 방식을 구성하는 것임을 더 명확하게 전달합니다 . 이 값을 사용하는 모든 코드는 &lt;code&gt;config&lt;/code&gt; 에서 값을 찾는 것을 알고 있습니다. 인스턴스에서 목적으로 이름 지정된 필드의 있습니다.</target>
        </trans-unit>
        <trans-unit id="e98906bcddd6edae414bc05f0060b41c04becc18" translate="yes" xml:space="preserve">
          <source>Now run &lt;code&gt;cargo test&lt;/code&gt; in the top-level &lt;em&gt;add&lt;/em&gt; directory:</source>
          <target state="translated">이제 최상위 레벨 &lt;em&gt;추가&lt;/em&gt; 에서 &lt;code&gt;cargo test&lt;/code&gt; 를 실행 &lt;em&gt;하십시오.&lt;/em&gt; 디렉토리 .</target>
        </trans-unit>
        <trans-unit id="d7999991a01bc3db0ab51179e8f7d5b7ea1e4709" translate="yes" xml:space="preserve">
          <source>Now that the &lt;code&gt;search&lt;/code&gt; function is working and tested, we need to call &lt;code&gt;search&lt;/code&gt; from our &lt;code&gt;run&lt;/code&gt; function. We need to pass the &lt;code&gt;config.query&lt;/code&gt; value and the &lt;code&gt;contents&lt;/code&gt; that &lt;code&gt;run&lt;/code&gt; reads from the file to the &lt;code&gt;search&lt;/code&gt; function. Then &lt;code&gt;run&lt;/code&gt; will print each line returned from &lt;code&gt;search&lt;/code&gt;:</source>
          <target state="translated">이제 것을 &lt;code&gt;search&lt;/code&gt; 기능이 작동 및 테스트, 우리는 호출 할 필요가 &lt;code&gt;search&lt;/code&gt; 우리의 &lt;code&gt;run&lt;/code&gt; 기능을. &lt;code&gt;config.query&lt;/code&gt; 값과 &lt;code&gt;run&lt;/code&gt; 된 &lt;code&gt;contents&lt;/code&gt; 을 파일에서 &lt;code&gt;search&lt;/code&gt; 기능 으로 전달해야 합니다. 그런 다음 &lt;code&gt;run&lt;/code&gt; 은 &lt;code&gt;search&lt;/code&gt; 에서 반환 된 각 줄을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="03229adf31a42bdb64eb9cba521d26f0154223d5" translate="yes" xml:space="preserve">
          <source>Now that the closure has its own copy of the data, there's no need to worry about safety.</source>
          <target state="translated">클로저에는 자체 데이터 사본이 있으므로 안전에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="80c8ae661a453d666a29851514f9590667d50328" translate="yes" xml:space="preserve">
          <source>Now that we have a library crate in the workspace, we can have the binary crate &lt;code&gt;adder&lt;/code&gt; depend on the library crate &lt;code&gt;add-one&lt;/code&gt;. First, we&amp;rsquo;ll need to add a path dependency on &lt;code&gt;add-one&lt;/code&gt; to &lt;em&gt;adder/Cargo.toml&lt;/em&gt;.</source>
          <target state="translated">이제 우리는 작업 공간에서 라이브러리 상자를 가지고, 우리는 진 상자 가질 수 &lt;code&gt;adder&lt;/code&gt; 라이브러리 나무 상자에 따라 &lt;code&gt;add-one&lt;/code&gt; . 먼저 &lt;code&gt;add-one&lt;/code&gt; 에 &lt;em&gt;adder / Cargo.toml&lt;/em&gt; 에 경로 의존성을 추가 해야합니다.&lt;em&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e1d03746f7af11550c4dab530f554fdd12c9b9be" translate="yes" xml:space="preserve">
          <source>Now that we have a way to know we have a valid number of threads to store in the pool, we can create those threads and store them in the &lt;code&gt;ThreadPool&lt;/code&gt; struct before returning it. But how do we &amp;ldquo;store&amp;rdquo; a thread? Let&amp;rsquo;s take another look at the &lt;code&gt;thread::spawn&lt;/code&gt; signature:</source>
          <target state="translated">이제 풀에 저장할 수있는 스레드 수가 유효한지 알 수 있으므로 해당 스레드를 작성하여 반환하기 전에 &lt;code&gt;ThreadPool&lt;/code&gt; 구조체 에 저장할 수 있습니다. 그러나 어떻게 스레드를 &quot;저장&quot;합니까? &lt;code&gt;thread::spawn&lt;/code&gt; 을 다시 살펴 보겠습니다. signature를 :</target>
        </trans-unit>
        <trans-unit id="bda29c679c337b77198a68eb0c281ffe77fd4dfe" translate="yes" xml:space="preserve">
          <source>Now that we have an external dependency, Cargo fetches the latest versions of everything from the &lt;em&gt;registry&lt;/em&gt;, which is a copy of data from &lt;a href=&quot;https://crates.io/&quot;&gt;Crates.io&lt;/a&gt;. Crates.io is where people in the Rust ecosystem post their open source Rust projects for others to use.</source>
          <target state="translated">이제 외부 의존성 이 &lt;a href=&quot;https://crates.io/&quot;&gt;생겼으므로 Cargo&lt;/a&gt; 는 Crates.io 의 데이터 복사 본인 &lt;em&gt;레지스트리&lt;/em&gt; 에서 최신 버전을 가져옵니다. . Crates.io는 Rust 생태계의 사람들이 다른 사람들이 사용할 수 있도록 오픈 소스 Rust 프로젝트를 게시하는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="b1ccc08848b1ba0169c7f988c879a0f190ff1fea" translate="yes" xml:space="preserve">
          <source>Now that we have another package in the workspace, we can have the &lt;code&gt;adder&lt;/code&gt; package with our binary depend on the &lt;code&gt;add-one&lt;/code&gt; package, that has our library. First, we&amp;rsquo;ll need to add a path dependency on &lt;code&gt;add-one&lt;/code&gt; to &lt;em&gt;adder/Cargo.toml&lt;/em&gt;.</source>
          <target state="translated">이제 작업 공간에 다른 패키지가 있으므로 바이너리 가있는 &lt;code&gt;adder&lt;/code&gt; 패키지가 라이브러리가 있는 &lt;code&gt;add-one&lt;/code&gt; 패키지 에 종속되도록 할 수 있습니다 . 첫째, 우리는에 경로 의존성을 추가해야합니다 &lt;code&gt;add-one&lt;/code&gt; 에 &lt;em&gt;/ 가산기 Cargo.toml을&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3228f1351fbe40c57701ca17a80dd025a6bfe94f" translate="yes" xml:space="preserve">
          <source>Now that we have the code to turn the annotated Rust code from a &lt;code&gt;TokenStream&lt;/code&gt; into a &lt;code&gt;DeriveInput&lt;/code&gt; instance, let&amp;rsquo;s generate the code that implements the &lt;code&gt;HelloMacro&lt;/code&gt; trait on the annotated type, as shown in Listing 19-33.</source>
          <target state="translated">이제 주석이 달린 Rust 코드를 &lt;code&gt;TokenStream&lt;/code&gt; 에서 &lt;code&gt;DeriveInput&lt;/code&gt; 인스턴스 로 변환하는 코드를 작성 &lt;code&gt;HelloMacro&lt;/code&gt; 에 표시된대로 주석이있는 유형 에서 HelloMacro 특성 을 구현하는 코드를 생성하자 .</target>
        </trans-unit>
        <trans-unit id="a05d1adf4441c02b17aff2e4ed6b1b6d76dccfa3" translate="yes" xml:space="preserve">
          <source>Now that we have the context, let&amp;rsquo;s get to the algorithm. The function &lt;code&gt;generate_workout&lt;/code&gt; in Listing 13-3 contains the business logic of the app that we&amp;rsquo;re most concerned with in this example. The rest of the code changes in this example will be made to this function.</source>
          <target state="translated">이제 컨텍스트가 완성되었으므로 알고리즘을 살펴 보겠습니다. Listing 13-3의 &lt;code&gt;generate_workout&lt;/code&gt; 함수 에는이 예제에서 가장 관심있는 앱의 비즈니스 로직이 포함되어있다. 이 예제에서 코드의 나머지 부분은이 기능에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d0d7185e0fbe1a274eebe89e5b39be3986c2db0a" translate="yes" xml:space="preserve">
          <source>Now that we have user input and a random number, we can compare them. That step is shown in Listing 2-4. Note that this code won&amp;rsquo;t compile quite yet, as we will explain.</source>
          <target state="translated">이제 사용자 입력과 임의의 숫자가 있으므로 비교할 수 있습니다. 이 단계는 목록 2-4에 표시되어 있습니다. 이 코드는 아직 설명하지 않듯이 아직 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="38f50db14e5d3025086efbe8bea15a9ba8ef6b08" translate="yes" xml:space="preserve">
          <source>Now that we know what the browser is asking for, let&amp;rsquo;s send back some data!</source>
          <target state="translated">브라우저가 요구하는 것을 알고 있으므로 데이터를 다시 보내 봅시다!</target>
        </trans-unit>
        <trans-unit id="e92484795e9a806e19045c8bd7479798242a92b0" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve defined the desired behavior using the &lt;code&gt;Summary&lt;/code&gt; trait, we can implement it on the types in our media aggregator. Listing 10-13 shows an implementation of the &lt;code&gt;Summary&lt;/code&gt; trait on the &lt;code&gt;NewsArticle&lt;/code&gt; struct that uses the headline, the author, and the location to create the return value of &lt;code&gt;summarize&lt;/code&gt;. For the &lt;code&gt;Tweet&lt;/code&gt; struct, we define &lt;code&gt;summarize&lt;/code&gt; as the username followed by the entire text of the tweet, assuming that tweet content is already limited to 280 characters.</source>
          <target state="translated">&lt;code&gt;Summary&lt;/code&gt; 특성을 사용하여 원하는 동작을 정의 했으므로 미디어 집 계기의 유형에이를 구현할 수 있습니다. 10-13 쇼의 구현 목록 &lt;code&gt;Summary&lt;/code&gt; 상의 특성 &lt;code&gt;NewsArticle&lt;/code&gt; 의 제목, 저자, 그리고 반환 값을 만들 수있는 위치에 사용하는 구조체 &lt;code&gt;summarize&lt;/code&gt; . 를 들어 &lt;code&gt;Tweet&lt;/code&gt; 구조체, 우리는 정의 &lt;code&gt;summarize&lt;/code&gt; 사용자 이름이 그 트윗 내용이 이미 280 자로 제한됩니다 가정, 트윗의 전체 텍스트 뒤에있다.</target>
        </trans-unit>
        <trans-unit id="847c864456f96a628c83e8df1e38c081c9008635" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve defined threads in Rust, let&amp;rsquo;s explore how to use the thread-related API provided by the standard library.</source>
          <target state="translated">Rust에서 스레드를 정의 했으므로 표준 라이브러리에서 제공하는 스레드 관련 API를 사용하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="4bba9ff87fd1d7a113978a70c232f211dcf89ab4" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve discussed some of the most common ways to use vectors, be sure to review &lt;a href=&quot;../std/vec/struct.vec&quot;&gt;the API documentation&lt;/a&gt; for all the many useful methods defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; by the standard library. For example, in addition to &lt;code&gt;push&lt;/code&gt;, a &lt;code&gt;pop&lt;/code&gt; method removes and returns the last element. Let&amp;rsquo;s move on to the next collection type: &lt;code&gt;String&lt;/code&gt;!</source>
          <target state="translated">벡터를 사용하는 가장 일반적인 방법에 대해 논의 했으므로 이제 표준 라이브러리 에서 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 에 정의 된 모든 유용한 메서드에 대한 &lt;a href=&quot;../std/vec/struct.vec&quot;&gt;API 설명서&lt;/a&gt; 를 검토 하십시오 . 예를 들어,뿐만 아니라 &lt;code&gt;push&lt;/code&gt; 하는 &lt;code&gt;pop&lt;/code&gt; 방법 제거하고 반환 마지막 요소. 다음 컬렉션 유형 인 &lt;code&gt;String&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="87dd1868af24eb68dc999a15f4b71b72a52c4914" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve discussed some of the most common ways to use vectors, be sure to review the API documentation for all the many useful methods defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; by the standard library. For example, in addition to &lt;code&gt;push&lt;/code&gt;, a &lt;code&gt;pop&lt;/code&gt; method removes and returns the last element. Let&amp;rsquo;s move on to the next collection type: &lt;code&gt;String&lt;/code&gt;!</source>
          <target state="translated">벡터를 사용하는 가장 일반적인 방법 중 일부를 살펴 보았 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 표준 라이브러리에 의해 Vec &amp;lt;T&amp;gt; 에 정의 된 많은 유용한 방법에 대한 API 설명서를 검토하십시오 . 예를 들어,뿐만 아니라 &lt;code&gt;push&lt;/code&gt; 하는 &lt;code&gt;pop&lt;/code&gt; 방법 제거하고 반환 마지막 요소. 다음 컬렉션 타입으로 넘어 갑시다 : &lt;code&gt;String&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="2ec4c24a317d3f7bc3c352fa146805708f0bd185" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve discussed the details of calling &lt;code&gt;panic!&lt;/code&gt; or returning &lt;code&gt;Result&lt;/code&gt;, let&amp;rsquo;s return to the topic of how to decide which is appropriate to use in which cases.</source>
          <target state="translated">이제 &lt;code&gt;panic!&lt;/code&gt; 전화의 세부 사항에 대해 논의했습니다 ! 또는 &lt;code&gt;Result&lt;/code&gt; 반환하는 경우 어떤 경우에 사용하기에 적합한지를 결정하는 방법의 주제로 돌아가 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="dcf9675ca650b7816e93bbac61987240fde0e1c1" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve examined &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and some of the characteristics of smart pointers, let&amp;rsquo;s look at a few other smart pointers defined in the standard library.</source>
          <target state="translated">우리가 검토 한 이제 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 와 스마트 포인터의 특성 중 일부를 표준 라이브러리에 정의 된 몇 가지 다른 스마트 포인터에서의 모습을 보자.</target>
        </trans-unit>
        <trans-unit id="1275cf5c5193957df5e8d9870d52448402e96389" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve explored how variables work, let&amp;rsquo;s look at more data types they can have.</source>
          <target state="translated">변수의 작동 방식을 살펴 보았으므로 더 많은 데이터 유형을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="b53e79d7c3785836a15f4ecfc6aac9abee118b76" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve extracted the logic into &lt;em&gt;src/lib.rs&lt;/em&gt; and left the argument collecting and error handling in &lt;em&gt;src/main.rs&lt;/em&gt;, it&amp;rsquo;s much easier to write tests for the core functionality of our code. We can call functions directly with various arguments and check return values without having to call our binary from the command line. Feel free to write some tests for the functionality in the &lt;code&gt;Config::new&lt;/code&gt; and &lt;code&gt;run&lt;/code&gt; functions on your own.</source>
          <target state="translated">이제 논리를 &lt;em&gt;src / lib.rs&lt;/em&gt; 로 추출하고 인수 수집 및 오류 처리를 &lt;em&gt;src / main.rs에 남겨 두었으므로&lt;/em&gt; 코드의 핵심 기능에 대한 테스트를 작성하는 것이 훨씬 쉽습니다. 명령 행에서 바이너리를 호출하지 않고도 다양한 인수로 직접 함수를 호출하고 리턴 값을 확인할 수 있습니다. 의 기능에 대한 몇 가지 테스트 쓰기 자유롭게 &lt;code&gt;Config::new&lt;/code&gt; 및 &lt;code&gt;run&lt;/code&gt; 자신의 기능을.</target>
        </trans-unit>
        <trans-unit id="2a08eff4bb167e5da1e95f954b1304af56f21965" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve finished refactoring the configuration parsing, let&amp;rsquo;s turn to the program&amp;rsquo;s logic. As we stated in &lt;a href=&quot;#separation-of-concerns-for-binary-projects&quot;&gt;&amp;ldquo;Separation of Concerns for Binary Projects&amp;rdquo;&lt;/a&gt;, we&amp;rsquo;ll extract a function named &lt;code&gt;run&lt;/code&gt; that will hold all the logic currently in the &lt;code&gt;main&lt;/code&gt; function that isn&amp;rsquo;t involved with setting up configuration or handling errors. When we&amp;rsquo;re done, &lt;code&gt;main&lt;/code&gt; will be concise and easy to verify by inspection, and we&amp;rsquo;ll be able to write tests for all the other logic.</source>
          <target state="translated">구성 구문 분석 리팩토링을 마쳤으므로 프로그램 논리로 돌아가 보겠습니다. &lt;a href=&quot;#separation-of-concerns-for-binary-projects&quot;&gt;&amp;ldquo;이진 프로젝트에 대한 우려 분리&amp;rdquo;&lt;/a&gt; 에서 언급했듯이 구성 설정 또는 오류 처리와 관련이없는 &lt;code&gt;main&lt;/code&gt; 기능에 현재있는 모든 논리를 보유하는 &lt;code&gt;run&lt;/code&gt; 이라는 함수를 추출 합니다. 완료되면 &lt;code&gt;main&lt;/code&gt; 은 간결하고 검사를 통해 쉽게 확인할 수 있으며 다른 모든 논리에 대한 테스트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67636ff52e1a7401207e61d89497c3656085f595" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve improved the expressiveness of our I/O project, let&amp;rsquo;s look at some more features of &lt;code&gt;cargo&lt;/code&gt; that will help us share the project with the world.</source>
          <target state="translated">이제 I / O 프로젝트의 표현성을 향상 시켰으므로 프로젝트를 세계와 공유하는 데 도움이되는 &lt;code&gt;cargo&lt;/code&gt; 몇 가지 추가 기능을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="f8c732cbf77e2073635c5b38e31310fafb9b6c1e" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve introduced iterators, we can demonstrate a common use of closures that capture their environment by using the &lt;code&gt;filter&lt;/code&gt; iterator adaptor. The &lt;code&gt;filter&lt;/code&gt; method on an iterator takes a closure that takes each item from the iterator and returns a Boolean. If the closure returns &lt;code&gt;true&lt;/code&gt;, the value will be included in the iterator produced by &lt;code&gt;filter&lt;/code&gt;. If the closure returns &lt;code&gt;false&lt;/code&gt;, the value won&amp;rsquo;t be included in the resulting iterator.</source>
          <target state="translated">반복자를 소개 했으므로 &lt;code&gt;filter&lt;/code&gt; 반복자 어댑터를 사용하여 환경을 캡처하는 클로저의 일반적인 사용을 보여줄 수 있습니다 . 반복자 의 &lt;code&gt;filter&lt;/code&gt; 메소드는 반복자에서 각 항목을 가져 와서 부울을 리턴하는 클로저를 가져옵니다. 클로저가 &lt;code&gt;true&lt;/code&gt; 를 반환하면 &lt;code&gt;filter&lt;/code&gt; 의해 생성 된 반복기에 값이 포함됩니다 . 클로저가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 결과 반복자에 값이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0f5c8cc4166bf098c054b91aa56eafdd80a280aa" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve looked at how channels work, let&amp;rsquo;s look at a different method of concurrency.</source>
          <target state="translated">채널 작동 방식을 살펴 보았으므로 다른 동시성 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="67653a6049372ba09d60cbd375a44f6c3cccaf9a" translate="yes" xml:space="preserve">
          <source>Now that we've got an idea of what unwind safety is in Rust, it's also important to understand what this trait represents. As mentioned above, one way to witness broken invariants is through the &lt;code&gt;catch_unwind&lt;/code&gt; function in this module as it allows catching a panic and then re-using the environment of the closure.</source>
          <target state="translated">이제 Rust의 언 와인드 안전성에 대한 아이디어를 얻었으므로이 특성이 무엇을 나타내는 지 이해하는 것이 중요합니다. 위에서 언급 한 것처럼 깨진 불변량을 목격하는 한 가지 방법 은 패닉을 포착 한 다음 클로저 환경을 재사용 할 수 있도록이 모듈 의 &lt;code&gt;catch_unwind&lt;/code&gt; 함수를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d02969884890c4347910c461b721cc439357c5a4" translate="yes" xml:space="preserve">
          <source>Now that you have an account, let&amp;rsquo;s say you have a crate you want to publish. Before publishing, you&amp;rsquo;ll need to add some metadata to your crate by adding it to the &lt;code&gt;[package]&lt;/code&gt; section of the crate&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">계정이 생겼으니 게시하려는 상자가 있다고 가정하겠습니다. 게시하기 전에 상자의 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일 의 &lt;code&gt;[package]&lt;/code&gt; 섹션에 메타 데이터를 추가하여 상자에 메타 데이터를 추가해야 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09f54035802dcb8ec1dd44caa3ea32209f58c20d" translate="yes" xml:space="preserve">
          <source>Now that you know how to create, update, and destroy vectors, knowing how to read their contents is a good next step. There are two ways to reference a value stored in a vector. In the examples, we&amp;rsquo;ve annotated the types of the values that are returned from these functions for extra clarity.</source>
          <target state="translated">이제 벡터를 생성, 업데이트 및 제거하는 방법을 알았으므로 내용을 읽는 방법을 아는 것이 좋은 다음 단계입니다. 벡터에 저장된 값을 참조하는 두 가지 방법이 있습니다. 이 예에서는 추가 기능을 위해 이러한 함수에서 반환되는 값 유형에 주석을 달았습니다.</target>
        </trans-unit>
        <trans-unit id="81f4f18161b98344a0f7e41a60ca860036728be7" translate="yes" xml:space="preserve">
          <source>Now that you know how to define and implement traits, we can explore how to use traits to define functions that accept many different types.</source>
          <target state="translated">특성을 정의하고 구현하는 방법을 배웠으므로 특성을 사용하여 다양한 유형을 허용하는 함수를 정의하는 방법을 살펴볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abb4d086b7b2c677929b00ae06d7123ecd180a15" translate="yes" xml:space="preserve">
          <source>Now that you know how to specify the behavior you want to use using the generic type parameter&amp;rsquo;s bounds, let&amp;rsquo;s return to Listing 10-5 to fix the definition of the &lt;code&gt;largest&lt;/code&gt; function that uses a generic type parameter! Last time we tried to run that code, we received this error:</source>
          <target state="translated">제네릭 형식 매개 변수의 경계를 사용하여 사용하려는 동작을 지정하는 방법을 알았으므로 제 10-5 장으로 돌아가서 제네릭 형식 매개 변수를 사용하는 &lt;code&gt;largest&lt;/code&gt; 함수 의 정의를 수정 해 봅시다 ! 지난번에 코드를 실행하려고 할 때 다음 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="e396981103292f81034753c73fe592831d9392a8" translate="yes" xml:space="preserve">
          <source>Now that you know several ways to write tests, let&amp;rsquo;s look at what is happening when we run our tests and explore the different options we can use with &lt;code&gt;cargo test&lt;/code&gt;.</source>
          <target state="translated">테스트를 작성하는 몇 가지 방법을 알았으므로 테스트를 실행할 때 발생하는 상황을 살펴보고 &lt;code&gt;cargo test&lt;/code&gt; 사용할 수있는 다양한 옵션을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="e62f4573546a99a0fd5e85dde630775910ab5fc8" translate="yes" xml:space="preserve">
          <source>Now that you know where the lifetimes of references are and how Rust analyzes lifetimes to ensure references will always be valid, let&amp;rsquo;s explore generic lifetimes of parameters and return values in the context of functions.</source>
          <target state="translated">참조의 수명이 어디인지, Rust가 수명을 분석하여 참조가 항상 유효한지 확인한 후, 함수의 맥락에서 파라미터의 일반적인 수명과 값을 반환 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="30a6477678dd7180d7e0d481486280f7e98fefae" translate="yes" xml:space="preserve">
          <source>Now that you know where to use patterns and the difference between refutable and irrefutable patterns, let&amp;rsquo;s cover all the syntax we can use to create patterns.</source>
          <target state="translated">패턴을 사용할 위치와 반박 가능 패턴과 반박 불가능 패턴의 차이점을 알았으므로 패턴을 만드는 데 사용할 수있는 모든 구문을 다루겠습니다.</target>
        </trans-unit>
        <trans-unit id="31528a068a5d3a841cff61741fee15a1c0b2479f" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve added the &lt;code&gt;rand&lt;/code&gt; crate to &lt;em&gt;Cargo.toml&lt;/em&gt;, let&amp;rsquo;s start using &lt;code&gt;rand&lt;/code&gt;. The next step is to update &lt;em&gt;src/main.rs&lt;/em&gt;, as shown in Listing 2-3.</source>
          <target state="translated">&lt;code&gt;rand&lt;/code&gt; 상자를 &lt;em&gt;Cargo.toml에&lt;/em&gt; 추가 &lt;em&gt;했으므로 &lt;/em&gt; &lt;code&gt;rand&lt;/code&gt; 사용을 시작하겠습니다 . 다음 단계는 Listing 2-3과 같이 &lt;em&gt;src / main.rs&lt;/em&gt; 를 업데이트하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="25f40b5e485b1b15ed8e4d216ebb9b698b979c06" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve created an account, saved your API token, chosen a name for your crate, and specified the required metadata, you&amp;rsquo;re ready to publish! Publishing a crate uploads a specific version to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; for others to use.</source>
          <target state="translated">계정을 만들고 API 토큰을 저장하고 상자 이름을 선택하고 필요한 메타 데이터를 지정 했으므로 게시 할 준비가되었습니다! 상자를 게시하면 다른 사람들이 사용할 수 있도록 특정 버전이 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; 에 업로드 됩니다.</target>
        </trans-unit>
        <trans-unit id="920c59c826e17db818f515c07dfec7c798d59ee0" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve installed Rust, let&amp;rsquo;s write your first Rust program. It&amp;rsquo;s traditional when learning a new language to write a little program that prints the text &lt;code&gt;Hello, world!&lt;/code&gt; to the screen, so we&amp;rsquo;ll do the same here!</source>
          <target state="translated">Rust를 설치 했으니 이제 첫 번째 Rust 프로그램을 작성해 봅시다. 텍스트를 인쇄하는 작은 프로그램을 작성하는 새로운 언어를 배우는 것은 전통적 &lt;code&gt;Hello, world!&lt;/code&gt; 화면에 표시되므로 여기서도 동일하게 수행합니다!</target>
        </trans-unit>
        <trans-unit id="da83ac95984492a0d09f569c59cd96503f2138e1" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen how to use &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, let&amp;rsquo;s dig into how it works!</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 사용법을 살펴 보았으니 작동 방식에 대해 알아 보자!</target>
        </trans-unit>
        <trans-unit id="3226e5056b022a9871764bceba61de34cf95da11" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen useful ways that the standard library uses generics with the &lt;code&gt;Option&lt;/code&gt; and &lt;code&gt;Result&lt;/code&gt; enums, we&amp;rsquo;ll talk about how generics work and how you can use them in your code.</source>
          <target state="translated">표준 라이브러리가 &lt;code&gt;Option&lt;/code&gt; 및 &lt;code&gt;Result&lt;/code&gt; 열거 형 과 함께 제네릭을 사용하는 유용한 방법을 살펴 보았 으므로 제네릭이 작동하는 방식과 코드에서 제네릭을 사용하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c62551adf3df866d6c2e2a8e1a359461a03ffa45" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen what the test results look like in different scenarios, let&amp;rsquo;s look at some macros other than &lt;code&gt;panic!&lt;/code&gt; that are useful in tests.</source>
          <target state="translated">다양한 시나리오에서 테스트 결과가 어떻게 보이는지 살펴 봤으니, &lt;code&gt;panic!&lt;/code&gt; 이외의 매크로를 살펴 보자 ! 테스트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b7ef50d26b9af16e9b7dc94b8c74f1d0f89a5d4f" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks only return the appropriate values for the status line and filename in a tuple; we then use destructuring to assign these two values to &lt;code&gt;status_line&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; using a pattern in the &lt;code&gt;let&lt;/code&gt; statement, as discussed in Chapter 18.</source>
          <target state="translated">이제 &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 블록은 튜플에서 상태 행과 파일 이름에 적절한 값만 반환합니다. 그런 다음 18 장에서 논의한 것처럼 &lt;code&gt;let&lt;/code&gt; 문 에서 패턴 을 사용하여 destructuring을 사용 &lt;code&gt;status_line&lt;/code&gt; 두 값을 status_line 및 &lt;code&gt;filename&lt;/code&gt; 에 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="4c7125187714db67fed394d49d485e2e00abd4cb" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;search&lt;/code&gt; function should return only the lines that contain &lt;code&gt;query&lt;/code&gt;, and our test should pass. Let&amp;rsquo;s run the test:</source>
          <target state="translated">이제 &lt;code&gt;search&lt;/code&gt; 함수는 &lt;code&gt;query&lt;/code&gt; 가 포함 된 행만 반환 해야하며 테스트는 통과해야합니다. 테스트를 실행 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="522023e5be1135a608b1cd7f8c8337b4cfc43235" translate="yes" xml:space="preserve">
          <source>Now the code will compile! Let&amp;rsquo;s look at the absolute and the relative path and double-check why adding the &lt;code&gt;pub&lt;/code&gt; keyword lets us use these paths in &lt;code&gt;add_to_waitlist&lt;/code&gt; with respect to the privacy rules.</source>
          <target state="translated">이제 코드가 컴파일됩니다! 절대 경로와 상대 경로를 살펴보고 &lt;code&gt;pub&lt;/code&gt; 키워드를 추가 하여 개인 정보 규칙과 관련하여 &lt;code&gt;add_to_waitlist&lt;/code&gt; 에서 이러한 경로를 사용할 수 있는 이유를 다시 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b0d5ba9ad57069914ace4b7ba7c228161663abb" translate="yes" xml:space="preserve">
          <source>Now the entire program should work! Let&amp;rsquo;s try it out, first with a word that should return exactly one line from the Emily Dickinson poem, &amp;ldquo;frog&amp;rdquo;:</source>
          <target state="translated">이제 전체 프로그램이 작동합니다! Emily Dickinson의시에서 정확히 한 줄을 돌려 보내야하는 단어로 먼저 시도해 보도록하겠습니다.</target>
        </trans-unit>
        <trans-unit id="acdcf552dc404df4d014e75904c60498b68c4c55" translate="yes" xml:space="preserve">
          <source>Now the error occurs because we don&amp;rsquo;t have an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt;. Recall from the &lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&amp;ldquo;Creating a Similar Interface for a Finite Number of Threads&amp;rdquo;&lt;/a&gt; section that we decided our thread pool should have an interface similar to &lt;code&gt;thread::spawn&lt;/code&gt;. In addition, we&amp;rsquo;ll implement the &lt;code&gt;execute&lt;/code&gt; function so it takes the closure it&amp;rsquo;s given and gives it to an idle thread in the pool to run.</source>
          <target state="translated">이제 &lt;code&gt;ThreadPool&lt;/code&gt; 에 &lt;code&gt;execute&lt;/code&gt; 메서드 가 없기 때문에 오류가 발생합니다 . 스레드 풀이 &lt;code&gt;thread::spawn&lt;/code&gt; 과 유사한 인터페이스를 가져야한다고 결정한 &lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&quot;유한 한 수의 스레드를위한 유사한 인터페이스 생성&quot;&lt;/a&gt; 섹션을 떠올려 보십시오 . 추가로 우리는 주어진 클로저를 받아 풀의 유휴 스레드에 제공하도록 &lt;code&gt;execute&lt;/code&gt; 함수를 구현할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="14d34886bdb2d79a108c1eb310a74fea56db9de1" translate="yes" xml:space="preserve">
          <source>Now the expensive calculation is called in only one place, and we&amp;rsquo;re only executing that code where we need the results.</source>
          <target state="translated">이제 비싼 계산은 한 곳에서만 호출되며 결과가 필요한 곳에서만 해당 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="e22993365c1cb308452dac73cf5565235b2c67e8" translate="yes" xml:space="preserve">
          <source>Now the program is getting interesting! There&amp;rsquo;s a lot going on in this little line. Notice that this is a &lt;code&gt;let&lt;/code&gt; statement, which is used to create a &lt;em&gt;variable&lt;/em&gt;. Here&amp;rsquo;s another example:</source>
          <target state="translated">이제 프로그램이 재미있어지고 있습니다! 이 작은 줄에는 많은 일이 일어나고 있습니다. 이것은 &lt;code&gt;let&lt;/code&gt; 문이며 &lt;em&gt;변수&lt;/em&gt; 를 만드는 데 사용됩니다 . 또 다른 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b5e26741b88a54ad8284d61f9e2e51ca7f82268" translate="yes" xml:space="preserve">
          <source>Now the signature indicates that the function data borrowed from either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;. Alternatively, you could change the body to not return data from &lt;code&gt;y&lt;/code&gt;:</source>
          <target state="translated">이제 서명은 함수 데이터가 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 에서 빌려 왔음을 나타냅니다 . 또는 &lt;code&gt;y&lt;/code&gt; 에서 데이터를 반환하지 않도록 본문을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1198ca2a8c86240e1af84c3d28743f89fded1ad" translate="yes" xml:space="preserve">
          <source>Now we can start seeing the advantages of the state pattern: the &lt;code&gt;request_review&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt; is the same no matter its &lt;code&gt;state&lt;/code&gt; value. Each state is responsible for its own rules.</source>
          <target state="translated">이제 상태 패턴의 장점을 볼 수 있습니다 . &lt;code&gt;Post&lt;/code&gt; 의 &lt;code&gt;request_review&lt;/code&gt; 메소드 는 &lt;code&gt;state&lt;/code&gt; 값에 관계없이 동일 합니다. 각 주마다 자체 규칙에 대한 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ea1cd6e6626b68365f6c8947fa55d16ff141954" translate="yes" xml:space="preserve">
          <source>Now we get a warning and an error. Ignoring the warning for a moment, the error occurs because we don&amp;rsquo;t have an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt;. Recall from the &lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&amp;ldquo;Creating a Similar Interface for a Finite Number of Threads&amp;rdquo;&lt;/a&gt; section that we decided our thread pool should have an interface similar to &lt;code&gt;thread::spawn&lt;/code&gt;. In addition, we&amp;rsquo;ll implement the &lt;code&gt;execute&lt;/code&gt; function so it takes the closure it&amp;rsquo;s given and gives it to an idle thread in the pool to run.</source>
          <target state="translated">이제 경고와 오류가 발생합니다. 경고를 잠시 무시하면 &lt;code&gt;ThreadPool&lt;/code&gt; 에 &lt;code&gt;execute&lt;/code&gt; 메소드 가 없으므로 오류가 발생합니다 . 로부터 호출 &lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&quot;스레드의 유한 수의 비슷한 인터페이스를 만들기&quot;&lt;/a&gt; 우리가 우리의 스레드 풀과 유사한 인터페이스가 있어야 결정했다고 섹션 &lt;code&gt;thread::spawn&lt;/code&gt; . 또한 &lt;code&gt;execute&lt;/code&gt; 함수를 구현하여 주어진 클로저를 가져 와서 풀의 유휴 스레드에 실행을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d7705a7f1894fbc9d3a536be0dfea4d6af32a807" translate="yes" xml:space="preserve">
          <source>Now we need to bring the code we moved to &lt;em&gt;src/lib.rs&lt;/em&gt; into the scope of the binary crate in &lt;em&gt;src/main.rs&lt;/em&gt;, as shown in Listing 12-14.</source>
          <target state="translated">이제 &lt;em&gt;src / lib.rs&lt;/em&gt; 로 옮긴 코드를 &lt;em&gt;src / main.rs&lt;/em&gt; 의 바이너리 크레이트 범위로 &lt;em&gt;가져와야한다 (&lt;/em&gt; 목록 12-14 참조).</target>
        </trans-unit>
        <trans-unit id="b54fd4c3b5f78dc6afcacc14a208e5f25a781f43" translate="yes" xml:space="preserve">
          <source>Now we need to update the &lt;code&gt;content&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt;: if the state is &lt;code&gt;Published&lt;/code&gt;, we want to return the value in the post&amp;rsquo;s &lt;code&gt;content&lt;/code&gt; field; otherwise, we want to return an empty string slice, as shown in Listing 17-17:</source>
          <target state="translated">이제 &lt;code&gt;Post&lt;/code&gt; 에서 &lt;code&gt;content&lt;/code&gt; 메소드 를 업데이트해야 합니다. 상태가 &lt;code&gt;Published&lt;/code&gt; 이면 포스트의 &lt;code&gt;content&lt;/code&gt; 필드에 값을 리턴하려고 합니다. 그렇지 않으면 Listing 17-17에 표시된 것처럼 빈 문자열 슬라이스를 리턴하려고한다.</target>
        </trans-unit>
        <trans-unit id="6174f1c624d6e6d6e079aee3674396394f363d5b" translate="yes" xml:space="preserve">
          <source>Now we see the error onscreen and &lt;em&gt;output.txt&lt;/em&gt; contains nothing, which is the behavior we expect of command line programs.</source>
          <target state="translated">이제 화면에 오류가 있고 &lt;em&gt;output.txt&lt;/em&gt; 에 아무것도 포함되어 있지 않습니다. 이는 명령 행 프로그램에서 예상되는 동작입니다.</target>
        </trans-unit>
        <trans-unit id="cdda59c39165af59e97381c7390ecfef3d12a8f6" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll add functionality to read the file that is specified in the &lt;code&gt;filename&lt;/code&gt; command line argument. First, we need a sample file to test it with: the best kind of file to use to make sure &lt;code&gt;minigrep&lt;/code&gt; is working is one with a small amount of text over multiple lines with some repeated words. Listing 12-3 has an Emily Dickinson poem that will work well! Create a file called &lt;em&gt;poem.txt&lt;/em&gt; at the root level of your project, and enter the poem &amp;ldquo;I&amp;rsquo;m Nobody! Who are you?&amp;rdquo;</source>
          <target state="translated">이제 &lt;code&gt;filename&lt;/code&gt; 명령 줄 인수에 지정된 파일을 읽는 기능을 추가하겠습니다 . 먼저 테스트 할 샘플 파일이 필요합니다. &lt;code&gt;minigrep&lt;/code&gt; 이 작동 하는지 확인하는 데 사용할 수있는 최상의 파일 유형은 반복되는 단어가 여러 줄에 걸쳐 적은 양의 텍스트가있는 파일입니다. 리스팅 12-3에는 잘 작동하는 Emily Dickinson 시가있다! 프로젝트의 루트 수준에서 &lt;em&gt;poem.txt&lt;/em&gt; 라는 파일을 &lt;em&gt;만들고&lt;/em&gt; &amp;ldquo;I 'm Nobody! 누구세요?&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="dd1d31103e62a1ec520be0bcddbbbdb89e976849" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll add some types that implement the &lt;code&gt;Draw&lt;/code&gt; trait. We&amp;rsquo;ll provide the &lt;code&gt;Button&lt;/code&gt; type. Again, actually implementing a GUI library is beyond the scope of this book, so the &lt;code&gt;draw&lt;/code&gt; method won&amp;rsquo;t have any useful implementation in its body. To imagine what the implementation might look like, a &lt;code&gt;Button&lt;/code&gt; struct might have fields for &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt;, as shown in Listing 17-7:</source>
          <target state="translated">이제 &lt;code&gt;Draw&lt;/code&gt; 특성 을 구현하는 몇 가지 유형을 추가하겠습니다 . &lt;code&gt;Button&lt;/code&gt; 유형을 제공하겠습니다 . 다시 말하지만 실제로 GUI 라이브러리를 구현하는 것은이 책의 범위를 벗어나므로 &lt;code&gt;draw&lt;/code&gt; 메소드에는 유용한 구현이 없습니다. 구현이 어떻게 생겼는지 상상하기 위해, &lt;code&gt;Button&lt;/code&gt; struct 에는 Listing 17-7에 표시된 것처럼 &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; 및 &lt;code&gt;label&lt;/code&gt; 필드가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e57698dd0ca960cc0b20cbcaaf7560d2276dfedc" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll implement sending data in response to a client request. Responses have the following format:</source>
          <target state="translated">이제 클라이언트 요청에 대한 응답으로 데이터 전송을 구현합니다. 응답의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="faa7223d94f8959f76182c7251992c3581bab825" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll implement the &lt;code&gt;Drop&lt;/code&gt; trait to call &lt;code&gt;join&lt;/code&gt; on each of the threads in the pool so they can finish the requests they&amp;rsquo;re working on before closing. Then we&amp;rsquo;ll implement a way to tell the threads they should stop accepting new requests and shut down. To see this code in action, we&amp;rsquo;ll modify our server to accept only two requests before gracefully shutting down its thread pool.</source>
          <target state="translated">이제 &lt;code&gt;Drop&lt;/code&gt; 특성을 구현하여 풀의 각 스레드에서 &lt;code&gt;join&lt;/code&gt; 을 호출 하여 처리 전에 요청을 완료 할 수 있도록합니다. 그런 다음 스레드에 새 요청 수락을 중지하고 종료해야한다는 것을 알리는 방법을 구현합니다. 이 코드가 실제로 작동하는지 확인하기 위해 스레드 풀을 정상적으로 종료하기 전에 두 개의 요청 만 수락하도록 서버를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="f36ce7a9b5e2c1e7eedfaeab844cfb65b78a49c0" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll tackle the problem that the closures given to &lt;code&gt;thread::spawn&lt;/code&gt; do absolutely nothing. Currently, we get the closure we want to execute in the &lt;code&gt;execute&lt;/code&gt; method. But we need to give &lt;code&gt;thread::spawn&lt;/code&gt; a closure to run when we create each &lt;code&gt;Worker&lt;/code&gt; during the creation of the &lt;code&gt;ThreadPool&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;thread::spawn&lt;/code&gt; 주어진 클로저 가 아무 것도하지 않는 문제를 해결해 보겠습니다 . 현재 우리는 &lt;code&gt;execute&lt;/code&gt; 메소드 에서 실행하려는 클로저를 얻습니다 . 그러나 &lt;code&gt;ThreadPool&lt;/code&gt; 을 만드는 동안 각 &lt;code&gt;Worker&lt;/code&gt; 를 만들 때 &lt;code&gt;thread::spawn&lt;/code&gt; 에 클로저 를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0ff72d33ea4877ceb607d0497b7819ecb5fe8345" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll work on fixing our error handling. Recall that attempting to access the values in the &lt;code&gt;args&lt;/code&gt; vector at index 1 or index 2 will cause the program to panic if the vector contains fewer than three items. Try running the program without any arguments; it will look like this:</source>
          <target state="translated">이제 오류 처리 문제를 해결해 보겠습니다. 인덱스 1 또는 인덱스 2에서 &lt;code&gt;args&lt;/code&gt; 벡터 의 값에 액세스하려고하면 벡터에 3 개 미만의 항목이 포함 된 경우 프로그램이 패닉 상태가됩니다. 인수없이 프로그램을 실행하십시오. 다음과 같이 보일 것입니다 :</target>
        </trans-unit>
        <trans-unit id="13208408fb234a6274c662e0cea2839eb0d4df4f" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;re tracking a starting &lt;em&gt;and&lt;/em&gt; an ending index, and we have even more values that were calculated from data in a particular state but aren&amp;rsquo;t tied to that state at all. We now have three unrelated variables floating around that need to be kept in sync.</source>
          <target state="translated">이제 시작 &lt;em&gt;및&lt;/em&gt; 끝 색인을 추적하고 있으며 특정 상태의 데이터에서 계산되었지만 해당 상태와 전혀 관련이없는 더 많은 값이 있습니다. 우리는 이제 세 개의 관련없는 변수들이 떠다니며 동기화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e2c6d85ff7e11c55ebfacf4a5ea15b76883f9037" translate="yes" xml:space="preserve">
          <source>Now when we call &lt;code&gt;first_word&lt;/code&gt;, we get back a single value that is tied to the underlying data. The value is made up of a reference to the starting point of the slice and the number of elements in the slice.</source>
          <target state="translated">이제 &lt;code&gt;first_word&lt;/code&gt; 를 호출 하면 기본 데이터와 연결된 단일 값을 다시 얻습니다. 이 값은 슬라이스의 시작점과 슬라이스의 요소 수에 대한 참조로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="ae56f18fed45d04e5e1b1341584607fec330d0c6" translate="yes" xml:space="preserve">
          <source>Now when we run the program, we won&amp;rsquo;t get any errors, and we&amp;rsquo;ll see the following output:</source>
          <target state="translated">이제 프로그램을 실행할 때 오류가 발생하지 않으며 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a1e40e49d7c93a75ee26e23465f603f6bbef3e57" translate="yes" xml:space="preserve">
          <source>Now when we run the test, we&amp;rsquo;ll get a more informative error message:</source>
          <target state="translated">이제 테스트를 실행하면보다 유익한 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="77f2a1a56e2b0bc8d28e09777d58b6d63d25bdc8" translate="yes" xml:space="preserve">
          <source>Now you know how the newtype pattern is used in relation to traits; it&amp;rsquo;s also a useful pattern even when traits are not involved. Let&amp;rsquo;s switch focus and look at some advanced ways to interact with Rust&amp;rsquo;s type system.</source>
          <target state="translated">이제 새 특성 패턴이 특성과 관련하여 어떻게 사용되는지 알았습니다. 특성이 관련되지 않은 경우에도 유용한 패턴입니다. 포커스를 전환하고 Rust의 유형 시스템과 상호 작용하는 고급 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="698e184c44b77b78a4f0259358fd0568a9ef42f1" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;foo()&lt;/code&gt; can no longer be called on a trait object, but you will now be allowed to make a trait object, and that will be able to call any object-safe methods. With such a bound, one can still call &lt;code&gt;foo()&lt;/code&gt; on types implementing that trait that aren't behind trait objects.</source>
          <target state="translated">이제는 trait 객체 에서 &lt;code&gt;foo()&lt;/code&gt; 를 더 이상 호출 할 수 없지만 이제는 trait 객체를 만들 수 있으며 객체 안전 메서드를 호출 할 수 있습니다. 그러한 바운드를 사용하면 특성 객체 뒤에없는 특성을 구현하는 유형에서 여전히 &lt;code&gt;foo()&lt;/code&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2eab767e7fabf7d41783d8a69e9cbea73a62c87" translate="yes" xml:space="preserve">
          <source>Now, every time you call &lt;code&gt;rustc&lt;/code&gt; or &lt;code&gt;cargo&lt;/code&gt; inside of &lt;em&gt;~/projects/needs-nightly&lt;/em&gt;, &lt;code&gt;rustup&lt;/code&gt; will make sure that you are using nightly Rust, rather than your default of stable Rust. This comes in handy when you have a lot of Rust projects!</source>
          <target state="translated">이제 때마다 당신이 전화 &lt;code&gt;rustc&lt;/code&gt; 또는 &lt;code&gt;cargo&lt;/code&gt; 의 내부 &lt;em&gt;~ / 프로젝트 / 요구 - 야간&lt;/em&gt; , &lt;code&gt;rustup&lt;/code&gt; 은 오히려 안정 녹의 기본보다, 야간 녹를 사용하고 있는지 확인합니다. Rust 프로젝트가 많을 때 편리합니다!</target>
        </trans-unit>
        <trans-unit id="e79236607753f413c66ac854a24fa640c09a981f" translate="yes" xml:space="preserve">
          <source>Now, if we have the following code:</source>
          <target state="translated">이제 다음 코드가 있다면 :</target>
        </trans-unit>
        <trans-unit id="8bfc390ee5863dbfd9bc2b1fac71150d32bafb63" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s try to share a value between multiple threads using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;. We&amp;rsquo;ll spin up 10 threads and have them each increment a counter value by 1, so the counter goes from 0 to 10. Note that the next few examples will have compiler errors, and we&amp;rsquo;ll use those errors to learn more about using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and how Rust helps us use it correctly. Listing 16-13 has our starting example:</source>
          <target state="translated">이제 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 사용하여 여러 스레드간에 값을 공유해 봅시다 . 우리는 10 개의 스레드를 회전시키고 각각의 카운터 값을 1 씩 증가 시키도록합니다. 따라서 카운터는 0에서 10으로갑니다. 다음 몇 가지 예제에는 컴파일러 오류가있을 것입니다. &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 와 Rust가 올바르게 사용하는 방법 Listing 16-13에는 시작 예제가있다.</target>
        </trans-unit>
        <trans-unit id="12a0ede889bbdab76f8ecdca9c8b3f108a1224a8" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s try to share a value between multiple threads using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;. We&amp;rsquo;ll spin up 10 threads and have them each increment a counter value by 1, so the counter goes from 0 to 10. The next example in Listing 16-13 will have a compiler error, and we&amp;rsquo;ll use that error to learn more about using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and how Rust helps us use it correctly.</source>
          <target state="translated">이제 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 사용하여 여러 스레드간에 값을 공유해 보겠습니다 . 10 개의 스레드를 스핀 업하고 각각 카운터 값을 1 씩 증가 시키도록 할 것입니다. 따라서 카운터는 0에서 10으로 이동합니다. 목록 16-13의 다음 예제에는 컴파일러 오류가 있으며이 오류를 사용하여 학습 할 것입니다. &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 사용에 대한 자세한 내용 과 Rust가이를 올바르게 사용하는 데 어떻게 도움이되는지 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="4684dc088b34ae2083e2057208489a24262c5c09" translate="yes" xml:space="preserve">
          <source>Now, run this program using &lt;code&gt;cargo run&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;cargo run&lt;/code&gt; 사용하여이 프로그램을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f63a9b785af57bd0365b9cf3f0ad0d87a3314b8" translate="yes" xml:space="preserve">
          <source>Now, the alias &lt;code&gt;Kilometers&lt;/code&gt; is a &lt;em&gt;synonym&lt;/em&gt; for &lt;code&gt;i32&lt;/code&gt;; unlike the &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt; types we created in Listing 19-15, &lt;code&gt;Kilometers&lt;/code&gt; is not a separate, new type. Values that have the type &lt;code&gt;Kilometers&lt;/code&gt; will be treated the same as values of type &lt;code&gt;i32&lt;/code&gt;:</source>
          <target state="translated">별명 &lt;code&gt;Kilometers&lt;/code&gt; 는 &lt;code&gt;i32&lt;/code&gt; 의 &lt;em&gt;동의어&lt;/em&gt; 입니다 . 목록 19-15에서 만든 &lt;code&gt;Millimeters&lt;/code&gt; 및 &lt;code&gt;Meters&lt;/code&gt; 유형 과 달리 &lt;code&gt;Kilometers&lt;/code&gt; 는 별도의 새로운 유형이 아닙니다. 타입이 값 &lt;code&gt;Kilometers&lt;/code&gt; 타입의 값과 동일하게 취급한다 &lt;code&gt;i32&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="89254150c2be7dc87d0a9f78d979708d51af3c47" translate="yes" xml:space="preserve">
          <source>Now, we can go further. Here are some erroneous code examples:</source>
          <target state="translated">이제 더 나아갈 수 있습니다. 다음은 잘못된 코드 예입니다.</target>
        </trans-unit>
        <trans-unit id="0a10d92135d2873e2b02f8fce9c6f1692a0cbb60" translate="yes" xml:space="preserve">
          <source>Now, we can use &lt;code&gt;?&lt;/code&gt; instead of &lt;code&gt;match&lt;/code&gt;, and the return type makes a lot more sense: if the loop ever stops, it means that an error occurred. We don't even have to wrap the loop in an &lt;code&gt;Ok&lt;/code&gt; because &lt;code&gt;!&lt;/code&gt; coerces to &lt;code&gt;Result&amp;lt;!, ConnectionError&amp;gt;&lt;/code&gt; automatically.</source>
          <target state="translated">이제 사용할 수 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;match&lt;/code&gt; 대신 반환 유형이 훨씬 더 의미가 있습니다. 루프가 중지되면 오류가 발생했음을 의미합니다. 우리는 심지어에서 루프를 포장하지 않아도 &lt;code&gt;Ok&lt;/code&gt; 하기 때문에 &lt;code&gt;!&lt;/code&gt; &lt;code&gt;Result&amp;lt;!, ConnectionError&amp;gt;&lt;/code&gt; 자동 강제 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="00574ee534bf3b794cc8e985f367f79be7646f65" translate="yes" xml:space="preserve">
          <source>Now, when the server disconnects, we exit the loop with an error instead of panicking. While it might be intuitive to simply return the error, we might want to wrap it in a &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">이제 서버 연결이 끊어지면 당황하지 않고 오류와 함께 루프를 종료합니다. 단순히 오류를 반환하는 것이 직관적 일 수도 있지만 대신 &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt; &lt;/a&gt; 로 래핑 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63f5d491af12e32408bf602e1dfb4af7a20ca44f" translate="yes" xml:space="preserve">
          <source>Now, without changing any of the code, let&amp;rsquo;s build the project, as shown in Listing 2-2.</source>
          <target state="translated">이제 코드를 변경하지 않고 Listing 2-2와 같이 프로젝트를 빌드하자.</target>
        </trans-unit>
        <trans-unit id="335506e2ff8a4e3e39e5a5e2b3fc6bf1463c0bb5" translate="yes" xml:space="preserve">
          <source>Now, you get all of the default values. Rust implements &lt;code&gt;Default&lt;/code&gt; for various primitives types.</source>
          <target state="translated">이제 모든 기본값을 얻습니다. Rust 는 다양한 프리미티브 유형에 대해 &lt;code&gt;Default&lt;/code&gt; 을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="019a7808328d4c7ef510130b49858e7cc7a93df4" translate="yes" xml:space="preserve">
          <source>NulError</source>
          <target state="translated">NulError</target>
        </trans-unit>
        <trans-unit id="0cb22fef16057827ecc4973a05f1f48159ecfb08" translate="yes" xml:space="preserve">
          <source>NulError::borrow</source>
          <target state="translated">NulError::borrow</target>
        </trans-unit>
        <trans-unit id="093c6ad11b2674276a386aef18e019c41e18c73d" translate="yes" xml:space="preserve">
          <source>NulError::borrow_mut</source>
          <target state="translated">NulError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2212c8b5028758465c03e3f70e4f2b53155ddf4f" translate="yes" xml:space="preserve">
          <source>NulError::cause</source>
          <target state="translated">NulError::cause</target>
        </trans-unit>
        <trans-unit id="29768f5bfd32a963dcb296b9cb20f40a82c74df5" translate="yes" xml:space="preserve">
          <source>NulError::clone</source>
          <target state="translated">NulError::clone</target>
        </trans-unit>
        <trans-unit id="11102afce6dc8292dc39655665283f8191fb13f1" translate="yes" xml:space="preserve">
          <source>NulError::clone_from</source>
          <target state="translated">NulError::clone_from</target>
        </trans-unit>
        <trans-unit id="f533f8602af54aaa16eff696d1575d42e14848a1" translate="yes" xml:space="preserve">
          <source>NulError::clone_into</source>
          <target state="translated">NulError::clone_into</target>
        </trans-unit>
        <trans-unit id="dbdb7cc3a8e4e6691a99909b0fc53de13cd8f2d3" translate="yes" xml:space="preserve">
          <source>NulError::description</source>
          <target state="translated">NulError::description</target>
        </trans-unit>
        <trans-unit id="90a567cb98b0dcdd50aff9ea97e9fff9eaab566d" translate="yes" xml:space="preserve">
          <source>NulError::eq</source>
          <target state="translated">NulError::eq</target>
        </trans-unit>
        <trans-unit id="5a4bafcb93f1795790aaa47109d1e73bf1dc48ee" translate="yes" xml:space="preserve">
          <source>NulError::fmt</source>
          <target state="translated">NulError::fmt</target>
        </trans-unit>
        <trans-unit id="fea70f345cef208acafc3c691d14a34ddbaffb2c" translate="yes" xml:space="preserve">
          <source>NulError::from</source>
          <target state="translated">NulError::from</target>
        </trans-unit>
        <trans-unit id="c667a60cc8a552cdd2774d6820e70ba3a6f7fa11" translate="yes" xml:space="preserve">
          <source>NulError::into</source>
          <target state="translated">NulError::into</target>
        </trans-unit>
        <trans-unit id="30b7683d9cdd43993a6fc1126ff7ee715887f7b2" translate="yes" xml:space="preserve">
          <source>NulError::into_vec</source>
          <target state="translated">NulError::into_vec</target>
        </trans-unit>
        <trans-unit id="0a051a00c0c437269ea80583c284491216e4bda7" translate="yes" xml:space="preserve">
          <source>NulError::ne</source>
          <target state="translated">NulError::ne</target>
        </trans-unit>
        <trans-unit id="2853d8c78438f77254b0a497c86fde1fc17dc043" translate="yes" xml:space="preserve">
          <source>NulError::nul_position</source>
          <target state="translated">NulError::nul_position</target>
        </trans-unit>
        <trans-unit id="266ad98111087a4df9e19e655c096e1306270de2" translate="yes" xml:space="preserve">
          <source>NulError::source</source>
          <target state="translated">NulError::source</target>
        </trans-unit>
        <trans-unit id="5a34a4566a411696ebf16a2b9ec49441272c8c0b" translate="yes" xml:space="preserve">
          <source>NulError::to_owned</source>
          <target state="translated">NulError::to_owned</target>
        </trans-unit>
        <trans-unit id="657290a7e7bc42a0480eee65c34175ba47172560" translate="yes" xml:space="preserve">
          <source>NulError::to_string</source>
          <target state="translated">NulError::to_string</target>
        </trans-unit>
        <trans-unit id="d1202df6e66660732652af8ec880ff1ae89ff7c3" translate="yes" xml:space="preserve">
          <source>NulError::try_from</source>
          <target state="translated">NulError::try_from</target>
        </trans-unit>
        <trans-unit id="1d16960d944bfade9db6cf467b0e67afd7e5faaf" translate="yes" xml:space="preserve">
          <source>NulError::try_into</source>
          <target state="translated">NulError::try_into</target>
        </trans-unit>
        <trans-unit id="1f3e1c8599374779dd8128ca0f06731901b2e4e4" translate="yes" xml:space="preserve">
          <source>NulError::type_id</source>
          <target state="translated">NulError::type_id</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="a7321f8049c14a666fefc1ca42149346db408d7b" translate="yes" xml:space="preserve">
          <source>Null-unchecked version</source>
          <target state="translated">확인되지 않은 버전</target>
        </trans-unit>
        <trans-unit id="2276df81ba459368e74bc9d4361d3c8cfd09f1df" translate="yes" xml:space="preserve">
          <source>Nullable pointers</source>
          <target state="translated">널 입력 가능 포인터</target>
        </trans-unit>
        <trans-unit id="c25cad253b19d0908d73f07b038e8b9aad37e183" translate="yes" xml:space="preserve">
          <source>Number literals</source>
          <target state="translated">숫자 리터럴</target>
        </trans-unit>
        <trans-unit id="bcec75d4dad01d7ef8298e79673d17da682b5ff9" translate="yes" xml:space="preserve">
          <source>Number of significant digits in base 2.</source>
          <target state="translated">밑이 2 인 유효 자릿수</target>
        </trans-unit>
        <trans-unit id="2805eca363fc3f5bc17c10d2663c97e212a66b12" translate="yes" xml:space="preserve">
          <source>Number of significant digits in base 2. Use &lt;a href=&quot;../primitive.f32#associatedconstant.MANTISSA_DIGITS&quot;&gt;&lt;code&gt;f32::MANTISSA_DIGITS&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">2 진법의 유효 자릿수입니다 . 대신 &lt;a href=&quot;../primitive.f32#associatedconstant.MANTISSA_DIGITS&quot;&gt; &lt;code&gt;f32::MANTISSA_DIGITS&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="12801815bc7acefa87d6f150e6c4da3f8cfc4e2c" translate="yes" xml:space="preserve">
          <source>Number of significant digits in base 2. Use &lt;a href=&quot;../primitive.f64#associatedconstant.MANTISSA_DIGITS&quot;&gt;&lt;code&gt;f64::MANTISSA_DIGITS&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">2 진법의 유효 자릿수입니다 . 대신 &lt;a href=&quot;../primitive.f64#associatedconstant.MANTISSA_DIGITS&quot;&gt; &lt;code&gt;f64::MANTISSA_DIGITS&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="21e67f90f74a7a640f48c34557cd9804c3bb16bf" translate="yes" xml:space="preserve">
          <source>Numeric Operations</source>
          <target state="translated">숫자 연산</target>
        </trans-unit>
        <trans-unit id="46e7eddaee58aa04d38eef7cd137db7696751094" translate="yes" xml:space="preserve">
          <source>Numeric cast</source>
          <target state="translated">숫자 형 캐스트</target>
        </trans-unit>
        <trans-unit id="5fc7eba5de8d1ad8c7f788326b72adec568ef6c6" translate="yes" xml:space="preserve">
          <source>Numeric literal of specific type</source>
          <target state="translated">특정 유형의 숫자 ​​리터럴</target>
        </trans-unit>
        <trans-unit id="1569010f07b1014b3cf4df2495e2025b598353cd" translate="yes" xml:space="preserve">
          <source>Numeric type</source>
          <target state="translated">숫자 형</target>
        </trans-unit>
        <trans-unit id="d74de684582cb87f5abe203c6987280191b1e915" translate="yes" xml:space="preserve">
          <source>Numeric types</source>
          <target state="translated">숫자 형</target>
        </trans-unit>
        <trans-unit id="448f04fec46467e790879ea8707bb67f916a6de0" translate="yes" xml:space="preserve">
          <source>Numeric values used in this type don't have portable meanings, and different platforms may mask different amounts of them.</source>
          <target state="translated">이 유형에 사용 된 숫자 값은 이식 가능한 의미가 없으며 플랫폼에 따라 다른 양으로 가려 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c69dc5bbeb314ef78589c0047ce04c8e5006432" translate="yes" xml:space="preserve">
          <source>O(1)</source>
          <target state="translated">O(1)</target>
        </trans-unit>
        <trans-unit id="41a98fdd88fe9c4cdb77aa3ef162d2e340554b26" translate="yes" xml:space="preserve">
          <source>O(1)~</source>
          <target state="translated">O(1)~</target>
        </trans-unit>
        <trans-unit id="aae47a530dc867303fbce9c5d00c60595dd72df2" translate="yes" xml:space="preserve">
          <source>O(1)~*</source>
          <target state="translated">O(1)~*</target>
        </trans-unit>
        <trans-unit id="21c63d891edf29bd0dc5694a68dc0fe5e6523174" translate="yes" xml:space="preserve">
          <source>O(log n)</source>
          <target state="translated">O (로그 n)</target>
        </trans-unit>
        <trans-unit id="e74f9c141120b2be3e1dcb28f8561ddce1e8fcd1" translate="yes" xml:space="preserve">
          <source>O(log(n))</source>
          <target state="translated">O(log(n))</target>
        </trans-unit>
        <trans-unit id="eed5a0c9d789f93df61247fbcb2bb3a3c20ad0c2" translate="yes" xml:space="preserve">
          <source>O(m)*</source>
          <target state="translated">O(m)*</target>
        </trans-unit>
        <trans-unit id="0a498ed9d22d1c99ae0662d3eb2e582169c852e2" translate="yes" xml:space="preserve">
          <source>O(min(i, n-i))</source>
          <target state="translated">O (분 (i, ni))</target>
        </trans-unit>
        <trans-unit id="dede0f12fa78bfb74f3fa2188214d44df32644d9" translate="yes" xml:space="preserve">
          <source>O(min(i, n-i))*</source>
          <target state="translated">O (분 (i, ni)) *</target>
        </trans-unit>
        <trans-unit id="1eb19fcfc5873ac1d44e4d58ddd8518a66a4491a" translate="yes" xml:space="preserve">
          <source>O(n+m)</source>
          <target state="translated">O(n+m)</target>
        </trans-unit>
        <trans-unit id="c8fadbf37575cb84317acb6f8d4f3d46463f8753" translate="yes" xml:space="preserve">
          <source>O(n-i)</source>
          <target state="translated">O(n-i)</target>
        </trans-unit>
        <trans-unit id="cc8b4f2a60d0d1f3741e6ca4292cce74adf6d07a" translate="yes" xml:space="preserve">
          <source>O(n-i)*</source>
          <target state="translated">O(n-i)*</target>
        </trans-unit>
        <trans-unit id="40df041793dd78f66b71a0840b6daf38640d0a3a" translate="yes" xml:space="preserve">
          <source>OCT_DIGIT : [&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;7&lt;/code&gt;]</source>
          <target state="translated">OCT_DIGIT : &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;7&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="2458dc9d400f320af963a0c090896d1bb8a3eafb" translate="yes" xml:space="preserve">
          <source>OCT_LITERAL :</source>
          <target state="translated">OCT_LITERAL :</target>
        </trans-unit>
        <trans-unit id="7eefb54fc6fa85bcfd8cad8fd3e002943372f832" translate="yes" xml:space="preserve">
          <source>ONCE_INIT</source>
          <target state="translated">ONCE_INIT</target>
        </trans-unit>
        <trans-unit id="de8aa86286dbb8eb74d2748c7b6d4486d0458203" translate="yes" xml:space="preserve">
          <source>OS</source>
          <target state="translated">OS</target>
        </trans-unit>
        <trans-unit id="7367af2af477750e5937879b87fd589c058636c7" translate="yes" xml:space="preserve">
          <source>OS-specific behaviors</source>
          <target state="translated">OS 별 동작</target>
        </trans-unit>
        <trans-unit id="c616ed05e5cb0d4373e277ab3e8348ce34b627e9" translate="yes" xml:space="preserve">
          <source>OS-specific extensions to &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt;&lt;code&gt;fs::Metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.metadata&quot;&gt; &lt;code&gt;fs::Metadata&lt;/code&gt; &lt;/a&gt; 대한 OS 별 확장 .</target>
        </trans-unit>
        <trans-unit id="d40770bb8444e5820c3f38469b205f65cc11cae4" translate="yes" xml:space="preserve">
          <source>OS-specific functionality.</source>
          <target state="translated">OS 별 기능.</target>
        </trans-unit>
        <trans-unit id="a6c434024b24606a906b9f03f39592fffa3be309" translate="yes" xml:space="preserve">
          <source>OUTER_BLOCK_DOC :</source>
          <target state="translated">OUTER_BLOCK_DOC :</target>
        </trans-unit>
        <trans-unit id="0bb940376a39f5fb9ff8c9b1c3a635c5bc777eb9" translate="yes" xml:space="preserve">
          <source>OUTER_LINE_DOC :</source>
          <target state="translated">OUTER_LINE_DOC :</target>
        </trans-unit>
        <trans-unit id="497044c1c5d284e50b6c69945072ebc9add34281" translate="yes" xml:space="preserve">
          <source>Object Oriented Programming Features of Rust</source>
          <target state="translated">Rust의 객체 지향 프로그래밍 기능</target>
        </trans-unit>
        <trans-unit id="1cd60d3a8e30cd469c24d35e86095d88eed38ea9" translate="yes" xml:space="preserve">
          <source>Object Safety</source>
          <target state="translated">객체 안전</target>
        </trans-unit>
        <trans-unit id="907637cc210857e2030448d19632670732a6954a" translate="yes" xml:space="preserve">
          <source>Object Safety Is Required for Trait Objects</source>
          <target state="translated">특성 개체에 개체 안전이 필요합니다</target>
        </trans-unit>
        <trans-unit id="bca6b9d231b55a9e6e8a10f5e5322c009f386439" translate="yes" xml:space="preserve">
          <source>Object safe traits</source>
          <target state="translated">객체 안전 특성</target>
        </trans-unit>
        <trans-unit id="c0123c00fdac3367f93d574c1f48635a32708f0d" translate="yes" xml:space="preserve">
          <source>Object safe traits can be the base trait of a &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt;. A trait is &lt;em&gt;object safe&lt;/em&gt; if it has the following qualities (defined in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;RFC 255&lt;/a&gt;):</source>
          <target state="translated">개체 안전 특성은 &lt;a href=&quot;../types/trait-object&quot;&gt;특성 개체&lt;/a&gt; 의 기본 특성 일 수 있습니다 . 특성은 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;RFC 255에&lt;/a&gt; 정의 된 다음과 같은 특성이있는 경우 &lt;em&gt;객체 안전&lt;/em&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="23297e036939da16d72f8c944d8900bfb5bf3104" translate="yes" xml:space="preserve">
          <source>Object-oriented programming (OOP) is a way of modeling programs. Objects came from Simula in the 1960s. Those objects influenced Alan Kay&amp;rsquo;s programming architecture in which objects pass messages to each other. He coined the term &lt;em&gt;object-oriented programming&lt;/em&gt; in 1967 to describe this architecture. Many competing definitions describe what OOP is; some definitions would classify Rust as object oriented, but other definitions would not. In this chapter, we&amp;rsquo;ll explore certain characteristics that are commonly considered object oriented and how those characteristics translate to idiomatic Rust. We&amp;rsquo;ll then show you how to implement an object-oriented design pattern in Rust and discuss the trade-offs of doing so versus implementing a solution using some of Rust&amp;rsquo;s strengths instead.</source>
          <target state="translated">객체 지향 프로그래밍 (OOP)은 프로그램을 모델링하는 방법입니다. 개체는 1960 년대 Simula에서 나왔습니다. 이러한 개체는 개체가 서로 메시지를 전달하는 Alan Kay의 프로그래밍 아키텍처에 영향을 미쳤습니다. 그는 1967 년에 &lt;em&gt;객체 지향 프로그래밍&lt;/em&gt; 이라는 용어를 만들어이 아키텍처를 설명했습니다. 많은 경쟁 정의는 OOP가 무엇인지 설명합니다. 일부 정의는 Rust를 객체 지향으로 분류하지만 다른 정의는 그렇지 않습니다. 이 장에서는 일반적으로 객체 지향으로 간주되는 특정 특성과 이러한 특성이 관용적 녹으로 변환되는 방식을 살펴 봅니다. 그런 다음 Rust에서 객체 지향 디자인 패턴을 구현하는 방법을 보여주고 대신 Rust의 강점을 사용하여 솔루션을 구현하는 것과의 단점을 논의합니다.</target>
        </trans-unit>
        <trans-unit id="93a2f7998a1b0abd936ff0b0c2f570cbbedd6635" translate="yes" xml:space="preserve">
          <source>Object-oriented programs are made up of objects. An &lt;em&gt;object&lt;/em&gt; packages both data and the procedures that operate on that data. The procedures are typically called &lt;em&gt;methods&lt;/em&gt; or &lt;em&gt;operations&lt;/em&gt;.</source>
          <target state="translated">객체 지향 프로그램은 객체로 구성됩니다. &lt;em&gt;개체&lt;/em&gt; 패키지 데이터와 데이터에서 작동 절차. 절차를 일반적으로 &lt;em&gt;방법&lt;/em&gt; 또는 &lt;em&gt;작업&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="69fa88294fcaac54902a4347d53a07e91ef5771c" translate="yes" xml:space="preserve">
          <source>Objects Contain Data and Behavior</source>
          <target state="translated">객체는 데이터와 행동을 포함</target>
        </trans-unit>
        <trans-unit id="d206d3fa18be5581f351f10db48f9bf4a1014628" translate="yes" xml:space="preserve">
          <source>Objects that can be stepped over in both directions.</source>
          <target state="translated">양방향으로 걸을 수있는 물체.</target>
        </trans-unit>
        <trans-unit id="c6ec1c4f32b6ec8b2dd6c5acb228ddee1480f8b1" translate="yes" xml:space="preserve">
          <source>Objects that have a notion of &lt;em&gt;successor&lt;/em&gt; and &lt;em&gt;predecessor&lt;/em&gt; operations.</source>
          <target state="translated">&lt;em&gt;후속&lt;/em&gt; 작업 및 &lt;em&gt;선행&lt;/em&gt; 작업 의 개념이있는 개체입니다 .</target>
        </trans-unit>
        <trans-unit id="b899f01274e7bc44fb14d411dd765a15a7787c5f" translate="yes" xml:space="preserve">
          <source>Occasionally it may be desirable not to expose in an API that there is mutation happening &quot;under the hood&quot;. This may be because logically the operation is immutable, but e.g., caching forces the implementation to perform mutation; or because you must employ mutation to implement a trait method that was originally defined to take &lt;code&gt;&amp;amp;self&lt;/code&gt;.</source>
          <target state="translated">때때로 &quot;후드&quot;에서 발생하는 돌연변이가 API에 노출되지 않는 것이 바람직 할 수 있습니다. 이는 논리적으로 작업이 변경 불가능하기 때문일 수 있지만, 예를 들어 캐싱은 구현이 돌연변이를 수행하도록 강제합니다. 또는 원래 &lt;code&gt;&amp;amp;self&lt;/code&gt; 를 취하도록 정의 된 특성 분석법을 구현하려면 돌연변이를 사용해야하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="473e728a2f59da64c670799897819b1d614ba35f" translate="yes" xml:space="preserve">
          <source>OccupiedEntry</source>
          <target state="translated">OccupiedEntry</target>
        </trans-unit>
        <trans-unit id="9d9953ee64c9a9ed960498f1a51e79c8aae9c8dd" translate="yes" xml:space="preserve">
          <source>Occurrences of &lt;code&gt;.&lt;/code&gt; are normalized away, except if they are at the beginning of the path. For example, &lt;code&gt;a/./b&lt;/code&gt;, &lt;code&gt;a/b/&lt;/code&gt;, &lt;code&gt;a/b/.&lt;/code&gt; and &lt;code&gt;a/b&lt;/code&gt; all have &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; as components, but &lt;code&gt;./a/b&lt;/code&gt; starts with an additional &lt;a href=&quot;enum.component#variant.CurDir&quot;&gt;&lt;code&gt;CurDir&lt;/code&gt;&lt;/a&gt; component.</source>
          <target state="translated">의 발생 &lt;code&gt;.&lt;/code&gt; 경로의 시작 부분에있는 경우를 제외하고 정규화됩니다. 예를 들어, &lt;code&gt;a/./b&lt;/code&gt; , &lt;code&gt;a/b/&lt;/code&gt; , &lt;code&gt;a/b/.&lt;/code&gt; 및 &lt;code&gt;a/b&lt;/code&gt; 모두가 및 &lt;code&gt;b&lt;/code&gt; 성분뿐만 아니라 &lt;code&gt;./a/b&lt;/code&gt; 추가로 시작 &lt;a href=&quot;enum.component#variant.CurDir&quot;&gt; &lt;code&gt;CurDir&lt;/code&gt; &lt;/a&gt; 성분. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10500e54805775e3d661be35724e87f0b1dbc4c9" translate="yes" xml:space="preserve">
          <source>Octal</source>
          <target state="translated">Octal</target>
        </trans-unit>
        <trans-unit id="e6f02e23e2b227ac6699b92be300da464d475a6e" translate="yes" xml:space="preserve">
          <source>Octal integer</source>
          <target state="translated">8 진 정수</target>
        </trans-unit>
        <trans-unit id="d04577406c042a11b4da7bb39486816308c607a6" translate="yes" xml:space="preserve">
          <source>Octal::fmt</source>
          <target state="translated">Octal::fmt</target>
        </trans-unit>
        <trans-unit id="615b20b5b110a1806177c985ebbca57031daa785" translate="yes" xml:space="preserve">
          <source>Of course, knowing which collection is the right one for the job doesn't instantly permit you to use it correctly. Here are some quick tips for efficient and correct usage of the standard collections in general. If you're interested in how to use a specific collection in particular, consult its documentation for detailed discussion and code examples.</source>
          <target state="translated">물론, 어떤 컬렉션이 작업에 적합한 지 알면 즉시 사용할 수있는 것은 아닙니다. 다음은 일반적으로 표준 모음을 효율적이고 올바르게 사용하기위한 몇 가지 빠른 팁입니다. 특정 모음을 사용하는 방법에 관심이있는 경우 자세한 설명 및 코드 예제는 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2cbe09e34f3d1d91d444d3537b55bb92b3326aea" translate="yes" xml:space="preserve">
          <source>Of course, using &lt;a href=&quot;fn.stdout&quot;&gt;&lt;code&gt;io::stdout&lt;/code&gt;&lt;/a&gt; directly is less common than something like &lt;a href=&quot;../macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">물론 &lt;a href=&quot;fn.stdout&quot;&gt; &lt;code&gt;io::stdout&lt;/code&gt; &lt;/a&gt; 직접 사용하는 것은 &lt;a href=&quot;../macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt; 같은 것보다 덜 일반적입니다 ! .</target>
        </trans-unit>
        <trans-unit id="35c2f4d3ee9ba6ff467650c366d5a389ebdd0812" translate="yes" xml:space="preserve">
          <source>Of course, you can do it as long as the module you're referring to is an ancestor:</source>
          <target state="translated">물론, 참조하는 모듈이 조상이라면 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35d478ea3e054425d68cac2b881bb4303c629df5" translate="yes" xml:space="preserve">
          <source>Often, you&amp;rsquo;ll want to combine two existing strings. One way is to use the &lt;code&gt;+&lt;/code&gt; operator, as shown in Listing 8-18.</source>
          <target state="translated">종종 두 개의 기존 문자열을 결합하려고 할 것입니다. 한 가지 방법은 목록 8-18에 표시된대로 &lt;code&gt;+&lt;/code&gt; 연산자 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3894dea4e557c370e601b5214f719623a770bfec" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;packed&lt;/code&gt; structs</source>
          <target state="translated">에 &lt;code&gt;packed&lt;/code&gt; 구조체</target>
        </trans-unit>
        <trans-unit id="6b1d4e18544489b4eaf442b238d12d6d0846066b" translate="yes" xml:space="preserve">
          <source>On Linux systems, if this is compiled as &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">Linux 시스템에서 이것이 &lt;code&gt;foo&lt;/code&gt; 로 컴파일 된 경우 :</target>
        </trans-unit>
        <trans-unit id="81c83f6982dcc0359616815ff2d1c2e0f9aa8bfa" translate="yes" xml:space="preserve">
          <source>On Linux, macOS, and PowerShell on Windows, you can see the executable by entering the &lt;code&gt;ls&lt;/code&gt; command in your shell. On Linux and macOS, you&amp;rsquo;ll see two files. With PowerShell on Windows, you&amp;rsquo;ll see the same three files that you would see using CMD.</source>
          <target state="translated">Linux, macOS 및 Windows의 PowerShell에서는 쉘에 &lt;code&gt;ls&lt;/code&gt; 명령 을 입력하여 실행 파일을 볼 수 있습니다 . Linux 및 macOS에는 두 개의 파일이 있습니다. Windows에서 PowerShell을 사용하면 CMD를 사용할 때와 동일한 세 개의 파일이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7fc3d52902162d74f8ed313c5de739bb86f3a25d" translate="yes" xml:space="preserve">
          <source>On Linux:</source>
          <target state="translated">Linux에서 :</target>
        </trans-unit>
        <trans-unit id="28f964279968ee11e024ad4734a1849f6d567b40" translate="yes" xml:space="preserve">
          <source>On Redox this always returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Redox에서는 항상 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2c27c55a04c34d1416124c71c1487f965daf5e2b" translate="yes" xml:space="preserve">
          <source>On Unix</source>
          <target state="translated">유닉스에서</target>
        </trans-unit>
        <trans-unit id="f580d63739e00a5c78d3db723e0a54f4eebdec61" translate="yes" xml:space="preserve">
          <source>On Unix platforms, calling this method corresponds to calling &lt;code&gt;fcntl&lt;/code&gt;&lt;code&gt;FIONBIO&lt;/code&gt;. On Windows calling this method corresponds to calling &lt;code&gt;ioctlsocket&lt;/code&gt;&lt;code&gt;FIONBIO&lt;/code&gt;.</source>
          <target state="translated">Unix 플랫폼에서이 메소드 호출은 &lt;code&gt;fcntl&lt;/code&gt; &lt;code&gt;FIONBIO&lt;/code&gt; 호출에 해당합니다 . Windows 호출에서이 메소드는 &lt;code&gt;ioctlsocket&lt;/code&gt; &lt;code&gt;FIONBIO&lt;/code&gt; 호출에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="368e8ed37eeed58c150496b19476b91dc7031ee8" translate="yes" xml:space="preserve">
          <source>On Unix platforms, the underlying syscall may be interrupted by a spurious wakeup or signal handler. To ensure the sleep occurs for at least the specified duration, this function may invoke that system call multiple times.</source>
          <target state="translated">Unix 플랫폼에서 기본 syscall은 가짜 웨이크 업 또는 신호 처리기에 의해 중단 될 수 있습니다. 지정된 기간 동안 휴면이 발생하도록하기 위해이 함수는 해당 시스템 호출을 여러 번 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d8d403cb28547a9afda373b97085e009420f7cc" translate="yes" xml:space="preserve">
          <source>On Unix platforms, the underlying syscall may be interrupted by a spurious wakeup or signal handler. To ensure the sleep occurs for at least the specified duration, this function may invoke that system call multiple times. Platforms which do not support nanosecond precision for sleeping will have &lt;code&gt;dur&lt;/code&gt; rounded up to the nearest granularity of time they can sleep for.</source>
          <target state="translated">Unix 플랫폼에서 기본 syscall은 가짜 웨이크 업 또는 신호 처리기에 의해 중단 될 수 있습니다. 지정된 기간 동안 휴면이 발생하도록하기 위해이 함수는 해당 시스템 호출을 여러 번 호출 할 수 있습니다. 해야합니다 수면을위한 나노초 정밀도를 지원하지 않는 플랫폼 &lt;code&gt;dur&lt;/code&gt; 그들이 잘 수있는 시간의 가장 가까운 단위로 반올림.</target>
        </trans-unit>
        <trans-unit id="f15b383f304eefe4931d61a084a59f34627760f4" translate="yes" xml:space="preserve">
          <source>On Unix systems shell usually expands unquoted arguments with glob patterns (such as &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt;). On Windows this is not done, and such arguments are passed as-is.</source>
          <target state="translated">유닉스 시스템에서 쉘은 일반적으로 glob 패턴 (예 : &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;?&lt;/code&gt; ) 으로 따옴표없는 인수를 확장 합니다. Windows에서는이 작업이 수행되지 않으며 이러한 인수는 그대로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="35aecf3282b41109feea97145ac8fcf33e5a85c0" translate="yes" xml:space="preserve">
          <source>On Unix systems the shell usually expands unquoted arguments with glob patterns (such as &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt;). On Windows this is not done, and such arguments are passed as-is.</source>
          <target state="translated">Unix 시스템에서 쉘은 일반적으로 glob 패턴 (예 : &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;?&lt;/code&gt; ) 으로 인용되지 않은 인수를 확장 합니다. Windows에서는이 작업이 수행되지 않으며 이러한 인수는있는 그대로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="73ed9ce935220230672af1ba06994403c22fd01d" translate="yes" xml:space="preserve">
          <source>On Unix systems when pthread-based TLS is being used, destructors will not be run for TLS values on the main thread when it exits. Note that the application will exit immediately after the main thread exits as well.</source>
          <target state="translated">pthread 기반 TLS를 사용중인 Unix 시스템에서는 종료시 기본 스레드에서 TLS 값에 대해 소멸자가 실행되지 않습니다. 메인 스레드가 종료 된 직후에도 응용 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="fb3ee6950e481b93ea06bd207e97b8f1a208a9e6" translate="yes" xml:space="preserve">
          <source>On Unix systems, strings are often arbitrary sequences of non-zero bytes, in many cases interpreted as UTF-8.</source>
          <target state="translated">유닉스 시스템에서 문자열은 종종 0이 아닌 바이트의 임의의 시퀀스이며, 많은 경우 UTF-8로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="ade1ebaf1f97bbb67b44937124b853209f01a0de" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::unix::ffi::&lt;/code&gt;&lt;a href=&quot;../os/unix/ffi/trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait, which augments it with two methods, &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.from_bytes&quot;&gt;&lt;code&gt;from_bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.as_bytes&quot;&gt;&lt;code&gt;as_bytes&lt;/code&gt;&lt;/a&gt;. These do inexpensive conversions from and to UTF-8 byte slices.</source>
          <target state="translated">Unix에서 &lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;std::os::unix::ffi::&lt;/code&gt; &lt;a href=&quot;../os/unix/ffi/trait.osstrext&quot;&gt; &lt;code&gt;OsStrExt&lt;/code&gt; &lt;/a&gt; 특성을 구현하여 &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.from_bytes&quot;&gt; &lt;code&gt;from_bytes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.as_bytes&quot;&gt; &lt;code&gt;as_bytes&lt;/code&gt; 의&lt;/a&gt; 두 가지 방법으로 기능을 보강합니다 . 이것들은 UTF-8 바이트 슬라이스를 저렴하게 변환합니다.</target>
        </trans-unit>
        <trans-unit id="947b55450ee1839446a5472dd42bc83b983d60aa" translate="yes" xml:space="preserve">
          <source>On Unix, a path has a root if it begins with &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">유닉스에서 경로는 &lt;code&gt;/&lt;/code&gt; 로 시작하면 루트가됩니다 .</target>
        </trans-unit>
        <trans-unit id="3bd3b4c86524e4799caf099ecd37af36c6672deb" translate="yes" xml:space="preserve">
          <source>On Unix, a path is absolute if it starts with the root, so &lt;code&gt;is_absolute&lt;/code&gt; and &lt;a href=&quot;#method.has_root&quot;&gt;&lt;code&gt;has_root&lt;/code&gt;&lt;/a&gt; are equivalent.</source>
          <target state="translated">Unix에서 루트로 시작하면 경로는 절대이므로 &lt;code&gt;is_absolute&lt;/code&gt; 와 &lt;a href=&quot;#method.has_root&quot;&gt; &lt;code&gt;has_root&lt;/code&gt; &lt;/a&gt; 는 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1d8cd80a5b3e4b5d2416174dfc8848e290d79c0" translate="yes" xml:space="preserve">
          <source>On Unix, a path is absolute if it starts with the root, so &lt;code&gt;is_absolute&lt;/code&gt; and &lt;a href=&quot;struct.path#method.has_root&quot;&gt;&lt;code&gt;has_root&lt;/code&gt;&lt;/a&gt; are equivalent.</source>
          <target state="translated">Unix에서 루트로 시작하는 경로는 절대 경로이므로 &lt;code&gt;is_absolute&lt;/code&gt; 와 &lt;a href=&quot;struct.path#method.has_root&quot;&gt; &lt;code&gt;has_root&lt;/code&gt; &lt;/a&gt; 는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8c49b23a9e8913d5f28e887403c1dd64ea25f5f0" translate="yes" xml:space="preserve">
          <source>On Unix, this will return &lt;code&gt;None&lt;/code&gt; if the process was terminated by a signal; &lt;code&gt;std::os::unix&lt;/code&gt; provides an extension trait for extracting the signal and other details from the &lt;code&gt;ExitStatus&lt;/code&gt;.</source>
          <target state="translated">유닉스에서는 프로세스가 신호에 의해 종료되면 &lt;code&gt;None&lt;/code&gt; 을 반환합니다. &lt;code&gt;std::os::unix&lt;/code&gt; 는 &lt;code&gt;ExitStatus&lt;/code&gt; 에서 신호 및 기타 세부 사항을 추출하기위한 확장 특성을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="08103bc8083664f610de1cd76da40c7342e367bf" translate="yes" xml:space="preserve">
          <source>On Windows</source>
          <target state="translated">Windows에서</target>
        </trans-unit>
        <trans-unit id="340634e7ba37ae9abb46e394a10f468ca07b5406" translate="yes" xml:space="preserve">
          <source>On Windows and most Unix platforms this function is free (no extra system calls needed), but some Unix platforms may require the equivalent call to &lt;code&gt;symlink_metadata&lt;/code&gt; to learn about the target file type.</source>
          <target state="translated">Windows 및 대부분의 Unix 플랫폼에서이 기능은 무료이지만 (추가 시스템 호출이 필요하지 않음) 일부 Unix 플랫폼 에서는 대상 파일 유형에 대해 학습 하기 위해 &lt;code&gt;symlink_metadata&lt;/code&gt; 에 해당하는 호출이 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc05b2580f0d12742976994a81fdd3a92daa9627" translate="yes" xml:space="preserve">
          <source>On Windows this function is cheap to call (no extra system calls needed), but on Unix platforms this function is the equivalent of calling &lt;code&gt;symlink_metadata&lt;/code&gt; on the path.</source>
          <target state="translated">Windows에서는이 기능을 호출하는 것이 저렴하지만 (추가 시스템 호출이 필요하지 않음) Unix 플랫폼에서이 기능은 경로에서 &lt;code&gt;symlink_metadata&lt;/code&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="96488f7f2e398f8d620db102c3767404f52cec35" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows::ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait, which provides an &lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; method. This provides an iterator that can be &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt;ed into a vector of &lt;a href=&quot;../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;std::os::windows::ffi::&lt;/code&gt; &lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt; &lt;code&gt;OsStrExt&lt;/code&gt; &lt;/a&gt; 특성을 구현하여 &lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt; &lt;code&gt;encode_wide&lt;/code&gt; &lt;/a&gt; 메소드 를 제공합니다 . 이것은 &lt;a href=&quot;../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; 의 벡터로 &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt; 될 수있는 반복자를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="354971d9fc4cf41d4726d0f246b8a7efa90a20dd" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows::ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait, which provides an &lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; method. This provides an iterator that can be &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt;ed into a vector of &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u16.html&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt; &lt;code&gt;encode_wide&lt;/code&gt; &lt;/a&gt; 메소드 를 제공하는 &lt;code&gt;std::os::windows::ffi::&lt;/code&gt; &lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt; &lt;code&gt;OsStrExt&lt;/code&gt; &lt;/a&gt;트레이 트를 구현합니다 . 이것은 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u16.html&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; 벡터로 &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt; 될 수있는 반복자를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="9af64d7ebac16f152870c457029381910a90ad98" translate="yes" xml:space="preserve">
          <source>On Windows, a path has a root if it:</source>
          <target state="translated">Windows에서 경로는 다음과 같은 경우 루트를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="23aad31490e7c68a187977dea619fd53f62cad2c" translate="yes" xml:space="preserve">
          <source>On Windows, a path is absolute if it has a prefix and starts with the root: &lt;code&gt;c:\windows&lt;/code&gt; is absolute, while &lt;code&gt;c:temp&lt;/code&gt; and &lt;code&gt;\temp&lt;/code&gt; are not.</source>
          <target state="translated">Windows에서 접두어가 있고 루트로 시작하는 경로는 절대 경로입니다. &lt;code&gt;c:\windows&lt;/code&gt; 는 절대이지만 &lt;code&gt;c:temp&lt;/code&gt; 및 &lt;code&gt;\temp&lt;/code&gt; 는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76c59bd2f582fcbc4571a1c46e5718df63ea4def" translate="yes" xml:space="preserve">
          <source>On Windows, a symbolic link knows whether it is a file or directory.</source>
          <target state="translated">Windows에서 기호 링크는 파일인지 디렉토리인지를 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="21bc0d515b3e6fb7f3d9412e9a760b756bd52140" translate="yes" xml:space="preserve">
          <source>On Windows, enter the command &lt;code&gt;.\main.exe&lt;/code&gt; instead of &lt;code&gt;./main&lt;/code&gt;:</source>
          <target state="translated">Windows에서 명령을 입력 &lt;code&gt;.\main.exe&lt;/code&gt; 대신 &lt;code&gt;./main&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a5430ea74797e1304f80750653012edbeaab36ca" translate="yes" xml:space="preserve">
          <source>On Windows, go to &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt; and follow the instructions for installing Rust. At some point in the installation, you&amp;rsquo;ll receive a message explaining that you&amp;rsquo;ll also need the C++ build tools for Visual Studio 2013 or later. The easiest way to acquire the build tools is to install &lt;a href=&quot;https://visualstudio.microsoft.com/visual-cpp-build-tools/&quot;&gt;Build Tools for Visual Studio 2019&lt;/a&gt;. When asked which workloads to install make sure &quot;C++ build tools&quot; is selected and that the Windows 10 SDK and the English language pack components are included.</source>
          <target state="translated">Windows에서는 &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt; 로 이동하여 Rust 설치 지침을 따릅니다. 설치의 어느 시점에서 Visual Studio 2013 이상용 C ++ 빌드 도구도 필요하다는 메시지가 표시됩니다. 빌드 도구를 얻는 가장 쉬운 방법 &lt;a href=&quot;https://visualstudio.microsoft.com/visual-cpp-build-tools/&quot;&gt;은 Visual Studio 2019 용 빌드 도구&lt;/a&gt; 를 설치하는 것 입니다. 설치할 워크로드를 묻는 메시지가 표시되면 &quot;C ++ 빌드 도구&quot;가 선택되어 있고 Windows 10 SDK 및 영어 언어 팩 구성 요소가 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="bd7a73ca0a18d815fd6e51cfa03502575932403d" translate="yes" xml:space="preserve">
          <source>On Windows, go to &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt; and follow the instructions for installing Rust. At some point in the installation, you&amp;rsquo;ll receive a message explaining that you&amp;rsquo;ll also need the C++ build tools for Visual Studio 2013 or later. The easiest way to acquire the build tools is to install &lt;a href=&quot;https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019&quot;&gt;Build Tools for Visual Studio 2019&lt;/a&gt;. The tools are in the Other Tools and Frameworks section.</source>
          <target state="translated">Windows의 경우 &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt; 로 이동하여 Rust 설치 지침을 따르십시오. 설치의 어느 시점에서 Visual Studio 2013 이상의 C ++ 빌드 도구가 필요하다는 메시지가 표시됩니다. 빌드 도구를 얻는 가장 쉬운 방법 &lt;a href=&quot;https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019&quot;&gt;은 Visual Studio 2019 용 빌드 도구&lt;/a&gt; 를 설치하는 것 입니다. 도구는 기타 도구 및 프레임 워크 섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9e96b3ce49cbd593ce10eba431579916c1beb4e" translate="yes" xml:space="preserve">
          <source>On Windows, strings are often arbitrary sequences of non-zero 16-bit values, interpreted as UTF-16 when it is valid to do so.</source>
          <target state="translated">Windows에서 문자열은 종종 0이 아닌 16 비트 값의 임의 시퀀스이며, 유효 할 때 UTF-16으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="4d87cfdfbe26beaf98d7cabde9343985e270cf11" translate="yes" xml:space="preserve">
          <source>On Windows, this converts the path to use &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file&quot;&gt;extended length path&lt;/a&gt; syntax, which allows your program to use longer path names, but means you can only join backslash-delimited paths to it, and it may be incompatible with other applications (if passed to the application on the command-line, or written to a file another application may read).</source>
          <target state="translated">Windows에서는 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file&quot;&gt;확장 된 길이 경로&lt;/a&gt; 구문 을 사용하도록 경로를 변환 하여 프로그램에서 더 긴 경로 이름을 사용할 수 있지만 백 슬래시로 구분 된 경로 만 결합 할 수 있으며 다른 응용 프로그램과 호환되지 않을 수 있습니다 ( 명령 줄에서 응용 프로그램을 작성하거나 다른 응용 프로그램이 읽을 수있는 파일에 기록됨).</target>
        </trans-unit>
        <trans-unit id="e57ac5776aebf69e1a4091e5f62bdd9bd9a59609" translate="yes" xml:space="preserve">
          <source>On Windows, this converts the path to use &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx#maxpath&quot;&gt;extended length path&lt;/a&gt; syntax, which allows your program to use longer path names, but means you can only join backslash-delimited paths to it, and it may be incompatible with other applications (if passed to the application on the command-line, or written to a file another application may read).</source>
          <target state="translated">Windows에서는 경로를 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx#maxpath&quot;&gt;확장 길이 경로&lt;/a&gt; 구문 을 사용하도록 변환 하여 프로그램에서 더 긴 경로 이름을 사용할 수 있지만 백 슬래시로 구분 된 경로 만 조인 할 수 있으며 다른 응용 프로그램과 호환되지 않을 수 있습니다 ( 명령 줄에있는 응용 프로그램 또는 다른 응용 프로그램이 읽을 수있는 파일에 기록).</target>
        </trans-unit>
        <trans-unit id="22cfd134aef9e5447e4029c33c01913e82dca29d" translate="yes" xml:space="preserve">
          <source>On Windows, you must specify whether a symbolic link points to a file or directory. Use &lt;code&gt;os::windows::fs::symlink_file&lt;/code&gt; to create a symbolic link to a file, or &lt;code&gt;os::windows::fs::symlink_dir&lt;/code&gt; to create a symbolic link to a directory. Additionally, the process must have &lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; in order to be able to create a symbolic link.</source>
          <target state="translated">Windows에서는 기호 링크가 파일 또는 디렉토리를 가리키는 지 여부를 지정해야합니다. 사용 &lt;code&gt;os::windows::fs::symlink_file&lt;/code&gt; 파일에 대한 심볼릭 링크를 만들거나 &lt;code&gt;os::windows::fs::symlink_dir&lt;/code&gt; 디렉토리에 대한 심볼릭 링크를 만들 수 있습니다. 또한 심볼릭 링크를 만들려면 프로세스에 &lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; 가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">Windows에서 :</target>
        </trans-unit>
        <trans-unit id="2d943049f7275605af2957c0729af75e15804644" translate="yes" xml:space="preserve">
          <source>On a struct pattern, the fields are referenced by name, index (in the case of tuple structs) or ignored by use of &lt;code&gt;..&lt;/code&gt;:</source>
          <target state="translated">구조체 패턴에서 필드는 이름, 인덱스 (튜플 구조체의 경우)로 참조되거나 &lt;code&gt;..&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bc5ae395985a077524b266fc2c058a9c41f9a6c9" translate="yes" xml:space="preserve">
          <source>On a technical level, Rust inserts</source>
          <target state="translated">기술적으로 Rust inserts</target>
        </trans-unit>
        <trans-unit id="1b348ad01b675597a26bee9f6007707cf4e88f3f" translate="yes" xml:space="preserve">
          <source>On all platforms it's possible for TLS to re-initialize other TLS slots during destruction. Some platforms ensure that this cannot happen infinitely by preventing re-initialization of any slot that has been destroyed, but not all platforms have this guard. Those platforms that do not guard typically have a synthetic limit after which point no more destructors are run.</source>
          <target state="translated">모든 플랫폼에서 TLS는 파괴 중에 다른 TLS 슬롯을 다시 초기화 할 수 있습니다. 일부 플랫폼은 파괴 된 슬롯의 재 초기화를 방지하여 무한정 발생할 수는 없지만 모든 플랫폼에 이러한 보호 기능이있는 것은 아닙니다. 보호하지 않는 플랫폼은 일반적으로 더 이상 소멸자가 실행되지 않는 합성 한계를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="037d4731f94d8fe39eb9b4a6879b2f19130604a0" translate="yes" xml:space="preserve">
          <source>On all platforms, the newline is the LINE FEED character (&lt;code&gt;\n&lt;/code&gt;/&lt;code&gt;U+000A&lt;/code&gt;) alone (no additional CARRIAGE RETURN (&lt;code&gt;\r&lt;/code&gt;/&lt;code&gt;U+000D&lt;/code&gt;)).</source>
          <target state="translated">모든 플랫폼에서 개행 문자는 LINE FEED 문자 ( &lt;code&gt;\n&lt;/code&gt; / &lt;code&gt;U+000A&lt;/code&gt; ) 만입니다 (추가 CARRIAGE RETURN ( &lt;code&gt;\r&lt;/code&gt; / &lt;code&gt;U+000D&lt;/code&gt; ) 없음).</target>
        </trans-unit>
        <trans-unit id="d799d2a3d45a2a27a645560d44031039269d8400" translate="yes" xml:space="preserve">
          <source>On all platforms, the newline is the LINE FEED character (&lt;code&gt;\n&lt;/code&gt;/&lt;code&gt;U+000A&lt;/code&gt;) alone (no additional CARRIAGE RETURN (&lt;code&gt;\r&lt;/code&gt;/&lt;code&gt;U+000D&lt;/code&gt;).</source>
          <target state="translated">모든 플랫폼에서 줄 바꿈은 LINE FEED 문자 ( &lt;code&gt;\n&lt;/code&gt; / &lt;code&gt;U+000A&lt;/code&gt; ) 단독입니다 (추가 캐리지 리턴 ( &lt;code&gt;\r&lt;/code&gt; / &lt;code&gt;U+000D&lt;/code&gt; ) 없음 ).</target>
        </trans-unit>
        <trans-unit id="8026d1566cfb33142845deb08dc55be0e48c8b84" translate="yes" xml:space="preserve">
          <source>On arithmetic overflow, returns &lt;code&gt;LayoutErr&lt;/code&gt;.</source>
          <target state="translated">산술 오버플로에서 &lt;code&gt;LayoutErr&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="62056a56ee350ef2ac48d7878ee0e8c05c6cdab9" translate="yes" xml:space="preserve">
          <source>On big endian this is a no-op. On little endian the bytes are swapped.</source>
          <target state="translated">빅 엔디안에서 이것은 no-op입니다. 리틀 엔디안에서는 바이트가 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="3209db243d37f470d1d7cfe42ce3d766b7bc29ef" translate="yes" xml:space="preserve">
          <source>On failure, ownership of the original &lt;code&gt;CString&lt;/code&gt; is returned.</source>
          <target state="translated">실패하면 원래 &lt;code&gt;CString&lt;/code&gt; 의 소유권 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="4c9afd72e5fc07b12e4a58aab05b5a861ccfe991" translate="yes" xml:space="preserve">
          <source>On failure, ownership of the original &lt;code&gt;OsString&lt;/code&gt; is returned.</source>
          <target state="translated">실패하면 원래 &lt;code&gt;OsString&lt;/code&gt; 의 소유권 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="259a9191e45f4405904adb74ccfbaecde8fac969" translate="yes" xml:space="preserve">
          <source>On glibc Linux systems, arguments are retrieved by placing a function in &quot;.init_array&quot;. Glibc passes argc, argv, and envp to functions in &quot;.init_array&quot;, as a non-standard extension. This allows &lt;code&gt;std::env::args&lt;/code&gt; to work even in a &lt;code&gt;cdylib&lt;/code&gt; or &lt;code&gt;staticlib&lt;/code&gt;, as it does on macOS and Windows.</source>
          <target state="translated">glibc Linux 시스템에서는 &quot;.init_array&quot;에 함수를 배치하여 인수를 검색합니다. Glibc는 &quot;.init_array&quot;의 함수에 비표준 확장으로 argc, argv 및 envp를 전달합니다. 이것은 &lt;code&gt;std::env::args&lt;/code&gt; 가 macOS 및 Windows에서와 마찬가지로 &lt;code&gt;cdylib&lt;/code&gt; 또는 &lt;code&gt;staticlib&lt;/code&gt; 에서도 작동하도록 합니다.</target>
        </trans-unit>
        <trans-unit id="d682d53e730f8107b6e28e70ea3aca1f2f84a3a2" translate="yes" xml:space="preserve">
          <source>On glibc Linux systems, arguments are retrieved by placing a function in &lt;code&gt;.init_array&lt;/code&gt;. Glibc passes &lt;code&gt;argc&lt;/code&gt;, &lt;code&gt;argv&lt;/code&gt;, and &lt;code&gt;envp&lt;/code&gt; to functions in &lt;code&gt;.init_array&lt;/code&gt;, as a non-standard extension. This allows &lt;code&gt;std::env::args&lt;/code&gt; to work even in a &lt;code&gt;cdylib&lt;/code&gt; or &lt;code&gt;staticlib&lt;/code&gt;, as it does on macOS and Windows.</source>
          <target state="translated">glibc Linux 시스템에서 인수는 &lt;code&gt;.init_array&lt;/code&gt; 에 함수를 배치하여 검색 됩니다 . Glibc는 비표준 확장으로 &lt;code&gt;argc&lt;/code&gt; , &lt;code&gt;argv&lt;/code&gt; 및 &lt;code&gt;envp&lt;/code&gt; 를 &lt;code&gt;.init_array&lt;/code&gt; 의 함수에 전달 합니다. 이것은 &lt;code&gt;std::env::args&lt;/code&gt; 가 macOS 및 Windows에서와 마찬가지로 &lt;code&gt;cdylib&lt;/code&gt; 또는 &lt;code&gt;staticlib&lt;/code&gt; 에서도 작동하도록 합니다.</target>
        </trans-unit>
        <trans-unit id="3818a4eb5a3ae2432429a2be6f00d2b57327ad67" translate="yes" xml:space="preserve">
          <source>On iteration, the closure will be applied to each element of the iterator and the return value from the closure, an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;, is yielded by the iterator.</source>
          <target state="translated">반복시 클로저는 반복자의 각 요소에 적용되며 클로저의 반환 값인 &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 은 반복자에 의해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7ac8ec0fd24d5e212f6e7881f085d7af49a49607" translate="yes" xml:space="preserve">
          <source>On little endian this is a no-op. On big endian the bytes are swapped.</source>
          <target state="translated">리틀 엔디안에서는 이것이 작동하지 않습니다. 빅 엔디안에서는 바이트가 교환됩니다.</target>
        </trans-unit>
        <trans-unit id="5d4ddcfc8d324d93f4c94125de45c5742f4d5101" translate="yes" xml:space="preserve">
          <source>On non-pointer types &lt;code&gt;*x&lt;/code&gt; is equivalent to &lt;code&gt;*std::ops::Deref::deref(&amp;amp;x)&lt;/code&gt; in an &lt;a href=&quot;../expressions#mutability&quot;&gt;immutable place expression context&lt;/a&gt; and &lt;code&gt;*std::ops::DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; in a mutable place expression context.</source>
          <target state="translated">비 포인터 유형 &lt;code&gt;*x&lt;/code&gt; 동등 &lt;code&gt;*std::ops::Deref::deref(&amp;amp;x)&lt;/code&gt; 에서 &lt;a href=&quot;../expressions#mutability&quot;&gt;불변 장소 식 컨텍스트&lt;/a&gt; 및 &lt;code&gt;*std::ops::DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; 변경 가능한 곳에 표현 문맥.</target>
        </trans-unit>
        <trans-unit id="152e667068d08065574b6f3ea75735b1ef22f81c" translate="yes" xml:space="preserve">
          <source>On panic, this macro will print the values of the expressions with their debug representations.</source>
          <target state="translated">패닉 상태에서이 매크로는 표현식의 값을 디버그 표현으로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="a0e8d873b690ac84365bcb6ce9a48ba9ac4a73cf" translate="yes" xml:space="preserve">
          <source>On some system, calling &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or similar is necessary for the OS to release resources. A process that terminated but has not been waited on is still around as a &quot;zombie&quot;. Leaving too many zombies around may exhaust global resources (for example process IDs).</source>
          <target state="translated">일부 시스템에서는 OS가 리소스를 해제하려면 호출 &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 또는 이와 유사한 것이 필요합니다. 종료되었지만 대기하지 않은 프로세스는 여전히 &quot;좀비&quot;입니다. 주위에 너무 많은 좀비를 남겨두면 전역 리소스 (예 : 프로세스 ID)가 소모 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d680bbd1b29ac2bd7f1c4039cc2f034c2409b58" translate="yes" xml:space="preserve">
          <source>On some systems, calling &lt;a href=&quot;struct.child#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or similar is necessary for the OS to release resources. A process that terminated but has not been waited on is still around as a &quot;zombie&quot;. Leaving too many zombies around may exhaust global resources (for example process IDs).</source>
          <target state="translated">일부 시스템에서는 OS가 리소스를 해제하기 위해 &lt;a href=&quot;struct.child#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 또는 이와 유사한 호출 이 필요합니다. 종료되었지만 기다리지 않은 프로세스는 여전히 &quot;좀비&quot;로 남아 있습니다. 좀비를 너무 많이 남겨두면 글로벌 리소스 (예 : 프로세스 ID)가 고갈 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f95b6f9f5ca3589fe7d076155399faa6b71dbbbe" translate="yes" xml:space="preserve">
          <source>On success this function will not return, and otherwise it will return an error indicating why the exec (or another part of the setup of the &lt;code&gt;Command&lt;/code&gt;) failed.</source>
          <target state="translated">성공하면이 함수는 반환되지 않으며, 그렇지 않으면 exec (또는 &lt;code&gt;Command&lt;/code&gt; 설정의 다른 부분 )가 실패한 이유를 나타내는 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9dc3aca4d292aed062c338c543e13af0f74c89de" translate="yes" xml:space="preserve">
          <source>On success, returns a &lt;a href=&quot;../ptr/struct.nonnull&quot;&gt;&lt;code&gt;NonNull&amp;lt;[u8]&amp;gt;&lt;/code&gt;&lt;/a&gt; meeting the size and alignment guarantees of &lt;code&gt;layout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ee4aa1b293e333458ae17de2dc9971adc5a07b" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes read and the address from whence the data came.</source>
          <target state="translated">성공하면 읽은 바이트 수와 데이터가 왔을 때의 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4ea0ccaabe0c9b1fbc90341ab5a04d65215e560d" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes read.</source>
          <target state="translated">성공하면 읽은 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc5a49aba56a5b26329959ae0e37a7391cbb54ed" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes written.</source>
          <target state="translated">성공하면 쓴 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f9b7167ab1cb81802d4cc93ff38048bd7cd2f218" translate="yes" xml:space="preserve">
          <source>On success, the total number of bytes copied is returned and it is equal to the length of the &lt;code&gt;to&lt;/code&gt; file as reported by &lt;code&gt;metadata&lt;/code&gt;.</source>
          <target state="translated">성공시, 복사 된 총 바이트 수를 반환하고, 그것은의 길이와 동일한 &lt;code&gt;to&lt;/code&gt; 의해보고 된 파일 &lt;code&gt;metadata&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6bfa6f8c514698639a06b222dc94c1639495b9f" translate="yes" xml:space="preserve">
          <source>On success, the total number of bytes that were copied from &lt;code&gt;reader&lt;/code&gt; to &lt;code&gt;writer&lt;/code&gt; is returned.</source>
          <target state="translated">성공하면 &lt;code&gt;reader&lt;/code&gt; 에서 &lt;code&gt;writer&lt;/code&gt; 로 복사 된 총 바이트 수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="43a00d4716ce2886f17dadaa3b0e2204d940167a" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;Screen&lt;/code&gt; struct, we&amp;rsquo;ll define a method named &lt;code&gt;run&lt;/code&gt; that will call the &lt;code&gt;draw&lt;/code&gt; method on each of its &lt;code&gt;components&lt;/code&gt;, as shown in Listing 17-5:</source>
          <target state="translated">온 &lt;code&gt;Screen&lt;/code&gt; 구조체, 우리는 방법 이름을 정의 할 것이다 &lt;code&gt;run&lt;/code&gt; 부르는 것 &lt;code&gt;draw&lt;/code&gt; 는 각각 방법을 &lt;code&gt;components&lt;/code&gt; 17-5 목록과 같이를 :</target>
        </trans-unit>
        <trans-unit id="417a01b51fb2fc402d7ff9e7a38ed36ddb3ab97a" translate="yes" xml:space="preserve">
          <source>On the first line of &lt;code&gt;main&lt;/code&gt;, we call &lt;code&gt;env::args&lt;/code&gt;, and we immediately use &lt;code&gt;collect&lt;/code&gt; to turn the iterator into a vector containing all the values produced by the iterator. We can use the &lt;code&gt;collect&lt;/code&gt; function to create many kinds of collections, so we explicitly annotate the type of &lt;code&gt;args&lt;/code&gt; to specify that we want a vector of strings. Although we very rarely need to annotate types in Rust, &lt;code&gt;collect&lt;/code&gt; is one function you do often need to annotate because Rust isn&amp;rsquo;t able to infer the kind of collection you want.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 의 첫 번째 줄에서 &lt;code&gt;env::args&lt;/code&gt; 라고 부르고 즉시 &lt;code&gt;collect&lt;/code&gt; 를 사용 하여 반복자를 반복자에 의해 생성 된 모든 값을 포함하는 벡터로 바꿉니다. 우리는 사용할 수 있습니다 &lt;code&gt;collect&lt;/code&gt; 우리가 명시 적으로 유형 주석, 그래서 컬렉션의 많은 종류를 생성하는 기능을 &lt;code&gt;args&lt;/code&gt; 우리가 문자열의 벡터를 지정할 수 있습니다. Rust에서 유형에 주석을 달아야 &lt;code&gt;collect&lt;/code&gt; 는 거의 없지만 collect 는 Rust가 원하는 컬렉션을 유추 할 수 없기 때문에 주석을 달아야하는 함수 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="9eddcffce559b2f4fd96faa276545d34f1b2fe9a" translate="yes" xml:space="preserve">
          <source>On the other hand, one trait which would not be appropriate to implement is &lt;a href=&quot;default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">반면에 구현하기에 적합하지 않은 한 가지 특성은 &lt;a href=&quot;default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; 입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c286483c8f6ceb616a180cf64f82c92b911d5676" translate="yes" xml:space="preserve">
          <source>On the other hand, this is correct:</source>
          <target state="translated">반면에 이것은 정확합니다.</target>
        </trans-unit>
        <trans-unit id="8cf67f3b833240197b7f3967e7a28b88e1336e77" translate="yes" xml:space="preserve">
          <source>On the other hand, this will not compile because the &lt;code&gt;where 'b: 'a&lt;/code&gt; clause is missing: the &lt;code&gt;'b&lt;/code&gt; lifetime is not known to live at least as long as &lt;code&gt;'a&lt;/code&gt; which means this function cannot ensure it always returns a valid reference:</source>
          <target state="translated">반면에, &lt;code&gt;where 'b: 'a&lt;/code&gt; 절이 없기 때문에 컴파일되지 않습니다 : &lt;code&gt;'b&lt;/code&gt; 수명은 적어도 &lt;code&gt;'a&lt;/code&gt; 만큼 오래 사는 것으로 알려져 있지 않습니다. 즉,이 함수가 항상 유효한 참조를 반환하도록 보장 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="09d6ad3b118e12286d44db37bda32a77e5392fde" translate="yes" xml:space="preserve">
          <source>On the other hand, when bringing in structs, enums, and other items with &lt;code&gt;use&lt;/code&gt;, it&amp;rsquo;s idiomatic to specify the full path. Listing 7-14 shows the idiomatic way to bring the standard library&amp;rsquo;s &lt;code&gt;HashMap&lt;/code&gt; struct into the scope of a binary crate.</source>
          <target state="translated">반면에 struct, enum 및 기타 &lt;code&gt;use&lt;/code&gt; 항목을 가져올 때는 전체 경로를 지정하는 것이 관용적입니다. 리스팅 7-14는 표준 라이브러리의 &lt;code&gt;HashMap&lt;/code&gt; 구조체를 이진 크레이트의 범위로 가져 오는 관용적 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="50d2f428f140a723a3dc474c3eb5d43ababe5b45" translate="yes" xml:space="preserve">
          <source>On the other hand, with the method using trait objects, one &lt;code&gt;Screen&lt;/code&gt; instance can hold a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that contains a &lt;code&gt;Box&amp;lt;Button&amp;gt;&lt;/code&gt; as well as a &lt;code&gt;Box&amp;lt;TextField&amp;gt;&lt;/code&gt;. Let&amp;rsquo;s look at how this works, and then we&amp;rsquo;ll talk about the runtime performance implications.</source>
          <target state="translated">반면에 trait 객체를 사용하는 메서드를 사용하면 하나의 &lt;code&gt;Screen&lt;/code&gt; 인스턴스는 &lt;code&gt;Box&amp;lt;Button&amp;gt;&lt;/code&gt; 과 &lt;code&gt;Box&amp;lt;TextField&amp;gt;&lt;/code&gt; 를 포함하는 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 를 보유 할 수 있습니다 . 이것이 어떻게 작동하는지 살펴보고 런타임 성능 관련 사항에 대해 이야기하겠습니다.</target>
        </trans-unit>
        <trans-unit id="05a08140d648b8eef0f62e5e0b016ae12318d58b" translate="yes" xml:space="preserve">
          <source>On the surface, &lt;code&gt;static&lt;/code&gt; items seem very similar to &lt;a href=&quot;keyword.const&quot;&gt;&lt;code&gt;const&lt;/code&gt;&lt;/a&gt;s: both contain a value, both require type annotations and both can only be initialized with constant functions and values. However, &lt;code&gt;static&lt;/code&gt;s are notably different in that they represent a location in memory. That means that you can have references to &lt;code&gt;static&lt;/code&gt; items and potentially even modify them, making them essentially global variables.</source>
          <target state="translated">표면적으로 &lt;code&gt;static&lt;/code&gt; 항목은 &lt;a href=&quot;keyword.const&quot;&gt; &lt;code&gt;const&lt;/code&gt; &lt;/a&gt; 와 매우 유사 해 보입니다 . 둘 다 값을 포함하고 둘 다 유형 주석을 필요로하며 둘 다 상수 함수 및 값으로 만 초기화 할 수 있습니다. 그러나 &lt;code&gt;static&lt;/code&gt; 은 메모리의 위치를 ​​나타내는 점에서 현저하게 다릅니다. 즉, &lt;code&gt;static&lt;/code&gt; 항목에 대한 참조를 가질 수 있고 잠재적으로 수정하여 본질적으로 전역 변수로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8593d2dddd7916b4461c2238bc4c5b8191583e5e" translate="yes" xml:space="preserve">
          <source>On top of that, all additional invariants of the type &lt;code&gt;T&lt;/code&gt; must be satisfied, as the &lt;code&gt;Drop&lt;/code&gt; implementation of &lt;code&gt;T&lt;/code&gt; (or its members) may rely on this. For example, a &lt;code&gt;1&lt;/code&gt;-initialized &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is considered initialized (under the current implementation; this does not constitute a stable guarantee) because the only requirement the compiler knows about it is that the data pointer must be non-null. Dropping such a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; however will cause undefined behaviour.</source>
          <target state="translated">또한 &lt;code&gt;T&lt;/code&gt; (또는 해당 멤버) 의 &lt;code&gt;Drop&lt;/code&gt; 구현 이 이에 의존 할 수 있으므로 &lt;code&gt;T&lt;/code&gt; 유형의 모든 추가 불변 이 충족되어야합니다 . 예를 들어, &lt;code&gt;1&lt;/code&gt; 초기화 된 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 컴파일러가 데이터 포인터가 null이 아니어야한다는 것을 알고있는 유일한 요구 사항이기 때문에 초기화 된 것으로 간주됩니다 (현재 구현에서 이것은 안정적인 보장을 구성하지 않음). 그러나 이러한 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 삭제 하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7d7c692a18f46234aa3957edc945a28ff83c44fe" translate="yes" xml:space="preserve">
          <source>On top of that, function pointers can vary based on what ABI they use. This is achieved by adding the &lt;code&gt;extern&lt;/code&gt; keyword before the type, followed by the ABI in question. The default ABI is &quot;Rust&quot;, i.e., &lt;code&gt;fn()&lt;/code&gt; is the exact same type as &lt;code&gt;extern &quot;Rust&quot; fn()&lt;/code&gt;. A pointer to a function with C ABI would have type &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt;.</source>
          <target state="translated">또한 함수 포인터는 사용하는 ABI에 따라 달라질 수 있습니다. 이는 유형 앞에 &lt;code&gt;extern&lt;/code&gt; 키워드 를 추가하고 그 뒤에 해당 ABI를 추가하면 됩니다. 기본 ABI는 &quot;Rust&quot;입니다. 즉, &lt;code&gt;fn()&lt;/code&gt; 은 &lt;code&gt;extern &quot;Rust&quot; fn()&lt;/code&gt; 과 정확히 동일한 유형 입니다. C ABI를 사용하는 함수에 대한 포인터는 &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt; 유형을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="a7c793eb037e8ef3b7da8efa89ac452132495eae" translate="yes" xml:space="preserve">
          <source>On top of that, function pointers can vary based on what ABI they use. This is achieved by adding the &lt;code&gt;extern&lt;/code&gt; keyword to the type name, followed by the ABI in question. For example, &lt;code&gt;fn()&lt;/code&gt; is different from &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt;, which itself is different from &lt;code&gt;extern &quot;stdcall&quot; fn()&lt;/code&gt;, and so on for the various ABIs that Rust supports. Non-&lt;code&gt;extern&lt;/code&gt; functions have an ABI of &lt;code&gt;&quot;Rust&quot;&lt;/code&gt;, and &lt;code&gt;extern&lt;/code&gt; functions without an explicit ABI have an ABI of &lt;code&gt;&quot;C&quot;&lt;/code&gt;. For more information, see &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions&quot;&gt;the nomicon's section on foreign calling conventions&lt;/a&gt;.</source>
          <target state="translated">또한 함수 포인터는 사용하는 ABI에 따라 달라질 수 있습니다. &lt;code&gt;extern&lt;/code&gt; 키워드를 형식 이름 에 추가 한 다음 해당 ABI를 추가하면 됩니다. 예를 들어, &lt;code&gt;fn()&lt;/code&gt; 은 &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt; 과 다릅니다. 이는 &lt;code&gt;extern &quot;stdcall&quot; fn()&lt;/code&gt; 과 는 다릅니다 . Rust가 지원하는 다양한 ABI에 대해서도 마찬가지입니다. 비 &lt;code&gt;extern&lt;/code&gt; 함수는 ABI가 &lt;code&gt;&quot;Rust&quot;&lt;/code&gt; 이고, 명시 적 ABI가없는 &lt;code&gt;extern&lt;/code&gt; 함수는 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 입니다. 자세한 내용 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions&quot;&gt;은 외래 통화 규칙에 대한 nomicon 섹션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b2aa688af42ea89b3fbf818f2d4bdeab6c73c4a" translate="yes" xml:space="preserve">
          <source>On top of that, remember that most types have additional invariants beyond merely being considered initialized at the type level. For example, a &lt;code&gt;1&lt;/code&gt;-initialized &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is considered initialized (under the current implementation; this does not constitute a stable guarantee) because the only requirement the compiler knows about it is that the data pointer must be non-null. Creating such a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; does not cause &lt;em&gt;immediate&lt;/em&gt; undefined behavior, but will cause undefined behavior with most safe operations (including dropping it).</source>
          <target state="translated">또한 대부분의 유형에는 단순히 유형 수준에서 초기화되는 것으로 간주되는 것 이상의 추가 불변성이 있다는 점을 기억하십시오. 예를 들어, &lt;code&gt;1&lt;/code&gt; 초기화 된 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 컴파일러가 데이터 포인터가 null이 아니어야한다는 것을 알고있는 유일한 요구 사항이기 때문에 초기화 된 것으로 간주됩니다 (현재 구현에서 이것은 안정적인 보장을 구성하지 않음). 이러한 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 생성 하면 &lt;em&gt;즉시&lt;/em&gt; 정의되지 않은 동작이 발생하지는 않지만 대부분의 안전한 작업 (삭제 포함)으로 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="630c59f788be2f8b6b4b1ca247b245094c3530e8" translate="yes" xml:space="preserve">
          <source>On top of that, remember that most types have additional invariants beyond merely being considered initialized at the type level. For example, a &lt;code&gt;1&lt;/code&gt;-initialized &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is considered initialized because the only requirement the compiler knows about it is that the data pointer must be non-null. Creating such a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; does not cause &lt;em&gt;immediate&lt;/em&gt; undefined behavior, but will cause undefined behavior with most safe operations (including dropping it).</source>
          <target state="translated">또한 대부분의 유형에는 유형 수준에서 초기화 된 것으로 간주되는 것 외에 추가 불변이 있습니다. 예를 들어, 컴파일러가 알고있는 유일한 요구 사항은 데이터 포인터가 널이 아니어야하기 때문에 &lt;code&gt;1&lt;/code&gt; - 초기화 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 초기화 된 것으로 간주됩니다. 이러한 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 작성 하면 &lt;em&gt;즉시&lt;/em&gt; 정의되지 않은 동작이 발생하지 않지만 가장 안전한 조작 (삭제 포함)에서 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="dde4e913efe3a7bb20d91e29731b497ad0b7ade2" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;Config::new&lt;/code&gt; takes ownership of the iterator and stops using indexing operations that borrow, we can move the &lt;code&gt;String&lt;/code&gt; values from the iterator into &lt;code&gt;Config&lt;/code&gt; rather than calling &lt;code&gt;clone&lt;/code&gt; and making a new allocation.</source>
          <target state="translated">일단 &lt;code&gt;Config::new&lt;/code&gt; 것을 빌려을 인덱싱 작업을 사용하여 반복자의 소유권을 정지, 우리는 이동할 수 있습니다 &lt;code&gt;String&lt;/code&gt; 로 반복자의 값 &lt;code&gt;Config&lt;/code&gt; 하지 않고 호출하는 대신 &lt;code&gt;clone&lt;/code&gt; 및 새로운 할당을.</target>
        </trans-unit>
        <trans-unit id="8b0de6bbc4d6a271545919a41560436f915e4647" translate="yes" xml:space="preserve">
          <source>Once a future has completed (returned &lt;code&gt;Ready&lt;/code&gt; from &lt;code&gt;poll&lt;/code&gt;), calling its &lt;code&gt;poll&lt;/code&gt; method again may panic, block forever, or cause other kinds of problems; the &lt;code&gt;Future&lt;/code&gt; trait places no requirements on the effects of such a call. However, as the &lt;code&gt;poll&lt;/code&gt; method is not marked &lt;code&gt;unsafe&lt;/code&gt;, Rust's usual rules apply: calls must never cause undefined behavior (memory corruption, incorrect use of &lt;code&gt;unsafe&lt;/code&gt; functions, or the like), regardless of the future's state.</source>
          <target state="translated">미래가 완료되면 ( &lt;code&gt;poll&lt;/code&gt; 에서 &lt;code&gt;Ready&lt;/code&gt; 완료로 돌아옴 ), &lt;code&gt;poll&lt;/code&gt; 방법을 다시 호출하면 패닉이 발생하거나 영원히 차단되거나 다른 종류의 문제가 발생할 수 있습니다. &lt;code&gt;Future&lt;/code&gt; 특성은 호출의 효과에 대한 요구 사항을 배치하지 않습니다. 그러나 &lt;code&gt;poll&lt;/code&gt; 방법이 &lt;code&gt;unsafe&lt;/code&gt; 로 표시되지 않으므로 Rust의 일반적인 규칙이 적용됩니다. 호출은 미래 상태에 관계없이 정의되지 않은 동작 (메모리 손상, &lt;code&gt;unsafe&lt;/code&gt; 기능 의 잘못된 사용 등)을 유발해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="472f512f503c00a7a3badf54bca4e8a984d78d81" translate="yes" xml:space="preserve">
          <source>Once a future has finished, clients should not &lt;code&gt;poll&lt;/code&gt; it again.</source>
          <target state="translated">미래가 끝나면 클라이언트는 다시 &lt;code&gt;poll&lt;/code&gt; 하지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="52d66dce2b0cbeb3ef0b4a40c595411581c4bf47" translate="yes" xml:space="preserve">
          <source>Once a valid size is received, our &lt;code&gt;ThreadPool&lt;/code&gt; creates a new vector that can hold &lt;code&gt;size&lt;/code&gt; items. We haven&amp;rsquo;t used the &lt;code&gt;with_capacity&lt;/code&gt; function in this book yet, which performs the same task as &lt;code&gt;Vec::new&lt;/code&gt; but with an important difference: it preallocates space in the vector. Because we know we need to store &lt;code&gt;size&lt;/code&gt; elements in the vector, doing this allocation up front is slightly more efficient than using &lt;code&gt;Vec::new&lt;/code&gt;, which resizes itself as elements are inserted.</source>
          <target state="translated">유효한 크기가 수신되면 &lt;code&gt;ThreadPool&lt;/code&gt; 은 &lt;code&gt;size&lt;/code&gt; 항목을 보유 할 수있는 새로운 벡터를 생성 합니다. 이 책 에서는 &lt;code&gt;with_capacity&lt;/code&gt; 함수를 아직 사용하지 않았습니다.이 함수는 &lt;code&gt;Vec::new&lt;/code&gt; 와 동일한 작업을 수행 하지만 중요한 차이점이 있습니다. 벡터의 공간을 미리 할당합니다. 벡터에 &lt;code&gt;size&lt;/code&gt; 요소 를 저장해야한다는 것을 알고 있기 때문에이 할당을 &lt;code&gt;Vec::new&lt;/code&gt; 하는 것은 요소가 삽입 될 때 자체 크기를 조정 하는 Vec :: new를 사용하는 것보다 약간 더 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="b9c2a150a70fbfb0f86650e1f5cd73ca0f595c49" translate="yes" xml:space="preserve">
          <source>Once again we're using &lt;code&gt;!&lt;/code&gt;'s ability to coerce into any other type, in this case &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;. Since this method takes a &lt;code&gt;&amp;amp;!&lt;/code&gt; as an argument we know that it can never be called (because there is no value of type &lt;code&gt;!&lt;/code&gt; for it to be called with). Writing &lt;code&gt;*self&lt;/code&gt; essentially tells the compiler &quot;We know that this code can never be run, so just treat the entire function body as having type &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;&quot;. This pattern can be used a lot when implementing traits for &lt;code&gt;!&lt;/code&gt;. Generally, any trait which only has methods which take a &lt;code&gt;self&lt;/code&gt; parameter should have such an impl.</source>
          <target state="translated">다시 한번 우리는 사용하고 있습니다 &lt;code&gt;!&lt;/code&gt; 이 경우의 다른 타입으로 강요의 능력, &lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt; . 이 방법은 &lt;code&gt;&amp;amp;!&lt;/code&gt; 인수로 우리는 호출 될 수 없다는 것을 알고 있습니다 (호출 할 유형의 값이 없기 때문에 &lt;code&gt;!&lt;/code&gt; ). &lt;code&gt;*self&lt;/code&gt; 를 작성 하면 본질적으로 컴파일러에게 &quot;이 코드를 실행할 수 없다는 것을 알고 있으므로 전체 함수 본문을 &lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt; 유형 &quot; 으로 취급하면 됩니다. 이 패턴은 특성을 구현할 때 많이 사용할 수 있습니다 &lt;code&gt;!&lt;/code&gt; . 일반적으로 &lt;code&gt;self&lt;/code&gt; 매개 변수 를 취하는 방법 만있는 특성 은 그러한 의미를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="3c60f2098dcfc1948a1cd5eb57c13cccf48d2d00" translate="yes" xml:space="preserve">
          <source>Once again, we compile and get... different errors! The compiler is teaching us a lot.</source>
          <target state="translated">다시 한 번, 컴파일하고 다른 오류가 발생합니다! 컴파일러는 우리에게 많은 것을 가르치고 있습니다.</target>
        </trans-unit>
        <trans-unit id="30ba447807ee16c40637ce8c42ca10892e8780ac" translate="yes" xml:space="preserve">
          <source>Once half of a channel has been deallocated, most operations can no longer continue to make progress, so &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; will be returned. Many applications will continue to &lt;a href=&quot;../../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt; the results returned from this module, instigating a propagation of failure among threads if one unexpectedly dies.</source>
          <target state="translated">채널의 절반이 할당 해제되면 대부분의 작업이 더 이상 진행을 계속할 수 없으므로 &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 이 반환됩니다. 많은 응용 프로그램 이이 모듈에서 반환 된 결과를 계속해서 &lt;a href=&quot;../../result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;unwrap&lt;/code&gt; &lt;/a&gt; 면서 예기치 않게 스레드가 중단 될 경우 스레드간에 오류가 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="a91c464fe4209e458222e2a75f2d92f1b46b0155" translate="yes" xml:space="preserve">
          <source>Once the internal storage is contiguous, the &lt;a href=&quot;../struct.vecdeque#method.as_slices&quot;&gt;&lt;code&gt;as_slices&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../struct.vecdeque#method.as_mut_slices&quot;&gt;&lt;code&gt;as_mut_slices&lt;/code&gt;&lt;/a&gt; methods will return the entire contents of the &lt;code&gt;VecDeque&lt;/code&gt; in a single slice.</source>
          <target state="translated">내부 저장 장치가 연속되면, &lt;a href=&quot;../struct.vecdeque#method.as_slices&quot;&gt; &lt;code&gt;as_slices&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../struct.vecdeque#method.as_mut_slices&quot;&gt; &lt;code&gt;as_mut_slices&lt;/code&gt; 의&lt;/a&gt; 방법은 그 전체 내용 반환 &lt;code&gt;VecDeque&lt;/code&gt; 을 한 조각이다.</target>
        </trans-unit>
        <trans-unit id="6364bb4d426e3f0cecb2911427f26ed73152d755" translate="yes" xml:space="preserve">
          <source>Once the internal storage is contiguous, the &lt;a href=&quot;struct.vecdeque#method.as_slices&quot;&gt;&lt;code&gt;as_slices&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.vecdeque#method.as_mut_slices&quot;&gt;&lt;code&gt;as_mut_slices&lt;/code&gt;&lt;/a&gt; methods will return the entire contents of the &lt;code&gt;VecDeque&lt;/code&gt; in a single slice.</source>
          <target state="translated">내부 저장 장치가 연속되면, &lt;a href=&quot;struct.vecdeque#method.as_slices&quot;&gt; &lt;code&gt;as_slices&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.vecdeque#method.as_mut_slices&quot;&gt; &lt;code&gt;as_mut_slices&lt;/code&gt; 의&lt;/a&gt; 방법은 그 전체 내용 반환 &lt;code&gt;VecDeque&lt;/code&gt; 을 한 조각이다.</target>
        </trans-unit>
        <trans-unit id="7b36c9a4ffe1c545648e7557d44e1b469b4df260" translate="yes" xml:space="preserve">
          <source>Once this function returns, the contents of &lt;code&gt;bufs&lt;/code&gt; are unspecified, as this depends on how many calls to &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt; were necessary. It is best to understand this function as taking ownership of &lt;code&gt;bufs&lt;/code&gt; and to not use &lt;code&gt;bufs&lt;/code&gt; afterwards. The underlying buffers, to which the &lt;a href=&quot;struct.ioslice&quot;&gt;&lt;code&gt;IoSlice&lt;/code&gt;&lt;/a&gt;s point (but not the &lt;a href=&quot;struct.ioslice&quot;&gt;&lt;code&gt;IoSlice&lt;/code&gt;&lt;/a&gt;s themselves), are unchanged and can be reused.</source>
          <target state="translated">이 함수가 반환되면 &lt;code&gt;bufs&lt;/code&gt; 의 내용 이 지정되지 않습니다. &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt; &lt;code&gt;write_vectored&lt;/code&gt; &lt;/a&gt; 에 대한 호출 이 필요한 횟수 에 따라 달라집니다 . 이 기능은 &lt;code&gt;bufs&lt;/code&gt; 의 소유권을 가지고 나중에 &lt;code&gt;bufs&lt;/code&gt; 를 사용하지 않는 것으로 이해하는 것이 가장 좋습니다 . &lt;a href=&quot;struct.ioslice&quot;&gt; &lt;code&gt;IoSlice&lt;/code&gt; &lt;/a&gt; 가 가리키는 기본 버퍼 ( &lt;a href=&quot;struct.ioslice&quot;&gt; &lt;code&gt;IoSlice&lt;/code&gt; &lt;/a&gt; 자체는 아님)는 변경되지 않으며 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fa4b20ac7b7c2a8a0f92535a2333b6aa807706f" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve created an iterator, we can use it in a variety of ways. In Listing 3-5 in Chapter 3, we used iterators with &lt;code&gt;for&lt;/code&gt; loops to execute some code on each item, although we glossed over what the call to &lt;code&gt;iter&lt;/code&gt; did until now.</source>
          <target state="translated">반복자를 만든 후에는 다양한 방법으로 사용할 수 있습니다. 3 장의 목록 3-5에서 &lt;code&gt;for&lt;/code&gt; 루프 와 함께 반복자를 사용 하여 각 항목에 대해 일부 코드를 실행했지만 지금까지 &lt;code&gt;iter&lt;/code&gt; 호출이 수행 한 작업에 대해 설명했습니다 .</target>
        </trans-unit>
        <trans-unit id="58851a1903858c976f2730a714ae3f3f46765304" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve implemented the &lt;code&gt;Iterator&lt;/code&gt; trait, we have an iterator! Listing 13-22 shows a test demonstrating that we can use the iterator functionality of our &lt;code&gt;Counter&lt;/code&gt; struct by calling the &lt;code&gt;next&lt;/code&gt; method on it directly, just as we did with the iterator created from a vector in Listing 13-15.</source>
          <target state="translated">&lt;code&gt;Iterator&lt;/code&gt; 특성을 구현하면 반복자 가 있습니다! Listing 13-22는 Listing 13-15의 벡터에서 생성 된 이터레이터에서와 마찬가지로 &lt;code&gt;next&lt;/code&gt; 메소드를 직접 호출하여 &lt;code&gt;Counter&lt;/code&gt; 구조체 의 이터레이터 기능을 사용할 수 있음을 보여주는 테스트를 보여준다 .</target>
        </trans-unit>
        <trans-unit id="84bcbd885f09e288fb3013478b1c1b345aab434e" translate="yes" xml:space="preserve">
          <source>Once you are familiar with the contents of the standard library you may begin to find the verbosity of the prose distracting. At this stage in your development you may want to press the &lt;code&gt;[-]&lt;/code&gt; button near the top of the page to collapse it into a more skimmable view.</source>
          <target state="translated">표준 라이브러리의 내용에 익숙해지면 산만 산만 함의 장황함을 찾기 시작할 수 있습니다. 개발 단계에서 페이지 상단 부근의 &lt;code&gt;[-]&lt;/code&gt; 버튼 을 눌러 더보기 좋게 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9e4ff73fcbf2b9b71b1855afa48c76c6aa49139" translate="yes" xml:space="preserve">
          <source>Once you have the kind of slice you need (with or without a nul terminator), you can call the slice's own &lt;a href=&quot;../primitive.slice#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; method to get a read-only raw pointer to pass to extern functions. See the documentation for that function for a discussion on ensuring the lifetime of the raw pointer.</source>
          <target state="translated">필요한 종류의 슬라이스가 있으면 (널 터미네이터를 사용하거나 사용하지 않고) 슬라이스 자체 &lt;a href=&quot;../primitive.slice#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 extern 함수에 전달할 읽기 전용 원시 포인터를 얻을 수 있습니다. 원시 포인터의 수명을 보장하는 것에 대한 설명은 해당 기능의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ef776c26c7f6b2f89aaf4c349afba29be9ab2040" translate="yes" xml:space="preserve">
          <source>Once::all</source>
          <target state="translated">Once::all</target>
        </trans-unit>
        <trans-unit id="fa85c00dce196844734611fc55302ba498cdda9b" translate="yes" xml:space="preserve">
          <source>Once::any</source>
          <target state="translated">Once::any</target>
        </trans-unit>
        <trans-unit id="826f1ec43224196e7c0e18a9f4c8ba3d03de27f1" translate="yes" xml:space="preserve">
          <source>Once::borrow</source>
          <target state="translated">Once::borrow</target>
        </trans-unit>
        <trans-unit id="e53e91b8fe24cb0570a1a97b3316a02ec5d3ee03" translate="yes" xml:space="preserve">
          <source>Once::borrow_mut</source>
          <target state="translated">Once::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c2f8e8374534fd9f5e2ff592398a6ffc6014fd99" translate="yes" xml:space="preserve">
          <source>Once::by_ref</source>
          <target state="translated">Once::by_ref</target>
        </trans-unit>
        <trans-unit id="28a72e0c985bccd2edce22b1340d3ed027a4ac1f" translate="yes" xml:space="preserve">
          <source>Once::call_once</source>
          <target state="translated">Once::call_once</target>
        </trans-unit>
        <trans-unit id="e0cfc1e91951cfca51a0190fd8a21d0b035190a9" translate="yes" xml:space="preserve">
          <source>Once::call_once_force</source>
          <target state="translated">Once::call_once_force</target>
        </trans-unit>
        <trans-unit id="1376857cb86f72af6eff74ad397cf00fcde6210e" translate="yes" xml:space="preserve">
          <source>Once::chain</source>
          <target state="translated">Once::chain</target>
        </trans-unit>
        <trans-unit id="190ff92b2c593bf6e13bca7abde87e505a3ec2bb" translate="yes" xml:space="preserve">
          <source>Once::clone</source>
          <target state="translated">Once::clone</target>
        </trans-unit>
        <trans-unit id="212f098b1763e1e51ae7f7bc19ffa302ddfe30a1" translate="yes" xml:space="preserve">
          <source>Once::clone_from</source>
          <target state="translated">Once::clone_from</target>
        </trans-unit>
        <trans-unit id="311f7aa02f0a54433f61dae481c3b3e4040d2495" translate="yes" xml:space="preserve">
          <source>Once::clone_into</source>
          <target state="translated">Once::clone_into</target>
        </trans-unit>
        <trans-unit id="19afa196b08d6f8f3b6f43f40d2d7cd3c50fbc8f" translate="yes" xml:space="preserve">
          <source>Once::cloned</source>
          <target state="translated">Once::cloned</target>
        </trans-unit>
        <trans-unit id="6b4930ea79c81962eae48dcaf70c7227f1aa12a7" translate="yes" xml:space="preserve">
          <source>Once::cmp</source>
          <target state="translated">Once::cmp</target>
        </trans-unit>
        <trans-unit id="5d169980cad74ac2c6880808ed94fb787b98960a" translate="yes" xml:space="preserve">
          <source>Once::collect</source>
          <target state="translated">Once::collect</target>
        </trans-unit>
        <trans-unit id="313d94ea32a51b1b516cb8b52850728efe9ae8b5" translate="yes" xml:space="preserve">
          <source>Once::copied</source>
          <target state="translated">Once::copied</target>
        </trans-unit>
        <trans-unit id="f98560cce6e4eadc3911ce81d61f52d107ea5142" translate="yes" xml:space="preserve">
          <source>Once::count</source>
          <target state="translated">Once::count</target>
        </trans-unit>
        <trans-unit id="2ef6bd0928aad3dcaf46fb7f0bdafb3492745ec4" translate="yes" xml:space="preserve">
          <source>Once::cycle</source>
          <target state="translated">Once::cycle</target>
        </trans-unit>
        <trans-unit id="8ad5b4150f82970fff0038e17ac64a51521d1924" translate="yes" xml:space="preserve">
          <source>Once::enumerate</source>
          <target state="translated">Once::enumerate</target>
        </trans-unit>
        <trans-unit id="23c903ad536fa2bd73035fce46787048ed4f628a" translate="yes" xml:space="preserve">
          <source>Once::eq</source>
          <target state="translated">Once::eq</target>
        </trans-unit>
        <trans-unit id="82879e4fcf39171c09b466e2bf43bc8f45af6822" translate="yes" xml:space="preserve">
          <source>Once::filter</source>
          <target state="translated">Once::filter</target>
        </trans-unit>
        <trans-unit id="095605951ca140555bd59e4149308c63f272478d" translate="yes" xml:space="preserve">
          <source>Once::filter_map</source>
          <target state="translated">Once::filter_map</target>
        </trans-unit>
        <trans-unit id="7ca070326207c327aa1bb557f657f2fac61b1c8a" translate="yes" xml:space="preserve">
          <source>Once::find</source>
          <target state="translated">Once::find</target>
        </trans-unit>
        <trans-unit id="f8cbae0491d42da2ee0b9caaa6d41cbeef0233e4" translate="yes" xml:space="preserve">
          <source>Once::find_map</source>
          <target state="translated">Once::find_map</target>
        </trans-unit>
        <trans-unit id="8f0358e16d2477b8dc5e572ca1dae6005b455b17" translate="yes" xml:space="preserve">
          <source>Once::flat_map</source>
          <target state="translated">Once::flat_map</target>
        </trans-unit>
        <trans-unit id="8580b5a613c1d1f4df99cede210bdc2e9fe3a843" translate="yes" xml:space="preserve">
          <source>Once::flatten</source>
          <target state="translated">Once::flatten</target>
        </trans-unit>
        <trans-unit id="c9a403b6a5f9f7ce825a2ce8e6b8fc78c53b4261" translate="yes" xml:space="preserve">
          <source>Once::fmt</source>
          <target state="translated">Once::fmt</target>
        </trans-unit>
        <trans-unit id="a4dbe0ef075896956284d0f6da5e3cf48dd08238" translate="yes" xml:space="preserve">
          <source>Once::fold</source>
          <target state="translated">Once::fold</target>
        </trans-unit>
        <trans-unit id="9129023999880ed84891680b4f8fd96dda590894" translate="yes" xml:space="preserve">
          <source>Once::for_each</source>
          <target state="translated">Once::for_each</target>
        </trans-unit>
        <trans-unit id="d64f18e6780e0faf671ed9d539a0b268b8174066" translate="yes" xml:space="preserve">
          <source>Once::from</source>
          <target state="translated">Once::from</target>
        </trans-unit>
        <trans-unit id="bbf7ace21ce049891d14dd08bdb7b81831f05411" translate="yes" xml:space="preserve">
          <source>Once::fuse</source>
          <target state="translated">Once::fuse</target>
        </trans-unit>
        <trans-unit id="6d843124e3a2669cb3c40cac626394b00fbd78a9" translate="yes" xml:space="preserve">
          <source>Once::ge</source>
          <target state="translated">Once::ge</target>
        </trans-unit>
        <trans-unit id="a9af56769b34f56c5ffcf89a8ea47ff768c6858a" translate="yes" xml:space="preserve">
          <source>Once::gt</source>
          <target state="translated">Once::gt</target>
        </trans-unit>
        <trans-unit id="52b97e5420ac6c5141f11b243b00d6a1d91a82aa" translate="yes" xml:space="preserve">
          <source>Once::inspect</source>
          <target state="translated">Once::inspect</target>
        </trans-unit>
        <trans-unit id="24c9670c06579750ad91802403773c861f00f73c" translate="yes" xml:space="preserve">
          <source>Once::into</source>
          <target state="translated">Once::into</target>
        </trans-unit>
        <trans-unit id="efb0afcea9cf69ad9f300407891f7cf24889abde" translate="yes" xml:space="preserve">
          <source>Once::into_iter</source>
          <target state="translated">Once::into_iter</target>
        </trans-unit>
        <trans-unit id="0608fd7f8eac14cce16ca80dbfd5613b14204122" translate="yes" xml:space="preserve">
          <source>Once::is_completed</source>
          <target state="translated">Once::is_completed</target>
        </trans-unit>
        <trans-unit id="7251c3dcf49fe3c4c5830d926dcb3f340b9a4518" translate="yes" xml:space="preserve">
          <source>Once::is_empty</source>
          <target state="translated">Once::is_empty</target>
        </trans-unit>
        <trans-unit id="4b0fbfe12c4a015929a04dd53407a0499a03410c" translate="yes" xml:space="preserve">
          <source>Once::is_sorted</source>
          <target state="translated">Once::is_sorted</target>
        </trans-unit>
        <trans-unit id="6f25e0f3331d93f4e5eb47652d49ab83abddd5c6" translate="yes" xml:space="preserve">
          <source>Once::is_sorted_by</source>
          <target state="translated">Once::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="cb7a1da6af62c62d1c48e6f892b45246ff8fb722" translate="yes" xml:space="preserve">
          <source>Once::is_sorted_by_key</source>
          <target state="translated">Once::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="12b8716333449d7ef6ccc84a866d8c71f4d4596a" translate="yes" xml:space="preserve">
          <source>Once::last</source>
          <target state="translated">Once::last</target>
        </trans-unit>
        <trans-unit id="14b21ec5ab3251444e0715d08a995824bf98046f" translate="yes" xml:space="preserve">
          <source>Once::le</source>
          <target state="translated">Once::le</target>
        </trans-unit>
        <trans-unit id="c7ec127a76b81f92cbddfa60f7e443869f07dfc3" translate="yes" xml:space="preserve">
          <source>Once::len</source>
          <target state="translated">Once::len</target>
        </trans-unit>
        <trans-unit id="5200802a32d08edabd28e77c8bfacda66faabb5f" translate="yes" xml:space="preserve">
          <source>Once::lt</source>
          <target state="translated">Once::lt</target>
        </trans-unit>
        <trans-unit id="f2976b7d4debc6f0c6faff19e72feb23c6da98c9" translate="yes" xml:space="preserve">
          <source>Once::map</source>
          <target state="translated">Once::map</target>
        </trans-unit>
        <trans-unit id="37c43ed9043bf5a1d86c776c7a83980f8e44b550" translate="yes" xml:space="preserve">
          <source>Once::max</source>
          <target state="translated">Once::max</target>
        </trans-unit>
        <trans-unit id="42f687a90cb8ae799fc923fe98bf332780e16e1a" translate="yes" xml:space="preserve">
          <source>Once::max_by</source>
          <target state="translated">Once::max_by</target>
        </trans-unit>
        <trans-unit id="f790fae0c1ab8520d2b3bb6dee8c10e0df61fb21" translate="yes" xml:space="preserve">
          <source>Once::max_by_key</source>
          <target state="translated">Once::max_by_key</target>
        </trans-unit>
        <trans-unit id="be86a53ca110f0c0f2e5f786db25770b11e8fb89" translate="yes" xml:space="preserve">
          <source>Once::min</source>
          <target state="translated">Once::min</target>
        </trans-unit>
        <trans-unit id="5b4c2bfd34d4ce8913a24cdbba40c903c58ba228" translate="yes" xml:space="preserve">
          <source>Once::min_by</source>
          <target state="translated">Once::min_by</target>
        </trans-unit>
        <trans-unit id="0ff4bd1f1edb9d1e53ee61824c45a6b65f4eafd0" translate="yes" xml:space="preserve">
          <source>Once::min_by_key</source>
          <target state="translated">Once::min_by_key</target>
        </trans-unit>
        <trans-unit id="6236fe088142c957857770ab09a2b6fc2f27b69e" translate="yes" xml:space="preserve">
          <source>Once::ne</source>
          <target state="translated">Once::ne</target>
        </trans-unit>
        <trans-unit id="7d6911dda1f2483e209159a8e136b2c52051e6bb" translate="yes" xml:space="preserve">
          <source>Once::new</source>
          <target state="translated">Once::new</target>
        </trans-unit>
        <trans-unit id="578bd116c5e7fde5716979b05be2a783abe2fcec" translate="yes" xml:space="preserve">
          <source>Once::next</source>
          <target state="translated">Once::next</target>
        </trans-unit>
        <trans-unit id="8af821c9e317f67614d97739eed7d7394a46629b" translate="yes" xml:space="preserve">
          <source>Once::next_back</source>
          <target state="translated">Once::next_back</target>
        </trans-unit>
        <trans-unit id="430bb3482a938ef6cd7fe977041d4fa3bbc1fc55" translate="yes" xml:space="preserve">
          <source>Once::nth</source>
          <target state="translated">Once::nth</target>
        </trans-unit>
        <trans-unit id="c55b0c5a25d6a4c7729b67045964bd182f6c743b" translate="yes" xml:space="preserve">
          <source>Once::nth_back</source>
          <target state="translated">Once::nth_back</target>
        </trans-unit>
        <trans-unit id="22c36618829e3a03fdefff9bbca40dbd8e473846" translate="yes" xml:space="preserve">
          <source>Once::partial_cmp</source>
          <target state="translated">Once::partial_cmp</target>
        </trans-unit>
        <trans-unit id="b7269ba05ed7753f4b47e7a0b54fad46c7fdfa25" translate="yes" xml:space="preserve">
          <source>Once::partition</source>
          <target state="translated">Once::partition</target>
        </trans-unit>
        <trans-unit id="a2a93318d906b75ba7d478b7d2053f09b5d47c8e" translate="yes" xml:space="preserve">
          <source>Once::peekable</source>
          <target state="translated">Once::peekable</target>
        </trans-unit>
        <trans-unit id="443ba5a518af1ceeeb00165b521452d07ea04e5b" translate="yes" xml:space="preserve">
          <source>Once::position</source>
          <target state="translated">Once::position</target>
        </trans-unit>
        <trans-unit id="aefb04c2392cc211f451d367f733cc6c65c3e11b" translate="yes" xml:space="preserve">
          <source>Once::product</source>
          <target state="translated">Once::product</target>
        </trans-unit>
        <trans-unit id="0bc9c08f73c34cac78d945ebc22d8397bbb66131" translate="yes" xml:space="preserve">
          <source>Once::rev</source>
          <target state="translated">Once::rev</target>
        </trans-unit>
        <trans-unit id="3c7856aff7c1c10689eb91760b905ac36a86fd8f" translate="yes" xml:space="preserve">
          <source>Once::rfind</source>
          <target state="translated">Once::rfind</target>
        </trans-unit>
        <trans-unit id="bb98b537fa90b815cfad245be9b6f8a9980c10ad" translate="yes" xml:space="preserve">
          <source>Once::rfold</source>
          <target state="translated">Once::rfold</target>
        </trans-unit>
        <trans-unit id="068dbc2b0446d02924974dc89dc2e5c0506be3c0" translate="yes" xml:space="preserve">
          <source>Once::rposition</source>
          <target state="translated">Once::rposition</target>
        </trans-unit>
        <trans-unit id="2f7d42081a9a3b1a18973e17303b804987f7c991" translate="yes" xml:space="preserve">
          <source>Once::scan</source>
          <target state="translated">Once::scan</target>
        </trans-unit>
        <trans-unit id="689e357b41f0be20a1862814b9c83d77ef8f1e70" translate="yes" xml:space="preserve">
          <source>Once::size_hint</source>
          <target state="translated">Once::size_hint</target>
        </trans-unit>
        <trans-unit id="cbf339d38d49468cb345d7cfb9cb77b78f365fd1" translate="yes" xml:space="preserve">
          <source>Once::skip</source>
          <target state="translated">Once::skip</target>
        </trans-unit>
        <trans-unit id="86fd91a24a1bbc66ca2ece695858498a65db16dd" translate="yes" xml:space="preserve">
          <source>Once::skip_while</source>
          <target state="translated">Once::skip_while</target>
        </trans-unit>
        <trans-unit id="6fe0f81f7153271dc977040947a6cad61882f9d1" translate="yes" xml:space="preserve">
          <source>Once::step_by</source>
          <target state="translated">Once::step_by</target>
        </trans-unit>
        <trans-unit id="033b2578f1615ee184814d95335d5fd74302c231" translate="yes" xml:space="preserve">
          <source>Once::sum</source>
          <target state="translated">Once::sum</target>
        </trans-unit>
        <trans-unit id="442e2927616d29972c328197ab646af0a109e0ac" translate="yes" xml:space="preserve">
          <source>Once::take</source>
          <target state="translated">Once::take</target>
        </trans-unit>
        <trans-unit id="e0055054cf1a45bf179b412f905b6b7b804fe427" translate="yes" xml:space="preserve">
          <source>Once::take_while</source>
          <target state="translated">Once::take_while</target>
        </trans-unit>
        <trans-unit id="1ff7fdb84e0ce09813e50c320654790d32c718fe" translate="yes" xml:space="preserve">
          <source>Once::to_owned</source>
          <target state="translated">Once::to_owned</target>
        </trans-unit>
        <trans-unit id="b045ee709dc7ad89b9c21500aecbcde1537d7e58" translate="yes" xml:space="preserve">
          <source>Once::try_fold</source>
          <target state="translated">Once::try_fold</target>
        </trans-unit>
        <trans-unit id="ca7011c5d5b35881f4391164193c191f7c91a8ed" translate="yes" xml:space="preserve">
          <source>Once::try_for_each</source>
          <target state="translated">Once::try_for_each</target>
        </trans-unit>
        <trans-unit id="145392f846fa35a3754a9cdb737cf3389c9b3bb1" translate="yes" xml:space="preserve">
          <source>Once::try_from</source>
          <target state="translated">Once::try_from</target>
        </trans-unit>
        <trans-unit id="36d585158ca953d0dbbe69c61419f1e9cfd5cbd0" translate="yes" xml:space="preserve">
          <source>Once::try_into</source>
          <target state="translated">Once::try_into</target>
        </trans-unit>
        <trans-unit id="bb47966988d0ea30157cfc9b32edfc0454ef3340" translate="yes" xml:space="preserve">
          <source>Once::try_rfold</source>
          <target state="translated">Once::try_rfold</target>
        </trans-unit>
        <trans-unit id="0e7005b30f23dbe8e521fbb090487b02e260839e" translate="yes" xml:space="preserve">
          <source>Once::type_id</source>
          <target state="translated">Once::type_id</target>
        </trans-unit>
        <trans-unit id="89b4b7dbbcd40342a9b06361de2f912cf9887391" translate="yes" xml:space="preserve">
          <source>Once::unzip</source>
          <target state="translated">Once::unzip</target>
        </trans-unit>
        <trans-unit id="9c587dbc5b4ada9eb96816888453bd9099854f2c" translate="yes" xml:space="preserve">
          <source>Once::zip</source>
          <target state="translated">Once::zip</target>
        </trans-unit>
        <trans-unit id="69dcb4de79e8a81381a0466b75f257a36ecf89cd" translate="yes" xml:space="preserve">
          <source>OnceCell</source>
          <target state="translated">OnceCell</target>
        </trans-unit>
        <trans-unit id="2db71cb543a4836972aba340022bf66c34ca9483" translate="yes" xml:space="preserve">
          <source>OnceState</source>
          <target state="translated">OnceState</target>
        </trans-unit>
        <trans-unit id="864b2494c0a17291fe44802d2dfa7280c6515a58" translate="yes" xml:space="preserve">
          <source>OnceState::borrow</source>
          <target state="translated">OnceState::borrow</target>
        </trans-unit>
        <trans-unit id="3ba03425574355acef161a03b37753e3dc3fce0d" translate="yes" xml:space="preserve">
          <source>OnceState::borrow_mut</source>
          <target state="translated">OnceState::borrow_mut</target>
        </trans-unit>
        <trans-unit id="137f612918b3ff9f01b5b2eed8a892cbbde080f1" translate="yes" xml:space="preserve">
          <source>OnceState::fmt</source>
          <target state="translated">OnceState::fmt</target>
        </trans-unit>
        <trans-unit id="cc9d74ec28c33e153d2d0894a6de5f14c5c9aabd" translate="yes" xml:space="preserve">
          <source>OnceState::from</source>
          <target state="translated">OnceState::from</target>
        </trans-unit>
        <trans-unit id="d968db4b631f42cce77d0ea2bff8656be4e57c06" translate="yes" xml:space="preserve">
          <source>OnceState::into</source>
          <target state="translated">OnceState::into</target>
        </trans-unit>
        <trans-unit id="5279da3ce88f5a2ebd344f9b9ae566f2cb009268" translate="yes" xml:space="preserve">
          <source>OnceState::poisoned</source>
          <target state="translated">OnceState::poisoned</target>
        </trans-unit>
        <trans-unit id="8447bc72e127b3443efef418a2e8188e3cc3f620" translate="yes" xml:space="preserve">
          <source>OnceState::try_from</source>
          <target state="translated">OnceState::try_from</target>
        </trans-unit>
        <trans-unit id="2a35fc55239b76803a74ad10688fe793f6102501" translate="yes" xml:space="preserve">
          <source>OnceState::try_into</source>
          <target state="translated">OnceState::try_into</target>
        </trans-unit>
        <trans-unit id="fcd8d541e6822fd809940974bebc8a81f8b16c8d" translate="yes" xml:space="preserve">
          <source>OnceState::type_id</source>
          <target state="translated">OnceState::type_id</target>
        </trans-unit>
        <trans-unit id="bac414ebd5a08ef0bd8f0f09a9b6b081da1540b4" translate="yes" xml:space="preserve">
          <source>OnceWith</source>
          <target state="translated">OnceWith</target>
        </trans-unit>
        <trans-unit id="9421b02fba334e65b31591c89d7fcfa34aea5e57" translate="yes" xml:space="preserve">
          <source>OnceWith::all</source>
          <target state="translated">OnceWith::all</target>
        </trans-unit>
        <trans-unit id="ec045f959571abb529fe845ffb143c5aa440d98a" translate="yes" xml:space="preserve">
          <source>OnceWith::any</source>
          <target state="translated">OnceWith::any</target>
        </trans-unit>
        <trans-unit id="1ef37dd0c57f299c431f6fc7296ed50225f08e1a" translate="yes" xml:space="preserve">
          <source>OnceWith::borrow</source>
          <target state="translated">OnceWith::borrow</target>
        </trans-unit>
        <trans-unit id="527f129227b962c7154dfbbc8fa56239753273a3" translate="yes" xml:space="preserve">
          <source>OnceWith::borrow_mut</source>
          <target state="translated">OnceWith::borrow_mut</target>
        </trans-unit>
        <trans-unit id="220386db15c3ac797f2d78a1fa6328e0e524bbaa" translate="yes" xml:space="preserve">
          <source>OnceWith::by_ref</source>
          <target state="translated">OnceWith::by_ref</target>
        </trans-unit>
        <trans-unit id="8cca4e55ae50dd0aee68afe79ea244d5bca99ced" translate="yes" xml:space="preserve">
          <source>OnceWith::chain</source>
          <target state="translated">OnceWith::chain</target>
        </trans-unit>
        <trans-unit id="69a3e8d814785ab85c33556c6a099c9cc6ea940e" translate="yes" xml:space="preserve">
          <source>OnceWith::clone</source>
          <target state="translated">OnceWith::clone</target>
        </trans-unit>
        <trans-unit id="18ada5e17d413555745065a07348ed90106c203d" translate="yes" xml:space="preserve">
          <source>OnceWith::clone_from</source>
          <target state="translated">OnceWith::clone_from</target>
        </trans-unit>
        <trans-unit id="840d6af9e9dfbf237e7af2ccf27dbd5ad69cee46" translate="yes" xml:space="preserve">
          <source>OnceWith::clone_into</source>
          <target state="translated">OnceWith::clone_into</target>
        </trans-unit>
        <trans-unit id="28fb35fd1901c33eee7b84b451b7753c7c867260" translate="yes" xml:space="preserve">
          <source>OnceWith::cloned</source>
          <target state="translated">OnceWith::cloned</target>
        </trans-unit>
        <trans-unit id="30d119dee0d9c070c3e61005d6831099ce8bd793" translate="yes" xml:space="preserve">
          <source>OnceWith::cmp</source>
          <target state="translated">OnceWith::cmp</target>
        </trans-unit>
        <trans-unit id="abe9447efe3162bb1b99fa4be3a78e85a49dc04b" translate="yes" xml:space="preserve">
          <source>OnceWith::collect</source>
          <target state="translated">OnceWith::collect</target>
        </trans-unit>
        <trans-unit id="4d6da14365d0d73a28c1b23f782a042915618b92" translate="yes" xml:space="preserve">
          <source>OnceWith::copied</source>
          <target state="translated">OnceWith::copied</target>
        </trans-unit>
        <trans-unit id="7016f9903cc220eec1b3d930f0d6d91062934899" translate="yes" xml:space="preserve">
          <source>OnceWith::count</source>
          <target state="translated">OnceWith::count</target>
        </trans-unit>
        <trans-unit id="addfc373b9df5fc305b9e5e6eb635cd2466d07d4" translate="yes" xml:space="preserve">
          <source>OnceWith::cycle</source>
          <target state="translated">OnceWith::cycle</target>
        </trans-unit>
        <trans-unit id="095f0dc0c2b642b81131fb698197ca6766b54a2e" translate="yes" xml:space="preserve">
          <source>OnceWith::enumerate</source>
          <target state="translated">OnceWith::enumerate</target>
        </trans-unit>
        <trans-unit id="7e9ec613a8f6c55d8eb6ea553ee7ebd7e6244ce6" translate="yes" xml:space="preserve">
          <source>OnceWith::eq</source>
          <target state="translated">OnceWith::eq</target>
        </trans-unit>
        <trans-unit id="f3f3ad0faefd45bbd859ece3bf3eef9075759214" translate="yes" xml:space="preserve">
          <source>OnceWith::filter</source>
          <target state="translated">OnceWith::filter</target>
        </trans-unit>
        <trans-unit id="ea81115d4b00890df3a160e9b9a84ff71ded3a01" translate="yes" xml:space="preserve">
          <source>OnceWith::filter_map</source>
          <target state="translated">OnceWith::filter_map</target>
        </trans-unit>
        <trans-unit id="04462b9dd7bbda24ad2bd90e2b7883781de4acd6" translate="yes" xml:space="preserve">
          <source>OnceWith::find</source>
          <target state="translated">OnceWith::find</target>
        </trans-unit>
        <trans-unit id="aca2dee92401221e00169ab44175f018d2db65f4" translate="yes" xml:space="preserve">
          <source>OnceWith::find_map</source>
          <target state="translated">OnceWith::find_map</target>
        </trans-unit>
        <trans-unit id="10d39de4f24d2dcddb78ea6874f21fecb0e42b39" translate="yes" xml:space="preserve">
          <source>OnceWith::flat_map</source>
          <target state="translated">OnceWith::flat_map</target>
        </trans-unit>
        <trans-unit id="6ff780249f2a51d00d5d95dcfd4610dadafd2bd8" translate="yes" xml:space="preserve">
          <source>OnceWith::flatten</source>
          <target state="translated">OnceWith::flatten</target>
        </trans-unit>
        <trans-unit id="e7394a8ea887cd043223fc687a97cc1f193256c1" translate="yes" xml:space="preserve">
          <source>OnceWith::fmt</source>
          <target state="translated">OnceWith::fmt</target>
        </trans-unit>
        <trans-unit id="5e004a4ea95a589f773f9befbef25abe72f46ba2" translate="yes" xml:space="preserve">
          <source>OnceWith::fold</source>
          <target state="translated">OnceWith::fold</target>
        </trans-unit>
        <trans-unit id="0826514ea858174b22832240424d387a6a62a698" translate="yes" xml:space="preserve">
          <source>OnceWith::for_each</source>
          <target state="translated">OnceWith::for_each</target>
        </trans-unit>
        <trans-unit id="6f44e41130791319e6c6d5e080615570ac91fa72" translate="yes" xml:space="preserve">
          <source>OnceWith::from</source>
          <target state="translated">OnceWith::from</target>
        </trans-unit>
        <trans-unit id="d991094123caac201e372f78da1221c72316dec1" translate="yes" xml:space="preserve">
          <source>OnceWith::fuse</source>
          <target state="translated">OnceWith::fuse</target>
        </trans-unit>
        <trans-unit id="491865c492a9358b9d74d7461f65fbb3c2ad3116" translate="yes" xml:space="preserve">
          <source>OnceWith::ge</source>
          <target state="translated">OnceWith::ge</target>
        </trans-unit>
        <trans-unit id="cb6cb84ba3cef039e288bea61f9e271654ca16b3" translate="yes" xml:space="preserve">
          <source>OnceWith::gt</source>
          <target state="translated">OnceWith::gt</target>
        </trans-unit>
        <trans-unit id="f9bca0dbc5eb1308057e3acda537f87ae5584bf0" translate="yes" xml:space="preserve">
          <source>OnceWith::inspect</source>
          <target state="translated">OnceWith::inspect</target>
        </trans-unit>
        <trans-unit id="130c0779f2fab716215af75fb82426f43a016224" translate="yes" xml:space="preserve">
          <source>OnceWith::into</source>
          <target state="translated">OnceWith::into</target>
        </trans-unit>
        <trans-unit id="e53104deb8174e788d926bdbaa53ed5840ec7390" translate="yes" xml:space="preserve">
          <source>OnceWith::into_iter</source>
          <target state="translated">OnceWith::into_iter</target>
        </trans-unit>
        <trans-unit id="57fb266c4456dcf8194282f31a9c9693a675f52f" translate="yes" xml:space="preserve">
          <source>OnceWith::is_empty</source>
          <target state="translated">OnceWith::is_empty</target>
        </trans-unit>
        <trans-unit id="35067e17a5dc55a4bb918b85dcd10ca948035cb7" translate="yes" xml:space="preserve">
          <source>OnceWith::is_sorted</source>
          <target state="translated">OnceWith::is_sorted</target>
        </trans-unit>
        <trans-unit id="fa54dbd797d14264ee865bf4783d41bbaaceb9bb" translate="yes" xml:space="preserve">
          <source>OnceWith::is_sorted_by</source>
          <target state="translated">OnceWith::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="0805f33825aaffa765bd319b5f5123f28e25c541" translate="yes" xml:space="preserve">
          <source>OnceWith::is_sorted_by_key</source>
          <target state="translated">OnceWith::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="b8642e0e6fa2a743b75cee962cacad7d55075240" translate="yes" xml:space="preserve">
          <source>OnceWith::last</source>
          <target state="translated">OnceWith::last</target>
        </trans-unit>
        <trans-unit id="93fa8fd9eba96e349d5cb407b64fe72f152eb5a8" translate="yes" xml:space="preserve">
          <source>OnceWith::le</source>
          <target state="translated">OnceWith::le</target>
        </trans-unit>
        <trans-unit id="7222c5552e670e1ab40e927a15a3bb3893a18137" translate="yes" xml:space="preserve">
          <source>OnceWith::len</source>
          <target state="translated">OnceWith::len</target>
        </trans-unit>
        <trans-unit id="115bc72442e41419d2748702b3dc2105c1045ca1" translate="yes" xml:space="preserve">
          <source>OnceWith::lt</source>
          <target state="translated">OnceWith::lt</target>
        </trans-unit>
        <trans-unit id="4a5a3ea857244c9e36891ebf8831e5ae98613302" translate="yes" xml:space="preserve">
          <source>OnceWith::map</source>
          <target state="translated">OnceWith::map</target>
        </trans-unit>
        <trans-unit id="e13117c44b319bc7f0f9709faa2a5544da1bccc4" translate="yes" xml:space="preserve">
          <source>OnceWith::max</source>
          <target state="translated">OnceWith::max</target>
        </trans-unit>
        <trans-unit id="5fe974dd4baeb92c36de177f1091466a40a950e9" translate="yes" xml:space="preserve">
          <source>OnceWith::max_by</source>
          <target state="translated">OnceWith::max_by</target>
        </trans-unit>
        <trans-unit id="4bced0b61c3c1cb8410f882718a68a33aeae5a9b" translate="yes" xml:space="preserve">
          <source>OnceWith::max_by_key</source>
          <target state="translated">OnceWith::max_by_key</target>
        </trans-unit>
        <trans-unit id="06568f09e719a331a84ceae60f4b66de6e9d0ea4" translate="yes" xml:space="preserve">
          <source>OnceWith::min</source>
          <target state="translated">OnceWith::min</target>
        </trans-unit>
        <trans-unit id="286481980c2d0b526534de52416aa1cce0683996" translate="yes" xml:space="preserve">
          <source>OnceWith::min_by</source>
          <target state="translated">OnceWith::min_by</target>
        </trans-unit>
        <trans-unit id="5dd37a258caeec2b0eb6451dca8a726b836a9a92" translate="yes" xml:space="preserve">
          <source>OnceWith::min_by_key</source>
          <target state="translated">OnceWith::min_by_key</target>
        </trans-unit>
        <trans-unit id="69f93b3a318af71379ddca4ec93fe8d140ce5f0f" translate="yes" xml:space="preserve">
          <source>OnceWith::ne</source>
          <target state="translated">OnceWith::ne</target>
        </trans-unit>
        <trans-unit id="ac26f725cccaf1526e5014347f9adea936f74ce7" translate="yes" xml:space="preserve">
          <source>OnceWith::next</source>
          <target state="translated">OnceWith::next</target>
        </trans-unit>
        <trans-unit id="e4330c855cf5f92fc7584c51cdee41319443487c" translate="yes" xml:space="preserve">
          <source>OnceWith::next_back</source>
          <target state="translated">OnceWith::next_back</target>
        </trans-unit>
        <trans-unit id="1527b9229bda86674b9d9102f7590dba88349ecd" translate="yes" xml:space="preserve">
          <source>OnceWith::nth</source>
          <target state="translated">OnceWith::nth</target>
        </trans-unit>
        <trans-unit id="52e0f2df5caf846213c666b22fff6456cda8a68f" translate="yes" xml:space="preserve">
          <source>OnceWith::nth_back</source>
          <target state="translated">OnceWith::nth_back</target>
        </trans-unit>
        <trans-unit id="2d124bbf09c7f2b80ff84f088c67f3f07ae5780b" translate="yes" xml:space="preserve">
          <source>OnceWith::partial_cmp</source>
          <target state="translated">OnceWith::partial_cmp</target>
        </trans-unit>
        <trans-unit id="cabc7165c7c9b316158511856e73e51b4305e89b" translate="yes" xml:space="preserve">
          <source>OnceWith::partition</source>
          <target state="translated">OnceWith::partition</target>
        </trans-unit>
        <trans-unit id="1cda021009cce16eced253abaf1a3a1b11566d18" translate="yes" xml:space="preserve">
          <source>OnceWith::peekable</source>
          <target state="translated">OnceWith::peekable</target>
        </trans-unit>
        <trans-unit id="03590b6367dd3bb1ba4d65b39afee2b09ca08df1" translate="yes" xml:space="preserve">
          <source>OnceWith::position</source>
          <target state="translated">OnceWith::position</target>
        </trans-unit>
        <trans-unit id="e1735abbbee6972dc130e89d570fd8fa919407fe" translate="yes" xml:space="preserve">
          <source>OnceWith::product</source>
          <target state="translated">OnceWith::product</target>
        </trans-unit>
        <trans-unit id="ec925c93a26e2eadc7d07e055f695e74c83d4c23" translate="yes" xml:space="preserve">
          <source>OnceWith::rev</source>
          <target state="translated">OnceWith::rev</target>
        </trans-unit>
        <trans-unit id="6243776ef017e4a1cf3d502a3968703e2ab8d6ed" translate="yes" xml:space="preserve">
          <source>OnceWith::rfind</source>
          <target state="translated">OnceWith::rfind</target>
        </trans-unit>
        <trans-unit id="aea12fd7d31659bccdee8c41ecdb4fb0f15444db" translate="yes" xml:space="preserve">
          <source>OnceWith::rfold</source>
          <target state="translated">OnceWith::rfold</target>
        </trans-unit>
        <trans-unit id="0c9e294cb61289d08c63ceca07aff5dfaea0261e" translate="yes" xml:space="preserve">
          <source>OnceWith::rposition</source>
          <target state="translated">OnceWith::rposition</target>
        </trans-unit>
        <trans-unit id="cef9b43e5eedf9af103faef7b1bbe4d12db9ab2f" translate="yes" xml:space="preserve">
          <source>OnceWith::scan</source>
          <target state="translated">OnceWith::scan</target>
        </trans-unit>
        <trans-unit id="cc6e5c82263a6bf9a575956ff17a327f6e8e1a12" translate="yes" xml:space="preserve">
          <source>OnceWith::size_hint</source>
          <target state="translated">OnceWith::size_hint</target>
        </trans-unit>
        <trans-unit id="eb30275a1bfcdf9e0075819a60e55de8140da973" translate="yes" xml:space="preserve">
          <source>OnceWith::skip</source>
          <target state="translated">OnceWith::skip</target>
        </trans-unit>
        <trans-unit id="d51df4ad9879230eee4b7d1f410130e26dd6a97e" translate="yes" xml:space="preserve">
          <source>OnceWith::skip_while</source>
          <target state="translated">OnceWith::skip_while</target>
        </trans-unit>
        <trans-unit id="13b1461f738d3541f7f825bf588919136b55d36d" translate="yes" xml:space="preserve">
          <source>OnceWith::step_by</source>
          <target state="translated">OnceWith::step_by</target>
        </trans-unit>
        <trans-unit id="74e43ad0cf8bc22a5af2d491f032ca5523c1d7b0" translate="yes" xml:space="preserve">
          <source>OnceWith::sum</source>
          <target state="translated">OnceWith::sum</target>
        </trans-unit>
        <trans-unit id="89cc6b13712f2c2ac536c3feb4e1809f1a6b5cc2" translate="yes" xml:space="preserve">
          <source>OnceWith::take</source>
          <target state="translated">OnceWith::take</target>
        </trans-unit>
        <trans-unit id="8c2cd8a3d3dfa6e2cb6f5f270f11cddff7173ce1" translate="yes" xml:space="preserve">
          <source>OnceWith::take_while</source>
          <target state="translated">OnceWith::take_while</target>
        </trans-unit>
        <trans-unit id="5a630013ba78b1577b011778f861dca34fdb6510" translate="yes" xml:space="preserve">
          <source>OnceWith::to_owned</source>
          <target state="translated">OnceWith::to_owned</target>
        </trans-unit>
        <trans-unit id="030ec595a21a12e03c641afa5fc2a0fbf3cfd96d" translate="yes" xml:space="preserve">
          <source>OnceWith::try_fold</source>
          <target state="translated">OnceWith::try_fold</target>
        </trans-unit>
        <trans-unit id="716d560ebaa2fa12887a04435f9271204fee9212" translate="yes" xml:space="preserve">
          <source>OnceWith::try_for_each</source>
          <target state="translated">OnceWith::try_for_each</target>
        </trans-unit>
        <trans-unit id="585e7e8b9f7e6990f4b13d54ca37d88a0bf70ca8" translate="yes" xml:space="preserve">
          <source>OnceWith::try_from</source>
          <target state="translated">OnceWith::try_from</target>
        </trans-unit>
        <trans-unit id="7cb93d634335cbd032ccfe91d14126a928250279" translate="yes" xml:space="preserve">
          <source>OnceWith::try_into</source>
          <target state="translated">OnceWith::try_into</target>
        </trans-unit>
        <trans-unit id="640ef41bdeff4cb6f8ee26085f02e8464a124452" translate="yes" xml:space="preserve">
          <source>OnceWith::try_rfold</source>
          <target state="translated">OnceWith::try_rfold</target>
        </trans-unit>
        <trans-unit id="100a64512cd2fe1b9fbd4ceea4850862b8f813b7" translate="yes" xml:space="preserve">
          <source>OnceWith::type_id</source>
          <target state="translated">OnceWith::type_id</target>
        </trans-unit>
        <trans-unit id="64fd105a0a6aa5f709a9477cafb3d6c01fd6cfb0" translate="yes" xml:space="preserve">
          <source>OnceWith::unzip</source>
          <target state="translated">OnceWith::unzip</target>
        </trans-unit>
        <trans-unit id="433df116ad00f74cb6d78ea83682ace23f21cb19" translate="yes" xml:space="preserve">
          <source>OnceWith::zip</source>
          <target state="translated">OnceWith::zip</target>
        </trans-unit>
        <trans-unit id="c04e60357eae6b0d2f646024db69bbf3bdb3f30b" translate="yes" xml:space="preserve">
          <source>One Rust community member, Andrew Gallant, has already created a fully featured, very fast version of &lt;code&gt;grep&lt;/code&gt;, called &lt;code&gt;ripgrep&lt;/code&gt;. By comparison, our version of &lt;code&gt;grep&lt;/code&gt; will be fairly simple, but this chapter will give you some of the background knowledge you need to understand a real-world project such as &lt;code&gt;ripgrep&lt;/code&gt;.</source>
          <target state="translated">Andrew Gallant의 한 Rust 커뮤니티 회원은 이미 &lt;code&gt;ripgrep&lt;/code&gt; 이라는 완전한 기능을 갖춘 매우 빠른 &lt;code&gt;grep&lt;/code&gt; 버전을 작성했습니다 . 그에 비해 &lt;code&gt;grep&lt;/code&gt; 버전은 매우 단순하지만이 장에서는 &lt;code&gt;ripgrep&lt;/code&gt; 와 같은 실제 프로젝트를 이해하는 데 필요한 배경 지식을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="6d8cb1de18a6c59ff63b7aa03082a18e5d9546ee" translate="yes" xml:space="preserve">
          <source>One benefit of implementing &lt;code&gt;IntoIterator&lt;/code&gt; is that your type will &lt;a href=&quot;index#for-loops-and-intoiterator&quot;&gt;work with Rust's &lt;code&gt;for&lt;/code&gt; loop syntax&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;IntoIterator&lt;/code&gt; 를 구현할 때 얻을 수있는 이점 중 하나 는 형식이 &lt;a href=&quot;index#for-loops-and-intoiterator&quot;&gt;Rust의 &lt;code&gt;for&lt;/code&gt; 루프 구문 에서 작동&lt;/a&gt; 한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="1d5bdf955d9dc47b0601586e8217dda6094c541f" translate="yes" xml:space="preserve">
          <source>One character can become multiple:</source>
          <target state="translated">하나의 문자가 여러 개가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a0e2dea9fc38cc31adcbb6e264358edce5cb875" translate="yes" xml:space="preserve">
          <source>One could use &lt;code&gt;std::os::raw::c_void&lt;/code&gt; if they want to support old Rust compiler down to 1.1.0. After Rust 1.30.0, it was re-exported by this definition. For more information, please read &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2521-c_void-reunification.md&quot;&gt;RFC 2521&lt;/a&gt;.</source>
          <target state="translated">이전 Rust 컴파일러를 1.1.0까지 지원 하려면 &lt;code&gt;std::os::raw::c_void&lt;/code&gt; 사용할 수 있습니다 . Rust 1.30.0 이후에는이 정의에 따라 다시 내보내졌습니다. 자세한 내용은 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2521-c_void-reunification.md&quot;&gt;RFC 2521을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa91f526636a9109f1e67616db8e82d52af8d580" translate="yes" xml:space="preserve">
          <source>One detail we didn&amp;rsquo;t discuss in the &lt;a href=&quot;ch04-02-references-and-borrowing#references-and-borrowing&quot;&gt;&amp;ldquo;References and Borrowing&amp;rdquo;&lt;/a&gt; section in Chapter 4 is that every reference in Rust has a &lt;em&gt;lifetime&lt;/em&gt;, which is the scope for which that reference is valid. Most of the time, lifetimes are implicit and inferred, just like most of the time, types are inferred. We must annotate types when multiple types are possible. In a similar way, we must annotate lifetimes when the lifetimes of references could be related in a few different ways. Rust requires us to annotate the relationships using generic lifetime parameters to ensure the actual references used at runtime will definitely be valid.</source>
          <target state="translated">4 장의 &lt;a href=&quot;ch04-02-references-and-borrowing#references-and-borrowing&quot;&gt;&quot;참조 및 차용&quot;&lt;/a&gt; 섹션에서 논의하지 않은 세부 사항 중 하나 는 Rust의 모든 참조에 &lt;em&gt;수명&lt;/em&gt; 이 있다는 것입니다. 이는 해당 참조의 유효 범위입니다. 대부분의 경우 수명은 암시 적이며 대부분의 경우와 마찬가지로 유형이 유추됩니다. 여러 유형이 가능한 경우 유형에 주석을 달아야합니다. 비슷한 방식으로 참조의 수명이 몇 가지 다른 방식으로 관련 될 수있는 경우 수명에 주석을 달아야합니다. Rust는 런타임에 사용 된 실제 참조가 확실히 유효하도록 일반 수명 매개 변수를 사용하여 관계에 주석을 달아야합니다.</target>
        </trans-unit>
        <trans-unit id="d218cebb1b26aab7ac78425185eee65d682c0943" translate="yes" xml:space="preserve">
          <source>One downside of the state pattern is that, because the states implement the transitions between states, some of the states are coupled to each other. If we add another state between &lt;code&gt;PendingReview&lt;/code&gt; and &lt;code&gt;Published&lt;/code&gt;, such as &lt;code&gt;Scheduled&lt;/code&gt;, we would have to change the code in &lt;code&gt;PendingReview&lt;/code&gt; to transition to &lt;code&gt;Scheduled&lt;/code&gt; instead. It would be less work if &lt;code&gt;PendingReview&lt;/code&gt; didn&amp;rsquo;t need to change with the addition of a new state, but that would mean switching to another design pattern.</source>
          <target state="translated">상태 패턴의 한 가지 단점은, 상태가 상태 간의 전이를 구현하기 때문에 일부 상태가 서로 연결된다는 것입니다. 우리는 사이에 다른 주를 추가하는 경우 &lt;code&gt;PendingReview&lt;/code&gt; 및 &lt;code&gt;Published&lt;/code&gt; 등, &lt;code&gt;Scheduled&lt;/code&gt; , 우리의 코드를 변경해야 할 것 &lt;code&gt;PendingReview&lt;/code&gt; 에 전환에 &lt;code&gt;Scheduled&lt;/code&gt; 대신. &lt;code&gt;PendingReview&lt;/code&gt; 가 새로운 상태의 추가로 변경 될 필요가 없다면 작업이 줄어들지 만 다른 디자인 패턴으로 전환해야합니다.</target>
        </trans-unit>
        <trans-unit id="79dab74a608a5fe55775f425d883e5609ea6484a" translate="yes" xml:space="preserve">
          <source>One example of a trait with an associated type is the &lt;code&gt;Iterator&lt;/code&gt; trait that the standard library provides. The associated type is named &lt;code&gt;Item&lt;/code&gt; and stands in for the type of the values the type implementing the &lt;code&gt;Iterator&lt;/code&gt; trait is iterating over. In &lt;a href=&quot;ch13-02-iterators#the-iterator-trait-and-the-next-method&quot;&gt;&amp;ldquo;The &lt;code&gt;Iterator&lt;/code&gt; Trait and the &lt;code&gt;next&lt;/code&gt; Method&amp;rdquo;&lt;/a&gt; section of Chapter 13, we mentioned that the definition of the &lt;code&gt;Iterator&lt;/code&gt; trait is as shown in Listing 19-12.</source>
          <target state="translated">연관된 유형을 가진 특성의 한 예 는 표준 라이브러리가 제공 하는 &lt;code&gt;Iterator&lt;/code&gt; 특성입니다. 연관된 유형의 이름은 &lt;code&gt;Item&lt;/code&gt; 이며 &lt;code&gt;Iterator&lt;/code&gt; 특성을 구현하는 유형 이 반복 하는 값의 유형 을 나타냅니다. 에서 &lt;a href=&quot;ch13-02-iterators#the-iterator-trait-and-the-next-method&quot;&gt;는 &quot; &lt;code&gt;Iterator&lt;/code&gt; 형질과 &lt;code&gt;next&lt;/code&gt; 방법&quot;&lt;/a&gt; 장 13 절, 우리는의 정의에 언급 &lt;code&gt;Iterator&lt;/code&gt; 목록 19-12에서와 같이이다 특징.</target>
        </trans-unit>
        <trans-unit id="6e24d429d27b48134811a91f7546e1e6d93fd489" translate="yes" xml:space="preserve">
          <source>One final expression that has the type &lt;code&gt;!&lt;/code&gt; is a &lt;code&gt;loop&lt;/code&gt;:</source>
          <target state="translated">유형이 하나의 최종 표현식 &lt;code&gt;!&lt;/code&gt; A는 &lt;code&gt;loop&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="08b7d5a5c0be732c550b04476aeb4d64ed0d9f34" translate="yes" xml:space="preserve">
          <source>One fix is to use &lt;code&gt;Option&lt;/code&gt;, like so:</source>
          <target state="translated">한 가지 수정은 &lt;code&gt;Option&lt;/code&gt; 을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0404f28b47072e36d14ad36dc7e51fdfb00d1799" translate="yes" xml:space="preserve">
          <source>One fix may be to increase the recursion limit. Note that it is possible to create an infinite recursion of dereferencing, in which case the only fix is to somehow break the recursion.</source>
          <target state="translated">하나의 수정은 재귀 한계를 증가시키는 것일 수 있습니다. 역 참조 해제의 무한 재귀를 생성 할 수 있습니다.이 경우 유일한 수정은 재귀를 중단시키는 것입니다.</target>
        </trans-unit>
        <trans-unit id="604777bf4c9ef568f65e74a5ef4770d9197bf0e4" translate="yes" xml:space="preserve">
          <source>One greater than the minimum possible normal power of 2 exponent.</source>
          <target state="translated">최소 지수 2의 지수 인 1보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="d1aad5d49e44c9e98dc9d596c60e87f16270d447" translate="yes" xml:space="preserve">
          <source>One greater than the minimum possible normal power of 2 exponent. Use &lt;a href=&quot;../primitive.f32#associatedconstant.MIN_EXP&quot;&gt;&lt;code&gt;f32::MIN_EXP&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">2 지수의 가능한 최소 정규 거듭 제곱보다 큰 값입니다. 대신 &lt;a href=&quot;../primitive.f32#associatedconstant.MIN_EXP&quot;&gt; &lt;code&gt;f32::MIN_EXP&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="af913244c1df707f9c82d8aebefb4735e4abcae8" translate="yes" xml:space="preserve">
          <source>One greater than the minimum possible normal power of 2 exponent. Use &lt;a href=&quot;../primitive.f64#associatedconstant.MIN_EXP&quot;&gt;&lt;code&gt;f64::MIN_EXP&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">2 지수의 가능한 최소 정규 거듭 제곱보다 큰 값입니다. 대신 &lt;a href=&quot;../primitive.f64#associatedconstant.MIN_EXP&quot;&gt; &lt;code&gt;f64::MIN_EXP&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6888a831481b2df0737ae6067a1763cc0ae4b8b" translate="yes" xml:space="preserve">
          <source>One important part of this code is that the &lt;code&gt;Messenger&lt;/code&gt; trait has one method called &lt;code&gt;send&lt;/code&gt; that takes an immutable reference to &lt;code&gt;self&lt;/code&gt; and the text of the message. This is the interface our mock object needs to have. The other important part is that we want to test the behavior of the &lt;code&gt;set_value&lt;/code&gt; method on the &lt;code&gt;LimitTracker&lt;/code&gt;. We can change what we pass in for the &lt;code&gt;value&lt;/code&gt; parameter, but &lt;code&gt;set_value&lt;/code&gt; doesn&amp;rsquo;t return anything for us to make assertions on. We want to be able to say that if we create a &lt;code&gt;LimitTracker&lt;/code&gt; with something that implements the &lt;code&gt;Messenger&lt;/code&gt; trait and a particular value for &lt;code&gt;max&lt;/code&gt;, when we pass different numbers for &lt;code&gt;value&lt;/code&gt;, the messenger is told to send the appropriate messages.</source>
          <target state="translated">이 코드의 중요한 부분 중 하나는 &lt;code&gt;Messenger&lt;/code&gt; 특성에 &lt;code&gt;send&lt;/code&gt; 라는 한 가지 메서드가 있는데,이 메서드는 &lt;code&gt;self&lt;/code&gt; 과 메시지의 텍스트 를 변경할 수 없습니다 . 이것은 모의 객체에 필요한 인터페이스입니다. 다른 중요한 부분은 &lt;code&gt;LimitTracker&lt;/code&gt; 에서 &lt;code&gt;set_value&lt;/code&gt; 메소드 의 동작을 테스트하려는 것 입니다. &lt;code&gt;value&lt;/code&gt; 매개 변수에 전달하는 내용을 변경할 수 있지만 &lt;code&gt;set_value&lt;/code&gt; 는 어설 션을 만들기 위해 아무것도 반환하지 않습니다. &lt;code&gt;Messenger&lt;/code&gt; 특성과 특정 값을 구현하는 무언가 로 &lt;code&gt;LimitTracker&lt;/code&gt; 를 만들면 &lt;code&gt;max&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 에 다른 숫자를 전달 하면 메신저에 적절한 메시지를 보내라는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ded7cc38097138108681f22bf5306daeb4f49884" translate="yes" xml:space="preserve">
          <source>One increasingly popular approach to ensuring safe concurrency is &lt;em&gt;message passing&lt;/em&gt;, where threads or actors communicate by sending each other messages containing data. Here&amp;rsquo;s the idea in a slogan from &lt;a href=&quot;http://golang.org/doc/effective_go.html&quot;&gt;the Go language documentation&lt;/a&gt;: &amp;ldquo;Do not communicate by sharing memory; instead, share memory by communicating.&amp;rdquo;</source>
          <target state="translated">안전한 동시성을 보장하기 위해 점점 대중적으로 접근하는 방법 중 하나는 &lt;em&gt;메시지 전달입니다&lt;/em&gt; . 스레드 또는 행위자는 데이터가 포함 된 서로 메시지를 보내 통신합니다. &lt;a href=&quot;http://golang.org/doc/effective_go.html&quot;&gt;Go 언어 문서&lt;/a&gt; 의 슬로건은 다음과 같습니다 .&amp;ldquo;메모리를 공유하여 의사 소통하지 마십시오. 대신 의사 소통을 통해 메모리를 공유하십시오.&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="d3eaa18d42b0806c5f4bdf2e764c2ce7e402d5e8" translate="yes" xml:space="preserve">
          <source>One increasingly popular approach to ensuring safe concurrency is &lt;em&gt;message passing&lt;/em&gt;, where threads or actors communicate by sending each other messages containing data. Here&amp;rsquo;s the idea in a slogan from &lt;a href=&quot;https://golang.org/doc/effective_go.html#concurrency&quot;&gt;the Go language documentation&lt;/a&gt;: &amp;ldquo;Do not communicate by sharing memory; instead, share memory by communicating.&amp;rdquo;</source>
          <target state="translated">안전한 동시성을 보장하기 위해 점점 더 많이 사용되는 접근 방식은 스레드 또는 행위자가 데이터를 포함하는 메시지를 서로 전송하여 통신하는 &lt;em&gt;메시지 전달&lt;/em&gt; 입니다. &lt;a href=&quot;https://golang.org/doc/effective_go.html#concurrency&quot;&gt;Go 언어 문서&lt;/a&gt; 의 슬로건에있는 아이디어는 다음과 같습니다 .&amp;ldquo;기억을 공유하여 의사 소통하지 마십시오. 대신 의사 소통을 통해 기억을 공유하십시오.&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="d6b559b40224203447024d2ae45e68a9e1945eed" translate="yes" xml:space="preserve">
          <source>One last example:</source>
          <target state="translated">마지막 예 :</target>
        </trans-unit>
        <trans-unit id="1ad534544463088b932bc112e0ba96d50acc9887" translate="yes" xml:space="preserve">
          <source>One lifetime annotation by itself doesn&amp;rsquo;t have much meaning, because the annotations are meant to tell Rust how generic lifetime parameters of multiple references relate to each other. For example, let&amp;rsquo;s say we have a function with the parameter &lt;code&gt;first&lt;/code&gt; that is a reference to an &lt;code&gt;i32&lt;/code&gt; with lifetime &lt;code&gt;'a&lt;/code&gt;. The function also has another parameter named &lt;code&gt;second&lt;/code&gt; that is another reference to an &lt;code&gt;i32&lt;/code&gt; that also has the lifetime &lt;code&gt;'a&lt;/code&gt;. The lifetime annotations indicate that the references &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt; must both live as long as that generic lifetime.</source>
          <target state="translated">하나의 수명 주석 자체는 그다지 의미가 없습니다. 주석은 Rust에게 여러 참조의 일반적인 수명 매개 변수가 서로 어떤 관련이 있는지 알려주기 때문입니다. 예를 들어, 수명이 &lt;code&gt;'a&lt;/code&gt; ' 인 &lt;code&gt;i32&lt;/code&gt; 에 대한 참조 인 매개 변수가 &lt;code&gt;first&lt;/code&gt; 있는 함수가 있다고 가정 합니다 . 이 함수에는 또한 수명이 &lt;code&gt;'a&lt;/code&gt; &lt;code&gt;i32&lt;/code&gt; 에 대한 또 다른 참조 인 &lt;code&gt;second&lt;/code&gt; 라는 또 다른 매개 변수 가 있습니다 . 수명 주석은 &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;second&lt;/code&gt; 참조 가 해당 일반 수명 동안 지속되어야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="eb999aea4a6804c2aba22f0ab64c0d473a5cc357" translate="yes" xml:space="preserve">
          <source>One major tool Rust has for accomplishing message-sending concurrency is the &lt;em&gt;channel&lt;/em&gt;, a programming concept that Rust&amp;rsquo;s standard library provides an implementation of. You can imagine a channel in programming as being like a channel of water, such as a stream or a river. If you put something like a rubber duck or boat into a stream, it will travel downstream to the end of the waterway.</source>
          <target state="translated">Rust가 메시지 전송 동시성을 달성하기 위해 가지고있는 주요 도구 중 하나 는 Rust의 표준 라이브러리가 구현하는 프로그래밍 개념 인 &lt;em&gt;채널&lt;/em&gt; 입니다. 프로그래밍에서 채널이 하천이나 강과 같은 수로와 같다고 상상할 수 있습니다. 고무 오리 또는 보트와 같은 것을 하천에 넣으면 수로 끝까지 하류로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="5a21bfbca68fd0fbb69da3809cb39488fd50f372" translate="yes" xml:space="preserve">
          <source>One maybe obvious note when using append-mode: make sure that all data that belongs together is written to the file in one operation. This can be done by concatenating strings before passing them to &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;, or using a buffered writer (with a buffer of adequate size), and calling &lt;a href=&quot;../io/trait.write#tymethod.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; when the message is complete.</source>
          <target state="translated">추가 모드를 사용할 때 한 가지 분명한 점은 함께 속한 모든 데이터가 한 번의 작업으로 파일에 기록되는지 확인하는 것입니다. 문자열을 &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; 전달하기 전에 문자열을 연결 하거나 버퍼링 된 작성기 (적절한 크기의 버퍼 포함 &lt;a href=&quot;../io/trait.write#tymethod.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt; 를 사용하고 메시지가 완료되면 flush ()를 호출하여 이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a100de9eac9101d503c874b2c73fc8e99b7771dc" translate="yes" xml:space="preserve">
          <source>One maybe obvious note when using append-mode: make sure that all data that belongs together is written to the file in one operation. This can be done by concatenating strings before passing them to &lt;a href=&quot;struct.file#method.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;, or using a buffered writer (with a buffer of adequate size), and calling &lt;a href=&quot;struct.file#method.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; when the message is complete.</source>
          <target state="translated">추가 모드를 사용할 때 한 가지 분명한 참고 사항은 하나의 작업으로 함께 속하는 모든 데이터가 파일에 기록되는지 확인하십시오. 문자열을 &lt;a href=&quot;struct.file#method.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; 전달하기 전에 문자열을 연결 하거나 버퍼링 된 작성기 (적당한 크기의 버퍼 사용 &lt;a href=&quot;struct.file#method.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt; 를 사용하고 메시지가 완료되면 flush ()를 호출 하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2650888f948816ac8a9838e1462a292b91d57e17" translate="yes" xml:space="preserve">
          <source>One of the keys to &lt;code&gt;collect()&lt;/code&gt;'s power is that many things you might not think of as 'collections' actually are. For example, a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; is a collection of &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. And a collection of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt; can be thought of as single &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;Collection&amp;lt;T&amp;gt;, E&amp;gt;&lt;/code&gt;. See the examples below for more.</source>
          <target state="translated">&lt;code&gt;collect()&lt;/code&gt; 의 힘 을 얻는 열쇠 중 하나는 실제로 '컬렉션'으로 생각할 수없는 많은 것들입니다. 예를 들어, &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 의 모음입니다 . 그리고 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;Collection&amp;lt;T&amp;gt;, E&amp;gt;&lt;/code&gt; 은 단일 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &amp;lt;Collection &amp;lt;T&amp;gt;, E&amp;gt; 로 간주 될 수 있습니다 . 자세한 내용은 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c25ed3c3dc3acc46e3e6ecc55a7e68acca10b918" translate="yes" xml:space="preserve">
          <source>One of the uses of a &lt;code&gt;loop&lt;/code&gt; is to retry an operation you know might fail, such as checking whether a thread has completed its job. However, you might need to pass the result of that operation to the rest of your code. To do this, you can add the value you want returned after the &lt;code&gt;break&lt;/code&gt; expression you use to stop the loop; that value will be returned out of the loop so you can use it, as shown here:</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 사용하는 것 중 하나는 스레드가 작업을 완료했는지 여부를 확인하는 등 실패한 작업을 다시 시도하는 것입니다. 그러나 해당 작업의 결과를 나머지 코드로 전달해야 할 수도 있습니다. 이렇게하려면 루프를 중지하는 데 사용 하는 &lt;code&gt;break&lt;/code&gt; 식 다음에 반환 할 값을 추가 할 수 있습니다 . 해당 값은 다음과 같이 루프에서 반환되므로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f31603daf9af84bcc62de6d02f7c02e0a197c236" translate="yes" xml:space="preserve">
          <source>One requirement for &lt;code&gt;match&lt;/code&gt; expressions is that they need to be &lt;em&gt;exhaustive&lt;/em&gt; in the sense that all possibilities for the value in the &lt;code&gt;match&lt;/code&gt; expression must be accounted for. One way to ensure you&amp;rsquo;ve covered every possibility is to have a catchall pattern for the last arm: for example, a variable name matching any value can never fail and thus covers every remaining case.</source>
          <target state="translated">에 대한 하나 개의 요구 사항에 &lt;code&gt;match&lt;/code&gt; 표현은 할 필요가있다 &lt;em&gt;철저한&lt;/em&gt; 의 값에 대한 모든 가능성한다는 점에서 &lt;code&gt;match&lt;/code&gt; 식을 차지해야합니다. 모든 가능성을 다룰 수있는 한 가지 방법은 마지막 팔에 대해 포괄적 인 패턴을 갖는 것입니다. 예를 들어, 어떤 값과도 일치하는 변수 이름은 절대 실패하지 않으므로 나머지 모든 경우를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="2015b7ca5d5d193e7b2cd1b845883b1560077b31" translate="yes" xml:space="preserve">
          <source>One restriction to note with trait implementations is that we can implement a trait on a type only if either the trait or the type is local to our crate. For example, we can implement standard library traits like &lt;code&gt;Display&lt;/code&gt; on a custom type like &lt;code&gt;Tweet&lt;/code&gt; as part of our &lt;code&gt;aggregator&lt;/code&gt; crate functionality, because the type &lt;code&gt;Tweet&lt;/code&gt; is local to our &lt;code&gt;aggregator&lt;/code&gt; crate. We can also implement &lt;code&gt;Summary&lt;/code&gt; on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in our &lt;code&gt;aggregator&lt;/code&gt; crate, because the trait &lt;code&gt;Summary&lt;/code&gt; is local to our &lt;code&gt;aggregator&lt;/code&gt; crate.</source>
          <target state="translated">특성 구현에 주목해야 할 한 가지 제한은 특성이나 유형이 상자에 로컬 인 경우에만 유형에 특성을 구현할 수 있다는 것입니다. 예를 들어, 우리는 같은 표준 라이브러리 특성을 구현할 수있는 &lt;code&gt;Display&lt;/code&gt; 와 같은 사용자 정의 유형에 &lt;code&gt;Tweet&lt;/code&gt; 우리의 일환으로 &lt;code&gt;aggregator&lt;/code&gt; 유형 있기 때문에, 상자의 기능을 &lt;code&gt;Tweet&lt;/code&gt; 우리의 로컬 &lt;code&gt;aggregator&lt;/code&gt; 상자. 특성 &lt;code&gt;Summary&lt;/code&gt; 이 &lt;code&gt;aggregator&lt;/code&gt; 상자에 로컬 이기 때문에 &lt;code&gt;aggregator&lt;/code&gt; 상자 에서 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 에 대한 &lt;code&gt;Summary&lt;/code&gt; 을 구현할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ca14e0e855a4d320ac718d1dbab1d5658779f12" translate="yes" xml:space="preserve">
          <source>One should always prefer implementing &lt;code&gt;From&lt;/code&gt; over &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; because implementing &lt;code&gt;From&lt;/code&gt; automatically provides one with a implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library.</source>
          <target state="translated">하나는 항상 구현 선호한다 &lt;code&gt;From&lt;/code&gt; 이상 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 구현하기 때문에 &lt;code&gt;From&lt;/code&gt; 자동으로하기의 구현을 제공합니다 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 표준 라이브러리에있는 담요 구현에 감사합니다.</target>
        </trans-unit>
        <trans-unit id="721950a5dec28e319b3fc49a8295aa63db96bacc" translate="yes" xml:space="preserve">
          <source>One should always prefer implementing &lt;code&gt;From&lt;/code&gt; over &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; because implementing &lt;code&gt;From&lt;/code&gt; automatically provides one with an implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library.</source>
          <target state="translated">하나는 항상 구현 선호한다 &lt;code&gt;From&lt;/code&gt; 이상 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 구현하기 때문에 &lt;code&gt;From&lt;/code&gt; 자동으로하기의 구현을 제공합니다 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 표준 라이브러리에있는 담요 구현에 감사합니다.</target>
        </trans-unit>
        <trans-unit id="bb98649134293913fe4a45ee10ddf0211b082fad" translate="yes" xml:space="preserve">
          <source>One should avoid implementing &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; and implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; instead. Implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; automatically provides one with an implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library.</source>
          <target state="translated">하나는 구현 피해야 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 하고 구현 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 대신. 구현 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 자동으로하여 구현 한 제공 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 표준 라이브러리에있는 담요 구현에 감사합니다.</target>
        </trans-unit>
        <trans-unit id="b9063035453c1b2c42529a52a82eaf086598016e" translate="yes" xml:space="preserve">
          <source>One should only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; if a conversion to a type outside the current crate is required. Otherwise one should always prefer implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; over &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; because implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; automatically provides one with a implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library. &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; cannot do these type of conversions because of Rust's orphaning rules.</source>
          <target state="translated">현재 상자 이외의 유형으로의 변환이 필요한 경우 에만 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; 를&lt;/a&gt; 구현해야 합니다. 그렇지 않으면 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 라이브러리를 구현하는 것이 표준 라이브러리의 블랭킷 구현 덕분 에 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 구현을 자동으로 제공 하므로 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; over &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 구현을 항상 선호해야 합니다. &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 할 수 있기 때문에 녹의 orphaning 규칙의 전환이 유형을하지.</target>
        </trans-unit>
        <trans-unit id="1a1308a26b40990e2a9ab226282be34a9c0f3915" translate="yes" xml:space="preserve">
          <source>One special lifetime we need to discuss is &lt;code&gt;'static&lt;/code&gt;, which means that this reference &lt;em&gt;can&lt;/em&gt; live for the entire duration of the program. All string literals have the &lt;code&gt;'static&lt;/code&gt; lifetime, which we can annotate as follows:</source>
          <target state="translated">우리가 논의해야 할 한 가지 특별한 수명은 &lt;code&gt;'static&lt;/code&gt; 이며, 이는이 참조 &lt;em&gt;가&lt;/em&gt; 프로그램의 전체 기간 동안 지속될 &lt;em&gt;수&lt;/em&gt; 있음을 의미합니다 . 모든 문자열 리터럴에는 &lt;code&gt;'static&lt;/code&gt; 수명 ' 이 있으며 다음과 같이 주석을 달 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3c0e81ae8d50e16a5ef5685ec5ba7252876cd13" translate="yes" xml:space="preserve">
          <source>One way to do this would be to parse the guess as an &lt;code&gt;i32&lt;/code&gt; instead of only a &lt;code&gt;u32&lt;/code&gt; to allow potentially negative numbers, and then add a check for the number being in range, like so:</source>
          <target state="translated">이를 수행하는 한 가지 방법은 음수를 허용하기 위해 &lt;code&gt;u32&lt;/code&gt; 대신 &lt;code&gt;i32&lt;/code&gt; 로 추측을 구문 분석 한 다음 범위 내에있는 수에 대한 확인을 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="040e8b6c5e16e2eb7dbd8ea369897b2ed67939bb" translate="yes" xml:space="preserve">
          <source>One way to fix this is by wrapping &lt;code&gt;ListNode&lt;/code&gt; in a &lt;code&gt;Box&lt;/code&gt;, like so:</source>
          <target state="translated">이를 해결하는 한 가지 방법은 다음과 같이 &lt;code&gt;ListNode&lt;/code&gt; 를 &lt;code&gt;Box&lt;/code&gt; 에 배치하는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="7b55ce1dd92a000535e70271090068fe574bb882" translate="yes" xml:space="preserve">
          <source>One way to fix this is to remove the items in negative impls:</source>
          <target state="translated">이 문제를 해결하는 한 가지 방법은 부정적인 impls에서 항목을 제거하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e58c5baae639d4247baa5d3c55a2e51c5fc2fcbf" translate="yes" xml:space="preserve">
          <source>One way to use &lt;code&gt;AssertUnwindSafe&lt;/code&gt; is to assert that the entire closure itself is unwind safe, bypassing all checks for all variables:</source>
          <target state="translated">&lt;code&gt;AssertUnwindSafe&lt;/code&gt; 를 사용하는 한 가지 방법 은 모든 변수 자체에 대한 모든 검사를 무시하고 전체 클로저 자체가 풀림 에 안전하다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1d8228fcb1896e7f726b443ff97084ceedc8b0d1" translate="yes" xml:space="preserve">
          <source>One way to work around this is to introduce a phantom type parameter into &lt;code&gt;FooMaker&lt;/code&gt;, like so:</source>
          <target state="translated">이 문제를 해결하는 한 가지 방법은 &lt;code&gt;FooMaker&lt;/code&gt; 에 팬텀 유형 매개 변수를 도입하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5d2a1cfc42a9afc1fe710bb8389ace0259e088eb" translate="yes" xml:space="preserve">
          <source>Only &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; has expected costs, due to the probabilistic nature of hashing. It is theoretically possible, though very unlikely, for &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; to experience worse performance.</source>
          <target state="translated">해시의 확률 적 특성으로 인해 &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 만이 비용을 예상했습니다. 비록 이론적으로는 &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 이 더 나쁜 성능을 경험할 가능성은 거의 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c64700ee184977494a32292609d647c2790da91d" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;extern crate&lt;/code&gt; imports at the crate root level are allowed to import macros.</source>
          <target state="translated">만 &lt;code&gt;extern crate&lt;/code&gt; 나무 상자 루트 레벨에서의 수입은 수입 매크로를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f1a591311049947010f4fb443dacb5d1227b8a1" translate="yes" xml:space="preserve">
          <source>Only Inserting a Value If the Key Has No Value</source>
          <target state="translated">키에 값이없는 경우에만 값 삽입</target>
        </trans-unit>
        <trans-unit id="a86a2e98e34b9080a837979f0cd7c8a23bdc05cc" translate="yes" xml:space="preserve">
          <source>Only a higher-ranked bound can be used here as the lifetime of the reference is shorter than a lifetime parameter on the function:</source>
          <target state="translated">참조의 수명이 함수의 수명 매개 변수보다 짧기 때문에 상위 바운드 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="154f9dfbda3c7139a94a5be92a5a5842ea10cd7e" translate="yes" xml:space="preserve">
          <source>Only a single explicit lifetime bound is permitted on trait objects. To fix this error, consider removing one of the lifetime bounds:</source>
          <target state="translated">특성 개체에는 명시 적 수명 제한이 하나만 허용됩니다. 이 오류를 수정하려면 수명 범위 중 하나를 제거하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1d9857467e96b586319b486e37d19a227573b8ef" translate="yes" xml:space="preserve">
          <source>Only considers whole path components to match.</source>
          <target state="translated">전체 경로 구성 요소 만 일치한다고 간주합니다.</target>
        </trans-unit>
        <trans-unit id="79d045850f7f84e6ac5788c792fcb946090d94ed" translate="yes" xml:space="preserve">
          <source>Only field-less enums can be cast to numerical primitives, so this attribute will not apply to structs.</source>
          <target state="translated">필드가없는 열거 형 만 숫자 기본 요소로 캐스트 할 수 있으므로이 속성은 구조체에 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="848279e3313c44734789a01608c8102412c68498" translate="yes" xml:space="preserve">
          <source>Only foreign functions can use the C-variadic type (&lt;code&gt;...&lt;/code&gt;). In such functions, &lt;code&gt;...&lt;/code&gt; may only occur non-nested. That is, &lt;code&gt;y: &amp;amp;'a ...&lt;/code&gt; is not allowed.</source>
          <target state="translated">외래 함수 만 C- 변수 유형 ( &lt;code&gt;...&lt;/code&gt; )을 사용할 수 있습니다 . 이러한 함수에서 &lt;code&gt;...&lt;/code&gt; 는 중첩되지 않은 상태로만 발생할 수 있습니다. 즉, &lt;code&gt;y: &amp;amp;'a ...&lt;/code&gt; 는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="905a2eaaaa2de81962debc1768f8a3e80eac42bb" translate="yes" xml:space="preserve">
          <source>Only functions and methods can be called using &lt;code&gt;()&lt;/code&gt;. Example:</source>
          <target state="translated">&lt;code&gt;()&lt;/code&gt; 를 사용하여 함수와 메소드 만 호출 할 수 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="75a9ac98deeca6b24da630baa2c701b9504057f7" translate="yes" xml:space="preserve">
          <source>Only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; if a conversion to a type outside the current crate is required. &lt;code&gt;From&lt;/code&gt; cannot do these type of conversions because of Rust's orphaning rules. See &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">현재 상자 이외의 유형으로 변환해야하는 경우 에만 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; 를&lt;/a&gt; 구현하십시오 . &lt;code&gt;From&lt;/code&gt; 할 수 있기 때문에 녹의 orphaning 규칙의 전환이 유형을하지. 참조 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="9b305a83e8f3d0e4a37b5c57b23584e5d9862317" translate="yes" xml:space="preserve">
          <source>Only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; when targeting a version prior to Rust 1.41 and converting to a type outside the current crate. &lt;code&gt;From&lt;/code&gt; was not able to do these types of conversions in earlier versions because of Rust's orphaning rules. See &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">Rust 1.41 이전 버전을 대상으로하고 현재 상자 외부의 유형으로 변환 할 때만 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; 를&lt;/a&gt; 구현 하십시오. &lt;code&gt;From&lt;/code&gt; 은 Rust의 고아 규칙 때문에 이전 버전에서 이러한 유형의 변환을 수행 할 수 없었습니다. 자세한 내용은 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="32f9fc3a3cbf2058b25d70080083b8cc212e6656" translate="yes" xml:space="preserve">
          <source>Only one argument can be passed per use. So instead of:</source>
          <target state="translated">사용 당 하나의 인수 만 전달할 수 있습니다. 따라서 대신 :</target>
        </trans-unit>
        <trans-unit id="457e98acf3983b9b27751cc789092296edcc762f" translate="yes" xml:space="preserve">
          <source>Only one thread will have &lt;code&gt;true&lt;/code&gt; returned from their result, all other threads will have &lt;code&gt;false&lt;/code&gt; returned.</source>
          <target state="translated">하나의 스레드 만 결과에서 &lt;code&gt;true&lt;/code&gt; 를 반환하고 다른 모든 스레드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc230d3e221cc5ba4ebb17173e6ee922e206f00e" translate="yes" xml:space="preserve">
          <source>Only paths to traits are allowed as argument inside &lt;code&gt;#[derive]&lt;/code&gt;. You can find more information about the &lt;code&gt;#[derive]&lt;/code&gt; attribute in the &lt;a href=&quot;book/appendix-03-derivable-traits&quot;&gt;Rust Book&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3609d3dffa4fe7169c12045193a601a2a125a6f" translate="yes" xml:space="preserve">
          <source>Only primitive types can be cast into each other. Examples:</source>
          <target state="translated">기본 유형 만 서로 캐스트 할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="ab9f48b23a6a48f0ef7b5f4e6bfbc32e252bb8f0" translate="yes" xml:space="preserve">
          <source>Only published blog posts return content to print, so unapproved posts can&amp;rsquo;t accidentally be published.</source>
          <target state="translated">게시 된 블로그 게시물 만 인쇄 할 내용을 반환하므로 승인되지 않은 게시물은 실수로 게시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="073ebf55d3884fb61165383e76a504c9d12cc4b5" translate="yes" xml:space="preserve">
          <source>Only structs and enums are permitted to impl Send, Sync, and other opt-out trait, and the struct or enum must be local to the current crate. So, for example, &lt;code&gt;unsafe impl Send for Rc&amp;lt;Foo&amp;gt;&lt;/code&gt; is not allowed.</source>
          <target state="translated">구조체와 열거 형 만 보내기, 동기화 및 기타 옵트 아웃 특성을 내포 할 수 있으며 구조체 나 열거 형은 현재 상자에 로컬이어야합니다. 예를 들어 &lt;code&gt;unsafe impl Send for Rc&amp;lt;Foo&amp;gt;&lt;/code&gt; 는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="48b01a920bc2fb585e3535476a3e6dbbaef350e6" translate="yes" xml:space="preserve">
          <source>Only structural-match types (that is, types that derive &lt;code&gt;PartialEq&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt;) may be used as the types of const generic parameters.</source>
          <target state="translated">구조적 일치 유형 (즉, &lt;code&gt;PartialEq&lt;/code&gt; 및 &lt;code&gt;Eq&lt;/code&gt; 를 파생 하는 유형) 만 const 제네릭 매개 변수 유형으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51b0c3f2b71fcd0ea3442b5d718eb8c566a2296f" translate="yes" xml:space="preserve">
          <source>Only the appearance of &lt;em&gt;uncovered&lt;/em&gt; type parameters is restricted. Note that for the purposes of coherence, &lt;a href=&quot;../glossary#fundamental-type-constructors&quot;&gt;fundamental types&lt;/a&gt; are special. The &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is not considered covered, and &lt;code&gt;Box&amp;lt;LocalType&amp;gt;&lt;/code&gt; is considered local.</source>
          <target state="translated">&lt;em&gt;커버되지 않은&lt;/em&gt; 유형 매개 변수 의 모양 만 제한됩니다. 일관성을 위해 &lt;a href=&quot;../glossary#fundamental-type-constructors&quot;&gt;기본 유형&lt;/a&gt; 은 특별합니다. &lt;code&gt;T&lt;/code&gt; 의 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 포함로 간주되지 않으며, &lt;code&gt;Box&amp;lt;LocalType&amp;gt;&lt;/code&gt; 지역 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="62a5a90afa5fbb53aff61b9a8c2fc3d66d83b35e" translate="yes" xml:space="preserve">
          <source>Only the last field of &lt;code&gt;Foo&lt;/code&gt; has a type involving &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 의 마지막 필드에만 &lt;code&gt;T&lt;/code&gt; 와 관련된 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa278176dd71a6e098f1078a99115e300d8910ce" translate="yes" xml:space="preserve">
          <source>Only the test with the name &lt;code&gt;one_hundred&lt;/code&gt; ran; the other two tests didn&amp;rsquo;t match that name. The test output lets us know we had more tests than what this command ran by displaying &lt;code&gt;2 filtered out&lt;/code&gt; at the end of the summary line.</source>
          <target state="translated">&lt;code&gt;one_hundred&lt;/code&gt; 라는 이름의 테스트 만 실행되었습니다. 다른 두 테스트는 그 이름과 일치하지 않았습니다. 테스트 결과 는 요약 행 끝에 &lt;code&gt;2 filtered out&lt;/code&gt; 을 표시하여이 명령이 실행 한 것보다 더 많은 테스트를 수행했음을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="d609ff949d70f19612dfe2483b65eb476e7f69db" translate="yes" xml:space="preserve">
          <source>Only traits defined in the current crate can be implemented for arbitrary types.</source>
          <target state="translated">현재 상자에 정의 된 특성 만 임의 유형에 대해 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="faa9f253f7801e4d949e62ca0dcb20642b072d46" translate="yes" xml:space="preserve">
          <source>Only types implementing &lt;code&gt;std::ops::Deref&lt;/code&gt; can be dereferenced (such as &lt;code&gt;&amp;amp;T&lt;/code&gt;). Example:</source>
          <target state="translated">&lt;code&gt;std::ops::Deref&lt;/code&gt; 구현하는 유형 만 역 참조 될 수 있습니다 (예 : &lt;code&gt;&amp;amp;T&lt;/code&gt; ). 예:</target>
        </trans-unit>
        <trans-unit id="5b7cee0492b998101b493b89f7410ea880e0f8c8" translate="yes" xml:space="preserve">
          <source>Only use the item in the scope it has been defined:</source>
          <target state="translated">정의 된 범위 내에서만 항목을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="737047a48ebff11c2ae87259e8e12b5a0ea9f000" translate="yes" xml:space="preserve">
          <source>Opaque type representing the discriminant of an enum.</source>
          <target state="translated">열거 형의 판별자를 나타내는 불투명 한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="3ba5a04eec7ab34d16390d75e26fc3fe98620cc4" translate="yes" xml:space="preserve">
          <source>Open &lt;em&gt;Cargo.toml&lt;/em&gt; in your text editor of choice. It should look similar to the code in Listing 1-2.</source>
          <target state="translated">선택한 텍스트 편집기에서 &lt;em&gt;Cargo.toml&lt;/em&gt; 을 엽니 다 . Listing 1-2의 코드와 비슷해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b3dfe100cddab4329734c9e3ee2eed64968e7db" translate="yes" xml:space="preserve">
          <source>Open Source Developers</source>
          <target state="translated">오픈 소스 개발자</target>
        </trans-unit>
        <trans-unit id="9e593a95e08dd5f0164cac54edffcaa5d02e5a5e" translate="yes" xml:space="preserve">
          <source>Open a TCP connection to &lt;code&gt;127.0.0.1:8080&lt;/code&gt;. If the connection fails, open a TCP connection to &lt;code&gt;127.0.0.1:8081&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;127.0.0.1:8080&lt;/code&gt; 에 대한 TCP 연결을여십시오 . 연결이 실패하면 &lt;code&gt;127.0.0.1:8081&lt;/code&gt; 에 대한 TCP 연결을여십시오 .</target>
        </trans-unit>
        <trans-unit id="36758b7ca5d96a8abc3401009a4668433b033b74" translate="yes" xml:space="preserve">
          <source>Open a TCP connection to &lt;code&gt;127.0.0.1:8080&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;127.0.0.1:8080&lt;/code&gt; 에 대한 TCP 연결을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="7e13d18d4e6433983fbb1efa54b9983d326c5ae6" translate="yes" xml:space="preserve">
          <source>Open a terminal and enter the following commands to make a &lt;em&gt;projects&lt;/em&gt; directory and a directory for the &amp;ldquo;Hello, world!&amp;rdquo; project within the &lt;em&gt;projects&lt;/em&gt; directory.</source>
          <target state="translated">터미널을 열고 다음 명령을 입력하여 &lt;em&gt;프로젝트&lt;/em&gt; 디렉토리와 &quot;Hello, world!&quot;를위한 디렉토리 를 만듭니다 . 프로젝트 디렉토리 내의 &lt;em&gt;프로젝트&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="65c15f3ba1726083fcf5e460a4e8e6321cd0586e" translate="yes" xml:space="preserve">
          <source>Open a terminal and enter the following commands to make a &lt;em&gt;projects&lt;/em&gt; directory and a directory for the Hello, world! project within the &lt;em&gt;projects&lt;/em&gt; directory.</source>
          <target state="translated">터미널을 열고 다음 명령을 입력하여 &lt;em&gt;프로젝트&lt;/em&gt; 디렉토리와 Hello, world! 디렉토리 를 만드십시오 . 프로젝트 디렉토리 내의 &lt;em&gt;프로젝트&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b4eb537f2a91bae055600573be45de77a27b9ed7" translate="yes" xml:space="preserve">
          <source>Open locally installed documentation</source>
          <target state="translated">로컬로 설치된 설명서 열기</target>
        </trans-unit>
        <trans-unit id="84587cdad70cebf6217908dcf7d0133574192d78" translate="yes" xml:space="preserve">
          <source>Open your I/O project&amp;rsquo;s &lt;em&gt;src/main.rs&lt;/em&gt; file, which should look like this:</source>
          <target state="translated">다음과 같이 I / O 프로젝트의 &lt;em&gt;src / main.rs&lt;/em&gt; 파일을여십시오.</target>
        </trans-unit>
        <trans-unit id="aa0399eaec8c7efbd5c34bb50abdda7465b3ccba" translate="yes" xml:space="preserve">
          <source>OpenOptions</source>
          <target state="translated">OpenOptions</target>
        </trans-unit>
        <trans-unit id="8de57f288f4a4084e69c7c4b2aa9da0a06b4257d" translate="yes" xml:space="preserve">
          <source>OpenOptions::access_mode</source>
          <target state="translated">OpenOptions::access_mode</target>
        </trans-unit>
        <trans-unit id="b67e2c499284523d04746aeea5c1bfc24b967904" translate="yes" xml:space="preserve">
          <source>OpenOptions::append</source>
          <target state="translated">OpenOptions::append</target>
        </trans-unit>
        <trans-unit id="32e358709483fecc1c34aed91a515c84a061da75" translate="yes" xml:space="preserve">
          <source>OpenOptions::attributes</source>
          <target state="translated">OpenOptions::attributes</target>
        </trans-unit>
        <trans-unit id="e5c7a13c833ad959de5247957e258cf0746e21f9" translate="yes" xml:space="preserve">
          <source>OpenOptions::borrow</source>
          <target state="translated">OpenOptions::borrow</target>
        </trans-unit>
        <trans-unit id="0acab324be26d91ab189d61abdf16dc747c5192c" translate="yes" xml:space="preserve">
          <source>OpenOptions::borrow_mut</source>
          <target state="translated">OpenOptions::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ebf38deb5d5125bd571ab2fbede6b16bab299f15" translate="yes" xml:space="preserve">
          <source>OpenOptions::clone</source>
          <target state="translated">OpenOptions::clone</target>
        </trans-unit>
        <trans-unit id="f31d22dcf8f9c141ab8ed3fbc1d9d368635388e2" translate="yes" xml:space="preserve">
          <source>OpenOptions::clone_from</source>
          <target state="translated">OpenOptions::clone_from</target>
        </trans-unit>
        <trans-unit id="b0b15f6e5b6b2ad70a686d3798f9b969c1be6e56" translate="yes" xml:space="preserve">
          <source>OpenOptions::clone_into</source>
          <target state="translated">OpenOptions::clone_into</target>
        </trans-unit>
        <trans-unit id="2924b17a8e2b9d34f65d2694a37b0e1b92b85fc1" translate="yes" xml:space="preserve">
          <source>OpenOptions::create</source>
          <target state="translated">OpenOptions::create</target>
        </trans-unit>
        <trans-unit id="518de4d4d480c6aa0ee355b7e8b68e44c261345e" translate="yes" xml:space="preserve">
          <source>OpenOptions::create_new</source>
          <target state="translated">OpenOptions::create_new</target>
        </trans-unit>
        <trans-unit id="5af121b8450a8bfc83582fafa544f257437f0c14" translate="yes" xml:space="preserve">
          <source>OpenOptions::custom_flags</source>
          <target state="translated">OpenOptions::custom_flags</target>
        </trans-unit>
        <trans-unit id="676df7a6e2a4b55c69a37308e4d1e8ab3f83cd3a" translate="yes" xml:space="preserve">
          <source>OpenOptions::fmt</source>
          <target state="translated">OpenOptions::fmt</target>
        </trans-unit>
        <trans-unit id="82f3b255624db61ae979a06d980867d5802d4709" translate="yes" xml:space="preserve">
          <source>OpenOptions::from</source>
          <target state="translated">OpenOptions::from</target>
        </trans-unit>
        <trans-unit id="96ad0ddadc43e2419e6227a5777a55351dd9ac83" translate="yes" xml:space="preserve">
          <source>OpenOptions::into</source>
          <target state="translated">OpenOptions::into</target>
        </trans-unit>
        <trans-unit id="8b77c907fad19cddc5960121fab1fa49b4431f22" translate="yes" xml:space="preserve">
          <source>OpenOptions::mode</source>
          <target state="translated">OpenOptions::mode</target>
        </trans-unit>
        <trans-unit id="1285fb69a9cc28fa9fdf3579b2f9690ab52069d7" translate="yes" xml:space="preserve">
          <source>OpenOptions::new</source>
          <target state="translated">OpenOptions::new</target>
        </trans-unit>
        <trans-unit id="aa320b137860771a593f171b8bca56f205bab7e2" translate="yes" xml:space="preserve">
          <source>OpenOptions::open</source>
          <target state="translated">OpenOptions::open</target>
        </trans-unit>
        <trans-unit id="add50a5d5957c658756ea3d2bf5f0dc20542a4ce" translate="yes" xml:space="preserve">
          <source>OpenOptions::read</source>
          <target state="translated">OpenOptions::read</target>
        </trans-unit>
        <trans-unit id="7e91e59a4c689bbc7efae946cf7ef51cecceeefe" translate="yes" xml:space="preserve">
          <source>OpenOptions::security_qos_flags</source>
          <target state="translated">OpenOptions::security_qos_flags</target>
        </trans-unit>
        <trans-unit id="90b2992d4cec48c28058dee872298370548406ec" translate="yes" xml:space="preserve">
          <source>OpenOptions::share_mode</source>
          <target state="translated">OpenOptions::share_mode</target>
        </trans-unit>
        <trans-unit id="48a692736f06da779873a596d6bb2424b9ad7161" translate="yes" xml:space="preserve">
          <source>OpenOptions::to_owned</source>
          <target state="translated">OpenOptions::to_owned</target>
        </trans-unit>
        <trans-unit id="46e980851a36d656e0daadb411e16ffdbbc2e1eb" translate="yes" xml:space="preserve">
          <source>OpenOptions::truncate</source>
          <target state="translated">OpenOptions::truncate</target>
        </trans-unit>
        <trans-unit id="5f197b60663b22df305247c4bfa1a457e5c0d835" translate="yes" xml:space="preserve">
          <source>OpenOptions::try_from</source>
          <target state="translated">OpenOptions::try_from</target>
        </trans-unit>
        <trans-unit id="747eda4c8e3b44e7c01f7e027a9bd03352e1f790" translate="yes" xml:space="preserve">
          <source>OpenOptions::try_into</source>
          <target state="translated">OpenOptions::try_into</target>
        </trans-unit>
        <trans-unit id="5058de688dcc60c90693a5096962f6405ea1f171" translate="yes" xml:space="preserve">
          <source>OpenOptions::type_id</source>
          <target state="translated">OpenOptions::type_id</target>
        </trans-unit>
        <trans-unit id="19a0518d3e6a36eb2eabd3b78700ce36d617b64d" translate="yes" xml:space="preserve">
          <source>OpenOptions::write</source>
          <target state="translated">OpenOptions::write</target>
        </trans-unit>
        <trans-unit id="6dc0ebb4fa3738b9bc9aac0db1fdc06f34fea9fc" translate="yes" xml:space="preserve">
          <source>OpenOptionsExt</source>
          <target state="translated">OpenOptionsExt</target>
        </trans-unit>
        <trans-unit id="45d6a023e7aaf3a8b617725a7efb650cf62cdf6c" translate="yes" xml:space="preserve">
          <source>Opening a file for both reading and writing, as well as creating it if it doesn't exist:</source>
          <target state="translated">읽기 및 쓰기를위한 파일 열기 및 존재하지 않는 경우 파일 열기 :</target>
        </trans-unit>
        <trans-unit id="d0521aae78e8ad155838f7de5e8f14d0ef7781f3" translate="yes" xml:space="preserve">
          <source>Opening a file to read:</source>
          <target state="translated">읽을 파일 열기 :</target>
        </trans-unit>
        <trans-unit id="d7d34b4c8e94f4c904313459b9fb9b442177d441" translate="yes" xml:space="preserve">
          <source>Opens a TCP connection to a remote host with a timeout.</source>
          <target state="translated">시간 초과로 원격 호스트에 대한 TCP 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="209d3641e1fce80e2ba36a03cac2a67f569fb4c6" translate="yes" xml:space="preserve">
          <source>Opens a TCP connection to a remote host.</source>
          <target state="translated">원격 호스트에 대한 TCP 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="48dea963058d766cb37add48852fe3f445feaf08" translate="yes" xml:space="preserve">
          <source>Opens a file at &lt;code&gt;path&lt;/code&gt; with the options specified by &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 로 지정된 옵션을 사용하여 &lt;code&gt;path&lt;/code&gt; 에서 파일을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="1ebe50b26242826a11bca679d30a026d4444d1a2" translate="yes" xml:space="preserve">
          <source>Opens a file in write-only mode.</source>
          <target state="translated">쓰기 전용 모드로 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="127d959111790c197f023d709985c8cb7e583159" translate="yes" xml:space="preserve">
          <source>Operand of the &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference operator&lt;/a&gt; (&lt;code&gt;*&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;역 참조 연산자의&lt;/a&gt; 피연산자 ( &lt;code&gt;*&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a2b8c4621b34e3c27498c6c8832719e530f09634" translate="yes" xml:space="preserve">
          <source>Operands</source>
          <target state="translated">Operands</target>
        </trans-unit>
        <trans-unit id="3b28f00441a9534ad36bef8779425496277b4521" translate="yes" xml:space="preserve">
          <source>Operands of &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;comparison&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;비교의&lt;/a&gt; 피연산자 .</target>
        </trans-unit>
        <trans-unit id="796e9c6aba0ed5f7facb56a161b990345eb7dff2" translate="yes" xml:space="preserve">
          <source>Operations like &lt;code&gt;+&lt;/code&gt; on &lt;code&gt;u32&lt;/code&gt; values are intended to never overflow, and in some debug configurations overflow is detected and results in a panic. While most arithmetic falls into this category, some code explicitly expects and relies upon modular arithmetic (e.g., hashing).</source>
          <target state="translated">&lt;code&gt;u32&lt;/code&gt; 값 에 대한 &lt;code&gt;+&lt;/code&gt; 와 같은 작업은 오버플로를 방지하기위한 것이며 일부 디버그 구성에서는 오버플로가 감지되어 패닉이 발생합니다. 대부분의 산술이이 범주에 속하지만 일부 코드는 모듈 식 산술 (예 : 해싱)을 명시 적으로 예상하고 이에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="fd7809a925050c789646447f7ccccf00c4e8608c" translate="yes" xml:space="preserve">
          <source>Operations like &lt;code&gt;+&lt;/code&gt; on &lt;code&gt;u32&lt;/code&gt; values is intended to never overflow, and in some debug configurations overflow is detected and results in a panic. While most arithmetic falls into this category, some code explicitly expects and relies upon modular arithmetic (e.g., hashing).</source>
          <target state="translated">&lt;code&gt;u32&lt;/code&gt; 값 에서 &lt;code&gt;+&lt;/code&gt; 와 같은 연산 은 오버플로되지 않으며 일부 디버그 구성에서는 오버플로가 감지되어 패닉이 발생합니다. 대부분의 산술이이 범주에 속하지만 일부 코드는 모듈 식 산술 (예 : 해싱)을 명시 적으로 기대하고 의존합니다.</target>
        </trans-unit>
        <trans-unit id="732a02d050941e6169a56caaf931604a39dfcf26" translate="yes" xml:space="preserve">
          <source>Operations on ASCII strings and characters.</source>
          <target state="translated">ASCII 문자열 및 문자에 대한 작업.</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="e2cce0c9ff63663c1cea812414bb03fc6e974bec" translate="yes" xml:space="preserve">
          <source>Operator Traits</source>
          <target state="translated">운영자 특성</target>
        </trans-unit>
        <trans-unit id="9cad0fd3139ef048c0168daf393a34c1807af1a2" translate="yes" xml:space="preserve">
          <source>Operator expressions</source>
          <target state="translated">연산자 표현식</target>
        </trans-unit>
        <trans-unit id="9ae1b0ed74ef02f2a20320b8054a76c10c592467" translate="yes" xml:space="preserve">
          <source>Operator/Expression</source>
          <target state="translated">Operator/Expression</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="a48efc62628a97b690c020f8a1e8f8cb0bb0733d" translate="yes" xml:space="preserve">
          <source>Operators are defined for built in types by the Rust language. Many of the following operators can also be overloaded using traits in &lt;code&gt;std::ops&lt;/code&gt; or &lt;code&gt;std::cmp&lt;/code&gt;.</source>
          <target state="translated">연산자는 Rust 언어에 의해 내장 유형으로 정의됩니다. &lt;code&gt;std::ops&lt;/code&gt; 또는 &lt;code&gt;std::cmp&lt;/code&gt; 특성을 사용하여 다음 연산자 중 다수를 오버로드 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7b5d154187c93c9da7d2603b606ea0b5d7ebfc3" translate="yes" xml:space="preserve">
          <source>Optimization hints</source>
          <target state="translated">최적화 힌트</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="9a8587bd4b256cb6bf9e533c046c7ec07658a2a8" translate="yes" xml:space="preserve">
          <source>Option::and</source>
          <target state="translated">Option::and</target>
        </trans-unit>
        <trans-unit id="ad6a1d3208211ea9f4a0bbc163a21ab722dcc207" translate="yes" xml:space="preserve">
          <source>Option::and_then</source>
          <target state="translated">Option::and_then</target>
        </trans-unit>
        <trans-unit id="3f27b9ef99923ea0d93a7d269559394c38b333c3" translate="yes" xml:space="preserve">
          <source>Option::as_mut</source>
          <target state="translated">Option::as_mut</target>
        </trans-unit>
        <trans-unit id="e2458bfdc527d230aa943b40bea1e47ef7c1716a" translate="yes" xml:space="preserve">
          <source>Option::as_pin_mut</source>
          <target state="translated">Option::as_pin_mut</target>
        </trans-unit>
        <trans-unit id="627cd8388f389dc8a414dc64f0bd2aeb93b8bdb8" translate="yes" xml:space="preserve">
          <source>Option::as_pin_ref</source>
          <target state="translated">Option::as_pin_ref</target>
        </trans-unit>
        <trans-unit id="9e1386f584a53f30c4efc9f16fd6a42d3d390020" translate="yes" xml:space="preserve">
          <source>Option::as_ref</source>
          <target state="translated">Option::as_ref</target>
        </trans-unit>
        <trans-unit id="7e71699a5e7a9d061403b6a9d9cd2031f35e7d57" translate="yes" xml:space="preserve">
          <source>Option::borrow</source>
          <target state="translated">Option::borrow</target>
        </trans-unit>
        <trans-unit id="5a2fc76bcd6cc7797b2fc8e79077c3b905ad253b" translate="yes" xml:space="preserve">
          <source>Option::borrow_mut</source>
          <target state="translated">Option::borrow_mut</target>
        </trans-unit>
        <trans-unit id="f8c7733356cc897d454d9d0b3ed5583a86a4fc0c" translate="yes" xml:space="preserve">
          <source>Option::clamp</source>
          <target state="translated">Option::clamp</target>
        </trans-unit>
        <trans-unit id="b2ed5b3da837f6c02fff44b90e9fcf28f2c92857" translate="yes" xml:space="preserve">
          <source>Option::clone</source>
          <target state="translated">Option::clone</target>
        </trans-unit>
        <trans-unit id="41a138cf124c5fbd9ab6a71d2a521b6f7b355bd9" translate="yes" xml:space="preserve">
          <source>Option::clone_from</source>
          <target state="translated">Option::clone_from</target>
        </trans-unit>
        <trans-unit id="428c2ed3ef54229edff7bb1c574b0bfd79b5c01e" translate="yes" xml:space="preserve">
          <source>Option::clone_into</source>
          <target state="translated">Option::clone_into</target>
        </trans-unit>
        <trans-unit id="7cd06b03e80642a3e13258da69f36190c57d76fe" translate="yes" xml:space="preserve">
          <source>Option::cloned</source>
          <target state="translated">Option::cloned</target>
        </trans-unit>
        <trans-unit id="7ea9e4985c5cd3b4ff11c4891148d8ba5e1cf7f3" translate="yes" xml:space="preserve">
          <source>Option::cmp</source>
          <target state="translated">Option::cmp</target>
        </trans-unit>
        <trans-unit id="0498a1a6447eab280dd5d4ffdbbf44f5e3cd0a3e" translate="yes" xml:space="preserve">
          <source>Option::copied</source>
          <target state="translated">Option::copied</target>
        </trans-unit>
        <trans-unit id="cb4ad142555a29053e45e10fc10d79edcbc2a96c" translate="yes" xml:space="preserve">
          <source>Option::default</source>
          <target state="translated">Option::default</target>
        </trans-unit>
        <trans-unit id="ba7eb304c78625b7673ed4fb2b20bafd2105ff7d" translate="yes" xml:space="preserve">
          <source>Option::deref</source>
          <target state="translated">Option::deref</target>
        </trans-unit>
        <trans-unit id="cb4668f98374c478c313d6124b78706cb9deedbc" translate="yes" xml:space="preserve">
          <source>Option::eq</source>
          <target state="translated">Option::eq</target>
        </trans-unit>
        <trans-unit id="76cfff0c978f7770807e24ce63e5dfca252d4367" translate="yes" xml:space="preserve">
          <source>Option::expect</source>
          <target state="translated">Option::expect</target>
        </trans-unit>
        <trans-unit id="6a0b764b6cbe10497b80db91840a28c114598907" translate="yes" xml:space="preserve">
          <source>Option::filter</source>
          <target state="translated">Option::filter</target>
        </trans-unit>
        <trans-unit id="560bd097e6d518e06d94482f4a9697ad398f15d0" translate="yes" xml:space="preserve">
          <source>Option::flatten</source>
          <target state="translated">Option::flatten</target>
        </trans-unit>
        <trans-unit id="d94a2e5f0e616513666e331c6d9144bddb878e9c" translate="yes" xml:space="preserve">
          <source>Option::fmt</source>
          <target state="translated">Option::fmt</target>
        </trans-unit>
        <trans-unit id="cbd7d776e3b699aac19b698f4ca1165601a486cb" translate="yes" xml:space="preserve">
          <source>Option::from</source>
          <target state="translated">Option::from</target>
        </trans-unit>
        <trans-unit id="e4ce8c942f648512db0f55fca12f5af00d0f8696" translate="yes" xml:space="preserve">
          <source>Option::from_error</source>
          <target state="translated">Option::from_error</target>
        </trans-unit>
        <trans-unit id="7e569e7075b5cfd328272103d6b5f8ce7d4d2194" translate="yes" xml:space="preserve">
          <source>Option::from_iter</source>
          <target state="translated">Option::from_iter</target>
        </trans-unit>
        <trans-unit id="a43b3b6ad08c70527052c24fb47f39fcaa4ebb0e" translate="yes" xml:space="preserve">
          <source>Option::from_ok</source>
          <target state="translated">Option::from_ok</target>
        </trans-unit>
        <trans-unit id="39c61b7ca243afc1e123c7964d51460ccf7ce39f" translate="yes" xml:space="preserve">
          <source>Option::ge</source>
          <target state="translated">Option::ge</target>
        </trans-unit>
        <trans-unit id="9b6edfb0a8e4a4f18c5a5177c880df9517534d89" translate="yes" xml:space="preserve">
          <source>Option::get_or_insert</source>
          <target state="translated">Option::get_or_insert</target>
        </trans-unit>
        <trans-unit id="998b5cc317f56f6b2107c170f3756fdcf6a6be39" translate="yes" xml:space="preserve">
          <source>Option::get_or_insert_with</source>
          <target state="translated">Option::get_or_insert_with</target>
        </trans-unit>
        <trans-unit id="ff18d337dd9fab1c83bb85ddea3fd7d94d3281c1" translate="yes" xml:space="preserve">
          <source>Option::gt</source>
          <target state="translated">Option::gt</target>
        </trans-unit>
        <trans-unit id="501ecb8b666b964e28da12f4615b48d3b7e450ee" translate="yes" xml:space="preserve">
          <source>Option::hash</source>
          <target state="translated">Option::hash</target>
        </trans-unit>
        <trans-unit id="8801dd069757ebf03df00700d2f0d8f4ca13be56" translate="yes" xml:space="preserve">
          <source>Option::hash_slice</source>
          <target state="translated">Option::hash_slice</target>
        </trans-unit>
        <trans-unit id="f71ce62ec4a3ad0f752a7c591ebba32d36455564" translate="yes" xml:space="preserve">
          <source>Option::into</source>
          <target state="translated">Option::into</target>
        </trans-unit>
        <trans-unit id="551bf0cc26ba2d59fc63fcbd70e362e1518cf5f4" translate="yes" xml:space="preserve">
          <source>Option::into_iter</source>
          <target state="translated">Option::into_iter</target>
        </trans-unit>
        <trans-unit id="acac2476c84bf169ea317554e6fccedcf73128cf" translate="yes" xml:space="preserve">
          <source>Option::into_result</source>
          <target state="translated">Option::into_result</target>
        </trans-unit>
        <trans-unit id="495a0a7509c9951579c075005e7b0266bf1a69f9" translate="yes" xml:space="preserve">
          <source>Option::is_none</source>
          <target state="translated">Option::is_none</target>
        </trans-unit>
        <trans-unit id="a5dbcd7af5f3480d6b9a0c381da167cc002b596c" translate="yes" xml:space="preserve">
          <source>Option::is_some</source>
          <target state="translated">Option::is_some</target>
        </trans-unit>
        <trans-unit id="da8976bc81fc53470a3fc8a5b2319faadd2e5469" translate="yes" xml:space="preserve">
          <source>Option::iter</source>
          <target state="translated">Option::iter</target>
        </trans-unit>
        <trans-unit id="4938dbe4f632b13fbb7938f29e586697061d0533" translate="yes" xml:space="preserve">
          <source>Option::iter_mut</source>
          <target state="translated">Option::iter_mut</target>
        </trans-unit>
        <trans-unit id="7b1a1684dd39ce6dd73cf515b242f23a85ff1b4b" translate="yes" xml:space="preserve">
          <source>Option::le</source>
          <target state="translated">Option::le</target>
        </trans-unit>
        <trans-unit id="488cf9c5fcceb69fb2b839af923c0fb53e272ed1" translate="yes" xml:space="preserve">
          <source>Option::lt</source>
          <target state="translated">Option::lt</target>
        </trans-unit>
        <trans-unit id="86dab5a9d3dc8266baf2ccd67588a2c19c44f695" translate="yes" xml:space="preserve">
          <source>Option::map</source>
          <target state="translated">Option::map</target>
        </trans-unit>
        <trans-unit id="9191b28fc19ae2afb4047d887913361af7f182b6" translate="yes" xml:space="preserve">
          <source>Option::map_or</source>
          <target state="translated">Option::map_or</target>
        </trans-unit>
        <trans-unit id="7de284a6d01f951e374aa763b2767eae6a3c5ccb" translate="yes" xml:space="preserve">
          <source>Option::map_or_else</source>
          <target state="translated">Option::map_or_else</target>
        </trans-unit>
        <trans-unit id="66654aab17a6b3aa6f143b9ae3fc8b7dca5dabd2" translate="yes" xml:space="preserve">
          <source>Option::max</source>
          <target state="translated">Option::max</target>
        </trans-unit>
        <trans-unit id="1adb57018df709f1877032a8ddcc892c8dac1998" translate="yes" xml:space="preserve">
          <source>Option::min</source>
          <target state="translated">Option::min</target>
        </trans-unit>
        <trans-unit id="eb7a9479460140930952934380e221ea1697242c" translate="yes" xml:space="preserve">
          <source>Option::ne</source>
          <target state="translated">Option::ne</target>
        </trans-unit>
        <trans-unit id="e51e9c41e5e117e0e07f5dfcd46ea7199497f649" translate="yes" xml:space="preserve">
          <source>Option::ok_or</source>
          <target state="translated">Option::ok_or</target>
        </trans-unit>
        <trans-unit id="d3009c3d13c96510f1ca710672d0c816ed55d018" translate="yes" xml:space="preserve">
          <source>Option::ok_or_else</source>
          <target state="translated">Option::ok_or_else</target>
        </trans-unit>
        <trans-unit id="dfb07ec794538d88d7c6482aed34a705f3390f21" translate="yes" xml:space="preserve">
          <source>Option::or</source>
          <target state="translated">Option::or</target>
        </trans-unit>
        <trans-unit id="197db9177edef17365dcd83807a4634b079ac530" translate="yes" xml:space="preserve">
          <source>Option::or_else</source>
          <target state="translated">Option::or_else</target>
        </trans-unit>
        <trans-unit id="47d22a5e34207ea66404113eba50209751121ad9" translate="yes" xml:space="preserve">
          <source>Option::partial_cmp</source>
          <target state="translated">Option::partial_cmp</target>
        </trans-unit>
        <trans-unit id="3e59f933c6766bd1ca8ae161c652e7b1f7df0e0f" translate="yes" xml:space="preserve">
          <source>Option::product</source>
          <target state="translated">Option::product</target>
        </trans-unit>
        <trans-unit id="43654d863e5a9272f5fcee9e6318f91e4ee0f0d7" translate="yes" xml:space="preserve">
          <source>Option::replace</source>
          <target state="translated">Option::replace</target>
        </trans-unit>
        <trans-unit id="33de023317fb385ec03a2bfdc37c470e03771088" translate="yes" xml:space="preserve">
          <source>Option::sum</source>
          <target state="translated">Option::sum</target>
        </trans-unit>
        <trans-unit id="1eb0b7661e8e838c0043a0e9891c68ec0fbe9581" translate="yes" xml:space="preserve">
          <source>Option::take</source>
          <target state="translated">Option::take</target>
        </trans-unit>
        <trans-unit id="281a61201db99ce270b59bd9978c0c4a876c16d2" translate="yes" xml:space="preserve">
          <source>Option::to_owned</source>
          <target state="translated">Option::to_owned</target>
        </trans-unit>
        <trans-unit id="3923e90861904a7d50dc82fa7bf9be53e14859da" translate="yes" xml:space="preserve">
          <source>Option::transpose</source>
          <target state="translated">Option::transpose</target>
        </trans-unit>
        <trans-unit id="29a44fa076b1666e1ed7b6e9a41abfa7aa142ab4" translate="yes" xml:space="preserve">
          <source>Option::try_from</source>
          <target state="translated">Option::try_from</target>
        </trans-unit>
        <trans-unit id="14385e832f6fb04b85656e914cf56c48e8369aff" translate="yes" xml:space="preserve">
          <source>Option::try_into</source>
          <target state="translated">Option::try_into</target>
        </trans-unit>
        <trans-unit id="a80b7a13a9d97e9cdb20ea081ae3532129b7ba72" translate="yes" xml:space="preserve">
          <source>Option::type_id</source>
          <target state="translated">Option::type_id</target>
        </trans-unit>
        <trans-unit id="fde8f7a5fc9d3f658b63f5e23bda1110f162ed70" translate="yes" xml:space="preserve">
          <source>Option::unwrap</source>
          <target state="translated">Option::unwrap</target>
        </trans-unit>
        <trans-unit id="3a5910b9b482b80f2d66da87c051adfb8d8bf61e" translate="yes" xml:space="preserve">
          <source>Option::unwrap_or</source>
          <target state="translated">Option::unwrap_or</target>
        </trans-unit>
        <trans-unit id="976c733f76ae18fb91e76013cca3578adab70346" translate="yes" xml:space="preserve">
          <source>Option::unwrap_or_default</source>
          <target state="translated">Option::unwrap_or_default</target>
        </trans-unit>
        <trans-unit id="f1995eada89f4dc6ecedad44f0c0c2330349c1bc" translate="yes" xml:space="preserve">
          <source>Option::unwrap_or_else</source>
          <target state="translated">Option::unwrap_or_else</target>
        </trans-unit>
        <trans-unit id="68786e698cfd6fd27d36f1fba3b6a686517fa05c" translate="yes" xml:space="preserve">
          <source>Option::xor</source>
          <target state="translated">Option::xor</target>
        </trans-unit>
        <trans-unit id="e3c9c006d7dd32e4af03ce0e476b71491a8d4b8a" translate="yes" xml:space="preserve">
          <source>Optional function arguments</source>
          <target state="translated">선택적 함수 인수</target>
        </trans-unit>
        <trans-unit id="2e47febec66d688ce101287ee00d853516af2cfa" translate="yes" xml:space="preserve">
          <source>Optional struct fields</source>
          <target state="translated">선택적 구조체 필드</target>
        </trans-unit>
        <trans-unit id="1a34f2c7171c8f888634b370538fba1e9d6296a5" translate="yes" xml:space="preserve">
          <source>Optional values.</source>
          <target state="translated">선택적 값.</target>
        </trans-unit>
        <trans-unit id="77d6758103e11af5591d29f41814c8b3a39a2aa1" translate="yes" xml:space="preserve">
          <source>Optionally inspects an environment variable at compile time.</source>
          <target state="translated">선택적으로 컴파일시 환경 변수를 검사합니다.</target>
        </trans-unit>
        <trans-unit id="8c3b56b50deaba4f743a2a6fc1b83731273806d4" translate="yes" xml:space="preserve">
          <source>Optionally specified integer width that the output should be.</source>
          <target state="translated">선택적으로 출력의 정수 너비를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="2048d6f0b11cf29779cd20fa71eaae6ce5ed3b2c" translate="yes" xml:space="preserve">
          <source>Optionally specified precision for numeric types.</source>
          <target state="translated">숫자 유형에 대해 선택적으로 지정된 정밀도.</target>
        </trans-unit>
        <trans-unit id="1485f5527557aac2d77bac994aa8db370179bdf0" translate="yes" xml:space="preserve">
          <source>Optionally specified precision for numeric types. Alternatively, the maximum width for string types.</source>
          <target state="translated">숫자 유형에 대해 선택적으로 지정된 정밀도. 또는 문자열 유형의 최대 너비입니다.</target>
        </trans-unit>
        <trans-unit id="04373894adc677092b8d9a4d5813bcd7335dffdf" translate="yes" xml:space="preserve">
          <source>Optionally, we can also include an &lt;code&gt;else&lt;/code&gt; expression, which we chose to do here, to give the program an alternative block of code to execute should the condition evaluate to false. If you don&amp;rsquo;t provide an &lt;code&gt;else&lt;/code&gt; expression and the condition is false, the program will just skip the &lt;code&gt;if&lt;/code&gt; block and move on to the next bit of code.</source>
          <target state="translated">선택적으로 조건을 거짓으로 평가할 때 실행할 대체 코드 블록을 프로그램에 제공하기 위해 &lt;code&gt;else&lt;/code&gt; 표현식을 포함시킬 수도 있습니다 . &lt;code&gt;else&lt;/code&gt; 표현식을 제공하지 않고 조건이 false 인 경우 프로그램은 &lt;code&gt;if&lt;/code&gt; 블록을 건너 뛰고 다음 코드 비트로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="502d9e6ffaa61a4c673c37dfc595e040fc80f37d" translate="yes" xml:space="preserve">
          <source>Options and flags which can be used to configure how a file is opened.</source>
          <target state="translated">파일을 여는 방법을 구성하는 데 사용할 수있는 옵션 및 플래그.</target>
        </trans-unit>
        <trans-unit id="2972721d46b095876455597aebeba50e3a239b32" translate="yes" xml:space="preserve">
          <source>Options and pointers (&quot;nullable&quot; pointers)</source>
          <target state="translated">옵션 및 포인터 ( &quot;널링 가능&quot;포인터)</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="3521d8b1e1c376b132968d2b9a34b13f5c378d81" translate="yes" xml:space="preserve">
          <source>Or as return types:</source>
          <target state="translated">또는 반환 유형으로 :</target>
        </trans-unit>
        <trans-unit id="3bc6e013cee463ae97ecfa631a2e64cad8625c6a" translate="yes" xml:space="preserve">
          <source>Or by cloning &lt;code&gt;value&lt;/code&gt; before borrowing it:</source>
          <target state="translated">또는 빌리기 전에 &lt;code&gt;value&lt;/code&gt; 를 복제함으로써 :</target>
        </trans-unit>
        <trans-unit id="06b4e6d65f4c6512515713febc219b11096f10cd" translate="yes" xml:space="preserve">
          <source>Or by moving the reference into a function:</source>
          <target state="translated">또는 참조를 함수로 이동하여 :</target>
        </trans-unit>
        <trans-unit id="b578c07095ed6ed46d6f153638a36e12535cf287" translate="yes" xml:space="preserve">
          <source>Or if you want to &lt;code&gt;break&lt;/code&gt; the labeled block:</source>
          <target state="translated">또는 레이블이 지정된 블록 을 &lt;code&gt;break&lt;/code&gt; 하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="543cf658926daaaf4b0291516127021d4e7895e7" translate="yes" xml:space="preserve">
          <source>Or in a generic context, an erroneous code example would look like:</source>
          <target state="translated">또는 일반적인 맥락에서 잘못된 코드 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d25ee9f0412b435226c79f36ce66d89e6ad4a334" translate="yes" xml:space="preserve">
          <source>Or in the &lt;code&gt;where&lt;/code&gt; clause:</source>
          <target state="translated">또는 &lt;code&gt;where&lt;/code&gt; 절에서 :</target>
        </trans-unit>
        <trans-unit id="04b11240c2114782b42391bcc69fead4c1890df6" translate="yes" xml:space="preserve">
          <source>Or make the outer reference mutable:</source>
          <target state="translated">또는 외부 참조를 변경 가능하게 만드십시오.</target>
        </trans-unit>
        <trans-unit id="f651c3b7a885d71e3753d367a44690ed57098104" translate="yes" xml:space="preserve">
          <source>Or maybe did you mean to unify? Consider using a guard:</source>
          <target state="translated">아니면 통일한다는 의미입니까? 가드 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c63cbe0fb14548b7cc3943b49c3283f01873fa23" translate="yes" xml:space="preserve">
          <source>Or propagate the error up the call stack with &lt;a href=&quot;../macro.try&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">또는 &lt;a href=&quot;../macro.try&quot;&gt; &lt;code&gt;?&lt;/code&gt; 를 사용&lt;/a&gt; 하여 오류를 호출 스택에 전파하십시오 . :</target>
        </trans-unit>
        <trans-unit id="9d3b2a716e8d9c7848de5e61cb846ea61281c3e6" translate="yes" xml:space="preserve">
          <source>Or propagate the error up the call stack with &lt;a href=&quot;../ops/trait.try&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">또는 &lt;a href=&quot;../ops/trait.try&quot;&gt; &lt;code&gt;?&lt;/code&gt; 를 사용&lt;/a&gt; 하여 오류를 호출 스택 위로 전파하십시오 . :</target>
        </trans-unit>
        <trans-unit id="e0995f3133b7ba0da84026e83b875a8d8f53ccb9" translate="yes" xml:space="preserve">
          <source>Or put an end to your inclusive range:</source>
          <target state="translated">또는 포함 범위를 끝내십시오.</target>
        </trans-unit>
        <trans-unit id="7cd4277b9afe890f3408bbac80cb04dacb17b62d" translate="yes" xml:space="preserve">
          <source>Or replace the captured variable with a constant or a static item:</source>
          <target state="translated">또는 캡처 된 변수를 상수 또는 정적 항목으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="2a55f1def49ba2cf28edd04aebe0ae914d6adc01" translate="yes" xml:space="preserve">
          <source>Or this:</source>
          <target state="translated">아니면 이거:</target>
        </trans-unit>
        <trans-unit id="9530c0225cb87d6d4bf8e3185c27b10d6c71d11a" translate="yes" xml:space="preserve">
          <source>Or use &lt;code&gt;if let&lt;/code&gt;:</source>
          <target state="translated">아니면 &lt;code&gt;if let&lt;/code&gt; 사용 하십시오 :</target>
        </trans-unit>
        <trans-unit id="273aeb6aa2ac245c7ceee53c519ceb04f6599128" translate="yes" xml:space="preserve">
          <source>Or we could name a function as the argument to &lt;code&gt;map&lt;/code&gt; instead of the closure, like this:</source>
          <target state="translated">또는 함수를 클로저 대신에 &lt;code&gt;map&lt;/code&gt; 할 인수로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a52286981391759a88ba22e7a9a24f451bd18e85" translate="yes" xml:space="preserve">
          <source>Or we could use an &lt;code&gt;if let&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; expression like this:</source>
          <target state="translated">또는 &lt;code&gt;if let&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 식을 다음과 같이 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b200a52a06b6557c28d7d5c924593515b39b57ed" translate="yes" xml:space="preserve">
          <source>Or we use only one lifetime:</source>
          <target state="translated">또는 우리는 수명을 하나만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e6bd34bc197da74a1c27a575e977239ccfe16684" translate="yes" xml:space="preserve">
          <source>Or you can pass the variable as a parameter to the closure:</source>
          <target state="translated">또는 변수를 클로저에 매개 변수로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0f7258ca7f4f4e82cbb45da80b92cb552d5cffe" translate="yes" xml:space="preserve">
          <source>Or you can reference the item with its parent:</source>
          <target state="translated">또는 부모와 함께 항목을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a29edca74e59817dda05bb2e131ecfb108fa5284" translate="yes" xml:space="preserve">
          <source>Or, if the type implements the &lt;code&gt;Clone&lt;/code&gt; trait, you can clone it between closures:</source>
          <target state="translated">또는 유형이 &lt;code&gt;Clone&lt;/code&gt; 특성을 구현하는 경우 클로저간에 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12dfe56e60634e928fd42ae5d599dda01263dc2d" translate="yes" xml:space="preserve">
          <source>Or, if you tried to use a module from an external crate, you may have missed the &lt;code&gt;extern crate&lt;/code&gt; declaration (which is usually placed in the crate root):</source>
          <target state="translated">또는 외부 상자에서 모듈을 사용하려고 시도한 경우 &lt;code&gt;extern crate&lt;/code&gt; 선언 (일반적으로 상자 루트에 있음) 을 놓쳤을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="756e00b4ce5e9d39383d2b108674676d2a5eb78e" translate="yes" xml:space="preserve">
          <source>OrEq</source>
          <target state="translated">OrEq</target>
        </trans-unit>
        <trans-unit id="564b40230868f4b78bca3166973a37e562d97dee" translate="yes" xml:space="preserve">
          <source>OrOr</source>
          <target state="translated">OrOr</target>
        </trans-unit>
        <trans-unit id="2813ca76372ef7834dbf7b83dd19ec3f7be3b60a" translate="yes" xml:space="preserve">
          <source>Ord</source>
          <target state="translated">Ord</target>
        </trans-unit>
        <trans-unit id="74b60f23ebce31b7a22a55c578f050bcee26fe5b" translate="yes" xml:space="preserve">
          <source>Ord::clamp</source>
          <target state="translated">Ord::clamp</target>
        </trans-unit>
        <trans-unit id="c1c60ff58cc75226de9806234302570046dbd8f5" translate="yes" xml:space="preserve">
          <source>Ord::cmp</source>
          <target state="translated">Ord::cmp</target>
        </trans-unit>
        <trans-unit id="5aac35ef704655ca052ef8370ff03afac6b470d9" translate="yes" xml:space="preserve">
          <source>Ord::max</source>
          <target state="translated">Ord::max</target>
        </trans-unit>
        <trans-unit id="44eb8ae78f7ff3385e9ae21dbb73540bf94e22db" translate="yes" xml:space="preserve">
          <source>Ord::min</source>
          <target state="translated">Ord::min</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="c8683d7a9b3cca82d5bfc4fb160497e659833355" translate="yes" xml:space="preserve">
          <source>Ordering::borrow</source>
          <target state="translated">Ordering::borrow</target>
        </trans-unit>
        <trans-unit id="2110fd32ceaf8e35714b9f4c770ee6cbc575392b" translate="yes" xml:space="preserve">
          <source>Ordering::borrow_mut</source>
          <target state="translated">Ordering::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2d789d0561eb273919f31e5f66336ffda8097e51" translate="yes" xml:space="preserve">
          <source>Ordering::clamp</source>
          <target state="translated">Ordering::clamp</target>
        </trans-unit>
        <trans-unit id="6de6fd1c26e0555f07bc1925f3805557c3fda70f" translate="yes" xml:space="preserve">
          <source>Ordering::clone</source>
          <target state="translated">Ordering::clone</target>
        </trans-unit>
        <trans-unit id="eee5275789348dde36794118669be1ff7cd1bb4a" translate="yes" xml:space="preserve">
          <source>Ordering::clone_from</source>
          <target state="translated">Ordering::clone_from</target>
        </trans-unit>
        <trans-unit id="40853728568d4672aba47821accc24160a1b99f8" translate="yes" xml:space="preserve">
          <source>Ordering::clone_into</source>
          <target state="translated">Ordering::clone_into</target>
        </trans-unit>
        <trans-unit id="d214ed8406272d61a0d7c592025d6abf1f5d1473" translate="yes" xml:space="preserve">
          <source>Ordering::cmp</source>
          <target state="translated">Ordering::cmp</target>
        </trans-unit>
        <trans-unit id="6359dfdce4c6d799333d91033efe381426c22804" translate="yes" xml:space="preserve">
          <source>Ordering::eq</source>
          <target state="translated">Ordering::eq</target>
        </trans-unit>
        <trans-unit id="e55fb4de4f643ffa35cfa13e29a8d8ae17c99930" translate="yes" xml:space="preserve">
          <source>Ordering::fmt</source>
          <target state="translated">Ordering::fmt</target>
        </trans-unit>
        <trans-unit id="8223604ca595d0dc7d03ed1d15beee5d38176846" translate="yes" xml:space="preserve">
          <source>Ordering::from</source>
          <target state="translated">Ordering::from</target>
        </trans-unit>
        <trans-unit id="a579d7a090bb1dc3fd3d2f9a3e37ce7352737881" translate="yes" xml:space="preserve">
          <source>Ordering::ge</source>
          <target state="translated">Ordering::ge</target>
        </trans-unit>
        <trans-unit id="4618dec778641079f26c6e4998d38724ccd55bc3" translate="yes" xml:space="preserve">
          <source>Ordering::gt</source>
          <target state="translated">Ordering::gt</target>
        </trans-unit>
        <trans-unit id="efe1e62a68b71bab75ead05adff759d1187652f7" translate="yes" xml:space="preserve">
          <source>Ordering::hash</source>
          <target state="translated">Ordering::hash</target>
        </trans-unit>
        <trans-unit id="c05089412848f92294833568d422af5dbf1903b4" translate="yes" xml:space="preserve">
          <source>Ordering::hash_slice</source>
          <target state="translated">Ordering::hash_slice</target>
        </trans-unit>
        <trans-unit id="2250580789c212cd410023ce2ecb8bbc3f4ed5d2" translate="yes" xml:space="preserve">
          <source>Ordering::into</source>
          <target state="translated">Ordering::into</target>
        </trans-unit>
        <trans-unit id="70a87b5390eddefc5bd61055a8da6b411465a3b4" translate="yes" xml:space="preserve">
          <source>Ordering::le</source>
          <target state="translated">Ordering::le</target>
        </trans-unit>
        <trans-unit id="e07fd04110fe52e557d54608bb0d4cf4cd5af061" translate="yes" xml:space="preserve">
          <source>Ordering::lt</source>
          <target state="translated">Ordering::lt</target>
        </trans-unit>
        <trans-unit id="2da6624e13df6b2930a58d521c8512c0ee8d6a7b" translate="yes" xml:space="preserve">
          <source>Ordering::max</source>
          <target state="translated">Ordering::max</target>
        </trans-unit>
        <trans-unit id="9beab77e1fd3338267c9abb1b7bdf0317c0f161a" translate="yes" xml:space="preserve">
          <source>Ordering::min</source>
          <target state="translated">Ordering::min</target>
        </trans-unit>
        <trans-unit id="110f4e4f96d577bdee265f9f4c84f0bc5a9e62d9" translate="yes" xml:space="preserve">
          <source>Ordering::ne</source>
          <target state="translated">Ordering::ne</target>
        </trans-unit>
        <trans-unit id="932d7efe4223aad7b2447933dc9fc2df76690914" translate="yes" xml:space="preserve">
          <source>Ordering::partial_cmp</source>
          <target state="translated">Ordering::partial_cmp</target>
        </trans-unit>
        <trans-unit id="bd351c74f745da13de54fe0d9a1669cfb9e21ee6" translate="yes" xml:space="preserve">
          <source>Ordering::reverse</source>
          <target state="translated">Ordering::reverse</target>
        </trans-unit>
        <trans-unit id="8db4349ef9928c9f97e125860622b05714dc2737" translate="yes" xml:space="preserve">
          <source>Ordering::then</source>
          <target state="translated">Ordering::then</target>
        </trans-unit>
        <trans-unit id="ad25d15baa7a0275cbc02b73accdf10273dae875" translate="yes" xml:space="preserve">
          <source>Ordering::then_with</source>
          <target state="translated">Ordering::then_with</target>
        </trans-unit>
        <trans-unit id="5266204925b37c2e8fbeb44187ac5ae55ef0ceee" translate="yes" xml:space="preserve">
          <source>Ordering::to_owned</source>
          <target state="translated">Ordering::to_owned</target>
        </trans-unit>
        <trans-unit id="1021043cb17ea480cf742910888e38334eccb5e0" translate="yes" xml:space="preserve">
          <source>Ordering::try_from</source>
          <target state="translated">Ordering::try_from</target>
        </trans-unit>
        <trans-unit id="d7fda93cca2b35645e782a8cad0106bd8488e1ff" translate="yes" xml:space="preserve">
          <source>Ordering::try_into</source>
          <target state="translated">Ordering::try_into</target>
        </trans-unit>
        <trans-unit id="fcfc78161ff2a24d952d0059fa4182641cc917f9" translate="yes" xml:space="preserve">
          <source>Ordering::type_id</source>
          <target state="translated">Ordering::type_id</target>
        </trans-unit>
        <trans-unit id="519255ae1f74ffc5ddd29979295c7572f048ad81" translate="yes" xml:space="preserve">
          <source>Organization</source>
          <target state="translated">Organization</target>
        </trans-unit>
        <trans-unit id="5065a843766fd7080cee74229c5035721dfbaf44" translate="yes" xml:space="preserve">
          <source>Organize code into &lt;a href=&quot;../reference/items/modules&quot;&gt;modules&lt;/a&gt;.</source>
          <target state="translated">코드를 &lt;a href=&quot;../reference/items/modules&quot;&gt;모듈&lt;/a&gt; 로 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c037896c3d7d61ff179675edabd6484f44719e2" translate="yes" xml:space="preserve">
          <source>Organize large projects with workspaces</source>
          <target state="translated">작업 공간으로 대규모 프로젝트 구성</target>
        </trans-unit>
        <trans-unit id="c32c014eaf11ad9e4bbf5e85159bee172f2bd221" translate="yes" xml:space="preserve">
          <source>Organizing code (using what you learned about modules in &lt;a href=&quot;ch07-00-managing-growing-projects-with-packages-crates-and-modules&quot;&gt;Chapter 7&lt;/a&gt;)</source>
          <target state="translated">코드 구성 ( &lt;a href=&quot;ch07-00-managing-growing-projects-with-packages-crates-and-modules&quot;&gt;7 장&lt;/a&gt; 에서 모듈에 대해 배운 내용 사용 )</target>
        </trans-unit>
        <trans-unit id="07e325e4f2f3d878f292564a3ecf710b5ee187df" translate="yes" xml:space="preserve">
          <source>Orphan rules</source>
          <target state="translated">고아 규칙</target>
        </trans-unit>
        <trans-unit id="ee41445c200801ea9fbf6274e97db6586289a236" translate="yes" xml:space="preserve">
          <source>OsStr</source>
          <target state="translated">OsStr</target>
        </trans-unit>
        <trans-unit id="ac78b45740efbd2536654e00fa8976f2de0098a2" translate="yes" xml:space="preserve">
          <source>OsStr::as_bytes</source>
          <target state="translated">OsStr::as_bytes</target>
        </trans-unit>
        <trans-unit id="f755c63dce374d2cd8123b73b1dd4de3e66ae36b" translate="yes" xml:space="preserve">
          <source>OsStr::as_ref</source>
          <target state="translated">OsStr::as_ref</target>
        </trans-unit>
        <trans-unit id="79eaad0b134d02d5a8a3b219fea43cf82505483f" translate="yes" xml:space="preserve">
          <source>OsStr::borrow</source>
          <target state="translated">OsStr::borrow</target>
        </trans-unit>
        <trans-unit id="bfa4d2525dd3bb64cf12c0c54ba0831b012c7cfd" translate="yes" xml:space="preserve">
          <source>OsStr::borrow_mut</source>
          <target state="translated">OsStr::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2d969a374bcc571cff3bb654c0d2a624ed26d159" translate="yes" xml:space="preserve">
          <source>OsStr::clamp</source>
          <target state="translated">OsStr::clamp</target>
        </trans-unit>
        <trans-unit id="7f1396f2e8255fe6f5c9a4390d7098b8034c8699" translate="yes" xml:space="preserve">
          <source>OsStr::clone_into</source>
          <target state="translated">OsStr::clone_into</target>
        </trans-unit>
        <trans-unit id="569b89a072350ca831472f039e3799986d4f11db" translate="yes" xml:space="preserve">
          <source>OsStr::cmp</source>
          <target state="translated">OsStr::cmp</target>
        </trans-unit>
        <trans-unit id="02e4586950251d98cb8068b61addb477edffaa5f" translate="yes" xml:space="preserve">
          <source>OsStr::default</source>
          <target state="translated">OsStr::default</target>
        </trans-unit>
        <trans-unit id="1ca22c665e0765af3d1f73e68414935fa3b71420" translate="yes" xml:space="preserve">
          <source>OsStr::encode_wide</source>
          <target state="translated">OsStr::encode_wide</target>
        </trans-unit>
        <trans-unit id="fa5103a2532ae1fa374ed2927f602df85a454480" translate="yes" xml:space="preserve">
          <source>OsStr::eq</source>
          <target state="translated">OsStr::eq</target>
        </trans-unit>
        <trans-unit id="ef3f35d77c080423fa7da5fdd1ccb7cf95b71966" translate="yes" xml:space="preserve">
          <source>OsStr::fmt</source>
          <target state="translated">OsStr::fmt</target>
        </trans-unit>
        <trans-unit id="e3396244efc29b3316f86bd28df2f41d538010a9" translate="yes" xml:space="preserve">
          <source>OsStr::from</source>
          <target state="translated">OsStr::from</target>
        </trans-unit>
        <trans-unit id="9964c092761696f03f0660510726f34c37a101ba" translate="yes" xml:space="preserve">
          <source>OsStr::from_bytes</source>
          <target state="translated">OsStr::from_bytes</target>
        </trans-unit>
        <trans-unit id="20db41b61263f9037ce0775edf41bb748db52953" translate="yes" xml:space="preserve">
          <source>OsStr::ge</source>
          <target state="translated">OsStr::ge</target>
        </trans-unit>
        <trans-unit id="78612c827c884f24395b52a0e978a02ae1553397" translate="yes" xml:space="preserve">
          <source>OsStr::gt</source>
          <target state="translated">OsStr::gt</target>
        </trans-unit>
        <trans-unit id="320510460598d45269ce9bb2345c35feadc65354" translate="yes" xml:space="preserve">
          <source>OsStr::hash</source>
          <target state="translated">OsStr::hash</target>
        </trans-unit>
        <trans-unit id="2d1ef587fbe4200c7d4f9c12c46688036aba59bf" translate="yes" xml:space="preserve">
          <source>OsStr::hash_slice</source>
          <target state="translated">OsStr::hash_slice</target>
        </trans-unit>
        <trans-unit id="0020d09dec473595eec574f96d727910a223a8c2" translate="yes" xml:space="preserve">
          <source>OsStr::into_os_string</source>
          <target state="translated">OsStr::into_os_string</target>
        </trans-unit>
        <trans-unit id="03e0477c96addfca9b6c52bb8c2a51379c80e50b" translate="yes" xml:space="preserve">
          <source>OsStr::is_empty</source>
          <target state="translated">OsStr::is_empty</target>
        </trans-unit>
        <trans-unit id="9b6be64e74b26edd733b5abecea0d6e130bb8530" translate="yes" xml:space="preserve">
          <source>OsStr::le</source>
          <target state="translated">OsStr::le</target>
        </trans-unit>
        <trans-unit id="42ab8f4050f992b35836d4c6c791ac02ceb47de0" translate="yes" xml:space="preserve">
          <source>OsStr::len</source>
          <target state="translated">OsStr::len</target>
        </trans-unit>
        <trans-unit id="26a782a3c88c68f441ebbb7e07135b266f502a7e" translate="yes" xml:space="preserve">
          <source>OsStr::lt</source>
          <target state="translated">OsStr::lt</target>
        </trans-unit>
        <trans-unit id="96c41ae9f3f5a0afa117d7b0c1f0d8f14b6ad682" translate="yes" xml:space="preserve">
          <source>OsStr::max</source>
          <target state="translated">OsStr::max</target>
        </trans-unit>
        <trans-unit id="b6ada99738929e011cce58a8a1894064aa33f1c5" translate="yes" xml:space="preserve">
          <source>OsStr::min</source>
          <target state="translated">OsStr::min</target>
        </trans-unit>
        <trans-unit id="9779de4259895832c6000749300b1e884eaf3771" translate="yes" xml:space="preserve">
          <source>OsStr::ne</source>
          <target state="translated">OsStr::ne</target>
        </trans-unit>
        <trans-unit id="f62b92e58f40cddea76007419338471014c88556" translate="yes" xml:space="preserve">
          <source>OsStr::new</source>
          <target state="translated">OsStr::new</target>
        </trans-unit>
        <trans-unit id="69d32b580a0a7fc56f54834922e1ebc2ed90dd8f" translate="yes" xml:space="preserve">
          <source>OsStr::partial_cmp</source>
          <target state="translated">OsStr::partial_cmp</target>
        </trans-unit>
        <trans-unit id="71de02492654f161c7d616d82efe20f7246fff90" translate="yes" xml:space="preserve">
          <source>OsStr::to_os_string</source>
          <target state="translated">OsStr::to_os_string</target>
        </trans-unit>
        <trans-unit id="922c1b6b75bc73f9ec7e1ce34c75dd120595e71e" translate="yes" xml:space="preserve">
          <source>OsStr::to_owned</source>
          <target state="translated">OsStr::to_owned</target>
        </trans-unit>
        <trans-unit id="e32adb9e0e7fdfd7c025541e85d143ec5c74f1d0" translate="yes" xml:space="preserve">
          <source>OsStr::to_str</source>
          <target state="translated">OsStr::to_str</target>
        </trans-unit>
        <trans-unit id="bb2e4753fe627ce0f1bf0c683a900db127e08ec2" translate="yes" xml:space="preserve">
          <source>OsStr::to_string_lossy</source>
          <target state="translated">OsStr::to_string_lossy</target>
        </trans-unit>
        <trans-unit id="dbcbed83a2bb794dc501b27ebb739dedef369b66" translate="yes" xml:space="preserve">
          <source>OsStr::type_id</source>
          <target state="translated">OsStr::type_id</target>
        </trans-unit>
        <trans-unit id="1088f5a844b295ed089a98113972dbab8d734ea9" translate="yes" xml:space="preserve">
          <source>OsStrExt</source>
          <target state="translated">OsStrExt</target>
        </trans-unit>
        <trans-unit id="c3e4ec69b476c21a31135f26f6e1eb099354582b" translate="yes" xml:space="preserve">
          <source>OsString</source>
          <target state="translated">OsString</target>
        </trans-unit>
        <trans-unit id="859fe191dd2729e9636e923ce4c6010c065350e7" translate="yes" xml:space="preserve">
          <source>OsString::as_os_str</source>
          <target state="translated">OsString::as_os_str</target>
        </trans-unit>
        <trans-unit id="ae48ed668160d2660222446dc33130e3b99195f4" translate="yes" xml:space="preserve">
          <source>OsString::as_ref</source>
          <target state="translated">OsString::as_ref</target>
        </trans-unit>
        <trans-unit id="6c154a705bbfda0f8caa78dc3c83c688ceee4be3" translate="yes" xml:space="preserve">
          <source>OsString::borrow</source>
          <target state="translated">OsString::borrow</target>
        </trans-unit>
        <trans-unit id="d9285a7312a04823cbec150024a67d6051a0009c" translate="yes" xml:space="preserve">
          <source>OsString::borrow_mut</source>
          <target state="translated">OsString::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8a8add6d5f7047dabf38c9708dbfcb9af76b753d" translate="yes" xml:space="preserve">
          <source>OsString::capacity</source>
          <target state="translated">OsString::capacity</target>
        </trans-unit>
        <trans-unit id="50f898a7828fada3d305d75a881fa7124881e2fb" translate="yes" xml:space="preserve">
          <source>OsString::clamp</source>
          <target state="translated">OsString::clamp</target>
        </trans-unit>
        <trans-unit id="fabd01818745e590afdeb16840705b296b4f807c" translate="yes" xml:space="preserve">
          <source>OsString::clear</source>
          <target state="translated">OsString::clear</target>
        </trans-unit>
        <trans-unit id="36e853d6cde946db2cccb29c4b429f832343aee2" translate="yes" xml:space="preserve">
          <source>OsString::clone</source>
          <target state="translated">OsString::clone</target>
        </trans-unit>
        <trans-unit id="6677d860d733e3ddcebb3f1bd2f72aa39598eb34" translate="yes" xml:space="preserve">
          <source>OsString::clone_from</source>
          <target state="translated">OsString::clone_from</target>
        </trans-unit>
        <trans-unit id="fd2ac952ffefdec51ff75b3d8c4bd391741ff1aa" translate="yes" xml:space="preserve">
          <source>OsString::clone_into</source>
          <target state="translated">OsString::clone_into</target>
        </trans-unit>
        <trans-unit id="315aba73fb5b2c6e23b4c97ac9884d2d33416e0c" translate="yes" xml:space="preserve">
          <source>OsString::cmp</source>
          <target state="translated">OsString::cmp</target>
        </trans-unit>
        <trans-unit id="997c73836512dc762004a3abdc5f64badf532f66" translate="yes" xml:space="preserve">
          <source>OsString::default</source>
          <target state="translated">OsString::default</target>
        </trans-unit>
        <trans-unit id="4e609361ff7ebe3dda2c2af92f6bf48fc86e09ed" translate="yes" xml:space="preserve">
          <source>OsString::deref</source>
          <target state="translated">OsString::deref</target>
        </trans-unit>
        <trans-unit id="a49ed3e5e5b9f62e906780fb5c5b78ac4a2a0b5c" translate="yes" xml:space="preserve">
          <source>OsString::eq</source>
          <target state="translated">OsString::eq</target>
        </trans-unit>
        <trans-unit id="5ff83c8f690658cf0d00115fedc8222c0236bcb8" translate="yes" xml:space="preserve">
          <source>OsString::fmt</source>
          <target state="translated">OsString::fmt</target>
        </trans-unit>
        <trans-unit id="d829d856e0a7a3deaac1d6966fc1b56a61c44355" translate="yes" xml:space="preserve">
          <source>OsString::from</source>
          <target state="translated">OsString::from</target>
        </trans-unit>
        <trans-unit id="8b016e304ada7a6de67311a8e7bd75a8a30eaf55" translate="yes" xml:space="preserve">
          <source>OsString::from_vec</source>
          <target state="translated">OsString::from_vec</target>
        </trans-unit>
        <trans-unit id="a2eb5354a38de73c95f950cccc782fb4d3776aee" translate="yes" xml:space="preserve">
          <source>OsString::from_wide</source>
          <target state="translated">OsString::from_wide</target>
        </trans-unit>
        <trans-unit id="977e48357172af9c7749af46184abf10a9947e2a" translate="yes" xml:space="preserve">
          <source>OsString::ge</source>
          <target state="translated">OsString::ge</target>
        </trans-unit>
        <trans-unit id="314983aa089e7916ba19eefbde10540d490c42ec" translate="yes" xml:space="preserve">
          <source>OsString::gt</source>
          <target state="translated">OsString::gt</target>
        </trans-unit>
        <trans-unit id="d83cedf1ea2574802fd81387a247eaac5739dc8f" translate="yes" xml:space="preserve">
          <source>OsString::hash</source>
          <target state="translated">OsString::hash</target>
        </trans-unit>
        <trans-unit id="6471585df89443f18cf65690eeb246e384a5afc1" translate="yes" xml:space="preserve">
          <source>OsString::hash_slice</source>
          <target state="translated">OsString::hash_slice</target>
        </trans-unit>
        <trans-unit id="a3083a37ba1b773dac91a510ae8576268b2f1358" translate="yes" xml:space="preserve">
          <source>OsString::index</source>
          <target state="translated">OsString::index</target>
        </trans-unit>
        <trans-unit id="df165c7ea6f9026088706c74d86435360f8329c2" translate="yes" xml:space="preserve">
          <source>OsString::into</source>
          <target state="translated">OsString::into</target>
        </trans-unit>
        <trans-unit id="7b6bb618d98ad820b98be022b6f7ab21e27f48a9" translate="yes" xml:space="preserve">
          <source>OsString::into_boxed_os_str</source>
          <target state="translated">OsString::into_boxed_os_str</target>
        </trans-unit>
        <trans-unit id="5fb180fdd023e0d002b850baebc43995b6922d6f" translate="yes" xml:space="preserve">
          <source>OsString::into_string</source>
          <target state="translated">OsString::into_string</target>
        </trans-unit>
        <trans-unit id="703c49b20d1d36582961bf46cf1aaf46d794f379" translate="yes" xml:space="preserve">
          <source>OsString::into_vec</source>
          <target state="translated">OsString::into_vec</target>
        </trans-unit>
        <trans-unit id="7a9071ad2ca6707ddd075812eb2d9bbf1fbd1754" translate="yes" xml:space="preserve">
          <source>OsString::is_empty</source>
          <target state="translated">OsString::is_empty</target>
        </trans-unit>
        <trans-unit id="a389a86add52b0902ca1ba2740d69696a8dddda5" translate="yes" xml:space="preserve">
          <source>OsString::le</source>
          <target state="translated">OsString::le</target>
        </trans-unit>
        <trans-unit id="3cb68f0936840ee30472030decd42b714beb3d76" translate="yes" xml:space="preserve">
          <source>OsString::len</source>
          <target state="translated">OsString::len</target>
        </trans-unit>
        <trans-unit id="56ef3320c0111ea02994b262a3cb861dbbb34f17" translate="yes" xml:space="preserve">
          <source>OsString::lt</source>
          <target state="translated">OsString::lt</target>
        </trans-unit>
        <trans-unit id="575270b5621cafd0101a5eb1bb050bc3b7e64b45" translate="yes" xml:space="preserve">
          <source>OsString::max</source>
          <target state="translated">OsString::max</target>
        </trans-unit>
        <trans-unit id="68564a48326d166c885a4ae2b7d3f0bad4e64da0" translate="yes" xml:space="preserve">
          <source>OsString::min</source>
          <target state="translated">OsString::min</target>
        </trans-unit>
        <trans-unit id="16abd935f98a70793180d4823ab08017279d0508" translate="yes" xml:space="preserve">
          <source>OsString::ne</source>
          <target state="translated">OsString::ne</target>
        </trans-unit>
        <trans-unit id="e6e8d533b010a6662c3913ad01078c70169e049a" translate="yes" xml:space="preserve">
          <source>OsString::new</source>
          <target state="translated">OsString::new</target>
        </trans-unit>
        <trans-unit id="9f53066685538b1d11ce53a4356dbcab1eb4a849" translate="yes" xml:space="preserve">
          <source>OsString::partial_cmp</source>
          <target state="translated">OsString::partial_cmp</target>
        </trans-unit>
        <trans-unit id="98f9021005b406d62879209d12b7a0b671d50c32" translate="yes" xml:space="preserve">
          <source>OsString::push</source>
          <target state="translated">OsString::push</target>
        </trans-unit>
        <trans-unit id="3d381aaee3f35c33f3658ad6121f892e6c693335" translate="yes" xml:space="preserve">
          <source>OsString::reserve</source>
          <target state="translated">OsString::reserve</target>
        </trans-unit>
        <trans-unit id="cc3d6518430a6da401547d4c22ea3d8cf229d297" translate="yes" xml:space="preserve">
          <source>OsString::reserve_exact</source>
          <target state="translated">OsString::reserve_exact</target>
        </trans-unit>
        <trans-unit id="7dcd71178aa021af3ef23a7f736f91a63dc04a08" translate="yes" xml:space="preserve">
          <source>OsString::shrink_to</source>
          <target state="translated">OsString::shrink_to</target>
        </trans-unit>
        <trans-unit id="a78619a63262a6398074a44d67d1e1c0055a9e42" translate="yes" xml:space="preserve">
          <source>OsString::shrink_to_fit</source>
          <target state="translated">OsString::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="e677a0fce97086e2dbd5116d8c73422a5b17335f" translate="yes" xml:space="preserve">
          <source>OsString::to_os_string</source>
          <target state="translated">OsString::to_os_string</target>
        </trans-unit>
        <trans-unit id="1e5d3ed2984e0c0a94e3614d04a4b6d1e5283af6" translate="yes" xml:space="preserve">
          <source>OsString::to_owned</source>
          <target state="translated">OsString::to_owned</target>
        </trans-unit>
        <trans-unit id="2010c47df96f790856e2a60e7f3995e78eada375" translate="yes" xml:space="preserve">
          <source>OsString::to_str</source>
          <target state="translated">OsString::to_str</target>
        </trans-unit>
        <trans-unit id="c5ab5192e0b8fd775bd3e8f9b3e0573d969f29b3" translate="yes" xml:space="preserve">
          <source>OsString::to_string_lossy</source>
          <target state="translated">OsString::to_string_lossy</target>
        </trans-unit>
        <trans-unit id="effa33ff4c0c0309f8ac54bad875e745daa055b5" translate="yes" xml:space="preserve">
          <source>OsString::try_from</source>
          <target state="translated">OsString::try_from</target>
        </trans-unit>
        <trans-unit id="fb369eb73b7652c7f64f7858a0ab00fb0d746ca4" translate="yes" xml:space="preserve">
          <source>OsString::try_into</source>
          <target state="translated">OsString::try_into</target>
        </trans-unit>
        <trans-unit id="2df035af1f5a524f1b084c9f6fb3b92ba6dc0ed1" translate="yes" xml:space="preserve">
          <source>OsString::type_id</source>
          <target state="translated">OsString::type_id</target>
        </trans-unit>
        <trans-unit id="5174f93493c600b6d13e517fcdf7e8efbdb14dca" translate="yes" xml:space="preserve">
          <source>OsString::with_capacity</source>
          <target state="translated">OsString::with_capacity</target>
        </trans-unit>
        <trans-unit id="746c2997c2de636223c1bd2e6ffbcac4d777ef7f" translate="yes" xml:space="preserve">
          <source>OsStringExt</source>
          <target state="translated">OsStringExt</target>
        </trans-unit>
        <trans-unit id="5bc9a5878701d6eea8963b31b0c3a5a1dc4ff057" translate="yes" xml:space="preserve">
          <source>Other Rust features, such as pattern matching and enums, which we&amp;rsquo;ve covered in other chapters, are influenced by the functional style as well. Mastering closures and iterators is an important part of writing idiomatic, fast Rust code, so we&amp;rsquo;ll devote this entire chapter to them.</source>
          <target state="translated">다른 장에서 다룬 패턴 일치 및 열거와 같은 다른 녹 기능도 기능적 스타일의 영향을받습니다. 클로저와 이터레이터를 마스터하는 것은 관용적이고 빠른 Rust 코드 작성의 중요한 부분이므로이 장 전체를 그들에게 바칠 것입니다.</target>
        </trans-unit>
        <trans-unit id="78f4a1803901c79b472a31aac60c766c79e0cd1d" translate="yes" xml:space="preserve">
          <source>Other Slices</source>
          <target state="translated">다른 조각들</target>
        </trans-unit>
        <trans-unit id="7ebd492d99acb79e16a874d198f25fa4ea4ca260" translate="yes" xml:space="preserve">
          <source>Other duplication includes the similar implementations of the &lt;code&gt;request_review&lt;/code&gt; and &lt;code&gt;approve&lt;/code&gt; methods on &lt;code&gt;Post&lt;/code&gt;. Both methods delegate to the implementation of the same method on the value in the &lt;code&gt;state&lt;/code&gt; field of &lt;code&gt;Option&lt;/code&gt; and set the new value of the &lt;code&gt;state&lt;/code&gt; field to the result. If we had a lot of methods on &lt;code&gt;Post&lt;/code&gt; that followed this pattern, we might consider defining a macro to eliminate the repetition (see the &lt;a href=&quot;ch19-06-macros#macros&quot;&gt;&amp;ldquo;Macros&amp;rdquo;&lt;/a&gt; section in Chapter 19).</source>
          <target state="translated">다른 중복에는 &lt;code&gt;Post&lt;/code&gt; 에 대한 &lt;code&gt;request_review&lt;/code&gt; 및 &lt;code&gt;approve&lt;/code&gt; 메소드 의 유사한 구현이 포함됩니다 . 두 방법 모두의 값에 동일하게 구현 위임 &lt;code&gt;state&lt;/code&gt; 필드 &lt;code&gt;Option&lt;/code&gt; 및 새로운 값을 설정 한 &lt;code&gt;state&lt;/code&gt; 결과에 필드. &lt;code&gt;Post&lt;/code&gt; 에서이 패턴을 따르는 방법 이 많으면 반복을 제거하기 위해 매크로를 정의하는 것을 고려할 수 있습니다 ( 19 장의 &lt;a href=&quot;ch19-06-macros#macros&quot;&gt;&quot;매크로&quot;&lt;/a&gt; 섹션 참조 ).</target>
        </trans-unit>
        <trans-unit id="752d28b2015c4a5a9b75eaf4a1216f39bbdf32b1" translate="yes" xml:space="preserve">
          <source>Other languages, like C, will attempt to give you exactly what you asked for in this situation, even though it isn&amp;rsquo;t what you want: you&amp;rsquo;ll get whatever is at the location in memory that would correspond to that element in the vector, even though the memory doesn&amp;rsquo;t belong to the vector. This is called a &lt;em&gt;buffer overread&lt;/em&gt; and can lead to security vulnerabilities if an attacker is able to manipulate the index in such a way as to read data they shouldn&amp;rsquo;t be allowed to that is stored after the array.</source>
          <target state="translated">C와 같은 다른 언어는 원하는 상황이 아니더라도이 상황에서 요청한 내용을 정확하게 제공하려고 시도합니다. 벡터의 해당 요소에 해당하는 메모리 위치는 무엇이든 얻을 수 있습니다. 메모리가 벡터에 속하지 않아도. 이를 &lt;em&gt;버퍼 덮어 쓰기&lt;/em&gt; 라고하며 , 공격자가 배열 뒤에 저장된 데이터에 허용되지 않아야하는 데이터를 읽는 방식으로 인덱스를 조작 할 수있는 경우 보안 취약점이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="648ace77ed0f39aac89b4770e105e365ba693a3e" translate="yes" xml:space="preserve">
          <source>Other methods defined on the &lt;code&gt;Iterator&lt;/code&gt; trait, known as &lt;em&gt;iterator adaptors&lt;/em&gt;, allow you to change iterators into different kinds of iterators. You can chain multiple calls to iterator adaptors to perform complex actions in a readable way. But because all iterators are lazy, you have to call one of the consuming adaptor methods to get results from calls to iterator adaptors.</source>
          <target state="translated">&lt;em&gt;반복자 어댑터&lt;/em&gt; 로 알려진 &lt;code&gt;Iterator&lt;/code&gt; 특성 에 정의 된 다른 메소드를 사용하면 반복자를 다른 종류의 반복자로 변경할 수 있습니다. 여러 호출을 반복기 어댑터에 연결하여 복잡한 조치를 읽기 쉬운 방식으로 수행 할 수 있습니다. 그러나 모든 반복자가 게으 르기 때문에 소비하는 어댑터 메소드 중 하나를 호출하여 반복자 어댑터에 대한 호출 결과를 가져와야합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2249508fdf94c149e36ab432d8b683b49f9e6995" translate="yes" xml:space="preserve">
          <source>Other places &lt;code&gt;as&lt;/code&gt; is used include as extra syntax for &lt;a href=&quot;keyword.crate&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;use&lt;/code&gt;, to change the name something is imported as.</source>
          <target state="translated">다른 장소 &lt;code&gt;as&lt;/code&gt; 사용됩니다에 대한 추가 구문으로 포함 &lt;a href=&quot;keyword.crate&quot;&gt; &lt;code&gt;crate&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;use&lt;/code&gt; 으로 가져온 이름 무언가를 변경하려면.</target>
        </trans-unit>
        <trans-unit id="ca7f9932674bb9c25f134a0105ec09c2c00e169d" translate="yes" xml:space="preserve">
          <source>Other places the &lt;code&gt;let&lt;/code&gt; keyword is used include along with &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt;, in the form of &lt;code&gt;if let&lt;/code&gt; expressions. They're useful if the pattern being matched isn't exhaustive, such as with enumerations. &lt;code&gt;while let&lt;/code&gt; also exists, which runs a loop with a pattern matched value until that pattern can't be matched.</source>
          <target state="translated">기타 장소 &lt;code&gt;let&lt;/code&gt; 키워드가 사용됩니다와 함께 포함 &lt;a href=&quot;keyword.if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 의 형태로 &lt;code&gt;if let&lt;/code&gt; 표현. 열거와 같이 일치하는 패턴이 완전하지 않은 경우에 유용합니다. &lt;code&gt;while let&lt;/code&gt; 도 존재합니다. 패턴이 일치하지 않을 때까지 패턴 일치 값으로 루프를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="995a627762e880a789090e71c29696dd2233250e" translate="yes" xml:space="preserve">
          <source>Other preludes</source>
          <target state="translated">다른 전주</target>
        </trans-unit>
        <trans-unit id="446bad3bff9defd3006cda2835a7a1319d8a35e5" translate="yes" xml:space="preserve">
          <source>Other programming languages don&amp;rsquo;t require you to connect arguments to return values in the signature. Although this might seem strange, it will get easier over time. You might want to compare this example with the &lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&amp;ldquo;Validating References with Lifetimes&amp;rdquo;&lt;/a&gt; section in Chapter 10.</source>
          <target state="translated">다른 프로그래밍 언어에서는 서명에 값을 반환하기 위해 인수를 연결하지 않아도됩니다. 이것이 이상하게 보일지 모르지만 시간이 지나면 더 쉬워 질 것입니다. 이 예를 10 장의 &lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&quot;평생 검증 참조&quot;&lt;/a&gt; 섹션 과 비교할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60eaf9cabcdeaacd84dda8af53312b70b5da796b" translate="yes" xml:space="preserve">
          <source>Other than that, attribute-like macros work the same way as custom derive macros: you create a crate with the &lt;code&gt;proc-macro&lt;/code&gt; crate type and implement a function that generates the code you want!</source>
          <target state="translated">그 외에도 속성과 유사한 매크로는 커스텀 파생 매크로와 같은 방식으로 작동합니다. &lt;code&gt;proc-macro&lt;/code&gt; 상자 유형으로 상자를 만들고 원하는 코드를 생성하는 함수를 구현하십시오!</target>
        </trans-unit>
        <trans-unit id="18d96cb86d3646fb81607f614e4ed101dbb61f72" translate="yes" xml:space="preserve">
          <source>Other traits</source>
          <target state="translated">다른 특성</target>
        </trans-unit>
        <trans-unit id="9112d41ffd7475a6522498133c87c82589bd20c2" translate="yes" xml:space="preserve">
          <source>Other types are return or parameter types for various methods in this module</source>
          <target state="translated">다른 유형은이 모듈의 다양한 메소드에 대한 리턴 또는 매개 변수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="9a231351b0f4e7aeebda1053a5e76d13dcb380a5" translate="yes" xml:space="preserve">
          <source>Other types don't result in any further drops.</source>
          <target state="translated">다른 유형은 더 이상 하락하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7020ce2c6597276032beef17fd5a264945d38617" translate="yes" xml:space="preserve">
          <source>Other types with interior mutability can be created by using &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; as a field. The standard library provides a variety of types that provide safe interior mutability APIs. For example, &lt;a href=&quot;../std/cell/struct.refcell&quot;&gt;&lt;code&gt;std::cell::RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; uses run-time borrow checks to ensure the usual rules around multiple references. The &lt;a href=&quot;../std/sync/atomic/index&quot;&gt;&lt;code&gt;std::sync::atomic&lt;/code&gt;&lt;/a&gt; module contains types that wrap a value that is only accessed with atomic operations, allowing the value to be shared and mutated across threads.</source>
          <target state="translated">&lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 를 필드로 사용하여 내부 변경이 가능한 다른 유형을 만들 수 있습니다 . 표준 라이브러리는 안전한 내부 변경 가능성 API를 제공하는 다양한 유형을 제공합니다. 예를 들어 &lt;a href=&quot;../std/cell/struct.refcell&quot;&gt; &lt;code&gt;std::cell::RefCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 런타임 차용 ​​확인을 사용하여 여러 참조에 대한 일반적인 규칙을 보장합니다. &lt;a href=&quot;../std/sync/atomic/index&quot;&gt; &lt;code&gt;std::sync::atomic&lt;/code&gt; &lt;/a&gt; 모듈은 값을 허용, 원자 작업에 액세스하는 값이 공유 스레드를 통해 변이되는 랩 종류가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="599ae630fe84d3beb8513b4b711cd547079431cd" translate="yes" xml:space="preserve">
          <source>Other use-cases of &lt;code&gt;assert!&lt;/code&gt; include testing and enforcing run-time invariants in safe code (whose violation cannot result in unsafety).</source>
          <target state="translated">&lt;code&gt;assert!&lt;/code&gt; 다른 유스 케이스 ! 안전한 코드로 런타임 불변량을 테스트하고 시행하는 행위 (위반할 경우 안전하지 않을 수 있음).</target>
        </trans-unit>
        <trans-unit id="137a49284667a8d8d78ea49224e1089ee25a5b67" translate="yes" xml:space="preserve">
          <source>Other uses of &lt;code&gt;const&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8937a7fc4e72088623e287ce30c97cb2dfe7283" translate="yes" xml:space="preserve">
          <source>Otherwise it is equivalent to calling &lt;a href=&quot;struct.pathbuf#method.pop&quot;&gt;&lt;code&gt;pop&lt;/code&gt;&lt;/a&gt; and then pushing &lt;code&gt;file_name&lt;/code&gt;. The new path will be a sibling of the original path. (That is, it will have the same parent.)</source>
          <target state="translated">그렇지 않으면 &lt;a href=&quot;struct.pathbuf#method.pop&quot;&gt; &lt;code&gt;pop&lt;/code&gt; &lt;/a&gt; 을 호출 한 다음 &lt;code&gt;file_name&lt;/code&gt; 을 누르는 것과 같습니다 . 새로운 경로는 원래 경로의 형제입니다. (즉, 동일한 부모가 있습니다.)</target>
        </trans-unit>
        <trans-unit id="96540f88a556928131ba8d92a01693b0a2eeaf4d" translate="yes" xml:space="preserve">
          <source>Otherwise the call to &lt;code&gt;poll&lt;/code&gt; must have returned &lt;a href=&quot;../../std/task/enum.poll#variant.Ready&quot;&gt;&lt;code&gt;Poll::Ready&lt;/code&gt;&lt;/a&gt;, in which case the value contained in the &lt;a href=&quot;../../std/task/enum.poll#variant.Ready&quot;&gt;&lt;code&gt;Poll::Ready&lt;/code&gt;&lt;/a&gt; variant is used as the result of the &lt;code&gt;await&lt;/code&gt; expression itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37fe747217886166ea371a631e142a031b6a7b7" translate="yes" xml:space="preserve">
          <source>Otherwise, M is a token-tree sequence starting with a complex NT: &lt;code&gt;M = $( tt ... ) OP &amp;alpha;&lt;/code&gt;, or &lt;code&gt;M = $( tt ... ) SEP OP &amp;alpha;&lt;/code&gt;, (where &lt;code&gt;&amp;alpha;&lt;/code&gt; is the (potentially empty) sequence of token trees for the rest of the matcher).</source>
          <target state="translated">그렇지 않으면 M은 복소 NT로 시작하는 토큰 트리 시퀀스입니다. &lt;code&gt;M = $( tt ... ) OP &amp;alpha;&lt;/code&gt; 또는 &lt;code&gt;M = $( tt ... ) SEP OP &amp;alpha;&lt;/code&gt; , 여기서 &lt;code&gt;&amp;alpha;&lt;/code&gt; 는 (잠재적으로 비어 있음) 나머지 매처의 토큰 트리 순서).</target>
        </trans-unit>
        <trans-unit id="b3979bc5186a96b9165f258e5cf3641aa97f2109" translate="yes" xml:space="preserve">
          <source>Otherwise, a temporary vector is allocated and the tail is moved twice.</source>
          <target state="translated">그렇지 않으면 임시 벡터가 할당되고 꼬리가 두 번 이동됩니다.</target>
        </trans-unit>
        <trans-unit id="924bccd077970d788135a7832dffedb5e19ed44b" translate="yes" xml:space="preserve">
          <source>Otherwise, an &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the same &lt;code&gt;Arc&lt;/code&gt; that was passed in.</source>
          <target state="translated">그렇지 않으면, 전달 된 동일한 &lt;code&gt;Arc&lt;/code&gt; 와 함께 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 이 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="46a74754ed30587d7524fb80829f9c67f0fd59f6" translate="yes" xml:space="preserve">
          <source>Otherwise, an &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the same &lt;code&gt;Rc&lt;/code&gt; that was passed in.</source>
          <target state="translated">그렇지 않으면 전달 된 동일한 &lt;code&gt;Rc&lt;/code&gt; 와 함께 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 이 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="a9eb5eed15b5d494937b924570de6ed9892756ab" translate="yes" xml:space="preserve">
          <source>Otherwise, an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the same &lt;code&gt;Arc&lt;/code&gt; that was passed in.</source>
          <target state="translated">그렇지 않으면 전달 된 동일한 &lt;code&gt;Arc&lt;/code&gt; 와 함께 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 이 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="076aed98362102b58857ec0dff921bab2bf57831" translate="yes" xml:space="preserve">
          <source>Otherwise, an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the same &lt;code&gt;Rc&lt;/code&gt; that was passed in.</source>
          <target state="translated">그렇지 않으면 전달 된 동일한 &lt;code&gt;Rc&lt;/code&gt; 와 함께 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 이 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="41af0b79355036082d1d8c65ff7faff1fc431650" translate="yes" xml:space="preserve">
          <source>Otherwise, check whether &lt;code&gt;T_t&lt;/code&gt; can be coerced to &lt;code&gt;Ti&lt;/code&gt;; if so, the &lt;code&gt;T_t&lt;/code&gt; is changed to &lt;code&gt;Ti&lt;/code&gt;. (This check is also conditioned on whether all of the source expressions considered thus far have implicit coercions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ea00676375cce55b25c24c3900ad8d91fe8b198" translate="yes" xml:space="preserve">
          <source>Otherwise, edit the code to pass the lint check, and remove the overruled attribute:</source>
          <target state="translated">그렇지 않으면 코드를 편집하여 보푸라기 검사를 통과하고 무시 된 속성을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="3e85707b79250bd8b856e5ae665d19d426f3f381" translate="yes" xml:space="preserve">
          <source>Otherwise, it tries to determine the home directory by invoking the &lt;code&gt;getpwuid_r&lt;/code&gt; function using the UID of the current user. An empty home directory field returned from the &lt;code&gt;getpwuid_r&lt;/code&gt; function is considered to be a valid value.</source>
          <target state="translated">그렇지 않으면 현재 사용자의 UID를 사용하여 &lt;code&gt;getpwuid_r&lt;/code&gt; 함수를 호출하여 홈 디렉토리를 판별하려고합니다 . &lt;code&gt;getpwuid_r&lt;/code&gt; 함수 에서 리턴 된 빈 홈 디렉토리 필드 는 유효한 값으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="5085664d3dd97fdbb0b3f9d3d918e581e0986f55" translate="yes" xml:space="preserve">
          <source>Otherwise, returns the value of the 'USERPROFILE' environment variable if it is set (including to an empty string).</source>
          <target state="translated">그렇지 않으면 'USERPROFILE'환경 변수가 설정된 경우 (빈 문자열 포함) 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9a8101e7cf6341fccad86da30ddd075e4eab3ee5" translate="yes" xml:space="preserve">
          <source>Otherwise, the portion of the file name after the final &lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">그렇지 않으면 final 다음의 파일 이름 부분입니다 &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="080897ebd41df30ce96e1487fbd29e58924856eb" translate="yes" xml:space="preserve">
          <source>Otherwise, the portion of the file name before the final &lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">그렇지 않으면 파일 이름에서 final 이전 부분 &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d86ad59ea40d5cf59b8de4ede8f6b7e49f58d63e" translate="yes" xml:space="preserve">
          <source>Otherwise, the sequence &lt;code&gt;uu ...&lt;/code&gt; must be non-empty; then LAST(M) = LAST(&lt;code&gt;uu ...&lt;/code&gt;).</source>
          <target state="translated">그렇지 않으면 시퀀스 &lt;code&gt;uu ...&lt;/code&gt; 는 비어 있지 않아야합니다. 그런 다음 LAST (M) = LAST ( &lt;code&gt;uu ...&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5270e35ef24eac532a4d91eeaaf7988bb3731097" translate="yes" xml:space="preserve">
          <source>Otherwise, they work just like regular lint attributes:</source>
          <target state="translated">그렇지 않으면 일반 보풀 속성처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2e0d61497954041bb9b7946612d5835e3fcd762c" translate="yes" xml:space="preserve">
          <source>Otherwise, you may want to jump to one of these useful sections:</source>
          <target state="translated">그렇지 않으면 다음 유용한 섹션 중 하나로 바로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7655b057b9db516628b6ec609cbbac4394a83302" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; type can&amp;rsquo;t be dereferenced because we haven&amp;rsquo;t implemented that ability on our type. To enable dereferencing with the &lt;code&gt;*&lt;/code&gt; operator, we implement the &lt;code&gt;Deref&lt;/code&gt; trait.</source>
          <target state="translated">우리 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 우리는 우리의 유형에 능력이 있음을 구현하지 않았기 때문에 유형은 역 참조 할 수 없습니다. &lt;code&gt;*&lt;/code&gt; 연산자로 역 참조를 가능하게 하기 위해 &lt;code&gt;Deref&lt;/code&gt; 특성을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a9207a8de5e841e4cc95ac4f3689ea87897da5c7" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;area&lt;/code&gt; function is now defined with one parameter, which we&amp;rsquo;ve named &lt;code&gt;rectangle&lt;/code&gt;, whose type is an immutable borrow of a struct &lt;code&gt;Rectangle&lt;/code&gt; instance. As mentioned in Chapter 4, we want to borrow the struct rather than take ownership of it. This way, &lt;code&gt;main&lt;/code&gt; retains its ownership and can continue using &lt;code&gt;rect1&lt;/code&gt;, which is the reason we use the &lt;code&gt;&amp;amp;&lt;/code&gt; in the function signature and where we call the function.</source>
          <target state="translated">우리의 &lt;code&gt;area&lt;/code&gt; 함수는 이제 하나의 매개 변수로 정의되는데, 우리는 &lt;code&gt;rectangle&lt;/code&gt; 이라는 이름 을 가지며, 그 유형은 struct &lt;code&gt;Rectangle&lt;/code&gt; 인스턴스를 변경할 수 없습니다 . 4 장에서 언급했듯이, 우리는 구조체를 소유하기보다는 빌려오고 싶습니다. 이 방법으로 &lt;code&gt;main&lt;/code&gt; 은 소유권을 유지하고 &lt;code&gt;rect1&lt;/code&gt; 을 계속 사용할 수 있습니다 . 이것이 함수 서명에서 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 사용하고 함수를 호출하는 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="e1a3bac1f2dca57cc73f9221b0cab7bd13107caf" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;area&lt;/code&gt; function is very specific: it only computes the area of rectangles. It would be helpful to tie this behavior more closely to our &lt;code&gt;Rectangle&lt;/code&gt; struct, because it won&amp;rsquo;t work with any other type. Let&amp;rsquo;s look at how we can continue to refactor this code by turning the &lt;code&gt;area&lt;/code&gt; function into an &lt;code&gt;area&lt;/code&gt;&lt;em&gt;method&lt;/em&gt; defined on our &lt;code&gt;Rectangle&lt;/code&gt; type.</source>
          <target state="translated">우리 &lt;code&gt;area&lt;/code&gt; 기능은 매우 구체적이다 : 그것은 단지 직사각형의 면적을 계산합니다. 이 동작 은 다른 유형과 작동하지 않으므로 &lt;code&gt;Rectangle&lt;/code&gt; 구조체에 더 밀접하게 연결하는 것이 좋습니다 . &lt;code&gt;area&lt;/code&gt; 함수를 다음과 같이 하여이 코드를 계속 리팩토링하는 방법을 살펴 보겠습니다 &lt;code&gt;area&lt;/code&gt; &lt;code&gt;Rectangle&lt;/code&gt; 유형 에 정의 된 영역 &lt;em&gt;메서드&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cfaad3af2e76dcb6534645f49f572bb14dcdc4f2" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;grep&lt;/code&gt; project will combine a number of concepts you&amp;rsquo;ve learned so far:</source>
          <target state="translated">우리 &lt;code&gt;grep&lt;/code&gt; 프로젝트는 지금까지 배운 많은 개념들을 결합 할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="f52a72cb6754c1fcd4ce1c66bc4693a888ef0a14" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;minigrep&lt;/code&gt; project is looking good so far! Now we&amp;rsquo;ll split the &lt;em&gt;src/main.rs&lt;/em&gt; file and put some code into the &lt;em&gt;src/lib.rs&lt;/em&gt; file so we can test it and have a &lt;em&gt;src/main.rs&lt;/em&gt; file with fewer responsibilities.</source>
          <target state="translated">우리의 &lt;code&gt;minigrep&lt;/code&gt; 프로젝트는 지금까지 좋아 보입니다 ! 이제 &lt;em&gt;src / main.rs&lt;/em&gt; 파일을 분할하고 일부 코드를 &lt;em&gt;src / lib.rs&lt;/em&gt; 파일에 &lt;em&gt;넣어서&lt;/em&gt; 테스트하고 책임을 &lt;em&gt;덜어 src / main.rs&lt;/em&gt; 파일을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b5e063d7a3c760c57b190162bbd9b74d1a3d4d2" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;new&lt;/code&gt; function now returns a &lt;code&gt;Result&lt;/code&gt; with a &lt;code&gt;Config&lt;/code&gt; instance in the success case and a &lt;code&gt;&amp;amp;'static str&lt;/code&gt; in the error case. Recall from &lt;a href=&quot;ch10-03-lifetime-syntax#the-static-lifetime&quot;&gt;&amp;ldquo;The Static Lifetime&amp;rdquo;&lt;/a&gt; section in Chapter 10 that &lt;code&gt;&amp;amp;'static str&lt;/code&gt; is the type of string literals, which is our error message type for now.</source>
          <target state="translated">우리의 &lt;code&gt;new&lt;/code&gt; 함수는 이제 성공 사례 에서는 &lt;code&gt;Config&lt;/code&gt; 인스턴스와 오류 사례 에서는 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 을 가진 &lt;code&gt;Result&lt;/code&gt; 를 반환합니다 . 에서 리콜 &lt;a href=&quot;ch10-03-lifetime-syntax#the-static-lifetime&quot;&gt;&quot;정적 수명&quot;&lt;/a&gt; 장 10 절 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 지금 우리의 오류 메시지 유형 인 문자열 리터럴의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="efe671180d978c835b8f59ac0f3f67492ee61022" translate="yes" xml:space="preserve">
          <source>Our concurrency mistake has caused a compile time error. The &lt;code&gt;send&lt;/code&gt; function takes ownership of its parameter, and when the value is moved, the receiver takes ownership of it. This stops us from accidentally using the value again after sending it; the ownership system checks that everything is okay.</source>
          <target state="translated">동시성 실수로 컴파일 시간 오류가 발생했습니다. 그만큼 &lt;code&gt;send&lt;/code&gt; 함수의 매개 변수의 소유권을 얻어,이 값이 이동되는 경우, 상기 수신기는 소유권 걸린다. 값을 보낸 후 실수로 값을 다시 사용하지 못하게합니다. 소유권 시스템은 모든 것이 정상인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a4444c88cfb7348be7065a71b67411c38cf815d8" translate="yes" xml:space="preserve">
          <source>Our first example is presented in a tree structure to elaborate on how the analysis of the matcher composes. (Some of the simpler subtrees have been elided.)</source>
          <target state="translated">첫 번째 예는 매처 분석이 어떻게 구성되는지 자세히 설명하기 위해 트리 구조로 제공됩니다. (더 간단한 하위 트리 중 일부가 제거되었습니다.)</target>
        </trans-unit>
        <trans-unit id="03dc9c7158dfa2429d4c3d6b283a663461fb78f3" translate="yes" xml:space="preserve">
          <source>Our library will only provide the functionality of tracking how close to the maximum a value is and what the messages should be at what times. Applications that use our library will be expected to provide the mechanism for sending the messages: the application could put a message in the application, send an email, send a text message, or something else. The library doesn&amp;rsquo;t need to know that detail. All it needs is something that implements a trait we&amp;rsquo;ll provide called &lt;code&gt;Messenger&lt;/code&gt;. Listing 15-20 shows the library code:</source>
          <target state="translated">Google 라이브러리는 최대 값에 얼마나 근접하고 메시지가 몇시에 있어야하는지 추적하는 기능 만 제공합니다. 라이브러리를 사용하는 응용 프로그램은 메시지를 전송하는 메커니즘을 제공해야합니다. 응용 프로그램은 응용 프로그램에 메시지를 넣거나 전자 메일을 보내거나 문자 메시지를 보내거나 그 밖의 것을 보낼 수 있습니다. 라이브러리는 그 세부 사항을 알 필요가 없습니다. 필요한 것은 &lt;code&gt;Messenger&lt;/code&gt; 라는 우리가 제공 할 특성을 구현하는 것입니다 . 코드 15-20은 라이브러리 코드를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5e4872fe1ff4af8ea372abc0eed84c5f2cc971ce" translate="yes" xml:space="preserve">
          <source>Our library&amp;rsquo;s user can now write their &lt;code&gt;main&lt;/code&gt; function to create a &lt;code&gt;Screen&lt;/code&gt; instance. To the &lt;code&gt;Screen&lt;/code&gt; instance, they can add a &lt;code&gt;SelectBox&lt;/code&gt; and a &lt;code&gt;Button&lt;/code&gt; by putting each in a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to become a trait object. They can then call the &lt;code&gt;run&lt;/code&gt; method on the &lt;code&gt;Screen&lt;/code&gt; instance, which will call &lt;code&gt;draw&lt;/code&gt; on each of the components. Listing 17-9 shows this implementation:</source>
          <target state="translated">라이브러리 사용자는 이제 &lt;code&gt;main&lt;/code&gt; 기능을 작성하여 &lt;code&gt;Screen&lt;/code&gt; 인스턴스 를 만들 수 있습니다 . 받는 &lt;code&gt;Screen&lt;/code&gt; 예, 그들은 추가 할 수있는 &lt;code&gt;SelectBox&lt;/code&gt; 와 &lt;code&gt;Button&lt;/code&gt; A의 각을 넣어 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 형질 객체가 될 수 있습니다. 그런 다음 &lt;code&gt;Screen&lt;/code&gt; 인스턴스 에서 &lt;code&gt;run&lt;/code&gt; 메서드 를 호출하면 &lt;code&gt;draw&lt;/code&gt; 가 호출됩니다. 각 구성 요소에 대해 . Listing 17-9는이 구현을 보여준다 :</target>
        </trans-unit>
        <trans-unit id="8f97ecd7d9bde89d0ef157149e44feaabe641749" translate="yes" xml:space="preserve">
          <source>Our solution to this problem is what we call &amp;ldquo;stability without stagnation&amp;rdquo;, and our guiding principle is this: you should never have to fear upgrading to a new version of stable Rust. Each upgrade should be painless, but should also bring you new features, fewer bugs, and faster compile times.</source>
          <target state="translated">이 문제에 대한 우리의 해결책은 우리가&amp;ldquo;정체없는 안정성&amp;rdquo;이라고 부르는 것이며, 우리의 기본 원칙은 다음과 같습니다. 안정된 녹의 새 버전으로 업그레이드하는 것을 두려워 할 필요가 없습니다. 각 업그레이드는 번거롭지 않지만 새로운 기능, 버그 수 감소 및 컴파일 시간 단축을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="97f7b86920d282f1c8d565f0454438b9d0c724e1" translate="yes" xml:space="preserve">
          <source>Our test caught the bug! The &lt;code&gt;it_adds_two&lt;/code&gt; test failed, displaying the message &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; and showing that &lt;code&gt;left&lt;/code&gt; was &lt;code&gt;4&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; was &lt;code&gt;5&lt;/code&gt;. This message is useful and helps us start debugging: it means the &lt;code&gt;left&lt;/code&gt; argument to &lt;code&gt;assert_eq!&lt;/code&gt; was &lt;code&gt;4&lt;/code&gt; but the &lt;code&gt;right&lt;/code&gt; argument, where we had &lt;code&gt;add_two(2)&lt;/code&gt;, was &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">우리 테스트에서 버그가 발견되었습니다! &lt;code&gt;it_adds_two&lt;/code&gt; 테스트 메시지 표시 실패 &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; 하고 도시 &lt;code&gt;left&lt;/code&gt; 였다 &lt;code&gt;4&lt;/code&gt; 및 &lt;code&gt;right&lt;/code&gt; 하였다 &lt;code&gt;5&lt;/code&gt; . 이 메시지는 유용하며 디버깅을 시작하는 데 도움이 됩니다. &lt;code&gt;assert_eq!&lt;/code&gt; 의 &lt;code&gt;left&lt;/code&gt; 인수를 의미합니다 ! 했다 &lt;code&gt;4&lt;/code&gt; 하지만 &lt;code&gt;right&lt;/code&gt; 우리가 가진 인수, &lt;code&gt;add_two(2)&lt;/code&gt; 이었다 &lt;code&gt;5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="069f6f48b22dbba6f3aadbd66c65751d3e689873" translate="yes" xml:space="preserve">
          <source>Our test passed, so we know it works!</source>
          <target state="translated">테스트가 통과되었으므로 작동한다는 것을 알게되었습니다!</target>
        </trans-unit>
        <trans-unit id="c3fb5986f91b2dcdf4f3ae02d18ace519c5ef26d" translate="yes" xml:space="preserve">
          <source>Our tests caught the bug! Because &lt;code&gt;larger.width&lt;/code&gt; is 8 and &lt;code&gt;smaller.width&lt;/code&gt; is 5, the comparison of the widths in &lt;code&gt;can_hold&lt;/code&gt; now returns &lt;code&gt;false&lt;/code&gt;: 8 is not less than 5.</source>
          <target state="translated">테스트 결과 버그가 발견되었습니다! 때문에 &lt;code&gt;larger.width&lt;/code&gt; 이 8이고 &lt;code&gt;smaller.width&lt;/code&gt; 은 5에서 폭의 비교 &lt;code&gt;can_hold&lt;/code&gt; 은 지금 반환 &lt;code&gt;false&lt;/code&gt; : 8 이하 5 이상이다.</target>
        </trans-unit>
        <trans-unit id="932377194a3525a80fe9e2644ba7f5912ea2df25" translate="yes" xml:space="preserve">
          <source>Our two crates are tightly related, so we create the procedural macro crate within the directory of our &lt;code&gt;hello_macro&lt;/code&gt; crate. If we change the trait definition in &lt;code&gt;hello_macro&lt;/code&gt;, we&amp;rsquo;ll have to change the implementation of the procedural macro in &lt;code&gt;hello_macro_derive&lt;/code&gt; as well. The two crates will need to be published separately, and programmers using these crates will need to add both as dependencies and bring them both into scope. We could instead have the &lt;code&gt;hello_macro&lt;/code&gt; crate use &lt;code&gt;hello_macro_derive&lt;/code&gt; as a dependency and re-export the procedural macro code. However, the way we&amp;rsquo;ve structured the project makes it possible for programmers to use &lt;code&gt;hello_macro&lt;/code&gt; even if they don&amp;rsquo;t want the &lt;code&gt;derive&lt;/code&gt; functionality.</source>
          <target state="translated">우리의 두 상자는 밀접하게 관련되어 있으므로 &lt;code&gt;hello_macro&lt;/code&gt; 상자 의 디렉토리 내에 절차 적 매크로 상자를 만듭니다 . &lt;code&gt;hello_macro&lt;/code&gt; 에서 특성 정의 를 변경하면 &lt;code&gt;hello_macro_derive&lt;/code&gt; 에서도 절차 적 매크로 구현을 변경해야합니다 . 두 상자는 별도로 게시해야하며, 이러한 상자를 사용하는 프로그래머는 둘 모두를 종속성으로 추가하고 둘 다 범위로 가져와야합니다. 대신 &lt;code&gt;hello_macro&lt;/code&gt; 크레이트가 &lt;code&gt;hello_macro_derive&lt;/code&gt; 를 종속성으로 사용 하고 절차 적 매크로 코드를 다시 내보내도록 할 수 있습니다. 그러나 우리가 프로젝트를 구조화 한 방식은 프로그래머가 원하지 않는 경우에도 &lt;code&gt;hello_macro&lt;/code&gt; 를 사용할 수있게 합니다. &lt;code&gt;derive&lt;/code&gt; 기능을 파생 합니다.</target>
        </trans-unit>
        <trans-unit id="a456009a7c6e37690dc20c96fd3a00e2535e519a" translate="yes" xml:space="preserve">
          <source>Our two crates are tightly related, so we create the procedural macro crate within the directory of our &lt;code&gt;hello_macro&lt;/code&gt; crate. If we change the trait definition in &lt;code&gt;hello_macro&lt;/code&gt;, we&amp;rsquo;ll have to change the implementation of the procedural macro in &lt;code&gt;hello_macro_derive&lt;/code&gt; as well. The two crates will need to be published separately, and programmers using these crates will need to add both as dependencies and bring them both into scope. We could instead have the &lt;code&gt;hello_macro&lt;/code&gt; crate use &lt;code&gt;hello_macro_derive&lt;/code&gt; as a dependency and reexport the procedural macro code. However, the way we&amp;rsquo;ve structured the project makes it possible for programmers to use &lt;code&gt;hello_macro&lt;/code&gt; even if they don&amp;rsquo;t want the &lt;code&gt;derive&lt;/code&gt; functionality.</source>
          <target state="translated">우리의 두 상자는 밀접하게 관련되어 있으므로 &lt;code&gt;hello_macro&lt;/code&gt; 상자 의 디렉토리 내에 절차 적 매크로 상자를 만듭니다 . &lt;code&gt;hello_macro&lt;/code&gt; 에서 특성 정의 를 변경하면 &lt;code&gt;hello_macro_derive&lt;/code&gt; 에서 절차 매크로의 구현도 변경해야합니다 . 두 상자는 별도로 게시해야하며,이 상자를 사용하는 프로그래머는 두 가지 상자를 모두 종속성으로 추가하고 범위를 모두 가져와야합니다. 대신 &lt;code&gt;hello_macro&lt;/code&gt; 상자에서 &lt;code&gt;hello_macro_derive&lt;/code&gt; 를 종속성으로 사용 하고 절차 매크로 코드를 다시 내보낼 수 있습니다. 그러나 우리가 프로젝트를 &lt;code&gt;hello_macro&lt;/code&gt; 원하지 않는 경우에도 합니다. 방식으로 프로그래머는 hello_macro &lt;code&gt;derive&lt;/code&gt; 기능 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d04d54136e7055f33bb3e1bbb4cb0ac4fca594a8" translate="yes" xml:space="preserve">
          <source>Our web server needs to listen to a TCP connection, so that&amp;rsquo;s the first part we&amp;rsquo;ll work on. The standard library offers a &lt;code&gt;std::net&lt;/code&gt; module that lets us do this. Let&amp;rsquo;s make a new project in the usual fashion:</source>
          <target state="translated">우리의 웹 서버는 TCP 연결을 수신해야하므로 이것이 우리가 작업 할 첫 번째 부분입니다. 표준 라이브러리는이를 가능하게하는 &lt;code&gt;std::net&lt;/code&gt; 모듈을 제공합니다 . 일반적인 방식으로 새 프로젝트를 만들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="17e421fbadb43b474b631f0045b2106bd87824cc" translate="yes" xml:space="preserve">
          <source>Out-of-order execution</source>
          <target state="translated">고장난 실행</target>
        </trans-unit>
        <trans-unit id="730dfeeb12a571e95bc1961c0b2230a903923296" translate="yes" xml:space="preserve">
          <source>Outer attribute</source>
          <target state="translated">외부 속성</target>
        </trans-unit>
        <trans-unit id="2522054e66f17e8ce74357f93aa3d55cec3e5c37" translate="yes" xml:space="preserve">
          <source>Outer attributes are allowed on match arms. The only attributes that have meaning on match arms are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/codegen#the-cold-attribute&quot;&gt;&lt;code&gt;cold&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lint check attributes&lt;/a&gt;.</source>
          <target state="translated">경기 무기에는 외부 속성이 허용됩니다. match arm에 의미가있는 유일한 속성은 &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/codegen#the-cold-attribute&quot;&gt; &lt;code&gt;cold&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lint check 속성&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e17ac49e59e3c24f65b6eb7eb800c128e2d0327f" translate="yes" xml:space="preserve">
          <source>Outer block doc comment</source>
          <target state="translated">외부 블록 문서 주석</target>
        </trans-unit>
        <trans-unit id="49bb2a2dcd1d2f083a137acbbd937d73adfc4ddf" translate="yes" xml:space="preserve">
          <source>Outer line doc comment</source>
          <target state="translated">외부 문서 주석</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="d1823c68a7e59aee497eaf6bcce7cab74d25109b" translate="yes" xml:space="preserve">
          <source>Output::borrow</source>
          <target state="translated">Output::borrow</target>
        </trans-unit>
        <trans-unit id="bd4894b30dacbb463e4f9b290aef62366ceaea5b" translate="yes" xml:space="preserve">
          <source>Output::borrow_mut</source>
          <target state="translated">Output::borrow_mut</target>
        </trans-unit>
        <trans-unit id="91e25cbffb5245c6c4c63c7f061f2d786fdb521f" translate="yes" xml:space="preserve">
          <source>Output::clone</source>
          <target state="translated">Output::clone</target>
        </trans-unit>
        <trans-unit id="6df4f0510aea77969aaaa10e205502ea42c93963" translate="yes" xml:space="preserve">
          <source>Output::clone_from</source>
          <target state="translated">Output::clone_from</target>
        </trans-unit>
        <trans-unit id="687e30cb7117f28eda51e39e7bab28b83cc9e405" translate="yes" xml:space="preserve">
          <source>Output::clone_into</source>
          <target state="translated">Output::clone_into</target>
        </trans-unit>
        <trans-unit id="3032d1424e084a9f76413e7e6788cdfd8a67b58a" translate="yes" xml:space="preserve">
          <source>Output::eq</source>
          <target state="translated">Output::eq</target>
        </trans-unit>
        <trans-unit id="865dec7fa701b8a9ca5f805a39100052bfe318b6" translate="yes" xml:space="preserve">
          <source>Output::fmt</source>
          <target state="translated">Output::fmt</target>
        </trans-unit>
        <trans-unit id="993990d97649b770ccd9d98ea8487d704986b6d9" translate="yes" xml:space="preserve">
          <source>Output::from</source>
          <target state="translated">Output::from</target>
        </trans-unit>
        <trans-unit id="5b9601c898cded464f2e06dadaf7ab7c9741cd5c" translate="yes" xml:space="preserve">
          <source>Output::into</source>
          <target state="translated">Output::into</target>
        </trans-unit>
        <trans-unit id="1c87bedb995cad24d365f47966cbd4346b591666" translate="yes" xml:space="preserve">
          <source>Output::ne</source>
          <target state="translated">Output::ne</target>
        </trans-unit>
        <trans-unit id="62c76b51d4718e2ffcbe3b7aa04ddda3b2b70e94" translate="yes" xml:space="preserve">
          <source>Output::to_owned</source>
          <target state="translated">Output::to_owned</target>
        </trans-unit>
        <trans-unit id="9a87d3e2cc9f1d250bfa315a36823fa4cbec36e3" translate="yes" xml:space="preserve">
          <source>Output::try_from</source>
          <target state="translated">Output::try_from</target>
        </trans-unit>
        <trans-unit id="5be92053871d2c9c72d6bad5e8965eb4276aed9e" translate="yes" xml:space="preserve">
          <source>Output::try_into</source>
          <target state="translated">Output::try_into</target>
        </trans-unit>
        <trans-unit id="a0027fc28599b52fba5b8c93b690e40203fbae0a" translate="yes" xml:space="preserve">
          <source>Output::type_id</source>
          <target state="translated">Output::type_id</target>
        </trans-unit>
        <trans-unit id="fc89893a1de62fd92a4d6c68804db741e3ea0dcd" translate="yes" xml:space="preserve">
          <source>Outputs the detailed cause of parsing an integer failing.</source>
          <target state="translated">정수 구문 분석 실패의 자세한 원인을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="f456860c31542ff957a3adb8014b9119de57fc9b" translate="yes" xml:space="preserve">
          <source>Outside of the defining crate, types annotated with &lt;code&gt;non_exhaustive&lt;/code&gt; have limitations that preserve backwards compatibility when new fields or variants are added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da7bc9200c71949eae8135d4a25bb5b299cf7cc" translate="yes" xml:space="preserve">
          <source>Overflow</source>
          <target state="translated">Overflow</target>
        </trans-unit>
        <trans-unit id="3467b7b5de17cb6f124e7f7c4127e41ae85ffcdf" translate="yes" xml:space="preserve">
          <source>Overflow Behavior</source>
          <target state="translated">오버플로 동작</target>
        </trans-unit>
        <trans-unit id="91ff3d30af6aecf4f3bfff401ee0c4026a8aeafc" translate="yes" xml:space="preserve">
          <source>Overflow behavior</source>
          <target state="translated">오버플로 동작</target>
        </trans-unit>
        <trans-unit id="268ceeb8fd762749a7c0aa0e18a308d2a3e0eae9" translate="yes" xml:space="preserve">
          <source>Overflowing Euclidean remainder. Calculates &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt;.</source>
          <target state="translated">넘치는 유클리드 잔재. &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt; 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="1a536f91d51d79c240c5d894b51ca7769b45b744" translate="yes" xml:space="preserve">
          <source>Overloadable operators.</source>
          <target state="translated">과부하 연산자.</target>
        </trans-unit>
        <trans-unit id="40546cb9c881ab1291c600fcc0df156813d3befe" translate="yes" xml:space="preserve">
          <source>Overloadable?</source>
          <target state="translated">Overloadable?</target>
        </trans-unit>
        <trans-unit id="1541c7c02fe167096e792d52736b0810a9fb3cfa" translate="yes" xml:space="preserve">
          <source>Overloading Trait</source>
          <target state="translated">과부하 특성</target>
        </trans-unit>
        <trans-unit id="76ecfec5f0e4ba427d318353841c4d754fd5e25f" translate="yes" xml:space="preserve">
          <source>Overloading Traits</source>
          <target state="translated">과부하 특성</target>
        </trans-unit>
        <trans-unit id="39a5b884e85ec2d623399dce4a7f443948a467bd" translate="yes" xml:space="preserve">
          <source>Overloading method</source>
          <target state="translated">과부하 방식</target>
        </trans-unit>
        <trans-unit id="2304de1bde1f4f91ef0e295fad1655647768d0a1" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;dwDesiredAccess&lt;/code&gt; argument to the call to &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea&quot;&gt;&lt;code&gt;CreateFile&lt;/code&gt;&lt;/a&gt; with the specified value.</source>
          <target state="translated">호출에 대한 &lt;code&gt;dwDesiredAccess&lt;/code&gt; 인수를 재정의합니다.&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea&quot;&gt; &lt;code&gt;CreateFile&lt;/code&gt; &lt;/a&gt;지정된 값을 사용하여 CreateFile.</target>
        </trans-unit>
        <trans-unit id="5d6da6029474f8062969b88fdeb581d72daa0b18" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;dwDesiredAccess&lt;/code&gt; argument to the call to &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea&quot;&gt;&lt;code&gt;CreateFile&lt;/code&gt;&lt;/a&gt; with the specified value. &lt;a href=&quot;../os/windows/fs/trait.openoptionsext#tymethod.access_mode&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea&quot;&gt; &lt;code&gt;CreateFile&lt;/code&gt; &lt;/a&gt; 호출에 대한 &lt;code&gt;dwDesiredAccess&lt;/code&gt; 인수를 재정의합니다.지정된 값을 사용하여 . &lt;a href=&quot;../os/windows/fs/trait.openoptionsext#tymethod.access_mode&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd333bcce81d89530a67062d3af83d0e05013841" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;dwDesiredAccess&lt;/code&gt; argument to the call to &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858.aspx&quot;&gt;&lt;code&gt;CreateFile&lt;/code&gt;&lt;/a&gt; with the specified value.</source>
          <target state="translated">지정된 값을 사용하여 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858.aspx&quot;&gt; &lt;code&gt;CreateFile&lt;/code&gt; &lt;/a&gt; 호출에 대한 &lt;code&gt;dwDesiredAccess&lt;/code&gt; 인수를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="6c959035dcdad00a6f6547d8f9d2286eb95a249a" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;dwDesiredAccess&lt;/code&gt; argument to the call to [&lt;code&gt;CreateFile&lt;/code&gt;] with the specified value. &lt;a href=&quot;../os/windows/fs/trait.openoptionsext#tymethod.access_mode&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">지정된 값 으로 [ &lt;code&gt;CreateFile&lt;/code&gt; ] 호출에 대한 &lt;code&gt;dwDesiredAccess&lt;/code&gt; 인수를 대체합니다 . &lt;a href=&quot;../os/windows/fs/trait.openoptionsext#tymethod.access_mode&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f75345eeea8107cdd449ddf381cab1978912715e" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;dwShareMode&lt;/code&gt; argument to the call to &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea&quot;&gt;&lt;code&gt;CreateFile&lt;/code&gt;&lt;/a&gt; with the specified value.</source>
          <target state="translated">&lt;code&gt;dwShareMode&lt;/code&gt; 인수를 다음 호출에 재정의합니다.&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea&quot;&gt; &lt;code&gt;CreateFile&lt;/code&gt; &lt;/a&gt;지정된 값을 사용하여 CreateFile.</target>
        </trans-unit>
        <trans-unit id="3e26cda912f98913d10a65d39724557408f3a607" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;dwShareMode&lt;/code&gt; argument to the call to &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea&quot;&gt;&lt;code&gt;CreateFile&lt;/code&gt;&lt;/a&gt; with the specified value. &lt;a href=&quot;../os/windows/fs/trait.openoptionsext#tymethod.share_mode&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">지정된 값을 사용하여 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea&quot;&gt; &lt;code&gt;CreateFile&lt;/code&gt; &lt;/a&gt; 에 대한 호출에 대한 &lt;code&gt;dwShareMode&lt;/code&gt; 인수를 재정의합니다 . &lt;a href=&quot;../os/windows/fs/trait.openoptionsext#tymethod.share_mode&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b87109866c9e881094fc3108cb2582359d9f6aa9" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;dwShareMode&lt;/code&gt; argument to the call to &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858.aspx&quot;&gt;&lt;code&gt;CreateFile&lt;/code&gt;&lt;/a&gt; with the specified value.</source>
          <target state="translated">지정된 값 으로 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858.aspx&quot;&gt; &lt;code&gt;CreateFile&lt;/code&gt; &lt;/a&gt; 호출에 대한 &lt;code&gt;dwShareMode&lt;/code&gt; 인수를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="cf2d85760bd185994ef5bf2f175143dec9ca3909" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;dwShareMode&lt;/code&gt; argument to the call to [&lt;code&gt;CreateFile&lt;/code&gt;] with the specified value. &lt;a href=&quot;../os/windows/fs/trait.openoptionsext#tymethod.share_mode&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">지정된 값 으로 [ &lt;code&gt;CreateFile&lt;/code&gt; ] 호출에 대한 &lt;code&gt;dwShareMode&lt;/code&gt; 인수를 대체합니다 . &lt;a href=&quot;../os/windows/fs/trait.openoptionsext#tymethod.share_mode&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="cd8f194e8d7e958260d7af2051984d8f3e683b51" translate="yes" xml:space="preserve">
          <source>Overwrites a memory location with the given value without reading or dropping the old value.</source>
          <target state="translated">이전 값을 읽거나 삭제하지 않고 주어진 값으로 메모리 위치를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="949a410afc355b96a7905ccc83a834749836d22c" translate="yes" xml:space="preserve">
          <source>Overwriting a Value</source>
          <target state="translated">값 덮어 쓰기</target>
        </trans-unit>
        <trans-unit id="5ebf9d2abbf1cc7aae1c696ee32449969d19a22c" translate="yes" xml:space="preserve">
          <source>Owned data.</source>
          <target state="translated">소유 한 데이터.</target>
        </trans-unit>
        <trans-unit id="4fbf13be9f8b7616cdb154755370e6d320e7e90d" translate="yes" xml:space="preserve">
          <source>Ownership Rules</source>
          <target state="translated">소유권 규칙</target>
        </trans-unit>
        <trans-unit id="1340f6fc9cc4c2d08ca6cee78e483a7eadf7311f" translate="yes" xml:space="preserve">
          <source>Ownership affects how lots of other parts of Rust work, so we&amp;rsquo;ll talk about these concepts further throughout the rest of the book. Let&amp;rsquo;s move on to Chapter 5 and look at grouping pieces of data together in a &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">소유권은 Rust의 다른 많은 부분에 영향을 미치므로이 책의 나머지 부분에서 이러한 개념에 대해 더 이야기하겠습니다. 5 장으로 넘어 가서 &lt;code&gt;struct&lt;/code&gt; 에 데이터 조각을 그룹화하는 것을 보자 .</target>
        </trans-unit>
        <trans-unit id="061f3ef75cdf7d220844151ec65f84114fd6c667" translate="yes" xml:space="preserve">
          <source>Ownership and Functions</source>
          <target state="translated">소유권과 기능</target>
        </trans-unit>
        <trans-unit id="e783f9dc891702d006be5ffb27e982821fefa6e5" translate="yes" xml:space="preserve">
          <source>Ownership and the drop check</source>
          <target state="translated">소유권과 낙차 확인</target>
        </trans-unit>
        <trans-unit id="dd97430c54818d57ae7f4721676609e1836384c3" translate="yes" xml:space="preserve">
          <source>Ownership is Rust&amp;rsquo;s most unique feature, and it enables Rust to make memory safety guarantees without needing a garbage collector. Therefore, it&amp;rsquo;s important to understand how ownership works in Rust. In this chapter, we&amp;rsquo;ll talk about ownership as well as several related features: borrowing, slices, and how Rust lays data out in memory.</source>
          <target state="translated">소유권은 Rust의 가장 독창적 인 기능이며 Rust가 가비지 콜렉터없이 메모리 안전을 보장 할 수 있도록합니다. 따라서 Rust에서 소유권이 어떻게 작동하는지 이해하는 것이 중요합니다. 이 장에서는 소유권과 몇 가지 관련 기능 (차용, 슬라이스 및 Rust이 데이터를 메모리에 배치하는 방법)에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7bcd32d1ab543a47fbd7ea77937460f4ae2b2e40" translate="yes" xml:space="preserve">
          <source>Ownership of Struct Data</source>
          <target state="translated">구조 데이터의 소유권</target>
        </trans-unit>
        <trans-unit id="7d0b385e3bf746d2a40063b477100d32fc06fbb3" translate="yes" xml:space="preserve">
          <source>Ownership of the Returned Value</source>
          <target state="translated">반환 된 가치의 소유권</target>
        </trans-unit>
        <trans-unit id="fa7ff6fb00a7ace8d98cf880a492dc6c5ffc8ca7" translate="yes" xml:space="preserve">
          <source>PI</source>
          <target state="translated">PI</target>
        </trans-unit>
        <trans-unit id="99a088ed6d9619a992c784e598231666dc79ef59" translate="yes" xml:space="preserve">
          <source>Packages and Crates</source>
          <target state="translated">패키지 및 상자</target>
        </trans-unit>
        <trans-unit id="d6664ac6a163b68baf85aa80b0de081ae92d3945" translate="yes" xml:space="preserve">
          <source>Panic support in the standard library.</source>
          <target state="translated">표준 라이브러리에서 패닉 지원.</target>
        </trans-unit>
        <trans-unit id="e69c39e691255780ecc80f46bb976506c1d6aca2" translate="yes" xml:space="preserve">
          <source>Panic the current thread with the given message as the panic payload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64750ba8905f79ec9b27121f796de54641de81e8" translate="yes" xml:space="preserve">
          <source>Panic-free bitwise shift-left; yields &lt;code&gt;self &amp;lt;&amp;lt; mask(rhs)&lt;/code&gt;, where &lt;code&gt;mask&lt;/code&gt; removes any high-order bits of &lt;code&gt;rhs&lt;/code&gt; that would cause the shift to exceed the bitwidth of the type.</source>
          <target state="translated">패닉 프리 비트 시프트 왼쪽; 산출 된 &lt;code&gt;self &amp;lt;&amp;lt; mask(rhs)&lt;/code&gt; , &lt;code&gt;mask&lt;/code&gt; 중 상위 비트 제거 &lt;code&gt;rhs&lt;/code&gt; 시프트 타입의 비트 폭을 초과 할 수있다.</target>
        </trans-unit>
        <trans-unit id="8aa0a650679136bf5c6a5c931f1774da4aa63dd5" translate="yes" xml:space="preserve">
          <source>Panic-free bitwise shift-right; yields &lt;code&gt;self &amp;gt;&amp;gt; mask(rhs)&lt;/code&gt;, where &lt;code&gt;mask&lt;/code&gt; removes any high-order bits of &lt;code&gt;rhs&lt;/code&gt; that would cause the shift to exceed the bitwidth of the type.</source>
          <target state="translated">패닉 프리 비트 단위 시프트 오른쪽; 산출 된 &lt;code&gt;self &amp;gt;&amp;gt; mask(rhs)&lt;/code&gt; , &lt;code&gt;mask&lt;/code&gt; 중 상위 비트 제거 &lt;code&gt;rhs&lt;/code&gt; 시프트 타입의 비트 폭을 초과 할 수있다.</target>
        </trans-unit>
        <trans-unit id="ab31f4ac9fc3c9e915343e6e27bd26eabe596bd8" translate="yes" xml:space="preserve">
          <source>PanicInfo</source>
          <target state="translated">PanicInfo</target>
        </trans-unit>
        <trans-unit id="643cc2152accd53993d549a5d958a2a8112c605d" translate="yes" xml:space="preserve">
          <source>PanicInfo::borrow</source>
          <target state="translated">PanicInfo::borrow</target>
        </trans-unit>
        <trans-unit id="6f87929cce7f37a4643cf9668cce7fd2a3c0a867" translate="yes" xml:space="preserve">
          <source>PanicInfo::borrow_mut</source>
          <target state="translated">PanicInfo::borrow_mut</target>
        </trans-unit>
        <trans-unit id="0627e71cb9d2ea5c4e376502d4b534944d95a2b5" translate="yes" xml:space="preserve">
          <source>PanicInfo::fmt</source>
          <target state="translated">PanicInfo::fmt</target>
        </trans-unit>
        <trans-unit id="a75f88ef036635c57bb6c3f294eb1864b080d92b" translate="yes" xml:space="preserve">
          <source>PanicInfo::from</source>
          <target state="translated">PanicInfo::from</target>
        </trans-unit>
        <trans-unit id="f5d51dd33ffc0fc2d5c8579f0762bbffa7356d33" translate="yes" xml:space="preserve">
          <source>PanicInfo::into</source>
          <target state="translated">PanicInfo::into</target>
        </trans-unit>
        <trans-unit id="1a5376f14ebb31aa62bb71354df743f4ab22d90f" translate="yes" xml:space="preserve">
          <source>PanicInfo::location</source>
          <target state="translated">PanicInfo::location</target>
        </trans-unit>
        <trans-unit id="f4f5b6dcf5ba5934d97c8506165f90b66a53635d" translate="yes" xml:space="preserve">
          <source>PanicInfo::message</source>
          <target state="translated">PanicInfo::message</target>
        </trans-unit>
        <trans-unit id="41ad71622e704da94b5ec33eec78cbe35e9d9051" translate="yes" xml:space="preserve">
          <source>PanicInfo::payload</source>
          <target state="translated">PanicInfo::payload</target>
        </trans-unit>
        <trans-unit id="0c5da16342c18730d19426fb04fb7d13e95927ef" translate="yes" xml:space="preserve">
          <source>PanicInfo::to_string</source>
          <target state="translated">PanicInfo::to_string</target>
        </trans-unit>
        <trans-unit id="128dfe7ed8ea9040dfa6b755a8f58a058809a754" translate="yes" xml:space="preserve">
          <source>PanicInfo::try_from</source>
          <target state="translated">PanicInfo::try_from</target>
        </trans-unit>
        <trans-unit id="124e8d1366dede099902e66296c0fd7c941d22c8" translate="yes" xml:space="preserve">
          <source>PanicInfo::try_into</source>
          <target state="translated">PanicInfo::try_into</target>
        </trans-unit>
        <trans-unit id="7d559bee200d64d9ed14e627440fc27efa09a6ed" translate="yes" xml:space="preserve">
          <source>PanicInfo::type_id</source>
          <target state="translated">PanicInfo::type_id</target>
        </trans-unit>
        <trans-unit id="b6d2a57e62de0b05a8e65f1687e4f544c18dd949" translate="yes" xml:space="preserve">
          <source>Panics</source>
          <target state="translated">Panics</target>
        </trans-unit>
        <trans-unit id="3f15b674a181b9dd8657cd84469dac52f9c96550" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;N&lt;/code&gt; is 0. This check will most probably get changed to a compile time error before this method gets stabilized.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 이 0 이면 패닉 이 발생합니다.이 검사는이 메서드가 안정화되기 전에 컴파일 시간 오류로 변경 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="45e26bbcde013da7d92e500c033afb14073380bf" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; are out of bounds.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 또는 &lt;code&gt;b&lt;/code&gt; 가 범위를 벗어난 경우 패닉이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="e3cf74e01d7358bfd9a5fe8f5999d1266efbbdf0" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;at &amp;gt; len&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;at &amp;gt; len&lt;/code&gt; 경우 패닉이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="9a00b9bcb539cbd67965e71599dbb2232d727abe" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;at&lt;/code&gt; is not on a &lt;code&gt;UTF-8&lt;/code&gt; code point boundary, or if it is beyond the last code point of the string.</source>
          <target state="translated">&lt;code&gt;at&lt;/code&gt; 이 &lt;code&gt;UTF-8&lt;/code&gt; 코드 포인트 경계에 있지 않거나 문자열의 마지막 코드 포인트를 초과하면 패닉이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="cc29dc108576e18e0990d54dd465b6a57e3a4505" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;begin&lt;/code&gt; does not point to the starting byte offset of a character (as defined by &lt;code&gt;is_char_boundary&lt;/code&gt;), if &lt;code&gt;end&lt;/code&gt; does not point to the ending byte offset of a character (&lt;code&gt;end + 1&lt;/code&gt; is either a starting byte offset or equal to &lt;code&gt;len&lt;/code&gt;), if &lt;code&gt;begin &amp;gt; end&lt;/code&gt;, or if &lt;code&gt;end &amp;gt;= len&lt;/code&gt;.</source>
          <target state="translated">패닉 경우 &lt;code&gt;begin&lt;/code&gt; (의해 정의되는 문자의 개시 오프셋 바이트를 가리 키지 &lt;code&gt;is_char_boundary&lt;/code&gt; 경우) &lt;code&gt;end&lt;/code&gt; 문자의 오프셋 끝나는 바이트 지점 (되지 않는 &lt;code&gt;end + 1&lt;/code&gt; 오프셋 중 시작 바이트 혹은 등전위 &lt;code&gt;len&lt;/code&gt; ), 경우 &lt;code&gt;begin &amp;gt; end&lt;/code&gt; , 또는 경우에 &lt;code&gt;end &amp;gt;= len&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdce63887d8794a1745f1a7cccaa08d82fd51111" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;begin&lt;/code&gt; does not point to the starting byte offset of a character (as defined by &lt;code&gt;is_char_boundary&lt;/code&gt;), or if &lt;code&gt;begin &amp;gt; len&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;begin&lt;/code&gt; 이 문자의 시작 바이트 오프셋을 가리 키지 않으면 패닉이 발생 합니다 ( &lt;code&gt;is_char_boundary&lt;/code&gt; 에 정의 된 대로) ) 않거나 &lt;code&gt;begin &amp;gt; len&lt;/code&gt; 경우 .</target>
        </trans-unit>
        <trans-unit id="d883f0070f09958226988ed7cfef750adf9a7212" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;begin&lt;/code&gt; does not point to the starting byte offset of a character (as defined by &lt;code&gt;is_char_boundary&lt;/code&gt;), or if &lt;code&gt;begin &amp;gt;= len&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;begin&lt;/code&gt; 이 문자의 시작 바이트 오프셋을 가리 키지 않거나 ( &lt;code&gt;is_char_boundary&lt;/code&gt; 에 정의 된 대로 ) &lt;code&gt;begin &amp;gt;= len&lt;/code&gt; 경우 패닉이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="227c67bc70f8605678180bb1c51bde64cbfc241f" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;begin&lt;/code&gt; or &lt;code&gt;end&lt;/code&gt; does not point to the starting byte offset of a character (as defined by &lt;code&gt;is_char_boundary&lt;/code&gt;), if &lt;code&gt;begin &amp;gt; end&lt;/code&gt;, or if &lt;code&gt;end &amp;gt; len&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;begin&lt;/code&gt; 또는 &lt;code&gt;end&lt;/code&gt; 가 패닉 ( &lt;code&gt;is_char_boundary&lt;/code&gt; 에 정의 된 대로 ) 문자의 시작 바이트 오프셋을 가리 키지 않거나 &lt;code&gt;begin &amp;gt; end&lt;/code&gt; 또는 &lt;code&gt;end &amp;gt; len&lt;/code&gt; 경우 패닉이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="e87f5b8a7bcf907dca18470bd2c4295b8f82a333" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;chunk_size&lt;/code&gt; is 0.</source>
          <target state="translated">&lt;code&gt;chunk_size&lt;/code&gt; 가 0 인 경우 패닉이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="b26629f2e9cb257daf9479ce741e24d310ef11cc" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;end&lt;/code&gt; does not point to the ending byte offset of a character (&lt;code&gt;end + 1&lt;/code&gt; is either a starting byte offset as defined by &lt;code&gt;is_char_boundary&lt;/code&gt;, or equal to &lt;code&gt;len&lt;/code&gt;), or if &lt;code&gt;end &amp;gt;= len&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;end&lt;/code&gt; 가 문자의 종료 바이트 오프셋을 가리 키지 않는 경우 ( &lt;code&gt;end + 1&lt;/code&gt; 은 &lt;code&gt;is_char_boundary&lt;/code&gt; 에 의해 정의 된 시작 바이트 오프셋 이거나 &lt;code&gt;len&lt;/code&gt; 과 동일 함 ) 또는 &lt;code&gt;end &amp;gt;= len&lt;/code&gt; 경우 패닉이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="6581cda5b120f3ca8bd07261fc66544bbbb296d9" translate="yes" xml:space="preserve">
          <source>Panics if &lt;code&gt;end&lt;/code&gt; does not point to the starting byte offset of a character (as defined by &lt;code&gt;is_char_boundary&lt;/code&gt;), or if &lt;code&gt;end &amp;gt; len&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;end&lt;/code&gt; 가 문자의 시작 바이트 오프셋을 가리 키지 않거나 ( &lt;code&gt;is_char_boundary&lt;/code&gt; 로 정의 된 경우) &lt;code&gt;end &amp;gt; len&lt;/code&gt; 경우 패닉이 발생 합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
