<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="74ec56d1bf817c0befd406275e3cdc68acd63801" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Unknown.field.cmsg_level&quot;&gt;&lt;code&gt;cmsg_level:&amp;nbsp;&lt;a href=&quot;../../../primitive.i32&quot;&gt;i32&lt;/a&gt;&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Unknown.field.cmsg_level&quot;&gt;&lt;code&gt;cmsg_level:&amp;nbsp;&lt;a href=&quot;../../../primitive.i32&quot;&gt;i32&lt;/a&gt;&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9f752b0935e93abaf0f9500cbb548195f26e0793" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Unknown.field.cmsg_type&quot;&gt;&lt;code&gt;cmsg_type:&amp;nbsp;&lt;a href=&quot;../../../primitive.i32&quot;&gt;i32&lt;/a&gt;&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Unknown.field.cmsg_type&quot;&gt;&lt;code&gt;cmsg_type:&amp;nbsp;&lt;a href=&quot;../../../primitive.i32&quot;&gt;i32&lt;/a&gt;&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="a8dd251a1207d4e11e3d10d61c6d014b2646ff37" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.V4&quot;&gt;&lt;code id=&quot;V4.v&quot;&gt;V4(&lt;a href=&quot;struct.ipv4addr&quot;&gt;Ipv4Addr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.V4&quot;&gt;&lt;code id=&quot;V4.v&quot;&gt;V4(&lt;a href=&quot;struct.ipv4addr&quot;&gt;Ipv4Addr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="900d145487fbb075cf35b7f31871559fc4e06aea" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.V4&quot;&gt;&lt;code id=&quot;V4.v&quot;&gt;V4(&lt;a href=&quot;struct.socketaddrv4&quot;&gt;SocketAddrV4&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.V4&quot;&gt;&lt;code id=&quot;V4.v&quot;&gt;V4(&lt;a href=&quot;struct.socketaddrv4&quot;&gt;SocketAddrV4&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="ccd5990162f9019755ca0861aec17eeb838635c5" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.V6&quot;&gt;&lt;code id=&quot;V6.v&quot;&gt;V6(&lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6Addr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.V6&quot;&gt;&lt;code id=&quot;V6.v&quot;&gt;V6(&lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6Addr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="df27b63255e5ca4dd10ee3931d89a214cb7a79e8" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.V6&quot;&gt;&lt;code id=&quot;V6.v&quot;&gt;V6(&lt;a href=&quot;struct.socketaddrv6&quot;&gt;SocketAddrV6&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.V6&quot;&gt;&lt;code id=&quot;V6.v&quot;&gt;V6(&lt;a href=&quot;struct.socketaddrv6&quot;&gt;SocketAddrV6&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="b1ea069ef9327f5c3a1a861557ea04c82575ae3c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Vacant&quot;&gt;&lt;code id=&quot;Vacant.v&quot;&gt;Vacant(&lt;a href=&quot;struct.rawvacantentrymut&quot;&gt;RawVacantEntryMut&lt;/a&gt;&amp;lt;'a, K, V, S&amp;gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Vacant&quot;&gt; &lt;code id=&quot;Vacant.v&quot;&gt;Vacant(&lt;a href=&quot;struct.rawvacantentrymut&quot;&gt;RawVacantEntryMut&lt;/a&gt;&amp;lt;'a, K, V, S&amp;gt;)&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="a3f52e8e92525a9484f9ea21a413660d15607c54" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Vacant&quot;&gt;&lt;code id=&quot;Vacant.v&quot;&gt;Vacant(&lt;a href=&quot;struct.vacantentry&quot;&gt;VacantEntry&lt;/a&gt;&amp;lt;'a, K, V&amp;gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Vacant&quot;&gt; &lt;code id=&quot;Vacant.v&quot;&gt;Vacant(&lt;a href=&quot;struct.vacantentry&quot;&gt;VacantEntry&lt;/a&gt;&amp;lt;'a, K, V&amp;gt;)&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="cc590a03de1082f370b8b404e093e91ac5cb0306" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Verbatim&quot;&gt;&lt;code id=&quot;Verbatim.v&quot;&gt;Verbatim(&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Verbatim&quot;&gt; &lt;code id=&quot;Verbatim.v&quot;&gt;Verbatim(&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;)&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="5aa296add133e61d06a6d4259d1fb0881eb7bd39" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.VerbatimDisk&quot;&gt;&lt;code id=&quot;VerbatimDisk.v&quot;&gt;VerbatimDisk(&lt;a href=&quot;../primitive.u8&quot;&gt;u8&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.VerbatimDisk&quot;&gt;&lt;code id=&quot;VerbatimDisk.v&quot;&gt;VerbatimDisk(&lt;a href=&quot;../primitive.u8&quot;&gt;u8&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="f6b929546a75faa42e8181de8ca57bcfbd173f85" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.VerbatimUNC&quot;&gt;&lt;code id=&quot;VerbatimUNC.v&quot;&gt;VerbatimUNC(&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;,&amp;nbsp;&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.VerbatimUNC&quot;&gt; &lt;code id=&quot;VerbatimUNC.v&quot;&gt;VerbatimUNC(&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;,&amp;nbsp;&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;)&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9cd9ad739de8cce934db346fc40fc958c8b3429e" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.WouldBlock&quot;&gt;&lt;code id=&quot;WouldBlock.v&quot;&gt;WouldBlock&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.WouldBlock&quot;&gt;&lt;code id=&quot;WouldBlock.v&quot;&gt;WouldBlock&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="31c97026aa6d07f6414185d909730c36779144a9" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Write&quot;&gt;&lt;code id=&quot;Write.v&quot;&gt;Write&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Write&quot;&gt;&lt;code id=&quot;Write.v&quot;&gt;Write&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="61e6c90d5de31882b090799d674e61ef0d0f389c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.WriteZero&quot;&gt;&lt;code id=&quot;WriteZero.v&quot;&gt;WriteZero&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.WriteZero&quot;&gt;&lt;code id=&quot;WriteZero.v&quot;&gt;WriteZero&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="dc8ede49b45bb296751c2a5d3ace189c5a80e69c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Yielded&quot;&gt;&lt;code id=&quot;Yielded.v&quot;&gt;Yielded(Y)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Yielded&quot;&gt;&lt;code id=&quot;Yielded.v&quot;&gt;Yielded(Y)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="6b8f56e3c79b5975e1be195dd3734989bee366c7" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Zero&quot;&gt;&lt;code id=&quot;Zero.v&quot;&gt;Zero&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Zero&quot;&gt;&lt;code id=&quot;Zero.v&quot;&gt;Zero&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="8d30ecbd2f33931b54af81e7b1473f6ce8c0ba0d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/10184&quot;&gt;NOTE: currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type&lt;/a&gt;&lt;/strong&gt;. This includes Inf and NaN. This is a bug and will be fixed.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/10184&quot;&gt;참고 : 현재 반올림 된 값을 대상 정수 유형으로 나타낼 수없는 경우 정의되지 않은 동작이 발생합니다&lt;/a&gt;&lt;/strong&gt; . 여기에는 Inf 및 NaN이 포함됩니다. 이것은 버그이며 수정 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="92971d62fe3186475f026398e7a0174099738633" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/15536&quot;&gt;NOTE: currently this will cause Undefined Behavior if the value is finite but larger or smaller than the largest or smallest finite value representable by f32&lt;/a&gt;&lt;/strong&gt;. This is a bug and will be fixed.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/15536&quot;&gt;참고 : 현재 값이 유한하지만 f32로 나타낼 수있는 최대 또는 최소 유한 값보다 크거나 작은 경우 정의되지 않은 동작이 발생합니다.&lt;/a&gt;&lt;/strong&gt; . 이것은 버그이며 수정 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="1afbb08e18a2a8950ebdff5b3534ae0f7e3fd83f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Note&lt;/em&gt;&lt;/strong&gt;: The &lt;code&gt;rustc&lt;/code&gt; compiler automatically inlines functions based on internal heuristics. Incorrectly inlining functions can make the program slower, so this attribute should be used with care.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;참고&lt;/em&gt;&lt;/strong&gt; : &lt;code&gt;rustc&lt;/code&gt; 컴파일러는 내부 휴리스틱을 기반으로 함수를 자동으로 인라인합니다. 함수를 잘못 인라인하면 프로그램 속도가 느려질 수 있으므로이 속성을주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="52af196e2df7d6d1d70d4b20971e00ada5feef77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt; Dereferencing an unaligned pointer is &lt;a href=&quot;behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; and it is possible to &lt;a href=&quot;https://github.com/rust-lang/rust/issues/27060&quot;&gt;safely create unaligned pointers to &lt;code&gt;packed&lt;/code&gt; fields&lt;/a&gt;. Like all ways to create undefined behavior in safe Rust, this is a bug.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;경고 :&lt;/em&gt;&lt;/strong&gt; 정렬되지 않은 포인터를 참조 해제하는 것은&lt;a href=&quot;behavior-considered-undefined&quot;&gt; 정의되지 않은 동작&lt;/a&gt; 이며&lt;a href=&quot;https://github.com/rust-lang/rust/issues/27060&quot;&gt; &lt;code&gt;packed&lt;/code&gt; &lt;/a&gt; 필드에 대해 정렬되지 않은 포인터를 안전하게 만들 수 있습니다 . 안전한 Rust에서 정의되지 않은 동작을 만드는 모든 방법과 마찬가지로 이것은 버그입니다.</target>
        </trans-unit>
        <trans-unit id="641eae7d16c8e6d62bab0c62010b11532ce2de80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt; For &lt;a href=&quot;../types/trait-object&quot;&gt;trait objects&lt;/a&gt;, if there is an inherent method of the same name as a trait method, it will give a compiler error when trying to call the method in a method call expression. Instead, you can call the method using &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;disambiguating function call syntax&lt;/a&gt;, in which case it calls the trait method, not the inherent method. There is no way to call the inherent method. Just don't define inherent methods on trait objects with the same name a trait method and you'll be fine.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;경고 :&lt;/em&gt;&lt;/strong&gt; 들어&lt;a href=&quot;../types/trait-object&quot;&gt; 특성 객체를&lt;/a&gt; 형질 방법과 동일한 이름의 고유 한 방법이있는 경우, 메소드 호출 식의 메소드를 호출 할 때, 그것은 컴파일러 오류를 줄 것이다. 대신&lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt; 명확성있는 함수 호출 구문을&lt;/a&gt; 사용하여 메소드를 호출 할 수 있습니다.이 경우 고유 메소드가 아닌 특성 메소드를 호출합니다. 고유 메소드를 호출 할 방법이 없습니다. 특성 이름과 같은 특성을 가진 특성 오브젝트에 고유 한 메소드를 정의하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="14f5badea1be2736539096eaf684db8c5d26b01b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt; The following list is not exhaustive. There is no formal model of Rust's semantics for what is and is not allowed in unsafe code, so there may be more behavior considered unsafe. The following list is just what we know for sure is undefined behavior. Please read the &lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt;Rustonomicon&lt;/a&gt; before writing unsafe code.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;경고 :&lt;/em&gt;&lt;/strong&gt; 다음 목록은 전체가 아닙니다. 안전하지 않은 코드에서 허용되는 것과 허용되지 않는 것에 대한 Rust 의미의 공식 모델은 없으므로 안전하지 않은 것으로 간주되는 동작이 더있을 수 있습니다. 다음 목록은 정의되지 않은 동작입니다. 안전하지 않은 코드를 작성하기 전에&lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt; Rustonomicon을&lt;/a&gt; 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="0029a09af0cc0f5afc1611697c9ad1ed7b7d0cfc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt; With two trait object types, even when the complete set of traits is the same, if the base traits differ, the type is different. For example, &lt;code&gt;dyn Send + Sync&lt;/code&gt; is a different type from &lt;code&gt;dyn Sync + Send&lt;/code&gt;. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/33140&quot;&gt;issue 33140&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;경고 :&lt;/em&gt;&lt;/strong&gt; 두 개의 특성 오브젝트 유형을 사용하면 전체 특성 세트가 동일하더라도 기본 특성이 다르면 유형이 다릅니다. 예를 들어, &lt;code&gt;dyn Send + Sync&lt;/code&gt; 는 &lt;code&gt;dyn Sync + Send&lt;/code&gt; 와 다른 유형입니다. &lt;a href=&quot;https://github.com/rust-lang/rust/issues/33140&quot;&gt;이슈 33140을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ee107fe206809602998471109ca3cf88bae2bbb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Lexer 2015&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;렉서 2015&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="086e314e305cc39ba4d4b327b89e5d7a0d8c6f03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Lexer 2018+&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;렉서 2018+&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32563aa7feb766e8d7e65307f8bc48e47003b702" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Lexer:&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;Lexer:&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a3ac7aad80402b534d708e407025f17f7772a4ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Lexer&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;Lexer&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="13ea811ecc594e94181b24eb80a75c60e5e29672" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Syntax:&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;Syntax:&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4284bd4d709ac711e8c06bbdaf51939ae42316ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Syntax&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;Syntax&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="04d38a540329625df538c94f4f56761b0074d0fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Character size&lt;/strong&gt; - C strings may use &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt;-sized characters; please &lt;strong&gt;note&lt;/strong&gt; that C's &lt;code&gt;char&lt;/code&gt; is different from Rust's. The C standard leaves the actual sizes of those types open to interpretation, but defines different APIs for strings made up of each character type. Rust strings are always UTF-8, so different Unicode characters will be encoded in a variable number of bytes each. The Rust type &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a '&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="translated">&lt;strong&gt;문자 크기&lt;/strong&gt; -C 문자열은 &lt;code&gt;char&lt;/code&gt; 또는 &lt;code&gt;wchar_t&lt;/code&gt; 크기의 문자를 사용할 수 있습니다 . 제발 &lt;strong&gt;주의&lt;/strong&gt; C의 것을 &lt;code&gt;char&lt;/code&gt; 녹의 다릅니다. C 표준은 이러한 유형의 실제 크기를 해석하기 위해 개방하지만 각 문자 유형으로 구성된 문자열에 대해 서로 다른 API를 정의합니다. 녹 문자열은 항상 UTF-8이므로 다른 유니 코드 문자는 각각 가변 바이트 수로 인코딩됩니다. Rust 타입 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 는 ' &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;유니 코드 스칼라 값&lt;/a&gt; '을 나타내며, 이는 ' &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;유니 코드 코드 포인트&lt;/a&gt; ' 와 유사하지만 동일하지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0ce042add186ebd327aa00b3f56f494c53302773" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Character size&lt;/strong&gt; - C strings may use &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt;-sized characters; please &lt;strong&gt;note&lt;/strong&gt; that C's &lt;code&gt;char&lt;/code&gt; is different from Rust's. The C standard leaves the actual sizes of those types open to interpretation, but defines different APIs for strings made up of each character type. Rust strings are always UTF-8, so different Unicode characters will be encoded in a variable number of bytes each. The Rust type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.char.html&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a '&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="translated">&lt;strong&gt;문자 크기&lt;/strong&gt; -C 문자열은 &lt;code&gt;char&lt;/code&gt; 또는 &lt;code&gt;wchar_t&lt;/code&gt; 크기의 문자를 사용할 수 있습니다 . 제발 &lt;strong&gt;주의&lt;/strong&gt; C의 것을 &lt;code&gt;char&lt;/code&gt; 녹의 다릅니다. C 표준은 이러한 유형의 실제 크기를 해석 할 수 있도록 남겨 두지 만 각 문자 유형으로 구성된 문자열에 대해 서로 다른 API를 정의합니다. Rust 문자열은 항상 UTF-8이므로 서로 다른 유니 코드 문자가 각각 가변 바이트 수로 인코딩됩니다. Rust 유형 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.char.html&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 은 ' &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode 코드 포인트&lt;/a&gt; ' 와 유사하지만 동일하지는 않은 ' &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode 스칼라 값&lt;/a&gt; '을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="c1da5390166def59a905c5a3bf23d0d789eae735" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Character size&lt;/strong&gt; - C strings may use &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt;-sized characters; please &lt;strong&gt;note&lt;/strong&gt; that C's &lt;code&gt;char&lt;/code&gt; is different from Rust's. The C standard leaves the actual sizes of those types open to interpretation, but defines different APIs for strings made up of each character type. Rust strings are always UTF-8, so different Unicode characters will be encoded in a variable number of bytes each. The Rust type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.char.html&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a '&lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="translated">&lt;strong&gt;문자 크기&lt;/strong&gt; -C 문자열은 &lt;code&gt;char&lt;/code&gt; 또는 &lt;code&gt;wchar_t&lt;/code&gt; 크기의 문자를 사용할 수 있습니다 . 제발 &lt;strong&gt;주의&lt;/strong&gt; C의 것을 &lt;code&gt;char&lt;/code&gt; 녹의 다릅니다. C 표준은 이러한 유형의 실제 크기를 해석 할 수 있도록 남겨 두지 만 각 문자 유형으로 구성된 문자열에 대해 서로 다른 API를 정의합니다. Rust 문자열은 항상 UTF-8이므로 서로 다른 유니 코드 문자가 각각 가변 바이트 수로 인코딩됩니다. Rust 유형 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.char.html&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 은 ' &lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;Unicode 코드 포인트&lt;/a&gt; ' 와 유사하지만 동일하지는 않은 ' &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode 스칼라 값&lt;/a&gt; '을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="700eaca40cee125f38cc4d75b02d62979fde8825" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Crates:&lt;/strong&gt; A tree of modules that produces a library or executable</source>
          <target state="translated">&lt;strong&gt;상자 :&lt;/strong&gt; 라이브러리 또는 실행 파일을 생성하는 모듈 트리</target>
        </trans-unit>
        <trans-unit id="e782bb6068e1aacf17c4b0b3ec1d9875e47c4925" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer:&lt;/strong&gt; These system calls might change over time.</source>
          <target state="translated">&lt;strong&gt;고지 사항 :&lt;/strong&gt; 이러한 시스템 호출은 시간이 지남에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b8b3462b6d6c541b754f0aec381f7e706c421ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 Edition, the crate root contains a variety of different items, including external crates, default crates such as &lt;code&gt;std&lt;/code&gt; and &lt;code&gt;core&lt;/code&gt;, and items in the top level of the crate (including &lt;code&gt;use&lt;/code&gt; imports).</source>
          <target state="translated">&lt;strong&gt;판 차이&lt;/strong&gt; : 2015 년 판에서 상자 루트 외부 상자 등 다양한 항목의 다양한 포함 기본적는 같은 상자 &lt;code&gt;std&lt;/code&gt; 및 &lt;code&gt;core&lt;/code&gt; (를 포함하여 상자의 상단 레벨 및 아이템 &lt;code&gt;use&lt;/code&gt; 수입).</target>
        </trans-unit>
        <trans-unit id="e088bfe5ad018353c64bdbb01968dcde42ba3d14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 edition, &lt;code&gt;use&lt;/code&gt; paths also allow accessing items in the crate root. Using the example above, the following &lt;code&gt;use&lt;/code&gt; paths work in 2015 but not 2018:</source>
          <target state="translated">&lt;strong&gt;판의 차이는&lt;/strong&gt; : 2015 에디션에서 &lt;code&gt;use&lt;/code&gt; 경로는 또한 상자 루트의 항목을 액세스 할 수 있습니다. 위의 예를 사용하면 다음과 같은 &lt;code&gt;use&lt;/code&gt; 경로가 2015 년에 작동하지만 2018 년에는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="627f712f9b93a0a851f59c926530c05272107ff4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 edition, crates in the extern prelude cannot be referenced via &lt;a href=&quot;use-declarations&quot;&gt;use declarations&lt;/a&gt;, so it is generally standard practice to include &lt;code&gt;extern crate&lt;/code&gt; declarations to bring them into scope.</source>
          <target state="translated">&lt;strong&gt;판의 차이점&lt;/strong&gt; : 2015 판에서 extern prelude의 상자는 &lt;a href=&quot;use-declarations&quot;&gt;use declarations&lt;/a&gt; 를 통해 참조 할 수 없으므로 일반적으로 &lt;code&gt;extern crate&lt;/code&gt; 선언을 포함 시켜 범위를 넓히는 것이 표준 관행 입니다.</target>
        </trans-unit>
        <trans-unit id="f5085a0b269138950b893252f1966657953ef4b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 edition, if the first bound of the trait object is a path that starts with &lt;code&gt;::&lt;/code&gt;, then the &lt;code&gt;dyn&lt;/code&gt; will be treated as a part of the path. The first path can be put in parenthesis to get around this. As such, if you want a trait object with the trait &lt;code&gt;::your_module::Trait&lt;/code&gt;, you should write it as &lt;code&gt;dyn (::your_module::Trait)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;판 차이&lt;/strong&gt; : 2015 판에서 trait 객체의 첫 번째 경계가 &lt;code&gt;::&lt;/code&gt; 로 시작하는 경로 인 경우 &lt;code&gt;dyn&lt;/code&gt; 은 경로의 일부로 처리됩니다. 이 문제를 해결하기 위해 첫 번째 경로를 괄호 안에 넣을 수 있습니다. 따라서 &lt;code&gt;::your_module::Trait&lt;/code&gt; 특성을 가진 특성 오브젝트를 원하면 &lt;code&gt;dyn (::your_module::Trait)&lt;/code&gt; 로 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d876e32afa65f2d220b1dd922c7a25c124ae5c8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 edition, it is possible to declare trait methods with anonymous parameters (e.g. &lt;code&gt;fn foo(u8)&lt;/code&gt;). This is deprecated and an error as of the 2018 edition. All parameters must have an argument name.</source>
          <target state="translated">&lt;strong&gt;에디션 차이&lt;/strong&gt; : 2015 년 에디션에서는 익명 매개 변수 (예 : &lt;code&gt;fn foo(u8)&lt;/code&gt; )를 사용하여 특성 메소드를 선언 할 수 있습니다 . 이 기능은 더 이상 사용되지 않으며 2018 년판에서 오류가 발생했습니다. 모든 매개 변수에는 인수 이름이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d8a4eb3a8ecd26bd2a8200c1aa407e7c962a47c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 edition, this syntax is valid that is disallowed as of the 2018 edition.</source>
          <target state="translated">&lt;strong&gt;판 차이&lt;/strong&gt; : 2015 판에서이 구문은 2018 판에서 허용되지 않는 것으로 유효합니다.</target>
        </trans-unit>
        <trans-unit id="e6c48e95dbd2c5b344112038b2d6d28be512c6e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: Starting with the 2018 edition, paths for &lt;code&gt;pub(in path)&lt;/code&gt; must start with &lt;code&gt;crate&lt;/code&gt;, &lt;code&gt;self&lt;/code&gt;, or &lt;code&gt;super&lt;/code&gt;. The 2015 edition may also use paths starting with &lt;code&gt;::&lt;/code&gt; or modules from the crate root.</source>
          <target state="translated">&lt;strong&gt;에디션 차이&lt;/strong&gt; : 2018 년판부터 &lt;code&gt;pub(in path)&lt;/code&gt; 는 &lt;code&gt;crate&lt;/code&gt; , &lt;code&gt;self&lt;/code&gt; 또는 &lt;code&gt;super&lt;/code&gt; 로 시작해야합니다 . 2015 년판은 &lt;code&gt;::&lt;/code&gt; 로 시작하는 경로 나 상자 루트의 모듈을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="62a6b70d43483dfe4d5b7b6c6b58326793ee331d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition differences&lt;/strong&gt;: Async blocks are only available beginning with Rust 2018.</source>
          <target state="translated">&lt;strong&gt;에디션 차이점&lt;/strong&gt; : 비동기 블록은 Rust 2018부터 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ffeac211f4d5959ca339c3909c25a46b1449c9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition differences&lt;/strong&gt;: Async functions are only available beginning with Rust 2018.</source>
          <target state="translated">&lt;strong&gt;에디션 차이점&lt;/strong&gt; : 비동기 함수는 Rust 2018부터 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbba24256158782afff4e1bf3667267a636ed2ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition differences&lt;/strong&gt;: Await expressions are only available beginning with Rust 2018.</source>
          <target state="translated">&lt;strong&gt;에디션 차이점&lt;/strong&gt; : Await 표현식은 Rust 2018부터 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bd803d8196215afbdb722ca42ff6863ebfdce05" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Encodings&lt;/strong&gt; - Rust strings are UTF-8, but C strings may use other encodings. If you are using a string from C, you should check its encoding explicitly, rather than just assuming that it is UTF-8 like you can do in Rust.</source>
          <target state="translated">&lt;strong&gt;인코딩&lt;/strong&gt; -녹 문자열은 UTF-8이지만 C 문자열은 다른 인코딩을 사용할 수 있습니다. C의 문자열을 사용하는 경우 Rust에서와 같이 UTF-8이라고 가정하기보다는 인코딩을 명시 적으로 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="c4744b4de56ac84ab4967b9e79393a7382d93137" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Errors&lt;/strong&gt;: If the function returns a &lt;code&gt;Result&lt;/code&gt;, describing the kinds of errors that might occur and what conditions might cause those errors to be returned can be helpful to callers so they can write code to handle the different kinds of errors in different ways.</source>
          <target state="translated">&lt;strong&gt;오류&lt;/strong&gt; : 함수가 &lt;code&gt;Result&lt;/code&gt; 를 반환하는 경우 발생할 수있는 오류 종류와 해당 오류가 반환되는 조건을 설명하면 호출자에게 도움이되므로 다양한 종류의 오류를 다른 방식으로 처리하는 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab2c858e00d5352d65014ede49ecfd4f78f2629f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From C to Rust:&lt;/strong&gt;&lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; represents a borrowed C string; it is what you would use to wrap a raw &lt;code&gt;*const &lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; that you got from a C function. A &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; is guaranteed to be a nul-terminated array of bytes. Once you have a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt;, you can convert it to a Rust &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; if it's valid UTF-8, or lossily convert it by adding replacement characters.</source>
          <target state="translated">&lt;strong&gt;C에서 Rust로 : &lt;/strong&gt;&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt; 은 빌린 C 문자열을 나타냅니다. C 함수에서 얻은 원시 &lt;code&gt;*const &lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; 을 래핑하는 데 사용할 것 입니다. &lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt; 바이트의 NUL 종료 배열이 보장됩니다. 당신은 일단 &lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt; , 당신은 녹로 변환 할 수 있습니다 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 이 유효 UTF-8 인 경우, 또는 lossily 대체 문자를 추가하여 변환합니다.</target>
        </trans-unit>
        <trans-unit id="be0edd96752d258e24714cab9620512785d60bc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From C to Rust:&lt;/strong&gt;&lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; represents a borrowed C string; it is what you would use to wrap a raw &lt;code&gt;*const &lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; that you got from a C function. A &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; is guaranteed to be a nul-terminated array of bytes. Once you have a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt;, you can convert it to a Rust &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; if it's valid UTF-8, or lossily convert it by adding replacement characters.</source>
          <target state="translated">&lt;strong&gt;C에서 Rust로 : &lt;/strong&gt;&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt; 은 빌린 C 문자열을 나타냅니다. C 함수에서 얻은 raw &lt;code&gt;*const &lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; 을 래핑하는 데 사용할 것 입니다. &lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt; 바이트의 NUL 종료 배열이 보장됩니다. 당신은 일단 &lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt; , 당신은 녹로 변환 할 수 있습니다 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 이 유효 UTF-8 인 경우, 또는 lossily 대체 문자를 추가하여 변환합니다.</target>
        </trans-unit>
        <trans-unit id="6a880c7c09fd0c1f69a3098a3095ef95bac0a546" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From Rust to C:&lt;/strong&gt;&lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; represents an owned, C-friendly string: it is nul-terminated, and has no internal nul characters. Rust code can create a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; out of a normal string (provided that the string doesn't have nul characters in the middle), and then use a variety of methods to obtain a raw &lt;code&gt;*mut &lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; that can then be passed as an argument to functions which use the C conventions for strings.</source>
          <target state="translated">&lt;strong&gt;Rust에서 C로 : &lt;/strong&gt;&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; 은 소유되고 C에 친숙한 문자열을 나타냅니다. Null로 끝나고 내부 NUL 문자가 없습니다. 녹 코드는 일반 문자열 에서 &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; 을 생성하고 (문자열에 중간에 널 문자가없는 경우) 다양한 메소드를 사용하여 원시 &lt;code&gt;*mut &lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; 을 얻 습니다. 문자열에 C 규칙을 사용하는 함수</target>
        </trans-unit>
        <trans-unit id="aae173511f045be6a9f0dfcffd69891dd82a8b0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From Rust to C:&lt;/strong&gt;&lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; represents an owned, C-friendly string: it is nul-terminated, and has no internal nul characters. Rust code can create a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; out of a normal string (provided that the string doesn't have nul characters in the middle), and then use a variety of methods to obtain a raw &lt;code&gt;*mut &lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; that can then be passed as an argument to functions which use the C conventions for strings.</source>
          <target state="translated">&lt;strong&gt;Rust에서 C로 : &lt;/strong&gt;&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; 은 소유하고 C 친화적 인 문자열을 나타냅니다. nul로 끝나고 내부 nul 문자가 없습니다. Rust 코드는 일반 문자열 (중간에 nul 문자가없는 경우) 에서 &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; 을 생성 한 다음 다양한 방법을 사용하여 원시 &lt;code&gt;*mut &lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; 을 얻은 다음 인수로 전달할 수 있습니다. 문자열에 대해 C 규칙을 사용하는 함수.</target>
        </trans-unit>
        <trans-unit id="c2238adb64a05e56adbe151507af6c19abcbbbc4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From a Rust string&lt;/strong&gt;: &lt;code&gt;OsString&lt;/code&gt; implements &lt;a href=&quot;../convert/trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;, so you can use &lt;code&gt;my_string.from&lt;/code&gt; to create an &lt;code&gt;OsString&lt;/code&gt; from a normal Rust string.</source>
          <target state="translated">&lt;strong&gt;Rust 문자열에서&lt;/strong&gt; : &lt;code&gt;OsString&lt;/code&gt; 은 &lt;a href=&quot;../convert/trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 을 구현 하므로 &lt;code&gt;my_string.from&lt;/code&gt; 을 사용하여 일반 Rust 문자열에서 &lt;code&gt;OsString&lt;/code&gt; 을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a856fdf688afa04d2bd84181c6260aaef0048cb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From slices:&lt;/strong&gt; Just like you can start with an empty Rust &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and then &lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt;&lt;code&gt;String::push_str&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt; sub-string slices into it, you can create an empty &lt;code&gt;OsString&lt;/code&gt; with the &lt;a href=&quot;struct.osstring#method.new&quot;&gt;&lt;code&gt;OsString::new&lt;/code&gt;&lt;/a&gt; method and then push string slices into it with the &lt;a href=&quot;struct.osstring#method.push&quot;&gt;&lt;code&gt;OsString::push&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;strong&gt;조각에서 :&lt;/strong&gt; 그냥 당신이 시작할 수 있습니다처럼 빈 녹 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 다음 &lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt; &lt;code&gt;String::push_str&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; 그것에 하위 문자열 조각, 당신은 빈 만들 수 있습니다 &lt;code&gt;OsString&lt;/code&gt; 와 &lt;a href=&quot;struct.osstring#method.new&quot;&gt; &lt;code&gt;OsString::new&lt;/code&gt; &lt;/a&gt; 방법을 다음과 그것으로 문자열 조각을 밀어 &lt;a href=&quot;struct.osstring#method.push&quot;&gt; &lt;code&gt;OsString::push&lt;/code&gt; &lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="adfbc9f4c9b7bf87cce69244480b633a8de2c39f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From slices:&lt;/strong&gt; Just like you can start with an empty Rust &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and then &lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt; sub-string slices into it, you can create an empty &lt;code&gt;OsString&lt;/code&gt; with the &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method and then push string slices into it with the &lt;a href=&quot;#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;strong&gt;조각에서 :&lt;/strong&gt; 그냥 당신이 빈 녹 시작할 수와 같은 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 다음과 &lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt; &lt;code&gt;push_str&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; 하위 문자열 조각 그것으로, 당신은 빈 만들 수 있습니다 &lt;code&gt;OsString&lt;/code&gt; 와 &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 방법을 다음과 그것으로 문자열 조각을 밀어 &lt;a href=&quot;#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="5663223157e2b3d6031e4a48c107b41038aa63b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important.&lt;/strong&gt; At least at present, you should avoid using &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; types for functions that are defined in C but invoked from Rust. In those cases, you should directly mirror the C types as closely as possible. Using types like &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; where the C definition is just using &lt;code&gt;T*&lt;/code&gt; can lead to undefined behavior, as described in &lt;a href=&quot;https://github.com/rust-lang/unsafe-code-guidelines/issues/198&quot;&gt;rust-lang/unsafe-code-guidelines#198&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;중대한. &lt;/strong&gt;적어도 현재로서는 C로 정의되었지만 Rust에서 호출되는 함수에 대해 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 유형을 사용하지 않아야합니다 . 이 경우 가능한 한 가깝게 C 유형을 직접 미러링해야합니다. C 정의가 &lt;code&gt;T*&lt;/code&gt; 사용하는 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 와 같은 유형을 사용하면 &lt;a href=&quot;https://github.com/rust-lang/unsafe-code-guidelines/issues/198&quot;&gt;rust-lang / unsafe-code-guidelines # 198에&lt;/a&gt; 설명 된대로 정의되지 않은 동작이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="629ec911ccd79d718629d3b5e11521368319be97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Internal nul characters&lt;/strong&gt; - When C strings have a nul terminator character, this usually means that they cannot have nul characters in the middle &amp;mdash; a nul character would essentially truncate the string. Rust strings &lt;em&gt;can&lt;/em&gt; have nul characters in the middle, because nul does not have to mark the end of the string in Rust.</source>
          <target state="translated">&lt;strong&gt;내부 널 문자&lt;/strong&gt; -C 문자열에 &lt;strong&gt;널&lt;/strong&gt; 종료 문자가있는 경우 일반적으로 중간에 &lt;strong&gt;널 문자&lt;/strong&gt; 를 사용할 수 없음을 의미합니다. 널 문자는 본질적으로 문자열을 자릅니다. Null은 Rust에서 문자열 의 끝을 표시 할 필요가 없기 때문에 Rust 문자열 &lt;em&gt;은&lt;/em&gt; 중간에 널 문자를 가질 &lt;em&gt;수&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="b41d1a37bb22ed7e91444167c781b032f81cc870" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Modules&lt;/strong&gt; and &lt;strong&gt;use:&lt;/strong&gt; Let you control the organization, scope, and privacy of paths</source>
          <target state="translated">&lt;strong&gt;모듈&lt;/strong&gt; 및 &lt;strong&gt;사용 :&lt;/strong&gt; 경로의 조직, 범위 및 개인 정보를 제어 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="41c40dd8ed6820329fca0f856e36989c1fdbd2b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NB.&lt;/strong&gt; The never type was expected to be stabilized in 1.41, but due to some last minute regressions detected the stabilization was temporarily reverted. The &lt;code&gt;!&lt;/code&gt; type can only appear in function return types presently. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/35121&quot;&gt;the tracking issue&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;strong&gt;NB. &lt;/strong&gt;never 유형은 1.41에서 안정화 될 것으로 예상되었지만 마지막 순간 회귀가 감지되어 안정화가 일시적으로 되돌려졌습니다. &lt;code&gt;!&lt;/code&gt; type은 현재 함수 반환 유형에만 나타날 수 있습니다. 자세한 내용 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/35121&quot;&gt;은 추적 문제&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="060d89d923956472cc05e7319b76fa9d50a7e876" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE: The third invariant is currently unenforced due to historical oversight and significant reliance on the behaviour. It is currently undecided what to do about this going forward. Macros that do not respect the behaviour may become invalid in a future edition of Rust. See the &lt;a href=&quot;https://github.com/rust-lang/rust/issues/56575&quot;&gt;tracking issue&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : 세 번째 불변은 현재 역사적 감독과 행동에 대한 상당한 의존으로 인해 시행되지 않습니다. 현재 이것에 대해 어떻게해야할지 결정되지 않았습니다. 동작을 존중하지 않는 매크로는 다음 버전의 Rust에서 유효하지 않을 수 있습니다. &lt;a href=&quot;https://github.com/rust-lang/rust/issues/56575&quot;&gt;추적 문제를&lt;/a&gt; 참조하십시오 .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="379a60c8e2b4b827557b233553a6bc6c82683fa1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: If a parent of the given path doesn't exist, this function will return an error. To create a directory and all its missing parents at the same time, use the &lt;a href=&quot;fn.create_dir_all&quot;&gt;&lt;code&gt;create_dir_all&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 주어진 경로의 부모가 존재하지 않으면이 함수는 오류를 반환합니다. 디렉토리와 누락 된 모든 상위를 동시에 작성하려면 &lt;a href=&quot;fn.create_dir_all&quot;&gt; &lt;code&gt;create_dir_all&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c177380835dd615160771cec4b0171b325482499" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No matter what, Safe Rust can't cause Undefined Behavior&lt;/strong&gt;. This is referred to as &lt;a href=&quot;https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#soundness-of-code--of-a-library&quot;&gt;soundness&lt;/a&gt;: a well-typed program actually has the desired properties. The &lt;a href=&quot;https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html&quot;&gt;Nomicon&lt;/a&gt; has a more detailed explanation on the subject.</source>
          <target state="translated">&lt;strong&gt;어쨌든 Safe Rust는 Undefined Behavior를 일으킬 수 없습니다&lt;/strong&gt; . 이를 &lt;a href=&quot;https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#soundness-of-code--of-a-library&quot;&gt;건전성&lt;/a&gt; 이라고합니다 . 잘 형식화 된 프로그램은 실제로 원하는 속성을 가지고 있습니다. &lt;a href=&quot;https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html&quot;&gt;Nomicon이&lt;/a&gt; 주제에 대한 자세한 설명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6558cd07ee1a59a066bae7f1a7d1d4e7129c19ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: This trait must not fail&lt;/strong&gt;. If the conversion can fail, use &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :이 특성은 실패하지 않아야합니다&lt;/strong&gt; . 변환이 실패하면 &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc7fd5e949a51b13efc359ef4faae3bf584089ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: This trait must not fail&lt;/strong&gt;. If the conversion can fail, use &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :이 특성은 실패하지 않아야합니다&lt;/strong&gt; . 변환이 실패하면 &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5b6ef596678a6ec7ac86f37d73d853ca889a37a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: This trait must not fail&lt;/strong&gt;. If the conversion can fail, use a dedicated method which returns an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :이 특성은 실패하지 않아야합니다&lt;/strong&gt; . 변환이 실패하면 &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 리턴하는 전용 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9f7d81ecf2a6b96e00a858ce77d080e3c485f5c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you need to borrow a string that was allocated by foreign code, use &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt;. If you need to take ownership of a string that was allocated by foreign code, you will need to make your own provisions for freeing it appropriately, likely with the foreign code's API to do that.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 외부 코드로 할당 된 문자열을 빌려야하는 경우 &lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 . 외부 코드에 의해 할당 된 문자열의 소유권을 가져야하는 경우, 외부 코드의 API를 사용하여 적절하게 해제하기위한 자체 규정을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="64f82543ebfb5e0c22f3304371c4e50429156fcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The future type that rustc generates is roughly equivalent to an enum with one variant per &lt;code&gt;await&lt;/code&gt; point, where each variant stores the data needed to resume from its corresponding point.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; rustc가 생성하는 미래 유형은 &lt;code&gt;await&lt;/code&gt; 지점 당 하나의 변형이있는 열거 형과 거의 동일합니다. 여기서 각 변형은 해당 지점에서 재개하는 데 필요한 데이터를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="d2eeefa40f9901be73a381ca76c97ef76a1ea8ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;i16&lt;/code&gt; has an alignment of 2 bytes.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 기능은 &lt;code&gt;i16&lt;/code&gt; 에 2 바이트 정렬이있는 대상에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c2293fd49da6801b825298bc259cec03257c7fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;i32&lt;/code&gt; has an alignment of 4 bytes.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 기능은 &lt;code&gt;i32&lt;/code&gt; 의 정렬이 4 바이트 인 대상에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b262d56cf8e8f408dcc17fe9b8801b4eb3fadab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;i64&lt;/code&gt; has an alignment of 8 bytes.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 기능은 &lt;code&gt;i64&lt;/code&gt; 에 8 바이트 정렬이있는 대상에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16b9eed4ac2d21cb27e6a0debb93f9f3a3bcc5a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;isize&lt;/code&gt; has an alignment of 8 bytes.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 함수는 &lt;code&gt;isize&lt;/code&gt; 가 8 바이트로 정렬 된 대상에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44eefe3185a3db0f5cea7158f26fe463c75dc726" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;u16&lt;/code&gt; has an alignment of 2 bytes.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 기능은 &lt;code&gt;u16&lt;/code&gt; 에 2 바이트 정렬이있는 대상에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb1fea0129a87e0a989b444fe1258f62a320490b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;u32&lt;/code&gt; has an alignment of 4 bytes.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 함수는 &lt;code&gt;u32&lt;/code&gt; 가 4 바이트로 정렬 된 대상에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28e50b005c31c5d32ebfdba7f184b17a96b48b58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;u64&lt;/code&gt; has an alignment of 8 bytes.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 기능은 &lt;code&gt;u64&lt;/code&gt; 에 8 바이트 정렬이있는 대상에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bc61ff9f0824102bc626b9c7cdffa39c424b522" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;usize&lt;/code&gt; has an alignment of 8 bytes.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 기능은 &lt;code&gt;usize&lt;/code&gt; 의 정렬이 8 바이트 인 대상에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7305f68e95514e24a7c95d0883b00ea54e7a5611" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This method is only available on platforms that support atomic operations on &lt;code&gt;u8&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 메서드는 &lt;code&gt;u8&lt;/code&gt; 에서 원자 적 작업을 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f9beca619923587f1e53345a612ee54183accda" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This method is only available on platforms that support atomic operations on pointers.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 메서드는 포인터에 대한 원자 적 연산을 지원하는 플랫폼에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4637566695ac5a54cd62243b48c42f9fc2ba5a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This syntax only adds another restriction to the visibility of an item. It does not guarantee that the item is visible within all parts of the specified scope. To access an item, all of its parent items up to the current scope must still be visible as well.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 구문은 항목의 가시성에 또 다른 제한을 추가합니다. 항목이 지정된 범위의 모든 부분에서 표시된다는 보장은 없습니다. 항목에 액세스하려면 현재 범위까지의 모든 상위 항목도 계속 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="133699edea54cc02f638b728f6d305bf0c4eb4aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 유형은 원자로드 및 &lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; &lt;/a&gt; 저장소를 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24d47c135cd7e9598aabb084d4e238fb2da1f926" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 유형은 원자로드 및 &lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 저장소를 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f12df48c2a5ede4cad5f196c278170c76aa69b27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 유형은 원자로드 및 &lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; 저장소를 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="770d30f50039965c0a80bc18afb0f57006c8ecf7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 유형은 원자로드 및 &lt;a href=&quot;../../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; &lt;/a&gt; 저장소를 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3770fb7d89c845d66075484dac6af6613879c5c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 유형은 원자로드 및 &lt;a href=&quot;../../primitive.isize&quot;&gt; &lt;code&gt;isize&lt;/code&gt; &lt;/a&gt; 저장소를 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb007ca7675d599d0fd1022828e893745c373c65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 유형은 원자로드 및 &lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; 저장을 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3cf286238fb78dad77f34b185f05fcd2ccdeabb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 유형은 원자로드 및 &lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 저장을 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e3460e7cb91ab667e7a2edc5f99bef2b41f79b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 유형은 원자로드 및 &lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; &lt;/a&gt; 저장을 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe0118a9443b5848b0cf822fd3a311a3f6ce113f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 유형은 원자로드 및 &lt;a href=&quot;../../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; 저장을 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de09eea9ef2bf2d098a984258c71927e3c4b2b70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 유형은 원자로드 및 &lt;a href=&quot;../../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; 저장을 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bc278c534e3be01a1f5e2970b2fd676ed81d535" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Uninitialized memory is also implicitly invalid for any type that has a restricted set of valid values. In other words, the only cases in which reading uninitialized memory is permitted are inside &lt;code&gt;union&lt;/code&gt;s and in &quot;padding&quot; (the gaps between the fields/elements of a type).</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 초기화되지 않은 메모리는 유효한 값 집합이 제한된 모든 유형에 대해 암시 적으로 유효하지 않습니다. 즉, 초기화되지 않은 메모리 읽기가 허용되는 유일한 경우는 &lt;code&gt;union&lt;/code&gt; 내부 와 &quot;패딩&quot;(유형의 필드 / 요소 사이의 간격)입니다.</target>
        </trans-unit>
        <trans-unit id="2bb5d63cdf94e5456c6918112042bd1091e5e9f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, function parameters, &lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt; items, and &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt; items must be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;a href=&quot;variables&quot;&gt;변수&lt;/a&gt; , 함수 매개 변수, &lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt; 항목 및 &lt;a href=&quot;items/static-items&quot;&gt;정적&lt;/a&gt; 항목은 &lt;code&gt;Sized&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="1d46ac6d8774740d98a4009a231d2213aeed2a7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;rustc&lt;/code&gt; achieves this with the unstable &lt;code&gt;rustc_layout_scalar_valid_range_*&lt;/code&gt; attributes.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;rustc&lt;/code&gt; 는 불안정한 &lt;code&gt;rustc_layout_scalar_valid_range_*&lt;/code&gt; 속성으로 이것을 달성 합니다.</target>
        </trans-unit>
        <trans-unit id="c50c739d9eb5da5613037181f561652a032953a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Additional crates that ship with &lt;code&gt;rustc&lt;/code&gt;, such as &lt;a href=&quot;https://doc.rust-lang.org/alloc/index.html&quot;&gt;&lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/test/index.html&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt;, are not automatically included with the &lt;code&gt;--extern&lt;/code&gt; flag when using Cargo. They must be brought into scope with an &lt;code&gt;extern crate&lt;/code&gt; declaration, even in the 2018 edition.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;a href=&quot;https://doc.rust-lang.org/alloc/index.html&quot;&gt; &lt;code&gt;alloc&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://doc.rust-lang.org/test/index.html&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt; 와 같이 &lt;code&gt;rustc&lt;/code&gt; 와 함께 제공되는 추가 상자는 Cargo를 사용할 때 &lt;code&gt;--extern&lt;/code&gt; 플래그 와 함께 자동으로 포함되지 않습니다 . 2018 년 버전에서도 &lt;code&gt;extern crate&lt;/code&gt; 선언 을 통해 범위에 포함되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="bf68398fddb94f0a1abd51db31ce0b9347bd8495" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Additional crates that ship with &lt;code&gt;rustc&lt;/code&gt;, such as &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/index.html&quot;&gt;&lt;code&gt;proc_macro&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/alloc/index.html&quot;&gt;&lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/test/index.html&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt;, are not automatically included with the &lt;code&gt;--extern&lt;/code&gt; flag when using Cargo. They must be brought into scope with an &lt;code&gt;extern crate&lt;/code&gt; declaration, even in the 2018 edition.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 함께 제공하는 것이 추가 상자 &lt;code&gt;rustc&lt;/code&gt; 등, &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/index.html&quot;&gt; &lt;code&gt;proc_macro&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://doc.rust-lang.org/alloc/index.html&quot;&gt; &lt;code&gt;alloc&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://doc.rust-lang.org/test/index.html&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt; 자동으로 포함되지 않은 &lt;code&gt;--extern&lt;/code&gt; 화물을 사용하는 경우 플래그. 그것들은 2018 년 판에서도 &lt;code&gt;extern crate&lt;/code&gt; 선언 으로 범위 안에 들어와야합니다.</target>
        </trans-unit>
        <trans-unit id="d2b504e0a31dcf2bae64d03c73c728e13b4132f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Configuration options with the key &lt;code&gt;feature&lt;/code&gt; are a convention used by &lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/features.html&quot;&gt;Cargo&lt;/a&gt; for specifying compile-time options and optional dependencies.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 주요 &lt;code&gt;feature&lt;/code&gt; 이있는 구성 옵션 은 &lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/features.html&quot;&gt;Cargo&lt;/a&gt; 에서 컴파일 시간 옵션 및 선택적 종속성을 지정하는 데 사용하는 규칙 입니다.</target>
        </trans-unit>
        <trans-unit id="f8381d4f5be828c7771e48194e3784bf6556e9d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For &lt;code&gt;rustc&lt;/code&gt;, arbitrary-set configuration options are set using the &lt;a href=&quot;https://doc.rust-lang.org/rustc/command-line-arguments.html#--cfg-configure-the-compilation-environment&quot;&gt;&lt;code&gt;--cfg&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;rustc&lt;/code&gt; 의 경우 임의 설정 구성 옵션은 &lt;a href=&quot;https://doc.rust-lang.org/rustc/command-line-arguments.html#--cfg-configure-the-compilation-environment&quot;&gt; &lt;code&gt;--cfg&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0e534aae954895e78357179a1ac94a40dd8cf86b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For &lt;code&gt;rustc&lt;/code&gt;, arbitrary-set configuration options are set using the &lt;a href=&quot;https://doc.rust-lang.org/rustc/command-line-arguments.html#a--cfg-configure-the-compilation-environment&quot;&gt;&lt;code&gt;--cfg&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;rustc&lt;/code&gt; 의 경우 임의 설정 구성 옵션은 &lt;a href=&quot;https://doc.rust-lang.org/rustc/command-line-arguments.html#a--cfg-configure-the-compilation-environment&quot;&gt; &lt;code&gt;--cfg&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="c424a34ea4d877226958104553992541e3787ae9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: In the past, the Rust community used the terms &quot;Unambiguous Function Call Syntax&quot;, &quot;Universal Function Call Syntax&quot;, or &quot;UFCS&quot;, in documentation, issues, RFCs, and other community writings. However, the term lacks descriptive power and potentially confuses the issue at hand. We mention it here for searchability's sake.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 과거 Rust 커뮤니티는 문서, 문제, RFC 및 기타 커뮤니티 문서에서 &quot;명확한 함수 호출 구문&quot;, &quot;범용 함수 호출 구문&quot;또는 &quot;UFCS&quot;라는 용어를 사용했습니다. 그러나이 용어는 설명력이 부족하여 현재 문제를 혼동 할 수 있습니다. 검색 가능성을 위해 여기에 언급했습니다.</target>
        </trans-unit>
        <trans-unit id="7e4168c7dfa2ff3fb21bdd3b2ee7e059ab5726bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Lifetimes can be, and usually are, elided with this shorthand.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 수명은 일반적으로이 속기로 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bccc13cc797f7b85b663c8c0720dcbb028e2999f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Many pieces of Rust code may assume that pointers, &lt;code&gt;usize&lt;/code&gt;, and &lt;code&gt;isize&lt;/code&gt; are either 32-bit or 64-bit. As a consequence, 16-bit pointer support is limited and may require explicit care and acknowledgment from a library to support.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Rust 코드의 많은 부분은 포인터, &lt;code&gt;usize&lt;/code&gt; 및 &lt;code&gt;isize&lt;/code&gt; 가 32 비트 또는 64 비트 라고 가정 할 수 있습니다 . 결과적으로 16 비트 포인터 지원이 제한되고 지원하려면 라이브러리에서 명시적인주의와 승인이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ee6a6f44b42148913ce05336e8333f03b878a8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: On platforms that do not support receiving spin-loop hints this function does not do anything at all.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 스핀 루프 힌트 수신을 지원하지 않는 플랫폼에서는이 기능이 전혀 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3cd7dc42d46fc1a7eaf8316e86e18b4771b7a37c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Previous to &lt;code&gt;rustc&lt;/code&gt; 1.30, using &lt;code&gt;mod.rs&lt;/code&gt; files was the way to load a module with nested children. It is encouraged to use the new naming convention as it is more consistent, and avoids having many files named &lt;code&gt;mod.rs&lt;/code&gt; within a project.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;rustc&lt;/code&gt; 1.30 이전 버전 에서는 &lt;code&gt;mod.rs&lt;/code&gt; 파일을 사용하여 중첩 된 하위가있는 모듈을로드했습니다. 새로운 이름 지정 규칙을보다 일관성있게 사용하는 것이 &lt;code&gt;mod.rs&lt;/code&gt; 프로젝트 내에 mod.rs 라는 많은 파일이 없어야 합니다.</target>
        </trans-unit>
        <trans-unit id="09dbeb2a0b5b6ab350517ca73457c241b60699f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;cfg_attr&lt;/code&gt; can expand to another &lt;code&gt;cfg_attr&lt;/code&gt;. For example, &lt;code&gt;#[cfg_attr(linux, cfg_attr(feature = &quot;multithreaded&quot;, some_other_attribute))&lt;/code&gt; is valid. This example would be equivalent to &lt;code&gt;#[cfg_attr(all(linux, feature =&quot;multithreaded&quot;), some_other_attribute)]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;주&lt;/strong&gt; : &lt;code&gt;cfg_attr&lt;/code&gt; 은 다른 &lt;code&gt;cfg_attr&lt;/code&gt; 로 확장 될 수 있습니다 . 예를 들어, &lt;code&gt;#[cfg_attr(linux, cfg_attr(feature = &quot;multithreaded&quot;, some_other_attribute))&lt;/code&gt; 가 유효합니다. 이 예제는 &lt;code&gt;#[cfg_attr(all(linux, feature =&quot;multithreaded&quot;), some_other_attribute)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48afce94d3f617db585b69f838ac8fa2fe7c7c45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;cfg_attr&lt;/code&gt; can expand to another &lt;code&gt;cfg_attr&lt;/code&gt;. For example, &lt;code&gt;#[cfg_attr(target_os = &quot;linux&quot;, cfg_attr(feature = &quot;multithreaded&quot;, some_other_attribute))]&lt;/code&gt; is valid. This example would be equivalent to &lt;code&gt;#[cfg_attr(all(target_os = &quot;linux&quot;, feature =&quot;multithreaded&quot;), some_other_attribute)]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;cfg_attr&lt;/code&gt; 은 다른 &lt;code&gt;cfg_attr&lt;/code&gt; 로 확장 할 수 있습니다 . 예를 들어 &lt;code&gt;#[cfg_attr(target_os = &quot;linux&quot;, cfg_attr(feature = &quot;multithreaded&quot;, some_other_attribute))]&lt;/code&gt; 가 유효합니다. 이 예제는 &lt;code&gt;#[cfg_attr(all(target_os = &quot;linux&quot;, feature =&quot;multithreaded&quot;), some_other_attribute)]&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="542e5e434f17a5e7fe96f177447ca260c03e5782" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;rustc&lt;/code&gt; test harness supports the &lt;code&gt;--include-ignored&lt;/code&gt; flag to force ignored tests to be run.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;rustc&lt;/code&gt; 테스트 하네스는 &lt;code&gt;--include-ignored&lt;/code&gt; 플래그를 지원하여 무시 된 테스트를 강제로 실행합니다.</target>
        </trans-unit>
        <trans-unit id="ee8746d1970619c1573d4cba9ddf4d37981ddfcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The LLVM backend of the &lt;code&gt;rustc&lt;/code&gt; implementation aborts the process by executing an illegal instruction.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;rustc&lt;/code&gt; 구현 의 LLVM 백엔드 는 잘못된 명령을 실행하여 프로세스를 중단합니다.</target>
        </trans-unit>
        <trans-unit id="0b6a9b1648330a6c400057a929b0e006d7b0e3f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The exact rules for temporary lifetime extension are subject to change. This is describing the current behavior only.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 임시 평생 연장에 대한 정확한 규칙은 변경 될 수 있습니다. 이것은 현재 동작만을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9663ac595985a9b26dbb960d0c43b0ba63112b12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The tuple index may include an &lt;code&gt;INTEGER_SUFFIX&lt;/code&gt;, but this is not intended to be valid, and may be removed in a future version. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60210&quot;&gt;https://github.com/rust-lang/rust/issues/60210&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 튜플 인덱스에는 &lt;code&gt;INTEGER_SUFFIX&lt;/code&gt; 가 포함될 수 있지만 이는 유효하지 않으며 향후 버전에서 제거 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60210&quot;&gt;https://github.com/rust-lang/rust/issues/60210&lt;/a&gt; 을 참조 하세요 .</target>
        </trans-unit>
        <trans-unit id="2e578eea7529dc499f5ab70e8ee02f1a3a04f7e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This function returns an array of length 2, 4 or 8 bytes depending on the target pointer size.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 함수는 대상 포인터 크기에 따라 길이가 2, 4 또는 8 바이트 인 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="204f556d6eb284d02edf2bf12e7415dff429dcbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This function takes an array of length 2, 4 or 8 bytes depending on the target pointer size.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 함수는 대상 포인터 크기에 따라 길이가 2, 4 또는 8 바이트 인 배열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="205669dd54e34ac0f225ea4e8c1e039e92861b84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is an example note.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 예제는 참고입니다.</target>
        </trans-unit>
        <trans-unit id="4f8175ab0b6ced026c78c226ce62e4e0326a00cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is currently implemented as a 0-cost cast, but it is planned to alter its definition in the future to perform the length calculation whenever this method is called.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 메소드는 현재 0 비용 캐스트로 구현되지만이 메소드가 호출 될 때마다 길이 계산을 수행하도록 나중에 정의를 변경할 계획입니다.</target>
        </trans-unit>
        <trans-unit id="9364ca407d4e4789b372b4d12ec8ebcdd47debe7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is currently implemented as a constant-time cast, but it is planned to alter its definition in the future to perform the length calculation whenever this method is called.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 메소드는 현재 상수 시간 캐스트로 구현되지만이 메소드가 호출 될 때마다 길이 계산을 수행하도록 나중에 정의를 변경할 계획입니다.</target>
        </trans-unit>
        <trans-unit id="9acff81794f805a2a107dfa5d332d79517391aa9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is currently implemented to check for validity after a constant-time cast, but it is planned to alter its definition in the future to perform the length calculation in addition to the UTF-8 check whenever this method is called.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 메소드는 현재 일정 시간 캐스트 후에 유효성을 검사하기 위해 구현되었지만이 메소드가 호출 될 때마다 UTF-8 검사 외에 길이 계산을 수행하도록 나중에 정의를 변경하려고합니다.</target>
        </trans-unit>
        <trans-unit id="77e80de2eb59d874ef66f952f67864f1b6680268" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 방법은 &lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; 에서&lt;/a&gt; 원자 적 작업을 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="416612bbf1909b1aaf73c8e8594ced2ad9b5958a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 방법은 &lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; 에서&lt;/a&gt; 원자 적 작업을 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="798babd1633ffc3445fb72738f51aaf665f2e799" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 방법은 &lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; 에서&lt;/a&gt; 원자 적 작업을 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="969f814fd42a6f3586c98e8e6d74c5e1cf0d998f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 방법은 &lt;a href=&quot;../../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; 에서&lt;/a&gt; 원자 적 작업을 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3a8e7d995f2b7f517cfd0675f44c74f193e4d3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 방법은 &lt;a href=&quot;../../primitive.isize&quot;&gt; &lt;code&gt;isize&lt;/code&gt; 에서&lt;/a&gt; 원자 적 작업을 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a7cf4f75cf7c1494a07e470c8288c8e67f0a8a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 방법은 &lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; 에서&lt;/a&gt; 원자 적 연산을 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="902c1326c59de40d4ee4bf24e303fa8f00886b0f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 방법은 &lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; 에서&lt;/a&gt; 원자 적 연산을 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b49fa7c747b4b2f8fc4c2e1fee0ddd570ecece9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 방법은 &lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; 에서&lt;/a&gt; 원자 적 연산을 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c60105950473e3de294db7b21f197086831cb667" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 방법은 &lt;a href=&quot;../../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; 에서&lt;/a&gt; 원자 적 연산을 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7be6463d1fafa0db1e322e03e3852c3a451379a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 방법은 &lt;a href=&quot;../../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; 에서&lt;/a&gt; 원자 적 작업을 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5c5be5853f961e5512f727adc94106859254411" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This operation is intended to be a 0-cost cast but it is currently implemented with an up-front calculation of the length of the string. This is not guaranteed to always be the case.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 작업은 비용이 0 인 캐스트를 목표로하지만 현재 문자열 길이를 사전 계산하여 구현합니다. 항상 그런 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="669d4b633ce688c467334ac7653c165183f2e3ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This section is incomplete.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 섹션은 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="543aaedbc9a3d7322ce93678b22b0281abf794f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This type is only available on platforms that support atomic loads and stores of &lt;code&gt;u8&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 유형은 원자로드 및 &lt;code&gt;u8&lt;/code&gt; 저장을 지원하는 플랫폼에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="245a6aeba0c030e92193a51c1b871f48d851f54f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This type is only available on platforms that support atomic loads and stores of pointers. Its size depends on the target pointer's size.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 유형은 원자로드 및 포인터 저장을 지원하는 플랫폼에서만 사용할 수 있습니다. 크기는 대상 포인터의 크기에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f5df3103e6447e1ad2ce9490f42afb19650917b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Undefined behavior affects the entire program. For example, calling a function in C that exhibits undefined behavior of C means your entire program contains undefined behaviour that can also affect the Rust code. And vice versa, undefined behavior in Rust can cause adverse affects on code executed by any FFI calls to other languages.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 정의되지 않은 동작은 전체 프로그램에 영향을줍니다. 예를 들어 C에서 정의되지 않은 C 동작을 나타내는 함수를 호출하면 전체 프로그램에 Rust 코드에도 영향을 줄 수있는 정의되지 않은 동작이 포함됩니다. 반대로 Rust에서 정의되지 않은 동작은 다른 언어에 대한 FFI 호출로 실행 된 코드에 부정적인 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b1e7bb136e3f88a33c4a3167dcad6a39cd6165d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Unlike field access expressions, tuple index expressions can be the function operand of a &lt;a href=&quot;call-expr&quot;&gt;call expression&lt;/a&gt; as it cannot be confused with a method call since method names cannot be numbers.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 필드 액세스 식과 달리 튜플 인덱스 식은 메서드 이름이 숫자가 될 수 없으므로 메서드 호출과 혼동 될 수 없으므로 &lt;a href=&quot;call-expr&quot;&gt;호출 식&lt;/a&gt; 의 함수 피연산자가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bf566863d0e6c1f93fa47ff736f9ade81dd38c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: When using Cargo, Procedural macro crates are defined with the &lt;code&gt;proc-macro&lt;/code&gt; key in your manifest:</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :화물을 사용할 때 절차 적 매크로 상자는 매니페스트 의 &lt;code&gt;proc-macro&lt;/code&gt; 키로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="a7f8ef7c18d1ebc911a4b8802c9c294409605f53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Whitespace around the &lt;code&gt;=&lt;/code&gt; is ignored. &lt;code&gt;foo=&quot;bar&quot;&lt;/code&gt; and &lt;code&gt;foo = &quot;bar&quot;&lt;/code&gt; are equivalent configuration options.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;=&lt;/code&gt; 주위의 공백 은 무시됩니다. &lt;code&gt;foo=&quot;bar&quot;&lt;/code&gt; 및 &lt;code&gt;foo = &quot;bar&quot;&lt;/code&gt; 는 동등한 구성 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="c47f0cd1f3859cc5bbc515bae176883c35a2e5e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: that the outer &lt;code&gt;match&lt;/code&gt; is used to ensure that any &lt;a href=&quot;../expressions#temporaries&quot;&gt;temporary values&lt;/a&gt; in &lt;code&gt;iter_expr&lt;/code&gt; don't get dropped before the loop is finished. &lt;code&gt;next&lt;/code&gt; is declared before being assigned because it results in types being inferred correctly more often.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 외부 것을 &lt;code&gt;match&lt;/code&gt; 모든 것을 보장하기 위해 사용되는 &lt;a href=&quot;../expressions#temporaries&quot;&gt;임시 값&lt;/a&gt; 에 &lt;code&gt;iter_expr&lt;/code&gt; 는 루프가 완료되기 전에 떨어되지 않습니다. &lt;code&gt;next&lt;/code&gt; 는 할당되기 전에 선언됩니다. 유형이 더 자주 올바르게 추론되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ca0b8f99436f4b7d93b7e3e4bd936fecc9cacde1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: that the outer &lt;code&gt;match&lt;/code&gt; is used to ensure that any &lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;temporary values&lt;/a&gt; in &lt;code&gt;iter_expr&lt;/code&gt; don't get dropped before the loop is finished. &lt;code&gt;next&lt;/code&gt; is declared before being assigned because it results in types being inferred correctly more often.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 외부 것을 &lt;code&gt;match&lt;/code&gt; 모든 것을 보장하기 위해 사용되는 &lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;임시 값&lt;/a&gt; 에 &lt;code&gt;iter_expr&lt;/code&gt; 는 루프가 완료되기 전에 떨어되지 않습니다. &lt;code&gt;next&lt;/code&gt; 는 타입이 더 정확하게 추론되기 때문에 할당되기 전에 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="3d08b1d0d9771f64d914289f8a909594611ec769" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this list is more restrictive than what you can write in regular constants</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 목록은 일반 상수로 작성할 수있는 것보다 제한적입니다</target>
        </trans-unit>
        <trans-unit id="ff87edb614dc63eb552a33d527babfe470e595e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this module is unstable and is designed in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2504-fix-error.md&quot;&gt;RFC 2504&lt;/a&gt;, and you can learn more about its status in the &lt;a href=&quot;https://github.com/rust-lang/rust/issues/53487&quot;&gt;tracking issue&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 모듈은 불안정하며 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2504-fix-error.md&quot;&gt;RFC 2504&lt;/a&gt; 로 설계되었으며 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/53487&quot;&gt;추적 문제&lt;/a&gt; 에서 상태에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f69af187844f3307c7ac46ebb6a50af4199d0748" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Notes&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="b0d06bb798430870d22a876657b39e78b6fbe0c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nul terminators and implicit string lengths&lt;/strong&gt; - Often, C strings are nul-terminated, i.e., they have a &lt;code&gt;\0&lt;/code&gt; character at the end. The length of a string buffer is not stored, but has to be calculated; to compute the length of a string, C code must manually call a function like &lt;code&gt;strlen()&lt;/code&gt; for &lt;code&gt;char&lt;/code&gt;-based strings, or &lt;code&gt;wcslen()&lt;/code&gt; for &lt;code&gt;wchar_t&lt;/code&gt;-based ones. Those functions return the number of characters in the string excluding the nul terminator, so the buffer length is really &lt;code&gt;len+1&lt;/code&gt; characters. Rust strings don't have a nul terminator; their length is always stored and does not need to be calculated. While in Rust accessing a string's length is a &lt;code&gt;O(1)&lt;/code&gt; operation (because the length is stored); in C it is an &lt;code&gt;O(length)&lt;/code&gt; operation because the length needs to be computed by scanning the string for the nul terminator.</source>
          <target state="translated">&lt;strong&gt;Nul 종결 자 및 암시 적 문자열 길이&lt;/strong&gt; -종종 C 문자열은 nul로 종결됩니다. 즉, 끝에 &lt;code&gt;\0&lt;/code&gt; 문자가 있습니다. 문자열 버퍼의 길이는 저장되지 않지만 계산되어야합니다. 문자열의 길이를 계산하기 위해, C 코드를 수동으로 같은 함수를 호출해야합니다 &lt;code&gt;strlen()&lt;/code&gt; 에 대한 &lt;code&gt;char&lt;/code&gt; 문자열 기반, 또는 &lt;code&gt;wcslen()&lt;/code&gt; 에 대한 &lt;code&gt;wchar_t&lt;/code&gt; 를 기반 것. 이러한 함수는 nul 종결자를 제외한 문자열의 문자 수를 반환하므로 버퍼 길이는 실제로 &lt;code&gt;len+1&lt;/code&gt; 문자입니다. Rust 문자열에는 nul 종결자가 없습니다. 길이는 항상 저장되며 계산할 필요가 없습니다. Rust에서 문자열의 길이에 접근하는 동안 &lt;code&gt;O(1)&lt;/code&gt; 작업 (길이가 저장되기 때문에); C 에서는 길이가 nul 종결 자에 대한 문자열을 스캔하여 계산되어야하므로 &lt;code&gt;O(length)&lt;/code&gt; 연산입니다.</target>
        </trans-unit>
        <trans-unit id="484956955d43e1da5356d63148d3bf3ffefed245" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nul terminators and implicit string lengths&lt;/strong&gt; - Often, C strings are nul-terminated, i.e., they have a &lt;code&gt;\0&lt;/code&gt; character at the end. The length of a string buffer is not stored, but has to be calculated; to compute the length of a string, C code must manually call a function like &lt;code&gt;strlen()&lt;/code&gt; for &lt;code&gt;char&lt;/code&gt;-based strings, or &lt;code&gt;wcslen()&lt;/code&gt; for &lt;code&gt;wchar_t&lt;/code&gt;-based ones. Those functions return the number of characters in the string excluding the nul terminator, so the buffer length is really &lt;code&gt;len+1&lt;/code&gt; characters. Rust strings don't have a nul terminator; their length is always stored and does not need to be calculated. While in Rust accessing a string's length is a O(1) operation (because the length is stored); in C it is an O(length) operation because the length needs to be computed by scanning the string for the nul terminator.</source>
          <target state="translated">&lt;strong&gt;널 종결 자 및 암시 적 문자열 길이&lt;/strong&gt; -종종 C 문자열은 널로 종료됩니다. 즉, 끝에 &lt;code&gt;\0&lt;/code&gt; 문자가 있습니다. 문자열 버퍼의 길이는 저장되지 않지만 계산되어야합니다. 문자열의 길이를 계산하기 위해, C 코드를 수동으로 같은 함수를 호출해야합니다 &lt;code&gt;strlen()&lt;/code&gt; 에 대한 &lt;code&gt;char&lt;/code&gt; 문자열 기반, 또는 &lt;code&gt;wcslen()&lt;/code&gt; 에 대한 &lt;code&gt;wchar_t&lt;/code&gt; 를 기반 것. 이러한 함수는 null 종료자를 제외한 문자열의 문자 수를 반환하므로 버퍼 길이는 실제로 &lt;code&gt;len+1&lt;/code&gt; 입니다.문자. 녹 문자열에는 널 종결자가 없습니다. 길이는 항상 저장되므로 계산할 필요가 없습니다. Rust에서 문자열의 길이에 접근하는 것은 (길이가 저장되어 있기 때문에) O (1) 연산입니다; C에서는 길이가 널 종결 자에 대해 스캔하여 계산되어야하므로 O (길이) 연산입니다.</target>
        </trans-unit>
        <trans-unit id="b3a55015f9b574b249377781d35ad1256b26e09a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Packages:&lt;/strong&gt; A Cargo feature that lets you build, test, and share crates</source>
          <target state="translated">&lt;strong&gt;패키지 :&lt;/strong&gt; 상자를 제작, 테스트 및 공유 할 수있는화물 기능</target>
        </trans-unit>
        <trans-unit id="b9614e48c420558746aa5a195f1ca3514d9bdb89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Panics&lt;/strong&gt;: The scenarios in which the function being documented could panic. Callers of the function who don&amp;rsquo;t want their programs to panic should make sure they don&amp;rsquo;t call the function in these situations.</source>
          <target state="translated">&lt;strong&gt;패닉&lt;/strong&gt; : 문서화되는 기능이 패닉 될 수있는 시나리오. 프로그램을 당황하게하지 않으려는 함수 호출자는 이러한 상황에서 함수를 호출하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="48ddec251d4b93c950c826aa556ff50e924f3f09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Paths:&lt;/strong&gt; A way of naming an item, such as a struct, function, or module</source>
          <target state="translated">&lt;strong&gt;경로 :&lt;/strong&gt; 구조체, 함수 또는 모듈과 같은 항목의 이름을 지정하는 방법</target>
        </trans-unit>
        <trans-unit id="481513e92d2c79e9922e6fdaeaecbe26904d2dbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Safety&lt;/strong&gt;: If the function is &lt;code&gt;unsafe&lt;/code&gt; to call (we discuss unsafety in Chapter 19), there should be a section explaining why the function is unsafe and covering the invariants that the function expects callers to uphold.</source>
          <target state="translated">&lt;strong&gt;안전&lt;/strong&gt; : 함수가 호출하기 에 &lt;code&gt;unsafe&lt;/code&gt; 경우 (19 장의 안전 에 대해 논의), 함수가 안전하지 않은 이유를 설명하고 함수가 호출자가 유지할 것으로 예상되는 불변을 다루는 섹션이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f938faca9bb27bfed4287077e548ce31cbf39365" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stability note:&lt;/strong&gt; This impl does not yet exist, but we are &quot;reserving space&quot; to add it in the future. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/64715&quot;&gt;rust-lang/rust#64715&lt;/a&gt; for details.</source>
          <target state="translated">&lt;strong&gt;안정성 참고 :&lt;/strong&gt; 이 impl은 아직 존재하지 않지만 향후 추가 할 &quot;공간을 예약&quot;하고 있습니다. 자세한 내용은 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/64715&quot;&gt;rust-lang / rust # 64715&lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="7e43e997b28aeec3b9c71554f3cb60497761adcd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Supertraits&lt;/strong&gt; are traits that are required to be implemented for a type to implement a specific trait. Furthermore, anywhere a &lt;a href=&quot;generics&quot;&gt;generic&lt;/a&gt; or &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt; is bounded by a trait, it has access to the associated items of its supertraits.</source>
          <target state="translated">&lt;strong&gt;초&lt;/strong&gt; 특성은 유형이 특정 특성을 구현하기 위해 구현되어야하는 특성입니다. 또한, &lt;a href=&quot;generics&quot;&gt;일반 &lt;/a&gt;&lt;a href=&quot;../types/trait-object&quot;&gt;객체&lt;/a&gt; 또는 특성 객체 가 특성에 의해 구속되는 곳이면, 해당 상위 특성의 관련 항목에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b38548e4d26b2038d4463b0d5471fd35986ae8ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This function is deprecated.&lt;/strong&gt; Use &lt;a href=&quot;union.maybeuninit&quot;&gt;&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;이 기능은 더 이상 사용되지 않습니다. &lt;/strong&gt;사용 &lt;a href=&quot;union.maybeuninit&quot;&gt; &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="8f3ae627337dcbcd948c51fd96893635d151265e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This functon is deprecated.&lt;/strong&gt; Use &lt;a href=&quot;union.maybeuninit&quot;&gt;&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;이 기능은 더 이상 사용되지 않습니다. &lt;/strong&gt;사용 &lt;a href=&quot;union.maybeuninit&quot;&gt; &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="90d5331accb6d1f759b6d533c2ffbb7485074384" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This method is soft-deprecated.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이 방법은 더 이상 사용되지 않습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2492dfd60adc66b908569e7ad4f918b77633047" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Type coercions&lt;/strong&gt; are implicit operations that change the type of a value. They happen automatically at specific locations and are highly restricted in what types actually coerce.</source>
          <target state="translated">&lt;strong&gt;유형 강제 변환&lt;/strong&gt; 은 값의 유형을 변경하는 암시 적 연산입니다. 특정 위치에서 자동으로 발생하며 실제로 강제하는 유형이 매우 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="7cd5055ffa46d984c313532603ca78647862a3d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unix&lt;/strong&gt;: On Unix-like platforms, it is unlikely that all 32 bits of &lt;code&gt;exit&lt;/code&gt; will be visible to a parent process inspecting the exit code. On most Unix-like platforms, only the eight least-significant bits are considered.</source>
          <target state="translated">&lt;strong&gt;유닉스 (Unix)&lt;/strong&gt; : 유닉스 계열의 플랫폼에서는 종료 코드를 검사하는 상위 프로세스가 모든 32 비트 &lt;code&gt;exit&lt;/code&gt; 를 볼 수 없을 것입니다. 대부분의 유닉스 계열 플랫폼에서는 8 개의 최하위 비트 만 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="4c1aa9b3c8e196e8c2b0242b80db4f7600ac8956" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Version &amp;amp; Edition Differences&lt;/strong&gt;: Prior to Rust 1.30, &lt;code&gt;$crate&lt;/code&gt; and &lt;code&gt;local_inner_macros&lt;/code&gt; (below) were unsupported. They were added alongside path-based imports of macros (described above), to ensure that helper macros did not need to be manually imported by users of a macro-exporting crate. Crates written for earlier versions of Rust that use helper macros need to be modified to use &lt;code&gt;$crate&lt;/code&gt; or &lt;code&gt;local_inner_macros&lt;/code&gt; to work well with path-based imports.</source>
          <target state="translated">&lt;strong&gt;버전 및 에디션 차이&lt;/strong&gt; : Rust 1.30 이전에는 &lt;code&gt;$crate&lt;/code&gt; 및 &lt;code&gt;local_inner_macros&lt;/code&gt; (아래)가 지원되지 않았습니다. 매크로 내보내기 상자의 사용자가 도우미 매크로를 수동으로 가져올 필요가 없도록 경로 기반 매크로 가져 오기 (위에서 설명)와 함께 추가되었습니다. 도우미 매크로를 사용하는 이전 버전의 Rust 용으로 작성된 &lt;code&gt;$crate&lt;/code&gt; 는 경로 기반 가져 오기에서 잘 작동 하도록 $ crate 또는 &lt;code&gt;local_inner_macros&lt;/code&gt; 를 사용하도록 수정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a61fe7dcc9b944b7aa4bb3863418ae332c93ffba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;WARNING&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="70d92d3e972f8d8fddf85474fbc20df429ca9e9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: While various forms of this were discussed in &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1937&quot;&gt;RFC #1937&lt;/a&gt;, it was ultimately cut from that RFC, and thus this type is more subject to change even than the usual unstable item churn.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1937&quot;&gt;RFC # 1937&lt;/a&gt; 에서 다양한 형태가 논의되었지만 궁극적으로 RFC에서 제거되었으므로이 유형은 일반적인 불안정한 항목 변동보다 더 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="430cf372e21694405a7f29b4ea7aae36bbc30335" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0a5afaa9ee5bac968c87333877722aa1495b952b" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="488963209bc6867c0591ac82a1cb9c1a6a118fd7" translate="yes" xml:space="preserve">
          <source>A &quot;meta item&quot; is the syntax used for the &lt;em&gt;Attr&lt;/em&gt; rule by most &lt;a href=&quot;#built-in-attributes-index&quot;&gt;built-in attributes&lt;/a&gt;. It has the following grammar:</source>
          <target state="translated">&quot;메타 항목&quot;은 대부분의 &lt;a href=&quot;#built-in-attributes-index&quot;&gt;기본 제공 속성에서 &lt;/a&gt;&lt;em&gt;Attr&lt;/em&gt; 규칙에 사용되는 구문 입니다. 문법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a4ab7f7217b5214e279ea052fb2ed3cfbd58c8f2" translate="yes" xml:space="preserve">
          <source>A &quot;meta item&quot; is the syntax used for the &lt;em&gt;Attr&lt;/em&gt; rule by most &lt;a href=&quot;attributes#built-in-attributes-index&quot;&gt;built-in attributes&lt;/a&gt; and the &lt;a href=&quot;macros-by-example&quot;&gt;&lt;code&gt;meta&lt;/code&gt; macro fragment specifier&lt;/a&gt;. It has the following grammar:</source>
          <target state="translated">&quot;메타 항목&quot;은 대부분의 &lt;a href=&quot;attributes#built-in-attributes-index&quot;&gt;기본 제공 속성&lt;/a&gt; 및 &lt;a href=&quot;macros-by-example&quot;&gt; &lt;code&gt;meta&lt;/code&gt; &lt;/a&gt; 매크로 조각 지정자 에서 &lt;em&gt;Attr&lt;/em&gt; 규칙에 사용되는 구문 입니다. 문법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="22d3a6ec1e16d0b77c16e420bbe8e26c33c2811f" translate="yes" xml:space="preserve">
          <source>A &quot;stack allocated string&quot;:</source>
          <target state="translated">&quot;스택 할당 문자열&quot;:</target>
        </trans-unit>
        <trans-unit id="b64a876ef415d016ec9dc92ffaf76e9ab89ca04f" translate="yes" xml:space="preserve">
          <source>A 'radix' here is sometimes also called a 'base'. A radix of two indicates a binary number, a radix of ten, decimal, and a radix of sixteen, hexadecimal, to give some common values. Arbitrary radices are supported.</source>
          <target state="translated">여기서 '기수'는 때때로 '베이스'라고도합니다. 2의 기수는 2 진 수, 10의 기수, 10 진수 및 16의 16 진 기수를 나타내며 공통 값을 제공합니다. 임의의 기수가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="41c53bc2a64d3e62babdedd9c3047a7e08995ee3" translate="yes" xml:space="preserve">
          <source>A (half-open) range bounded inclusively below and exclusively above (&lt;code&gt;start..end&lt;/code&gt;).</source>
          <target state="translated">(반 개방) 범위는 ( &lt;code&gt;start..end&lt;/code&gt; ) 아래 및 배타적으로 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="e85a39e82a0e6ccf8c895d65c91fa1d7ce99d7cb" translate="yes" xml:space="preserve">
          <source>A 32-bit floating point type (specifically, the &quot;binary32&quot; type defined in IEEE 754-2008).</source>
          <target state="translated">32 비트 부동 소수점 유형 (특히 IEEE 754-2008에 정의 된 &quot;binary32&quot;유형).</target>
        </trans-unit>
        <trans-unit id="10239381d11a9cda1bbf8cfa43daeb6653a356ab" translate="yes" xml:space="preserve">
          <source>A 64-bit floating point type (specifically, the &quot;binary64&quot; type defined in IEEE 754-2008).</source>
          <target state="translated">64 비트 부동 소수점 유형 (특히 IEEE 754-2008에 정의 된 &quot;binary64&quot;유형).</target>
        </trans-unit>
        <trans-unit id="3a791c9e3c1b8c3cb3ad7090a3f0956b3498d4ea" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#infinite-loops&quot;&gt;&lt;code&gt;loop&lt;/code&gt; expression&lt;/a&gt; denotes an infinite loop.</source>
          <target state="translated">&lt;a href=&quot;#infinite-loops&quot;&gt; &lt;code&gt;loop&lt;/code&gt; 발현은&lt;/a&gt; 무한 루프를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="c403143d347d88d290407287e086a1c24df257de" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#iterator-loops&quot;&gt;&lt;code&gt;for&lt;/code&gt; expression&lt;/a&gt; extracts values from an iterator, looping until the iterator is empty.</source>
          <target state="translated">&lt;a href=&quot;#iterator-loops&quot;&gt; &lt;code&gt;for&lt;/code&gt; 표현&lt;/a&gt; 반복자가 빌 때까지 반복 반복자에서 추출 값.</target>
        </trans-unit>
        <trans-unit id="3523931588ba19ab3285934f4c9625ad5b0ff3e8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#predicate-loops&quot;&gt;&lt;code&gt;while&lt;/code&gt; expression&lt;/a&gt; loops until a predicate is false.</source>
          <target state="translated">A는 &lt;a href=&quot;#predicate-loops&quot;&gt; &lt;code&gt;while&lt;/code&gt; 표현&lt;/a&gt; 루프 술어가 거짓이 될 때까지.</target>
        </trans-unit>
        <trans-unit id="43257c2bbdee41f14d8f6aab49394bf581fd3e4e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#predicate-pattern-loops&quot;&gt;&lt;code&gt;while let&lt;/code&gt; expression&lt;/a&gt; tests a pattern.</source>
          <target state="translated">A &lt;a href=&quot;#predicate-pattern-loops&quot;&gt; &lt;code&gt;while let&lt;/code&gt; expression&lt;/a&gt; 은 패턴을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="c1847a494c164bc5812c67ca50bfe2768f6e254d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../expressions/closure-expr&quot;&gt;closure expression&lt;/a&gt; produces a closure value with a unique, anonymous type that cannot be written out. A closure type is approximately equivalent to a struct which contains the captured variables. For instance, the following closure:</source>
          <target state="translated">&lt;a href=&quot;../expressions/closure-expr&quot;&gt;폐쇄 식을&lt;/a&gt; 기입 할 수없는 고유 한 익명 형식으로 폐쇄 값을 생성합니다. 클로저 유형은 캡처 된 변수를 포함하는 구조체와 거의 같습니다. 예를 들어, 다음 클로저 :</target>
        </trans-unit>
        <trans-unit id="3cfb72d2748a10ee8855d86ad887d39ff3f43dfe" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; used as an expression context denotes either a local variable or an item. Path expressions that resolve to local or static variables are &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expressions&lt;/a&gt;, other paths are &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expressions&lt;/a&gt;. Using a &lt;a href=&quot;../items/static-items#mutable-statics&quot;&gt;&lt;code&gt;static mut&lt;/code&gt;&lt;/a&gt; variable requires an &lt;a href=&quot;block-expr#unsafe-blocks&quot;&gt;&lt;code&gt;unsafe&lt;/code&gt; block&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../paths&quot;&gt;클리핑&lt;/a&gt; 식 컨텍스트 나타낸다 로컬 변수 있거나 항목으로서 사용된다. 로컬 또는 정적 변수로 해석되는 경로 표현식은 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;장소 표현식&lt;/a&gt; 이고 다른 경로는 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;값 표현식&lt;/a&gt; 입니다. 사용하여 A &lt;a href=&quot;../items/static-items#mutable-statics&quot;&gt; &lt;code&gt;static mut&lt;/code&gt; &lt;/a&gt; 변수 것은 필요 &lt;a href=&quot;block-expr#unsafe-blocks&quot;&gt; &lt;code&gt;unsafe&lt;/code&gt; 블록&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c135626ccc454eee440ccf3a13f0ec15be919ba" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;, which means that it is a &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Code Point&lt;/a&gt;, but only ones within a certain range. &lt;code&gt;MAX&lt;/code&gt; is the highest valid code point that's a valid &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; A는 &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;유니 코드 스칼라 값&lt;/a&gt; 하는 그것이 있다는 것을 의미, &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;코드 포인트&lt;/a&gt; 하지만, 특정 범위 내에서 유일한 사람. &lt;code&gt;MAX&lt;/code&gt; 는 유효한 &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;유니 코드 스칼라 값인&lt;/a&gt; 가장 높은 유효한 코드 포인트입니다 .</target>
        </trans-unit>
        <trans-unit id="e348847ccb660c7b0b5c01ab1a1ba0e9112a0d13" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;, which means that it is a &lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;Code Point&lt;/a&gt;, but only ones within a certain range. &lt;code&gt;MAX&lt;/code&gt; is the highest valid code point that's a valid &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; A는 &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;유니 코드 스칼라 값&lt;/a&gt; 하는 그것이 있다는 것을 의미, &lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;코드 포인트&lt;/a&gt; 하지만, 특정 범위 내에서 유일한 사람. &lt;code&gt;MAX&lt;/code&gt; 는 유효한 &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value 인&lt;/a&gt; 가장 높은 유효한 코드 포인트입니다 .</target>
        </trans-unit>
        <trans-unit id="cc3502c112d8c240016de6db9fd46c1abe533f18" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; without structural pinning could &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Vec&amp;lt;T&amp;gt;&lt;/code&gt;, because the contents are never pinned and the &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; itself is fine with being moved as well. At that point pinning just has no effect on the vector at all.</source>
          <target state="translated">&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 구조적 피닝 수없는 &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Vec&amp;lt;T&amp;gt;&lt;/code&gt; 상기 내용은 고정되지 않으며 결코 때문에 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 그 자체가 아니라, 함께 이동되는 미세하다. 이 시점에서 고정은 벡터에 전혀 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3bd0f4f45a9992b5e83d00a801ad1d124dd353bf" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;enum.searchstep#variant.Match&quot;&gt;&lt;code&gt;Match&lt;/code&gt;&lt;/a&gt; result needs to contain the whole matched pattern, however &lt;a href=&quot;enum.searchstep#variant.Reject&quot;&gt;&lt;code&gt;Reject&lt;/code&gt;&lt;/a&gt; results may be split up into arbitrary many adjacent fragments. Both ranges may have zero length.</source>
          <target state="translated">&lt;a href=&quot;enum.searchstep#variant.Match&quot;&gt; &lt;code&gt;Match&lt;/code&gt; &lt;/a&gt; 결과 그러나, 전체 매칭 패턴을 포함 할 필요가 &lt;a href=&quot;enum.searchstep#variant.Reject&quot;&gt; &lt;code&gt;Reject&lt;/code&gt; &lt;/a&gt; 결과는 임의의 다수의 인접한 조각으로 분할 될 수있다. 두 범위 모두 길이가 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="817aefb1123a860203996fe1bc087199cf9a9301" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;fn.null&quot;&gt;null&lt;/a&gt; pointer is &lt;em&gt;never&lt;/em&gt; valid, not even for accesses of &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;size zero&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fn.null&quot;&gt;널&lt;/a&gt; 포인터는 &lt;em&gt;결코&lt;/em&gt; 조차의 액세스에 대한 유효한 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;크기 제로&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64470c49d997c71e612fbbb1108517461ba5028e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;items/associated-items#methods&quot;&gt;method&lt;/a&gt; defined in an &lt;a href=&quot;items/implementations#inherent-implementations&quot;&gt;inherent implementation&lt;/a&gt;, not in a trait implementation.</source>
          <target state="translated">&lt;a href=&quot;items/associated-items#methods&quot;&gt;방법은&lt;/a&gt; 에 정의 된 &lt;a href=&quot;items/implementations#inherent-implementations&quot;&gt;고유 구현&lt;/a&gt; 하지 않는 특성 구현에.</target>
        </trans-unit>
        <trans-unit id="2929c70726dc937049a9f5950f13c4723ad1c193" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;loop-expr#infinite-loops&quot;&gt;&lt;code&gt;loop&lt;/code&gt; expression&lt;/a&gt; denotes an infinite loop.</source>
          <target state="translated">&lt;a href=&quot;loop-expr#infinite-loops&quot;&gt; &lt;code&gt;loop&lt;/code&gt; 발현은&lt;/a&gt; 무한 루프를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="e86e93a58bbbbc71c44b9b885a659ff826ce9490" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;loop-expr#iterator-loops&quot;&gt;&lt;code&gt;for&lt;/code&gt; expression&lt;/a&gt; extracts values from an iterator, looping until the iterator is empty.</source>
          <target state="translated">&lt;a href=&quot;loop-expr#iterator-loops&quot;&gt; &lt;code&gt;for&lt;/code&gt; 표현&lt;/a&gt; 반복자가 빌 때까지 반복 반복자에서 추출 값.</target>
        </trans-unit>
        <trans-unit id="78d2df8a50ce969bca66a5211eeeb6570b3f1784" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;loop-expr#predicate-loops&quot;&gt;&lt;code&gt;while&lt;/code&gt; expression&lt;/a&gt; loops until a predicate is false.</source>
          <target state="translated">A는 &lt;a href=&quot;loop-expr#predicate-loops&quot;&gt; &lt;code&gt;while&lt;/code&gt; 표현&lt;/a&gt; 루프 술어가 거짓이 될 때까지.</target>
        </trans-unit>
        <trans-unit id="506fd8c66fe2c3330ab3ababc69a27680d58db08" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;loop-expr#predicate-pattern-loops&quot;&gt;&lt;code&gt;while let&lt;/code&gt; expression&lt;/a&gt; tests a pattern.</source>
          <target state="translated">&lt;a href=&quot;loop-expr#predicate-pattern-loops&quot;&gt; &lt;code&gt;while let&lt;/code&gt; 표현&lt;/a&gt; 패턴을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="33cacd9cafdfaf3ef4cf01b5b7dfb994c4cd9727" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;patterns#struct-patterns&quot;&gt;struct&lt;/a&gt;, &lt;a href=&quot;patterns#tuple-patterns&quot;&gt;tuple&lt;/a&gt;, &lt;a href=&quot;patterns#tuple-struct-patterns&quot;&gt;tuple struct&lt;/a&gt;, or &lt;a href=&quot;patterns#slice-patterns&quot;&gt;slice&lt;/a&gt; pattern where at least one of the direct subpatterns is a extending pattern.</source>
          <target state="translated">&lt;a href=&quot;patterns#struct-patterns&quot;&gt;구조체&lt;/a&gt; , &lt;a href=&quot;patterns#tuple-patterns&quot;&gt;튜플&lt;/a&gt; , &lt;a href=&quot;patterns#tuple-struct-patterns&quot;&gt;튜플 구조체&lt;/a&gt; 또는 &lt;a href=&quot;patterns#slice-patterns&quot;&gt;슬라이스&lt;/a&gt; 직접 서브 패턴 중 적어도 하나는 연장 패턴 패턴.</target>
        </trans-unit>
        <trans-unit id="8b1f2559cf32a60aeffbe295d8dcc8b7d2d1bc74" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; might contain non-Unicode data. This &lt;code&gt;struct&lt;/code&gt; implements the &lt;a href=&quot;../fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait in a way that mitigates that. It is created by the &lt;a href=&quot;struct.path#method.display&quot;&gt;&lt;code&gt;display&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 유니 코드가 아닌 데이터를 포함 할 수 있습니다. 이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; 특성을 완화하는 방식으로 구현합니다 . &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.path#method.display&quot;&gt; &lt;code&gt;display&lt;/code&gt; &lt;/a&gt; 방법으로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="8ad6cb9fb2de3ff94c9692c27c57c7195ec6d6cb" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; ensures that the pointee of any pointer type &lt;code&gt;P&lt;/code&gt; has a stable location in memory, meaning it cannot be moved elsewhere and its memory cannot be deallocated until it gets dropped. We say that the pointee is &quot;pinned&quot;.</source>
          <target state="translated">&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt; 모든 포인터 타입의 pointee되도록 &lt;code&gt;P&lt;/code&gt; 가 다른 곳으로 이동 될 수없고 떨어 때까지 메모리가 해제 될 수없는 것을 의미 메모리 안정된 위치에있다. 우리는 그 포인트가 고정되어 있다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="a15e8cc8aa6158fcb3389cfdaf6e7e84bacae80c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.syncsender&quot;&gt;&lt;code&gt;SyncSender&lt;/code&gt;&lt;/a&gt; is used to send data to a &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt;. Both senders are clone-able (multi-producer) such that many threads can send simultaneously to one receiver (single-consumer).</source>
          <target state="translated">&lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.syncsender&quot;&gt; &lt;code&gt;SyncSender&lt;/code&gt; 는&lt;/a&gt; (A)에 데이터를 전송하는 데 사용되는 &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; . 두 발신자 모두 복제 가능 (다중 생산자)이므로 많은 스레드가 한 수신자 (단일 소비자)에게 동시에 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e878b6c48911644ea2ee908e204d14d9ba8414f3" translate="yes" xml:space="preserve">
          <source>A &lt;code id=&quot;a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread&quot;&gt;Worker&lt;/code&gt; Struct Responsible for Sending Code from the &lt;code&gt;ThreadPool&lt;/code&gt; to a Thread</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; 에서 스레드 로 코드를 보내는 책임이 있는 &lt;code id=&quot;a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread&quot;&gt;Worker&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f340f8a1c0de4fb7863ae5c6dacd93b470ac42d8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;!&lt;/code&gt; (all values are invalid for this type).</source>
          <target state="translated">A &lt;code&gt;!&lt;/code&gt; (이 유형에는 모든 값이 유효하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="cb1329292e0705741bc6efb49bebc4980736dafb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#![feature]&lt;/code&gt; attribute was declared for a feature that is stable in the current edition, but not in all editions.</source>
          <target state="translated">&lt;code&gt;#![feature]&lt;/code&gt; 속성이 있지만 모든 버전에서 현재 버전에서 안정 기능에 대한 선언했다.</target>
        </trans-unit>
        <trans-unit id="aaa8a708af81269c0b5576d02729333db199fa1d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#![feature]&lt;/code&gt; attribute was declared multiple times.</source>
          <target state="translated">&lt;code&gt;#![feature]&lt;/code&gt; 속성은 여러 번 선언했다.</target>
        </trans-unit>
        <trans-unit id="871ef5c0f72000286445ffa6aeaeb13201eef94a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#[lang = &quot;..&quot;]&lt;/code&gt; attribute was placed on the wrong item type.</source>
          <target state="translated">&lt;code&gt;#[lang = &quot;..&quot;]&lt;/code&gt; 속성 잘못된 항목 유형에 넣었다.</target>
        </trans-unit>
        <trans-unit id="12a617fa960129a71a59055ffc0553333e4d1938" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#[marker]&lt;/code&gt; trait contained an associated item.</source>
          <target state="translated">&lt;code&gt;#[marker]&lt;/code&gt; 특성은 연관된 항목을 포함 하였다.</target>
        </trans-unit>
        <trans-unit id="9dfceb8cd31c1c51915cc559ef8cce0d369c7062" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#[repr(..)]&lt;/code&gt; attribute was placed on an unsupported item.</source>
          <target state="translated">&lt;code&gt;#[repr(..)]&lt;/code&gt; 속성은 지원되지 않는 항목에 넣었다.</target>
        </trans-unit>
        <trans-unit id="0a9d6b916ce0da508f854e05a1feec7e0befaef9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#[repr(inttype)]&lt;/code&gt; must be provided on an &lt;code&gt;enum&lt;/code&gt; if it has a non-unit variant with a discriminant, or where there are both unit variants with discriminants and non-unit variants. This restriction ensures that there is a well-defined way to extract a variant's discriminant from a value; for instance:</source>
          <target state="translated">&lt;code&gt;#[repr(inttype)]&lt;/code&gt; 온 제공해야 &lt;code&gt;enum&lt;/code&gt; 그것이 판별 가진 비 단위 변형이있는 경우, 또는이 두 곳 유닛 판별 식 및 비 변형 부 변이체. 이 제한은 값에서 변형의 판별 변수를 추출하는 잘 정의 된 방법을 보장합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="b12f48dd90abc9841d426a5fab9c2ec4ff61214a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#[simd]&lt;/code&gt; attribute was applied to an empty tuple struct.</source>
          <target state="translated">&lt;code&gt;#[simd]&lt;/code&gt; 속성 튜플 빈 구조체에 적용 하였다.</target>
        </trans-unit>
        <trans-unit id="c012898141fc2cec018c7c222ae43346e5dd5f44" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;T&lt;/code&gt; reference can be released to safe code and there it can co-exist with other &lt;code&gt;&amp;amp;T&lt;/code&gt; references, but not with a &lt;code&gt;&amp;amp;mut T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;amp;T&lt;/code&gt; 참조 안전 코드에 출시 될 수 있으며이 공존 할 수있는 다른과 &lt;code&gt;&amp;amp;T&lt;/code&gt; 아니지만과, 참고 문헌 &lt;code&gt;&amp;amp;mut T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ec5710ef1f0b84eb29b3c1cc1f924e822fb56fa" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference may be released to safe code provided neither other &lt;code&gt;&amp;amp;mut T&lt;/code&gt; nor &lt;code&gt;&amp;amp;T&lt;/code&gt; co-exist with it. A &lt;code&gt;&amp;amp;mut T&lt;/code&gt; must always be unique.</source>
          <target state="translated">&lt;code&gt;&amp;amp;mut T&lt;/code&gt; 기준은 어느 다른 제공된 안전한 코드로 방출 될 수있다 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 나 &lt;code&gt;&amp;amp;T&lt;/code&gt; 그것과 공존. &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 항상 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="40585fc29df20c1219babfcdddcfc95974719e32" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;str&lt;/code&gt; is made up of two components: a pointer to some bytes, and a length. You can look at these with the &lt;a href=&quot;#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; methods:</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; 몇 바이트에 대한 포인터와 길이 : 두 가지 구성 요소로 구성되어 있습니다. &lt;a href=&quot;#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 이를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96eae277d841da5acce951109ccad7e43958c9c5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;str&lt;/code&gt; is made up of two components: a pointer to some bytes, and a length. You can look at these with the &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; methods:</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; 몇 바이트에 대한 포인터와 길이 : 두 가지 구성 요소로 구성되어 있습니다. &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 이를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d26915dade1d3ce3c223fcfcc944e12fb9d06d42" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BarrierWaitResult&lt;/code&gt; is returned by &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;Barrier::wait()&lt;/code&gt;&lt;/a&gt; when all threads in the &lt;a href=&quot;struct.barrier&quot;&gt;&lt;code&gt;Barrier&lt;/code&gt;&lt;/a&gt; have rendezvoused.</source>
          <target state="translated">&lt;code&gt;BarrierWaitResult&lt;/code&gt; 은 에 의해 반환되는 &lt;a href=&quot;struct.barrier#method.wait&quot;&gt; &lt;code&gt;Barrier::wait()&lt;/code&gt; &lt;/a&gt; 의 모든 스레드 때 &lt;a href=&quot;struct.barrier&quot;&gt; &lt;code&gt;Barrier&lt;/code&gt; &lt;/a&gt; 랑데부했다.</target>
        </trans-unit>
        <trans-unit id="35fb8d8640dfbea523c47310a34e3d854229d236" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BarrierWaitResult&lt;/code&gt; is returned by &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; when all threads in the &lt;a href=&quot;struct.barrier&quot;&gt;&lt;code&gt;Barrier&lt;/code&gt;&lt;/a&gt; have rendezvoused.</source>
          <target state="translated">&lt;code&gt;BarrierWaitResult&lt;/code&gt; 은 에 의해 반환되는 &lt;a href=&quot;struct.barrier#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 의 모든 스레드 때 &lt;a href=&quot;struct.barrier&quot;&gt; &lt;code&gt;Barrier&lt;/code&gt; &lt;/a&gt; 랑데부했다.</target>
        </trans-unit>
        <trans-unit id="a33fe1ab5786729bf200982553a4a40b28677c12" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BufRead&lt;/code&gt; is a type of &lt;code&gt;Read&lt;/code&gt;er which has an internal buffer, allowing it to perform extra ways of reading.</source>
          <target state="translated">&lt;code&gt;BufRead&lt;/code&gt; 은 의 유형입니다 &lt;code&gt;Read&lt;/code&gt; 는 읽기의 추가 방법을 수행 할 수 있도록, 내부 버퍼를 가지고 어.</target>
        </trans-unit>
        <trans-unit id="c2a7d564e1881467808b1da26fc7f621d550ac35" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BuildHasher&lt;/code&gt; is typically used (e.g., by &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;) to create &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;s for each key such that they are hashed independently of one another, since &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;s contain state.</source>
          <target state="translated">&lt;code&gt;BuildHasher&lt;/code&gt; 는 일반적으로 (기준, 예를 들어 사용 &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 만들) &lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; 때문에, 그들은 서로 독립적으로 해싱하는 각 키에 대한 예들 &lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; 들 상태를 포함한다.</target>
        </trans-unit>
        <trans-unit id="5ac6d9ca4b25b818aa6f9cb17715ea50c25bf2ef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CString&lt;/code&gt; is created from either a byte slice or a byte vector, or anything that implements &lt;a href=&quot;../convert/trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (for example, you can build a &lt;code&gt;CString&lt;/code&gt; straight out of a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;, since both implement that trait).</source>
          <target state="translated">&lt;code&gt;CString&lt;/code&gt; 을은 바이트 슬라이스 또는 바이트 벡터, 또는 아무것도 중 하나에서 생성되는 구현 &lt;a href=&quot;../convert/trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (예를 들어, 당신이 만들 수 &lt;code&gt;CString&lt;/code&gt; 을을 똑바로 밖으로의 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 모두 그 특성을 구현하기 때문에,).</target>
        </trans-unit>
        <trans-unit id="a976b86b7133ebd168dd44069ca430099fb11fcd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CString&lt;/code&gt; is created from either a byte slice or a byte vector, or anything that implements &lt;a href=&quot;../convert/trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (for example, you can build a &lt;code&gt;CString&lt;/code&gt; straight out of a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;, since both implement that trait).</source>
          <target state="translated">&lt;code&gt;CString&lt;/code&gt; 을은 바이트 슬라이스 또는 바이트 벡터, 또는 아무것도 중 하나에서 생성되는 구현 &lt;a href=&quot;../convert/trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (예를 들어, 당신이 만들 수 &lt;code&gt;CString&lt;/code&gt; 을을 똑바로 밖으로의 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 모두 그 특성을 구현하기 때문에,).</target>
        </trans-unit>
        <trans-unit id="bef22157720da42f049eda44831ae9039ff96672" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Component&lt;/code&gt; roughly corresponds to a substring between path separators (&lt;code&gt;/&lt;/code&gt; or ).</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; 대략 경로 분리기 (문자열 사이에 상당 &lt;code&gt;/&lt;/code&gt; OR).</target>
        </trans-unit>
        <trans-unit id="00d5a6a3fb8d035432bd26a66264da1cd9fcfcb1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Component&lt;/code&gt; roughly corresponds to a substring between path separators (&lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; 대략 경로 분리기 사이에 해당하는 문자열 ( &lt;code&gt;/&lt;/code&gt; 또는 &lt;code&gt;\&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f8dc93d165313d1d53fe035b20236e511c258009" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Cursor&lt;/code&gt; is like an iterator, except that it can freely seek back-and-forth, and can safely mutate the list during iteration. This is because the lifetime of its yielded references is tied to its own lifetime, instead of just the underlying list. This means cursors cannot yield multiple elements at once.</source>
          <target state="translated">&lt;code&gt;Cursor&lt;/code&gt; 자유롭게 앞뒤로 추구 할 수 있고, 안전하게 반복하는 동안 목록을 돌연변이 수를 제외하고, 반복자 같다. 이는 생성 된 참조의 수명이 기본 목록이 아닌 자체 수명에 연결되어 있기 때문입니다. 이는 커서가 한 번에 여러 요소를 생성 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d1edbc893c845d675ae565c5adc4b48af73fbd0b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Cursor&lt;/code&gt; is like an iterator, except that it can freely seek back-and-forth.</source>
          <target state="translated">&lt;code&gt;Cursor&lt;/code&gt; 자유롭게 앞뒤로 추구 할 수 제외하고, 반복자 같다.</target>
        </trans-unit>
        <trans-unit id="592f6bf36d948cda2dbd34364696113591fa1887" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Cursor&lt;/code&gt; wraps an in-memory buffer and provides it with a &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">&lt;code&gt;Cursor&lt;/code&gt; 메모리 내 버퍼 랩과 함께 제공 &lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt; 구현.</target>
        </trans-unit>
        <trans-unit id="a89cb140638fa3cd771cb02496374d776ad6d007" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Duration&lt;/code&gt; type to represent a span of time, typically used for system timeouts.</source>
          <target state="translated">&lt;code&gt;Duration&lt;/code&gt; 유형은 일반적으로 시스템 시간 제한에 사용되는 시간의 범위를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e39d340a59cb5b2bb2e11548f7d50ffd50cdcaa5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Formatter&lt;/code&gt; represents various options related to formatting. Users do not construct &lt;code&gt;Formatter&lt;/code&gt;s directly; a mutable reference to one is passed to the &lt;code&gt;fmt&lt;/code&gt; method of all formatting traits, like &lt;a href=&quot;trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Formatter&lt;/code&gt; 포맷과 관련된 다양한 옵션을 의미합니다. 사용자는 &lt;code&gt;Formatter&lt;/code&gt; 를 직접 구성하지 않습니다 . 하나에 대한 변경 가능한 참조는 &lt;a href=&quot;trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; 와 같은 모든 형식화 특성 의 &lt;code&gt;fmt&lt;/code&gt; 메소드로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="921821ce37ee7be55d1f4cd9ec14a09989a7422f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HashMap&lt;/code&gt; with fixed list of elements can be initialized from an array:</source>
          <target state="translated">고정 요소 목록이 있는 &lt;code&gt;HashMap&lt;/code&gt; 은 배열에서 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e3e7578434780dbd4d9d999f38a9955ea8f8204" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HashSet&lt;/code&gt; with fixed list of elements can be initialized from an array:</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 의 요소 고정리스트가 배열에서 초기화 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="9b7c01af6b5011fee801753cdfcb67030ddd18ba" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;JoinHandle&lt;/code&gt;&lt;em&gt;detaches&lt;/em&gt; the associated thread when it is dropped, which means that there is no longer any handle to thread and no way to &lt;code&gt;join&lt;/code&gt; on it.</source>
          <target state="translated">&lt;code&gt;JoinHandle&lt;/code&gt; 는&lt;em&gt;분리&lt;/em&gt; 가 더 이상 스레드 어떤 핸들 할 수있는 방법이 있다고하는 수단 제거 될 때 관련 스레드 &lt;code&gt;join&lt;/code&gt; 거기에있다.</target>
        </trans-unit>
        <trans-unit id="134a2452be93d4c2cdb1b9f1f0542b4b65ecae3d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;LocalKey&lt;/code&gt;'s initializer cannot recursively depend on itself, and using a &lt;code&gt;LocalKey&lt;/code&gt; in this way will cause the initializer to infinitely recurse on the first call to &lt;code&gt;with&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LocalKey&lt;/code&gt; 의 초기화는 재귀 자체에 의존하지 수 있으며, 사용 &lt;code&gt;LocalKey&lt;/code&gt; 을 이런 식으로하는 최초의 호출에 무한 같이 Recurse에 초기화 원인이됩니다 &lt;code&gt;with&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c72c40c2b2da09870992c3f25ebf2fd884c3cef5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Match&lt;/code&gt; result needs to contain the whole matched pattern, however &lt;code&gt;Reject&lt;/code&gt; results may be split up into arbitrary many adjacent fragments. Both ranges may have zero length.</source>
          <target state="translated">&lt;code&gt;Match&lt;/code&gt; 결과 그러나, 전체 매칭 패턴을 포함 할 필요가 &lt;code&gt;Reject&lt;/code&gt; 결과는 임의의 다수의 인접한 조각으로 분할 될 수있다. 두 범위 모두 길이가 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14d52da7769e774ed02f1e53e420687489f136bc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; expresses that the implementing type can be used as a string pattern for searching in a &lt;a href=&quot;../../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;'a str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; 표현하는 형태가 구현에 검색하는 문자열 패턴으로서 사용될 수 &lt;a href=&quot;../../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;'a str&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5668f2d21fa477474ed4b8f6c89c068e50ff97ac" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; expresses that the implementing type can be used as a string pattern for searching in a &lt;code&gt;&amp;amp;'a str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; 표현하는 형태가 구현에 검색하는 문자열 패턴으로서 사용될 수 &lt;code&gt;&amp;amp;'a str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb85096bf6f841f9bc42b20ab21fbdaddee5e86c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RawWaker&lt;/code&gt; allows the implementor of a task executor to create a &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; which provides customized wakeup behavior.</source>
          <target state="translated">&lt;code&gt;RawWaker&lt;/code&gt; 는 만들기 위해 작업 실행의 구현을 허용 &lt;a href=&quot;struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; 사용자 정의 웨이크 업 동작을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1193137c297d5cbd26cbbc2bf90d52838e50813a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; can grow in size and its contents can change, just like the contents of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, if you push more data into it. In addition, you can conveniently use the &lt;code&gt;+&lt;/code&gt; operator or the &lt;code&gt;format!&lt;/code&gt; macro to concatenate &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 단지의 내용처럼, 크기가 증가 할 수 있으며 그 내용을 변경할 수 있습니다 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , 당신은 더 많은 데이터를 밀어 경우에. 또한 &lt;code&gt;+&lt;/code&gt; 연산자 또는 &lt;code&gt;format!&lt;/code&gt; 편리하게 사용할 수 있습니다 ! &lt;code&gt;String&lt;/code&gt; 값 을 연결하는 매크로 입니다.</target>
        </trans-unit>
        <trans-unit id="ad2a4c35b866459c9366f5bbd3c6f621ece58985" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is a wrapper over a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;. Let&amp;rsquo;s look at some of our properly encoded UTF-8 example strings from Listing 8-14. First, this one:</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 이상 래퍼입니다 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; . Listing 8-14에서 올바르게 인코딩 된 UTF-8 예제 문자열 중 일부를 살펴 보자. 첫째, 이것은 :</target>
        </trans-unit>
        <trans-unit id="dcd60f52764dfb12603585382f304c29b3d891eb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is made up of three components: a pointer to some bytes, a length, and a capacity. The pointer points to an internal buffer &lt;code&gt;String&lt;/code&gt; uses to store its data. The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 일부 바이트 길이 및 용량에 대한 포인터 : 세 가지 구성 요소로 구성되어 있습니다. 포인터 는 &lt;code&gt;String&lt;/code&gt; 이 데이터를 저장하는 데 사용 하는 내부 버퍼를 가리 킵니다 . 길이는 현재 버퍼에 저장된 바이트 수이고 용량은 버퍼 크기 (바이트)입니다. 따라서 길이는 항상 용량보다 작거나 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ad19c9717a97c44c08a93976b602e0990d24669" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SystemTimeError&lt;/code&gt; is returned from the &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt;&lt;code&gt;SystemTime::duration_since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt;&lt;code&gt;SystemTime::elapsed&lt;/code&gt;&lt;/a&gt; methods whenever the second system time represents a point later in time than the &lt;code&gt;self&lt;/code&gt; of the method call.</source>
          <target state="translated">&lt;code&gt;SystemTimeError&lt;/code&gt; 는 로부터 반환 &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt; &lt;code&gt;SystemTime::duration_since&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt; &lt;code&gt;SystemTime::elapsed&lt;/code&gt; &lt;/a&gt; 번째 시스템보다 시간이 시간 이후 지점을 나타내는 방법마다 &lt;code&gt;self&lt;/code&gt; 메소드 호출한다.</target>
        </trans-unit>
        <trans-unit id="2815fef167ebe8b526c9b5e3287501b1039ea114" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SystemTimeError&lt;/code&gt; is returned from the &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt;&lt;code&gt;duration_since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt;&lt;code&gt;elapsed&lt;/code&gt;&lt;/a&gt; methods of &lt;a href=&quot;struct.systemtime&quot;&gt;&lt;code&gt;SystemTime&lt;/code&gt;&lt;/a&gt; whenever the second system time represents a point later in time than the &lt;code&gt;self&lt;/code&gt; of the method call.</source>
          <target state="translated">&lt;code&gt;SystemTimeError&lt;/code&gt; 는 로부터 반환 &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt; &lt;code&gt;duration_since&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt; &lt;code&gt;elapsed&lt;/code&gt; &lt;/a&gt; 방법 &lt;a href=&quot;struct.systemtime&quot;&gt; &lt;code&gt;SystemTime&lt;/code&gt; &lt;/a&gt; 번째 시스템보다 시간이 시간 이후 지점을 나타내고마다 &lt;code&gt;self&lt;/code&gt; 메소드 호출한다.</target>
        </trans-unit>
        <trans-unit id="f0e9bc60c4e3276e60ae09f7f961f64e01c5bfbd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ThreadId&lt;/code&gt; is an opaque object that has a unique value for each thread that creates one. &lt;code&gt;ThreadId&lt;/code&gt;s are not guaranteed to correspond to a thread's system-designated identifier. A &lt;code&gt;ThreadId&lt;/code&gt; can be retrieved from the &lt;a href=&quot;struct.thread#method.id&quot;&gt;&lt;code&gt;id&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ThreadId&lt;/code&gt; 는 하나를 생성 스레드마다 고유 한 값을 갖는 불투명 한 객체이다. &lt;code&gt;ThreadId&lt;/code&gt; 는 스레드의 시스템 지정 식별자에 해당하는 것은 아닙니다. &lt;code&gt;ThreadId&lt;/code&gt; 는 으로부터 검색 할 수있는 &lt;a href=&quot;struct.thread#method.id&quot;&gt; &lt;code&gt;id&lt;/code&gt; &lt;/a&gt; A의 방법 &lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1818d010b7b29b87c4502d46870a6345ca3ee68" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TypeId&lt;/code&gt; is currently only available for types which ascribe to &lt;code&gt;'static&lt;/code&gt;, but this limitation may be removed in the future.</source>
          <target state="translated">&lt;code&gt;TypeId&lt;/code&gt; 현재에있는 돌리다 유형에만 사용할 수 있습니다 &lt;code&gt;'static&lt;/code&gt; 하지만,이 제한은 미래에 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b2832f9ef1617c1a164688031f12174b8e5931d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TypeId&lt;/code&gt; represents a globally unique identifier for a type.</source>
          <target state="translated">&lt;code&gt;TypeId&lt;/code&gt; 유형에 대한 글로벌 고유 식별자를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="05e63a516d556e9577522a23860139fad9899875" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Vec&lt;/code&gt; can be mutable. Slices, on the other hand, are read-only objects. To get a &lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;, use &lt;a href=&quot;../primitive.reference&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;. Example:</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; 변경할 수 있습니다. 반면에 슬라이스는 읽기 전용 개체입니다. &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 를 얻으려면 &lt;a href=&quot;../primitive.reference&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="345e82ed2183b66aaf325e8ad24887f5dd3ff3ad" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Vec&lt;/code&gt; can be mutable. Slices, on the other hand, are read-only objects. To get a slice, use &lt;code&gt;&amp;amp;&lt;/code&gt;. Example:</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; 변경할 수 있습니다. 반면에 슬라이스는 읽기 전용 개체입니다. 슬라이스를 얻으려면 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 사용하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="84a3e0757f03c2cf35d8f4ee02786937e5e0845a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Waker&lt;/code&gt; is a handle for waking up a task by notifying its executor that it is ready to be run.</source>
          <target state="translated">&lt;code&gt;Waker&lt;/code&gt; 은 그것을 실행할 준비가되었음을 그 집행을 통지하여 작업을 깨어위한 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="d9bc289fc584bbfaef86d0de4ba94863300845d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the allocation managed by &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; without preventing its inner value from being dropped. It is also used to prevent circular references between &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터에 의해 관리 된 배치에 대한 임시 기준 유지에 유용 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 삭제하는 것을 그 내부 값을 예방하지. 상호 소유 참조는 두 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 중 어느 쪽 도 드롭 되지 않도록 허용하므로 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 포인터 사이의 순환 참조를 방지하는데도 사용됩니다 . 예를 들어, 나무는 부모 노드에서 자식으로의 강한 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 포인터와 자식에서 부모로 돌아가는 &lt;code&gt;Weak&lt;/code&gt; 포인터를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a226c54ce6028079ee3f0e935344b03753cf6ea2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the allocation managed by &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; without preventing its inner value from being dropped. It is also used to prevent circular references between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터에 의해 관리 된 배치에 대한 임시 기준 유지에 유용 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; 를을&lt;/a&gt; 삭제하는 것을 그 내부 값을 예방하지. 또한 상호 소유 참조는 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 가 삭제되는 것을 허용하지 않으므로 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터 간의 순환 참조를 방지하는데도 사용됩니다 . 예를 들어, 트리는 부모 노드에서 자식으로의 강력한 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터와 자식에서 부모로 돌아가는 &lt;code&gt;Weak&lt;/code&gt; 포인터를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92c5425b2664515a7d6b0bd3279f583d1e16c172" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the value within &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; without extending its lifetime. It is also used to prevent circular references between &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터 내의 값으로 임시 기준 유지에 유용 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 수명을 연장하지 않고. 또한 상호 소유하는 참조는 어느 한 쪽의 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 도 삭제할 수 없으므로 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 포인터 사이의 순환 참조를 방지하는 데 사용됩니다 . 예를 들어, 나무는 부모 노드에서 자식으로 강한 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 포인터를, 자식에서 부모로 &lt;code&gt;Weak&lt;/code&gt; 포인터를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c317832e61e5046de4792c85bcf63089c251292c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the value within &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; without extending its lifetime. It is also used to prevent circular references between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터 내의 값으로 임시 기준 유지에 유용 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; 를가&lt;/a&gt; 수명 연장없이. 또한 상호 소유 참조가 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 를 삭제할 수 없기 때문에 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터 사이의 순환 참조를 방지하는 데에도 사용됩니다 . 예를 들어, 나무는 부모 노드에서 자식으로 강력한 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터를, 자식에서 부모로 &lt;code&gt;Weak&lt;/code&gt; 포인터를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ab6f5c59e2d0418f87950a3ebfb26ab14b557db" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is normally associated with the innermost &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; loop enclosing the &lt;code&gt;break&lt;/code&gt; expression, but a &lt;a href=&quot;#loop-labels&quot;&gt;label&lt;/a&gt; can be used to specify which enclosing loop is affected. Example:</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 표현은 일반적으로 내측과 연관된 &lt;code&gt;loop&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; 또는 &lt;code&gt;while&lt;/code&gt; 루프가 클로징 &lt;code&gt;break&lt;/code&gt; 발현하지만 &lt;a href=&quot;#loop-labels&quot;&gt;라벨&lt;/a&gt; 영향을 둘러싸고있는 루프를 지정하기 위해 사용될 수있다. 예:</target>
        </trans-unit>
        <trans-unit id="4bf74475c310d76b2da5f50f50fec722f68f826f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is normally associated with the innermost &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; loop enclosing the &lt;code&gt;break&lt;/code&gt; expression, but a &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;label&lt;/a&gt; can be used to specify which enclosing loop is affected. Example:</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 표현은 일반적으로 내측과 연관된 &lt;code&gt;loop&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; 또는 &lt;code&gt;while&lt;/code&gt; 루프가 클로징 &lt;code&gt;break&lt;/code&gt; 발현하지만 &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;라벨&lt;/a&gt; 영향을 둘러싸고있는 루프를 지정하기 위해 사용될 수있다. 예:</target>
        </trans-unit>
        <trans-unit id="dc2182d07a207a24da6c811d0b8e308ce9f0619b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is only permitted in the body of a loop, and has one of the forms &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;break 'label&lt;/code&gt; or (&lt;a href=&quot;#break-and-loop-values&quot;&gt;see below&lt;/a&gt;) &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 발현은 루프 본체에서 허용하고, 폼의 한 갖는다 &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;break 'label&lt;/code&gt; 또는 ( &lt;a href=&quot;#break-and-loop-values&quot;&gt;아래 참조&lt;/a&gt; ) &lt;code&gt;break EXPR&lt;/code&gt; 또는 &lt;code&gt;break 'label EXPR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1929ca3782f20314772673eb1b3076f6e73f81b3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is only permitted in the body of a loop, and has one of the forms &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;break 'label&lt;/code&gt; or (&lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;see below&lt;/a&gt;) &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 발현은 루프 본체에서 허용하고, 폼의 한 갖는다 &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;break 'label&lt;/code&gt; 또는 ( &lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;아래 참조&lt;/a&gt; ) &lt;code&gt;break EXPR&lt;/code&gt; 또는 &lt;code&gt;break 'label EXPR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f212565caf5ca5d26733a24ecd450094943708a5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; statement with an argument appeared in a non-&lt;code&gt;loop&lt;/code&gt; loop.</source>
          <target state="translated">인수가 있는 &lt;code&gt;break&lt;/code&gt; 문은 비 &lt;code&gt;loop&lt;/code&gt; 루프에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="0719aea9e00a3f18488e8dec397e352b5e69370a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; statement without a label appeared inside a labeled block.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 레이블이없는 문은 레이블 블록 내부 나타났다.</target>
        </trans-unit>
        <trans-unit id="3cd69f4f6c3139636621e0e9a9e16305bdb70d6f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;, which means that it is a &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Code Point&lt;/a&gt;, but only ones within a certain range. &lt;code&gt;MAX&lt;/code&gt; is the highest valid code point that's a valid &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; A는 &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;유니 코드 스칼라 값&lt;/a&gt; 하는 그것이 있다는 것을 의미, &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;코드 포인트&lt;/a&gt; 하지만, 특정 범위 내에서 유일한 사람. &lt;code&gt;MAX&lt;/code&gt; 는 유효한 &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value 인&lt;/a&gt; 가장 높은 유효한 코드 포인트입니다 .</target>
        </trans-unit>
        <trans-unit id="e8ee25848e86a1b5a5cc249fddb42f44e3d6d658" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;, which means that it is a &lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;Code Point&lt;/a&gt;, but only ones within a certain range. &lt;code&gt;MAX&lt;/code&gt; is the highest valid code point that's a valid &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; A는 &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;유니 코드 스칼라 값&lt;/a&gt; 하는 그것이 있다는 것을 의미, &lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;코드 포인트&lt;/a&gt; 하지만, 특정 범위 내에서 유일한 사람. &lt;code&gt;MAX&lt;/code&gt; 는 유효한 &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value 인&lt;/a&gt; 가장 높은 유효한 코드 포인트입니다 .</target>
        </trans-unit>
        <trans-unit id="6de9c91a3e0c1eb1015d4865a476f244ccddf52f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;const&lt;/code&gt; represents a constant value that should never change. If one takes a &lt;code&gt;&amp;amp;&lt;/code&gt; reference to the constant, then one is taking a pointer to some memory location containing the value. Normally this is perfectly fine: most values can't be changed via a shared &lt;code&gt;&amp;amp;&lt;/code&gt; pointer, but interior mutability would allow it. That is, a constant value could be mutated. On the other hand, a &lt;code&gt;static&lt;/code&gt; is explicitly a single memory location, which can be mutated at will.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 변경해서는 안 상수 값을 나타냅니다. 상수에 대한 &lt;code&gt;&amp;amp;&lt;/code&gt; 참조를 취하면 값을 포함하는 일부 메모리 위치에 대한 포인터를 가져옵니다. 일반적으로 이것은 완벽하게 좋습니다 : 대부분의 값은 공유 &lt;code&gt;&amp;amp;&lt;/code&gt; 포인터 를 통해 변경할 수 없지만 내부 변경은 허용합니다. 즉, 상수 값이 변경 될 수 있습니다. 반면에 &lt;code&gt;static&lt;/code&gt; 은 명시 적으로 단일 메모리 위치이며 마음대로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcf892710236415af0f5e027b5569143cb3933af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; expression is a syntactic construct for looping over elements provided by an implementation of &lt;code&gt;std::iter::IntoIterator&lt;/code&gt;. If the iterator yields a value, that value is given the specified name and the body of the loop is executed, then control returns to the head of the &lt;code&gt;for&lt;/code&gt; loop. If the iterator is empty, the &lt;code&gt;for&lt;/code&gt; expression completes.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 표현식의 구현에 의해 제공되는 요소를 반복하는 구문 론적 구조 인 &lt;code&gt;std::iter::IntoIterator&lt;/code&gt; . 반복자가 값을 생성하면 해당 값에 지정된 이름이 지정되고 루프 본문이 실행 된 후 제어가 &lt;code&gt;for&lt;/code&gt; 루프 의 헤드로 돌아갑니다 . 반복자가 비어 있으면 &lt;code&gt;for&lt;/code&gt; 표현식이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="7cc2ad054c8700f44ee39d9eb760a19117e088af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; expression is a syntactic construct for looping over elements provided by an implementation of &lt;code&gt;std::iter::IntoIterator&lt;/code&gt;. If the iterator yields a value, that value is matched against the irrefutable pattern, the body of the loop is executed, and then control returns to the head of the &lt;code&gt;for&lt;/code&gt; loop. If the iterator is empty, the &lt;code&gt;for&lt;/code&gt; expression completes.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 표현식의 구현에 의해 제공되는 요소를 반복하는 구문 론적 구조 인 &lt;code&gt;std::iter::IntoIterator&lt;/code&gt; . 반복기가 값을 산출하면 해당 값이 반박 할 수없는 패턴과 일치하고 루프 본문이 실행 된 다음 제어가 &lt;code&gt;for&lt;/code&gt; 루프 의 헤드로 돌아갑니다 . 반복기가 비어 있으면 &lt;code&gt;for&lt;/code&gt; 식이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="d73920ce8bc8796a34637626ebd1ee2bfe7e1d77" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; loop expands as shown:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프 팽창 같이 :</target>
        </trans-unit>
        <trans-unit id="0dcdc530771d15a6a0db69b3817439a78d80a1af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression repeats execution of its body continuously: &lt;code&gt;loop { println!(&quot;I live.&quot;); }&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 표현은 지속적으로 신체의 실행을 반복 : &lt;code&gt;loop { println!(&quot;I live.&quot;); }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d617ef5af3dab30c4c49b4baffa8bfa3c5f2ec66" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression without an associated &lt;code&gt;break&lt;/code&gt; expression is diverging and has type &lt;a href=&quot;../types/never&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;loop&lt;/code&gt; expression containing associated &lt;a href=&quot;#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expression(s)&lt;/a&gt; may terminate, and must have type compatible with the value of the &lt;code&gt;break&lt;/code&gt; expression(s).</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 관련이없는 표현 &lt;code&gt;break&lt;/code&gt; 표현 분기와 종류를 가지고있다 &lt;a href=&quot;../types/never&quot;&gt; &lt;code&gt;!&lt;/code&gt; &lt;/a&gt;. &lt;code&gt;loop&lt;/code&gt; 연관된 함유 식 &lt;a href=&quot;#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; 표현식 (들)을&lt;/a&gt; 종료 할 수 있으며,의 값에 대응 한 입력해야 &lt;code&gt;break&lt;/code&gt; 식 (S).</target>
        </trans-unit>
        <trans-unit id="e36c323c7511710c9caa566121cf59ed62c95bef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression without an associated &lt;code&gt;break&lt;/code&gt; expression is diverging and has type &lt;a href=&quot;../types/never&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;loop&lt;/code&gt; expression containing associated &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expression(s)&lt;/a&gt; may terminate, and must have type compatible with the value of the &lt;code&gt;break&lt;/code&gt; expression(s).</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 관련이없는 표현 &lt;code&gt;break&lt;/code&gt; 표현 분기와 종류를 가지고있다 &lt;a href=&quot;../types/never&quot;&gt; &lt;code&gt;!&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;loop&lt;/code&gt; 연관된 함유 식 &lt;a href=&quot;loop-expr#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; 표현식 (들)을&lt;/a&gt; 종료 할 수 있으며,의 값에 대응 한 입력해야 &lt;code&gt;break&lt;/code&gt; 식 (S).</target>
        </trans-unit>
        <trans-unit id="27cdf38632ff8742feaafa6612389bb67003ed19" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; behaves differently depending on whether or not the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression or value expression&lt;/a&gt;. If the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;, it is first evaluated into a temporary location, and the resulting value is sequentially compared to the patterns in the arms until a match is found. The first arm with a matching pattern is chosen as the branch target of the &lt;code&gt;match&lt;/code&gt;, any variables bound by the pattern are assigned to local variables in the arm's block, and control enters the block.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 동작합니다 다르게 scrutinee 표현이 있는지 여부에 따라 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;장소 발현 또는 값 표현&lt;/a&gt; . scrutinee 표현식이 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt; 인 경우 먼저 임시 위치로 평가되고 결과 값은 일치하는 것을 찾을 때까지 팔의 패턴과 순차적으로 비교됩니다. 일치하는 패턴이있는 첫 번째 팔이 &lt;code&gt;match&lt;/code&gt; 의 분기 대상으로 선택되고 패턴에 의해 바인딩 된 모든 변수가 팔 블록의 로컬 변수에 할당되고 제어가 블록으로 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="9d65cf4e1e473919c3773c077a67170ac8398876" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; expression is made up of &lt;em&gt;arms&lt;/em&gt;. An arm consists of a &lt;em&gt;pattern&lt;/em&gt; and the code that should be run if the value given to the beginning of the &lt;code&gt;match&lt;/code&gt; expression fits that arm&amp;rsquo;s pattern. Rust takes the value given to &lt;code&gt;match&lt;/code&gt; and looks through each arm&amp;rsquo;s pattern in turn. The &lt;code&gt;match&lt;/code&gt; construct and patterns are powerful features in Rust that let you express a variety of situations your code might encounter and make sure that you handle them all. These features will be covered in detail in Chapter 6 and Chapter 18, respectively.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 표현으로 구성되어 &lt;em&gt;팔&lt;/em&gt; . 팔은 &lt;em&gt;패턴&lt;/em&gt; 과 &lt;code&gt;match&lt;/code&gt; 표현식 의 시작 부분에 제공된 값이 해당 팔의 패턴에 맞는 경우 실행해야하는 코드 로 구성됩니다 . Rust는 주어진 값을 &lt;code&gt;match&lt;/code&gt; 각 팔의 패턴을 차례로 살펴 봅니다. &lt;code&gt;match&lt;/code&gt; 구조와 패턴을 사용하면 코드가 발생하고 당신이 그들 모두를 처리 할 것을 만들 수있는 다양한 상황을 표현하자 녹 강력한 기능입니다. 이러한 기능에 대해서는 6 장과 18 장에 각각 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2653905e02c1a5978b97c0dfd21c1d160c036b3e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;repr(transparent)&lt;/code&gt; type was also annotated with other, incompatible representation hints.</source>
          <target state="translated">&lt;code&gt;repr(transparent)&lt;/code&gt; 타입은 다른 호환 표현 힌트로 주석했다.</target>
        </trans-unit>
        <trans-unit id="c5a4ca7ea6b5bc0339d74f8626989e641c9a4f2a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;return&lt;/code&gt; marks the end of an execution path in a function:</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 표시 기능의 실행 경로의 끝 :</target>
        </trans-unit>
        <trans-unit id="d04d984159639545c2a9b782d494bbc89f68eb09" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt; which was defined in the current crate. This is not affected by applied type arguments. &lt;code&gt;struct Foo&lt;/code&gt; is considered local, but &lt;code&gt;Vec&amp;lt;Foo&amp;gt;&lt;/code&gt; is not. &lt;code&gt;LocalType&amp;lt;ForeignType&amp;gt;&lt;/code&gt; is local. Type aliases do not affect locality.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;enum&lt;/code&gt; , 또는 &lt;code&gt;union&lt;/code&gt; 현재 상자에 정의 하였다. 이는 적용된 형식 인수의 영향을받지 않습니다. &lt;code&gt;struct Foo&lt;/code&gt; 는 로컬로 간주되지만 &lt;code&gt;Vec&amp;lt;Foo&amp;gt;&lt;/code&gt; 는 그렇지 않습니다. &lt;code&gt;LocalType&amp;lt;ForeignType&amp;gt;&lt;/code&gt; 은 로컬입니다. 유형 별칭은 지역에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0bcaf88ff1b66b63413f83d3b7d32c0a7ea7cbfe" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;&lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;fields&lt;/em&gt; of the type.&lt;sup&gt;&lt;a href=&quot;#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; &lt;em&gt;타입&lt;/em&gt; 착신 다른 종류의 이종 제품 &lt;em&gt;필드&lt;/em&gt; 유형. &lt;sup&gt;&lt;a href=&quot;#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="e983e7b3d7471c078bb152c54f1d0e490ae64bff" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;&lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;fields&lt;/em&gt; of the type.&lt;sup&gt;&lt;a href=&quot;struct#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; &lt;em&gt;타입&lt;/em&gt; 착신 다른 종류의 이종 제품 &lt;em&gt;필드&lt;/em&gt; 유형. &lt;sup&gt;&lt;a href=&quot;struct#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="5dc372cb983e81c62a84e7d307e5c691468779fc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;trait&lt;/code&gt; is like an interface that data types can implement. When a type implements a trait it can be treated abstractly as that trait using generics or trait objects.</source>
          <target state="translated">&lt;code&gt;trait&lt;/code&gt; 데이터 유형을 구현할 수있는 인터페이스와 같다. 유형이 특성을 구현할 때 제네릭 또는 특성 개체를 사용하여 해당 특성으로 추상적으로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="2ad87d3d4edf2b4861565127275e5ad1afc1a755" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;trait&lt;/code&gt; which was defined in the current crate. A trait definition is local or not independent of applied type arguments. Given &lt;code&gt;trait Foo&amp;lt;T, U&amp;gt;&lt;/code&gt;, &lt;code&gt;Foo&lt;/code&gt; is always local, regardless of the types substituted for &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;trait&lt;/code&gt; 현재 상자에 정의 하였다. 특성 정의는 지역적이거나 적용된 유형 인수와 독립적이지 않습니다. 주어 &lt;code&gt;trait Foo&amp;lt;T, U&amp;gt;&lt;/code&gt; , &lt;code&gt;Foo&lt;/code&gt; 에 관계없이 대체 유형에 항상 로컬 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99ab68cda9330ceba3e059532d454bd1454a3c76" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; cannot have fields with destructors.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 소멸자 필드를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7456e28e3269b8fcb15b4e8220467fa67683b4bd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; is similar to a &lt;code&gt;struct&lt;/code&gt;, but only one declared field is used in a particular instance at one time. Unions are primarily used to interface with unions in C code. Accessing union fields is unsafe because Rust can&amp;rsquo;t guarantee the type of the data currently being stored in the union instance. You can learn more about unions in &lt;a href=&quot;../reference/items/unions&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; A와 유사하다 &lt;code&gt;struct&lt;/code&gt; 하지만, 단 하나의 선언 된 필드는 한 번에 특정 인스턴스에 사용됩니다. 공용체는 주로 C 코드에서 공용체와 인터페이스하는 데 사용됩니다. 통합 필드에 액세스하는 것은 Rust가 현재 통합 인스턴스에 저장되고있는 데이터의 유형을 보장 할 수 없기 때문에 안전하지 않습니다. &lt;a href=&quot;../reference/items/unions&quot;&gt;참조&lt;/a&gt; 에서 공용체에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d933644dc98827f86adb027ad1edada503180c92" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; looks like a &lt;a href=&quot;keyword.struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; in terms of declaration, but all of its fields exist in the same memory, superimposed over one another. For instance, if we wanted some bits in memory that we sometimes interpret as a &lt;code&gt;u32&lt;/code&gt; and sometimes as an &lt;code&gt;f32&lt;/code&gt;, we could write:</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 유사한 외모 &lt;a href=&quot;keyword.struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; 선언의 측면에서,하지만 모든 필드는 서로 겹쳐, 같은 메모리에 존재한다. 예를 들어 우리가 때때로 &lt;code&gt;u32&lt;/code&gt; 로 해석 하고 때로는 &lt;code&gt;f32&lt;/code&gt; 로 해석하는 메모리에 비트를 원한다면 다음 과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aae4dfd16f669123c1df46acb99529aa8db4f78e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; was declared with fields with destructors.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 소멸자 필드로 선언했다.</target>
        </trans-unit>
        <trans-unit id="31174f5a2be478aaee87f1f4ce26d9142eeb339c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while let&lt;/code&gt; loop is equivalent to a &lt;code&gt;loop&lt;/code&gt; expression containing a &lt;a href=&quot;match-expr&quot;&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/a&gt; as follows.</source>
          <target state="translated">&lt;code&gt;while let&lt;/code&gt; 루프가에 해당 &lt;code&gt;loop&lt;/code&gt; 포함하는 발현 &lt;a href=&quot;match-expr&quot;&gt; &lt;code&gt;match&lt;/code&gt; 식을&lt;/a&gt; 다음과 같이.</target>
        </trans-unit>
        <trans-unit id="132dd0b4198a0332783e039cb830e80e3a95c535" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while let&lt;/code&gt; loop is semantically similar to a &lt;code&gt;while&lt;/code&gt; loop but in place of a condition expression it expects the keyword &lt;code&gt;let&lt;/code&gt; followed by a pattern, an &lt;code&gt;=&lt;/code&gt;, a &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression and a block expression. If the value of the scrutinee matches the pattern, the loop body block executes then control returns to the pattern matching statement. Otherwise, the while expression completes.</source>
          <target state="translated">&lt;code&gt;while let&lt;/code&gt; 루프는 의미 상 유사하다 &lt;code&gt;while&lt;/code&gt; 루프는 조건식 대신는 키워드가 예상되지만 &lt;code&gt;let&lt;/code&gt; 패턴, 다음 &lt;code&gt;=&lt;/code&gt; 하는 &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee의&lt;/a&gt; 발현 및 블록 식. scrutinee의 값이 패턴과 일치하면 루프 본문 블록이 실행 된 다음 제어가 패턴 일치 명령문으로 돌아갑니다. 그렇지 않으면 while 표현식이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="718179093a0d6e082dbdc6f07f43775afb09f0f9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; expression is used for predicate loops. The &lt;code&gt;while&lt;/code&gt; expression runs the conditional expression before running the loop body, then runs the loop body if the conditional expression evaluates to &lt;code&gt;true&lt;/code&gt;, or exits the loop otherwise.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 표현은 조건 루프에 사용됩니다. &lt;code&gt;while&lt;/code&gt; 표현 루프 본문을 실행하기 전에 조건식을 실행 한 후 조건식 평가되는 경우에 루프 본문을 실행하는 &lt;code&gt;true&lt;/code&gt; 또는 기타 루프를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="283fcf53585988268a7d68d52030cb117688b529" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; loop begins by evaluating the boolean loop conditional expression. If the loop conditional expression evaluates to &lt;code&gt;true&lt;/code&gt;, the loop body block executes, then control returns to the loop conditional expression. If the loop conditional expression evaluates to &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;while&lt;/code&gt; expression completes.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 루프는 부울 루프 조건식을 평가하여 시작합니다. 루프 조건식이 &lt;code&gt;true&lt;/code&gt; 로 평가 되면 루프 본문 블록이 실행 된 다음 제어가 루프 조건식으로 돌아갑니다. 에 루프 조건식 평가되면 &lt;code&gt;false&lt;/code&gt; 의 &lt;code&gt;while&lt;/code&gt; 표현이 완료.</target>
        </trans-unit>
        <trans-unit id="9024dfdf6115f20a47566e1a178072686b644d4c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;yield&lt;/code&gt; clause was used in an &lt;code&gt;async&lt;/code&gt; context.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; 절은에 사용 된 &lt;code&gt;async&lt;/code&gt; 상황.</target>
        </trans-unit>
        <trans-unit id="9a98030fcb71c42d6137c8ff5fae0192e67a25d8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;24-bit code point escape&lt;/em&gt; starts with &lt;code&gt;U+0075&lt;/code&gt; (&lt;code&gt;u&lt;/code&gt;) and is followed by up to six &lt;em&gt;hex digits&lt;/em&gt; surrounded by braces &lt;code&gt;U+007B&lt;/code&gt; (&lt;code&gt;{&lt;/code&gt;) and &lt;code&gt;U+007D&lt;/code&gt; (&lt;code&gt;}&lt;/code&gt;). It denotes the Unicode code point equal to the provided hex value.</source>
          <target state="translated">&lt;em&gt;24 비트 코드 포인트 탈출&lt;/em&gt; 로 시작 &lt;code&gt;U+0075&lt;/code&gt; ( &lt;code&gt;u&lt;/code&gt; ) 및 여섯까지 이어진다 &lt;em&gt;16 진수&lt;/em&gt; 중괄호 &lt;code&gt;U+007B&lt;/code&gt; ( &lt;code&gt;{&lt;/code&gt; ) 및 &lt;code&gt;U+007D&lt;/code&gt; ( &lt;code&gt;}&lt;/code&gt; ). 제공된 16 진수 값과 동일한 유니 코드 코드 포인트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="869073214f1b9edb093744ef355f142778b07763" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;7-bit code point escape&lt;/em&gt; starts with &lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) and is followed by exactly two &lt;em&gt;hex digits&lt;/em&gt; with value up to &lt;code&gt;0x7F&lt;/code&gt;. It denotes the ASCII character with value equal to the provided hex value. Higher values are not permitted because it is ambiguous whether they mean Unicode code points or byte values.</source>
          <target state="translated">&lt;em&gt;7 비트 코드 포인트 탈출&lt;/em&gt; 시작 &lt;code&gt;U+0078&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; )과 정확히 두 뒤에 &lt;em&gt;16 진수&lt;/em&gt; 로 값쪽으로 &lt;code&gt;0x7F&lt;/code&gt; 의 . 제공된 16 진 값과 동일한 값을 갖는 ASCII 문자를 나타냅니다. 유니 코드 코드 포인트 또는 바이트 값을 의미하는지 여부가 모호하므로 더 큰 값은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba5e9b49178a0e6b5d252044b97fef65592fc293" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/em&gt; introduces a new set of &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, given by a &lt;a href=&quot;patterns&quot;&gt;pattern&lt;/a&gt;. The pattern is followed optionally by a type annotation and then optionally by an initializer expression. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.</source>
          <target state="translated">A는 &lt;em&gt; &lt;code&gt;let&lt;/code&gt; 문&lt;/em&gt; 을 소개합니다에게의 새로운 &lt;a href=&quot;variables&quot;&gt;변수&lt;/a&gt; a로 주어진 &lt;a href=&quot;patterns&quot;&gt;패턴을&lt;/a&gt; . 패턴 다음에는 선택적으로 형식 주석이 있고 초기화식이 있습니다. 형식 주석이 제공되지 않으면 컴파일러는 형식을 유추하거나 불충분 한 형식 정보가 명확한 추론에 사용 가능한 경우 오류를 알립니다. 변수 선언에 의해 도입 된 모든 변수는 선언 지점에서 둘러싸는 블록 범위의 끝까지 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ca18f2a30c6ddfd6e41efbe967d1604f354b083" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/em&gt; introduces a new set of &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, given by an irrefutable &lt;a href=&quot;patterns&quot;&gt;pattern&lt;/a&gt;. The pattern is followed optionally by a type annotation and then optionally by an initializer expression. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.</source>
          <target state="translated">A는 &lt;em&gt; &lt;code&gt;let&lt;/code&gt; 문&lt;/em&gt; 을 소개합니다에게의 새로운 &lt;a href=&quot;variables&quot;&gt;변수&lt;/a&gt; 반박 할 수없는 의해 주어진 &lt;a href=&quot;patterns&quot;&gt;패턴&lt;/a&gt; . 패턴 뒤에는 선택적으로 유형 어노테이션이오고 선택적으로 이니셜 라이저 표현식이옵니다. 유형 주석이 제공되지 않으면 컴파일러는 유형을 추론하거나 명확한 추론에 사용할 수있는 유형 정보가 충분하지 않은 경우 오류 신호를 보냅니다. 변수 선언에 의해 도입 된 모든 변수는 선언 지점에서 둘러싸는 블록 범위가 끝날 때까지 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4965d161e4fa0b76aa8e253a8b735c3ef6585135" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/em&gt; branches on a pattern. The exact form of matching that occurs depends on the &lt;a href=&quot;../patterns&quot;&gt;pattern&lt;/a&gt;. A &lt;code&gt;match&lt;/code&gt; expression has a &lt;em&gt;&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression&lt;/em&gt;, which is the value to compare to the patterns. The scrutinee expression and the patterns must have the same type.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;match&lt;/code&gt; 발현&lt;/em&gt; 패턴에 분기합니다. 일치하는 정확한 형태는 &lt;a href=&quot;../patterns&quot;&gt;패턴에&lt;/a&gt; 따라 다릅니다 . &lt;code&gt;match&lt;/code&gt; 표현식은이 &lt;em&gt;&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee의&lt;/a&gt; 표현&lt;/em&gt; , 패턴을 비교하는 값입니다. 스크 루틴 표현과 패턴은 같은 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="58385518472acdb41b644cab1601f90a746d55aa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;binary literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;0b&lt;/code&gt;) and continues as any mixture (with at least one digit) of binary digits and underscores.</source>
          <target state="translated">&lt;em&gt;이진 리터럴&lt;/em&gt; 문자 시퀀스로 시작하는 &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+0062&lt;/code&gt; ( &lt;code&gt;0b&lt;/code&gt; ) 및 이진수 및 밑줄 (적어도 한 디지트를 가진) 임의의 혼합물로 계속된다.</target>
        </trans-unit>
        <trans-unit id="e1bc1112f211249d5a018412bd10ed929678eeda" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;block expression&lt;/em&gt;, or &lt;em&gt;block&lt;/em&gt;, is a control flow expression and anonymous namespace scope for items and variable declarations. As a control flow expression, a block sequentially executes its component non-item declaration statements and then its final optional expression. As an anonymous namespace scope, item declarations are only in scope inside the block itself and variables declared by &lt;code&gt;let&lt;/code&gt; statements are in scope from the next statement until the end of the block.</source>
          <target state="translated">&lt;em&gt;블록 식&lt;/em&gt; 또는 &lt;em&gt;블록&lt;/em&gt; , 항목 변수 선언하기위한 제어 흐름 식 익명 공간 범위이다. 제어 흐름 표현식으로서 블록은 구성 요소 비 항목 선언문을 순차적으로 실행 한 다음 최종 선택적 표현식을 실행합니다. 익명의 네임 스페이스 범위 인 항목 선언은 블록 자체의 범위에만 있고 &lt;code&gt;let&lt;/code&gt; 문으로 선언 된 변수는 다음 명령문에서 블록 끝까지 범위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="d959096d425f9582c596a1eece69230b21ea3b75" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;byte escape&lt;/em&gt; escape starts with &lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) and is followed by exactly two &lt;em&gt;hex digits&lt;/em&gt;. It denotes the byte equal to the provided hex value.</source>
          <target state="translated">&lt;em&gt;바이트 이스케이프&lt;/em&gt; 탈출 시작 &lt;code&gt;U+0078&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; )과 정확히 두 뒤에 &lt;em&gt;16 진수&lt;/em&gt; . 제공된 16 진 값과 동일한 바이트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="08d56300cad1166d8bb2fb927ceda10d77863d64" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;byte literal&lt;/em&gt; is a single ASCII character (in the &lt;code&gt;U+0000&lt;/code&gt; to &lt;code&gt;U+007F&lt;/code&gt; range) or a single &lt;em&gt;escape&lt;/em&gt; preceded by the characters &lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) and &lt;code&gt;U+0027&lt;/code&gt; (single-quote), and followed by the character &lt;code&gt;U+0027&lt;/code&gt;. If the character &lt;code&gt;U+0027&lt;/code&gt; is present within the literal, it must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) character. It is equivalent to a &lt;code&gt;u8&lt;/code&gt; unsigned 8-bit integer &lt;em&gt;number literal&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;바이트 리터럴&lt;/em&gt; 합니다 (단일 ASCII 문자 인 &lt;code&gt;U+0000&lt;/code&gt; 에 &lt;code&gt;U+007F&lt;/code&gt; 의 범위) 또는 단일 &lt;em&gt;이스케이프&lt;/em&gt; 문자 앞에 &lt;code&gt;U+0062&lt;/code&gt; ( &lt;code&gt;b&lt;/code&gt; ) 및 &lt;code&gt;U+0027&lt;/code&gt; 문자 그래피 (따옴표)을 따라 &lt;code&gt;U+0027&lt;/code&gt; . 문자 &lt;code&gt;U+0027&lt;/code&gt; 이 리터럴 내에 있으면 선행 &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) 문자 로 &lt;em&gt;이스케이프&lt;/em&gt; 해야합니다 . 그것은 동등 &lt;code&gt;u8&lt;/code&gt; 부호없는 8 비트 정수 &lt;em&gt;번호 리터럴&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="82cbcd824290282b86dc09637a06221aa40fcffe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;call expression&lt;/em&gt; consists of an expression followed by a parenthesized expression-list. It invokes a function, providing zero or more input variables. If the function eventually returns, then the expression completes. For &lt;a href=&quot;../types/function-item&quot;&gt;non-function types&lt;/a&gt;, the expression f(...) uses the method on one of the &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;std::ops::Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;std::ops::FnMut&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt;&lt;code&gt;std::ops::FnOnce&lt;/code&gt;&lt;/a&gt; traits, which differ in whether they take the type by reference, mutable reference, or take ownership respectively. An automatic borrow will be taken if needed. Rust will also automatically dereference &lt;code&gt;f&lt;/code&gt; as required. Some examples of call expressions:</source>
          <target state="translated">&lt;em&gt;전화 식은&lt;/em&gt; 괄호 표현 목록 다음 식으로 구성되어 있습니다. 0 개 이상의 입력 변수를 제공하는 함수를 호출합니다. 함수가 결국 리턴하면 표현식이 완료됩니다. 들면 &lt;a href=&quot;../types/function-item&quot;&gt;비 기능 유형&lt;/a&gt; , 식 (F)는 (...) 중 하나의 방법을 사용한다 &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;std::ops::Fn&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;std::ops::FnMut&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt; &lt;code&gt;std::ops::FnOnce&lt;/code&gt; &lt;/a&gt; 특성이든 상이한 이들은 참조, 변경 가능한 참조 또는 유형별로 각각 유형을 취합니다. 필요한 경우 자동 대출이 이루어집니다. Rust는 필요에 따라 자동으로 &lt;code&gt;f&lt;/code&gt; 를 역 참조 합니다. 호출 표현식의 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="30fdc766ea9fe7cd1ba45798e3f6d282c53ef441" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;character literal&lt;/em&gt; is a single Unicode character enclosed within two &lt;code&gt;U+0027&lt;/code&gt; (single-quote) characters, with the exception of &lt;code&gt;U+0027&lt;/code&gt; itself, which must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;문자 리터럴은&lt;/em&gt; 두 가지로 둘러싸인 하나의 유니 코드 문자 &lt;code&gt;U+0027&lt;/code&gt; 를 제외하고 (따옴표) 문자 &lt;code&gt;U+0027&lt;/code&gt; 해야 자체 &lt;em&gt;탈출&lt;/em&gt; 선행에 의해 &lt;code&gt;U+005C&lt;/code&gt; 문자 ( &lt;code&gt;\&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3c6b198e97c9744354ac6c754b38292587c4fb26" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;closure expression&lt;/em&gt; defines a closure and denotes it as a value, in a single expression. A closure expression is a pipe-symbol-delimited (&lt;code&gt;|&lt;/code&gt;) list of irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt; followed by an expression. Type annotations may optionally be added for the type of the parameters or for the return type. If there is a return type, the expression used for the body of the closure must be a normal &lt;a href=&quot;block-expr&quot;&gt;block&lt;/a&gt;. A closure expression also may begin with the &lt;code&gt;move&lt;/code&gt; keyword before the initial &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;폐쇄 식&lt;/em&gt; 클로저를 정의하고, 하나의 식에 값으로 나타낸다. (A 밀폐 식 파이프 심볼 구분이다 &lt;code&gt;|&lt;/code&gt; ) 반박에서 &lt;a href=&quot;../patterns&quot;&gt;패턴을&lt;/a&gt; 표현 하였다. 매개 변수 유형 또는 리턴 유형에 대해 유형 어노테이션을 선택적으로 추가 할 수 있습니다. 리턴 유형이있는 경우 클로저 본문에 사용 된 표현식은 일반 &lt;a href=&quot;block-expr&quot;&gt;블록&lt;/a&gt; 이어야합니다 . 클로저 표현도 함께 시작할 수 있습니다 &lt;code&gt;move&lt;/code&gt; 초기 전에 키워드 &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="339cfc7fe9f16f898782c7f7150b6fb18b64f9c3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;closure expression&lt;/em&gt;, also know as a lambda expression or a lambda, defines a closure and denotes it as a value, in a single expression. A closure expression is a pipe-symbol-delimited (&lt;code&gt;|&lt;/code&gt;) list of irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt; followed by an expression. Type annotations may optionally be added for the type of the parameters or for the return type. If there is a return type, the expression used for the body of the closure must be a normal &lt;a href=&quot;block-expr&quot;&gt;block&lt;/a&gt;. A closure expression also may begin with the &lt;code&gt;move&lt;/code&gt; keyword before the initial &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">람다 식 또는 람다라고도 하는 &lt;em&gt;클로저 식은 클로저를&lt;/em&gt; 정의하고 단일 식의 값으로 나타냅니다. 클로저 표현식은 파이프 기호로 구분 된 ( &lt;code&gt;|&lt;/code&gt; ) 반박 할 수없는 &lt;a href=&quot;../patterns&quot;&gt;패턴&lt;/a&gt; 목록과 표현식입니다. 매개 변수 유형 또는 반환 유형에 대해 유형 주석을 선택적으로 추가 할 수 있습니다. 반환 유형이있는 경우 클로저 본문에 사용되는 표현식은 일반 &lt;a href=&quot;block-expr&quot;&gt;블록&lt;/a&gt; 이어야합니다 . 클로저 표현도 함께 시작할 수 있습니다 &lt;code&gt;move&lt;/code&gt; 초기 전에 키워드 &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12a150efcf9ffb345d5ef3ddd2a2876cc8ac7c18" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;cons list&lt;/em&gt; is a data structure that comes from the Lisp programming language and its dialects. In Lisp, the &lt;code&gt;cons&lt;/code&gt; function (short for &amp;ldquo;construct function&amp;rdquo;) constructs a new pair from its two arguments, which usually are a single value and another pair. These pairs containing pairs form a list.</source>
          <target state="translated">&lt;em&gt;단점리스트는&lt;/em&gt; 리스프 프로그래밍 언어와 방언에서 제공되는 데이터 구조입니다. Lisp에서 &lt;code&gt;cons&lt;/code&gt; 함수 ( &quot;construct 함수&quot;의 줄임말)는 일반적으로 단일 값과 다른 쌍인 두 인수에서 새 쌍을 구성합니다. 쌍을 포함하는이 쌍은 목록을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="cfba0b21b720ac42e28e2be5d6bab07c901fa318" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;const context&lt;/em&gt; is one of the following:</source>
          <target state="translated">&lt;em&gt;CONST 컨텍스트는&lt;/em&gt; 다음 중 하나입니다 :</target>
        </trans-unit>
        <trans-unit id="493b2f63697e56331a49f53a0195846cde72e171" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;const fn&lt;/em&gt; is a function that one is permitted to call from a const context. Declaring a function &lt;code&gt;const&lt;/code&gt; has no effect on any existing uses, it only restricts the types that arguments and the return type may use, as well as prevent various expressions from being used within it. You can freely do anything with a const function that you can do with a regular function.</source>
          <target state="translated">&lt;em&gt;CONST의 FN은&lt;/em&gt; 하나가 CONST 컨텍스트에서 호출하도록 허용하는 기능입니다. &lt;code&gt;const&lt;/code&gt; 함수를 선언하는 것은 기존 사용에 영향을 미치지 않으며 인수와 반환 유형이 사용할 수있는 유형 만 제한 할뿐 아니라 다양한 표현식이 그 안에서 사용되는 것을 방지합니다. 일반 함수로 할 수있는 모든 것을 const 함수로 자유롭게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c36e88175514c7e87236cec6eff5e35e2ff35de3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constant item&lt;/em&gt; is an optionally named &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant value&lt;/a&gt;&lt;/em&gt; which is not associated with a specific memory location in the program. Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. References to the same constant are not necessarily guaranteed to refer to the same memory address.</source>
          <target state="translated">&lt;em&gt;상수 항목&lt;/em&gt; 임의로라는 &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;일정한 값으로&lt;/a&gt;&lt;/em&gt; 프로그램 내의 특정 메모리 위치에 연관되지 않는다. 상수는 기본적으로 사용되는 곳마다 인라인되어 있으므로 사용시 관련 컨텍스트에 직접 복사됩니다. 동일한 상수에 대한 참조가 반드시 동일한 메모리 주소를 나타내는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2e06b409839c096ae71106f8baaaf9f78507004d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constant item&lt;/em&gt; is an optionally named &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant value&lt;/a&gt;&lt;/em&gt; which is not associated with a specific memory location in the program. Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. This includes usage of constants from external crates, and non-&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; types. References to the same constant are not necessarily guaranteed to refer to the same memory address.</source>
          <target state="translated">&lt;em&gt;상수 항목&lt;/em&gt; 임의로라는 &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;일정한 값으로&lt;/a&gt;&lt;/em&gt; 프로그램 내의 특정 메모리 위치에 연관되지 않는다. 상수는 사용되는 위치에 관계없이 본질적으로 인라인됩니다. 즉, 사용될 때 관련 컨텍스트에 직접 복사됩니다. 여기에는 외부 상자의 상수 사용 및 비 &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 유형 이 포함됩니다 . 동일한 상수에 대한 참조가 반드시 동일한 메모리 주소를 참조한다고 보장되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f7145ab5c52684eb21ecb032f3560fae33132c02" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;crate&lt;/em&gt; is a unit of compilation and linking, as well as versioning, distribution and runtime loading. A crate contains a &lt;em&gt;tree&lt;/em&gt; of nested &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; scopes. The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical &lt;a href=&quot;paths&quot;&gt;module path&lt;/a&gt; denoting its location within the crate's module tree.</source>
          <target state="translated">&lt;em&gt;상자는&lt;/em&gt; 컴파일 및 링크뿐만 아니라 버전 관리, 유통 및 런타임로드의 단위이다. 상자에는 중첩 된 &lt;a href=&quot;items/modules&quot;&gt;모듈&lt;/a&gt; 범위 의 &lt;em&gt;트리&lt;/em&gt; 가 있습니다 . 이 트리의 최상위 레벨은 (모듈 내의 경로 관점에서 볼 때 익명의) 모듈이며, 상자 안의 모든 항목 에는 상자의 모듈 트리 내에서 해당 위치를 나타내는 표준 &lt;a href=&quot;paths&quot;&gt;모듈 경로&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dbd934a0d90b722d503e93f98eb0c64d5f9ddfa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;crate&lt;/em&gt; is a unit of compilation and linking, as well as versioning, distribution, and runtime loading. A crate contains a &lt;em&gt;tree&lt;/em&gt; of nested &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; scopes. The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical &lt;a href=&quot;paths&quot;&gt;module path&lt;/a&gt; denoting its location within the crate's module tree.</source>
          <target state="translated">&lt;em&gt;상자는&lt;/em&gt; 컴파일 및 링크뿐만 아니라 버전 관리, 유통, 런타임로드의 단위이다. 상자에는 중첩 된 &lt;a href=&quot;items/modules&quot;&gt;모듈&lt;/a&gt; 범위 의 &lt;em&gt;트리&lt;/em&gt; 가 있습니다 . 이 트리의 최상위 레벨은 (모듈 내의 경로 관점에서) 익명의 모듈이며 상자 내의 모든 항목 에는 상자의 모듈 트리 내의 위치를 ​​나타내는 표준 &lt;a href=&quot;paths&quot;&gt;모듈 경로&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2299b04cb26521f6ac83c838a00ce161fe3ebdb6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;decimal literal&lt;/em&gt; followed by a period character &lt;code&gt;U+002E&lt;/code&gt; (&lt;code&gt;.&lt;/code&gt;). This is optionally followed by another decimal literal, with an optional &lt;em&gt;exponent&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;소수점 리터럴&lt;/em&gt; 마침표 다음에 &lt;code&gt;U+002E&lt;/code&gt; ( &lt;code&gt;.&lt;/code&gt; ). 선택적으로 &lt;em&gt;exponent&lt;/em&gt; 가있는 또 다른 10 진 리터럴이 뒤에옵니다 .</target>
        </trans-unit>
        <trans-unit id="8945005fcfd339455451ef03bfa95bfaaedef426" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;decimal literal&lt;/em&gt; starts with a &lt;em&gt;decimal digit&lt;/em&gt; and continues with any mixture of &lt;em&gt;decimal digits&lt;/em&gt; and &lt;em&gt;underscores&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;진수 문자&lt;/em&gt; 로 시작 &lt;em&gt;소수점 자리수&lt;/em&gt; 와의 임의의 혼합물로 계속 &lt;em&gt;십진수&lt;/em&gt; 와 &lt;em&gt;밑줄&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="766049e827df03480f975a74379f283f50ff3914" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;declaration statement&lt;/em&gt; is one that introduces one or more &lt;em&gt;names&lt;/em&gt; into the enclosing statement block. The declared names may denote new variables or new &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;선언문은&lt;/em&gt; 하나 또는 그 이상의 도입 하나 &lt;em&gt;이름을&lt;/em&gt; 둘러싸는 문 블록에. 선언 된 이름은 새 변수 또는 새 &lt;a href=&quot;items&quot;&gt;항목을&lt;/a&gt; 나타낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50530b588ed49ed96a8c5783ad73ba3e37c6ea25" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;field expression&lt;/em&gt; consists of an expression followed by a single dot and an &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;, when not immediately followed by a parenthesized expression-list (the latter is always a &lt;a href=&quot;method-call-expr&quot;&gt;method call expression&lt;/a&gt;). A field expression denotes a field of a &lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt;. To call a function stored in a struct, parentheses are needed around the field expression.</source>
          <target state="translated">&lt;em&gt;필드 식은&lt;/em&gt; 단일 점 및 다음 식으로 구성 &lt;a href=&quot;../identifiers&quot;&gt;식별자&lt;/a&gt; 즉시 괄호 표현리스트 다음하지 않을 때, (후자는 항상 인 &lt;a href=&quot;method-call-expr&quot;&gt;메소드 호출의 표현&lt;/a&gt; ). 필드 표현식은 &lt;a href=&quot;../items/structs&quot;&gt;구조체&lt;/a&gt; 또는 &lt;a href=&quot;../items/unions&quot;&gt;공용체&lt;/a&gt; 의 필드를 나타냅니다 . 구조체에 저장된 함수를 호출하려면 필드 표현식 주위에 괄호가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cf5014cd7ac2068f18f118543ff07241eda10fbd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;floating-point literal&lt;/em&gt; has one of two forms:</source>
          <target state="translated">&lt;em&gt;부동 소수점 리터럴&lt;/em&gt; 두 가지 형태 중 하나가 :</target>
        </trans-unit>
        <trans-unit id="4f4b1ebbfdc25acf10623629374f684851ce4095" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;function&lt;/em&gt; consists of a &lt;a href=&quot;../expressions/block-expr&quot;&gt;block&lt;/a&gt;, along with a name and a set of parameters. Other than a name, all these are optional. Functions are declared with the keyword &lt;code&gt;fn&lt;/code&gt;. Functions may declare a set of &lt;em&gt;input&lt;/em&gt;&lt;a href=&quot;../variables&quot;&gt;&lt;em&gt;variables&lt;/em&gt;&lt;/a&gt; as parameters, through which the caller passes arguments into the function, and the &lt;em&gt;output&lt;/em&gt;&lt;a href=&quot;../types#type-expressions&quot;&gt;&lt;em&gt;type&lt;/em&gt;&lt;/a&gt; of the value the function will return to its caller on completion.</source>
          <target state="translated">&lt;em&gt;기능은&lt;/em&gt; 구성&lt;a href=&quot;../expressions/block-expr&quot;&gt; 블록&lt;/a&gt; 의 이름 및 파라미터들의 세트와 함께,. 이름 이외의 모든 옵션은 선택 사항입니다. 함수는 키워드 &lt;code&gt;fn&lt;/code&gt; 으로 선언됩니다 . 함수는 &lt;em&gt;입력 &lt;/em&gt;&lt;a href=&quot;../variables&quot;&gt;&lt;em&gt;변수&lt;/em&gt;&lt;/a&gt; 세트를 매개 &lt;em&gt;변수&lt;/em&gt; 로 선언 할 수 있으며 ,이를 통해 호출자가 인수를 함수에 전달하고, 완료시 함수가 호출자에게 리턴 할 값의 &lt;em&gt;출력 &lt;/em&gt;&lt;a href=&quot;../types#type-expressions&quot;&gt;&lt;em&gt;유형&lt;/em&gt;&lt;/a&gt; 을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f85371a9c250b84e230a898102f42e92fb5ad83" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;generic function&lt;/em&gt; allows one or more &lt;em&gt;parameterized types&lt;/em&gt; to appear in its signature. Each type parameter must be explicitly declared in an angle-bracket-enclosed and comma-separated list, following the function name.</source>
          <target state="translated">&lt;em&gt;일반적인 기능은&lt;/em&gt; 하나 또는 그 이상의 수 &lt;em&gt;매개 변수 유형&lt;/em&gt; 의 서명에 나타납니다. 각 유형 매개 변수는 함수 이름 뒤에 꺾쇠 괄호로 묶고 쉼표로 구분 된 목록으로 명시 적으로 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="e5b0c06878c29b647a5cee7cefa81c23fca43579" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hash map&lt;/em&gt; allows you to associate a value with a particular key. It&amp;rsquo;s a particular implementation of the more general data structure called a &lt;em&gt;map&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;해시 맵은&lt;/em&gt; 특정 키 값을 연결할 수 있습니다. &lt;em&gt;map&lt;/em&gt; 이라는보다 일반적인 데이터 구조의 특정 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="d2dddac086e471872aa5bba992c51dee8e784e1c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hex literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;0x&lt;/code&gt;) and continues as any mixture (with at least one digit) of hex digits and underscores.</source>
          <target state="translated">ㅏ &lt;em&gt;헥스 리터럴&lt;/em&gt; 문자 시퀀스로 시작하는 &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+0078&lt;/code&gt; ( &lt;code&gt;0x&lt;/code&gt; )과 16 진수 밑줄의 임의의 혼합물 (상기 적어도 하나 명의 숫자로)로 계속된다.</target>
        </trans-unit>
        <trans-unit id="9e38a4ee6fc96f56c22e46e8162db6bbee2c0881" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;literal expression&lt;/em&gt; consists of one of the &lt;a href=&quot;../tokens#literals&quot;&gt;literal&lt;/a&gt; forms described earlier. It directly describes a number, character, string, or boolean value.</source>
          <target state="translated">&lt;em&gt;문자 표현&lt;/em&gt; 의 한 구성 &lt;a href=&quot;../tokens#literals&quot;&gt;문자&lt;/a&gt; 앞에서 설명한 형태. 숫자, 문자, 문자열 또는 부울 값을 직접 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ad9efa9913447a56224684e0aa75e5aeea6b8381" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;local variable&lt;/em&gt; (or &lt;em&gt;stack-local&lt;/em&gt; allocation) holds a value directly, allocated within the stack's memory. The value is a part of the stack frame.</source>
          <target state="translated">&lt;em&gt;로컬 변수&lt;/em&gt; (또는 &lt;em&gt;스택 로컬&lt;/em&gt; 할당) 스택의 메모리 내에 할당 직접 값을 보유하고있다. 값은 스택 프레임의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="5494ba7068df28e0c7f4a4e2a11fa8f85cf97050" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;match guard&lt;/em&gt; is an additional &lt;code&gt;if&lt;/code&gt; condition specified after the pattern in a &lt;code&gt;match&lt;/code&gt; arm that must also match, along with the pattern matching, for that arm to be chosen. Match guards are useful for expressing more complex ideas than a pattern alone allows.</source>
          <target state="translated">ㅏ &lt;em&gt;매치 가드&lt;/em&gt; 부가 인 &lt;code&gt;if&lt;/code&gt; 조건 A의 패턴 후 지정된 &lt;code&gt;match&lt;/code&gt; 이 아암 선택 될 수 있도록, 패턴 정합과 함께도 일치해야 아암. 매치 가드는 패턴만으로 허용되는 것보다 복잡한 아이디어를 표현하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="99824c60f6f2f15272aa4440e52b0f6ee9405ef8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;method call&lt;/em&gt; consists of an expression (the &lt;em&gt;receiver&lt;/em&gt;) followed by a single dot, an expression path segment, and a parenthesized expression-list. Method calls are resolved to associated &lt;a href=&quot;../items/associated-items#methods&quot;&gt;methods&lt;/a&gt; on specific traits, either statically dispatching to a method if the exact &lt;code&gt;self&lt;/code&gt;-type of the left-hand-side is known, or dynamically dispatching if the left-hand-side expression is an indirect &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;메소드 호출은&lt;/em&gt; 식 (이루어져의 &lt;em&gt;수신기&lt;/em&gt; 는 단일 도트 발현 경로 세그먼트, 및 괄호 표현리스트 하였다). 메소드 호출은 연관된 것으로 해석됩니다.&lt;a href=&quot;../items/associated-items#methods&quot;&gt;&lt;/a&gt;왼쪽 의 정확한 &lt;code&gt;self&lt;/code&gt; 유형을 알고있는 경우 메소드에 정적으로 디스패치 하거나 왼쪽 표현식이 간접 &lt;a href=&quot;../types/trait-object&quot;&gt;특성 오브젝트 인&lt;/a&gt; 경우 동적으로 디스패치하는 특정 특성의 메소드 .</target>
        </trans-unit>
        <trans-unit id="4326f6a26736f9868551af52753b80b0248e3c0e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;module item&lt;/em&gt; is a module, surrounded in braces, named, and prefixed with the keyword &lt;code&gt;mod&lt;/code&gt;. A module item introduces a new, named module into the tree of modules making up a crate. Modules can nest arbitrarily.</source>
          <target state="translated">&lt;em&gt;모듈 항목은&lt;/em&gt; 모듈, 괄호로 둘러싸인이라는 이름을 키워드로 시작입니다 &lt;code&gt;mod&lt;/code&gt; . 모듈 아이템은 상자를 구성하는 모듈 트리에 새로운 이름의 모듈을 도입합니다. 모듈은 임의로 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4782354728434eca4d6ed0db530842093ebdfbdf" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;number literal&lt;/em&gt; is either an &lt;em&gt;integer literal&lt;/em&gt; or a &lt;em&gt;floating-point literal&lt;/em&gt;. The grammar for recognizing the two kinds of literals is mixed.</source>
          <target state="translated">&lt;em&gt;숫자 리터럴은&lt;/em&gt; 어느 쪽이다&lt;em&gt; 정수 리터럴&lt;/em&gt; 또는 &lt;em&gt;부동 소수점 리터럴&lt;/em&gt; . 두 종류의 리터럴을 인식하는 문법이 혼합되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a1aa14aba61f76729922fa97eab5dfb14fd43e6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;path&lt;/em&gt; is a sequence of one or more path segments &lt;em&gt;logically&lt;/em&gt; separated by a namespace qualifier (&lt;code&gt;::&lt;/code&gt;). If a path consists of only one segment, it refers to either an &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; or a &lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; in a local control scope. If a path has multiple segments, it always refers to an item.</source>
          <target state="translated">&lt;em&gt;경로는&lt;/em&gt; 하나 개 이상의 경로 세그먼트의 서열이다 &lt;em&gt;논리적&lt;/em&gt; 이름 공간 한정자 (의해 분리 &lt;code&gt;::&lt;/code&gt; ). 경로가 하나의 세그먼트로만 구성된 경우 경로는&lt;a href=&quot;items&quot;&gt;&lt;/a&gt; 로컬 제어 범위 항목 또는 &lt;a href=&quot;variables&quot;&gt;변수&lt;/a&gt; 를 . 경로에 여러 세그먼트가 있으면 항상 항목을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bb92d4c241b315859972fd645fc7612b4dfc9464" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;place expression&lt;/em&gt; is an expression that represents a memory location. These expressions are &lt;a href=&quot;expressions/path-expr&quot;&gt;paths&lt;/a&gt; which refer to local variables, &lt;a href=&quot;items/static-items&quot;&gt;static variables&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereferences&lt;/a&gt; (&lt;code&gt;*expr&lt;/code&gt;), &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; expressions (&lt;code&gt;expr[expr]&lt;/code&gt;), &lt;a href=&quot;expressions/field-expr&quot;&gt;field&lt;/a&gt; references (&lt;code&gt;expr.f&lt;/code&gt;) and parenthesized place expressions. All other expressions are value expressions.</source>
          <target state="translated">&lt;em&gt;장소 식&lt;/em&gt; 메모리 위치를 나타내는 식이다. 이 표현식은 로컬 변수, &lt;a href=&quot;items/static-items&quot;&gt;정적 변수&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;역 참조&lt;/a&gt; ( &lt;code&gt;*expr&lt;/code&gt; ), &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;배열 인덱싱&lt;/a&gt; 표현식 ( &lt;code&gt;expr[expr]&lt;/code&gt; ), &lt;a href=&quot;expressions/field-expr&quot;&gt;필드&lt;/a&gt; 를 참조하는 &lt;a href=&quot;expressions/path-expr&quot;&gt;경로 &lt;/a&gt;입니다. 레퍼런스 ( &lt;code&gt;expr.f&lt;/code&gt; ) 및 괄호 장소 식. 다른 모든 표현식은 값 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="53e179d5349063cc7a43deec2333f4a66dd27469" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pointer&lt;/em&gt; is a general concept for a variable that contains an address in memory. This address refers to, or &amp;ldquo;points at,&amp;rdquo; some other data. The most common kind of pointer in Rust is a reference, which you learned about in Chapter 4. References are indicated by the &lt;code&gt;&amp;amp;&lt;/code&gt; symbol and borrow the value they point to. They don&amp;rsquo;t have any special capabilities other than referring to data. Also, they don&amp;rsquo;t have any overhead and are the kind of pointer we use most often.</source>
          <target state="translated">&lt;em&gt;포인터&lt;/em&gt; 메모리에 주소를 포함하는 변수에 대한 일반적인 개념이다. 이 주소는 다른 데이터를 가리 킵니다. Rust에서 가장 일반적인 종류의 포인터는 4 장에서 배운 참조입니다. 참조는 &lt;code&gt;&amp;amp;&lt;/code&gt; 기호 로 표시되며 그들이 가리키는 값을 빌립니다. 그들은 데이터를 언급하는 것 외에 특별한 기능이 없습니다. 또한 오버 헤드가 없으며 가장 자주 사용하는 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="7fe098911943171d28affe53c0c7d6311adf867c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;relative path&lt;/em&gt; starts from the current module and uses &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;super&lt;/code&gt;, or an identifier in the current module.</source>
          <target state="translated">&lt;em&gt;상대 경로는&lt;/em&gt; 현재 모듈 및 용법에서 시작 &lt;code&gt;self&lt;/code&gt; , &lt;code&gt;super&lt;/code&gt; 또는 현재 모듈 식별자.</target>
        </trans-unit>
        <trans-unit id="b7be095308c163f67b48127967466163200c85dc" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;scalar&lt;/em&gt; type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Let&amp;rsquo;s jump into how they work in Rust.</source>
          <target state="translated">ㅏ &lt;em&gt;스칼라&lt;/em&gt; 타입은 하나의 값을 나타낸다. Rust에는 정수, 부동 소수점 숫자, 부울 및 문자의 네 가지 기본 스칼라 유형이 있습니다. 다른 프로그래밍 언어에서이를 인식 할 수 있습니다. 그들이 Rust에서 어떻게 작동하는지 살펴 봅시다.</target>
        </trans-unit>
        <trans-unit id="5e00452619a2cd4e10d7a42ab9898d401215bca3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;statement&lt;/em&gt; is a component of a &lt;a href=&quot;expressions/block-expr&quot;&gt;block&lt;/a&gt;, which is in turn a component of an outer &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; or &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;문&lt;/em&gt; (A)의 구성 요소 인 &lt;a href=&quot;expressions/block-expr&quot;&gt;블록&lt;/a&gt; 차례로 외부의 구성 요소, &lt;a href=&quot;expressions&quot;&gt;표현&lt;/a&gt; 또는 &lt;a href=&quot;items/functions&quot;&gt;함수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9cd3832cf111028f53f6cad959deb6ad53f56ca0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;static item&lt;/em&gt; is similar to a &lt;a href=&quot;constant-items&quot;&gt;constant&lt;/a&gt;, except that it represents a precise memory location in the program. All references to the static refer to the same memory location. Static items have the &lt;code&gt;static&lt;/code&gt; lifetime, which outlives all other lifetimes in a Rust program. Non-&lt;code&gt;mut&lt;/code&gt; static items that contain a type that is not &lt;a href=&quot;../interior-mutability&quot;&gt;interior mutable&lt;/a&gt; may be placed in read-only memory. Static items do not call &lt;a href=&quot;../destructors&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; at the end of the program.</source>
          <target state="translated">&lt;em&gt;정적 항목&lt;/em&gt; A와 비슷 &lt;a href=&quot;constant-items&quot;&gt;상수&lt;/a&gt; 가 프로그램의 정확한 메모리 위치를 나타내는 것을 제외. 정적에 대한 모든 참조는 동일한 메모리 위치를 나타냅니다. 정적 아이템은 &lt;code&gt;static&lt;/code&gt; 수명을 가지며 , 이는 Rust 프로그램에서 다른 모든 수명보다 오래 지속됩니다. &lt;a href=&quot;../interior-mutability&quot;&gt;내부에서 변경할&lt;/a&gt; 수 없는 유형이 포함 된 비 &lt;code&gt;mut&lt;/code&gt; 정적 항목 은 읽기 전용 메모리에 배치 될 수 있습니다. 정적 아이템은 &lt;a href=&quot;../destructors&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; 호출하지 않습니다 프로그램 끝에서 을 .</target>
        </trans-unit>
        <trans-unit id="9ed445848ff0ebfb7d1082c79316c3f0dc94cf17" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;static item&lt;/em&gt; is similar to a &lt;a href=&quot;constant-items&quot;&gt;constant&lt;/a&gt;, except that it represents a precise memory location in the program. All references to the static refer to the same memory location. Static items have the &lt;code&gt;static&lt;/code&gt; lifetime, which outlives all other lifetimes in a Rust program. Static items do not call &lt;a href=&quot;../destructors&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; at the end of the program.</source>
          <target state="translated">&lt;em&gt;정적 항목&lt;/em&gt; A와 비슷 &lt;a href=&quot;constant-items&quot;&gt;상수&lt;/a&gt; 가 프로그램의 정확한 메모리 위치를 나타내는 것을 제외. 정적에 대한 모든 참조는 동일한 메모리 위치를 참조합니다. 정적 항목은 Rust 프로그램의 다른 모든 수명보다 오래 지속 되는 &lt;code&gt;static&lt;/code&gt; 수명을 갖습니다 . 정적 항목은 프로그램 끝에서 &lt;a href=&quot;../destructors&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; 을 호출하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="045ded2942d599b289c8f6860ad989b955a99d7c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string literal&lt;/em&gt; is a sequence of any Unicode characters enclosed within two &lt;code&gt;U+0022&lt;/code&gt; (double-quote) characters, with the exception of &lt;code&gt;U+0022&lt;/code&gt; itself, which must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;문자열 리터럴&lt;/em&gt; 이 묶여 유니 코드 문자의 순서입니다 &lt;code&gt;U+0022&lt;/code&gt; 를 제외하고, (큰 따옴표) 문자 &lt;code&gt;U+0022&lt;/code&gt; 해야 자체 &lt;em&gt;탈출&lt;/em&gt; 선행에 의해 &lt;code&gt;U+005C&lt;/code&gt; 문자 ( &lt;code&gt;\&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f12122f88fa635dd2b58aa377fdb09d19aba988d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string slice&lt;/em&gt; is a reference to part of a &lt;code&gt;String&lt;/code&gt;, and it looks like this:</source>
          <target state="translated">&lt;em&gt;문자열 슬라이스&lt;/em&gt; (A)의 일부에 대한 참조입니다 &lt;code&gt;String&lt;/code&gt; , 그것은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="691e369dd4289704604ecf4cd7dd7181b87971ad" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string&lt;/em&gt; is a collection of characters. We&amp;rsquo;ve mentioned the &lt;code&gt;String&lt;/code&gt; type previously, but in this chapter we&amp;rsquo;ll talk about it in depth.</source>
          <target state="translated">&lt;em&gt;문자열은&lt;/em&gt; 문자의 모음입니다. 우리는 &lt;code&gt;String&lt;/code&gt; 언급했습니다 유형에 했지만이 장에서는 이에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ac2f7e212f4d47b7d6ba3c1b79c057cc109911ff" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct expression&lt;/em&gt; creates a struct or union value. It consists of a path to a &lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt; item followed by the values for the fields of the item. There are three forms of struct expressions: struct, tuple, and unit.</source>
          <target state="translated">&lt;em&gt;구조체 식&lt;/em&gt; 구조체 또는 조합 값을 생성합니다. &lt;a href=&quot;../items/structs&quot;&gt;구조체&lt;/a&gt; 또는 &lt;a href=&quot;../items/unions&quot;&gt;공용체&lt;/a&gt; 에 대한 경로로 구성됩니다. 아이템 아이템 필드의 값으로 구성됩니다. 구조체 표현에는 구조체, 튜플 및 단위의 세 가지 형태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d65205e4e512b884279b051d3f883110c3677542" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct&lt;/em&gt; is a nominal &lt;a href=&quot;../types/struct&quot;&gt;struct type&lt;/a&gt; defined with the keyword &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;구조체는&lt;/em&gt; 공칭입니다 &lt;a href=&quot;../types/struct&quot;&gt;구조체 형식&lt;/a&gt; 키워드로 정의 &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b38ad3b7538f97629f5686d68a34da8981cf5d0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct&lt;/em&gt;, or &lt;em&gt;structure&lt;/em&gt;, is a custom data type that lets you name and package together multiple related values that make up a meaningful group. If you&amp;rsquo;re familiar with an object-oriented language, a &lt;em&gt;struct&lt;/em&gt; is like an object&amp;rsquo;s data attributes. In this chapter, we&amp;rsquo;ll compare and contrast tuples with structs, demonstrate how to use structs, and discuss how to define methods and associated functions to specify behavior associated with a struct&amp;rsquo;s data. Structs and enums (discussed in Chapter 6) are the building blocks for creating new types in your program&amp;rsquo;s domain to take full advantage of Rust&amp;rsquo;s compile time type checking.</source>
          <target state="translated">&lt;em&gt;구조체&lt;/em&gt; , 또는 &lt;em&gt;구조&lt;/em&gt; , 당신은 이름을 지정하고 의미있는 그룹을 만들어 함께 여러 관련 값을 패키징 할 수있는 사용자 정의 데이터 유형입니다. 객체 지향 언어에 익숙하다면 &lt;em&gt;구조체&lt;/em&gt; 는 객체의 데이터 속성과 같습니다. 이 장에서는 튜플을 구조체와 비교 및 ​​대조하고, 구조체를 사용하는 방법을 보여 주며, 구조체의 데이터와 관련된 동작을 지정하는 메서드 및 관련 함수를 정의하는 방법에 대해 설명합니다. Structs와 enum (6 장에서 논의)은 Rust의 컴파일 타임 타입 검사를 최대한 활용하기 위해 프로그램 도메인에서 새로운 타입을 생성하기위한 빌딩 블록입니다.</target>
        </trans-unit>
        <trans-unit id="c2b858ff2e5a4ed485b3e5e4a18471183d07402f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;test double&lt;/em&gt; is the general programming concept for a type used in place of another type during testing. &lt;em&gt;Mock objects&lt;/em&gt; are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.</source>
          <target state="translated">&lt;em&gt;시험은 두 번&lt;/em&gt; 테스트 중에 다른 유형의 장소에서 사용되는 유형에 대한 일반 프로그래밍 개념이다. &lt;em&gt;모의 객체&lt;/em&gt; 는 테스트 중에 발생하는 상황을 기록하는 특정 유형의 테스트 복식으로 올바른 동작이 발생했는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a0e24d887e877ac9c41e5667ab7a119a4c29456" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;thread pool&lt;/em&gt; is a group of spawned threads that are waiting and ready to handle a task. When the program receives a new task, it assigns one of the threads in the pool to the task, and that thread will process the task. The remaining threads in the pool are available to handle any other tasks that come in while the first thread is processing. When the first thread is done processing its task, it&amp;rsquo;s returned to the pool of idle threads, ready to handle a new task. A thread pool allows you to process connections concurrently, increasing the throughput of your server.</source>
          <target state="translated">&lt;em&gt;스레드 풀&lt;/em&gt; 기다리고 작업을 처리 할 준비가되어 산란 스레드 그룹입니다. 프로그램이 새 작업을 받으면 풀의 스레드 중 하나를 작업에 할당하면 해당 스레드가 작업을 처리합니다. 풀의 나머지 스레드는 첫 번째 스레드가 처리되는 동안 들어오는 다른 작업을 처리하는 데 사용할 수 있습니다. 첫 번째 스레드가 작업 처리를 완료하면 유휴 스레드 풀로 반환되어 새 작업을 처리 할 수 ​​있습니다. 스레드 풀을 사용하면 연결을 동시에 처리하여 서버의 처리량을 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="313b18e83bc534426ba5a3363e3ef30c68738ffe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait implementation&lt;/em&gt; is defined like an inherent implementation except that the optional generic type declarations is followed by a &lt;a href=&quot;traits&quot;&gt;trait&lt;/a&gt; followed by the keyword &lt;code&gt;for&lt;/code&gt;. Followed by a path to a nominal type.</source>
          <target state="translated">&lt;em&gt;특성 구현은&lt;/em&gt; 선택 사양 제네릭 형식 선언이 뒤에 것을 제외하고 고유의 구현과 같이 정의 &lt;a href=&quot;traits&quot;&gt;특성&lt;/a&gt; 키워드 다음 &lt;code&gt;for&lt;/code&gt; . 공칭 유형에 대한 경로가 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="61547573b3bf424e11f1f4f9cd8d9184f5546ee1" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait object&lt;/em&gt; is an opaque value of another type that implements a set of traits. A trait object implements all specified traits as well as their supertraits (if any).</source>
          <target state="translated">&lt;em&gt;특성 객체는&lt;/em&gt; 다른 종류의 특성을 구현하는 일련의 불투명 한 값이다. 특성 개체는 지정된 모든 특성과 해당 상위 특성 (있는 경우)을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="2ba7bca2e53443f2e59cd9b7a5cdc8e34241ae48" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait object&lt;/em&gt; is an opaque value of another type that implements a set of traits. The set of traits is made up of an &lt;a href=&quot;../items/traits#object-safety&quot;&gt;object safe&lt;/a&gt;&lt;em&gt;base trait&lt;/em&gt; plus any number of &lt;a href=&quot;../special-types-and-traits#auto-traits&quot;&gt;auto traits&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;특성 객체는&lt;/em&gt; 다른 종류의 특성을 구현하는 일련의 불투명 한 값이다. 특성 세트는 &lt;a href=&quot;../items/traits#object-safety&quot;&gt;객체 안전 &lt;/a&gt;&lt;em&gt;기본 특성&lt;/em&gt; 과 여러 &lt;a href=&quot;../special-types-and-traits#auto-traits&quot;&gt;자동 특성으로 구성&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="5df129cc6b630156d556e5813378ed108b2ab443" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait&lt;/em&gt; describes an abstract interface that types can implement. This interface consists of &lt;a href=&quot;associated-items&quot;&gt;associated items&lt;/a&gt;, which come in three varieties:</source>
          <target state="translated">&lt;em&gt;특성은&lt;/em&gt; 유형을 구현할 수 있다는 추상적 인 인터페이스를 설명합니다. 이 인터페이스는 &lt;a href=&quot;associated-items&quot;&gt;관련 항목으로&lt;/a&gt; 구성 되며 세 가지 유형으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a413d8d80703ed47836b183924cabc19246e5f7c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait&lt;/em&gt; tells the Rust compiler about functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic can be any type that has certain behavior.</source>
          <target state="translated">&lt;em&gt;특성은&lt;/em&gt; 특정 유형이 다른 유형과 공유 할 수있는 기능에 대해 녹 컴파일러를 알려줍니다. 특성을 사용하여 추상적 인 방식으로 공유 동작을 정의 할 수 있습니다. 특성 경계를 사용하여 제네릭이 특정 동작이있는 모든 유형이 될 수 있음을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9018c5e20d838075d5b138f7d86d8d8c684fb244" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple index&lt;/em&gt; is either &lt;code&gt;0&lt;/code&gt;, or starts with a &lt;em&gt;non-zero decimal digit&lt;/em&gt; and continues with zero or more decimal digits. Tuple indexes are used to refer to the fields of &lt;a href=&quot;types/tuple&quot;&gt;tuples&lt;/a&gt;, &lt;a href=&quot;items/structs&quot;&gt;tuple structs&lt;/a&gt; and &lt;a href=&quot;items/enumerations&quot;&gt;tuple variants&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;튜플 인덱스&lt;/em&gt; 하나이고 &lt;code&gt;0&lt;/code&gt; 또는로 시작 &lt;em&gt;비제 소수점 자리수&lt;/em&gt; 와 0 개 이상의 십진수로 계속된다. 튜플 인덱스는 &lt;a href=&quot;types/tuple&quot;&gt;튜플&lt;/a&gt; , &lt;a href=&quot;items/structs&quot;&gt;튜플 구조체&lt;/a&gt; 및 &lt;a href=&quot;items/enumerations&quot;&gt;튜플 변형&lt;/a&gt; 의 필드를 나타내는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c47a882c5415e255f49931b3989ce3cbb03e65f7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple struct&lt;/em&gt; is a nominal &lt;a href=&quot;../types/tuple&quot;&gt;tuple type&lt;/a&gt;, also defined with the keyword &lt;code&gt;struct&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;em&gt;튜플 구조체는&lt;/em&gt; 공칭입니다 &lt;a href=&quot;../types/tuple&quot;&gt;튜플 형식&lt;/a&gt; 또한 키워드를 사용하여 정의, &lt;code&gt;struct&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e97b14c685e031728ecd4469c910a8f3603e601d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple struct&lt;/em&gt; type is just like a struct type, except that the fields are anonymous.</source>
          <target state="translated">&lt;em&gt;튜플 구조체의&lt;/em&gt; 유형은 필드가 익명 것을 제외하고, 단지 구조체 형과 같다.</target>
        </trans-unit>
        <trans-unit id="57b75c1dd6681cfbd15ca11a1f0f5681b515a0f3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type alias&lt;/em&gt; defines a new name for an existing &lt;a href=&quot;../types&quot;&gt;type&lt;/a&gt;. Type aliases are declared with the keyword &lt;code&gt;type&lt;/code&gt;. Every value has a single, specific type, but may implement several different traits, or be compatible with several different type constraints.</source>
          <target state="translated">&lt;em&gt;타입 별칭은&lt;/em&gt; 기존의 새 이름을 정의하는 &lt;a href=&quot;../types&quot;&gt;유형&lt;/a&gt; . 유형 별명은 키워드 &lt;code&gt;type&lt;/code&gt; 으로 선언됩니다 . 모든 값에는 하나의 특정 유형이 있지만 여러 가지 특성을 구현하거나 여러 가지 유형 제한 조건과 호환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64ff4b8d7e3ee42067c7072aacfc14cd027c093c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type expression&lt;/em&gt; as defined in the &lt;em&gt;Type&lt;/em&gt; grammar rule above is the syntax for referring to a type. It may refer to:</source>
          <target state="translated">&lt;em&gt;형 표현&lt;/em&gt; 에 정의로 &lt;em&gt;입력&lt;/em&gt; 문법 규칙은 전술 한 유형을 참조하는 구문이다. 다음을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50c0af6b4bb64ca1523e3b2abba8e82a69abff5a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;union type&lt;/em&gt; is a nominal, heterogeneous C-like union, denoted by the name of a &lt;a href=&quot;../items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt; item&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;유니온 타입&lt;/em&gt; (A)의 이름 붙이고 공칭 이종 C 형상의 조합 인 &lt;a href=&quot;../items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; 아이템&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="96e68805af9609cb7109b9bd3ef8c3be60b740ca" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;unit-like struct&lt;/em&gt; is a struct without any fields, defined by leaving off the list of fields entirely. Such a struct implicitly defines a constant of its type with the same name. For example:</source>
          <target state="translated">&lt;em&gt;유닛 형 구조체&lt;/em&gt; 전체 필드 목록을 남김으로써 정의 된 필드가없는 구조체이다. 이러한 구조체는 동일한 이름을 가진 유형의 상수를 암시 적으로 정의합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6075d4cd12c28e60ac874060f12974e3762a509a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;unit-like struct&lt;/em&gt; type is like a struct type, except that it has no fields. The one value constructed by the associated &lt;a href=&quot;../expressions/struct-expr&quot;&gt;struct expression&lt;/a&gt; is the only value that inhabits such a type.</source>
          <target state="translated">&lt;em&gt;구조체 부 형상&lt;/em&gt; 타입은 어떤 필드가 없다는 것을 제외하고, 구조체의 형태와 같다. 연관된 &lt;a href=&quot;../expressions/struct-expr&quot;&gt;구조체 표현식으로&lt;/a&gt; 구성된 하나의 값 은 이러한 유형에있는 유일한 값입니다.</target>
        </trans-unit>
        <trans-unit id="ed7d45b3f3a4f92438f32980c894150a8a0dee9d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;use declaration&lt;/em&gt; creates one or more local name bindings synonymous with some other &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt;. Usually a &lt;code&gt;use&lt;/code&gt; declaration is used to shorten the path required to refer to a module item. These declarations may appear in &lt;a href=&quot;modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;../expressions/block-expr&quot;&gt;blocks&lt;/a&gt;, usually at the top.</source>
          <target state="translated">&lt;em&gt;사용 선언은&lt;/em&gt; 다른과 동의어 하나 이상의 로컬 이름 바인딩 생성 &lt;a href=&quot;../paths&quot;&gt;경로를&lt;/a&gt; . 일반적으로 &lt;code&gt;use&lt;/code&gt; 선언은 모듈 항목을 참조하는 데 필요한 경로를 단축하는 데 사용됩니다. 이러한 선언은 일반적으로 맨 위에 &lt;a href=&quot;modules&quot;&gt;모듈&lt;/a&gt; 과 &lt;a href=&quot;../expressions/block-expr&quot;&gt;블록에&lt;/a&gt; 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d8a654904db4cbe04f06da827ae2d7d450774ec" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;value expression&lt;/em&gt; is an expression that represents an actual value.</source>
          <target state="translated">&lt;em&gt;값 식은&lt;/em&gt; 실제의 값을 나타내는 식이다.</target>
        </trans-unit>
        <trans-unit id="e6fd1c9fb448dc3050e431f7efdd6fccf7fb69e9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a component of a stack frame, either a named function parameter, an anonymous &lt;a href=&quot;expressions#temporaries&quot;&gt;temporary&lt;/a&gt;, or a named local variable.</source>
          <target state="translated">&lt;em&gt;변수는&lt;/em&gt; 스택 프레임의 구성 요소 중 하나라는 함수 파라미터 익명 인 &lt;a href=&quot;expressions#temporaries&quot;&gt;임시&lt;/a&gt; 또는 로컬 변수의 이름.</target>
        </trans-unit>
        <trans-unit id="729fdc3c2a54819bca891fd0485aedb791a49cea" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a component of a stack frame, either a named function parameter, an anonymous &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporary&lt;/a&gt;, or a named local variable.</source>
          <target state="translated">&lt;em&gt;변수는&lt;/em&gt; 스택 프레임의 구성 요소 중 하나라는 함수 파라미터 익명 인 &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;임시&lt;/a&gt; 또는 로컬 변수의 이름.</target>
        </trans-unit>
        <trans-unit id="81028e39252e1de4d0939b21f1ccc9432b693d6d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;vector&lt;/em&gt; allows you to store a variable number of values next to each other.</source>
          <target state="translated">&lt;em&gt;벡터&lt;/em&gt; 는 서로 옆에 값의 변수 번호를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbf31b3f11b4472e6a3c452469774ef2fe901798" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;whitespace escape&lt;/em&gt; is one of the characters &lt;code&gt;U+006E&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt;), &lt;code&gt;U+0072&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;), or &lt;code&gt;U+0074&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt;), denoting the Unicode values &lt;code&gt;U+000A&lt;/code&gt; (LF), &lt;code&gt;U+000D&lt;/code&gt; (CR) or &lt;code&gt;U+0009&lt;/code&gt; (HT) respectively.</source>
          <target state="translated">&lt;em&gt;공백 탈출&lt;/em&gt; 문자 중 하나이며 &lt;code&gt;U+006E&lt;/code&gt; ( &lt;code&gt;n&lt;/code&gt; ), &lt;code&gt;U+0072&lt;/code&gt; ( &lt;code&gt;r&lt;/code&gt; ) 또는 &lt;code&gt;U+0074&lt;/code&gt; ( &lt;code&gt;t&lt;/code&gt; 유니 값들 나타내는) &lt;code&gt;U+000A&lt;/code&gt; (LF), &lt;code&gt;U+000D&lt;/code&gt; (CR) 또는 &lt;code&gt;U+0009&lt;/code&gt; (HT).</target>
        </trans-unit>
        <trans-unit id="733e62321cc2dbb502882e64ee8c595f1cf223e3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;whitespace escape&lt;/em&gt; is one of the characters &lt;code&gt;U+006E&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt;), &lt;code&gt;U+0072&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;), or &lt;code&gt;U+0074&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt;), denoting the bytes values &lt;code&gt;0x0A&lt;/code&gt; (ASCII LF), &lt;code&gt;0x0D&lt;/code&gt; (ASCII CR) or &lt;code&gt;0x09&lt;/code&gt; (ASCII HT) respectively.</source>
          <target state="translated">&lt;em&gt;공백 탈출&lt;/em&gt; 문자 중 하나이며 &lt;code&gt;U+006E&lt;/code&gt; ( &lt;code&gt;n&lt;/code&gt; ), &lt;code&gt;U+0072&lt;/code&gt; ( &lt;code&gt;r&lt;/code&gt; ) 또는 &lt;code&gt;U+0074&lt;/code&gt; ( &lt;code&gt;t&lt;/code&gt; (가) 값 바이트를 나타내는) &lt;code&gt;0x0A&lt;/code&gt; (ASCII의 LF) &lt;code&gt;0x0D&lt;/code&gt; (ASCII CR) 또는 &lt;code&gt;0x09&lt;/code&gt; (ASCII HT ).</target>
        </trans-unit>
        <trans-unit id="17736723b13336b3d27ceb298ec5fb02952febad" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;workspace&lt;/em&gt; is a set of packages that share the same &lt;em&gt;Cargo.lock&lt;/em&gt; and output directory. Let&amp;rsquo;s make a project using a workspace&amp;mdash;we&amp;rsquo;ll use trivial code so we can concentrate on the structure of the workspace. There are multiple ways to structure a workspace; we&amp;rsquo;re going to show one common way. We&amp;rsquo;ll have a workspace containing a binary and two libraries. The binary, which will provide the main functionality, will depend on the two libraries. One library will provide an &lt;code&gt;add_one&lt;/code&gt; function, and a second library an &lt;code&gt;add_two&lt;/code&gt; function. These three crates will be part of the same workspace. We&amp;rsquo;ll start by creating a new directory for the workspace:</source>
          <target state="translated">&lt;em&gt;작업 공간은&lt;/em&gt; 같은 공유 패키지 세트입니다 &lt;em&gt;Cargo.lock&lt;/em&gt; 출력 디렉토리를. 작업 공간을 사용하여 프로젝트를 만들어 봅시다. 간단한 코드를 사용하여 작업 공간의 구조에 집중할 수 있습니다. 작업 공간을 구성하는 방법에는 여러 가지가 있습니다. 우리는 하나의 일반적인 방법을 보여줄 것입니다. 바이너리와 두 개의 라이브러리가 포함 된 작업 공간이 있습니다. 주요 기능을 제공 할 바이너리는 두 라이브러리에 따라 다릅니다. 하나의 라이브러리가 제공됩니다 &lt;code&gt;add_one&lt;/code&gt; 의 기능, 두 번째 라이브러리 &lt;code&gt;add_two&lt;/code&gt; 기능을. 이 3 개의 상자는 동일한 작업 공간의 일부가됩니다. 작업 공간을위한 새로운 디렉토리를 생성하는 것으로 시작하겠습니다 :</target>
        </trans-unit>
        <trans-unit id="57b97a971f9a5924055674cfb5ecccdeda84f005" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;multiprocessor&lt;/strong&gt; system executing multiple hardware threads at the same time: In multi-threaded scenarios, you can use two kinds of primitives to deal with synchronization:</source>
          <target state="translated">다중 하드웨어 스레드를 동시에 실행 하는 &lt;strong&gt;다중 프로세서&lt;/strong&gt; 시스템 : 다중 스레드 시나리오에서는 두 가지 유형의 기본 요소를 사용하여 동기화를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="9915cb86be4513e2479c88bd6630c4bace88619c" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;send&lt;/strong&gt; operation can only fail if the receiving end of a channel is disconnected, implying that the data could never be received. The error contains the data being sent as a payload so it can be recovered.</source>
          <target state="translated">&lt;strong&gt;전송&lt;/strong&gt; 채널의 수신 측이 데이터가 수신되지 않을 수 있음을 암시 분리되면 조작은 실패 할 수 있습니다. 오류는 복구 할 수 있도록 페이로드로 전송되는 데이터를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="45d6b0e56e209127760ab52ba9ab193c0dce03db" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;single processor&lt;/strong&gt; executing instructions &lt;a href=&quot;https://en.wikipedia.org/wiki/Out-of-order_execution&quot;&gt;out-of-order&lt;/a&gt;: Modern CPUs are capable of &lt;a href=&quot;https://en.wikipedia.org/wiki/Superscalar_processor&quot;&gt;superscalar&lt;/a&gt; execution, i.e., multiple instructions might be executing at the same time, even though the machine code describes a sequential process.</source>
          <target state="translated">&lt;strong&gt;단일 프로세서&lt;/strong&gt; 명령어 실행 &lt;a href=&quot;https://en.wikipedia.org/wiki/Out-of-order_execution&quot;&gt;밖으로의 순서를&lt;/a&gt; : 현대 CPU는 할 수있는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Superscalar_processor&quot;&gt;슈퍼 스칼라&lt;/a&gt; , 여러 지침은 기계 코드가 순차적 인 프로세스를 설명에도 불구하고, 동시에 실행 될 수있다 즉 실행.</target>
        </trans-unit>
        <trans-unit id="f80e6281478ac21b10d3f64a5db5116d11300661" translate="yes" xml:space="preserve">
          <source>A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing this, we reduce the number of allocations by a factor of B, and improve cache efficiency in searches. However, this does mean that searches will have to do &lt;em&gt;more&lt;/em&gt; comparisons on average. The precise number of comparisons depends on the node search strategy used. For optimal cache efficiency, one could search the nodes linearly. For optimal comparisons, one could search the node using binary search. As a compromise, one could also perform a linear search that initially only checks every i&lt;sup&gt;th&lt;/sup&gt; element for some choice of i.</source>
          <target state="translated">대신 B- 트리는 각 노드에 연속 배열의 B-1 ~ 2B-1 요소를 포함시킵니다. 이를 통해 B 수만큼 할당 수를 줄이고 검색시 캐시 효율성을 향상시킵니다. 그러나 이것은 검색이 평균적으로 &lt;em&gt;더 많은&lt;/em&gt; 비교 를 수행해야 함을 의미합니다 . 정확한 비교 수는 사용 된 노드 검색 전략에 따라 다릅니다. 최적의 캐시 효율성을 위해 노드를 선형으로 검색 할 수 있습니다. 최적의 비교를 위해 이진 검색을 사용하여 노드를 검색 할 수 있습니다. 타협으로, 처음에는 모든 i &lt;sup&gt;번째&lt;/sup&gt; 요소 만 i의 선택을 확인하는 선형 검색을 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c64fcf1b73694ea8bba81897d2a64705afb1b18" translate="yes" xml:space="preserve">
          <source>A C-variadic type is used to give an undefined number of parameters to a given function (like &lt;code&gt;printf&lt;/code&gt; in C). The equivalent in Rust would be to use macros directly (like &lt;code&gt;println!&lt;/code&gt; for example).</source>
          <target state="translated">C-variadic 유형은 지정된 함수에 정의되지 않은 수의 매개 변수를 제공하는 데 사용됩니다 (예 : C의 &lt;code&gt;printf&lt;/code&gt; ). Rust에서 동등한 것은 매크로를 직접 사용하는 것입니다 (예 : &lt;code&gt;println!&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c719a71ad064f07814cb183dc83cacff56d42170" translate="yes" xml:space="preserve">
          <source>A Closer Look at an HTTP Request</source>
          <target state="translated">HTTP 요청 자세히 살펴보기</target>
        </trans-unit>
        <trans-unit id="225f2cd7742ef94df62bae5174a9097b85507248" translate="yes" xml:space="preserve">
          <source>A Condition Variable</source>
          <target state="translated">조건 변수</target>
        </trans-unit>
        <trans-unit id="e89d14f838ea1a71651772640c4009592aced676" translate="yes" xml:space="preserve">
          <source>A Rust binary or library.</source>
          <target state="translated">Rust 바이너리 또는 라이브러리.</target>
        </trans-unit>
        <trans-unit id="16eac1f550799edbb7e48476dda921af52e9a679" translate="yes" xml:space="preserve">
          <source>A Rust program has identical meaning if each whitespace element is replaced with any other legal whitespace element, such as a single space character.</source>
          <target state="translated">각 공백 요소가 단일 공백 ​​문자와 같은 다른 유효한 공백 요소로 대체되는 경우 Rust 프로그램은 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="3436eb9d1ac524996565fc93c80cf6376e000505" translate="yes" xml:space="preserve">
          <source>A Rust source file describes a module, the name and location of which &amp;mdash; in the module tree of the current crate &amp;mdash; are defined from outside the source file: either by an explicit &lt;a href=&quot;items/modules&quot;&gt;&lt;em&gt;Module&lt;/em&gt;&lt;/a&gt; item in a referencing source file, or by the name of the crate itself. Every source file is a module, but not every module needs its own source file: &lt;a href=&quot;items/modules&quot;&gt;module definitions&lt;/a&gt; can be nested within one file.</source>
          <target state="translated">Rust 소스 파일은 현재 상자의 모듈 트리에서 모듈의 이름과 위치를 소스 파일 외부에서 정의 합니다 (참조 소스 파일 의 명시 적 &lt;a href=&quot;items/modules&quot;&gt;&lt;em&gt;모듈&lt;/em&gt;&lt;/a&gt; 항목 또는 상자 자체. 모든 소스 파일은 모듈이지만 모든 모듈에 고유 한 소스 파일이 필요한 것은 아닙니다. &lt;a href=&quot;items/modules&quot;&gt;모듈 정의&lt;/a&gt; 는 하나의 파일 내에 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e4ee862d170940577240b6a363de9c90118288a" translate="yes" xml:space="preserve">
          <source>A Shortcut for Propagating Errors: the &lt;code id=&quot;a-shortcut-for-propagating-errors-the--operator&quot;&gt;?&lt;/code&gt; Operator</source>
          <target state="translated">오류 전파를위한 지름길 : &lt;code id=&quot;a-shortcut-for-propagating-errors-the--operator&quot;&gt;?&lt;/code&gt; 운영자</target>
        </trans-unit>
        <trans-unit id="e0701ba8496c6c0ce0663c50dfed3d1742ffe428" translate="yes" xml:space="preserve">
          <source>A TCP socket server, listening for connections.</source>
          <target state="translated">연결을 청취하는 TCP 소켓 서버.</target>
        </trans-unit>
        <trans-unit id="18b391c1b0a22ff1e173b47c159e749d6face6b8" translate="yes" xml:space="preserve">
          <source>A TCP stream between a local and a remote socket.</source>
          <target state="translated">로컬 소켓과 원격 소켓 사이의 TCP 스트림.</target>
        </trans-unit>
        <trans-unit id="14cd46b40ffb5428999e053c5d3b3c28ef9b4547" translate="yes" xml:space="preserve">
          <source>A Touch of Refactoring</source>
          <target state="translated">리팩토링의 손길</target>
        </trans-unit>
        <trans-unit id="f8b80e8d44eb439e0e6a949110529d41c8e00ad6" translate="yes" xml:space="preserve">
          <source>A Tour of The Rust Standard Library</source>
          <target state="translated">녹 표준 도서관 둘러보기</target>
        </trans-unit>
        <trans-unit id="816b40a1a34bc0276678819c021264566903408c" translate="yes" xml:space="preserve">
          <source>A UDP socket.</source>
          <target state="translated">UDP 소켓.</target>
        </trans-unit>
        <trans-unit id="276e8a17fbe2956e663b37ba194fe05fa5a8f2c4" translate="yes" xml:space="preserve">
          <source>A UTF-8 encoded, growable string.</source>
          <target state="translated">UTF-8로 인코딩되고 확장 가능한 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="9de745a43beb358e074abd87790ad347e9b21ca2" translate="yes" xml:space="preserve">
          <source>A UTF-8&amp;ndash;encoded, growable string.</source>
          <target state="translated">UTF-8로 인코딩되고 확장 가능한 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="bb20973ca0b74c01c90760f89fd1e1ce6ddd0490" translate="yes" xml:space="preserve">
          <source>A Unix datagram socket.</source>
          <target state="translated">유닉스 데이터 그램 소켓.</target>
        </trans-unit>
        <trans-unit id="735c3a01ab88f3b77275bbda413fc5d0f8e00e4c" translate="yes" xml:space="preserve">
          <source>A Unix socket Ancillary data struct.</source>
          <target state="translated">유닉스 소켓 보조 데이터 구조체.</target>
        </trans-unit>
        <trans-unit id="a23c9f511bfc020ca8a27e2556501e3c327d1d73" translate="yes" xml:space="preserve">
          <source>A Unix stream socket.</source>
          <target state="translated">유닉스 스트림 소켓.</target>
        </trans-unit>
        <trans-unit id="3ad52f3aeb1d324427854f3ea2a73655c8ec06e9" translate="yes" xml:space="preserve">
          <source>A Use Case for Interior Mutability: Mock Objects</source>
          <target state="translated">내부 돌연변이 성을위한 유스 케이스 : 모의 객체</target>
        </trans-unit>
        <trans-unit id="822d2ee37fadc9a2c447d0ca642e7e4a4d011579" translate="yes" xml:space="preserve">
          <source>A Windows path prefix, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\\server\share&lt;/code&gt;.</source>
          <target state="translated">Windows 경로 접두사 (예 &lt;code&gt;C:&lt;/code&gt; 또는 &lt;code&gt;\\server\share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37a911d0c1b6b4316ddb2ac619c44257424a4bb3" translate="yes" xml:space="preserve">
          <source>A Windows path prefix, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\server\share&lt;/code&gt;.</source>
          <target state="translated">윈도우 경로 접두어, 예를 들어, &lt;code&gt;C:&lt;/code&gt; 또는 &lt;code&gt;\server\share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41a63844a54d0452136942153b7bfc3f9e8d7950" translate="yes" xml:space="preserve">
          <source>A backtrace has been captured and the &lt;code&gt;Backtrace&lt;/code&gt; should print reasonable information when rendered.</source>
          <target state="translated">역 추적 캡처되었으며, &lt;code&gt;Backtrace&lt;/code&gt; 렌더링 될 때 적절한 정보를 인쇄해야합니다.</target>
        </trans-unit>
        <trans-unit id="063c41d44c26a8e514637789567756dedf001744" translate="yes" xml:space="preserve">
          <source>A backtrace is typically quite handy to attach to errors (e.g. types implementing &lt;code&gt;std::error::Error&lt;/code&gt;) to get a causal chain of where an error was generated.</source>
          <target state="translated">역 추적은 일반적으로 오류 (예 : &lt;code&gt;std::error::Error&lt;/code&gt; 구현하는 유형 )에 연결하여 오류가 생성 된 위치의 인과 관계 를 파악하는 데 매우 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="ff93a614690d1d51c188c5129e768aec7cd0c763" translate="yes" xml:space="preserve">
          <source>A barrier enables multiple threads to synchronize the beginning of some computation.</source>
          <target state="translated">장벽은 여러 스레드가 일부 계산의 시작을 동기화 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="c1ac9e66093aa4ca440868ee501f91a3a0e906b0" translate="yes" xml:space="preserve">
          <source>A barrier will block &lt;code&gt;n&lt;/code&gt;-1 threads which call &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; and then wake up all threads at once when the &lt;code&gt;n&lt;/code&gt;th thread calls &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">장벽은 &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 를 호출 한 &lt;code&gt;n&lt;/code&gt; -1 스레드를 차단 한 다음 &lt;code&gt;n&lt;/code&gt; 번째 스레드 호출이 &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 할 때 모든 스레드를 한 번에 깨 웁니다 .</target>
        </trans-unit>
        <trans-unit id="62ccc167e0423bac501b2cd57e5b7720dec15103" translate="yes" xml:space="preserve">
          <source>A barrier will block &lt;code&gt;n&lt;/code&gt;-1 threads which call &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; and then wake up all threads at once when the &lt;code&gt;n&lt;/code&gt;th thread calls &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">장벽은 &lt;a href=&quot;struct.barrier#method.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 를 호출하는 &lt;code&gt;n&lt;/code&gt; -1 스레드를 차단 한 다음 &lt;code&gt;n&lt;/code&gt; 번째 스레드가 &lt;a href=&quot;struct.barrier#method.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 호출 할 때 한 번에 모든 스레드를 깨 웁니다 .</target>
        </trans-unit>
        <trans-unit id="58cdbd4e4749375a003884d9f4eb272538b31a8e" translate="yes" xml:space="preserve">
          <source>A basic example:</source>
          <target state="translated">기본 예 :</target>
        </trans-unit>
        <trans-unit id="b427e17a0965dfac7d96b4ee22a549d95854674d" translate="yes" xml:space="preserve">
          <source>A basic string declaration of &lt;code&gt;&amp;amp;str&lt;/code&gt; type:</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; 유형 의 기본 문자열 선언 :</target>
        </trans-unit>
        <trans-unit id="e58e2e213f635868b8917c1f64d97bcd94087385" translate="yes" xml:space="preserve">
          <source>A binary assignment operator like &lt;code&gt;+=&lt;/code&gt; or &lt;code&gt;^=&lt;/code&gt; was applied to a type that doesn't support it.</source>
          <target state="translated">&lt;code&gt;+=&lt;/code&gt; 또는 &lt;code&gt;^=&lt;/code&gt; 와 같은 이진 할당 연산자 가이를 지원하지 않는 유형에 적용되었습니다.</target>
        </trans-unit>
        <trans-unit id="807a8b4172841ae84d2493b466a14c239a712c9e" translate="yes" xml:space="preserve">
          <source>A binary can only have one entry point, and by default that entry point is the &lt;code&gt;main()&lt;/code&gt; function. If there are multiple instances of this function, please rename one of them.</source>
          <target state="translated">바이너리는 하나의 진입 점 만 가질 수 있으며 기본적으로 해당 진입 점은 &lt;code&gt;main()&lt;/code&gt; 함수입니다. 이 함수의 인스턴스가 여러 개인 경우 그 중 하나의 이름을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="5f95a7b46c7703730f6563de2663542b39249317" translate="yes" xml:space="preserve">
          <source>A binary can only have one entry point, and by default that entry point is the function &lt;code&gt;main()&lt;/code&gt;. If there are multiple such functions, please rename one.</source>
          <target state="translated">바이너리는 하나의 진입 점 만 가질 수 있으며 기본적으로 진입 점은 함수 &lt;code&gt;main()&lt;/code&gt; 입니다. 이러한 기능이 여러 개인 경우 이름을 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="66f8440b5cbe5979ef5cd4aca43bf502a1ba0914" translate="yes" xml:space="preserve">
          <source>A binary operation was attempted on a type which doesn't support it.</source>
          <target state="translated">지원하지 않는 유형에서 이진 연산을 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="b38f665f61e73d6f968e8571206665e15cc36346" translate="yes" xml:space="preserve">
          <source>A binary operation was attempted on a type which doesn't support it. Erroneous code example:</source>
          <target state="translated">지원하지 않는 유형에서 이진 연산을 시도했습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="aa172e5751306c59c090e9db789e410971427e9e" translate="yes" xml:space="preserve">
          <source>A binding shadowed something it shouldn't.</source>
          <target state="translated">바인딩은해서는 안되는 것을 숨겼습니다.</target>
        </trans-unit>
        <trans-unit id="2196fa2a21cb36f1296a2eab8560f7f044fc56a6" translate="yes" xml:space="preserve">
          <source>A block expression as the tail expression of another block expression.</source>
          <target state="translated">다른 블록 표현식의 테일 표현식 인 블록 표현식.</target>
        </trans-unit>
        <trans-unit id="a693c9a42f3c8985b5be041d70547d78d1d2e744" translate="yes" xml:space="preserve">
          <source>A block of code can be prefixed with the &lt;code&gt;unsafe&lt;/code&gt; keyword to permit &lt;a href=&quot;../unsafety&quot;&gt;unsafe operations&lt;/a&gt;. Examples:</source>
          <target state="translated">&lt;a href=&quot;../unsafety&quot;&gt;안전하지 않은 작업&lt;/a&gt; 을 허용하기 위해 &lt;code&gt;unsafe&lt;/code&gt; 키워드를 코드 블록 앞에 붙일 수 있습니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="3f1de3ecbc17ea9a1f67c2ee7ad38362f83951f6" translate="yes" xml:space="preserve">
          <source>A block of code can be prefixed with the &lt;code&gt;unsafe&lt;/code&gt; keyword, to permit calling &lt;code&gt;unsafe&lt;/code&gt; functions or dereferencing raw pointers within a safe function.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 함수를 호출 하거나 안전 함수 내에서 원시 포인터를 역 참조 할 수 있도록 &lt;code&gt;unsafe&lt;/code&gt; 키워드 를 코드 블록 앞에 붙일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2aaacb371035dfa3169004d8d112f1e5b1ca71a" translate="yes" xml:space="preserve">
          <source>A blog post starts as an empty draft.</source>
          <target state="translated">블로그 게시물은 빈 초안으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="beb16f573b8715d8a98aa06e002398f8060629f2" translate="yes" xml:space="preserve">
          <source>A boolean type which can be safely shared between threads.</source>
          <target state="translated">스레드간에 안전하게 공유 할 수있는 부울 유형입니다.</target>
        </trans-unit>
        <trans-unit id="eb779fca6863a6a0d358d8e696c27d09f35c87e4" translate="yes" xml:space="preserve">
          <source>A borrow of a constant containing interior mutability was attempted.</source>
          <target state="translated">내부 가변성을 포함하는 상수를 빌리려고했습니다.</target>
        </trans-unit>
        <trans-unit id="3d64914b686b3e740569b7a037982d02419990a4" translate="yes" xml:space="preserve">
          <source>A borrow of a constant containing interior mutability was attempted. Erroneous code example:</source>
          <target state="translated">내부 변이성을 포함하는 상수를 빌리려고 시도했습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="6c3704913d69bb40474f716695cc894d7bfa528c" translate="yes" xml:space="preserve">
          <source>A borrow of a thread-local variable was made inside a function which outlived the lifetime of the function.</source>
          <target state="translated">스레드 로컬 변수의 차용은 함수의 수명을 초과 한 함수 내부에서 이루어졌습니다.</target>
        </trans-unit>
        <trans-unit id="f237c3c1919eddd418933b1a63f322a0d0d2a0eb" translate="yes" xml:space="preserve">
          <source>A borrowed value was moved out.</source>
          <target state="translated">차용 한 가치가 밖으로 옮겨졌습니다.</target>
        </trans-unit>
        <trans-unit id="9b2fc820fbc3d301d2c71b19ff6713c60dff7377" translate="yes" xml:space="preserve">
          <source>A borrowed variable was used by a closure.</source>
          <target state="translated">빌린 변수가 클로저에 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="c83fc1310c1c04b54cc7e1f86e92066f4da726ab" translate="yes" xml:space="preserve">
          <source>A borrowed variable was used by a closure. Example of erroneous code:</source>
          <target state="translated">빌린 변수가 빌린 변수를 사용했습니다. 잘못된 코드의 예 :</target>
        </trans-unit>
        <trans-unit id="b7c0d93da848c216d8d60ef97d23c6ae7dfef33f" translate="yes" xml:space="preserve">
          <source>A break expression is normally associated with the innermost loop enclosing the &lt;code&gt;break&lt;/code&gt; but a label can be used to specify which enclosing loop is affected.</source>
          <target state="translated">break 표현식은 일반적으로 &lt;code&gt;break&lt;/code&gt; 를 둘러싸는 가장 안쪽 루프와 연관 되지만 레이블을 사용하여 영향을받는 둘러싸는 루프를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4584a71b04a4125f9586dd4d0599984c41f8d406" translate="yes" xml:space="preserve">
          <source>A broadcast address has all octets set to 255 as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc919&quot;&gt;IETF RFC 919&lt;/a&gt;.</source>
          <target state="translated">브로드 캐스트 주소는 &lt;a href=&quot;https://tools.ietf.org/html/rfc919&quot;&gt;IETF RFC 919에&lt;/a&gt; 정의 된대로 모든 옥텟이 255로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5ed95e144c4e88ac8aa93a227c762654f2cb478" translate="yes" xml:space="preserve">
          <source>A buffer that's too small:</source>
          <target state="translated">너무 작은 버퍼 :</target>
        </trans-unit>
        <trans-unit id="4b481eff295b8689efc0884b27cfb033e7e5efe6" translate="yes" xml:space="preserve">
          <source>A buffer type used with &lt;code&gt;Read::read_vectored&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Read::read_vectored&lt;/code&gt; 와 함께 사용되는 버퍼 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="bc33ba1a0c8fc7e0d6803cc242c896b07605dc58" translate="yes" xml:space="preserve">
          <source>A buffer type used with &lt;code&gt;Write::write_vectored&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Write::write_vectored&lt;/code&gt; 와 함께 사용되는 버퍼 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="9634bddc5eaddedf795f81dbe84a65e742c0b750" translate="yes" xml:space="preserve">
          <source>A builder for computing where in a HashMap a key-value pair would be stored.</source>
          <target state="translated">HashMap에서 키-값 쌍이 저장되는 위치를 계산하기위한 빌더.</target>
        </trans-unit>
        <trans-unit id="164e9f9ed41b273049862041cd75d7cccf4e70e8" translate="yes" xml:space="preserve">
          <source>A builder used to create directories in various manners.</source>
          <target state="translated">다양한 방법으로 디렉토리를 작성하는 데 사용되는 빌더.</target>
        </trans-unit>
        <trans-unit id="d9b7dd70756681f35180b19cd1bfebd1be340c71" translate="yes" xml:space="preserve">
          <source>A builtin-macro was defined more than once.</source>
          <target state="translated">내장 매크로가 두 번 이상 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="3712794ff88bfb37526db3c27354e391cdfb3531" translate="yes" xml:space="preserve">
          <source>A by-value &lt;a href=&quot;../primitive.array&quot;&gt;array&lt;/a&gt; iterator.</source>
          <target state="translated">바이 값 &lt;a href=&quot;../primitive.array&quot;&gt;어레이&lt;/a&gt; 반복기.</target>
        </trans-unit>
        <trans-unit id="db1dde52635a5e1dfcc3c9c412ee03038fd5a1fd" translate="yes" xml:space="preserve">
          <source>A byte constant wasn't correctly ended.</source>
          <target state="translated">바이트 상수가 올바르게 종료되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="358ac47a7f574535f0a6c2b6627900a1db482bcb" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;Drop::drop&lt;/code&gt; for that value, if this special &lt;code&gt;Drop&lt;/code&gt; trait is implemented for its type.</source>
          <target state="translated">이 특별한 &lt;code&gt;Drop&lt;/code&gt; 특성이 해당 유형에 대해 구현 된 경우 해당 값에 대한 &lt;code&gt;Drop::drop&lt;/code&gt; 호출 .</target>
        </trans-unit>
        <trans-unit id="6f6bbc745c6c0811da9c03d5975cfda20a1ec075" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;park&lt;/code&gt; does not guarantee that the thread will remain parked forever, and callers should be prepared for this possibility.</source>
          <target state="translated">를 호출 &lt;code&gt;park&lt;/code&gt; 스레드가 영원히 주차 유지하는 것을 보증하지 않으며, 호출자는이 가능성에 대비해야한다.</target>
        </trans-unit>
        <trans-unit id="310114efe1d071325aac9ee697835f3fab748547" translate="yes" xml:space="preserve">
          <source>A captured OS thread stack backtrace.</source>
          <target state="translated">캡처 된 OS 스레드 스택 역 추적.</target>
        </trans-unit>
        <trans-unit id="068d1bfcec9a1ae7628a6bb97579dd58498f1145" translate="yes" xml:space="preserve">
          <source>A captured variable in a closure may not live long enough.</source>
          <target state="translated">클로저에서 캡처 된 변수는 충분히 오래 살지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87031d3ddac7dc2da2592a12784d3310334c67dd" translate="yes" xml:space="preserve">
          <source>A cast between a thin and a fat pointer was attempted.</source>
          <target state="translated">얇고 뚱뚱한 포인터 사이의 캐스트가 시도되었습니다.</target>
        </trans-unit>
        <trans-unit id="fa8c8681d28baf8dc8f1366a76e05505996e07da" translate="yes" xml:space="preserve">
          <source>A cast to &lt;code&gt;char&lt;/code&gt; was attempted on a type other than &lt;code&gt;u8&lt;/code&gt;.</source>
          <target state="translated">에 대한 캐스트 &lt;code&gt;char&lt;/code&gt; 아닌 다른 유형에 시도되었습니다 &lt;code&gt;u8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d806d6a4232967c179bddb0726f09f0a0c1cae9" translate="yes" xml:space="preserve">
          <source>A cast to an unsized type was attempted.</source>
          <target state="translated">크기가 조정되지 않은 유형으로 캐스트를 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="8ca946f31b782b50520401ae5f6d2242f47dbf2a" translate="yes" xml:space="preserve">
          <source>A cell which can be written to only once.</source>
          <target state="translated">한 번만 쓸 수있는 셀입니다.</target>
        </trans-unit>
        <trans-unit id="7ab45f97583623706555b717305df511d6d6755b" translate="yes" xml:space="preserve">
          <source>A channel in programming has two halves: a transmitter and a receiver. The transmitter half is the upstream location where you put rubber ducks into the river, and the receiver half is where the rubber duck ends up downstream. One part of your code calls methods on the transmitter with the data you want to send, and another part checks the receiving end for arriving messages. A channel is said to be &lt;em&gt;closed&lt;/em&gt; if either the transmitter or receiver half is dropped.</source>
          <target state="translated">프로그래밍 채널에는 송신기와 수신기의 두 부분이 있습니다. 송신기 반은 고무 오리를 강에 넣는 업스트림 위치이고 수신기 반은 고무 오리가 다운 스트림에서 끝나는 곳입니다. 코드의 한 부분은 전송하려는 데이터를 사용하여 송신기에서 메서드를 호출하고 다른 부분은 수신 쪽에서 도착 메시지를 확인합니다. 채널이 &lt;em&gt;폐쇄&lt;/em&gt; 되었다고합니다&lt;em&gt;&lt;/em&gt;송신기 또는 수신기 절반이 떨어지면 있다고합니다.</target>
        </trans-unit>
        <trans-unit id="9b271c9cb4969ff9e8017b48dea5ee7ea287981f" translate="yes" xml:space="preserve">
          <source>A character literal wasn't ended with a quote.</source>
          <target state="translated">문자 리터럴이 따옴표로 끝나지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="730c231d230d4d65e9a1cdedca314d8b69b7866c" translate="yes" xml:space="preserve">
          <source>A character type.</source>
          <target state="translated">문자 유형.</target>
        </trans-unit>
        <trans-unit id="195b8c50281f62fd27ad7158cd7ae79ac4f9afca" translate="yes" xml:space="preserve">
          <source>A classification of floating point numbers.</source>
          <target state="translated">부동 소수점 숫자의 분류.</target>
        </trans-unit>
        <trans-unit id="dea8ae8b6b70c73b2cce436aaeecb02e010d0c2b" translate="yes" xml:space="preserve">
          <source>A clobber was surrounded by braces in the &lt;code&gt;llvm_asm&lt;/code&gt; macro.</source>
          <target state="translated">clobber는 &lt;code&gt;llvm_asm&lt;/code&gt; 매크로 에서 중괄호로 둘러싸여 있습니다.</target>
        </trans-unit>
        <trans-unit id="52397aa21f3cbabb1bcadcab29fd5a79bd3be6ee" translate="yes" xml:space="preserve">
          <source>A clone-on-write smart pointer.</source>
          <target state="translated">복제시 쓰기 스마트 포인터.</target>
        </trans-unit>
        <trans-unit id="17d70d4cf5c4adf5f0753809fb9cb729a2f8379d" translate="yes" xml:space="preserve">
          <source>A closure expression denotes a function that maps a list of parameters onto the expression that follows the parameters. Just like a &lt;a href=&quot;../statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; binding&lt;/a&gt;, the parameters are irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt;, whose type annotation is optional and will be inferred from context if not given. Each closure expression has a unique, anonymous type.</source>
          <target state="translated">클로저 식은 매개 변수 목록을 매개 변수 다음에 오는 식에 매핑하는 함수를 나타냅니다. &lt;a href=&quot;../statements#let-statements&quot;&gt; &lt;code&gt;let&lt;/code&gt; 바인딩&lt;/a&gt; 처럼 매개 변수는 반박 할 수없는 &lt;a href=&quot;../patterns&quot;&gt;패턴입니다&lt;/a&gt; 유형이 주석 선택 사항이며 지정하지 않을 경우 문맥에서 추론됩니다. 각 클로저 표현식에는 고유 한 익명 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="229f7ae12c2338583566d98b6347b250aaf7fe51" translate="yes" xml:space="preserve">
          <source>A closure has been used as &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">클로저는 &lt;code&gt;static&lt;/code&gt; 으로 사용되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a9e518044a28e364a6d5caf649a49a37d36a9e44" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; if it does not capture any values by unique immutable or mutable reference, and if all values it captures by copy or move are &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, respectively.</source>
          <target state="translated">고유 한 불변 또는 변경 가능한 참조로 값을 캡처하지 않고 복사 또는 이동으로 캡처하는 모든 값 이 &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 경우 클로저는 &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="f47eb76e99123d39021af1de1b77a6fbf1ed2931" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; if all variables captured by non-unique immutable reference are &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, and all values captured by unique immutable or mutable reference, copy, or move are &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">고유하지 않은 불변의 참조로 캡처 된 모든 변수가 &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 이고 고유 한 불변의 또는 변경 가능한 참조, 복사 또는 이동으로 캡처 된 모든 값 이 &lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; 인&lt;/a&gt; 경우 클로저는 &lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; 입니다.&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0d261d9dcf84a04b55a505f635cb5d6d0068277d" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if all captured variables are &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">캡처 된 모든 변수 가 &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; 인&lt;/a&gt; 경우 클로저는 &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f3dcf856d438dee9833c1d37d61c6e01baf7766e" translate="yes" xml:space="preserve">
          <source>A closure or generator was constructed that references its own type.</source>
          <target state="translated">자체 유형을 참조하는 클로저 또는 생성기가 구성되었습니다.</target>
        </trans-unit>
        <trans-unit id="3bcd57420ec9a5b5481261d30eb81ca537f99421" translate="yes" xml:space="preserve">
          <source>A closure was used but didn't implement the expected trait.</source>
          <target state="translated">클로저가 사용되었지만 예상되는 특성을 구현하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c9d5fcd074a946b081167d5c176a725de44ced3d" translate="yes" xml:space="preserve">
          <source>A closure which does not move out of any captured variables implements &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, indicating that it can be called by mutable reference.</source>
          <target state="translated">캡처 된 변수에서 &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; 않는 클로저는 FnMut을 구현 하여 변경 가능한 참조로 호출 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cd4b51e9607f8ce4ec972f070cc5a727f780aa02" translate="yes" xml:space="preserve">
          <source>A closure which does not mutate or move out of any captured variables implements &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, indicating that it can be called by shared reference.</source>
          <target state="translated">캡처 된 변수를 변경하거나 벗어나지 않는 클로저는 &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; 을&lt;/a&gt; 구현 하여 공유 참조에 의해 호출 될 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e935c8f48fd175281f69484ea6d8e34c3df1f772" translate="yes" xml:space="preserve">
          <source>A coercion can only occur at certain coercion sites in a program; these are typically places where the desired type is explicit or can be derived by propagation from explicit types (without type inference). Possible coercion sites are:</source>
          <target state="translated">강요는 프로그램의 특정 강요 사이트에서만 발생할 수 있습니다. 이들은 일반적으로 원하는 유형이 명시 적이거나 명시 적 유형 (유형 유추없이)에서 전파되어 파생 될 수있는 장소입니다. 가능한 강제 사이트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d399a6fb5b1366dacbcbc3c485166cb44a8fe4f" translate="yes" xml:space="preserve">
          <source>A collection of methods that are required to format a message into a stream.</source>
          <target state="translated">메시지를 스트림으로 형식화하는 데 필요한 메소드 콜렉션.</target>
        </trans-unit>
        <trans-unit id="2a7f703e336c6bdb6cbae32714276165fd6dcc43" translate="yes" xml:space="preserve">
          <source>A common example is the &lt;code&gt;collect&lt;/code&gt; method on &lt;code&gt;Iterator&lt;/code&gt;. It has a generic type parameter with a &lt;code&gt;FromIterator&lt;/code&gt; bound, which for a &lt;code&gt;char&lt;/code&gt; iterator is implemented by &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; among others. Consider the following snippet that reverses the characters of a string:</source>
          <target state="translated">일반적인 예는 &lt;code&gt;Iterator&lt;/code&gt; 의 &lt;code&gt;collect&lt;/code&gt; 메소드입니다 . &lt;code&gt;FromIterator&lt;/code&gt; 바운드 가있는 제네릭 형식 매개 변수가 있으며 , &lt;code&gt;char&lt;/code&gt; 반복기의 경우 &lt;code&gt;Vec&lt;/code&gt; 및 &lt;code&gt;String&lt;/code&gt; 으로 구현됩니다 . 문자열의 문자를 뒤집는 다음 스 니펫을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e2236ceee783d907728a27d889b17b89679caa37" translate="yes" xml:space="preserve">
          <source>A common interface for a class of types.</source>
          <target state="translated">유형 클래스에 대한 공통 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="8baf44157a38997462218326dfa5b36c89567539" translate="yes" xml:space="preserve">
          <source>A common interface for a group of types.</source>
          <target state="translated">유형 그룹에 대한 공통 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="23bb5a3938b6b7101f14bfe5b204b2401bdf9250" translate="yes" xml:space="preserve">
          <source>A common mis-conception is to think that &quot;unicast link-local addresses start with &lt;code&gt;fe80::&lt;/code&gt;&quot;, but the &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; actually defines a stricter format for these addresses:</source>
          <target state="translated">일반적인 오해는 &quot;유니 캐스트 링크 로컬 주소는 &lt;code&gt;fe80::&lt;/code&gt; &quot;으로 시작 하지만 &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; 이라고 생각하는 것입니다. 실제로 다음 주소에 대해보다 엄격한 형식을 정의 .</target>
        </trans-unit>
        <trans-unit id="4615ae2634801f990b77ad209e23e9d53e5c0d34" translate="yes" xml:space="preserve">
          <source>A common problem with using return values to indicate errors is that it is easy to ignore the return value, thus failing to handle the error. &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is annotated with the &lt;code&gt;#[must_use]&lt;/code&gt; attribute, which will cause the compiler to issue a warning when a Result value is ignored. This makes &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; especially useful with functions that may encounter errors but don't otherwise return a useful value.</source>
          <target state="translated">리턴 값을 사용하여 오류를 표시 할 때 일반적으로 발생하는 문제점은 리턴 값을 무시하기 쉽고 오류를 처리하지 못한다는 것입니다. &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 에 &lt;code&gt;#[must_use]&lt;/code&gt; 속성 이 주석으로 표시되어 결과 값이 무시 될 때 컴파일러가 경고를 발행합니다. 이 차종은 &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 오류가 발생할 수 있지만, 그렇지 않으면 유용한 값을 반환하지 않는 기능이 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9e6af95ab7d6f1c50d97f5f2eb1a6e3eebe549bf" translate="yes" xml:space="preserve">
          <source>A common trait for the ability to explicitly duplicate an object.</source>
          <target state="translated">객체를 명시 적으로 복제 할 수있는 능력에 대한 일반적인 특징.</target>
        </trans-unit>
        <trans-unit id="f3fcc76ff39756ffd2b4cb1d33e25cb209dbe4a4" translate="yes" xml:space="preserve">
          <source>A common use case for &lt;code&gt;spin_loop&lt;/code&gt; is implementing bounded optimistic spinning in a CAS loop in synchronization primitives. To avoid problems like priority inversion, it is strongly recommended that the spin loop is terminated after a finite amount of iterations and an appropriate blocking syscall is made.</source>
          <target state="translated">&lt;code&gt;spin_loop&lt;/code&gt; 의 일반적인 사용 사례 는 동기화 프리미티브의 CAS 루프에서 제한된 낙관적 회전을 구현하는 것입니다. 우선 순위 반전과 같은 문제를 방지하려면 한정된 양의 반복과 적절한 차단 시스템 호출이 이루어진 후에 스핀 루프를 종료하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0f3bf37cba543ca385f5031852ec32495e2e84e3" translate="yes" xml:space="preserve">
          <source>A common use case for &lt;code&gt;spin_loop_hint&lt;/code&gt; is implementing bounded optimistic spinning in a CAS loop in synchronization primitives. To avoid problems like priority inversion, it is strongly recommended that the spin loop is terminated after a finite amount of iterations and an appropriate blocking syscall is made.</source>
          <target state="translated">&lt;code&gt;spin_loop_hint&lt;/code&gt; 의 일반적인 사용 사례 는 동기화 프리미티브의 CAS 루프에서 제한된 낙관적 회전을 구현하는 것입니다. 우선 순위 반전과 같은 문제를 방지하려면 한정된 양의 반복과 적절한 차단 시스템 호출이 이루어진 후에 스핀 루프를 종료하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3e2c1919c7a821f5f3bf3a38d0ef8acb4190a932" translate="yes" xml:space="preserve">
          <source>A common use for &lt;code&gt;format!&lt;/code&gt; is concatenation and interpolation of strings. The same convention is used with &lt;a href=&quot;macro.print&quot;&gt;&lt;code&gt;print!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macros, depending on the intended destination of the string.</source>
          <target state="translated">&lt;code&gt;format!&lt;/code&gt; 의 일반적인 사용 ! 문자열의 연결 및 보간입니다. &lt;a href=&quot;macro.print&quot;&gt; &lt;code&gt;print!&lt;/code&gt; &lt;/a&gt; 동일한 규칙이 사용됩니다 ! 그리고 &lt;a href=&quot;macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;문자열의 대상에 따라 매크로</target>
        </trans-unit>
        <trans-unit id="44fea0684e72cef1ddaf4be0010340215dffbec7" translate="yes" xml:space="preserve">
          <source>A common use of this feature is to poison shared resources when writing unsafe code, by checking &lt;code&gt;panicking&lt;/code&gt; when the &lt;code&gt;drop&lt;/code&gt; is called.</source>
          <target state="translated">이 기능은 일반적으로 &lt;code&gt;drop&lt;/code&gt; 이 호출 될 때 &lt;code&gt;panicking&lt;/code&gt; 을 확인하여 안전하지 않은 코드를 작성할 때 공유 리소스를 독살하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3016e8bc4b1ae0cb5dbf3daaacd9d48f6d65eed5" translate="yes" xml:space="preserve">
          <source>A common way to test functionality is to compare the result of the code under test to the value you expect the code to return to make sure they&amp;rsquo;re equal. You could do this using the &lt;code&gt;assert!&lt;/code&gt; macro and passing it an expression using the &lt;code&gt;==&lt;/code&gt; operator. However, this is such a common test that the standard library provides a pair of macros&amp;mdash;&lt;code&gt;assert_eq!&lt;/code&gt; and &lt;code&gt;assert_ne!&lt;/code&gt;&amp;mdash;to perform this test more conveniently. These macros compare two arguments for equality or inequality, respectively. They&amp;rsquo;ll also print the two values if the assertion fails, which makes it easier to see &lt;em&gt;why&lt;/em&gt; the test failed; conversely, the &lt;code&gt;assert!&lt;/code&gt; macro only indicates that it got a &lt;code&gt;false&lt;/code&gt; value for the &lt;code&gt;==&lt;/code&gt; expression, not the values that lead to the &lt;code&gt;false&lt;/code&gt; value.</source>
          <target state="translated">기능을 테스트하는 일반적인 방법은 테스트중인 코드의 결과를 코드가 동일한 지 확인하기 위해 반환 할 것으로 예상되는 값과 비교하는 것입니다. 당신은 &lt;code&gt;assert!&lt;/code&gt; 사용하여 이것을 할 수 있습니다 ! &lt;code&gt;==&lt;/code&gt; 연산자를 사용하여 표현식을 전달하십시오 . 그러나 이것은 표준 라이브러리가 매크로 쌍인 &lt;code&gt;assert_eq!&lt;/code&gt; 제공하는 일반적인 테스트입니다 . 그리고 &lt;code&gt;assert_ne!&lt;/code&gt; &amp;mdash;이 테스트를보다 편리하게 수행합니다. 이 매크로는 두 가지 인수가 동일한 지 또는 불평등인지를 각각 비교합니다. 또한 어설 션이 실패하면 두 값을 인쇄 하여 테스트가 실패한 &lt;em&gt;이유를&lt;/em&gt; 더 쉽게 확인할 수 있습니다 . 반대로, &lt;code&gt;assert!&lt;/code&gt; 매크로는 &lt;code&gt;false&lt;/code&gt; 나타냅니다. &lt;code&gt;==&lt;/code&gt; 의 값 &lt;code&gt;false&lt;/code&gt; 이끄는 값이 아닌 표현 값.</target>
        </trans-unit>
        <trans-unit id="6f72785cb8deaf70098be764432ad287d8764020" translate="yes" xml:space="preserve">
          <source>A common way to use &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is in combination with &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;. Recall that &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; lets you have multiple owners of some data, but it only gives immutable access to that data. If you have an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; that holds a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, you can get a value that can have multiple owners &lt;em&gt;and&lt;/em&gt; that you can mutate!</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 을 사용하는 일반적인 방법 은 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 와 함께 사용하는 것 입니다. 리콜 그 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 일부 데이터의 여러 소유자를 할 수 있지만, 해당 데이터에 대한 불변의 액세스를 제공합니다. 당신이있는 경우 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 보유 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 여러 소유자를 가질 수있는 값 얻을 수 있습니다 &lt;em&gt;그리고&lt;/em&gt; 당신은 돌연변이 수를!</target>
        </trans-unit>
        <trans-unit id="c3a2eb5105511775d59e5e4cd686eb5579136f33" translate="yes" xml:space="preserve">
          <source>A comparison like the one above, which ignores some fields of the struct, can be dangerous. It can easily lead to an unintended violation of the requirements for a partial equivalence relation. For example, if we kept the above implementation of &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; for &lt;code&gt;BookFormat&lt;/code&gt; and added an implementation of &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; for &lt;code&gt;Book&lt;/code&gt; (either via a &lt;code&gt;#[derive]&lt;/code&gt; or via the manual implementation from the first example) then the result would violate transitivity:</source>
          <target state="translated">구조체의 일부 필드를 무시하는 위와 같은 비교는 위험 할 수 있습니다. 부분적 동등성 관계에 대한 요구 사항의 의도하지 않은 위반으로 쉽게 이어질 수 있습니다. , 예를 들어, 우리의 상기 구현 유지 &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; 대한 &lt;code&gt;BookFormat&lt;/code&gt; 을 하고 구현 첨가 &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; 에 대한 &lt;code&gt;Book&lt;/code&gt; (어느 비아 &lt;code&gt;#[derive]&lt;/code&gt; 또는 제 1 예에서 수동 구현을 통한) 결과는 위반 전이성 :</target>
        </trans-unit>
        <trans-unit id="1b20c9de094581b8f84861af4164c5552e60a2ee" translate="yes" xml:space="preserve">
          <source>A compile time error is never emitted when using this macro regardless of whether the environment variable is present or not.</source>
          <target state="translated">환경 변수의 존재 여부에 관계없이이 매크로를 사용할 때 컴파일 시간 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="378954a8b28d0b17cfcc628e2457199a86abdd79" translate="yes" xml:space="preserve">
          <source>A compiler memory fence.</source>
          <target state="translated">컴파일러 메모리 펜스</target>
        </trans-unit>
        <trans-unit id="592fedd9ba4ca1ae2681effb1b9b42a165b45c38" translate="yes" xml:space="preserve">
          <source>A compiler-only memory barrier.</source>
          <target state="translated">컴파일러 전용 메모리 장벽.</target>
        </trans-unit>
        <trans-unit id="5af9d265d7cc350d6c8dd5eca2e52c0984df494d" translate="yes" xml:space="preserve">
          <source>A configuration option. It is true if the option is set and false if it is unset.</source>
          <target state="translated">구성 옵션. 옵션이 설정되어 있으면 true이고 설정되어 있지 않으면 false입니다.</target>
        </trans-unit>
        <trans-unit id="3457f182555f50a2c7cffa76112cf04e013ed4c3" translate="yes" xml:space="preserve">
          <source>A consequence of the borrowing rules is that when you have an immutable value, you can&amp;rsquo;t borrow it mutably. For example, this code won&amp;rsquo;t compile:</source>
          <target state="translated">차용 규칙의 결과는 불변의 가치가있을 때 변경할 수 없다는 것입니다. 예를 들어이 코드는 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82e92c5c9841d5d2d3e69bff0f6aeb9309a13f00" translate="yes" xml:space="preserve">
          <source>A constant item was initialized with something that is not a constant expression.</source>
          <target state="translated">상수 항목이 상수 표현식이 아닌 것으로 초기화되었습니다.</target>
        </trans-unit>
        <trans-unit id="5ce86a2e004403aa5ba6b72a885c67d143829985" translate="yes" xml:space="preserve">
          <source>A constant value failed to get evaluated.</source>
          <target state="translated">상수 값을 평가하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="2574c153f328b1e202d9e64649cb65b6702dbcde" translate="yes" xml:space="preserve">
          <source>A contiguous growable array type with heap-allocated contents, written &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">힙 할당 내용이 있고 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 작성된 연속 확장 가능 배열 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="ceaa636b8440544799d1a505ee00079d04849fb0" translate="yes" xml:space="preserve">
          <source>A contiguous growable array type, written &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; but pronounced 'vector'.</source>
          <target state="translated">연속 가능한 확장 가능 배열 유형으로 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 작성 되었지만 'vector'로 발음됩니다.</target>
        </trans-unit>
        <trans-unit id="821a3f39751014be2886a42509e99ef71f4b3a2f" translate="yes" xml:space="preserve">
          <source>A control-flow expression was used inside a const context.</source>
          <target state="translated">제어 흐름식이 const 컨텍스트 내에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="0490b6e232133e0013be8f4fef9d50c9926445a5" translate="yes" xml:space="preserve">
          <source>A convenience function that bubbles an &lt;code&gt;io::Result&lt;/code&gt; to its caller:</source>
          <target state="translated">&lt;code&gt;io::Result&lt;/code&gt; 를 호출자에게 버블 링하는 편리한 함수 :</target>
        </trans-unit>
        <trans-unit id="16d79d851ab24be5a7dea27948897afa80e31902" translate="yes" xml:space="preserve">
          <source>A convenience impl that delegates to the impl for &lt;code&gt;&amp;amp;str&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; 대한 impl을 위임하는 편리한 impl</target>
        </trans-unit>
        <trans-unit id="35a7bd82b1e1370c217a40362b5ca9b11be11f9d" translate="yes" xml:space="preserve">
          <source>A convenience impl that delegates to the impl for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; 을 위해 impl에 위임하는 편리한 impl .</target>
        </trans-unit>
        <trans-unit id="c5815609ea9bdc6c8447adfe133c418ba6a0e628" translate="yes" xml:space="preserve">
          <source>A correct implementation could look like:</source>
          <target state="translated">올바른 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0847e6a8b80cb99079b74075a954fd750b19a38b" translate="yes" xml:space="preserve">
          <source>A crate is somewhat analogous to an &lt;em&gt;assembly&lt;/em&gt; in the ECMA-335 CLI model, a &lt;em&gt;library&lt;/em&gt; in the SML/NJ Compilation Manager, a &lt;em&gt;unit&lt;/em&gt; in the Owens and Flatt module system, or a &lt;em&gt;configuration&lt;/em&gt; in Mesa.</source>
          <target state="translated">상자는 ECMA-335 CLI 모델 의 &lt;em&gt;어셈블리&lt;/em&gt; , SML / NJ Compilation Manager 의 &lt;em&gt;라이브러리&lt;/em&gt; , Owens and Flatt 모듈 시스템 의 &lt;em&gt;단위&lt;/em&gt; 또는 Mesa 의 &lt;em&gt;구성&lt;/em&gt; 과 다소 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="6436f7757ac841fe0b93278e071a64e419b3a404" translate="yes" xml:space="preserve">
          <source>A crate needs a global available &quot;helper module&quot; to itself, but it doesn't want to expose the helper module as a public API. To accomplish this, the root of the crate's hierarchy would have a private module which then internally has a &quot;public API&quot;. Because the entire crate is a descendant of the root, then the entire local crate can access this private module through the second case.</source>
          <target state="translated">상자에는 자체적으로 사용할 수있는 전역 &quot;도우미 모듈&quot;이 필요하지만, 도우미 모듈을 공개 API로 노출하고 싶지는 않습니다. 이를 달성하기 위해 크레이트 계층의 루트는 내부적으로 &quot;공용 API&quot;를 갖는 개인 모듈을 갖게됩니다. 전체 상자는 루트의 자손이므로 전체 로컬 상자는 두 번째 경우를 통해이 개인 모듈에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc65255cb2d6b61579af61c12db502f3b72ad815" translate="yes" xml:space="preserve">
          <source>A crate that contains a &lt;code&gt;main&lt;/code&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; can be compiled to an executable. If a &lt;code&gt;main&lt;/code&gt; function is present, it must take no arguments, must not declare any &lt;a href=&quot;trait-bounds&quot;&gt;trait or lifetime bounds&lt;/a&gt;, must not have any &lt;a href=&quot;items/generics#where-clauses&quot;&gt;where clauses&lt;/a&gt;, and its return type must be one of the following:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; &lt;a href=&quot;items/functions&quot;&gt;기능&lt;/a&gt; 이 포함 된 상자 는 실행 파일로 컴파일 할 수 있습니다. &lt;code&gt;main&lt;/code&gt; 함수가 존재 한다면, 인수를 취하지 않아야하며, &lt;a href=&quot;trait-bounds&quot;&gt;특성이나 수명 한계를&lt;/a&gt; 선언 해서는 안되며 &lt;a href=&quot;items/generics#where-clauses&quot;&gt;where 절이&lt;/a&gt; 없어야 합니다. , 리턴 유형은 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="1dd52734851cf6f3cf436dc5839dcfddfdcaf815" translate="yes" xml:space="preserve">
          <source>A crate will group related functionality together in a scope so the functionality is easy to share between multiple projects. For example, the &lt;code&gt;rand&lt;/code&gt; crate we used in &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;Chapter 2&lt;/a&gt; provides functionality that generates random numbers. We can use that functionality in our own projects by bringing the &lt;code&gt;rand&lt;/code&gt; crate into our project&amp;rsquo;s scope. All the functionality provided by the &lt;code&gt;rand&lt;/code&gt; crate is accessible through the crate&amp;rsquo;s name, &lt;code&gt;rand&lt;/code&gt;.</source>
          <target state="translated">크레이트는 관련 기능을 범위 내에서 그룹화하여 여러 프로젝트간에 기능을 쉽게 공유 할 수 있습니다. 예를 들어, &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;2 장&lt;/a&gt; 에서 사용한 &lt;code&gt;rand&lt;/code&gt; 상자는 난수를 생성하는 기능을 제공합니다. &lt;code&gt;rand&lt;/code&gt; 크레이트를 프로젝트 범위로 가져 와서 자체 프로젝트에서 해당 기능을 사용할 수 있습니다 . &lt;code&gt;rand&lt;/code&gt; 상자에서 제공하는 모든 기능 은 상자의 이름 인 &lt;code&gt;rand&lt;/code&gt; 를 통해 액세스 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="9489488427833bc0214d8f4c5f5a907ee47ae129" translate="yes" xml:space="preserve">
          <source>A cross-crate opt-out trait was implemented on something which wasn't a struct or enum type.</source>
          <target state="translated">struct 또는 enum 유형이 아닌 것에 교차 상자 옵트 아웃 특성이 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="00851a5c172b45fa5d81433f76656b498876dd4d" translate="yes" xml:space="preserve">
          <source>A cross-crate opt-out trait was implemented on something which wasn't a struct or enum type. Erroneous code example:</source>
          <target state="translated">교차 상자 옵트 아웃 특성은 구조체 또는 열거 형이 아닌 것으로 구현되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="521073eb4a9d5dea34971bbf2d3b43472252d22c" translate="yes" xml:space="preserve">
          <source>A cursor over a &lt;code&gt;LinkedList&lt;/code&gt; with editing operations.</source>
          <target state="translated">편집 작업이 있는 &lt;code&gt;LinkedList&lt;/code&gt; 위의 커서 입니다.</target>
        </trans-unit>
        <trans-unit id="e765e383228431ae063a8d9a831d2b82107b6c73" translate="yes" xml:space="preserve">
          <source>A cursor over a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; 위의 커서 .</target>
        </trans-unit>
        <trans-unit id="36316fe5916fd156e2a88a749ac433147a8da4cc" translate="yes" xml:space="preserve">
          <source>A cycle between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers will never be deallocated. For this reason, &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is used to break cycles. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터 사이의 사이클은 할당 해제되지 않습니다. 이러한 이유로 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 을 사용하여 사이클을 중단합니다. 예를 들어, 나무는 부모 노드에서 자식으로 강력한 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터를, 자식에서 부모로 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b90e3c2a1d2a35888ed9e0be0c1ef31680e920a" translate="yes" xml:space="preserve">
          <source>A cycle between &lt;code&gt;Arc&lt;/code&gt; pointers will never be deallocated. For this reason, &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is used to break cycles. For example, a tree could have strong &lt;code&gt;Arc&lt;/code&gt; pointers from parent nodes to children, and &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Arc&lt;/code&gt; 포인터 사이의 사이클은 할당 해제되지 않습니다. 이러한 이유로 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 을 사용하여 사이클을 중단합니다. 예를 들어, 나무는 부모 노드에서 자식으로 강한 &lt;code&gt;Arc&lt;/code&gt; 포인터를, 자식에서 부모로 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd0e6a515d806f28a3a9117a215e0567225d9f11" translate="yes" xml:space="preserve">
          <source>A data structure is in a temporarily invalid state when the thread panics.</source>
          <target state="translated">스레드 패닉시 데이터 구조가 일시적으로 유효하지 않은 상태입니다.</target>
        </trans-unit>
        <trans-unit id="590870896f27fcf4f2a0264dabbc0794e9042402" translate="yes" xml:space="preserve">
          <source>A default configuration can be generated using &lt;code&gt;Command::new(program)&lt;/code&gt;, where &lt;code&gt;program&lt;/code&gt; gives a path to the program to be executed. Additional builder methods allow the configuration to be changed (for example, by adding arguments) prior to spawning:</source>
          <target state="translated">기본 구성은 &lt;code&gt;Command::new(program)&lt;/code&gt; 사용하여 생성 할 수 있습니다 . 여기서 &lt;code&gt;program&lt;/code&gt; 은 실행할 프로그램의 경로를 제공합니다. 추가 빌더 메소드를 사용하면 생성 전에 구성을 변경할 수 있습니다 (예 : 인수 추가).</target>
        </trans-unit>
        <trans-unit id="cc1e47ebf18eca6629966fd3d1126236437b08eb" translate="yes" xml:space="preserve">
          <source>A definition of a method not in the implemented trait was given in a trait implementation.</source>
          <target state="translated">구현 된 특성에없는 방법의 정의는 특성 구현에서 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="74bdee4c01f0e2a5b888cedf761fad306ec9d91d" translate="yes" xml:space="preserve">
          <source>A discriminant in an &lt;code&gt;enum&lt;/code&gt; not included in the type definition.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 의 판별 자는 유형 정의에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d4413773858071be2cda9c035b93d8adb5ed9c4" translate="yes" xml:space="preserve">
          <source>A discriminant value is present more than once.</source>
          <target state="translated">판별 값이 두 번 이상 존재합니다.</target>
        </trans-unit>
        <trans-unit id="e33398f8a1c82819cfc272eb4db0376550aceebc" translate="yes" xml:space="preserve">
          <source>A doc comment that is not attached to anything has been encountered.</source>
          <target state="translated">아무것도 첨부되지 않은 문서 주석이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="449c61354d124e018f4ac7cc6a32776bf259e4bc" translate="yes" xml:space="preserve">
          <source>A documentation comment that doesn't document anything was found.</source>
          <target state="translated">아무것도 문서화하지 않은 문서 주석이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="b5da65d7d41e577505a8697b6d53146c919ad568" translate="yes" xml:space="preserve">
          <source>A double quote byte string (&lt;code&gt;b&quot;&lt;/code&gt;) was not terminated.</source>
          <target state="translated">큰 따옴표 바이트 문자열 ( &lt;code&gt;b&quot;&lt;/code&gt; )이 종료되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="6c189219618ff090bbaf1c282c8ad43303eb7709" translate="yes" xml:space="preserve">
          <source>A double quote string (&lt;code&gt;&quot;&lt;/code&gt;) was not terminated.</source>
          <target state="translated">큰 따옴표 문자열 ( &lt;code&gt;&quot;&lt;/code&gt; )이 종료되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="844fc94f2ec6c20bbd8c3c61aa63bf0f8f4c60a0" translate="yes" xml:space="preserve">
          <source>A double-ended iterator with the direction inverted.</source>
          <target state="translated">방향이 반전 된 이중 종단 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="9e374237ea1be12ca52873f6b8cd4c6757ef72d7" translate="yes" xml:space="preserve">
          <source>A double-ended queue implemented with a growable ring buffer.</source>
          <target state="translated">확장 가능한 링 버퍼로 구현 된 이중 엔드 큐입니다.</target>
        </trans-unit>
        <trans-unit id="28050b20d2fb7eccf5c8a8ecb22f1b2923430db5" translate="yes" xml:space="preserve">
          <source>A doubly-linked list with owned nodes.</source>
          <target state="translated">소유 한 노드가있는 이중 연결 목록입니다.</target>
        </trans-unit>
        <trans-unit id="7fb38950784a1933e77430becd7b735f7149cba0" translate="yes" xml:space="preserve">
          <source>A draining iterator for &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 의 배수 반복기 .</target>
        </trans-unit>
        <trans-unit id="4c37906477f09b5f321b2effe6bce9b886812638" translate="yes" xml:space="preserve">
          <source>A draining iterator for &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 의 배수 반복기 .</target>
        </trans-unit>
        <trans-unit id="429ad4a5f6fa96f2bca9279ba7532d1e6d671a36" translate="yes" xml:space="preserve">
          <source>A draining iterator over the elements of a &lt;code&gt;BinaryHeap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BinaryHeap&lt;/code&gt; 요소의 배수 반복기 .</target>
        </trans-unit>
        <trans-unit id="91b15bef979787193522a6fe820b65bca6b71b6d" translate="yes" xml:space="preserve">
          <source>A draining iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; 요소의 배수 반복기 .</target>
        </trans-unit>
        <trans-unit id="6e8fa0dd341d84cbc1afdb686f6037ff7ef3d24c" translate="yes" xml:space="preserve">
          <source>A draining iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 의 항목에 대한 배수 반복기 .</target>
        </trans-unit>
        <trans-unit id="3f3d65aa6b0bc2c1da1319190787588eadcf2d84" translate="yes" xml:space="preserve">
          <source>A draining iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 항목의 배수 반복기 입니다.</target>
        </trans-unit>
        <trans-unit id="d0414ecefaa3523675384470efb07b95159dba45" translate="yes" xml:space="preserve">
          <source>A draining, filtering iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 항목에 대한 배수, 필터링 반복기 .</target>
        </trans-unit>
        <trans-unit id="bdb2903d11786dcb8b8844e91d87fb7f80657414" translate="yes" xml:space="preserve">
          <source>A draining, filtering iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 항목에 대한 배수, 필터링 반복기 입니다.</target>
        </trans-unit>
        <trans-unit id="c40d5a17630e0b8c5262cd5da85143e19cf981ab" translate="yes" xml:space="preserve">
          <source>A duration of zero time.</source>
          <target state="translated">시간이 0 인 기간입니다.</target>
        </trans-unit>
        <trans-unit id="cc90bdb96c97b6e432d2ff036bf4b852213faf58" translate="yes" xml:space="preserve">
          <source>A dynamically sized type (DST) is a type without a statically known size or alignment.</source>
          <target state="translated">DST (Dynamic Sized Type)는 정적으로 알려진 크기 나 정렬이없는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="211aeaeaf569d6a37ba4f9e761ab58dda09c15a6" translate="yes" xml:space="preserve">
          <source>A dynamically-sized view into a contiguous sequence, &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">연속적인 순서로 동적으로 크기보기 &lt;code&gt;[T]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9b7bf32fab7bb231166bbede96c90271ed78811" translate="yes" xml:space="preserve">
          <source>A dynamically-sized view into a contiguous sequence, &lt;code&gt;[T]&lt;/code&gt;. Contiguous here means that elements are laid out so that every element is the same distance from its neighbors.</source>
          <target state="translated">연속적인 시퀀스에 대한 동적 크기보기, &lt;code&gt;[T]&lt;/code&gt; . 여기서 Contiguous는 모든 요소가 인접 요소와 동일한 거리에 있도록 요소가 배치됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="31f05f23c58b03a01fb9e427108a188fcf6b07f3" translate="yes" xml:space="preserve">
          <source>A feature attribute named a feature that has been removed.</source>
          <target state="translated">제거 된 기능이라는 기능 속성입니다.</target>
        </trans-unit>
        <trans-unit id="dd28c7fe46ecde36f6e0a91f768af6503a5d1816" translate="yes" xml:space="preserve">
          <source>A feature attribute named a feature that was disallowed in the compiler command line flags.</source>
          <target state="translated">컴파일러 명령 행 플래그에서 허용되지 않은 기능이라는 기능 속성입니다.</target>
        </trans-unit>
        <trans-unit id="7d16601ad6554f548eab3701b5a36e77bca297da" translate="yes" xml:space="preserve">
          <source>A feature name is missing.</source>
          <target state="translated">기능 이름이 없습니다.</target>
        </trans-unit>
        <trans-unit id="80c1f2d8465e2f0474908b699c574231c3f93ea8" translate="yes" xml:space="preserve">
          <source>A fence 'A' which has (at least) &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering semantics, synchronizes with a fence 'B' with (at least) &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; semantics, if and only if there exist operations X and Y, both operating on some atomic object 'M' such that A is sequenced before X, Y is synchronized before B and Y observes the change to M. This provides a happens-before dependence between A and B.</source>
          <target state="translated">최소 &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; 시맨틱을 갖는 펜스 'A'는 적어도 원자 적 객체 'M'에서 작동하는 X 및 Y 오퍼레이션이 존재하는 경우에만 시맨틱을 &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 최소 '시맨틱'을 갖는 펜스 'B'와 동기화됩니다. A는 X보다 먼저 시퀀싱되고, Y는 B보다 먼저 동기화되고 Y는 M에 대한 변화를 관찰합니다. 이는 A와 B 사이의 사전 의존성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="55e68042fec783cba9aad8dce1b35e99ef85dbdf" translate="yes" xml:space="preserve">
          <source>A fence which has &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; ordering, in addition to having both &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; semantics, participates in the global program order of the other &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; operations and/or fences.</source>
          <target state="translated">보유 울타리 &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; 를&lt;/a&gt; 모두 갖는 외에, 순서를 &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; 다른 프로그램의 글로벌 순서 시멘틱스가 참여를 &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; 의&lt;/a&gt; 동작 및 / 또는 울타리.</target>
        </trans-unit>
        <trans-unit id="1cb36d0ee361d78dbe2fa3dcfcac72e9a2dee2b5" translate="yes" xml:space="preserve">
          <source>A field access is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt; referring to the location of that field. When the subexpression is &lt;a href=&quot;../expressions#mutability&quot;&gt;mutable&lt;/a&gt;, the field expression is also mutable.</source>
          <target state="translated">필드 액세스는 해당 필드의 위치를 ​​나타내는 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;장소 표현&lt;/a&gt; 입니다. 하위 표현식이 &lt;a href=&quot;../expressions#mutability&quot;&gt;변경 가능&lt;/a&gt; 하면 필드 표현식도 변경 가능합니다.</target>
        </trans-unit>
        <trans-unit id="f7e446184b876f98fd13cf13bfdf4f57607ba15b" translate="yes" xml:space="preserve">
          <source>A file wasn't found for an out-of-line module.</source>
          <target state="translated">라인 외부 모듈에 대한 파일을 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="730142c15726a49fe7ebbd5c1ceae068d1e76798" translate="yes" xml:space="preserve">
          <source>A final reason Rust doesn&amp;rsquo;t allow us to index into a &lt;code&gt;String&lt;/code&gt; to get a character is that indexing operations are expected to always take constant time (O(1)). But it isn&amp;rsquo;t possible to guarantee that performance with a &lt;code&gt;String&lt;/code&gt;, because Rust would have to walk through the contents from the beginning to the index to determine how many valid characters there were.</source>
          <target state="translated">Rust가 문자를 얻기 위해 &lt;code&gt;String&lt;/code&gt; 로 색인을 생성 할 수없는 마지막 이유 는 색인 작업이 항상 일정한 시간 (O (1))이 걸리기 때문입니다. 그러나 Rust는 유효한 문자 수를 결정하기 위해 처음부터 색인까지 내용을 탐색해야하기 때문에 &lt;code&gt;String&lt;/code&gt; 성능을 보장 할 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0106151a82df636bbbb97134363a6aef4336540d" translate="yes" xml:space="preserve">
          <source>A finite heterogeneous sequence, &lt;code&gt;(T, U, ..)&lt;/code&gt;.</source>
          <target state="translated">유한 이종 시퀀스 &lt;code&gt;(T, U, ..)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="405c2e4c1352a9dd275d0dcf43af6465cfa06fc2" translate="yes" xml:space="preserve">
          <source>A fixed-size array, denoted &lt;code&gt;[T; N]&lt;/code&gt;, for the element type, &lt;code&gt;T&lt;/code&gt;, and the non-negative compile-time constant size, &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">표시 고정 크기 어레이, &lt;code&gt;[T; N]&lt;/code&gt; , 요소 유형에 대한 &lt;code&gt;T&lt;/code&gt; 및 음이 아닌 컴파일 시간 상수 크기 &lt;code&gt;N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01e8ae155635ffa00df108a976552eb0550b9e9b" translate="yes" xml:space="preserve">
          <source>A for loop is equivalent to the following block expression.</source>
          <target state="translated">for 루프는 다음 블록 표현식과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b694a59d19302341ecbd00f4fa0cb3b358a2f81b" translate="yes" xml:space="preserve">
          <source>A format string is required to use all of its arguments, otherwise it is a compile-time error. You may refer to the same argument more than once in the format string.</source>
          <target state="translated">모든 인수를 사용하려면 형식 문자열이 필요합니다. 그렇지 않으면 컴파일 타임 오류입니다. 형식 문자열에서 동일한 인수를 두 번 이상 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01b7129399ded6b05b30578334c78e0c28495f39" translate="yes" xml:space="preserve">
          <source>A function annotated with the &lt;code&gt;test&lt;/code&gt; attribute can also be annotated with the &lt;code&gt;ignore&lt;/code&gt; attribute. The &lt;em&gt;&lt;code&gt;ignore&lt;/code&gt; attribute&lt;/em&gt; tells the test harness to not execute that function as a test. It will still be compiled when in test mode.</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 속성으로 주석이 달린 함수 는 &lt;code&gt;ignore&lt;/code&gt; 속성 으로 주석을 달 수도 있습니다 . 는 &lt;em&gt; &lt;code&gt;ignore&lt;/code&gt; 속성&lt;/em&gt; 테스트로서 그 기능을 실행하지 않는 테스트 장치를 말한다. 테스트 모드에있을 때는 여전히 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="05308286e6d20f1bc15a1d74d19f5246b35ba29f" translate="yes" xml:space="preserve">
          <source>A function annotated with the &lt;code&gt;test&lt;/code&gt; attribute that returns &lt;code&gt;()&lt;/code&gt; can also be annotated with the &lt;code&gt;should_panic&lt;/code&gt; attribute. The &lt;em&gt;&lt;code&gt;should_panic&lt;/code&gt; attribute&lt;/em&gt; makes the test only pass if it actually panics.</source>
          <target state="translated">&lt;code&gt;()&lt;/code&gt; 를 반환 하는 &lt;code&gt;test&lt;/code&gt; 속성으로 주석이 달린 함수 는 &lt;code&gt;should_panic&lt;/code&gt; 속성 으로 주석을 달 수 있습니다 . &lt;em&gt; &lt;code&gt;should_panic&lt;/code&gt; &lt;/em&gt;&lt;em&gt; 속성은&lt;/em&gt; 테스트 만하면 실제로 패닉을 통과한다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d9fe742a8fa7d8036e041c35d1e5b1052fe5c884" translate="yes" xml:space="preserve">
          <source>A function call isn't allowed in the const's initialization expression because the expression's value must be known at compile-time. Erroneous code example:</source>
          <target state="translated">표현식의 값을 컴파일 타임에 알아야하기 때문에 const의 초기화 표현식에서는 함수 호출이 허용되지 않습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="cdbab3b7a45160aa6bbfe85128d0bf7bac272328" translate="yes" xml:space="preserve">
          <source>A function declared in an extern block is implicitly &lt;code&gt;unsafe&lt;/code&gt;. When coerced to a function pointer, a function declared in an extern block has type &lt;code&gt;unsafe extern &quot;abi&quot; for&amp;lt;'l1, ..., 'lm&amp;gt; fn(A1, ..., An) -&amp;gt; R&lt;/code&gt;, where &lt;code&gt;'l1&lt;/code&gt;, ... &lt;code&gt;'lm&lt;/code&gt; are its lifetime parameters, &lt;code&gt;A1&lt;/code&gt;, ..., &lt;code&gt;An&lt;/code&gt; are the declared types of its parameters and &lt;code&gt;R&lt;/code&gt; is the declared return type.</source>
          <target state="translated">extern 블록에 선언 된 함수는 암시 적으로 &lt;code&gt;unsafe&lt;/code&gt; . 함수 포인터로 강제 변환되면, extern 블록에 선언 된 함수는 &lt;code&gt;unsafe extern &quot;abi&quot; for&amp;lt;'l1, ..., 'lm&amp;gt; fn(A1, ..., An) -&amp;gt; R&lt;/code&gt; 유형을 갖습니다 . 여기서 &lt;code&gt;'l1&lt;/code&gt; , ... &lt;code&gt;'lm&lt;/code&gt; 은 수명 매개 변수, &lt;code&gt;A1&lt;/code&gt; , ..., &lt;code&gt;An&lt;/code&gt; 은 매개 변수의 선언 된 유형이고 &lt;code&gt;R&lt;/code&gt; 은 선언 된 리턴 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d0692343f061c0cd9d5ae6d4139b26c55c59ad9f" translate="yes" xml:space="preserve">
          <source>A function is using &lt;code&gt;continue&lt;/code&gt; keyword incorrectly.</source>
          <target state="translated">함수가 &lt;code&gt;continue&lt;/code&gt; 키워드를 잘못 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0055fb8a733d1b0d5afb4ae44802bb8e5a0c86da" translate="yes" xml:space="preserve">
          <source>A function or function pointer.</source>
          <target state="translated">함수 또는 함수 포인터.</target>
        </trans-unit>
        <trans-unit id="b5bfe20067693f41e9be24910b3f1d1c865c4b39" translate="yes" xml:space="preserve">
          <source>A function signature must declare the number and type of parameters the function has. Macros, on the other hand, can take a variable number of parameters: we can call &lt;code&gt;println!(&quot;hello&quot;)&lt;/code&gt; with one argument or &lt;code&gt;println!(&quot;hello {}&quot;, name)&lt;/code&gt; with two arguments. Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. A function can&amp;rsquo;t, because it gets called at runtime and a trait needs to be implemented at compile time.</source>
          <target state="translated">함수 시그니처는 함수가 가진 매개 변수의 수와 유형을 선언해야합니다. 반면에 매크로는 가변 개수의 매개 변수를 사용할 수 있습니다 &lt;code&gt;println!(&quot;hello&quot;)&lt;/code&gt; 하나의 인수로 println! ( &quot;hello&quot;) 또는 두 개의 인수로 &lt;code&gt;println!(&quot;hello {}&quot;, name)&lt;/code&gt; 을 호출 할 수 있습니다. 또한 매크로는 컴파일러가 코드의 의미를 해석하기 전에 확장되므로 매크로는 예를 들어 지정된 유형에 특성을 구현할 수 있습니다. 함수는 런타임에 호출되고 특성은 컴파일 타임에 구현되어야하기 때문에 함수를 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cfea53bdada8b3687c10319a4dd10194cef976b7" translate="yes" xml:space="preserve">
          <source>A function that has a parameter or returns only numbers between 1 and 100 could then declare in its signature that it takes or returns a &lt;code&gt;Guess&lt;/code&gt; rather than an &lt;code&gt;i32&lt;/code&gt; and wouldn&amp;rsquo;t need to do any additional checks in its body.</source>
          <target state="translated">매개 변수가 있거나 1에서 100 사이의 숫자 만 반환하는 함수는 서명 에서 &lt;code&gt;i32&lt;/code&gt; 가 아닌 &lt;code&gt;Guess&lt;/code&gt; 를 가져 오거나 반환한다고 선언 할 수 있으며 본문에서 추가 검사를 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="330c21e7bd84509b137caeeff4bed7a7da24e5b7" translate="yes" xml:space="preserve">
          <source>A function that is opaque to the optimizer, to allow benchmarks to pretend to use outputs to assist in avoiding dead-code elimination.</source>
          <target state="translated">옵티 마이저에 대해 불투명 한 기능으로, 벤치 마크에서 출력을 사용하는 척하여 데드 코드 제거를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2ed9af48e681bbf5a9216d3deb00de57795222b" translate="yes" xml:space="preserve">
          <source>A function with the &lt;code&gt;start&lt;/code&gt; attribute was declared with type parameters.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 속성을 가진 함수가 유형 매개 변수로 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="cc716e4e83b4efb34e4101d17ccb62e4b2b1eb26" translate="yes" xml:space="preserve">
          <source>A fundamental trait is one where adding an impl of it for an existing type is a breaking change. The &lt;code&gt;Fn&lt;/code&gt; traits and &lt;code&gt;Sized&lt;/code&gt; are fundamental.</source>
          <target state="translated">근본적인 특성은 기존 유형에 대한 impl을 추가하는 것이 브레이킹 체인지입니다. &lt;code&gt;Fn&lt;/code&gt; 을 특성과 &lt;code&gt;Sized&lt;/code&gt; 기본이다.</target>
        </trans-unit>
        <trans-unit id="0649f34bf1c96947359554a4e3b1fb6bd7f77d90" translate="yes" xml:space="preserve">
          <source>A fundamental type constructor is a type where implementing a &lt;a href=&quot;#blanket-implementation&quot;&gt;blanket implementation&lt;/a&gt; over it is a breaking change. &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;mut&lt;/code&gt;, &lt;code&gt;Box&lt;/code&gt;, and &lt;code&gt;Pin&lt;/code&gt; are fundamental.</source>
          <target state="translated">기본 형식 생성자는 그 위에 &lt;a href=&quot;#blanket-implementation&quot;&gt;블랭킷 구현을 구현&lt;/a&gt; 하는 것이 주요 변경 인 형식입니다. &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;&amp;amp;mut&lt;/code&gt; , &lt;code&gt;Box&lt;/code&gt; 및 &lt;code&gt;Pin&lt;/code&gt; 은 기본입니다.</target>
        </trans-unit>
        <trans-unit id="b104136e74bd26ea4949e609270e7bafb60abae9" translate="yes" xml:space="preserve">
          <source>A future is a value that may not have finished computing yet. This kind of &quot;asynchronous value&quot; makes it possible for a thread to continue doing useful work while it waits for the value to become available.</source>
          <target state="translated">미래는 아직 컴퓨팅을 마치지 못한 가치입니다. 이런 종류의 &quot;비동기 값&quot;은 값을 사용할 수있을 때까지 스레드가 유용한 작업을 계속 수행 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="7c377e6c372ce66665ebea21944588366ee85648" translate="yes" xml:space="preserve">
          <source>A future represents an asynchronous computation.</source>
          <target state="translated">미래는 비동기 계산을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c1da397a075afa74abc70c7bb33c6bfaa50fd933" translate="yes" xml:space="preserve">
          <source>A generalization of &lt;code&gt;Clone&lt;/code&gt; to borrowed data.</source>
          <target state="translated">빌린 데이터에 대한 &lt;code&gt;Clone&lt;/code&gt; 의 일반화 .</target>
        </trans-unit>
        <trans-unit id="851d3775359dee45f6fc12b7c593dac300677e98" translate="yes" xml:space="preserve">
          <source>A generic function must be treated similarly:</source>
          <target state="translated">일반 함수는 다음과 유사하게 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="47dc8336e1d401035013095c768eec4aaa7de80d" translate="yes" xml:space="preserve">
          <source>A generic type was described using parentheses rather than angle brackets.</source>
          <target state="translated">일반 유형은 꺾쇠 괄호 대신 괄호를 사용하여 설명되었습니다.</target>
        </trans-unit>
        <trans-unit id="b9e2cdc9d185c52c49734ce26b1038e50519630f" translate="yes" xml:space="preserve">
          <source>A generic type was described using parentheses rather than angle brackets. For example:</source>
          <target state="translated">괄호 대신 괄호를 사용하여 일반 유형을 설명했습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d667559155454841982582189ab274f14a49b2bf" translate="yes" xml:space="preserve">
          <source>A generic type where one or more associated types have specific assignments (e.g., &lt;code&gt;Iterator&amp;lt;Item=T&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">하나 이상의 연관된 유형에 특정 지정이있는 일반 유형 (예 : &lt;code&gt;Iterator&amp;lt;Item=T&amp;gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6f0496f55807a095b66d7d51e944864622ad78d2" translate="yes" xml:space="preserve">
          <source>A ghastly note 👻👻👻</source>
          <target state="translated">대단한 메모 👻👻👻</target>
        </trans-unit>
        <trans-unit id="91fcac820244ae988bc857941377bad5a84fac8d" translate="yes" xml:space="preserve">
          <source>A given matcher M maps to three sets: FIRST(M), LAST(M) and FOLLOW(M).</source>
          <target state="translated">주어진 매처 M은 FIRST (M), LAST (M) 및 FOLLOW (M)의 세 세트에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="ce503e49f8d95cbc61a21e14a3b1dd613e9d99ae" translate="yes" xml:space="preserve">
          <source>A great example of a situation where this technique is useful is with operator overloading. &lt;em&gt;Operator overloading&lt;/em&gt; is customizing the behavior of an operator (such as &lt;code&gt;+&lt;/code&gt;) in particular situations.</source>
          <target state="translated">이 기술이 유용한 상황의 좋은 예는 운영자 과부하입니다. &lt;em&gt;연산자 과부하&lt;/em&gt; 는 특정 상황에서 연산자의 동작 (예 : &lt;code&gt;+&lt;/code&gt; )을 사용자 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="77b606312f70d0e0e8a4e81eb457af73b41943c1" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; does not permit zero-initialization: This will statically either panic, or do nothing.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 제로 초기화를 허용하지 않으면 실행될 수없는 안전하지 않은 기능에 대한 보호 : 이것은 정적으로 패닉 상태가되거나 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73d1fa93ccd1713ed23cb21dd7e4493abed0a332" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; has invalid bit patterns: This will statically either panic, or do nothing.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 에 유효하지 않은 비트 패턴이있는 경우 실행할 수없는 안전하지 않은 함수에 대한 가드 : 정적으로 패닉 상태가되거나 아무 작업도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e24815403ad3a79092fe51890734de71f5057ede" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; is uninhabited: This will statically either panic, or do nothing.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 무인 상태 일 때 실행할 수없는 안전하지 않은 기능에 대한 보호 : 정적으로 패닉 상태이거나 아무 것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a319cd7f43cac10207753e127b6908e7ad723f6" translate="yes" xml:space="preserve">
          <source>A handle to a child process's standard input (stdin).</source>
          <target state="translated">자식 프로세스의 표준 입력 (stdin)에 대한 핸들.</target>
        </trans-unit>
        <trans-unit id="1c0c017d7e2d5d79869d31d54d7aed18a0e39b40" translate="yes" xml:space="preserve">
          <source>A handle to a child process's standard output (stdout).</source>
          <target state="translated">자식 프로세스의 표준 출력 (stdout)에 대한 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="36463654df6f05a2c5f7eb7e4b2efec9b5402d6f" translate="yes" xml:space="preserve">
          <source>A handle to a child process's stderr.</source>
          <target state="translated">자식 프로세스의 stderr에 대한 핸들.</target>
        </trans-unit>
        <trans-unit id="539b8b33fb86eae0a19eb8338bbb41567108f8bd" translate="yes" xml:space="preserve">
          <source>A handle to a thread.</source>
          <target state="translated">스레드 핸들.</target>
        </trans-unit>
        <trans-unit id="e4354965858e59daba47e025f6bf432587785439" translate="yes" xml:space="preserve">
          <source>A handle to the global standard output stream of the current process.</source>
          <target state="translated">현재 프로세스의 글로벌 표준 출력 스트림에 대한 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="4e5458b43a1ef2ac995209fb2fb9a0f1f086d8ff" translate="yes" xml:space="preserve">
          <source>A handle to the standard error stream of a process.</source>
          <target state="translated">프로세스의 표준 오류 스트림에 대한 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="c04e6d93f5332bb8558883edf3c0666a1ead6820" translate="yes" xml:space="preserve">
          <source>A handle to the standard input stream of a process.</source>
          <target state="translated">프로세스의 표준 입력 스트림에 대한 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="52f29960ee00cd31852f436ce3c064a63d21c4a9" translate="yes" xml:space="preserve">
          <source>A hash map implemented with linear probing and Robin Hood bucket stealing.</source>
          <target state="translated">선형 프로빙 및 Robin Hood 버킷 스틸 링으로 구현 된 해시 맵입니다.</target>
        </trans-unit>
        <trans-unit id="1b24fb3ba32189304beb3027b487b7bde1af7301" translate="yes" xml:space="preserve">
          <source>A hash map implemented with quadratic probing and SIMD lookup.</source>
          <target state="translated">2 차 프로빙 및 SIMD 조회로 구현 된 해시 맵입니다.</target>
        </trans-unit>
        <trans-unit id="3236fb9d674df64208b5e1cf2d78d481f577b4f2" translate="yes" xml:space="preserve">
          <source>A hash set implemented as a &lt;code&gt;HashMap&lt;/code&gt; where the value is &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;()&lt;/code&gt; 인 &lt;code&gt;HashMap&lt;/code&gt; 으로 구현 된 해시 세트 입니다.</target>
        </trans-unit>
        <trans-unit id="4944fd02934cfc33b70591237170d7c0599ffebd" translate="yes" xml:space="preserve">
          <source>A hashable type.</source>
          <target state="translated">해시 가능 유형</target>
        </trans-unit>
        <trans-unit id="4d0ef9738cd0ca2c9edcc6b3b923fd916c2b5807" translate="yes" xml:space="preserve">
          <source>A helper struct for reverse ordering.</source>
          <target state="translated">역순 정렬을위한 도우미 구조체</target>
        </trans-unit>
        <trans-unit id="2fcfddbae21727b9845f52dbf5c24515e281ef8f" translate="yes" xml:space="preserve">
          <source>A helper trait used for indexing operations.</source>
          <target state="translated">인덱싱 작업에 사용되는 도우미 특성입니다.</target>
        </trans-unit>
        <trans-unit id="29862de09ef195f3021bf8c1026b55bc84123b69" translate="yes" xml:space="preserve">
          <source>A incorrectly formatted &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; will produce an error.</source>
          <target state="translated">잘못된 형식의 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; 는 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2e3f1a456a73954f3da04455c2ebc9a53acd9daf" translate="yes" xml:space="preserve">
          <source>A lang item was redefined.</source>
          <target state="translated">랭 아이템이 재정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="6ffd27d3b6539a3465361b45b3e5461748a1b187" translate="yes" xml:space="preserve">
          <source>A large number of the structures provided by &lt;code&gt;std::io&lt;/code&gt; are for various ways of iterating over I/O. For example, &lt;a href=&quot;struct.lines&quot;&gt;&lt;code&gt;Lines&lt;/code&gt;&lt;/a&gt; is used to split over lines:</source>
          <target state="translated">&lt;code&gt;std::io&lt;/code&gt; 가 제공하는 많은 구조는 I / O를 반복하는 다양한 방법을위한 것입니다. 예를 들어 &lt;a href=&quot;struct.lines&quot;&gt; &lt;code&gt;Lines&lt;/code&gt; &lt;/a&gt; 은 선 을 분할하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="662b6a3ff994171dfffca1e061e7e8ce70b26c02" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the difference of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; 의 차이에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="78a980f05e3a46c3d69eb02390416d427839b9ce" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the difference of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 의 차이에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="b8f2ea928876732f6cdd8b20aeb46e1a07becd11" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the intersection of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; 의 교차점에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="298c27c033e43f06428f6ee3aa3dd406f79bfc1d" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the intersection of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 의 교차점에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="5e5f0a0d812adca265e03240d1f5f96e6f3c302c" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the symmetric difference of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; 의 대칭 적 차이에서 요소를 생성하는 지연 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="5248d39b20b8a278703de3ef71e840882448f153" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the symmetric difference of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 의 대칭 적 차이에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="0f9f2f9fdddb7747ea07bd3f3640c23d49782e5c" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the union of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; 조합에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="fc9bf6d7c1e4850a63411aee9c08fbc8782aa61a" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the union of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 통합에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="32415c91edd2506ae578a648363d87b8a79c9954" translate="yes" xml:space="preserve">
          <source>A library developer needs to expose functionality to crates which link against their library. As a consequence of the first case, this means that anything which is usable externally must be &lt;code&gt;pub&lt;/code&gt; from the root down to the destination item. Any private item in the chain will disallow external accesses.</source>
          <target state="translated">라이브러리 개발자는 라이브러리와 링크되는 크레이트에 기능을 노출해야합니다. 첫 번째 경우의 결과로 외부에서 사용할 수있는 것은 루트에서 대상 항목까지 &lt;code&gt;pub&lt;/code&gt; 이어야합니다 . 체인의 모든 개인 품목은 외부 액세스를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ffc7aa510e5357070634b59c577ca85e2c2292b" translate="yes" xml:space="preserve">
          <source>A lifetime appears only in an associated-type binding, and not in the input types to the trait.</source>
          <target state="translated">수명은 특성에 대한 입력 유형이 아니라 연관된 유형 바인딩에만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="15786eaf619ace068790ae58d796d7da4d047a8c" translate="yes" xml:space="preserve">
          <source>A lifetime bound on a trait implementation was captured at an incorrect place.</source>
          <target state="translated">특성 구현에 대한 수명이 잘못된 위치에서 캡처되었습니다.</target>
        </trans-unit>
        <trans-unit id="7c38295bdcc0eafcba2929a676ec6ceb8e9304c9" translate="yes" xml:space="preserve">
          <source>A lifetime bound was not satisfied.</source>
          <target state="translated">수명 한계가 충족되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="f5eb99d9ba1d633f5bab932159c4263f91c6e225" translate="yes" xml:space="preserve">
          <source>A lifetime cannot be determined in the given situation.</source>
          <target state="translated">주어진 상황에서 수명을 결정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f5cad79ba7fd3784fc14fc3f6b2c2d3527062c63" translate="yes" xml:space="preserve">
          <source>A lifetime didn't match what was expected.</source>
          <target state="translated">일생이 예상했던 것과 일치하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="f2036255cc30a38458aebc41a1b7522c2030656d" translate="yes" xml:space="preserve">
          <source>A lifetime is only present in an associated-type binding, and not in the input types to the trait.</source>
          <target state="translated">수명은 트레이 트에 대한 입력 유형이 아닌 연관된 유형 바인딩에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="7b0bc06cbbd42c2c42f3c7edb056daf04c8c1022" translate="yes" xml:space="preserve">
          <source>A lifetime name cannot be declared more than once in the same scope. For example:</source>
          <target state="translated">수명 범위 이름은 동일한 범위에서 두 번 이상 선언 될 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="315c1653fb8738d323beeedab26038fcdebdd0a1" translate="yes" xml:space="preserve">
          <source>A lifetime name is shadowing another lifetime name.</source>
          <target state="translated">평생 이름이 다른 평생 이름을 숨기고 있습니다.</target>
        </trans-unit>
        <trans-unit id="24a3a2bd418c09a4c4c2d74fd258bdb9f00cd151" translate="yes" xml:space="preserve">
          <source>A lifetime name is shadowing another lifetime name. Erroneous code example:</source>
          <target state="translated">평생 이름이 다른 평생 이름을 가리고 있습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="60dd9352a1988e94c38ce60166a9c885adb54457" translate="yes" xml:space="preserve">
          <source>A lifetime was declared more than once in the same scope.</source>
          <target state="translated">동일한 범위에서 수명이 두 번 이상 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="6c742ea21e8d68de6fe9c8cd053579ea9357b0ab" translate="yes" xml:space="preserve">
          <source>A link name was given with an empty name.</source>
          <target state="translated">빈 이름으로 링크 이름이 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="e76bb7dad8b82c5bd8c5e995749d2ddcac1434e4" translate="yes" xml:space="preserve">
          <source>A link name was given with an empty name. Erroneous code example:</source>
          <target state="translated">빈 이름으로 링크 이름이 지정되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="7aff8ae0fa99ab18b982ebf4bf49db472c773b53" translate="yes" xml:space="preserve">
          <source>A link was used without a name parameter.</source>
          <target state="translated">이름 매개 변수없이 링크가 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="916890e2e829b39ca74b6c85b7ab19a70dff37fc" translate="yes" xml:space="preserve">
          <source>A link was used without a name parameter. Erroneous code example:</source>
          <target state="translated">이름 매개 변수없이 링크가 사용되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="ac64cfd6177747480c1f0a80dd27bc3c2253949c" translate="yes" xml:space="preserve">
          <source>A lint check attribute was overruled by a &lt;code&gt;forbid&lt;/code&gt; directive set as an attribute on an enclosing scope, or on the command line with the &lt;code&gt;-F&lt;/code&gt; option.</source>
          <target state="translated">보푸라기 검사 속성이 묶는 범위 또는 &lt;code&gt;-F&lt;/code&gt; 옵션 을 사용하여 명령 줄에서 속성으로 설정된 &lt;code&gt;forbid&lt;/code&gt; 지시문 으로 인해 무효화되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4ec2e82a43ec2456c074c084d9bde606ea9ab3b3" translate="yes" xml:space="preserve">
          <source>A lint check names a potentially undesirable coding pattern, such as unreachable code or omitted documentation. The lint attributes &lt;code&gt;allow&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;deny&lt;/code&gt;, and &lt;code&gt;forbid&lt;/code&gt; use the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; syntax to specify a list of lint names to change the lint level for the entity to which the attribute applies.</source>
          <target state="translated">린트 검사는 도달 할 수없는 코드 또는 생략 된 문서와 같이 잠재적으로 바람직하지 않은 코딩 패턴의 이름을 지정합니다. 린트 속성은 &lt;code&gt;allow&lt;/code&gt; , &lt;code&gt;warn&lt;/code&gt; , &lt;code&gt;deny&lt;/code&gt; 및 &lt;code&gt;forbid&lt;/code&gt; 를 사용 &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; 속성이 적용되는 개체에 대한 보풀 수준을 변경 보풀 이름의 목록을 지정하는 구문을.</target>
        </trans-unit>
        <trans-unit id="2f470d70068148b9c3f60f9da5c6e02f3a36f8a9" translate="yes" xml:space="preserve">
          <source>A list of available external lang items is available in &lt;code&gt;src/librustc/middle/weak_lang_items.rs&lt;/code&gt;. Example:</source>
          <target state="translated">사용 가능한 외부 랭 항목 목록은 &lt;code&gt;src/librustc/middle/weak_lang_items.rs&lt;/code&gt; 에서 사용할 수 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="a93ce4eba1c20223d4f7efd374435922dc780a28" translate="yes" xml:space="preserve">
          <source>A list of available external lang items is available in &lt;code&gt;src/librustc_middle/middle/weak_lang_items.rs&lt;/code&gt;. Example:</source>
          <target state="translated">사용 가능한 외부 lang 항목 목록은 &lt;code&gt;src/librustc_middle/middle/weak_lang_items.rs&lt;/code&gt; 에 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="508df8833b23d4b6921f12bfae0871fdb8efa7ce" translate="yes" xml:space="preserve">
          <source>A list specifying general categories of I/O error.</source>
          <target state="translated">일반적인 I / O 오류 범주를 지정하는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="6afbc1cd2e7b35cec4d1c86812f59ca981f43d9f" translate="yes" xml:space="preserve">
          <source>A list with each element, i.e., &lt;code&gt;[x, y, z]&lt;/code&gt;.</source>
          <target state="translated">각 요소, 즉, 함께 목록 &lt;code&gt;[x, y, z]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15c8d2d5a110eff4a4e3eff0337b45af3836ff58" translate="yes" xml:space="preserve">
          <source>A literal is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it evaluates to, rather than referring to it by name or some other evaluation rule. A literal is a form of &lt;a href=&quot;const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, so is evaluated (primarily) at compile time.</source>
          <target state="translated">리터럴은 일련의 토큰이 아닌 단일 토큰으로 구성되는 표현식으로, 이름이나 다른 평가 규칙으로 참조하지 않고 평가하는 값을 즉시 직접 나타냅니다. 리터럴은 &lt;a href=&quot;const_eval#constant-expressions&quot;&gt;상수 표현식&lt;/a&gt; 의 형태 이므로 컴파일 타임에 (주로) 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="1857afd88875f6678401e5a6388b40ec5e076688" translate="yes" xml:space="preserve">
          <source>A literal value was used inside &lt;code&gt;#[derive]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;#[derive]&lt;/code&gt; 내부에 리터럴 값이 사용되었습니다 .</target>
        </trans-unit>
        <trans-unit id="7acc2bbca8147fd009370161f8e9ac4665c257d0" translate="yes" xml:space="preserve">
          <source>A literal was used in a built-in attribute that doesn't support literals.</source>
          <target state="translated">리터럴은 리터럴을 지원하지 않는 내장 속성에 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="efa9c544d88ff2ed4857caf7a6d5b87ab71f9e34" translate="yes" xml:space="preserve">
          <source>A little reminder: a doc comment has to be placed before the item it's supposed to document. So if you want to document the &lt;code&gt;Island&lt;/code&gt; trait, you need to put a doc comment before it, not inside it. Same goes for the &lt;code&gt;lost&lt;/code&gt; method: the doc comment needs to be before it:</source>
          <target state="translated">약간의 알림 : 문서 주석은 문서화 할 항목 앞에 배치해야합니다. 따라서 &lt;code&gt;Island&lt;/code&gt; 특성 을 문서화하려면 내부가 아니라 그 앞에 문서 주석을 추가해야합니다. &lt;code&gt;lost&lt;/code&gt; 방법도 마찬가지입니다 . 문서 주석은 앞에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8c7298eaf33d5d7b34d2bf261698fdf05d319588" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stderr&lt;/code&gt; handle.</source>
          <target state="translated">&lt;code&gt;Stderr&lt;/code&gt; 핸들에 대한 잠긴 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="e64008e4cbb40a24042f57f0ba8206541604d8ca" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stdin&lt;/code&gt; handle.</source>
          <target state="translated">&lt;code&gt;Stdin&lt;/code&gt; 핸들에 대한 잠긴 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="27f936b73151ca7329818fe3daa46cf14b38bc95" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stdout&lt;/code&gt; handle.</source>
          <target state="translated">&lt;code&gt;Stdout&lt;/code&gt; 핸들에 대한 잠긴 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="209614c8cbb6478d39bb33efacb63355ac82d199" translate="yes" xml:space="preserve">
          <source>A locked standard input implements &lt;code&gt;BufRead&lt;/code&gt;:</source>
          <target state="translated">잠긴 표준 입력은 &lt;code&gt;BufRead&lt;/code&gt; 를 구현 합니다 .</target>
        </trans-unit>
        <trans-unit id="3af527db8725fae95a62589160c6f0f2118456fd" translate="yes" xml:space="preserve">
          <source>A loop expression may optionally have a &lt;em&gt;label&lt;/em&gt;. The label is written as a lifetime preceding the loop expression, as in &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt;, &lt;code&gt;'bar: while false {}&lt;/code&gt;, &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt;. If a label is present, then labeled &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; expressions nested within this loop may exit out of this loop or return control to its head. See &lt;a href=&quot;#break-expressions&quot;&gt;break expressions&lt;/a&gt; and &lt;a href=&quot;#continue-expressions&quot;&gt;continue expressions&lt;/a&gt;.</source>
          <target state="translated">루프 표현식은 선택적으로 &lt;em&gt;레이블을&lt;/em&gt; 가질 수 있습니다 . 레이블은 &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt; , &lt;code&gt;'bar: while false {}&lt;/code&gt; , &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt; . 레이블이 있는 경우이 루프 내에 중첩 된 레이블이 지정된 &lt;code&gt;break&lt;/code&gt; 및 &lt;code&gt;continue&lt;/code&gt; 표현식은이 루프를 종료하거나 제어를 헤드로 반환 할 수 있습니다. &lt;a href=&quot;#break-expressions&quot;&gt;break 표현식&lt;/a&gt; 및 &lt;a href=&quot;#continue-expressions&quot;&gt;continue 표현식을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3748fe7789bb3fdcadf97f48b577f7242f80249c" translate="yes" xml:space="preserve">
          <source>A loop expression may optionally have a &lt;em&gt;label&lt;/em&gt;. The label is written as a lifetime preceding the loop expression, as in &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt;, &lt;code&gt;'bar: while false {}&lt;/code&gt;, &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt;. If a label is present, then labeled &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; expressions nested within this loop may exit out of this loop or return control to its head. See &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;break expressions&lt;/a&gt; and &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;continue expressions&lt;/a&gt;.</source>
          <target state="translated">루프 표현식은 선택적으로 &lt;em&gt;label을&lt;/em&gt; 가질 수 있습니다 . 레이블은 &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt; 에서와 같이 루프 표현식 앞에 수명으로 기록됩니다 . } , &lt;code&gt;'bar: while false {}&lt;/code&gt; , &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt; . 레이블이 있으면 이 루프 내에 중첩 된 &lt;code&gt;break&lt;/code&gt; 된 break 및 &lt;code&gt;continue&lt;/code&gt; 표현식이이 루프를 종료하거나 제어를 헤드로 리턴 할 수 있습니다. &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;구분 표현식&lt;/a&gt; 및 &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;계속 표현식을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="621a2333164d1c1ddcc3e28445c529a5edcd0f4d" translate="yes" xml:space="preserve">
          <source>A loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) was used inside a closure but outside of any loop.</source>
          <target state="translated">루프 키워드 ( &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;continue&lt;/code&gt; )가 클로저 내부에서 사용되었지만 루프 외부에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="f49094ffad160345ac5b867a45ab1d0476b39ead" translate="yes" xml:space="preserve">
          <source>A loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) was used outside of a loop.</source>
          <target state="translated">루프 키워드 ( &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;continue&lt;/code&gt; )가 루프 외부에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="511e4a1a5b552d0daef468f2387fb6edd0e92546" translate="yes" xml:space="preserve">
          <source>A lossy decoder can be obtained by replacing &lt;code&gt;Err&lt;/code&gt; results with the replacement character:</source>
          <target state="translated">&lt;code&gt;Err&lt;/code&gt; 결과를 대체 문자 로 바꾸면 손실이있는 디코더를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aaa61df7a5c37f0e9baf2b1d7a2af95d48009664" translate="yes" xml:space="preserve">
          <source>A lower range wasn't less than the upper range.</source>
          <target state="translated">낮은 범위는 높은 범위보다 작지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d97f1261b9b58d3e3fe4caf6b3ed4e3d57f050f7" translate="yes" xml:space="preserve">
          <source>A macro invocation executes a macro at compile time and replaces the invocation with the result of the macro. Macros may be invoked in the following situations:</source>
          <target state="translated">매크로 호출은 컴파일 타임에 매크로를 실행하고 호출을 매크로 결과로 대체합니다. 다음과 같은 상황에서 매크로가 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="604f17220a435dfda6ce25b3286e96cae9c124f4" translate="yes" xml:space="preserve">
          <source>A macro listed for import was not found.</source>
          <target state="translated">가져 오기 위해 나열된 매크로를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2e0526607109d7012469029a56fd3ee785be2e0d" translate="yes" xml:space="preserve">
          <source>A macro to test at &lt;em&gt;runtime&lt;/em&gt; whether a CPU feature is available on x86/x86-64 platforms.</source>
          <target state="translated">x86 / x86-64 플랫폼에서 CPU 기능을 사용할 수 있는지 여부 를 &lt;em&gt;런타임&lt;/em&gt; 에 테스트하는 매크로 입니다.</target>
        </trans-unit>
        <trans-unit id="5b9ba25200988be7523c79ceef0a08b5dbf3a289" translate="yes" xml:space="preserve">
          <source>A major goal of the compiler is to ensure that a library never appears more than once in any artifact. For example, if dynamic libraries B and C were each statically linked to library A, then a crate could not link to B and C together because there would be two copies of A. The compiler allows mixing the rlib and dylib formats, but this restriction must be satisfied.</source>
          <target state="translated">컴파일러의 주요 목표는 라이브러리가 아티팩트에 두 번 이상 나타나지 않도록하는 것입니다. 예를 들어, 동적 라이브러리 B와 C가 각각 라이브러리 A에 정적으로 링크 된 경우, 두 개의 사본이 있으므로 상자가 B와 C에 연결할 수 없습니다. 컴파일러는 rlib와 dylib 형식을 혼합 할 수 있지만이 제한은 만족해야합니다.</target>
        </trans-unit>
        <trans-unit id="416ce06261874aaff012fa6c737cea866a967092" translate="yes" xml:space="preserve">
          <source>A map based on a B-Tree.</source>
          <target state="translated">B- 트리를 기반으로하는지도.</target>
        </trans-unit>
        <trans-unit id="f2df32e1b651fa8937f10fb914a69befa91dcf32" translate="yes" xml:space="preserve">
          <source>A marker trait representing types where a shared reference is considered unwind safe.</source>
          <target state="translated">공유 참조가 안전하지 않은 것으로 간주되는 유형을 나타내는 마커 특성.</target>
        </trans-unit>
        <trans-unit id="3bc97c0d55aa2cae1126bc3f3d83ef27e23658de" translate="yes" xml:space="preserve">
          <source>A marker trait to express that a &lt;a href=&quot;trait.reversesearcher&quot;&gt;&lt;code&gt;ReverseSearcher&lt;/code&gt;&lt;/a&gt; can be used for a &lt;a href=&quot;../../iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">&lt;a href=&quot;../../iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt; 구현에 &lt;a href=&quot;trait.reversesearcher&quot;&gt; &lt;code&gt;ReverseSearcher&lt;/code&gt; 를&lt;/a&gt; 사용할 수 있음 을 나타내는 마커 특성 입니다.</target>
        </trans-unit>
        <trans-unit id="ba67e3276d83805bffe74ea0a7a327593cf9467b" translate="yes" xml:space="preserve">
          <source>A marker trait to express that a &lt;code&gt;ReverseSearcher&lt;/code&gt; can be used for a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; implementation.</source>
          <target state="translated">&lt;code&gt;DoubleEndedIterator&lt;/code&gt; 구현에 &lt;code&gt;ReverseSearcher&lt;/code&gt; 를 사용할 수 있음 을 나타내는 마커 특성 .</target>
        </trans-unit>
        <trans-unit id="2f67969c6f12d96330ceaae49a9df5d58837b264" translate="yes" xml:space="preserve">
          <source>A marker trait which represents &quot;panic safe&quot; types in Rust.</source>
          <target state="translated">Rust에서 &quot;panic safe&quot;유형을 나타내는 마커 특성.</target>
        </trans-unit>
        <trans-unit id="7c9160659faee9d41f691cb8f88f2f8a49c219c0" translate="yes" xml:space="preserve">
          <source>A marker type which does not implement &lt;code&gt;Unpin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Unpin&lt;/code&gt; 을 구현하지 않는 마커 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="2cd086d02e989df16ae8561bd2410188577f706c" translate="yes" xml:space="preserve">
          <source>A measurement of a monotonically nondecreasing clock. Opaque and useful only with &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">단조 비 감소 클록의 측정치입니다. 불투명하고 &lt;code&gt;Duration&lt;/code&gt; 에서만 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="f1b2d1acc7998286a04c3bbe416b5e64b3d2a408" translate="yes" xml:space="preserve">
          <source>A measurement of the system clock, useful for talking to external entities like the file system or other processes.</source>
          <target state="translated">파일 시스템이나 다른 프로세스와 같은 외부 엔터티와 통신하는 데 유용한 시스템 클록 측정입니다.</target>
        </trans-unit>
        <trans-unit id="ab0a8ccacb7225c2d2eaa3d61513ce8be0301515" translate="yes" xml:space="preserve">
          <source>A memory allocator that can be registered as the standard library&amp;rsquo;s default though the &lt;code&gt;#[global_allocator]&lt;/code&gt; attributes.</source>
          <target state="translated">&lt;code&gt;#[global_allocator]&lt;/code&gt; 속성 을 통해 표준 라이브러리의 기본값으로 등록 할 수있는 메모리 할당 자 .</target>
        </trans-unit>
        <trans-unit id="36390b8dd6062ca0b9666a02db751bef68ddc91f" translate="yes" xml:space="preserve">
          <source>A memory allocator that can be registered as the standard library&amp;rsquo;s default through the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;#[global_allocator]&lt;/code&gt; 속성을 통해 표준 라이브러리의 기본값으로 등록 할 수있는 메모리 할당 자입니다 .</target>
        </trans-unit>
        <trans-unit id="f52897b7b1a254a773b596ff34aeb774856f7c04" translate="yes" xml:space="preserve">
          <source>A metavariable must appear in exactly the same number, kind, and nesting order of repetitions in the transcriber as it did in the matcher. So for the matcher &lt;code&gt;$( $i:ident ),*&lt;/code&gt;, the transcribers &lt;code&gt;=&amp;gt; { $i }&lt;/code&gt;, &lt;code&gt;=&amp;gt; { $( $( $i)* )* }&lt;/code&gt;, and &lt;code&gt;=&amp;gt; { $( $i )+ }&lt;/code&gt; are all illegal, but &lt;code&gt;=&amp;gt; { $( $i );* }&lt;/code&gt; is correct and replaces a comma-separated list of identifiers with a semicolon-separated list.</source>
          <target state="translated">메타 변수는 매처에서와 마찬가지로 전 사기에서 정확히 동일한 수, 종류 및 반복 순서로 나타나야합니다. 따라서 매처 &lt;code&gt;$( $i:ident ),*&lt;/code&gt; 의 경우 전사자는 &lt;code&gt;=&amp;gt; { $i }&lt;/code&gt; , &lt;code&gt;=&amp;gt; { $( $( $i)* )* }&lt;/code&gt; 및 &lt;code&gt;=&amp;gt; { $( $i )+ }&lt;/code&gt; 입니다. 모두 불법이지만 &lt;code&gt;=&amp;gt; { $( $i );* }&lt;/code&gt; 는 정확하며 쉼표로 구분 된 식별자 목록을 세미콜론으로 구분 된 목록으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="8b9a4a11c65ef071b5b26c72c1c0d6cc7317036f" translate="yes" xml:space="preserve">
          <source>A method or constant was implemented on a primitive type.</source>
          <target state="translated">기본 유형에 메서드 또는 상수가 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="801757bf4a897de3dc38db9dc1b65e4429ae7c96" translate="yes" xml:space="preserve">
          <source>A method was called on a raw pointer whose inner type wasn't completely known.</source>
          <target state="translated">내부 유형이 완전히 알려지지 않은 원시 포인터에서 메소드가 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="da23ec6794439455d8bda2444d9dc191c1a91b2b" translate="yes" xml:space="preserve">
          <source>A method was called on an ambiguous numeric type.</source>
          <target state="translated">모호한 숫자 유형에서 메소드가 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="cb6424b2d67ae2d104f32890640da913ac560f8f" translate="yes" xml:space="preserve">
          <source>A method was implemented on a primitive type.</source>
          <target state="translated">기본 유형에 메소드가 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="b83bd54b545ece8364d586c3e7f838baf02e8c65" translate="yes" xml:space="preserve">
          <source>A method was implemented when another trait item was expected.</source>
          <target state="translated">다른 특성 항목이 예상 될 때 메서드가 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="0b9ba16b85d0fa75f6c2790fe89555c2da2a5ee8" translate="yes" xml:space="preserve">
          <source>A method was implemented when another trait item was expected. Erroneous code example:</source>
          <target state="translated">다른 특성 항목이 예상 될 때 방법이 구현되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="30d915c6907e57ec215e0d955c2fea0a426c859a" translate="yes" xml:space="preserve">
          <source>A module can import both &lt;code&gt;std::fmt::Write&lt;/code&gt; and &lt;code&gt;std::io::Write&lt;/code&gt; and call &lt;code&gt;write!&lt;/code&gt; on objects implementing either, as objects do not typically implement both. However, the module must import the traits qualified so their names do not conflict:</source>
          <target state="translated">모듈은 &lt;code&gt;std::fmt::Write&lt;/code&gt; 와 &lt;code&gt;std::io::Write&lt;/code&gt; 와 call &lt;code&gt;write!&lt;/code&gt; 모두 가져올 수 있습니다 ! 객체는 일반적으로 둘 다를 구현하지 않으므로 객체를 구현합니다. 그러나 모듈은 이름이 충돌하지 않도록 규정 된 특성을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="8df0b4f7cbe7a3d63c8935c00a09e49b670eda46" translate="yes" xml:space="preserve">
          <source>A module cannot be found and therefore, the visibility cannot be determined.</source>
          <target state="translated">모듈을 찾을 수 없으므로 가시성을 결정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9b81303b4be9b1fd6a4b7a6468837e80d06c4579" translate="yes" xml:space="preserve">
          <source>A module for working with borrowed data.</source>
          <target state="translated">빌린 데이터 작업을위한 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="279721754abe896ed73051fc4e21afc678f9887f" translate="yes" xml:space="preserve">
          <source>A module for working with processes.</source>
          <target state="translated">프로세스 작업을위한 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="6a05a78578f1dbd0078ba611f8fe4d06c249f5a6" translate="yes" xml:space="preserve">
          <source>A module is a container for zero or more &lt;a href=&quot;../items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">모듈은 0 개 이상의 &lt;a href=&quot;../items&quot;&gt;항목을&lt;/a&gt; 위한 컨테이너입니다 .</target>
        </trans-unit>
        <trans-unit id="c04981413bae044ff3db488edfd9ac3f31ccdfa7" translate="yes" xml:space="preserve">
          <source>A module without a body is loaded from an external file. When the module does not have a &lt;code&gt;path&lt;/code&gt; attribute, the path to the file mirrors the logical &lt;a href=&quot;../paths&quot;&gt;module path&lt;/a&gt;. Ancestor module path components are directories, and the module's contents are in a file with the name of the module plus the &lt;code&gt;.rs&lt;/code&gt; extension. For example, the following module structure can have this corresponding filesystem structure:</source>
          <target state="translated">본문이없는 모듈은 외부 파일에서로드됩니다. 모듈에 &lt;code&gt;path&lt;/code&gt; 속성 이없는 경우 파일 &lt;a href=&quot;../paths&quot;&gt;경로&lt;/a&gt; 는 논리 모듈 경로를 미러링합니다 . 조상 모듈 경로 구성 요소는 디렉토리이며 모듈의 내용은 모듈 이름과 &lt;code&gt;.rs&lt;/code&gt; 확장자를 가진 파일에 있습니다. 예를 들어, 다음 모듈 구조는 해당 파일 시스템 구조를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29558e1ce9256ba552f6d5cea0ac0d8f0b314326" translate="yes" xml:space="preserve">
          <source>A more complex example:</source>
          <target state="translated">더 복잡한 예 :</target>
        </trans-unit>
        <trans-unit id="d3b971a729c5c72b8be0c4aea17fd6538988f22d" translate="yes" xml:space="preserve">
          <source>A more complex pattern, using a closure:</source>
          <target state="translated">클로저를 사용하는 더 복잡한 패턴 :</target>
        </trans-unit>
        <trans-unit id="3dd589b621cc1adc060715bf9a9ed158d11abe3d" translate="yes" xml:space="preserve">
          <source>A more experienced Rustacean would write the signature shown in Listing 4-9 instead because it allows us to use the same function on both &lt;code&gt;&amp;amp;String&lt;/code&gt; values and &lt;code&gt;&amp;amp;str&lt;/code&gt; values.</source>
          <target state="translated">보다 숙련 된 Rustacean은 대신 &lt;code&gt;&amp;amp;String&lt;/code&gt; 값과 &lt;code&gt;&amp;amp;str&lt;/code&gt; 값 모두에 동일한 함수를 사용할 수 있기 때문에 Listing 4-9에 표시된 서명을 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="e13722d1be852ba526aeffb3cbbf03d8cad62a98" translate="yes" xml:space="preserve">
          <source>A more realistic usage of &lt;code&gt;!&lt;/code&gt; is in this code:</source>
          <target state="translated">보다 현실적인 사용법 &lt;code&gt;!&lt;/code&gt; 이 코드에 있습니다 :</target>
        </trans-unit>
        <trans-unit id="47b3111cf8992e03f361ef35402077d40b862b00" translate="yes" xml:space="preserve">
          <source>A more user-friendly and stable version of this operation is &lt;a href=&quot;../process/fn.abort&quot;&gt;&lt;code&gt;std::process::abort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 작업의보다 사용자 친화적이고 안정적인 버전은 &lt;a href=&quot;../process/fn.abort&quot;&gt; &lt;code&gt;std::process::abort&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e80c7507fc9ff231be351f8cae94b1cf2dae1652" translate="yes" xml:space="preserve">
          <source>A multi-line (doc-)comment is unterminated.</source>
          <target state="translated">여러 줄 (doc-) 주석은 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a85c20eab8c8f59bbb7b3375434e1c4c2a5fba1b" translate="yes" xml:space="preserve">
          <source>A mutable binding, reference, or pointer.</source>
          <target state="translated">변경 가능한 바인딩, 참조 또는 포인터</target>
        </trans-unit>
        <trans-unit id="8cd7d09d26092ca44a3f65ffe3c3325410d6931b" translate="yes" xml:space="preserve">
          <source>A mutable iterator over a sub-range of entries in a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 의 하위 범위 항목에 대해 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="0adc791ed0f0c19141af510a4b25898187d82ab6" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the elements of a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; 의 요소에 대한 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="ad89e0aaae2a988478ed905cd86eb0dc9435d0ff" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; 요소에 대한 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="79c92db5fb2c00374466341575412a72b346b96d" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the entries of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 의 항목에 대한 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="82c043e3bfeb960195491db7d3d334e90cb7714f" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 의 항목에 대한 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="d985ac327f38804e748201a497e2781eda7b7dde" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the values of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 값에 대한 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="3180573575f9ee53aeac5bbb0709534becff511d" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the values of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 값에 대한 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="8b90716d837b7248d5e9906c50d0a99bd6595870" translate="yes" xml:space="preserve">
          <source>A mutable memory location with dynamically checked borrow rules</source>
          <target state="translated">동적으로 확인 된 대여 규칙이있는 변경 가능한 메모리 위치</target>
        </trans-unit>
        <trans-unit id="c91e5fa32d436ead641cd9a3940ea6b760cc8d42" translate="yes" xml:space="preserve">
          <source>A mutable memory location.</source>
          <target state="translated">변경 가능한 메모리 위치.</target>
        </trans-unit>
        <trans-unit id="0b14b941c806b921d8ab056b2552003af1435118" translate="yes" xml:space="preserve">
          <source>A mutable reference can be created with &lt;code&gt;&amp;amp;mut&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;mut&lt;/code&gt; 하여 변경 가능한 참조를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa831fb6e4681d63ec9057ce3580c443fec9edb2" translate="yes" xml:space="preserve">
          <source>A mutable reference was used in a constant.</source>
          <target state="translated">상수에 가변 참조가 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="7ad0f3cf407381fd22bba2cf586e95f6a6a15615" translate="yes" xml:space="preserve">
          <source>A mutable variable is used but it is already captured by a closure.</source>
          <target state="translated">가변 변수가 사용되지만 이미 클로저에 의해 캡처되었습니다.</target>
        </trans-unit>
        <trans-unit id="1ceef8798472360db16ce7d238d9ede4272142f3" translate="yes" xml:space="preserve">
          <source>A mutable variable, reference, or pointer.</source>
          <target state="translated">가변 변수, 참조 또는 포인터.</target>
        </trans-unit>
        <trans-unit id="0f8c1096d067dc232cad356da19d2cbebed307a4" translate="yes" xml:space="preserve">
          <source>A mutual exclusion primitive useful for protecting shared data</source>
          <target state="translated">공유 데이터 보호에 유용한 상호 배제 기본 요소</target>
        </trans-unit>
        <trans-unit id="342f794408fe251ce7add66c87de4ca58808181b" translate="yes" xml:space="preserve">
          <source>A named address:</source>
          <target state="translated">지명 된 주소 :</target>
        </trans-unit>
        <trans-unit id="01a291706f0b443b495b0b8c907121279cbace5d" translate="yes" xml:space="preserve">
          <source>A negative impl was made default impl.</source>
          <target state="translated">네거티브 impl이 기본 impl로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="da1879858ed2ef626482e4f36f37eea0d652d696" translate="yes" xml:space="preserve">
          <source>A negative implementation is one that excludes a type from implementing a particular trait. Not being able to use a trait is always a safe operation, so negative implementations are always safe and never need to be marked as unsafe.</source>
          <target state="translated">부정적인 구현은 유형이 특정 특성을 구현하지 못하게하는 것입니다. 특성을 사용할 수없는 것은 항상 안전한 작업이므로 부정적인 구현은 항상 안전하며 안전하지 않은 것으로 표시 될 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="64f76de0f189c143b75250fce4afe6feb8fa06dc" translate="yes" xml:space="preserve">
          <source>A negative implementation was marked as unsafe.</source>
          <target state="translated">부정적인 구현은 안전하지 않은 것으로 표시되었습니다.</target>
        </trans-unit>
        <trans-unit id="4ca3ab38594dcb0b01232bdbb9c6f42b411e7856" translate="yes" xml:space="preserve">
          <source>A new pipe should be arranged to connect the parent and child processes.</source>
          <target state="translated">부모와 자식 프로세스를 연결하기 위해 새로운 파이프를 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="9ef1ea249a1150bef2505217b3c43c59ac961084" translate="yes" xml:space="preserve">
          <source>A new thread can be configured before it is spawned via the &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; type, which currently allows you to set the name and stack size for the child thread:</source>
          <target state="translated">&lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt; 유형을 통해 스폰하기 전에 새 스레드를 구성 할 수 있으며 현재 하위 스레드의 이름과 스택 크기를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e4ae553ae5846b13d461bd059795986a05e550e" translate="yes" xml:space="preserve">
          <source>A new thread can be spawned using the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 새로운 스레드를 생성 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="012e80e619e9a75c91e5b48d3d4ff0741fba078e" translate="yes" xml:space="preserve">
          <source>A node will be able to refer to its parent node but doesn&amp;rsquo;t own its parent. In Listing 15-28, we update &lt;code&gt;main&lt;/code&gt; to use this new definition so the &lt;code&gt;leaf&lt;/code&gt; node will have a way to refer to its parent, &lt;code&gt;branch&lt;/code&gt;:</source>
          <target state="translated">노드는 부모 노드를 참조 할 수 있지만 부모를 소유하지는 않습니다. Listing 15-28 에서이 새로운 정의를 사용하도록 &lt;code&gt;main&lt;/code&gt; 을 업데이트 하여 &lt;code&gt;leaf&lt;/code&gt; 노드가 부모 인 &lt;code&gt;branch&lt;/code&gt; 를 참조하는 방법을 갖도록한다 .</target>
        </trans-unit>
        <trans-unit id="0d77bcf0653e102d2dc04011199024bd95fbb9db" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;'static&lt;/code&gt; lifetime was used in a const generic. This is currently not allowed.</source>
          <target state="translated">비 &lt;code&gt;'static&lt;/code&gt; 수명이 const 제네릭에서 사용되었습니다. 현재 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c1956450560b920c7d29f562d8c785a2a837c6c" translate="yes" xml:space="preserve">
          <source>A non-constant value was used in a constant expression.</source>
          <target state="translated">상수 표현식에 상수가 아닌 값이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="1eee5bad5b1b537626b09062a59e028d86d55ec2" translate="yes" xml:space="preserve">
          <source>A non-default implementation was already made on this type so it cannot be specialized further.</source>
          <target state="translated">기본이 아닌 구현이 이미이 유형에 대해 작성되었으므로 더 이상 전문화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f749bb15fde0e4ed5d6ca2223f09a3999408a077" translate="yes" xml:space="preserve">
          <source>A non-default implementation was already made on this type so it cannot be specialized further. Erroneous code example:</source>
          <target state="translated">기본이 아닌 구현이이 유형에서 이미 만들어 졌으므로 더 이상 전문화 할 수 없습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="945520bcba1761f9fc7afafe8dcc369bff6ec8f2" translate="yes" xml:space="preserve">
          <source>A non-final component in path is not a directory.</source>
          <target state="translated">경로의 최종 구성 요소가 아닌 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="c1d61674888a79b8d093da31552849442beb0211" translate="yes" xml:space="preserve">
          <source>A non-ident or non-wildcard pattern has been used as a parameter of a function pointer type.</source>
          <target state="translated">동일하지 않거나 와일드 카드가 아닌 패턴이 함수 포인터 유형의 매개 변수로 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="3c2d2a8d307a0d585bf4d4468aa00fb158ce3e7d" translate="yes" xml:space="preserve">
          <source>A non-mutable value was assigned a value.</source>
          <target state="translated">변경할 수없는 값에 값이 할당되었습니다.</target>
        </trans-unit>
        <trans-unit id="6d5a3ee2105e8888d79910fc840ffa44f6ec8258" translate="yes" xml:space="preserve">
          <source>A non-raw &lt;em&gt;byte string literal&lt;/em&gt; is a sequence of ASCII characters and &lt;em&gt;escapes&lt;/em&gt;, preceded by the characters &lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) and &lt;code&gt;U+0022&lt;/code&gt; (double-quote), and followed by the character &lt;code&gt;U+0022&lt;/code&gt;. If the character &lt;code&gt;U+0022&lt;/code&gt; is present within the literal, it must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) character. Alternatively, a byte string literal can be a &lt;em&gt;raw byte string literal&lt;/em&gt;, defined below. The type of a byte string literal of length &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;&amp;amp;'static [u8; n]&lt;/code&gt;.</source>
          <target state="translated">비원시 &lt;em&gt;바이트 문자열 리터럴&lt;/em&gt; 은 ASCII 문자 및 &lt;em&gt;이스케이프&lt;/em&gt; 시퀀스이며 앞에 &lt;code&gt;U+0062&lt;/code&gt; ( &lt;code&gt;b&lt;/code&gt; ) 및 &lt;code&gt;U+0022&lt;/code&gt; (큰 따옴표) 문자가오고 그 뒤에 &lt;code&gt;U+0022&lt;/code&gt; 문자가옵니다 . 문자 &lt;code&gt;U+0022&lt;/code&gt; 가 리터럴 내에있는 경우 선행 &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) 문자 로 &lt;em&gt;이스케이프&lt;/em&gt; 해야합니다 . 또는 바이트 문자열 리터럴은 아래에 정의 된 &lt;em&gt;원시 바이트 문자열 리터럴&lt;/em&gt; 일 수 있습니다. 길이가 &lt;code&gt;n&lt;/code&gt; 인 바이트 문자열 리터럴의 유형 은 &lt;code&gt;&amp;amp;'static [u8; n]&lt;/code&gt; n] .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5c51fee9eaaa31ddc4415e9556f81e14c7ecfe88" translate="yes" xml:space="preserve">
          <source>A non-root module attempts to import macros from another crate.</source>
          <target state="translated">비 루트 모듈은 다른 상자에서 매크로를 가져 오려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="0f7f88934a0864a48a1aa3e075daab332c8783a0" translate="yes" xml:space="preserve">
          <source>A non-root module tried to import macros from another crate.</source>
          <target state="translated">루트가 아닌 모듈이 다른 상자에서 매크로를 가져 오려고했습니다.</target>
        </trans-unit>
        <trans-unit id="84ccf07b47b66963a7e3e32486b9dba6e199bf07" translate="yes" xml:space="preserve">
          <source>A non-structural-match type was used as the type of a const generic parameter.</source>
          <target state="translated">비 구조적 일치 유형이 const 일반 매개 변수의 유형으로 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="2fa1a2ea6af29cff8cb26708218d5730128ed29d" translate="yes" xml:space="preserve">
          <source>A nonexistent interface was requested or the requested address was not local.</source>
          <target state="translated">존재하지 않는 인터페이스가 요청되었거나 요청 된 주소가 로컬이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="96ce721c887ff14a23c8684eb9a885bd0450c6a3" translate="yes" xml:space="preserve">
          <source>A normal component, e.g., &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;a/b&lt;/code&gt;.</source>
          <target state="translated">정상 성분, 예 및 &lt;code&gt;b&lt;/code&gt; 에서 &lt;code&gt;a/b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5782d98ce3a8ef05d6f0d54e23bbea53e593ec4e" translate="yes" xml:space="preserve">
          <source>A note regarding zero-sized types and zero-sized layouts: many methods in the &lt;code&gt;Alloc&lt;/code&gt; trait state that allocation requests must be non-zero size, or else undefined behavior can result.</source>
          <target state="translated">크기가 0이 아닌 유형과 크기가 0 인 레이아웃에 대한 참고 사항 : &lt;code&gt;Alloc&lt;/code&gt; 특성의 많은 메서드는 할당 요청의 크기가 0이 아니어야합니다. 그렇지 않으면 정의되지 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d70ff5d8ac6ec719cfc0758b679c32b46a7a0fdd" translate="yes" xml:space="preserve">
          <source>A null &lt;code&gt;fn&lt;/code&gt; pointer.</source>
          <target state="translated">널 &lt;code&gt;fn&lt;/code&gt; 포인터.</target>
        </trans-unit>
        <trans-unit id="dbd524388dc48721a46df11a0e678684cddc1ff5" translate="yes" xml:space="preserve">
          <source>A number in a non-decimal base has no digits.</source>
          <target state="translated">10 진수가 아닌 기수의 숫자에는 숫자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="79055d577bd4470f262c27ac3d7f2c814ba28782" translate="yes" xml:space="preserve">
          <source>A panic upon overflow:</source>
          <target state="translated">오버플로시 패닉 :</target>
        </trans-unit>
        <trans-unit id="7e451dc65737a3d0078f0a0cdca0352afd247852" translate="yes" xml:space="preserve">
          <source>A parameter type is missing a lifetime constraint or has a lifetime that does not live long enough.</source>
          <target state="translated">매개 변수 유형에 수명 제약이 없거나 수명이 충분히 오래 지속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c17681e220340a047c028939b5c9a6007c707423" translate="yes" xml:space="preserve">
          <source>A parameter type is missing an explicit lifetime bound and may not live long enough.</source>
          <target state="translated">매개 변수 유형에 명시 적 수명 제한이 없으며 충분히 오래 지속되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd0627aebae59febc951bf56bcbbb5c77e2a3cca" translate="yes" xml:space="preserve">
          <source>A parameter was incorrect.</source>
          <target state="translated">매개 변수가 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="8faec6289671e90add0a6793ff7c83244ee9ad52" translate="yes" xml:space="preserve">
          <source>A parent of the given path doesn't exist. (To create a directory and all its missing parents at the same time, use the &lt;a href=&quot;fn.create_dir_all&quot;&gt;&lt;code&gt;create_dir_all&lt;/code&gt;&lt;/a&gt; function.)</source>
          <target state="translated">주어진 경로의 부모가 존재하지 않습니다. (디렉토리와 누락 된 모든 부모를 동시에 작성하려면 &lt;a href=&quot;fn.create_dir_all&quot;&gt; &lt;code&gt;create_dir_all&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .)</target>
        </trans-unit>
        <trans-unit id="3c44a59945c31a15632dad83502ad5c534fa6460" translate="yes" xml:space="preserve">
          <source>A particular instance &lt;code&gt;RandomState&lt;/code&gt; will create the same instances of &lt;a href=&quot;../../hash/trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;, but the hashers created by two different &lt;code&gt;RandomState&lt;/code&gt; instances are unlikely to produce the same result for the same values.</source>
          <target state="translated">특정 인스턴스 &lt;code&gt;RandomState&lt;/code&gt; 는 동일한 인스턴스 생성한다 &lt;a href=&quot;../../hash/trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; 하지만, 두 가지에 의해 생성 hashers &lt;code&gt;RandomState&lt;/code&gt; 의 인스턴스는 동일한 값에 대해 동일한 결과를 생성 할 가능성이있다.</target>
        </trans-unit>
        <trans-unit id="83b0cbf0a90bcfe2367c6fdcc070513f6d4d75f8" translate="yes" xml:space="preserve">
          <source>A particular pattern &lt;code&gt;_&lt;/code&gt; will match anything, but it never binds to a variable, so it&amp;rsquo;s often used in the last match arm. The &lt;code&gt;_&lt;/code&gt; pattern can be useful when you want to ignore any value not specified, for example. We&amp;rsquo;ll cover the &lt;code&gt;_&lt;/code&gt; pattern in more detail in the &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;Ignoring Values in a Pattern&amp;rdquo;&lt;/a&gt; section later in this chapter.</source>
          <target state="translated">특정 패턴 &lt;code&gt;_&lt;/code&gt; 는 어떤 것과도 일치하지만 변수에 바인딩되지 않으므로 마지막 매치 암에서 종종 사용됩니다. &lt;code&gt;_&lt;/code&gt; 당신은 예를 들어, 지정되지 않은 값을 무시하고자 할 때 패턴이 유용 할 수 있습니다. 우리는 다룰 &lt;code&gt;_&lt;/code&gt; 에서 더 자세히 패턴 &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&quot;패턴으로 무시 값&quot;&lt;/a&gt; 섹션이 장 뒷부분을.</target>
        </trans-unit>
        <trans-unit id="1f72278829757d575931ca8a320129aa5f0521b4" translate="yes" xml:space="preserve">
          <source>A path can take two forms:</source>
          <target state="translated">경로는 두 가지 형태를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7908f4aa852c1de2737ef7d2b9796ba4b3783229" translate="yes" xml:space="preserve">
          <source>A pattern a &lt;code&gt;..=&lt;/code&gt; b must always have a &amp;le; b. It is an error to have a range pattern &lt;code&gt;10..=0&lt;/code&gt;, for example.</source>
          <target state="translated">패턴 a &lt;code&gt;..=&lt;/code&gt; b에는 항상 &amp;le; b가 있어야합니다. 예를 들어 범위 패턴 &lt;code&gt;10..=0&lt;/code&gt; 을 갖는 것은 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="891da3d988f6fc5238b5b4fb583d072b5a0287dc" translate="yes" xml:space="preserve">
          <source>A pattern attempted to extract an incorrect number of fields from a variant.</source>
          <target state="translated">패턴이 변형에서 잘못된 수의 필드를 추출하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="6d6b7416ed8a3ba7b4dcdc0423f76b297ea15288" translate="yes" xml:space="preserve">
          <source>A pattern binding is using the same name as one of the variants of a type.</source>
          <target state="translated">패턴 바인딩은 유형의 변형 중 하나와 동일한 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="53b95bece3c7641fd29f13b871ae1a3d402281d9" translate="yes" xml:space="preserve">
          <source>A pattern for a struct fails to specify a sub-pattern for every one of the struct's fields.</source>
          <target state="translated">구조체의 패턴은 구조체의 모든 필드에 대한 하위 패턴을 지정하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="2c3ec235405c966e5db61078265ddd06c38fdf87" translate="yes" xml:space="preserve">
          <source>A pattern guard may refer to the variables bound within the pattern they follow. Before evaluating the guard, a shared reference is taken to the part of the scrutinee the variable matches on. While evaluating the guard, this shared reference is then used when accessing the variable. Only when the guard evaluates to true is the value moved, or copied, from the scrutinee into the variable. This allows shared borrows to be used inside guards without moving out of the scrutinee in case guard fails to match. Moreover, by holding a shared reference while evaluating the guard, mutation inside guards is also prevented.</source>
          <target state="translated">패턴 가드는 그들이 따르는 패턴 내에 바인딩 된 변수를 참조 할 수 있습니다. 가드를 평가하기 전에 변수가 일치하는 스크 루틴 부분에 대한 공유 참조를 가져옵니다. 가드를 평가하는 동안이 공유 참조는 변수에 액세스 할 때 사용됩니다. 가드가 참으로 평가 될 때만 값이 스크 러틴에서 변수로 이동 또는 복사됩니다. 이를 통해 가드가 일치하지 않을 경우 스크 루틴에서 벗어나지 않고도 가드 내부에서 공유 빌리기를 사용할 수 있습니다. 또한 가드를 평가하는 동안 공유 참조를 유지함으로써 가드 내부의 돌연변이도 방지됩니다.</target>
        </trans-unit>
        <trans-unit id="bf85ec7c19381f75fc673dab8bb0b15ce1a79c9a" translate="yes" xml:space="preserve">
          <source>A pattern is said to be &lt;em&gt;refutable&lt;/em&gt; when it has the possibility of not being matched by the value it is being matched against. &lt;em&gt;Irrefutable&lt;/em&gt; patterns, on the other hand, always match the value they are being matched against. Examples:</source>
          <target state="translated">패턴은 것으로 알려져 &lt;em&gt;논파&lt;/em&gt; 그것이 대해 매칭되는 값에 일치하지 않을 가능성이있는 경우. 반면 &lt;em&gt;반박 할 수없는&lt;/em&gt; 패턴은 항상 일치하는 값과 일치합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="50718096ba0e9d977821568bde4dc051a6527468" translate="yes" xml:space="preserve">
          <source>A pattern used to match against an enum variant must provide a sub-pattern for each field of the enum variant.</source>
          <target state="translated">열거 형 변형과 일치하는 데 사용되는 패턴은 열거 형 변형의 각 필드에 대한 하위 패턴을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf12d88e1623c0c22171573d10a1573941789f14" translate="yes" xml:space="preserve">
          <source>A pattern used to match against an enum variant must provide a sub-pattern for each field of the enum variant. This error indicates that a pattern attempted to extract an incorrect number of fields from a variant.</source>
          <target state="translated">열거 형 변형과 일치시키는 데 사용되는 패턴은 열거 형 변형의 각 필드에 대한 하위 패턴을 제공해야합니다. 이 오류는 패턴이 변형에서 잘못된 수의 필드를 추출하려고 시도했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="27a0056206e19a4b052630f19a00fbd4710c685a" translate="yes" xml:space="preserve">
          <source>A pattern was declared as an argument in a foreign function declaration.</source>
          <target state="translated">패턴이 외부 함수 선언에서 인수로 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="d00f0437e6924080d1afab40ce4328811dd1cc4e" translate="yes" xml:space="preserve">
          <source>A pinned pointer.</source>
          <target state="translated">고정 된 포인터.</target>
        </trans-unit>
        <trans-unit id="a57ac3109ff2b056cae1f3bd5a56c84d66c44184" translate="yes" xml:space="preserve">
          <source>A place that is valid for the duration of a program.</source>
          <target state="translated">프로그램 기간 동안 유효한 장소.</target>
        </trans-unit>
        <trans-unit id="7d0a1c9d0822781050522c413844b46b3f9e19ec" translate="yes" xml:space="preserve">
          <source>A plugin/crate was declared but cannot be found.</source>
          <target state="translated">플러그인 / 크레이트가 선언되었지만 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="de1781b485888ee330b207b934e4f4c6b09830cf" translate="yes" xml:space="preserve">
          <source>A plugin/crate was declared but cannot be found. Erroneous code example:</source>
          <target state="translated">플러그인 / 상자가 선언되었지만 찾을 수 없습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="2db11183c5e69392e41fbe166caeebf1df741e85" translate="yes" xml:space="preserve">
          <source>A pointer to a trait type cannot be implicitly dereferenced by a pattern. Every trait defines a type, but because the size of trait implementers isn't fixed, this type has no compile-time size. Therefore, all accesses to trait types must be through pointers. If you encounter this error you should try to avoid dereferencing the pointer.</source>
          <target state="translated">특성 유형에 대한 포인터는 패턴에 의해 암시 적으로 역 참조 될 수 없습니다. 모든 특성은 유형을 정의하지만 특성 구현 자의 크기가 고정되어 있지 않기 때문에이 유형에는 컴파일 시간 크기가 없습니다. 따라서 트레이 트 유형에 대한 모든 액세스는 포인터를 통해 이루어져야합니다. 이 오류가 발생하면 포인터를 역 참조하지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="34017de9c0f653b0f37f4a6965f6e339b6e3eb8f" translate="yes" xml:space="preserve">
          <source>A pointer type for heap allocation.</source>
          <target state="translated">힙 할당을위한 포인터 유형.</target>
        </trans-unit>
        <trans-unit id="068b4756f4660015d453841abd0c47d397debbf3" translate="yes" xml:space="preserve">
          <source>A poisoned &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">중독 된 한 &lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a8f3faefa5c5d4137483f566406d69333a9e2fb7" translate="yes" xml:space="preserve">
          <source>A poisoned &lt;code&gt;Once&lt;/code&gt;:</source>
          <target state="translated">A는 중독 &lt;code&gt;Once&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="929b0eef10b3144f1332f3b71eafbab8eba71fe6" translate="yes" xml:space="preserve">
          <source>A poisoned mutex, however, does not prevent all access to the underlying data. The &lt;a href=&quot;struct.poisonerror&quot;&gt;&lt;code&gt;PoisonError&lt;/code&gt;&lt;/a&gt; type has an &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; method which will return the guard that would have otherwise been returned on a successful lock. This allows access to the data, despite the lock being poisoned.</source>
          <target state="translated">그러나 중독 된 뮤텍스가 기본 데이터에 대한 모든 액세스를 막지는 못합니다. &lt;a href=&quot;struct.poisonerror&quot;&gt; &lt;code&gt;PoisonError&lt;/code&gt; 의&lt;/a&gt; 유형은이 &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt; &lt;code&gt;into_inner&lt;/code&gt; 의&lt;/a&gt; 그렇지 않으면 성공적인 잠금에 반환 된 것이다 가드를 반환하는 방법을. 이렇게하면 잠금 장치가 감염 되더라도 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73fd6c45e77753ba09fc6ae1f1a84a2bc4c2f7fb" translate="yes" xml:space="preserve">
          <source>A possible error value when converting a &lt;code&gt;String&lt;/code&gt; from a UTF-16 byte slice.</source>
          <target state="translated">UTF-16 바이트 슬라이스에서 &lt;code&gt;String&lt;/code&gt; 을 변환 할 때 가능한 오류 값 입니다.</target>
        </trans-unit>
        <trans-unit id="ffac94ea92c56dd95950816abb00c940a0255f3a" translate="yes" xml:space="preserve">
          <source>A possible error value when converting a &lt;code&gt;String&lt;/code&gt; from a UTF-8 byte vector.</source>
          <target state="translated">UTF-8 바이트 벡터에서 &lt;code&gt;String&lt;/code&gt; 을 변환 할 때 가능한 오류 값 입니다.</target>
        </trans-unit>
        <trans-unit id="de325cfd40d79951f0c1e349c34b7cd70df1fbf9" translate="yes" xml:space="preserve">
          <source>A prelude for conveniently writing platform-specific code.</source>
          <target state="translated">플랫폼 별 코드를 편리하게 작성하기위한 서문입니다.</target>
        </trans-unit>
        <trans-unit id="c5e33e24aca6a074f404567a2953c71b3f5c603f" translate="yes" xml:space="preserve">
          <source>A priority queue implemented with a binary heap.</source>
          <target state="translated">이진 힙으로 구현 된 우선 순위 큐.</target>
        </trans-unit>
        <trans-unit id="839f5fda33c60277611f831c62b151f9e603547e" translate="yes" xml:space="preserve">
          <source>A private item was used outside its scope.</source>
          <target state="translated">개인 항목이 범위 밖에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="519be8a210afc21029c91c0c6f7917299f8dedbe" translate="yes" xml:space="preserve">
          <source>A private item was used outside of its scope.</source>
          <target state="translated">개인 항목이 범위 밖에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="b050bad5b423d40a7cbc2510e0a714043fcaa01a" translate="yes" xml:space="preserve">
          <source>A private trait was used on a public type parameter bound.</source>
          <target state="translated">공용 유형 매개 변수 바인딩에 개인 특성이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="94c921f0636467349880453e7613dadeb16d5d80" translate="yes" xml:space="preserve">
          <source>A private trait was used on a public type parameter bound. Erroneous code examples:</source>
          <target state="translated">개인 특성은 공용 유형 매개 변수 바운드에서 사용되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="9a0df3af8cfe7414b96a23dc7a41a25700bb086e" translate="yes" xml:space="preserve">
          <source>A private type was used in a public type signature.</source>
          <target state="translated">공용 유형 서명에 개인 유형이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="5e925db174af759a11ddedae27575f0f853ed111" translate="yes" xml:space="preserve">
          <source>A private type was used in a public type signature. Erroneous code example:</source>
          <target state="translated">개인 유형은 공용 유형 서명에 사용되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="c311fafb046b4454c158177c3e7c9d9343861f7d" translate="yes" xml:space="preserve">
          <source>A process builder, providing fine-grained control over how a new process should be spawned.</source>
          <target state="translated">새로운 프로세스 생성 방법을 세밀하게 제어 할 수있는 프로세스 빌더.</target>
        </trans-unit>
        <trans-unit id="b012d3c393a9f2ccaba1d026e4a05fd4cbe591b1" translate="yes" xml:space="preserve">
          <source>A quick refresher on memory ordering:</source>
          <target state="translated">메모리 주문에 대한 빠른 정보 :</target>
        </trans-unit>
        <trans-unit id="63343f59c96578fe01a096392dc2051b122408d3" translate="yes" xml:space="preserve">
          <source>A random number that will generate some variety in the workout plans</source>
          <target state="translated">다양한 운동 계획을 생성하는 난수</target>
        </trans-unit>
        <trans-unit id="72b92a764b3becb3cc5dd577eea9f2e87d42d804" translate="yes" xml:space="preserve">
          <source>A range bounded inclusively below and above (&lt;code&gt;start..=end&lt;/code&gt;).</source>
          <target state="translated">아래 및 위에 포함 된 범위 ( &lt;code&gt;start..=end&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="79fc3105ea5313c5378041705247103257830779" translate="yes" xml:space="preserve">
          <source>A range only bounded exclusively above (&lt;code&gt;..end&lt;/code&gt;).</source>
          <target state="translated">( &lt;code&gt;..end&lt;/code&gt; ) 위에 만 한정된 범위 입니다.</target>
        </trans-unit>
        <trans-unit id="e19446803edcf89ddaf7319d7c6427759416990d" translate="yes" xml:space="preserve">
          <source>A range only bounded inclusively above (&lt;code&gt;..=end&lt;/code&gt;).</source>
          <target state="translated">범위는 ( &lt;code&gt;..=end&lt;/code&gt; ) 에만 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="74324727cee50500895944c74cdd394c1b31fc07" translate="yes" xml:space="preserve">
          <source>A range only bounded inclusively below (&lt;code&gt;start..&lt;/code&gt;).</source>
          <target state="translated">범위는 ( &lt;code&gt;start..&lt;/code&gt; ) 이하로만 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f00d04637794ce3f904922bdb42fa3ce7f3d5fe" translate="yes" xml:space="preserve">
          <source>A raw identifier is like a normal identifier, but prefixed by &lt;code&gt;r#&lt;/code&gt;. (Note that the &lt;code&gt;r#&lt;/code&gt; prefix is not included as part of the actual identifier.) Unlike a normal identifier, a raw identifier may be any strict or reserved keyword except the ones listed above for &lt;code&gt;RAW_IDENTIFIER&lt;/code&gt;.</source>
          <target state="translated">원시 식별자는 일반 식별자와 비슷하지만 접두사가 &lt;code&gt;r#&lt;/code&gt; 입니다. 합니다 (참고 &lt;code&gt;r#&lt;/code&gt; 프리픽스는 실제 식별자의 일부분으로서 포함되지 않는다.) 일반 식별자는 달리, 생 식별자에 대해 상기 열거 된 것들을 제외한 모든 엄격한 또는 예약어 수있다 &lt;code&gt;RAW_IDENTIFIER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffc636325c67605fadec2b68ebb55669b2cd9c34" translate="yes" xml:space="preserve">
          <source>A raw pointer type which can be safely shared between threads.</source>
          <target state="translated">스레드간에 안전하게 공유 할 수있는 원시 포인터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="f1f955686d561bc8208f2ce3b12ca99c3765110a" translate="yes" xml:space="preserve">
          <source>A raw string isn't correctly terminated because the trailing &lt;code&gt;#&lt;/code&gt; count doesn't match its leading &lt;code&gt;#&lt;/code&gt; count.</source>
          <target state="translated">후행 &lt;code&gt;#&lt;/code&gt; 개수가 선행 &lt;code&gt;#&lt;/code&gt; 개수 와 일치하지 않기 때문에 원시 문자열이 올바르게 종료 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="20341b33140e6b08a4b41c1574d7c2c86bdc7608" translate="yes" xml:space="preserve">
          <source>A reader which is always at EOF.</source>
          <target state="translated">항상 EOF에있는 독자.</target>
        </trans-unit>
        <trans-unit id="5c0eac8aa6da425e06c685e18fd91d499e3c16f1" translate="yes" xml:space="preserve">
          <source>A reader which yields one byte over and over and over and over and over and...</source>
          <target state="translated">1 바이트 이상 반복해서 반복해서 읽는 독자</target>
        </trans-unit>
        <trans-unit id="0187c58d40ebb5aaa0b543a6b1bda48ead05f016" translate="yes" xml:space="preserve">
          <source>A reader-writer lock</source>
          <target state="translated">리더 라이터 락</target>
        </trans-unit>
        <trans-unit id="2d89d8dfb8b1c58f5d841e5165fcf975a6c55e6a" translate="yes" xml:space="preserve">
          <source>A recursive type has infinite size because it doesn't have an indirection.</source>
          <target state="translated">재귀 유형은 간접 지정이 없기 때문에 크기가 무한합니다.</target>
        </trans-unit>
        <trans-unit id="414e2acfb8956698eab95c0efb754ad454841ffa" translate="yes" xml:space="preserve">
          <source>A reference has a longer lifetime than the data it references.</source>
          <target state="translated">참조는 참조하는 데이터보다 수명이 길다.</target>
        </trans-unit>
        <trans-unit id="8299c0d135b8f5441cc8858d8675b0fc5f91fcc2" translate="yes" xml:space="preserve">
          <source>A reference or &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that is dangling, unaligned, or points to an invalid value.</source>
          <target state="translated">매달려 있거나 정렬되지 않았거나 잘못된 값을 가리키는 참조 또는 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9108b5b496b508ef46e829906b2e7b5524691e8f" translate="yes" xml:space="preserve">
          <source>A reference represents a borrow of some owned value. You can get one by using the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut&lt;/code&gt; operators on a value, or by using a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref mut&lt;/code&gt; pattern.</source>
          <target state="translated">참조는 일부 소유 가치의 대출을 나타냅니다. 값에 &lt;code&gt;&amp;amp;&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 연산자를 사용하거나 &lt;code&gt;ref&lt;/code&gt; 또는 &lt;code&gt;ref mut&lt;/code&gt; 패턴 을 사용하여 값을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="def229fac786a814e540383a36be7448c81c2810" translate="yes" xml:space="preserve">
          <source>A reference to a local variable was returned.</source>
          <target state="translated">지역 변수에 대한 참조가 반환되었습니다.</target>
        </trans-unit>
        <trans-unit id="9b45e7cfae560003198e2ac81c9a7e5c60325d0a" translate="yes" xml:space="preserve">
          <source>A reference to an open file on the filesystem.</source>
          <target state="translated">파일 시스템에서 열린 파일에 대한 참조</target>
        </trans-unit>
        <trans-unit id="cbf7d17da7f9b8415b894a96d3c62639060d8148" translate="yes" xml:space="preserve">
          <source>A reference to the current directory, i.e., &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">즉, 현재 디렉토리에의 참조 &lt;code&gt;.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54c4ba3b0f946cb73000b704747ed0cc043ef985" translate="yes" xml:space="preserve">
          <source>A reference to the parent directory, i.e., &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="translated">상위 디렉토리에 대한 참조, 즉, &lt;code&gt;..&lt;/code&gt; . .</target>
        </trans-unit>
        <trans-unit id="b305ff2e1e8a128729de5a06db133ccf46d493cc" translate="yes" xml:space="preserve">
          <source>A reference/pointer is &quot;dangling&quot; if it is null or not all of the bytes it points to are part of the same allocation (so in particular they all have to be part of &lt;em&gt;some&lt;/em&gt; allocation). The span of bytes it points to is determined by the pointer value and the size of the pointee type (using &lt;code&gt;size_of_val&lt;/code&gt;). As a consequence, if the span is empty, &quot;dangling&quot; is the same as &quot;non-null&quot;. Note that slices and strings point to their entire range, so it is important that the length metadata is never too large. In particular, allocations and therefore slices and strings cannot be bigger than &lt;code&gt;isize::MAX&lt;/code&gt; bytes.</source>
          <target state="translated">참조 / 포인터가 null이거나 가리키는 모든 바이트가 동일한 할당의 일부가 아닌 경우 &quot;dangling&quot;입니다 (특히 모두 &lt;em&gt;일부&lt;/em&gt; 할당 의 &lt;em&gt;일부&lt;/em&gt; 여야 함 ). 가리키는 바이트 범위는 포인터 값과 pointee 유형의 크기 ( &lt;code&gt;size_of_val&lt;/code&gt; 사용 )에 의해 결정됩니다 . 결과적으로 범위가 비어있는 경우 &quot;dangling&quot;은 &quot;non-null&quot;과 동일합니다. 슬라이스와 문자열은 전체 범위를 가리 키므로 길이 메타 데이터가 너무 크지 않아야합니다. 특히 할당 및 따라서 슬라이스 및 문자열은 &lt;code&gt;isize::MAX&lt;/code&gt; 바이트 보다 클 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="771deb0451fb407b0fb913d5488c53c42558785c" translate="yes" xml:space="preserve">
          <source>A regular floating point number.</source>
          <target state="translated">정규 부동 소수점 숫자</target>
        </trans-unit>
        <trans-unit id="cd85c1b05128e75e217b61f7154c9636692d1cea" translate="yes" xml:space="preserve">
          <source>A regular reference is a type of pointer, and one way to think of a pointer is as an arrow to a value stored somewhere else. In Listing 15-6, we create a reference to an &lt;code&gt;i32&lt;/code&gt; value and then use the dereference operator to follow the reference to the data:</source>
          <target state="translated">일반 참조는 포인터의 한 유형이며 포인터를 생각하는 한 가지 방법은 다른 곳에 저장된 값에 대한 화살표입니다. Listing 15-6에서 &lt;code&gt;i32&lt;/code&gt; 값에 대한 참조를 작성한 후 역 참조 연산자를 사용하여 데이터에 대한 참조를 따른다.</target>
        </trans-unit>
        <trans-unit id="461658f899b03c712ef32df7b204d3908a10ea3a" translate="yes" xml:space="preserve">
          <source>A related concept is scope: the nested context in which code is written has a set of names that are defined as &amp;ldquo;in scope.&amp;rdquo; When reading, writing, and compiling code, programmers and compilers need to know whether a particular name at a particular spot refers to a variable, function, struct, enum, module, constant, or other item and what that item means. You can create scopes and change which names are in or out of scope. You can&amp;rsquo;t have two items with the same name in the same scope; tools are available to resolve name conflicts.</source>
          <target state="translated">관련 개념은 범위입니다. 코드가 작성되는 중첩 컨텍스트에는 &quot;범위 내&quot;로 정의 된 일련의 이름이 있습니다. 코드를 읽고, 쓰고, 컴파일 할 때 프로그래머와 컴파일러는 특정 지점의 특정 이름이 변수, 함수, 구조체, 열거 형, 모듈, 상수 또는 기타 항목을 나타내는 지 여부와 해당 항목의 의미를 알아야합니다. 범위를 만들고 범위에 있거나 범위를 벗어난 이름을 변경할 수 있습니다. 같은 범위에서 같은 이름을 가진 두 항목을 가질 수 없습니다. 이름 충돌을 해결하는 도구를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4629afc869292537f9c628724559e37eef9a2cb2" translate="yes" xml:space="preserve">
          <source>A repeat expression &lt;code&gt;[x; N]&lt;/code&gt;, which produces an array with &lt;code&gt;N&lt;/code&gt; copies of &lt;code&gt;x&lt;/code&gt;. The type of &lt;code&gt;x&lt;/code&gt; must be &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반복 표현 &lt;code&gt;[x; N]&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;N&lt;/code&gt; 복사본을 가진 배열을 생성합니다 . &lt;code&gt;x&lt;/code&gt; 의 유형은 &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="3238c87767b981c84fc407d2a6b89dd0a8979fcd" translate="yes" xml:space="preserve">
          <source>A restriction is imposed on the shebang syntax to avoid confusion with an &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;. The &lt;code&gt;#!&lt;/code&gt; characters must not be followed by a &lt;code&gt;[&lt;/code&gt; token, ignoring intervening &lt;a href=&quot;comments&quot;&gt;comments&lt;/a&gt; or &lt;a href=&quot;whitespace&quot;&gt;whitespace&lt;/a&gt;. If this restriction fails, then it is not treated as a shebang, but instead as the start of an attribute.</source>
          <target state="translated">&lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 과의 혼동을 피하기 위해 shebang 구문에 제한이 적용됩니다 . &lt;code&gt;#!&lt;/code&gt; 문자 뒤에는 &lt;code&gt;[&lt;/code&gt; 토큰, 중간 &lt;a href=&quot;comments&quot;&gt;주석&lt;/a&gt; 또는 &lt;a href=&quot;whitespace&quot;&gt;공백을&lt;/a&gt; 무시 합니다. 이 제한이 실패하면 shebang으로 처리되지 않고 대신 속성의 시작으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="6bdd3de922c246975bfd1cbfd244a2a660fcbad2" translate="yes" xml:space="preserve">
          <source>A return statement was found outside of a function body.</source>
          <target state="translated">함수 본문 외부에서 return 문이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="80cb47a4163ef3f70e5ddff5f65587e6f1ef80e1" translate="yes" xml:space="preserve">
          <source>A reverse searcher for a string pattern.</source>
          <target state="translated">문자열 패턴에 대한 역방향 검색 자.</target>
        </trans-unit>
        <trans-unit id="4d45eae920f51ae4fa809b8359142e43a5dccbee" translate="yes" xml:space="preserve">
          <source>A scrutinee is the expression that is matched on in &lt;code&gt;match&lt;/code&gt; expressions and similar pattern matching constructs. For example, in &lt;code&gt;match x { A =&amp;gt; 1, B =&amp;gt; 2 }&lt;/code&gt;, the expression &lt;code&gt;x&lt;/code&gt; is the scrutinee.</source>
          <target state="translated">스크루 티네는 &lt;code&gt;match&lt;/code&gt; 표현식 및 유사한 패턴 일치 구문 에서 일치하는 표현식입니다. 예를 들어, &lt;code&gt;match x { A =&amp;gt; 1, B =&amp;gt; 2 }&lt;/code&gt; 에서 식 &lt;code&gt;x&lt;/code&gt; 는 스크 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="090be4c47ade9f54015d614891f57e36867218e4" translate="yes" xml:space="preserve">
          <source>A searcher for a string pattern.</source>
          <target state="translated">문자열 패턴을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="805b0de6f894d8345c096cc31db6d9d15c14c18a" translate="yes" xml:space="preserve">
          <source>A seek beyond the end of a stream is allowed, but behavior is defined by the implementation.</source>
          <target state="translated">스트림 끝을 넘어서는 탐색이 허용되지만 동작은 구현에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="187cb85d876dbb3e8278047d50cee3e8447cafbc" translate="yes" xml:space="preserve">
          <source>A set based on a B-Tree.</source>
          <target state="translated">B- 트리를 기반으로 한 세트.</target>
        </trans-unit>
        <trans-unit id="89f39617bf1d1e8280f2895b2baeee66b493c8f3" translate="yes" xml:space="preserve">
          <source>A similar error is E0201. The difference is whether there is one declaration block or not. To avoid this error, you must give each &lt;code&gt;fn&lt;/code&gt; a unique name.</source>
          <target state="translated">비슷한 오류는 E0201입니다. 차이점은 하나의 선언 블록이 있는지 여부입니다. 이 오류를 피하려면 각 &lt;code&gt;fn&lt;/code&gt; 에 고유 한 이름을 지정 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6f6761295ae70019a0d2d6374dca4eaf6df07696" translate="yes" xml:space="preserve">
          <source>A similar rule exists for combining mutable and immutable references. This code results in an error:</source>
          <target state="translated">변경 가능한 참조와 변경 불가능한 참조를 결합하는 비슷한 규칙이 있습니다. 이 코드는 오류가 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="8e839688e01ba01e9dfe145feb09335f1aa963d0" translate="yes" xml:space="preserve">
          <source>A simple example:</source>
          <target state="translated">간단한 예 :</target>
        </trans-unit>
        <trans-unit id="823d579a067f8a96f5626154ea604d86f19d68ef" translate="yes" xml:space="preserve">
          <source>A simple function returning &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; might be defined and used like so:</source>
          <target state="translated">&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 반환하는 간단한 함수 는 다음과 같이 정의되고 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d53eef6dd046b01cc7902a1c3902a172dad006e2" translate="yes" xml:space="preserve">
          <source>A simple spinlock:</source>
          <target state="translated">간단한 스핀 락 :</target>
        </trans-unit>
        <trans-unit id="a2f952715a286d980e4f33b8e4525dcb3eac03bb" translate="yes" xml:space="preserve">
          <source>A simple workaround is to use a helper method instead:</source>
          <target state="translated">간단한 해결 방법은 도우미 메서드를 대신 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="054dbf6f392fa38162c0d62e6ead09a79999e53b" translate="yes" xml:space="preserve">
          <source>A simple wrapper around a type to assert that it is unwind safe.</source>
          <target state="translated">타입을 둘러싼 간단한 래퍼로 안전합니다.</target>
        </trans-unit>
        <trans-unit id="b53617da96fc2eac5eec0b6bb0e92f32c47fc76e" translate="yes" xml:space="preserve">
          <source>A single (arbitrary) thread will receive a &lt;a href=&quot;struct.barrierwaitresult&quot;&gt;&lt;code&gt;BarrierWaitResult&lt;/code&gt;&lt;/a&gt; that returns &lt;code&gt;true&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt;&lt;/a&gt; when returning from this function, and all other threads will receive a result that will return &lt;code&gt;false&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단일 (임의) 스레드는 이 함수에서 반환 할 때 &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;true&lt;/code&gt; 를 반환 하는 &lt;a href=&quot;struct.barrierwaitresult&quot;&gt; &lt;code&gt;BarrierWaitResult&lt;/code&gt; &lt;/a&gt; 를 수신하고 다른 모든 스레드는 &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;false&lt;/code&gt; 를 반환하는 결과를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="cd3fd0649d54745c9dde4e2f256bda95babba9f6" translate="yes" xml:space="preserve">
          <source>A single (arbitrary) thread will receive a &lt;a href=&quot;struct.barrierwaitresult&quot;&gt;&lt;code&gt;BarrierWaitResult&lt;/code&gt;&lt;/a&gt; that returns &lt;code&gt;true&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;is_leader&lt;/code&gt;&lt;/a&gt; when returning from this function, and all other threads will receive a result that will return &lt;code&gt;false&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;is_leader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단일 (임의의) 스레드는 이 함수 에서 &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;is_leader&lt;/code&gt; &lt;/a&gt; 때 is_leader 에서 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 &lt;a href=&quot;struct.barrierwaitresult&quot;&gt; &lt;code&gt;BarrierWaitResult&lt;/code&gt; &lt;/a&gt; 를 수신하고 다른 모든 스레드는 &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;is_leader&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;false&lt;/code&gt; 를 리턴하는 결과를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="0e774847b8b17cfc775f96b4b6ba3419133c2ae2" translate="yes" xml:space="preserve">
          <source>A single &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; may be encoded as more than one byte. This method can only succeed if the entire byte sequence was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="translated">단일 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 는 둘 이상의 바이트로 인코딩 될 수 있습니다. 이 방법은 전체 바이트 시퀀스가 ​​성공적으로 기록 된 경우에만 성공할 수 있으며 모든 데이터가 기록되거나 오류가 발생할 때까지 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7ad66dadfa2951ac2cd349b4d260c6f6b28c527" translate="yes" xml:space="preserve">
          <source>A single &lt;em&gt;decimal literal&lt;/em&gt; followed by an &lt;em&gt;exponent&lt;/em&gt;.</source>
          <target state="translated">단일 &lt;em&gt;10 진수 리터럴&lt;/em&gt; 다음에 &lt;em&gt;지수가&lt;/em&gt; 옵니다 .</target>
        </trans-unit>
        <trans-unit id="538d82224c466a3fa46957bd1dad7926fc97c926" translate="yes" xml:space="preserve">
          <source>A single component of a path.</source>
          <target state="translated">경로의 단일 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="2286204503218f0f2c8d94ba2bb110e020e0bc00" translate="yes" xml:space="preserve">
          <source>A single-threaded reference-counting pointer. 'Rc' stands for 'Reference Counted'.</source>
          <target state="translated">단일 스레드 참조 계산 포인터 'Rc'는 'Reference Counted'를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5b101d21362e496b89adfac2fbb37a58e0757a7e" translate="yes" xml:space="preserve">
          <source>A slice is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt; representing a 'view' into a sequence of elements of type &lt;code&gt;T&lt;/code&gt;. The slice type is written as &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">슬라이스는 &lt;code&gt;T&lt;/code&gt; 유형의 요소 시퀀스에 대한 '보기'를 나타내는 &lt;a href=&quot;../dynamically-sized-types&quot;&gt;동적 크기&lt;/a&gt; 의 유형 입니다. 슬라이스 유형은 &lt;code&gt;[T]&lt;/code&gt; 로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="aba616073ac3de8beab95ccfac7bd633d599946d" translate="yes" xml:space="preserve">
          <source>A slice is dynamically-sized view into a contiguous sequence, written as &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">슬라이스는 &lt;code&gt;[T]&lt;/code&gt; 로 작성된 연속적인 시퀀스로 동적 크기 뷰를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="fe635e064516decbfbc3e3d9ce043f9d25e8ca9f" translate="yes" xml:space="preserve">
          <source>A slice of a path (akin to &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">경로의 슬라이스 ( &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; 에 영향&lt;/a&gt; 을 미침 ).</target>
        </trans-unit>
        <trans-unit id="2759e6b662ba691ba47b65069c920c9b980fcd79" translate="yes" xml:space="preserve">
          <source>A slice of a path (akin to &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">경로의 슬라이스 ( &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 과 유사 ).</target>
        </trans-unit>
        <trans-unit id="11824dd936b3023e24b3affd0ef64f49ba6ed2c9" translate="yes" xml:space="preserve">
          <source>A slightly sad example of not reading anything into a buffer:</source>
          <target state="translated">버퍼로 아무것도 읽지 않는 약간 슬픈 예 :</target>
        </trans-unit>
        <trans-unit id="45dafb0f63eaca5bfb7f56b27e11fa2b7d396e89" translate="yes" xml:space="preserve">
          <source>A socket address could not be bound because the address is already in use elsewhere.</source>
          <target state="translated">주소가 이미 다른 곳에서 사용 중이므로 소켓 주소를 바인딩 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac2b051bc6a92539c672158c6142e1d18c98d73f" translate="yes" xml:space="preserve">
          <source>A somewhat surprising consequence of the definition is that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; (if &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt;) even though it seems like that might provide unsynchronized mutation. The trick is that a mutable reference behind a shared reference (that is, &lt;code&gt;&amp;amp; &amp;amp;mut T&lt;/code&gt;) becomes read-only, as if it were a &lt;code&gt;&amp;amp; &amp;amp;T&lt;/code&gt;. Hence there is no risk of a data race.</source>
          <target state="translated">정의의 다소 놀라운 결과 는 &lt;code&gt;Sync&lt;/code&gt; 되지 않은 돌연변이를 제공 할 수있는 것처럼 보이지만 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 가 &lt;code&gt;Sync&lt;/code&gt; ( &lt;code&gt;T&lt;/code&gt; 가 Sync 인 경우 )입니다. 트릭은 공유 참조 뒤에있는 가변 참조 ( &lt;code&gt;&amp;amp; &amp;amp;mut T&lt;/code&gt; )가 &lt;code&gt;&amp;amp; &amp;amp;T&lt;/code&gt; 인 것처럼 읽기 전용이되는 것 입니다. 따라서 데이터 경쟁의 위험이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2194c015edca7318deaf09554d0cad9263a5128b" translate="yes" xml:space="preserve">
          <source>A source file can have a &lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix)&quot;&gt;&lt;em&gt;shebang&lt;/em&gt;&lt;/a&gt; (SHEBANG production), which indicates to the operating system what program to use to execute this file. It serves essentially to treat the source file as an executable script. The shebang can only occur at the beginning of the file (but after the optional &lt;em&gt;UTF8BOM&lt;/em&gt;). It is ignored by the compiler. For example:</source>
          <target state="translated">소스 파일에는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix)&quot;&gt;&lt;em&gt;shebang&lt;/em&gt;&lt;/a&gt; (SHEBANG 프로덕션) 이있을 수 있으며 운영 체제에이 파일을 실행하는 데 사용할 프로그램을 나타냅니다. 기본적으로 소스 파일을 실행 가능한 스크립트로 취급합니다. shebang은 파일의 시작 부분 (옵션 &lt;em&gt;UTF8BOM&lt;/em&gt; 이후)에서만 발생할 수 있습니다 . 컴파일러는이를 무시합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ec62fb18603ebc6519f469782df4169fc5a681f" translate="yes" xml:space="preserve">
          <source>A source stage in an iterator pipeline.</source>
          <target state="translated">반복기 파이프 라인의 소스 단계.</target>
        </trans-unit>
        <trans-unit id="3a13e4ab897112a5bbfa779986c13ffc8249c723" translate="yes" xml:space="preserve">
          <source>A specialized &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type for I/O operations.</source>
          <target state="translated">I / O 작업에 대한 특수 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="29c08563a92ed84161c48f32442e9c55ea57c60e" translate="yes" xml:space="preserve">
          <source>A specialized &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type for threads.</source>
          <target state="translated">스레드에 대한 특수 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="c3d479aee422ab65a96675342bd98a8476bf0c50" translate="yes" xml:space="preserve">
          <source>A splicing iterator for &lt;code&gt;Vec&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; 의 스 플라이 싱 반복자 .</target>
        </trans-unit>
        <trans-unit id="382d455769d00569a95a026174c2cb511f9bbb7a" translate="yes" xml:space="preserve">
          <source>A stability attribute has been used outside of the standard library.</source>
          <target state="translated">안정성 속성이 표준 라이브러리 외부에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="9c6a5b448820983a6050fcd10b6c3d4dd333f376" translate="yes" xml:space="preserve">
          <source>A stability attribute was used outside of the standard library.</source>
          <target state="translated">표준 라이브러리 외부에서 안정성 속성이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="7208bc1e59d67cb800b9b249868cce02c7e08ab0" translate="yes" xml:space="preserve">
          <source>A stability attribute was used outside of the standard library. Erroneous code example:</source>
          <target state="translated">안정성 속성은 표준 라이브러리 외부에서 사용되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="c28a8a30c83d119da8eeb5ad945a45667f90aa8f" translate="yes" xml:space="preserve">
          <source>A statement is the smallest standalone element of a programming language that commands a computer to perform an action.</source>
          <target state="translated">명령문은 컴퓨터가 동작을 수행하도록 명령하는 프로그래밍 언어의 가장 작은 독립형 요소입니다.</target>
        </trans-unit>
        <trans-unit id="7993655a3c3f53e3aa0f9baecc01e8b1f97ae73b" translate="yes" xml:space="preserve">
          <source>A statement.</source>
          <target state="translated">진술.</target>
        </trans-unit>
        <trans-unit id="d137e324ac57303f829812294caa15b53500d48e" translate="yes" xml:space="preserve">
          <source>A static item is a value which is valid for the entire duration of your program (a &lt;code&gt;'static&lt;/code&gt; lifetime).</source>
          <target state="translated">정적 항목은 프로그램의 전체 기간 ( &lt;code&gt;'static&lt;/code&gt; 수명) 동안 유효한 값입니다 .</target>
        </trans-unit>
        <trans-unit id="1525834046325d03a0ffcca63064524577af3217" translate="yes" xml:space="preserve">
          <source>A string (&lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a vector of bytes (&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid &lt;code&gt;String&lt;/code&gt;s, however: &lt;code&gt;String&lt;/code&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">문자열 ( &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; )은 바이트 ( &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; )로 구성되고 바이트 벡터 ( &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt; )는 바이트로 구성 되므로이 함수는 둘 사이를 변환합니다. 모든 바이트 조각이 유효 &lt;code&gt;String&lt;/code&gt; 그러나, S : &lt;code&gt;String&lt;/code&gt; 이 유효한 UTF-8해야합니다. &lt;code&gt;from_utf8()&lt;/code&gt; 은 바이트가 유효한 UTF-8인지 확인한 다음 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d8b0000fb42f01e7695f858d20347ce505d823eb" translate="yes" xml:space="preserve">
          <source>A string describing the architecture of the CPU that is currently in use.</source>
          <target state="translated">현재 사용중인 CPU 아키텍처를 설명하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="5df1b3a45cf6eb695745e50e624d24676a48e8a7" translate="yes" xml:space="preserve">
          <source>A string describing the specific operating system in use. Example value is &lt;code&gt;linux&lt;/code&gt;.</source>
          <target state="translated">사용중인 특정 운영 체제를 설명하는 문자열입니다. 예제 값은 &lt;code&gt;linux&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8947468201a55a4ba9cd06d3d0a2f1ff1271df73" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. 'Left' in this context means the first position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the &lt;em&gt;right&lt;/em&gt; side, not the left.</source>
          <target state="translated">문자열은 일련의 바이트입니다. 이 문맥에서 '왼쪽'은 해당 바이트 문자열의 첫 번째 위치를 의미합니다. '오른쪽에서 왼쪽으로'가 아니라보다 아랍어 또는 히브리어와 같은 언어에 대해 '왼쪽에서 오른쪽으로', 이것은있을 것이다 &lt;em&gt;우측&lt;/em&gt; 측면이 아닌 왼쪽.</target>
        </trans-unit>
        <trans-unit id="0bc83c493a049c765d2dfbebad0f09d82d1b6fde" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. 'Right' in this context means the last position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the &lt;em&gt;left&lt;/em&gt; side, not the right.</source>
          <target state="translated">문자열은 일련의 바이트입니다. 이 문맥에서 '오른쪽'은 해당 바이트 문자열의 마지막 위치를 의미합니다. '오른쪽에서 왼쪽으로'가 아니라보다 아랍어 또는 히브리어와 같은 언어에 대해 '왼쪽에서 오른쪽으로', 이것은있을 것입니다 &lt;em&gt;왼쪽&lt;/em&gt; 측면하지 않을 권리.</target>
        </trans-unit>
        <trans-unit id="a7d73837e1ae6f385cc7b12b321574d70650bd43" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;end&lt;/code&gt; in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side.</source>
          <target state="translated">문자열은 일련의 바이트입니다. 이 컨텍스트에서 &lt;code&gt;end&lt;/code&gt; 은 해당 바이트 문자열의 마지막 위치를 의미합니다. 영어 나 러시아어와 같은 왼쪽에서 오른쪽으로 쓰는 언어의 경우 오른쪽이되고 아랍어 나 히브리어와 같은 오른쪽에서 왼쪽으로 쓰는 언어의 경우 왼쪽이됩니다.</target>
        </trans-unit>
        <trans-unit id="fd472172ba3e393c6a98b65077b0a65554fdb8e3" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;end&lt;/code&gt; in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like like Arabic or Hebrew, this will be the left side.</source>
          <target state="translated">문자열은 일련의 바이트입니다. 이 문맥에서 &lt;code&gt;end&lt;/code&gt; 은 해당 바이트 문자열의 마지막 위치를 의미합니다. 영어 나 러시아어와 같이 왼쪽에서 오른쪽으로 쓰는 언어의 경우 오른쪽이되고 아랍어 나 히브리어와 같은 오른쪽에서 왼쪽으로 쓰는 언어의 경우 왼쪽이됩니다.</target>
        </trans-unit>
        <trans-unit id="8add450b8d835c6c86dcce6d9f4412fe207173ed" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;start&lt;/code&gt; in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side.</source>
          <target state="translated">문자열은 일련의 바이트입니다. 이 컨텍스트에서 &lt;code&gt;start&lt;/code&gt; 은 해당 바이트 문자열의 첫 번째 위치를 의미합니다. 영어 나 러시아어와 같은 왼쪽에서 오른쪽으로 쓰는 언어의 경우 왼쪽이되고 아랍어 나 히브리어와 같은 오른쪽에서 왼쪽으로 쓰는 언어의 경우 오른쪽이됩니다.</target>
        </trans-unit>
        <trans-unit id="b8e69c41862936bd74ab07a7db3ea33fabc1421d" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;start&lt;/code&gt; in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like like Arabic or Hebrew, this will be the right side.</source>
          <target state="translated">문자열은 일련의 바이트입니다. 이 문맥에서 &lt;code&gt;start&lt;/code&gt; 은 해당 바이트 문자열의 첫 번째 위치를 의미합니다. 영어 나 러시아어와 같은 왼쪽에서 오른쪽으로 쓰는 언어의 경우 왼쪽이되고 아랍어 나 히브리어와 같은 오른쪽에서 왼쪽으로 쓰는 언어의 경우 오른쪽이됩니다.</target>
        </trans-unit>
        <trans-unit id="3af90a5c6860195d31687a2b123d3690f30cc3df" translate="yes" xml:space="preserve">
          <source>A string literal is a string stored directly in the final binary, and so will be valid for the &lt;code&gt;'static&lt;/code&gt; duration.</source>
          <target state="translated">문자열 리터럴은 최종 바이너리에 직접 저장된 문자열이므로 &lt;code&gt;'static&lt;/code&gt; 지속 기간 동안 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="72d1187b478d157904cca7877538ced2b416e35f" translate="yes" xml:space="preserve">
          <source>A string pattern.</source>
          <target state="translated">문자열 패턴.</target>
        </trans-unit>
        <trans-unit id="067ff927875044f01fc32c9a4450dd787608c362" translate="yes" xml:space="preserve">
          <source>A string slice (&lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a byte slice (&lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid string slices, however: &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">문자열 슬라이스 ( &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; )는 바이트 ( &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; )로 구성되고 바이트 슬라이스 ( &lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt; )는 바이트로 구성 되므로이 함수는 둘 사이를 변환합니다. 모든 바이트 슬라이스가 유효한 문자열 슬라이스는 아니지만 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 하려면 유효한 UTF-8 이어야 합니다. &lt;code&gt;from_utf8()&lt;/code&gt; 은 바이트가 유효한 UTF-8인지 확인한 다음 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e7464828dc4f92a12dd0ad9693849275688a2fde" translate="yes" xml:space="preserve">
          <source>A string slice (&lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a vector of bytes (&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid &lt;code&gt;String&lt;/code&gt;s, however: &lt;code&gt;String&lt;/code&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">문자열 슬라이스 ( &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; )는 바이트 ( &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; ) 로 만들어지고 바이트 벡터 ( &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt; )는 바이트로 만들어 지므로이 함수는 둘 사이를 변환합니다. 그러나 모든 바이트 슬라이스가 유효한 &lt;code&gt;String&lt;/code&gt; 은 아닙니다 . &lt;code&gt;String&lt;/code&gt; 은 유효한 UTF-8이어야합니다. &lt;code&gt;from_utf8()&lt;/code&gt; 은 바이트가 유효한 UTF-8인지 확인한 다음 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="185b4c50dbb326aeb04eb1f2bab9a2d41dd7280a" translate="yes" xml:space="preserve">
          <source>A string slice is the most primitive string type in Rust, written as &lt;code&gt;str&lt;/code&gt;. It is often seen in its borrowed forms, either mutable or shared. The shared string slice type is &lt;code&gt;&amp;amp;str&lt;/code&gt;, while the mutable string slice type is &lt;code&gt;&amp;amp;mut str&lt;/code&gt;.</source>
          <target state="translated">문자열 슬라이스는 Rust에서 가장 원시적 인 문자열 유형으로 &lt;code&gt;str&lt;/code&gt; 로 작성됩니다 . 종종 빌린 형태로 변경 가능하거나 공유됩니다. 공유 문자열 슬라이스 유형은 &lt;code&gt;&amp;amp;str&lt;/code&gt; 이고 변경 가능한 문자열 슬라이스 유형은 &lt;code&gt;&amp;amp;mut str&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="696c15b61497eb0b1cb08d222cb16dce5b4582da" translate="yes" xml:space="preserve">
          <source>A struct can be &lt;code&gt;Copy&lt;/code&gt;, and &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;Copy&lt;/code&gt;, therefore &lt;code&gt;Point&lt;/code&gt; is eligible to be &lt;code&gt;Copy&lt;/code&gt;. By contrast, consider</source>
          <target state="translated">구조체가 될 수 있습니다 &lt;code&gt;Copy&lt;/code&gt; 하고, &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 이다 &lt;code&gt;Copy&lt;/code&gt; 따라서 &lt;code&gt;Point&lt;/code&gt; 가 될 자격이 &lt;code&gt;Copy&lt;/code&gt; . 대조적으로, 고려</target>
        </trans-unit>
        <trans-unit id="eb9b96b59ca1189f15dc2a933aeadc425813dff3" translate="yes" xml:space="preserve">
          <source>A struct constructor with private fields was invoked.</source>
          <target state="translated">개인 필드가있는 구조체 생성자가 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="f5d13af10075668c4266bfa2af5c2d787c33d9d3" translate="yes" xml:space="preserve">
          <source>A struct constructor with private fields was invoked. Erroneous code example:</source>
          <target state="translated">개인 필드가있는 구조체 생성자가 호출되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="d5d8cb072da62f16419c7934c8ea02767949e9d6" translate="yes" xml:space="preserve">
          <source>A struct containing information about the location of a panic.</source>
          <target state="translated">공황의 위치에 대한 정보를 포함하는 구조체.</target>
        </trans-unit>
        <trans-unit id="4cbc7f2982657f6ecdc97f40e8df1ad547c2b1e9" translate="yes" xml:space="preserve">
          <source>A struct expression can terminate with the syntax &lt;code&gt;..&lt;/code&gt; followed by an expression to denote a functional update. The expression following &lt;code&gt;..&lt;/code&gt; (the base) must have the same struct type as the new struct type being formed.</source>
          <target state="translated">구조체 식은 구문 &lt;code&gt;..&lt;/code&gt; 으로 끝나고 기능 업데이트를 나타내는식이 뒤따를 수 있습니다 . &lt;code&gt;..&lt;/code&gt; (기본) 다음에 나오는 표현식 은 새로운 struct 유형과 동일한 struct 유형을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="86c4b8e1d72da61f04333be84148a5de11fccd79" translate="yes" xml:space="preserve">
          <source>A struct expression with fields enclosed in curly braces allows you to specify the value for each individual field in any order. The field name is separated from its value with a colon.</source>
          <target state="translated">중괄호로 묶인 필드가있는 구조체 표현식을 사용하면 각 개별 필드의 값을 임의의 순서로 지정할 수 있습니다. 필드 이름은 콜론으로 값과 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="89ddcc2481a3b96d64219755d7c1825c0ff65c03" translate="yes" xml:space="preserve">
          <source>A struct expression with fields enclosed in parentheses constructs a tuple struct. Though it is listed here as a specific expression for completeness, it is equivalent to a &lt;a href=&quot;call-expr&quot;&gt;call expression&lt;/a&gt; to the tuple struct's constructor. For example:</source>
          <target state="translated">괄호로 묶인 필드가있는 구조체 표현식은 튜플 구조체를 구성합니다. 여기에는 완전성을위한 특정 표현식으로 나열되어 있지만 튜플 구조체의 생성자 에 대한 &lt;a href=&quot;call-expr&quot;&gt;호출 표현식&lt;/a&gt; 과 동일합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a5683978535ef36d2f4a36fc97769f59882d764" translate="yes" xml:space="preserve">
          <source>A struct pattern attempted to extract a non-existent field from a struct.</source>
          <target state="translated">구조체 패턴이 구조체에서 존재하지 않는 필드를 추출하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="fed041bebb665ccd5885e8c57eed09e9404a7bab" translate="yes" xml:space="preserve">
          <source>A struct pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">하위 패턴 중 하나가 반박 가능한 경우 구조체 패턴은 반박 가능합니다.</target>
        </trans-unit>
        <trans-unit id="7845438dcb42a82b5f335b8afeff28c09f01fb02" translate="yes" xml:space="preserve">
          <source>A struct providing information about a panic.</source>
          <target state="translated">공황에 관한 정보를 제공하는 구조체.</target>
        </trans-unit>
        <trans-unit id="2e74ee410a88a7bd4dc9ec3e4439e1be7c03f52f" translate="yes" xml:space="preserve">
          <source>A struct to help with &lt;a href=&quot;trait.debug&quot;&gt;&lt;code&gt;fmt::Debug&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">&lt;a href=&quot;trait.debug&quot;&gt; &lt;code&gt;fmt::Debug&lt;/code&gt; &lt;/a&gt; 구현 을 돕는 구조체 입니다.</target>
        </trans-unit>
        <trans-unit id="878d9a84ea5b4c1dd0e00cf0901eb339704e2d00" translate="yes" xml:space="preserve">
          <source>A struct was declared with two fields having the same name.</source>
          <target state="translated">동일한 이름을 가진 두 개의 필드로 구조체가 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="5cc6e14f7d3ffa0d43917de969f7811f2b833f5b" translate="yes" xml:space="preserve">
          <source>A struct with a single field which is accessible by dereferencing the struct.</source>
          <target state="translated">구조체를 역 참조함으로써 접근 가능한 단일 필드를 가진 구조체.</target>
        </trans-unit>
        <trans-unit id="804d90713791042aa7ae7163ec47b488d14fba5e" translate="yes" xml:space="preserve">
          <source>A struct with a single field which is modifiable by dereferencing the struct.</source>
          <target state="translated">구조체를 역 참조함으로써 수정 가능한 단일 필드를 가진 구조체.</target>
        </trans-unit>
        <trans-unit id="0888572f00b05df1f9ff3f22503c0dc7eb90c709" translate="yes" xml:space="preserve">
          <source>A struct with more than one field containing an unsized type cannot implement &lt;code&gt;CoerceUnsized&lt;/code&gt;. This only occurs when you are trying to coerce one of the types in your struct to another type in the struct. In this case we try to impl &lt;code&gt;CoerceUnsized&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;U&lt;/code&gt; which are both types that the struct takes. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">크기가 조정되지 않은 유형을 포함하는 필드가 둘 이상인 구조체는 &lt;code&gt;CoerceUnsized&lt;/code&gt; 를 구현할 수 없습니다 . 구조체의 형식 중 하나를 구조체의 다른 형식으로 강제 변환하려는 경우에만 발생합니다. 이 경우 구조체가 취하는 두 가지 유형 인 &lt;code&gt;CoerceUnsized&lt;/code&gt; 를 &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;U&lt;/code&gt; 로묵시 하려고합니다 . &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;크기를 지정하지 않은 타입은&lt;/a&gt; 컴파일러가 컴파일시에 길이 또는 정렬을 알고하지 않습니다 어떤 유형입니다. 크기가 조정되지 않은 유형을 포함하는 모든 구조체도 크기가 조정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd90f531eb1d0ac938c6ffc13d21933bccfecc8d" translate="yes" xml:space="preserve">
          <source>A struct with the representation hint &lt;code&gt;repr(transparent)&lt;/code&gt; had zero or more than one fields that were not guaranteed to be zero-sized.</source>
          <target state="translated">표현 힌트 &lt;code&gt;repr(transparent)&lt;/code&gt; 가 있는 구조체 는 0 또는 두 개 이상의 필드를 갖지만 크기가 0이 아님을 보증하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1c33e6a538a3d99ccd128f7c3f5572cd613b66b" translate="yes" xml:space="preserve">
          <source>A struct without a field containing an unsized type cannot implement &lt;code&gt;CoerceUnsized&lt;/code&gt;. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">크기가 지정되지 않은 유형을 포함하는 필드가없는 구조체는 &lt;code&gt;CoerceUnsized&lt;/code&gt; 를 구현할 수 없습니다 . &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;크기를 지정하지 않은 타입은&lt;/a&gt; 컴파일러가 컴파일시에 길이 또는 정렬을 알고하지 않습니다 어떤 유형입니다. 크기가 조정되지 않은 유형을 포함하는 모든 구조체도 크기가 조정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bfe3d05f336ffd910d212738048395d48df402c2" translate="yes" xml:space="preserve">
          <source>A struct's or struct-like enum variant's field was not provided.</source>
          <target state="translated">구조체 또는 구조체와 유사한 열거 형 변형의 필드가 제공되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5bcfe0f822e1b5462565a584546dacf4f3c36744" translate="yes" xml:space="preserve">
          <source>A struct's or struct-like enum variant's field was specified more than once.</source>
          <target state="translated">구조체 또는 구조체와 유사한 열거 형 변형의 필드가 두 번 이상 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="d312c16b162889c1bce1669ed072c5b476d65baa" translate="yes" xml:space="preserve">
          <source>A struct, enum, or union with the &lt;code&gt;repr(transparent)&lt;/code&gt; representation hint contains a zero-sized field that requires non-trivial alignment.</source>
          <target state="translated">&lt;code&gt;repr(transparent)&lt;/code&gt; 표현 힌트 와 구조체, 열거 또는 공용체는 사소한 정렬이 필요한 크기가 0 인 필드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="87c6cf95d3e0451e702dc377209e4618399b1fa6" translate="yes" xml:space="preserve">
          <source>A structure representing a Unix domain socket server.</source>
          <target state="translated">유닉스 도메인 소켓 서버를 나타내는 구조.</target>
        </trans-unit>
        <trans-unit id="369143bfa607c6bacd39b080c8d08420dc95dcbd" translate="yes" xml:space="preserve">
          <source>A structure representing a type of file with accessors for each file type. It is returned by &lt;a href=&quot;struct.metadata#method.file_type&quot;&gt;&lt;code&gt;Metadata::file_type&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">각 파일 형식에 대한 접근자가있는 파일 형식을 나타내는 구조입니다. &lt;a href=&quot;struct.metadata#method.file_type&quot;&gt; &lt;code&gt;Metadata::file_type&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="2859b7dadbca8f1bc62c1ff5e0e2a9f89b18f533" translate="yes" xml:space="preserve">
          <source>A structure wrapping a Windows path prefix as well as its unparsed string representation.</source>
          <target state="translated">구문 분석되지 않은 문자열 표현뿐만 아니라 Windows 경로 접두사를 래핑하는 구조입니다.</target>
        </trans-unit>
        <trans-unit id="a18cd960fc14986c70aa975cf92200531a20ff48" translate="yes" xml:space="preserve">
          <source>A structure-literal syntax was used to create an item that is not a structure or enum variant.</source>
          <target state="translated">구조 또는 열거 형 변형이 아닌 항목을 만드는 데 구조 리터럴 구문이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="450ed556ad629fd6ee6dd398c15074a8c129be66" translate="yes" xml:space="preserve">
          <source>A successful conversion will produce the same result as &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;CString::new&lt;/code&gt;&lt;/a&gt; when called without the ending nul byte.</source>
          <target state="translated">성공적인 변환은 끝 nul 바이트없이 호출 될 때 &lt;a href=&quot;struct.cstring#method.new&quot;&gt; &lt;code&gt;CString::new&lt;/code&gt; &lt;/a&gt; 와 동일한 결과를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="d24a2a657ceada76d6bbbb3c74ce41c5696fa9c3" translate="yes" xml:space="preserve">
          <source>A successful send occurs when it is determined that the other end of the channel has not hung up already. An unsuccessful send would be one where the corresponding receiver has already been deallocated. Note that a return value of &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; means that the data will never be received, but a return value of &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; does &lt;em&gt;not&lt;/em&gt; mean that the data will be received. It is possible for the corresponding receiver to hang up immediately after this function returns &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">채널의 다른 쪽 끝이 이미 끊지 않았다고 판단되면 성공적으로 전송됩니다. 실패한 송신은 해당 수신자가 이미 할당 해제 된 것입니다. &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 의 반환 값은 데이터가 수신 되지 &lt;em&gt;않음을&lt;/em&gt; 의미 하지만 &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 의 반환 값이 데이터가 수신됨을 의미 하지는 &lt;em&gt;않습니다&lt;/em&gt; . 이 함수가 &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; 를&lt;/a&gt; 반환 한 직후에 해당 수신기가 끊어 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74d74f5ba0d4e61c19c1486af3bde440292622e8" translate="yes" xml:space="preserve">
          <source>A suffix is a non-raw identifier immediately (without whitespace) following the primary part of a literal.</source>
          <target state="translated">접미사는 리터럴의 주요 부분 바로 뒤에 나오는 공백이 아닌 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="01225be668ae4fcd869b26b266eae668b00e87f5" translate="yes" xml:space="preserve">
          <source>A super trait has been added to an auto trait.</source>
          <target state="translated">자동 특성에 슈퍼 특성이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="fcd1d7403a3a0b004c92da849e81f0a2dc9aaf82" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with &lt;a href=&quot;struct.once#method.new&quot;&gt;&lt;code&gt;Once::new()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일회성 전역 초기화를 실행하는 데 사용할 수있는 동기화 기본 요소입니다. FFI 또는 관련 기능에 대한 일회성 초기화에 유용합니다. 이 유형은 &lt;a href=&quot;struct.once#method.new&quot;&gt; &lt;code&gt;Once::new()&lt;/code&gt; &lt;/a&gt; 로만 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a56a331926b2603c064792db84cd20c38dc32bf0" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with the &lt;a href=&quot;constant.once_init&quot;&gt;&lt;code&gt;ONCE_INIT&lt;/code&gt;&lt;/a&gt; value or the equivalent &lt;a href=&quot;struct.once#method.new&quot;&gt;&lt;code&gt;Once::new&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">일회성 글로벌 초기화를 실행하는 데 사용할 수있는 동기화 기본 요소. FFI 또는 관련 기능의 일회성 초기화에 유용합니다. 이 유형은 &lt;a href=&quot;constant.once_init&quot;&gt; &lt;code&gt;ONCE_INIT&lt;/code&gt; &lt;/a&gt; 값 또는 동등한 &lt;a href=&quot;struct.once#method.new&quot;&gt; &lt;code&gt;Once::new&lt;/code&gt; &lt;/a&gt; 생성자 로만 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ae033712f05c69a86c1b61d9806f301efbdf2ee" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be written to only once.</source>
          <target state="translated">한 번만 쓸 수있는 동기화 기본 요소입니다.</target>
        </trans-unit>
        <trans-unit id="ec350722ecdc068b18a23660d975deaef83608f5" translate="yes" xml:space="preserve">
          <source>A synchronous, bounded channel. The &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; function will return a &lt;code&gt;(SyncSender, Receiver)&lt;/code&gt; tuple where the storage for pending messages is a pre-allocated buffer of a fixed size. All sends will be &lt;strong&gt;synchronous&lt;/strong&gt; by blocking until there is buffer space available. Note that a bound of 0 is allowed, causing the channel to become a &quot;rendezvous&quot; channel where each sender atomically hands off a message to a receiver.</source>
          <target state="translated">동기적이고 제한된 채널. &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; 의&lt;/a&gt; 함수 반환 &lt;code&gt;(SyncSender, Receiver)&lt;/code&gt; 보류 된 메시지의 저장이 고정 된 크기의 사전 - 할당 된 버퍼이다 튜플. 사용 가능한 버퍼 공간이 확보 될 때까지 차단하여 모든 송신이 &lt;strong&gt;동기&lt;/strong&gt; 됩니다. 0의 경계가 허용되므로 채널은 각 발신자가 원자 적으로 수신자에게 메시지를 전달하는 &quot;랑데부&quot;채널이됩니다.</target>
        </trans-unit>
        <trans-unit id="cba628809f9496f1476d8b33de698410511ed6a9" translate="yes" xml:space="preserve">
          <source>A syntactical production</source>
          <target state="translated">구문 생산</target>
        </trans-unit>
        <trans-unit id="a737498d76fd77a9ff17becf5c122eff8eaa0e65" translate="yes" xml:space="preserve">
          <source>A temporary value is being dropped while a borrow is still in active use.</source>
          <target state="translated">차용이 아직 활성 상태 인 동안 임시 값이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="96826c24c299b2bf43fb19f0b4fbba10405e86b7" translate="yes" xml:space="preserve">
          <source>A thread can also return a value through its &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;, you can use this to make asynchronous computations (futures might be more appropriate though).</source>
          <target state="translated">스레드는 &lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; 을&lt;/a&gt; 통해 값을 반환 할 수도 있습니다.이를 사용하여 비동기 계산을 수행 할 수 있습니다 (미래가 더 적합 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="ca6a08446cfa59c90fd402f951ed8784aa3d5f4c" translate="yes" xml:space="preserve">
          <source>A thread local storage key which owns its contents.</source>
          <target state="translated">내용을 소유하는 스레드 로컬 스토리지 키.</target>
        </trans-unit>
        <trans-unit id="a566c05b188249907018616799317e8f6688426e" translate="yes" xml:space="preserve">
          <source>A thread that completes without panicking is considered to exit successfully.</source>
          <target state="translated">당황하지 않고 완료된 스레드는 성공적으로 종료 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="cd2f16a831072bb59e0c5fa9974e56f23c534e74" translate="yes" xml:space="preserve">
          <source>A thread-local key owns the value it contains and will destroy the value when the thread exits. It is created with the &lt;a href=&quot;../macro.thread_local&quot;&gt;&lt;code&gt;thread_local!&lt;/code&gt;&lt;/a&gt; macro and can contain any value that is &lt;code&gt;'static&lt;/code&gt; (no borrowed pointers). It provides an accessor function, &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt;, that yields a shared reference to the value to the specified closure. Thread-local keys allow only shared access to values, as there would be no way to guarantee uniqueness if mutable borrows were allowed. Most values will want to make use of some form of &lt;strong&gt;interior mutability&lt;/strong&gt; through the &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt; types.</source>
          <target state="translated">스레드 로컬 키는 포함 된 값을 소유하며 스레드가 종료되면 값을 삭제합니다. &lt;a href=&quot;../macro.thread_local&quot;&gt; &lt;code&gt;thread_local!&lt;/code&gt; &lt;/a&gt; 로 작성됩니다 ! 매크로이며 &lt;code&gt;'static&lt;/code&gt; (임대 된 포인터 없음) 인 값을 포함 할 수 있습니다 . &lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 접근 자 함수를 제공 하여 지정된 클로저에 대한 값에 대한 공유 참조를 생성합니다. 스레드 로컬 키는 변경 가능한 차용이 허용 된 경우 고유성을 보장 할 방법이 없으므로 값에 대한 공유 액세스 만 허용합니다. 대부분의 값은 &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; 유형을 통해 어떤 형태의 &lt;strong&gt;내부 변이성&lt;/strong&gt; 을 사용 하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="7c1b3e385815bb55356e10c862b54219c0c9bb61" translate="yes" xml:space="preserve">
          <source>A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically Reference Counted'.</source>
          <target state="translated">스레드 안전 레퍼런스 카운팅 포인터. 'Arc'는 'Atomically Reference Counted'를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c20fcb5862a17955d3c9171cc540c5db72364cad" translate="yes" xml:space="preserve">
          <source>A token produced by the lexer</source>
          <target state="translated">어휘 분석기에서 생산 한 토큰</target>
        </trans-unit>
        <trans-unit id="507266de8c913e006a522a90feaa72cf485f935b" translate="yes" xml:space="preserve">
          <source>A trailing slash is normalized away, &lt;code&gt;/a/b&lt;/code&gt; and &lt;code&gt;/a/b/&lt;/code&gt; are equivalent.</source>
          <target state="translated">후행 슬래시는 &lt;code&gt;/a/b&lt;/code&gt; 및 &lt;code&gt;/a/b/&lt;/code&gt; 정규화됩니다. 는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4ac633f47782fcea3e3cdbd2b28541d42f49cb1e" translate="yes" xml:space="preserve">
          <source>A trait bound on &lt;code&gt;?Sized&lt;/code&gt; is the opposite of a trait bound on &lt;code&gt;Sized&lt;/code&gt;: we would read this as &amp;ldquo;&lt;code&gt;T&lt;/code&gt; may or may not be &lt;code&gt;Sized&lt;/code&gt;.&amp;rdquo; This syntax is only available for &lt;code&gt;Sized&lt;/code&gt;, not any other traits.</source>
          <target state="translated">&quot; &lt;code&gt;?Sized&lt;/code&gt; 에있는 특성은 &lt;code&gt;Sized&lt;/code&gt; 에 대한 특성과 반대입니다 . 우리는 이것을 &quot; &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;Sized&lt;/code&gt; 가 될 수도 있고 그렇지 않을 수도 있습니다 &quot;라고 읽습니다 . 이 구문은 &lt;code&gt;Sized&lt;/code&gt; 다른 특성이 아닌 Sized .</target>
        </trans-unit>
        <trans-unit id="a7f257ac376cb00e120748ca01c24ce026b8963b" translate="yes" xml:space="preserve">
          <source>A trait can have multiple methods in its body: the method signatures are listed one per line and each line ends in a semicolon.</source>
          <target state="translated">특성은 본문에 여러 메소드를 가질 수 있습니다. 메소드 서명은 한 줄에 하나씩 나열되고 각 줄은 세미콜론으로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="9262128bd94142a9efd03c6641a2bff3a39b5b73" translate="yes" xml:space="preserve">
          <source>A trait for borrowing data.</source>
          <target state="translated">데이터를 빌리는 특성.</target>
        </trans-unit>
        <trans-unit id="7529a2277a29d3ff854565242eed7e5e7895a272" translate="yes" xml:space="preserve">
          <source>A trait for converting a value to a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">값을로 변환하는 특성 &lt;code&gt;String&lt;/code&gt; 으로 .</target>
        </trans-unit>
        <trans-unit id="1e3010340eda1a0df2c156c88d0e99044a3b58ec" translate="yes" xml:space="preserve">
          <source>A trait for creating instances of &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; 인스턴스를 만들기위한 특성 .</target>
        </trans-unit>
        <trans-unit id="c6d9b8a4582a6d812cf132a7f8cdac8ff53fc3aa" translate="yes" xml:space="preserve">
          <source>A trait for customizing the behavior of the &lt;code&gt;?&lt;/code&gt; operator.</source>
          <target state="translated">의 행동을 사용자 정의하기위한 특성 &lt;code&gt;?&lt;/code&gt; 운영자.</target>
        </trans-unit>
        <trans-unit id="976dcd2549faab554b8e6bbecaabfc30542917fd" translate="yes" xml:space="preserve">
          <source>A trait for giving a type a useful default value.</source>
          <target state="translated">유형에 유용한 기본값을 제공하는 특성입니다.</target>
        </trans-unit>
        <trans-unit id="e18827eba48f91a1c885aefb421b9657624cb210" translate="yes" xml:space="preserve">
          <source>A trait for hashing an arbitrary stream of bytes.</source>
          <target state="translated">임의의 바이트 스트림을 해시하는 특성.</target>
        </trans-unit>
        <trans-unit id="bdee9213c6e4170b3110b9dd5eaa365239c9d83d" translate="yes" xml:space="preserve">
          <source>A trait for implementing arbitrary return types in the &lt;code&gt;main&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 함수 에서 임의의 리턴 유형을 구현하기위한 특성 .</target>
        </trans-unit>
        <trans-unit id="20b8f1b86976a3452526ed169982978b3d0e907f" translate="yes" xml:space="preserve">
          <source>A trait for mutably borrowing data.</source>
          <target state="translated">데이터를 변경 가능하게 빌리는 특성.</target>
        </trans-unit>
        <trans-unit id="d1ed2c9d8583af1348e3be7781420c71c940ca4b" translate="yes" xml:space="preserve">
          <source>A trait for objects which are byte-oriented sinks.</source>
          <target state="translated">바이트 지향 싱크 인 객체의 특성.</target>
        </trans-unit>
        <trans-unit id="754c048641e5a68c7fd81cc8028cfbaf095e1cb7" translate="yes" xml:space="preserve">
          <source>A trait for objects which can be converted or resolved to one or more &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">하나 이상의 &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; 값 으로 변환되거나 해석 될 수있는 객체의 특성입니다 .</target>
        </trans-unit>
        <trans-unit id="20da43414d9faf5772a30fd6329b8b6d3aa3e3b4" translate="yes" xml:space="preserve">
          <source>A trait for writing or formatting into Unicode-accepting buffers or streams.</source>
          <target state="translated">유니 코드 허용 버퍼 또는 스트림에 쓰거나 서식을 지정하는 특성입니다.</target>
        </trans-unit>
        <trans-unit id="23adce518b9b9c7fb3e196dc3fd75bab1e5f0059" translate="yes" xml:space="preserve">
          <source>A trait implementation has stricter requirements than the trait definition.</source>
          <target state="translated">특성 구현에는 특성 정의보다 더 엄격한 요구 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc29685de3e170d55184516a7b3d199864139684" translate="yes" xml:space="preserve">
          <source>A trait implementation is considered incoherent if either the orphan check fails or there are overlapping implementation instances.</source>
          <target state="translated">고아 검사가 실패하거나 구현 인스턴스가 겹치는 경우 특성 구현이 일관성이없는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a4884230017ffb802f52c6721c470c8593e7fcd5" translate="yes" xml:space="preserve">
          <source>A trait implementation is considered incoherent if either the orphan rules check fails or there are overlapping implementation instances.</source>
          <target state="translated">고아 규칙 검사가 실패하거나 겹치는 구현 인스턴스가있는 경우 특성 구현은 일관성이없는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="bb0a26a692dfe7bee9af7137b27b0e076260ccbc" translate="yes" xml:space="preserve">
          <source>A trait implementation must define all non-default associated items declared by the implemented trait, may redefine default associated items defined by the implemented trait, and cannot define any other items.</source>
          <target state="translated">특성 구현은 구현 된 특성에 의해 선언 된 모든 비 기본 연관 항목을 정의해야하며 구현 된 특성에 의해 정의 된 기본 연관 항목을 재정의 할 수 있으며 다른 항목을 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d0010f4426c0d6cbe2dc68d818b29e968be48db6" translate="yes" xml:space="preserve">
          <source>A trait implementation was marked as unsafe while the trait is safe.</source>
          <target state="translated">특성 구현은 특성이 안전하지만 안전하지 않은 것으로 표시되었습니다.</target>
        </trans-unit>
        <trans-unit id="1951065ab3447cdfa4016a3198b5e5dd606d4a6b" translate="yes" xml:space="preserve">
          <source>A trait is a language item that is used for describing the functionalities a type must provide. It allows a type to make certain promises about its behavior.</source>
          <target state="translated">특성은 유형이 제공해야하는 기능을 설명하는 데 사용되는 언어 항목입니다. 형식이 동작에 대해 특정 약속을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9de8e0634dfdc7f3f2e02723351cb17b73aefe4" translate="yes" xml:space="preserve">
          <source>A trait may be implemented for &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; in the same crate as &lt;code&gt;T&lt;/code&gt;, which the &lt;a href=&quot;items/implementations#trait-implementation-coherence&quot;&gt;orphan rules&lt;/a&gt; prevent for other generic types.</source>
          <target state="translated">&lt;a href=&quot;items/implementations#trait-implementation-coherence&quot;&gt;고아 규칙&lt;/a&gt; 이 다른 일반 유형에 대해 방지 하는 &lt;code&gt;T&lt;/code&gt; 와 동일한 상자에서 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 에 대해 특성이 구현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b745de10511ea796795a51c79ea5a4b196da151" translate="yes" xml:space="preserve">
          <source>A trait method was declared const.</source>
          <target state="translated">특성 메서드가 const로 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="c934c2073046ff60e5d7154f42129a33305f83af" translate="yes" xml:space="preserve">
          <source>A trait object is defined over a single, fully-defined trait. With a regular default parameter, this parameter can just be substituted in. However, if the default parameter is &lt;code&gt;Self&lt;/code&gt;, the trait changes for each concrete type; i.e. &lt;code&gt;i32&lt;/code&gt; will be expected to implement &lt;code&gt;A&amp;lt;i32&amp;gt;&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt; will be expected to implement &lt;code&gt;A&amp;lt;bool&amp;gt;&lt;/code&gt;, etc... These types will not share an implementation of a fully-defined trait; instead they share implementations of a trait with different parameters substituted in for each implementation. This is irreconcilable with what we need to make a trait object work, and is thus disallowed. Making the trait concrete by explicitly specifying the value of the defaulted parameter will fix this issue. Fixed example:</source>
          <target state="translated">형질 개체는 완전히 정의 된 단일 특성에 대해 정의됩니다. 일반 기본 매개 변수를 사용하면이 매개 변수를 대체 할 수 있습니다. 그러나 기본 매개 변수가 &lt;code&gt;Self&lt;/code&gt; 인 경우 각 콘크리트 유형에 따라 특성이 변경됩니다. 즉,이 &lt;code&gt;i32&lt;/code&gt; 구현 할 것으로 예상됩니다 &lt;code&gt;A&amp;lt;i32&amp;gt;&lt;/code&gt; , &lt;code&gt;bool&lt;/code&gt; 구현 할 것으로 예상됩니다 &lt;code&gt;A&amp;lt;bool&amp;gt;&lt;/code&gt; 등 ...이 유형은 완전히 정의 된 특성의 구현을 공유하지 않습니다. 대신 각 구현에 대해 다른 매개 변수로 대체 된 특성의 구현을 공유합니다. 이것은 특질 대상을 작동시키는 데 필요한 것과 양립 할 수 없으므로 허용되지 않습니다. 기본 매개 변수의 값을 명시 적으로 지정하여 특성을 구체적으로 만들면이 문제가 해결됩니다. 고정 된 예 :</target>
        </trans-unit>
        <trans-unit id="09ed217e59efc6a63ebd08cd2d7fd8370e33eb53" translate="yes" xml:space="preserve">
          <source>A trait object was declared with no traits.</source>
          <target state="translated">특성이없는 특성 개체가 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="16935dd0c42b10d2b4960eb5cbdc15bbae87c965" translate="yes" xml:space="preserve">
          <source>A trait to emulate dynamic typing.</source>
          <target state="translated">동적 타이핑을 모방하는 특성.</target>
        </trans-unit>
        <trans-unit id="2977e50a37e0d1dad52d9fd5a6a043035b25bd2b" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to construct an object from a raw file descriptor.</source>
          <target state="translated">원시 파일 디스크립터에서 오브젝트를 구성하는 기능을 표현하는 특성입니다.</target>
        </trans-unit>
        <trans-unit id="d60c5c028a11d7b4ae9ad91367b8c4ed38349307" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw &lt;code&gt;HANDLE&lt;/code&gt;.</source>
          <target state="translated">객체를 소비하고 원시 &lt;code&gt;HANDLE&lt;/code&gt; 소유권을 얻는 능력을 표현하는 특성 .</target>
        </trans-unit>
        <trans-unit id="c1f9b5c774891d37ad148a2229500ad192b8b52c" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw &lt;code&gt;SOCKET&lt;/code&gt;.</source>
          <target state="translated">객체를 소비하고 원시 &lt;code&gt;SOCKET&lt;/code&gt; 의 소유권을 얻는 능력을 표현하는 특성 .</target>
        </trans-unit>
        <trans-unit id="a98e8ff575c7077546911de64edefa1e0d617067" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw file descriptor.</source>
          <target state="translated">객체를 소비하고 원시 파일 디스크립터의 소유권을 얻는 기능을 표현하는 특성.</target>
        </trans-unit>
        <trans-unit id="25a11a87d2f4adf0083235ec32efcdd357ad1b14" translate="yes" xml:space="preserve">
          <source>A trait to extract the raw unix file descriptor from an underlying object.</source>
          <target state="translated">기본 개체에서 원시 unix 파일 설명자를 추출하는 특성입니다.</target>
        </trans-unit>
        <trans-unit id="74dfee4318a470e1c8aa720bcf48b06f65b677a2" translate="yes" xml:space="preserve">
          <source>A trait type has been dereferenced.</source>
          <target state="translated">특성 유형이 역 참조되었습니다.</target>
        </trans-unit>
        <trans-unit id="a3b4acf36ca74c434adb6226f16d93f351b2c3d1" translate="yes" xml:space="preserve">
          <source>A trait was implemented on another which already automatically implemented it.</source>
          <target state="translated">이미 자동으로 구현 된 다른 특성이 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="1af6d624d68ca3ca313d81ebc03c7ca717454c50" translate="yes" xml:space="preserve">
          <source>A transparent struct, enum, or union is supposed to be represented exactly like the piece of data it contains. Zero-sized fields with different alignment requirements potentially conflict with this property. In the example above, &lt;code&gt;Wrapper&lt;/code&gt; would have to be aligned to 32 bytes even though &lt;code&gt;f32&lt;/code&gt; has a smaller alignment requirement.</source>
          <target state="translated">투명한 구조체, 열거 형 또는 공용체는 포함 된 데이터와 똑같이 표현되어야합니다. 다른 정렬 요구 사항을 가진 크기가 0 인 필드는이 속성과 충돌 할 가능성이 있습니다. 위의 예에서, &lt;code&gt;f32&lt;/code&gt; 는 더 작은 정렬 요구 사항을 갖 더라도 &lt;code&gt;Wrapper&lt;/code&gt; 는 32 바이트로 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="490336a5e305f2d2e8d1363f03a6314c497a78fa" translate="yes" xml:space="preserve">
          <source>A tricky example, with sigma:</source>
          <target state="translated">시그마를 사용한 까다로운 예 :</target>
        </trans-unit>
        <trans-unit id="2d6e480d45ae2d8d8e393f568dbe81e3240a2b6b" translate="yes" xml:space="preserve">
          <source>A trivial example of the usage of &lt;code&gt;bool&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 사용법의 간단한 예 ,</target>
        </trans-unit>
        <trans-unit id="26204199326019f143410da0c8e1f31498a99258" translate="yes" xml:space="preserve">
          <source>A tuple &lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;elements&lt;/em&gt; of the tuple. It has no nominal name and is instead structurally typed.</source>
          <target state="translated">튜플 &lt;em&gt;유형&lt;/em&gt; 은 튜플 의 &lt;em&gt;요소&lt;/em&gt; 라고하는 다른 유형의 이기종 곱입니다 . 명목 이름이 없으며 구조적으로 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="e9dbb3e94f53ac8e3a8ca087dfd88ec94acc48f5" translate="yes" xml:space="preserve">
          <source>A tuple index is used to refer to the fields of &lt;a href=&quot;types/tuple&quot;&gt;tuples&lt;/a&gt;, &lt;a href=&quot;items/structs&quot;&gt;tuple structs&lt;/a&gt;, and &lt;a href=&quot;items/enumerations&quot;&gt;tuple variants&lt;/a&gt;.</source>
          <target state="translated">튜플 인덱스는 &lt;a href=&quot;types/tuple&quot;&gt;튜플&lt;/a&gt; , &lt;a href=&quot;items/structs&quot;&gt;튜플 구조체&lt;/a&gt; 및 &lt;a href=&quot;items/enumerations&quot;&gt;튜플 변형&lt;/a&gt; 의 필드를 참조하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b0541e4cbc97c5e40f947c03ae1731aeaba596f" translate="yes" xml:space="preserve">
          <source>A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</source>
          <target state="translated">튜플은 다양한 유형의 여러 값을 하나의 복합 유형으로 그룹화하는 일반적인 방법입니다. 튜플의 길이는 고정되어 있습니다. 일단 선언되면 크기가 늘어나거나 줄어들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="402bd39bb6c42541595f5aba7871ff88c655396e" translate="yes" xml:space="preserve">
          <source>A tuple is a general way of grouping together some number of other values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</source>
          <target state="translated">튜플은 다양한 유형의 여러 다른 값을 하나의 복합 유형으로 그룹화하는 일반적인 방법입니다. 튜플의 길이는 고정되어 있습니다. 일단 선언하면 크기를 늘리거나 줄일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8d3a96e70924f2a82e85cf6036b452ac805c64ec" translate="yes" xml:space="preserve">
          <source>A tuple struct or tuple variant was used in a pattern as if it were a struct or struct variant.</source>
          <target state="translated">튜플 구조체 또는 튜플 변형은 마치 구조체 또는 구조체 변형 인 것처럼 패턴에 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="1696a724c358dd0091f73a52db83c7a8082d2750" translate="yes" xml:space="preserve">
          <source>A tuple struct pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">튜플 구조체 패턴은 하위 패턴 중 하나가 반박 가능할 때 반박 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8f5d8407de99f6165aaf419c7f8aaf0ecf33a5a2" translate="yes" xml:space="preserve">
          <source>A tuple struct's element isn't a machine type when using the &lt;code&gt;#[simd]&lt;/code&gt; attribute.</source>
          <target state="translated">튜플 구조체의 요소는 &lt;code&gt;#[simd]&lt;/code&gt; 속성을 사용할 때 머신 유형이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="63c229f3f830c234653affc74d3c7117a6730da6" translate="yes" xml:space="preserve">
          <source>A type alias for &lt;a href=&quot;../convert/enum.infallible&quot;&gt;&lt;code&gt;Infallible&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../convert/enum.infallible&quot;&gt; &lt;code&gt;Infallible&lt;/code&gt; &lt;/a&gt; 의 유형 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="1009527a15bba1ad137f4f63c037795bd4a2bfe2" translate="yes" xml:space="preserve">
          <source>A type alias for the result of a lock method which can be poisoned.</source>
          <target state="translated">중독 될 수있는 잠금 방법의 결과에 대한 유형 별명입니다.</target>
        </trans-unit>
        <trans-unit id="aae3cf8f6eb9071486813bec542109175b1464e5" translate="yes" xml:space="preserve">
          <source>A type alias for the result of a nonblocking locking method.</source>
          <target state="translated">비 블로킹 잠금 방법의 결과에 대한 유형 별명입니다.</target>
        </trans-unit>
        <trans-unit id="811e3fb59c28acd0a23a2498fc25dd5079b4be0d" translate="yes" xml:space="preserve">
          <source>A type alias makes this code more manageable by reducing the repetition. In Listing 19-25, we&amp;rsquo;ve introduced an alias named &lt;code&gt;Thunk&lt;/code&gt; for the verbose type and can replace all uses of the type with the shorter alias &lt;code&gt;Thunk&lt;/code&gt;.</source>
          <target state="translated">타입 별칭은 반복을 줄임으로써이 코드를보다 관리하기 쉽게 만듭니다. Listing 19-25에서는 상세 유형에 &lt;code&gt;Thunk&lt;/code&gt; 라는 별명을 도입 했으며이 유형의 모든 사용을 더 짧은 별명 &lt;code&gt;Thunk&lt;/code&gt; 로 대체 할 수있다 .</target>
        </trans-unit>
        <trans-unit id="4e38a79e72762fd78e402d5747ab629fd9e3cf95" translate="yes" xml:space="preserve">
          <source>A type alias to a tuple-struct or unit-struct cannot be used to qualify that type's constructor:</source>
          <target state="translated">tuple-struct 또는 unit-struct에 대한 형식 별칭은 해당 형식의 생성자를 한정하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="872091a52699e1a821b52be55e9443115016332c" translate="yes" xml:space="preserve">
          <source>A type alias to an enum type cannot be used to qualify the constructors:</source>
          <target state="translated">열거 형에 대한 유형 별칭은 생성자를 한정하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e407e83d82ec15858c1c29f981a47a04ebb8636" translate="yes" xml:space="preserve">
          <source>A type annotated as &lt;code&gt;repr(transparent)&lt;/code&gt; delegates all representation concerns to another type, so adding more representation hints is contradictory. Remove either the &lt;code&gt;transparent&lt;/code&gt; hint or the other hints, like this:</source>
          <target state="translated">&lt;code&gt;repr(transparent)&lt;/code&gt; 로 주석이 달린 유형 은 모든 표현 문제를 다른 유형으로 위임하므로 더 많은 표현 힌트를 추가하는 것은 모순됩니다. 다음과 같이 &lt;code&gt;transparent&lt;/code&gt; 힌트 또는 다른 힌트를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb5e8aa2faa836eb0e6e33148484b741b2f52f31" translate="yes" xml:space="preserve">
          <source>A type can also have multiple inherent implementations. An implementing type must be defined within the same crate as the original type definition.</source>
          <target state="translated">유형에는 여러 고유 구현이있을 수도 있습니다. 구현 유형은 원래 유형 정의와 동일한 상자 내에 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec397cd955b41db47c056843b89f1c979b1499b9" translate="yes" xml:space="preserve">
          <source>A type can implement &lt;code&gt;Copy&lt;/code&gt; if all of its components implement &lt;code&gt;Copy&lt;/code&gt;. For example, this struct can be &lt;code&gt;Copy&lt;/code&gt;:</source>
          <target state="translated">모든 구성 요소가 &lt;code&gt;Copy&lt;/code&gt; 를 구현하는 경우 형식은 &lt;code&gt;Copy&lt;/code&gt; 를 구현할 수 있습니다 . 예를 들어이 구조체는 &lt;code&gt;Copy&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1e5e79c85877ceec782fbfaa18c2c4e5b9b2282" translate="yes" xml:space="preserve">
          <source>A type cast expression is denoted with the binary operator &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">유형 캐스트 ​​표현식은 이항 연산자 &lt;code&gt;as&lt;/code&gt; 로 표시 됩니다 .</target>
        </trans-unit>
        <trans-unit id="2b97b41bd9c7eae77d5c3b940d4a5832d7e972fb" translate="yes" xml:space="preserve">
          <source>A type dependency cycle has been encountered.</source>
          <target state="translated">유형 종속성주기가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="2904374f2c0e91251791d02f72bd6378c8bccc80" translate="yes" xml:space="preserve">
          <source>A type has both &lt;code&gt;packed&lt;/code&gt; and &lt;code&gt;align&lt;/code&gt; representation hints.</source>
          <target state="translated">형식에는 &lt;code&gt;packed&lt;/code&gt; 및 &lt;code&gt;align&lt;/code&gt; 표시 힌트 가 모두 있습니다.</target>
        </trans-unit>
        <trans-unit id="77f0b7a28b6f2753f1d76d09de19c12454b7888f" translate="yes" xml:space="preserve">
          <source>A type has conflicting &lt;code&gt;packed&lt;/code&gt; representation hints.</source>
          <target state="translated">유형에 충돌하는 &lt;code&gt;packed&lt;/code&gt; 표현 힌트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="995f457de088e34d1af6ab0e7cbed95033f1f938" translate="yes" xml:space="preserve">
          <source>A type implementing &lt;code&gt;Try&lt;/code&gt; is one that has a canonical way to view it in terms of a success/failure dichotomy. This trait allows both extracting those success or failure values from an existing instance and creating a new instance from a success or failure value.</source>
          <target state="translated">&lt;code&gt;Try&lt;/code&gt; 를 구현하는 형식 은 성공 / 실패 이분법으로 볼 수있는 정식 방법이있는 유형 입니다. 이 특성을 통해 기존 인스턴스에서 해당 성공 또는 실패 값을 추출하고 성공 또는 실패 값에서 새 인스턴스를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5199d6683f66f6377d3e5c541ab1e1a45f0a440" translate="yes" xml:space="preserve">
          <source>A type indicating whether a timed wait on a condition variable returned due to a time out or not.</source>
          <target state="translated">시간 종료로 인해 조건 변수에 대한 시간 종료 대기가 리턴되는지 여부를 표시하는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bcb42c5f4b4345c9c33893996e574612ab86b0f7" translate="yes" xml:space="preserve">
          <source>A type is inhabited if it has constructors and therefore can be instantiated. An inhabited type is not &quot;empty&quot; in the sense that there can be values of the type. Opposite of &lt;a href=&quot;#uninhabited&quot;&gt;Uninhabited&lt;/a&gt;.</source>
          <target state="translated">생성자가있는 경우 형식이 존재하므로 인스턴스화 할 수 있습니다. 거주 유형은 유형의 값이있을 수 있다는 점에서 &quot;비어있는&quot;것이 아닙니다. &lt;a href=&quot;#uninhabited&quot;&gt;무인도의&lt;/a&gt; 반대 .</target>
        </trans-unit>
        <trans-unit id="61c125cceb1922063b5ac33f0666ef79257f43a2" translate="yes" xml:space="preserve">
          <source>A type is uninhabited if it has no constructors and therefore can never be instantiated. An uninhabited type is &quot;empty&quot; in the sense that there are no values of the type. The canonical example of an uninhabited type is the &lt;a href=&quot;types/never&quot;&gt;never type&lt;/a&gt;&lt;code&gt;!&lt;/code&gt;, or an enum with no variants &lt;code&gt;enum Never { }&lt;/code&gt;. Opposite of &lt;a href=&quot;#inhabited&quot;&gt;Inhabited&lt;/a&gt;.</source>
          <target state="translated">생성자가없는 형식은 사람이 살지 않으므로 인스턴스화 할 수 없습니다. 무인 유형은 유형의 값이 없다는 의미에서 &quot;비어 있습니다&quot;. 무인 유형의 표준 예는 &lt;a href=&quot;types/never&quot;&gt;never 유형입니다 &lt;/a&gt; &lt;code&gt;!&lt;/code&gt; , 또는 변형이없는 &lt;code&gt;enum Never { }&lt;/code&gt; . 의 반대 &lt;a href=&quot;#inhabited&quot;&gt;거주 된&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3666c5137a8c2f5bd25b41e59026d010547814d" translate="yes" xml:space="preserve">
          <source>A type mismatched an associated type of a trait.</source>
          <target state="translated">유형이 관련 유형의 특성과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="195d3e2324eafc4b95d0787028892dc2ce75ef57" translate="yes" xml:space="preserve">
          <source>A type of error which can be returned whenever a lock is acquired.</source>
          <target state="translated">잠금을 획득 할 때마다 리턴 될 수있는 오류 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e09ee31e80fe4ed67d90fe93645d23ccc6bd8f11" translate="yes" xml:space="preserve">
          <source>A type or lifetime parameter has been declared but is not actually used.</source>
          <target state="translated">유형 또는 수명 매개 변수가 선언되었지만 실제로 사용되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7fb190bd9cd84e642f9c437ffcc3a0470b68cd6" translate="yes" xml:space="preserve">
          <source>A type or module has been defined more than once.</source>
          <target state="translated">유형 또는 모듈이 두 번 이상 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="630bff58f7c530334c09b287d02fb5f603530515" translate="yes" xml:space="preserve">
          <source>A type parameter that is specified for &lt;code&gt;impl&lt;/code&gt; is not constrained.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; 에 지정된 유형 매개 변수 는 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a60e8550db7fb8bf181c3c2af427df857c9bf7d" translate="yes" xml:space="preserve">
          <source>A type parameter was declared which shadows an existing one. An example of this error:</source>
          <target state="translated">기존 매개 변수를 음영 처리하는 유형 매개 변수가 선언되었습니다. 이 오류의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e1d3a1b69ee90016db302de62e4dd15a2f4ff16" translate="yes" xml:space="preserve">
          <source>A type parameter which references &lt;code&gt;Self&lt;/code&gt; in its default value was not specified.</source>
          <target state="translated">기본값으로 &lt;code&gt;Self&lt;/code&gt; 를 참조하는 유형 매개 변수가 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="25fe9cd48afec311fa3f403a24aafba6272aeca5" translate="yes" xml:space="preserve">
          <source>A type parameter which references &lt;code&gt;Self&lt;/code&gt; in its default value was not specified. Example of erroneous code:</source>
          <target state="translated">기본값에서 &lt;code&gt;Self&lt;/code&gt; 를 참조하는 유형 매개 변수가 지정되지 않았습니다. 잘못된 코드의 예 :</target>
        </trans-unit>
        <trans-unit id="5ff8db748ed5eaad6145c2ecc683c1493e2ac732" translate="yes" xml:space="preserve">
          <source>A type parameter with default value is using forward declared identifier.</source>
          <target state="translated">기본값이있는 유형 매개 변수는 앞으로 선언 된 식별자를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d790d10f882d09d23c776016863815c5b3e2b81" translate="yes" xml:space="preserve">
          <source>A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the middle.</source>
          <target state="translated">중간에 널 바이트가없는 고유 한 C 호환 널 종료 문자열을 나타내는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b3b99d63ae795914f8001d38731a170b595e6b2b" translate="yes" xml:space="preserve">
          <source>A type that can be any one of several variants.</source>
          <target state="translated">여러 변형 중 하나 일 수있는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="090b303bdd4057540547275158d9e42939d01cec" translate="yes" xml:space="preserve">
          <source>A type that can represent owned, mutable platform-native strings, but is cheaply inter-convertible with Rust strings.</source>
          <target state="translated">소유하고 변경 가능한 플랫폼 네이티브 문자열을 나타낼 수 있지만 Rust 문자열과 저렴하게 상호 변환 할 수있는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="220ecc56d2012059c1d8cd78943adf0ed8ed7d8e" translate="yes" xml:space="preserve">
          <source>A type that is composed of other types.</source>
          <target state="translated">다른 유형으로 구성된 유형입니다.</target>
        </trans-unit>
        <trans-unit id="0a851afebbaf8a3f378080846c51bf756d8476cc" translate="yes" xml:space="preserve">
          <source>A type that is not a trait was used in a trait position, such as a bound or &lt;code&gt;impl&lt;/code&gt;.</source>
          <target state="translated">특성이 아닌 유형이 bound 또는 &lt;code&gt;impl&lt;/code&gt; 과 같은 특성 위치에 사용되었습니다 .</target>
        </trans-unit>
        <trans-unit id="48dabc713e66c06bf48c0ba95cf5b1b2867095db" translate="yes" xml:space="preserve">
          <source>A type to emulate dynamic typing.</source>
          <target state="translated">동적 타이핑을 에뮬레이트하는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="18995bad7092858c6b32d35a26167b88faf2e216" translate="yes" xml:space="preserve">
          <source>A type used to conditionally initialize buffers passed to &lt;code&gt;Read&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; 메서드에 전달 된 버퍼를 조건부로 초기화하는 데 사용되는 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="8a527d3dadad04c815571442c7e455c6295d0179" translate="yes" xml:space="preserve">
          <source>A type which does not appear as an argument to another type. For example, &lt;code&gt;T&lt;/code&gt; is uncovered, but the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; is covered. This is only relevant for type arguments.</source>
          <target state="translated">다른 유형에 대한 인수로 나타나지 않는 유형입니다. 예를 들어, &lt;code&gt;T&lt;/code&gt; 는 발견되었지만 &lt;code&gt;T&lt;/code&gt; 에 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 덮여있다. 이것은 유형 인수에만 관련됩니다.</target>
        </trans-unit>
        <trans-unit id="48a3662dff4bc918fde00d869523d6a4f45ec09b" translate="yes" xml:space="preserve">
          <source>A type with &lt;code&gt;packed&lt;/code&gt; representation hint has a field with &lt;code&gt;align&lt;/code&gt; representation hint.</source>
          <target state="translated">&lt;code&gt;packed&lt;/code&gt; 표현 힌트가있는 유형에는 &lt;code&gt;align&lt;/code&gt; 표현 힌트 가있는 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f40b2b31a159196f4517607c9d76ab5a80f0274d" translate="yes" xml:space="preserve">
          <source>A type&amp;rsquo;s behavior consists of the methods we can call on that type. Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.</source>
          <target state="translated">유형의 동작은 해당 유형을 호출 할 수있는 메소드로 구성됩니다. 모든 유형에서 동일한 메소드를 호출 할 수 있으면 다른 유형이 동일한 동작을 공유합니다. 특성 정의는 몇 가지 목적을 달성하는 데 필요한 일련의 동작을 정의하기 위해 메소드 서명을 그룹화하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="3b6ddcc149faf5698a16d1a853b87785df3d76f9" translate="yes" xml:space="preserve">
          <source>A union access transmutes the content of the union to the type of the accessed field. Since transmutes can cause unexpected or undefined behaviour, &lt;code&gt;unsafe&lt;/code&gt; is required to read from a union field or to write to a field that doesn't implement &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">공용체 액세스는 공용체의 내용을 액세스 된 필드의 유형으로 변환합니다. 변환은 예기치 않은 동작이나 정의되지 않은 동작을 유발할 수 있으므로 공용 필드에서 읽거나 &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; 를&lt;/a&gt; 구현하지 않는 필드에 쓰려면 &lt;code&gt;unsafe&lt;/code&gt; 것이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="5466b2051b7ddfaa4d58e8a7c5e165f16f139371" translate="yes" xml:space="preserve">
          <source>A union declaration uses the same syntax as a struct declaration, except with &lt;code&gt;union&lt;/code&gt; in place of &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">유니온 선언 제외하고, 구조체 선언과 같은 구문을 사용하여 &lt;code&gt;union&lt;/code&gt; 대신 &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca484ccd859cf11dbaf1461b26fb4e6e0c1155bd" translate="yes" xml:space="preserve">
          <source>A union declared with &lt;code&gt;#[repr(C)]&lt;/code&gt; will have the same size and alignment as an equivalent C union declaration in the C language for the target platform. The union will have a size of the maximum size of all of its fields rounded to its alignment, and an alignment of the maximum alignment of all of its fields. These maximums may come from different fields.</source>
          <target state="translated">노조는 선언 &lt;code&gt;#[repr(C)]&lt;/code&gt; 타겟 플랫폼에 대한 C 언어의 등가 C 조합 선언 같은 것 같은 크기와 정렬. 공용체는 모든 필드의 최대 크기를 정렬로 반올림하고 모든 필드의 최대 정렬을 정렬합니다. 이 최대 값은 다른 필드에서 나올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5f776fff8bd64de524df1b33719d9e03226007b" translate="yes" xml:space="preserve">
          <source>A unique identifier for a running thread.</source>
          <target state="translated">실행중인 스레드의 고유 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="10b778820b33fd4a7dd6fe5ae783d38d25f8f4be" translate="yes" xml:space="preserve">
          <source>A unit struct expression is just the path to a unit struct item. This refers to the unit struct's implicit constant of its value. The unit struct value can also be constructed with a fieldless struct expression. For example:</source>
          <target state="translated">유닛 구조체 표현식은 유닛 구조체 아이템의 경로 일뿐입니다. 이것은 단위 구조체의 값의 암시 적 상수를 나타냅니다. 단위 구조체 값은 필드없는 구조체 식으로 구성 할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1ccfef1f9d17695dcb29cad8794e8d363ce8a2b" translate="yes" xml:space="preserve">
          <source>A unrecognized representation attribute was used.</source>
          <target state="translated">인식 할 수없는 표현 속성이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="5b4c71cc75880bc2daa87d6294e45d4e462f56c4" translate="yes" xml:space="preserve">
          <source>A used type name is not in scope.</source>
          <target state="translated">사용 된 유형 이름이 범위에 없습니다.</target>
        </trans-unit>
        <trans-unit id="bb363e92161ec8a647cc462201572019f30fe79b" translate="yes" xml:space="preserve">
          <source>A vacant entry.</source>
          <target state="translated">비어있는 항목.</target>
        </trans-unit>
        <trans-unit id="ac311baab6584071250fc9bbbfdd8d2bebd0c9e9" translate="yes" xml:space="preserve">
          <source>A value in a &lt;code&gt;char&lt;/code&gt; which is a surrogate or above &lt;code&gt;char::MAX&lt;/code&gt;.</source>
          <target state="translated">A의 값 &lt;code&gt;char&lt;/code&gt; 대리 또는 이상 &lt;code&gt;char::MAX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cd18e9d0df56f2d91218b99bcfa24832cc2e846" translate="yes" xml:space="preserve">
          <source>A value of a &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt; type can also be created using this syntax, except that it must specify exactly one field.</source>
          <target state="translated">정확히 하나의 필드를 지정해야한다는 점을 제외하고이 구문을 사용하여 &lt;a href=&quot;../items/unions&quot;&gt;공용체&lt;/a&gt; 유형 의 값을 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f77849f445f82a7dac2f95551cd7b942f343391" translate="yes" xml:space="preserve">
          <source>A value of a union type can be created using the same syntax that is used for struct types, except that it must specify exactly one field:</source>
          <target state="translated">구조체 유형에 사용되는 것과 동일한 구문을 사용하여 유니온 유형의 값을 만들 수 있습니다. 단 하나의 필드 만 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="2edc0a57205327b0c616a8834c05686bc2cd3aab" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">논리적 &lt;strong&gt;false를&lt;/strong&gt; 나타내는 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; 유형의 값입니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7083e77e4fd9ce896b8de61f936c4776bbf66b89" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">논리적 &lt;strong&gt;true를&lt;/strong&gt; 나타내는 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; 유형의 값입니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c8dd18f78fe47645f4c465046226e5bceaa87924" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">논리적 &lt;strong&gt;false를&lt;/strong&gt; 나타내는 &lt;a href=&quot;primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; 유형의 값입니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f389328467f7ba3f2c3abda8662442b712ffb60" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">논리적 &lt;strong&gt;true를&lt;/strong&gt; 나타내는 &lt;a href=&quot;primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; 유형의 값입니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b855bdd2c1132135fcde425660863334401f8ec6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string.</source>
          <target state="translated">입력 값 &lt;code&gt;char&lt;/code&gt; A는 &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;유니 스칼라 값&lt;/a&gt; 0x10FFFF 범위 0xD7FF 또는 0xE000 행 0000의 32 비트 부호 워드로 표현 (대리없는 즉 코드 포인트). &lt;code&gt;[char]&lt;/code&gt; 효과적으로 UCS-4 / UTF-32 문자열이다.</target>
        </trans-unit>
        <trans-unit id="d1f3055da898f22398d4fbd4a38fa84ee1e65f98" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. It is immediate &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;Undefined Behavior&lt;/a&gt; to create a &lt;code&gt;char&lt;/code&gt; that falls outside this range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string of length 1.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 유형의 값은 0x0000에서 0xD7FF 또는 0xE000에서 0x10FFFF 범위의 32 비트 부호없는 단어로 표시 되는 &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;유니 코드 스칼라 값&lt;/a&gt; (즉, 서로 게이트가 아닌 코드 포인트)입니다. 이 범위를 벗어나는 &lt;code&gt;char&lt;/code&gt; 를 만드는 것은 즉시 &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;정의되지 않은 동작&lt;/a&gt; 입니다. &lt;code&gt;[char]&lt;/code&gt; 유효 길이 1의 UCS-4 / UTF-32 문자열이다.</target>
        </trans-unit>
        <trans-unit id="3e06926f845b74d33c5ef28adb8bb299e3388cd7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. It is immediate &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;Undefined Behavior&lt;/a&gt; to create a &lt;code&gt;char&lt;/code&gt; that falls outside this range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string of length 1.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 유형의 값은 0x0000에서 0xD7FF 또는 0xE000에서 0x10FFFF 범위의 32 비트 부호없는 단어로 표시 되는 &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;유니 코드 스칼라 값&lt;/a&gt; (즉, 서로 게이트가 아닌 코드 포인트)입니다. 이 범위를 벗어나는 &lt;code&gt;char&lt;/code&gt; 를 만드는 것은 즉시 &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;정의되지 않은 동작&lt;/a&gt; 입니다. &lt;code&gt;[char]&lt;/code&gt; 유효 길이 1의 UCS-4 / UTF-32 문자열이다.</target>
        </trans-unit>
        <trans-unit id="59d76a5d3d80327c3f37cdc56ddfd9ab850292ae" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;str&lt;/code&gt; is a Unicode string, represented as an array of 8-bit unsigned bytes holding a sequence of UTF-8 code points. Since &lt;code&gt;str&lt;/code&gt; is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt;, it is not a &lt;em&gt;first-class&lt;/em&gt; type, but can only be instantiated through a pointer type, such as &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 유형의 값은 UTF-8 코드 포인트 시퀀스를 보유하는 8 비트 부호없는 바이트의 배열로 표시되는 유니 코드 문자열입니다. 이후 &lt;code&gt;str&lt;/code&gt; A는 &lt;a href=&quot;../dynamically-sized-types&quot;&gt;동적으로 크기 유형&lt;/a&gt; , 그것은 아닙니다 &lt;em&gt;일류&lt;/em&gt; 유형,하지만 같은 포인터 타입을 통해 인스턴스화 할 수 &lt;code&gt;&amp;amp;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbb241cb793b74334bb4ee4c800e211086ca2124" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;str&lt;/code&gt; is represented the same way as &lt;code&gt;[u8]&lt;/code&gt;, it is a slice of 8-bit unsigned bytes. However, the Rust standard library makes extra assumptions about &lt;code&gt;str&lt;/code&gt;: methods working on &lt;code&gt;str&lt;/code&gt; assume and ensure that the data in there is valid UTF-8. Calling a &lt;code&gt;str&lt;/code&gt; method with a non-UTF-8 buffer can cause &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;Undefined Behavior&lt;/a&gt; now or in the future.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 유형의 값은 &lt;code&gt;[u8]&lt;/code&gt; 과 같은 방식으로 표현되며 8 비트 부호없는 바이트의 조각입니다. 그러나, 녹 표준 라이브러리에 대해 별도의 가정을 &lt;code&gt;str&lt;/code&gt; : 작업 방법 &lt;code&gt;str&lt;/code&gt; 가정 및 데이터에 유효한 UTF-8이 있음을 확인합니다. 비 UTF-8 버퍼 로 &lt;code&gt;str&lt;/code&gt; 메서드를 호출하면 현재 또는 미래에 &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;정의되지 않은 동작&lt;/a&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a63b20136e367659035b6e689b2afe4c29bd6017" translate="yes" xml:space="preserve">
          <source>A value other than &lt;code&gt;false&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) or &lt;code&gt;true&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt;) in a &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 에서 &lt;code&gt;false&lt;/code&gt; ( &lt;code&gt;0&lt;/code&gt; ) 또는 &lt;code&gt;true&lt;/code&gt; ( &lt;code&gt;1&lt;/code&gt; ) 이외의 값 입니다.</target>
        </trans-unit>
        <trans-unit id="b4cba545fd19cda1128ffaf1d3286b9b7d56cde6" translate="yes" xml:space="preserve">
          <source>A value was moved out of a non-copy fixed-size array.</source>
          <target state="translated">복사가 아닌 고정 크기 배열에서 값이 이동되었습니다.</target>
        </trans-unit>
        <trans-unit id="b42cffab7e9c15b342f66d8f5259941653a63c96" translate="yes" xml:space="preserve">
          <source>A value was moved out while it was still borrowed.</source>
          <target state="translated">아직 빌린 동안 가치가 옮겨졌습니다.</target>
        </trans-unit>
        <trans-unit id="82027756f29be28c79aeae3975a5766aa1d2efa8" translate="yes" xml:space="preserve">
          <source>A value was moved whose size was not known at compile time.</source>
          <target state="translated">컴파일시 크기를 알 수없는 값이 이동되었습니다.</target>
        </trans-unit>
        <trans-unit id="9706341e2da60c066ce6e7cf05178b38f120d103" translate="yes" xml:space="preserve">
          <source>A value was moved. However, its size was not known at compile time, and only values of a known size can be moved.</source>
          <target state="translated">값이 이동되었습니다. 그러나 크기는 컴파일 타임에 알려지지 않았으며 알려진 크기의 값만 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44837e659d57e9e8963db42f2a8ff432184c868b" translate="yes" xml:space="preserve">
          <source>A value was used after it was mutably borrowed.</source>
          <target state="translated">변경 가능하게 빌린 후에 값이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="a269a1265b9da40e02988ddb4b935f3e57685c81" translate="yes" xml:space="preserve">
          <source>A value which is initialized on the first access.</source>
          <target state="translated">첫 번째 액세스에서 초기화되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="0a9fd9c77be9db665eaa8aa09f7c11046598c96c" translate="yes" xml:space="preserve">
          <source>A value with a custom &lt;code&gt;Drop&lt;/code&gt; implementation may be dropped during const-eval.</source>
          <target state="translated">사용자 지정 &lt;code&gt;Drop&lt;/code&gt; 구현이있는 값은 const-eval 중에 삭제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce9baf105eb065b4e2e707a1c70964d52846271c" translate="yes" xml:space="preserve">
          <source>A value, once pinned, must remain pinned forever (unless its type implements &lt;code&gt;Unpin&lt;/code&gt;).</source>
          <target state="translated">고정 된 값은 해당 유형이 &lt;code&gt;Unpin&lt;/code&gt; 을 구현하지 않는 한 영구적으로 고정 된 상태를 유지해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f834afc88c6404de279c7c8f515cfb4300b16ac9" translate="yes" xml:space="preserve">
          <source>A value-to-value conversion that consumes the input value. The opposite of &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">입력 값을 사용하는 값-값 변환입니다. &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="0ec26c2f12c942e7a95c50dd2e23886df77a4d3b" translate="yes" xml:space="preserve">
          <source>A variable already borrowed as immutable was borrowed as mutable.</source>
          <target state="translated">이미 불변으로 차용 된 변수는 변할 수있는 것으로 차용되었습니다.</target>
        </trans-unit>
        <trans-unit id="e13d6f0eba74b4bdfc6f5572578b32920b145941" translate="yes" xml:space="preserve">
          <source>A variable is initialized if it has been assigned a value and hasn't since been moved from. All other memory locations are assumed to be uninitialized. Only unsafe Rust can create such a memory without initializing it.</source>
          <target state="translated">변수에 값이 할당되었고 그 이후로 이동하지 않은 경우 변수가 초기화됩니다. 다른 모든 메모리 위치는 초기화되지 않은 것으로 가정합니다. 안전하지 않은 Rust만이 메모리를 초기화하지 않고 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcb706d6a23f6a1ef0d6e932c9012ea02de89d1f" translate="yes" xml:space="preserve">
          <source>A variable used inside an inner function comes from a dynamic environment.</source>
          <target state="translated">내부 함수 내에서 사용되는 변수는 동적 환경에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="624b6ee4bba7ea4936aac9cd4851655dde5b7367" translate="yes" xml:space="preserve">
          <source>A variable was borrowed as mutable more than once.</source>
          <target state="translated">변수가 두 번 이상 가변으로 빌려졌습니다.</target>
        </trans-unit>
        <trans-unit id="d671f0302da4834f34c2a582f5308578a61da28e" translate="yes" xml:space="preserve">
          <source>A variable was borrowed as mutable more than once. Erroneous code example:</source>
          <target state="translated">변수가 두 번 이상 변경 가능하도록 빌 렸습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="8f68dfea86962d0e6496e5ee7e7ba76db7429014" translate="yes" xml:space="preserve">
          <source>A variable was used after its contents have been moved elsewhere.</source>
          <target state="translated">내용이 다른 곳으로 이동 된 후 변수가 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="7373f15283d19d70ccdc1ebdabd671b6fa35a616" translate="yes" xml:space="preserve">
          <source>A variable which requires unique access is being used in more than one closure at the same time.</source>
          <target state="translated">고유 액세스가 필요한 변수가 동시에 둘 이상의 클로저에서 사용되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="179ae2668e7ec007982c4f5de54552aaba759982" translate="yes" xml:space="preserve">
          <source>A very common source of input is standard input:</source>
          <target state="translated">매우 일반적인 입력 소스는 표준 입력입니다.</target>
        </trans-unit>
        <trans-unit id="8fd033d78acbcd4754d1027990e8d5a9b9826bd0" translate="yes" xml:space="preserve">
          <source>A very simple implementation of a &lt;code&gt;Balance&lt;/code&gt; struct that has two sides, where each can be indexed mutably and immutably.</source>
          <target state="translated">두 개의 측면을 갖는 &lt;code&gt;Balance&lt;/code&gt; 구조체 의 매우 간단한 구현으로, 각면은 변경 가능하고 불변으로 인덱싱 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97a780f793593419e0ff592febcf6977a93355f0" translate="yes" xml:space="preserve">
          <source>A view into a single entry in a map, which may either be vacant or occupied.</source>
          <target state="translated">비어 있거나 점유 될 수있는 맵의 단일 항목에 대한 뷰입니다.</target>
        </trans-unit>
        <trans-unit id="8b25993b294c4224a4cf2b72c86b09f4a1df51e2" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;BTreeMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">A의 빈 항목에 대한 전망 &lt;code&gt;BTreeMap&lt;/code&gt; . &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; 열거 형의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="7403429e7fd780dc27d8a13d9952581d4b4e445e" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">A의 빈 항목에 대한 전망 &lt;code&gt;HashMap&lt;/code&gt; . &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; 열거 형의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="e122826d4e223005f70614b786e8ddc75140b027" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.rawentrymut&quot;&gt;&lt;code&gt;RawEntryMut&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">A의 빈 항목에 대한 전망 &lt;code&gt;HashMap&lt;/code&gt; . &lt;a href=&quot;enum.rawentrymut&quot;&gt; &lt;code&gt;RawEntryMut&lt;/code&gt; &lt;/a&gt; 열거 형의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="ce99b5e5cd3ea34b7d4c0f89a8831922c382a6d4" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;BTreeMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">A의 점령 항목에 대한 전망 &lt;code&gt;BTreeMap&lt;/code&gt; . &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; 열거 형의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="be269036f18f5f092608a130f8ea68df4394d390" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">A의 점령 항목에 대한 전망 &lt;code&gt;HashMap&lt;/code&gt; . &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; 열거 형의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="097a52eaa6538170318bb496b2404a2534b2fc4c" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.rawentrymut&quot;&gt;&lt;code&gt;RawEntryMut&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">A의 점령 항목에 대한 전망 &lt;code&gt;HashMap&lt;/code&gt; . &lt;a href=&quot;enum.rawentrymut&quot;&gt; &lt;code&gt;RawEntryMut&lt;/code&gt; &lt;/a&gt; 열거 형의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="1dcb56819c21811e53111728b70cf9c4d536f34f" translate="yes" xml:space="preserve">
          <source>A virtual function pointer table (vtable) that specifies the behavior of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; 의 동작을 지정하는 가상 함수 포인터 테이블 (vtable)입니다 .</target>
        </trans-unit>
        <trans-unit id="9f3a191fe5eca1034f9485c5579c98bfcc0c4efc" translate="yes" xml:space="preserve">
          <source>A visibility qualifier was used when it was unnecessary.</source>
          <target state="translated">가시성 한정자가 불필요 할 때 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="ac7d35f82dab2d813057ea592ffddd469b64e834" translate="yes" xml:space="preserve">
          <source>A visibility qualifier was used when it was unnecessary. Erroneous code examples:</source>
          <target state="translated">불필요 할 때 가시성 한정자가 사용되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="b3fc7b3827a6fcc8a59a000c786e3c02a55a53ac" translate="yes" xml:space="preserve">
          <source>A while-let pattern attempts to match the pattern, and enters the body if the match was successful. If the match is irrefutable (when it cannot fail to match), use a regular &lt;code&gt;let&lt;/code&gt;-binding inside a &lt;code&gt;loop&lt;/code&gt; instead. For instance:</source>
          <target state="translated">while-let 패턴은 패턴과 일치하려고 시도하고 일치하면 본문에 들어갑니다. 일치 할 수없는 경우 (일치 할 수없는 경우) 대신 &lt;code&gt;loop&lt;/code&gt; 내에서 규칙적인 &lt;code&gt;let&lt;/code&gt; - binding을 사용하십시오. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="410ed7d62125fc62e5f4dca9f96376b96589d768" translate="yes" xml:space="preserve">
          <source>A windowed iterator over a slice in overlapping chunks (&lt;code&gt;N&lt;/code&gt; elements at a time), starting at the beginning of the slice</source>
          <target state="translated">슬라이스 의 시작 부분에서 시작하여 겹치는 청크 ( 한 번에 &lt;code&gt;N&lt;/code&gt; 개의 요소)에 있는 슬라이스에 대한 윈도우 반복기</target>
        </trans-unit>
        <trans-unit id="fc142166b026c4503335a66425ed02745d313757" translate="yes" xml:space="preserve">
          <source>A workaround for this problem is to wrap the trait up in a struct, and implement Drop on that. An example is shown below:</source>
          <target state="translated">이 문제에 대한 해결 방법은 구조체에서 특성을 마무리하고 Drop을 구현하는 것입니다. 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f617743555e205f1a8f890d184cd3c23b7f7c1f7" translate="yes" xml:space="preserve">
          <source>A workaround for this problem is to wrap the trait up in a struct, and implement Drop on that:</source>
          <target state="translated">이 문제에 대한 해결 방법은 특성을 구조체로 래핑하고 Drop을 구현하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2126e0b1e41989d782fb5cb045faec8bb5419d59" translate="yes" xml:space="preserve">
          <source>A working version would be:</source>
          <target state="translated">작동하는 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d662f80f6ce134ee94f8241854c8eb7d0a73167" translate="yes" xml:space="preserve">
          <source>A wrapper for a &lt;code&gt;va_list&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;va_list&lt;/code&gt; 의 래퍼</target>
        </trans-unit>
        <trans-unit id="b7d2953f481ad207e80e2b4f3ea38a3fc7fdbf37" translate="yes" xml:space="preserve">
          <source>A wrapper to inhibit compiler from automatically calling &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s destructor.</source>
          <target state="translated">컴파일러가 &lt;code&gt;T&lt;/code&gt; 의 소멸자 를 자동으로 호출하지 못하게하는 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="fd107425d645d1765a8fa8c1d57cb5b2986006a8" translate="yes" xml:space="preserve">
          <source>A wrapper to inhibit compiler from automatically calling &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s destructor. This wrapper is 0-cost.</source>
          <target state="translated">컴파일러가 &lt;code&gt;T&lt;/code&gt; 의 소멸자 를 자동으로 호출하지 못하도록하는 래퍼 입니다. 이 래퍼는 비용이 0입니다.</target>
        </trans-unit>
        <trans-unit id="27e603a9954cbc24a31a5ec5bf12ad7cbfb65091" translate="yes" xml:space="preserve">
          <source>A wrapper type for a mutably borrowed value from a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 에서 차용 한 값의 래퍼 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="76e573ae156cec07995313b0af472777485c1ac4" translate="yes" xml:space="preserve">
          <source>A wrapper type to construct uninitialized instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">초기화되지 않은 &lt;code&gt;T&lt;/code&gt; 인스턴스를 생성하는 래퍼 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="4e4e6894ffe01981313c8a0bdd641986bcbb13e0" translate="yes" xml:space="preserve">
          <source>A writer which will move data into the void.</source>
          <target state="translated">데이터를 빈 공간으로 이동시키는 라이터.</target>
        </trans-unit>
        <trans-unit id="3c1aa63d0f65966b349901d79576dfb3a03d713a" translate="yes" xml:space="preserve">
          <source>A yank &lt;em&gt;does not&lt;/em&gt; delete any code. For example, the yank feature is not intended for deleting accidentally uploaded secrets. If that happens, you must reset those secrets immediately.</source>
          <target state="translated">yank &lt;em&gt;는&lt;/em&gt; 코드를 삭제 &lt;em&gt;하지 않습니다&lt;/em&gt; . 예를 들어, yank 기능은 실수로 업로드 한 비밀을 삭제하기위한 것이 아닙니다. 이 경우 해당 비밀을 즉시 재설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0f586bae86592aff79f5cdbd80a984e38bc5729" translate="yes" xml:space="preserve">
          <source>A yield expression was used outside of the generator literal.</source>
          <target state="translated">생성기 리터럴 외부에서 yield 표현식이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="441d954d4dd0146ecde4bbe0bfe1d8d54e840f8a" translate="yes" xml:space="preserve">
          <source>ABI</source>
          <target state="translated">ABI</target>
        </trans-unit>
        <trans-unit id="f7f4dbec39b0ff3d85b8eb96500c85b0c6447c9c" translate="yes" xml:space="preserve">
          <source>ABI, linking, symbols, and FFI</source>
          <target state="translated">ABI, 링크, 심볼 및 FFI</target>
        </trans-unit>
        <trans-unit id="6984d7f2e63fc7e0a74bddee5e62b9dd8e8c052e" translate="yes" xml:space="preserve">
          <source>API not fully fleshed out and ready to be stabilized</source>
          <target state="translated">API가 완전히 구체화되지 않았고 안정화 될 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="711248439308ea2477b7d1f8ab4f7bd34663bf23" translate="yes" xml:space="preserve">
          <source>APIs like &lt;code&gt;try_for_each&lt;/code&gt; don't need values with &lt;code&gt;Break&lt;/code&gt;, so this provides a way to avoid typing &lt;code&gt;(())&lt;/code&gt;, if you prefer it.</source>
          <target state="translated">&lt;code&gt;try_for_each&lt;/code&gt; 와 같은 API 에는 &lt;code&gt;Break&lt;/code&gt; 값이 필요하지 않으므로 원하는 경우 &lt;code&gt;(())&lt;/code&gt; 을 입력하지 않는 방법을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="623cb147c595ee00f55c9bfbece2fd89256c0ca0" translate="yes" xml:space="preserve">
          <source>ARCH</source>
          <target state="translated">ARCH</target>
        </trans-unit>
        <trans-unit id="ebb42dcc0b64c9c253b3563c217764b64d93cc3b" translate="yes" xml:space="preserve">
          <source>ARM platforms like &lt;code&gt;armv5te&lt;/code&gt; that aren't for Linux do not have any atomics at all.</source>
          <target state="translated">Linux 용이 아닌 &lt;code&gt;armv5te&lt;/code&gt; 와 같은 ARM 플랫폼에는 원자가 전혀 없습니다.</target>
        </trans-unit>
        <trans-unit id="9c08db2a34e8bae40e385191593c075648426189" translate="yes" xml:space="preserve">
          <source>ARM platforms like &lt;code&gt;armv5te&lt;/code&gt; that aren't for Linux only provide &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;store&lt;/code&gt; operations, and do not support Compare and Swap (CAS) operations, such as &lt;code&gt;swap&lt;/code&gt;, &lt;code&gt;fetch_add&lt;/code&gt;, etc. Additionally on Linux, these CAS operations are implemented via &lt;a href=&quot;https://www.kernel.org/doc/Documentation/arm/kernel_user_helpers.txt&quot;&gt;operating system support&lt;/a&gt;, which may come with a performance penalty.</source>
          <target state="translated">Linux 용이 아닌 &lt;code&gt;armv5te&lt;/code&gt; 와 같은 ARM 플랫폼 은 &lt;code&gt;load&lt;/code&gt; 및 &lt;code&gt;store&lt;/code&gt; 작업 만 제공 하고 &lt;code&gt;swap&lt;/code&gt; , &lt;code&gt;fetch_add&lt;/code&gt; 등과 같은 CAS (Compare and Swap) 작업을 지원하지 않습니다 . 또한 Linux에서 이러한 CAS 작업은 &lt;a href=&quot;https://www.kernel.org/doc/Documentation/arm/kernel_user_helpers.txt&quot;&gt;운영 체제 지원을&lt;/a&gt; 통해 구현됩니다. , 성능이 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d8a36ef8e4b107d52ef5f736828e510925b8177" translate="yes" xml:space="preserve">
          <source>ARM targets with &lt;code&gt;thumbv6m&lt;/code&gt; do not have atomic operations at all.</source>
          <target state="translated">&lt;code&gt;thumbv6m&lt;/code&gt; 이있는 ARM 대상에는 전혀 원자 연산이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f34ee041311ae3f08813e81fbedc2a8cd4a047c6" translate="yes" xml:space="preserve">
          <source>ARM targets with &lt;code&gt;thumbv6m&lt;/code&gt; only provide &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;store&lt;/code&gt; operations, and do not support Compare and Swap (CAS) operations, such as &lt;code&gt;swap&lt;/code&gt;, &lt;code&gt;fetch_add&lt;/code&gt;, etc.</source>
          <target state="translated">&lt;code&gt;thumbv6m&lt;/code&gt; 을 사용하는 ARM 타겟 은 &lt;code&gt;load&lt;/code&gt; 및 &lt;code&gt;store&lt;/code&gt; 작업 만 제공 하고 &lt;code&gt;swap&lt;/code&gt; , &lt;code&gt;fetch_add&lt;/code&gt; 등과 같은 CAS (비교 및 교체) 작업을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bb0279d84c9ab08002a8ea7634cd21f2283a6099" translate="yes" xml:space="preserve">
          <source>ASCII :</source>
          <target state="translated">ASCII :</target>
        </trans-unit>
        <trans-unit id="317e8901215d42ccc7940d34b4ce9490884463f7" translate="yes" xml:space="preserve">
          <source>ASCII byte literal</source>
          <target state="translated">ASCII 바이트 리터럴</target>
        </trans-unit>
        <trans-unit id="4d8ae89e872f4c2b2dd8feb9252c9a119be50b1e" translate="yes" xml:space="preserve">
          <source>ASCII escapes</source>
          <target state="translated">ASCII 이스케이프</target>
        </trans-unit>
        <trans-unit id="ca370d4b69baa6a205bc27d7c92d683f7ec62f70" translate="yes" xml:space="preserve">
          <source>ASCII letters 'A' to 'Z' are mapped to 'a' to 'z', but non-ASCII letters are unchanged.</source>
          <target state="translated">ASCII 문자 'A'~ 'Z'는 'a'~ 'z'에 매핑되지만 비 ASCII 문자는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e3db4ca30bac04610a9ba330ec0d3d5c61cf4d8" translate="yes" xml:space="preserve">
          <source>ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but non-ASCII letters are unchanged.</source>
          <target state="translated">ASCII 문자 'a'에서 'z'는 'A'에서 'Z'로 매핑되지만 ASCII가 아닌 문자는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="958cc1148f8aff5543459cc62e998e9d661990e7" translate="yes" xml:space="preserve">
          <source>ASCII_ESCAPE :</source>
          <target state="translated">ASCII_ESCAPE :</target>
        </trans-unit>
        <trans-unit id="8d6c4817508ef1c56c15761069329bc78c08e97c" translate="yes" xml:space="preserve">
          <source>ASCII_FOR_CHAR :</source>
          <target state="translated">ASCII_FOR_CHAR :</target>
        </trans-unit>
        <trans-unit id="1e976fbca3f1cd1471746ec2b3ff6a7a5d15936f" translate="yes" xml:space="preserve">
          <source>ASCII_FOR_STRING :</source>
          <target state="translated">ASCII_FOR_STRING :</target>
        </trans-unit>
        <trans-unit id="b6453d9f657d21e7c289076ce98028e47dc7282d" translate="yes" xml:space="preserve">
          <source>ATOMIC_BOOL_INIT</source>
          <target state="translated">ATOMIC_BOOL_INIT</target>
        </trans-unit>
        <trans-unit id="2b9c513ccbb146434eeb5bd6802254d3e9319214" translate="yes" xml:space="preserve">
          <source>ATOMIC_I16_INIT</source>
          <target state="translated">ATOMIC_I16_INIT</target>
        </trans-unit>
        <trans-unit id="6eacbfe2c8c788ffc6b7a2bdbffc94fa45c82d1a" translate="yes" xml:space="preserve">
          <source>ATOMIC_I32_INIT</source>
          <target state="translated">ATOMIC_I32_INIT</target>
        </trans-unit>
        <trans-unit id="66f562d6648e128b70300462dcad7b8fc4608b4d" translate="yes" xml:space="preserve">
          <source>ATOMIC_I64_INIT</source>
          <target state="translated">ATOMIC_I64_INIT</target>
        </trans-unit>
        <trans-unit id="3fed299eb934560d34d135ac41857a8fb36ef0bf" translate="yes" xml:space="preserve">
          <source>ATOMIC_I8_INIT</source>
          <target state="translated">ATOMIC_I8_INIT</target>
        </trans-unit>
        <trans-unit id="bdb0440ba3e33135f2c764f4348aac2801df19e3" translate="yes" xml:space="preserve">
          <source>ATOMIC_ISIZE_INIT</source>
          <target state="translated">ATOMIC_ISIZE_INIT</target>
        </trans-unit>
        <trans-unit id="8666b79dcee9e5c85aa6e1517921389330c7bb56" translate="yes" xml:space="preserve">
          <source>ATOMIC_U16_INIT</source>
          <target state="translated">ATOMIC_U16_INIT</target>
        </trans-unit>
        <trans-unit id="5463cfe71666bd3cbb7e7bd93e1dea5283405daf" translate="yes" xml:space="preserve">
          <source>ATOMIC_U32_INIT</source>
          <target state="translated">ATOMIC_U32_INIT</target>
        </trans-unit>
        <trans-unit id="fee37bb8c4ae8ff95ead7263aeefbf92f4fb076f" translate="yes" xml:space="preserve">
          <source>ATOMIC_U64_INIT</source>
          <target state="translated">ATOMIC_U64_INIT</target>
        </trans-unit>
        <trans-unit id="b5fd0a39697ab3a5f13871b24404fa76ef7723d2" translate="yes" xml:space="preserve">
          <source>ATOMIC_U8_INIT</source>
          <target state="translated">ATOMIC_U8_INIT</target>
        </trans-unit>
        <trans-unit id="b775de59887a198b8bb80812de87ea9a271a97f2" translate="yes" xml:space="preserve">
          <source>ATOMIC_USIZE_INIT</source>
          <target state="translated">ATOMIC_USIZE_INIT</target>
        </trans-unit>
        <trans-unit id="931aa76f7d621b2bd9a484f56b5e9a93cf07c3f7" translate="yes" xml:space="preserve">
          <source>Abort on memory allocation error or failure.</source>
          <target state="translated">메모리 할당 오류 또는 실패시 중단하십시오.</target>
        </trans-unit>
        <trans-unit id="df06ef34b8240a09fa9f161ea99137607ac00a56" translate="yes" xml:space="preserve">
          <source>Aborts the execution of the process.</source>
          <target state="translated">프로세스 실행을 중단합니다.</target>
        </trans-unit>
        <trans-unit id="b619665e057a59c1a1dbdf52957bcc9212748104" translate="yes" xml:space="preserve">
          <source>Abstract return types</source>
          <target state="translated">추상 반환 유형</target>
        </trans-unit>
        <trans-unit id="db7472b4d6bc69237c01f48a8b625cef374de6c1" translate="yes" xml:space="preserve">
          <source>Abstract return types (written &lt;code&gt;impl Trait&lt;/code&gt; for some trait &lt;code&gt;Trait&lt;/code&gt;) are only allowed as function and inherent impl return types.</source>
          <target state="translated">(작성 추상 반환 형식 &lt;code&gt;impl Trait&lt;/code&gt; 일부 특성에 대한 &lt;code&gt;Trait&lt;/code&gt; ) 단지 기능과 고유 IMPL 반환 유형으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdd7aedb4bc31655563e1852b48c298d5ec5570e" translate="yes" xml:space="preserve">
          <source>Abstract syntax tree</source>
          <target state="translated">추상 구문 트리</target>
        </trans-unit>
        <trans-unit id="8a308b160b478c6d80c833cea5942381a0eb8138" translate="yes" xml:space="preserve">
          <source>Accept a new incoming connection from this listener.</source>
          <target state="translated">이 리스너로부터 새로운 수신 연결을 수락하십시오.</target>
        </trans-unit>
        <trans-unit id="9d161ad935c554382c0d645c53e65dd6566a4bb5" translate="yes" xml:space="preserve">
          <source>Accepting Command Line Arguments</source>
          <target state="translated">명령 줄 인수 수락</target>
        </trans-unit>
        <trans-unit id="5c44c9a8bf41c1458082624764926e9e452b0f9a" translate="yes" xml:space="preserve">
          <source>Accepts &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; orderings.</source>
          <target state="translated">&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;AcqRel&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt; 주문을 수락합니다 .</target>
        </trans-unit>
        <trans-unit id="a053fb66cacbf9febf839206d8e07b27aeeb3488" translate="yes" xml:space="preserve">
          <source>Accepts a new incoming connection to this listener.</source>
          <target state="translated">이 리스너에 대한 새로운 수신 연결을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="41aadfd41c1a6581a617dbde4d22fdb01baa3e91" translate="yes" xml:space="preserve">
          <source>Access an entry by a key and its hash.</source>
          <target state="translated">키와 해시로 항목에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="51a3abe326b3c0792015c0e4fe719586def474a7" translate="yes" xml:space="preserve">
          <source>Access an entry by hash.</source>
          <target state="translated">해시로 항목에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="fab65c5f7333ea79c15d33939860036f46df2b02" translate="yes" xml:space="preserve">
          <source>Access an entry by key.</source>
          <target state="translated">키로 항목에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="f8d8572e08e06ee9c752f760cd0d14aa8e2826f1" translate="yes" xml:space="preserve">
          <source>Access fields in a packed struct:</source>
          <target state="translated">패킹 된 구조체의 필드에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="dcc61ae90f40e1ace5937cd1dcd9d685d9053fd4" translate="yes" xml:space="preserve">
          <source>Access fields of &lt;a href=&quot;keyword.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt;s</source>
          <target state="translated">&lt;a href=&quot;keyword.union&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt; 의 액세스 필드</target>
        </trans-unit>
        <trans-unit id="b465e0094928c80bf2ab2af5859dca5bafc8fa28" translate="yes" xml:space="preserve">
          <source>Access fields of &lt;code&gt;union&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 의 액세스 필드</target>
        </trans-unit>
        <trans-unit id="9ea16fa6ced966020c4bffbd61fb4353757d0cf8" translate="yes" xml:space="preserve">
          <source>Access members of a packed struct by reference:</source>
          <target state="translated">패킹 된 구조체의 멤버에 참조로 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="8b8e97faa7739e19473f47e07608526221b515e7" translate="yes" xml:space="preserve">
          <source>Access or modify a mutable static variable</source>
          <target state="translated">변경 가능한 정적 변수 액세스 또는 수정</target>
        </trans-unit>
        <trans-unit id="cd54de93b3358e522ad1a3c574f8befd63e8ca75" translate="yes" xml:space="preserve">
          <source>Access the underlying UTF-8 error that was the cause of this error.</source>
          <target state="translated">이 오류의 원인이 된 기본 UTF-8 오류에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="46164e9a717820065d93ac43f40d916b0e4e7553" translate="yes" xml:space="preserve">
          <source>AccessError</source>
          <target state="translated">AccessError</target>
        </trans-unit>
        <trans-unit id="ce24154072e2c91b2d63af9c452a4cc41adea723" translate="yes" xml:space="preserve">
          <source>AccessError::borrow</source>
          <target state="translated">AccessError::borrow</target>
        </trans-unit>
        <trans-unit id="0cc742fcaecb2fa19742b5bc67e762feaa6f37c0" translate="yes" xml:space="preserve">
          <source>AccessError::borrow_mut</source>
          <target state="translated">AccessError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a94e2b3363d2d1a8ced8c51a5e15ff4f96e5bb39" translate="yes" xml:space="preserve">
          <source>AccessError::fmt</source>
          <target state="translated">AccessError::fmt</target>
        </trans-unit>
        <trans-unit id="2c2380ad9f60011344ab503262723a632ed3c1d2" translate="yes" xml:space="preserve">
          <source>AccessError::from</source>
          <target state="translated">AccessError::from</target>
        </trans-unit>
        <trans-unit id="7621469337a4b2f74d2a377616bccd38326a7edd" translate="yes" xml:space="preserve">
          <source>AccessError::into</source>
          <target state="translated">AccessError::into</target>
        </trans-unit>
        <trans-unit id="57d0ff4e6d1785ba4d9a1781d3047ed655772b49" translate="yes" xml:space="preserve">
          <source>AccessError::to_string</source>
          <target state="translated">AccessError::to_string</target>
        </trans-unit>
        <trans-unit id="c9ce68542ae4f2f8f818a2b5731ce826d35da932" translate="yes" xml:space="preserve">
          <source>AccessError::try_from</source>
          <target state="translated">AccessError::try_from</target>
        </trans-unit>
        <trans-unit id="cbc880d00714a36a28ddfefa1107fb401f040376" translate="yes" xml:space="preserve">
          <source>AccessError::try_into</source>
          <target state="translated">AccessError::try_into</target>
        </trans-unit>
        <trans-unit id="f18106e890f07e143593c942859c5df6ac97bdb0" translate="yes" xml:space="preserve">
          <source>AccessError::type_id</source>
          <target state="translated">AccessError::type_id</target>
        </trans-unit>
        <trans-unit id="6260b03bb183bb1a54da2dc8ffad6ed6483c869e" translate="yes" xml:space="preserve">
          <source>Accessing Array Elements</source>
          <target state="translated">배열 요소에 액세스</target>
        </trans-unit>
        <trans-unit id="0457e6128b17f06deb434a0c2873ebd99b60eb0d" translate="yes" xml:space="preserve">
          <source>Accessing Fields of a Union</source>
          <target state="translated">연합의 필드에 액세스</target>
        </trans-unit>
        <trans-unit id="6a8c72aa13ec7be5fc27578400a1a226881f478c" translate="yes" xml:space="preserve">
          <source>Accessing Values in a Hash Map</source>
          <target state="translated">해시 맵에서 값에 액세스</target>
        </trans-unit>
        <trans-unit id="b06fec963d87626314583ae2b00b8c48fde3efce" translate="yes" xml:space="preserve">
          <source>Accessing a field of a &lt;a href=&quot;items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt;, other than to assign to it.</source>
          <target state="translated">할당 이외 의 &lt;a href=&quot;items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt; 필드 액세스</target>
        </trans-unit>
        <trans-unit id="a0cd0bd48f335ea136bd217d77f1a368ccbcee58" translate="yes" xml:space="preserve">
          <source>Accessing adjacent &lt;code&gt;u8&lt;/code&gt; as &lt;code&gt;u16&lt;/code&gt;</source>
          <target state="translated">인접 액세스 &lt;code&gt;u8&lt;/code&gt; 같은 &lt;code&gt;u16&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
