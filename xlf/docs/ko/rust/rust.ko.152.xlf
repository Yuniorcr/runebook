<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="d0129491a9c802e31402a256b2ed3248526999bd" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU8&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u8&lt;/code&gt;:</source>
          <target state="translated">이것은 일부 메모리 레이아웃 최적화를 가능하게합니다. 예를 들어, &lt;code&gt;Option&amp;lt;NonZeroU8&amp;gt;&lt;/code&gt; 은 &lt;code&gt;u8&lt;/code&gt; 과 크기가 같습니다.</target>
        </trans-unit>
        <trans-unit id="444ef8a1b6149aa40edb45ac918d2fcc6dd0e6a5" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroUsize&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;usize&lt;/code&gt;:</source>
          <target state="translated">이것은 일부 메모리 레이아웃 최적화를 가능하게합니다. 예를 들어 &lt;code&gt;Option&amp;lt;NonZeroUsize&amp;gt;&lt;/code&gt; 는 usize 와 크기가 &lt;code&gt;usize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05b9c29faea2a683215e0b23ceda6c29cb84253c" translate="yes" xml:space="preserve">
          <source>This enum can contain either an &lt;a href=&quot;struct.ipv4addr&quot;&gt;&lt;code&gt;Ipv4Addr&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;struct.ipv6addr&quot;&gt;&lt;code&gt;Ipv6Addr&lt;/code&gt;&lt;/a&gt;, see their respective documentation for more details.</source>
          <target state="translated">이 열거 형은 하나 포함 할 수 &lt;a href=&quot;struct.ipv4addr&quot;&gt; &lt;code&gt;Ipv4Addr&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.ipv6addr&quot;&gt; &lt;code&gt;Ipv6Addr&lt;/code&gt; 이&lt;/a&gt; , 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="760b8f1ec007bba813777fc9f56dd941c92b8841" translate="yes" xml:space="preserve">
          <source>This enum has four variants with different types:</source>
          <target state="translated">이 열거 형에는 유형이 다른 네 가지 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ced6caa3ad1703b55bcd5c2e59bf560b6691cb01" translate="yes" xml:space="preserve">
          <source>This enum has the same role as &lt;a href=&quot;../primitive.never&quot;&gt;the &lt;code&gt;!&lt;/code&gt; &amp;ldquo;never&amp;rdquo; type&lt;/a&gt;, which is unstable in this version of Rust. When &lt;code&gt;!&lt;/code&gt; is stabilized, we plan to make &lt;code&gt;Infallible&lt;/code&gt; a type alias to it:</source>
          <target state="translated">이 열거 형과 같은 역할이 &lt;a href=&quot;../primitive.never&quot;&gt;을 &lt;code&gt;!&lt;/code&gt; &lt;/a&gt;이 버전의 Rust에서는 불안정한 &quot;never&quot;type 입니다. 언제 &lt;code&gt;!&lt;/code&gt; &lt;code&gt;Infallible&lt;/code&gt; 을 유형 별명으로 만들 계획입니다 .</target>
        </trans-unit>
        <trans-unit id="6ee104c9c1676af30fcb1ff39c18e2ed9e455f59" translate="yes" xml:space="preserve">
          <source>This enum is returned from the &lt;code&gt;Generator::resume&lt;/code&gt; method and indicates the possible return values of a generator. Currently this corresponds to either a suspension point (&lt;code&gt;Yielded&lt;/code&gt;) or a termination point (&lt;code&gt;Complete&lt;/code&gt;).</source>
          <target state="translated">이 열거 형은 &lt;code&gt;Generator::resume&lt;/code&gt; 메소드 에서 리턴되며 생성기 의 가능한 리턴 값을 나타냅니다. 현재 이것은 일시 중단 지점 ( &lt;code&gt;Yielded&lt;/code&gt; ) 또는 종료 지점 ( &lt;code&gt;Complete&lt;/code&gt; )에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="b0fad9f14978736d5cc5f3492964033b9a38fd54" translate="yes" xml:space="preserve">
          <source>This enum represent one control message of variable type.</source>
          <target state="translated">이 열거 형은 변수 유형의 하나의 제어 메시지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1703fcf1fccea6643fefc20e49e4c80e84f95499" translate="yes" xml:space="preserve">
          <source>This enumeration is the list of possible errors that made &lt;a href=&quot;struct.receiver#method.recv_timeout&quot;&gt;&lt;code&gt;recv_timeout&lt;/code&gt;&lt;/a&gt; unable to return data when called. This can occur with both a &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 열거는 &lt;a href=&quot;struct.receiver#method.recv_timeout&quot;&gt; &lt;code&gt;recv_timeout&lt;/code&gt; 이&lt;/a&gt; 호출 될 때 데이터를 리턴 할 수 없게 만든 가능한 오류 목록입니다 . &lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt; 모두에서 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbe05c4f5a229c7e20d58b03f49460f0df3da02f" translate="yes" xml:space="preserve">
          <source>This enumeration is the list of the possible error outcomes for the &lt;a href=&quot;struct.syncsender#method.try_send&quot;&gt;&lt;code&gt;try_send&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 열거는 &lt;a href=&quot;struct.syncsender#method.try_send&quot;&gt; &lt;code&gt;try_send&lt;/code&gt; &lt;/a&gt; 메소드에 가능한 오류 결과 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="6dc63139830daa8f080f2bf636d153d6ed98ad21" translate="yes" xml:space="preserve">
          <source>This enumeration is the list of the possible reasons that &lt;a href=&quot;struct.receiver#method.try_recv&quot;&gt;&lt;code&gt;try_recv&lt;/code&gt;&lt;/a&gt; could not return data when called. This can occur with both a &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 열거는 &lt;a href=&quot;struct.receiver#method.try_recv&quot;&gt; &lt;code&gt;try_recv&lt;/code&gt; &lt;/a&gt; 가 호출 될 때 데이터를 리턴 할 수없는 가능한 이유의 목록입니다 . &lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt; 모두에서 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1093396faf4de8ad558d41dcf5187f56b3280a8" translate="yes" xml:space="preserve">
          <source>This error also frequently arises with iteration:</source>
          <target state="translated">이 오류는 반복과 함께 자주 발생합니다.</target>
        </trans-unit>
        <trans-unit id="94b9a993ad00befb67d90a954bbd93d2df863b1b" translate="yes" xml:space="preserve">
          <source>This error appears when the curly braces contain an identifier which doesn't match with any of the type parameters or the string &lt;code&gt;Self&lt;/code&gt;. This might happen if you misspelled a type parameter, or if you intended to use literal curly braces. If it is the latter, escape the curly braces with a second curly brace of the same type; e.g., a literal &lt;code&gt;{&lt;/code&gt; is &lt;code&gt;{{&lt;/code&gt;.</source>
          <target state="translated">이 오류는 중괄호에 형식 매개 변수 또는 문자열 &lt;code&gt;Self&lt;/code&gt; 와 일치하지 않는 식별자가 포함 된 경우에 나타납니다 . 유형 매개 변수의 철자가 틀리거나 리터럴 중괄호를 사용하려는 경우에 발생할 수 있습니다. 후자 인 경우 동일한 유형의 두 번째 중괄호를 사용하여 중괄호를 이스케이프 처리하십시오. 예를 들어 리터럴 &lt;code&gt;{&lt;/code&gt; 은 &lt;code&gt;{{&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="584182c12fbcdc7236283566d4fe892f8514a84a" translate="yes" xml:space="preserve">
          <source>This error appears when the curly braces do not contain an identifier. Please add one of the same name as a type parameter. If you intended to use literal braces, use &lt;code&gt;{{&lt;/code&gt; and &lt;code&gt;}}&lt;/code&gt; to escape them.</source>
          <target state="translated">중괄호에 식별자가없는 경우이 오류가 나타납니다. 유형 매개 변수와 동일한 이름 중 하나를 추가하십시오. 리터럴 괄호를 사용하려면 &lt;code&gt;{{&lt;/code&gt; 및 &lt;code&gt;}}&lt;/code&gt; 를 사용하여 괄호 를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="0250b09263b0cf211b3144438a4935e1e43d799a" translate="yes" xml:space="preserve">
          <source>This error can be fixed by changing &lt;code&gt;demo&lt;/code&gt; so that the destructor does not run while the string-data is borrowed; for example by taking &lt;code&gt;S&lt;/code&gt; by reference:</source>
          <target state="translated">문자열 데이터를 빌리는 동안 소멸자가 실행되지 않도록 &lt;code&gt;demo&lt;/code&gt; 를 변경 하여이 오류를 해결할 수 있습니다 . 예를 들어 &lt;code&gt;S&lt;/code&gt; 를 참조로 사용하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cf00137495add2df4af51c96509efb72f8de11bd" translate="yes" xml:space="preserve">
          <source>This error can be fixed by creating a reference to the fields of a struct, enum, or tuple using the &lt;code&gt;ref&lt;/code&gt; keyword:</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 키워드를 사용하여 구조체, 열거 형 또는 튜플의 필드에 대한 참조를 작성하면이 오류를 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0dff7bc132443224671e948d9ffe4c7e1624395f" translate="yes" xml:space="preserve">
          <source>This error can be fixed by fully reinitializing the structure in question:</source>
          <target state="translated">이 오류는 해당 구조를 완전히 다시 초기화하여 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c719c44866ac61477960cb8b276b7f76f8c6533" translate="yes" xml:space="preserve">
          <source>This error can be fixed by making the container mutable:</source>
          <target state="translated">이 오류는 컨테이너를 변경 가능하게 만들어 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="413b5d16e5f0759b900c5fe5dc8c6c4f80d50366" translate="yes" xml:space="preserve">
          <source>This error can be solved by adding type annotations that provide the missing information to the compiler. In this case, the solution is to use a concrete type:</source>
          <target state="translated">이 오류는 누락 된 정보를 컴파일러에 제공하는 유형 주석을 추가하여 해결할 수 있습니다. 이 경우 해결책은 구체적인 유형을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f0e10eb9c6b47c452a0e1f4fb8a082452a2d703" translate="yes" xml:space="preserve">
          <source>This error code indicates a mismatch between the lifetimes appearing in the function signature (i.e., the parameter types and the return type) and the data-flow found in the function body.</source>
          <target state="translated">이 오류 코드는 함수 시그니처 (예 : 매개 변수 유형 및 반환 유형)에 나타나는 수명과 함수 본문에있는 데이터 흐름이 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="21caa47590bc7c04cd88dfba7269f8c13368e7a3" translate="yes" xml:space="preserve">
          <source>This error generally appears when two items with the same name are imported into a module. Here, the &lt;code&gt;foo&lt;/code&gt; functions are imported and reexported from the &lt;code&gt;collider&lt;/code&gt; module and therefore, when we're using &lt;code&gt;collider::foo()&lt;/code&gt;, both functions collide.</source>
          <target state="translated">이 오류는 일반적으로 이름이 같은 두 항목을 모듈로 가져올 때 나타납니다. 여기서 &lt;code&gt;foo&lt;/code&gt; 함수는 &lt;code&gt;collider&lt;/code&gt; 모듈 에서 가져오고 다시 내보내 므로 &lt;code&gt;collider::foo()&lt;/code&gt; 하면 두 함수가 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="3dfae522bf711393bcf17e2c72e0d218bd40909c" translate="yes" xml:space="preserve">
          <source>This error indicates a type mismatch in closure arguments.</source>
          <target state="translated">이 오류는 클로저 인수의 유형 불일치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1f7e9e73655654d551ddbe67dfdca41396aade3d" translate="yes" xml:space="preserve">
          <source>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule concerns the use of type parameters in an implementation of a foreign trait (a trait defined in another crate), and states that type parameters must be &quot;covered&quot; by a local type.</source>
          <target state="translated">이 오류는 특성 구현에 대한 Rust의 고아 규칙 중 하나를 위반했음을 나타냅니다. 이 규칙은 외부 특성 (다른 크레이트에 정의 된 특성)의 구현에서 유형 매개 변수의 사용과 관련이 있으며 유형 매개 변수는 로컬 유형에 의해 &quot;덮여&quot;되어야한다고 명시합니다.</target>
        </trans-unit>
        <trans-unit id="5926fa6825473ce8b14051d29bff524913459d93" translate="yes" xml:space="preserve">
          <source>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule concerns the use of type parameters in an implementation of a foreign trait (a trait defined in another crate), and states that type parameters must be &quot;covered&quot; by a local type. To understand what this means, it is perhaps easiest to consider a few examples.</source>
          <target state="translated">이 오류는 특성 구현에 대한 Rust의 고아 규칙 중 하나를 위반했음을 나타냅니다. 이 규칙은 외래 특성 (다른 상자에 정의 된 특성)을 구현할 때 형식 매개 변수를 사용하는 것과 관련이 있으며 형식 매개 변수는 로컬 형식으로 &quot;덮어야&quot;합니다. 이것이 의미하는 바를 이해하려면 몇 가지 예를 고려하는 것이 가장 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="62c66f8f6d53d3993670c86c1f09308676282e5b" translate="yes" xml:space="preserve">
          <source>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule prohibits any implementation of a foreign trait (a trait defined in another crate) where</source>
          <target state="translated">이 오류는 특성 구현에 대한 Rust의 고아 규칙 중 하나를 위반했음을 나타냅니다. 이 규칙은 외국 특성 (다른 상자에 정의 된 특성)의 구현을 금지합니다.</target>
        </trans-unit>
        <trans-unit id="447a5e9fa4c8cf25c5cd5302f4311b3fbd33ec5e" translate="yes" xml:space="preserve">
          <source>This error indicates that a &lt;code&gt;#[lang = &quot;..&quot;]&lt;/code&gt; attribute was placed on the wrong type of item.</source>
          <target state="translated">이 오류는 &lt;code&gt;#[lang = &quot;..&quot;]&lt;/code&gt; 속성이 잘못된 유형의 항목에 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="04b6c6e07e059a0181ccbe377eeeabdfa436d081" translate="yes" xml:space="preserve">
          <source>This error indicates that a &lt;code&gt;#[non_exhaustive]&lt;/code&gt; attribute was incorrectly placed on something other than a struct or enum.</source>
          <target state="translated">이 오류는 &lt;code&gt;#[non_exhaustive]&lt;/code&gt; 속성이 구조체 나 열거 형 이외의 항목에 잘못 배치 되었음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="7022f431bbd32573cf9101aaa229f54136c6e815" translate="yes" xml:space="preserve">
          <source>This error indicates that a &lt;code&gt;#[repr(..)]&lt;/code&gt; attribute was placed on an unsupported item.</source>
          <target state="translated">이 오류는 &lt;code&gt;#[repr(..)]&lt;/code&gt; 속성이 지원되지 않는 항목에 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ca9d1588d95295137d9296e3cc73990ee881720a" translate="yes" xml:space="preserve">
          <source>This error indicates that a binary assignment operator like &lt;code&gt;+=&lt;/code&gt; or &lt;code&gt;^=&lt;/code&gt; was applied to a type that doesn't support it. For example:</source>
          <target state="translated">이 오류는 &lt;code&gt;+=&lt;/code&gt; 또는 &lt;code&gt;^=&lt;/code&gt; 와 같은 이진 대입 연산자 가 지원하지 않는 형식에 적용 되었음을 나타냅니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="942586ad68f246da14ea422c40de5e3f0b9face6" translate="yes" xml:space="preserve">
          <source>This error indicates that a incorrect visibility restriction was specified.</source>
          <target state="translated">이 오류는 잘못된 가시성 제한이 지정되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0ed5220e5bb81a5a254920c1211412f9ef92a217" translate="yes" xml:space="preserve">
          <source>This error indicates that a lifetime is missing from a type. If it is an error inside a function signature, the problem may be with failing to adhere to the lifetime elision rules (see below).</source>
          <target state="translated">이 오류는 유형에서 수명이 누락되었음을 나타냅니다. 함수 서명 내부에 오류가있는 경우 수명 제거 규칙을 준수하지 못하는 문제 일 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="163c07e3082230bfd9dd310e7a36d455707b90b1" translate="yes" xml:space="preserve">
          <source>This error indicates that a mutable variable is being used while it is still captured by a closure. Because the closure has borrowed the variable, it is not available for use until the closure goes out of scope.</source>
          <target state="translated">이 오류는 변수 변수가 클로저에 의해 여전히 캡처되는 동안 사용되고 있음을 나타냅니다. 클로저가 변수를 빌려 왔기 때문에 클로저가 범위를 벗어날 때까지 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f5aeaeedbb41e69e7d361beb7e7f664611c650d" translate="yes" xml:space="preserve">
          <source>This error indicates that a mutable variable is used while it is still captured by a closure. Because the closure has borrowed the variable, it is not available until the closure goes out of scope.</source>
          <target state="translated">이 오류는 클로저에 의해 캡처되는 동안 변경 가능한 변수가 사용됨을 나타냅니다. 클로저가 변수를 차용했기 때문에 클로저가 범위를 벗어날 때까지 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f276e617d109dc1e2831917bc3e9ec17e8a46ef1" translate="yes" xml:space="preserve">
          <source>This error indicates that a pattern for a struct fails to specify a sub-pattern for every one of the struct's fields. Ensure that each field from the struct's definition is mentioned in the pattern, or use &lt;code&gt;..&lt;/code&gt; to ignore unwanted fields.</source>
          <target state="translated">이 오류는 구조체의 패턴이 구조체의 모든 필드에 대해 하위 패턴을 지정하지 못했음을 나타냅니다. 구조체 정의의 각 필드가 패턴에 언급되어 있는지 확인하거나 &lt;code&gt;..&lt;/code&gt; 을 사용 하여 원하지 않는 필드를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="cf2673db078cb233aef2cf4d975d04209851d888" translate="yes" xml:space="preserve">
          <source>This error indicates that a pointer to a trait type cannot be implicitly dereferenced by a pattern. Every trait defines a type, but because the size of trait implementors isn't fixed, this type has no compile-time size. Therefore, all accesses to trait types must be through pointers. If you encounter this error you should try to avoid dereferencing the pointer.</source>
          <target state="translated">이 오류는 특성 유형에 대한 포인터를 패턴으로 내재적으로 역 참조 할 수 없음을 나타냅니다. 모든 특성은 유형을 정의하지만 특성 구현 자의 크기는 고정되어 있지 않기 때문에이 유형에는 컴파일 타임 크기가 없습니다. 따라서 형질 유형에 대한 모든 액세스는 포인터를 통해 이루어져야합니다. 이 오류가 발생하면 포인터 역 참조를 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="828017bc333a648d7ba2ba05b6d8defb66538498" translate="yes" xml:space="preserve">
          <source>This error indicates that a struct pattern attempted to extract a non-existent field from a struct. Struct fields are identified by the name used before the colon &lt;code&gt;:&lt;/code&gt; so struct patterns should resemble the declaration of the struct type being matched.</source>
          <target state="translated">이 오류는 구조체 패턴이 구조체에서 존재하지 않는 필드를 추출하려고 시도했음을 나타냅니다. 구조체 필드는 콜론 전에 사용 된 이름에 의해 식별됩니다 &lt;code&gt;:&lt;/code&gt; 구조체 패턴이 구조체 형식의 선언이 일치되고 유사합니다 그래서.</target>
        </trans-unit>
        <trans-unit id="8fe4ff510197fbaaaaa06c8b33b203c1e4dc7f1a" translate="yes" xml:space="preserve">
          <source>This error indicates that a temporary value is being dropped while a borrow is still in active use.</source>
          <target state="translated">이 오류는 대출이 여전히 사용중인 동안 임시 값이 삭제됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="29f636e2d8527491e9c968890f3142a6d2d79a49" translate="yes" xml:space="preserve">
          <source>This error indicates that a type or lifetime parameter has been declared but not actually used. Here is an example that demonstrates the error:</source>
          <target state="translated">이 오류는 유형 또는 수명 매개 변수가 선언되었지만 실제로 사용되지 않았 음을 나타냅니다. 다음은 오류를 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="021899c7481112f5b1115194dfebb6c6433d75e6" translate="yes" xml:space="preserve">
          <source>This error indicates that a variable usage inside an inner function is invalid because the variable comes from a dynamic environment. Inner functions do not have access to their containing environment.</source>
          <target state="translated">이 오류는 변수가 동적 환경에서 제공되므로 내부 함수 내부의 변수 사용법이 유효하지 않음을 나타냅니다. 내부 함수는 포함 환경에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ee2b7895f62fe245340d50c3f8c134d38d139ea0" translate="yes" xml:space="preserve">
          <source>This error indicates that an &lt;code&gt;#[inline(..)]&lt;/code&gt; attribute was incorrectly placed on something other than a function or method.</source>
          <target state="translated">이 오류는 &lt;code&gt;#[inline(..)]&lt;/code&gt; 속성이 함수 나 메소드 이외의 것에 잘못 배치 되었음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="b354ce81cf352c1f70206a250c5709ec2f51795d" translate="yes" xml:space="preserve">
          <source>This error indicates that an attempted implementation of a trait method has the wrong number of function parameters.</source>
          <target state="translated">이 오류는 특성 메소드의 구현 시도에 잘못된 수의 함수 매개 변수가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e0c31ba5c6bda555cd8ea81a836bf176c496c77b" translate="yes" xml:space="preserve">
          <source>This error indicates that an attempted implementation of a trait method has the wrong number of type or const parameters.</source>
          <target state="translated">이 오류는 특성 메소드의 구현 시도에 잘못된 유형 또는 const 매개 변수 수가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b75e5fdc31d31d1c4e71b1b39da466c4c14335c3" translate="yes" xml:space="preserve">
          <source>This error indicates that an empty match expression is invalid because the type it is matching on is non-empty (there exist values of this type). In safe code it is impossible to create an instance of an empty type, so empty match expressions are almost never desired. This error is typically fixed by adding one or more cases to the match expression.</source>
          <target state="translated">이 오류는 일치하는 유형이 비어 있지 않기 때문에 빈 일치 표현식이 유효하지 않음을 나타냅니다 (이 유형의 값이 있음). 안전한 코드에서는 빈 형식의 인스턴스를 만드는 것이 불가능하므로 빈 일치 식은 거의 필요하지 않습니다. 이 오류는 일반적으로 하나 이상의 사례를 일치 표현식에 추가하여 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="aa5d0ed3544dd02116d741311bf5dc31cbf1e877" translate="yes" xml:space="preserve">
          <source>This error indicates that during an attempt to build a struct or struct-like enum variant, one of the fields was not provided. Erroneous code example:</source>
          <target state="translated">이 오류는 구조체 또는 구조체와 유사한 열거 형 변형을 작성하려고 시도하는 동안 필드 중 하나가 제공되지 않았 음을 나타냅니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="4fe613edd2e0d9ed1781cdd172cb95fcc86dda95" translate="yes" xml:space="preserve">
          <source>This error indicates that during an attempt to build a struct or struct-like enum variant, one of the fields was specified more than once. Each field should be specified exactly one time. Example:</source>
          <target state="translated">이 오류는 구조체 또는 구조체와 유사한 열거 형 변형을 빌드하는 동안 필드 중 하나가 두 번 이상 지정되었음을 나타냅니다. 각 필드는 정확히 한 번 지정해야합니다. 예:</target>
        </trans-unit>
        <trans-unit id="3e8ed17cc79bcd070351fc2c779882f025c94d0d" translate="yes" xml:space="preserve">
          <source>This error indicates that during an attempt to build a struct or struct-like enum variant, one of the fields was specified more than once. Erroneous code example:</source>
          <target state="translated">이 오류는 구조체 또는 구조체와 같은 열거 형 변형을 작성하는 중에 필드 중 하나가 두 번 이상 지정되었음을 나타냅니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="184a0c9f21c2159367397ab03b1af11810a4b7a9" translate="yes" xml:space="preserve">
          <source>This error indicates that next we need to create an associated function named &lt;code&gt;new&lt;/code&gt; for &lt;code&gt;ThreadPool&lt;/code&gt;. We also know that &lt;code&gt;new&lt;/code&gt; needs to have one parameter that can accept &lt;code&gt;4&lt;/code&gt; as an argument and should return a &lt;code&gt;ThreadPool&lt;/code&gt; instance. Let&amp;rsquo;s implement the simplest &lt;code&gt;new&lt;/code&gt; function that will have those characteristics:</source>
          <target state="translated">이 오류는 다음 에 &lt;code&gt;ThreadPool&lt;/code&gt; 에 대해 &lt;code&gt;new&lt;/code&gt; 라는 관련 함수를 작성해야 함을 나타냅니다 . 또한 &lt;code&gt;new&lt;/code&gt; 에는 인수로 &lt;code&gt;4&lt;/code&gt; 를 허용 하고 &lt;code&gt;ThreadPool&lt;/code&gt; 인스턴스를 반환 해야하는 하나의 매개 변수가 있어야한다는 것도 알고 있습니다 . 이러한 특성을 가진 가장 간단한 &lt;code&gt;new&lt;/code&gt; 기능을 구현해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="2dad13e650883f25d2104ae52eca1fef407497bf" translate="yes" xml:space="preserve">
          <source>This error indicates that not enough type parameters were found in a type or trait.</source>
          <target state="translated">이 오류는 유형 또는 특성에서 유형 매개 변수가 충분하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ca21a72c98d3df2023442d374a3dadbb098c691b" translate="yes" xml:space="preserve">
          <source>This error indicates that some types or traits depend on each other and therefore cannot be constructed.</source>
          <target state="translated">이 오류는 일부 유형 또는 특성이 서로 종속되어 구성 할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="04671a501f0a2d188e9fcc11f1a02fbc634b9fe6" translate="yes" xml:space="preserve">
          <source>This error indicates that the bindings in a match arm would require a value to be moved into more than one location, thus violating unique ownership. Code like the following is invalid as it requires the entire &lt;code&gt;Option&amp;lt;String&amp;gt;&lt;/code&gt; to be moved into a variable called &lt;code&gt;op_string&lt;/code&gt; while simultaneously requiring the inner &lt;code&gt;String&lt;/code&gt; to be moved into a variable called &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">이 오류는 일치 암의 바인딩이 하나 이상의 위치로 값을 이동해야하므로 고유 소유권을 위반 함을 나타냅니다. 다음과 같은 코드는 전체 &lt;code&gt;Option&amp;lt;String&amp;gt;&lt;/code&gt; 을 &lt;code&gt;op_string&lt;/code&gt; 이라는 변수로 이동 해야하는 동시에 내부 &lt;code&gt;String&lt;/code&gt; 을 &lt;code&gt;s&lt;/code&gt; 라는 변수로 이동 해야하므로 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0593569b391769294fc0cbd6c435421f4f05566e" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler cannot guarantee a matching pattern for one or more possible inputs to a match expression. Guaranteed matches are required in order to assign values to match expressions, or alternatively, determine the flow of execution.</source>
          <target state="translated">이 오류는 컴파일러가 일치 식에 대한 하나 이상의 가능한 입력에 대해 일치 패턴을 보장 할 수 없음을 나타냅니다. 식과 일치하는 값을 할당하거나 실행 흐름을 결정하려면 보장 된 일치가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e6ec80fb058ca19fb5e7892d541e007d08b04d8f" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler cannot guarantee a matching pattern for one or more possible inputs to a match expression. Guaranteed matches are required in order to assign values to match expressions, or alternatively, determine the flow of execution. Erroneous code example:</source>
          <target state="translated">이 오류는 컴파일러가 일치 표현식에 대한 하나 이상의 가능한 입력에 대한 일치 패턴을 보장 할 수 없음을 나타냅니다. 표현식과 일치하는 값을 할당하거나 실행 흐름을 결정하려면 보장 된 일치가 필요합니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="561856cda5e25152013aec070f3d54bab7aa1df8" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler found multiple functions with the &lt;code&gt;#[main]&lt;/code&gt; attribute. This is an error because there must be a unique entry point into a Rust program. Example:</source>
          <target state="translated">이 오류는 컴파일러가 &lt;code&gt;#[main]&lt;/code&gt; 속성을 가진 여러 함수를 찾았 음을 나타냅니다 . Rust 프로그램에 고유 한 진입 점이 있어야하기 때문에 이는 오류입니다. 예:</target>
        </trans-unit>
        <trans-unit id="5bea3375dcc80f531e3766516bd9f6d7115c2ccf" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler found multiple functions with the &lt;code&gt;#[start]&lt;/code&gt; attribute. This is an error because there must be a unique entry point into a Rust program. Example:</source>
          <target state="translated">이 오류는 컴파일러가 &lt;code&gt;#[start]&lt;/code&gt; 속성을 가진 여러 함수를 찾았 음을 나타냅니다 . Rust 프로그램에 고유 한 진입 점이 있어야하기 때문에 이는 오류입니다. 예:</target>
        </trans-unit>
        <trans-unit id="8f30ae6ab3b3757a6fafd59d7ba821bfd1db82b1" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler was unable to sensibly evaluate a constant expression that had to be evaluated. Attempting to divide by 0 or causing an integer overflow are two ways to induce this error.</source>
          <target state="translated">이 오류는 컴파일러가 평가해야하는 상수 식을 현명하게 평가할 수 없음을 나타냅니다. 0으로 나누거나 정수 오버플로를 유발하는 것은이 오류를 유발하는 두 가지 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f36d8b8d1d8446198729b807cb2a4a2419af004e" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler was unable to sensibly evaluate an constant expression that had to be evaluated. Attempting to divide by 0 or causing integer overflow are two ways to induce this error. For example:</source>
          <target state="translated">이 오류는 컴파일러가 평가해야하는 상수 표현식을 현명하게 평가할 수 없음을 나타냅니다. 0으로 나누거나 정수 오버플로를 발생시키는 것은이 오류를 유발하는 두 가지 방법입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6a1e2255560b86b2d9499ff55662d827b519b332" translate="yes" xml:space="preserve">
          <source>This error indicates that the numeric value for the method being passed exists but the type of the numeric value or binding could not be identified.</source>
          <target state="translated">이 오류는 전달중인 메소드의 숫자 값이 존재하지만 숫자 값 또는 바인딩 유형을 식별 할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="148347b598d68fa69c31f92c37c1da55d76c0063" translate="yes" xml:space="preserve">
          <source>This error indicates that the struct, enum or enum variant cannot be instantiated from outside of the defining crate as it has been marked as &lt;code&gt;non_exhaustive&lt;/code&gt; and as such more fields/variants may be added in future that could cause adverse side effects for this code.</source>
          <target state="translated">이 오류는 struct, enum 또는 enum 변형이 정의되지 않은 크레이트 외부에서 인스턴스화 할 수 없음을 나타냅니다. 이는 비 &lt;code&gt;non_exhaustive&lt;/code&gt; 이라고 표시되어 향후이 코드에 부작용을 일으킬 수있는 더 많은 필드 / 변형이 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcad2c51ea5b37a57bae2601eed616fe3e726b2e" translate="yes" xml:space="preserve">
          <source>This error indicates that the struct, enum or enum variant must be matched non-exhaustively as it has been marked as &lt;code&gt;non_exhaustive&lt;/code&gt;.</source>
          <target state="translated">이 오류는 구조체, 열거 형 또는 열거 형 변형이 &lt;code&gt;non_exhaustive&lt;/code&gt; 로 표시 되었으므로 전체적으로 일치하지 않아야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="37c7a2a28ca533246457e808e16c999f3f050492" translate="yes" xml:space="preserve">
          <source>This error indicates that there is a mismatch between generic parameters and impl Trait parameters in a trait declaration versus its impl.</source>
          <target state="translated">이 오류는 특성 선언에서 일반 매개 변수와 impl 특성 매개 변수와 해당 impl간에 불일치가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="51a28020fb3170ca33d27d23beb6ff4c2ae9ce5c" translate="yes" xml:space="preserve">
          <source>This error indicates that too many type parameters were found in a type or trait.</source>
          <target state="translated">이 오류는 유형 또는 특성에서 너무 많은 유형 매개 변수가 발견되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="52a40c02e70b32e434b6bbe135867f805601219b" translate="yes" xml:space="preserve">
          <source>This error indicates that type inference did not result in one unique possible type, and extra information is required. In most cases this can be provided by adding a type annotation. Sometimes you need to specify a generic type parameter manually.</source>
          <target state="translated">이 오류는 형식 유추로 인해 하나의 고유 한 형식이 만들어지지 않았으며 추가 정보가 필요함을 나타냅니다. 대부분의 경우 유형 주석을 추가하여 제공 할 수 있습니다. 때로는 일반 유형 매개 변수를 수동으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4c3b94702358e1162bf8effa04b8b4b7e098714c" translate="yes" xml:space="preserve">
          <source>This error indicates that you are trying to borrow a variable as mutable when it has already been borrowed as immutable.</source>
          <target state="translated">이 오류는 변수가 이미 변경 불가능한 것으로 빌려 졌을 때 변수를 변경 가능으로 빌리려고 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5d266dd2a168d28b90102ea5f40d828bae3909b4" translate="yes" xml:space="preserve">
          <source>This error indicates the use of a loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) inside a closure but outside of any loop. Erroneous code example:</source>
          <target state="translated">이 오류는 클로저 내부에서 루프 외부 에서 루프 키워드 ( &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;continue&lt;/code&gt; )를 사용함을 나타냅니다 . 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="a14d78d3da966b89fe122674705e062ddb4c4c41" translate="yes" xml:space="preserve">
          <source>This error indicates the use of a loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) outside of a loop. Without a loop to break out of or continue in, no sensible action can be taken. Erroneous code example:</source>
          <target state="translated">이 오류는 루프 외부 에서 루프 키워드 ( &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;continue&lt;/code&gt; )를 사용함을 나타냅니다 . 루프가 끊어 지거나 계속 진행되지 않으면 현명한 조치를 취할 수 없습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="50520313e8b1d1b1c6569c98ff40cb57f7812069" translate="yes" xml:space="preserve">
          <source>This error is created by the &lt;a href=&quot;struct.cstr#method.from_bytes_with_nul&quot;&gt;&lt;code&gt;CStr::from_bytes_with_nul&lt;/code&gt;&lt;/a&gt; method. See its documentation for more.</source>
          <target state="translated">이 오류는 &lt;a href=&quot;struct.cstr#method.from_bytes_with_nul&quot;&gt; &lt;code&gt;CStr::from_bytes_with_nul&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1b9e91e9541342a47e9d0b1ac521444fa8e68a88" translate="yes" xml:space="preserve">
          <source>This error is created by the &lt;a href=&quot;struct.cstr#method.from_bytes_with_nul&quot;&gt;&lt;code&gt;from_bytes_with_nul&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 오류는 &lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.cstr#method.from_bytes_with_nul&quot;&gt; &lt;code&gt;from_bytes_with_nul&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bbb5b15b9e8658856b49fb418cbe7dfc72c8452a" translate="yes" xml:space="preserve">
          <source>This error is created by the &lt;a href=&quot;struct.cstring#method.from_vec_with_nul&quot;&gt;&lt;code&gt;CString::from_vec_with_nul&lt;/code&gt;&lt;/a&gt; method. See its documentation for more.</source>
          <target state="translated">이 오류는 &lt;a href=&quot;struct.cstring#method.from_vec_with_nul&quot;&gt; &lt;code&gt;CString::from_vec_with_nul&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7f88231c82f77383d008a182af5374b0e8d20578" translate="yes" xml:space="preserve">
          <source>This error is created by the &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 에러는 &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.cstring#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e66887716e5bc2fbc972f3ffc3450120cd6c7b7e" translate="yes" xml:space="preserve">
          <source>This error is fairly cryptic because the problem is fairly cryptic. To call a &lt;code&gt;FnOnce&lt;/code&gt; closure that is stored in a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; (which is what our &lt;code&gt;Job&lt;/code&gt; type alias is), the closure needs to move itself &lt;em&gt;out&lt;/em&gt; of the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; because the closure takes ownership of &lt;code&gt;self&lt;/code&gt; when we call it. In general, Rust doesn&amp;rsquo;t allow us to move a value out of a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; because Rust doesn&amp;rsquo;t know how big the value inside the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; will be: recall in Chapter 15 that we used &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; precisely because we had something of an unknown size that we wanted to store in a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to get a value of a known size.</source>
          <target state="translated">이 오류는 문제가 상당히 복잡하기 때문에 상당히 복잡합니다. 통화에 &lt;code&gt;FnOnce&lt;/code&gt; 의 (A)에 저장되어있는 폐쇄 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; (우리의 것입니다 &lt;code&gt;Job&lt;/code&gt; 유형의 별칭입니다), 폐쇄 요구 자체를 이동 &lt;em&gt;밖으로&lt;/em&gt; 의 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 폐쇄가의 소유권을하기 때문에 &lt;code&gt;self&lt;/code&gt; 우리가 그것을 호출 할 때. 일반적으로, 녹 우리가 밖으로 값을 이동하는 것을 허용하지 않습니다 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 녹 알고하지 않기 때문에 얼마나 큰 내부 값 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 될 것입니다 장 : 우리가 사용했던 15 리콜 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 정확히 알려지지 않은 크기의 무언가가 있었기 때문에 알려진 크기의 값을 얻기 위해 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 에 저장하려고했습니다 .</target>
        </trans-unit>
        <trans-unit id="ac1c7bfe67c403881a0d5e5220daf766f18ab15b" translate="yes" xml:space="preserve">
          <source>This error is used as the error type for the &lt;a href=&quot;../str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; implementation for &lt;a href=&quot;../primitive.f32&quot;&gt;&lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 오류는 대한 오류 유형으로 사용되는 &lt;a href=&quot;../str/trait.fromstr&quot;&gt; &lt;code&gt;FromStr&lt;/code&gt; 에&lt;/a&gt; 대한 구현 &lt;a href=&quot;../primitive.f32&quot;&gt; &lt;code&gt;f32&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a413bd30b0780353f6f0cb9ec7112a60510b4c1b" translate="yes" xml:space="preserve">
          <source>This error is used as the error type for the &lt;a href=&quot;../str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; implementation for &lt;a href=&quot;enum.ipaddr&quot;&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.ipv4addr&quot;&gt;&lt;code&gt;Ipv4Addr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.ipv6addr&quot;&gt;&lt;code&gt;Ipv6Addr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.socketaddrv4&quot;&gt;&lt;code&gt;SocketAddrV4&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.socketaddrv6&quot;&gt;&lt;code&gt;SocketAddrV6&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 오류는 &lt;a href=&quot;enum.ipaddr&quot;&gt; &lt;code&gt;IpAddr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.ipv4addr&quot;&gt; &lt;code&gt;Ipv4Addr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.ipv6addr&quot;&gt; &lt;code&gt;Ipv6Addr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.socketaddrv4&quot;&gt; &lt;code&gt;SocketAddrV4&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.socketaddrv6&quot;&gt; &lt;code&gt;SocketAddrV6&lt;/code&gt; &lt;/a&gt; 에 대한 &lt;a href=&quot;../str/trait.fromstr&quot;&gt; &lt;code&gt;FromStr&lt;/code&gt; &lt;/a&gt; 구현 의 오류 유형으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="dbd5a817ebd0158354fc9b6704f3a0f2b0fc517f" translate="yes" xml:space="preserve">
          <source>This error is used as the error type for the &lt;code&gt;from_str_radix()&lt;/code&gt; functions on the primitive integer types, such as &lt;a href=&quot;../primitive.i8#method.from_str_radix&quot;&gt;&lt;code&gt;i8::from_str_radix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 오류는 기본 정수 유형 (예 : &lt;a href=&quot;../primitive.i8#method.from_str_radix&quot;&gt; &lt;code&gt;i8::from_str_radix&lt;/code&gt; &lt;/a&gt; &lt;code&gt;from_str_radix()&lt;/code&gt; 에서 from_str_radix () 함수 의 오류 유형으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="022d759f57798a79780636ae9f03f6fedf32312c" translate="yes" xml:space="preserve">
          <source>This error lets us know that either we&amp;rsquo;re passing something to &lt;code&gt;Screen&lt;/code&gt; we didn&amp;rsquo;t mean to pass and we should pass a different type or we should implement &lt;code&gt;Draw&lt;/code&gt; on &lt;code&gt;String&lt;/code&gt; so that &lt;code&gt;Screen&lt;/code&gt; is able to call &lt;code&gt;draw&lt;/code&gt; on it.</source>
          <target state="translated">이 오류는 우리가 하나 우리가 무언가를 전달하는 것을 알 수 있습니다 &lt;code&gt;Screen&lt;/code&gt; 우리가 전달하는 의미하지 않았다 우리는 다른 종류의를 통과해야 또는 우리가 구현해야 &lt;code&gt;Draw&lt;/code&gt; 에 &lt;code&gt;String&lt;/code&gt; 있도록 &lt;code&gt;Screen&lt;/code&gt; 호출 할 수있다 &lt;code&gt;draw&lt;/code&gt; 그 위에.</target>
        </trans-unit>
        <trans-unit id="7089a49860a1eeefd308980067bc3b5e6f3e5841" translate="yes" xml:space="preserve">
          <source>This error lets you know that Rust has this constant defined more precisely and that your program would be more correct if you used the constant instead. You would then change your code to use the &lt;code&gt;PI&lt;/code&gt; constant. The following code doesn&amp;rsquo;t result in any errors or warnings from Clippy:</source>
          <target state="translated">이 오류는 Rust가이 상수를보다 정확하게 정의했으며 상수를 대신 사용하면 프로그램이 더 정확하다는 것을 알려줍니다. 그런 다음 &lt;code&gt;PI&lt;/code&gt; 상수 를 사용하도록 코드를 변경합니다 . 다음 코드는 Clippy에서 오류나 경고를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7527f99b3dbab9d3281da26cc0de240205ca3ed7" translate="yes" xml:space="preserve">
          <source>This error may also commonly be found when working with unsafe code. For example, when using raw pointers one may wish to specify the lifetime for which the pointed-at data is valid. An initial attempt (below) causes this error:</source>
          <target state="translated">안전하지 않은 코드로 작업 할 때이 오류가 일반적으로 발견 될 수 있습니다. 예를 들어, 원시 포인터를 사용할 때 지정된 데이터가 유효한 수명을 지정할 수 있습니다. 초기 시도 (아래)는이 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="1e7204b5ea49e32896ab0ba12a29a6e3937bc0f3" translate="yes" xml:space="preserve">
          <source>This error means that an attempt was made to match a struct type enum variant as a non-struct type:</source>
          <target state="translated">이 오류는 구조체 형식 열거 형 변형을 구조체 이외의 형식으로 일치 시키려고 시도했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="76d97f884e0ba6f5c3488397207d55a3b212ce21" translate="yes" xml:space="preserve">
          <source>This error means that an attempt was made to match something which is neither a tuple struct nor a tuple variant. Only these two elements are allowed as a pattern:</source>
          <target state="translated">이 오류는 튜플 구조체도 아니고 튜플 변형도 아닌 것을 일치 시키려고 시도했음을 의미합니다. 다음 두 요소 만 패턴으로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c1988ee636e2a4d68092372fb6c89de2473339d3" translate="yes" xml:space="preserve">
          <source>This error means that an incorrect number of generic arguments were provided:</source>
          <target state="translated">이 오류는 잘못된 수의 일반 인수가 제공되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="368e8d1bf22974707354d4d21e3f6ab34ed1757e" translate="yes" xml:space="preserve">
          <source>This error means you can&amp;rsquo;t use this trait as a trait object in this way. If you&amp;rsquo;re interested in more details on object safety, see &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;Rust RFC 255&lt;/a&gt;.</source>
          <target state="translated">이 오류는이 특성을 이런 방식으로 특성 오브젝트로 사용할 수 없음을 의미합니다. 객체 안전에 대한 자세한 내용은 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;Rust RFC 255를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="027a2fdf6a3f9948a9c92b0f1c99c26f859c6929" translate="yes" xml:space="preserve">
          <source>This error message refers to a feature we haven&amp;rsquo;t covered yet: lifetimes. We&amp;rsquo;ll discuss lifetimes in detail in Chapter 10. But, if you disregard the parts about lifetimes, the message does contain the key to why this code is a problem:</source>
          <target state="translated">이 오류 메시지는 아직 다루지 않은 기능인 수명을 나타냅니다. 수명에 대해서는 10 장에서 자세히 설명 할 것입니다. 그러나 수명에 대한 부분을 무시하면이 코드가 왜 문제가 되는가에 대한 메시지가 메시지에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b934f7e266f094b4b999e8bf2f04c71dea6d6829" translate="yes" xml:space="preserve">
          <source>This error message states that we&amp;rsquo;re not allowed to explicitly call &lt;code&gt;drop&lt;/code&gt;. The error message uses the term &lt;em&gt;destructor&lt;/em&gt;, which is the general programming term for a function that cleans up an instance. A &lt;em&gt;destructor&lt;/em&gt; is analogous to a &lt;em&gt;constructor&lt;/em&gt;, which creates an instance. The &lt;code&gt;drop&lt;/code&gt; function in Rust is one particular destructor.</source>
          <target state="translated">이 오류 메시지는 &lt;code&gt;drop&lt;/code&gt; 호출을 명시 적으로 호출 할 수 없음을 나타 냅니다. 오류 메시지에는 &lt;em&gt;소멸 자라는&lt;/em&gt; 용어가 사용 되는데, 이는 인스턴스를 정리하는 함수의 일반적인 프로그래밍 용어입니다. &lt;em&gt;소멸자&lt;/em&gt; A와 유사 &lt;em&gt;생성자&lt;/em&gt; 인스턴스를 생성한다. Rust 의 &lt;code&gt;drop&lt;/code&gt; 함수는 특정 소멸자입니다.</target>
        </trans-unit>
        <trans-unit id="2c2b32b5586db42f3b0dff4da46b1782d86e698e" translate="yes" xml:space="preserve">
          <source>This error occurs because a borrow in a generator persists across a yield point.</source>
          <target state="translated">이 오류는 생성기의 차용이 항복점에 걸쳐 지속되기 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1e6bf835d8f1dd37c8b25ebb4f51cc6621c79aa9" translate="yes" xml:space="preserve">
          <source>This error occurs because a borrow of a thread-local variable was made inside a function which outlived the lifetime of the function.</source>
          <target state="translated">이 오류는 함수의 수명보다 오래 지속되는 함수 내에서 스레드 로컬 변수를 빌려 왔기 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="249f7bc8f6d82a80564f1c3f396aa42dbc6e451f" translate="yes" xml:space="preserve">
          <source>This error occurs because a value was dropped while it was still borrowed</source>
          <target state="translated">이 오류는 여전히 빌린 동안 값이 삭제 되었기 때문에 발생합니다</target>
        </trans-unit>
        <trans-unit id="074bebec9bc1d161aacdccb6e09fa091949d4c0d" translate="yes" xml:space="preserve">
          <source>This error occurs because you tried to mutably borrow a non-mutable variable.</source>
          <target state="translated">이 오류는 변경 불가능한 변수를 변경 가능하게 차용하려고했기 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1c3db0f8ef7d737dfd4c2dc90ac02bc9a5c77f3f" translate="yes" xml:space="preserve">
          <source>This error occurs when a bound in an implementation of a trait does not match the bounds specified in the original trait. For example:</source>
          <target state="translated">이 오류는 특성 구현에서 바운드가 원래 특성에 지정된 범위와 일치하지 않을 때 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="093dfc68eae74dcc328a7c8a1a3d68f0b36d7fb4" translate="yes" xml:space="preserve">
          <source>This error occurs when a method is used on a type which doesn't implement it:</source>
          <target state="translated">이 오류는 메소드를 구현하지 않는 유형에서 메소드를 사용할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="da941b6947e460e43f6112767122feb782f16207" translate="yes" xml:space="preserve">
          <source>This error occurs when an &lt;code&gt;if&lt;/code&gt; expression without an &lt;code&gt;else&lt;/code&gt; block is used in a context where a type other than &lt;code&gt;()&lt;/code&gt; is expected, for example a &lt;code&gt;let&lt;/code&gt; expression:</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt; 블록이 없는 &lt;code&gt;if&lt;/code&gt; 표현식 이 &lt;code&gt;()&lt;/code&gt; 이외의 유형 ( 예 : &lt;code&gt;let&lt;/code&gt; ) 이 필요한 컨텍스트에서 사용될 경우이 오류가 발생합니다. : 표현식 .</target>
        </trans-unit>
        <trans-unit id="5a28a2c48baba84d59c80917ee2d999515b5d378" translate="yes" xml:space="preserve">
          <source>This error occurs when an &lt;code&gt;if&lt;/code&gt; expression without an &lt;code&gt;else&lt;/code&gt; block is used in a context where a type other than &lt;code&gt;()&lt;/code&gt; is expected. In the previous code example, the &lt;code&gt;let&lt;/code&gt; expression was expecting a value but since there was no &lt;code&gt;else&lt;/code&gt;, no value was returned.</source>
          <target state="translated">이 오류 는 &lt;code&gt;else&lt;/code&gt; 블록이 없는 &lt;code&gt;if&lt;/code&gt; 표현식 이 &lt;code&gt;()&lt;/code&gt; 이외의 유형 이 예상되는 컨텍스트에서 사용될 때 발생합니다 . 이전 코드 예제에서 &lt;code&gt;let&lt;/code&gt; 식은 값을 예상했지만 &lt;code&gt;else&lt;/code&gt; 값이 없기 때문에 값이 반환되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d0370ddda8b1bb558216506bbbbafb414b273904" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to assign to a borrowed value.</source>
          <target state="translated">이 오류는 빌린 값에 할당하려고 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="81568110c66c811e652efe84f4e84d35ccd0ca5f" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to borrow state past the end of the lifetime of a type that implements the &lt;code&gt;Drop&lt;/code&gt; trait.</source>
          <target state="translated">이 오류는 &lt;code&gt;Drop&lt;/code&gt; 을 구현하는 형식의 수명이 끝났을 때 상태를 차용하려고 할 때 발생합니다. 특성 특성 .</target>
        </trans-unit>
        <trans-unit id="552e357ec5f4118a4e87577f4bd866d88ddeba4b" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to move a borrowed variable into a closure.</source>
          <target state="translated">이 오류는 빌린 변수를 클로저로 이동하려고 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="08dbd4d1c622d91c2a3b2e7680f087d95c0c0ad4" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to move out of a value whose type implements the &lt;code&gt;Drop&lt;/code&gt; trait.</source>
          <target state="translated">이 오류는 유형이 &lt;code&gt;Drop&lt;/code&gt; 을 구현하는 값에서 벗어나려고 할 때 발생합니다. 특성을 .</target>
        </trans-unit>
        <trans-unit id="a382ee4f257c1e4d223e9634a0678761229064a5" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to mutate or mutably reference data that a closure has captured immutably.</source>
          <target state="translated">이 오류는 클로저가 변경되지 않게 캡처 한 데이터를 변경하거나 참조하는 데이터를 변경하려고 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b0cd32a89f254835e1067e05e21bdf36f5041728" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to mutate or mutably reference data that a closure has captured immutably. Examples of this error are shown below:</source>
          <target state="translated">이 오류는 클로저가 변경 불가능하게 캡처 한 데이터를 변경하거나 변경 가능하게 참조하려고 할 때 발생합니다. 이 오류의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6dbb4812461df19f2be9097a66c157fbdbf8c85f" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to mutate the target of a mutable reference stored inside an immutable container.</source>
          <target state="translated">이 오류는 변경 불가능한 컨테이너 내부에 저장된 변경 가능한 참조의 대상을 변경하려고 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e494d266acb1b46fd28c9cc0c8ca718e819da16c" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to partially reinitialize a structure that is currently uninitialized.</source>
          <target state="translated">이 오류는 현재 초기화되지 않은 구조를 부분적으로 다시 초기화하려고 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8feee21757ea4763c54c8d19077d7ff7e0dd5208" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to reassign an immutable variable. For example:</source>
          <target state="translated">이 오류는 불변 변수를 재 할당하려고 할 때 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b105f193c377f1f9fe2f520a0094f3220a7d20d3" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to use a variable after its contents have been moved elsewhere. For example:</source>
          <target state="translated">이 오류는 변수 내용을 다른 곳으로 옮긴 후 변수를 사용하려고 할 때 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7658c866cb10684f9a43de713daa72ba91346907" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to use data captured by a closure, when that data may no longer exist. It's most commonly seen when attempting to return a closure as shown in the previous code example.</source>
          <target state="translated">이 오류는 해당 데이터가 더 이상 존재하지 않을 수있는 클로저에 의해 캡처 된 데이터를 사용하려고 할 때 발생합니다. 이전 코드 예제와 같이 클로저를 반환하려고 할 때 가장 일반적으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="47a25aa9b1a97609269b45b233bf81af91519446" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to use data captured by a closure, when that data may no longer exist. It's most commonly seen when attempting to return a closure:</source>
          <target state="translated">이 오류는 해당 데이터가 더 이상 존재하지 않을 때 클로저로 캡처 한 데이터를 사용하려고 할 때 발생합니다. 클로저를 반환하려고 할 때 가장 일반적으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="25b45e0aeb2d0b344f458087fd222c2b9143243a" translate="yes" xml:space="preserve">
          <source>This error occurs when an expression was used in a place where the compiler expected an expression of a different type. It can occur in several cases, the most common being when calling a function and passing an argument which has a different type than the matching type in the function declaration.</source>
          <target state="translated">이 오류는 컴파일러가 다른 형식의 식을 예상 한 곳에서식이 사용 된 경우 발생합니다. 여러 경우에 발생할 수 있습니다. 가장 일반적인 경우는 함수를 호출하고 함수 선언에서 일치하는 유형과 다른 유형을 가진 인수를 전달할 때입니다.</target>
        </trans-unit>
        <trans-unit id="fa2c4bec036eb23e59f4739f281ec16e241dd98a" translate="yes" xml:space="preserve">
          <source>This error occurs when the compiler doesn't have enough information to unambiguously choose an implementation.</source>
          <target state="translated">이 오류는 컴파일러에 구현을 명확하게 선택할 수있는 충분한 정보가 없을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b03f07ba71f847bb7aaff9d23af91941f61b2264" translate="yes" xml:space="preserve">
          <source>This error occurs when the compiler is unable to infer the concrete type of a variable. It can occur in several cases, the most common being a mismatch between two types: the type the author explicitly assigned, and the type the compiler inferred.</source>
          <target state="translated">이 오류는 컴파일러가 변수의 구체적인 유형을 추론 할 수 없을 때 발생합니다. 여러 경우에 발생할 수 있습니다. 가장 일반적인 경우는 작성자가 명시 적으로 할당 한 유형과 컴파일러가 유추 한 유형 간의 불일치입니다.</target>
        </trans-unit>
        <trans-unit id="f68d6da4cba1c2fe73a0bdd6ed998a8c685d2f7a" translate="yes" xml:space="preserve">
          <source>This error occurs when the compiler is unable to unambiguously infer the return type of a function or method which is generic on return type, such as the &lt;code&gt;collect&lt;/code&gt; method for &lt;code&gt;Iterator&lt;/code&gt;s.</source>
          <target state="translated">이 오류는 컴파일러가 &lt;code&gt;Iterator&lt;/code&gt; 의 &lt;code&gt;collect&lt;/code&gt; 메소드 와 같이 리턴 유형에 일반적인 함수 또는 메소드의 리턴 유형을 명확하게 유추 할 수없는 경우 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="f8852702dc84baa326e19b865b76e83190126314" translate="yes" xml:space="preserve">
          <source>This error occurs when the compiler was unable to infer the concrete type of a variable. It can occur for several cases, the most common of which is a mismatch in the expected type that the compiler inferred for a variable's initializing expression, and the actual type explicitly assigned to the variable.</source>
          <target state="translated">이 오류는 컴파일러가 구체적인 유형의 변수를 유추 할 수 없을 때 발생합니다. 여러 경우에 발생할 수 있는데, 그 중 가장 일반적인 것은 컴파일러가 변수의 초기화 표현식에 대해 유추 한 예상 유형과 변수에 명시 적으로 지정된 실제 유형이 일치하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="40572c6042150247d80f8e73ff85712050d543de" translate="yes" xml:space="preserve">
          <source>This error occurs when there was a recursive trait requirement that overflowed before it could be evaluated. Often this means that there is unbounded recursion in resolving some type bounds.</source>
          <target state="translated">이 오류는 재귀 특성 요구 사항이 평가되기 전에 오버플로 된 경우에 발생합니다. 이것은 종종 일부 유형 범위를 해결하는 데 무한 재귀가 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4c98fdf7c35ee8cb8fdd6e9ff309c4211fcf94cf" translate="yes" xml:space="preserve">
          <source>This error occurs when there was a recursive trait requirement that overflowed before it could be evaluated. This often means that there is an unbounded recursion in resolving some type bounds.</source>
          <target state="translated">이 오류는 평가하기 전에 넘친 재귀 특성 요구 사항이있을 때 발생합니다. 이것은 종종 일부 유형 경계를 해결하는 데 무제한 재귀가 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7b6569d564fb77649858b1d55f9d8b2a0efd5a34" translate="yes" xml:space="preserve">
          <source>This error occurs when you defined methods or associated functions with same name.</source>
          <target state="translated">이 오류는 동일한 이름으로 메소드 또는 연관된 함수를 정의 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="31aab3dcb3c76822f5a50ebdbab3c624e3384795" translate="yes" xml:space="preserve">
          <source>This error points at a file we didn&amp;rsquo;t write, &lt;em&gt;libcore/slice/mod.rs&lt;/em&gt;. That&amp;rsquo;s the implementation of &lt;code&gt;slice&lt;/code&gt; in the Rust source code. The code that gets run when we use &lt;code&gt;[]&lt;/code&gt; on our vector &lt;code&gt;v&lt;/code&gt; is in &lt;em&gt;libcore/slice/mod.rs&lt;/em&gt;, and that is where the &lt;code&gt;panic!&lt;/code&gt; is actually happening.</source>
          <target state="translated">이 오류는 우리가 작성하지 않은 파일 인 &lt;em&gt;libcore / slice / mod.rs를 가리 킵니다&lt;/em&gt; . 이것이 Rust 소스 코드에서 &lt;code&gt;slice&lt;/code&gt; 의 구현입니다 . 벡터 &lt;code&gt;v&lt;/code&gt; 에서 &lt;code&gt;[]&lt;/code&gt; 를 사용할 때 실행되는 코드 는 &lt;em&gt;libcore / slice / mod.rs&lt;/em&gt; 에 있으며, 여기서 &lt;code&gt;panic!&lt;/code&gt; 이 발생합니다 ! 실제로 일어나고 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="daff356f50087f066d8d7f295e45f7db503c47eb" translate="yes" xml:space="preserve">
          <source>This error points out that we&amp;rsquo;re only allowed to use the &lt;code&gt;?&lt;/code&gt; operator in a function that returns &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. When you&amp;rsquo;re writing code in a function that doesn&amp;rsquo;t return &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, and you want to use &lt;code&gt;?&lt;/code&gt; when you call other functions that return &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, you have two choices to fix this problem. One technique is to change the return type of your function to be &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; if you have no restrictions preventing that. The other technique is to use a &lt;code&gt;match&lt;/code&gt; or one of the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; methods to handle the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; in whatever way is appropriate.</source>
          <target state="translated">이 오류는 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 를 반환하는 함수의 연산자 . &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 반환하지 않는 함수에서 코드를 작성 하고 싶 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 를 리턴하는 다른 함수를 호출 할 때이 문제를 해결하기위한 두 가지 선택 사항이 있습니다. 이를 방지하는 데 제한이없는 경우 함수의 반환 유형을 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 로 변경하는 방법이 있습니다 . 다른 기술은 사용하는 &lt;code&gt;match&lt;/code&gt; 의 하나 또는 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 핸들하는 방법 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 방법은 적절한 무엇이든에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef0f484866e508390ede392520c4e2f457d726bf" translate="yes" xml:space="preserve">
          <source>This error points out that we&amp;rsquo;re only allowed to use the &lt;code&gt;?&lt;/code&gt; operator in a function that returns &lt;code&gt;Result&lt;/code&gt; or &lt;code&gt;Option&lt;/code&gt; or another type that implements &lt;code&gt;std::ops::Try&lt;/code&gt;. When you&amp;rsquo;re writing code in a function that doesn&amp;rsquo;t return one of these types, and you want to use &lt;code&gt;?&lt;/code&gt; when you call other functions that return &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, you have two choices to fix this problem. One technique is to change the return type of your function to be &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; if you have no restrictions preventing that. The other technique is to use a &lt;code&gt;match&lt;/code&gt; or one of the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; methods to handle the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; in whatever way is appropriate.</source>
          <target state="translated">이 오류는 우리가 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; 또는 &lt;code&gt;Option&lt;/code&gt; 을 반환하는 함수 또는 &lt;code&gt;std::ops::Try&lt;/code&gt; 를 구현하는 다른 유형의 연산자 . 이러한 유형 중 하나를 반환하지 않는 함수에서 코드를 작성할 때 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 를 반환하는 다른 함수를 호출 할 때이 문제를 해결할 수있는 두 가지 방법이 있습니다. 한 가지 방법은 제한 사항이없는 경우 함수의 반환 유형을 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 하는 것입니다. 다른 기술은 사용하는 &lt;code&gt;match&lt;/code&gt; 의 하나 또는 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 핸들하는 방법 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 어떤 식 으로든 적절합니다.</target>
        </trans-unit>
        <trans-unit id="f5d927c97470a6bdf532b94621efe13e0092f99e" translate="yes" xml:space="preserve">
          <source>This error suggests that the expression arm corresponding to the noted pattern will never be reached as for all possible values of the expression being matched, one of the preceding patterns will match.</source>
          <target state="translated">이 오류는 일치하는 표현식의 모든 가능한 값에 대해 언급 된 패턴에 해당하는 표현식 암에 도달하지 않으며, 이전 패턴 중 하나가 일치 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f4cd2a99a6de016ca859c1b751566814099aa1c3" translate="yes" xml:space="preserve">
          <source>This error type&amp;rsquo;s methods can be used to create functionality similar to &lt;code&gt;String::from_utf8_lossy&lt;/code&gt; without allocating heap memory:</source>
          <target state="translated">이 오류 유형의 메소드를 사용하여 &lt;code&gt;String::from_utf8_lossy&lt;/code&gt; 와 유사한 기능을 작성할 수 있습니다. 힙 메모리를 할당하지 않고 .</target>
        </trans-unit>
        <trans-unit id="fb422fab14fffbfe5c78207ee2ae02a65418bd40" translate="yes" xml:space="preserve">
          <source>This error usually happens when trying to pass in a value to an input inline assembly operand that is actually a pair of values. In particular, this can happen when trying to pass in a slice, for instance a &lt;code&gt;&amp;amp;str&lt;/code&gt;. In Rust, these values are represented internally as a pair of values, the pointer and its length. When passed as an input operand, this pair of values can not be coerced into a register and thus we must fail with an error.</source>
          <target state="translated">이 오류는 일반적으로 실제로 값 쌍인 입력 인라인 어셈블리 피연산자에 값을 전달하려고 할 때 발생합니다. 특히 이것은 슬라이스를 전달하려고 할 때 발생할 수 있습니다 (예 : &lt;code&gt;&amp;amp;str&lt;/code&gt; . Rust에서 이러한 값은 내부적으로 한 쌍의 값, 포인터 및 길이로 표시됩니다. 입력 피연산자로 전달되면이 값 쌍을 레지스터로 강제 변환 할 수 없으므로 오류와 함께 실패해야합니다.</target>
        </trans-unit>
        <trans-unit id="46906d1c89db9bd7d3aa62947de98893bb4109ab" translate="yes" xml:space="preserve">
          <source>This error was returned when attempting to write the internal buffer.</source>
          <target state="translated">내부 버퍼를 쓰려고 할 때이 오류가 리턴되었습니다.</target>
        </trans-unit>
        <trans-unit id="3d919bd775721ac4d8e4678ab5d56f5c5d828138" translate="yes" xml:space="preserve">
          <source>This error will be emitted by the compiler when using an invalid receiver type, like in the following example:</source>
          <target state="translated">이 오류는 다음 예제와 같이 유효하지 않은 수신기 유형을 사용할 때 컴파일러에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6f5335a8d7c6f37faeab381d52fe1092a252bd8d" translate="yes" xml:space="preserve">
          <source>This example also shows how to use &lt;code&gt;move&lt;/code&gt;, in order to give ownership of values to a thread.</source>
          <target state="translated">이 예제는 값 소유권을 스레드에 부여하기 위해 &lt;code&gt;move&lt;/code&gt; 를 사용하는 방법도 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="175716bea92c9d941f0898dc29c4ed209e64c353" translate="yes" xml:space="preserve">
          <source>This example builds a string, starting with an initial value and continuing with each element from the back until the front:</source>
          <target state="translated">이 예제는 초기 값부터 시작하여 각 요소를 뒤에서 앞으로 계속하여 문자열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4d013525fa73f401dcf7648ce7d8e69f8100f085" translate="yes" xml:space="preserve">
          <source>This example creates a &lt;code&gt;Point&lt;/code&gt; struct that implements &lt;a href=&quot;trait.add&quot;&gt;&lt;code&gt;Add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.sub&quot;&gt;&lt;code&gt;Sub&lt;/code&gt;&lt;/a&gt;, and then demonstrates adding and subtracting two &lt;code&gt;Point&lt;/code&gt;s.</source>
          <target state="translated">이 예제에서는 &lt;a href=&quot;trait.add&quot;&gt; &lt;code&gt;Add&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;trait.sub&quot;&gt; &lt;code&gt;Sub&lt;/code&gt; &lt;/a&gt; 을 구현 하는 &lt;code&gt;Point&lt;/code&gt; 구조체를 만든 다음 두 &lt;code&gt;Point&lt;/code&gt; 를 더하고 빼는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="612bd6352093018ae655e26b99b1150fb9f0d9dc" translate="yes" xml:space="preserve">
          <source>This example creates a &lt;code&gt;Point&lt;/code&gt; struct that implements the &lt;code&gt;AddAssign&lt;/code&gt; trait, and then demonstrates add-assigning to a mutable &lt;code&gt;Point&lt;/code&gt;.</source>
          <target state="translated">이 예제에서는 &lt;code&gt;AddAssign&lt;/code&gt; 특성 을 구현 하는 &lt;code&gt;Point&lt;/code&gt; 구조체를 만든 다음 변경 가능한 &lt;code&gt;Point&lt;/code&gt; 에 대한 추가 할당을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="84b61046cfa323fa19b23ac20e12034ef787e01b" translate="yes" xml:space="preserve">
          <source>This example creates a &lt;code&gt;Point&lt;/code&gt; struct that implements the &lt;code&gt;SubAssign&lt;/code&gt; trait, and then demonstrates sub-assigning to a mutable &lt;code&gt;Point&lt;/code&gt;.</source>
          <target state="translated">이 예제 는 &lt;code&gt;SubAssign&lt;/code&gt; 특성 을 구현 하는 &lt;code&gt;Point&lt;/code&gt; 구조체를 만든 다음 변경 가능한 &lt;code&gt;Point&lt;/code&gt; 에 대한 하위 할당을 보여줍니다. .</target>
        </trans-unit>
        <trans-unit id="979ade7fbba01641154de5a065a6e6890cf54db4" translate="yes" xml:space="preserve">
          <source>This example creates a function with two parameters, both of which are &lt;code&gt;i32&lt;/code&gt; types. The function then prints the values in both of its parameters. Note that function parameters don&amp;rsquo;t all need to be the same type, they just happen to be in this example.</source>
          <target state="translated">이 예는 &lt;code&gt;i32&lt;/code&gt; 유형 인 두 개의 매개 변수로 함수를 작성합니다 . 그런 다음이 함수는 두 매개 변수 모두에 값을 인쇄합니다. 함수 매개 변수가 모두 같은 유형일 필요는 없으며이 예제에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="701db2e46c2038eecc101dd4ef0779ff5ad8d4cc" translate="yes" xml:space="preserve">
          <source>This example implements &lt;code&gt;Rem&lt;/code&gt; on a &lt;code&gt;SplitSlice&lt;/code&gt; object. After &lt;code&gt;Rem&lt;/code&gt; is implemented, one can use the &lt;code&gt;%&lt;/code&gt; operator to find out what the remaining elements of the slice would be after splitting it into equal slices of a given length.</source>
          <target state="translated">이 예제 는 &lt;code&gt;SplitSlice&lt;/code&gt; 객체 에서 &lt;code&gt;Rem&lt;/code&gt; 을 구현 합니다. &lt;code&gt;Rem&lt;/code&gt; 이 구현 된 후 &lt;code&gt;%&lt;/code&gt; 를 사용할 수 있습니다 연산자를 하여 슬라이스의 나머지 요소를 주어진 길이의 동일한 슬라이스로 분할 한 후의 나머지 요소를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d81c01c409b8ce1936b460c9219c2266b9648d9" translate="yes" xml:space="preserve">
          <source>This example prints 3, 2, and then 1. The &lt;code&gt;pop&lt;/code&gt; method takes the last element out of the vector and returns &lt;code&gt;Some(value)&lt;/code&gt;. If the vector is empty, &lt;code&gt;pop&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;. The &lt;code&gt;while&lt;/code&gt; loop continues running the code in its block as long as &lt;code&gt;pop&lt;/code&gt; returns &lt;code&gt;Some&lt;/code&gt;. When &lt;code&gt;pop&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, the loop stops. We can use &lt;code&gt;while let&lt;/code&gt; to pop every element off our stack.</source>
          <target state="translated">이 예제는 3, 2, 1을 인쇄합니다. &lt;code&gt;pop&lt;/code&gt; 메서드는 벡터에서 마지막 요소를 가져와 &lt;code&gt;Some(value)&lt;/code&gt; 반환합니다 . 벡터가 비어 있으면 &lt;code&gt;pop&lt;/code&gt; 은 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 . &lt;code&gt;while&lt;/code&gt; 루프는 길이만큼의 블록의 코드를 계속 실행 &lt;code&gt;pop&lt;/code&gt; 반환 &lt;code&gt;Some&lt;/code&gt; . 때 &lt;code&gt;pop&lt;/code&gt; 반환 &lt;code&gt;None&lt;/code&gt; , 루프가 중지됩니다. 스택에서 모든 요소를 ​​튀기는 &lt;code&gt;while let&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f29d652e237479a6c170562a3189e4859a56b5e" translate="yes" xml:space="preserve">
          <source>This example shows an inner attribute on a function. The function is documented with just the word &quot;Example&quot;.</source>
          <target state="translated">이 예는 함수의 내부 속성을 보여줍니다. 이 기능은 &quot;예제&quot;라는 단어로만 문서화됩니다.</target>
        </trans-unit>
        <trans-unit id="33bd3bf0b7b00466cfe4514bc631cc4d45b75356" translate="yes" xml:space="preserve">
          <source>This example shows an inner attribute on a function. The function will only be available while running tests.</source>
          <target state="translated">이 예제는 함수의 내부 속성을 보여줍니다. 이 기능은 테스트를 실행하는 동안에 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02dcd48945408a840f3079c83663da1b30b196c7" translate="yes" xml:space="preserve">
          <source>This example shows how one can use &lt;code&gt;allow&lt;/code&gt; and &lt;code&gt;warn&lt;/code&gt; to toggle a particular check on and off:</source>
          <target state="translated">이 예제는 &lt;code&gt;allow&lt;/code&gt; 와 &lt;code&gt;warn&lt;/code&gt; 을 사용 하여 특정 검사를 켜고 끄는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="b51a82804a004969c18f750e315e49a925f322a3" translate="yes" xml:space="preserve">
          <source>This example shows how one can use &lt;code&gt;forbid&lt;/code&gt; to disallow uses of &lt;code&gt;allow&lt;/code&gt; for that lint check:</source>
          <target state="translated">사람이 사용할 수있는 방법이 예제 쇼 &lt;code&gt;forbid&lt;/code&gt; 의 용도를 허용하지 &lt;code&gt;allow&lt;/code&gt; 하는 보풀 확인을 위해 :</target>
        </trans-unit>
        <trans-unit id="20dcd5999998e80d936e0fa700c4a9a09932a423" translate="yes" xml:space="preserve">
          <source>This example shows how the compiler helps you find errors in your programs. Even though compiler errors can be frustrating, they only mean your program isn&amp;rsquo;t safely doing what you want it to do yet; they do &lt;em&gt;not&lt;/em&gt; mean that you&amp;rsquo;re not a good programmer! Experienced Rustaceans still get compiler errors.</source>
          <target state="translated">이 예제는 컴파일러가 프로그램에서 오류를 찾는 방법을 보여줍니다. 컴파일러 오류는 실망 스러울 수 있지만 프로그램이 아직 원하는 작업을 안전하게 수행하고 있지 않다는 것을 의미합니다. 그들은 당신이 좋은 프로그래머 가 &lt;em&gt;아니라는&lt;/em&gt; 것을 의미 하지는 &lt;em&gt;않습니다&lt;/em&gt; ! 경험 많은 Rustaceans는 여전히 컴파일러 오류를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="2cb4570e4e31d810429621e0a69fd89abfdb2ea3" translate="yes" xml:space="preserve">
          <source>This example shows using a custom derive attribute to modify the meaning of a generic parameter.</source>
          <target state="translated">이 예는 사용자 정의 파생 속성을 사용하여 일반 매개 변수의 의미를 수정하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e1b71afb4f7ccdfd339dd3d129a43084a3b35c6b" translate="yes" xml:space="preserve">
          <source>This example spawns a thread which will update the boolean value and then wait 100 milliseconds before notifying the condvar.</source>
          <target state="translated">이 예제는 부울 값을 업데이트 한 다음 100 밀리 초 동안 기다렸다가 condvar에 알리는 스레드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b7617cea2234e7524bc25112d50668635c06f962" translate="yes" xml:space="preserve">
          <source>This example will print &lt;code&gt;Found an id in range: 5&lt;/code&gt;. By specifying &lt;code&gt;id_variable @&lt;/code&gt; before the range &lt;code&gt;3...7&lt;/code&gt;, we&amp;rsquo;re capturing whatever value matched the range while also testing that the value matched the range pattern.</source>
          <target state="translated">이 예제는 &lt;code&gt;Found an id in range: 5&lt;/code&gt; 를 인쇄 합니다. &lt;code&gt;3...7&lt;/code&gt; 범위 앞에 &lt;code&gt;id_variable @&lt;/code&gt; 을 지정하여 와 일치하는 값을 캡처하는 동시에 값이 범위 패턴과 일치하는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="6bcb3e1c80011a7567e2eb18a8ff65f6e860aa55" translate="yes" xml:space="preserve">
          <source>This example will print &lt;code&gt;Found an id in range: 5&lt;/code&gt;. By specifying &lt;code&gt;id_variable @&lt;/code&gt; before the range &lt;code&gt;3..=7&lt;/code&gt;, we&amp;rsquo;re capturing whatever value matched the range while also testing that the value matched the range pattern.</source>
          <target state="translated">이 예제는 &lt;code&gt;Found an id in range: 5&lt;/code&gt; 인쇄 합니다. 범위 &lt;code&gt;3..=7&lt;/code&gt; 앞에 &lt;code&gt;id_variable @&lt;/code&gt; 을 지정 하여 범위 와 일치하는 값을 캡처하는 동시에 값이 범위 패턴과 일치하는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="0792a7553f859fe5307a072fac84a140057b4ecf" translate="yes" xml:space="preserve">
          <source>This example will print &lt;code&gt;less than five: 4&lt;/code&gt;. When &lt;code&gt;num&lt;/code&gt; is compared to the pattern in the first arm, it matches, because &lt;code&gt;Some(4)&lt;/code&gt; matches &lt;code&gt;Some(x)&lt;/code&gt;. Then the match guard checks whether the value in &lt;code&gt;x&lt;/code&gt; is less than &lt;code&gt;5&lt;/code&gt;, and because it is, the first arm is selected.</source>
          <target state="translated">이 예는 &lt;code&gt;less than five: 4&lt;/code&gt; 을 인쇄합니다 : 4 . 경우 &lt;code&gt;num&lt;/code&gt; 제 1 아암의 패턴과 비교된다 때문 일치 &lt;code&gt;Some(4)&lt;/code&gt; 과 일치하는 &lt;code&gt;Some(x)&lt;/code&gt; . 그런 다음 매치 가드는 &lt;code&gt;x&lt;/code&gt; 의 값 이 &lt;code&gt;5&lt;/code&gt; 보다 작은 지 여부를 확인하고 그 값 이므로 첫 번째 팔이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="e9c51ef5db1956234586460cd5d4e3f2d56f3c15" translate="yes" xml:space="preserve">
          <source>This exists solely for &lt;a href=&quot;../mem/fn.forget_unsized&quot;&gt;&lt;code&gt;mem::forget_unsized&lt;/code&gt;&lt;/a&gt;; normal &lt;code&gt;forget&lt;/code&gt; uses &lt;code&gt;ManuallyDrop&lt;/code&gt; instead.</source>
          <target state="translated">이것은 &lt;a href=&quot;../mem/fn.forget_unsized&quot;&gt; &lt;code&gt;mem::forget_unsized&lt;/code&gt; &lt;/a&gt; 만을 위해 존재합니다 . 정상은 &lt;code&gt;forget&lt;/code&gt; 사용이 &lt;code&gt;ManuallyDrop&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="13f35b34cb9f0940df9ede968c0941933fe5a63e" translate="yes" xml:space="preserve">
          <source>This explicitly states that you expect the trait object &lt;code&gt;SomeTrait&lt;/code&gt; to contain references (with a maximum lifetime of &lt;code&gt;'a&lt;/code&gt;).</source>
          <target state="translated">이는 특성 오브젝트 &lt;code&gt;SomeTrait&lt;/code&gt; 에 참조 (최대 수명이 &lt;code&gt;'a&lt;/code&gt; ' ) 를 포함 할 것으로 예상 함을 명시 적으로 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="55550702354f0f532a45a47534287ba31230892e" translate="yes" xml:space="preserve">
          <source>This expression:</source>
          <target state="translated">이 표현은 :</target>
        </trans-unit>
        <trans-unit id="d4d243a04a2e7c3baa5aaa70386526d20f9c61fb" translate="yes" xml:space="preserve">
          <source>This fails because &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is not &lt;code&gt;Copy&lt;/code&gt;, even when &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Copy&lt;/code&gt; (this differs from the behavior for &lt;code&gt;&amp;amp;T&lt;/code&gt;, which is always &lt;code&gt;Copy&lt;/code&gt;).</source>
          <target state="translated">이는 실패 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 아닌 &lt;code&gt;Copy&lt;/code&gt; 하더라도, &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;code&gt;Copy&lt;/code&gt; (대한 동작에서이 다릅니다 &lt;code&gt;&amp;amp;T&lt;/code&gt; 항상, &lt;code&gt;Copy&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="96a49ec58cf9d3de1eca61f7643ce5de9d8c4e5e" translate="yes" xml:space="preserve">
          <source>This fails because &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; does not implement &lt;code&gt;Copy&lt;/code&gt; for any &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 가 &lt;code&gt;T&lt;/code&gt; 에 대해 &lt;code&gt;Copy&lt;/code&gt; 를 구현하지 않기 때문에 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="77c78e0cdd88af63c9805574659b7e0844c8f178" translate="yes" xml:space="preserve">
          <source>This fails to compile because &lt;code&gt;T&lt;/code&gt; does not appear in the trait or in the implementing type.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 는 특성 또는 구현 유형에 나타나지 않기 때문에 컴파일에 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="586c08bc607fd5a338c048e0f30142b22328caf5" translate="yes" xml:space="preserve">
          <source>This field contains the file system attribute information for a file or directory. For possible values and their descriptions, see &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants&quot;&gt;File Attribute Constants&lt;/a&gt; in the Windows Dev Center.</source>
          <target state="translated">이 필드에는 파일 또는 디렉토리에 대한 파일 시스템 속성 정보가 포함됩니다. 가능한 값과 설명 은 Windows 개발자 센터의 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants&quot;&gt;파일 특성 상수&lt;/a&gt; 를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="0c5af671ad45076c8c92a16a6b71ec7dd6cf3c8d" translate="yes" xml:space="preserve">
          <source>This field contains the file system attribute information for a file or directory. For possible values and their descriptions, see &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/gg258117.aspx&quot;&gt;File Attribute Constants&lt;/a&gt; in the Windows Dev Center.</source>
          <target state="translated">이 필드에는 파일 또는 디렉토리에 대한 파일 시스템 속성 정보가 있습니다. 가능한 값과 설명은 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/gg258117.aspx&quot;&gt;파일 속성 상수를&lt;/a&gt; 참조하십시오. 은 Windows 개발자 센터의 를 .</target>
        </trans-unit>
        <trans-unit id="a06da2f86acca1e87efa6c64e9e56d6bba45e46d" translate="yes" xml:space="preserve">
          <source>This field may not be available on all platforms, and will return an &lt;code&gt;Err&lt;/code&gt; on platforms or filesystems where it is not available.</source>
          <target state="translated">이 필드는 모든 플랫폼에서 사용 가능하지 않을 수 있으며 사용할 수없는 플랫폼이나 파일 시스템에서 &lt;code&gt;Err&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fed8ac050f10d4961483960b90a8bb5fa116bf7c" translate="yes" xml:space="preserve">
          <source>This field may not be available on all platforms, and will return an &lt;code&gt;Err&lt;/code&gt; on platforms where it is not available.</source>
          <target state="translated">이 필드는 모든 플랫폼에서 사용 가능하지 않을 수 있으며 사용할 수없는 플랫폼에서는 &lt;code&gt;Err&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="5368359fd79a3572b28925e44099327d749ce6f1" translate="yes" xml:space="preserve">
          <source>This file is in the &lt;a href=&quot;https://github.com/toml-lang/toml&quot;&gt;&lt;em&gt;TOML&lt;/em&gt;&lt;/a&gt; (&lt;em&gt;Tom&amp;rsquo;s Obvious, Minimal Language&lt;/em&gt;) format, which is Cargo&amp;rsquo;s configuration format.</source>
          <target state="translated">이 파일은 &lt;a href=&quot;https://github.com/toml-lang/toml&quot;&gt;&lt;em&gt;TOML&lt;/em&gt;&lt;/a&gt; ( &lt;em&gt;Tom 's Obvious, Minimal Language&lt;/em&gt; ) 형식이며, 이는 Cargo의 구성 형식입니다.</target>
        </trans-unit>
        <trans-unit id="403b498b0ea95a8401971fc9fa18c953b57bf6c7" translate="yes" xml:space="preserve">
          <source>This file is in the &lt;a href=&quot;https://toml.io&quot;&gt;&lt;em&gt;TOML&lt;/em&gt;&lt;/a&gt; (&lt;em&gt;Tom&amp;rsquo;s Obvious, Minimal Language&lt;/em&gt;) format, which is Cargo&amp;rsquo;s configuration format.</source>
          <target state="translated">이 파일은 Cargo의 구성 형식 인 &lt;a href=&quot;https://toml.io&quot;&gt;&lt;em&gt;TOML&lt;/em&gt;&lt;/a&gt; ( &lt;em&gt;Tom 's Obvious, Minimal Language&lt;/em&gt; ) 형식입니다.</target>
        </trans-unit>
        <trans-unit id="f0537f20b3c4c0b16d4802ffcd175906f9816b83" translate="yes" xml:space="preserve">
          <source>This following example shows the stringified &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;s&lt;/a&gt; that the attribute macros see. The output will show in the output of the compiler. The output is shown in the comments after the function prefixed with &quot;out:&quot;.</source>
          <target state="translated">이 다음 예제 표시는도 캐릭터 라인 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; 의&lt;/a&gt; 속성 매크로를 참조하는 것이 있습니다. 출력은 컴파일러의 출력에 표시됩니다. &quot;out :&quot;접두사가 붙은 함수 뒤에 주석에 출력이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a9c265b88652152ca2b28f53cb136d7ff3a25c8d" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;consumes ownership&lt;/strong&gt; of the specified file descriptor. The returned object will take responsibility for closing it when the object goes out of scope.</source>
          <target state="translated">이 함수 &lt;strong&gt;는 소유권을 소비합니다&lt;/strong&gt; 지정된 파일 디스크립터의 을 합니다. 반환 된 객체는 객체가 범위를 벗어날 때 객체를 닫는 책임을집니다.</target>
        </trans-unit>
        <trans-unit id="7770f6814daf86198289168c0cb8b4e0eaa39b97" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;transfers ownership&lt;/strong&gt; of the underlying file descriptor to the caller. Callers are then the unique owners of the file descriptor and must close the descriptor once it's no longer needed.</source>
          <target state="translated">이 함수 는 기본 파일 디스크립터의 &lt;strong&gt;소유권&lt;/strong&gt; 을 호출자에게 &lt;strong&gt;전송&lt;/strong&gt; 합니다. 그러면 호출자는 파일 디스크립터의 고유 한 소유자이며 더 이상 필요하지 않은 디스크립터를 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="9e16870fdc5324388fb513d47d710cb2a9d23e70" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;transfers ownership&lt;/strong&gt; of the underlying handle to the caller. Callers are then the unique owners of the handle and must close it once it's no longer needed.</source>
          <target state="translated">이 함수 는 기본 핸들의 &lt;strong&gt;소유권&lt;/strong&gt; 을 호출자에게 &lt;strong&gt;전송&lt;/strong&gt; 합니다. 그러면 발신자는 핸들의 고유 한 소유자이므로 더 이상 필요하지 않으면 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="90c9a08f16b0c10b615b5b0843cebfac39017e99" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;transfers ownership&lt;/strong&gt; of the underlying pthread_t to the caller. Callers are then the unique owners of the pthread_t and must either detach or join the pthread_t once it's no longer needed.</source>
          <target state="translated">이 함수 는 기본 pthread_t의 &lt;strong&gt;소유권&lt;/strong&gt; 을 호출자에게 &lt;strong&gt;전송&lt;/strong&gt; 합니다. 그러면 호출자는 pthread_t의 고유 한 소유자이며 더 이상 필요하지 않은 pthread_t를 분리하거나 결합해야합니다.</target>
        </trans-unit>
        <trans-unit id="06669b18e93261495eb1fcf2252cb895da69c39a" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;transfers ownership&lt;/strong&gt; of the underlying socket to the caller. Callers are then the unique owners of the socket and must close it once it's no longer needed.</source>
          <target state="translated">이 함수 는 기본 소켓의 &lt;strong&gt;소유권&lt;/strong&gt; 을 호출자에게 &lt;strong&gt;전송&lt;/strong&gt; 합니다. 그러면 호출자는 소켓의 고유 한 소유자이므로 더 이상 필요하지 않으면 소켓을 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="3028ce76268abc4493b0febc5668a0c85baa5e06" translate="yes" xml:space="preserve">
          <source>This function accepts strings such as</source>
          <target state="translated">이 함수는 다음과 같은 문자열을 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="3b6b07c29d146488fec502f1e37e5fcc2f92d5fd" translate="yes" xml:space="preserve">
          <source>This function allows inspecting the location, in code, of where an error happened. The returned &lt;code&gt;Backtrace&lt;/code&gt; contains information about the stack trace of the OS thread of execution of where the error originated from.</source>
          <target state="translated">이 함수는 코드에서 오류가 발생한 위치를 검사 할 수 있습니다. 반환 된 &lt;code&gt;Backtrace&lt;/code&gt; 에는 오류가 발생한 OS 스레드 실행의 스택 추적에 대한 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dcca4cdb6fc324905436b470716282df197ae1a7" translate="yes" xml:space="preserve">
          <source>This function behaves the same as &lt;code&gt;capture&lt;/code&gt; except that it ignores the values of the &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; and &lt;code&gt;RUST_LIB_BACKTRACE&lt;/code&gt; environment variables, always capturing a backtrace.</source>
          <target state="translated">이 함수 는 &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; 및 &lt;code&gt;RUST_LIB_BACKTRACE&lt;/code&gt; 환경 변수 의 값을 무시하고 항상 역 추적 을 &lt;code&gt;capture&lt;/code&gt; 한다는 점을 제외하면 capture 와 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="e1eb2ceefa3b664d9a9270981fa8cbdd469bffdd" translate="yes" xml:space="preserve">
          <source>This function can be used for control flow based on &lt;code&gt;Result&lt;/code&gt; values.</source>
          <target state="translated">이 기능은 &lt;code&gt;Result&lt;/code&gt; 값을 기준으로 제어 흐름에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="069d719c6868f05d1ad9a84a0abe1540eb6a83ca" translate="yes" xml:space="preserve">
          <source>This function can be used for control flow based on result values.</source>
          <target state="translated">이 기능은 결과 값을 기준으로 제어 흐름에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f2e8570607d30aa900e189937d7916fe8ed3230" translate="yes" xml:space="preserve">
          <source>This function can be used to compose the results of two functions.</source>
          <target state="translated">이 기능은 두 가지 기능의 결과를 구성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="890b1ba5d17963460809400c8357e2da154ed2a6" translate="yes" xml:space="preserve">
          <source>This function can be used to pass through a successful result while handling an error.</source>
          <target state="translated">이 기능을 사용하면 오류를 처리하는 동안 성공적인 결과를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f898974fbfac52e97eb29d82afb416cf7dbf9a7a" translate="yes" xml:space="preserve">
          <source>This function can be used to unpack a successful result while handling an error.</source>
          <target state="translated">이 기능을 사용하면 오류를 처리하는 동안 성공적인 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="663e29d3010e4fe834fdfef457c75d87463c66ed" translate="yes" xml:space="preserve">
          <source>This function can be written in a much shorter way, but we&amp;rsquo;re going to start by doing a lot of it manually in order to explore error handling; at the end, we&amp;rsquo;ll show the shorter way. Let&amp;rsquo;s look at the return type of the function first: &lt;code&gt;Result&amp;lt;String, io::Error&amp;gt;&lt;/code&gt;. This means the function is returning a value of the type &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; where the generic parameter &lt;code&gt;T&lt;/code&gt; has been filled in with the concrete type &lt;code&gt;String&lt;/code&gt; and the generic type &lt;code&gt;E&lt;/code&gt; has been filled in with the concrete type &lt;code&gt;io::Error&lt;/code&gt;. If this function succeeds without any problems, the code that calls this function will receive an &lt;code&gt;Ok&lt;/code&gt; value that holds a &lt;code&gt;String&lt;/code&gt;&amp;mdash;the username that this function read from the file. If this function encounters any problems, the code that calls this function will receive an &lt;code&gt;Err&lt;/code&gt; value that holds an instance of &lt;code&gt;io::Error&lt;/code&gt; that contains more information about what the problems were. We chose &lt;code&gt;io::Error&lt;/code&gt; as the return type of this function because that happens to be the type of the error value returned from both of the operations we&amp;rsquo;re calling in this function&amp;rsquo;s body that might fail: the &lt;code&gt;File::open&lt;/code&gt; function and the &lt;code&gt;read_to_string&lt;/code&gt; method.</source>
          <target state="translated">이 함수는 훨씬 짧은 방식으로 작성 될 수 있지만 오류 처리를 탐색하기 위해 수동으로 많은 기능을 수행하는 것으로 시작합니다. 마지막에 더 짧은 방법을 보여 드리겠습니다. 함수의 반환 유형을 먼저 보자 : &lt;code&gt;Result&amp;lt;String, io::Error&amp;gt;&lt;/code&gt; . 이는 함수가 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 유형의 값을 리턴한다는 것을 의미합니다. 여기서 일반 매개 변수 &lt;code&gt;T&lt;/code&gt; 는 콘크리트 유형 &lt;code&gt;String&lt;/code&gt; 으로 채워지고 일반 유형 &lt;code&gt;E&lt;/code&gt; 는 콘크리트 유형 &lt;code&gt;io::Error&lt;/code&gt; 로 채워집니다 . 이 함수가 아무런 문제없이 성공하면이 함수를 호출하는 코드 는 &lt;code&gt;String&lt;/code&gt; 을 보유한 &lt;code&gt;Ok&lt;/code&gt; 값을 받습니다.&amp;mdash;이 함수가 파일에서 읽은 사용자 이름. 이 함수에 문제가 발생하면이 함수를 호출하는 코드 는 문제의 원인에 대한 자세한 정보가 포함 된 &lt;code&gt;io::Error&lt;/code&gt; 인스턴스를 보유하는 &lt;code&gt;Err&lt;/code&gt; 값을 받습니다 . 이 함수의 반환 유형으로 &lt;code&gt;io::Error&lt;/code&gt; 를 선택했습니다. 실패했을 수있는이 함수의 본문에서 호출하는 두 작업 모두에서 반환 된 오류 값의 유형이기 때문입니다. &lt;code&gt;File::open&lt;/code&gt; 함수 및 &lt;code&gt;read_to_string&lt;/code&gt; 메소드.</target>
        </trans-unit>
        <trans-unit id="cb45099429d3a43cd1fd9c5de5abe0335d7b7e9d" translate="yes" xml:space="preserve">
          <source>This function corresponds to &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;std::mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;std::mem::replace&lt;/code&gt; &lt;/a&gt; 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="bc55369db6754d8ec7579c34bfc5b97438f6a7f6" translate="yes" xml:space="preserve">
          <source>This function corresponds to &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;std::mem::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;std::mem::swap&lt;/code&gt; &lt;/a&gt; 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="ac167c5922dc46db61626cca7bc837d30e8e8d77" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to &lt;code&gt;opendir&lt;/code&gt;, &lt;code&gt;lstat&lt;/code&gt;, &lt;code&gt;rm&lt;/code&gt; and &lt;code&gt;rmdir&lt;/code&gt; functions on Unix and the &lt;code&gt;FindFirstFile&lt;/code&gt;, &lt;code&gt;GetFileAttributesEx&lt;/code&gt;, &lt;code&gt;DeleteFile&lt;/code&gt;, and &lt;code&gt;RemoveDirectory&lt;/code&gt; functions on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">이 함수는 현재 Unix의 &lt;code&gt;opendir&lt;/code&gt; , &lt;code&gt;lstat&lt;/code&gt; , &lt;code&gt;rm&lt;/code&gt; 및 &lt;code&gt;rmdir&lt;/code&gt; 함수 및 Windows 의 &lt;code&gt;FindFirstFile&lt;/code&gt; , &lt;code&gt;GetFileAttributesEx&lt;/code&gt; , &lt;code&gt;DeleteFile&lt;/code&gt; 및 &lt;code&gt;RemoveDirectory&lt;/code&gt; 함수에 해당합니다. 그 참고이 &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;미래에 변경 될 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bea785a55c87ae52504d49f8f95ea16d8aa3ce9e" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;chmod&lt;/code&gt; function on Unix and the &lt;code&gt;SetFileAttributes&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">이 함수는 현재 Unix 의 &lt;code&gt;chmod&lt;/code&gt; 함수와 Windows 의 &lt;code&gt;SetFileAttributes&lt;/code&gt; 함수에 해당합니다. 그 참고이 &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;미래에 변경 될 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04e383479b2228c3ffffa98975698e9dda256dbb" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;fchmod&lt;/code&gt; function on Unix and the &lt;code&gt;SetFileInformationByHandle&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">이 함수는 현재 Unix 의 &lt;code&gt;fchmod&lt;/code&gt; 함수와 Windows 의 &lt;code&gt;SetFileInformationByHandle&lt;/code&gt; 함수에 해당합니다. 그 참고이 &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;미래에 변경 될 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0176ddcd073fa8b60d6460114db8d5951e367349" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;link&lt;/code&gt; function on Unix and the &lt;code&gt;CreateHardLink&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">이 기능은 현재 Unix 의 &lt;code&gt;link&lt;/code&gt; 기능과 Windows 의 &lt;code&gt;CreateHardLink&lt;/code&gt; 기능에 해당합니다. 그 참고이 &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;미래에 변경 될 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="21169ffe61676853807722591cc30f485744220c" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;linkat&lt;/code&gt; function with no flags on Unix and the &lt;code&gt;CreateHardLink&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">이 기능은 현재에 해당하는 &lt;code&gt;linkat&lt;/code&gt; 의 유닉스에 아무런 플래그와와 기능 &lt;code&gt;CreateHardLink&lt;/code&gt; 의 Windows에서 작동합니다. 그 참고이 &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;미래에 변경 될 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01e2694d82da90e8f24cd10e750a58377e07410c" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;lstat&lt;/code&gt; function on Unix and the &lt;code&gt;GetFileAttributesEx&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">이 함수는 현재 Unix 의 &lt;code&gt;lstat&lt;/code&gt; 함수와 Windows 의 &lt;code&gt;GetFileAttributesEx&lt;/code&gt; 함수에 해당합니다. 그 참고이 &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;미래에 변경 될 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3537e3f2c9af1f7a17489b68fe05b364816b75fc" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;mkdir&lt;/code&gt; function on Unix and the &lt;code&gt;CreateDirectory&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">이 함수는 현재 Unix 의 &lt;code&gt;mkdir&lt;/code&gt; 함수와 Windows 의 &lt;code&gt;CreateDirectory&lt;/code&gt; 함수에 해당합니다. 그 참고이 &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;미래에 변경 될 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ffbba2d718a3b3920d07fee5dfb64d2a84ce583" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;open&lt;/code&gt; function in Unix with &lt;code&gt;O_RDONLY&lt;/code&gt; for &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;O_WRONLY&lt;/code&gt;, &lt;code&gt;O_CREAT&lt;/code&gt;, and &lt;code&gt;O_TRUNC&lt;/code&gt; for &lt;code&gt;to&lt;/code&gt;. &lt;code&gt;O_CLOEXEC&lt;/code&gt; is set for returned file descriptors. On Windows, this function currently corresponds to &lt;code&gt;CopyFileEx&lt;/code&gt;. Alternate NTFS streams are copied but only the size of the main stream is returned by this function. On MacOS, this function corresponds to &lt;code&gt;fclonefileat&lt;/code&gt; and &lt;code&gt;fcopyfile&lt;/code&gt;. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">이 기능은 현재 &lt;code&gt;open&lt;/code&gt; 해당합니다 &lt;code&gt;from&lt;/code&gt; 에 대해 &lt;code&gt;O_RDONLY&lt;/code&gt; 를 사용 하고 &lt;code&gt;to&lt;/code&gt; 에 대해 &lt;code&gt;O_WRONLY&lt;/code&gt; , &lt;code&gt;O_CREAT&lt;/code&gt; 및 &lt;code&gt;O_TRUNC&lt;/code&gt; 를 사용 하는 Unix 함수에 합니다 . 리턴 된 파일 디스크립터에 대해 &lt;code&gt;O_CLOEXEC&lt;/code&gt; 가 설정되었습니다. Windows에서이 기능은 현재 &lt;code&gt;CopyFileEx&lt;/code&gt; 에 해당합니다 . 대체 NTFS 스트림은 복사되지만이 기능은 주 스트림 크기 만 반환합니다. MacOS에서이 기능은 &lt;code&gt;fclonefileat&lt;/code&gt; 및 &lt;code&gt;fcopyfile&lt;/code&gt; 에 해당합니다 . 그 참고이 &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;미래에 변경 될 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="69a3d5683d593b686853078a406cbc99ddb7840f" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;opendir&lt;/code&gt; function on Unix and the &lt;code&gt;FindFirstFile&lt;/code&gt; function on Windows. Advancing the iterator currently corresponds to &lt;code&gt;readdir&lt;/code&gt; on Unix and &lt;code&gt;FindNextFile&lt;/code&gt; on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">이 함수는 현재 Unix 의 &lt;code&gt;opendir&lt;/code&gt; 함수와 Windows 의 &lt;code&gt;FindFirstFile&lt;/code&gt; 함수에 해당합니다. 반복자를 발전시키는 것은 현재 Unix의 &lt;code&gt;readdir&lt;/code&gt; 과 Windows의 &lt;code&gt;FindNextFile&lt;/code&gt; 에 해당합니다. 그 참고이 &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;미래에 변경 될 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85bdcb1c22d0b90cfc515b44a49195abde2937e0" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;opendir&lt;/code&gt; function on Unix and the &lt;code&gt;FindFirstFile&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">이 함수는 현재 Unix 의 &lt;code&gt;opendir&lt;/code&gt; 함수와 Windows 의 &lt;code&gt;FindFirstFile&lt;/code&gt; 함수에 해당합니다. 그 참고이 &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;미래에 변경 될 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6d0089b9c1b95a34e4ecb4a009ec095c9db172d" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;readlink&lt;/code&gt; function on Unix and the &lt;code&gt;CreateFile&lt;/code&gt; function with &lt;code&gt;FILE_FLAG_OPEN_REPARSE_POINT&lt;/code&gt; and &lt;code&gt;FILE_FLAG_BACKUP_SEMANTICS&lt;/code&gt; flags on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">이 함수는 현재 Unix 의 &lt;code&gt;readlink&lt;/code&gt; 함수와 Windows의 &lt;code&gt;FILE_FLAG_OPEN_REPARSE_POINT&lt;/code&gt; 및 &lt;code&gt;FILE_FLAG_BACKUP_SEMANTICS&lt;/code&gt; 플래그가 있는 &lt;code&gt;CreateFile&lt;/code&gt; 함수 에 해당합니다. 그 참고이 &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;미래에 변경 될 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83d811fb4fcc08f1492a059a3536fbb7a2a90ca2" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;realpath&lt;/code&gt; function on Unix and the &lt;code&gt;CreateFile&lt;/code&gt; and &lt;code&gt;GetFinalPathNameByHandle&lt;/code&gt; functions on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">이 함수는 현재 Unix 의 &lt;code&gt;realpath&lt;/code&gt; 함수와 Windows 의 &lt;code&gt;CreateFile&lt;/code&gt; 및 &lt;code&gt;GetFinalPathNameByHandle&lt;/code&gt; 함수에 해당합니다. 그 참고이 &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;미래에 변경 될 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8892007c2c9e02432f47cff4848a4e40ebbc10c" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;rename&lt;/code&gt; function on Unix and the &lt;code&gt;MoveFileEx&lt;/code&gt; function with the &lt;code&gt;MOVEFILE_REPLACE_EXISTING&lt;/code&gt; flag on Windows.</source>
          <target state="translated">이 함수는 현재 Unix 의 &lt;code&gt;rename&lt;/code&gt; 기능과 Windows 의 &lt;code&gt;MOVEFILE_REPLACE_EXISTING&lt;/code&gt; 플래그를 가진 &lt;code&gt;MoveFileEx&lt;/code&gt; 함수에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="8dd8f559f50531dc710476fe85e80e2f8d9753bd" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;rmdir&lt;/code&gt; function on Unix and the &lt;code&gt;RemoveDirectory&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">이 기능은 현재 Unix 의 &lt;code&gt;rmdir&lt;/code&gt; 기능과 Windows 의 &lt;code&gt;RemoveDirectory&lt;/code&gt; 기능에 해당합니다. 그 참고이 &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;미래에 변경 될 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b504889b373cb94fdb7ee56e28d937c2f36d6f0b" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;stat&lt;/code&gt; function on Unix and the &lt;code&gt;GetFileAttributesEx&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">이 함수는 현재 Unix 의 &lt;code&gt;stat&lt;/code&gt; 함수와 Windows 의 &lt;code&gt;GetFileAttributesEx&lt;/code&gt; 함수에 해당합니다. 그 참고이 &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;미래에 변경 될 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6672293739936665c26201ef3156432a0e98fd87" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;unlink&lt;/code&gt; function on Unix and the &lt;code&gt;DeleteFile&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">이 기능은 현재 Unix 의 &lt;code&gt;unlink&lt;/code&gt; 기능과 Windows 의 &lt;code&gt;DeleteFile&lt;/code&gt; 기능에 해당합니다. 그 참고이 &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;미래에 변경 될 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c94bdac48da7a0fc40fd1e5a086497b625f64825" translate="yes" xml:space="preserve">
          <source>This function does &lt;strong&gt;not&lt;/strong&gt; follow symbolic links and it will simply remove the symbolic link itself.</source>
          <target state="translated">이 기능은 심볼릭 링크를 따르지 &lt;strong&gt;않으며&lt;/strong&gt; 단순히 심볼릭 링크 자체를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="977a8c203f0461d37e9d1afc3c85702bdcf54979" translate="yes" xml:space="preserve">
          <source>This function does not block.</source>
          <target state="translated">이 기능은 차단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99013d0e9f610e4b4ac531acb8d3cae6c5f35caf" translate="yes" xml:space="preserve">
          <source>This function does not provide any guarantees about whether it blocks waiting for data, but if an object needs to block for a read and cannot, it will typically signal this via an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; return value.</source>
          <target state="translated">이 함수는 데이터 대기를 차단할지 여부를 보장하지 않지만, 객체가 읽기를 위해 차단해야하고 차단할 수없는 경우 일반적으로 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 반환 값을 통해이를 신호 합니다.</target>
        </trans-unit>
        <trans-unit id="6f6f2506f47f0d38fd935eda8f1d3f32af31d36c" translate="yes" xml:space="preserve">
          <source>This function does not provide any guarantees about whether it blocks waiting for data, but if an object needs to block for a read but cannot it will typically signal this via an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; return value.</source>
          <target state="translated">이 함수는 데이터 대기를 차단하는지 여부에 대한 보장을 제공하지 않지만 객체가 읽기를 차단해야하지만 일반적으로 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 반환 값을 통해 신호를 보내지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c9eb6fee31ded1ada354009451436d0884930106" translate="yes" xml:space="preserve">
          <source>This function does not provide any guarantees with respect to the ordering of whether contentious readers or writers will acquire the lock first.</source>
          <target state="translated">이 기능은 논쟁적인 독자 또는 작가가 우선 잠금을 획득 할 것인지의 순서와 관련하여 어떠한 보장도 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="710d2720b9947751fee0e57d2b8d496c47712e72" translate="yes" xml:space="preserve">
          <source>This function does not resolve trait objects, meaning that &lt;code&gt;type_name_of_val(&amp;amp;7u32 as &amp;amp;dyn Debug)&lt;/code&gt; may return &lt;code&gt;&quot;dyn Debug&quot;&lt;/code&gt;, but not &lt;code&gt;&quot;u32&quot;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 특성 객체를 확인하지 않습니다. 즉, &lt;code&gt;type_name_of_val(&amp;amp;7u32 as &amp;amp;dyn Debug)&lt;/code&gt; 는 &lt;code&gt;&quot;dyn Debug&quot;&lt;/code&gt; 를 반환 할 수 있지만 &lt;code&gt;&quot;u32&quot;&lt;/code&gt; 는 반환 하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4305826482cc10423eedc0c48122ffd5b51fb63b" translate="yes" xml:space="preserve">
          <source>This function doesn't create the file if it doesn't exist. Use the &lt;a href=&quot;#method.create&quot;&gt;&lt;code&gt;create&lt;/code&gt;&lt;/a&gt; method to do so.</source>
          <target state="translated">이 함수는 파일이 존재하지 않으면 파일을 생성하지 않습니다. 그렇게 하려면 &lt;a href=&quot;#method.create&quot;&gt; &lt;code&gt;create&lt;/code&gt; &lt;/a&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="33592db8fb3f9eb9295ccd92b371a923eae06e5a" translate="yes" xml:space="preserve">
          <source>This function doesn't create the file if it doesn't exist. Use the &lt;a href=&quot;struct.openoptions#method.create&quot;&gt;&lt;code&gt;OpenOptions::create&lt;/code&gt;&lt;/a&gt; method to do so.</source>
          <target state="translated">이 함수는 파일이없는 경우 생성하지 않습니다. 그렇게 하려면 &lt;a href=&quot;struct.openoptions#method.create&quot;&gt; &lt;code&gt;OpenOptions::create&lt;/code&gt; &lt;/a&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2ecd58992bf3950332fa012ed014d7ac0b8bc7f" translate="yes" xml:space="preserve">
          <source>This function first gets the total length of the slice. Then it asserts that the index given as a parameter is within the slice by checking whether it&amp;rsquo;s less than or equal to the length. The assertion means that if we pass an index that is greater than the index to split the slice at, the function will panic before it attempts to use that index.</source>
          <target state="translated">이 함수는 먼저 슬라이스의 전체 길이를 가져옵니다. 그런 다음 매개 변수로 제공된 인덱스가 길이보다 작거나 같은지 확인하여 슬라이스 내에 있다고 주장합니다. 어설 션은 슬라이스를 분할하기 위해 인덱스보다 큰 인덱스를 전달하면 해당 인덱스를 사용하기 전에 함수가 패닉 상태임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ef704585a456099301abe7c7cdfceffbef996018" translate="yes" xml:space="preserve">
          <source>This function first gets the total length of the slice. Then it asserts that the index given as a parameter is within the slice by checking whether it&amp;rsquo;s less than or equal to the length. The assertion means that if we pass an index that is greater than the length to split the slice at, the function will panic before it attempts to use that index.</source>
          <target state="translated">이 함수는 먼저 슬라이스의 총 길이를 가져옵니다. 그런 다음 매개 변수로 제공된 인덱스가 길이보다 작거나 같은지 확인하여 슬라이스 내에 있다고 주장합니다. 단언은 슬라이스를 분할 할 길이보다 큰 인덱스를 전달하면 해당 인덱스를 사용하려고 시도하기 전에 함수가 패닉 상태가됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="457e092a949142d636a9e03fab0c159238f5daa4" translate="yes" xml:space="preserve">
          <source>This function forwards calls to the &lt;a href=&quot;trait.globalalloc#method.alloc_zeroed&quot;&gt;&lt;code&gt;GlobalAlloc::alloc_zeroed&lt;/code&gt;&lt;/a&gt; method of the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="translated">이 함수는 호출을 &lt;a href=&quot;trait.globalalloc#method.alloc_zeroed&quot;&gt; &lt;code&gt;GlobalAlloc::alloc_zeroed&lt;/code&gt; &lt;/a&gt; 전달합니다. &lt;code&gt;#[global_allocator]&lt;/code&gt; 속성 또는 &lt;code&gt;std&lt;/code&gt; crate의 기본값 이있는 경우 # [global_allocator] 속성으로 등록 된 할당 메소드로 .</target>
        </trans-unit>
        <trans-unit id="dac6968f4833b95b4cfc0a37edb3317e41dafb8d" translate="yes" xml:space="preserve">
          <source>This function forwards calls to the &lt;a href=&quot;trait.globalalloc#method.realloc&quot;&gt;&lt;code&gt;GlobalAlloc::realloc&lt;/code&gt;&lt;/a&gt; method of the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="translated">이 함수는 호출을 &lt;a href=&quot;trait.globalalloc#method.realloc&quot;&gt; &lt;code&gt;GlobalAlloc::realloc&lt;/code&gt; &lt;/a&gt; 전달합니다. &lt;code&gt;#[global_allocator]&lt;/code&gt; 속성 또는 &lt;code&gt;std&lt;/code&gt; crate의 기본값 이있는 경우 # [global_allocator] 속성으로 등록 된 할당 메소드로 .</target>
        </trans-unit>
        <trans-unit id="0ee226de8b2847b4bcaa66f0141bab39ef9c2e4e" translate="yes" xml:space="preserve">
          <source>This function forwards calls to the &lt;a href=&quot;trait.globalalloc#tymethod.alloc&quot;&gt;&lt;code&gt;GlobalAlloc::alloc&lt;/code&gt;&lt;/a&gt; method of the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="translated">이 함수는 에 할당 된 할당 자의 &lt;a href=&quot;trait.globalalloc#tymethod.alloc&quot;&gt; &lt;code&gt;GlobalAlloc::alloc&lt;/code&gt; &lt;/a&gt; 메소드로 호출을 전달합니다 . &lt;code&gt;#[global_allocator]&lt;/code&gt; 속성 또는 &lt;code&gt;std&lt;/code&gt; crate의 기본값 이있는 경우 # [global_allocator] 속성으로 .</target>
        </trans-unit>
        <trans-unit id="43408a3e60cf657f5104a853eae37001a5663e2b" translate="yes" xml:space="preserve">
          <source>This function forwards calls to the &lt;a href=&quot;trait.globalalloc#tymethod.dealloc&quot;&gt;&lt;code&gt;GlobalAlloc::dealloc&lt;/code&gt;&lt;/a&gt; method of the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="translated">이 함수는 에 할당 된 할당 자의 &lt;a href=&quot;trait.globalalloc#tymethod.dealloc&quot;&gt; &lt;code&gt;GlobalAlloc::dealloc&lt;/code&gt; &lt;/a&gt; 메소드로 호출을 전달합니다 . &lt;code&gt;#[global_allocator]&lt;/code&gt; 속성 또는 &lt;code&gt;std&lt;/code&gt; crate의 기본값 이있는 경우 # [global_allocator] 속성으로 .</target>
        </trans-unit>
        <trans-unit id="438ebff47f84838c22c79fbc8bfdda182cd513dc" translate="yes" xml:space="preserve">
          <source>This function gets called when a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; gets dropped.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; 가 삭제.</target>
        </trans-unit>
        <trans-unit id="13819f0b7aa144e5ea6bcb9cc9f9a6808e198851" translate="yes" xml:space="preserve">
          <source>This function has the same error semantics as &lt;a href=&quot;#method.read_until&quot;&gt;&lt;code&gt;read_until&lt;/code&gt;&lt;/a&gt; and will also return an error if the read bytes are not valid UTF-8. If an I/O error is encountered then &lt;code&gt;buf&lt;/code&gt; may contain some bytes already read in the event that all data read so far was valid UTF-8.</source>
          <target state="translated">이 함수는 오류 의미와 동일한 &lt;a href=&quot;#method.read_until&quot;&gt; &lt;code&gt;read_until&lt;/code&gt; &lt;/a&gt; 과 가지며 읽기 바이트가 유효한 UTF-8이 아닌 경우 오류를 리턴합니다. I / O 오류가 발생하면 &lt;code&gt;buf&lt;/code&gt; 는 지금까지 읽은 모든 데이터가 유효한 UTF-8 인 경우 이미 읽은 일부 바이트를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b30023fb932961fde08dc32d5756888772fda90" translate="yes" xml:space="preserve">
          <source>This function has the same error semantics as &lt;a href=&quot;trait.bufread#method.read_until&quot;&gt;&lt;code&gt;read_until&lt;/code&gt;&lt;/a&gt; and will also return an error if the read bytes are not valid UTF-8. If an I/O error is encountered then &lt;code&gt;buf&lt;/code&gt; may contain some bytes already read in the event that all data read so far was valid UTF-8.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;trait.bufread#method.read_until&quot;&gt; &lt;code&gt;read_until&lt;/code&gt; &lt;/a&gt; 과 동일한 오류 의미를 가지며 읽은 바이트가 유효한 UTF-8이 아닌 경우 오류를 반환합니다. I / O 오류가 발생 하면 지금까지 읽은 모든 데이터가 유효한 UTF-8 인 경우 &lt;code&gt;buf&lt;/code&gt; 에 이미 읽은 바이트가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f52e89cf7de02d11dddd72bc5753735b903e55b9" translate="yes" xml:space="preserve">
          <source>This function has the same safety guarantees as the &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;Iterator::size_hint&lt;/code&gt; &lt;/a&gt; 함수 와 동일한 안전성을 보장 합니다.</target>
        </trans-unit>
        <trans-unit id="adea46a33368b546562d3adbbc93c24db07769c5" translate="yes" xml:space="preserve">
          <source>This function has the same safety guarantees as the &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;size_hint&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;size_hint&lt;/code&gt; &lt;/a&gt; 함수합니다.</target>
        </trans-unit>
        <trans-unit id="1b144c49949055dde44dc3050173804acf39c11f" translate="yes" xml:space="preserve">
          <source>This function internally uses the &lt;a href=&quot;#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt; method on this trait and hence will continuously write data so long as no errors are received. This also means that partial writes are not indicated in this signature.</source>
          <target state="translated">이 기능은 내부적으로 &lt;a href=&quot;#method.write_all&quot;&gt; &lt;code&gt;write_all&lt;/code&gt; &lt;/a&gt;으로이 특성에 write_all 메소드를하므로 오류가 수신되지 않는 한 지속적으로 데이터를 작성합니다. 또한이 서명에는 부분 쓰기가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66530779d87bba553e9df64d147255f7af9fe886" translate="yes" xml:space="preserve">
          <source>This function internally uses the &lt;a href=&quot;trait.write#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt; method on this trait and hence will continuously write data so long as no errors are received. This also means that partial writes are not indicated in this signature.</source>
          <target state="translated">이 함수는 내부적 으로이 특성에 대해 &lt;a href=&quot;trait.write#method.write_all&quot;&gt; &lt;code&gt;write_all&lt;/code&gt; &lt;/a&gt; 메소드를 사용 하므로 오류가 수신되지 않는 한 계속해서 데이터를 기록합니다. 이것은 또한 부분 쓰기가이 서명에 표시되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1f9b7d260474b82b56786f2b96849de01b420191" translate="yes" xml:space="preserve">
          <source>This function is a lower-level call. It needs to be paired with the &lt;a href=&quot;#tymethod.consume&quot;&gt;&lt;code&gt;consume&lt;/code&gt;&lt;/a&gt; method to function properly. When calling this method, none of the contents will be &quot;read&quot; in the sense that later calling &lt;code&gt;read&lt;/code&gt; may return the same contents. As such, &lt;a href=&quot;#tymethod.consume&quot;&gt;&lt;code&gt;consume&lt;/code&gt;&lt;/a&gt; must be called with the number of bytes that are consumed from this buffer to ensure that the bytes are never returned twice.</source>
          <target state="translated">이 기능은 하위 수준 호출입니다. 올바르게 작동 하려면 &lt;a href=&quot;#tymethod.consume&quot;&gt; &lt;code&gt;consume&lt;/code&gt; r&lt;/a&gt; 메소드 와 쌍을 이루어야합니다 . 이 메소드를 호출 할 때, 나중에 호출을 &lt;code&gt;read&lt;/code&gt; 는 의미에서 어떤 내용도 &quot;읽지&quot;않습니다. 하면 동일한 내용을 반환 할 수 . 따라서&lt;a href=&quot;#tymethod.consume&quot;&gt; &lt;code&gt;consume&lt;/code&gt; &lt;/a&gt;바이트가 두 번 리턴되지 않도록이 버퍼에서 소비 된 바이트 수로 소비 를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="1da3425b653a05b924f0c013401f366dcdf5aa2c" translate="yes" xml:space="preserve">
          <source>This function is a lower-level call. It needs to be paired with the &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt; method to function properly. This function does not perform any I/O, it simply informs this object that some amount of its buffer, returned from &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;, has been consumed and should no longer be returned. As such, this function may do odd things if &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt; isn't called before calling it.</source>
          <target state="translated">이 기능은 하위 수준 호출입니다. 올바르게 작동 하려면 &lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt; 메소드 와 쌍을 이루어야 합니다. 이 함수는 I / O를 수행하지 않으며, &lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt; 에서 리턴 된 일부 버퍼 가 소비되어 더 이상 리턴되지 않아야 함을 이 오브젝트에 알립니다 . 따라서이 기능은 다음과 같은 경우 이상한 일을 할 수 있습니다&lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt; 가 호출되기 전에 호출되지 않으면수 있습니다.</target>
        </trans-unit>
        <trans-unit id="854ee5963ab7cb501fb556356449a0a75bec7aa8" translate="yes" xml:space="preserve">
          <source>This function is a lower-level call. It needs to be paired with the &lt;a href=&quot;trait.bufread#tymethod.consume&quot;&gt;&lt;code&gt;consume&lt;/code&gt;&lt;/a&gt; method to function properly. When calling this method, none of the contents will be &quot;read&quot; in the sense that later calling &lt;code&gt;read&lt;/code&gt; may return the same contents. As such, &lt;a href=&quot;trait.bufread#tymethod.consume&quot;&gt;&lt;code&gt;consume&lt;/code&gt;&lt;/a&gt; must be called with the number of bytes that are consumed from this buffer to ensure that the bytes are never returned twice.</source>
          <target state="translated">이 함수는 하위 수준 호출입니다. 제대로 작동 하려면 &lt;a href=&quot;trait.bufread#tymethod.consume&quot;&gt; &lt;code&gt;consume&lt;/code&gt; &lt;/a&gt; 메소드 와 쌍을 이루어야합니다 . 이 메서드를 호출 할 때 나중에 &lt;code&gt;read&lt;/code&gt; 를 호출 하면 동일한 내용을 반환 할 수 있다는 점에서 어떤 내용도 &quot;읽지&quot; 않습니다. 따라서, &lt;a href=&quot;trait.bufread#tymethod.consume&quot;&gt; &lt;code&gt;consume&lt;/code&gt; &lt;/a&gt; 바이트 두 번 반환되지 않습니다 수 있도록이 버퍼에서 소비되는 바이트 수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="579c281433d14ce69320e4d857132a7a2c6352d3" translate="yes" xml:space="preserve">
          <source>This function is a lower-level call. It needs to be paired with the &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt; method to function properly. This function does not perform any I/O, it simply informs this object that some amount of its buffer, returned from &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;, has been consumed and should no longer be returned. As such, this function may do odd things if &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt; isn't called before calling it.</source>
          <target state="translated">이 함수는 하위 수준 호출입니다. 제대로 작동 하려면 &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt; 메소드 와 쌍을 이루어야 합니다. 이 함수는 I / O를 수행하지 않으며, &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt; 에서 반환 된 버퍼의 일부 가 사용되었으며 더 이상 반환되지 않아야 한다고이 객체에 알립니다 . &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt; 함수는 호출하기 전에 fill_buf 를 호출하지 않으면 이상한 일을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="415a263593c43f00d8f5a632e9e771b274ca8329" translate="yes" xml:space="preserve">
          <source>This function is a no-op, and does not even read from &lt;code&gt;dummy&lt;/code&gt;.</source>
          <target state="translated">이 기능은 작동하지 않으며 읽을 수 없습니다. &lt;code&gt;dummy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04e44698b394de41883f1cf69eb125285be21b0e" translate="yes" xml:space="preserve">
          <source>This function is also unsafe as the primitives currently returned have the contract that they are the sole owner of the file descriptor they are wrapping. Usage of this function could accidentally allow violating this contract which can cause memory unsafety in code that relies on it being true.</source>
          <target state="translated">이 함수는 현재 반환 된 프리미티브가 랩핑하는 파일 디스크립터의 유일한 소유자라는 계약을 가지고 있기 때문에 안전하지 않습니다. 이 기능을 사용하면 실수로이 계약을 위반할 수 있으며 이로 인해 코드에 의존하는 코드에서 메모리 안전 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f34531fffd31ebc3903cc0f2c5f5bc232a9d53da" translate="yes" xml:space="preserve">
          <source>This function is blocking and should be used carefully: it is possible for an attacker to continuously send bytes without ever sending a newline or EOF.</source>
          <target state="translated">이 함수는 차단되며 신중하게 사용해야합니다. 공격자가 개행 문자 나 EOF를 보내지 않고 계속해서 바이트를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="767fc2a16ab91407b9680a74099aea95b9c90341" translate="yes" xml:space="preserve">
          <source>This function is blocking and should be used carefully: it is possible for an attacker to continuously send bytes without ever sending the delimiter or EOF.</source>
          <target state="translated">이 함수는 블로킹이므로 신중하게 사용해야합니다. 공격자가 구분 기호 나 EOF를 보내지 않고 계속해서 바이트를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4f07981812bfb90d5d613f3cd12334bfad99018" translate="yes" xml:space="preserve">
          <source>This function is blocking, and should not be used in &lt;code&gt;async&lt;/code&gt; functions.</source>
          <target state="translated">이 기능은 차단 &lt;code&gt;async&lt;/code&gt; 기능에 사용하면 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="2491a3d7b07b5d574df89b38429aea33453977ac" translate="yes" xml:space="preserve">
          <source>This function is different from &lt;a href=&quot;../../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt; which directly yields to the system's scheduler, whereas &lt;code&gt;spin_loop_hint&lt;/code&gt; does not interact with the operating system.</source>
          <target state="translated">이 함수는 시스템의 스케줄러에 직접 양보하는 &lt;a href=&quot;../../thread/fn.yield_now&quot;&gt; &lt;code&gt;std::thread::yield_now&lt;/code&gt; &lt;/a&gt; 와 다른 반면 &lt;code&gt;spin_loop_hint&lt;/code&gt; 는 운영 체제와 상호 작용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98d00324eb55b3a641f30a2bb642d7084ef611a4" translate="yes" xml:space="preserve">
          <source>This function is different from &lt;a href=&quot;../thread/fn.yield_now&quot;&gt;&lt;code&gt;thread::yield_now&lt;/code&gt;&lt;/a&gt; which directly yields to the system's scheduler, whereas &lt;code&gt;spin_loop&lt;/code&gt; does not interact with the operating system.</source>
          <target state="translated">이 함수는 시스템의 스케줄러에 직접 양보하는 &lt;a href=&quot;../thread/fn.yield_now&quot;&gt; &lt;code&gt;thread::yield_now&lt;/code&gt; &lt;/a&gt; 와 다른 반면 &lt;code&gt;spin_loop&lt;/code&gt; 는 운영 체제와 상호 작용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2844b634a91113f81bf8561b54a56d96807ba95f" translate="yes" xml:space="preserve">
          <source>This function is different than &lt;a href=&quot;../../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt; which directly yields to the system's scheduler, whereas &lt;code&gt;spin_loop_hint&lt;/code&gt; only signals the processor that it is entering a busy-wait spin-loop without yielding control to the system's scheduler.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;../../thread/fn.yield_now&quot;&gt; &lt;code&gt;std::thread::yield_now&lt;/code&gt; &lt;/a&gt; 시스템 스케줄러에 직접 양보하는 반면 &lt;code&gt;spin_loop_hint&lt;/code&gt; 는 시스템 스케줄러에 대한 제어를 제공하지 않고 프로세서에게 통화 중 대기 스핀 루프로 들어간다는 신호 만 보냅니다.</target>
        </trans-unit>
        <trans-unit id="98f804e178831934e2704907d9977fcb07b49649" translate="yes" xml:space="preserve">
          <source>This function is different than &lt;a href=&quot;../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt; which directly yields to the system's scheduler, whereas &lt;code&gt;spin_loop&lt;/code&gt; only signals the processor that it is entering a busy-wait spin-loop without yielding control to the system's scheduler.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;../thread/fn.yield_now&quot;&gt; &lt;code&gt;std::thread::yield_now&lt;/code&gt; &lt;/a&gt; 시스템 스케줄러에 직접 양보하는 반면 &lt;code&gt;spin_loop&lt;/code&gt; 는 시스템 스케줄러에 대한 제어를 제공하지 않고 프로세서가 통화 중 대기 스핀 루프에 진입하고 있음을 프로세서에만 신호로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="41b9515d2076760cfa3f4b5d6d17d095ddb905fd" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of &lt;a href=&quot;../../hint/fn.spin_loop&quot;&gt;&lt;code&gt;hint::spin_loop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;../../hint/fn.spin_loop&quot;&gt; &lt;code&gt;hint::spin_loop&lt;/code&gt; &lt;/a&gt; 대신 사용되지 않을 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="467a74dd68a231eab8ded24aa170197676eb9466" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;alloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">이 기능은 추천되지 않게 될 것으로 예상된다 &lt;code&gt;alloc&lt;/code&gt; 의 방법 &lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt; IT 및 유형 &lt;a href=&quot;trait.alloc&quot;&gt; &lt;code&gt;Alloc&lt;/code&gt; &lt;/a&gt; 안정 될 특징.</target>
        </trans-unit>
        <trans-unit id="b99b444be238e8b895735ba0a1305ae0f8a074c7" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;alloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.allocator&quot;&gt;&lt;code&gt;Allocator&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt; 유형 의 &lt;code&gt;alloc&lt;/code&gt; 방법 과 &lt;a href=&quot;trait.allocator&quot;&gt; &lt;code&gt;Allocator&lt;/code&gt; &lt;/a&gt; 특성이 안정 되면 더 이상 사용되지 않을 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="af165703deff9d928fee107e2b077ae27c60ea8e" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;alloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.allocref&quot;&gt;&lt;code&gt;AllocRef&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt; 타입 의 &lt;code&gt;alloc&lt;/code&gt; 메소드 와 &lt;a href=&quot;trait.allocref&quot;&gt; &lt;code&gt;AllocRef&lt;/code&gt; 트레이 트&lt;/a&gt; 가 안정 되면 더 이상 사용되지 않을 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="6654c3116763d1cd428eebcad450e10896b561da" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;alloc_zeroed&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;trait.alloc&quot;&gt; &lt;code&gt;Alloc&lt;/code&gt; &lt;/a&gt; 특성이 안정 될 때 &lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt; 유형 의 &lt;code&gt;alloc_zeroed&lt;/code&gt; 메소드를 위해 더 이상 사용되지 않을 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="c7978c6c99bcb0bfa61713bb6f008fffa8ca6068" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;alloc_zeroed&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.allocator&quot;&gt;&lt;code&gt;Allocator&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">이 함수 와 &lt;a href=&quot;trait.allocator&quot;&gt; &lt;code&gt;Allocator&lt;/code&gt; &lt;/a&gt; &lt;code&gt;alloc_zeroed&lt;/code&gt; 가 안정 되면 &lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt; 유형 의 alloc_zeroed 메소드를 사용하기 위해 더 이상 사용되지 않을 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="bcbf3e248baf2acbd0ca22a0a9243de796c9b484" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;alloc_zeroed&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.allocref&quot;&gt;&lt;code&gt;AllocRef&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">이 함수 와 &lt;a href=&quot;trait.allocref&quot;&gt; &lt;code&gt;AllocRef&lt;/code&gt; 트레이 트&lt;/a&gt; 가 안정 되면 &lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt; 유형 의 &lt;code&gt;alloc_zeroed&lt;/code&gt; 메서드를 선호하여 더 이상 사용되지 않을 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="0400d9b530af2cdc75200e564b1d3df4717e5b0d" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;dealloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">이 기능은 추천되지 않게 될 것으로 예상된다 &lt;code&gt;dealloc&lt;/code&gt; 의 방법 &lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt; IT 및 유형 &lt;a href=&quot;trait.alloc&quot;&gt; &lt;code&gt;Alloc&lt;/code&gt; &lt;/a&gt; 안정 될 특징.</target>
        </trans-unit>
        <trans-unit id="a8b61d41d166bb1c78751280bc5439d73580399f" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;dealloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.allocator&quot;&gt;&lt;code&gt;Allocator&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt; 유형 의 &lt;code&gt;dealloc&lt;/code&gt; 메소드 와 &lt;a href=&quot;trait.allocator&quot;&gt; &lt;code&gt;Allocator&lt;/code&gt; &lt;/a&gt; 트레이 트가 안정 되면 더 이상 사용되지 않을 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ed58253cb2bb6abe90cf553f72f373e1d0723cc" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;dealloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.allocref&quot;&gt;&lt;code&gt;AllocRef&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">이 함수 와 &lt;a href=&quot;trait.allocref&quot;&gt; &lt;code&gt;AllocRef&lt;/code&gt; 트레이 트&lt;/a&gt; 가 안정 되면 &lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt; 유형 의 &lt;code&gt;dealloc&lt;/code&gt; 메소드를 선호하여 더 이상 사용되지 않을 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c9fc6e063817eb54b121ff88e105f246093f7ff" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;realloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;trait.alloc&quot;&gt; &lt;code&gt;Alloc&lt;/code&gt; &lt;/a&gt; 특성이 안정 될 때 &lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt; 유형 의 &lt;code&gt;realloc&lt;/code&gt; 방법을 위해 사용되지 않을 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="15aa09ac5eb8ebd0a5e1dff85588ffec210b0c21" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;realloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.allocator&quot;&gt;&lt;code&gt;Allocator&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt; 유형 의 &lt;code&gt;realloc&lt;/code&gt; 메소드 와 &lt;a href=&quot;trait.allocator&quot;&gt; &lt;code&gt;Allocator&lt;/code&gt; &lt;/a&gt; 트레이 트가 안정 되면 더 이상 사용되지 않을 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa62f51911ddb19be8f5aa47587e29e20dee089f" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;realloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.allocref&quot;&gt;&lt;code&gt;AllocRef&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt; 유형 의 &lt;code&gt;realloc&lt;/code&gt; 메소드 와 &lt;a href=&quot;trait.allocref&quot;&gt; &lt;code&gt;AllocRef&lt;/code&gt; &lt;/a&gt; 특성이 안정 되면 더 이상 사용되지 않을 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="5b11361fb076bd1f28fd827ccd142c64af2b467e" translate="yes" xml:space="preserve">
          <source>This function is just a shim intended to be removed when the &lt;code&gt;unsized_locals&lt;/code&gt; feature gets stabilized.</source>
          <target state="translated">이 기능은 &lt;code&gt;unsized_locals&lt;/code&gt; 기능이 안정화 될 때 제거하기위한 심입니다 .</target>
        </trans-unit>
        <trans-unit id="bc7e9741757bc42e41e144d227e772dfb6ad20fc" translate="yes" xml:space="preserve">
          <source>This function is mainly useful for data that lives for the remainder of the program's life. Dropping the returned reference will cause a memory leak.</source>
          <target state="translated">이 기능은 프로그램의 남은 수명 동안 유지되는 데이터에 주로 유용합니다. 반환 된 참조를 삭제하면 메모리 누수가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="177431c922c0d0a7a204582e17b86736e812c93b" translate="yes" xml:space="preserve">
          <source>This function is mainly useful for data that lives for the remainder of the program's life. Dropping the returned reference will cause a memory leak. If this is not acceptable, the reference should first be wrapped with the &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::from_raw&lt;/code&gt;&lt;/a&gt; function producing a &lt;code&gt;Box&lt;/code&gt;. This &lt;code&gt;Box&lt;/code&gt; can then be dropped which will properly destroy &lt;code&gt;T&lt;/code&gt; and release the allocated memory.</source>
          <target state="translated">이 기능은 주로 프로그램 수명의 나머지 기간 동안 유지되는 데이터에 유용합니다. 반환 된 참조를 삭제하면 메모리 누수가 발생합니다. 이것이 허용되지 않으면, 참조는 먼저 &lt;a href=&quot;struct.box#method.from_raw&quot;&gt; &lt;code&gt;Box::from_raw&lt;/code&gt; &lt;/a&gt; 함수로 감싸서 &lt;code&gt;Box&lt;/code&gt; 를 생성해야합니다 . 그런 다음 이 &lt;code&gt;Box&lt;/code&gt; 를 떨어 뜨려서 &lt;code&gt;T&lt;/code&gt; 를 올바르게 파괴 하고 할당 된 메모리를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="59cb1896e3dcd115f785bf2479cb4580b1b9722d" translate="yes" xml:space="preserve">
          <source>This function is not magic; it is literally defined as</source>
          <target state="translated">이 기능은 마술이 아닙니다. 말 그대로 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="cc2ffe8b61942162bfcfde0b12c33ce86e8880cb" translate="yes" xml:space="preserve">
          <source>This function is only safe to call if the following conditions hold:</source>
          <target state="translated">이 함수는 다음 조건이 충족되는 경우에만 호출해도 안전합니다.</target>
        </trans-unit>
        <trans-unit id="eeccb3e706f48a212133104a654e31843b7b7b92" translate="yes" xml:space="preserve">
          <source>This function is primarily used for optimization purposes.</source>
          <target state="translated">이 기능은 주로 최적화 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="93c7910f6179639ce884370e8d94a5595d080311" translate="yes" xml:space="preserve">
          <source>This function is primarily useful for allowing byte-wise pointer arithmetic on potentially fat pointers:</source>
          <target state="translated">이 함수는 잠재적으로 뚱뚱한 포인터에 대해 바이트 단위 포인터 산술을 허용하는 데 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1cd0464bff7e9c8dd1499717db18b2f31952ba8c" translate="yes" xml:space="preserve">
          <source>This function is safe, but actually using the return value is unsafe. See the documentation of &lt;a href=&quot;../slice/fn.from_raw_parts&quot;&gt;&lt;code&gt;slice::from_raw_parts&lt;/code&gt;&lt;/a&gt; for slice safety requirements.</source>
          <target state="translated">이 함수는 안전하지만 실제로 반환 값을 사용하는 것은 안전하지 않습니다. 슬라이스 안전 요구 사항 은 &lt;a href=&quot;../slice/fn.from_raw_parts&quot;&gt; &lt;code&gt;slice::from_raw_parts&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="47c5699202ba358abe356e82ca7c6c5715bfdeae" translate="yes" xml:space="preserve">
          <source>This function is safe, but actually using the return value is unsafe. See the documentation of &lt;a href=&quot;../slice/fn.from_raw_parts_mut&quot;&gt;&lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt;&lt;/a&gt; for slice safety requirements.</source>
          <target state="translated">이 함수는 안전하지만 실제로 반환 값을 사용하는 것은 안전하지 않습니다. 슬라이스 안전 요구 사항 은 &lt;a href=&quot;../slice/fn.from_raw_parts_mut&quot;&gt; &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="451ae39575c352f08886704c7ffa48d2181b8a99" translate="yes" xml:space="preserve">
          <source>This function is safe, but dereferencing the return value is unsafe. See the documentation of &lt;a href=&quot;../slice/fn.from_raw_parts&quot;&gt;&lt;code&gt;slice::from_raw_parts&lt;/code&gt;&lt;/a&gt; for slice safety requirements.</source>
          <target state="translated">이 함수는 안전하지만 반환 값을 역 참조하는 것은 안전하지 않습니다. 슬라이스 안전 요구 사항 은 &lt;a href=&quot;../slice/fn.from_raw_parts&quot;&gt; &lt;code&gt;slice::from_raw_parts&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a4d03cae95a52ccbe2043ee8d63640e5a40a11f" translate="yes" xml:space="preserve">
          <source>This function is safe, even when the non-null raw slice cannot be dereferenced to a slice because the pointer does not have a valid address.</source>
          <target state="translated">이 함수는 포인터에 유효한 주소가 없기 때문에 널이 아닌 원시 슬라이스를 슬라이스로 역 참조 할 수없는 경우에도 안전합니다.</target>
        </trans-unit>
        <trans-unit id="f368bea1b2408b163770a1c33d9edf8ea07be6d6" translate="yes" xml:space="preserve">
          <source>This function is safe, even when the raw slice cannot be cast to a slice reference because the pointer is null or unaligned.</source>
          <target state="translated">이 함수는 포인터가 null이거나 정렬되지 않았기 때문에 원시 슬라이스를 슬라이스 참조로 캐스트 할 수없는 경우에도 안전합니다.</target>
        </trans-unit>
        <trans-unit id="9a9053fe38824d2de0054cbaba771d8a6b62c54f" translate="yes" xml:space="preserve">
          <source>This function is semantically equivalent to &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt; except that it operates on raw pointers instead of references. When references are available, &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt; should be preferred.</source>
          <target state="translated">이 함수는 의미 적으로 &lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt; 동일하지만 참조 대신 원시 포인터에서 작동한다는 점이 다릅니다. 참조가 가능하면 &lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt; 를 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bc2ee69e11ff49cf8f44aa7be972ea956317ef2" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;a href=&quot;struct.file#method.sync_all&quot;&gt;&lt;code&gt;sync_all&lt;/code&gt;&lt;/a&gt;, except that it may not synchronize file metadata to the filesystem.</source>
          <target state="translated">이 함수는 파일 메타 데이터를 파일 시스템과 동기화하지 않을 수 있다는 점을 제외하고 &lt;a href=&quot;struct.file#method.sync_all&quot;&gt; &lt;code&gt;sync_all&lt;/code&gt; &lt;/a&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="c9cbe9f2a91fb1ea199b620a6bb920ab34b40788" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;wake&lt;/code&gt;, but must not consume the provided data pointer.</source>
          <target state="translated">이 함수는 &lt;code&gt;wake&lt;/code&gt; 와 유사 하지만 제공된 데이터 포인터를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="3817c9c59ae829a4e4b6db71acecc27e54fc335a" translate="yes" xml:space="preserve">
          <source>This function is similar to the &lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt;&lt;code&gt;leak&lt;/code&gt;&lt;/a&gt; function on &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt; except that there is no way to recover the leaked memory.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt; &lt;code&gt;leak&lt;/code&gt; &lt;/a&gt; 된 메모리를 복구 할 방법이 없다는 점을 제외하면 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; 의 누수 함수 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="a4ebf22d46bf6517393acc377fdd446867946954" translate="yes" xml:space="preserve">
          <source>This function is similar to the &lt;code&gt;leak&lt;/code&gt; function on &lt;code&gt;Box&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;code&gt;Box&lt;/code&gt; 의 &lt;code&gt;leak&lt;/code&gt; 기능 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="b2a62d49d2d0f2fe0fb6a0071ccf5e43d3885dc1" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;#method.to_bytes&quot;&gt;&lt;code&gt;to_bytes&lt;/code&gt;&lt;/a&gt; except that it will retain the trailing nul terminator instead of chopping it off.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#method.to_bytes&quot;&gt; &lt;code&gt;to_bytes&lt;/code&gt; 와&lt;/a&gt; 동일합니다. 단, 종료하지 않고 후미 널 종결자를 유지한다는 점이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="aa81adf357f1575ab28bd1d9c5804caf46b4ba04" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;struct.cstr#method.to_bytes&quot;&gt;&lt;code&gt;CStr::to_bytes&lt;/code&gt;&lt;/a&gt; except that it will retain the trailing nul terminator instead of chopping it off.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;struct.cstr#method.to_bytes&quot;&gt; &lt;code&gt;CStr::to_bytes&lt;/code&gt; &lt;/a&gt; 동일하지만 후행 nul 종결 자를 잘라내 는 대신 유지합니다.</target>
        </trans-unit>
        <trans-unit id="bbca71aedd00db40d26ceff11e63bc8c656a9f3e" translate="yes" xml:space="preserve">
          <source>This function is the inverse of &lt;a href=&quot;#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;#method.offset&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt; 의 역수입니다 .</target>
        </trans-unit>
        <trans-unit id="60af8a75ca29fd4b9524979a42c65b475dac17ca" translate="yes" xml:space="preserve">
          <source>This function is the inverse of &lt;a href=&quot;#method.offset-1&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;#method.offset-1&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt; 의 역수입니다 .</target>
        </trans-unit>
        <trans-unit id="a968e659e413eae940af237b572b89fdec65a1f7" translate="yes" xml:space="preserve">
          <source>This function is the mirror of &lt;a href=&quot;#method.guaranteed_eq&quot;&gt;&lt;code&gt;guaranteed_eq&lt;/code&gt;&lt;/a&gt;, but not its inverse. There are pointer comparisons for which both functions return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 함수의 거울 &lt;a href=&quot;#method.guaranteed_eq&quot;&gt; &lt;code&gt;guaranteed_eq&lt;/code&gt; &lt;/a&gt; 아니라 그 반대. 두 함수가 모두 &lt;code&gt;false&lt;/code&gt; 를 반환하는 포인터 비교가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df5c6e62763bfc43519897ed41868fc1d62d6938" translate="yes" xml:space="preserve">
          <source>This function is the mirror of &lt;a href=&quot;#method.guaranteed_ne&quot;&gt;&lt;code&gt;guaranteed_ne&lt;/code&gt;&lt;/a&gt;, but not its inverse. There are pointer comparisons for which both functions return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 함수의 거울 &lt;a href=&quot;#method.guaranteed_ne&quot;&gt; &lt;code&gt;guaranteed_ne&lt;/code&gt; &lt;/a&gt; 아니라 그 반대. 두 함수가 모두 &lt;code&gt;false&lt;/code&gt; 를 반환하는 포인터 비교가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4e91aa4b5730d86849f9ad126912325901a438a" translate="yes" xml:space="preserve">
          <source>This function is unsafe as it does not verify the preconditions from &lt;a href=&quot;#method.from_size_align&quot;&gt;&lt;code&gt;Layout::from_size_align&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#method.from_size_align&quot;&gt; &lt;code&gt;Layout::from_size_align&lt;/code&gt; &lt;/a&gt; 에서 전제 조건을 확인하지 않으므로 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8570a34fff9bbf02e64d50247313e6b25b11941e" translate="yes" xml:space="preserve">
          <source>This function is unsafe as it does not verify the preconditions from &lt;a href=&quot;struct.layout#method.from_size_align&quot;&gt;&lt;code&gt;Layout::from_size_align&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;struct.layout#method.from_size_align&quot;&gt; &lt;code&gt;Layout::from_size_align&lt;/code&gt; &lt;/a&gt; 의 전제 조건을 확인하지 않으므로 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c0adf1d1fbca05371274b33d836dbb8ba3b0da96" translate="yes" xml:space="preserve">
          <source>This function is unsafe as there is no guarantee that the given pointer is valid for &lt;code&gt;len&lt;/code&gt; elements, nor whether the lifetime inferred is a suitable lifetime for the returned slice.</source>
          <target state="translated">주어진 포인터가 &lt;code&gt;len&lt;/code&gt; 요소에 유효 하거나 유추 된 수명이 반환 된 슬라이스에 적합한 수명인지 여부 가 보장되지 않으므로이 함수는 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ead8661237451bd45c2559207ff2f0d2dcefd5f7" translate="yes" xml:space="preserve">
          <source>This function is unsafe because improper use may lead to memory problems. For example, a double-free may occur if the function is called twice on the same raw pointer.</source>
          <target state="translated">이 기능은 잘못 사용하면 메모리 문제가 발생할 수 있으므로 안전하지 않습니다. 예를 들어, 동일한 원시 포인터에서 함수가 두 번 호출되면 double-free가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35f3e90c9d123dc330088febbcb755f29e299a96" translate="yes" xml:space="preserve">
          <source>This function is unsafe because improper use may lead to memory unsafety, even if the returned &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; is never accessed.</source>
          <target state="translated">이 함수는 반환 된 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 에 액세스하지 않더라도 부적절한 사용으로 인해 메모리가 안전하지 않을 수 있으므로 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8bd102f6698ee49286a5c128925e7efc3ca2420" translate="yes" xml:space="preserve">
          <source>This function is unsafe because improper use may lead to memory unsafety, even if the returned &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is never accessed.</source>
          <target state="translated">이 함수는 반환 된 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 에 액세스하지 않더라도 부적절한 사용으로 인해 메모리가 안전하지 않을 수 있으므로 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f0606f18b84a9d14096f66fc981df0b42c6d0bf" translate="yes" xml:space="preserve">
          <source>This function is unsafe because it does not check that the bytes passed to it are valid UTF-8. If this constraint is violated, it may cause memory unsafety issues with future users of the &lt;code&gt;String&lt;/code&gt;, as the rest of the standard library assumes that &lt;code&gt;String&lt;/code&gt;s are valid UTF-8.</source>
          <target state="translated">이 함수는 전달 된 바이트가 유효한 UTF-8인지 확인하지 않으므로 안전하지 않습니다. 이 제약 조건을 위반 하면 표준 라이브러리의 나머지 부분에서 &lt;code&gt;String&lt;/code&gt; 이 유효한 UTF-8 이라고 가정하므로 향후 &lt;code&gt;String&lt;/code&gt; 사용자에게 메모리 안전 문제가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36c2b1be1ffd545e988489f24fde5b599256ff94" translate="yes" xml:space="preserve">
          <source>This function is unsafe because it does not check that the bytes passed to it are valid UTF-8. If this constraint is violated, undefined behavior results, as the rest of Rust assumes that &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s are valid UTF-8.</source>
          <target state="translated">이 함수는 전달 된 바이트가 유효한 UTF-8인지 확인하지 않으므로 안전하지 않습니다. 이 제약 조건을 위반하면 Rust의 나머지 부분은 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 이 유효한 UTF-8 이라고 가정하므로 정의되지 않은 동작 결과 가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="d26d0eb0451d8006697165ba21e7f4a6d2affd96" translate="yes" xml:space="preserve">
          <source>This function is unsafe because undefined behavior can result if the caller does not ensure all of the following:</source>
          <target state="translated">호출자가 다음을 모두 보장하지 않으면 정의되지 않은 동작이 발생할 수 있으므로이 기능은 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42a04935e77664a45c1ca55344796f0f9622e5b5" translate="yes" xml:space="preserve">
          <source>This function is unsafe because undefined behavior can result if the caller does not ensure both:</source>
          <target state="translated">호출자가 두 가지 모두를 보장하지 않으면 정의되지 않은 동작이 발생할 수 있으므로이 함수는 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b81cd2be550f8d99eeb1700fa914c58868e2867c" translate="yes" xml:space="preserve">
          <source>This function is unsafe because undefined behavior can result if the caller does not ensure that &lt;code&gt;layout&lt;/code&gt; has non-zero size.</source>
          <target state="translated">호출자가 &lt;code&gt;layout&lt;/code&gt; 크기가 0 이 아닌지 확인하지 않으면 정의되지 않은 동작이 발생할 수 있으므로이 함수는 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="454ec0a5acadcaac0aa85170f5ed93cb46c13302" translate="yes" xml:space="preserve">
          <source>This function is unsafe for the same reasons as &lt;a href=&quot;fn.from_raw_parts&quot;&gt;&lt;code&gt;from_raw_parts&lt;/code&gt;&lt;/a&gt;, as well as not being able to provide a non-aliasing guarantee of the returned mutable slice. &lt;code&gt;data&lt;/code&gt; must be non-null and aligned even for zero-length slices as with &lt;a href=&quot;fn.from_raw_parts&quot;&gt;&lt;code&gt;from_raw_parts&lt;/code&gt;&lt;/a&gt;. The total size of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;&lt;strong&gt;bytes&lt;/strong&gt; in memory.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;fn.from_raw_parts&quot;&gt; &lt;code&gt;from_raw_parts&lt;/code&gt; &lt;/a&gt; 와 같은 이유로 안전하지 않으며 반환 된 가변 슬라이스의 앨리어싱 제거를 제공 할 수 없습니다. &lt;a href=&quot;fn.from_raw_parts&quot;&gt; &lt;code&gt;from_raw_parts&lt;/code&gt; &lt;/a&gt; 와 같이 길이가 0 인 슬라이스라도 &lt;code&gt;data&lt;/code&gt; 는 null이 아니고 정렬되어야합니다 . 슬라이스의 총 크기는 메모리의 &lt;code&gt;isize::MAX&lt;/code&gt; &lt;strong&gt;바이트&lt;/strong&gt; 보다 크지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="eecdc0e72496ca31779009b14276f9c964f0fc63" translate="yes" xml:space="preserve">
          <source>This function is unsafe for the same reasons that &lt;code&gt;alloc&lt;/code&gt; is.</source>
          <target state="translated">이 함수는 &lt;code&gt;alloc&lt;/code&gt; 과 같은 이유로 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f46ccfd28f902efc152ad3d0bc725d272999fa8f" translate="yes" xml:space="preserve">
          <source>This function is unsafe for the same reasons that &lt;code&gt;alloc&lt;/code&gt; is. However the allocated block of memory is guaranteed to be initialized.</source>
          <target state="translated">이 기능은 다음과 같은 이유로 안전하지 않습니다 &lt;code&gt;alloc&lt;/code&gt; . 그러나 할당 된 메모리 블록은 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="c8935ef267a58bf14edf52661928291938f416d8" translate="yes" xml:space="preserve">
          <source>This function is unsafe for the same reasons that &lt;code&gt;realloc&lt;/code&gt; is.</source>
          <target state="translated">이 기능은 &lt;code&gt;realloc&lt;/code&gt; 과 같은 이유로 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="010c54d09909e31d21b794c4e10275c4b255b332" translate="yes" xml:space="preserve">
          <source>This function is unsafe, as it may construct invalid &lt;code&gt;char&lt;/code&gt; values.</source>
          <target state="translated">이 함수는 유효하지 않은 &lt;code&gt;char&lt;/code&gt; 생성 할 수 있으므로 안전하지 않습니다. 값을 .</target>
        </trans-unit>
        <trans-unit id="71a1e970e4af15e1e28b626518e246fe2beaa9ff" translate="yes" xml:space="preserve">
          <source>This function is unsafe. You must guarantee that the data you return will not move so long as the argument value does not move (for example, because it is one of the fields of that value), and also that you do not move out of the argument you receive to the interior function.</source>
          <target state="translated">이 기능은 안전하지 않습니다. 인수 값이 이동하지 않는 한 (예를 들어, 해당 값의 필드 중 하나이므로) 반환하는 데이터가 이동하지 않으며 수신 한 인수에서 이동하지 않아야합니다. 내부 기능.</target>
        </trans-unit>
        <trans-unit id="39a3dbf4634bdba5a0505dade8771f96ac64c22f" translate="yes" xml:space="preserve">
          <source>This function is unsafe. You must guarantee that you will continue to treat the pointer &lt;code&gt;P&lt;/code&gt; as pinned after you call this function, so that the invariants on the &lt;code&gt;Pin&lt;/code&gt; type can be upheld. If the code using the resulting &lt;code&gt;P&lt;/code&gt; does not continue to maintain the pinning invariants that is a violation of the API contract and may lead to undefined behavior in later (safe) operations.</source>
          <target state="translated">이 기능은 안전하지 않습니다. 이 함수를 호출 한 후에도 포인터 &lt;code&gt;P&lt;/code&gt; 를 고정 된 상태로 계속 처리 하여 &lt;code&gt;Pin&lt;/code&gt; 유형 의 불변 값을 유지할 수 있도록해야합니다 . 결과를 사용하여 코드가 &lt;code&gt;P&lt;/code&gt; 를 가 API 계약을 위반하는 고정 고정 변수를 계속 유지하지 않고 이후 (안전한) 작업에서 정의되지 않은 동작을 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c0c82733953c468905548df35ad6822c84f6c7f" translate="yes" xml:space="preserve">
          <source>This function is unsafe. You must guarantee that you will never move the data out of the mutable reference you receive when you call this function, so that the invariants on the &lt;code&gt;Pin&lt;/code&gt; type can be upheld.</source>
          <target state="translated">이 기능은 안전하지 않습니다. 당신은 당신이에,이 함수를 호출 할 때받는 가변 기준에서 그래서 그 불변의 데이터를 이동하지 않을 것이라는 점을 보장해야한다 &lt;code&gt;Pin&lt;/code&gt; 유형 유지할 수 .</target>
        </trans-unit>
        <trans-unit id="a2e566f884f51c3384b3aa58f5bde7f2e2df2f79" translate="yes" xml:space="preserve">
          <source>This function is used to generically create I/O errors which do not originate from the OS itself. The &lt;code&gt;error&lt;/code&gt; argument is an arbitrary payload which will be contained in this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능은 일반적으로 OS 자체에서 발생하지 않는 I / O 오류를 생성하는 데 사용됩니다. &lt;code&gt;error&lt;/code&gt; 인수는이에 포함됩니다 임의의 페이로드 &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94b97e70917e2ec0dff12c2bd6e40f05c9be7d64" translate="yes" xml:space="preserve">
          <source>This function is used to generically create I/O errors which do not originate from the OS itself. The &lt;code&gt;error&lt;/code&gt; argument is an arbitrary payload which will be contained in this &lt;code&gt;Error&lt;/code&gt;.</source>
          <target state="translated">이 기능은 일반적으로 OS 자체에서 발생하지 않는 I / O 오류를 생성하는 데 사용됩니다. &lt;code&gt;error&lt;/code&gt; 인수는이에 포함됩니다 임의의 페이로드 &lt;code&gt;Error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5970a37a4fd89e4e4191139591e16ccec329bf2a" translate="yes" xml:space="preserve">
          <source>This function is useful for interacting with foreign interfaces which use two pointers to refer to a range of elements in memory, as is common in C++.</source>
          <target state="translated">이 함수는 C ++에서 일반적으로 사용되는 것처럼 메모리의 요소 범위를 참조하기 위해 두 개의 포인터를 사용하는 외부 인터페이스와 상호 작용하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0bf849f4d8fe700d85a6260475a19ac69c25acf8" translate="yes" xml:space="preserve">
          <source>This function is very easy to write, thanks to &lt;code&gt;match&lt;/code&gt;, and will look like Listing 6-5.</source>
          <target state="translated">이 기능은 &lt;code&gt;match&lt;/code&gt; 하기 때문에 쓰기가 매우 쉽습니다. Listing 6-5와 같다.</target>
        </trans-unit>
        <trans-unit id="19c2bab36fa633ea4bf26b73afdd5bd0e16edc9a" translate="yes" xml:space="preserve">
          <source>This function is, in some sense, the opposite of &lt;a href=&quot;#method.zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능은 어떤 의미에서는 &lt;a href=&quot;#method.zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt; 의 반대입니다. .</target>
        </trans-unit>
        <trans-unit id="a37c6f8dc5c32c647225cb24a1c4f508d03c0fdf" translate="yes" xml:space="preserve">
          <source>This function is, in some sense, the opposite of &lt;a href=&quot;trait.iterator#method.zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 어떤 의미에서 &lt;a href=&quot;trait.iterator#method.zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt; 과 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="2ee7b59ee419592da35ea7242eb2e8123baaf3cf" translate="yes" xml:space="preserve">
          <source>This function may &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; if it is used with more than one mutex over time.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt; 할 수 있습니다 ! 시간이 지남에 따라 둘 이상의 뮤텍스와 함께 사용되는 경우.</target>
        </trans-unit>
        <trans-unit id="f705e261edec6d4798f68322cebb8b5768877e5d" translate="yes" xml:space="preserve">
          <source>This function may fail as the underlying system clock is susceptible to drift and updates (e.g., the system clock could go backwards), so this function may not always succeed. If successful, &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; is returned where the duration represents the amount of time elapsed from this time measurement to the current time.</source>
          <target state="translated">기본 시스템 클럭이 드리프트 및 업데이트되기 쉬운 (예 : 시스템 클럭이 뒤로 갈 수 있음)이 기능이 실패 할 수 있으므로이 기능이 항상 성공하지 못할 수 있습니다. 성공하면 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 이 반환되며 여기서 지속 시간은이 시간 측정에서 현재 시간까지의 경과 시간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a43d8a17e850a82c732c367bf89a844d3d96e4fe" translate="yes" xml:space="preserve">
          <source>This function may fail because measurements taken earlier are not guaranteed to always be before later measurements (due to anomalies such as the system clock being adjusted either forwards or backwards).</source>
          <target state="translated">이 기능은 이전에 측정 한 값이 나중에 측정하기 전에 항상 보장되는 것은 아니기 때문에 (시스템 클럭이 앞뒤로 조정되는 등의 이상으로 인해) 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dd49c0cb240e2dbb52b64ec4b25e571052a70a5" translate="yes" xml:space="preserve">
          <source>This function may fail because measurements taken earlier are not guaranteed to always be before later measurements (due to anomalies such as the system clock being adjusted either forwards or backwards). &lt;a href=&quot;struct.instant&quot;&gt;&lt;code&gt;Instant&lt;/code&gt;&lt;/a&gt; can be used to measure elapsed time without this risk of failure.</source>
          <target state="translated">이 기능은 이전에 측정 한 값이 항상 이후 측정보다 앞선다고 보장 할 수 없기 때문에 실패 할 수 있습니다 (시스템 시계가 앞으로 또는 뒤로 조정되는 것과 같은 이상으로 인해). &lt;a href=&quot;struct.instant&quot;&gt; &lt;code&gt;Instant&lt;/code&gt; &lt;/a&gt; 는 이러한 실패 위험없이 경과 시간을 측정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5904fd4e8b5ae82205f779a00c5c8f588077b44a" translate="yes" xml:space="preserve">
          <source>This function may panic if &lt;code&gt;key&lt;/code&gt; is empty, contains an ASCII equals sign &lt;code&gt;'='&lt;/code&gt; or the NUL character &lt;code&gt;'\0'&lt;/code&gt;, or when the value contains the NUL character.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 비어 있거나 ASCII 등호 &lt;code&gt;'='&lt;/code&gt; 또는 NUL 문자 &lt;code&gt;'\0'&lt;/code&gt; 을 포함하거나 값에 NUL 문자가 포함되어 있으면이 기능이 패닉 상태 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a0dc67c9d122eb74decfcdabf36a2e9b439b108" translate="yes" xml:space="preserve">
          <source>This function may panic if it is called after the &lt;code&gt;Complete&lt;/code&gt; variant has been returned previously. While generator literals in the language are guaranteed to panic on resuming after &lt;code&gt;Complete&lt;/code&gt;, this is not guaranteed for all implementations of the &lt;code&gt;Generator&lt;/code&gt; trait.</source>
          <target state="translated">&lt;code&gt;Complete&lt;/code&gt; 변형이 이전에 반환 된 후이 함수가 호출되면이 함수가 패닉 상태 일 수 있습니다 . 언어의 생성기 리터럴 이 &lt;code&gt;Complete&lt;/code&gt; 후에 다시 시작하면 패닉이 보장되지만 &lt;code&gt;Generator&lt;/code&gt; 특성 의 모든 구현에 대해 이것이 보장되는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="22c11ebcd140410550c98ffdd0ada9fb8238ab32" translate="yes" xml:space="preserve">
          <source>This function may panic if the current time is earlier than this instant, which is something that can happen if an &lt;code&gt;Instant&lt;/code&gt; is produced synthetically.</source>
          <target state="translated">현재 시간은 경우에 일어날 수있는 일이다이 순간, 이전의 경우이 기능은 당황 할 수 &lt;code&gt;Instant&lt;/code&gt; 가 합성 적으로 생성 된 .</target>
        </trans-unit>
        <trans-unit id="24a0a37cf3864874d04875e7b90815fd8bf61604" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;../time/struct.instant#method.checked_add&quot;&gt;&lt;code&gt;Instant::checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="translated">이 함수는 결과 시점을 기본 데이터 구조로 표현할 수없는 경우 패닉을 일으킬 수 있습니다. 패닉이없는 버전 은 &lt;a href=&quot;../time/struct.instant#method.checked_add&quot;&gt; &lt;code&gt;Instant::checked_add&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8aed85a838914397cfff90a6f158e84b7b3b4829" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;../time/struct.instant#method.checked_add&quot;&gt;&lt;code&gt;checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="translated">결과 시점을 기본 데이터 구조로 표시 할 수없는 경우이 함수가 패닉 상태가 될 수 있습니다. 패닉이없는 버전 은 &lt;a href=&quot;../time/struct.instant#method.checked_add&quot;&gt; &lt;code&gt;checked_add&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9bc75e1d489664d08b58daa300cbacf1f7764cb4" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;../time/struct.systemtime#method.checked_add&quot;&gt;&lt;code&gt;SystemTime::checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="translated">이 함수는 결과 시점을 기본 데이터 구조로 표현할 수없는 경우 패닉을 일으킬 수 있습니다. 패닉이없는 버전 은 &lt;a href=&quot;../time/struct.systemtime#method.checked_add&quot;&gt; &lt;code&gt;SystemTime::checked_add&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="366269740ca74a1798b4e975775caf12fd1ce852" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;../time/struct.systemtime#method.checked_add&quot;&gt;&lt;code&gt;checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="translated">결과 시점을 기본 데이터 구조로 표시 할 수없는 경우이 함수가 패닉 상태가 될 수 있습니다. 패닉이없는 버전 은 &lt;a href=&quot;../time/struct.systemtime#method.checked_add&quot;&gt; &lt;code&gt;checked_add&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="401bf91c85ca55e966355c7f85b21d7639dab4cd" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;struct.instant#method.checked_add&quot;&gt;&lt;code&gt;Instant::checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="translated">이 함수는 결과 시점을 기본 데이터 구조로 표현할 수없는 경우 패닉을 일으킬 수 있습니다. 패닉이없는 버전 은 &lt;a href=&quot;struct.instant#method.checked_add&quot;&gt; &lt;code&gt;Instant::checked_add&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f02bfc3fdf0149848c26b5693e3c3c2e193c842" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;struct.instant#method.checked_add&quot;&gt;&lt;code&gt;checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="translated">결과 시점을 기본 데이터 구조로 표시 할 수없는 경우이 함수가 패닉 상태가 될 수 있습니다. 패닉이없는 버전 은 &lt;a href=&quot;struct.instant#method.checked_add&quot;&gt; &lt;code&gt;checked_add&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6625bc40abfc907779e7819cb337a56bc6be6b98" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;struct.systemtime#method.checked_add&quot;&gt;&lt;code&gt;SystemTime::checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="translated">이 함수는 결과 시점을 기본 데이터 구조로 표현할 수없는 경우 패닉을 일으킬 수 있습니다. 패닉이없는 버전 은 &lt;a href=&quot;struct.systemtime#method.checked_add&quot;&gt; &lt;code&gt;SystemTime::checked_add&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="df93ffa2c06e7d9c793296fff9096b1f4a09746a" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;struct.systemtime#method.checked_add&quot;&gt;&lt;code&gt;checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="translated">결과 시점을 기본 데이터 구조로 표시 할 수없는 경우이 함수가 패닉 상태가 될 수 있습니다. 패닉이없는 버전 은 &lt;a href=&quot;struct.systemtime#method.checked_add&quot;&gt; &lt;code&gt;checked_add&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f047ee1947a40935115c87e9ff5da84ba7c716fb" translate="yes" xml:space="preserve">
          <source>This function may panic on some platforms if a thread attempts to join itself or otherwise may create a deadlock with joining threads.</source>
          <target state="translated">스레드가 자체 결합을 시도하거나 스레드 결합으로 교착 상태를 발생시키는 경우 일부 플랫폼에서이 기능이 패닉 상태가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2aa9c9fbe6e7d8e79dbcc09f82ff622cc49e7e8c" translate="yes" xml:space="preserve">
          <source>This function might panic if the iterator has more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">이터레이터에 &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; 요소 이상이 있으면이 함수가 패닉 상태가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1fc6a40a80536289c51eca2e61adf3162489e6d" translate="yes" xml:space="preserve">
          <source>This function might panic if the iterator has more than &lt;code&gt;usize::MAX&lt;/code&gt; non-matching elements.</source>
          <target state="translated">반복자가 &lt;code&gt;usize::MAX&lt;/code&gt; 비 일치 요소를 초과하면이 함수가 패닉 상태가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e85b3c94c6e63ddd25298570364b3a6122b73135" translate="yes" xml:space="preserve">
          <source>This function might panic when called if the lock is already held by the current thread.</source>
          <target state="translated">현재 스레드가 잠금을 이미 보유한 경우이 함수는 호출 될 때 패닉 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3552c30ec404d25019fce8d0e95a821dc885077" translate="yes" xml:space="preserve">
          <source>This function panics if &lt;code&gt;T&lt;/code&gt; is a Zero-Sized Type (&quot;ZST&quot;).</source>
          <target state="translated">이 함수는 &lt;code&gt;T&lt;/code&gt; 인 경우 패닉 는 가 제로 크기 유형 ( &quot;ZST&quot;) 인 .</target>
        </trans-unit>
        <trans-unit id="101814bfeeecf8436008ed4880368756ae5c8d29" translate="yes" xml:space="preserve">
          <source>This function panics if &lt;code&gt;T&lt;/code&gt; is a zero-sized type.</source>
          <target state="translated">이 함수 는 &lt;code&gt;T&lt;/code&gt; 가 제로 크기 인 경우 패닉 상태 입니다.</target>
        </trans-unit>
        <trans-unit id="9eaa9b63e5ef7b899f75363fe8681ac3e3da2fd4" translate="yes" xml:space="preserve">
          <source>This function panics if &lt;code&gt;radix&lt;/code&gt; is not in the range from 2 to 36.</source>
          <target state="translated">&lt;code&gt;radix&lt;/code&gt; 가 2에서 36 사이가 아닌 경우이 기능은 패닉 상태 입니다.</target>
        </trans-unit>
        <trans-unit id="f62c2a73ad1ab98a4ef40a980a80cd47e78cfc5e" translate="yes" xml:space="preserve">
          <source>This function reads as many bytes as necessary to completely fill the specified buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">이 함수는 지정된 버퍼 &lt;code&gt;buf&lt;/code&gt; 를 완전히 채우는 데 필요한만큼의 바이트를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="c39eec7f7794b4915b46c58cff436d679c91fcab" translate="yes" xml:space="preserve">
          <source>This function reads the value of &lt;code&gt;errno&lt;/code&gt; for the target platform (e.g. &lt;code&gt;GetLastError&lt;/code&gt; on Windows) and will return a corresponding instance of &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; for the error code.</source>
          <target state="translated">이 함수 는 대상 플랫폼 (예 : Windows의 &lt;code&gt;GetLastError&lt;/code&gt; ) 에 대한 &lt;code&gt;errno&lt;/code&gt; 값을 읽고 해당 인스턴스를 반환합니다.&lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 오류 코드.</target>
        </trans-unit>
        <trans-unit id="32152f76d2e83d5c89836d9aa45ce33c14bc03d9" translate="yes" xml:space="preserve">
          <source>This function reads the value of &lt;code&gt;errno&lt;/code&gt; for the target platform (e.g. &lt;code&gt;GetLastError&lt;/code&gt; on Windows) and will return a corresponding instance of &lt;code&gt;Error&lt;/code&gt; for the error code.</source>
          <target state="translated">이 함수 는 대상 플랫폼에 대한 &lt;code&gt;errno&lt;/code&gt; 값 (예 : Windows의 &lt;code&gt;GetLastError&lt;/code&gt; )을 읽고 오류 코드에 해당하는 &lt;code&gt;Error&lt;/code&gt; 인스턴스를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1cc405a72fa71224d4a044b7593cdccf93a633ec" translate="yes" xml:space="preserve">
          <source>This function returning &lt;code&gt;false&lt;/code&gt; does not mean that &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; has not been executed. For example, it may have been executed in the time between when &lt;code&gt;is_completed&lt;/code&gt; starts executing and when it returns, in which case the &lt;code&gt;false&lt;/code&gt; return value would be stale (but still permissible).</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 를 반환하는이 함수 는 &lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt; 가 실행되지 않았 음을 의미하지 않습니다 . 예를 들어 &lt;code&gt;is_completed&lt;/code&gt; 가 실행을 시작하고 반환 되는 시간 사이에 실행되었을 수 있습니다. &lt;code&gt;false&lt;/code&gt; 반환 값은 부실 (그러나 여전히 허용 가능)입니다.</target>
        </trans-unit>
        <trans-unit id="05ed95f7312c1878141bc36d8d210b9fa11581c5" translate="yes" xml:space="preserve">
          <source>This function returns a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt;&lt;/a&gt;. If our byte slice is invalid UTF-8, then we need to insert the replacement characters, which will change the size of the string, and hence, require a &lt;code&gt;String&lt;/code&gt;. But if it's already valid UTF-8, we don't need a new allocation. This return type allows us to handle both cases.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt; &lt;/a&gt; 반환합니다 . 우리 바이트 슬라이스가 무효 UTF-8의 경우, 우리는 필요, 따라서 문자열의 크기를 변경 한 것이다 교체 문자를 삽입해야 할 &lt;code&gt;String&lt;/code&gt; . 그러나 이미 유효한 UTF-8이면 새로운 할당이 필요하지 않습니다. 이 반환 유형을 사용하면 두 경우를 모두 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="12ee7d651a482e6bf7ef02b5e21ea7e98deba17a" translate="yes" xml:space="preserve">
          <source>This function returns a new OpenOptions object that you can use to open or create a file with specific options if &lt;code&gt;open()&lt;/code&gt; or &lt;code&gt;create()&lt;/code&gt; are not appropriate.</source>
          <target state="translated">이 기능은 새로운 OpenOptions가 열거 나 경우 특정 옵션이있는 파일을 생성하는 데 사용할 수있는 개체를 반환합니다 &lt;code&gt;open()&lt;/code&gt; 또는 &lt;code&gt;create()&lt;/code&gt; 가 적절하지 않은 .</target>
        </trans-unit>
        <trans-unit id="6f72ba6fb91e1ce3e00f9d70494a4d758f1ff97b" translate="yes" xml:space="preserve">
          <source>This function returns a new instance of &lt;code&gt;Read&lt;/code&gt; which will read at most &lt;code&gt;limit&lt;/code&gt; bytes, after which it will always return EOF (&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;). Any read errors will not count towards the number of bytes read and future calls to &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; may succeed.</source>
          <target state="translated">이 함수는 최대 &lt;code&gt;limit&lt;/code&gt; 바이트를 읽은 후 항상 EOF ( &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt; )를 반환하는 새로운 &lt;code&gt;Read&lt;/code&gt; 인스턴스를 반환합니다 . 읽기 오류는 읽은 바이트 수에 포함되지 않으며 향후 &lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; 호출 이 성공할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef0ad46bb886f62fbf2201ba9b9f859d8daf73a5" translate="yes" xml:space="preserve">
          <source>This function returns:</source>
          <target state="translated">이 함수는 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e286b47aa27a1649f35422e9cb038c26279f95e3" translate="yes" xml:space="preserve">
          <source>This function runs the destructor of the contained value and thus the wrapped value now represents uninitialized data. It is up to the user of this method to ensure the uninitialized data is not actually used.</source>
          <target state="translated">이 함수는 포함 된 값의 소멸자를 실행하므로 랩핑 된 값은 이제 초기화되지 않은 데이터를 나타냅니다. 초기화되지 않은 데이터가 실제로 사용되지 않도록하는 것은이 방법의 사용자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="d626c9a67f6c1bb6dde6295b947e23c4df085081" translate="yes" xml:space="preserve">
          <source>This function runs the destructor of the contained value. Other than changes made by the destructor itself, the memory is left unchanged, and so as far as the compiler is concerned still holds a bit-pattern which is valid for the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">이 함수는 포함 된 값의 소멸자를 실행합니다. 소멸자 자체에 의해 변경된 것 외에 메모리는 변경되지 않은 채로 남아 있으며 컴파일러에 관한 한 여전히 유형에 유효한 비트 패턴을 보유합니다. &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7791922c183e6e6d1b0127e9349abae66c275dd6" translate="yes" xml:space="preserve">
          <source>This function semantically moves out the contained value without preventing further usage, leaving the state of this container unchanged. It is your responsibility to ensure that this &lt;code&gt;ManuallyDrop&lt;/code&gt; is not used again.</source>
          <target state="translated">이 함수는 추가 사용을 방지하지 않고 포함 된 값을 의미 적으로 이동하여이 컨테이너의 상태를 변경하지 않습니다. 이를 확인하는 것은 귀하의 책임입니다. &lt;code&gt;ManuallyDrop&lt;/code&gt; 이 다시 사용되지 입니다.</target>
        </trans-unit>
        <trans-unit id="e07f846f13b5b07afd4d29501d5ea48bcae4f64b" translate="yes" xml:space="preserve">
          <source>This function semantically moves out the contained value without preventing further usage. It is up to the user of this method to ensure that this container is not used again.</source>
          <target state="translated">이 기능은 추가 사용을 막지 않고 포함 된 값을 의미 적으로 제거합니다. 이 컨테이너를 다시 사용하지 않는 것은이 방법의 사용자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="b73fe46d5d15372cef97957fc6bcb2aba3a35b19" translate="yes" xml:space="preserve">
          <source>This function specifies a new multicast group for this socket to join. The address must be a valid multicast address, and &lt;code&gt;interface&lt;/code&gt; is the address of the local interface with which the system should join the multicast group. If it's equal to &lt;code&gt;INADDR_ANY&lt;/code&gt; then an appropriate interface is chosen by the system.</source>
          <target state="translated">이 함수는이 소켓이 참가할 새로운 멀티 캐스트 그룹을 지정합니다. 주소는 유효한 멀티 캐스트 주소 여야하며 &lt;code&gt;interface&lt;/code&gt; 는 시스템이 멀티 캐스트 그룹에 가입해야하는 로컬 인터페이스의 주소입니다. &lt;code&gt;INADDR_ANY&lt;/code&gt; 와 같으면 시스템에서 적절한 인터페이스를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="1f12ea05478bb3baf501603f551862b3ebf72f88" translate="yes" xml:space="preserve">
          <source>This function specifies a new multicast group for this socket to join. The address must be a valid multicast address, and &lt;code&gt;interface&lt;/code&gt; is the index of the interface to join/leave (or 0 to indicate any interface).</source>
          <target state="translated">이 함수는이 소켓이 참가할 새로운 멀티 캐스트 그룹을 지정합니다. 주소는 유효한 멀티 캐스트 주소 및 &lt;code&gt;interface&lt;/code&gt; 여야합니다 는 결합 / 탈출 할 인터페이스의 색인입니다 (또는 인터페이스를 나타내려면 0).</target>
        </trans-unit>
        <trans-unit id="24119e41ff16fdb059a46c613efe17ad7fc57293" translate="yes" xml:space="preserve">
          <source>This function takes a string slice and emits it to the internal buffer after applying the relevant formatting flags specified. The flags recognized for generic strings are:</source>
          <target state="translated">이 함수는 문자열 슬라이스를 사용하여 지정된 관련 형식 지정 플래그를 적용한 후 내부 버퍼로 방출합니다. 일반 문자열로 인식되는 플래그는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5aebd3cecb06bef11683a2b627652c498c3d60b0" translate="yes" xml:space="preserve">
          <source>This function will &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; if it is used with more than one mutex over time. Each condition variable is dynamically bound to exactly one mutex to ensure defined behavior across platforms. If this functionality is not desired, then unsafe primitives in &lt;code&gt;sys&lt;/code&gt; are provided.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt; 할 것입니다 ! 시간이 지남에 둘 이상의 뮤텍스와 함께 사용되는 경우. 각 조건 변수는 플랫폼간에 정의 된 동작을 보장하기 위해 정확히 하나의 뮤텍스에 동적으로 바인딩됩니다. 이 기능을 원하지 않으면 &lt;code&gt;sys&lt;/code&gt; 의 안전하지 않은 프리미티브 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="78327b333ccf6b689aaecb9ee26d119fa6c5777a" translate="yes" xml:space="preserve">
          <source>This function will &lt;code&gt;panic!()&lt;/code&gt; if the key currently has its destructor running, and it &lt;strong&gt;may&lt;/strong&gt; panic if the destructor has previously been run for this thread.</source>
          <target state="translated">이 기능은 것 &lt;code&gt;panic!()&lt;/code&gt; 키가 현재 소멸자 실행이있는 경우, 그것은 &lt;strong&gt;할 수있다&lt;/strong&gt; 이되고이 스레드에 대해 소멸자가 이전에 실행 된 경우 패닉 발생할 .</target>
        </trans-unit>
        <trans-unit id="de2e867f0f0c2461353251de2093fad37d9de75b" translate="yes" xml:space="preserve">
          <source>This function will &lt;em&gt;block&lt;/em&gt; until space in the internal buffer becomes available or a receiver is available to hand off the message to.</source>
          <target state="translated">이 기능은 내부 버퍼의 공간이 사용 가능해 지거나 수신자가 메시지를 전달할 수 있을 때까지 &lt;em&gt;차단&lt;/em&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="aa7ba2de98a6c309498a7c489e34ef4ae855d255" translate="yes" xml:space="preserve">
          <source>This function will &lt;strong&gt;consume ownership&lt;/strong&gt; of the handle given, passing responsibility for closing the handle to the returned object.</source>
          <target state="translated">이 함수는 주어진 핸들의 &lt;strong&gt;소유권&lt;/strong&gt; 을 &lt;strong&gt;소비&lt;/strong&gt; 하여 반환 된 객체에 핸들을 닫는 책임을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="b6de52c208f12c4efe8542e2cc11b06fa42d2cf9" translate="yes" xml:space="preserve">
          <source>This function will &lt;strong&gt;consume ownership&lt;/strong&gt; of the socket provided and it will be closed when the returned object goes out of scope.</source>
          <target state="translated">이 함수는 제공된 소켓의 &lt;strong&gt;소유권&lt;/strong&gt; 을 &lt;strong&gt;소비&lt;/strong&gt; 하며 반환 된 객체가 범위를 벗어날 때 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="34a9593fc439cb6bab67a9e273e42357e335b574" translate="yes" xml:space="preserve">
          <source>This function will &lt;strong&gt;overwrite&lt;/strong&gt; the contents of &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">이 기능은됩니다 &lt;strong&gt;덮어 쓰기&lt;/strong&gt; 의 내용 &lt;code&gt;to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b50d15cbddd54c77fb77c9639aae5bb9352e901e" translate="yes" xml:space="preserve">
          <source>This function will always block the current thread if there is no data available and it's possible for more data to be sent. Once a message is sent to the corresponding &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;struct.syncsender&quot;&gt;&lt;code&gt;SyncSender&lt;/code&gt;&lt;/a&gt;), then this receiver will wake up and return that message.</source>
          <target state="translated">사용 가능한 데이터가없고 더 많은 데이터를 전송할 수있는 경우이 함수는 항상 현재 스레드를 차단합니다. 해당 &lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;struct.syncsender&quot;&gt; &lt;code&gt;SyncSender&lt;/code&gt; &lt;/a&gt; )에게 메시지가 전송되면 ) 이 수신자는 깨어나 해당 메시지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2f7bc7c7785b26db5d2ba1d43d57ec9e10153387" translate="yes" xml:space="preserve">
          <source>This function will atomically unlock the mutex specified (represented by &lt;code&gt;guard&lt;/code&gt;) and block the current thread. This means that any calls to &lt;a href=&quot;#method.notify_one&quot;&gt;&lt;code&gt;notify_one&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.notify_all&quot;&gt;&lt;code&gt;notify_all&lt;/code&gt;&lt;/a&gt; which happen logically after the mutex is unlocked are candidates to wake this thread up. When this function call returns, the lock specified will have been re-acquired.</source>
          <target state="translated">이 함수는 지정된 mutex를 원자 적으로 잠금 해제하고 ( &lt;code&gt;guard&lt;/code&gt; 로 표시 ) 현재 스레드를 차단합니다. 이것은 mutex가 잠금 해제 된 후 논리적으로 발생 하는 &lt;a href=&quot;#method.notify_one&quot;&gt; &lt;code&gt;notify_one&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#method.notify_all&quot;&gt; &lt;code&gt;notify_all&lt;/code&gt; 에&lt;/a&gt; 대한 호출 이이 스레드를 깨울 수있는 후보 임을 의미 합니다. 이 함수 호출이 리턴되면 지정된 잠금이 다시 획득됩니다.</target>
        </trans-unit>
        <trans-unit id="07010b30f6fb56afc898bded5d3cc83a49e39776" translate="yes" xml:space="preserve">
          <source>This function will atomically unlock the mutex specified (represented by &lt;code&gt;guard&lt;/code&gt;) and block the current thread. This means that any calls to &lt;a href=&quot;struct.condvar#method.notify_one&quot;&gt;&lt;code&gt;notify_one&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.condvar#method.notify_all&quot;&gt;&lt;code&gt;notify_all&lt;/code&gt;&lt;/a&gt; which happen logically after the mutex is unlocked are candidates to wake this thread up. When this function call returns, the lock specified will have been re-acquired.</source>
          <target state="translated">이 함수는 지정된 뮤텍스 ( &lt;code&gt;guard&lt;/code&gt; 로 표시됨) 를 원자 적으로 잠금 해제 하고 현재 스레드를 차단합니다. 즉, &lt;a href=&quot;struct.condvar#method.notify_one&quot;&gt; &lt;code&gt;notify_one&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.condvar#method.notify_all&quot;&gt; &lt;code&gt;notify_all&lt;/code&gt; 에&lt;/a&gt; 대한 모든 호출은 뮤텍스가 잠금 해제 된 후 논리적으로 발생 이이 스레드를 깨울 후보 합니다. 이 함수 호출이 반환되면 지정된 잠금이 다시 획득됩니다.</target>
        </trans-unit>
        <trans-unit id="d633c453ad140c0449c1db8cbeeaa851bc2659b6" translate="yes" xml:space="preserve">
          <source>This function will attempt to ensure that all in-memory data reaches the filesystem before returning.</source>
          <target state="translated">이 함수는 반환하기 전에 모든 메모리 내 데이터가 파일 시스템에 도달하도록합니다.</target>
        </trans-unit>
        <trans-unit id="3cdc162bace3b7e0f3af0944a143fb84bab4d03d" translate="yes" xml:space="preserve">
          <source>This function will attempt to write the entire contents of &lt;code&gt;buf&lt;/code&gt;, but the entire write may not succeed, or the write may also generate an error. A call to &lt;code&gt;write&lt;/code&gt; represents &lt;em&gt;at most one&lt;/em&gt; attempt to write to any wrapped object.</source>
          <target state="translated">이 함수는 &lt;code&gt;buf&lt;/code&gt; 의 전체 내용을 쓰려고 시도 하지만 전체 쓰기가 성공하지 못하거나 쓰기도 오류를 생성 할 수 있습니다. &lt;code&gt;write&lt;/code&gt; 요청 &lt;em&gt;은 최대 하나를&lt;/em&gt; 나타냅니다 &lt;em&gt;.&lt;/em&gt; 랩핑 된 객체에 대한 쓰기 시도를 .</target>
        </trans-unit>
        <trans-unit id="41d06b3c8e4189760b322760b47992d4717d7848" translate="yes" xml:space="preserve">
          <source>This function will be a noop if the &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; or &lt;code&gt;RUST_LIB_BACKTRACE&lt;/code&gt; backtrace variables are both not set. If either environment variable is set and enabled then this function will actually capture a backtrace. Capturing a backtrace can be both memory intensive and slow, so these environment variables allow liberally using &lt;code&gt;Backtrace::capture&lt;/code&gt; and only incurring a slowdown when the environment variables are set.</source>
          <target state="translated">&lt;code&gt;RUST_BACKTRACE&lt;/code&gt; 또는 &lt;code&gt;RUST_LIB_BACKTRACE&lt;/code&gt; 역 추적 변수가 둘 다 설정되지 않은 경우이 함수는 noop이됩니다 . 환경 변수가 설정되고 활성화 된 경우이 함수는 실제로 역 추적을 캡처합니다. 역 추적 캡처는 메모리 집약적이고 느릴 수 있으므로 이러한 환경 변수를 사용하면 &lt;code&gt;Backtrace::capture&lt;/code&gt; 자유롭게 사용할 수 있으며 환경 변수가 설정된 경우에만 속도가 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="d59143ff7e9860f113062c67363bd75c2092c35a" translate="yes" xml:space="preserve">
          <source>This function will be called when &lt;code&gt;wake&lt;/code&gt; is called on the &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt;. It must wake up the task associated with this &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;wake&lt;/code&gt; 가 호출 될 때 호출됩니다 . 이 &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; 와 관련된 작업을 깨워 야합니다 .</target>
        </trans-unit>
        <trans-unit id="12cb59dc2a2a1b37303ef992097df532faaa8b94" translate="yes" xml:space="preserve">
          <source>This function will be called when &lt;code&gt;wake_by_ref&lt;/code&gt; is called on the &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt;. It must wake up the task associated with this &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;wake_by_ref&lt;/code&gt; 가 호출 될 때 호출됩니다 . 이 &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; 와 관련된 작업을 깨워 야합니다 .</target>
        </trans-unit>
        <trans-unit id="76c72888278b0a8cb4941353a709e0ecd237c2c8" translate="yes" xml:space="preserve">
          <source>This function will be called when the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; gets cloned, e.g. when the &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; in which the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; is stored gets cloned.</source>
          <target state="translated">때이 함수가 호출됩니다 &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; 가&lt;/a&gt; 복제됩니다, 예를 들면 때 &lt;a href=&quot;struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; 하는 &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; 저장이 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="83e27c1cac935244e1d8ce7e9b3bc5a49eb326cd" translate="yes" xml:space="preserve">
          <source>This function will block the calling thread until a new TCP connection is established. When established, the corresponding &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; and the remote peer's address will be returned.</source>
          <target state="translated">이 기능은 새로운 TCP 연결이 설정 될 때까지 호출 스레드를 차단합니다. 설정되면 해당 &lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; 과 원격 피어의 주소가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b771e75bfd99083821bb9279c74d5a51cd594b6a" translate="yes" xml:space="preserve">
          <source>This function will block the calling thread until a new Unix connection is established. When established, the corresponding &lt;a href=&quot;struct.unixstream&quot;&gt;&lt;code&gt;UnixStream&lt;/code&gt;&lt;/a&gt; and the remote peer's address will be returned.</source>
          <target state="translated">이 함수는 새로운 유닉스 연결이 설정 될 때까지 호출 스레드를 차단합니다. 설정되면 해당 &lt;a href=&quot;struct.unixstream&quot;&gt; &lt;code&gt;UnixStream&lt;/code&gt; &lt;/a&gt; 과 원격 피어의 주소가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4d1cb142862a95e8531c0e6c5eeff4f29562add6" translate="yes" xml:space="preserve">
          <source>This function will block the local thread until it is available to acquire the mutex. Upon returning, the thread is the only thread with the lock held. An RAII guard is returned to allow scoped unlock of the lock. When the guard goes out of scope, the mutex will be unlocked.</source>
          <target state="translated">이 함수는 뮤텍스를 획득 할 수있을 때까지 로컬 스레드를 차단합니다. 돌아올 때 스레드는 잠금 장치가있는 유일한 스레드입니다. 범위의 잠금을 해제 할 수 있도록 RAII 보호대가 반환됩니다. 가드가 범위를 벗어나면 뮤텍스가 잠금 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="1061d2d5e43718addf8cd833a952b821898f457c" translate="yes" xml:space="preserve">
          <source>This function will capture a stack backtrace of the current OS thread of execution, returning a &lt;code&gt;Backtrace&lt;/code&gt; type which can be later used to print the entire stack trace or render it to a string.</source>
          <target state="translated">이 함수는 현재 실행중인 OS 스레드의 스택 역 추적을 캡처하여 나중에 전체 스택 추적을 인쇄하거나 문자열로 렌더링하는 데 사용할 수 있는 &lt;code&gt;Backtrace&lt;/code&gt; 유형을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e63b5a3d38dde4813e2c02e7906910d9bbecad76" translate="yes" xml:space="preserve">
          <source>This function will cast the provided &lt;code&gt;bytes&lt;/code&gt; to a &lt;code&gt;CStr&lt;/code&gt; wrapper after ensuring that the byte slice is nul-terminated and does not contain any interior nul bytes.</source>
          <target state="translated">이 함수는 바이트 슬라이스가 널 종료되고 내부 널 바이트를 포함하지 않는지 확인한 후 제공된 &lt;code&gt;bytes&lt;/code&gt; 를 &lt;code&gt;CStr&lt;/code&gt; 랩퍼 로 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="8c3891c10a9a0ae62223a6915ab48a717d1803e4" translate="yes" xml:space="preserve">
          <source>This function will cast the provided &lt;code&gt;bytes&lt;/code&gt; to a &lt;code&gt;CStr&lt;/code&gt; wrapper without performing any sanity checks. The provided slice &lt;strong&gt;must&lt;/strong&gt; be nul-terminated and not contain any interior nul bytes.</source>
          <target state="translated">이 함수는 온 전성 검사를 수행하지 않고 제공된 &lt;code&gt;bytes&lt;/code&gt; 를 &lt;code&gt;CStr&lt;/code&gt; 랩퍼 로 캐스트 합니다. 제공된 슬라이스 &lt;strong&gt;는&lt;/strong&gt; 널로 끝나야하며 내부 널 바이트를 포함하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="8f259ce0614bcf2d0063ac4400649f231860a760" translate="yes" xml:space="preserve">
          <source>This function will cause all pending and future I/O calls on the specified portions to immediately return with an appropriate value (see the documentation of &lt;a href=&quot;../../../net/enum.shutdown&quot;&gt;&lt;code&gt;Shutdown&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 기능을 사용하면 지정된 부분에서 보류중인 모든 향후 I / O 호출이 즉시 적절한 값으로 반환됩니다 ( &lt;a href=&quot;../../../net/enum.shutdown&quot;&gt; &lt;code&gt;Shutdown&lt;/code&gt; &lt;/a&gt; 문서 참조 ).</target>
        </trans-unit>
        <trans-unit id="f2081c3bcdd573e767785b3929fff378af8293c8" translate="yes" xml:space="preserve">
          <source>This function will cause all pending and future I/O on the specified portions to return immediately with an appropriate value (see the documentation of &lt;a href=&quot;enum.shutdown&quot;&gt;&lt;code&gt;Shutdown&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 기능을 사용하면 지정된 부분의 모든 보류 중 및 향후 I / O가 적절한 값으로 즉시 반환됩니다 ( &lt;a href=&quot;enum.shutdown&quot;&gt; &lt;code&gt;Shutdown&lt;/code&gt; &lt;/a&gt; 설명서 참조 ).</target>
        </trans-unit>
        <trans-unit id="e9782cf601eece8d5d886326b28d5030905f50d6" translate="yes" xml:space="preserve">
          <source>This function will consume the provided data and use the underlying bytes to construct a new string, ensuring that there is a trailing 0 byte. This trailing 0 byte will be appended by this function; the provided data should &lt;em&gt;not&lt;/em&gt; contain any 0 bytes in it.</source>
          <target state="translated">이 함수는 제공된 데이터를 소비하고 기본 바이트를 사용하여 새 문자열을 구성하여 후행 0 바이트가 있는지 확인합니다. 이 후행 0 바이트에이 함수가 추가됩니다. 제공된 데이터 에는 0 바이트가 포함 &lt;em&gt;되지 않아야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4a81f58ae0af06c0e29ed9547bff428e9a075df5" translate="yes" xml:space="preserve">
          <source>This function will continuously read data from &lt;code&gt;reader&lt;/code&gt; and then write it into &lt;code&gt;writer&lt;/code&gt; in a streaming fashion until &lt;code&gt;reader&lt;/code&gt; returns EOF.</source>
          <target state="translated">이 기능은 &lt;code&gt;reader&lt;/code&gt; 에서 지속적으로 데이터를 읽은 다음 &lt;code&gt;reader&lt;/code&gt; 까지 스트리밍 방식 으로 &lt;code&gt;writer&lt;/code&gt; 에 기록합니다. 가 EOF를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="74b77ba5c4f9d07323cf0380138b2c4acac538aa" translate="yes" xml:space="preserve">
          <source>This function will correctly account for the flags provided as well as the minimum width. It will not take precision into account.</source>
          <target state="translated">이 함수는 제공되는 플래그와 최소 너비를 올바르게 설명합니다. 정밀도는 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e2de984561c8e2a215768e0c15afc535bb75bf0" translate="yes" xml:space="preserve">
          <source>This function will create a file if it does not exist, and will entirely replace its contents if it does.</source>
          <target state="translated">이 함수는 파일이 존재하지 않으면 파일을 작성하고 파일이 있으면 그 내용을 완전히 대체합니다.</target>
        </trans-unit>
        <trans-unit id="f65976cf8345e044488976485c5a6e346af5a578" translate="yes" xml:space="preserve">
          <source>This function will create a file if it does not exist, and will truncate it if it does.</source>
          <target state="translated">이 함수는 파일이 존재하지 않으면 파일을 작성하고 파일이 있으면 잘립니다.</target>
        </trans-unit>
        <trans-unit id="0e1b8893ba63c7e2758784f05b5644780ac55d15" translate="yes" xml:space="preserve">
          <source>This function will ignore all instances of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; and will otherwise return any errors returned by &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 의 모든 인스턴스를 무시하고 그렇지 않으면 &lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt; 가 반환 한 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a56b9fb350dbbed0024c336c03c94d6b856e68cd" translate="yes" xml:space="preserve">
          <source>This function will ignore all instances of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; and will otherwise return any errors returned by &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 의 모든 인스턴스를 무시하고 그렇지 않으면 &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; 에서&lt;/a&gt; 반환 된 모든 오류를 반환합니다 . .</target>
        </trans-unit>
        <trans-unit id="326c8120454de566fb3a6866a530ebb7b6b992dc" translate="yes" xml:space="preserve">
          <source>This function will never panic, but it may return &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if the &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; has disconnected and is no longer able to receive information.</source>
          <target state="translated">이 함수는 패닉이 발생하지 않지만 &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; 을&lt;/a&gt; 반환 하면 가 연결을 끊고 더 이상 정보를 수신 할 수없는 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fc6b983aea89da54a39cad92dbfed108559d536" translate="yes" xml:space="preserve">
          <source>This function will never return and will immediately terminate the current process. The exit code is passed through to the underlying OS and will be available for consumption by another process.</source>
          <target state="translated">이 함수는 절대 반환되지 않으며 현재 프로세스를 즉시 종료합니다. 종료 코드는 기본 OS로 전달되며 다른 프로세스에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4fd0f129a9f8ea495fd3f5d41ad244c1f805fd1" translate="yes" xml:space="preserve">
          <source>This function will not block the calling thread and will only check to see if the child process has exited or not. If the child has exited then on Unix the process ID is reaped. This function is guaranteed to repeatedly return a successful exit status so long as the child has already exited.</source>
          <target state="translated">이 함수는 호출 스레드를 차단하지 않으며 하위 프로세스가 종료되었는지 여부 만 확인합니다. 자식이 종료되면 Unix에서 프로세스 ID가 나타납니다. 이 함수는 자식이 이미 종료 된 한 성공적인 종료 상태를 반복해서 반환합니다.</target>
        </trans-unit>
        <trans-unit id="db8a9f6074ffbe2434b96b3349b436c824d317bf" translate="yes" xml:space="preserve">
          <source>This function will not return while other writers or other readers currently have access to the lock.</source>
          <target state="translated">다른 작성자 나 다른 독자가 현재 잠금에 액세스하는 동안에는이 기능이 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f40a0312ebfb2b0e54e13329e7ace227d51b5cf1" translate="yes" xml:space="preserve">
          <source>This function will not traverse symlinks if this entry points at a symlink.</source>
          <target state="translated">이 항목이 심볼릭 링크를 가리키는 경우이 기능은 심볼릭 링크를 통과하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30de93c6705afd606c5b68502e92fede48ab8cb8" translate="yes" xml:space="preserve">
          <source>This function will not traverse symlinks if this entry points at a symlink. To traverse symlinks use &lt;a href=&quot;fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.file#method.metadata&quot;&gt;&lt;code&gt;fs::File::metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 항목이 심볼릭 링크를 가리키는 경우이 함수는 심볼릭 링크를 통과하지 않습니다. 심볼릭 링크를 탐색하려면 &lt;a href=&quot;fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.file#method.metadata&quot;&gt; &lt;code&gt;fs::File::metadata&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c834f424a9053dbdf6234c9da264d70e8ba7b880" translate="yes" xml:space="preserve">
          <source>This function will panic if &lt;code&gt;earlier&lt;/code&gt; is later than &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">경우 당황 것이 기능 &lt;code&gt;earlier&lt;/code&gt; 보다 이후 &lt;code&gt;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="255f788a8373ceb0a89289a41ca323624e5b7999" translate="yes" xml:space="preserve">
          <source>This function will panic if &lt;code&gt;k&lt;/code&gt; is greater than the length of the slice. Note that &lt;code&gt;k == self.len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">이 함수는 &lt;code&gt;k&lt;/code&gt; 가 슬라이스 길이보다 길면 패닉 상태가됩니다 . 참고 &lt;code&gt;k == self.len()&lt;/code&gt; 않는다 &lt;em&gt;하지&lt;/em&gt; 당황 무 조작 회전이다.</target>
        </trans-unit>
        <trans-unit id="95270b721e4d05b72ba071aee1067eda4042613d" translate="yes" xml:space="preserve">
          <source>This function will panic if &lt;code&gt;mid&lt;/code&gt; is greater than the length of the slice. Note that &lt;code&gt;mid == self.len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">&lt;code&gt;mid&lt;/code&gt; 가 슬라이스 길이보다 길면 이 기능이 패닉 상태가됩니다 . 참고 &lt;code&gt;mid == self.len()&lt;/code&gt; 않습니다 &lt;em&gt;하지&lt;/em&gt; 당황을하고, 무 조작 회전이다.</target>
        </trans-unit>
        <trans-unit id="e717b0d6a1e36e01967338ee832d65ba4d48839e" translate="yes" xml:space="preserve">
          <source>This function will panic if &lt;code&gt;rhs&lt;/code&gt; is 0 or the division results in overflow.</source>
          <target state="translated">이 기능은 &lt;code&gt;rhs&lt;/code&gt; 가 0이거나 나눗셈으로 인해 오버플로 .</target>
        </trans-unit>
        <trans-unit id="46e96193daf65415936b126b06264ed8418f5b5e" translate="yes" xml:space="preserve">
          <source>This function will panic if &lt;code&gt;rhs&lt;/code&gt; is 0.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; 가 0 이면이 함수는 패닉 상태가됩니다 .</target>
        </trans-unit>
        <trans-unit id="d72d270dceb6908b40e770de6a7cca4ee6d954fb" translate="yes" xml:space="preserve">
          <source>This function will panic if either range exceeds the end of the slice, or if the end of &lt;code&gt;src&lt;/code&gt; is before the start.</source>
          <target state="translated">이 함수는 범위 중 하나가 슬라이스의 끝을 초과하거나 &lt;code&gt;src&lt;/code&gt; 의 끝 이 시작하기 전에 패닉 상태가됩니다 .</target>
        </trans-unit>
        <trans-unit id="ffa5cde970751a9af3f3c95b9bc636f122bbdd4f" translate="yes" xml:space="preserve">
          <source>This function will panic if the capacity would overflow.</source>
          <target state="translated">용량이 오버플로되면이 기능이 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="157be01a917f2466c041055463b9f02120a94753" translate="yes" xml:space="preserve">
          <source>This function will panic if the position of the inner reader is smaller than the amount of buffered data. That can happen if the inner reader has an incorrect implementation of &lt;a href=&quot;trait.seek#method.stream_position&quot;&gt;&lt;code&gt;Seek::stream_position&lt;/code&gt;&lt;/a&gt;, or if the position has gone out of sync due to calling &lt;a href=&quot;trait.seek#tymethod.seek&quot;&gt;&lt;code&gt;Seek::seek&lt;/code&gt;&lt;/a&gt; directly on the underlying reader.</source>
          <target state="translated">이 기능은 내부 리더의 위치가 버퍼링 된 데이터의 양보다 작 으면 패닉 상태가됩니다. 내부 리더에 &lt;a href=&quot;trait.seek#method.stream_position&quot;&gt; &lt;code&gt;Seek::stream_position&lt;/code&gt; &lt;/a&gt; 의 잘못된 구현이 있거나 &lt;a href=&quot;trait.seek#tymethod.seek&quot;&gt; &lt;code&gt;Seek::seek&lt;/code&gt; &lt;/a&gt; 호출로 인해 위치가 동기화되지 않은 경우 발생할 수 있습니다. 기본 리더에서 직접 있습니다.</target>
        </trans-unit>
        <trans-unit id="000897a350419f9fea274e80815181a20fc49025" translate="yes" xml:space="preserve">
          <source>This function will panic if the two slices have different lengths, or if the implementation of &lt;code&gt;Clone&lt;/code&gt; panics.</source>
          <target state="translated">이 함수는 두 슬라이스의 길이가 다르거 나 &lt;code&gt;Clone&lt;/code&gt; 구현이 패닉 하는 경우 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="b80c161450352b3f264fa270e71aafac41ce5a3b" translate="yes" xml:space="preserve">
          <source>This function will panic if the two slices have different lengths.</source>
          <target state="translated">이 기능은 두 슬라이스의 길이가 다른 경우 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="f9a04d3eaea11b5bf70c2b1e292fe13090c46ff0" translate="yes" xml:space="preserve">
          <source>This function will read bytes from the underlying stream until the delimiter or EOF is found. Once found, all bytes up to, and including, the delimiter (if found) will be appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">이 함수는 분리 문자 또는 EOF가 발견 될 때까지 기본 스트림에서 바이트를 읽습니다. 일단 발견되면, 분리 문자 (발견 된 경우)까지의 모든 바이트가 &lt;code&gt;buf&lt;/code&gt; 에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="1dad503d6df9a455b05b17e9982a9b93c55eab53" translate="yes" xml:space="preserve">
          <source>This function will read bytes from the underlying stream until the newline delimiter (the 0xA byte) or EOF is found. Once found, all bytes up to, and including, the delimiter (if found) will be appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">이 함수는 개행 분리 문자 (0xA 바이트) 또는 EOF가 발견 될 때까지 기본 스트림에서 바이트를 읽습니다. 일단 발견되면, 분리 문자 (발견 된 경우)까지의 모든 바이트가 &lt;code&gt;buf&lt;/code&gt; 에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="4641b6a37e2fa63178c9c82e80780dcf197015e4" translate="yes" xml:space="preserve">
          <source>This function will read bytes from the underlying stream until the newline delimiter (the &lt;code&gt;0xA&lt;/code&gt; byte) or EOF is found. Once found, all bytes up to, and including, the delimiter (if found) will be appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">이 함수는 줄 바꿈 구분 기호 ( &lt;code&gt;0xA&lt;/code&gt; 바이트) 또는 EOF를 찾을 때까지 기본 스트림에서 바이트를 읽습니다 . 발견되면 구분 기호 (발견 된 경우)까지 포함하여 모든 바이트가 &lt;code&gt;buf&lt;/code&gt; 에 추가됩니다. .</target>
        </trans-unit>
        <trans-unit id="5509bdb3a49d4f3afca9be3c4e49fc0d8f43d023" translate="yes" xml:space="preserve">
          <source>This function will resume execution of the generator or start execution if it hasn't already. This call will return back into the generator's last suspension point, resuming execution from the latest &lt;code&gt;yield&lt;/code&gt;. The generator will continue executing until it either yields or returns, at which point this function will return.</source>
          <target state="translated">이 함수는 생성기의 실행을 재개하거나 아직 실행하지 않은 경우 실행을 시작합니다. 이 호출은 최신 &lt;code&gt;yield&lt;/code&gt; 에서 실행을 다시 시작하여 생성기의 마지막 중단 지점으로 다시 돌아갑니다 . 제너레이터는 생성 또는 리턴 될 때까지 계속 실행되며이 시점에서이 함수는 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="379fb0237a1103a33f0bdfcecfb22299eb043557" translate="yes" xml:space="preserve">
          <source>This function will return &lt;code&gt;Ok&lt;/code&gt; with the closure's result if the closure does not panic, and will return &lt;code&gt;Err(cause)&lt;/code&gt; if the closure panics. The &lt;code&gt;cause&lt;/code&gt; returned is the object with which panic was originally invoked.</source>
          <target state="translated">이 함수는 클로저가 패닉 상태가 아닌 경우 클로저 결과와 함께 &lt;code&gt;Ok&lt;/code&gt; 를 반환 하고 클로저 패닉이 &lt;code&gt;Err(cause)&lt;/code&gt; 반환합니다. 리턴 된 &lt;code&gt;cause&lt;/code&gt; 은 공황이 원래 호출 된 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="d89140f93781fe909c3c1a3e0e29b63c7e369dd7" translate="yes" xml:space="preserve">
          <source>This function will return an I/O error if the underlying reader was read, but returned an error.</source>
          <target state="translated">이 함수는 기본 판독기를 읽은 경우 I / O 오류를 반환하지만 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="53872c0f37fe2cee76394788d7b1f123503054e5" translate="yes" xml:space="preserve">
          <source>This function will return an error if &lt;code&gt;path&lt;/code&gt; does not already exist. Other errors may also be returned according to &lt;a href=&quot;struct.openoptions#method.open&quot;&gt;&lt;code&gt;OpenOptions::open&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;path&lt;/code&gt; 가 없으면 오류를 반환 합니다. &lt;a href=&quot;struct.openoptions#method.open&quot;&gt; &lt;code&gt;OpenOptions::open&lt;/code&gt; &lt;/a&gt; 에 따라 다른 오류가 반환 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89c6971a5e8debeb3922f37bf3a67af3e6b7d708" translate="yes" xml:space="preserve">
          <source>This function will return an error if the RwLock is poisoned. An RwLock is poisoned whenever a writer panics while holding an exclusive lock. An error will be returned when the lock is acquired.</source>
          <target state="translated">이 기능은 RwLock이 감염된 경우 오류를 반환합니다. RwLock은 독자적인 잠금을 유지하면서 라이터가 패닉 할 때마다 중독됩니다. 잠금을 획득하면 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="dd9f12f8f4834cac09e7d8702d9c30c5d7a3ff26" translate="yes" xml:space="preserve">
          <source>This function will return an error if the RwLock is poisoned. An RwLock is poisoned whenever a writer panics while holding an exclusive lock. An error will only be returned if the lock would have otherwise been acquired.</source>
          <target state="translated">이 기능은 RwLock이 감염된 경우 오류를 반환합니다. RwLock은 독자적인 잠금을 유지하면서 라이터가 패닉 할 때마다 중독됩니다. 잠금을 획득 한 경우에만 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="853f4abcb0adc2f4d392d459e3d4bcbfc1ffde02" translate="yes" xml:space="preserve">
          <source>This function will return an error if the RwLock is poisoned. An RwLock is poisoned whenever a writer panics while holding an exclusive lock. The failure will occur immediately after the lock has been acquired.</source>
          <target state="translated">이 기능은 RwLock이 감염된 경우 오류를 반환합니다. RwLock은 독자적인 잠금을 유지하면서 라이터가 패닉 할 때마다 중독됩니다. 잠금이 획득 된 직후 실패가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="08332f9ce278762f6fd52afefe704489d0688f37" translate="yes" xml:space="preserve">
          <source>This function will return an error if the file is not opened for writing.</source>
          <target state="translated">파일을 쓰기 위해 열지 않은 경우이 함수는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cdbfb4a0b16adba4591761f7aedf5e4a9ea34196" translate="yes" xml:space="preserve">
          <source>This function will return an error if the file is not opened for writing. Also, std::io::ErrorKind::InvalidInput will be returned if the desired length would cause an overflow due to the implementation specifics.</source>
          <target state="translated">이 함수는 쓰기 위해 파일을 열지 않은 경우 오류를 반환합니다. 또한 원하는 길이로 인해 구현 세부 사항으로 인해 오버플로가 발생하면 std :: io :: ErrorKind :: InvalidInput이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b6cdf441223c3eb9f4334399883d69c73ecd1bf4" translate="yes" xml:space="preserve">
          <source>This function will return an error if the mutex being waited on is poisoned when this thread re-acquires the lock. For more information, see information about &lt;a href=&quot;struct.mutex#poisoning&quot;&gt;poisoning&lt;/a&gt; on the &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">이 스레드가 잠금을 다시 획득 할 때 대기중인 뮤텍스가 중독되면이 함수는 오류를 리턴합니다. 자세한 정보 는 &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; 유형의 &lt;a href=&quot;struct.mutex#poisoning&quot;&gt;중독&lt;/a&gt; 에 대한 정보를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27a931587ff628dc51ea9585254e81a44150f056" translate="yes" xml:space="preserve">
          <source>This function will return an error if the supplied bytes contain an internal 0 byte. The &lt;a href=&quot;struct.nulerror&quot;&gt;&lt;code&gt;NulError&lt;/code&gt;&lt;/a&gt; returned will contain the bytes as well as the position of the nul byte.</source>
          <target state="translated">제공된 바이트에 내부 0 바이트가 포함 된 경우이 함수는 오류를 반환합니다. 반환 된 &lt;a href=&quot;struct.nulerror&quot;&gt; &lt;code&gt;NulError&lt;/code&gt; &lt;/a&gt; 는 바이트와 널 바이트의 위치를 ​​포함합니다.</target>
        </trans-unit>
        <trans-unit id="dbf84289e9d9e4926b496bd897b3083ec6312b71" translate="yes" xml:space="preserve">
          <source>This function will return an error if the user lacks permission change attributes on the underlying file. It may also return an error in other os-specific unspecified cases.</source>
          <target state="translated">이 함수는 사용자에게 기본 파일에 대한 권한 변경 속성이없는 경우 오류를 반환합니다. 또한 다른 OS 별 지정되지 않은 경우 오류를 반환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d42b76127c0c24013b14924e889090949109ff6" translate="yes" xml:space="preserve">
          <source>This function will return an error immediately if any call to &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; returns an error. All instances of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; are handled by this function and the underlying operation is retried.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 호출이 오류를 반환하는 경우 즉시 오류를 반환합니다. &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 의 모든 인스턴스는 이 함수에 의해 처리되고 기본 작업이 다시 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="6020fefae74dafb3cbf7677aedde54d28946007d" translate="yes" xml:space="preserve">
          <source>This function will return an error immediately if any call to &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt; returns an error. All instances of &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; are handled by this function and the underlying operation is retried.</source>
          <target state="translated">이 함수는 &lt;code&gt;read&lt;/code&gt; 또는 &lt;code&gt;write&lt;/code&gt; 호출이 오류를 반환하면 즉시 오류를 반환합니다. &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; 의 모든 인스턴스는 이 함수에 의해 처리되며 기본 작업이 재 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="789ed5daa8073ac179354d082eb69d8ff28cdee6" translate="yes" xml:space="preserve">
          <source>This function will return an error in the following situations, but is not limited to just these cases:</source>
          <target state="translated">이 함수는 다음 상황에서 오류를 반환하지만 이러한 경우에만 국한되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c2926688126ed0bb4700cfc41330adcd34075d1" translate="yes" xml:space="preserve">
          <source>This function will return an error under a number of different circumstances. Some of these error conditions are listed here, together with their &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;ErrorKind&lt;/code&gt;&lt;/a&gt;. The mapping to &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;ErrorKind&lt;/code&gt;&lt;/a&gt;s is not part of the compatibility contract of the function, especially the &lt;code&gt;Other&lt;/code&gt; kind might change to more specific kinds in the future.</source>
          <target state="translated">이 함수는 여러 가지 다른 상황에서 오류를 반환합니다. 이러한 오류 조건 중 일부는 &lt;a href=&quot;../io/enum.errorkind&quot;&gt; &lt;code&gt;ErrorKind&lt;/code&gt; &lt;/a&gt; 와 함께 여기에 나열됩니다 . &lt;a href=&quot;../io/enum.errorkind&quot;&gt; &lt;code&gt;ErrorKind&lt;/code&gt; 에&lt;/a&gt; 대한 매핑 은 함수의 호환성 계약의 일부가 아니며 특히 &lt;code&gt;Other&lt;/code&gt; 유형은 향후 더 구체적인 유형으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbf346cba719ecc4a64a28fdc51747223ea1ead1" translate="yes" xml:space="preserve">
          <source>This function will return an error under a number of different circumstances. Some of these error conditions are listed here, together with their &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;io::ErrorKind&lt;/code&gt;&lt;/a&gt;. The mapping to &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;io::ErrorKind&lt;/code&gt;&lt;/a&gt;s is not part of the compatibility contract of the function, especially the &lt;a href=&quot;../io/enum.errorkind#variant.Other&quot;&gt;&lt;code&gt;Other&lt;/code&gt;&lt;/a&gt; kind might change to more specific kinds in the future.</source>
          <target state="translated">이 함수는 다양한 상황에서 오류를 반환합니다. 이러한 오류 조건 중 일부는 &lt;a href=&quot;../io/enum.errorkind&quot;&gt; &lt;code&gt;io::ErrorKind&lt;/code&gt; &lt;/a&gt; 와 함께 여기에 나열됩니다 . &lt;a href=&quot;../io/enum.errorkind&quot;&gt; &lt;code&gt;io::ErrorKind&lt;/code&gt; &lt;/a&gt; 대한 매핑 은 함수, 특히 &lt;a href=&quot;../io/enum.errorkind#variant.Other&quot;&gt; &lt;code&gt;Other&lt;/code&gt; &lt;/a&gt; 의 호환성 계약의 일부가 아닙니다. 종류는 향후 더 구체적인 종류로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6a8bd83b584fa0f13cb1bcd08f12c3e0060dff9" translate="yes" xml:space="preserve">
          <source>This function will return an instance of &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; on error.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 시 오류 인스턴스를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="6fae4edeb2bc2b830762c223977c0f9e31e7f71d" translate="yes" xml:space="preserve">
          <source>This function will return any I/O error reported while formatting.</source>
          <target state="translated">이 함수는 포맷 중에보고 된 모든 I / O 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="82d9dcac7df30707ace2de701aba5471ae21281c" translate="yes" xml:space="preserve">
          <source>This function will return the first error of non-&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind that &lt;a href=&quot;#tymethod.write_at&quot;&gt;&lt;code&gt;write_at&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#tymethod.write_at&quot;&gt; &lt;code&gt;write_at&lt;/code&gt; 이&lt;/a&gt; 반환 하는 ErrorKind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류가 아닌 첫 번째 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cbfac2234e26fd5ad38b1fb7d157edb650781848" translate="yes" xml:space="preserve">
          <source>This function will return the first error of non-&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind that &lt;a href=&quot;trait.fileext#tymethod.write_at&quot;&gt;&lt;code&gt;write_at&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="translated">이 기능은 비의 첫 번째 오류 반환합니다 &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 그런 종류의 &lt;a href=&quot;trait.fileext#tymethod.write_at&quot;&gt; &lt;code&gt;write_at&lt;/code&gt; &lt;/a&gt; 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="e505864f4a28d60809a69e771d2b212f82c7410c" translate="yes" xml:space="preserve">
          <source>This function will return the first error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind that &lt;a href=&quot;#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 오류가 아닌 &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 의 첫 번째 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e4e34f750f27d3b0d205fe34d5653142bb6c6abe" translate="yes" xml:space="preserve">
          <source>This function will return the first error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind that &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 반환 하는 비 &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 의 첫 번째 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="749cf49b6adfac5a93f23dcbbade901579686611" translate="yes" xml:space="preserve">
          <source>This function will still &lt;code&gt;panic!()&lt;/code&gt; if the key is uninitialized and the key's initializer panics.</source>
          <target state="translated">이 함수는 여전히 &lt;code&gt;panic!()&lt;/code&gt; 키가 초기화되지 않고 키의 이니셜 라이저가 패닉 인 경우 .</target>
        </trans-unit>
        <trans-unit id="aa2dcaf81660e38d976b3c073799f64e35c409b8" translate="yes" xml:space="preserve">
          <source>This function will traverse symbolic links to query information about the destination file.</source>
          <target state="translated">이 함수는 심볼릭 링크를 탐색하여 대상 파일에 대한 정보를 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="7a60f9a71c97e3c48d6ddbb61757095cfb7454e6" translate="yes" xml:space="preserve">
          <source>This function will traverse symbolic links to query information about the destination file. In case of broken symbolic links this will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 함수는 심볼릭 링크를 탐색하여 대상 파일에 대한 정보를 쿼리합니다. 심볼릭 링크가 끊어지면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e2e9a4f19c05867342225932a802795ba8df8be2" translate="yes" xml:space="preserve">
          <source>This function will unsafely assume the pointer &lt;code&gt;src&lt;/code&gt; is valid for &lt;a href=&quot;fn.size_of&quot;&gt;&lt;code&gt;size_of::&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; bytes by transmuting &lt;code&gt;&amp;amp;T&lt;/code&gt; to &lt;code&gt;&amp;amp;U&lt;/code&gt; and then reading the &lt;code&gt;&amp;amp;U&lt;/code&gt; (except that this is done in a way that is correct even when &lt;code&gt;&amp;amp;U&lt;/code&gt; makes stricter alignment requirements than &lt;code&gt;&amp;amp;T&lt;/code&gt;). It will also unsafely create a copy of the contained value instead of moving out of &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">안전하지 포인터 가정합니다이 기능 &lt;code&gt;src&lt;/code&gt; 유효 &lt;a href=&quot;fn.size_of&quot;&gt; &lt;code&gt;size_of::&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt; 변형의에 의해 바이트 &lt;code&gt;&amp;amp;T&lt;/code&gt; 에 &lt;code&gt;&amp;amp;U&lt;/code&gt; 후 읽기 &lt;code&gt;&amp;amp;U&lt;/code&gt; (이 경우에도 올바른 방법으로 수행된다는 점을 제외 &lt;code&gt;&amp;amp;U&lt;/code&gt; 보다 엄격한 정렬 요구 사항을 만드는 &lt;code&gt;&amp;amp;T&lt;/code&gt; ) . 또한 &lt;code&gt;src&lt;/code&gt; 밖으로 이동하는 대신 포함 된 값의 복사본을 안전하지 않게 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="2144ac018e241484dd88280c401709723264165b" translate="yes" xml:space="preserve">
          <source>This function will unsafely assume the pointer &lt;code&gt;src&lt;/code&gt; is valid for &lt;a href=&quot;fn.size_of&quot;&gt;&lt;code&gt;size_of::&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; bytes by transmuting &lt;code&gt;&amp;amp;T&lt;/code&gt; to &lt;code&gt;&amp;amp;U&lt;/code&gt; and then reading the &lt;code&gt;&amp;amp;U&lt;/code&gt;. It will also unsafely create a copy of the contained value instead of moving out of &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">안전하지 포인터 가정합니다이 기능 &lt;code&gt;src&lt;/code&gt; 유효 &lt;a href=&quot;fn.size_of&quot;&gt; &lt;code&gt;size_of::&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt; 변형의에 의해 바이트 &lt;code&gt;&amp;amp;T&lt;/code&gt; 에 &lt;code&gt;&amp;amp;U&lt;/code&gt; 다음 읽기 &lt;code&gt;&amp;amp;U&lt;/code&gt; . 또한 &lt;code&gt;src&lt;/code&gt; 밖으로 이동하는 대신 포함 된 값의 복사본을 안전하지 않게 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="be98532def31c781d65ddc0b9dc20df02eb564e6" translate="yes" xml:space="preserve">
          <source>This function will wrap the provided &lt;code&gt;ptr&lt;/code&gt; with a &lt;code&gt;CStr&lt;/code&gt; wrapper, which allows inspection and interoperation of non-owned C strings. The total size of the raw C string must be smaller than &lt;code&gt;isize::MAX&lt;/code&gt;&lt;strong&gt;bytes&lt;/strong&gt; in memory due to calling the &lt;code&gt;slice::from_raw_parts&lt;/code&gt; function. This method is unsafe for a number of reasons:</source>
          <target state="translated">이 함수는 제공된 &lt;code&gt;ptr&lt;/code&gt; 을 &lt;code&gt;CStr&lt;/code&gt; 래퍼로 래핑하여 소유하지 않은 C 문자열의 검사 및 상호 운용을 허용합니다. &lt;code&gt;slice::from_raw_parts&lt;/code&gt; 호출로 인해 원시 C 문자열의 총 크기는 메모리의 &lt;code&gt;isize::MAX&lt;/code&gt; &lt;strong&gt;바이트&lt;/strong&gt; 보다 작아야합니다. 함수 합니다. 이 방법은 여러 가지 이유로 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5bb3f5f774e85331b120930c24070df4dbb7ef1" translate="yes" xml:space="preserve">
          <source>This function will wrap the provided &lt;code&gt;ptr&lt;/code&gt; with a &lt;code&gt;CStr&lt;/code&gt; wrapper, which allows inspection and interoperation of non-owned C strings. This method is unsafe for a number of reasons:</source>
          <target state="translated">이 함수는 제공된 &lt;code&gt;ptr&lt;/code&gt; 을 &lt;code&gt;CStr&lt;/code&gt; 로 래핑합니다. 랩퍼로 소유하지 않은 C 문자열의 검사 및 상호 운용이 가능합니다. 이 방법은 여러 가지 이유로 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb6de22f90abba9d8b2e22f07508357043cd45b1" translate="yes" xml:space="preserve">
          <source>This function will yield errors whenever &lt;a href=&quot;#method.read_until&quot;&gt;&lt;code&gt;read_until&lt;/code&gt;&lt;/a&gt; would have also yielded an error.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#method.read_until&quot;&gt; &lt;code&gt;read_until&lt;/code&gt; &lt;/a&gt; 이 오류를 생성 할 때마다 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0ec10f22723b4146e4ed97d9a1ccb195f6666569" translate="yes" xml:space="preserve">
          <source>This function will yield errors whenever &lt;a href=&quot;trait.bufread#method.read_until&quot;&gt;&lt;code&gt;read_until&lt;/code&gt;&lt;/a&gt; would have also yielded an error.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;trait.bufread#method.read_until&quot;&gt; &lt;code&gt;read_until&lt;/code&gt; &lt;/a&gt; 이 오류를 생성 할 때마다 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="761c3823fedfe961f64b60f5bbf8dadb1c015978" translate="yes" xml:space="preserve">
          <source>This function works on a best-effort basis, and may return false even when the &lt;code&gt;Waker&lt;/code&gt;s would awaken the same task. However, if this function returns &lt;code&gt;true&lt;/code&gt;, it is guaranteed that the &lt;code&gt;Waker&lt;/code&gt;s will awaken the same task.</source>
          <target state="translated">이 함수는 최선의 노력으로 작동하며 &lt;code&gt;Waker&lt;/code&gt; 가 동일한 작업을 깨워 도 거짓을 반환 할 수 있습니다 . 그러나이 함수가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 &lt;code&gt;Waker&lt;/code&gt; 가 동일한 작업을 깨울 것입니다.</target>
        </trans-unit>
        <trans-unit id="0fef1eb994767850b63d5d3191f1364d1d996711" translate="yes" xml:space="preserve">
          <source>This function works similar to &lt;a href=&quot;../iter/trait.iterator#method.filter&quot;&gt;&lt;code&gt;Iterator::filter()&lt;/code&gt;&lt;/a&gt;. You can imagine the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; being an iterator over one or zero elements. &lt;code&gt;filter()&lt;/code&gt; lets you decide which elements to keep.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;../iter/trait.iterator#method.filter&quot;&gt; &lt;code&gt;Iterator::filter()&lt;/code&gt; &lt;/a&gt; 와 유사하게 작동합니다 . &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 가 하나 또는 0 개의 요소에 대한 반복 자라고 상상할 수 있습니다 . &lt;code&gt;filter()&lt;/code&gt; 사용하면 유지할 요소를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ae0840523d6333733f66bb75a006add83e1ec36" translate="yes" xml:space="preserve">
          <source>This function works similar to &lt;code&gt;Iterator::filter()&lt;/code&gt;. You can imagine the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; being an iterator over one or zero elements. &lt;code&gt;filter()&lt;/code&gt; lets you decide which elements to keep.</source>
          <target state="translated">이 함수는 &lt;code&gt;Iterator::filter()&lt;/code&gt; 와 유사하게 작동합니다 . &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 가 하나 또는 0 개의 요소에 대한 반복 자라고 상상할 수 있습니다 . &lt;code&gt;filter()&lt;/code&gt; 사용하면 유지할 요소를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="113d936138ddc7ae4f63a1a50d8105ac5a7add0d" translate="yes" xml:space="preserve">
          <source>This function&amp;rsquo;s signature is less cluttered: the function name, parameter list, and return type are close together, similar to a function without lots of trait bounds.</source>
          <target state="translated">이 함수의 서명은 덜 복잡합니다. 함수 이름, 매개 변수 목록 및 리턴 유형은 많은 특성 한계가없는 함수와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="23da01dd3aa4ebf7371ab6dbecf83fca400f0b49" translate="yes" xml:space="preserve">
          <source>This function's behavior is unexpected and probably not what you want. Consider using a crate from crates.io instead.</source>
          <target state="translated">이 함수의 동작은 예상치 못한 것이며 아마도 원하는 것이 아닐 것입니다. 대신 crates.io의 상자를 사용하는 것을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="59db1f1ce2d556d00a44653625d9c4310aa82a71" translate="yes" xml:space="preserve">
          <source>This function, &lt;code&gt;first_word&lt;/code&gt;, has a &lt;code&gt;&amp;amp;String&lt;/code&gt; as a parameter. We don&amp;rsquo;t want ownership, so this is fine. But what should we return? We don&amp;rsquo;t really have a way to talk about &lt;em&gt;part&lt;/em&gt; of a string. However, we could return the index of the end of the word. Let&amp;rsquo;s try that, as shown in Listing 4-7.</source>
          <target state="translated">이 함수 &lt;code&gt;first_word&lt;/code&gt; 는 매개 변수로 &lt;code&gt;&amp;amp;String&lt;/code&gt; 을 갖습니다 . 우리는 소유권을 원하지 않으므로 괜찮습니다. 그러나 우리는 무엇을 반환해야합니까? 우리는 실제로 문자열의 &lt;em&gt;일부&lt;/em&gt; 에 대해 이야기 할 수있는 방법이 없습니다 . 그러나 단어 끝의 색인을 반환 할 수 있습니다. Listing 4-7에 표시된 것처럼 시도해 보자.</target>
        </trans-unit>
        <trans-unit id="c0b65dd63b8d87baa6cb2781b4c83fe9b710f211" translate="yes" xml:space="preserve">
          <source>This function, unlike &lt;code&gt;spawn&lt;/code&gt;, will &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;fork&lt;/code&gt; the process to create a new child. Like spawn, however, the default behavior for the stdio descriptors will be to inherited from the current process.</source>
          <target state="translated">이 기능을 달리 &lt;code&gt;spawn&lt;/code&gt; , 것입니다 &lt;strong&gt;하지 &lt;/strong&gt; &lt;code&gt;fork&lt;/code&gt; 새로운 아이를 만드는 과정을. 그러나 스폰처럼 stdio 디스크립터의 기본 동작은 현재 프로세스에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="a7e07fc3dba284598652a13174e554562e5525f8" translate="yes" xml:space="preserve">
          <source>This handle encapsulates a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; instance, which defines the executor-specific wakeup behavior.</source>
          <target state="translated">이 핸들 은 실행 프로그램 별 웨이크 업 동작을 정의 하는 &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; 인스턴스를 캡슐화합니다 .</target>
        </trans-unit>
        <trans-unit id="d605d26d55dc2758f0b6de9e17a49a349f074534" translate="yes" xml:space="preserve">
          <source>This handle implements both the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.bufread&quot;&gt;&lt;code&gt;BufRead&lt;/code&gt;&lt;/a&gt; traits, and is constructed via the &lt;a href=&quot;struct.stdin#method.lock&quot;&gt;&lt;code&gt;Stdin::lock&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 핸들은 &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;trait.bufread&quot;&gt; &lt;code&gt;BufRead&lt;/code&gt; &lt;/a&gt; 특성을 모두 구현 하며 &lt;a href=&quot;struct.stdin#method.lock&quot;&gt; &lt;code&gt;Stdin::lock&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="f7258bae2e88ec63ae3dd338b65d64451a9b331b" translate="yes" xml:space="preserve">
          <source>This handle implements the &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; trait, and is constructed via the &lt;a href=&quot;struct.stdout#method.lock&quot;&gt;&lt;code&gt;Stdout::lock&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 핸들은 &lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; 특성을 구현하며 &lt;a href=&quot;struct.stdout#method.lock&quot;&gt; &lt;code&gt;Stdout::lock&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="d288bcdc54960c2a1210bed705519ebb1c8b509b" translate="yes" xml:space="preserve">
          <source>This handle implements the &lt;code&gt;Read&lt;/code&gt; trait, but beware that concurrent reads of &lt;code&gt;Stdin&lt;/code&gt; must be executed with care.</source>
          <target state="translated">이 핸들은 &lt;code&gt;Read&lt;/code&gt; 특성을 구현 하지만 &lt;code&gt;Stdin&lt;/code&gt; 의 동시 읽기를주의하십시오. 해서 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="01441d3c1d26b75fb46c2c721477af0652ee7979" translate="yes" xml:space="preserve">
          <source>This handle implements the &lt;code&gt;Write&lt;/code&gt; trait and is constructed via the &lt;a href=&quot;struct.stderr#method.lock&quot;&gt;&lt;code&gt;Stderr::lock&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 핸들은 &lt;code&gt;Write&lt;/code&gt; 특성을 구현하며 &lt;a href=&quot;struct.stderr#method.lock&quot;&gt; &lt;code&gt;Stderr::lock&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="2708f4eb8582ea4d70309feff62a1d2748e13184" translate="yes" xml:space="preserve">
          <source>This handle is not buffered.</source>
          <target state="translated">이 핸들은 버퍼링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c48d5f61a1b6b181a01656b1e94697dc7bb9249" translate="yes" xml:space="preserve">
          <source>This happens because the pointer returned by &lt;code&gt;as_ptr&lt;/code&gt; does not carry any lifetime information and the &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; is deallocated immediately after the &lt;code&gt;CString::new(&quot;Hello&quot;).expect(&quot;CString::new failed&quot;).as_ptr()&lt;/code&gt; expression is evaluated. To fix the problem, bind the &lt;code&gt;CString&lt;/code&gt; to a local variable:</source>
          <target state="translated">이는 &lt;code&gt;as_ptr&lt;/code&gt; 에서 반환 한 포인터에 수명 정보가없고 &lt;code&gt;CString::new(&quot;Hello&quot;).expect(&quot;CString::new failed&quot;).as_ptr()&lt;/code&gt; 식이 평가 된 직후 &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; 이 할당 해제 되기 때문에 발생 합니다 . 문제를 해결하려면 &lt;code&gt;CString&lt;/code&gt; 을 로컬 변수에 바인딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="6047b82331195849fba72da79674452a117df64d" translate="yes" xml:space="preserve">
          <source>This happens when a trait has a method like the following:</source>
          <target state="translated">이것은 특성에 다음과 같은 방법이있을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="863bad715d4f6d1bd75efa3884a2cc5b250ca381" translate="yes" xml:space="preserve">
          <source>This has the same behavior as the &lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이것은 &lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt; &lt;code&gt;push_str&lt;/code&gt; &lt;/a&gt; 메소드 와 동일한 동작을합니다 .</target>
        </trans-unit>
        <trans-unit id="6a3c452ab4ee63f33d895b0f991faaa23887feb8" translate="yes" xml:space="preserve">
          <source>This has the same behavior as the &lt;a href=&quot;struct.string#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이것은 &lt;a href=&quot;struct.string#method.push_str&quot;&gt; &lt;code&gt;push_str&lt;/code&gt; &lt;/a&gt; 메소드 와 동일한 동작을합니다 .</target>
        </trans-unit>
        <trans-unit id="b58a8c2add590746e5048b4f132cbbc19047500f" translate="yes" xml:space="preserve">
          <source>This has the same effect as &lt;a href=&quot;union.maybeuninit#method.zeroed&quot;&gt;&lt;code&gt;MaybeUninit::zeroed().assume_init()&lt;/code&gt;&lt;/a&gt;. It is useful for FFI sometimes, but should generally be avoided.</source>
          <target state="translated">이것은 &lt;a href=&quot;union.maybeuninit#method.zeroed&quot;&gt; &lt;code&gt;MaybeUninit::zeroed().assume_init()&lt;/code&gt; &lt;/a&gt; 와 동일한 효과를 갖습니다 . 때때로 FFI에 유용하지만 일반적으로 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7eb4340faf9e85d2da20b4776ce2bebbe29c12a" translate="yes" xml:space="preserve">
          <source>This has the same lifetime as the original slice, and so the iterator can continue to be used while this exists.</source>
          <target state="translated">이것은 원래 슬라이스와 동일한 수명을 가지므로 이것이 존재하는 동안 반복기를 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65d35375dd8acb85bc9eba434584e8313fb0a245" translate="yes" xml:space="preserve">
          <source>This hasher is not guaranteed to be the same as all other &lt;code&gt;DefaultHasher&lt;/code&gt; instances, but is the same as all other &lt;code&gt;DefaultHasher&lt;/code&gt; instances created through &lt;code&gt;new&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">이 hasher는 다른 모든 &lt;code&gt;DefaultHasher&lt;/code&gt; 인스턴스와 동일하지는 않지만 &lt;code&gt;new&lt;/code&gt; 또는 &lt;code&gt;default&lt;/code&gt; 를 통해 작성된 다른 모든 &lt;code&gt;DefaultHasher&lt;/code&gt; 인스턴스 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="90feee4915436dfe2be982f4c15a9da7834c5004" translate="yes" xml:space="preserve">
          <source>This implementation is specialized for slice iterators, where it uses &lt;a href=&quot;../primitive.slice#method.copy_from_slice&quot;&gt;&lt;code&gt;copy_from_slice&lt;/code&gt;&lt;/a&gt; to append the entire slice at once.</source>
          <target state="translated">이 구현은 슬라이스 반복기에 특화되어 있으며 여기서 &lt;a href=&quot;../primitive.slice#method.copy_from_slice&quot;&gt; &lt;code&gt;copy_from_slice&lt;/code&gt; &lt;/a&gt; 를 사용 하여 전체 슬라이스를 한 번에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0b6b99c1c8632506c647afb83336adc1ee13b73f" translate="yes" xml:space="preserve">
          <source>This information corresponds to the &lt;code&gt;sin6_flowinfo&lt;/code&gt; field in C's &lt;code&gt;netinet/in.h&lt;/code&gt;, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt;. It combines information about the flow label and the traffic class as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2460&quot;&gt;IETF RFC 2460&lt;/a&gt;, respectively &lt;a href=&quot;https://tools.ietf.org/html/rfc2460#section-6&quot;&gt;Section 6&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2460#section-7&quot;&gt;Section 7&lt;/a&gt;.</source>
          <target state="translated">이 정보 는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553 섹션 3.3에&lt;/a&gt; 지정된 C의 &lt;code&gt;netinet/in.h&lt;/code&gt; 에 있는 &lt;code&gt;sin6_flowinfo&lt;/code&gt; 필드에 해당합니다 . &lt;a href=&quot;https://tools.ietf.org/html/rfc2460&quot;&gt;IETF RFC 2460&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2460#section-6&quot;&gt;섹션 6&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc2460#section-7&quot;&gt;섹션 7에&lt;/a&gt; 지정된대로 플로우 레이블 및 트래픽 클래스에 대한 정보를 결합합니다 .</target>
        </trans-unit>
        <trans-unit id="3af31b70c11ef4a3b608a04beaf7ba9284e068c3" translate="yes" xml:space="preserve">
          <source>This information corresponds to the &lt;code&gt;sin6_scope_id&lt;/code&gt; field in C's &lt;code&gt;netinet/in.h&lt;/code&gt;, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt;.</source>
          <target state="translated">이 정보 는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553 섹션 3.3에&lt;/a&gt; 지정된 C의 &lt;code&gt;netinet/in.h&lt;/code&gt; 에 있는 &lt;code&gt;sin6_scope_id&lt;/code&gt; 필드에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="ec67651ac375d4791b71fe8abc3629f814f16ccf" translate="yes" xml:space="preserve">
          <source>This information is a hint and implementations are not required to preserve it.</source>
          <target state="translated">이 정보는 힌트이며이를 보존하기 위해 구현할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="63ed31757d724807cc9238c95c5432cd39c9735a" translate="yes" xml:space="preserve">
          <source>This instance may reach &lt;code&gt;EOF&lt;/code&gt; after reading fewer bytes than indicated by this method if the underlying &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; instance reaches EOF.</source>
          <target state="translated">기본 &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; 인스턴스가 EOF에 도달하면 이 메소드가 나타내는 것보다 적은 바이트를 읽은 &lt;code&gt;EOF&lt;/code&gt; 인스턴스가 EOF에 도달 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e890a8fb1ba0d0cd9928016f0c75ede3fcfd9a0" translate="yes" xml:space="preserve">
          <source>This intrinsic does not have a stable counterpart.</source>
          <target state="translated">이 내장 함수에는 안정적인 대응 항목이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b4ee533fa428c42a5629056a56b7692fc9445d45" translate="yes" xml:space="preserve">
          <source>This intrinsic should not be used outside of the compiler.</source>
          <target state="translated">이 내장 함수는 컴파일러 외부에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="1fa64cf4a4634521305dce783239fdfdeec13027" translate="yes" xml:space="preserve">
          <source>This is a &quot;helper marker trait&quot; used to provide impl blocks for the &lt;a href=&quot;trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt; trait, for more information see that documentation.</source>
          <target state="translated">&lt;a href=&quot;trait.unwindsafe&quot;&gt; &lt;code&gt;UnwindSafe&lt;/code&gt; 에&lt;/a&gt; impl 블록을 제공하는 데 사용되는 &quot;도우미 마커 특성&quot;입니다. 특성에 대한 입니다. 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dca2a0780f1a583478627dae521a3cd19fa18332" translate="yes" xml:space="preserve">
          <source>This is a convenience function for using &lt;a href=&quot;struct.file#method.create&quot;&gt;&lt;code&gt;File::create&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt; with fewer imports.</source>
          <target state="translated">가져 오기 &lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt; &lt;code&gt;write_all&lt;/code&gt; &lt;/a&gt; 가 적은 &lt;a href=&quot;struct.file#method.create&quot;&gt; &lt;code&gt;File::create&lt;/code&gt; &lt;/a&gt; 및 write_all 을 사용하기위한 편리한 기능입니다 .</target>
        </trans-unit>
        <trans-unit id="8a3e47d631d6356541264338a28634452afdd7c3" translate="yes" xml:space="preserve">
          <source>This is a convenience function for using &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.read#method.read_to_end&quot;&gt;&lt;code&gt;read_to_end&lt;/code&gt;&lt;/a&gt; with fewer imports and without an intermediate variable. It pre-allocates a buffer based on the file size when available, so it is generally faster than reading into a vector created with &lt;a href=&quot;../vec/struct.vec#method.new&quot;&gt;&lt;code&gt;Vec::new()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;struct.file#method.open&quot;&gt; &lt;code&gt;File::open&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../io/trait.read#method.read_to_end&quot;&gt; &lt;code&gt;read_to_end&lt;/code&gt; &lt;/a&gt; 를 더 적게 가져오고 중간 변수없이 사용하기위한 편리한 함수입니다 . 가능한 경우 파일 크기에 따라 버퍼를 미리 할당하므로 일반적으로 &lt;a href=&quot;../vec/struct.vec#method.new&quot;&gt; &lt;code&gt;Vec::new()&lt;/code&gt; &lt;/a&gt; 만든 벡터로 읽는 것보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="187131cff0eb9e697908b49a26f702ec337c3799" translate="yes" xml:space="preserve">
          <source>This is a convenience function for using &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.read#method.read_to_end&quot;&gt;&lt;code&gt;read_to_end&lt;/code&gt;&lt;/a&gt; with fewer imports and without an intermediate variable. It pre-allocates a buffer based on the file size when available, so it is generally faster than reading into a vector created with &lt;code&gt;Vec::new()&lt;/code&gt;.</source>
          <target state="translated">이는 가져 오기 &lt;a href=&quot;../io/trait.read#method.read_to_end&quot;&gt; &lt;code&gt;read_to_end&lt;/code&gt; &lt;/a&gt; 가 적고 중간 변수없이 &lt;a href=&quot;struct.file#method.open&quot;&gt; &lt;code&gt;File::open&lt;/code&gt; &lt;/a&gt; 및 read_to_end 를 사용하기위한 편리한 기능입니다 . 사용 가능한 경우 파일 크기를 기준으로 버퍼를 미리 할당하므로 일반적으로 &lt;code&gt;Vec::new()&lt;/code&gt; 만든 벡터를 읽는 것보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="4ad096cd1a7e9fdbf72506102cbfdd2fbcf9b981" translate="yes" xml:space="preserve">
          <source>This is a convenience function for using &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.read#method.read_to_string&quot;&gt;&lt;code&gt;read_to_string&lt;/code&gt;&lt;/a&gt; with fewer imports and without an intermediate variable. It pre-allocates a buffer based on the file size when available, so it is generally faster than reading into a string created with &lt;a href=&quot;../string/struct.string#method.new&quot;&gt;&lt;code&gt;String::new()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;struct.file#method.open&quot;&gt; &lt;code&gt;File::open&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../io/trait.read#method.read_to_string&quot;&gt; &lt;code&gt;read_to_string&lt;/code&gt; &lt;/a&gt; 을 더 적은 수의 가져 오기와 중간 변수없이 사용하기위한 편리한 함수입니다 . 사용 가능한 경우 파일 크기에 따라 버퍼를 미리 할당하므로 일반적으로 &lt;a href=&quot;../string/struct.string#method.new&quot;&gt; &lt;code&gt;String::new()&lt;/code&gt; &lt;/a&gt; 만든 문자열을 읽는 것보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="9c7392177420bfa03e5c328d086366669dabd90c" translate="yes" xml:space="preserve">
          <source>This is a convenience function for using &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.read#method.read_to_string&quot;&gt;&lt;code&gt;read_to_string&lt;/code&gt;&lt;/a&gt; with fewer imports and without an intermediate variable. It pre-allocates a buffer based on the file size when available, so it is generally faster than reading into a string created with &lt;code&gt;String::new()&lt;/code&gt;.</source>
          <target state="translated">이것은 수입이 적고 중간 변수없이 &lt;a href=&quot;struct.file#method.open&quot;&gt; &lt;code&gt;File::open&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../io/trait.read#method.read_to_string&quot;&gt; &lt;code&gt;read_to_string&lt;/code&gt; &lt;/a&gt; 을 사용하기위한 편리한 기능입니다 . 사용 가능한 경우 파일 크기에 따라 버퍼를 미리 할당하므로 일반적으로 &lt;code&gt;String::new()&lt;/code&gt; 만든 문자열을 읽는 것보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="6368465bb72af615f875d8e839f3e68ea414aaaa" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; and handle its &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;. Then call &lt;a href=&quot;../fs/struct.metadata#method.is_dir&quot;&gt;&lt;code&gt;fs::Metadata::is_dir&lt;/code&gt;&lt;/a&gt; if it was &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 오류를 거짓으로 강제하는 편리한 함수입니다. 오류를 확인하려면 &lt;a href=&quot;../fs/fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt; 호출 하고 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; 를&lt;/a&gt; 처리하십시오 . 그런 다음 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../fs/struct.metadata#method.is_dir&quot;&gt; &lt;code&gt;fs::Metadata::is_dir&lt;/code&gt; &lt;/a&gt; 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="8ec158d2dde1ce8ee75d1772394d851e65f39fd6" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; and handle its &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;. Then call &lt;a href=&quot;../fs/struct.metadata#method.is_file&quot;&gt;&lt;code&gt;fs::Metadata::is_file&lt;/code&gt;&lt;/a&gt; if it was &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 오류를 거짓으로 강제하는 편리한 함수입니다. 오류를 확인하려면 &lt;a href=&quot;../fs/fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt; 호출 하고 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; 를&lt;/a&gt; 처리하십시오 . 그런 다음 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../fs/struct.metadata#method.is_file&quot;&gt; &lt;code&gt;fs::Metadata::is_file&lt;/code&gt; &lt;/a&gt; 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="2f680ca8918b755dd586b16c26d23dbb3dd42957" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 오류를 거짓으로 강제하는 편리한 함수입니다. 오류를 확인하려면 &lt;a href=&quot;../fs/fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="dac9be08ca6ab3c0d6956dc411e028285b59848d" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs::metadata&lt;/a&gt; and handle its Result. Then call &lt;a href=&quot;../fs/struct.metadata#method.is_dir&quot;&gt;fs::Metadata::is_dir&lt;/a&gt; if it was Ok.</source>
          <target state="translated">이것은 에러를 거짓으로 강제하는 편리한 함수입니다. 오류를 확인하려면 &lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs :: metadata를&lt;/a&gt; 호출 하고 결과를 처리하십시오. 그런 다음 괜찮 으면 &lt;a href=&quot;../fs/struct.metadata#method.is_dir&quot;&gt;fs :: Metadata :: is_dir을&lt;/a&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="78d539aab76737f8cf396eefb6d1ce6f5b6f255b" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs::metadata&lt;/a&gt; and handle its Result. Then call &lt;a href=&quot;../fs/struct.metadata#method.is_file&quot;&gt;fs::Metadata::is_file&lt;/a&gt; if it was Ok.</source>
          <target state="translated">이것은 에러를 거짓으로 강제하는 편리한 함수입니다. 오류를 확인하려면 &lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs :: metadata를&lt;/a&gt; 호출 하고 결과를 처리하십시오. 그런 다음 괜찮 으면 &lt;a href=&quot;../fs/struct.metadata#method.is_file&quot;&gt;fs :: Metadata :: is_file을&lt;/a&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="63bfc9edacf3bb27391de3d729c554b4c3c2df6a" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs::metadata&lt;/a&gt;.</source>
          <target state="translated">이것은 에러를 거짓으로 강제하는 편리한 함수입니다. 오류를 확인하려면 &lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs :: metadata를&lt;/a&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="748753921bdcefd01924d5e43ae2dad4f042e3b3" translate="yes" xml:space="preserve">
          <source>This is a cost-free conversion.</source>
          <target state="translated">이 비용은 무료입니다.</target>
        </trans-unit>
        <trans-unit id="0bed32ad8a4ac210351c4fe08ac569f4ede1369a" translate="yes" xml:space="preserve">
          <source>This is a curious macro used to safely pass around an opaque object describing the format string. This object does not require any heap allocations to create, and it only references information on the stack. Under the hood, all of the related macros are implemented in terms of this. First off, some example usage is:</source>
          <target state="translated">이것은 형식 문자열을 설명하는 불투명 한 개체를 안전하게 전달하는 데 사용되는 흥미로운 매크로입니다. 이 개체는 생성하는 데 힙 할당이 필요하지 않으며 스택의 정보 만 참조합니다. 내부적으로 모든 관련 매크로가 이와 관련하여 구현됩니다. 먼저 몇 가지 사용 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="29fa7c971247c161eeccc64d10b730dfdf57cf6f" translate="yes" xml:space="preserve">
          <source>This is a curious macro which is used to safely pass around an opaque object describing the format string. This object does not require any heap allocations to create, and it only references information on the stack. Under the hood, all of the related macros are implemented in terms of this. First off, some example usage is:</source>
          <target state="translated">이것은 형식 문자열을 설명하는 불투명 한 객체를 안전하게 전달하는 데 사용되는 호기심 매크로입니다. 이 객체는 생성하는 데 힙 할당이 필요하지 않으며 스택의 정보 만 참조합니다. 후드 아래에서 모든 관련 매크로가 이와 관련하여 구현됩니다. 먼저 몇 가지 사용 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5cb34f6e2e869f23ba4b01f87c2789e85bd0de1" translate="yes" xml:space="preserve">
          <source>This is a generic method to go from &lt;code&gt;&amp;amp;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; to &lt;code&gt;Pin&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;. It is safe because, as part of the contract of &lt;code&gt;Pin::new_unchecked&lt;/code&gt;, the pointee cannot move after &lt;code&gt;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; got created. &quot;Malicious&quot; implementations of &lt;code&gt;Pointer::Deref&lt;/code&gt; are likewise ruled out by the contract of &lt;code&gt;Pin::new_unchecked&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;&amp;amp;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;Pin&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; 로 이동하는 일반적인 방법 입니다. &lt;code&gt;Pin::new_unchecked&lt;/code&gt; 의 계약의 일부로 &lt;code&gt;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 가 생성 된 후 포인트를 이동할 수 없기 때문에 안전 합니다. &lt;code&gt;Pointer::Deref&lt;/code&gt; 의 &quot;악의적 인&quot;구현 은 &lt;code&gt;Pin::new_unchecked&lt;/code&gt; 의 계약에 의해 배제됩니다 .</target>
        </trans-unit>
        <trans-unit id="56c4f5951c7828ae5ee50cc814a919ce365cfc61" translate="yes" xml:space="preserve">
          <source>This is a generic method to go from &lt;code&gt;&amp;amp;mut Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; to &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt;. It is safe because, as part of the contract of &lt;code&gt;Pin::new_unchecked&lt;/code&gt;, the pointee cannot move after &lt;code&gt;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; got created. &quot;Malicious&quot; implementations of &lt;code&gt;Pointer::DerefMut&lt;/code&gt; are likewise ruled out by the contract of &lt;code&gt;Pin::new_unchecked&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;&amp;amp;mut Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; 로 이동하는 일반적인 방법 입니다. &lt;code&gt;Pin::new_unchecked&lt;/code&gt; 의 계약의 일부로 &lt;code&gt;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 가 생성 된 후 포인트를 이동할 수 없기 때문에 안전 합니다. &lt;code&gt;Pointer::DerefMut&lt;/code&gt; 의 &quot;악의적 인&quot;구현 은 &lt;code&gt;Pin::new_unchecked&lt;/code&gt; 의 계약에 의해 배제됩니다 .</target>
        </trans-unit>
        <trans-unit id="89763ee5b7958c417ffa6362fe62836bd12504df" translate="yes" xml:space="preserve">
          <source>This is a great time to build a more substantial program to get used to reading and writing Rust code. So, in Chapter 2, we&amp;rsquo;ll build a guessing game program. If you would rather start by learning how common programming concepts work in Rust, see Chapter 3 and then return to Chapter 2.</source>
          <target state="translated">Rust 코드를 읽고 쓰는 데 익숙한보다 실질적인 프로그램을 구축하기에 좋은시기입니다. 따라서 2 장에서는 추측 게임 프로그램을 작성합니다. Rust에서 일반적인 프로그래밍 개념의 작동 방식을 배우는 것부터 시작하려면 3 장을 참조한 다음 2 장으로 돌아가십시오.</target>
        </trans-unit>
        <trans-unit id="bafda2af6137ec515a17c15aeff3f2735f4091da" translate="yes" xml:space="preserve">
          <source>This is a hack to work around a limitation in our type system.</source>
          <target state="translated">이것은 우리 유형 시스템의 제한을 해결하기위한 해킹입니다.</target>
        </trans-unit>
        <trans-unit id="b462da8b85a8420993ace33b35e2459c3b0f94de" translate="yes" xml:space="preserve">
          <source>This is a hack to workaround a limitation in our type-system.</source>
          <target state="translated">이것은 우리 유형 시스템의 제한을 해결하기위한 해킹입니다.</target>
        </trans-unit>
        <trans-unit id="88ca2eb8b4f8037d6f9bc35aac9a7c204a66255a" translate="yes" xml:space="preserve">
          <source>This is a larger example that implements &lt;a href=&quot;http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm&quot;&gt;Dijkstra's algorithm&lt;/a&gt; to solve the &lt;a href=&quot;http://en.wikipedia.org/wiki/Shortest_path_problem&quot;&gt;shortest path problem&lt;/a&gt; on a &lt;a href=&quot;http://en.wikipedia.org/wiki/Directed_graph&quot;&gt;directed graph&lt;/a&gt;. It shows how to use &lt;a href=&quot;struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt; with custom types.</source>
          <target state="translated">이것은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm&quot;&gt;Dijkstra의 알고리즘&lt;/a&gt; 을 구현 하여 유 &lt;a href=&quot;http://en.wikipedia.org/wiki/Directed_graph&quot;&gt;방향 그래프&lt;/a&gt; 의 &lt;a href=&quot;http://en.wikipedia.org/wiki/Shortest_path_problem&quot;&gt;최단 경로 문제&lt;/a&gt; 를 해결 하는 더 큰 예입니다 . &lt;a href=&quot;struct.binaryheap&quot;&gt; &lt;code&gt;BinaryHeap&lt;/code&gt; &lt;/a&gt; 을 사용자 정의 유형과 함께 사용하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="0ce22a5b8db2ccd4642599318fe60aee2faa03ed" translate="yes" xml:space="preserve">
          <source>This is a larger example that implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm&quot;&gt;Dijkstra's algorithm&lt;/a&gt; to solve the &lt;a href=&quot;https://en.wikipedia.org/wiki/Shortest_path_problem&quot;&gt;shortest path problem&lt;/a&gt; on a &lt;a href=&quot;https://en.wikipedia.org/wiki/Directed_graph&quot;&gt;directed graph&lt;/a&gt;. It shows how to use &lt;a href=&quot;../struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt; with custom types.</source>
          <target state="translated">이것은 구현하는 큰 예이다 &lt;a href=&quot;https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm&quot;&gt;익스트라 알고리즘은&lt;/a&gt; 상기와 같은 문제점을 해결하기 위하여 &lt;a href=&quot;https://en.wikipedia.org/wiki/Shortest_path_problem&quot;&gt;최단 경로 문제를&lt;/a&gt; (A)에 &lt;a href=&quot;https://en.wikipedia.org/wiki/Directed_graph&quot;&gt;관한 그래프&lt;/a&gt; . 사용자 지정 형식과 함께 &lt;a href=&quot;../struct.binaryheap&quot;&gt; &lt;code&gt;BinaryHeap&lt;/code&gt; &lt;/a&gt; 을 사용하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="26c511330b7bfd645fe1ae62ba92f808907b836b" translate="yes" xml:space="preserve">
          <source>This is a low-level operation that maintains none of the normal invariants of the type. Normally changing the length of a vector is done using one of the safe operations instead, such as &lt;a href=&quot;#method.truncate&quot;&gt;&lt;code&gt;truncate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.extend-1&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 유형의 정규 변량을 유지하지 않는 저수준 연산입니다. 일반적으로 벡터 길이 변경은 &lt;a href=&quot;#method.truncate&quot;&gt; &lt;code&gt;truncate&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#method.resize&quot;&gt; &lt;code&gt;resize&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#method.extend-1&quot;&gt; &lt;code&gt;extend&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt; 와 같은 안전한 작업 중 하나를 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="f83da737778161016a797e059513bd95b7a1b562" translate="yes" xml:space="preserve">
          <source>This is a low-level operation that maintains none of the normal invariants of the type. Normally changing the length of a vector is done using one of the safe operations instead, such as &lt;a href=&quot;struct.vec#method.truncate&quot;&gt;&lt;code&gt;truncate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.vec#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../iter/trait.extend#tymethod.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;struct.vec#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 유형의 정상적인 불변을 유지하지 않는 저수준 작업입니다. 일반적으로 벡터 길이 변경은 &lt;a href=&quot;struct.vec#method.truncate&quot;&gt; &lt;code&gt;truncate&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.vec#method.resize&quot;&gt; &lt;code&gt;resize&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../iter/trait.extend#tymethod.extend&quot;&gt; &lt;code&gt;extend&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.vec#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt; 와 같은 안전한 작업 중 하나를 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="e5a83358209b9d321dd626221b446c20e90a835f" translate="yes" xml:space="preserve">
          <source>This is a lower-level version of &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 하위 버전의 &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d779513c1e09f65a072541be686df3371c86d19d" translate="yes" xml:space="preserve">
          <source>This is a minimal HTML5 document with a heading and some text. To return this from the server when a request is received, we&amp;rsquo;ll modify &lt;code&gt;handle_connection&lt;/code&gt; as shown in Listing 20-5 to read the HTML file, add it to the response as a body, and send it.</source>
          <target state="translated">제목과 텍스트가 포함 된 최소 HTML5 문서입니다. 요청이 수신 될 때 서버에서이를 반환하기 위해 Listing 20-5에 표시된 것처럼 &lt;code&gt;handle_connection&lt;/code&gt; 을 수정 하여 HTML 파일을 읽고 응답에 본문으로 추가 한 후 보냅니다.</target>
        </trans-unit>
        <trans-unit id="b1799e7b3d355702a52652e9f785dc24c41920f9" translate="yes" xml:space="preserve">
          <source>This is a parameter for the &quot;minimum width&quot; that the format should take up. If the value's string does not fill up this many characters, then the padding specified by fill/alignment will be used to take up the required space (see below).</source>
          <target state="translated">형식이 차지해야하는 &quot;최소 너비&quot;에 대한 매개 변수입니다. 값의 문자열이 이만큼 많은 문자를 채우지 않으면 채우기 / 정렬로 지정된 패딩이 필요한 공간을 차지하는 데 사용됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="3a7bcaac4b774ad822d1d354cccc21a6015fca6e" translate="yes" xml:space="preserve">
          <source>This is a parameter for the &quot;minimum width&quot; that the format should take up. If the value's string does not fill up this many characters, then the padding specified by fill/alignment will be used to take up the required space.</source>
          <target state="translated">형식이 사용하는 &quot;최소 너비&quot;에 대한 매개 변수입니다. 값의 문자열이이 많은 문자를 채우지 않으면 채우기 / 정렬로 지정된 패딩이 필요한 공간을 차지하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b084ef158428b63f0e7eeac68dee8b3d095bdb3c" translate="yes" xml:space="preserve">
          <source>This is a situation in which interior mutability can help! We&amp;rsquo;ll store the &lt;code&gt;sent_messages&lt;/code&gt; within a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, and then the &lt;code&gt;send&lt;/code&gt; message will be able to modify &lt;code&gt;sent_messages&lt;/code&gt; to store the messages we&amp;rsquo;ve seen. Listing 15-22 shows what that looks like:</source>
          <target state="translated">이것은 내부 변이가 도움이 될 수있는 상황입니다! 우리는 저장할 수 있습니다 &lt;code&gt;sent_messages&lt;/code&gt; 을 내 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; , 다음 &lt;code&gt;send&lt;/code&gt; 메시지는 수정할 수 있습니다 &lt;code&gt;sent_messages&lt;/code&gt; 을 우리가 본 적이 메시지를 저장합니다. Listing 15-22는 다음과 같은 모습을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="871d091695de2003c7e2185527248e9604155d93" translate="yes" xml:space="preserve">
          <source>This is a syntax error at the level of attribute declarations. The proper syntax for &lt;code&gt;align&lt;/code&gt; representation hint is the following:</source>
          <target state="translated">속성 선언 수준의 구문 오류입니다. &lt;code&gt;align&lt;/code&gt; 표현 힌트 의 적절한 구문 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e698a362ad50285269b0f450993154391ed3fb9c" translate="yes" xml:space="preserve">
          <source>This is a syntax error at the level of attribute declarations. The proper syntax for macro imports is the following:</source>
          <target state="translated">이것은 속성 선언 수준에서 구문 오류입니다. 매크로 가져 오기에 대한 올바른 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7207d1f263b95ee330100ad60d168c6bbd00e341" translate="yes" xml:space="preserve">
          <source>This is a very simple case, of course. In more complex cases, we may wish to have more than one reference to the value that was borrowed -- in those cases, something like the &lt;code&gt;Rc&lt;/code&gt; or &lt;code&gt;Arc&lt;/code&gt; types may be useful.</source>
          <target state="translated">물론 이것은 매우 간단한 경우입니다. 좀 더 복잡한 경우에는 빌린 값에 대해 둘 이상의 참조를 원할 수 있습니다. 이러한 경우 &lt;code&gt;Rc&lt;/code&gt; 또는 &lt;code&gt;Arc&lt;/code&gt; 유형 과 같은 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="795aa426a1aadc3299f800d117f15424e179c91c" translate="yes" xml:space="preserve">
          <source>This is a wrapper around a kind of pointer which makes that pointer &quot;pin&quot; its value in place, preventing the value referenced by that pointer from being moved unless it implements &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 포인터는 일종의 포인터를 감싸는 래퍼로, 포인터가 해당 값을 &quot;핀&quot;하여 해당 포인터가 참조하는 값이 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 을 구현하지 않는 한 이동되지 않도록 합니다 .</target>
        </trans-unit>
        <trans-unit id="40cc1dd050d81853f1d6473844a8f5105ed4ba71" translate="yes" xml:space="preserve">
          <source>This is also available via &lt;a href=&quot;../convert/trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../convert/trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; 을&lt;/a&gt; 통해서도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69c7de76e4d6cac4ead699615a01132090109223" translate="yes" xml:space="preserve">
          <source>This is an &lt;code&gt;O(n)&lt;/code&gt; operation as it requires copying every element in the buffer.</source>
          <target state="translated">이것은 버퍼의 모든 요소를 ​​복사해야하므로 &lt;code&gt;O(n)&lt;/code&gt; 연산입니다.</target>
        </trans-unit>
        <trans-unit id="7714852846e41026b7148ab604a67c761a44e811" translate="yes" xml:space="preserve">
          <source>This is an &lt;code&gt;O(n)&lt;/code&gt; operation, as it requires copying every element in the buffer.</source>
          <target state="translated">이는 버퍼의 모든 요소를 ​​복사해야하므로 &lt;code&gt;O(n)&lt;/code&gt; 연산입니다.</target>
        </trans-unit>
        <trans-unit id="0851cea6a2c1ead7bc3e7afcac1e76a989dd5af9" translate="yes" xml:space="preserve">
          <source>This is an &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) operation as it requires copying every element in the buffer.</source>
          <target state="translated">이것은 인 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;N&lt;/em&gt; 은 상기 버퍼에있는 모든 요소를 필요로 복사) 동작.</target>
        </trans-unit>
        <trans-unit id="ebfdb05e0c25e262e85513236d16ce28096eaa2c" translate="yes" xml:space="preserve">
          <source>This is an &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) operation, as it requires copying every element in the buffer.</source>
          <target state="translated">이것은 인 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;N&lt;/em&gt; 은 상기 버퍼에있는 모든 요소를 필요로 복사) 동작.</target>
        </trans-unit>
        <trans-unit id="e7773930b7607b5b74b44eb47accc2cfca7d33e4" translate="yes" xml:space="preserve">
          <source>This is an &lt;em&gt;unsized&lt;/em&gt; type, meaning that it must always be used behind a pointer like &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;. For an owned version of this type, see &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;em&gt;크기&lt;/em&gt; 가 조정되지 &lt;em&gt;않은&lt;/em&gt; 유형이므로 항상 &lt;code&gt;&amp;amp;&lt;/code&gt; 또는 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; 와 같은 포인터 뒤에 사용해야합니다 . 이 유형의 소유 버전은 &lt;a href=&quot;struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae5b715f0a76526280a5abae050e91bd520680ba" translate="yes" xml:space="preserve">
          <source>This is an absolute path starting with &lt;code&gt;std&lt;/code&gt;, the name of the standard library crate.</source>
          <target state="translated">이것은 표준 라이브러리 상자의 이름 인 &lt;code&gt;std&lt;/code&gt; 로 시작하는 절대 경로 입니다.</target>
        </trans-unit>
        <trans-unit id="fb3851cbc0fb3af560d20b0226cbd7a0adc72483" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt;&lt;code&gt;fs::canonicalize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt; &lt;code&gt;fs::canonicalize&lt;/code&gt; &lt;/a&gt; 의 별명 입니다.</target>
        </trans-unit>
        <trans-unit id="ccff757092656f4cd5645f893d07b3a2270144b9" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;../fs/fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt; 의 별명 입니다.</target>
        </trans-unit>
        <trans-unit id="fe9cf4a133a88b8bc470c4394f4eb8cf3b306e68" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.read_dir&quot;&gt;&lt;code&gt;fs::read_dir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;../fs/fn.read_dir&quot;&gt; &lt;code&gt;fs::read_dir&lt;/code&gt; &lt;/a&gt; 의 별명 입니다.</target>
        </trans-unit>
        <trans-unit id="f461dafd60906d9babd38850b381951321bafa0a" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.read_link&quot;&gt;&lt;code&gt;fs::read_link&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;../fs/fn.read_link&quot;&gt; &lt;code&gt;fs::read_link&lt;/code&gt; &lt;/a&gt; 의 별명 입니다.</target>
        </trans-unit>
        <trans-unit id="8a772f821d093dc45f53501fe5deb3218dd74356" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.symlink_metadata&quot;&gt;&lt;code&gt;fs::symlink_metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;../fs/fn.symlink_metadata&quot;&gt; &lt;code&gt;fs::symlink_metadata&lt;/code&gt; &lt;/a&gt; 의 별명 입니다.</target>
        </trans-unit>
        <trans-unit id="d34ac7564172d2ff8117857aff9df3320c42fae5" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::clone(...)&lt;/code&gt;. A &lt;code&gt;Clone&lt;/code&gt; implementation or a method would interfere with the widespread use of &lt;code&gt;r.borrow().clone()&lt;/code&gt; to clone the contents of a &lt;code&gt;RefCell&lt;/code&gt;.</source>
          <target state="translated">이는 &lt;code&gt;Ref::clone(...)&lt;/code&gt; 으로 사용해야하는 관련 함수입니다 . &lt;code&gt;Clone&lt;/code&gt; 구현이나 방법의 광범위한 사용을 방해 할 &lt;code&gt;r.borrow().clone()&lt;/code&gt; a의 내용을 복제 할 &lt;code&gt;RefCell&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="0de597cdfc25d4b695eb376a8a0838157803d015" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::leak(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;Ref::leak(...)&lt;/code&gt; 로 사용해야하는 관련 함수입니다 . 메서드는 &lt;code&gt;RefCell&lt;/code&gt; 통해 사용되는 &lt;code&gt;Deref&lt;/code&gt; 의 내용에서 동일한 이름의 메서드를 방해 합니다.</target>
        </trans-unit>
        <trans-unit id="f83e3e547dadb3f845f93bfeaf6231ee030e91c8" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::map(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">이는 &lt;code&gt;Ref::map(...)&lt;/code&gt; 으로 사용해야하는 관련 함수입니다 . 방법은 내용에 같은 이름의 방법 방해 &lt;code&gt;RefCell&lt;/code&gt; 통해 사용 &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f18aedd0b02030c35b1012078adf973833d874e" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::map_split(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">이 기능은 다음과 같이 사용해야합니다. &lt;code&gt;Ref::map_split(...)&lt;/code&gt; . 방법은 내용에 같은 이름의 방법 방해 &lt;code&gt;RefCell&lt;/code&gt; 통해 사용 &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9124c09eb61044a9051beed91e77bd6ffcbf176" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;RefMut::leak(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;RefMut::leak(...)&lt;/code&gt; 로 사용되어야하는 관련 함수입니다 . 메서드는 &lt;code&gt;RefCell&lt;/code&gt; 통해 사용되는 &lt;code&gt;Deref&lt;/code&gt; 의 내용에서 동일한 이름의 메서드를 방해 합니다.</target>
        </trans-unit>
        <trans-unit id="14ab5139ea01a60d2224bebc358fd7f5a09aee7b" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;RefMut::map(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">이 기능은 다음과 같이 사용해야합니다. &lt;code&gt;RefMut::map(...)&lt;/code&gt; . 방법은 내용에 같은 이름의 방법 방해 &lt;code&gt;RefCell&lt;/code&gt; 통해 사용 &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="202f23e551bc61ba34f51a486b60ddfce30150ab" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;RefMut::map_split(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">이 기능은 다음과 같이 사용해야합니다. &lt;code&gt;RefMut::map_split(...)&lt;/code&gt; . 방법은 내용에 같은 이름의 방법 방해 &lt;code&gt;RefCell&lt;/code&gt; 통해 사용 &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb3bd037be08bb82591900e7ddf468637a2b8c80" translate="yes" xml:space="preserve">
          <source>This is appropriate for initializing uninitialized memory, or overwriting memory that has previously been &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; from.</source>
          <target state="translated">초기화되지 않은 메모리를 초기화하거나 이전에 &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 메모리를 덮어 쓰는 데 적합합니다 .</target>
        </trans-unit>
        <trans-unit id="856709efbf0ee049257184bc9760c0b3d18a43eb" translate="yes" xml:space="preserve">
          <source>This is appropriate for initializing uninitialized memory, or overwriting memory that has previously been read with &lt;a href=&quot;fn.read_unaligned&quot;&gt;&lt;code&gt;read_unaligned&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">초기화되지 않은 메모리를 초기화하거나 이전에 읽은 메모리를 덮어 쓰는 데 적합합니다. &lt;a href=&quot;fn.read_unaligned&quot;&gt; &lt;code&gt;read_unaligned&lt;/code&gt; 로 적합&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9049d14f9f0cb6f47694e4f8dd6256baa32e595c" translate="yes" xml:space="preserve">
          <source>This is based on &lt;code&gt;malloc&lt;/code&gt; on Unix platforms and &lt;code&gt;HeapAlloc&lt;/code&gt; on Windows, plus related functions.</source>
          <target state="translated">이것은 기반으로합니다 &lt;code&gt;malloc&lt;/code&gt; Unix 플랫폼의 malloc 과 Windows의 &lt;code&gt;HeapAlloc&lt;/code&gt; 및 관련 기능을 합니다.</target>
        </trans-unit>
        <trans-unit id="d9e17b1971fcc8ebac923ca9bdcdbe86fd7ccc27" translate="yes" xml:space="preserve">
          <source>This is because &lt;code&gt;AddAssign&lt;/code&gt; is not automatically implemented, so you need to manually implement it for your type.</source>
          <target state="translated">이는 &lt;code&gt;AddAssign&lt;/code&gt; 이 자동으로 구현되지 않기 때문에 사용자 유형에 맞게 수동으로 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="5c0cfc8e697e9e04f2ac8988522860bd36ed371a" translate="yes" xml:space="preserve">
          <source>This is because cell types do operations that are not thread-safe. Due to this, they don't implement Sync and thus can't be placed in statics.</source>
          <target state="translated">셀 유형이 스레드로부터 안전하지 않은 작업을 수행하기 때문입니다. 이로 인해 동기화를 구현하지 않으므로 스태틱에 배치 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="43247ccf0e7189f6826d62c195b63176c827f652" translate="yes" xml:space="preserve">
          <source>This is because of a type mismatch between the associated type of some trait (e.g., &lt;code&gt;T::Bar&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;trait Quux { type Bar; }&lt;/code&gt;) and another type &lt;code&gt;U&lt;/code&gt; that is required to be equal to &lt;code&gt;T::Bar&lt;/code&gt;, but is not. Examples follow.</source>
          <target state="translated">이는 일부 특성의 연관된 유형 (예 : &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;trait Quux { type Bar; }&lt;/code&gt; 구현 하는 T &lt;code&gt;T::Bar&lt;/code&gt; )과 &lt;code&gt;T::Bar&lt;/code&gt; 동일해야하는 다른 유형 &lt;code&gt;U&lt;/code&gt; 간의 유형이 일치하지 않기 때문입니다 . 와 아니다. 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e543293d9c4cb900df2afb34a1c801950192149" translate="yes" xml:space="preserve">
          <source>This is because there could exist &lt;code&gt;V&lt;/code&gt; types with multiple &lt;code&gt;Borrow&amp;lt;[_]&amp;gt;&lt;/code&gt; impls, such that multiple &lt;code&gt;T&lt;/code&gt; types would apply:</source>
          <target state="translated">이는 여러 개의 &lt;code&gt;T&lt;/code&gt; 유형이 적용될 수 있도록 여러 개의 &lt;code&gt;Borrow&amp;lt;[_]&amp;gt;&lt;/code&gt; impls 가있는 &lt;code&gt;V&lt;/code&gt; 유형 이 존재할 수 있기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="a641717e833808f9f0bc4f5f362a54b6a1faff5b" translate="yes" xml:space="preserve">
          <source>This is borrow-generalized version of &lt;code&gt;Clone::clone_from&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;Clone::clone_from&lt;/code&gt; 의 차용 일반화 버전입니다. .</target>
        </trans-unit>
        <trans-unit id="834216017331c86ca1e125eb990783c9079a99f6" translate="yes" xml:space="preserve">
          <source>This is called the &amp;ldquo;train model&amp;rdquo; because every six weeks, a release &amp;ldquo;leaves the station&amp;rdquo;, but still has to take a journey through the beta channel before it arrives as a stable release.</source>
          <target state="translated">6 주마다 릴리스가 &quot;스테이션을 떠나지 만&quot;베타 채널이 안정적인 릴리스로 도착하기 전에 여행해야하기 때문에 이것을 &quot;기차 모델&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="d83e7e82097d376958eb95d5e51d98e6719f2542" translate="yes" xml:space="preserve">
          <source>This is catastrophic, it means we can first pin the content of the &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; (using &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt;) and then move that content using the mutable reference we got later.</source>
          <target state="translated">이것은 재앙 적입니다. 먼저 &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 의 내용을 고정한 다음 ( &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt; ) 나중에 얻은 변경 가능한 참조를 사용하여 해당 내용을 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9e339d64ba30c9973394f6282049233c7be4f71" translate="yes" xml:space="preserve">
          <source>This is catastrophic, it means we can first pin the content of the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; (using &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt;) and then move that content using the mutable reference we got later.</source>
          <target state="translated">이것은 치명적이므로 먼저 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 의 내용을 고정하고 ( &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt; ) 나중에 얻은 가변 참조를 사용하여 해당 내용을 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ed19556018375489742916bfb6ea73b08918fbf" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value generator into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain()&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="translated">이것은 일반적으로 단일 값 생성기를 다른 종류의 반복 &lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain()&lt;/code&gt; &lt;/a&gt; 에 적용하는 데 사용됩니다 . 거의 모든 것을 다루는 반복자가있을 수 있지만 특별한 경우가 더 필요합니다. 반복자에서 작동하는 함수가있을 수 있지만 하나의 값만 처리하면됩니다.</target>
        </trans-unit>
        <trans-unit id="67913f9219472099fcca84773f5f227006ffbcce" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value generator into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="translated">이것은 일반적으로 단일 값 생성기를 다른 종류의 반복 &lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt; 에 적용하는 데 사용됩니다 . 어쩌면 거의 모든 것을 다루는 반복자가 있지만 특별한 경우가 필요합니다. 반복자에서 작동하는 함수가 있지만 하나의 값만 처리하면됩니다.</target>
        </trans-unit>
        <trans-unit id="507d399d0caa748ec0f687d63827f62d38ea93b1" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain()&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="translated">일반적으로 단일 값을 다른 종류의 반복 &lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain()&lt;/code&gt; &lt;/a&gt; 에 적용하는 데 사용됩니다 . 거의 모든 것을 다루는 반복자가있을 수 있지만 특별한 경우가 더 필요합니다. 반복자에서 작동하는 함수가있을 수 있지만 하나의 값만 처리하면됩니다.</target>
        </trans-unit>
        <trans-unit id="764e0240ad7ec9a9585ed8305ceb8e8099f2723d" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="translated">이것은 일반적으로 단일 값을 &lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt; 에 적용하는 데 사용됩니다 다른 종류의 반복 에 . 어쩌면 거의 모든 것을 다루는 반복자가 있지만 특별한 경우가 필요합니다. 반복자에서 작동하는 함수가 있지만 하나의 값만 처리하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f239b530d28c30ec1070f1658b16620a287e3251" translate="yes" xml:space="preserve">
          <source>This is correct (explicit):</source>
          <target state="translated">이것은 정확합니다 (명시 적).</target>
        </trans-unit>
        <trans-unit id="7d6342cfa6f9200a801992dcf925b5cee5be4a5b" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;f32, u32&amp;gt;(self)&lt;/code&gt; on all platforms.</source>
          <target state="translated">이것은 현재 모든 플랫폼 에서 &lt;code&gt;transmute::&amp;lt;f32, u32&amp;gt;(self)&lt;/code&gt; 와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a48f92d085d1c5423be432a065e6504acd5a4a36" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;f64, u64&amp;gt;(self)&lt;/code&gt; on all platforms.</source>
          <target state="translated">이것은 현재 모든 플랫폼 에서 &lt;code&gt;transmute::&amp;lt;f64, u64&amp;gt;(self)&lt;/code&gt; 와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="918c5990ef12f35794f26c0b83e42a5d2ef0c694" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;u32, f32&amp;gt;(v)&lt;/code&gt; on all platforms. It turns out this is incredibly portable, for two reasons:</source>
          <target state="translated">이것은 현재 모든 플랫폼 에서 &lt;code&gt;transmute::&amp;lt;u32, f32&amp;gt;(v)&lt;/code&gt; 와 동일합니다. 이것은 두 가지 이유로 믿을 수 없을만큼 이식성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="00309d71e504692e129d008c7a1eff96961c44fc" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;u64, f64&amp;gt;(v)&lt;/code&gt; on all platforms. It turns out this is incredibly portable, for two reasons:</source>
          <target state="translated">이것은 현재 모든 플랫폼 에서 &lt;code&gt;transmute::&amp;lt;u64, f64&amp;gt;(v)&lt;/code&gt; 와 동일합니다. 이것은 두 가지 이유로 믿을 수 없을만큼 이식성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="de7179edea4813efbd79fdfefd23f0fcc07d0700" translate="yes" xml:space="preserve">
          <source>This is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5737&quot;&gt;IETF RFC 5737&lt;/a&gt;:</source>
          <target state="translated">이것은 &lt;a href=&quot;https://tools.ietf.org/html/rfc5737&quot;&gt;IETF RFC 5737에&lt;/a&gt; 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59a6ad6e6ae513088e0c1bb8ed9888b474a9dbba" translate="yes" xml:space="preserve">
          <source>This is designed to be used in conjunction with &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; to, for example, carry a panic across a layer of C code.</source>
          <target state="translated">예를 들어 C 코드 계층에 패닉을 전달하기 위해 &lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; &lt;/a&gt; 와 함께 사용하도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5fdeff8202418046160b5ede029f4ae17e4cb706" translate="yes" xml:space="preserve">
          <source>This is different than the &lt;code&gt;C&lt;/code&gt; representation because a struct with the &lt;code&gt;C&lt;/code&gt; representation will always have the ABI of a &lt;code&gt;C&lt;/code&gt;&lt;code&gt;struct&lt;/code&gt; while, for example, a struct with the &lt;code&gt;transparent&lt;/code&gt; representation with a primitive field will have the ABI of the primitive field.</source>
          <target state="translated">이것은 다르다 &lt;code&gt;C&lt;/code&gt; 의 가진 구조체 때문에 표현 &lt;code&gt;C&lt;/code&gt; 의 표현은 항상의 ABI있을 것이다 &lt;code&gt;C&lt;/code&gt; 의 &lt;code&gt;struct&lt;/code&gt; , 예를 들면, 함께 구조체 중에 &lt;code&gt;transparent&lt;/code&gt; 원시적 필드 표현 프리미티브 필드 ABI있을 것이다.</target>
        </trans-unit>
        <trans-unit id="f40a48629593c80076df828df6524a31bbb5832c" translate="yes" xml:space="preserve">
          <source>This is done as if by the Euclidean division algorithm -- given &lt;code&gt;r = self.rem_euclid(rhs)&lt;/code&gt;, &lt;code&gt;self = rhs * self.div_euclid(rhs) + r&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= r &amp;lt; abs(rhs)&lt;/code&gt;.</source>
          <target state="translated">이는 &lt;code&gt;r = self.rem_euclid(rhs)&lt;/code&gt; , &lt;code&gt;self = rhs * self.div_euclid(rhs) + r&lt;/code&gt; 및 &lt;code&gt;0 &amp;lt;= r &amp;lt; abs(rhs)&lt;/code&gt; 주어진 유클리드 분할 알고리즘에 의해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="261341fb7dbde0853cc1e229f30dada63a712ac0" translate="yes" xml:space="preserve">
          <source>This is enforced by the Rust compiler. However, there are situations where this rule is not flexible enough. Sometimes it is required to have multiple references to an object and yet mutate it.</source>
          <target state="translated">이것은 Rust 컴파일러에 의해 시행됩니다. 그러나이 규칙이 충분히 유연하지 않은 상황이 있습니다. 때로는 객체에 대한 여러 참조가 있어야하지만 여전히 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a48a3285621637ef35ee331d4de4979ad866379" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea3c08c47d3f2c239e1b0612d35fd093489ce76f" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;to_ascii_lowercase(a) == to_ascii_lowercase(b)&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;to_ascii_lowercase(a) == to_ascii_lowercase(b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a97a7d1bcb8cd7cc77582edff43cedf5b5f9e7ec" translate="yes" xml:space="preserve">
          <source>This is equivalent to adding the result of &lt;code&gt;padding_needed_for&lt;/code&gt; to the layout's current size.</source>
          <target state="translated">이는 &lt;code&gt;padding_needed_for&lt;/code&gt; 의 결과를 레이아웃의 현재 크기 에 추가하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="cd40c4706f12ddab3deeab19ddffb1056c56c24a" translate="yes" xml:space="preserve">
          <source>This is equivalent to casting &lt;code&gt;self&lt;/code&gt; to &lt;code&gt;*const T&lt;/code&gt;, but more type-safe.</source>
          <target state="translated">이것은 &lt;code&gt;self&lt;/code&gt; 를 &lt;code&gt;*const T&lt;/code&gt; 로 캐스팅하는 것과 동일 하지만 더 형식에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="b1cc6c65ebdd0a382483c4dc8c7f13d29cc10dc3" translate="yes" xml:space="preserve">
          <source>This is equivalent to casting &lt;code&gt;self&lt;/code&gt; to &lt;code&gt;*mut T&lt;/code&gt;, but more type-safe.</source>
          <target state="translated">이것은 &lt;code&gt;self&lt;/code&gt; 를 &lt;code&gt;*mut T&lt;/code&gt; 로 캐스팅하는 것과 동일 하지만 더 형식에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="f6cc1d085b275d07a515f10b6c1293ccce68e246" translate="yes" xml:space="preserve">
          <source>This is equivalent to sending a SIGKILL on Unix platforms.</source>
          <target state="translated">이것은 Unix 플랫폼에서 SIGKILL을 보내는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f985a290d8b35439e1509532b1f307ab14186afb" translate="yes" xml:space="preserve">
          <source>This is equivalent to the &lt;code&gt;Deref&lt;/code&gt; impl, but is explicit.</source>
          <target state="translated">이것은 &lt;code&gt;Deref&lt;/code&gt; impl 과 동일 하지만 명시 적입니다.</target>
        </trans-unit>
        <trans-unit id="dbb80b753a6a285f62ca3be46d0ca7ebb71f7211" translate="yes" xml:space="preserve">
          <source>This is equivalent to using a &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop on the iterator, although &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; are not possible from a closure. It's generally more idiomatic to use a &lt;code&gt;for&lt;/code&gt; loop, but &lt;code&gt;for_each&lt;/code&gt; may be more legible when processing items at the end of longer iterator chains. In some cases &lt;code&gt;for_each&lt;/code&gt; may also be faster than a loop, because it will use internal iteration on adaptors like &lt;code&gt;Chain&lt;/code&gt;.</source>
          <target state="translated">이것은을 사용하는 것과 같습니다 &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; 있지만, 반복자에 루프 &lt;code&gt;break&lt;/code&gt; 과 &lt;code&gt;continue&lt;/code&gt; 폐쇄에서 가능하지 않습니다. 일반적으로 &lt;code&gt;for&lt;/code&gt; 루프 를 사용하는 것이 관용적 이지만 &lt;code&gt;for_each&lt;/code&gt; 는 더 긴 반복자 체인 끝에서 항목을 처리 할 때 더 읽기 쉽습니다 . 경우에 따라 &lt;code&gt;for_each&lt;/code&gt; 는 &lt;code&gt;Chain&lt;/code&gt; 과 같은 어댑터에서 내부 반복을 사용하기 때문에 루프보다 빠를 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85aa708c3c4c286a53847d7118e6789eccd018b1" translate="yes" xml:space="preserve">
          <source>This is essentially the reversed version of &lt;a href=&quot;trait.iterator#method.nth&quot;&gt;&lt;code&gt;Iterator::nth()&lt;/code&gt;&lt;/a&gt;. Although like most indexing operations, the count starts from zero, so &lt;code&gt;nth_back(0)&lt;/code&gt; returns the first value from the end, &lt;code&gt;nth_back(1)&lt;/code&gt; the second, and so on.</source>
          <target state="translated">이것은 본질적으로 &lt;a href=&quot;trait.iterator#method.nth&quot;&gt; &lt;code&gt;Iterator::nth()&lt;/code&gt; &lt;/a&gt; 의 역 버전입니다 . 대부분의 인덱싱 작업과 마찬가지로 개수는 0부터 시작하므로 &lt;code&gt;nth_back(0)&lt;/code&gt; 은 끝에서 첫 번째 값을 반환하고 &lt;code&gt;nth_back(1)&lt;/code&gt; 은 두 번째 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0d5fc7a87669eb5a575d2a14569feb14339d998c" translate="yes" xml:space="preserve">
          <source>This is essentially the reversed version of &lt;a href=&quot;trait.iterator#method.nth&quot;&gt;&lt;code&gt;nth&lt;/code&gt;&lt;/a&gt;. Although like most indexing operations, the count starts from zero, so &lt;code&gt;nth_back(0)&lt;/code&gt; returns the first value fro the end, &lt;code&gt;nth_back(1)&lt;/code&gt; the second, and so on.</source>
          <target state="translated">이것은 본질적으로 &lt;a href=&quot;trait.iterator#method.nth&quot;&gt; &lt;code&gt;nth&lt;/code&gt; &lt;/a&gt; 의 반대 버전입니다 . 대부분의 인덱싱 작업과 마찬가지로 카운트는 0부터 시작하므로 &lt;code&gt;nth_back(0)&lt;/code&gt; 은 끝의 첫 번째 값, &lt;code&gt;nth_back(1)&lt;/code&gt; 의 두 번째 값 등을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="da357ed847b3be924604524d54de90650dc840c5" translate="yes" xml:space="preserve">
          <source>This is exactly the kind of guarantee that the intrusive linked list from the previous section needs to function correctly.</source>
          <target state="translated">이것은 이전 섹션의 침입 링크 목록이 올바르게 작동해야한다는 보장입니다.</target>
        </trans-unit>
        <trans-unit id="bb45c58beba541079b29f983c2bd8c56db26b71e" translate="yes" xml:space="preserve">
          <source>This is exploited by the compiler for various optimizations, such as eliding run-time checks and optimizing &lt;code&gt;enum&lt;/code&gt; layout.</source>
          <target state="translated">컴파일러는 런타임 검사 생략 및 &lt;code&gt;enum&lt;/code&gt; 레이아웃 최적화와 같은 다양한 최적화를 위해 컴파일러를 이용 합니다.</target>
        </trans-unit>
        <trans-unit id="2800cba431c3f0317ff7290328c22feda7e8a245" translate="yes" xml:space="preserve">
          <source>This is fixed by declaring the impl block like this:</source>
          <target state="translated">이것은 다음과 같이 impl 블록을 선언하여 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="7800b5b60ece10a2bb3977b34790a457f9ba1d9b" translate="yes" xml:space="preserve">
          <source>This is generally created by methods like &lt;a href=&quot;struct.mutex#method.lock&quot;&gt;&lt;code&gt;Mutex::lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.rwlock#method.read&quot;&gt;&lt;code&gt;RwLock::read&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 일반적으로 &lt;a href=&quot;struct.mutex#method.lock&quot;&gt; &lt;code&gt;Mutex::lock&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.rwlock#method.read&quot;&gt; &lt;code&gt;RwLock::read&lt;/code&gt; &lt;/a&gt; 와 같은 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="d04e3acde7f8ef92dfb6b7b52b3e3c3811cad1e0" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;#method.get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 일반적으로 권장되지 않으므로주의해서 사용하십시오! 안전한 대안을 &lt;a href=&quot;#method.get&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4bd5c92d6bc3bc69b3d544b464184377050cce05" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 일반적으로 권장되지 않으므로주의해서 사용하십시오! 안전한 대안은 &lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1be3a48c43f2cbe9f66bb8b317aa83c1345f1b36" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 일반적으로 권장되지 않으므로주의해서 사용하십시오! 안전한 대안은 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="60f2e569769a80d9853e1327c13dd3289346f0be" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 일반적으로 권장되지 않으므로주의해서 사용하십시오! 안전한 대안은 &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5835397a3648f1790072b1697b1686de073dd8a5" translate="yes" xml:space="preserve">
          <source>This is highly unsafe, due to the number of invariants that aren't checked:</source>
          <target state="translated">이것은 확인되지 않은 불변의 수로 인해 매우 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75907ab0f8297b43f4704528d57293015e32b770" translate="yes" xml:space="preserve">
          <source>This is implemented as an intrinsic to avoid converting to and from an integer, since the conversion inhibits certain optimizations.</source>
          <target state="translated">이것은 변환이 특정 최적화를 방해하기 때문에 정수로 변환하거나 정수에서 변환하는 것을 피하기 위해 본질적으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="11f5a22e0c8092b2e830a298d3f000dd528e1ac9" translate="yes" xml:space="preserve">
          <source>This is implemented as an intrinsic to avoid converting to and from an integer, since the conversion would throw away aliasing information.</source>
          <target state="translated">이것은 변환이 앨리어싱 정보를 버릴 것이기 때문에 정수로 변환하거나 정수에서 변환하는 것을 피하기 위해 본질적으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="0d148f9608c961194f7d8d82b9462e528bb48245" translate="yes" xml:space="preserve">
          <source>This is in contrast to the default behaviour of &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; which unwinds the current thread's stack and calls all destructors. When &lt;code&gt;panic=&quot;abort&quot;&lt;/code&gt; is set, either as an argument to &lt;code&gt;rustc&lt;/code&gt; or in a crate's Cargo.toml, &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;abort&lt;/code&gt; are similar. However, &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; will still call the &lt;a href=&quot;../panic/fn.set_hook&quot;&gt;panic hook&lt;/a&gt; while &lt;code&gt;abort&lt;/code&gt; will not.</source>
          <target state="translated">이것은 &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt; 의 기본 행동과 대조적입니다 ! 현재 스레드의 스택을 풀고 모든 소멸자를 호출합니다. 때 &lt;code&gt;panic=&quot;abort&quot;&lt;/code&gt; 설정되어, 하나의 인수로 &lt;code&gt;rustc&lt;/code&gt; 또는 상자의 Cargo.toml에, &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;및 &lt;code&gt;abort&lt;/code&gt; 유사하다. 그러나, &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt; &lt;code&gt;abort&lt;/code&gt; 되지 않는 동안 여전히 &lt;a href=&quot;../panic/fn.set_hook&quot;&gt;공황 고리&lt;/a&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="4ae8371c0715e2fc1f945296e51fa6a1f4eac55c" translate="yes" xml:space="preserve">
          <source>This is intended for diagnostic use. The exact contents and format of the string are not specified, other than being a best-effort description of the type. For example, &lt;code&gt;type_name_of_val::&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt;(None)&lt;/code&gt; could return &lt;code&gt;&quot;Option&amp;lt;String&amp;gt;&quot;&lt;/code&gt; or &lt;code&gt;&quot;std::option::Option&amp;lt;std::string::String&amp;gt;&quot;&lt;/code&gt;, but not &lt;code&gt;&quot;foobar&quot;&lt;/code&gt;. In addition, the output may change between versions of the compiler.</source>
          <target state="translated">이것은 진단용입니다. 문자열의 정확한 내용과 형식은 형식에 대한 최선의 설명을 제외하고는 지정되지 않습니다. 예를 들어 &lt;code&gt;type_name_of_val::&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt;(None)&lt;/code&gt; 은 &lt;code&gt;&quot;Option&amp;lt;String&amp;gt;&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;std::option::Option&amp;lt;std::string::String&amp;gt;&quot;&lt;/code&gt; 반환 할 수 있지만 &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; 는 반환 하지 않을 수 있습니다. 또한 출력은 컴파일러 버전간에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8ec787ed30362b911645f3b84c9e12d95cf9472" translate="yes" xml:space="preserve">
          <source>This is intended for diagnostic use. The exact contents and format of the string returned are not specified, other than being a best-effort description of the type. For example, amongst the strings that &lt;code&gt;type_name::&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt;()&lt;/code&gt; might return are &lt;code&gt;&quot;Option&amp;lt;String&amp;gt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;std::option::Option&amp;lt;std::string::String&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">이것은 진단용입니다. 반환 된 문자열의 정확한 내용과 형식은 형식에 대한 최선의 설명 외에는 지정되지 않습니다. 예를 들어 &lt;code&gt;type_name::&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt;()&lt;/code&gt; 이 반환 할 수있는 &lt;code&gt;&quot;Option&amp;lt;String&amp;gt;&quot;&lt;/code&gt; 중에는 &quot;Option &amp;lt;String&amp;gt;&quot; 및 &lt;code&gt;&quot;std::option::Option&amp;lt;std::string::String&amp;gt;&quot;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="abc319fa8d54bb7f30ec3fbd3c75a33f269dda0d" translate="yes" xml:space="preserve">
          <source>This is intended for use cases that must synchronize content, but don't need the metadata on disk. The goal of this method is to reduce disk operations.</source>
          <target state="translated">콘텐츠를 동기화해야하지만 디스크의 메타 데이터가 필요없는 사용 사례를위한 것입니다. 이 방법의 목표는 디스크 작업을 줄이는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b4baa659f5df3a480bf1bbe9b4f50e4e5030b61c" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;OsStrExt::encode_wide&lt;/code&gt;&lt;/a&gt; on the resulting string will always return the original code units.</source>
          <target state="translated">이것은 무손실입니다. 결과 문자열에서 &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt; &lt;code&gt;OsStrExt::encode_wide&lt;/code&gt; &lt;/a&gt; 를 호출 하면 항상 원래 코드 단위가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8a817bf3dc422e9202ff238105af54d744a0e12d" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; on the resulting string will always return the original code units.</source>
          <target state="translated">이는 손실이 없습니다. 결과 문자열에서 &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt; &lt;code&gt;encode_wide&lt;/code&gt; &lt;/a&gt; 를 호출 하면 항상 원래 코드 단위가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="628dc171fde34c2da2657493d9e0d1f50a03e413" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;OsString::from_wide&lt;/code&gt;&lt;/a&gt; and then &lt;code&gt;encode_wide&lt;/code&gt; on the result will yield the original code units. Note that the encoding does not add a final null terminator.</source>
          <target state="translated">전화 : 이것은 손실이 &lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt; &lt;code&gt;OsString::from_wide&lt;/code&gt; &lt;/a&gt; 다음 &lt;code&gt;encode_wide&lt;/code&gt; 결과에 원래의 코드 단위를 얻을 것입니다. 인코딩은 최종 널 종료자를 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77e982184c9ea4360d1954dd63bc884090bdd324" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;OsStringExt::from_wide&lt;/code&gt;&lt;/a&gt; and then &lt;code&gt;encode_wide&lt;/code&gt; on the result will yield the original code units. Note that the encoding does not add a final null terminator.</source>
          <target state="translated">이것은 무손실입니다. &lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt; &lt;code&gt;OsStringExt::from_wide&lt;/code&gt; &lt;/a&gt; 호출 한 다음 결과에 대해 &lt;code&gt;encode_wide&lt;/code&gt; 를 호출 하면 원래 코드 단위가 생성됩니다. 인코딩은 최종 null 종결자를 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0151e5762979bf36757d9fa68f187e7676c048da" translate="yes" xml:space="preserve">
          <source>This is more useful when combined with higher-level abstractions, like collecting to a &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; where you only care about errors:</source>
          <target state="translated">이것은 오류에만 관심 이있는 &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; 로 수집과 같은 상위 레벨 추상화와 결합 할 때 더 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="10329d9d786a635bdda96b8986fb374a569f8990" translate="yes" xml:space="preserve">
          <source>This is normally only useful in macro generated code.</source>
          <target state="translated">이것은 일반적으로 매크로 생성 코드에서만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e2fe1510c25bad6c81eb0b6402e2bd1a4066b7f9" translate="yes" xml:space="preserve">
          <source>This is not currently supported: &lt;code&gt;v&lt;/code&gt; should be defined as &lt;code&gt;Vec&amp;lt;&amp;amp;str&amp;gt;&lt;/code&gt;. Parentheses are currently only used with generic types when defining parameters for &lt;code&gt;Fn&lt;/code&gt;-family traits.</source>
          <target state="translated">이것은 현재 지원되지 않습니다. &lt;code&gt;v&lt;/code&gt; 는 &lt;code&gt;Vec&amp;lt;&amp;amp;str&amp;gt;&lt;/code&gt; 으로 정의되어야합니다 . 괄호는 현재 &lt;code&gt;Fn&lt;/code&gt; 계열 특성에 대한 매개 변수를 정의 할 때 일반 유형에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="711ce4ce5401a3c09d45281217695490f1c55a87" translate="yes" xml:space="preserve">
          <source>This is often the correct thing to use when building data structures using raw pointers, but is ultimately more dangerous to use because of its additional properties. If you're not sure if you should use &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt;, just use &lt;code&gt;*mut T&lt;/code&gt;!</source>
          <target state="translated">원시 포인터를 사용하여 데이터 구조를 빌드 할 때 사용하는 것이 올바른 경우가 많지만 추가 특성으로 인해 사용하는 것이 더 위험합니다. &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; 사용 해야하는지 확실하지 않으면 &lt;code&gt;*mut T&lt;/code&gt; 만 사용하십시오 !</target>
        </trans-unit>
        <trans-unit id="fa820eea81b725c2fa4febe2a3901035a1fc9e49" translate="yes" xml:space="preserve">
          <source>This is one of the reasons Rust projects that provide a binary have a straightforward &lt;em&gt;src/main.rs&lt;/em&gt; file that calls logic that lives in the &lt;em&gt;src/lib.rs&lt;/em&gt; file. Using that structure, integration tests &lt;em&gt;can&lt;/em&gt; test the library crate with &lt;code&gt;use&lt;/code&gt; to make the important functionality available. If the important functionality works, the small amount of code in the &lt;em&gt;src/main.rs&lt;/em&gt; file will work as well, and that small amount of code doesn&amp;rsquo;t need to be tested.</source>
          <target state="translated">이 이유 녹 바이너리 가지고 간단 제공하는 프로젝트 중 하나입니다 &lt;em&gt;SRC / main.rs&lt;/em&gt; 파일이 호출 논리를 그의 삶 &lt;em&gt;SRC / lib.rs의&lt;/em&gt; 파일. 그 구조를 사용하여 통합 테스트는 &lt;em&gt;수&lt;/em&gt; 와 라이브러리 상자를 테스트 &lt;code&gt;use&lt;/code&gt; 중요한 기능을 사용할 수 있도록. 중요한 기능이 작동하면 &lt;em&gt;src / main.rs&lt;/em&gt; 파일 의 소량의 코드 도 잘 작동하며 소량의 코드는 테스트 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="73e2aa9ae5cc887b643d8522a473733b99e09722" translate="yes" xml:space="preserve">
          <source>This is only available on unix platforms and must be imported in order to call the method. Windows platforms have a corresponding &lt;code&gt;AsRawHandle&lt;/code&gt; and &lt;code&gt;AsRawSocket&lt;/code&gt; set of traits.</source>
          <target state="translated">유닉스 플랫폼에서만 사용할 수 있으며 메소드를 호출하려면 가져와야합니다. Windows 플랫폼에는 해당 &lt;code&gt;AsRawHandle&lt;/code&gt; 및 &lt;code&gt;AsRawSocket&lt;/code&gt; 특성 세트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b95758d57810f70a3e0dda910c113e0c41898398" translate="yes" xml:space="preserve">
          <source>This is only possible if the iterator has an end, so &lt;code&gt;rev()&lt;/code&gt; only works on &lt;a href=&quot;trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">이것은 iterator에 끝이있는 경우에만 가능하므로 &lt;code&gt;rev()&lt;/code&gt; 는 &lt;a href=&quot;trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt; 에서만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="3a074412ade07f77d614925409e4080a4208783e" translate="yes" xml:space="preserve">
          <source>This is optimal if:</source>
          <target state="translated">다음과 같은 경우에 최적입니다.</target>
        </trans-unit>
        <trans-unit id="37e51cab1c9ec8f6780dbae6b990b1f230875324" translate="yes" xml:space="preserve">
          <source>This is primarily due to ABI incompatibilities between the two attributes. See &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md&quot;&gt;RFC 2091&lt;/a&gt; for details on this and other limitations.</source>
          <target state="translated">이는 주로 두 속성 간의 ABI 비 호환성 때문입니다. 이에 대한 자세한 내용과 기타 제한 사항 은 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md&quot;&gt;RFC 2091&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d34b82a0a85b619783fe065420d506ce185b6196" translate="yes" xml:space="preserve">
          <source>This is purely an optimization hint, and may be implemented conservatively: it may return &lt;code&gt;true&lt;/code&gt; for types that don't actually need to be dropped. As such always returning &lt;code&gt;true&lt;/code&gt; would be a valid implementation of this function. However if this function actually returns &lt;code&gt;false&lt;/code&gt;, then you can be certain dropping &lt;code&gt;T&lt;/code&gt; has no side effect.</source>
          <target state="translated">이것은 순전히 최적화 힌트이며 보수적으로 구현 될 수 있습니다 . 실제로 삭제하지 않아도되는 유형에 대해서는 &lt;code&gt;true&lt;/code&gt; 를 반환 할 수 있습니다. 따라서 항상 &lt;code&gt;true&lt;/code&gt; 를 반환 하면이 함수의 유효한 구현이됩니다. 그러나이 함수가 실제로 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 &lt;code&gt;T&lt;/code&gt; 를 떨어 뜨리면 부작용이 없을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e7810a8956ac37cd206f449b307f75cea11f52b" translate="yes" xml:space="preserve">
          <source>This is returned in a Result by either the &lt;a href=&quot;struct.command#method.output&quot;&gt;&lt;code&gt;output&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt;, or the &lt;a href=&quot;struct.child#method.wait_with_output&quot;&gt;&lt;code&gt;wait_with_output&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt; process.</source>
          <target state="translated">이것은 &lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.command#method.output&quot;&gt; &lt;code&gt;output&lt;/code&gt; &lt;/a&gt; 메소드 또는 &lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt; 프로세스 의 &lt;a href=&quot;struct.child#method.wait_with_output&quot;&gt; &lt;code&gt;wait_with_output&lt;/code&gt; &lt;/a&gt; 메소드에 의해 결과로 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="b6ad57d3243660eeae5c83dc6d6e37580997866e" translate="yes" xml:space="preserve">
          <source>This is safe because it is not possible to move out of a shared reference. It may seem like there is an issue here with interior mutability: in fact, it &lt;em&gt;is&lt;/em&gt; possible to move a &lt;code&gt;T&lt;/code&gt; out of a &lt;code&gt;&amp;amp;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;. However, this is not a problem as long as there does not also exist a &lt;code&gt;Pin&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; pointing to the same data, and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; does not let you create a pinned reference to its contents. See the discussion on &lt;a href=&quot;index#projections-and-structural-pinning&quot;&gt;&quot;pinning projections&quot;&lt;/a&gt; for further details.</source>
          <target state="translated">공유 참조에서 벗어날 수 없기 때문에 안전합니다. 문제는 내부 가변성 여기가 것처럼 보일 수 있습니다 : 사실, &lt;em&gt;이다&lt;/em&gt; 이동 할 수 &lt;code&gt;T&lt;/code&gt; 를 에서 &lt;code&gt;&amp;amp;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; . 그러나 동일한 데이터를 가리키는 &lt;code&gt;Pin&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; 없고 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용하면 해당 내용에 대한 고정 된 참조를 만들 수없는 한 문제가되지 않습니다. 자세한 내용은 &lt;a href=&quot;index#projections-and-structural-pinning&quot;&gt;&quot;투영 고정&quot;&lt;/a&gt; 에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="559d85299736482aa3edc92867921c11931dac34" translate="yes" xml:space="preserve">
          <source>This is safe because passing &lt;code&gt;self&lt;/code&gt; by value guarantees that no other threads are concurrently accessing the atomic data.</source>
          <target state="translated">값으로 &lt;code&gt;self&lt;/code&gt; 를 전달 하면 다른 스레드가 원자 데이터에 동시에 액세스하지 못 하므로 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="fdcd86e75de03ac238cab2145da08762d1c1fa0e" translate="yes" xml:space="preserve">
          <source>This is safe because the mutable reference guarantees that no other threads are concurrently accessing the atomic data.</source>
          <target state="translated">변경 가능한 참조는 다른 스레드가 원자 데이터에 동시에 액세스하지 않도록하기 때문에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="a603b8208d8f49fcc985893385a8e118d832cdea" translate="yes" xml:space="preserve">
          <source>This is safe, because &lt;code&gt;T&lt;/code&gt; is borrowed for the &lt;code&gt;'static&lt;/code&gt; lifetime, which never ends.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 는 절대 끝나지 않는 &lt;code&gt;'static&lt;/code&gt; 수명 ' 동안 빌리기 때문에 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="62f1c9ceb59d3f4f94d3d3fedf2ebcb7110ae8d6" translate="yes" xml:space="preserve">
          <source>This is semantically equivalent to calling &lt;a href=&quot;../ptr/fn.read&quot;&gt;&lt;code&gt;ptr::read&lt;/code&gt;&lt;/a&gt; and discarding the result, but has the following advantages:</source>
          <target state="translated">이것은 의미 적으로 &lt;a href=&quot;../ptr/fn.read&quot;&gt; &lt;code&gt;ptr::read&lt;/code&gt; &lt;/a&gt; 를 호출 하고 결과를 버리는 것과 동일 하지만 다음과 같은 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8249e0d4f2746bf5b8aa8a678e0e1e5a321179d" translate="yes" xml:space="preserve">
          <source>This is semantically equivalent to calling &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;ptr::read&lt;/code&gt;&lt;/a&gt; and discarding the result, but has the following advantages:</source>
          <target state="translated">이것은 의미 적으로 &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;ptr::read&lt;/code&gt; &lt;/a&gt; 를 호출 하고 결과를 버리는 것과 동일 하지만 다음과 같은 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f02e339323ce653dbff1ca427dde093c5fbdbad" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;../primitive.slice#method.clone_from_slice&quot;&gt;&lt;code&gt;slice::clone_from_slice&lt;/code&gt;&lt;/a&gt; but does not drop existing elements.</source>
          <target state="translated">&lt;a href=&quot;../primitive.slice#method.clone_from_slice&quot;&gt; &lt;code&gt;slice::clone_from_slice&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 기존 요소를 삭제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="358e0f225467b03900d6e8992dde5d0b7bc40738" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;../primitive.slice#method.copy_from_slice&quot;&gt;&lt;code&gt;slice::copy_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;../primitive.slice#method.copy_from_slice&quot;&gt; &lt;code&gt;slice::copy_from_slice&lt;/code&gt; &lt;/a&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="fb69e9b77c8f67d2dd23964f55732bc6174eb1f3" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;struct.mutex#poisoning&quot;&gt;poisoning with mutexes&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;struct.mutex#poisoning&quot;&gt;뮤텍스&lt;/a&gt; 를 이용한 중독과 유사하다 .</target>
        </trans-unit>
        <trans-unit id="323433898b799fb03eed09fdd2d727e9828c9a3d" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;wake&lt;/code&gt;, but may be slightly less efficient in the case where an owned &lt;code&gt;Waker&lt;/code&gt; is available. This method should be preferred to calling &lt;code&gt;waker.clone().wake()&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;wake&lt;/code&gt; 와 비슷 하지만 소유 한 &lt;code&gt;Waker&lt;/code&gt; 를 사용할 수 있는 경우 약간 덜 효율적일 수 있습니다. 이 메소드는 &lt;code&gt;waker.clone().wake()&lt;/code&gt; 를 호출하는 것보다 선호됩니다 .</target>
        </trans-unit>
        <trans-unit id="67ff9ed313be1a208e09d5213c1e87906d1b8ae8" translate="yes" xml:space="preserve">
          <source>This is similar to taking a reference to the whole &lt;code&gt;String&lt;/code&gt; but with the extra &lt;code&gt;[0..5]&lt;/code&gt; bit. Rather than a reference to the entire &lt;code&gt;String&lt;/code&gt;, it&amp;rsquo;s a reference to a portion of the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">이것은 전체 &lt;code&gt;String&lt;/code&gt; 참조 하지만 여분의 &lt;code&gt;[0..5]&lt;/code&gt; 비트 를 갖는 것과 유사합니다 . 전체 &lt;code&gt;String&lt;/code&gt; 에 대한 참조가 아니라 &lt;code&gt;String&lt;/code&gt; 의 일부에 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="8e7a7ddaef0be30145306f6816d2b3ff35a14d32" translate="yes" xml:space="preserve">
          <source>This is similar to the second sub-error, but subtler. It happens in situations like the following:</source>
          <target state="translated">이것은 두 번째 하위 오류와 비슷하지만 미묘합니다. 다음과 같은 상황에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7512abd4f4f8baf21d2fa3f6cea905e84ac77b34" translate="yes" xml:space="preserve">
          <source>This is simply a special - but common - case of the previous: hiding mutability for operations that appear to be immutable. The &lt;code&gt;clone&lt;/code&gt; method is expected to not change the source value, and is declared to take &lt;code&gt;&amp;amp;self&lt;/code&gt;, not &lt;code&gt;&amp;amp;mut self&lt;/code&gt;. Therefore, any mutation that happens in the &lt;code&gt;clone&lt;/code&gt; method must use cell types. For example, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; maintains its reference counts within a &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 단순히 이전의 특별한 경우이지만 일반적인 경우입니다. 변경 불가능한 것으로 보이는 조작에 대해 변경 가능한 숨기기. &lt;code&gt;clone&lt;/code&gt; 방법은 소스 값을 변경할 것으로 예상되며, 취할 선언 &lt;code&gt;&amp;amp;self&lt;/code&gt; ,하지 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; . 따라서 &lt;code&gt;clone&lt;/code&gt; 방법 에서 발생하는 모든 돌연변이는 세포 유형을 사용해야합니다. 예를 들어, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 는 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 내에서 참조 횟수를 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="022f67943cd560f4bdb5afc8c97b7f6c6d3167eb" translate="yes" xml:space="preserve">
          <source>This is sometimes done as part of an FFI:</source>
          <target state="translated">이것은 때때로 FFI의 일부로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="29a8f7be9a323b371a4c7f94c367da9cdcb60e7e" translate="yes" xml:space="preserve">
          <source>This is supported on &lt;strong&gt;(Android or DragonFly BSD or Emscripten or FreeBSD or Linux or NetBSD or OpenBSD) and Unix&lt;/strong&gt; only.</source>
          <target state="translated">이것은 &lt;strong&gt;(Android 또는 DragonFly BSD 또는 Emscripten 또는 FreeBSD 또는 Linux 또는 NetBSD 또는 OpenBSD) 및 Unix&lt;/strong&gt; 에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1cd9f4e2b3a9d48a4944f59c96788167ca07951a" translate="yes" xml:space="preserve">
          <source>This is supported on &lt;strong&gt;Android or DragonFly BSD or Emscripten or FreeBSD or Linux or NetBSD or OpenBSD&lt;/strong&gt; only.</source>
          <target state="translated">이는 &lt;strong&gt;Android 또는 DragonFly BSD 또는 Emscripten 또는 FreeBSD 또는 Linux 또는 NetBSD 또는 OpenBSD&lt;/strong&gt; 에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c76ae31cc8e606b25f4d72f00019a489e501ce07" translate="yes" xml:space="preserve">
          <source>This is supported on &lt;strong&gt;Linux&lt;/strong&gt; only.</source>
          <target state="translated">이것은 &lt;strong&gt;Linux&lt;/strong&gt; 에서만 지원 됩니다.</target>
        </trans-unit>
        <trans-unit id="100ddfe0611f62c2fe34cd0d08120e1dfeacd050" translate="yes" xml:space="preserve">
          <source>This is supported on &lt;strong&gt;Unix&lt;/strong&gt; only.</source>
          <target state="translated">이것은 &lt;strong&gt;Unix&lt;/strong&gt; 에서만 지원 됩니다.</target>
        </trans-unit>
        <trans-unit id="820275ba907af27ec04ee3e4464292d92354d5b6" translate="yes" xml:space="preserve">
          <source>This is supported on &lt;strong&gt;Windows&lt;/strong&gt; only.</source>
          <target state="translated">이것은 &lt;strong&gt;Windows&lt;/strong&gt; 에서만 지원 됩니다.</target>
        </trans-unit>
        <trans-unit id="ce79f7fec51f65c567a6d4b960b891ab223ea0af" translate="yes" xml:space="preserve">
          <source>This is supported on Linux only.</source>
          <target state="translated">이것은 Linux에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5d02662201a60807bdb13970d8ae5dbd58d92a03" translate="yes" xml:space="preserve">
          <source>This is supported on Unix only.</source>
          <target state="translated">이것은 유닉스에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="fe81960399abac0748704c3a05349d9cd7f1ac2c" translate="yes" xml:space="preserve">
          <source>This is supported on Windows only.</source>
          <target state="translated">이것은 Windows에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7dbd409e3c209511b0279195cd6826fb5e1a2b3b" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;longest&lt;/code&gt; function from Listing 10-22 that returns the longer of two string slices. But now it has an extra parameter named &lt;code&gt;ann&lt;/code&gt; of the generic type &lt;code&gt;T&lt;/code&gt;, which can be filled in by any type that implements the &lt;code&gt;Display&lt;/code&gt; trait as specified by the &lt;code&gt;where&lt;/code&gt; clause. This extra parameter will be printed before the function compares the lengths of the string slices, which is why the &lt;code&gt;Display&lt;/code&gt; trait bound is necessary. Because lifetimes are a type of generic, the declarations of the lifetime parameter &lt;code&gt;'a&lt;/code&gt; and the generic type parameter &lt;code&gt;T&lt;/code&gt; go in the same list inside the angle brackets after the function name.</source>
          <target state="translated">이것은 Listing 10-22에서 &lt;code&gt;longest&lt;/code&gt; 함수로, 두 문자열 슬라이스 중 더 긴 문자열을 반환합니다. 그러나 이제 일반 유형 &lt;code&gt;T&lt;/code&gt; 의 &lt;code&gt;ann&lt;/code&gt; 이라는 추가 매개 변수 가 있으며 , &lt;code&gt;where&lt;/code&gt; 절에 지정된대로 &lt;code&gt;Display&lt;/code&gt; 특성 을 구현하는 모든 유형으로 채울 수 있습니다 . 이 추가 매개 변수는 함수가 문자열 슬라이스의 길이를 비교하기 전에 인쇄되므로 &lt;code&gt;Display&lt;/code&gt; 특성 제한이 필요한 이유 입니다. 수명은 제네릭 형식이므로 수명 매개 변수 &lt;code&gt;'a&lt;/code&gt; 와 제네릭 형식 매개 변수 &lt;code&gt;T&lt;/code&gt; 의 선언은 함수 이름 뒤에 꺾쇠 괄호 안에있는 동일한 목록에 있습니다.</target>
        </trans-unit>
        <trans-unit id="771b5400b1697f2e03b3ff52d8994e98c72fb56e" translate="yes" xml:space="preserve">
          <source>This is the alignment used for struct fields. It may be smaller than the preferred alignment.</source>
          <target state="translated">구조체 필드에 사용되는 정렬입니다. 선호하는 정렬보다 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7e12ec340db516b6de450f2a63092abb536959d" translate="yes" xml:space="preserve">
          <source>This is the const generic equivalent of &lt;a href=&quot;#method.windows&quot;&gt;&lt;code&gt;windows&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#method.windows&quot;&gt; &lt;code&gt;windows&lt;/code&gt; &lt;/a&gt; 와 동등한 일반 const 입니다.</target>
        </trans-unit>
        <trans-unit id="9ea5fa4cdf245151000dcd8208cd57fa7396ef40" translate="yes" xml:space="preserve">
          <source>This is the correct syntax:</source>
          <target state="translated">이것은 올바른 구문입니다.</target>
        </trans-unit>
        <trans-unit id="8a3edb9de97e0819d33135bbb50051a98c123c3a" translate="yes" xml:space="preserve">
          <source>This is the difference between &lt;code&gt;1.0&lt;/code&gt; and the next larger representable number.</source>
          <target state="translated">이것은 &lt;code&gt;1.0&lt;/code&gt; 과 다음으로 큰 표현 가능한 숫자의 차이입니다.</target>
        </trans-unit>
        <trans-unit id="540ad0b8406b1727e0f455b9b013663295117df7" translate="yes" xml:space="preserve">
          <source>This is the difference between &lt;code&gt;1.0&lt;/code&gt; and the next largest representable number.</source>
          <target state="translated">이것은 &lt;code&gt;1.0&lt;/code&gt; 과 다음으로 가장 큰 표현 가능한 숫자의 차이입니다.</target>
        </trans-unit>
        <trans-unit id="c620ac5f199d804600d9e6fa867d20d7e4f16f11" translate="yes" xml:space="preserve">
          <source>This is the first example of Rust&amp;rsquo;s safety principles in action. In many low-level languages, this kind of check is not done, and when you provide an incorrect index, invalid memory can be accessed. Rust protects you against this kind of error by immediately exiting instead of allowing the memory access and continuing. Chapter 9 discusses more of Rust&amp;rsquo;s error handling.</source>
          <target state="translated">이것이 Rust의 안전 원칙의 첫 번째 예입니다. 많은 저수준 언어에서 이러한 종류의 검사는 수행되지 않으며 잘못된 인덱스를 제공하면 유효하지 않은 메모리에 액세스 할 수 있습니다. Rust는 메모리 액세스를 허용하고 계속하는 대신 즉시 종료하여 이러한 종류의 오류로부터 사용자를 보호합니다. 9 장에서는 Rust의 오류 처리에 대해 더 설명합니다.</target>
        </trans-unit>
        <trans-unit id="96d082bf8459464d47b35442a1fa45813a325a53" translate="yes" xml:space="preserve">
          <source>This is the main iterator trait. For more about the concept of iterators generally, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;. In particular, you may want to know how to &lt;a href=&quot;index#implementing-iterator&quot;&gt;implement &lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것이 주요 반복자 특성입니다. 반복자의 개념에 대한 자세한 내용은 &lt;a href=&quot;index&quot;&gt;모듈 수준 설명서&lt;/a&gt; 를 참조하십시오 . 특히, &lt;a href=&quot;index#implementing-iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 구현 방법을 알고 싶을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b386764c4159d37f683e85f4c4afa8c88d4fe909" translate="yes" xml:space="preserve">
          <source>This is the non-panicking alternative to indexing the &lt;code&gt;str&lt;/code&gt;. Returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; whenever equivalent indexing operation would panic.</source>
          <target state="translated">이것은 &lt;code&gt;str&lt;/code&gt; 인덱싱에 대한 당황하지 않는 대안 입니다. 동등한 인덱싱 작업이 패닉 될 때마다 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="289f1434eafb60316aca77ad31a00e3c0eb9323a" translate="yes" xml:space="preserve">
          <source>This is the non-panicking alternative to indexing the &lt;code&gt;str&lt;/code&gt;. Returns &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; whenever equivalent indexing operation would panic.</source>
          <target state="translated">이것은 &lt;code&gt;str&lt;/code&gt; 인덱싱에 대한 당황하지 않는 대안 입니다. 동등한 색인 작업이 패닉 상태가 될 때마다 &lt;a href=&quot;option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="759018d521d201d38bc076c0727a5d9a6e429fac" translate="yes" xml:space="preserve">
          <source>This is the non-panicking variant of &lt;a href=&quot;#method.borrow&quot;&gt;&lt;code&gt;borrow&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 당황스럽지 않은 &lt;a href=&quot;#method.borrow&quot;&gt; &lt;code&gt;borrow&lt;/code&gt; &lt;/a&gt; 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="70fed40b0a485aa104ed49c92498ff0b436cf03b" translate="yes" xml:space="preserve">
          <source>This is the non-panicking variant of &lt;a href=&quot;#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#method.borrow_mut&quot;&gt; &lt;code&gt;borrow_mut&lt;/code&gt; &lt;/a&gt; 당황하지 않은 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="ccd5e95eaa2f4ad9676aca34c8e9ba1ff21b3015" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;../../iter/trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이것은 &lt;a href=&quot;../../iter/trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;Iterator::try_fold()&lt;/code&gt; &lt;/a&gt; 의 역 버전입니다 : 반복기의 뒤에서 시작하는 요소를받습니다. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fd0528fc88151b305168bd5debfa38b6c659b612" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;../iter/trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이것은 &lt;a href=&quot;../iter/trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;Iterator::try_fold()&lt;/code&gt; &lt;/a&gt; 의 역 버전입니다 : 반복기의 뒤에서 시작하는 요소를받습니다. &lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d0fe748271e612bae240bf98e735a830b559c459" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;iter/trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이것은 &lt;a href=&quot;iter/trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;Iterator::try_fold()&lt;/code&gt; &lt;/a&gt; 의 역 버전입니다 : 반복기의 뒤에서 시작하는 요소를받습니다. &lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d3a0dba802b6e4f6285d94d4683f5056846f9fd" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;Iterator::fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="translated">이것은 &lt;a href=&quot;trait.iterator#method.fold&quot;&gt; &lt;code&gt;Iterator::fold()&lt;/code&gt; &lt;/a&gt; 의 반대 버전입니다. 반복기 의 뒤에서 시작하는 요소를받습니다.</target>
        </trans-unit>
        <trans-unit id="cce445e189c1252f0055062d54b89751ff0fb729" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="translated">이것은 &lt;a href=&quot;trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt; 의 역 버전입니다 : 반복자의 뒤에서 시작하는 요소를 취합니다.</target>
        </trans-unit>
        <trans-unit id="bc1780a770503660513f01fa15c1efc71fef0175" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="translated">이것은 &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;Iterator::try_fold()&lt;/code&gt; &lt;/a&gt; 의 역 버전입니다 : 반복기의 뒤에서 시작하는 요소를받습니다.</target>
        </trans-unit>
        <trans-unit id="fe6ff5d62e332d4883802b0cf8675d53b663b171" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이것은 &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;Iterator::try_fold()&lt;/code&gt; &lt;/a&gt; 의 역 버전입니다 : 반복기의 뒤에서 시작하는 요소를받습니다. &lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53f33f9266690c3f1f82aab587ca29e140daa7ab" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="translated">이것은 &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;try_fold()&lt;/code&gt; &lt;/a&gt; 의 역 버전입니다 . 그것은 반복자의 뒤에서 시작하는 요소를 취합니다.</target>
        </trans-unit>
        <trans-unit id="d46122a89a465fda704ceb8118ba4c1126be2832" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이것은 [ &lt;code&gt;try_fold()&lt;/code&gt; ] 의 역 버전입니다 . 반복자의 뒤에서 시작하는 요소가 필요합니다. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f495531f8eacf0a1680dc0219ed83707197faddd" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이것은 [ &lt;code&gt;try_fold()&lt;/code&gt; ] 의 역 버전입니다 . 반복자의 뒤에서 시작하는 요소가 필요합니다. &lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0ec81940d41390cbbcb80997a4e3d957d2b9a317" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이것은 [ &lt;code&gt;try_fold()&lt;/code&gt; ] 의 역 버전입니다 . 반복자의 뒤에서 시작하는 요소가 필요합니다. &lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ff3fa51ad38f312277040719826a7c977bbcd8a" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이것은 [ &lt;code&gt;try_fold()&lt;/code&gt; ] 의 역 버전입니다 . 반복자의 뒤에서 시작하는 요소가 필요합니다. &lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="383e94e01b1343c9d6bcfb23e7f045e384d94336" translate="yes" xml:space="preserve">
          <source>This is the same as using the &lt;code&gt;==&lt;/code&gt; operator, but less generic: the arguments have to be &lt;code&gt;*const T&lt;/code&gt; raw pointers, not anything that implements &lt;code&gt;PartialEq&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;==&lt;/code&gt; 연산자 를 사용하는 것과 동일 하지만 덜 일반적입니다. 인수는 &lt;code&gt;PartialEq&lt;/code&gt; 를 구현하는 것이 아니라 &lt;code&gt;*const T&lt;/code&gt; 원시 포인터 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="22b2f39cdef64a09df83167c24366e9e24591fdf" translate="yes" xml:space="preserve">
          <source>This is the unchecked alternative to indexing the &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;str&lt;/code&gt; 인덱싱에 대한 확인되지 않은 대안 입니다.</target>
        </trans-unit>
        <trans-unit id="589a4243aa6d42e7fc5ac36f0baed5a47e1de444" translate="yes" xml:space="preserve">
          <source>This is used for object safety, to check that a method's receiver type can be dispatched on.</source>
          <target state="translated">메소드의 수신자 유형을 전달할 수 있는지 확인하기 위해 오브젝트 안전에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9aea807f1415223ad9d946b1ace7fbf6d55fe5aa" translate="yes" xml:space="preserve">
          <source>This is used when the programmer knows that the thread will have nothing to do for some time, and thus avoid wasting computing time.</source>
          <target state="translated">이것은 프로그래머가 스레드가 한동안 아무 것도 할 일이 없다는 것을 알고 컴퓨팅 시간 낭비를 피할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ce1e416198eb464ee0a2977f8013c35c0e89565" translate="yes" xml:space="preserve">
          <source>This is useful any time that the compiler can't determine that some code is unreachable. For example:</source>
          <target state="translated">이것은 컴파일러가 일부 코드에 도달 할 수 없다고 판단 할 수 없을 때 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85e4c5ffc08236fd25e25201dcbaaa8757900c78" translate="yes" xml:space="preserve">
          <source>This is useful for</source>
          <target state="translated">이것은 유용합니다</target>
        </trans-unit>
        <trans-unit id="a885d8fe460e46c9230b0d468a457bef6acf54a6" translate="yes" xml:space="preserve">
          <source>This is useful for a flavor of &quot;optimistic check&quot; before deciding to block on a receiver.</source>
          <target state="translated">이는 수신기에서 차단을 결정하기 전에 &quot;낙관적 검사&quot;의 특징에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="79e1d9086d9f417d98c9a3f1df01e78fe0db96d9" translate="yes" xml:space="preserve">
          <source>This is useful for initializing types which lazily allocate, like &lt;code&gt;Vec::new&lt;/code&gt; does.</source>
          <target state="translated">이것은 &lt;code&gt;Vec::new&lt;/code&gt; 처럼 지연 할당하는 타입을 초기화하는데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="08ec962229a27774cdabf85bddcaa5d6f625b9ff" translate="yes" xml:space="preserve">
          <source>This is useful to allow applying iterator adaptors while still retaining ownership of the original iterator.</source>
          <target state="translated">이것은 원래 반복자의 소유권을 계속 유지하면서 반복자 어댑터를 적용 할 수 있도록하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="920763b96fccf7eb85a93a16a5bdd675d6fd634c" translate="yes" xml:space="preserve">
          <source>This is useful when the ownership of the underlying resource was previously transferred to code outside of Rust, for example by transmitting the raw file descriptor to C code.</source>
          <target state="translated">이는 예를 들어 원시 파일 설명자를 C 코드로 전송하여 기본 리소스의 소유권이 이전에 Rust 외부의 코드로 전송되었을 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c983c1aa2c476c3f346d2a87a469f6be7bac78d1" translate="yes" xml:space="preserve">
          <source>This is useful when you are doing a type conversion that may trivially succeed but may also need special handling. For example, there is no way to convert an &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt; into an &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; using the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait, because an &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt; may contain a value that an &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; cannot represent and so the conversion would lose data. This might be handled by truncating the &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt; to an &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; (essentially giving the &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;'s value modulo &lt;a href=&quot;../i32/constant.max&quot;&gt;&lt;code&gt;i32::MAX&lt;/code&gt;&lt;/a&gt;) or by simply returning &lt;a href=&quot;../i32/constant.max&quot;&gt;&lt;code&gt;i32::MAX&lt;/code&gt;&lt;/a&gt;, or by some other method. The &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait is intended for perfect conversions, so the &lt;code&gt;TryFrom&lt;/code&gt; trait informs the programmer when a type conversion could go bad and lets them decide how to handle it.</source>
          <target state="translated">이것은 사소하게 성공할 수 있지만 특별한 처리가 필요할 수도있는 유형 변환을 수행 할 때 유용합니다. 예를 들어 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; 를 사용하여 i64 를 &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 로 변환 할 수있는 방법이 없습니다 . &lt;a href=&quot;../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; 에는 &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 가 나타낼 수없는 값이 포함될 수 있으므로 변환에서 데이터가 손실 될 수 있기 때문 입니다. 이것은 &lt;a href=&quot;../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; 를 &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; 로&lt;/a&gt;자르거나 (본질적으로 &lt;a href=&quot;../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; 의 값 모듈로 &lt;a href=&quot;../i32/constant.max&quot;&gt; &lt;code&gt;i32::MAX&lt;/code&gt; &lt;/a&gt; ) 또는 단순히 &lt;a href=&quot;../i32/constant.max&quot;&gt; &lt;code&gt;i32::MAX&lt;/code&gt; &lt;/a&gt; 를 반환 하거나 다른 방법으로 처리 할 수 ​​있습니다. &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 특성은, 완벽한 전환을위한 소위되어 &lt;code&gt;TryFrom&lt;/code&gt; 특성은 프로그래머에게 유형 변환이 잘못 될 수 있음을 알리고 처리 방법을 결정할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="63ccb84e9a4faa353cb290ddc5e855748a76c17b" translate="yes" xml:space="preserve">
          <source>This is useful when you are doing a type conversion that may trivially succeed but may also need special handling. For example, there is no way to convert an &lt;code&gt;i64&lt;/code&gt; into an &lt;code&gt;i32&lt;/code&gt; using the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait, because an &lt;code&gt;i64&lt;/code&gt; may contain a value that an &lt;code&gt;i32&lt;/code&gt; cannot represent and so the conversion would lose data. This might be handled by truncating the &lt;code&gt;i64&lt;/code&gt; to an &lt;code&gt;i32&lt;/code&gt; (essentially giving the &lt;code&gt;i64&lt;/code&gt;'s value modulo &lt;code&gt;i32::MAX&lt;/code&gt;) or by simply returning &lt;code&gt;i32::MAX&lt;/code&gt;, or by some other method. The &lt;code&gt;From&lt;/code&gt; trait is intended for perfect conversions, so the &lt;code&gt;TryFrom&lt;/code&gt; trait informs the programmer when a type conversion could go bad and lets them decide how to handle it.</source>
          <target state="translated">사소하게 성공할 수도 있지만 특수 처리가 필요할 수도있는 유형 변환을 수행 할 때 유용합니다. 예를 들어, 변환 할 수있는 방법이 없습니다 &lt;code&gt;i64&lt;/code&gt; 로 &lt;code&gt;i32&lt;/code&gt; 를 사용 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 때문에, 특성 &lt;code&gt;i64&lt;/code&gt; 하는 값이 포함될 수 있습니다 &lt;code&gt;i32&lt;/code&gt; 변환이 데이터를 잃을 수 있도록 표현하고 할 수 있습니다. 이것은 &lt;code&gt;i64&lt;/code&gt; 를 &lt;code&gt;i32&lt;/code&gt; 로자르거나 (필수적으로 &lt;code&gt;i64&lt;/code&gt; 의 값 modulo &lt;code&gt;i32::MAX&lt;/code&gt; ) 또는 단순히 &lt;code&gt;i32::MAX&lt;/code&gt; 를 반환 하거나 다른 방법으로 처리 할 수 ​​있습니다. &lt;code&gt;From&lt;/code&gt; 특성은, 완벽한 전환을위한 소위되어 &lt;code&gt;TryFrom&lt;/code&gt; trait는 프로그래머에게 타입 변환이 나빠질 때 알려주고 처리 방법을 결정할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="878335df341d736b2b477f7d269d41d041479a70" translate="yes" xml:space="preserve">
          <source>This is useful when you have an iterator of iterators or an iterator of things that can be turned into iterators and you want to remove one level of indirection.</source>
          <target state="translated">이터레이터의 이터레이터 또는 이터레이터로 변환 될 수있는 것들의 이터레이터가 있고 한 레벨의 간접적 인 제거를 원할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bc06069272831e3fab63600d60da8286a4aa9faf" translate="yes" xml:space="preserve">
          <source>This is useful when you have an iterator over &lt;code&gt;&amp;amp;T&lt;/code&gt;, but you need an iterator over &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">당신의 반복자가있을 때 유용 &lt;code&gt;&amp;amp;T&lt;/code&gt; ,하지만 당신은 반복자 필요 &lt;code&gt;T&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="28c350dd4bfc1f4f50a6db4a558fce8f481fa714" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted list of items as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">형식화 된 항목 목록을 &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt; 구현 의 일부로 출력하려는 ​​경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="023c37d743c95a28f62cb66dc28c6981840e275e" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted map as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">형식화 된 맵을 &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt; 구현 의 일부로 출력하려는 ​​경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="5a019c845f0ac55c26e73d5fc98b9e29c14a5266" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted set of items as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">형식화 된 항목 집합을 &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt; 구현 의 일부로 출력하려는 ​​경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="742e4efaa0964cab1a9b13d64aa3f1ee505fbe93" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted struct as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">형식화 된 구조체를 &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt; 구현 의 일부로 출력하려는 ​​경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="7450774ae735743f9affac51ccc2935a02180916" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted tuple as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">형식화 된 튜플을 &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt; 구현 의 일부로 출력하려는 ​​경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="678189b9778744d56a77a9ddbd180a89dff66dd0" translate="yes" xml:space="preserve">
          <source>This is usually not needed when writing safe code, as &lt;a href=&quot;../sync/struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;es&lt;/a&gt; already poison themselves when a thread panics while holding the lock.</source>
          <target state="translated">&lt;a href=&quot;../sync/struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; es&lt;/a&gt; 는 잠금 장치를 잡고있는 동안 스레드 패닉이 발생하면 이미 중독 되기 때문에 일반적으로 안전한 코드를 작성할 때는 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="73513599023f5ddb254ee6ed0d00bccac264c338" translate="yes" xml:space="preserve">
          <source>This is usually the same as &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;. However, when &lt;code&gt;T&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; no statically-known size, e.g., a slice &lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;trait object&lt;/a&gt;, then &lt;code&gt;size_of_val&lt;/code&gt; can be used to get the dynamically-known size.</source>
          <target state="translated">일반적으로 &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 와 동일 합니다. 그러나 &lt;code&gt;T&lt;/code&gt; &lt;em&gt;에&lt;/em&gt; 정적으로 알려진 크기, 예를 들어 슬라이스 &lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;특성 객체&lt;/a&gt; 가없는 경우 &lt;code&gt;size_of_val&lt;/code&gt; 을 사용하여 동적으로 알려진 크기를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b96a4f28b82d88010bb7132ad9ee35ef317464c" translate="yes" xml:space="preserve">
          <source>This is usually the same as &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;. However, when &lt;code&gt;T&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; no statically-known size, e.g., a slice &lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;trait object&lt;/a&gt;, then &lt;code&gt;size_of_val_raw&lt;/code&gt; can be used to get the dynamically-known size.</source>
          <target state="translated">일반적으로 &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 와 동일 합니다. 그러나 &lt;code&gt;T&lt;/code&gt; &lt;em&gt;에&lt;/em&gt; 정적으로 알려진 크기 &lt;em&gt;가&lt;/em&gt; 없는 경우 (예 : 슬라이스 &lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;특성 객체)&lt;/a&gt; , &lt;code&gt;size_of_val_raw&lt;/code&gt; 를 사용하여 동적으로 알려진 크기를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8abe6d863c59136664f0a7528f19c0cd3ff2fed7" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the exact signature that&amp;rsquo;s in the standard library: in the standard library, &lt;code&gt;add&lt;/code&gt; is defined using generics. Here, we&amp;rsquo;re looking at the signature of &lt;code&gt;add&lt;/code&gt; with concrete types substituted for the generic ones, which is what happens when we call this method with &lt;code&gt;String&lt;/code&gt; values. We&amp;rsquo;ll discuss generics in Chapter 10. This signature gives us the clues we need to understand the tricky bits of the &lt;code&gt;+&lt;/code&gt; operator.</source>
          <target state="translated">이것은 표준 라이브러리에있는 정확한 서명이 아닙니다. 표준 라이브러리에서 &lt;code&gt;add&lt;/code&gt; 는 제네릭을 사용하여 정의됩니다. 여기서는 일반적인 타입으로 대체 된 구체적인 타입을 가진 &lt;code&gt;add&lt;/code&gt; 의 시그니처를보고 있는데, 이것은 &lt;code&gt;String&lt;/code&gt; 값 으로이 메소드를 호출 할 때 발생 합니다. 10 장에서 제네릭에 대해 논의 할 것입니다.이 서명은 &lt;code&gt;+&lt;/code&gt; 연산자 의 까다로운 비트를 이해하는 데 필요한 단서를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="677e3e0ad58a3857efcf5b71bd28f251f1ad71c2" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the last you&amp;rsquo;ll see of concurrency in this book: the project in Chapter 20 will use the concepts in this chapter in a more realistic situation than the smaller examples discussed here.</source>
          <target state="translated">이 책에서 동시성에 대해 마지막으로 볼 수있는 것은 아닙니다. 20 장의 프로젝트는 여기에서 논의 된 작은 예제보다 더 현실적인 상황에서이 장의 개념을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c724cabc6d2e28a46495b5e9f7308161c3ff4773" translate="yes" xml:space="preserve">
          <source>This isn't allowed, but using a trait to implement a method is a good solution. Example:</source>
          <target state="translated">이것은 허용되지 않지만 특성을 사용하여 메소드를 구현하는 것이 좋습니다. 예:</target>
        </trans-unit>
        <trans-unit id="89a100ed08885eb96e8a08b563ffa2fce44e1756" translate="yes" xml:space="preserve">
          <source>This isn't allowed, but using a trait to implement a method or constant is a good solution. Example:</source>
          <target state="translated">이것은 허용되지 않지만, 메소드 나 상수를 구현하기 위해 트레이 트를 사용하는 것이 좋은 해결책입니다. 예:</target>
        </trans-unit>
        <trans-unit id="c15fbb2556c65982174521dc6e82a15681dc164d" translate="yes" xml:space="preserve">
          <source>This isn't typically the method you want; these addresses don't typically function on modern systems. Use &lt;code&gt;to_ipv6_mapped&lt;/code&gt; instead.</source>
          <target state="translated">이것은 일반적으로 원하는 방법이 아닙니다. 이러한 주소는 일반적으로 최신 시스템에서 작동하지 않습니다. 대신 &lt;code&gt;to_ipv6_mapped&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca75bc59c45502aa721dfcf6b2008b560ce93b8c" translate="yes" xml:space="preserve">
          <source>This issue also ties into the second problem: although &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; are configuration variables to our program, variables like &lt;code&gt;contents&lt;/code&gt; are used to perform the program&amp;rsquo;s logic. The longer &lt;code&gt;main&lt;/code&gt; becomes, the more variables we&amp;rsquo;ll need to bring into scope; the more variables we have in scope, the harder it will be to keep track of the purpose of each. It&amp;rsquo;s best to group the configuration variables into one structure to make their purpose clear.</source>
          <target state="translated">이 문제는 두 번째 문제와도 관련이 있습니다. &lt;code&gt;query&lt;/code&gt; 와 &lt;code&gt;filename&lt;/code&gt; 은 프로그램의 구성 변수 이지만 &lt;code&gt;contents&lt;/code&gt; 과 같은 변수 는 프로그램의 논리를 수행하는 데 사용됩니다. &lt;code&gt;main&lt;/code&gt; 이 길어질 수록 범위에 더 많은 변수를 가져와야합니다. 범위에있는 변수가 많을수록 각각의 목적을 추적하기가 더 어려워집니다. 구성 변수를 하나의 구조로 그룹화하여 목적을 명확하게하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f6ff2f3673f7e2d10b1136073892f6a7e26909fe" translate="yes" xml:space="preserve">
          <source>This iterator is &lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;fused&lt;/a&gt;, but the specific values of &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; after iteration has finished are &lt;strong&gt;unspecified&lt;/strong&gt; other than that &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;.is_empty()&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;true&lt;/code&gt; once no more values will be produced.</source>
          <target state="translated">이 반복자입니다 &lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;융합&lt;/a&gt; 만의 특정 값 &lt;code&gt;start&lt;/code&gt; 과 &lt;code&gt;end&lt;/code&gt; 반복이 완료된 후에는 &lt;strong&gt;지정되지 않은&lt;/strong&gt; 그 이외의 &lt;a href=&quot;#method.is_empty&quot;&gt; &lt;code&gt;.is_empty()&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;true&lt;/code&gt; 더 이상 값이 생성되지 않습니다 번.</target>
        </trans-unit>
        <trans-unit id="b1db674404809b8384b33fb85e1f59e9aa55c87a" translate="yes" xml:space="preserve">
          <source>This iterator is &lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;fused&lt;/a&gt;, but the specific values of &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; after iteration has finished are &lt;strong&gt;unspecified&lt;/strong&gt; other than that &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt;&lt;code&gt;.is_empty()&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;true&lt;/code&gt; once no more values will be produced.</source>
          <target state="translated">이 반복자는 &lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;fused&lt;/a&gt; 이지만 반복이 완료된 후 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 의 특정 값 은 &lt;strong&gt;지정되지&lt;/strong&gt; 않습니다. 그 &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt; &lt;code&gt;.is_empty()&lt;/code&gt; &lt;/a&gt; 가 더 이상 값이 생성되지 않으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="22ff5b740b07569a5d9914bbdea6a0fe28474b82" translate="yes" xml:space="preserve">
          <source>This iterator is returned from the &lt;a href=&quot;fn.read_dir&quot;&gt;&lt;code&gt;read_dir&lt;/code&gt;&lt;/a&gt; function of this module and will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Through a &lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt; information like the entry's path and possibly other metadata can be learned.</source>
          <target state="translated">이 반복자는 이 모듈 의 &lt;a href=&quot;fn.read_dir&quot;&gt; &lt;code&gt;read_dir&lt;/code&gt; &lt;/a&gt; 함수 에서 반환되며 &lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 의 인스턴스를 생성합니다 . &lt;a href=&quot;struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; 를&lt;/a&gt; 통해 항목의 경로 및 기타 메타 데이터와 같은 정보를 학습 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="039cfdd22f7232d788dc3924aaf58e6af89b9b42" translate="yes" xml:space="preserve">
          <source>This iterator will block whenever &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called, waiting for a new message, and &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; will be returned if the corresponding channel has hung up.</source>
          <target state="translated">이 반복자는 &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 메시지가 호출 될 때마다 차단 되고 새 메시지를 기다리며 해당 채널이 중단되면 &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="47622e0905704752b067e8fb130b53a4d875da6d" translate="yes" xml:space="preserve">
          <source>This iterator will block whenever &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called, waiting for a new message, and &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; will be returned when the corresponding channel has hung up.</source>
          <target state="translated">이 반복자는 &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 이 호출 될 때마다 차단 되고 새 메시지를 기다리며 해당 채널이 중단되면 &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3d5f1a4f383a40c5608e98cdb7f233b0d0bd50b4" translate="yes" xml:space="preserve">
          <source>This iterator will never block the caller in order to wait for data to become available. Instead, it will return &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 반복기는 데이터를 사용할 수있을 때까지 호출자를 차단하지 않습니다. 대신 &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="2ded90014878b45a9d1013952a0eeccef1815fa3" translate="yes" xml:space="preserve">
          <source>This iterator yields mutable references to the slice's elements, so while the element type of the slice is &lt;code&gt;i32&lt;/code&gt;, the element type of the iterator is &lt;code&gt;&amp;amp;mut i32&lt;/code&gt;.</source>
          <target state="translated">이 반복자는 슬라이스의 요소에 대해 변경 가능한 참조를 생성하므로 슬라이스의 요소 유형은 &lt;code&gt;i32&lt;/code&gt; 이고 반복자의 요소 유형은 &lt;code&gt;&amp;amp;mut i32&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f11293328eb4e550149e3eb11d18b4b99dadeb4a" translate="yes" xml:space="preserve">
          <source>This key uses the fastest possible implementation available to it for the target platform. It is instantiated with the &lt;a href=&quot;../macro.thread_local&quot;&gt;&lt;code&gt;thread_local!&lt;/code&gt;&lt;/a&gt; macro and the primary method is the &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 키는 대상 플랫폼에 대해 가장 빠른 구현을 사용합니다. &lt;a href=&quot;../macro.thread_local&quot;&gt; &lt;code&gt;thread_local!&lt;/code&gt; &lt;/a&gt; 로 인스턴스화됩니다 ! 매크로와 기본 방법은 &lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8ba72c9f8d060c616c313ff46104db0834e023c2" translate="yes" xml:space="preserve">
          <source>This kind of reordering is handled transparently by the CPU.</source>
          <target state="translated">이러한 종류의 재정렬은 CPU에 의해 투명하게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="01e9e67a62e244fe3547a3a6a38b452018a02bd0" translate="yes" xml:space="preserve">
          <source>This kind of string &lt;em&gt;can&lt;/em&gt; be mutated:</source>
          <target state="translated">이러한 종류의 문자열 &lt;em&gt;은 변경&lt;/em&gt; 될 &lt;em&gt;수&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="a40000b09a25d1541d4b670c6d1a695e653d4397" translate="yes" xml:space="preserve">
          <source>This last example is different because it is not possible to use the suffix syntax with a floating point literal ending in a period. &lt;code&gt;2.f64&lt;/code&gt; would attempt to call a method named &lt;code&gt;f64&lt;/code&gt; on &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">이 마지막 예제는 마침표로 끝나는 부동 소수점 리터럴과 함께 접미어 구문을 사용할 수 없기 때문에 다릅니다. &lt;code&gt;2.f64&lt;/code&gt; 는 방법이라는 호출을 시도 할 &lt;code&gt;f64&lt;/code&gt; 에 &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d48b41e91473a0fe92d3d1ed63ecf51de63aefff" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="translated">이 길이는 &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 또는 grapheme이 아닌 바이트 단위 입니다. 다시 말해, 인간이 줄의 길이를 고려하는 것이 아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="73dde2c319f588f84c6b8fc0596849d35bbf8b64" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="translated">이 길이는 바이트,하지에 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; s 또는 제자. 즉, 인간이 현의 길이를 고려하는 것과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="903d848487fc64b3813a8038fcea8db3d845066a" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="translated">이 길이는 &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 또는 grapheme이 아닌 바이트 단위 입니다. 다시 말해, 인간이 줄의 길이를 고려하는 것이 아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b4fe84d99fc580ad8ef75775e9a6a1acf338c01" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="translated">이 길이는 바이트,하지에 &lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; s 또는 제자. 즉, 인간이 현의 길이를 고려하는 것과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f8980a7dcbb36debff75ad398d722c2e476b435" translate="yes" xml:space="preserve">
          <source>This limitation may be removed in a future version of Rust.</source>
          <target state="translated">이 제한은 이후 버전의 Rust에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65d7d6e48995b9a8b70ff571d23a4947777c0d68" translate="yes" xml:space="preserve">
          <source>This limitation on the size &lt;code&gt;N&lt;/code&gt; exists because Rust does not yet support code that is generic over the size of an array type. &lt;code&gt;[Foo; 3]&lt;/code&gt; and &lt;code&gt;[Bar; 3]&lt;/code&gt; are instances of same generic type &lt;code&gt;[T; 3]&lt;/code&gt;, but &lt;code&gt;[Foo; 3]&lt;/code&gt; and &lt;code&gt;[Foo; 5]&lt;/code&gt; are entirely different types. As a stopgap, trait implementations are statically generated up to size 32.</source>
          <target state="translated">Rust가 배열 유형의 크기보다 일반적인 코드를 아직 지원하지 않기 때문에 크기 &lt;code&gt;N&lt;/code&gt; 에 대한 이러한 제한이 존재합니다. &lt;code&gt;[Foo; 3]&lt;/code&gt; 및 &lt;code&gt;[Bar; 3]&lt;/code&gt; 은 동일한 제네릭 형식 &lt;code&gt;[T; 3]&lt;/code&gt; 이지만 &lt;code&gt;[Foo; 3]&lt;/code&gt; 및 &lt;code&gt;[Foo; 5]&lt;/code&gt; 는 완전히 다른 유형입니다. 스탑 갭으로서, 특성 구현은 정적으로 32까지 정적으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="08204384af7f77c5b07543f234ee809fc102751e" translate="yes" xml:space="preserve">
          <source>This line brings &lt;code&gt;std::io&lt;/code&gt; and &lt;code&gt;std::io::Write&lt;/code&gt; into scope.</source>
          <target state="translated">이 줄은 &lt;code&gt;std::io&lt;/code&gt; 및 &lt;code&gt;std::io::Write&lt;/code&gt; 를 범위로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="c84219e32c60c562866367e57dce5465f094cc72" translate="yes" xml:space="preserve">
          <source>This line creates a new empty string called &lt;code&gt;s&lt;/code&gt;, which we can then load data into. Often, we&amp;rsquo;ll have some initial data that we want to start the string with. For that, we use the &lt;code&gt;to_string&lt;/code&gt; method, which is available on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait, as string literals do. Listing 8-12 shows two examples.</source>
          <target state="translated">이 줄은 &lt;code&gt;s&lt;/code&gt; 라는 빈 문자열을 새로 만들어 데이터를로드 할 수 있습니다. 종종 문자열을 시작하려는 초기 데이터가 있습니다. 이를 위해 &lt;code&gt;to_string&lt;/code&gt; 메소드를 사용합니다 .이 메소드는 문자열 리터럴처럼 &lt;code&gt;Display&lt;/code&gt; 특성 을 구현하는 모든 유형에서 사용할 수 있습니다 . 목록 8-12는 두 가지 예를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c6d1af215b1b045e01e47bacfa1ae42f66655d33" translate="yes" xml:space="preserve">
          <source>This line creates a new variable named &lt;code&gt;foo&lt;/code&gt; and binds it to the value of the &lt;code&gt;bar&lt;/code&gt; variable. In Rust, variables are immutable by default. We&amp;rsquo;ll be discussing this concept in detail in the &lt;a href=&quot;ch03-01-variables-and-mutability#variables-and-mutability&quot;&gt;&amp;ldquo;Variables and Mutability&amp;rdquo;&lt;/a&gt; section in Chapter 3. The following example shows how to use &lt;code&gt;mut&lt;/code&gt; before the variable name to make a variable mutable:</source>
          <target state="translated">이 행은 &lt;code&gt;foo&lt;/code&gt; 라는 새 변수를 작성하고 이를 &lt;code&gt;bar&lt;/code&gt; 변수 의 값에 바인드합니다 . Rust에서 변수는 기본적으로 불변입니다. 이 개념에 &lt;a href=&quot;ch03-01-variables-and-mutability#variables-and-mutability&quot;&gt;대해서는&lt;/a&gt; 3 장의 &quot;변수 및 변경 가능성&quot; 섹션 에서 자세히 설명합니다 . 다음 예제는 변수 이름 앞에 &lt;code&gt;mut&lt;/code&gt; 를 사용 하여 변수를 변경 가능하게 만드는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="f414052fdd19a240f8f368c285f45f2ce792b467" translate="yes" xml:space="preserve">
          <source>This line does all the work in this little program: it prints text to the screen. There are four important details to notice here.</source>
          <target state="translated">이 줄은이 작은 프로그램의 모든 작업을 수행합니다. 텍스트를 화면에 인쇄합니다. 여기서 주목해야 할 4 가지 중요한 세부 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d9eacc9407c12ec62c5abf0aec26e9081e77d6a" translate="yes" xml:space="preserve">
          <source>This line does all the work in this little program: it prints text to the screen. There are four important details to notice here. First, Rust style is to indent with four spaces, not a tab.</source>
          <target state="translated">이 줄은이 작은 프로그램의 모든 작업을 수행합니다. 화면에 텍스트를 인쇄합니다. 여기에 주목해야 할 네 가지 중요한 세부 사항이 있습니다. 먼저, 녹 스타일은 탭이 아닌 네 개의 공백으로 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="6bb12529672d4d91a104d1b5e1346fffbd28c07c" translate="yes" xml:space="preserve">
          <source>This line prints the string we saved the user&amp;rsquo;s input in. The set of curly brackets, &lt;code&gt;{}&lt;/code&gt;, is a placeholder: think of &lt;code&gt;{}&lt;/code&gt; as little crab pincers that hold a value in place. You can print more than one value using curly brackets: the first set of curly brackets holds the first value listed after the format string, the second set holds the second value, and so on. Printing multiple values in one call to &lt;code&gt;println!&lt;/code&gt; would look like this:</source>
          <target state="translated">이 줄은 사용자의 입력을 저장 한 문자열을 인쇄합니다. 중괄호 &lt;code&gt;{}&lt;/code&gt; 는 자리 표시 자입니다. &lt;code&gt;{}&lt;/code&gt; 는 값을 유지하는 작은 게 집게로 생각하십시오 . 중괄호를 사용하여 둘 이상의 값을 인쇄 할 수 있습니다. 첫 번째 중괄호 세트는 형식 문자열 뒤에 나열된 첫 번째 값을 보유하고 두 번째 세트는 두 번째 값을 보유합니다. 한 번의 호출로 &lt;code&gt;println!&lt;/code&gt; 다음과 같이 보일 것입니다 :</target>
        </trans-unit>
        <trans-unit id="250f132a4cd3e14f1923c5e6c25a460649fabde4" translate="yes" xml:space="preserve">
          <source>This list is intended to grow over time and it is not recommended to exhaustively match against it.</source>
          <target state="translated">이 목록은 시간이 지남에 따라 증가하기위한 것이며 철저하게 일치시키는 것은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="308882c8bb15621452c72c71d1e862ba6ca42816" translate="yes" xml:space="preserve">
          <source>This longer form is equivalent to the example in the previous section but is more verbose. We place trait bounds with the declaration of the generic type parameter after a colon and inside angle brackets.</source>
          <target state="translated">이 긴 형식은 이전 섹션의 예와 동일하지만 더 장황합니다. 콜론과 꺾쇠 괄호 뒤에 generic 형식 매개 변수를 선언하여 특성 경계를 배치합니다.</target>
        </trans-unit>
        <trans-unit id="cc7e694b75fd14e7d2942129d96e2363378281a2" translate="yes" xml:space="preserve">
          <source>This looks very similar to the previous code, so we might assume that the way it works would be the same: that is, the second line would make a copy of the value in &lt;code&gt;s1&lt;/code&gt; and bind it to &lt;code&gt;s2&lt;/code&gt;. But this isn&amp;rsquo;t quite what happens.</source>
          <target state="translated">이것은 이전 코드와 매우 비슷해 보이므로 작동 방식이 동일하다고 가정 할 수 있습니다. 즉, 두 번째 줄은 &lt;code&gt;s1&lt;/code&gt; 의 값을 복사 하여 &lt;code&gt;s2&lt;/code&gt; 에 바인딩합니다 . 그러나 이것은 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1be98a7c6692df395b8bd9dd115eb38bb55be823" translate="yes" xml:space="preserve">
          <source>This macro accepts a 'writer', a format string, and a list of arguments. Arguments will be formatted according to the specified format string and the result will be passed to the writer. The writer may be any value with a &lt;code&gt;write_fmt&lt;/code&gt; method; generally this comes from an implementation of either the &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;fmt::Write&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait. The macro returns whatever the &lt;code&gt;write_fmt&lt;/code&gt; method returns; commonly a &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;, or an &lt;a href=&quot;io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 매크로는 '작성기', 형식 문자열 및 인수 목록을 허용합니다. 인수는 지정된 형식 문자열에 따라 형식이 지정되고 결과가 작성기에 전달됩니다. writer는 &lt;code&gt;write_fmt&lt;/code&gt; 메소드를 사용하는 모든 값이 될 수 있습니다 . 일반적으로 이것은 &lt;a href=&quot;fmt/trait.write&quot;&gt; &lt;code&gt;fmt::Write&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;io/trait.write&quot;&gt; &lt;code&gt;io::Write&lt;/code&gt; &lt;/a&gt; 특성 의 구현에서 비롯됩니다 . 매크로는 &lt;code&gt;write_fmt&lt;/code&gt; 메소드가 반환하는 모든 것을 반환합니다. 일반적으로 &lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3025eb870ba9e5f6ef770103ab20b04b0f42de4f" translate="yes" xml:space="preserve">
          <source>This macro accepts a format string, a list of arguments, and a 'writer'. Arguments will be formatted according to the specified format string and the result will be passed to the writer. The writer may be any value with a &lt;code&gt;write_fmt&lt;/code&gt; method; generally this comes from an implementation of either the &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;fmt::Write&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait. The macro returns whatever the &lt;code&gt;write_fmt&lt;/code&gt; method returns; commonly a &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;, or an &lt;a href=&quot;io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 매크로는 형식 문자열, 인수 목록 및 '작성기'를 허용합니다. 인수는 지정된 형식 문자열에 따라 형식이 지정되고 결과가 작성기에 전달됩니다. writer는 &lt;code&gt;write_fmt&lt;/code&gt; 메소드를 사용하는 모든 값이 될 수 있습니다 . 일반적으로 이것은 &lt;a href=&quot;fmt/trait.write&quot;&gt; &lt;code&gt;fmt::Write&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;io/trait.write&quot;&gt; &lt;code&gt;io::Write&lt;/code&gt; &lt;/a&gt; 특성 의 구현에서 비롯됩니다 . 매크로는 &lt;code&gt;write_fmt&lt;/code&gt; 메소드가 반환하는 모든 것을 반환합니다. 일반적으로 &lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e9c26f6e16b6bec90033e045df684b9983904c03" translate="yes" xml:space="preserve">
          <source>This macro accepts a format string, a list of arguments, and a 'writer'. Arguments will be formatted according to the specified format string and the result will be passed to the writer. The writer may be any value with a &lt;code&gt;write_fmt&lt;/code&gt; method; generally this comes from an implementation of either the &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;std::fmt::Write&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;io/trait.write&quot;&gt;&lt;code&gt;std::io::Write&lt;/code&gt;&lt;/a&gt; trait. The macro returns whatever the &lt;code&gt;write_fmt&lt;/code&gt; method returns; commonly a &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;std::fmt::Result&lt;/code&gt;&lt;/a&gt;, or an &lt;a href=&quot;io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 매크로는 형식 문자열, 인수 목록 및 '작성자'를 허용합니다. 인수는 지정된 형식 문자열에 따라 형식이 지정되고 결과는 작성기에 전달됩니다. 기록기는 &lt;code&gt;write_fmt&lt;/code&gt; 메소드를 사용하는 임의의 값일 수 있습니다 . 일반적으로 이것은 &lt;a href=&quot;fmt/trait.write&quot;&gt; &lt;code&gt;std::fmt::Write&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;io/trait.write&quot;&gt; &lt;code&gt;std::io::Write&lt;/code&gt; &lt;/a&gt; 특성 의 구현에서 비롯됩니다 . 매크로는 &lt;code&gt;write_fmt&lt;/code&gt; 메소드가 리턴하는 모든 것을 리턴합니다. 일반적으로 &lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;std::fmt::Result&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5250c44d93ce30f02a5f809915ffe3743184cf00" translate="yes" xml:space="preserve">
          <source>This macro bakes in propagation of &lt;a href=&quot;enum.poll#variant.Pending&quot;&gt;&lt;code&gt;Pending&lt;/code&gt;&lt;/a&gt; signals by returning early.</source>
          <target state="translated">이 매크로는 일찍 반환 하여 &lt;a href=&quot;enum.poll#variant.Pending&quot;&gt; &lt;code&gt;Pending&lt;/code&gt; &lt;/a&gt; 신호의 전파를 베이크 합니다.</target>
        </trans-unit>
        <trans-unit id="80d761ee9febd1152f2043eb4792d1bde7232938" translate="yes" xml:space="preserve">
          <source>This macro bakes in propagation of &lt;code&gt;Pending&lt;/code&gt; signals by returning early.</source>
          <target state="translated">이 매크로는 일찍 반환 하여 &lt;code&gt;Pending&lt;/code&gt; 신호의 전파를 베이크 합니다.</target>
        </trans-unit>
        <trans-unit id="9104464c61f2440f3d22798d14bf9b51373598ab" translate="yes" xml:space="preserve">
          <source>This macro functions by taking a formatting string literal containing &lt;code&gt;{}&lt;/code&gt; for each additional argument passed. &lt;code&gt;format_args!&lt;/code&gt; prepares the additional parameters to ensure the output can be interpreted as a string and canonicalizes the arguments into a single type. Any value that implements the &lt;a href=&quot;fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait can be passed to &lt;code&gt;format_args!&lt;/code&gt;, as can any &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; implementation be passed to a &lt;code&gt;{:?}&lt;/code&gt; within the formatting string.</source>
          <target state="translated">이 매크로 는 전달 된 각 추가 인수에 대해 &lt;code&gt;{}&lt;/code&gt; 를 포함하는 형식화 문자열 리터럴을 사용하여 작동합니다 . &lt;code&gt;format_args!&lt;/code&gt; 출력이 문자열로 해석 될 수 있도록 추가 매개 변수를 준비하고 인수를 단일 유형으로 정규화합니다. &lt;a href=&quot;fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; 특성 을 구현하는 모든 값 을 &lt;code&gt;format_args!&lt;/code&gt; 전달할 수 있습니다 ! 형식화 문자열 내에서 모든 &lt;a href=&quot;fmt/trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt; 구현을 &lt;code&gt;{:?}&lt;/code&gt; 에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0f46ebdcffb6d5939dcac636e4ba0ac8074178d" translate="yes" xml:space="preserve">
          <source>This macro has a second form, where a custom panic message can be provided with or without arguments for formatting. See &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for syntax for this form.</source>
          <target state="translated">이 매크로는 두 번째 형식으로, 사용자 정의 패닉 메시지를 형식화를위한 인수와 함께 또는 인수없이 제공 할 수 있습니다. 이 양식의 구문 은 &lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1cb7c87fdbeb8a27a8d17493d87d56c13827aded" translate="yes" xml:space="preserve">
          <source>This macro has a second form, where a custom panic message can be provided with or without arguments for formatting. See &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for syntax for this form.</source>
          <target state="translated">이 매크로에는 두 번째 형식이 있습니다. 여기서 사용자 지정 패닉 메시지는 형식 지정 인수를 포함하거나 포함하지 않고 제공 할 수 있습니다. 이 양식의 구문 은 &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b5986245d717af402afebe47105d05cdf22c051" translate="yes" xml:space="preserve">
          <source>This macro is provided in the standard library and will detect at runtime whether the specified CPU feature is detected. This does &lt;strong&gt;not&lt;/strong&gt; resolve at compile time unless the specified feature is already enabled for the entire crate. Runtime detection currently relies mostly on the &lt;code&gt;cpuid&lt;/code&gt; instruction.</source>
          <target state="translated">이 매크로는 표준 라이브러리에 제공되며 지정된 CPU 기능이 감지되는지 런타임에 감지합니다. 지정된 기능이 전체 상자에서 이미 활성화되어 있지 않으면 컴파일 타임에 해결 되지 &lt;strong&gt;않습니다&lt;/strong&gt; . 런타임 감지는 현재 대부분 &lt;code&gt;cpuid&lt;/code&gt; 명령어 에 의존 합니다.</target>
        </trans-unit>
        <trans-unit id="9c76b02a9e85e30ad24e030882216f3064330d6d" translate="yes" xml:space="preserve">
          <source>This macro is the perfect way to assert conditions in example code and in tests. &lt;code&gt;panic!&lt;/code&gt; is closely tied with the &lt;code&gt;unwrap&lt;/code&gt; method of both &lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; enums. Both implementations call &lt;code&gt;panic!&lt;/code&gt; when they are set to &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; variants.</source>
          <target state="translated">이 매크로는 예제 코드와 테스트에서 조건을 주장하는 완벽한 방법입니다. &lt;code&gt;panic!&lt;/code&gt; &lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 열거 형 의 &lt;code&gt;unwrap&lt;/code&gt; 메서드 와 밀접하게 연결되어 있습니다. 두 구현 모두 &lt;code&gt;panic!&lt;/code&gt; 호출합니다 ! &lt;a href=&quot;option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 변형으로 설정된 경우 .</target>
        </trans-unit>
        <trans-unit id="80d199c9b2bbee396aca26a7f3417fd4e87ff814" translate="yes" xml:space="preserve">
          <source>This macro is the perfect way to assert conditions in example code and in tests. &lt;code&gt;panic!&lt;/code&gt; is closely tied with the &lt;code&gt;unwrap&lt;/code&gt; method of both &lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; enums. Both implementations call &lt;code&gt;panic!&lt;/code&gt; when they are set to None or Err variants.</source>
          <target state="translated">이 매크로는 예제 코드와 테스트에서 조건을 확인하는 완벽한 방법입니다. &lt;code&gt;panic!&lt;/code&gt; &lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 열거 형 의 &lt;code&gt;unwrap&lt;/code&gt; 메소드 와 밀접하게 연결되어 있습니다. 두 가지 구현 모두 &lt;code&gt;panic!&lt;/code&gt; None 또는 Err 변형으로 설정된 경우</target>
        </trans-unit>
        <trans-unit id="d0ebce932633e1b0cd797b4ddeb6ac5a11d9e6f7" translate="yes" xml:space="preserve">
          <source>This macro is used to inject panic into a Rust thread, causing the thread to panic entirely. Each thread's panic can be reaped as the &lt;a href=&quot;boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;any/trait.any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; type, and the single-argument form of the &lt;code&gt;panic!&lt;/code&gt; macro will be the value which is transmitted.</source>
          <target state="translated">이 매크로는 Rust 스레드에 패닉을 주입하여 스레드를 완전히 패닉 상태로 만드는 데 사용됩니다. 각 스레드의 패닉은 &lt;a href=&quot;boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;any/trait.any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 유형과 &lt;code&gt;panic!&lt;/code&gt; 의 단일 인수 형식으로 거둘 수 있습니다! 매크로는 전송되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="cf0774da3df0d29e08106daf482fff334bcea403" translate="yes" xml:space="preserve">
          <source>This macro is used to inject panic into a Rust thread, causing the thread to panic entirely. Each thread's panic can be reaped as the &lt;code&gt;Box&amp;lt;Any&amp;gt;&lt;/code&gt; type, and the single-argument form of the &lt;code&gt;panic!&lt;/code&gt; macro will be the value which is transmitted.</source>
          <target state="translated">이 매크로는 패닉을 Rust 스레드에 주입하여 스레드가 완전히 패닉되도록하는 데 사용됩니다. 각 스레드의 패닉은 &lt;code&gt;Box&amp;lt;Any&amp;gt;&lt;/code&gt; 유형과 단일 인수 형태의 &lt;code&gt;panic!&lt;/code&gt; 매크로는 전송되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="e7802aaf0db102edbab92f402c03063ff3b73be4" translate="yes" xml:space="preserve">
          <source>This macro only takes one argument which is a string literal of the feature being tested for. The feature names supported are the lowercase versions of the ones defined by Intel in &lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide&quot;&gt;their documentation&lt;/a&gt;.</source>
          <target state="translated">이 매크로는 테스트 할 기능의 문자열 리터럴 인 하나의 인수 만 사용합니다. 지원되는 기능 이름은 &lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide&quot;&gt;설명서&lt;/a&gt; 에서 인텔이 정의한 소문자 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="4bd8a54709ee381edf667e1b754c2dd4776028dd" translate="yes" xml:space="preserve">
          <source>This macro produces a value of type &lt;a href=&quot;fmt/struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This value can be passed to the macros within &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for performing useful redirection. All other formatting macros (&lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;, etc) are proxied through this one. &lt;code&gt;format_args!&lt;/code&gt;, unlike its derived macros, avoids heap allocations.</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;fmt/struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt; 유형의 값을 생성합니다 . 이 값은 유용한 리디렉션을 수행하기 위해 &lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; 내의 매크로에 전달 될 수 있습니다 . 다른 모든 형식의 매크로 ( &lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt; 등)이 하나를 통해 프락시된다. &lt;code&gt;format_args!&lt;/code&gt; 파생 매크로와 달리 힙 할당을 피합니다.</target>
        </trans-unit>
        <trans-unit id="209265c4eb72c5eca06cd095d36df90048938379" translate="yes" xml:space="preserve">
          <source>This macro produces a value of type &lt;a href=&quot;fmt/struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This value can be passed to the macros within &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for performing useful redirection. All other formatting macros (&lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;, etc) are proxied through this one. &lt;code&gt;format_args!&lt;/code&gt;, unlike its derived macros, avoids heap allocations.</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;fmt/struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt; 유형의 값을 생성합니다 . 이 값은 유용한 리디렉션을 수행하기 위해 &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; 내의 매크로에 전달 될 수 있습니다 . 다른 모든 형식의 매크로 ( &lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt; 등)이 하나를 통해 프락시된다. &lt;code&gt;format_args!&lt;/code&gt; 는 파생 된 매크로와 달리 힙 할당을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="1d449e18cd48bf8c444aeabc9c847abf69b5ab8d" translate="yes" xml:space="preserve">
          <source>This macro should be used when a crate uses a conditional compilation strategy to provide better error messages for erroneous conditions. It's the compiler-level form of &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;, but emits an error during &lt;em&gt;compilation&lt;/em&gt; rather than at &lt;em&gt;runtime&lt;/em&gt;.</source>
          <target state="translated">이 매크로는 크레이트가 잘못된 조건에 대해 더 나은 오류 메시지를 제공하기 위해 조건부 컴파일 전략을 사용할 때 사용해야합니다. 이것은 컴파일러 수준의 &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;그러나 &lt;em&gt;런타임이&lt;/em&gt; 아닌 &lt;em&gt;컴파일&lt;/em&gt; 중에 오류가 발생 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d49c196cc9f23d7594245f1cc87a1f518746592e" translate="yes" xml:space="preserve">
          <source>This macro should be used when a crate uses a conditional compilation strategy to provide better error messages for erroneous conditions. It's the compiler-level form of &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;, which emits an error at &lt;em&gt;runtime&lt;/em&gt;, rather than during compilation.</source>
          <target state="translated">상자에서 조건부 컴파일 전략을 사용하여 잘못된 조건에 대해 더 나은 오류 메시지를 제공 할 때이 매크로를 사용해야합니다. 컴파일러 수준의 &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;컴파일 중이 아닌 &lt;em&gt;런타임시&lt;/em&gt; 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="68d15cf83524f34dd8d8be7a2a8e7bed6740e783" translate="yes" xml:space="preserve">
          <source>This macro supports the same names that &lt;code&gt;#[target_feature]&lt;/code&gt; supports. Unlike &lt;code&gt;#[target_feature]&lt;/code&gt;, however, this macro does not support names separated with a comma. Instead testing for multiple features must be done through separate macro invocations for now.</source>
          <target state="translated">이 매크로는 &lt;code&gt;#[target_feature]&lt;/code&gt; 가 지원하는 것과 동일한 이름을 지원합니다. 그러나 &lt;code&gt;#[target_feature]&lt;/code&gt; 와 달리이 매크로는 쉼표로 구분 된 이름을 지원하지 않습니다. 대신 여러 기능에 대한 테스트는 현재 별도의 매크로 호출을 통해 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="fefc6add454f34259443790785050840eebbeb57" translate="yes" xml:space="preserve">
          <source>This macro takes any number of comma-separated identifiers, and concatenates them all into one, yielding an expression which is a new identifier. Note that hygiene makes it such that this macro cannot capture local variables. Also, as a general rule, macros are only allowed in item, statement or expression position. That means while you may use this macro for referring to existing variables, functions or modules etc, you cannot define a new one with it.</source>
          <target state="translated">이 매크로는 임의의 수의 쉼표로 구분 된 식별자를 가져 와서 모두 하나로 결합하여 새로운 식별자 인 표현식을 생성합니다. 위생은이 매크로가 지역 변수를 캡처 할 수 없도록합니다. 또한 일반적으로 매크로는 항목, 명령문 또는 표현식 위치에서만 허용됩니다. 즉, 기존 변수, 함수 또는 모듈 등을 참조하기 위해이 매크로를 사용할 수 있지만 새 변수를 정의 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="a79ce9bb3fa69012483f80e7a1a2541065700d68" translate="yes" xml:space="preserve">
          <source>This macro takes any number of comma-separated literals, yielding an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which represents all of the literals concatenated left-to-right.</source>
          <target state="translated">이 매크로는 임의의 수의 쉼표로 구분 된 리터럴을 사용하여 왼쪽에서 오른쪽으로 연결된 모든 리터럴을 나타내는 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 유형의 표현식을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="79fc3c2904becf8aa3c820c279472de0fe3a1f68" translate="yes" xml:space="preserve">
          <source>This macro will expand to the value of the named environment variable at compile time, yielding an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.</source>
          <target state="translated">이 매크로는 컴파일 타임에 명명 된 환경 변수의 값으로 확장되어 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 유형의 표현식을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="95e973b1ebc33842358cee19e0dba22c8a81f994" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static [u8; N]&lt;/code&gt; which is the contents of the file.</source>
          <target state="translated">이 매크로는 &lt;code&gt;&amp;amp;'static [u8; N]&lt;/code&gt; 파일의 내용입니다.</target>
        </trans-unit>
        <trans-unit id="9cdb0bb59a3aefac2ea084695df47352b8cc7f18" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which is the contents of the file.</source>
          <target state="translated">이 매크로는 파일의 내용 인 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 유형의 표현식을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="8d3907f6b0e9a61a4bdb55de9a362a92915237c3" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which is the stringification of all the tokens passed to the macro. No restrictions are placed on the syntax of the macro invocation itself.</source>
          <target state="translated">이 매크로는 매크로에 전달 된 모든 토큰의 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 유형의 표현식을 생성합니다 . 매크로 호출 자체의 구문에는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="96f8e740156b1fe8242bb1857eb516b34c772e7e" translate="yes" xml:space="preserve">
          <source>This macro would parse the SQL statement inside it and check that it&amp;rsquo;s syntactically correct, which is much more complex processing than a &lt;code&gt;macro_rules!&lt;/code&gt; macro can do. The &lt;code&gt;sql!&lt;/code&gt; macro would be defined like this:</source>
          <target state="translated">이 매크로는 그 안에있는 SQL 문을 구문 분석하고 구문 상 올바른지 확인합니다. 이는 &lt;code&gt;macro_rules!&lt;/code&gt; 보다 훨씬 복잡한 처리입니다 ! 매크로가 할 수 있습니다. &lt;code&gt;sql!&lt;/code&gt; 매크로는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f58f7dcc462ef7387fceff17b5cae04e3cbcbf04" translate="yes" xml:space="preserve">
          <source>This makes the trait implemented on all types in the scope. So if you try to implement it on another one after that, the implementations will conflict. Example:</source>
          <target state="translated">이를 통해 범위의 모든 유형에 특성이 구현됩니다. 따라서 그 후에 다른 것을 구현하려고하면 구현이 충돌합니다. 예:</target>
        </trans-unit>
        <trans-unit id="024ad2ae59c4dd5f5ee7d7c019680237dc88183b" translate="yes" xml:space="preserve">
          <source>This may be allowed at some point in the future, but the implementation is not yet complete. See the tracking issues for &lt;a href=&quot;https://github.com/rust-lang/rust/issues/69431&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/rust-lang/rust/issues/74935&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;const fn&lt;/code&gt;, and (to support &lt;code&gt;for&lt;/code&gt; loops in &lt;code&gt;const fn&lt;/code&gt;) the tracking issues for &lt;a href=&quot;https://github.com/rust-lang/rust/issues/67792&quot;&gt;&lt;code&gt;impl const Trait for Ty&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/rust-lang/rust/issues/57349&quot;&gt;&lt;code&gt;&amp;amp;mut T&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;const fn&lt;/code&gt;.</source>
          <target state="translated">이것은 미래의 어느 시점에서 허용 될 수 있지만 구현이 아직 완료되지 않았습니다. &lt;a href=&quot;https://github.com/rust-lang/rust/issues/69431&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/74935&quot;&gt; &lt;code&gt;?&lt;/code&gt; 에&lt;/a&gt; 대한 추적 문제를 참조하십시오 . 에서 &lt;code&gt;const fn&lt;/code&gt; , 및 (지원 &lt;code&gt;for&lt;/code&gt; 에서 루프 &lt;code&gt;const fn&lt;/code&gt; 추적에 대한 문제) &lt;a href=&quot;https://github.com/rust-lang/rust/issues/67792&quot;&gt; &lt;code&gt;impl const Trait for Ty&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/57349&quot;&gt; &lt;code&gt;&amp;amp;mut T&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;const fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dafc2f14b4f56d8dc5d075ff34c826a36e387880" translate="yes" xml:space="preserve">
          <source>This may not actually increase the capacity:</source>
          <target state="translated">실제로 용량을 늘리지 못할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="af903b6fc00acf0d280f6c29b1e0e8d3aeb94082" translate="yes" xml:space="preserve">
          <source>This may only be called by &lt;code&gt;Read&lt;/code&gt;ers which guarantee that they will not read from buffers passed to &lt;code&gt;Read&lt;/code&gt; methods, and that the return value of the method accurately reflects the number of bytes that have been written to the head of the buffer.</source>
          <target state="translated">이은으로 호출 할 수 &lt;code&gt;Read&lt;/code&gt; 가 전달 버퍼에서 읽을 것이라는 점을 보증 ERS &lt;code&gt;Read&lt;/code&gt; 방법 및 메소드의 반환 값은 정확하게 버퍼의 머리에 기록 된 바이트 수를 반영.</target>
        </trans-unit>
        <trans-unit id="14a8a7c42cf833272747226b7446d6fe81b3ec47" translate="yes" xml:space="preserve">
          <source>This may require additional type hints in the function body.</source>
          <target state="translated">함수 본문에 추가 유형 힌트가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac8b21b0f73b2747acf512efef8390bcec866c71" translate="yes" xml:space="preserve">
          <source>This means iterator adapters can rely on the source not changing during iteration but they cannot rely on it in their Drop implementations.</source>
          <target state="translated">즉, 반복기 어댑터는 반복 중에 변경되지 않는 소스에 의존 할 수 있지만 Drop 구현에서는이를 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b07ba109060bf875c034ba50fdb9ffdabfec4929" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;&amp;lt;T: 'a + ?Sized&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;T: 'b + Sized&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; are all permitted.</source>
          <target state="translated">이것은 &lt;code&gt;&amp;lt;T: 'a + ?Sized&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;T: 'b + Sized&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 가 모두 허용됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7a8c1c98c2b07fe7a77662bf8cf1e31aa75a3d05" translate="yes" xml:space="preserve">
          <source>This means that any external crate referencing &lt;code&gt;implementation::api::f&lt;/code&gt; would receive a privacy violation, while the path &lt;code&gt;api::f&lt;/code&gt; would be allowed.</source>
          <target state="translated">즉, 외부 상자 참조 &lt;code&gt;implementation::api::f&lt;/code&gt; 는 개인 정보 보호 위반을 수신하지만 경로 &lt;code&gt;api::f&lt;/code&gt; 는 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="be2e4dfa333e1a56bbed2f9ca40e5f02293eda70" translate="yes" xml:space="preserve">
          <source>This means that perhaps some of the preceding patterns are too general, this one is too specific or the ordering is incorrect.</source>
          <target state="translated">이것은 아마도 앞의 패턴 중 일부가 너무 일반적이거나,이 패턴이 너무 구체적이거나 순서가 잘못되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3a6a30f5c049c4edc23b7fd66710a9051982b10a" translate="yes" xml:space="preserve">
          <source>This means that someone can specify such a function:</source>
          <target state="translated">이것은 누군가가 그러한 기능을 지정할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="cb26a69e23fbbf1b07ba0d9979e852887a91fd3d" translate="yes" xml:space="preserve">
          <source>This means that the contents of the first string above &lt;em&gt;will&lt;/em&gt; fit into a &lt;code&gt;char&lt;/code&gt; while the contents of the second string &lt;em&gt;will not&lt;/em&gt;. Trying to create a &lt;code&gt;char&lt;/code&gt; literal with the contents of the second string gives an error:</source>
          <target state="translated">제 문자열의 내용이 상술 한 것을 의미 &lt;em&gt;한다&lt;/em&gt; (A) 내로 맞 &lt;code&gt;char&lt;/code&gt; 동안 제 문자열의 내용은 &lt;em&gt;하지 않을 것이다&lt;/em&gt; . 두 번째 문자열의 내용으로 &lt;code&gt;char&lt;/code&gt; 리터럴 을 만들려고 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f9131c9dc6b963db63fbff2769fe5ceda6bacdcc" translate="yes" xml:space="preserve">
          <source>This means that the operands don't have to be moved out of.</source>
          <target state="translated">이것은 피연산자가 이동할 필요가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b2ca51239acb100a6dd5efb03e14c814a0a94286" translate="yes" xml:space="preserve">
          <source>This means that when &lt;code&gt;s&lt;/code&gt; reaches the end of &lt;code&gt;demo&lt;/code&gt;, its destructor gets exclusive access to its &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrowed string data. allowing another borrow of that string data (&lt;code&gt;p&lt;/code&gt;), to exist across the drop of &lt;code&gt;s&lt;/code&gt; would be a violation of the principle that &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrows have exclusive, unaliased access to their referenced data.</source>
          <target state="translated">이것은 &lt;code&gt;s&lt;/code&gt; 가 &lt;code&gt;demo&lt;/code&gt; 의 끝에 도달하면 소멸자는 &lt;code&gt;&amp;amp;mut&lt;/code&gt; borrowed 문자열 데이터에 독점적으로 액세스 할 수 있음을 의미합니다. 해당 문자열 데이터 ( &lt;code&gt;p&lt;/code&gt; ) 의 다른 차용이 &lt;code&gt;s&lt;/code&gt; 의 드롭에 걸쳐 존재 하게하는 것은 &lt;code&gt;&amp;amp;mut&lt;/code&gt; borrows가 참조 된 데이터에 대한 독점적이고 별명으로 액세스 할 수 없다는 원칙을 위반하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="9b50029fc42e472fbad4bc857af78f98f36c748f" translate="yes" xml:space="preserve">
          <source>This means that, for example, the padding byte in &lt;code&gt;(u8, u16)&lt;/code&gt; is not necessarily zeroed.</source>
          <target state="translated">이는 예를 들어 &lt;code&gt;(u8, u16)&lt;/code&gt; 의 패딩 바이트 가 반드시 0이 될 필요는 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="382ebf724244bccd694c658a6e7769ce6b7c071d" translate="yes" xml:space="preserve">
          <source>This means, that in addition to &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;a != b&lt;/code&gt; being strict inverses, the equality must be (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="translated">즉, &lt;code&gt;a == b&lt;/code&gt; 및 &lt;code&gt;a != b&lt;/code&gt; 외에 엄격한 역수를 갖는 등호 (모든 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; ) 는 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="30330510a00e9290fc18b35d20dbe32f6afe0cd7" translate="yes" xml:space="preserve">
          <source>This method always returns &lt;code&gt;false&lt;/code&gt; after iteration has finished:</source>
          <target state="translated">이 메서드는 반복이 완료된 후 항상 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f2cb7c4ca14739fd7d110ae41517acd9e412a5c2" translate="yes" xml:space="preserve">
          <source>This method by itself is safe, but using it correctly requires extra care. Another thread can change the strong count at any time, including potentially between calling this method and acting on the result.</source>
          <target state="translated">이 방법 자체는 안전하지만 올바르게 사용하려면 특별한주의가 필요합니다. 다른 스레드는이 메소드 호출과 결과 수행 사이를 포함하여 언제든지 강력한 수를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="949f62fcaa7fc2070951a1bf81357a1eb29cd126" translate="yes" xml:space="preserve">
          <source>This method by itself is safe, but using it correctly requires extra care. Another thread can change the weak count at any time, including potentially between calling this method and acting on the result.</source>
          <target state="translated">이 방법 자체는 안전하지만 올바르게 사용하려면 특별한주의가 필요합니다. 다른 스레드는이 메소드 호출과 결과 수행 사이를 포함하여 언제든지 약한 수를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3282baf6619178b04f6e093d59df95e6b50b4f0b" translate="yes" xml:space="preserve">
          <source>This method can be used for string data that is &lt;em&gt;terminated&lt;/em&gt;, rather than &lt;em&gt;separated&lt;/em&gt; by a pattern.</source>
          <target state="translated">이 메소드는 패턴으로 &lt;em&gt;구분&lt;/em&gt; 되지 않고 &lt;em&gt;종료&lt;/em&gt; 되는 문자열 데이터에 사용할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3369ccac8ace2a653ec652b1d0a5f9f1bd24f346" translate="yes" xml:space="preserve">
          <source>This method can be used to reverse a comparison:</source>
          <target state="translated">이 방법을 사용하면 비교를 반대로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f13cbe122409bed70a7bfa8652dd2b252fa340b" translate="yes" xml:space="preserve">
          <source>This method can be useful for situations in which the vector is serving as a buffer for other code, particularly over FFI:</source>
          <target state="translated">이 방법은 벡터가 다른 코드, 특히 FFI를위한 버퍼 역할을하는 상황에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ce975c1398d44efbe8c10a5c85f55c0075a45068" translate="yes" xml:space="preserve">
          <source>This method can only succeed if the entire byte slice was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="translated">이 방법은 전체 바이트 슬라이스가 성공적으로 기록 된 경우에만 성공할 수 있으며 모든 데이터가 기록되거나 오류가 발생할 때까지 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e42e806090a8aa6caab77166483a1eda09b5296d" translate="yes" xml:space="preserve">
          <source>This method can only succeed if the entire string slice was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="translated">이 메서드는 전체 문자열 조각이 성공적으로 기록 된 경우에만 성공할 수 있으며 모든 데이터가 기록되거나 오류가 발생할 때까지이 메서드는 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1f7d3cdb0bfa41dd91aa3d1bf03416a16ee48f3" translate="yes" xml:space="preserve">
          <source>This method differs from &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; by returning immediately if the channel's buffer is full or no receiver is waiting to acquire some data. Compared with &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt;, this function has two failure cases instead of one (one for disconnection, one for a full buffer).</source>
          <target state="translated">이 방법은 채널의 버퍼가 가득 찼거나 수신자가 데이터를 수집하기 위해 대기하지 않는 경우 즉시 리턴 하여 &lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 과 다릅니다 . &lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 와 비교할 때이 함수는 하나 대신 두 개의 실패 사례가 있습니다 (하나는 연결 해제, 하나는 전체 버퍼).</target>
        </trans-unit>
        <trans-unit id="028002d34f3fafd7bc54cd77bcaa912497a3b074" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; pass ownership of the raw file descriptor to the caller. The descriptor is only guaranteed to be valid while the original object has not yet been destroyed.</source>
          <target state="translated">이 메소드는 원시 파일 디스크립터의 소유권을 호출자에게 전달 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 디스크립터는 원래 오브젝트가 아직 파괴되지 않은 동안에 만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="5fd9fa51612a49edd496cd80117e23b29a509eb6" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by microseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one million).</source>
          <target state="translated">이 메소드는 마이크로 초로 표시 될 때 지속 시간의 길이를 리턴 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 반환 된 숫자는 항상 초의 소수 부분을 나타냅니다 (즉, 백만 미만).</target>
        </trans-unit>
        <trans-unit id="d3a3c1cf0cc150bd1c72971205d2190e708b8d2b" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by milliseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one thousand).</source>
          <target state="translated">이 메소드는 밀리 초로 표시 될 때 지속 시간의 길이를 리턴 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 반환 된 숫자는 항상 초의 소수 부분을 나타냅니다 (즉, 1000 미만).</target>
        </trans-unit>
        <trans-unit id="e8135547d5a3a3a5006fe1cbd5d76d770ff2a7a9" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by nanoseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one billion).</source>
          <target state="translated">이 메소드는 나노초로 표시 될 때 지속 시간의 길이를 리턴 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 반환 된 숫자는 항상 초의 소수 부분을 나타냅니다 (즉, 10 억 미만).</target>
        </trans-unit>
        <trans-unit id="ac2e63056cc906cac74875b70f6f9009af31f73d" translate="yes" xml:space="preserve">
          <source>This method does not allocate and does not change the order of the inserted elements. As it returns a mutable slice, this can be used to sort a deque.</source>
          <target state="translated">이 메서드는 삽입 된 요소의 순서를 할당하거나 변경하지 않습니다. 가변 슬라이스를 반환하므로 deque를 정렬하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdc4e2ef2ed35366fa011a172b72477b2d16bbd4" translate="yes" xml:space="preserve">
          <source>This method does not allocate and does not change the order of the inserted elements. As it returns a mutable slice, this can be used to sort or binary search a deque.</source>
          <target state="translated">이 메서드는 삽입 된 요소의 순서를 할당하거나 변경하지 않습니다. 가변 슬라이스를 반환하므로 데크를 정렬하거나 이진 검색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16f6f5d172fff1f1f8e9b8bb728e19c58e51b4b5" translate="yes" xml:space="preserve">
          <source>This method doesn't produce a value, but the write may fail. It's crucial to handle the error case, and &lt;em&gt;not&lt;/em&gt; write something like this:</source>
          <target state="translated">이 방법은 값을 생성하지 않지만 쓰기가 실패 할 수 있습니다. 오류 사례를 처리하고 다음과 같이 쓰지 &lt;em&gt;않는&lt;/em&gt; 것이 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="0b024448d5d7228119631ad22266fba4066f9577" translate="yes" xml:space="preserve">
          <source>This method has a default implementation using &lt;a href=&quot;trait.exactsizeiterator#method.len&quot;&gt;&lt;code&gt;ExactSizeIterator::len()&lt;/code&gt;&lt;/a&gt;, so you don't need to implement it yourself.</source>
          <target state="translated">이 메서드에는 &lt;a href=&quot;trait.exactsizeiterator#method.len&quot;&gt; &lt;code&gt;ExactSizeIterator::len()&lt;/code&gt; &lt;/a&gt; 사용하는 기본 구현이 있으므로 직접 구현할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="803e98a2b6e5f0d6a98c75881fdb55c1597f80f0" translate="yes" xml:space="preserve">
          <source>This method has a default implementation using &lt;code&gt;self.len()&lt;/code&gt;, so you don't need to implement it yourself.</source>
          <target state="translated">이 메소드에는 &lt;code&gt;self.len()&lt;/code&gt; 사용하는 기본 구현이 있으므로 직접 구현할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="02fc3c4c098f9a864e6c45270c0a8ae6ffc408ef" translate="yes" xml:space="preserve">
          <source>This method has a default implementation, so you usually should not implement it directly. However, if you can provide a more efficient implementation, you can do so. See the &lt;a href=&quot;trait.exactsizeiterator&quot;&gt;trait-level&lt;/a&gt; docs for an example.</source>
          <target state="translated">이 메소드에는 기본 구현이 있으므로 일반적으로 직접 구현하지 않아야합니다. 그러나보다 효율적인 구현을 제공 할 수 있다면 그렇게 할 수 있습니다. 예를 들어 &lt;a href=&quot;trait.exactsizeiterator&quot;&gt;특성 수준&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="89f3649aa28c1d3c90be74ebfb70d517cce77458" translate="yes" xml:space="preserve">
          <source>This method has no purpose when either input element &lt;code&gt;T&lt;/code&gt; or output element &lt;code&gt;U&lt;/code&gt; are zero-sized and will return the original slice without splitting anything.</source>
          <target state="translated">이 방법은 입력 요소 &lt;code&gt;T&lt;/code&gt; 또는 출력 요소 &lt;code&gt;U&lt;/code&gt; 가 크기가 0 인 경우 아무 목적도 없으며 아무 것도 나누지 않고 원래 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08ef0643ebf0dc48a599dc8d5b289675edb9e0a3" translate="yes" xml:space="preserve">
          <source>This method is called implicitly when the value goes out of scope, and cannot be called explicitly (this is compiler error &lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040&lt;/a&gt;). However, the &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt; function in the prelude can be used to call the argument's &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="translated">이 메서드는 값이 범위를 벗어날 때 암시 적으로 호출되며 명시 적으로 호출 할 수 없습니다 (이는 컴파일러 오류 &lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040&lt;/a&gt; ). 그러나 전주곡 의 &lt;a href=&quot;../mem/fn.drop&quot;&gt; &lt;code&gt;mem::drop&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 인수의 &lt;code&gt;Drop&lt;/code&gt; 구현 을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37d2a8db1a00abc88d21d10b6113bf279aaebd51" translate="yes" xml:space="preserve">
          <source>This method is called implicitly when the value goes out of scope, and cannot be called explicitly (this is compiler error &lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040&lt;/a&gt;). However, the &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;std::mem::drop&lt;/code&gt;&lt;/a&gt; function in the prelude can be used to call the argument's &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="translated">이 메소드는 값이 범위를 벗어날 때 내재적으로 호출되며 명시 적으로 호출 할 수 없습니다 (이는 컴파일러 오류 &lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040입니다&lt;/a&gt; ). 그러나, prelude 의 &lt;a href=&quot;../mem/fn.drop&quot;&gt; &lt;code&gt;std::mem::drop&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 인수의 &lt;code&gt;Drop&lt;/code&gt; 구현 을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b2c9d3aaaa76ea8e330a8973b644085bc25e3bb" translate="yes" xml:space="preserve">
          <source>This method is carefully constructed to avoid allocation. It will consume the error, moving out the bytes, so that a copy of the bytes does not need to be made.</source>
          <target state="translated">이 방법은 할당을 피하기 위해 신중하게 구성됩니다. 바이트를 옮길 때 오류가 발생하여 바이트 사본을 만들 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ef9d0891851c4c2229a94b62e2e2cf59a2fd15db" translate="yes" xml:space="preserve">
          <source>This method is deprecated in favor of the identically-named inherent methods on &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;[u8]&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">이 메서드는 &lt;code&gt;u8&lt;/code&gt; , &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;[u8]&lt;/code&gt; 및 &lt;code&gt;str&lt;/code&gt; 에서 동일한 이름의 고유 메서드를 사용하기 위해 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="84886aa1dad1934a5c9bdd981667f36e45fab018" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; except that no runtime assertion is made that &lt;code&gt;v&lt;/code&gt; contains no 0 bytes, and it requires an actual byte vector, not anything that can be converted to one with Into.</source>
          <target state="translated">이 방법은 &lt;code&gt;v&lt;/code&gt; 에 0 바이트가 포함되지 않는다는 런타임 어설 션이 없고 실제 바이트 벡터가 필요 하다는 점을 제외하고는 &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 와 동등합니다 . Into를 사용하여 변환 할 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="38f2c8e8e67faa398a8a8adc0a46e90cd363606b" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;CString::new&lt;/code&gt;&lt;/a&gt; except that no runtime assertion is made that &lt;code&gt;v&lt;/code&gt; contains no 0 bytes, and it requires an actual byte vector, not anything that can be converted to one with Into.</source>
          <target state="translated">이 메서드는 &lt;code&gt;v&lt;/code&gt; 에 0 바이트 가 없다는 런타임 어설 션이 없다는 점을 제외하고는 &lt;a href=&quot;struct.cstring#method.new&quot;&gt; &lt;code&gt;CString::new&lt;/code&gt; &lt;/a&gt; 동일 하며 Into를 사용하여 변환 할 수있는 것이 아니라 실제 바이트 벡터가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0358b021b2254c197a04c16c02e67b7c9901af56" translate="yes" xml:space="preserve">
          <source>This method is essentially a &lt;code&gt;transmute&lt;/code&gt; with respect to the elements in the returned middle slice, so all the usual caveats pertaining to &lt;code&gt;transmute::&amp;lt;T, U&amp;gt;&lt;/code&gt; also apply here.</source>
          <target state="translated">이 방법은 반환 된 중간 슬라이스의 요소와 관련하여 본질적으로 &lt;code&gt;transmute&lt;/code&gt; 이므로 변환식과 관련된 모든 일반적인주의 사항 &lt;code&gt;transmute::&amp;lt;T, U&amp;gt;&lt;/code&gt; 도 여기에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dd229ccab2f3fea46c41c098065dd891d877a2e6" translate="yes" xml:space="preserve">
          <source>This method is identical to &lt;a href=&quot;struct.builder#method.spawn&quot;&gt;&lt;code&gt;thread::Builder::spawn&lt;/code&gt;&lt;/a&gt;, except for the relaxed lifetime bounds, which render it unsafe. For a more complete documentation see &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 편안한 수명 한계를 제외하고 &lt;a href=&quot;struct.builder#method.spawn&quot;&gt; &lt;code&gt;thread::Builder::spawn&lt;/code&gt; &lt;/a&gt; 과 동일하므로 안전하지 않습니다. 보다 완전한 문서는 &lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0bc2506b00444cfc62462ac1af4908c0bbe44456" translate="yes" xml:space="preserve">
          <source>This method is implemented using up to three seek operations. If this method returns successfully, the seek position is unchanged (i.e. the position before calling this method is the same as afterwards). However, if this method returns an error, the seek position is unspecified.</source>
          <target state="translated">이 방법은 최대 3 개의 탐색 작업을 사용하여 구현됩니다. 이 메소드가 성공적으로 리턴되면 탐색 위치는 변경되지 않습니다 (즉,이 메소드를 호출하기 전의 위치는 이후와 동일 함). 그러나이 메소드가 오류를 리턴하면 탐색 위치는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f531cfc3a2c409d73bd0f5c2e2364c282b1a69bd" translate="yes" xml:space="preserve">
          <source>This method is primarily intended for moving out values in drop. Instead of using &lt;a href=&quot;#method.drop&quot;&gt;&lt;code&gt;ManuallyDrop::drop&lt;/code&gt;&lt;/a&gt; to manually drop the value, you can use this method to take the value and use it however desired. &lt;code&gt;Drop&lt;/code&gt; will be invoked on the returned value following normal end-of-scope rules.</source>
          <target state="translated">이 방법은 주로 값을 떨어 뜨리기위한 것입니다. &lt;a href=&quot;#method.drop&quot;&gt; &lt;code&gt;ManuallyDrop::drop&lt;/code&gt; &lt;/a&gt; 을 사용 하여 값을 수동으로 삭제하는 대신 이 방법을 사용하여 값을 가져와 원하는대로 사용할 수 있습니다. 일반적인 범위 끝 규칙에 따라 반환 된 값에 대해 &lt;code&gt;Drop&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ff2d30c02e4e3426a2eb2e0e84eb302b53b0327c" translate="yes" xml:space="preserve">
          <source>This method is primarily intended for moving out values in drop. Instead of using &lt;a href=&quot;struct.manuallydrop#method.drop&quot;&gt;&lt;code&gt;ManuallyDrop::drop&lt;/code&gt;&lt;/a&gt; to manually drop the value, you can use this method to take the value and use it however desired.</source>
          <target state="translated">이 방법은 주로 값을 떨어 뜨리는 데 사용됩니다. &lt;a href=&quot;struct.manuallydrop#method.drop&quot;&gt; &lt;code&gt;ManuallyDrop::drop&lt;/code&gt; &lt;/a&gt; 을 사용 하여 값을 수동으로 삭제하는 대신 이 방법을 사용하여 값을 가져와 원하는대로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="923fe0c4f9dba0ad8dc8e37a00ed66b6a9da0759" translate="yes" xml:space="preserve">
          <source>This method is primarily used to interface with the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro, but it is rare that this should explicitly be called. The &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro should be favored to invoke this method instead.</source>
          <target state="translated">이 메소드는 주로 &lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt; 와 인터페이스하는 데 사용됩니다 ! 매크로, 그러나 명시 적으로 호출해야하는 경우는 거의 없습니다. &lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;대신이 메소드를 호출하기 위해 매크로를 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="80fc60d5306ac7d19519f64033eaf35397e48023" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;../../error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은 더 이상 사용되지 않습니다. &lt;a href=&quot;../../error/trait.error#method.description&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e4625fa8bf128959917fb79c2180bb0bb7de232" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;../error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은 더 이상 사용되지 않습니다. &lt;a href=&quot;../error/trait.error#method.description&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a9beb6c54e6c8b198cf2df220314195725bd7bb" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은 더 이상 사용되지 않습니다. &lt;a href=&quot;error/trait.error#method.description&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5490d12dcf25f9008acb9584a8ddf0c95e1664f2" translate="yes" xml:space="preserve">
          <source>This method is stable and usable, but it should be unsafe. To fix that, it got deprecated in favor of the unsafe &lt;a href=&quot;#tymethod.pre_exec&quot;&gt;&lt;code&gt;pre_exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 안정적이고 사용 가능하지만 안전하지 않아야합니다. 이 문제를 해결하기 위해 안전하지 않은 &lt;a href=&quot;#tymethod.pre_exec&quot;&gt; &lt;code&gt;pre_exec&lt;/code&gt; &lt;/a&gt; 를 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="6a040da9f6f49ab3965186c9b54eab70d6aecfa7" translate="yes" xml:space="preserve">
          <source>This method is stable and usable, but it should be unsafe. To fix that, it got deprecated in favor of the unsafe &lt;a href=&quot;trait.commandext#tymethod.pre_exec&quot;&gt;&lt;code&gt;pre_exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 안정적이고 사용할 수 있지만 안전하지 않습니다. 이 문제를 해결하기 위해 안전하지 않은 &lt;a href=&quot;trait.commandext#tymethod.pre_exec&quot;&gt; &lt;code&gt;pre_exec&lt;/code&gt; &lt;/a&gt; 대신 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="428465480a8425bf96628f818ad9aad9c7155318" translate="yes" xml:space="preserve">
          <source>This method is the const generic equivalent of &lt;a href=&quot;#method.chunks_exact&quot;&gt;&lt;code&gt;chunks_exact&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드는 &lt;a href=&quot;#method.chunks_exact&quot;&gt; &lt;code&gt;chunks_exact&lt;/code&gt; 에&lt;/a&gt; 해당하는 const 제네릭입니다 .</target>
        </trans-unit>
        <trans-unit id="d5d24cf3a26d22530ab9cc10e498dc43f87c776a" translate="yes" xml:space="preserve">
          <source>This method is the const generic equivalent of &lt;a href=&quot;#method.chunks_exact_mut&quot;&gt;&lt;code&gt;chunks_exact_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드는 &lt;a href=&quot;#method.chunks_exact_mut&quot;&gt; &lt;code&gt;chunks_exact_mut&lt;/code&gt; 에&lt;/a&gt; 해당하는 const 제네릭입니다 .</target>
        </trans-unit>
        <trans-unit id="881a668b22b8af1fbfcb4abff65037dd8a73fd44" translate="yes" xml:space="preserve">
          <source>This method is unsafe because a &lt;code&gt;Read&lt;/code&gt;er could otherwise return a non-zeroing &lt;code&gt;Initializer&lt;/code&gt; from another &lt;code&gt;Read&lt;/code&gt; type without an &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="translated">때문에이 방법은 안전하지 않은 &lt;code&gt;Read&lt;/code&gt; 어 그렇지 않으면 비 제로 반환 할 수 &lt;code&gt;Initializer&lt;/code&gt; 서로 &lt;code&gt;Read&lt;/code&gt; 없이 형 &lt;code&gt;unsafe&lt;/code&gt; 블록.</target>
        </trans-unit>
        <trans-unit id="272d98e018b9a74f9a82d093db1b7d2de5f94a24" translate="yes" xml:space="preserve">
          <source>This method is useful when doing multiple calls to functions that consume the pinned type.</source>
          <target state="translated">이 메서드는 고정 된 형식을 사용하는 함수를 여러 번 호출 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b649b72cfd66bc53cdd1236dc499f467fbbbfc65" translate="yes" xml:space="preserve">
          <source>This method requires &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; to be able clone the passed value. If you need more flexibility (or want to rely on &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;), use &lt;a href=&quot;#method.resize_with&quot;&gt;&lt;code&gt;resize_with&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법을 사용하려면 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 에서 전달 된 값을 복제 할 수 있어야합니다. 더 많은 유연성이 필요하거나 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; 를 사용하려면 &lt;a href=&quot;#method.resize_with&quot;&gt; &lt;code&gt;resize_with&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe86d6b287ee66b5bfe82d8d97c6de5a30a28fea" translate="yes" xml:space="preserve">
          <source>This method requires &lt;code&gt;T&lt;/code&gt; to implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, in order to be able to clone the passed value. If you need more flexibility (or want to rely on &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;), use &lt;a href=&quot;struct.vec#method.resize_with&quot;&gt;&lt;code&gt;Vec::resize_with&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드 는 전달 된 값을 복제 할 수 있도록 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 을 구현 해야 합니다. 더 많은 유연성이 필요하거나 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; 를 사용하려면 &lt;a href=&quot;struct.vec#method.resize_with&quot;&gt; &lt;code&gt;Vec::resize_with&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9a3bfc3f1c3963b065d50d6828d4da511aead6e" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not end with &lt;code&gt;suffix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;suffix&lt;/code&gt; is an empty slice</source>
          <target state="translated">slice가 &lt;code&gt;suffix&lt;/code&gt; 로 끝나지 않으면 이 메서드는 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . 또한 &lt;code&gt;suffix&lt;/code&gt; 가 빈 조각 이면 원래 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b59bebec2345a5a01479f3be93783390bba5fe3b" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not start with &lt;code&gt;prefix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;prefix&lt;/code&gt; is an empty slice.</source>
          <target state="translated">이 메서드는 slice가 &lt;code&gt;prefix&lt;/code&gt; 로 시작하지 않으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환 합니다 . 또한 &lt;code&gt;prefix&lt;/code&gt; 가 빈 조각 이면 원래 조각을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b95f081db21ce8cf4e6f46e10880425784f2765c" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for addresses in the range reserved by [RFC 4291 section 2.4], i.e. addresses with the following format:</source>
          <target state="translated">이 메소드는 [RFC 4291 섹션 2.4]에 의해 예약 된 범위의 주소, 즉 다음 형식의 주소에 대해 &lt;a href=&quot;../primitive.bool&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="14217d50c79e4eb45c163835b69cd4e673a45e20" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for site-local addresses as per &lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291 section 2.5.7&lt;/a&gt;</source>
          <target state="translated">이 방법은 &lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291 섹션 2.5.7에&lt;/a&gt; 따라 사이트 로컬 주소에 대해 &lt;a href=&quot;../primitive.bool&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c067946f55e22970a3dc70591f782f7bfd3be70c" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for addresses in the range reserved by [RFC 4291 section 2.4], i.e. addresses with the following format:</source>
          <target state="translated">이 메소드는 [RFC 4291 섹션 2.4]에 의해 예약 된 범위의 주소, 즉 다음 형식의 주소에 대해 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1ac7dcf5283432feb1c671ca5dfa7bc7104e0a1d" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for site-local addresses as per &lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291 section 2.5.7&lt;/a&gt;</source>
          <target state="translated">이 메서드는 &lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291 섹션 2.5.7에&lt;/a&gt; 따라 사이트 로컬 주소에 대해 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="48c542fa498c19ba50cecb51c023284b67bf89ad" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not end with &lt;code&gt;suffix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;suffix&lt;/code&gt; is an empty slice</source>
          <target state="translated">slice가 &lt;code&gt;suffix&lt;/code&gt; 로 끝나지 않으면 이 메서드는 &lt;a href=&quot;option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . 또한 &lt;code&gt;suffix&lt;/code&gt; 가 빈 조각 이면 원래 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="da5bb928bae82aca5b2fc0bf565da6017cb0d4d8" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not start with &lt;code&gt;prefix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;prefix&lt;/code&gt; is an empty slice.</source>
          <target state="translated">이 메서드는 slice가 &lt;code&gt;prefix&lt;/code&gt; 로 시작하지 않으면 &lt;a href=&quot;option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환 합니다 . 또한 &lt;code&gt;prefix&lt;/code&gt; 가 빈 조각 이면 원래 조각을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8678f0273a7a7e566a6f4ee8c92fbd30439ee626" translate="yes" xml:space="preserve">
          <source>This method returns &lt;code&gt;Ok(())&lt;/code&gt; if the cell was empty and &lt;code&gt;Err(value)&lt;/code&gt; if it was full.</source>
          <target state="translated">이 메서드는 셀이 비어 있으면 &lt;code&gt;Ok(())&lt;/code&gt; 를, 가득 차면 &lt;code&gt;Err(value)&lt;/code&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1fe438568aa64ab40ad3ae63a4e80c06e5f2d121" translate="yes" xml:space="preserve">
          <source>This method returns &lt;code&gt;true&lt;/code&gt; after iteration has finished:</source>
          <target state="translated">이 메소드는 반복이 완료된 후 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="a10727aefe2c0619a67b5c808cec5f4b8a1e7af5" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;../../cmp/enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메서드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이 의 &lt;a href=&quot;../../cmp/enum.ordering&quot;&gt; &lt;code&gt;Ordering&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . &lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="553b97aa02f0558b1b0de2b63742a555e1d788b0" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;../cmp/enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메서드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이 의 &lt;a href=&quot;../cmp/enum.ordering&quot;&gt; &lt;code&gt;Ordering&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . &lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1fe70a42b371f1df3da8be36396abdc2eaf19453" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;cmp/enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메서드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이 의 &lt;a href=&quot;cmp/enum.ordering&quot;&gt; &lt;code&gt;Ordering&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . &lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="36badfc81f37e8dd9893bdb06702e1f5b7aef202" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">이 메서드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이 의 &lt;a href=&quot;enum.ordering&quot;&gt; &lt;code&gt;Ordering&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c319c899ab4990e562735b3d21d0f6cd464c7156" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메서드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이 의 &lt;a href=&quot;enum.ordering&quot;&gt; &lt;code&gt;Ordering&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da8759d1633206733343524980d7a489afd16956" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이 의 &lt;code&gt;Ordering&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="9f3bbc3554d60688630609ad13846c405e876fac" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이 의 &lt;code&gt;Ordering&lt;/code&gt; 을 리턴합니다 . &lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e875552f6e4025920ca5a71d7c281b1fbfaaa2a8" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이 의 &lt;code&gt;Ordering&lt;/code&gt; 을 리턴합니다 . &lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="400399c6db28cb18bc3db2944eff105cd4fca3da" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이 의 &lt;code&gt;Ordering&lt;/code&gt; 을 리턴합니다 . &lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a47b24f63b5fe410c6da12441f9c98d2fe17c15" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이 의 &lt;code&gt;Ordering&lt;/code&gt; 을 리턴합니다 . &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3cf087c16e29fe754de64f334036b96fe0b3931" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists.</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 값 사이의 순서를 리턴합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="eb17b52a796e0693ad06487790fde93b26d1d781" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;../../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 값 사이의 순서를 리턴합니다 (있는 경우). &lt;a href=&quot;../../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="39953b189e90eb45e12641b5213bac17fb6a067f" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 값 사이의 순서를 리턴합니다 (있는 경우). &lt;a href=&quot;../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a426df736d2450e1483768eb842876560c3cb8d7" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 값 사이의 순서를 리턴합니다 (있는 경우). &lt;a href=&quot;cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d64233d3af8194ec0eefc11c727f80c62d14630a" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 값 사이의 순서를 리턴합니다 (있는 경우). &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="edb583eeb291a512bd3d2447d1fbe080bc3b9dce" translate="yes" xml:space="preserve">
          <source>This method should generally not be invoked manually, but rather through the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro itself.</source>
          <target state="translated">이 메소드는 일반적으로 수동으로 호출되는 것이 아니라 &lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt; 통해 호출되어야합니다 ! 매크로 자체.</target>
        </trans-unit>
        <trans-unit id="d7174476c42e976c470e5d3d833837447fe7b624" translate="yes" xml:space="preserve">
          <source>This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix slice. The method does a best effort to make the middle slice the greatest length possible for a given type and input slice, but only your algorithm's performance should depend on that, not its correctness.</source>
          <target state="translated">이 방법은 슬라이스를 접두사, 올바르게 정렬 된 새 유형의 중간 슬라이스 및 접미사 슬라이스의 세 가지 개별 슬라이스로 분할합니다. 이 방법은 중간 슬라이스를 주어진 유형과 입력 슬라이스에 대해 가능한 최대 길이로 만들기 위해 최선의 노력을 다하지만 알고리즘의 정확성 만이 아니라 그 성능에 의존해야합니다.</target>
        </trans-unit>
        <trans-unit id="a7dca763f7ea1b34a0cad9b954868418d78e506c" translate="yes" xml:space="preserve">
          <source>This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix slice. The method may make the middle slice the greatest length possible for a given type and input slice, but only your algorithm's performance should depend on that, not its correctness. It is permissible for all of the input data to be returned as the prefix or suffix slice.</source>
          <target state="translated">이 방법은 슬라이스를 접두사, 새 유형의 올바르게 정렬 된 중간 슬라이스 및 접미사 슬라이스의 세 가지 개별 슬라이스로 분할합니다. 이 방법은 중간 슬라이스를 주어진 유형 및 입력 슬라이스에 대해 가능한 최대 길이로 만들 수 있지만 알고리즘의 성능 만이 정확성이 아니라 그것에 의존해야합니다. 모든 입력 데이터가 접두사 또는 접미사 슬라이스로 반환되는 것은 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="8000abb209a936f78ade63de708f2749dd5748c7" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;!=&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;!=&lt;/code&gt; 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="3639f2a22177e5f40d5314d575e638c54018960a" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 값이 같은지 테스트 하고 &lt;code&gt;==&lt;/code&gt; 에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3ea7ba813a098b9b6ae43b0aee731d0092913bf" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;../../../cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메서드는 &lt;code&gt;self&lt;/code&gt; 값 과 &lt;code&gt;other&lt;/code&gt; 값이 같은지 테스트 하고 &lt;code&gt;==&lt;/code&gt; 에서 사용됩니다 . &lt;a href=&quot;../../../cmp/trait.partialeq#tymethod.eq&quot;&gt;더 많은 것을 읽으십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f00abfa17fbf62bab913260c77c4736307dd6b08" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;../../cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 값이 같은지 테스트 하고 &lt;code&gt;==&lt;/code&gt; 에 의해 사용됩니다 . &lt;a href=&quot;../../cmp/trait.partialeq#tymethod.eq&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c257c51217cc2c43c24273fbc2f10164037dd5b1" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;../cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 값이 같은지 테스트 하고 &lt;code&gt;==&lt;/code&gt; 에 의해 사용됩니다 . &lt;a href=&quot;../cmp/trait.partialeq#tymethod.eq&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34550195d18fa1542599bef9324d74efad99aeb1" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 값이 같은지 테스트 하고 &lt;code&gt;==&lt;/code&gt; 에 의해 사용됩니다 . &lt;a href=&quot;cmp/trait.partialeq#tymethod.eq&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d32084f8ce776d9a529be0f1da6ec9ca22e44396" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 값이 같은지 테스트 하고 &lt;code&gt;==&lt;/code&gt; 에 의해 사용됩니다 . &lt;a href=&quot;trait.partialeq#tymethod.eq&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9893b74b381c1707e88afd0a7ed6401e06b38424" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator.</source>
          <target state="translated">이 방법은보다 큰 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 테스트 하고 &lt;code&gt;&amp;gt;&lt;/code&gt; 연산자에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9be75e39e05fc52a961a6f8a30bebafa3abc619e" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은보다 큰 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 테스트 하고 &lt;code&gt;&amp;gt;&lt;/code&gt; 연산자에서 사용합니다. &lt;a href=&quot;../../cmp/trait.partialord#method.gt&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b084733b90b43f4725bbd31294cb1f36404ce0a" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은보다 큰 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 테스트 하고 &lt;code&gt;&amp;gt;&lt;/code&gt; 연산자에서 사용합니다. &lt;a href=&quot;../cmp/trait.partialord#method.gt&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="44184bc5bd845c73d3a6bdc521b7927b64cd5369" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은보다 큰 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 테스트 하고 &lt;code&gt;&amp;gt;&lt;/code&gt; 연산자에서 사용합니다. &lt;a href=&quot;cmp/trait.partialord#method.gt&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8eec657a4246dd487288b986e3d57dfd9657b208" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은보다 큰 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 테스트 하고 &lt;code&gt;&amp;gt;&lt;/code&gt; 연산자에서 사용합니다. &lt;a href=&quot;trait.partialord#method.gt&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0eabc442f100ec2b7e353c049aaaf4ca623d1f2c" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator.</source>
          <target state="translated">이 방법은 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 크거나 같고 &lt;code&gt;&amp;gt;=&lt;/code&gt; 연산자에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4194eb24934481036250e733ab18937ab48da677" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 크거나 같고 &lt;code&gt;&amp;gt;=&lt;/code&gt; 연산자에 의해 사용됩니다 . &lt;a href=&quot;../../cmp/trait.partialord#method.ge&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="219eec29ea3645fe37ee0a3de43c26a2abe5b61f" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 크거나 같고 &lt;code&gt;&amp;gt;=&lt;/code&gt; 연산자에 의해 사용됩니다 . &lt;a href=&quot;../cmp/trait.partialord#method.ge&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a7907168214aeaea1aa4db413b937e0f747bd41c" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 크거나 같고 &lt;code&gt;&amp;gt;=&lt;/code&gt; 연산자에 의해 사용됩니다 . &lt;a href=&quot;cmp/trait.partialord#method.ge&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e579d59fed2657492555041f61545aa7206f59b6" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 방법은 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 크거나 같고 &lt;code&gt;&amp;gt;=&lt;/code&gt; 연산자에 의해 사용됩니다 . &lt;a href=&quot;trait.partialord#method.ge&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c0e789163efc5086c683b5a1f62c9a3bb50e4538" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">이 메소드는보다 적은 테스트 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; )를 수행하며 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자 가 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="a9a38093c98e8f8478fc7a4cb9a47c1ad908df47" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는보다 적은 테스트 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; )를 수행하며 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자 가 사용합니다 . &lt;a href=&quot;../../cmp/trait.partialord#method.lt&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d167afca39913e71e4062a05ae7a9d99838896ab" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는보다 적은 테스트 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; )를 수행하며 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자 가 사용합니다 . &lt;a href=&quot;../cmp/trait.partialord#method.lt&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ebc7cc22118ac04d1f984d545d5be0d85818a1e" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는보다 적은 테스트 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; )를 수행하며 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자 가 사용합니다 . &lt;a href=&quot;cmp/trait.partialord#method.lt&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="54945ad3f8cac4a154fb7b9e35518b30ae999d4d" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는보다 적은 테스트 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; )를 수행하며 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자 가 사용합니다 . &lt;a href=&quot;trait.partialord#method.lt&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d161a6ff3e691349ec054ac0d4002d49a30e7893" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator.</source>
          <target state="translated">이 메소드는 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 이하의 테스트를 수행 하며 &lt;code&gt;&amp;lt;=&lt;/code&gt; 연산자에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="aadf89f483a504081f46ca5ef3749d0af43a4387" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 이하의 테스트를 수행 하며 &lt;code&gt;&amp;lt;=&lt;/code&gt; 연산자에 의해 사용됩니다 . &lt;a href=&quot;../../cmp/trait.partialord#method.le&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ddb1ab74197bbadea31b206cbb3f4c8f2c4d9f37" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 이하의 테스트를 수행 하며 &lt;code&gt;&amp;lt;=&lt;/code&gt; 연산자에 의해 사용됩니다 . &lt;a href=&quot;../cmp/trait.partialord#method.le&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="db00fc514ef8b2e5769c8d739b13605dcfb91f42" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 이하의 테스트를 수행 하며 &lt;code&gt;&amp;lt;=&lt;/code&gt; 연산자에 의해 사용됩니다 . &lt;a href=&quot;cmp/trait.partialord#method.le&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bca462ad1eb0c753d442b14b7fe002228f03d1ee" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 메소드는 ( &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; ) 이하의 테스트를 수행 하며 &lt;code&gt;&amp;lt;=&lt;/code&gt; 연산자에 의해 사용됩니다 . &lt;a href=&quot;trait.partialord#method.le&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5f2ae443e73d5f88ef06a1d6b529c7d18527f78a" translate="yes" xml:space="preserve">
          <source>This method uses &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; 을 사용하여 모든 푸시에서 새 값을 만듭니다. 당신은 오히려 줄 경우 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 주어진 값, 사용 &lt;a href=&quot;#method.resize&quot;&gt; &lt;code&gt;resize&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1dc00be165ac3a4a63601e65e376c360363d264c" translate="yes" xml:space="preserve">
          <source>This method uses &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;struct.vec#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드는 &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; 을 사용하여 푸시 할 때마다 새 값을 만듭니다. 당신은 오히려 줄 경우 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 주어진 값, 사용 &lt;a href=&quot;struct.vec#method.resize&quot;&gt; &lt;code&gt;resize&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5ffc4fb20de54f6e75ded6f37d7e6542ba4dcb3" translate="yes" xml:space="preserve">
          <source>This method uses a closure to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;. If you want to use the &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait to generate values, you can pass &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default()&lt;/code&gt;&lt;/a&gt; as the second argument.</source>
          <target state="translated">이 방법은 클로저를 사용하여 모든 푸시에서 새 값을 만듭니다. 당신은 오히려 줄 경우 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 주어진 값, 사용 &lt;a href=&quot;#method.resize&quot;&gt; &lt;code&gt;resize&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; 특성 을 사용하여 값을 생성 하려는 경우 두 번째 인수로 &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default()&lt;/code&gt; &lt;/a&gt; 를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94cb38be3cc225054f996a63889a25410328f00e" translate="yes" xml:space="preserve">
          <source>This method uses a closure to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;struct.vec#method.resize&quot;&gt;&lt;code&gt;Vec::resize&lt;/code&gt;&lt;/a&gt;. If you want to use the &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait to generate values, you can pass &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default&lt;/code&gt;&lt;/a&gt; as the second argument.</source>
          <target state="translated">이 방법은 모든 푸시에서 새로운 값을 생성하기 위해 클로저를 사용합니다. 당신은 오히려 줄 경우 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 주어진 값, 사용 &lt;a href=&quot;struct.vec#method.resize&quot;&gt; &lt;code&gt;Vec::resize&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; 트레이 트 를 사용하여 값을 생성하려면 &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default&lt;/code&gt; &lt;/a&gt; 를 두 번째 인수로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2c5f86d4c9d838972d27ad9b235e2a91344da57" translate="yes" xml:space="preserve">
          <source>This method uses a closure to create new values. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;#method.fill&quot;&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/a&gt;. If you want to use the &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait to generate values, you can pass &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default&lt;/code&gt;&lt;/a&gt; as the argument.</source>
          <target state="translated">이 메서드는 클로저를 사용하여 새 값을 만듭니다. 당신은 오히려 줄 경우 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 주어진 값, 사용 &lt;a href=&quot;#method.fill&quot;&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; 트레이 트 를 사용하여 값을 생성하려면 &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default&lt;/code&gt; &lt;/a&gt; 를 인수로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="900514ffa4e50bfbbb68fdfe9dc96a8ee8c53300" translate="yes" xml:space="preserve">
          <source>This method uses a closure to create new values. If you'd rather &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;#method.fill&quot;&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/a&gt;. If you want to use the &lt;a href=&quot;default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait to generate values, you can pass &lt;a href=&quot;default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default&lt;/code&gt;&lt;/a&gt; as the argument.</source>
          <target state="translated">이 메서드는 클로저를 사용하여 새 값을 만듭니다. 당신은 오히려 줄 경우 &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 주어진 값, 사용 &lt;a href=&quot;#method.fill&quot;&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; 트레이 트 를 사용하여 값을 생성하려면 &lt;a href=&quot;default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default&lt;/code&gt; &lt;/a&gt; 를 인수로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e8aba760b1e58965c26c5247df8d78a97a2b7d9" translate="yes" xml:space="preserve">
          <source>This method validates the format defined in the RFC and won't recognize the following addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; as unicast link-local addresses for example. If you need a less strict validation use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt;&lt;code&gt;Ipv6Addr::is_unicast_link_local()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 메서드는 RFC에 정의 된 형식의 유효성을 검사하고 &lt;code&gt;fe80:0:0:1::&lt;/code&gt; 또는 &lt;code&gt;fe81::&lt;/code&gt; 과 같은 다음 주소 를 유니 캐스트 링크 로컬 주소로 인식하지 않습니다 . 덜 엄격한 유효성 검사가 필요한 경우 &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt; &lt;code&gt;Ipv6Addr::is_unicast_link_local()&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="57f44223f055f4bc85ef6eebc9a26838b98e07df" translate="yes" xml:space="preserve">
          <source>This method validates the format defined in the RFC and won't recognize the following addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; as unicast link-local addresses for example. If you need a less strict validation use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt;&lt;code&gt;is_unicast_link_local()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 방법은 RFC에 정의 된 형식의 유효성을 검사하고 &lt;code&gt;fe80:0:0:1::&lt;/code&gt; 또는 &lt;code&gt;fe81::&lt;/code&gt; 와 같은 다음 주소 를 유니 캐스트 링크 로컬 주소로 인식하지 않습니다 . 덜 엄격한 유효성 검사가 필요한 경우 대신 &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt; &lt;code&gt;is_unicast_link_local()&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="34a9aeb12096c73821e3d3f2146e3bcd68d312a7" translate="yes" xml:space="preserve">
          <source>This method will be deprecated in favor of the identically-named inherent methods on &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;[u8]&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;u8&lt;/code&gt; , &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;[u8]&lt;/code&gt; 및 &lt;code&gt;str&lt;/code&gt; 에서 동일한 이름의 고유 메소드를 위해 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="71c3fa499cb951e39a31bf79d7f47ca94405dd75" translate="yes" xml:space="preserve">
          <source>This method will be removed soon.</source>
          <target state="translated">이 방법은 곧 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="dab63bf4ac92d7a8265610c22503839aea1e5938" translate="yes" xml:space="preserve">
          <source>This method will block the calling thread if another initialization routine is currently running.</source>
          <target state="translated">이 메소드는 다른 초기화 루틴이 현재 실행중인 경우 호출 스레드를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="fd65ab04cca83f42050b2936debdcfa64855e2e3" translate="yes" xml:space="preserve">
          <source>This method will call &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; repeatedly until &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is encountered, returning the number of times it saw &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;. Note that &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; has to be called at least once even if the iterator does not have any elements.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 만날 때까지 &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; 를&lt;/a&gt; 반복적으로 호출 하여 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; 을 본 횟수를 반환합니다 . 참고 것을 &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 반복자는 어떤 요소가없는 경우에도 한 번에 적어도 호출 할 수있다.</target>
        </trans-unit>
        <trans-unit id="4dcd7df93995d5669f9a19d9090b19b5d2473592" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 데이터가 더 이상 &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 의 오류 가 리턴 될 때까지 쓰기 를 계속 호출 합니다. 이 메소드는 전체 버퍼가 성공적으로 작성되거나 그러한 오류가 발생할 때까지 리턴되지 않습니다. 이 메소드에서 생성 된 &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 가 아닌 첫 번째 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0bf4855a0328106cbe0baa3671aad93298aa630b" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;#tymethod.write_at&quot;&gt;&lt;code&gt;write_at&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">이 메소드는 쓸 데이터가 더 이상 &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 의 오류 가 리턴 될 때까지 &lt;a href=&quot;#tymethod.write_at&quot;&gt; &lt;code&gt;write_at&lt;/code&gt; &lt;/a&gt; 를 계속 호출 합니다. 이 메소드는 전체 버퍼가 성공적으로 작성되거나 그러한 오류가 발생할 때까지 리턴되지 않습니다. 이 메소드에서 생성 된 &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 가 아닌 첫 번째 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="34bd7dd9f2f6fd228fe4ece502dea492de39f939" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;trait.fileext#tymethod.write_at&quot;&gt;&lt;code&gt;write_at&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">이 메소드 는 더 이상 쓸 데이터가 없거나 비 &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 의 오류 가 반환 될 때까지 &lt;a href=&quot;trait.fileext#tymethod.write_at&quot;&gt; &lt;code&gt;write_at&lt;/code&gt; &lt;/a&gt; 를 계속 호출 합니다. 이 메서드는 전체 버퍼가 성공적으로 기록되거나 이러한 오류가 발생할 때까지 반환되지 않습니다. 이 메서드에서 생성 된 &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 가 아닌 첫 번째 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="59d4273ac7a3ba1d7a87ecc5115120efa61d6d44" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until all buffers have been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">이 메서드 는 더 이상 쓸 데이터가 없거나 &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 유형이 아닌 오류 가 반환 될 때까지 &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt; &lt;code&gt;write_vectored&lt;/code&gt; &lt;/a&gt; 를 계속 호출 합니다. 이 메서드는 모든 버퍼가 성공적으로 기록되거나 이러한 오류가 발생할 때까지 반환되지 않습니다. 이 메서드에서 생성 된 &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 가 아닌 첫 번째 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d3edbd42d79d3d4c4b13caf2b0a59c3d785c0e55" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">이 메서드 는 더 이상 쓸 데이터가 없거나 &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류가 아닌 오류 가 반환 될 때까지 &lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 를 계속 호출 합니다. 이 메서드는 전체 버퍼가 성공적으로 기록되거나 이러한 오류가 발생할 때까지 반환되지 않습니다. 이 메서드에서 생성 된 &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 가 아닌 첫 번째 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b531b20d0eb83c8a34e8a69001999cab52351ebf" translate="yes" xml:space="preserve">
          <source>This method will currently always return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, but this may change in future versions.</source>
          <target state="translated">이 메소드는 현재 항상 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; 을&lt;/a&gt; 리턴 하지만 이후 버전에서는 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5ce2db6ab8281674bdcae7d5e2f97235788a1d6" translate="yes" xml:space="preserve">
          <source>This method will eagerly skip &lt;code&gt;n&lt;/code&gt; elements by calling &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; up to &lt;code&gt;n&lt;/code&gt; times until &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is encountered.</source>
          <target state="translated">이 메서드는 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 만날 때까지 &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;n&lt;/code&gt; 번 호출 하여 n &lt;code&gt;n&lt;/code&gt; 요소를 간절히 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="2170c54e7e7e211e3d0e2c65e377ae8bcaea7ac1" translate="yes" xml:space="preserve">
          <source>This method will ensure that any current waiters on the condition variable are awoken. Calls to &lt;code&gt;notify_all()&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">이 방법을 사용하면 조건 변수의 현재 웨이터가 해제됩니다. &lt;code&gt;notify_all()&lt;/code&gt; 대한 호출 은 어떤 식으로도 버퍼링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="149968b75a735130b9e849f252f39d4aeeb3370e" translate="yes" xml:space="preserve">
          <source>This method will evaluate the iterator until it returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. While doing so, it keeps track of the current element. After &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned, &lt;code&gt;last()&lt;/code&gt; will then return the last element it saw.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 리턴 될 때까지 반복자를 평가합니다 . 그렇게하는 동안 현재 요소를 추적합니다. &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환 된 후 &lt;code&gt;last()&lt;/code&gt; 는 마지막으로 본 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="60132e29639954faf0b02a7c1a61ca490fca81f1" translate="yes" xml:space="preserve">
          <source>This method will evaluate the iterator until its &lt;a href=&quot;#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. Once &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is encountered, &lt;code&gt;count()&lt;/code&gt; returns the number of times it called &lt;a href=&quot;#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 이&lt;/a&gt; 리턴 될 때까지 반복자를 평가합니다 . 일단 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 발생되지 않으며, &lt;code&gt;count()&lt;/code&gt; 의 수를 반환이라는 시간 &lt;a href=&quot;#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="430231e1c82b4b198abc958a7fd105f7b17a6eb0" translate="yes" xml:space="preserve">
          <source>This method will fail if the socket is not connected. The &lt;code&gt;connect&lt;/code&gt; method will connect this socket to a remote address.</source>
          <target state="translated">소켓이 연결되어 있지 않으면이 방법이 실패합니다. &lt;code&gt;connect&lt;/code&gt; 방법은 리모트 주소에 소켓을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="99d3a71bbe68b832fc3370a5188434c797f36ae5" translate="yes" xml:space="preserve">
          <source>This method will never block the caller in order to wait for data to become available. Instead, this will always return immediately with a possible option of pending data on the channel.</source>
          <target state="translated">이 메소드는 데이터가 사용 가능할 때까지 호출자를 차단하지 않습니다. 대신 채널에서 보류중인 데이터의 가능한 옵션과 함께 항상 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cbdaac7e9262e1ca34c4fe476a690d8dd791b78c" translate="yes" xml:space="preserve">
          <source>This method will never block the current thread.</source>
          <target state="translated">이 메소드는 현재 스레드를 차단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46d2c9fdd8f22af9ddb09186941e568038365eb2" translate="yes" xml:space="preserve">
          <source>This method will panic if result is not finite, negative or overflows &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">결과가 유한, 음수 또는 오버플로 &lt;code&gt;Duration&lt;/code&gt; 이 아닌 경우이 메서드는 패닉 상태가됩니다 .</target>
        </trans-unit>
        <trans-unit id="361fc3f209ee1e7f236b4d7adeffb54823eee70f" translate="yes" xml:space="preserve">
          <source>This method will take care to not copy the vector, for efficiency's sake.</source>
          <target state="translated">이 방법은 효율성을 위해 벡터를 복사하지 않도록주의합니다.</target>
        </trans-unit>
        <trans-unit id="086f7043b4f8a7fd4a6336d78995f0e85e9d5744" translate="yes" xml:space="preserve">
          <source>This method, together with &lt;code&gt;key&lt;/code&gt;, is an alternative to &lt;code&gt;entry&lt;/code&gt; that can be used when the complete entry isn't known upfront. Prefer the &lt;code&gt;entry&lt;/code&gt; method when it's possible to use.</source>
          <target state="translated">이 방법은 &lt;code&gt;key&lt;/code&gt; 와 함께 전체 항목을 미리 알 수 없을 때 사용할 수있는 &lt;code&gt;entry&lt;/code&gt; 의 대안 입니다. 사용 가능한 경우 &lt;code&gt;entry&lt;/code&gt; 방법을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="8e6fca229e267292b225ded4f3ea56dd1917d4dd" translate="yes" xml:space="preserve">
          <source>This method, together with &lt;code&gt;value&lt;/code&gt;, is an alternative to &lt;code&gt;entry&lt;/code&gt; that can be used when the complete entry isn't known upfront. Prefer the &lt;code&gt;entry&lt;/code&gt; method when it's possible to use.</source>
          <target state="translated">이 방법은 &lt;code&gt;value&lt;/code&gt; 와 함께 전체 항목을 미리 알 수없는 경우 사용할 수있는 &lt;code&gt;entry&lt;/code&gt; 의 대안 입니다. 사용 가능한 경우 &lt;code&gt;entry&lt;/code&gt; 방법을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="15bda4a4da4275b96ba5bd1843478dd37908d7e9" translate="yes" xml:space="preserve">
          <source>This module also provides an implementation of thread-local storage for Rust programs. Thread-local storage is a method of storing data into a global variable that each thread in the program will have its own copy of. Threads do not share this data, so accesses do not need to be synchronized.</source>
          <target state="translated">이 모듈은 Rust 프로그램을위한 스레드 로컬 스토리지의 구현도 제공합니다. 스레드 로컬 저장소는 프로그램의 각 스레드가 고유 한 복사본을 갖는 전역 변수에 데이터를 저장하는 방법입니다. 스레드는이 데이터를 공유하지 않으므로 액세스를 동기화 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a618e47bcd778e6fbdbebc05ca474e36092d34bf" translate="yes" xml:space="preserve">
          <source>This module contains basic methods to manipulate the contents of the local filesystem. All methods in this module represent cross-platform filesystem operations. Extra platform-specific functionality can be found in the extension traits of &lt;code&gt;std::os::$platform&lt;/code&gt;.</source>
          <target state="translated">이 모듈에는 로컬 파일 시스템의 내용을 조작하는 기본 방법이 포함되어 있습니다. 이 모듈의 모든 메소드는 크로스 플랫폼 파일 시스템 조작을 나타냅니다. 추가 플랫폼 별 기능은 &lt;code&gt;std::os::$platform&lt;/code&gt; 의 확장 특성에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="facf45454888eb2d77ede3ccdd2076d5cf487a0e" translate="yes" xml:space="preserve">
          <source>This module contains functions for querying the size and alignment of types, initializing and manipulating memory.</source>
          <target state="translated">이 모듈에는 유형의 크기와 정렬을 쿼리하고 메모리를 초기화하고 조작하는 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2408b577206af618721c013114d9c06e429f800a" translate="yes" xml:space="preserve">
          <source>This module contains functions to inspect various aspects such as environment variables, process arguments, the current directory, and various other important directories.</source>
          <target state="translated">이 모듈에는 환경 변수, 프로세스 인수, 현재 디렉토리 및 기타 중요한 디렉토리와 같은 다양한 측면을 검사하는 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="493f5d09dd437f62e48924cee92d925e5c7d2ef1" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; type, a trait for converting &lt;a href=&quot;trait.tostring&quot;&gt;&lt;code&gt;ToString&lt;/code&gt;&lt;/a&gt;s, and several error types that may result from working with &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">이 모듈에는 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 유형, &lt;a href=&quot;trait.tostring&quot;&gt; &lt;code&gt;ToString&lt;/code&gt; &lt;/a&gt; 변환에 대한 특성 및 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 작업으로 인해 발생할 수있는 몇 가지 오류 유형이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="0a09e5de88124067a8f4a272146af1f58ce6f16e" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; type, the &lt;a href=&quot;trait.tostring&quot;&gt;&lt;code&gt;ToString&lt;/code&gt;&lt;/a&gt; trait for converting to strings, and several error types that may result from working with &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">이 모듈에는 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 유형, 문자열로 변환하기위한 &lt;a href=&quot;trait.tostring&quot;&gt; &lt;code&gt;ToString&lt;/code&gt; &lt;/a&gt; 특성 및 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 작업으로 인해 발생할 수있는 여러 오류 유형이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a15bad5d969fcb97693f6f0bc38018fba7343164" translate="yes" xml:space="preserve">
          <source>This module contains the runtime support for the &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; syntax extension. This macro is implemented in the compiler to emit calls to this module in order to format arguments at runtime into strings.</source>
          <target state="translated">이 모듈에는 &lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt; 대한 런타임 지원이 포함되어 있습니다 ! 구문 확장. 이 매크로는 컴파일러에서 구현되어 런타임시 인수를 문자열로 형식화하기 위해이 모듈에 대한 호출을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="12f15aefb562d878bda21e27716658fa02862f93" translate="yes" xml:space="preserve">
          <source>This module contains the support necessary to capture a stack backtrace of a running OS thread from the OS thread itself. The &lt;code&gt;Backtrace&lt;/code&gt; type supports capturing a stack trace via the &lt;code&gt;Backtrace::capture&lt;/code&gt; and &lt;code&gt;Backtrace::force_capture&lt;/code&gt; functions.</source>
          <target state="translated">이 모듈에는 OS 스레드 자체에서 실행중인 OS 스레드의 스택 역 추적을 캡처하는 데 필요한 지원이 포함되어 있습니다. &lt;code&gt;Backtrace&lt;/code&gt; 스택 비아 추적 캡처 유형 지원 &lt;code&gt;Backtrace::capture&lt;/code&gt; 및 &lt;code&gt;Backtrace::force_capture&lt;/code&gt; 기능을.</target>
        </trans-unit>
        <trans-unit id="fe75678b9da36500f1155d5a63660783d7b96c49" translate="yes" xml:space="preserve">
          <source>This module contains various tools for ordering and comparing values. In summary:</source>
          <target state="translated">이 모듈에는 값을 정렬하고 비교하기위한 다양한 도구가 포함되어 있습니다. 요약해서 말하자면:</target>
        </trans-unit>
        <trans-unit id="5526cfdf674b75dda2276399dbf95bab9061f815" translate="yes" xml:space="preserve">
          <source>This module defines atomic versions of a select number of primitive types, including &lt;a href=&quot;struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicisize&quot;&gt;&lt;code&gt;AtomicIsize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicusize&quot;&gt;&lt;code&gt;AtomicUsize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomici8&quot;&gt;&lt;code&gt;AtomicI8&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicu16&quot;&gt;&lt;code&gt;AtomicU16&lt;/code&gt;&lt;/a&gt;, etc. Atomic types present operations that, when used correctly, synchronize updates between threads.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.atomicisize&quot;&gt; &lt;code&gt;AtomicIsize&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.atomicusize&quot;&gt; &lt;code&gt;AtomicUsize&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.atomici8&quot;&gt; &lt;code&gt;AtomicI8&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.atomicu16&quot;&gt; &lt;code&gt;AtomicU16&lt;/code&gt; &lt;/a&gt; 등을 포함하여 선택된 수의 기본 유형의 원자 버전을 정의합니다 . 원자 유형은 올바르게 사용될 때 스레드 간 업데이트를 동기화하는 조작을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="69b6d67047755d0189ccf8e0dd69886ba1af9f48" translate="yes" xml:space="preserve">
          <source>This module exists for technical reasons, the primary documentation for &lt;code&gt;char&lt;/code&gt; is directly on &lt;a href=&quot;../primitive.char&quot;&gt;the &lt;code&gt;char&lt;/code&gt; primitive type&lt;/a&gt; itself.</source>
          <target state="translated">이 모듈에 대한 기본 문서, 기술적 인 이유로 존재 &lt;code&gt;char&lt;/code&gt; 에 바로 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 원시 형 자체.</target>
        </trans-unit>
        <trans-unit id="0c05c40f88eef085aa06e135cdea7a637a633c60" translate="yes" xml:space="preserve">
          <source>This module implements the &lt;code&gt;Any&lt;/code&gt; trait, which enables dynamic typing of any &lt;code&gt;'static&lt;/code&gt; type through runtime reflection.</source>
          <target state="translated">이 모듈은 &lt;code&gt;Any&lt;/code&gt; 특성을 구현하여 런타임 반영을 통해 모든 &lt;code&gt;'static&lt;/code&gt; 유형을 동적으로 입력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2779c978566f8d66cd98dfb5457c45d53a57fb6" translate="yes" xml:space="preserve">
          <source>This module is largely organized by type:</source>
          <target state="translated">이 모듈은 크게 유형별로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="5be07f93f33ed08d424575dcac18854b8631d380" translate="yes" xml:space="preserve">
          <source>This module is mostly concerned with spawning and interacting with child processes, but it also provides &lt;a href=&quot;fn.abort&quot;&gt;&lt;code&gt;abort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.exit&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt; for terminating the current process.</source>
          <target state="translated">이 모듈은 주로 자식 프로세스의 생성 및 상호 작용과 관련이 있지만 현재 프로세스를 종료하기위한 &lt;a href=&quot;fn.abort&quot;&gt; &lt;code&gt;abort&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fn.exit&quot;&gt; &lt;code&gt;exit&lt;/code&gt; &lt;/a&gt; 도 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="288daae4ba933c2cf1c52332e7aec01da8baaf15" translate="yes" xml:space="preserve">
          <source>This module is the home of the iterator implementations for the iterators implemented on &lt;code&gt;char&lt;/code&gt;, as well as some useful constants and conversion functions that convert various types to &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;char&lt;/code&gt; 에 구현 된 반복자에 대한 반복자 구현 과 다양한 유형을 &lt;code&gt;char&lt;/code&gt; 로 변환하는 유용한 상수 및 변환 함수의 홈입니다 .</target>
        </trans-unit>
        <trans-unit id="55568ed1c38eacf7d09bc4bc93efa4b457d73318" translate="yes" xml:space="preserve">
          <source>This module only currently provides one bit of information, &lt;a href=&quot;struct.permissions#method.readonly&quot;&gt;&lt;code&gt;Permissions::readonly&lt;/code&gt;&lt;/a&gt;, which is exposed on all currently supported platforms. Unix-specific functionality, such as mode bits, is available through the &lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt;&lt;code&gt;PermissionsExt&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">이 모듈 은 현재 지원되는 모든 플랫폼에 노출되는 한 비트의 정보 인 &lt;a href=&quot;struct.permissions#method.readonly&quot;&gt; &lt;code&gt;Permissions::readonly&lt;/code&gt; &lt;/a&gt; 만 제공 합니다. 모드 비트와 같은 Unix 관련 기능은 &lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt; &lt;code&gt;PermissionsExt&lt;/code&gt; &lt;/a&gt; 특성을 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16223be8f664aa8af7792fdf4f8c15d5b579360d" translate="yes" xml:space="preserve">
          <source>This module only currently provides one bit of information, &lt;a href=&quot;struct.permissions#method.readonly&quot;&gt;&lt;code&gt;readonly&lt;/code&gt;&lt;/a&gt;, which is exposed on all currently supported platforms. Unix-specific functionality, such as mode bits, is available through the &lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt;&lt;code&gt;PermissionsExt&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">이 모듈은 현재 현재 지원되는 모든 플랫폼에서 공개되는 1 비트의 정보 인 &lt;a href=&quot;struct.permissions#method.readonly&quot;&gt; &lt;code&gt;readonly&lt;/code&gt; &lt;/a&gt; 만 제공 합니다. 모드 비트와 같은 유닉스 관련 기능은 &lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt; &lt;code&gt;PermissionsExt&lt;/code&gt; &lt;/a&gt; 특성을 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72abc30b878e9efe98c4c560589176b50cfcfb02" translate="yes" xml:space="preserve">
          <source>This module provides a generic way to compute the hash of a value. The simplest way to make a type hashable is to use &lt;code&gt;#[derive(Hash)]&lt;/code&gt;:</source>
          <target state="translated">이 모듈은 값의 해시를 계산하는 일반적인 방법을 제공합니다. 형식을 해시 가능하게 만드는 가장 간단한 방법은 &lt;code&gt;#[derive(Hash)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f6357e74fc7527ed8e55102f82ccb8843f20d51" translate="yes" xml:space="preserve">
          <source>This module provides constants which are specific to the implementation of the &lt;code&gt;f32&lt;/code&gt; floating point data type.</source>
          <target state="translated">이 모듈은 &lt;code&gt;f32&lt;/code&gt; 부동 소수점 데이터 유형 의 구현에 고유 한 상수를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="87f0d2ad3a049e2ea757e82944e2e6b1d2f310c4" translate="yes" xml:space="preserve">
          <source>This module provides constants which are specific to the implementation of the &lt;code&gt;f64&lt;/code&gt; floating point data type.</source>
          <target state="translated">이 모듈은 &lt;code&gt;f64&lt;/code&gt; 부동 소수점 데이터 유형 의 구현에 고유 한 상수를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="4dd1d432064e6f3e28ac8c1d81caf06446f388ba" translate="yes" xml:space="preserve">
          <source>This module provides message-based communication over channels, concretely defined among three types:</source>
          <target state="translated">이 모듈은 세 가지 유형으로 구체적으로 정의 된 채널을 통한 메시지 기반 통신을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bfedf6f4f14d905a894526b273dfe17f7e7c03dc" translate="yes" xml:space="preserve">
          <source>This module provides networking functionality for the Transmission Control and User Datagram Protocols, as well as types for IP and socket addresses.</source>
          <target state="translated">이 모듈은 IP 및 소켓 주소 유형뿐만 아니라 전송 제어 및 사용자 데이터 그램 프로토콜에 대한 네트워킹 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fcfa8dfe7aed9682173752b15b6103829ea655a1" translate="yes" xml:space="preserve">
          <source>This module provides some extra types that are useful when doing numerical work. See the individual documentation for each piece for more information.</source>
          <target state="translated">이 모듈은 수치 작업을 할 때 유용한 추가 유형을 제공합니다. 자세한 내용은 각 부분에 대한 개별 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b42dc453d74574a22f838766ed6a6210b7719f9b" translate="yes" xml:space="preserve">
          <source>This module provides two types, &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; (akin to &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;), for working with paths abstractly. These types are thin wrappers around &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; respectively, meaning that they work directly on strings according to the local platform's path syntax.</source>
          <target state="translated">이 모듈은 경로를 추상적으로 사용하기 위해 &lt;a href=&quot;struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; (akin to &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; )의 두 가지 유형을 제공합니다 . 이러한 유형은 각각 &lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; 주위의 얇은 래퍼 입니다. 즉, 로컬 플랫폼의 경로 구문에 따라 문자열에서 직접 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a9add5ffa74ddef61504588ae8fe02f3fc02034e" translate="yes" xml:space="preserve">
          <source>This module provides two types, &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; (akin to &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;), for working with paths abstractly. These types are thin wrappers around &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; respectively, meaning that they work directly on strings according to the local platform's path syntax.</source>
          <target state="translated">이 모듈은 추상적 인 경로 작업을 위해 &lt;a href=&quot;struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 과 유사)의 두 가지 유형을 제공합니다 . 이러한 유형은 각각 &lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; 을&lt;/a&gt; 둘러싼 얇은 래퍼 입니다. 즉, 로컬 플랫폼의 경로 구문에 따라 문자열에서 직접 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f2fe72f6bcf1faf654e10546253a992773369d18" translate="yes" xml:space="preserve">
          <source>This module provides utilities to handle data across non-Rust interfaces, like other programming languages and the underlying operating system. It is mainly of use for FFI (Foreign Function Interface) bindings and code that needs to exchange C-like strings with other languages.</source>
          <target state="translated">이 모듈은 다른 프로그래밍 언어 및 기본 운영 체제와 같이 비 Rust 인터페이스에서 데이터를 처리하는 유틸리티를 제공합니다. C 유사 문자열을 다른 언어와 교환해야하는 FFI (Foreign Function Interface) 바인딩 및 코드에 주로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="523a58a1796e44e7bd8c46d95ef23447cedfbc5f" translate="yes" xml:space="preserve">
          <source>This module reexports the primitive types to allow usage that is not possibly shadowed by other declared types.</source>
          <target state="translated">이 모듈은 다른 선언 된 유형에 의해 가려지지 않는 사용을 허용하기 위해 기본 유형을 다시 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="2bfbd1c67f1485adce8aa9ca96b08fda6c8d21af" translate="yes" xml:space="preserve">
          <source>This mutex will block threads waiting for the lock to become available. The mutex can also be statically initialized or created via a &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; constructor. Each mutex has a type parameter which represents the data that it is protecting. The data can only be accessed through the RAII guards returned from &lt;a href=&quot;#method.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;, which guarantees that the data is only ever accessed when the mutex is locked.</source>
          <target state="translated">이 뮤텍스는 잠금을 사용할 수있게되기를 기다리는 스레드를 차단합니다. 뮤텍스는 정적으로 초기화되거나 &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 생성자 를 통해 생성 될 수도 있습니다 . 각 뮤텍스에는 보호하고있는 데이터를 나타내는 유형 매개 변수가 있습니다. 데이터는 &lt;a href=&quot;#method.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#method.try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; 에서 반환 된 RAII 가드를 통해서만 액세스 할 수 있으며, 뮤텍스가 잠겨있을 때만 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37c35fdf98665e8061d3ede706452fcafbf6bf45" translate="yes" xml:space="preserve">
          <source>This mutex will block threads waiting for the lock to become available. The mutex can also be statically initialized or created via a &lt;a href=&quot;struct.mutex#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; constructor. Each mutex has a type parameter which represents the data that it is protecting. The data can only be accessed through the RAII guards returned from &lt;a href=&quot;struct.mutex#method.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;, which guarantees that the data is only ever accessed when the mutex is locked.</source>
          <target state="translated">이 뮤텍스는 잠금을 사용할 수있을 때까지 기다리는 스레드를 차단합니다. 뮤텍스는 정적으로 초기화되거나 &lt;a href=&quot;struct.mutex#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 생성자 를 통해 생성 될 수도 있습니다 . 각 뮤텍스에는 보호중인 데이터를 나타내는 유형 매개 변수가 있습니다. 데이터는 &lt;a href=&quot;struct.mutex#method.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; 에서 반환 된 RAII 가드를 통해서만 액세스 할 수 있으며 , 이는 뮤텍스가 잠겨있을 때만 데이터에 액세스 할 수 있음을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="c6bb4ef8774a69f40318879a20a2f5485ae10af2" translate="yes" xml:space="preserve">
          <source>This never needs to re-allocate, but does need to do &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) data movement if the circular buffer doesn't happen to be at the beginning of the allocation.</source>
          <target state="translated">재 할당 할 필요 는 없지만 순환 버퍼가 할당의 시작 부분에 있지 않으면 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; ) 데이터 이동 을 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="56f3b065f3863bd74d78c00a2522270062418669" translate="yes" xml:space="preserve">
          <source>This never needs to re-allocate, but does need to do O(n) data movement if the circular buffer doesn't happen to be at the beginning of the allocation.</source>
          <target state="translated">이것은 다시 할당 할 필요는 없지만 순환 버퍼가 할당의 시작 부분에 있지 않으면 O (n) 데이터 이동을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="d28b87d734ed0d5315fcb74f17b2994ec84a38d2" translate="yes" xml:space="preserve">
          <source>This new slice goes from &lt;code&gt;begin&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt;, including &lt;code&gt;begin&lt;/code&gt; but excluding &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">이 새로운 슬라이스는 &lt;code&gt;begin&lt;/code&gt; 을 제외한 &lt;code&gt;end&lt;/code&gt; 를 포함하여 &lt;code&gt;begin&lt;/code&gt; 부터 &lt;code&gt;end&lt;/code&gt; 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5e5d3eaf75778ffc4640687e8cefa2e10e75497" translate="yes" xml:space="preserve">
          <source>This next example calls a supertrait method on a generic parameter.</source>
          <target state="translated">다음 예제는 일반 매개 변수에서 수퍼 특성 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="9f7ad17f03d80b97ecff41fe1815f8dca0918d1f" translate="yes" xml:space="preserve">
          <source>This next example gives &lt;code&gt;radius&lt;/code&gt; a default implementation using the &lt;code&gt;area&lt;/code&gt; function from &lt;code&gt;Shape&lt;/code&gt;.</source>
          <target state="translated">다음 예제 에서는 &lt;code&gt;Shape&lt;/code&gt; 의 &lt;code&gt;area&lt;/code&gt; 함수를 사용하여 &lt;code&gt;radius&lt;/code&gt; 에 기본 구현을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="50d4d7072a1ea5b824d1df9626f273fc9c52a75a" translate="yes" xml:space="preserve">
          <source>This number is a lower bound; the &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; might be able to hold more, but is guaranteed to be able to hold at least this many.</source>
          <target state="translated">이 숫자는 하한입니다. &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 더 보유 할 수있을 수도 있지만, 적어도이 많이 보유 할 수 있도록 보장한다.</target>
        </trans-unit>
        <trans-unit id="75625b78a6cc53054a38dc48c604ece0622bfe30" translate="yes" xml:space="preserve">
          <source>This number is simply useful for passing to other methods, like &lt;a href=&quot;struct.osstring#method.with_capacity&quot;&gt;&lt;code&gt;OsString::with_capacity&lt;/code&gt;&lt;/a&gt; to avoid reallocations.</source>
          <target state="translated">이 숫자는 재 할당을 피하기 위해 &lt;a href=&quot;struct.osstring#method.with_capacity&quot;&gt; &lt;code&gt;OsString::with_capacity&lt;/code&gt; &lt;/a&gt; 와 같은 다른 메소드로 전달하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="1f022d625542e31d83b61a7cfb496898fc698f8a" translate="yes" xml:space="preserve">
          <source>This only differs from the previous &lt;code&gt;impl&lt;/code&gt; in that the parameters &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;MyType&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;code&gt;ForeignTrait2&lt;/code&gt; have been swapped. This example does &lt;em&gt;not&lt;/em&gt; violate the orphan rule; it is permitted.</source>
          <target state="translated">&lt;code&gt;ForeignTrait2&lt;/code&gt; 에 대한 매개 변수 &lt;code&gt;T&lt;/code&gt; 및 &lt;code&gt;MyType&amp;lt;T&amp;gt;&lt;/code&gt; 이 바뀌 었다는 점에서 이것은 이전 &lt;code&gt;impl&lt;/code&gt; 과 다릅니다 . 이 예제는 고아 규칙을 위반 하지 &lt;em&gt;않습니다&lt;/em&gt; . 허용됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1833c0a27c1d09954fa6a057a5eb72b9706f31ec" translate="yes" xml:space="preserve">
          <source>This only includes environment variables explicitly set with &lt;a href=&quot;struct.command#method.env&quot;&gt;&lt;code&gt;Command::env&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.command#method.envs&quot;&gt;&lt;code&gt;Command::envs&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.command#method.env_remove&quot;&gt;&lt;code&gt;Command::env_remove&lt;/code&gt;&lt;/a&gt;. It does not include environment variables that will be inherited by the child process.</source>
          <target state="translated">여기에는 &lt;a href=&quot;struct.command#method.env&quot;&gt; &lt;code&gt;Command::env&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.command#method.envs&quot;&gt; &lt;code&gt;Command::envs&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.command#method.env_remove&quot;&gt; &lt;code&gt;Command::env_remove&lt;/code&gt; &lt;/a&gt; 명시 적으로 설정된 환경 변수 만 포함됩니다 . 하위 프로세스에서 상속 할 환경 변수는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="123296246acbbeb137b9c0c76f971008749a56bb" translate="yes" xml:space="preserve">
          <source>This operation does &lt;strong&gt;not&lt;/strong&gt; modify the filesystem. To modify the filesystem use the &lt;a href=&quot;fn.set_permissions&quot;&gt;&lt;code&gt;fs::set_permissions&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 작업은 파일 시스템을 수정 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 파일 시스템을 수정하려면 &lt;a href=&quot;fn.set_permissions&quot;&gt; &lt;code&gt;fs::set_permissions&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7036bf2f2a1e56b239ac49dd49a90706f4ff18c2" translate="yes" xml:space="preserve">
          <source>This operation does &lt;strong&gt;not&lt;/strong&gt; modify the filesystem. To modify the filesystem use the &lt;a href=&quot;fn.set_permissions&quot;&gt;&lt;code&gt;set_permissions&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 작업은 파일 시스템을 수정 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 파일 시스템을 수정하려면 &lt;a href=&quot;fn.set_permissions&quot;&gt; &lt;code&gt;set_permissions&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c0bbc4d892938033fbacd4684ea2a287c924f8c" translate="yes" xml:space="preserve">
          <source>This operation is &lt;code&gt;O(1)&lt;/code&gt;.</source>
          <target state="translated">이 작업은 &lt;code&gt;O(1)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dd1a487434fc87832e2f1a787954854ff60dfa9b" translate="yes" xml:space="preserve">
          <source>This operation is &lt;em&gt;O&lt;/em&gt;(1).</source>
          <target state="translated">이 작업은 &lt;em&gt;O&lt;/em&gt; (1)입니다.</target>
        </trans-unit>
        <trans-unit id="1fdec81639aa08f036b813714ac253cba45f17ed" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called 'reduce' or 'inject'.</source>
          <target state="translated">이 작업을 때때로 '감소'또는 '주입'이라고합니다.</target>
        </trans-unit>
        <trans-unit id="c8451edf8bf7bc5bb1bf0555fcc9a5705a25da14" translate="yes" xml:space="preserve">
          <source>This operation performs an unconditional mapping without tailoring. That is, the conversion is independent of context and language.</source>
          <target state="translated">이 작업은 조정없이 무조건 매핑을 수행합니다. 즉, 변환은 컨텍스트 및 언어와 무관합니다.</target>
        </trans-unit>
        <trans-unit id="e2fd1d86e77ef341cc160d32009392653fd89ec1" translate="yes" xml:space="preserve">
          <source>This operation rounds towards zero, truncating any fractional part of the exact result.</source>
          <target state="translated">이 연산은 0으로 반올림하여 정확한 결과의 일부를 잘라냅니다.</target>
        </trans-unit>
        <trans-unit id="77029037758bda804fd792f27ba1f29cea457a7e" translate="yes" xml:space="preserve">
          <source>This operation satisfies &lt;code&gt;n % d == n - (n / d) * d&lt;/code&gt;. The result has the same sign as the left operand.</source>
          <target state="translated">이 연산은 &lt;code&gt;n % d == n - (n / d) * d&lt;/code&gt; 충족시킵니다 . 결과는 왼쪽 피연산자와 같은 부호를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="bdbe7ca28eb7e43951e771605b8bd474b48c29e7" translate="yes" xml:space="preserve">
          <source>This operation should compute in &lt;em&gt;O&lt;/em&gt;(1) time and &lt;em&gt;O&lt;/em&gt;(1) memory.</source>
          <target state="translated">이 연산은 &lt;em&gt;O&lt;/em&gt; (1) 시간과 &lt;em&gt;O&lt;/em&gt; (1) 메모리 에서 계산해야 합니다.</target>
        </trans-unit>
        <trans-unit id="43df87c6439b0a85582f9e67d3c1fce146118f3d" translate="yes" xml:space="preserve">
          <source>This operation should compute in &lt;em&gt;O&lt;/em&gt;(1) time.</source>
          <target state="translated">이 연산은 &lt;em&gt;O&lt;/em&gt; (1) 시간에 계산되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0d494ef70142bea4ddf2b4f6d9f09545f47dd54e" translate="yes" xml:space="preserve">
          <source>This operation should compute in &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) time.</source>
          <target state="translated">이 연산은 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; ) 시간에 계산해야합니다 .</target>
        </trans-unit>
        <trans-unit id="48c9bdd59dbbaca42da37bc9d33eec68b2af8961" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(1) time and O(1) memory.</source>
          <target state="translated">이 작업은 O (1) 시간과 O (1) 메모리로 계산해야합니다.</target>
        </trans-unit>
        <trans-unit id="fc7c0f50f52c35ea7e364b7e26d103277ce95b38" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(1) time.</source>
          <target state="translated">이 작업은 O (1) 시간으로 계산되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a13a41f53da524732e21aa1da4b3958def62f00f" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(n) time.</source>
          <target state="translated">이 작업은 O (n) 시간으로 계산해야합니다.</target>
        </trans-unit>
        <trans-unit id="4da5d428cc5f4bb1f1eadb7b45f2669f2c6be87e" translate="yes" xml:space="preserve">
          <source>This operation was interrupted.</source>
          <target state="translated">이 작업이 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="e5b25bf34db3082fbebf881dd2f3b63132ce24a9" translate="yes" xml:space="preserve">
          <source>This operation wraps around on overflow.</source>
          <target state="translated">이 작업은 오버플로로 래핑됩니다.</target>
        </trans-unit>
        <trans-unit id="513292ffc7d15c4c6459299bf349f4e8ef41bcc6" translate="yes" xml:space="preserve">
          <source>This option defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 옵션의 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="07732c105324f285891b421be7b1897cf45eb1a8" translate="yes" xml:space="preserve">
          <source>This option indicates whether a new file will be created if the file does not yet already exist.</source>
          <target state="translated">이 옵션은 파일이 아직없는 경우 새 파일을 만들지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2ab719a36168121ae6911773d2659e3887ae7b87" translate="yes" xml:space="preserve">
          <source>This option indicates whether a new file will be created. No file is allowed to exist at the target location, also no (dangling) symlink.</source>
          <target state="translated">이 옵션은 새 파일을 만들지 여부를 나타냅니다. 대상 위치에 파일이 존재하지 않으며 (댕글 링) 심볼릭 링크도 없습니다.</target>
        </trans-unit>
        <trans-unit id="1997355865e9c95bba24957f07adb48aa7900b34" translate="yes" xml:space="preserve">
          <source>This option is useful because it is atomic. Otherwise between checking whether a file exists and creating a new one, the file may have been created by another process (a TOCTOU race condition / attack).</source>
          <target state="translated">이 옵션은 원자 적이기 때문에 유용합니다. 그렇지 않으면 파일이 존재하는지 확인하고 새 파일을 작성하는 사이에 다른 프로세스 (TOCTOU 경쟁 조건 / 공격)에 의해 파일이 작성되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d1d1f446736eda75bb94ad6c4911fc032b1110f" translate="yes" xml:space="preserve">
          <source>This option, when true, means that writes will append to a file instead of overwriting previous contents. Note that setting &lt;code&gt;.write(true).append(true)&lt;/code&gt; has the same effect as setting only &lt;code&gt;.append(true)&lt;/code&gt;.</source>
          <target state="translated">이 옵션이 true이면 쓰기가 이전 내용을 덮어 쓰지 않고 파일에 추가됨을 의미합니다. 설정주의 &lt;code&gt;.write(true).append(true)&lt;/code&gt; 만을 설정하는 것과 같은 효과가있다 &lt;code&gt;.append(true)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="279fd5d225ffc9cf4a6694f03d2272dc1973056a" translate="yes" xml:space="preserve">
          <source>This option, when true, will indicate that the file should be &lt;code&gt;read&lt;/code&gt;-able if opened.</source>
          <target state="translated">이 옵션이 true 인 경우 파일을 열면 파일을 &lt;code&gt;read&lt;/code&gt; 수 있어야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="2aa691cde7b75893eb561d3865c9d79612f73f71" translate="yes" xml:space="preserve">
          <source>This option, when true, will indicate that the file should be &lt;code&gt;write&lt;/code&gt;-able if opened.</source>
          <target state="translated">이 옵션은 true 인 경우 파일을 열면 &lt;code&gt;write&lt;/code&gt; 해야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="42af0ae9cc5372b7ccd519ad313f0abe9e0cfe15" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that can perform a load.</source>
          <target state="translated">이 순서는로드를 수행 할 수있는 작업에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="20a3da5b9e12d0ccdf3e64c2e589466b4721fced" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that can perform a store.</source>
          <target state="translated">이 주문은 상점을 수행 할 수있는 조작에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ea76b31c997f4d8a61f17e8560093311b945344f" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that combine both loads and stores.</source>
          <target state="translated">이 주문은로드와 저장을 모두 결합하는 조작에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a87804f30fcdf78425015d26ec12efca3e1a08c7" translate="yes" xml:space="preserve">
          <source>This output is better: we now have a reasonable error message. However, we also have extraneous information we don&amp;rsquo;t want to give to our users. Perhaps using the technique we used in Listing 9-10 isn&amp;rsquo;t the best to use here: a call to &lt;code&gt;panic!&lt;/code&gt; is more appropriate for a programming problem than a usage problem, &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#guidelines-for-error-handling&quot;&gt;as discussed in Chapter 9&lt;/a&gt;. Instead, we can use the other technique you learned about in Chapter 9&amp;mdash;&lt;a href=&quot;ch09-02-recoverable-errors-with-result&quot;&gt;returning a &lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; that indicates either success or an error.</source>
          <target state="translated">이 출력이 더 좋습니다 : 이제 합리적인 오류 메시지가 나타납니다. 그러나 사용자에게 제공하고 싶지 않은 정보도 있습니다. 아마도 우리가 Listing 9-10에서 사용한 기술을 사용하는 것이 여기에 사용하기에 가장 좋은 것은 아닙니다 &lt;code&gt;panic!&lt;/code&gt; &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#guidelines-for-error-handling&quot;&gt;9 장에서 논의 된 것처럼&lt;/a&gt; 사용 문제보다 프로그래밍 문제에 더 적합합니다 . 대신 9 장에서 배운 다른 기술인 성공 또는 오류를 나타내는 &lt;a href=&quot;ch09-02-recoverable-errors-with-result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04051f730c7eeba40e7dd9250f9fd3ae55f310b9" translate="yes" xml:space="preserve">
          <source>This output isn&amp;rsquo;t what we wanted. We want to call the &lt;code&gt;baby_name&lt;/code&gt; function that is part of the &lt;code&gt;Animal&lt;/code&gt; trait that we implemented on &lt;code&gt;Dog&lt;/code&gt; so the code prints &lt;code&gt;A baby dog is called a puppy&lt;/code&gt;. The technique of specifying the trait name that we used in Listing 19-18 doesn&amp;rsquo;t help here; if we change &lt;code&gt;main&lt;/code&gt; to the code in Listing 19-20, we&amp;rsquo;ll get a compilation error.</source>
          <target state="translated">이 결과는 우리가 원하는 것이 아닙니다. 우리는 &lt;code&gt;Dog&lt;/code&gt; 에 구현 한 &lt;code&gt;Animal&lt;/code&gt; 특성의 일부인 &lt;code&gt;baby_name&lt;/code&gt; 함수 를 호출하여 코드를 인쇄 &lt;code&gt;A baby dog is called a puppy&lt;/code&gt; 합니다 . baby dog는 강아지라고합니다 . Listing 19-18에서 사용한 특성 이름을 지정하는 기술은 여기서 도움이되지 않습니다. Listing 19-20의 코드로 &lt;code&gt;main&lt;/code&gt; 을 변경 하면 컴파일 오류가 발생한다.</target>
        </trans-unit>
        <trans-unit id="66b4788ea5425d4692dd1ffafd058fec8508d60c" translate="yes" xml:space="preserve">
          <source>This output shows &lt;code&gt;cargo test&lt;/code&gt; only ran the tests for the &lt;code&gt;add-one&lt;/code&gt; crate and didn&amp;rsquo;t run the &lt;code&gt;adder&lt;/code&gt; crate tests.</source>
          <target state="translated">이 출력은 &lt;code&gt;cargo test&lt;/code&gt; 에서 &lt;code&gt;add-one&lt;/code&gt; 크레이트에 대한 테스트 만 실행했으며 &lt;code&gt;adder&lt;/code&gt; 크레이트 테스트 는 실행하지 않았 음을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="f91d4073e1806ac4e46d9be9407b7439ade530c5" translate="yes" xml:space="preserve">
          <source>This outputs:</source>
          <target state="translated">이 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="220a338b4d08066eba2a22fb127e73c40665ebcb" translate="yes" xml:space="preserve">
          <source>This overwrites pinned data, but that is okay: its destructor gets run before being overwritten, so no pinning guarantee is violated.</source>
          <target state="translated">이것은 고정 된 데이터를 덮어 쓰지만 괜찮습니다. 소멸자가 덮어 쓰기 전에 실행되므로 고정 보장이 위반되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05caefb888af241727a56b286e8ae483a7d9633f" translate="yes" xml:space="preserve">
          <source>This page documents the formal specification of the follow rules for &lt;a href=&quot;macros-by-example&quot;&gt;Macros By Example&lt;/a&gt;. They were originally specified in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.html&quot;&gt;RFC 550&lt;/a&gt;, from which the bulk of this text is copied, and expanded upon in subsequent RFCs.</source>
          <target state="translated">이 페이지는 &lt;a href=&quot;macros-by-example&quot;&gt;Macros By Example에&lt;/a&gt; 대한 다음 규칙의 공식 사양을 설명합니다 . 그것들은 원래 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.html&quot;&gt;RFC 550에&lt;/a&gt; 지정되었으며 ,이 텍스트의 대부분이 복사되고 후속 RFC에서 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="3b9633b5692298146f03a49947c6dcff6df1f7b9" translate="yes" xml:space="preserve">
          <source>This page documents the formal specification of the follow rules for &lt;a href=&quot;macros-by-example&quot;&gt;Macros By Example&lt;/a&gt;. They were originally specified in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md&quot;&gt;RFC 550&lt;/a&gt;, from which the bulk of this text is copied, and expanded upon in subsequent RFCs.</source>
          <target state="translated">이 페이지는 &lt;a href=&quot;macros-by-example&quot;&gt;예제 별 매크로&lt;/a&gt; 에 대한 다음 규칙의 공식 사양을 문서화합니다 . 원래 는이 텍스트의 대부분이 복사되고 후속 RFC에서 확장되는 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md&quot;&gt;RFC 550&lt;/a&gt; 에서 지정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f87b1d9607de86149c082e3d8de19453e0048df2" translate="yes" xml:space="preserve">
          <source>This pattern has a profound impact on the way Rust code is written. It may seem simple right now, but the behavior of code can be unexpected in more complicated situations when we want to have multiple variables use the data we&amp;rsquo;ve allocated on the heap. Let&amp;rsquo;s explore some of those situations now.</source>
          <target state="translated">이 패턴은 Rust 코드 작성 방식에 중대한 영향을 미칩니다. 지금은 단순 해 보일 수 있지만 더 복잡한 상황에서는 여러 변수가 힙에 할당 한 데이터를 사용하도록하려는 경우 코드 동작이 예상치 못한 것일 수 있습니다. 이러한 상황 중 일부를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ebae1cd81adce77daea1f3e37e663633c554fab5" translate="yes" xml:space="preserve">
          <source>This pattern is about separating concerns: &lt;em&gt;main.rs&lt;/em&gt; handles running the program, and &lt;em&gt;lib.rs&lt;/em&gt; handles all the logic of the task at hand. Because you can&amp;rsquo;t test the &lt;code&gt;main&lt;/code&gt; function directly, this structure lets you test all of your program&amp;rsquo;s logic by moving it into functions in &lt;em&gt;lib.rs&lt;/em&gt;. The only code that remains in &lt;em&gt;main.rs&lt;/em&gt; will be small enough to verify its correctness by reading it. Let&amp;rsquo;s rework our program by following this process.</source>
          <target state="translated">이 패턴은 우려를 분리하는 것에 관한 것입니다 : &lt;em&gt;main.rs&lt;/em&gt; 는 프로그램 실행을 처리하고 &lt;em&gt;lib.rs&lt;/em&gt; 는 작업의 모든 논리를 처리합니다. 당신이 테스트 할 수 없기 때문에 &lt;code&gt;main&lt;/code&gt; 직접 기능을,이 구조는 당신이 함수로 이동하여 프로그램의 로직을 모두 테스트 할 수 있습니다 &lt;em&gt;lib.rs&lt;/em&gt; . &lt;em&gt;main.rs에&lt;/em&gt; 남아있는 유일한 코드는 코드를 읽고 정확성을 확인할 수있을 정도로 작습니다. 이 과정에 따라 프로그램을 재 작업하겠습니다.</target>
        </trans-unit>
        <trans-unit id="4f7fef1aec609824d9a98cbd4986f806fb8112f5" translate="yes" xml:space="preserve">
          <source>This pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">이 패턴은 하위 패턴 중 하나가 반박 가능한 경우 반박 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8e7824ffc5e192a74a0014b97fd199a69a9bbad1" translate="yes" xml:space="preserve">
          <source>This pattern of propagating errors is so common in Rust that Rust provides the question mark operator &lt;code&gt;?&lt;/code&gt; to make this easier.</source>
          <target state="translated">이러한 전파 오류 패턴은 Rust에서 매우 일반적이므로 Rust는 물음표 연산자를 제공 &lt;code&gt;?&lt;/code&gt; 이것을 쉽게하기 위해.</target>
        </trans-unit>
        <trans-unit id="be8e420bedd2fafb3e2ace598d4c2a4fc61a219a" translate="yes" xml:space="preserve">
          <source>This performs complex unconditional mappings with no tailoring: it maps one Unicode character to its lowercase equivalent according to the &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;Unicode database&lt;/a&gt; and the additional complex mappings &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;. Conditional mappings (based on context or language) are not considered here.</source>
          <target state="translated">이는 조정없이 복잡한 무조건 맵핑을 수행합니다. 이는 &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;유니 코드 데이터베이스&lt;/a&gt; 및 추가 복합 맵핑 &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt; &lt;code&gt;SpecialCasing.txt&lt;/code&gt; &lt;/a&gt; 에 따라 하나의 유니 코드 문자를 소문자로 맵핑합니다 . 여기에서는 문맥 또는 언어를 기반으로하는 조건부 매핑을 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2bedef26ecd391020afcece167562372d74e3b11" translate="yes" xml:space="preserve">
          <source>This performs complex unconditional mappings with no tailoring: it maps one Unicode character to its uppercase equivalent according to the &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;Unicode database&lt;/a&gt; and the additional complex mappings &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;. Conditional mappings (based on context or language) are not considered here.</source>
          <target state="translated">이는 조정없이 복잡한 무조건 맵핑을 수행합니다. 이는 &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;유니 코드 데이터베이스&lt;/a&gt; 및 추가 복합 맵핑 &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt; &lt;code&gt;SpecialCasing.txt&lt;/code&gt; &lt;/a&gt; 에 따라 하나의 유니 코드 문자를 대문자로 맵핑합니다 . 여기에서는 문맥 또는 언어를 기반으로하는 조건부 매핑을 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="367fd59cc7a5ce52d6910a709b90bfcbe81a7ab5" translate="yes" xml:space="preserve">
          <source>This piece of Rust history is relevant because it&amp;rsquo;s possible that more deterministic patterns will emerge and be added to the compiler. In the future, even fewer lifetime annotations might be required.</source>
          <target state="translated">이 Rust 히스토리는 더 결정적인 패턴이 나타나고 컴파일러에 추가 될 수 있기 때문에 관련이 있습니다. 앞으로는 더 적은 수명의 주석이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d1e98917aa47fb301eb32dc85055855554e0b37" translate="yes" xml:space="preserve">
          <source>This pinned future is then polled by calling the &lt;a href=&quot;../../std/future/trait.future#tymethod.poll&quot;&gt;&lt;code&gt;Future::poll&lt;/code&gt;&lt;/a&gt; method and passing it the current &lt;a href=&quot;#task-context&quot;&gt;task context&lt;/a&gt;;</source>
          <target state="translated">이 고정 된 future는 &lt;a href=&quot;../../std/future/trait.future#tymethod.poll&quot;&gt; &lt;code&gt;Future::poll&lt;/code&gt; &lt;/a&gt; 메서드 를 호출 하고 현재 &lt;a href=&quot;#task-context&quot;&gt;작업 컨텍스트에&lt;/a&gt; 전달하여 폴링 됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce7cedc5fc51216f120f0eb8fae3379dc963620e" translate="yes" xml:space="preserve">
          <source>This prints output like:</source>
          <target state="translated">다음과 같은 출력을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="ff9f7a5e1d4525cd7d8438461ac9c53da48b455e" translate="yes" xml:space="preserve">
          <source>This prints to &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt;:</source>
          <target state="translated">이것은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr에&lt;/a&gt; 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="3c9f3b33a54ec1f8657331a04066cc462bed4e33" translate="yes" xml:space="preserve">
          <source>This problem can be solved by specifying from which trait we want to use the &lt;code&gt;Bar&lt;/code&gt; type:</source>
          <target state="translated">이 유형 은 &lt;code&gt;Bar&lt;/code&gt; 유형 을 사용하려는 특성을 지정하여 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc4e53a566f64cd7b3bd5c8e48b6dab0075560d7" translate="yes" xml:space="preserve">
          <source>This process does not take into account the mutability or lifetime of the receiver, or whether a method is &lt;code&gt;unsafe&lt;/code&gt;. Once a method is looked up, if it can't be called for one (or more) of those reasons, the result is a compiler error.</source>
          <target state="translated">이 프로세스는 수신자의 가변성 또는 수명 또는 메소드가 &lt;code&gt;unsafe&lt;/code&gt; 않은지 여부를 고려하지 않습니다 . 메소드를 찾은 후 이러한 이유 중 하나 이상으로 호출 할 수없는 경우 결과는 컴파일러 오류입니다.</target>
        </trans-unit>
        <trans-unit id="1ff3edc7107794fccb9370413ce9f2edb3d33555" translate="yes" xml:space="preserve">
          <source>This process is just one of many ways to write software, but TDD can help drive code design as well. Writing the test before you write the code that makes the test pass helps to maintain high test coverage throughout the process.</source>
          <target state="translated">이 프로세스는 소프트웨어를 작성하는 여러 가지 방법 중 하나 일 뿐이지 만 TDD는 코드 설계를 지원할 수 있습니다. 테스트를 통과시키는 코드를 작성하기 전에 테스트를 작성하면 프로세스 전체에서 높은 테스트 범위를 유지하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="2a5870cc6149419aa4b701948d1d720f8c2eb21c" translate="yes" xml:space="preserve">
          <source>This program compiles without any errors and would also do so if we used &lt;code&gt;word&lt;/code&gt; after calling &lt;code&gt;s.clear()&lt;/code&gt;. Because &lt;code&gt;word&lt;/code&gt; isn&amp;rsquo;t connected to the state of &lt;code&gt;s&lt;/code&gt; at all, &lt;code&gt;word&lt;/code&gt; still contains the value &lt;code&gt;5&lt;/code&gt;. We could use that value &lt;code&gt;5&lt;/code&gt; with the variable &lt;code&gt;s&lt;/code&gt; to try to extract the first word out, but this would be a bug because the contents of &lt;code&gt;s&lt;/code&gt; have changed since we saved &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;word&lt;/code&gt;.</source>
          <target state="translated">이 프로그램은 오류없이 컴파일되며 &lt;code&gt;s.clear()&lt;/code&gt; 호출 한 후 &lt;code&gt;word&lt;/code&gt; 를 사용하면 컴파일됩니다 . 때문에 &lt;code&gt;word&lt;/code&gt; 의 상태에 연결되어 있지 &lt;code&gt;s&lt;/code&gt; 모든에서, &lt;code&gt;word&lt;/code&gt; 여전히 값 포함 &lt;code&gt;5&lt;/code&gt; . 우리는 그 값을 사용할 수 있습니다 &lt;code&gt;5&lt;/code&gt; 변수와 &lt;code&gt;s&lt;/code&gt; 첫 번째 단어를 추출하려고하지만, 내용 때문에 버그 것 &lt;code&gt;s&lt;/code&gt; 변경되었습니다 우리가 구원 이후 &lt;code&gt;5&lt;/code&gt; 에 &lt;code&gt;word&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1a216c5bb2240db271ccf5242339067640e2983" translate="yes" xml:space="preserve">
          <source>This program creates a tuple, &lt;code&gt;x&lt;/code&gt;, and then makes new variables for each element by using their index. As with most programming languages, the first index in a tuple is 0.</source>
          <target state="translated">이 프로그램은 튜플 &lt;code&gt;x&lt;/code&gt; 를 만든 다음 색인을 사용하여 각 요소에 대해 새 변수를 만듭니다. 대부분의 프로그래밍 언어와 마찬가지로 튜플의 첫 번째 인덱스는 0입니다.</target>
        </trans-unit>
        <trans-unit id="a953795409deaf59d9e6550cf24f5329cf86ee13" translate="yes" xml:space="preserve">
          <source>This program creates a tuple, &lt;code&gt;x&lt;/code&gt;, and then makes new variables for each element by using their respective indices. As with most programming languages, the first index in a tuple is 0.</source>
          <target state="translated">이 프로그램은 튜플 &lt;code&gt;x&lt;/code&gt; 를 만든 다음 해당 인덱스를 사용하여 각 요소에 대한 새 변수를 만듭니다. 대부분의 프로그래밍 언어와 마찬가지로 튜플의 첫 번째 인덱스는 0입니다.</target>
        </trans-unit>
        <trans-unit id="052f0899e565e8d2644e743be0e56bf26e6e1767" translate="yes" xml:space="preserve">
          <source>This program first binds &lt;code&gt;x&lt;/code&gt; to a value of &lt;code&gt;5&lt;/code&gt;. Then it shadows &lt;code&gt;x&lt;/code&gt; by repeating &lt;code&gt;let x =&lt;/code&gt;, taking the original value and adding &lt;code&gt;1&lt;/code&gt; so the value of &lt;code&gt;x&lt;/code&gt; is then &lt;code&gt;6&lt;/code&gt;. The third &lt;code&gt;let&lt;/code&gt; statement also shadows &lt;code&gt;x&lt;/code&gt;, multiplying the previous value by &lt;code&gt;2&lt;/code&gt; to give &lt;code&gt;x&lt;/code&gt; a final value of &lt;code&gt;12&lt;/code&gt;. When we run this program, it will output the following:</source>
          <target state="translated">이 프로그램은 먼저 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;5&lt;/code&gt; 값에 바인딩 합니다. 그런 다음 &lt;code&gt;let x =&lt;/code&gt; 를 반복 하여 원래 값을 취하고 &lt;code&gt;1&lt;/code&gt; 을 추가하여 &lt;code&gt;x&lt;/code&gt; 의 값이 &lt;code&gt;6&lt;/code&gt; 이 되도록하여 &lt;code&gt;x&lt;/code&gt; 를 음영 처리 합니다. 세 번째 &lt;code&gt;let&lt;/code&gt; 문은 &lt;code&gt;x&lt;/code&gt; 를 음영 처리 하여 이전 값에 &lt;code&gt;2&lt;/code&gt; 를 곱하여 &lt;code&gt;x&lt;/code&gt; 에 최종 값 &lt;code&gt;12&lt;/code&gt; 를 제공 합니다. 이 프로그램을 실행하면 다음이 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="e37eff19d0df592c13224ef2e32fd74387b55f9e" translate="yes" xml:space="preserve">
          <source>This program first creates a tuple and binds it to the variable &lt;code&gt;tup&lt;/code&gt;. It then uses a pattern with &lt;code&gt;let&lt;/code&gt; to take &lt;code&gt;tup&lt;/code&gt; and turn it into three separate variables, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;. This is called &lt;em&gt;destructuring&lt;/em&gt;, because it breaks the single tuple into three parts. Finally, the program prints the value of &lt;code&gt;y&lt;/code&gt;, which is &lt;code&gt;6.4&lt;/code&gt;.</source>
          <target state="translated">이 프로그램은 먼저 튜플을 만들어 변수 &lt;code&gt;tup&lt;/code&gt; 에 바인딩합니다 . 그런 다음 &lt;code&gt;let&lt;/code&gt; 을 사용하여 &lt;code&gt;tup&lt;/code&gt; 패턴을 사용하여 세 개의 개별 변수 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 로 바꿉니다 . 이것은 단일 터플을 세 부분으로 나누기 때문에 &lt;em&gt;destructuring&lt;/em&gt; 이라고 합니다. 마지막으로,이 프로그램의 출력 값 &lt;code&gt;y&lt;/code&gt; 이며, &lt;code&gt;6.4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e68e59981686f4d6d9628e4a0f06c39a18431f20" translate="yes" xml:space="preserve">
          <source>This program has four possible paths it can take. After running it, you should see the following output:</source>
          <target state="translated">이 프로그램에는 가능한 4 가지 경로가 있습니다. 실행 한 후 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c268368ea9194ea4e99d8e793596c3443d5a9397" translate="yes" xml:space="preserve">
          <source>This project was a hands-on way to introduce you to many new Rust concepts: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;match&lt;/code&gt;, methods, associated functions, the use of external crates, and more. In the next few chapters, you&amp;rsquo;ll learn about these concepts in more detail. Chapter 3 covers concepts that most programming languages have, such as variables, data types, and functions, and shows how to use them in Rust. Chapter 4 explores ownership, a feature that makes Rust different from other languages. Chapter 5 discusses structs and method syntax, and Chapter 6 explains how enums work.</source>
          <target state="translated">이 프로젝트는 &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;match&lt;/code&gt; , 메소드, 관련 함수, 외부 상자 사용 등과 같은 많은 새로운 Rust 개념을 소개하는 실제 방법이었습니다. 다음 몇 장에서는 이러한 개념에 대해 자세히 설명합니다. 3 장에서는 변수, 데이터 유형 및 함수와 같은 대부분의 프로그래밍 언어가 갖고있는 개념을 다루고 Rust에서이를 사용하는 방법을 보여줍니다. 4 장에서는 Rust를 다른 언어와 차별화하는 기능인 소유권에 대해 설명합니다. 5 장에서는 구조체와 메서드 구문에 대해 설명하고 6 장에서는 열거 형 작동 방식에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9ce38c4decb31cc4f3034ac7fae7c79d93e80f53" translate="yes" xml:space="preserve">
          <source>This property cannot be checked by the compiler, and therefore &lt;code&gt;Eq&lt;/code&gt; implies &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, and has no extra methods.</source>
          <target state="translated">이 속성은 컴파일러에서 확인할 수 없으므로 &lt;code&gt;Eq&lt;/code&gt; 는 &lt;a href=&quot;trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; 를&lt;/a&gt; 의미 하며 추가 메서드가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ab41f4f49ac9b596f3ff341e670c3c513d2c2a1e" translate="yes" xml:space="preserve">
          <source>This property cannot be checked by the compiler, and therefore &lt;code&gt;Eq&lt;/code&gt; implies &lt;code&gt;PartialEq&lt;/code&gt;, and has no extra methods.</source>
          <target state="translated">이 속성은 컴파일러에서 확인할 수 없으므로 &lt;code&gt;Eq&lt;/code&gt; 는 &lt;code&gt;PartialEq&lt;/code&gt; 를 암시 하며 추가 메서드는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1608442363fd58986072b46f4e6a650827d3385c" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1122&quot;&gt;IETF RFC 1122&lt;/a&gt;.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;https://tools.ietf.org/html/rfc1122&quot;&gt;IETF RFC 1122에&lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="25a4736ccf9a4ba3c3e3dac30177800bc1f743c9" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc3927&quot;&gt;IETF RFC 3927&lt;/a&gt;.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;https://tools.ietf.org/html/rfc3927&quot;&gt;IETF RFC 3927에&lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="2cdf66b6082611e25a822825249d22e6f28f1917" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;.</source>
          <target state="translated">이 특성은 &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291에&lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="93af0d07e68cafd035375823424d1e725ddb07d1" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3849&quot;&gt;IETF RFC 3849&lt;/a&gt;.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;https://tools.ietf.org/html/rfc3849&quot;&gt;IETF RFC 3849에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="85df454e96ffa6c63ed8ab37d8086b690c9dba86" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4193&quot;&gt;IETF RFC 4193&lt;/a&gt;.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;https://tools.ietf.org/html/rfc4193&quot;&gt;IETF RFC 4193에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d5a4dec1164aed352e96ad9af690b1a3591dc76" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c731a3c6e670f4842c76f756fa1e0f4c4f1cfae6" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;em&gt;UNIX Network Programming, Second Edition&lt;/em&gt;, W. Richard Stevens, p. 891; see also &lt;a href=&quot;http://man7.org/linux/man-pages/man7/ip.7.html&quot;&gt;ip7&lt;/a&gt;.</source>
          <target state="translated">이 속성은 &lt;em&gt;UNIX 네트워크 프로그래밍, 제 2 판&lt;/em&gt; , W. Richard Stevens, p. 891; &lt;a href=&quot;http://man7.org/linux/man-pages/man7/ip.7.html&quot;&gt;ip7&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="19926d7df32802514fef095810b287a92fa4b874" translate="yes" xml:space="preserve">
          <source>This queue has &lt;code&gt;O(1)&lt;/code&gt; amortized inserts and removals from both ends of the container. It also has &lt;code&gt;O(1)&lt;/code&gt; indexing like a vector. The contained elements are not required to be copyable, and the queue will be sendable if the contained type is sendable.</source>
          <target state="translated">이 대기열에는 컨테이너의 양쪽 끝에서 &lt;code&gt;O(1)&lt;/code&gt; 상각 삽입 및 제거가 있습니다. 또한 벡터처럼 &lt;code&gt;O(1)&lt;/code&gt; 인덱싱이 있습니다. 포함 된 요소는 복사 할 필요가 없으며 포함 된 유형을 보낼 수있는 경우 큐를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f222b6950bf888a7c8ce05739a640f15b3f1b84f" translate="yes" xml:space="preserve">
          <source>This queue has &lt;em&gt;O&lt;/em&gt;(1) amortized inserts and removals from both ends of the container. It also has &lt;em&gt;O&lt;/em&gt;(1) indexing like a vector. The contained elements are not required to be copyable, and the queue will be sendable if the contained type is sendable.</source>
          <target state="translated">이 대기열에는 컨테이너의 양쪽 끝에서 &lt;em&gt;O&lt;/em&gt; (1) 개의 상각 된 삽입 및 제거가 있습니다. 또한 벡터와 같은 &lt;em&gt;O&lt;/em&gt; (1) 인덱싱이 있습니다. 포함 된 요소는 복사 가능할 필요가 없으며 포함 된 유형이 전송 가능한 경우 큐를 전송할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae16a9ff1b9b0bb4dc2773f7faab160bd7347257" translate="yes" xml:space="preserve">
          <source>This reader has reached its &quot;end of file&quot; and will likely no longer be able to produce bytes. Note that this does not mean that the reader will &lt;em&gt;always&lt;/em&gt; no longer be able to produce bytes.</source>
          <target state="translated">이 독자는 &quot;파일 끝&quot;에 도달하여 더 이상 바이트를 생성 할 수 없습니다. 참고이 독자는 것을 의미하지 않는다는 것을 &lt;em&gt;항상&lt;/em&gt; 더 이상 바이트를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eabbe1cac74b5970cf00777c8a04a9b08b503051" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the comparator function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided comparator function.</source>
          <target state="translated">이 재정렬에는 비교 함수를 사용하여 위치 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 모든 값이 위치 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 임의의 값보다 작거나 같다는 추가 특성 이 있습니다 . 또한,이 재정렬은 불안정합니다 (즉, 동일한 수의 동일한 요소가 위치 &lt;code&gt;index&lt;/code&gt; 에서 끝날 수 있음 ), 적절한 위치 (즉, 할당되지 않음) 및 &lt;code&gt;O(n)&lt;/code&gt; 최악의 경우. 이 기능은 다른 라이브러리에서 &quot;kth element&quot;라고도합니다. 제공된 비교기 함수를 사용하여 지정된 색인의 값보다 작은 모든 요소, 지정된 색인의 값 및 주어진 색인의 값보다 큰 모든 요소의 트리플렛을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5a5e3f81a187820f825f4369ca83b2c286d9273d" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the comparator function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided comparator function.</source>
          <target state="translated">이 재정렬에는 comparator 함수를 사용하여 위치 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 값이 위치 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 값보다 작거나 같다는 추가 속성 이 있습니다 . 추가적으로,이 재정렬은 불안정하고 (즉, 동일한 요소의 수가 위치 &lt;code&gt;index&lt;/code&gt; 에서 끝날 수 있음 ), 제자리 (즉, 할당하지 않음) 및 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; ) 최악의 경우입니다. 이 함수는 다른 라이브러리에서 &quot;k 번째 요소&quot;라고도합니다. 제공된 비교기 함수를 사용하여 주어진 인덱스의 값보다 작은 모든 요소, 주어진 인덱스의 값, 주어진 인덱스의 값보다 큰 모든 요소의 세 가지 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="58333e6fd2204efb6d059b5e0ebaa3ad2ae11cea" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the key extraction function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided key extraction function.</source>
          <target state="translated">이 재정렬에는 키 추출 기능을 사용하여 위치 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 모든 값이 위치 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 임의의 값보다 작거나 같은 추가 속성 이 있습니다 . 또한,이 재정렬은 불안정합니다 (즉, 동일한 수의 동일한 요소가 위치 &lt;code&gt;index&lt;/code&gt; 에서 끝날 수 있음 ), 적절한 위치 (즉, 할당되지 않음) 및 &lt;code&gt;O(n)&lt;/code&gt; 최악의 경우. 이 기능은 다른 라이브러리에서 &quot;kth element&quot;라고도합니다. 제공된 키 추출 함수를 사용하여 지정된 색인의 값보다 작은 모든 요소, 지정된 색인의 값 및 주어진 색인의 값보다 큰 모든 요소의 트리플렛을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c83a0af8a141703ce8a894f271d81b6b5d0d2d99" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the key extraction function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided key extraction function.</source>
          <target state="translated">이 재정렬에는 키 추출 기능을 사용하여 위치 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 값이 위치 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 값보다 작거나 같다는 추가 속성 이 있습니다 . 추가적으로,이 재정렬은 불안정하고 (즉, 동일한 요소의 수가 위치 &lt;code&gt;index&lt;/code&gt; 에서 끝날 수 있음 ), 제자리 (즉, 할당하지 않음) 및 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; ) 최악의 경우입니다. 이 함수는 다른 라이브러리에서 &quot;k 번째 요소&quot;라고도합니다. 제공된 키 추출 함수를 사용하여 주어진 인덱스의 값보다 작은 모든 요소, 지정된 인덱스의 값, 지정된 인덱스의 값보다 큰 모든 요소의 세 가지 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="18b0ecb2451beab6446b7792a5f32ac5b93e64f7" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt;. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also/ known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index.</source>
          <target state="translated">이 재정렬에는 위치 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 값이 위치 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 값보다 작거나 같은 추가 속성 이 있습니다 . 또한,이 재정렬은 불안정합니다 (즉, 동일한 수의 동일한 요소가 위치 &lt;code&gt;index&lt;/code&gt; 에서 끝날 수 있음 ), 적절한 위치 (즉, 할당되지 않음) 및 &lt;code&gt;O(n)&lt;/code&gt; 최악의 경우. 이 기능은 다른 라이브러리에서 &quot;kth element&quot;라고도합니다. 지정된 인덱스의 값보다 작은 모든 요소, 지정된 인덱스의 값 및 지정된 인덱스의 값보다 큰 모든 요소의 트리플렛을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3d259af27d2572df43e2afe02e6f4d51f6ff06a9" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt;. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) worst-case. This function is also/ known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index.</source>
          <target state="translated">이 재정렬에는 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 위치의 값이 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 위치의 값보다 작거나 같다는 추가 속성 이 있습니다 . 추가적으로,이 재정렬은 불안정하고 (즉, 동일한 요소의 수가 위치 &lt;code&gt;index&lt;/code&gt; 에서 끝날 수 있음 ), 제자리 (즉, 할당하지 않음) 및 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; ) 최악의 경우입니다. 이 함수는 다른 라이브러리에서 &quot;k 번째 요소&quot;라고도합니다. 주어진 인덱스에있는 것보다 작은 모든 요소, 주어진 인덱스에있는 값, 주어진 인덱스에있는 것보다 큰 모든 요소의 삼중 항 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a44d46360998129b78ed15d687f727979c543e5" translate="yes" xml:space="preserve">
          <source>This representation can be applied to structs, unions, and enums.</source>
          <target state="translated">이 표현은 구조체, 공용체 및 열거 형에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c79281349d10df09672689425c0c484e6ef587c0" translate="yes" xml:space="preserve">
          <source>This representation can be applied to structs, unions, and enums. The exception is &lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;zero-variant enums&lt;/a&gt; for which the &lt;code&gt;C&lt;/code&gt; representation is an error.</source>
          <target state="translated">이 표현은 구조체, 공용체 및 열거 형에 적용 할 수 있습니다. 예외는 &lt;code&gt;C&lt;/code&gt; 표현이 오류 인 &lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;0 변형 열거 형&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="54d003da75e5c18c6d78ec752d4c5ea2c1005e03" translate="yes" xml:space="preserve">
          <source>This requires that the data inside this &lt;code&gt;Pin&lt;/code&gt; is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; so that we can ignore the pinning invariants when unwrapping it.</source>
          <target state="translated">&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 위해서는이 &lt;code&gt;Pin&lt;/code&gt; 내부의 데이터 가 언핀 이어야합니다.</target>
        </trans-unit>
        <trans-unit id="84a024e08861a138f89bc49f72665722f5345893" translate="yes" xml:space="preserve">
          <source>This requires that the data inside this &lt;code&gt;Pin&lt;/code&gt; is &lt;code&gt;Unpin&lt;/code&gt;.</source>
          <target state="translated">이를 위해서는이 &lt;code&gt;Pin&lt;/code&gt; 내부의 데이터 가 &lt;code&gt;Unpin&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="bb8049ba5b3a969809828fb6b20b4c6f803c243a" translate="yes" xml:space="preserve">
          <source>This restriction allows for mutation but in a very controlled fashion. It&amp;rsquo;s something that new Rustaceans struggle with, because most languages let you mutate whenever you&amp;rsquo;d like.</source>
          <target state="translated">이 제한은 돌연변이를 허용하지만 매우 통제 된 방식으로 이루어집니다. 대부분의 언어로 원할 때마다 변경할 수 있기 때문에 새로운 Rustaceans가 어려움을 겪고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9005ee922bd85c1b8cdd5bf9e647bc71bc7e1d1" translate="yes" xml:space="preserve">
          <source>This restricts us to a &lt;code&gt;Screen&lt;/code&gt; instance that has a list of components all of type &lt;code&gt;Button&lt;/code&gt; or all of type &lt;code&gt;TextField&lt;/code&gt;. If you&amp;rsquo;ll only ever have homogeneous collections, using generics and trait bounds is preferable because the definitions will be monomorphized at compile time to use the concrete types.</source>
          <target state="translated">이렇게하면 &lt;code&gt;Button&lt;/code&gt; 유형 또는 &lt;code&gt;TextField&lt;/code&gt; 유형의 구성 요소 목록이 있는 &lt;code&gt;Screen&lt;/code&gt; 인스턴스로 제한 됩니다. 동종 컬렉션 만있는 경우에는 정의가 콘크리트 유형을 사용하기 위해 컴파일 타임에 단일화되므로 제네릭 및 특성 경계를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fef61557094c53c94d8f4b9c87d239c1c4ddf6a3" translate="yes" xml:space="preserve">
          <source>This result just indicates that the assertion failed and which line the assertion is on. A more useful failure message in this case would print the value we got from the &lt;code&gt;greeting&lt;/code&gt; function. Let&amp;rsquo;s change the test function, giving it a custom failure message made from a format string with a placeholder filled in with the actual value we got from the &lt;code&gt;greeting&lt;/code&gt; function:</source>
          <target state="translated">이 결과는 어설 션이 실패했으며 어설 션이 어느 행에 있는지 나타냅니다. 이 경우 더 유용한 실패 메시지는 &lt;code&gt;greeting&lt;/code&gt; 기능 에서 얻은 값을 인쇄합니다 . 테스트 함수를 변경하여 &lt;code&gt;greeting&lt;/code&gt; 함수 에서 얻은 실제 값으로 자리 표시자가 채워진 형식 문자열로 작성된 사용자 지정 실패 메시지를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="0886cd5bf439fbbc8be3535b3d5401de7c87877b" translate="yes" xml:space="preserve">
          <source>This return type means the call to &lt;code&gt;File::open&lt;/code&gt; might succeed and return a file handle that we can read from or write to. The function call also might fail: for example, the file might not exist, or we might not have permission to access the file. The &lt;code&gt;File::open&lt;/code&gt; function needs to have a way to tell us whether it succeeded or failed and at the same time give us either the file handle or error information. This information is exactly what the &lt;code&gt;Result&lt;/code&gt; enum conveys.</source>
          <target state="translated">이 반환 유형은 &lt;code&gt;File::open&lt;/code&gt; 대한 호출 이 성공하고 읽거나 쓸 수있는 파일 핸들을 반환 할 수 있음을 의미합니다 . 함수 호출도 실패 할 수 있습니다. 예를 들어 파일이 없거나 파일에 액세스 할 수있는 권한이 없을 수 있습니다. &lt;code&gt;File::open&lt;/code&gt; 기능 요구는 성공 또는 실패와 동시에 우리에게 파일 핸들 또는 오류 정보 중 하나를 제공하는지 여부를 알려 수있는 방법이 있습니다. 이 정보는 &lt;code&gt;Result&lt;/code&gt; 열거 형이 전달 하는 것과 정확히 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="6e6467b9314c67467a583133eaf79a55bec1323c" translate="yes" xml:space="preserve">
          <source>This returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the working directory will not be changed.</source>
          <target state="translated">작업 디렉토리가 변경되지 않으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c7256f6dfb124c4206009cc4970395f092ae3141" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;None&lt;/code&gt; if the cursor is currently pointing to the &quot;ghost&quot; non-element.</source>
          <target state="translated">커서가 현재 &quot;고스트&quot;비 요소를 가리키고있는 경우 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2b3770e7d2efd1b08fe66eb571f2a780fb54e25f" translate="yes" xml:space="preserve">
          <source>This returns a numeric identifier for the thread identified by this &lt;code&gt;ThreadId&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;ThreadId&lt;/code&gt; 로 식별되는 스레드의 숫자 식별자를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="368beec57f1181b8799a91ee73ada8b4184da78e" translate="yes" xml:space="preserve">
          <source>This reuses all the nodes from &lt;code&gt;other&lt;/code&gt; and moves them into &lt;code&gt;self&lt;/code&gt;. After this operation, &lt;code&gt;other&lt;/code&gt; becomes empty.</source>
          <target state="translated">이것은 &lt;code&gt;other&lt;/code&gt; 노드의 모든 노드를 재사용하고 &lt;code&gt;self&lt;/code&gt; 로 옮깁니다 . 이 작업 후에 &lt;code&gt;other&lt;/code&gt; 은 비게됩니다.</target>
        </trans-unit>
        <trans-unit id="7730271090bac7f074841851b1b821f9fc7fca43" translate="yes" xml:space="preserve">
          <source>This rework may seem like overkill for our small program, but we&amp;rsquo;re refactoring in small, incremental steps. After making this change, run the program again to verify that the argument parsing still works. It&amp;rsquo;s good to check your progress often, to help identify the cause of problems when they occur.</source>
          <target state="translated">이 재 작업은 우리의 작은 프로그램에 대해 과도한 것처럼 보일 수 있지만, 우리는 작은 단계적으로 리팩토링하고 있습니다. 이 변경을 수행 한 후 프로그램을 다시 실행하여 인수 구문 분석이 여전히 작동하는지 확인하십시오. 문제가 발생할 때 원인을 식별하는 데 도움이되도록 진행 상황을 자주 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c68a9d1019f31cc86d07a97f90c903ea86167b11" translate="yes" xml:space="preserve">
          <source>This rule also applies to type parameters of impl blocks that contain const methods</source>
          <target state="translated">이 규칙은 const 메소드를 포함하는 impl 블록의 유형 매개 변수에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c9e400474c407c09b7fb37164368bcd30fbe8830" translate="yes" xml:space="preserve">
          <source>This runs the code in &lt;em&gt;adder/src/main.rs&lt;/em&gt;, which depends on the &lt;code&gt;add-one&lt;/code&gt; crate.</source>
          <target state="translated">이 코드는 &lt;em&gt;adder / src / main.rs&lt;/em&gt; 코드를 실행하며 &lt;code&gt;add-one&lt;/code&gt; 상자 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="e6b2224800e73c42ee25267c2896a776ab41e710" translate="yes" xml:space="preserve">
          <source>This section documents features that affect the ABI of the compiled output of a crate.</source>
          <target state="translated">이 섹션에서는 상자의 컴파일 된 출력의 ABI에 영향을주는 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7dc2765b02ef149354a7a9ee16a696edf0827240" translate="yes" xml:space="preserve">
          <source>This section documents features that define some aspects of the Rust runtime.</source>
          <target state="translated">이 섹션에서는 Rust 런타임의 일부 측면을 정의하는 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f7c12226b9e0c0ca24fa6bdd6239b023bf8ef3a4" translate="yes" xml:space="preserve">
          <source>This should only ever be called with a pointer that was earlier obtained by calling &lt;a href=&quot;#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;CString&lt;/code&gt;. Other usage (e.g., trying to take ownership of a string that was allocated by foreign code) is likely to lead to undefined behavior or allocator corruption.</source>
          <target state="translated">&lt;code&gt;CString&lt;/code&gt; 에서&lt;a href=&quot;#method.into_raw&quot;&gt; &lt;code&gt;into_raw&lt;/code&gt; &lt;/a&gt; 를 호출하여 이전에 얻은 포인터로만 호출해야합니다 . 다른 사용법 (예 : 외래 코드에 의해 할당 된 문자열의 소유권을 얻으려고 시도)은 정의되지 않은 동작 또는 할당 자 손상을 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb13fd72f340b7885313dcc12025456f86beff96" translate="yes" xml:space="preserve">
          <source>This should only ever be called with a pointer that was earlier obtained by calling &lt;a href=&quot;struct.cstring#method.into_raw&quot;&gt;&lt;code&gt;CString::into_raw&lt;/code&gt;&lt;/a&gt;. Other usage (e.g., trying to take ownership of a string that was allocated by foreign code) is likely to lead to undefined behavior or allocator corruption.</source>
          <target state="translated">이것은 &lt;a href=&quot;struct.cstring#method.into_raw&quot;&gt; &lt;code&gt;CString::into_raw&lt;/code&gt; &lt;/a&gt; 를 호출하여 이전에 얻은 포인터로만 호출되어야합니다 . 다른 사용 (예 : 외부 코드에 의해 할당 된 문자열의 소유권을 얻으려는 시도)은 정의되지 않은 동작 또는 할당 자 손상으로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6de4781e84fd1ffb8326c915806ff4604cbf7406" translate="yes" xml:space="preserve">
          <source>This shows the source code file with the &lt;em&gt;.rs&lt;/em&gt; extension, the executable file (&lt;em&gt;main.exe&lt;/em&gt; on Windows, but &lt;em&gt;main&lt;/em&gt; on all other platforms), and, when using Windows, a file containing debugging information with the &lt;em&gt;.pdb&lt;/em&gt; extension. From here, you run the &lt;em&gt;main&lt;/em&gt; or &lt;em&gt;main.exe&lt;/em&gt; file, like this:</source>
          <target state="translated">확장명 이 &lt;em&gt;.rs 인&lt;/em&gt; 소스 코드 파일 , 실행 파일 ( Windows에서는 &lt;em&gt;main.exe&lt;/em&gt; , 다른 모든 플랫폼 에서는 &lt;em&gt;main&lt;/em&gt; ) 및 Windows를 사용할 경우 확장자 가 &lt;em&gt;.pdb 인&lt;/em&gt; 디버깅 정보가 들어있는 파일이 표시 됩니다. 여기에서 &lt;em&gt;main&lt;/em&gt; 또는 &lt;em&gt;main.exe&lt;/em&gt; 파일을 다음과 같이 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="9575f8046ce99c60fbe347fdb162c3debc44c697" translate="yes" xml:space="preserve">
          <source>This slice has the type &lt;code&gt;&amp;amp;[i32]&lt;/code&gt;. It works the same way as string slices do, by storing a reference to the first element and a length. You&amp;rsquo;ll use this kind of slice for all sorts of other collections. We&amp;rsquo;ll discuss these collections in detail when we talk about vectors in Chapter 8.</source>
          <target state="translated">이 슬라이스는 &lt;code&gt;&amp;amp;[i32]&lt;/code&gt; 유형 입니다. 첫 번째 요소에 대한 참조와 길이를 저장하여 문자열 슬라이스와 같은 방식으로 작동합니다. 모든 종류의 다른 컬렉션에이 종류의 슬라이스를 사용합니다. 8 장에서 벡터에 대해 이야기 할 때 이러한 컬렉션에 대해 자세히 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="d65fb4bd24471a81f14e38e503058f70c64833b3" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m * n * log(n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">이 정렬은 안정적이며 (즉, 동일한 요소를 재정렬하지 않음) &lt;code&gt;O(m * n * log(n))&lt;/code&gt; 최악의 경우 키 함수가 &lt;code&gt;O(m)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b5c9c4b26823864ca42f73d970b5f61574652362" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m * n + n * log(n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">이 정렬은 안정적이며 (즉, 동일한 요소의 순서를 변경하지 않음) &lt;code&gt;O(m * n + n * log(n))&lt;/code&gt; 최악의 경우 키 함수가 &lt;code&gt;O(m)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b3fe498c20a11bda205dc93f4390f850884c310c" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m n + n log n)&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">이 정렬은 안정적이며 (즉, 동일한 요소를 재정렬하지 않음) &lt;code&gt;O(m n + n log n)&lt;/code&gt; 최악의 경우 키 함수는 &lt;code&gt;O(m)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="04ff5f9e434224075f07c47221408f586ed69430" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m n log(m n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">이 정렬은 안정적이며 (즉, 동일한 요소를 재정렬하지 않음) &lt;code&gt;O(m n log(m n))&lt;/code&gt; 최악의 경우 키 함수는 &lt;code&gt;O(m)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="13defa388ad16a8832cba0851748fe2d9c59598b" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(n * log(n))&lt;/code&gt; worst-case.</source>
          <target state="translated">이 정렬은 안정적이며 (즉, 동일한 요소를 재정렬하지 않음) &lt;code&gt;O(n * log(n))&lt;/code&gt; 최악의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="29bb618262e9818d4542507320a836e4faf4b56f" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(n log n)&lt;/code&gt; worst-case.</source>
          <target state="translated">이 정렬은 안정적이며 (즉, 동일한 요소를 재정렬하지 않음) &lt;code&gt;O(n log n)&lt;/code&gt; 최악의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="342fc35a79498863eed086153ecf4de54d803470" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case, where the key function is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;).</source>
          <target state="translated">이 정렬은 안정적이며 (즉, 동일한 요소를 재정렬하지 않음) &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt; * log ( &lt;em&gt;n&lt;/em&gt; )) 최악의 경우 키 함수가 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;m&lt;/em&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="b9e6ed2e7770cad1c08fcd52e4c75266e91bca66" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt; + &lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case, where the key function is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;).</source>
          <target state="translated">이 정렬은 안정적이며 (즉, 동일한 요소를 재정렬하지 않음) &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt; + &lt;em&gt;n&lt;/em&gt; * log ( &lt;em&gt;n&lt;/em&gt; )) 최악의 경우 키 함수가 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;m&lt;/em&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="b0fa553880d5f214b25277a39b204d8402684264" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case.</source>
          <target state="translated">이 정렬은 안정적이며 (즉, 동일한 요소를 재정렬하지 않음) &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; * log ( &lt;em&gt;n&lt;/em&gt; )) 최악의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="f8094b9acbcdfe817a2beca8fbbfd03d36adf019" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;code&gt;O(m n log(m n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">이런 종류의 (즉, 동일한 요소의 순서를 변경 할 수 있습니다)에 장소 (즉, 할당하지 않습니다) 불안정하고, &lt;code&gt;O(m n log(m n))&lt;/code&gt; 의 핵심 기능은 최악의 경우, &lt;code&gt;O(m)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e852a79da20e649bf213cb6826ee95c589ae984" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;code&gt;O(n log n)&lt;/code&gt; worst-case.</source>
          <target state="translated">이 정렬은 불안정하며 (즉, 동일한 요소를 재정렬 할 수 있음), 내부 (즉, 할당하지 않음) 및 &lt;code&gt;O(n log n)&lt;/code&gt; 최악의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="3d7156d28541cb0cabeaa7410dd06cdaa9199652" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case.</source>
          <target state="translated">이 정렬은 불안정하고 (즉, 동일한 요소를 재정렬 할 수 있음) 제자리에 (즉, 할당하지 않음), &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; * log ( &lt;em&gt;n&lt;/em&gt; )) 최악의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="b3e0c73c0881bd5d99646c6bd52683bfabd1a90e" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;em&gt;O&lt;/em&gt;(m * &lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case, where the key function is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;).</source>
          <target state="translated">이 정렬은 불안정하고 (즉, 동일한 요소를 재정렬 할 수 있음) 제자리 (즉, 할당하지 않음) 및 &lt;em&gt;O&lt;/em&gt; (m * &lt;em&gt;n&lt;/em&gt; * log ( &lt;em&gt;n&lt;/em&gt; )) 최악의 경우 키 함수가 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;m&lt;/em&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="7b9136d07194a4e8e43750309da02e688255bd47" translate="yes" xml:space="preserve">
          <source>This sort of behavior has been known to &lt;a href=&quot;https://securityvulns.com/Wdocument183.html&quot;&gt;lead to privilege escalation&lt;/a&gt; when used incorrectly.</source>
          <target state="translated">이러한 종류의 동작은 잘못 사용될 경우 &lt;a href=&quot;https://securityvulns.com/Wdocument183.html&quot;&gt;권한 상승&lt;/a&gt; 으로 이어지는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="4609a563600ff8952232a98685a394486b72fb56" translate="yes" xml:space="preserve">
          <source>This state indicates that a generator has been suspended, and typically corresponds to a &lt;code&gt;yield&lt;/code&gt; statement. The value provided in this variant corresponds to the expression passed to &lt;code&gt;yield&lt;/code&gt; and allows generators to provide a value each time they yield.</source>
          <target state="translated">이 상태는 생성기가 일시 중지되었음을 나타내며 일반적으로 &lt;code&gt;yield&lt;/code&gt; 문에 해당 합니다. 이 변형에 제공된 값은 &lt;code&gt;yield&lt;/code&gt; 전달 된 표현에 해당하며 생성자가 생성 할 때마다 값을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90c88a5ca708244c3219f050c7309e58bf365755" translate="yes" xml:space="preserve">
          <source>This state indicates that a generator has finished execution with the provided value. Once a generator has returned &lt;code&gt;Complete&lt;/code&gt; it is considered a programmer error to call &lt;code&gt;resume&lt;/code&gt; again.</source>
          <target state="translated">이 상태는 생성기가 제공된 값으로 실행을 완료했음을 나타냅니다. 생성기가 &lt;code&gt;Complete&lt;/code&gt; 를 반환하면 다시 &lt;code&gt;resume&lt;/code&gt; 다시 호출하는 프로그래머 오류로 간주 됩니다.</target>
        </trans-unit>
        <trans-unit id="7be578f8354e75e786ae7f8a72194e570efdeae6" translate="yes" xml:space="preserve">
          <source>This stream will be ignored. This is the equivalent of attaching the stream to &lt;code&gt;/dev/null&lt;/code&gt;</source>
          <target state="translated">이 스트림은 무시됩니다. 이것은 스트림을 &lt;code&gt;/dev/null&lt;/code&gt; 에 첨부하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86aaaf1ade8618d076dfddfcf43a493fbd9d9208" translate="yes" xml:space="preserve">
          <source>This stream will be ignored. This is the equivalent of attaching the stream to &lt;code&gt;/dev/null&lt;/code&gt;.</source>
          <target state="translated">이 스트림은 무시됩니다. 이것은 스트림을 &lt;code&gt;/dev/null&lt;/code&gt; 에 연결하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="047e86b07f343619951ab342d709e9864cc54c3d" translate="yes" xml:space="preserve">
          <source>This struct has one field, &lt;code&gt;part&lt;/code&gt;, that holds a string slice, which is a reference. As with generic data types, we declare the name of the generic lifetime parameter inside angle brackets after the name of the struct so we can use the lifetime parameter in the body of the struct definition. This annotation means an instance of &lt;code&gt;ImportantExcerpt&lt;/code&gt; can&amp;rsquo;t outlive the reference it holds in its &lt;code&gt;part&lt;/code&gt; field.</source>
          <target state="translated">이 구조체에는 문자열 슬라이스를 보유하는 하나의 필드 &lt;code&gt;part&lt;/code&gt; 가 있으며 이는 참조입니다. 일반 데이터 유형과 마찬가지로 구조체 이름 뒤에 꺾쇠 괄호 안에 일반 수명 매개 변수의 이름을 선언하므로 구조체 정의 본문에서 수명 매개 변수를 사용할 수 있습니다. 이 주석은 &lt;code&gt;ImportantExcerpt&lt;/code&gt; 인스턴스가 &lt;code&gt;part&lt;/code&gt; 필드 에서 보유한 참조보다 오래 지속될 수 없음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="035a190c93ffcb98a162f4a1c124850fba76f70b" translate="yes" xml:space="preserve">
          <source>This struct has the same layout as types like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; and &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 구조체는 &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; 및 &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt; 와 같은 형식과 레이아웃이 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8bcde4812fcc7ef55a0760fedbc39c027f9accb6" translate="yes" xml:space="preserve">
          <source>This struct has the same layout as types like &lt;code&gt;&amp;amp;dyn SomeTrait&lt;/code&gt; and &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 구조체는 &lt;code&gt;&amp;amp;dyn SomeTrait&lt;/code&gt; 및 &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt; 와 같은 유형과 동일한 레이아웃을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="78fc6455134464feceba11cc2db121b5a8d643b0" translate="yes" xml:space="preserve">
          <source>This struct is a helper to be used with functions like &lt;a href=&quot;../vec/struct.vec#method.sort_by_key&quot;&gt;&lt;code&gt;Vec::sort_by_key&lt;/code&gt;&lt;/a&gt; and can be used to reverse order a part of a key.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../vec/struct.vec#method.sort_by_key&quot;&gt; &lt;code&gt;Vec::sort_by_key&lt;/code&gt; &lt;/a&gt; 와 같은 함수와 함께 사용되는 도우미 이며 키의 일부를 역순으로 정렬하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="698bb1f1506a6aa8b90b6f64dc7e32c0c5091a12" translate="yes" xml:space="preserve">
          <source>This struct is a helper to be used with functions like &lt;code&gt;Vec::sort_by_key&lt;/code&gt; and can be used to reverse order a part of a key.</source>
          <target state="translated">이 구조체는 &lt;code&gt;Vec::sort_by_key&lt;/code&gt; 와 같은 함수와 함께 사용할 수있는 도우미 이며 키의 일부를 역순으로 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84ced59217a045f0ae6136d2f9bd0162d392046f" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;fn.args&quot;&gt;&lt;code&gt;env::args()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;fn.args&quot;&gt; &lt;code&gt;env::args()&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="421112f55866033bf937c2c2104c004765f83d6c" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;fn.args_os&quot;&gt;&lt;code&gt;env::args_os()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;fn.args_os&quot;&gt; &lt;code&gt;env::args_os()&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6d98990c007f08843ac1df1a07fad048ba02e034" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.command#method.get_args&quot;&gt;&lt;code&gt;Command::get_args&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;struct.command#method.get_args&quot;&gt; &lt;code&gt;Command::get_args&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c34405b53d7303b0dec8e54e6aa5a0abefbaa23c" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.command#method.get_envs&quot;&gt;&lt;code&gt;Command::get_envs&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;struct.command#method.get_envs&quot;&gt; &lt;code&gt;Command::get_envs&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2147718c894a448fcb5bace3573d8c66021b6ecf" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.vec#method.drain_filter&quot;&gt;&lt;code&gt;Vec::drain_filter&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;struct.vec#method.drain_filter&quot;&gt; &lt;code&gt;Vec::drain_filter&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3b56bd91b0140c9f3d261bb2e7de1a84ee87136c" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.vec#method.splice&quot;&gt;&lt;code&gt;Vec::splice()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;struct.vec#method.splice&quot;&gt; &lt;code&gt;Vec::splice()&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3b94fdb25d3a1999fbb00df483466c3f3ad93974" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../iter/trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; (provided by the &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; trait).</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; 특성에 의해 제공되는 &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../iter/trait.intoiterator#tymethod.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="0f993739b1a6e12d97f61853ab3a7aeead8ab4b9" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.array_chunks&quot;&gt;&lt;code&gt;array_chunks&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.array_chunks&quot;&gt; &lt;code&gt;array_chunks&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="306d58f57f3d10dc00f2031814b48c48929d8df3" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.array_chunks_mut&quot;&gt;&lt;code&gt;array_chunks_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.array_chunks_mut&quot;&gt; &lt;code&gt;array_chunks_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="0f3c9f948ac0eb252b070770390b8ad86aa3b895" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.array_windows&quot;&gt;&lt;code&gt;array_windows&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.array_windows&quot;&gt; &lt;code&gt;array_windows&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="1dd8330957d499a2a2bc9ec6116864588108859d" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks&quot;&gt;&lt;code&gt;chunks&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.chunks&quot;&gt; &lt;code&gt;chunks&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f546acf131aa1e22a602b9ef3fb82d4387eee8e" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_exact&quot;&gt;&lt;code&gt;chunks_exact&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.chunks_exact&quot;&gt; &lt;code&gt;chunks_exact&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e45db796c91b4ce48eb20085844caa57f6053703" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_exact_mut&quot;&gt;&lt;code&gt;chunks_exact_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.chunks_exact_mut&quot;&gt; &lt;code&gt;chunks_exact_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="4164f449a467d7ed1b48f5a88a1f8a74fb26a190" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_mut&quot;&gt;&lt;code&gt;chunks_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.chunks_mut&quot;&gt; &lt;code&gt;chunks_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="76b48770dc5ec192ca6962e1d7faa3bd68e942ab" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="7681a887be4ac8a42d7f0ef28706aee3c6323619" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="523facc9e10029a951175d54b1f37f2671749ed6" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks&quot;&gt;&lt;code&gt;rchunks&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rchunks&quot;&gt; &lt;code&gt;rchunks&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="7743c6e4ca6fc913a9f4d37b6de12a320056fa8b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_exact&quot;&gt;&lt;code&gt;rchunks_exact&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rchunks_exact&quot;&gt; &lt;code&gt;rchunks_exact&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="82404af50a38a848751818c48976a9a56b795818" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_exact_mut&quot;&gt;&lt;code&gt;rchunks_exact_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rchunks_exact_mut&quot;&gt; &lt;code&gt;rchunks_exact_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="711c0f689f1d3a75f7b5a1b1833bc925f8986127" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_mut&quot;&gt;&lt;code&gt;rchunks_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rchunks_mut&quot;&gt; &lt;code&gt;rchunks_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ffea197c31595a869becf274e9c9ef3509b405a" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a28e12c215b6246a69d2f856da858d720de99619" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplit_mut&quot;&gt;&lt;code&gt;rsplit_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rsplit_mut&quot;&gt; &lt;code&gt;rsplit_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e1ddb16a3352ab0f837d4fac934c98e22db158e5" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="2305be064f2e36144fd442bf726fd4dd5a160216" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplitn_mut&quot;&gt;&lt;code&gt;rsplitn_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rsplitn_mut&quot;&gt; &lt;code&gt;rsplitn_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="9d2c4405dee882e98a94c3681ae8ce615cfcc3f7" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="abdc8d3421db5241b7ca4544a7b51d6159d67e49" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.split_mut&quot;&gt;&lt;code&gt;split_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.split_mut&quot;&gt; &lt;code&gt;split_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="b850789ebec6b616db674ca7582ef014921e3e50" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.splitn&quot;&gt;&lt;code&gt;splitn&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.splitn&quot;&gt; &lt;code&gt;splitn&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="fcbac1aabe82a2c466b31106e57bd4691b6a4588" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.splitn_mut&quot;&gt;&lt;code&gt;splitn_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.splitn_mut&quot;&gt; &lt;code&gt;splitn_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="4faa0b9911c89c4588e753ca1891a11cb9aac5c2" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.windows&quot;&gt;&lt;code&gt;windows&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.windows&quot;&gt; &lt;code&gt;windows&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="972c0f2531dd3e046ad902a7f6f569ef9de9571e" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9dc716c653425077e3bf50725d3ddc775e25fe94" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.char_indices&quot;&gt;&lt;code&gt;char_indices&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.char_indices&quot;&gt; &lt;code&gt;char_indices&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="607ded9325aedcb5c140c227e32c8ad28d5439d9" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.chars&quot;&gt; &lt;code&gt;chars&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eb31472d0cae7541e173fe527a7087a142820c04" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.encode_utf16&quot;&gt;&lt;code&gt;encode_utf16&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.encode_utf16&quot;&gt; &lt;code&gt;encode_utf16&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e7c273a10bb61ef5da70d27b34dc57f12929254d" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.split_ascii_whitespace&quot;&gt;&lt;code&gt;split_ascii_whitespace&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.split_ascii_whitespace&quot;&gt; &lt;code&gt;split_ascii_whitespace&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e335f4d066241eacb01d34cbc9797fdfc696dc6b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f9cd50ffb5bf76be59d59fc2f81ddf738ff0464b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;fn.args&quot;&gt;&lt;code&gt;std::env::args&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;fn.args&quot;&gt; &lt;code&gt;std::env::args&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0ec39f7b0daa2776e166f7fac0653e5c7c5e4333" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;fn.args_os&quot;&gt;&lt;code&gt;std::env::args_os&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;fn.args_os&quot;&gt; &lt;code&gt;std::env::args_os&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d49df01529faa1803ee9ac5934efa956bfb59ca5" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;struct.string#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.string#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7821d89ece3dc45805333802521c4ece28a6ec77" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;struct.vec#method.splice&quot;&gt;&lt;code&gt;splice()&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.vec#method.splice&quot;&gt; &lt;code&gt;splice()&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="df074a53b5359b4dd926d5ab8c21cb3fdb8391e4" translate="yes" xml:space="preserve">
          <source>This struct is created with the &lt;a href=&quot;../primitive.str#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.lines&quot;&gt; &lt;code&gt;lines&lt;/code&gt; &lt;/a&gt; 메소드로 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5a1492f5f04561e29bfe6f623f2dc30782a50bbf" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 &lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty()&lt;/code&gt; &lt;/a&gt; 를 호출하여 생성됩니다 . 자세한 내용은 &lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty()&lt;/code&gt; &lt;/a&gt; 문서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8df7525ac9b1331bb51b51ca2c5df8a11c0a1c0e" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 &lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty&lt;/code&gt; &lt;/a&gt; 호출하여 생성됩니다 . 자세한 내용은 &lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty()&lt;/code&gt; &lt;/a&gt; 설명서 를 참조하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
