<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="6e589b43f3082da98ca0e4f046ea8ace2906bf51" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#method.from_utf8_lossy&quot;&gt;&lt;code&gt;from_utf8_lossy&lt;/code&gt;&lt;/a&gt; which returns a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;from_utf16_lossy&lt;/code&gt; returns a &lt;code&gt;String&lt;/code&gt; since the UTF-16 to UTF-8 conversion requires a memory allocation.</source>
          <target state="translated">달리 &lt;a href=&quot;#method.from_utf8_lossy&quot;&gt; &lt;code&gt;from_utf8_lossy&lt;/code&gt; &lt;/a&gt; 반환 &lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;from_utf16_lossy&lt;/code&gt; 리턴 &lt;code&gt;String&lt;/code&gt; 가 UTF-16, UTF-8 변환 이후에 메모리 할당을 필요로한다.</target>
        </trans-unit>
        <trans-unit id="1e5e6606c716b7d8ea23880ff26dd47bb4cb772b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#variant.InvalidInput&quot;&gt;&lt;code&gt;InvalidInput&lt;/code&gt;&lt;/a&gt;, this typically means that the operation parameters were valid, however the error was caused by malformed input data.</source>
          <target state="translated">&lt;a href=&quot;#variant.InvalidInput&quot;&gt; &lt;code&gt;InvalidInput&lt;/code&gt; &lt;/a&gt; 과 달리 이것은 일반적으로 작업 매개 변수가 유효하지만 오류는 잘못된 입력 데이터로 인해 발생했음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="42150160f2ba583b7d6c6990db7fe7b9390515b8" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../convert/fn.identity&quot;&gt;&lt;code&gt;std::convert::identity&lt;/code&gt;&lt;/a&gt;, a Rust compiler is encouraged to assume that &lt;code&gt;black_box&lt;/code&gt; can use &lt;code&gt;dummy&lt;/code&gt; in any possible valid way that Rust code is allowed to without introducing undefined behavior in the calling code. This property makes &lt;code&gt;black_box&lt;/code&gt; useful for writing code in which certain optimizations are not desired, such as benchmarks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8fe9eebd36a2bd7140bc3ec3fdc0c32e569dabf" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; uses atomic operations for its reference counting. This means that it is thread-safe. The disadvantage is that atomic operations are more expensive than ordinary memory accesses. If you are not sharing reference-counted allocations between threads, consider using &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for lower overhead. &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is a safe default, because the compiler will catch any attempt to send an &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; between threads. However, a library might choose &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; in order to give library consumers more flexibility.</source>
          <target state="translated">달리 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 는 참조 카운팅 원자 연산을 사용한다. 이것은 스레드로부터 안전하다는 것을 의미합니다. 단점은 원자 적 연산이 일반 메모리 액세스보다 더 비싸다는 것입니다. 스레드간에 참조 횟수 할당을 공유하지 않는 경우 낮은 오버 헤드를 위해 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다. &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 컴파일러가 스레드간에 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 보내려는 시도를 포착하므로 안전한 기본값 입니다. 그러나 라이브러리 소비자에게 더 많은 유연성을 제공하기 위해 라이브러리는 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 를 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="398c5c34b191e4676dc6961558a4a76db9314267" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; uses atomic operations for its reference counting. This means that it is thread-safe. The disadvantage is that atomic operations are more expensive than ordinary memory accesses. If you are not sharing reference-counted values between threads, consider using &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for lower overhead. &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is a safe default, because the compiler will catch any attempt to send an &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; between threads. However, a library might choose &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; in order to give library consumers more flexibility.</source>
          <target state="translated">달리 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 는 참조 카운팅 원자 연산을 사용한다. 이것은 스레드 안전하다는 것을 의미합니다. 단점은 원 자성 연산이 일반 메모리 액세스보다 비싸다는 것입니다. 스레드간에 참조 횟수 값을 공유하지 않는 경우 오버 헤드를 낮추기 위해 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 . 컴파일러는 스레드간에 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 보내려고 시도하기 때문에 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 가 안전한 기본값 입니다. 그러나 라이브러리는 라이브러리 소비자에게 더 많은 유연성을 제공하기 위해 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 를 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e29ce9f9179b04ed1ae04e60eaff67bddb9bd1a4" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;enum.errorkind#variant.InvalidInput&quot;&gt;&lt;code&gt;InvalidInput&lt;/code&gt;&lt;/a&gt;, this typically means that the operation parameters were valid, however the error was caused by malformed input data.</source>
          <target state="translated">&lt;a href=&quot;enum.errorkind#variant.InvalidInput&quot;&gt; &lt;code&gt;InvalidInput&lt;/code&gt; &lt;/a&gt; 과 달리 이는 일반적으로 작업 매개 변수가 유효했지만 잘못된 입력 데이터로 인해 오류가 발생했음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="977087ec8c6cc227ec1b23f036b52a53ba5572b7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;enum.result#method.unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt;, this method is known to never panic on the result types it is implemented for. Therefore, it can be used instead of &lt;code&gt;unwrap&lt;/code&gt; as a maintainability safeguard that will fail to compile if the error type of the &lt;code&gt;Result&lt;/code&gt; is later changed to an error that can actually occur.</source>
          <target state="translated">&lt;a href=&quot;enum.result#method.unwrap&quot;&gt; &lt;code&gt;unwrap&lt;/code&gt; &lt;/a&gt; 과 달리이 메서드는 구현 된 결과 유형에 대해 절대 당황하지 않는 것으로 알려져 있습니다. 따라서 &lt;code&gt;Result&lt;/code&gt; 의 오류 유형 이 나중에 실제로 발생할 수있는 오류로 변경 되면 컴파일에 실패하는 유지 보수성 보호 수단 으로 &lt;code&gt;unwrap&lt;/code&gt; 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f0ba302caf06a67df91ba9d9ffb499576009fcd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.once&quot;&gt;&lt;code&gt;once()&lt;/code&gt;&lt;/a&gt;, this function will lazily generate the value on request.</source>
          <target state="translated">&lt;a href=&quot;fn.once&quot;&gt; &lt;code&gt;once()&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 요청시 값을 느리게 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d18aaa1337521f474ebf73b2e843073b1e6c1a48" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.once&quot;&gt;&lt;code&gt;once&lt;/code&gt;&lt;/a&gt;, this function will lazily generate the value on request.</source>
          <target state="translated">&lt;a href=&quot;fn.once&quot;&gt; &lt;code&gt;once&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 요청시 값을 게으르게 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f9a90d0a5de7f0a5dcb5f54e9d3e2cfa25b0db2a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;read_unaligned&lt;/code&gt; works with unaligned pointers.</source>
          <target state="translated">달리 &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;read_unaligned&lt;/code&gt; 정렬되지 않은 포인터 작품.</target>
        </trans-unit>
        <trans-unit id="45376ed6cd7ba7a1378a0b53a56bfa0037e236a4" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;, the pointer may be unaligned.</source>
          <target state="translated">&lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; 와 달리 포인터가 정렬되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f193c98cf25a325eda25618a82a356c0b0cf6349" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, the pointer may be unaligned.</source>
          <target state="translated">&lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 와 달리 포인터가 정렬되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eb0fda1ae28c8f30f8d9d31bf06172d448763b9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://doc.rust-lang.org/core/convert/fn.identity.html&quot;&gt;&lt;code&gt;std::convert::identity&lt;/code&gt;&lt;/a&gt;, a Rust compiler is encouraged to assume that &lt;code&gt;black_box&lt;/code&gt; can use &lt;code&gt;dummy&lt;/code&gt; in any possible valid way that Rust code is allowed to without introducing undefined behavior in the calling code. This property makes &lt;code&gt;black_box&lt;/code&gt; useful for writing code in which certain optimizations are not desired, such as benchmarks.</source>
          <target state="translated">달리 &lt;a href=&quot;https://doc.rust-lang.org/core/convert/fn.identity.html&quot;&gt; &lt;code&gt;std::convert::identity&lt;/code&gt; &lt;/a&gt; , 녹 컴파일러는 그 가정 권장 &lt;code&gt;black_box&lt;/code&gt; 을 사용할 수 있습니다 &lt;code&gt;dummy&lt;/code&gt; 호출 코드에서 정의되지 않은 동작을 도입하지 않고 녹 코드가 허용되는 가능한 모든 유효한 방법. 이 속성은 &lt;code&gt;black_box&lt;/code&gt; 를 벤치 마크와 같이 특정 최적화가 바람직하지 않은 코드를 작성하는 데 유용 하게 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="91d4ccc7c19b4e12670ef1bb1f42a0a03d42f849" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will not execute &lt;code&gt;debug_assert!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development. The result of expanding &lt;code&gt;debug_assert!&lt;/code&gt; is always type checked.</source>
          <target state="translated">&lt;a href=&quot;macro.assert&quot;&gt; &lt;code&gt;assert!&lt;/code&gt; &lt;/a&gt; 과 달리 ! , &lt;code&gt;debug_assert!&lt;/code&gt; 문은 기본적으로 최적화되지 않은 빌드에서만 활성화됩니다. 최적화 된 빌드는 &lt;code&gt;debug_assert!&lt;/code&gt; 실행하지 않습니다 ! &lt;code&gt;-C debug-assertions&lt;/code&gt; 이 컴파일러에 전달 되지 않는 한 명령문 . 이것은 &lt;code&gt;debug_assert!&lt;/code&gt; 릴리스 빌드에 존재하기에는 너무 비싸지 만 개발 중에 도움이 될 수있는 검사에 유용합니다. &lt;code&gt;debug_assert!&lt;/code&gt; 를 확장 한 결과 ! 항상 유형 검사입니다.</target>
        </trans-unit>
        <trans-unit id="c003bf6ddb754586528cac314e476dba52106915" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will omit all &lt;code&gt;debug_assert!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development.</source>
          <target state="translated">&lt;a href=&quot;macro.assert&quot;&gt; &lt;code&gt;assert!&lt;/code&gt; &lt;/a&gt; 과 달리 ! , &lt;code&gt;debug_assert!&lt;/code&gt; 명령문은 기본적으로 최적화되지 않은 빌드에서만 사용 가능합니다. 최적화 된 빌드는 모든 &lt;code&gt;debug_assert!&lt;/code&gt; 를 생략합니다 ! &lt;code&gt;-C debug-assertions&lt;/code&gt; 가 컴파일러에 전달 되지 않는 한 명령문 . 이것은 &lt;code&gt;debug_assert!&lt;/code&gt; 릴리스 빌드에 포함하기에는 너무 비싸지 만 개발 중에 도움이 될 수있는 검사에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c7b2f5bacfdb6fe8fd35fce9254ebaf2411b3683" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_eq&quot;&gt;&lt;code&gt;assert_eq!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will not execute &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_eq!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development. The result of expanding &lt;code&gt;debug_assert_eq!&lt;/code&gt; is always type checked.</source>
          <target state="translated">&lt;a href=&quot;macro.assert_eq&quot;&gt; &lt;code&gt;assert_eq!&lt;/code&gt; &lt;/a&gt; 와 달리 ! , &lt;code&gt;debug_assert_eq!&lt;/code&gt; 문은 기본적으로 최적화되지 않은 빌드에서만 활성화됩니다. 최적화 된 빌드는 &lt;code&gt;debug_assert_eq!&lt;/code&gt; 실행하지 않습니다 ! &lt;code&gt;-C debug-assertions&lt;/code&gt; 이 컴파일러에 전달 되지 않는 한 명령문 . 이것은 &lt;code&gt;debug_assert_eq!&lt;/code&gt; 릴리스 빌드에 존재하기에는 너무 비싸지 만 개발 중에 도움이 될 수있는 검사에 유용합니다. &lt;code&gt;debug_assert_eq!&lt;/code&gt; 를 확장 한 결과 ! 항상 유형 검사입니다.</target>
        </trans-unit>
        <trans-unit id="3263afd688aea4401eb3df7127fbabe1b1fe028e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_eq&quot;&gt;&lt;code&gt;assert_eq!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will omit all &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_eq!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development.</source>
          <target state="translated">&lt;a href=&quot;macro.assert_eq&quot;&gt; &lt;code&gt;assert_eq!&lt;/code&gt; &lt;/a&gt; 와 달리 ! , &lt;code&gt;debug_assert_eq!&lt;/code&gt; 명령문은 기본적으로 최적화되지 않은 빌드에서만 사용 가능합니다. 최적화 된 빌드는 모든 &lt;code&gt;debug_assert_eq!&lt;/code&gt; 를 생략합니다 ! &lt;code&gt;-C debug-assertions&lt;/code&gt; 가 컴파일러에 전달 되지 않는 한 명령문 . 이것은 &lt;code&gt;debug_assert_eq!&lt;/code&gt; 릴리스 빌드에 포함하기에는 너무 비싸지 만 개발 중에 도움이 될 수있는 검사에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="dacd029d3cc2c2a10a75c84ef45c21166b5ba90a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_ne&quot;&gt;&lt;code&gt;assert_ne!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will not execute &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_ne!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development. The result of expanding &lt;code&gt;debug_assert_ne!&lt;/code&gt; is always type checked.</source>
          <target state="translated">&lt;a href=&quot;macro.assert_ne&quot;&gt; &lt;code&gt;assert_ne!&lt;/code&gt; &lt;/a&gt; 과 달리 ! , &lt;code&gt;debug_assert_ne!&lt;/code&gt; 문은 기본적으로 최적화되지 않은 빌드에서만 활성화됩니다. 최적화 된 빌드는 &lt;code&gt;debug_assert_ne!&lt;/code&gt; 실행하지 않습니다 ! &lt;code&gt;-C debug-assertions&lt;/code&gt; 이 컴파일러에 전달 되지 않는 한 명령문 . 이것은 &lt;code&gt;debug_assert_ne!&lt;/code&gt; 릴리스 빌드에 존재하기에는 너무 비싸지 만 개발 중에 도움이 될 수있는 검사에 유용합니다. &lt;code&gt;debug_assert_ne!&lt;/code&gt; 을 확장 한 결과 ! 항상 유형 검사입니다.</target>
        </trans-unit>
        <trans-unit id="04d1e96304d1bbf7140b253d02ca2ad39e16daa5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_ne&quot;&gt;&lt;code&gt;assert_ne!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will omit all &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_ne!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development.</source>
          <target state="translated">&lt;a href=&quot;macro.assert_ne&quot;&gt; &lt;code&gt;assert_ne!&lt;/code&gt; &lt;/a&gt; 과 달리 ! , &lt;code&gt;debug_assert_ne!&lt;/code&gt; 명령문은 기본적으로 최적화되지 않은 빌드에서만 사용 가능합니다. 최적화 된 빌드는 모든 &lt;code&gt;debug_assert_ne!&lt;/code&gt; 을 생략합니다 ! &lt;code&gt;-C debug-assertions&lt;/code&gt; 가 컴파일러에 전달 되지 않는 한 명령문 . 이것은 &lt;code&gt;debug_assert_ne!&lt;/code&gt; 릴리스 빌드에 포함하기에는 너무 비싸지 만 개발 중에 도움이 될 수있는 검사에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6cce36d9c22bd93c2a41b7e0597974f3cee7e7ac" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 가짜로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드를 생성 할 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="5c9ddf39955f900e36cc1e90f2b549ad7472a5bd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomici16#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicI16::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomici16#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicI16::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 가짜로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드를 생성 할 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="d36949a10789f440243db02c27d7a2a4839d4968" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomici32#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicI32::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomici32#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicI32::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 가짜로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드가 생성 될 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="541167404f49247535e6737ca512feb21f2cf377" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomici64#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicI64::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomici64#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicI64::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 허위로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드를 생성 할 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="bac30468509752a4dadb45b544078909afc04dd2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomici8#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicI8::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomici8#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicI8::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 허위로 실패 할 수 있으므로 일부 플랫폼에서는 더 효율적인 코드가 생성 될 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="f1e77b06d8fc7bb242ede2586728e20cd5ec38f2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicisize#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicIsize::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomicisize#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicIsize::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 가짜로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드를 생성 할 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9c1cb338dee4d9a50fbbd7a4ca8f1d9671b92ea5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicptr#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicPtr::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomicptr#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicPtr::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 가짜로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드를 생성 할 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="fcca6a9c5592b18a67aa751975baab86b8d73470" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicu16#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicU16::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomicu16#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicU16::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 가짜로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드를 생성 할 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8564dc4303f86be3afe445dd42ac378dde93ba88" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicu32#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicU32::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomicu32#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicU32::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 가짜로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드를 생성 할 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="b2f28ad76976058589a61b38b753ee6ff0210850" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicu64#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicU64::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomicu64#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicU64::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 가짜로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드를 생성 할 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="76887ce7cd48ec3a42bf06e1a6d5d6113a38547a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicu8#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicU8::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomicu8#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicU8::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 허위로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드를 생성 할 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="beb26d7e8cfff635de8d1457d1dfb96fc541fdd8" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicusize#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicUsize::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomicusize#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicUsize::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 가짜로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드를 생성 할 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8e0f6d29be16ce7f6bbb39d8f34d156c5bad7880" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once()&lt;/code&gt;&lt;/a&gt;, if this &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; has been poisoned (i.e., a previous call to &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt;&lt;code&gt;call_once_force()&lt;/code&gt;&lt;/a&gt; caused a panic), calling &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt;&lt;code&gt;call_once_force()&lt;/code&gt;&lt;/a&gt; will still invoke the closure &lt;code&gt;f&lt;/code&gt; and will &lt;em&gt;not&lt;/em&gt; result in an immediate panic. If &lt;code&gt;f&lt;/code&gt; panics, the &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; will remain in a poison state. If &lt;code&gt;f&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic, the &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; will no longer be in a poison state and all future calls to &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt;&lt;code&gt;call_once_force()&lt;/code&gt;&lt;/a&gt; will be no-ops.</source>
          <target state="translated">달리 &lt;a href=&quot;struct.once#method.call_once&quot;&gt; &lt;code&gt;call_once()&lt;/code&gt; &lt;/a&gt; ,이 경우 &lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt; 중독 된 (즉,에 대한 이전 호출 &lt;a href=&quot;struct.once#method.call_once&quot;&gt; &lt;code&gt;call_once()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt; &lt;code&gt;call_once_force()&lt;/code&gt; &lt;/a&gt; 호출, 패닉의 원인) &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt; &lt;code&gt;call_once_force()&lt;/code&gt; &lt;/a&gt; 폐쇄 된 invoke 여전히 것이다 &lt;code&gt;f&lt;/code&gt; 것 &lt;em&gt;하지&lt;/em&gt; 즉시 공황을 초래할. 경우 &lt;code&gt;f&lt;/code&gt; 패닉의는 &lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt; 포이즌 상태를 유지합니다. 경우 &lt;code&gt;f&lt;/code&gt; 는 않습니다 &lt;em&gt;하지&lt;/em&gt; 공포의이 &lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt; 더 이상 독 상태에있을 것이며, 모든 미래의 통화 &lt;a href=&quot;struct.once#method.call_once&quot;&gt; &lt;code&gt;call_once()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt; &lt;code&gt;call_once_force()&lt;/code&gt; &lt;/a&gt; 어떤 작전 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="97444204f29f9f8d725d9dd412f9b1cb5f20d4e2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once&lt;/code&gt;&lt;/a&gt;, if this &lt;code&gt;Once&lt;/code&gt; has been poisoned (i.e., a previous call to &lt;code&gt;call_once&lt;/code&gt; or &lt;code&gt;call_once_force&lt;/code&gt; caused a panic), calling &lt;code&gt;call_once_force&lt;/code&gt; will still invoke the closure &lt;code&gt;f&lt;/code&gt; and will &lt;em&gt;not&lt;/em&gt; result in an immediate panic. If &lt;code&gt;f&lt;/code&gt; panics, the &lt;code&gt;Once&lt;/code&gt; will remain in a poison state. If &lt;code&gt;f&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic, the &lt;code&gt;Once&lt;/code&gt; will no longer be in a poison state and all future calls to &lt;code&gt;call_once&lt;/code&gt; or &lt;code&gt;call_one_force&lt;/code&gt; will be no-ops.</source>
          <target state="translated">달리 &lt;a href=&quot;struct.once#method.call_once&quot;&gt; &lt;code&gt;call_once&lt;/code&gt; &lt;/a&gt; 이 경우, &lt;code&gt;Once&lt;/code&gt; 중독 된 (즉,에 대한 이전 호출 &lt;code&gt;call_once&lt;/code&gt; 또는 &lt;code&gt;call_once_force&lt;/code&gt; 는 호출, 패닉의 원인) &lt;code&gt;call_once_force&lt;/code&gt; 를 여전히 폐쇄 호출합니다 &lt;code&gt;f&lt;/code&gt; 것 &lt;em&gt;하지&lt;/em&gt; 즉시 공황을 초래할. 경우 &lt;code&gt;f&lt;/code&gt; 패닉의는 &lt;code&gt;Once&lt;/code&gt; 포이즌 상태를 유지합니다. &lt;code&gt;f&lt;/code&gt; 가 패닉 상태 가 &lt;em&gt;아닌&lt;/em&gt; 경우 &lt;code&gt;Once&lt;/code&gt; 는 더 이상 독 상태가 &lt;code&gt;call_once&lt;/code&gt; 향후 call_once 또는 &lt;code&gt;call_one_force&lt;/code&gt; 에 대한 모든 호출 은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69bf1113333b0a6b470f760044140ccfaef050a0" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.string#method.from_utf8_lossy&quot;&gt;&lt;code&gt;from_utf8_lossy&lt;/code&gt;&lt;/a&gt; which returns a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;from_utf16_lossy&lt;/code&gt; returns a &lt;code&gt;String&lt;/code&gt; since the UTF-16 to UTF-8 conversion requires a memory allocation.</source>
          <target state="translated">&lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt; &lt;/a&gt; 을 반환하는 &lt;a href=&quot;struct.string#method.from_utf8_lossy&quot;&gt; &lt;code&gt;from_utf8_lossy&lt;/code&gt; &lt;/a&gt; 와 달리 , &lt;code&gt;from_utf16_lossy&lt;/code&gt; 는 UTF-16에서 UTF-8 로의 변환에 메모리 할당이 필요하기 때문에 &lt;code&gt;String&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9701139045e2ad48d71d09c86c7eff61381e89c9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;, this will not attempt to fill the buffer if it is empty.</source>
          <target state="translated">&lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt; 와 달리 , 비어있는 경우 버퍼를 채우려 고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb694c3e76472c257054ea4932b6e425a8976f9f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.globalalloc&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt;, zero-sized allocations are allowed in &lt;code&gt;AllocRef&lt;/code&gt;. If an underlying allocator does not support this (like jemalloc) or return a null pointer (such as &lt;code&gt;libc::malloc&lt;/code&gt;), this must be caught by the implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53e5897fa59de78d867c186db4554c739885b98" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt;, there is no guarantee that the returned ranges of this and &lt;a href=&quot;trait.searcher#method.next_match&quot;&gt;&lt;code&gt;next_match&lt;/code&gt;&lt;/a&gt; will overlap.</source>
          <target state="translated">&lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt; 와 달리 this 및 &lt;a href=&quot;trait.searcher#method.next_match&quot;&gt; &lt;code&gt;next_match&lt;/code&gt; &lt;/a&gt; 의 반환 된 범위 가 겹칠 것이라는 보장은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7d5b411ac352c96a1edc968b7e49d8e28ffb6bde" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt;, there is no guarantee that the returned ranges of this and &lt;a href=&quot;trait.searcher#method.next_reject&quot;&gt;&lt;code&gt;next_reject&lt;/code&gt;&lt;/a&gt; will overlap. This will return &lt;code&gt;(start_match, end_match)&lt;/code&gt;, where start_match is the index of where the match begins, and end_match is the index after the end of the match.</source>
          <target state="translated">&lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt; 와 달리 this 및 &lt;a href=&quot;trait.searcher#method.next_reject&quot;&gt; &lt;code&gt;next_reject&lt;/code&gt; &lt;/a&gt; 의 반환 된 범위 가 겹칠 것이라는 보장은 없습니다 . 이것은 &lt;code&gt;(start_match, end_match)&lt;/code&gt; 를 반환합니다 . 여기서 start_match는 일치가 시작되는 인덱스이고 end_match는 일치가 끝난 후의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="b07cc87b6de700e95562f870286c85dae89d1a54" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt;, this takes a &lt;em&gt;mutable&lt;/em&gt; reference to a slice of &lt;a href=&quot;struct.ioslice&quot;&gt;&lt;code&gt;IoSlice&lt;/code&gt;&lt;/a&gt;s, not an immutable one. That's because we need to modify the slice to keep track of the bytes already written.</source>
          <target state="translated">&lt;a href=&quot;trait.write#method.write_vectored&quot;&gt; &lt;code&gt;write_vectored&lt;/code&gt; &lt;/a&gt; 와 달리 이것은 불변이 아닌 &lt;a href=&quot;struct.ioslice&quot;&gt; &lt;code&gt;IoSlice&lt;/code&gt; &lt;/a&gt; 슬라이스에 대한 &lt;em&gt;가변&lt;/em&gt; 참조를 취합니다 . 이미 쓴 바이트를 추적하기 위해 슬라이스를 수정해야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="eee6890d64168a6d63a327f53d097426ab508e0a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;*mut T&lt;/code&gt;, &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; is covariant over &lt;code&gt;T&lt;/code&gt;. If this is incorrect for your use case, you should include some &lt;a href=&quot;../marker/struct.phantomdata&quot;&gt;&lt;code&gt;PhantomData&lt;/code&gt;&lt;/a&gt; in your type to provide invariance, such as &lt;code&gt;PhantomData&amp;lt;Cell&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a mut T&amp;gt;&lt;/code&gt;. Usually this won't be necessary; covariance is correct for most safe abstractions, such as &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Rc&lt;/code&gt;, &lt;code&gt;Arc&lt;/code&gt;, &lt;code&gt;Vec&lt;/code&gt;, and &lt;code&gt;LinkedList&lt;/code&gt;. This is the case because they provide a public API that follows the normal shared XOR mutable rules of Rust.</source>
          <target state="translated">달리 &lt;code&gt;*mut T&lt;/code&gt; , &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; IS 공변 위에 &lt;code&gt;T&lt;/code&gt; . 이것이 사용 사례에 맞지 않으면 &lt;code&gt;PhantomData&amp;lt;Cell&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a mut T&amp;gt;&lt;/code&gt; 와 같이 불일치 를 제공하기 위해 &lt;a href=&quot;../marker/struct.phantomdata&quot;&gt; &lt;code&gt;PhantomData&lt;/code&gt; &lt;/a&gt; 를 유형에 포함시켜야 합니다 . 보통 이것은 필요하지 않습니다. 공분산은 &lt;code&gt;Box&lt;/code&gt; , &lt;code&gt;Rc&lt;/code&gt; , &lt;code&gt;Arc&lt;/code&gt; , &lt;code&gt;Vec&lt;/code&gt; 및 &lt;code&gt;LinkedList&lt;/code&gt; 와 같은 대부분의 안전한 추상화에 적합 합니다. Rust의 일반적인 공유 XOR 변경 가능 규칙을 따르는 공개 API를 제공하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="da5b9cd95305c47f8c2680144fa717b64a77ae08" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;*mut T&lt;/code&gt;, the pointer must always be non-null, even if the pointer is never dereferenced. This is so that enums may use this forbidden value as a discriminant -- &lt;code&gt;Option&amp;lt;NonNull&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; has the same size as &lt;code&gt;*mut T&lt;/code&gt;. However the pointer may still dangle if it isn't dereferenced.</source>
          <target state="translated">&lt;code&gt;*mut T&lt;/code&gt; 와 달리 포인터가 역 참조되지 않더라도 포인터는 항상 널이 아니어야합니다. 이것은 열거 형이이 금지 된 값을 판별 자로 사용할 수 있도록하기위한 것입니다. &lt;code&gt;Option&amp;lt;NonNull&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 는 &lt;code&gt;*mut T&lt;/code&gt; 와 크기가 같습니다 . 그러나 포인터가 역 참조되지 않으면 여전히 매달려있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2af92ae1d7844362d4deb8a5a097d647449edca7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;AsRef&lt;/code&gt;, &lt;a href=&quot;../borrow/trait.borrow&quot;&gt;&lt;code&gt;Borrow&lt;/code&gt;&lt;/a&gt; has a blanket impl for any &lt;code&gt;T&lt;/code&gt;, and can be used to accept either a reference or a value.</source>
          <target state="translated">달리 &lt;code&gt;AsRef&lt;/code&gt; , &lt;a href=&quot;../borrow/trait.borrow&quot;&gt; &lt;code&gt;Borrow&lt;/code&gt; &lt;/a&gt; 임의 용 블랭킷 IMPL 갖는 &lt;code&gt;T&lt;/code&gt; 를 하고, 기준 위치 값 중 하나를 수용 할 수있다.</target>
        </trans-unit>
        <trans-unit id="23b18281654acc984643104c10e5e6c721877239" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;AsRef&lt;/code&gt;, &lt;code&gt;Borrow&lt;/code&gt; has a blanket impl for any &lt;code&gt;T&lt;/code&gt;, and can be used to accept either a reference or a value.</source>
          <target state="translated">&lt;code&gt;AsRef&lt;/code&gt; 와 달리 &lt;code&gt;Borrow&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 에 대한 담요 임펄스 를 가지며 참조 또는 값을 수락하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ceb8d46ab7abd8b54416adda315f1d04158fc52" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;C&lt;/code&gt;, zero sized structs are not rounded up to one byte in size.</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 와 달리 크기가 0 인 구조체는 크기가 1 바이트로 반올림되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02f8b77aa6c48466699ca8ee968807c87cf6172e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;C&lt;/code&gt;, zero sized unions are not rounded up to one byte in size.</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 와 달리 크기가 0 인 유니언은 1 바이트 크기로 올림되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af8a23b1549826352efacb218921580838863fd0" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;Pin::new_unchecked&lt;/code&gt;, this method is safe because the pointer &lt;code&gt;P&lt;/code&gt; dereferences to an &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; type, which cancels the pinning guarantees.</source>
          <target state="translated">&lt;code&gt;Pin::new_unchecked&lt;/code&gt; 와는 달리 ,이 방법은 포인터 &lt;code&gt;P&lt;/code&gt; 가 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 유형을 역 참조 하여 고정 보장을 취소 하므로 안전 합니다 .</target>
        </trans-unit>
        <trans-unit id="f597f0fe6680930140f1186767bedc7add8ce577" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type represents single ownership over the data it holds. So, what makes &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; different from a type like &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;? Recall the borrowing rules you learned in Chapter 4:</source>
          <target state="translated">달리 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 상기 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 유형은 보유 데이터에 대한 단일 소유권을 나타낸다. 그렇다면 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 와 같은 유형과 다른 점은 무엇입니까? 4 장에서 배운 차용 규칙을 상기하십시오.</target>
        </trans-unit>
        <trans-unit id="926eeb30ef8b029d9a554336169dcbfbccf0209b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;RefCell::borrow&lt;/code&gt;, this method is unsafe because it does not return a &lt;code&gt;Ref&lt;/code&gt;, thus leaving the borrow flag untouched. Mutably borrowing the &lt;code&gt;RefCell&lt;/code&gt; while the reference returned by this method is alive is undefined behaviour.</source>
          <target state="translated">&lt;code&gt;RefCell::borrow&lt;/code&gt; 와 달리 ,이 메소드는 &lt;code&gt;Ref&lt;/code&gt; 를 반환하지 않기 때문에 안전하지 않으므로 차용 플래그를 그대로 둡니다. Mutably 차입 &lt;code&gt;RefCell&lt;/code&gt; 를 기준이 방법에 의해 리턴 동안 살아 정의되지 않은 문제이다.</target>
        </trans-unit>
        <trans-unit id="42c8dcf936cacded32e38266231efc7d97352aa2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;RefCell&lt;/code&gt;, a &lt;code&gt;OnceCell&lt;/code&gt; only provides shared &lt;code&gt;&amp;amp;T&lt;/code&gt; references to its value. Unlike &lt;code&gt;Cell&lt;/code&gt;, a &lt;code&gt;OnceCell&lt;/code&gt; doesn't require copying or replacing the value to access it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57c88d683b5f207c6b40e5f43b3334b288246db" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;connect&lt;/code&gt;, &lt;code&gt;connect_timeout&lt;/code&gt; takes a single &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; since timeout must be applied to individual addresses.</source>
          <target state="translated">달리 &lt;code&gt;connect&lt;/code&gt; , &lt;code&gt;connect_timeout&lt;/code&gt; 은 하나의 소요 &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; 을&lt;/a&gt; 제한 시간은 개별 주소에 적용해야하기 때문이다.</target>
        </trans-unit>
        <trans-unit id="1ac28d4f87c8eadd078ff1fbd83c69852aa4b470" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;fill_buf&lt;/code&gt;, this will not attempt to fill the buffer if it is empty.</source>
          <target state="translated">&lt;code&gt;fill_buf&lt;/code&gt; 와 달리 버퍼가 비어 있으면 버퍼를 채우려 고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c33686d3ffa81ffa69b98b7573a09c025985a84a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;read&lt;/code&gt;, the pointer may be unaligned.</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; 와 달리 포인터가 정렬되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5074eaba30dfa9d17ab40b89f4a8cde3f2ff28d5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;write&lt;/code&gt;, the pointer may be unaligned.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 와 달리 포인터가 정렬되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0869ce408d434adce2ac58f521663bfd0e76626c" translate="yes" xml:space="preserve">
          <source>Unlike an &lt;a href=&quot;../glossary#associated-item&quot;&gt;associated&lt;/a&gt; constant, a &lt;a href=&quot;../glossary#free-item&quot;&gt;free&lt;/a&gt; constant may be unnamed by using an underscore instead of the name. For example:</source>
          <target state="translated">&lt;a href=&quot;../glossary#associated-item&quot;&gt;연관된&lt;/a&gt; 상수 와 달리 &lt;a href=&quot;../glossary#free-item&quot;&gt;자유&lt;/a&gt; 상수는 이름 대신 밑줄을 사용하여 이름을 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1df7fba2918a10b0657219d3fc33575209df6ce" translate="yes" xml:space="preserve">
          <source>Unlike arithmetic and logical operators, the traits for overloading the operators the traits for these operators are used more generally to show how a type may be compared and will likely be assumed to define actual comparisons by functions that use these traits as bounds. Many functions and macros in the standard library can then use that assumption (although not to ensure safety). Unlike the arithmetic and logical operators above, these operators implicitly take shared borrows of their operands, evaluating them in &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression context&lt;/a&gt;:</source>
          <target state="translated">산술 및 논리 연산자와 달리 연산자 오버로드에 대한 특성은 이러한 연산자에 대한 특성이 유형을 비교하는 방법을 보여주기 위해 더 일반적으로 사용되며 이러한 특성을 경계로 사용하는 함수에 의한 실제 비교를 정의하는 것으로 가정됩니다. 표준 라이브러리의 많은 기능과 매크로는 안전을 보장하지는 않지만이 가정을 사용할 수 있습니다. 위의 산술 및 논리 연산자와 달리이 연산자는 암시 적으로 피연산자의 차용을 가져 와서 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;표현 컨텍스트를&lt;/a&gt; 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="121561ea59642cbf851a475739b422a107512b01" translate="yes" xml:space="preserve">
          <source>Unlike closures, &lt;code&gt;fn&lt;/code&gt; is a type rather than a trait, so we specify &lt;code&gt;fn&lt;/code&gt; as the parameter type directly rather than declaring a generic type parameter with one of the &lt;code&gt;Fn&lt;/code&gt; traits as a trait bound.</source>
          <target state="translated">클로저와 달리 &lt;code&gt;fn&lt;/code&gt; 은 특성이 아닌 유형이므로 &lt;code&gt;Fn&lt;/code&gt; 특성 중 하나를 특성 바인딩으로 사용하는 일반 유형 매개 변수를 선언하지 않고 &lt;code&gt;fn&lt;/code&gt; 을 매개 변수 유형으로 직접 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="ddb54f325fe389efa56003444a2d405f87525e97" translate="yes" xml:space="preserve">
          <source>Unlike for structs, local variables are dropped in reverse order:</source>
          <target state="translated">구조체와 달리 지역 변수는 역순으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="64287ed646615b0f4f1dbe6a0afd166352be3fa4" translate="yes" xml:space="preserve">
          <source>Unlike generic parameters or &lt;code&gt;impl Trait&lt;/code&gt;, the compiler does not know the concrete type that is being passed. That is, the type has been &lt;a href=&quot;https://en.wikipedia.org/wiki/Type_erasure&quot;&gt;erased&lt;/a&gt;. As such, a &lt;code&gt;dyn Trait&lt;/code&gt; reference contains &lt;em&gt;two&lt;/em&gt; pointers. One pointer goes to the data (e.g., an instance of a struct). Another pointer goes to a map of method call names to function pointers (known as a virtual method table or vtable).</source>
          <target state="translated">일반 매개 변수 또는 &lt;code&gt;impl Trait&lt;/code&gt; 과 달리 컴파일러는 전달되는 구체적인 유형을 알지 못합니다. 즉, 유형이 &lt;a href=&quot;https://en.wikipedia.org/wiki/Type_erasure&quot;&gt;지워졌습니다&lt;/a&gt; . 따라서 &lt;code&gt;dyn Trait&lt;/code&gt; 참조에는 &lt;em&gt;두 개의&lt;/em&gt; 포인터 가 포함 됩니다. 하나의 포인터는 데이터 (예 : 구조체의 인스턴스)로 이동합니다. 또 다른 포인터는 함수 포인터 (가상 메서드 테이블 또는 vtable이라고 함)에 대한 메서드 호출 이름 맵으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="7ac0121efe5c81f6ee999aad45c525acd80438be" translate="yes" xml:space="preserve">
          <source>Unlike in the TCP case, passing an array of addresses to the &lt;code&gt;connect&lt;/code&gt; function of a UDP socket is not a useful thing to do: The OS will be unable to determine whether something is listening on the remote address without the application sending data.</source>
          <target state="translated">TCP의 경우와 달리 , UDP 소켓 의 &lt;code&gt;connect&lt;/code&gt; 기능 에 주소 배열을 전달하는 것은 유용한 방법이 아닙니다. OS는 응용 프로그램이 데이터를 전송하지 않고 원격 주소에서 무언가 수신 중인지 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a7c8893077e685528bec1188265b9f18660f72cd" translate="yes" xml:space="preserve">
          <source>Unlike next(), there is no guarantee that the returned ranges of this and next_match will overlap.</source>
          <target state="translated">next ()와 달리이 범위와 next_match의 반환 범위가 겹칠 것이라는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="d71db212c677479519bbb6e79cc1b75787a4617d" translate="yes" xml:space="preserve">
          <source>Unlike next(), there is no guarantee that the returned ranges of this and next_reject will overlap. This will return (start_match, end_match), where start_match is the index of where the match begins, and end_match is the index after the end of the match.</source>
          <target state="translated">next ()와 달리 이것과 next_reject의 반환 범위가 겹칠 것이라는 보장은 없습니다. 그러면 start_match, end_match가 반환됩니다. 여기서 start_match는 일치가 시작되는 위치의 인덱스이고 end_match는 일치가 끝난 후의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="6692903ae621839ab645be72d216172c7413d4a0" translate="yes" xml:space="preserve">
          <source>Unlike normal functions, extern fns have type &lt;code&gt;extern &quot;ABI&quot; fn()&lt;/code&gt;. This is the same type as the functions declared in an extern block.</source>
          <target state="translated">일반 함수와 달리 extern fns에는 &lt;code&gt;extern &quot;ABI&quot; fn()&lt;/code&gt; 유형이 있습니다. 이것은 extern 블록에 선언 된 함수와 동일한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="36f4ada6278b2f8caced444ea3301e8d71339c65" translate="yes" xml:space="preserve">
          <source>Unlike other methods on &lt;code&gt;TcpStream&lt;/code&gt;, this does not correspond to a single system call. It instead calls &lt;code&gt;connect&lt;/code&gt; in nonblocking mode and then uses an OS-specific mechanism to await the completion of the connection request.</source>
          <target state="translated">&lt;code&gt;TcpStream&lt;/code&gt; 의 다른 메소드와 달리 이는 단일 시스템 호출에 해당하지 않습니다. 대신 비 차단 모드에서 &lt;code&gt;connect&lt;/code&gt; 를 호출 한 다음 OS 별 메커니즘을 사용하여 연결 요청 완료를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="d70fcfde3feb0ab38dc2fc9e1a50deff87be8c12" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; free function, this method yields an &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt; to capture any failure to create the thread at the OS level.</source>
          <target state="translated">&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt; 프리 기능 과 달리이 방법은 &lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; 를 생성하여 OS 레벨에서 스레드를 작성하는 데 실패한 것을 캡처합니다.</target>
        </trans-unit>
        <trans-unit id="f0b436366c65f5f44a2751625381a1b624985a04" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;offset&lt;/code&gt; intrinsic, this intrinsic does not restrict the resulting pointer to point into or one byte past the end of an allocated object, and it wraps with two's complement arithmetic. The resulting value is not necessarily valid to be used to actually access memory.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 내장 함수 와 달리이 내장 함수는 결과 포인터가 할당 된 객체의 끝을지나 1 바이트를 가리 키도록 제한하지 않으며 2의 보수 산술로 래핑됩니다. 결과 값이 실제로 메모리에 액세스하는 데 사용될 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="6faf47afea7f3d6a44a9251fcf64aa5fc01a6de0" translate="yes" xml:space="preserve">
          <source>Unlike the other kinds of loops in Rust (&lt;code&gt;while&lt;/code&gt;, &lt;code&gt;while let&lt;/code&gt;, and &lt;code&gt;for&lt;/code&gt;), loops can be used as expressions that return values via &lt;code&gt;break&lt;/code&gt;.</source>
          <target state="translated">Rust의 다른 종류의 루프 ( &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;while let&lt;/code&gt; 및 &lt;code&gt;for&lt;/code&gt; ) 와 달리 루프는 &lt;code&gt;break&lt;/code&gt; 를 통해 값을 반환하는 표현식으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c816b7f283c34ee4cf6d4ad3a434746ee09b413" translate="yes" xml:space="preserve">
          <source>Unnamed constant</source>
          <target state="translated">이름이없는 상수</target>
        </trans-unit>
        <trans-unit id="2eba6a03b89a9ddb19e9cb15699a8737f8bab076" translate="yes" xml:space="preserve">
          <source>Unpin</source>
          <target state="translated">Unpin</target>
        </trans-unit>
        <trans-unit id="5ea7d63651b5ab2fca876bb44555b1ae728096be" translate="yes" xml:space="preserve">
          <source>Unqualified path patterns can refer to:</source>
          <target state="translated">규정되지 않은 경로 패턴은 다음을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76194078e8e620ab2e92b2710e1b86b55aa19577" translate="yes" xml:space="preserve">
          <source>Unrecoverable Errors with &lt;code id=&quot;unrecoverable-errors-with-panic&quot;&gt;panic!&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;unrecoverable-errors-with-panic&quot;&gt;panic!&lt;/code&gt; 복구 할 수없는 오류 !</target>
        </trans-unit>
        <trans-unit id="70558ee42c96fb4886d205abf6563d627dc6cb30" translate="yes" xml:space="preserve">
          <source>Unregisters the current allocation error hook, returning it.</source>
          <target state="translated">현재 할당 오류 후크를 등록 취소하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0b233b52323b31980ad438994ac81379bf159f10" translate="yes" xml:space="preserve">
          <source>Unregisters the current panic hook, returning it.</source>
          <target state="translated">현재 패닉 후크를 등록 취소하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4ad2c25804ae1c9519924b3333558a84852f9759" translate="yes" xml:space="preserve">
          <source>Unsafe Rust</source>
          <target state="translated">안전하지 않은 녹</target>
        </trans-unit>
        <trans-unit id="2bf8239af3f464752ec2490794f409624c78c660" translate="yes" xml:space="preserve">
          <source>Unsafe Rust exists because, by nature, static analysis is conservative. When the compiler tries to determine whether or not code upholds the guarantees, it&amp;rsquo;s better for it to reject some valid programs rather than accept some invalid programs. Although the code might be okay, as far as Rust is able to tell, it&amp;rsquo;s not! In these cases, you can use unsafe code to tell the compiler, &amp;ldquo;Trust me, I know what I&amp;rsquo;m doing.&amp;rdquo; The downside is that you use it at your own risk: if you use unsafe code incorrectly, problems due to memory unsafety, such as null pointer dereferencing, can occur.</source>
          <target state="translated">안전하지 않은 녹은 본질적으로 정적 분석이 보수적이기 때문에 존재합니다. 컴파일러가 코드가 보증을 유지하는지 여부를 판별하려고 할 때 일부 유효하지 않은 프로그램을 승인하는 것보다 일부 유효 프로그램을 거부하는 것이 좋습니다. Rust가 말할 수있는 한 코드는 괜찮을 수도 있지만 그렇지 않습니다! 이 경우 안전하지 않은 코드를 사용하여 컴파일러에게&amp;ldquo;내가하는 일을 알고 있습니다.&amp;rdquo;라고 말할 수 있습니다. 안전하지 않은 코드를 잘못 사용하면 null 포인터 역 참조와 같은 메모리 안전 문제로 인해 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6d976facee53ef7685c3c2e196f51896ea84263" translate="yes" xml:space="preserve">
          <source>Unsafe Rust: how to opt out of some of Rust&amp;rsquo;s guarantees and take responsibility for manually upholding those guarantees</source>
          <target state="translated">안전하지 않은 녹 : Rust의 보증 중 일부를 선택 해제하고 해당 보증을 수동으로 유지하는 책임을지는 방법</target>
        </trans-unit>
        <trans-unit id="fe954ab5c7d2bf81229af474f3df1f82baf2452e" translate="yes" xml:space="preserve">
          <source>Unsafe Superpowers</source>
          <target state="translated">안전하지 않은 초능력</target>
        </trans-unit>
        <trans-unit id="213dd70d91f9e41a9bf1846e9c631a99cd907b6a" translate="yes" xml:space="preserve">
          <source>Unsafe abilities</source>
          <target state="translated">안전하지 않은 능력</target>
        </trans-unit>
        <trans-unit id="baac6e0b0340f8475119715946cbe8c2961f1b1b" translate="yes" xml:space="preserve">
          <source>Unsafe blocks</source>
          <target state="translated">안전하지 않은 블록</target>
        </trans-unit>
        <trans-unit id="14b175946b1bbc439b9bcf446b898eb6bb255e29" translate="yes" xml:space="preserve">
          <source>Unsafe blocks are used to wrap foreign libraries, make direct use of hardware or implement features not directly present in the language. For example, Rust provides the language features necessary to implement memory-safe concurrency in the language but the implementation of threads and message passing is in the standard library.</source>
          <target state="translated">안전하지 않은 블록은 외부 라이브러리를 래핑하거나 하드웨어를 직접 사용하거나 언어에 직접 존재하지 않는 기능을 구현하는 데 사용됩니다. 예를 들어, Rust는 언어로 메모리 안전 동시성을 구현하는 데 필요한 언어 기능을 제공하지만 스레드 및 메시지 전달 구현은 표준 라이브러리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="22664c4ba89e060c3e51b8ae88cd58e9bfacca10" translate="yes" xml:space="preserve">
          <source>Unsafe code may rely on &lt;code&gt;assert!&lt;/code&gt; to enforce run-time invariants that, if violated could lead to unsafety.</source>
          <target state="translated">안전하지 않은 코드는 &lt;code&gt;assert!&lt;/code&gt; 위반할 경우 안전하지 않을 수있는 런타임 불변성을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="c67e2a049687812f1b206c18f80d4f4b930977c1" translate="yes" xml:space="preserve">
          <source>Unsafe code relies on &lt;code&gt;assert!&lt;/code&gt; to enforce run-time invariants that, if violated could lead to unsafety.</source>
          <target state="translated">안전하지 않은 코드는 &lt;code&gt;assert!&lt;/code&gt; 의존합니다 ! 위반시 안전하지 않을 수있는 런타임 불변량을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="4155a1ec65a094fcbe134a0c2768d51a34c574a8" translate="yes" xml:space="preserve">
          <source>Unsafe code should not rely on the correctness of behavior after overflow.</source>
          <target state="translated">안전하지 않은 코드는 오버플로 후 동작의 정확성에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="c53274f3a611843db2cae74ec90f381fafeb9213" translate="yes" xml:space="preserve">
          <source>Unsafe code was used outside of an unsafe function or block.</source>
          <target state="translated">안전하지 않은 코드는 안전하지 않은 기능 또는 블록 외부에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="8e1ff2612e7d854020e10b3d3b36d74fbd9cd65b" translate="yes" xml:space="preserve">
          <source>Unsafe functions</source>
          <target state="translated">안전하지 않은 기능</target>
        </trans-unit>
        <trans-unit id="10b765166af116817c2643c79030e41920ee70d7" translate="yes" xml:space="preserve">
          <source>Unsafe functions are functions that are not safe in all contexts and/or for all possible inputs. Such a function must be prefixed with the keyword &lt;code&gt;unsafe&lt;/code&gt; and can only be called from an &lt;code&gt;unsafe&lt;/code&gt; block or another &lt;code&gt;unsafe&lt;/code&gt; function.</source>
          <target state="translated">안전하지 않은 기능은 모든 상황 및 / 또는 모든 가능한 입력에 대해 안전하지 않은 기능입니다. 이러한 함수는 &lt;code&gt;unsafe&lt;/code&gt; 키워드로 시작해야하며 &lt;code&gt;unsafe&lt;/code&gt; 블록이나 다른 &lt;code&gt;unsafe&lt;/code&gt; 함수 에서만 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d33167b0116d560739d43b19ab027e220d852053" translate="yes" xml:space="preserve">
          <source>Unsafe is used on an async function in precisely the same way that it is used on other functions: it indicates that the function imposes some additional obligations on its caller to ensure soundness. As in any other unsafe function, these conditions may extend beyond the initial call itself -- in the snippet above, for example, the &lt;code&gt;unsafe_example&lt;/code&gt; function took a pointer &lt;code&gt;x&lt;/code&gt; as argument, and then (when awaited) dereferenced that pointer. This implies that &lt;code&gt;x&lt;/code&gt; would have to be valid until the future is finished executing, and it is the callers responsibility to ensure that.</source>
          <target state="translated">Unsafe는 다른 함수에서 사용되는 것과 똑같은 방식으로 비동기 함수에서 사용됩니다. 이는 함수가 건전성을 보장하기 위해 호출자에게 몇 가지 추가 의무를 부과 함을 나타냅니다. 다른 안전 기능에서와 같이, 이러한 조건은 초기 호출 자체를 넘어 연장 될 수있다 - 위에서 코드에서, 예를 들면, &lt;code&gt;unsafe_example&lt;/code&gt; 함수 포인터했다 &lt;code&gt;x&lt;/code&gt; 인수로 한 다음 (대망시) 그 포인터를 역 참조. 이것은 미래가 실행을 마칠 때까지 &lt;code&gt;x&lt;/code&gt; 가 유효해야 함을 의미 하며이를 보장하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="44d7f0c36d2323b4760c5854a9da5e93bff496e9" translate="yes" xml:space="preserve">
          <source>Unsafe operations are those that can potentially violate the memory-safety guarantees of Rust's static semantics.</source>
          <target state="translated">안전하지 않은 작업은 Rust의 정적 의미론의 메모리 안전 보장을 위반할 가능성이있는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="bf164d180d2c3d60fa72dcb8309415b858fb3ef4" translate="yes" xml:space="preserve">
          <source>Unsafe traits</source>
          <target state="translated">안전하지 않은 특성</target>
        </trans-unit>
        <trans-unit id="3f92b08e3c34ebb357bc1ad626c86bb44dccf639" translate="yes" xml:space="preserve">
          <source>Unsafe traits must have unsafe implementations. This error occurs when an implementation for an unsafe trait isn't marked as unsafe. This may be resolved by marking the unsafe implementation as unsafe.</source>
          <target state="translated">안전하지 않은 특성에는 안전하지 않은 구현이 있어야합니다. 안전하지 않은 특성의 구현이 안전하지 않은 것으로 표시되지 않은 경우이 오류가 발생합니다. 안전하지 않은 구현을 안전하지 않은 것으로 표시하면이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5115d7bdd1417d736db11b27ea37e8ee82718f27" translate="yes" xml:space="preserve">
          <source>UnsafeCell</source>
          <target state="translated">UnsafeCell</target>
        </trans-unit>
        <trans-unit id="2c35a285bb852cf3e62f32e3633426c0ef4631a3" translate="yes" xml:space="preserve">
          <source>UnsafeCell::borrow</source>
          <target state="translated">UnsafeCell::borrow</target>
        </trans-unit>
        <trans-unit id="75bc0d417d751ed027f53b28049e848ca0749b51" translate="yes" xml:space="preserve">
          <source>UnsafeCell::borrow_mut</source>
          <target state="translated">UnsafeCell::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a881f13247abe21c6a44c037b8dd96d764dbe3f6" translate="yes" xml:space="preserve">
          <source>UnsafeCell::default</source>
          <target state="translated">UnsafeCell::default</target>
        </trans-unit>
        <trans-unit id="dff2508a0e8759e4bdb101a66e3d4f193575af5f" translate="yes" xml:space="preserve">
          <source>UnsafeCell::fmt</source>
          <target state="translated">UnsafeCell::fmt</target>
        </trans-unit>
        <trans-unit id="fdaf457db9ff90155c2c22c46f8d7d84bbcf495e" translate="yes" xml:space="preserve">
          <source>UnsafeCell::from</source>
          <target state="translated">UnsafeCell::from</target>
        </trans-unit>
        <trans-unit id="3345a29406bcc11d2b5b8b2bbebd7e4e0bd82ec5" translate="yes" xml:space="preserve">
          <source>UnsafeCell::get</source>
          <target state="translated">UnsafeCell::get</target>
        </trans-unit>
        <trans-unit id="c9466ca2fc8e49b6dbd92183423a4c8fa163622c" translate="yes" xml:space="preserve">
          <source>UnsafeCell::into</source>
          <target state="translated">UnsafeCell::into</target>
        </trans-unit>
        <trans-unit id="f93e09df9c8216c70f11ba4964e183b8a07e1fb7" translate="yes" xml:space="preserve">
          <source>UnsafeCell::into_inner</source>
          <target state="translated">UnsafeCell::into_inner</target>
        </trans-unit>
        <trans-unit id="b09cd160b3ecd626dee4e6ef60b717116e682ae5" translate="yes" xml:space="preserve">
          <source>UnsafeCell::new</source>
          <target state="translated">UnsafeCell::new</target>
        </trans-unit>
        <trans-unit id="4a93c833e143a391e62488b530430f04d10a5b76" translate="yes" xml:space="preserve">
          <source>UnsafeCell::try_from</source>
          <target state="translated">UnsafeCell::try_from</target>
        </trans-unit>
        <trans-unit id="cde666e236559ffd66009b3fdec4a7ed6f2c1d9f" translate="yes" xml:space="preserve">
          <source>UnsafeCell::try_into</source>
          <target state="translated">UnsafeCell::try_into</target>
        </trans-unit>
        <trans-unit id="3b8d314be6e0f9f234457b987c6cbb99be6adc66" translate="yes" xml:space="preserve">
          <source>UnsafeCell::type_id</source>
          <target state="translated">UnsafeCell::type_id</target>
        </trans-unit>
        <trans-unit id="e0539de3e0de023b7e2dd1485ffa3c4a0acc8d49" translate="yes" xml:space="preserve">
          <source>Unsafely creates a C string wrapper from a byte slice.</source>
          <target state="translated">바이트 슬라이스에서 C 문자열 래퍼를 안전하지 않게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="80d75cb6c5a344f6eadb72b7d847c31a12dc80ca" translate="yes" xml:space="preserve">
          <source>Unsafety</source>
          <target state="translated">Unsafety</target>
        </trans-unit>
        <trans-unit id="e91344ea16120944c87d0e0635826ca2b1e1956c" translate="yes" xml:space="preserve">
          <source>Unsigned</source>
          <target state="translated">Unsigned</target>
        </trans-unit>
        <trans-unit id="ec69039d9aace16bc0675cab4f4e5d7118fc67b0" translate="yes" xml:space="preserve">
          <source>Unsize</source>
          <target state="translated">Unsize</target>
        </trans-unit>
        <trans-unit id="8702197dc32e4fc5986508c97d9597351056f2bf" translate="yes" xml:space="preserve">
          <source>Unsized Coercions</source>
          <target state="translated">크기가없는 강제</target>
        </trans-unit>
        <trans-unit id="a090334da83d2c5e2a98abcbd42c6af2bf5571a1" translate="yes" xml:space="preserve">
          <source>Unsized data:</source>
          <target state="translated">크기가 조정되지 않은 데이터 :</target>
        </trans-unit>
        <trans-unit id="ea2569aaa33eada2280795d75f286bd6771924fe" translate="yes" xml:space="preserve">
          <source>Unstable Features</source>
          <target state="translated">불안정한 특징</target>
        </trans-unit>
        <trans-unit id="92ffa7782162b2b301a0b11d2aefb00ca2f2a2f0" translate="yes" xml:space="preserve">
          <source>Until now, all our examples have been matching structs or enums that were one level deep. Matching can work on nested items too!</source>
          <target state="translated">지금까지 우리의 모든 예제는 한 수준 깊이의 구조체 또는 열거와 일치했습니다. 중첩 된 항목에서도 매칭이 가능합니다!</target>
        </trans-unit>
        <trans-unit id="9a0d085fdd50abbdcb3c17611b8692b87c3b02d5" translate="yes" xml:space="preserve">
          <source>Until now, we&amp;rsquo;ve not talked about &lt;em&gt;global variables&lt;/em&gt;, which Rust does support but can be problematic with Rust&amp;rsquo;s ownership rules. If two threads are accessing the same mutable global variable, it can cause a data race.</source>
          <target state="translated">지금까지 우리는 Rust가 지원하지만 Rust의 소유권 규칙에 문제가 될 수있는 &lt;em&gt;전역 변수&lt;/em&gt; 에 대해서는 이야기하지 않았습니다 . 두 개의 스레드가 동일한 가변 글로벌 변수에 액세스하는 경우 데이터 경쟁이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bef75503876861f1652d24e0b101fc042661d7b5" translate="yes" xml:space="preserve">
          <source>Until these issues are resolved, you can use the &lt;a href=&quot;https://crates.io/crates/async-trait&quot;&gt;&lt;code&gt;async-trait&lt;/code&gt; crate&lt;/a&gt;, allowing you to use &lt;code&gt;async fn&lt;/code&gt; in traits by desugaring to &quot;boxed futures&quot; (&lt;code&gt;Pin&amp;lt;Box&amp;lt;dyn Future + Send + 'async&amp;gt;&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">이러한 문제가 해결 될 때까지 &lt;a href=&quot;https://crates.io/crates/async-trait&quot;&gt; &lt;code&gt;async-trait&lt;/code&gt; crate&lt;/a&gt; 를 사용 하면 &quot;boxed futures&quot;( &lt;code&gt;Pin&amp;lt;Box&amp;lt;dyn Future + Send + 'async&amp;gt;&amp;gt;&lt;/code&gt; ) 로 desugaring하여 특성에서 &lt;code&gt;async fn&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a466dbcb07d272a4827d08399fcc579473f95bac" translate="yes" xml:space="preserve">
          <source>Unused lifetime parameters</source>
          <target state="translated">사용하지 않은 수명 매개 변수</target>
        </trans-unit>
        <trans-unit id="67f29d2fd70384a80fd94676bef420c60ec02613" translate="yes" xml:space="preserve">
          <source>Unused type parameters</source>
          <target state="translated">사용하지 않는 유형 매개 변수</target>
        </trans-unit>
        <trans-unit id="4309bf93c467874d67ac366ea9fc690edd209fc3" translate="yes" xml:space="preserve">
          <source>UnwindSafe</source>
          <target state="translated">UnwindSafe</target>
        </trans-unit>
        <trans-unit id="cbc02d75adc1ffc39fd3a16b3b4074d157341ccf" translate="yes" xml:space="preserve">
          <source>Unwinding the Stack or Aborting in Response to a Panic</source>
          <target state="translated">공황에 대한 응답으로 스택 풀기 또는 중단</target>
        </trans-unit>
        <trans-unit id="2789441f00b1b852b1abc369acfc06188469d312" translate="yes" xml:space="preserve">
          <source>Unwraps a result or propagates its error.</source>
          <target state="translated">결과를 풀거나 오류를 전파합니다.</target>
        </trans-unit>
        <trans-unit id="bf154983f21c606f5ed175df0a60de13c896591a" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과를 풀고 &lt;a href=&quot;enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 의 내용을 산출합니다 .</target>
        </trans-unit>
        <trans-unit id="88ae872ed59ebfa48f0864e25ba0455dd8b90e15" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과를 풀고 &lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 의 내용을 산출합니다 .</target>
        </trans-unit>
        <trans-unit id="f6bb0d8e70fa6dd56dc1322239dbf82a2df0a4ac" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;. Else, it returns &lt;code&gt;optb&lt;/code&gt;.</source>
          <target state="translated">결과를 풀고 &lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 의 내용을 산출합니다 . 그렇지 않으면 &lt;code&gt;optb&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="117016b46649ef00153af6f7350c9138ecc67dda" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;. If the value is an &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; then it calls &lt;code&gt;op&lt;/code&gt; with its value.</source>
          <target state="translated">결과를 풀고 &lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 의 내용을 산출합니다 . 값이 &lt;a href=&quot;enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 이면 해당 값으로 &lt;code&gt;op&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="6d656a32648587effa39921eb330f108c0675d59" translate="yes" xml:space="preserve">
          <source>Unwraps an option, yielding the content of a &lt;a href=&quot;#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">옵션을 풀어서 &lt;a href=&quot;#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; 의 컨텐츠를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="44e46942e6b3560b76547c4068197f656ff8557f" translate="yes" xml:space="preserve">
          <source>Unwraps the value.</source>
          <target state="translated">값을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="cbbcbd99f909cf5773cc2f8cf87cdd95f999143d" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt;, returning the underlying reader.</source>
          <target state="translated">이 &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; 해제 하고 기본 판독기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="45c0f60884f81c191ed8a1499ae68b62ce7e7ea6" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufReader&lt;/code&gt;, returning the underlying reader.</source>
          <target state="translated">이 &lt;code&gt;BufReader&lt;/code&gt; 의 랩을 해제 해 , 기본이되는 리더를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="d79f711284b065af6b4e74f8652871df33141f21" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt;, returning the underlying writer.</source>
          <target state="translated">이 &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt; 언 래핑 하고 기본 라이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="69524452be5afea8f11639be9af1a3cd4b2bfb03" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufWriter&lt;/code&gt;, returning the underlying writer.</source>
          <target state="translated">이 &lt;code&gt;BufWriter&lt;/code&gt; 의 랩을 해제 해 , 기본이되는 라이터를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="935d143678423728d032f85b20c66b89ea1e5a53" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;LineWriter&lt;/code&gt;, returning the underlying writer.</source>
          <target state="translated">이 &lt;code&gt;LineWriter&lt;/code&gt; 의 랩을 해제 해 , 기본이되는 라이터를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="2e3b12243482f11a01fe101039b067f041f66124" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; returning the underlying pointer.</source>
          <target state="translated">기본이되는 포인터를 돌려주는 이 &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; 랩을 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="9b17789b43e82ba91c88e4d986c1f5d5ba8289b4" translate="yes" xml:space="preserve">
          <source>Update the two instances of duplicated code to call the function instead.</source>
          <target state="translated">대신 중복 된 코드의 두 인스턴스를 업데이트하여 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="9d8edb0cba2f3c71c929550f878ec6f1ab95a982" translate="yes" xml:space="preserve">
          <source>Update to a newer Rust version</source>
          <target state="translated">최신 Rust 버전으로 업데이트</target>
        </trans-unit>
        <trans-unit id="a37ad606755c045819fc66433cff2f591c85b628" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.path#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;extension&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.path#method.extension&quot;&gt; &lt;code&gt;self.extension&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;extension&lt;/code&gt; 업데이트 합니다 .</target>
        </trans-unit>
        <trans-unit id="b39de9c5b81e5a6bb6d85d389439d91c0bfb9619" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.path#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.path#method.file_name&quot;&gt; &lt;code&gt;self.file_name&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;file_name&lt;/code&gt; 으로 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="383cb3a84b0a57cded7c0258c7e1a49880c35c95" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;extension&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt; &lt;code&gt;self.extension&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;extension&lt;/code&gt; 으로 업데이트 합니다 .</target>
        </trans-unit>
        <trans-unit id="f3c4a6fdd4244e071cb1f5b4ee0c1015487b2074" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt; &lt;code&gt;self.file_name&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;file_name&lt;/code&gt; 으로 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="499d5f0f7c8875ae92624d65ec97b14c16b89ea7" translate="yes" xml:space="preserve">
          <source>Updates the contained value using a function and returns the new value.</source>
          <target state="translated">함수를 사용하여 포함 된 값을 업데이트하고 새 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="54c400ee034681ba4f94547c1f9e6d6c6ae60547" translate="yes" xml:space="preserve">
          <source>Updating a Crate to Get a New Version</source>
          <target state="translated">새 버전을 얻기 위해 상자 업데이트</target>
        </trans-unit>
        <trans-unit id="230bbf8ccb89f28d643435c51ba717b409f87480" translate="yes" xml:space="preserve">
          <source>Updating a Hash Map</source>
          <target state="translated">해시 맵 업데이트</target>
        </trans-unit>
        <trans-unit id="83885ba9f035a9010b4b1ccae0e7e7d6ed9f8e1e" translate="yes" xml:space="preserve">
          <source>Updating a String</source>
          <target state="translated">문자열 업데이트</target>
        </trans-unit>
        <trans-unit id="d2ba6d88a1646ea3bcd8516dafee00edcea72844" translate="yes" xml:space="preserve">
          <source>Updating a Value Based on the Old Value</source>
          <target state="translated">기존 값을 기준으로 값 업데이트</target>
        </trans-unit>
        <trans-unit id="923fa3af760fbaa62e4ad240ccab4df3cf7cd0e1" translate="yes" xml:space="preserve">
          <source>Updating a Vector</source>
          <target state="translated">벡터 업데이트</target>
        </trans-unit>
        <trans-unit id="e383c87cdb72887f6744a78bd78fa459e44a666d" translate="yes" xml:space="preserve">
          <source>Updating and Uninstalling</source>
          <target state="translated">업데이트 및 제거</target>
        </trans-unit>
        <trans-unit id="874862d7b95e02718d554f979aec41adae9c4cee" translate="yes" xml:space="preserve">
          <source>Upon receiving spin-loop signal the processor can optimize its behavior by, for example, saving power or switching hyper-threads.</source>
          <target state="translated">스핀 루프 신호를 수신하면 프로세서는 예를 들어 전력을 절약하거나 하이퍼 스레드를 전환하여 동작을 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0b0bd731b8e15bb23bd7cc76d2aa724aa6bbacd" translate="yes" xml:space="preserve">
          <source>Upon receiving the spin-loop signal the processor can optimize its behavior by, for example, saving power or switching hyper-threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22415b6a3d0c513d757498ec107592efc88cd6e4" translate="yes" xml:space="preserve">
          <source>UpperExp</source>
          <target state="translated">UpperExp</target>
        </trans-unit>
        <trans-unit id="fcfc7b5ea59d907143490b4156e6805ce49d5515" translate="yes" xml:space="preserve">
          <source>UpperExp::fmt</source>
          <target state="translated">UpperExp::fmt</target>
        </trans-unit>
        <trans-unit id="f690e8510e34f299255dfcc6523578488db8db3e" translate="yes" xml:space="preserve">
          <source>UpperHex</source>
          <target state="translated">UpperHex</target>
        </trans-unit>
        <trans-unit id="2bafd282159acd4fe944a3d1a0e5e2492ec2091e" translate="yes" xml:space="preserve">
          <source>UpperHex::fmt</source>
          <target state="translated">UpperHex::fmt</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="8139f3704cf1ae8bc1b831776ef1b322f4905331" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; for this behavior.</source>
          <target state="translated">이 동작 에는 &lt;a href=&quot;#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="31c647ca0e64548e5df242f616757ada55c0dfbe" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; for this behavior.</source>
          <target state="translated">이 동작을 위해 &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="687f0dae29440086643b86ae5972f2641cdbdfdb" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;fn.park_timeout&quot;&gt;&lt;code&gt;park_timeout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fn.park_timeout&quot;&gt; &lt;code&gt;park_timeout&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ebca8bdf54e76e24d82dc68f6b0bc04c50c7f47f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; for this behavior.</source>
          <target state="translated">이 동작을 위해 &lt;a href=&quot;primitive.str#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e960174a6840a72333f0c4af39164868fd34c4f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;struct.vec#method.get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.vec#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt; if you want to check whether the index is in the &lt;code&gt;Vec&lt;/code&gt;.</source>
          <target state="translated">인덱스가 &lt;code&gt;Vec&lt;/code&gt; 에 있는지 확인 하려면 &lt;a href=&quot;struct.vec#method.get&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.vec#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="88bbc8b66ff470f012eb3c0cc67e657fee2b3c01" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Fn&lt;/code&gt; as a bound when you want to accept a parameter of function-like type and need to call it repeatedly and without mutating state (e.g., when calling it concurrently). If you do not need such strict requirements, use &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; as bounds.</source>
          <target state="translated">함수형 유형의 매개 변수를 승인하고 변경 상태없이 (예 : 동시에 호출 할 때) 반복해서 호출해야하는 경우 &lt;code&gt;Fn&lt;/code&gt; 을 바운드로 사용하십시오 . 이러한 엄격한 요구 사항이 필요하지 않은 경우 &lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt; 를 범위로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="606e32d3718b3ad9261ab53d0c58fffdae2c3eb7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;FnMut&lt;/code&gt; as a bound when you want to accept a parameter of function-like type and need to call it repeatedly, while allowing it to mutate state. If you don't want the parameter to mutate state, use &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; as a bound; if you don't need to call it repeatedly, use &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">함수와 같은 유형의 매개 변수를 승인하고 상태를 변경하는 동안 반복적으로 호출해야 할 경우 &lt;code&gt;FnMut&lt;/code&gt; 를 바운드로 사용하십시오 . 매개 변수가 상태를 변경하지 않게하려면 &lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; 을 바운드로 사용하십시오. 반복해서 호출 할 필요가 없으면 &lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0490417243191fd2b7e8ec23e8ffa3dcdc8fa81b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;FnOnce&lt;/code&gt; as a bound when you want to accept a parameter of function-like type and only need to call it once. If you need to call the parameter repeatedly, use &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; as a bound; if you also need it to not mutate state, use &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;FnOnce&lt;/code&gt; 유형의 매개 변수를 승인하고 한 번만 호출해야하는 경우 FnOnce 를 바운드로 사용하십시오 . 매개 변수를 반복해서 호출해야하는 경우 &lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; 를 바운드로 사용 하십시오 . 상태를 변경하지 않으려면 &lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="58e9a37a75f6d151dc00d0d282a3a92ae64a1400" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ThreadPool&lt;/code&gt; to perform some task other than serving web requests.</source>
          <target state="translated">웹 요청을 제공하는 것 이외의 작업을 수행 하려면 &lt;code&gt;ThreadPool&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d84e22d164ffb7c941231da29582df4847d529a7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;async&lt;/code&gt; in front of &lt;code&gt;fn&lt;/code&gt;, &lt;code&gt;closure&lt;/code&gt;, or a &lt;code&gt;block&lt;/code&gt; to turn the marked code into a &lt;code&gt;Future&lt;/code&gt;. As such the code will not be run immediately, but will only be evaluated when the returned future is &lt;code&gt;.await&lt;/code&gt;ed.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; , &lt;code&gt;closure&lt;/code&gt; 또는 &lt;code&gt;block&lt;/code&gt; 앞에 &lt;code&gt;async&lt;/code&gt; 를 사용 하여 표시된 코드를 &lt;code&gt;Future&lt;/code&gt; 로 바꿉니다 . 따라서 코드는 즉시 실행되지 않지만 반환 된 future가 &lt;code&gt;.await&lt;/code&gt; ed 일 때만 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="b14f208baffea7d1c86f95f732b3ef39c695038a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;eprint!&lt;/code&gt; only for error and progress messages. Use &lt;code&gt;print!&lt;/code&gt; instead for the primary output of your program.</source>
          <target state="translated">&lt;code&gt;eprint!&lt;/code&gt; 사용하십시오 ! 오류 및 진행 메시지에만 해당됩니다. &lt;code&gt;print!&lt;/code&gt; 사용하십시오 ! 대신 프로그램의 기본 출력을 위해.</target>
        </trans-unit>
        <trans-unit id="22665c8a7bbb569c824fae1113f4c37d6c60b38a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;eprintln!&lt;/code&gt; only for error and progress messages. Use &lt;code&gt;println!&lt;/code&gt; instead for the primary output of your program.</source>
          <target state="translated">&lt;code&gt;eprintln!&lt;/code&gt; 사용하십시오 ! 오류 및 진행 메시지에만 해당됩니다. &lt;code&gt;println!&lt;/code&gt; 사용하십시오 ! 대신 프로그램의 기본 출력을 위해.</target>
        </trans-unit>
        <trans-unit id="c5580c57c536b501604c5a18501909570a4f8755" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;mod&lt;/code&gt; to create new &lt;a href=&quot;../reference/items/modules&quot;&gt;modules&lt;/a&gt; to encapsulate code, including other modules:</source>
          <target state="translated">사용 &lt;code&gt;mod&lt;/code&gt; 새로운 생성 &lt;a href=&quot;../reference/items/modules&quot;&gt;모듈을&lt;/a&gt; 다른 모듈을 포함하여 캡슐화 코드를 :</target>
        </trans-unit>
        <trans-unit id="2ead4795448020930657e9470aadfc30b6e379b7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;print!&lt;/code&gt; only for the primary output of your program. Use &lt;a href=&quot;macro.eprint&quot;&gt;&lt;code&gt;eprint!&lt;/code&gt;&lt;/a&gt; instead to print error and progress messages.</source>
          <target state="translated">&lt;code&gt;print!&lt;/code&gt; 사용하십시오 ! 프로그램의 기본 출력에만 해당됩니다. &lt;a href=&quot;macro.eprint&quot;&gt; &lt;code&gt;eprint!&lt;/code&gt; &lt;/a&gt; 사용하십시오 ! 대신 오류 및 진행 메시지를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="8622f52bbce3eafc5d53c96e1ec31dc91867c0d2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;println!&lt;/code&gt; only for the primary output of your program. Use &lt;a href=&quot;macro.eprintln&quot;&gt;&lt;code&gt;eprintln!&lt;/code&gt;&lt;/a&gt; instead to print error and progress messages.</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; 사용하십시오 ! 프로그램의 기본 출력에만 해당됩니다. &lt;a href=&quot;macro.eprintln&quot;&gt; &lt;code&gt;eprintln!&lt;/code&gt; &lt;/a&gt; 사용하십시오 ! 대신 오류 및 진행 메시지를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="4a325d56085ed8734f6810e0ff71ad595b95fd50" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;BTreeMap&lt;/code&gt; when:</source>
          <target state="translated">다음과 &lt;code&gt;BTreeMap&lt;/code&gt; 경우 BTreeMap을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5b8b83e450ccf5b057f6e9cdd558c50e56abe87" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;BinaryHeap&lt;/code&gt; when:</source>
          <target state="translated">다음과 같은 경우 &lt;code&gt;BinaryHeap&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c44210c4cd02de7b469e04353c99013251f0bdb6" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;HashMap&lt;/code&gt; when:</source>
          <target state="translated">다음과 같은 경우 &lt;code&gt;HashMap&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="461b6ce24b45cd8f2525e7819f63e5f3b7e5d4c8" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;LinkedList&lt;/code&gt; when:</source>
          <target state="translated">다음과 같은 경우 &lt;code&gt;LinkedList&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8effe57e9b8b3183f9d4a4c43ec54816a50215a" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; as an efficient stack:</source>
          <target state="translated">효율적인 스택으로 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="18acad408e22b76af330889473712392d945f0e6" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;Vec&lt;/code&gt; when:</source>
          <target state="translated">다음과 같은 경우 &lt;code&gt;Vec&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="610593fe7c0408bbb0f35796499627c6f2245b92" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;VecDeque&lt;/code&gt; when:</source>
          <target state="translated">다음과 &lt;code&gt;VecDeque&lt;/code&gt; 경우 VecDeque를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="928e71deb9616cde37637c874eca1ef7178b77b4" translate="yes" xml:space="preserve">
          <source>Use a slice.</source>
          <target state="translated">슬라이스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="37c1eb662164587065262615f820c57ffe90b9ef" translate="yes" xml:space="preserve">
          <source>Use an array with a fixed length.</source>
          <target state="translated">길이가 고정 된 배열을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="aa019f3006a2c79cffd1cb8f757987c40c32ebd5" translate="yes" xml:space="preserve">
          <source>Use declarations</source>
          <target state="translated">선언 사용</target>
        </trans-unit>
        <trans-unit id="4285ed0690ab255637e0ac148f5c792cd6b8149b" translate="yes" xml:space="preserve">
          <source>Use declarations support a number of convenient shortcuts:</source>
          <target state="translated">사용 선언은 여러 가지 편리한 바로 가기를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1d940a95921bf352b68ae08ab069e2750541ca02" translate="yes" xml:space="preserve">
          <source>Use of a &lt;code&gt;str&lt;/code&gt; whose contents are not valid UTF-8 is undefined behavior.</source>
          <target state="translated">내용이 유효한 UTF-8이 아닌 &lt;code&gt;str&lt;/code&gt; 을 사용하는 것은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="d154502a3f5f6795f896efa6e13908d9370d8f9a" translate="yes" xml:space="preserve">
          <source>Use of generic parameters.</source>
          <target state="translated">일반 매개 변수 사용.</target>
        </trans-unit>
        <trans-unit id="5c5acc62e88ff47e84c111044c30c66db333ca88" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; syntax to write data to the standard output. See &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt; 사용하십시오 ! 표준 출력에 데이터를 쓰는 구문. 자세한 내용은 &lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2fbe9e80ba417914254163793e464ee62322f093" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ptr/fn.null_mut&quot;&gt;&lt;code&gt;null_mut&lt;/code&gt;&lt;/a&gt; functions to create null pointers, and the &lt;a href=&quot;primitive.pointer#method.is_null&quot;&gt;&lt;code&gt;is_null&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt; types to check for null. The &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt; types also define the &lt;a href=&quot;primitive.pointer#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt; method, for pointer math.</source>
          <target state="translated">사용 &lt;a href=&quot;ptr/fn.null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;ptr/fn.null_mut&quot;&gt; &lt;code&gt;null_mut&lt;/code&gt; &lt;/a&gt; 널 포인터 및 생성 기능을 &lt;a href=&quot;primitive.pointer#method.is_null&quot;&gt; &lt;code&gt;is_null&lt;/code&gt; &lt;/a&gt; 의 방법 &lt;code&gt;*const T&lt;/code&gt; 와 &lt;code&gt;*mut T&lt;/code&gt; 널 (null)를 확인하는 유형. &lt;code&gt;*const T&lt;/code&gt; 및 &lt;code&gt;*mut T&lt;/code&gt; 종류는 또한 정의 &lt;a href=&quot;primitive.pointer#method.offset&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt; 포인터 수학위한 방법.</target>
        </trans-unit>
        <trans-unit id="2e570be59fc7fd5ff7530405783a29f5828f0fe8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;Set&lt;/code&gt; variant of any of these &lt;code&gt;Map&lt;/code&gt;s when:</source>
          <target state="translated">다음 과 같은 경우 이러한 &lt;code&gt;Map&lt;/code&gt; 의 &lt;code&gt;Set&lt;/code&gt; 변형을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e80c04da83a86a4ecbf94ec7503d652753e12266" translate="yes" xml:space="preserve">
          <source>Use the code in Listing 12-1 to allow your &lt;code&gt;minigrep&lt;/code&gt; program to read any command line arguments passed to it and then collect the values into a vector.</source>
          <target state="translated">Listing 12-1의 코드를 사용하여 &lt;code&gt;minigrep&lt;/code&gt; 프로그램이 전달 된 명령 행 인수를 읽은 다음 값을 벡터로 수집하십시오.</target>
        </trans-unit>
        <trans-unit id="b7e242e19e576b066c1fbe08cfb0b75455ae8cac" translate="yes" xml:space="preserve">
          <source>Use the same lifetime requirement for both input and output values.</source>
          <target state="translated">입력 및 출력 값 모두에 대해 동일한 수명 요구 사항을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="45a96fe96ad1c2ec9146b51dd14fea6aa97e8389" translate="yes" xml:space="preserve">
          <source>Use this function only when you can prove that the code will never call it. Otherwise, consider using the &lt;a href=&quot;../macro.unreachable&quot;&gt;&lt;code&gt;unreachable!&lt;/code&gt;&lt;/a&gt; macro, which does not allow optimizations but will panic when executed.</source>
          <target state="translated">이 함수는 코드가이를 호출하지 않음을 증명할 수있는 경우에만 사용하십시오. 그렇지 않으면 &lt;a href=&quot;../macro.unreachable&quot;&gt; &lt;code&gt;unreachable!&lt;/code&gt; &lt;/a&gt; 사용해보십시오 ! 매크로는 최적화를 허용하지 않지만 실행되면 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="d6a3c9f03120ec47a98d4a452b1e2127aae8581a" translate="yes" xml:space="preserve">
          <source>Used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeFull&lt;/code&gt; produces the full array as a slice.</source>
          <target state="translated">A와 사용 &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;슬라이스 지수&lt;/a&gt; , &lt;code&gt;RangeFull&lt;/code&gt; 은 슬라이스로 전체 배열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0ee0968c281548e8c4956da0bb80d17ce6a46d94" translate="yes" xml:space="preserve">
          <source>Used for immutable dereferencing operations, like &lt;code&gt;*v&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*v&lt;/code&gt; 와 같은 불변의 역 참조 작업에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a4b9aeea072b24e3f199cbe699727a85aca473bd" translate="yes" xml:space="preserve">
          <source>Used for indexing operations (&lt;code&gt;container[index]&lt;/code&gt;) in immutable contexts.</source>
          <target state="translated">변경할 수없는 컨텍스트에서 인덱싱 작업 ( &lt;code&gt;container[index]&lt;/code&gt; )에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6a6db850fe7a0893deca48224e890877525cf009" translate="yes" xml:space="preserve">
          <source>Used for indexing operations (&lt;code&gt;container[index]&lt;/code&gt;) in mutable contexts.</source>
          <target state="translated">가변 컨텍스트에서 인덱싱 작업 ( &lt;code&gt;container[index]&lt;/code&gt; )에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b8ea53757bb98a6b5189506b4ea7e3a3e9a3ec16" translate="yes" xml:space="preserve">
          <source>Used for mutable dereferencing operations, like in &lt;code&gt;*v = 1;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*v = 1;&lt;/code&gt; 과 같이 변경 가능한 역 참조 작업에 사용됩니다 . .</target>
        </trans-unit>
        <trans-unit id="0fe043543944b7d7b206d45160cd5299a8af93e5" translate="yes" xml:space="preserve">
          <source>Used to create a default &lt;a href=&quot;trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; instance for types that implement &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 만드는 데 사용 &lt;a href=&quot;trait.buildhasher&quot;&gt; &lt;code&gt;BuildHasher&lt;/code&gt; 의&lt;/a&gt; 구현 유형에 대한 예를 &lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e28b1efed767d7b3e60d0a7700706d6642dda67" translate="yes" xml:space="preserve">
          <source>Used to do a cheap mutable-to-mutable reference conversion.</source>
          <target state="translated">저렴한 가변-변동 가능한 기준 변환을 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f1b7626a3b6465a294975154f6e043096ec5995f" translate="yes" xml:space="preserve">
          <source>Used to do a cheap reference-to-reference conversion.</source>
          <target state="translated">저렴한 참조 대 참조 변환을 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="14c0b7ffa101db42d6f394a0ed0a2a772e18316c" translate="yes" xml:space="preserve">
          <source>Used to do value-to-value conversions while consuming the input value. It is the reciprocal of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">입력 값을 소비하면서 값을 값으로 변환하는 데 사용됩니다. &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 의 역수입니다 .</target>
        </trans-unit>
        <trans-unit id="87832790df189d88ca8070bb6de895ef1d392b7c" translate="yes" xml:space="preserve">
          <source>Used to make try_fold closures more like normal loops</source>
          <target state="translated">try_fold 클로저를 일반 루프처럼 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3e26b00e1661d4c5dea648883f63653b80651f39" translate="yes" xml:space="preserve">
          <source>Used to run some code when a value goes out of scope. This is sometimes called a 'destructor'.</source>
          <target state="translated">값이 범위를 벗어날 때 일부 코드를 실행하는 데 사용됩니다. 이것을 '소멸자'라고도합니다.</target>
        </trans-unit>
        <trans-unit id="5dc9662fcc8a7efba76268741a2aa91414af229f" translate="yes" xml:space="preserve">
          <source>Useful synchronization primitives.</source>
          <target state="translated">유용한 동기화 프리미티브.</target>
        </trans-unit>
        <trans-unit id="b05cb9060bef7e9cf540890d5647fd3ffbac6f9d" translate="yes" xml:space="preserve">
          <source>User lacks permissions to create directory at &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 에 디렉토리를 만들 수있는 권한이 사용자에게 없습니다 .</target>
        </trans-unit>
        <trans-unit id="01ed5872aedec24d23d900d1581e6ff53ed21665" translate="yes" xml:space="preserve">
          <source>User-defined types:</source>
          <target state="translated">사용자 정의 유형 :</target>
        </trans-unit>
        <trans-unit id="62be4731dedfbbc70aa7fa30d6649d816af8ca4b" translate="yes" xml:space="preserve">
          <source>Uses</source>
          <target state="translated">Uses</target>
        </trans-unit>
        <trans-unit id="55cf66299b4b2f9f7eb9ea6abdf809a42de50634" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning.</source>
          <target state="translated">빌린 데이터를 사용하여 일반적으로 복제하여 소유 한 데이터를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="01c085ac9a4eda7ad0e1fc8b863d1b23ac3713d3" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;../../../borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">빌린 데이터를 사용하여 일반적으로 복제하여 소유 한 데이터를 대체합니다. &lt;a href=&quot;../../../borrow/trait.toowned#method.clone_into&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1a7e308c9ce8c72dc79594fe592d8ac0e474a60" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;../../borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">빌린 데이터를 사용하여 일반적으로 복제하여 소유 한 데이터를 대체합니다. &lt;a href=&quot;../../borrow/trait.toowned#method.clone_into&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="41f5a93c96209d01bd88a54a350a97a8859d2caf" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;../borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">빌린 데이터를 사용하여 일반적으로 복제하여 소유 한 데이터를 대체합니다. &lt;a href=&quot;../borrow/trait.toowned#method.clone_into&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="527bd4367972a752863741d60fd99d8435d00fca" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">빌린 데이터를 사용하여 일반적으로 복제하여 소유 한 데이터를 대체합니다. &lt;a href=&quot;borrow/trait.toowned#method.clone_into&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb87bc230d96c818f8f39be65a97f0f0c56ca879" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">빌린 데이터를 사용하여 일반적으로 복제하여 소유 한 데이터를 대체합니다. &lt;a href=&quot;trait.toowned#method.clone_into&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e92ce0c09d5d2c377945a784545c389cc7e9354" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;../std/ptr/fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;std::ptr::copy_nonoverlapping_memory&lt;/code&gt;&lt;/a&gt;, a.k.a. the &lt;code&gt;memcpy32&lt;/code&gt;and &lt;code&gt;memcpy64&lt;/code&gt; intrinsics, on overlapping buffers.</source>
          <target state="translated">겹치는 버퍼에서 &lt;a href=&quot;../std/ptr/fn.copy_nonoverlapping&quot;&gt; &lt;code&gt;std::ptr::copy_nonoverlapping_memory&lt;/code&gt; &lt;/a&gt; 사용 하여 &lt;code&gt;memcpy32&lt;/code&gt; 및 &lt;code&gt;memcpy64&lt;/code&gt; 내장 함수라고합니다.</target>
        </trans-unit>
        <trans-unit id="6e1dcc3d8137ddd7e3681f9bc104f285826b7f48" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; as success ordering makes the store part of this operation &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt;, and using &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; makes the final successful load &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt;. The (failed) load ordering can only be &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; and must be equivalent to or weaker than the success ordering.</source>
          <target state="translated">사용하여 &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 성공 주문이 작업의 저장 부분을 만들면서 &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; , 그리고 사용 &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; 최종 성공적으로로드하게 &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; . (실패한)로드 순서는 &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; 일&lt;/a&gt; 수 있으며 성공 순서와 같거나 약해야합니다.</target>
        </trans-unit>
        <trans-unit id="7a6e8bfcb648c037a665b572caa617368582e79d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;Iterator::collect()&lt;/code&gt;&lt;/a&gt; to implicitly use &lt;code&gt;FromIterator&lt;/code&gt;:</source>
          <target state="translated">사용 &lt;a href=&quot;trait.iterator#method.collect&quot;&gt; &lt;code&gt;Iterator::collect()&lt;/code&gt; &lt;/a&gt; 암시 적으로 사용하는 &lt;code&gt;FromIterator&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="f6057ce3700db1903febbd4571a9030f98dccb52" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; to implicitly use &lt;code&gt;FromIterator&lt;/code&gt;:</source>
          <target state="translated">사용 &lt;a href=&quot;trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt; 암시 적으로 사용하는 &lt;code&gt;FromIterator&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="b8581b668b89dc42d1d55734cab92752391e678b" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-boxt-like-a-reference&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; Like a Reference</source>
          <target state="translated">&lt;code id=&quot;using-boxt-like-a-reference&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 를 참조처럼 사용</target>
        </trans-unit>
        <trans-unit id="2786f97dc365e66bda997868734cec33ef9fcf92" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-boxt-to-get-a-recursive-type-with-a-known-size&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to Get a Recursive Type with a Known Size</source>
          <target state="translated">알려진 크기의 재귀 유형을 얻기 위해 &lt;code id=&quot;using-boxt-to-get-a-recursive-type-with-a-known-size&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="8300c99c1ff66e26c9f9b017e5522a93d571ce81" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-boxt-to-point-to-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to Point to Data on the Heap</source>
          <target state="translated">&lt;code id=&quot;using-boxt-to-point-to-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용 하여 힙의 데이터를 가리킴</target>
        </trans-unit>
        <trans-unit id="c4104bedba70839a84674c526e20638655c760d0" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-extern-functions-to-call-external-code&quot;&gt;extern&lt;/code&gt; Functions to Call External Code</source>
          <target state="translated">&lt;code id=&quot;using-extern-functions-to-call-external-code&quot;&gt;extern&lt;/code&gt; 함수를 사용하여 외부 코드 호출</target>
        </trans-unit>
        <trans-unit id="39a61fb39b0b2c2b47e27003fb9ca80ee4d7ca24" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-if-in-a-let-statement&quot;&gt;if&lt;/code&gt; in a &lt;code&gt;let&lt;/code&gt; Statement</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 문 에서 &lt;code id=&quot;using-if-in-a-let-statement&quot;&gt;if&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="17f21cd4682f3498e05d46c9ba5f0db1ecf73ca1" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-iterator-trait-methods-instead-of-indexing&quot;&gt;Iterator&lt;/code&gt; Trait Methods Instead of Indexing</source>
          <target state="translated">인덱싱 대신 &lt;code id=&quot;using-iterator-trait-methods-instead-of-indexing&quot;&gt;Iterator&lt;/code&gt; 특성 방법 사용</target>
        </trans-unit>
        <trans-unit id="cd4dbe3102cc8a86458c21a6edcf0745a3880b2c" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-move-closures-with-threads&quot;&gt;move&lt;/code&gt; Closures with Threads</source>
          <target state="translated">스레드와 함께 &lt;code id=&quot;using-move-closures-with-threads&quot;&gt;move&lt;/code&gt; 클로저 사용</target>
        </trans-unit>
        <trans-unit id="bcb24e74610f11ffcd8b36fc02251143626de877" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-rct-to-share-data&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to Share Data</source>
          <target state="translated">&lt;code id=&quot;using-rct-to-share-data&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용하여 데이터 공유</target>
        </trans-unit>
        <trans-unit id="4bedcde0cd8963bedfb716621a284a40e61ba006" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-resultt-e-in-tests&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; in Tests</source>
          <target state="translated">테스트에서 &lt;code id=&quot;using-resultt-e-in-tests&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="5d4e8a0abd2628d1463a51e66037adf55b78b3eb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;#[repr(C)]&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;#[repr(C)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfc71d2f097570894eba309d1d3e23fc1440f195" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; where the right-hand argument is greater than or equal to the number of bits in the type of the left-hand argument, or is negative.</source>
          <target state="translated">오른쪽 인수가 왼쪽 인수 유형의 비트 수보다 크거나 같은 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 사용 또는 음수.</target>
        </trans-unit>
        <trans-unit id="b645209e67cee4f9f92c20f0e033dab698fba2f2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt;, where the left-hand argument is the smallest integer of a signed integer type and the right-hand argument is &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;/&lt;/code&gt; 또는 &lt;code&gt;%&lt;/code&gt; 왼쪽의 인수가 부호있는 정수 타입과 오른쪽 인수의 가장 작은 정수입니다 &lt;code&gt;-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d0998ec9f168a2eeef48fd713f566a42f1d1993" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;@&lt;/code&gt; lets us test a value and save it in a variable within one pattern.</source>
          <target state="translated">사용 &lt;code&gt;@&lt;/code&gt; 우리가 값을 테스트하고 하나 개의 패턴 내에서 변수에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ae9824a370d1fed45ea9444f749e0c2d3a71823" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;AsMut&lt;/code&gt; as trait bound for a generic function we can accept all mutable references that can be converted to type &lt;code&gt;&amp;amp;mut T&lt;/code&gt;. Because &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt; we can write a function &lt;code&gt;add_one&lt;/code&gt; that takes all arguments that can be converted to &lt;code&gt;&amp;amp;mut u64&lt;/code&gt;. Because &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;add_one&lt;/code&gt; accepts arguments of type &lt;code&gt;&amp;amp;mut Box&amp;lt;u64&amp;gt;&lt;/code&gt; as well:</source>
          <target state="translated">일반 함수에 대한 특성 바인딩으로 &lt;code&gt;AsMut&lt;/code&gt; 을 사용하여 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 유형으로 변환 할 수있는 모든 가변 참조를 허용 할 수 있습니다 . 때문에 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 구현 &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt; 우리는 함수를 작성할 수 있습니다 &lt;code&gt;add_one&lt;/code&gt; 로 변환 할 수있는 모든 인수를 취 &lt;code&gt;&amp;amp;mut u64&lt;/code&gt; . 때문에 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 구현 &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;add_one&lt;/code&gt; 이 형의 인수를 받아 &lt;code&gt;&amp;amp;mut Box&amp;lt;u64&amp;gt;&lt;/code&gt; 뿐만 아니라 :</target>
        </trans-unit>
        <trans-unit id="e5f61609aec29d1aa58bf125645b7b8bf1c8648b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;BuildHasherDefault&lt;/code&gt; to specify a custom &lt;a href=&quot;trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">사용 &lt;code&gt;BuildHasherDefault&lt;/code&gt; 을 사용자 정의 지정 &lt;a href=&quot;trait.buildhasher&quot;&gt; &lt;code&gt;BuildHasher&lt;/code&gt; &lt;/a&gt; 에 대한 &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="741ce1478263e946f77de5614872f7257f7d9bd0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;TcpListener&lt;/code&gt;, we can listen for TCP connections at the address &lt;code&gt;127.0.0.1:7878&lt;/code&gt;. In the address, the section before the colon is an IP address representing your computer (this is the same on every computer and doesn&amp;rsquo;t represent the authors&amp;rsquo; computer specifically), and &lt;code&gt;7878&lt;/code&gt; is the port. We&amp;rsquo;ve chosen this port for two reasons: HTTP is normally accepted on this port, and 7878 is &lt;em&gt;rust&lt;/em&gt; typed on a telephone.</source>
          <target state="translated">&lt;code&gt;TcpListener&lt;/code&gt; 를 사용 하면 주소 &lt;code&gt;127.0.0.1:7878&lt;/code&gt; 에서 TCP 연결을 수신 할 수 있습니다 . 주소에서 콜론 앞의 섹션은 컴퓨터를 나타내는 IP 주소 (모든 컴퓨터에서 동일하며 작성자의 컴퓨터를 구체적으로 나타내지 않음)이며 &lt;code&gt;7878&lt;/code&gt; 은 포트입니다. 두 가지 이유로이 포트를 선택했습니다. HTTP는 일반적으로이 포트에서 허용되며 7878은 전화기에 &lt;em&gt;녹이&lt;/em&gt; 슬게 입력됩니다.</target>
        </trans-unit>
        <trans-unit id="9d282af0a0db5a0f3935d90926c6551a24490d56" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;cargo&lt;/code&gt;, Rust&amp;rsquo;s package manager and build system</source>
          <target state="translated">Rust의 패키지 관리자 및 빌드 시스템 인 &lt;code&gt;cargo&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="063f2ebb8c76224924321e7e9857525474aed57a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;collect()&lt;/code&gt; to make a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">사용 &lt;code&gt;collect()&lt;/code&gt; a를하는 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="781d7dd79f196f5deffe456d6e4de88c8628e79c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;env::join_paths()&lt;/code&gt; with &lt;a href=&quot;fn.split_paths&quot;&gt;&lt;code&gt;env::split_paths()&lt;/code&gt;&lt;/a&gt; to append an item to the &lt;code&gt;PATH&lt;/code&gt; environment variable:</source>
          <target state="translated">사용 &lt;code&gt;env::join_paths()&lt;/code&gt; 와 &lt;a href=&quot;fn.split_paths&quot;&gt; &lt;code&gt;env::split_paths()&lt;/code&gt; &lt;/a&gt; 받는 항목을 추가하는 &lt;code&gt;PATH&lt;/code&gt; 의 환경 변수를 :</target>
        </trans-unit>
        <trans-unit id="efb72794ee8412b2ec8c4ed130b77aa3fe94a4cc" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;env::join_paths&lt;/code&gt; with &lt;a href=&quot;fn.split_paths&quot;&gt;&lt;code&gt;env::split_paths&lt;/code&gt;&lt;/a&gt; to append an item to the &lt;code&gt;PATH&lt;/code&gt; environment variable:</source>
          <target state="translated">사용 &lt;code&gt;env::join_paths&lt;/code&gt; 함께 &lt;a href=&quot;fn.split_paths&quot;&gt; &lt;code&gt;env::split_paths&lt;/code&gt; &lt;/a&gt; 받는 항목을 추가하려면 &lt;code&gt;PATH&lt;/code&gt; 의 환경 변수를 :</target>
        </trans-unit>
        <trans-unit id="883e296f0933a9796d7609478617eb9fc57e41d8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; as a &quot;do nothing&quot; base case in a conditional:</source>
          <target state="translated">조건부에서 &quot;아무것도하지 않는&quot;기본 케이스로 &lt;code&gt;identity&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="145643f8069cc90bb1d66393cde6c665263c5694" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to do nothing among other interesting functions:</source>
          <target state="translated">다른 흥미로운 기능들 중에서 아무것도하지 않기 위해 &lt;code&gt;identity&lt;/code&gt; 사용 하기 :</target>
        </trans-unit>
        <trans-unit id="f1235a5ac3f06cf39c5a154506b55894e72fe10a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to do nothing in a sequence of other, interesting, functions:</source>
          <target state="translated">&lt;code&gt;identity&lt;/code&gt; 를 사용하여 다른 흥미로운 기능 시퀀스에서 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0c92b7b9d3a5d2fd97452ae43966326ca17955c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to get a function that changes nothing in a conditional:</source>
          <target state="translated">조건부에서 아무것도 변경하지 않는 함수를 얻기 위해 &lt;code&gt;identity&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="8a03c63b02cfcec88b468a3f0a4f356859de8742" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to keep the &lt;code&gt;Some&lt;/code&gt; variants of an iterator of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">사용 &lt;code&gt;identity&lt;/code&gt; 유지하기 위해 &lt;code&gt;Some&lt;/code&gt; 의 반복자 변종 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b86b145b4aec4479f3e7888989e9c6f53ce3db7d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;if let&lt;/code&gt; means less typing, less indentation, and less boilerplate code. However, you lose the exhaustive checking that &lt;code&gt;match&lt;/code&gt; enforces. Choosing between &lt;code&gt;match&lt;/code&gt; and &lt;code&gt;if let&lt;/code&gt; depends on what you&amp;rsquo;re doing in your particular situation and whether gaining conciseness is an appropriate trade-off for losing exhaustive checking.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 을 사용 하면 타이핑이 적고 들여 쓰기가 적고 상용구 코드가 줄어 듭니다. 그러나 &lt;code&gt;match&lt;/code&gt; 하는 철저한 검사를 잃게됩니다 . &lt;code&gt;match&lt;/code&gt; 와 &lt;code&gt;if let&lt;/code&gt; 사이의 선택은 특정 상황에서 무엇을하고 있는지와 간결성을 얻는 것이 철저한 검사를 잃는 데 적절한 절충인지에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b98e766b3b912d79bb4b0c519c379c12d658619" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;match&lt;/code&gt; works well enough, but it can be a bit verbose and doesn&amp;rsquo;t always communicate intent well. The &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type has many helper methods defined on it to do various tasks. One of those methods, called &lt;code&gt;unwrap&lt;/code&gt;, is a shortcut method that is implemented just like the &lt;code&gt;match&lt;/code&gt; expression we wrote in Listing 9-4. If the &lt;code&gt;Result&lt;/code&gt; value is the &lt;code&gt;Ok&lt;/code&gt; variant, &lt;code&gt;unwrap&lt;/code&gt; will return the value inside the &lt;code&gt;Ok&lt;/code&gt;. If the &lt;code&gt;Result&lt;/code&gt; is the &lt;code&gt;Err&lt;/code&gt; variant, &lt;code&gt;unwrap&lt;/code&gt; will call the &lt;code&gt;panic!&lt;/code&gt; macro for us. Here is an example of &lt;code&gt;unwrap&lt;/code&gt; in action:</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 사용하면 충분하지만 조금 장황 할 수 있으며 항상 의도를 잘 전달하지는 않습니다. &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 형태는 다양한 작업을 수행하는 데에 정의 된 많은 헬퍼 메소드가 있습니다. &lt;code&gt;unwrap&lt;/code&gt; 이라는 메소드 중 하나는 Listing 9-4에서 작성한 &lt;code&gt;match&lt;/code&gt; 표현식 과 같이 구현되는 단축 메소드이다 . 경우 &lt;code&gt;Result&lt;/code&gt; 값이입니다 &lt;code&gt;Ok&lt;/code&gt; 변형, &lt;code&gt;unwrap&lt;/code&gt; 내부 값을 반환합니다 &lt;code&gt;Ok&lt;/code&gt; . 는 IF &lt;code&gt;Result&lt;/code&gt; 는 IS &lt;code&gt;Err&lt;/code&gt; 변형, &lt;code&gt;unwrap&lt;/code&gt; 부르는 것 &lt;code&gt;panic!&lt;/code&gt; 우리를 위해 매크로. 다음은 &lt;code&gt;unwrap&lt;/code&gt; 실제 예입니다 .</target>
        </trans-unit>
        <trans-unit id="716d3b2c36a0e8f26b1196bb5c8509c4d656cdaa" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;mul_add&lt;/code&gt; can be more performant than an unfused multiply-add if the target architecture has a dedicated &lt;code&gt;fma&lt;/code&gt; CPU instruction.</source>
          <target state="translated">대상 아키텍처에 전용 &lt;code&gt;fma&lt;/code&gt; CPU 명령어 가있는 경우 &lt;code&gt;mul_add&lt;/code&gt; 를 사용 하면 융합되지 않은 곱하기 추가보다 성능이 우수 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8c91e11b4f888f4c592a35e44ac17004a0fb755" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;println!&lt;/code&gt; directly:</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; 사용 ! 직접:</target>
        </trans-unit>
        <trans-unit id="4e19595061858aceb197932ab33548b4e2d9024e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;to_string&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;to_string&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="9355d5eaee5786ccc5834b09b61c0a558e231c8f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;unsafe {}&lt;/code&gt; blocks and &lt;code&gt;impl&lt;/code&gt;s</source>
          <target state="translated">사용 &lt;code&gt;unsafe {}&lt;/code&gt; 블록 및 &lt;code&gt;impl&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="ddd1e2fb0a495ca1deedb73f663b2b41b48287c3" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;unsafe&lt;/code&gt; to take one of the five actions (superpowers) just discussed isn&amp;rsquo;t wrong or even frowned upon. But it is trickier to get &lt;code&gt;unsafe&lt;/code&gt; code correct because the compiler can&amp;rsquo;t help uphold memory safety. When you have a reason to use &lt;code&gt;unsafe&lt;/code&gt; code, you can do so, and having the explicit &lt;code&gt;unsafe&lt;/code&gt; annotation makes it easier to track down the source of problems when they occur.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 것을 사용하여 방금 논의한 다섯 가지 행동 (초강대국) 중 하나를 취하는 것은 잘못되거나 눈살을 찌푸리는 일이 아닙니다. 그러나 컴파일러가 메모리 안전을 유지하는 데 도움이되지 않기 때문에 &lt;code&gt;unsafe&lt;/code&gt; 코드를 수정 하는 것이 더 까다 롭습니다 . &lt;code&gt;unsafe&lt;/code&gt; 코드 를 사용할 이유가있을 때 그렇게 할 수 있으며 명시적인 &lt;code&gt;unsafe&lt;/code&gt; 주석을 사용하면 문제 발생시 문제의 원인을 쉽게 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23e77887900c6717f9133b9abc150eed86948327" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;unsafe&lt;/code&gt; to take one of the four actions (superpowers) just discussed isn&amp;rsquo;t wrong or even frowned upon. But it is trickier to get &lt;code&gt;unsafe&lt;/code&gt; code correct because the compiler can&amp;rsquo;t help uphold memory safety. When you have a reason to use &lt;code&gt;unsafe&lt;/code&gt; code, you can do so, and having the explicit &lt;code&gt;unsafe&lt;/code&gt; annotation makes it easier to track down the source of problems if they occur.</source>
          <target state="translated">방금 논의한 네 가지 행동 (초강대국) 중 하나를 수행하기 위해 &lt;code&gt;unsafe&lt;/code&gt; 것을 사용하는 것은 잘못되거나 눈살을 찌푸 리지도 않습니다. 그러나 컴파일러가 메모리 안전을 유지하는 데 도움을 줄 수 없으므로 &lt;code&gt;unsafe&lt;/code&gt; 코드를 올바르게 작성 하는 것이 더 까다 롭습니다 . &lt;code&gt;unsafe&lt;/code&gt; 코드 를 사용해야하는 이유가 있을 경우 그렇게 할 수 있으며 명시적인 &lt;code&gt;unsafe&lt;/code&gt; 주석을 사용하면 문제의 원인을 쉽게 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="079ef6902b572fab1f5b45933254dfd23aa7b9b5" translate="yes" xml:space="preserve">
          <source>Using Closures that Capture Their Environment</source>
          <target state="translated">환경을 캡처하는 클로저 사용</target>
        </trans-unit>
        <trans-unit id="356483451b80563e823eec07c158f3c0e2a19756" translate="yes" xml:space="preserve">
          <source>Using External Packages</source>
          <target state="translated">외부 패키지 사용</target>
        </trans-unit>
        <trans-unit id="195ec6c54d68d4bc74c1c0e9e4aa71e8ed1d66dc" translate="yes" xml:space="preserve">
          <source>Using Message Passing to Transfer Data Between Threads</source>
          <target state="translated">메시지 전달을 사용하여 스레드간에 데이터 전송</target>
        </trans-unit>
        <trans-unit id="1f1119d00f411f28a788c634b094f7830af90354" translate="yes" xml:space="preserve">
          <source>Using Mutexes to Allow Access to Data from One Thread at a Time</source>
          <target state="translated">뮤텍스를 사용하여 한 번에 하나의 스레드에서 데이터에 액세스 할 수 있도록 허용</target>
        </trans-unit>
        <trans-unit id="0f71d9d6c5e4eb6b3d84f4f1645f9d37c7834e08" translate="yes" xml:space="preserve">
          <source>Using Nested Paths to Clean Up Large &lt;code id=&quot;using-nested-paths-to-clean-up-large-use-lists&quot;&gt;use&lt;/code&gt; Lists</source>
          <target state="translated">중첩 된 경로를 사용하여 대규모 &lt;code id=&quot;using-nested-paths-to-clean-up-large-use-lists&quot;&gt;use&lt;/code&gt; 목록 정리</target>
        </trans-unit>
        <trans-unit id="d061dfad64af5ced98da4099941d9962a4cf4ab6" translate="yes" xml:space="preserve">
          <source>Using Other &lt;code id=&quot;using-other-iterator-trait-methods&quot;&gt;Iterator&lt;/code&gt; Trait Methods</source>
          <target state="translated">다른 &lt;code id=&quot;using-other-iterator-trait-methods&quot;&gt;Iterator&lt;/code&gt; 특성 방법 사용</target>
        </trans-unit>
        <trans-unit id="90caab8414681ad380cd72175835d7d3a714a974" translate="yes" xml:space="preserve">
          <source>Using Our &lt;code id=&quot;using-our-counter-iterators-next-method&quot;&gt;Counter&lt;/code&gt; Iterator&amp;rsquo;s &lt;code&gt;next&lt;/code&gt; Method</source>
          <target state="translated">우리의 사용 &lt;code id=&quot;using-our-counter-iterators-next-method&quot;&gt;Counter&lt;/code&gt; 반복자의 &lt;code&gt;next&lt;/code&gt; 방법을</target>
        </trans-unit>
        <trans-unit id="4a36ca6063affef138895d5e70695435940c7941" translate="yes" xml:space="preserve">
          <source>Using Statics or Consts</source>
          <target state="translated">정적 또는 상수 사용</target>
        </trans-unit>
        <trans-unit id="1d80a86fe9446545a29df6fe583694b8305fad7f" translate="yes" xml:space="preserve">
          <source>Using Structs to Structure Related Data</source>
          <target state="translated">구조를 사용하여 관련 데이터 구조화</target>
        </trans-unit>
        <trans-unit id="1725c7720c6951cb5321da47bdec76e1efb5b498" translate="yes" xml:space="preserve">
          <source>Using Supertraits to Require One Trait&amp;rsquo;s Functionality Within Another Trait</source>
          <target state="translated">다른 특성 내에서 한 특성의 기능을 요구하기 위해 상위 특성 사용</target>
        </trans-unit>
        <trans-unit id="e5f7eb8898bb60910740832d2142728eab94b626" translate="yes" xml:space="preserve">
          <source>Using Threads to Run Code Simultaneously</source>
          <target state="translated">스레드를 사용하여 코드를 동시에 실행</target>
        </trans-unit>
        <trans-unit id="9c88360016895ec6069e43a4e277e7bdb51ba9ed" translate="yes" xml:space="preserve">
          <source>Using Trait Bounds to Conditionally Implement Methods</source>
          <target state="translated">특성 바인드를 사용하여 조건부로 메소드 구현</target>
        </trans-unit>
        <trans-unit id="b4544e80831327296977b0f0c1bed06cd890a1fd" translate="yes" xml:space="preserve">
          <source>Using Trait Objects That Allow for Values of Different Types</source>
          <target state="translated">다른 유형의 값을 허용하는 특성 객체 사용</target>
        </trans-unit>
        <trans-unit id="735958a37951062c949a84a063e5b1d398369b00" translate="yes" xml:space="preserve">
          <source>Using Tuple Structs without Named Fields to Create Different Types</source>
          <target state="translated">명명 된 필드없이 튜플 구조를 사용하여 다른 유형 만들기</target>
        </trans-unit>
        <trans-unit id="675231858eb84206141ae12e664714cc21d2c19b" translate="yes" xml:space="preserve">
          <source>Using a &lt;code id=&quot;using-a-boxt-to-store-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to Store Data on the Heap</source>
          <target state="translated">&lt;code id=&quot;using-a-boxt-to-store-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용 하여 힙에 데이터 저장</target>
        </trans-unit>
        <trans-unit id="f84a17c2b7b640800d3c95a6c6874936d40e4172" translate="yes" xml:space="preserve">
          <source>Using a &lt;code id=&quot;using-a-panic-backtrace&quot;&gt;panic!&lt;/code&gt; Backtrace</source>
          <target state="translated">사용 &lt;code id=&quot;using-a-panic-backtrace&quot;&gt;panic!&lt;/code&gt; 역 추적</target>
        </trans-unit>
        <trans-unit id="fa90ed41bcf90ab01a0c0386a65d7892a205380d" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;Fn&lt;/code&gt; parameter</source>
          <target state="translated">사용 &lt;code&gt;Fn&lt;/code&gt; 매개 변수를</target>
        </trans-unit>
        <trans-unit id="c233f257ce2f61e1743d09ba4202b368e77eac25" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;FnMut&lt;/code&gt; parameter</source>
          <target state="translated">사용 &lt;code&gt;FnMut&lt;/code&gt; 의 매개 변수를</target>
        </trans-unit>
        <trans-unit id="c47fce11968d69df2be1beb510ac309f7cc7fe1c" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;FnOnce&lt;/code&gt; parameter</source>
          <target state="translated">사용 &lt;code&gt;FnOnce&lt;/code&gt; 의 매개 변수를</target>
        </trans-unit>
        <trans-unit id="eaa2ddbdb2af4f1c7b600386f3ab5d07fb639266" translate="yes" xml:space="preserve">
          <source>Using a Crate to Get More Functionality</source>
          <target state="translated">상자를 사용하여 더 많은 기능 얻기</target>
        </trans-unit>
        <trans-unit id="5490ba3cbb37583be424e7381702b1ad23cc8d1f" translate="yes" xml:space="preserve">
          <source>Using a busy-wait spin-loop with &lt;code&gt;spin_loop&lt;/code&gt; is ideally used in situations where a contended lock is held by another thread executed on a different CPU and where the waiting times are relatively small. Because entering busy-wait spin-loop does not trigger the system's scheduler, no overhead for switching threads occurs. However, if the thread holding the contended lock is running on the same CPU, the spin-loop is likely to occupy an entire CPU slice before switching to the thread that holds the lock. If the contending lock is held by a thread on the same CPU or if the waiting times for acquiring the lock are longer, it is often better to use &lt;a href=&quot;../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 CPU에서 실행되는 다른 스레드에 의해 잠금이 유지되고 대기 시간이 비교적 &lt;code&gt;spin_loop&lt;/code&gt; 상황에서 spin_loop 과 함께 사용 중 대기 스핀 루프를 사용하는 것이 이상적입니다. busy-wait spin-loop를 입력해도 시스템 스케줄러가 트리거되지 않으므로 스레드 전환에 대한 오버 헤드가 발생하지 않습니다. 그러나 Content Lock을 보유한 스레드가 동일한 CPU에서 실행중인 경우, 잠금 루프를 보유한 스레드로 전환하기 전에 스핀 루프가 전체 CPU 슬라이스를 차지할 수 있습니다. 경합 잠금이 동일한 CPU의 스레드에 의해 유지되거나 잠금 획득 대기 시간이 더 길면 &lt;a href=&quot;../thread/fn.yield_now&quot;&gt; &lt;code&gt;std::thread::yield_now&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4c1ce34ae6a3ca80d5e3bf4a0b0c41abaf191eae" translate="yes" xml:space="preserve">
          <source>Using a busy-wait spin-loop with &lt;code&gt;spin_loop_hint&lt;/code&gt; is ideally used in situations where a contended lock is held by another thread executed on a different CPU and where the waiting times are relatively small. Because entering busy-wait spin-loop does not trigger the system's scheduler, no overhead for switching threads occurs. However, if the thread holding the contended lock is running on the same CPU, the spin-loop is likely to occupy an entire CPU slice before switching to the thread that holds the lock. If the contending lock is held by a thread on the same CPU or if the waiting times for acquiring the lock are longer, it is often better to use &lt;a href=&quot;../../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;spin_loop_hint&lt;/code&gt; 와 함께 사용 중 대기 스핀 루프를 사용하면 다른 CPU에서 실행되는 다른 스레드가 컨 텐션 된 잠금을 유지하고 대기 시간이 비교적 짧은 경우 에 이상적으로 사용됩니다. busy-wait spin-loop를 입력해도 시스템 스케줄러가 트리거되지 않으므로 스레드 전환에 대한 오버 헤드가 발생하지 않습니다. 그러나 Content Lock을 보유한 스레드가 동일한 CPU에서 실행중인 경우, 잠금 루프를 보유한 스레드로 전환하기 전에 스핀 루프가 전체 CPU 슬라이스를 차지할 수 있습니다. 경합 잠금이 동일한 CPU의 스레드에 의해 유지되거나 잠금 획득 대기 시간이 더 길면 &lt;a href=&quot;../../thread/fn.yield_now&quot;&gt; &lt;code&gt;std::thread::yield_now&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3b1ac01f9a3840dc6d78887aac134760ed5ceafe" translate="yes" xml:space="preserve">
          <source>Using a hash map and vectors, create a text interface to allow a user to add employee names to a department in a company. For example, &amp;ldquo;Add Sally to Engineering&amp;rdquo; or &amp;ldquo;Add Amir to Sales.&amp;rdquo; Then let the user retrieve a list of all people in a department or all people in the company by department, sorted alphabetically.</source>
          <target state="translated">해시 맵과 벡터를 사용하여 사용자가 회사의 부서에 직원 이름을 추가 할 수있는 텍스트 인터페이스를 작성하십시오. 예를 들어 &quot;엔지니어링에 Sally 추가&quot;또는 &quot;판매에 Amir 추가&quot;가 있습니다. 그런 다음 사용자가 부서의 모든 사람 또는 회사의 모든 사람들의 목록을 알파벳순으로 검색하도록합니다.</target>
        </trans-unit>
        <trans-unit id="09dacd7c78dbd0bf44dabf88b33b52973a393ac8" translate="yes" xml:space="preserve">
          <source>Using a primitive representation in addition to &lt;code&gt;repr(C)&lt;/code&gt; can change the size of an enum from the &lt;code&gt;repr(C)&lt;/code&gt; form:</source>
          <target state="translated">&lt;code&gt;repr(C)&lt;/code&gt; 외에 기본 표현을 사용 하면 &lt;code&gt;repr(C)&lt;/code&gt; 형식 에서 열거 형의 크기를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4c37907d281b1198f03324a18111844e539d53d" translate="yes" xml:space="preserve">
          <source>Using a search key that doesn't work with the Borrow trait</source>
          <target state="translated">대출 특성과 작동하지 않는 검색 키 사용</target>
        </trans-unit>
        <trans-unit id="cd14ecb207f28002c37a4e53dc6c1cebfa5f2ee9" translate="yes" xml:space="preserve">
          <source>Using a semicolon after &lt;code&gt;mod front_of_house&lt;/code&gt; rather than using a block tells Rust to load the contents of the module from another file with the same name as the module. To continue with our example and extract the &lt;code&gt;hosting&lt;/code&gt; module to its own file as well, we change &lt;em&gt;src/front_of_house.rs&lt;/em&gt; to contain only the declaration of the &lt;code&gt;hosting&lt;/code&gt; module:</source>
          <target state="translated">블록을 사용하지 않고 &lt;code&gt;mod front_of_house&lt;/code&gt; 뒤에 세미콜론을 사용하면 Rust는 모듈과 동일한 이름을 가진 다른 파일에서 모듈의 내용을로드하도록합니다. 우리의 예를 계속하고 추출하려면 &lt;code&gt;hosting&lt;/code&gt; 뿐만 아니라 자신의 파일에 모듈을, 우리는 변화 &lt;em&gt;SRC / front_of_house.rs을&lt;/em&gt; 의 단지 선언을 포함 &lt;code&gt;hosting&lt;/code&gt; 모듈 :</target>
        </trans-unit>
        <trans-unit id="fe93078130b3109ad5108e782dba78cf01903057" translate="yes" xml:space="preserve">
          <source>Using a tuple of &lt;code&gt;Bound&lt;/code&gt;s as an argument to &lt;a href=&quot;../collections/btree_map/struct.btreemap#method.range&quot;&gt;&lt;code&gt;BTreeMap::range&lt;/code&gt;&lt;/a&gt;. Note that in most cases, it's better to use range syntax (&lt;code&gt;1..5&lt;/code&gt;) instead.</source>
          <target state="translated">&lt;code&gt;Bound&lt;/code&gt; 튜플 을 &lt;a href=&quot;../collections/btree_map/struct.btreemap#method.range&quot;&gt; &lt;code&gt;BTreeMap::range&lt;/code&gt; &lt;/a&gt; 의 인수로 사용 합니다 . 대부분의 경우 범위 구문 ( &lt;code&gt;1..5&lt;/code&gt; )을 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="015c01b29f1c8ebb6c4c8943a2dc3adcbae06181" translate="yes" xml:space="preserve">
          <source>Using an Enum to Store Multiple Types</source>
          <target state="translated">열거 형을 사용하여 여러 유형 저장</target>
        </trans-unit>
        <trans-unit id="b5882a2dc057a0d8d156ec2e30b99dd996e5bdcc" translate="yes" xml:space="preserve">
          <source>Using built-in default values:</source>
          <target state="translated">내장 기본값 사용 :</target>
        </trans-unit>
        <trans-unit id="f3dacd0d875f3e763ce98391694ffe59eeffec43" translate="yes" xml:space="preserve">
          <source>Using custom comparison logic without newtype wrappers</source>
          <target state="translated">뉴 타입 래퍼없이 사용자 정의 비교 로직 사용</target>
        </trans-unit>
        <trans-unit id="a4db67f6f9b0784800ae988e7704553e6de06b09" translate="yes" xml:space="preserve">
          <source>Using default values:</source>
          <target state="translated">기본값 사용 :</target>
        </trans-unit>
        <trans-unit id="8ec600b0ec907749b0fdd372e79b0c70b7b0dce0" translate="yes" xml:space="preserve">
          <source>Using enums has even more advantages. Thinking more about our IP address type, at the moment we don&amp;rsquo;t have a way to store the actual IP address &lt;em&gt;data&lt;/em&gt;; we only know what &lt;em&gt;kind&lt;/em&gt; it is. Given that you just learned about structs in Chapter 5, you might tackle this problem as shown in Listing 6-1.</source>
          <target state="translated">열거 형을 사용하면 더 많은 이점이 있습니다. 실제 IP 주소 &lt;em&gt;데이터&lt;/em&gt; 를 저장할 수있는 방법은 없습니다 . 우리는 그것이 어떤 &lt;em&gt;종류&lt;/em&gt; 인지 알고 있습니다. 5 장의 구조체에 대해 방금 배웠다면 Listing 6-1에 표시된 것처럼이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e92abb62f29a9ab743c0868201fc7c6f7cc104c" translate="yes" xml:space="preserve">
          <source>Using explicit synchronization:</source>
          <target state="translated">명시 적 동기화 사용 :</target>
        </trans-unit>
        <trans-unit id="26140a4b00b6db68bc5c08aa7b59f4de9a496d44" translate="yes" xml:space="preserve">
          <source>Using implicit synchronization:</source>
          <target state="translated">암시 적 동기화 사용 :</target>
        </trans-unit>
        <trans-unit id="0964494ac4fd47f86d6e1abd134d8f88a80450c7" translate="yes" xml:space="preserve">
          <source>Using mutation and going finite:</source>
          <target state="translated">돌연변이를 사용하고 유한하기 :</target>
        </trans-unit>
        <trans-unit id="c5cfc67f6bee08fd41a46b1d08f1ad9861c6e196" translate="yes" xml:space="preserve">
          <source>Using path qualifiers like &lt;a href=&quot;keyword.crate&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;keyword.super&quot;&gt;&lt;code&gt;super&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keyword.self&quot;&gt;&lt;code&gt;self&lt;/code&gt;&lt;/a&gt; is supported: &lt;code&gt;use crate::a::b;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;keyword.crate&quot;&gt; &lt;code&gt;crate&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;keyword.super&quot;&gt; &lt;code&gt;super&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;keyword.self&quot;&gt; &lt;code&gt;self&lt;/code&gt; &lt;/a&gt; 와 같은 경로 한정자를 사용하는 것이 지원됩니다. &lt;code&gt;use crate::a::b;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff5b3892671b9cc1bcba84f83ea8ba99412282b3" translate="yes" xml:space="preserve">
          <source>Using struct update syntax, we can achieve the same effect with less code, as shown in Listing 5-7. The syntax &lt;code&gt;..&lt;/code&gt; specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.</source>
          <target state="translated">구조체 업데이트 구문을 사용하면 코드 5-7과 같이 적은 코드로 동일한 효과를 얻을 수 있습니다. &lt;code&gt;..&lt;/code&gt; 구문 은 명시 적으로 설정되지 않은 나머지 필드가 지정된 인스턴스의 필드와 동일한 값을 가져야 함을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="149131436ae6fcc58b9d3b44704c0a4f62b58b80" translate="yes" xml:space="preserve">
          <source>Using the 'turbofish' instead of annotating &lt;code&gt;doubled&lt;/code&gt;:</source>
          <target state="translated">대신 주석의 'turbofish'사용 &lt;code&gt;doubled&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1fee5723d61f0a87e52c62c70350b33d4a2c1211" translate="yes" xml:space="preserve">
          <source>Using the 'turbofish' instead of annotating &lt;code&gt;four&lt;/code&gt;:</source>
          <target state="translated">대신 주석의 'turbofish'사용 &lt;code&gt;four&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b8dca1dfea48258776a757d0e7fdd52e32ddc6d8" translate="yes" xml:space="preserve">
          <source>Using the &lt;code id=&quot;using-the-search-function-in-the-run-function&quot;&gt;search&lt;/code&gt; Function in the &lt;code&gt;run&lt;/code&gt; Function</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 기능 에서 &lt;code id=&quot;using-the-search-function-in-the-run-function&quot;&gt;search&lt;/code&gt; 기능 사용</target>
        </trans-unit>
        <trans-unit id="73cb7c6eceba8574fdab292dc3c5b0a2f2322727" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;List&lt;/code&gt; type to store the list &lt;code&gt;1, 2, 3&lt;/code&gt; would look like the code in Listing 15-3:</source>
          <target state="translated">은 Using &lt;code&gt;List&lt;/code&gt; 목록 저장 유형을 &lt;code&gt;1, 2, 3&lt;/code&gt; 목록 15-3의 코드처럼 보일 것이다 :</target>
        </trans-unit>
        <trans-unit id="707e73f8481ac39cdfa5e294240c14e577bab80b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;ref&lt;/code&gt; keyword, the value is only borrowed, not moved, making it available for use after the &lt;a href=&quot;keyword.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 키워드를 사용하면 값이 차용되고 이동되지 않으므로 &lt;a href=&quot;keyword.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; 문 다음 에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2545ef2f465dd4b2bb1fca4f7b62b633439903e" translate="yes" xml:space="preserve">
          <source>Using the Field Init Shorthand when Variables and Fields Have the Same Name</source>
          <target state="translated">변수와 필드의 이름이 같은 경우 필드 초기화 단축 사용</target>
        </trans-unit>
        <trans-unit id="527c6fc37f2c7ff511bb334d8bc01dfd4d796198" translate="yes" xml:space="preserve">
          <source>Using the Newtype Pattern for Type Safety and Abstraction</source>
          <target state="translated">타입 안전성 및 추상화를위한 새로운 타입의 패턴 사용</target>
        </trans-unit>
        <trans-unit id="0445dab15f95bbaf439f12315a2f6c2606b64d6c" translate="yes" xml:space="preserve">
          <source>Using the Newtype Pattern to Implement External Traits on External Types</source>
          <target state="translated">Newtype 패턴을 사용하여 외부 유형에 대한 외부 특성 구현</target>
        </trans-unit>
        <trans-unit id="6efe08dd70627a6ae791a8f3c7e219c91abdce73" translate="yes" xml:space="preserve">
          <source>Using the Returned Iterator Directly</source>
          <target state="translated">리턴 된 반복자를 직접 사용</target>
        </trans-unit>
        <trans-unit id="bfe1a641af30e378f1440126b6876e787e3aeb21" translate="yes" xml:space="preserve">
          <source>Using the state pattern means when the business requirements of the program change, we won&amp;rsquo;t need to change the code of the value holding the state or the code that uses the value. We&amp;rsquo;ll only need to update the code inside one of the state objects to change its rules or perhaps add more state objects. Let&amp;rsquo;s look at an example of the state design pattern and how to use it in Rust.</source>
          <target state="translated">상태 패턴을 사용한다는 것은 프로그램의 비즈니스 요구 사항이 변경 될 때 상태를 유지하는 값의 코드 또는 값을 사용하는 코드를 변경할 필요가 없음을 의미합니다. 규칙을 변경하거나 상태 개체를 더 추가하기 위해 상태 개체 중 하나의 코드 만 업데이트하면됩니다. 상태 디자인 패턴의 예와 Rust에서 사용하는 방법을 보자.</target>
        </trans-unit>
        <trans-unit id="f27958ea70e4427546613b6470c7b4a627139188" translate="yes" xml:space="preserve">
          <source>Using this declaration, it must be called with at least one argument, so simply calling &lt;code&gt;printf()&lt;/code&gt; is invalid. But the following uses are allowed:</source>
          <target state="translated">이 선언을 사용하면 적어도 하나의 인수로 호출해야하므로 &lt;code&gt;printf()&lt;/code&gt; 호출 이 유효하지 않습니다. 그러나 다음과 같은 용도로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3febf8421408faebfe197da05a42aac2ff47af45" translate="yes" xml:space="preserve">
          <source>Using this definition, Rust is object oriented: structs and enums have data, and &lt;code&gt;impl&lt;/code&gt; blocks provide methods on structs and enums. Even though structs and enums with methods aren&amp;rsquo;t &lt;em&gt;called&lt;/em&gt; objects, they provide the same functionality, according to the Gang of Four&amp;rsquo;s definition of objects.</source>
          <target state="translated">이 정의를 사용하여 Rust는 객체 지향입니다. 구조체와 열거 형에는 데이터가 있고 &lt;code&gt;impl&lt;/code&gt; 블록은 구조체와 열거 형에 대한 메서드를 제공합니다. 메소드를 가진 구조체와 열거 형을 객체 &lt;em&gt;라고 부르지&lt;/em&gt; 는 않지만 Gang of Four의 객체 정의에 따르면 동일한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4bd35f75969eee3d765cd1e9dcbd0cf13c21dc8a" translate="yes" xml:space="preserve">
          <source>Using this function is generally faster than using &lt;code&gt;powf&lt;/code&gt;</source>
          <target state="translated">이 기능을 사용하면 일반적으로 &lt;code&gt;powf&lt;/code&gt; 를 사용하는 것보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="c548fba9d029d6e16cb5aeebbb487347aada0fef" translate="yes" xml:space="preserve">
          <source>Using this macro is often a bad idea, because if the file is parsed as an expression, it is going to be placed in the surrounding code unhygienically. This could result in variables or functions being different from what the file expected if there are variables or functions that have the same name in the current file.</source>
          <target state="translated">파일을 표현식으로 구문 분석하면 주변 코드에 비위생적으로 배치되기 때문에이 매크로를 사용하는 것은 좋지 않은 생각입니다. 이로 인해 현재 파일에 이름이 같은 변수 나 함수가있는 경우 변수 나 함수가 파일에서 예상 한 것과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7c45efccaaa01e2feb082b19ddba5a32324e6fa" translate="yes" xml:space="preserve">
          <source>Using this method is equivalent to the following code:</source>
          <target state="translated">이 방법을 사용하는 것은 다음 코드와 같습니다.</target>
        </trans-unit>
        <trans-unit id="15e11a1b79c37f9d667f56c8b714852cef36b238" translate="yes" xml:space="preserve">
          <source>Using too many &lt;code&gt;else if&lt;/code&gt; expressions can clutter your code, so if you have more than one, you might want to refactor your code. Chapter 6 describes a powerful Rust branching construct called &lt;code&gt;match&lt;/code&gt; for these cases.</source>
          <target state="translated">식이 코드를 복잡하게 만들 수있는 &lt;code&gt;else if&lt;/code&gt; 너무 많은 수를 사용 하므로 둘 이상인 경우 코드를 리팩토링해야 할 수 있습니다. 6 장 에서는 이러한 경우에 &lt;code&gt;match&lt;/code&gt; 하는 강력한 녹 분기 구성을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="e52bd27c5d26825ad08651412fd660a16f020f77" translate="yes" xml:space="preserve">
          <source>Using too many trait bounds has its downsides. Each generic has its own trait bounds, so functions with multiple generic type parameters can contain lots of trait bound information between the function&amp;rsquo;s name and its parameter list, making the function signature hard to read. For this reason, Rust has alternate syntax for specifying trait bounds inside a &lt;code&gt;where&lt;/code&gt; clause after the function signature. So instead of writing this:</source>
          <target state="translated">너무 많은 특성 범위를 사용하면 단점이 있습니다. 각 제네릭에는 고유 한 특성 경계가 있으므로 여러 제네릭 형식 매개 변수가있는 함수에는 함수 이름과 매개 변수 목록 사이에 많은 특성 바인딩 정보가 포함될 수 있으므로 함수 서명을 읽기가 어렵습니다. 이러한 이유로 Rust에는 함수 시그니처 뒤에 &lt;code&gt;where&lt;/code&gt; 절 내에 특성 범위를 지정하는 대체 구문 이 있습니다. 따라서 이것을 쓰는 대신 :</target>
        </trans-unit>
        <trans-unit id="e8270120e8e5872b95f691e94134c3c38cbe49b0" translate="yes" xml:space="preserve">
          <source>Using traits and lifetimes where appropriate (&lt;a href=&quot;ch10-00-generics&quot;&gt;Chapter 10&lt;/a&gt;)</source>
          <target state="translated">적절한 곳에서 특성과 생애를 사용함 ( &lt;a href=&quot;ch10-00-generics&quot;&gt;10 장&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="1c8fe76861637e35d40bd85f3825d619bc84eadf" translate="yes" xml:space="preserve">
          <source>Using unsafe functionality is potentially dangerous and disallowed by safety checks. Examples:</source>
          <target state="translated">안전하지 않은 기능을 사용하는 것은 잠재적으로 위험하며 안전 점검으로 인해 허용되지 않습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="f903dfb928504d5e71a1ab430366f1a7eae7e14e" translate="yes" xml:space="preserve">
          <source>Using vectors and strings (collections, &lt;a href=&quot;ch08-00-common-collections&quot;&gt;Chapter 8&lt;/a&gt;)</source>
          <target state="translated">벡터와 문자열 사용 (컬렉션, &lt;a href=&quot;ch08-00-common-collections&quot;&gt;8 장&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="d6513e8f7510d42121946e2407ba6c2011fc2c1c" translate="yes" xml:space="preserve">
          <source>Usually a &lt;code&gt;use&lt;/code&gt; keyword is used to shorten the path required to refer to a module item. The keyword may appear in modules, blocks and even functions, usually at the top.</source>
          <target state="translated">일반적으로 &lt;code&gt;use&lt;/code&gt; 키워드는 모듈 항목을 참조하는 데 필요한 경로를 줄이는 데 사용됩니다. 키워드는 일반적으로 상단에 모듈, 블록 및 심지어 기능에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d83a4fba159bee344e91cbe040d6123421c523d3" translate="yes" xml:space="preserve">
          <source>Usually you wouldn't literally use &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; from Rust, but C APIs hand out a lot of pointers generally, so are a common source of raw pointers in Rust.</source>
          <target state="translated">보통은 그대로 사용하지 않을 &lt;code&gt;malloc&lt;/code&gt; 와 &lt;code&gt;free&lt;/code&gt; 그래서 녹 원시 포인터의 공통 소스입니다, 일반적으로 포인터를 많이에서 녹에서,하지만 C API에 손을.</target>
        </trans-unit>
        <trans-unit id="906d4775d8872c7dc79527063674165dda2ccbc0" translate="yes" xml:space="preserve">
          <source>Usually, generic parameters get &lt;em&gt;monomorphized&lt;/em&gt;. For example, if I have</source>
          <target state="translated">일반적으로 일반 매개 변수는 &lt;em&gt;단일화&lt;/em&gt; 됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="d259bb65f469f691c60fbc1cce6f48ae71721980" translate="yes" xml:space="preserve">
          <source>Usually, iterators iterate from left to right. After using &lt;code&gt;rev()&lt;/code&gt;, an iterator will instead iterate from right to left.</source>
          <target state="translated">일반적으로 반복자는 왼쪽에서 오른쪽으로 반복됩니다. &lt;code&gt;rev()&lt;/code&gt; 사용한 후 반복자는 오른쪽에서 왼쪽으로 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="71c8b88aacf28ce47b0a58b2d2bc8a3fb05b911b" translate="yes" xml:space="preserve">
          <source>Utf8Error</source>
          <target state="translated">Utf8Error</target>
        </trans-unit>
        <trans-unit id="0dc56eae851492c66ecabf78d1bbaf00296acfbe" translate="yes" xml:space="preserve">
          <source>Utf8Error::borrow</source>
          <target state="translated">Utf8Error::borrow</target>
        </trans-unit>
        <trans-unit id="62c9947a079483bdf0d15d01617213826dc02f38" translate="yes" xml:space="preserve">
          <source>Utf8Error::borrow_mut</source>
          <target state="translated">Utf8Error::borrow_mut</target>
        </trans-unit>
        <trans-unit id="3f5e10da6a480e49a740c45c14fd97e4e299d73d" translate="yes" xml:space="preserve">
          <source>Utf8Error::cause</source>
          <target state="translated">Utf8Error::cause</target>
        </trans-unit>
        <trans-unit id="aba276798126f3d9e88abbf114717adc671724b0" translate="yes" xml:space="preserve">
          <source>Utf8Error::clone</source>
          <target state="translated">Utf8Error::clone</target>
        </trans-unit>
        <trans-unit id="d9f741fd3eb062e41262e053f0eb1a689e8b68c8" translate="yes" xml:space="preserve">
          <source>Utf8Error::clone_from</source>
          <target state="translated">Utf8Error::clone_from</target>
        </trans-unit>
        <trans-unit id="6fb618053c3a87e8372bf0b005ef3aee33a2be29" translate="yes" xml:space="preserve">
          <source>Utf8Error::clone_into</source>
          <target state="translated">Utf8Error::clone_into</target>
        </trans-unit>
        <trans-unit id="5eb848f299ba96b5c68a3de5bf02961b034fb439" translate="yes" xml:space="preserve">
          <source>Utf8Error::description</source>
          <target state="translated">Utf8Error::description</target>
        </trans-unit>
        <trans-unit id="1e357eccf69d01f74bf39edbfab63655804a87a8" translate="yes" xml:space="preserve">
          <source>Utf8Error::eq</source>
          <target state="translated">Utf8Error::eq</target>
        </trans-unit>
        <trans-unit id="88f730d875142fa4beddb68ae32ca749e55c5da0" translate="yes" xml:space="preserve">
          <source>Utf8Error::error_len</source>
          <target state="translated">Utf8Error::error_len</target>
        </trans-unit>
        <trans-unit id="81707f4d43116cddc3b6180c7d1812770aa6aabd" translate="yes" xml:space="preserve">
          <source>Utf8Error::fmt</source>
          <target state="translated">Utf8Error::fmt</target>
        </trans-unit>
        <trans-unit id="80d9f3c5cc9b436bfc54741853eb348edcd31923" translate="yes" xml:space="preserve">
          <source>Utf8Error::from</source>
          <target state="translated">Utf8Error::from</target>
        </trans-unit>
        <trans-unit id="186ae2f6ff2c38ceed80692f48587dd9073b281b" translate="yes" xml:space="preserve">
          <source>Utf8Error::into</source>
          <target state="translated">Utf8Error::into</target>
        </trans-unit>
        <trans-unit id="da5d217600f498b06be2479022d36a4a5c15449b" translate="yes" xml:space="preserve">
          <source>Utf8Error::ne</source>
          <target state="translated">Utf8Error::ne</target>
        </trans-unit>
        <trans-unit id="65ff32fff52c3afe8fd1470fd4590b2fae222e96" translate="yes" xml:space="preserve">
          <source>Utf8Error::source</source>
          <target state="translated">Utf8Error::source</target>
        </trans-unit>
        <trans-unit id="d542954047d8755ad1a4e9a853bcf03561cdf1c9" translate="yes" xml:space="preserve">
          <source>Utf8Error::to_owned</source>
          <target state="translated">Utf8Error::to_owned</target>
        </trans-unit>
        <trans-unit id="ef5e78b58ef441d19d975802cc905ce882b752c7" translate="yes" xml:space="preserve">
          <source>Utf8Error::to_string</source>
          <target state="translated">Utf8Error::to_string</target>
        </trans-unit>
        <trans-unit id="eb1790431a34016d236cceca893cabedf79794fa" translate="yes" xml:space="preserve">
          <source>Utf8Error::try_from</source>
          <target state="translated">Utf8Error::try_from</target>
        </trans-unit>
        <trans-unit id="d78057a09376f581ad70dcf23d55b916b4ec76d6" translate="yes" xml:space="preserve">
          <source>Utf8Error::try_into</source>
          <target state="translated">Utf8Error::try_into</target>
        </trans-unit>
        <trans-unit id="77455bd6cede93b6937284b56ca0ee7128f3fcd5" translate="yes" xml:space="preserve">
          <source>Utf8Error::type_id</source>
          <target state="translated">Utf8Error::type_id</target>
        </trans-unit>
        <trans-unit id="061f930ae2881081028ec6f4738788ea0386348a" translate="yes" xml:space="preserve">
          <source>Utf8Error::valid_up_to</source>
          <target state="translated">Utf8Error::valid_up_to</target>
        </trans-unit>
        <trans-unit id="098996f33abfeafe0fd0a1060966a3bd981c2d4c" translate="yes" xml:space="preserve">
          <source>Utilities for formatting and printing &lt;code&gt;String&lt;/code&gt;s.</source>
          <target state="translated">서식 및 인쇄 유틸리티 &lt;code&gt;String&lt;/code&gt; 들.</target>
        </trans-unit>
        <trans-unit id="bbf05f92621e129ba6a9d6d71f520f94619321a3" translate="yes" xml:space="preserve">
          <source>Utilities related to FFI bindings.</source>
          <target state="translated">FFI 바인딩과 관련된 유틸리티.</target>
        </trans-unit>
        <trans-unit id="2cfce7b7e1bbf22d999dd679513efd8dd1774d5b" translate="yes" xml:space="preserve">
          <source>Utility trait implemented only on arrays of fixed size</source>
          <target state="translated">고정 된 크기의 배열에서만 구현되는 유틸리티 특성</target>
        </trans-unit>
        <trans-unit id="f4dc02e287a9f4de99799a5c31108f51723830a7" translate="yes" xml:space="preserve">
          <source>VXWorks</source>
          <target state="translated">VXWorks</target>
        </trans-unit>
        <trans-unit id="2a62ae9e6e10d5b4d844ad431e3d12dd6181892a" translate="yes" xml:space="preserve">
          <source>VaList</source>
          <target state="translated">VaList</target>
        </trans-unit>
        <trans-unit id="d3dc417a5e809aff4e928e1c2ccc9e1476eea745" translate="yes" xml:space="preserve">
          <source>VaList::arg</source>
          <target state="translated">VaList::arg</target>
        </trans-unit>
        <trans-unit id="e56bcc6610b1a8196319373f5b202bf4d9783931" translate="yes" xml:space="preserve">
          <source>VaList::as_va_list</source>
          <target state="translated">VaList::as_va_list</target>
        </trans-unit>
        <trans-unit id="93ccd0479992f30997a13f7a0291305d4a7bcf8f" translate="yes" xml:space="preserve">
          <source>VaList::borrow</source>
          <target state="translated">VaList::borrow</target>
        </trans-unit>
        <trans-unit id="14c647375c9b8191c6015d7e9763130b93ea3cb0" translate="yes" xml:space="preserve">
          <source>VaList::borrow_mut</source>
          <target state="translated">VaList::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c8adb5d15703c32cb6620339a1ad3a830f1ad937" translate="yes" xml:space="preserve">
          <source>VaList::deref</source>
          <target state="translated">VaList::deref</target>
        </trans-unit>
        <trans-unit id="ef4f8c0aefca94cf0351ab804dcb1192072b3317" translate="yes" xml:space="preserve">
          <source>VaList::deref_mut</source>
          <target state="translated">VaList::deref_mut</target>
        </trans-unit>
        <trans-unit id="4df0a82f8196ee6c8e34acaf7e521f5043ecc3f2" translate="yes" xml:space="preserve">
          <source>VaList::fmt</source>
          <target state="translated">VaList::fmt</target>
        </trans-unit>
        <trans-unit id="03cb0ba45ef46a478c6e89bd3b44e1281a4d5eb6" translate="yes" xml:space="preserve">
          <source>VaList::from</source>
          <target state="translated">VaList::from</target>
        </trans-unit>
        <trans-unit id="2b7cbe3710d07592cd359bf917b0387f4e9e9c5d" translate="yes" xml:space="preserve">
          <source>VaList::into</source>
          <target state="translated">VaList::into</target>
        </trans-unit>
        <trans-unit id="006354eed9f82fbe26fc29d15037b46b80c2b68d" translate="yes" xml:space="preserve">
          <source>VaList::try_from</source>
          <target state="translated">VaList::try_from</target>
        </trans-unit>
        <trans-unit id="cb8a2fefa105254fc69713249a582cf152da5fab" translate="yes" xml:space="preserve">
          <source>VaList::try_into</source>
          <target state="translated">VaList::try_into</target>
        </trans-unit>
        <trans-unit id="00466fb65a3743839a76ad49fc45873af21ac5b5" translate="yes" xml:space="preserve">
          <source>VaList::type_id</source>
          <target state="translated">VaList::type_id</target>
        </trans-unit>
        <trans-unit id="c8012d496381feb2e9a104eb4daca8ce56213794" translate="yes" xml:space="preserve">
          <source>VaList::with_copy</source>
          <target state="translated">VaList::with_copy</target>
        </trans-unit>
        <trans-unit id="cda940b5210ef6c9c3a6f85409e7dfeabc36a58a" translate="yes" xml:space="preserve">
          <source>VaListImpl</source>
          <target state="translated">VaListImpl</target>
        </trans-unit>
        <trans-unit id="3ca16b32106de1b77aafe6c23653b3844b349ae2" translate="yes" xml:space="preserve">
          <source>VaListImpl::arg</source>
          <target state="translated">VaListImpl::arg</target>
        </trans-unit>
        <trans-unit id="f4173f47c545e4746400db7076f692fc8d564b6d" translate="yes" xml:space="preserve">
          <source>VaListImpl::as_va_list</source>
          <target state="translated">VaListImpl::as_va_list</target>
        </trans-unit>
        <trans-unit id="d4f4feeb2f49c83d41fa723579047ba246044ff7" translate="yes" xml:space="preserve">
          <source>VaListImpl::borrow</source>
          <target state="translated">VaListImpl::borrow</target>
        </trans-unit>
        <trans-unit id="12efac9fbc832f37c148aabeed63349a1f5126dd" translate="yes" xml:space="preserve">
          <source>VaListImpl::borrow_mut</source>
          <target state="translated">VaListImpl::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c3f6404a6c3b18f2e79cb5750c66a38cba6e8a6c" translate="yes" xml:space="preserve">
          <source>VaListImpl::clone</source>
          <target state="translated">VaListImpl::clone</target>
        </trans-unit>
        <trans-unit id="c95d8d0d76cdd92d3789595b002435cb8b173ba3" translate="yes" xml:space="preserve">
          <source>VaListImpl::clone_from</source>
          <target state="translated">VaListImpl::clone_from</target>
        </trans-unit>
        <trans-unit id="b7e21123ef8eeecb128af522573adb35c0d73ae7" translate="yes" xml:space="preserve">
          <source>VaListImpl::clone_into</source>
          <target state="translated">VaListImpl::clone_into</target>
        </trans-unit>
        <trans-unit id="8cc867e3d0ec9d7fb9edb3f064cbe3324e06efce" translate="yes" xml:space="preserve">
          <source>VaListImpl::drop</source>
          <target state="translated">VaListImpl::drop</target>
        </trans-unit>
        <trans-unit id="c61984180c1cbdf98ccebd337221adae24339007" translate="yes" xml:space="preserve">
          <source>VaListImpl::fmt</source>
          <target state="translated">VaListImpl::fmt</target>
        </trans-unit>
        <trans-unit id="5914da98901e40d1b7387569cc8698d5354eda2d" translate="yes" xml:space="preserve">
          <source>VaListImpl::from</source>
          <target state="translated">VaListImpl::from</target>
        </trans-unit>
        <trans-unit id="69d61c23655b32b3d7479d5b9b6a68338cf35be2" translate="yes" xml:space="preserve">
          <source>VaListImpl::into</source>
          <target state="translated">VaListImpl::into</target>
        </trans-unit>
        <trans-unit id="5bfd2cfab7029ef58c310f856c3da54cb4b8f66b" translate="yes" xml:space="preserve">
          <source>VaListImpl::to_owned</source>
          <target state="translated">VaListImpl::to_owned</target>
        </trans-unit>
        <trans-unit id="2a010a2b25dc2ad1ab26cc514156dc9263f6a636" translate="yes" xml:space="preserve">
          <source>VaListImpl::try_from</source>
          <target state="translated">VaListImpl::try_from</target>
        </trans-unit>
        <trans-unit id="d69de8fd6c5d1bc620b9f394404b1608c17d118f" translate="yes" xml:space="preserve">
          <source>VaListImpl::try_into</source>
          <target state="translated">VaListImpl::try_into</target>
        </trans-unit>
        <trans-unit id="d07770d2e23a78895791cb1ceaf87ef62f25d60c" translate="yes" xml:space="preserve">
          <source>VaListImpl::type_id</source>
          <target state="translated">VaListImpl::type_id</target>
        </trans-unit>
        <trans-unit id="d2fa0e7319df7d0644b9ea0a44af083d4b6e723c" translate="yes" xml:space="preserve">
          <source>VaListImpl::with_copy</source>
          <target state="translated">VaListImpl::with_copy</target>
        </trans-unit>
        <trans-unit id="4e28dc650ae01219c2816ac14486f89634c8fc55" translate="yes" xml:space="preserve">
          <source>VacantEntry</source>
          <target state="translated">VacantEntry</target>
        </trans-unit>
        <trans-unit id="c96052bd94ad047ad8849208c48bf71c8e89ef7c" translate="yes" xml:space="preserve">
          <source>Valid pattern syntax in macro definitions is different than the pattern syntax covered in Chapter 18 because macro patterns are matched against Rust code structure rather than values. Let&amp;rsquo;s walk through what the pattern pieces in Listing 19-28 mean; for the full macro pattern syntax, see &lt;a href=&quot;../reference/macros&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="translated">매크로 정의에서 유효한 패턴 구문은 18 장에서 다룬 패턴 구문과 다릅니다. 매크로 패턴은 값이 아닌 Rust 코드 구조와 일치하기 때문입니다. Listing 19-28의 패턴 부분이 무엇을 의미하는지 살펴 보자. 전체 매크로 패턴 구문에 대해서는 &lt;a href=&quot;../reference/macros&quot;&gt;reference를 참조&lt;/a&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7af7dd6d571b7430a0f3a804a2823ff5e3b34175" translate="yes" xml:space="preserve">
          <source>Valid pattern syntax in macro definitions is different than the pattern syntax covered in Chapter 18 because macro patterns are matched against Rust code structure rather than values. Let&amp;rsquo;s walk through what the pattern pieces in Listing 19-28 mean; for the full macro pattern syntax, see &lt;a href=&quot;../reference/macros-by-example&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="translated">매크로 패턴이 값이 아닌 Rust 코드 구조와 일치하기 때문에 매크로 정의에서 유효한 패턴 구문은 18 장에서 다룬 패턴 구문과 다릅니다. Listing 19-28의 패턴 조각이 무엇을 의미하는지 살펴 보겠습니다. 전체 매크로 패턴 구문 &lt;a href=&quot;../reference/macros-by-example&quot;&gt;은 참조를 참조&lt;/a&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="06e50fbff8c8b7744c52b295c7fbf72559544494" translate="yes" xml:space="preserve">
          <source>Valid raw pointers as defined above are not necessarily properly aligned (where &quot;proper&quot; alignment is defined by the pointee type, i.e., &lt;code&gt;*const T&lt;/code&gt; must be aligned to &lt;code&gt;mem::align_of::&amp;lt;T&amp;gt;()&lt;/code&gt;). However, most functions require their arguments to be properly aligned, and will explicitly state this requirement in their documentation. Notable exceptions to this are &lt;a href=&quot;fn.read_unaligned&quot;&gt;&lt;code&gt;read_unaligned&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.write_unaligned&quot;&gt;&lt;code&gt;write_unaligned&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">위에서 정의한 유효한 원시 포인터는 반드시 올바르게 정렬 될 필요는 없습니다 ( &quot;적절한&quot;정렬은 포인트 유형에 의해 정의됩니다. 즉 &lt;code&gt;*const T&lt;/code&gt; 는 &lt;code&gt;mem::align_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 으로 정렬되어야합니다 ). 그러나 대부분의 함수는 인수를 올바르게 정렬해야하며 설명서에이 요구 사항을 명시 적으로 명시합니다. 이에 대한 예외는 &lt;a href=&quot;fn.read_unaligned&quot;&gt; &lt;code&gt;read_unaligned&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fn.write_unaligned&quot;&gt; &lt;code&gt;write_unaligned&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c48f78e987c312ef821adcc0d7ee75c56d9144ac" translate="yes" xml:space="preserve">
          <source>Validating References with Lifetimes</source>
          <target state="translated">수명으로 참조 확인</target>
        </trans-unit>
        <trans-unit id="9bbb454d5a41c8f26ec9fb9b367e97c6b19c2f83" translate="yes" xml:space="preserve">
          <source>Validating the Number of Threads in &lt;code id=&quot;validating-the-number-of-threads-in-new&quot;&gt;new&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;validating-the-number-of-threads-in-new&quot;&gt;new&lt;/code&gt; 스레드 수 확인</target>
        </trans-unit>
        <trans-unit id="b5528864ad5f1464447c6381f31faab679eb55d8" translate="yes" xml:space="preserve">
          <source>Validating the Request and Selectively Responding</source>
          <target state="translated">요청 확인 및 선택적으로 응답</target>
        </trans-unit>
        <trans-unit id="c4d75c989017ceaea555b5cb2f965e9a31a0f2ae" translate="yes" xml:space="preserve">
          <source>Value being parsed is empty.</source>
          <target state="translated">구문 분석중인 값이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="202eac546e1cca5cc40fbd1aa3d448b11c2717ed" translate="yes" xml:space="preserve">
          <source>Value was Zero</source>
          <target state="translated">가치는 0이었다</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="0c9f5af2d57c101875a9c09b9e64f7ab67e3fee1" translate="yes" xml:space="preserve">
          <source>Values larger than the maximum integer value will saturate to the maximum value of the integer type.</source>
          <target state="translated">최대 정수 값보다 큰 값은 정수 유형의 최대 값으로 포화됩니다.</target>
        </trans-unit>
        <trans-unit id="1cb37a0444183e3bd07455b2f462b02a3823b4ce" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; types may be mutated through shared references (i.e. the common &lt;code&gt;&amp;amp;T&lt;/code&gt; type), whereas most Rust types can only be mutated through unique (&lt;code&gt;&amp;amp;mut T&lt;/code&gt;) references. We say that &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; provide 'interior mutability', in contrast with typical Rust types that exhibit 'inherited mutability'.</source>
          <target state="translated">의 값은 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 유형 (즉, 공통의 참조를 통해 공유 될 수있다 돌연변이 &lt;code&gt;&amp;amp;T&lt;/code&gt; 가장 녹 종류 만 (고유 통해 돌연변이 될 수있는 반면, 타입) &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ) 참조. 우리는 말을 그 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 와 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 일반적인 녹 유형이 전시 '상속 가변성'와 달리 '내부의 가변성'을 제공한다.</target>
        </trans-unit>
        <trans-unit id="df0b0235c50fdaa3c200fefa43bc29bd936a024f" translate="yes" xml:space="preserve">
          <source>Values of this type are constructed using a &lt;a href=&quot;../expressions/tuple-expr#tuple-expressions&quot;&gt;tuple expression&lt;/a&gt;. Furthermore, various expressions will produce the unit value if there is no other meaningful value for it to evaluate to. Tuple elements can be accessed by either a &lt;a href=&quot;../expressions/tuple-expr#tuple-indexing-expressions&quot;&gt;tuple index expression&lt;/a&gt; or &lt;a href=&quot;../patterns#tuple-patterns&quot;&gt;pattern matching&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ead0c6d8884038da5a1c37b81bd9ecdfeb765f5" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;&amp;amp;T&lt;/code&gt; are coerced to values of type &lt;code&gt;&amp;amp;U&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;amp;T&lt;/code&gt; 유형의 값은 &lt;code&gt;&amp;amp;U&lt;/code&gt; 유형의 값으로 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="dd64aa37983b87ea2f61bdac9618cf696e12dc47" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;&amp;amp;mut T&lt;/code&gt; are coerced to values of type &lt;code&gt;&amp;amp;mut U&lt;/code&gt;</source>
          <target state="translated">유형의 값 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 타입의 값으로 강제되는 &lt;code&gt;&amp;amp;mut U&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e8a037908d83b45e7c8a2c2c4fe0fb372c4e345" translate="yes" xml:space="preserve">
          <source>Values returned by the iterator are returned in ascending order:</source>
          <target state="translated">반복자가 반환 한 값은 오름차순으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7d470a568e8e665e2abbc283ee00bd48e19164d9" translate="yes" xml:space="preserve">
          <source>Values smaller than the minimum integer value will saturate to the minimum value of the integer type.</source>
          <target state="translated">최소 정수 값보다 작은 값은 정수 유형의 최소 값으로 포화됩니다.</target>
        </trans-unit>
        <trans-unit id="7afb9932010efa26617ba00942998437043da478" translate="yes" xml:space="preserve">
          <source>ValuesMut</source>
          <target state="translated">ValuesMut</target>
        </trans-unit>
        <trans-unit id="6f7df0e9c5abd887cbbca9fb8a84f3706f71be4d" translate="yes" xml:space="preserve">
          <source>VarError</source>
          <target state="translated">VarError</target>
        </trans-unit>
        <trans-unit id="b2249943fec1979f3539ebcd42bc0163bc44ee0a" translate="yes" xml:space="preserve">
          <source>VarError::borrow</source>
          <target state="translated">VarError::borrow</target>
        </trans-unit>
        <trans-unit id="e76b4c157350bd5d1faf74dc1a04fc95858ad1b0" translate="yes" xml:space="preserve">
          <source>VarError::borrow_mut</source>
          <target state="translated">VarError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8102864035147256ef0e364c15593289f8d64dc2" translate="yes" xml:space="preserve">
          <source>VarError::cause</source>
          <target state="translated">VarError::cause</target>
        </trans-unit>
        <trans-unit id="7077379d5b4387ff8ef4d01332e0c9cb99aeba54" translate="yes" xml:space="preserve">
          <source>VarError::clone</source>
          <target state="translated">VarError::clone</target>
        </trans-unit>
        <trans-unit id="0632068939784835c82259892b18fa3851d349ae" translate="yes" xml:space="preserve">
          <source>VarError::clone_from</source>
          <target state="translated">VarError::clone_from</target>
        </trans-unit>
        <trans-unit id="3e4c81dcadc33c305fcb9909e431adbde92a23e1" translate="yes" xml:space="preserve">
          <source>VarError::clone_into</source>
          <target state="translated">VarError::clone_into</target>
        </trans-unit>
        <trans-unit id="ec42cb6e55e02863f7703ec026731824032ed4c6" translate="yes" xml:space="preserve">
          <source>VarError::description</source>
          <target state="translated">VarError::description</target>
        </trans-unit>
        <trans-unit id="8d65ad24989288d2260d520733e5b865bcae5729" translate="yes" xml:space="preserve">
          <source>VarError::eq</source>
          <target state="translated">VarError::eq</target>
        </trans-unit>
        <trans-unit id="467b0e136a5d88a16831d064cfef40627edbdee5" translate="yes" xml:space="preserve">
          <source>VarError::fmt</source>
          <target state="translated">VarError::fmt</target>
        </trans-unit>
        <trans-unit id="5122b46ea820b54b6d938c3fc817b38fbb3551ec" translate="yes" xml:space="preserve">
          <source>VarError::from</source>
          <target state="translated">VarError::from</target>
        </trans-unit>
        <trans-unit id="489e1a123c276c2da9ec69dea9020703001650ca" translate="yes" xml:space="preserve">
          <source>VarError::into</source>
          <target state="translated">VarError::into</target>
        </trans-unit>
        <trans-unit id="77f840cd95edf89f75e8cbd45132b08b456a0812" translate="yes" xml:space="preserve">
          <source>VarError::ne</source>
          <target state="translated">VarError::ne</target>
        </trans-unit>
        <trans-unit id="0c18e774293ad67a8f9a9531c4cd7c614981cf63" translate="yes" xml:space="preserve">
          <source>VarError::source</source>
          <target state="translated">VarError::source</target>
        </trans-unit>
        <trans-unit id="e8289e8f0efbef22ac2ef6d43d6c953e17d68e73" translate="yes" xml:space="preserve">
          <source>VarError::to_owned</source>
          <target state="translated">VarError::to_owned</target>
        </trans-unit>
        <trans-unit id="3b34bb1f1ce27eec8b875707ed1773dc9147c967" translate="yes" xml:space="preserve">
          <source>VarError::to_string</source>
          <target state="translated">VarError::to_string</target>
        </trans-unit>
        <trans-unit id="2d14c21b020fdc28d154a0e06cc4cefbc03f8bd7" translate="yes" xml:space="preserve">
          <source>VarError::try_from</source>
          <target state="translated">VarError::try_from</target>
        </trans-unit>
        <trans-unit id="20dfa7580a9574a0ffa43df49fcb51fd1edef1e7" translate="yes" xml:space="preserve">
          <source>VarError::try_into</source>
          <target state="translated">VarError::try_into</target>
        </trans-unit>
        <trans-unit id="67e6d907fb202086a0226ec13ebdeab6dee225b8" translate="yes" xml:space="preserve">
          <source>VarError::type_id</source>
          <target state="translated">VarError::type_id</target>
        </trans-unit>
        <trans-unit id="b280dc1f4f1b58422609af96e60af9910ffc1aac" translate="yes" xml:space="preserve">
          <source>Variable Scope</source>
          <target state="translated">변수 범위</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="732411588a5167f463feab941a8f9ac01a5767df" translate="yes" xml:space="preserve">
          <source>Variables and Mutability</source>
          <target state="translated">변수와 돌연변이</target>
        </trans-unit>
        <trans-unit id="3aa41db4c47f6adb669361c7bd5c456d22e65ea3" translate="yes" xml:space="preserve">
          <source>Variables are dropped in reverse order of declaration</source>
          <target state="translated">변수는 선언의 역순으로 삭제됩니다</target>
        </trans-unit>
        <trans-unit id="be65562327a4b52bee54dc313d949d1238b35a3e" translate="yes" xml:space="preserve">
          <source>Variables are dropped in reverse order of declaration. Variables declared in the same pattern drop in an unspecified ordered.</source>
          <target state="translated">변수는 선언 순서와 반대로 삭제됩니다. 동일한 패턴으로 선언 된 변수는 지정되지 않은 순서로 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="098937ab2cfb527e074d853750f7a28c47a33f35" translate="yes" xml:space="preserve">
          <source>Variables bound within the pattern are scoped to the match guard and the arm's expression. The &lt;a href=&quot;../patterns#binding-modes&quot;&gt;binding mode&lt;/a&gt; (move, copy, or reference) depends on the pattern.</source>
          <target state="translated">패턴 내에 바인드 된 변수는 매치 가드 및 팔의 식으로 범위가 지정됩니다. &lt;a href=&quot;../patterns#binding-modes&quot;&gt;결합 모드&lt;/a&gt; (이동, 복사 또는 기준)의 패턴에 따라 달라진다.</target>
        </trans-unit>
        <trans-unit id="3c4d82fabad7ffdf2edb09b215e05fb61c4a456f" translate="yes" xml:space="preserve">
          <source>Variables in Rust are immutable by default, and require the &lt;code&gt;mut&lt;/code&gt; keyword to be made mutable.</source>
          <target state="translated">Rust의 변수는 기본적 으로 변경할 수 없으며 &lt;code&gt;mut&lt;/code&gt; 키워드를 변경할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="8e36a4956d4555b32607f272180c87deea209898" translate="yes" xml:space="preserve">
          <source>Variadic functions</source>
          <target state="translated">다양한 기능</target>
        </trans-unit>
        <trans-unit id="09181b83bd980777906a8422efadb22af2c263db" translate="yes" xml:space="preserve">
          <source>Variadic parameters can only be specified with &lt;a href=&quot;../items/external-blocks&quot;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/a&gt; function types with the &lt;code&gt;&quot;C&quot;&lt;/code&gt; or &lt;code&gt;&quot;cdecl&quot;&lt;/code&gt; calling convention.</source>
          <target state="translated">Variadic 매개 변수는 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;cdecl&quot;&lt;/code&gt; 호출 규칙을 사용하여 &lt;a href=&quot;../items/external-blocks&quot;&gt; &lt;code&gt;extern&lt;/code&gt; &lt;/a&gt; 함수 유형으로 만 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c86f67a7083ae244751a61c00202e2c7bd69682" translate="yes" xml:space="preserve">
          <source>Variadic parameters have been used on a non-C ABI function.</source>
          <target state="translated">C가 아닌 ABI 함수에 가변 매개 변수가 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="eb39bbf6ccbbc8fdb77438c3cd6155bb1b7ec6b8" translate="yes" xml:space="preserve">
          <source>Variance</source>
          <target state="translated">Variance</target>
        </trans-unit>
        <trans-unit id="8a62a01b810204975c3451044bb90c7a71ef1cde" translate="yes" xml:space="preserve">
          <source>Variance in &lt;code&gt;'a&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'a&lt;/code&gt; 의 차이</target>
        </trans-unit>
        <trans-unit id="34a3731e86c04bcba14d808de4b083ba9ec18ab8" translate="yes" xml:space="preserve">
          <source>Variance in &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">에 분산 &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13ea9443937d9e6015e5a5cffcafae425d987b1a" translate="yes" xml:space="preserve">
          <source>Variance is a property that generic types have with respect to their arguments. A generic type's &lt;em&gt;variance&lt;/em&gt; in a parameter is how the subtyping of the parameter affects the subtyping of the type.</source>
          <target state="translated">분산은 일반 유형이 인수와 관련하여 갖는 특성입니다. 매개 변수에서 일반 유형의 &lt;em&gt;분산&lt;/em&gt; 은 매개 변수의 하위 유형이 유형의 하위 유형에 미치는 영향입니다.</target>
        </trans-unit>
        <trans-unit id="9c74b0f6448f867bdf1be672d84dbe75d3a10d26" translate="yes" xml:space="preserve">
          <source>Variance of types is automatically determined as follows</source>
          <target state="translated">유형의 편차는 다음과 같이 자동으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="59640c3e0b061bd7062f06a5f01816c4cfbcbe86" translate="yes" xml:space="preserve">
          <source>Variant visibility</source>
          <target state="translated">변형 가시성</target>
        </trans-unit>
        <trans-unit id="1bc3d368f8ad61e91648458829240a7efefcd2c1" translate="yes" xml:space="preserve">
          <source>Variants</source>
          <target state="translated">Variants</target>
        </trans-unit>
        <trans-unit id="1cec834cdc1b08e2f3ed59d65a8026d0864fc5b4" translate="yes" xml:space="preserve">
          <source>Variants (Non-exhaustive)</source>
          <target state="translated">변형 (비 제한적)</target>
        </trans-unit>
        <trans-unit id="b3fbdc730db8eecbbf239ec3967489785ffcc13f" translate="yes" xml:space="preserve">
          <source>Various built-in attributes use different subsets of the meta item syntax to specify their inputs. The following grammar rules show some commonly used forms:</source>
          <target state="translated">다양한 내장 속성은 메타 항목 구문의 다른 서브 세트를 사용하여 입력을 지정합니다. 다음 문법 규칙은 일반적으로 사용되는 양식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="18d5bf7e0fee25c311080dec74d574b65c4b0764" translate="yes" xml:space="preserve">
          <source>Various separators</source>
          <target state="translated">다양한 분리기</target>
        </trans-unit>
        <trans-unit id="d4251864c293c17029bfa74793ffa95136fcec6d" translate="yes" xml:space="preserve">
          <source>Various things in the standard library may implement one or more of the three, where appropriate.</source>
          <target state="translated">표준 라이브러리의 다양한 것들이 적절한 경우 세 가지 중 하나 이상을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9069e323599df5d27b7c9d2e68cb81566e2b60e" translate="yes" xml:space="preserve">
          <source>Vars</source>
          <target state="translated">Vars</target>
        </trans-unit>
        <trans-unit id="1c47de6b16a76ec820d60a85839ecc1cbf5e4457" translate="yes" xml:space="preserve">
          <source>Vars::all</source>
          <target state="translated">Vars::all</target>
        </trans-unit>
        <trans-unit id="b398eaf22edd2ef7aed1c4f858c613d773d5dd59" translate="yes" xml:space="preserve">
          <source>Vars::any</source>
          <target state="translated">Vars::any</target>
        </trans-unit>
        <trans-unit id="80450fe90037366e6900e0207a00a0ff5399c353" translate="yes" xml:space="preserve">
          <source>Vars::borrow</source>
          <target state="translated">Vars::borrow</target>
        </trans-unit>
        <trans-unit id="21a23559330914e11672cfb421023160c25aceab" translate="yes" xml:space="preserve">
          <source>Vars::borrow_mut</source>
          <target state="translated">Vars::borrow_mut</target>
        </trans-unit>
        <trans-unit id="781b07302eb0ba1fcc3cf935ec319d0ab20b1f65" translate="yes" xml:space="preserve">
          <source>Vars::by_ref</source>
          <target state="translated">Vars::by_ref</target>
        </trans-unit>
        <trans-unit id="9951d905bdeb385924f734897456db259730b15b" translate="yes" xml:space="preserve">
          <source>Vars::chain</source>
          <target state="translated">Vars::chain</target>
        </trans-unit>
        <trans-unit id="b7b0b3926db3e290b2a0c4b07b1ac73606da0d40" translate="yes" xml:space="preserve">
          <source>Vars::cloned</source>
          <target state="translated">Vars::cloned</target>
        </trans-unit>
        <trans-unit id="af8d7407e3b763504a144307a7303f5603d6229f" translate="yes" xml:space="preserve">
          <source>Vars::cmp</source>
          <target state="translated">Vars::cmp</target>
        </trans-unit>
        <trans-unit id="5a55a34bc63ca6a0899a5379932cae28b637a085" translate="yes" xml:space="preserve">
          <source>Vars::collect</source>
          <target state="translated">Vars::collect</target>
        </trans-unit>
        <trans-unit id="4eb06a4620fc01558a8bd2f2bf2b0ca80dc89a4b" translate="yes" xml:space="preserve">
          <source>Vars::copied</source>
          <target state="translated">Vars::copied</target>
        </trans-unit>
        <trans-unit id="bfb7648d61e3607bf3caff921735ae88f75f92ef" translate="yes" xml:space="preserve">
          <source>Vars::count</source>
          <target state="translated">Vars::count</target>
        </trans-unit>
        <trans-unit id="f6b7790787f62ef8a6724b8647c199f3e9fc0e6f" translate="yes" xml:space="preserve">
          <source>Vars::cycle</source>
          <target state="translated">Vars::cycle</target>
        </trans-unit>
        <trans-unit id="c728f5f416f691b01f40cd87af7f9137219eb03f" translate="yes" xml:space="preserve">
          <source>Vars::enumerate</source>
          <target state="translated">Vars::enumerate</target>
        </trans-unit>
        <trans-unit id="0a270124e47b9e2828a920edca2e2e533038569f" translate="yes" xml:space="preserve">
          <source>Vars::eq</source>
          <target state="translated">Vars::eq</target>
        </trans-unit>
        <trans-unit id="7080a20dc333e44166a8558123ba98d85eb6ded3" translate="yes" xml:space="preserve">
          <source>Vars::filter</source>
          <target state="translated">Vars::filter</target>
        </trans-unit>
        <trans-unit id="d41dd539031344f9e7e7bb6171c556fc42ef1957" translate="yes" xml:space="preserve">
          <source>Vars::filter_map</source>
          <target state="translated">Vars::filter_map</target>
        </trans-unit>
        <trans-unit id="78b0b6d5abfd7026b83ef665a619f46c392d69ed" translate="yes" xml:space="preserve">
          <source>Vars::find</source>
          <target state="translated">Vars::find</target>
        </trans-unit>
        <trans-unit id="7044c163171ec6f76f077a2bec8324df3677eec1" translate="yes" xml:space="preserve">
          <source>Vars::find_map</source>
          <target state="translated">Vars::find_map</target>
        </trans-unit>
        <trans-unit id="3b73b80a39e593c77029fbb50e77a9c267cde8cd" translate="yes" xml:space="preserve">
          <source>Vars::flat_map</source>
          <target state="translated">Vars::flat_map</target>
        </trans-unit>
        <trans-unit id="804f30eccc2a282312bcb332187a328e639337a6" translate="yes" xml:space="preserve">
          <source>Vars::flatten</source>
          <target state="translated">Vars::flatten</target>
        </trans-unit>
        <trans-unit id="4534d320518c99c9f5ec34ac48943387ea6be6eb" translate="yes" xml:space="preserve">
          <source>Vars::fmt</source>
          <target state="translated">Vars::fmt</target>
        </trans-unit>
        <trans-unit id="dcbe8ef4d0dae4b0a34ef3131b548dcabe7f720d" translate="yes" xml:space="preserve">
          <source>Vars::fold</source>
          <target state="translated">Vars::fold</target>
        </trans-unit>
        <trans-unit id="c0ce61b83b4e9c664534b8dfbab835e7e489b655" translate="yes" xml:space="preserve">
          <source>Vars::for_each</source>
          <target state="translated">Vars::for_each</target>
        </trans-unit>
        <trans-unit id="5dd1e805808b1f032c733423cbf4ac8a4c5a6981" translate="yes" xml:space="preserve">
          <source>Vars::from</source>
          <target state="translated">Vars::from</target>
        </trans-unit>
        <trans-unit id="af8c15b94b4468f337a1725be34d5554460f0a04" translate="yes" xml:space="preserve">
          <source>Vars::fuse</source>
          <target state="translated">Vars::fuse</target>
        </trans-unit>
        <trans-unit id="51bb1a81fecead1d604391ae02d739a62889b8ac" translate="yes" xml:space="preserve">
          <source>Vars::ge</source>
          <target state="translated">Vars::ge</target>
        </trans-unit>
        <trans-unit id="5b570a759e39ddbf689c5b76c7875f777d223503" translate="yes" xml:space="preserve">
          <source>Vars::gt</source>
          <target state="translated">Vars::gt</target>
        </trans-unit>
        <trans-unit id="e0b5b9d9e5ab4d21c95b05a37ba730388417d6b6" translate="yes" xml:space="preserve">
          <source>Vars::inspect</source>
          <target state="translated">Vars::inspect</target>
        </trans-unit>
        <trans-unit id="b8b6b4992b9eef91d9d506454c1498ee57011e6a" translate="yes" xml:space="preserve">
          <source>Vars::into</source>
          <target state="translated">Vars::into</target>
        </trans-unit>
        <trans-unit id="c48afb05fd046801df4e6edbf9f840dd304b60e1" translate="yes" xml:space="preserve">
          <source>Vars::into_iter</source>
          <target state="translated">Vars::into_iter</target>
        </trans-unit>
        <trans-unit id="e0ccc72484b281423161007f22d8a9293e1ba907" translate="yes" xml:space="preserve">
          <source>Vars::is_sorted</source>
          <target state="translated">Vars::is_sorted</target>
        </trans-unit>
        <trans-unit id="e191fd1f8c7ce00d777cb35f9c5c82504bbe7781" translate="yes" xml:space="preserve">
          <source>Vars::is_sorted_by</source>
          <target state="translated">Vars::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="eb9ca2ba30c83815b850a09d3feb972dfdc158e2" translate="yes" xml:space="preserve">
          <source>Vars::is_sorted_by_key</source>
          <target state="translated">Vars::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="6141318cc3ccabd5ae05e4611a7c5181f6046637" translate="yes" xml:space="preserve">
          <source>Vars::last</source>
          <target state="translated">Vars::last</target>
        </trans-unit>
        <trans-unit id="eecce1750e26f1ae1d749a4bae2b92eade287d53" translate="yes" xml:space="preserve">
          <source>Vars::le</source>
          <target state="translated">Vars::le</target>
        </trans-unit>
        <trans-unit id="b0904ac784f88af599fae6febadea78be6bd22be" translate="yes" xml:space="preserve">
          <source>Vars::lt</source>
          <target state="translated">Vars::lt</target>
        </trans-unit>
        <trans-unit id="aed51bf24598897e8d0ea447d651f3de39248cdc" translate="yes" xml:space="preserve">
          <source>Vars::map</source>
          <target state="translated">Vars::map</target>
        </trans-unit>
        <trans-unit id="8ab4e4308d5f56473c748138761d5bb14402ca33" translate="yes" xml:space="preserve">
          <source>Vars::max</source>
          <target state="translated">Vars::max</target>
        </trans-unit>
        <trans-unit id="5fbff539f6d31b21ce7158f6c6c1edd461357314" translate="yes" xml:space="preserve">
          <source>Vars::max_by</source>
          <target state="translated">Vars::max_by</target>
        </trans-unit>
        <trans-unit id="09ad51f2df0437fa8ff5bd6b68362c0cd8c5cfca" translate="yes" xml:space="preserve">
          <source>Vars::max_by_key</source>
          <target state="translated">Vars::max_by_key</target>
        </trans-unit>
        <trans-unit id="0ea5634589a7714b3ce13a9b994859ddc43c1472" translate="yes" xml:space="preserve">
          <source>Vars::min</source>
          <target state="translated">Vars::min</target>
        </trans-unit>
        <trans-unit id="84ccbe5bb178770383b19523a56c94a1a328c579" translate="yes" xml:space="preserve">
          <source>Vars::min_by</source>
          <target state="translated">Vars::min_by</target>
        </trans-unit>
        <trans-unit id="ef0e80e93b2480afa1eef5654b1d44253416e329" translate="yes" xml:space="preserve">
          <source>Vars::min_by_key</source>
          <target state="translated">Vars::min_by_key</target>
        </trans-unit>
        <trans-unit id="ed5f11b0702d02069bbdec987cd8231701e2f83d" translate="yes" xml:space="preserve">
          <source>Vars::ne</source>
          <target state="translated">Vars::ne</target>
        </trans-unit>
        <trans-unit id="5507ff5e66b6d746ac06bacbd6adfad687952f9d" translate="yes" xml:space="preserve">
          <source>Vars::next</source>
          <target state="translated">Vars::next</target>
        </trans-unit>
        <trans-unit id="aec94ecfda5dc5e8fd928e072a549d3135f6ad84" translate="yes" xml:space="preserve">
          <source>Vars::nth</source>
          <target state="translated">Vars::nth</target>
        </trans-unit>
        <trans-unit id="7b9faff88b13bea2403bdb806528b1b03e775923" translate="yes" xml:space="preserve">
          <source>Vars::partial_cmp</source>
          <target state="translated">Vars::partial_cmp</target>
        </trans-unit>
        <trans-unit id="2c2aef1b9bc3af83507c48a9bec747732d905de4" translate="yes" xml:space="preserve">
          <source>Vars::partition</source>
          <target state="translated">Vars::partition</target>
        </trans-unit>
        <trans-unit id="86900414ba1e745a10275dfdac62d2d9717049f6" translate="yes" xml:space="preserve">
          <source>Vars::peekable</source>
          <target state="translated">Vars::peekable</target>
        </trans-unit>
        <trans-unit id="20b949f960f581abec205874631185ffb7bb5fa1" translate="yes" xml:space="preserve">
          <source>Vars::position</source>
          <target state="translated">Vars::position</target>
        </trans-unit>
        <trans-unit id="8f8bd9d5815bdec99dfe7927fb90687bd92fab9b" translate="yes" xml:space="preserve">
          <source>Vars::product</source>
          <target state="translated">Vars::product</target>
        </trans-unit>
        <trans-unit id="9f0f47f9e4c4906312f7cde7ba18939a86f5931f" translate="yes" xml:space="preserve">
          <source>Vars::rev</source>
          <target state="translated">Vars::rev</target>
        </trans-unit>
        <trans-unit id="4a55d6ece90a2e102e6248bacf85b746657dbf67" translate="yes" xml:space="preserve">
          <source>Vars::rposition</source>
          <target state="translated">Vars::rposition</target>
        </trans-unit>
        <trans-unit id="ef63b4a7e167047c985114917f57fd0d737537fe" translate="yes" xml:space="preserve">
          <source>Vars::scan</source>
          <target state="translated">Vars::scan</target>
        </trans-unit>
        <trans-unit id="3551c9199efbcf81653d617970dabf0cd9ed3d99" translate="yes" xml:space="preserve">
          <source>Vars::size_hint</source>
          <target state="translated">Vars::size_hint</target>
        </trans-unit>
        <trans-unit id="7943d6f84fa998209693b43046c7975775eb51cd" translate="yes" xml:space="preserve">
          <source>Vars::skip</source>
          <target state="translated">Vars::skip</target>
        </trans-unit>
        <trans-unit id="2d1337e0ea678c9a71cefd99de6b48cd2e8b1203" translate="yes" xml:space="preserve">
          <source>Vars::skip_while</source>
          <target state="translated">Vars::skip_while</target>
        </trans-unit>
        <trans-unit id="9ad1eaaaf974f3fa2bff01f61e628ff1dd93b8e7" translate="yes" xml:space="preserve">
          <source>Vars::step_by</source>
          <target state="translated">Vars::step_by</target>
        </trans-unit>
        <trans-unit id="3cfd4ab54ebdd5fc54ce1f5c5cd82d3493150512" translate="yes" xml:space="preserve">
          <source>Vars::sum</source>
          <target state="translated">Vars::sum</target>
        </trans-unit>
        <trans-unit id="b11b3042c11657cd454ca8548f85ff8aeb32a4fd" translate="yes" xml:space="preserve">
          <source>Vars::take</source>
          <target state="translated">Vars::take</target>
        </trans-unit>
        <trans-unit id="70f8ea67196cc23888fa00b81267afd9a27d3c32" translate="yes" xml:space="preserve">
          <source>Vars::take_while</source>
          <target state="translated">Vars::take_while</target>
        </trans-unit>
        <trans-unit id="288b6c944d7368cdf54e313b28e14e5725efaa9b" translate="yes" xml:space="preserve">
          <source>Vars::try_fold</source>
          <target state="translated">Vars::try_fold</target>
        </trans-unit>
        <trans-unit id="cf043e48c60478e52e24f6c062f28fb96fba6f9d" translate="yes" xml:space="preserve">
          <source>Vars::try_for_each</source>
          <target state="translated">Vars::try_for_each</target>
        </trans-unit>
        <trans-unit id="b4fd24921ed57ce691083c1322eaf0856a89e518" translate="yes" xml:space="preserve">
          <source>Vars::try_from</source>
          <target state="translated">Vars::try_from</target>
        </trans-unit>
        <trans-unit id="1daadb045ef158df87f592275c11205ecf5af378" translate="yes" xml:space="preserve">
          <source>Vars::try_into</source>
          <target state="translated">Vars::try_into</target>
        </trans-unit>
        <trans-unit id="2e2cb28cd54a254643d5c8595fc8be18813e9b3a" translate="yes" xml:space="preserve">
          <source>Vars::type_id</source>
          <target state="translated">Vars::type_id</target>
        </trans-unit>
        <trans-unit id="6b38c485c26bfb440ab87bcbfba50961f6cb40d6" translate="yes" xml:space="preserve">
          <source>Vars::unzip</source>
          <target state="translated">Vars::unzip</target>
        </trans-unit>
        <trans-unit id="bbe99efeecd60ccb331cf47e045d9299f8d35e6e" translate="yes" xml:space="preserve">
          <source>Vars::zip</source>
          <target state="translated">Vars::zip</target>
        </trans-unit>
        <trans-unit id="b3dd49122e36d39473d927caf75a7a1efe1ad95f" translate="yes" xml:space="preserve">
          <source>VarsOs</source>
          <target state="translated">VarsOs</target>
        </trans-unit>
        <trans-unit id="0be42997f9c0fa87236d029096ab1f10b322e7b9" translate="yes" xml:space="preserve">
          <source>VarsOs::all</source>
          <target state="translated">VarsOs::all</target>
        </trans-unit>
        <trans-unit id="2f3479491bf53557e01f4e76c184381ed836098b" translate="yes" xml:space="preserve">
          <source>VarsOs::any</source>
          <target state="translated">VarsOs::any</target>
        </trans-unit>
        <trans-unit id="434053241a0ce77b4a57a19b617f9cd0e0d5e814" translate="yes" xml:space="preserve">
          <source>VarsOs::borrow</source>
          <target state="translated">VarsOs::borrow</target>
        </trans-unit>
        <trans-unit id="2d141f266e89d234f18a990d5d607d1646f48aee" translate="yes" xml:space="preserve">
          <source>VarsOs::borrow_mut</source>
          <target state="translated">VarsOs::borrow_mut</target>
        </trans-unit>
        <trans-unit id="425cc86c692b838ef921c23811c4e3302d1bdfc4" translate="yes" xml:space="preserve">
          <source>VarsOs::by_ref</source>
          <target state="translated">VarsOs::by_ref</target>
        </trans-unit>
        <trans-unit id="2ea472498ef341c6fb344b9d8ee413b4e6235be7" translate="yes" xml:space="preserve">
          <source>VarsOs::chain</source>
          <target state="translated">VarsOs::chain</target>
        </trans-unit>
        <trans-unit id="a8c6d8c806adad2da3dacb9238da96bf328655bd" translate="yes" xml:space="preserve">
          <source>VarsOs::cloned</source>
          <target state="translated">VarsOs::cloned</target>
        </trans-unit>
        <trans-unit id="fda36a1ed84216068b1296731249e671c956362c" translate="yes" xml:space="preserve">
          <source>VarsOs::cmp</source>
          <target state="translated">VarsOs::cmp</target>
        </trans-unit>
        <trans-unit id="2db35bab4983e6e4d87a02ad263efa15ddb43d0d" translate="yes" xml:space="preserve">
          <source>VarsOs::collect</source>
          <target state="translated">VarsOs::collect</target>
        </trans-unit>
        <trans-unit id="e1850e83c9e256bacb297e01d179d1197cc0db06" translate="yes" xml:space="preserve">
          <source>VarsOs::copied</source>
          <target state="translated">VarsOs::copied</target>
        </trans-unit>
        <trans-unit id="5c6630d2555a45d97d28a5536655aff9f9e9d3b8" translate="yes" xml:space="preserve">
          <source>VarsOs::count</source>
          <target state="translated">VarsOs::count</target>
        </trans-unit>
        <trans-unit id="f0ac502bdac4e93b09bdc50516564d5e56dc7727" translate="yes" xml:space="preserve">
          <source>VarsOs::cycle</source>
          <target state="translated">VarsOs::cycle</target>
        </trans-unit>
        <trans-unit id="a5e0728a5c9381105cc966f06f76ab6ed5f65903" translate="yes" xml:space="preserve">
          <source>VarsOs::enumerate</source>
          <target state="translated">VarsOs::enumerate</target>
        </trans-unit>
        <trans-unit id="0d4efb3a8d96184d450211631b5b79b1a60ab789" translate="yes" xml:space="preserve">
          <source>VarsOs::eq</source>
          <target state="translated">VarsOs::eq</target>
        </trans-unit>
        <trans-unit id="31db361add8338260d55916657c39337f09b86d7" translate="yes" xml:space="preserve">
          <source>VarsOs::filter</source>
          <target state="translated">VarsOs::filter</target>
        </trans-unit>
        <trans-unit id="0d0a62d2dca8a37393e2c92243786aaf41313690" translate="yes" xml:space="preserve">
          <source>VarsOs::filter_map</source>
          <target state="translated">VarsOs::filter_map</target>
        </trans-unit>
        <trans-unit id="ae7d5fede6f36ca665efd08ae94669cbd14b7cc6" translate="yes" xml:space="preserve">
          <source>VarsOs::find</source>
          <target state="translated">VarsOs::find</target>
        </trans-unit>
        <trans-unit id="a97602f19f448bb335f850af073a9ce84cd5d88f" translate="yes" xml:space="preserve">
          <source>VarsOs::find_map</source>
          <target state="translated">VarsOs::find_map</target>
        </trans-unit>
        <trans-unit id="3678c5ef82f2cb08bc3b287c092316a2ada00a18" translate="yes" xml:space="preserve">
          <source>VarsOs::flat_map</source>
          <target state="translated">VarsOs::flat_map</target>
        </trans-unit>
        <trans-unit id="e8a42aa17639bc96d10468e86951b455866c4904" translate="yes" xml:space="preserve">
          <source>VarsOs::flatten</source>
          <target state="translated">VarsOs::flatten</target>
        </trans-unit>
        <trans-unit id="46320ba9ecbf055cb2e56af08cec6e628a336f92" translate="yes" xml:space="preserve">
          <source>VarsOs::fmt</source>
          <target state="translated">VarsOs::fmt</target>
        </trans-unit>
        <trans-unit id="7bcbf2e75da1a46894beb596faa2a485d58f6a2d" translate="yes" xml:space="preserve">
          <source>VarsOs::fold</source>
          <target state="translated">VarsOs::fold</target>
        </trans-unit>
        <trans-unit id="51b69162489f5329a52d08395d177be1d60cb6a5" translate="yes" xml:space="preserve">
          <source>VarsOs::for_each</source>
          <target state="translated">VarsOs::for_each</target>
        </trans-unit>
        <trans-unit id="e06ff647273899d3fd4ea62e139dbf757cf3d8cc" translate="yes" xml:space="preserve">
          <source>VarsOs::from</source>
          <target state="translated">VarsOs::from</target>
        </trans-unit>
        <trans-unit id="0245bbf420434587e8ec6bdf35d9cf62a6cde011" translate="yes" xml:space="preserve">
          <source>VarsOs::fuse</source>
          <target state="translated">VarsOs::fuse</target>
        </trans-unit>
        <trans-unit id="479913c8896a1c5102d2a5ea1234f740bfde2328" translate="yes" xml:space="preserve">
          <source>VarsOs::ge</source>
          <target state="translated">VarsOs::ge</target>
        </trans-unit>
        <trans-unit id="17feba1de0fe9c2331df5c53c185c7617b4b8cc1" translate="yes" xml:space="preserve">
          <source>VarsOs::gt</source>
          <target state="translated">VarsOs::gt</target>
        </trans-unit>
        <trans-unit id="3033c2aeecf938c398013c5ab0852cd122a7d6b0" translate="yes" xml:space="preserve">
          <source>VarsOs::inspect</source>
          <target state="translated">VarsOs::inspect</target>
        </trans-unit>
        <trans-unit id="3f0b3d392367dab2dc143ca178da7b4d778bbd17" translate="yes" xml:space="preserve">
          <source>VarsOs::into</source>
          <target state="translated">VarsOs::into</target>
        </trans-unit>
        <trans-unit id="16fa54e40b1321bab910ef3ac287342748aea056" translate="yes" xml:space="preserve">
          <source>VarsOs::into_iter</source>
          <target state="translated">VarsOs::into_iter</target>
        </trans-unit>
        <trans-unit id="5c63504ce660906345551dba943ce8d045612e95" translate="yes" xml:space="preserve">
          <source>VarsOs::is_sorted</source>
          <target state="translated">VarsOs::is_sorted</target>
        </trans-unit>
        <trans-unit id="0fdd66d1bfafd9226a154278db222c3aee97c735" translate="yes" xml:space="preserve">
          <source>VarsOs::is_sorted_by</source>
          <target state="translated">VarsOs::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="204163a740d898b80542e502e7da9a7661337b36" translate="yes" xml:space="preserve">
          <source>VarsOs::is_sorted_by_key</source>
          <target state="translated">VarsOs::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="ae35eac698343e1ee4eeec512aed1c16a136d0c7" translate="yes" xml:space="preserve">
          <source>VarsOs::last</source>
          <target state="translated">VarsOs::last</target>
        </trans-unit>
        <trans-unit id="c01f90cf460a2003e266fcb0b34415121c12b736" translate="yes" xml:space="preserve">
          <source>VarsOs::le</source>
          <target state="translated">VarsOs::le</target>
        </trans-unit>
        <trans-unit id="c0cd86a67a36a78ad1451aca611b8fd991760e20" translate="yes" xml:space="preserve">
          <source>VarsOs::lt</source>
          <target state="translated">VarsOs::lt</target>
        </trans-unit>
        <trans-unit id="1cefab93b3f7c14142541eedb899ab5e71be9fc4" translate="yes" xml:space="preserve">
          <source>VarsOs::map</source>
          <target state="translated">VarsOs::map</target>
        </trans-unit>
        <trans-unit id="e6a8c9754fd49b2d51cbf24ecf6d94304e8e64c3" translate="yes" xml:space="preserve">
          <source>VarsOs::max</source>
          <target state="translated">VarsOs::max</target>
        </trans-unit>
        <trans-unit id="1f1f50d119da0ed96c40d44ea09ef96812375781" translate="yes" xml:space="preserve">
          <source>VarsOs::max_by</source>
          <target state="translated">VarsOs::max_by</target>
        </trans-unit>
        <trans-unit id="0f2e6793ee02c5031cf6cc652fab9884db10bbdb" translate="yes" xml:space="preserve">
          <source>VarsOs::max_by_key</source>
          <target state="translated">VarsOs::max_by_key</target>
        </trans-unit>
        <trans-unit id="af3d6a04943a8cf3ad8a6978c4e20520bbd7810c" translate="yes" xml:space="preserve">
          <source>VarsOs::min</source>
          <target state="translated">VarsOs::min</target>
        </trans-unit>
        <trans-unit id="65325562c65c7a37d9553910d80a4c50713493e5" translate="yes" xml:space="preserve">
          <source>VarsOs::min_by</source>
          <target state="translated">VarsOs::min_by</target>
        </trans-unit>
        <trans-unit id="ce454f9015d8cd8601694fb53b1aac058cf4ec7c" translate="yes" xml:space="preserve">
          <source>VarsOs::min_by_key</source>
          <target state="translated">VarsOs::min_by_key</target>
        </trans-unit>
        <trans-unit id="1c7e1099c4b87dd8e83e87ef896a8fe06530c255" translate="yes" xml:space="preserve">
          <source>VarsOs::ne</source>
          <target state="translated">VarsOs::ne</target>
        </trans-unit>
        <trans-unit id="abe200e7a70bbf42fbb261f3d6ecb1a850953161" translate="yes" xml:space="preserve">
          <source>VarsOs::next</source>
          <target state="translated">VarsOs::next</target>
        </trans-unit>
        <trans-unit id="753f8e880e8ece081c8080be088d05ec0d200f80" translate="yes" xml:space="preserve">
          <source>VarsOs::nth</source>
          <target state="translated">VarsOs::nth</target>
        </trans-unit>
        <trans-unit id="b6af18bf99508b4a2d5aac1fbdfad4b5780a6f74" translate="yes" xml:space="preserve">
          <source>VarsOs::partial_cmp</source>
          <target state="translated">VarsOs::partial_cmp</target>
        </trans-unit>
        <trans-unit id="ba0322e8a281d2965f09dafdfe9b78ec1f84e172" translate="yes" xml:space="preserve">
          <source>VarsOs::partition</source>
          <target state="translated">VarsOs::partition</target>
        </trans-unit>
        <trans-unit id="91938a0453fc3e7b7813e5df0009b7580ef490d3" translate="yes" xml:space="preserve">
          <source>VarsOs::peekable</source>
          <target state="translated">VarsOs::peekable</target>
        </trans-unit>
        <trans-unit id="7a37b0e06b2930dc5a294f234caa4a16804177d0" translate="yes" xml:space="preserve">
          <source>VarsOs::position</source>
          <target state="translated">VarsOs::position</target>
        </trans-unit>
        <trans-unit id="4f098ada18205fbc46f5cd22be9968ee3d7b0363" translate="yes" xml:space="preserve">
          <source>VarsOs::product</source>
          <target state="translated">VarsOs::product</target>
        </trans-unit>
        <trans-unit id="6bf84c68f9daffbf302bd074f0e8be5a6ea7823d" translate="yes" xml:space="preserve">
          <source>VarsOs::rev</source>
          <target state="translated">VarsOs::rev</target>
        </trans-unit>
        <trans-unit id="1c60d42a9413b8a7c101dc83c2565f5d37b81a2a" translate="yes" xml:space="preserve">
          <source>VarsOs::rposition</source>
          <target state="translated">VarsOs::rposition</target>
        </trans-unit>
        <trans-unit id="f65790ae1d5619919415f11aef0fe2aee47448a6" translate="yes" xml:space="preserve">
          <source>VarsOs::scan</source>
          <target state="translated">VarsOs::scan</target>
        </trans-unit>
        <trans-unit id="cb8748c599d4e59ff120199769de64e5786ad929" translate="yes" xml:space="preserve">
          <source>VarsOs::size_hint</source>
          <target state="translated">VarsOs::size_hint</target>
        </trans-unit>
        <trans-unit id="3ea59b4b1aae9dc7c132d58be49e094fc8eaa95f" translate="yes" xml:space="preserve">
          <source>VarsOs::skip</source>
          <target state="translated">VarsOs::skip</target>
        </trans-unit>
        <trans-unit id="02c1e6608b48c61896af2016b5b52d75d023957f" translate="yes" xml:space="preserve">
          <source>VarsOs::skip_while</source>
          <target state="translated">VarsOs::skip_while</target>
        </trans-unit>
        <trans-unit id="a0d6c6ad525cb20f675d004819c2121e056f42c8" translate="yes" xml:space="preserve">
          <source>VarsOs::step_by</source>
          <target state="translated">VarsOs::step_by</target>
        </trans-unit>
        <trans-unit id="6846222d088cefb1075c2f24c4eadbd7aed705eb" translate="yes" xml:space="preserve">
          <source>VarsOs::sum</source>
          <target state="translated">VarsOs::sum</target>
        </trans-unit>
        <trans-unit id="91c3203375fe48ab0d3fa32901ee5de67c77a411" translate="yes" xml:space="preserve">
          <source>VarsOs::take</source>
          <target state="translated">VarsOs::take</target>
        </trans-unit>
        <trans-unit id="144ba83f71bf339d2fc7ce6106d27d858be059f1" translate="yes" xml:space="preserve">
          <source>VarsOs::take_while</source>
          <target state="translated">VarsOs::take_while</target>
        </trans-unit>
        <trans-unit id="330e5de6bdd0923300ee2e19673f82661fe3b5aa" translate="yes" xml:space="preserve">
          <source>VarsOs::try_fold</source>
          <target state="translated">VarsOs::try_fold</target>
        </trans-unit>
        <trans-unit id="7f9b1fb25f2d8dc898d57dd0ad57aa6074d0db25" translate="yes" xml:space="preserve">
          <source>VarsOs::try_for_each</source>
          <target state="translated">VarsOs::try_for_each</target>
        </trans-unit>
        <trans-unit id="0371b8d74af891c05681249ef7f32d83f6e8d3d4" translate="yes" xml:space="preserve">
          <source>VarsOs::try_from</source>
          <target state="translated">VarsOs::try_from</target>
        </trans-unit>
        <trans-unit id="45aa3acec5ebcabeaf089da80e453c0f5f80cd2d" translate="yes" xml:space="preserve">
          <source>VarsOs::try_into</source>
          <target state="translated">VarsOs::try_into</target>
        </trans-unit>
        <trans-unit id="24d5d9ef2bba5983d72962681554163d3cc0d7ea" translate="yes" xml:space="preserve">
          <source>VarsOs::type_id</source>
          <target state="translated">VarsOs::type_id</target>
        </trans-unit>
        <trans-unit id="3e592311e132f7aa730baaf56aa5dd0ae220e3d4" translate="yes" xml:space="preserve">
          <source>VarsOs::unzip</source>
          <target state="translated">VarsOs::unzip</target>
        </trans-unit>
        <trans-unit id="e4769bb4e270bd8e779d33f3cae641957c2527b8" translate="yes" xml:space="preserve">
          <source>VarsOs::zip</source>
          <target state="translated">VarsOs::zip</target>
        </trans-unit>
        <trans-unit id="3e8f48ebd55451a20501b45af4a4265976d600b6" translate="yes" xml:space="preserve">
          <source>Vec</source>
          <target state="translated">Vec</target>
        </trans-unit>
        <trans-unit id="9e8ec9d213a0da31ccaaba571b14789e42b08935" translate="yes" xml:space="preserve">
          <source>Vec::align_to</source>
          <target state="translated">Vec::align_to</target>
        </trans-unit>
        <trans-unit id="a6107ed66afb53f802511a5a643ee8656e497b0a" translate="yes" xml:space="preserve">
          <source>Vec::align_to_mut</source>
          <target state="translated">Vec::align_to_mut</target>
        </trans-unit>
        <trans-unit id="f61abeec7dd01f8c47bf83db4b4d0456a9af5e0b" translate="yes" xml:space="preserve">
          <source>Vec::append</source>
          <target state="translated">Vec::append</target>
        </trans-unit>
        <trans-unit id="966721890fa8492f6b4046bd9708da68c72adc73" translate="yes" xml:space="preserve">
          <source>Vec::as_mut</source>
          <target state="translated">Vec::as_mut</target>
        </trans-unit>
        <trans-unit id="831194353af948439212b65f5180ee63686be5ff" translate="yes" xml:space="preserve">
          <source>Vec::as_mut_ptr</source>
          <target state="translated">Vec::as_mut_ptr</target>
        </trans-unit>
        <trans-unit id="2cd229f1c1c1c67e55b523142a4b5506c79ab5e4" translate="yes" xml:space="preserve">
          <source>Vec::as_mut_slice</source>
          <target state="translated">Vec::as_mut_slice</target>
        </trans-unit>
        <trans-unit id="c1e6da016e5f4ce35006127886b4b180eede68b8" translate="yes" xml:space="preserve">
          <source>Vec::as_ptr</source>
          <target state="translated">Vec::as_ptr</target>
        </trans-unit>
        <trans-unit id="8b5099d8e9c3e715862b2b38f181235c7cc24477" translate="yes" xml:space="preserve">
          <source>Vec::as_ref</source>
          <target state="translated">Vec::as_ref</target>
        </trans-unit>
        <trans-unit id="e50619a5c819f0a35e08edd227565f793562e4c8" translate="yes" xml:space="preserve">
          <source>Vec::as_slice</source>
          <target state="translated">Vec::as_slice</target>
        </trans-unit>
        <trans-unit id="0fd5dd3c29cf93dd4e97ef65f08a9644b11adf66" translate="yes" xml:space="preserve">
          <source>Vec::binary_search</source>
          <target state="translated">Vec::binary_search</target>
        </trans-unit>
        <trans-unit id="b52fc5259d9a5986689a231729ba2250dccdf822" translate="yes" xml:space="preserve">
          <source>Vec::binary_search_by</source>
          <target state="translated">Vec::binary_search_by</target>
        </trans-unit>
        <trans-unit id="c25875b591cdd49de2d27d47ee6d7ac1e21d9162" translate="yes" xml:space="preserve">
          <source>Vec::binary_search_by_key</source>
          <target state="translated">Vec::binary_search_by_key</target>
        </trans-unit>
        <trans-unit id="85bd126983a102e0968ff3a77e6cc098a02d6d2b" translate="yes" xml:space="preserve">
          <source>Vec::borrow</source>
          <target state="translated">Vec::borrow</target>
        </trans-unit>
        <trans-unit id="ce949f50884f71dd9c3bd065b3e9f2fac3e1b9b1" translate="yes" xml:space="preserve">
          <source>Vec::borrow_mut</source>
          <target state="translated">Vec::borrow_mut</target>
        </trans-unit>
        <trans-unit id="adf16c9ee55ed12543d9f09958b2da182d391549" translate="yes" xml:space="preserve">
          <source>Vec::by_ref</source>
          <target state="translated">Vec::by_ref</target>
        </trans-unit>
        <trans-unit id="879e3baf25a9301dece592c8e2fe831ab282b68c" translate="yes" xml:space="preserve">
          <source>Vec::capacity</source>
          <target state="translated">Vec::capacity</target>
        </trans-unit>
        <trans-unit id="0008361e288cf11981ce829d1646ffd8fcfd353d" translate="yes" xml:space="preserve">
          <source>Vec::chunks</source>
          <target state="translated">Vec::chunks</target>
        </trans-unit>
        <trans-unit id="753b8583ee481b3421bba7d981070ec72378a929" translate="yes" xml:space="preserve">
          <source>Vec::chunks_exact</source>
          <target state="translated">Vec::chunks_exact</target>
        </trans-unit>
        <trans-unit id="c16f1e8e4bdb33b2b62eb139dbdd695cce8cd9cb" translate="yes" xml:space="preserve">
          <source>Vec::chunks_exact_mut</source>
          <target state="translated">Vec::chunks_exact_mut</target>
        </trans-unit>
        <trans-unit id="5129df9df37eeb41ed7c2d7d9a8c46bfb809e00b" translate="yes" xml:space="preserve">
          <source>Vec::chunks_mut</source>
          <target state="translated">Vec::chunks_mut</target>
        </trans-unit>
        <trans-unit id="b0c0c66afeddeab3613458326ddff56179dee6c6" translate="yes" xml:space="preserve">
          <source>Vec::clamp</source>
          <target state="translated">Vec::clamp</target>
        </trans-unit>
        <trans-unit id="2c2fbd7321fb15ce32f39380f1451dd1d8285167" translate="yes" xml:space="preserve">
          <source>Vec::clear</source>
          <target state="translated">Vec::clear</target>
        </trans-unit>
        <trans-unit id="f74617c56b1b4cb0ac739e41c8d386b187a932a0" translate="yes" xml:space="preserve">
          <source>Vec::clone</source>
          <target state="translated">Vec::clone</target>
        </trans-unit>
        <trans-unit id="7d2eba94d2d4e553221edef828d32477a74ec086" translate="yes" xml:space="preserve">
          <source>Vec::clone_from</source>
          <target state="translated">Vec::clone_from</target>
        </trans-unit>
        <trans-unit id="d765a16b06a09ff23e51adef46f6c11da8454339" translate="yes" xml:space="preserve">
          <source>Vec::clone_from_slice</source>
          <target state="translated">Vec::clone_from_slice</target>
        </trans-unit>
        <trans-unit id="33b8cb435611a78c3d465aaa7784c2b37cbb74e7" translate="yes" xml:space="preserve">
          <source>Vec::clone_into</source>
          <target state="translated">Vec::clone_into</target>
        </trans-unit>
        <trans-unit id="54c91e49e772a616e17900001275475155f0db86" translate="yes" xml:space="preserve">
          <source>Vec::cmp</source>
          <target state="translated">Vec::cmp</target>
        </trans-unit>
        <trans-unit id="0a3297559d1b2d0f5e9d86fb8e4f2702a52aed73" translate="yes" xml:space="preserve">
          <source>Vec::contains</source>
          <target state="translated">Vec::contains</target>
        </trans-unit>
        <trans-unit id="15b499228e83cdfe5d9bacf8f2717eb38b48f38b" translate="yes" xml:space="preserve">
          <source>Vec::copy_from_slice</source>
          <target state="translated">Vec::copy_from_slice</target>
        </trans-unit>
        <trans-unit id="b8ba6b02b6ab7d9e4a58c6ff8c4f8ed29c394009" translate="yes" xml:space="preserve">
          <source>Vec::copy_within</source>
          <target state="translated">Vec::copy_within</target>
        </trans-unit>
        <trans-unit id="789846c5e092b1b0a4c096dc5aa2920af554cadf" translate="yes" xml:space="preserve">
          <source>Vec::dedup</source>
          <target state="translated">Vec::dedup</target>
        </trans-unit>
        <trans-unit id="ef8409a58825c28ce8665f515341da99406dc45e" translate="yes" xml:space="preserve">
          <source>Vec::dedup_by</source>
          <target state="translated">Vec::dedup_by</target>
        </trans-unit>
        <trans-unit id="363d4ee344588ea07c6bc5cfb25580f99e4e6fc4" translate="yes" xml:space="preserve">
          <source>Vec::dedup_by_key</source>
          <target state="translated">Vec::dedup_by_key</target>
        </trans-unit>
        <trans-unit id="1a3c24e46d01efcb53b2e47b9f9fe05604eec885" translate="yes" xml:space="preserve">
          <source>Vec::default</source>
          <target state="translated">Vec::default</target>
        </trans-unit>
        <trans-unit id="b1a2319f3d6321033c9832ada871bb0364c41d6d" translate="yes" xml:space="preserve">
          <source>Vec::deref</source>
          <target state="translated">Vec::deref</target>
        </trans-unit>
        <trans-unit id="700ab6732dec0f913d9f30592a8a083e6275f0e9" translate="yes" xml:space="preserve">
          <source>Vec::deref_mut</source>
          <target state="translated">Vec::deref_mut</target>
        </trans-unit>
        <trans-unit id="5b692065705c3002050f3bc84600cd18eab70011" translate="yes" xml:space="preserve">
          <source>Vec::drain</source>
          <target state="translated">Vec::drain</target>
        </trans-unit>
        <trans-unit id="b56f02a07b5d1e06767ba9089e5a26237d2b6e96" translate="yes" xml:space="preserve">
          <source>Vec::drain_filter</source>
          <target state="translated">Vec::drain_filter</target>
        </trans-unit>
        <trans-unit id="1590e7c585be22084bde77caac361ebaa4d26167" translate="yes" xml:space="preserve">
          <source>Vec::drop</source>
          <target state="translated">Vec::drop</target>
        </trans-unit>
        <trans-unit id="c4e9c1a11aab0c3fbaa646a64a22f3069178f1e1" translate="yes" xml:space="preserve">
          <source>Vec::ends_with</source>
          <target state="translated">Vec::ends_with</target>
        </trans-unit>
        <trans-unit id="6460efc15d9228e5937dc4d9b4bb45990d32a27e" translate="yes" xml:space="preserve">
          <source>Vec::eq</source>
          <target state="translated">Vec::eq</target>
        </trans-unit>
        <trans-unit id="8e07e8d35672a19e43e8097f16c00d816c5cbe97" translate="yes" xml:space="preserve">
          <source>Vec::eq_ignore_ascii_case</source>
          <target state="translated">Vec::eq_ignore_ascii_case</target>
        </trans-unit>
        <trans-unit id="e46b7aa4e045855309d716fccf00cabd75a21e77" translate="yes" xml:space="preserve">
          <source>Vec::extend</source>
          <target state="translated">Vec::extend</target>
        </trans-unit>
        <trans-unit id="bb82f4df3cb27f5fbf87e6541ca1f465f414d3a5" translate="yes" xml:space="preserve">
          <source>Vec::extend_from_slice</source>
          <target state="translated">Vec::extend_from_slice</target>
        </trans-unit>
        <trans-unit id="87732cce3e95948f8d258db19ab24839895b0f76" translate="yes" xml:space="preserve">
          <source>Vec::first</source>
          <target state="translated">Vec::first</target>
        </trans-unit>
        <trans-unit id="fd582f0cbcb6e9f15ed28c1811608a7720bbbf52" translate="yes" xml:space="preserve">
          <source>Vec::first_mut</source>
          <target state="translated">Vec::first_mut</target>
        </trans-unit>
        <trans-unit id="cea112245a192a2715a4ac0d0d4ca6f9f0c88d11" translate="yes" xml:space="preserve">
          <source>Vec::flush</source>
          <target state="translated">Vec::flush</target>
        </trans-unit>
        <trans-unit id="74c0bff699639364b714e18c5e924ebe36d7bbb8" translate="yes" xml:space="preserve">
          <source>Vec::fmt</source>
          <target state="translated">Vec::fmt</target>
        </trans-unit>
        <trans-unit id="3b03e0120686cad397d6fe329718262a73208e9a" translate="yes" xml:space="preserve">
          <source>Vec::from</source>
          <target state="translated">Vec::from</target>
        </trans-unit>
        <trans-unit id="d2409bb7c2f488110f44be1023fc83c93200bfb1" translate="yes" xml:space="preserve">
          <source>Vec::from_iter</source>
          <target state="translated">Vec::from_iter</target>
        </trans-unit>
        <trans-unit id="e5b23b921224c968a51d83bca668d1740812f940" translate="yes" xml:space="preserve">
          <source>Vec::from_raw_parts</source>
          <target state="translated">Vec::from_raw_parts</target>
        </trans-unit>
        <trans-unit id="1b86c87d45b678c05eaedfa482e8e125c09283aa" translate="yes" xml:space="preserve">
          <source>Vec::ge</source>
          <target state="translated">Vec::ge</target>
        </trans-unit>
        <trans-unit id="a36985c63a8174e8d6e9d553daa519abe7ef73a3" translate="yes" xml:space="preserve">
          <source>Vec::get</source>
          <target state="translated">Vec::get</target>
        </trans-unit>
        <trans-unit id="55451d4c9012f0e9dc2705a9a20313c583cbad02" translate="yes" xml:space="preserve">
          <source>Vec::get_mut</source>
          <target state="translated">Vec::get_mut</target>
        </trans-unit>
        <trans-unit id="fbd1dbfc28f1dbf35081eb8a3b624e1ddb17a7d4" translate="yes" xml:space="preserve">
          <source>Vec::get_unchecked</source>
          <target state="translated">Vec::get_unchecked</target>
        </trans-unit>
        <trans-unit id="17aa782943cb8ba6f59f4076d63241b08687fe04" translate="yes" xml:space="preserve">
          <source>Vec::get_unchecked_mut</source>
          <target state="translated">Vec::get_unchecked_mut</target>
        </trans-unit>
        <trans-unit id="12e2684fc2a72b4cdaf5511139faebcd74106115" translate="yes" xml:space="preserve">
          <source>Vec::gt</source>
          <target state="translated">Vec::gt</target>
        </trans-unit>
        <trans-unit id="3214576db0b2f915d4813a780951e762d0453108" translate="yes" xml:space="preserve">
          <source>Vec::hash</source>
          <target state="translated">Vec::hash</target>
        </trans-unit>
        <trans-unit id="cbad63e4de555a52c1156aacfa7acaa37d288f2d" translate="yes" xml:space="preserve">
          <source>Vec::hash_slice</source>
          <target state="translated">Vec::hash_slice</target>
        </trans-unit>
        <trans-unit id="817acc1f56c6b7266c14b400f36bd6915fc69aa9" translate="yes" xml:space="preserve">
          <source>Vec::index</source>
          <target state="translated">Vec::index</target>
        </trans-unit>
        <trans-unit id="255317cd139deae7b3798accef614b86d687af60" translate="yes" xml:space="preserve">
          <source>Vec::index_mut</source>
          <target state="translated">Vec::index_mut</target>
        </trans-unit>
        <trans-unit id="dae9879e89996749967d788919fd3919726095e5" translate="yes" xml:space="preserve">
          <source>Vec::insert</source>
          <target state="translated">Vec::insert</target>
        </trans-unit>
        <trans-unit id="4607993cbee4135669d2825495742a160937c51e" translate="yes" xml:space="preserve">
          <source>Vec::into</source>
          <target state="translated">Vec::into</target>
        </trans-unit>
        <trans-unit id="349c4bbf0cf7617a82524fff4ab6dd6dc12191ae" translate="yes" xml:space="preserve">
          <source>Vec::into_boxed_slice</source>
          <target state="translated">Vec::into_boxed_slice</target>
        </trans-unit>
        <trans-unit id="a2683d7c8a491dd1d14d82cbf394796000e6a7fa" translate="yes" xml:space="preserve">
          <source>Vec::into_iter</source>
          <target state="translated">Vec::into_iter</target>
        </trans-unit>
        <trans-unit id="0617d70073dd3ee36b70acc3469082e13a466d03" translate="yes" xml:space="preserve">
          <source>Vec::is_ascii</source>
          <target state="translated">Vec::is_ascii</target>
        </trans-unit>
        <trans-unit id="03169a81c036f8a9e76093b58242f30ae578d6e1" translate="yes" xml:space="preserve">
          <source>Vec::is_empty</source>
          <target state="translated">Vec::is_empty</target>
        </trans-unit>
        <trans-unit id="61e088912bf7c1fb5b0f0a806c372825ce419a0f" translate="yes" xml:space="preserve">
          <source>Vec::is_sorted</source>
          <target state="translated">Vec::is_sorted</target>
        </trans-unit>
        <trans-unit id="2f71d97de0d886a25068ec904913d5f995b9ec67" translate="yes" xml:space="preserve">
          <source>Vec::is_sorted_by</source>
          <target state="translated">Vec::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="13b69e903c4a68fcfe01f0c6f71a43d7cffcb8d2" translate="yes" xml:space="preserve">
          <source>Vec::is_sorted_by_key</source>
          <target state="translated">Vec::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="67f810a4a6906d879a0e5bcdbd0629cdca0805fc" translate="yes" xml:space="preserve">
          <source>Vec::iter</source>
          <target state="translated">Vec::iter</target>
        </trans-unit>
        <trans-unit id="de14eea28b8af3ebd1fa7277134614ec35bede5f" translate="yes" xml:space="preserve">
          <source>Vec::iter_mut</source>
          <target state="translated">Vec::iter_mut</target>
        </trans-unit>
        <trans-unit id="89cb435951d0739bd80a43fd6eff389c96ea9137" translate="yes" xml:space="preserve">
          <source>Vec::last</source>
          <target state="translated">Vec::last</target>
        </trans-unit>
        <trans-unit id="8ec2cd17a9007516bf67a64facc2086a511ddabc" translate="yes" xml:space="preserve">
          <source>Vec::last_mut</source>
          <target state="translated">Vec::last_mut</target>
        </trans-unit>
        <trans-unit id="fbceeb72cec6860fa83702dbf07c61c0fba92768" translate="yes" xml:space="preserve">
          <source>Vec::le</source>
          <target state="translated">Vec::le</target>
        </trans-unit>
        <trans-unit id="525552cdf64c17bf1df49d77d5e10db05c4a1e65" translate="yes" xml:space="preserve">
          <source>Vec::len</source>
          <target state="translated">Vec::len</target>
        </trans-unit>
        <trans-unit id="1987ee0ae7df89f62926afad448cc8dcba8deb75" translate="yes" xml:space="preserve">
          <source>Vec::lt</source>
          <target state="translated">Vec::lt</target>
        </trans-unit>
        <trans-unit id="d73c1ce0cf0d3ba3f02694929282ef1ce4003f43" translate="yes" xml:space="preserve">
          <source>Vec::make_ascii_lowercase</source>
          <target state="translated">Vec::make_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="c984649eda1457369a83cadb8cb7cced71d85e8a" translate="yes" xml:space="preserve">
          <source>Vec::make_ascii_uppercase</source>
          <target state="translated">Vec::make_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="a14d3f9cce464f0a15bfb1ccdba70544cd9996dc" translate="yes" xml:space="preserve">
          <source>Vec::max</source>
          <target state="translated">Vec::max</target>
        </trans-unit>
        <trans-unit id="b7e2ddaad5a1e72a47531993b322493826992f01" translate="yes" xml:space="preserve">
          <source>Vec::min</source>
          <target state="translated">Vec::min</target>
        </trans-unit>
        <trans-unit id="27ac869c9c4d65022ccbe3db59b454048dac5d01" translate="yes" xml:space="preserve">
          <source>Vec::ne</source>
          <target state="translated">Vec::ne</target>
        </trans-unit>
        <trans-unit id="6fd848867337ba44b23b17c9fe00c94d829ea233" translate="yes" xml:space="preserve">
          <source>Vec::new</source>
          <target state="translated">Vec::new</target>
        </trans-unit>
        <trans-unit id="dcf8d5a328aa406810dabf32cd5ae01b3697decb" translate="yes" xml:space="preserve">
          <source>Vec::partial_cmp</source>
          <target state="translated">Vec::partial_cmp</target>
        </trans-unit>
        <trans-unit id="9694e7862ef0e60d886fd728679d90a8ee9470af" translate="yes" xml:space="preserve">
          <source>Vec::partition_at_index</source>
          <target state="translated">Vec::partition_at_index</target>
        </trans-unit>
        <trans-unit id="0bf6ca8cb659d720aa701bffc2851bc20dd39575" translate="yes" xml:space="preserve">
          <source>Vec::partition_at_index_by</source>
          <target state="translated">Vec::partition_at_index_by</target>
        </trans-unit>
        <trans-unit id="e14cd1ff21e7d949dfbecf45a57afb30d74ae935" translate="yes" xml:space="preserve">
          <source>Vec::partition_at_index_by_key</source>
          <target state="translated">Vec::partition_at_index_by_key</target>
        </trans-unit>
        <trans-unit id="a3bcf68a32491f6ce459bed1b83a0728f8d3facb" translate="yes" xml:space="preserve">
          <source>Vec::partition_dedup</source>
          <target state="translated">Vec::partition_dedup</target>
        </trans-unit>
        <trans-unit id="b33b907d031cab1a9f82dfabed52b3ec36a0bec7" translate="yes" xml:space="preserve">
          <source>Vec::partition_dedup_by</source>
          <target state="translated">Vec::partition_dedup_by</target>
        </trans-unit>
        <trans-unit id="e9042527cd9f8f7b837ac9979689f102fa5b9413" translate="yes" xml:space="preserve">
          <source>Vec::partition_dedup_by_key</source>
          <target state="translated">Vec::partition_dedup_by_key</target>
        </trans-unit>
        <trans-unit id="bb66cba5fa2c2be8852cc1be9f1f0442c400f3c1" translate="yes" xml:space="preserve">
          <source>Vec::pop</source>
          <target state="translated">Vec::pop</target>
        </trans-unit>
        <trans-unit id="015702c3beb31216ec8635f66c58b2dd6c7ce7d3" translate="yes" xml:space="preserve">
          <source>Vec::push</source>
          <target state="translated">Vec::push</target>
        </trans-unit>
        <trans-unit id="2a4ecb67c06267aff12807a92f7519558492cac3" translate="yes" xml:space="preserve">
          <source>Vec::rchunks</source>
          <target state="translated">Vec::rchunks</target>
        </trans-unit>
        <trans-unit id="2190a180c9e13d2c97a99729fb1cab9822f2b367" translate="yes" xml:space="preserve">
          <source>Vec::rchunks_exact</source>
          <target state="translated">Vec::rchunks_exact</target>
        </trans-unit>
        <trans-unit id="8817d4c686ebb9e3df7649dc1ef10bbfc99e5a0f" translate="yes" xml:space="preserve">
          <source>Vec::rchunks_exact_mut</source>
          <target state="translated">Vec::rchunks_exact_mut</target>
        </trans-unit>
        <trans-unit id="d8b31989d0600b79568eabfbd02443e705c374f4" translate="yes" xml:space="preserve">
          <source>Vec::rchunks_mut</source>
          <target state="translated">Vec::rchunks_mut</target>
        </trans-unit>
        <trans-unit id="845831747d56f3eeb00bb35e02809974b407e592" translate="yes" xml:space="preserve">
          <source>Vec::remove</source>
          <target state="translated">Vec::remove</target>
        </trans-unit>
        <trans-unit id="f2019e8c59ea1c039539318392c79102cc50f496" translate="yes" xml:space="preserve">
          <source>Vec::remove_item</source>
          <target state="translated">Vec::remove_item</target>
        </trans-unit>
        <trans-unit id="2a5af4f0d9906283d3505112b8edea1ff6aa8327" translate="yes" xml:space="preserve">
          <source>Vec::repeat</source>
          <target state="translated">Vec::repeat</target>
        </trans-unit>
        <trans-unit id="4030131e8b0f427754fca9b6fc2438b48ee132aa" translate="yes" xml:space="preserve">
          <source>Vec::reserve</source>
          <target state="translated">Vec::reserve</target>
        </trans-unit>
        <trans-unit id="c585b5b6b44dd8ead3846dfe6ff450a1d78b7ca4" translate="yes" xml:space="preserve">
          <source>Vec::reserve_exact</source>
          <target state="translated">Vec::reserve_exact</target>
        </trans-unit>
        <trans-unit id="abcfd065a68ab661075eb65973b1c2983f76906b" translate="yes" xml:space="preserve">
          <source>Vec::resize</source>
          <target state="translated">Vec::resize</target>
        </trans-unit>
        <trans-unit id="f9f7275b35ba8425eb32e3d8e98e0b77a08d75b9" translate="yes" xml:space="preserve">
          <source>Vec::resize_default</source>
          <target state="translated">Vec::resize_default</target>
        </trans-unit>
        <trans-unit id="9f1a1a7d355751c7299454f0938fedf8e60dd549" translate="yes" xml:space="preserve">
          <source>Vec::resize_with</source>
          <target state="translated">Vec::resize_with</target>
        </trans-unit>
        <trans-unit id="fd564ef5b54702a40658f77d501d340f02796c3b" translate="yes" xml:space="preserve">
          <source>Vec::retain</source>
          <target state="translated">Vec::retain</target>
        </trans-unit>
        <trans-unit id="020a2b7b3ef0fc23c178b5a1d57cf3220ce5e5ff" translate="yes" xml:space="preserve">
          <source>Vec::reverse</source>
          <target state="translated">Vec::reverse</target>
        </trans-unit>
        <trans-unit id="b4c1d9424701ec16b3d33474bf2a08c4a985a07b" translate="yes" xml:space="preserve">
          <source>Vec::rotate_left</source>
          <target state="translated">Vec::rotate_left</target>
        </trans-unit>
        <trans-unit id="a21a400e9268e082bb2ce482e8a8dfc6ab09fcf1" translate="yes" xml:space="preserve">
          <source>Vec::rotate_right</source>
          <target state="translated">Vec::rotate_right</target>
        </trans-unit>
        <trans-unit id="230272571f5aeb260545461fbf996bc487081e16" translate="yes" xml:space="preserve">
          <source>Vec::rsplit</source>
          <target state="translated">Vec::rsplit</target>
        </trans-unit>
        <trans-unit id="7588b43de214dc9942b6ec718d4f47a2bcedcba0" translate="yes" xml:space="preserve">
          <source>Vec::rsplit_mut</source>
          <target state="translated">Vec::rsplit_mut</target>
        </trans-unit>
        <trans-unit id="7d1297a0cd4e2ea121ae3252d869a3ab0996a1d6" translate="yes" xml:space="preserve">
          <source>Vec::rsplitn</source>
          <target state="translated">Vec::rsplitn</target>
        </trans-unit>
        <trans-unit id="62a275a0772dd8dc1d1984c12daaf575f3aeeba5" translate="yes" xml:space="preserve">
          <source>Vec::rsplitn_mut</source>
          <target state="translated">Vec::rsplitn_mut</target>
        </trans-unit>
        <trans-unit id="b0b31a5d59982433104183b210cdc7f9a7187cc9" translate="yes" xml:space="preserve">
          <source>Vec::set_len</source>
          <target state="translated">Vec::set_len</target>
        </trans-unit>
        <trans-unit id="dcf4c0bec18deb050ca3760e0ffcb5fbdd9b508d" translate="yes" xml:space="preserve">
          <source>Vec::shrink_to</source>
          <target state="translated">Vec::shrink_to</target>
        </trans-unit>
        <trans-unit id="85ba0030d7417692c1610e814b9b07a58d76e77c" translate="yes" xml:space="preserve">
          <source>Vec::shrink_to_fit</source>
          <target state="translated">Vec::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="16d167d14ba9fe06f16ed99bae2a2c03419b826b" translate="yes" xml:space="preserve">
          <source>Vec::sort</source>
          <target state="translated">Vec::sort</target>
        </trans-unit>
        <trans-unit id="81d8d3adb266cd3ddbf5075796bf792188963e60" translate="yes" xml:space="preserve">
          <source>Vec::sort_by</source>
          <target state="translated">Vec::sort_by</target>
        </trans-unit>
        <trans-unit id="fdaa89a60d5801892ad1d2af91cf732bf0fa3243" translate="yes" xml:space="preserve">
          <source>Vec::sort_by_cached_key</source>
          <target state="translated">Vec::sort_by_cached_key</target>
        </trans-unit>
        <trans-unit id="d7a763e74650730d9254a393db15ca96341ce8b4" translate="yes" xml:space="preserve">
          <source>Vec::sort_by_key</source>
          <target state="translated">Vec::sort_by_key</target>
        </trans-unit>
        <trans-unit id="abf375eb46a47b0a7dc0651c427daa5777cdc87d" translate="yes" xml:space="preserve">
          <source>Vec::sort_unstable</source>
          <target state="translated">Vec::sort_unstable</target>
        </trans-unit>
        <trans-unit id="6b1b6c683e214a704567cbb4866e258d5339b1a6" translate="yes" xml:space="preserve">
          <source>Vec::sort_unstable_by</source>
          <target state="translated">Vec::sort_unstable_by</target>
        </trans-unit>
        <trans-unit id="98bc35f1fee62d3c06dfa775a7a509e42577ec92" translate="yes" xml:space="preserve">
          <source>Vec::sort_unstable_by_key</source>
          <target state="translated">Vec::sort_unstable_by_key</target>
        </trans-unit>
        <trans-unit id="32db21414779495d647f8b90a008c9ef3267c648" translate="yes" xml:space="preserve">
          <source>Vec::splice</source>
          <target state="translated">Vec::splice</target>
        </trans-unit>
        <trans-unit id="a29a88b90b2283fcc62467ac92b894872c49e16c" translate="yes" xml:space="preserve">
          <source>Vec::split</source>
          <target state="translated">Vec::split</target>
        </trans-unit>
        <trans-unit id="6850cc7f3a18a5ae8795a517214f52bd03e37d1b" translate="yes" xml:space="preserve">
          <source>Vec::split_at</source>
          <target state="translated">Vec::split_at</target>
        </trans-unit>
        <trans-unit id="fffa7968cc458ceca06542d5bd41cbc6ab30cf0c" translate="yes" xml:space="preserve">
          <source>Vec::split_at_mut</source>
          <target state="translated">Vec::split_at_mut</target>
        </trans-unit>
        <trans-unit id="a158f5776929dc5fa591347c97af279ee6f308b5" translate="yes" xml:space="preserve">
          <source>Vec::split_first</source>
          <target state="translated">Vec::split_first</target>
        </trans-unit>
        <trans-unit id="6bc5d749a8be60dd619275925ca3abe61e1f1d9c" translate="yes" xml:space="preserve">
          <source>Vec::split_first_mut</source>
          <target state="translated">Vec::split_first_mut</target>
        </trans-unit>
        <trans-unit id="37a2c9e4c660e48769312c66dd3af4005f29a265" translate="yes" xml:space="preserve">
          <source>Vec::split_last</source>
          <target state="translated">Vec::split_last</target>
        </trans-unit>
        <trans-unit id="18a1b33cf122a212120639e6c43b624cc50e7d15" translate="yes" xml:space="preserve">
          <source>Vec::split_last_mut</source>
          <target state="translated">Vec::split_last_mut</target>
        </trans-unit>
        <trans-unit id="cf6ca76593d5b57fc21960139169843fb9cd7b00" translate="yes" xml:space="preserve">
          <source>Vec::split_mut</source>
          <target state="translated">Vec::split_mut</target>
        </trans-unit>
        <trans-unit id="03a916c0fcda14cb715141144403e9cf172139de" translate="yes" xml:space="preserve">
          <source>Vec::split_off</source>
          <target state="translated">Vec::split_off</target>
        </trans-unit>
        <trans-unit id="07108e7065deeacdbce3703bf0867dca70e0aa63" translate="yes" xml:space="preserve">
          <source>Vec::splitn</source>
          <target state="translated">Vec::splitn</target>
        </trans-unit>
        <trans-unit id="670a558b46826ad5134c813b4ea72c5f594e6c9a" translate="yes" xml:space="preserve">
          <source>Vec::splitn_mut</source>
          <target state="translated">Vec::splitn_mut</target>
        </trans-unit>
        <trans-unit id="0c0afbd8febc9c5f973424fd46f0e38ed59ccbe9" translate="yes" xml:space="preserve">
          <source>Vec::starts_with</source>
          <target state="translated">Vec::starts_with</target>
        </trans-unit>
        <trans-unit id="ad111eb0f36abc808f9f63d831dd393671b7d60f" translate="yes" xml:space="preserve">
          <source>Vec::swap</source>
          <target state="translated">Vec::swap</target>
        </trans-unit>
        <trans-unit id="c2d87a017cf8d077c99bd71bef846182121ea2f2" translate="yes" xml:space="preserve">
          <source>Vec::swap_remove</source>
          <target state="translated">Vec::swap_remove</target>
        </trans-unit>
        <trans-unit id="65ba4dcc752fbaf145dfc393c0ebd072c03850f4" translate="yes" xml:space="preserve">
          <source>Vec::swap_with_slice</source>
          <target state="translated">Vec::swap_with_slice</target>
        </trans-unit>
        <trans-unit id="187dcbc4c913473ea9ecc0da0ece64f155078f4d" translate="yes" xml:space="preserve">
          <source>Vec::to_ascii_lowercase</source>
          <target state="translated">Vec::to_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="9e994a24d814eaa773517353561f7db1763ba8c8" translate="yes" xml:space="preserve">
          <source>Vec::to_ascii_uppercase</source>
          <target state="translated">Vec::to_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="2d58122faa3b804afda87ac1afe94b0c2cf49a62" translate="yes" xml:space="preserve">
          <source>Vec::to_owned</source>
          <target state="translated">Vec::to_owned</target>
        </trans-unit>
        <trans-unit id="8295dc906018a2b87ebb59e81316a74736c8fba2" translate="yes" xml:space="preserve">
          <source>Vec::to_vec</source>
          <target state="translated">Vec::to_vec</target>
        </trans-unit>
        <trans-unit id="bbcf834cd40bf8d351710e8898b52c0706e47891" translate="yes" xml:space="preserve">
          <source>Vec::truncate</source>
          <target state="translated">Vec::truncate</target>
        </trans-unit>
        <trans-unit id="b539d40fa6817c484aec79eab2f72f8b069cd61a" translate="yes" xml:space="preserve">
          <source>Vec::try_from</source>
          <target state="translated">Vec::try_from</target>
        </trans-unit>
        <trans-unit id="edfbddcc1f5344a46cf8226a51d4480baae3f991" translate="yes" xml:space="preserve">
          <source>Vec::try_into</source>
          <target state="translated">Vec::try_into</target>
        </trans-unit>
        <trans-unit id="5c86c8fb54973c689718f247d2725be10c514476" translate="yes" xml:space="preserve">
          <source>Vec::try_reserve</source>
          <target state="translated">Vec::try_reserve</target>
        </trans-unit>
        <trans-unit id="31147313c7e8fcea891f9a87a61ed1563dcc2831" translate="yes" xml:space="preserve">
          <source>Vec::try_reserve_exact</source>
          <target state="translated">Vec::try_reserve_exact</target>
        </trans-unit>
        <trans-unit id="eed582f83a9d0aa9e1d0f2c268a23f8e413a6328" translate="yes" xml:space="preserve">
          <source>Vec::type_id</source>
          <target state="translated">Vec::type_id</target>
        </trans-unit>
        <trans-unit id="464742f01bb0869c25eb2800b7d8db8a1c7aac11" translate="yes" xml:space="preserve">
          <source>Vec::windows</source>
          <target state="translated">Vec::windows</target>
        </trans-unit>
        <trans-unit id="5728e3095df170ba310bd22e53f060f7088cdde8" translate="yes" xml:space="preserve">
          <source>Vec::with_capacity</source>
          <target state="translated">Vec::with_capacity</target>
        </trans-unit>
        <trans-unit id="265d2eb25b96552c36adc69855110dc3fd58c9aa" translate="yes" xml:space="preserve">
          <source>Vec::write</source>
          <target state="translated">Vec::write</target>
        </trans-unit>
        <trans-unit id="aeb1c503a25270fdde3115b7ad8a988a9c161a9d" translate="yes" xml:space="preserve">
          <source>Vec::write_all</source>
          <target state="translated">Vec::write_all</target>
        </trans-unit>
        <trans-unit id="bdef50740c7daaafaaf5156f90836f0887c73803" translate="yes" xml:space="preserve">
          <source>Vec::write_fmt</source>
          <target state="translated">Vec::write_fmt</target>
        </trans-unit>
        <trans-unit id="fb5d72587567483189e25ea2273df15eb40edb69" translate="yes" xml:space="preserve">
          <source>Vec::write_vectored</source>
          <target state="translated">Vec::write_vectored</target>
        </trans-unit>
        <trans-unit id="d8b188dca79494d553b4a25f8e7ba135fd059e06" translate="yes" xml:space="preserve">
          <source>VecDeque</source>
          <target state="translated">VecDeque</target>
        </trans-unit>
        <trans-unit id="daac388a0835b2f7f116ce4b930ba45f24e2d4f5" translate="yes" xml:space="preserve">
          <source>VecDeque::append</source>
          <target state="translated">VecDeque::append</target>
        </trans-unit>
        <trans-unit id="131f1606d9fb60120a570fc56345c3b4206cde68" translate="yes" xml:space="preserve">
          <source>VecDeque::as_mut_slices</source>
          <target state="translated">VecDeque::as_mut_slices</target>
        </trans-unit>
        <trans-unit id="e9e3cfebdd186278d399abad0a429053157088f8" translate="yes" xml:space="preserve">
          <source>VecDeque::as_slices</source>
          <target state="translated">VecDeque::as_slices</target>
        </trans-unit>
        <trans-unit id="0edc19e4ca1884e4aacf2a2a4380274826fb2740" translate="yes" xml:space="preserve">
          <source>VecDeque::back</source>
          <target state="translated">VecDeque::back</target>
        </trans-unit>
        <trans-unit id="ccf30a4382ae9328f9552afa5c5dfcfb35aef1b4" translate="yes" xml:space="preserve">
          <source>VecDeque::back_mut</source>
          <target state="translated">VecDeque::back_mut</target>
        </trans-unit>
        <trans-unit id="1d2610cb9f7282ea37e182a5f5c322a259c73e56" translate="yes" xml:space="preserve">
          <source>VecDeque::borrow</source>
          <target state="translated">VecDeque::borrow</target>
        </trans-unit>
        <trans-unit id="c85001c25549712efa3bc4037af617403882f850" translate="yes" xml:space="preserve">
          <source>VecDeque::borrow_mut</source>
          <target state="translated">VecDeque::borrow_mut</target>
        </trans-unit>
        <trans-unit id="50c2744064aa2c0045027447f96537e071e16754" translate="yes" xml:space="preserve">
          <source>VecDeque::capacity</source>
          <target state="translated">VecDeque::capacity</target>
        </trans-unit>
        <trans-unit id="d9ea40fef888b1aa5e6f0be9bc6eb9c5f0603d26" translate="yes" xml:space="preserve">
          <source>VecDeque::clamp</source>
          <target state="translated">VecDeque::clamp</target>
        </trans-unit>
        <trans-unit id="cef7bd89bf4a4eb9ba33004328fb058621269fe0" translate="yes" xml:space="preserve">
          <source>VecDeque::clear</source>
          <target state="translated">VecDeque::clear</target>
        </trans-unit>
        <trans-unit id="7e47848a7466bf6f810550e555917863d0558598" translate="yes" xml:space="preserve">
          <source>VecDeque::clone</source>
          <target state="translated">VecDeque::clone</target>
        </trans-unit>
        <trans-unit id="b0049440019ab3255550d699f8fa2c7e984241f3" translate="yes" xml:space="preserve">
          <source>VecDeque::clone_from</source>
          <target state="translated">VecDeque::clone_from</target>
        </trans-unit>
        <trans-unit id="5a931f3dab8ce84e0c1498215e0a5ee5c312dbc4" translate="yes" xml:space="preserve">
          <source>VecDeque::clone_into</source>
          <target state="translated">VecDeque::clone_into</target>
        </trans-unit>
        <trans-unit id="fd9dee766072ccb51f39babcce6cdd2ca35cde93" translate="yes" xml:space="preserve">
          <source>VecDeque::cmp</source>
          <target state="translated">VecDeque::cmp</target>
        </trans-unit>
        <trans-unit id="95d4c1d4f7170dca761e595f58227ed371676262" translate="yes" xml:space="preserve">
          <source>VecDeque::contains</source>
          <target state="translated">VecDeque::contains</target>
        </trans-unit>
        <trans-unit id="551608dce97aa0630c90774ad10f52c70cb6f3f6" translate="yes" xml:space="preserve">
          <source>VecDeque::default</source>
          <target state="translated">VecDeque::default</target>
        </trans-unit>
        <trans-unit id="6f86475df434e68c6dc113b2e5b2233f287a6033" translate="yes" xml:space="preserve">
          <source>VecDeque::drain</source>
          <target state="translated">VecDeque::drain</target>
        </trans-unit>
        <trans-unit id="4fddce3df4c9fe156f475165f3f4d5240f0afce4" translate="yes" xml:space="preserve">
          <source>VecDeque::drop</source>
          <target state="translated">VecDeque::drop</target>
        </trans-unit>
        <trans-unit id="0fcb62d0015e3066aec7a6e38e31f65772d5501d" translate="yes" xml:space="preserve">
          <source>VecDeque::eq</source>
          <target state="translated">VecDeque::eq</target>
        </trans-unit>
        <trans-unit id="075a7bfccff36cfa5ad77b2a00e19382093a8565" translate="yes" xml:space="preserve">
          <source>VecDeque::extend</source>
          <target state="translated">VecDeque::extend</target>
        </trans-unit>
        <trans-unit id="e054fa9bced4f47898e926baffbc0c60a08459c0" translate="yes" xml:space="preserve">
          <source>VecDeque::fmt</source>
          <target state="translated">VecDeque::fmt</target>
        </trans-unit>
        <trans-unit id="19d255ee2f123a37e942fb29c84911a9f64f017f" translate="yes" xml:space="preserve">
          <source>VecDeque::from</source>
          <target state="translated">VecDeque::from</target>
        </trans-unit>
        <trans-unit id="242a52440e095905c36864a3c86c19da0f44a3fd" translate="yes" xml:space="preserve">
          <source>VecDeque::from_iter</source>
          <target state="translated">VecDeque::from_iter</target>
        </trans-unit>
        <trans-unit id="29993bead69617ad206973adb616d88cb8d89425" translate="yes" xml:space="preserve">
          <source>VecDeque::front</source>
          <target state="translated">VecDeque::front</target>
        </trans-unit>
        <trans-unit id="e4634241db2e3ef12564b756a7fc707c4a7a5f18" translate="yes" xml:space="preserve">
          <source>VecDeque::front_mut</source>
          <target state="translated">VecDeque::front_mut</target>
        </trans-unit>
        <trans-unit id="bc3f2b749e59a78256a0d2040a1d3bb5af4f5693" translate="yes" xml:space="preserve">
          <source>VecDeque::ge</source>
          <target state="translated">VecDeque::ge</target>
        </trans-unit>
        <trans-unit id="915b9e825c31e8d816c506ced80cc1f68ac3f054" translate="yes" xml:space="preserve">
          <source>VecDeque::get</source>
          <target state="translated">VecDeque::get</target>
        </trans-unit>
        <trans-unit id="136e7c47681eaa1d904864e8ff5c5bc220e4a7dc" translate="yes" xml:space="preserve">
          <source>VecDeque::get_mut</source>
          <target state="translated">VecDeque::get_mut</target>
        </trans-unit>
        <trans-unit id="ba60604fac009b3ce77b20443c60c9bac64877e8" translate="yes" xml:space="preserve">
          <source>VecDeque::gt</source>
          <target state="translated">VecDeque::gt</target>
        </trans-unit>
        <trans-unit id="bb2d82113864a1efc245faa3fb2f0734777df20f" translate="yes" xml:space="preserve">
          <source>VecDeque::hash</source>
          <target state="translated">VecDeque::hash</target>
        </trans-unit>
        <trans-unit id="f6b79958f591855d1dfc59a3acb71adf01cbc54f" translate="yes" xml:space="preserve">
          <source>VecDeque::hash_slice</source>
          <target state="translated">VecDeque::hash_slice</target>
        </trans-unit>
        <trans-unit id="2874956ebb7bcf9026d0ebcfd7bebe25fd32ed31" translate="yes" xml:space="preserve">
          <source>VecDeque::index</source>
          <target state="translated">VecDeque::index</target>
        </trans-unit>
        <trans-unit id="0deef4e869afff07622817110cb765c3c5082356" translate="yes" xml:space="preserve">
          <source>VecDeque::index_mut</source>
          <target state="translated">VecDeque::index_mut</target>
        </trans-unit>
        <trans-unit id="723879b69186c6e2f0632b97f6198a38736cdfca" translate="yes" xml:space="preserve">
          <source>VecDeque::insert</source>
          <target state="translated">VecDeque::insert</target>
        </trans-unit>
        <trans-unit id="5940a7ce6c6c2aa56e27efb2aeab5436d0047626" translate="yes" xml:space="preserve">
          <source>VecDeque::into</source>
          <target state="translated">VecDeque::into</target>
        </trans-unit>
        <trans-unit id="4f160a12e1c1a6ef0fe052b739a694daddb4a0ba" translate="yes" xml:space="preserve">
          <source>VecDeque::into_iter</source>
          <target state="translated">VecDeque::into_iter</target>
        </trans-unit>
        <trans-unit id="381e6c2228a85e3684cbe01131ece6f6d4ed363e" translate="yes" xml:space="preserve">
          <source>VecDeque::is_empty</source>
          <target state="translated">VecDeque::is_empty</target>
        </trans-unit>
        <trans-unit id="2ca65467993d11e2001a70631255186873bfafbb" translate="yes" xml:space="preserve">
          <source>VecDeque::iter</source>
          <target state="translated">VecDeque::iter</target>
        </trans-unit>
        <trans-unit id="8a7f75f31f2781e622162ab2f9f48e26e163488d" translate="yes" xml:space="preserve">
          <source>VecDeque::iter_mut</source>
          <target state="translated">VecDeque::iter_mut</target>
        </trans-unit>
        <trans-unit id="f0a5bfefb2b6fe51d59e368db422f4c5b160ce8f" translate="yes" xml:space="preserve">
          <source>VecDeque::le</source>
          <target state="translated">VecDeque::le</target>
        </trans-unit>
        <trans-unit id="4bb921fa6df10d02b3f7cab0954102290f635a15" translate="yes" xml:space="preserve">
          <source>VecDeque::len</source>
          <target state="translated">VecDeque::len</target>
        </trans-unit>
        <trans-unit id="71e95769828a9b92c66e7c31ffd10fc3033cd8d6" translate="yes" xml:space="preserve">
          <source>VecDeque::lt</source>
          <target state="translated">VecDeque::lt</target>
        </trans-unit>
        <trans-unit id="34ae597b0c94f97d4d1d62357cf5e38331a6df8f" translate="yes" xml:space="preserve">
          <source>VecDeque::max</source>
          <target state="translated">VecDeque::max</target>
        </trans-unit>
        <trans-unit id="1bd90cfd9d14576806aeb5601e565be6d9a2c392" translate="yes" xml:space="preserve">
          <source>VecDeque::min</source>
          <target state="translated">VecDeque::min</target>
        </trans-unit>
        <trans-unit id="916cd3bda61d1c51bd600b30eeee5cb3cd744e77" translate="yes" xml:space="preserve">
          <source>VecDeque::ne</source>
          <target state="translated">VecDeque::ne</target>
        </trans-unit>
        <trans-unit id="e81647b640d809ed6db522b8fec3ed80b259e69f" translate="yes" xml:space="preserve">
          <source>VecDeque::new</source>
          <target state="translated">VecDeque::new</target>
        </trans-unit>
        <trans-unit id="2417422e13a2ce0e6f09ab0a2c5ca7d335599a19" translate="yes" xml:space="preserve">
          <source>VecDeque::partial_cmp</source>
          <target state="translated">VecDeque::partial_cmp</target>
        </trans-unit>
        <trans-unit id="2f7ea749d2fc3447b1276750b71f28b1df80824c" translate="yes" xml:space="preserve">
          <source>VecDeque::pop_back</source>
          <target state="translated">VecDeque::pop_back</target>
        </trans-unit>
        <trans-unit id="b5099f7ca42bc97193acf6d46c82dfad34dce9ea" translate="yes" xml:space="preserve">
          <source>VecDeque::pop_front</source>
          <target state="translated">VecDeque::pop_front</target>
        </trans-unit>
        <trans-unit id="b68186ce0ffaa5c573e191524102ee4df9e5a76f" translate="yes" xml:space="preserve">
          <source>VecDeque::push_back</source>
          <target state="translated">VecDeque::push_back</target>
        </trans-unit>
        <trans-unit id="c974534a42ac8b948ff96329fe775b8663ed7e1c" translate="yes" xml:space="preserve">
          <source>VecDeque::push_front</source>
          <target state="translated">VecDeque::push_front</target>
        </trans-unit>
        <trans-unit id="f66c8df74e7950f8a5c27628b399552275e7990b" translate="yes" xml:space="preserve">
          <source>VecDeque::remove</source>
          <target state="translated">VecDeque::remove</target>
        </trans-unit>
        <trans-unit id="63da2dc6f5d7c077d66b800dc3e9cfb610812d1e" translate="yes" xml:space="preserve">
          <source>VecDeque::reserve</source>
          <target state="translated">VecDeque::reserve</target>
        </trans-unit>
        <trans-unit id="f0c9f269e1c0f3fe87bb1e1d4dbafbb60fe03a88" translate="yes" xml:space="preserve">
          <source>VecDeque::reserve_exact</source>
          <target state="translated">VecDeque::reserve_exact</target>
        </trans-unit>
        <trans-unit id="15c7000e6223107d6e8f85520188c2ad5dbc3269" translate="yes" xml:space="preserve">
          <source>VecDeque::resize</source>
          <target state="translated">VecDeque::resize</target>
        </trans-unit>
        <trans-unit id="2509349114431a93f293a45b673cb587453cf5c1" translate="yes" xml:space="preserve">
          <source>VecDeque::resize_with</source>
          <target state="translated">VecDeque::resize_with</target>
        </trans-unit>
        <trans-unit id="ccc031575f67542dd46824a3e983601461110cc4" translate="yes" xml:space="preserve">
          <source>VecDeque::retain</source>
          <target state="translated">VecDeque::retain</target>
        </trans-unit>
        <trans-unit id="b5a555e8903b3b7977f45918d1ce6774e918a183" translate="yes" xml:space="preserve">
          <source>VecDeque::rotate_left</source>
          <target state="translated">VecDeque::rotate_left</target>
        </trans-unit>
        <trans-unit id="e6e34526379d06662776e4b338c08f5600228980" translate="yes" xml:space="preserve">
          <source>VecDeque::rotate_right</source>
          <target state="translated">VecDeque::rotate_right</target>
        </trans-unit>
        <trans-unit id="49e9a45e383cf99b6b9e65b1da390fd01a8bda3d" translate="yes" xml:space="preserve">
          <source>VecDeque::shrink_to</source>
          <target state="translated">VecDeque::shrink_to</target>
        </trans-unit>
        <trans-unit id="f6fcc5b10ec16f8a12c0c4dc559d3a8de78ca52b" translate="yes" xml:space="preserve">
          <source>VecDeque::shrink_to_fit</source>
          <target state="translated">VecDeque::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="230a74fc242f8f9ef7eacdecb321bb25f227f97b" translate="yes" xml:space="preserve">
          <source>VecDeque::split_off</source>
          <target state="translated">VecDeque::split_off</target>
        </trans-unit>
        <trans-unit id="2a4ea39d8e7a00cf428e2650b17e58a789217e16" translate="yes" xml:space="preserve">
          <source>VecDeque::swap</source>
          <target state="translated">VecDeque::swap</target>
        </trans-unit>
        <trans-unit id="558d98e0536ea1f17ff9046952a317ebda0ef01d" translate="yes" xml:space="preserve">
          <source>VecDeque::swap_remove_back</source>
          <target state="translated">VecDeque::swap_remove_back</target>
        </trans-unit>
        <trans-unit id="43928a9b864a3fd9bdb5ec554ba365e4bdf9ef8f" translate="yes" xml:space="preserve">
          <source>VecDeque::swap_remove_front</source>
          <target state="translated">VecDeque::swap_remove_front</target>
        </trans-unit>
        <trans-unit id="49014001bde4ab42b533abbe113ed3c97ffe8b66" translate="yes" xml:space="preserve">
          <source>VecDeque::to_owned</source>
          <target state="translated">VecDeque::to_owned</target>
        </trans-unit>
        <trans-unit id="4a856cf5c6f4f0083955ca9fd38f17e56d42db38" translate="yes" xml:space="preserve">
          <source>VecDeque::truncate</source>
          <target state="translated">VecDeque::truncate</target>
        </trans-unit>
        <trans-unit id="1c108e04a773fcc428e30cb84e0bbed6cbe42d01" translate="yes" xml:space="preserve">
          <source>VecDeque::try_from</source>
          <target state="translated">VecDeque::try_from</target>
        </trans-unit>
        <trans-unit id="63a287d3d33ab67ecaccc4cde3b6cb4bbc9bf2f9" translate="yes" xml:space="preserve">
          <source>VecDeque::try_into</source>
          <target state="translated">VecDeque::try_into</target>
        </trans-unit>
        <trans-unit id="4492e019180be9cbd1149bea9dacc85b974da183" translate="yes" xml:space="preserve">
          <source>VecDeque::try_reserve</source>
          <target state="translated">VecDeque::try_reserve</target>
        </trans-unit>
        <trans-unit id="f18ae4264c3943cfe280f4bac2b78e0d6daaad9f" translate="yes" xml:space="preserve">
          <source>VecDeque::try_reserve_exact</source>
          <target state="translated">VecDeque::try_reserve_exact</target>
        </trans-unit>
        <trans-unit id="01e7052c0ca6f4f03791b81a8f2de96b096c403e" translate="yes" xml:space="preserve">
          <source>VecDeque::type_id</source>
          <target state="translated">VecDeque::type_id</target>
        </trans-unit>
        <trans-unit id="21024b6a92b5ebe7899517ec253ead58d6d5c99f" translate="yes" xml:space="preserve">
          <source>VecDeque::with_capacity</source>
          <target state="translated">VecDeque::with_capacity</target>
        </trans-unit>
        <trans-unit id="14ddd4e611818edf9f3b1bf4e1ac181e0ff9a35c" translate="yes" xml:space="preserve">
          <source>Vectors also support indexing (through the &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.indexmut&quot;&gt;&lt;code&gt;IndexMut&lt;/code&gt;&lt;/a&gt; traits):</source>
          <target state="translated">벡터는 또한 &lt;a href=&quot;../ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../ops/trait.indexmut&quot;&gt; &lt;code&gt;IndexMut&lt;/code&gt; &lt;/a&gt; 특성을 통해 인덱싱을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="10bd4ec04f26e95aeb5bf4a6ea31710e8b61d3aa" translate="yes" xml:space="preserve">
          <source>Vectors ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes.</source>
          <target state="translated">벡터는 &lt;code&gt;isize::MAX&lt;/code&gt; 바이트 이상을 할당하지 않도록 합니다.</target>
        </trans-unit>
        <trans-unit id="1fcacbf65fe28c66eeb9a0946fc51047bb848688" translate="yes" xml:space="preserve">
          <source>Vectors have &lt;code&gt;O(1)&lt;/code&gt; indexing, amortized &lt;code&gt;O(1)&lt;/code&gt; push (to the end) and &lt;code&gt;O(1)&lt;/code&gt; pop (from the end).</source>
          <target state="translated">벡터에는 &lt;code&gt;O(1)&lt;/code&gt; 인덱싱, &lt;code&gt;O(1)&lt;/code&gt; 푸시 (끝) 및 &lt;code&gt;O(1)&lt;/code&gt; 팝 (끝)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e52ec64b79bd415e19f90abf054a377374903982" translate="yes" xml:space="preserve">
          <source>Vectors, strings, and hash maps will provide a large amount of functionality necessary in programs when you need to store, access, and modify data. Here are some exercises you should now be equipped to solve:</source>
          <target state="translated">벡터, 문자열 및 해시 맵은 데이터를 저장, 액세스 및 수정해야 할 때 프로그램에 필요한 많은 기능을 제공합니다. 다음은 해결해야 할 몇 가지 연습입니다.</target>
        </trans-unit>
        <trans-unit id="93994f6561df197197d9ab4e109435108851564b" translate="yes" xml:space="preserve">
          <source>Verbatim UNC prefixes consist of &lt;code&gt;\?\UNC\&lt;/code&gt; immediately followed by the server's hostname and a share name.</source>
          <target state="translated">Verbatim UNC 접두사는 &lt;code&gt;\?\UNC\&lt;/code&gt; 바로 뒤에 서버의 호스트 이름과 공유 이름으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="deeec6948b9b0c7f539defff599e2c9119f209e1" translate="yes" xml:space="preserve">
          <source>Verbatim UNC prefixes consist of &lt;code&gt;\\?\UNC\&lt;/code&gt; immediately followed by the server's hostname and a share name.</source>
          <target state="translated">축 어적 UNC 접두사는 &lt;code&gt;\\?\UNC\&lt;/code&gt; 바로 뒤에 서버의 호스트 이름과 공유 이름으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="a6bddd5ce42d02852a5de958933bae21b4a5cfba" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefix, e.g., &lt;code&gt;\?\C:\&lt;/code&gt;.</source>
          <target state="translated">축 어적으로 디스크 접두사, 예를 들어, &lt;code&gt;\?\C:\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc9892a19a8c55087305e1dc4f1a3f3fc14b7bbe" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefix, e.g., &lt;code&gt;\\?\C:&lt;/code&gt;.</source>
          <target state="translated">축 어적 디스크 접두사, 예 : &lt;code&gt;\\?\C:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd1495f59f098b63bc590bd84cd0a43862e1bc2d" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefixes consist of &lt;code&gt;\?\&lt;/code&gt; immediately followed by the drive letter and &lt;code&gt;:\&lt;/code&gt;.</source>
          <target state="translated">완전 디스크 접두사는 &lt;code&gt;\?\&lt;/code&gt; 바로 다음에 드라이브 문자와 &lt;code&gt;:\&lt;/code&gt; 로 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="bbcf31c83c72d79322932f64e5c3a662a2b82084" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefixes consist of &lt;code&gt;\\?\&lt;/code&gt; immediately followed by the drive letter and &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">축 어적 디스크 접두사는 &lt;code&gt;\\?\&lt;/code&gt; 바로 뒤에 드라이브 문자와 &lt;code&gt;:&lt;/code&gt; 으로 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="cf73e30b59ed0c54d6be7774228261a2779fe5cc" translate="yes" xml:space="preserve">
          <source>Verbatim prefix using Windows' &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;N&lt;/strong&gt;aming &lt;strong&gt;C&lt;/strong&gt;onvention&lt;/em&gt;, e.g., &lt;code&gt;\?\UNC\server\share&lt;/code&gt;.</source>
          <target state="translated">축 어적으로 접두사 윈도우 '를 사용하여 &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt; niform &lt;strong&gt;N은&lt;/strong&gt; aming &lt;strong&gt;C의&lt;/strong&gt; onvention를&lt;/em&gt; 예를 들면, &lt;code&gt;\?\UNC\server\share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d803e02d9c2966256665f4a37fc515a7b6b0270" translate="yes" xml:space="preserve">
          <source>Verbatim prefix using Windows' &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;N&lt;/strong&gt;aming &lt;strong&gt;C&lt;/strong&gt;onvention&lt;/em&gt;, e.g., &lt;code&gt;\\?\UNC\server\share&lt;/code&gt;.</source>
          <target state="translated">축 어적으로 접두사 윈도우 '를 사용하여 &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt; niform &lt;strong&gt;N은&lt;/strong&gt; aming &lt;strong&gt;C의&lt;/strong&gt; onvention을&lt;/em&gt; 예를 들어, &lt;code&gt;\\?\UNC\server\share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0f55e7ce5ed8a93cf2556500fb3c6edc3497a78" translate="yes" xml:space="preserve">
          <source>Verbatim prefix, e.g., &lt;code&gt;\?\cat_pics&lt;/code&gt;.</source>
          <target state="translated">축 어적으로 접두사, 예를 들면, &lt;code&gt;\?\cat_pics&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec64b930987590c33c18d3b5f5e6cd65655febca" translate="yes" xml:space="preserve">
          <source>Verbatim prefix, e.g., &lt;code&gt;\\?\cat_pics&lt;/code&gt;.</source>
          <target state="translated">축 어적 접두사, 예 : &lt;code&gt;\\?\cat_pics&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45aebd4cf45d4a9cae739dfb022275481be2f580" translate="yes" xml:space="preserve">
          <source>Verbatim prefixes consist of &lt;code&gt;\?\&lt;/code&gt; immediately followed by the given component.</source>
          <target state="translated">동사 접두사는 &lt;code&gt;\?\&lt;/code&gt; 바로 뒤에 주어진 구성 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c060304c7d1622fca546ec1708bfccb55b07579" translate="yes" xml:space="preserve">
          <source>Verbatim prefixes consist of &lt;code&gt;\\?\&lt;/code&gt; immediately followed by the given component.</source>
          <target state="translated">축 어적 접두사는 &lt;code&gt;\\?\&lt;/code&gt; 바로 뒤에 주어진 구성 요소로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="9fe26a152f2000c79f02c76f235c753790949e1b" translate="yes" xml:space="preserve">
          <source>Verify you didn't misspell the field's name or that the field exists. Example:</source>
          <target state="translated">필드 이름을 잘못 입력하지 않았거나 필드가 존재하는지 확인하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="13a25bba13e90167e49cf7cd3a2f78bb62a9115f" translate="yes" xml:space="preserve">
          <source>Via immutable references, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allows you to share data between multiple parts of your program for reading only. If &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allowed you to have multiple mutable references too, you might violate one of the borrowing rules discussed in Chapter 4: multiple mutable borrows to the same place can cause data races and inconsistencies. But being able to mutate data is very useful! In the next section, we&amp;rsquo;ll discuss the interior mutability pattern and the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type that you can use in conjunction with an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to work with this immutability restriction.</source>
          <target state="translated">변경 불가능한 참조를 통해 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 사용하면 읽기 전용으로 프로그램의 여러 부분간에 데이터를 공유 할 수 있습니다. 경우 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 너무 여러 변경 가능한 참조를 가질 수, 당신은 제 4 장에서 논의 된 차입 규칙 중 하나를 위반할 수 : 같은 장소에 여러 개의 가변 차용 데이터 인종과 불일치가 발생할 수 있습니다. 그러나 데이터를 변경하는 것은 매우 유용합니다! 다음 섹션에서는 이러한 불변성 제한을 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 위해 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 와 함께 사용할 수 있는 내부 변이 패턴과 RefCell &amp;lt;T&amp;gt; 유형에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="0d87f61e558881a5ade183d0bde7c788bfd6f83f" translate="yes" xml:space="preserve">
          <source>Views the underlying data as a subslice of the original data.</source>
          <target state="translated">기본 데이터를 원본 데이터의 하위 슬라이스로 봅니다.</target>
        </trans-unit>
        <trans-unit id="1365826e0c779fd37f6eca7e517fca02b3a8cb6e" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures.</source>
          <target state="translated">이를 위반하면 할당 자의 내부 데이터 구조가 손상되는 등의 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb48d3b71d8e2b4ff5d04e4cf39bdefa7b5572e2" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures. For example it is &lt;strong&gt;not&lt;/strong&gt; safe to build a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; from a pointer to a C &lt;code&gt;char&lt;/code&gt; array and a &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">이를 위반하면 할당 자의 내부 데이터 구조가 손상되는 등의 문제가 발생할 수 있습니다. 예를 들어 , 포인터에서 C &lt;code&gt;char&lt;/code&gt; 배열 및 &lt;code&gt;size_t&lt;/code&gt; 에 대한 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 을 작성하는 &lt;strong&gt;것은&lt;/strong&gt; 안전 &lt;strong&gt;하지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8f4c0ad7ae3e37221747e827bd3d99a0ac9c1516" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures. For example it is &lt;strong&gt;not&lt;/strong&gt; safe to build a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; from a pointer to a C &lt;code&gt;char&lt;/code&gt; array with length &lt;code&gt;size_t&lt;/code&gt;. It's also not safe to build one from a &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt; and its length, because the allocator cares about the alignment, and these two types have different alignments. The buffer was allocated with alignment 2 (for &lt;code&gt;u16&lt;/code&gt;), but after turning it into a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; it'll be deallocated with alignment 1.</source>
          <target state="translated">이를 위반하면 할당 자의 내부 데이터 구조가 손상되는 것과 같은 문제가 발생할 수 있습니다. 예를 들어, 길이가 &lt;code&gt;size_t&lt;/code&gt; 인 C &lt;code&gt;char&lt;/code&gt; 배열에 대한 포인터에서 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 을 빌드하는 &lt;strong&gt;것은&lt;/strong&gt; 안전 &lt;strong&gt;하지 않습니다&lt;/strong&gt; . 할당자가 정렬에 관심이 &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt; 두 가지 유형이 서로 다른 정렬을 갖기 때문에 Vec &amp;lt;u16&amp;gt; 및 해당 길이 에서 하나를 빌드하는 것도 안전하지 않습니다 . 버퍼는 정렬 2 ( &lt;code&gt;u16&lt;/code&gt; 의 경우 ) 로 할당 되었지만 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 로 바꾼 후 정렬 1로 할당 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="68a9e976ee9a673b03411318a7594553e252043a" translate="yes" xml:space="preserve">
          <source>Visibility and Privacy</source>
          <target state="translated">가시성 및 개인 정보</target>
        </trans-unit>
        <trans-unit id="acf880408a272d86a4dffcc14370fa0e4c75f47e" translate="yes" xml:space="preserve">
          <source>Visibility is restricted to a module which isn't an ancestor of the current item.</source>
          <target state="translated">가시성은 현재 항목의 조상이 아닌 모듈로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="2253ed7f72dc34e443e7ac4b4d54a938632b8a51" translate="yes" xml:space="preserve">
          <source>Visits the values representing the difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; but not in &lt;code&gt;other&lt;/code&gt;, in ascending order.</source>
          <target state="translated">차이를 나타내는 값, 즉 &lt;code&gt;self&lt;/code&gt; 있지만 &lt;code&gt;other&lt;/code&gt; 것은 아닌 값을 오름차순으로 방문합니다.</target>
        </trans-unit>
        <trans-unit id="f8a6bc69139e604b07a0f7b4fbe59cbc45d6edd3" translate="yes" xml:space="preserve">
          <source>Visits the values representing the difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; but not in &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">차이를 나타내는 값, 즉 &lt;code&gt;self&lt;/code&gt; 있지만 &lt;code&gt;other&lt;/code&gt; 것은 아닌 값을 방문합니다 .</target>
        </trans-unit>
        <trans-unit id="dc96275105d5fba203854ba6f2ee584290bb3b73" translate="yes" xml:space="preserve">
          <source>Visits the values representing the intersection, i.e., the values that are both in &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;, in ascending order.</source>
          <target state="translated">교차점을 나타내는 값, 즉 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 에있는 값을 오름차순으로 방문합니다.</target>
        </trans-unit>
        <trans-unit id="93583e19debdd8af49f8221dd00dfcadd36273e2" translate="yes" xml:space="preserve">
          <source>Visits the values representing the intersection, i.e., the values that are both in &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">교차점을 나타내는 값, 즉 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 에있는 값을 방문합니다 .</target>
        </trans-unit>
        <trans-unit id="28e2e9de1a1c698adb94ec422ee9bf00f1688bfd" translate="yes" xml:space="preserve">
          <source>Visits the values representing the symmetric difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; or in &lt;code&gt;other&lt;/code&gt; but not in both, in ascending order.</source>
          <target state="translated">대칭 차이를 나타내는 값, 즉 &lt;code&gt;self&lt;/code&gt; 또는 &lt;code&gt;other&lt;/code&gt; 이지만 둘 다 아닌 값을 오름차순으로 방문합니다.</target>
        </trans-unit>
        <trans-unit id="fa09c4a89b2981de0304dd859519ef2763925fbe" translate="yes" xml:space="preserve">
          <source>Visits the values representing the symmetric difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; or in &lt;code&gt;other&lt;/code&gt; but not in both.</source>
          <target state="translated">대칭 차이를 나타내는 값, 즉 &lt;code&gt;self&lt;/code&gt; 또는 &lt;code&gt;other&lt;/code&gt; 이지만 둘 다 아닌 값을 방문합니다 .</target>
        </trans-unit>
        <trans-unit id="0df67d950d55cf2c0598f1e1251b10522c48b544" translate="yes" xml:space="preserve">
          <source>Visits the values representing the union, i.e., all the values in &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;other&lt;/code&gt;, without duplicates, in ascending order.</source>
          <target state="translated">합집합을 나타내는 값, 즉 &lt;code&gt;self&lt;/code&gt; 또는 &lt;code&gt;other&lt;/code&gt; 모든 값을 중복없이 오름차순으로 방문합니다.</target>
        </trans-unit>
        <trans-unit id="372c3b3a71e44e50a3dea412035758dc5043954e" translate="yes" xml:space="preserve">
          <source>Visits the values representing the union, i.e., all the values in &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;other&lt;/code&gt;, without duplicates.</source>
          <target state="translated">합집합을 나타내는 값, 즉 &lt;code&gt;self&lt;/code&gt; 또는 &lt;code&gt;other&lt;/code&gt; 의 모든 값을 중복없이 방문합니다 .</target>
        </trans-unit>
        <trans-unit id="b51bd391919340a1d743507985c13733c7d6ef03" translate="yes" xml:space="preserve">
          <source>Visualizing Changes to &lt;code id=&quot;visualizing-changes-to-strong_count-and-weak_count&quot;&gt;strong_count&lt;/code&gt; and &lt;code&gt;weak_count&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;visualizing-changes-to-strong_count-and-weak_count&quot;&gt;strong_count&lt;/code&gt; 및 &lt;code&gt;weak_count&lt;/code&gt; 의 변경 사항 시각화</target>
        </trans-unit>
        <trans-unit id="5676220497eef42728656e0979bea9c2b6a82a8d" translate="yes" xml:space="preserve">
          <source>Volatile operations are intended to act on I/O memory, and are guaranteed to not be elided or reordered by the compiler across other volatile operations.</source>
          <target state="translated">휘발성 작업은 I / O 메모리에서 작동하도록 만들어졌으며 다른 휘발성 작업에서 컴파일러에 의해 제거되거나 재정렬되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d931abb9ea1e9005fc4f3995afaab08188bb3825" translate="yes" xml:space="preserve">
          <source>Volatiles</source>
          <target state="translated">Volatiles</target>
        </trans-unit>
        <trans-unit id="84367e806ed16f93cd67aba890fbaef52d16a0b0" translate="yes" xml:space="preserve">
          <source>WASI</source>
          <target state="translated">WASI</target>
        </trans-unit>
        <trans-unit id="ba8f9147789a84cc1ed9d8889e7d1c5f2daf86f4" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult</source>
          <target state="translated">WaitTimeoutResult</target>
        </trans-unit>
        <trans-unit id="d23921257696dfde2d9be54900202ded6b40531a" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::borrow</source>
          <target state="translated">WaitTimeoutResult::borrow</target>
        </trans-unit>
        <trans-unit id="e4bfa58c6b772c5c978a9f15aff3ea8c9c337b13" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::borrow_mut</source>
          <target state="translated">WaitTimeoutResult::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c3089a31c84a7e69d4ddcec9c0086d559ad1b613" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone</source>
          <target state="translated">WaitTimeoutResult::clone</target>
        </trans-unit>
        <trans-unit id="70898505602cfbffc60f6b92220a2bc67a50e4fc" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone_from</source>
          <target state="translated">WaitTimeoutResult::clone_from</target>
        </trans-unit>
        <trans-unit id="506d6ad86d4aff5c7e768f2126b38a03b1d6c423" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone_into</source>
          <target state="translated">WaitTimeoutResult::clone_into</target>
        </trans-unit>
        <trans-unit id="6f6dbd7e4a97fd19ec8ae296c6d1dac4f8b0cd21" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::eq</source>
          <target state="translated">WaitTimeoutResult::eq</target>
        </trans-unit>
        <trans-unit id="35a169d82c2d4126bbef2d91986f74234c08e3f4" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::fmt</source>
          <target state="translated">WaitTimeoutResult::fmt</target>
        </trans-unit>
        <trans-unit id="d91631f6c310b01cb29b0c0162a387839cb15ffe" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::from</source>
          <target state="translated">WaitTimeoutResult::from</target>
        </trans-unit>
        <trans-unit id="ef7960e6e721280bc278dd1c18cf9bca11f3e3ed" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::into</source>
          <target state="translated">WaitTimeoutResult::into</target>
        </trans-unit>
        <trans-unit id="976e11e82a160257a424dca59d93a6c8b4ea9c2e" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::ne</source>
          <target state="translated">WaitTimeoutResult::ne</target>
        </trans-unit>
        <trans-unit id="d44ae46166a2e05fe6ce0cd81947f8954e918fc2" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::timed_out</source>
          <target state="translated">WaitTimeoutResult::timed_out</target>
        </trans-unit>
        <trans-unit id="7529a448deceda69965b242f331d3d2d47de0385" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::to_owned</source>
          <target state="translated">WaitTimeoutResult::to_owned</target>
        </trans-unit>
        <trans-unit id="65e57a3d134eede7b603278b2efd076550f5d118" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::try_from</source>
          <target state="translated">WaitTimeoutResult::try_from</target>
        </trans-unit>
        <trans-unit id="d9057517a24e151919a1e702856497fc9f2e1e84" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::try_into</source>
          <target state="translated">WaitTimeoutResult::try_into</target>
        </trans-unit>
        <trans-unit id="3644db7e54ec2be3e6df93522ec9c4b7fd95833f" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::type_id</source>
          <target state="translated">WaitTimeoutResult::type_id</target>
        </trans-unit>
        <trans-unit id="707f6cef491effde076842e8db8ae647cd201bf6" translate="yes" xml:space="preserve">
          <source>Waiting for All Threads to Finish Using &lt;code id=&quot;waiting-for-all-threads-to-finish-using-join-handles&quot;&gt;join&lt;/code&gt; Handles</source>
          <target state="translated">&lt;code id=&quot;waiting-for-all-threads-to-finish-using-join-handles&quot;&gt;join&lt;/code&gt; 핸들을 사용하여 모든 스레드가 완료되기를 기다리는 중</target>
        </trans-unit>
        <trans-unit id="16762eaefa56555c2eaf6e62a6941b2c5ed7357c" translate="yes" xml:space="preserve">
          <source>Waiting for the complete expiration of the timeout:</source>
          <target state="translated">시간 종료가 완료되기를 기다리는 중 :</target>
        </trans-unit>
        <trans-unit id="d04122eb5d85e603a5a6012d2d57fbefd85efc03" translate="yes" xml:space="preserve">
          <source>Waits for the associated thread to finish.</source>
          <target state="translated">연관된 스레드가 완료 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="34b4e1bb7b04512bdbb73573cc9f9995a4cee485" translate="yes" xml:space="preserve">
          <source>Waits for the child to exit completely, returning the status that it exited with. This function will continue to have the same return value after it has been called at least once.</source>
          <target state="translated">자식이 완전히 종료 될 때까지 기다렸다가 종료 한 상태를 반환합니다. 이 함수는 한 번 이상 호출 된 후에도 동일한 반환 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="bada0f7482ebbe8649cfde044b8142e9d439c89f" translate="yes" xml:space="preserve">
          <source>Waits on this condition variable for a notification, timing out after a specified duration.</source>
          <target state="translated">지정된 기간이 지나면 시간이 초과되어 알림을 받기 위해이 조건 변수를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="5f3ce7afc1b4ccb3adac9511f2e1a29e873da201" translate="yes" xml:space="preserve">
          <source>Waits on this condition variable for a notification, timing out after a specified duration. Spurious wakes will not cause this function to return.</source>
          <target state="translated">지정된 기간이 지나면 시간이 초과되어 알림을 받기 위해이 조건 변수를 기다립니다. 가짜 깨우기는이 기능을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6a3650e37b6043ab9616dfc37b87c0ed505a997" translate="yes" xml:space="preserve">
          <source>Wake</source>
          <target state="translated">Wake</target>
        </trans-unit>
        <trans-unit id="2b6971b8cb619ebe6c9f69185b57e5e06726f961" translate="yes" xml:space="preserve">
          <source>Wake this task without consuming the waker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b7b65fb8cc05d38d07b2b178ad74919bff2a82" translate="yes" xml:space="preserve">
          <source>Wake this task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c08e4975d568759cf6703d7bf42952ea304f69e" translate="yes" xml:space="preserve">
          <source>Wake up the task associated with this &lt;code&gt;Waker&lt;/code&gt; without consuming the &lt;code&gt;Waker&lt;/code&gt;.</source>
          <target state="translated">이와 관련된 작업 일어나 &lt;code&gt;Waker&lt;/code&gt; 소비없이 &lt;code&gt;Waker&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="d14583aa06ad08eac440eaabe26c3c50f057b2bc" translate="yes" xml:space="preserve">
          <source>Wake up the task associated with this &lt;code&gt;Waker&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Waker&lt;/code&gt; 와 연관된 태스크를 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="3351e0284024332d1623f9bb9a71979fc567226e" translate="yes" xml:space="preserve">
          <source>Waker</source>
          <target state="translated">Waker</target>
        </trans-unit>
        <trans-unit id="cde3f67c66f5f28656fc3e5918215e0e89065f1b" translate="yes" xml:space="preserve">
          <source>Waker::borrow</source>
          <target state="translated">Waker::borrow</target>
        </trans-unit>
        <trans-unit id="4730ffe6cdd3c37ff166509e6842ce9c54808ecd" translate="yes" xml:space="preserve">
          <source>Waker::borrow_mut</source>
          <target state="translated">Waker::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c55434e246359c8fc39f697b6dc48a600c843fc6" translate="yes" xml:space="preserve">
          <source>Waker::clone</source>
          <target state="translated">Waker::clone</target>
        </trans-unit>
        <trans-unit id="67b661bd0a919b7f0b91980320280ec91e150f76" translate="yes" xml:space="preserve">
          <source>Waker::clone_from</source>
          <target state="translated">Waker::clone_from</target>
        </trans-unit>
        <trans-unit id="1c2f577207eaa3ec3e4ed985f5d3e602b6562f5b" translate="yes" xml:space="preserve">
          <source>Waker::clone_into</source>
          <target state="translated">Waker::clone_into</target>
        </trans-unit>
        <trans-unit id="5763e4fbb711b943b7adb49f3b570b11dfc56482" translate="yes" xml:space="preserve">
          <source>Waker::drop</source>
          <target state="translated">Waker::drop</target>
        </trans-unit>
        <trans-unit id="59f5fb30df1099c8be4ea0f63525b5f20bc3b0cc" translate="yes" xml:space="preserve">
          <source>Waker::fmt</source>
          <target state="translated">Waker::fmt</target>
        </trans-unit>
        <trans-unit id="481f8567d4cc56bcde4c4c7a68610c7e2afe3467" translate="yes" xml:space="preserve">
          <source>Waker::from</source>
          <target state="translated">Waker::from</target>
        </trans-unit>
        <trans-unit id="a71eeb1ffb09bb62e0abc145961000b8eb952efc" translate="yes" xml:space="preserve">
          <source>Waker::from_raw</source>
          <target state="translated">Waker::from_raw</target>
        </trans-unit>
        <trans-unit id="e4a2920ea1322a025438e540af5908bbe5355feb" translate="yes" xml:space="preserve">
          <source>Waker::into</source>
          <target state="translated">Waker::into</target>
        </trans-unit>
        <trans-unit id="b5c94deea812ac7971e5e547d37f8de0e4069039" translate="yes" xml:space="preserve">
          <source>Waker::to_owned</source>
          <target state="translated">Waker::to_owned</target>
        </trans-unit>
        <trans-unit id="4d7590d298d6e86cfce8436d7126d6579b5efe02" translate="yes" xml:space="preserve">
          <source>Waker::try_from</source>
          <target state="translated">Waker::try_from</target>
        </trans-unit>
        <trans-unit id="93850bbbeb49130f5814f2b2766dad35d67a02cd" translate="yes" xml:space="preserve">
          <source>Waker::try_into</source>
          <target state="translated">Waker::try_into</target>
        </trans-unit>
        <trans-unit id="defc51d6b61ef5711b242ae9d4802c4e7e0c0ef8" translate="yes" xml:space="preserve">
          <source>Waker::type_id</source>
          <target state="translated">Waker::type_id</target>
        </trans-unit>
        <trans-unit id="3b802cf623fed6228c8df899224af25458dc9ead" translate="yes" xml:space="preserve">
          <source>Waker::wake</source>
          <target state="translated">Waker::wake</target>
        </trans-unit>
        <trans-unit id="21f366613aaf5bfb62a448abcbff836bae6e879b" translate="yes" xml:space="preserve">
          <source>Waker::wake_by_ref</source>
          <target state="translated">Waker::wake_by_ref</target>
        </trans-unit>
        <trans-unit id="8aecacb6eb7528e5a7db24ccc5440f41aaa29b5e" translate="yes" xml:space="preserve">
          <source>Waker::will_wake</source>
          <target state="translated">Waker::will_wake</target>
        </trans-unit>
        <trans-unit id="cb2a27aece1c0e17c9a4f0452314d6cd5e8fb236" translate="yes" xml:space="preserve">
          <source>Wakes up all blocked threads on this condvar.</source>
          <target state="translated">이 condvar의 모든 차단 스레드를 깨 웁니다.</target>
        </trans-unit>
        <trans-unit id="2ed59db39229b55b2b647aa6c360911539dad3f2" translate="yes" xml:space="preserve">
          <source>Wakes up one blocked thread on this condvar.</source>
          <target state="translated">이 condvar에서 하나의 차단 된 스레드를 깨 웁니다.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="0c441a7834cca3176be65fd184ebccd3cdfff007" translate="yes" xml:space="preserve">
          <source>Warning: &lt;code&gt;hash_builder&lt;/code&gt; is normally randomly generated, and is designed to allow HashMaps to be resistant to attacks that cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack vector.</source>
          <target state="translated">경고 : &lt;code&gt;hash_builder&lt;/code&gt; 는 일반적으로 무작위로 생성되며 HashMaps 가 많은 충돌과 성능 저하를 유발하는 공격에 저항 할 수 있도록 설계되었습니다. 이 기능을 사용하여 수동으로 설정하면 DoS 공격 경로가 노출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7950a45e4b64d6e5edea8b18ef2a3e5365114042" translate="yes" xml:space="preserve">
          <source>Warning: &lt;code&gt;hasher&lt;/code&gt; is normally randomly generated, and is designed to allow &lt;code&gt;HashSet&lt;/code&gt;s to be resistant to attacks that cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack vector.</source>
          <target state="translated">경고 : &lt;code&gt;hasher&lt;/code&gt; 는 일반적으로 무작위로 생성되며 &lt;code&gt;HashSet&lt;/code&gt; 이 많은 충돌과 성능 저하를 유발하는 공격에 저항 할 수 있도록 설계되었습니다 . 이 기능을 사용하여 수동으로 설정하면 DoS 공격 경로가 노출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2edf09dde564575fa5343a5e7951070dc2295c5" translate="yes" xml:space="preserve">
          <source>Warning: It is possible for arbitrarily-set configuration options to have the same value as compiler-set configuration options. For example, it is possible to do &lt;code&gt;rustc --cfg &quot;unix&quot; program.rs&lt;/code&gt; while compiling to a Windows target, and have both &lt;code&gt;unix&lt;/code&gt; and &lt;code&gt;windows&lt;/code&gt; configuration options set at the same time. It is unwise to actually do this.</source>
          <target state="translated">경고 : 임의로 설정 한 구성 옵션이 컴파일러 설정 구성 옵션과 동일한 값을 가질 수 있습니다. 예를 들어, Windows 대상으로 컴파일하는 동안 &lt;code&gt;rustc --cfg &quot;unix&quot; program.rs&lt;/code&gt; 를 수행하고 &lt;code&gt;unix&lt;/code&gt; 및 &lt;code&gt;windows&lt;/code&gt; 구성 옵션을 동시에 설정할 수 있습니다. 실제로 이렇게하는 것은 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="953fdee2421f57eef922d79cc862ee6e22ccfc48" translate="yes" xml:space="preserve">
          <source>Warning: There are crucial differences between an &lt;code&gt;enum&lt;/code&gt; in the C language and Rust's &lt;a href=&quot;items/enumerations#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;field-less enums&lt;/a&gt; with this representation. An &lt;code&gt;enum&lt;/code&gt; in C is mostly a &lt;code&gt;typedef&lt;/code&gt; plus some named constants; in other words, an object of an &lt;code&gt;enum&lt;/code&gt; type can hold any integer value. For example, this is often used for bitflags in &lt;code&gt;C&lt;/code&gt;. In contrast, Rust&amp;rsquo;s &lt;a href=&quot;items/enumerations#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;field-less enums&lt;/a&gt; can only legally hold the discrimnant values, everything else is &lt;a href=&quot;behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;. Therefore, using a field-less enum in FFI to model a C &lt;code&gt;enum&lt;/code&gt; is often wrong.</source>
          <target state="translated">경고 : 사이의 중요한 차이가 있습니다 &lt;code&gt;enum&lt;/code&gt; C 언어와 녹의 &lt;a href=&quot;items/enumerations#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;현장 덜 열거&lt;/a&gt; 이 표현으로는. C 의 &lt;code&gt;enum&lt;/code&gt; 은 대부분 &lt;code&gt;typedef&lt;/code&gt; 와 일부 명명 된 상수입니다. 즉, &lt;code&gt;enum&lt;/code&gt; 유형 의 객체는 모든 정수 값을 보유 할 수 있습니다. 예를 들어, 이것은 종종 &lt;code&gt;C&lt;/code&gt; 의 비트 플래그에 사용됩니다 . 대조적으로, Rust의 &lt;a href=&quot;items/enumerations#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;field-less enum&lt;/a&gt; 은 합법적으로 불분명 한 값을 보유 할 수 있으며 다른 모든 것은 &lt;a href=&quot;behavior-considered-undefined&quot;&gt;정의되지 않은 동작&lt;/a&gt; 입니다. 따라서 FFI에서 필드없는 열거를 사용하여 C &lt;code&gt;enum&lt;/code&gt; 을 모델링하는 것은 종종 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="3380a2f82f6fe7cbeb705d60d75cf6bd01597812" translate="yes" xml:space="preserve">
          <source>Warning: There are crucial differences between an &lt;code&gt;enum&lt;/code&gt; in the C language and Rust's C-like enumerations with this representation. An &lt;code&gt;enum&lt;/code&gt; in C is mostly a &lt;code&gt;typedef&lt;/code&gt; plus some named constants; in other words, an object of an &lt;code&gt;enum&lt;/code&gt; type can hold any integer value. For example, this is often used for bitflags in &lt;code&gt;C&lt;/code&gt;. In contrast, Rust&amp;rsquo;s C-like enumerations can only legally hold the discriminant values, everything else is undefined behaviour. Therefore, using a C-like enumeration in FFI to model a C &lt;code&gt;enum&lt;/code&gt; is often wrong.</source>
          <target state="translated">경고 : C 언어의 열거 형과이 표현으로 Rust의 C와 같은 열거 &lt;code&gt;enum&lt;/code&gt; 간에는 중요한 차이점 이 있습니다. C 의 &lt;code&gt;enum&lt;/code&gt; 은 대부분 &lt;code&gt;typedef&lt;/code&gt; 와 이름이 지정된 상수입니다. 즉, &lt;code&gt;enum&lt;/code&gt; 형 의 객체는 모든 정수 값을 보유 할 수 있습니다. 예를 들어, 이것은 종종 &lt;code&gt;C&lt;/code&gt; 의 비트 플래그에 사용됩니다 . 대조적으로 Rust의 C와 같은 열거 형은 법적으로 만 판별 가능한 값을 보유 할 수 있으며 다른 모든 것은 정의되지 않은 동작입니다. 따라서, C의 모델에 C와 같은 FFI에 열거를 사용하여 &lt;code&gt;enum&lt;/code&gt; 종종 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="9ff73fc74b538fd61456634251f2c1d94f2f06da" translate="yes" xml:space="preserve">
          <source>Warning: This book is incomplete. Documenting everything takes a while. See the &lt;a href=&quot;https://github.com/rust-lang-nursery/reference/issues&quot;&gt;GitHub issues&lt;/a&gt; for what is not documented in this book.</source>
          <target state="translated">경고 :이 책은 불완전합니다. 모든 것을 문서화하는 데는 시간이 걸립니다. 이 책에 설명되어 있지 않은 내용은 &lt;a href=&quot;https://github.com/rust-lang-nursery/reference/issues&quot;&gt;GitHub 문제&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1f7ce6b6e1db1f6b36ab4dbe1ad4b6e4aa8f982" translate="yes" xml:space="preserve">
          <source>Warning: This book is incomplete. Documenting everything takes a while. See the &lt;a href=&quot;https://github.com/rust-lang/reference/issues&quot;&gt;GitHub issues&lt;/a&gt; for what is not documented in this book.</source>
          <target state="translated">경고 :이 책은 불완전합니다. 모든 것을 문서화하는 데는 시간이 걸립니다. 이 책에 설명되지 않은 내용은 &lt;a href=&quot;https://github.com/rust-lang/reference/issues&quot;&gt;GitHub 문제&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6bfa37af5724b2422c63f7ff73c9837f336fb04" translate="yes" xml:space="preserve">
          <source>Warning: This is an example warning.</source>
          <target state="translated">경고 : 이것은 경고 예입니다.</target>
        </trans-unit>
        <trans-unit id="0411a6eec332f44831efbc3f9708608318be0eda" translate="yes" xml:space="preserve">
          <source>Warning: This pseudocode uses a naive algorithm that ignores overflow issues for the sake of clarity. To perform memory layout computations in actual code, use &lt;a href=&quot;../std/alloc/struct.layout&quot;&gt;&lt;code&gt;Layout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경고 :이 의사 코드는 명확성을 위해 오버플로 문제를 무시하는 순진한 알고리즘을 사용합니다. 실제 코드에서 메모리 레이아웃 계산을 수행하려면 &lt;a href=&quot;../std/alloc/struct.layout&quot;&gt; &lt;code&gt;Layout&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="aeae9f716fbecdbdacc2c0d2ad381e158829c6f8" translate="yes" xml:space="preserve">
          <source>Warning: Using &lt;code&gt;no_std&lt;/code&gt; does not prevent the standard library from being linked in. It is still valid to put &lt;code&gt;extern crate std;&lt;/code&gt; into the crate and dependencies can also link it in.</source>
          <target state="translated">경고 : &lt;code&gt;no_std&lt;/code&gt; 를 사용해도 표준 라이브러리가 연결되지 않습니다. &lt;code&gt;extern crate std;&lt;/code&gt; 를 넣는 것은 여전히 ​​유효합니다 . 상자에 의존하고 종속성도 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dfdf1e49306b2e83d806807f7999f1effda97a2" translate="yes" xml:space="preserve">
          <source>Warnings that show unsound behavior in the language or possibly confusing interactions of language features are in a special warning box.</source>
          <target state="translated">언어에서 소리가 나지 않거나 언어 기능의 혼란스러운 상호 작용을 나타내는 경고는 특별한 경고 상자에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1dc0af7f844bca35986a1e9209411ae68e0fca0" translate="yes" xml:space="preserve">
          <source>Was termination successful? Signal termination is not considered a success, and success is defined as a zero exit status.</source>
          <target state="translated">해지에 성공 했습니까? 신호 종료는 성공으로 간주되지 않으며 성공은 제로 종료 상태로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="ac046f0c3f07db034ba94ce5da784eb3ed007796" translate="yes" xml:space="preserve">
          <source>Ways Variables and Data Interact: Clone</source>
          <target state="translated">변수 및 데이터 상호 작용 방법 : 복제</target>
        </trans-unit>
        <trans-unit id="06457bc6418af723aa9f628283f0ba6362fe6a36" translate="yes" xml:space="preserve">
          <source>Ways Variables and Data Interact: Move</source>
          <target state="translated">변수 및 데이터 상호 작용 방법 : 이동</target>
        </trans-unit>
        <trans-unit id="aa61cf33de95859952369ab26063824f574acc8d" translate="yes" xml:space="preserve">
          <source>We add a &lt;code&gt;use minigrep::Config&lt;/code&gt; line to bring the &lt;code&gt;Config&lt;/code&gt; type from the library crate into the binary crate&amp;rsquo;s scope, and we prefix the &lt;code&gt;run&lt;/code&gt; function with our crate name. Now all the functionality should be connected and should work. Run the program with &lt;code&gt;cargo run&lt;/code&gt; and make sure everything works correctly.</source>
          <target state="translated">&lt;code&gt;use minigrep::Config&lt;/code&gt; 행을 추가 하여 &lt;code&gt;Config&lt;/code&gt; 유형을 라이브러리 상자에서 이진 상자 범위 로 가져오고 &lt;code&gt;run&lt;/code&gt; 함수 앞에 상자 이름을 붙입니다. 이제 모든 기능이 연결되어 작동해야합니다. &lt;code&gt;cargo run&lt;/code&gt; 프로그램을 실행 하고 모든 것이 올바르게 작동하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="703d634836fbf0167e7202dfb742abab520056ce" translate="yes" xml:space="preserve">
          <source>We add a default implementation for the &lt;code&gt;content&lt;/code&gt; method that returns an empty string slice. That means we don&amp;rsquo;t need to implement &lt;code&gt;content&lt;/code&gt; on the &lt;code&gt;Draft&lt;/code&gt; and &lt;code&gt;PendingReview&lt;/code&gt; structs. The &lt;code&gt;Published&lt;/code&gt; struct will override the &lt;code&gt;content&lt;/code&gt; method and return the value in &lt;code&gt;post.content&lt;/code&gt;.</source>
          <target state="translated">빈 문자열 슬라이스를 반환하는 &lt;code&gt;content&lt;/code&gt; 메소드에 대한 기본 구현을 추가합니다 . 즉 , &lt;code&gt;Draft&lt;/code&gt; 및 &lt;code&gt;PendingReview&lt;/code&gt; 구조체 에 &lt;code&gt;content&lt;/code&gt; 를 구현할 필요가 없습니다 . &lt;code&gt;Published&lt;/code&gt; 구조체는 우선합니다 &lt;code&gt;content&lt;/code&gt; 방법과에서 값을 반환 &lt;code&gt;post.content&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb16e5fa6efe59fc0c2272d7f438d5fdaa67503c" translate="yes" xml:space="preserve">
          <source>We add the &lt;code&gt;approve&lt;/code&gt; method to the &lt;code&gt;State&lt;/code&gt; trait and add a new struct that implements &lt;code&gt;State&lt;/code&gt;, the &lt;code&gt;Published&lt;/code&gt; state.</source>
          <target state="translated">우리는 추가 &lt;code&gt;approve&lt;/code&gt; 받는 방법을 &lt;code&gt;State&lt;/code&gt; 특성과 새로운 구조체를 추가 구현 &lt;code&gt;State&lt;/code&gt; 의 &lt;code&gt;Published&lt;/code&gt; 상태입니다.</target>
        </trans-unit>
        <trans-unit id="a8d45ae4bf5b9c5a466c7bb052250652de464f72" translate="yes" xml:space="preserve">
          <source>We add types to the &lt;code&gt;Fn&lt;/code&gt; trait bound to represent the types of the parameters and return values the closures must have to match this trait bound. In this case, our closure has a parameter of type &lt;code&gt;u32&lt;/code&gt; and returns a &lt;code&gt;u32&lt;/code&gt;, so the trait bound we specify is &lt;code&gt;Fn(u32) -&amp;gt; u32&lt;/code&gt;.</source>
          <target state="translated">매개 변수의 유형을 나타 내기 위해 &lt;code&gt;Fn&lt;/code&gt; 특성 바인딩 에 유형을 추가 하고 클로저가이 특성 바인딩과 일치해야하는 값을 반환합니다. 이 경우, 우리의 폐쇄 형의 매개 변수가 &lt;code&gt;u32&lt;/code&gt; 하고 반환 &lt;code&gt;u32&lt;/code&gt; 우리가 지정 바인딩 특성이 있으므로, &lt;code&gt;Fn(u32) -&amp;gt; u32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="874a35fb6fc23853895ba769fd48f7062f2b74c7" translate="yes" xml:space="preserve">
          <source>We also need a way to store the lines that contain our query string. For that, we can make a mutable vector before the &lt;code&gt;for&lt;/code&gt; loop and call the &lt;code&gt;push&lt;/code&gt; method to store a &lt;code&gt;line&lt;/code&gt; in the vector. After the &lt;code&gt;for&lt;/code&gt; loop, we return the vector, as shown in Listing 12-19.</source>
          <target state="translated">쿼리 문자열이 포함 된 줄을 저장하는 방법도 필요합니다. 이를 &lt;code&gt;for&lt;/code&gt; 루프 전에 가변 벡터를 만들고 &lt;code&gt;push&lt;/code&gt; 메서드를 호출 하여 벡터에 &lt;code&gt;line&lt;/code&gt; 을 저장할 수 있습니다 . 애프터 &lt;code&gt;for&lt;/code&gt; 12-19 목록과 같이 루프, 우리는 벡터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dd076b92dfab849e70346ed509304415baca5781" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t able to run this test and watch it fail because the test doesn&amp;rsquo;t even compile: the &lt;code&gt;search&lt;/code&gt; function doesn&amp;rsquo;t exist yet! So now we&amp;rsquo;ll add just enough code to get the test to compile and run by adding a definition of the &lt;code&gt;search&lt;/code&gt; function that always returns an empty vector, as shown in Listing 12-16. Then the test should compile and fail because an empty vector doesn&amp;rsquo;t match a vector containing the line &lt;code&gt;&quot;safe, fast, productive.&quot;&lt;/code&gt;</source>
          <target state="translated">이 테스트를 실행할 수 없으며 테스트가 컴파일되지 않았기 때문에 실패합니다. &lt;code&gt;search&lt;/code&gt; 기능이 아직 존재하지 않습니다! 이제 Listing 12-16에 표시된 것처럼 항상 빈 벡터를 반환하는 &lt;code&gt;search&lt;/code&gt; 함수 의 정의를 추가하여 테스트를 컴파일하고 실행할 수 있도록 충분한 코드를 추가 할 것이다 . 그런 다음 빈 벡터가 &lt;code&gt;&quot;safe, fast, productive.&quot;&lt;/code&gt; 줄을 포함하는 벡터와 일치하지 않으므로 테스트가 컴파일 및 실패해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3c085966e58da674ee452521f620be197a7ca241" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t able to use the variables &lt;code&gt;field_name&lt;/code&gt; and &lt;code&gt;field_value&lt;/code&gt; after they&amp;rsquo;ve been moved into the hash map with the call to &lt;code&gt;insert&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;field_name&lt;/code&gt; 및 &lt;code&gt;field_value&lt;/code&gt; 변수 는 &lt;code&gt;insert&lt;/code&gt; 호출로 해시 맵으로 이동 한 후에 는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1a29a26e7eebeedc17f2b05615992dc5203d17a2" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t allowed to use &lt;code&gt;v1_iter&lt;/code&gt; after the call to &lt;code&gt;sum&lt;/code&gt; because &lt;code&gt;sum&lt;/code&gt; takes ownership of the iterator we call it on.</source>
          <target state="translated">우리는 사용에 허용되지 않습니다 &lt;code&gt;v1_iter&lt;/code&gt; 에 대한 호출 후 &lt;code&gt;sum&lt;/code&gt; 때문에 &lt;code&gt;sum&lt;/code&gt; 우리에 전화 반복자의 소유권을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="03b218b584e4a8c7465d02aa1590edcd7370cd71" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t doing anything with the parameters to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;execute&lt;/code&gt;. Let&amp;rsquo;s implement the bodies of these functions with the behavior we want. To start, let&amp;rsquo;s think about &lt;code&gt;new&lt;/code&gt;. Earlier we chose an unsigned type for the &lt;code&gt;size&lt;/code&gt; parameter, because a pool with a negative number of threads makes no sense. However, a pool with zero threads also makes no sense, yet zero is a perfectly valid &lt;code&gt;usize&lt;/code&gt;. We&amp;rsquo;ll add code to check that &lt;code&gt;size&lt;/code&gt; is greater than zero before we return a &lt;code&gt;ThreadPool&lt;/code&gt; instance and have the program panic if it receives a zero by using the &lt;code&gt;assert!&lt;/code&gt; macro, as shown in Listing 20-13.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 및 &lt;code&gt;execute&lt;/code&gt; 에 대한 매개 변수로 아무것도 수행하지 않습니다 . 우리가 원하는 동작으로 이러한 함수의 본문을 구현합시다. 시작하려면 &lt;code&gt;new&lt;/code&gt; . 이전에 우리는 &lt;code&gt;size&lt;/code&gt; 매개 변수에 대해 서명되지 않은 유형을 선택했습니다 . 음수 스레드가있는 풀은 의미가 없기 때문입니다. 그러나 스레드가 0 인 풀도 의미가 없지만 0은 완벽하게 유효한 &lt;code&gt;usize&lt;/code&gt; 입니다. &lt;code&gt;ThreadPool&lt;/code&gt; 인스턴스를 반환하기 전에 &lt;code&gt;size&lt;/code&gt; 가 0보다 큰지 확인하는 코드를 추가 하고 &lt;code&gt;assert!&lt;/code&gt; 매크로 (Listing 20-13).</target>
        </trans-unit>
        <trans-unit id="69762a669aa35e1fe1f80ac259fc74112cee84ee" translate="yes" xml:space="preserve">
          <source>We attach data to each variant of the enum directly, so there is no need for an extra struct.</source>
          <target state="translated">우리는 열거 형의 각 변형에 데이터를 직접 첨부하므로 추가 구조체가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9efe92607cf53ea012fe63bd8f0d6e89b6731360" translate="yes" xml:space="preserve">
          <source>We bind &lt;code&gt;guess&lt;/code&gt; to the expression &lt;code&gt;guess.trim().parse()&lt;/code&gt;. The &lt;code&gt;guess&lt;/code&gt; in the expression refers to the original &lt;code&gt;guess&lt;/code&gt; that was a &lt;code&gt;String&lt;/code&gt; with the input in it. The &lt;code&gt;trim&lt;/code&gt; method on a &lt;code&gt;String&lt;/code&gt; instance will eliminate any whitespace at the beginning and end. Although &lt;code&gt;u32&lt;/code&gt; can contain only numerical characters, the user must press enter to satisfy &lt;code&gt;read_line&lt;/code&gt;. When the user presses enter, a newline character is added to the string. For example, if the user types 5 and presses enter, &lt;code&gt;guess&lt;/code&gt; looks like this: &lt;code&gt;5\n&lt;/code&gt;. The &lt;code&gt;\n&lt;/code&gt; represents &amp;ldquo;newline,&amp;rdquo; the result of pressing enter. The &lt;code&gt;trim&lt;/code&gt; method eliminates &lt;code&gt;\n&lt;/code&gt;, resulting in just &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;guess&lt;/code&gt; 을 표현식 &lt;code&gt;guess.trim().parse()&lt;/code&gt; 바인딩 합니다. 표현식 의 &lt;code&gt;guess&lt;/code&gt; 은 입력 이 포함 된 &lt;code&gt;String&lt;/code&gt; 원래 &lt;code&gt;guess&lt;/code&gt; 을 나타냅니다 . &lt;code&gt;String&lt;/code&gt; 인스턴스 의 &lt;code&gt;trim&lt;/code&gt; 메소드 는 시작과 끝에서 공백을 제거합니다. &lt;code&gt;u32&lt;/code&gt; 는 숫자 만 포함 할 수 있지만 , 사용자는 &lt;code&gt;read_line&lt;/code&gt; 을 충족시키기 위해 enter를 눌러야 합니다. 사용자가 Enter 키를 누르면 줄 바꿈 문자가 문자열에 추가됩니다. 예를 들어, 사용자가 5를 입력하고 Enter 키를 누르면 다음과 같이 &lt;code&gt;guess&lt;/code&gt; . &lt;code&gt;5\n&lt;/code&gt; . &lt;code&gt;\n&lt;/code&gt; Enter 키를 누른 결과 인 &quot;newline&quot;을 나타냅니다. &lt;code&gt;trim&lt;/code&gt; 방법 제거해 &lt;code&gt;\n&lt;/code&gt; 단지의 결과로 &lt;code&gt;5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ddf963103dba15efd7153809c5942b206394546" translate="yes" xml:space="preserve">
          <source>We bring &lt;code&gt;std::io::prelude&lt;/code&gt; into scope to get access to certain traits that let us read from and write to the stream. In the &lt;code&gt;for&lt;/code&gt; loop in the &lt;code&gt;main&lt;/code&gt; function, instead of printing a message that says we made a connection, we now call the new &lt;code&gt;handle_connection&lt;/code&gt; function and pass the &lt;code&gt;stream&lt;/code&gt; to it.</source>
          <target state="translated">&lt;code&gt;std::io::prelude&lt;/code&gt; 를 범위 내로 가져 와서 스트림에서 읽고 쓸 수있는 특정 특성에 액세스 할 수 있습니다. &lt;code&gt;main&lt;/code&gt; 함수 의 &lt;code&gt;for&lt;/code&gt; 루프에서 연결을했다는 메시지를 인쇄하는 대신 새로운 &lt;code&gt;handle_connection&lt;/code&gt; 함수를 호출 하고 &lt;code&gt;stream&lt;/code&gt; 을 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="240ed8bfedc49b8fc597eafa1de3c89f98bf93c0" translate="yes" xml:space="preserve">
          <source>We call having references as function parameters &lt;em&gt;borrowing&lt;/em&gt;. As in real life, if a person owns something, you can borrow it from them. When you&amp;rsquo;re done, you have to give it back.</source>
          <target state="translated">우리는 함수 매개 변수를 &lt;em&gt;빌리&lt;/em&gt; 는 참조라고 부릅니다 . 실생활에서와 같이, 사람이 무언가를 소유하고 있다면 그들에게서 빌릴 수 있습니다. 완료되면 돌려 주어야합니다.</target>
        </trans-unit>
        <trans-unit id="d947f39cbc67a29eb7ea69291febb53660aa4608" translate="yes" xml:space="preserve">
          <source>We call the &lt;code&gt;as_ref&lt;/code&gt; method on the &lt;code&gt;Option&lt;/code&gt; because we want a reference to the value inside the &lt;code&gt;Option&lt;/code&gt; rather than ownership of the value. Because &lt;code&gt;state&lt;/code&gt; is an &lt;code&gt;Option&amp;lt;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt;, when we call &lt;code&gt;as_ref&lt;/code&gt;, an &lt;code&gt;Option&amp;lt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; is returned. If we didn&amp;rsquo;t call &lt;code&gt;as_ref&lt;/code&gt;, we would get an error because we can&amp;rsquo;t move &lt;code&gt;state&lt;/code&gt; out of the borrowed &lt;code&gt;&amp;amp;self&lt;/code&gt; of the function parameter.</source>
          <target state="translated">우리 는 값의 소유권이 아닌 &lt;code&gt;Option&lt;/code&gt; 내부의 값에 대한 참조를 원하기 때문에 &lt;code&gt;Option&lt;/code&gt; 에서 &lt;code&gt;as_ref&lt;/code&gt; 메소드를 호출합니다 . 때문에 &lt;code&gt;state&lt;/code&gt; 입니다 &lt;code&gt;Option&amp;lt;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; 우리가 호출 할 때, &lt;code&gt;as_ref&lt;/code&gt; , &lt;code&gt;Option&amp;lt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; 반환됩니다. &lt;code&gt;as_ref&lt;/code&gt; 를 호출하지 않으면 함수 매개 변수 의 빌린 &lt;code&gt;&amp;amp;self&lt;/code&gt; 에서 &lt;code&gt;state&lt;/code&gt; 를 이동할 수 없으므로 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="5d77e6f9c521f22991317e685c1445407461715a" translate="yes" xml:space="preserve">
          <source>We can also conditionally implement a trait for any type that implements another trait. Implementations of a trait on any type that satisfies the trait bounds are called &lt;em&gt;blanket implementations&lt;/em&gt; and are extensively used in the Rust standard library. For example, the standard library implements the &lt;code&gt;ToString&lt;/code&gt; trait on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait. The &lt;code&gt;impl&lt;/code&gt; block in the standard library looks similar to this code:</source>
          <target state="translated">또한 다른 특성을 구현하는 모든 유형의 특성을 조건부로 구현할 수도 있습니다. 특성 한계를 충족시키는 모든 유형의 특성의 &lt;em&gt;구현을 담요 구현&lt;/em&gt; 이라고 하며 Rust 표준 라이브러리에서 광범위하게 사용됩니다. 예를 들어 표준 라이브러리 는 &lt;code&gt;Display&lt;/code&gt; 특성 을 구현하는 모든 유형 에서 &lt;code&gt;ToString&lt;/code&gt; 특성을 구현합니다 . 표준 라이브러리 의 &lt;code&gt;impl&lt;/code&gt; 블록은 다음 코드와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="bb52f4cd6ad33cd891f08333028285ede3e7db5b" translate="yes" xml:space="preserve">
          <source>We can also construct relative paths that begin in the parent module by using &lt;code&gt;super&lt;/code&gt; at the start of the path. This is like starting a filesystem path with the &lt;code&gt;..&lt;/code&gt; syntax. Why would we want to do this?</source>
          <target state="translated">경로 시작시 &lt;code&gt;super&lt;/code&gt; 를 사용하여 상위 모듈에서 시작하는 상대 경로를 구성 할 수도 있습니다 . 이것은 &lt;code&gt;..&lt;/code&gt; 구문 으로 파일 시스템 경로를 시작하는 것과 같습니다 . 왜 우리가 이것을하고 싶습니까?</target>
        </trans-unit>
        <trans-unit id="778ae68ad9feeabdfe80f409dafc0d4bb361e3fe" translate="yes" xml:space="preserve">
          <source>We can also define structs to use a generic type parameter in one or more fields using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; syntax. Listing 10-6 shows how to define a &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct to hold &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; coordinate values of any type.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 구문을 사용하여 하나 이상의 필드에서 일반 유형 매개 변수를 사용하도록 구조체를 정의 할 수도 있습니다 . 코드 10-6은 모든 유형의 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 좌표 값 을 보유 하도록 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 구조체 를 정의하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="4e08f30b1a9d52c6dfe2c35efab8e3fc06f66951" translate="yes" xml:space="preserve">
          <source>We can also destructure with literal values as part of the struct pattern rather than creating variables for all the fields. Doing so allows us to test some of the fields for particular values while creating variables to destructure the other fields.</source>
          <target state="translated">모든 필드에 대한 변수를 생성하는 대신 구조체 패턴의 일부로 리터럴 값으로 구조를 변경할 수도 있습니다. 그렇게하면 특정 필드에 대해 일부 필드를 테스트하면서 다른 필드를 구조화하기위한 변수를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea3e2d4c2367c79cd84990de2bc0f7a727763cdc" translate="yes" xml:space="preserve">
          <source>We can also iterate over mutable references to each element in a mutable vector in order to make changes to all the elements. The &lt;code&gt;for&lt;/code&gt; loop in Listing 8-9 will add &lt;code&gt;50&lt;/code&gt; to each element.</source>
          <target state="translated">또한 모든 요소를 ​​변경하기 위해 변경 가능한 벡터의 각 요소에 대한 변경 가능한 참조를 반복 할 수 있습니다. 목록 8-9 의 &lt;code&gt;for&lt;/code&gt; 루프는 각 요소 에 &lt;code&gt;50&lt;/code&gt; 을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="ee5cf07fc2a2f75074aafe8e551ff5bba6cab992" translate="yes" xml:space="preserve">
          <source>We can also run tests for one particular crate in a workspace from the top-level directory by using the &lt;code&gt;-p&lt;/code&gt; flag and specifying the name of the crate we want to test:</source>
          <target state="translated">&lt;code&gt;-p&lt;/code&gt; 플래그 를 사용하고 테스트하려는 상자의 이름을 지정 하여 최상위 디렉토리의 작업 공간에서 특정 상자에 대한 테스트를 실행할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3efbe53d0f34cdeceddc81b7e977c9d7e0e4e394" translate="yes" xml:space="preserve">
          <source>We can also specify more than one trait bound. Say we wanted &lt;code&gt;notify&lt;/code&gt; to use display formatting on &lt;code&gt;item&lt;/code&gt; as well as the &lt;code&gt;summarize&lt;/code&gt; method: we specify in the &lt;code&gt;notify&lt;/code&gt; definition that &lt;code&gt;item&lt;/code&gt; must implement both &lt;code&gt;Display&lt;/code&gt; and &lt;code&gt;Summary&lt;/code&gt;. We can do so using the &lt;code&gt;+&lt;/code&gt; syntax:</source>
          <target state="translated">하나 이상의 특성 바운드를 지정할 수도 있습니다. 우리가 원하는 말 &lt;code&gt;notify&lt;/code&gt; 에 서식 사용 디스플레이 &lt;code&gt;item&lt;/code&gt; 뿐만 아니라 &lt;code&gt;summarize&lt;/code&gt; (가)에서 우리는 지정 방법 &lt;code&gt;notify&lt;/code&gt; 것을 정의 &lt;code&gt;item&lt;/code&gt; 모두 구현해야 &lt;code&gt;Display&lt;/code&gt; 및 &lt;code&gt;Summary&lt;/code&gt; . &lt;code&gt;+&lt;/code&gt; 구문을 사용하면됩니다 :</target>
        </trans-unit>
        <trans-unit id="3cc038561d9ea414d06a0435ac0f33d9a3ec4206" translate="yes" xml:space="preserve">
          <source>We can also take advantage of iterators in the &lt;code&gt;search&lt;/code&gt; function in our I/O project, which is reproduced here in Listing 13-28 as it was in Listing 12-19:</source>
          <target state="translated">또한 I / O 프로젝트 의 &lt;code&gt;search&lt;/code&gt; 기능에서 반복자를 활용할 수 있는데,이 목록은 Listing 12-19에서와 같이 Listing 13-28에서 재현된다.</target>
        </trans-unit>
        <trans-unit id="27743a857d8c37964df0ba1bbc48632a920fe5c1" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;_&lt;/code&gt; inside another pattern to ignore just part of a value, for example, when we want to test for only part of a value but have no use for the other parts in the corresponding code we want to run. Listing 18-18 shows code responsible for managing a setting&amp;rsquo;s value. The business requirements are that the user should not be allowed to overwrite an existing customization of a setting but can unset the setting and give it a value if it is currently unset.</source>
          <target state="translated">또한 다른 패턴 안에 &lt;code&gt;_&lt;/code&gt; 를 사용 하여 값의 일부만 무시할 수 있습니다 (예 : 값의 일부만 테스트하려고하지만 실행하려는 해당 코드에서 다른 부분은 사용하지 않는 경우). 목록 18-18은 설정 값을 관리하는 코드를 보여줍니다. 비즈니스 요구 사항은 사용자가 기존 설정의 사용자 지정을 덮어 쓸 수 없어야하지만 설정을 해제하고 현재 설정되어 있지 않은 경우 값을 제공 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a9a0da5e69869676d450fe480d1807e1cd097a3d" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;extern&lt;/code&gt; to create an interface that allows other languages to call Rust functions. Instead of an &lt;code&gt;extern&lt;/code&gt; block, we add the &lt;code&gt;extern&lt;/code&gt; keyword and specify the ABI to use just before the &lt;code&gt;fn&lt;/code&gt; keyword. We also need to add a &lt;code&gt;#[no_mangle]&lt;/code&gt; annotation to tell the Rust compiler not to mangle the name of this function. &lt;em&gt;Mangling&lt;/em&gt; is when a compiler changes the name we&amp;rsquo;ve given a function to a different name that contains more information for other parts of the compilation process to consume but is less human readable. Every programming language compiler mangles names slightly differently, so for a Rust function to be nameable by other languages, we must disable the Rust compiler&amp;rsquo;s name mangling.</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; 을 사용하여 다른 언어가 Rust 함수를 호출 할 수있는 인터페이스를 만들 수도 있습니다 . &lt;code&gt;extern&lt;/code&gt; 블록 대신 &lt;code&gt;extern&lt;/code&gt; 키워드를 추가 하고 &lt;code&gt;fn&lt;/code&gt; 키워드 바로 앞에 사용할 ABI를 지정합니다 . 또한 Rust 컴파일러에게이 함수의 이름을 &lt;code&gt;#[no_mangle]&lt;/code&gt; 하지 말라고 알리려면 # [no_mangle] 주석 을 추가해야 합니다. &lt;em&gt;맹 글링&lt;/em&gt;컴파일러가 이름을 변경하면 컴파일 프로세스의 다른 부분에 대해 더 많은 정보를 포함하지만 사람이 읽을 수없는 다른 정보로 함수에 이름을 부여했습니다. 모든 프로그래밍 언어 컴파일러는 이름을 약간 다르게 조정하므로 Rust 함수의 이름을 다른 언어로 지정할 수 있으려면 Rust 컴파일러의 이름 조작을 비활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c62477778083229abf76f408542398691e71468" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;pub&lt;/code&gt; to designate structs and enums as public, but there are a few extra details. If we use &lt;code&gt;pub&lt;/code&gt; before a struct definition, we make the struct public, but the struct&amp;rsquo;s fields will still be private. We can make each field public or not on a case-by-case basis. In Listing 7-9, we&amp;rsquo;ve defined a public &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; struct with a public &lt;code&gt;toast&lt;/code&gt; field but a private &lt;code&gt;seasonal_fruit&lt;/code&gt; field. This models the case in a restaurant where the customer can pick the type of bread that comes with a meal, but the chef decides which fruit accompanies the meal based on what&amp;rsquo;s in season and in stock. The available fruit changes quickly, so customers can&amp;rsquo;t choose the fruit or even see which fruit they&amp;rsquo;ll get.</source>
          <target state="translated">&lt;code&gt;pub&lt;/code&gt; 을 사용 하여 구조체와 열거 형을 공용으로 지정할 수도 있지만 몇 가지 추가 정보가 있습니다. 구조체 정의 전에 &lt;code&gt;pub&lt;/code&gt; 를 사용 하면 구조체를 공개하지만 구조체의 필드는 여전히 비공개입니다. 각 필드를 사례별로 공개하거나 공개하지 않을 수 있습니다. 목록 7-9에서 우리는 공공 정의한 &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; 공개와 구조체 &lt;code&gt;toast&lt;/code&gt; 가 아니고 개인 &lt;code&gt;seasonal_fruit&lt;/code&gt; 을들. 고객이 식사와 함께 제공되는 빵 종류를 선택할 수있는 식당에서 사례를 모델링하지만 요리사는 계절과 재고에 따라 어떤 과일이 식사와 함께 제공되는지 결정합니다. 사용 가능한 과일이 빠르게 바뀌므로 고객은 과일을 선택하거나 과일을 얻을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="58de59dd22e3e6fc1f10ec4a02d3f8e6ab27da48" translate="yes" xml:space="preserve">
          <source>We can also use patterns in closure parameter lists in the same way as in function parameter lists, because closures are similar to functions, as discussed in Chapter 13.</source>
          <target state="translated">클로저는 13 장에서 설명한 것처럼 함수와 비슷하기 때문에 함수 파라미터 목록과 같은 방식으로 클로저 파라미터 목록에 패턴을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7925e7cd27a3e1f56c26966752834adef5ab34e2" translate="yes" xml:space="preserve">
          <source>We can also use patterns to destructure structs, enums, tuples, and references to use different parts of these values. Let&amp;rsquo;s walk through each value.</source>
          <target state="translated">패턴을 사용하여 구조체, 열거 형, 튜플 및 참조를 재구성하여 이러한 값의 다른 부분을 사용할 수 있습니다. 각 값을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="76f3cf0eca098985427ff4b99e4f8800ead6e68e" translate="yes" xml:space="preserve">
          <source>We can also use the &lt;code&gt;impl Trait&lt;/code&gt; syntax in the return position to return a value of some type that implements a trait, as shown here:</source>
          <target state="translated">리턴 위치에서 &lt;code&gt;impl Trait&lt;/code&gt; 구문을 사용하여 다음 과 같이 특성을 구현하는 일부 유형의 값을 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05cebebac68137cbc376dfa219f26ac621d46c69" translate="yes" xml:space="preserve">
          <source>We can also use the function &lt;code&gt;String::from&lt;/code&gt; to create a &lt;code&gt;String&lt;/code&gt; from a string literal. The code in Listing 8-13 is equivalent to the code from Listing 8-12 that uses &lt;code&gt;to_string&lt;/code&gt;.</source>
          <target state="translated">우리는 또한 기능을 사용할 수있는 &lt;code&gt;String::from&lt;/code&gt; 만들 &lt;code&gt;String&lt;/code&gt; 문자열 리터럴에서합니다. Listing 8-13의 코드는 &lt;code&gt;to_string&lt;/code&gt; 을 사용하는 Listing 8-12의 코드와 동일하다 .</target>
        </trans-unit>
        <trans-unit id="75923eaf7777a97564f4dc777548d05d59942c29" translate="yes" xml:space="preserve">
          <source>We can also use underscores in multiple places within one pattern to ignore particular values. Listing 18-19 shows an example of ignoring the second and fourth values in a tuple of five items.</source>
          <target state="translated">특정 패턴을 무시하기 위해 한 패턴 내에서 여러 위치에 밑줄을 사용할 수도 있습니다. Listing 18-19는 5 개 항목의 튜플에서 두 번째 및 네 번째 값을 무시하는 예를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="122a72509f3b2907e160e4a188856f5df6c2c85d" translate="yes" xml:space="preserve">
          <source>We can build a project using &lt;code&gt;cargo build&lt;/code&gt; or &lt;code&gt;cargo check&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cargo build&lt;/code&gt; 또는 &lt;code&gt;cargo check&lt;/code&gt; 사용하여 프로젝트를 구축 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="838e973f1067e2cb1c1db7ba741330fcbc0ac60a" translate="yes" xml:space="preserve">
          <source>We can build a project using &lt;code&gt;cargo build&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cargo build&lt;/code&gt; 사용하여 프로젝트를 빌드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce64501de0b20285b589ca7f67901cf5515ef19d" translate="yes" xml:space="preserve">
          <source>We can build a project without producing a binary to check for errors using &lt;code&gt;cargo check&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cargo check&lt;/code&gt; 사용하여 오류를 확인하기 위해 바이너리를 생성하지 않고 프로젝트를 구축 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="809d50064260569cdd4712de50a56577f9d92391" translate="yes" xml:space="preserve">
          <source>We can build and run a project in one step using &lt;code&gt;cargo run&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cargo run&lt;/code&gt; 사용하여 한 단계로 프로젝트를 빌드하고 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b242aca9d7e4caf52b300cdcd3d90184f5c24f79" translate="yes" xml:space="preserve">
          <source>We can call any function we&amp;rsquo;ve defined by entering its name followed by a set of parentheses. Because &lt;code&gt;another_function&lt;/code&gt; is defined in the program, it can be called from inside the &lt;code&gt;main&lt;/code&gt; function. Note that we defined &lt;code&gt;another_function&lt;/code&gt;&lt;em&gt;after&lt;/em&gt; the &lt;code&gt;main&lt;/code&gt; function in the source code; we could have defined it before as well. Rust doesn&amp;rsquo;t care where you define your functions, only that they&amp;rsquo;re defined somewhere.</source>
          <target state="translated">이름 뒤에 일련의 괄호를 입력하여 정의한 함수를 호출 할 수 있습니다. 프로그램에서 &lt;code&gt;another_function&lt;/code&gt; 이 정의 되었으므로 &lt;code&gt;main&lt;/code&gt; 함수 내부에서 호출 할 수 있습니다 . 우리가 정의합니다 &lt;code&gt;another_function&lt;/code&gt; 을&lt;em&gt;한 후 &lt;/em&gt; &lt;code&gt;main&lt;/code&gt; 소스 코드의 기능; 우리는 그것을 전에도 정의 할 수있었습니다. Rust는 함수를 정의하는 위치를 신경 쓰지 않고 어딘가에 정의되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a8abea5de761553bb0b42e8a7f618aa89a49c8ee" translate="yes" xml:space="preserve">
          <source>We can call the &lt;code&gt;hello&lt;/code&gt; function with a string slice as an argument, such as &lt;code&gt;hello(&quot;Rust&quot;);&lt;/code&gt; for example. Deref coercion makes it possible to call &lt;code&gt;hello&lt;/code&gt; with a reference to a value of type &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt;, as shown in Listing 15-12:</source>
          <target state="translated">&lt;code&gt;hello(&quot;Rust&quot;);&lt;/code&gt; 와 같이 문자열 슬라이스를 인자로 사용 하여 &lt;code&gt;hello&lt;/code&gt; 함수를 호출 할 수 있습니다 . 예를 들어. 참조 강제 변환을 사용하면 목록 15-12에 표시된대로 &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 유형의 값에 대한 참조로 &lt;code&gt;hello&lt;/code&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f891b91f54057660d908040351a0ff29848041a" translate="yes" xml:space="preserve">
          <source>We can call the &lt;code&gt;next&lt;/code&gt; method on iterators directly; Listing 13-15 demonstrates what values are returned from repeated calls to &lt;code&gt;next&lt;/code&gt; on the iterator created from the vector.</source>
          <target state="translated">반복자 에서 &lt;code&gt;next&lt;/code&gt; 메소드를 직접 호출 할 수 있습니다. Listing 13-15는 반복 호출 에서 벡터에서 생성 된 반복자 에서 &lt;code&gt;next&lt;/code&gt; 값으로 리턴되는 값을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="8ef978ad4b55aca46bfe72e7cdc27105e5aa535e" translate="yes" xml:space="preserve">
          <source>We can change the definition of the &lt;code&gt;List&lt;/code&gt; enum in Listing 15-2 and the usage of the &lt;code&gt;List&lt;/code&gt; in Listing 15-3 to the code in Listing 15-5, which will compile:</source>
          <target state="translated">Listing 15-2 의 &lt;code&gt;List&lt;/code&gt; 열거 형 정의 와 Listing 15-3 의 &lt;code&gt;List&lt;/code&gt; 사용법을 Listing 15-5의 코드로 변경하면 컴파일된다.</target>
        </trans-unit>
        <trans-unit id="5aa55fe5a8ea6e7664f5b8f2b891ac8638dc6a08" translate="yes" xml:space="preserve">
          <source>We can combine &lt;code&gt;str&lt;/code&gt; with all kinds of pointers: for example, &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;/code&gt; or &lt;code&gt;Rc&amp;lt;str&amp;gt;&lt;/code&gt;. In fact, you&amp;rsquo;ve seen this before but with a different dynamically sized type: traits. Every trait is a dynamically sized type we can refer to by using the name of the trait. In Chapter 17 in the &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; section, we mentioned that to use traits as trait objects, we must put them behind a pointer, such as &lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt; or &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; (&lt;code&gt;Rc&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; would work too).</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 을 모든 종류의 포인터와 결합 할 수 있습니다 ( 예 : &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;Rc&amp;lt;str&amp;gt;&lt;/code&gt; . 사실, 이전에는이 ​​점을 보았지만 동적으로 크기가 다른 유형 인 특성이 있습니다. 모든 특성은 특성의 이름을 사용하여 참조 할 수있는 동적 크기 유형입니다. 17 장 &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;다른 유형의 값을 허용하는 특성 개체 사용&amp;rdquo;&lt;/a&gt; 섹션에서 특성을 특성 개체로 사용하려면 &lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt; 또는 &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; ( &lt;code&gt;Rc&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; 도 작동합니다).</target>
        </trans-unit>
        <trans-unit id="ede179db3525aa1a779f8adeec565b9391c18d6a" translate="yes" xml:space="preserve">
          <source>We can create instances of each of the two variants of &lt;code&gt;IpAddrKind&lt;/code&gt; like this:</source>
          <target state="translated">&lt;code&gt;IpAddrKind&lt;/code&gt; 과 같이 IpAddrKind 의 두 가지 변형 각각의 인스턴스를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6778f0bff382e98f9e7494c1dbfeeb8d0d54aa88" translate="yes" xml:space="preserve">
          <source>We can create slices using a range within brackets by specifying &lt;code&gt;[starting_index..ending_index]&lt;/code&gt;, where &lt;code&gt;starting_index&lt;/code&gt; is the first position in the slice and &lt;code&gt;ending_index&lt;/code&gt; is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to &lt;code&gt;ending_index&lt;/code&gt; minus &lt;code&gt;starting_index&lt;/code&gt;. So in the case of &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt;, &lt;code&gt;world&lt;/code&gt; would be a slice that contains a pointer to the 7th byte (counting from 1) of &lt;code&gt;s&lt;/code&gt; with a length value of 5.</source>
          <target state="translated">&lt;code&gt;[starting_index..ending_index]&lt;/code&gt; 를 지정하여 괄호 안의 범위를 사용하여 슬라이스를 만들 수 있습니다 . 여기서 &lt;code&gt;starting_index&lt;/code&gt; 는 슬라이스의 첫 번째 위치이고 &lt;code&gt;ending_index&lt;/code&gt; 는 슬라이스 의 마지막 위치보다 하나 더 많습니다. 내부적으로 슬라이스 데이터 구조는 슬라이스의 시작 위치와 길이를 저장하며, 이는 &lt;code&gt;ending_index&lt;/code&gt; 빼기 &lt;code&gt;starting_index&lt;/code&gt; 에 해당합니다 . 따라서 &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt; , &lt;code&gt;world&lt;/code&gt; 는 길이 값이 5 인 &lt;code&gt;s&lt;/code&gt; 의 7 번째 바이트 (1에서 계산)에 대한 포인터를 포함하는 슬라이스입니다 .</target>
        </trans-unit>
        <trans-unit id="9f3fa459dfc1535461c3584787a472521830592f" translate="yes" xml:space="preserve">
          <source>We can create slices using a range within brackets by specifying &lt;code&gt;[starting_index..ending_index]&lt;/code&gt;, where &lt;code&gt;starting_index&lt;/code&gt; is the first position in the slice and &lt;code&gt;ending_index&lt;/code&gt; is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to &lt;code&gt;ending_index&lt;/code&gt; minus &lt;code&gt;starting_index&lt;/code&gt;. So in the case of &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt;, &lt;code&gt;world&lt;/code&gt; would be a slice that contains a pointer to the 7th byte of &lt;code&gt;s&lt;/code&gt; with a length value of 5.</source>
          <target state="translated">&lt;code&gt;[starting_index..ending_index]&lt;/code&gt; 를 지정하여 괄호 안에 범위를 사용하여 슬라이스를 만들 수 있습니다 . 여기서 &lt;code&gt;starting_index&lt;/code&gt; 는 슬라이스의 첫 번째 위치이고 &lt;code&gt;ending_index&lt;/code&gt; 는 슬라이스 의 마지막 위치보다 하나 더 큽니다. 내부적으로 슬라이스 데이터 구조는 슬라이스의 시작 위치와 길이를 저장하며, 이는 &lt;code&gt;ending_index&lt;/code&gt; 에서 &lt;code&gt;starting_index&lt;/code&gt; 를 뺀 값에 해당합니다 . 따라서 &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt; , &lt;code&gt;world&lt;/code&gt; 의 7 바이트에 대한 포인터가 포함 된 슬라이스 것 &lt;code&gt;s&lt;/code&gt; 5의 길이 값을.</target>
        </trans-unit>
        <trans-unit id="480beb4f2fbdbd05ea0df3529278b68c75d63e3d" translate="yes" xml:space="preserve">
          <source>We can express this concept in code by defining an &lt;code&gt;IpAddrKind&lt;/code&gt; enumeration and listing the possible kinds an IP address can be, &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt;. These are known as the &lt;em&gt;variants&lt;/em&gt; of the enum:</source>
          <target state="translated">&lt;code&gt;IpAddrKind&lt;/code&gt; 열거 를 정의 하고 IP 주소가 &lt;code&gt;V4&lt;/code&gt; 및 &lt;code&gt;V6&lt;/code&gt; 일 수있는 가능한 종류를 나열 하여이 개념을 코드로 표현할 수 있습니다 . 이들은 열거 형 의 &lt;em&gt;변형&lt;/em&gt; 으로 알려져 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76dc799b358f8c432443282c326218cb637140a7" translate="yes" xml:space="preserve">
          <source>We can express this concept in code by defining an &lt;code&gt;IpAddrKind&lt;/code&gt; enumeration and listing the possible kinds an IP address can be, &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt;. These are the variants of the enum:</source>
          <target state="translated">&lt;code&gt;IpAddrKind&lt;/code&gt; 열거 형 을 정의 하고 가능한 IP 주소 종류 ( &lt;code&gt;V4&lt;/code&gt; 및 &lt;code&gt;V6&lt;/code&gt; )를 나열 하여이 개념을 코드로 표현할 수 있습니다 . 다음은 열거 형의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="71fae2fe3370b32c9db5f4eaf59056e914aed565" translate="yes" xml:space="preserve">
          <source>We can fix the error in the code from Listing 4-6 with just a small tweak:</source>
          <target state="translated">Listing 4-6의 코드에서 약간의 수정만으로 오류를 수정할 수있다.</target>
        </trans-unit>
        <trans-unit id="e5578ac88136133dd874daa05323286bc4dd633b" translate="yes" xml:space="preserve">
          <source>We can fix the problem of the spawned thread not getting to run, or not getting to run completely, by saving the return value of &lt;code&gt;thread::spawn&lt;/code&gt; in a variable. The return type of &lt;code&gt;thread::spawn&lt;/code&gt; is &lt;code&gt;JoinHandle&lt;/code&gt;. A &lt;code&gt;JoinHandle&lt;/code&gt; is an owned value that, when we call the &lt;code&gt;join&lt;/code&gt; method on it, will wait for its thread to finish. Listing 16-2 shows how to use the &lt;code&gt;JoinHandle&lt;/code&gt; of the thread we created in Listing 16-1 and call &lt;code&gt;join&lt;/code&gt; to make sure the spawned thread finishes before &lt;code&gt;main&lt;/code&gt; exits:</source>
          <target state="translated">&lt;code&gt;thread::spawn&lt;/code&gt; 의 반환 값을 변수 에 저장하여 스폰 된 스레드가 실행되지 않거나 완전히 실행되지 않는 문제를 해결할 수 있습니다 . &lt;code&gt;thread::spawn&lt;/code&gt; 의 반환 유형 은 &lt;code&gt;JoinHandle&lt;/code&gt; 입니다. &lt;code&gt;JoinHandle&lt;/code&gt; 는 우리가 전화 할 때, 소유 한 값 &lt;code&gt;join&lt;/code&gt; 그것을 방법, 마무리의 스레드를 기다립니다. Listing 16-2는 Listing 16-1에서 만든 스레드 의 &lt;code&gt;JoinHandle&lt;/code&gt; 을 사용하고 &lt;code&gt;join&lt;/code&gt; 을 호출 하여 &lt;code&gt;main&lt;/code&gt; 종료 전에 생성 된 스레드가 완료되도록 하는 방법을 보여준다 .</target>
        </trans-unit>
        <trans-unit id="22158c42f561db77e36e5c0f1f6b412465276779" translate="yes" xml:space="preserve">
          <source>We can get a value out of the hash map by providing its key to the &lt;code&gt;get&lt;/code&gt; method, as shown in Listing 8-23.</source>
          <target state="translated">목록 8-23에 표시된 것처럼 &lt;code&gt;get&lt;/code&gt; 메소드에 키를 제공하여 해시 맵에서 값을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7da9dd9f69b66e99d2bf7be9bcdfd0fb6edf1903" translate="yes" xml:space="preserve">
          <source>We can grow a &lt;code&gt;String&lt;/code&gt; by using the &lt;code&gt;push_str&lt;/code&gt; method to append a string slice, as shown in Listing 8-15.</source>
          <target state="translated">우리는 성장할 수있는 &lt;code&gt;String&lt;/code&gt; 사용하여 &lt;code&gt;push_str&lt;/code&gt; 의 8-15 목록과 같이 문자열 슬라이스를 추가하는 방법을.</target>
        </trans-unit>
        <trans-unit id="30087969975a89cb5c986ff322b7e98d082b7a13" translate="yes" xml:space="preserve">
          <source>We can implement methods on structs and enums (as we did in Chapter 5) and use generic types in their definitions, too. Listing 10-9 shows the &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct we defined in Listing 10-6 with a method named &lt;code&gt;x&lt;/code&gt; implemented on it.</source>
          <target state="translated">struct와 enum에 메소드를 구현할 수 있고 (5 장에서했던 것처럼) 정의에 일반 타입을 사용할 수도 있습니다. Listing 10-9는 Listing 10-6에서 정의한 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 구조체를 &lt;code&gt;x&lt;/code&gt; 라는 메소드로 구현 한 것이다.</target>
        </trans-unit>
        <trans-unit id="1416b44fa4e60a1b91e773a8e3e18fa14181606e" translate="yes" xml:space="preserve">
          <source>We can include an &lt;code&gt;else&lt;/code&gt; with an &lt;code&gt;if let&lt;/code&gt;. The block of code that goes with the &lt;code&gt;else&lt;/code&gt; is the same as the block of code that would go with the &lt;code&gt;_&lt;/code&gt; case in the &lt;code&gt;match&lt;/code&gt; expression that is equivalent to the &lt;code&gt;if let&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt;. Recall the &lt;code&gt;Coin&lt;/code&gt; enum definition in Listing 6-4, where the &lt;code&gt;Quarter&lt;/code&gt; variant also held a &lt;code&gt;UsState&lt;/code&gt; value. If we wanted to count all non-quarter coins we see while also announcing the state of the quarters, we could do that with a &lt;code&gt;match&lt;/code&gt; expression like this:</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 과 함께 &lt;code&gt;else&lt;/code&gt; 를 포함시킬 수 있습니다 . 로가는 코드의 블록 &lt;code&gt;else&lt;/code&gt; 와 함께 갈 것 코드 블록과 동일 &lt;code&gt;_&lt;/code&gt; 의 경우 &lt;code&gt;match&lt;/code&gt; 받는 것과 동일 표현 &lt;code&gt;if let&lt;/code&gt; 와 &lt;code&gt;else&lt;/code&gt; . &lt;code&gt;Quarter&lt;/code&gt; 변형이 &lt;code&gt;UsState&lt;/code&gt; 값을 보유한 Listing 6-4 의 &lt;code&gt;Coin&lt;/code&gt; 열거 형 정의를 상기 하자 . 쿼터가 아닌 모든 코인을 세고 쿼터의 상태를 알리면서 다음과 같은 &lt;code&gt;match&lt;/code&gt; 표현식을 사용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="66061395d6ec2f861be65b1f6e172defc0d75534" translate="yes" xml:space="preserve">
          <source>We can instead return a &lt;code&gt;Result&lt;/code&gt; value that will contain a &lt;code&gt;Config&lt;/code&gt; instance in the successful case and will describe the problem in the error case. When &lt;code&gt;Config::new&lt;/code&gt; is communicating to &lt;code&gt;main&lt;/code&gt;, we can use the &lt;code&gt;Result&lt;/code&gt; type to signal there was a problem. Then we can change &lt;code&gt;main&lt;/code&gt; to convert an &lt;code&gt;Err&lt;/code&gt; variant into a more practical error for our users without the surrounding text about &lt;code&gt;thread 'main'&lt;/code&gt; and &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; that a call to &lt;code&gt;panic!&lt;/code&gt; causes.</source>
          <target state="translated">대신 성공적인 경우 &lt;code&gt;Config&lt;/code&gt; 인스턴스를 포함 하고 오류 경우의 문제점을 설명 하는 &lt;code&gt;Result&lt;/code&gt; 값을 리턴 할 수 있습니다 . &lt;code&gt;Config::new&lt;/code&gt; 가 &lt;code&gt;main&lt;/code&gt; 과 통신 할 때 &lt;code&gt;Result&lt;/code&gt; 유형을 사용하여 문제가 있음을 알릴 수 있습니다 . 그런 다음 &lt;code&gt;main&lt;/code&gt; 을 변경 하여 &lt;code&gt;thread 'main'&lt;/code&gt; 및 &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; 에 대한 주변 텍스트없이 &lt;code&gt;panic!&lt;/code&gt; 대한 호출 없이 &lt;code&gt;Err&lt;/code&gt; 변형을보다 실용적인 오류로 변환 할 수 있습니다 ! 원인.</target>
        </trans-unit>
        <trans-unit id="bb29fed4b14f1816c3bd75cc8c7b8985f01f0348" translate="yes" xml:space="preserve">
          <source>We can iterate over each key/value pair in a hash map in a similar manner as we do with vectors, using a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프를 사용하여 벡터와 비슷한 방식으로 해시 맵에서 각 키 / 값 쌍을 반복 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44d33f5a0b00602e0254a6df2e134266a90e2aa9" translate="yes" xml:space="preserve">
          <source>We can mix, match, and nest destructuring patterns in even more complex ways. The following example shows a complicated destructure where we nest structs and tuples inside a tuple and destructure all the primitive values out:</source>
          <target state="translated">더 복잡한 방식으로 파괴 패턴을 혼합, 일치 및 중첩 할 수 있습니다. 다음 예제는 구조체와 튜플을 튜플 내부에 중첩하고 모든 기본 값을 구성 해제하는 복잡한 구조화를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a2535d8585e0b8b29c1374b49286a87170bfb973" translate="yes" xml:space="preserve">
          <source>We can now add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;add-one/src/lib.rs&lt;/em&gt; file, and building the whole workspace by running &lt;code&gt;cargo build&lt;/code&gt; in the &lt;em&gt;add&lt;/em&gt; directory will bring in and compile the &lt;code&gt;rand&lt;/code&gt; crate:</source>
          <target state="translated">이제 &lt;code&gt;use rand;&lt;/code&gt; 추가 할 수 있습니다 . 받는 &lt;em&gt;추가 한 / SRC / lib.rs의&lt;/em&gt; 파일을 실행하여 전체 작업 공간을 구축 &lt;code&gt;cargo build&lt;/code&gt; 에 &lt;em&gt;추가&lt;/em&gt; 로 가져오고 컴파일 디렉토리 &lt;code&gt;rand&lt;/code&gt; 상자를 :</target>
        </trans-unit>
        <trans-unit id="af6ef7240c4fe2205d00598530304a1736702c02" translate="yes" xml:space="preserve">
          <source>We can pass the name of any test function to &lt;code&gt;cargo test&lt;/code&gt; to run only that test:</source>
          <target state="translated">모든 테스트 기능의 이름을 &lt;code&gt;cargo test&lt;/code&gt; 에 전달하여 해당 테스트 만 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="681f8bb7bce5dc24c780df89cf3cfd8148dcbad5" translate="yes" xml:space="preserve">
          <source>We can probably guess what this is doing: &amp;ldquo;bind the value &lt;code&gt;5&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;; then make a copy of the value in &lt;code&gt;x&lt;/code&gt; and bind it to &lt;code&gt;y&lt;/code&gt;.&amp;rdquo; We now have two variables, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and both equal &lt;code&gt;5&lt;/code&gt;. This is indeed what is happening, because integers are simple values with a known, fixed size, and these two &lt;code&gt;5&lt;/code&gt; values are pushed onto the stack.</source>
          <target state="translated">우리는 아마도 이것이 무엇을하고 있는지 추측 할 수있을 것입니다.&amp;ldquo;값 &lt;code&gt;5&lt;/code&gt; 를 &lt;code&gt;x&lt;/code&gt; 에 바인딩 ; 그런 다음 &lt;code&gt;x&lt;/code&gt; 에 값을 복사 하여 &lt;code&gt;y&lt;/code&gt; 에 바인딩합니다 .&amp;rdquo; 이제 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 두 변수가 있고 모두 &lt;code&gt;5&lt;/code&gt; 입니다. 정수는 알려진 고정 크기의 단순 값이고이 두 &lt;code&gt;5&lt;/code&gt; 개의 값이 스택으로 푸시 되기 때문에 실제로 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="adf5d763de0af108f5d4c46398e531c69df86785" translate="yes" xml:space="preserve">
          <source>We can represent the same concept in a more concise way using just an enum, rather than an enum inside a struct, by putting data directly into each enum variant. This new definition of the &lt;code&gt;IpAddr&lt;/code&gt; enum says that both &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt; variants will have associated &lt;code&gt;String&lt;/code&gt; values:</source>
          <target state="translated">데이터를 각 열거 형 변형에 직접 넣어서 구조체 내부의 열거 형이 아닌 열거 형 만 사용하여 동일한 개념을 더 간결한 방식으로 나타낼 수 있습니다. &lt;code&gt;IpAddr&lt;/code&gt; 열거 형 에 대한이 새로운 정의에 따르면 &lt;code&gt;V4&lt;/code&gt; 및 &lt;code&gt;V6&lt;/code&gt; 변형은 모두 연관된 &lt;code&gt;String&lt;/code&gt; 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="76b94955b3f9249c5ee98ad0f6852e07d511a594" translate="yes" xml:space="preserve">
          <source>We can rewrite the code in Listing 15-6 to use a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; instead of a reference; the dereference operator will work as shown in Listing 15-7:</source>
          <target state="translated">참조 대신 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용하도록 Listing 15-6의 코드를 다시 작성할 수있다 . 역 참조 연산자는 목록 15-7에 표시된대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7ea000b0b28ece0260d2f2bea2366776a6be260f" translate="yes" xml:space="preserve">
          <source>We can see that the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; has an initial reference count of 1; then each time we call &lt;code&gt;clone&lt;/code&gt;, the count goes up by 1. When &lt;code&gt;c&lt;/code&gt; goes out of scope, the count goes down by 1. We don&amp;rsquo;t have to call a function to decrease the reference count like we have to call &lt;code&gt;Rc::clone&lt;/code&gt; to increase the reference count: the implementation of the &lt;code&gt;Drop&lt;/code&gt; trait decreases the reference count automatically when an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope.</source>
          <target state="translated">우리가 볼 수있는 그 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 에 &lt;code&gt;a&lt;/code&gt; 1의 초기 참조 횟수를 가지고; &lt;code&gt;clone&lt;/code&gt; 을 호출 할 때마다 카운트가 1 씩 증가합니다. &lt;code&gt;c&lt;/code&gt; 가 범위를 벗어나면 카운트가 1만큼 감소합니다. &lt;code&gt;Rc::clone&lt;/code&gt; 를 호출해야하는 것처럼 참조 카운트를 줄이기 위해 함수를 호출 할 필요는 없습니다. 클론 은 참조 카운트를 증가시킵니다 : &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 값이 범위를 벗어날 때 &lt;code&gt;Drop&lt;/code&gt; 특성 의 구현은 참조 카운트를 자동으로 감소시킵니다 .</target>
        </trans-unit>
        <trans-unit id="a214ec338df6341cdb5d296dddcacc3063fdedc3" translate="yes" xml:space="preserve">
          <source>We can see the value we actually got in the test output, which would help us debug what happened instead of what we were expecting to happen.</source>
          <target state="translated">테스트 결과에서 실제로 얻은 값을 볼 수 있는데, 예상했던 결과 대신 발생한 결과를 디버그하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="5e778fc8d2caec156d83fcf7afdb2aae2c506e66" translate="yes" xml:space="preserve">
          <source>We can specify part of a test name, and any test whose name matches that value will be run. For example, because two of our tests&amp;rsquo; names contain &lt;code&gt;add&lt;/code&gt;, we can run those two by running &lt;code&gt;cargo test add&lt;/code&gt;:</source>
          <target state="translated">테스트 이름의 일부를 지정할 수 있으며 해당 값과 이름이 같은 테스트가 실행됩니다. 예를 들어 테스트 이름 중 두 개에 &lt;code&gt;add&lt;/code&gt; 가 포함되어 있으므로 &lt;code&gt;cargo test add&lt;/code&gt; 를 실행하여 두 개를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c477c81d4998e0c2db0cd1cb4d1eb52e5c21091" translate="yes" xml:space="preserve">
          <source>We can still do better than this! Since these are all strings, we can use &lt;code&gt;From::from&lt;/code&gt;:</source>
          <target state="translated">우리는 여전히 이것보다 더 잘할 수 있습니다! 이들은 모두 문자열이므로 &lt;code&gt;From::from&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f5820640c7aec271923f9535645ba49661f2f13" translate="yes" xml:space="preserve">
          <source>We can still run a particular integration test function by specifying the test function&amp;rsquo;s name as an argument to &lt;code&gt;cargo test&lt;/code&gt;. To run all the tests in a particular integration test file, use the &lt;code&gt;--test&lt;/code&gt; argument of &lt;code&gt;cargo test&lt;/code&gt; followed by the name of the file:</source>
          <target state="translated">테스트 함수의 이름을 &lt;code&gt;cargo test&lt;/code&gt; 의 인수로 지정하여 특정 통합 테스트 함수를 계속 실행할 수 있습니다 . 특정 통합 테스트 파일에서 모든 테스트를 실행하려면 &lt;code&gt;cargo test&lt;/code&gt; 의 &lt;code&gt;--test&lt;/code&gt; 인수와 파일 이름을 차례로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9a8c8ef2737df71d8388e134a7c0ccb41beb3655" translate="yes" xml:space="preserve">
          <source>We can take another small step to improve the &lt;code&gt;parse_config&lt;/code&gt; function further. At the moment, we&amp;rsquo;re returning a tuple, but then we immediately break that tuple into individual parts again. This is a sign that perhaps we don&amp;rsquo;t have the right abstraction yet.</source>
          <target state="translated">&lt;code&gt;parse_config&lt;/code&gt; 함수를 더 향상시키기 위해 또 다른 작은 단계를 취할 수 있습니다 . 현재 튜플을 반환하지만 즉시 해당 튜플을 개별 부분으로 다시 나눕니다. 이것은 아마도 우리가 아직 올바른 추상화를 가지고 있지 않다는 신호입니다.</target>
        </trans-unit>
        <trans-unit id="5b506bd5bc9447453d0ff0e70736267fe699653e" translate="yes" xml:space="preserve">
          <source>We can use &lt;code&gt;LineWriter&lt;/code&gt; to write one line at a time, significantly reducing the number of actual writes to the file.</source>
          <target state="translated">&lt;code&gt;LineWriter&lt;/code&gt; 를 사용 하여 한 번에 한 줄씩 쓸 수 있으므로 파일에 대한 실제 쓰기 횟수가 크게 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="589393eead9827eb0357a452c622a307b85e9161" translate="yes" xml:space="preserve">
          <source>We can use a nested path at any level in a path, which is useful when combining two &lt;code&gt;use&lt;/code&gt; statements that share a subpath. For example, Listing 7-19 shows two &lt;code&gt;use&lt;/code&gt; statements: one that brings &lt;code&gt;std::io&lt;/code&gt; into scope and one that brings &lt;code&gt;std::io::Write&lt;/code&gt; into scope.</source>
          <target state="translated">경로의 어느 수준에서나 중첩 된 경로를 사용할 수 있으며, 이는 하위 경로를 공유하는 두 개의 &lt;code&gt;use&lt;/code&gt; 문을 결합 할 때 유용합니다 . 예를 들어, 목록 7-19는 &lt;code&gt;std::io&lt;/code&gt; 를 범위로 가져오고 &lt;code&gt;std::io::Write&lt;/code&gt; 를 범위 로 가져 오는 두 가지 &lt;code&gt;use&lt;/code&gt; 설명을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="ef8af218d727ce9d8232f2296725304b83f601ff" translate="yes" xml:space="preserve">
          <source>We can use generics to create definitions for items like function signatures or structs, which we can then use with many different concrete data types. Let&amp;rsquo;s first look at how to define functions, structs, enums, and methods using generics. Then we&amp;rsquo;ll discuss how generics affect code performance.</source>
          <target state="translated">제네릭을 사용하여 함수 시그너처 또는 구조체와 같은 항목에 대한 정의를 생성 할 수 있으며,이를 통해 다양한 콘크리트 데이터 유형과 함께 사용할 수 있습니다. 먼저 제네릭을 사용하여 함수, 구조체, 열거 형 및 메서드를 정의하는 방법을 살펴 보겠습니다. 그런 다음 제네릭이 코드 성능에 미치는 영향에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e8dc1033c290aa4d0f8f436900ce0a06f8d56ae8" translate="yes" xml:space="preserve">
          <source>We can write tests that assert, for example, that when we pass &lt;code&gt;3&lt;/code&gt; to the &lt;code&gt;add_two&lt;/code&gt; function, the returned value is &lt;code&gt;5&lt;/code&gt;. We can run these tests whenever we make changes to our code to make sure any existing correct behavior has not changed.</source>
          <target state="translated">예를 들어 &lt;code&gt;add_two&lt;/code&gt; 함수에 &lt;code&gt;3&lt;/code&gt; 을 전달할 때 반환되는 값은 &lt;code&gt;5&lt;/code&gt; 라는 테스트를 작성할 수 있습니다 . 코드가 변경 될 때마다 이러한 테스트를 실행하여 기존의 올바른 동작이 변경되지 않았는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9385857c424a38be102f8d4b72e9e3b61729bf2a" translate="yes" xml:space="preserve">
          <source>We can write this code in a more concise way using iterator adaptor methods. Doing so also lets us avoid having a mutable intermediate &lt;code&gt;results&lt;/code&gt; vector. The functional programming style prefers to minimize the amount of mutable state to make code clearer. Removing the mutable state might enable a future enhancement to make searching happen in parallel, because we wouldn&amp;rsquo;t have to manage concurrent access to the &lt;code&gt;results&lt;/code&gt; vector. Listing 13-29 shows this change:</source>
          <target state="translated">반복자 어댑터 메소드를 사용하여이 코드를보다 간결하게 작성할 수 있습니다. 그렇게하면 변경 가능한 중간 &lt;code&gt;results&lt;/code&gt; 벡터를 피할 수 있습니다 . 함수형 프로그래밍 스타일은 코드를 더 명확하게하기 위해 변경 가능한 상태의 양을 최소화하는 것을 선호합니다. 변경 가능한 상태를 제거하면 &lt;code&gt;results&lt;/code&gt; 벡터에 대한 동시 액세스를 관리 할 필요가 없으므로 검색 기능이 동시에 향상 될 수 있도록 향후 향상 될 수 있습니다 . Listing 13-29는 이러한 변화를 보여준다 :</target>
        </trans-unit>
        <trans-unit id="e88d0bfc51700a22588d6147632aec4291d1a85c" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t disable the automatic insertion of &lt;code&gt;drop&lt;/code&gt; when a value goes out of scope, and we can&amp;rsquo;t call the &lt;code&gt;drop&lt;/code&gt; method explicitly. So, if we need to force a value to be cleaned up early, we can use the &lt;code&gt;std::mem::drop&lt;/code&gt; function.</source>
          <target state="translated">값이 범위를 벗어나면 &lt;code&gt;drop&lt;/code&gt; 자동 삽입을 비활성화 할 수 없으며 &lt;code&gt;drop&lt;/code&gt; 메서드를 명시 적으로 호출 할 수 없습니다 . 따라서 값을 일찍 정리해야하는 경우 &lt;code&gt;std::mem::drop&lt;/code&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5eb55f0f3c1815005ce6026f04d2d3d7695261ea" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t do the same with functions; if we try with the following example, our code won&amp;rsquo;t compile:</source>
          <target state="translated">우리는 함수로 똑같이 할 수 없습니다. 다음 예제를 시도하면 코드가 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="004573547af483d7764ab7d46060e1c54dc0773a" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t implement this function using only safe Rust. An attempt might look something like Listing 19-5, which won&amp;rsquo;t compile. For simplicity, we&amp;rsquo;ll implement &lt;code&gt;split_at_mut&lt;/code&gt; as a function rather than a method and only for slices of &lt;code&gt;i32&lt;/code&gt; values rather than for a generic type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">안전한 녹만 사용하여이 기능을 구현할 수 없습니다. 시도는 컴파일되지 않는 Listing 19-5와 같다. 간단하게하기 위해 &lt;code&gt;split_at_mut&lt;/code&gt; 를 메소드가 아닌 함수로 구현 하고 일반 유형이 아닌 &lt;code&gt;i32&lt;/code&gt; 값의 슬라이스에 대해서만 구현 합니다. &lt;code&gt;T&lt;/code&gt; 가 합니다.</target>
        </trans-unit>
        <trans-unit id="582ce9f7ce322bfba577c502da3fd8ad049c4d4a" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t modify the &lt;code&gt;MockMessenger&lt;/code&gt; to keep track of the messages, because the &lt;code&gt;send&lt;/code&gt; method takes an immutable reference to &lt;code&gt;self&lt;/code&gt;. We also can&amp;rsquo;t take the suggestion from the error text to use &lt;code&gt;&amp;amp;mut self&lt;/code&gt; instead, because then the signature of &lt;code&gt;send&lt;/code&gt; wouldn&amp;rsquo;t match the signature in the &lt;code&gt;Messenger&lt;/code&gt; trait definition (feel free to try and see what error message you get).</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; 메소드는 &lt;code&gt;self&lt;/code&gt; 에 대한 불변의 참조를 &lt;code&gt;MockMessenger&lt;/code&gt; 때문에 메시지를 추적하기 위해 MockMessenger 를 수정할 수 없습니다 . 또한 &lt;code&gt;send&lt;/code&gt; 의 서명이 &lt;code&gt;Messenger&lt;/code&gt; 특성 정의 의 서명과 일치하지 않기 때문에 오류 텍스트에서 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 대신 사용하라는 제안을 취할 수 없습니다 (자신의 오류 메시지를 확인하고 시도하십시오).</target>
        </trans-unit>
        <trans-unit id="475ed34c630883783c7ce91b1cbb038a7124429f" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t specify the names of multiple tests in this way; only the first value given to &lt;code&gt;cargo test&lt;/code&gt; will be used. But there is a way to run multiple tests.</source>
          <target state="translated">이 방법으로 여러 테스트의 이름을 지정할 수 없습니다. &lt;code&gt;cargo test&lt;/code&gt; 주어진 첫 번째 값만 사용됩니다. 그러나 여러 테스트를 실행할 수있는 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e237fd577614eaca9ca57bd30e8d152c826a8f6a" translate="yes" xml:space="preserve">
          <source>We cannot create an object of type &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;Foo&lt;/code&gt; since in this case &lt;code&gt;Self&lt;/code&gt; would not be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;Foo&lt;/code&gt; 유형의 오브젝트를 작성할 수 없습니다 .이 경우 &lt;code&gt;Self&lt;/code&gt; 는 그렇지 않습니다. &lt;code&gt;Sized&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="44f6533d2b54ba2e8cfd6b4cbb63ec903b4d8b3d" translate="yes" xml:space="preserve">
          <source>We chose &lt;code&gt;usize&lt;/code&gt; as the type of the &lt;code&gt;size&lt;/code&gt; parameter, because we know that a negative number of threads doesn&amp;rsquo;t make any sense. We also know we&amp;rsquo;ll use this 4 as the number of elements in a collection of threads, which is what the &lt;code&gt;usize&lt;/code&gt; type is for, as discussed in the &lt;a href=&quot;ch03-02-data-types#integer-types&quot;&gt;&amp;ldquo;Integer Types&amp;rdquo;&lt;/a&gt; section of Chapter 3.</source>
          <target state="translated">음수의 스레드가 의미가 없다는 것을 알기 때문에 &lt;code&gt;size&lt;/code&gt; 매개 변수 의 유형으로 &lt;code&gt;usize&lt;/code&gt; 를 선택했습니다 . 또한이 정수를 스레드 컬렉션의 요소 수로 사용한다는 것을 알고 있습니다. 이는 &lt;a href=&quot;ch03-02-data-types#integer-types&quot;&gt;&amp;ldquo;정수 유형&amp;rdquo;&lt;/a&gt; 에서 설명한대로 사용 유형 의 &lt;code&gt;usize&lt;/code&gt; 입니다. 장 3 절.</target>
        </trans-unit>
        <trans-unit id="7895e1f893882c82193d8df3d4f2286271194e94" translate="yes" xml:space="preserve">
          <source>We clone the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; and store that in &lt;code&gt;branch&lt;/code&gt;, meaning the &lt;code&gt;Node&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; now has two owners: &lt;code&gt;leaf&lt;/code&gt; and &lt;code&gt;branch&lt;/code&gt;. We can get from &lt;code&gt;branch&lt;/code&gt; to &lt;code&gt;leaf&lt;/code&gt; through &lt;code&gt;branch.children&lt;/code&gt;, but there&amp;rsquo;s no way to get from &lt;code&gt;leaf&lt;/code&gt; to &lt;code&gt;branch&lt;/code&gt;. The reason is that &lt;code&gt;leaf&lt;/code&gt; has no reference to &lt;code&gt;branch&lt;/code&gt; and doesn&amp;rsquo;t know they&amp;rsquo;re related. We want &lt;code&gt;leaf&lt;/code&gt; to know that &lt;code&gt;branch&lt;/code&gt; is its parent. We&amp;rsquo;ll do that next.</source>
          <target state="translated">우리 는 &lt;code&gt;leaf&lt;/code&gt; 에 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 를 복제하고 그것을 &lt;code&gt;branch&lt;/code&gt; 에 저장합니다 . 이는 &lt;code&gt;leaf&lt;/code&gt; 의 &lt;code&gt;Node&lt;/code&gt; 에 이제 &lt;code&gt;leaf&lt;/code&gt; 와 &lt;code&gt;branch&lt;/code&gt; 의 두 소유자가 있음을 의미합니다 . 우리는에서 얻을 수있는 &lt;code&gt;branch&lt;/code&gt; 에 &lt;code&gt;leaf&lt;/code&gt; 을 통해 &lt;code&gt;branch.children&lt;/code&gt; 만에서 얻을 수있는 방법은 없습니다 &lt;code&gt;leaf&lt;/code&gt; 으로 &lt;code&gt;branch&lt;/code&gt; . 그 이유는 &lt;code&gt;leaf&lt;/code&gt; 은 &lt;code&gt;branch&lt;/code&gt; 대한 언급이 없으며 관련이 있다는 것을 모르기 때문입니다. 우리는 &lt;code&gt;leaf&lt;/code&gt; 이 &lt;code&gt;branch&lt;/code&gt; 가 부모 라는 것을 알고 싶어 합니다. 다음에 해보겠습니다.</target>
        </trans-unit>
        <trans-unit id="05f1667dd3106c8abc956cd0b899e6b8c6b816c1" translate="yes" xml:space="preserve">
          <source>We could also use the &lt;code&gt;vec!&lt;/code&gt; macro to make a vector of two integers or a vector of five string slices. We wouldn&amp;rsquo;t be able to use a function to do the same because we wouldn&amp;rsquo;t know the number or type of values up front.</source>
          <target state="translated">우리는 또한 &lt;code&gt;vec!&lt;/code&gt; 사용할 수 있습니다 ! 2 개의 정수로 구성된 벡터 또는 5 개의 문자열 슬라이스로 구성된 벡터를 만드는 매크로입니다. 값의 수 또는 유형을 미리 알 수 없으므로 함수를 사용하여 동일한 작업을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f6d258f9750395523193a3f14c9610f257a272c0" translate="yes" xml:space="preserve">
          <source>We could change the definition of &lt;code&gt;Cons&lt;/code&gt; to hold references instead, but then we would have to specify lifetime parameters. By specifying lifetime parameters, we would be specifying that every element in the list will live at least as long as the entire list. The borrow checker wouldn&amp;rsquo;t let us compile &lt;code&gt;let a = Cons(10, &amp;amp;Nil);&lt;/code&gt; for example, because the temporary &lt;code&gt;Nil&lt;/code&gt; value would be dropped before &lt;code&gt;a&lt;/code&gt; could take a reference to it.</source>
          <target state="translated">대신 참조를 보유하도록 &lt;code&gt;Cons&lt;/code&gt; 의 정의를 변경할 수 있지만 수명 매개 변수를 지정해야합니다. 수명 매개 변수를 지정하면 목록의 모든 요소가 최소한 전체 목록만큼 지속되도록 지정합니다. 빌리 체커는 컴파일을 &lt;code&gt;let a = Cons(10, &amp;amp;Nil);&lt;/code&gt; 하지 않습니다 let a = Cons (10, &amp;amp; Nil); 임시 때문에 예를 들어, &lt;code&gt;Nil&lt;/code&gt; 값이 전에 삭제 될 것입니다 &lt;code&gt;a&lt;/code&gt; 는 에 대한 참조 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d05429b5e9fe586f9bb77f649f37d1e197f6a7f0" translate="yes" xml:space="preserve">
          <source>We could do more here! If you want to continue enhancing this project, here are some ideas:</source>
          <target state="translated">우리는 여기서 더 할 수 있습니다! 이 프로젝트를 계속 향상 시키려면 다음과 같은 아이디어가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fefbbccf770b8f30f2dc978bcfe9a114e9fbb7e" translate="yes" xml:space="preserve">
          <source>We could have called &lt;code&gt;a.clone()&lt;/code&gt; rather than &lt;code&gt;Rc::clone(&amp;amp;a)&lt;/code&gt;, but Rust&amp;rsquo;s convention is to use &lt;code&gt;Rc::clone&lt;/code&gt; in this case. The implementation of &lt;code&gt;Rc::clone&lt;/code&gt; doesn&amp;rsquo;t make a deep copy of all the data like most types&amp;rsquo; implementations of &lt;code&gt;clone&lt;/code&gt; do. The call to &lt;code&gt;Rc::clone&lt;/code&gt; only increments the reference count, which doesn&amp;rsquo;t take much time. Deep copies of data can take a lot of time. By using &lt;code&gt;Rc::clone&lt;/code&gt; for reference counting, we can visually distinguish between the deep-copy kinds of clones and the kinds of clones that increase the reference count. When looking for performance problems in the code, we only need to consider the deep-copy clones and can disregard calls to &lt;code&gt;Rc::clone&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Rc::clone(&amp;amp;a)&lt;/code&gt; &lt;code&gt;a.clone()&lt;/code&gt; 대신 a.clone () 을 호출 할 수 있지만 Rust의 규칙은 이 경우 &lt;code&gt;Rc::clone&lt;/code&gt; 을 사용하는 것 입니다. &lt;code&gt;Rc::clone&lt;/code&gt; 의 구현은 대부분의 유형의 &lt;code&gt;clone&lt;/code&gt; 구현처럼 모든 데이터의 딥 카피를 만들지는 않습니다 . &lt;code&gt;Rc::clone&lt;/code&gt; 호출 하면 참조 횟수 만 증가하므로 시간이 많이 걸리지 않습니다. 깊은 데이터 사본에는 많은 시간이 걸릴 수 있습니다. 참조 카운트에 &lt;code&gt;Rc::clone&lt;/code&gt; 을 사용 하면 딥 카피 종류의 클론과 참조 횟수를 증가시키는 클론의 종류를 시각적으로 구별 할 수 있습니다. 코드에서 성능 문제를 찾을 때 딥 카피 클론 만 고려하면되고 호출은 무시해도됩니다 &lt;code&gt;Rc::clone&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eca83f4ee5c90ab6cc276aa537db842341cf4adb" translate="yes" xml:space="preserve">
          <source>We could manage the &lt;code&gt;String&lt;/code&gt; data in a number of different ways, but the easiest, though somewhat inefficient, route is to call the &lt;code&gt;clone&lt;/code&gt; method on the values. This will make a full copy of the data for the &lt;code&gt;Config&lt;/code&gt; instance to own, which takes more time and memory than storing a reference to the string data. However, cloning the data also makes our code very straightforward because we don&amp;rsquo;t have to manage the lifetimes of the references; in this circumstance, giving up a little performance to gain simplicity is a worthwhile trade-off.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 데이터는 여러 가지 방법으로 관리 할 수 있지만 가장 비효율적이지만 가장 효율적인 방법은 값에 대해 &lt;code&gt;clone&lt;/code&gt; 메서드 를 호출하는 것 입니다. 이렇게하면 &lt;code&gt;Config&lt;/code&gt; 인스턴스 의 데이터 전체 를 소유하게되므로 문자열 데이터에 대한 참조를 저장하는 것보다 시간과 메모리가 더 많이 걸립니다. 그러나 데이터를 복제하면 참조의 수명을 관리 할 필요가 없으므로 코드가 매우 간단 해집니다. 이 상황에서 단순성을 얻기 위해 약간의 성능을 포기하는 것은 가치있는 트레이드 오프입니다.</target>
        </trans-unit>
        <trans-unit id="c509f8d6e89246f38539832c75fb48cf6c5ba2b0" translate="yes" xml:space="preserve">
          <source>We could restructure the workout program in many ways. First, we&amp;rsquo;ll try extracting the duplicated call to the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function into a variable, as shown in Listing 13-4.</source>
          <target state="translated">운동 프로그램을 여러 가지 방식으로 재구성 할 수있었습니다. 먼저, Listing 13-4에서 보여 지듯이, &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 함수에 대한 복제 된 호출을 변수로 추출해 보도록하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="b747f40b6d976ebdbf66a032afb6e45dd5554fe8" translate="yes" xml:space="preserve">
          <source>We could, for example, implement methods only on &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; instances rather than on &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; instances with any generic type. In Listing 10-10 we use the concrete type &lt;code&gt;f32&lt;/code&gt;, meaning we don&amp;rsquo;t declare any types after &lt;code&gt;impl&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 제네릭 형식의 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 인스턴스가 아닌 &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; 인스턴스 에서만 메서드를 구현할 수 있습니다 . Listing 10-10에서 우리는 구체적 타입 &lt;code&gt;f32&lt;/code&gt; 를 사용한다 . 즉, &lt;code&gt;impl&lt;/code&gt; 뒤에 어떤 타입도 선언하지 않는다 .</target>
        </trans-unit>
        <trans-unit id="dc540cd4ac8553c761d432c98ece0eb2c93f00d9" translate="yes" xml:space="preserve">
          <source>We covered a lot in this chapter! Now that you know about generic type parameters, traits and trait bounds, and generic lifetime parameters, you&amp;rsquo;re ready to write code without repetition that works in many different situations. Generic type parameters let you apply the code to different types. Traits and trait bounds ensure that even though the types are generic, they&amp;rsquo;ll have the behavior the code needs. You learned how to use lifetime annotations to ensure that this flexible code won&amp;rsquo;t have any dangling references. And all of this analysis happens at compile time, which doesn&amp;rsquo;t affect runtime performance!</source>
          <target state="translated">이 장에서는 많은 내용을 다루었습니다! 이제 일반 유형 매개 변수, 특성 및 특성 경계 및 일반 수명 매개 변수에 대해 알게되었으므로 다양한 상황에서 작동하는 반복없이 코드를 작성할 수 있습니다. 제네릭 형식 매개 변수를 사용하면 코드를 다른 형식에 적용 할 수 있습니다. 특성 및 특성 범위는 유형이 일반이지만 코드에 필요한 동작을 갖도록합니다. 이 유연한 코드에 매달려있는 참조가 없도록 평생 주석을 사용하는 방법을 배웠습니다. 이 모든 분석은 컴파일 타임에 수행되며 런타임 성능에는 영향을 미치지 않습니다!</target>
        </trans-unit>
        <trans-unit id="eb3fa7151412c41431bd677558948e5410e9f15a" translate="yes" xml:space="preserve">
          <source>We create a &lt;code&gt;counter&lt;/code&gt; variable to hold an &lt;code&gt;i32&lt;/code&gt; inside a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;, as we did in Listing 16-12. Next, we create 10 threads by iterating over a range of numbers. We use &lt;code&gt;thread::spawn&lt;/code&gt; and give all the threads the same closure, one that moves the counter into the thread, acquires a lock on the &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; by calling the &lt;code&gt;lock&lt;/code&gt; method, and then adds 1 to the value in the mutex. When a thread finishes running its closure, &lt;code&gt;num&lt;/code&gt; will go out of scope and release the lock so another thread can acquire it.</source>
          <target state="translated">Listing 16-12에서와 같이 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 안에 &lt;code&gt;i32&lt;/code&gt; 를 보유하는 &lt;code&gt;counter&lt;/code&gt; 변수를 만든다 . 다음으로, 다양한 숫자를 반복하여 10 개의 스레드를 만듭니다. 우리가 사용하는 &lt;code&gt;thread::spawn&lt;/code&gt; 하고 모든 스레드에게 같은 폐쇄, 스레드에 카운터를 이동에 잠금을 획득 한 줄 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 호출에 의해 &lt;code&gt;lock&lt;/code&gt; 방법을 다음 뮤텍스의 값에 1을 추가합니다. 스레드가 클로저 실행을 마치면 &lt;code&gt;num&lt;/code&gt; 이 범위를 벗어나고 다른 스레드가이를 획득 할 수 있도록 잠금을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="213f26aca0645a1c53b1bbcf5c4371b8d84d7d68" translate="yes" xml:space="preserve">
          <source>We create a &lt;em&gt;tests&lt;/em&gt; directory at the top level of our project directory, next to &lt;em&gt;src&lt;/em&gt;. Cargo knows to look for integration test files in this directory. We can then make as many test files as we want to in this directory, and Cargo will compile each of the files as an individual crate.</source>
          <target state="translated">프로젝트 디렉토리의 최상위 레벨 인 &lt;em&gt;src&lt;/em&gt; 옆에 &lt;em&gt;tests&lt;/em&gt; 디렉토리를 만듭니다 . Cargo는이 디렉토리에서 통합 테스트 파일을 찾습니다. 그런 다음이 디렉토리에서 원하는만큼 테스트 파일을 만들 수 있으며, Cargo는 각 파일을 개별 상자로 컴파일합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d1f90968f355a976c1446423d6bfb4b640e2c12" translate="yes" xml:space="preserve">
          <source>We create a new channel using the &lt;code&gt;mpsc::channel&lt;/code&gt; function; &lt;code&gt;mpsc&lt;/code&gt; stands for &lt;em&gt;multiple producer, single consumer&lt;/em&gt;. In short, the way Rust&amp;rsquo;s standard library implements channels means a channel can have multiple &lt;em&gt;sending&lt;/em&gt; ends that produce values but only one &lt;em&gt;receiving&lt;/em&gt; end that consumes those values. Imagine multiple streams flowing together into one big river: everything sent down any of the streams will end up in one river at the end. We&amp;rsquo;ll start with a single producer for now, but we&amp;rsquo;ll add multiple producers when we get this example working.</source>
          <target state="translated">&lt;code&gt;mpsc::channel&lt;/code&gt; 함수를 사용하여 새 채널을 만듭니다 . &lt;code&gt;mpsc&lt;/code&gt; 는 &lt;em&gt;여러 생산자, 단일 소비자를&lt;/em&gt; 나타냅니다 . 간단히 말해서 Rust의 표준 라이브러리가 채널을 구현하는 방식은 채널이 값을 생성하는 여러 &lt;em&gt;송신&lt;/em&gt; 엔드를 가질 수 있지만 해당 값을 소비하는 &lt;em&gt;수신&lt;/em&gt; 엔드는 하나만 가질 수 있다는 것을 의미 합니다. 하나의 큰 강으로 여러 개의 개울이 함께 흐른다 고 상상해보십시오. 지금은 단일 제작자로 시작하지만이 예제가 작동하면 여러 생산자를 추가 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="f5c29204bb0d962e79055d0d1b3b5bbda1a961e7" translate="yes" xml:space="preserve">
          <source>We create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple don&amp;rsquo;t have to be the same. We&amp;rsquo;ve added optional type annotations in this example:</source>
          <target state="translated">괄호 안에 쉼표로 구분 된 값 목록을 작성하여 튜플을 만듭니다. 튜플의 각 위치에는 유형이 있으며 튜플의 서로 다른 값의 유형이 같을 필요는 없습니다. 이 예제에서는 선택적 유형 주석을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="217c985ce00adb4e75f034015851790eafde7ce0" translate="yes" xml:space="preserve">
          <source>We create a value that is an instance of &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt; and store it in a variable named &lt;code&gt;value&lt;/code&gt; so we can access it directly later. Then we create a &lt;code&gt;List&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; with a &lt;code&gt;Cons&lt;/code&gt; variant that holds &lt;code&gt;value&lt;/code&gt;. We need to clone &lt;code&gt;value&lt;/code&gt; so both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; have ownership of the inner &lt;code&gt;5&lt;/code&gt; value rather than transferring ownership from &lt;code&gt;value&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; or having &lt;code&gt;a&lt;/code&gt; borrow from &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">우리의 인스턴스 값을 만들 &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt; 와라는 변수에 저장 &lt;code&gt;value&lt;/code&gt; 우리가 직접 나중에 액세스 할 수 있도록합니다. 그런 다음 우리는 만들 &lt;code&gt;List&lt;/code&gt; 에 A의 &lt;code&gt;Cons&lt;/code&gt; 보유 변형 &lt;code&gt;value&lt;/code&gt; . 우리는 &lt;code&gt;value&lt;/code&gt; 를 복제해야 합니다. 따라서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;value&lt;/code&gt; 모두 소유권을 &lt;code&gt;value&lt;/code&gt; 에서 &lt;code&gt;a&lt;/code&gt; 로 또는 &lt;code&gt;value&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 차용 하지 않고 내부 &lt;code&gt;5&lt;/code&gt; 가치의 소유권을 갖도록해야 합니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a78ec46695882234043b0ee9037ddd70e71fc2b2" translate="yes" xml:space="preserve">
          <source>We create a variable &lt;code&gt;one_borrow&lt;/code&gt; for the &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer returned from &lt;code&gt;borrow_mut&lt;/code&gt;. Then we create another mutable borrow in the same way in the variable &lt;code&gt;two_borrow&lt;/code&gt;. This makes two mutable references in the same scope, which isn&amp;rsquo;t allowed. When we run the tests for our library, the code in Listing 15-23 will compile without any errors, but the test will fail:</source>
          <target state="translated">&lt;code&gt;one_borrow&lt;/code&gt; 에서 반환 된 &lt;code&gt;borrow_mut&lt;/code&gt; &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; 스마트 포인터 에 대해 one_borrow 변수 를 만듭니다 . 그런 다음 변수 &lt;code&gt;two_borrow&lt;/code&gt; 에서 같은 방식으로 다른 가변 차용을 작성 합니다. 이렇게하면 같은 범위에서 두 개의 변경 가능한 참조가 만들어 지므로 허용되지 않습니다. 라이브러리에 대한 테스트를 실행하면 Listing 15-23의 코드가 오류없이 컴파일되지만 테스트는 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a13f3cc429bf174699131984fc2de3412f7e9ed1" translate="yes" xml:space="preserve">
          <source>We create a variable named &lt;code&gt;guess&lt;/code&gt;. But wait, doesn&amp;rsquo;t the program already have a variable named &lt;code&gt;guess&lt;/code&gt;? It does, but Rust allows us to &lt;em&gt;shadow&lt;/em&gt; the previous value of &lt;code&gt;guess&lt;/code&gt; with a new one. This feature is often used in situations in which you want to convert a value from one type to another type. Shadowing lets us reuse the &lt;code&gt;guess&lt;/code&gt; variable name rather than forcing us to create two unique variables, such as &lt;code&gt;guess_str&lt;/code&gt; and &lt;code&gt;guess&lt;/code&gt; for example. (Chapter 3 covers shadowing in more detail.)</source>
          <target state="translated">&lt;code&gt;guess&lt;/code&gt; 라는 변수를 만듭니다 . 그러나 잠깐, 프로그램에 &lt;code&gt;guess&lt;/code&gt; 라는 변수가 이미 없습니까? 하지만 Rust를 사용 하면 이전 &lt;code&gt;guess&lt;/code&gt; 값을 새로운 것으로 &lt;em&gt;그림자를&lt;/em&gt; 만들 수 있습니다 . 이 기능은 한 유형에서 다른 유형으로 값을 변환하려는 상황에서 자주 사용됩니다. 섀도 잉을 사용하면 &lt;code&gt;guess_str&lt;/code&gt; 및 &lt;code&gt;guess&lt;/code&gt; 와 같은 두 가지 고유 변수를 만들지 않고 &lt;code&gt;guess&lt;/code&gt; 변수 이름을 재사용 할 수 있습니다 . 3 장에서는 섀도 잉에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="de4fc4d2d99789fde2fe26a07b69cc901ac7718d" translate="yes" xml:space="preserve">
          <source>We create an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance holding a &lt;code&gt;List&lt;/code&gt; value in the variable &lt;code&gt;a&lt;/code&gt; with an initial list of &lt;code&gt;5, Nil&lt;/code&gt;. We then create an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance holding another &lt;code&gt;List&lt;/code&gt; value in the variable &lt;code&gt;b&lt;/code&gt; that contains the value 10 and points to the list in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">초기 값 이 &lt;code&gt;5, Nil&lt;/code&gt; 변수 &lt;code&gt;a&lt;/code&gt; 에 &lt;code&gt;List&lt;/code&gt; 값을 보유 하는 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 인스턴스를 만듭니다 . 우리는 다음 만들 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 다른 지주 예 &lt;code&gt;List&lt;/code&gt; 변수의 가치 &lt;code&gt;b&lt;/code&gt; 의 목록에 값 10 점을 포함 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2247cf495f9d29b643c1d913b5721c0a5bd3745" translate="yes" xml:space="preserve">
          <source>We define a module by starting with the &lt;code&gt;mod&lt;/code&gt; keyword and then specify the name of the module (in this case, &lt;code&gt;front_of_house&lt;/code&gt;) and place curly brackets around the body of the module. Inside modules, we can have other modules, as in this case with the modules &lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;serving&lt;/code&gt;. Modules can also hold definitions for other items, such as structs, enums, constants, traits, or&amp;mdash;as in Listing 7-1&amp;mdash;functions.</source>
          <target state="translated">&lt;code&gt;mod&lt;/code&gt; 키워드 로 시작하여 모듈을 정의한 다음 모듈 이름 (이 경우 &lt;code&gt;front_of_house&lt;/code&gt; )을 지정하고 모듈 본문 주위에 중괄호를 넣 습니다. 모듈 내부에는이 경우와 같이 모듈을 &lt;code&gt;hosting&lt;/code&gt; 하고 &lt;code&gt;serving&lt;/code&gt; 다른 모듈이있을 수 있습니다 . 모듈은 구조체, 열거 형, 상수, 특성 또는 함수 (목록 7-1에서와 같이)와 같은 다른 항목에 대한 정의를 보유 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e47ede752c48b9631f3f17b5d74a77ce4b734cb8" translate="yes" xml:space="preserve">
          <source>We define a struct named &lt;code&gt;MyBox&lt;/code&gt; and declare a generic parameter &lt;code&gt;T&lt;/code&gt;, because we want our type to hold values of any type. The &lt;code&gt;MyBox&lt;/code&gt; type is a tuple struct with one element of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;MyBox::new&lt;/code&gt; function takes one parameter of type &lt;code&gt;T&lt;/code&gt; and returns a &lt;code&gt;MyBox&lt;/code&gt; instance that holds the value passed in.</source>
          <target state="translated">&lt;code&gt;MyBox&lt;/code&gt; 라는 구조체를 정의 하고 형식이 모든 형식의 값을 보유하기를 원하기 때문에 일반 매개 변수 &lt;code&gt;T&lt;/code&gt; 를 선언합니다 . &lt;code&gt;MyBox&lt;/code&gt; 의 타입 타입의 한 요소 튜플 구조체 인 &lt;code&gt;T&lt;/code&gt; . &lt;code&gt;MyBox::new&lt;/code&gt; 기능은 유형의 하나 개의 매개 변수 소요 &lt;code&gt;T&lt;/code&gt; 를 하고 반환 &lt;code&gt;MyBox&lt;/code&gt; 에 전달 된 값을 보유 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="3dba1e3de49b65359a5e4f8f90084e7de4bbd56a" translate="yes" xml:space="preserve">
          <source>We define the variable &lt;code&gt;b&lt;/code&gt; to have the value of a &lt;code&gt;Box&lt;/code&gt; that points to the value &lt;code&gt;5&lt;/code&gt;, which is allocated on the heap. This program will print &lt;code&gt;b = 5&lt;/code&gt;; in this case, we can access the data in the box similar to how we would if this data were on the stack. Just like any owned value, when a box goes out of scope, as &lt;code&gt;b&lt;/code&gt; does at the end of &lt;code&gt;main&lt;/code&gt;, it will be deallocated. The deallocation happens for the box (stored on the stack) and the data it points to (stored on the heap).</source>
          <target state="translated">변수 &lt;code&gt;b&lt;/code&gt; 를 정의하여 값이 &lt;code&gt;5&lt;/code&gt; 를 가리키는 &lt;code&gt;Box&lt;/code&gt; 값을 갖도록 지정합니다.이 값은 힙에 할당됩니다. 이 프로그램은 &lt;code&gt;b = 5&lt;/code&gt; 를 인쇄합니다 . 이 경우이 데이터가 스택에있는 경우와 유사한 방식으로 상자의 데이터에 액세스 할 수 있습니다. 소유 한 값과 마찬가지로 상자가 범위를 벗어나면 &lt;code&gt;b&lt;/code&gt; 가 &lt;code&gt;main&lt;/code&gt; 의 끝에서 와 같이 할당이 해제됩니다. 할당 취소는 스택 (스택에 저장 됨)과 그것이 가리키는 (힙에 저장 됨) 데이터에 대해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6c4670dac61b6eae4d1d24a214b4ec0473603413" translate="yes" xml:space="preserve">
          <source>We did it! We counted from 0 to 10, which may not seem very impressive, but it did teach us a lot about &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and thread safety. You could also use this program&amp;rsquo;s structure to do more complicated operations than just incrementing a counter. Using this strategy, you can divide a calculation into independent parts, split those parts across threads, and then use a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; to have each thread update the final result with its part.</source>
          <target state="translated">우리는 해냈다! 우리는 0에서 10까지 세 었는데, 그다지 인상적이지는 않지만 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 와 스레드 안전성에 대해 많은 것을 가르쳐주었습니다 . 이 프로그램의 구조를 사용하여 카운터를 늘리는 것보다 더 복잡한 작업을 수행 할 수도 있습니다. 이 전략을 사용하면 계산을 독립 부품으로 나누고 해당 부품을 스레드간에 분할 한 다음 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용하여 각 스레드가 최종 결과를 해당 부품으로 업데이트하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe1aa557fede41366c6004f8700f2e15672b0f90" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t handle the &lt;code&gt;None&lt;/code&gt; case, so this code will cause a bug. Luckily, it&amp;rsquo;s a bug Rust knows how to catch. If we try to compile this code, we&amp;rsquo;ll get this error:</source>
          <target state="translated">우리는 &lt;code&gt;None&lt;/code&gt; 케이스를 처리하지 않았으므로이 코드는 버그를 일으킬 것입니다. 다행히 Rust가 잡는 방법을 알고있는 버그입니다. 이 코드를 컴파일하려고하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="989f3e5cd017623906ee76c93f904f2554f643be" translate="yes" xml:space="preserve">
          <source>We discussed how to control encapsulation in Chapter 7: we can use the &lt;code&gt;pub&lt;/code&gt; keyword to decide which modules, types, functions, and methods in our code should be public, and by default everything else is private. For example, we can define a struct &lt;code&gt;AveragedCollection&lt;/code&gt; that has a field containing a vector of &lt;code&gt;i32&lt;/code&gt; values. The struct can also have a field that contains the average of the values in the vector, meaning the average doesn&amp;rsquo;t have to be computed on demand whenever anyone needs it. In other words, &lt;code&gt;AveragedCollection&lt;/code&gt; will cache the calculated average for us. Listing 17-1 has the definition of the &lt;code&gt;AveragedCollection&lt;/code&gt; struct:</source>
          <target state="translated">7 장에서 캡슐화를 제어하는 ​​방법에 대해 논의했습니다. &lt;code&gt;pub&lt;/code&gt; 키워드를 사용하여 코드에서 어떤 모듈, 유형, 함수 및 메소드를 공개해야하는지 결정할 수 있으며 기본적으로 다른 모든 것은 비공개입니다. 예를 들어, &lt;code&gt;i32&lt;/code&gt; 값 의 벡터를 포함하는 필드가있는 구조체 &lt;code&gt;AveragedCollection&lt;/code&gt; 을 정의 할 수 있습니다 . 구조체에는 벡터의 평균 값을 포함하는 필드가있을 수 있습니다. 즉, 필요할 때마다 필요할 때 평균을 계산할 필요가 없습니다. 즉, &lt;code&gt;AveragedCollection&lt;/code&gt; 은 계산 된 평균을 캐시합니다. Listing 17-1에는 &lt;code&gt;AveragedCollection&lt;/code&gt; 구조체 의 정의가있다 :</target>
        </trans-unit>
        <trans-unit id="b3015808d9d1facbbe8da90fee53a4b9abf4f2fa" translate="yes" xml:space="preserve">
          <source>We do this by adding another attribute, &lt;code&gt;should_panic&lt;/code&gt;, to our test function. This attribute makes a test pass if the code inside the function panics; the test will fail if the code inside the function doesn&amp;rsquo;t panic.</source>
          <target state="translated">테스트 함수에 다른 속성 &lt;code&gt;should_panic&lt;/code&gt; 을 추가하여이를 수행합니다. 이 속성은 함수 내부의 코드가 패닉 상태 인 경우 테스트를 통과합니다. 함수 내부의 코드가 패닉하지 않으면 테스트가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="8639f3d179b96373aaacdd4299811b8d0f9290d7" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t get a very helpful message in this case, but when we look at the test function, we see that it&amp;rsquo;s annotated with &lt;code&gt;#[should_panic]&lt;/code&gt;. The failure we got means that the code in the test function did not cause a panic.</source>
          <target state="translated">이 경우에는 매우 유용한 메시지가 나타나지 않지만 테스트 함수를 보면 &lt;code&gt;#[should_panic]&lt;/code&gt; 로 주석이 달린 것을 볼 수 있습니다 . 우리가 얻은 실패는 테스트 함수의 코드가 패닉을 유발하지 않았다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4068c6471062184c3b20d8cf98be5e41f0b8825e" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t need to annotate any code in &lt;em&gt;tests/integration_test.rs&lt;/em&gt; with &lt;code&gt;#[cfg(test)]&lt;/code&gt;. Cargo treats the &lt;code&gt;tests&lt;/code&gt; directory specially and compiles files in this directory only when we run &lt;code&gt;cargo test&lt;/code&gt;. Run &lt;code&gt;cargo test&lt;/code&gt; now:</source>
          <target state="translated">우리는 어떤 코드에 주석 할 필요가 없습니다 &lt;em&gt;테스트 / integration_test.rs을&lt;/em&gt; 함께 &lt;code&gt;#[cfg(test)]&lt;/code&gt; . 카고는 &lt;code&gt;tests&lt;/code&gt; 디렉토리를 특별하게 취급하고 &lt;code&gt;cargo test&lt;/code&gt; 실행할 때만이 디렉토리의 파일을 컴파일합니다 . 지금 &lt;code&gt;cargo test&lt;/code&gt; 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="75fb1977c5f782491b5c56b13b35e7dc4f98b7f9" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t own the memory at this arbitrary location, and there is no guarantee that the slice this code creates contains valid &lt;code&gt;i32&lt;/code&gt; values. Attempting to use &lt;code&gt;slice&lt;/code&gt; as though it&amp;rsquo;s a valid slice results in undefined behavior.</source>
          <target state="translated">우리는이 임의의 위치에 메모리를 소유하지 &lt;code&gt;i32&lt;/code&gt; 코드가 생성하는 슬라이스에 유효한 i32 값 이 포함되어 있다고 보장 할 수 없습니다 . &lt;code&gt;slice&lt;/code&gt; 가 유효한 슬라이스 인 것처럼 슬라이스 를 사용하려고하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="33c7757c8f6132df6178843a84503652a22ac2d5" translate="yes" xml:space="preserve">
          <source>We don't just need to create a table of all implementations of all methods of &lt;code&gt;Trait&lt;/code&gt;, we need to create such a table, for each different type fed to &lt;code&gt;foo()&lt;/code&gt;. In this case this turns out to be (10 types implementing &lt;code&gt;Trait&lt;/code&gt;)*(3 types being fed to &lt;code&gt;foo()&lt;/code&gt;) = 30 implementations!</source>
          <target state="translated">우리는 &lt;code&gt;Trait&lt;/code&gt; 의 모든 메소드의 모든 구현에 대한 테이블을 만들 필요가 없으며 &lt;code&gt;foo()&lt;/code&gt; 공급되는 각기 다른 유형에 대해 이러한 테이블을 만들어야합니다 . 이 경우 이것은 (10 유형의 &lt;code&gt;Trait&lt;/code&gt; 구현 ) * (3 유형이 &lt;code&gt;foo()&lt;/code&gt; ) = 30 구현으로 나타납니다!</target>
        </trans-unit>
        <trans-unit id="7a128a92848713923bf5723a8f3ff04cf358a747" translate="yes" xml:space="preserve">
          <source>We end up with a different output:</source>
          <target state="translated">우리는 다른 출력으로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="3d3bdc9538d2becbfd76f7b51c9431cf8009e000" translate="yes" xml:space="preserve">
          <source>We fill in the body of the &lt;code&gt;deref&lt;/code&gt; method with &lt;code&gt;&amp;amp;self.0&lt;/code&gt; so &lt;code&gt;deref&lt;/code&gt; returns a reference to the value we want to access with the &lt;code&gt;*&lt;/code&gt; operator. The &lt;code&gt;main&lt;/code&gt; function in Listing 15-9 that calls &lt;code&gt;*&lt;/code&gt; on the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; value now compiles, and the assertions pass!</source>
          <target state="translated">&lt;code&gt;deref&lt;/code&gt; 메소드 의 본문을 &lt;code&gt;&amp;amp;self.0&lt;/code&gt; 따라서 &lt;code&gt;deref&lt;/code&gt; 는 &lt;code&gt;*&lt;/code&gt; 연산자 로 액세스하려는 값에 대한 참조를 반환합니다 . Listing 15-9 의 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 값 에서 &lt;code&gt;*&lt;/code&gt; 를 호출 하는 &lt;code&gt;main&lt;/code&gt; 함수가 이제 컴파일되고 어설 션이 전달된다!</target>
        </trans-unit>
        <trans-unit id="1a6e44b1c1cf0243b066c756c716999badd37ed6" translate="yes" xml:space="preserve">
          <source>We first covered traits in the &lt;a href=&quot;ch10-02-traits#traits-defining-shared-behavior&quot;&gt;&amp;ldquo;Traits: Defining Shared Behavior&amp;rdquo;&lt;/a&gt; section of Chapter 10, but as with lifetimes, we didn&amp;rsquo;t discuss the more advanced details. Now that you know more about Rust, we can get into the nitty-gritty.</source>
          <target state="translated">우리는 10 장의 &lt;a href=&quot;ch10-02-traits#traits-defining-shared-behavior&quot;&gt;&amp;ldquo;특성 : 공유 행동 정의&amp;rdquo;&lt;/a&gt; 섹션 에서 먼저 특성을 다루었 지만, 평생과 마찬가지로 더 세부적인 내용은 다루지 않았습니다. 이제 Rust에 대해 더 많이 알았으니, 우리는 핵심에 빠질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1ee78ca605c05c7a5c18ad3c92e24962b3e1d93" translate="yes" xml:space="preserve">
          <source>We fixed a number of small errors and imprecise wording throughout the book. Thank you to the readers who reported them!</source>
          <target state="translated">우리는이 책 전체에서 여러 가지 작은 오류를 수정하고 부정확 한 표현을했습니다. 보도 한 독자들에게 감사합니다!</target>
        </trans-unit>
        <trans-unit id="6dfcd8805f1de550cc498ea6159c7bf6b6fb1747" translate="yes" xml:space="preserve">
          <source>We get an &lt;code&gt;Ident&lt;/code&gt; struct instance containing the name (identifier) of the annotated type using &lt;code&gt;ast.ident&lt;/code&gt;. The struct in Listing 19-32 shows that when we run the &lt;code&gt;impl_hello_macro&lt;/code&gt; function on the code in Listing 19-30, the &lt;code&gt;ident&lt;/code&gt; we get will have the &lt;code&gt;ident&lt;/code&gt; field with a value of &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt;. Thus, the &lt;code&gt;name&lt;/code&gt; variable in Listing 19-33 will contain an &lt;code&gt;Ident&lt;/code&gt; struct instance that, when printed, will be the string &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt;, the name of the struct in Listing 19-30.</source>
          <target state="translated">&lt;code&gt;ast.ident&lt;/code&gt; 를 사용하여 주석이 달린 유형의 이름 (식별자)을 포함 하는 &lt;code&gt;Ident&lt;/code&gt; 구조체 인스턴스를 얻습니다 . Listing 19-32의 구조체는 &lt;code&gt;impl_hello_macro&lt;/code&gt; 목록 19-30의 코드에 기능은 &lt;code&gt;ident&lt;/code&gt; 우리가 얻을 수는있을 것이다 &lt;code&gt;ident&lt;/code&gt; 값으로 필드를 &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt; . 따라서 Listing 19-33 의 &lt;code&gt;name&lt;/code&gt; 변수에는 인쇄 될 때 Listing 19-30의 구조체 이름 인 &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt; 문자열 인 &lt;code&gt;Ident&lt;/code&gt; 구조체 인스턴스 가 포함된다 .</target>
        </trans-unit>
        <trans-unit id="fa5a76e7eb4f80b2d90e24f7c2b1ad7e6ecb3a57" translate="yes" xml:space="preserve">
          <source>We get an error saying that &lt;code&gt;Display&lt;/code&gt; is required but not implemented:</source>
          <target state="translated">&lt;code&gt;Display&lt;/code&gt; 가 필요하지만 구현되지 않았다는 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="7d2c8ffa5144563c1615375b324817ac18c0824c" translate="yes" xml:space="preserve">
          <source>We get an error:</source>
          <target state="translated">오류가 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="3ba89346d67718e5bc6cde49796722897eef8118" translate="yes" xml:space="preserve">
          <source>We get the index for the end of the word in the same way as we did in Listing 4-7, by looking for the first occurrence of a space. When we find a space, we return a string slice using the start of the string and the index of the space as the starting and ending indices.</source>
          <target state="translated">공백의 첫 번째 항목을 찾아서 목록 4-7에서와 같은 방식으로 단어 끝의 색인을 얻습니다. 공백을 찾으면 문자열의 시작과 공백의 색인을 시작 및 끝 색인으로 사용하여 문자열 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ef6ac0d2fb1390b1ec4785e58118caa03d2717e4" translate="yes" xml:space="preserve">
          <source>We give &lt;code&gt;Post&lt;/code&gt; a public method named &lt;code&gt;request_review&lt;/code&gt; that will take a mutable reference to &lt;code&gt;self&lt;/code&gt;. Then we call an internal &lt;code&gt;request_review&lt;/code&gt; method on the current state of &lt;code&gt;Post&lt;/code&gt;, and this second &lt;code&gt;request_review&lt;/code&gt; method consumes the current state and returns a new state.</source>
          <target state="translated">&lt;code&gt;Post&lt;/code&gt; 에 &lt;code&gt;request_review&lt;/code&gt; 라는 공개 메소드를 제공합니다 &lt;code&gt;self&lt;/code&gt; 에 변경 가능한 참조를 취할 합니다. 그런 다음 &lt;code&gt;Post&lt;/code&gt; 의 현재 상태에서 내부 &lt;code&gt;request_review&lt;/code&gt; 메소드를 호출 하고이 두 번째 &lt;code&gt;request_review&lt;/code&gt; 메소드는 현재 상태를 소비하고 새 상태를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e6c80fee7f3dde04888c77a6cd846415ab744177" translate="yes" xml:space="preserve">
          <source>We have a trait and its function. At this point, our crate user could implement the trait to achieve the desired functionality, like so:</source>
          <target state="translated">우리는 특성과 그 기능을 가지고 있습니다. 이 시점에서 크레이트 사용자는 원하는 기능을 달성하기 위해 특성을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c17bca679d4e20c394f90f8fcfedbf4fbf9ebe88" translate="yes" xml:space="preserve">
          <source>We have another useful pattern that exploits an implementation detail of tuple structs and tuple-struct enum variants. These types use &lt;code&gt;()&lt;/code&gt; as initializer syntax, which looks like a function call. The initializers are actually implemented as functions returning an instance that&amp;rsquo;s constructed from their arguments. We can use these initializer functions as function pointers that implement the closure traits, which means we can specify the initializer functions as arguments for methods that take closures, like so:</source>
          <target state="translated">우리는 tuple 구조체와 tuple-struct 열거 형 변형의 구현 세부 사항을 이용하는 또 다른 유용한 패턴을 가지고 있습니다. 이러한 유형은 &lt;code&gt;()&lt;/code&gt; 를 초기화 구문으로 사용 하며 함수 호출처럼 보입니다. 이니셜 라이저는 실제로 인수로 구성된 인스턴스를 반환하는 함수로 구현됩니다. 이러한 초기화 함수를 클로저 특성을 구현하는 함수 포인터로 사용할 수 있습니다. 즉, 초기화 함수를 클로저를 취하는 메소드의 인수로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bd65f3ffc2c662fc4446b91a67d9e1b143c07d7" translate="yes" xml:space="preserve">
          <source>We have most of the game working now, but the user can make only one guess. Let&amp;rsquo;s change that by adding a loop!</source>
          <target state="translated">현재 대부분의 게임이 작동하고 있지만 사용자는 한 번만 추측 할 수 있습니다. 루프를 추가하여 변경해 봅시다!</target>
        </trans-unit>
        <trans-unit id="3aa84427fb5c8531cf1e35659e181c7888c45db6" translate="yes" xml:space="preserve">
          <source>We have two structs, &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, holding values in different units. We want to add values in millimeters to values in meters and have the implementation of &lt;code&gt;Add&lt;/code&gt; do the conversion correctly. We can implement &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; with &lt;code&gt;Meters&lt;/code&gt; as the &lt;code&gt;RHS&lt;/code&gt;, as shown in Listing 19-15.</source>
          <target state="translated">&lt;code&gt;Millimeters&lt;/code&gt; 와 &lt;code&gt;Meters&lt;/code&gt; 라는 두 개의 구조체가 있으며 다른 단위로 값을 보유합니다. 미터 단위의 값에 밀리미터 단위의 값을 추가하고 &lt;code&gt;Add&lt;/code&gt; 를 구현 하여 변환을 올바르게 수행 하려고 합니다. &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; 를 구현할 수 있습니다Listing 19-15와 같이 &lt;code&gt;RHS&lt;/code&gt; 로 &lt;code&gt;Meters&lt;/code&gt; 를 사용하여 를 .</target>
        </trans-unit>
        <trans-unit id="d8a3dea7c52bc3f0b1a5887645fbfc3ac18bf504" translate="yes" xml:space="preserve">
          <source>We have two structs, &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, holding values in different units. We want to add values in millimeters to values in meters and have the implementation of &lt;code&gt;Add&lt;/code&gt; do the conversion correctly. We can implement &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; with &lt;code&gt;Meters&lt;/code&gt; as the &lt;code&gt;Rhs&lt;/code&gt;, as shown in Listing 19-15.</source>
          <target state="translated">두 개의 구조체, &lt;code&gt;Millimeters&lt;/code&gt; 및 &lt;code&gt;Meters&lt;/code&gt; 가 있으며 다른 단위로 값을 유지합니다. 우리는 밀리미터 단위의 값을 미터 단위의 값에 &lt;code&gt;Add&lt;/code&gt; 구현이 올바르게 변환하도록 하고 싶습니다 . 목록 19-15에 표시된 것처럼 &lt;code&gt;Rhs&lt;/code&gt; 로 &lt;code&gt;Meters&lt;/code&gt; 를 사용하여 &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; 를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="160ceff2ab6cdd2b56a8bbd9402294ab3fbd2021" translate="yes" xml:space="preserve">
          <source>We have written an &lt;a href=&quot;https://rust-lang.github.io/async-book/&quot;&gt;async book&lt;/a&gt; detailing async/await and trade-offs compared to using threads.</source>
          <target state="translated">스레드 사용과 비교하여 async / await 및 트레이드 오프를 자세히 설명 하는 &lt;a href=&quot;https://rust-lang.github.io/async-book/&quot;&gt;비동기 책&lt;/a&gt; 을 작성했습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
