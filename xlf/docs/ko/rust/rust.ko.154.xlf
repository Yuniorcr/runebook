<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="5927f0d5ac8801b4254d8379327d991a701a80da" translate="yes" xml:space="preserve">
          <source>Truncates or extends the underlying file, updating the size of this file to become &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">기본 파일을 자르거나 확장하여이 파일의 크기를 &lt;code&gt;size&lt;/code&gt; 가되도록 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="2702cfbf0e58f8f82fb23e8d650e499d7cc927c5" translate="yes" xml:space="preserve">
          <source>Truncates the &lt;code&gt;OsString&lt;/code&gt; to zero length.</source>
          <target state="translated">&lt;code&gt;OsString&lt;/code&gt; 을 0 길이로 자릅니다 .</target>
        </trans-unit>
        <trans-unit id="ed28d8bdecc758ddcef76eed8b86ffa1d4ea3181" translate="yes" xml:space="preserve">
          <source>Truncates this &lt;code&gt;String&lt;/code&gt;, removing all contents.</source>
          <target state="translated">이 &lt;code&gt;String&lt;/code&gt; 을 잘라내어 모든 내용을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="5474aa5946c713a1f6e7a033ad591db623edd6d3" translate="yes" xml:space="preserve">
          <source>Truncating a five element vector to two elements:</source>
          <target state="translated">다섯 요소 벡터를 두 요소로 자르기 :</target>
        </trans-unit>
        <trans-unit id="743f01c9ef69fe480785553858265deba678132e" translate="yes" xml:space="preserve">
          <source>Truncating when &lt;code&gt;len == 0&lt;/code&gt; is equivalent to calling the &lt;a href=&quot;#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;len == 0&lt;/code&gt; 때 잘리는 것은 &lt;a href=&quot;#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7b9f4a78a76c6893e05b1ff011a47211505551b2" translate="yes" xml:space="preserve">
          <source>Truncating when &lt;code&gt;len == 0&lt;/code&gt; is equivalent to calling the &lt;a href=&quot;struct.vec#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;len == 0&lt;/code&gt; 때 자르는 것은 &lt;a href=&quot;struct.vec#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="63908c3dcfc457f07a333b89f52c763024b846da" translate="yes" xml:space="preserve">
          <source>TrustedLen</source>
          <target state="translated">TrustedLen</target>
        </trans-unit>
        <trans-unit id="72677028b4d0d41af475041fdbe030f7c7146d2c" translate="yes" xml:space="preserve">
          <source>Try</source>
          <target state="translated">Try</target>
        </trans-unit>
        <trans-unit id="93cacc9f6a162523f52bc4401526c741faac95a0" translate="yes" xml:space="preserve">
          <source>Try designing more experiments that vary the values and lifetimes of the references passed in to the &lt;code&gt;longest&lt;/code&gt; function and how the returned reference is used. Make hypotheses about whether or not your experiments will pass the borrow checker before you compile; then check to see if you&amp;rsquo;re right!</source>
          <target state="translated">&lt;code&gt;longest&lt;/code&gt; 함수에 전달 된 참조의 값과 수명 및 반환 된 참조가 사용되는 방법 을 변화시키는 더 많은 실험을 설계하십시오 . 컴파일하기 전에 실험이 차용 검사기를 통과할지 여부에 대한 가설을 세우십시오. 그런 다음 당신이 옳은지 확인하십시오!</target>
        </trans-unit>
        <trans-unit id="b25651affa48a09fef804a246293a9441327deef" translate="yes" xml:space="preserve">
          <source>Try making a request from a different browser or asking for a different address, such as &lt;em&gt;127.0.0.1:7878/test&lt;/em&gt;, to see how the request data changes.</source>
          <target state="translated">다른 브라우저에서 요청하거나 &lt;em&gt;127.0.0.1:7878/test&lt;/em&gt; 와 같은 다른 주소를 요청하여 요청 데이터가 어떻게 변경되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3cdedf03df7f2d7ff7f62a3fe4c0233e49c2605a" translate="yes" xml:space="preserve">
          <source>Try modifying &lt;code&gt;Cacher&lt;/code&gt; to hold a hash map rather than a single value. The keys of the hash map will be the &lt;code&gt;arg&lt;/code&gt; values that are passed in, and the values of the hash map will be the result of calling the closure on that key. Instead of looking at whether &lt;code&gt;self.value&lt;/code&gt; directly has a &lt;code&gt;Some&lt;/code&gt; or a &lt;code&gt;None&lt;/code&gt; value, the &lt;code&gt;value&lt;/code&gt; function will look up the &lt;code&gt;arg&lt;/code&gt; in the hash map and return the value if it&amp;rsquo;s present. If it&amp;rsquo;s not present, the &lt;code&gt;Cacher&lt;/code&gt; will call the closure and save the resulting value in the hash map associated with its &lt;code&gt;arg&lt;/code&gt; value.</source>
          <target state="translated">단일 값이 아닌 해시 맵을 보유 하도록 &lt;code&gt;Cacher&lt;/code&gt; 를 수정하십시오 . 해시 맵의 키 는 전달 된 &lt;code&gt;arg&lt;/code&gt; 값이되고 해시 맵의 값은 해당 키에서 클로저를 호출 한 결과가됩니다. &lt;code&gt;self.value&lt;/code&gt; 에 &lt;code&gt;Some&lt;/code&gt; 또는 &lt;code&gt;None&lt;/code&gt; 값 이 직접 있는지 확인하는 대신 &lt;code&gt;value&lt;/code&gt; 함수는 해시 맵에서 &lt;code&gt;arg&lt;/code&gt; 를 조회하고 존재하는 경우 값을 리턴합니다. 존재하지 않는 경우, &lt;code&gt;Cacher&lt;/code&gt; 는 클로저를 호출하고 결과 값을 &lt;code&gt;arg&lt;/code&gt; 값 과 관련된 해시 맵에 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="746db25e46725d2a25a5be38541b8fd90c0e318e" translate="yes" xml:space="preserve">
          <source>Try running the program a few times:</source>
          <target state="translated">프로그램을 몇 번 실행 해보십시오.</target>
        </trans-unit>
        <trans-unit id="40db21ca976b20c4f1a37614a766d7e0fedff356" translate="yes" xml:space="preserve">
          <source>Try running this code; you should see the following output:</source>
          <target state="translated">이 코드를 실행 해보십시오. 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="0c704dff8c8947b24bdb19d42ed1933021fa9b51" translate="yes" xml:space="preserve">
          <source>Try running this program with the &lt;code&gt;main&lt;/code&gt; function from Listing 13-2. Change the values in the &lt;code&gt;simulated_user_specified_value&lt;/code&gt; and &lt;code&gt;simulated_random_number&lt;/code&gt; variables to verify that in all the cases in the various &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks, &lt;code&gt;calculating slowly...&lt;/code&gt; appears only once and only when needed. The &lt;code&gt;Cacher&lt;/code&gt; takes care of the logic necessary to ensure we aren&amp;rsquo;t calling the expensive calculation more than we need to so &lt;code&gt;generate_workout&lt;/code&gt; can focus on the business logic.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 으로이 프로그램을 실행 해보십시오목록 13-2 기능 . 다양한 &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 블록 의 모든 경우에 &lt;code&gt;calculating slowly...&lt;/code&gt; 것이 필요한 경우에만 한 번만 나타나는지 확인 하려면 &lt;code&gt;simulated_user_specified_value&lt;/code&gt; 및 &lt;code&gt;simulated_random_number&lt;/code&gt; 변수 의 값을 변경하십시오 . &lt;code&gt;Cacher&lt;/code&gt; 는 우리가 우리가 필요보다 더 비싼 계산을 호출되지 않도록하는 데 필요한 로직을 담당 &lt;code&gt;generate_workout&lt;/code&gt; 는 비즈니스 로직에 집중할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f64954535b22680cee23c59284f0821d313912c5" translate="yes" xml:space="preserve">
          <source>Try running this program; you should get the following output:</source>
          <target state="translated">이 프로그램을 실행 해보십시오. 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4e2f79e768da3d333677b7768aba6698b9473abe" translate="yes" xml:space="preserve">
          <source>Try the tasks suggested for additional requirements that we mentioned at the start of this section on the &lt;code&gt;blog&lt;/code&gt; crate as it is after Listing 17-20 to see what you think about the design of this version of the code. Note that some of the tasks might be completed already in this design.</source>
          <target state="translated">Listing 17-20 이후로 &lt;code&gt;blog&lt;/code&gt; 상자 에서이 섹션의 시작 부분에서 언급 한 추가 요구 사항에 대해 제안 된 태스크를 시도하여이 코드 버전의 디자인에 대해 어떻게 생각하는지보십시오. 이 작업에서 일부 작업이 이미 완료되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bea7aa5241bc934fb93d73fbe72c3c92fd9cb391" translate="yes" xml:space="preserve">
          <source>Try this instead:</source>
          <target state="translated">대신 이것을 시도하십시오 :</target>
        </trans-unit>
        <trans-unit id="cf4dffd1f17e87d4131fe9dbd6ed3566366e3295" translate="yes" xml:space="preserve">
          <source>Try to avoid moving the variable.</source>
          <target state="translated">변수 이동을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="708f496ce718cad5f2bfb9c2203cb73e375d06e0" translate="yes" xml:space="preserve">
          <source>Try to create the target number type from a source number type. This returns an error if the source value is outside of the range of the target type.</source>
          <target state="translated">소스 번호 유형에서 대상 번호 유형을 작성하십시오. 소스 값이 목표 유형의 범위를 벗어나면 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d7bb54d91c5813615d6b6445e2ebf488e82cdc0c" translate="yes" xml:space="preserve">
          <source>Try using &lt;code&gt;{}&lt;/code&gt; instead:</source>
          <target state="translated">대신 &lt;code&gt;{}&lt;/code&gt; 를 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="b8a1eb6a4114d62537aa281f5d03abf55ba6e9e3" translate="yes" xml:space="preserve">
          <source>Try using type inference instead. Example:</source>
          <target state="translated">대신 형식 유추를 사용해보십시오. 예:</target>
        </trans-unit>
        <trans-unit id="ea0079401a89dd04fe8291c0c734d4aa5a8c7177" translate="yes" xml:space="preserve">
          <source>Try::from_error</source>
          <target state="translated">Try::from_error</target>
        </trans-unit>
        <trans-unit id="bde6f44b7e04bd6491a07ffb037c4fa48b882a33" translate="yes" xml:space="preserve">
          <source>Try::from_ok</source>
          <target state="translated">Try::from_ok</target>
        </trans-unit>
        <trans-unit id="809111dd75695d75905fa1c8b4bad5d14691a30e" translate="yes" xml:space="preserve">
          <source>Try::into_result</source>
          <target state="translated">Try::into_result</target>
        </trans-unit>
        <trans-unit id="18e77d4b44ff639060d9a2fa2960f190781f7859" translate="yes" xml:space="preserve">
          <source>TryFrom</source>
          <target state="translated">TryFrom</target>
        </trans-unit>
        <trans-unit id="4acc1ac1c58ab4ae6724001d461baf2c8b8dbc3a" translate="yes" xml:space="preserve">
          <source>TryFrom::try_from</source>
          <target state="translated">TryFrom::try_from</target>
        </trans-unit>
        <trans-unit id="ad96c601815ad5f050e0b6351dd0b189e48a31a9" translate="yes" xml:space="preserve">
          <source>TryFromIntError</source>
          <target state="translated">TryFromIntError</target>
        </trans-unit>
        <trans-unit id="f81061adcf59a4b18f6432dc500e16b9a793d0e6" translate="yes" xml:space="preserve">
          <source>TryFromIntError::borrow</source>
          <target state="translated">TryFromIntError::borrow</target>
        </trans-unit>
        <trans-unit id="4d5e6ded3e6e6a7b69de27e74b52df8d33085625" translate="yes" xml:space="preserve">
          <source>TryFromIntError::borrow_mut</source>
          <target state="translated">TryFromIntError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8c6ac7bc7b08a0164c28c84e181d07ac7264caa1" translate="yes" xml:space="preserve">
          <source>TryFromIntError::cause</source>
          <target state="translated">TryFromIntError::cause</target>
        </trans-unit>
        <trans-unit id="f0da83cb703ff9ab478400076f17fb3b6df58453" translate="yes" xml:space="preserve">
          <source>TryFromIntError::clone</source>
          <target state="translated">TryFromIntError::clone</target>
        </trans-unit>
        <trans-unit id="21c991dfc7c9f46d0f223e9ada6bbb1b3ddc0419" translate="yes" xml:space="preserve">
          <source>TryFromIntError::clone_from</source>
          <target state="translated">TryFromIntError::clone_from</target>
        </trans-unit>
        <trans-unit id="611f56282230f313fea840ae9d1b4022b318faec" translate="yes" xml:space="preserve">
          <source>TryFromIntError::clone_into</source>
          <target state="translated">TryFromIntError::clone_into</target>
        </trans-unit>
        <trans-unit id="05df18eb5e5e51ad418c603a8c9e45f939b7afa0" translate="yes" xml:space="preserve">
          <source>TryFromIntError::description</source>
          <target state="translated">TryFromIntError::description</target>
        </trans-unit>
        <trans-unit id="cffa72c79f028d8b2b67ac3b5a88fa8e893445f1" translate="yes" xml:space="preserve">
          <source>TryFromIntError::eq</source>
          <target state="translated">TryFromIntError::eq</target>
        </trans-unit>
        <trans-unit id="7ec29ac29b26af4ad4e22c908d20f04e34123009" translate="yes" xml:space="preserve">
          <source>TryFromIntError::fmt</source>
          <target state="translated">TryFromIntError::fmt</target>
        </trans-unit>
        <trans-unit id="27af3cbe1fc043a4ba2263a1ddb04f43ed3341d8" translate="yes" xml:space="preserve">
          <source>TryFromIntError::from</source>
          <target state="translated">TryFromIntError::from</target>
        </trans-unit>
        <trans-unit id="88b0ca4bd6e97295df88042c17da3bc4ad1d1e49" translate="yes" xml:space="preserve">
          <source>TryFromIntError::into</source>
          <target state="translated">TryFromIntError::into</target>
        </trans-unit>
        <trans-unit id="b590493dab8454ef91bc8263edc4d90474ae7585" translate="yes" xml:space="preserve">
          <source>TryFromIntError::ne</source>
          <target state="translated">TryFromIntError::ne</target>
        </trans-unit>
        <trans-unit id="34bc40cbf452f309c77160c0bc046a559d512c4c" translate="yes" xml:space="preserve">
          <source>TryFromIntError::source</source>
          <target state="translated">TryFromIntError::source</target>
        </trans-unit>
        <trans-unit id="4650111711913011245aed1cfd4e401bf80b92bd" translate="yes" xml:space="preserve">
          <source>TryFromIntError::to_owned</source>
          <target state="translated">TryFromIntError::to_owned</target>
        </trans-unit>
        <trans-unit id="145d38c6294ea7b0b18a9beaf5c2ba62d71c6d31" translate="yes" xml:space="preserve">
          <source>TryFromIntError::to_string</source>
          <target state="translated">TryFromIntError::to_string</target>
        </trans-unit>
        <trans-unit id="3bd074fd7b824eb16d5c009603fefee21d967354" translate="yes" xml:space="preserve">
          <source>TryFromIntError::try_from</source>
          <target state="translated">TryFromIntError::try_from</target>
        </trans-unit>
        <trans-unit id="2a66975e8a4a9df97b01eea79b97edba1ce4fc13" translate="yes" xml:space="preserve">
          <source>TryFromIntError::try_into</source>
          <target state="translated">TryFromIntError::try_into</target>
        </trans-unit>
        <trans-unit id="853b95e029b9b10b04426ea41bce22a33cadfde3" translate="yes" xml:space="preserve">
          <source>TryFromIntError::type_id</source>
          <target state="translated">TryFromIntError::type_id</target>
        </trans-unit>
        <trans-unit id="f7ae979f3e3e5c6883cf562acec4a3d8911ff6b7" translate="yes" xml:space="preserve">
          <source>TryFromSliceError</source>
          <target state="translated">TryFromSliceError</target>
        </trans-unit>
        <trans-unit id="08abda7dda4132c13ad2de215a8116ad1c512693" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::borrow</source>
          <target state="translated">TryFromSliceError::borrow</target>
        </trans-unit>
        <trans-unit id="a42a16b656b3e78ad3c1fba788c25cca8562aa04" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::borrow_mut</source>
          <target state="translated">TryFromSliceError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6b154dc43d23a695abe3c26c810c9600a10bbfc7" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::cause</source>
          <target state="translated">TryFromSliceError::cause</target>
        </trans-unit>
        <trans-unit id="06c3cdee5b115341587a81b7640e380fd15333ea" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::clone</source>
          <target state="translated">TryFromSliceError::clone</target>
        </trans-unit>
        <trans-unit id="a4d48a9b9f7dd5e07e2bb398d2d1029a5b1eb76b" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::clone_from</source>
          <target state="translated">TryFromSliceError::clone_from</target>
        </trans-unit>
        <trans-unit id="faf3d5f757e37a47d1e58275eb48efaa726218ad" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::clone_into</source>
          <target state="translated">TryFromSliceError::clone_into</target>
        </trans-unit>
        <trans-unit id="49619f8bf5df143f7d9e552904f6a84fca8093ea" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::description</source>
          <target state="translated">TryFromSliceError::description</target>
        </trans-unit>
        <trans-unit id="fc484006f6aa38bffa40eb517d8b4b32091a5671" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::fmt</source>
          <target state="translated">TryFromSliceError::fmt</target>
        </trans-unit>
        <trans-unit id="630dd1955f1b733df02d2f1446cd6b9ba9cd293b" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::from</source>
          <target state="translated">TryFromSliceError::from</target>
        </trans-unit>
        <trans-unit id="2a5519380aabe238e175f9b6849d0a2d7f53c5a8" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::into</source>
          <target state="translated">TryFromSliceError::into</target>
        </trans-unit>
        <trans-unit id="b1ef9a7f4941a7c7fc1ee4d269c0be752b4049c1" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::source</source>
          <target state="translated">TryFromSliceError::source</target>
        </trans-unit>
        <trans-unit id="46b791fdfec792bbb13fbb3115a245caecffc0d8" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::to_owned</source>
          <target state="translated">TryFromSliceError::to_owned</target>
        </trans-unit>
        <trans-unit id="04f8529255b3a3ba17e31837ca350fb03a1837a0" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::to_string</source>
          <target state="translated">TryFromSliceError::to_string</target>
        </trans-unit>
        <trans-unit id="d39f8030ca01a81b1eedd289678e98a9a8c6374d" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::try_from</source>
          <target state="translated">TryFromSliceError::try_from</target>
        </trans-unit>
        <trans-unit id="87b56d5270282ca8cea8f2ae22fb393b6ef2e185" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::try_into</source>
          <target state="translated">TryFromSliceError::try_into</target>
        </trans-unit>
        <trans-unit id="273ef45502220a3e82cc6cd2ff47d1b967ced192" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::type_id</source>
          <target state="translated">TryFromSliceError::type_id</target>
        </trans-unit>
        <trans-unit id="eb91bb9edb358310d1de44ff46dcb50ed3d4dbf6" translate="yes" xml:space="preserve">
          <source>TryInto</source>
          <target state="translated">TryInto</target>
        </trans-unit>
        <trans-unit id="d4782bb6e82830853df5d390b765742f2ed433ce" translate="yes" xml:space="preserve">
          <source>TryInto::try_into</source>
          <target state="translated">TryInto::try_into</target>
        </trans-unit>
        <trans-unit id="d550a8f93a6fe62cffc66481db4e53166b4de9e5" translate="yes" xml:space="preserve">
          <source>TryIter</source>
          <target state="translated">TryIter</target>
        </trans-unit>
        <trans-unit id="b4f81b18947056193693e5cce08cae5bcc996cf1" translate="yes" xml:space="preserve">
          <source>TryLockError</source>
          <target state="translated">TryLockError</target>
        </trans-unit>
        <trans-unit id="6408d526dcb04978c761f176b4b48253f6e2b3a3" translate="yes" xml:space="preserve">
          <source>TryLockError::borrow</source>
          <target state="translated">TryLockError::borrow</target>
        </trans-unit>
        <trans-unit id="c1162b670a7e56c24667fd355cb74c01579b66f6" translate="yes" xml:space="preserve">
          <source>TryLockError::borrow_mut</source>
          <target state="translated">TryLockError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="645caaf83340c9e36066d5283df40d2289f0c56a" translate="yes" xml:space="preserve">
          <source>TryLockError::cause</source>
          <target state="translated">TryLockError::cause</target>
        </trans-unit>
        <trans-unit id="edc35be2771c53d502f5e8aaee878dd2e15d3b5a" translate="yes" xml:space="preserve">
          <source>TryLockError::description</source>
          <target state="translated">TryLockError::description</target>
        </trans-unit>
        <trans-unit id="c6f2c000c844249e646527b009bb44e488eef5e5" translate="yes" xml:space="preserve">
          <source>TryLockError::fmt</source>
          <target state="translated">TryLockError::fmt</target>
        </trans-unit>
        <trans-unit id="9001bf82d878e70373f04e6654b0f776179b2f53" translate="yes" xml:space="preserve">
          <source>TryLockError::from</source>
          <target state="translated">TryLockError::from</target>
        </trans-unit>
        <trans-unit id="655a2e7bdf752d14f5354358dacab8b46b5c1b0d" translate="yes" xml:space="preserve">
          <source>TryLockError::into</source>
          <target state="translated">TryLockError::into</target>
        </trans-unit>
        <trans-unit id="e4ccb09bacf6984439f523c7aecac39df9844058" translate="yes" xml:space="preserve">
          <source>TryLockError::source</source>
          <target state="translated">TryLockError::source</target>
        </trans-unit>
        <trans-unit id="c61e09fc91fbcfa81bcf718beb714ea63719b4eb" translate="yes" xml:space="preserve">
          <source>TryLockError::to_string</source>
          <target state="translated">TryLockError::to_string</target>
        </trans-unit>
        <trans-unit id="ebcde8097671e82bd0e812397421ce3e5f83aa6a" translate="yes" xml:space="preserve">
          <source>TryLockError::try_from</source>
          <target state="translated">TryLockError::try_from</target>
        </trans-unit>
        <trans-unit id="7b92cc07d0ee9b28099cb947d6053805d66baac1" translate="yes" xml:space="preserve">
          <source>TryLockError::try_into</source>
          <target state="translated">TryLockError::try_into</target>
        </trans-unit>
        <trans-unit id="904eaeeceb270dd726f594af3ac7324866060774" translate="yes" xml:space="preserve">
          <source>TryLockError::type_id</source>
          <target state="translated">TryLockError::type_id</target>
        </trans-unit>
        <trans-unit id="7d779fd6e34ddc3c9ecd145e12eaab2707fb88f2" translate="yes" xml:space="preserve">
          <source>TryLockResult</source>
          <target state="translated">TryLockResult</target>
        </trans-unit>
        <trans-unit id="b00cb1382a524b91c7b6f872f909018a2ba2fcdb" translate="yes" xml:space="preserve">
          <source>TryRecvError</source>
          <target state="translated">TryRecvError</target>
        </trans-unit>
        <trans-unit id="ffa19b2195d0c15e9339c99460878fe4f010d76d" translate="yes" xml:space="preserve">
          <source>TryReserveError</source>
          <target state="translated">TryReserveError</target>
        </trans-unit>
        <trans-unit id="7b782adc98cd68cba60f49733fd7fc4e8ce78c2c" translate="yes" xml:space="preserve">
          <source>TrySendError</source>
          <target state="translated">TrySendError</target>
        </trans-unit>
        <trans-unit id="bb111acc067364e9c3571b77d0ce5c4a9c6b3124" translate="yes" xml:space="preserve">
          <source>Trying to implement this scenario using our definition of &lt;code&gt;List&lt;/code&gt; with &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; won&amp;rsquo;t work, as shown in Listing 15-17:</source>
          <target state="translated">우리의 정의를 사용하여이 시나리오를 구현하려고 &lt;code&gt;List&lt;/code&gt; 에 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 목록 15 ~ 17과 같이하지 않습니다 일 :</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="5518f0873d902287241e5e83188a303861d5a9e6" translate="yes" xml:space="preserve">
          <source>Tuple Layout</source>
          <target state="translated">튜플 레이아웃</target>
        </trans-unit>
        <trans-unit id="11dd41e6851bdf449646a773272c37c50a284fc9" translate="yes" xml:space="preserve">
          <source>Tuple and tuple indexing expressions</source>
          <target state="translated">튜플 및 튜플 인덱싱 표현식</target>
        </trans-unit>
        <trans-unit id="6bdf2a89da03771b9bc590f650c8c5b6c77c5197" translate="yes" xml:space="preserve">
          <source>Tuple expression</source>
          <target state="translated">튜플 표현</target>
        </trans-unit>
        <trans-unit id="a63a11d9cdfd9d84d9c0b5569d554b9e83dcf1cc" translate="yes" xml:space="preserve">
          <source>Tuple expression attributes</source>
          <target state="translated">튜플 표현식 속성</target>
        </trans-unit>
        <trans-unit id="e822aa7ad790f9164d76dd24bd82039b2ac65758" translate="yes" xml:space="preserve">
          <source>Tuple expressions</source>
          <target state="translated">튜플 표현식</target>
        </trans-unit>
        <trans-unit id="49e52f54a16d5e893978d9d7c233cca906e4a8cd" translate="yes" xml:space="preserve">
          <source>Tuple expressions are written by listing the &lt;a href=&quot;../expressions&quot;&gt;operands&lt;/a&gt; in a parenthesized, comma-separated list. 1-ary tuple expressions require a comma after their operand to be disambiguated with a &lt;a href=&quot;grouped-expr&quot;&gt;parenthetical expression&lt;/a&gt;.</source>
          <target state="translated">튜플 식은 괄호로 묶인 쉼표로 구분 된 목록에 &lt;a href=&quot;../expressions&quot;&gt;피연산자&lt;/a&gt; 를 나열하여 작성됩니다 . 1 항 튜플 표현식은 피연산자 뒤에 쉼표가 있어야 &lt;a href=&quot;grouped-expr&quot;&gt;괄호 표현식&lt;/a&gt; 으로 명확 해 집니다.</target>
        </trans-unit>
        <trans-unit id="65e413cd44223377d7cfb3699dad2f2341e4e6ba" translate="yes" xml:space="preserve">
          <source>Tuple expressions evaluate into &lt;a href=&quot;../types/tuple&quot;&gt;tuple values&lt;/a&gt; with the operands initializing the elements of the tuple.</source>
          <target state="translated">튜플 표현식은 &lt;a href=&quot;../types/tuple&quot;&gt;튜플&lt;/a&gt; 의 요소를 초기화하는 피연산자를 사용하여 튜플 값 으로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="f601e94cafc9d12d8593dd02c6d703d40de35c4d" translate="yes" xml:space="preserve">
          <source>Tuple index</source>
          <target state="translated">튜플 인덱스</target>
        </trans-unit>
        <trans-unit id="b17e1ada42d80816617817c68a5ec792352c6c67" translate="yes" xml:space="preserve">
          <source>Tuple index expressions are written as an operand, &lt;code&gt;.&lt;/code&gt;, and a tuple index. The index must be written as a &lt;a href=&quot;../tokens#integer-literals&quot;&gt;decimal literal&lt;/a&gt; with no leading zeros, underscores, or suffix. The operand must have the type of a tuple or tuple struct. If the tuple index is not an element of the tuple or tuple struct, it is a compiler error.</source>
          <target state="translated">튜플 인덱스 식은 피연산자로 작성됩니다 &lt;code&gt;.&lt;/code&gt; 및 튜플 인덱스. 인덱스는 선행 0, 밑줄 또는 접미사가없는 &lt;a href=&quot;../tokens#integer-literals&quot;&gt;10 진수 리터럴&lt;/a&gt; 로 작성되어야합니다 . 피연산자는 튜플 또는 튜플 구조체 유형이어야합니다. 튜플 인덱스가 튜플 또는 튜플 구조체의 요소가 아니면 컴파일러 오류입니다.</target>
        </trans-unit>
        <trans-unit id="fe6c1f43b44b32fa35dca7937a6775d19792506c" translate="yes" xml:space="preserve">
          <source>Tuple indexing</source>
          <target state="translated">튜플 인덱싱</target>
        </trans-unit>
        <trans-unit id="44dc4b3b01b16ad2661df0966d7c7a1cf905b8b9" translate="yes" xml:space="preserve">
          <source>Tuple indexing expressions</source>
          <target state="translated">튜플 인덱싱 표현식</target>
        </trans-unit>
        <trans-unit id="9e4c13ade8d660c6335dcf428421b9b28b1656d1" translate="yes" xml:space="preserve">
          <source>Tuple indexing expressions evaluate like &lt;a href=&quot;field-expr#field-access-expressions&quot;&gt;field access expressions&lt;/a&gt;, but access elements of &lt;a href=&quot;../types/tuple&quot;&gt;tuples&lt;/a&gt; or &lt;a href=&quot;../types/struct&quot;&gt;tuple structs&lt;/a&gt;.</source>
          <target state="translated">튜플 인덱싱 식은 &lt;a href=&quot;field-expr#field-access-expressions&quot;&gt;필드 액세스 식과&lt;/a&gt; 같이 평가 되지만 &lt;a href=&quot;../types/tuple&quot;&gt;튜플&lt;/a&gt; 또는 &lt;a href=&quot;../types/struct&quot;&gt;튜플 구조체의&lt;/a&gt; 요소에 액세스 합니다 .</target>
        </trans-unit>
        <trans-unit id="b8a1d058f14f452a93d10da089ec69f4c32d794e" translate="yes" xml:space="preserve">
          <source>Tuple indices are compared with the literal token directly. Tuple indices start with &lt;code&gt;0&lt;/code&gt; and each successive index increments the value by &lt;code&gt;1&lt;/code&gt; as a decimal value. Thus, only decimal values will match, and the value must not have any extra &lt;code&gt;0&lt;/code&gt; prefix characters.</source>
          <target state="translated">튜플 인덱스는 리터럴 토큰과 직접 비교됩니다. 튜플 인덱스는 &lt;code&gt;0&lt;/code&gt; 으로 시작 하고 각 연속 인덱스는 값을 10 진수 값 으로 &lt;code&gt;1&lt;/code&gt; 씩 증가시킵니다 . 따라서 10 진수 값만 일치하며 값에는 추가 &lt;code&gt;0&lt;/code&gt; 접두사 문자 가 없어야 합니다.</target>
        </trans-unit>
        <trans-unit id="f28c59e960977888e94a3c34b0278e6e00c6936d" translate="yes" xml:space="preserve">
          <source>Tuple patterns</source>
          <target state="translated">튜플 패턴</target>
        </trans-unit>
        <trans-unit id="49d48b16cda97c82ccd41f82c8b675a2db8b4116" translate="yes" xml:space="preserve">
          <source>Tuple patterns match tuple values that match all criteria defined by its subpatterns. They are also used to &lt;a href=&quot;#destructuring&quot;&gt;destructure&lt;/a&gt; a tuple.</source>
          <target state="translated">튜플 패턴은 하위 패턴으로 정의 된 모든 기준과 일치하는 튜플 값과 일치합니다. 또한 튜플 을 &lt;a href=&quot;#destructuring&quot;&gt;구조화&lt;/a&gt; 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0d60a4a77a7ad9b86665dc5ec42ea14f2698ee75" translate="yes" xml:space="preserve">
          <source>Tuple patterns match tuple values that match all criteria defined by its subpatterns. They are also used to &lt;a href=&quot;patterns#destructuring&quot;&gt;destructure&lt;/a&gt; a tuple.</source>
          <target state="translated">튜플 패턴은 하위 패턴으로 정의 된 모든 기준과 일치하는 튜플 값과 일치합니다. 그들은 또한하는 데 사용됩니다 &lt;a href=&quot;patterns#destructuring&quot;&gt;destructure&lt;/a&gt; 튜플을.</target>
        </trans-unit>
        <trans-unit id="f4691e7b0b597791c415f166cd1397c0daec1163" translate="yes" xml:space="preserve">
          <source>Tuple struct expression</source>
          <target state="translated">튜플 구조체 표현</target>
        </trans-unit>
        <trans-unit id="ea9f0838dcbcc88a01e222d90f53e8f39880136f" translate="yes" xml:space="preserve">
          <source>Tuple struct patterns</source>
          <target state="translated">튜플 구조체 패턴</target>
        </trans-unit>
        <trans-unit id="91a08356932d9cf1d09320f96dfca3ba26d2fc8a" translate="yes" xml:space="preserve">
          <source>Tuple struct patterns match tuple struct and enum values that match all criteria defined by its subpatterns. They are also used to &lt;a href=&quot;#destructuring&quot;&gt;destructure&lt;/a&gt; a tuple struct or enum value.</source>
          <target state="translated">튜플 구조체 패턴은 하위 패턴으로 정의 된 모든 기준과 일치하는 튜플 구조체 및 열거 형 값과 일치합니다. 또한 튜플 구조체 또는 열거 형 값 을 &lt;a href=&quot;#destructuring&quot;&gt;구조화&lt;/a&gt; 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6ce23bf97599891184ee6af65a034650dc03427a" translate="yes" xml:space="preserve">
          <source>Tuple struct patterns match tuple struct and enum values that match all criteria defined by its subpatterns. They are also used to &lt;a href=&quot;patterns#destructuring&quot;&gt;destructure&lt;/a&gt; a tuple struct or enum value.</source>
          <target state="translated">튜플 구조체 패턴은 해당 서브 패턴에 의해 정의 된 모든 기준과 일치하는 튜플 구조체 및 열거 형 값과 일치합니다. 또한 튜플 구조체 또는 열거 형 값 을 &lt;a href=&quot;patterns#destructuring&quot;&gt;구조화&lt;/a&gt; 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="dd28158a620f360ba4aa0c759eb104e4dede6329" translate="yes" xml:space="preserve">
          <source>Tuple structs are instantiated in the same way as tuples themselves, except with the struct's name as a prefix: &lt;code&gt;Foo(123, false, 0.1)&lt;/code&gt;.</source>
          <target state="translated">튜플 구조체는 접두사로 구조체 이름을 사용하는 것을 제외하고 튜플 자체와 동일한 방식으로 인스턴스화됩니다 : &lt;code&gt;Foo(123, false, 0.1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="985c4283e220405d4d0ac504a38671b8b680d3c5" translate="yes" xml:space="preserve">
          <source>Tuple structs are similar to regular structs, but its fields have no names. They are used like tuples, with deconstruction possible via &lt;code&gt;let TupleStruct(x, y) = foo;&lt;/code&gt; syntax. For accessing individual variables, the same syntax is used as with regular tuples, namely &lt;code&gt;foo.0&lt;/code&gt;, &lt;code&gt;foo.1&lt;/code&gt;, etc, starting at zero.</source>
          <target state="translated">튜플 구조체는 일반 구조체와 비슷하지만 해당 필드에는 이름이 없습니다. 그것들은 &lt;code&gt;let TupleStruct(x, y) = foo;&lt;/code&gt; 를 통해 해체가 가능한 튜플처럼 사용됩니다 . 통사론. 개별 변수에 액세스하기 위해 일반 튜플과 동일한 구문, 즉 &lt;code&gt;foo.0&lt;/code&gt; , &lt;code&gt;foo.1&lt;/code&gt; 등이 0에서 시작하여 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="405d7b4bc4604c6657b54f4846e0560006e9fc0e" translate="yes" xml:space="preserve">
          <source>Tuple type</source>
          <target state="translated">튜플 타입</target>
        </trans-unit>
        <trans-unit id="5501f69a4f42fb8e135b4df10c2273778be704fd" translate="yes" xml:space="preserve">
          <source>Tuple types</source>
          <target state="translated">튜플 유형</target>
        </trans-unit>
        <trans-unit id="5e273646744d8620cb13d8fba10b333bc84bed1e" translate="yes" xml:space="preserve">
          <source>Tuple types and values are denoted by listing the types or values of their elements, respectively, in a parenthesized, comma-separated list.</source>
          <target state="translated">튜플 유형 및 값은 괄호로 묶은 쉼표로 구분 된 목록에 해당 요소의 유형 또는 값을 각각 나열하여 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a1babd8f3b1a5b3b8804a04ea58994b24b061e4b" translate="yes" xml:space="preserve">
          <source>Tuple types are written by listing the types of their elements in a parenthesized, comma-separated list. 1-ary tuples require a comma after their element type to be disambiguated with a &lt;a href=&quot;../types#parenthesized-types&quot;&gt;parenthesized type&lt;/a&gt;.</source>
          <target state="translated">튜플 유형은 괄호로 묶인 쉼표로 구분 된 목록에 요소 유형을 나열하여 작성됩니다. 1 항 튜플은 &lt;a href=&quot;../types#parenthesized-types&quot;&gt;괄호로 묶인 유형&lt;/a&gt; 으로 구분하기 위해 요소 유형 뒤에 쉼표가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="3fbd57dd63bac7c82834159ddc9ea56e1515ece9" translate="yes" xml:space="preserve">
          <source>Tuple types, if each component also implements &lt;code&gt;Clone&lt;/code&gt; (e.g., &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;(i32, bool)&lt;/code&gt;)</source>
          <target state="translated">각 구성 요소가 &lt;code&gt;Clone&lt;/code&gt; 를 구현하는 경우 튜플 유형 (예 : &lt;code&gt;()&lt;/code&gt; , &lt;code&gt;(i32, bool)&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="bd89c408cfdec88fd6d8e898f3566b701ea35d3a" translate="yes" xml:space="preserve">
          <source>Tuple types, if each component also implements &lt;code&gt;Copy&lt;/code&gt; (e.g., &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;(i32, bool)&lt;/code&gt;)</source>
          <target state="translated">튜플 유형 (각 구성 요소가 &lt;code&gt;Copy&lt;/code&gt; (예 : &lt;code&gt;()&lt;/code&gt; , &lt;code&gt;(i32, bool)&lt;/code&gt; ) 도 구현하는 경우 )</target>
        </trans-unit>
        <trans-unit id="56d624bd930abb83c2a720d48bf858a7d49eb690" translate="yes" xml:space="preserve">
          <source>Tuples are &lt;em&gt;finite&lt;/em&gt;. In other words, a tuple has a length. Here's a tuple of length &lt;code&gt;3&lt;/code&gt;:</source>
          <target state="translated">튜플은 &lt;em&gt;유한&lt;/em&gt; 합니다. 즉, 튜플의 길이는 길다. 길이 &lt;code&gt;3&lt;/code&gt; 의 튜플은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4da05b6b2dc1fb19e334d246d97430b523feb378" translate="yes" xml:space="preserve">
          <source>Tuples are &lt;em&gt;heterogeneous&lt;/em&gt;. This means that each element of the tuple can have a different type. In that tuple above, it has the type:</source>
          <target state="translated">튜플은 &lt;em&gt;이기종&lt;/em&gt; 입니다. 이것은 튜플의 각 요소가 다른 유형을 가질 수 있음을 의미합니다. 위의 튜플에서 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="567f8079007690271f5a29cda47d067992841b99" translate="yes" xml:space="preserve">
          <source>Tuples are a &lt;em&gt;sequence&lt;/em&gt;. This means that they can be accessed by position; this is called 'tuple indexing', and it looks like this:</source>
          <target state="translated">튜플은 &lt;em&gt;시퀀스&lt;/em&gt; 입니다. 이는 위치별로 액세스 할 수 있음을 의미합니다. 이것을 '튜플 인덱싱'이라고하며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e91ee0fad8731c0386a059fa3bf0652dd08c64d3" translate="yes" xml:space="preserve">
          <source>Tuples are often used as a return type when you want to return more than one value:</source>
          <target state="translated">튜플은 둘 이상의 값을 반환하려는 경우 종종 반환 유형으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d7ee3ba750e08e0013c45b2b001ce78e8459fa90" translate="yes" xml:space="preserve">
          <source>Tuples are written by enclosing zero or more comma-separated expressions in parentheses. They are used to create &lt;a href=&quot;../types/tuple&quot;&gt;tuple-typed&lt;/a&gt; values.</source>
          <target state="translated">튜플은 0 개 이상의 쉼표로 구분 된 표현식을 괄호로 묶어 작성합니다. &lt;a href=&quot;../types/tuple&quot;&gt;튜플 형식의&lt;/a&gt; 값 을 만드는 데 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="5fb8ee22cf29120bf8f87bd0e3ee7ebd9949b96b" translate="yes" xml:space="preserve">
          <source>Tuples do not have any guarantees about their layout.</source>
          <target state="translated">튜플은 레이아웃에 대해 보증하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e0a1a935961bff4d0e0f65eae726bdf533b1fbc7" translate="yes" xml:space="preserve">
          <source>Tuples, if they only contain types that also implement &lt;code&gt;Copy&lt;/code&gt;. For example, &lt;code&gt;(i32, i32)&lt;/code&gt; implements &lt;code&gt;Copy&lt;/code&gt;, but &lt;code&gt;(i32, String)&lt;/code&gt; does not.</source>
          <target state="translated">튜플, &lt;code&gt;Copy&lt;/code&gt; 를 구현하는 유형 만 포함하는 경우 . 예를 들어 &lt;code&gt;(i32, i32)&lt;/code&gt; 는 &lt;code&gt;Copy&lt;/code&gt; 를 구현 하지만 &lt;code&gt;(i32, String)&lt;/code&gt; 은 구현 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf3ce6296bd35ecede807c2ca855fee144afacb9" translate="yes" xml:space="preserve">
          <source>Tuples, if they only contain types that are also &lt;code&gt;Copy&lt;/code&gt;. For example, &lt;code&gt;(i32, i32)&lt;/code&gt; is &lt;code&gt;Copy&lt;/code&gt;, but &lt;code&gt;(i32, String)&lt;/code&gt; is not.</source>
          <target state="translated">튜플은, 그들은 단지 또한 종류가 포함 된 경우 &lt;code&gt;Copy&lt;/code&gt; . 예를 들어 &lt;code&gt;(i32, i32)&lt;/code&gt; 는 &lt;code&gt;Copy&lt;/code&gt; 이지만 &lt;code&gt;(i32, String)&lt;/code&gt; 은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f9c67af2890eabc2460069a200a1d4229437528f" translate="yes" xml:space="preserve">
          <source>Tuples, where a tuple is a coercion site to type &lt;code&gt;(U_0, U_1, ..., U_n)&lt;/code&gt;. Each sub-expression is a coercion site to the respective type, e.g. the zeroth sub-expression is a coercion site to type &lt;code&gt;U_0&lt;/code&gt;.</source>
          <target state="translated">튜플은 튜플이 &lt;code&gt;(U_0, U_1, ..., U_n)&lt;/code&gt; 을 입력 할 수있는 강제 사이트 입니다. 각 하위 표현은 각 유형에 대한 강제 사이트입니다. 예를 들어, 0 번째 하위 표현은 &lt;code&gt;U_0&lt;/code&gt; 유형에 대한 강제 사이트 입니다.</target>
        </trans-unit>
        <trans-unit id="c9853aa9de5add5fa51a4530e193cc7279fd6159" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">차례 &lt;a href=&quot;../../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;../struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e89ab8db9a13e916878d1aff18816e183dfae8d6" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">차례 &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7311ea0eb58a505bdf5f01b88b3339c4b7cd8b3" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">차례 &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b38a71dfcaefc79a39b01d00754205648079aa2" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">차례 &lt;a href=&quot;../struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;../../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6fe97f664cc043b9cae686cc00711fc73ef1df08" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">차례 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fbea64da5a5f06d75e0a8af0090b3b0e2a08380" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">차례 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4669fd8f77a02ec1c266c7fe545791bb7885dad1" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">차례 &lt;a href=&quot;struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b09625451991a5b8e805da34776aaedc90525fbd" translate="yes" xml:space="preserve">
          <source>Turn a &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">차례 &lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="54437abef1f3840afb67899d2d515749e44d9fef" translate="yes" xml:space="preserve">
          <source>Turn a [&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;] into a [&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;].</source>
          <target state="translated">[ &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ]를 [ &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; ]로 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="e6b58be63cc031a2c0fb9a41ef4a5c4c544f30d9" translate="yes" xml:space="preserve">
          <source>Turn a [&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;] into a [&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;].</source>
          <target state="translated">[ &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; ]를 [ &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ] 로 바꾸 십시오 .</target>
        </trans-unit>
        <trans-unit id="68fccb5986b95d1769fe3ac2f5db1e4528fbe17a" translate="yes" xml:space="preserve">
          <source>Turning Our Single-Threaded Server into a Multithreaded Server</source>
          <target state="translated">단일 스레드 서버를 다중 스레드 서버로 전환</target>
        </trans-unit>
        <trans-unit id="b859b7ff96007e824952102a2b6cf7f2532bb6f5" translate="yes" xml:space="preserve">
          <source>Turning a &lt;code&gt;*mut T&lt;/code&gt; into an &lt;code&gt;&amp;amp;mut T&lt;/code&gt;:</source>
          <target state="translated">터닝 &lt;code&gt;*mut T&lt;/code&gt; 로 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="92f32c54d91cd32dab86c92433ff5bf59fbe670a" translate="yes" xml:space="preserve">
          <source>Turning a &lt;code&gt;Vec&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; into a &lt;code&gt;Vec&amp;lt;Option&amp;lt;&amp;amp;T&amp;gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">선삭 &lt;code&gt;Vec&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; (A) 내로 &lt;code&gt;Vec&amp;lt;Option&amp;lt;&amp;amp;T&amp;gt;&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="25f375d70a4ba87d59382df0fccc95f55dd8020a" translate="yes" xml:space="preserve">
          <source>Turning a &lt;code&gt;fn&lt;/code&gt; into a &lt;code&gt;const fn&lt;/code&gt; has no effect on run-time uses of that function.</source>
          <target state="translated">터닝 &lt;code&gt;fn&lt;/code&gt; 에 &lt;code&gt;const fn&lt;/code&gt; 그 함수의 실행 시간의 사용에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ddddd1c6a422bfc2e73b1e1e06d4513f4b671ef3" translate="yes" xml:space="preserve">
          <source>Turning a pointer into a &lt;code&gt;usize&lt;/code&gt;:</source>
          <target state="translated">포인터를 &lt;code&gt;usize&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0cfcb75a89ff8f3d42e0969a81b68c58ff41ffed" translate="yes" xml:space="preserve">
          <source>Turning a pointer into a function pointer. This is &lt;em&gt;not&lt;/em&gt; portable to machines where function pointers and data pointers have different sizes.</source>
          <target state="translated">포인터를 함수 포인터로 바꾸기 함수 포인터와 데이터 포인터의 크기가 다른 기계에는 이식성 이 &lt;em&gt;없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="406e60e2392b6e162c75155bdd0eec0802166101" translate="yes" xml:space="preserve">
          <source>Turning an &lt;code&gt;&amp;amp;mut T&lt;/code&gt; into an &lt;code&gt;&amp;amp;mut U&lt;/code&gt;:</source>
          <target state="translated">켜기 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 로 &lt;code&gt;&amp;amp;mut U&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b7709a825d906324651f42904d312bfc3d9cfdce" translate="yes" xml:space="preserve">
          <source>Turning an &lt;code&gt;&amp;amp;str&lt;/code&gt; into an &lt;code&gt;&amp;amp;[u8]&lt;/code&gt;:</source>
          <target state="translated">선삭 &lt;code&gt;&amp;amp;str&lt;/code&gt; 로 &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8fe665706a3a9d23c3f80f786fb6f659e7dafb3b" translate="yes" xml:space="preserve">
          <source>Turning raw bytes(&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;) to &lt;code&gt;u32&lt;/code&gt;, &lt;code&gt;f64&lt;/code&gt;, etc.:</source>
          <target state="translated">원시 바이트 ( &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; )를 &lt;code&gt;u32&lt;/code&gt; , &lt;code&gt;f64&lt;/code&gt; 등으로 변환 :</target>
        </trans-unit>
        <trans-unit id="45cfabf1744551752d0d316f8226b7949182c80d" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Arc&lt;/code&gt;s are equal if their inner values are equal, even if they are stored in different allocation.</source>
          <target state="translated">두 개의 &lt;code&gt;Arc&lt;/code&gt; 는 서로 다른 할당에 저장되어 있어도 내부 값이 같으면 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1e4a5ffe0d58bc942e71a31a403ac137dbf193dd" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Arc&lt;/code&gt;s are equal if their inner values are equal.</source>
          <target state="translated">내부 값이 같으면 두 개의 &lt;code&gt;Arc&lt;/code&gt; 가 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b0340dc9882895d2ed9f18ec41d4ee9ceaf4e0c" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Arc&lt;/code&gt;s are unequal if their inner values are unequal.</source>
          <target state="translated">내부 값이 같지 않으면 두 개의 &lt;code&gt;Arc&lt;/code&gt; 가 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77c963714f423503919254b2ffd83b6fa90a298e" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Rc&lt;/code&gt;s are equal if their inner values are equal, even if they are stored in different allocation.</source>
          <target state="translated">두 &lt;code&gt;Rc&lt;/code&gt; 는 서로 다른 할당에 저장되어 있더라도 내부 값이 같으면 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d6a2d18514777aaae37a7ce067b908310bbd6b4b" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Rc&lt;/code&gt;s are equal if their inner values are equal.</source>
          <target state="translated">내부 값이 같으면 두 개의 &lt;code&gt;Rc&lt;/code&gt; 가 같습니다.</target>
        </trans-unit>
        <trans-unit id="2fa5c112e4e91cdb91570c34d930cf27ff1cdefa" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Rc&lt;/code&gt;s are unequal if their inner values are unequal.</source>
          <target state="translated">내부 값이 같지 않으면 두 개의 &lt;code&gt;Rc&lt;/code&gt; 가 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2b4b2f527e82e5d4b1ed0e9743d509787616d686" translate="yes" xml:space="preserve">
          <source>Two associated items (like methods, associated types, associated functions, etc.) were defined with the same identifier.</source>
          <target state="translated">두 개의 관련 항목 (메서드, 관련 유형, 관련 함수 등)이 동일한 식별자로 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="f479794ce7a491842f3bc3c9a27aca16db4ad3d3" translate="yes" xml:space="preserve">
          <source>Two empty sequences are lexicographically equal.</source>
          <target state="translated">두 개의 빈 시퀀스는 사 전적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="026acb3ca4aa61acf271a2918c10ebc97e741248" translate="yes" xml:space="preserve">
          <source>Two examples of simple paths consisting of only identifier segments:</source>
          <target state="translated">식별자 세그먼트로만 구성된 간단한 경로의 두 가지 예 :</target>
        </trans-unit>
        <trans-unit id="0cd83d672a615733082e8ee7f56c39b0af561a3e" translate="yes" xml:space="preserve">
          <source>Two items of the same name cannot be imported without rebinding one of the items under a new local name.</source>
          <target state="translated">같은 이름의 두 항목은 새 로컬 이름으로 항목 중 하나를 리 바인드하지 않으면 가져올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cbb02c3e2b1b62256b2dccb2ec1aec1fddd7391c" translate="yes" xml:space="preserve">
          <source>Two kind of item &lt;em&gt;declarations&lt;/em&gt; are allowed in external blocks: &lt;a href=&quot;functions&quot;&gt;functions&lt;/a&gt; and &lt;a href=&quot;static-items&quot;&gt;statics&lt;/a&gt;. Calling functions or accessing statics that are declared in external blocks is only allowed in an &lt;code&gt;unsafe&lt;/code&gt; context.</source>
          <target state="translated">두 종류의 항목 &lt;em&gt;선언&lt;/em&gt; 이 외부 블록에서 허용됩니다 : &lt;a href=&quot;functions&quot;&gt;함수&lt;/a&gt; 및 &lt;a href=&quot;static-items&quot;&gt;정적&lt;/a&gt; . 외부 블록에서 선언 된 함수를 호출하거나 정적에 액세스하는 것은 &lt;code&gt;unsafe&lt;/code&gt; 컨텍스트 에서만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f6d0f0b6138243f294ae08264cc55ed1bd1ca167" translate="yes" xml:space="preserve">
          <source>Two lifetimes cannot have the same name. To fix this example, change the second &lt;code&gt;'a&lt;/code&gt; lifetime into something else (&lt;code&gt;'c&lt;/code&gt; for example):</source>
          <target state="translated">두 개의 수명은 같은 이름을 가질 수 없습니다. 이 예제를 수정하려면 두 번째 &lt;code&gt;'a&lt;/code&gt; 수명을 다른 것으로 변경하십시오 ( 예 : &lt;code&gt;'c&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="30c944c513e67b8c4ff5047db8e7ab8f3c379bad" translate="yes" xml:space="preserve">
          <source>Two or more pointers access the same data at the same time.</source>
          <target state="translated">둘 이상의 포인터가 동시에 동일한 데이터에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="ea818e0ad4fe2dcf3d6dd4c02bacf808745d38d6" translate="yes" xml:space="preserve">
          <source>Two possibilities are available to solve this issue:</source>
          <target state="translated">이 문제를 해결하기 위해 두 가지 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="00651d0b6fd0e23f3452ef97aaddc1cda2303a0d" translate="yes" xml:space="preserve">
          <source>Two sequences are compared element by element.</source>
          <target state="translated">두 시퀀스는 요소별로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="9e61db6f0549ccd99ae56429864c2f4cbe98bb50" translate="yes" xml:space="preserve">
          <source>Two such examples are macros and &lt;code&gt;#[cfg]&lt;/code&gt; environments.</source>
          <target state="translated">이러한 두 가지 예는 매크로 및 &lt;code&gt;#[cfg]&lt;/code&gt; 환경입니다.</target>
        </trans-unit>
        <trans-unit id="9d8a406e3a91b6f18f7fee9fffccd411cd7bea0e" translate="yes" xml:space="preserve">
          <source>Two tests that pass! Now let&amp;rsquo;s see what happens to our test results when we introduce a bug in our code. Let&amp;rsquo;s change the implementation of the &lt;code&gt;can_hold&lt;/code&gt; method by replacing the greater than sign with a less than sign when it compares the widths:</source>
          <target state="translated">통과하는 두 가지 테스트! 이제 코드에 버그를 도입 할 때 테스트 결과가 어떻게되는지 봅시다. 너비를 비교할 때보 다 큼 기호를보다 작음 기호로 바꾸어 &lt;code&gt;can_hold&lt;/code&gt; 메소드 의 구현을 변경해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="6831c93d3c0041ecff78583892f51cefdc18f74a" translate="yes" xml:space="preserve">
          <source>Two things are important to note about this function:</source>
          <target state="translated">이 기능에 대해 두 가지 중요한 점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d73651bf2df8af467f41b29a872952ef24a40245" translate="yes" xml:space="preserve">
          <source>Two trait implementations overlap when there is a non-empty intersection of the traits the implementation is for, the implementations can be instantiated with the same type.</source>
          <target state="translated">구현에 대한 특성이 비어 있지 않은 교차가있는 경우 두 가지 특성 구현이 겹치므로 동일한 유형으로 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45049ec7ea97abec9bd8269a665797ccca478bf9" translate="yes" xml:space="preserve">
          <source>Two trait object types alias each other if the base traits alias each other and if the sets of auto traits are the same and the lifetime bounds are the same. For example, &lt;code&gt;dyn Trait + Send + UnwindSafe&lt;/code&gt; is the same as &lt;code&gt;dyn Trait + UnwindSafe + Send&lt;/code&gt;.</source>
          <target state="translated">기본 특성이 서로 별칭을 지정하고 자동 특성 집합이 동일하고 수명 경계가 동일한 경우 두 특성 개체 유형이 서로 별칭을 지정합니다. 예를 들어, &lt;code&gt;dyn Trait + Send + UnwindSafe&lt;/code&gt; 는 &lt;code&gt;dyn Trait + UnwindSafe + Send&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="7b6094fd54b67e7d276ce315b3b79ffc2dd18ae2" translate="yes" xml:space="preserve">
          <source>Two trait object types alias each other if the base traits alias each other and if the sets of auto traits are the same and the lifetime bounds are the same. For example, &lt;code&gt;dyn Trait + Send + UnwindSafe&lt;/code&gt; is the same as &lt;code&gt;dyn Trait + Unwindsafe + Send&lt;/code&gt;.</source>
          <target state="translated">기본 특성이 서로 별명을 설정하고 자동 특성 세트가 동일하고 수명 한계가 동일한 경우 두 특성 오브젝트 유형이 서로 별명을 지정합니다. 예를 들어, &lt;code&gt;dyn Trait + Send + UnwindSafe&lt;/code&gt; 는 &lt;code&gt;dyn Trait + Unwindsafe + Send&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="0d078a0dedfa986439265f5fefabc817ba279445" translate="yes" xml:space="preserve">
          <source>Two traits, &lt;a href=&quot;../std/marker/trait.unsize&quot;&gt;&lt;code&gt;Unsize&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/ops/trait.coerceunsized&quot;&gt;&lt;code&gt;CoerceUnsized&lt;/code&gt;&lt;/a&gt;, are used to assist in this process and expose it for library use. The following coercions are built-ins and, if &lt;code&gt;T&lt;/code&gt; can be coerced to &lt;code&gt;U&lt;/code&gt; with one of them, then an implementation of &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt; will be provided:</source>
          <target state="translated">&lt;a href=&quot;../std/marker/trait.unsize&quot;&gt; &lt;code&gt;Unsize&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../std/ops/trait.coerceunsized&quot;&gt; &lt;code&gt;CoerceUnsized&lt;/code&gt; 의&lt;/a&gt; 두 가지 특성 이이 프로세스를 지원하고 라이브러리 사용을 위해 노출하는 데 사용됩니다. 경우 다음과 강제 변환은 기능을 내장하고 있습니다 &lt;code&gt;T&lt;/code&gt; 는 강제 변환 할 수있다 &lt;code&gt;U&lt;/code&gt; 그들 중 하나의 다음 구현 &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; 에 대한 &lt;code&gt;T&lt;/code&gt; 가 제공 될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="0c40881391e5533daaab739e69ccda2bb7bda270" translate="yes" xml:space="preserve">
          <source>TyCtor(&lt;code&gt;T&lt;/code&gt;) to TyCtor(&lt;code&gt;U&lt;/code&gt;), where TyCtor(&lt;code&gt;T&lt;/code&gt;) is one of</source>
          <target state="translated">TyCtor ( &lt;code&gt;T&lt;/code&gt; ) ~ TyCtor ( &lt;code&gt;U&lt;/code&gt; )에서 TyCtor ( &lt;code&gt;T&lt;/code&gt; )는</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="8893ac4ddfe0ea4688a44afc0ddfe4ebc76a84ef" translate="yes" xml:space="preserve">
          <source>Type &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; represents an optional value: every &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is either &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; and contains a value, or &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, and does not. &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; types are very common in Rust code, as they have a number of uses:</source>
          <target state="translated">Type &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 은 선택적 값을 나타냅니다. 모든 &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; 이며 값을 포함하거나 &lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이며 그렇지 않습니다. &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 유형은 여러 가지 용도로 Rust 코드에서 매우 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="e705c5fc187594d957e6b2868fc24eb8ee56f315" translate="yes" xml:space="preserve">
          <source>Type Definition std::alloc::LayoutErr</source>
          <target state="translated">유형 정의 std :: alloc :: LayoutErr</target>
        </trans-unit>
        <trans-unit id="5a34cc9264aacb6462265b18d25bcf726faf398f" translate="yes" xml:space="preserve">
          <source>Type Definition std::fmt::Result</source>
          <target state="translated">유형 정의 std :: fmt :: Result</target>
        </trans-unit>
        <trans-unit id="34dd3e846f6d75301a90ce0c190a60bbb2f75015" translate="yes" xml:space="preserve">
          <source>Type Definition std::io::Result</source>
          <target state="translated">유형 정의 std :: io :: Result</target>
        </trans-unit>
        <trans-unit id="46f6920a49ecfbe5727cafe69a86a93c6dc323b4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::blkcnt_t</source>
          <target state="translated">타입 정의 std :: os :: linux :: raw :: blkcnt_t</target>
        </trans-unit>
        <trans-unit id="85fbcc37c53b78d2794e588bd5f55d25d53b121b" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::blksize_t</source>
          <target state="translated">타입 정의 std :: os :: linux :: raw :: blksize_t</target>
        </trans-unit>
        <trans-unit id="e2606fd8324f1985d42d98f82ef97532070eae3e" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::dev_t</source>
          <target state="translated">타입 정의 std :: os :: linux :: raw :: dev_t</target>
        </trans-unit>
        <trans-unit id="1a0725c0d449cfcc82b033154c822ab6aa94cb70" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::ino_t</source>
          <target state="translated">타입 정의 std :: os :: linux :: raw :: ino_t</target>
        </trans-unit>
        <trans-unit id="96a7fc18b0419da7fc9a515e767bed1bfbc9562c" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::mode_t</source>
          <target state="translated">타입 정의 std :: os :: linux :: raw :: mode_t</target>
        </trans-unit>
        <trans-unit id="75a060e0f5140a7dabbcb1ba8000909c3c0378d8" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::nlink_t</source>
          <target state="translated">타입 정의 std :: os :: linux :: raw :: nlink_t</target>
        </trans-unit>
        <trans-unit id="7ae7bb16976469a8ad4e67f2c0d76a2afe6847e7" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::off_t</source>
          <target state="translated">타입 정의 std :: os :: linux :: raw :: off_t</target>
        </trans-unit>
        <trans-unit id="76556b9aa9b1d76aecac20fd90dee8158aed1fa4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::pthread_t</source>
          <target state="translated">타입 정의 std :: os :: linux :: raw :: pthread_t</target>
        </trans-unit>
        <trans-unit id="c8140af217e68caacdab8d2aaef2318b6e02ba66" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::linux::raw::time_t</source>
          <target state="translated">타입 정의 std :: os :: linux :: raw :: time_t</target>
        </trans-unit>
        <trans-unit id="d80e70a5e9f44648db2fa12eba538e96a084706b" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_char</source>
          <target state="translated">타입 정의 std :: os :: raw :: c_char</target>
        </trans-unit>
        <trans-unit id="47268ec268f5e51266c8c9b25e903a966387595d" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_double</source>
          <target state="translated">타입 정의 std :: os :: raw :: c_double</target>
        </trans-unit>
        <trans-unit id="167acfa92657a06bc69cb3f91777f380110e4dc9" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_float</source>
          <target state="translated">타입 정의 std :: os :: raw :: c_float</target>
        </trans-unit>
        <trans-unit id="c27fd9199e90c2472f965bdc0cca23d6c8c570f4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_int</source>
          <target state="translated">타입 정의 std :: os :: raw :: c_int</target>
        </trans-unit>
        <trans-unit id="19f693eccac3c497abf741d0f8baed1d19e53f4b" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_long</source>
          <target state="translated">타입 정의 std :: os :: raw :: c_long</target>
        </trans-unit>
        <trans-unit id="8600d6f2d9a4b023e7037b70faa22dc15e66388f" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_longlong</source>
          <target state="translated">타입 정의 std :: os :: raw :: c_longlong</target>
        </trans-unit>
        <trans-unit id="38fbb377e146c43dbf57e7ef0b9149de46dd63ee" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_schar</source>
          <target state="translated">타입 정의 std :: os :: raw :: c_schar</target>
        </trans-unit>
        <trans-unit id="24f91247eef9f189a56e0d26eb63e94174545d18" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_short</source>
          <target state="translated">타입 정의 std :: os :: raw :: c_short</target>
        </trans-unit>
        <trans-unit id="8fd264b0559dbbedb815b835dcd8dc23c60e3e46" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_uchar</source>
          <target state="translated">타입 정의 std :: os :: raw :: c_uchar</target>
        </trans-unit>
        <trans-unit id="73ae8275dba1734adb8dd3eb79d165dfd8926f8e" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_uint</source>
          <target state="translated">타입 정의 std :: os :: raw :: c_uint</target>
        </trans-unit>
        <trans-unit id="963d890a0fa816ac69f7b2a91122d42f47482af6" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_ulong</source>
          <target state="translated">타입 정의 std :: os :: raw :: c_ulong</target>
        </trans-unit>
        <trans-unit id="9529b81e31c700d29c794b44439c31236befee6e" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_ulonglong</source>
          <target state="translated">타입 정의 std :: os :: raw :: c_ulonglong</target>
        </trans-unit>
        <trans-unit id="2add572706fcd5310850bb5c41c263a68becd701" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::raw::c_ushort</source>
          <target state="translated">타입 정의 std :: os :: raw :: c_ushort</target>
        </trans-unit>
        <trans-unit id="af576d5699684e5ccc6dd3bdda06f283b79646ba" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::io::RawFd</source>
          <target state="translated">타입 정의 std :: os :: unix :: io :: RawFd</target>
        </trans-unit>
        <trans-unit id="54df1b972115ebdb7492ee1ec118ad059c5b96b9" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::blkcnt_t</source>
          <target state="translated">타입 정의 std :: os :: unix :: raw :: blkcnt_t</target>
        </trans-unit>
        <trans-unit id="24cf96c7673dcafd447d654adb8e4cf01b30bb6f" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::blksize_t</source>
          <target state="translated">타입 정의 std :: os :: unix :: raw :: blksize_t</target>
        </trans-unit>
        <trans-unit id="27da02afd4df0cefb0f36b07dc40fb05a497c94e" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::dev_t</source>
          <target state="translated">타입 정의 std :: os :: unix :: raw :: dev_t</target>
        </trans-unit>
        <trans-unit id="73d1317f78cb687f50d63c8e6d4ee01bdba096f4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::gid_t</source>
          <target state="translated">타입 정의 std :: os :: unix :: raw :: gid_t</target>
        </trans-unit>
        <trans-unit id="f1c61da35b3b5a8948934b0c33b08607e17ab49a" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::ino_t</source>
          <target state="translated">타입 정의 std :: os :: unix :: raw :: ino_t</target>
        </trans-unit>
        <trans-unit id="f57f89ce06fb76c13960558bcf6af72b48025b0a" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::mode_t</source>
          <target state="translated">타입 정의 std :: os :: unix :: raw :: mode_t</target>
        </trans-unit>
        <trans-unit id="6efe4bc154c56731d72a72033b5e96f1e8e776fa" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::nlink_t</source>
          <target state="translated">타입 정의 std :: os :: unix :: raw :: nlink_t</target>
        </trans-unit>
        <trans-unit id="16d41f66ea53de25694ff8008809453896212992" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::off_t</source>
          <target state="translated">타입 정의 std :: os :: unix :: raw :: off_t</target>
        </trans-unit>
        <trans-unit id="7fcd1c7c7d47846aeea79e3b67b951552799ecac" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::pid_t</source>
          <target state="translated">타입 정의 std :: os :: unix :: raw :: pid_t</target>
        </trans-unit>
        <trans-unit id="15394730cd6adf60683b03d0f547388ed732a617" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::pthread_t</source>
          <target state="translated">타입 정의 std :: os :: unix :: raw :: pthread_t</target>
        </trans-unit>
        <trans-unit id="f5866aac0842b4a721a91364de015f0e36fbc706" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::time_t</source>
          <target state="translated">타입 정의 std :: os :: unix :: raw :: time_t</target>
        </trans-unit>
        <trans-unit id="c10ba42310b44320213f70095552a73e406c10bc" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::raw::uid_t</source>
          <target state="translated">타입 정의 std :: os :: unix :: raw :: uid_t</target>
        </trans-unit>
        <trans-unit id="ccfd242450d8d8e764c541c183e48c95060db965" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::unix::thread::RawPthread</source>
          <target state="translated">타입 정의 std :: os :: unix :: thread :: RawPthread</target>
        </trans-unit>
        <trans-unit id="43663035c10bc49312c1bd0f80dfefc8e89294c1" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::windows::io::RawHandle</source>
          <target state="translated">유형 정의 std :: os :: windows :: io :: RawHandle</target>
        </trans-unit>
        <trans-unit id="3c2575150d67f1e23972163c0fc5f2c5d673b3e4" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::windows::io::RawSocket</source>
          <target state="translated">유형 정의 std :: os :: windows :: io :: RawSocket</target>
        </trans-unit>
        <trans-unit id="05dc66459d6d8527de01519647dff10489bc279b" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::windows::raw::HANDLE</source>
          <target state="translated">유형 정의 std :: os :: windows :: raw :: HANDLE</target>
        </trans-unit>
        <trans-unit id="e2a21128c36897e8cf2791477ca7f265a71b8679" translate="yes" xml:space="preserve">
          <source>Type Definition std::os::windows::raw::SOCKET</source>
          <target state="translated">유형 정의 std :: os :: windows :: raw :: SOCKET</target>
        </trans-unit>
        <trans-unit id="f0f25e562f1eacf92009b3b9edd31757a9d568ee" translate="yes" xml:space="preserve">
          <source>Type Definition std::string::ParseError</source>
          <target state="translated">유형 정의 std :: string :: ParseError</target>
        </trans-unit>
        <trans-unit id="2cb5d5fbdf79715e3b849f3194ff3e1783dcc241" translate="yes" xml:space="preserve">
          <source>Type Definition std::sync::LockResult</source>
          <target state="translated">유형 정의 std :: sync :: LockResult</target>
        </trans-unit>
        <trans-unit id="a007682d472492c4b8b35e81f42caebf855855fb" translate="yes" xml:space="preserve">
          <source>Type Definition std::sync::TryLockResult</source>
          <target state="translated">유형 정의 std :: sync :: TryLockResult</target>
        </trans-unit>
        <trans-unit id="0fbaa33419fbed78ef077708914d095867001a9d" translate="yes" xml:space="preserve">
          <source>Type Definition std::thread::Result</source>
          <target state="translated">타입 정의 std :: thread :: Result</target>
        </trans-unit>
        <trans-unit id="3ba69662a63352acd45295d8a4cf929df3f97fd7" translate="yes" xml:space="preserve">
          <source>Type Definitions</source>
          <target state="translated">타입 정의</target>
        </trans-unit>
        <trans-unit id="9037feed073eee5a9272aeaba9be605266f5d249" translate="yes" xml:space="preserve">
          <source>Type Layout</source>
          <target state="translated">타입 레이아웃</target>
        </trans-unit>
        <trans-unit id="7433446286e8e2d16c8a5d667b180309a3d0c3b1" translate="yes" xml:space="preserve">
          <source>Type System</source>
          <target state="translated">타입 시스템</target>
        </trans-unit>
        <trans-unit id="58cf557846d7f65d34e8a92739eef2665164fad4" translate="yes" xml:space="preserve">
          <source>Type aliases</source>
          <target state="translated">타입 별칭</target>
        </trans-unit>
        <trans-unit id="46e484c635b0e4d4b2d73cd209e4672f43ad07bf" translate="yes" xml:space="preserve">
          <source>Type aliases are also commonly used with the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type for reducing repetition. Consider the &lt;code&gt;std::io&lt;/code&gt; module in the standard library. I/O operations often return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; to handle situations when operations fail to work. This library has a &lt;code&gt;std::io::Error&lt;/code&gt; struct that represents all possible I/O errors. Many of the functions in &lt;code&gt;std::io&lt;/code&gt; will be returning &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; where the &lt;code&gt;E&lt;/code&gt; is &lt;code&gt;std::io::Error&lt;/code&gt;, such as these functions in the &lt;code&gt;Write&lt;/code&gt; trait:</source>
          <target state="translated">타입 별칭은 반복을 줄이기 위해 일반적으로 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 타입 과 함께 사용됩니다 . 표준 라이브러리 의 &lt;code&gt;std::io&lt;/code&gt; 모듈을 고려하십시오 . I / O 작업은 종종 작업이 실패하는 상황을 처리하기 위해 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 를 반환합니다 . 이 라이브러리에는 가능한 모든 I / O 오류를 나타내는 &lt;code&gt;std::io::Error&lt;/code&gt; 구조체가 있습니다. 의 기능의 많은 &lt;code&gt;std::io&lt;/code&gt; 반환됩니다 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;code&gt;E&lt;/code&gt; 가 있다 &lt;code&gt;std::io::Error&lt;/code&gt; 같은 이러한 기능으로, &lt;code&gt;Write&lt;/code&gt; 특성을 :</target>
        </trans-unit>
        <trans-unit id="6d5463932cf5afab710bceb8f1d7684735a25ccf" translate="yes" xml:space="preserve">
          <source>Type and Lifetime Parameters</source>
          <target state="translated">유형 및 수명 매개 변수</target>
        </trans-unit>
        <trans-unit id="46505cd1622c8bbcf00ce8fef2ff0cd36549954e" translate="yes" xml:space="preserve">
          <source>Type bounds may be &lt;em&gt;higher ranked&lt;/em&gt; over lifetimes. These bounds specify a bound is true &lt;em&gt;for all&lt;/em&gt; lifetimes. For example, a bound such as &lt;code&gt;for&amp;lt;'a&amp;gt; &amp;amp;'a T: PartialEq&amp;lt;i32&amp;gt;&lt;/code&gt; would require an implementation like</source>
          <target state="translated">유형 범위는 평생 동안 &lt;em&gt;높은 순위&lt;/em&gt; 를 가질 수 있습니다 . 이 범위는 &lt;em&gt;모든&lt;/em&gt; 수명에 &lt;em&gt;대해&lt;/em&gt; 범위가 참임을 지정합니다 . 예를 들어 &lt;code&gt;for&amp;lt;'a&amp;gt; &amp;amp;'a T: PartialEq&amp;lt;i32&amp;gt;&lt;/code&gt; 와 같은 경계는 다음과 같은 구현이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ee004d162350a5b317e1dbaab9ce920a6f34a9cb" translate="yes" xml:space="preserve">
          <source>Type cast expressions</source>
          <target state="translated">타입 캐스트 표현식</target>
        </trans-unit>
        <trans-unit id="7b7e747774abb621d3a39f39c2761d3405b325bb" translate="yes" xml:space="preserve">
          <source>Type coercions</source>
          <target state="translated">유형 강제</target>
        </trans-unit>
        <trans-unit id="b6d852132e2d9e31234c0b7e2d2b2f126e521734" translate="yes" xml:space="preserve">
          <source>Type expressions</source>
          <target state="translated">타입 표현식</target>
        </trans-unit>
        <trans-unit id="00e950510855acd161003d11973afbcccbd1f3d1" translate="yes" xml:space="preserve">
          <source>Type inference typically proceeds from the top of the function to the bottom, figuring out types as it goes. In some cases -- notably method calls and overloadable operators like &lt;code&gt;*&lt;/code&gt; -- the type checker may not have enough information &lt;em&gt;yet&lt;/em&gt; to make progress. This can be true even if the rest of the function provides enough context (because the type-checker hasn't looked that far ahead yet). In this case, type annotations can be used to help it along.</source>
          <target state="translated">유형 유추는 일반적으로 함수의 상단에서 하단으로 진행하여 유형이 진행되는 시점을 파악합니다. 경우에 따라 (특히 메서드 호출 및 &lt;code&gt;*&lt;/code&gt; 와 같은 오버로드 가능한 연산자) 형식 검사기는 &lt;em&gt;아직&lt;/em&gt; 진행할 정보가 충분하지 않을 수 있습니다 . 나머지 함수가 충분한 컨텍스트를 제공하더라도 (타입 검사기가 아직 그렇게 앞을 보지 않았기 때문에) 이것은 사실 일 수 있습니다. 이 경우 유형 주석을 사용하여 도움을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c11526a8c75cf7eda7350bd42de65837b525d024" translate="yes" xml:space="preserve">
          <source>Type information must be provided if a pointer type being cast from/into another type which cannot be inferred:</source>
          <target state="translated">추론 할 수없는 다른 유형으로 캐스트되는 포인터 유형 인 경우 유형 정보를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="a230d1816e8c1575c2c45ae6cf6a3850545e094f" translate="yes" xml:space="preserve">
          <source>Type layout can be changed with each compilation. Instead of trying to document exactly what is done, we only document what is guaranteed today.</source>
          <target state="translated">컴파일 할 때마다 유형 레이아웃을 변경할 수 있습니다. 수행 된 작업을 정확하게 문서화하는 대신 오늘날 보장되는 작업 만 문서화합니다.</target>
        </trans-unit>
        <trans-unit id="421e94d5ad1cf070315124ce8a70fe7342de0094" translate="yes" xml:space="preserve">
          <source>Type of &lt;code&gt;e&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 종류</target>
        </trans-unit>
        <trans-unit id="483996222a68497be8a52e043163c1b07da634c0" translate="yes" xml:space="preserve">
          <source>Type of the hasher that will be created.</source>
          <target state="translated">생성 될 Hasher의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="90d41d3e02c3a5714dfb49c0b53d465ea95595cd" translate="yes" xml:space="preserve">
          <source>Type parameter defaults can only use parameters that occur before them. Erroneous code example:</source>
          <target state="translated">유형 매개 변수 기본값은 이전에 발생하는 매개 변수 만 사용할 수 있습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="610a43f90945887f546fa9894dbf887213eca6c4" translate="yes" xml:space="preserve">
          <source>Type parameter defaults can only use parameters that occur before them. Since type parameters are evaluated in-order, this issue could be fixed by doing:</source>
          <target state="translated">유형 매개 변수 기본값은 이전에 발생하는 매개 변수 만 사용할 수 있습니다. 유형 매개 변수는 순서대로 평가되므로 다음을 수행하여이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dac2f87deb7b8641c81a7d19aab25baf97b67f2a" translate="yes" xml:space="preserve">
          <source>Type parameter defaults cannot use &lt;code&gt;Self&lt;/code&gt; on structs, enums, or unions.</source>
          <target state="translated">유형 매개 변수 기본값은 구조체, 열거 형 또는 공용체에서 &lt;code&gt;Self&lt;/code&gt; 를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c9a3646a7ac556f56d25e93e18f2d2b1583d0264" translate="yes" xml:space="preserve">
          <source>Type parameters</source>
          <target state="translated">유형 매개 변수</target>
        </trans-unit>
        <trans-unit id="4a3ece058bb3ba65db202bc18df133e4b49391e3" translate="yes" xml:space="preserve">
          <source>Type parameters can be specified for a trait to make it generic. These appear after the trait name, using the same syntax used in &lt;a href=&quot;functions#generic-functions&quot;&gt;generic functions&lt;/a&gt;.</source>
          <target state="translated">특성에 대해 유형 매개 변수를 지정하여 일반 특성으로 만들 수 있습니다. 이것들은 &lt;a href=&quot;functions#generic-functions&quot;&gt;일반 함수에&lt;/a&gt; 사용 된 것과 동일한 구문을 사용하여 특성 이름 뒤에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="8de0a3ce745cf3e1cf2895f8f92a4c1b4a8865b7" translate="yes" xml:space="preserve">
          <source>Type parameters for &lt;code&gt;impl Trait&lt;/code&gt; types must be explicitly defined as named generic parameters:</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; 유형에 대한 유형 매개 변수는 명명 된 일반 매개 변수로 명시 적으로 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="788f8ff13becde924812f48a846332da2dde1b3b" translate="yes" xml:space="preserve">
          <source>Type parameters in an associated item also cannot shadow parameters from the containing item:</source>
          <target state="translated">연관된 항목의 유형 매개 변수도 포함하는 항목의 매개 변수를 섀도 잉 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d2b6a64cfc2d2019725a350386f952f6ea964501" translate="yes" xml:space="preserve">
          <source>Type parameters in type definitions have lifetimes associated with them that represent how long the data stored within them is guaranteed to live. This lifetime must be as long as the data needs to be alive, and missing the constraint that denotes this will cause this error.</source>
          <target state="translated">유형 정의의 유형 매개 변수에는 그 안에 저장된 데이터의 수명을 나타내는 수명이 연결되어 있습니다. 이 수명은 데이터가 살아 있어야하는만큼 길어야하며이를 나타내는 제약 조건이 없으면이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="635a70628fcb4cdf2545b82d9a213017cf1ec1dc" translate="yes" xml:space="preserve">
          <source>Type parameters where the parameters only have any &lt;a href=&quot;../trait-bounds&quot;&gt;trait bounds&lt;/a&gt; of the following kind:</source>
          <target state="translated">매개 변수에 다음과 같은 종류의 &lt;a href=&quot;../trait-bounds&quot;&gt;특성 범위&lt;/a&gt; 만있는 매개 변수를 입력 하십시오.</target>
        </trans-unit>
        <trans-unit id="f5436dd7df5cce78281ac167ac45b8ad046b6808" translate="yes" xml:space="preserve">
          <source>Type paths are used within type definitions, trait bounds, type parameter bounds, and qualified paths.</source>
          <target state="translated">유형 경로는 유형 정의, 특성 범위, 유형 매개 변수 범위 및 규정 된 경로 내에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0fc5390ca69aecade222ecf85ac47ee15fecaa1e" translate="yes" xml:space="preserve">
          <source>Type system</source>
          <target state="translated">타입 시스템</target>
        </trans-unit>
        <trans-unit id="40294f1b1dbbecd786588c1ac7a98f52d1946633" translate="yes" xml:space="preserve">
          <source>Type system attributes</source>
          <target state="translated">유형 시스템 속성</target>
        </trans-unit>
        <trans-unit id="e6b05abe4f4f396debd3f7c7c7a457e652381139" translate="yes" xml:space="preserve">
          <source>TypeId</source>
          <target state="translated">TypeId</target>
        </trans-unit>
        <trans-unit id="6174852658dcb07e66221cdda0d47c6a79955026" translate="yes" xml:space="preserve">
          <source>TypeId::borrow</source>
          <target state="translated">TypeId::borrow</target>
        </trans-unit>
        <trans-unit id="9240a6191da03dd3e162b4d594573c014ae637e8" translate="yes" xml:space="preserve">
          <source>TypeId::borrow_mut</source>
          <target state="translated">TypeId::borrow_mut</target>
        </trans-unit>
        <trans-unit id="1e830f38943c98994765e5634b28fc734e6d131b" translate="yes" xml:space="preserve">
          <source>TypeId::clamp</source>
          <target state="translated">TypeId::clamp</target>
        </trans-unit>
        <trans-unit id="716fa011ef15618f6c39d058d78de9fd5d26d8a4" translate="yes" xml:space="preserve">
          <source>TypeId::clone</source>
          <target state="translated">TypeId::clone</target>
        </trans-unit>
        <trans-unit id="d206fca55570d1ee7222250a6099efa3eefe5378" translate="yes" xml:space="preserve">
          <source>TypeId::clone_from</source>
          <target state="translated">TypeId::clone_from</target>
        </trans-unit>
        <trans-unit id="795523e4b3053e8ae487bb7ffbfed98163be00e1" translate="yes" xml:space="preserve">
          <source>TypeId::clone_into</source>
          <target state="translated">TypeId::clone_into</target>
        </trans-unit>
        <trans-unit id="ddba09636ddf2c450efd47bdbd5c1086798641ce" translate="yes" xml:space="preserve">
          <source>TypeId::cmp</source>
          <target state="translated">TypeId::cmp</target>
        </trans-unit>
        <trans-unit id="3f0565a2054d47ca089c9dd28d09f714cfe255a6" translate="yes" xml:space="preserve">
          <source>TypeId::eq</source>
          <target state="translated">TypeId::eq</target>
        </trans-unit>
        <trans-unit id="3b66ed765f5e07da8b6a35c0796de577d880004a" translate="yes" xml:space="preserve">
          <source>TypeId::fmt</source>
          <target state="translated">TypeId::fmt</target>
        </trans-unit>
        <trans-unit id="a6d534f62ff1c6a2b12bb6ea7101f9db8f3b6a65" translate="yes" xml:space="preserve">
          <source>TypeId::from</source>
          <target state="translated">TypeId::from</target>
        </trans-unit>
        <trans-unit id="0ad8421f49348cec9c5c0ea27504bddf46f46746" translate="yes" xml:space="preserve">
          <source>TypeId::ge</source>
          <target state="translated">TypeId::ge</target>
        </trans-unit>
        <trans-unit id="98d12bbe982cc4e9feaef864de49f327eade548c" translate="yes" xml:space="preserve">
          <source>TypeId::gt</source>
          <target state="translated">TypeId::gt</target>
        </trans-unit>
        <trans-unit id="e1dea7697f9d16fe9585b0146b54ef1ba2595a7c" translate="yes" xml:space="preserve">
          <source>TypeId::hash</source>
          <target state="translated">TypeId::hash</target>
        </trans-unit>
        <trans-unit id="d7a9744fc39a0fe544964e9b703ad9db8ff88413" translate="yes" xml:space="preserve">
          <source>TypeId::hash_slice</source>
          <target state="translated">TypeId::hash_slice</target>
        </trans-unit>
        <trans-unit id="8f7e7f7b59fc95161e5efd4c331382bf506c5fe2" translate="yes" xml:space="preserve">
          <source>TypeId::into</source>
          <target state="translated">TypeId::into</target>
        </trans-unit>
        <trans-unit id="02f386a913763d6012a9e28821eacb6458ea8546" translate="yes" xml:space="preserve">
          <source>TypeId::le</source>
          <target state="translated">TypeId::le</target>
        </trans-unit>
        <trans-unit id="578f87bf8b84d3b8635f212a617fcec0f23b5476" translate="yes" xml:space="preserve">
          <source>TypeId::lt</source>
          <target state="translated">TypeId::lt</target>
        </trans-unit>
        <trans-unit id="6c7811e3962847e55153d132edc379a97aeab156" translate="yes" xml:space="preserve">
          <source>TypeId::max</source>
          <target state="translated">TypeId::max</target>
        </trans-unit>
        <trans-unit id="5de1024eb47140ae18a0b9ef6b7abda00f5ebc42" translate="yes" xml:space="preserve">
          <source>TypeId::min</source>
          <target state="translated">TypeId::min</target>
        </trans-unit>
        <trans-unit id="19a1b2382c162a3deb2660f8d535151330c4dd68" translate="yes" xml:space="preserve">
          <source>TypeId::ne</source>
          <target state="translated">TypeId::ne</target>
        </trans-unit>
        <trans-unit id="57bbf815ae3734582141e6c3d94d16d795b42238" translate="yes" xml:space="preserve">
          <source>TypeId::of</source>
          <target state="translated">TypeId::of</target>
        </trans-unit>
        <trans-unit id="9387d6c30cfc43859bbce0cd6a9e882f482aa548" translate="yes" xml:space="preserve">
          <source>TypeId::partial_cmp</source>
          <target state="translated">TypeId::partial_cmp</target>
        </trans-unit>
        <trans-unit id="275a8a5c8970873ed0f6e5f7be025d1d88c24b17" translate="yes" xml:space="preserve">
          <source>TypeId::to_owned</source>
          <target state="translated">TypeId::to_owned</target>
        </trans-unit>
        <trans-unit id="b305d0eb27c70d75d6581a7bb24fd3b0cabb8713" translate="yes" xml:space="preserve">
          <source>TypeId::try_from</source>
          <target state="translated">TypeId::try_from</target>
        </trans-unit>
        <trans-unit id="ab6bd512f140c02836e01449097676127e0b1727" translate="yes" xml:space="preserve">
          <source>TypeId::try_into</source>
          <target state="translated">TypeId::try_into</target>
        </trans-unit>
        <trans-unit id="b7aa84284f56989bd040008a9a1842dc034ac075" translate="yes" xml:space="preserve">
          <source>TypeId::type_id</source>
          <target state="translated">TypeId::type_id</target>
        </trans-unit>
        <trans-unit id="ca804ab74bf9fa2667ceb8c95926b696eb69be50" translate="yes" xml:space="preserve">
          <source>Typedefs</source>
          <target state="translated">Typedefs</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="51920e55843cc4f1f030d29bb9494f870acf0911" translate="yes" xml:space="preserve">
          <source>Types and Traits for working with asynchronous tasks.</source>
          <target state="translated">비동기 작업을 수행하기위한 유형 및 특성.</target>
        </trans-unit>
        <trans-unit id="eb96b9196c6d15505da132a08c116566f7a5d2bc" translate="yes" xml:space="preserve">
          <source>Types express that they can be borrowed as some type &lt;code&gt;T&lt;/code&gt; by implementing &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;, providing a reference to a &lt;code&gt;T&lt;/code&gt; in the trait&amp;rsquo;s &lt;a href=&quot;#tymethod.borrow&quot;&gt;&lt;code&gt;borrow&lt;/code&gt;&lt;/a&gt; method. A type is free to borrow as several different types. If it wishes to mutably borrow as the type &amp;ndash; allowing the underlying data to be modified, it can additionally implement &lt;a href=&quot;trait.borrowmut&quot;&gt;&lt;code&gt;BorrowMut&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유형 은 특성의 &lt;a href=&quot;#tymethod.borrow&quot;&gt; &lt;code&gt;borrow&lt;/code&gt; &lt;/a&gt; 방법 에서 &lt;code&gt;T&lt;/code&gt; 에 대한 참조를 제공하여 &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; 를 구현 하여 일부 유형 &lt;code&gt;T&lt;/code&gt; 로 차용 할 수 있음 을 나타냅니다 . 유형은 여러 가지 유형으로 자유롭게 빌릴 수 있습니다. 기본 데이터를 수정할 수 있도록 유형으로 변경 가능하게 빌리 &lt;a href=&quot;trait.borrowmut&quot;&gt; &lt;code&gt;BorrowMut&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 추가로 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6aef87c840bd9c8d6b5be21927a32724dcebf8ad" translate="yes" xml:space="preserve">
          <source>Types express that they can be borrowed as some type &lt;code&gt;T&lt;/code&gt; by implementing &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;, providing a reference to a &lt;code&gt;T&lt;/code&gt; in the trait&amp;rsquo;s &lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt;&lt;code&gt;borrow&lt;/code&gt;&lt;/a&gt; method. A type is free to borrow as several different types. If it wishes to mutably borrow as the type &amp;ndash; allowing the underlying data to be modified, it can additionally implement &lt;a href=&quot;trait.borrowmut&quot;&gt;&lt;code&gt;BorrowMut&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유형은 어떤 형식으로 차용 될 수 있음을 표현하는 &lt;code&gt;T&lt;/code&gt; 구현하여 &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; 하는에 대한 참조를 제공하는 &lt;code&gt;T&lt;/code&gt; 형질의에서 &lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt; &lt;code&gt;borrow&lt;/code&gt; &lt;/a&gt; 방법. 한 유형은 여러 유형으로 무료로 빌릴 수 있습니다. 유형으로 변경 가능하게 빌려서 기본 데이터를 수정할 수 있도록하려면 &lt;a href=&quot;trait.borrowmut&quot;&gt; &lt;code&gt;BorrowMut&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 추가로 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a53d10bc9765156a98cd22298d0dddb08f16d1f" translate="yes" xml:space="preserve">
          <source>Types for which it is safe to share references between threads.</source>
          <target state="translated">스레드간에 참조를 공유하는 것이 안전한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="98c95794e6189dee1201d1bd443780e1c531d39b" translate="yes" xml:space="preserve">
          <source>Types implementing &lt;code&gt;Hash&lt;/code&gt; are able to be &lt;a href=&quot;#tymethod.hash&quot;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt;ed with an instance of &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Hash&lt;/code&gt; 구현하는 유형 은 &lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; 인스턴스 로 &lt;a href=&quot;#tymethod.hash&quot;&gt; &lt;code&gt;hash&lt;/code&gt; &lt;/a&gt; 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e63cf5842f436d926f1be87d5535f3c61b75dd54" translate="yes" xml:space="preserve">
          <source>Types implementing &lt;code&gt;Hash&lt;/code&gt; are able to be &lt;a href=&quot;trait.hash#tymethod.hash&quot;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt;ed with an instance of &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Hash&lt;/code&gt; 를 구현하는 유형 은 &lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; 인스턴스 로 &lt;a href=&quot;trait.hash#tymethod.hash&quot;&gt; &lt;code&gt;hash&lt;/code&gt; &lt;/a&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f882465e79764914f835cc19a5911f31e45f796b" translate="yes" xml:space="preserve">
          <source>Types in type definitions have lifetimes associated with them that represent how long the data stored within them is guaranteed to be live. This lifetime must be as long as the data needs to be alive, and missing the constraint that denotes this will cause this error.</source>
          <target state="translated">유형 정의의 유형에는 저장된 데이터의 유효 기간을 나타내는 수명이 있습니다. 이 수명은 데이터를 유지해야하는 기간이어야하며이를 나타내는 제한이 없으면이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="777921b6f1b475c9ffaa77c98a5d17f39e3660e5" translate="yes" xml:space="preserve">
          <source>Types like &lt;code&gt;&amp;amp;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;, however, are unwind safe because they implement poisoning by default. They still allow witnessing a broken invariant, but they already provide their own &quot;speed bumps&quot; to do so.</source>
          <target state="translated">그러나 &lt;code&gt;&amp;amp;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 와 같은 유형 은 기본적으로 중독을 구현하기 때문에 안전합니다. 그들은 여전히 ​​불변을 깨뜨리는 것을 목격 할 수 있지만, 그렇게하기 위해 이미 &quot;스피드 범프&quot;를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b83d85bf5da8e86595350c0dcf9e419a4d654c49" translate="yes" xml:space="preserve">
          <source>Types like Vec therefore just &lt;code&gt;drop_in_place(&amp;amp;mut self[..])&lt;/code&gt; without using &lt;code&gt;needs_drop&lt;/code&gt; explicitly. Types like &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;, on the other hand, have to drop values one at a time and should use this API.</source>
          <target state="translated">따라서 Vec과 같은 유형은 &lt;code&gt;needs_drop&lt;/code&gt; 을 명시 적으로 사용하지 않고 &lt;code&gt;drop_in_place(&amp;amp;mut self[..])&lt;/code&gt; 뿐입니다 . 반면에 &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 과 같은 유형은 한 번에 하나씩 값을 삭제해야하며이 API를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a8a83f5b2fb6977b69a3feef08ecd269c85a9244" translate="yes" xml:space="preserve">
          <source>Types like Vec therefore just &lt;code&gt;drop_in_place(&amp;amp;mut self[..])&lt;/code&gt; without using needs_drop explicitly. Types like &lt;code&gt;HashMap&lt;/code&gt;, on the other hand, have to drop values one at a time and should use this API.</source>
          <target state="translated">따라서 Vec과 같은 유형은 needs_drop을 명시 적으로 사용하지 않고 &lt;code&gt;drop_in_place(&amp;amp;mut self[..])&lt;/code&gt; 입니다. 반면에 &lt;code&gt;HashMap&lt;/code&gt; 과 같은 유형은 한 번에 하나씩 값을 삭제해야하며이 API를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7478d20240bfc3f122030bf28d31bd62139a2c2b" translate="yes" xml:space="preserve">
          <source>Types of paths</source>
          <target state="translated">경로의 종류</target>
        </trans-unit>
        <trans-unit id="927769adc55a691f31ed2d50893e6b26e3a7e1f3" translate="yes" xml:space="preserve">
          <source>Types such as &lt;code&gt;&amp;amp;mut T&lt;/code&gt; and &lt;code&gt;&amp;amp;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; are examples which are &lt;strong&gt;not&lt;/strong&gt; unwind safe. The general idea is that any mutable state which can be shared across &lt;code&gt;catch_unwind&lt;/code&gt; is not unwind safe by default. This is because it is very easy to witness a broken invariant outside of &lt;code&gt;catch_unwind&lt;/code&gt; as the data is simply accessed as usual.</source>
          <target state="translated">&lt;code&gt;&amp;amp;mut T&lt;/code&gt; 및 &lt;code&gt;&amp;amp;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 와 같은 유형 은 풀기 안전 &lt;strong&gt;하지 않은&lt;/strong&gt; 예입니다 . 일반적인 아이디어는 &lt;code&gt;catch_unwind&lt;/code&gt; 에서 공유 할 수있는 변경 가능한 상태 는 기본적으로 해제 안전하지 않다는 것 입니다. 데이터가 평소와 같이 단순히 액세스 되기 때문에 &lt;code&gt;catch_unwind&lt;/code&gt; 외부에서 깨진 불변을 목격하기가 매우 쉽기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="c3195172a47cd29103a9c049d30b8fbf3e8b1360" translate="yes" xml:space="preserve">
          <source>Types that are &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; should have a trivial implementation of &lt;code&gt;Clone&lt;/code&gt;. More formally: if &lt;code&gt;T: Copy&lt;/code&gt;, &lt;code&gt;x: T&lt;/code&gt;, and &lt;code&gt;y: &amp;amp;T&lt;/code&gt;, then &lt;code&gt;let x = y.clone();&lt;/code&gt; is equivalent to &lt;code&gt;let x = *y;&lt;/code&gt;. Manual implementations should be careful to uphold this invariant; however, unsafe code must not rely on it to ensure memory safety.</source>
          <target state="translated">&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; 인&lt;/a&gt; 유형 은 간단한 &lt;code&gt;Clone&lt;/code&gt; 구현이 있어야합니다 . 더 공식적으로 : &lt;code&gt;T: Copy&lt;/code&gt; , &lt;code&gt;x: T&lt;/code&gt; 및 &lt;code&gt;y: &amp;amp;T&lt;/code&gt; 이면 &lt;code&gt;let x = y.clone();&lt;/code&gt; &lt;code&gt;let x = *y;&lt;/code&gt; 와 같습니다 . . 수동 구현은이 불변을 유지하도록주의해야합니다. 그러나 안전하지 않은 코드는 메모리 안전을 위해 코드에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f0ac37d244c8fc744b51cd8122917f397c819f37" translate="yes" xml:space="preserve">
          <source>Types that are not &lt;code&gt;Sync&lt;/code&gt; are those that have &quot;interior mutability&quot; in a non-thread-safe form, such as &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;. These types allow for mutation of their contents even through an immutable, shared reference. For example the &lt;code&gt;set&lt;/code&gt; method on &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; takes &lt;code&gt;&amp;amp;self&lt;/code&gt;, so it requires only a shared reference &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;&amp;amp;Cell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. The method performs no synchronization, thus &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; cannot be &lt;code&gt;Sync&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Sync&lt;/code&gt; 가 아닌 유형은 &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; 과 같이 스레드로부터 안전 하지 않은 형식으로 &quot;내부 변경 가능성&quot;이있는 유형 입니다. 이러한 유형은 변경 불가능한 공유 참조를 통해서도 내용을 변경할 수 있습니다. 예를 들어 &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;set&lt;/code&gt; 메서드 는 &lt;code&gt;&amp;amp;self&lt;/code&gt; 를 사용하므로 공유 참조 &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;&amp;amp;Cell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 만 필요합니다 . 이 메서드는 동기화를 수행하지 않으므로 &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;Sync&lt;/code&gt; 가 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="052471a32eb0536b190d6178524500a9ab363d4b" translate="yes" xml:space="preserve">
          <source>Types that are not &lt;code&gt;Sync&lt;/code&gt; are those that have &quot;interior mutability&quot; in a non-thread-safe form, such as &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;cell::Cell&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;cell::RefCell&lt;/code&gt;&lt;/a&gt;. These types allow for mutation of their contents even through an immutable, shared reference. For example the &lt;code&gt;set&lt;/code&gt; method on &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; takes &lt;code&gt;&amp;amp;self&lt;/code&gt;, so it requires only a shared reference &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;&amp;amp;Cell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. The method performs no synchronization, thus &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; cannot be &lt;code&gt;Sync&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Sync&lt;/code&gt; 가 아닌 유형은 &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;cell::Cell&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;cell::RefCell&lt;/code&gt; &lt;/a&gt; 과 같이 스레드로부터 안전하지 않은 형태로 &quot;내부 변경 가능성&quot;이있는 유형 입니다. 이러한 유형은 불변의 공유 참조를 통해서도 내용의 돌연변이를 허용합니다. 예를 들어 &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;set&lt;/code&gt; 메소드 는 &lt;code&gt;&amp;amp;self&lt;/code&gt; 를 사용하므로 공유 참조 &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;&amp;amp;Cell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 만 필요합니다 . 이 메소드는 동기화를 수행하지 않으므로 &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;Sync&lt;/code&gt; 일 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a93bcdad638deb7c786807f08f731b7cc346d96e" translate="yes" xml:space="preserve">
          <source>Types that can be &quot;unsized&quot; to a dynamically-sized type.</source>
          <target state="translated">크기를 동적으로 조정할 수있는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="cb55fa05185a6907e8b5c6521da0fcc611e7870b" translate="yes" xml:space="preserve">
          <source>Types that can be referred to by a path directly. Specifically &lt;a href=&quot;items/enumerations&quot;&gt;enums&lt;/a&gt;, &lt;a href=&quot;items/structs&quot;&gt;structs&lt;/a&gt;, &lt;a href=&quot;items/unions&quot;&gt;unions&lt;/a&gt;, and &lt;a href=&quot;types/trait-object&quot;&gt;trait objects&lt;/a&gt;.</source>
          <target state="translated">경로에서 직접 참조 할 수있는 유형입니다. 특히 &lt;a href=&quot;items/enumerations&quot;&gt;열거 형&lt;/a&gt; , &lt;a href=&quot;items/structs&quot;&gt;구조체&lt;/a&gt; , &lt;a href=&quot;items/unions&quot;&gt;공용체&lt;/a&gt; 및 &lt;a href=&quot;types/trait-object&quot;&gt;특성 객체&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="25ee853941e3e88ccc68136bde43188a34e9bb72" translate="yes" xml:space="preserve">
          <source>Types that can be safely moved after being pinned.</source>
          <target state="translated">고정 후 안전하게 이동할 수있는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1ac756fd205dd639ca5e2fd93c5deef27d4364ad" translate="yes" xml:space="preserve">
          <source>Types that can be transferred across thread boundaries.</source>
          <target state="translated">스레드 경계를 통해 전송할 수있는 유형</target>
        </trans-unit>
        <trans-unit id="320fc78d266da1348d0700937ff111e53e935f29" translate="yes" xml:space="preserve">
          <source>Types that pin data to its location in memory.</source>
          <target state="translated">데이터를 메모리의 해당 위치에 고정하는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="76aa938f99526e648196d0e632e37d9cfcfbe64a" translate="yes" xml:space="preserve">
          <source>Types where all values have the same size and alignment known at compile time implement the &lt;a href=&quot;../std/marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; trait and can be checked with the &lt;a href=&quot;../std/mem/fn.size_of&quot;&gt;&lt;code&gt;size_of&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/mem/fn.align_of&quot;&gt;&lt;code&gt;align_of&lt;/code&gt;&lt;/a&gt; functions. Types that are not &lt;a href=&quot;../std/marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; are known as &lt;a href=&quot;dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt;. Since all values of a &lt;code&gt;Sized&lt;/code&gt; type share the same size and alignment, we refer to those shared values as the size of the type and the alignment of the type respectively.</source>
          <target state="translated">컴파일시 알려진 모든 값의 크기와 정렬이 같은 유형은 &lt;a href=&quot;../std/marker/trait.sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt; 특성을 구현 하며 &lt;a href=&quot;../std/mem/fn.size_of&quot;&gt; &lt;code&gt;size_of&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../std/mem/fn.align_of&quot;&gt; &lt;code&gt;align_of&lt;/code&gt; &lt;/a&gt; 함수 로 확인할 수 있습니다 . 없는 유형 &lt;a href=&quot;../std/marker/trait.sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt; 으로 알려져 있습니다 &lt;a href=&quot;dynamically-sized-types&quot;&gt;동적으로 크기 유형&lt;/a&gt; . &lt;code&gt;Sized&lt;/code&gt; 유형 의 모든 값은 동일한 크기와 정렬을 공유하므로 공유 값을 유형의 크기와 유형의 정렬이라고합니다.</target>
        </trans-unit>
        <trans-unit id="4c5a249120cc9cc75ac3bb033531eaa8e4965e16" translate="yes" xml:space="preserve">
          <source>Types where all values have the same size and alignment, and both are known at compile time, implement the &lt;a href=&quot;../std/marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; trait and can be checked with the &lt;a href=&quot;../std/mem/fn.size_of&quot;&gt;&lt;code&gt;size_of&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/mem/fn.align_of&quot;&gt;&lt;code&gt;align_of&lt;/code&gt;&lt;/a&gt; functions. Types that are not &lt;a href=&quot;../std/marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; are known as &lt;a href=&quot;dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt;. Since all values of a &lt;code&gt;Sized&lt;/code&gt; type share the same size and alignment, we refer to those shared values as the size of the type and the alignment of the type respectively.</source>
          <target state="translated">모든 값이 동일한 크기와 정렬을 가지며 컴파일시 둘 다 알려진 유형은 &lt;a href=&quot;../std/marker/trait.sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt; 특성을 구현 하며 &lt;a href=&quot;../std/mem/fn.size_of&quot;&gt; &lt;code&gt;size_of&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../std/mem/fn.align_of&quot;&gt; &lt;code&gt;align_of&lt;/code&gt; &lt;/a&gt; 함수 로 확인할 수 있습니다 . 없는 유형 &lt;a href=&quot;../std/marker/trait.sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt; 으로 알려져 있습니다 &lt;a href=&quot;dynamically-sized-types&quot;&gt;동적으로 크기 유형&lt;/a&gt; . &lt;code&gt;Sized&lt;/code&gt; 유형 의 모든 값은 동일한 크기와 정렬을 공유하므로 이러한 공유 값을 각각 유형의 크기와 유형의 정렬이라고합니다.</target>
        </trans-unit>
        <trans-unit id="3210f89648e92f030dff845af33244c5ff84d48b" translate="yes" xml:space="preserve">
          <source>Types which can be safely moved after being pinned.</source>
          <target state="translated">고정 후 안전하게 이동할 수있는 유형.</target>
        </trans-unit>
        <trans-unit id="2f9fa3c4c8befc1e893d11ac3d1acf505f4ef9f3" translate="yes" xml:space="preserve">
          <source>Types whose values can be duplicated simply by copying bits.</source>
          <target state="translated">단순히 비트를 복사하여 값을 복제 할 수있는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="184223af25e77a5fba4124f5c744634bac8d8134" translate="yes" xml:space="preserve">
          <source>Types with a built-in &lt;code&gt;Copy&lt;/code&gt; implementation (see above)</source>
          <target state="translated">내장 &lt;code&gt;Copy&lt;/code&gt; 구현 이있는 유형 (위 참조)</target>
        </trans-unit>
        <trans-unit id="484e89278738e43bbfac83c89cf041e830b0fa33" translate="yes" xml:space="preserve">
          <source>Types with a constant size known at compile time.</source>
          <target state="translated">컴파일 타임에 알려진 일정한 크기의 유형.</target>
        </trans-unit>
        <trans-unit id="c606776082303165b5e8cc822f677d6b3746b68d" translate="yes" xml:space="preserve">
          <source>Typically in Rust, it is difficult to perform step (2) because catching a panic involves either spawning a thread (which in turns makes it difficult to later witness broken invariants) or using the &lt;code&gt;catch_unwind&lt;/code&gt; function in this module. Additionally, even if an invariant is witnessed, it typically isn't a problem in Rust because there are no uninitialized values (like in C or C++).</source>
          <target state="translated">일반적으로 Rust에서는 패닉을 잡기 위해 스레드를 생성하거나 (나중에 깨진 불변 값을 확인하기 어렵게 함) 이 모듈에서 &lt;code&gt;catch_unwind&lt;/code&gt; 함수를 사용하기 때문에 단계 2를 수행하기가 어렵습니다 . 또한, 불변이 목격 되더라도 초기화되지 않은 값 (예 : C 또는 C ++)이 없기 때문에 Rust에서는 일반적으로 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb301c3b538136ec6b1f761774f64171df868f5f" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;quit&lt;/code&gt; actually quits the game, but so will any other non-number input. However, this is suboptimal to say the least. We want the game to automatically stop when the correct number is guessed.</source>
          <target state="translated">&lt;code&gt;quit&lt;/code&gt; 실제로 게임을 종료하지만 숫자가 아닌 다른 입력은 종료 됩니다. 그러나 이것은 가장 적게 말하면 차선책입니다. 올바른 숫자를 추측하면 게임이 자동으로 중지되기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="a153700f851859e0ff4a79a843433857f27950a3" translate="yes" xml:space="preserve">
          <source>U+0021 ..= U+002F &lt;code&gt;! &quot; # $ % &amp;amp; ' ( ) * + , - . /&lt;/code&gt;, or</source>
          <target state="translated">U + 0021 .. = U + 002F &lt;code&gt;! &quot; # $ % &amp;amp; ' ( ) * + , - . /&lt;/code&gt; 또는</target>
        </trans-unit>
        <trans-unit id="9a3efbcf50b26fb17c75edefb4d0573be03644e1" translate="yes" xml:space="preserve">
          <source>U+0030 '0' ..= U+0039 '9', or</source>
          <target state="translated">U + 0030 '0'.. = U + 0039 '9'또는</target>
        </trans-unit>
        <trans-unit id="974d5e574e1e2bc13b31d24cc4a60ea2f16fa049" translate="yes" xml:space="preserve">
          <source>U+0030 '0' ..= U+0039 '9'.</source>
          <target state="translated">U + 0030 '0'.. = U + 0039 '9'.</target>
        </trans-unit>
        <trans-unit id="fc0e8044fa37810bc4ad961db684088868f06aba" translate="yes" xml:space="preserve">
          <source>U+003A ..= U+0040 &lt;code&gt;: ; &amp;lt; = &amp;gt; ? @&lt;/code&gt;, or</source>
          <target state="translated">U + 003A .. = U + 0040 &lt;code&gt;: ; &amp;lt; = &amp;gt; ? @&lt;/code&gt; 또는</target>
        </trans-unit>
        <trans-unit id="302310fbdc6543d9d3ceaffa2ea8c3882849e20a" translate="yes" xml:space="preserve">
          <source>U+0041 'A' ..= U+0046 'F', or</source>
          <target state="translated">U + 0041 'A'.. = U + 0046 'F'또는</target>
        </trans-unit>
        <trans-unit id="0736721e1e5a1d0311260bd3b8011dcd68e67375" translate="yes" xml:space="preserve">
          <source>U+0041 'A' ..= U+005A 'Z', or</source>
          <target state="translated">U + 0041 'A'.. = U + 005A 'Z'또는</target>
        </trans-unit>
        <trans-unit id="db2fb3a2a6da1a41f13ef4503845f3b0b40f0c2e" translate="yes" xml:space="preserve">
          <source>U+005B ..= U+0060 &lt;code&gt;[ \ ] ^ _ ` &lt;/code&gt;, or</source>
          <target state="translated">U + 005B .. = U + 0060 &lt;code&gt;[ \ ] ^ _ ` &lt;/code&gt; _` 또는</target>
        </trans-unit>
        <trans-unit id="d8cc906d3074f1fb9435c008fb8f60999129ec67" translate="yes" xml:space="preserve">
          <source>U+0061 'a' ..= U+0066 'f'.</source>
          <target state="translated">U + 0061 'a'.. = U + 0066 'f'.</target>
        </trans-unit>
        <trans-unit id="c1d839fcec5226b8d1bd246357b031dd87454f54" translate="yes" xml:space="preserve">
          <source>U+0061 'a' ..= U+007A 'z', or</source>
          <target state="translated">U + 0061 'a'.. = U + 007A 'z'또는</target>
        </trans-unit>
        <trans-unit id="94a61fd70b1e7aaf895ebbced86d7174cebf3cb2" translate="yes" xml:space="preserve">
          <source>U+0061 'a' ..= U+007A 'z'.</source>
          <target state="translated">U + 0061 'a'.. = U + 007A 'z'.</target>
        </trans-unit>
        <trans-unit id="2bed9fc1e2abd580e2aa130399315d68f08afda9" translate="yes" xml:space="preserve">
          <source>U+007B ..= U+007E &lt;code&gt;{ | } ~&lt;/code&gt;</source>
          <target state="translated">U + 007B .. = U + 007E &lt;code&gt;{ | } ~&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6732b9263430ba9b754d7ce4c99335950d3da8b" translate="yes" xml:space="preserve">
          <source>UCred</source>
          <target state="translated">UCred</target>
        </trans-unit>
        <trans-unit id="0dd9df57e9839a1ea6ed560675b576be4884654a" translate="yes" xml:space="preserve">
          <source>UNC prefixes consist of the server's hostname and a share name.</source>
          <target state="translated">UNC 접두사는 서버의 호스트 이름과 공유 이름으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="08e32e0a7cca1165daa904dec1d1f04e68736d5e" translate="yes" xml:space="preserve">
          <source>UNICODE_ESCAPE :</source>
          <target state="translated">UNICODE_ESCAPE :</target>
        </trans-unit>
        <trans-unit id="a22641b9fc9c9910a6cdbff4d4c69eb3d13192f7" translate="yes" xml:space="preserve">
          <source>UNICODE_VERSION</source>
          <target state="translated">UNICODE_VERSION</target>
        </trans-unit>
        <trans-unit id="039571ef60c9b1a6527c96a684dccfc0e4f32a75" translate="yes" xml:space="preserve">
          <source>UNIX</source>
          <target state="translated">UNIX</target>
        </trans-unit>
        <trans-unit id="82e26360ac87e10e1e21c7c1d4d889a8777bad06" translate="yes" xml:space="preserve">
          <source>UNIX_EPOCH</source>
          <target state="translated">UNIX_EPOCH</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="ff463dac21cfe2cbf8ee41ca3cd6ef5584048c23" translate="yes" xml:space="preserve">
          <source>UTF8BOM : &lt;code&gt;\uFEFF&lt;/code&gt;</source>
          <target state="translated">UTF8BOM : &lt;code&gt;\uFEFF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9bc8e71f3f5fe8f28cf7f67493cc988d6461307a" translate="yes" xml:space="preserve">
          <source>UTF8BOM&lt;sup&gt;?&lt;/sup&gt;</source>
          <target state="translated">UTF8BOM&lt;sup&gt;?&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="f301189dd0e6ecd6aa5f6cd826f3ac3660574f9f" translate="yes" xml:space="preserve">
          <source>UdpSocket</source>
          <target state="translated">UdpSocket</target>
        </trans-unit>
        <trans-unit id="eef9838e551c21ad60465337cf4a411d0bc3c3b0" translate="yes" xml:space="preserve">
          <source>UdpSocket::as_raw_fd</source>
          <target state="translated">UdpSocket::as_raw_fd</target>
        </trans-unit>
        <trans-unit id="3dead55d6e23751656153f593bd69532bbdd74b4" translate="yes" xml:space="preserve">
          <source>UdpSocket::as_raw_socket</source>
          <target state="translated">UdpSocket::as_raw_socket</target>
        </trans-unit>
        <trans-unit id="e711eb64b283a492f76bc94de05d5beae4ce3446" translate="yes" xml:space="preserve">
          <source>UdpSocket::bind</source>
          <target state="translated">UdpSocket::bind</target>
        </trans-unit>
        <trans-unit id="bd6abe4ecc1b7a3998504825b222c78c7397b977" translate="yes" xml:space="preserve">
          <source>UdpSocket::borrow</source>
          <target state="translated">UdpSocket::borrow</target>
        </trans-unit>
        <trans-unit id="d6dfaba170b099d4935948d95be3a9b2d44c1b67" translate="yes" xml:space="preserve">
          <source>UdpSocket::borrow_mut</source>
          <target state="translated">UdpSocket::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c7601afb8a1f8cbf9600b90ec208697e7f31bb37" translate="yes" xml:space="preserve">
          <source>UdpSocket::broadcast</source>
          <target state="translated">UdpSocket::broadcast</target>
        </trans-unit>
        <trans-unit id="b5425c83fcfa16a56bdac78f93d426c4d76de0d0" translate="yes" xml:space="preserve">
          <source>UdpSocket::connect</source>
          <target state="translated">UdpSocket::connect</target>
        </trans-unit>
        <trans-unit id="4ef0111b75ab32121f2408b7d5f05ebfa5b6081d" translate="yes" xml:space="preserve">
          <source>UdpSocket::fmt</source>
          <target state="translated">UdpSocket::fmt</target>
        </trans-unit>
        <trans-unit id="6967c776a7bd3c84521bc241c391c1e849c635bd" translate="yes" xml:space="preserve">
          <source>UdpSocket::from</source>
          <target state="translated">UdpSocket::from</target>
        </trans-unit>
        <trans-unit id="bb5a7c0a1436e4ab18aa912a9f605f7b18ee8765" translate="yes" xml:space="preserve">
          <source>UdpSocket::from_raw_fd</source>
          <target state="translated">UdpSocket::from_raw_fd</target>
        </trans-unit>
        <trans-unit id="f80335b07809af571cc3df35b472a55569fb682a" translate="yes" xml:space="preserve">
          <source>UdpSocket::from_raw_socket</source>
          <target state="translated">UdpSocket::from_raw_socket</target>
        </trans-unit>
        <trans-unit id="9027e17e6ff5173579151cfa12fc5dbe9441694f" translate="yes" xml:space="preserve">
          <source>UdpSocket::into</source>
          <target state="translated">UdpSocket::into</target>
        </trans-unit>
        <trans-unit id="a803dafad8d15d21084fc92907391bd1b059ddfd" translate="yes" xml:space="preserve">
          <source>UdpSocket::into_raw_fd</source>
          <target state="translated">UdpSocket::into_raw_fd</target>
        </trans-unit>
        <trans-unit id="9cf9f423f72726c7578e2b5f5e2920796c1f2793" translate="yes" xml:space="preserve">
          <source>UdpSocket::into_raw_socket</source>
          <target state="translated">UdpSocket::into_raw_socket</target>
        </trans-unit>
        <trans-unit id="3f8673b9aaf4671a169334c3798e42c1cef61195" translate="yes" xml:space="preserve">
          <source>UdpSocket::join_multicast_v4</source>
          <target state="translated">UdpSocket::join_multicast_v4</target>
        </trans-unit>
        <trans-unit id="fdb0ef8819eb18c412a260ee8e4e9ed4c176ee44" translate="yes" xml:space="preserve">
          <source>UdpSocket::join_multicast_v6</source>
          <target state="translated">UdpSocket::join_multicast_v6</target>
        </trans-unit>
        <trans-unit id="daf0d0331de8a89e9e07829bd3f8f62b73e26c9f" translate="yes" xml:space="preserve">
          <source>UdpSocket::leave_multicast_v4</source>
          <target state="translated">UdpSocket::leave_multicast_v4</target>
        </trans-unit>
        <trans-unit id="19e7ef348410341be9e9f87a0c453576eeabf4f2" translate="yes" xml:space="preserve">
          <source>UdpSocket::leave_multicast_v6</source>
          <target state="translated">UdpSocket::leave_multicast_v6</target>
        </trans-unit>
        <trans-unit id="4541378b6e55fa1b6ff0ecd59a93caf5944114ce" translate="yes" xml:space="preserve">
          <source>UdpSocket::local_addr</source>
          <target state="translated">UdpSocket::local_addr</target>
        </trans-unit>
        <trans-unit id="e1d4fbc9e9ee16f13b25d7e15d3094bef922be02" translate="yes" xml:space="preserve">
          <source>UdpSocket::multicast_loop_v4</source>
          <target state="translated">UdpSocket::multicast_loop_v4</target>
        </trans-unit>
        <trans-unit id="47fea5b479b31e88d1e71ca6bcfb3bb1110ffa70" translate="yes" xml:space="preserve">
          <source>UdpSocket::multicast_loop_v6</source>
          <target state="translated">UdpSocket::multicast_loop_v6</target>
        </trans-unit>
        <trans-unit id="af0afd1673286058b665d369d31b395392204948" translate="yes" xml:space="preserve">
          <source>UdpSocket::multicast_ttl_v4</source>
          <target state="translated">UdpSocket::multicast_ttl_v4</target>
        </trans-unit>
        <trans-unit id="7ea92dd593f0d5cfd6700064620321c00b369e37" translate="yes" xml:space="preserve">
          <source>UdpSocket::peek</source>
          <target state="translated">UdpSocket::peek</target>
        </trans-unit>
        <trans-unit id="618b3359f531c1676b89a79683f9f10d7d9e63d6" translate="yes" xml:space="preserve">
          <source>UdpSocket::peek_from</source>
          <target state="translated">UdpSocket::peek_from</target>
        </trans-unit>
        <trans-unit id="ed605d1f943615e31a607bcc21bab5caa4744d32" translate="yes" xml:space="preserve">
          <source>UdpSocket::peer_addr</source>
          <target state="translated">UdpSocket::peer_addr</target>
        </trans-unit>
        <trans-unit id="e623079f9fa431b1604c2d3e586552e0f51cec43" translate="yes" xml:space="preserve">
          <source>UdpSocket::read_timeout</source>
          <target state="translated">UdpSocket::read_timeout</target>
        </trans-unit>
        <trans-unit id="117a240778e6d7c73d9190f8661f261267ed1dce" translate="yes" xml:space="preserve">
          <source>UdpSocket::recv</source>
          <target state="translated">UdpSocket::recv</target>
        </trans-unit>
        <trans-unit id="6b5d35c54deb341c259817d88dd2d0d29fec7a61" translate="yes" xml:space="preserve">
          <source>UdpSocket::recv_from</source>
          <target state="translated">UdpSocket::recv_from</target>
        </trans-unit>
        <trans-unit id="342543bea1d10360d53cdb0e77dc5cb9afda6331" translate="yes" xml:space="preserve">
          <source>UdpSocket::send</source>
          <target state="translated">UdpSocket::send</target>
        </trans-unit>
        <trans-unit id="22d3f7e464f346e514fa3986fce3b3f1e2571e5b" translate="yes" xml:space="preserve">
          <source>UdpSocket::send_to</source>
          <target state="translated">UdpSocket::send_to</target>
        </trans-unit>
        <trans-unit id="9e2a55f7f7b4b48356483d8d2fb5b602fa0f3530" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_broadcast</source>
          <target state="translated">UdpSocket::set_broadcast</target>
        </trans-unit>
        <trans-unit id="3f47efd4587a1a296613dd09d826c04823707540" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_multicast_loop_v4</source>
          <target state="translated">UdpSocket::set_multicast_loop_v4</target>
        </trans-unit>
        <trans-unit id="e20ba27d970b370c3419b1aeb14d08d71bc56a8c" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_multicast_loop_v6</source>
          <target state="translated">UdpSocket::set_multicast_loop_v6</target>
        </trans-unit>
        <trans-unit id="9cd522d20aa030dbf9138752a7e810a44b5efb38" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_multicast_ttl_v4</source>
          <target state="translated">UdpSocket::set_multicast_ttl_v4</target>
        </trans-unit>
        <trans-unit id="03074d339b260baa1ad044577238a1336825ab4b" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_nonblocking</source>
          <target state="translated">UdpSocket::set_nonblocking</target>
        </trans-unit>
        <trans-unit id="d915caa0f42d8eb7576e0424ad1fb96ff110018c" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_read_timeout</source>
          <target state="translated">UdpSocket::set_read_timeout</target>
        </trans-unit>
        <trans-unit id="00311ef46c51fae7556414d73e84c73f1d7812ff" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_ttl</source>
          <target state="translated">UdpSocket::set_ttl</target>
        </trans-unit>
        <trans-unit id="febfbd7ca83810329de07b88d8fb3393c6ca4798" translate="yes" xml:space="preserve">
          <source>UdpSocket::set_write_timeout</source>
          <target state="translated">UdpSocket::set_write_timeout</target>
        </trans-unit>
        <trans-unit id="9d7c771c5a45977006ca3dfa60a86af6dd8ee823" translate="yes" xml:space="preserve">
          <source>UdpSocket::take_error</source>
          <target state="translated">UdpSocket::take_error</target>
        </trans-unit>
        <trans-unit id="9f4ec7ded42c7be9420f00ecf5a43baac427f3a2" translate="yes" xml:space="preserve">
          <source>UdpSocket::try_clone</source>
          <target state="translated">UdpSocket::try_clone</target>
        </trans-unit>
        <trans-unit id="124c70e6a48a5f998f83b2f8f60af01be757111c" translate="yes" xml:space="preserve">
          <source>UdpSocket::try_from</source>
          <target state="translated">UdpSocket::try_from</target>
        </trans-unit>
        <trans-unit id="419d8221e876e08ccc71dcef9e30956e6a2336ce" translate="yes" xml:space="preserve">
          <source>UdpSocket::try_into</source>
          <target state="translated">UdpSocket::try_into</target>
        </trans-unit>
        <trans-unit id="179be00cc6604f24b28a0eaa033c371e9b537141" translate="yes" xml:space="preserve">
          <source>UdpSocket::ttl</source>
          <target state="translated">UdpSocket::ttl</target>
        </trans-unit>
        <trans-unit id="2e57927ff8f0f2d0d53c88f359b91dce0a9fac1a" translate="yes" xml:space="preserve">
          <source>UdpSocket::type_id</source>
          <target state="translated">UdpSocket::type_id</target>
        </trans-unit>
        <trans-unit id="6e4a0fe28e49c9f074eb8b5bf8aa033213c911d5" translate="yes" xml:space="preserve">
          <source>UdpSocket::write_timeout</source>
          <target state="translated">UdpSocket::write_timeout</target>
        </trans-unit>
        <trans-unit id="ad739a773605a26e0e278e2e21fb10279a5b2fe3" translate="yes" xml:space="preserve">
          <source>Ultimately, lifetime syntax is about connecting the lifetimes of various parameters and return values of functions. Once they&amp;rsquo;re connected, Rust has enough information to allow memory-safe operations and disallow operations that would create dangling pointers or otherwise violate memory safety.</source>
          <target state="translated">궁극적으로 수명 구문은 다양한 매개 변수의 수명과 함수의 반환 값을 연결하는 것입니다. 일단 연결되면 Rust는 메모리 안전 작업을 허용하고 매달려 포인터를 만들거나 메모리 안전을 위반하는 작업을 허용하지 않을만큼 충분한 정보를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="4eb578990ad7468d516f19c1a212e616f769fb7d" translate="yes" xml:space="preserve">
          <source>Ultimately, we want to convert the &lt;code&gt;String&lt;/code&gt; the program reads as input into a real number type so we can compare it numerically to the secret number. We can do that by adding another line to the &lt;code&gt;main&lt;/code&gt; function body:</source>
          <target state="translated">궁극적으로 우리 는 프로그램이 입력으로 읽은 &lt;code&gt;String&lt;/code&gt; 실수 유형 으로 변환하여 숫자로 비밀 번호와 비교할 수 있습니다. &lt;code&gt;main&lt;/code&gt; 함수 본문에 다른 줄을 추가하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c83e690d015c2dda5615d91434e066248316e35" translate="yes" xml:space="preserve">
          <source>Ultimately, we want to convert the &lt;code&gt;String&lt;/code&gt; the program reads as input into a real number type so we can compare it numerically to the secret number. We can do that by adding the following two lines to the &lt;code&gt;main&lt;/code&gt; function body:</source>
          <target state="translated">궁극적으로, 우리 는 프로그램이 입력으로 읽은 &lt;code&gt;String&lt;/code&gt; 실수 형 으로 변환하여 숫자와 비밀 번호를 비교할 수 있습니다. &lt;code&gt;main&lt;/code&gt; 함수 본문에 다음 두 줄을 추가하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="f65abf2396d9d0e3036b5edd214ba0117f22347c" translate="yes" xml:space="preserve">
          <source>Unaligned pointer reading and writing outside of &lt;a href=&quot;../std/ptr/fn.read_unaligned&quot;&gt;&lt;code&gt;read_unaligned&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/ptr/fn.write_unaligned&quot;&gt;&lt;code&gt;write_unaligned&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정렬되지 않은 포인터 읽기 및 쓰기 외부 &lt;a href=&quot;../std/ptr/fn.read_unaligned&quot;&gt; &lt;code&gt;read_unaligned&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../std/ptr/fn.write_unaligned&quot;&gt; &lt;code&gt;write_unaligned&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e740f17c2c4678005ceef9e2ecf547507892500" translate="yes" xml:space="preserve">
          <source>Unaligned values cannot be dropped in place, they must be copied to an aligned location first using &lt;a href=&quot;../ptr/fn.read_unaligned&quot;&gt;&lt;code&gt;ptr::read_unaligned&lt;/code&gt;&lt;/a&gt;. For packed structs, this move is done automatically by the compiler. This means the fields of packed structs are not dropped in-place.</source>
          <target state="translated">정렬되지 않은 값은 제자리에 놓을 수 없으며 먼저 &lt;a href=&quot;../ptr/fn.read_unaligned&quot;&gt; &lt;code&gt;ptr::read_unaligned&lt;/code&gt; &lt;/a&gt; 사용하여 정렬 된 위치에 복사해야합니다 . 패킹 된 구조체의 경우이 이동은 컴파일러에 의해 자동으로 수행됩니다. 이는 패킹 된 구조체의 필드가 제자리에 놓이지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="de8646776b21ba1fa4fa08017bad8f9f8fd98a56" translate="yes" xml:space="preserve">
          <source>Unaligned values cannot be dropped in place, they must be copied to an aligned location first using &lt;a href=&quot;fn.read_unaligned&quot;&gt;&lt;code&gt;ptr::read_unaligned&lt;/code&gt;&lt;/a&gt;. For packed structs, this move is done automatically by the compiler. This means the fields of packed structs are not dropped in-place.</source>
          <target state="translated">정렬되지 않은 값은 제자리에 놓을 수 없으며 먼저 &lt;a href=&quot;fn.read_unaligned&quot;&gt; &lt;code&gt;ptr::read_unaligned&lt;/code&gt; &lt;/a&gt; 사용하여 정렬 된 위치에 복사해야합니다 . 패킹 된 구조체의 경우이 이동은 컴파일러에 의해 자동으로 수행됩니다. 이는 패킹 된 구조체의 필드가 제자리에 놓이지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a19c02a20defb4e5a19ad20ddc9f198b595912c2" translate="yes" xml:space="preserve">
          <source>Unaligned values cannot be dropped in place, they must be copied to an aligned location first:</source>
          <target state="translated">정렬되지 않은 값은 제자리에 놓을 수 없으며 정렬 된 위치에 먼저 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="06561b17b729c80e40714208c692221607fb499c" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;-&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;&lt;code&gt;!&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;&amp;amp;mut&lt;/code&gt;</source>
          <target state="translated">단항 &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;!&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;&amp;amp;mut&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eaeaaeab2b8c39fed19b6ad2f8f02ca13156250d" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; i128::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; i128::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 더하기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self + rhs&lt;/code&gt; 계산 합니다. 따라서 &lt;code&gt;self + rhs &amp;gt; i128::MAX&lt;/code&gt; 또는 &lt;code&gt;self + rhs &amp;lt; i128::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="bf60089baa8e1b12ead76beae70eb523584bfcff" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; i16::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; i16::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 더하기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self + rhs&lt;/code&gt; 계산 합니다. 따라서 &lt;code&gt;self + rhs &amp;gt; i16::MAX&lt;/code&gt; 또는 &lt;code&gt;self + rhs &amp;lt; i16::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="57d2d3f2c8b1f0f83b5c8311b2489a069d73a68e" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; i32::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; i32::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 더하기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self + rhs&lt;/code&gt; 계산 합니다. 따라서 &lt;code&gt;self + rhs &amp;gt; i32::MAX&lt;/code&gt; 또는 &lt;code&gt;self + rhs &amp;lt; i32::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="04a73576177ebee5f439e851247328471bb0c25a" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; i64::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; i64::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 더하기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self + rhs&lt;/code&gt; 계산 합니다. 따라서 &lt;code&gt;self + rhs &amp;gt; i64::MAX&lt;/code&gt; 또는 &lt;code&gt;self + rhs &amp;lt; i64::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="98456ae98d27b023cd6297deba77970fa8fe5737" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; i8::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; i8::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 더하기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self + rhs&lt;/code&gt; 계산 합니다. 따라서 &lt;code&gt;self + rhs &amp;gt; i8::MAX&lt;/code&gt; 또는 &lt;code&gt;self + rhs &amp;lt; i8::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="181cfbbcfa7badb7116e737475005644ef4b02af" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; isize::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; isize::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 더하기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self + rhs&lt;/code&gt; 계산 합니다. 결과적으로 &lt;code&gt;self + rhs &amp;gt; isize::MAX&lt;/code&gt; 또는 &lt;code&gt;self + rhs &amp;lt; isize::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="6e7dffee5ddf31f6bb308589f3d1034539c1ed44" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; u128::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; u128::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 더하기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self + rhs&lt;/code&gt; 계산 합니다. 따라서 &lt;code&gt;self + rhs &amp;gt; u128::MAX&lt;/code&gt; 또는 &lt;code&gt;self + rhs &amp;lt; u128::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="f17243b2da1ec0e37d5c613451d7b628005e7af8" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; u16::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; u16::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 더하기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self + rhs&lt;/code&gt; 계산 합니다. 따라서 &lt;code&gt;self + rhs &amp;gt; u16::MAX&lt;/code&gt; 또는 &lt;code&gt;self + rhs &amp;lt; u16::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="e8a542644a4285f9d7b2a44c5f2775b79db39a7b" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; u32::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; u32::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 더하기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self + rhs&lt;/code&gt; 계산 합니다. 결과적으로 &lt;code&gt;self + rhs &amp;gt; u32::MAX&lt;/code&gt; 또는 &lt;code&gt;self + rhs &amp;lt; u32::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="bae0a8aba40c37aa489fd12e7bd803aa59ab9b06" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; u64::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; u64::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 더하기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self + rhs&lt;/code&gt; 계산 합니다. 따라서 &lt;code&gt;self + rhs &amp;gt; u64::MAX&lt;/code&gt; 또는 &lt;code&gt;self + rhs &amp;lt; u64::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="217823d7931de445dbac4c7c600ba231f5d01a32" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; u8::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; u8::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 더하기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self + rhs&lt;/code&gt; 계산 합니다. 따라서 &lt;code&gt;self + rhs &amp;gt; u8::MAX&lt;/code&gt; 또는 &lt;code&gt;self + rhs &amp;lt; u8::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="3784f542c08995d9da31ec918116bee7959049c6" translate="yes" xml:space="preserve">
          <source>Unchecked integer addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self + rhs &amp;gt; usize::MAX&lt;/code&gt; or &lt;code&gt;self + rhs &amp;lt; usize::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 더하기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self + rhs&lt;/code&gt; 계산 합니다. 이로 인해 &lt;code&gt;self + rhs &amp;gt; usize::MAX&lt;/code&gt; 또는 &lt;code&gt;self + rhs &amp;lt; usize::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="e46989e35b2cb886206f7735df0231524fbe7ccd" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; i128::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; i128::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 곱셈. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self * rhs&lt;/code&gt; 계산 합니다. 따라서 &lt;code&gt;self * rhs &amp;gt; i128::MAX&lt;/code&gt; 또는 &lt;code&gt;self * rhs &amp;lt; i128::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="e25f8da52dbbff157dca4617b3f1a59b2bfc36a7" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; i16::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; i16::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 곱셈. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self * rhs&lt;/code&gt; 계산 합니다. 따라서 &lt;code&gt;self * rhs &amp;gt; i16::MAX&lt;/code&gt; 또는 &lt;code&gt;self * rhs &amp;lt; i16::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="35f739b4aaf5e35f8f41b2fc34c5c1af364fd56e" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; i32::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; i32::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 곱셈. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self * rhs&lt;/code&gt; 계산 합니다. 이로 인해 &lt;code&gt;self * rhs &amp;gt; i32::MAX&lt;/code&gt; 또는 &lt;code&gt;self * rhs &amp;lt; i32::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="68857c1be152e69874bd8a3d7df9e0082927641b" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; i64::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; i64::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 곱셈. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self * rhs&lt;/code&gt; 계산 합니다. 이로 인해 &lt;code&gt;self * rhs &amp;gt; i64::MAX&lt;/code&gt; 또는 &lt;code&gt;self * rhs &amp;lt; i64::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="43ba5e2f667a70448c2bc30e68127889e33fbcb0" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; i8::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; i8::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 곱셈. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self * rhs&lt;/code&gt; 계산 합니다. 이로 인해 &lt;code&gt;self * rhs &amp;gt; i8::MAX&lt;/code&gt; 또는 &lt;code&gt;self * rhs &amp;lt; i8::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="2d8ea5bd84cde0d4b308a1762db7027c570a55b6" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; isize::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; isize::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 곱셈. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self * rhs&lt;/code&gt; 계산 합니다. 이로 인해 &lt;code&gt;self * rhs &amp;gt; isize::MAX&lt;/code&gt; 또는 &lt;code&gt;self * rhs &amp;lt; isize::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="b9ddf676d896b37ebffa48cd9f6ff3ee28c7f039" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; u128::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; u128::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 곱셈. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self * rhs&lt;/code&gt; 계산 합니다. 결과적으로 &lt;code&gt;self * rhs &amp;gt; u128::MAX&lt;/code&gt; 또는 &lt;code&gt;self * rhs &amp;lt; u128::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="a3bb62e69c1601ccfe0ef959e2a876a22790ef04" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; u16::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; u16::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 곱셈. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self * rhs&lt;/code&gt; 계산 합니다. 이로 인해 &lt;code&gt;self * rhs &amp;gt; u16::MAX&lt;/code&gt; 또는 &lt;code&gt;self * rhs &amp;lt; u16::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="e65b8aaadedff35c0a62f7a135254f90f4ccab0a" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; u32::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; u32::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 곱셈. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self * rhs&lt;/code&gt; 계산 합니다. 이로 인해 &lt;code&gt;self * rhs &amp;gt; u32::MAX&lt;/code&gt; 또는 &lt;code&gt;self * rhs &amp;lt; u32::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="111c8c208814caa52463838dcecbd292a0ff4bce" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; u64::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; u64::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 곱셈. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self * rhs&lt;/code&gt; 계산 합니다. 따라서 &lt;code&gt;self * rhs &amp;gt; u64::MAX&lt;/code&gt; 또는 &lt;code&gt;self * rhs &amp;lt; u64::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="fa225d3efab56513dbab5c9b4e8a9843ef6fdaf6" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; u8::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; u8::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 곱셈. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self * rhs&lt;/code&gt; 계산 합니다. 이로 인해 &lt;code&gt;self * rhs &amp;gt; u8::MAX&lt;/code&gt; 또는 &lt;code&gt;self * rhs &amp;lt; u8::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="357967f063fbfe8af622e52b6f92d48adbffb3ef" translate="yes" xml:space="preserve">
          <source>Unchecked integer multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self * rhs &amp;gt; usize::MAX&lt;/code&gt; or &lt;code&gt;self * rhs &amp;lt; usize::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 곱셈. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self * rhs&lt;/code&gt; 계산 합니다. 이로 인해 &lt;code&gt;self * rhs &amp;gt; usize::MAX&lt;/code&gt; 또는 &lt;code&gt;self * rhs &amp;lt; usize::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="fe8dd13c5dff45f9d9fade7c23010632d824bbc5" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; i128::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; i128::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 빼기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self - rhs&lt;/code&gt; 계산 합니다. 이로 인해 &lt;code&gt;self - rhs &amp;gt; i128::MAX&lt;/code&gt; 또는 &lt;code&gt;self - rhs &amp;lt; i128::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="4f796122fc9def8df4649d0b2d125dd1cd6e291b" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; i16::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; i16::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 빼기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self - rhs&lt;/code&gt; 계산 합니다. 이로 인해 &lt;code&gt;self - rhs &amp;gt; i16::MAX&lt;/code&gt; 또는 &lt;code&gt;self - rhs &amp;lt; i16::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="84c8864cef260c48a4e59f2b70d655fdf389430b" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; i32::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; i32::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 빼기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self - rhs&lt;/code&gt; 계산 합니다. 이로 인해 &lt;code&gt;self - rhs &amp;gt; i32::MAX&lt;/code&gt; 또는 &lt;code&gt;self - rhs &amp;lt; i32::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="31a325f491fcfe3291d440373b764f580c3f0582" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; i64::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; i64::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 빼기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self - rhs&lt;/code&gt; 계산 합니다. 이로 인해 &lt;code&gt;self - rhs &amp;gt; i64::MAX&lt;/code&gt; 또는 &lt;code&gt;self - rhs &amp;lt; i64::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="c6cd990380c2a0d5b9b2454a9569e6e2c5a42f96" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; i8::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; i8::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 빼기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self - rhs&lt;/code&gt; 계산 합니다. 이로 인해 &lt;code&gt;self - rhs &amp;gt; i8::MAX&lt;/code&gt; 또는 &lt;code&gt;self - rhs &amp;lt; i8::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="af189c7306f2089208258aece688aaa4cbb8ac02" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; isize::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; isize::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 빼기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self - rhs&lt;/code&gt; 계산 합니다. 이로 인해 &lt;code&gt;self - rhs &amp;gt; isize::MAX&lt;/code&gt; 또는 &lt;code&gt;self - rhs &amp;lt; isize::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="ba6ec2a37ff7eb25e8c786febab4ab98bbd27660" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; u128::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; u128::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 빼기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self - rhs&lt;/code&gt; 계산 합니다. 이로 인해 &lt;code&gt;self - rhs &amp;gt; u128::MAX&lt;/code&gt; 또는 &lt;code&gt;self - rhs &amp;lt; u128::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="baacb800b9617663d503dd16c499fbf3c18d485b" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; u16::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; u16::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 빼기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self - rhs&lt;/code&gt; 계산 합니다. 이로 인해 &lt;code&gt;self - rhs &amp;gt; u16::MAX&lt;/code&gt; 또는 &lt;code&gt;self - rhs &amp;lt; u16::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="026df7825e54c4d4d1564e862d070306e0b0ad6b" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; u32::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; u32::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 빼기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self - rhs&lt;/code&gt; 계산 합니다. 이로 인해 &lt;code&gt;self - rhs &amp;gt; u32::MAX&lt;/code&gt; 또는 &lt;code&gt;self - rhs &amp;lt; u32::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="7acb45d177f4b13e2bbada8a1a7786dfd123ebb3" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; u64::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; u64::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 빼기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self - rhs&lt;/code&gt; 계산 합니다. 이로 인해 &lt;code&gt;self - rhs &amp;gt; u64::MAX&lt;/code&gt; 또는 &lt;code&gt;self - rhs &amp;lt; u64::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="474d17a8d47d3b421384881d2bc565471dac82d4" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; u8::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; u8::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 빼기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self - rhs&lt;/code&gt; 계산 합니다. 따라서 &lt;code&gt;self - rhs &amp;gt; u8::MAX&lt;/code&gt; 또는 &lt;code&gt;self - rhs &amp;lt; u8::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="f27d966c87f4516cf43f8b199f1a37517f69d9bb" translate="yes" xml:space="preserve">
          <source>Unchecked integer subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, assuming overflow cannot occur. This results in undefined behavior when &lt;code&gt;self - rhs &amp;gt; usize::MAX&lt;/code&gt; or &lt;code&gt;self - rhs &amp;lt; usize::MIN&lt;/code&gt;.</source>
          <target state="translated">확인되지 않은 정수 빼기. 오버플로가 발생할 수 없다고 가정하고 &lt;code&gt;self - rhs&lt;/code&gt; 계산 합니다. 이로 인해 &lt;code&gt;self - rhs &amp;gt; usize::MAX&lt;/code&gt; 또는 &lt;code&gt;self - rhs &amp;lt; usize::MIN&lt;/code&gt; 때 정의되지 않은 동작이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="1c9a7a4592fa01f0c87a973312a3417b3c758e1e" translate="yes" xml:space="preserve">
          <source>Uncovered type</source>
          <target state="translated">폭로 된 유형</target>
        </trans-unit>
        <trans-unit id="ebb35fed37a359f87ca6b9131bfd7b210eb81cd6" translate="yes" xml:space="preserve">
          <source>Undefined behavior</source>
          <target state="translated">정의되지 않은 동작</target>
        </trans-unit>
        <trans-unit id="370c58f039e07727be3fca997e7473eb72b353e5" translate="yes" xml:space="preserve">
          <source>Under the &lt;a href=&quot;../type-layout#the-default-representation&quot;&gt;default representation&lt;/a&gt;, the specified discriminant is interpreted as an &lt;code&gt;isize&lt;/code&gt; value although the compiler is allowed to use a smaller type in the actual memory layout. The size and thus acceptable values can be changed by using a &lt;a href=&quot;../type-layout#primitive-representations&quot;&gt;primitive representation&lt;/a&gt; or the &lt;a href=&quot;../type-layout#the-c-representation&quot;&gt;&lt;code&gt;C&lt;/code&gt; representation&lt;/a&gt;.</source>
          <target state="translated">언더 &lt;a href=&quot;../type-layout#the-default-representation&quot;&gt;기본 표현&lt;/a&gt; , 지정된 판별은로 해석됩니다 &lt;code&gt;isize&lt;/code&gt; 컴파일러가 실제 메모리 레이아웃에 작은 유형을 사용할 수 있지만 값. &lt;a href=&quot;../type-layout#primitive-representations&quot;&gt;프리미티브 표현&lt;/a&gt; 또는 &lt;a href=&quot;../type-layout#the-c-representation&quot;&gt; &lt;code&gt;C&lt;/code&gt; 표현&lt;/a&gt; 을 사용하여 크기와 허용 가능한 값을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="934025592a349e0ccdf3fcea702e3b4fab1b4701" translate="yes" xml:space="preserve">
          <source>Under the surface, the &lt;code&gt;assert_eq!&lt;/code&gt; and &lt;code&gt;assert_ne!&lt;/code&gt; macros use the operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;, respectively. When the assertions fail, these macros print their arguments using debug formatting, which means the values being compared must implement the &lt;code&gt;PartialEq&lt;/code&gt; and &lt;code&gt;Debug&lt;/code&gt; traits. All the primitive types and most of the standard library types implement these traits. For structs and enums that you define, you&amp;rsquo;ll need to implement &lt;code&gt;PartialEq&lt;/code&gt; to assert that values of those types are equal or not equal. You&amp;rsquo;ll need to implement &lt;code&gt;Debug&lt;/code&gt; to print the values when the assertion fails. Because both traits are derivable traits, as mentioned in Listing 5-12 in Chapter 5, this is usually as straightforward as adding the &lt;code&gt;#[derive(PartialEq, Debug)]&lt;/code&gt; annotation to your struct or enum definition. See Appendix C, &lt;a href=&quot;appendix-03-derivable-traits&quot;&gt;&amp;ldquo;Derivable Traits,&amp;rdquo;&lt;/a&gt; for more details about these and other derivable traits.</source>
          <target state="translated">표면 아래에서 &lt;code&gt;assert_eq!&lt;/code&gt; 그리고 &lt;code&gt;assert_ne!&lt;/code&gt; 매크로는 각각 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 연산자를 사용합니다 . 어설 션이 실패하면 이러한 매크로는 디버그 형식을 사용하여 인수를 인쇄합니다. 이는 비교중인 값이 &lt;code&gt;PartialEq&lt;/code&gt; 및 &lt;code&gt;Debug&lt;/code&gt; 특성을 구현해야 함을 의미합니다 . 모든 기본 유형과 대부분의 표준 라이브러리 유형은 이러한 특성을 구현합니다. 정의한 구조체와 열거 형의 경우 &lt;code&gt;PartialEq&lt;/code&gt; 를 구현 하여 해당 유형의 값이 같거나 같지 않아야합니다. &lt;code&gt;Debug&lt;/code&gt; 를 구현해야합니다어설 션이 실패 할 때 값을 인쇄합니다. 5 장의 목록 5-12에서 언급 한 것처럼 두 특성이 모두 파생 가능한 특성이므로 일반적으로 &lt;code&gt;#[derive(PartialEq, Debug)]&lt;/code&gt; 주석을 구조체 또는 열거 정의에 추가하는 것만 큼 간단 합니다. 이러한 특성 및 기타 파생 &lt;a href=&quot;appendix-03-derivable-traits&quot;&gt;가능한 특성에&lt;/a&gt; 대한 자세한 내용은 부록 C, &quot; 파생 특성 &quot; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c52b1bbb83c6ff68ef901a5b3c68e708f2da78aa" translate="yes" xml:space="preserve">
          <source>Underlying System calls</source>
          <target state="translated">기본 시스템 호출</target>
        </trans-unit>
        <trans-unit id="ca035a5ce4c3df59c37ddda21e0189a6380e3b1f" translate="yes" xml:space="preserve">
          <source>Underscore</source>
          <target state="translated">Underscore</target>
        </trans-unit>
        <trans-unit id="7bd1424f9d38ad3f094e622e30f38d61cffee843" translate="yes" xml:space="preserve">
          <source>Underscore Imports</source>
          <target state="translated">밑줄 수입</target>
        </trans-unit>
        <trans-unit id="e31df2c04ec1e4b0b36bedd38e82d9eeb2726bb3" translate="yes" xml:space="preserve">
          <source>Understanding Ownership</source>
          <target state="translated">소유권 이해</target>
        </trans-unit>
        <trans-unit id="f50d8069b5b46a2b00b55d627b937dadef8d4c8b" translate="yes" xml:space="preserve">
          <source>Undo the effect of leaked guards on the borrow state of the &lt;code&gt;RefCell&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RefCell&lt;/code&gt; 의 차용 상태에서 누출 된 가드의 효과를 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="2bd6a0012c9128bdcdb48f1df7a5232a746b1dd8" translate="yes" xml:space="preserve">
          <source>Unfortunately, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is not safe to share across threads. When &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; manages the reference count, it adds to the count for each call to &lt;code&gt;clone&lt;/code&gt; and subtracts from the count when each clone is dropped. But it doesn&amp;rsquo;t use any concurrency primitives to make sure that changes to the count can&amp;rsquo;t be interrupted by another thread. This could lead to wrong counts&amp;mdash;subtle bugs that could in turn lead to memory leaks or a value being dropped before we&amp;rsquo;re done with it. What we need is a type exactly like &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; but one that makes changes to the reference count in a thread-safe way.</source>
          <target state="translated">불행히도 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 는 스레드간에 공유하기에 안전하지 않습니다. &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 는 참조 횟수를 관리 할 때 &lt;code&gt;clone&lt;/code&gt; 할 각 호출의 개수에 추가하고 각 클론이 삭제 될 때 해당 개수에서 뺍니다. 그러나 다른 스레드가 카운트 변경을 방해 할 수 없도록 동시성 프리미티브를 사용하지 않습니다. 이것은 잘못된 카운트로 이어질 수 있습니다. 미묘한 버그로 인해 메모리 누수가 발생하거나 완료하기 전에 값이 떨어질 수 있습니다. 우리에게 필요한 것은 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 와 정확히 같은 유형 이지만 스레드 안전 방식으로 참조 카운트를 변경 하는 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="ccb18a8dd577d217916f372c4de88677ea8361fc" translate="yes" xml:space="preserve">
          <source>Unfortunately, it&amp;rsquo;s not straightforward to disable the automatic &lt;code&gt;drop&lt;/code&gt; functionality. Disabling &lt;code&gt;drop&lt;/code&gt; isn&amp;rsquo;t usually necessary; the whole point of the &lt;code&gt;Drop&lt;/code&gt; trait is that it&amp;rsquo;s taken care of automatically. Occasionally, however, you might want to clean up a value early. One example is when using smart pointers that manage locks: you might want to force the &lt;code&gt;drop&lt;/code&gt; method that releases the lock so that other code in the same scope can acquire the lock. Rust doesn&amp;rsquo;t let you call the &lt;code&gt;Drop&lt;/code&gt; trait&amp;rsquo;s &lt;code&gt;drop&lt;/code&gt; method manually; instead you have to call the &lt;code&gt;std::mem::drop&lt;/code&gt; function provided by the standard library if you want to force a value to be dropped before the end of its scope.</source>
          <target state="translated">불행히도 자동 &lt;code&gt;drop&lt;/code&gt; 기능 을 비활성화하는 것은 간단하지 않습니다 . &lt;code&gt;drop&lt;/code&gt; 비활성화 는 일반적으로 필요하지 않습니다. 의 요점 &lt;code&gt;Drop&lt;/code&gt; 특성은 자동으로 알아서 점이다. 그러나 때때로 값을 일찍 정리해야 할 수 있습니다. 한 가지 예는 잠금을 관리하는 스마트 포인터를 사용하는 경우 입니다. 동일한 범위에있는 다른 코드가 잠금을 획득 할 수 있도록 잠금을 해제하는 &lt;code&gt;drop&lt;/code&gt; 메소드 를 강제로 사용할 수 있습니다. Rust는 &lt;code&gt;Drop&lt;/code&gt; 트레이 트의 &lt;code&gt;drop&lt;/code&gt; 메서드를 수동으로 호출 할 수 없습니다 . 대신 &lt;code&gt;std::mem::drop&lt;/code&gt; 을 호출해야합니다.범위가 끝나기 전에 값을 강제로 삭제하려는 경우 표준 라이브러리에서 제공하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="1444761777045d9a10886b422e6940c76965059f" translate="yes" xml:space="preserve">
          <source>Unfortunately, it&amp;rsquo;s not straightforward to disable the automatic &lt;code&gt;drop&lt;/code&gt; functionality. Disabling &lt;code&gt;drop&lt;/code&gt; isn&amp;rsquo;t usually necessary; the whole point of the &lt;code&gt;Drop&lt;/code&gt; trait is that it&amp;rsquo;s taken care of automatically. Occasionally, however, you might want to clean up a value early. One example is when using smart pointers that manage locks: you might want to force the &lt;code&gt;drop&lt;/code&gt; method that releases the lock to run so other code in the same scope can acquire the lock. Rust doesn&amp;rsquo;t let you call the &lt;code&gt;Drop&lt;/code&gt; trait&amp;rsquo;s &lt;code&gt;drop&lt;/code&gt; method manually; instead you have to call the &lt;code&gt;std::mem::drop&lt;/code&gt; function provided by the standard library if you want to force a value to be dropped before the end of its scope.</source>
          <target state="translated">불행히도 자동 &lt;code&gt;drop&lt;/code&gt; 기능 을 비활성화하는 것은 간단하지 않습니다 . &lt;code&gt;drop&lt;/code&gt; 비활성화 는 일반적으로 필요하지 않습니다. 의 요점 &lt;code&gt;Drop&lt;/code&gt; 특성은 자동으로 알아서 점이다. 그러나 때때로 값을 일찍 정리하고 싶을 수도 있습니다. 잠금을 관리하는 스마트 포인터를 사용하는 경우를 예로들 수 있습니다 . 잠금을 해제하는 &lt;code&gt;drop&lt;/code&gt; 메소드 를 강제 로 실행하여 동일한 범위에있는 다른 코드가 잠금을 획득 할 수 있습니다. Rust는 &lt;code&gt;Drop&lt;/code&gt; 특성의 &lt;code&gt;drop&lt;/code&gt; 메소드를 수동으로 호출 할 수 없습니다 . 대신 &lt;code&gt;std::mem::drop&lt;/code&gt; 을 호출해야합니다. 범위가 끝나기 전에 값을 강제로 삭제하려는 경우 표준 라이브러리에서 제공하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="1a531b7898235009a0cc7b2eec486ea25b9d6d2f" translate="yes" xml:space="preserve">
          <source>Unfortunately, the code in Listing 7-5 still results in an error, as shown in Listing 7-6.</source>
          <target state="translated">불행히도 Listing 7-5에 표시된 것처럼 Listing 7-5의 코드는 여전히 오류를 발생시킨다.</target>
        </trans-unit>
        <trans-unit id="be79a988f81db8bfcf6945f3ba47d61010546fc9" translate="yes" xml:space="preserve">
          <source>Unicode escapes</source>
          <target state="translated">유니 코드 이스케이프</target>
        </trans-unit>
        <trans-unit id="ae0d9cce1182bdae15059a991a47bf01218e3825" translate="yes" xml:space="preserve">
          <source>Unicode escapes are never generated by this function.</source>
          <target state="translated">이 함수는 유니 코드 이스케이프를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="049c2f43b308773f947249e6515dfdd4cc3c35a2" translate="yes" xml:space="preserve">
          <source>Unicode is designed such that this effectively decodes bytes with the character encoding that IANA calls ISO-8859-1. This encoding is compatible with ASCII.</source>
          <target state="translated">유니 코드는 IANA가 ISO-8859-1이라고 부르는 문자 인코딩으로 바이트를 효과적으로 디코딩하도록 설계되었습니다. 이 인코딩은 ASCII와 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="045e4620605ab61ee2d00d3c61380dde56a437e0" translate="yes" xml:space="preserve">
          <source>Unicode string slices.</source>
          <target state="translated">유니 코드 문자열 조각.</target>
        </trans-unit>
        <trans-unit id="ea8b0aa9835ad896a48c3cd1f5107ad4d8a0d9e1" translate="yes" xml:space="preserve">
          <source>UnicodeVersion</source>
          <target state="translated">UnicodeVersion</target>
        </trans-unit>
        <trans-unit id="2e2480da297a5a795e54a8b1e8174027d5cb3056" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::borrow</source>
          <target state="translated">UnicodeVersion::borrow</target>
        </trans-unit>
        <trans-unit id="89b51103925ce314bbcaaf20a8fe1cadc3924003" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::borrow_mut</source>
          <target state="translated">UnicodeVersion::borrow_mut</target>
        </trans-unit>
        <trans-unit id="88a2e4badb33e94ea8a5b499e6fc153387a0beb3" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::clamp</source>
          <target state="translated">UnicodeVersion::clamp</target>
        </trans-unit>
        <trans-unit id="d17cdcafd0174814c16b4f219e4fed72e9bd469a" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::clone</source>
          <target state="translated">UnicodeVersion::clone</target>
        </trans-unit>
        <trans-unit id="47b2336d0c0eb30610891e9aeb66476192776d1f" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::clone_from</source>
          <target state="translated">UnicodeVersion::clone_from</target>
        </trans-unit>
        <trans-unit id="df3118b48825d7934a06fa42be12de85a41743a3" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::clone_into</source>
          <target state="translated">UnicodeVersion::clone_into</target>
        </trans-unit>
        <trans-unit id="a501e28c8f674e6c8775cd5763a1269e58854a95" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::cmp</source>
          <target state="translated">UnicodeVersion::cmp</target>
        </trans-unit>
        <trans-unit id="eb0f8f28b23626496734a42b66b3d04fceab6e15" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::eq</source>
          <target state="translated">UnicodeVersion::eq</target>
        </trans-unit>
        <trans-unit id="d50614eac8572f390490b398b9df8d2ee6162d01" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::fmt</source>
          <target state="translated">UnicodeVersion::fmt</target>
        </trans-unit>
        <trans-unit id="870f165e6cd936b143cbc0dbc14afac1093420d0" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::from</source>
          <target state="translated">UnicodeVersion::from</target>
        </trans-unit>
        <trans-unit id="2bad969f3e70b400e54b881fe8536995db1f2994" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::ge</source>
          <target state="translated">UnicodeVersion::ge</target>
        </trans-unit>
        <trans-unit id="08f3a8d2999b98ac5f6c67691d5bdd1bc1a0e145" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::gt</source>
          <target state="translated">UnicodeVersion::gt</target>
        </trans-unit>
        <trans-unit id="b5a9d9239e831f7ef74e7e53b12fa0fd62d71a97" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::into</source>
          <target state="translated">UnicodeVersion::into</target>
        </trans-unit>
        <trans-unit id="1ea14b2a7575169ecf16f30acb48c3409c34b763" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::le</source>
          <target state="translated">UnicodeVersion::le</target>
        </trans-unit>
        <trans-unit id="eb08588571d008fa3a48093f6cad0aa8209e47e3" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::lt</source>
          <target state="translated">UnicodeVersion::lt</target>
        </trans-unit>
        <trans-unit id="809dd77e054b744c6372ff89e0b31e14994e27e7" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::max</source>
          <target state="translated">UnicodeVersion::max</target>
        </trans-unit>
        <trans-unit id="1c035e39a67ae5609815950cc75aebf117385e95" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::min</source>
          <target state="translated">UnicodeVersion::min</target>
        </trans-unit>
        <trans-unit id="064f84b6703cb5f6f68f68e7fc2c4d251f631296" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::ne</source>
          <target state="translated">UnicodeVersion::ne</target>
        </trans-unit>
        <trans-unit id="7c59df82b034e552f2c3f4f3995f283f8463f626" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::partial_cmp</source>
          <target state="translated">UnicodeVersion::partial_cmp</target>
        </trans-unit>
        <trans-unit id="cd2d6e2e056d2c57e62b0e2e433f8281504be6b4" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::to_owned</source>
          <target state="translated">UnicodeVersion::to_owned</target>
        </trans-unit>
        <trans-unit id="c51cc398d26afae848ea754f781315242ac4e979" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::try_from</source>
          <target state="translated">UnicodeVersion::try_from</target>
        </trans-unit>
        <trans-unit id="a8b18a0ff13e1e11bb861c761bf0dc70df4c71e0" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::try_into</source>
          <target state="translated">UnicodeVersion::try_into</target>
        </trans-unit>
        <trans-unit id="eecb3bfce19f7a3ae0d89e37123a7c922b8eeab9" translate="yes" xml:space="preserve">
          <source>UnicodeVersion::type_id</source>
          <target state="translated">UnicodeVersion::type_id</target>
        </trans-unit>
        <trans-unit id="6ec76a97b7c965b8294c7506df62a1b9b03c72be" translate="yes" xml:space="preserve">
          <source>Uninhabited</source>
          <target state="translated">Uninhabited</target>
        </trans-unit>
        <trans-unit id="72d1bc1786787b9f5cf6f8701a1fb442f4f59285" translate="yes" xml:space="preserve">
          <source>Union</source>
          <target state="translated">Union</target>
        </trans-unit>
        <trans-unit id="431e2898d7b9070b1bc9e3d0e0fac72fa778d000" translate="yes" xml:space="preserve">
          <source>Union std::mem::MaybeUninit</source>
          <target state="translated">유니온 std :: mem :: MaybeUninit</target>
        </trans-unit>
        <trans-unit id="2697f04d1c34bc0fd003a5d4f2f248be3c9842cb" translate="yes" xml:space="preserve">
          <source>Union types</source>
          <target state="translated">연합 유형</target>
        </trans-unit>
        <trans-unit id="00002b164c08859d5a15579e55c8f17ce6478546" translate="yes" xml:space="preserve">
          <source>Unions</source>
          <target state="translated">Unions</target>
        </trans-unit>
        <trans-unit id="0b4b57a2ff8ee5597f14593b11685d486d14ac1f" translate="yes" xml:space="preserve">
          <source>Unions and &lt;code id=&quot;unions-and-drop&quot;&gt;Drop&lt;/code&gt;</source>
          <target state="translated">유니온과 &lt;code id=&quot;unions-and-drop&quot;&gt;Drop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70ff5b52f206cf593da36650b6dcc3e0e0087048" translate="yes" xml:space="preserve">
          <source>Unions have no notion of an &quot;active field&quot;. Instead, every union access just interprets the storage at the type of the field used for the access. Reading a union field reads the bits of the union at the field's type. Fields might have a non-zero offset (except when &lt;code&gt;#[repr(C)]&lt;/code&gt; is used); in that case the bits starting at the offset of the fields are read. It is the programmer's responsibility to make sure that the data is valid at the field's type. Failing to do so results in undefined behavior. For example, reading the value &lt;code&gt;3&lt;/code&gt; at type &lt;code&gt;bool&lt;/code&gt; is undefined behavior. Effectively, writing to and then reading from a &lt;code&gt;#[repr(C)]&lt;/code&gt; union is analogous to a &lt;a href=&quot;../../std/mem/fn.transmute&quot;&gt;&lt;code&gt;transmute&lt;/code&gt;&lt;/a&gt; from the type used for writing to the type used for reading.</source>
          <target state="translated">공용체에는 &quot;활성 필드&quot;라는 개념이 없습니다. 대신 모든 공용체 액세스는 액세스에 사용되는 필드의 유형에서 스토리지를 해석합니다. 공용체 필드를 읽으면 필드 유형에서 공용체의 비트를 읽습니다. 필드는 0이 아닌 오프셋을 가질 수 있습니다 ( &lt;code&gt;#[repr(C)]&lt;/code&gt; 가 사용되는 경우 제외 ). 이 경우 필드의 오프셋에서 시작하는 비트를 읽습니다. 데이터가 필드의 유형에서 유효한지 확인하는 것은 프로그래머의 책임입니다. 그렇게하지 않으면 정의되지 않은 동작이 발생합니다. 예를 들어 &lt;code&gt;bool&lt;/code&gt; 유형에서 값 &lt;code&gt;3&lt;/code&gt; 을 읽는 것은 정의되지 않은 동작입니다. 효과적으로 &lt;code&gt;#[repr(C)]&lt;/code&gt; 공용체에 쓰고 읽는 것은 &lt;a href=&quot;../../std/mem/fn.transmute&quot;&gt; &lt;code&gt;transmute&lt;/code&gt; &lt;/a&gt; 과 유사합니다. 쓰기에 사용되는 유형에서 읽기에 사용되는 유형으로.</target>
        </trans-unit>
        <trans-unit id="9ee9dda7ec1e961b1ea8bab0ad66f79036feccce" translate="yes" xml:space="preserve">
          <source>Unions have no notion of an &quot;active field&quot;. Instead, every union access just interprets the storage at the type of the field used for the access. Reading a union field reads the bits of the union at the field's type. It is the programmer's responsibility to make sure that the data is valid at that type. Failing to do so results in undefined behavior. For example, reading the value &lt;code&gt;3&lt;/code&gt; at type &lt;code&gt;bool&lt;/code&gt; is undefined behavior. Effectively, writing to and then reading from a union is analogous to a &lt;a href=&quot;../../std/mem/fn.transmute&quot;&gt;&lt;code&gt;transmute&lt;/code&gt;&lt;/a&gt; from the type used for writing to the type used for reading.</source>
          <target state="translated">노동 조합은 &quot;활동 분야&quot;에 대한 개념이 없습니다. 대신, 모든 유니언 액세스는 액세스에 사용되는 필드 유형에서 스토리지를 해석합니다. 유니온 필드를 읽으면 필드 유형에서 유니온 비트를 읽습니다. 데이터가 해당 유형에 유효한지 확인하는 것은 프로그래머의 책임입니다. 그렇지 않으면 정의되지 않은 동작이 발생합니다. 예를 들어, &lt;code&gt;bool&lt;/code&gt; 유형에서 값 &lt;code&gt;3&lt;/code&gt; 을 읽는 것은 정의되지 않은 동작입니다. 실제로, 공용체 에 쓰고 읽은 것은 읽는 데 사용되는 형식에서 쓰는 형식 의 &lt;a href=&quot;../../std/mem/fn.transmute&quot;&gt; &lt;code&gt;transmute&lt;/code&gt; &lt;/a&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="5078dc66c307401e9db5997fdb77c1b9baee7912" translate="yes" xml:space="preserve">
          <source>Unions have no notion of an &quot;active field&quot;. Instead, every union access transmutes parts of the content of the union to the type of the accessed field. Since transmutes can cause unexpected or undefined behaviour, &lt;code&gt;unsafe&lt;/code&gt; is required to read from a union field or to write to a field that doesn't implement &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;../items/unions&quot;&gt;item&lt;/a&gt; documentation for further details.</source>
          <target state="translated">공용체에는 &quot;활성 필드&quot;라는 개념이 없습니다. 대신 모든 공용체 액세스는 공용체 콘텐츠의 일부를 액세스 된 필드의 유형으로 변환합니다. 변환은 예기치 않거나 정의되지 않은 동작을 유발할 수 있으므로 통합 필드에서 읽거나 &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; 를&lt;/a&gt; 구현하지 않는 필드에 쓰려면 &lt;code&gt;unsafe&lt;/code&gt; 하지 않아야합니다 . 자세한 내용은 &lt;a href=&quot;../items/unions&quot;&gt;항목&lt;/a&gt; 문서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="1f74eae91f9cc29430ec662dac7122d37bb39e1b" translate="yes" xml:space="preserve">
          <source>Unions have no notion of an &quot;active field&quot;. Instead, every union access transmutes parts of the content of the union to the type of the accessed field. Since transmutes can cause unexpected or undefined behaviour, &lt;code&gt;unsafe&lt;/code&gt; is required to read from a union field, or to write to a field that doesn't implement &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; or has a &lt;a href=&quot;../../std/mem/struct.manuallydrop&quot;&gt;&lt;code&gt;ManuallyDrop&lt;/code&gt;&lt;/a&gt; type. See the &lt;a href=&quot;../items/unions&quot;&gt;item&lt;/a&gt; documentation for further details.</source>
          <target state="translated">공용체에는 &quot;활성 필드&quot;라는 개념이 없습니다. 대신 모든 공용체 액세스는 공용체 콘텐츠의 일부를 액세스 된 필드의 유형으로 변환합니다. transmutes 예기치 않은 또는 정의되지 않은 동작이 발생할 수 있기 때문에, &lt;code&gt;unsafe&lt;/code&gt; 구현하지 않는 필드에 노동 조합 필드에서, 또는 쓰기를 읽을 필요 &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 하거나이 &lt;a href=&quot;../../std/mem/struct.manuallydrop&quot;&gt; &lt;code&gt;ManuallyDrop&lt;/code&gt; 의&lt;/a&gt; 유형입니다. 자세한 내용은 &lt;a href=&quot;../items/unions&quot;&gt;항목&lt;/a&gt; 문서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="fa92690b772357d1ef06b6b63773a7916e701512" translate="yes" xml:space="preserve">
          <source>Unions have no notion of an &quot;active field&quot;. Instead, every union access transmutes parts of the content of the union to the type of the accessed field. Since transmutes can cause unexpected or undefined behaviour, &lt;code&gt;unsafe&lt;/code&gt; is required to read from a union field, or to write to a field that doesn't implement &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;../items/unions&quot;&gt;item&lt;/a&gt; documentation for further details.</source>
          <target state="translated">공용체에는 &quot;활성 필드&quot;라는 개념이 없습니다. 대신 모든 공용체 액세스는 공용체 콘텐츠의 일부를 액세스 된 필드의 유형으로 변환합니다. transmutes 예기치 않은 또는 정의되지 않은 동작이 발생할 수 있기 때문에, &lt;code&gt;unsafe&lt;/code&gt; 구현하지 않는 필드에 노동 조합 필드에서, 또는 쓰기를 읽을 필요 &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; . 자세한 내용은 &lt;a href=&quot;../items/unions&quot;&gt;항목&lt;/a&gt; 문서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="cb2b3efb0aed2e9062949d0d6efb28c840e4bdd0" translate="yes" xml:space="preserve">
          <source>Unique immutable borrows in captures</source>
          <target state="translated">캡처에서 고유 한 불변의 차용</target>
        </trans-unit>
        <trans-unit id="55319d93decd49524c6577ad2944aab8499b8def" translate="yes" xml:space="preserve">
          <source>Unit Tests</source>
          <target state="translated">단위 테스트</target>
        </trans-unit>
        <trans-unit id="fc4dd0d2f506c2585198c093fe3355566c69c50a" translate="yes" xml:space="preserve">
          <source>Unit struct expression</source>
          <target state="translated">유닛 구조체 표현</target>
        </trans-unit>
        <trans-unit id="43b9bb5cd29f3ad5aabe2057140ec12468595ac3" translate="yes" xml:space="preserve">
          <source>Unit structs are most commonly used as marker. They have a size of zero bytes, but unlike empty enums they can be instantiated, making them isomorphic to the unit type &lt;code&gt;()&lt;/code&gt;. Unit structs are useful when you need to implement a trait on something, but don't need to store any data inside it.</source>
          <target state="translated">단위 구조체는 가장 일반적으로 마커로 사용됩니다. 크기는 0 바이트이지만 빈 열거 형과 달리 인스턴스화 할 수 있으므로 단위 유형 &lt;code&gt;()&lt;/code&gt; 과 동형이됩니다 . 유닛 구조체는 무언가에 특성을 구현해야하지만 그 안에 데이터를 저장할 필요는 없을 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="29ad46d73653a34f4423b5d45017917794627b45" translate="yes" xml:space="preserve">
          <source>Unit-Like Structs Without Any Fields</source>
          <target state="translated">필드가없는 단위와 같은 구조</target>
        </trans-unit>
        <trans-unit id="cecc0d8500754b34f5bd7f11dfabb25c3a770aaf" translate="yes" xml:space="preserve">
          <source>Unix</source>
          <target state="translated">Unix</target>
        </trans-unit>
        <trans-unit id="5ebca32071333343f0c708c52c532da98a8cd4f1" translate="yes" xml:space="preserve">
          <source>Unix credential.</source>
          <target state="translated">Unix 자격 증명.</target>
        </trans-unit>
        <trans-unit id="b00eb2991ece231ee34e1193574afcc6b4379e47" translate="yes" xml:space="preserve">
          <source>Unix peer credentials.</source>
          <target state="translated">Unix 피어 자격 증명.</target>
        </trans-unit>
        <trans-unit id="122365e7dc1f75db94d30ca063c2e50b567c06af" translate="yes" xml:space="preserve">
          <source>Unix-specific extension methods for &lt;a href=&quot;../../../fs/struct.direntry&quot;&gt;&lt;code&gt;fs::DirEntry&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.direntry&quot;&gt; &lt;code&gt;fs::DirEntry&lt;/code&gt; &lt;/a&gt; 유닉스 별 확장 메소드 .</target>
        </trans-unit>
        <trans-unit id="40290eba8741a7fb561802cc4fd7a5f03fc12be7" translate="yes" xml:space="preserve">
          <source>Unix-specific extension to the primitives in the &lt;code&gt;std::ffi&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;std::ffi&lt;/code&gt; 모듈 의 프리미티브에 대한 유닉스 별 확장</target>
        </trans-unit>
        <trans-unit id="abb9e72437d43bc0a2c9b376ba3ef37ee9f0016a" translate="yes" xml:space="preserve">
          <source>Unix-specific extension to the primitives in the &lt;code&gt;std::ffi&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;std::ffi&lt;/code&gt; 모듈 의 기본 요소에 대한 유닉스 특정 확장 .</target>
        </trans-unit>
        <trans-unit id="7d8456cebfaf04274630f018fe98c85f0928fd59" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions for &lt;a href=&quot;../../../fs/struct.filetype&quot;&gt;&lt;code&gt;FileType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.filetype&quot;&gt; &lt;code&gt;FileType&lt;/code&gt; 의&lt;/a&gt; 유닉스 별 확장자 .</target>
        </trans-unit>
        <trans-unit id="1f656dcd59d506e815045da5be6675c4c9594d4c" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions for &lt;a href=&quot;../../../fs/struct.filetype&quot;&gt;&lt;code&gt;fs::FileType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.filetype&quot;&gt; &lt;code&gt;fs::FileType&lt;/code&gt; &lt;/a&gt; 대한 Unix 특정 확장 .</target>
        </trans-unit>
        <trans-unit id="44ae3204adf61398987a8d1c1ea0cc0ee7054526" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../fs/struct.dirbuilder&quot;&gt;&lt;code&gt;fs::DirBuilder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.dirbuilder&quot;&gt; &lt;code&gt;fs::DirBuilder&lt;/code&gt; &lt;/a&gt; 대한 유닉스 별 확장 .</target>
        </trans-unit>
        <trans-unit id="5c055cc3e8d38d074a1699c2467aa73f8a67ec8b" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; 에&lt;/a&gt; 대한 유닉스 별 확장 .</target>
        </trans-unit>
        <trans-unit id="edc026b1b59822f06029958a23a0df330b02c688" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../fs/struct.file&quot;&gt;&lt;code&gt;fs::File&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.file&quot;&gt; &lt;code&gt;fs::File&lt;/code&gt; &lt;/a&gt; 대한 Unix 특정 확장 .</target>
        </trans-unit>
        <trans-unit id="f808e6d0f3cef15729ba995896155633f9c4e702" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt;&lt;code&gt;fs::Metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.metadata&quot;&gt; &lt;code&gt;fs::Metadata&lt;/code&gt; &lt;/a&gt; 유닉스 별 확장 .</target>
        </trans-unit>
        <trans-unit id="a398ee8c4edc244dd48383efb674694800d11b42" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../fs/struct.openoptions&quot;&gt;&lt;code&gt;fs::OpenOptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.openoptions&quot;&gt; &lt;code&gt;fs::OpenOptions&lt;/code&gt; &lt;/a&gt; 유닉스 별 확장 .</target>
        </trans-unit>
        <trans-unit id="5c3e2254255ed122649ef706ca6351a05878a982" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../fs/struct.permissions&quot;&gt;&lt;code&gt;fs::Permissions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.permissions&quot;&gt; &lt;code&gt;fs::Permissions&lt;/code&gt; &lt;/a&gt; 유닉스 별 확장 .</target>
        </trans-unit>
        <trans-unit id="debd12446f93bf566a622bdf802607a7783bf6af" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../process/struct.exitstatus&quot;&gt;&lt;code&gt;process::ExitStatus&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유닉스 특정 확장하는 &lt;a href=&quot;../../../process/struct.exitstatus&quot;&gt; &lt;code&gt;process::ExitStatus&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04090d3e2df7580a6d7cec986c08600c0473b452" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../thread/struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../thread/struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; 에&lt;/a&gt; 대한 Unix 특정 확장 .</target>
        </trans-unit>
        <trans-unit id="a44e2e0da5854a8ebdf4095318d97783ef5ced71" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to &lt;a href=&quot;../../../thread/struct.joinhandle&quot;&gt;&lt;code&gt;thread::JoinHandle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../thread/struct.joinhandle&quot;&gt; &lt;code&gt;thread::JoinHandle&lt;/code&gt; &lt;/a&gt; 대한 유닉스 고유의 확장 .</target>
        </trans-unit>
        <trans-unit id="d0f569dc194098f87c8bc0882017a7d0c963c955" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to general I/O primitives</source>
          <target state="translated">일반 I / O 프리미티브에 대한 유닉스 별 확장</target>
        </trans-unit>
        <trans-unit id="8e6df3ed34620f11bd872bbbdadc0905f4158426" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to general I/O primitives.</source>
          <target state="translated">일반 I / O 프리미티브에 대한 Unix 특정 확장.</target>
        </trans-unit>
        <trans-unit id="3789837939ff4014248adcb7118252ef4bacad14" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to primitives in the &lt;code&gt;std::fs&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;std::fs&lt;/code&gt; 모듈의 프리미티브에 대한 유닉스 별 확장 .</target>
        </trans-unit>
        <trans-unit id="b4f34673a7f1203fc92e8429aa07449552c09698" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to primitives in the &lt;code&gt;std::process&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;std::process&lt;/code&gt; 모듈의 프리미티브에 대한 유닉스 별 확장 .</target>
        </trans-unit>
        <trans-unit id="60cfd734bf76c756b8e059f4a9d1700ff9a4713c" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to primitives in the &lt;code&gt;std::thread&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;std::thread&lt;/code&gt; 모듈의 프리미티브에 대한 유닉스 별 확장 .</target>
        </trans-unit>
        <trans-unit id="2ffca9f4f9cc7c8dd85f78563efe7167f6d2b47d" translate="yes" xml:space="preserve">
          <source>Unix-specific extensions to the &lt;a href=&quot;../../../process/struct.command&quot;&gt;&lt;code&gt;process::Command&lt;/code&gt;&lt;/a&gt; builder.</source>
          <target state="translated">&lt;a href=&quot;../../../process/struct.command&quot;&gt; &lt;code&gt;process::Command&lt;/code&gt; &lt;/a&gt; 빌더 에 대한 유닉스 별 확장 .</target>
        </trans-unit>
        <trans-unit id="e0d68049fb554c75225dfe9c03296f580e460278" translate="yes" xml:space="preserve">
          <source>Unix-specific networking functionality</source>
          <target state="translated">유닉스 전용 네트워킹 기능</target>
        </trans-unit>
        <trans-unit id="547d566a755a9f281512ec4438e2afbe2e8555f4" translate="yes" xml:space="preserve">
          <source>Unix-specific networking functionality.</source>
          <target state="translated">Unix 관련 네트워킹 기능.</target>
        </trans-unit>
        <trans-unit id="6dc7e1fbf723c58f49b9c7b7c9486e8910ff303f" translate="yes" xml:space="preserve">
          <source>Unix-specific primitives available on all unix platforms</source>
          <target state="translated">모든 유닉스 플랫폼에서 사용 가능한 유닉스 관련 프리미티브</target>
        </trans-unit>
        <trans-unit id="5d6c2bdf64d7b2867f336fc3ecf7da3868d50a13" translate="yes" xml:space="preserve">
          <source>Unix-specific primitives available on all unix platforms.</source>
          <target state="translated">모든 유닉스 플랫폼에서 사용할 수있는 유닉스 특정 프리미티브.</target>
        </trans-unit>
        <trans-unit id="559d58e1a8d746d91fa3600f29dbbb56c9ca25cd" translate="yes" xml:space="preserve">
          <source>UnixDatagram</source>
          <target state="translated">UnixDatagram</target>
        </trans-unit>
        <trans-unit id="67d62a4911bb1e0d83beb3b448aab6df455a9a7a" translate="yes" xml:space="preserve">
          <source>UnixListener</source>
          <target state="translated">UnixListener</target>
        </trans-unit>
        <trans-unit id="941c06c80eb53ce02937637ee16d42217c4f223a" translate="yes" xml:space="preserve">
          <source>UnixStream</source>
          <target state="translated">UnixStream</target>
        </trans-unit>
        <trans-unit id="55add9bdacff5201b17fde89c00c759c2cb86e1e" translate="yes" xml:space="preserve">
          <source>Unless you are in such a situation, higher-level and more foolproof APIs like &lt;code&gt;get&lt;/code&gt; should be preferred.</source>
          <target state="translated">이러한 상황에 있지 않으면 &lt;code&gt;get&lt;/code&gt; 과 같은 고급 및 더 안전한 API 가 선호되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a444b89922afd7135047b0a62b434579bde022e6" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#method.compare_exchange&quot;&gt;&lt;code&gt;compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;#method.compare_exchange&quot;&gt; &lt;code&gt;compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리 ,이 함수는 비교가 성공하더라도 허위로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드가 생성 될 수 있습니다. 리턴 값은 새 값이 작성되었으며 이전 값을 포함하는지 여부를 나타내는 결과입니다.</target>
        </trans-unit>
        <trans-unit id="6e589b43f3082da98ca0e4f046ea8ace2906bf51" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#method.from_utf8_lossy&quot;&gt;&lt;code&gt;from_utf8_lossy&lt;/code&gt;&lt;/a&gt; which returns a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;from_utf16_lossy&lt;/code&gt; returns a &lt;code&gt;String&lt;/code&gt; since the UTF-16 to UTF-8 conversion requires a memory allocation.</source>
          <target state="translated">달리 &lt;a href=&quot;#method.from_utf8_lossy&quot;&gt; &lt;code&gt;from_utf8_lossy&lt;/code&gt; &lt;/a&gt; 반환 &lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;from_utf16_lossy&lt;/code&gt; 리턴 &lt;code&gt;String&lt;/code&gt; 가 UTF-16, UTF-8 변환 이후에 메모리 할당을 필요로한다.</target>
        </trans-unit>
        <trans-unit id="1e5e6606c716b7d8ea23880ff26dd47bb4cb772b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#variant.InvalidInput&quot;&gt;&lt;code&gt;InvalidInput&lt;/code&gt;&lt;/a&gt;, this typically means that the operation parameters were valid, however the error was caused by malformed input data.</source>
          <target state="translated">&lt;a href=&quot;#variant.InvalidInput&quot;&gt; &lt;code&gt;InvalidInput&lt;/code&gt; &lt;/a&gt; 과 달리 이것은 일반적으로 작업 매개 변수가 유효하지만 오류는 잘못된 입력 데이터로 인해 발생했음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="42150160f2ba583b7d6c6990db7fe7b9390515b8" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../convert/fn.identity&quot;&gt;&lt;code&gt;std::convert::identity&lt;/code&gt;&lt;/a&gt;, a Rust compiler is encouraged to assume that &lt;code&gt;black_box&lt;/code&gt; can use &lt;code&gt;dummy&lt;/code&gt; in any possible valid way that Rust code is allowed to without introducing undefined behavior in the calling code. This property makes &lt;code&gt;black_box&lt;/code&gt; useful for writing code in which certain optimizations are not desired, such as benchmarks.</source>
          <target state="translated">달리 &lt;a href=&quot;../convert/fn.identity&quot;&gt; &lt;code&gt;std::convert::identity&lt;/code&gt; &lt;/a&gt; , 녹 컴파일러는 그 가정 권장 &lt;code&gt;black_box&lt;/code&gt; 을 사용할 수 있습니다 &lt;code&gt;dummy&lt;/code&gt; 호출 코드에서 정의되지 않은 동작을 도입하지 않고 녹 코드가 허용되는 가능한 모든 유효한 방법. 이 속성은 &lt;code&gt;black_box&lt;/code&gt; 를 벤치 마크와 같이 특정 최적화가 바람직하지 않은 코드를 작성하는 데 유용 하게 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e8fe9eebd36a2bd7140bc3ec3fdc0c32e569dabf" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; uses atomic operations for its reference counting. This means that it is thread-safe. The disadvantage is that atomic operations are more expensive than ordinary memory accesses. If you are not sharing reference-counted allocations between threads, consider using &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for lower overhead. &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is a safe default, because the compiler will catch any attempt to send an &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; between threads. However, a library might choose &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; in order to give library consumers more flexibility.</source>
          <target state="translated">달리 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 는 참조 카운팅 원자 연산을 사용한다. 이것은 스레드로부터 안전하다는 것을 의미합니다. 단점은 원자 적 연산이 일반 메모리 액세스보다 더 비싸다는 것입니다. 스레드간에 참조 횟수 할당을 공유하지 않는 경우 낮은 오버 헤드를 위해 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다. &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 컴파일러가 스레드간에 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 보내려는 시도를 포착하므로 안전한 기본값 입니다. 그러나 라이브러리 소비자에게 더 많은 유연성을 제공하기 위해 라이브러리는 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 를 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="398c5c34b191e4676dc6961558a4a76db9314267" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; uses atomic operations for its reference counting. This means that it is thread-safe. The disadvantage is that atomic operations are more expensive than ordinary memory accesses. If you are not sharing reference-counted values between threads, consider using &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for lower overhead. &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is a safe default, because the compiler will catch any attempt to send an &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; between threads. However, a library might choose &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; in order to give library consumers more flexibility.</source>
          <target state="translated">달리 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 는 참조 카운팅 원자 연산을 사용한다. 이것은 스레드 안전하다는 것을 의미합니다. 단점은 원 자성 연산이 일반 메모리 액세스보다 비싸다는 것입니다. 스레드간에 참조 횟수 값을 공유하지 않는 경우 오버 헤드를 낮추기 위해 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 . 컴파일러는 스레드간에 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 보내려고 시도하기 때문에 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 가 안전한 기본값 입니다. 그러나 라이브러리는 라이브러리 소비자에게 더 많은 유연성을 제공하기 위해 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 를 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e29ce9f9179b04ed1ae04e60eaff67bddb9bd1a4" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;enum.errorkind#variant.InvalidInput&quot;&gt;&lt;code&gt;InvalidInput&lt;/code&gt;&lt;/a&gt;, this typically means that the operation parameters were valid, however the error was caused by malformed input data.</source>
          <target state="translated">&lt;a href=&quot;enum.errorkind#variant.InvalidInput&quot;&gt; &lt;code&gt;InvalidInput&lt;/code&gt; &lt;/a&gt; 과 달리 이는 일반적으로 작업 매개 변수가 유효했지만 잘못된 입력 데이터로 인해 오류가 발생했음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="977087ec8c6cc227ec1b23f036b52a53ba5572b7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;enum.result#method.unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt;, this method is known to never panic on the result types it is implemented for. Therefore, it can be used instead of &lt;code&gt;unwrap&lt;/code&gt; as a maintainability safeguard that will fail to compile if the error type of the &lt;code&gt;Result&lt;/code&gt; is later changed to an error that can actually occur.</source>
          <target state="translated">&lt;a href=&quot;enum.result#method.unwrap&quot;&gt; &lt;code&gt;unwrap&lt;/code&gt; &lt;/a&gt; 과 달리이 메서드는 구현 된 결과 유형에 대해 절대 당황하지 않는 것으로 알려져 있습니다. 따라서 &lt;code&gt;Result&lt;/code&gt; 의 오류 유형 이 나중에 실제로 발생할 수있는 오류로 변경 되면 컴파일에 실패하는 유지 보수성 보호 수단 으로 &lt;code&gt;unwrap&lt;/code&gt; 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f0ba302caf06a67df91ba9d9ffb499576009fcd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.once&quot;&gt;&lt;code&gt;once()&lt;/code&gt;&lt;/a&gt;, this function will lazily generate the value on request.</source>
          <target state="translated">&lt;a href=&quot;fn.once&quot;&gt; &lt;code&gt;once()&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 요청시 값을 느리게 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d18aaa1337521f474ebf73b2e843073b1e6c1a48" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.once&quot;&gt;&lt;code&gt;once&lt;/code&gt;&lt;/a&gt;, this function will lazily generate the value on request.</source>
          <target state="translated">&lt;a href=&quot;fn.once&quot;&gt; &lt;code&gt;once&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 요청시 값을 게으르게 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f9a90d0a5de7f0a5dcb5f54e9d3e2cfa25b0db2a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;read_unaligned&lt;/code&gt; works with unaligned pointers.</source>
          <target state="translated">달리 &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;read_unaligned&lt;/code&gt; 정렬되지 않은 포인터 작품.</target>
        </trans-unit>
        <trans-unit id="45376ed6cd7ba7a1378a0b53a56bfa0037e236a4" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;, the pointer may be unaligned.</source>
          <target state="translated">&lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; 와 달리 포인터가 정렬되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f193c98cf25a325eda25618a82a356c0b0cf6349" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, the pointer may be unaligned.</source>
          <target state="translated">&lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 와 달리 포인터가 정렬되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eb0fda1ae28c8f30f8d9d31bf06172d448763b9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://doc.rust-lang.org/core/convert/fn.identity.html&quot;&gt;&lt;code&gt;std::convert::identity&lt;/code&gt;&lt;/a&gt;, a Rust compiler is encouraged to assume that &lt;code&gt;black_box&lt;/code&gt; can use &lt;code&gt;dummy&lt;/code&gt; in any possible valid way that Rust code is allowed to without introducing undefined behavior in the calling code. This property makes &lt;code&gt;black_box&lt;/code&gt; useful for writing code in which certain optimizations are not desired, such as benchmarks.</source>
          <target state="translated">달리 &lt;a href=&quot;https://doc.rust-lang.org/core/convert/fn.identity.html&quot;&gt; &lt;code&gt;std::convert::identity&lt;/code&gt; &lt;/a&gt; , 녹 컴파일러는 그 가정 권장 &lt;code&gt;black_box&lt;/code&gt; 을 사용할 수 있습니다 &lt;code&gt;dummy&lt;/code&gt; 호출 코드에서 정의되지 않은 동작을 도입하지 않고 녹 코드가 허용되는 가능한 모든 유효한 방법. 이 속성은 &lt;code&gt;black_box&lt;/code&gt; 를 벤치 마크와 같이 특정 최적화가 바람직하지 않은 코드를 작성하는 데 유용 하게 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="91d4ccc7c19b4e12670ef1bb1f42a0a03d42f849" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will not execute &lt;code&gt;debug_assert!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development. The result of expanding &lt;code&gt;debug_assert!&lt;/code&gt; is always type checked.</source>
          <target state="translated">&lt;a href=&quot;macro.assert&quot;&gt; &lt;code&gt;assert!&lt;/code&gt; &lt;/a&gt; 과 달리 ! , &lt;code&gt;debug_assert!&lt;/code&gt; 문은 기본적으로 최적화되지 않은 빌드에서만 활성화됩니다. 최적화 된 빌드는 &lt;code&gt;debug_assert!&lt;/code&gt; 실행하지 않습니다 ! &lt;code&gt;-C debug-assertions&lt;/code&gt; 이 컴파일러에 전달 되지 않는 한 명령문 . 이것은 &lt;code&gt;debug_assert!&lt;/code&gt; 릴리스 빌드에 존재하기에는 너무 비싸지 만 개발 중에 도움이 될 수있는 검사에 유용합니다. &lt;code&gt;debug_assert!&lt;/code&gt; 를 확장 한 결과 ! 항상 유형 검사입니다.</target>
        </trans-unit>
        <trans-unit id="c003bf6ddb754586528cac314e476dba52106915" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will omit all &lt;code&gt;debug_assert!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development.</source>
          <target state="translated">&lt;a href=&quot;macro.assert&quot;&gt; &lt;code&gt;assert!&lt;/code&gt; &lt;/a&gt; 과 달리 ! , &lt;code&gt;debug_assert!&lt;/code&gt; 명령문은 기본적으로 최적화되지 않은 빌드에서만 사용 가능합니다. 최적화 된 빌드는 모든 &lt;code&gt;debug_assert!&lt;/code&gt; 를 생략합니다 ! &lt;code&gt;-C debug-assertions&lt;/code&gt; 가 컴파일러에 전달 되지 않는 한 명령문 . 이것은 &lt;code&gt;debug_assert!&lt;/code&gt; 릴리스 빌드에 포함하기에는 너무 비싸지 만 개발 중에 도움이 될 수있는 검사에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c7b2f5bacfdb6fe8fd35fce9254ebaf2411b3683" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_eq&quot;&gt;&lt;code&gt;assert_eq!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will not execute &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_eq!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development. The result of expanding &lt;code&gt;debug_assert_eq!&lt;/code&gt; is always type checked.</source>
          <target state="translated">&lt;a href=&quot;macro.assert_eq&quot;&gt; &lt;code&gt;assert_eq!&lt;/code&gt; &lt;/a&gt; 와 달리 ! , &lt;code&gt;debug_assert_eq!&lt;/code&gt; 문은 기본적으로 최적화되지 않은 빌드에서만 활성화됩니다. 최적화 된 빌드는 &lt;code&gt;debug_assert_eq!&lt;/code&gt; 실행하지 않습니다 ! &lt;code&gt;-C debug-assertions&lt;/code&gt; 이 컴파일러에 전달 되지 않는 한 명령문 . 이것은 &lt;code&gt;debug_assert_eq!&lt;/code&gt; 릴리스 빌드에 존재하기에는 너무 비싸지 만 개발 중에 도움이 될 수있는 검사에 유용합니다. &lt;code&gt;debug_assert_eq!&lt;/code&gt; 를 확장 한 결과 ! 항상 유형 검사입니다.</target>
        </trans-unit>
        <trans-unit id="3263afd688aea4401eb3df7127fbabe1b1fe028e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_eq&quot;&gt;&lt;code&gt;assert_eq!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will omit all &lt;code&gt;debug_assert_eq!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_eq!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development.</source>
          <target state="translated">&lt;a href=&quot;macro.assert_eq&quot;&gt; &lt;code&gt;assert_eq!&lt;/code&gt; &lt;/a&gt; 와 달리 ! , &lt;code&gt;debug_assert_eq!&lt;/code&gt; 명령문은 기본적으로 최적화되지 않은 빌드에서만 사용 가능합니다. 최적화 된 빌드는 모든 &lt;code&gt;debug_assert_eq!&lt;/code&gt; 를 생략합니다 ! &lt;code&gt;-C debug-assertions&lt;/code&gt; 가 컴파일러에 전달 되지 않는 한 명령문 . 이것은 &lt;code&gt;debug_assert_eq!&lt;/code&gt; 릴리스 빌드에 포함하기에는 너무 비싸지 만 개발 중에 도움이 될 수있는 검사에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="dacd029d3cc2c2a10a75c84ef45c21166b5ba90a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_ne&quot;&gt;&lt;code&gt;assert_ne!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will not execute &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_ne!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development. The result of expanding &lt;code&gt;debug_assert_ne!&lt;/code&gt; is always type checked.</source>
          <target state="translated">&lt;a href=&quot;macro.assert_ne&quot;&gt; &lt;code&gt;assert_ne!&lt;/code&gt; &lt;/a&gt; 과 달리 ! , &lt;code&gt;debug_assert_ne!&lt;/code&gt; 문은 기본적으로 최적화되지 않은 빌드에서만 활성화됩니다. 최적화 된 빌드는 &lt;code&gt;debug_assert_ne!&lt;/code&gt; 실행하지 않습니다 ! &lt;code&gt;-C debug-assertions&lt;/code&gt; 이 컴파일러에 전달 되지 않는 한 명령문 . 이것은 &lt;code&gt;debug_assert_ne!&lt;/code&gt; 릴리스 빌드에 존재하기에는 너무 비싸지 만 개발 중에 도움이 될 수있는 검사에 유용합니다. &lt;code&gt;debug_assert_ne!&lt;/code&gt; 을 확장 한 결과 ! 항상 유형 검사입니다.</target>
        </trans-unit>
        <trans-unit id="04d1e96304d1bbf7140b253d02ca2ad39e16daa5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;macro.assert_ne&quot;&gt;&lt;code&gt;assert_ne!&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements are only enabled in non optimized builds by default. An optimized build will omit all &lt;code&gt;debug_assert_ne!&lt;/code&gt; statements unless &lt;code&gt;-C debug-assertions&lt;/code&gt; is passed to the compiler. This makes &lt;code&gt;debug_assert_ne!&lt;/code&gt; useful for checks that are too expensive to be present in a release build but may be helpful during development.</source>
          <target state="translated">&lt;a href=&quot;macro.assert_ne&quot;&gt; &lt;code&gt;assert_ne!&lt;/code&gt; &lt;/a&gt; 과 달리 ! , &lt;code&gt;debug_assert_ne!&lt;/code&gt; 명령문은 기본적으로 최적화되지 않은 빌드에서만 사용 가능합니다. 최적화 된 빌드는 모든 &lt;code&gt;debug_assert_ne!&lt;/code&gt; 을 생략합니다 ! &lt;code&gt;-C debug-assertions&lt;/code&gt; 가 컴파일러에 전달 되지 않는 한 명령문 . 이것은 &lt;code&gt;debug_assert_ne!&lt;/code&gt; 릴리스 빌드에 포함하기에는 너무 비싸지 만 개발 중에 도움이 될 수있는 검사에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6cce36d9c22bd93c2a41b7e0597974f3cee7e7ac" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 가짜로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드를 생성 할 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="5c9ddf39955f900e36cc1e90f2b549ad7472a5bd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomici16#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicI16::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomici16#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicI16::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 가짜로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드를 생성 할 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="d36949a10789f440243db02c27d7a2a4839d4968" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomici32#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicI32::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomici32#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicI32::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 가짜로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드가 생성 될 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="541167404f49247535e6737ca512feb21f2cf377" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomici64#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicI64::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomici64#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicI64::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 허위로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드를 생성 할 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="bac30468509752a4dadb45b544078909afc04dd2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomici8#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicI8::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomici8#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicI8::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 허위로 실패 할 수 있으므로 일부 플랫폼에서는 더 효율적인 코드가 생성 될 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="f1e77b06d8fc7bb242ede2586728e20cd5ec38f2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicisize#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicIsize::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomicisize#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicIsize::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 가짜로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드를 생성 할 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9c1cb338dee4d9a50fbbd7a4ca8f1d9671b92ea5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicptr#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicPtr::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomicptr#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicPtr::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 가짜로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드를 생성 할 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="fcca6a9c5592b18a67aa751975baab86b8d73470" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicu16#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicU16::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomicu16#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicU16::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 가짜로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드를 생성 할 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8564dc4303f86be3afe445dd42ac378dde93ba88" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicu32#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicU32::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomicu32#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicU32::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 가짜로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드를 생성 할 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="b2f28ad76976058589a61b38b753ee6ff0210850" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicu64#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicU64::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomicu64#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicU64::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 가짜로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드를 생성 할 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="76887ce7cd48ec3a42bf06e1a6d5d6113a38547a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicu8#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicU8::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomicu8#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicU8::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 허위로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드를 생성 할 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="beb26d7e8cfff635de8d1457d1dfb96fc541fdd8" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.atomicusize#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicUsize::compare_exchange&lt;/code&gt;&lt;/a&gt;, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</source>
          <target state="translated">&lt;a href=&quot;struct.atomicusize#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicUsize::compare_exchange&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 비교가 성공하더라도 가짜로 실패 할 수 있으므로 일부 플랫폼에서 더 효율적인 코드를 생성 할 수 있습니다. 반환 값은 새 값이 작성되었는지 여부를 나타내는 결과이며 이전 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8e0f6d29be16ce7f6bbb39d8f34d156c5bad7880" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once()&lt;/code&gt;&lt;/a&gt;, if this &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; has been poisoned (i.e., a previous call to &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt;&lt;code&gt;call_once_force()&lt;/code&gt;&lt;/a&gt; caused a panic), calling &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt;&lt;code&gt;call_once_force()&lt;/code&gt;&lt;/a&gt; will still invoke the closure &lt;code&gt;f&lt;/code&gt; and will &lt;em&gt;not&lt;/em&gt; result in an immediate panic. If &lt;code&gt;f&lt;/code&gt; panics, the &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; will remain in a poison state. If &lt;code&gt;f&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic, the &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; will no longer be in a poison state and all future calls to &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt;&lt;code&gt;call_once_force()&lt;/code&gt;&lt;/a&gt; will be no-ops.</source>
          <target state="translated">달리 &lt;a href=&quot;struct.once#method.call_once&quot;&gt; &lt;code&gt;call_once()&lt;/code&gt; &lt;/a&gt; ,이 경우 &lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt; 중독 된 (즉,에 대한 이전 호출 &lt;a href=&quot;struct.once#method.call_once&quot;&gt; &lt;code&gt;call_once()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt; &lt;code&gt;call_once_force()&lt;/code&gt; &lt;/a&gt; 호출, 패닉의 원인) &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt; &lt;code&gt;call_once_force()&lt;/code&gt; &lt;/a&gt; 폐쇄 된 invoke 여전히 것이다 &lt;code&gt;f&lt;/code&gt; 것 &lt;em&gt;하지&lt;/em&gt; 즉시 공황을 초래할. 경우 &lt;code&gt;f&lt;/code&gt; 패닉의는 &lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt; 포이즌 상태를 유지합니다. 경우 &lt;code&gt;f&lt;/code&gt; 는 않습니다 &lt;em&gt;하지&lt;/em&gt; 공포의이 &lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt; 더 이상 독 상태에있을 것이며, 모든 미래의 통화 &lt;a href=&quot;struct.once#method.call_once&quot;&gt; &lt;code&gt;call_once()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.once#method.call_once_force&quot;&gt; &lt;code&gt;call_once_force()&lt;/code&gt; &lt;/a&gt; 어떤 작전 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="97444204f29f9f8d725d9dd412f9b1cb5f20d4e2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.once#method.call_once&quot;&gt;&lt;code&gt;call_once&lt;/code&gt;&lt;/a&gt;, if this &lt;code&gt;Once&lt;/code&gt; has been poisoned (i.e., a previous call to &lt;code&gt;call_once&lt;/code&gt; or &lt;code&gt;call_once_force&lt;/code&gt; caused a panic), calling &lt;code&gt;call_once_force&lt;/code&gt; will still invoke the closure &lt;code&gt;f&lt;/code&gt; and will &lt;em&gt;not&lt;/em&gt; result in an immediate panic. If &lt;code&gt;f&lt;/code&gt; panics, the &lt;code&gt;Once&lt;/code&gt; will remain in a poison state. If &lt;code&gt;f&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic, the &lt;code&gt;Once&lt;/code&gt; will no longer be in a poison state and all future calls to &lt;code&gt;call_once&lt;/code&gt; or &lt;code&gt;call_one_force&lt;/code&gt; will be no-ops.</source>
          <target state="translated">달리 &lt;a href=&quot;struct.once#method.call_once&quot;&gt; &lt;code&gt;call_once&lt;/code&gt; &lt;/a&gt; 이 경우, &lt;code&gt;Once&lt;/code&gt; 중독 된 (즉,에 대한 이전 호출 &lt;code&gt;call_once&lt;/code&gt; 또는 &lt;code&gt;call_once_force&lt;/code&gt; 는 호출, 패닉의 원인) &lt;code&gt;call_once_force&lt;/code&gt; 를 여전히 폐쇄 호출합니다 &lt;code&gt;f&lt;/code&gt; 것 &lt;em&gt;하지&lt;/em&gt; 즉시 공황을 초래할. 경우 &lt;code&gt;f&lt;/code&gt; 패닉의는 &lt;code&gt;Once&lt;/code&gt; 포이즌 상태를 유지합니다. &lt;code&gt;f&lt;/code&gt; 가 패닉 상태 가 &lt;em&gt;아닌&lt;/em&gt; 경우 &lt;code&gt;Once&lt;/code&gt; 는 더 이상 독 상태가 &lt;code&gt;call_once&lt;/code&gt; 향후 call_once 또는 &lt;code&gt;call_one_force&lt;/code&gt; 에 대한 모든 호출 은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69bf1113333b0a6b470f760044140ccfaef050a0" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct.string#method.from_utf8_lossy&quot;&gt;&lt;code&gt;from_utf8_lossy&lt;/code&gt;&lt;/a&gt; which returns a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;from_utf16_lossy&lt;/code&gt; returns a &lt;code&gt;String&lt;/code&gt; since the UTF-16 to UTF-8 conversion requires a memory allocation.</source>
          <target state="translated">&lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt; &lt;/a&gt; 을 반환하는 &lt;a href=&quot;struct.string#method.from_utf8_lossy&quot;&gt; &lt;code&gt;from_utf8_lossy&lt;/code&gt; &lt;/a&gt; 와 달리 , &lt;code&gt;from_utf16_lossy&lt;/code&gt; 는 UTF-16에서 UTF-8 로의 변환에 메모리 할당이 필요하기 때문에 &lt;code&gt;String&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9701139045e2ad48d71d09c86c7eff61381e89c9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;, this will not attempt to fill the buffer if it is empty.</source>
          <target state="translated">&lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt; 와 달리 , 비어있는 경우 버퍼를 채우려 고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb694c3e76472c257054ea4932b6e425a8976f9f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.globalalloc&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt;, zero-sized allocations are allowed in &lt;code&gt;AllocRef&lt;/code&gt;. If an underlying allocator does not support this (like jemalloc) or return a null pointer (such as &lt;code&gt;libc::malloc&lt;/code&gt;), this must be caught by the implementation.</source>
          <target state="translated">&lt;a href=&quot;trait.globalalloc&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt; 과 달리 &lt;code&gt;AllocRef&lt;/code&gt; 에서는 크기가 0 인 할당이 허용됩니다 . 기본 할당자가이를 지원하지 않거나 (예 : jemalloc) null 포인터 (예 : &lt;code&gt;libc::malloc&lt;/code&gt; )를 반환하는 경우 구현에서이를 포착해야합니다.</target>
        </trans-unit>
        <trans-unit id="88f01dda433daf6efa3bd2602e5fc9ccc01477f8" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.globalalloc&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt;, zero-sized allocations are allowed in &lt;code&gt;Allocator&lt;/code&gt;. If an underlying allocator does not support this (like jemalloc) or return a null pointer (such as &lt;code&gt;libc::malloc&lt;/code&gt;), this must be caught by the implementation.</source>
          <target state="translated">&lt;a href=&quot;trait.globalalloc&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt; 과 달리 &lt;code&gt;Allocator&lt;/code&gt; 에서는 크기가 0 인 할당이 허용됩니다 . 기본 할당자가이를 지원하지 않거나 (예 : jemalloc) null 포인터 (예 : &lt;code&gt;libc::malloc&lt;/code&gt; )를 반환하는 경우 구현에서이를 포착해야합니다.</target>
        </trans-unit>
        <trans-unit id="e53e5897fa59de78d867c186db4554c739885b98" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt;, there is no guarantee that the returned ranges of this and &lt;a href=&quot;trait.searcher#method.next_match&quot;&gt;&lt;code&gt;next_match&lt;/code&gt;&lt;/a&gt; will overlap.</source>
          <target state="translated">&lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt; 와 달리 this 및 &lt;a href=&quot;trait.searcher#method.next_match&quot;&gt; &lt;code&gt;next_match&lt;/code&gt; &lt;/a&gt; 의 반환 된 범위 가 겹칠 것이라는 보장은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7d5b411ac352c96a1edc968b7e49d8e28ffb6bde" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt;, there is no guarantee that the returned ranges of this and &lt;a href=&quot;trait.searcher#method.next_reject&quot;&gt;&lt;code&gt;next_reject&lt;/code&gt;&lt;/a&gt; will overlap. This will return &lt;code&gt;(start_match, end_match)&lt;/code&gt;, where start_match is the index of where the match begins, and end_match is the index after the end of the match.</source>
          <target state="translated">&lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt; 와 달리 this 및 &lt;a href=&quot;trait.searcher#method.next_reject&quot;&gt; &lt;code&gt;next_reject&lt;/code&gt; &lt;/a&gt; 의 반환 된 범위 가 겹칠 것이라는 보장은 없습니다 . 이것은 &lt;code&gt;(start_match, end_match)&lt;/code&gt; 를 반환합니다 . 여기서 start_match는 일치가 시작되는 인덱스이고 end_match는 일치가 끝난 후의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="b07cc87b6de700e95562f870286c85dae89d1a54" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt;, this takes a &lt;em&gt;mutable&lt;/em&gt; reference to a slice of &lt;a href=&quot;struct.ioslice&quot;&gt;&lt;code&gt;IoSlice&lt;/code&gt;&lt;/a&gt;s, not an immutable one. That's because we need to modify the slice to keep track of the bytes already written.</source>
          <target state="translated">&lt;a href=&quot;trait.write#method.write_vectored&quot;&gt; &lt;code&gt;write_vectored&lt;/code&gt; &lt;/a&gt; 와 달리 이것은 불변이 아닌 &lt;a href=&quot;struct.ioslice&quot;&gt; &lt;code&gt;IoSlice&lt;/code&gt; &lt;/a&gt; 슬라이스에 대한 &lt;em&gt;가변&lt;/em&gt; 참조를 취합니다 . 이미 쓴 바이트를 추적하기 위해 슬라이스를 수정해야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="eee6890d64168a6d63a327f53d097426ab508e0a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;*mut T&lt;/code&gt;, &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; is covariant over &lt;code&gt;T&lt;/code&gt;. If this is incorrect for your use case, you should include some &lt;a href=&quot;../marker/struct.phantomdata&quot;&gt;&lt;code&gt;PhantomData&lt;/code&gt;&lt;/a&gt; in your type to provide invariance, such as &lt;code&gt;PhantomData&amp;lt;Cell&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a mut T&amp;gt;&lt;/code&gt;. Usually this won't be necessary; covariance is correct for most safe abstractions, such as &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Rc&lt;/code&gt;, &lt;code&gt;Arc&lt;/code&gt;, &lt;code&gt;Vec&lt;/code&gt;, and &lt;code&gt;LinkedList&lt;/code&gt;. This is the case because they provide a public API that follows the normal shared XOR mutable rules of Rust.</source>
          <target state="translated">달리 &lt;code&gt;*mut T&lt;/code&gt; , &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; IS 공변 위에 &lt;code&gt;T&lt;/code&gt; . 이것이 사용 사례에 맞지 않으면 &lt;code&gt;PhantomData&amp;lt;Cell&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a mut T&amp;gt;&lt;/code&gt; 와 같이 불일치 를 제공하기 위해 &lt;a href=&quot;../marker/struct.phantomdata&quot;&gt; &lt;code&gt;PhantomData&lt;/code&gt; &lt;/a&gt; 를 유형에 포함시켜야 합니다 . 보통 이것은 필요하지 않습니다. 공분산은 &lt;code&gt;Box&lt;/code&gt; , &lt;code&gt;Rc&lt;/code&gt; , &lt;code&gt;Arc&lt;/code&gt; , &lt;code&gt;Vec&lt;/code&gt; 및 &lt;code&gt;LinkedList&lt;/code&gt; 와 같은 대부분의 안전한 추상화에 적합 합니다. Rust의 일반적인 공유 XOR 변경 가능 규칙을 따르는 공개 API를 제공하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="da5b9cd95305c47f8c2680144fa717b64a77ae08" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;*mut T&lt;/code&gt;, the pointer must always be non-null, even if the pointer is never dereferenced. This is so that enums may use this forbidden value as a discriminant -- &lt;code&gt;Option&amp;lt;NonNull&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; has the same size as &lt;code&gt;*mut T&lt;/code&gt;. However the pointer may still dangle if it isn't dereferenced.</source>
          <target state="translated">&lt;code&gt;*mut T&lt;/code&gt; 와 달리 포인터가 역 참조되지 않더라도 포인터는 항상 널이 아니어야합니다. 이것은 열거 형이이 금지 된 값을 판별 자로 사용할 수 있도록하기위한 것입니다. &lt;code&gt;Option&amp;lt;NonNull&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 는 &lt;code&gt;*mut T&lt;/code&gt; 와 크기가 같습니다 . 그러나 포인터가 역 참조되지 않으면 여전히 매달려있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2af92ae1d7844362d4deb8a5a097d647449edca7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;AsRef&lt;/code&gt;, &lt;a href=&quot;../borrow/trait.borrow&quot;&gt;&lt;code&gt;Borrow&lt;/code&gt;&lt;/a&gt; has a blanket impl for any &lt;code&gt;T&lt;/code&gt;, and can be used to accept either a reference or a value.</source>
          <target state="translated">달리 &lt;code&gt;AsRef&lt;/code&gt; , &lt;a href=&quot;../borrow/trait.borrow&quot;&gt; &lt;code&gt;Borrow&lt;/code&gt; &lt;/a&gt; 임의 용 블랭킷 IMPL 갖는 &lt;code&gt;T&lt;/code&gt; 를 하고, 기준 위치 값 중 하나를 수용 할 수있다.</target>
        </trans-unit>
        <trans-unit id="23b18281654acc984643104c10e5e6c721877239" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;AsRef&lt;/code&gt;, &lt;code&gt;Borrow&lt;/code&gt; has a blanket impl for any &lt;code&gt;T&lt;/code&gt;, and can be used to accept either a reference or a value.</source>
          <target state="translated">&lt;code&gt;AsRef&lt;/code&gt; 와 달리 &lt;code&gt;Borrow&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 에 대한 담요 임펄스 를 가지며 참조 또는 값을 수락하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ceb8d46ab7abd8b54416adda315f1d04158fc52" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;C&lt;/code&gt;, zero sized structs are not rounded up to one byte in size.</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 와 달리 크기가 0 인 구조체는 크기가 1 바이트로 반올림되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02f8b77aa6c48466699ca8ee968807c87cf6172e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;C&lt;/code&gt;, zero sized unions are not rounded up to one byte in size.</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 와 달리 크기가 0 인 유니언은 1 바이트 크기로 올림되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af8a23b1549826352efacb218921580838863fd0" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;Pin::new_unchecked&lt;/code&gt;, this method is safe because the pointer &lt;code&gt;P&lt;/code&gt; dereferences to an &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; type, which cancels the pinning guarantees.</source>
          <target state="translated">&lt;code&gt;Pin::new_unchecked&lt;/code&gt; 와는 달리 ,이 방법은 포인터 &lt;code&gt;P&lt;/code&gt; 가 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 유형을 역 참조 하여 고정 보장을 취소 하므로 안전 합니다 .</target>
        </trans-unit>
        <trans-unit id="f597f0fe6680930140f1186767bedc7add8ce577" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type represents single ownership over the data it holds. So, what makes &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; different from a type like &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;? Recall the borrowing rules you learned in Chapter 4:</source>
          <target state="translated">달리 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 상기 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 유형은 보유 데이터에 대한 단일 소유권을 나타낸다. 그렇다면 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 와 같은 유형과 다른 점은 무엇입니까? 4 장에서 배운 차용 규칙을 상기하십시오.</target>
        </trans-unit>
        <trans-unit id="926eeb30ef8b029d9a554336169dcbfbccf0209b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;RefCell::borrow&lt;/code&gt;, this method is unsafe because it does not return a &lt;code&gt;Ref&lt;/code&gt;, thus leaving the borrow flag untouched. Mutably borrowing the &lt;code&gt;RefCell&lt;/code&gt; while the reference returned by this method is alive is undefined behaviour.</source>
          <target state="translated">&lt;code&gt;RefCell::borrow&lt;/code&gt; 와 달리 ,이 메소드는 &lt;code&gt;Ref&lt;/code&gt; 를 반환하지 않기 때문에 안전하지 않으므로 차용 플래그를 그대로 둡니다. Mutably 차입 &lt;code&gt;RefCell&lt;/code&gt; 를 기준이 방법에 의해 리턴 동안 살아 정의되지 않은 문제이다.</target>
        </trans-unit>
        <trans-unit id="42c8dcf936cacded32e38266231efc7d97352aa2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;RefCell&lt;/code&gt;, a &lt;code&gt;OnceCell&lt;/code&gt; only provides shared &lt;code&gt;&amp;amp;T&lt;/code&gt; references to its value. Unlike &lt;code&gt;Cell&lt;/code&gt;, a &lt;code&gt;OnceCell&lt;/code&gt; doesn't require copying or replacing the value to access it.</source>
          <target state="translated">달리 &lt;code&gt;RefCell&lt;/code&gt; 하는 &lt;code&gt;OnceCell&lt;/code&gt; 는 전용 공유 제공 &lt;code&gt;&amp;amp;T&lt;/code&gt; 그 값에 대한 참조를. 달리 &lt;code&gt;Cell&lt;/code&gt; 하는 &lt;code&gt;OnceCell&lt;/code&gt; 는 복사 또는 액세스 여기에 값을 교체 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d57c88d683b5f207c6b40e5f43b3334b288246db" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;connect&lt;/code&gt;, &lt;code&gt;connect_timeout&lt;/code&gt; takes a single &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; since timeout must be applied to individual addresses.</source>
          <target state="translated">달리 &lt;code&gt;connect&lt;/code&gt; , &lt;code&gt;connect_timeout&lt;/code&gt; 은 하나의 소요 &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; 을&lt;/a&gt; 제한 시간은 개별 주소에 적용해야하기 때문이다.</target>
        </trans-unit>
        <trans-unit id="1ac28d4f87c8eadd078ff1fbd83c69852aa4b470" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;fill_buf&lt;/code&gt;, this will not attempt to fill the buffer if it is empty.</source>
          <target state="translated">&lt;code&gt;fill_buf&lt;/code&gt; 와 달리 버퍼가 비어 있으면 버퍼를 채우려 고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c33686d3ffa81ffa69b98b7573a09c025985a84a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;read&lt;/code&gt;, the pointer may be unaligned.</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; 와 달리 포인터가 정렬되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5074eaba30dfa9d17ab40b89f4a8cde3f2ff28d5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;write&lt;/code&gt;, the pointer may be unaligned.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 와 달리 포인터가 정렬되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0869ce408d434adce2ac58f521663bfd0e76626c" translate="yes" xml:space="preserve">
          <source>Unlike an &lt;a href=&quot;../glossary#associated-item&quot;&gt;associated&lt;/a&gt; constant, a &lt;a href=&quot;../glossary#free-item&quot;&gt;free&lt;/a&gt; constant may be unnamed by using an underscore instead of the name. For example:</source>
          <target state="translated">&lt;a href=&quot;../glossary#associated-item&quot;&gt;연관된&lt;/a&gt; 상수 와 달리 &lt;a href=&quot;../glossary#free-item&quot;&gt;자유&lt;/a&gt; 상수는 이름 대신 밑줄을 사용하여 이름을 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1df7fba2918a10b0657219d3fc33575209df6ce" translate="yes" xml:space="preserve">
          <source>Unlike arithmetic and logical operators, the traits for overloading the operators the traits for these operators are used more generally to show how a type may be compared and will likely be assumed to define actual comparisons by functions that use these traits as bounds. Many functions and macros in the standard library can then use that assumption (although not to ensure safety). Unlike the arithmetic and logical operators above, these operators implicitly take shared borrows of their operands, evaluating them in &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression context&lt;/a&gt;:</source>
          <target state="translated">산술 및 논리 연산자와 달리 연산자 오버로드에 대한 특성은 이러한 연산자에 대한 특성이 유형을 비교하는 방법을 보여주기 위해 더 일반적으로 사용되며 이러한 특성을 경계로 사용하는 함수에 의한 실제 비교를 정의하는 것으로 가정됩니다. 표준 라이브러리의 많은 기능과 매크로는 안전을 보장하지는 않지만이 가정을 사용할 수 있습니다. 위의 산술 및 논리 연산자와 달리이 연산자는 암시 적으로 피연산자의 차용을 가져 와서 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;표현 컨텍스트를&lt;/a&gt; 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="121561ea59642cbf851a475739b422a107512b01" translate="yes" xml:space="preserve">
          <source>Unlike closures, &lt;code&gt;fn&lt;/code&gt; is a type rather than a trait, so we specify &lt;code&gt;fn&lt;/code&gt; as the parameter type directly rather than declaring a generic type parameter with one of the &lt;code&gt;Fn&lt;/code&gt; traits as a trait bound.</source>
          <target state="translated">클로저와 달리 &lt;code&gt;fn&lt;/code&gt; 은 특성이 아닌 유형이므로 &lt;code&gt;Fn&lt;/code&gt; 특성 중 하나를 특성 바인딩으로 사용하는 일반 유형 매개 변수를 선언하지 않고 &lt;code&gt;fn&lt;/code&gt; 을 매개 변수 유형으로 직접 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="ddb54f325fe389efa56003444a2d405f87525e97" translate="yes" xml:space="preserve">
          <source>Unlike for structs, local variables are dropped in reverse order:</source>
          <target state="translated">구조체와 달리 지역 변수는 역순으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="64287ed646615b0f4f1dbe6a0afd166352be3fa4" translate="yes" xml:space="preserve">
          <source>Unlike generic parameters or &lt;code&gt;impl Trait&lt;/code&gt;, the compiler does not know the concrete type that is being passed. That is, the type has been &lt;a href=&quot;https://en.wikipedia.org/wiki/Type_erasure&quot;&gt;erased&lt;/a&gt;. As such, a &lt;code&gt;dyn Trait&lt;/code&gt; reference contains &lt;em&gt;two&lt;/em&gt; pointers. One pointer goes to the data (e.g., an instance of a struct). Another pointer goes to a map of method call names to function pointers (known as a virtual method table or vtable).</source>
          <target state="translated">일반 매개 변수 또는 &lt;code&gt;impl Trait&lt;/code&gt; 과 달리 컴파일러는 전달되는 구체적인 유형을 알지 못합니다. 즉, 유형이 &lt;a href=&quot;https://en.wikipedia.org/wiki/Type_erasure&quot;&gt;지워졌습니다&lt;/a&gt; . 따라서 &lt;code&gt;dyn Trait&lt;/code&gt; 참조에는 &lt;em&gt;두 개의&lt;/em&gt; 포인터 가 포함 됩니다. 하나의 포인터는 데이터 (예 : 구조체의 인스턴스)로 이동합니다. 또 다른 포인터는 함수 포인터 (가상 메서드 테이블 또는 vtable이라고 함)에 대한 메서드 호출 이름 맵으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="7ac0121efe5c81f6ee999aad45c525acd80438be" translate="yes" xml:space="preserve">
          <source>Unlike in the TCP case, passing an array of addresses to the &lt;code&gt;connect&lt;/code&gt; function of a UDP socket is not a useful thing to do: The OS will be unable to determine whether something is listening on the remote address without the application sending data.</source>
          <target state="translated">TCP의 경우와 달리 , UDP 소켓 의 &lt;code&gt;connect&lt;/code&gt; 기능 에 주소 배열을 전달하는 것은 유용한 방법이 아닙니다. OS는 응용 프로그램이 데이터를 전송하지 않고 원격 주소에서 무언가 수신 중인지 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a7c8893077e685528bec1188265b9f18660f72cd" translate="yes" xml:space="preserve">
          <source>Unlike next(), there is no guarantee that the returned ranges of this and next_match will overlap.</source>
          <target state="translated">next ()와 달리이 범위와 next_match의 반환 범위가 겹칠 것이라는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="d71db212c677479519bbb6e79cc1b75787a4617d" translate="yes" xml:space="preserve">
          <source>Unlike next(), there is no guarantee that the returned ranges of this and next_reject will overlap. This will return (start_match, end_match), where start_match is the index of where the match begins, and end_match is the index after the end of the match.</source>
          <target state="translated">next ()와 달리 이것과 next_reject의 반환 범위가 겹칠 것이라는 보장은 없습니다. 그러면 start_match, end_match가 반환됩니다. 여기서 start_match는 일치가 시작되는 위치의 인덱스이고 end_match는 일치가 끝난 후의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="6692903ae621839ab645be72d216172c7413d4a0" translate="yes" xml:space="preserve">
          <source>Unlike normal functions, extern fns have type &lt;code&gt;extern &quot;ABI&quot; fn()&lt;/code&gt;. This is the same type as the functions declared in an extern block.</source>
          <target state="translated">일반 함수와 달리 extern fns에는 &lt;code&gt;extern &quot;ABI&quot; fn()&lt;/code&gt; 유형이 있습니다. 이것은 extern 블록에 선언 된 함수와 동일한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="36f4ada6278b2f8caced444ea3301e8d71339c65" translate="yes" xml:space="preserve">
          <source>Unlike other methods on &lt;code&gt;TcpStream&lt;/code&gt;, this does not correspond to a single system call. It instead calls &lt;code&gt;connect&lt;/code&gt; in nonblocking mode and then uses an OS-specific mechanism to await the completion of the connection request.</source>
          <target state="translated">&lt;code&gt;TcpStream&lt;/code&gt; 의 다른 메소드와 달리 이는 단일 시스템 호출에 해당하지 않습니다. 대신 비 차단 모드에서 &lt;code&gt;connect&lt;/code&gt; 를 호출 한 다음 OS 별 메커니즘을 사용하여 연결 요청 완료를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="d70fcfde3feb0ab38dc2fc9e1a50deff87be8c12" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; free function, this method yields an &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt; to capture any failure to create the thread at the OS level.</source>
          <target state="translated">&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt; 프리 기능 과 달리이 방법은 &lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; 를 생성하여 OS 레벨에서 스레드를 작성하는 데 실패한 것을 캡처합니다.</target>
        </trans-unit>
        <trans-unit id="f0b436366c65f5f44a2751625381a1b624985a04" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;offset&lt;/code&gt; intrinsic, this intrinsic does not restrict the resulting pointer to point into or one byte past the end of an allocated object, and it wraps with two's complement arithmetic. The resulting value is not necessarily valid to be used to actually access memory.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 내장 함수 와 달리이 내장 함수는 결과 포인터가 할당 된 객체의 끝을지나 1 바이트를 가리 키도록 제한하지 않으며 2의 보수 산술로 래핑됩니다. 결과 값이 실제로 메모리에 액세스하는 데 사용될 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="6faf47afea7f3d6a44a9251fcf64aa5fc01a6de0" translate="yes" xml:space="preserve">
          <source>Unlike the other kinds of loops in Rust (&lt;code&gt;while&lt;/code&gt;, &lt;code&gt;while let&lt;/code&gt;, and &lt;code&gt;for&lt;/code&gt;), loops can be used as expressions that return values via &lt;code&gt;break&lt;/code&gt;.</source>
          <target state="translated">Rust의 다른 종류의 루프 ( &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;while let&lt;/code&gt; 및 &lt;code&gt;for&lt;/code&gt; ) 와 달리 루프는 &lt;code&gt;break&lt;/code&gt; 를 통해 값을 반환하는 표현식으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c816b7f283c34ee4cf6d4ad3a434746ee09b413" translate="yes" xml:space="preserve">
          <source>Unnamed constant</source>
          <target state="translated">이름이없는 상수</target>
        </trans-unit>
        <trans-unit id="2eba6a03b89a9ddb19e9cb15699a8737f8bab076" translate="yes" xml:space="preserve">
          <source>Unpin</source>
          <target state="translated">Unpin</target>
        </trans-unit>
        <trans-unit id="5ea7d63651b5ab2fca876bb44555b1ae728096be" translate="yes" xml:space="preserve">
          <source>Unqualified path patterns can refer to:</source>
          <target state="translated">규정되지 않은 경로 패턴은 다음을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76194078e8e620ab2e92b2710e1b86b55aa19577" translate="yes" xml:space="preserve">
          <source>Unrecoverable Errors with &lt;code id=&quot;unrecoverable-errors-with-panic&quot;&gt;panic!&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;unrecoverable-errors-with-panic&quot;&gt;panic!&lt;/code&gt; 복구 할 수없는 오류 !</target>
        </trans-unit>
        <trans-unit id="70558ee42c96fb4886d205abf6563d627dc6cb30" translate="yes" xml:space="preserve">
          <source>Unregisters the current allocation error hook, returning it.</source>
          <target state="translated">현재 할당 오류 후크를 등록 취소하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0b233b52323b31980ad438994ac81379bf159f10" translate="yes" xml:space="preserve">
          <source>Unregisters the current panic hook, returning it.</source>
          <target state="translated">현재 패닉 후크를 등록 취소하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4ad2c25804ae1c9519924b3333558a84852f9759" translate="yes" xml:space="preserve">
          <source>Unsafe Rust</source>
          <target state="translated">안전하지 않은 녹</target>
        </trans-unit>
        <trans-unit id="2bf8239af3f464752ec2490794f409624c78c660" translate="yes" xml:space="preserve">
          <source>Unsafe Rust exists because, by nature, static analysis is conservative. When the compiler tries to determine whether or not code upholds the guarantees, it&amp;rsquo;s better for it to reject some valid programs rather than accept some invalid programs. Although the code might be okay, as far as Rust is able to tell, it&amp;rsquo;s not! In these cases, you can use unsafe code to tell the compiler, &amp;ldquo;Trust me, I know what I&amp;rsquo;m doing.&amp;rdquo; The downside is that you use it at your own risk: if you use unsafe code incorrectly, problems due to memory unsafety, such as null pointer dereferencing, can occur.</source>
          <target state="translated">안전하지 않은 녹은 본질적으로 정적 분석이 보수적이기 때문에 존재합니다. 컴파일러가 코드가 보증을 유지하는지 여부를 판별하려고 할 때 일부 유효하지 않은 프로그램을 승인하는 것보다 일부 유효 프로그램을 거부하는 것이 좋습니다. Rust가 말할 수있는 한 코드는 괜찮을 수도 있지만 그렇지 않습니다! 이 경우 안전하지 않은 코드를 사용하여 컴파일러에게&amp;ldquo;내가하는 일을 알고 있습니다.&amp;rdquo;라고 말할 수 있습니다. 안전하지 않은 코드를 잘못 사용하면 null 포인터 역 참조와 같은 메모리 안전 문제로 인해 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6d976facee53ef7685c3c2e196f51896ea84263" translate="yes" xml:space="preserve">
          <source>Unsafe Rust: how to opt out of some of Rust&amp;rsquo;s guarantees and take responsibility for manually upholding those guarantees</source>
          <target state="translated">안전하지 않은 녹 : Rust의 보증 중 일부를 선택 해제하고 해당 보증을 수동으로 유지하는 책임을지는 방법</target>
        </trans-unit>
        <trans-unit id="fe954ab5c7d2bf81229af474f3df1f82baf2452e" translate="yes" xml:space="preserve">
          <source>Unsafe Superpowers</source>
          <target state="translated">안전하지 않은 초능력</target>
        </trans-unit>
        <trans-unit id="213dd70d91f9e41a9bf1846e9c631a99cd907b6a" translate="yes" xml:space="preserve">
          <source>Unsafe abilities</source>
          <target state="translated">안전하지 않은 능력</target>
        </trans-unit>
        <trans-unit id="baac6e0b0340f8475119715946cbe8c2961f1b1b" translate="yes" xml:space="preserve">
          <source>Unsafe blocks</source>
          <target state="translated">안전하지 않은 블록</target>
        </trans-unit>
        <trans-unit id="14b175946b1bbc439b9bcf446b898eb6bb255e29" translate="yes" xml:space="preserve">
          <source>Unsafe blocks are used to wrap foreign libraries, make direct use of hardware or implement features not directly present in the language. For example, Rust provides the language features necessary to implement memory-safe concurrency in the language but the implementation of threads and message passing is in the standard library.</source>
          <target state="translated">안전하지 않은 블록은 외부 라이브러리를 래핑하거나 하드웨어를 직접 사용하거나 언어에 직접 존재하지 않는 기능을 구현하는 데 사용됩니다. 예를 들어, Rust는 언어로 메모리 안전 동시성을 구현하는 데 필요한 언어 기능을 제공하지만 스레드 및 메시지 전달 구현은 표준 라이브러리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="22664c4ba89e060c3e51b8ae88cd58e9bfacca10" translate="yes" xml:space="preserve">
          <source>Unsafe code may rely on &lt;code&gt;assert!&lt;/code&gt; to enforce run-time invariants that, if violated could lead to unsafety.</source>
          <target state="translated">안전하지 않은 코드는 &lt;code&gt;assert!&lt;/code&gt; 위반할 경우 안전하지 않을 수있는 런타임 불변성을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="c67e2a049687812f1b206c18f80d4f4b930977c1" translate="yes" xml:space="preserve">
          <source>Unsafe code relies on &lt;code&gt;assert!&lt;/code&gt; to enforce run-time invariants that, if violated could lead to unsafety.</source>
          <target state="translated">안전하지 않은 코드는 &lt;code&gt;assert!&lt;/code&gt; 의존합니다 ! 위반시 안전하지 않을 수있는 런타임 불변량을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="4155a1ec65a094fcbe134a0c2768d51a34c574a8" translate="yes" xml:space="preserve">
          <source>Unsafe code should not rely on the correctness of behavior after overflow.</source>
          <target state="translated">안전하지 않은 코드는 오버플로 후 동작의 정확성에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="c53274f3a611843db2cae74ec90f381fafeb9213" translate="yes" xml:space="preserve">
          <source>Unsafe code was used outside of an unsafe function or block.</source>
          <target state="translated">안전하지 않은 코드는 안전하지 않은 기능 또는 블록 외부에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="8e1ff2612e7d854020e10b3d3b36d74fbd9cd65b" translate="yes" xml:space="preserve">
          <source>Unsafe functions</source>
          <target state="translated">안전하지 않은 기능</target>
        </trans-unit>
        <trans-unit id="10b765166af116817c2643c79030e41920ee70d7" translate="yes" xml:space="preserve">
          <source>Unsafe functions are functions that are not safe in all contexts and/or for all possible inputs. Such a function must be prefixed with the keyword &lt;code&gt;unsafe&lt;/code&gt; and can only be called from an &lt;code&gt;unsafe&lt;/code&gt; block or another &lt;code&gt;unsafe&lt;/code&gt; function.</source>
          <target state="translated">안전하지 않은 기능은 모든 상황 및 / 또는 모든 가능한 입력에 대해 안전하지 않은 기능입니다. 이러한 함수는 &lt;code&gt;unsafe&lt;/code&gt; 키워드로 시작해야하며 &lt;code&gt;unsafe&lt;/code&gt; 블록이나 다른 &lt;code&gt;unsafe&lt;/code&gt; 함수 에서만 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d33167b0116d560739d43b19ab027e220d852053" translate="yes" xml:space="preserve">
          <source>Unsafe is used on an async function in precisely the same way that it is used on other functions: it indicates that the function imposes some additional obligations on its caller to ensure soundness. As in any other unsafe function, these conditions may extend beyond the initial call itself -- in the snippet above, for example, the &lt;code&gt;unsafe_example&lt;/code&gt; function took a pointer &lt;code&gt;x&lt;/code&gt; as argument, and then (when awaited) dereferenced that pointer. This implies that &lt;code&gt;x&lt;/code&gt; would have to be valid until the future is finished executing, and it is the callers responsibility to ensure that.</source>
          <target state="translated">Unsafe는 다른 함수에서 사용되는 것과 똑같은 방식으로 비동기 함수에서 사용됩니다. 이는 함수가 건전성을 보장하기 위해 호출자에게 몇 가지 추가 의무를 부과 함을 나타냅니다. 다른 안전 기능에서와 같이, 이러한 조건은 초기 호출 자체를 넘어 연장 될 수있다 - 위에서 코드에서, 예를 들면, &lt;code&gt;unsafe_example&lt;/code&gt; 함수 포인터했다 &lt;code&gt;x&lt;/code&gt; 인수로 한 다음 (대망시) 그 포인터를 역 참조. 이것은 미래가 실행을 마칠 때까지 &lt;code&gt;x&lt;/code&gt; 가 유효해야 함을 의미 하며이를 보장하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="44d7f0c36d2323b4760c5854a9da5e93bff496e9" translate="yes" xml:space="preserve">
          <source>Unsafe operations are those that can potentially violate the memory-safety guarantees of Rust's static semantics.</source>
          <target state="translated">안전하지 않은 작업은 Rust의 정적 의미론의 메모리 안전 보장을 위반할 가능성이있는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="bf164d180d2c3d60fa72dcb8309415b858fb3ef4" translate="yes" xml:space="preserve">
          <source>Unsafe traits</source>
          <target state="translated">안전하지 않은 특성</target>
        </trans-unit>
        <trans-unit id="3f92b08e3c34ebb357bc1ad626c86bb44dccf639" translate="yes" xml:space="preserve">
          <source>Unsafe traits must have unsafe implementations. This error occurs when an implementation for an unsafe trait isn't marked as unsafe. This may be resolved by marking the unsafe implementation as unsafe.</source>
          <target state="translated">안전하지 않은 특성에는 안전하지 않은 구현이 있어야합니다. 안전하지 않은 특성의 구현이 안전하지 않은 것으로 표시되지 않은 경우이 오류가 발생합니다. 안전하지 않은 구현을 안전하지 않은 것으로 표시하면이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5115d7bdd1417d736db11b27ea37e8ee82718f27" translate="yes" xml:space="preserve">
          <source>UnsafeCell</source>
          <target state="translated">UnsafeCell</target>
        </trans-unit>
        <trans-unit id="2c35a285bb852cf3e62f32e3633426c0ef4631a3" translate="yes" xml:space="preserve">
          <source>UnsafeCell::borrow</source>
          <target state="translated">UnsafeCell::borrow</target>
        </trans-unit>
        <trans-unit id="75bc0d417d751ed027f53b28049e848ca0749b51" translate="yes" xml:space="preserve">
          <source>UnsafeCell::borrow_mut</source>
          <target state="translated">UnsafeCell::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a881f13247abe21c6a44c037b8dd96d764dbe3f6" translate="yes" xml:space="preserve">
          <source>UnsafeCell::default</source>
          <target state="translated">UnsafeCell::default</target>
        </trans-unit>
        <trans-unit id="dff2508a0e8759e4bdb101a66e3d4f193575af5f" translate="yes" xml:space="preserve">
          <source>UnsafeCell::fmt</source>
          <target state="translated">UnsafeCell::fmt</target>
        </trans-unit>
        <trans-unit id="fdaf457db9ff90155c2c22c46f8d7d84bbcf495e" translate="yes" xml:space="preserve">
          <source>UnsafeCell::from</source>
          <target state="translated">UnsafeCell::from</target>
        </trans-unit>
        <trans-unit id="3345a29406bcc11d2b5b8b2bbebd7e4e0bd82ec5" translate="yes" xml:space="preserve">
          <source>UnsafeCell::get</source>
          <target state="translated">UnsafeCell::get</target>
        </trans-unit>
        <trans-unit id="c9466ca2fc8e49b6dbd92183423a4c8fa163622c" translate="yes" xml:space="preserve">
          <source>UnsafeCell::into</source>
          <target state="translated">UnsafeCell::into</target>
        </trans-unit>
        <trans-unit id="f93e09df9c8216c70f11ba4964e183b8a07e1fb7" translate="yes" xml:space="preserve">
          <source>UnsafeCell::into_inner</source>
          <target state="translated">UnsafeCell::into_inner</target>
        </trans-unit>
        <trans-unit id="b09cd160b3ecd626dee4e6ef60b717116e682ae5" translate="yes" xml:space="preserve">
          <source>UnsafeCell::new</source>
          <target state="translated">UnsafeCell::new</target>
        </trans-unit>
        <trans-unit id="4a93c833e143a391e62488b530430f04d10a5b76" translate="yes" xml:space="preserve">
          <source>UnsafeCell::try_from</source>
          <target state="translated">UnsafeCell::try_from</target>
        </trans-unit>
        <trans-unit id="cde666e236559ffd66009b3fdec4a7ed6f2c1d9f" translate="yes" xml:space="preserve">
          <source>UnsafeCell::try_into</source>
          <target state="translated">UnsafeCell::try_into</target>
        </trans-unit>
        <trans-unit id="3b8d314be6e0f9f234457b987c6cbb99be6adc66" translate="yes" xml:space="preserve">
          <source>UnsafeCell::type_id</source>
          <target state="translated">UnsafeCell::type_id</target>
        </trans-unit>
        <trans-unit id="e0539de3e0de023b7e2dd1485ffa3c4a0acc8d49" translate="yes" xml:space="preserve">
          <source>Unsafely creates a C string wrapper from a byte slice.</source>
          <target state="translated">바이트 슬라이스에서 C 문자열 래퍼를 안전하지 않게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="80d75cb6c5a344f6eadb72b7d847c31a12dc80ca" translate="yes" xml:space="preserve">
          <source>Unsafety</source>
          <target state="translated">Unsafety</target>
        </trans-unit>
        <trans-unit id="e91344ea16120944c87d0e0635826ca2b1e1956c" translate="yes" xml:space="preserve">
          <source>Unsigned</source>
          <target state="translated">Unsigned</target>
        </trans-unit>
        <trans-unit id="ec69039d9aace16bc0675cab4f4e5d7118fc67b0" translate="yes" xml:space="preserve">
          <source>Unsize</source>
          <target state="translated">Unsize</target>
        </trans-unit>
        <trans-unit id="8702197dc32e4fc5986508c97d9597351056f2bf" translate="yes" xml:space="preserve">
          <source>Unsized Coercions</source>
          <target state="translated">크기가없는 강제</target>
        </trans-unit>
        <trans-unit id="a090334da83d2c5e2a98abcbd42c6af2bf5571a1" translate="yes" xml:space="preserve">
          <source>Unsized data:</source>
          <target state="translated">크기가 조정되지 않은 데이터 :</target>
        </trans-unit>
        <trans-unit id="ea2569aaa33eada2280795d75f286bd6771924fe" translate="yes" xml:space="preserve">
          <source>Unstable Features</source>
          <target state="translated">불안정한 특징</target>
        </trans-unit>
        <trans-unit id="92ffa7782162b2b301a0b11d2aefb00ca2f2a2f0" translate="yes" xml:space="preserve">
          <source>Until now, all our examples have been matching structs or enums that were one level deep. Matching can work on nested items too!</source>
          <target state="translated">지금까지 우리의 모든 예제는 한 수준 깊이의 구조체 또는 열거와 일치했습니다. 중첩 된 항목에서도 매칭이 가능합니다!</target>
        </trans-unit>
        <trans-unit id="9a0d085fdd50abbdcb3c17611b8692b87c3b02d5" translate="yes" xml:space="preserve">
          <source>Until now, we&amp;rsquo;ve not talked about &lt;em&gt;global variables&lt;/em&gt;, which Rust does support but can be problematic with Rust&amp;rsquo;s ownership rules. If two threads are accessing the same mutable global variable, it can cause a data race.</source>
          <target state="translated">지금까지 우리는 Rust가 지원하지만 Rust의 소유권 규칙에 문제가 될 수있는 &lt;em&gt;전역 변수&lt;/em&gt; 에 대해서는 이야기하지 않았습니다 . 두 개의 스레드가 동일한 가변 글로벌 변수에 액세스하는 경우 데이터 경쟁이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bef75503876861f1652d24e0b101fc042661d7b5" translate="yes" xml:space="preserve">
          <source>Until these issues are resolved, you can use the &lt;a href=&quot;https://crates.io/crates/async-trait&quot;&gt;&lt;code&gt;async-trait&lt;/code&gt; crate&lt;/a&gt;, allowing you to use &lt;code&gt;async fn&lt;/code&gt; in traits by desugaring to &quot;boxed futures&quot; (&lt;code&gt;Pin&amp;lt;Box&amp;lt;dyn Future + Send + 'async&amp;gt;&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">이러한 문제가 해결 될 때까지 &lt;a href=&quot;https://crates.io/crates/async-trait&quot;&gt; &lt;code&gt;async-trait&lt;/code&gt; crate&lt;/a&gt; 를 사용 하면 &quot;boxed futures&quot;( &lt;code&gt;Pin&amp;lt;Box&amp;lt;dyn Future + Send + 'async&amp;gt;&amp;gt;&lt;/code&gt; ) 로 desugaring하여 특성에서 &lt;code&gt;async fn&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a466dbcb07d272a4827d08399fcc579473f95bac" translate="yes" xml:space="preserve">
          <source>Unused lifetime parameters</source>
          <target state="translated">사용하지 않은 수명 매개 변수</target>
        </trans-unit>
        <trans-unit id="67f29d2fd70384a80fd94676bef420c60ec02613" translate="yes" xml:space="preserve">
          <source>Unused type parameters</source>
          <target state="translated">사용하지 않는 유형 매개 변수</target>
        </trans-unit>
        <trans-unit id="4309bf93c467874d67ac366ea9fc690edd209fc3" translate="yes" xml:space="preserve">
          <source>UnwindSafe</source>
          <target state="translated">UnwindSafe</target>
        </trans-unit>
        <trans-unit id="cbc02d75adc1ffc39fd3a16b3b4074d157341ccf" translate="yes" xml:space="preserve">
          <source>Unwinding the Stack or Aborting in Response to a Panic</source>
          <target state="translated">공황에 대한 응답으로 스택 풀기 또는 중단</target>
        </trans-unit>
        <trans-unit id="2789441f00b1b852b1abc369acfc06188469d312" translate="yes" xml:space="preserve">
          <source>Unwraps a result or propagates its error.</source>
          <target state="translated">결과를 풀거나 오류를 전파합니다.</target>
        </trans-unit>
        <trans-unit id="bf154983f21c606f5ed175df0a60de13c896591a" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과를 풀고 &lt;a href=&quot;enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 의 내용을 산출합니다 .</target>
        </trans-unit>
        <trans-unit id="88ae872ed59ebfa48f0864e25ba0455dd8b90e15" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과를 풀고 &lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 의 내용을 산출합니다 .</target>
        </trans-unit>
        <trans-unit id="f6bb0d8e70fa6dd56dc1322239dbf82a2df0a4ac" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;. Else, it returns &lt;code&gt;optb&lt;/code&gt;.</source>
          <target state="translated">결과를 풀고 &lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 의 내용을 산출합니다 . 그렇지 않으면 &lt;code&gt;optb&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="117016b46649ef00153af6f7350c9138ecc67dda" translate="yes" xml:space="preserve">
          <source>Unwraps a result, yielding the content of an &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;. If the value is an &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; then it calls &lt;code&gt;op&lt;/code&gt; with its value.</source>
          <target state="translated">결과를 풀고 &lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 의 내용을 산출합니다 . 값이 &lt;a href=&quot;enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 이면 해당 값으로 &lt;code&gt;op&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="6d656a32648587effa39921eb330f108c0675d59" translate="yes" xml:space="preserve">
          <source>Unwraps an option, yielding the content of a &lt;a href=&quot;#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">옵션을 풀어서 &lt;a href=&quot;#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; 의 컨텐츠를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="44e46942e6b3560b76547c4068197f656ff8557f" translate="yes" xml:space="preserve">
          <source>Unwraps the value.</source>
          <target state="translated">값을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="cbbcbd99f909cf5773cc2f8cf87cdd95f999143d" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt;, returning the underlying reader.</source>
          <target state="translated">이 &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; 해제 하고 기본 판독기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="45c0f60884f81c191ed8a1499ae68b62ce7e7ea6" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufReader&lt;/code&gt;, returning the underlying reader.</source>
          <target state="translated">이 &lt;code&gt;BufReader&lt;/code&gt; 의 랩을 해제 해 , 기본이되는 리더를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="d79f711284b065af6b4e74f8652871df33141f21" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt;, returning the underlying writer.</source>
          <target state="translated">이 &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt; 언 래핑 하고 기본 라이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="69524452be5afea8f11639be9af1a3cd4b2bfb03" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;BufWriter&lt;/code&gt;, returning the underlying writer.</source>
          <target state="translated">이 &lt;code&gt;BufWriter&lt;/code&gt; 의 랩을 해제 해 , 기본이되는 라이터를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="935d143678423728d032f85b20c66b89ea1e5a53" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;LineWriter&lt;/code&gt;, returning the underlying writer.</source>
          <target state="translated">이 &lt;code&gt;LineWriter&lt;/code&gt; 의 랩을 해제 해 , 기본이되는 라이터를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="2e3b12243482f11a01fe101039b067f041f66124" translate="yes" xml:space="preserve">
          <source>Unwraps this &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; returning the underlying pointer.</source>
          <target state="translated">기본이되는 포인터를 돌려주는 이 &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; 랩을 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="9b17789b43e82ba91c88e4d986c1f5d5ba8289b4" translate="yes" xml:space="preserve">
          <source>Update the two instances of duplicated code to call the function instead.</source>
          <target state="translated">대신 중복 된 코드의 두 인스턴스를 업데이트하여 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="9d8edb0cba2f3c71c929550f878ec6f1ab95a982" translate="yes" xml:space="preserve">
          <source>Update to a newer Rust version</source>
          <target state="translated">최신 Rust 버전으로 업데이트</target>
        </trans-unit>
        <trans-unit id="a37ad606755c045819fc66433cff2f591c85b628" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.path#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;extension&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.path#method.extension&quot;&gt; &lt;code&gt;self.extension&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;extension&lt;/code&gt; 업데이트 합니다 .</target>
        </trans-unit>
        <trans-unit id="b39de9c5b81e5a6bb6d85d389439d91c0bfb9619" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.path#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.path#method.file_name&quot;&gt; &lt;code&gt;self.file_name&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;file_name&lt;/code&gt; 으로 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="383cb3a84b0a57cded7c0258c7e1a49880c35c95" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;extension&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt; &lt;code&gt;self.extension&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;extension&lt;/code&gt; 으로 업데이트 합니다 .</target>
        </trans-unit>
        <trans-unit id="f3c4a6fdd4244e071cb1f5b4ee0c1015487b2074" translate="yes" xml:space="preserve">
          <source>Updates &lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt; &lt;code&gt;self.file_name&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;file_name&lt;/code&gt; 으로 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="499d5f0f7c8875ae92624d65ec97b14c16b89ea7" translate="yes" xml:space="preserve">
          <source>Updates the contained value using a function and returns the new value.</source>
          <target state="translated">함수를 사용하여 포함 된 값을 업데이트하고 새 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="54c400ee034681ba4f94547c1f9e6d6c6ae60547" translate="yes" xml:space="preserve">
          <source>Updating a Crate to Get a New Version</source>
          <target state="translated">새 버전을 얻기 위해 상자 업데이트</target>
        </trans-unit>
        <trans-unit id="230bbf8ccb89f28d643435c51ba717b409f87480" translate="yes" xml:space="preserve">
          <source>Updating a Hash Map</source>
          <target state="translated">해시 맵 업데이트</target>
        </trans-unit>
        <trans-unit id="83885ba9f035a9010b4b1ccae0e7e7d6ed9f8e1e" translate="yes" xml:space="preserve">
          <source>Updating a String</source>
          <target state="translated">문자열 업데이트</target>
        </trans-unit>
        <trans-unit id="d2ba6d88a1646ea3bcd8516dafee00edcea72844" translate="yes" xml:space="preserve">
          <source>Updating a Value Based on the Old Value</source>
          <target state="translated">기존 값을 기준으로 값 업데이트</target>
        </trans-unit>
        <trans-unit id="923fa3af760fbaa62e4ad240ccab4df3cf7cd0e1" translate="yes" xml:space="preserve">
          <source>Updating a Vector</source>
          <target state="translated">벡터 업데이트</target>
        </trans-unit>
        <trans-unit id="e383c87cdb72887f6744a78bd78fa459e44a666d" translate="yes" xml:space="preserve">
          <source>Updating and Uninstalling</source>
          <target state="translated">업데이트 및 제거</target>
        </trans-unit>
        <trans-unit id="874862d7b95e02718d554f979aec41adae9c4cee" translate="yes" xml:space="preserve">
          <source>Upon receiving spin-loop signal the processor can optimize its behavior by, for example, saving power or switching hyper-threads.</source>
          <target state="translated">스핀 루프 신호를 수신하면 프로세서는 예를 들어 전력을 절약하거나 하이퍼 스레드를 전환하여 동작을 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0b0bd731b8e15bb23bd7cc76d2aa724aa6bbacd" translate="yes" xml:space="preserve">
          <source>Upon receiving the spin-loop signal the processor can optimize its behavior by, for example, saving power or switching hyper-threads.</source>
          <target state="translated">스핀 루프 신호를 수신하면 프로세서는 예를 들어 전력을 절약하거나 하이퍼 스레드를 전환하여 동작을 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22415b6a3d0c513d757498ec107592efc88cd6e4" translate="yes" xml:space="preserve">
          <source>UpperExp</source>
          <target state="translated">UpperExp</target>
        </trans-unit>
        <trans-unit id="fcfc7b5ea59d907143490b4156e6805ce49d5515" translate="yes" xml:space="preserve">
          <source>UpperExp::fmt</source>
          <target state="translated">UpperExp::fmt</target>
        </trans-unit>
        <trans-unit id="f690e8510e34f299255dfcc6523578488db8db3e" translate="yes" xml:space="preserve">
          <source>UpperHex</source>
          <target state="translated">UpperHex</target>
        </trans-unit>
        <trans-unit id="2bafd282159acd4fe944a3d1a0e5e2492ec2091e" translate="yes" xml:space="preserve">
          <source>UpperHex::fmt</source>
          <target state="translated">UpperHex::fmt</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="8139f3704cf1ae8bc1b831776ef1b322f4905331" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; for this behavior.</source>
          <target state="translated">이 동작 에는 &lt;a href=&quot;#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="31c647ca0e64548e5df242f616757ada55c0dfbe" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; for this behavior.</source>
          <target state="translated">이 동작을 위해 &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="687f0dae29440086643b86ae5972f2641cdbdfdb" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;fn.park_timeout&quot;&gt;&lt;code&gt;park_timeout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fn.park_timeout&quot;&gt; &lt;code&gt;park_timeout&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ebca8bdf54e76e24d82dc68f6b0bc04c50c7f47f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; for this behavior.</source>
          <target state="translated">이 동작을 위해 &lt;a href=&quot;primitive.str#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e960174a6840a72333f0c4af39164868fd34c4f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;struct.vec#method.get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.vec#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt; if you want to check whether the index is in the &lt;code&gt;Vec&lt;/code&gt;.</source>
          <target state="translated">인덱스가 &lt;code&gt;Vec&lt;/code&gt; 에 있는지 확인 하려면 &lt;a href=&quot;struct.vec#method.get&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.vec#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="88bbc8b66ff470f012eb3c0cc67e657fee2b3c01" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Fn&lt;/code&gt; as a bound when you want to accept a parameter of function-like type and need to call it repeatedly and without mutating state (e.g., when calling it concurrently). If you do not need such strict requirements, use &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; as bounds.</source>
          <target state="translated">함수형 유형의 매개 변수를 승인하고 변경 상태없이 (예 : 동시에 호출 할 때) 반복해서 호출해야하는 경우 &lt;code&gt;Fn&lt;/code&gt; 을 바운드로 사용하십시오 . 이러한 엄격한 요구 사항이 필요하지 않은 경우 &lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt; 를 범위로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="606e32d3718b3ad9261ab53d0c58fffdae2c3eb7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;FnMut&lt;/code&gt; as a bound when you want to accept a parameter of function-like type and need to call it repeatedly, while allowing it to mutate state. If you don't want the parameter to mutate state, use &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; as a bound; if you don't need to call it repeatedly, use &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">함수와 같은 유형의 매개 변수를 승인하고 상태를 변경하는 동안 반복적으로 호출해야 할 경우 &lt;code&gt;FnMut&lt;/code&gt; 를 바운드로 사용하십시오 . 매개 변수가 상태를 변경하지 않게하려면 &lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; 을 바운드로 사용하십시오. 반복해서 호출 할 필요가 없으면 &lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0490417243191fd2b7e8ec23e8ffa3dcdc8fa81b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;FnOnce&lt;/code&gt; as a bound when you want to accept a parameter of function-like type and only need to call it once. If you need to call the parameter repeatedly, use &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; as a bound; if you also need it to not mutate state, use &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;FnOnce&lt;/code&gt; 유형의 매개 변수를 승인하고 한 번만 호출해야하는 경우 FnOnce 를 바운드로 사용하십시오 . 매개 변수를 반복해서 호출해야하는 경우 &lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; 를 바운드로 사용 하십시오 . 상태를 변경하지 않으려면 &lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="58e9a37a75f6d151dc00d0d282a3a92ae64a1400" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ThreadPool&lt;/code&gt; to perform some task other than serving web requests.</source>
          <target state="translated">웹 요청을 제공하는 것 이외의 작업을 수행 하려면 &lt;code&gt;ThreadPool&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d84e22d164ffb7c941231da29582df4847d529a7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;async&lt;/code&gt; in front of &lt;code&gt;fn&lt;/code&gt;, &lt;code&gt;closure&lt;/code&gt;, or a &lt;code&gt;block&lt;/code&gt; to turn the marked code into a &lt;code&gt;Future&lt;/code&gt;. As such the code will not be run immediately, but will only be evaluated when the returned future is &lt;code&gt;.await&lt;/code&gt;ed.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; , &lt;code&gt;closure&lt;/code&gt; 또는 &lt;code&gt;block&lt;/code&gt; 앞에 &lt;code&gt;async&lt;/code&gt; 를 사용 하여 표시된 코드를 &lt;code&gt;Future&lt;/code&gt; 로 바꿉니다 . 따라서 코드는 즉시 실행되지 않지만 반환 된 future가 &lt;code&gt;.await&lt;/code&gt; ed 일 때만 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="78610f1f9c97f303d12e27f1de6220faa88beddc" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;compare_exchange&lt;/code&gt; or &lt;code&gt;compare_exchange_weak&lt;/code&gt; instead</source>
          <target state="translated">사용 &lt;code&gt;compare_exchange&lt;/code&gt; 또는 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 대신</target>
        </trans-unit>
        <trans-unit id="b14f208baffea7d1c86f95f732b3ef39c695038a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;eprint!&lt;/code&gt; only for error and progress messages. Use &lt;code&gt;print!&lt;/code&gt; instead for the primary output of your program.</source>
          <target state="translated">&lt;code&gt;eprint!&lt;/code&gt; 사용하십시오 ! 오류 및 진행 메시지에만 해당됩니다. &lt;code&gt;print!&lt;/code&gt; 사용하십시오 ! 대신 프로그램의 기본 출력을 위해.</target>
        </trans-unit>
        <trans-unit id="22665c8a7bbb569c824fae1113f4c37d6c60b38a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;eprintln!&lt;/code&gt; only for error and progress messages. Use &lt;code&gt;println!&lt;/code&gt; instead for the primary output of your program.</source>
          <target state="translated">&lt;code&gt;eprintln!&lt;/code&gt; 사용하십시오 ! 오류 및 진행 메시지에만 해당됩니다. &lt;code&gt;println!&lt;/code&gt; 사용하십시오 ! 대신 프로그램의 기본 출력을 위해.</target>
        </trans-unit>
        <trans-unit id="c5580c57c536b501604c5a18501909570a4f8755" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;mod&lt;/code&gt; to create new &lt;a href=&quot;../reference/items/modules&quot;&gt;modules&lt;/a&gt; to encapsulate code, including other modules:</source>
          <target state="translated">사용 &lt;code&gt;mod&lt;/code&gt; 새로운 생성 &lt;a href=&quot;../reference/items/modules&quot;&gt;모듈을&lt;/a&gt; 다른 모듈을 포함하여 캡슐화 코드를 :</target>
        </trans-unit>
        <trans-unit id="2ead4795448020930657e9470aadfc30b6e379b7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;print!&lt;/code&gt; only for the primary output of your program. Use &lt;a href=&quot;macro.eprint&quot;&gt;&lt;code&gt;eprint!&lt;/code&gt;&lt;/a&gt; instead to print error and progress messages.</source>
          <target state="translated">&lt;code&gt;print!&lt;/code&gt; 사용하십시오 ! 프로그램의 기본 출력에만 해당됩니다. &lt;a href=&quot;macro.eprint&quot;&gt; &lt;code&gt;eprint!&lt;/code&gt; &lt;/a&gt; 사용하십시오 ! 대신 오류 및 진행 메시지를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="8622f52bbce3eafc5d53c96e1ec31dc91867c0d2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;println!&lt;/code&gt; only for the primary output of your program. Use &lt;a href=&quot;macro.eprintln&quot;&gt;&lt;code&gt;eprintln!&lt;/code&gt;&lt;/a&gt; instead to print error and progress messages.</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; 사용하십시오 ! 프로그램의 기본 출력에만 해당됩니다. &lt;a href=&quot;macro.eprintln&quot;&gt; &lt;code&gt;eprintln!&lt;/code&gt; &lt;/a&gt; 사용하십시오 ! 대신 오류 및 진행 메시지를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="4a325d56085ed8734f6810e0ff71ad595b95fd50" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;BTreeMap&lt;/code&gt; when:</source>
          <target state="translated">다음과 &lt;code&gt;BTreeMap&lt;/code&gt; 경우 BTreeMap을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5b8b83e450ccf5b057f6e9cdd558c50e56abe87" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;BinaryHeap&lt;/code&gt; when:</source>
          <target state="translated">다음과 같은 경우 &lt;code&gt;BinaryHeap&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c44210c4cd02de7b469e04353c99013251f0bdb6" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;HashMap&lt;/code&gt; when:</source>
          <target state="translated">다음과 같은 경우 &lt;code&gt;HashMap&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="461b6ce24b45cd8f2525e7819f63e5f3b7e5d4c8" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;LinkedList&lt;/code&gt; when:</source>
          <target state="translated">다음과 같은 경우 &lt;code&gt;LinkedList&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8effe57e9b8b3183f9d4a4c43ec54816a50215a" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; as an efficient stack:</source>
          <target state="translated">효율적인 스택으로 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="18acad408e22b76af330889473712392d945f0e6" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;Vec&lt;/code&gt; when:</source>
          <target state="translated">다음과 같은 경우 &lt;code&gt;Vec&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="610593fe7c0408bbb0f35796499627c6f2245b92" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;VecDeque&lt;/code&gt; when:</source>
          <target state="translated">다음과 &lt;code&gt;VecDeque&lt;/code&gt; 경우 VecDeque를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="928e71deb9616cde37637c874eca1ef7178b77b4" translate="yes" xml:space="preserve">
          <source>Use a slice.</source>
          <target state="translated">슬라이스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="37c1eb662164587065262615f820c57ffe90b9ef" translate="yes" xml:space="preserve">
          <source>Use an array with a fixed length.</source>
          <target state="translated">길이가 고정 된 배열을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="aa019f3006a2c79cffd1cb8f757987c40c32ebd5" translate="yes" xml:space="preserve">
          <source>Use declarations</source>
          <target state="translated">선언 사용</target>
        </trans-unit>
        <trans-unit id="4285ed0690ab255637e0ac148f5c792cd6b8149b" translate="yes" xml:space="preserve">
          <source>Use declarations support a number of convenient shortcuts:</source>
          <target state="translated">사용 선언은 여러 가지 편리한 바로 가기를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1d940a95921bf352b68ae08ab069e2750541ca02" translate="yes" xml:space="preserve">
          <source>Use of a &lt;code&gt;str&lt;/code&gt; whose contents are not valid UTF-8 is undefined behavior.</source>
          <target state="translated">내용이 유효한 UTF-8이 아닌 &lt;code&gt;str&lt;/code&gt; 을 사용하는 것은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="d154502a3f5f6795f896efa6e13908d9370d8f9a" translate="yes" xml:space="preserve">
          <source>Use of generic parameters.</source>
          <target state="translated">일반 매개 변수 사용.</target>
        </trans-unit>
        <trans-unit id="5c5acc62e88ff47e84c111044c30c66db333ca88" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; syntax to write data to the standard output. See &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt; 사용하십시오 ! 표준 출력에 데이터를 쓰는 구문. 자세한 내용은 &lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2fbe9e80ba417914254163793e464ee62322f093" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ptr/fn.null_mut&quot;&gt;&lt;code&gt;null_mut&lt;/code&gt;&lt;/a&gt; functions to create null pointers, and the &lt;a href=&quot;primitive.pointer#method.is_null&quot;&gt;&lt;code&gt;is_null&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt; types to check for null. The &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt; types also define the &lt;a href=&quot;primitive.pointer#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt; method, for pointer math.</source>
          <target state="translated">사용 &lt;a href=&quot;ptr/fn.null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;ptr/fn.null_mut&quot;&gt; &lt;code&gt;null_mut&lt;/code&gt; &lt;/a&gt; 널 포인터 및 생성 기능을 &lt;a href=&quot;primitive.pointer#method.is_null&quot;&gt; &lt;code&gt;is_null&lt;/code&gt; &lt;/a&gt; 의 방법 &lt;code&gt;*const T&lt;/code&gt; 와 &lt;code&gt;*mut T&lt;/code&gt; 널 (null)를 확인하는 유형. &lt;code&gt;*const T&lt;/code&gt; 및 &lt;code&gt;*mut T&lt;/code&gt; 종류는 또한 정의 &lt;a href=&quot;primitive.pointer#method.offset&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt; 포인터 수학위한 방법.</target>
        </trans-unit>
        <trans-unit id="2e570be59fc7fd5ff7530405783a29f5828f0fe8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;Set&lt;/code&gt; variant of any of these &lt;code&gt;Map&lt;/code&gt;s when:</source>
          <target state="translated">다음 과 같은 경우 이러한 &lt;code&gt;Map&lt;/code&gt; 의 &lt;code&gt;Set&lt;/code&gt; 변형을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e80c04da83a86a4ecbf94ec7503d652753e12266" translate="yes" xml:space="preserve">
          <source>Use the code in Listing 12-1 to allow your &lt;code&gt;minigrep&lt;/code&gt; program to read any command line arguments passed to it and then collect the values into a vector.</source>
          <target state="translated">Listing 12-1의 코드를 사용하여 &lt;code&gt;minigrep&lt;/code&gt; 프로그램이 전달 된 명령 행 인수를 읽은 다음 값을 벡터로 수집하십시오.</target>
        </trans-unit>
        <trans-unit id="b7e242e19e576b066c1fbe08cfb0b75455ae8cac" translate="yes" xml:space="preserve">
          <source>Use the same lifetime requirement for both input and output values.</source>
          <target state="translated">입력 및 출력 값 모두에 대해 동일한 수명 요구 사항을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="45a96fe96ad1c2ec9146b51dd14fea6aa97e8389" translate="yes" xml:space="preserve">
          <source>Use this function only when you can prove that the code will never call it. Otherwise, consider using the &lt;a href=&quot;../macro.unreachable&quot;&gt;&lt;code&gt;unreachable!&lt;/code&gt;&lt;/a&gt; macro, which does not allow optimizations but will panic when executed.</source>
          <target state="translated">이 함수는 코드가이를 호출하지 않음을 증명할 수있는 경우에만 사용하십시오. 그렇지 않으면 &lt;a href=&quot;../macro.unreachable&quot;&gt; &lt;code&gt;unreachable!&lt;/code&gt; &lt;/a&gt; 사용해보십시오 ! 매크로는 최적화를 허용하지 않지만 실행되면 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="d6a3c9f03120ec47a98d4a452b1e2127aae8581a" translate="yes" xml:space="preserve">
          <source>Used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeFull&lt;/code&gt; produces the full array as a slice.</source>
          <target state="translated">A와 사용 &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;슬라이스 지수&lt;/a&gt; , &lt;code&gt;RangeFull&lt;/code&gt; 은 슬라이스로 전체 배열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0ee0968c281548e8c4956da0bb80d17ce6a46d94" translate="yes" xml:space="preserve">
          <source>Used for immutable dereferencing operations, like &lt;code&gt;*v&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*v&lt;/code&gt; 와 같은 불변의 역 참조 작업에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a4b9aeea072b24e3f199cbe699727a85aca473bd" translate="yes" xml:space="preserve">
          <source>Used for indexing operations (&lt;code&gt;container[index]&lt;/code&gt;) in immutable contexts.</source>
          <target state="translated">변경할 수없는 컨텍스트에서 인덱싱 작업 ( &lt;code&gt;container[index]&lt;/code&gt; )에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6a6db850fe7a0893deca48224e890877525cf009" translate="yes" xml:space="preserve">
          <source>Used for indexing operations (&lt;code&gt;container[index]&lt;/code&gt;) in mutable contexts.</source>
          <target state="translated">가변 컨텍스트에서 인덱싱 작업 ( &lt;code&gt;container[index]&lt;/code&gt; )에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b8ea53757bb98a6b5189506b4ea7e3a3e9a3ec16" translate="yes" xml:space="preserve">
          <source>Used for mutable dereferencing operations, like in &lt;code&gt;*v = 1;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*v = 1;&lt;/code&gt; 과 같이 변경 가능한 역 참조 작업에 사용됩니다 . .</target>
        </trans-unit>
        <trans-unit id="0fe043543944b7d7b206d45160cd5299a8af93e5" translate="yes" xml:space="preserve">
          <source>Used to create a default &lt;a href=&quot;trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; instance for types that implement &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 만드는 데 사용 &lt;a href=&quot;trait.buildhasher&quot;&gt; &lt;code&gt;BuildHasher&lt;/code&gt; 의&lt;/a&gt; 구현 유형에 대한 예를 &lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e28b1efed767d7b3e60d0a7700706d6642dda67" translate="yes" xml:space="preserve">
          <source>Used to do a cheap mutable-to-mutable reference conversion.</source>
          <target state="translated">저렴한 가변-변동 가능한 기준 변환을 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f1b7626a3b6465a294975154f6e043096ec5995f" translate="yes" xml:space="preserve">
          <source>Used to do a cheap reference-to-reference conversion.</source>
          <target state="translated">저렴한 참조 대 참조 변환을 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="14c0b7ffa101db42d6f394a0ed0a2a772e18316c" translate="yes" xml:space="preserve">
          <source>Used to do value-to-value conversions while consuming the input value. It is the reciprocal of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">입력 값을 소비하면서 값을 값으로 변환하는 데 사용됩니다. &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 의 역수입니다 .</target>
        </trans-unit>
        <trans-unit id="87832790df189d88ca8070bb6de895ef1d392b7c" translate="yes" xml:space="preserve">
          <source>Used to make try_fold closures more like normal loops</source>
          <target state="translated">try_fold 클로저를 일반 루프처럼 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3e26b00e1661d4c5dea648883f63653b80651f39" translate="yes" xml:space="preserve">
          <source>Used to run some code when a value goes out of scope. This is sometimes called a 'destructor'.</source>
          <target state="translated">값이 범위를 벗어날 때 일부 코드를 실행하는 데 사용됩니다. 이것을 '소멸자'라고도합니다.</target>
        </trans-unit>
        <trans-unit id="5dc9662fcc8a7efba76268741a2aa91414af229f" translate="yes" xml:space="preserve">
          <source>Useful synchronization primitives.</source>
          <target state="translated">유용한 동기화 프리미티브.</target>
        </trans-unit>
        <trans-unit id="b05cb9060bef7e9cf540890d5647fd3ffbac6f9d" translate="yes" xml:space="preserve">
          <source>User lacks permissions to create directory at &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 에 디렉토리를 만들 수있는 권한이 사용자에게 없습니다 .</target>
        </trans-unit>
        <trans-unit id="01ed5872aedec24d23d900d1581e6ff53ed21665" translate="yes" xml:space="preserve">
          <source>User-defined types:</source>
          <target state="translated">사용자 정의 유형 :</target>
        </trans-unit>
        <trans-unit id="62be4731dedfbbc70aa7fa30d6649d816af8ca4b" translate="yes" xml:space="preserve">
          <source>Uses</source>
          <target state="translated">Uses</target>
        </trans-unit>
        <trans-unit id="55cf66299b4b2f9f7eb9ea6abdf809a42de50634" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning.</source>
          <target state="translated">빌린 데이터를 사용하여 일반적으로 복제하여 소유 한 데이터를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="01c085ac9a4eda7ad0e1fc8b863d1b23ac3713d3" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;../../../borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">빌린 데이터를 사용하여 일반적으로 복제하여 소유 한 데이터를 대체합니다. &lt;a href=&quot;../../../borrow/trait.toowned#method.clone_into&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1a7e308c9ce8c72dc79594fe592d8ac0e474a60" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;../../borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">빌린 데이터를 사용하여 일반적으로 복제하여 소유 한 데이터를 대체합니다. &lt;a href=&quot;../../borrow/trait.toowned#method.clone_into&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="41f5a93c96209d01bd88a54a350a97a8859d2caf" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;../borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">빌린 데이터를 사용하여 일반적으로 복제하여 소유 한 데이터를 대체합니다. &lt;a href=&quot;../borrow/trait.toowned#method.clone_into&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="527bd4367972a752863741d60fd99d8435d00fca" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;borrow/trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">빌린 데이터를 사용하여 일반적으로 복제하여 소유 한 데이터를 대체합니다. &lt;a href=&quot;borrow/trait.toowned#method.clone_into&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb87bc230d96c818f8f39be65a97f0f0c56ca879" translate="yes" xml:space="preserve">
          <source>Uses borrowed data to replace owned data, usually by cloning. &lt;a href=&quot;trait.toowned#method.clone_into&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">빌린 데이터를 사용하여 일반적으로 복제하여 소유 한 데이터를 대체합니다. &lt;a href=&quot;trait.toowned#method.clone_into&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e92ce0c09d5d2c377945a784545c389cc7e9354" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;../std/ptr/fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;std::ptr::copy_nonoverlapping_memory&lt;/code&gt;&lt;/a&gt;, a.k.a. the &lt;code&gt;memcpy32&lt;/code&gt;and &lt;code&gt;memcpy64&lt;/code&gt; intrinsics, on overlapping buffers.</source>
          <target state="translated">겹치는 버퍼에서 &lt;a href=&quot;../std/ptr/fn.copy_nonoverlapping&quot;&gt; &lt;code&gt;std::ptr::copy_nonoverlapping_memory&lt;/code&gt; &lt;/a&gt; 사용 하여 &lt;code&gt;memcpy32&lt;/code&gt; 및 &lt;code&gt;memcpy64&lt;/code&gt; 내장 함수라고합니다.</target>
        </trans-unit>
        <trans-unit id="6e1dcc3d8137ddd7e3681f9bc104f285826b7f48" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; as success ordering makes the store part of this operation &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt;, and using &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; makes the final successful load &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt;. The (failed) load ordering can only be &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; and must be equivalent to or weaker than the success ordering.</source>
          <target state="translated">사용하여 &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 성공 주문이 작업의 저장 부분을 만들면서 &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; , 그리고 사용 &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; 최종 성공적으로로드하게 &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt; . (실패한)로드 순서는 &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; 일&lt;/a&gt; 수 있으며 성공 순서와 같거나 약해야합니다.</target>
        </trans-unit>
        <trans-unit id="7a6e8bfcb648c037a665b572caa617368582e79d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;Iterator::collect()&lt;/code&gt;&lt;/a&gt; to implicitly use &lt;code&gt;FromIterator&lt;/code&gt;:</source>
          <target state="translated">사용 &lt;a href=&quot;trait.iterator#method.collect&quot;&gt; &lt;code&gt;Iterator::collect()&lt;/code&gt; &lt;/a&gt; 암시 적으로 사용하는 &lt;code&gt;FromIterator&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="f6057ce3700db1903febbd4571a9030f98dccb52" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; to implicitly use &lt;code&gt;FromIterator&lt;/code&gt;:</source>
          <target state="translated">사용 &lt;a href=&quot;trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt; 암시 적으로 사용하는 &lt;code&gt;FromIterator&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="b8581b668b89dc42d1d55734cab92752391e678b" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-boxt-like-a-reference&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; Like a Reference</source>
          <target state="translated">&lt;code id=&quot;using-boxt-like-a-reference&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 를 참조처럼 사용</target>
        </trans-unit>
        <trans-unit id="2786f97dc365e66bda997868734cec33ef9fcf92" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-boxt-to-get-a-recursive-type-with-a-known-size&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to Get a Recursive Type with a Known Size</source>
          <target state="translated">알려진 크기의 재귀 유형을 얻기 위해 &lt;code id=&quot;using-boxt-to-get-a-recursive-type-with-a-known-size&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="8300c99c1ff66e26c9f9b017e5522a93d571ce81" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-boxt-to-point-to-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to Point to Data on the Heap</source>
          <target state="translated">&lt;code id=&quot;using-boxt-to-point-to-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용 하여 힙의 데이터를 가리킴</target>
        </trans-unit>
        <trans-unit id="c4104bedba70839a84674c526e20638655c760d0" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-extern-functions-to-call-external-code&quot;&gt;extern&lt;/code&gt; Functions to Call External Code</source>
          <target state="translated">&lt;code id=&quot;using-extern-functions-to-call-external-code&quot;&gt;extern&lt;/code&gt; 함수를 사용하여 외부 코드 호출</target>
        </trans-unit>
        <trans-unit id="39a61fb39b0b2c2b47e27003fb9ca80ee4d7ca24" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-if-in-a-let-statement&quot;&gt;if&lt;/code&gt; in a &lt;code&gt;let&lt;/code&gt; Statement</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 문 에서 &lt;code id=&quot;using-if-in-a-let-statement&quot;&gt;if&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="17f21cd4682f3498e05d46c9ba5f0db1ecf73ca1" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-iterator-trait-methods-instead-of-indexing&quot;&gt;Iterator&lt;/code&gt; Trait Methods Instead of Indexing</source>
          <target state="translated">인덱싱 대신 &lt;code id=&quot;using-iterator-trait-methods-instead-of-indexing&quot;&gt;Iterator&lt;/code&gt; 특성 방법 사용</target>
        </trans-unit>
        <trans-unit id="cd4dbe3102cc8a86458c21a6edcf0745a3880b2c" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-move-closures-with-threads&quot;&gt;move&lt;/code&gt; Closures with Threads</source>
          <target state="translated">스레드와 함께 &lt;code id=&quot;using-move-closures-with-threads&quot;&gt;move&lt;/code&gt; 클로저 사용</target>
        </trans-unit>
        <trans-unit id="bcb24e74610f11ffcd8b36fc02251143626de877" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-rct-to-share-data&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to Share Data</source>
          <target state="translated">&lt;code id=&quot;using-rct-to-share-data&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용하여 데이터 공유</target>
        </trans-unit>
        <trans-unit id="4bedcde0cd8963bedfb716621a284a40e61ba006" translate="yes" xml:space="preserve">
          <source>Using &lt;code id=&quot;using-resultt-e-in-tests&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; in Tests</source>
          <target state="translated">테스트에서 &lt;code id=&quot;using-resultt-e-in-tests&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="5d4e8a0abd2628d1463a51e66037adf55b78b3eb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;#[repr(C)]&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;#[repr(C)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfc71d2f097570894eba309d1d3e23fc1440f195" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; where the right-hand argument is greater than or equal to the number of bits in the type of the left-hand argument, or is negative.</source>
          <target state="translated">오른쪽 인수가 왼쪽 인수 유형의 비트 수보다 크거나 같은 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 사용 또는 음수.</target>
        </trans-unit>
        <trans-unit id="b645209e67cee4f9f92c20f0e033dab698fba2f2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt;, where the left-hand argument is the smallest integer of a signed integer type and the right-hand argument is &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;/&lt;/code&gt; 또는 &lt;code&gt;%&lt;/code&gt; 왼쪽의 인수가 부호있는 정수 타입과 오른쪽 인수의 가장 작은 정수입니다 &lt;code&gt;-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d0998ec9f168a2eeef48fd713f566a42f1d1993" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;@&lt;/code&gt; lets us test a value and save it in a variable within one pattern.</source>
          <target state="translated">사용 &lt;code&gt;@&lt;/code&gt; 우리가 값을 테스트하고 하나 개의 패턴 내에서 변수에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ae9824a370d1fed45ea9444f749e0c2d3a71823" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;AsMut&lt;/code&gt; as trait bound for a generic function we can accept all mutable references that can be converted to type &lt;code&gt;&amp;amp;mut T&lt;/code&gt;. Because &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt; we can write a function &lt;code&gt;add_one&lt;/code&gt; that takes all arguments that can be converted to &lt;code&gt;&amp;amp;mut u64&lt;/code&gt;. Because &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;add_one&lt;/code&gt; accepts arguments of type &lt;code&gt;&amp;amp;mut Box&amp;lt;u64&amp;gt;&lt;/code&gt; as well:</source>
          <target state="translated">일반 함수에 대한 특성 바인딩으로 &lt;code&gt;AsMut&lt;/code&gt; 을 사용하여 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 유형으로 변환 할 수있는 모든 가변 참조를 허용 할 수 있습니다 . 때문에 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 구현 &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt; 우리는 함수를 작성할 수 있습니다 &lt;code&gt;add_one&lt;/code&gt; 로 변환 할 수있는 모든 인수를 취 &lt;code&gt;&amp;amp;mut u64&lt;/code&gt; . 때문에 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 구현 &lt;code&gt;AsMut&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;add_one&lt;/code&gt; 이 형의 인수를 받아 &lt;code&gt;&amp;amp;mut Box&amp;lt;u64&amp;gt;&lt;/code&gt; 뿐만 아니라 :</target>
        </trans-unit>
        <trans-unit id="e5f61609aec29d1aa58bf125645b7b8bf1c8648b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;BuildHasherDefault&lt;/code&gt; to specify a custom &lt;a href=&quot;trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">사용 &lt;code&gt;BuildHasherDefault&lt;/code&gt; 을 사용자 정의 지정 &lt;a href=&quot;trait.buildhasher&quot;&gt; &lt;code&gt;BuildHasher&lt;/code&gt; &lt;/a&gt; 에 대한 &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="741ce1478263e946f77de5614872f7257f7d9bd0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;TcpListener&lt;/code&gt;, we can listen for TCP connections at the address &lt;code&gt;127.0.0.1:7878&lt;/code&gt;. In the address, the section before the colon is an IP address representing your computer (this is the same on every computer and doesn&amp;rsquo;t represent the authors&amp;rsquo; computer specifically), and &lt;code&gt;7878&lt;/code&gt; is the port. We&amp;rsquo;ve chosen this port for two reasons: HTTP is normally accepted on this port, and 7878 is &lt;em&gt;rust&lt;/em&gt; typed on a telephone.</source>
          <target state="translated">&lt;code&gt;TcpListener&lt;/code&gt; 를 사용 하면 주소 &lt;code&gt;127.0.0.1:7878&lt;/code&gt; 에서 TCP 연결을 수신 할 수 있습니다 . 주소에서 콜론 앞의 섹션은 컴퓨터를 나타내는 IP 주소 (모든 컴퓨터에서 동일하며 작성자의 컴퓨터를 구체적으로 나타내지 않음)이며 &lt;code&gt;7878&lt;/code&gt; 은 포트입니다. 두 가지 이유로이 포트를 선택했습니다. HTTP는 일반적으로이 포트에서 허용되며 7878은 전화기에 &lt;em&gt;녹이&lt;/em&gt; 슬게 입력됩니다.</target>
        </trans-unit>
        <trans-unit id="9d282af0a0db5a0f3935d90926c6551a24490d56" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;cargo&lt;/code&gt;, Rust&amp;rsquo;s package manager and build system</source>
          <target state="translated">Rust의 패키지 관리자 및 빌드 시스템 인 &lt;code&gt;cargo&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="063f2ebb8c76224924321e7e9857525474aed57a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;collect()&lt;/code&gt; to make a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">사용 &lt;code&gt;collect()&lt;/code&gt; a를하는 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="781d7dd79f196f5deffe456d6e4de88c8628e79c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;env::join_paths()&lt;/code&gt; with &lt;a href=&quot;fn.split_paths&quot;&gt;&lt;code&gt;env::split_paths()&lt;/code&gt;&lt;/a&gt; to append an item to the &lt;code&gt;PATH&lt;/code&gt; environment variable:</source>
          <target state="translated">사용 &lt;code&gt;env::join_paths()&lt;/code&gt; 와 &lt;a href=&quot;fn.split_paths&quot;&gt; &lt;code&gt;env::split_paths()&lt;/code&gt; &lt;/a&gt; 받는 항목을 추가하는 &lt;code&gt;PATH&lt;/code&gt; 의 환경 변수를 :</target>
        </trans-unit>
        <trans-unit id="efb72794ee8412b2ec8c4ed130b77aa3fe94a4cc" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;env::join_paths&lt;/code&gt; with &lt;a href=&quot;fn.split_paths&quot;&gt;&lt;code&gt;env::split_paths&lt;/code&gt;&lt;/a&gt; to append an item to the &lt;code&gt;PATH&lt;/code&gt; environment variable:</source>
          <target state="translated">사용 &lt;code&gt;env::join_paths&lt;/code&gt; 함께 &lt;a href=&quot;fn.split_paths&quot;&gt; &lt;code&gt;env::split_paths&lt;/code&gt; &lt;/a&gt; 받는 항목을 추가하려면 &lt;code&gt;PATH&lt;/code&gt; 의 환경 변수를 :</target>
        </trans-unit>
        <trans-unit id="883e296f0933a9796d7609478617eb9fc57e41d8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; as a &quot;do nothing&quot; base case in a conditional:</source>
          <target state="translated">조건부에서 &quot;아무것도하지 않는&quot;기본 케이스로 &lt;code&gt;identity&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="145643f8069cc90bb1d66393cde6c665263c5694" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to do nothing among other interesting functions:</source>
          <target state="translated">다른 흥미로운 기능들 중에서 아무것도하지 않기 위해 &lt;code&gt;identity&lt;/code&gt; 사용 하기 :</target>
        </trans-unit>
        <trans-unit id="f1235a5ac3f06cf39c5a154506b55894e72fe10a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to do nothing in a sequence of other, interesting, functions:</source>
          <target state="translated">&lt;code&gt;identity&lt;/code&gt; 를 사용하여 다른 흥미로운 기능 시퀀스에서 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0c92b7b9d3a5d2fd97452ae43966326ca17955c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to get a function that changes nothing in a conditional:</source>
          <target state="translated">조건부에서 아무것도 변경하지 않는 함수를 얻기 위해 &lt;code&gt;identity&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="8a03c63b02cfcec88b468a3f0a4f356859de8742" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;identity&lt;/code&gt; to keep the &lt;code&gt;Some&lt;/code&gt; variants of an iterator of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">사용 &lt;code&gt;identity&lt;/code&gt; 유지하기 위해 &lt;code&gt;Some&lt;/code&gt; 의 반복자 변종 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b86b145b4aec4479f3e7888989e9c6f53ce3db7d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;if let&lt;/code&gt; means less typing, less indentation, and less boilerplate code. However, you lose the exhaustive checking that &lt;code&gt;match&lt;/code&gt; enforces. Choosing between &lt;code&gt;match&lt;/code&gt; and &lt;code&gt;if let&lt;/code&gt; depends on what you&amp;rsquo;re doing in your particular situation and whether gaining conciseness is an appropriate trade-off for losing exhaustive checking.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 을 사용 하면 타이핑이 적고 들여 쓰기가 적고 상용구 코드가 줄어 듭니다. 그러나 &lt;code&gt;match&lt;/code&gt; 하는 철저한 검사를 잃게됩니다 . &lt;code&gt;match&lt;/code&gt; 와 &lt;code&gt;if let&lt;/code&gt; 사이의 선택은 특정 상황에서 무엇을하고 있는지와 간결성을 얻는 것이 철저한 검사를 잃는 데 적절한 절충인지에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b98e766b3b912d79bb4b0c519c379c12d658619" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;match&lt;/code&gt; works well enough, but it can be a bit verbose and doesn&amp;rsquo;t always communicate intent well. The &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type has many helper methods defined on it to do various tasks. One of those methods, called &lt;code&gt;unwrap&lt;/code&gt;, is a shortcut method that is implemented just like the &lt;code&gt;match&lt;/code&gt; expression we wrote in Listing 9-4. If the &lt;code&gt;Result&lt;/code&gt; value is the &lt;code&gt;Ok&lt;/code&gt; variant, &lt;code&gt;unwrap&lt;/code&gt; will return the value inside the &lt;code&gt;Ok&lt;/code&gt;. If the &lt;code&gt;Result&lt;/code&gt; is the &lt;code&gt;Err&lt;/code&gt; variant, &lt;code&gt;unwrap&lt;/code&gt; will call the &lt;code&gt;panic!&lt;/code&gt; macro for us. Here is an example of &lt;code&gt;unwrap&lt;/code&gt; in action:</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 사용하면 충분하지만 조금 장황 할 수 있으며 항상 의도를 잘 전달하지는 않습니다. &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 형태는 다양한 작업을 수행하는 데에 정의 된 많은 헬퍼 메소드가 있습니다. &lt;code&gt;unwrap&lt;/code&gt; 이라는 메소드 중 하나는 Listing 9-4에서 작성한 &lt;code&gt;match&lt;/code&gt; 표현식 과 같이 구현되는 단축 메소드이다 . 경우 &lt;code&gt;Result&lt;/code&gt; 값이입니다 &lt;code&gt;Ok&lt;/code&gt; 변형, &lt;code&gt;unwrap&lt;/code&gt; 내부 값을 반환합니다 &lt;code&gt;Ok&lt;/code&gt; . 는 IF &lt;code&gt;Result&lt;/code&gt; 는 IS &lt;code&gt;Err&lt;/code&gt; 변형, &lt;code&gt;unwrap&lt;/code&gt; 부르는 것 &lt;code&gt;panic!&lt;/code&gt; 우리를 위해 매크로. 다음은 &lt;code&gt;unwrap&lt;/code&gt; 실제 예입니다 .</target>
        </trans-unit>
        <trans-unit id="716d3b2c36a0e8f26b1196bb5c8509c4d656cdaa" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;mul_add&lt;/code&gt; can be more performant than an unfused multiply-add if the target architecture has a dedicated &lt;code&gt;fma&lt;/code&gt; CPU instruction.</source>
          <target state="translated">대상 아키텍처에 전용 &lt;code&gt;fma&lt;/code&gt; CPU 명령어 가있는 경우 &lt;code&gt;mul_add&lt;/code&gt; 를 사용 하면 융합되지 않은 곱하기 추가보다 성능이 우수 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1150ca9c0c5f9cb7d33fb3908d78558b0edfddac" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;mul_add&lt;/code&gt;&lt;em&gt;may&lt;/em&gt; be more performant than an unfused multiply-add if the target architecture has a dedicated &lt;code&gt;fma&lt;/code&gt; CPU instruction. However, this is not always true, and will be heavily dependant on designing algorithms with specific target hardware in mind.</source>
          <target state="translated">대상 아키텍처에 전용 &lt;code&gt;fma&lt;/code&gt; CPU 명령 이있는 경우 &lt;code&gt;mul_add&lt;/code&gt; 를 사용 하는 것이 통합되지 않은 곱하기 더하기보다 성능이 더 우수 &lt;em&gt;할 수&lt;/em&gt; 있습니다 . 그러나 이것은 항상 사실이 아니며 특정 대상 하드웨어를 염두에두고 알고리즘을 설계하는 데 크게 의존합니다.</target>
        </trans-unit>
        <trans-unit id="b8c91e11b4f888f4c592a35e44ac17004a0fb755" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;println!&lt;/code&gt; directly:</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; 사용 ! 직접:</target>
        </trans-unit>
        <trans-unit id="4e19595061858aceb197932ab33548b4e2d9024e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;to_string&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;to_string&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="9355d5eaee5786ccc5834b09b61c0a558e231c8f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;unsafe {}&lt;/code&gt; blocks and &lt;code&gt;impl&lt;/code&gt;s</source>
          <target state="translated">사용 &lt;code&gt;unsafe {}&lt;/code&gt; 블록 및 &lt;code&gt;impl&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="ddd1e2fb0a495ca1deedb73f663b2b41b48287c3" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;unsafe&lt;/code&gt; to take one of the five actions (superpowers) just discussed isn&amp;rsquo;t wrong or even frowned upon. But it is trickier to get &lt;code&gt;unsafe&lt;/code&gt; code correct because the compiler can&amp;rsquo;t help uphold memory safety. When you have a reason to use &lt;code&gt;unsafe&lt;/code&gt; code, you can do so, and having the explicit &lt;code&gt;unsafe&lt;/code&gt; annotation makes it easier to track down the source of problems when they occur.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 것을 사용하여 방금 논의한 다섯 가지 행동 (초강대국) 중 하나를 취하는 것은 잘못되거나 눈살을 찌푸리는 일이 아닙니다. 그러나 컴파일러가 메모리 안전을 유지하는 데 도움이되지 않기 때문에 &lt;code&gt;unsafe&lt;/code&gt; 코드를 수정 하는 것이 더 까다 롭습니다 . &lt;code&gt;unsafe&lt;/code&gt; 코드 를 사용할 이유가있을 때 그렇게 할 수 있으며 명시적인 &lt;code&gt;unsafe&lt;/code&gt; 주석을 사용하면 문제 발생시 문제의 원인을 쉽게 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23e77887900c6717f9133b9abc150eed86948327" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;unsafe&lt;/code&gt; to take one of the four actions (superpowers) just discussed isn&amp;rsquo;t wrong or even frowned upon. But it is trickier to get &lt;code&gt;unsafe&lt;/code&gt; code correct because the compiler can&amp;rsquo;t help uphold memory safety. When you have a reason to use &lt;code&gt;unsafe&lt;/code&gt; code, you can do so, and having the explicit &lt;code&gt;unsafe&lt;/code&gt; annotation makes it easier to track down the source of problems if they occur.</source>
          <target state="translated">방금 논의한 네 가지 행동 (초강대국) 중 하나를 수행하기 위해 &lt;code&gt;unsafe&lt;/code&gt; 것을 사용하는 것은 잘못되거나 눈살을 찌푸 리지도 않습니다. 그러나 컴파일러가 메모리 안전을 유지하는 데 도움을 줄 수 없으므로 &lt;code&gt;unsafe&lt;/code&gt; 코드를 올바르게 작성 하는 것이 더 까다 롭습니다 . &lt;code&gt;unsafe&lt;/code&gt; 코드 를 사용해야하는 이유가 있을 경우 그렇게 할 수 있으며 명시적인 &lt;code&gt;unsafe&lt;/code&gt; 주석을 사용하면 문제의 원인을 쉽게 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="079ef6902b572fab1f5b45933254dfd23aa7b9b5" translate="yes" xml:space="preserve">
          <source>Using Closures that Capture Their Environment</source>
          <target state="translated">환경을 캡처하는 클로저 사용</target>
        </trans-unit>
        <trans-unit id="356483451b80563e823eec07c158f3c0e2a19756" translate="yes" xml:space="preserve">
          <source>Using External Packages</source>
          <target state="translated">외부 패키지 사용</target>
        </trans-unit>
        <trans-unit id="195ec6c54d68d4bc74c1c0e9e4aa71e8ed1d66dc" translate="yes" xml:space="preserve">
          <source>Using Message Passing to Transfer Data Between Threads</source>
          <target state="translated">메시지 전달을 사용하여 스레드간에 데이터 전송</target>
        </trans-unit>
        <trans-unit id="1f1119d00f411f28a788c634b094f7830af90354" translate="yes" xml:space="preserve">
          <source>Using Mutexes to Allow Access to Data from One Thread at a Time</source>
          <target state="translated">뮤텍스를 사용하여 한 번에 하나의 스레드에서 데이터에 액세스 할 수 있도록 허용</target>
        </trans-unit>
        <trans-unit id="0f71d9d6c5e4eb6b3d84f4f1645f9d37c7834e08" translate="yes" xml:space="preserve">
          <source>Using Nested Paths to Clean Up Large &lt;code id=&quot;using-nested-paths-to-clean-up-large-use-lists&quot;&gt;use&lt;/code&gt; Lists</source>
          <target state="translated">중첩 된 경로를 사용하여 대규모 &lt;code id=&quot;using-nested-paths-to-clean-up-large-use-lists&quot;&gt;use&lt;/code&gt; 목록 정리</target>
        </trans-unit>
        <trans-unit id="d061dfad64af5ced98da4099941d9962a4cf4ab6" translate="yes" xml:space="preserve">
          <source>Using Other &lt;code id=&quot;using-other-iterator-trait-methods&quot;&gt;Iterator&lt;/code&gt; Trait Methods</source>
          <target state="translated">다른 &lt;code id=&quot;using-other-iterator-trait-methods&quot;&gt;Iterator&lt;/code&gt; 특성 방법 사용</target>
        </trans-unit>
        <trans-unit id="90caab8414681ad380cd72175835d7d3a714a974" translate="yes" xml:space="preserve">
          <source>Using Our &lt;code id=&quot;using-our-counter-iterators-next-method&quot;&gt;Counter&lt;/code&gt; Iterator&amp;rsquo;s &lt;code&gt;next&lt;/code&gt; Method</source>
          <target state="translated">우리의 사용 &lt;code id=&quot;using-our-counter-iterators-next-method&quot;&gt;Counter&lt;/code&gt; 반복자의 &lt;code&gt;next&lt;/code&gt; 방법을</target>
        </trans-unit>
        <trans-unit id="4a36ca6063affef138895d5e70695435940c7941" translate="yes" xml:space="preserve">
          <source>Using Statics or Consts</source>
          <target state="translated">정적 또는 상수 사용</target>
        </trans-unit>
        <trans-unit id="1d80a86fe9446545a29df6fe583694b8305fad7f" translate="yes" xml:space="preserve">
          <source>Using Structs to Structure Related Data</source>
          <target state="translated">구조를 사용하여 관련 데이터 구조화</target>
        </trans-unit>
        <trans-unit id="1725c7720c6951cb5321da47bdec76e1efb5b498" translate="yes" xml:space="preserve">
          <source>Using Supertraits to Require One Trait&amp;rsquo;s Functionality Within Another Trait</source>
          <target state="translated">다른 특성 내에서 한 특성의 기능을 요구하기 위해 상위 특성 사용</target>
        </trans-unit>
        <trans-unit id="e5f7eb8898bb60910740832d2142728eab94b626" translate="yes" xml:space="preserve">
          <source>Using Threads to Run Code Simultaneously</source>
          <target state="translated">스레드를 사용하여 코드를 동시에 실행</target>
        </trans-unit>
        <trans-unit id="9c88360016895ec6069e43a4e277e7bdb51ba9ed" translate="yes" xml:space="preserve">
          <source>Using Trait Bounds to Conditionally Implement Methods</source>
          <target state="translated">특성 바인드를 사용하여 조건부로 메소드 구현</target>
        </trans-unit>
        <trans-unit id="b4544e80831327296977b0f0c1bed06cd890a1fd" translate="yes" xml:space="preserve">
          <source>Using Trait Objects That Allow for Values of Different Types</source>
          <target state="translated">다른 유형의 값을 허용하는 특성 객체 사용</target>
        </trans-unit>
        <trans-unit id="735958a37951062c949a84a063e5b1d398369b00" translate="yes" xml:space="preserve">
          <source>Using Tuple Structs without Named Fields to Create Different Types</source>
          <target state="translated">명명 된 필드없이 튜플 구조를 사용하여 다른 유형 만들기</target>
        </trans-unit>
        <trans-unit id="675231858eb84206141ae12e664714cc21d2c19b" translate="yes" xml:space="preserve">
          <source>Using a &lt;code id=&quot;using-a-boxt-to-store-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to Store Data on the Heap</source>
          <target state="translated">&lt;code id=&quot;using-a-boxt-to-store-data-on-the-heap&quot;&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용 하여 힙에 데이터 저장</target>
        </trans-unit>
        <trans-unit id="f84a17c2b7b640800d3c95a6c6874936d40e4172" translate="yes" xml:space="preserve">
          <source>Using a &lt;code id=&quot;using-a-panic-backtrace&quot;&gt;panic!&lt;/code&gt; Backtrace</source>
          <target state="translated">사용 &lt;code id=&quot;using-a-panic-backtrace&quot;&gt;panic!&lt;/code&gt; 역 추적</target>
        </trans-unit>
        <trans-unit id="fa90ed41bcf90ab01a0c0386a65d7892a205380d" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;Fn&lt;/code&gt; parameter</source>
          <target state="translated">사용 &lt;code&gt;Fn&lt;/code&gt; 매개 변수를</target>
        </trans-unit>
        <trans-unit id="c233f257ce2f61e1743d09ba4202b368e77eac25" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;FnMut&lt;/code&gt; parameter</source>
          <target state="translated">사용 &lt;code&gt;FnMut&lt;/code&gt; 의 매개 변수를</target>
        </trans-unit>
        <trans-unit id="c47fce11968d69df2be1beb510ac309f7cc7fe1c" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;FnOnce&lt;/code&gt; parameter</source>
          <target state="translated">사용 &lt;code&gt;FnOnce&lt;/code&gt; 의 매개 변수를</target>
        </trans-unit>
        <trans-unit id="eaa2ddbdb2af4f1c7b600386f3ab5d07fb639266" translate="yes" xml:space="preserve">
          <source>Using a Crate to Get More Functionality</source>
          <target state="translated">상자를 사용하여 더 많은 기능 얻기</target>
        </trans-unit>
        <trans-unit id="5490ba3cbb37583be424e7381702b1ad23cc8d1f" translate="yes" xml:space="preserve">
          <source>Using a busy-wait spin-loop with &lt;code&gt;spin_loop&lt;/code&gt; is ideally used in situations where a contended lock is held by another thread executed on a different CPU and where the waiting times are relatively small. Because entering busy-wait spin-loop does not trigger the system's scheduler, no overhead for switching threads occurs. However, if the thread holding the contended lock is running on the same CPU, the spin-loop is likely to occupy an entire CPU slice before switching to the thread that holds the lock. If the contending lock is held by a thread on the same CPU or if the waiting times for acquiring the lock are longer, it is often better to use &lt;a href=&quot;../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 CPU에서 실행되는 다른 스레드에 의해 잠금이 유지되고 대기 시간이 비교적 &lt;code&gt;spin_loop&lt;/code&gt; 상황에서 spin_loop 과 함께 사용 중 대기 스핀 루프를 사용하는 것이 이상적입니다. busy-wait spin-loop를 입력해도 시스템 스케줄러가 트리거되지 않으므로 스레드 전환에 대한 오버 헤드가 발생하지 않습니다. 그러나 Content Lock을 보유한 스레드가 동일한 CPU에서 실행중인 경우, 잠금 루프를 보유한 스레드로 전환하기 전에 스핀 루프가 전체 CPU 슬라이스를 차지할 수 있습니다. 경합 잠금이 동일한 CPU의 스레드에 의해 유지되거나 잠금 획득 대기 시간이 더 길면 &lt;a href=&quot;../thread/fn.yield_now&quot;&gt; &lt;code&gt;std::thread::yield_now&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4c1ce34ae6a3ca80d5e3bf4a0b0c41abaf191eae" translate="yes" xml:space="preserve">
          <source>Using a busy-wait spin-loop with &lt;code&gt;spin_loop_hint&lt;/code&gt; is ideally used in situations where a contended lock is held by another thread executed on a different CPU and where the waiting times are relatively small. Because entering busy-wait spin-loop does not trigger the system's scheduler, no overhead for switching threads occurs. However, if the thread holding the contended lock is running on the same CPU, the spin-loop is likely to occupy an entire CPU slice before switching to the thread that holds the lock. If the contending lock is held by a thread on the same CPU or if the waiting times for acquiring the lock are longer, it is often better to use &lt;a href=&quot;../../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;spin_loop_hint&lt;/code&gt; 와 함께 사용 중 대기 스핀 루프를 사용하면 다른 CPU에서 실행되는 다른 스레드가 컨 텐션 된 잠금을 유지하고 대기 시간이 비교적 짧은 경우 에 이상적으로 사용됩니다. busy-wait spin-loop를 입력해도 시스템 스케줄러가 트리거되지 않으므로 스레드 전환에 대한 오버 헤드가 발생하지 않습니다. 그러나 Content Lock을 보유한 스레드가 동일한 CPU에서 실행중인 경우, 잠금 루프를 보유한 스레드로 전환하기 전에 스핀 루프가 전체 CPU 슬라이스를 차지할 수 있습니다. 경합 잠금이 동일한 CPU의 스레드에 의해 유지되거나 잠금 획득 대기 시간이 더 길면 &lt;a href=&quot;../../thread/fn.yield_now&quot;&gt; &lt;code&gt;std::thread::yield_now&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3b1ac01f9a3840dc6d78887aac134760ed5ceafe" translate="yes" xml:space="preserve">
          <source>Using a hash map and vectors, create a text interface to allow a user to add employee names to a department in a company. For example, &amp;ldquo;Add Sally to Engineering&amp;rdquo; or &amp;ldquo;Add Amir to Sales.&amp;rdquo; Then let the user retrieve a list of all people in a department or all people in the company by department, sorted alphabetically.</source>
          <target state="translated">해시 맵과 벡터를 사용하여 사용자가 회사의 부서에 직원 이름을 추가 할 수있는 텍스트 인터페이스를 작성하십시오. 예를 들어 &quot;엔지니어링에 Sally 추가&quot;또는 &quot;판매에 Amir 추가&quot;가 있습니다. 그런 다음 사용자가 부서의 모든 사람 또는 회사의 모든 사람들의 목록을 알파벳순으로 검색하도록합니다.</target>
        </trans-unit>
        <trans-unit id="09dacd7c78dbd0bf44dabf88b33b52973a393ac8" translate="yes" xml:space="preserve">
          <source>Using a primitive representation in addition to &lt;code&gt;repr(C)&lt;/code&gt; can change the size of an enum from the &lt;code&gt;repr(C)&lt;/code&gt; form:</source>
          <target state="translated">&lt;code&gt;repr(C)&lt;/code&gt; 외에 기본 표현을 사용 하면 &lt;code&gt;repr(C)&lt;/code&gt; 형식 에서 열거 형의 크기를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4c37907d281b1198f03324a18111844e539d53d" translate="yes" xml:space="preserve">
          <source>Using a search key that doesn't work with the Borrow trait</source>
          <target state="translated">대출 특성과 작동하지 않는 검색 키 사용</target>
        </trans-unit>
        <trans-unit id="cd14ecb207f28002c37a4e53dc6c1cebfa5f2ee9" translate="yes" xml:space="preserve">
          <source>Using a semicolon after &lt;code&gt;mod front_of_house&lt;/code&gt; rather than using a block tells Rust to load the contents of the module from another file with the same name as the module. To continue with our example and extract the &lt;code&gt;hosting&lt;/code&gt; module to its own file as well, we change &lt;em&gt;src/front_of_house.rs&lt;/em&gt; to contain only the declaration of the &lt;code&gt;hosting&lt;/code&gt; module:</source>
          <target state="translated">블록을 사용하지 않고 &lt;code&gt;mod front_of_house&lt;/code&gt; 뒤에 세미콜론을 사용하면 Rust는 모듈과 동일한 이름을 가진 다른 파일에서 모듈의 내용을로드하도록합니다. 우리의 예를 계속하고 추출하려면 &lt;code&gt;hosting&lt;/code&gt; 뿐만 아니라 자신의 파일에 모듈을, 우리는 변화 &lt;em&gt;SRC / front_of_house.rs을&lt;/em&gt; 의 단지 선언을 포함 &lt;code&gt;hosting&lt;/code&gt; 모듈 :</target>
        </trans-unit>
        <trans-unit id="fe93078130b3109ad5108e782dba78cf01903057" translate="yes" xml:space="preserve">
          <source>Using a tuple of &lt;code&gt;Bound&lt;/code&gt;s as an argument to &lt;a href=&quot;../collections/btree_map/struct.btreemap#method.range&quot;&gt;&lt;code&gt;BTreeMap::range&lt;/code&gt;&lt;/a&gt;. Note that in most cases, it's better to use range syntax (&lt;code&gt;1..5&lt;/code&gt;) instead.</source>
          <target state="translated">&lt;code&gt;Bound&lt;/code&gt; 튜플 을 &lt;a href=&quot;../collections/btree_map/struct.btreemap#method.range&quot;&gt; &lt;code&gt;BTreeMap::range&lt;/code&gt; &lt;/a&gt; 의 인수로 사용 합니다 . 대부분의 경우 범위 구문 ( &lt;code&gt;1..5&lt;/code&gt; )을 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="015c01b29f1c8ebb6c4c8943a2dc3adcbae06181" translate="yes" xml:space="preserve">
          <source>Using an Enum to Store Multiple Types</source>
          <target state="translated">열거 형을 사용하여 여러 유형 저장</target>
        </trans-unit>
        <trans-unit id="b5882a2dc057a0d8d156ec2e30b99dd996e5bdcc" translate="yes" xml:space="preserve">
          <source>Using built-in default values:</source>
          <target state="translated">내장 기본값 사용 :</target>
        </trans-unit>
        <trans-unit id="f3dacd0d875f3e763ce98391694ffe59eeffec43" translate="yes" xml:space="preserve">
          <source>Using custom comparison logic without newtype wrappers</source>
          <target state="translated">뉴 타입 래퍼없이 사용자 정의 비교 로직 사용</target>
        </trans-unit>
        <trans-unit id="a4db67f6f9b0784800ae988e7704553e6de06b09" translate="yes" xml:space="preserve">
          <source>Using default values:</source>
          <target state="translated">기본값 사용 :</target>
        </trans-unit>
        <trans-unit id="8ec600b0ec907749b0fdd372e79b0c70b7b0dce0" translate="yes" xml:space="preserve">
          <source>Using enums has even more advantages. Thinking more about our IP address type, at the moment we don&amp;rsquo;t have a way to store the actual IP address &lt;em&gt;data&lt;/em&gt;; we only know what &lt;em&gt;kind&lt;/em&gt; it is. Given that you just learned about structs in Chapter 5, you might tackle this problem as shown in Listing 6-1.</source>
          <target state="translated">열거 형을 사용하면 더 많은 이점이 있습니다. 실제 IP 주소 &lt;em&gt;데이터&lt;/em&gt; 를 저장할 수있는 방법은 없습니다 . 우리는 그것이 어떤 &lt;em&gt;종류&lt;/em&gt; 인지 알고 있습니다. 5 장의 구조체에 대해 방금 배웠다면 Listing 6-1에 표시된 것처럼이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e92abb62f29a9ab743c0868201fc7c6f7cc104c" translate="yes" xml:space="preserve">
          <source>Using explicit synchronization:</source>
          <target state="translated">명시 적 동기화 사용 :</target>
        </trans-unit>
        <trans-unit id="26140a4b00b6db68bc5c08aa7b59f4de9a496d44" translate="yes" xml:space="preserve">
          <source>Using implicit synchronization:</source>
          <target state="translated">암시 적 동기화 사용 :</target>
        </trans-unit>
        <trans-unit id="0964494ac4fd47f86d6e1abd134d8f88a80450c7" translate="yes" xml:space="preserve">
          <source>Using mutation and going finite:</source>
          <target state="translated">돌연변이를 사용하고 유한하기 :</target>
        </trans-unit>
        <trans-unit id="c5cfc67f6bee08fd41a46b1d08f1ad9861c6e196" translate="yes" xml:space="preserve">
          <source>Using path qualifiers like &lt;a href=&quot;keyword.crate&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;keyword.super&quot;&gt;&lt;code&gt;super&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keyword.self&quot;&gt;&lt;code&gt;self&lt;/code&gt;&lt;/a&gt; is supported: &lt;code&gt;use crate::a::b;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;keyword.crate&quot;&gt; &lt;code&gt;crate&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;keyword.super&quot;&gt; &lt;code&gt;super&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;keyword.self&quot;&gt; &lt;code&gt;self&lt;/code&gt; &lt;/a&gt; 와 같은 경로 한정자를 사용하는 것이 지원됩니다. &lt;code&gt;use crate::a::b;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff5b3892671b9cc1bcba84f83ea8ba99412282b3" translate="yes" xml:space="preserve">
          <source>Using struct update syntax, we can achieve the same effect with less code, as shown in Listing 5-7. The syntax &lt;code&gt;..&lt;/code&gt; specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.</source>
          <target state="translated">구조체 업데이트 구문을 사용하면 코드 5-7과 같이 적은 코드로 동일한 효과를 얻을 수 있습니다. &lt;code&gt;..&lt;/code&gt; 구문 은 명시 적으로 설정되지 않은 나머지 필드가 지정된 인스턴스의 필드와 동일한 값을 가져야 함을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="149131436ae6fcc58b9d3b44704c0a4f62b58b80" translate="yes" xml:space="preserve">
          <source>Using the 'turbofish' instead of annotating &lt;code&gt;doubled&lt;/code&gt;:</source>
          <target state="translated">대신 주석의 'turbofish'사용 &lt;code&gt;doubled&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1fee5723d61f0a87e52c62c70350b33d4a2c1211" translate="yes" xml:space="preserve">
          <source>Using the 'turbofish' instead of annotating &lt;code&gt;four&lt;/code&gt;:</source>
          <target state="translated">대신 주석의 'turbofish'사용 &lt;code&gt;four&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b8dca1dfea48258776a757d0e7fdd52e32ddc6d8" translate="yes" xml:space="preserve">
          <source>Using the &lt;code id=&quot;using-the-search-function-in-the-run-function&quot;&gt;search&lt;/code&gt; Function in the &lt;code&gt;run&lt;/code&gt; Function</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 기능 에서 &lt;code id=&quot;using-the-search-function-in-the-run-function&quot;&gt;search&lt;/code&gt; 기능 사용</target>
        </trans-unit>
        <trans-unit id="73cb7c6eceba8574fdab292dc3c5b0a2f2322727" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;List&lt;/code&gt; type to store the list &lt;code&gt;1, 2, 3&lt;/code&gt; would look like the code in Listing 15-3:</source>
          <target state="translated">은 Using &lt;code&gt;List&lt;/code&gt; 목록 저장 유형을 &lt;code&gt;1, 2, 3&lt;/code&gt; 목록 15-3의 코드처럼 보일 것이다 :</target>
        </trans-unit>
        <trans-unit id="707e73f8481ac39cdfa5e294240c14e577bab80b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;ref&lt;/code&gt; keyword, the value is only borrowed, not moved, making it available for use after the &lt;a href=&quot;keyword.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 키워드를 사용하면 값이 차용되고 이동되지 않으므로 &lt;a href=&quot;keyword.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; 문 다음 에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2545ef2f465dd4b2bb1fca4f7b62b633439903e" translate="yes" xml:space="preserve">
          <source>Using the Field Init Shorthand when Variables and Fields Have the Same Name</source>
          <target state="translated">변수와 필드의 이름이 같은 경우 필드 초기화 단축 사용</target>
        </trans-unit>
        <trans-unit id="527c6fc37f2c7ff511bb334d8bc01dfd4d796198" translate="yes" xml:space="preserve">
          <source>Using the Newtype Pattern for Type Safety and Abstraction</source>
          <target state="translated">타입 안전성 및 추상화를위한 새로운 타입의 패턴 사용</target>
        </trans-unit>
        <trans-unit id="0445dab15f95bbaf439f12315a2f6c2606b64d6c" translate="yes" xml:space="preserve">
          <source>Using the Newtype Pattern to Implement External Traits on External Types</source>
          <target state="translated">Newtype 패턴을 사용하여 외부 유형에 대한 외부 특성 구현</target>
        </trans-unit>
        <trans-unit id="6efe08dd70627a6ae791a8f3c7e219c91abdce73" translate="yes" xml:space="preserve">
          <source>Using the Returned Iterator Directly</source>
          <target state="translated">리턴 된 반복자를 직접 사용</target>
        </trans-unit>
        <trans-unit id="bfe1a641af30e378f1440126b6876e787e3aeb21" translate="yes" xml:space="preserve">
          <source>Using the state pattern means when the business requirements of the program change, we won&amp;rsquo;t need to change the code of the value holding the state or the code that uses the value. We&amp;rsquo;ll only need to update the code inside one of the state objects to change its rules or perhaps add more state objects. Let&amp;rsquo;s look at an example of the state design pattern and how to use it in Rust.</source>
          <target state="translated">상태 패턴을 사용한다는 것은 프로그램의 비즈니스 요구 사항이 변경 될 때 상태를 유지하는 값의 코드 또는 값을 사용하는 코드를 변경할 필요가 없음을 의미합니다. 규칙을 변경하거나 상태 개체를 더 추가하기 위해 상태 개체 중 하나의 코드 만 업데이트하면됩니다. 상태 디자인 패턴의 예와 Rust에서 사용하는 방법을 보자.</target>
        </trans-unit>
        <trans-unit id="f27958ea70e4427546613b6470c7b4a627139188" translate="yes" xml:space="preserve">
          <source>Using this declaration, it must be called with at least one argument, so simply calling &lt;code&gt;printf()&lt;/code&gt; is invalid. But the following uses are allowed:</source>
          <target state="translated">이 선언을 사용하면 적어도 하나의 인수로 호출해야하므로 &lt;code&gt;printf()&lt;/code&gt; 호출 이 유효하지 않습니다. 그러나 다음과 같은 용도로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3febf8421408faebfe197da05a42aac2ff47af45" translate="yes" xml:space="preserve">
          <source>Using this definition, Rust is object oriented: structs and enums have data, and &lt;code&gt;impl&lt;/code&gt; blocks provide methods on structs and enums. Even though structs and enums with methods aren&amp;rsquo;t &lt;em&gt;called&lt;/em&gt; objects, they provide the same functionality, according to the Gang of Four&amp;rsquo;s definition of objects.</source>
          <target state="translated">이 정의를 사용하여 Rust는 객체 지향입니다. 구조체와 열거 형에는 데이터가 있고 &lt;code&gt;impl&lt;/code&gt; 블록은 구조체와 열거 형에 대한 메서드를 제공합니다. 메소드를 가진 구조체와 열거 형을 객체 &lt;em&gt;라고 부르지&lt;/em&gt; 는 않지만 Gang of Four의 객체 정의에 따르면 동일한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4bd35f75969eee3d765cd1e9dcbd0cf13c21dc8a" translate="yes" xml:space="preserve">
          <source>Using this function is generally faster than using &lt;code&gt;powf&lt;/code&gt;</source>
          <target state="translated">이 기능을 사용하면 일반적으로 &lt;code&gt;powf&lt;/code&gt; 를 사용하는 것보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="c548fba9d029d6e16cb5aeebbb487347aada0fef" translate="yes" xml:space="preserve">
          <source>Using this macro is often a bad idea, because if the file is parsed as an expression, it is going to be placed in the surrounding code unhygienically. This could result in variables or functions being different from what the file expected if there are variables or functions that have the same name in the current file.</source>
          <target state="translated">파일을 표현식으로 구문 분석하면 주변 코드에 비위생적으로 배치되기 때문에이 매크로를 사용하는 것은 좋지 않은 생각입니다. 이로 인해 현재 파일에 이름이 같은 변수 나 함수가있는 경우 변수 나 함수가 파일에서 예상 한 것과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7c45efccaaa01e2feb082b19ddba5a32324e6fa" translate="yes" xml:space="preserve">
          <source>Using this method is equivalent to the following code:</source>
          <target state="translated">이 방법을 사용하는 것은 다음 코드와 같습니다.</target>
        </trans-unit>
        <trans-unit id="15e11a1b79c37f9d667f56c8b714852cef36b238" translate="yes" xml:space="preserve">
          <source>Using too many &lt;code&gt;else if&lt;/code&gt; expressions can clutter your code, so if you have more than one, you might want to refactor your code. Chapter 6 describes a powerful Rust branching construct called &lt;code&gt;match&lt;/code&gt; for these cases.</source>
          <target state="translated">식이 코드를 복잡하게 만들 수있는 &lt;code&gt;else if&lt;/code&gt; 너무 많은 수를 사용 하므로 둘 이상인 경우 코드를 리팩토링해야 할 수 있습니다. 6 장 에서는 이러한 경우에 &lt;code&gt;match&lt;/code&gt; 하는 강력한 녹 분기 구성을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="e52bd27c5d26825ad08651412fd660a16f020f77" translate="yes" xml:space="preserve">
          <source>Using too many trait bounds has its downsides. Each generic has its own trait bounds, so functions with multiple generic type parameters can contain lots of trait bound information between the function&amp;rsquo;s name and its parameter list, making the function signature hard to read. For this reason, Rust has alternate syntax for specifying trait bounds inside a &lt;code&gt;where&lt;/code&gt; clause after the function signature. So instead of writing this:</source>
          <target state="translated">너무 많은 특성 범위를 사용하면 단점이 있습니다. 각 제네릭에는 고유 한 특성 경계가 있으므로 여러 제네릭 형식 매개 변수가있는 함수에는 함수 이름과 매개 변수 목록 사이에 많은 특성 바인딩 정보가 포함될 수 있으므로 함수 서명을 읽기가 어렵습니다. 이러한 이유로 Rust에는 함수 시그니처 뒤에 &lt;code&gt;where&lt;/code&gt; 절 내에 특성 범위를 지정하는 대체 구문 이 있습니다. 따라서 이것을 쓰는 대신 :</target>
        </trans-unit>
        <trans-unit id="e8270120e8e5872b95f691e94134c3c38cbe49b0" translate="yes" xml:space="preserve">
          <source>Using traits and lifetimes where appropriate (&lt;a href=&quot;ch10-00-generics&quot;&gt;Chapter 10&lt;/a&gt;)</source>
          <target state="translated">적절한 곳에서 특성과 생애를 사용함 ( &lt;a href=&quot;ch10-00-generics&quot;&gt;10 장&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="1c8fe76861637e35d40bd85f3825d619bc84eadf" translate="yes" xml:space="preserve">
          <source>Using unsafe functionality is potentially dangerous and disallowed by safety checks. Examples:</source>
          <target state="translated">안전하지 않은 기능을 사용하는 것은 잠재적으로 위험하며 안전 점검으로 인해 허용되지 않습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="f903dfb928504d5e71a1ab430366f1a7eae7e14e" translate="yes" xml:space="preserve">
          <source>Using vectors and strings (collections, &lt;a href=&quot;ch08-00-common-collections&quot;&gt;Chapter 8&lt;/a&gt;)</source>
          <target state="translated">벡터와 문자열 사용 (컬렉션, &lt;a href=&quot;ch08-00-common-collections&quot;&gt;8 장&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="d6513e8f7510d42121946e2407ba6c2011fc2c1c" translate="yes" xml:space="preserve">
          <source>Usually a &lt;code&gt;use&lt;/code&gt; keyword is used to shorten the path required to refer to a module item. The keyword may appear in modules, blocks and even functions, usually at the top.</source>
          <target state="translated">일반적으로 &lt;code&gt;use&lt;/code&gt; 키워드는 모듈 항목을 참조하는 데 필요한 경로를 줄이는 데 사용됩니다. 키워드는 일반적으로 상단에 모듈, 블록 및 심지어 기능에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d83a4fba159bee344e91cbe040d6123421c523d3" translate="yes" xml:space="preserve">
          <source>Usually you wouldn't literally use &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; from Rust, but C APIs hand out a lot of pointers generally, so are a common source of raw pointers in Rust.</source>
          <target state="translated">보통은 그대로 사용하지 않을 &lt;code&gt;malloc&lt;/code&gt; 와 &lt;code&gt;free&lt;/code&gt; 그래서 녹 원시 포인터의 공통 소스입니다, 일반적으로 포인터를 많이에서 녹에서,하지만 C API에 손을.</target>
        </trans-unit>
        <trans-unit id="906d4775d8872c7dc79527063674165dda2ccbc0" translate="yes" xml:space="preserve">
          <source>Usually, generic parameters get &lt;em&gt;monomorphized&lt;/em&gt;. For example, if I have</source>
          <target state="translated">일반적으로 일반 매개 변수는 &lt;em&gt;단일화&lt;/em&gt; 됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="d259bb65f469f691c60fbc1cce6f48ae71721980" translate="yes" xml:space="preserve">
          <source>Usually, iterators iterate from left to right. After using &lt;code&gt;rev()&lt;/code&gt;, an iterator will instead iterate from right to left.</source>
          <target state="translated">일반적으로 반복자는 왼쪽에서 오른쪽으로 반복됩니다. &lt;code&gt;rev()&lt;/code&gt; 사용한 후 반복자는 오른쪽에서 왼쪽으로 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="71c8b88aacf28ce47b0a58b2d2bc8a3fb05b911b" translate="yes" xml:space="preserve">
          <source>Utf8Error</source>
          <target state="translated">Utf8Error</target>
        </trans-unit>
        <trans-unit id="0dc56eae851492c66ecabf78d1bbaf00296acfbe" translate="yes" xml:space="preserve">
          <source>Utf8Error::borrow</source>
          <target state="translated">Utf8Error::borrow</target>
        </trans-unit>
        <trans-unit id="62c9947a079483bdf0d15d01617213826dc02f38" translate="yes" xml:space="preserve">
          <source>Utf8Error::borrow_mut</source>
          <target state="translated">Utf8Error::borrow_mut</target>
        </trans-unit>
        <trans-unit id="3f5e10da6a480e49a740c45c14fd97e4e299d73d" translate="yes" xml:space="preserve">
          <source>Utf8Error::cause</source>
          <target state="translated">Utf8Error::cause</target>
        </trans-unit>
        <trans-unit id="aba276798126f3d9e88abbf114717adc671724b0" translate="yes" xml:space="preserve">
          <source>Utf8Error::clone</source>
          <target state="translated">Utf8Error::clone</target>
        </trans-unit>
        <trans-unit id="d9f741fd3eb062e41262e053f0eb1a689e8b68c8" translate="yes" xml:space="preserve">
          <source>Utf8Error::clone_from</source>
          <target state="translated">Utf8Error::clone_from</target>
        </trans-unit>
        <trans-unit id="6fb618053c3a87e8372bf0b005ef3aee33a2be29" translate="yes" xml:space="preserve">
          <source>Utf8Error::clone_into</source>
          <target state="translated">Utf8Error::clone_into</target>
        </trans-unit>
        <trans-unit id="5eb848f299ba96b5c68a3de5bf02961b034fb439" translate="yes" xml:space="preserve">
          <source>Utf8Error::description</source>
          <target state="translated">Utf8Error::description</target>
        </trans-unit>
        <trans-unit id="1e357eccf69d01f74bf39edbfab63655804a87a8" translate="yes" xml:space="preserve">
          <source>Utf8Error::eq</source>
          <target state="translated">Utf8Error::eq</target>
        </trans-unit>
        <trans-unit id="88f730d875142fa4beddb68ae32ca749e55c5da0" translate="yes" xml:space="preserve">
          <source>Utf8Error::error_len</source>
          <target state="translated">Utf8Error::error_len</target>
        </trans-unit>
        <trans-unit id="81707f4d43116cddc3b6180c7d1812770aa6aabd" translate="yes" xml:space="preserve">
          <source>Utf8Error::fmt</source>
          <target state="translated">Utf8Error::fmt</target>
        </trans-unit>
        <trans-unit id="80d9f3c5cc9b436bfc54741853eb348edcd31923" translate="yes" xml:space="preserve">
          <source>Utf8Error::from</source>
          <target state="translated">Utf8Error::from</target>
        </trans-unit>
        <trans-unit id="186ae2f6ff2c38ceed80692f48587dd9073b281b" translate="yes" xml:space="preserve">
          <source>Utf8Error::into</source>
          <target state="translated">Utf8Error::into</target>
        </trans-unit>
        <trans-unit id="da5d217600f498b06be2479022d36a4a5c15449b" translate="yes" xml:space="preserve">
          <source>Utf8Error::ne</source>
          <target state="translated">Utf8Error::ne</target>
        </trans-unit>
        <trans-unit id="65ff32fff52c3afe8fd1470fd4590b2fae222e96" translate="yes" xml:space="preserve">
          <source>Utf8Error::source</source>
          <target state="translated">Utf8Error::source</target>
        </trans-unit>
        <trans-unit id="d542954047d8755ad1a4e9a853bcf03561cdf1c9" translate="yes" xml:space="preserve">
          <source>Utf8Error::to_owned</source>
          <target state="translated">Utf8Error::to_owned</target>
        </trans-unit>
        <trans-unit id="ef5e78b58ef441d19d975802cc905ce882b752c7" translate="yes" xml:space="preserve">
          <source>Utf8Error::to_string</source>
          <target state="translated">Utf8Error::to_string</target>
        </trans-unit>
        <trans-unit id="eb1790431a34016d236cceca893cabedf79794fa" translate="yes" xml:space="preserve">
          <source>Utf8Error::try_from</source>
          <target state="translated">Utf8Error::try_from</target>
        </trans-unit>
        <trans-unit id="d78057a09376f581ad70dcf23d55b916b4ec76d6" translate="yes" xml:space="preserve">
          <source>Utf8Error::try_into</source>
          <target state="translated">Utf8Error::try_into</target>
        </trans-unit>
        <trans-unit id="77455bd6cede93b6937284b56ca0ee7128f3fcd5" translate="yes" xml:space="preserve">
          <source>Utf8Error::type_id</source>
          <target state="translated">Utf8Error::type_id</target>
        </trans-unit>
        <trans-unit id="061f930ae2881081028ec6f4738788ea0386348a" translate="yes" xml:space="preserve">
          <source>Utf8Error::valid_up_to</source>
          <target state="translated">Utf8Error::valid_up_to</target>
        </trans-unit>
        <trans-unit id="098996f33abfeafe0fd0a1060966a3bd981c2d4c" translate="yes" xml:space="preserve">
          <source>Utilities for formatting and printing &lt;code&gt;String&lt;/code&gt;s.</source>
          <target state="translated">서식 및 인쇄 유틸리티 &lt;code&gt;String&lt;/code&gt; 들.</target>
        </trans-unit>
        <trans-unit id="bbf05f92621e129ba6a9d6d71f520f94619321a3" translate="yes" xml:space="preserve">
          <source>Utilities related to FFI bindings.</source>
          <target state="translated">FFI 바인딩과 관련된 유틸리티.</target>
        </trans-unit>
        <trans-unit id="2cfce7b7e1bbf22d999dd679513efd8dd1774d5b" translate="yes" xml:space="preserve">
          <source>Utility trait implemented only on arrays of fixed size</source>
          <target state="translated">고정 된 크기의 배열에서만 구현되는 유틸리티 특성</target>
        </trans-unit>
        <trans-unit id="f4dc02e287a9f4de99799a5c31108f51723830a7" translate="yes" xml:space="preserve">
          <source>VXWorks</source>
          <target state="translated">VXWorks</target>
        </trans-unit>
        <trans-unit id="2a62ae9e6e10d5b4d844ad431e3d12dd6181892a" translate="yes" xml:space="preserve">
          <source>VaList</source>
          <target state="translated">VaList</target>
        </trans-unit>
        <trans-unit id="d3dc417a5e809aff4e928e1c2ccc9e1476eea745" translate="yes" xml:space="preserve">
          <source>VaList::arg</source>
          <target state="translated">VaList::arg</target>
        </trans-unit>
        <trans-unit id="e56bcc6610b1a8196319373f5b202bf4d9783931" translate="yes" xml:space="preserve">
          <source>VaList::as_va_list</source>
          <target state="translated">VaList::as_va_list</target>
        </trans-unit>
        <trans-unit id="93ccd0479992f30997a13f7a0291305d4a7bcf8f" translate="yes" xml:space="preserve">
          <source>VaList::borrow</source>
          <target state="translated">VaList::borrow</target>
        </trans-unit>
        <trans-unit id="14c647375c9b8191c6015d7e9763130b93ea3cb0" translate="yes" xml:space="preserve">
          <source>VaList::borrow_mut</source>
          <target state="translated">VaList::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c8adb5d15703c32cb6620339a1ad3a830f1ad937" translate="yes" xml:space="preserve">
          <source>VaList::deref</source>
          <target state="translated">VaList::deref</target>
        </trans-unit>
        <trans-unit id="ef4f8c0aefca94cf0351ab804dcb1192072b3317" translate="yes" xml:space="preserve">
          <source>VaList::deref_mut</source>
          <target state="translated">VaList::deref_mut</target>
        </trans-unit>
        <trans-unit id="4df0a82f8196ee6c8e34acaf7e521f5043ecc3f2" translate="yes" xml:space="preserve">
          <source>VaList::fmt</source>
          <target state="translated">VaList::fmt</target>
        </trans-unit>
        <trans-unit id="03cb0ba45ef46a478c6e89bd3b44e1281a4d5eb6" translate="yes" xml:space="preserve">
          <source>VaList::from</source>
          <target state="translated">VaList::from</target>
        </trans-unit>
        <trans-unit id="2b7cbe3710d07592cd359bf917b0387f4e9e9c5d" translate="yes" xml:space="preserve">
          <source>VaList::into</source>
          <target state="translated">VaList::into</target>
        </trans-unit>
        <trans-unit id="006354eed9f82fbe26fc29d15037b46b80c2b68d" translate="yes" xml:space="preserve">
          <source>VaList::try_from</source>
          <target state="translated">VaList::try_from</target>
        </trans-unit>
        <trans-unit id="cb8a2fefa105254fc69713249a582cf152da5fab" translate="yes" xml:space="preserve">
          <source>VaList::try_into</source>
          <target state="translated">VaList::try_into</target>
        </trans-unit>
        <trans-unit id="00466fb65a3743839a76ad49fc45873af21ac5b5" translate="yes" xml:space="preserve">
          <source>VaList::type_id</source>
          <target state="translated">VaList::type_id</target>
        </trans-unit>
        <trans-unit id="c8012d496381feb2e9a104eb4daca8ce56213794" translate="yes" xml:space="preserve">
          <source>VaList::with_copy</source>
          <target state="translated">VaList::with_copy</target>
        </trans-unit>
        <trans-unit id="cda940b5210ef6c9c3a6f85409e7dfeabc36a58a" translate="yes" xml:space="preserve">
          <source>VaListImpl</source>
          <target state="translated">VaListImpl</target>
        </trans-unit>
        <trans-unit id="3ca16b32106de1b77aafe6c23653b3844b349ae2" translate="yes" xml:space="preserve">
          <source>VaListImpl::arg</source>
          <target state="translated">VaListImpl::arg</target>
        </trans-unit>
        <trans-unit id="f4173f47c545e4746400db7076f692fc8d564b6d" translate="yes" xml:space="preserve">
          <source>VaListImpl::as_va_list</source>
          <target state="translated">VaListImpl::as_va_list</target>
        </trans-unit>
        <trans-unit id="d4f4feeb2f49c83d41fa723579047ba246044ff7" translate="yes" xml:space="preserve">
          <source>VaListImpl::borrow</source>
          <target state="translated">VaListImpl::borrow</target>
        </trans-unit>
        <trans-unit id="12efac9fbc832f37c148aabeed63349a1f5126dd" translate="yes" xml:space="preserve">
          <source>VaListImpl::borrow_mut</source>
          <target state="translated">VaListImpl::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c3f6404a6c3b18f2e79cb5750c66a38cba6e8a6c" translate="yes" xml:space="preserve">
          <source>VaListImpl::clone</source>
          <target state="translated">VaListImpl::clone</target>
        </trans-unit>
        <trans-unit id="c95d8d0d76cdd92d3789595b002435cb8b173ba3" translate="yes" xml:space="preserve">
          <source>VaListImpl::clone_from</source>
          <target state="translated">VaListImpl::clone_from</target>
        </trans-unit>
        <trans-unit id="b7e21123ef8eeecb128af522573adb35c0d73ae7" translate="yes" xml:space="preserve">
          <source>VaListImpl::clone_into</source>
          <target state="translated">VaListImpl::clone_into</target>
        </trans-unit>
        <trans-unit id="8cc867e3d0ec9d7fb9edb3f064cbe3324e06efce" translate="yes" xml:space="preserve">
          <source>VaListImpl::drop</source>
          <target state="translated">VaListImpl::drop</target>
        </trans-unit>
        <trans-unit id="c61984180c1cbdf98ccebd337221adae24339007" translate="yes" xml:space="preserve">
          <source>VaListImpl::fmt</source>
          <target state="translated">VaListImpl::fmt</target>
        </trans-unit>
        <trans-unit id="5914da98901e40d1b7387569cc8698d5354eda2d" translate="yes" xml:space="preserve">
          <source>VaListImpl::from</source>
          <target state="translated">VaListImpl::from</target>
        </trans-unit>
        <trans-unit id="69d61c23655b32b3d7479d5b9b6a68338cf35be2" translate="yes" xml:space="preserve">
          <source>VaListImpl::into</source>
          <target state="translated">VaListImpl::into</target>
        </trans-unit>
        <trans-unit id="5bfd2cfab7029ef58c310f856c3da54cb4b8f66b" translate="yes" xml:space="preserve">
          <source>VaListImpl::to_owned</source>
          <target state="translated">VaListImpl::to_owned</target>
        </trans-unit>
        <trans-unit id="2a010a2b25dc2ad1ab26cc514156dc9263f6a636" translate="yes" xml:space="preserve">
          <source>VaListImpl::try_from</source>
          <target state="translated">VaListImpl::try_from</target>
        </trans-unit>
        <trans-unit id="d69de8fd6c5d1bc620b9f394404b1608c17d118f" translate="yes" xml:space="preserve">
          <source>VaListImpl::try_into</source>
          <target state="translated">VaListImpl::try_into</target>
        </trans-unit>
        <trans-unit id="d07770d2e23a78895791cb1ceaf87ef62f25d60c" translate="yes" xml:space="preserve">
          <source>VaListImpl::type_id</source>
          <target state="translated">VaListImpl::type_id</target>
        </trans-unit>
        <trans-unit id="d2fa0e7319df7d0644b9ea0a44af083d4b6e723c" translate="yes" xml:space="preserve">
          <source>VaListImpl::with_copy</source>
          <target state="translated">VaListImpl::with_copy</target>
        </trans-unit>
        <trans-unit id="4e28dc650ae01219c2816ac14486f89634c8fc55" translate="yes" xml:space="preserve">
          <source>VacantEntry</source>
          <target state="translated">VacantEntry</target>
        </trans-unit>
        <trans-unit id="c96052bd94ad047ad8849208c48bf71c8e89ef7c" translate="yes" xml:space="preserve">
          <source>Valid pattern syntax in macro definitions is different than the pattern syntax covered in Chapter 18 because macro patterns are matched against Rust code structure rather than values. Let&amp;rsquo;s walk through what the pattern pieces in Listing 19-28 mean; for the full macro pattern syntax, see &lt;a href=&quot;../reference/macros&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="translated">매크로 정의에서 유효한 패턴 구문은 18 장에서 다룬 패턴 구문과 다릅니다. 매크로 패턴은 값이 아닌 Rust 코드 구조와 일치하기 때문입니다. Listing 19-28의 패턴 부분이 무엇을 의미하는지 살펴 보자. 전체 매크로 패턴 구문에 대해서는 &lt;a href=&quot;../reference/macros&quot;&gt;reference를 참조&lt;/a&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7af7dd6d571b7430a0f3a804a2823ff5e3b34175" translate="yes" xml:space="preserve">
          <source>Valid pattern syntax in macro definitions is different than the pattern syntax covered in Chapter 18 because macro patterns are matched against Rust code structure rather than values. Let&amp;rsquo;s walk through what the pattern pieces in Listing 19-28 mean; for the full macro pattern syntax, see &lt;a href=&quot;../reference/macros-by-example&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="translated">매크로 패턴이 값이 아닌 Rust 코드 구조와 일치하기 때문에 매크로 정의에서 유효한 패턴 구문은 18 장에서 다룬 패턴 구문과 다릅니다. Listing 19-28의 패턴 조각이 무엇을 의미하는지 살펴 보겠습니다. 전체 매크로 패턴 구문 &lt;a href=&quot;../reference/macros-by-example&quot;&gt;은 참조를 참조&lt;/a&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="06e50fbff8c8b7744c52b295c7fbf72559544494" translate="yes" xml:space="preserve">
          <source>Valid raw pointers as defined above are not necessarily properly aligned (where &quot;proper&quot; alignment is defined by the pointee type, i.e., &lt;code&gt;*const T&lt;/code&gt; must be aligned to &lt;code&gt;mem::align_of::&amp;lt;T&amp;gt;()&lt;/code&gt;). However, most functions require their arguments to be properly aligned, and will explicitly state this requirement in their documentation. Notable exceptions to this are &lt;a href=&quot;fn.read_unaligned&quot;&gt;&lt;code&gt;read_unaligned&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.write_unaligned&quot;&gt;&lt;code&gt;write_unaligned&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">위에서 정의한 유효한 원시 포인터는 반드시 올바르게 정렬 될 필요는 없습니다 ( &quot;적절한&quot;정렬은 포인트 유형에 의해 정의됩니다. 즉 &lt;code&gt;*const T&lt;/code&gt; 는 &lt;code&gt;mem::align_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 으로 정렬되어야합니다 ). 그러나 대부분의 함수는 인수를 올바르게 정렬해야하며 설명서에이 요구 사항을 명시 적으로 명시합니다. 이에 대한 예외는 &lt;a href=&quot;fn.read_unaligned&quot;&gt; &lt;code&gt;read_unaligned&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fn.write_unaligned&quot;&gt; &lt;code&gt;write_unaligned&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c48f78e987c312ef821adcc0d7ee75c56d9144ac" translate="yes" xml:space="preserve">
          <source>Validating References with Lifetimes</source>
          <target state="translated">수명으로 참조 확인</target>
        </trans-unit>
        <trans-unit id="9bbb454d5a41c8f26ec9fb9b367e97c6b19c2f83" translate="yes" xml:space="preserve">
          <source>Validating the Number of Threads in &lt;code id=&quot;validating-the-number-of-threads-in-new&quot;&gt;new&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;validating-the-number-of-threads-in-new&quot;&gt;new&lt;/code&gt; 스레드 수 확인</target>
        </trans-unit>
        <trans-unit id="b5528864ad5f1464447c6381f31faab679eb55d8" translate="yes" xml:space="preserve">
          <source>Validating the Request and Selectively Responding</source>
          <target state="translated">요청 확인 및 선택적으로 응답</target>
        </trans-unit>
        <trans-unit id="c4d75c989017ceaea555b5cb2f965e9a31a0f2ae" translate="yes" xml:space="preserve">
          <source>Value being parsed is empty.</source>
          <target state="translated">구문 분석중인 값이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="202eac546e1cca5cc40fbd1aa3d448b11c2717ed" translate="yes" xml:space="preserve">
          <source>Value was Zero</source>
          <target state="translated">가치는 0이었다</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="0c9f5af2d57c101875a9c09b9e64f7ab67e3fee1" translate="yes" xml:space="preserve">
          <source>Values larger than the maximum integer value will saturate to the maximum value of the integer type.</source>
          <target state="translated">최대 정수 값보다 큰 값은 정수 유형의 최대 값으로 포화됩니다.</target>
        </trans-unit>
        <trans-unit id="1cb37a0444183e3bd07455b2f462b02a3823b4ce" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; types may be mutated through shared references (i.e. the common &lt;code&gt;&amp;amp;T&lt;/code&gt; type), whereas most Rust types can only be mutated through unique (&lt;code&gt;&amp;amp;mut T&lt;/code&gt;) references. We say that &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; provide 'interior mutability', in contrast with typical Rust types that exhibit 'inherited mutability'.</source>
          <target state="translated">의 값은 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 유형 (즉, 공통의 참조를 통해 공유 될 수있다 돌연변이 &lt;code&gt;&amp;amp;T&lt;/code&gt; 가장 녹 종류 만 (고유 통해 돌연변이 될 수있는 반면, 타입) &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ) 참조. 우리는 말을 그 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 와 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 일반적인 녹 유형이 전시 '상속 가변성'와 달리 '내부의 가변성'을 제공한다.</target>
        </trans-unit>
        <trans-unit id="df0b0235c50fdaa3c200fefa43bc29bd936a024f" translate="yes" xml:space="preserve">
          <source>Values of this type are constructed using a &lt;a href=&quot;../expressions/tuple-expr#tuple-expressions&quot;&gt;tuple expression&lt;/a&gt;. Furthermore, various expressions will produce the unit value if there is no other meaningful value for it to evaluate to. Tuple elements can be accessed by either a &lt;a href=&quot;../expressions/tuple-expr#tuple-indexing-expressions&quot;&gt;tuple index expression&lt;/a&gt; or &lt;a href=&quot;../patterns#tuple-patterns&quot;&gt;pattern matching&lt;/a&gt;.</source>
          <target state="translated">이 유형의 값은 &lt;a href=&quot;../expressions/tuple-expr#tuple-expressions&quot;&gt;튜플 식을&lt;/a&gt; 사용하여 생성됩니다 . 또한 평가할 다른 의미있는 값이 없으면 다양한식이 단위 값을 생성합니다. 튜플 요소는 &lt;a href=&quot;../expressions/tuple-expr#tuple-indexing-expressions&quot;&gt;튜플 인덱스 표현식&lt;/a&gt; 또는 &lt;a href=&quot;../patterns#tuple-patterns&quot;&gt;패턴 일치를&lt;/a&gt; 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ead0c6d8884038da5a1c37b81bd9ecdfeb765f5" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;&amp;amp;T&lt;/code&gt; are coerced to values of type &lt;code&gt;&amp;amp;U&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;amp;T&lt;/code&gt; 유형의 값은 &lt;code&gt;&amp;amp;U&lt;/code&gt; 유형의 값으로 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="dd64aa37983b87ea2f61bdac9618cf696e12dc47" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;&amp;amp;mut T&lt;/code&gt; are coerced to values of type &lt;code&gt;&amp;amp;mut U&lt;/code&gt;</source>
          <target state="translated">유형의 값 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 타입의 값으로 강제되는 &lt;code&gt;&amp;amp;mut U&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e8a037908d83b45e7c8a2c2c4fe0fb372c4e345" translate="yes" xml:space="preserve">
          <source>Values returned by the iterator are returned in ascending order:</source>
          <target state="translated">반복자가 반환 한 값은 오름차순으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7d470a568e8e665e2abbc283ee00bd48e19164d9" translate="yes" xml:space="preserve">
          <source>Values smaller than the minimum integer value will saturate to the minimum value of the integer type.</source>
          <target state="translated">최소 정수 값보다 작은 값은 정수 유형의 최소 값으로 포화됩니다.</target>
        </trans-unit>
        <trans-unit id="7afb9932010efa26617ba00942998437043da478" translate="yes" xml:space="preserve">
          <source>ValuesMut</source>
          <target state="translated">ValuesMut</target>
        </trans-unit>
        <trans-unit id="6f7df0e9c5abd887cbbca9fb8a84f3706f71be4d" translate="yes" xml:space="preserve">
          <source>VarError</source>
          <target state="translated">VarError</target>
        </trans-unit>
        <trans-unit id="b2249943fec1979f3539ebcd42bc0163bc44ee0a" translate="yes" xml:space="preserve">
          <source>VarError::borrow</source>
          <target state="translated">VarError::borrow</target>
        </trans-unit>
        <trans-unit id="e76b4c157350bd5d1faf74dc1a04fc95858ad1b0" translate="yes" xml:space="preserve">
          <source>VarError::borrow_mut</source>
          <target state="translated">VarError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8102864035147256ef0e364c15593289f8d64dc2" translate="yes" xml:space="preserve">
          <source>VarError::cause</source>
          <target state="translated">VarError::cause</target>
        </trans-unit>
        <trans-unit id="7077379d5b4387ff8ef4d01332e0c9cb99aeba54" translate="yes" xml:space="preserve">
          <source>VarError::clone</source>
          <target state="translated">VarError::clone</target>
        </trans-unit>
        <trans-unit id="0632068939784835c82259892b18fa3851d349ae" translate="yes" xml:space="preserve">
          <source>VarError::clone_from</source>
          <target state="translated">VarError::clone_from</target>
        </trans-unit>
        <trans-unit id="3e4c81dcadc33c305fcb9909e431adbde92a23e1" translate="yes" xml:space="preserve">
          <source>VarError::clone_into</source>
          <target state="translated">VarError::clone_into</target>
        </trans-unit>
        <trans-unit id="ec42cb6e55e02863f7703ec026731824032ed4c6" translate="yes" xml:space="preserve">
          <source>VarError::description</source>
          <target state="translated">VarError::description</target>
        </trans-unit>
        <trans-unit id="8d65ad24989288d2260d520733e5b865bcae5729" translate="yes" xml:space="preserve">
          <source>VarError::eq</source>
          <target state="translated">VarError::eq</target>
        </trans-unit>
        <trans-unit id="467b0e136a5d88a16831d064cfef40627edbdee5" translate="yes" xml:space="preserve">
          <source>VarError::fmt</source>
          <target state="translated">VarError::fmt</target>
        </trans-unit>
        <trans-unit id="5122b46ea820b54b6d938c3fc817b38fbb3551ec" translate="yes" xml:space="preserve">
          <source>VarError::from</source>
          <target state="translated">VarError::from</target>
        </trans-unit>
        <trans-unit id="489e1a123c276c2da9ec69dea9020703001650ca" translate="yes" xml:space="preserve">
          <source>VarError::into</source>
          <target state="translated">VarError::into</target>
        </trans-unit>
        <trans-unit id="77f840cd95edf89f75e8cbd45132b08b456a0812" translate="yes" xml:space="preserve">
          <source>VarError::ne</source>
          <target state="translated">VarError::ne</target>
        </trans-unit>
        <trans-unit id="0c18e774293ad67a8f9a9531c4cd7c614981cf63" translate="yes" xml:space="preserve">
          <source>VarError::source</source>
          <target state="translated">VarError::source</target>
        </trans-unit>
        <trans-unit id="e8289e8f0efbef22ac2ef6d43d6c953e17d68e73" translate="yes" xml:space="preserve">
          <source>VarError::to_owned</source>
          <target state="translated">VarError::to_owned</target>
        </trans-unit>
        <trans-unit id="3b34bb1f1ce27eec8b875707ed1773dc9147c967" translate="yes" xml:space="preserve">
          <source>VarError::to_string</source>
          <target state="translated">VarError::to_string</target>
        </trans-unit>
        <trans-unit id="2d14c21b020fdc28d154a0e06cc4cefbc03f8bd7" translate="yes" xml:space="preserve">
          <source>VarError::try_from</source>
          <target state="translated">VarError::try_from</target>
        </trans-unit>
        <trans-unit id="20dfa7580a9574a0ffa43df49fcb51fd1edef1e7" translate="yes" xml:space="preserve">
          <source>VarError::try_into</source>
          <target state="translated">VarError::try_into</target>
        </trans-unit>
        <trans-unit id="67e6d907fb202086a0226ec13ebdeab6dee225b8" translate="yes" xml:space="preserve">
          <source>VarError::type_id</source>
          <target state="translated">VarError::type_id</target>
        </trans-unit>
        <trans-unit id="b280dc1f4f1b58422609af96e60af9910ffc1aac" translate="yes" xml:space="preserve">
          <source>Variable Scope</source>
          <target state="translated">변수 범위</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="732411588a5167f463feab941a8f9ac01a5767df" translate="yes" xml:space="preserve">
          <source>Variables and Mutability</source>
          <target state="translated">변수와 돌연변이</target>
        </trans-unit>
        <trans-unit id="3aa41db4c47f6adb669361c7bd5c456d22e65ea3" translate="yes" xml:space="preserve">
          <source>Variables are dropped in reverse order of declaration</source>
          <target state="translated">변수는 선언의 역순으로 삭제됩니다</target>
        </trans-unit>
        <trans-unit id="be65562327a4b52bee54dc313d949d1238b35a3e" translate="yes" xml:space="preserve">
          <source>Variables are dropped in reverse order of declaration. Variables declared in the same pattern drop in an unspecified ordered.</source>
          <target state="translated">변수는 선언 순서와 반대로 삭제됩니다. 동일한 패턴으로 선언 된 변수는 지정되지 않은 순서로 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="098937ab2cfb527e074d853750f7a28c47a33f35" translate="yes" xml:space="preserve">
          <source>Variables bound within the pattern are scoped to the match guard and the arm's expression. The &lt;a href=&quot;../patterns#binding-modes&quot;&gt;binding mode&lt;/a&gt; (move, copy, or reference) depends on the pattern.</source>
          <target state="translated">패턴 내에 바인드 된 변수는 매치 가드 및 팔의 식으로 범위가 지정됩니다. &lt;a href=&quot;../patterns#binding-modes&quot;&gt;결합 모드&lt;/a&gt; (이동, 복사 또는 기준)의 패턴에 따라 달라진다.</target>
        </trans-unit>
        <trans-unit id="3c4d82fabad7ffdf2edb09b215e05fb61c4a456f" translate="yes" xml:space="preserve">
          <source>Variables in Rust are immutable by default, and require the &lt;code&gt;mut&lt;/code&gt; keyword to be made mutable.</source>
          <target state="translated">Rust의 변수는 기본적 으로 변경할 수 없으며 &lt;code&gt;mut&lt;/code&gt; 키워드를 변경할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="8e36a4956d4555b32607f272180c87deea209898" translate="yes" xml:space="preserve">
          <source>Variadic functions</source>
          <target state="translated">다양한 기능</target>
        </trans-unit>
        <trans-unit id="09181b83bd980777906a8422efadb22af2c263db" translate="yes" xml:space="preserve">
          <source>Variadic parameters can only be specified with &lt;a href=&quot;../items/external-blocks&quot;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/a&gt; function types with the &lt;code&gt;&quot;C&quot;&lt;/code&gt; or &lt;code&gt;&quot;cdecl&quot;&lt;/code&gt; calling convention.</source>
          <target state="translated">Variadic 매개 변수는 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;cdecl&quot;&lt;/code&gt; 호출 규칙을 사용하여 &lt;a href=&quot;../items/external-blocks&quot;&gt; &lt;code&gt;extern&lt;/code&gt; &lt;/a&gt; 함수 유형으로 만 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c86f67a7083ae244751a61c00202e2c7bd69682" translate="yes" xml:space="preserve">
          <source>Variadic parameters have been used on a non-C ABI function.</source>
          <target state="translated">C가 아닌 ABI 함수에 가변 매개 변수가 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="eb39bbf6ccbbc8fdb77438c3cd6155bb1b7ec6b8" translate="yes" xml:space="preserve">
          <source>Variance</source>
          <target state="translated">Variance</target>
        </trans-unit>
        <trans-unit id="8a62a01b810204975c3451044bb90c7a71ef1cde" translate="yes" xml:space="preserve">
          <source>Variance in &lt;code&gt;'a&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'a&lt;/code&gt; 의 차이</target>
        </trans-unit>
        <trans-unit id="34a3731e86c04bcba14d808de4b083ba9ec18ab8" translate="yes" xml:space="preserve">
          <source>Variance in &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">에 분산 &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13ea9443937d9e6015e5a5cffcafae425d987b1a" translate="yes" xml:space="preserve">
          <source>Variance is a property that generic types have with respect to their arguments. A generic type's &lt;em&gt;variance&lt;/em&gt; in a parameter is how the subtyping of the parameter affects the subtyping of the type.</source>
          <target state="translated">분산은 일반 유형이 인수와 관련하여 갖는 특성입니다. 매개 변수에서 일반 유형의 &lt;em&gt;분산&lt;/em&gt; 은 매개 변수의 하위 유형이 유형의 하위 유형에 미치는 영향입니다.</target>
        </trans-unit>
        <trans-unit id="9c74b0f6448f867bdf1be672d84dbe75d3a10d26" translate="yes" xml:space="preserve">
          <source>Variance of types is automatically determined as follows</source>
          <target state="translated">유형의 편차는 다음과 같이 자동으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="59640c3e0b061bd7062f06a5f01816c4cfbcbe86" translate="yes" xml:space="preserve">
          <source>Variant visibility</source>
          <target state="translated">변형 가시성</target>
        </trans-unit>
        <trans-unit id="1bc3d368f8ad61e91648458829240a7efefcd2c1" translate="yes" xml:space="preserve">
          <source>Variants</source>
          <target state="translated">Variants</target>
        </trans-unit>
        <trans-unit id="1cec834cdc1b08e2f3ed59d65a8026d0864fc5b4" translate="yes" xml:space="preserve">
          <source>Variants (Non-exhaustive)</source>
          <target state="translated">변형 (비 제한적)</target>
        </trans-unit>
        <trans-unit id="b3fbdc730db8eecbbf239ec3967489785ffcc13f" translate="yes" xml:space="preserve">
          <source>Various built-in attributes use different subsets of the meta item syntax to specify their inputs. The following grammar rules show some commonly used forms:</source>
          <target state="translated">다양한 내장 속성은 메타 항목 구문의 다른 서브 세트를 사용하여 입력을 지정합니다. 다음 문법 규칙은 일반적으로 사용되는 양식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="18d5bf7e0fee25c311080dec74d574b65c4b0764" translate="yes" xml:space="preserve">
          <source>Various separators</source>
          <target state="translated">다양한 분리기</target>
        </trans-unit>
        <trans-unit id="d4251864c293c17029bfa74793ffa95136fcec6d" translate="yes" xml:space="preserve">
          <source>Various things in the standard library may implement one or more of the three, where appropriate.</source>
          <target state="translated">표준 라이브러리의 다양한 것들이 적절한 경우 세 가지 중 하나 이상을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9069e323599df5d27b7c9d2e68cb81566e2b60e" translate="yes" xml:space="preserve">
          <source>Vars</source>
          <target state="translated">Vars</target>
        </trans-unit>
        <trans-unit id="1c47de6b16a76ec820d60a85839ecc1cbf5e4457" translate="yes" xml:space="preserve">
          <source>Vars::all</source>
          <target state="translated">Vars::all</target>
        </trans-unit>
        <trans-unit id="b398eaf22edd2ef7aed1c4f858c613d773d5dd59" translate="yes" xml:space="preserve">
          <source>Vars::any</source>
          <target state="translated">Vars::any</target>
        </trans-unit>
        <trans-unit id="80450fe90037366e6900e0207a00a0ff5399c353" translate="yes" xml:space="preserve">
          <source>Vars::borrow</source>
          <target state="translated">Vars::borrow</target>
        </trans-unit>
        <trans-unit id="21a23559330914e11672cfb421023160c25aceab" translate="yes" xml:space="preserve">
          <source>Vars::borrow_mut</source>
          <target state="translated">Vars::borrow_mut</target>
        </trans-unit>
        <trans-unit id="781b07302eb0ba1fcc3cf935ec319d0ab20b1f65" translate="yes" xml:space="preserve">
          <source>Vars::by_ref</source>
          <target state="translated">Vars::by_ref</target>
        </trans-unit>
        <trans-unit id="9951d905bdeb385924f734897456db259730b15b" translate="yes" xml:space="preserve">
          <source>Vars::chain</source>
          <target state="translated">Vars::chain</target>
        </trans-unit>
        <trans-unit id="b7b0b3926db3e290b2a0c4b07b1ac73606da0d40" translate="yes" xml:space="preserve">
          <source>Vars::cloned</source>
          <target state="translated">Vars::cloned</target>
        </trans-unit>
        <trans-unit id="af8d7407e3b763504a144307a7303f5603d6229f" translate="yes" xml:space="preserve">
          <source>Vars::cmp</source>
          <target state="translated">Vars::cmp</target>
        </trans-unit>
        <trans-unit id="5a55a34bc63ca6a0899a5379932cae28b637a085" translate="yes" xml:space="preserve">
          <source>Vars::collect</source>
          <target state="translated">Vars::collect</target>
        </trans-unit>
        <trans-unit id="4eb06a4620fc01558a8bd2f2bf2b0ca80dc89a4b" translate="yes" xml:space="preserve">
          <source>Vars::copied</source>
          <target state="translated">Vars::copied</target>
        </trans-unit>
        <trans-unit id="bfb7648d61e3607bf3caff921735ae88f75f92ef" translate="yes" xml:space="preserve">
          <source>Vars::count</source>
          <target state="translated">Vars::count</target>
        </trans-unit>
        <trans-unit id="f6b7790787f62ef8a6724b8647c199f3e9fc0e6f" translate="yes" xml:space="preserve">
          <source>Vars::cycle</source>
          <target state="translated">Vars::cycle</target>
        </trans-unit>
        <trans-unit id="c728f5f416f691b01f40cd87af7f9137219eb03f" translate="yes" xml:space="preserve">
          <source>Vars::enumerate</source>
          <target state="translated">Vars::enumerate</target>
        </trans-unit>
        <trans-unit id="0a270124e47b9e2828a920edca2e2e533038569f" translate="yes" xml:space="preserve">
          <source>Vars::eq</source>
          <target state="translated">Vars::eq</target>
        </trans-unit>
        <trans-unit id="7080a20dc333e44166a8558123ba98d85eb6ded3" translate="yes" xml:space="preserve">
          <source>Vars::filter</source>
          <target state="translated">Vars::filter</target>
        </trans-unit>
        <trans-unit id="d41dd539031344f9e7e7bb6171c556fc42ef1957" translate="yes" xml:space="preserve">
          <source>Vars::filter_map</source>
          <target state="translated">Vars::filter_map</target>
        </trans-unit>
        <trans-unit id="78b0b6d5abfd7026b83ef665a619f46c392d69ed" translate="yes" xml:space="preserve">
          <source>Vars::find</source>
          <target state="translated">Vars::find</target>
        </trans-unit>
        <trans-unit id="7044c163171ec6f76f077a2bec8324df3677eec1" translate="yes" xml:space="preserve">
          <source>Vars::find_map</source>
          <target state="translated">Vars::find_map</target>
        </trans-unit>
        <trans-unit id="3b73b80a39e593c77029fbb50e77a9c267cde8cd" translate="yes" xml:space="preserve">
          <source>Vars::flat_map</source>
          <target state="translated">Vars::flat_map</target>
        </trans-unit>
        <trans-unit id="804f30eccc2a282312bcb332187a328e639337a6" translate="yes" xml:space="preserve">
          <source>Vars::flatten</source>
          <target state="translated">Vars::flatten</target>
        </trans-unit>
        <trans-unit id="4534d320518c99c9f5ec34ac48943387ea6be6eb" translate="yes" xml:space="preserve">
          <source>Vars::fmt</source>
          <target state="translated">Vars::fmt</target>
        </trans-unit>
        <trans-unit id="dcbe8ef4d0dae4b0a34ef3131b548dcabe7f720d" translate="yes" xml:space="preserve">
          <source>Vars::fold</source>
          <target state="translated">Vars::fold</target>
        </trans-unit>
        <trans-unit id="c0ce61b83b4e9c664534b8dfbab835e7e489b655" translate="yes" xml:space="preserve">
          <source>Vars::for_each</source>
          <target state="translated">Vars::for_each</target>
        </trans-unit>
        <trans-unit id="5dd1e805808b1f032c733423cbf4ac8a4c5a6981" translate="yes" xml:space="preserve">
          <source>Vars::from</source>
          <target state="translated">Vars::from</target>
        </trans-unit>
        <trans-unit id="af8c15b94b4468f337a1725be34d5554460f0a04" translate="yes" xml:space="preserve">
          <source>Vars::fuse</source>
          <target state="translated">Vars::fuse</target>
        </trans-unit>
        <trans-unit id="51bb1a81fecead1d604391ae02d739a62889b8ac" translate="yes" xml:space="preserve">
          <source>Vars::ge</source>
          <target state="translated">Vars::ge</target>
        </trans-unit>
        <trans-unit id="5b570a759e39ddbf689c5b76c7875f777d223503" translate="yes" xml:space="preserve">
          <source>Vars::gt</source>
          <target state="translated">Vars::gt</target>
        </trans-unit>
        <trans-unit id="e0b5b9d9e5ab4d21c95b05a37ba730388417d6b6" translate="yes" xml:space="preserve">
          <source>Vars::inspect</source>
          <target state="translated">Vars::inspect</target>
        </trans-unit>
        <trans-unit id="b8b6b4992b9eef91d9d506454c1498ee57011e6a" translate="yes" xml:space="preserve">
          <source>Vars::into</source>
          <target state="translated">Vars::into</target>
        </trans-unit>
        <trans-unit id="c48afb05fd046801df4e6edbf9f840dd304b60e1" translate="yes" xml:space="preserve">
          <source>Vars::into_iter</source>
          <target state="translated">Vars::into_iter</target>
        </trans-unit>
        <trans-unit id="e0ccc72484b281423161007f22d8a9293e1ba907" translate="yes" xml:space="preserve">
          <source>Vars::is_sorted</source>
          <target state="translated">Vars::is_sorted</target>
        </trans-unit>
        <trans-unit id="e191fd1f8c7ce00d777cb35f9c5c82504bbe7781" translate="yes" xml:space="preserve">
          <source>Vars::is_sorted_by</source>
          <target state="translated">Vars::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="eb9ca2ba30c83815b850a09d3feb972dfdc158e2" translate="yes" xml:space="preserve">
          <source>Vars::is_sorted_by_key</source>
          <target state="translated">Vars::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="6141318cc3ccabd5ae05e4611a7c5181f6046637" translate="yes" xml:space="preserve">
          <source>Vars::last</source>
          <target state="translated">Vars::last</target>
        </trans-unit>
        <trans-unit id="eecce1750e26f1ae1d749a4bae2b92eade287d53" translate="yes" xml:space="preserve">
          <source>Vars::le</source>
          <target state="translated">Vars::le</target>
        </trans-unit>
        <trans-unit id="b0904ac784f88af599fae6febadea78be6bd22be" translate="yes" xml:space="preserve">
          <source>Vars::lt</source>
          <target state="translated">Vars::lt</target>
        </trans-unit>
        <trans-unit id="aed51bf24598897e8d0ea447d651f3de39248cdc" translate="yes" xml:space="preserve">
          <source>Vars::map</source>
          <target state="translated">Vars::map</target>
        </trans-unit>
        <trans-unit id="8ab4e4308d5f56473c748138761d5bb14402ca33" translate="yes" xml:space="preserve">
          <source>Vars::max</source>
          <target state="translated">Vars::max</target>
        </trans-unit>
        <trans-unit id="5fbff539f6d31b21ce7158f6c6c1edd461357314" translate="yes" xml:space="preserve">
          <source>Vars::max_by</source>
          <target state="translated">Vars::max_by</target>
        </trans-unit>
        <trans-unit id="09ad51f2df0437fa8ff5bd6b68362c0cd8c5cfca" translate="yes" xml:space="preserve">
          <source>Vars::max_by_key</source>
          <target state="translated">Vars::max_by_key</target>
        </trans-unit>
        <trans-unit id="0ea5634589a7714b3ce13a9b994859ddc43c1472" translate="yes" xml:space="preserve">
          <source>Vars::min</source>
          <target state="translated">Vars::min</target>
        </trans-unit>
        <trans-unit id="84ccbe5bb178770383b19523a56c94a1a328c579" translate="yes" xml:space="preserve">
          <source>Vars::min_by</source>
          <target state="translated">Vars::min_by</target>
        </trans-unit>
        <trans-unit id="ef0e80e93b2480afa1eef5654b1d44253416e329" translate="yes" xml:space="preserve">
          <source>Vars::min_by_key</source>
          <target state="translated">Vars::min_by_key</target>
        </trans-unit>
        <trans-unit id="ed5f11b0702d02069bbdec987cd8231701e2f83d" translate="yes" xml:space="preserve">
          <source>Vars::ne</source>
          <target state="translated">Vars::ne</target>
        </trans-unit>
        <trans-unit id="5507ff5e66b6d746ac06bacbd6adfad687952f9d" translate="yes" xml:space="preserve">
          <source>Vars::next</source>
          <target state="translated">Vars::next</target>
        </trans-unit>
        <trans-unit id="aec94ecfda5dc5e8fd928e072a549d3135f6ad84" translate="yes" xml:space="preserve">
          <source>Vars::nth</source>
          <target state="translated">Vars::nth</target>
        </trans-unit>
        <trans-unit id="7b9faff88b13bea2403bdb806528b1b03e775923" translate="yes" xml:space="preserve">
          <source>Vars::partial_cmp</source>
          <target state="translated">Vars::partial_cmp</target>
        </trans-unit>
        <trans-unit id="2c2aef1b9bc3af83507c48a9bec747732d905de4" translate="yes" xml:space="preserve">
          <source>Vars::partition</source>
          <target state="translated">Vars::partition</target>
        </trans-unit>
        <trans-unit id="86900414ba1e745a10275dfdac62d2d9717049f6" translate="yes" xml:space="preserve">
          <source>Vars::peekable</source>
          <target state="translated">Vars::peekable</target>
        </trans-unit>
        <trans-unit id="20b949f960f581abec205874631185ffb7bb5fa1" translate="yes" xml:space="preserve">
          <source>Vars::position</source>
          <target state="translated">Vars::position</target>
        </trans-unit>
        <trans-unit id="8f8bd9d5815bdec99dfe7927fb90687bd92fab9b" translate="yes" xml:space="preserve">
          <source>Vars::product</source>
          <target state="translated">Vars::product</target>
        </trans-unit>
        <trans-unit id="9f0f47f9e4c4906312f7cde7ba18939a86f5931f" translate="yes" xml:space="preserve">
          <source>Vars::rev</source>
          <target state="translated">Vars::rev</target>
        </trans-unit>
        <trans-unit id="4a55d6ece90a2e102e6248bacf85b746657dbf67" translate="yes" xml:space="preserve">
          <source>Vars::rposition</source>
          <target state="translated">Vars::rposition</target>
        </trans-unit>
        <trans-unit id="ef63b4a7e167047c985114917f57fd0d737537fe" translate="yes" xml:space="preserve">
          <source>Vars::scan</source>
          <target state="translated">Vars::scan</target>
        </trans-unit>
        <trans-unit id="3551c9199efbcf81653d617970dabf0cd9ed3d99" translate="yes" xml:space="preserve">
          <source>Vars::size_hint</source>
          <target state="translated">Vars::size_hint</target>
        </trans-unit>
        <trans-unit id="7943d6f84fa998209693b43046c7975775eb51cd" translate="yes" xml:space="preserve">
          <source>Vars::skip</source>
          <target state="translated">Vars::skip</target>
        </trans-unit>
        <trans-unit id="2d1337e0ea678c9a71cefd99de6b48cd2e8b1203" translate="yes" xml:space="preserve">
          <source>Vars::skip_while</source>
          <target state="translated">Vars::skip_while</target>
        </trans-unit>
        <trans-unit id="9ad1eaaaf974f3fa2bff01f61e628ff1dd93b8e7" translate="yes" xml:space="preserve">
          <source>Vars::step_by</source>
          <target state="translated">Vars::step_by</target>
        </trans-unit>
        <trans-unit id="3cfd4ab54ebdd5fc54ce1f5c5cd82d3493150512" translate="yes" xml:space="preserve">
          <source>Vars::sum</source>
          <target state="translated">Vars::sum</target>
        </trans-unit>
        <trans-unit id="b11b3042c11657cd454ca8548f85ff8aeb32a4fd" translate="yes" xml:space="preserve">
          <source>Vars::take</source>
          <target state="translated">Vars::take</target>
        </trans-unit>
        <trans-unit id="70f8ea67196cc23888fa00b81267afd9a27d3c32" translate="yes" xml:space="preserve">
          <source>Vars::take_while</source>
          <target state="translated">Vars::take_while</target>
        </trans-unit>
        <trans-unit id="288b6c944d7368cdf54e313b28e14e5725efaa9b" translate="yes" xml:space="preserve">
          <source>Vars::try_fold</source>
          <target state="translated">Vars::try_fold</target>
        </trans-unit>
        <trans-unit id="cf043e48c60478e52e24f6c062f28fb96fba6f9d" translate="yes" xml:space="preserve">
          <source>Vars::try_for_each</source>
          <target state="translated">Vars::try_for_each</target>
        </trans-unit>
        <trans-unit id="b4fd24921ed57ce691083c1322eaf0856a89e518" translate="yes" xml:space="preserve">
          <source>Vars::try_from</source>
          <target state="translated">Vars::try_from</target>
        </trans-unit>
        <trans-unit id="1daadb045ef158df87f592275c11205ecf5af378" translate="yes" xml:space="preserve">
          <source>Vars::try_into</source>
          <target state="translated">Vars::try_into</target>
        </trans-unit>
        <trans-unit id="2e2cb28cd54a254643d5c8595fc8be18813e9b3a" translate="yes" xml:space="preserve">
          <source>Vars::type_id</source>
          <target state="translated">Vars::type_id</target>
        </trans-unit>
        <trans-unit id="6b38c485c26bfb440ab87bcbfba50961f6cb40d6" translate="yes" xml:space="preserve">
          <source>Vars::unzip</source>
          <target state="translated">Vars::unzip</target>
        </trans-unit>
        <trans-unit id="bbe99efeecd60ccb331cf47e045d9299f8d35e6e" translate="yes" xml:space="preserve">
          <source>Vars::zip</source>
          <target state="translated">Vars::zip</target>
        </trans-unit>
        <trans-unit id="b3dd49122e36d39473d927caf75a7a1efe1ad95f" translate="yes" xml:space="preserve">
          <source>VarsOs</source>
          <target state="translated">VarsOs</target>
        </trans-unit>
        <trans-unit id="0be42997f9c0fa87236d029096ab1f10b322e7b9" translate="yes" xml:space="preserve">
          <source>VarsOs::all</source>
          <target state="translated">VarsOs::all</target>
        </trans-unit>
        <trans-unit id="2f3479491bf53557e01f4e76c184381ed836098b" translate="yes" xml:space="preserve">
          <source>VarsOs::any</source>
          <target state="translated">VarsOs::any</target>
        </trans-unit>
        <trans-unit id="434053241a0ce77b4a57a19b617f9cd0e0d5e814" translate="yes" xml:space="preserve">
          <source>VarsOs::borrow</source>
          <target state="translated">VarsOs::borrow</target>
        </trans-unit>
        <trans-unit id="2d141f266e89d234f18a990d5d607d1646f48aee" translate="yes" xml:space="preserve">
          <source>VarsOs::borrow_mut</source>
          <target state="translated">VarsOs::borrow_mut</target>
        </trans-unit>
        <trans-unit id="425cc86c692b838ef921c23811c4e3302d1bdfc4" translate="yes" xml:space="preserve">
          <source>VarsOs::by_ref</source>
          <target state="translated">VarsOs::by_ref</target>
        </trans-unit>
        <trans-unit id="2ea472498ef341c6fb344b9d8ee413b4e6235be7" translate="yes" xml:space="preserve">
          <source>VarsOs::chain</source>
          <target state="translated">VarsOs::chain</target>
        </trans-unit>
        <trans-unit id="a8c6d8c806adad2da3dacb9238da96bf328655bd" translate="yes" xml:space="preserve">
          <source>VarsOs::cloned</source>
          <target state="translated">VarsOs::cloned</target>
        </trans-unit>
        <trans-unit id="fda36a1ed84216068b1296731249e671c956362c" translate="yes" xml:space="preserve">
          <source>VarsOs::cmp</source>
          <target state="translated">VarsOs::cmp</target>
        </trans-unit>
        <trans-unit id="2db35bab4983e6e4d87a02ad263efa15ddb43d0d" translate="yes" xml:space="preserve">
          <source>VarsOs::collect</source>
          <target state="translated">VarsOs::collect</target>
        </trans-unit>
        <trans-unit id="e1850e83c9e256bacb297e01d179d1197cc0db06" translate="yes" xml:space="preserve">
          <source>VarsOs::copied</source>
          <target state="translated">VarsOs::copied</target>
        </trans-unit>
        <trans-unit id="5c6630d2555a45d97d28a5536655aff9f9e9d3b8" translate="yes" xml:space="preserve">
          <source>VarsOs::count</source>
          <target state="translated">VarsOs::count</target>
        </trans-unit>
        <trans-unit id="f0ac502bdac4e93b09bdc50516564d5e56dc7727" translate="yes" xml:space="preserve">
          <source>VarsOs::cycle</source>
          <target state="translated">VarsOs::cycle</target>
        </trans-unit>
        <trans-unit id="a5e0728a5c9381105cc966f06f76ab6ed5f65903" translate="yes" xml:space="preserve">
          <source>VarsOs::enumerate</source>
          <target state="translated">VarsOs::enumerate</target>
        </trans-unit>
        <trans-unit id="0d4efb3a8d96184d450211631b5b79b1a60ab789" translate="yes" xml:space="preserve">
          <source>VarsOs::eq</source>
          <target state="translated">VarsOs::eq</target>
        </trans-unit>
        <trans-unit id="31db361add8338260d55916657c39337f09b86d7" translate="yes" xml:space="preserve">
          <source>VarsOs::filter</source>
          <target state="translated">VarsOs::filter</target>
        </trans-unit>
        <trans-unit id="0d0a62d2dca8a37393e2c92243786aaf41313690" translate="yes" xml:space="preserve">
          <source>VarsOs::filter_map</source>
          <target state="translated">VarsOs::filter_map</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
