<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="fe6abd0552b2b40662057338eb474072bfd467ab" translate="yes" xml:space="preserve">
          <source>It can be implemented very efficiently on many platforms.</source>
          <target state="translated">많은 플랫폼에서 매우 효율적으로 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1742a20f108d58ed46034272510180c651908ea6" translate="yes" xml:space="preserve">
          <source>It can be more efficient to read the contents of a file with a buffered &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;er. This can be accomplished with &lt;a href=&quot;../io/struct.bufreader&quot;&gt;&lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">버퍼를 가진 파일의 내용을 읽어하는 것이 더 효율적이 될 수 &lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; 어. 이것은으로 수행 할 수 있습니다 &lt;a href=&quot;../io/struct.bufreader&quot;&gt; &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="66395a368b8513422e9376d626f808ed1f8bf32e" translate="yes" xml:space="preserve">
          <source>It can be used to drop &lt;a href=&quot;../pin/index&quot;&gt;pinned&lt;/a&gt; data when &lt;code&gt;T&lt;/code&gt; is not &lt;code&gt;repr(packed)&lt;/code&gt; (pinned data must not be moved before it is dropped).</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;repr(packed)&lt;/code&gt; 되지 않은 경우 &lt;a href=&quot;../pin/index&quot;&gt;고정 된&lt;/a&gt; 데이터 를 삭제하는 데 사용할 수 있습니다 (고정 된 데이터는 삭제되기 전에 이동해서는 안 됨).</target>
        </trans-unit>
        <trans-unit id="7a115494bb139f55de5b0b3f70529477957a7f61" translate="yes" xml:space="preserve">
          <source>It can occur, for example, when giving ill-formed UTF-8 bytes to &lt;a href=&quot;../string/struct.string#method.from_utf8_lossy&quot;&gt;&lt;code&gt;String::from_utf8_lossy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">예를 들어 잘못된 형식의 UTF-8 바이트를 &lt;a href=&quot;../string/struct.string#method.from_utf8_lossy&quot;&gt; &lt;code&gt;String::from_utf8_lossy&lt;/code&gt; &lt;/a&gt; 제공 할 때 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99e2bcf85c866fbb510069805b1b10aa2dbd5078" translate="yes" xml:space="preserve">
          <source>It can occur, for example, when giving ill-formed UTF-8 bytes to &lt;a href=&quot;string/struct.string#method.from_utf8_lossy&quot;&gt;&lt;code&gt;String::from_utf8_lossy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">예를 들어 잘못된 형식의 UTF-8 바이트를 &lt;a href=&quot;string/struct.string#method.from_utf8_lossy&quot;&gt; &lt;code&gt;String::from_utf8_lossy&lt;/code&gt; &lt;/a&gt; 제공 할 때 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="865ab19a4feb80b70039c9bd315636afdebb41d4" translate="yes" xml:space="preserve">
          <source>It compiles! But note that if you try &lt;code&gt;cargo run&lt;/code&gt; and make a request in the browser, you&amp;rsquo;ll see the errors in the browser that we saw at the beginning of the chapter. Our library isn&amp;rsquo;t actually calling the closure passed to &lt;code&gt;execute&lt;/code&gt; yet!</source>
          <target state="translated">컴파일됩니다! 그러나 &lt;code&gt;cargo run&lt;/code&gt; 을 시도 하고 브라우저에서 요청하면 장 시작 부분에서 보았던 브라우저에서 오류를 볼 수 있습니다. 우리 라이브러리는 실제로 아직 &lt;code&gt;execute&lt;/code&gt; 하기 위해 전달 된 클로저를 호출하지 않습니다 !</target>
        </trans-unit>
        <trans-unit id="00fe0776828801d6e4d2d0000fdfe545e88338bd" translate="yes" xml:space="preserve">
          <source>It consists of a data pointer and a &lt;a href=&quot;https://en.wikipedia.org/wiki/Virtual_method_table&quot;&gt;virtual function pointer table (vtable)&lt;/a&gt; that customizes the behavior of the &lt;code&gt;RawWaker&lt;/code&gt;.</source>
          <target state="translated">데이터 포인터와 &lt;code&gt;RawWaker&lt;/code&gt; 의 동작을 사용자 정의 하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Virtual_method_table&quot;&gt;가상 함수 포인터 테이블 (vtable)로 &lt;/a&gt;구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="304308a190fdf4f0822058e40b620979e500ac31" translate="yes" xml:space="preserve">
          <source>It could also be that the browser is trying to connect to the server multiple times because the server isn&amp;rsquo;t responding with any data. When &lt;code&gt;stream&lt;/code&gt; goes out of scope and is dropped at the end of the loop, the connection is closed as part of the &lt;code&gt;drop&lt;/code&gt; implementation. Browsers sometimes deal with closed connections by retrying, because the problem might be temporary. The important factor is that we&amp;rsquo;ve successfully gotten a handle to a TCP connection!</source>
          <target state="translated">서버가 데이터로 응답하지 않기 때문에 브라우저가 서버에 여러 번 연결하려고 할 수도 있습니다. 경우 &lt;code&gt;stream&lt;/code&gt; 범위를 벗어나 루프의 끝 부분을 삭제, 연결의 일부로 폐쇄 &lt;code&gt;drop&lt;/code&gt; 구현. 일시적인 문제 일 수 있으므로 브라우저는 때때로 재 시도하여 닫힌 연결을 처리합니다. 중요한 요소는 TCP 연결을 성공적으로 처리했다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ade427f6a9f3a1335d386816dffbf2fdc2034717" translate="yes" xml:space="preserve">
          <source>It does &lt;em&gt;not&lt;/em&gt; give you:</source>
          <target state="translated">그것은 당신에게 주지 &lt;em&gt;않습니다&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="794a6ddebef5a3a25c88c1d2d823ee0600bddf9c" translate="yes" xml:space="preserve">
          <source>It does not have an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; implementation, so you can't use it in a &lt;code&gt;for&lt;/code&gt; loop directly. This won't compile:</source>
          <target state="translated">그것은이없는 &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; 의&lt;/a&gt; 당신이 그것을 사용할 수 있도록 구현을 &lt;code&gt;for&lt;/code&gt; 직접 루프. 이것은 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ffb73bdc252e7f6e26b2827c67cb797c04a45c79" translate="yes" xml:space="preserve">
          <source>It does not have an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; implementation, so you can't use it in a &lt;code&gt;for&lt;/code&gt; loop directly. This won't compile:</source>
          <target state="translated">그것은이없는 &lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; 의&lt;/a&gt; 당신이 그것을 사용할 수 있도록 구현을 &lt;code&gt;for&lt;/code&gt; 직접 루프. 이것은 컴파일되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="74bec73f805593fee91ebe017ac47c318ef63b70" translate="yes" xml:space="preserve">
          <source>It does pass! Let&amp;rsquo;s add another test, this time asserting that a smaller rectangle cannot hold a larger rectangle:</source>
          <target state="translated">통과합니다! 더 작은 사각형이 더 큰 사각형을 가질 수 없다고 주장하는 다른 테스트를 추가해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="e2bf564d4c76feec85879b21bc874b8175ee437c" translate="yes" xml:space="preserve">
          <source>It doesn&amp;rsquo;t matter if we mix up width and height for the area calculation, but if we want to draw the rectangle on the screen, it would matter! We would have to keep in mind that &lt;code&gt;width&lt;/code&gt; is the tuple index &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; is the tuple index &lt;code&gt;1&lt;/code&gt;. If someone else worked on this code, they would have to figure this out and keep it in mind as well. It would be easy to forget or mix up these values and cause errors, because we haven&amp;rsquo;t conveyed the meaning of our data in our code.</source>
          <target state="translated">면적 계산을 위해 너비와 높이를 섞어도 중요하지 않지만 화면에 사각형을 그리려면 중요합니다! &lt;code&gt;width&lt;/code&gt; 는 튜플 인덱스 &lt;code&gt;0&lt;/code&gt; 이고 &lt;code&gt;height&lt;/code&gt; 는 튜플 인덱스 &lt;code&gt;1&lt;/code&gt; 임을 명심해야합니다 . 다른 사람이이 코드를 연구했다면이를 파악하고 염두에 두어야합니다. 코드에서 데이터의 의미를 전달하지 않았기 때문에 이러한 값을 잊어 버리거나 혼합하여 오류를 발생시키는 것이 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="d52b4ba1c15e44e888e3928ea17d62d2f1924cb8" translate="yes" xml:space="preserve">
          <source>It exposes more ways to deal with platform-specific strings (&lt;code&gt;OsStr&lt;/code&gt;, &lt;code&gt;OsString&lt;/code&gt;), allows to set permissions more granularly, extract low-level file descriptors from files and sockets, and has platform-specific helpers for spawning processes.</source>
          <target state="translated">플랫폼 별 문자열 ( &lt;code&gt;OsStr&lt;/code&gt; , &lt;code&gt;OsString&lt;/code&gt; ) 을 처리하는 더 많은 방법을 제공하고 , 권한을보다 세밀하게 설정하고, 파일 및 소켓에서 하위 레벨 파일 디스크립터를 추출하며, 프로세스 생성을위한 플랫폼 별 헬퍼가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b00fd960002cfd9909fc9bce365f904914da1b7" translate="yes" xml:space="preserve">
          <source>It has also initialized a new Git repository along with a &lt;em&gt;.gitignore&lt;/em&gt; file. Git files won&amp;rsquo;t be generated if you run &lt;code&gt;cargo new&lt;/code&gt; within an existing Git repository; you can override this behavior by using &lt;code&gt;cargo new --vcs=git&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;em&gt;.gitignore&lt;/em&gt; 파일 과 함께 새 Git 저장소를 초기화했습니다 . 기존 Git 저장소 내에서 &lt;code&gt;cargo new&lt;/code&gt; 를 실행하면 Git 파일이 생성되지 않습니다 . &lt;code&gt;cargo new --vcs=git&lt;/code&gt; 을 사용하여이 동작을 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11abb8c04f2668a58f566442bd95936d3058b5af" translate="yes" xml:space="preserve">
          <source>It is &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; to call a function that is compiled with a feature that is not supported on the current platform the code is running on.</source>
          <target state="translated">코드가 실행되는 현재 플랫폼에서 지원되지 않는 기능으로 컴파일 된 함수를 호출하는 것은 &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;정의되지 않은 동작&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="14b8fe5823c3e0b4ead46dab65d150ba97815143" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;unsafe&lt;/code&gt; to access a static item declared in an extern block, whether or not it's mutable.</source>
          <target state="translated">변경 가능 여부에 관계없이 extern 블록에 선언 된 정적 항목에 액세스하는 것은 &lt;code&gt;unsafe&lt;/code&gt; 않습니다.</target>
        </trans-unit>
        <trans-unit id="789a56605a4c0fc94024c04229e1954360379606" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;required&lt;/em&gt; to use &lt;code&gt;drop_in_place&lt;/code&gt; to drop unsized types like trait objects, because they can't be read out onto the stack and dropped normally.</source>
          <target state="translated">됩니다 &lt;em&gt;필요한&lt;/em&gt; 사용에 &lt;code&gt;drop_in_place&lt;/code&gt; 들이 스택에 읽어 정상적으로 삭제 될 수 없기 때문에, 특성 객체처럼 크기가 지정되지 않은 유형을 드롭.</target>
        </trans-unit>
        <trans-unit id="122d47e267f58dbf245d83bbd151c9d835be4c42" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;not&lt;/strong&gt; considered an error if the entire buffer could not be written to this writer.</source>
          <target state="translated">그것은되어 &lt;strong&gt;있지&lt;/strong&gt; 전체 버퍼가이 작가에 기록 할 수없는 경우 오류로 간주.</target>
        </trans-unit>
        <trans-unit id="bf8bf34a5d274735d5f3f6b75aeb9079259905f3" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;not&lt;/strong&gt; recommended to use this function for a general try/catch mechanism. The &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type is more appropriate to use for functions that can fail on a regular basis. Additionally, this function is not guaranteed to catch all panics, see the &quot;Notes&quot; section below.</source>
          <target state="translated">되어 &lt;strong&gt;있지&lt;/strong&gt; 일반적인 시도 / 캐치 메커니즘이 기능을 사용하는 것이 좋습니다. &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 유형은 정기적으로 실패 할 수 있습니다 기능을 위해 사용하는 것이 더 적절하다. 또한이 기능으로 모든 패닉이 발생할 수 있습니다. 아래 &quot;참고&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b1a810a5051116223295807560408c5af68cd37c" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;not&lt;/strong&gt; recommended to use this function for a general try/catch mechanism. The &lt;a href=&quot;../thread/type.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type is more appropriate to use for functions that can fail on a regular basis. Additionally, this function is not guaranteed to catch all panics, see the &quot;Notes&quot; section below.</source>
          <target state="translated">되어 &lt;strong&gt;있지&lt;/strong&gt; 일반적인 시도 / 캐치 메커니즘이 기능을 사용하는 것이 좋습니다. &lt;a href=&quot;../thread/type.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 유형은 정기적으로 실패 할 수 있습니다 기능을 위해 사용하는 것이 더 적절하다. 또한이 기능이 모든 패닉을 포착하는 것은 아닙니다. 아래 &quot;참고&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f44c0918ab46b70725b0bcd2ecf83b8a768d4eb5" translate="yes" xml:space="preserve">
          <source>It is a logic error for a key to be modified in such a way that the key's hash, as determined by the &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait, or its equality, as determined by the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the map. This is normally only possible through &lt;a href=&quot;../../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 특성에 의해 결정된 키의 해시 또는 &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 특성에 의해 결정되는 동등성 이 맵에있는 동안 변경되는 방식으로 키를 수정하는 것은 논리 오류입니다 . 일반적으로 &lt;a href=&quot;../../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; , 전역 상태, I / O 또는 안전하지 않은 코드를 통해서만 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="d5c36c17020650b28936fe4d1b2ab87233144be8" translate="yes" xml:space="preserve">
          <source>It is a logic error for a key to be modified in such a way that the key's hash, as determined by the &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait, or its equality, as determined by the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the map. This is normally only possible through &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 특성에 의해 결정된 키의 해시 또는 &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 특성에 의해 결정되는 동등성 이 맵에있는 동안 변경되는 방식으로 키를 수정하는 것은 논리 오류입니다 . 일반적으로 &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; , 전역 상태, I / O 또는 안전하지 않은 코드를 통해서만 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="46331dafb0153e4395d3531f25654f92dc26340b" translate="yes" xml:space="preserve">
          <source>It is a logic error for a key to be modified in such a way that the key's ordering relative to any other key, as determined by the &lt;a href=&quot;../../cmp/trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the map. This is normally only possible through &lt;a href=&quot;../../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">&lt;a href=&quot;../../cmp/trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt; 특성에 의해 결정된 다른 키에 대한 키의 순서 가 맵에있는 동안 변경 되도록 키를 수정하는 것은 논리 오류입니다 . 일반적으로 &lt;a href=&quot;../../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; , 전역 상태, I / O 또는 안전하지 않은 코드를 통해서만 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="85493dfb2b8e297a25b008cf35e5fe74ede0c214" translate="yes" xml:space="preserve">
          <source>It is a logic error for a key to be modified in such a way that the key's ordering relative to any other key, as determined by the &lt;a href=&quot;../cmp/trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the map. This is normally only possible through &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">&lt;a href=&quot;../cmp/trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt; 특성에 의해 결정된 다른 키에 대한 키의 순서 가 맵에있는 동안 변경 되도록 키를 수정하는 것은 논리 오류입니다 . 일반적으로 &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; , 전역 상태, I / O 또는 안전하지 않은 코드를 통해서만 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="3a06bdad2097a07f5094016d13cc933d3f72af47" translate="yes" xml:space="preserve">
          <source>It is a logic error for an item to be modified in such a way that the item's hash, as determined by the &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait, or its equality, as determined by the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the set. This is normally only possible through &lt;a href=&quot;../../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">의해 결정되는 아이템의 해시 것과 같은 방식으로 변형 될 수있는 항목에 대한 논리 에러 인 &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 에 의해 결정되는 바와 같이, 특징, 또는 그 평등 &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 이 설정되는 동안 형질이 변화. 일반적으로 &lt;a href=&quot;../../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; , 전역 상태, I / O 또는 안전하지 않은 코드를 통해서만 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="d42ef3a74bef90b249465c06d2f032ccefb653f1" translate="yes" xml:space="preserve">
          <source>It is a logic error for an item to be modified in such a way that the item's hash, as determined by the &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait, or its equality, as determined by the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the set. This is normally only possible through &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">의해 결정되는 아이템의 해시 것과 같은 방식으로 변형 될 수있는 항목에 대한 논리 에러 인 &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 에 의해 결정되는 바와 같이, 특징, 또는 그 평등 &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 이 설정되는 동안 형질이 변화. 일반적으로 &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; , 전역 상태, I / O 또는 안전하지 않은 코드를 통해서만 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="3ab5c67b79a448ca7bc9aba52ab29aac6f49d326" translate="yes" xml:space="preserve">
          <source>It is a logic error for an item to be modified in such a way that the item's ordering relative to any other item, as determined by the &lt;a href=&quot;../../cmp/trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the set. This is normally only possible through &lt;a href=&quot;../../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">&lt;a href=&quot;../../cmp/trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt; 특성에 의해 결정된 바와 같이, 다른 아이템에 대한 아이템의 순서 가 세트 내에있는 동안 변경되는 방식으로 아이템을 수정하는 것은 논리 에러 이다. 일반적으로 &lt;a href=&quot;../../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; , 전역 상태, I / O 또는 안전하지 않은 코드를 통해서만 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="81558e504ca17a10e655e3f35b43a6c2e19151af" translate="yes" xml:space="preserve">
          <source>It is a logic error for an item to be modified in such a way that the item's ordering relative to any other item, as determined by the &lt;a href=&quot;../cmp/trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the set. This is normally only possible through &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">&lt;a href=&quot;../cmp/trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt; 특성에 의해 결정된 바와 같이, 다른 아이템에 대한 아이템의 순서 가 세트 내에있는 동안 변경되는 방식으로 아이템을 수정하는 것은 논리 에러 이다. 일반적으로 &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; , 전역 상태, I / O 또는 안전하지 않은 코드를 통해서만 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="5e476b6f2887551b48a3be2ee9ea6d582ce86836" translate="yes" xml:space="preserve">
          <source>It is a logic error for an item to be modified in such a way that the item's ordering relative to any other item, as determined by the &lt;code&gt;Ord&lt;/code&gt; trait, changes while it is in the heap. This is normally only possible through &lt;code&gt;Cell&lt;/code&gt;, &lt;code&gt;RefCell&lt;/code&gt;, global state, I/O, or unsafe code.</source>
          <target state="translated">&lt;code&gt;Ord&lt;/code&gt; 특성에 의해 결정된대로 다른 항목에 대한 항목의 순서 가 힙에있는 동안 변경되는 방식으로 항목을 수정하는 것은 논리적 오류입니다 . 일반적으로 &lt;code&gt;Cell&lt;/code&gt; , &lt;code&gt;RefCell&lt;/code&gt; , 전역 상태, I / O 또는 안전하지 않은 코드를 통해서만 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="a1fecc95182812f5ebb362d1bac59ac94dc2f98d" translate="yes" xml:space="preserve">
          <source>It is a multiple of the alignment, including zero. The size can change depending on compiler version (as new optimizations are made) and target platform (similar to how &lt;code&gt;usize&lt;/code&gt; varies per-platform).</source>
          <target state="translated">0을 포함하여 정렬의 배수입니다. 크기는 컴파일러 버전 (새 최적화가 &lt;code&gt;usize&lt;/code&gt; ) 및 대상 플랫폼 (사용 방법 이 플랫폼마다 다릅니다 )에 따라 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78d00f7fd123a3c3fdf75cbae3233ae2e6e3470e" translate="yes" xml:space="preserve">
          <source>It is allowed for the strong count to be 0 at the time of calling this. Nevertheless, this takes ownership of one weak reference currently represented as a raw pointer (the weak count is not modified by this operation) and therefore it must be paired with a previous call to &lt;a href=&quot;struct.weak#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것을 호출 할 때 강한 카운트는 0이 될 수 있습니다. 그럼에도 불구하고 이것은 현재 원시 포인터로 표시된 하나의 약한 참조의 소유권을 취하므로 (약한 수는이 작업에 의해 수정되지 않음) 이전 &lt;a href=&quot;struct.weak#method.into_raw&quot;&gt; &lt;code&gt;into_raw&lt;/code&gt; &lt;/a&gt; 호출과 쌍을 이루어야 합니다.</target>
        </trans-unit>
        <trans-unit id="a0f9d3e3312ad57e5a6d3bcdd50a937a22f832b6" translate="yes" xml:space="preserve">
          <source>It is also an error to have an unspecified discriminant where the previous discriminant is the maximum value for the size of the discriminant.</source>
          <target state="translated">또한 이전 판별자가 판별 기의 크기에 대한 최대 값 인 지정되지 않은 판별기를 갖는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="2aaa72db942d7c7ea290053204f195dee9198e63" translate="yes" xml:space="preserve">
          <source>It is also possible that immediately after &lt;code&gt;is_completed&lt;/code&gt; returns false, some other thread finishes executing &lt;code&gt;call_once&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;is_completed&lt;/code&gt; 가 즉시 false를 리턴하면 일부 다른 스레드가 &lt;code&gt;call_once&lt;/code&gt; 실행을 완료 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="19ceccce9e9543f68e6cf0b82b34ef37c7f04824" translate="yes" xml:space="preserve">
          <source>It is also possible to manually transmute:</source>
          <target state="translated">수동으로 변환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9152c587c216123563f72b60e624fb7b37150c7" translate="yes" xml:space="preserve">
          <source>It is also possible to overload most operators for your own type by implementing the &lt;code&gt;[OP]Assign&lt;/code&gt; traits from &lt;code&gt;std::ops&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::ops&lt;/code&gt; 에서 &lt;code&gt;[OP]Assign&lt;/code&gt; 특성을 구현하여 자신의 유형에 맞는 대부분의 연산자를 오버로드 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c720012a3e805c9d62f2435d313e2b4c97a82fa" translate="yes" xml:space="preserve">
          <source>It is also possible to overload most operators for your own type by implementing traits from &lt;code&gt;std::ops&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::ops&lt;/code&gt; 특성을 구현하여 자신의 유형에 맞는 대부분의 연산자를 오버로드 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="665d59482618a683a851550ec2845d9aceb97fe9" translate="yes" xml:space="preserve">
          <source>It is also possible to use &lt;code&gt;super&lt;/code&gt; multiple times: &lt;code&gt;super::super::foo&lt;/code&gt;, going up the ancestor chain.</source>
          <target state="translated">&lt;code&gt;super&lt;/code&gt; 를 여러 번 사용할 수도 있습니다 : &lt;code&gt;super::super::foo&lt;/code&gt; , 상위 체인으로 올라갑니다.</target>
        </trans-unit>
        <trans-unit id="12a0c387e81a8235a99c7d165954f2002b18f388" translate="yes" xml:space="preserve">
          <source>It is an error for &lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;zero-variant enumerations&lt;/a&gt; to have a primitive representation.</source>
          <target state="translated">&lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;제로 변형 열거&lt;/a&gt; 가 기본 표현을 갖는 것은 오류입니다 .</target>
        </trans-unit>
        <trans-unit id="8b8784e54718e2a6d91bae7b9a9deae29e0d7cb7" translate="yes" xml:space="preserve">
          <source>It is an error for &lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;zero-variant enumerations&lt;/a&gt; to have the &lt;code&gt;C&lt;/code&gt; representation.</source>
          <target state="translated">&lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;제로 변형 열거&lt;/a&gt; 에 &lt;code&gt;C&lt;/code&gt; 표현 이있는 것은 오류입니다 .</target>
        </trans-unit>
        <trans-unit id="c5e73da35c291d17423e4b430565c57bff241da2" translate="yes" xml:space="preserve">
          <source>It is an error to define two associated items (like methods, associated types, associated functions, etc.) with the same identifier.</source>
          <target state="translated">동일한 식별자로 두 개의 연관된 항목 (예 : 메소드, 연관된 유형, 연관된 함수 등)을 정의하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="1ecd71d2b66919da6bca2d4ca4f7a151af58acc5" translate="yes" xml:space="preserve">
          <source>It is an error to pass a zero &lt;code&gt;Duration&lt;/code&gt; to this function.</source>
          <target state="translated">이 함수에 제로 &lt;code&gt;Duration&lt;/code&gt; 을 전달하면 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="c705f9525d896b896f63b638e17d43664425dcf5" translate="yes" xml:space="preserve">
          <source>It is an error when two variants share the same discriminant.</source>
          <target state="translated">두 변형이 동일한 판별 변수를 공유하면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="2f90cd6ec421d6e869d99b74e53a91895af9c5d9" translate="yes" xml:space="preserve">
          <source>It is available for use in stable rust from version 1.39 onwards.</source>
          <target state="translated">1.39 버전부터 안정적인 녹에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e066ad57d2ce7768c716de2f11bbba9cfbc5ef3" translate="yes" xml:space="preserve">
          <source>It is common to forget the trailing &lt;code&gt;!&lt;/code&gt; on macro invocations, which would also yield this error:</source>
          <target state="translated">후행을 잊는 것이 일반적입니다 &lt;code&gt;!&lt;/code&gt; 매크로 호출 에서이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ab682946a2c7b0a4e860227b119766dc69c7e1ad" translate="yes" xml:space="preserve">
          <source>It is common to use &lt;code&gt;IntoIterator&lt;/code&gt; as a trait bound. This allows the input collection type to change, so long as it is still an iterator. Additional bounds can be specified by restricting on &lt;code&gt;Item&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;IntoIterator&lt;/code&gt; 를 특성 바운드로 사용하는 것이 일반적 입니다. 이렇게하면 입력 반복 유형이 여전히 반복자 인 한 입력 콜렉션 유형을 변경할 수 있습니다. &lt;code&gt;Item&lt;/code&gt; 을 제한하여 추가 범위를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24d52c7dd0ec99d9a6af7862341acee02c183bdc" translate="yes" xml:space="preserve">
          <source>It is common to use the &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; iterator adapter to turn an infinite iterator into a finite one:</source>
          <target state="translated">&lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 반복기 어댑터 를 사용하여 무한 반복기를 유한 반복자로 바꾸는 것이 일반적입니다 .</target>
        </trans-unit>
        <trans-unit id="c95bb9f004735a87f727f19d983aa3691d7d3210" translate="yes" xml:space="preserve">
          <source>It is considered an error if not all bytes could be written due to I/O errors or EOF being reached.</source>
          <target state="translated">I / O 오류 또는 EOF에 도달하여 모든 바이트를 쓸 수있는 경우 오류로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="3bd73943cb17deb4f2b3ccabad843f693f98447d" translate="yes" xml:space="preserve">
          <source>It is considered an error if the directory already exists unless recursive mode is enabled.</source>
          <target state="translated">재귀 모드를 사용하지 않으면 디렉토리가 이미 존재하면 오류로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="537243f1f25a0d4711910325fd3d083b4262a463" translate="yes" xml:space="preserve">
          <source>It is critical to call &lt;a href=&quot;trait.write#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; before &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt; is dropped. Though dropping will attempt to flush the contents of the buffer, any errors that happen in the process of dropping will be ignored. Calling &lt;a href=&quot;trait.write#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; ensures that the buffer is empty and thus dropping will not even attempt file operations.</source>
          <target state="translated">&lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt; 가 삭제 되기 전에 &lt;a href=&quot;trait.write#tymethod.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; 를 호출하는 것이 중요합니다 . 삭제는 버퍼의 내용을 플러시하려고 시도하지만 삭제 과정에서 발생하는 오류는 무시됩니다. &lt;a href=&quot;trait.write#tymethod.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; 를&lt;/a&gt; 호출 하면 버퍼가 비어 있으므로 삭제는 파일 작업을 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60b8c7a920e8c6cdcbcebde2d4eda5f284d3bbea" translate="yes" xml:space="preserve">
          <source>It is currently impossible to create raw pointers to unaligned fields of a packed struct.</source>
          <target state="translated">현재 패킹 된 구조체의 정렬되지 않은 필드에 대한 원시 포인터를 만드는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="c5c36c5e7602baf3c3616b07cef1f3665caf1d22" translate="yes" xml:space="preserve">
          <source>It is currently undefined behavior to unwind from Rust code into foreign code, so this function is particularly useful when Rust is called from another language (normally C). This can run arbitrary Rust code, capturing a panic and allowing a graceful handling of the error.</source>
          <target state="translated">Rust 코드에서 외부 코드로 풀리는 것은 현재 정의되지 않은 동작이므로,이 함수는 Rust가 다른 언어 (일반적으로 C)에서 호출 될 때 특히 유용합니다. 이것은 임의의 녹 코드를 실행하여 공황을 포착하고 오류를 정상적으로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="5c66ccca042f9b01dffd3651727dd1995756e7b3" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;OpenOptions::new()&lt;/code&gt; but allows you to write more readable code. Instead of &lt;code&gt;OpenOptions::new().read(true).open(&quot;foo.txt&quot;)&lt;/code&gt; you can write &lt;code&gt;File::with_options().read(true).open(&quot;foo.txt&quot;)&lt;/code&gt;. This also avoids the need to import &lt;code&gt;OpenOptions&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OpenOptions::new()&lt;/code&gt; 와 동일 하지만 더 읽기 쉬운 코드를 작성할 수 있습니다. 대신 &lt;code&gt;OpenOptions::new().read(true).open(&quot;foo.txt&quot;)&lt;/code&gt; 당신이 쓸 수있는 &lt;code&gt;File::with_options().read(true).open(&quot;foo.txt&quot;)&lt;/code&gt; . 또한 &lt;code&gt;OpenOptions&lt;/code&gt; 를 가져올 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="dae5ff64ed07894b48692747efd0c02dda81558f" translate="yes" xml:space="preserve">
          <source>It is fine only if you put something back. &lt;code&gt;mem::replace&lt;/code&gt; can be used for that:</source>
          <target state="translated">무언가를 다시 넣으면 괜찮습니다. &lt;code&gt;mem::replace&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c557fd6825bdb89ba5f031ec165be0dd6a26ff58" translate="yes" xml:space="preserve">
          <source>It is friendlier to the optimizer to do this over &lt;a href=&quot;../ptr/fn.read&quot;&gt;&lt;code&gt;ptr::read&lt;/code&gt;&lt;/a&gt; when dropping manually allocated memory (e.g., when writing Box/Rc/Vec), as the compiler doesn't need to prove that it's sound to elide the copy.</source>
          <target state="translated">컴파일러가 복사본을 제거하는 것이 소리임을 증명할 필요가 없기 때문에 수동으로 할당 된 메모리를 떨어 뜨릴 때 (예 : Box / Rc / Vec를 쓰는 경우) &lt;a href=&quot;../ptr/fn.read&quot;&gt; &lt;code&gt;ptr::read&lt;/code&gt; &lt;/a&gt; 통해이 작업을 수행하는 것이 옵티 마이저에게 더 친숙합니다 .</target>
        </trans-unit>
        <trans-unit id="98cf066d0eeb6931da37108448f70da379f6d2ff" translate="yes" xml:space="preserve">
          <source>It is friendlier to the optimizer to do this over &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;ptr::read&lt;/code&gt;&lt;/a&gt; when dropping manually allocated memory (e.g., when writing Box/Rc/Vec), as the compiler doesn't need to prove that it's sound to elide the copy.</source>
          <target state="translated">컴파일러가 복사본을 제거하는 것이 소리임을 증명할 필요가 없기 때문에 수동으로 할당 된 메모리를 떨어 뜨릴 때 (예 : Box / Rc / Vec를 쓰는 경우) &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;ptr::read&lt;/code&gt; &lt;/a&gt; 통해이 작업을 수행하는 것이 옵티 마이저에게 더 친숙합니다 .</target>
        </trans-unit>
        <trans-unit id="ed685795cf4962708592336505a9a35be53c890e" translate="yes" xml:space="preserve">
          <source>It is further guaranteed that, for the cases above, one can &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;mem::transmute&lt;/code&gt;&lt;/a&gt; from all valid values of &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and from &lt;code&gt;Some::&amp;lt;T&amp;gt;(_)&lt;/code&gt; to &lt;code&gt;T&lt;/code&gt; (but transmuting &lt;code&gt;None::&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;T&lt;/code&gt; is undefined behaviour).</source>
          <target state="translated">또한 위의 경우 &lt;code&gt;T&lt;/code&gt; 의 모든 유효한 값 에서 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;Some::&amp;lt;T&amp;gt;(_)&lt;/code&gt; 에서 &lt;code&gt;T&lt;/code&gt; 로&lt;a href=&quot;../mem/fn.transmute&quot;&gt; &lt;code&gt;mem::transmute&lt;/code&gt; &lt;/a&gt; 할 수 있습니다 (그러나 &lt;code&gt;None::&amp;lt;T&amp;gt;&lt;/code&gt; 변환). 에 &lt;code&gt;T&lt;/code&gt; 가 ) 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="a482eb06332931aa49748cd7170635733f6d060d" translate="yes" xml:space="preserve">
          <source>It is important to note that although the returned vector has the &lt;em&gt;capacity&lt;/em&gt; specified, the vector will have a zero &lt;em&gt;length&lt;/em&gt;. For an explanation of the difference between length and capacity, see &lt;em&gt;&lt;a href=&quot;#capacity-and-reallocation&quot;&gt;Capacity and reallocation&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">반환 된 벡터에 지정된 &lt;em&gt;용량&lt;/em&gt; 이 있지만 벡터의 &lt;em&gt;길이&lt;/em&gt; 는 0 &lt;em&gt;입니다&lt;/em&gt; . 길이와 용량의 차이에 대한 설명은 &lt;em&gt;&lt;a href=&quot;#capacity-and-reallocation&quot;&gt;용량 및 재 할당을&lt;/a&gt;&lt;/em&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3de289a473969bb492d7f49323becca72758c15" translate="yes" xml:space="preserve">
          <source>It is important to note that both back and forth work on the same range, and do not cross: iteration is over when they meet in the middle.</source>
          <target state="translated">앞뒤로 동일한 범위에서 작동하고 교차하지 마십시오. 반복이 중간에서 만나면 끝납니다.</target>
        </trans-unit>
        <trans-unit id="688443f49dee6c57698fbe38d0a4fd0c6b98badb" translate="yes" xml:space="preserve">
          <source>It is important to understand that &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; does not provide a &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; implementation (as &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; does with &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;). Therefore, you should always try to implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and then fall back to &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; if &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; can't be implemented.</source>
          <target state="translated">&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 구현을 제공하지 않는다는 점을 이해하는 것이 중요합니다 ( &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 와 동일 함 ). 따라서, 당신은 항상 구현하는 시도해야 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 다음에 다시 가을 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 경우 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 구현 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0b60eba4804f29ceedf6d48ba368778e00e21367" translate="yes" xml:space="preserve">
          <source>It is impossible to define an integer type to be used to represent zero-variant enum values because there are no zero-variant enum values. There is no way to construct an instance of the following type using only safe code. So you have two solutions. Either you add variants in your enum:</source>
          <target state="translated">제로 변형 열거 형 값이 없으므로 제로 변형 열거 형 값을 나타내는 데 사용할 정수 유형을 정의 할 수 없습니다. 안전한 코드 만 사용하여 다음 유형의 인스턴스를 구성 할 방법이 없습니다. 따라서 두 가지 솔루션이 있습니다. 열거 형에 변형을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="4d5291d52684a5eab8a4aab9333d7cc4b2cb958b" translate="yes" xml:space="preserve">
          <source>It is inadvisable to directly read from the underlying reader.</source>
          <target state="translated">기본 독자로부터 직접 읽는 것은 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3c4bfe06953b97ae05b73dab70d1d3859db96ce" translate="yes" xml:space="preserve">
          <source>It is inadvisable to directly write to the underlying writer.</source>
          <target state="translated">기본 작성자에게 직접 쓰는 것은 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ec3e32d91034e8ec262cdcaaa5495ade82532d3" translate="yes" xml:space="preserve">
          <source>It is legal to declare a function that is both async and unsafe. The resulting function is unsafe to call and (like any async function) returns a future. This future is just an ordinary future and thus an &lt;code&gt;unsafe&lt;/code&gt; context is not required to &quot;await&quot; it:</source>
          <target state="translated">비동기적이고 안전하지 않은 함수를 선언하는 것은 합법적입니다. 결과 함수는 호출하기에 안전하지 않으며 (비동기 함수처럼) 퓨처를 반환합니다. 이 미래는 평범한 미래이므로 &lt;code&gt;unsafe&lt;/code&gt; 컨텍스트는 &quot;기다릴&quot;필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f3dbb1246b199ac521c8acb1693aa5061246652a" translate="yes" xml:space="preserve">
          <source>It is not a compile-time error if &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; have different sizes, but it is highly encouraged to only invoke this function where &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; have the same size. This function triggers &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; if &lt;code&gt;U&lt;/code&gt; is larger than &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; 의 크기가 다른 경우 컴파일 타임 오류가 아니지만 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; 의 크기가 동일한 경우에만이 함수를 호출하는 것이 좋습니다 . 이 함수 는 &lt;code&gt;U&lt;/code&gt; 가 &lt;code&gt;T&lt;/code&gt; 보다 큰 경우 &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;정의되지 않은 동작을&lt;/a&gt; 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="c8633689304bc80e12157956bafdee7aa5571ef8" translate="yes" xml:space="preserve">
          <source>It is not allowed to cast to a bool.</source>
          <target state="translated">bool로 캐스팅 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="804904553c24d5c3119a2a373f46ee3afe1e1bcf" translate="yes" xml:space="preserve">
          <source>It is not allowed to cast to a bool. If you are trying to cast a numeric type to a bool, you can compare it with zero instead:</source>
          <target state="translated">부울에 캐스팅 할 수 없습니다. 숫자 유형을 부울로 캐스트하려는 경우 대신 0과 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fc97c498b6845f6dd515270a06b8fc333df6ada" translate="yes" xml:space="preserve">
          <source>It is not allowed to manually call destructors in Rust.</source>
          <target state="translated">Rust에서 소멸자를 수동으로 호출하는 것은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="16c9437daa5a5b2d54fcaf5cf82931c13dd48503" translate="yes" xml:space="preserve">
          <source>It is not allowed to manually call destructors in Rust. It is also not necessary to do this since &lt;code&gt;drop&lt;/code&gt; is called automatically whenever a value goes out of scope.</source>
          <target state="translated">Rust에서는 소멸자를 수동으로 호출 할 수 없습니다. 값이 범위를 벗어날 때마다 &lt;code&gt;drop&lt;/code&gt; 이 자동으로 호출 되므로이를 수행 할 필요도 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0af3651d21c13332936be1aeb070069427b04863" translate="yes" xml:space="preserve">
          <source>It is not allowed to use or capture an uninitialized variable.</source>
          <target state="translated">초기화되지 않은 변수를 사용하거나 캡처 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7767b89b540932cb942c6e1844049703b82b847b" translate="yes" xml:space="preserve">
          <source>It is not allowed to use or capture an uninitialized variable. For example:</source>
          <target state="translated">초기화되지 않은 변수는 사용하거나 캡처 할 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ec565a6be063138e105edece3d9609dbd23ba59" translate="yes" xml:space="preserve">
          <source>It is not always equivalent to a closure like &lt;code&gt;|x| x&lt;/code&gt; since the closure may coerce &lt;code&gt;x&lt;/code&gt; into a different type.</source>
          <target state="translated">항상 &lt;code&gt;|x| x&lt;/code&gt; 와 같은 클로저와 동일하지는 않습니다. X 폐쇄가 강요 할 수 있기 때문에 &lt;code&gt;x&lt;/code&gt; 다른 유형으로.</target>
        </trans-unit>
        <trans-unit id="d85afe6ee8d10535dc66c9e1b7be7b3cdd688a64" translate="yes" xml:space="preserve">
          <source>It is not always equivalent to a closure like &lt;code&gt;|x| x&lt;/code&gt;, since the closure may coerce &lt;code&gt;x&lt;/code&gt; into a different type.</source>
          <target state="translated">&lt;code&gt;|x| x&lt;/code&gt; 와 같은 클로저와 항상 동일하지는 않습니다. x , 클로저가 &lt;code&gt;x&lt;/code&gt; 를 다른 유형으로 강제 할 수 있기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="f1671d6fa1d906f29299a5bc6eb309657467bdad" translate="yes" xml:space="preserve">
          <source>It is not an error if the returned value &lt;code&gt;n&lt;/code&gt; is smaller than the buffer size, even when the reader is not at the end of the stream yet. This may happen for example because fewer bytes are actually available right now (e. g. being close to end-of-file) or because read() was interrupted by a signal.</source>
          <target state="translated">판독기가 아직 스트림의 끝에 있지 않더라도 반환 된 값 &lt;code&gt;n&lt;/code&gt; 이 버퍼 크기보다 작 으면 오류 가 아닙니다. 예를 들어, 현재 사용 가능한 바이트 수가 더 적거나 (예 : 파일 끝에 가까움) read ()가 신호에 의해 중단 되었기 때문에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d7dcfb4170b72e2facf78d57d95eed97b2a6250" translate="yes" xml:space="preserve">
          <source>It is not an error to define a macro multiple times; the most recent declaration will shadow the previous one unless it has gone out of scope.</source>
          <target state="translated">매크로를 여러 번 정의하는 것은 오류가 아닙니다. 가장 최근의 선언은 범위를 벗어나지 않는 한 이전 선언을 어둡게합니다.</target>
        </trans-unit>
        <trans-unit id="fe10caafa0ee23dcebc8469f9e22713be6e1455c" translate="yes" xml:space="preserve">
          <source>It is not enforced that an iterator implementation yields the declared number of elements. A buggy iterator may yield less than the lower bound or more than the upper bound of elements.</source>
          <target state="translated">반복자 구현이 선언 된 수의 요소를 생성하도록 강요되지는 않습니다. 버기 반복자는 요소의 하한보다 작거나 상한보다 더 많이 산출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8f822d10fd7f248875122ae295429f7075d08d7" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that the memory pointed by &lt;code&gt;ptr&lt;/code&gt; won't change before the &lt;code&gt;CStr&lt;/code&gt; has been destroyed.</source>
          <target state="translated">&lt;code&gt;CStr&lt;/code&gt; 이 소멸 되기 전에 &lt;code&gt;ptr&lt;/code&gt; 이 가리키는 메모리가 변경되지 않는다는 보장은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="63ef7dab9cc8c89ff48dae3884d5439039407f4c" translate="yes" xml:space="preserve">
          <source>It is not intended that most types or functions need to worry about this trait. It is only used as a bound on the &lt;code&gt;catch_unwind&lt;/code&gt; function and as mentioned above, the lack of &lt;code&gt;unsafe&lt;/code&gt; means it is mostly an advisory. The &lt;a href=&quot;struct.assertunwindsafe&quot;&gt;&lt;code&gt;AssertUnwindSafe&lt;/code&gt;&lt;/a&gt; wrapper struct can be used to force this trait to be implemented for any closed over variables passed to &lt;code&gt;catch_unwind&lt;/code&gt;.</source>
          <target state="translated">대부분의 유형 또는 기능이이 특성에 대해 걱정할 필요는 없습니다. &lt;code&gt;catch_unwind&lt;/code&gt; 함수 에 대한 경계로만 사용되며 위에서 언급했듯이 &lt;code&gt;unsafe&lt;/code&gt; 것은 대부분 권고 사항임을 의미합니다. &lt;a href=&quot;struct.assertunwindsafe&quot;&gt; &lt;code&gt;AssertUnwindSafe&lt;/code&gt; &lt;/a&gt; 구조체 래퍼로 전달 된 변수 닫혀 구현되는 특징이 강제로 사용될 수 &lt;code&gt;catch_unwind&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="34f3040279fd242d13257751040f971829001939" translate="yes" xml:space="preserve">
          <source>It is not necessary to annotate the full type. Once the ambiguity is resolved, the compiler can infer the rest:</source>
          <target state="translated">전체 유형에 주석을 달 필요는 없습니다. 모호성이 해결되면 컴파일러가 나머지를 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79ac203d9d8f6d2d15f792ef9b54266d902c1bf2" translate="yes" xml:space="preserve">
          <source>It is not possible to declare type parameters on a function that has the &lt;code&gt;start&lt;/code&gt; attribute. Such a function must have the following type signature (for more information, view &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib&quot;&gt;the unstable book&lt;/a&gt;):</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 속성 이있는 함수에서 유형 매개 변수를 선언 할 수 없습니다 . 이러한 함수에는 다음과 같은 형식 서명이 있어야합니다 (자세한 내용 &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib&quot;&gt;은 불안정한 서적 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="de00175d000048a3ab2db1da305a9746730281d2" translate="yes" xml:space="preserve">
          <source>It is not possible to define &lt;code&gt;main&lt;/code&gt; with a where clause.</source>
          <target state="translated">where 절을 사용하여 &lt;code&gt;main&lt;/code&gt; 을 정의 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9b5f5303b9508d3572ecb0aabe587d9c97215e2a" translate="yes" xml:space="preserve">
          <source>It is not possible to define &lt;code&gt;main&lt;/code&gt; with a where clause. Erroneous code example:</source>
          <target state="translated">where 절로 &lt;code&gt;main&lt;/code&gt; 을 정의 할 수 없습니다 . 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="d0b1c5c12eac01beb248497b03a0ab70e561e5a5" translate="yes" xml:space="preserve">
          <source>It is not possible to define &lt;code&gt;main&lt;/code&gt; with generic parameters. When &lt;code&gt;main&lt;/code&gt; is present, it must take no arguments and return &lt;code&gt;()&lt;/code&gt;. Erroneous code example:</source>
          <target state="translated">일반 매개 변수로 &lt;code&gt;main&lt;/code&gt; 을 정의 할 수 없습니다 . &lt;code&gt;main&lt;/code&gt; 이 존재 하면 인수를 취하지 않고 &lt;code&gt;()&lt;/code&gt; 를 리턴해야합니다 . 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="dac867cdafaa004a57591e1391a5068dc6cc6e4a" translate="yes" xml:space="preserve">
          <source>It is not possible to define &lt;code&gt;start&lt;/code&gt; with a where clause. Erroneous code example:</source>
          <target state="translated">where 절로 &lt;code&gt;start&lt;/code&gt; 을 정의 할 수 없습니다 . 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="77edaee193e2b26f0dc132c04fc983d7a3f09123" translate="yes" xml:space="preserve">
          <source>It is not possible to define the &lt;code&gt;main&lt;/code&gt; function with generic parameters. It must not take any arguments.</source>
          <target state="translated">일반 매개 변수로 &lt;code&gt;main&lt;/code&gt; 함수 를 정의 할 수 없습니다 . 인수를 가져서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="42e4484b8793e84f3d96cf9d91150a25ddc1b027" translate="yes" xml:space="preserve">
          <source>It is not possible to use stability attributes outside of the standard library. Also, for now, it is not possible to write deprecation messages either.</source>
          <target state="translated">표준 라이브러리 외부에서는 안정성 속성을 사용할 수 없습니다. 또한 현재로서는 지원 중단 메시지를 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4bacc3cad49d167308e0fdf3be52c1450a1de33" translate="yes" xml:space="preserve">
          <source>It is not valid to put positional parameters (those without names) after arguments that have names. Like with positional parameters, it is not valid to provide named parameters that are unused by the format string.</source>
          <target state="translated">이름이있는 인수 뒤에 위치 매개 변수 (이름이없는 매개 변수)를 넣는 것은 유효하지 않습니다. 위치 매개 변수와 마찬가지로 형식 문자열에서 사용하지 않는 명명 된 매개 변수를 제공하는 것은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="babf4563d827f22cdca258081ab4debae3695f91" translate="yes" xml:space="preserve">
          <source>It is not valid to put positional parameters (those without names) after arguments which have names. Like with positional parameters, it is not valid to provide named parameters that are unused by the format string.</source>
          <target state="translated">이름이있는 인수 뒤에 위치 매개 변수 (이름이없는 것)를 넣는 것은 유효하지 않습니다. 위치 매개 변수와 마찬가지로 형식 문자열에서 사용하지 않는 명명 된 매개 변수를 제공하는 것은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3ba3f42fb0bf8686407f3cf8b99f8a8d970d5d7" translate="yes" xml:space="preserve">
          <source>It is often seen in its borrowed forms, either mutable or shared. The shared slice type is &lt;code&gt;&amp;amp;[T]&lt;/code&gt;, while the mutable slice type is &lt;code&gt;&amp;amp;mut [T]&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; represents the element type.</source>
          <target state="translated">종종 빌린 형태로 변경 가능하거나 공유됩니다. 공유 슬라이스 유형은 &lt;code&gt;&amp;amp;[T]&lt;/code&gt; 이고 가변 슬라이스 유형은 &lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; 이며 여기서 &lt;code&gt;T&lt;/code&gt; 는 요소 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2fab516d94cc4b051eccfa289cd47f35b51a6906" translate="yes" xml:space="preserve">
          <source>It is possible for &lt;code&gt;addr&lt;/code&gt; to yield multiple addresses, but &lt;code&gt;send_to&lt;/code&gt; will only send data to the first address yielded by &lt;code&gt;addr&lt;/code&gt;.</source>
          <target state="translated">것이 가능하다 &lt;code&gt;addr&lt;/code&gt; 여러 개의 주소를 생성하는 것이 아니라 &lt;code&gt;send_to&lt;/code&gt; 이 단지에 의해 산출 첫 번째 주소로 데이터를 전송합니다 &lt;code&gt;addr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6369907ebe6b468b9a2ca85d26bcb0993424305d" translate="yes" xml:space="preserve">
          <source>It is possible to seek beyond the end of an object, but it's an error to seek before byte 0.</source>
          <target state="translated">객체의 끝을 넘어서 탐색하는 것이 가능하지만 바이트 0 전에 탐색하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="fdaed3dad08dda198d1195920589e6980812bcbd" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;code&gt;ManuallyDrop&lt;/code&gt; to control the drop order, but this requires unsafe code and is hard to do correctly in the presence of unwinding.</source>
          <target state="translated">사용할 수 있습니다 &lt;code&gt;ManuallyDrop&lt;/code&gt; 을 드롭 순서를 제어 할 수 있지만, 이것은 안전하지 않은 코드를 필요로하고 풀기의 존재 제대로 수행하기 어렵다.</target>
        </trans-unit>
        <trans-unit id="2a2042bff8db30718f4be68e6828fc24e384458a" translate="yes" xml:space="preserve">
          <source>It is possible to use pattern matching on &lt;code&gt;union&lt;/code&gt;s. A single field name must be used and it must match the name of one of the &lt;code&gt;union&lt;/code&gt;'s field. Like reading from a &lt;code&gt;union&lt;/code&gt;, pattern matching on a &lt;code&gt;union&lt;/code&gt; requires &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 에서 패턴 매칭을 사용할 수 있습니다 . 단일 필드 이름을 사용해야하며 &lt;code&gt;union&lt;/code&gt; 필드 중 하나의 이름과 일치해야 합니다. A로부터 읽기와 마찬가지로 &lt;code&gt;union&lt;/code&gt; , A의 패턴 매칭 &lt;code&gt;union&lt;/code&gt; 필요 &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cecc5cbf610b50fb9b85dc5d9562253999d191e2" translate="yes" xml:space="preserve">
          <source>It is possible, however, for &lt;strong&gt;logical&lt;/strong&gt; invariants to be broken in Rust, which can end up causing behavioral bugs. Another key aspect of unwind safety in Rust is that, in the absence of &lt;code&gt;unsafe&lt;/code&gt; code, a panic cannot lead to memory unsafety.</source>
          <target state="translated">그러나 Rust에서 &lt;strong&gt;논리적&lt;/strong&gt; 불변이 깨져서 동작 버그가 발생할 수 있습니다. Rust에서 언 와인드 안전의 또 다른 주요 측면은 안전 &lt;code&gt;unsafe&lt;/code&gt; 코드 가 없으면 패닉이 메모리 안전을 초래할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="da80bba13418a2462cda990927908d8ad7892c41" translate="yes" xml:space="preserve">
          <source>It is recommended that you look for a &lt;code&gt;new&lt;/code&gt; function or equivalent in the crate's documentation.</source>
          <target state="translated">상자 설명서에서 &lt;code&gt;new&lt;/code&gt; 기능 또는 이와 동등한 기능 을 찾는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="158d82d49dddadcae62bf58b7e9d48850c1ba3f3" translate="yes" xml:space="preserve">
          <source>It is required that the keys implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits, although this can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">&lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 를 사용하여 키 를 자주 얻을 수 있지만 키가 &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 특성을 구현해야합니다 . 이를 직접 구현하는 경우 다음 속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="1c5f8488f4eecd7c3ca6dd6e0c4ceb285589eb45" translate="yes" xml:space="preserve">
          <source>It is required that the keys implement the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits, although this can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">&lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 를 사용하여 키 를 자주 얻을 수 있지만 키가 &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 특성을 구현해야합니다 . 이를 직접 구현하는 경우 다음 속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9e65409691544dfbd0d6482536ef748a0086ee53" translate="yes" xml:space="preserve">
          <source>It is returned by the &lt;a href=&quot;struct.condvar#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;struct.condvar#method.wait_timeout&quot;&gt; &lt;code&gt;wait_timeout&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="43f6a5e55fbbfc805831e83b9b3a4f775c58ea12" translate="yes" xml:space="preserve">
          <source>It is roughly equal to a duration of 584,942,417,355 years.</source>
          <target state="translated">대략 584,942,417,355 년의 기간과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e22d2249ea3cf1183d26c8fb6b0c9e7619f06c9" translate="yes" xml:space="preserve">
          <source>It is semantically a wrapper around an &lt;code&gt;&amp;amp;[u8]&lt;/code&gt;, but is guaranteed to be ABI compatible with the &lt;code&gt;iovec&lt;/code&gt; type on Unix platforms and &lt;code&gt;WSABUF&lt;/code&gt; on Windows.</source>
          <target state="translated">의미 상 &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; 주위의 랩퍼 이지만 Unix 플랫폼 의 &lt;code&gt;iovec&lt;/code&gt; 유형 및 Windows의 &lt;code&gt;WSABUF&lt;/code&gt; 와 ABI 호환 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="310066900f319893888448530eda337cc1113b35" translate="yes" xml:space="preserve">
          <source>It is semantically a wrapper around an &lt;code&gt;&amp;amp;mut [u8]&lt;/code&gt;, but is guaranteed to be ABI compatible with the &lt;code&gt;iovec&lt;/code&gt; type on Unix platforms and &lt;code&gt;WSABUF&lt;/code&gt; on Windows.</source>
          <target state="translated">의미 상 &lt;code&gt;&amp;amp;mut [u8]&lt;/code&gt; 주위의 래퍼 이지만 Unix 플랫폼 의 &lt;code&gt;iovec&lt;/code&gt; 유형 및 Windows의 &lt;code&gt;WSABUF&lt;/code&gt; 와 ABI 호환이 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="d5c70546718e8bec6af4968356db7e36252be3a4" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary to manually drop the mutex guard to unlock it sooner than the end of the enclosing scope.</source>
          <target state="translated">둘러싸는 범위의 끝보다 빨리 잠금을 해제하기 위해 뮤텍스 가드를 수동으로 드롭해야하는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="82e8beb4413ce9188f6c9ea8439432ef5b9611d2" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to have objects that are guaranteed not to move, in the sense that their placement in memory does not change, and can thus be relied upon. A prime example of such a scenario would be building self-referential structs, as moving an object with pointers to itself will invalidate them, which could cause undefined behavior.</source>
          <target state="translated">메모리에서의 위치가 변경되지 않아 신뢰할 수있는 점에서 움직이지 않는 개체를 확보하는 것이 유용한 경우가 있습니다. 이러한 시나리오의 주요 예는 자체 참조 구조체를 작성하는 것입니다. 포인터를 사용하여 객체를 이동하면 객체가 무효화되어 정의되지 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4371e8f3f7450e76f6a242238c801628a1cbf06b" translate="yes" xml:space="preserve">
          <source>It is the declarations that make up the contract of traits and what is available on generic types.</source>
          <target state="translated">특성 계약과 제네릭 유형에서 사용할 수있는 것은 선언입니다.</target>
        </trans-unit>
        <trans-unit id="d37c9a79672120af34904e218ec499be2dd86aef" translate="yes" xml:space="preserve">
          <source>It is the declarations that make up the contract of traits and what it available on generic types.</source>
          <target state="translated">특성의 계약을 구성하는 선언과 일반 유형에서 사용할 수있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0b7557ddb14fd9cccc6582df092ab6f10becd5d9" translate="yes" xml:space="preserve">
          <source>It is the maximum index such that &lt;code&gt;from_utf8(&amp;amp;input[..index])&lt;/code&gt; would return &lt;code&gt;Ok(_)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;from_utf8(&amp;amp;input[..index])&lt;/code&gt; 이 &lt;code&gt;Ok(_)&lt;/code&gt; 리턴 하는 최대 색인 입니다.</target>
        </trans-unit>
        <trans-unit id="b264294fdd4a01382c3aea7e168cfb7358441c48" translate="yes" xml:space="preserve">
          <source>It is the programmer's responsibility when writing &lt;code&gt;unsafe&lt;/code&gt; code to ensure that any safe code interacting with the &lt;code&gt;unsafe&lt;/code&gt; code cannot trigger these behaviors. &lt;code&gt;unsafe&lt;/code&gt; code that satisfies this property for any safe client is called &lt;em&gt;sound&lt;/em&gt;; if &lt;code&gt;unsafe&lt;/code&gt; code can be misused by safe code to exhibit undefined behavior, it is &lt;em&gt;unsound&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 코드와 상호 작용하는 &lt;code&gt;unsafe&lt;/code&gt; 코드가 이러한 동작을 트리거 하지 못하도록하는 것은 안전 하지 않은 코드를 작성할 때 프로그래머의 책임 입니다. 안전한 클라이언트에 대해이 속성을 충족하는 &lt;code&gt;unsafe&lt;/code&gt; 코드를 &lt;em&gt;사운드&lt;/em&gt; 라고합니다 . &lt;code&gt;unsafe&lt;/code&gt; 코드가 안전 코드에서 오용되어 정의되지 않은 동작을 나타낼 수 있다면 &lt;em&gt;건전하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f5ade12a490d1fb2caaede62e82d953ed5a36f49" translate="yes" xml:space="preserve">
          <source>It is typically faster than stable sorting, except in a few special cases, e.g., when the slice consists of several concatenated sorted sequences.</source>
          <target state="translated">슬라이스가 여러 개의 연결된 정렬 된 시퀀스로 구성된 경우와 같은 몇 가지 특수한 경우를 제외하고는 일반적으로 안정적인 정렬보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="a75ff90de5ca8eff04b8583b7bb1f33e14e7d147" translate="yes" xml:space="preserve">
          <source>It is undefined behavior for this operation to overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;. If you cannot guarantee that this will not overflow, use &lt;code&gt;backward&lt;/code&gt; or &lt;code&gt;backward_checked&lt;/code&gt; instead.</source>
          <target state="translated">이 작업에 대해 &lt;code&gt;Self&lt;/code&gt; 가 지원하는 값 범위를 오버플로하는 것은 정의되지 않은 동작입니다 . 이것이 오버플로되지 않을 것이라고 보장 할 수 없다면, 대신 &lt;code&gt;backward&lt;/code&gt; 또는 &lt;code&gt;backward_checked&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ea8054d51290c5e837766cf36b3dc8b91cb98821" translate="yes" xml:space="preserve">
          <source>It is undefined behavior for this operation to overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;. If you cannot guarantee that this will not overflow, use &lt;code&gt;forward&lt;/code&gt; or &lt;code&gt;forward_checked&lt;/code&gt; instead.</source>
          <target state="translated">이 작업에 대해 &lt;code&gt;Self&lt;/code&gt; 가 지원하는 값 범위를 오버플로하는 것은 정의되지 않은 동작입니다 . 이것이 오버플로되지 않을 것이라고 보장 할 수없는 경우 대신 &lt;code&gt;forward&lt;/code&gt; 또는 &lt;code&gt;forward_checked&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4acc32d24d7d6395cf0c7d59cd524a48233ae10a" translate="yes" xml:space="preserve">
          <source>It is unnecessary to do this since &lt;code&gt;drop&lt;/code&gt; is called automatically whenever a value goes out of scope. However, if you really need to drop a value by hand, you can use the &lt;code&gt;std::mem::drop&lt;/code&gt; function:</source>
          <target state="translated">값이 범위를 벗어날 때마다 &lt;code&gt;drop&lt;/code&gt; 이 자동으로 호출 되므로이를 수행 할 필요가 없습니다 . 그러나 실제로 값을 직접 삭제해야하는 경우 &lt;code&gt;std::mem::drop&lt;/code&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44e547b1d483f3958a2447866fe3c4d46a3e009d" translate="yes" xml:space="preserve">
          <source>It is unspecified how many elements are removed from the vector if the &lt;code&gt;Splice&lt;/code&gt; value is leaked.</source>
          <target state="translated">&lt;code&gt;Splice&lt;/code&gt; 값이 누출 된 경우 벡터에서 얼마나 많은 요소가 제거되는지는 지정되어 있지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="295705b2fa436290d781c9b500c921db48521039" translate="yes" xml:space="preserve">
          <source>It is unspecified how many more elements will be subjected to the closure if a panic occurs in the closure, or a panic occurs while dropping an element, or if the &lt;code&gt;DrainFilter&lt;/code&gt; value is leaked.</source>
          <target state="translated">클로저에서 패닉이 발생하거나, 요소를 드롭하는 동안 패닉이 발생하거나, &lt;code&gt;DrainFilter&lt;/code&gt; 값이 누출 되면 얼마나 많은 요소가 클로저에 노출 될 것인지는 지정되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c5e979093f4634e70883c1e6b5d99af22f995783" translate="yes" xml:space="preserve">
          <source>It is unspecified how many more values will be subjected to the closure if a panic occurs in the closure, or if a panic occurs while dropping a value, or if the &lt;code&gt;DrainFilter&lt;/code&gt; itself is leaked.</source>
          <target state="translated">클로저에서 패닉이 발생하거나 값을 삭제하는 동안 패닉이 발생하거나 &lt;code&gt;DrainFilter&lt;/code&gt; 자체가 누출 된 경우 얼마나 많은 값이 클로저에 적용되는지는 지정되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d6cad4b99027fa4acf9843034ac2fdd309a68ec9" translate="yes" xml:space="preserve">
          <source>It is up to the caller to ensure that the object is still alive when accessing it through the pointer.</source>
          <target state="translated">포인터를 통해 객체에 액세스 할 때 객체가 여전히 살아 있는지 확인하는 것은 호출자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="98956152124bb7bc80eb86d315a85b9b45c037d0" translate="yes" xml:space="preserve">
          <source>It is up to the caller to guarantee that the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; elements really are in an initialized state. Calling this when the content is not yet fully initialized causes undefined behavior.</source>
          <target state="translated">&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 요소가 실제로 초기화 된 상태인지 확인하는 것은 호출자에게 달려 있습니다. 콘텐츠가 아직 완전히 초기화되지 않았을 때 이것을 호출하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aa61fcbe3608674ea2f0e3a8facadbaeb00b9db0" translate="yes" xml:space="preserve">
          <source>It is up to the caller to guarantee that the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior. The &lt;a href=&quot;#initialization-invariant&quot;&gt;type-level documentation&lt;/a&gt; contains more information about this initialization invariant.</source>
          <target state="translated">&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 실제로 초기화 된 상태 임을 보장하는 것은 호출자에게 달려 있습니다. 내용이 아직 완전히 초기화되지 않은 상태에서이를 호출하면 즉시 정의되지 않은 동작이 발생합니다. &lt;a href=&quot;#initialization-invariant&quot;&gt;타입 수준의 문서는&lt;/a&gt; 이 초기화 불변에 대한 자세한 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e90618210aeb35b7fbf1d0dce959c7d288e195c5" translate="yes" xml:space="preserve">
          <source>It is up to the caller to guarantee that the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; really is in an initialized state. Calling this when the content is not yet fully initialized causes undefined behavior.</source>
          <target state="translated">&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 실제로 초기화 된 상태 임을 보장하는 것은 호출자에게 달려 있습니다. 내용이 아직 완전히 초기화되지 않은 상태에서이를 호출하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1cc21693b6059e6e8119cffad058e61a70eeecf5" translate="yes" xml:space="preserve">
          <source>It is up to the caller to guarantee that the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; really is in an initialized state. Calling this when the content is not yet fully initialized causes undefined behavior. The &lt;a href=&quot;#initialization-invariant&quot;&gt;type-level documentation&lt;/a&gt; contains more information about this initialization invariant.</source>
          <target state="translated">&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 실제로 초기화 된 상태 임을 보장하는 것은 호출자에게 달려 있습니다. 내용이 아직 완전히 초기화되지 않은 상태에서이를 호출하면 정의되지 않은 동작이 발생합니다. &lt;a href=&quot;#initialization-invariant&quot;&gt;타입 수준의 문서는&lt;/a&gt; 이 초기화 불변에 대한 자세한 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea0a0e4346d92e82b2088690613099c2bf07dc7c" translate="yes" xml:space="preserve">
          <source>It is used by the &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">그것은 &lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt; 특성에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="76aa244bb958db0a4b9e995026430044d057625c" translate="yes" xml:space="preserve">
          <source>It is used with the &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">&lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;io::Error&lt;/code&gt; &lt;/a&gt; 유형 과 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f1ece6b57f7a1f8dc31198244f231a713dd3042" translate="yes" xml:space="preserve">
          <source>It is valid to add the &lt;code&gt;link&lt;/code&gt; attribute on an empty extern block. You can use this to satisfy the linking requirements of extern blocks elsewhere in your code (including upstream crates) instead of adding the attribute to each extern block.</source>
          <target state="translated">빈 extern 블록에 &lt;code&gt;link&lt;/code&gt; 속성 을 추가하는 것이 유효합니다 . 이를 사용하여 각 extern 블록에 속성을 추가하는 대신 코드의 다른 위치 (업스트림 크레이트 포함)에 extern 블록의 링크 요구 사항을 충족 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3e90c3943be0d42f62f18b3f27da88ff78617f2" translate="yes" xml:space="preserve">
          <source>It is worth reiterating that &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; does &lt;em&gt;not&lt;/em&gt; change the fact that a Rust compiler considers all types movable. &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt; remains callable for any &lt;code&gt;T&lt;/code&gt;. Instead, &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; prevents certain &lt;em&gt;values&lt;/em&gt; (pointed to by pointers wrapped in &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt;) from being moved by making it impossible to call methods that require &lt;code&gt;&amp;amp;mut T&lt;/code&gt; on them (like &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 Rust 컴파일러가 모든 유형을 이동 가능한 것으로 간주한다는 사실을 변경 하지 &lt;em&gt;않는다는&lt;/em&gt; 사실을 반복 할 가치가 있습니다. &lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt; 은 모든 &lt;code&gt;T&lt;/code&gt; 에 대해 호출 가능합니다 . 대신 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 특정 &lt;em&gt;값&lt;/em&gt; ( &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt; 래핑 된 포인터로 가리키는 )이 이동되는 것을 방지 합니다 (예 &lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt; ) 에 대해 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 가 필요한 메서드를 호출 할 수 없도록합니다 .</target>
        </trans-unit>
        <trans-unit id="6738e5c58c6dd95792620faa63b8d5cc231a8b6d" translate="yes" xml:space="preserve">
          <source>It is worth reiterating that &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; does &lt;em&gt;not&lt;/em&gt; change the fact that a Rust compiler considers all types movable. &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt; remains callable for any &lt;code&gt;T&lt;/code&gt;. Instead, &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; prevents certain &lt;em&gt;values&lt;/em&gt; (pointed to by pointers wrapped in &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;) from being moved by making it impossible to call methods that require &lt;code&gt;&amp;amp;mut T&lt;/code&gt; on them (like &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">그것은 것을 되풀이 가치가 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt; 않습니다 &lt;em&gt;하지&lt;/em&gt; 녹 컴파일러는 모든 종류의 이동 고려는 사실을 변경합니다. &lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt; 은 모든 &lt;code&gt;T&lt;/code&gt; 에 대해 호출 가능합니다 . 대신, &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; 는 특정 &lt;em&gt;값&lt;/em&gt; ( &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; 싸인 포인터로 표시 )이 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; &lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt; 과 같이 &amp;amp; mut T 가 필요한 메소드를 호출 할 수 없도록하여 이동되는 것을 방지합니다 .</target>
        </trans-unit>
        <trans-unit id="0497668f013a73ed21db051aa84713bf2b2c56fa" translate="yes" xml:space="preserve">
          <source>It is written as &lt;code&gt;cfg&lt;/code&gt;, &lt;code&gt;(&lt;/code&gt;, a configuration predicate, and finally &lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">이 같은 기록 &lt;code&gt;cfg&lt;/code&gt; , &lt;code&gt;(&lt;/code&gt; , 구성 조건, 그리고 마지막으로 &lt;code&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff3c5f08953486f2ebadb5983fbdd75f91d8e664" translate="yes" xml:space="preserve">
          <source>It is your responsibility to make sure that the string slice only gets modified in a way that it remains valid UTF-8.</source>
          <target state="translated">문자열 슬라이스가 유효한 UTF-8을 유지하는 방식으로 만 수정되도록하는 것은 귀하의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="e9c82e577605ff32cb90a4cd85e5d6c96aa90577" translate="yes" xml:space="preserve">
          <source>It is your responsibility to make sure that the underlying memory is not freed too early. For example, the following code will cause undefined behavior when &lt;code&gt;ptr&lt;/code&gt; is used inside the &lt;code&gt;unsafe&lt;/code&gt; block:</source>
          <target state="translated">기본 메모리가 너무 일찍 해제되지 않도록하는 것은 귀하의 책임입니다. 예를 들어, 다음 코드는 &lt;code&gt;unsafe&lt;/code&gt; 블록 내에서 &lt;code&gt;ptr&lt;/code&gt; 을 사용할 때 정의되지 않은 동작을 유발합니다 .</target>
        </trans-unit>
        <trans-unit id="0e3a6e91bbdb9a45516082a07a40a29592b3f0cb" translate="yes" xml:space="preserve">
          <source>It makes sense to name the function parameters with the same name as the struct fields, but having to repeat the &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;username&lt;/code&gt; field names and variables is a bit tedious. If the struct had more fields, repeating each name would get even more annoying. Luckily, there&amp;rsquo;s a convenient shorthand!</source>
          <target state="translated">struct 필드와 동일한 이름으로 함수 매개 변수의 이름을 지정하는 것이 합리적이지만 &lt;code&gt;email&lt;/code&gt; 및 &lt;code&gt;username&lt;/code&gt; 필드 이름과 변수 를 반복해야하는 것은 약간 지루합니다. 구조체에 더 많은 필드가 있으면 각 이름을 반복하면 더 성 가실 것입니다. 운 좋게도 편리한 속기가 있습니다!</target>
        </trans-unit>
        <trans-unit id="d6943ba68e7fe9f38375bc9f4ece082b476fd104" translate="yes" xml:space="preserve">
          <source>It matches! There&amp;rsquo;s no value to add to, so the program stops and returns the &lt;code&gt;None&lt;/code&gt; value on the right side of &lt;code&gt;=&amp;gt;&lt;/code&gt;. Because the first arm matched, no other arms are compared.</source>
          <target state="translated">일치합니다! 더할 값이 없으므로 프로그램은 중지하고 &lt;code&gt;=&amp;gt;&lt;/code&gt; 의 오른쪽에 &lt;code&gt;None&lt;/code&gt; 값을 반환합니다 . 첫 번째 팔이 일치하기 때문에 다른 팔은 비교되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="843b41eaa3d5b0c22ed8a08ff3f89c4230955bbd" translate="yes" xml:space="preserve">
          <source>It may be possible to define the closure later:</source>
          <target state="translated">나중에 클로저를 정의하는 것이 가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37366d1499bbe80dc60f80cfc9ff38beb421f588" translate="yes" xml:space="preserve">
          <source>It may seem counter-intuitive that the field of a pinned struct might not be pinned, but that is actually the easiest choice: if a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; is never created, nothing can go wrong! So, if you decide that some field does not have structural pinning, all you have to ensure is that you never create a pinned reference to that field.</source>
          <target state="translated">고정 된 구조체의 필드가 고정되지 않을 수 있다는 것은 직관에 반하는 것처럼 보일 수 있지만 실제로는 가장 쉬운 선택입니다. &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; 가 생성되지 않으면 아무 것도 잘못 될 수 없습니다! 따라서 일부 필드에 구조적 고정이 없다고 결정한 경우 해당 필드에 대한 고정 된 참조를 만들지 않기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="7626a2cf86a0ef32fb36f30c95b230833af23f10" translate="yes" xml:space="preserve">
          <source>It may seem counter-intuitive that the field of a pinned struct might not be pinned, but that is actually the easiest choice: if a &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; is never created, nothing can go wrong! So, if you decide that some field does not have structural pinning, all you have to ensure is that you never create a pinned reference to that field.</source>
          <target state="translated">그것은 고정 된 구조체의 필드가 고정되지 않을 수 있다는 반 직관적 보일 수 있지만, 실제로 가장 쉬운 선택하십시오 경우 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; 생성되지 않습니다, 아무것도 잘못 될 수 있습니다! 따라서 일부 필드에 구조적 고정이없는 것으로 결정한 경우 해당 필드에 대한 고정 된 참조를 작성하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="1bb0d24f6b4149955502e6e8ad32374412376163" translate="yes" xml:space="preserve">
          <source>It might seem like the paths we&amp;rsquo;ve written to call functions so far are inconveniently long and repetitive. For example, in Listing 7-7, whether we chose the absolute or relative path to the &lt;code&gt;add_to_waitlist&lt;/code&gt; function, every time we wanted to call &lt;code&gt;add_to_waitlist&lt;/code&gt; we had to specify &lt;code&gt;front_of_house&lt;/code&gt; and &lt;code&gt;hosting&lt;/code&gt; too. Fortunately, there&amp;rsquo;s a way to simplify this process. We can bring a path into a scope once and then call the items in that path as if they&amp;rsquo;re local items with the &lt;code&gt;use&lt;/code&gt; keyword.</source>
          <target state="translated">지금까지 함수를 호출하기 위해 작성한 경로가 불편하고 길고 반복적 인 것처럼 보일 수 있습니다. 예를 들어, 목록 7-7에서, 우리는에 절대 또는 상대 경로를 선택했는지 여부 &lt;code&gt;add_to_waitlist&lt;/code&gt; 의 함수 우리가 전화를하고 싶어 할 때마다 &lt;code&gt;add_to_waitlist&lt;/code&gt; 우리가 지정했다 &lt;code&gt;front_of_house&lt;/code&gt; 및 &lt;code&gt;hosting&lt;/code&gt; 도 있습니다. 다행히이 프로세스를 단순화 할 수있는 방법이 있습니다. 스코프에 경로를 한 번 가져온 다음 &lt;code&gt;use&lt;/code&gt; 키워드를 사용 하여 로컬 항목 인 것처럼 해당 경로의 항목을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="805aa02c515eaa318de6b78a094bce98b8c53d4d" translate="yes" xml:space="preserve">
          <source>It moves the input &lt;code&gt;x&lt;/code&gt; passed to the function.</source>
          <target state="translated">함수에 전달 된 입력 &lt;code&gt;x&lt;/code&gt; 를 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="5eebbaa7bc3cdd0a56ef1daa1103d4c78b76f258" translate="yes" xml:space="preserve">
          <source>It must be &quot;dereferencable&quot; in the sense defined in &lt;a href=&quot;index#safety&quot;&gt;the module documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;index#safety&quot;&gt;모듈 설명서에&lt;/a&gt; 정의 된 의미에서 &quot;비정의 가능&quot;해야합니다 .</target>
        </trans-unit>
        <trans-unit id="00a5c10c251d6c8327aa492d2913739597d4a71f" translate="yes" xml:space="preserve">
          <source>It must be &quot;dereferencable&quot; in the sense defined in &lt;a href=&quot;ptr/index#safety&quot;&gt;the module documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;ptr/index#safety&quot;&gt;모듈 설명서에&lt;/a&gt; 정의 된 의미에서 &quot;비정의 가능&quot;해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e3e5a16652e3acc5312ad5ba06a9e285d4162164" translate="yes" xml:space="preserve">
          <source>It must not have any associated constants.</source>
          <target state="translated">연관된 상수가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="2ed9fe4f614f6746c16c9c39cbffbf6f903c7ae2" translate="yes" xml:space="preserve">
          <source>It must not require &lt;code&gt;Self: Sized&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Self: Sized&lt;/code&gt; 필요하지 않음 : 크기</target>
        </trans-unit>
        <trans-unit id="3f3447254df95470f3130af039bc15cf58155424" translate="yes" xml:space="preserve">
          <source>It operates on raw pointers instead of references. When references are available, &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt; should be preferred.</source>
          <target state="translated">참조 대신 원시 포인터에서 작동합니다. 참조가 가능하면 &lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt; 이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="15a360bcd6063536513f56852862c8efa63c2070" translate="yes" xml:space="preserve">
          <source>It remains valid until it goes &lt;em&gt;out of scope&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;범위를 벗어날&lt;/em&gt; 때까지 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="28129f615360627e84e6c1c9dbfcb777498ce57b" translate="yes" xml:space="preserve">
          <source>It replaces this:</source>
          <target state="translated">이것을 대체합니다 :</target>
        </trans-unit>
        <trans-unit id="a96e5b042b30c122375f53b68b92a35b6c66cd8b" translate="yes" xml:space="preserve">
          <source>It represents a separator that designates that a path starts from root.</source>
          <target state="translated">경로가 루트에서 시작하도록 지정하는 구분 기호를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="813494512097c4629c56611a8d3205233aba9f55" translate="yes" xml:space="preserve">
          <source>It should be noted that the length isn't just &quot;recomputed,&quot; but that the recomputed length must match the original length from the &lt;a href=&quot;struct.cstring#method.into_raw&quot;&gt;&lt;code&gt;CString::into_raw&lt;/code&gt;&lt;/a&gt; call. This means the &lt;a href=&quot;struct.cstring#method.into_raw&quot;&gt;&lt;code&gt;CString::into_raw&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;from_raw&lt;/code&gt; methods should not be used when passing the string to C functions that can modify the string's length.</source>
          <target state="translated">길이는 단순히 &quot;재 계산&quot;된 것이 아니라 재 계산 된 길이가 &lt;a href=&quot;struct.cstring#method.into_raw&quot;&gt; &lt;code&gt;CString::into_raw&lt;/code&gt; &lt;/a&gt; 호출 의 원래 길이와 일치해야한다는 점에 유의해야합니다 . 즉, 문자열 길이를 수정할 수있는 C 함수에 문자열을 전달할 때 &lt;a href=&quot;struct.cstring#method.into_raw&quot;&gt; &lt;code&gt;CString::into_raw&lt;/code&gt; &lt;/a&gt; / &lt;code&gt;from_raw&lt;/code&gt; 메서드를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="110275e5135057ece97674a5c23f292001714824" translate="yes" xml:space="preserve">
          <source>It sometimes happens that you have unused type parameters which indicate what type of data a struct is &quot;tied&quot; to, even though that data is not actually found in the struct itself. Here is an example where this arises with &lt;a href=&quot;../../book/ch19-01-unsafe-rust#using-extern-functions-to-call-external-code&quot;&gt;FFI&lt;/a&gt;. The foreign interface uses handles of type &lt;code&gt;*mut ()&lt;/code&gt; to refer to Rust values of different types. We track the Rust type using a phantom type parameter on the struct &lt;code&gt;ExternalResource&lt;/code&gt; which wraps a handle.</source>
          <target state="translated">구조체 자체에서 실제로 데이터를 찾을 수없는 경우에도 구조체가 &quot;연결된&quot;데이터 형식을 나타내는 사용하지 않는 형식 매개 변수가있는 경우가 있습니다. 다음은 &lt;a href=&quot;../../book/ch19-01-unsafe-rust#using-extern-functions-to-call-external-code&quot;&gt;FFI에서&lt;/a&gt; 발생하는 예 입니다. 외부 인터페이스는 &lt;code&gt;*mut ()&lt;/code&gt; 유형의 핸들을 사용 하여 다른 유형의 녹 값을 나타냅니다. 핸들을 래핑하는 struct &lt;code&gt;ExternalResource&lt;/code&gt; 의 팬텀 유형 매개 변수를 사용하여 Rust 유형을 추적합니다 .</target>
        </trans-unit>
        <trans-unit id="c8a5407ac4250c5a13730093f7af0747e49f3547" translate="yes" xml:space="preserve">
          <source>It takes ownership of one weak count. In case a &lt;a href=&quot;../ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; is passed, a dangling &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">약한 수의 소유권이 필요합니다. 경우에, &lt;a href=&quot;../ptr/fn.null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; A가 매달려, 전달 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cc57f2847f6e3b461b4b48ae401fd449efb6afda" translate="yes" xml:space="preserve">
          <source>It takes ownership of one weak reference (with the exception of pointers created by &lt;a href=&quot;struct.weak#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt;, as these don't own anything; the method still works on them).</source>
          <target state="translated">하나의 약한 참조에 대한 소유권이 필요합니다 ( &lt;a href=&quot;struct.weak#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 에 의해 생성 된 포인터는 예외입니다. 이것들은 아무것도 소유하지 않기 때문에 메서드는 여전히 작동합니다).</target>
        </trans-unit>
        <trans-unit id="556eed10e4ddb25bae7da43fa1a61a57fb93be86" translate="yes" xml:space="preserve">
          <source>It turns out that it is actually up to the author of the data structure to decide whether the pinned projection for a particular field turns &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; into &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Field&lt;/code&gt;. There are some constraints though, and the most important constraint is &lt;em&gt;consistency&lt;/em&gt;: every field can be &lt;em&gt;either&lt;/em&gt; projected to a pinned reference, &lt;em&gt;or&lt;/em&gt; have pinning removed as part of the projection. If both are done for the same field, that will likely be unsound!</source>
          <target state="translated">특정 필드에 대한 고정 된 투영이 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; 를 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut Field&lt;/code&gt; 로 바꿀지 여부를 결정하는 것은 실제로 데이터 구조의 작성자에게 달려 있습니다. 이하지만 일부 제약이 있고, 가장 중요한 제약은 &lt;em&gt;일관성&lt;/em&gt; : 모든 필드는 할 수 있습니다 &lt;em&gt;중 하나를&lt;/em&gt; 고정 된 기준에 투영, &lt;em&gt;또는&lt;/em&gt; 투사의 일환으로 제거 피닝있다. 둘 다 동일한 분야에 대해 수행되면 불건전 할 것입니다!</target>
        </trans-unit>
        <trans-unit id="2e869ff63d6d4b946c2cdd219b436de253a41746" translate="yes" xml:space="preserve">
          <source>It turns out that it is actually up to the author of the data structure to decide whether the pinned projection for a particular field turns &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; into &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Field&lt;/code&gt;. There are some constraints though, and the most important constraint is &lt;em&gt;consistency&lt;/em&gt;: every field can be &lt;em&gt;either&lt;/em&gt; projected to a pinned reference, &lt;em&gt;or&lt;/em&gt; have pinning removed as part of the projection. If both are done for the same field, that will likely be unsound!</source>
          <target state="translated">특정 필드에 대한 고정 된 투영이 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; 를 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut Field&lt;/code&gt; 로 바꿀지 여부를 결정하는 것은 실제로 데이터 구조의 작성자에게 달려 있음이 밝혀 졌습니다 . 이하지만 일부 제약이 있고, 가장 중요한 제약은 &lt;em&gt;일관성&lt;/em&gt; : 모든 필드는 할 수 있습니다 &lt;em&gt;중 하나를&lt;/em&gt; 고정 된 기준에 투영, &lt;em&gt;또는&lt;/em&gt; 투사의 일환으로 제거 피닝있다. 둘 다 같은 분야에서 행해지면 소리가 나지 않을 것입니다!</target>
        </trans-unit>
        <trans-unit id="43f35f0c065fabfd41f89d1318ce0f42a18d0c80" translate="yes" xml:space="preserve">
          <source>It wasn&amp;rsquo;t always so clear, but the Rust programming language is fundamentally about &lt;em&gt;empowerment&lt;/em&gt;: no matter what kind of code you are writing now, Rust empowers you to reach farther, to program with confidence in a wider variety of domains than you did before.</source>
          <target state="translated">항상 명확하지는 않았지만 Rust 프로그래밍 언어는 기본적으로 &lt;em&gt;권한 부여&lt;/em&gt; 에 관한 &lt;em&gt;것입니다&lt;/em&gt; . 현재 어떤 종류의 코드를 작성하든 Rust는 더 넓은 범위의 영역에서 자신감을 가지고 프로그래밍 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="e5c52d18214990d951c10878c00ac04808b86559" translate="yes" xml:space="preserve">
          <source>It will also return an error if it encounters while reading an error of a kind other than &lt;a href=&quot;../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt;, or if the contents of the file are not valid UTF-8.</source>
          <target state="translated">&lt;a href=&quot;../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 이외의 다른 종류의 오류를 읽는 동안 발생 하거나 파일의 내용이 UTF-8이 아닌 경우 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="88d7df68d5037684c00152095cea66d62196594d" translate="yes" xml:space="preserve">
          <source>It will also return an error if it encounters while reading an error of a kind other than &lt;a href=&quot;../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 이외의 다른 종류의 오류를 읽는 동안 발생하면 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b634d15305e7f67a78aa8cca8e62aa2565532e97" translate="yes" xml:space="preserve">
          <source>It will also return an error if it encounters while reading an error of a kind other than &lt;a href=&quot;../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt;, or if the contents of the file are not valid UTF-8.</source>
          <target state="translated">&lt;a href=&quot;../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 이외의 종류의 오류를 읽는 동안 발생 하거나 파일의 내용이 유효한 UTF-8이 아닌 경우에도 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f94bfac984e5cdabffa566b75c8486ad84a9f63a" translate="yes" xml:space="preserve">
          <source>It will also return an error if it encounters while reading an error of a kind other than &lt;a href=&quot;../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 이외의 종류의 오류를 읽는 동안 발생하면 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4977950c4a1247296e8ff0c58adfe3a8ef825061" translate="yes" xml:space="preserve">
          <source>It will be implemented by associated &lt;a href=&quot;trait.searcher&quot;&gt;&lt;code&gt;Searcher&lt;/code&gt;&lt;/a&gt; types of the &lt;a href=&quot;trait.pattern&quot;&gt;&lt;code&gt;Pattern&lt;/code&gt;&lt;/a&gt; trait if the pattern supports searching for it from the back.</source>
          <target state="translated">패턴이 뒤에서 검색을 지원하는 경우 &lt;a href=&quot;trait.pattern&quot;&gt; &lt;code&gt;Pattern&lt;/code&gt; &lt;/a&gt; 특성 의 연관된 &lt;a href=&quot;trait.searcher&quot;&gt; &lt;code&gt;Searcher&lt;/code&gt; &lt;/a&gt; 유형에 의해 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="01c79069ef32a54734e3b8b3c591b459a403a4fa" translate="yes" xml:space="preserve">
          <source>It will be implemented by associated &lt;code&gt;Searcher&lt;/code&gt; types of the &lt;a href=&quot;trait.pattern&quot;&gt;&lt;code&gt;Pattern&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">&lt;a href=&quot;trait.pattern&quot;&gt; &lt;code&gt;Pattern&lt;/code&gt; &lt;/a&gt; 특성 의 관련 &lt;code&gt;Searcher&lt;/code&gt; 유형에 의해 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea8e67a12d7988664bc05e18e9798989cd3eb135" translate="yes" xml:space="preserve">
          <source>It will be implemented by associated &lt;code&gt;Searcher&lt;/code&gt; types of the &lt;code&gt;Pattern&lt;/code&gt; trait if the pattern supports searching for it from the back.</source>
          <target state="translated">패턴이 뒤에서 검색을 지원하는 경우 &lt;code&gt;Pattern&lt;/code&gt; 특성 의 연관된 &lt;code&gt;Searcher&lt;/code&gt; 유형 으로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f81a8ca5067c3c3b4399b6129a830805c0cc0ff" translate="yes" xml:space="preserve">
          <source>It will be implemented by associated &lt;code&gt;Searcher&lt;/code&gt; types of the &lt;code&gt;Pattern&lt;/code&gt; trait.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 특성 의 연관된 &lt;code&gt;Searcher&lt;/code&gt; 유형 으로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="6ec53dce211a7944d162428d571097183435ce6f" translate="yes" xml:space="preserve">
          <source>It will drop down as close as possible to the length but the allocator may still inform the &lt;code&gt;VecDeque&lt;/code&gt; that there is space for a few more elements.</source>
          <target state="translated">가능한 한 길이에 가깝게 떨어지지 만 할당자는 여전히 &lt;code&gt;VecDeque&lt;/code&gt; 에 몇 가지 요소를 더 넣을 공간이 있음을 알릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d0e16f9adb2110bbd3e927ea4577168391e9b74" translate="yes" xml:space="preserve">
          <source>It will drop down as close as possible to the length but the allocator may still inform the vector that there is space for a few more elements.</source>
          <target state="translated">가능한 한 길이에 가깝게 떨어지지 만 할당자는 여전히 벡터에 몇 가지 요소를 더 넣을 공간이 있음을 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="583613916c43b1fe106e05c39ca4ce6da47ce68b" translate="yes" xml:space="preserve">
          <source>It will never return &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="38d1d8fbd49b71b116c5d704cf7c49ee955c939a" translate="yes" xml:space="preserve">
          <source>It would also be appropriate to call &lt;code&gt;unwrap&lt;/code&gt; when you have some other logic that ensures the &lt;code&gt;Result&lt;/code&gt; will have an &lt;code&gt;Ok&lt;/code&gt; value, but the logic isn&amp;rsquo;t something the compiler understands. You&amp;rsquo;ll still have a &lt;code&gt;Result&lt;/code&gt; value that you need to handle: whatever operation you&amp;rsquo;re calling still has the possibility of failing in general, even though it&amp;rsquo;s logically impossible in your particular situation. If you can ensure by manually inspecting the code that you&amp;rsquo;ll never have an &lt;code&gt;Err&lt;/code&gt; variant, it&amp;rsquo;s perfectly acceptable to call &lt;code&gt;unwrap&lt;/code&gt;. Here&amp;rsquo;s an example:</source>
          <target state="translated">&lt;code&gt;Result&lt;/code&gt; 에 &lt;code&gt;Ok&lt;/code&gt; 값 이 있는지 확인하는 다른 로직이있을 때 &lt;code&gt;unwrap&lt;/code&gt; 을 호출하는 것이 적절 하지만 로직은 컴파일러가 이해하는 것이 아닙니다. 당신은 여전히해야합니다 &lt;code&gt;Result&lt;/code&gt; 는 특정 상황에서 논리적으로 불가능하더라도, 여전히 일반적으로 실패의 가능성이 어떤 동작을 당신이 전화하는거야 : 당신이 처리 할 필요가 있음을 값입니다. &lt;code&gt;Err&lt;/code&gt; 변형 이없는 코드를 수동으로 검사하여 확인할 수 있다면 &lt;code&gt;unwrap&lt;/code&gt; 을 호출하는 것이 좋습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="281e22ba57501fc7d3d70b8f1f8f4bfbc5dcf1a5" translate="yes" xml:space="preserve">
          <source>It would make it more difficult for unsafe code to correctly manipulate a &lt;code&gt;Vec&lt;/code&gt;. The contents of a &lt;code&gt;Vec&lt;/code&gt; wouldn't have a stable address if it were only moved, and it would be more difficult to determine if a &lt;code&gt;Vec&lt;/code&gt; had actually allocated memory.</source>
          <target state="translated">안전하지 않은 코드가 &lt;code&gt;Vec&lt;/code&gt; 를 올바르게 조작하기가 더 어려워 집니다. &lt;code&gt;Vec&lt;/code&gt; 의 내용은 이동 된 경우에만 안정적인 주소를 가지지 않으며 &lt;code&gt;Vec&lt;/code&gt; 이 실제로 메모리를 할당 했는지 확인하기가 더 어려울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8927c51bfbab721165d17b97848a237b8ec4da60" translate="yes" xml:space="preserve">
          <source>It would penalize the general case, incurring an additional branch on every access.</source>
          <target state="translated">모든 액세스에서 추가 분기가 발생하여 일반적인 경우에 불이익을줍니다.</target>
        </trans-unit>
        <trans-unit id="0a1ec3ed4f97e53ed39cbe77eeb33099668d0775" translate="yes" xml:space="preserve">
          <source>It wouldn't work. This is because the size of a &lt;code&gt;List&lt;/code&gt; depends on how many elements are in the list, and so we don't know how much memory to allocate for a &lt;code&gt;Cons&lt;/code&gt;. By introducing a &lt;a href=&quot;struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, which has a defined size, we know how big &lt;code&gt;Cons&lt;/code&gt; needs to be.</source>
          <target state="translated">작동하지 않습니다. 이것은 &lt;code&gt;List&lt;/code&gt; 의 크기가 목록 에있는 요소의 수에 따라 다르기 때문에 &lt;code&gt;Cons&lt;/code&gt; 에 할당 할 메모리 양을 알지 못하기 때문 입니다. 정의 된 크기를 가진 &lt;a href=&quot;struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 도입함으로써 우리는 얼마나 큰 &lt;code&gt;Cons&lt;/code&gt; 필요한지 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6be8378a582020df10360545b9470cc00244ca7" translate="yes" xml:space="preserve">
          <source>It wouldn't work. This is because the size of a &lt;code&gt;List&lt;/code&gt; depends on how many elements are in the list, and so we don't know how much memory to allocate for a &lt;code&gt;Cons&lt;/code&gt;. By introducing a &lt;code&gt;Box&lt;/code&gt;, which has a defined size, we know how big &lt;code&gt;Cons&lt;/code&gt; needs to be.</source>
          <target state="translated">작동하지 않습니다. &lt;code&gt;List&lt;/code&gt; 의 크기는 목록 에있는 요소 수에 따라 달라 지기 때문에 &lt;code&gt;Cons&lt;/code&gt; 에 할당 할 메모리 양을 알 수 없기 때문 입니다. 크기가 정의 된 &lt;code&gt;Box&lt;/code&gt; 를 도입함으로써 우리는 얼마나 큰 &lt;code&gt;Cons&lt;/code&gt; 필요한지 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4998da21c6a9914c8ce4ea9184bccf6c0873e7d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;d be nice to be able to print an instance of &lt;code&gt;Rectangle&lt;/code&gt; while we&amp;rsquo;re debugging our program and see the values for all its fields. Listing 5-11 tries using the &lt;code&gt;println!&lt;/code&gt; macro as we have used in previous chapters. This won&amp;rsquo;t work, however.</source>
          <target state="translated">프로그램을 디버깅하는 동안 &lt;code&gt;Rectangle&lt;/code&gt; 인스턴스를 인쇄하고 모든 필드의 값을 볼 수 있다면 좋을 것 입니다. Listing 5-11은 &lt;code&gt;println!&lt;/code&gt; 사용해 본다! 이전 장에서 사용한 매크로 그러나 이것은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fd4ff89cd3ed9767f9bb50021655606612821c0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a panoply of Rust features with something for everyone! Let&amp;rsquo;s dive in!</source>
          <target state="translated">모두를위한 무언가를 가진 Rust 기능의 인기입니다! 뛰어 들자!</target>
        </trans-unit>
        <trans-unit id="2f4a91582fca2b4ddf611bb05db0236c35e6a95d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s advisable to have your code panic when it&amp;rsquo;s possible that your code could end up in a bad state. In this context, a &lt;em&gt;bad state&lt;/em&gt; is when some assumption, guarantee, contract, or invariant has been broken, such as when invalid values, contradictory values, or missing values are passed to your code&amp;mdash;plus one or more of the following:</source>
          <target state="translated">코드 상태가 나빠질 수있는 경우 코드 패닉이 발생하는 것이 좋습니다. 이와 관련하여 &lt;em&gt;잘못된 상태&lt;/em&gt; 는 유효하지 않은 값, 모순되는 값 또는 결 측값이 코드에 전달 될 때 (예 : 다음 중 하나 이상)와 같은 일부 가정, 보증, 계약 또는 불변이 깨졌을 때입니다.</target>
        </trans-unit>
        <trans-unit id="1d4af836f0cd460a3ac351996453b851549fe52a" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also worth noting that the condition in this code &lt;em&gt;must&lt;/em&gt; be a &lt;code&gt;bool&lt;/code&gt;. If the condition isn&amp;rsquo;t a &lt;code&gt;bool&lt;/code&gt;, we&amp;rsquo;ll get an error. For example, try running the following code:</source>
          <target state="translated">이 코드의 조건이 &lt;code&gt;bool&lt;/code&gt; &lt;em&gt;이어야&lt;/em&gt; 한다는 점도 주목할 가치가 있습니다 . 조건이 &lt;code&gt;bool&lt;/code&gt; 이 아닌 경우 오류가 발생합니다. 예를 들어 다음 코드를 실행 해보십시오.</target>
        </trans-unit>
        <trans-unit id="d52fc1028632f974c83efdc9f4200e35b249610e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s been a long journey, but we&amp;rsquo;ve reached the end of the book. In this chapter, we&amp;rsquo;ll build one more project together to demonstrate some of the concepts we covered in the final chapters, as well as recap some earlier lessons.</source>
          <target state="translated">긴 여행 이었지만 책의 끝에 도달했습니다. 이 장에서는 마지막 장에서 다룬 몇 가지 개념을 보여주고 이전 단원을 요약하여 프로젝트를 하나 더 작성합니다.</target>
        </trans-unit>
        <trans-unit id="1024ef58107465d0b2d166ab80e88f189d22f3a3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common to check whether a particular key has a value and, if it doesn&amp;rsquo;t, insert a value for it. Hash maps have a special API for this called &lt;code&gt;entry&lt;/code&gt; that takes the key you want to check as a parameter. The return value of the &lt;code&gt;entry&lt;/code&gt; method is an enum called &lt;code&gt;Entry&lt;/code&gt; that represents a value that might or might not exist. Let&amp;rsquo;s say we want to check whether the key for the Yellow team has a value associated with it. If it doesn&amp;rsquo;t, we want to insert the value 50, and the same for the Blue team. Using the &lt;code&gt;entry&lt;/code&gt; API, the code looks like Listing 8-25.</source>
          <target state="translated">특정 키에 값이 있는지 확인하고없는 경우 값을 삽입하는 것이 일반적입니다. 해시 맵에는 매개 변수로 확인하려는 키를 사용하는 &lt;code&gt;entry&lt;/code&gt; 이라고하는 특수 API가 있습니다. &lt;code&gt;entry&lt;/code&gt; 메소드 의 리턴 값은 존재하거나 존재하지 않는 값을 나타내는 &lt;code&gt;Entry&lt;/code&gt; 라는 열거 형 입니다. 옐로우 팀의 키에 관련 값이 있는지 확인하고 싶다고 가정 해 봅시다. 그렇지 않은 경우 값 50을 삽입하고 Blue 팀에도 동일하게 삽입하려고합니다. &lt;code&gt;entry&lt;/code&gt; API를 사용하면 코드는 Listing 8-25와 같다.</target>
        </trans-unit>
        <trans-unit id="b254f401bbc453696a95036f25cc6c8b9f205677" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important that we get compile-time errors when we attempt to change a value that we previously designated as immutable because this very situation can lead to bugs. If one part of our code operates on the assumption that a value will never change and another part of our code changes that value, it&amp;rsquo;s possible that the first part of the code won&amp;rsquo;t do what it was designed to do. The cause of this kind of bug can be difficult to track down after the fact, especially when the second piece of code changes the value only &lt;em&gt;sometimes&lt;/em&gt;.</source>
          <target state="translated">버그로 이어질 수 있으므로 이전에 불변으로 지정한 값을 변경하려고 할 때 컴파일 타임 오류가 발생하는 것이 중요합니다. 코드의 한 부분이 값이 변하지 않을 것이라는 가정하에 작동하고 코드의 다른 부분이 그 값을 변경하면 코드의 첫 부분이 의도 한대로 작동하지 않을 수 있습니다. 이러한 종류의 버그의 원인은 사실 이후에 추적하기 어려울 수 있습니다. 특히 두 번째 코드가 &lt;em&gt;때때로&lt;/em&gt; 값을 변경하는 경우에는 더욱 그렇습니다 .</target>
        </trans-unit>
        <trans-unit id="9ed2c9ced3e236750c87d43ad1072d6e0ed07bbb" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to understand that &lt;code&gt;unsafe&lt;/code&gt; doesn&amp;rsquo;t turn off the borrow checker or disable any other of Rust&amp;rsquo;s safety checks: if you use a reference in unsafe code, it will still be checked. The &lt;code&gt;unsafe&lt;/code&gt; keyword only gives you access to these five features that are then not checked by the compiler for memory safety. You&amp;rsquo;ll still get some degree of safety inside of an unsafe block.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 하지 않은 것이 차용 검사기를 끄거나 다른 Rust의 안전 검사를 비활성화하지 않는다는 것을 이해하는 것이 중요합니다. 안전 하지 않은 코드에서 참조를 사용하는 경우에도 여전히 검사됩니다. &lt;code&gt;unsafe&lt;/code&gt; 키워드는 당신에게 다음 메모리 안전을 위해 컴파일러에 의해 확인되지 않은이 다섯 개 가지 기능에 액세스 할 수 있습니다. 안전하지 않은 블록 내부에서는 여전히 어느 정도의 안전을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cdb0b8313d7ae007e7e125bdfd991a30a8e291c" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to understand that &lt;code&gt;unsafe&lt;/code&gt; doesn&amp;rsquo;t turn off the borrow checker or disable any other of Rust&amp;rsquo;s safety checks: if you use a reference in unsafe code, it will still be checked. The &lt;code&gt;unsafe&lt;/code&gt; keyword only gives you access to these four features that are then not checked by the compiler for memory safety. You&amp;rsquo;ll still get some degree of safety inside of an unsafe block.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 는 차용 검사기를 끄거나 Rust의 다른 안전 검사를 비활성화하지 않는다는 것을 이해하는 것이 중요합니다. 안전 하지 않은 코드에서 참조를 사용하면 여전히 검사됩니다. &lt;code&gt;unsafe&lt;/code&gt; 키워드는 당신에게 다음 메모리 안전을 위해 컴파일러에 의해 확인되지 않은이 네 가지 기능에 액세스 할 수 있습니다. 안전하지 않은 블록 안에는 어느 정도 안전이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="8deea23b26cb7cf37f9d9061e806bcfc7feaa092" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s impossible for Rust to determine how many values in the tuple to ignore before matching a value with &lt;code&gt;second&lt;/code&gt; and then how many further values to ignore thereafter. This code could mean that we want to ignore &lt;code&gt;2&lt;/code&gt;, bind &lt;code&gt;second&lt;/code&gt; to &lt;code&gt;4&lt;/code&gt;, and then ignore &lt;code&gt;8&lt;/code&gt;, &lt;code&gt;16&lt;/code&gt;, and &lt;code&gt;32&lt;/code&gt;; or that we want to ignore &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt;, bind &lt;code&gt;second&lt;/code&gt; to &lt;code&gt;8&lt;/code&gt;, and then ignore &lt;code&gt;16&lt;/code&gt; and &lt;code&gt;32&lt;/code&gt;; and so forth. The variable name &lt;code&gt;second&lt;/code&gt; doesn&amp;rsquo;t mean anything special to Rust, so we get a compiler error because using &lt;code&gt;..&lt;/code&gt; in two places like this is ambiguous.</source>
          <target state="translated">Rust가 값을 &lt;code&gt;second&lt;/code&gt; 와 일치시키기 전에 튜플에서 무시할 값의 수를 결정한 다음 이후에 무시할 추가 값의 수 를 결정하는 것은 불가능합니다 . 이 코드는 우리가 무시 할 수도 있다는 뜻 &lt;code&gt;2&lt;/code&gt; 바인드 &lt;code&gt;second&lt;/code&gt; 에 &lt;code&gt;4&lt;/code&gt; 를 무시 다음, 및 &lt;code&gt;8&lt;/code&gt; , &lt;code&gt;16&lt;/code&gt; , 및 &lt;code&gt;32&lt;/code&gt; ; 또는 &lt;code&gt;2&lt;/code&gt; 와 &lt;code&gt;4&lt;/code&gt; 를 무시 하고 , &lt;code&gt;second&lt;/code&gt; 를 &lt;code&gt;8&lt;/code&gt; 에 바인딩 한 다음 &lt;code&gt;16&lt;/code&gt; 과 &lt;code&gt;32&lt;/code&gt; 를 무시하고 싶습니다 . 기타 등등. 변수 이름 &lt;code&gt;second&lt;/code&gt; 는 Rust에 특별한 의미가 없으므로 &lt;code&gt;..&lt;/code&gt; 를 사용하기 때문에 컴파일러 오류가 발생합니다 . 이 두 곳에서 모호합니다.</target>
        </trans-unit>
        <trans-unit id="b30b0ad80edd47c563a2e1776ed2c849ecd649e3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s often useful for a program to evaluate a condition within a loop. While the condition is true, the loop runs. When the condition ceases to be true, the program calls &lt;code&gt;break&lt;/code&gt;, stopping the loop. This loop type could be implemented using a combination of &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, and &lt;code&gt;break&lt;/code&gt;; you could try that now in a program, if you&amp;rsquo;d like.</source>
          <target state="translated">프로그램이 루프 내에서 조건을 평가하는 데 종종 유용합니다. 조건이 true 인 동안 루프가 실행됩니다. 조건이 참이되면 프로그램은 &lt;code&gt;break&lt;/code&gt; 를 호출 하고 루프를 중지합니다. 이 루프 유형은 &lt;code&gt;loop&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; 및 &lt;code&gt;break&lt;/code&gt; 조합을 사용하여 구현할 수 있습니다 . 원하는 경우 지금 프로그램에서 시도해 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a4b6828f8495332d03de5c3d6e1db7c761b6380" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s often useful to create a new instance of a struct that uses most of an old instance&amp;rsquo;s values but changes some. You&amp;rsquo;ll do this using &lt;em&gt;struct update syntax&lt;/em&gt;.</source>
          <target state="translated">오래된 인스턴스 값의 대부분을 사용하지만 일부를 변경하는 구조체의 새 인스턴스를 만드는 것이 종종 유용합니다. &lt;em&gt;struct update syntax&lt;/em&gt; 사용 하여이 작업을 수행 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="723b901f30cea9edf0e74e2f7413d0b6d6d9f846" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s often useful to execute a block of code more than once. For this task, Rust provides several &lt;em&gt;loops&lt;/em&gt;. A loop runs through the code inside the loop body to the end and then starts immediately back at the beginning. To experiment with loops, let&amp;rsquo;s make a new project called &lt;em&gt;loops&lt;/em&gt;.</source>
          <target state="translated">종종 코드 블록을 두 번 이상 실행하는 것이 유용합니다. 이 작업을 위해 Rust는 여러 개의 &lt;em&gt;루프를&lt;/em&gt; 제공합니다 . 루프는 루프 본체 내부의 코드를 끝까지 통과 한 다음 처음부터 즉시 다시 시작됩니다. 루프를 실험하기 위해, 새 프로젝트를 호출 할 수 있도록 &lt;em&gt;루프를&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="753665469cbfa717250694f7de09ac1968d71cfc" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible for structs to store references to data owned by something else, but to do so requires the use of &lt;em&gt;lifetimes&lt;/em&gt;, a Rust feature that we&amp;rsquo;ll discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct is valid for as long as the struct is. Let&amp;rsquo;s say you try to store a reference in a struct without specifying lifetimes, like this, which won&amp;rsquo;t work:</source>
          <target state="translated">그것은 뭔가 다른 소유 데이터 저장 참조 구조체 가능하지만 그렇게하는 것은의 사용이 필요 &lt;em&gt;수명을&lt;/em&gt; , 우리는 10 장 일생에서 논의 할 것이다하는 녹 기능은 구조체에 의해 참조되는 데이터는만큼 유효 있는지 확인 구조체가 그대로. 수명을 지정하지 않고 구조체에 참조를 저장하려고하면 다음과 같이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1330d73ba4baef219cde7c8056164e7a0d0b3b12" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to return multiple values using a tuple, as shown in Listing 4-5.</source>
          <target state="translated">Listing 4-5와 같이 튜플을 사용하여 여러 값을 반환 할 수있다.</target>
        </trans-unit>
        <trans-unit id="dd54062a6d4a18f88f50f4130b2d691d87e7c906" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s useful to discuss strings in the context of collections because strings are implemented as a collection of bytes, plus some methods to provide useful functionality when those bytes are interpreted as text. In this section, we&amp;rsquo;ll talk about the operations on &lt;code&gt;String&lt;/code&gt; that every collection type has, such as creating, updating, and reading. We&amp;rsquo;ll also discuss the ways in which &lt;code&gt;String&lt;/code&gt; is different from the other collections, namely how indexing into a &lt;code&gt;String&lt;/code&gt; is complicated by the differences between how people and computers interpret &lt;code&gt;String&lt;/code&gt; data.</source>
          <target state="translated">문자열은 바이트 모음으로 구현되므로 해당 바이트가 텍스트로 해석 될 때 유용한 기능을 제공하는 몇 가지 방법이 있기 때문에 컬렉션 컨텍스트에서 문자열을 토론하는 것이 유용합니다. 이 섹션에서는 생성, 업데이트 및 읽기와 같은 모든 컬렉션 유형 에 포함 된 &lt;code&gt;String&lt;/code&gt; 작업에 대해 설명합니다 . 또한 &lt;code&gt;String&lt;/code&gt; 이 다른 컬렉션과 다른 방식, 즉 사람과 컴퓨터가 &lt;code&gt;String&lt;/code&gt; 데이터를 해석하는 방식의 차이 로 인해 &lt;code&gt;String&lt;/code&gt; 인덱싱하는 방법이 어떻게 복잡한 지 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="08a5c61453f5e990492626e9bb6d14bf2f43a9aa" translate="yes" xml:space="preserve">
          <source>It's also important to note that the Rust compiler can generally determine the lifetime by itself. Example:</source>
          <target state="translated">Rust 컴파일러는 일반적으로 수명을 스스로 결정할 수 있다는 점도 중요합니다. 예:</target>
        </trans-unit>
        <trans-unit id="33ba7241cc90a10e5fee095fa049c987fe61e308" translate="yes" xml:space="preserve">
          <source>It's common for people who haven't used iterators a lot to use a &lt;code&gt;for&lt;/code&gt; loop with a list of things to build up a result. Those can be turned into &lt;code&gt;fold()&lt;/code&gt;s:</source>
          <target state="translated">반복자를 많이 사용하지 않은 사람들은 &lt;code&gt;for&lt;/code&gt; 루프 를 사용 하여 결과를 빌드 할 항목 목록 을 사용하는 것이 일반적입니다. 그것들은 &lt;code&gt;fold()&lt;/code&gt; 로 바꿀 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ba017d93d6349943ce3ed0d06f842a0f9c987ffa" translate="yes" xml:space="preserve">
          <source>It's common to instead use destructuring on the argument to strip away one:</source>
          <target state="translated">대신에 인수를 제거하여 제거하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="686ffc7f644232912f8eff3ec52197d230c78db4" translate="yes" xml:space="preserve">
          <source>It's important to note that in these two examples, the only difference is whether you are allowed to access &lt;code&gt;x&lt;/code&gt; after the assignment. Under the hood, both a copy and a move can result in bits being copied in memory, although this is sometimes optimized away.</source>
          <target state="translated">이 두 예 에서 할당 후 &lt;code&gt;x&lt;/code&gt; 에 액세스 할 수 있는지 여부 만 다릅니다 . 후드 아래에서 복사와 이동 모두 비트가 메모리에 복사 될 수 있지만 때로는 최적화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf0d2bc6515048c1222c1faf89f4b7dfbf926400" translate="yes" xml:space="preserve">
          <source>It's important to remember that &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a Unicode Scalar Value, and may not match your idea of what a 'character' is. Iteration over grapheme clusters may be what you actually want.</source>
          <target state="translated">그것은 그 기억하는 것이 중요 &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 유니 코드 스칼라 값 표현하고, '문자'가 무엇인지에 대한 당신의 생각과 일치하지 않을 수 있습니다. grapheme 클러스터에 대한 반복은 실제로 원하는 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a89bf255278a9fcad7529f6bfd4c6a49b45cb147" translate="yes" xml:space="preserve">
          <source>It's important to remember that &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a Unicode Scalar Value, and may not match your idea of what a 'character' is. Iteration over grapheme clusters may be what you actually want. This functionality is not provided by Rust's standard library, check crates.io instead.</source>
          <target state="translated">&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 는 유니 코드 스칼라 값을 나타내며 '문자'가 무엇인지에 대한 아이디어와 일치하지 않을 수 있음을 기억하는 것이 중요합니다 . grapheme 클러스터에 대한 반복은 실제로 원하는 것일 수 있습니다. 이 기능은 Rust의 표준 라이브러리에서 제공하지 않습니다. 대신 crates.io를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a4da28ef521125e0c1be74a0e5b5fccf5a9444a6" translate="yes" xml:space="preserve">
          <source>It's important to remember that &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a Unicode Scalar Value, and may not match your idea of what a 'character' is. Iteration over grapheme clusters may be what you actually want.</source>
          <target state="translated">그것은 그 기억하는 것이 중요 &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 유니 코드 스칼라 값 표현하고, '문자'가 무엇인지에 대한 당신의 생각과 일치하지 않을 수 있습니다. grapheme 클러스터에 대한 반복은 실제로 원하는 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21dabe83c3c9b91d37de871b20d8a3fe9aea8d87" translate="yes" xml:space="preserve">
          <source>It's important to remember that &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a Unicode Scalar Value, and may not match your idea of what a 'character' is. Iteration over grapheme clusters may be what you actually want. This functionality is not provided by Rust's standard library, check crates.io instead.</source>
          <target state="translated">&lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 는 유니 코드 스칼라 값을 나타내며 '문자'가 무엇인지에 대한 아이디어와 일치하지 않을 수 있음을 기억하는 것이 중요합니다 . grapheme 클러스터에 대한 반복은 실제로 원하는 것일 수 있습니다. 이 기능은 Rust의 표준 라이브러리에서 제공하지 않습니다. 대신 crates.io를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="34560c82a9fb0dc71d1acee3f7d70c175383bc7b" translate="yes" xml:space="preserve">
          <source>It's invalid to directly import methods belonging to a trait or concrete type.</source>
          <target state="translated">특성 또는 구체적인 유형에 속하는 메소드를 직접 가져 오는 것은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4ea1a04986d9525398a48411915463d79b08630" translate="yes" xml:space="preserve">
          <source>It's more common for &lt;code&gt;inspect()&lt;/code&gt; to be used as a debugging tool than to exist in your final code, but applications may find it useful in certain situations when errors need to be logged before being discarded.</source>
          <target state="translated">&lt;code&gt;inspect()&lt;/code&gt; 가 최종 코드에 존재하는 것보다 디버깅 도구로 사용되는 것이 더 일반적 이지만 응용 프로그램은 오류를 삭제하기 전에 기록해야하는 특정 상황에서 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f6fd4d024f3a27229b0326aaec954fc7e7267f9" translate="yes" xml:space="preserve">
          <source>It's only possible to directly instantiate a struct using struct literal syntax when all of its fields are visible to you.</source>
          <target state="translated">모든 필드를 볼 수있을 때 구조체 리터럴 구문을 사용하여 구조체를 직접 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc2a391a320094b486e218290333929f21b82924" translate="yes" xml:space="preserve">
          <source>It's undefined behavior if global allocators unwind. This restriction may be lifted in the future, but currently a panic from any of these functions may lead to memory unsafety.</source>
          <target state="translated">글로벌 할당자가 긴장을 풀면 정의되지 않은 동작입니다. 이 제한은 향후에 해제 될 수 있지만 현재 이러한 기능 중 하나에서 패닉이 발생하면 메모리가 안전하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90d66c69bdab0c4f62a7abada1a3e2fdee354d75" translate="yes" xml:space="preserve">
          <source>It's very common then to put a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; inside shared pointer types to reintroduce mutability:</source>
          <target state="translated">그런 다음 공유 포인터 유형 내에 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 을 넣어 변경 가능성을 다시 도입 하는 것이 매우 일반적입니다 .</target>
        </trans-unit>
        <trans-unit id="21df73947a06d77d2ad5fe166c8ddfcdc53a6fdb" translate="yes" xml:space="preserve">
          <source>Italiano</source>
          <target state="translated">Italiano</target>
        </trans-unit>
        <trans-unit id="1927b99b7203a5d61bb78b1a858edbf1a4446227" translate="yes" xml:space="preserve">
          <source>Item declarations</source>
          <target state="translated">아이템 선언</target>
        </trans-unit>
        <trans-unit id="052ff2f8a72886a3883816a6bea2ff5da9ae8dcc" translate="yes" xml:space="preserve">
          <source>Item visibility</source>
          <target state="translated">항목 가시성</target>
        </trans-unit>
        <trans-unit id="44d25b5d1b6d98c7d090ca3609aca11ae2815fa0" translate="yes" xml:space="preserve">
          <source>Items</source>
          <target state="translated">Items</target>
        </trans-unit>
        <trans-unit id="e94f4a33f00d601e0668e3316c1f5baec10b371b" translate="yes" xml:space="preserve">
          <source>Items are entirely determined at compile-time, generally remain fixed during execution, and may reside in read-only memory.</source>
          <target state="translated">항목은 컴파일 타임에 완전히 결정되며 일반적으로 실행 중에 고정 된 상태로 유지되며 읽기 전용 메모리에 상주 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d65bc9662d384da5396d0c23266596b91dc5d76b" translate="yes" xml:space="preserve">
          <source>Items are missing in a trait implementation.</source>
          <target state="translated">특성 구현에 항목이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ddf93f2b738152017441b72f8223700a6c86d570" translate="yes" xml:space="preserve">
          <source>Items are missing in a trait implementation. Erroneous code example:</source>
          <target state="translated">특성 구현에서 항목이 누락되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="e8b3f0ebaa39e2f70c17e1cb57e9f0ef34b2a7cd" translate="yes" xml:space="preserve">
          <source>Items associated with a trait do not need to be defined in the trait, but they may be. If the trait provides a definition, then this definition acts as a default for any implementation which does not override it. If it does not, then any implementation must provide a definition.</source>
          <target state="translated">특성과 관련된 항목은 특성에서 정의 할 필요는 없지만 정의 할 수 있습니다. 특성이 정의를 제공하는 경우이 정의는이를 대체하지 않는 모든 구현의 기본값으로 작동합니다. 그렇지 않은 경우 모든 구현에서 정의를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="d525f8eb402a25c60f5c5ba9759986177ee5a851" translate="yes" xml:space="preserve">
          <source>Items can be imported without binding to a name by using an underscore with the form &lt;code&gt;use path as _&lt;/code&gt;. This is particularly useful to import a trait so that its methods may be used without importing the trait's symbol, for example if the trait's symbol may conflict with another symbol. Another example is to link an external crate without importing its name.</source>
          <target state="translated">&lt;code&gt;use path as _&lt;/code&gt; 밑줄을 사용하여 이름에 바인딩하지 않고 항목을 가져올 수 있습니다 . 이는 특성의 기호가 다른 기호와 충돌 할 수있는 경우와 같이 특성의 기호를 가져 오지 않고 해당 방법을 사용할 수 있도록 특성을 가져 오는 데 특히 유용합니다. 또 다른 예는 이름을 가져 오지 않고 외부 상자를 연결하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d80427c3d2c84e1095c0f47d752a2b536590da04" translate="yes" xml:space="preserve">
          <source>Items defined in a module or implementation have a &lt;em&gt;canonical path&lt;/em&gt; that corresponds to where within its crate it is defined. All other paths to these items are aliases. The canonical path is defined as a &lt;em&gt;path prefix&lt;/em&gt; appended by the path segment the item itself defines.</source>
          <target state="translated">모듈 또는 구현에 정의 된 항목 은 해당 상자 내에서 정의 된 위치에 해당 하는 &lt;em&gt;정식 경로&lt;/em&gt; 를 갖습니다 . 이러한 항목에 대한 다른 모든 경로는 별칭입니다. 정식 경로는 항목 자체가 정의한 경로 세그먼트가 추가 된 &lt;em&gt;경로 접두사로&lt;/em&gt; 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="dff50658b0fc9891bf43ec3aa222a12df699a4f5" translate="yes" xml:space="preserve">
          <source>Items inside functions are basically just like top-level items, except that they can only be used from the function they are in.</source>
          <target state="translated">함수 내부의 항목은 기본적으로 최상위 항목과 같습니다. 단, 해당 함수에서만 사용할 수 있다는 점이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="091b8d78ec3176b66348479ab0a7eba113756aa7" translate="yes" xml:space="preserve">
          <source>Iter</source>
          <target state="translated">Iter</target>
        </trans-unit>
        <trans-unit id="562356f4191fd96292159c9a51f1502a656a766d" translate="yes" xml:space="preserve">
          <source>Iter::all</source>
          <target state="translated">Iter::all</target>
        </trans-unit>
        <trans-unit id="598e9d1442d2d90b30d41f52dc9f35d312a9ea85" translate="yes" xml:space="preserve">
          <source>Iter::any</source>
          <target state="translated">Iter::any</target>
        </trans-unit>
        <trans-unit id="11c24b7b71f44b4c32bd475993cf94651f69ef7b" translate="yes" xml:space="preserve">
          <source>Iter::as_path</source>
          <target state="translated">Iter::as_path</target>
        </trans-unit>
        <trans-unit id="b00470be46e8b1319d806bf1fedc19612d599118" translate="yes" xml:space="preserve">
          <source>Iter::as_ref</source>
          <target state="translated">Iter::as_ref</target>
        </trans-unit>
        <trans-unit id="1c4a85c9060fc0533851d2ebb18b0944dec20504" translate="yes" xml:space="preserve">
          <source>Iter::as_slice</source>
          <target state="translated">Iter::as_slice</target>
        </trans-unit>
        <trans-unit id="cd753ac2ff5d2f5e373d6da3f28eb6cc4f4a12da" translate="yes" xml:space="preserve">
          <source>Iter::borrow</source>
          <target state="translated">Iter::borrow</target>
        </trans-unit>
        <trans-unit id="ccae721db6c0b80ead456e39e15a574d91f05503" translate="yes" xml:space="preserve">
          <source>Iter::borrow_mut</source>
          <target state="translated">Iter::borrow_mut</target>
        </trans-unit>
        <trans-unit id="9e9e1cc006a1a0c230f182d60dc3ae25867fa96b" translate="yes" xml:space="preserve">
          <source>Iter::by_ref</source>
          <target state="translated">Iter::by_ref</target>
        </trans-unit>
        <trans-unit id="40958308a6a00b30f0186ac470a90b4263782276" translate="yes" xml:space="preserve">
          <source>Iter::chain</source>
          <target state="translated">Iter::chain</target>
        </trans-unit>
        <trans-unit id="a16e2afb6a204e2c61484cc43715d2838e449cea" translate="yes" xml:space="preserve">
          <source>Iter::clone</source>
          <target state="translated">Iter::clone</target>
        </trans-unit>
        <trans-unit id="d33632634125b5bfb914d7696031de5e4050211f" translate="yes" xml:space="preserve">
          <source>Iter::clone_from</source>
          <target state="translated">Iter::clone_from</target>
        </trans-unit>
        <trans-unit id="c521a7d4341dba591b54fa4bc0805ada3d50f399" translate="yes" xml:space="preserve">
          <source>Iter::clone_into</source>
          <target state="translated">Iter::clone_into</target>
        </trans-unit>
        <trans-unit id="566bebbe7d115865fba84687df984d4d09e626cd" translate="yes" xml:space="preserve">
          <source>Iter::cloned</source>
          <target state="translated">Iter::cloned</target>
        </trans-unit>
        <trans-unit id="49fa3b568d34193bae851426004f13121d5dfbf5" translate="yes" xml:space="preserve">
          <source>Iter::cmp</source>
          <target state="translated">Iter::cmp</target>
        </trans-unit>
        <trans-unit id="8a894f2ab589ed2151abc86111334156ce8c99e0" translate="yes" xml:space="preserve">
          <source>Iter::collect</source>
          <target state="translated">Iter::collect</target>
        </trans-unit>
        <trans-unit id="d84a1dc76269ab42456219572352b77058751d5b" translate="yes" xml:space="preserve">
          <source>Iter::copied</source>
          <target state="translated">Iter::copied</target>
        </trans-unit>
        <trans-unit id="e3337214a7610ab020e239ae370944a464cce517" translate="yes" xml:space="preserve">
          <source>Iter::count</source>
          <target state="translated">Iter::count</target>
        </trans-unit>
        <trans-unit id="e2ed51e9cb2227202dee5fc9ebaab5c5c44fe8c9" translate="yes" xml:space="preserve">
          <source>Iter::cycle</source>
          <target state="translated">Iter::cycle</target>
        </trans-unit>
        <trans-unit id="b1eb95f6c453fe7f1cf4909e898eaf13d79e9e40" translate="yes" xml:space="preserve">
          <source>Iter::enumerate</source>
          <target state="translated">Iter::enumerate</target>
        </trans-unit>
        <trans-unit id="f2edb3630485a9830839e0b2bd5394c408a64499" translate="yes" xml:space="preserve">
          <source>Iter::eq</source>
          <target state="translated">Iter::eq</target>
        </trans-unit>
        <trans-unit id="f27a886f8dd8072bf872054aa4fa798de4583d5b" translate="yes" xml:space="preserve">
          <source>Iter::filter</source>
          <target state="translated">Iter::filter</target>
        </trans-unit>
        <trans-unit id="9f085b504d73e51e20340f0c14d7d3ec20d8c09e" translate="yes" xml:space="preserve">
          <source>Iter::filter_map</source>
          <target state="translated">Iter::filter_map</target>
        </trans-unit>
        <trans-unit id="482d391704ccfc6551b38406a5c7e4a07c0b7dc9" translate="yes" xml:space="preserve">
          <source>Iter::find</source>
          <target state="translated">Iter::find</target>
        </trans-unit>
        <trans-unit id="cf9a0662f2645651e697db323db99571753cf8fe" translate="yes" xml:space="preserve">
          <source>Iter::find_map</source>
          <target state="translated">Iter::find_map</target>
        </trans-unit>
        <trans-unit id="1afb3fc5d230f5ed3a998d62e9235b71e0c70e53" translate="yes" xml:space="preserve">
          <source>Iter::flat_map</source>
          <target state="translated">Iter::flat_map</target>
        </trans-unit>
        <trans-unit id="233b4826a12d699f0512cb0d95df19aaab9dd4ca" translate="yes" xml:space="preserve">
          <source>Iter::flatten</source>
          <target state="translated">Iter::flatten</target>
        </trans-unit>
        <trans-unit id="7f47a4f5f722efa8de94b21b465ada55ddfa53c5" translate="yes" xml:space="preserve">
          <source>Iter::fmt</source>
          <target state="translated">Iter::fmt</target>
        </trans-unit>
        <trans-unit id="2d150a20937e50aeb5fc3c33739f77c30ca57b98" translate="yes" xml:space="preserve">
          <source>Iter::fold</source>
          <target state="translated">Iter::fold</target>
        </trans-unit>
        <trans-unit id="9ee0b5e31b874c88b499b0f63ac35f2da29dcbb1" translate="yes" xml:space="preserve">
          <source>Iter::for_each</source>
          <target state="translated">Iter::for_each</target>
        </trans-unit>
        <trans-unit id="fb5570128f1baf2cde42d918eac6ebeb0e442ac8" translate="yes" xml:space="preserve">
          <source>Iter::from</source>
          <target state="translated">Iter::from</target>
        </trans-unit>
        <trans-unit id="840450e607dae83abf8fa2b370c6fb1be77c898b" translate="yes" xml:space="preserve">
          <source>Iter::fuse</source>
          <target state="translated">Iter::fuse</target>
        </trans-unit>
        <trans-unit id="23bdea91405b4acdaeed6b4d07b8c58d93cbd9ee" translate="yes" xml:space="preserve">
          <source>Iter::ge</source>
          <target state="translated">Iter::ge</target>
        </trans-unit>
        <trans-unit id="47e26389513b5fb9c312c18d98dfcb98e224fec9" translate="yes" xml:space="preserve">
          <source>Iter::gt</source>
          <target state="translated">Iter::gt</target>
        </trans-unit>
        <trans-unit id="ce4e0788e86ba75e4d44e53b0367cc1f2f04da63" translate="yes" xml:space="preserve">
          <source>Iter::inspect</source>
          <target state="translated">Iter::inspect</target>
        </trans-unit>
        <trans-unit id="84b381fb810d521e23ba1af41b818ce7d2699ac5" translate="yes" xml:space="preserve">
          <source>Iter::into</source>
          <target state="translated">Iter::into</target>
        </trans-unit>
        <trans-unit id="0ec8b2c7e9866e4932264828ae5ae53473579659" translate="yes" xml:space="preserve">
          <source>Iter::into_iter</source>
          <target state="translated">Iter::into_iter</target>
        </trans-unit>
        <trans-unit id="fef12e1b5037aa29137e1d32a9384c2c3b1a9d46" translate="yes" xml:space="preserve">
          <source>Iter::is_empty</source>
          <target state="translated">Iter::is_empty</target>
        </trans-unit>
        <trans-unit id="c845a405850165bfe2d3ee71bdc1256c40185ebf" translate="yes" xml:space="preserve">
          <source>Iter::is_sorted</source>
          <target state="translated">Iter::is_sorted</target>
        </trans-unit>
        <trans-unit id="12877f076c9cd1f4b18bb0043ef86e4ecaae9828" translate="yes" xml:space="preserve">
          <source>Iter::is_sorted_by</source>
          <target state="translated">Iter::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="20997a51f1e8798fb3f3c383fb60434b3e8cb926" translate="yes" xml:space="preserve">
          <source>Iter::is_sorted_by_key</source>
          <target state="translated">Iter::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="b86d7151989059491e48352d38e9c3a298578cd1" translate="yes" xml:space="preserve">
          <source>Iter::last</source>
          <target state="translated">Iter::last</target>
        </trans-unit>
        <trans-unit id="be8b408760eecdbf28c58c97d461c17d4700ffae" translate="yes" xml:space="preserve">
          <source>Iter::le</source>
          <target state="translated">Iter::le</target>
        </trans-unit>
        <trans-unit id="0c6655f000bb8d852e4c2ebc7d52bd9826150f55" translate="yes" xml:space="preserve">
          <source>Iter::len</source>
          <target state="translated">Iter::len</target>
        </trans-unit>
        <trans-unit id="f5f969c8865a706d946ba8d9640ca2c5a0bcf40e" translate="yes" xml:space="preserve">
          <source>Iter::lt</source>
          <target state="translated">Iter::lt</target>
        </trans-unit>
        <trans-unit id="bc0be7886235deb5cb7d836720591efa37538450" translate="yes" xml:space="preserve">
          <source>Iter::map</source>
          <target state="translated">Iter::map</target>
        </trans-unit>
        <trans-unit id="d7746cc600a78a4b80fd8b858ffaf0fe418f31a5" translate="yes" xml:space="preserve">
          <source>Iter::max</source>
          <target state="translated">Iter::max</target>
        </trans-unit>
        <trans-unit id="bdd59dfbd93f93e5159fb6bb4b959f6208971864" translate="yes" xml:space="preserve">
          <source>Iter::max_by</source>
          <target state="translated">Iter::max_by</target>
        </trans-unit>
        <trans-unit id="f2c43a9070f91fd7b274911cb1767f64abad6d73" translate="yes" xml:space="preserve">
          <source>Iter::max_by_key</source>
          <target state="translated">Iter::max_by_key</target>
        </trans-unit>
        <trans-unit id="4953889b3e4b5985acf4e330c37581c731343efb" translate="yes" xml:space="preserve">
          <source>Iter::min</source>
          <target state="translated">Iter::min</target>
        </trans-unit>
        <trans-unit id="a4a384bc464b64ebda76930693b161019c57569b" translate="yes" xml:space="preserve">
          <source>Iter::min_by</source>
          <target state="translated">Iter::min_by</target>
        </trans-unit>
        <trans-unit id="c1b4af4d4490229831ed89e5d2564fd1a077b311" translate="yes" xml:space="preserve">
          <source>Iter::min_by_key</source>
          <target state="translated">Iter::min_by_key</target>
        </trans-unit>
        <trans-unit id="16cc992c33d00ce5220249a5220c02b65f8e4e1b" translate="yes" xml:space="preserve">
          <source>Iter::ne</source>
          <target state="translated">Iter::ne</target>
        </trans-unit>
        <trans-unit id="5726d1319a6927ed8641e6153ccd76700e05b49d" translate="yes" xml:space="preserve">
          <source>Iter::next</source>
          <target state="translated">Iter::next</target>
        </trans-unit>
        <trans-unit id="73c0a4abe0cf04469092e41f4f2fe0440e2dba4e" translate="yes" xml:space="preserve">
          <source>Iter::next_back</source>
          <target state="translated">Iter::next_back</target>
        </trans-unit>
        <trans-unit id="71ecfc9eea70a0501cbf73f369a815090a015495" translate="yes" xml:space="preserve">
          <source>Iter::nth</source>
          <target state="translated">Iter::nth</target>
        </trans-unit>
        <trans-unit id="c585764b69dade897771dda3b24e4c7fa05c8894" translate="yes" xml:space="preserve">
          <source>Iter::nth_back</source>
          <target state="translated">Iter::nth_back</target>
        </trans-unit>
        <trans-unit id="f0d7a323f948a119f8ad33ad48acc983a8d68fd3" translate="yes" xml:space="preserve">
          <source>Iter::partial_cmp</source>
          <target state="translated">Iter::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d508da27672fef4e1401a3134f511ffdb76349df" translate="yes" xml:space="preserve">
          <source>Iter::partition</source>
          <target state="translated">Iter::partition</target>
        </trans-unit>
        <trans-unit id="b7e23f6eab45233e924f47870e7155a7d93ac461" translate="yes" xml:space="preserve">
          <source>Iter::peekable</source>
          <target state="translated">Iter::peekable</target>
        </trans-unit>
        <trans-unit id="c6069463aa7c4524fc50e7f8524606571f2479a2" translate="yes" xml:space="preserve">
          <source>Iter::position</source>
          <target state="translated">Iter::position</target>
        </trans-unit>
        <trans-unit id="49a5d1c1b47f8042ecc9f92065cab6ee7c7e1cc2" translate="yes" xml:space="preserve">
          <source>Iter::product</source>
          <target state="translated">Iter::product</target>
        </trans-unit>
        <trans-unit id="226d371b07f791bdc3b75f6182aa99ed768f3c2f" translate="yes" xml:space="preserve">
          <source>Iter::rev</source>
          <target state="translated">Iter::rev</target>
        </trans-unit>
        <trans-unit id="0e61327392e92ba0988cedb744e914baec8d327a" translate="yes" xml:space="preserve">
          <source>Iter::rfind</source>
          <target state="translated">Iter::rfind</target>
        </trans-unit>
        <trans-unit id="436b05314063cdc717e75ffae43d2197b71db43d" translate="yes" xml:space="preserve">
          <source>Iter::rfold</source>
          <target state="translated">Iter::rfold</target>
        </trans-unit>
        <trans-unit id="ff90d1def598911fc5bfcb191f5cc4a07e4d1561" translate="yes" xml:space="preserve">
          <source>Iter::rposition</source>
          <target state="translated">Iter::rposition</target>
        </trans-unit>
        <trans-unit id="e85d8810cc5f5069c23f9a8039d15b9337b41c52" translate="yes" xml:space="preserve">
          <source>Iter::scan</source>
          <target state="translated">Iter::scan</target>
        </trans-unit>
        <trans-unit id="02418ffbb8d48f42372da15dae730f8a6afc35b5" translate="yes" xml:space="preserve">
          <source>Iter::size_hint</source>
          <target state="translated">Iter::size_hint</target>
        </trans-unit>
        <trans-unit id="4369939a1ce2e9f84ffb9bdab8e42a905e51bdaa" translate="yes" xml:space="preserve">
          <source>Iter::skip</source>
          <target state="translated">Iter::skip</target>
        </trans-unit>
        <trans-unit id="366d06ce202700d06e1162480b372fb9fe5f9f48" translate="yes" xml:space="preserve">
          <source>Iter::skip_while</source>
          <target state="translated">Iter::skip_while</target>
        </trans-unit>
        <trans-unit id="32cde76eb29f240c9e4df839757b9c8dee038962" translate="yes" xml:space="preserve">
          <source>Iter::step_by</source>
          <target state="translated">Iter::step_by</target>
        </trans-unit>
        <trans-unit id="17f9c830155902444763f7911cd38ce5759e0af8" translate="yes" xml:space="preserve">
          <source>Iter::sum</source>
          <target state="translated">Iter::sum</target>
        </trans-unit>
        <trans-unit id="dcb50b3349dc76f0b288cc8da46262ff9851d3ff" translate="yes" xml:space="preserve">
          <source>Iter::take</source>
          <target state="translated">Iter::take</target>
        </trans-unit>
        <trans-unit id="cde2481711540ccdcb763463f9a8e48ead5b8c11" translate="yes" xml:space="preserve">
          <source>Iter::take_while</source>
          <target state="translated">Iter::take_while</target>
        </trans-unit>
        <trans-unit id="7be8f868236c0bacde7fa60a245f689dbd73f4b1" translate="yes" xml:space="preserve">
          <source>Iter::to_owned</source>
          <target state="translated">Iter::to_owned</target>
        </trans-unit>
        <trans-unit id="a61b9bdc8bf2d65e849104ea9f9ddb34b2e438f1" translate="yes" xml:space="preserve">
          <source>Iter::try_fold</source>
          <target state="translated">Iter::try_fold</target>
        </trans-unit>
        <trans-unit id="a376d6605801d1f94fdc5bc8378bfb7d3bf0f291" translate="yes" xml:space="preserve">
          <source>Iter::try_for_each</source>
          <target state="translated">Iter::try_for_each</target>
        </trans-unit>
        <trans-unit id="4742b7e7ce2dc63b3cde1feac9ff7841b386d97b" translate="yes" xml:space="preserve">
          <source>Iter::try_from</source>
          <target state="translated">Iter::try_from</target>
        </trans-unit>
        <trans-unit id="305f66fe9d6f3bd4da9108c4fb964e6d3d7ae558" translate="yes" xml:space="preserve">
          <source>Iter::try_into</source>
          <target state="translated">Iter::try_into</target>
        </trans-unit>
        <trans-unit id="28e819d5eb5da6c1ca2f6898d2a9682f6bd3113c" translate="yes" xml:space="preserve">
          <source>Iter::try_rfold</source>
          <target state="translated">Iter::try_rfold</target>
        </trans-unit>
        <trans-unit id="5431b8f7a2f8d57a1b9712ca70970d17da1898b4" translate="yes" xml:space="preserve">
          <source>Iter::type_id</source>
          <target state="translated">Iter::type_id</target>
        </trans-unit>
        <trans-unit id="ba93aa487eb63805115eee9259cd946bbcc81dc7" translate="yes" xml:space="preserve">
          <source>Iter::unzip</source>
          <target state="translated">Iter::unzip</target>
        </trans-unit>
        <trans-unit id="2eb63393ea4d4a003b71033749175816e8e34fdf" translate="yes" xml:space="preserve">
          <source>Iter::zip</source>
          <target state="translated">Iter::zip</target>
        </trans-unit>
        <trans-unit id="685f18edffd1064c20f2b29242001a402ffdb3fc" translate="yes" xml:space="preserve">
          <source>IterMut</source>
          <target state="translated">IterMut</target>
        </trans-unit>
        <trans-unit id="d15ac12246998b60e4436683e1d97cc9ae701e03" translate="yes" xml:space="preserve">
          <source>IterMut::all</source>
          <target state="translated">IterMut::all</target>
        </trans-unit>
        <trans-unit id="c1e555b3dfd69f8056e360cb14a2a01feb0013e6" translate="yes" xml:space="preserve">
          <source>IterMut::any</source>
          <target state="translated">IterMut::any</target>
        </trans-unit>
        <trans-unit id="fbe3dac2bb3b890d1d56cbc2f3fa0126fa2d43e8" translate="yes" xml:space="preserve">
          <source>IterMut::as_slice</source>
          <target state="translated">IterMut::as_slice</target>
        </trans-unit>
        <trans-unit id="0a947d1a8be02e41fa37714da075d627e9a6d6da" translate="yes" xml:space="preserve">
          <source>IterMut::borrow</source>
          <target state="translated">IterMut::borrow</target>
        </trans-unit>
        <trans-unit id="f88bb4554293b88f8dc1c8bb69415e923325b965" translate="yes" xml:space="preserve">
          <source>IterMut::borrow_mut</source>
          <target state="translated">IterMut::borrow_mut</target>
        </trans-unit>
        <trans-unit id="48fa60a837a6bc036bd0c7d9497e19c4f719ec84" translate="yes" xml:space="preserve">
          <source>IterMut::by_ref</source>
          <target state="translated">IterMut::by_ref</target>
        </trans-unit>
        <trans-unit id="f5d9bc35cc15ce8be47292ce1998b21d7b90f454" translate="yes" xml:space="preserve">
          <source>IterMut::chain</source>
          <target state="translated">IterMut::chain</target>
        </trans-unit>
        <trans-unit id="4859f67bc45d1cfa5be5d41026dcf3b89772eceb" translate="yes" xml:space="preserve">
          <source>IterMut::cloned</source>
          <target state="translated">IterMut::cloned</target>
        </trans-unit>
        <trans-unit id="0680e13c44f187b2e2903bd2e1023ab5334923ea" translate="yes" xml:space="preserve">
          <source>IterMut::cmp</source>
          <target state="translated">IterMut::cmp</target>
        </trans-unit>
        <trans-unit id="a0e64fc534b3756ecdc15f5f8acaf539397a5145" translate="yes" xml:space="preserve">
          <source>IterMut::collect</source>
          <target state="translated">IterMut::collect</target>
        </trans-unit>
        <trans-unit id="95a4dd4c3dfd61737eaad683762b0bc7a7f9e7fc" translate="yes" xml:space="preserve">
          <source>IterMut::copied</source>
          <target state="translated">IterMut::copied</target>
        </trans-unit>
        <trans-unit id="5766f26143f5bcf6f3046a585e17bcfe339aad1e" translate="yes" xml:space="preserve">
          <source>IterMut::count</source>
          <target state="translated">IterMut::count</target>
        </trans-unit>
        <trans-unit id="b687092d76c8cc05745b7269130d0abfdaca355d" translate="yes" xml:space="preserve">
          <source>IterMut::cycle</source>
          <target state="translated">IterMut::cycle</target>
        </trans-unit>
        <trans-unit id="6d2db6ed0889c67bb6b498f2b3f67091fe29b968" translate="yes" xml:space="preserve">
          <source>IterMut::enumerate</source>
          <target state="translated">IterMut::enumerate</target>
        </trans-unit>
        <trans-unit id="fb228b5c55ad8378b706b298cb18e19a8d1b92e0" translate="yes" xml:space="preserve">
          <source>IterMut::eq</source>
          <target state="translated">IterMut::eq</target>
        </trans-unit>
        <trans-unit id="10b9735610da183bc0904cfcdc41b325717c5fa4" translate="yes" xml:space="preserve">
          <source>IterMut::filter</source>
          <target state="translated">IterMut::filter</target>
        </trans-unit>
        <trans-unit id="50b5344a605daa6db154682749d39063c82b3aa3" translate="yes" xml:space="preserve">
          <source>IterMut::filter_map</source>
          <target state="translated">IterMut::filter_map</target>
        </trans-unit>
        <trans-unit id="bc7ee8167e059bacfd966b6012e519970cd73008" translate="yes" xml:space="preserve">
          <source>IterMut::find</source>
          <target state="translated">IterMut::find</target>
        </trans-unit>
        <trans-unit id="410d4ebdc94090e744fedb731647c7ec0d8578cc" translate="yes" xml:space="preserve">
          <source>IterMut::find_map</source>
          <target state="translated">IterMut::find_map</target>
        </trans-unit>
        <trans-unit id="65e5eda673bd31f19324431c366d3dfedb17fb01" translate="yes" xml:space="preserve">
          <source>IterMut::flat_map</source>
          <target state="translated">IterMut::flat_map</target>
        </trans-unit>
        <trans-unit id="b284560776dd5bb1ff4273557604dbb2553c7c07" translate="yes" xml:space="preserve">
          <source>IterMut::flatten</source>
          <target state="translated">IterMut::flatten</target>
        </trans-unit>
        <trans-unit id="ab0f6e0b99bf1433157d69dc73b614b9ae6780fe" translate="yes" xml:space="preserve">
          <source>IterMut::fmt</source>
          <target state="translated">IterMut::fmt</target>
        </trans-unit>
        <trans-unit id="4b759c2db23677552fe4a6582ff9535f267cf416" translate="yes" xml:space="preserve">
          <source>IterMut::fold</source>
          <target state="translated">IterMut::fold</target>
        </trans-unit>
        <trans-unit id="ff2b68bb585bc2eef74e222255298430657bd568" translate="yes" xml:space="preserve">
          <source>IterMut::for_each</source>
          <target state="translated">IterMut::for_each</target>
        </trans-unit>
        <trans-unit id="a33e41fe818af66e485ef7d3667b7d969b562154" translate="yes" xml:space="preserve">
          <source>IterMut::from</source>
          <target state="translated">IterMut::from</target>
        </trans-unit>
        <trans-unit id="b0e6a8de88a1b4c1f800636e965b45722312ad0f" translate="yes" xml:space="preserve">
          <source>IterMut::fuse</source>
          <target state="translated">IterMut::fuse</target>
        </trans-unit>
        <trans-unit id="664fd7bab24c7daac348bb72a1609830e80d691b" translate="yes" xml:space="preserve">
          <source>IterMut::ge</source>
          <target state="translated">IterMut::ge</target>
        </trans-unit>
        <trans-unit id="6bfb9c74b746559572b1cb3b3a42167374cd95d6" translate="yes" xml:space="preserve">
          <source>IterMut::gt</source>
          <target state="translated">IterMut::gt</target>
        </trans-unit>
        <trans-unit id="661eb528c55fa69d49ca565e9e26cfd5ddfff9bb" translate="yes" xml:space="preserve">
          <source>IterMut::inspect</source>
          <target state="translated">IterMut::inspect</target>
        </trans-unit>
        <trans-unit id="0085a0c4d6891c0fa655511a1f17f0c6798fffe3" translate="yes" xml:space="preserve">
          <source>IterMut::into</source>
          <target state="translated">IterMut::into</target>
        </trans-unit>
        <trans-unit id="f9d872a7753c37096516c695a54e36bf555e681e" translate="yes" xml:space="preserve">
          <source>IterMut::into_iter</source>
          <target state="translated">IterMut::into_iter</target>
        </trans-unit>
        <trans-unit id="56c9e9ebed846a8f50f7cd23275cf61e51741490" translate="yes" xml:space="preserve">
          <source>IterMut::into_slice</source>
          <target state="translated">IterMut::into_slice</target>
        </trans-unit>
        <trans-unit id="85db2b71d3d95945de22fd6957284758e551f164" translate="yes" xml:space="preserve">
          <source>IterMut::is_empty</source>
          <target state="translated">IterMut::is_empty</target>
        </trans-unit>
        <trans-unit id="057c3534bd6c2db79908fbeb1a2667df6a91093f" translate="yes" xml:space="preserve">
          <source>IterMut::is_sorted</source>
          <target state="translated">IterMut::is_sorted</target>
        </trans-unit>
        <trans-unit id="f6db0e52cbdd1cc2839465c01104f6e07b7e10a1" translate="yes" xml:space="preserve">
          <source>IterMut::is_sorted_by</source>
          <target state="translated">IterMut::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="946b50eea7f94363f84f06fd925cc2268637ae6d" translate="yes" xml:space="preserve">
          <source>IterMut::is_sorted_by_key</source>
          <target state="translated">IterMut::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="65af3e32ba1cf5aa400435aa3fc4596f2e5a4e39" translate="yes" xml:space="preserve">
          <source>IterMut::last</source>
          <target state="translated">IterMut::last</target>
        </trans-unit>
        <trans-unit id="7443e3959cb51f380b4aef241caca0a305e10720" translate="yes" xml:space="preserve">
          <source>IterMut::le</source>
          <target state="translated">IterMut::le</target>
        </trans-unit>
        <trans-unit id="1762aa132da5d0386a5ab5fa889856d0873e884a" translate="yes" xml:space="preserve">
          <source>IterMut::len</source>
          <target state="translated">IterMut::len</target>
        </trans-unit>
        <trans-unit id="e9d8a70597f6275813f3185cc0aa3025f469551a" translate="yes" xml:space="preserve">
          <source>IterMut::lt</source>
          <target state="translated">IterMut::lt</target>
        </trans-unit>
        <trans-unit id="a21d9b76e7d9ffcd6558423c0bce4cbb10973697" translate="yes" xml:space="preserve">
          <source>IterMut::map</source>
          <target state="translated">IterMut::map</target>
        </trans-unit>
        <trans-unit id="c3e262249b1040974db8d46e55cbdb196ff35924" translate="yes" xml:space="preserve">
          <source>IterMut::max</source>
          <target state="translated">IterMut::max</target>
        </trans-unit>
        <trans-unit id="45f2597a4580057864afc9b38782024b25dbed8f" translate="yes" xml:space="preserve">
          <source>IterMut::max_by</source>
          <target state="translated">IterMut::max_by</target>
        </trans-unit>
        <trans-unit id="4cfc9346f59180a900cadc955b42333b50460424" translate="yes" xml:space="preserve">
          <source>IterMut::max_by_key</source>
          <target state="translated">IterMut::max_by_key</target>
        </trans-unit>
        <trans-unit id="ae960d89241a17cf377151468fe032b6642a741c" translate="yes" xml:space="preserve">
          <source>IterMut::min</source>
          <target state="translated">IterMut::min</target>
        </trans-unit>
        <trans-unit id="6afc2639b644683e7d150f8f0a89926a274e7f5d" translate="yes" xml:space="preserve">
          <source>IterMut::min_by</source>
          <target state="translated">IterMut::min_by</target>
        </trans-unit>
        <trans-unit id="ba1f0877c3ded4eb9fc2eca35f95a34f57a1aa87" translate="yes" xml:space="preserve">
          <source>IterMut::min_by_key</source>
          <target state="translated">IterMut::min_by_key</target>
        </trans-unit>
        <trans-unit id="5c517328108a7b9b0752cdfee41b31e1a02675ed" translate="yes" xml:space="preserve">
          <source>IterMut::ne</source>
          <target state="translated">IterMut::ne</target>
        </trans-unit>
        <trans-unit id="4a2e580d79a7438865d40d31a56726e9127888c8" translate="yes" xml:space="preserve">
          <source>IterMut::next</source>
          <target state="translated">IterMut::next</target>
        </trans-unit>
        <trans-unit id="139a3236402870ecd266bb0a9bc31561280b31bb" translate="yes" xml:space="preserve">
          <source>IterMut::next_back</source>
          <target state="translated">IterMut::next_back</target>
        </trans-unit>
        <trans-unit id="7bbe293cbd53f286fef36815b6c7398d20db404f" translate="yes" xml:space="preserve">
          <source>IterMut::nth</source>
          <target state="translated">IterMut::nth</target>
        </trans-unit>
        <trans-unit id="5772506353380947ff699b52a37feaee46051df3" translate="yes" xml:space="preserve">
          <source>IterMut::nth_back</source>
          <target state="translated">IterMut::nth_back</target>
        </trans-unit>
        <trans-unit id="5668de5a92d85d1071ad1f82e9ef7513d2b7bc31" translate="yes" xml:space="preserve">
          <source>IterMut::partial_cmp</source>
          <target state="translated">IterMut::partial_cmp</target>
        </trans-unit>
        <trans-unit id="a3382b312019633bbea8d455e903695ff7a81f6d" translate="yes" xml:space="preserve">
          <source>IterMut::partition</source>
          <target state="translated">IterMut::partition</target>
        </trans-unit>
        <trans-unit id="def8ddaad6d23f184f1d8f90e47c52e6771c8726" translate="yes" xml:space="preserve">
          <source>IterMut::peekable</source>
          <target state="translated">IterMut::peekable</target>
        </trans-unit>
        <trans-unit id="e4e4bcd4ad39225fe6f1d31a86b7460e74649082" translate="yes" xml:space="preserve">
          <source>IterMut::position</source>
          <target state="translated">IterMut::position</target>
        </trans-unit>
        <trans-unit id="f8e28dca24a6d5cb911b812d63ca4210ad500397" translate="yes" xml:space="preserve">
          <source>IterMut::product</source>
          <target state="translated">IterMut::product</target>
        </trans-unit>
        <trans-unit id="e40a83a0559fe372b3fe052ff00a96a4950cded6" translate="yes" xml:space="preserve">
          <source>IterMut::rev</source>
          <target state="translated">IterMut::rev</target>
        </trans-unit>
        <trans-unit id="1e68d13e84703c21f465d900fde2ea2255c05c3d" translate="yes" xml:space="preserve">
          <source>IterMut::rfind</source>
          <target state="translated">IterMut::rfind</target>
        </trans-unit>
        <trans-unit id="1071e32d4bd9d85b7bb9988ca035b92c220cbc89" translate="yes" xml:space="preserve">
          <source>IterMut::rfold</source>
          <target state="translated">IterMut::rfold</target>
        </trans-unit>
        <trans-unit id="d9ad978343710ca3ac668584e5ec56ee87a41af1" translate="yes" xml:space="preserve">
          <source>IterMut::rposition</source>
          <target state="translated">IterMut::rposition</target>
        </trans-unit>
        <trans-unit id="3d57b99fe3a36a90ffb9f9e83e9da20276fd9a22" translate="yes" xml:space="preserve">
          <source>IterMut::scan</source>
          <target state="translated">IterMut::scan</target>
        </trans-unit>
        <trans-unit id="fae924a614763f37e082883ddaabc2b87b19bf2c" translate="yes" xml:space="preserve">
          <source>IterMut::size_hint</source>
          <target state="translated">IterMut::size_hint</target>
        </trans-unit>
        <trans-unit id="709c8510ff15526b1a9b732e5db04549151388c6" translate="yes" xml:space="preserve">
          <source>IterMut::skip</source>
          <target state="translated">IterMut::skip</target>
        </trans-unit>
        <trans-unit id="c54d538f96fcc47416c4e42ffc8829538ae491ab" translate="yes" xml:space="preserve">
          <source>IterMut::skip_while</source>
          <target state="translated">IterMut::skip_while</target>
        </trans-unit>
        <trans-unit id="38fb28ea29c6bc530e47f9dad6ca847a8308a455" translate="yes" xml:space="preserve">
          <source>IterMut::step_by</source>
          <target state="translated">IterMut::step_by</target>
        </trans-unit>
        <trans-unit id="07bbba43ad63c86d9539b561228e2c22eba74a81" translate="yes" xml:space="preserve">
          <source>IterMut::sum</source>
          <target state="translated">IterMut::sum</target>
        </trans-unit>
        <trans-unit id="e4e5a5c0090d5cac8762c3c6b597e5689d25a27c" translate="yes" xml:space="preserve">
          <source>IterMut::take</source>
          <target state="translated">IterMut::take</target>
        </trans-unit>
        <trans-unit id="33dd2e99d843e213c0ddd91584e7448ac2d4b106" translate="yes" xml:space="preserve">
          <source>IterMut::take_while</source>
          <target state="translated">IterMut::take_while</target>
        </trans-unit>
        <trans-unit id="89c3c4340f9719a145ec3899304b1842903b1e8e" translate="yes" xml:space="preserve">
          <source>IterMut::try_fold</source>
          <target state="translated">IterMut::try_fold</target>
        </trans-unit>
        <trans-unit id="3ecd354292c647432d92da5022d802acbefdaf09" translate="yes" xml:space="preserve">
          <source>IterMut::try_for_each</source>
          <target state="translated">IterMut::try_for_each</target>
        </trans-unit>
        <trans-unit id="07824f2f826e7e718e59741916504b108d880d62" translate="yes" xml:space="preserve">
          <source>IterMut::try_from</source>
          <target state="translated">IterMut::try_from</target>
        </trans-unit>
        <trans-unit id="9a96ea4150cfa217a4f1dd08ae093708354d29eb" translate="yes" xml:space="preserve">
          <source>IterMut::try_into</source>
          <target state="translated">IterMut::try_into</target>
        </trans-unit>
        <trans-unit id="29aff2c0b7bfd47c5d4837ac67638482b835e70d" translate="yes" xml:space="preserve">
          <source>IterMut::try_rfold</source>
          <target state="translated">IterMut::try_rfold</target>
        </trans-unit>
        <trans-unit id="bf0e0921f0da7331cb27e7d17d9e221b70171a7a" translate="yes" xml:space="preserve">
          <source>IterMut::type_id</source>
          <target state="translated">IterMut::type_id</target>
        </trans-unit>
        <trans-unit id="7f6f9babd020f3f6641909fd4a54810ef8d5c98a" translate="yes" xml:space="preserve">
          <source>IterMut::unzip</source>
          <target state="translated">IterMut::unzip</target>
        </trans-unit>
        <trans-unit id="bbedf0cc88bd2517be640465c65b23b15a5a71ba" translate="yes" xml:space="preserve">
          <source>IterMut::zip</source>
          <target state="translated">IterMut::zip</target>
        </trans-unit>
        <trans-unit id="5de97051f4a5bf9656a21f5c9446ab6c961f1d50" translate="yes" xml:space="preserve">
          <source>Iterate over a series of values with &lt;a href=&quot;keyword.for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;keyword.for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; 로 일련의 값을 반복 합니다 .</target>
        </trans-unit>
        <trans-unit id="2499260c1be5541b8c3abea5b95c5cff7ca9f173" translate="yes" xml:space="preserve">
          <source>Iterate through each line of the contents.</source>
          <target state="translated">내용의 각 줄을 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="ddc1d37b3a6ff7065f6616ad5090d037179310e5" translate="yes" xml:space="preserve">
          <source>Iterates over the entire iterator, multiplying all the elements</source>
          <target state="translated">전체 반복자를 반복하여 모든 요소를 ​​곱합니다.</target>
        </trans-unit>
        <trans-unit id="12f90576d62ee51bcd72346f4eea97d035ff3fbf" translate="yes" xml:space="preserve">
          <source>Iterates over the entire iterator, multiplying all the elements &lt;a href=&quot;../../../iter/trait.iterator#method.product&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">모든 요소를 곱하여 전체 반복자로 반복은 &lt;a href=&quot;../../../iter/trait.iterator#method.product&quot;&gt;더 읽기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e32fff0b6901e0665a7a8c46f77166fe30575d0c" translate="yes" xml:space="preserve">
          <source>Iterates over the entire iterator, multiplying all the elements &lt;a href=&quot;../../iter/trait.iterator#method.product&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">모든 요소를 곱하여 전체 반복자로 반복은 &lt;a href=&quot;../../iter/trait.iterator#method.product&quot;&gt;더 읽기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ba661f58c25c048da380a890db7f86c82d555ed" translate="yes" xml:space="preserve">
          <source>Iterates over the entire iterator, multiplying all the elements &lt;a href=&quot;../iter/trait.iterator#method.product&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">모든 요소를 곱하여 전체 반복자로 반복은 &lt;a href=&quot;../iter/trait.iterator#method.product&quot;&gt;더 읽기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e40697331454225ecb2ac731fb00044a53174cc1" translate="yes" xml:space="preserve">
          <source>Iterates over the entire iterator, multiplying all the elements &lt;a href=&quot;iter/trait.iterator#method.product&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">모든 요소를 곱하여 전체 반복자로 반복은 &lt;a href=&quot;iter/trait.iterator#method.product&quot;&gt;더 읽기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba2858c97778cf6ff78dc3d4e578f6ce94c7f587" translate="yes" xml:space="preserve">
          <source>Iterates over the entire iterator, multiplying all the elements &lt;a href=&quot;trait.iterator#method.product&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">모든 요소를 곱하여 전체 반복자로 반복은 &lt;a href=&quot;trait.iterator#method.product&quot;&gt;더 읽기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0dff502cf70a8cb10dd882dfdf098dc4aa48cf1e" translate="yes" xml:space="preserve">
          <source>Iterates over the slice &lt;code&gt;other&lt;/code&gt;, clones each element, and then appends it to this &lt;code&gt;Vec&lt;/code&gt;. The &lt;code&gt;other&lt;/code&gt; vector is traversed in-order.</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; 슬라이스를 반복하고 각 요소를 복제 한 다음이 &lt;code&gt;Vec&lt;/code&gt; 에 추가합니다 . &lt;code&gt;other&lt;/code&gt; 벡터에 주문 이송됩니다.</target>
        </trans-unit>
        <trans-unit id="5d265d453acaa19c0ae15ceee2e6a72145e4e232" translate="yes" xml:space="preserve">
          <source>Iterating Through Lines with the &lt;code id=&quot;iterating-through-lines-with-the-lines-method&quot;&gt;lines&lt;/code&gt; Method</source>
          <target state="translated">&lt;code id=&quot;iterating-through-lines-with-the-lines-method&quot;&gt;lines&lt;/code&gt; 방법으로 라인 반복</target>
        </trans-unit>
        <trans-unit id="9232973e4659ad95034977407f818f02bad0423b" translate="yes" xml:space="preserve">
          <source>Iterating over the Values in a Vector</source>
          <target state="translated">벡터의 값을 반복</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="4bbe26c7d68240e48a823975e3e785a737635548" translate="yes" xml:space="preserve">
          <source>Iteration with &lt;a href=&quot;keyword.in&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt;, trait implementation with &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../reference/trait-bounds#higher-ranked-trait-bounds&quot;&gt;higher-ranked trait bounds&lt;/a&gt; (&lt;code&gt;for&amp;lt;'a&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;keyword.in&quot;&gt; &lt;code&gt;in&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; 을&lt;/a&gt; 사용한 특성 구현 또는 &lt;a href=&quot;../reference/trait-bounds#higher-ranked-trait-bounds&quot;&gt;상위 특성 범위를&lt;/a&gt; 사용한 반복 ( &lt;code&gt;for&amp;lt;'a&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bae8809b2429231a50c28ba87cecc038aac88855" translate="yes" xml:space="preserve">
          <source>Iterator</source>
          <target state="translated">Iterator</target>
        </trans-unit>
        <trans-unit id="9423090682be31506d3158301d684f4abe89d00e" translate="yes" xml:space="preserve">
          <source>Iterator behavior</source>
          <target state="translated">반복자 동작</target>
        </trans-unit>
        <trans-unit id="bb7528b69192612888be1c4ce8f89b0e0e581862" translate="yes" xml:space="preserve">
          <source>Iterator loops</source>
          <target state="translated">반복자 루프</target>
        </trans-unit>
        <trans-unit id="d19530e5d03b36f27c9d84864c3b65bb57584a79" translate="yes" xml:space="preserve">
          <source>Iterator over the entries in a directory.</source>
          <target state="translated">디렉토리의 항목을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="ba33042f2a1b69e3f8c089958f5c5514f1643aee" translate="yes" xml:space="preserve">
          <source>Iterator types</source>
          <target state="translated">반복자 유형</target>
        </trans-unit>
        <trans-unit id="4273ec271075233286703458c7e9ebc00e2e82df" translate="yes" xml:space="preserve">
          <source>Iterator::all</source>
          <target state="translated">Iterator::all</target>
        </trans-unit>
        <trans-unit id="f86c54ca12225c13236cdc3a624968944761ea05" translate="yes" xml:space="preserve">
          <source>Iterator::any</source>
          <target state="translated">Iterator::any</target>
        </trans-unit>
        <trans-unit id="d57ec500fe9ec2bba36378c03fe82c9f66576f38" translate="yes" xml:space="preserve">
          <source>Iterator::by_ref</source>
          <target state="translated">Iterator::by_ref</target>
        </trans-unit>
        <trans-unit id="eee7519010a092f18111fa15dd804b221949785a" translate="yes" xml:space="preserve">
          <source>Iterator::chain</source>
          <target state="translated">Iterator::chain</target>
        </trans-unit>
        <trans-unit id="2737cab8dbd36c284c2d2a04345b6f802d76520e" translate="yes" xml:space="preserve">
          <source>Iterator::cloned</source>
          <target state="translated">Iterator::cloned</target>
        </trans-unit>
        <trans-unit id="4d53642d0597c543ebd99c70d62ee5234be120ee" translate="yes" xml:space="preserve">
          <source>Iterator::cmp</source>
          <target state="translated">Iterator::cmp</target>
        </trans-unit>
        <trans-unit id="6840be4400b24989a5f3ee01f218588655855ede" translate="yes" xml:space="preserve">
          <source>Iterator::collect</source>
          <target state="translated">Iterator::collect</target>
        </trans-unit>
        <trans-unit id="afd3fcee84d868df85114f2c2de87906ba8b73fd" translate="yes" xml:space="preserve">
          <source>Iterator::copied</source>
          <target state="translated">Iterator::copied</target>
        </trans-unit>
        <trans-unit id="65c267a3908408f21f20c7542c580b394c3ac479" translate="yes" xml:space="preserve">
          <source>Iterator::count</source>
          <target state="translated">Iterator::count</target>
        </trans-unit>
        <trans-unit id="a62029a441e5502574f74110e73622b6c124b195" translate="yes" xml:space="preserve">
          <source>Iterator::cycle</source>
          <target state="translated">Iterator::cycle</target>
        </trans-unit>
        <trans-unit id="4cf31dbb9795763807136c75aa5ab726e70ab4da" translate="yes" xml:space="preserve">
          <source>Iterator::enumerate</source>
          <target state="translated">Iterator::enumerate</target>
        </trans-unit>
        <trans-unit id="e54da00842cf3d69c5bb79f7e6ff037be7b7d1eb" translate="yes" xml:space="preserve">
          <source>Iterator::eq</source>
          <target state="translated">Iterator::eq</target>
        </trans-unit>
        <trans-unit id="7cf8c3afdf60282496111d5e9294d886ba58ff32" translate="yes" xml:space="preserve">
          <source>Iterator::filter</source>
          <target state="translated">Iterator::filter</target>
        </trans-unit>
        <trans-unit id="d6f882e7564be02de62cc36c2cb255e404103b69" translate="yes" xml:space="preserve">
          <source>Iterator::filter_map</source>
          <target state="translated">Iterator::filter_map</target>
        </trans-unit>
        <trans-unit id="8bad19b292d0ba35dd2b96e68725fc1ecca7ab20" translate="yes" xml:space="preserve">
          <source>Iterator::find</source>
          <target state="translated">Iterator::find</target>
        </trans-unit>
        <trans-unit id="3ea058ee3e827f8722e557a5ed69196b9d69ffef" translate="yes" xml:space="preserve">
          <source>Iterator::find_map</source>
          <target state="translated">Iterator::find_map</target>
        </trans-unit>
        <trans-unit id="fb5d2f94b065377a6651ac4b6316f941b8a73d83" translate="yes" xml:space="preserve">
          <source>Iterator::flat_map</source>
          <target state="translated">Iterator::flat_map</target>
        </trans-unit>
        <trans-unit id="111068d32ae21f272191794cb73558e1cac98f8c" translate="yes" xml:space="preserve">
          <source>Iterator::flatten</source>
          <target state="translated">Iterator::flatten</target>
        </trans-unit>
        <trans-unit id="43a4b81bd3319dd7c1f643ea1239981100f2bfe0" translate="yes" xml:space="preserve">
          <source>Iterator::fold</source>
          <target state="translated">Iterator::fold</target>
        </trans-unit>
        <trans-unit id="4b6d8e0bb7e0875f730af26e464f2d7f56787c00" translate="yes" xml:space="preserve">
          <source>Iterator::for_each</source>
          <target state="translated">Iterator::for_each</target>
        </trans-unit>
        <trans-unit id="d331641f18373a947667fdd994090cbdbe5e56e3" translate="yes" xml:space="preserve">
          <source>Iterator::fuse</source>
          <target state="translated">Iterator::fuse</target>
        </trans-unit>
        <trans-unit id="a1d0aae8a33bedb12212f917dec98beb3c31719d" translate="yes" xml:space="preserve">
          <source>Iterator::ge</source>
          <target state="translated">Iterator::ge</target>
        </trans-unit>
        <trans-unit id="d02804beda6f63be283b340587c424846986c214" translate="yes" xml:space="preserve">
          <source>Iterator::gt</source>
          <target state="translated">Iterator::gt</target>
        </trans-unit>
        <trans-unit id="f6f98700823020b1af15767f0fd9cf51cc5b3580" translate="yes" xml:space="preserve">
          <source>Iterator::inspect</source>
          <target state="translated">Iterator::inspect</target>
        </trans-unit>
        <trans-unit id="2b970d2781d8419238596de0ecda94a2ec01de0f" translate="yes" xml:space="preserve">
          <source>Iterator::is_sorted</source>
          <target state="translated">Iterator::is_sorted</target>
        </trans-unit>
        <trans-unit id="856d4b939b6e2b1172c61d2fab65a6f2f22d06a3" translate="yes" xml:space="preserve">
          <source>Iterator::is_sorted_by</source>
          <target state="translated">Iterator::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="8d2695a4fa6c8f77acecd3c782968648c5c7e47f" translate="yes" xml:space="preserve">
          <source>Iterator::is_sorted_by_key</source>
          <target state="translated">Iterator::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="fc7204aa1fca5db78599c8ff71f528a152d2799f" translate="yes" xml:space="preserve">
          <source>Iterator::last</source>
          <target state="translated">Iterator::last</target>
        </trans-unit>
        <trans-unit id="89a83249a4c0370a4e7fe4b445980fe3d4bdb85b" translate="yes" xml:space="preserve">
          <source>Iterator::le</source>
          <target state="translated">Iterator::le</target>
        </trans-unit>
        <trans-unit id="3de38ebedca0b7133046aaeeabbf64a22e912ef4" translate="yes" xml:space="preserve">
          <source>Iterator::lt</source>
          <target state="translated">Iterator::lt</target>
        </trans-unit>
        <trans-unit id="791a1e23f54e2b3d01c25daf21bceda253396401" translate="yes" xml:space="preserve">
          <source>Iterator::map</source>
          <target state="translated">Iterator::map</target>
        </trans-unit>
        <trans-unit id="14ca2127fd3ab1a13326b57f93a743807d4a385a" translate="yes" xml:space="preserve">
          <source>Iterator::max</source>
          <target state="translated">Iterator::max</target>
        </trans-unit>
        <trans-unit id="73c5938125fe2dda5817351036d306957ab62fdf" translate="yes" xml:space="preserve">
          <source>Iterator::max_by</source>
          <target state="translated">Iterator::max_by</target>
        </trans-unit>
        <trans-unit id="0d48dc0112caa2401ba3e6305374cbe9d9f62de6" translate="yes" xml:space="preserve">
          <source>Iterator::max_by_key</source>
          <target state="translated">Iterator::max_by_key</target>
        </trans-unit>
        <trans-unit id="1e915bf62293697842ab0cc1c78d7c4d9247f8a2" translate="yes" xml:space="preserve">
          <source>Iterator::min</source>
          <target state="translated">Iterator::min</target>
        </trans-unit>
        <trans-unit id="350a01c462ad653692ad3d7c81cc7f998b33cc7a" translate="yes" xml:space="preserve">
          <source>Iterator::min_by</source>
          <target state="translated">Iterator::min_by</target>
        </trans-unit>
        <trans-unit id="3fa40a72cbf669f1ff2dd6db52b49bf6e29072d6" translate="yes" xml:space="preserve">
          <source>Iterator::min_by_key</source>
          <target state="translated">Iterator::min_by_key</target>
        </trans-unit>
        <trans-unit id="898579db7c8bd3e1760f9dc45aebef8f31d79de6" translate="yes" xml:space="preserve">
          <source>Iterator::ne</source>
          <target state="translated">Iterator::ne</target>
        </trans-unit>
        <trans-unit id="2d360ad0443fc86aaf713ff8a07e3d0e24910e14" translate="yes" xml:space="preserve">
          <source>Iterator::next</source>
          <target state="translated">Iterator::next</target>
        </trans-unit>
        <trans-unit id="4ef73a468549da918e9ddd255430293b4d475cf4" translate="yes" xml:space="preserve">
          <source>Iterator::nth</source>
          <target state="translated">Iterator::nth</target>
        </trans-unit>
        <trans-unit id="6430563009c292bd461b9dbdbc8efbc87ed667e5" translate="yes" xml:space="preserve">
          <source>Iterator::partial_cmp</source>
          <target state="translated">Iterator::partial_cmp</target>
        </trans-unit>
        <trans-unit id="38feb7e4eded7516cbc44a5b7ae390dbea8a1c5f" translate="yes" xml:space="preserve">
          <source>Iterator::partition</source>
          <target state="translated">Iterator::partition</target>
        </trans-unit>
        <trans-unit id="b1d4b5a349a9bfe583ffe37ec59e50ccad659479" translate="yes" xml:space="preserve">
          <source>Iterator::peekable</source>
          <target state="translated">Iterator::peekable</target>
        </trans-unit>
        <trans-unit id="6ffb8dda5bc3637bf0fea7d50ee2879f36477dbd" translate="yes" xml:space="preserve">
          <source>Iterator::position</source>
          <target state="translated">Iterator::position</target>
        </trans-unit>
        <trans-unit id="ec1b6d5e61cc3a26f25348b0a2e1ad79bbac1c52" translate="yes" xml:space="preserve">
          <source>Iterator::product</source>
          <target state="translated">Iterator::product</target>
        </trans-unit>
        <trans-unit id="48046e9ab82515a6dd4fd7b646f1ce53e8faac3b" translate="yes" xml:space="preserve">
          <source>Iterator::rev</source>
          <target state="translated">Iterator::rev</target>
        </trans-unit>
        <trans-unit id="67f9a990bd064873346b5c9e2d17fe35c839d67c" translate="yes" xml:space="preserve">
          <source>Iterator::rposition</source>
          <target state="translated">Iterator::rposition</target>
        </trans-unit>
        <trans-unit id="ff5bd4337968d7f15fa02188bc9ec8899d066887" translate="yes" xml:space="preserve">
          <source>Iterator::scan</source>
          <target state="translated">Iterator::scan</target>
        </trans-unit>
        <trans-unit id="ecc32183d685c53eedf20225f612a8f2cd0d1e50" translate="yes" xml:space="preserve">
          <source>Iterator::size_hint</source>
          <target state="translated">Iterator::size_hint</target>
        </trans-unit>
        <trans-unit id="5407d981fcc2957741d940d765b5c8aeeb89a7d3" translate="yes" xml:space="preserve">
          <source>Iterator::skip</source>
          <target state="translated">Iterator::skip</target>
        </trans-unit>
        <trans-unit id="b37ac34fd4f971b4431eb07cfed110e756486a69" translate="yes" xml:space="preserve">
          <source>Iterator::skip_while</source>
          <target state="translated">Iterator::skip_while</target>
        </trans-unit>
        <trans-unit id="18e1ae8414f33fb71bfb82df82aa89205f40cf2a" translate="yes" xml:space="preserve">
          <source>Iterator::step_by</source>
          <target state="translated">Iterator::step_by</target>
        </trans-unit>
        <trans-unit id="17eae761d55f0527972d28d8efb13700ff9cd9a8" translate="yes" xml:space="preserve">
          <source>Iterator::sum</source>
          <target state="translated">Iterator::sum</target>
        </trans-unit>
        <trans-unit id="7818fb82bcb2e27b1eaf83bc4a006e1deaa87c61" translate="yes" xml:space="preserve">
          <source>Iterator::take</source>
          <target state="translated">Iterator::take</target>
        </trans-unit>
        <trans-unit id="8585d3ded5bed1eba060e171ff1f8d071aa3c3c0" translate="yes" xml:space="preserve">
          <source>Iterator::take_while</source>
          <target state="translated">Iterator::take_while</target>
        </trans-unit>
        <trans-unit id="f3a0250ddc27ec143683c1a6492e90be2e63cdfb" translate="yes" xml:space="preserve">
          <source>Iterator::try_fold</source>
          <target state="translated">Iterator::try_fold</target>
        </trans-unit>
        <trans-unit id="97ee2ddc3ae8f6722d8aa8a8f03acf882d6fb21c" translate="yes" xml:space="preserve">
          <source>Iterator::try_for_each</source>
          <target state="translated">Iterator::try_for_each</target>
        </trans-unit>
        <trans-unit id="d42112e418ab0fd56186356df14c7791d504e7e2" translate="yes" xml:space="preserve">
          <source>Iterator::unzip</source>
          <target state="translated">Iterator::unzip</target>
        </trans-unit>
        <trans-unit id="2191de9c88e99f9f5438674c00e37989322ce302" translate="yes" xml:space="preserve">
          <source>Iterator::zip</source>
          <target state="translated">Iterator::zip</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="2f934a245522e136eca293cd75a09317df2f2cd7" translate="yes" xml:space="preserve">
          <source>Iterators (and iterator &lt;a href=&quot;#adapters&quot;&gt;adapters&lt;/a&gt;) are &lt;em&gt;lazy&lt;/em&gt;. This means that just creating an iterator doesn't &lt;em&gt;do&lt;/em&gt; a whole lot. Nothing really happens until you call &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;. This is sometimes a source of confusion when creating an iterator solely for its side effects. For example, the &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; method calls a closure on each element it iterates over:</source>
          <target state="translated">반복자 (및 반복자 &lt;a href=&quot;#adapters&quot;&gt;어댑터&lt;/a&gt; )가 &lt;em&gt;느&lt;/em&gt; 립니다. 즉, 반복자를 만드는 것만으로는 많은 &lt;em&gt;일을&lt;/em&gt; 하지 않습니다 . &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 전화 할 때까지는 아무 일도 일어나지 않습니다 . 부작용에 대해서만 반복자를 만들 때 때때로 혼란의 원인이됩니다. 예를 들어 &lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 메소드는 반복되는 각 요소에서 클로저를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="bc571c24ac50d6cee6e1818f6a078d2a419abc9e" translate="yes" xml:space="preserve">
          <source>Iterators also provide a series of &lt;em&gt;adapter&lt;/em&gt; methods for performing common threads to sequences. Among the adapters are functional favorites like &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;fold&lt;/code&gt;, &lt;code&gt;skip&lt;/code&gt; and &lt;code&gt;take&lt;/code&gt;. Of particular interest to collections is the &lt;code&gt;rev&lt;/code&gt; adapter, that reverses any iterator that supports this operation. Most collections provide reversible iterators as the way to iterate over them in reverse order.</source>
          <target state="translated">반복자는 시퀀스에 공통 스레드를 수행하기위한 일련의 &lt;em&gt;어댑터&lt;/em&gt; 메소드 도 제공합니다 . 어댑터 중에는 &lt;code&gt;map&lt;/code&gt; , &lt;code&gt;fold&lt;/code&gt; , &lt;code&gt;skip&lt;/code&gt; 및 &lt;code&gt;take&lt;/code&gt; 와 같은 기능 즐겨 찾기가 있습니다 . 콜렉션에 특히 관심이있는 것은이 조작을 지원하는 모든 반복자를 뒤집는 &lt;code&gt;rev&lt;/code&gt; 어댑터입니다. 대부분의 컬렉션은 가역적 인 반복자를 역순으로 반복하는 방법으로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1604a556288e09f94874ae1b1e2b1eb8eabf0eb7" translate="yes" xml:space="preserve">
          <source>Iterators are a powerful and robust mechanism used throughout Rust's standard libraries. Iterators provide a sequence of values in a generic, safe, efficient and convenient way. The contents of an iterator are usually &lt;em&gt;lazily&lt;/em&gt; evaluated, so that only the values that are actually needed are ever actually produced, and no allocation need be done to temporarily store them. Iterators are primarily consumed using a &lt;code&gt;for&lt;/code&gt; loop, although many functions also take iterators where a collection or sequence of values is desired.</source>
          <target state="translated">반복자는 Rust의 표준 라이브러리에서 사용되는 강력하고 강력한 메커니즘입니다. 반복자는 일반적이고 안전하며 효율적이며 편리한 방식으로 일련의 값을 제공합니다. 반복자의 내용은 일반적으로 &lt;em&gt;지연&lt;/em&gt; 평가되므로 실제로 필요한 값만 실제로 생성되므로 임시로 저장하기 위해 할당을 수행 할 필요가 없습니다. 반복자는 주로 &lt;code&gt;for&lt;/code&gt; 루프를 사용하여 소비 되지만 많은 함수가 값의 수집 또는 일련의 값이 필요한 반복자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="578d7fdeb01ae2ce26df2699ac5468054a311e64" translate="yes" xml:space="preserve">
          <source>Iterators are also composable, and it's common to chain them together to do more complex forms of processing. See the &lt;a href=&quot;#adapters&quot;&gt;Adapters&lt;/a&gt; section below for more details.</source>
          <target state="translated">반복자는 구성 할 수 있으며 더 복잡한 형태의 처리를 수행하기 위해 함께 연결하는 것이 일반적입니다. 자세한 내용은 아래 &lt;a href=&quot;#adapters&quot;&gt;어댑터&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="73a40f4f406e6b8d805bf4ec3dd55761493e5309" translate="yes" xml:space="preserve">
          <source>Iterators do not have to be finite. As an example, an open-ended range is an infinite iterator:</source>
          <target state="translated">반복자는 유한 할 필요가 없습니다. 예를 들어, 개방형 범위는 무한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="cd7908f9004d53eb6241ef825d90a63188a57756" translate="yes" xml:space="preserve">
          <source>Iterators handle all that logic for you, cutting down on repetitive code you could potentially mess up. Iterators give you more flexibility to use the same logic with many different kinds of sequences, not just data structures you can index into, like vectors. Let&amp;rsquo;s examine how iterators do that.</source>
          <target state="translated">반복자는 잠재적으로 엉망이 될 수있는 반복적 인 코드를 줄여 모든 논리를 처리합니다. 반복자는 벡터와 같이 인덱싱 할 수있는 데이터 구조뿐만 아니라 다양한 종류의 시퀀스에서 동일한 논리를 사용할 수있는 유연성을 제공합니다. 반복자가 어떻게 하는지를 살펴 보자.</target>
        </trans-unit>
        <trans-unit id="ef660a43407868b9cb1e9e11d499fe58b2a67f0d" translate="yes" xml:space="preserve">
          <source>Iterators of known length</source>
          <target state="translated">알려진 길이의 반복자</target>
        </trans-unit>
        <trans-unit id="e2c70e7513b6f7cfa60a8740edd8f829825ff6ce" translate="yes" xml:space="preserve">
          <source>Iterators produce a series of values, and collections can also be thought of as a series of values. The &lt;code&gt;Extend&lt;/code&gt; trait bridges this gap, allowing you to extend a collection by including the contents of that iterator. When extending a collection with an already existing key, that entry is updated or, in the case of collections that permit multiple entries with equal keys, that entry is inserted.</source>
          <target state="translated">반복자는 일련의 값을 생성하며 컬렉션은 일련의 값으로 생각할 수도 있습니다. 는 &lt;code&gt;Extend&lt;/code&gt; 특성 당신이 반복자 그 내용을 포함하여 컬렉션을 확장 할 수 있도록,이 격차를 다리. 기존 키가있는 컬렉션을 확장하면 해당 항목이 업데이트되거나 동일한 키가있는 여러 항목을 허용하는 컬렉션의 경우 해당 항목이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="36fe73edebcef37071d90c761137d6e576a12835" translate="yes" xml:space="preserve">
          <source>Iterators that dynamically terminate.</source>
          <target state="translated">동적으로 종료되는 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="c4a0156a59a95761c105c3a3e41e56a330667ccb" translate="yes" xml:space="preserve">
          <source>Iterators:</source>
          <target state="translated">Iterators:</target>
        </trans-unit>
        <trans-unit id="f0236db9f43733339562b17d0dc2c960dc9c9a8f" translate="yes" xml:space="preserve">
          <source>Its type is &lt;code&gt;'static&lt;/code&gt; duration borrowed string slice, &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;code&gt;'static&lt;/code&gt; 지속 기간 빌린 문자열 슬라이스, &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="9c46090b4698309dc6d00e2e6c188ead587a40e9" translate="yes" xml:space="preserve">
          <source>JoinHandle</source>
          <target state="translated">JoinHandle</target>
        </trans-unit>
        <trans-unit id="dbe795c59f1c72343d5a4f517f9ad3b4275e45c2" translate="yes" xml:space="preserve">
          <source>JoinHandle::as_pthread_t</source>
          <target state="translated">JoinHandle::as_pthread_t</target>
        </trans-unit>
        <trans-unit id="412c59894065992ad9701ec7e4a5555a722a3202" translate="yes" xml:space="preserve">
          <source>JoinHandle::as_raw_handle</source>
          <target state="translated">JoinHandle::as_raw_handle</target>
        </trans-unit>
        <trans-unit id="3cec4888e9d7b5ae79106f6aa6dc453c6917c4e8" translate="yes" xml:space="preserve">
          <source>JoinHandle::borrow</source>
          <target state="translated">JoinHandle::borrow</target>
        </trans-unit>
        <trans-unit id="fd2845c5bf15e89eb7f9f69c8adaebecb219c672" translate="yes" xml:space="preserve">
          <source>JoinHandle::borrow_mut</source>
          <target state="translated">JoinHandle::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4c3ce23926add99bcb7d4f4c43a106d00bccac89" translate="yes" xml:space="preserve">
          <source>JoinHandle::fmt</source>
          <target state="translated">JoinHandle::fmt</target>
        </trans-unit>
        <trans-unit id="f7242c7bfb17274370663c2f02ebe9f7d7c96f0f" translate="yes" xml:space="preserve">
          <source>JoinHandle::from</source>
          <target state="translated">JoinHandle::from</target>
        </trans-unit>
        <trans-unit id="d5627903ac6c6fca86247def251096015fffbc5a" translate="yes" xml:space="preserve">
          <source>JoinHandle::into</source>
          <target state="translated">JoinHandle::into</target>
        </trans-unit>
        <trans-unit id="7e1eec403cc018629f136e34f3666787322dd901" translate="yes" xml:space="preserve">
          <source>JoinHandle::into_pthread_t</source>
          <target state="translated">JoinHandle::into_pthread_t</target>
        </trans-unit>
        <trans-unit id="c6314894dabf847146013c8140ba901c5f3fc886" translate="yes" xml:space="preserve">
          <source>JoinHandle::into_raw_handle</source>
          <target state="translated">JoinHandle::into_raw_handle</target>
        </trans-unit>
        <trans-unit id="45b01c0739817e609f8d08e9f75c05ce81644422" translate="yes" xml:space="preserve">
          <source>JoinHandle::join</source>
          <target state="translated">JoinHandle::join</target>
        </trans-unit>
        <trans-unit id="c16676e74c56443eeda553ebfbb33efee8fee2c2" translate="yes" xml:space="preserve">
          <source>JoinHandle::thread</source>
          <target state="translated">JoinHandle::thread</target>
        </trans-unit>
        <trans-unit id="8607545c9c64edf874a5905869af45ed541936fc" translate="yes" xml:space="preserve">
          <source>JoinHandle::try_from</source>
          <target state="translated">JoinHandle::try_from</target>
        </trans-unit>
        <trans-unit id="5b4f897ba8176b628f13a3930ac9376591daff65" translate="yes" xml:space="preserve">
          <source>JoinHandle::try_into</source>
          <target state="translated">JoinHandle::try_into</target>
        </trans-unit>
        <trans-unit id="81095dc64ba5b13ce027669fbb3134aaf6614b5d" translate="yes" xml:space="preserve">
          <source>JoinHandle::type_id</source>
          <target state="translated">JoinHandle::type_id</target>
        </trans-unit>
        <trans-unit id="abb0b2d530b1bed37c520e95e0964bc4442ee134" translate="yes" xml:space="preserve">
          <source>JoinHandleExt</source>
          <target state="translated">JoinHandleExt</target>
        </trans-unit>
        <trans-unit id="c5dafe3d3c39e51618733fd88e0def9741b4e835" translate="yes" xml:space="preserve">
          <source>JoinPathsError</source>
          <target state="translated">JoinPathsError</target>
        </trans-unit>
        <trans-unit id="dec0bd024ba9e43e73fa5ecd613a46a6513fd917" translate="yes" xml:space="preserve">
          <source>JoinPathsError::borrow</source>
          <target state="translated">JoinPathsError::borrow</target>
        </trans-unit>
        <trans-unit id="1f287d847c80825aeaa42f5ff5c4d17823d49d12" translate="yes" xml:space="preserve">
          <source>JoinPathsError::borrow_mut</source>
          <target state="translated">JoinPathsError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="823a4e0b65b65d02ed9c70bea6734955e28b7a64" translate="yes" xml:space="preserve">
          <source>JoinPathsError::cause</source>
          <target state="translated">JoinPathsError::cause</target>
        </trans-unit>
        <trans-unit id="edc1e4fdc91ad7cadf96a809927c8b059c8a1cbe" translate="yes" xml:space="preserve">
          <source>JoinPathsError::description</source>
          <target state="translated">JoinPathsError::description</target>
        </trans-unit>
        <trans-unit id="c6c91db5b7bc4a5beebd630f559897ab6b3cea42" translate="yes" xml:space="preserve">
          <source>JoinPathsError::fmt</source>
          <target state="translated">JoinPathsError::fmt</target>
        </trans-unit>
        <trans-unit id="127ef4e1b3f565f1a2bca65f9de0550244e7bc38" translate="yes" xml:space="preserve">
          <source>JoinPathsError::from</source>
          <target state="translated">JoinPathsError::from</target>
        </trans-unit>
        <trans-unit id="8a0a4301d2f110a8e8ef605ea4bf646ad3a9581c" translate="yes" xml:space="preserve">
          <source>JoinPathsError::into</source>
          <target state="translated">JoinPathsError::into</target>
        </trans-unit>
        <trans-unit id="0693ee59f808878ad8873da2ff694215418c0ee4" translate="yes" xml:space="preserve">
          <source>JoinPathsError::source</source>
          <target state="translated">JoinPathsError::source</target>
        </trans-unit>
        <trans-unit id="b148a85037443dfc7b589e93179ee679cee0e0a2" translate="yes" xml:space="preserve">
          <source>JoinPathsError::to_string</source>
          <target state="translated">JoinPathsError::to_string</target>
        </trans-unit>
        <trans-unit id="e3d928e5001d65eef527b0e798f2ed958d4242d9" translate="yes" xml:space="preserve">
          <source>JoinPathsError::try_from</source>
          <target state="translated">JoinPathsError::try_from</target>
        </trans-unit>
        <trans-unit id="e96758935a84b6c6b7f43135aee06bfbdb4c12b7" translate="yes" xml:space="preserve">
          <source>JoinPathsError::try_into</source>
          <target state="translated">JoinPathsError::try_into</target>
        </trans-unit>
        <trans-unit id="b4849b93731305d8c42c5c2a1a4688106ef4de73" translate="yes" xml:space="preserve">
          <source>JoinPathsError::type_id</source>
          <target state="translated">JoinPathsError::type_id</target>
        </trans-unit>
        <trans-unit id="97c4f7769f9c5e2f4f5b9d5caac54744e0a9f90a" translate="yes" xml:space="preserve">
          <source>Joining a path containing a colon on a Unix-like platform results in an error:</source>
          <target state="translated">유닉스 계열 플랫폼에서 콜론이 포함 된 경로를 결합하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b4466f438f59f9e3e6b0c11543857ad0cb8e936d" translate="yes" xml:space="preserve">
          <source>Joining paths on a Unix-like platform:</source>
          <target state="translated">유닉스 계열 플랫폼에서 경로 결합 :</target>
        </trans-unit>
        <trans-unit id="b3a56bf6b2881876f787cf53e3b3c50398570960" translate="yes" xml:space="preserve">
          <source>Joins a collection of &lt;a href=&quot;../path/struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;s appropriately for the &lt;code&gt;PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;PATH&lt;/code&gt; 환경 변수에 적절하게 &lt;a href=&quot;../path/struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 콜렉션을 결합 합니다.</target>
        </trans-unit>
        <trans-unit id="9058cfb3941c57451d031360b87440956e3d0576" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;cargo run&lt;/code&gt; compiles your code and then runs the resulting binary, &lt;code&gt;cargo test&lt;/code&gt; compiles your code in test mode and runs the resulting test binary. You can specify command line options to change the default behavior of &lt;code&gt;cargo test&lt;/code&gt;. For example, the default behavior of the binary produced by &lt;code&gt;cargo test&lt;/code&gt; is to run all the tests in parallel and capture output generated during test runs, preventing the output from being displayed and making it easier to read the output related to the test results.</source>
          <target state="translated">&lt;code&gt;cargo run&lt;/code&gt; 코드를 컴파일 한 다음 결과 바이너리를 실행하는 것처럼 &lt;code&gt;cargo test&lt;/code&gt; 는 코드를 테스트 모드로 컴파일하고 결과 테스트 바이너리를 실행합니다. &lt;code&gt;cargo test&lt;/code&gt; 의 기본 동작을 변경하기 위해 명령 행 옵션을 지정할 수 있습니다 . 예를 들어, &lt;code&gt;cargo test&lt;/code&gt; 의해 생성 된 이진의 기본 동작은 모든 테스트를 병렬로 실행하고 테스트 실행 중에 생성 된 출력을 캡처하여 출력이 표시되지 않고 테스트 결과와 관련된 출력을보다 쉽게 ​​읽을 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="001e99c6d562d4610082356bd914b66e7791c6d7" translate="yes" xml:space="preserve">
          <source>Just as variables are immutable by default, so are references. We&amp;rsquo;re not allowed to modify something we have a reference to.</source>
          <target state="translated">변수가 기본적으로 불변 인 것처럼 참조도 마찬가지입니다. 우리는 우리가 참조하는 것을 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d60a8e1c1966b92263798202c5f621ad3271182f" translate="yes" xml:space="preserve">
          <source>Just as we might want to refer to a part of a string, we might want to refer to part of an array. We&amp;rsquo;d do so like this:</source>
          <target state="translated">문자열의 일부를 참조하는 것처럼 배열의 일부를 참조 할 수 있습니다. 우리는 이렇게 할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="7ad9184de5a77f6309e9e7ededd89f40f9a37f5e" translate="yes" xml:space="preserve">
          <source>Just as with &lt;a href=&quot;external-blocks&quot;&gt;external block&lt;/a&gt;, when the &lt;code&gt;extern&lt;/code&gt; keyword is used and the &lt;code&gt;&quot;ABI&lt;/code&gt; is omitted, the ABI used defaults to &lt;code&gt;&quot;C&quot;&lt;/code&gt;. That is, this:</source>
          <target state="translated">단지와 같은 &lt;a href=&quot;external-blocks&quot;&gt;외부 블록&lt;/a&gt; 때, &lt;code&gt;extern&lt;/code&gt; 키워드가 사용되고, &lt;code&gt;&quot;ABI&lt;/code&gt; 가 생략되면, ABI는 디폴트 사용 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 즉,이된다. :</target>
        </trans-unit>
        <trans-unit id="d3cd0c38914e4f9de946957888fda12a2aef698c" translate="yes" xml:space="preserve">
          <source>Just because a function contains unsafe code doesn&amp;rsquo;t mean we need to mark the entire function as unsafe. In fact, wrapping unsafe code in a safe function is a common abstraction. As an example, let&amp;rsquo;s study a function from the standard library, &lt;code&gt;split_at_mut&lt;/code&gt;, that requires some unsafe code and explore how we might implement it. This safe method is defined on mutable slices: it takes one slice and makes it two by splitting the slice at the index given as an argument. Listing 19-4 shows how to use &lt;code&gt;split_at_mut&lt;/code&gt;.</source>
          <target state="translated">함수에 안전하지 않은 코드가 포함되어 있다고해서 전체 함수를 안전하지 않은 것으로 표시해야하는 것은 아닙니다. 실제로 안전하지 않은 코드를 안전한 기능으로 포장하는 것은 일반적인 추상화입니다. 예를 들어, 안전하지 않은 코드가 필요한 표준 라이브러리 &lt;code&gt;split_at_mut&lt;/code&gt; 의 함수를 연구하고 구현 방법을 살펴 보겠습니다. 이 안전한 방법은 가변 슬라이스에 정의되어 있습니다. 하나의 슬라이스를 취하고 인수로 제공된 인덱스에서 슬라이스를 분할하여 두 개의 슬라이스를 만듭니다. Listing 19-4는 &lt;code&gt;split_at_mut&lt;/code&gt; 사용 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="687163feff04cea4e68067b5a858f533ad06e05e" translate="yes" xml:space="preserve">
          <source>Just compiling with &lt;code&gt;rustc&lt;/code&gt; is fine for simple programs, but as your project grows, you&amp;rsquo;ll want to manage all the options and make it easy to share your code. Next, we&amp;rsquo;ll introduce you to the Cargo tool, which will help you write real-world Rust programs.</source>
          <target state="translated">&lt;code&gt;rustc&lt;/code&gt; 으로 컴파일하는 것은 간단한 프로그램에는 적합하지만 프로젝트가 성장함에 따라 모든 옵션을 관리하고 코드를 쉽게 공유 할 수 있습니다. 다음으로 실제 Rust 프로그램 작성에 도움이되는 Cargo 도구를 소개합니다.</target>
        </trans-unit>
        <trans-unit id="edf4d5cc727a6c57ca685432668f892eb6c7cbd1" translate="yes" xml:space="preserve">
          <source>Just like in C, whether an operation is volatile has no bearing whatsoever on questions involving concurrent access from multiple threads. Volatile accesses behave exactly like non-atomic accesses in that regard. In particular, a race between a &lt;code&gt;read_volatile&lt;/code&gt; and any write operation to the same location is undefined behavior.</source>
          <target state="translated">C에서와 마찬가지로 작업이 일시적인지 여부는 여러 스레드의 동시 액세스와 관련된 질문에 영향을 미치지 않습니다. 휘발성 액세스는 이와 관련하여 비 원자 액세스와 똑같이 동작합니다. 특히, &lt;code&gt;read_volatile&lt;/code&gt; 과 같은 위치에 대한 모든 쓰기 작업 간의 경쟁 은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="317bc7ae9f1ea2d73138794a7e1fffbd3badd2f1" translate="yes" xml:space="preserve">
          <source>Just like in C, whether an operation is volatile has no bearing whatsoever on questions involving concurrent access from multiple threads. Volatile accesses behave exactly like non-atomic accesses in that regard. In particular, a race between a &lt;code&gt;write_volatile&lt;/code&gt; and any other operation (reading or writing) on the same location is undefined behavior.</source>
          <target state="translated">C에서와 마찬가지로 작업이 일시적인지 여부는 여러 스레드의 동시 액세스와 관련된 질문에 영향을 미치지 않습니다. 휘발성 액세스는 이와 관련하여 비 원자 액세스와 똑같이 동작합니다. 특히, 동일한 위치 에서 &lt;code&gt;write_volatile&lt;/code&gt; 과 다른 작업 (읽기 또는 쓰기) 간의 경쟁 은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="4e495fa1d1e849a4610409f46ad4ee2226bcc303" translate="yes" xml:space="preserve">
          <source>Just like static functions, associated constants aren't stored on the method table. If the trait or any subtrait contain an associated constant, they cannot be made into an object.</source>
          <target state="translated">정적 함수와 마찬가지로 관련 상수는 메서드 테이블에 저장되지 않습니다. 특성 또는 하위 특성에 연관된 상수가 포함되어 있으면 오브젝트로 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f8bf7b98f101ed3ceab4b0a28bb6ad41d9542aea" translate="yes" xml:space="preserve">
          <source>Just like vectors, hash maps store their data on the heap. This &lt;code&gt;HashMap&lt;/code&gt; has keys of type &lt;code&gt;String&lt;/code&gt; and values of type &lt;code&gt;i32&lt;/code&gt;. Like vectors, hash maps are homogeneous: all of the keys must have the same type, and all of the values must have the same type.</source>
          <target state="translated">벡터와 마찬가지로 해시 맵은 데이터를 힙에 저장합니다. 이 &lt;code&gt;HashMap&lt;/code&gt; 에는 &lt;code&gt;String&lt;/code&gt; 유형의 키 와 &lt;code&gt;i32&lt;/code&gt; 유형의 값이 있습니다. 벡터와 마찬가지로 해시 맵은 균일합니다. 모든 키의 유형이 동일해야하고 모든 값의 유형이 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="f4b3ade3597f2a53cd73a47fd91e8d89c9f37a8f" translate="yes" xml:space="preserve">
          <source>Just like you cannot have both &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; representation hints on a same type, a &lt;code&gt;packed&lt;/code&gt; type cannot contain another type with the &lt;code&gt;align&lt;/code&gt; representation hint. However, you can do the opposite:</source>
          <target state="translated">동일한 유형에 &lt;code&gt;align&lt;/code&gt; 및 &lt;code&gt;packed&lt;/code&gt; 표현 힌트를 모두 가질 수없는 것처럼 &lt;code&gt;packed&lt;/code&gt; 유형은 &lt;code&gt;align&lt;/code&gt; 표현 힌트가 있는 다른 유형을 포함 할 수 없습니다 . 그러나 그 반대로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad38c597b8238e8c5ffff5cb9392234534096181" translate="yes" xml:space="preserve">
          <source>KW_ABSTRACT : &lt;code&gt;abstract&lt;/code&gt;</source>
          <target state="translated">KW_ABSTRACT : &lt;code&gt;abstract&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be90ce625c319a7fdfb58a43e5bc5c5d9b71f25a" translate="yes" xml:space="preserve">
          <source>KW_AS : &lt;code&gt;as&lt;/code&gt;</source>
          <target state="translated">KW_AS : &lt;code&gt;as&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0173c787da7a615493ad8d7a2cb0a37333dc413" translate="yes" xml:space="preserve">
          <source>KW_ASYNC : &lt;code&gt;async&lt;/code&gt;</source>
          <target state="translated">KW_ASYNC : &lt;code&gt;async&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48849139f33d9b0b0e09242876428fca2f3b32a0" translate="yes" xml:space="preserve">
          <source>KW_AWAIT : &lt;code&gt;await&lt;/code&gt;</source>
          <target state="translated">KW_AWAIT : &lt;code&gt;await&lt;/code&gt; 를</target>
        </trans-unit>
        <trans-unit id="faeff081e9c7bb1476ef0597e5745e683e9089ac" translate="yes" xml:space="preserve">
          <source>KW_BECOME : &lt;code&gt;become&lt;/code&gt;</source>
          <target state="translated">KW_BECOME : &lt;code&gt;become&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb5b5f47578617a58162739554c68db1988e5f19" translate="yes" xml:space="preserve">
          <source>KW_BOX : &lt;code&gt;box&lt;/code&gt;</source>
          <target state="translated">KW_BOX : &lt;code&gt;box&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="789f5a93cd563740436ffcc55aa832d91d39e504" translate="yes" xml:space="preserve">
          <source>KW_BREAK : &lt;code&gt;break&lt;/code&gt;</source>
          <target state="translated">KW_BREAK : &lt;code&gt;break&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="646ebf0a8faa491f908a99b63b433e9b938d1d0d" translate="yes" xml:space="preserve">
          <source>KW_CONST : &lt;code&gt;const&lt;/code&gt;</source>
          <target state="translated">KW_CONST : &lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3b44085f94ca57ca2f334704a2a2c477986387b" translate="yes" xml:space="preserve">
          <source>KW_CONTINUE : &lt;code&gt;continue&lt;/code&gt;</source>
          <target state="translated">KW_CONTINUE : &lt;code&gt;continue&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e94a62fd0360430796d17226621f22aabfdbae9" translate="yes" xml:space="preserve">
          <source>KW_CRATE : &lt;code&gt;crate&lt;/code&gt;</source>
          <target state="translated">KW_CRATE : &lt;code&gt;crate&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e516b0f9399c34f538fa08c26037ff452464083" translate="yes" xml:space="preserve">
          <source>KW_DO : &lt;code&gt;do&lt;/code&gt;</source>
          <target state="translated">KW_DO : &lt;code&gt;do&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a55ecfee6ea0809448ea6f5c0847e66b961b8869" translate="yes" xml:space="preserve">
          <source>KW_DYN : &lt;code&gt;dyn&lt;/code&gt;</source>
          <target state="translated">KW_DYN : &lt;code&gt;dyn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43bd7725cfebb3448607c8a4f8fa78700ac6e981" translate="yes" xml:space="preserve">
          <source>KW_ELSE : &lt;code&gt;else&lt;/code&gt;</source>
          <target state="translated">KW_ELSE : &lt;code&gt;else&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a5b15ab165b8a37f5ca1b5c6cb8b552b4b74656" translate="yes" xml:space="preserve">
          <source>KW_ENUM : &lt;code&gt;enum&lt;/code&gt;</source>
          <target state="translated">KW_ENUM : &lt;code&gt;enum&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0ab52e66c553f670a2e4b9deb4214bb9187af23" translate="yes" xml:space="preserve">
          <source>KW_EXTERN : &lt;code&gt;extern&lt;/code&gt;</source>
          <target state="translated">KW_EXTERN : &lt;code&gt;extern&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a82d8ca4b2bfb3195b34b23742e5f65175a92d0" translate="yes" xml:space="preserve">
          <source>KW_FALSE : &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">KW_FALSE : &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c805a2e97aa19bcae5903d9a457908adfeea3d5" translate="yes" xml:space="preserve">
          <source>KW_FINAL : &lt;code&gt;final&lt;/code&gt;</source>
          <target state="translated">KW_FINAL : &lt;code&gt;final&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a1dbe403904f42293db37c4c0873bfb1846c985" translate="yes" xml:space="preserve">
          <source>KW_FN : &lt;code&gt;fn&lt;/code&gt;</source>
          <target state="translated">KW_FN : &lt;code&gt;fn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51804441d72df4f1c2711281dfd36ba09d409775" translate="yes" xml:space="preserve">
          <source>KW_FOR : &lt;code&gt;for&lt;/code&gt;</source>
          <target state="translated">KW_FOR : &lt;code&gt;for&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ae9f72e482e9a846d12338bb40fabc6e91c7824" translate="yes" xml:space="preserve">
          <source>KW_IF : &lt;code&gt;if&lt;/code&gt;</source>
          <target state="translated">KW_IF : &lt;code&gt;if&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a367c162e2fe29dc4e94c96cbfc7218815660b1" translate="yes" xml:space="preserve">
          <source>KW_IF, INTEGER_LITERAL</source>
          <target state="translated">KW_IF, INTEGER_LITERAL</target>
        </trans-unit>
        <trans-unit id="73fa9c35080f85eae254306fc02ef20b3a0228db" translate="yes" xml:space="preserve">
          <source>KW_IMPL : &lt;code&gt;impl&lt;/code&gt;</source>
          <target state="translated">KW_IMPL : &lt;code&gt;impl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59c563aec15dd074ead40cd8d2c65822bdb4fef2" translate="yes" xml:space="preserve">
          <source>KW_IN : &lt;code&gt;in&lt;/code&gt;</source>
          <target state="translated">KW_IN : &lt;code&gt;in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b10df35e646555ba6a73e442c5fb68654f251460" translate="yes" xml:space="preserve">
          <source>KW_LET : &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">KW_LET : &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2cc99c61ef358b05bbd7856a61981d75499ebec" translate="yes" xml:space="preserve">
          <source>KW_LOOP : &lt;code&gt;loop&lt;/code&gt;</source>
          <target state="translated">KW_LOOP : &lt;code&gt;loop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf074b1962cc7aeed758b10c5e770f59576a496d" translate="yes" xml:space="preserve">
          <source>KW_MACRO : &lt;code&gt;macro&lt;/code&gt;</source>
          <target state="translated">KW_MACRO : &lt;code&gt;macro&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21616e3fdd9348e77ec41feb87c87238b3f4e26c" translate="yes" xml:space="preserve">
          <source>KW_MATCH : &lt;code&gt;match&lt;/code&gt;</source>
          <target state="translated">KW_MATCH : &lt;code&gt;match&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cacbc1424997c4e31784ec865a9cf0e227d1f331" translate="yes" xml:space="preserve">
          <source>KW_MOD : &lt;code&gt;mod&lt;/code&gt;</source>
          <target state="translated">KW_MOD : &lt;code&gt;mod&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76c49906f1ece7b2086399766a4ebb775592dce9" translate="yes" xml:space="preserve">
          <source>KW_MOVE : &lt;code&gt;move&lt;/code&gt;</source>
          <target state="translated">KW_MOVE : &lt;code&gt;move&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e93813d5f885df35d1d34208741cb14417dd32b9" translate="yes" xml:space="preserve">
          <source>KW_MUT : &lt;code&gt;mut&lt;/code&gt;</source>
          <target state="translated">KW_MUT : &lt;code&gt;mut&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="986112403ae83ef4c659145d144f9037283438f0" translate="yes" xml:space="preserve">
          <source>KW_OVERRIDE : &lt;code&gt;override&lt;/code&gt;</source>
          <target state="translated">KW_OVERRIDE : &lt;code&gt;override&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="096b897ed7d5ae1c63992283c83f6e0f9013d7f0" translate="yes" xml:space="preserve">
          <source>KW_PRIV : &lt;code&gt;priv&lt;/code&gt;</source>
          <target state="translated">KW_PRIV : &lt;code&gt;priv&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f48e0064a9cb22ae594e388e4915e7d88ce3349c" translate="yes" xml:space="preserve">
          <source>KW_PUB : &lt;code&gt;pub&lt;/code&gt;</source>
          <target state="translated">KW_PUB : &lt;code&gt;pub&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ebf55b9ade912097bcab3d0fc356bd22943c572" translate="yes" xml:space="preserve">
          <source>KW_REF : &lt;code&gt;ref&lt;/code&gt;</source>
          <target state="translated">KW_REF : &lt;code&gt;ref&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4aa1bbded52171e54febc09f265f40e1c0be60b" translate="yes" xml:space="preserve">
          <source>KW_RETURN : &lt;code&gt;return&lt;/code&gt;</source>
          <target state="translated">KW_RETURN : &lt;code&gt;return&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb8c1f081587b4145c8d20e256de8a57807802c8" translate="yes" xml:space="preserve">
          <source>KW_SELFTYPE : &lt;code&gt;Self&lt;/code&gt;</source>
          <target state="translated">KW_SELFTYPE : &lt;code&gt;Self&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="589c3916c9b199922a8c5503d2f10a38cd602f6d" translate="yes" xml:space="preserve">
          <source>KW_SELFVALUE : &lt;code&gt;self&lt;/code&gt;</source>
          <target state="translated">KW_SELFVALUE : &lt;code&gt;self&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e97f068c91e52b8ee0bf7536b78346905ff65084" translate="yes" xml:space="preserve">
          <source>KW_STATIC : &lt;code&gt;static&lt;/code&gt;</source>
          <target state="translated">KW_STATIC : &lt;code&gt;static&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3f4b78faf33e54502b143b3311dfbbea495dd79" translate="yes" xml:space="preserve">
          <source>KW_STATICLIFETIME : &lt;code&gt;'static&lt;/code&gt;</source>
          <target state="translated">KW_STATICLIFETIME : &lt;code&gt;'static&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96f670f49f58217687c9c79e68cbb2ce6b233631" translate="yes" xml:space="preserve">
          <source>KW_STRUCT : &lt;code&gt;struct&lt;/code&gt;</source>
          <target state="translated">KW_STRUCT : &lt;code&gt;struct&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb41d3d257888d3ae68c1492a043887998f5646e" translate="yes" xml:space="preserve">
          <source>KW_SUPER : &lt;code&gt;super&lt;/code&gt;</source>
          <target state="translated">KW_SUPER : &lt;code&gt;super&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17d62ea6cea231ded0372e49c12635b034d685a2" translate="yes" xml:space="preserve">
          <source>KW_TRAIT : &lt;code&gt;trait&lt;/code&gt;</source>
          <target state="translated">KW_TRAIT : &lt;code&gt;trait&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2436e51574011f63df503ea8e052114e32b38421" translate="yes" xml:space="preserve">
          <source>KW_TRUE : &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">KW_TRUE : &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="33857bab7317b38e930f6e043274e294dfdb0837" translate="yes" xml:space="preserve">
          <source>KW_TRY : &lt;code&gt;try&lt;/code&gt;</source>
          <target state="translated">KW_TRY : &lt;code&gt;try&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b98be3594c838969fbf8e804a3b83125cd8f9164" translate="yes" xml:space="preserve">
          <source>KW_TYPE : &lt;code&gt;type&lt;/code&gt;</source>
          <target state="translated">KW_TYPE : &lt;code&gt;type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f90893de8264f12555e264daf55d8d3573f648a" translate="yes" xml:space="preserve">
          <source>KW_TYPEOF : &lt;code&gt;typeof&lt;/code&gt;</source>
          <target state="translated">KW_TYPEOF : &lt;code&gt;typeof&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="810b6331cc472782bf330b62c25e7caade19a83a" translate="yes" xml:space="preserve">
          <source>KW_UNION : &lt;code&gt;union&lt;/code&gt;</source>
          <target state="translated">KW_UNION : &lt;code&gt;union&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b8c046c3fefb22d66beea883f5fe4ae12ff703c3" translate="yes" xml:space="preserve">
          <source>KW_UNSAFE : &lt;code&gt;unsafe&lt;/code&gt;</source>
          <target state="translated">KW_UNSAFE : &lt;code&gt;unsafe&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1a504e9e9c867afd9ae5cd6865e04fd6708c18c" translate="yes" xml:space="preserve">
          <source>KW_UNSIZED : &lt;code&gt;unsized&lt;/code&gt;</source>
          <target state="translated">KW_UNSIZED : &lt;code&gt;unsized&lt;/code&gt; 조정되지 않음</target>
        </trans-unit>
        <trans-unit id="a42f6264915b56a563a35b937d40ee2b1092d828" translate="yes" xml:space="preserve">
          <source>KW_USE : &lt;code&gt;use&lt;/code&gt;</source>
          <target state="translated">KW_USE : &lt;code&gt;use&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0164d2f9ee89b4ff7027682d51a2a239aa74f90" translate="yes" xml:space="preserve">
          <source>KW_VIRTUAL : &lt;code&gt;virtual&lt;/code&gt;</source>
          <target state="translated">KW_VIRTUAL : &lt;code&gt;virtual&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ddbe1f7c29b3f7210557405db5ed34966c662d08" translate="yes" xml:space="preserve">
          <source>KW_WHERE : &lt;code&gt;where&lt;/code&gt;</source>
          <target state="translated">KW_WHERE : &lt;code&gt;where&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c9dfcdf6820da0b224753fce346422cdc8d7ae5" translate="yes" xml:space="preserve">
          <source>KW_WHILE : &lt;code&gt;while&lt;/code&gt;</source>
          <target state="translated">KW_WHILE : &lt;code&gt;while&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98333a752caf854e21271745fd6749b9c1d1a7d1" translate="yes" xml:space="preserve">
          <source>KW_YIELD : &lt;code&gt;yield&lt;/code&gt;</source>
          <target state="translated">KW_YIELD : &lt;code&gt;yield&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0691b0c7d3cefeeeae3a2289278f41bd8c7c1e6f" translate="yes" xml:space="preserve">
          <source>Keep a global count of live threads:</source>
          <target state="translated">전체 라이브 스레드 수를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="d2d8fe2c08e017878e56af189be768b49b58a3e4" translate="yes" xml:space="preserve">
          <source>Keep in mind that Rust is a &lt;em&gt;statically typed&lt;/em&gt; language, which means that it must know the types of all variables at compile time. The compiler can usually infer what type we want to use based on the value and how we use it. In cases when many types are possible, such as when we converted a &lt;code&gt;String&lt;/code&gt; to a numeric type using &lt;code&gt;parse&lt;/code&gt; in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt; section in Chapter 2, we must add a type annotation, like this:</source>
          <target state="translated">Rust는 &lt;em&gt;정적으로 유형이 지정된&lt;/em&gt; 언어이므로 컴파일 타임에 모든 변수의 유형을 알아야합니다. 컴파일러는 일반적으로 값과 사용 방법에 따라 사용하려는 유형을 유추 할 수 있습니다. 2 장의 &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&quot;비밀번호와 추측 비교&quot;&lt;/a&gt; 섹션의 &lt;code&gt;parse&lt;/code&gt; 을 사용하여 &lt;code&gt;String&lt;/code&gt; 을 숫자 유형으로 변환 할 때와 같이 많은 유형이 가능한 경우 다음과 같이 유형 주석을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="52e9fac3044bab3714b6ee55ecb852540b800b38" translate="yes" xml:space="preserve">
          <source>Keeping Track of Borrows at Runtime with &lt;code id=&quot;keeping-track-of-borrows-at-runtime-with-refcellt&quot;&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;keeping-track-of-borrows-at-runtime-with-refcellt&quot;&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 하여 런타임에 차용 내역 추적</target>
        </trans-unit>
        <trans-unit id="d3ebbc3717ea52d0fdffcb979b6a75601bc35c26" translate="yes" xml:space="preserve">
          <source>Keeping a crate&amp;rsquo;s functionality in its own scope clarifies whether particular functionality is defined in our crate or the &lt;code&gt;rand&lt;/code&gt; crate and prevents potential conflicts. For example, the &lt;code&gt;rand&lt;/code&gt; crate provides a trait named &lt;code&gt;Rng&lt;/code&gt;. We can also define a &lt;code&gt;struct&lt;/code&gt; named &lt;code&gt;Rng&lt;/code&gt; in our own crate. Because a crate&amp;rsquo;s functionality is namespaced in its own scope, when we add &lt;code&gt;rand&lt;/code&gt; as a dependency, the compiler isn&amp;rsquo;t confused about what the name &lt;code&gt;Rng&lt;/code&gt; refers to. In our crate, it refers to the &lt;code&gt;struct Rng&lt;/code&gt; that we defined. We would access the &lt;code&gt;Rng&lt;/code&gt; trait from the &lt;code&gt;rand&lt;/code&gt; crate as &lt;code&gt;rand::Rng&lt;/code&gt;.</source>
          <target state="translated">크레이트의 기능을 자체 범위로 유지하면 특정 기능이 크레이트 또는 &lt;code&gt;rand&lt;/code&gt; 크레이트에 정의되어 있는지 와 충돌 가능성을 방지 할 수 있습니다. 예를 들어 &lt;code&gt;rand&lt;/code&gt; 상자는 &lt;code&gt;Rng&lt;/code&gt; 라는 특성을 제공합니다 . 우리 자신의 상자에 &lt;code&gt;Rng&lt;/code&gt; 라는 &lt;code&gt;struct&lt;/code&gt; 정의 할 수도 있습니다 . 크레이트의 기능은 자체 범위에서 이름이 지정되어 있으므로 &lt;code&gt;rand&lt;/code&gt; 를 종속성으로 추가 할 때 컴파일러는 &lt;code&gt;Rng&lt;/code&gt; 라는 이름이 무엇인지 혼동하지 않습니다 . 우리 상자에서, 그것은 우리가 정의한 &lt;code&gt;struct Rng&lt;/code&gt; 를 나타냅니다 . &lt;code&gt;rand&lt;/code&gt; 상자에서 &lt;code&gt;rand::Rng&lt;/code&gt; 로 &lt;code&gt;Rng&lt;/code&gt; 특성에 액세스합니다..</target>
        </trans-unit>
        <trans-unit id="e9f12e803a098c99995539cb42f36c9f9739f97e" translate="yes" xml:space="preserve">
          <source>Keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you don&amp;rsquo;t run out of space are all problems that ownership addresses. Once you understand ownership, you won&amp;rsquo;t need to think about the stack and the heap very often, but knowing that managing heap data is why ownership exists can help explain why it works the way it does.</source>
          <target state="translated">코드의 어떤 부분이 힙의 데이터를 사용하고 있는지, 힙의 중복 데이터 양을 최소화하고, 힙에서 사용되지 않은 데이터를 정리하여 공간이 부족하지 않도록하는 것은 소유권이 해결하는 모든 문제입니다. 소유권을 이해하면 스택과 힙에 대해 자주 생각할 필요는 없지만 힙 데이터 관리가 소유권이 존재하는 이유를 알면 소유권이 작동 방식을 설명하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd35d612a134cd358cb5ad1ce1e9e74301067e1d" translate="yes" xml:space="preserve">
          <source>Key-value option set at most once with the target's operating system value.</source>
          <target state="translated">대상 운영 체제 값으로 최대 한 번 설정된 키-값 옵션.</target>
        </trans-unit>
        <trans-unit id="ce96f30fb0633a0de5217c6ddf2318f94830e44b" translate="yes" xml:space="preserve">
          <source>Key-value option set for each platform feature available for the current compilation target.</source>
          <target state="translated">현재 컴파일 대상에 사용 가능한 각 플랫폼 기능에 대한 키-값 옵션 세트.</target>
        </trans-unit>
        <trans-unit id="ce9ea81e67f13ab1e763fa87e4c0b2168fc63774" translate="yes" xml:space="preserve">
          <source>Key-value option set once with either a value of &quot;little&quot; or &quot;big&quot; depending on the endianness of the target's CPU.</source>
          <target state="translated">키 값 옵션은 대상 CPU의 엔디안에 따라 &quot;little&quot;또는 &quot;big&quot;값으로 한 번 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="63e95325de8c37181511cb94e0cd4096c6b7d2ef" translate="yes" xml:space="preserve">
          <source>Key-value option set once with the target's CPU architecture. The value is similar to the first element of the platform's target triple, but not identical.</source>
          <target state="translated">대상의 CPU 아키텍처로 한 번 설정된 키-값 옵션. 이 값은 플랫폼 대상 트리플의 첫 번째 요소와 유사하지만 동일하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f535aa6f58b910aacefadf78335cfd96c455f70" translate="yes" xml:space="preserve">
          <source>Key-value option set once with the target's operating system. This value is similar to the second and third element of the platform's target triple.</source>
          <target state="translated">대상 운영 체제로 한 번 설정된 키-값 옵션. 이 값은 플랫폼 대상 트리플의 두 번째 및 세 번째 요소와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="21bb65083a0c78de1363d38fcb64deec6c2f621f" translate="yes" xml:space="preserve">
          <source>Key-value option set once with the target's pointer width in bits.</source>
          <target state="translated">키-값 옵션은 대상의 포인터 너비 (비트)로 한 번 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="18ebc4327b545eab4c13648ab9805f30fdc72faa" translate="yes" xml:space="preserve">
          <source>Key-value option set once with the target's pointer width in bits. For example, for targets with 32-bit pointers, this is set to &lt;code&gt;&quot;32&quot;&lt;/code&gt;. Likewise, it is set to &lt;code&gt;&quot;64&quot;&lt;/code&gt; for targets with 64-bit pointers.</source>
          <target state="translated">키 값 옵션은 대상의 포인터 너비를 비트 단위로 한 번 설정합니다. 예를 들어, 32 비트 포인터가있는 대상의 경우 &lt;code&gt;&quot;32&quot;&lt;/code&gt; 로 설정됩니다 . 마찬가지로 64 비트 포인터가있는 대상의 경우 &lt;code&gt;&quot;64&quot;&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="919823df75a839f68908ab4a52f685cce0bc3afd" translate="yes" xml:space="preserve">
          <source>Key-value option set once with the vendor of the target.</source>
          <target state="translated">대상 공급 업체에 한 번 설정된 키-값 옵션.</target>
        </trans-unit>
        <trans-unit id="11da1ff3fc87f22cc67c02cf8eb624f317fde1c5" translate="yes" xml:space="preserve">
          <source>Key-value option set with further disambiguating information about the target platform with information about the ABI or &lt;code&gt;libc&lt;/code&gt; used. For historical reasons, this value is only defined as not the empty-string when actually needed for disambiguation. Thus, for example, on many GNU platforms, this value will be empty. This value is similar to the fourth element of the platform's target triple. One difference is that embedded ABIs such as &lt;code&gt;gnueabihf&lt;/code&gt; will simply define &lt;code&gt;target_env&lt;/code&gt; as &lt;code&gt;&quot;gnu&quot;&lt;/code&gt;.</source>
          <target state="translated">사용 된 ABI 또는 &lt;code&gt;libc&lt;/code&gt; 에 대한 정보를 사용하여 대상 플랫폼에 대한 자세한 정보를 제공하는 키-값 옵션 세트 . 역사적 이유로,이 값은 실제로 명확성을 위해 필요할 때 빈 문자열이 아닌 것으로 정의됩니다. 따라서 예를 들어 많은 GNU 플랫폼에서이 값은 비어 있습니다. 이 값은 플랫폼 대상 트리플의 네 번째 요소와 유사합니다. 한 가지 차이점은 &lt;code&gt;gnueabihf&lt;/code&gt; 와 같은 임베디드 ABI 는 단순히 &lt;code&gt;target_env&lt;/code&gt; 를 &lt;code&gt;&quot;gnu&quot;&lt;/code&gt; 로 정의 한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e5651c683f14c95aa972cfdbc300d9fecfe02019" translate="yes" xml:space="preserve">
          <source>Keys</source>
          <target state="translated">Keys</target>
        </trans-unit>
        <trans-unit id="8f31576d96d60f0abebc904da3b4f2881c89ac5a" translate="yes" xml:space="preserve">
          <source>Keys are not unique in the set of key-value configuration options. For example, both &lt;code&gt;feature = &quot;std&quot;&lt;/code&gt; and &lt;code&gt;feature = &quot;serde&quot;&lt;/code&gt; can be set at the same time.</source>
          <target state="translated">키는 키-값 구성 옵션 세트에서 고유하지 않습니다. 예를 들어, &lt;code&gt;feature = &quot;std&quot;&lt;/code&gt; 와 &lt;code&gt;feature = &quot;serde&quot;&lt;/code&gt; 를 동시에 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fe4683b112b96ba7631fcdc86fabb26bd695c7d" translate="yes" xml:space="preserve">
          <source>Keyword Self</source>
          <target state="translated">키워드 자체</target>
        </trans-unit>
        <trans-unit id="7a05409abe457818d06a7b2a827d071925e3123d" translate="yes" xml:space="preserve">
          <source>Keyword as</source>
          <target state="translated">키워드</target>
        </trans-unit>
        <trans-unit id="111297ecda21e09bfe2a8317450e29b120adfb90" translate="yes" xml:space="preserve">
          <source>Keyword async</source>
          <target state="translated">키워드 비동기</target>
        </trans-unit>
        <trans-unit id="2b96f62624a68fd871d5766ca2fa2145d4644a70" translate="yes" xml:space="preserve">
          <source>Keyword await</source>
          <target state="translated">키워드가 기다리고 있습니다</target>
        </trans-unit>
        <trans-unit id="f6c6e1b25bec0a5a14bc88afab261e9a04ec9707" translate="yes" xml:space="preserve">
          <source>Keyword break</source>
          <target state="translated">키워드 구분</target>
        </trans-unit>
        <trans-unit id="436846eb0b7f7b9748553b55f55233f3a2e1b42b" translate="yes" xml:space="preserve">
          <source>Keyword const</source>
          <target state="translated">키워드 const</target>
        </trans-unit>
        <trans-unit id="2a3920d65d1221a1de8f19c31f0add5d8fc541dd" translate="yes" xml:space="preserve">
          <source>Keyword continue</source>
          <target state="translated">키워드 계속</target>
        </trans-unit>
        <trans-unit id="9eb24d787290917c89c3e8b0eb98d952c8cdf70d" translate="yes" xml:space="preserve">
          <source>Keyword crate</source>
          <target state="translated">키워드 상자</target>
        </trans-unit>
        <trans-unit id="9274e1d61951bc25e37abafb1a71c5c41800be68" translate="yes" xml:space="preserve">
          <source>Keyword dyn</source>
          <target state="translated">키워드 dyn</target>
        </trans-unit>
        <trans-unit id="377e304b2d1e85347b20ff335b6d99538e6c187b" translate="yes" xml:space="preserve">
          <source>Keyword else</source>
          <target state="translated">다른 키워드</target>
        </trans-unit>
        <trans-unit id="7aba16f0afd468040716e09c2ae6718f272a6458" translate="yes" xml:space="preserve">
          <source>Keyword enum</source>
          <target state="translated">키워드 열거 형</target>
        </trans-unit>
        <trans-unit id="497cef40287ff8c1a00ccb47de8f855e132be344" translate="yes" xml:space="preserve">
          <source>Keyword extern</source>
          <target state="translated">키워드 인턴</target>
        </trans-unit>
        <trans-unit id="2a6e421aa23f1681fcb97ab460fe75051a3e013b" translate="yes" xml:space="preserve">
          <source>Keyword false</source>
          <target state="translated">키워드 거짓</target>
        </trans-unit>
        <trans-unit id="ad325f8a9f86ad3293235a282313ef21d8bfd594" translate="yes" xml:space="preserve">
          <source>Keyword fn</source>
          <target state="translated">키워드 fn</target>
        </trans-unit>
        <trans-unit id="a25477170e21ac7e2572a740282b4353f075bcfe" translate="yes" xml:space="preserve">
          <source>Keyword for</source>
          <target state="translated">의 키워드</target>
        </trans-unit>
        <trans-unit id="aa09921301016318d19919d413f46e0991eaa034" translate="yes" xml:space="preserve">
          <source>Keyword if</source>
          <target state="translated">키워드</target>
        </trans-unit>
        <trans-unit id="70d230cf570b8b6b9e41e2c04e4b1eecd566cc1c" translate="yes" xml:space="preserve">
          <source>Keyword impl</source>
          <target state="translated">키워드 노출</target>
        </trans-unit>
        <trans-unit id="1d1b8618ebc37a044f2789a54f15fcc89bca4b48" translate="yes" xml:space="preserve">
          <source>Keyword in</source>
          <target state="translated">키워드</target>
        </trans-unit>
        <trans-unit id="e45321f53ba7f20aaa2734b8d92fce994255c877" translate="yes" xml:space="preserve">
          <source>Keyword let</source>
          <target state="translated">키워드 let</target>
        </trans-unit>
        <trans-unit id="b17d0119a3acf3683a3f63c42ae8a1a62b0f2bec" translate="yes" xml:space="preserve">
          <source>Keyword loop</source>
          <target state="translated">키워드 루프</target>
        </trans-unit>
        <trans-unit id="08770e678060c19974b3fc3b3f50ffe441004b2d" translate="yes" xml:space="preserve">
          <source>Keyword match</source>
          <target state="translated">키워드 검색</target>
        </trans-unit>
        <trans-unit id="eb89d3478115288bccdf47fcaee875e6e9dec53b" translate="yes" xml:space="preserve">
          <source>Keyword mod</source>
          <target state="translated">키워드 모드</target>
        </trans-unit>
        <trans-unit id="5fcfe7efe61a879544f9458d60ef298a6eae68ef" translate="yes" xml:space="preserve">
          <source>Keyword move</source>
          <target state="translated">키워드 이동</target>
        </trans-unit>
        <trans-unit id="e8f403359a67fdeb4f9a69ff28eebe446a15425c" translate="yes" xml:space="preserve">
          <source>Keyword mut</source>
          <target state="translated">키워드 뮤트</target>
        </trans-unit>
        <trans-unit id="5aad2726454c0cfe99c64b86b5506fbc780aba60" translate="yes" xml:space="preserve">
          <source>Keyword pub</source>
          <target state="translated">키워드 펍</target>
        </trans-unit>
        <trans-unit id="fd01e715bc85516f46378428fd84c2baadd44546" translate="yes" xml:space="preserve">
          <source>Keyword ref</source>
          <target state="translated">키워드 심판</target>
        </trans-unit>
        <trans-unit id="0d24ace1f65b53c2f9e03ed8271b08e7fc77ee6d" translate="yes" xml:space="preserve">
          <source>Keyword return</source>
          <target state="translated">키워드 반환</target>
        </trans-unit>
        <trans-unit id="17548e2276001357bd22942d19f5cb00544567f5" translate="yes" xml:space="preserve">
          <source>Keyword static</source>
          <target state="translated">키워드 정적</target>
        </trans-unit>
        <trans-unit id="05f8b04e053f5e1b453e9b0b93670f8ffca49cf9" translate="yes" xml:space="preserve">
          <source>Keyword struct</source>
          <target state="translated">키워드 구조</target>
        </trans-unit>
        <trans-unit id="c230764a5d99ee580877e7cde563c5c1768ec51f" translate="yes" xml:space="preserve">
          <source>Keyword super</source>
          <target state="translated">키워드 슈퍼</target>
        </trans-unit>
        <trans-unit id="48effa325ed166316a6e508bc8da17af9983e809" translate="yes" xml:space="preserve">
          <source>Keyword trait</source>
          <target state="translated">키워드 특성</target>
        </trans-unit>
        <trans-unit id="3092260b25ab0be886a76ed515be7af36594b34e" translate="yes" xml:space="preserve">
          <source>Keyword true</source>
          <target state="translated">키워드 true</target>
        </trans-unit>
        <trans-unit id="48b8acd5cc92e931fbcf08f4564de6254a3688f3" translate="yes" xml:space="preserve">
          <source>Keyword type</source>
          <target state="translated">키워드 유형</target>
        </trans-unit>
        <trans-unit id="df96c1b537e86440f56db5003c98baa08726505b" translate="yes" xml:space="preserve">
          <source>Keyword union</source>
          <target state="translated">키워드 조합</target>
        </trans-unit>
        <trans-unit id="16040d77331d2a3b59872c42f67d3f8a96b1c3dd" translate="yes" xml:space="preserve">
          <source>Keyword unsafe</source>
          <target state="translated">안전하지 않은 키워드</target>
        </trans-unit>
        <trans-unit id="f29c9f829c3c510995b3f7cdf3202a3d7c402a35" translate="yes" xml:space="preserve">
          <source>Keyword use</source>
          <target state="translated">키워드 사용</target>
        </trans-unit>
        <trans-unit id="fe4e85de0c4f74847bd8e598f60609044af0ee40" translate="yes" xml:space="preserve">
          <source>Keyword where</source>
          <target state="translated">키워드</target>
        </trans-unit>
        <trans-unit id="7d7b00f33afab4f85be61beaf96d76b0462792b9" translate="yes" xml:space="preserve">
          <source>Keyword while</source>
          <target state="translated">키워드</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="e3640301ed0023ff94e08911cc76aa75eb8d7a5e" translate="yes" xml:space="preserve">
          <source>Keywords Currently in Use</source>
          <target state="translated">현재 사용중인 키워드</target>
        </trans-unit>
        <trans-unit id="8a1e43b45921c00d897b3f014078137489061012" translate="yes" xml:space="preserve">
          <source>Keywords Reserved for Future Use</source>
          <target state="translated">나중에 사용하기 위해 예약 된 키워드</target>
        </trans-unit>
        <trans-unit id="8894c6a0dbced6c16c0d9df706a39a96c0879833" translate="yes" xml:space="preserve">
          <source>Knowing that you can take slices of literals and &lt;code&gt;String&lt;/code&gt; values leads us to one more improvement on &lt;code&gt;first_word&lt;/code&gt;, and that&amp;rsquo;s its signature:</source>
          <target state="translated">리터럴과 &lt;code&gt;String&lt;/code&gt; 값 을 사용할 수 있다는 것을 알면 &lt;code&gt;first_word&lt;/code&gt; 를 한 번 더 개선 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5025143a89e9b224781aa62468c0e2c91c66496" translate="yes" xml:space="preserve">
          <source>Known Issues</source>
          <target state="translated">알려진 문제</target>
        </trans-unit>
        <trans-unit id="d3ae07e851fde32543939729ee80148fb0ebdf41" translate="yes" xml:space="preserve">
          <source>Known bugs</source>
          <target state="translated">알려진 버그</target>
        </trans-unit>
        <trans-unit id="7e70d2e585c390da7abcf2a3249245e0e36e0092" translate="yes" xml:space="preserve">
          <source>LAST</source>
          <target state="translated">LAST</target>
        </trans-unit>
        <trans-unit id="7c94d83254a2ffa0762a5bfff0ef000108b0fbf6" translate="yes" xml:space="preserve">
          <source>LAST(&lt;code&gt;$( $d:ident $e:expr );* $(h)* $( f ;)+ g&lt;/code&gt;) = { &lt;code&gt;g&lt;/code&gt; }</source>
          <target state="translated">마지막 ( &lt;code&gt;$( $d:ident $e:expr );* $(h)* $( f ;)+ g&lt;/code&gt; ) = { &lt;code&gt;g&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="e400fae22d0553b70188e398d3482c7e98a473b0" translate="yes" xml:space="preserve">
          <source>LAST(&lt;code&gt;$( $d:ident $e:expr );* $(h)* $( f ;)+&lt;/code&gt;) = { &lt;code&gt;;&lt;/code&gt; }</source>
          <target state="translated">LAST ( &lt;code&gt;$( $d:ident $e:expr );* $(h)* $( f ;)+&lt;/code&gt; ) = { &lt;code&gt;;&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="f4251e0f413cd3f41f3df9bb22d15a8115a98157" translate="yes" xml:space="preserve">
          <source>LAST(&lt;code&gt;$( $d:ident $e:expr );* $(h)*&lt;/code&gt;) = { &lt;code&gt;$e:expr&lt;/code&gt;, &amp;epsilon;, &lt;code&gt;h&lt;/code&gt; }</source>
          <target state="translated">LAST ( &lt;code&gt;$( $d:ident $e:expr );* $(h)*&lt;/code&gt; ) = { &lt;code&gt;$e:expr&lt;/code&gt; , &amp;epsilon;, &lt;code&gt;h&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="7ff61fa787f2c62adc8ee173405366e66cca6711" translate="yes" xml:space="preserve">
          <source>LAST(&lt;code&gt;$( $d:ident $e:expr );*&lt;/code&gt;) = { &lt;code&gt;$e:expr&lt;/code&gt;, &amp;epsilon; }</source>
          <target state="translated">LAST ( &lt;code&gt;$( $d:ident $e:expr );*&lt;/code&gt; ) = { &lt;code&gt;$e:expr&lt;/code&gt; , &amp;epsilon;}</target>
        </trans-unit>
        <trans-unit id="37aef063f183280d4f7dc041920c02a28b503744" translate="yes" xml:space="preserve">
          <source>LAST(&lt;code&gt;$d:ident $e:expr&lt;/code&gt;) = { &lt;code&gt;$e:expr&lt;/code&gt; }</source>
          <target state="translated">마지막 ( &lt;code&gt;$d:ident $e:expr&lt;/code&gt; ) = { &lt;code&gt;$e:expr&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="7fab544af8af2c23b62871343f4c928563121b43" translate="yes" xml:space="preserve">
          <source>LAST(M), defined by case analysis on M itself (a sequence of token-trees):</source>
          <target state="translated">M 자체 (시퀀스 트리 시퀀스)에 대한 사례 분석으로 정의 된 LAST (M) :</target>
        </trans-unit>
        <trans-unit id="f85099a357b111ba1d477f0dbd426a597f6e3435" translate="yes" xml:space="preserve">
          <source>LAST(M): collects the tokens potentially used last when matching a fragment to M.</source>
          <target state="translated">LAST (M) : 프래그먼트를 M과 일치시킬 때 마지막으로 사용 된 토큰을 수집합니다.</target>
        </trans-unit>
        <trans-unit id="e8ea6b99f854e01dbe363d86b29cecae5304f225" translate="yes" xml:space="preserve">
          <source>LIFETIME_OR_LABEL</source>
          <target state="translated">LIFETIME_OR_LABEL</target>
        </trans-unit>
        <trans-unit id="40a1fdbb26c080098fc98bb4705851d4859ab4d3" translate="yes" xml:space="preserve">
          <source>LIFETIME_OR_LABEL :</source>
          <target state="translated">LIFETIME_OR_LABEL :</target>
        </trans-unit>
        <trans-unit id="46318a9c5b3843dedcc74d3eda791e4202987f7e" translate="yes" xml:space="preserve">
          <source>LIFETIME_TOKEN :</source>
          <target state="translated">LIFETIME_TOKEN :</target>
        </trans-unit>
        <trans-unit id="ed2747925f72878526dce1d4b02fb7c509e9b22b" translate="yes" xml:space="preserve">
          <source>LINE_COMMENT :</source>
          <target state="translated">LINE_COMMENT :</target>
        </trans-unit>
        <trans-unit id="f87b1be490e7f2bd1d43aa401d9acb86c892b5d9" translate="yes" xml:space="preserve">
          <source>LLVM checks the validity of the constraints and the assembly string passed to it. This error implies that LLVM seems something wrong with the inline assembly call.</source>
          <target state="translated">LLVM은 구속 조건의 유효성과 전달 된 어셈블리 문자열을 확인합니다. 이 오류는 LLVM이 인라인 어셈블리 호출에 문제가있는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b658c08127be6d116e98bc8876055e873db0602" translate="yes" xml:space="preserve">
          <source>LLVM-style inline assembly.</source>
          <target state="translated">LLVM 스타일 인라인 어셈블리.</target>
        </trans-unit>
        <trans-unit id="4c275bc5d1a4e6d0414829b996cfcec4698e44c4" translate="yes" xml:space="preserve">
          <source>LN_10</source>
          <target state="translated">LN_10</target>
        </trans-unit>
        <trans-unit id="6a259766cb7d3ece474214d8a5b06e89f14ab44c" translate="yes" xml:space="preserve">
          <source>LN_2</source>
          <target state="translated">LN_2</target>
        </trans-unit>
        <trans-unit id="98673bb5e17015cbf16ed84d89d8f970845d818b" translate="yes" xml:space="preserve">
          <source>LOG10_2</source>
          <target state="translated">LOG10_2</target>
        </trans-unit>
        <trans-unit id="66e6842f3da223e16de827da3acf936ddc9d0df5" translate="yes" xml:space="preserve">
          <source>LOG10_E</source>
          <target state="translated">LOG10_E</target>
        </trans-unit>
        <trans-unit id="615a1422d501618265e393e3550ecb5f40f525ea" translate="yes" xml:space="preserve">
          <source>LOG2_10</source>
          <target state="translated">LOG2_10</target>
        </trans-unit>
        <trans-unit id="1e3656097aebf0f10597eae43f1c807651a96817" translate="yes" xml:space="preserve">
          <source>LOG2_E</source>
          <target state="translated">LOG2_E</target>
        </trans-unit>
        <trans-unit id="64b87b109e5db684a74aa921ff29dc63050bf704" translate="yes" xml:space="preserve">
          <source>Lang items are already implemented in the standard library. Unless you are writing a free-standing application (e.g., a kernel), you do not need to provide them yourself.</source>
          <target state="translated">Lang 항목은 이미 표준 라이브러리에 구현되어 있습니다. 독립형 응용 프로그램 (예 : 커널)을 작성하지 않는 한 직접 제공 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec882b1a036e4071e5191bd244e46720429e3479" translate="yes" xml:space="preserve">
          <source>Languages without case are not changed:</source>
          <target state="translated">대소 문자가없는 언어는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f3396549fa1fe2041e1f31d203c0b16d63a7207" translate="yes" xml:space="preserve">
          <source>Large amounts of data are being stored</source>
          <target state="translated">많은 양의 데이터가 저장되고 있습니다</target>
        </trans-unit>
        <trans-unit id="d3612663cc19e49c3a2d261d922690a9fc7582ed" translate="yes" xml:space="preserve">
          <source>Largest finite &lt;code&gt;f32&lt;/code&gt; value.</source>
          <target state="translated">가장 큰 유한 &lt;code&gt;f32&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="cdef2a389723afff7da4b608a1325e2bd13839b5" translate="yes" xml:space="preserve">
          <source>Largest finite &lt;code&gt;f32&lt;/code&gt; value. Use &lt;a href=&quot;../primitive.f32#associatedconstant.MAX&quot;&gt;&lt;code&gt;f32::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">최대 유한 &lt;code&gt;f32&lt;/code&gt; 값입니다. 대신 &lt;a href=&quot;../primitive.f32#associatedconstant.MAX&quot;&gt; &lt;code&gt;f32::MAX&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f275a12dc16bf46e1c9b02d6b9bdd0fdd3cd4f44" translate="yes" xml:space="preserve">
          <source>Largest finite &lt;code&gt;f64&lt;/code&gt; value.</source>
          <target state="translated">가장 큰 유한 &lt;code&gt;f64&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="caa7ded1cda53ab540342fa3edd4f2916d1b87b9" translate="yes" xml:space="preserve">
          <source>Largest finite &lt;code&gt;f64&lt;/code&gt; value. Use &lt;a href=&quot;../primitive.f64#associatedconstant.MAX&quot;&gt;&lt;code&gt;f64::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">최대 유한 &lt;code&gt;f64&lt;/code&gt; 값입니다. 대신 &lt;a href=&quot;../primitive.f64#associatedconstant.MAX&quot;&gt; &lt;code&gt;f64::MAX&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a58d72036ad47fa0a1439cec22ee87f753fd7e3f" translate="yes" xml:space="preserve">
          <source>Last, but certainly not least, is &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;. This type is used as the return type of many &lt;code&gt;std::io&lt;/code&gt; functions that can cause an error, and can be returned from your own functions as well. Many of the examples in this module use the &lt;a href=&quot;../../book/appendix-02-operators&quot;&gt;&lt;code&gt;?&lt;/code&gt; operator&lt;/a&gt;:</source>
          <target state="translated">마지막으로 &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; 입니다. 이 유형은 오류가 발생할 수있는 많은 &lt;code&gt;std::io&lt;/code&gt; 함수 의 리턴 유형으로 사용되며 자체 함수에서도 리턴 될 수 있습니다. 이 모듈의 많은 예제는 &lt;a href=&quot;../../book/appendix-02-operators&quot;&gt; &lt;code&gt;?&lt;/code&gt; 운영자&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="972ad8d8a50397ba8c02433ed8f048eeb4074b85" translate="yes" xml:space="preserve">
          <source>Layout</source>
          <target state="translated">Layout</target>
        </trans-unit>
        <trans-unit id="ae8568d10c64dba6b746ac76005e66dab74cb9ab" translate="yes" xml:space="preserve">
          <source>Layout of a block of memory.</source>
          <target state="translated">메모리 블록의 레이아웃.</target>
        </trans-unit>
        <trans-unit id="7d4179a87c3ab99e827a9f6e1aa71781644d0b85" translate="yes" xml:space="preserve">
          <source>Layout::align</source>
          <target state="translated">Layout::align</target>
        </trans-unit>
        <trans-unit id="2b7cae98e285326dfa8874cd827b7060dafbb97f" translate="yes" xml:space="preserve">
          <source>Layout::align_to</source>
          <target state="translated">Layout::align_to</target>
        </trans-unit>
        <trans-unit id="6ffbac24ba5cb9cdd880e70819658687db1a163d" translate="yes" xml:space="preserve">
          <source>Layout::array</source>
          <target state="translated">Layout::array</target>
        </trans-unit>
        <trans-unit id="faf545bb524583c428a14d8796fd332e8b1f4538" translate="yes" xml:space="preserve">
          <source>Layout::borrow</source>
          <target state="translated">Layout::borrow</target>
        </trans-unit>
        <trans-unit id="6e7c904826d6356b87a5fd10b67922e27e248f36" translate="yes" xml:space="preserve">
          <source>Layout::borrow_mut</source>
          <target state="translated">Layout::borrow_mut</target>
        </trans-unit>
        <trans-unit id="e98c55355125dbd6a52d2480ae5f678bafc47354" translate="yes" xml:space="preserve">
          <source>Layout::clone</source>
          <target state="translated">Layout::clone</target>
        </trans-unit>
        <trans-unit id="2687d55f8151ff4e3d3dfd56105fc50d005dbef6" translate="yes" xml:space="preserve">
          <source>Layout::clone_from</source>
          <target state="translated">Layout::clone_from</target>
        </trans-unit>
        <trans-unit id="d247f8af0b3641c1febfca5a66104f7e6cd7ae07" translate="yes" xml:space="preserve">
          <source>Layout::clone_into</source>
          <target state="translated">Layout::clone_into</target>
        </trans-unit>
        <trans-unit id="28c4c39a207293b5ac856dadaca01591e69acdf2" translate="yes" xml:space="preserve">
          <source>Layout::eq</source>
          <target state="translated">Layout::eq</target>
        </trans-unit>
        <trans-unit id="807fbd84446164c635ef92d05b4f032e4e469c63" translate="yes" xml:space="preserve">
          <source>Layout::extend</source>
          <target state="translated">Layout::extend</target>
        </trans-unit>
        <trans-unit id="8a66e95e85ef65243dad3fec906d59a444e63307" translate="yes" xml:space="preserve">
          <source>Layout::extend_packed</source>
          <target state="translated">Layout::extend_packed</target>
        </trans-unit>
        <trans-unit id="ebdf1907153114cac58ba5ec846d319f09e3c275" translate="yes" xml:space="preserve">
          <source>Layout::fmt</source>
          <target state="translated">Layout::fmt</target>
        </trans-unit>
        <trans-unit id="aab6fc5da3370994e8eb6ae5619aeb20b2942b01" translate="yes" xml:space="preserve">
          <source>Layout::for_value</source>
          <target state="translated">Layout::for_value</target>
        </trans-unit>
        <trans-unit id="804e6daf71de8cbddc2847d4efac40f08b730f12" translate="yes" xml:space="preserve">
          <source>Layout::from</source>
          <target state="translated">Layout::from</target>
        </trans-unit>
        <trans-unit id="9c52da202dbc1e86eb154e999a408fd8e5fbffba" translate="yes" xml:space="preserve">
          <source>Layout::from_size_align</source>
          <target state="translated">Layout::from_size_align</target>
        </trans-unit>
        <trans-unit id="97f7ac20412edfee9be62fc236598951052b803a" translate="yes" xml:space="preserve">
          <source>Layout::from_size_align_unchecked</source>
          <target state="translated">Layout::from_size_align_unchecked</target>
        </trans-unit>
        <trans-unit id="9cb8530d3128b6bd4c274c8e7e0e34f2f70b863a" translate="yes" xml:space="preserve">
          <source>Layout::into</source>
          <target state="translated">Layout::into</target>
        </trans-unit>
        <trans-unit id="e888b6d02ea4794c5fef327a295c976cc60f99e3" translate="yes" xml:space="preserve">
          <source>Layout::ne</source>
          <target state="translated">Layout::ne</target>
        </trans-unit>
        <trans-unit id="f8038f15aebe6dce4d4de95b3c13e472d2b02064" translate="yes" xml:space="preserve">
          <source>Layout::new</source>
          <target state="translated">Layout::new</target>
        </trans-unit>
        <trans-unit id="c67933e7b53ec19707602158f0983ec3386107e4" translate="yes" xml:space="preserve">
          <source>Layout::pad_to_align</source>
          <target state="translated">Layout::pad_to_align</target>
        </trans-unit>
        <trans-unit id="fb534b2d9180d9c41c85be4f3cc7a5e10900d871" translate="yes" xml:space="preserve">
          <source>Layout::padding_needed_for</source>
          <target state="translated">Layout::padding_needed_for</target>
        </trans-unit>
        <trans-unit id="a53e256b922777e3d8b52ed41502d58861453b8a" translate="yes" xml:space="preserve">
          <source>Layout::repeat</source>
          <target state="translated">Layout::repeat</target>
        </trans-unit>
        <trans-unit id="ac76fcd730f9145d3ef5771a73793f24557f189a" translate="yes" xml:space="preserve">
          <source>Layout::repeat_packed</source>
          <target state="translated">Layout::repeat_packed</target>
        </trans-unit>
        <trans-unit id="39b88a7f119bc78ddb9f4adea7781765100ba7de" translate="yes" xml:space="preserve">
          <source>Layout::size</source>
          <target state="translated">Layout::size</target>
        </trans-unit>
        <trans-unit id="4fc54c6aa1d00c912811a3198ba6c26a31cb141d" translate="yes" xml:space="preserve">
          <source>Layout::to_owned</source>
          <target state="translated">Layout::to_owned</target>
        </trans-unit>
        <trans-unit id="ec3e4dd97b8bdfbb69e8e8a4fe407933742763da" translate="yes" xml:space="preserve">
          <source>Layout::try_from</source>
          <target state="translated">Layout::try_from</target>
        </trans-unit>
        <trans-unit id="e7254c8b2c904f17a579a6512de1c3f53903e338" translate="yes" xml:space="preserve">
          <source>Layout::try_into</source>
          <target state="translated">Layout::try_into</target>
        </trans-unit>
        <trans-unit id="69613b626753f65b515ca28b5fe4fd7436a0a88d" translate="yes" xml:space="preserve">
          <source>Layout::type_id</source>
          <target state="translated">Layout::type_id</target>
        </trans-unit>
        <trans-unit id="6b15514a909ca7b027740ad8a4c4fe6fbfdeead1" translate="yes" xml:space="preserve">
          <source>LayoutErr</source>
          <target state="translated">LayoutErr</target>
        </trans-unit>
        <trans-unit id="18ae5986925972906df162748403c4571a3bd382" translate="yes" xml:space="preserve">
          <source>LayoutErr::borrow</source>
          <target state="translated">LayoutErr::borrow</target>
        </trans-unit>
        <trans-unit id="92579002fabcdb4525eb6353397c1fc960583290" translate="yes" xml:space="preserve">
          <source>LayoutErr::borrow_mut</source>
          <target state="translated">LayoutErr::borrow_mut</target>
        </trans-unit>
        <trans-unit id="1c9995b499c2000f5ea89f003f69988ad4d9295a" translate="yes" xml:space="preserve">
          <source>LayoutErr::cause</source>
          <target state="translated">LayoutErr::cause</target>
        </trans-unit>
        <trans-unit id="8694453e9f4b16d83cc25ab2975ab170ff1ad8c9" translate="yes" xml:space="preserve">
          <source>LayoutErr::clone</source>
          <target state="translated">LayoutErr::clone</target>
        </trans-unit>
        <trans-unit id="b630e1b5713feb7087721a06315e5b984a418a6f" translate="yes" xml:space="preserve">
          <source>LayoutErr::clone_from</source>
          <target state="translated">LayoutErr::clone_from</target>
        </trans-unit>
        <trans-unit id="c42cb73e4c87ec15d8bccdf73bd650c9df417b9b" translate="yes" xml:space="preserve">
          <source>LayoutErr::clone_into</source>
          <target state="translated">LayoutErr::clone_into</target>
        </trans-unit>
        <trans-unit id="3d5c517ec7fe54611274ae766b7e9a7911dc4865" translate="yes" xml:space="preserve">
          <source>LayoutErr::description</source>
          <target state="translated">LayoutErr::description</target>
        </trans-unit>
        <trans-unit id="497868f6f797da1325f8a9e9334379ca52fe4d37" translate="yes" xml:space="preserve">
          <source>LayoutErr::eq</source>
          <target state="translated">LayoutErr::eq</target>
        </trans-unit>
        <trans-unit id="3e42ce22d91446434898d46efd3223372301d536" translate="yes" xml:space="preserve">
          <source>LayoutErr::fmt</source>
          <target state="translated">LayoutErr::fmt</target>
        </trans-unit>
        <trans-unit id="73c4ad8234e8ca96453bac67aff91d0248f854d8" translate="yes" xml:space="preserve">
          <source>LayoutErr::from</source>
          <target state="translated">LayoutErr::from</target>
        </trans-unit>
        <trans-unit id="c3349dca57dd20451bc1fb01674dae961d63e9ce" translate="yes" xml:space="preserve">
          <source>LayoutErr::into</source>
          <target state="translated">LayoutErr::into</target>
        </trans-unit>
        <trans-unit id="f0f74e1ec8093e352aa9e8a3fd380fef9597b057" translate="yes" xml:space="preserve">
          <source>LayoutErr::ne</source>
          <target state="translated">LayoutErr::ne</target>
        </trans-unit>
        <trans-unit id="13438de55c63f100651925816f56012c5f1b1197" translate="yes" xml:space="preserve">
          <source>LayoutErr::source</source>
          <target state="translated">LayoutErr::source</target>
        </trans-unit>
        <trans-unit id="3bbdcbefa6e28507c6b0c6c634c7c7dc826a8bf4" translate="yes" xml:space="preserve">
          <source>LayoutErr::to_owned</source>
          <target state="translated">LayoutErr::to_owned</target>
        </trans-unit>
        <trans-unit id="2ec834ea6aa3644afac64a7ad23be1e1d6c10755" translate="yes" xml:space="preserve">
          <source>LayoutErr::to_string</source>
          <target state="translated">LayoutErr::to_string</target>
        </trans-unit>
        <trans-unit id="569d09cda7ad780d06bfd86cc93c53c21d1d507f" translate="yes" xml:space="preserve">
          <source>LayoutErr::try_from</source>
          <target state="translated">LayoutErr::try_from</target>
        </trans-unit>
        <trans-unit id="da95ddd29b8a42941df811e96eda4d3f3b529f15" translate="yes" xml:space="preserve">
          <source>LayoutErr::try_into</source>
          <target state="translated">LayoutErr::try_into</target>
        </trans-unit>
        <trans-unit id="b157e123211e4f6e633b31e52c5a1dcb6f18cc93" translate="yes" xml:space="preserve">
          <source>LayoutErr::type_id</source>
          <target state="translated">LayoutErr::type_id</target>
        </trans-unit>
        <trans-unit id="882d7824546e260d7aecb582ca23a9e9525d35d8" translate="yes" xml:space="preserve">
          <source>Laziness</source>
          <target state="translated">Laziness</target>
        </trans-unit>
        <trans-unit id="1a855a2a58b53f62fc3df50bb4fbd170d6d9104f" translate="yes" xml:space="preserve">
          <source>Lazy boolean operators</source>
          <target state="translated">게으른 부울 연산자</target>
        </trans-unit>
        <trans-unit id="7e80f065af51812290038b5aef5b515381e7b069" translate="yes" xml:space="preserve">
          <source>Lazy values and one-time initialization of static data.</source>
          <target state="translated">지연 값 및 정적 데이터의 일회성 초기화.</target>
        </trans-unit>
        <trans-unit id="e07edacb2555a09c495279c3384f36a675435d8d" translate="yes" xml:space="preserve">
          <source>Le</source>
          <target state="translated">Le</target>
        </trans-unit>
        <trans-unit id="5c517a3f3609c8f91e1addb0b08b45eb552a8056" translate="yes" xml:space="preserve">
          <source>Leading and trailing whitespace represent an error.</source>
          <target state="translated">선행 및 후행 공백은 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="171d90f8bc7e44b38d039153f89d2f57be6e9170" translate="yes" xml:space="preserve">
          <source>Leak an I/O object, never closing the file:</source>
          <target state="translated">파일을 닫지 않고 I / O 객체를 누출시킵니다.</target>
        </trans-unit>
        <trans-unit id="0c87712acc6d428c2446529002e5d51f0d06f2b8" translate="yes" xml:space="preserve">
          <source>Leaks of memory and other resources</source>
          <target state="translated">기억과 다른 자원의 누수</target>
        </trans-unit>
        <trans-unit id="4a0f6a000e4abc155c2355349886b493447a871e" translate="yes" xml:space="preserve">
          <source>Learn a bit about TCP and HTTP.</source>
          <target state="translated">TCP 및 HTTP에 대해 조금 배우십시오.</target>
        </trans-unit>
        <trans-unit id="3b3bf48bce1a18fd95b7ca358e1f16b46d7a4f20" translate="yes" xml:space="preserve">
          <source>Learn more in the &lt;a href=&quot;reference/attributes#conditional-compilation&quot;&gt;Conditional Compilation&lt;/a&gt; section of the Reference.</source>
          <target state="translated">참조 의 &lt;a href=&quot;reference/attributes#conditional-compilation&quot;&gt;조건부 컴파일&lt;/a&gt; 섹션 에서 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="aee627fb00174e09c28a9f8c4feb833b6e5f743c" translate="yes" xml:space="preserve">
          <source>Leaves the original &lt;code&gt;Option&lt;/code&gt; in-place, creating a new one containing a mutable reference to the inner type's &lt;code&gt;Deref::Target&lt;/code&gt; type.</source>
          <target state="translated">원래 &lt;code&gt;Option&lt;/code&gt; 을 제자리에두고 내부 유형의 &lt;code&gt;Deref::Target&lt;/code&gt; 유형에 대한 변경 가능한 참조를 포함하는 새 옵션 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="d7cf535c3451fcfd6307510b8776e34c835efbed" translate="yes" xml:space="preserve">
          <source>Leaves the original Option in-place, creating a new one with a reference to the original one, additionally coercing the contents via &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">원래 옵션을 제자리에두고 원래 옵션에 대한 참조가있는 새 옵션을 만들고 &lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; 를 통해 콘텐츠를 추가로 강제합니다 .</target>
        </trans-unit>
        <trans-unit id="c2c694f6b8cb7b00330c4d48a5ced6de4ae07bc6" translate="yes" xml:space="preserve">
          <source>Leaves the original Option in-place, creating a new one with a reference to the original one, additionally coercing the contents via &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">원본 옵션을 그대로두고 원본 옵션을 참조하여 새 옵션을 만들고 &lt;code&gt;Deref&lt;/code&gt; 를 통해 내용을 추가로 강제합니다 .</target>
        </trans-unit>
        <trans-unit id="fbc8d1a601145e0b8a0f4e2783062a13702a5915" translate="yes" xml:space="preserve">
          <source>Leaves the original Result in-place, creating a new one with a reference to the original one, additionally coercing both the &lt;code&gt;Ok&lt;/code&gt; and &lt;code&gt;Err&lt;/code&gt; arms of the Result via &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">원래 결과를 제자리에두고 원래 결과를 참조하여 새 결과를 &lt;code&gt;Deref&lt;/code&gt; 를 통해 결과 의 &lt;code&gt;Ok&lt;/code&gt; 및 &lt;code&gt;Err&lt;/code&gt; 팔을 추가로 강제합니다 .</target>
        </trans-unit>
        <trans-unit id="35c9a587594a401fda69e05b935e4d8b2ac65ada" translate="yes" xml:space="preserve">
          <source>Leaves the original Result in-place, creating a new one with a reference to the original one, additionally coercing the &lt;code&gt;Err&lt;/code&gt; arm of the Result via &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">원래 결과를 제자리에 남겨두고 원래 결과를 참조하여 새 결과를 &lt;code&gt;Deref&lt;/code&gt; 를 통해 결과 의 &lt;code&gt;Err&lt;/code&gt; 팔을 추가로 강제합니다 .</target>
        </trans-unit>
        <trans-unit id="50d3f8b919eb6aee8c76227d9ffbe9d9e4ef3631" translate="yes" xml:space="preserve">
          <source>Leaves the original Result in-place, creating a new one with a reference to the original one, additionally coercing the &lt;code&gt;Ok&lt;/code&gt; arm of the Result via &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">원래 결과를 제자리에 남겨두고 원래 결과를 참조하여 새 결과를 &lt;code&gt;Deref&lt;/code&gt; 를 통해 결과 의 &lt;code&gt;Ok&lt;/code&gt; 암을 추가로 강제합니다 .</target>
        </trans-unit>
        <trans-unit id="494064e70529e54389ad678d759801779c5c72df" translate="yes" xml:space="preserve">
          <source>Left Shift</source>
          <target state="translated">왼쪽 시프트</target>
        </trans-unit>
        <trans-unit id="357a167cfbb492462507b9b8569ac04e39500116" translate="yes" xml:space="preserve">
          <source>Left operand in &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; expressions.</source>
          <target state="translated">&lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;배열 인덱싱&lt;/a&gt; 표현식 에서 왼쪽 피연산자입니다 .</target>
        </trans-unit>
        <trans-unit id="802deb5f6a24f0153e1b52a743d60aef22ab93a7" translate="yes" xml:space="preserve">
          <source>Left operand in &lt;a href=&quot;expressions/call-expr&quot;&gt;call expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expressions/call-expr&quot;&gt;호출 표현식&lt;/a&gt; 에서 왼쪽 피연산자 .</target>
        </trans-unit>
        <trans-unit id="3463667b7fa2b91f4f33b26ea8c6945778008832" translate="yes" xml:space="preserve">
          <source>Left operand in &lt;a href=&quot;expressions/field-expr&quot;&gt;field&lt;/a&gt; expressions.</source>
          <target state="translated">&lt;a href=&quot;expressions/field-expr&quot;&gt;필드&lt;/a&gt; 표현식 에서 왼쪽 피연산자</target>
        </trans-unit>
        <trans-unit id="604e7ca527ffc17876e5a83a46e96dfa0fc8df57" translate="yes" xml:space="preserve">
          <source>Left operand in &lt;a href=&quot;expressions/method-call-expr&quot;&gt;method-call&lt;/a&gt; expressions.</source>
          <target state="translated">&lt;a href=&quot;expressions/method-call-expr&quot;&gt;메소드 호출&lt;/a&gt; 표현식 에서 왼쪽 피연산자</target>
        </trans-unit>
        <trans-unit id="eb226dadb2d69601a2e88f0aff30921d841ff9e2" translate="yes" xml:space="preserve">
          <source>Left operands of the &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;compound assignment&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;복합 할당&lt;/a&gt; 의 왼쪽 피연산자 .</target>
        </trans-unit>
        <trans-unit id="c80da6a471da3578e154404c086273e1a0815411" translate="yes" xml:space="preserve">
          <source>Left-shift</source>
          <target state="translated">Left-shift</target>
        </trans-unit>
        <trans-unit id="b5ac21daa5921e49b42d9ee7f63e24eef4f4e0f5" translate="yes" xml:space="preserve">
          <source>Left-shift and assignment</source>
          <target state="translated">왼쪽 교대와 과제</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="1d3d412a0852cc56c28ad0c2a1153229aa365b43" translate="yes" xml:space="preserve">
          <source>Less than</source>
          <target state="translated">이하</target>
        </trans-unit>
        <trans-unit id="2dd999a5f745b11640e747579b45ca334f6bd164" translate="yes" xml:space="preserve">
          <source>Less than comparison</source>
          <target state="translated">비교 미만</target>
        </trans-unit>
        <trans-unit id="33331a5bba7154831ad991e3d73f2368d8a52f4d" translate="yes" xml:space="preserve">
          <source>Less than or equal to</source>
          <target state="translated">이하</target>
        </trans-unit>
        <trans-unit id="4c0c7f8feba1a3be504536a32e6253de66037beb" translate="yes" xml:space="preserve">
          <source>Less than or equal to comparison</source>
          <target state="translated">비교 이하</target>
        </trans-unit>
        <trans-unit id="2bf9b5b6040aab2674d9953c9b7c713583f20dae" translate="yes" xml:space="preserve">
          <source>Less-than comparison for two &lt;code&gt;Arc&lt;/code&gt;s.</source>
          <target state="translated">두 &lt;code&gt;Arc&lt;/code&gt; 대한 비교보다 적습니다 .</target>
        </trans-unit>
        <trans-unit id="e86e08a482dea944d87e01c7d1358debb5cc8f8f" translate="yes" xml:space="preserve">
          <source>Less-than comparison for two &lt;code&gt;Rc&lt;/code&gt;s.</source>
          <target state="translated">두 &lt;code&gt;Rc&lt;/code&gt; 에 대한 비교보다 적습니다 .</target>
        </trans-unit>
        <trans-unit id="023a23666ee1826dd775c67ffcc792722addcad9" translate="yes" xml:space="preserve">
          <source>Let ALPHA_SET(M) = FIRST(&lt;code&gt;&amp;alpha;&lt;/code&gt;) if OP = &lt;code&gt;\*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; and ALPHA_SET(M) = {} if OP = &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">OP = &lt;code&gt;\*&lt;/code&gt; 또는 &lt;code&gt;?&lt;/code&gt; 인 경우 ALPHA_SET (M) = FIRST ( &lt;code&gt;&amp;alpha;&lt;/code&gt; ) 및 ALPHA_SET (M) = {} = 경우 OP &lt;code&gt;+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c00ee374b6dc82a14932bb4fd3e12ef63fb5d55f" translate="yes" xml:space="preserve">
          <source>Let SEP_SET(M) = { SEP } if SEP is present and &amp;epsilon; &amp;isin; FIRST(&lt;code&gt;tt ...&lt;/code&gt;); otherwise SEP_SET(M) = {}.</source>
          <target state="translated">SEP가 존재하고 &amp;epsilon; &amp;isin; FIRST ( &lt;code&gt;tt ...&lt;/code&gt; ) 이면 SEP_SET (M) = {SEP} ; 그렇지 않으면 SEP_SET (M) = {}입니다.</target>
        </trans-unit>
        <trans-unit id="53530264e4da661c5ecd3e262365a6de39f515ea" translate="yes" xml:space="preserve">
          <source>Let sep_set = { SEP } if SEP present; otherwise sep_set = {}.</source>
          <target state="translated">SEP가 존재하면 sep_set = {SEP}로 설정하십시오. 그렇지 않으면 sep_set = {}.</target>
        </trans-unit>
        <trans-unit id="911e3ff1d34feb7b7cd623e6d1a6a2dd2992b8d3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add another test, but this time we&amp;rsquo;ll make a test that fails! Tests fail when something in the test function panics. Each test is run in a new thread, and when the main thread sees that a test thread has died, the test is marked as failed. We talked about the simplest way to cause a panic in Chapter 9, which is to call the &lt;code&gt;panic!&lt;/code&gt; macro. Enter the new test, &lt;code&gt;another&lt;/code&gt;, so your &lt;em&gt;src/lib.rs&lt;/em&gt; file looks like Listing 11-3.</source>
          <target state="translated">다른 테스트를 추가해 봅시다. 이번에는 실패한 테스트를하겠습니다! 테스트 기능에 문제가있는 경우 테스트가 실패합니다. 각 테스트는 새 스레드에서 실행되며 기본 스레드에서 테스트 스레드가 종료 된 것으로 확인되면 테스트가 실패한 것으로 표시됩니다. 9 장에서 공황을 일으키는 가장 간단한 방법에 대해 이야기했습니다 &lt;code&gt;panic!&lt;/code&gt; 매크로. 새로운 테스트를 입력, &lt;code&gt;another&lt;/code&gt; , 당신 때문에 &lt;em&gt;SRC / lib.rs&lt;/em&gt; 11-3 목록과 같은 파일 모습을.</target>
        </trans-unit>
        <trans-unit id="862ded2868716c0b1f9c7eb816092a939af7bcb0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s address the second error, which points to the code at the end of &lt;code&gt;Worker::new&lt;/code&gt;; we need to wrap the &lt;code&gt;thread&lt;/code&gt; value in &lt;code&gt;Some&lt;/code&gt; when we create a new &lt;code&gt;Worker&lt;/code&gt;. Make the following changes to fix this error:</source>
          <target state="translated">&lt;code&gt;Worker::new&lt;/code&gt; 끝에있는 코드를 가리키는 두 번째 오류를 해결해 봅시다 . 새 &lt;code&gt;Worker&lt;/code&gt; 를 만들 때 &lt;code&gt;thread&lt;/code&gt; 값을 &lt;code&gt;Some&lt;/code&gt; 에 래핑해야합니다 . 이 오류를 수정하려면 다음을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="2f2efb01063714d86b5480ed1b824b067b1a031d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s address these four problems by refactoring our project.</source>
          <target state="translated">프로젝트를 리팩토링하여이 네 가지 문제를 해결해 봅시다.</target>
        </trans-unit>
        <trans-unit id="533040ac56d9f1aa4e4c0e2a9a9719c3755f6d7a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s also make the &lt;code&gt;add_to_waitlist&lt;/code&gt; function public by adding the &lt;code&gt;pub&lt;/code&gt; keyword before its definition, as in Listing 7-7.</source>
          <target state="translated">Listing 7-7에서와 같이 정의 앞에 &lt;code&gt;pub&lt;/code&gt; 키워드를 추가 하여 &lt;code&gt;add_to_waitlist&lt;/code&gt; 함수를 public으로 만들어 보자 .</target>
        </trans-unit>
        <trans-unit id="ea4a0f30216adf2bf51b73cd6dbecc829205bb86" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s apply the first rule: each parameter gets its own lifetime. This time we have two parameters instead of one, so we have two lifetimes:</source>
          <target state="translated">첫 번째 규칙을 적용 해 봅시다. 각 매개 변수는 고유 한 수명을 갖습니다. 이번에는 하나가 아닌 두 개의 매개 변수가 있으므로 두 개의 수명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bfaeb7ed44c7ba50fa8b27070055c189f55db1b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s break down the &lt;code&gt;match&lt;/code&gt; in the &lt;code&gt;value_in_cents&lt;/code&gt; function. First, we list the &lt;code&gt;match&lt;/code&gt; keyword followed by an expression, which in this case is the value &lt;code&gt;coin&lt;/code&gt;. This seems very similar to an expression used with &lt;code&gt;if&lt;/code&gt;, but there&amp;rsquo;s a big difference: with &lt;code&gt;if&lt;/code&gt;, the expression needs to return a Boolean value, but here, it can be any type. The type of &lt;code&gt;coin&lt;/code&gt; in this example is the &lt;code&gt;Coin&lt;/code&gt; enum that we defined on line 1.</source>
          <target state="translated">&lt;code&gt;value_in_cents&lt;/code&gt; 함수 에서 &lt;code&gt;match&lt;/code&gt; 을 분류합시다 . 먼저 &lt;code&gt;match&lt;/code&gt; 키워드와 표현식 (이 경우 값 &lt;code&gt;coin&lt;/code&gt; ) 이 나열 됩니다. 이것은 &lt;code&gt;if&lt;/code&gt; 와 함께 사용되는 표현식과 매우 비슷해 보이지만 큰 차이가 있습니다. &lt;code&gt;if&lt;/code&gt; 와 함께 표현식은 부울 값을 반환해야하지만 여기서는 모든 유형이 될 수 있습니다. 이 예에서 &lt;code&gt;coin&lt;/code&gt; 의 유형은 1 행에서 정의한 &lt;code&gt;Coin&lt;/code&gt; 열거 형입니다.</target>
        </trans-unit>
        <trans-unit id="f56b403e93973d8ea8cf3d0611a5804ed42ec21f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s break down this request data to understand what the browser is asking of our program.</source>
          <target state="translated">이 요청 데이터를 분석하여 브라우저가 프로그램에 요구하는 내용을 이해하십시오.</target>
        </trans-unit>
        <trans-unit id="b36a5ce769815370ab06336595b70e1c5c477b25" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s briefly look at the syntax of specifying generic type parameters, trait bounds, and lifetimes all in one function!</source>
          <target state="translated">하나의 함수에서 제네릭 형식 매개 변수, 특성 범위 및 수명을 지정하는 구문을 간단히 살펴 보겠습니다!</target>
        </trans-unit>
        <trans-unit id="0b5fe379df9523f20646a85915698650e52f567f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s build a smart pointer similar to the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; type provided by the standard library to experience how smart pointers behave differently from references by default. Then we&amp;rsquo;ll look at how to add the ability to use the dereference operator.</source>
          <target state="translated">스마트 라이브러리가 기본적으로 참조와 다르게 동작하는 방법을 경험하기 위해 표준 라이브러리에서 제공 하는 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 유형 과 유사한 스마트 포인터를 작성해 봅시다 . 그런 다음 역 참조 연산자를 사용하는 기능을 추가하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="a51f4557e798f86ab9a943604a40558633731ed7" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s build the workspace by running &lt;code&gt;cargo build&lt;/code&gt; in the top-level &lt;em&gt;add&lt;/em&gt; directory!</source>
          <target state="translated">최상위 레벨 &lt;em&gt;추가&lt;/em&gt; 디렉토리 에서 &lt;code&gt;cargo build&lt;/code&gt; 를 실행하여 작업 공간을 구축합시다 !&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5f04507c41a7a28beafb3cead61fdadb3dea0a6f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s call a function that returns a &lt;code&gt;Result&lt;/code&gt; value because the function could fail. In Listing 9-3 we try to open a file.</source>
          <target state="translated">함수가 실패 할 수 있기 때문에 &lt;code&gt;Result&lt;/code&gt; 값 을 반환하는 함수를 호출 해 봅시다 . Listing 9-3에서 파일을 열려고한다.</target>
        </trans-unit>
        <trans-unit id="a513da811ee53d6a1f83cac6544789f14693ebd9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change our working example in Listing 15-18 so we can see the reference counts changing as we create and drop references to the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Listing 15-18에서 작업 예제를 변경하여 a에서 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 에 &lt;code&gt;a&lt;/code&gt; 참조를 작성하고 삭제함에 따라 참조 횟수가 변경되는 것을 확인할 수 있다 .</target>
        </trans-unit>
        <trans-unit id="13b7e2a02ac5f6f1d6e7771973bf7e4e8630f77c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change the &lt;code&gt;area&lt;/code&gt; function that has a &lt;code&gt;Rectangle&lt;/code&gt; instance as a parameter and instead make an &lt;code&gt;area&lt;/code&gt; method defined on the &lt;code&gt;Rectangle&lt;/code&gt; struct, as shown in Listing 5-13.</source>
          <target state="translated">&lt;code&gt;Rectangle&lt;/code&gt; 인스턴스를 매개 변수로하는 &lt;code&gt;area&lt;/code&gt; 함수를 변경 하고 대신 &lt;code&gt;Rectangle&lt;/code&gt; 구조체 에 정의 된 &lt;code&gt;area&lt;/code&gt; 메소드 를 작성합니다 ( 목록 5-13 참조).</target>
        </trans-unit>
        <trans-unit id="a1f781d100edd0654c8707256174d0183b82ca21" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change the name of our test to see how that changes the test output. Change the &lt;code&gt;it_works&lt;/code&gt; function to a different name, such as &lt;code&gt;exploration&lt;/code&gt;, like so:</source>
          <target state="translated">테스트 이름을 변경하여 테스트 결과가 어떻게 바뀌는 지 봅시다. &lt;code&gt;it_works&lt;/code&gt; 함수를 &lt;code&gt;exploration&lt;/code&gt; 과 같은 다른 이름으로 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="e085a2cf9e4bfbccd609eb67b047befe0756bfad" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s check that it passes!</source>
          <target state="translated">통과하는지 확인합시다!</target>
        </trans-unit>
        <trans-unit id="6e6584addded7d162e25546426216dd008dbd0f0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s check the code again:</source>
          <target state="translated">코드를 다시 확인하자 :</target>
        </trans-unit>
        <trans-unit id="58ec20357926eeae9e87a4ac077cb4fc985ca821" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s combine the knowledge you learned in this chapter and in previous chapters to work on a project!</source>
          <target state="translated">이 장과 이전 장에서 배운 지식을 결합하여 프로젝트를 수행해 봅시다!</target>
        </trans-unit>
        <trans-unit id="7729d445e0c4aa723c02605775741a07569ce3c0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider the first part of &lt;code&gt;main&lt;/code&gt; in Listing 17-11:</source>
          <target state="translated">Listing 17-11에서 &lt;code&gt;main&lt;/code&gt; 의 첫 번째 부분을 살펴 보자 .</target>
        </trans-unit>
        <trans-unit id="9bd7feb2aa1c163d92ba2edc07ccaeec3f556691" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a crate named &lt;code&gt;hello_macro&lt;/code&gt; that defines a trait named &lt;code&gt;HelloMacro&lt;/code&gt; with one associated function named &lt;code&gt;hello_macro&lt;/code&gt;. Rather than making our crate users implement the &lt;code&gt;HelloMacro&lt;/code&gt; trait for each of their types, we&amp;rsquo;ll provide a procedural macro so users can annotate their type with &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; to get a default implementation of the &lt;code&gt;hello_macro&lt;/code&gt; function. The default implementation will print &lt;code&gt;Hello, Macro! My name is TypeName!&lt;/code&gt; where &lt;code&gt;TypeName&lt;/code&gt; is the name of the type on which this trait has been defined. In other words, we&amp;rsquo;ll write a crate that enables another programmer to write code like Listing 19-30 using our crate.</source>
          <target state="translated">하자라는 이름의 상자 만들 &lt;code&gt;hello_macro&lt;/code&gt; 을 정의하는 특성 이름이 &lt;code&gt;HelloMacro&lt;/code&gt; 일 개 관련 기능의 이름으로 &lt;code&gt;hello_macro&lt;/code&gt; . 상자 사용자 가 각 유형에 대해 &lt;code&gt;HelloMacro&lt;/code&gt; 특성을 구현하지 않고 절차 매크로를 제공하여 사용자가 &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; 로 유형에 주석을 달아 &lt;code&gt;hello_macro&lt;/code&gt; 함수 의 기본 구현을 얻을 수 있습니다. 기본 구현은 &lt;code&gt;Hello, Macro! My name is TypeName!&lt;/code&gt; 여기서 &lt;code&gt;TypeName&lt;/code&gt; 은이 특성이 정의 된 유형의 이름입니다. 다시 말해, 다른 프로그래머가 상자를 사용하여 Listing 19-30과 같은 코드를 작성할 수있는 상자를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="9e2142a26e44f4e6756b16f8090c68fc06e7085b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a new library project called &lt;code&gt;adder&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;adder&lt;/code&gt; 라는 새로운 라이브러리 프로젝트를 만들어 봅시다 :</target>
        </trans-unit>
        <trans-unit id="9c7399eee11ccb14463b23d58e457c71508e98d8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a new project using Cargo and look at how it differs from our original &amp;ldquo;Hello, world!&amp;rdquo; project. Navigate back to your &lt;em&gt;projects&lt;/em&gt; directory (or wherever you decided to store your code). Then, on any operating system, run the following:</source>
          <target state="translated">Cargo를 사용하여 새 프로젝트를 만들고 원래 &quot;Hello, world!&quot;와 어떻게 다른지 살펴 보겠습니다. 계획. &lt;em&gt;프로젝트&lt;/em&gt; 디렉토리 (또는 코드를 저장하기로 결정한 위치)로 다시 이동 합니다. 그런 다음 모든 운영 체제에서 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="41d473890aa102e1a8805b09a6342b2b1e9d3dd1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a new project using Cargo and look at how it differs from our original Hello, world! project. Navigate back to your &lt;em&gt;projects&lt;/em&gt; directory (or wherever you decided to store your code). Then, on any operating system, run the following:</source>
          <target state="translated">Cargo를 사용하여 새 프로젝트를 만들고 원래 Hello, world와 어떻게 다른지 살펴 봅시다! 계획. &lt;em&gt;프로젝트&lt;/em&gt; 디렉토리 (또는 코드를 저장하기로 결정한 곳)로 다시 이동 하십시오. 그런 다음 모든 운영 체제에서 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="74b1a7e7740baca8e782bfd3b97f4ca92299f7fa" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a new project with, as always, &lt;code&gt;cargo new&lt;/code&gt;. We&amp;rsquo;ll call our project &lt;code&gt;minigrep&lt;/code&gt; to distinguish it from the &lt;code&gt;grep&lt;/code&gt; tool that you might already have on your system.</source>
          <target state="translated">의는 항상 새 프로젝트, 만들어 보자 &lt;code&gt;cargo new&lt;/code&gt; . 우리는 프로젝트 &lt;code&gt;minigrep&lt;/code&gt; 을 호출 하여 시스템에 이미있는 &lt;code&gt;grep&lt;/code&gt; 도구 와 구별합니다 .</target>
        </trans-unit>
        <trans-unit id="7498e03400c34fc782316cecb8cfae701609c72c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create an integration test. With the code in Listing 11-12 still in the &lt;em&gt;src/lib.rs&lt;/em&gt; file, make a &lt;em&gt;tests&lt;/em&gt; directory, create a new file named &lt;em&gt;tests/integration_test.rs&lt;/em&gt;, and enter the code in Listing 11-13.</source>
          <target state="translated">통합 테스트를 만들어 봅시다. Listing 11-12의 코드가 여전히 &lt;em&gt;src / lib.rs&lt;/em&gt; 파일에있는 상태에서 &lt;em&gt;tests&lt;/em&gt; 디렉토리를 만들고 &lt;em&gt;tests / integration_test.rs&lt;/em&gt; 라는 새 파일을 작성한 후 Listing 11-13에 코드를 입력한다.</target>
        </trans-unit>
        <trans-unit id="76a754330b004eb7ac6a2d3134c0ac997e30ee22" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s dig into the details of a dynamically sized type called &lt;code&gt;str&lt;/code&gt;, which we&amp;rsquo;ve been using throughout the book. That&amp;rsquo;s right, not &lt;code&gt;&amp;amp;str&lt;/code&gt;, but &lt;code&gt;str&lt;/code&gt; on its own, is a DST. We can&amp;rsquo;t know how long the string is until runtime, meaning we can&amp;rsquo;t create a variable of type &lt;code&gt;str&lt;/code&gt;, nor can we take an argument of type &lt;code&gt;str&lt;/code&gt;. Consider the following code, which does not work:</source>
          <target state="translated">책 전체에서 사용했던 &lt;code&gt;str&lt;/code&gt; 이라는 동적 크기 유형의 세부 사항을 살펴 보겠습니다 . 맞습니다. &lt;code&gt;&amp;amp;str&lt;/code&gt; 이 아니라 &lt;code&gt;str&lt;/code&gt; 자체가 DST입니다. 우리는 우리가 형의 변수를 만들 수 없습니다 의미 문자열이 런타임 때까지 얼마나 오래 알 수 &lt;code&gt;str&lt;/code&gt; ,도 우리는 형의 인수를 취할 수 &lt;code&gt;str&lt;/code&gt; . 작동하지 않는 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="135058566e52c47af5c9c244e255bc4ce73db5f0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s dive in!</source>
          <target state="translated">뛰어 들자!</target>
        </trans-unit>
        <trans-unit id="5ea067197cecc0dcafe00ab16ce7bc41edb2cce3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s examine the difference between the two concepts with an example from Chapter 13 that implements the &lt;code&gt;Iterator&lt;/code&gt; trait on the &lt;code&gt;Counter&lt;/code&gt; struct. In Listing 13-21, we specified that the &lt;code&gt;Item&lt;/code&gt; type was &lt;code&gt;u32&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Counter&lt;/code&gt; 구조체 에 &lt;code&gt;Iterator&lt;/code&gt; 특성 을 구현하는 13 장의 예제를 통해 두 개념의 차이점을 살펴 보겠습니다 . Listing 13-21에서 우리는 &lt;code&gt;Item&lt;/code&gt; 타입이 &lt;code&gt;u32&lt;/code&gt; 임을 명시했다 .</target>
        </trans-unit>
        <trans-unit id="51c8e9031bf91446f9115b59a4810cccd5e08ba7" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s examine the first execution of &lt;code&gt;plus_one&lt;/code&gt; in more detail. When we call &lt;code&gt;plus_one(five)&lt;/code&gt;, the variable &lt;code&gt;x&lt;/code&gt; in the body of &lt;code&gt;plus_one&lt;/code&gt; will have the value &lt;code&gt;Some(5)&lt;/code&gt;. We then compare that against each match arm.</source>
          <target state="translated">&lt;code&gt;plus_one&lt;/code&gt; 의 첫 번째 실행에 대해 자세히 살펴 보겠습니다. 우리가 호출하면 &lt;code&gt;plus_one(five)&lt;/code&gt; 의 변수 &lt;code&gt;x&lt;/code&gt; 의 몸에 &lt;code&gt;plus_one&lt;/code&gt; 는 값이됩니다 &lt;code&gt;Some(5)&lt;/code&gt; . 그런 다음 각 경기 암과 비교합니다.</target>
        </trans-unit>
        <trans-unit id="6e71d1e8c50827371eaf73f583536f9bfaf50c55" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s explore the &lt;em&gt;cons list&lt;/em&gt;, which is a data type common in functional programming languages, as an example of a recursive type. The cons list type we&amp;rsquo;ll define is straightforward except for the recursion; therefore, the concepts in the example we&amp;rsquo;ll work with will be useful any time you get into more complex situations involving recursive types.</source>
          <target state="translated">재귀 유형의 예로 함수형 프로그래밍 언어에서 공통적 인 데이터 유형 인 &lt;em&gt;cons list를&lt;/em&gt; 살펴 보겠습니다 . 우리가 정의 할 단점 목록 유형은 재귀를 제외하고 간단합니다. 따라서 우리가 다루게 될 예제의 개념은 재귀 유형과 관련된 더 복잡한 상황에 처할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8dd4037a982ed3562f2f33f83b29e377988c8c74" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s explore this concept by looking at the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type that follows the interior mutability pattern.</source>
          <target state="translated">내부 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 패턴을 따르는 RefCell &amp;lt;T&amp;gt; 유형을 살펴보면서이 개념을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="33abe13cd0e5ac2dde5cfd9e196411eace5691ef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s figure this out by simplifying the program. Instead of making 10 threads in a &lt;code&gt;for&lt;/code&gt; loop, let&amp;rsquo;s just make two threads without a loop and see what happens. Replace the first &lt;code&gt;for&lt;/code&gt; loop in Listing 16-13 with this code instead:</source>
          <target state="translated">프로그램을 단순화하여 이것을 알아 봅시다. &lt;code&gt;for&lt;/code&gt; 루프 에서 10 개의 스레드를 만드는 대신 루프없이 두 개의 스레드를 만들고 결과를 확인하십시오. Listing 16-13 의 첫 번째 &lt;code&gt;for&lt;/code&gt; 루프를이 코드로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="f074800650aafbfc4673a0db2d7d24603b94e675" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s finally implement the &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt;. We&amp;rsquo;ll also change &lt;code&gt;Job&lt;/code&gt; from a struct to a type alias for a trait object that holds the type of closure that &lt;code&gt;execute&lt;/code&gt; receives. As discussed in the &lt;a href=&quot;ch19-04-advanced-types#creating-type-synonyms-with-type-aliases&quot;&gt;&amp;ldquo;Creating Type Synonyms with Type Aliases&amp;rdquo;&lt;/a&gt; section of Chapter 19, type aliases allow us to make long types shorter. Look at Listing 20-19.</source>
          <target state="translated">마지막 으로 &lt;code&gt;ThreadPool&lt;/code&gt; 에 &lt;code&gt;execute&lt;/code&gt; 메소드를 구현해 봅시다 . 우리는 또한 변경할 수 있습니다 &lt;code&gt;Job&lt;/code&gt; 폐쇄의 유형을 유지하는 특성 개체의 유형 별칭 구조체에서 &lt;code&gt;execute&lt;/code&gt; 수신합니다. 19 장의 &lt;a href=&quot;ch19-04-advanced-types#creating-type-synonyms-with-type-aliases&quot;&gt;&quot;유형 별명으로 유형 동의어 작성&quot;&lt;/a&gt; 섹션 에서 논의한 것처럼 , 유형 별명을 사용하면 긴 유형을 더 짧게 만들 수 있습니다. Listing 20-19를보십시오.</target>
        </trans-unit>
        <trans-unit id="8d1bc217cc494100da333abaf87d765e4a86b4ca" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s first look at how the dereference operator works with regular references. Then we&amp;rsquo;ll try to define a custom type that behaves like &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, and see why the dereference operator doesn&amp;rsquo;t work like a reference on our newly defined type. We&amp;rsquo;ll explore how implementing the &lt;code&gt;Deref&lt;/code&gt; trait makes it possible for smart pointers to work in a similar way as references. Then we&amp;rsquo;ll look at Rust&amp;rsquo;s &lt;em&gt;deref coercion&lt;/em&gt; feature and how it lets us work with either references or smart pointers.</source>
          <target state="translated">먼저 역 참조 연산자가 정규 참조와 작동하는 방식을 살펴 보겠습니다. 그런 다음 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 와 같이 작동하는 사용자 정의 유형을 정의하려고 시도 하고 역 참조 연산자가 새로 정의 된 유형에 대한 참조처럼 작동하지 않는 이유를 확인합니다. &lt;code&gt;Deref&lt;/code&gt; 특성을 구현하여 스마트 포인터가 참조와 유사한 방식으로 작동 하는 방법을 살펴 보겠습니다 . 그런 다음 Rust의 역 참조 &lt;em&gt;강제&lt;/em&gt; 기능과 참조 또는 스마트 포인터로 작업하는 방법을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="16b3f7c211345e679774caea38315635e0c83e2f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s first look at how the dereference operator works with regular references. Then we&amp;rsquo;ll try to define a custom type that behaves like &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, and see why the dereference operator doesn&amp;rsquo;t work like a reference on our newly defined type. We&amp;rsquo;ll explore how implementing the &lt;code&gt;Deref&lt;/code&gt; trait makes it possible for smart pointers to work in ways similar to references. Then we&amp;rsquo;ll look at Rust&amp;rsquo;s &lt;em&gt;deref coercion&lt;/em&gt; feature and how it lets us work with either references or smart pointers.</source>
          <target state="translated">먼저 역 참조 연산자가 일반 참조와 함께 작동하는 방식을 살펴 보겠습니다. 그런 다음 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 처럼 동작하는 사용자 지정 형식을 정의 하고 역 참조 연산자가 새로 정의 된 형식에 대한 참조처럼 작동하지 않는 이유를 확인합니다. &lt;code&gt;Deref&lt;/code&gt; 트레이 트를 구현하여 스마트 포인터가 참조와 유사한 방식으로 작동하는 방법을 살펴 보겠습니다 . 그런 다음 Rust의 &lt;em&gt;deref 강제&lt;/em&gt; 기능을 살펴보고 어떻게 참조 또는 스마트 포인터로 작업 할 수 있는지 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="5282924b8e4ccd503b1b10249bbf09058e192d22" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get started on the implementation of the library! We know we need a public &lt;code&gt;Post&lt;/code&gt; struct that holds some content, so we&amp;rsquo;ll start with the definition of the struct and an associated public &lt;code&gt;new&lt;/code&gt; function to create an instance of &lt;code&gt;Post&lt;/code&gt;, as shown in Listing 17-12. We&amp;rsquo;ll also make a private &lt;code&gt;State&lt;/code&gt; trait. Then &lt;code&gt;Post&lt;/code&gt; will hold a trait object of &lt;code&gt;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt; inside an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; in a private field named &lt;code&gt;state&lt;/code&gt;. You&amp;rsquo;ll see why the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is necessary in a bit.</source>
          <target state="translated">라이브러리 구현을 시작합시다! 컨텐츠를 보유한 public &lt;code&gt;Post&lt;/code&gt; 구조체 가 필요하다는 것을 알고 있으므로 Listing 17-12에 표시된 것처럼 구조체 정의와 관련 public &lt;code&gt;new&lt;/code&gt; 함수를 사용하여 &lt;code&gt;Post&lt;/code&gt; 인스턴스를 생성한다 . 우리는 또한 개인 &lt;code&gt;State&lt;/code&gt; 특성을 만들 것 입니다. 그러면 &lt;code&gt;Post&lt;/code&gt; 는 &lt;code&gt;state&lt;/code&gt; 라는 개인 필드 의 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 안에 &lt;code&gt;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt; 의 특성 오브젝트를 보유합니다 . &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 가 왜 필요한지 알게 될 것 입니다.</target>
        </trans-unit>
        <trans-unit id="6cf0779362e5e6e79905eb41dbbcf314ec8be6ec" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give it a try! First, we&amp;rsquo;ll run our program without the environment variable set and with the query &lt;code&gt;to&lt;/code&gt;, which should match any line that contains the word &amp;ldquo;to&amp;rdquo; in all lowercase:</source>
          <target state="translated">한번 해보자! 먼저 환경 변수를 설정하지 않고 query &lt;code&gt;to&lt;/code&gt; 로 프로그램을 실행 합니다.이 단어는 &quot;to&quot;라는 단어가 모두 포함 된 모든 줄과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="e21e94e46417f5d70be1f74cdc80a0200cf7ab38" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s imagine that a friend of ours is trying to collect all 50 state quarters. While we sort our loose change by coin type, we&amp;rsquo;ll also call out the name of the state associated with each quarter so if it&amp;rsquo;s one our friend doesn&amp;rsquo;t have, they can add it to their collection.</source>
          <target state="translated">우리 친구가 50 개 주 분기를 모두 모 으려고한다고 가정 해 봅시다. 코인 유형별로 느슨한 변경 사항을 정렬하는 동안 각 분기와 관련된 주 이름을 호출하므로 친구가없는 경우 컬렉션에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d46ead76362decf8ea1c4631f151578daeb7b13e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s implement the functionality for returning more than a blank page. Create a new file, &lt;em&gt;hello.html&lt;/em&gt;, in the root of your project directory, not in the &lt;em&gt;src&lt;/em&gt; directory. You can input any HTML you want; Listing 20-4 shows one possibility.</source>
          <target state="translated">빈 페이지 이상을 반환하는 기능을 구현해 봅시다. &lt;em&gt;src&lt;/em&gt; 디렉토리가 아닌 프로젝트 디렉토리의 루트에 &lt;em&gt;hello.html&lt;/em&gt; 파일을 새로 작성하십시오 . 원하는 HTML을 입력 할 수 있습니다. Listing 20-4는 한 가지 가능성을 보여준다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="875e251ee421cd235e0091a3ea3fc8e405d04cfd" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s implement the functionality to read the request from the browser! To separate the concerns of first getting a connection and then taking some action with the connection, we&amp;rsquo;ll start a new function for processing connections. In this new &lt;code&gt;handle_connection&lt;/code&gt; function, we&amp;rsquo;ll read data from the TCP stream and print it so we can see the data being sent from the browser. Change the code to look like Listing 20-2.</source>
          <target state="translated">브라우저에서 요청을 읽는 기능을 구현합시다! 먼저 연결을 얻은 다음 연결로 조치를 취해야하는 문제를 분리하기 위해 연결 처리를위한 새로운 기능을 시작합니다. 이 새로운 &lt;code&gt;handle_connection&lt;/code&gt; 함수에서는 TCP 스트림에서 데이터를 읽고 인쇄하여 브라우저에서 전송되는 데이터를 볼 수 있습니다. Listing 20-2와 같이 코드를 변경한다.</target>
        </trans-unit>
        <trans-unit id="b145c020f35d5cf12c1f16d9ae23adffafb9cf49" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s introduce a bug into our code to see what it looks like when a test that uses &lt;code&gt;assert_eq!&lt;/code&gt; fails. Change the implementation of the &lt;code&gt;add_two&lt;/code&gt; function to instead add &lt;code&gt;3&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;assert_eq!&lt;/code&gt; 를 사용하는 테스트에서 어떻게 보이는지 확인하기 위해 코드에 버그를 도입하자 ! 실패합니다. &lt;code&gt;add_two&lt;/code&gt; 함수 의 구현을 &lt;code&gt;3&lt;/code&gt; 대신에 추가하도록 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a740028676c8b0002977c98fe2eec37d0bee51d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s introduce a bug into this code by changing &lt;code&gt;greeting&lt;/code&gt; to not include &lt;code&gt;name&lt;/code&gt; to see what this test failure looks like:</source>
          <target state="translated">&lt;code&gt;greeting&lt;/code&gt; 에 &lt;code&gt;name&lt;/code&gt; 을 포함하지 않도록 이 테스트 실패의 모양 을 변경하여이 코드에 버그를 도입 해 보겠습니다</target>
        </trans-unit>
        <trans-unit id="19083fee6a8cc87ffd6b0d04bb94a51935ddddce" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s jump into Rust by working through a hands-on project together! This chapter introduces you to a few common Rust concepts by showing you how to use them in a real program. You&amp;rsquo;ll learn about &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;match&lt;/code&gt;, methods, associated functions, using external crates, and more! The following chapters will explore these ideas in more detail. In this chapter, you&amp;rsquo;ll practice the fundamentals.</source>
          <target state="translated">실습 프로젝트를 함께 진행하여 Rust로 뛰어 갑시다! 이 장에서는 실제 프로그램에서 사용하는 방법을 보여줌으로써 몇 가지 일반적인 Rust 개념을 소개합니다. &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;match&lt;/code&gt; , 메소드, 관련 함수, 외부 상자 사용 등에 대해 배웁니다 ! 다음 장에서는 이러한 아이디어에 대해 자세히 설명합니다. 이 장에서는 기본 사항을 연습합니다.</target>
        </trans-unit>
        <trans-unit id="63819f186c88b0330ee047bed09e478063cb1dae" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a situation we might want to express in code and see why enums are useful and more appropriate than structs in this case. Say we need to work with IP addresses. Currently, two major standards are used for IP addresses: version four and version six. These are the only possibilities for an IP address that our program will come across: we can &lt;em&gt;enumerate&lt;/em&gt; all possible values, which is where enumeration gets its name.</source>
          <target state="translated">코드로 표현하고 싶은 상황을 살펴보고이 경우에 열거 형이 구조체보다 유용하고 더 적합한 이유를 살펴 보겠습니다. IP 주소로 작업해야한다고 가정 해보십시오. 현재 IP 주소에는 버전 4와 버전 6의 두 가지 주요 표준이 사용됩니다. 이것들은 우리 프로그램이 접할 수있는 IP 주소에 대한 유일한 가능성 입니다. 열거가 이름을 얻는 모든 가능한 값을 &lt;em&gt;열거&lt;/em&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="983a8ae99cfeef9a151c58849d32ffe20aab79f5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a situation we might want to express in code and see why enums are useful and more appropriate than structs in this case. Say we need to work with IP addresses. Currently, two major standards are used for IP addresses: version four and version six. These are the only possibilities for an IP address that our program will come across: we can &lt;em&gt;enumerate&lt;/em&gt; all possible variants, which is where enumeration gets its name.</source>
          <target state="translated">코드로 표현하고 싶은 상황을 살펴보고이 경우에 열거 형이 구조체보다 유용하고 더 적절한 이유를 살펴 보겠습니다. IP 주소로 작업해야한다고 가정 해 보겠습니다. 현재 IP 주소에는 버전 4와 버전 6의 두 가지 주요 표준이 사용됩니다. 이것들은 우리 프로그램이 보게 될 IP 주소에 대한 유일한 가능성 입니다. 열거가 그 이름을 얻는 모든 가능한 변형을 &lt;em&gt;열거&lt;/em&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b455b737e0cc051701700c07362ed0b4be96ade0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example of what happens when we try to use a refutable pattern where Rust requires an irrefutable pattern and vice versa. Listing 18-8 shows a &lt;code&gt;let&lt;/code&gt; statement, but for the pattern we&amp;rsquo;ve specified &lt;code&gt;Some(x)&lt;/code&gt;, a refutable pattern. As you might expect, this code will not compile.</source>
          <target state="translated">Rust가 반박 할 수없는 패턴을 요구하고 그 반대의 경우에도 반박 할 수있는 패턴을 사용하려고 할 때 어떤 일이 발생하는지에 대한 예를 보자. Listing 18-8은 &lt;code&gt;let&lt;/code&gt; 문을 보여 주지만 패턴 에 대해 반박 가능한 패턴 &lt;code&gt;Some(x)&lt;/code&gt; 지정했다 . 예상 한대로이 코드는 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18ece25ab1e94beac903ba47f460140cd6525deb" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at another enum in the standard library that is very common and useful: &lt;code&gt;Option&lt;/code&gt;.</source>
          <target state="translated">매우 일반적이고 유용한 표준 라이브러리의 다른 열거 형을 살펴 보겠습니다. &lt;code&gt;Option&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c5a86e48ba4d029ee5e559b44f91369e39297f3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at another example of an enum in Listing 6-2: this one has a wide variety of types embedded in its variants.</source>
          <target state="translated">Listing 6-2에서 열거 형의 또 다른 예를 살펴 보자.이 형식에는 변형에 포함 된 다양한 유형이있다.</target>
        </trans-unit>
        <trans-unit id="eb252b4c369cd56d53d91f13fd045947d1bc97a2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at another example to see what it&amp;rsquo;s like when a &lt;code&gt;panic!&lt;/code&gt; call comes from a library because of a bug in our code instead of from our code calling the macro directly. Listing 9-1 has some code that attempts to access an element by index in a vector.</source>
          <target state="translated">&lt;code&gt;panic!&lt;/code&gt; 어떤지보기 위해 다른 예를 살펴 보자 ! 매크로를 직접 호출하는 코드가 아니라 코드의 버그로 인해 라이브러리에서 호출이 발생합니다. Listing 9-1에는 벡터의 인덱스로 요소에 액세스를 시도하는 코드가있다.</target>
        </trans-unit>
        <trans-unit id="6282a087fac47a7a9f015495370791f1a001baba" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at another example, this time using the &lt;code&gt;longest&lt;/code&gt; function that had no lifetime parameters when we started working with it in Listing 10-21:</source>
          <target state="translated">이번에 는 Listing 10-21에서 작업을 시작할 때 수명 매개 변수가없는 &lt;code&gt;longest&lt;/code&gt; 기능을 사용하는 또 다른 예를 살펴 보자 .</target>
        </trans-unit>
        <trans-unit id="79d263a7d612b559cee379001fac98bd72d76b84" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at another example:</source>
          <target state="translated">다른 예를 보자.</target>
        </trans-unit>
        <trans-unit id="4d45845f16951bf95eef2bf35703a5d1765d659f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at each of the five unsafe superpowers in turn. We&amp;rsquo;ll also look at some abstractions that provide a safe interface to unsafe code.</source>
          <target state="translated">5 개의 안전하지 않은 초강대국을 차례로 살펴 보겠습니다. 또한 안전하지 않은 코드에 대한 안전한 인터페이스를 제공하는 몇 가지 추상화도 살펴볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="2e8b25580ad4eac065cdf4b9269d34a342f40133" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at each of the four unsafe superpowers in turn. We&amp;rsquo;ll also look at some abstractions that provide a safe interface to unsafe code.</source>
          <target state="translated">안전하지 않은 4 가지 초강대국을 차례로 살펴 보자. 또한 안전하지 않은 코드에 안전한 인터페이스를 제공하는 몇 가지 추상화를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="df2bdcb8a48c5ab6b335860afc48b8bc078015c4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at how a reference cycle might happen and how to prevent it, starting with the definition of the &lt;code&gt;List&lt;/code&gt; enum and a &lt;code&gt;tail&lt;/code&gt; method in Listing 15-25:</source>
          <target state="translated">Listing 15-25 의 &lt;code&gt;List&lt;/code&gt; 열거 형과 &lt;code&gt;tail&lt;/code&gt; 메소드 의 정의부터 시작하여 참조주기가 어떻게 발생하고 방지하는지 살펴 보자.</target>
        </trans-unit>
        <trans-unit id="0944037c3cfba2d633f74e95d90cd2030445a3ef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at how the &lt;code&gt;strong_count&lt;/code&gt; and &lt;code&gt;weak_count&lt;/code&gt; values of the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; instances change by creating a new inner scope and moving the creation of &lt;code&gt;branch&lt;/code&gt; into that scope. By doing so, we can see what happens when &lt;code&gt;branch&lt;/code&gt; is created and then dropped when it goes out of scope. The modifications are shown in Listing 15-29:</source>
          <target state="translated">새로운 내부 범위를 만들고 &lt;code&gt;branch&lt;/code&gt; 생성 을 해당 범위로 이동하여 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 인스턴스 의 &lt;code&gt;strong_count&lt;/code&gt; 및 &lt;code&gt;weak_count&lt;/code&gt; 값이 어떻게 변경되는지 살펴 보겠습니다 . 이렇게하면 &lt;code&gt;branch&lt;/code&gt; 가 만들어지고 범위를 벗어나면 삭제 될 때 발생하는 상황을 확인할 수 있습니다 . 수정 사항은 목록 15-29에 표시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cefbc5ea6d98c6566c78f52ee80e603c9ecbe131" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at how the lifetime annotations restrict the &lt;code&gt;longest&lt;/code&gt; function by passing in references that have different concrete lifetimes. Listing 10-23 is a straightforward example.</source>
          <target state="translated">구체적인 수명이 다른 참조를 전달 하여 수명 주석이 &lt;code&gt;longest&lt;/code&gt; 기능을 제한하는 방법을 살펴 보겠습니다 . Listing 10-23은 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="2d907807641db37c8b548f8e680fff80ec47014d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at how this works with an example that uses the standard library&amp;rsquo;s &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum:</source>
          <target state="translated">표준 라이브러리의 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 열거 형 을 사용하는 예제에서 이것이 어떻게 작동하는지 봅시다 :</target>
        </trans-unit>
        <trans-unit id="017d18fbfa7c60f454e03eabc7d8ac1aa92c2937" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at the different kinds of procedural macros. We&amp;rsquo;ll start with a custom derive macro and then explain the small dissimilarities that make the other forms different.</source>
          <target state="translated">서로 다른 종류의 절차 적 매크로를 살펴 보겠습니다. 우리는 커스텀 파생 매크로로 시작한 다음 다른 형태를 다르게 만드는 작은 차이를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="47696a65864265aca3d18b3b28f87964618b9312" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at the features Rust provides specifically for writing tests that take these actions, which include the &lt;code&gt;test&lt;/code&gt; attribute, a few macros, and the &lt;code&gt;should_panic&lt;/code&gt; attribute.</source>
          <target state="translated">Rust가 &lt;code&gt;test&lt;/code&gt; 속성, 몇 가지 매크로 및 &lt;code&gt;should_panic&lt;/code&gt; 속성 을 포함하여 이러한 작업을 수행하는 테스트 작성을 위해 특별히 제공하는 기능을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="3a9e9db94ec59c60082aa0b5bcf4f78e81ff1885" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at what happens if we use the &lt;code&gt;?&lt;/code&gt; operator in the &lt;code&gt;main&lt;/code&gt; function, which you&amp;rsquo;ll recall has a return type of &lt;code&gt;()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; 를 사용하면 어떻게되는지 봅시다 . 당신이 기억할 &lt;code&gt;main&lt;/code&gt; 함수의 연산자 는 반환 유형이 &lt;code&gt;()&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="994a941f48d3bb1b233dbddd0cea3be0ad22a0a6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s make a new binary project with Cargo called &lt;em&gt;rectangles&lt;/em&gt; that will take the width and height of a rectangle specified in pixels and calculate the area of the rectangle. Listing 5-8 shows a short program with one way of doing exactly that in our project&amp;rsquo;s &lt;em&gt;src/main.rs&lt;/em&gt;.</source>
          <target state="translated">의 카고와 새로운 바이너리 프로젝트라고 만들어 보자 &lt;em&gt;사각형&lt;/em&gt; 픽셀로 지정되는 구형의 폭과 높이를 가지고 직사각형의 면적을 계산합니다. 리스트 5-8은 프로젝트의 &lt;em&gt;src / main.rs&lt;/em&gt; 에서 정확히 수행하는 한 가지 방법으로 간단한 프로그램을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="c3c6a3325302ea36dd5b079af7f9dcc2a96f2a1b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s make the following changes to what happens when we create a &lt;code&gt;ThreadPool&lt;/code&gt;. We&amp;rsquo;ll implement the code that sends the closure to the thread after we have &lt;code&gt;Worker&lt;/code&gt; set up in this way:</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; 을 만들 때 발생하는 사항을 다음과 같이 변경해 봅시다 . &lt;code&gt;Worker&lt;/code&gt; 다음과 같이 설정 한 후 클로저를 스레드로 보내는 코드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="d6f3986ccdbd0c969d703b2cf489c2df505e5f38" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move all the code that isn&amp;rsquo;t the &lt;code&gt;main&lt;/code&gt; function from &lt;em&gt;src/main.rs&lt;/em&gt; to &lt;em&gt;src/lib.rs&lt;/em&gt;:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 기능 이 아닌 모든 코드를 &lt;em&gt;src / main.rs&lt;/em&gt; 에서 &lt;em&gt;src / lib.rs로 옮깁니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e0993d86e241fd6659cd1a45b6773ecb8b7a697f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move on and talk about the module system!</source>
          <target state="translated">계속해서 모듈 시스템에 대해 이야기합시다!</target>
        </trans-unit>
        <trans-unit id="a8ee98777403910d66295d417b2df29ea314fb29" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move the transmitting end into a spawned thread and have it send one string so the spawned thread is communicating with the main thread, as shown in Listing 16-7. This is like putting a rubber duck in the river upstream or sending a chat message from one thread to another.</source>
          <target state="translated">전송 엔드를 생성 된 스레드로 옮기고 생성 된 스레드가 메인 스레드와 통신하도록 하나의 문자열을 보내도록한다 (Listing 16-7 참조). 이것은 고무 오리를 강 상류에 두거나 한 스레드에서 다른 스레드로 채팅 메시지를 보내는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d7bc5a1faae0876b47946a48ddda878ed24b40e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s practice using methods by implementing a second method on the &lt;code&gt;Rectangle&lt;/code&gt; struct. This time, we want an instance of &lt;code&gt;Rectangle&lt;/code&gt; to take another instance of &lt;code&gt;Rectangle&lt;/code&gt; and return &lt;code&gt;true&lt;/code&gt; if the second &lt;code&gt;Rectangle&lt;/code&gt; can fit completely within &lt;code&gt;self&lt;/code&gt;; otherwise it should return &lt;code&gt;false&lt;/code&gt;. That is, we want to be able to write the program shown in Listing 5-14, once we&amp;rsquo;ve defined the &lt;code&gt;can_hold&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;Rectangle&lt;/code&gt; 구조체 에 두 번째 메서드를 구현하여 메서드를 사용하여 연습 해 봅시다 . 이 시간, 우리의 인스턴스 원하는 &lt;code&gt;Rectangle&lt;/code&gt; 의 또 다른 예를 취할 &lt;code&gt;Rectangle&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; 두 번째 경우 &lt;code&gt;Rectangle&lt;/code&gt; 안에 완전히 들어갈 수있는 &lt;code&gt;self&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환해야합니다 . 즉, 일단 &lt;code&gt;can_hold&lt;/code&gt; 메소드를 정의하면 Listing 5-14에 표시된 프로그램을 작성할 수 있기를 원한다 .</target>
        </trans-unit>
        <trans-unit id="2f6a747ae7e60532bbff7c109c117027e46d5672" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s pretend we&amp;rsquo;re the compiler. We&amp;rsquo;ll apply these rules to figure out what the lifetimes of the references in the signature of the &lt;code&gt;first_word&lt;/code&gt; function in Listing 10-26 are. The signature starts without any lifetimes associated with the references:</source>
          <target state="translated">우리가 컴파일러 인 척하자. 이 규칙을 적용 하여 Listing 10-26 의 &lt;code&gt;first_word&lt;/code&gt; 함수 시그니처에서 참조의 수명이 무엇인지 알아낼 것이다 . 서명은 참조와 관련된 수명없이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="93c702edd44f0391f6b49bca85a25bb1c08f5ed4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s program the game to quit when the user wins by adding a &lt;code&gt;break&lt;/code&gt; statement:</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 문 을 추가하여 사용자가 이길 때 게임이 종료되도록 프로그래밍합시다 :</target>
        </trans-unit>
        <trans-unit id="37e690afeb6a44a19f29feff1bce10a2708fa622" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s re-implement the counter iterator from &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;모듈 수준 문서&lt;/a&gt; 에서 카운터 반복자를 다시 구현해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="12315912398a998ea0c31348f27e33b72d707ec2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what we&amp;rsquo;ve discussed about references:</source>
          <target state="translated">참고 문헌에 대해 논의한 내용을 다시 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="28953519c0667e1646cf53e71f06f86d4e114c07" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what we&amp;rsquo;ve learned so far about Cargo:</source>
          <target state="translated">화물에 대해 지금까지 배운 내용을 다시 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="2c9a7290077df3cf275a9a0becb103de92fc4b1c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to our cons list example in Listing 15-5. Recall that we defined it using &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. This time, we&amp;rsquo;ll create two lists that both share ownership of a third list. Conceptually, this looks similar to Figure 15-3:</source>
          <target state="translated">Listing 15-5의 단점 목록 예제로 돌아가 보자. &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 사용하여 정의했음을 상기하십시오 . 이번에는 세 번째 목록의 소유권을 공유하는 두 개의 목록을 만듭니다. 개념적으로 이것은 그림 15-3과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="4d5406eb80899f442e99be52053a8af746acbb33" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to our example: &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; have the same API, so we fix our program by changing the &lt;code&gt;use&lt;/code&gt; line, the call to &lt;code&gt;new&lt;/code&gt;, and the call to &lt;code&gt;clone&lt;/code&gt;. The code in Listing 16-15 will finally compile and run:</source>
          <target state="translated">예제로 돌아가 봅시다 : &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 와 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 는 같은 API를 가지고 있습니다. 따라서 우리는 &lt;code&gt;use&lt;/code&gt; 라인, &lt;code&gt;new&lt;/code&gt; 호출 , &lt;code&gt;clone&lt;/code&gt; 호출로 프로그램을 수정합니다 . Listing 16-15의 코드는 마침내 컴파일되고 실행될 것이다 :</target>
        </trans-unit>
        <trans-unit id="38b65fe4b5d3898a7fcecb397aa7533be4bdc414" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to our workout generation app. In Listing 13-6, our code was still calling the expensive calculation closure more times than it needed to. One option to solve this issue is to save the result of the expensive closure in a variable for reuse and use the variable in each place we need the result, instead of calling the closure again. However, this method could result in a lot of repeated code.</source>
          <target state="translated">운동 생성 앱으로 돌아 갑시다. Listing 13-6에서 코드는 여전히 비싼 계산 클로저를 필요한 것보다 더 많이 호출했다. 이 문제를 해결하는 한 가지 방법은 값 비싼 클로저의 결과를 재사용 할 변수에 저장하고 클로저를 다시 호출하는 대신 결과가 필요한 각 위치에서 변수를 사용하는 것입니다. 그러나이 방법을 사용하면 코드가 많이 반복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42c033ee17d1839060442674688298fa9208193f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to the error in Listing 7-4 that told us the &lt;code&gt;hosting&lt;/code&gt; module is private. We want the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function in the parent module to have access to the &lt;code&gt;add_to_waitlist&lt;/code&gt; function in the child module, so we mark the &lt;code&gt;hosting&lt;/code&gt; module with the &lt;code&gt;pub&lt;/code&gt; keyword, as shown in Listing 7-5.</source>
          <target state="translated">&lt;code&gt;hosting&lt;/code&gt; 모듈이 비공개 라는 것을 알려주는 Listing 7-4의 오류로 돌아가 보자 . 우리는 원하는 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 의 부모 모듈의 기능은 액세스하도록 &lt;code&gt;add_to_waitlist&lt;/code&gt; 의 우리가 표시되도록 하위 모듈의 기능을 &lt;code&gt;hosting&lt;/code&gt; 와 모듈 &lt;code&gt;pub&lt;/code&gt; 키워드를 7-5 목록과 같이.</target>
        </trans-unit>
        <trans-unit id="f0f51e7669e18c0438bddca7e592dae1d7afb926" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to the example in Listing 7-1. How do we call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function? This is the same as asking, what&amp;rsquo;s the path of the &lt;code&gt;add_to_waitlist&lt;/code&gt; function? In Listing 7-3, we simplified our code a bit by removing some of the modules and functions. We&amp;rsquo;ll show two ways to call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function from a new function &lt;code&gt;eat_at_restaurant&lt;/code&gt; defined in the crate root. The &lt;code&gt;eat_at_restaurant&lt;/code&gt; function is part of our library crate&amp;rsquo;s public API, so we mark it with the &lt;code&gt;pub&lt;/code&gt; keyword. In the &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree#exposing-paths-with-the-pub-keyword&quot;&gt;&amp;rdquo;Exposing Paths with the &lt;code&gt;pub&lt;/code&gt; Keyword&amp;rdquo;&lt;/a&gt; section, we&amp;rsquo;ll go into more detail about &lt;code&gt;pub&lt;/code&gt;.</source>
          <target state="translated">Listing 7-1의 예제로 돌아가 보자. &lt;code&gt;add_to_waitlist&lt;/code&gt; 함수를 어떻게 호출 합니까? &lt;code&gt;add_to_waitlist&lt;/code&gt; 함수 의 경로는 무엇 입니까? Listing 7-3에서는 일부 모듈과 함수를 제거하여 코드를 약간 단순화했다. 상자 루트에 정의 된 새로운 함수 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 에서 &lt;code&gt;add_to_waitlist&lt;/code&gt; 함수 를 호출하는 두 가지 방법을 보여줍니다 . &lt;code&gt;eat_at_restaurant&lt;/code&gt; 우리가 함께 표시 할 수 있도록 기능, 도서관 상자의 공개 API의 일부 &lt;code&gt;pub&lt;/code&gt; 키워드. 에서 &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree#exposing-paths-with-the-pub-keyword&quot;&gt;의 &quot;과 노출 경로 &lt;/a&gt; &lt;code&gt;pub&lt;/code&gt; 키워드 ' 섹션, 우리가에 대한 세부로 갈거야 &lt;code&gt;pub&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5708c518fe3a8a47dd6a9247e9757413e4ab26a1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to the example in Listing 7-1. How do we call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function? This is the same as asking, what&amp;rsquo;s the path of the &lt;code&gt;add_to_waitlist&lt;/code&gt; function? In Listing 7-3, we simplified our code a bit by removing some of the modules and functions. We&amp;rsquo;ll show two ways to call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function from a new function &lt;code&gt;eat_at_restaurant&lt;/code&gt; defined in the crate root. The &lt;code&gt;eat_at_restaurant&lt;/code&gt; function is part of our library crate&amp;rsquo;s public API, so we mark it with the &lt;code&gt;pub&lt;/code&gt; keyword. In the &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree#exposing-paths-with-the-pub-keyword&quot;&gt;&amp;rdquo;Exposing Paths with the &lt;code&gt;pub&lt;/code&gt; Keyword&amp;rdquo;&lt;/a&gt; section, we&amp;rsquo;ll go into more detail about &lt;code&gt;pub&lt;/code&gt;. Note that this example won&amp;rsquo;t compile just yet; we&amp;rsquo;ll explain why in a bit.</source>
          <target state="translated">Listing 7-1의 예제로 돌아 갑시다. &lt;code&gt;add_to_waitlist&lt;/code&gt; 함수를 어떻게 호출 합니까? 이것은 &lt;code&gt;add_to_waitlist&lt;/code&gt; 함수 의 경로가 무엇인지 묻는 것과 같습니다 . Listing 7-3에서는 일부 모듈과 함수를 제거하여 코드를 약간 단순화했습니다. 크레이트 루트에 정의 된 새로운 함수 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 에서 &lt;code&gt;add_to_waitlist&lt;/code&gt; 함수 를 호출하는 두 가지 방법을 보여 드리겠습니다 . &lt;code&gt;eat_at_restaurant&lt;/code&gt; 우리가 함께 표시 할 수 있도록 기능, 도서관 상자의 공개 API의 일부 &lt;code&gt;pub&lt;/code&gt; 키워드. 에서 &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree#exposing-paths-with-the-pub-keyword&quot;&gt;의 &quot;과 노출 경로 &lt;/a&gt; &lt;code&gt;pub&lt;/code&gt; 키워드 ' 섹션, 우리가에 대한 세부로 갈거야 &lt;code&gt;pub&lt;/code&gt; . 이 예제는 아직 컴파일되지 않습니다. 그 이유를 잠시 후 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="477b6d3273f07c6abd6b664ce37ceef78d0f7dbb" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s return to the guessing game program. You now know that &lt;code&gt;let mut guess&lt;/code&gt; will introduce a mutable variable named &lt;code&gt;guess&lt;/code&gt;. On the other side of the equal sign (&lt;code&gt;=&lt;/code&gt;) is the value that &lt;code&gt;guess&lt;/code&gt; is bound to, which is the result of calling &lt;code&gt;String::new&lt;/code&gt;, a function that returns a new instance of a &lt;code&gt;String&lt;/code&gt;. &lt;a href=&quot;../std/string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; is a string type provided by the standard library that is a growable, UTF-8 encoded bit of text.</source>
          <target state="translated">추측 게임 프로그램으로 돌아 갑시다. 이제 &lt;code&gt;let mut guess&lt;/code&gt; 가 &lt;code&gt;guess&lt;/code&gt; 라는 가변 변수를 도입 할 것임을 알게되었습니다 . 등호의 다른 측면에서 ( &lt;code&gt;=&lt;/code&gt; ) 한 값입니다 &lt;code&gt;guess&lt;/code&gt; 호출의 결과에 바인딩, &lt;code&gt;String::new&lt;/code&gt; , 함수가 리턴의 새로운 인스턴스 &lt;code&gt;String&lt;/code&gt; . &lt;a href=&quot;../std/string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 은 표준 라이브러리에서 제공하는 확장 가능한 UTF-8 인코딩 텍스트 비트 인 문자열 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1b391440eed0071039b3e089734bb6dbffc57331" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s review in detail what just happened in your &amp;ldquo;Hello, world!&amp;rdquo; program. Here&amp;rsquo;s the first piece of the puzzle:</source>
          <target state="translated">&quot;Hello, world!&quot;에서 방금 일어난 일을 자세히 살펴 보겠습니다. 프로그램. 다음은 퍼즐의 첫 번째 조각입니다.</target>
        </trans-unit>
        <trans-unit id="4e9b8de2d5b44130b83fee9c1ecdc0d98e51930d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s review in detail what just happened in your Hello, world! program. Here&amp;rsquo;s the first piece of the puzzle:</source>
          <target state="translated">Hello, world에서 무슨 일이 있었는지 자세히 검토합시다! 프로그램. 퍼즐의 첫 번째 조각은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="158e58c1e56ad7bd97dd01d2a60cf00e419cdf7a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s run the program again with arguments that don&amp;rsquo;t cause an error but still redirect standard output to a file, like so:</source>
          <target state="translated">오류를 일으키지 않지만 여전히 표준 출력을 파일로 리디렉션하는 인수를 사용하여 프로그램을 다시 실행 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="c402a40660ac8a0f30bee1587ae0160a6f7fa3c1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s run the program now!</source>
          <target state="translated">지금 프로그램을 실행하자!</target>
        </trans-unit>
        <trans-unit id="a23620a8daca09feb45d362acea31eb531fda8ce" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s run this code with any string as the first command line argument (because we haven&amp;rsquo;t implemented the searching part yet) and the &lt;em&gt;poem.txt&lt;/em&gt; file as the second argument:</source>
          <target state="translated">검색 코드를 아직 구현하지 않았기 때문에 첫 번째 명령 줄 인수로 문자열 을 사용하고 두 번째 인수로 &lt;em&gt;poem.txt&lt;/em&gt; 파일을 사용 하여이 코드를 실행 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="a00a1c9672a401c35b2df73be4edbb0185a8d666" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say a regression is found. Good thing we had some time to test the beta release before the regression snuck into a stable release! The fix is applied to &lt;code&gt;master&lt;/code&gt;, so that nightly is fixed, and then the fix is backported to the &lt;code&gt;beta&lt;/code&gt; branch, and a new release of beta is produced:</source>
          <target state="translated">회귀가 발견되었다고 가정 해 봅시다. 회귀가 안정적인 릴리스로 들어가기 전에 베타 릴리스를 테스트 할 시간이있었습니다. 수정 프로그램은 &lt;code&gt;master&lt;/code&gt; 에 적용되어 야간에 수정 된 다음 수정 프로그램이 &lt;code&gt;beta&lt;/code&gt; 분기로 백 포트되고 새로운 베타 릴리스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="9f9ce6103baa4662da2c83f8f5cc76efdcd0525f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we want to write a function that takes an &lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; and, if there&amp;rsquo;s a value inside, adds 1 to that value. If there isn&amp;rsquo;t a value inside, the function should return the &lt;code&gt;None&lt;/code&gt; value and not attempt to perform any operations.</source>
          <target state="translated">&lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; 를 취하는 함수를 작성하고 내부에 값이 있으면 그 값에 1을 더 한다고 가정 해 봅시다 . 내부에 값이 없으면 함수는 &lt;code&gt;None&lt;/code&gt; 값을 반환하고 작업을 수행하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="2d4331831e839f96e4320b04d84f9d160c78c289" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have a variable of type &lt;code&gt;u8&lt;/code&gt; that can hold values between 0 and 255. If you try to change the variable to a value outside of that range, such as 256, &lt;em&gt;integer overflow&lt;/em&gt; will occur. Rust has some interesting rules involving this behavior. When you&amp;rsquo;re compiling in debug mode, Rust includes checks for integer overflow that cause your program to &lt;em&gt;panic&lt;/em&gt; at runtime if this behavior occurs. Rust uses the term panicking when a program exits with an error; we&amp;rsquo;ll discuss panics in more depth in the &lt;a href=&quot;ch09-01-unrecoverable-errors-with-panic&quot;&gt;&amp;ldquo;Unrecoverable Errors with &lt;code&gt;panic!&lt;/code&gt;&amp;rdquo;&lt;/a&gt; section in Chapter 9.</source>
          <target state="translated">0과 255 사이의 값을 보유 할 수있는 &lt;code&gt;u8&lt;/code&gt; 유형의 변수가 있다고 가정 합니다. 변수를 해당 범위 밖의 값 (예 : 256)으로 변경하려고하면 &lt;em&gt;정수 오버 플로우&lt;/em&gt; 가 발생합니다. Rust는이 행동과 관련된 흥미로운 규칙을 가지고 있습니다. 디버그 모드에서 컴파일 할 때 Rust에는 정수 오버플로 검사가 포함되어이 동작이 발생하면 런타임에 프로그램이 &lt;em&gt;패닉 상태&lt;/em&gt; 가됩니다. Rust는 프로그램이 오류와 함께 종료 될 때 당황이라는 용어를 사용합니다. 우리는 패닉에 대해 더 깊이 논의 할 것입니다.&lt;a href=&quot;ch09-01-unrecoverable-errors-with-panic&quot;&gt; 함께 &quot;복구 할 수없는 오류 &lt;code&gt;panic!&lt;/code&gt; &amp;rdquo;&lt;/a&gt; 섹션 9 장.</target>
        </trans-unit>
        <trans-unit id="f0e1d796103ec14a5789c6d54a9113a4a736b9aa" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see if this implementation passes the tests:</source>
          <target state="translated">이 구현이 테스트를 통과했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e75f56bc99e0b08a29707c986c241848f766cec0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see what happens when we try to implement &lt;code&gt;OutlinePrint&lt;/code&gt; on a type that doesn&amp;rsquo;t implement &lt;code&gt;Display&lt;/code&gt;, such as the &lt;code&gt;Point&lt;/code&gt; struct:</source>
          <target state="translated">&lt;code&gt;Display&lt;/code&gt; 를 구현하지 않는 유형에서 &lt;code&gt;OutlinePrint&lt;/code&gt; 를 구현하려고 할 때 어떤 일이 발생하는지 봅시다 . &lt;code&gt;Point&lt;/code&gt; 구조체 .</target>
        </trans-unit>
        <trans-unit id="c59bb772f42d6153c276f779685fbcbc51239a51" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start a new binary project named &lt;em&gt;functions&lt;/em&gt; to explore functions further. Place the &lt;code&gt;another_function&lt;/code&gt; example in &lt;em&gt;src/main.rs&lt;/em&gt; and run it. You should see the following output:</source>
          <target state="translated">&lt;em&gt;함수&lt;/em&gt; 라는 새로운 바이너리 프로젝트를 시작하여 &lt;em&gt;함수&lt;/em&gt; 를 자세히 살펴 보겠습니다. 장소 &lt;code&gt;another_function&lt;/code&gt; 의 예를 &lt;em&gt;SRC / main.rs을&lt;/em&gt; 실행하십시오. 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="97cf07881b2328430539d964be0df2b91b35c6ed" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start by creating a channel in &lt;code&gt;ThreadPool::new&lt;/code&gt; and holding the sending side in the &lt;code&gt;ThreadPool&lt;/code&gt; instance, as shown in Listing 20-16. The &lt;code&gt;Job&lt;/code&gt; struct doesn&amp;rsquo;t hold anything for now but will be the type of item we&amp;rsquo;re sending down the channel.</source>
          <target state="translated">&lt;code&gt;ThreadPool::new&lt;/code&gt; 에서 채널을 만들고 &lt;code&gt;ThreadPool&lt;/code&gt; 인스턴스 에서 전송 측을 잡고 시작합니다 ( Listing 20-16). &lt;code&gt;Job&lt;/code&gt; 구조체 지금은 아무것도 보유하지 않고 우리가 채널을 보내는 항목의 유형이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="bf13023ab8a50a9cde566fb86f6034b24ede9e80" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with implementing &lt;code&gt;Drop&lt;/code&gt; on our thread pool. When the pool is dropped, our threads should all join to make sure they finish their work. Listing 20-22 shows a first attempt at a &lt;code&gt;Drop&lt;/code&gt; implementation; this code won&amp;rsquo;t quite work yet.</source>
          <target state="translated">스레드 풀에서 &lt;code&gt;Drop&lt;/code&gt; 을 구현하는 것으로 시작하겠습니다 . 풀이 삭제되면 스레드가 모두 참여하여 작업을 완료해야합니다. 목록 20-22는 &lt;code&gt;Drop&lt;/code&gt; 구현 의 첫 번째 시도를 보여줍니다 . 이 코드는 아직 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="590a1a269af356fe7eb20ade960ec2172988f407" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with implementing &lt;code&gt;Drop&lt;/code&gt; on our thread pool. When the pool is dropped, our threads should all join to make sure they finish their work. Listing 20-23 shows a first attempt at a &lt;code&gt;Drop&lt;/code&gt; implementation; this code won&amp;rsquo;t quite work yet.</source>
          <target state="translated">스레드 풀에서 &lt;code&gt;Drop&lt;/code&gt; 을 구현하는 것으로 시작하겠습니다 . 풀이 떨어지면 스레드가 모두 연결되어 작업을 완료해야합니다. Listing 20-23은 &lt;code&gt;Drop&lt;/code&gt; 구현 . 이 코드는 아직 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="17bad3ae86bcd63a6cce044cc99494cc4fff84d4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start your Rust journey! There&amp;rsquo;s a lot to learn, but every journey starts somewhere. In this chapter, we&amp;rsquo;ll discuss:</source>
          <target state="translated">녹 여행을 시작합시다! 배울 것이 많지만 모든 여행은 어딘가에서 시작됩니다. 이 장에서는 다음에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0457bf0b3ac99ac66b1f341140a99488a66fb382" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s switch to something a bit less complex: hash maps!</source>
          <target state="translated">좀 덜 복잡한 것으로 전환 해 봅시다 : 해시 맵!</target>
        </trans-unit>
        <trans-unit id="27749ea9200d1a0f4c7054bf492ec3c0b20e784f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a closer look at exactly what&amp;rsquo;s happening at each stage of our &lt;code&gt;dangle&lt;/code&gt; code:</source>
          <target state="translated">&lt;code&gt;dangle&lt;/code&gt; 코드 의 각 단계에서 무슨 일이 일어나고 있는지 자세히 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="7d9a8307e36aca49fe8db4d93f11fe8c7cef9311" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a closer look at the function call here:</source>
          <target state="translated">함수 호출을 자세히 살펴 보자.</target>
        </trans-unit>
        <trans-unit id="9a0c63ba49eeceb9940e6cb267159151436db7f3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take advantage of this newfound modularity by doing something that would have been difficult with the old code but is easy with the new code: we&amp;rsquo;ll write some tests!</source>
          <target state="translated">이전 코드로는 어려웠지만 새 코드로는 쉬운 작업을 수행하여이 새로운 모듈 식을 활용 해 봅시다. 테스트를 작성하겠습니다!</target>
        </trans-unit>
        <trans-unit id="1e8a01207efa7ffcc3d9fbd6fc8377d0a2bd28de" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the idea of using Rust&amp;rsquo;s type system to ensure we have a valid value one step further and look at creating a custom type for validation. Recall the guessing game in Chapter 2 in which our code asked the user to guess a number between 1 and 100. We never validated that the user&amp;rsquo;s guess was between those numbers before checking it against our secret number; we only validated that the guess was positive. In this case, the consequences were not very dire: our output of &amp;ldquo;Too high&amp;rdquo; or &amp;ldquo;Too low&amp;rdquo; would still be correct. But it would be a useful enhancement to guide the user toward valid guesses and have different behavior when a user guesses a number that&amp;rsquo;s out of range versus when a user types, for example, letters instead.</source>
          <target state="translated">Rust의 유형 시스템을 사용하여 한 단계 더 유효한 가치를 보장하고 유효성 검사를위한 사용자 정의 유형을 만드는 방법을 살펴 보겠습니다. 코드가 사용자에게 1에서 100 사이의 숫자를 추측하도록 요청한 2 장의 추측 게임을 상기하십시오. 우리는 사용자의 추측이 비밀 번호와 비교하기 전에 그 숫자 사이에 있다는 것을 검증하지 않았습니다. 우리는 추측이 긍정적이라는 것을 확인했습니다. 이 경우 그 결과는 그리 심각하지 않았습니다.&amp;ldquo;너무 높음&amp;rdquo;또는&amp;ldquo;너무 낮음&amp;rdquo;에 대한 출력은 여전히 ​​정확합니다. 그러나 사용자를 올바른 추측으로 안내하고 사용자가 범위를 벗어난 숫자를 추측 할 때와 사용자가 문자를 입력 할 때와 같이 입력 할 때 다른 동작을하는 것이 유용한 향상이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="10bbc468cc51314953c3274a9c50cb0da6662c26" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s test the first part of the guessing game. Run it using &lt;code&gt;cargo run&lt;/code&gt;:</source>
          <target state="translated">추측 게임의 첫 부분을 테스트 해 봅시다. &lt;code&gt;cargo run&lt;/code&gt; 사용하여 실행 .</target>
        </trans-unit>
        <trans-unit id="5f2f9297e2dc6cf0f3bff432893229470763f14d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s think about the signature of this function:</source>
          <target state="translated">이 함수의 서명에 대해 생각해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="0e370a4cd7c7ee7160c1da9e21eeb3426aa051c8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try adding the &lt;code&gt;main&lt;/code&gt; function in Listing 15-7 to Listing 15-8 and changing it to use the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; type we&amp;rsquo;ve defined instead of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. The code in Listing 15-9 won&amp;rsquo;t compile because Rust doesn&amp;rsquo;t know how to dereference &lt;code&gt;MyBox&lt;/code&gt;.</source>
          <target state="translated">Listing 15-7 의 &lt;code&gt;main&lt;/code&gt; 함수를 Listing 15-8에 추가하고 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 대신 정의한 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 유형 을 사용하도록 변경해 보자 . Rust가 &lt;code&gt;MyBox&lt;/code&gt; 를 역 참조하는 방법을 모르기 때문에 Listing 15-9의 코드는 컴파일되지 않는다 .</target>
        </trans-unit>
        <trans-unit id="f6856c71f770128395912c9e4d84ed22f9c2d61c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try calling &lt;code&gt;panic!&lt;/code&gt; in a simple program:</source>
          <target state="translated">&lt;code&gt;panic!&lt;/code&gt; 전화를 해보자 !간단한 프로그램에서 :</target>
        </trans-unit>
        <trans-unit id="495c15a2fcdcf4917d9c1bfab9452d52f6946a12" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try changing the value of &lt;code&gt;number&lt;/code&gt; to a value that makes the condition &lt;code&gt;false&lt;/code&gt; to see what happens:</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; 의 값을 조건을 &lt;code&gt;false&lt;/code&gt; 로 만드는 값으로 변경해 봅시다 으로 어떤 일이 발생하는지 .</target>
        </trans-unit>
        <trans-unit id="7e7646ea7f3a1ac4db23658ee4f242a38dc0f2d4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try it! The &lt;code&gt;println!&lt;/code&gt; macro call will now look like &lt;code&gt;println!(&quot;rect1 is {:?}&quot;, rect1);&lt;/code&gt;. Putting the specifier &lt;code&gt;:?&lt;/code&gt; inside the curly brackets tells &lt;code&gt;println!&lt;/code&gt; we want to use an output format called &lt;code&gt;Debug&lt;/code&gt;. The &lt;code&gt;Debug&lt;/code&gt; trait enables us to print our struct in a way that is useful for developers so we can see its value while we&amp;rsquo;re debugging our code.</source>
          <target state="translated">해 봅시다! &lt;code&gt;println!&lt;/code&gt; 매크로 호출은 이제 &lt;code&gt;println!(&quot;rect1 is {:?}&quot;, rect1);&lt;/code&gt; 처럼 보일 것입니다 ! ( &quot;rect1 is {:?}&quot;, rect1); . 지정자 &lt;code&gt;:?&lt;/code&gt; 중괄호 안에 &lt;code&gt;println!&lt;/code&gt; 알려줍니다 ! &lt;code&gt;Debug&lt;/code&gt; 라는 출력 형식을 사용하려고합니다 . &lt;code&gt;Debug&lt;/code&gt; 우리를있게 특성은 우리가 우리의 코드를 디버깅하는 동안 우리는 그 값을 볼 수 있도록 개발자를위한 유용한 방법으로 우리의 구조체를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="bd95d7f3d11c94bb095fdce37f40a8188a0a9f0c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try passing a receiving end of the channel into each worker as the thread pool creates the channel. We know we want to use the receiving end in the thread that the workers spawn, so we&amp;rsquo;ll reference the &lt;code&gt;receiver&lt;/code&gt; parameter in the closure. The code in Listing 20-17 won&amp;rsquo;t quite compile yet.</source>
          <target state="translated">스레드 풀이 채널을 만들 때 채널의 수신 쪽을 각 작업자에게 전달해 봅시다. 우리는 워커가 생성하는 스레드에서 수신 끝을 사용하고 싶다는 것을 알고 있으므로 &lt;code&gt;receiver&lt;/code&gt; 참조합니다. 클로저에서 매개 변수를 . Listing 20-17의 코드는 아직 컴파일되지 않았다.</target>
        </trans-unit>
        <trans-unit id="1369c278ca19b1e056ddf12681c203bea51b902a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try running this code! Invoke &lt;code&gt;cargo run&lt;/code&gt; in the terminal and then load &lt;em&gt;127.0.0.1:7878&lt;/em&gt; in a web browser. The browser should show an error message like &amp;ldquo;Connection reset,&amp;rdquo; because the server isn&amp;rsquo;t currently sending back any data. But when you look at your terminal, you should see several messages that were printed when the browser connected to the server!</source>
          <target state="translated">이 코드를 실행 해 봅시다! 터미널에서 &lt;code&gt;cargo run&lt;/code&gt; 을 호출 한 다음 &lt;em&gt;127.0.0.1:7878&lt;/em&gt; 을로드하십시오.&lt;em&gt;&lt;/em&gt; 웹 브라우저에서. 서버가 현재 데이터를 다시 보내지 않기 때문에 브라우저에 &quot;연결 재설정&quot;과 같은 오류 메시지가 표시되어야합니다. 그러나 터미널을 보면 브라우저가 서버에 연결되었을 때 인쇄 된 몇 가지 메시지가 표시됩니다!</target>
        </trans-unit>
        <trans-unit id="b5df448e7bbf55b42cbf4762a517bb598ff93363" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try running this code. Replace the program currently in your &lt;em&gt;functions&lt;/em&gt; project&amp;rsquo;s &lt;em&gt;src/main.rs&lt;/em&gt; file with the preceding example and run it using &lt;code&gt;cargo run&lt;/code&gt;:</source>
          <target state="translated">이 코드를 실행 해 봅시다. 현재 &lt;em&gt;함수&lt;/em&gt; 프로젝트의 &lt;em&gt;src / main.rs&lt;/em&gt; 파일에있는 프로그램을 이전 예제로 &lt;em&gt;바꾸고 &lt;/em&gt; &lt;code&gt;cargo run&lt;/code&gt; 을 사용하여 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="41e20d578122ffb945b15f0ad510b73ca09a5d3f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try this code! Start the program and make a request in a web browser again. Note that we&amp;rsquo;ll still get an error page in the browser, but our program&amp;rsquo;s output in the terminal will now look similar to this:</source>
          <target state="translated">이 코드를 사용해 봅시다! 프로그램을 시작하고 웹 브라우저에서 다시 요청하십시오. 브라우저에는 여전히 오류 페이지가 표시되지만 터미널의 프로그램 출력은 이제 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="7cc97ca0df32f4fb1eb75d95da6a337fcd334535" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try to compile Listing 7-3 and find out why it won&amp;rsquo;t compile yet! The error we get is shown in Listing 7-4.</source>
          <target state="translated">Listing 7-3을 컴파일하고 아직 컴파일되지 않는 이유를 알아 보자! 우리가 얻는 오류는 Listing 7-4에 표시되어있다.</target>
        </trans-unit>
        <trans-unit id="11ff9da674c818134a4406c35f39622fa04e8cbd" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try to create a dangling reference, which Rust will prevent with a compile-time error:</source>
          <target state="translated">Rust가 컴파일 타임 오류로 방지하는 매달려있는 참조를 만들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="ad30420ec21f7046e9cdcc78a94ec41a99a4cd28" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s walk through an example of what would happen with the &lt;code&gt;match&lt;/code&gt; expression used here. Say that the user has guessed 50 and the randomly generated secret number this time is 38. When the code compares 50 to 38, the &lt;code&gt;cmp&lt;/code&gt; method will return &lt;code&gt;Ordering::Greater&lt;/code&gt;, because 50 is greater than 38. The &lt;code&gt;match&lt;/code&gt; expression gets the &lt;code&gt;Ordering::Greater&lt;/code&gt; value and starts checking each arm&amp;rsquo;s pattern. It looks at the first arm&amp;rsquo;s pattern, &lt;code&gt;Ordering::Less&lt;/code&gt;, and sees that the value &lt;code&gt;Ordering::Greater&lt;/code&gt; does not match &lt;code&gt;Ordering::Less&lt;/code&gt;, so it ignores the code in that arm and moves to the next arm. The next arm&amp;rsquo;s pattern, &lt;code&gt;Ordering::Greater&lt;/code&gt;, &lt;em&gt;does&lt;/em&gt; match &lt;code&gt;Ordering::Greater&lt;/code&gt;! The associated code in that arm will execute and print &lt;code&gt;Too big!&lt;/code&gt; to the screen. The &lt;code&gt;match&lt;/code&gt; expression ends because it has no need to look at the last arm in this scenario.</source>
          <target state="translated">여기에 사용 된 &lt;code&gt;match&lt;/code&gt; 표현식에서 발생할 수있는 예를 살펴 보겠습니다 . 사용자가 50을 추측하고 이번에는 임의로 생성 된 비밀 번호가 38이라고 가정합니다. 코드가 50과 38을 비교할 때 &lt;code&gt;cmp&lt;/code&gt; 메소드는 50이 38보다 크기 때문에 &lt;code&gt;Ordering::Greater&lt;/code&gt; 를 반환합니다 . &lt;code&gt;match&lt;/code&gt; 표현식은 &lt;code&gt;Ordering::Greater&lt;/code&gt; 값이 클수록 각 팔의 패턴을 확인하기 시작합니다. 첫 번째 팔의 패턴 인 &lt;code&gt;Ordering::Less&lt;/code&gt; 를보고 &lt;code&gt;Ordering::Greater&lt;/code&gt; 값이 &lt;code&gt;Ordering::Less&lt;/code&gt; 와 일치하지 않음을 확인 하여 해당 팔의 코드를 무시하고 다음 팔로 이동합니다. 다음 팔의 패턴은 &lt;code&gt;Ordering::Greater&lt;/code&gt; , &lt;em&gt;하지&lt;/em&gt; 매치 &lt;code&gt;Ordering::Greater&lt;/code&gt; ! 해당 팔의 관련 코드가 실행되어 &lt;code&gt;Too big!&lt;/code&gt; 화면에. &lt;code&gt;match&lt;/code&gt; 표현의 끝은이 시나리오의 마지막 팔을보고 할 필요가 없기 때문에.</target>
        </trans-unit>
        <trans-unit id="7603084911e7c02de0fffb01fc0d07271e8ab207" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s walk through what happens when the &lt;code&gt;match&lt;/code&gt; expression runs. The pattern in the first match arm doesn&amp;rsquo;t match the defined value of &lt;code&gt;x&lt;/code&gt;, so the code continues.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 표현식이 실행될 때 어떤 일이 발생하는지 살펴 보겠습니다 . 첫 번째 일치 암의 패턴이 정의 된 &lt;code&gt;x&lt;/code&gt; 값과 일치하지 않으므로 코드가 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="9dbd7c7d9a346617c48d1fe6e1ab8464dd12c2ee" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s walk through what happens when we create a package. First, we enter the command &lt;code&gt;cargo new&lt;/code&gt;:</source>
          <target state="translated">패키지를 만들 때 어떤 일이 발생하는지 살펴 보겠습니다. 먼저, 우리는 &lt;code&gt;cargo new&lt;/code&gt; 을 입력합니다 :</target>
        </trans-unit>
        <trans-unit id="85979a5d9f34f3050620ce86eda10daa14a1b88f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s work on an example of a situation in which it&amp;rsquo;s useful to store a closure to be executed later. Along the way, we&amp;rsquo;ll talk about the syntax of closures, type inference, and traits.</source>
          <target state="translated">나중에 실행할 클로저를 저장하는 것이 유용한 상황의 예를 살펴 보겠습니다. 그 과정에서 클로저 구문, 형식 유추 및 특성에 대해 이야기하겠습니다.</target>
        </trans-unit>
        <trans-unit id="dde68cf723b263931fff6274e2649443a376d09e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s work through a practical example where we can use &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; to mutate an immutable value and see why that is useful.</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용 하여 불변 값을 변경하고 그 이유가 유용한 이유를 살펴볼 수있는 실용적인 예를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="48386f6d1144155006a32871e15dfe1b9ce157fb" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s work through each step, starting with iterating through lines.</source>
          <target state="translated">라인 반복을 시작으로 각 단계를 수행해 봅시다.</target>
        </trans-unit>
        <trans-unit id="a1a52fb721ec0d05f400a261580d4ddb22293c65" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a function that returns the longer of two string slices. This function will take two string slices and return a string slice. After we&amp;rsquo;ve implemented the &lt;code&gt;longest&lt;/code&gt; function, the code in Listing 10-20 should print &lt;code&gt;The longest string is abcd&lt;/code&gt;.</source>
          <target state="translated">두 문자열 슬라이스 중 더 긴 문자열을 반환하는 함수를 작성해 봅시다. 이 함수는 두 개의 문자열 슬라이스를 사용하여 문자열 슬라이스를 반환합니다. &lt;code&gt;longest&lt;/code&gt; 함수를 구현 한 후 , 목록 10-20의 코드는 인쇄해야합니다 &lt;code&gt;The longest string is abcd&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="31701d3a630b4f1aa08c2b129407ae716eb89b88" translate="yes" xml:space="preserve">
          <source>Let's cover each of those in turn:</source>
          <target state="translated">각각을 차례로 커버합시다 :</target>
        </trans-unit>
        <trans-unit id="4c315b125c5927660bb768b8b3fda2b0a5ee7326" translate="yes" xml:space="preserve">
          <source>Let's make an iterator named &lt;code&gt;Counter&lt;/code&gt; which counts from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;5&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 에서 &lt;code&gt;5&lt;/code&gt; 까지 카운트하는 &lt;code&gt;Counter&lt;/code&gt; 라는 이름의 반복자를 만들어 봅시다 .</target>
        </trans-unit>
        <trans-unit id="6c6a4583ed007c9bb1513143277357a280135d4c" translate="yes" xml:space="preserve">
          <source>Let's start with some erroneous code examples:</source>
          <target state="translated">잘못된 코드 예제로 시작해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="de018a296a31a1ffdcd9d1c61756c91e2595cea1" translate="yes" xml:space="preserve">
          <source>Let's walk through each step of the iteration here:</source>
          <target state="translated">반복의 각 단계를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="44815d1f0973ea841fa50391ff27766e7a1e43e1" translate="yes" xml:space="preserve">
          <source>Let's write the numbers one through ten to a &lt;a href=&quot;../net/struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;../net/struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; 에&lt;/a&gt; 1부터 10까지의 숫자를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="a46a79428acd36421f88fb475bcbddfbea0e22e5" translate="yes" xml:space="preserve">
          <source>Lexical structure</source>
          <target state="translated">어휘 구조</target>
        </trans-unit>
        <trans-unit id="97ced95f3282c2304ccbd2d1176522c359d54ea9" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;../../../iter/trait.iterator#method.cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">지정된 비교 함수와 관련 하여이 &lt;a href=&quot;../../../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소를 다른 요소의 요소와 사 전적으로 비교합니다 . &lt;a href=&quot;../../../iter/trait.iterator#method.cmp_by&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d2cca5450332e424d128448475a6775439ff31f6" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;../../../iter/trait.iterator#method.partial_cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">지정된 비교 함수와 관련 하여이 &lt;a href=&quot;../../../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소를 다른 요소의 요소와 사 전적으로 비교합니다 . &lt;a href=&quot;../../../iter/trait.iterator#method.partial_cmp_by&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f0dc7378d16e255ed01aabc2a54a07e3e6629f4" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;../../../iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 &lt;a href=&quot;../../../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소 를 다른 요소와 사 전적으로 비교합니다 . &lt;a href=&quot;../../../iter/trait.iterator#method.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d55096d24feded547137c63c7a384f3c4c0f255" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;../../../iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 &lt;a href=&quot;../../../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소 를 다른 요소와 사 전적으로 비교합니다 . &lt;a href=&quot;../../../iter/trait.iterator#method.partial_cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bddaf8f2edd0c91cf260c1ac14934d6aa825ae88" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;../../iter/trait.iterator#method.cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">지정된 비교 함수와 관련 하여이 &lt;a href=&quot;../../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소를 다른 요소의 요소와 사 전적으로 비교합니다 . &lt;a href=&quot;../../iter/trait.iterator#method.cmp_by&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a76c78472395e823b945082e38bc5d303e55719" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;../../iter/trait.iterator#method.partial_cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">지정된 비교 함수와 관련 하여이 &lt;a href=&quot;../../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소를 다른 요소의 요소와 사 전적으로 비교합니다 . &lt;a href=&quot;../../iter/trait.iterator#method.partial_cmp_by&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6d126c71de93d47651f31c95e0aa450c4800fd88" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;../../iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 &lt;a href=&quot;../../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소 를 다른 요소와 사 전적으로 비교합니다 . &lt;a href=&quot;../../iter/trait.iterator#method.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="609c60c9d5603d69bbf35fffd3566a6af30afb36" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;../../iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 &lt;a href=&quot;../../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소 를 다른 요소와 사 전적으로 비교합니다 . &lt;a href=&quot;../../iter/trait.iterator#method.partial_cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="43c25090a4ef088c71ace7e293566a76c0bb25be" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;../iter/trait.iterator#method.cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">지정된 비교 함수와 관련 하여이 &lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소를 다른 요소의 요소와 사 전적으로 비교합니다 . &lt;a href=&quot;../iter/trait.iterator#method.cmp_by&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="668bd83da9d322ea78d016864c5ab95e76011dec" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;../iter/trait.iterator#method.partial_cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">지정된 비교 함수와 관련 하여이 &lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소를 다른 요소의 요소와 사 전적으로 비교합니다 . &lt;a href=&quot;../iter/trait.iterator#method.partial_cmp_by&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2bff3a67247c3882318b7f41ce97184a0411570f" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;../iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 &lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소 를 다른 요소와 사 전적으로 비교합니다 . &lt;a href=&quot;../iter/trait.iterator#method.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd5c8cdaa83d4509b191af2c71b1b48c60f72b24" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;../iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 &lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소 를 다른 요소와 사 전적으로 비교합니다 . &lt;a href=&quot;../iter/trait.iterator#method.partial_cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dcf6b114d1123581ae2c9e4273fca508b0fdbde3" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;iter/trait.iterator#method.cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">지정된 비교 함수와 관련 하여이 &lt;a href=&quot;iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소를 다른 요소의 요소와 사 전적으로 비교합니다 . &lt;a href=&quot;iter/trait.iterator#method.cmp_by&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5d4ebf62364837d04d562c736d452c744c46f6e4" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;iter/trait.iterator#method.partial_cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">지정된 비교 함수와 관련 하여이 &lt;a href=&quot;iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소를 다른 요소의 요소와 사 전적으로 비교합니다 . &lt;a href=&quot;iter/trait.iterator#method.partial_cmp_by&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3953e041c330441a75e1dfa61d597df8c7d470e" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 &lt;a href=&quot;iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소 를 다른 요소와 사 전적으로 비교합니다 . &lt;a href=&quot;iter/trait.iterator#method.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cc2ad7e98b8195217ed6030e622bceaccf34c46b" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 &lt;a href=&quot;iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소 를 다른 요소와 사 전적으로 비교합니다 . &lt;a href=&quot;iter/trait.iterator#method.partial_cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="513ec20a4e8698e9bbbff2e3985a29e06196f05c" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function.</source>
          <target state="translated">지정된 비교 함수와 관련 하여이 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소를 다른 요소의 요소와 사 전적으로 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="a2e31f29d209ae250a7a227132954b7d8fe04deb" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;trait.iterator#method.cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">지정된 비교 함수와 관련 하여이 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소를 다른 요소의 요소와 사 전적으로 비교합니다 . &lt;a href=&quot;trait.iterator#method.cmp_by&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b3f1a9e4282d09a166c49d84325b88085f57ffa" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another with respect to the specified comparison function. &lt;a href=&quot;trait.iterator#method.partial_cmp_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">지정된 비교 함수와 관련 하여이 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소를 다른 요소의 요소와 사 전적으로 비교합니다 . &lt;a href=&quot;trait.iterator#method.partial_cmp_by&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f489f2a5cd07e538c7596d152dd9c17e3db469d7" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another.</source>
          <target state="translated">이 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소 를 다른 요소와 사 전적으로 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="15c8e7753b0c8e6c7481529dc1eff5f203de8fd0" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소 를 다른 요소와 사 전적으로 비교합니다 . &lt;a href=&quot;trait.iterator#method.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="39c64287527264c710512a6ae1c3417e504fcde8" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; with those of another. &lt;a href=&quot;trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 요소 를 다른 요소와 사 전적으로 비교합니다 . &lt;a href=&quot;trait.iterator#method.partial_cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f22f0e1553138efb51680148ef1747ad26c97982" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another.</source>
          <target state="translated">사 전적으로이 &lt;code&gt;Iterator&lt;/code&gt; 의 요소 를 다른 반복자 와 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="d38859ceb7b6303a207032995bde9d03c3feea29" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;../../../iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">사 전적으로이 &lt;code&gt;Iterator&lt;/code&gt; 의 요소 를 다른 반복자 와 비교합니다 . &lt;a href=&quot;../../../iter/trait.iterator#method.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ca4735197429808d0efeb2b253fe9bcfce18fe50" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;../../../iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">사 전적으로이 &lt;code&gt;Iterator&lt;/code&gt; 의 요소 를 다른 반복자 와 비교합니다 . &lt;a href=&quot;../../../iter/trait.iterator#method.partial_cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da9611fc3a83516ea2471a2bc5512aa400680e0d" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;../../iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">사 전적으로이 &lt;code&gt;Iterator&lt;/code&gt; 의 요소 를 다른 반복자 와 비교합니다 . &lt;a href=&quot;../../iter/trait.iterator#method.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="baa7a6a1172224029d4ace92b0dcc42af5ea43dc" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;../../iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">사 전적으로이 &lt;code&gt;Iterator&lt;/code&gt; 의 요소 를 다른 반복자 와 비교합니다 . &lt;a href=&quot;../../iter/trait.iterator#method.partial_cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df2d601aaa116406a1d3ed2d19ce7ccb8eda9f6d" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;../iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">사 전적으로이 &lt;code&gt;Iterator&lt;/code&gt; 의 요소 를 다른 반복자 와 비교합니다 . &lt;a href=&quot;../iter/trait.iterator#method.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e11c383f8dbc8d0d02a7e4c42f755738eaa3bd8b" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;../iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">사 전적으로이 &lt;code&gt;Iterator&lt;/code&gt; 의 요소 를 다른 반복자 와 비교합니다 . &lt;a href=&quot;../iter/trait.iterator#method.partial_cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5193c64367cbcdbfcac47602ae539c77c733dbd" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;iter/trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">사 전적으로이 &lt;code&gt;Iterator&lt;/code&gt; 의 요소 를 다른 반복자 와 비교합니다 . &lt;a href=&quot;iter/trait.iterator#method.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="50753dbaf3a4231173ff7ea3444ae3faef6bec15" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;iter/trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">사 전적으로이 &lt;code&gt;Iterator&lt;/code&gt; 의 요소 를 다른 반복자 와 비교합니다 . &lt;a href=&quot;iter/trait.iterator#method.partial_cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a26e03f1b58a87f3e69a164fb32f2308387a9a0d" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;trait.iterator#method.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">사 전적으로이 &lt;code&gt;Iterator&lt;/code&gt; 의 요소 를 다른 반복자 와 비교합니다 . &lt;a href=&quot;trait.iterator#method.cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="77268650d6474077dd95b0c1034d89e6138d9c8a" translate="yes" xml:space="preserve">
          <source>Lexicographically compares the elements of this &lt;code&gt;Iterator&lt;/code&gt; with those of another. &lt;a href=&quot;trait.iterator#method.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">사 전적으로이 &lt;code&gt;Iterator&lt;/code&gt; 의 요소 를 다른 반복자 와 비교합니다 . &lt;a href=&quot;trait.iterator#method.partial_cmp&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7cdfc7b1ef1b25862c1df7bf310283ec505f2f9e" translate="yes" xml:space="preserve">
          <source>Library authors should usually not directly implement this trait, but should prefer implementing the &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; trait, which offers greater flexibility and provides an equivalent &lt;code&gt;TryInto&lt;/code&gt; implementation for free, thanks to a blanket implementation in the standard library. For more information on this, see the documentation for &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">라이브러리 작성자는 일반적으로이 특성을 직접 구현하지 말고 표준 라이브러리의 블랭킷 구현 덕분에 유연성이 &lt;code&gt;TryInto&lt;/code&gt; 무료 로 동등한 TryInto 구현을 제공하는 &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; &lt;/a&gt; 특성을 구현해야합니다 . 이에 대한 자세한 내용은 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4758ec4228804e6ab30fe33d5019e3936dc6e0ac" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.</source>
          <target state="translated">선택에 따라 Apache 라이센스, 버전 2.0 또는 MIT 라이센스에 따라 라이센스가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="5ef0008f25a377dd2d246f55bb6f44f04dd3b9a3" translate="yes" xml:space="preserve">
          <source>Lifetime Annotation Syntax</source>
          <target state="translated">평생 주석 구문</target>
        </trans-unit>
        <trans-unit id="d684ab1615c80d05a111e3a5d43f3dd40b1f7fc7" translate="yes" xml:space="preserve">
          <source>Lifetime Annotations in Function Signatures</source>
          <target state="translated">함수 시그니처의 수명 주석</target>
        </trans-unit>
        <trans-unit id="ff9298a957239ce20a277b248758f21de5df0edf" translate="yes" xml:space="preserve">
          <source>Lifetime Annotations in Method Definitions</source>
          <target state="translated">분석법 정의의 수명 주석</target>
        </trans-unit>
        <trans-unit id="bf7eeb5a85880b38a5e28e77bcee94cc13003db0" translate="yes" xml:space="preserve">
          <source>Lifetime Annotations in Struct Definitions</source>
          <target state="translated">구조 정의의 수명 주석</target>
        </trans-unit>
        <trans-unit id="674c9a2bca3da0091dd89b55224da7caea179e1f" translate="yes" xml:space="preserve">
          <source>Lifetime Elision</source>
          <target state="translated">평생 소원</target>
        </trans-unit>
        <trans-unit id="717ff13cd888c9b3f73863d8fc6f55fb70c424ad" translate="yes" xml:space="preserve">
          <source>Lifetime annotations don&amp;rsquo;t change how long any of the references live. Just as functions can accept any type when the signature specifies a generic type parameter, functions can accept references with any lifetime by specifying a generic lifetime parameter. Lifetime annotations describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes.</source>
          <target state="translated">수명 주석은 참조의 수명 기간을 변경하지 않습니다. 서명이 제네릭 형식 매개 변수를 지정할 때 함수가 모든 형식을 허용 할 수있는 것처럼 함수는 일반 수명 매개 변수를 지정하여 수명이있는 참조를 허용 할 수 있습니다. 수명 주석은 수명에 영향을 미치지 않으면 서 여러 참조 수명의 관계를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="afdff3576da5c17c6d56a74897ff356724bed98a" translate="yes" xml:space="preserve">
          <source>Lifetime annotations have a slightly unusual syntax: the names of lifetime parameters must start with an apostrophe (&lt;code&gt;'&lt;/code&gt;) and are usually all lowercase and very short, like generic types. Most people use the name &lt;code&gt;'a&lt;/code&gt;. We place lifetime parameter annotations after the &lt;code&gt;&amp;amp;&lt;/code&gt; of a reference, using a space to separate the annotation from the reference&amp;rsquo;s type.</source>
          <target state="translated">수명 주석에는 약간 특이한 구문이 있습니다. 수명 매개 변수의 이름은 아포스트로피 ( &lt;code&gt;'&lt;/code&gt; )로 시작해야하며 일반적으로 일반 유형과 같이 모두 소문자이며 매우 짧습니다. 대부분의 사람들은 &lt;code&gt;'a&lt;/code&gt; ' 라는 이름을 사용합니다 . 우리는 평생 매개 변수 주석을 참조 의 &lt;code&gt;&amp;amp;&lt;/code&gt; 뒤에 배치 하고 주석을 참조 유형과 분리하는 공백을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1135a93608f0c4c9693be849ed8d4d3c3627b3b8" translate="yes" xml:space="preserve">
          <source>Lifetime bounds</source>
          <target state="translated">수명 한계</target>
        </trans-unit>
        <trans-unit id="251f40e2a7cdcbd4967d480a9d96d101163e7557" translate="yes" xml:space="preserve">
          <source>Lifetime bounds can be applied to types or other lifetimes. The bound &lt;code&gt;'a: 'b&lt;/code&gt; is usually read as &lt;code&gt;'a&lt;/code&gt;&lt;em&gt;outlives&lt;/em&gt;&lt;code&gt;'b&lt;/code&gt;. &lt;code&gt;'a: 'b&lt;/code&gt; means that &lt;code&gt;'a&lt;/code&gt; lasts longer than &lt;code&gt;'b&lt;/code&gt;, so a reference &lt;code&gt;&amp;amp;'a ()&lt;/code&gt; is valid whenever &lt;code&gt;&amp;amp;'b ()&lt;/code&gt; is valid.</source>
          <target state="translated">수명 범위는 유형 또는 다른 수명에 적용될 수 있습니다. 바운드는 &lt;code&gt;'a: 'b&lt;/code&gt; 일반적으로 읽기 &lt;code&gt;'a&lt;/code&gt; &lt;em&gt;들보 다 오래 남았습니다 &lt;/em&gt; &lt;code&gt;'b&lt;/code&gt; . &lt;code&gt;'a: 'b&lt;/code&gt; 것을 의미 &lt;code&gt;'a&lt;/code&gt; 이상 지속을 &lt;code&gt;'b&lt;/code&gt; 기준이므로 &lt;code&gt;&amp;amp;'a ()&lt;/code&gt; 언제 유효 &lt;code&gt;&amp;amp;'b ()&lt;/code&gt; 유효하다.</target>
        </trans-unit>
        <trans-unit id="4dbeb69ffc17e7e2b0614af0534a87d095aeab01" translate="yes" xml:space="preserve">
          <source>Lifetime elision</source>
          <target state="translated">평생 소원</target>
        </trans-unit>
        <trans-unit id="4ed17519ce5dbd6c80c5942b9e801bd65600d677" translate="yes" xml:space="preserve">
          <source>Lifetime elision in functions</source>
          <target state="translated">기능의 수명 제거</target>
        </trans-unit>
        <trans-unit id="cdf660f0b0e8334138261c27b1ecaed43d9845fb" translate="yes" xml:space="preserve">
          <source>Lifetime elision is a special, limited kind of inference for lifetimes in function signatures which allows you to leave out lifetimes in certain cases. For more background on lifetime elision see &lt;a href=&quot;book/ch10-03-lifetime-syntax#lifetime-elision&quot;&gt;the book&lt;/a&gt;.</source>
          <target state="translated">수명 제거는 함수 시그니처에서 수명에 대한 특별하고 제한된 종류의 추론으로 특정 경우 수명을 생략 할 수 있습니다. 평생 소실에 대한 자세한 배경은&lt;a href=&quot;book/ch10-03-lifetime-syntax#lifetime-elision&quot;&gt; 은 책을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c1728f6f98aaf9465cf90c15cd1b748f66e76ad" translate="yes" xml:space="preserve">
          <source>Lifetime names for struct fields always need to be declared after the &lt;code&gt;impl&lt;/code&gt; keyword and then used after the struct&amp;rsquo;s name, because those lifetimes are part of the struct&amp;rsquo;s type.</source>
          <target state="translated">구조체 필드의 수명 이름은 항상 &lt;code&gt;impl&lt;/code&gt; 키워드 다음 구조체 이름 뒤에 사용해야합니다. 수명은 구조체 유형의 일부이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a900c570930642dfc60a61e8d7bac83d7d6ce835" translate="yes" xml:space="preserve">
          <source>Lifetime parameters and &lt;a href=&quot;expressions/loop-expr&quot;&gt;loop labels&lt;/a&gt; use LIFETIME_OR_LABEL tokens. Any LIFETIME_TOKEN will be accepted by the lexer, and for example, can be used in macros.</source>
          <target state="translated">수명 매개 변수 및 &lt;a href=&quot;expressions/loop-expr&quot;&gt; 루프 레이블&lt;/a&gt; 은 LIFETIME_OR_LABEL 토큰을 사용합니다. LIFETIME_TOKEN은 어휘 분석기에 의해 허용되며, 예를 들어 매크로에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ff5a6b571244bea88cc86b164846e047b3ec7b5" translate="yes" xml:space="preserve">
          <source>Lifetime parameters or &lt;a href=&quot;expressions/loop-expr#loop-labels&quot;&gt;loop labels&lt;/a&gt;</source>
          <target state="translated">수명 매개 변수 또는 &lt;a href=&quot;expressions/loop-expr#loop-labels&quot;&gt; 루프 레이블&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec6b2b953ecf8f329d7e04b783de42bfc3652a53" translate="yes" xml:space="preserve">
          <source>Lifetimes</source>
          <target state="translated">Lifetimes</target>
        </trans-unit>
        <trans-unit id="6e3d4513c00b42e75eeb4d12543903cf3991d567" translate="yes" xml:space="preserve">
          <source>Lifetimes and loop labels</source>
          <target state="translated">수명 및 루프 라벨</target>
        </trans-unit>
        <trans-unit id="44ebe0741417aa78ef5defc6e06797a635cee244" translate="yes" xml:space="preserve">
          <source>Lifetimes on function or method parameters are called &lt;em&gt;input lifetimes&lt;/em&gt;, and lifetimes on return values are called &lt;em&gt;output lifetimes&lt;/em&gt;.</source>
          <target state="translated">함수 또는 메서드 매개 변수의 &lt;em&gt;수명을 입력 수명&lt;/em&gt; 이라고 하고 반환 값의 수명을 &lt;em&gt;출력 수명&lt;/em&gt; 이라고 &lt;em&gt;합니다.&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b0908dfa434be81e3deb0facdeb85bcd33472550" translate="yes" xml:space="preserve">
          <source>Lifetimes used in &lt;code&gt;fn&lt;/code&gt; or &lt;code&gt;Fn&lt;/code&gt; syntax must be explicitly declared using &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; binders. For example:</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; 또는 &lt;code&gt;Fn&lt;/code&gt; 구문에 사용되는 수명 은 &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; 바인더를 사용하여 명시 적으로 선언해야합니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="711484ebabd34c5bee47c2a0196b50ef7c53c764" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;, the lock specified will be re-acquired when this function returns, regardless of whether the timeout elapsed or not.</source>
          <target state="translated">&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 처럼 , 타임 아웃의 경과 여부에 관계없이이 함수가 반환 될 때 지정된 잠금이 다시 획득됩니다.</target>
        </trans-unit>
        <trans-unit id="9143067c5010240235e5098fdd6d0b035ca2de7f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#method.wait_until&quot;&gt;&lt;code&gt;wait_until&lt;/code&gt;&lt;/a&gt;, the lock specified will be re-acquired when this function returns, regardless of whether the timeout elapsed or not.</source>
          <target state="translated">&lt;a href=&quot;#method.wait_until&quot;&gt; &lt;code&gt;wait_until&lt;/code&gt; &lt;/a&gt; 처럼 , 시간 초과 여부에 관계없이이 함수가 리턴 될 때 지정된 잠금이 다시 획득됩니다.</target>
        </trans-unit>
        <trans-unit id="841a9a19b58dd6630bdc34ede04fb57fa218eece" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;../../../io/trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">같이 &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; ,이 버퍼의 조각에서 쓰는 것을 제외하고. &lt;a href=&quot;../../../io/trait.write#method.write_vectored&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="090c127fd35edc1d60b1dabd86f3ca4ea132ca47" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;../io/trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">같이 &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; ,이 버퍼의 조각에서 쓰는 것을 제외하고. &lt;a href=&quot;../io/trait.write#method.write_vectored&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="85cbabaec83102adcf38ba2f63965f7483dc4ff0" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../ptr/fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;copy&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using both the values in the region beginning at &lt;code&gt;*src&lt;/code&gt; and the region beginning at &lt;code&gt;*dst&lt;/code&gt; can &lt;a href=&quot;../ptr/fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;../ptr/fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;copy&lt;/code&gt; 의 비트 사본 생성 &lt;code&gt;T&lt;/code&gt; 를 여부에 관계없이의, &lt;code&gt;T&lt;/code&gt; 는 것입니다 &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 &lt;code&gt;*src&lt;/code&gt; 에서 시작하는 영역과 &lt;code&gt;*dst&lt;/code&gt; 에서 시작하는 영역의 값을 모두 사용하십시오.&lt;a href=&quot;../ptr/fn.read#ownership-of-the-returned-value&quot;&gt; 메모리 안전을 위반할&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6b5f673832d554b3ba278cb3e90ddc20575f12f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../ptr/fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;copy_nonoverlapping&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using &lt;em&gt;both&lt;/em&gt; the values in the region beginning at &lt;code&gt;*src&lt;/code&gt; and the region beginning at &lt;code&gt;*dst&lt;/code&gt; can &lt;a href=&quot;../ptr/fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;../ptr/fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;copy_nonoverlapping&lt;/code&gt; 은 의 비트 사본 생성 &lt;code&gt;T&lt;/code&gt; 를 여부에 관계없이의, &lt;code&gt;T&lt;/code&gt; 는 것입니다 &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 &lt;code&gt;*src&lt;/code&gt; 에서 시작하는 영역과 &lt;code&gt;*dst&lt;/code&gt; 에서 시작하는 영역의 값 을 &lt;em&gt;모두&lt;/em&gt; 사용 &lt;em&gt;하면 &lt;/em&gt;&lt;a href=&quot;../ptr/fn.read#ownership-of-the-returned-value&quot;&gt;메모리 안전을 위반할&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bbf650a829b373e9102813a508f7fe2ddc52356d" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../ptr/fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;copy_nonoverlapping&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;fn.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;fn.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using &lt;em&gt;both&lt;/em&gt; the values in the region beginning at &lt;code&gt;*src&lt;/code&gt; and the region beginning at &lt;code&gt;*dst&lt;/code&gt; can &lt;a href=&quot;../ptr/fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;../ptr/fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;copy_nonoverlapping&lt;/code&gt; 은 의 비트 사본 생성 &lt;code&gt;T&lt;/code&gt; 를 여부에 관계없이의, &lt;code&gt;T&lt;/code&gt; 는 것입니다 &lt;a href=&quot;fn.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;fn.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 &lt;code&gt;*src&lt;/code&gt; 로 시작하는 영역과 &lt;code&gt;*dst&lt;/code&gt; 로 시작 하는 영역의 값 을 &lt;em&gt;모두&lt;/em&gt; 사용 &lt;em&gt;하면 &lt;/em&gt;&lt;a href=&quot;../ptr/fn.read#ownership-of-the-returned-value&quot;&gt;메모리 안전을 위반할&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="673f6dbc7b8c22dd58a3649d0763e6d47086e689" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; (for load, store, and load-with-store operations, respectively) with the additional guarantee that all threads see all sequentially consistent operations in the same order.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;AcqRel&lt;/code&gt; &lt;/a&gt; 모든 스레드가 같은 순서로 모든 순차적으로 일관 작업을 참조하는 추가 보장과 (로드, 저장 및로드와 매장 운영, 각각의 경우).</target>
        </trans-unit>
        <trans-unit id="ddf9f8511904c5069b83f4fd094004a94b015444" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;fn.forget&quot;&gt;&lt;code&gt;forget&lt;/code&gt;&lt;/a&gt;, but also accepts unsized values.</source>
          <target state="translated">&lt;a href=&quot;fn.forget&quot;&gt; &lt;code&gt;forget&lt;/code&gt; &lt;/a&gt; 과 마찬가지로 크기가 지정되지 않은 값도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="4b60bd7f4df6aad7fa80856c1bd518eaad347be6" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;copy&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using both the values in the region beginning at &lt;code&gt;*src&lt;/code&gt; and the region beginning at &lt;code&gt;*dst&lt;/code&gt; can &lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;copy&lt;/code&gt; 의 비트 사본 생성 &lt;code&gt;T&lt;/code&gt; 를 여부에 관계없이의, &lt;code&gt;T&lt;/code&gt; 는 것입니다 &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 &lt;code&gt;*src&lt;/code&gt; 에서 시작하는 영역과 &lt;code&gt;*dst&lt;/code&gt; 에서 시작하는 영역의 값을 모두 사용하십시오.&lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt; 메모리 안전을 위반할&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae45f3009db76dae79642054ed9d2e4707eced76" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;copy_nonoverlapping&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using &lt;em&gt;both&lt;/em&gt; the values in the region beginning at &lt;code&gt;*src&lt;/code&gt; and the region beginning at &lt;code&gt;*dst&lt;/code&gt; can &lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;copy_nonoverlapping&lt;/code&gt; 은 의 비트 사본 생성 &lt;code&gt;T&lt;/code&gt; 를 여부에 관계없이의, &lt;code&gt;T&lt;/code&gt; 는 있다&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 &lt;code&gt;*src&lt;/code&gt; 에서 시작하는 영역과 &lt;code&gt;*dst&lt;/code&gt; 에서 시작하는 영역의 값 을 &lt;em&gt;모두&lt;/em&gt; 사용 &lt;em&gt;하면 &lt;/em&gt;&lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;메모리 안전을 위반할&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecfb87516d3e691309e3183e393372085b3eb5c7" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;copy_nonoverlapping&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;fn.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;fn.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using &lt;em&gt;both&lt;/em&gt; the values in the region beginning at &lt;code&gt;*src&lt;/code&gt; and the region beginning at &lt;code&gt;*dst&lt;/code&gt; can &lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;copy_nonoverlapping&lt;/code&gt; 은 의 비트 사본 생성 &lt;code&gt;T&lt;/code&gt; 를 여부에 관계없이의, &lt;code&gt;T&lt;/code&gt; 는 것입니다 &lt;a href=&quot;fn.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;fn.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 &lt;code&gt;*src&lt;/code&gt; 로 시작하는 영역과 &lt;code&gt;*dst&lt;/code&gt; 로 시작 하는 영역의 값 을 &lt;em&gt;모두&lt;/em&gt; 사용 &lt;em&gt;하면 &lt;/em&gt;&lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;메모리 안전을 위반할&lt;/a&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29fb501f0793a6ba4173aacc2026afb59ff625c1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;read_unaligned&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using both the returned value and the value at &lt;code&gt;*src&lt;/code&gt; can &lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;read_unaligned&lt;/code&gt; 은 의 비트 사본 생성 &lt;code&gt;T&lt;/code&gt; 를 여부에 관계없이의, &lt;code&gt;T&lt;/code&gt; 는 것입니다 &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; . 경우 &lt;code&gt;T&lt;/code&gt; 가 아닌 &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 반환 값과의 값을 모두 사용하여, &lt;code&gt;*src&lt;/code&gt; 캔을&lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt; 메모리 안전을 위반할&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf95f150b3e045a75caa61fd8dd299e1f6177de4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;read_volatile&lt;/code&gt; creates a bitwise copy of &lt;code&gt;T&lt;/code&gt;, regardless of whether &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using both the returned value and the value at &lt;code&gt;*src&lt;/code&gt; can &lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;violate memory safety&lt;/a&gt;. However, storing non-&lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; types in volatile memory is almost certainly incorrect.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;read_volatile&lt;/code&gt; 의 비트 사본 생성 &lt;code&gt;T&lt;/code&gt; 를 여부에 관계없이의, &lt;code&gt;T&lt;/code&gt; 는 것입니다 &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 리턴 된 값과 &lt;code&gt;*src&lt;/code&gt; 의 값을 모두 사용하면 &lt;a href=&quot;fn.read#ownership-of-the-returned-value&quot;&gt;메모리 안전을 위반할&lt;/a&gt; 수 있습니다 . 그러나 비 &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 저장 휘발성 메모리에 유형을 것은 거의 정확하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a2ef8c40adbd6ce1d9e2b9decbefda1339ad636f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; (for load, store, and load-with-store operations, respectively) with the additional guarantee that all threads see all sequentially consistent operations in the same order.</source>
          <target state="translated">&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt; &lt;code&gt;AcqRel&lt;/code&gt; &lt;/a&gt; 처럼 모든 스레드가 같은 순서로 모든 순차적으로 일관 작업을 참조하는 추가 보장과 (로드, 저장 및로드와 매장 운영, 각각의 경우).</target>
        </trans-unit>
        <trans-unit id="10040ebca04aab631b833e06ce9af822e9824086" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;io/trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">같이 &lt;a href=&quot;io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; ,이 버퍼의 조각에서 쓰는 것을 제외하고. &lt;a href=&quot;io/trait.write#method.write_vectored&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3cb3f2bd27f2c64ea34e80152dae14864b47bd75" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;keyword.struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt;s and &lt;a href=&quot;keyword.enum&quot;&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/a&gt;s, a module and its content are private by default, unaccessible to code outside of the module.</source>
          <target state="translated">&lt;a href=&quot;keyword.struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;keyword.enum&quot;&gt; &lt;code&gt;enum&lt;/code&gt; &lt;/a&gt; 과 마찬가지로 모듈과 그 내용은 기본적으로 비공개이며 모듈 외부의 코드에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c4a2b45437346496bd0f17702b7e91d1466c2799" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt;, this macro also has a second version, where a custom panic message can be provided.</source>
          <target state="translated">&lt;a href=&quot;macro.assert&quot;&gt; &lt;code&gt;assert!&lt;/code&gt; &lt;/a&gt; 처럼 !이 매크로에는 맞춤 패닉 메시지를 제공 할 수있는 두 번째 버전도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a3d6c41c117ef0813067fce9ad6d2c797819f20" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt;, this macro has a second form, where a custom panic message can be provided.</source>
          <target state="translated">&lt;a href=&quot;macro.assert&quot;&gt; &lt;code&gt;assert!&lt;/code&gt; &lt;/a&gt; 처럼 ! 이 매크로는 두 번째 형식으로되어 있으며 사용자 지정 패닉 메시지를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f9660f47631acac7f2a52b8ab96514dc036d49e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;struct.bufwriter&quot;&gt;&lt;code&gt;BufWriter&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;LineWriter&lt;/code&gt;&amp;rsquo;s buffer will also be flushed when the &lt;code&gt;LineWriter&lt;/code&gt; goes out of scope or when its internal buffer is full.</source>
          <target state="translated">추천 &lt;a href=&quot;struct.bufwriter&quot;&gt; &lt;code&gt;BufWriter&lt;/code&gt; &lt;/a&gt; 하는 &lt;code&gt;LineWriter&lt;/code&gt; 때의 버퍼는 플러시 &lt;code&gt;LineWriter&lt;/code&gt; 이 범위하거나 내부 버퍼가 가득 벗어나.</target>
        </trans-unit>
        <trans-unit id="58df427e5bbce21caf2fe2b837297d163849e77b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;, the lock specified will be re-acquired when this function returns, regardless of whether the timeout elapsed or not.</source>
          <target state="translated">&lt;a href=&quot;struct.condvar#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 지정된 잠금은 시간 초과 경과 여부에 관계없이이 함수가 반환 될 때 다시 획득됩니다.</target>
        </trans-unit>
        <trans-unit id="30c450b5b408d7fbd12d604817a55adc65281b8d" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;struct.condvar#method.wait_while&quot;&gt;&lt;code&gt;wait_while&lt;/code&gt;&lt;/a&gt;, the lock specified will be re-acquired when this function returns, regardless of whether the timeout elapsed or not.</source>
          <target state="translated">&lt;a href=&quot;struct.condvar#method.wait_while&quot;&gt; &lt;code&gt;wait_while&lt;/code&gt; &lt;/a&gt; 과 마찬가지로 지정된 잠금은 시간 제한이 경과했는지 여부에 관계없이이 함수가 반환 될 때 다시 획득됩니다.</target>
        </trans-unit>
        <trans-unit id="bb8fc695456a6957ca08bda068f50835ca6480df" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;, if there is a value, it is wrapped in a &lt;code&gt;Some(T)&lt;/code&gt;. But if the iteration is over, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 와 같이 값이 있으면 &lt;code&gt;Some(T)&lt;/code&gt; 래핑됩니다 . 그러나 반복이 끝나면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="375e88d0fb45924c13a3ac3d25d35cc53e0b6dbf" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, except that it writes from a slice of buffers.</source>
          <target state="translated">같이 &lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; ,이 버퍼의 조각에서 쓰는 것을 제외하고.</target>
        </trans-unit>
        <trans-unit id="3ece68e98c367b427da7eda601344bdda8373dc9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">같이 &lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; ,이 버퍼의 조각에서 쓰는 것을 제외하고. &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e96e1257fda431003f96a740ec957795754307e9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt; is normally associated with the innermost enclosing loop, but &lt;code&gt;continue 'label&lt;/code&gt; may be used to specify the loop affected. A &lt;code&gt;continue&lt;/code&gt; expression is only permitted in the body of a loop.</source>
          <target state="translated">마찬가지로 &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;continue&lt;/code&gt; 일반적으로 루프를 둘러싸는 가장 안쪽과 관련되어 있지만 &lt;code&gt;continue 'label&lt;/code&gt; 영향을 루프를 지정하는 데 사용할 수 있습니다. A는 &lt;code&gt;continue&lt;/code&gt; 표현은 루프의 본문에 허용된다.</target>
        </trans-unit>
        <trans-unit id="4e6414b7dcb2bf632ebca1570eac937be87ca89a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt; is normally associated with the innermost enclosing loop, but labels may be used to specify the affected loop.</source>
          <target state="translated">마찬가지로 &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;continue&lt;/code&gt; 일반적으로 가장 안쪽의 루프와 연결되어 있지만, 라벨은 영향을받는 루프를 지정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="088a111a2146143c269622f6720bedf46b4095af" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;ctlz&lt;/code&gt;, but extra-unsafe as it returns &lt;code&gt;undef&lt;/code&gt; when given an &lt;code&gt;x&lt;/code&gt; with value &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ctlz&lt;/code&gt; 와 비슷 하지만 값이 &lt;code&gt;0&lt;/code&gt; 인 &lt;code&gt;x&lt;/code&gt; 가 주어지면 &lt;code&gt;undef&lt;/code&gt; 를 반환하므로 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0441e738f2dd6cd8b8b2b78d7c0e5293c433e051" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;cttz&lt;/code&gt;, but extra-unsafe as it returns &lt;code&gt;undef&lt;/code&gt; when given an &lt;code&gt;x&lt;/code&gt; with value &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cttz&lt;/code&gt; 와 비슷 하지만 값이 &lt;code&gt;0&lt;/code&gt; 인 &lt;code&gt;x&lt;/code&gt; 가 주어지면 &lt;code&gt;undef&lt;/code&gt; 를 반환하므로 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="aafea1bc859a7c488e520cc6c530088c8d2d86f9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;panic!&lt;/code&gt;, this macro has a second form for displaying custom values.</source>
          <target state="translated">&lt;code&gt;panic!&lt;/code&gt; 처럼 ! ,이 매크로에는 사용자 지정 값을 표시하는 두 번째 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0af819e7752cc0d0f79bda85b3236f2d4d09b2e2" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;read&lt;/code&gt;, except that it reads into a slice of buffers.</source>
          <target state="translated">등 &lt;code&gt;read&lt;/code&gt; 는 버퍼의 조각으로 읽는 것을 제외하고.</target>
        </trans-unit>
        <trans-unit id="c398915090a8fe75043794195cb2a1010511d11d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;read&lt;/code&gt;, except that it reads into a slice of buffers. &lt;a href=&quot;../../../io/trait.read#method.read_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">등 &lt;code&gt;read&lt;/code&gt; 는 버퍼의 조각으로 읽는 것을 제외하고. &lt;a href=&quot;../../../io/trait.read#method.read_vectored&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4193e9abdbffc61433821360262b7ce147ba44be" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;read&lt;/code&gt;, except that it reads into a slice of buffers. &lt;a href=&quot;../io/trait.read#method.read_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">등 &lt;code&gt;read&lt;/code&gt; 는 버퍼의 조각으로 읽는 것을 제외하고. &lt;a href=&quot;../io/trait.read#method.read_vectored&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19a11d624c5ac2fd3c32083744114569a63b8be1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;read&lt;/code&gt;, except that it reads into a slice of buffers. &lt;a href=&quot;io/trait.read#method.read_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">등 &lt;code&gt;read&lt;/code&gt; 는 버퍼의 조각으로 읽는 것을 제외하고. &lt;a href=&quot;io/trait.read#method.read_vectored&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab91074c2b287fdf8a7b212edaf2da1655891bbf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;read&lt;/code&gt;, except that it reads into a slice of buffers. &lt;a href=&quot;trait.read#method.read_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">등 &lt;code&gt;read&lt;/code&gt; 는 버퍼의 조각으로 읽는 것을 제외하고. &lt;a href=&quot;trait.read#method.read_vectored&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d0c137ee5317a547c2505ef5380b9708644889bf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;write&lt;/code&gt;, except that it writes from a slice of buffers.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 처럼버퍼 슬라이스에서 쓰는 것을 제외하고 .</target>
        </trans-unit>
        <trans-unit id="52fa708382c8776f6cbe3b5227e8d830d96b01c9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;write&lt;/code&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;../../../io/trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">버퍼 슬라이스에서 쓰는 것을 제외하고 &lt;code&gt;write&lt;/code&gt; 처럼 . &lt;a href=&quot;../../../io/trait.write#method.write_vectored&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5724f707420fb63c78e29f6894aa5e96feb279b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;write&lt;/code&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;../io/trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">버퍼 슬라이스에서 쓰는 것을 제외하고 &lt;code&gt;write&lt;/code&gt; 처럼 . &lt;a href=&quot;../io/trait.write#method.write_vectored&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c8e23cd5a3cb733eb5eff3ebaeba471859348fb4" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;write&lt;/code&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;io/trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">버퍼 슬라이스에서 쓰는 것을 제외하고 &lt;code&gt;write&lt;/code&gt; 처럼 . &lt;a href=&quot;io/trait.write#method.write_vectored&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be2823934efbd612499317ea4eb64b49a897e3b9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;write&lt;/code&gt;, except that it writes from a slice of buffers. &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">버퍼 슬라이스에서 쓰는 것을 제외하고 &lt;code&gt;write&lt;/code&gt; 처럼 . &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="902993443cc36d88600a8cb05ef8c36915632034" translate="yes" xml:space="preserve">
          <source>Like all instances of UB, if this assumption turns out to be wrong, i.e., the &lt;code&gt;unreachable_unchecked()&lt;/code&gt; call is actually reachable among all possible control flow, the compiler will apply the wrong optimization strategy, and may sometimes even corrupt seemingly unrelated code, causing difficult-to-debug problems.</source>
          <target state="translated">UB의 모든 인스턴스와 마찬가지로이 가정이 잘못된 것으로 판명되면, 즉 모든 가능한 제어 흐름 중에서 &lt;code&gt;unreachable_unchecked()&lt;/code&gt; 호출에 실제로 도달 할 수있는 경우 컴파일러는 잘못된 최적화 전략을 적용하고 때로는 관련이없는 것처럼 보이는 코드를 손상시킬 수 있습니다. 디버그하기 어려운 문제.</target>
        </trans-unit>
        <trans-unit id="649ba6cfd601ba5aca37823d799268a81f5dc250" translate="yes" xml:space="preserve">
          <source>Like all technical books, this book has certain conventions in how it displays information. These conventions are documented here.</source>
          <target state="translated">모든 기술 서적과 마찬가지로이 서적에는 정보를 표시하는 방법에 대한 특정 규칙이 있습니다. 이러한 규칙은 여기에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="44d26e3390ffce91f282ebeb751d71157005049b" translate="yes" xml:space="preserve">
          <source>Like any literal, an integer literal may be followed (immediately, without any spaces) by an &lt;em&gt;integer suffix&lt;/em&gt;, which forcibly sets the type of the literal. The integer suffix must be the name of one of the integral types: &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;i8&lt;/code&gt;, &lt;code&gt;u16&lt;/code&gt;, &lt;code&gt;i16&lt;/code&gt;, &lt;code&gt;u32&lt;/code&gt;, &lt;code&gt;i32&lt;/code&gt;, &lt;code&gt;u64&lt;/code&gt;, &lt;code&gt;i64&lt;/code&gt;, &lt;code&gt;u128&lt;/code&gt;, &lt;code&gt;i128&lt;/code&gt;, &lt;code&gt;usize&lt;/code&gt;, or &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">다른 리터럴과 마찬가지로 정수 리터럴 뒤에는 &lt;em&gt;정수 접미어가&lt;/em&gt; 붙을 수 있으며 (즉시 공백없이) 리터럴의 유형을 강제로 설정합니다. 정수 접미 부는 정수 유형 중 하나의 이름이어야합니다 : &lt;code&gt;u8&lt;/code&gt; , &lt;code&gt;i8&lt;/code&gt; , &lt;code&gt;u16&lt;/code&gt; , &lt;code&gt;i16&lt;/code&gt; , &lt;code&gt;u32&lt;/code&gt; , &lt;code&gt;i32&lt;/code&gt; , &lt;code&gt;u64&lt;/code&gt; , &lt;code&gt;i64&lt;/code&gt; , &lt;code&gt;u128&lt;/code&gt; , &lt;code&gt;i128&lt;/code&gt; , &lt;code&gt;usize&lt;/code&gt; 또는 &lt;code&gt;isize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe96ba09f6c5b465c5068945c430d86210b786b4" translate="yes" xml:space="preserve">
          <source>Like any other &lt;code&gt;struct&lt;/code&gt;, a vector is freed when it goes out of scope, as annotated in Listing 8-4.</source>
          <target state="translated">다른 &lt;code&gt;struct&lt;/code&gt; 와 마찬가지로 벡터는 목록 8-4에 주석이 달린 범위를 벗어나면 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="05c02c45bd9fe3c41ff9466036864fee28d10e75" translate="yes" xml:space="preserve">
          <source>Like asynchronous channels, if the &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;struct.syncsender&quot;&gt;&lt;code&gt;SyncSender&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.senderror&quot;&gt;&lt;code&gt;SendError&lt;/code&gt;&lt;/a&gt;. Similarly, If the &lt;a href=&quot;struct.syncsender&quot;&gt;&lt;code&gt;SyncSender&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.recverror&quot;&gt;&lt;code&gt;RecvError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 비동기 채널과 마찬가지로, &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; 하는 동안 연결이 끊어 &lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;struct.syncsender&quot;&gt; &lt;code&gt;SyncSender&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 방법은 반환 &lt;a href=&quot;struct.senderror&quot;&gt; &lt;code&gt;SendError&lt;/code&gt; &lt;/a&gt; . 마찬가지로 &lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; 를 시도하는 중에 &lt;a href=&quot;struct.syncsender&quot;&gt; &lt;code&gt;SyncSender&lt;/code&gt; &lt;/a&gt; 연결이 끊어 지면 &lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;a href=&quot;struct.recverror&quot;&gt; &lt;code&gt;RecvError&lt;/code&gt; &lt;/a&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="5aebd2c614f88bfe78d840f656119aee198d25e8" translate="yes" xml:space="preserve">
          <source>Like integer literals, a floating-point literal may be followed by a suffix, so long as the pre-suffix part does not end with &lt;code&gt;U+002E&lt;/code&gt; (&lt;code&gt;.&lt;/code&gt;). The suffix forcibly sets the type of the literal. There are two valid &lt;em&gt;floating-point suffixes&lt;/em&gt;, &lt;code&gt;f32&lt;/code&gt; and &lt;code&gt;f64&lt;/code&gt; (the 32-bit and 64-bit floating point types), which explicitly determine the type of the literal.</source>
          <target state="translated">정수 리터럴과 마찬가지로, 접미사 &lt;code&gt;U+002E&lt;/code&gt; 부분이 U + 002E ( &lt;code&gt;.&lt;/code&gt; )로 끝나지 않는 한 부동 소수점 리터럴 뒤에 접미사가 올 수 있습니다 . 접미사는 리터럴의 유형을 강제로 설정합니다. 두 유효있다 &lt;em&gt;부동 소수점 접미사&lt;/em&gt; , &lt;code&gt;f32&lt;/code&gt; 및 &lt;code&gt;f64&lt;/code&gt; 명시 문자 유형을 결정 (32 비트 및 64 비트 부동 소수점 유형).</target>
        </trans-unit>
        <trans-unit id="75d8318497142cc1c07dc08759286ca5f2b7edc7" translate="yes" xml:space="preserve">
          <source>Like items, &lt;code&gt;use&lt;/code&gt; declarations are private to the containing module, by default. Also like items, a &lt;code&gt;use&lt;/code&gt; declaration can be public, if qualified by the &lt;code&gt;pub&lt;/code&gt; keyword. Such a &lt;code&gt;use&lt;/code&gt; declaration serves to &lt;em&gt;re-export&lt;/em&gt; a name. A public &lt;code&gt;use&lt;/code&gt; declaration can therefore &lt;em&gt;redirect&lt;/em&gt; some public name to a different target definition: even a definition with a private canonical path, inside a different module. If a sequence of such redirections form a cycle or cannot be resolved unambiguously, they represent a compile-time error.</source>
          <target state="translated">항목과 마찬가지로 &lt;code&gt;use&lt;/code&gt; 선언은 기본적으로 포함 모듈에 대해 비공개입니다. 항목과 마찬가지로 &lt;code&gt;pub&lt;/code&gt; 키워드로 한정된 경우 &lt;code&gt;use&lt;/code&gt; 선언을 공개 할 수 있습니다 . 이러한 &lt;code&gt;use&lt;/code&gt; 선언은 이름 을 &lt;em&gt;다시 내보내는&lt;/em&gt; 역할을 합니다. 따라서 공용 &lt;code&gt;use&lt;/code&gt; 선언은 일부 공용 이름을 다른 대상 정의 (다른 모듈 내부의 개인 표준 경로가있는 정의)로 경로 &lt;em&gt;재 지정할&lt;/em&gt; 수 있습니다 . 이러한 리디렉션 시퀀스가주기를 형성하거나 명확하게 해결할 수없는 경우 컴파일 타임 오류를 나타냅니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4455a5352379b9bfb84306293e10135e6768efff" translate="yes" xml:space="preserve">
          <source>Like most indexing operations, the count starts from zero, so &lt;code&gt;nth(0)&lt;/code&gt; returns the first value, &lt;code&gt;nth(1)&lt;/code&gt; the second, and so on.</source>
          <target state="translated">대부분의 인덱싱 작업과 마찬가지로 카운트는 0부터 시작하므로 &lt;code&gt;nth(0)&lt;/code&gt; 은 첫 번째 값, &lt;code&gt;nth(1)&lt;/code&gt; 은 두 번째 값 등을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="808e2460e25efca05f0265071060604e1e534bac" translate="yes" xml:space="preserve">
          <source>Like references in rust, function pointers are assumed to not be null, so if you want to pass a function pointer over FFI and be able to accommodate null pointers, make your type &lt;code&gt;Option&amp;lt;fn()&amp;gt;&lt;/code&gt; with your required signature.</source>
          <target state="translated">rust의 참조와 같이 함수 포인터는 널이 아닌 것으로 가정하므로 FFI에 함수 포인터를 전달하고 널 포인터를 수용 할 수 있으 려면 필수 서명으로 &lt;code&gt;Option&amp;lt;fn()&amp;gt;&lt;/code&gt; 을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="8e44ee89e79563bdf5dbc7eeeb4e89ae7df53d96" translate="yes" xml:space="preserve">
          <source>Like the &lt;a href=&quot;keyword.for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; expression, we can use &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt;. A &lt;code&gt;while&lt;/code&gt; expression cannot break with a value and always evaluates to &lt;code&gt;()&lt;/code&gt; unlike &lt;a href=&quot;keyword.loop&quot;&gt;&lt;code&gt;loop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;keyword.for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; 표현식 과 마찬가지로 &lt;code&gt;break&lt;/code&gt; 및 &lt;code&gt;continue&lt;/code&gt; 를 사용할 수 있습니다 . &lt;code&gt;while&lt;/code&gt; 표현식은 값으로 휴식 항상 평가 수 &lt;code&gt;()&lt;/code&gt; 와 달리 &lt;a href=&quot;keyword.loop&quot;&gt; &lt;code&gt;loop&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fdec5b5891f0978d4130ee94d9517ad5371a9c05" translate="yes" xml:space="preserve">
          <source>Likewise, combining the &lt;code&gt;C&lt;/code&gt; representation with a primitive representation, the layout is unspecified.</source>
          <target state="translated">마찬가지로 &lt;code&gt;C&lt;/code&gt; 표현을 기본 표현과 결합하면 레이아웃이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43eac78cc95cdbd3213a6055d8d48f1d53720313" translate="yes" xml:space="preserve">
          <source>Likewise, combining two primitive representations together is unspecified.</source>
          <target state="translated">마찬가지로 두 개의 기본 표현을 결합하는 것은 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a87f62e5c0ad27b39b657994af4f2f6af6bcd4e4" translate="yes" xml:space="preserve">
          <source>Likewise, the signature of the function uses &lt;code&gt;&amp;amp;&lt;/code&gt; to indicate that the type of the parameter &lt;code&gt;s&lt;/code&gt; is a reference. Let&amp;rsquo;s add some explanatory annotations:</source>
          <target state="translated">마찬가지로, 함수의 서명은 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 사용 하여 매개 변수 &lt;code&gt;s&lt;/code&gt; 의 유형이 참조 임을 나타냅니다 . 설명 주석을 추가해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="01de4d38c5a9265699ce4ab27dfaf087bbe8ecf6" translate="yes" xml:space="preserve">
          <source>Limitations of the &lt;code id=&quot;limitations-of-the-cacher-implementation&quot;&gt;Cacher&lt;/code&gt; Implementation</source>
          <target state="translated">&lt;code id=&quot;limitations-of-the-cacher-implementation&quot;&gt;Cacher&lt;/code&gt; 구현의 한계</target>
        </trans-unit>
        <trans-unit id="61a0ae3b849d95fb8185df69b96d0ec676fb0688" translate="yes" xml:space="preserve">
          <source>Limits</source>
          <target state="translated">Limits</target>
        </trans-unit>
        <trans-unit id="6374b1b52339bde3abd0bb8e4d466f1af18a84f0" translate="yes" xml:space="preserve">
          <source>Line comment</source>
          <target state="translated">라인 코멘트</target>
        </trans-unit>
        <trans-unit id="deea94a5bfb30ea2c7507a3f03c99253e4272a0a" translate="yes" xml:space="preserve">
          <source>Line comments beginning with &lt;code&gt;//!&lt;/code&gt; and block comments &lt;code&gt;/*! ... */&lt;/code&gt; are doc comments that apply to the parent of the comment, rather than the item that follows. That is, they are equivalent to writing &lt;code&gt;#![doc=&quot;...&quot;]&lt;/code&gt; around the body of the comment. &lt;code&gt;//!&lt;/code&gt; comments are usually used to document modules that occupy a source file.</source>
          <target state="translated">&lt;code&gt;//!&lt;/code&gt; 시작하는 줄 설명 댓글을 차단하고 &lt;code&gt;/*! ... */&lt;/code&gt; 는 뒤에 나오는 항목이 아니라 주석의 부모에게 적용되는 문서 주석입니다. 즉 , 주석 본문 주위에 &lt;code&gt;#![doc=&quot;...&quot;]&lt;/code&gt; 을 쓰는 것과 같습니다 . &lt;code&gt;//!&lt;/code&gt; 주석은 일반적으로 소스 파일을 차지하는 모듈을 문서화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="762dee2b9cd8a9da4291e16ff13ceac56af56d99" translate="yes" xml:space="preserve">
          <source>Line doc comments beginning with exactly &lt;em&gt;three&lt;/em&gt; slashes (&lt;code&gt;///&lt;/code&gt;), and block doc comments (&lt;code&gt;/** ... */&lt;/code&gt;), both inner doc comments, are interpreted as a special syntax for &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt; attributes&lt;/a&gt;. That is, they are equivalent to writing &lt;code&gt;#[doc=&quot;...&quot;]&lt;/code&gt; around the body of the comment, i.e., &lt;code&gt;/// Foo&lt;/code&gt; turns into &lt;code&gt;#[doc=&quot;Foo&quot;]&lt;/code&gt; and &lt;code&gt;/** Bar */&lt;/code&gt; turns into &lt;code&gt;#[doc=&quot;Bar&quot;]&lt;/code&gt;.</source>
          <target state="translated">정확히 &lt;em&gt;세 개의&lt;/em&gt; 슬래시 ( &lt;code&gt;///&lt;/code&gt; ) 로 시작하는 행 문서 주석 및 내부 문서 주석 인 블록 문서 주석 ( &lt;code&gt;/** ... */&lt;/code&gt; )은 &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; 속성에&lt;/a&gt; 대한 특수 구문으로 해석됩니다 . 그것이 그들이 작성하는 동일입니다 &lt;code&gt;#[doc=&quot;...&quot;]&lt;/code&gt; 하여 주석의 몸, 즉, 주위 &lt;code&gt;/// Foo&lt;/code&gt; 에 회전 &lt;code&gt;#[doc=&quot;Foo&quot;]&lt;/code&gt; 및 &lt;code&gt;/** Bar */&lt;/code&gt; 회전에 &lt;code&gt;#[doc=&quot;Bar&quot;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0f09e1a35a919b04916a657dcaf775def02ecc3" translate="yes" xml:space="preserve">
          <source>Line feed is escaped as &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">줄 바꿈은 &lt;code&gt;\n&lt;/code&gt; 이스케이프됩니다 .</target>
        </trans-unit>
        <trans-unit id="11a574794cee21df3f3bbe1f9331a0946b02f437" translate="yes" xml:space="preserve">
          <source>Line-break characters are allowed in string literals. Normally they represent themselves (i.e. no translation), but as a special exception, when an unescaped &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;) occurs immediately before the newline (&lt;code&gt;U+000A&lt;/code&gt;), the &lt;code&gt;U+005C&lt;/code&gt; character, the newline, and all whitespace at the beginning of the next line are ignored. Thus &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are equal:</source>
          <target state="translated">줄 바꿈 문자는 문자열 리터럴에 허용됩니다. 일반적으로 그것들은 자신을 나타냅니다 (즉, 번역 없음). 그러나 특별한 예외로, 이스케이프 처리되지 않은 &lt;code&gt;U+005C&lt;/code&gt; 문자 ( &lt;code&gt;\&lt;/code&gt; )가 개행 ( &lt;code&gt;U+000A&lt;/code&gt; ), &lt;code&gt;U+005C&lt;/code&gt; 문자, 개행 및 모든 공백의 바로 앞에 나타날 때 다음 줄의 시작은 무시됩니다. 따라서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 같습니다.</target>
        </trans-unit>
        <trans-unit id="d7a69d21787a597ee70bd4037b342464706e333a" translate="yes" xml:space="preserve">
          <source>Line-breaks are allowed in string literals. A line-break is either a newline (&lt;code&gt;U+000A&lt;/code&gt;) or a pair of carriage return and newline (&lt;code&gt;U+000D&lt;/code&gt;, &lt;code&gt;U+000A&lt;/code&gt;). Both byte sequences are normally translated to &lt;code&gt;U+000A&lt;/code&gt;, but as a special exception, when an unescaped &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;) occurs immediately before the line-break, then the &lt;code&gt;U+005C&lt;/code&gt; character, the line-break, and all whitespace at the beginning of the next line are ignored. Thus &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are equal:</source>
          <target state="translated">줄 바꿈은 문자열 리터럴에서 허용됩니다. 줄 바꿈은 줄 바꿈 ( &lt;code&gt;U+000A&lt;/code&gt; ) 또는 캐리지 리턴과 줄 바꿈 쌍 ( &lt;code&gt;U+000D&lt;/code&gt; , &lt;code&gt;U+000A&lt;/code&gt; )입니다. 두 바이트 시퀀스 모두 일반적으로 &lt;code&gt;U+000A&lt;/code&gt; 로 변환 되지만 특별한 예외로, 이스케이프 처리되지 않은 &lt;code&gt;U+005C&lt;/code&gt; 문자 ( &lt;code&gt;\&lt;/code&gt; )가 줄 바꿈 바로 전에 발생하면 &lt;code&gt;U+005C&lt;/code&gt; 문자, 줄 바꿈 및 모든 공백 다음 줄의 시작 부분은 무시됩니다. 따라서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="2830ad93f43cfc81ed338845630996d89e8c3581" translate="yes" xml:space="preserve">
          <source>LineWriter</source>
          <target state="translated">LineWriter</target>
        </trans-unit>
        <trans-unit id="a467a8d1c87cedc92c6a62d00ba608ee83995811" translate="yes" xml:space="preserve">
          <source>LineWriter::borrow</source>
          <target state="translated">LineWriter::borrow</target>
        </trans-unit>
        <trans-unit id="be9800c1f2dec531de8f863888451a1e1e2311ab" translate="yes" xml:space="preserve">
          <source>LineWriter::borrow_mut</source>
          <target state="translated">LineWriter::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2c13ce7518167bb16bb38a5b26d00211f5dffbd5" translate="yes" xml:space="preserve">
          <source>LineWriter::by_ref</source>
          <target state="translated">LineWriter::by_ref</target>
        </trans-unit>
        <trans-unit id="ad5e984ff0e6171936808b93fcf31ce4b80c212c" translate="yes" xml:space="preserve">
          <source>LineWriter::flush</source>
          <target state="translated">LineWriter::flush</target>
        </trans-unit>
        <trans-unit id="df10811fc6539a5582a3d6ba85fdf94454c319b5" translate="yes" xml:space="preserve">
          <source>LineWriter::fmt</source>
          <target state="translated">LineWriter::fmt</target>
        </trans-unit>
        <trans-unit id="99043611351dc9ff3e05b31b6386acec9bd4d9f9" translate="yes" xml:space="preserve">
          <source>LineWriter::from</source>
          <target state="translated">LineWriter::from</target>
        </trans-unit>
        <trans-unit id="ac69fff03ab2476a267ab98b2b6890c7cf1cc55d" translate="yes" xml:space="preserve">
          <source>LineWriter::get_mut</source>
          <target state="translated">LineWriter::get_mut</target>
        </trans-unit>
        <trans-unit id="1f40adca93e9d87127f3dcb17bebb2d113f8e8fe" translate="yes" xml:space="preserve">
          <source>LineWriter::get_ref</source>
          <target state="translated">LineWriter::get_ref</target>
        </trans-unit>
        <trans-unit id="e241aca740fc32914d91f0be104b82973eb66e5e" translate="yes" xml:space="preserve">
          <source>LineWriter::into</source>
          <target state="translated">LineWriter::into</target>
        </trans-unit>
        <trans-unit id="775f2c8ae9898d577c81da95ed4fcd902133aac3" translate="yes" xml:space="preserve">
          <source>LineWriter::into_inner</source>
          <target state="translated">LineWriter::into_inner</target>
        </trans-unit>
        <trans-unit id="dc3a9d15cfff5be7e19c52c4a56f2c5757e1f703" translate="yes" xml:space="preserve">
          <source>LineWriter::new</source>
          <target state="translated">LineWriter::new</target>
        </trans-unit>
        <trans-unit id="24e05e7c8c89d11d5f69df6388a9b0041bdc7c12" translate="yes" xml:space="preserve">
          <source>LineWriter::try_from</source>
          <target state="translated">LineWriter::try_from</target>
        </trans-unit>
        <trans-unit id="61eebd307b1c261703d7a99419578cfb8f7603b3" translate="yes" xml:space="preserve">
          <source>LineWriter::try_into</source>
          <target state="translated">LineWriter::try_into</target>
        </trans-unit>
        <trans-unit id="af6ffe50802be602950bd895cf9e0cb854fb1812" translate="yes" xml:space="preserve">
          <source>LineWriter::type_id</source>
          <target state="translated">LineWriter::type_id</target>
        </trans-unit>
        <trans-unit id="554b503c3ba754005e39b90ec87f0d92638d2c6e" translate="yes" xml:space="preserve">
          <source>LineWriter::with_capacity</source>
          <target state="translated">LineWriter::with_capacity</target>
        </trans-unit>
        <trans-unit id="221f080203de74c4a951139b8978acaf6b428212" translate="yes" xml:space="preserve">
          <source>LineWriter::write</source>
          <target state="translated">LineWriter::write</target>
        </trans-unit>
        <trans-unit id="718afa20219fcf1aa652f5865af9a7a30b0cf90f" translate="yes" xml:space="preserve">
          <source>LineWriter::write_all</source>
          <target state="translated">LineWriter::write_all</target>
        </trans-unit>
        <trans-unit id="e92db461a6c35320c65374e4144e5044c1b88bad" translate="yes" xml:space="preserve">
          <source>LineWriter::write_fmt</source>
          <target state="translated">LineWriter::write_fmt</target>
        </trans-unit>
        <trans-unit id="d174a06b1546e4b7fde2c0cdcd5ca37b66ded43b" translate="yes" xml:space="preserve">
          <source>LineWriter::write_vectored</source>
          <target state="translated">LineWriter::write_vectored</target>
        </trans-unit>
        <trans-unit id="c6fd3870c86e7422a0146e1e2a052437fb8e51e2" translate="yes" xml:space="preserve">
          <source>Lines</source>
          <target state="translated">Lines</target>
        </trans-unit>
        <trans-unit id="34d99e5c2f3cbf7a2f6c06ae38bf6f1437170c72" translate="yes" xml:space="preserve">
          <source>Lines are ended with either a newline (&lt;code&gt;\n&lt;/code&gt;) or a carriage return with a line feed (&lt;code&gt;\r\n&lt;/code&gt;).</source>
          <target state="translated">줄은 개행 ( &lt;code&gt;\n&lt;/code&gt; ) 또는 줄 바꿈 ( &lt;code&gt;\r\n&lt;/code&gt; )이 있는 캐리지 리턴으로 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="8372047979cef10f511e256735d06fdb5834080a" translate="yes" xml:space="preserve">
          <source>Lines::all</source>
          <target state="translated">Lines::all</target>
        </trans-unit>
        <trans-unit id="ab3890e2134cb7b243711c9eb9d91f7d2b2bdbb5" translate="yes" xml:space="preserve">
          <source>Lines::any</source>
          <target state="translated">Lines::any</target>
        </trans-unit>
        <trans-unit id="70cb6c67edb194cbf85640b28d5918c1d359d3b1" translate="yes" xml:space="preserve">
          <source>Lines::borrow</source>
          <target state="translated">Lines::borrow</target>
        </trans-unit>
        <trans-unit id="18b3ef85cc38f93f055a82652080b268c1813b05" translate="yes" xml:space="preserve">
          <source>Lines::borrow_mut</source>
          <target state="translated">Lines::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ddcac326a974acb99a5bdd0266258af4cf68f560" translate="yes" xml:space="preserve">
          <source>Lines::by_ref</source>
          <target state="translated">Lines::by_ref</target>
        </trans-unit>
        <trans-unit id="2210ca2bf58eac1157cb91245ab84bdb9fbfa42e" translate="yes" xml:space="preserve">
          <source>Lines::chain</source>
          <target state="translated">Lines::chain</target>
        </trans-unit>
        <trans-unit id="819432c98b0ed8115a058abc108fe41e16c028a7" translate="yes" xml:space="preserve">
          <source>Lines::clone</source>
          <target state="translated">Lines::clone</target>
        </trans-unit>
        <trans-unit id="3a9a20c42d37180cc289d3ed86b67aeef7065926" translate="yes" xml:space="preserve">
          <source>Lines::clone_from</source>
          <target state="translated">Lines::clone_from</target>
        </trans-unit>
        <trans-unit id="6d03cc14ec75314e6e9cd97f6317e2bfc576a512" translate="yes" xml:space="preserve">
          <source>Lines::clone_into</source>
          <target state="translated">Lines::clone_into</target>
        </trans-unit>
        <trans-unit id="2cc7e95a9a252a0e4512584de05d3735eda6c7e4" translate="yes" xml:space="preserve">
          <source>Lines::cloned</source>
          <target state="translated">Lines::cloned</target>
        </trans-unit>
        <trans-unit id="a59dde6acd33a5348665946c0a8673f286d24d8a" translate="yes" xml:space="preserve">
          <source>Lines::cmp</source>
          <target state="translated">Lines::cmp</target>
        </trans-unit>
        <trans-unit id="5fc1ed1cda1fe359bfcd4cfa1c08b06a6870ed72" translate="yes" xml:space="preserve">
          <source>Lines::collect</source>
          <target state="translated">Lines::collect</target>
        </trans-unit>
        <trans-unit id="40c012a06c39d10c7006c0601e73b3570aeddd35" translate="yes" xml:space="preserve">
          <source>Lines::copied</source>
          <target state="translated">Lines::copied</target>
        </trans-unit>
        <trans-unit id="484755e089b99c626b30d970a194b907cb3dceef" translate="yes" xml:space="preserve">
          <source>Lines::count</source>
          <target state="translated">Lines::count</target>
        </trans-unit>
        <trans-unit id="f9088b84e14bdd699a44622c6a8c96e4ac54b67c" translate="yes" xml:space="preserve">
          <source>Lines::cycle</source>
          <target state="translated">Lines::cycle</target>
        </trans-unit>
        <trans-unit id="bb1a7e9933496da163e7e92f98497488344c4b65" translate="yes" xml:space="preserve">
          <source>Lines::enumerate</source>
          <target state="translated">Lines::enumerate</target>
        </trans-unit>
        <trans-unit id="e403dedf91eb2082514d2e5162543f8e68efb7da" translate="yes" xml:space="preserve">
          <source>Lines::eq</source>
          <target state="translated">Lines::eq</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
