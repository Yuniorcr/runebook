<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="8c62b63ef24786f929500cd4f0e354183f51728d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait is rarely required; types that implement &lt;code&gt;Copy&lt;/code&gt; have optimizations available, meaning you don&amp;rsquo;t have to call &lt;code&gt;clone&lt;/code&gt;, which makes the code more concise.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; 특성이 거의 필요하지 않습니다; &lt;code&gt;Copy&lt;/code&gt; 를 구현하는 유형 에는 최적화가 가능 하므로 &lt;code&gt;clone&lt;/code&gt; 을 호출 할 필요가 없으므로 코드가 더 간결 해집니다.</target>
        </trans-unit>
        <trans-unit id="19e60de5e2cec4f66ffc273d83b18ba133a29961" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type which contains a field that doesn't implement the &lt;code&gt;Copy&lt;/code&gt; trait.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; 구현하지 않는 필드가 포함 된 형식에 구현 된 특성 &lt;code&gt;Copy&lt;/code&gt; 특성을.</target>
        </trans-unit>
        <trans-unit id="5bc1853088c8596ec738b63d0b306b0f2a10680d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type which is neither a struct nor an enum.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; 특성은 구조체 나 열거도 아닌 유형에 구현되었다.</target>
        </trans-unit>
        <trans-unit id="23cc8d6ab49e3b2451486ee83ff4fdc2f0dab312" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type with a &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; 특성이있는 유형에 구현 된 &lt;code&gt;Drop&lt;/code&gt; 구현입니다.</target>
        </trans-unit>
        <trans-unit id="7a2c2f0333db2747594fc8c5736d8f8e947ab10e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Counter&lt;/code&gt; struct has one field named &lt;code&gt;count&lt;/code&gt;. This field holds a &lt;code&gt;u32&lt;/code&gt; value that will keep track of where we are in the process of iterating from 1 to 5. The &lt;code&gt;count&lt;/code&gt; field is private because we want the implementation of &lt;code&gt;Counter&lt;/code&gt; to manage its value. The &lt;code&gt;new&lt;/code&gt; function enforces the behavior of always starting new instances with a value of 0 in the &lt;code&gt;count&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;Counter&lt;/code&gt; 구조체는 하나 개의 필드를 임명했다 &lt;code&gt;count&lt;/code&gt; . 이 필드는 1에서 5까지 반복하는 과정을 추적 하는 &lt;code&gt;u32&lt;/code&gt; 값을 보유합니다 . &lt;code&gt;count&lt;/code&gt; 필드는 값을 관리하기 위해 &lt;code&gt;Counter&lt;/code&gt; 구현을 원하기 때문에 비공개 입니다. &lt;code&gt;new&lt;/code&gt; 기능은 항상 0의 값으로 새로운 인스턴스를 시작하는 동작을 적용 &lt;code&gt;count&lt;/code&gt; 필드.</target>
        </trans-unit>
        <trans-unit id="e402bbce82e84dd539cf1e138daa2856a0613786" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait allows you to print instances of a type for debugging purposes, so you and other programmers using your type can inspect an instance at a particular point in a program&amp;rsquo;s execution.</source>
          <target state="translated">&lt;code&gt;Debug&lt;/code&gt; 당신과 당신의 유형을 사용하여 다른 프로그래머가 프로그램의 실행의 특정 시점에 인스턴스를 검사 할 수 있도록, 디버깅 목적으로 유형의 인스턴스를 인쇄 할 수 있습니다 특징.</target>
        </trans-unit>
        <trans-unit id="853b42f22ba0be46a6e5cd03ba34756814292e76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait enables debug formatting in format strings, which you indicate by adding &lt;code&gt;:?&lt;/code&gt; within &lt;code&gt;{}&lt;/code&gt; placeholders.</source>
          <target state="translated">&lt;code&gt;Debug&lt;/code&gt; 특성은 추가하여 표시 형식 문자열에 서식 디버그를 할 수 있습니다 &lt;code&gt;:?&lt;/code&gt; &lt;code&gt;{}&lt;/code&gt; 자리 표시 자 내에서</target>
        </trans-unit>
        <trans-unit id="6967ae462b0a2a18036d993e8418edd4a969bd40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait is required, for example, in use of the &lt;code&gt;assert_eq!&lt;/code&gt; macro. This macro prints the values of instances given as arguments if the equality assertion fails so programmers can see why the two instances weren&amp;rsquo;t equal.</source>
          <target state="translated">&lt;code&gt;Debug&lt;/code&gt; 특성은의 사용, 예를 들어, 필요 &lt;code&gt;assert_eq!&lt;/code&gt; 매크로. 이 매크로는 등식 어설 션이 실패하면 프로그래머가 두 인스턴스가 서로 다른 이유를 확인할 수있는 경우 인수로 제공된 인스턴스 값을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="aba43f90e22e0dfd98100913cb543e02752ca675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default::default&lt;/code&gt; function is commonly used in combination with the struct update syntax discussed in the &lt;a href=&quot;ch05-01-defining-structs#creating-instances-from-other-instances-with-struct-update-syntax&quot;&gt;&amp;ldquo;Creating Instances From Other Instances With Struct Update Syntax&amp;rdquo;&lt;/a&gt; section in Chapter 5. You can customize a few fields of a struct and then set and use a default value for the rest of the fields by using &lt;code&gt;..Default::default()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Default::default&lt;/code&gt; 기능은 일반적에서 논의 된 구조체 업데이트 구문과 함께 사용된다 &lt;a href=&quot;ch05-01-defining-structs#creating-instances-from-other-instances-with-struct-update-syntax&quot;&gt;&quot;구조체 업데이트 구문을 사용하여 다른 인스턴스에서 생성 인스턴스&quot;&lt;/a&gt; 설정 및 사용 A를 다음 구조체의 몇 가지 필드를 사용자 정의 할 수 있습니다 제 5 장에서 섹션 &lt;code&gt;..Default::default()&lt;/code&gt; 사용하여 나머지 필드의 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="4f7be30b5dee7044de3817ca4c87b66ab54682e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; cannot be derived on an enum for the simple reason that the compiler doesn't know which value to pick by default whereas it can for a struct as long as all its fields implement the &lt;code&gt;Default&lt;/code&gt; trait as well.</source>
          <target state="translated">&lt;code&gt;Default&lt;/code&gt; 컴파일러가 할 수있는 반면 긴 모든 필드는 구현으로 같은 구조체 기본적으로 선택되는 값을 알고하지 않는 단순한 이유 열거에서 파생 할 수없는 &lt;code&gt;Default&lt;/code&gt; 뿐만 아니라 특성을.</target>
        </trans-unit>
        <trans-unit id="155c03f436324748d5a47629042098342e63a6ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait allows you to create a default value for a type. Deriving &lt;code&gt;Default&lt;/code&gt; implements the &lt;code&gt;default&lt;/code&gt; function. The derived implementation of the &lt;code&gt;default&lt;/code&gt; function calls the &lt;code&gt;default&lt;/code&gt; function on each part of the type, meaning all fields or values in the type must also implement &lt;code&gt;Default&lt;/code&gt; to derive &lt;code&gt;Default&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Default&lt;/code&gt; 특성은 유형에 대한 기본값을 만들 수 있습니다. &lt;code&gt;Default&lt;/code&gt; 파생 은 &lt;code&gt;default&lt;/code&gt; 기능을 구현합니다 . 의 파생 구현 &lt;code&gt;default&lt;/code&gt; 기능은 호출 &lt;code&gt;default&lt;/code&gt; 도 구현해야하는 유형의 모든 필드 또는 값을 의미하는 유형의 각 부분에 기능을 &lt;code&gt;Default&lt;/code&gt; 유도하기 위해 &lt;code&gt;Default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="417d240e17ea189069372338520fb02d077b097b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait for types which may have meaningful default values.</source>
          <target state="translated">의미있는 기본값을 가질 수있는 유형 의 &lt;code&gt;Default&lt;/code&gt; 특성.</target>
        </trans-unit>
        <trans-unit id="e9ffe8630d56067e177ef382279c1fa4ad4f3ea3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait is required when you use the method &lt;code&gt;unwrap_or_default&lt;/code&gt; on &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; instances, for example. If the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the method &lt;code&gt;unwrap_or_default&lt;/code&gt; will return the result of &lt;code&gt;Default::default&lt;/code&gt; for the type &lt;code&gt;T&lt;/code&gt; stored in the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Default&lt;/code&gt; 당신이 방법을 사용할 때 특성이 필요합니다 &lt;code&gt;unwrap_or_default&lt;/code&gt; 을 에 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 경우, 예를 들면. 경우 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 입니다 &lt;code&gt;None&lt;/code&gt; , 메소드 &lt;code&gt;unwrap_or_default&lt;/code&gt; 은 결과 리턴 &lt;code&gt;Default::default&lt;/code&gt; 타입에 대한 &lt;code&gt;T&lt;/code&gt; 에 기억 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="faec1eafc86ec050669e657d677254ae1cc5eb09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait was derived on an enum.</source>
          <target state="translated">&lt;code&gt;Default&lt;/code&gt; 특성은 열거에서 파생되었다.</target>
        </trans-unit>
        <trans-unit id="3bac5d0a36fa049d2b9d797796c56dde34fe6945" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DispatchFromDyn&lt;/code&gt; trait currently can only be implemented for builtin pointer types and structs that are newtype wrappers around them &amp;mdash; that is, the struct must have only one field (except for&lt;code&gt;PhantomData&lt;/code&gt;), and that field must itself implement &lt;code&gt;DispatchFromDyn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DispatchFromDyn&lt;/code&gt; 는 현재는 주변 newtype은 래퍼 내장 포인터 유형과 구조체 구현 될 수있는 특성 - 즉, 구조체 (를 제외하고 단 하나의 필드가 있어야합니다 &lt;code&gt;PhantomData&lt;/code&gt; 을 ), 그 필드 자체가 구현해야 &lt;code&gt;DispatchFromDyn&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="f4511d27b8bd2f5f7b72a8b815a18a15df561075" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DispatchFromDyn&lt;/code&gt; trait was implemented on something which is not a pointer or a newtype wrapper around a pointer.</source>
          <target state="translated">&lt;code&gt;DispatchFromDyn&lt;/code&gt; 의 특성은 포인터 또는 포인터 주위에 newtype은 래퍼없는 무언가에 구현되었다.</target>
        </trans-unit>
        <trans-unit id="b6986e696b5a0b081bb4012a05eb9e1b65dcc35b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DraftPost&lt;/code&gt; struct has an &lt;code&gt;add_text&lt;/code&gt; method, so we can add text to &lt;code&gt;content&lt;/code&gt; as before, but note that &lt;code&gt;DraftPost&lt;/code&gt; does not have a &lt;code&gt;content&lt;/code&gt; method defined! So now the program ensures all posts start as draft posts, and draft posts don&amp;rsquo;t have their content available for display. Any attempt to get around these constraints will result in a compiler error.</source>
          <target state="translated">&lt;code&gt;DraftPost&lt;/code&gt; 의 구조체는이 &lt;code&gt;add_text&lt;/code&gt; 의 우리가 텍스트를 추가 할 수 있도록 방법을 &lt;code&gt;content&lt;/code&gt; 이전과 만 유의 &lt;code&gt;DraftPost&lt;/code&gt; 가 이없는 &lt;code&gt;content&lt;/code&gt; 방법 정의를! 이제 프로그램은 모든 게시물이 초안 게시물로 시작하고 초안 게시물에 내용을 표시 할 수 없도록합니다. 이러한 제약 조건을 해결하려고하면 컴파일러 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b1de117663cb2f27f8306ea33629038001aac2df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Drop&lt;/code&gt; trait is included in the prelude, so we don&amp;rsquo;t need to bring it into scope. We implement the &lt;code&gt;Drop&lt;/code&gt; trait on &lt;code&gt;CustomSmartPointer&lt;/code&gt; and provide an implementation for the &lt;code&gt;drop&lt;/code&gt; method that calls &lt;code&gt;println!&lt;/code&gt;. The body of the &lt;code&gt;drop&lt;/code&gt; function is where you would place any logic that you wanted to run when an instance of your type goes out of scope. We&amp;rsquo;re printing some text here to demonstrate when Rust will call &lt;code&gt;drop&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Drop&lt;/code&gt; 우리가 범위로 가져 필요가 없습니다 특성은 전주곡에 포함되어 있습니다. &lt;code&gt;CustomSmartPointer&lt;/code&gt; 에서 &lt;code&gt;Drop&lt;/code&gt; 특성을 구현하고 &lt;code&gt;println!&lt;/code&gt; 을 호출 하는 &lt;code&gt;drop&lt;/code&gt; 메소드에 대한 구현을 제공합니다 . . &lt;code&gt;drop&lt;/code&gt; 함수 의 본문은 유형의 인스턴스가 범위를 벗어날 때 실행하려는 로직을 배치하는 위치입니다. Rust가 언제 &lt;code&gt;drop&lt;/code&gt; 을 호출하는지 보여주기 위해 여기에 텍스트를 인쇄하고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a67a7efec93a37792cb31993e146b2f7a5f7bc09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Eq&lt;/code&gt; trait has no methods. Its purpose is to signal that for every value of the annotated type, the value is equal to itself. The &lt;code&gt;Eq&lt;/code&gt; trait can only be applied to types that also implement &lt;code&gt;PartialEq&lt;/code&gt;, although not all types that implement &lt;code&gt;PartialEq&lt;/code&gt; can implement &lt;code&gt;Eq&lt;/code&gt;. One example of this is floating point number types: the implementation of floating point numbers states that two instances of the not-a-number (&lt;code&gt;NaN&lt;/code&gt;) value are not equal to each other.</source>
          <target state="translated">&lt;code&gt;Eq&lt;/code&gt; 특성은 어떠한 방법이 없다. 그 목적은 주석이 달린 유형의 모든 값에 대해 값이 자체와 동일하다는 신호를 보내는 것입니다. &lt;code&gt;Eq&lt;/code&gt; 특성은 또한 구현 유형에 적용될 수 &lt;code&gt;PartialEq&lt;/code&gt; 을 구현하지 않지만 모든 유형, &lt;code&gt;PartialEq&lt;/code&gt; 을 구현할 수 &lt;code&gt;Eq&lt;/code&gt; . 부동 소수점 숫자 유형의 예로는 부동 소수점 숫자 유형이 있습니다. 부동 소수점 숫자의 구현은 숫자 가 아닌 ( &lt;code&gt;NaN&lt;/code&gt; ) 값 의 두 인스턴스가 서로 같지 않다고 말합니다 .</target>
        </trans-unit>
        <trans-unit id="339e508d8f9f4467a3c3de396b4c7c19141c661f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F&lt;/code&gt; type parameter also has the trait bound &lt;code&gt;Send&lt;/code&gt; and the lifetime bound &lt;code&gt;'static&lt;/code&gt;, which are useful in our situation: we need &lt;code&gt;Send&lt;/code&gt; to transfer the closure from one thread to another and &lt;code&gt;'static&lt;/code&gt; because we don&amp;rsquo;t know how long the thread will take to execute. Let&amp;rsquo;s create an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt; that will take a generic parameter of type &lt;code&gt;F&lt;/code&gt; with these bounds:</source>
          <target state="translated">&lt;code&gt;F&lt;/code&gt; 의 유형 매개 변수도 특성 바인딩이 &lt;code&gt;Send&lt;/code&gt; 및 바인딩 수명 &lt;code&gt;'static&lt;/code&gt; 우리의 상황에서 유용하다, 우리가 필요 &lt;code&gt;Send&lt;/code&gt; 서로 하나 개의 스레드에서 폐쇄를 전송하는 &lt;code&gt;'static&lt;/code&gt; 우리가 모르기 때문에 얼마나 스레드 것 실행하십시오. &lt;code&gt;ThreadPool&lt;/code&gt; 에서 다음과 같은 범위의 &lt;code&gt;F&lt;/code&gt; 유형의 일반 매개 변수를 사용하는 &lt;code&gt;execute&lt;/code&gt; 메서드를 만들어 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="44f286163600e21778b5e8ddc538f3f66c2c5215" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F&lt;/code&gt; type parameter is the one we&amp;rsquo;re concerned with here; the &lt;code&gt;T&lt;/code&gt; type parameter is related to the return value, and we&amp;rsquo;re not concerned with that. We can see that &lt;code&gt;spawn&lt;/code&gt; uses &lt;code&gt;FnOnce&lt;/code&gt; as the trait bound on &lt;code&gt;F&lt;/code&gt;. This is probably what we want as well, because we&amp;rsquo;ll eventually pass the argument we get in &lt;code&gt;execute&lt;/code&gt; to &lt;code&gt;spawn&lt;/code&gt;. We can be further confident that &lt;code&gt;FnOnce&lt;/code&gt; is the trait we want to use because the thread for running a request will only execute that request&amp;rsquo;s closure one time, which matches the &lt;code&gt;Once&lt;/code&gt; in &lt;code&gt;FnOnce&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;F&lt;/code&gt; 의 유형 매개 변수는 우리가 여기에 관심있는 하나이며, &lt;code&gt;T&lt;/code&gt; 의 유형 매개 변수는 반환 값에 관련되어, 우리는 그와 관련 아닙니다. &lt;code&gt;spawn&lt;/code&gt; &lt;code&gt;F&lt;/code&gt; 에 바인딩 된 특성으로 &lt;code&gt;FnOnce&lt;/code&gt; 를 사용 하는 것을 볼 수 있습니다 . 이것은 아마도 우리가 원하는 것 일 것입니다. 우리는 결국 우리가 &lt;code&gt;execute&lt;/code&gt; 인수 를 &lt;code&gt;spawn&lt;/code&gt; 하기 때문에 전달합니다 . 요청을 실행하는 스레드는 해당 요청의 클로저를 한 번만 실행하므로 &lt;code&gt;Once&lt;/code&gt; in &lt;code&gt;FnOnce&lt;/code&gt; 와 일치하기 때문에 &lt;code&gt;FnOnce&lt;/code&gt; 가 사용하려는 특성이라고 더 확신 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2cc0c55739bb91f91d10f706c9cab70e100723e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fn&lt;/code&gt; traits are provided by the standard library. All closures implement at least one of the traits: &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;, or &lt;code&gt;FnOnce&lt;/code&gt;. We&amp;rsquo;ll discuss the difference between these traits in the &lt;a href=&quot;#capturing-the-environment-with-closures&quot;&gt;&amp;ldquo;Capturing the Environment with Closures&amp;rdquo;&lt;/a&gt; section; in this example, we can use the &lt;code&gt;Fn&lt;/code&gt; trait.</source>
          <target state="translated">&lt;code&gt;Fn&lt;/code&gt; 특성은 표준 라이브러리에 의해 제공됩니다. 모든 클로저는 &lt;code&gt;Fn&lt;/code&gt; , &lt;code&gt;FnMut&lt;/code&gt; 또는 &lt;code&gt;FnOnce&lt;/code&gt; 특성 중 하나 이상을 구현 합니다. &lt;a href=&quot;#capturing-the-environment-with-closures&quot;&gt;&amp;ldquo;폐쇄 된 환경 캡처&amp;rdquo;&lt;/a&gt; 섹션 에서 이러한 특성의 차이점에 대해 설명합니다 . 이 예에서는 &lt;code&gt;Fn&lt;/code&gt; 특성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="851722264534e1910cdc1ef4f424b4a4414f9688" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;From&lt;/code&gt; is also very useful when performing error handling. When constructing a function that is capable of failing, the return type will generally be of the form &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. The &lt;code&gt;From&lt;/code&gt; trait simplifies error handling by allowing a function to return a single error type that encapsulate multiple error types. See the &quot;Examples&quot; section and &lt;a href=&quot;../../book/ch09-00-error-handling&quot;&gt;the book&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;From&lt;/code&gt; 오류 처리를 수행 할 때 매우 유용합니다. 실패 할 수있는 함수를 구성 할 때 반환 유형은 일반적으로 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 입니다. &lt;code&gt;From&lt;/code&gt; 함수가 여러 오류 유형을 캡슐화 한 오류 유형을 반환 할 수 있도록하여 특성 단순화 오류 처리. 자세한 내용은 &quot;예&quot;섹션과 &lt;a href=&quot;../../book/ch09-00-error-handling&quot;&gt;책&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="924c96483cec1214b829647e918270a4c12cbe49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GeneratorState&lt;/code&gt; enum returned from this function indicates what state the generator is in upon returning. If the &lt;code&gt;Yielded&lt;/code&gt; variant is returned then the generator has reached a suspension point and a value has been yielded out. Generators in this state are available for resumption at a later point.</source>
          <target state="translated">이 함수에서 반환 된 &lt;code&gt;GeneratorState&lt;/code&gt; 열거 형은 생성자가 반환 할 때의 상태를 나타냅니다. 경우] &lt;code&gt;Yielded&lt;/code&gt; 변형 후 리턴 발전기가 정지 지점에 도달하고있는 Value가 수득되었다. 이 상태의 발전기는 나중에 재개 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93144a0b07feb0dfc814fce370a7ec1878fc8518" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GlobalAlloc&lt;/code&gt; trait is an &lt;code&gt;unsafe&lt;/code&gt; trait for a number of reasons, and implementors must ensure that they adhere to these contracts:</source>
          <target state="translated">&lt;code&gt;GlobalAlloc&lt;/code&gt; 에 특성은이다 &lt;code&gt;unsafe&lt;/code&gt; 이유에 대한 특성 및 구현은이 계약을 준수하는지 확인해야합니다 :</target>
        </trans-unit>
        <trans-unit id="ac746bf118e800d6204d1b9be35a781fccfa8fc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Hash&lt;/code&gt; trait allows you to take an instance of a type of arbitrary size and map that instance to a value of fixed size using a hash function. Deriving &lt;code&gt;Hash&lt;/code&gt; implements the &lt;code&gt;hash&lt;/code&gt; method. The derived implementation of the &lt;code&gt;hash&lt;/code&gt; method combines the result of calling &lt;code&gt;hash&lt;/code&gt; on each of the parts of the type, meaning all fields or values must also implement &lt;code&gt;Hash&lt;/code&gt; to derive &lt;code&gt;Hash&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hash&lt;/code&gt; 특성은 임의의 크기의 형식의 인스턴스를 가지고 해시 함수를 사용하여 고정 된 크기의 값으로 해당 인스턴스를 매핑 할 수 있습니다. &lt;code&gt;Hash&lt;/code&gt; 파생 은 &lt;code&gt;hash&lt;/code&gt; 방법을 구현합니다 . 의 도출 구현 &lt;code&gt;hash&lt;/code&gt; 메소드 호출 결과 결합 &lt;code&gt;hash&lt;/code&gt; 의 종류의 부품의 각각에있는 모든 필드 또는 값도 구현해야 의미 &lt;code&gt;Hash&lt;/code&gt; 도출하도록 &lt;code&gt;Hash&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc2c322c74118357f702bcbb43acd3519194cb4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; trait has a number of different methods with default implementations provided by the standard library; you can find out about these methods by looking in the standard library API documentation for the &lt;code&gt;Iterator&lt;/code&gt; trait. Some of these methods call the &lt;code&gt;next&lt;/code&gt; method in their definition, which is why you&amp;rsquo;re required to implement the &lt;code&gt;next&lt;/code&gt; method when implementing the &lt;code&gt;Iterator&lt;/code&gt; trait.</source>
          <target state="translated">&lt;code&gt;Iterator&lt;/code&gt; 표준 라이브러리에서 제공하는 기본 구현과 상이한 다수의 방법이있다 특성; &lt;code&gt;Iterator&lt;/code&gt; 특성에 대한 표준 라이브러리 API 문서에서 이러한 메소드에 대해 찾을 수 있습니다 . 이러한 메소드 중 일부는 정의에서 &lt;code&gt;next&lt;/code&gt; 메소드를 호출 하므로 &lt;code&gt;Iterator&lt;/code&gt; 특성을 구현할 때 &lt;code&gt;next&lt;/code&gt; 메소드를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d7674b68a4f6af8a05d48508e05e8b51cf5d1646" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; trait only requires implementors to define one method: the &lt;code&gt;next&lt;/code&gt; method, which returns one item of the iterator at a time wrapped in &lt;code&gt;Some&lt;/code&gt; and, when iteration is over, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Iterator&lt;/code&gt; : 하나의 방법 정의 구현을 필요로 특징 부 (trait) &lt;code&gt;next&lt;/code&gt; 방법에 싸여 한 번에 반복자의 한 항목을 반환 &lt;code&gt;Some&lt;/code&gt; 반복, 이상 반환하지 않는 경우, 및 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9025083930c31cf7871ed20937306b52f26761a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LinkedList&lt;/code&gt; allows pushing and popping elements at either end in constant time.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; 의는 밀고 일정 시간의 양쪽 끝에 요소를 보여주고 있습니다.</target>
        </trans-unit>
        <trans-unit id="4baf38aed9bf1ffe36a931bbfb0cb77e6aa0a43b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LowerExp&lt;/code&gt; trait should format its output in scientific notation with a lower-case &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LowerExp&lt;/code&gt; 이 특성은 소문자와 과학적 표기법의 출력을 포맷한다 &lt;code&gt;e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc66d9062a365376bc4e9ff4cb202550c7cc32a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LowerHex&lt;/code&gt; trait should format its output as a number in hexadecimal, with &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt; in lower case.</source>
          <target state="translated">&lt;code&gt;LowerHex&lt;/code&gt; 의 특성으로는, 16 진수 숫자로의 출력을 포맷한다 내지 &lt;code&gt;f&lt;/code&gt; 소문자. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b321c2a56af633f328bf4b8ba254ce361d7a954" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Octal&lt;/code&gt; trait should format its output as a number in base-8.</source>
          <target state="translated">&lt;code&gt;Octal&lt;/code&gt; 특성은 염기 - 8의 수와, 그 출력을 포맷한다.</target>
        </trans-unit>
        <trans-unit id="eb10a578affd8a62e12f3ef265b344e167e3dcf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum is so useful that it&amp;rsquo;s even included in the prelude; you don&amp;rsquo;t need to bring it into scope explicitly. In addition, so are its variants: you can use &lt;code&gt;Some&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; directly without the &lt;code&gt;Option::&lt;/code&gt; prefix. The &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum is still just a regular enum, and &lt;code&gt;Some(T)&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; are still variants of type &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 열거 IS가도 전주곡에 포함되도록 유용한; 명시 적으로 범위로 가져올 필요가 없습니다. 또한 변형도 있습니다 . &lt;code&gt;Option::&lt;/code&gt; 접두사 없이 &lt;code&gt;Some&lt;/code&gt; 및 &lt;code&gt;None&lt;/code&gt; 을 직접 사용할 수 있습니다 . &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 열거 IS 여전히 정기적으로 열거하고, &lt;code&gt;Some(T)&lt;/code&gt; 과 &lt;code&gt;None&lt;/code&gt; 여전히 형 변종이다 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="757a8b38147115f7267a95ffaa6fac00dcad6a55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Option&lt;/code&gt; type. See &lt;a href=&quot;index&quot;&gt;the module level documentation&lt;/a&gt; for more.</source>
          <target state="translated">&lt;code&gt;Option&lt;/code&gt; 유형입니다. 자세한 내용 &lt;a href=&quot;index&quot;&gt;은 모듈 수준 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6ec87aec96d36200bb49beb7ba67c5c626bb7aad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ord&lt;/code&gt; trait allows you to know that for any two values of the annotated type, a valid ordering will exist. The &lt;code&gt;Ord&lt;/code&gt; trait implements the &lt;code&gt;cmp&lt;/code&gt; method, which returns an &lt;code&gt;Ordering&lt;/code&gt; rather than an &lt;code&gt;Option&amp;lt;Ordering&amp;gt;&lt;/code&gt; because a valid ordering will always be possible. You can only apply the &lt;code&gt;Ord&lt;/code&gt; trait to types that also implement &lt;code&gt;PartialOrd&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt; (and &lt;code&gt;Eq&lt;/code&gt; requires &lt;code&gt;PartialEq&lt;/code&gt;). When derived on structs and enums, &lt;code&gt;cmp&lt;/code&gt; behaves the same way as the derived implementation for &lt;code&gt;partial_cmp&lt;/code&gt; does with &lt;code&gt;PartialOrd&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ord&lt;/code&gt; 특성은 주석 유형의 두 값에 대한 올바른 순서가 존재하는 것을 알 수 있습니다. &lt;code&gt;Ord&lt;/code&gt; 구현에게 형질 &lt;code&gt;cmp&lt;/code&gt; 반환 방법, &lt;code&gt;Ordering&lt;/code&gt; 보다는 &lt;code&gt;Option&amp;lt;Ordering&amp;gt;&lt;/code&gt; 올바른 순서는 항상 가능하기 때문. 경우에만 적용 할 수 있습니다 &lt;code&gt;Ord&lt;/code&gt; 도 구현 유형 특성을 &lt;code&gt;PartialOrd&lt;/code&gt; 와 &lt;code&gt;Eq&lt;/code&gt; (그리고 &lt;code&gt;Eq&lt;/code&gt; 필요 &lt;code&gt;PartialEq&lt;/code&gt; 을 ). 구조체와 열거 형에서 파생 된 &lt;code&gt;cmp&lt;/code&gt; 는 &lt;code&gt;partial_cmp&lt;/code&gt; 에 대한 파생 구현 이 &lt;code&gt;PartialOrd&lt;/code&gt; 와 동일한 방식으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="711a8eb9ad73721345ff8b7d5d49057eb05ba2c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Orphan Check&lt;/code&gt; states that every trait implementation must meet either of the following conditions:</source>
          <target state="translated">&lt;code&gt;Orphan Check&lt;/code&gt; 모든 특성 구현이 다음 조건 중 하나에 부합해야합니다 상태 :</target>
        </trans-unit>
        <trans-unit id="c00d178bf6b2317cc12ea4871792b476ee2d6ac7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialEq&lt;/code&gt; trait allows you to compare instances of a type to check for equality and enables use of the &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; operators.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; 당신이 어떤지를 확인하는 유형의 인스턴스를 비교할 수 있습니다 및 사용 가능 특성 &lt;code&gt;==&lt;/code&gt; 와 &lt;code&gt;!=&lt;/code&gt; 연산자를.</target>
        </trans-unit>
        <trans-unit id="43e89dc3eb492904f3da074b02b2cf97b105430c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialEq&lt;/code&gt; trait is required, for example, with the use of the &lt;code&gt;assert_eq!&lt;/code&gt; macro, which needs to be able to compare two instances of a type for equality.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; 의 특성은의 사용으로, 예를 들어, 필요 &lt;code&gt;assert_eq!&lt;/code&gt; 매크로는 유형의 두 인스턴스가 동일한 지 비교할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a3b5763e3772b503d126748c966660daf7b02e86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialOrd&lt;/code&gt; trait allows you to compare instances of a type for sorting purposes. A type that implements &lt;code&gt;PartialOrd&lt;/code&gt; can be used with the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; operators. You can only apply the &lt;code&gt;PartialOrd&lt;/code&gt; trait to types that also implement &lt;code&gt;PartialEq&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PartialOrd&lt;/code&gt; 의 특성은 당신이 목적을 정렬 유형의 인스턴스를 비교할 수 있습니다. &lt;code&gt;PartialOrd&lt;/code&gt; 를 구현하는 형식 은 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;=&lt;/code&gt; 연산자 와 함께 사용할 수 있습니다 . 경우에만 적용 할 수 있습니다 &lt;code&gt;PartialOrd&lt;/code&gt; 의 도 구현 유형 특성을 &lt;code&gt;PartialEq&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="d44604638bc3e14fe0790aae9645322a35831c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialOrd&lt;/code&gt; trait is required, for example, for the &lt;code&gt;gen_range&lt;/code&gt; method from the &lt;code&gt;rand&lt;/code&gt; crate that generates a random value in the range specified by a low value and a high value.</source>
          <target state="translated">&lt;code&gt;PartialOrd&lt;/code&gt; 의 특성은, 예를 들면, 필요 &lt;code&gt;gen_range&lt;/code&gt; 용 로부터있어서 &lt;code&gt;rand&lt;/code&gt; 낮은 값과 높은 값에 의해 지정된 범위 내의 임의의 값을 생성 상자.</target>
        </trans-unit>
        <trans-unit id="aa9b33d349ddf99a4aba8a405103bf7fb4c6e253" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pointer&lt;/code&gt; trait should format its output as a memory location. This is commonly presented as hexadecimal.</source>
          <target state="translated">&lt;code&gt;Pointer&lt;/code&gt; 특징은 메모리 위치로의 출력을 포맷한다. 이것은 일반적으로 16 진수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ab8bbad2b08fc48ec0e5ed2730d22da62501a267" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt;&lt;code&gt;start..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt; and &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It is empty unless &lt;code&gt;start &amp;lt; end&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Range&lt;/code&gt; &lt;code&gt;start..end&lt;/code&gt; 모든 값을 포함 &lt;code&gt;x &amp;gt;= start&lt;/code&gt; 하고 &lt;code&gt;x &amp;lt; end&lt;/code&gt; . &lt;code&gt;start &amp;lt; end&lt;/code&gt; 가 아니면 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2aa0761be84214baf72bdc665e4aaa54d88ab96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeFrom&lt;/code&gt;&lt;code&gt;start..&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RangeFrom&lt;/code&gt; 의 &lt;code&gt;start..&lt;/code&gt; 모든 값을 포함하는 &lt;code&gt;x &amp;gt;= start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73c149dd90366bce823890f694cf867f1bb0a225" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeInclusive&lt;/code&gt;&lt;code&gt;start..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt; and &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It is empty unless &lt;code&gt;start &amp;lt;= end&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RangeInclusive&lt;/code&gt; &lt;code&gt;start..=end&lt;/code&gt; 모든 값을 포함 &lt;code&gt;x &amp;gt;= start&lt;/code&gt; 하고 &lt;code&gt;x &amp;lt;= end&lt;/code&gt; . &lt;code&gt;start &amp;lt;= end&lt;/code&gt; 아니면 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cec61b7c44a745e689ab10fff029089cd54c5d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeTo&lt;/code&gt;&lt;code&gt;..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">&lt;code&gt;RangeTo&lt;/code&gt; 의 &lt;code&gt;..end&lt;/code&gt; 은 모든 값을 포함 &lt;code&gt;x &amp;lt; end&lt;/code&gt; . 시작점이 없기 때문에 &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 로 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0de78a1c773797166ef937a052ccd5e9331c867f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeTo&lt;/code&gt;&lt;code&gt;..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">&lt;code&gt;RangeTo&lt;/code&gt; 의 &lt;code&gt;..end&lt;/code&gt; 은 모든 값을 포함 &lt;code&gt;x &amp;lt; end&lt;/code&gt; . 시작점이 없기 때문에 &lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 역할을 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8e2d4326e8450b1f620c09e80702de680708776b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeToInclusive&lt;/code&gt;&lt;code&gt;..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">&lt;code&gt;RangeToInclusive&lt;/code&gt; &lt;code&gt;..=end&lt;/code&gt; 모든 값을 포함 &lt;code&gt;x &amp;lt;= end&lt;/code&gt; . 시작점이 없기 때문에 &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 로 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0729997e88bb0119e0af233dfbcdefc61396cf4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeToInclusive&lt;/code&gt;&lt;code&gt;..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">&lt;code&gt;RangeToInclusive&lt;/code&gt; &lt;code&gt;..=end&lt;/code&gt; 모든 값을 포함 &lt;code&gt;x &amp;lt;= end&lt;/code&gt; . 시작점이 없기 때문에 &lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 역할을 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ebdc80637c460a3fe51040149db057ee546f653a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Rc::clone(&amp;amp;from)&lt;/code&gt; syntax is the most idiomatic because it conveys more explicitly the meaning of the code. In the example above, this syntax makes it easier to see that this code is creating a new reference rather than copying the whole content of foo.</source>
          <target state="translated">&lt;code&gt;Rc::clone(&amp;amp;from)&lt;/code&gt; 좀 더 명시 적으로 코드의 의미를 전달하기 때문에 구문은 대부분의 관용적이다. 위 예제에서이 구문을 사용하면이 코드가 foo의 전체 내용을 복사하지 않고 새로운 참조를 작성하고 있음을 쉽게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d18566a4555f118c35b2f7296c41294a80e62f05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; trait allows for reading bytes from a source.</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; 특성은 소스에서 바이트를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="167de79249a0cb690644cc2f30f26fd674ac84c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; keeps track of how many &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointers are currently active. Every time we call &lt;code&gt;borrow&lt;/code&gt;, the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; increases its count of how many immutable borrows are active. When a &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope, the count of immutable borrows goes down by one. Just like the compile-time borrowing rules, &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; lets us have many immutable borrows or one mutable borrow at any point in time.</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 의 추적 얼마나 많은 &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; 와 &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; 스마트 포인터가 현재 활성 상태입니다. 우리가 전화를 할 때마다 &lt;code&gt;borrow&lt;/code&gt; 의 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 많은 불변의 차용이 활성화 방법의 수를 증가시킨다. 때 &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; 값이 범위를 벗어나, 불변 차용의 카운트는 1 씩 아래로 진행한다. 컴파일 타임 차용 ​​규칙과 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 사용하면 언제든지 많은 불변의 차용 또는 하나의 변경 가능한 차용을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e6771afd6b14e03fc38f6d16106ee1f97bd4cbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&lt;/code&gt; is already immutably borrowed, so this cannot fail.</source>
          <target state="translated">&lt;code&gt;RefCell&lt;/code&gt; 는 이미 불변 빌려, 그래서 이것은 실패 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c305974ea6149ae71e2c43fcd219e993594dd96e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&lt;/code&gt; is already mutably borrowed, so this cannot fail.</source>
          <target state="translated">&lt;code&gt;RefCell&lt;/code&gt; 는 이미 mutably 빌려, 그래서 이것은 실패 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="52b1edfc20b8e3433cc429a2a34dab08626e2ce2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&amp;lt;..., Error&amp;gt;&lt;/code&gt; is repeated a lot. As such, &lt;code&gt;std::io&lt;/code&gt; has this type of alias declaration:</source>
          <target state="translated">&lt;code&gt;Result&amp;lt;..., Error&amp;gt;&lt;/code&gt; 많이 반복한다. 따라서 &lt;code&gt;std::io&lt;/code&gt; 에는 다음 유형의 별칭 선언이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e71572578c618ddeccc701e84d14574b4552896" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&lt;/code&gt; enum is generic over two types, &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt;, and has two variants: &lt;code&gt;Ok&lt;/code&gt;, which holds a value of type &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;Err&lt;/code&gt;, which holds a value of type &lt;code&gt;E&lt;/code&gt;. This definition makes it convenient to use the &lt;code&gt;Result&lt;/code&gt; enum anywhere we have an operation that might succeed (return a value of some type &lt;code&gt;T&lt;/code&gt;) or fail (return an error of some type &lt;code&gt;E&lt;/code&gt;). In fact, this is what we used to open a file in Listing 9-3, where &lt;code&gt;T&lt;/code&gt; was filled in with the type &lt;code&gt;std::fs::File&lt;/code&gt; when the file was opened successfully and &lt;code&gt;E&lt;/code&gt; was filled in with the type &lt;code&gt;std::io::Error&lt;/code&gt; when there were problems opening the file.</source>
          <target state="translated">&lt;code&gt;Result&lt;/code&gt; 열거 두 종류 이상의 제네릭 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;E&lt;/code&gt; , 그리고 두 가지 변종이 있습니다 &lt;code&gt;Ok&lt;/code&gt; 유형의 값 보유, &lt;code&gt;T&lt;/code&gt; , 및 &lt;code&gt;Err&lt;/code&gt; 형의 값을 보유하고, &lt;code&gt;E&lt;/code&gt; 를 . 이 정의를 사용하면 성공 ( &lt;code&gt;T&lt;/code&gt; 유형의 값을 반환 ) 또는 실패 (일부 유형 &lt;code&gt;E&lt;/code&gt; 의 오류를 반환) 할 수있는 작업이있는 모든 위치 에서 &lt;code&gt;Result&lt;/code&gt; 열거 형을 편리하게 사용할 수 있습니다 . 사실, 이것은 우리가 목록 9-3에서 파일을 여는 데 사용되는 것입니다 &lt;code&gt;T&lt;/code&gt; 는 종류에 기입 된 &lt;code&gt;std::fs::File&lt;/code&gt; 파일이 성공적으로 열릴 때 &lt;code&gt;E&lt;/code&gt; 파일을 여는 데 문제가있을 때 &lt;code&gt;std::io::Error&lt;/code&gt; 유형으로 채워졌습니다 .</target>
        </trans-unit>
        <trans-unit id="67d17ec2155cc71f4cbd159b4631b04d17855080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&lt;/code&gt; types are &lt;a href=&quot;ch06-00-enums&quot;&gt;&lt;em&gt;enumerations&lt;/em&gt;&lt;/a&gt;, often referred to as &lt;em&gt;enums&lt;/em&gt;. An enumeration is a type that can have a fixed set of values, and those values are called the enum&amp;rsquo;s &lt;em&gt;variants&lt;/em&gt;. Chapter 6 will cover enums in more detail.</source>
          <target state="translated">&lt;code&gt;Result&lt;/code&gt; 유형은 &lt;a href=&quot;ch06-00-enums&quot;&gt;&lt;em&gt;열거&lt;/em&gt;&lt;/a&gt; 종종 언급 &lt;em&gt;열거&lt;/em&gt; . 열거 형은 고정 된 값 세트를 가질 수있는 유형이며, 이러한 값을 열거 형 &lt;em&gt;variant&lt;/em&gt; 라고합니다 . 6 장에서는 열거 형에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="64d4c779a9a53da0609d26369514238e751f0a8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Seek&lt;/code&gt; trait provides a cursor which can be moved within a stream of bytes.</source>
          <target state="translated">는 &lt;code&gt;Seek&lt;/code&gt; 특성 바이트의 스트림 내에서 이동할 수있는 커서를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="45132395a8da1a9af17f15db9b29d073d0c74c5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword is an alias for the type we&amp;rsquo;re implementing the traits or methods on. Trait objects must be object safe because once you&amp;rsquo;ve used a trait object, Rust no longer knows the concrete type that&amp;rsquo;s implementing that trait. If a trait method returns the concrete &lt;code&gt;Self&lt;/code&gt; type, but a trait object forgets the exact type that &lt;code&gt;Self&lt;/code&gt; is, there is no way the method can use the original concrete type. The same is true of generic type parameters that are filled in with concrete type parameters when the trait is used: the concrete types become part of the type that implements the trait. When the type is forgotten through the use of a trait object, there is no way to know what types to fill in the generic type parameters with.</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; 키워드는 우리의 특성 또는 방법을 구현하고있는 유형의 별칭입니다. 특성 개체를 사용한 후에는 특성을 구현하는 콘크리트 유형을 더 이상 알 수 없으므로 특성 개체는 개체 안전해야합니다. 특성 메소드가 구체적 &lt;code&gt;Self&lt;/code&gt; 유형을 리턴 하지만 특성 오브젝트가 &lt;code&gt;Self&lt;/code&gt; 와 동일한 유형을 잊어 버린 경우 메소드가 원래 콘크리트 유형을 사용할 수있는 방법이 없습니다. 특성이 사용될 때 콘크리트 유형 매개 변수로 채워지는 일반 유형 매개 변수의 경우에도 마찬가지입니다. 콘크리트 유형은 특성을 구현하는 유형의 일부가됩니다. 특성 오브젝트를 사용하여 유형을 잊어 버린 경우 일반 유형 매개 변수를 채울 유형을 알 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="90a76b71efb75f391d26231783f81feb6c797a7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword represents the current type, which explains why it can only be used inside an impl, trait, or type definition. It gives access to the associated items of a type:</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; 키워드가 단지 IMPL, 특성, 또는 형식 정의 내에서 사용할 수있는 이유를 설명 현재의 형태를 나타냅니다. 유형의 관련 항목에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a02332e854d71300403fa93482ff8605d97eadb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword was used outside an impl, trait, or type definition.</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; 키워드는 IMPL, 특성, 또는 형식 정의 외부에 사용되었다.</target>
        </trans-unit>
        <trans-unit id="6a3c6ecd1deb9539342b4b667c8f7da5207114d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; term can be replaced with the type being implemented.</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; 용어는 타입이 구현되고 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="268068ec98ee8d589f1d0d25a4fa87cb52fefae1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; terminal in this grammar denotes a type resolving to the implementing type. This can also include the contextual type alias &lt;code&gt;Self&lt;/code&gt;, other type aliases, or associated type projections resolving to the implementing type.</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; 이 문법 단말기는 실시 형태에 해결 타입을 나타낸다. 여기에는 컨텍스트 형식 별칭 &lt;code&gt;Self&lt;/code&gt; , 기타 형식 별칭 또는 구현 형식으로 확인되는 관련 형식 프로젝션 이 포함될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d50619fe26b234beecf764a55ec164440b77b3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Send&lt;/code&gt; marker trait indicates that ownership of the type implementing &lt;code&gt;Send&lt;/code&gt; can be transferred between threads. Almost every Rust type is &lt;code&gt;Send&lt;/code&gt;, but there are some exceptions, including &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;: this cannot be &lt;code&gt;Send&lt;/code&gt; because if you cloned an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value and tried to transfer ownership of the clone to another thread, both threads might update the reference count at the same time. For this reason, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is implemented for use in single-threaded situations where you don&amp;rsquo;t want to pay the thread-safe performance penalty.</source>
          <target state="translated">&lt;code&gt;Send&lt;/code&gt; 유형 구현의 소유권을 나타냅니다 특성 마커 &lt;code&gt;Send&lt;/code&gt; 스레드 사이에 전송 될 수있다. 거의 모든 녹 유형이 &lt;code&gt;Send&lt;/code&gt; 만 등 일부 예외가 있습니다 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; :이 될 수 없습니다 &lt;code&gt;Send&lt;/code&gt; 당신이 복제 된 경우 때문에 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 값을 다른 스레드 클론의 소유권 이전에 시도, 두 스레드가를 업데이트 할 수 있습니다 동시에 참조 카운트. 이러한 이유로 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 는 스레드 안전성 성능 저하를 원하지 않는 단일 스레드 상황에서 사용하도록 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="da7504f8cf4ba12a9f166abe295fe49d0cc29f7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sized&lt;/code&gt; trait is a special trait built-in to the compiler for types with a constant size known at compile-time. This trait is automatically implemented for types as needed by the compiler, and it is currently disallowed to explicitly implement it for a type.</source>
          <target state="translated">&lt;code&gt;Sized&lt;/code&gt; 특성은 내장 유형에 대한 컴파일러에 대한 컴파일 타임에 일정한 크기의 특별한 특징이다. 이 특성은 컴파일러에서 필요에 따라 유형에 대해 자동으로 구현되며 현재 유형에 대해 명시 적으로 구현할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="faed9283b4f09789ea3439cf47c62be8b01765b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sized&lt;/code&gt; trait was implemented explicitly.</source>
          <target state="translated">&lt;code&gt;Sized&lt;/code&gt; 특성은 명시 적으로 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="57ed07b6ec3a8248f3dbedbfe819f564dab9a89c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Some(5)&lt;/code&gt; value doesn&amp;rsquo;t match the pattern &lt;code&gt;None&lt;/code&gt;, so we continue to the next arm.</source>
          <target state="translated">&lt;code&gt;Some(5)&lt;/code&gt; 값은 패턴과 일치하지 않습니다 &lt;code&gt;None&lt;/code&gt; 우리는 다음 팔을 계속, 그래서.</target>
        </trans-unit>
        <trans-unit id="5cf7d1bcd1b02d8684f384aeb150bd3c1fada36f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;State&lt;/code&gt; trait defines the behavior shared by different post states, and the &lt;code&gt;Draft&lt;/code&gt;, &lt;code&gt;PendingReview&lt;/code&gt;, and &lt;code&gt;Published&lt;/code&gt; states will all implement the &lt;code&gt;State&lt;/code&gt; trait. For now, the trait doesn&amp;rsquo;t have any methods, and we&amp;rsquo;ll start by defining just the &lt;code&gt;Draft&lt;/code&gt; state because that is the state we want a post to start in.</source>
          <target state="translated">&lt;code&gt;State&lt;/code&gt; 특성은 서로 다른 후 상태가 공유하는 동작을 정의하고, &lt;code&gt;Draft&lt;/code&gt; , &lt;code&gt;PendingReview&lt;/code&gt; 및 &lt;code&gt;Published&lt;/code&gt; 상태는 모두 구현할 &lt;code&gt;State&lt;/code&gt; 특성을. 지금은이 특성에 메소드가 없으며, &lt;code&gt;Draft&lt;/code&gt; 상태 만 정의 하여 시작합니다. 그 이유는 게시물을 시작하려는 상태이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a99c80ac2ff235e2978574f670cbd4660bb61703" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type implements the &lt;code&gt;Clone&lt;/code&gt; trait, and when we call the &lt;code&gt;clone&lt;/code&gt; method on an instance of &lt;code&gt;String&lt;/code&gt; we get back an instance of &lt;code&gt;String&lt;/code&gt;. Similarly, if we call &lt;code&gt;clone&lt;/code&gt; on an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, we get back an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. The signature of &lt;code&gt;clone&lt;/code&gt; needs to know what type will stand in for &lt;code&gt;Self&lt;/code&gt;, because that&amp;rsquo;s the return type.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 타입 구현하는 &lt;code&gt;Clone&lt;/code&gt; 의 특성, 우리가 호출 할 때 &lt;code&gt;clone&lt;/code&gt; 의 인스턴스에 방법을 &lt;code&gt;String&lt;/code&gt; 우리의 인스턴스 돌아가 &lt;code&gt;String&lt;/code&gt; . 우리가 호출하는 경우 마찬가지로, &lt;code&gt;clone&lt;/code&gt; 의 인스턴스에 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , 우리의 인스턴스 돌아 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; . &lt;code&gt;clone&lt;/code&gt; 의 서명은 반환 유형이기 때문에 &lt;code&gt;Self&lt;/code&gt; 에 어떤 유형의 스탠드가 필요한지 알아야 합니다.</target>
        </trans-unit>
        <trans-unit id="ce3a0f98cdb5c97fe7ff53bab286ef96b0a0614f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type is the most common string type that has ownership over the contents of the string. It has a close relationship with its borrowed counterpart, the primitive &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 타입은 문자열의 내용 소유권을 가지고있는 가장 일반적인 문자열 유형입니다. 빌린 대응하는 원시적 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 과 밀접한 관계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="75cb7ba1e6deab5f4a0c4ef1dddcb7ea6d8d2520" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type, which is provided by Rust&amp;rsquo;s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type. When Rustaceans refer to &amp;ldquo;strings&amp;rdquo; in Rust, they usually mean the &lt;code&gt;String&lt;/code&gt; and the string slice &lt;code&gt;&amp;amp;str&lt;/code&gt; types, not just one of those types. Although this section is largely about &lt;code&gt;String&lt;/code&gt;, both types are used heavily in Rust&amp;rsquo;s standard library, and both &lt;code&gt;String&lt;/code&gt; and string slices are UTF-8 encoded.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 핵심 언어로 녹의 표준 라이브러리가 제공하는 것이 아니라 코딩 유형은, 가변 장, 가변, 소유, UTF-8 인코딩 된 문자열 유형입니다. Rustaceans가 Rust에서 &quot;문자열&quot;을 언급 할 때, 이들은 보통 해당 유형 중 하나가 아니라 &lt;code&gt;String&lt;/code&gt; 및 문자열 슬라이스 &lt;code&gt;&amp;amp;str&lt;/code&gt; 유형을 의미합니다 . 이 섹션은 주로 &lt;code&gt;String&lt;/code&gt; 에 관한 것이지만 두 유형 모두 Rust의 표준 라이브러리에서 많이 사용되며 &lt;code&gt;String&lt;/code&gt; 및 문자열 슬라이스는 모두 UTF-8로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="e2f29f1c300ba36b21c6a01062d991f47ee83fd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; traits, which extend Rust&amp;rsquo;s concurrency guarantees to user-defined types as well as types provided by the standard library</source>
          <target state="translated">&lt;code&gt;Sync&lt;/code&gt; 및 &lt;code&gt;Send&lt;/code&gt; 표준 라이브러리에서 제공하는 사용자 정의 형식뿐만 아니라 종류에 녹의 동시성 보장을 확장 특성,</target>
        </trans-unit>
        <trans-unit id="546dfd59f5dde2a2d3bad5396a6d76cbe9696aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sync&lt;/code&gt; marker trait indicates that it is safe for the type implementing &lt;code&gt;Sync&lt;/code&gt; to be referenced from multiple threads. In other words, any type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; if &lt;code&gt;&amp;amp;T&lt;/code&gt; (a reference to &lt;code&gt;T&lt;/code&gt;) is &lt;code&gt;Send&lt;/code&gt;, meaning the reference can be sent safely to another thread. Similar to &lt;code&gt;Send&lt;/code&gt;, primitive types are &lt;code&gt;Sync&lt;/code&gt;, and types composed entirely of types that are &lt;code&gt;Sync&lt;/code&gt; are also &lt;code&gt;Sync&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Sync&lt;/code&gt; 마커 특성이 구현하는 유형의 안전을 나타냅니다 &lt;code&gt;Sync&lt;/code&gt; 여러 스레드에서 참조 할 수 있습니다. 즉, 어떤 종류의 &lt;code&gt;T&lt;/code&gt; 는 것입니다 &lt;code&gt;Sync&lt;/code&gt; 경우 &lt;code&gt;&amp;amp;T&lt;/code&gt; (참조 &lt;code&gt;T&lt;/code&gt; )된다 &lt;code&gt;Send&lt;/code&gt; , 참조를 의미하는 다른 스레드에 안전하게 보낼 수 있습니다. 유사 &lt;code&gt;Send&lt;/code&gt; , 기본 유형은 &lt;code&gt;Sync&lt;/code&gt; , 그리고 완전히이다 유형으로 구성 유형의 &lt;code&gt;Sync&lt;/code&gt; 또한 &lt;code&gt;Sync&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="646e9a46a3198e5aae6cea0647712ac157d7125f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; are generic type parameters: we&amp;rsquo;ll discuss generics in more detail in Chapter 10. What you need to know right now is that &lt;code&gt;T&lt;/code&gt; represents the type of the value that will be returned in a success case within the &lt;code&gt;Ok&lt;/code&gt; variant, and &lt;code&gt;E&lt;/code&gt; represents the type of the error that will be returned in a failure case within the &lt;code&gt;Err&lt;/code&gt; variant. Because &lt;code&gt;Result&lt;/code&gt; has these generic type parameters, we can use the &lt;code&gt;Result&lt;/code&gt; type and the functions that the standard library has defined on it in many different situations where the successful value and error value we want to return may differ.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;E&lt;/code&gt; 는 제네릭 형식 매개 변수입니다 : 우리는 당신이 있다는 것입니다 지금 알아야 할 사항 제 10 장에서 더 자세히 제네릭을 논의 할 것이다 &lt;code&gt;T&lt;/code&gt; 는 내에서 성공하는 경우에 반환되는 값의 유형을 나타내는 &lt;code&gt;Ok&lt;/code&gt; 변형, 및 &lt;code&gt;E&lt;/code&gt; 는 내의 고장시 반환되는 오류 유형 나타내는 &lt;code&gt;Err&lt;/code&gt; 변형. 때문에 &lt;code&gt;Result&lt;/code&gt; 이러한 제네릭 형식 매개 변수가, 우리가 사용할 수있는 &lt;code&gt;Result&lt;/code&gt; 유형 및 반환에 우리가 원하는 성공 값 및 오류 값이 다를 수 있습니다 경우 표준 라이브러리는 여러 가지 상황에서 정의했다고 기능을.</target>
        </trans-unit>
        <trans-unit id="cb756122c49feafba4692e36792c9ec503818ac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Thread&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="fadb7c71117e778367444a0d18f0442e8249124b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ThreadPool&lt;/code&gt; will create a channel and hold on to the sending side of the channel.</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; 채널을 생성하고, 채널의 송신 측에 유지된다.</target>
        </trans-unit>
        <trans-unit id="e48c39ae08cbb88aef00b305b9017512b2fc007b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnsafeCell&lt;/code&gt; API itself is technically very simple: &lt;a href=&quot;struct.unsafecell#method.get&quot;&gt;&lt;code&gt;.get()&lt;/code&gt;&lt;/a&gt; gives you a raw pointer &lt;code&gt;*mut T&lt;/code&gt; to its contents. It is up to &lt;em&gt;you&lt;/em&gt; as the abstraction designer to use that raw pointer correctly.</source>
          <target state="translated">&lt;code&gt;UnsafeCell&lt;/code&gt; 의 : API 자체는 기술적으로 매우 간단합니다 &lt;a href=&quot;struct.unsafecell#method.get&quot;&gt; &lt;code&gt;.get()&lt;/code&gt; &lt;/a&gt; 당신에게 원시 포인터를 제공합니다 &lt;code&gt;*mut T&lt;/code&gt; 의 내용을. 그것은까지입니다 &lt;em&gt;당신이&lt;/em&gt; 제대로 그 원시 포인터를 사용하는 추상화 디자이너로.</target>
        </trans-unit>
        <trans-unit id="6a5cd0207b32d758dbbf9a6159c66155c77acce0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnsafeCell&lt;/code&gt; API itself is technically very simple: it gives you a raw pointer &lt;code&gt;*mut T&lt;/code&gt; to its contents. It is up to &lt;em&gt;you&lt;/em&gt; as the abstraction designer to use that raw pointer correctly.</source>
          <target state="translated">&lt;code&gt;UnsafeCell&lt;/code&gt; 의 API 자체는 기술적으로 매우 간단하다 : 그것은 당신에게 원시 포인터를 제공합니다 &lt;code&gt;*mut T&lt;/code&gt; 의 내용을. 원시 포인터를 올바르게 사용하는 것은 추상화 디자이너로서 &lt;em&gt;귀하에게&lt;/em&gt; 달려 &lt;em&gt;있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0a41c6aadefabb63fa74ac6fccd4136ec47ca08f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UpperExp&lt;/code&gt; trait should format its output in scientific notation with an upper-case &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;UpperExp&lt;/code&gt; 이 특성은 상부 케이스와 과학적 표기법의 출력을 포맷한다 &lt;code&gt;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c532f0150ba601cb070b0fc006c6b873d809aeda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UpperHex&lt;/code&gt; trait should format its output as a number in hexadecimal, with &lt;code&gt;A&lt;/code&gt; through &lt;code&gt;F&lt;/code&gt; in upper case.</source>
          <target state="translated">&lt;code&gt;UpperHex&lt;/code&gt; 의 특성을 가진 16 진수 숫자로의 출력 포맷한다 내지 &lt;code&gt;F&lt;/code&gt; 를 대문자. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1692dc51a2dd0859a66b3a15d1e8df4859265ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vec&lt;/code&gt; type allows to access values by index, because it implements the &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; trait. An example will be more explicit:</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; 가 구현하므로 유형은 인덱스로 액세스 값을 허용 &lt;a href=&quot;../ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; 특성을. 보다 명확한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fdf15f1d79f5be8a81ff6d7d469c446ffbe09215" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_&lt;/code&gt; pattern will match any value. By putting it after our other arms, the &lt;code&gt;_&lt;/code&gt; will match all the possible cases that aren&amp;rsquo;t specified before it. The &lt;code&gt;()&lt;/code&gt; is just the unit value, so nothing will happen in the &lt;code&gt;_&lt;/code&gt; case. As a result, we can say that we want to do nothing for all the possible values that we don&amp;rsquo;t list before the &lt;code&gt;_&lt;/code&gt; placeholder.</source>
          <target state="translated">&lt;code&gt;_&lt;/code&gt; 패턴은 모든 값을 일치합니다. &lt;code&gt;_&lt;/code&gt; 를 다른 팔 뒤에 놓으면 _ 는 이전에 지정되지 않은 모든 가능한 경우와 일치합니다. 는 &lt;code&gt;()&lt;/code&gt; 아무것도에서 발생하지 않게, 단지 단위 값입니다 &lt;code&gt;_&lt;/code&gt; 경우. 결과적으로, 우리는 &lt;code&gt;_&lt;/code&gt; 자리 표시 자 앞에 나열하지 않은 모든 가능한 값에 대해 아무 것도 원하지 않는다고 말할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4f623218e4e907b6db896a6ba8ba2e0737f6051" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;abort&lt;/code&gt; function terminates the process, so the destructor will not get run on the example below:</source>
          <target state="translated">&lt;code&gt;abort&lt;/code&gt; 소멸자는 아래의 예에서 실행되지 않도록 기능, 프로세스를 종료한다 :</target>
        </trans-unit>
        <trans-unit id="1da31d2d7b88dbadae1ea02224cc02bf279c6b4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add&lt;/code&gt; method adds the &lt;code&gt;x&lt;/code&gt; values of two &lt;code&gt;Point&lt;/code&gt; instances and the &lt;code&gt;y&lt;/code&gt; values of two &lt;code&gt;Point&lt;/code&gt; instances to create a new &lt;code&gt;Point&lt;/code&gt;. The &lt;code&gt;Add&lt;/code&gt; trait has an associated type named &lt;code&gt;Output&lt;/code&gt; that determines the type returned from the &lt;code&gt;add&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; 방법은 추가 &lt;code&gt;x&lt;/code&gt; 개의 값 &lt;code&gt;Point&lt;/code&gt; 인스턴스 및 &lt;code&gt;y&lt;/code&gt; 개의 값 &lt;code&gt;Point&lt;/code&gt; 새로운 인스턴스를 생성하는 &lt;code&gt;Point&lt;/code&gt; . &lt;code&gt;Add&lt;/code&gt; 특성은 이름이 연관된 유형이 &lt;code&gt;Output&lt;/code&gt; 으로부터 반환 유형 결정 &lt;code&gt;add&lt;/code&gt; 방법을.</target>
        </trans-unit>
        <trans-unit id="6b4f66cfe4d8578da648c05ce2a1d295046eb19d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add_text&lt;/code&gt; method takes a mutable reference to &lt;code&gt;self&lt;/code&gt;, because we&amp;rsquo;re changing the &lt;code&gt;Post&lt;/code&gt; instance that we&amp;rsquo;re calling &lt;code&gt;add_text&lt;/code&gt; on. We then call &lt;code&gt;push_str&lt;/code&gt; on the &lt;code&gt;String&lt;/code&gt; in &lt;code&gt;content&lt;/code&gt; and pass the &lt;code&gt;text&lt;/code&gt; argument to add to the saved &lt;code&gt;content&lt;/code&gt;. This behavior doesn&amp;rsquo;t depend on the state the post is in, so it&amp;rsquo;s not part of the state pattern. The &lt;code&gt;add_text&lt;/code&gt; method doesn&amp;rsquo;t interact with the &lt;code&gt;state&lt;/code&gt; field at all, but it is part of the behavior we want to support.</source>
          <target state="translated">&lt;code&gt;add_text&lt;/code&gt; 의 방법으로 변경 가능한 참조 소요 &lt;code&gt;self&lt;/code&gt; 우리가 변화하고 있기 때문에, &lt;code&gt;Post&lt;/code&gt; 우리가 호출하고 해당 인스턴스를 &lt;code&gt;add_text&lt;/code&gt; 을 에. 그런 다음 &lt;code&gt;content&lt;/code&gt; 의 &lt;code&gt;String&lt;/code&gt; 에서 &lt;code&gt;push_str&lt;/code&gt; 을 호출 하고 &lt;code&gt;text&lt;/code&gt; 인수를 전달 하여 저장된 &lt;code&gt;content&lt;/code&gt; 에 추가합니다 . 이 동작은 게시물의 상태에 의존하지 않으므로 상태 패턴의 일부가 아닙니다. &lt;code&gt;add_text&lt;/code&gt; 의 방법은 상호 작용하지 않는 &lt;code&gt;state&lt;/code&gt; 모두에서 필드,하지만 우리가 지원하려는 행동의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="2c3ad15ad6826ff34548cd3374a6a4eed3efc204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers can be used to respectively raise or lower the alignment of &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;union&lt;/code&gt;s. &lt;code&gt;packed&lt;/code&gt; may also alter the padding between fields.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; 과 &lt;code&gt;packed&lt;/code&gt; 개질제 높이거나 낮출의 배향 각각에 사용될 수있는 &lt;code&gt;struct&lt;/code&gt; 들 및 &lt;code&gt;union&lt;/code&gt; 들. &lt;code&gt;packed&lt;/code&gt; 은 필드 사이의 패딩을 변경할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e0634e43790fec0970517f968c2cdaea9942a64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers cannot be applied on the same type and a &lt;code&gt;packed&lt;/code&gt; type cannot transitively contain another &lt;code&gt;align&lt;/code&gt;ed type. &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; may only be applied to the &lt;a href=&quot;#the-default-representation&quot;&gt;default&lt;/a&gt; and &lt;a href=&quot;#the-c-representation&quot;&gt;&lt;code&gt;C&lt;/code&gt;&lt;/a&gt; representations.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; 과 &lt;code&gt;packed&lt;/code&gt; 개질제는 동일한 유형에 적용되지 않을 수 있고, &lt;code&gt;packed&lt;/code&gt; 타입 이적 다른 포함될 수 &lt;code&gt;align&lt;/code&gt; 혼성 유형. &lt;code&gt;align&lt;/code&gt; 및 &lt;code&gt;packed&lt;/code&gt; 은 &lt;a href=&quot;#the-default-representation&quot;&gt;기본&lt;/a&gt; 및 &lt;a href=&quot;#the-c-representation&quot;&gt; &lt;code&gt;C&lt;/code&gt; &lt;/a&gt; 표현 에만 적용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba365c1b081658cee386344e9e2a04962a51bb04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers cannot be applied on the same type and a &lt;code&gt;packed&lt;/code&gt; type cannot transitively contain another &lt;code&gt;align&lt;/code&gt;ed type. &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; may only be applied to the &lt;a href=&quot;type-layout#the-default-representation&quot;&gt;default&lt;/a&gt; and &lt;a href=&quot;type-layout#the-c-representation&quot;&gt;&lt;code&gt;C&lt;/code&gt;&lt;/a&gt; representations.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; 과 &lt;code&gt;packed&lt;/code&gt; 개질제는 동일한 유형에 적용되지 않을 수 있고, &lt;code&gt;packed&lt;/code&gt; 타입 이적 다른 포함될 수 &lt;code&gt;align&lt;/code&gt; 혼성 유형. &lt;code&gt;align&lt;/code&gt; 및 &lt;code&gt;packed&lt;/code&gt; 은 &lt;a href=&quot;type-layout#the-default-representation&quot;&gt;기본&lt;/a&gt; 및 &lt;a href=&quot;type-layout#the-c-representation&quot;&gt; &lt;code&gt;C&lt;/code&gt; &lt;/a&gt; 표현 에만 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="53e65577e1cfa4684ae0b49bee71e8da03a67fa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; modifier can also be applied on an &lt;code&gt;enum&lt;/code&gt;. When it is, the effect on the &lt;code&gt;enum&lt;/code&gt;'s alignment is the same as if the &lt;code&gt;enum&lt;/code&gt; was wrapped in a newtype &lt;code&gt;struct&lt;/code&gt; with the same &lt;code&gt;align&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; 수정은 또한 적용 할 수 &lt;code&gt;enum&lt;/code&gt; . 이 경우, 효과에 &lt;code&gt;enum&lt;/code&gt; 는 IF로의 정렬이 동일 &lt;code&gt;enum&lt;/code&gt; newtype이란 래핑 된 &lt;code&gt;struct&lt;/code&gt; 동일한 함께 &lt;code&gt;align&lt;/code&gt; 개질제.</target>
        </trans-unit>
        <trans-unit id="6ad8df46a380899eaf26791f29aae33e2b0b76bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amt&lt;/code&gt; must be &lt;code&gt;&amp;lt;=&lt;/code&gt; the number of bytes in the buffer returned by &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;amt&lt;/code&gt; 있어야 &lt;code&gt;&amp;lt;=&lt;/code&gt; 버퍼의 바이트 수에 의해 반환 &lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6cdd430203e5d1bc8171135295b8e6a12c3f9ccb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amt&lt;/code&gt; must be &lt;code&gt;&amp;lt;=&lt;/code&gt; the number of bytes in the buffer returned by &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;amt&lt;/code&gt; 있어야 &lt;code&gt;&amp;lt;=&lt;/code&gt; 버퍼의 바이트 수에 의해 반환 &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45b714d09b6da61ea117e3601d5d1e5fd89a8774" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;approve&lt;/code&gt; method will be similar to the &lt;code&gt;request_review&lt;/code&gt; method: it will set &lt;code&gt;state&lt;/code&gt; to the value that the current state says it should have when that state is approved, as shown in Listing 17-16:</source>
          <target state="translated">는 &lt;code&gt;approve&lt;/code&gt; 방법은 유사합니다 &lt;code&gt;request_review&lt;/code&gt; 의 방법은 설정합니다 &lt;code&gt;state&lt;/code&gt; 현재 상태가이 목록 17-16에서와 같이 그 상태가 승인되면이 있어야 말한다 값 :</target>
        </trans-unit>
        <trans-unit id="0d99e2697c98f4ee00d53c8602d75f85424ebe1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function accesses the &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; fields of the &lt;code&gt;Rectangle&lt;/code&gt; instance. Our function signature for &lt;code&gt;area&lt;/code&gt; now says exactly what we mean: calculate the area of &lt;code&gt;Rectangle&lt;/code&gt;, using its &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; fields. This conveys that the width and height are related to each other, and it gives descriptive names to the values rather than using the tuple index values of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. This is a win for clarity.</source>
          <target state="translated">&lt;code&gt;area&lt;/code&gt; 함수는 액세스 &lt;code&gt;width&lt;/code&gt; 과 &lt;code&gt;height&lt;/code&gt; 의 필드 &lt;code&gt;Rectangle&lt;/code&gt; 인스턴스. &lt;code&gt;area&lt;/code&gt; 에 대한 함수 시그니처는 이제 정확히 의미하는대로 &lt;code&gt;width&lt;/code&gt; 와 &lt;code&gt;height&lt;/code&gt; 필드를 사용하여 &lt;code&gt;Rectangle&lt;/code&gt; 의 면적을 계산 합니다. 이것은 너비와 높이가 서로 관련되어 있음을 전달하며 튜플 인덱스 값 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; 을 사용하는 대신 값에 설명적인 이름을 제공합니다 . 이것은 명확성을위한 승리입니다.</target>
        </trans-unit>
        <trans-unit id="f0f4d5c245d843fc107cb0d995f1cc0cbaafe380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function is supposed to calculate the area of one rectangle, but the function we wrote has two parameters. The parameters are related, but that&amp;rsquo;s not expressed anywhere in our program. It would be more readable and more manageable to group width and height together. We&amp;rsquo;ve already discussed one way we might do that in &lt;a href=&quot;ch03-02-data-types#the-tuple-type&quot;&gt;&amp;ldquo;The Tuple Type&amp;rdquo;&lt;/a&gt; section of Chapter 3: by using tuples.</source>
          <target state="translated">&lt;code&gt;area&lt;/code&gt; 기능을 하나 개의 사각형의 면적을 계산하기로되어 있지만, 우리가 작성한 함수는 두 개의 매개 변수를 가지고있다. 매개 변수는 관련되어 있지만 프로그램의 어느 곳에서도 표현되지 않았습니다. 너비와 높이를 함께 그룹화하는 것이 더 읽기 쉽고 관리하기 쉽습니다. 우리는 3 장의 &lt;a href=&quot;ch03-02-data-types#the-tuple-type&quot;&gt;&amp;ldquo;튜플 유형&amp;rdquo;&lt;/a&gt; 섹션에서 튜플을 사용하여 그렇게 할 수있는 한 가지 방법에 대해 이미 논의했습니다 .</target>
        </trans-unit>
        <trans-unit id="03663b761515431ad66c10f38033078682c6e595" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;art&lt;/code&gt; crate users can still see and use the internal structure from Listing 14-3 as demonstrated in Listing 14-4, or they can use the more convenient structure in Listing 14-5, as shown in Listing 14-6:</source>
          <target state="translated">&lt;code&gt;art&lt;/code&gt; 상자의 사용자는보고 목록 14-4에서 입증 된 바와 같이 리스팅 14-3에서 내부 구조를 사용하거나 14-6 목록과 같이 그들은 목록 14-5에서보다 편리 구조를 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e825da57c4a60047ea61533b7c1bd5bca8251591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; keyword can be used to change what the crate is referred to as in your project. If a crate name includes a dash, it is implicitly imported with the dashes replaced by underscores.</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; 키워드는 상자가 프로젝트의라고하는 내용을 변경하는 데 사용할 수 있습니다. 상자 이름에 대시가 포함 된 경우 대시를 밑줄로 대체하여 암시 적으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2dd2463e89570fe4f3bb6f6203a6c56b03267f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert!&lt;/code&gt; macro, provided by the standard library, is useful when you want to ensure that some condition in a test evaluates to &lt;code&gt;true&lt;/code&gt;. We give the &lt;code&gt;assert!&lt;/code&gt; macro an argument that evaluates to a Boolean. If the value is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;assert!&lt;/code&gt; does nothing and the test passes. If the value is &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;assert!&lt;/code&gt; macro calls the &lt;code&gt;panic!&lt;/code&gt; macro, which causes the test to fail. Using the &lt;code&gt;assert!&lt;/code&gt; macro helps us check that our code is functioning in the way we intend.</source>
          <target state="translated">&lt;code&gt;assert!&lt;/code&gt; 표준 라이브러리에서 제공하는 매크로는 테스트의 일부 조건이 &lt;code&gt;true&lt;/code&gt; 로 평가되도록하려는 경우에 유용 합니다 . 우리는 &lt;code&gt;assert!&lt;/code&gt; 매크로 부울로 평가되는 인수. 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;assert!&lt;/code&gt; 아무것도하지 않고 테스트는 통과합니다. 값이 &lt;code&gt;false&lt;/code&gt; 인 경우 &lt;code&gt;assert!&lt;/code&gt; 매크로는 &lt;code&gt;panic!&lt;/code&gt; 호출합니다 ! 매크로는 테스트에 실패합니다. &lt;code&gt;assert!&lt;/code&gt; 사용 ! 매크로는 코드가 의도 한대로 작동하는지 확인하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="95f1355f51c209910ea66191ec2fc57f92344bfc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert_ne!&lt;/code&gt; macro will pass if the two values we give it are not equal and fail if they&amp;rsquo;re equal. This macro is most useful for cases when we&amp;rsquo;re not sure what a value &lt;em&gt;will&lt;/em&gt; be, but we know what the value definitely &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; be if our code is functioning as we intend. For example, if we&amp;rsquo;re testing a function that is guaranteed to change its input in some way, but the way in which the input is changed depends on the day of the week that we run our tests, the best thing to assert might be that the output of the function is not equal to the input.</source>
          <target state="translated">&lt;code&gt;assert_ne!&lt;/code&gt; 우리가 제공 한 두 값이 같지 않으면 매크로가 통과하고 같으면 실패합니다. 이 매크로는 값 &lt;em&gt;이&lt;/em&gt; 무엇인지 확실하지 않은 경우에 가장 유용 하지만 코드가 의도 한대로 작동하면 값이 확실 &lt;em&gt;하지 않은&lt;/em&gt; 것을 알고 있습니다. 예를 들어, 어떤 식 으로든 입력을 변경할 수있는 함수를 테스트하고 있지만 입력을 변경하는 방법이 테스트를 실행하는 요일에 따라 달라지는 경우 가장 좋은 주장은 함수의 출력이 입력과 같지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf35e012d7004404479ddec49cb6abc4ee90bc1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; function in this scenario works like the &lt;code&gt;new&lt;/code&gt; function in that it will return a new &lt;code&gt;TcpListener&lt;/code&gt; instance. The reason the function is called &lt;code&gt;bind&lt;/code&gt; is that in networking, connecting to a port to listen to is known as &amp;ldquo;binding to a port.&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;bind&lt;/code&gt; 이 시나리오의 기능은 같은 작품 &lt;code&gt;new&lt;/code&gt; 가 새 돌려 보낼 함수 &lt;code&gt;TcpListener&lt;/code&gt; 의 인스턴스를. 이 기능을 &lt;code&gt;bind&lt;/code&gt; 라고 하는 이유는 네트워킹에서 수신 대기하는 포트에 연결하는 것을 &quot;포트에 바인딩&quot;이라고하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3a9db4154e7cfc914c7af74a70f78787dc149e27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; function returns a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, which indicates that binding might fail. For example, connecting to port 80 requires administrator privileges (nonadministrators can listen only on ports higher than 1024), so if we tried to connect to port 80 without being an administrator, binding wouldn&amp;rsquo;t work. As another example, binding wouldn&amp;rsquo;t work if we ran two instances of our program and so had two programs listening to the same port. Because we&amp;rsquo;re writing a basic server just for learning purposes, we won&amp;rsquo;t worry about handling these kinds of errors; instead, we use &lt;code&gt;unwrap&lt;/code&gt; to stop the program if errors happen.</source>
          <target state="translated">&lt;code&gt;bind&lt;/code&gt; 함수가 반환하는 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; , 바인딩 실패 할 수 있음을 나타냅니다. 예를 들어 포트 80에 연결하려면 관리자 권한이 필요합니다 (비 관리자는 1024보다 높은 포트에서만 수신 할 수 있음). 관리자가 아닌 포트 80에 연결하려고하면 바인딩이 작동하지 않습니다. 또 다른 예로, 프로그램의 두 인스턴스를 실행하여 두 개의 프로그램이 동일한 포트를 수신하는 경우 바인딩이 작동하지 않습니다. 학습 목적으로 만 기본 서버를 작성하기 때문에 이러한 종류의 오류 처리에 대해 걱정하지 않아도됩니다. 대신 오류가 발생하면 &lt;code&gt;unwrap&lt;/code&gt; 을 사용 하여 프로그램을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="86e869ec27553a2645d530ee9b57e980ad085326" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool&lt;/code&gt; represents a value, which could only be either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. If you cast a &lt;code&gt;bool&lt;/code&gt; into an integer, &lt;code&gt;true&lt;/code&gt; will be 1 and &lt;code&gt;false&lt;/code&gt; will be 0.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 단지가 될 수있는 값을 나타내는 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;bool&lt;/code&gt; 을 정수로 캐스트하면 &lt;code&gt;true&lt;/code&gt; 는 1이고 &lt;code&gt;false&lt;/code&gt; 는 0입니다.</target>
        </trans-unit>
        <trans-unit id="d4311662fb8a13303491e364af26bcbe8200bef8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool&lt;/code&gt; type is a datatype which can be either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. The boolean type uses one byte of memory. It is used in comparisons and bitwise operations like &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 유형이 될 수있는 데이터 형이며, &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; . 부울 형식은 1 바이트의 메모리를 사용합니다. &lt;code&gt;&amp;amp;&lt;/code&gt; 와 같은 비교 및 ​​비트 연산에 사용됩니다 . &lt;code&gt;|&lt;/code&gt; , 그리고 &lt;code&gt;!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71b45beaeed4f4e8bb8cb42d1eee7255c7dfda23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; statement can take an argument (which will be the value of the loop expression if the &lt;code&gt;break&lt;/code&gt; statement is executed) in &lt;code&gt;loop&lt;/code&gt; loops, but not &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, or &lt;code&gt;while let&lt;/code&gt; loops.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 문합니다 (경우 루프 식의 값이됩니다 인수 걸릴 수 있습니다 &lt;code&gt;break&lt;/code&gt; 에 문이 실행될) &lt;code&gt;loop&lt;/code&gt; 루프를, 그러나 &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , 또는 &lt;code&gt;while let&lt;/code&gt; 루프.</target>
        </trans-unit>
        <trans-unit id="d4fc4821431bbe2f5d7ca950ef58b031fb001379" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bytes&lt;/code&gt; method returns each raw byte, which might be appropriate for your domain:</source>
          <target state="translated">는 &lt;code&gt;bytes&lt;/code&gt; 메소드가 리턴 도메인에 적합 할 수 있습니다 각 원시 바이트를 :</target>
        </trans-unit>
        <trans-unit id="0c67d48bb9bf16df95a3dc50a92dbdfe313c2a09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can_hold&lt;/code&gt; method returns a Boolean, which means it&amp;rsquo;s a perfect use case for the &lt;code&gt;assert!&lt;/code&gt; macro. In Listing 11-6, we write a test that exercises the &lt;code&gt;can_hold&lt;/code&gt; method by creating a &lt;code&gt;Rectangle&lt;/code&gt; instance that has a width of 8 and a height of 7 and asserting that it can hold another &lt;code&gt;Rectangle&lt;/code&gt; instance that has a width of 5 and a height of 1.</source>
          <target state="translated">&lt;code&gt;can_hold&lt;/code&gt; 의 방법은이를위한 완벽한 유스 케이스의 의미 부울 반환 &lt;code&gt;assert!&lt;/code&gt; 매크로. 리스트 (11-6)에서는, 운동 시험 물품 &lt;code&gt;can_hold&lt;/code&gt; 의 만들어 방법 &lt;code&gt;Rectangle&lt;/code&gt; (8)의 폭 (7)의 높이가 예를하고 다른 보유 할 수 있음을 주장 &lt;code&gt;Rectangle&lt;/code&gt; (5)의 폭과 높이를 가지고 예를 1.</target>
        </trans-unit>
        <trans-unit id="5a25b55443c783de850a8f716e7e98dd68745de2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cargo install&lt;/code&gt; command allows you to install and use binary crates locally. This isn&amp;rsquo;t intended to replace system packages; it&amp;rsquo;s meant to be a convenient way for Rust developers to install tools that others have shared on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;. Note that you can only install packages that have binary targets. A &lt;em&gt;binary target&lt;/em&gt; is the runnable program that is created if the crate has a &lt;em&gt;src/main.rs&lt;/em&gt; file or another file specified as a binary, as opposed to a library target that isn&amp;rsquo;t runnable on its own but is suitable for including within other programs. Usually, crates have information in the &lt;em&gt;README&lt;/em&gt; file about whether a crate is a library, has a binary target, or both.</source>
          <target state="translated">&lt;code&gt;cargo install&lt;/code&gt; 명령은 설치 및 로컬 진 상자를 사용할 수 있습니다. 이것은 시스템 패키지를 대체하기위한 것이 아닙니다. Rust 개발자가 다른 사람들이 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io에서&lt;/a&gt; 공유 한 도구를 설치하는 편리한 방법입니다 . 바이너리 대상이있는 패키지 만 설치할 수 있습니다. &lt;em&gt;진 대상은&lt;/em&gt; 나무 상자가있는 경우 생성되는 실행 가능한 프로그램입니다 &lt;em&gt;SRC / main.rs의&lt;/em&gt; 자체 실행 가능한 것이 아니라 다른 내 포함에 적합한 라이브러리 대상 반대로, 파일 또는 바이너리로 지정된 다른 파일을 프로그램들. 일반적으로 크레이트는 &lt;em&gt;README&lt;/em&gt; 파일에 크레이트가 라이브러리인지 바이너리 대상인지 또는 둘 다인지에 대한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2664dcbe5273c6722a5b153d876b9b792f2ada2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cargo test&lt;/code&gt; command runs all tests in our project, as shown in Listing 11-2.</source>
          <target state="translated">&lt;code&gt;cargo test&lt;/code&gt; 목록 11-2에서와 같이 명령은, 우리의 프로젝트에 모든 테스트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="375baaee400dee61b2707b887bd9af56fe2bc128" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="3c6c79dbe0366f164760e8fbd149ca95e0429eec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute is allowed anywhere attributes are allowed.</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; 속성은 어디 속성이 허용됩니다 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c1be4a466f7709a98c138b8664fae5693d56dd2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute supports only three kinds of predicates:</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; 속성 지원 조건의 삼가지 :</target>
        </trans-unit>
        <trans-unit id="28422790bd7081a79bb025fb9d66e378219a525d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; macro</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; 매크로</target>
        </trans-unit>
        <trans-unit id="fde18a15c12045ccc5f862ad4d07ffff9bb790a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; conditionally includes the thing it is attached to based on a configuration predicate.</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;속성은&lt;/a&gt; 조건이 구성 조건에 따라 부착되어있는 것을 포함한다.</target>
        </trans-unit>
        <trans-unit id="2223835f7d8034d74bbb5846af6ec97de49a67f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;cfg_attr&lt;/code&gt; 의 속성</target>
        </trans-unit>
        <trans-unit id="76546526e7489be649c0d74ada78ee80e5e85965" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt; attribute is allowed anywhere attributes are allowed.</source>
          <target state="translated">&lt;code&gt;cfg_attr&lt;/code&gt; 의 속성은 어디 속성이 허용됩니다 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="548a83f876de36acae9e81967a808fe451cf7938" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; conditionally includes &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; based on a configuration predicate.</source>
          <target state="translated">&lt;code&gt;cfg_attr&lt;/code&gt; 의&lt;a href=&quot;attributes&quot;&gt;속성은&lt;/a&gt; 조건부 포함 &lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 구성 조건을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="85a19bbf37eb56f0525c8c2436505adedd691250" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char&lt;/code&gt; type represents a single character. More specifically, since 'character' isn't a well-defined concept in Unicode, &lt;code&gt;char&lt;/code&gt; is a '&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 유형은 단일 문자를 나타냅니다. 보다 구체적으로, 'character'는 유니 코드에서 잘 정의 된 개념이 아니므로 &lt;code&gt;char&lt;/code&gt; 은 ' &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; '이며 ' &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt; ' 와 유사하지만 동일하지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b73bedd4705331ddde92b218ee42ae14fd783b1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; and &lt;code&gt;inline&lt;/code&gt;&lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; give suggestions to generate code in a way that may be faster than what it would do without the hint. The attributes are only hints, and may be ignored.</source>
          <target state="translated">&lt;code&gt;cold&lt;/code&gt; 와 &lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;속성은&lt;/a&gt; 더 빨리 힌트없이 할 것보다 될 수있는 방식으로 코드를 생성하기위한 제안을 제공합니다. 속성은 힌트 일 뿐이므로 무시해도됩니다.</target>
        </trans-unit>
        <trans-unit id="5e443e8933fc7022a9fff52a5391c70d8fc736a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;cold&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="f187d03d0870d5f7cf8d911158a2ad4bf8bfb1f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; keyword is also used in raw pointers in combination with &lt;code&gt;mut&lt;/code&gt;, as seen in &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;. More about &lt;code&gt;const&lt;/code&gt; as used in raw pointers can be read at the Rust docs for the &lt;a href=&quot;primitive.pointer&quot;&gt;pointer primitive&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 키워드는 조합하여 원재료에 사용 포인터 &lt;code&gt;mut&lt;/code&gt; 된 바와 같이, &lt;code&gt;*const T&lt;/code&gt; 및 &lt;code&gt;*mut T&lt;/code&gt; . 원시 포인터에서 사용되는 &lt;code&gt;const&lt;/code&gt; 에 대한 자세한 내용 은 &lt;a href=&quot;primitive.pointer&quot;&gt;포인터 프리미티브에&lt;/a&gt; 대한 Rust 문서에서 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c647cbb39e778e9b3fee3b9f221a846f5e10198a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; keyword is also used in raw pointers in combination with &lt;code&gt;mut&lt;/code&gt;, as seen in &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;. More about that can be read at the &lt;a href=&quot;primitive.pointer&quot;&gt;pointer&lt;/a&gt; primitive part of the Rust docs.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 키워드는 조합하여 원재료에 사용 포인터 &lt;code&gt;mut&lt;/code&gt; 된 바와 같이, &lt;code&gt;*const T&lt;/code&gt; 및 &lt;code&gt;*mut T&lt;/code&gt; . 이에 대한 자세한 내용 은 Rust 문서 의 &lt;a href=&quot;primitive.pointer&quot;&gt;포인터&lt;/a&gt; 기본 부분 에서 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90ef70a34f1bf7aa0febc79627f67bbce0e1d9d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;core&lt;/code&gt; crate is always added to the extern prelude. The &lt;code&gt;std&lt;/code&gt; crate is added as long as the &lt;a href=&quot;../crates-and-source-files#preludes-and-no_std&quot;&gt;&lt;code&gt;no_std&lt;/code&gt;&lt;/a&gt; attribute is not specified in the crate root.</source>
          <target state="translated">&lt;code&gt;core&lt;/code&gt; 상자는 항상 통근 전주곡에 추가됩니다. &lt;code&gt;std&lt;/code&gt; 상자는 오랫동안만큼 추가 &lt;a href=&quot;../crates-and-source-files#preludes-and-no_std&quot;&gt; &lt;code&gt;no_std&lt;/code&gt; &lt;/a&gt; 속성이 상자 루트에 지정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="38acae0d6ab176e191a45e1f1b54faccd4c7f448" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crate_name&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;crate_name&lt;/code&gt; 의 속성</target>
        </trans-unit>
        <trans-unit id="ef2c8badee302cb0baefa21db745a07eb79b3acf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; pointer can be used to store arbitrary data as required by the executor. This could be e.g. a type-erased pointer to an &lt;code&gt;Arc&lt;/code&gt; that is associated with the task. The value of this poiner will get passed to all functions that are part of the &lt;code&gt;vtable&lt;/code&gt; as the first parameter.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 포인터 실행 프로그램에 의해 요구되는 임의의 데이터를 저장하는데 사용될 수있다. 예를 들어 작업과 관련된 &lt;code&gt;Arc&lt;/code&gt; 대한 유형이 지워진 포인터 일 수 있습니다 . 이 poiner의 값은 첫 번째 매개 변수로 &lt;code&gt;vtable&lt;/code&gt; 의 일부인 모든 함수에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e90fa7bb07af3f80ba061dbc0af88db5a79ba76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; pointer can be used to store arbitrary data as required by the executor. This could be e.g. a type-erased pointer to an &lt;code&gt;Arc&lt;/code&gt; that is associated with the task. The value of this pointer will get passed to all functions that are part of the &lt;code&gt;vtable&lt;/code&gt; as the first parameter.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 포인터 실행 프로그램에 의해 요구되는 임의의 데이터를 저장하는데 사용될 수있다. 이것은 예를 들어 작업과 관련된 &lt;code&gt;Arc&lt;/code&gt; 에 대한 형식 지워진 포인터 일 수 있습니다 . 이 포인터의 값은 &lt;code&gt;vtable&lt;/code&gt; 의 일부인 모든 함수 에 첫 번째 매개 변수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="a7af61314557c2255ce30f13387bf574343b8476" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg!(..)&lt;/code&gt; macro moves the input:</source>
          <target state="translated">&lt;code&gt;dbg!(..)&lt;/code&gt; 매크로 이동 입력은 :</target>
        </trans-unit>
        <trans-unit id="b7a4dd4c094bb75a82ed633489f0ec96c82a6296" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg!&lt;/code&gt; macro works exactly the same in release builds. This is useful when debugging issues that only occur in release builds or when debugging in release mode is significantly faster.</source>
          <target state="translated">&lt;code&gt;dbg!&lt;/code&gt; 매크로는 릴리스 빌드에서 정확히 동일하게 작동합니다. 릴리스 빌드에서만 발생하는 문제를 디버깅하거나 릴리스 모드에서 디버깅하는 것이 훨씬 빠를 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5a03c825d089a243f66f60fd9869adfb4b5c6857" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute</source>
          <target state="translated">더 &lt;code&gt;deprecated&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="8b0ffc1f78b8eb9694b4e7509ecdd919acc0c0cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can only be present &lt;strong&gt;once&lt;/strong&gt; on an item.</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 속성은 존재할 수 &lt;strong&gt;번&lt;/strong&gt; 항목에.</target>
        </trans-unit>
        <trans-unit id="4c348bd3f38f8d7b286030ed2d1f972d4a02706b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute has several forms:</source>
          <target state="translated">더 &lt;code&gt;deprecated&lt;/code&gt; 속성에는 여러 가지 형태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="44c311ce3d12b2d5a8a0632c6cd020f999b4ee16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute may be applied to any &lt;a href=&quot;../items&quot;&gt;item&lt;/a&gt;, &lt;a href=&quot;../items/traits&quot;&gt;trait item&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;enum variant&lt;/a&gt;, &lt;a href=&quot;../items/structs&quot;&gt;struct field&lt;/a&gt;, &lt;a href=&quot;../items/external-blocks&quot;&gt;external block item&lt;/a&gt;, or &lt;a href=&quot;../macros-by-example&quot;&gt;macro definition&lt;/a&gt;. It cannot be applied to &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;trait implementation items&lt;/a&gt;. When applied to an item containing other items, such as a &lt;a href=&quot;../items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;../items/implementations&quot;&gt;implementation&lt;/a&gt;, all child items inherit the deprecation attribute.</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 특성 하나에 적용될 수있다 &lt;a href=&quot;../items&quot;&gt;아이템&lt;/a&gt; , &lt;a href=&quot;../items/traits&quot;&gt;특성 항목&lt;/a&gt; , &lt;a href=&quot;../items/enumerations&quot;&gt;ENUM 변형&lt;/a&gt; , &lt;a href=&quot;../items/structs&quot;&gt;구조체 필드&lt;/a&gt; , &lt;a href=&quot;../items/external-blocks&quot;&gt;외부 블록 항목&lt;/a&gt; 또는 &lt;a href=&quot;../macros-by-example&quot;&gt;매크로 정의&lt;/a&gt; . &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;특성 구현 항목에는&lt;/a&gt; 적용 할 수 없습니다 . &lt;a href=&quot;../items/modules&quot;&gt;모듈&lt;/a&gt; 또는 &lt;a href=&quot;../items/implementations&quot;&gt;구현&lt;/a&gt; 과 같은 다른 항목을 포함하는 항목에 적용하면 모든 하위 항목이 deprecation 속성을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="f1d23eb4050e4bb4bd6008dd3e0216cd81ba2cd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute may be applied to any &lt;a href=&quot;../items&quot;&gt;item&lt;/a&gt;, &lt;a href=&quot;../items/traits&quot;&gt;trait item&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;enum variant&lt;/a&gt;, &lt;a href=&quot;../items/structs&quot;&gt;struct field&lt;/a&gt;, or &lt;a href=&quot;../items/external-blocks&quot;&gt;external block item&lt;/a&gt;. It cannot be applied to &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;trait implementation items&lt;/a&gt;. When applied to an item containing other items, such as a &lt;a href=&quot;../items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;../items/implementations&quot;&gt;implementation&lt;/a&gt;, all child items inherit the deprecation attribute.</source>
          <target state="translated">더 &lt;code&gt;deprecated&lt;/code&gt; 속성은 모든 &lt;a href=&quot;../items&quot;&gt;항목&lt;/a&gt; , &lt;a href=&quot;../items/traits&quot;&gt;특성 항목&lt;/a&gt; , &lt;a href=&quot;../items/enumerations&quot;&gt;열거 형 변형&lt;/a&gt; , &lt;a href=&quot;../items/structs&quot;&gt;구조체 필드&lt;/a&gt; 또는 &lt;a href=&quot;../items/external-blocks&quot;&gt;외부 블록 항목에&lt;/a&gt; 적용될 수 있습니다. . &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;특성 구현 항목에는&lt;/a&gt; 적용 할 수 없습니다 . &lt;a href=&quot;../items/modules&quot;&gt;모듈&lt;/a&gt; 또는 &lt;a href=&quot;../items/implementations&quot;&gt;구현&lt;/a&gt; 과 같은 다른 항목을 포함하는 항목에 적용하면 모든 하위 항목이 지원 중단 속성을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="6e7f4030e080734f98683be5c8344d101d0992db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; shown in this build output indicate that the compiler is using different profiles.</source>
          <target state="translated">&lt;code&gt;dev&lt;/code&gt; 및 &lt;code&gt;release&lt;/code&gt; 이 빌드 출력에 나타낸 컴파일러는 다른 정보를 사용하는 것을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="2bcbec4aff44a7472a393bc8eca9c7c00034401d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;drop&lt;/code&gt; method is called when &lt;code&gt;_x&lt;/code&gt; goes out of scope, and therefore &lt;code&gt;main&lt;/code&gt; prints &lt;code&gt;Dropping!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;drop&lt;/code&gt; 방법을 때 호출되는 &lt;code&gt;_x&lt;/code&gt; 범위를 벗어나, 따라서 &lt;code&gt;main&lt;/code&gt; 지문이 &lt;code&gt;Dropping!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa3edbdb8ad85c4d37e55b2e809f2f18d6f4e045" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a directory symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">그만큼 &lt;code&gt;dst&lt;/code&gt; 경로를 가리키는 디렉토리 기호 링크가 될 것이다 &lt;code&gt;src&lt;/code&gt; 경로.</target>
        </trans-unit>
        <trans-unit id="f8ab040b8a001ca82f66534b2d20a3b8892fd2dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a file symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">그만큼 &lt;code&gt;dst&lt;/code&gt; 경로가 가리키는 파일을 기호 링크가 될 것이다 &lt;code&gt;src&lt;/code&gt; 경로.</target>
        </trans-unit>
        <trans-unit id="f0ecd1a2ccd0de8765e1ce7cbb8fab53800f6ce6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a link pointing to the &lt;code&gt;src&lt;/code&gt; path. Note that systems often require these two paths to both be located on the same filesystem.</source>
          <target state="translated">그만큼 &lt;code&gt;dst&lt;/code&gt; 경로를 가리키는 링크가 될 것이다 &lt;code&gt;src&lt;/code&gt; 경로. 시스템은 종종이 두 경로가 모두 동일한 파일 시스템에 위치해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0f3651131fc6e4c0e98108eb60e32485bb1899b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">그만큼 &lt;code&gt;dst&lt;/code&gt; 경로를 가리키는 기호 링크가 될 것이다 &lt;code&gt;src&lt;/code&gt; 경로.</target>
        </trans-unit>
        <trans-unit id="3c07e52fcb5c94a3c499bbc6e95804ccd5a8bfc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path. On Windows, this will be a file symlink, not a directory symlink; for this reason, the platform-specific &lt;a href=&quot;../os/unix/fs/fn.symlink&quot;&gt;&lt;code&gt;std::os::unix::fs::symlink&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/windows/fs/fn.symlink_file&quot;&gt;&lt;code&gt;std::os::windows::fs::symlink_file&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../os/windows/fs/fn.symlink_dir&quot;&gt;&lt;code&gt;symlink_dir&lt;/code&gt;&lt;/a&gt; should be used instead to make the intent explicit.</source>
          <target state="translated">&lt;code&gt;dst&lt;/code&gt; 경로를 가리키는 기호 링크가 될 것이다 &lt;code&gt;src&lt;/code&gt; 경로. Windows에서는 디렉토리 symlink가 아니라 파일 symlink가됩니다. 이러한 이유로 플랫폼 별 &lt;a href=&quot;../os/unix/fs/fn.symlink&quot;&gt; &lt;code&gt;std::os::unix::fs::symlink&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../os/windows/fs/fn.symlink_file&quot;&gt; &lt;code&gt;std::os::windows::fs::symlink_file&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../os/windows/fs/fn.symlink_dir&quot;&gt; &lt;code&gt;symlink_dir&lt;/code&gt; &lt;/a&gt; 을 사용하여 의도를 명시 적으로 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="fce5aa6e4c6fe0d2a117a0ec0a2f7f52bfd2748e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dyn&lt;/code&gt; keyword is used to highlight that calls to methods on the associated &lt;code&gt;Trait&lt;/code&gt; are dynamically dispatched. To use the trait this way, it must be 'object safe'.</source>
          <target state="translated">&lt;code&gt;dyn&lt;/code&gt; 키워드는 관련 메소드 호출 있음을 강조하기 위해 사용되는 &lt;code&gt;Trait&lt;/code&gt; 동적으로 전달됩니다. 이런 방식으로 특성을 사용하려면 '객체 안전'이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f31eeeb70d8a71f4b93bd89156c38bf0e5709ff2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;edition&lt;/code&gt; key in &lt;em&gt;Cargo.toml&lt;/em&gt; indicates which edition the compiler should use for your code. If the key doesn&amp;rsquo;t exist, Rust uses &lt;code&gt;2015&lt;/code&gt; as the edition value for backward compatibility reasons.</source>
          <target state="translated">&lt;em&gt;Cargo.toml&lt;/em&gt; 의 &lt;code&gt;edition&lt;/code&gt; 키&lt;em&gt;&lt;/em&gt; 는 컴파일러가 코드에 사용해야하는 에디션을 나타냅니다. 키가 존재하지 않으면 Rust는 이전 버전과의 호환성을 위해 &lt;code&gt;2015&lt;/code&gt; 를 에디션 값으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d4302d0f2edafc20c30c1bca4c608a973532a107" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;else&lt;/code&gt; block of an &lt;code&gt;if&lt;/code&gt; expression.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 표현식 의 &lt;code&gt;else&lt;/code&gt; 블록 .</target>
        </trans-unit>
        <trans-unit id="25d57c60dcf697c3f5bb61f1ff343393baeeb72f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;entry&lt;/code&gt; API is intended to provide an efficient mechanism for manipulating the contents of a map conditionally on the presence of a key or not. The primary motivating use case for this is to provide efficient accumulator maps. For instance, if one wishes to maintain a count of the number of times each key has been seen, they will have to perform some conditional logic on whether this is the first time the key has been seen or not. Normally, this would require a &lt;code&gt;find&lt;/code&gt; followed by an &lt;code&gt;insert&lt;/code&gt;, effectively duplicating the search effort on each insertion.</source>
          <target state="translated">&lt;code&gt;entry&lt;/code&gt; API는 조건부 키 또는하지의 존재에지도의 내용을 조작하기위한 효율적인 메커니즘을 제공하기위한 것입니다. 이를위한 주요 동기 사용 사례는 효율적인 누산기 맵을 제공하는 것입니다. 예를 들어, 각 키를 본 횟수를 유지하려면 키를 처음 본 것인지 아닌지에 대한 조건부 논리를 수행해야합니다. 일반적으로 &lt;code&gt;find&lt;/code&gt; 가 필요합니다 다음에 &lt;code&gt;insert&lt;/code&gt; 각 삽입에 대한 검색 노력을 효과적으로 복제합니다.</target>
        </trans-unit>
        <trans-unit id="f625c5b9aa8efa15984a630e2609a8460845d869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;enum&lt;/code&gt; type is analogous to a &lt;code&gt;data&lt;/code&gt; constructor declaration in ML, or a &lt;em&gt;pick ADT&lt;/em&gt; in Limbo.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 형은 유사 &lt;code&gt;data&lt;/code&gt; ML에서 생성자 선언, 또는 &lt;em&gt;픽업 ADT&lt;/em&gt; 림보한다.</target>
        </trans-unit>
        <trans-unit id="a4c06e2ed2dc5ac68975592625d2fc4a6fa31065" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;env::args&lt;/code&gt; function returns an iterator! Rather than collecting the iterator values into a vector and then passing a slice to &lt;code&gt;Config::new&lt;/code&gt;, now we&amp;rsquo;re passing ownership of the iterator returned from &lt;code&gt;env::args&lt;/code&gt; to &lt;code&gt;Config::new&lt;/code&gt; directly.</source>
          <target state="translated">&lt;code&gt;env::args&lt;/code&gt; 함수는 반복자를 반환! 반복자 값을 벡터로 수집 한 다음 슬라이스를 &lt;code&gt;Config::new&lt;/code&gt; 에 전달하는 대신 &lt;code&gt;env::args&lt;/code&gt; 에서 &lt;code&gt;Config::new&lt;/code&gt; 로 리턴 된 반복자의 소유권을 직접 전달합니다.</target>
        </trans-unit>
        <trans-unit id="8c4edba08b3e0cbdebf585d9d18019162245f0c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;execute&lt;/code&gt; method will send the job it wants to execute down the sending side of the channel.</source>
          <target state="translated">&lt;code&gt;execute&lt;/code&gt; 방법은이 채널의 송신 측을 실행하고자하는 작업을 보내드립니다.</target>
        </trans-unit>
        <trans-unit id="f04efaa242b2b0657b1281616eed7892b34b84f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expensive_test&lt;/code&gt; function is listed as &lt;code&gt;ignored&lt;/code&gt;. If we want to run only the ignored tests, we can use &lt;code&gt;cargo test -- --ignored&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;expensive_test&lt;/code&gt; 으로 기능이 나열되어 &lt;code&gt;ignored&lt;/code&gt; . 무시 된 테스트 만 실행하려면 &lt;code&gt;cargo test -- --ignored&lt;/code&gt; ignored를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3f7670e25e83de589c198657dfe09fdc1e175dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export_name&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;export_name&lt;/code&gt; 의 속성</target>
        </trans-unit>
        <trans-unit id="71ce9eba53db805fddc2d08a297018a65234c4f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; function qualifier allows providing function &lt;em&gt;definitions&lt;/em&gt; that can be called with a particular ABI:</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; 기능 제공 있도록 규정 함수 &lt;em&gt;정의&lt;/em&gt; 특정 ABI으로 호출 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="40efbff38e084ea29f3140f45238b8f3a1480902" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; keyword is used in two places in Rust. One is in conjunction with the &lt;a href=&quot;index&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt; keyword to make your Rust code aware of other Rust crates in your project, i.e., &lt;code&gt;extern crate lazy_static;&lt;/code&gt;. The other use is in foreign function interfaces (FFI).</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; 키워드는 녹 두 곳에서 사용된다. 하나는 &lt;a href=&quot;index&quot;&gt; &lt;code&gt;crate&lt;/code&gt; &lt;/a&gt; 와 함께 키워드 사용하여 Rust 코드가 프로젝트의 다른 Rust 상자를 인식하도록합니다 (예 : &lt;code&gt;extern crate lazy_static;&lt;/code&gt; . 다른 용도는 외부 기능 인터페이스 (FFI)입니다.</target>
        </trans-unit>
        <trans-unit id="e4b4130d453476128e8ae98130baa92b7675ca5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; keyword is used in two places in Rust. One is in conjunction with the &lt;a href=&quot;keyword.crate&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt; keyword to make your Rust code aware of other Rust crates in your project, i.e., &lt;code&gt;extern crate lazy_static;&lt;/code&gt;. The other use is in foreign function interfaces (FFI).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a6e01d93b27f65515594890e0091001ba7b217" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;feature&lt;/code&gt; attribute only accept a &quot;feature flag&quot; and can only be used on nightly. Example:</source>
          <target state="translated">&lt;code&gt;feature&lt;/code&gt; 속성 만 &quot;기능 플래그를&quot;받아 들일 만 야간에 사용할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="36584ecca666e59936c11f071bcfcb0da92fd4b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;feature&lt;/code&gt; attribute was badly formed.</source>
          <target state="translated">&lt;code&gt;feature&lt;/code&gt; 속성이 심하게 형성되었다.</target>
        </trans-unit>
        <trans-unit id="424a7adcc55a187f305df277831d5dda5afa7154" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_const&lt;/code&gt; attribute can only be used on foreign function declarations which have no side effects except for their return value:</source>
          <target state="translated">&lt;code&gt;ffi_const&lt;/code&gt; 의 속성은 자신의 반환 값을 제외하고 부작용이없는 외국 함수 선언에서 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f9fac3c8fa0259e175ffb5e9aab803c7bd9140ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_const&lt;/code&gt; attribute was used on something other than a foreign function declaration.</source>
          <target state="translated">&lt;code&gt;ffi_const&lt;/code&gt; 의 속성은 외부 함수 선언 이외에서 사용되었다.</target>
        </trans-unit>
        <trans-unit id="bfe6d270783e8b73023767bbcd8ed3a773bacf0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_pure&lt;/code&gt; attribute can only be used on foreign functions which do not have side effects or infinite loops:</source>
          <target state="translated">&lt;code&gt;ffi_pure&lt;/code&gt; 의 속성은하지 않는 부작용 또는 무한 루프가 외국 기능에서만 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="883b8dfd3c5fc179185e1d061b052f5f3e0fb52a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_pure&lt;/code&gt; attribute was used on a non-foreign function.</source>
          <target state="translated">&lt;code&gt;ffi_pure&lt;/code&gt; 의 속성이 아닌 외국 기능에 사용되었다.</target>
        </trans-unit>
        <trans-unit id="e96870e73ec5eb32cc1bdf8256711d63dccde7e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fix_incorrect_order&lt;/code&gt; function is in the &lt;code&gt;back_of_house&lt;/code&gt; module, so we can use &lt;code&gt;super&lt;/code&gt; to go to the parent module of &lt;code&gt;back_of_house&lt;/code&gt;, which in this case is &lt;code&gt;crate&lt;/code&gt;, the root. From there, we look for &lt;code&gt;serve_order&lt;/code&gt; and find it. Success! We think the &lt;code&gt;back_of_house&lt;/code&gt; module and the &lt;code&gt;serve_order&lt;/code&gt; function are likely to stay in the same relationship to each other and get moved together should we decide to reorganize the crate&amp;rsquo;s module tree. Therefore, we used &lt;code&gt;super&lt;/code&gt; so we&amp;rsquo;ll have fewer places to update code in the future if this code gets moved to a different module.</source>
          <target state="translated">&lt;code&gt;fix_incorrect_order&lt;/code&gt; 의 기능은에 &lt;code&gt;back_of_house&lt;/code&gt; 의 우리가 사용할 수 있도록, 모듈 &lt;code&gt;super&lt;/code&gt; 의 부모 모듈로 이동 &lt;code&gt;back_of_house&lt;/code&gt; 이 경우에, &lt;code&gt;crate&lt;/code&gt; , 루트. 거기서부터 &lt;code&gt;serve_order&lt;/code&gt; 를 찾아서 찾으십시오. 성공! 우리 는 상자의 모듈 트리를 재구성하기로 결정 하면 &lt;code&gt;back_of_house&lt;/code&gt; 모듈과 &lt;code&gt;serve_order&lt;/code&gt; 함수가 서로 같은 관계를 유지하고 함께 움직일 것으로 생각합니다 . 따라서 우리는 &lt;code&gt;super&lt;/code&gt; 코드가 다른 모듈로 이동하는 경우 나중에 super 하여 코드를 업데이트 할 공간이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="8941a23b194692ed51f3b950de07285880e660a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fn&lt;/code&gt; syntax declares a new function, the parentheses, &lt;code&gt;()&lt;/code&gt;, indicate there are no parameters, and the curly bracket, &lt;code&gt;{&lt;/code&gt;, starts the body of the function.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; 구문은 새로운 기능, 괄호 선언 &lt;code&gt;()&lt;/code&gt; ,,, 매개 변수가없는 표시하고 중괄호를 &lt;code&gt;{&lt;/code&gt; , 함수의 본문을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="2ec5406eba98b65177f08bb6b301125802a344f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; keyword is used in many syntactic locations:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 키워드가 많은 구문 위치에 사용된다 :</target>
        </trans-unit>
        <trans-unit id="f09d76fe1ac31bb0c6ea4013cf20271ea27e1d4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop variable is now named &lt;code&gt;_i&lt;/code&gt;, and the warning no longer appears.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프 변수는 이제 이름 &lt;code&gt;_i&lt;/code&gt; 하고, 경고가 더 이상 나타납니다.</target>
        </trans-unit>
        <trans-unit id="05236db55a3c27bea79ddd94d4c11b4238339e3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forbid&lt;/code&gt; lint setting, like &lt;code&gt;deny&lt;/code&gt;, turns the corresponding compiler warning into a hard error. Unlike &lt;code&gt;deny&lt;/code&gt;, &lt;code&gt;forbid&lt;/code&gt; prevents itself from being overridden by inner attributes.</source>
          <target state="translated">&lt;code&gt;forbid&lt;/code&gt; 보풀이 설정은 같은 &lt;code&gt;deny&lt;/code&gt; , 하드 오류에 해당하는 컴파일러 경고를 켭니다. 달리 &lt;code&gt;deny&lt;/code&gt; , &lt;code&gt;forbid&lt;/code&gt; 는 내부 속성에 의해 재정의되는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="4235fdb48267c248121e84a51ecfc4901ad84de8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; function takes an &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;Arguments&lt;/code&gt;&lt;/a&gt; struct and returns the resulting formatted string.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 함수 취하는&lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;Arguments&lt;/code&gt; &lt;/a&gt; 구조체 및 결과 형식의 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d0e2c1abc11834d5ec0f9413abedb6a8d1f2b1d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; file does not exist.</source>
          <target state="translated">그만큼 &lt;code&gt;from&lt;/code&gt; 파일이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c95afec6a5645bced705f13162ada21e2af597c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; path is not a file.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; 경로는 파일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6acb8d35118f04b02cccbeee4ae943f064bc37b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;global_allocator&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;global_allocator&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="ae2c6463795dadd5e649f9eb12f49008495df3a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash_builder&lt;/code&gt; passed should implement the &lt;a href=&quot;../../hash/trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; trait for the HashMap to be useful, see its documentation for details.</source>
          <target state="translated">전달 된 &lt;code&gt;hash_builder&lt;/code&gt; 는 HashMap이 유용 하도록 &lt;a href=&quot;../../hash/trait.buildhasher&quot;&gt; &lt;code&gt;BuildHasher&lt;/code&gt; &lt;/a&gt; 특성을 구현해야합니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5b0ca98b2928cdd13f0ccd74c40e39e4e68ec9cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash_builder&lt;/code&gt; passed should implement the &lt;a href=&quot;../hash/trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; trait for the HashMap to be useful, see its documentation for details.</source>
          <target state="translated">전달 된 &lt;code&gt;hash_builder&lt;/code&gt; 는 HashMap이 유용 하도록 &lt;a href=&quot;../hash/trait.buildhasher&quot;&gt; &lt;code&gt;BuildHasher&lt;/code&gt; &lt;/a&gt; 특성을 구현해야합니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c35c9498a5a0a48423b3c0138b12569234cd1c61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello_macro_derive&lt;/code&gt; function first converts the &lt;code&gt;input&lt;/code&gt; from a &lt;code&gt;TokenStream&lt;/code&gt; to a data structure that we can then interpret and perform operations on. This is where &lt;code&gt;syn&lt;/code&gt; comes into play. The &lt;code&gt;parse&lt;/code&gt; function in &lt;code&gt;syn&lt;/code&gt; takes a &lt;code&gt;TokenStream&lt;/code&gt; and returns a &lt;code&gt;DeriveInput&lt;/code&gt; struct representing the parsed Rust code. Listing 19-32 shows the relevant parts of the &lt;code&gt;DeriveInput&lt;/code&gt; struct we get from parsing the &lt;code&gt;struct Pancakes;&lt;/code&gt; string:</source>
          <target state="translated">&lt;code&gt;hello_macro_derive&lt;/code&gt; 함수는 먼저 변환하고 &lt;code&gt;input&lt;/code&gt; a로부터 &lt;code&gt;TokenStream&lt;/code&gt; 을 우리는 다음 해석 작업을 수행 할 수있는 데이터 구조에 관한 것이다. 여기에 &lt;code&gt;syn&lt;/code&gt; 이 등장합니다. &lt;code&gt;syn&lt;/code&gt; 의 &lt;code&gt;parse&lt;/code&gt; 함수 는 &lt;code&gt;TokenStream&lt;/code&gt; 을 &lt;code&gt;DeriveInput&lt;/code&gt; 구문 분석 된 Rust 코드를 나타내는 DeriveInput 구조체를 반환합니다 . Listing 19-32는 &lt;code&gt;struct Pancakes;&lt;/code&gt; 를 파싱하여 얻은 &lt;code&gt;DeriveInput&lt;/code&gt; 구조체 의 관련 부분을 보여줍니다 . 끈:</target>
        </trans-unit>
        <trans-unit id="004c835aa77c1c8e124a5716a58b7a6bffdd04f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello_macro_derive&lt;/code&gt; function will be called when a user of our library specifies &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; on a type. This is possible because we&amp;rsquo;ve annotated the &lt;code&gt;hello_macro_derive&lt;/code&gt; function here with &lt;code&gt;proc_macro_derive&lt;/code&gt; and specified the name, &lt;code&gt;HelloMacro&lt;/code&gt;, which matches our trait name; this is the convention most procedural macros follow.</source>
          <target state="translated">&lt;code&gt;hello_macro_derive&lt;/code&gt; 함수가 호출 될 때 도서관 지정하는 사용자 &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; 유형에. 우리가 주석 한 때문입니다 &lt;code&gt;hello_macro_derive&lt;/code&gt; 여기에 기능을 &lt;code&gt;proc_macro_derive&lt;/code&gt; 와 이름, 지정된 &lt;code&gt;HelloMacro&lt;/code&gt; 우리의 특성 이름과 일치; 이것은 대부분의 절차 적 매크로가 따르는 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="f6187e2c81223b9029c3a44a9c821bc39754afaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if let&lt;/code&gt; syntax lets you combine &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; into a less verbose way to handle values that match one pattern while ignoring the rest. Consider the program in Listing 6-6 that matches on an &lt;code&gt;Option&amp;lt;u8&amp;gt;&lt;/code&gt; value but only wants to execute code if the value is 3.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 구문은 결합 할 &lt;code&gt;if&lt;/code&gt; 와 &lt;code&gt;let&lt;/code&gt; 나머지를 무시하면서 핸들 값 방법 자세한 덜에 일치하는 하나 개의 패턴을. Listing 6-6의 &lt;code&gt;Option&amp;lt;u8&amp;gt;&lt;/code&gt; 값 과 일치 하지만 값이 3 인 경우에만 코드를 실행하려는 프로그램을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="4dd0a50c18a24fd3e6c3d1653fdf8d2add1e5c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; condition evaluates to a value of &lt;code&gt;3&lt;/code&gt; this time, and Rust throws an error:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 의 값을 조건 평가하여 &lt;code&gt;3&lt;/code&gt; 이 3 되고 Rust에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3b97788abf2717f652bd87cae2841d2689fe301c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; expression checks whether our value is out of range, tells the user about the problem, and calls &lt;code&gt;continue&lt;/code&gt; to start the next iteration of the loop and ask for another guess. After the &lt;code&gt;if&lt;/code&gt; expression, we can proceed with the comparisons between &lt;code&gt;guess&lt;/code&gt; and the secret number knowing that &lt;code&gt;guess&lt;/code&gt; is between 1 and 100.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 우리의 값이 범위를 벗어 여부를 발현 검사 문제에 대해 사용자에게 알려줍니다, 그리고 전화는 &lt;code&gt;continue&lt;/code&gt; 루프의 다음 반복을 시작하고 또 다른 추측을 요청. 애프터 &lt;code&gt;if&lt;/code&gt; 표현, 우리 사이의 비교를 진행할 수 있습니다 &lt;code&gt;guess&lt;/code&gt; 하고 아는 비밀 번호를 &lt;code&gt;guess&lt;/code&gt; 1에서 100 사이입니다.</target>
        </trans-unit>
        <trans-unit id="21d4200f741c0e5d495167ba918e66c0fa127463" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; keyword is used in one other place in Rust, namely as a part of pattern matching itself, allowing patterns such as &lt;code&gt;Some(x) if x &amp;gt; 200&lt;/code&gt; to be used.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 키워드, 즉 패턴의 일부와 같은 패턴의 수를 알아 내는데 같이 녹 하나의 다른 곳에서 사용되는 &lt;code&gt;Some(x) if x &amp;gt; 200&lt;/code&gt; 사용한다.</target>
        </trans-unit>
        <trans-unit id="60fa964e136b0f0fd7616e520f7abaf2ebfa7111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignore&lt;/code&gt; attribute</source>
          <target state="translated">는 &lt;code&gt;ignore&lt;/code&gt; 속성을</target>
        </trans-unit>
        <trans-unit id="1f363aa597e809eee39b1326a49009f8ed22190d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignore&lt;/code&gt; attribute may optionally be written with the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify a reason why the test is ignored.</source>
          <target state="translated">&lt;code&gt;ignore&lt;/code&gt; 속성은 선택적으로 기록 될 수있다&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt; MetaNameValueStr의&lt;/em&gt;&lt;/a&gt; 테스트가 무시되는 이유를 지정하는 구문.</target>
        </trans-unit>
        <trans-unit id="db8fdc6685b8fc701d318f4f3dec52f0b9a4e868" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; return type captures lifetime parameters that do not appear within the &lt;code&gt;impl Trait&lt;/code&gt; itself.</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; 내에서 표시되지 않는 반환 형식 캡처 수명 매개 변수 &lt;code&gt;impl Trait&lt;/code&gt; 자체.</target>
        </trans-unit>
        <trans-unit id="c9150ca2fdc92a2e0f4ccf4f986d692afa5493d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; syntax is convenient and makes for more concise code in simple cases. The trait bound syntax can express more complexity in other cases. For example, we can have two parameters that implement &lt;code&gt;Summary&lt;/code&gt;. Using the &lt;code&gt;impl Trait&lt;/code&gt; syntax looks like this:</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; 구문은 편리하고 간단한 경우 더 간결한 코드를 만든다. 특성 바인딩 구문은 다른 경우에 더 복잡한 것을 표현할 수 있습니다. 예를 들어, &lt;code&gt;Summary&lt;/code&gt; 를 구현하는 두 개의 매개 변수가있을 수 있습니다 . 사용 &lt;code&gt;impl Trait&lt;/code&gt; 구문을 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="778ea7a6b81f5bfa7d87e34cfb75fde414639934" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; syntax works for straightforward cases but is actually syntax sugar for a longer form, which is called a &lt;em&gt;trait bound&lt;/em&gt;; it looks like this:</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; 구문은 간단 경우에 작동하지만 실제로 호출되는 긴 형태, 구문 설탕입니다&lt;em&gt; 바인딩 특성을&lt;/em&gt; ; 다음과 같이 보입니다 :</target>
        </trans-unit>
        <trans-unit id="2ffdcc0f4b373da2777f00eb0b778b9205836471" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl&lt;/code&gt; keyword is primarily used to define implementations on types. Inherent implementations are standalone, while trait implementations are used to implement traits for types, or other traits.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; 키워드는 주로 유형의 구현을 정의하는 데 사용됩니다. 고유 한 구현은 독립형이며 특성 구현은 유형 또는 다른 특성에 대한 특성을 구현하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="49b529510ff41b8ce0e4f03d01af2d0795d82946" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;incoming&lt;/code&gt; method on &lt;code&gt;TcpListener&lt;/code&gt; returns an iterator that gives us a sequence of streams (more specifically, streams of type &lt;code&gt;TcpStream&lt;/code&gt;). A single &lt;em&gt;stream&lt;/em&gt; represents an open connection between the client and the server. A &lt;em&gt;connection&lt;/em&gt; is the name for the full request and response process in which a client connects to the server, the server generates a response, and the server closes the connection. As such, &lt;code&gt;TcpStream&lt;/code&gt; will read from itself to see what the client sent and then allow us to write our response to the stream. Overall, this &lt;code&gt;for&lt;/code&gt; loop will process each connection in turn and produce a series of streams for us to handle.</source>
          <target state="translated">&lt;code&gt;TcpListener&lt;/code&gt; 의 &lt;code&gt;incoming&lt;/code&gt; 메소드 는 일련의 스트림 (특히 &lt;code&gt;TcpStream&lt;/code&gt; 유형의 스트림)을 제공하는 반복자를 리턴합니다 . 단일 &lt;em&gt;스트림&lt;/em&gt; 은 클라이언트와 서버 간의 열린 연결을 나타냅니다. &lt;em&gt;연결&lt;/em&gt; 서버에 클라이언트 커넥트에서, 서버는 응답을 생성하는 전체 요청 및 응답 프로세스의 이름, 서버는 연결을 닫는다. 따라서 &lt;code&gt;TcpStream&lt;/code&gt; 은 클라이언트가 무엇을 보냈는지 확인하고 응답을 스트림에 쓸 수 있도록합니다. 전반적으로,이 &lt;code&gt;for&lt;/code&gt; &lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; 루프는 각 연결을 차례로 처리하고 처리 할 일련의 스트림을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3ae3f99054fefa43fcfe679af5b3d84ea2c62ac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="f0d784eef56974f3daef0d597995f18b5e5f8afb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute only supports two arguments:</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 속성은 두 개의 인수를 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="bc1a141c850728d98b956fd0716ebc10f9ffb6e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute was malformed.</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 속성의 형식이 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="91c34dfeac33c0fc72de6d1c1ac619e7a9084ef1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;instruction_set&lt;/code&gt; attribute only supports two arguments currently:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65492eab1824c51df92e478cb44c3823042f292f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;instruction_set&lt;/code&gt; attribute was malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4788ad11ac891125e5295255c9d02cd7b36750e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isize&lt;/code&gt; type is a signed integer type with the same number of bits as the platform's pointer type. The theoretical upper bound on object and array size is the maximum &lt;code&gt;isize&lt;/code&gt; value. This ensures that &lt;code&gt;isize&lt;/code&gt; can be used to calculate differences between pointers into an object or array and can address every byte within an object along with one byte past the end.</source>
          <target state="translated">&lt;code&gt;isize&lt;/code&gt; 유형은 플랫폼의 포인터 유형으로 동일한 비트 수의 부호있는 정수 유형입니다. 객체 및 배열 크기의 이론 상한은 최대 &lt;code&gt;isize&lt;/code&gt; 값입니다. 이렇게하면 &lt;code&gt;isize&lt;/code&gt; 를 사용하여 객체 또는 배열에 대한 포인터 간의 차이를 계산할 수 있고 객체 내의 모든 바이트와 끝을지나 1 바이트를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="7d599bd6c4aa9e941662680b3c4cf55e952c7777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;it_works&lt;/code&gt; function now has a return type, &lt;code&gt;Result&amp;lt;(), String&amp;gt;&lt;/code&gt;. In the body of the function, rather than calling the &lt;code&gt;assert_eq!&lt;/code&gt; macro, we return &lt;code&gt;Ok(())&lt;/code&gt; when the test passes and an &lt;code&gt;Err&lt;/code&gt; with a &lt;code&gt;String&lt;/code&gt; inside when the test fails.</source>
          <target state="translated">&lt;code&gt;it_works&lt;/code&gt; 가 이제 복귀 유형 작용, &lt;code&gt;Result&amp;lt;(), String&amp;gt;&lt;/code&gt; . &lt;code&gt;assert_eq!&lt;/code&gt; 호출하는 대신 함수 본문에서 ! 매크로, 테스트가 통과되면 &lt;code&gt;Ok(())&lt;/code&gt; 반환 하고 &lt;code&gt;Err&lt;/code&gt; 은 &lt;code&gt;String&lt;/code&gt; 하고 테스트에 실패하면 내부 합니다.</target>
        </trans-unit>
        <trans-unit id="d7cf351f8d0a069e43102c73f4dd09e2f7958bd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest&lt;/code&gt; function has a parameter called &lt;code&gt;list&lt;/code&gt;, which represents any concrete slice of &lt;code&gt;i32&lt;/code&gt; values that we might pass into the function. As a result, when we call the function, the code runs on the specific values that we pass in.</source>
          <target state="translated">&lt;code&gt;largest&lt;/code&gt; 함수가 호출 매개 변수가 &lt;code&gt;list&lt;/code&gt; 의 콘크리트 조각 나타내며, &lt;code&gt;i32&lt;/code&gt; 우리가 함수에 전달할 수 있다는 값을. 결과적으로 함수를 호출하면 전달한 특정 값에서 코드가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="29c272390da5b69d23c340bb06b514ca355b63f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest_i32&lt;/code&gt; function is the one we extracted in Listing 10-3 that finds the largest &lt;code&gt;i32&lt;/code&gt; in a slice. The &lt;code&gt;largest_char&lt;/code&gt; function finds the largest &lt;code&gt;char&lt;/code&gt; in a slice. The function bodies have the same code, so let&amp;rsquo;s eliminate the duplication by introducing a generic type parameter in a single function.</source>
          <target state="translated">&lt;code&gt;largest_i32&lt;/code&gt; 의 기능은 최대의 발견 우리가 목록 10-3에서 추출 된 하나 &lt;code&gt;i32&lt;/code&gt; 조각에. &lt;code&gt;largest_char&lt;/code&gt; 의 기능이 가장 큰 발견 &lt;code&gt;char&lt;/code&gt; 조각에 있습니다. 함수 본문에는 동일한 코드가 있으므로 단일 함수에 일반 형식 매개 변수를 도입하여 중복을 제거합시다.</target>
        </trans-unit>
        <trans-unit id="d1c6673a10646101d9e252f3f63c9d87dc9cd482" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;len&lt;/code&gt; argument is the number of &lt;strong&gt;elements&lt;/strong&gt;, not the number of bytes.</source>
          <target state="translated">&lt;code&gt;len&lt;/code&gt; 인수의 수입니다 &lt;strong&gt;요소&lt;/strong&gt; 가 아닌 바이트 수.</target>
        </trans-unit>
        <trans-unit id="eabd24b648d02186aedafa8c6e64a26cd4789b21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let y = 6&lt;/code&gt; statement does not return a value, so there isn&amp;rsquo;t anything for &lt;code&gt;x&lt;/code&gt; to bind to. This is different from what happens in other languages, such as C and Ruby, where the assignment returns the value of the assignment. In those languages, you can write &lt;code&gt;x = y = 6&lt;/code&gt; and have both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; have the value &lt;code&gt;6&lt;/code&gt;; that is not the case in Rust.</source>
          <target state="translated">&lt;code&gt;let y = 6&lt;/code&gt; 문은 그렇게 아무것도가없는, 값을 반환하지 않는 &lt;code&gt;x&lt;/code&gt; 에 바인딩. 이는 할당이 할당 값을 반환하는 C 및 Ruby와 같은 다른 언어에서 발생하는 것과 다릅니다. 해당 언어로 &lt;code&gt;x = y = 6&lt;/code&gt; 쓸 수 있으며 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 모두 &lt;code&gt;6&lt;/code&gt; 의 값을 갖습니다 . Rust에서는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="38e40fe06999fccdbadcd0aed2907afe5c6e93b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lines&lt;/code&gt; method returns an iterator. We&amp;rsquo;ll talk about iterators in depth in &lt;a href=&quot;ch13-02-iterators&quot;&gt;Chapter 13&lt;/a&gt;, but recall that you saw this way of using an iterator in &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listing 3-5&lt;/a&gt;, where we used a &lt;code&gt;for&lt;/code&gt; loop with an iterator to run some code on each item in a collection.</source>
          <target state="translated">&lt;code&gt;lines&lt;/code&gt; 방법은 반복자를 반환합니다. 이터레이터에 대해서는 &lt;a href=&quot;ch13-02-iterators&quot;&gt;13 장&lt;/a&gt; 에서 자세히 설명 할 것이지만, &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listing 3-5&lt;/a&gt; 에서 이터레이터를 사용하는 방법을 본 것을 기억하십시오 . 여기서는 컬렉션의 각 항목에 대해 일부 코드를 실행하기 위해 이터레이터가 있는 &lt;code&gt;for&lt;/code&gt; 루프를 사용 했습니다.</target>
        </trans-unit>
        <trans-unit id="eb368f642161e00040244b9fcf42bf09c020466c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lines&lt;/code&gt; method returns an iterator. We&amp;rsquo;ll talk about iterators in depth in [Chapter 13][ch13], but recall that you saw this way of using an iterator in &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listing 3-5&lt;/a&gt;, where we used a &lt;code&gt;for&lt;/code&gt; loop with an iterator to run some code on each item in a collection.</source>
          <target state="translated">&lt;code&gt;lines&lt;/code&gt; 방법은 반복자를 반환합니다. [Chapter 13] [ch13]에서 반복자에 대해 자세히 설명하지만, 반복자에 &lt;code&gt;for&lt;/code&gt; 루프를 사용하여 각 항목에 대해 일부 코드를 실행하는 &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listing 3-5&lt;/a&gt; 의 반복자를 사용하는 방법을 살펴 보았다. 컬렉션에서.</target>
        </trans-unit>
        <trans-unit id="eb1d841506acd030675c6922085c83e81e995a8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;link&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="49ce3813b3cc29f6621eed5040dfcafe494f7af6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_name&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;link_name&lt;/code&gt; 의 속성</target>
        </trans-unit>
        <trans-unit id="affa85dfaaac9c19595e178102133ab86d473f6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_name&lt;/code&gt; attribute may be specified on declarations inside an &lt;code&gt;extern&lt;/code&gt; block to indicate the symbol to import for the given function or static. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the name of the symbol.</source>
          <target state="translated">&lt;code&gt;link_name&lt;/code&gt; 의 속성은 내부 선언에서 지정 될 수있다 &lt;code&gt;extern&lt;/code&gt; 지정된 기능 또는 정적 위해 가져 기호를 나타내는 블록. 그것은 사용 &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr의&lt;/em&gt;&lt;/a&gt; 심볼의 이름을 지정하는 구문을.</target>
        </trans-unit>
        <trans-unit id="76e0be66315f639652150dfe37a31422ede56b88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_section&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;link_section&lt;/code&gt; 의 속성</target>
        </trans-unit>
        <trans-unit id="5d3ac97ce0e51b7500958397678a0747500d6a86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locality&lt;/code&gt; argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache</source>
          <target state="translated">&lt;code&gt;locality&lt;/code&gt; 인수는 상수 정수이어야하며, 시간적 지역의 지정 (0)에 이르기까지한다 - 캐시에서 매우 현지 킵 - (3)에, 아니 지역</target>
        </trans-unit>
        <trans-unit id="08d3f68a2cf00952341cb92b2cabeabf4f7aad60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locality&lt;/code&gt; argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache.</source>
          <target state="translated">&lt;code&gt;locality&lt;/code&gt; 인수는 상수 정수이어야하며 (0)에 이르기까지 시간적 지역 지정자입니다 - 어떤 지역에 (3) - 캐시에 매우 지역 킵은.</target>
        </trans-unit>
        <trans-unit id="ef1c91d4a25bd321565ee99def8880c9e7e661ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loop&lt;/code&gt; keyword creates an infinite loop. We&amp;rsquo;ll add that now to give users more chances at guessing the number:</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 키워드는 무한 루프를 만듭니다. 이제 사용자가 숫자를 추측 할 수있는 더 많은 기회를 제공하기 위해 추가하겠습니다.</target>
        </trans-unit>
        <trans-unit id="ebe9e1bcc2f0843b5208a2b5109915be71857732" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loop&lt;/code&gt; keyword tells Rust to execute a block of code over and over again forever or until you explicitly tell it to stop.</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 키워드는 녹에 걸쳐 코드 블록을 실행하고 다시 영원히 또는 명시 적으로 중지를 말할 때까지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="9910971bdcb643aec0b768364519db2f99d5aff4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macro_use&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;macro_use&lt;/code&gt; 의 속성</target>
        </trans-unit>
        <trans-unit id="c25fb9655125d01a5a1e9d67f7f0780bc361281a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function here creates an instance of the &lt;code&gt;ImportantExcerpt&lt;/code&gt; struct that holds a reference to the first sentence of the &lt;code&gt;String&lt;/code&gt; owned by the variable &lt;code&gt;novel&lt;/code&gt;. The data in &lt;code&gt;novel&lt;/code&gt; exists before the &lt;code&gt;ImportantExcerpt&lt;/code&gt; instance is created. In addition, &lt;code&gt;novel&lt;/code&gt; doesn&amp;rsquo;t go out of scope until after the &lt;code&gt;ImportantExcerpt&lt;/code&gt; goes out of scope, so the reference in the &lt;code&gt;ImportantExcerpt&lt;/code&gt; instance is valid.</source>
          <target state="translated">여기서 &lt;code&gt;main&lt;/code&gt; 함수 는 변수 &lt;code&gt;novel&lt;/code&gt; 소유 한 &lt;code&gt;String&lt;/code&gt; 의 첫 문장에 대한 참조를 보유하는 &lt;code&gt;ImportantExcerpt&lt;/code&gt; 구조체 의 인스턴스를 만듭니다 . &lt;code&gt;ImportantExcerpt&lt;/code&gt; 인스턴스가 생성 되기 전에 &lt;code&gt;novel&lt;/code&gt; 데이터가 존재합니다 . 또한 &lt;code&gt;ImportantExcerpt&lt;/code&gt; 가 범위를 벗어날 때까지 &lt;code&gt;novel&lt;/code&gt; 이 범위 를 벗어나지 않으므로 &lt;code&gt;ImportantExcerpt&lt;/code&gt; 인스턴스 의 참조 가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="db5fe1609c8c74f709a4f1880a24bb8f27550e1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function is special, and there are restrictions on what its return type must be. One valid return type for main is &lt;code&gt;()&lt;/code&gt;, and conveniently, another valid return type is &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, as shown here:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 기능은 특별하다, 그것의 반환 형식이 있어야합니다 무엇에 제한이 있습니다. main에 대한 하나의 유효한 반환 유형은 &lt;code&gt;()&lt;/code&gt; 이며, 다른 유효한 반환 유형은 다음 과 같이 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df8be9695315286ea699a84bc57bf274e0dcbb5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function prototype should never take arguments. Example:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 함수 프로토 타입 인수를해서는 안됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="db6afd48cca2e467a026116d5334792843766266" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function was defined with generic parameters.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 기능은 일반적인 매개 변수로 정의 하였다.</target>
        </trans-unit>
        <trans-unit id="b77f7c754f9c38d3041a1e299a31ef7eeecfa144" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function was incorrectly declared.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 기능은 잘못 선언했다.</target>
        </trans-unit>
        <trans-unit id="43e2fa6b27c55d262177050d71a4a20b71217bb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;move&lt;/code&gt; closure is often used alongside &lt;code&gt;thread::spawn&lt;/code&gt; because it allows you to use data from one thread in another thread.</source>
          <target state="translated">&lt;code&gt;move&lt;/code&gt; 폐쇄는 종종 함께 사용되는 &lt;code&gt;thread::spawn&lt;/code&gt; 이 다른 스레드에서 하나 개의 스레드에서 데이터를 사용할 수 있기 때문이다.</target>
        </trans-unit>
        <trans-unit id="619f2d182d04cd2437b9280f0034a655e725227f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mpsc::channel&lt;/code&gt; function returns a tuple, the first element of which is the sending end and the second element is the receiving end. The abbreviations &lt;code&gt;tx&lt;/code&gt; and &lt;code&gt;rx&lt;/code&gt; are traditionally used in many fields for &lt;em&gt;transmitter&lt;/em&gt; and &lt;em&gt;receiver&lt;/em&gt; respectively, so we name our variables as such to indicate each end. We&amp;rsquo;re using a &lt;code&gt;let&lt;/code&gt; statement with a pattern that destructures the tuples; we&amp;rsquo;ll discuss the use of patterns in &lt;code&gt;let&lt;/code&gt; statements and destructuring in Chapter 18. Using a &lt;code&gt;let&lt;/code&gt; statement this way is a convenient approach to extract the pieces of the tuple returned by &lt;code&gt;mpsc::channel&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mpsc::channel&lt;/code&gt; 기능 튜플을 반환 첫번째 엘리먼트는의 송신단이고 두번째 요소는 수신 측이다. 약어 &lt;code&gt;tx&lt;/code&gt; 와 &lt;code&gt;rx&lt;/code&gt; 는 전통적으로 &lt;em&gt;송신기&lt;/em&gt; 와 &lt;em&gt;수신기의&lt;/em&gt; 여러 필드에서 각각 사용되므로 각 끝을 나타내는 변수의 이름을 지정합니다. 우리는 튜플을 구조화하는 패턴 으로 &lt;code&gt;let&lt;/code&gt; 문을 사용하고 있습니다 . &lt;code&gt;let&lt;/code&gt; 문과 destructuring에서 패턴 사용에 대해서는 18 장 에서 논의 할 것이다 . &lt;code&gt;let&lt;/code&gt; 문을 이런 식으로 사용하는 것은 &lt;code&gt;mpsc::channel&lt;/code&gt; 의해 리턴 된 튜플 조각을 추출하는 편리한 방법 이다.</target>
        </trans-unit>
        <trans-unit id="0a5adaf35abd6fb52abc875dfd1ff8ace4487057" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;must_use&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;must_use&lt;/code&gt; 의 속성</target>
        </trans-unit>
        <trans-unit id="4dc21fbdabdadeb25794ca5fcb0a8eb690cc55f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;must_use&lt;/code&gt; attribute may include a message by using the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax such as &lt;code&gt;#[must_use = &quot;example message&quot;]&lt;/code&gt;. The message will be given alongside the warning.</source>
          <target state="translated">&lt;code&gt;must_use&lt;/code&gt; 의 특성을 사용하여 메시지를 포함 할 수있다 &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; 구문 등 &lt;code&gt;#[must_use = &quot;example message&quot;]&lt;/code&gt; . 경고와 함께 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fa08dd7bde9ed9336c6bf68b835c76ace5a2b281" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; key must be included if &lt;code&gt;kind&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 경우 키가 포함되어야합니다 &lt;code&gt;kind&lt;/code&gt; 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4f5d61c5238b80d1372117cdc9301f7c5a015909" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_builtins&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;no_builtins&lt;/code&gt; 의 속성</target>
        </trans-unit>
        <trans-unit id="0e25b9ca8aa17342df965438e7d8b3912387ac96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_link&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;no_link&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="4c0b9a2602cdb8c2f59fe6476a9d0299ede88a3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_main&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;no_main&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="63ed748c3f1f47aec501358b0494a62e8e33119a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_mangle&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;no_mangle&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="3db3cdb5f8ea826a09ba97c6a8d286d70aec5a65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;non_exhaustive&lt;/code&gt; attribute uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaWord&lt;/em&gt;&lt;/a&gt; syntax and thus does not take any inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6746e3c0ec6ce06b907e0392a7e5f26c1647e02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; cfg-predicate was malformed.</source>
          <target state="translated">&lt;code&gt;not&lt;/code&gt; CFG-술어의 형식이 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="522f2fe5c8ca134ded384cd8e598baad904cbb06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; predicate expects one cfg-pattern. Example:</source>
          <target state="translated">&lt;code&gt;not&lt;/code&gt; 술어 예상하는 하나의 CFG 패턴. 예:</target>
        </trans-unit>
        <trans-unit id="b32d84af66b0734455999894598a8249aed66fbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;number&lt;/code&gt; variable will be bound to a value based on the outcome of the &lt;code&gt;if&lt;/code&gt; expression. Run this code to see what happens:</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; 변수는 결과에 기초하는 값으로 결합 될 &lt;code&gt;if&lt;/code&gt; 식. 이 코드를 실행하여 어떤 일이 발생하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="60fb1fa966c95caff6ec3f67558fb81ff746c1d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;op_string_ref&lt;/code&gt; binding has type &lt;code&gt;&amp;amp;Option&amp;lt;&amp;amp;String&amp;gt;&lt;/code&gt; in both cases.</source>
          <target state="translated">&lt;code&gt;op_string_ref&lt;/code&gt; 바인딩 유형이있다 &lt;code&gt;&amp;amp;Option&amp;lt;&amp;amp;String&amp;gt;&lt;/code&gt; 두 경우 모두를.</target>
        </trans-unit>
        <trans-unit id="2d0c9a8f467995322cb26a15b43a2ed10bd928bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;opt-level&lt;/code&gt; setting controls the number of optimizations Rust will apply to your code, with a range of 0 to 3. Applying more optimizations extends compiling time, so if you&amp;rsquo;re in development and compiling your code often, you&amp;rsquo;ll want faster compiling even if the resulting code runs slower. That is the reason the default &lt;code&gt;opt-level&lt;/code&gt; for &lt;code&gt;dev&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;. When you&amp;rsquo;re ready to release your code, it&amp;rsquo;s best to spend more time compiling. You&amp;rsquo;ll only compile in release mode once, but you&amp;rsquo;ll run the compiled program many times, so release mode trades longer compile time for code that runs faster. That is why the default &lt;code&gt;opt-level&lt;/code&gt; for the &lt;code&gt;release&lt;/code&gt; profile is &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;opt-level&lt;/code&gt; 제어를 최적화의 수를 설정 녹 당신이 개발하고 자주 코드를 컴파일있어 만약 그렇다면, 시간을 컴파일 연장 0 3에 적용 더욱 최적화의 범위와, 코드에 적용됩니다, 당신은 빨리 할 것 결과 코드가 느리게 실행 되더라도 컴파일 이것이 &lt;code&gt;dev&lt;/code&gt; 에 대한 기본 &lt;code&gt;opt-level&lt;/code&gt; 이 &lt;code&gt;0&lt;/code&gt; 인 이유 입니다. 코드를 배포 할 준비가되면 컴파일에 더 많은 시간을 보내는 것이 가장 좋습니다. 릴리스 모드에서는 한 번만 컴파일하지만 컴파일 된 프로그램을 여러 번 실행하므로 릴리스 모드는 더 빨리 실행되는 코드에 대해 컴파일 시간이 길어집니다. 기본 이유입니다 &lt;code&gt;opt-level&lt;/code&gt; 에 대한 &lt;code&gt;release&lt;/code&gt; 프로필이다 &lt;code&gt;3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a0e04095b896f42634e32e5783ee8a2f1b36521" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;or_insert&lt;/code&gt; method on &lt;code&gt;Entry&lt;/code&gt; is defined to return a mutable reference to the value for the corresponding &lt;code&gt;Entry&lt;/code&gt; key if that key exists, and if not, inserts the parameter as the new value for this key and returns a mutable reference to the new value. This technique is much cleaner than writing the logic ourselves and, in addition, plays more nicely with the borrow checker.</source>
          <target state="translated">&lt;code&gt;Entry&lt;/code&gt; 의 &lt;code&gt;or_insert&lt;/code&gt; 메소드 는 해당 키가 존재하는 경우 해당 &lt;code&gt;Entry&lt;/code&gt; 키 의 값에 대한 변경 가능한 참조를 리턴하고 , 존재하지 않는 경우이 키의 새 값으로 매개 변수를 삽입하고 새 값에 대한 변경 가능한 참조를 리턴하도록 정의됩니다. 이 기술은 로직을 직접 작성하는 것보다 훨씬 깨끗하며 빌림 검사기에서 더 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6774c9469b6011fbcb32c16aad7d03e8b6f6c4d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;panic_handler&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;panic_handler&lt;/code&gt; 의 속성</target>
        </trans-unit>
        <trans-unit id="a6291890b4261d452b074ebd1ea09861364cf569" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="eca9cdb5a96c8de323e434d012e339f61d08ae9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; points at a non-directory file.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 가 아닌 디렉토리 파일에서 포인트.</target>
        </trans-unit>
        <trans-unit id="34ed0df01305ce0f75ec5fd43922003af97a525e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; function is not called repeatedly in a tight loop -- instead, it should only be called when the future indicates that it is ready to make progress (by calling &lt;code&gt;wake()&lt;/code&gt;). If you're familiar with the &lt;code&gt;poll(2)&lt;/code&gt; or &lt;code&gt;select(2)&lt;/code&gt; syscalls on Unix it's worth noting that futures typically do &lt;em&gt;not&lt;/em&gt; suffer the same problems of &quot;all wakeups must poll all events&quot;; they are more like &lt;code&gt;epoll(4)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;poll&lt;/code&gt; 기능이 꽉 루프에서 반복적으로 호출되지 않는다 - 대신, 그것은 단지 호출해야 미래가 진전을 이룰 준비가되어 있음을 나타냅니다 경우 (호출하여 &lt;code&gt;wake()&lt;/code&gt; ). 유닉스 에서 &lt;code&gt;poll(2)&lt;/code&gt; 또는 &lt;code&gt;select(2)&lt;/code&gt; syscalls에 익숙하다면 선물은 일반적으로 &quot;모든 웨이크 업이 모든 이벤트를 폴링해야합니다&quot;와 같은 문제가 발생 하지 &lt;em&gt;않습니다&lt;/em&gt; . 그것들은 &lt;code&gt;epoll(4)&lt;/code&gt; 와 비슷 합니다.</target>
        </trans-unit>
        <trans-unit id="a4cdf57409266ff4ceaefa41a5aa6a9d06ca0f60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;poll&lt;/code&gt; 방법</target>
        </trans-unit>
        <trans-unit id="f69f8390bb6f3d4deb2545de4fdfa29877369556" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefetch&lt;/code&gt; intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no effect on the behavior of the program but can change its performance characteristics.</source>
          <target state="translated">&lt;code&gt;prefetch&lt;/code&gt; 극한 지원한다면 프리 페치 명령을 삽입하는 코드 생성기 힌트; 그렇지 않으면, 그것은 no-op입니다. 프리 페치는 프로그램의 동작에 영향을 미치지 않지만 성능 특성을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa7fa9cd2241a28cad4fa12a2f135f7ef3c12daf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; function is only capable of printing to standard output, so we have to use something else to print to standard error.</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; 함수는 표준 출력으로 만 인쇄 할 수 있으므로 표준 오류로 인쇄하려면 다른 것을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f554c0d8cd003f0dac64077248339772aef74465" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; macro can do many kinds of formatting, and by default, the curly brackets tell &lt;code&gt;println!&lt;/code&gt; to use formatting known as &lt;code&gt;Display&lt;/code&gt;: output intended for direct end user consumption. The primitive types we&amp;rsquo;ve seen so far implement &lt;code&gt;Display&lt;/code&gt; by default, because there&amp;rsquo;s only one way you&amp;rsquo;d want to show a &lt;code&gt;1&lt;/code&gt; or any other primitive type to a user. But with structs, the way &lt;code&gt;println!&lt;/code&gt; should format the output is less clear because there are more display possibilities: Do you want commas or not? Do you want to print the curly brackets? Should all the fields be shown? Due to this ambiguity, Rust doesn&amp;rsquo;t try to guess what we want, and structs don&amp;rsquo;t have a provided implementation of &lt;code&gt;Display&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; 매크로는 여러 가지 형식을 지정할 수 있으며 기본적으로 중괄호는 &lt;code&gt;println!&lt;/code&gt; 알려줍니다 ! 최종 사용자가 직접 소비 할 수 있도록 &lt;code&gt;Display&lt;/code&gt; : 출력 이라는 형식을 사용 합니다. 지금까지 본 기본 유형은 사용자 에게 &lt;code&gt;1&lt;/code&gt; 또는 다른 기본 유형을 표시하려는 방법이 하나뿐이기 때문에 기본적으로 &lt;code&gt;Display&lt;/code&gt; 를 구현 합니다. 그러나 구조체와 함께 &lt;code&gt;println!&lt;/code&gt; 더 많은 표시 가능성이 있으므로 출력 형식을 명확하게 지정해야합니다. 쉼표를 원하십니까? 중괄호를 인쇄 하시겠습니까? 모든 필드가 표시되어야합니까? 이러한 모호성 때문에 Rust는 우리가 원하는 것을 추측하려고 시도하지 않으며 구조체에는 제공된 구현이 없습니다. &lt;code&gt;Display&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02931ec361bbc5f61952272ead50c2b1cc721cb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; macro is only capable of printing to standard output, so we have to use something else to print to standard error.</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; 매크로는 표준 출력으로 만 인쇄 할 수 있으므로 표준 오류로 인쇄하려면 다른 것을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="df3a7253c874e9c54aed370b97b0410e823ccbd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;proc_macro&lt;/code&gt; crate</source>
          <target state="translated">&lt;code&gt;proc_macro&lt;/code&gt; 상자</target>
        </trans-unit>
        <trans-unit id="0ebc19fdeafa41e303e045832093f26b01f1011c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a function.</source>
          <target state="translated">&lt;code&gt;pub&lt;/code&gt; 키워드는 함수 내에서 사용되었다.</target>
        </trans-unit>
        <trans-unit id="a4aeb159d9e69df04b16b32d0a540b4e48d1c2ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a function. Erroneous code example:</source>
          <target state="translated">&lt;code&gt;pub&lt;/code&gt; 키워드는 함수 내에서 사용되었다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="b670fe1e664ec6db0ea27f497b8f300d96565afa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a public enum.</source>
          <target state="translated">&lt;code&gt;pub&lt;/code&gt; 키워드는 공공 열거 내부에 사용되었다.</target>
        </trans-unit>
        <trans-unit id="d36ebedc5c61f3368fb308364706ea53f77e634b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a public enum. Erroneous code example:</source>
          <target state="translated">&lt;code&gt;pub&lt;/code&gt; 키워드는 공공 열거 내부에 사용되었다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="855c30613293c5803da1be19530bcff46d089f73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;push&lt;/code&gt; method takes a single character as a parameter and adds it to the &lt;code&gt;String&lt;/code&gt;. Listing 8-17 shows code that adds the letter &lt;em&gt;l&lt;/em&gt; to a &lt;code&gt;String&lt;/code&gt; using the &lt;code&gt;push&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; 방법은 매개 변수로 단일 문자를 취하고에 추가 &lt;code&gt;String&lt;/code&gt; . 코드 8-17은 &lt;code&gt;push&lt;/code&gt; 메소드를 사용하여 문자 &lt;em&gt;l&lt;/em&gt; 을 &lt;code&gt;String&lt;/code&gt; 추가하는 코드를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="e7c0b086ee3b65e9ef7299c70cf8f6fd0c56999e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quote!&lt;/code&gt; macro also provides some very cool templating mechanics: we can enter &lt;code&gt;#name&lt;/code&gt;, and &lt;code&gt;quote!&lt;/code&gt; will replace it with the value in the variable &lt;code&gt;name&lt;/code&gt;. You can even do some repetition similar to the way regular macros work. Check out &lt;a href=&quot;https://docs.rs/quote&quot;&gt;the &lt;code&gt;quote&lt;/code&gt; crate&amp;rsquo;s docs&lt;/a&gt; for a thorough introduction.</source>
          <target state="translated">&lt;code&gt;quote!&lt;/code&gt; 매크로는 또한 매우 멋진 템플릿 기법을 제공합니다 : &lt;code&gt;#name&lt;/code&gt; 을 입력 하고 &lt;code&gt;quote!&lt;/code&gt; 할 수 있습니다 ! 변수 &lt;code&gt;name&lt;/code&gt; 의 값으로 대체합니다 . 일반 매크로가 작동하는 방식과 유사한 반복을 수행 할 수도 있습니다. 확인 &lt;a href=&quot;https://docs.rs/quote&quot;&gt; &lt;code&gt;quote&lt;/code&gt; &lt;/a&gt; 상자의 문서를 철저하게 도입.</target>
        </trans-unit>
        <trans-unit id="62ab310a7862369bfdb3998e805adaae0cd4f2e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quote!&lt;/code&gt; macro lets us define the Rust code that we want to return. The compiler expects something different to the direct result of the &lt;code&gt;quote!&lt;/code&gt; macro&amp;rsquo;s execution, so we need to convert it to a &lt;code&gt;TokenStream&lt;/code&gt;. We do this by calling the &lt;code&gt;into&lt;/code&gt; method, which consumes this intermediate representation and returns a value of the required &lt;code&gt;TokenStream&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;quote!&lt;/code&gt; 매크로를 사용하면 반환하려는 Rust 코드를 정의 할 수 있습니다. 컴파일러는 &lt;code&gt;quote!&lt;/code&gt; 의 직접적인 결과와 다른 것을 기대합니다 ! 매크로의 실행으로 인해이를 &lt;code&gt;TokenStream&lt;/code&gt; 으로 변환해야합니다 . 이 중간 표현을 소비하고 필요한 &lt;code&gt;TokenStream&lt;/code&gt; 유형 의 값을 반환하는 &lt;code&gt;into&lt;/code&gt; 메소드 를 호출하여이를 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="53ae9c1c1e33423bee13e403e332e75689959214" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ready!&lt;/code&gt; call expands to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b83941e960f12671a681a1df28d6d59cb442a02e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursion_limit&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;recursion_limit&lt;/code&gt; 의 속성</target>
        </trans-unit>
        <trans-unit id="7fd3ec074e9dd99ae0db784fdf399ea43dd43516" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; and/or &lt;code&gt;mut&lt;/code&gt;&lt;em&gt;IDENTIFIER&lt;/em&gt; syntax matches any value and binds it to a variable with the same name as the given field.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 및 / 또는 &lt;code&gt;mut&lt;/code&gt; &lt;em&gt;식별자&lt;/em&gt; 구문은 특정 필드와 같은 이름의 변수에 대한 값을 귀속 일치한다.</target>
        </trans-unit>
        <trans-unit id="a07e646920bfd0169ef8462620bb6bf857e50545" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repeat()&lt;/code&gt; function repeats a single value over and over again.</source>
          <target state="translated">&lt;code&gt;repeat()&lt;/code&gt; 함수는 반복해서 하나의 값을 반복한다.</target>
        </trans-unit>
        <trans-unit id="ca6b7fab269378f975039696a9d029f43743fe55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repeat_with()&lt;/code&gt; function calls the repeater over and over again.</source>
          <target state="translated">&lt;code&gt;repeat_with()&lt;/code&gt; 함수는 또 다시 리피터를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="203b4d4e0f959a4e516770bf1c8acd411f9645d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request_review&lt;/code&gt; and &lt;code&gt;approve&lt;/code&gt; methods take ownership of &lt;code&gt;self&lt;/code&gt;, thus consuming the &lt;code&gt;DraftPost&lt;/code&gt; and &lt;code&gt;PendingReviewPost&lt;/code&gt; instances and transforming them into a &lt;code&gt;PendingReviewPost&lt;/code&gt; and a published &lt;code&gt;Post&lt;/code&gt;, respectively. This way, we won&amp;rsquo;t have any lingering &lt;code&gt;DraftPost&lt;/code&gt; instances after we&amp;rsquo;ve called &lt;code&gt;request_review&lt;/code&gt; on them, and so forth. The &lt;code&gt;PendingReviewPost&lt;/code&gt; struct doesn&amp;rsquo;t have a &lt;code&gt;content&lt;/code&gt; method defined on it, so attempting to read its content results in a compiler error, as with &lt;code&gt;DraftPost&lt;/code&gt;. Because the only way to get a published &lt;code&gt;Post&lt;/code&gt; instance that does have a &lt;code&gt;content&lt;/code&gt; method defined is to call the &lt;code&gt;approve&lt;/code&gt; method on a &lt;code&gt;PendingReviewPost&lt;/code&gt;, and the only way to get a &lt;code&gt;PendingReviewPost&lt;/code&gt; is to call the &lt;code&gt;request_review&lt;/code&gt; method on a &lt;code&gt;DraftPost&lt;/code&gt;, we&amp;rsquo;ve now encoded the blog post workflow into the type system.</source>
          <target state="translated">&lt;code&gt;request_review&lt;/code&gt; 및 &lt;code&gt;approve&lt;/code&gt; 방법의 소유권을 가지고 &lt;code&gt;self&lt;/code&gt; , 따라서 소비 &lt;code&gt;DraftPost&lt;/code&gt; 및 &lt;code&gt;PendingReviewPost&lt;/code&gt; 인스턴스를하고로 변환 &lt;code&gt;PendingReviewPost&lt;/code&gt; 및 게시 된 &lt;code&gt;Post&lt;/code&gt; 각각을,. 이런 식으로 &lt;code&gt;request_review&lt;/code&gt; 등 을 호출 한 후 남아있는 &lt;code&gt;DraftPost&lt;/code&gt; 인스턴스 가 없습니다 . &lt;code&gt;PendingReviewPost&lt;/code&gt; 의 구조체는없는 &lt;code&gt;content&lt;/code&gt; 때문에와 같은 컴파일러 오류에 컨텐츠 결과를 읽으려고, 그 위에 정의 된 방법을 &lt;code&gt;DraftPost&lt;/code&gt; . 게시 된 &lt;code&gt;Post&lt;/code&gt; 을 얻는 유일한 방법은가지고 예를 &lt;code&gt;content&lt;/code&gt; 정의 방법은 호출하는 것입니다 &lt;code&gt;approve&lt;/code&gt; A의 방법을 &lt;code&gt;PendingReviewPost&lt;/code&gt; 하고 얻을 수있는 유일한 방법 &lt;code&gt;PendingReviewPost&lt;/code&gt; 은 부르는 것입니다 &lt;code&gt;request_review&lt;/code&gt; 의 A의 방법을 &lt;code&gt;DraftPost&lt;/code&gt; 우리가 지금 형 시스템에 블로그 게시물 워크 플로우를 인코딩했습니다.</target>
        </trans-unit>
        <trans-unit id="14e654a0e6edb832d7ec2e9f01e2cec2e8fc8293" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request_review&lt;/code&gt; method on &lt;code&gt;Draft&lt;/code&gt; needs to return a new, boxed instance of a new &lt;code&gt;PendingReview&lt;/code&gt; struct, which represents the state when a post is waiting for a review. The &lt;code&gt;PendingReview&lt;/code&gt; struct also implements the &lt;code&gt;request_review&lt;/code&gt; method but doesn&amp;rsquo;t do any transformations. Rather, it returns itself, because when we request a review on a post already in the &lt;code&gt;PendingReview&lt;/code&gt; state, it should stay in the &lt;code&gt;PendingReview&lt;/code&gt; state.</source>
          <target state="translated">&lt;code&gt;Draft&lt;/code&gt; 의 &lt;code&gt;request_review&lt;/code&gt; 메소드 는 게시물이 검토 대기중인 상태를 나타내는 새로운 &lt;code&gt;PendingReview&lt;/code&gt; 구조체 의 새로운 박스형 인스턴스를 반환해야합니다 . &lt;code&gt;PendingReview&lt;/code&gt; 의 구조체는 또한 구현 &lt;code&gt;request_review&lt;/code&gt; 의 방법을하지만, 어떤 변환을하지 않습니다. 우리가 이미 게시물에 검토를 요청할 때 때문에 오히려 그 자체를 반환 &lt;code&gt;PendingReview&lt;/code&gt; 의 상태가를 유지해야 &lt;code&gt;PendingReview&lt;/code&gt; 의 상태입니다.</target>
        </trans-unit>
        <trans-unit id="e74e1506742074d3eac6be2b7d8e21235520da47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; command comes in handy when you need to rapidly iterate on a project, as we&amp;rsquo;ll do in this game, quickly testing each iteration before moving on to the next one.</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 우리는이 게임에서 할 수 있습니다 당신이 빨리 다음 단계로 이동하기 전에 각 반복 테스트, 프로젝트를 빠르게 반복 할 필요가있을 때 명령이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="46e85b1a08cc19eee77379933feec0b53082268f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; function definition</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 함수 정의</target>
        </trans-unit>
        <trans-unit id="5e5f409e03a8829700c6b7a5a46ab61b65379877" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; function now contains all the remaining logic from &lt;code&gt;main&lt;/code&gt;, starting from reading the file. The &lt;code&gt;run&lt;/code&gt; function takes the &lt;code&gt;Config&lt;/code&gt; instance as an argument.</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 기능은 지금부터 나머지 모든 로직을 포함 &lt;code&gt;main&lt;/code&gt; 파일을 읽는부터. &lt;code&gt;run&lt;/code&gt; 기능은 필요 &lt;code&gt;Config&lt;/code&gt; 인수로 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="6fc1541b8f6585c0ffe5cd745827dfb79f574e45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rustfmt&lt;/code&gt; tool reformats your code according to the community code style. Many collaborative projects use &lt;code&gt;rustfmt&lt;/code&gt; to prevent arguments about which style to use when writing Rust: everyone formats their code using the tool.</source>
          <target state="translated">&lt;code&gt;rustfmt&lt;/code&gt; 의 도구는 지역 코드 스타일에 따라 코드를 다시 포맷합니다. 많은 협업 프로젝트는 &lt;code&gt;rustfmt&lt;/code&gt; 를 사용 하여 Rust를 작성할 때 어떤 스타일을 사용 해야하는지 에 대한 논쟁을 막습니다. 모두가 도구를 사용하여 코드를 포맷합니다.</target>
        </trans-unit>
        <trans-unit id="f41fbdae4087d677734daccb36bd68168ac22c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_bucket&lt;/code&gt; function is passed references to two elements from the slice and must determine if the elements compare equal. The elements are passed in opposite order from their order in the slice, so if &lt;code&gt;same_bucket(a, b)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is moved at the end of the slice.</source>
          <target state="translated">&lt;code&gt;same_bucket&lt;/code&gt; 의 함수는 슬라이스에서 두 개의 요소에 대한 참조를 전달하고, 요소가 동일한 경우, 비교 판단한다. 요소는 그렇다면 슬라이스에서 순서 역순으로 전달된다 &lt;code&gt;same_bucket(a, b)&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; 슬라이스의 끝으로 이동한다.</target>
        </trans-unit>
        <trans-unit id="51106981f7e1a09193991d8a2ebd9672888c0e0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_bucket&lt;/code&gt; function is passed references to two elements from the vector and must determine if the elements compare equal. The elements are passed in opposite order from their order in the slice, so if &lt;code&gt;same_bucket(a, b)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is removed.</source>
          <target state="translated">&lt;code&gt;same_bucket&lt;/code&gt; 의 함수는 벡터에서 두 개의 요소에 대한 참조를 전달하고, 요소가 동일한 경우, 비교 판단한다. 요소는 슬라이스의 순서와 반대 순서로 전달되므로 &lt;code&gt;same_bucket(a, b)&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 &lt;code&gt;a&lt;/code&gt; 가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="a14ee345d1496dff6fbc5e218ae3b33c17f09dd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;search_case_insensitive&lt;/code&gt; function, shown in Listing 12-21, will be almost the same as the &lt;code&gt;search&lt;/code&gt; function. The only difference is that we&amp;rsquo;ll lowercase the &lt;code&gt;query&lt;/code&gt; and each &lt;code&gt;line&lt;/code&gt; so whatever the case of the input arguments, they&amp;rsquo;ll be the same case when we check whether the line contains the query.</source>
          <target state="translated">&lt;code&gt;search_case_insensitive&lt;/code&gt; 목록 12-21에 표시된 기능은,는 거의 동일합니다 &lt;code&gt;search&lt;/code&gt; 기능. 유일한 차이점은 &lt;code&gt;query&lt;/code&gt; 와 각 &lt;code&gt;line&lt;/code&gt; 소문자로 입력하므로 입력 인수의 경우에 상관없이 줄에 쿼리가 포함되어 있는지 확인할 때와 같은 경우가됩니다.</target>
        </trans-unit>
        <trans-unit id="bbcc387564e51cca06178b88f2766991af78a4d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; crate may be imported which creates a binding to the current crate. In this case the &lt;code&gt;as&lt;/code&gt; clause must be used to specify the name to bind it to.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 상자는 현재의 상자에 바인딩을 생성하는 가져올 수 있습니다. 이 경우 &lt;code&gt;as&lt;/code&gt; 절을 사용하여 바인딩 할 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5df3512b09c8677b58f509f70a4092543dbb8630" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; import appears more than once in the list.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 수입은 더 목록에 두 번 이상 나타납니다.</target>
        </trans-unit>
        <trans-unit id="776137337eaf5141c6cf75f1ef731869806d23fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword can only be used inside methods, which are associated functions (functions defined inside of a &lt;code&gt;trait&lt;/code&gt; or &lt;code&gt;impl&lt;/code&gt; block) that have a &lt;code&gt;self&lt;/code&gt; receiver as its first parameter, like &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;code&gt;&amp;amp;mut self&lt;/code&gt; or &lt;code&gt;self: &amp;amp;mut Pin&amp;lt;Self&amp;gt;&lt;/code&gt; (this last one is an example of an &lt;a href=&quot;https://github.com/rust-lang/rust/issues/44874&quot;&gt;&quot;abitrary &lt;code&gt;self&lt;/code&gt; type&quot;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 키워드은 함수 (a 내부에 정의 된 함수 연관되는 방법 내에서 사용될 수있는 &lt;code&gt;trait&lt;/code&gt; 또는 &lt;code&gt;impl&lt;/code&gt; 가 차단) &lt;code&gt;self&lt;/code&gt; 와 같은, 첫번째 파라미터로서 수신기 &lt;code&gt;self&lt;/code&gt; , &lt;code&gt;&amp;amp;self&lt;/code&gt; , &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 또는 &lt;code&gt;self: &amp;amp;mut Pin&amp;lt;Self&amp;gt;&lt;/code&gt; (이 마지막 항목은 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/44874&quot;&gt;&quot;비 &lt;code&gt;self&lt;/code&gt; 유형&quot;&lt;/a&gt; 의 예입니다 ).</target>
        </trans-unit>
        <trans-unit id="31848a0c1be52494be53b5a9553dbe8630cef51b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword can only be used inside methods, which are associated functions (functions defined inside of a &lt;code&gt;trait&lt;/code&gt; or &lt;code&gt;impl&lt;/code&gt; block) that have a &lt;code&gt;self&lt;/code&gt; receiver as its first parameter, like &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;code&gt;&amp;amp;mut self&lt;/code&gt; or &lt;code&gt;self: &amp;amp;mut Pin&amp;lt;Self&amp;gt;&lt;/code&gt; (this last one is an example of an &lt;a href=&quot;https://github.com/rust-lang/rust/issues/44874&quot;&gt;&quot;arbitrary &lt;code&gt;self&lt;/code&gt; type&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca20974e52a0607307348bb19d0d894eb2389060" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword cannot appear alone as the last segment in a &lt;code&gt;use&lt;/code&gt; declaration.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 키워드는의 마지막 부분으로 만 나타날 수 없습니다 &lt;code&gt;use&lt;/code&gt; 선언.</target>
        </trans-unit>
        <trans-unit id="3baa95a2b4735c8ad9eb06f47e895376f593ffa3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword was used in a static method.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 키워드는 정적 방법에 사용되었다.</target>
        </trans-unit>
        <trans-unit id="a9568dcdfe3a23be1dee117543923d717013ab13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword was used inside of an associated function without a &quot;&lt;code&gt;self&lt;/code&gt; receiver&quot; parameter.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 키워드는 &quot;없이 연관 함수의 내부를 사용한 &lt;code&gt;self&lt;/code&gt; 수신기&quot;파라미터.</target>
        </trans-unit>
        <trans-unit id="f67620c2fbc5330097742f848b2b9886ad0ef4ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; parameter in a method has an invalid &quot;receiver type&quot;.</source>
          <target state="translated">메소드 의 &lt;code&gt;self&lt;/code&gt; 매개 변수에 유효하지 않은 &quot;수신자 유형&quot;이 있습니다.</target>
        </trans-unit>
        <trans-unit id="71e55d8484323ba680a4d79f359c6a8e4726809e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sent_messages&lt;/code&gt; field is now of type &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; instead of &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;/code&gt;. In the &lt;code&gt;new&lt;/code&gt; function, we create a new &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; instance around the empty vector.</source>
          <target state="translated">&lt;code&gt;sent_messages&lt;/code&gt; 의 필드는 이제 유형 인 &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; 대신 &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;/code&gt; . 에서 &lt;code&gt;new&lt;/code&gt; 기능, 우리는 새로운 만들 &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; 빈 벡터 주변의 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="337c62942744e545dcf717c6319edbedc18f313b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shoes_in_my_size&lt;/code&gt; function takes ownership of a vector of shoes and a shoe size as parameters. It returns a vector containing only shoes of the specified size.</source>
          <target state="translated">&lt;code&gt;shoes_in_my_size&lt;/code&gt; 의 기능은 신발의 벡터 및 매개 변수로 신발 사이즈의 소유권을 가져옵니다. 지정된 크기의 신발 만 포함하는 벡터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="16a60caa064b42a78f27eb4d74ff02e2b3b32b36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;should_panic&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;should_panic&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="639f1b128b2e8340c54ba2df925fcc505b0aa67b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;should_panic&lt;/code&gt; attribute may optionally take an input string that must appear within the panic message. If the string is not found in the message, then the test will fail. The string may be passed using the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax or the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax with an &lt;code&gt;expected&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;should_panic&lt;/code&gt; 속성은 선택적으로 패닉 메시지 안에 있어야 입력 문자열이 걸릴 수 있습니다. 메시지에 문자열이 없으면 테스트가 실패합니다. 문자열은 &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; 구문 또는 &lt;code&gt;expected&lt;/code&gt; 필드 가있는 &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; 구문을 사용하여 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47db49dacc0e9fe0c5ab4b84de0a525fbcc167ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;simd_shuffle&lt;/code&gt; function needs the length of the array passed as last parameter in its name. Example:</source>
          <target state="translated">&lt;code&gt;simd_shuffle&lt;/code&gt; 함수 이름 마지막 매개 변수로 전달 된 배열의 길이가 필요하다. 예:</target>
        </trans-unit>
        <trans-unit id="1728894948cd279e5a554b1af44ad631d3c73ca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;spawn&lt;/code&gt; function returns a &lt;code&gt;JoinHandle&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the type that the closure returns. Let&amp;rsquo;s try using &lt;code&gt;JoinHandle&lt;/code&gt; too and see what happens. In our case, the closures we&amp;rsquo;re passing to the thread pool will handle the connection and not return anything, so &lt;code&gt;T&lt;/code&gt; will be the unit type &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;spawn&lt;/code&gt; 함수 리턴 &lt;code&gt;JoinHandle&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;T&lt;/code&gt; 는 밀폐 반환하는 타입이다. &lt;code&gt;JoinHandle&lt;/code&gt; 도 사용 해보고 어떻게되는지 보자 . 우리의 경우 스레드 풀에 전달되는 클로저는 연결을 처리하고 아무것도 반환하지 않으므로 &lt;code&gt;T&lt;/code&gt; 는 단위 유형 &lt;code&gt;()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="566807adf1a1b2e0676b75e750b724f0403f4cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; path is not a file or doesn't exist.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 경로는 파일이 아니거나 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b80b9ca4d5b5301222f74ba4e7cb474c1a9b0c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start..&lt;/code&gt; syntax is a &lt;code&gt;RangeFrom&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d29bbe16c04fa990f15f7ad6e1fd231be48fb8e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start..=end&lt;/code&gt; syntax is a &lt;code&gt;RangeInclusive&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f551a983bf25bb9ca332d4bf79a3c5ffe5eff531" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start..end&lt;/code&gt; syntax is a &lt;code&gt;Range&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07635229348f3268d25fca1958c374b441ce892b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; function was defined with a where clause.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 기능은 where 절에 정의 하였다.</target>
        </trans-unit>
        <trans-unit id="a73480c4afd7847e00e31fe3aafec20a20c54b25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;static&lt;/code&gt; keyword, on the other hand, guarantees a fixed location in memory. This does not always mean that the value is constant. For example, a global mutex can be declared &lt;code&gt;static&lt;/code&gt; as well.</source>
          <target state="translated">반면 &lt;code&gt;static&lt;/code&gt; 키워드는 메모리에서 고정 된 위치를 보장합니다. 이것이 항상 값이 일정하다는 것을 의미하지는 않습니다. 예를 들어, 전역 뮤텍스도 &lt;code&gt;static&lt;/code&gt; 으로 선언 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d33afa111381148e1c91bd2523fbea89118180e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::env&lt;/code&gt; module contains many more useful features for dealing with environment variables: check out its documentation to see what is available.</source>
          <target state="translated">&lt;code&gt;std::env&lt;/code&gt; 모듈은 환경 변수를 처리하기위한 더 많은 유용한 기능을 포함 : 가능한 것이 무엇인지 알아보기 위해 문서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="bcaf28a16adceb8447193d5235bef5d8bd3335ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::io&lt;/code&gt; module contains a number of common things you'll need when doing input and output. The most core part of this module is the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; traits, which provide the most general interface for reading and writing input and output.</source>
          <target state="translated">&lt;code&gt;std::io&lt;/code&gt; 모듈은 입력 및 출력을 할 때 당신이 필요합니다 일반적인 여러 가지가 포함되어 있습니다. 이 모듈의 가장 핵심 부분은 입력 및 출력을 읽고 쓰는 데 가장 일반적인 인터페이스를 제공하는 &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; 특성입니다.</target>
        </trans-unit>
        <trans-unit id="4a54af6bd4d1bf95ed93c13cd61787ff3a49ae58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::mem::drop&lt;/code&gt; function is different from the &lt;code&gt;drop&lt;/code&gt; method in the &lt;code&gt;Drop&lt;/code&gt; trait. We call it by passing the value we want to force to be dropped early as an argument. The function is in the prelude, so we can modify &lt;code&gt;main&lt;/code&gt; in Listing 15-15 to call the &lt;code&gt;drop&lt;/code&gt; function, as shown in Listing 15-16:</source>
          <target state="translated">&lt;code&gt;std::mem::drop&lt;/code&gt; 기능은 상이한 &lt;code&gt;drop&lt;/code&gt; 메소드 &lt;code&gt;Drop&lt;/code&gt; 특성. 우리는 그것을 강제로 포기하고 싶은 가치를 인수로 전달하여 그것을 부릅니다. 이 함수는 전주곡에 있으므로 Listing 15-16에서와 같이 Listing 15-15에서 &lt;code&gt;main&lt;/code&gt; 을 수정 하여 &lt;code&gt;drop&lt;/code&gt; 함수 를 호출 할 수있다 .</target>
        </trans-unit>
        <trans-unit id="964c58feb2d7a0e4b6c63c315388a37636bb2ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;steps_between&lt;/code&gt; function provides a way to efficiently compare two &lt;code&gt;Step&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;steps_between&lt;/code&gt; 의 효율적이 비교에 함수는 방법을 제공합니다 &lt;code&gt;Step&lt;/code&gt; 개체를.</target>
        </trans-unit>
        <trans-unit id="3d6948e046aa3d769d70c7d7f5831db7b61d283e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;str&lt;/code&gt; type, also called a 'string slice', is the most primitive string type. It is usually seen in its borrowed form, &lt;code&gt;&amp;amp;str&lt;/code&gt;. It is also the type of string literals, &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 도 '문자열 조각'이라는 유형은, 가장 원시적 인 문자열 유형입니다. 일반적으로 빌린 형태 인 &lt;code&gt;&amp;amp;str&lt;/code&gt; 됩니다. 또한 문자열 리터럴의 유형 인 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4ea4c33d08beaf7c17c84c4930138d5a7a1f80fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stringify!&lt;/code&gt; macro used here is built into Rust. It takes a Rust expression, such as &lt;code&gt;1 + 2&lt;/code&gt;, and at compile time turns the expression into a string literal, such as &lt;code&gt;&quot;1 + 2&quot;&lt;/code&gt;. This is different than &lt;code&gt;format!&lt;/code&gt; or &lt;code&gt;println!&lt;/code&gt;, macros which evaluate the expression and then turn the result into a &lt;code&gt;String&lt;/code&gt;. There is a possibility that the &lt;code&gt;#name&lt;/code&gt; input might be an expression to print literally, so we use &lt;code&gt;stringify!&lt;/code&gt;. Using &lt;code&gt;stringify!&lt;/code&gt; also saves an allocation by converting &lt;code&gt;#name&lt;/code&gt; to a string literal at compile time.</source>
          <target state="translated">&lt;code&gt;stringify!&lt;/code&gt; 여기에 사용 된 매크로는 Rust에 내장되어 있습니다. &lt;code&gt;1 + 2&lt;/code&gt; 와 같은 Rust 표현식을 취하고 컴파일 타임에 표현식을 &lt;code&gt;&quot;1 + 2&quot;&lt;/code&gt; 와 같은 문자열 리터럴로 바꿉니다 . 이것은 &lt;code&gt;format!&lt;/code&gt; 과 다릅니다 ! 또는 &lt;code&gt;println!&lt;/code&gt; 매크로는 표현식을 평가 한 다음 결과를 &lt;code&gt;String&lt;/code&gt; 로 바꿉니다 . &lt;code&gt;#name&lt;/code&gt; 입력은 문자 그대로 인쇄하는 표현식 일 가능성이 있으므로 &lt;code&gt;stringify!&lt;/code&gt; 를 사용합니다 ! . &lt;code&gt;stringify!&lt;/code&gt; 사용 ! 또한 컴파일 할 때 &lt;code&gt;#name&lt;/code&gt; 을 문자열 리터럴 로 변환하여 할당을 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="5e2bbf89c9d53502f02966909193300b8b8e39a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;syn&lt;/code&gt; crate parses Rust code from a string into a data structure that we can perform operations on. The &lt;code&gt;quote&lt;/code&gt; crate turns &lt;code&gt;syn&lt;/code&gt; data structures back into Rust code. These crates make it much simpler to parse any sort of Rust code we might want to handle: writing a full parser for Rust code is no simple task.</source>
          <target state="translated">&lt;code&gt;syn&lt;/code&gt; 상자는 우리가 작업을 수행 할 수있는 데이터 구조로 문자열에서 녹 코드를 구문 분석합니다. &lt;code&gt;quote&lt;/code&gt; 상자의 회전 &lt;code&gt;syn&lt;/code&gt; 데이터 구조 녹 코드로 백업 할 수 있습니다. 이 상자들은 우리가 처리하고자하는 모든 종류의 Rust 코드를 파싱하는 것을 훨씬 간단하게 만듭니다 : Rust 코드를위한 완전한 파서를 작성하는 것은 간단한 일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4c2f6cfbefda1dc3521b2af3bf1923ea6ba12d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;take&lt;/code&gt; method is defined in the &lt;code&gt;Iterator&lt;/code&gt; trait and limits the iteration to the first two items at most. The &lt;code&gt;ThreadPool&lt;/code&gt; will go out of scope at the end of &lt;code&gt;main&lt;/code&gt;, and the &lt;code&gt;drop&lt;/code&gt; implementation will run.</source>
          <target state="translated">&lt;code&gt;take&lt;/code&gt; 방법은 정의되어 &lt;code&gt;Iterator&lt;/code&gt; 특성에 가장 처음 두 항목 반복을 제한한다. &lt;code&gt;ThreadPool&lt;/code&gt; 의 끝에서 범위 밖으로 이동합니다 &lt;code&gt;main&lt;/code&gt; 및 &lt;code&gt;drop&lt;/code&gt; 구현이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f4261b148ae0a22c8791698e09a2d9939e795de1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target_feature&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;target_feature&lt;/code&gt; 의 속성</target>
        </trans-unit>
        <trans-unit id="0bfa2ee4e02addd4c71ab19bd1f7c85cc21dadfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="c6b28a9d1db605fca4af25fdaf7d2f63f3f4ff7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;track_caller&lt;/code&gt; attribute may be applied to any function with &lt;a href=&quot;../items/external-blocks#abi&quot;&gt;&lt;code&gt;&quot;Rust&quot;&lt;/code&gt; ABI&lt;/a&gt; with the exception of the entry point &lt;code&gt;fn main&lt;/code&gt;. When applied to functions and methods in trait declarations, the attribute applies to all implementations. If the trait provides a default implementation with the attribute, then the attribute also applies to override implementations.</source>
          <target state="translated">&lt;code&gt;track_caller&lt;/code&gt; 의 속성은 어떤 기능을 적용 할 수있다 &lt;a href=&quot;../items/external-blocks#abi&quot;&gt; &lt;code&gt;&quot;Rust&quot;&lt;/code&gt; ABI&lt;/a&gt; 엔트리 포인트를 제외한 &lt;code&gt;fn main&lt;/code&gt; . 특성 선언의 함수 및 메서드에 적용될 때 속성은 모든 구현에 적용됩니다. 특성이 특성과 함께 기본 구현을 제공하는 경우 특성은 재정의 구현에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dbbce8f10ed8de46d53a88134091400a4cad8f24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; Representation</source>
          <target state="translated">&lt;code&gt;transparent&lt;/code&gt; 표현</target>
        </trans-unit>
        <trans-unit id="16cfac7d668a26094fafdea930dd55dadb7672de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; representation can only be used on &lt;code&gt;struct&lt;/code&gt;s that have a single non-zero sized field and any number of zero-sized fields, including &lt;a href=&quot;special-types-and-traits#phantomdatat&quot;&gt;&lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;transparent&lt;/code&gt; 표현에서만 사용할 수있는 &lt;code&gt;struct&lt;/code&gt; 는 단일 비 - 제로 필드 크기를 포함한 크기 0의 필드의 개수가 S &lt;a href=&quot;special-types-and-traits#phantomdatat&quot;&gt; &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="811b48cd1ea2c8f7773b17e401a6ef4a6664ee6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; representation can only be used on a &lt;a href=&quot;items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/a&gt; with a single variant that has:</source>
          <target state="translated">&lt;code&gt;transparent&lt;/code&gt; 표현 만 사용할 수 있습니다 &lt;a href=&quot;items/structs&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; &lt;/a&gt; 갖는 단일 변종 :</target>
        </trans-unit>
        <trans-unit id="01d7d7afaf943b9e9b10757db03a01818240c2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try_recv&lt;/code&gt; method doesn&amp;rsquo;t block, but will instead return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; immediately: an &lt;code&gt;Ok&lt;/code&gt; value holding a message if one is available and an &lt;code&gt;Err&lt;/code&gt; value if there aren&amp;rsquo;t any messages this time. Using &lt;code&gt;try_recv&lt;/code&gt; is useful if this thread has other work to do while waiting for messages: we could write a loop that calls &lt;code&gt;try_recv&lt;/code&gt; every so often, handles a message if one is available, and otherwise does other work for a little while until checking again.</source>
          <target state="translated">&lt;code&gt;try_recv&lt;/code&gt; 의 방법은 차단하지 않고, 대신 돌아갑니다 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 즉시 : &lt;code&gt;Ok&lt;/code&gt; 하나가 가능하며, 경우에 값이 메시지를 들고 &lt;code&gt;Err&lt;/code&gt; 이 시간 모든 메시지가없는 경우 값을. 이 스레드가 메시지를 기다리는 동안 다른 작업을 수행하는 경우 &lt;code&gt;try_recv&lt;/code&gt; 를 사용하면 유용합니다. 우리는 &lt;code&gt;try_recv&lt;/code&gt; 를 호출하는 루프를 자주 작성하고, 사용 가능한 경우 메시지를 처리하고, 다시 검사 할 때까지 잠시 동안 다른 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c06a34327e19720b6fdb343c408e7c55dd84e16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type Target = T;&lt;/code&gt; syntax defines an associated type for the &lt;code&gt;Deref&lt;/code&gt; trait to use. Associated types are a slightly different way of declaring a generic parameter, but you don&amp;rsquo;t need to worry about them for now; we&amp;rsquo;ll cover them in more detail in Chapter 19.</source>
          <target state="translated">&lt;code&gt;type Target = T;&lt;/code&gt; 구문은 &lt;code&gt;Deref&lt;/code&gt; 특성이 사용할 관련 유형을 정의합니다 . 연관된 유형은 일반 매개 변수를 선언하는 약간 다른 방법이지만 지금은 걱정할 필요가 없습니다. 이에 대해서는 19 장에서 자세히 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="ed8f6c9e0893fd91a5e6d611722172ed9ef6f6c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type_length_limit&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;type_length_limit&lt;/code&gt; 의 속성</target>
        </trans-unit>
        <trans-unit id="88b76f9ce33c0af8e240ed6b37ada9e83ea43da5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; keyword is currently reserved but unimplemented.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 키워드는 현재 예약 만 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7495ddf8e7dd908218ee8fe0115f879a8fb5ec94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; keyword is currently reserved but unimplemented. Erroneous code example:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 키워드는 현재 예약 만 구현되지 않습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="dd3cfc211f63708e7ec9409ea2198c30928717cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; keyword has two uses: to declare the existence of contracts the compiler can't check (&lt;code&gt;unsafe fn&lt;/code&gt; and &lt;code&gt;unsafe trait&lt;/code&gt;), and to declare that a programmer has checked that these contracts have been upheld (&lt;code&gt;unsafe {}&lt;/code&gt; and &lt;code&gt;unsafe impl&lt;/code&gt;, but also &lt;code&gt;unsafe fn&lt;/code&gt; -- see below). They are not mutually exclusive, as can be seen in &lt;code&gt;unsafe fn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 키워드는 두 가지 용도가 있습니다 컴파일러 (확인할 수 없습니다 계약의 존재를 선언하는 &lt;code&gt;unsafe fn&lt;/code&gt; 과 &lt;code&gt;unsafe trait&lt;/code&gt; ), 그리고 프로그래머가 이러한 계약이 확정 된 것을 확인했다고 선언 ( &lt;code&gt;unsafe {}&lt;/code&gt; 와 &lt;code&gt;unsafe impl&lt;/code&gt; 하지만, 또한 &lt;code&gt;unsafe fn&lt;/code&gt; 아래 참조). &lt;code&gt;unsafe fn&lt;/code&gt; 에서 볼 수 있듯이 상호 배타적이지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b3bcdab50b34b5e5716db8fd4a0ee45ad2abea8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; keyword is syntactically allowed to appear before the &lt;code&gt;extern&lt;/code&gt; keyword, but it is rejected at a semantic level. This allows macros to consume the syntax and make use of the &lt;code&gt;unsafe&lt;/code&gt; keyword, before removing it from the token stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="205e3b2923533eb22d4e09801e3f784e668f24fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; keyword is syntactically allowed to appear before the &lt;code&gt;mod&lt;/code&gt; keyword, but it is rejected at a semantic level. This allows macros to consume the syntax and make use of the &lt;code&gt;unsafe&lt;/code&gt; keyword, before removing it from the token stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a346e1081bfa2911e1aa0fde6117ab4a081928a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; qualifier indicates that the type's value is an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt;, and the &lt;code&gt;extern&lt;/code&gt; qualifier indicates it is an &lt;a href=&quot;../items/functions#extern-function-qualifier&quot;&gt;extern function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 규정이 타입의 값이 있음을 나타내는 &lt;a href=&quot;../unsafe-functions&quot;&gt;안전 기능&lt;/a&gt; 및 &lt;code&gt;extern&lt;/code&gt; 규정은 그것이하다고되어 &lt;a href=&quot;../items/functions#extern-function-qualifier&quot;&gt;통근 기능&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="994e471fd3da940319d1417edcfca60d6a3db828" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; qualifier indicates that the type's value is an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt;, and the &lt;code&gt;extern&lt;/code&gt; qualifier indicates it is an &lt;a href=&quot;../items/functions#extern-functions&quot;&gt;extern function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 규정이 타입의 값이 있음을 나타내는 &lt;a href=&quot;../unsafe-functions&quot;&gt;안전 기능&lt;/a&gt; 및 &lt;code&gt;extern&lt;/code&gt; 규정은 그것이하다고되어 &lt;a href=&quot;../items/functions#extern-functions&quot;&gt;통근 기능&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78ba9e0cc65cc7840eaadd16f98f7cca440cd4f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unwind&lt;/code&gt; attribute was malformed.</source>
          <target state="translated">&lt;code&gt;unwind&lt;/code&gt; 속성의 형식이 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="a60fd78a94b551f1746c4a391dd52899994edd99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;used&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;used&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="762cbbe7d454d7148fa1b85ecdd6dd222c5646ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;usize&lt;/code&gt; type is an unsigned integer type with the same number of bits as the platform's pointer type. It can represent every memory address in the process.</source>
          <target state="translated">&lt;code&gt;usize&lt;/code&gt; 의 타입 플랫폼의 포인터 타입과 동일한 수의 비트를 갖는 부호없는 정수 형태이다. 프로세스의 모든 메모리 주소를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca7074c2679596c96e2d40f1a9e7060f1f83b71a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; field is of type &lt;code&gt;Option&amp;lt;u32&amp;gt;&lt;/code&gt;. Before we execute the closure, &lt;code&gt;value&lt;/code&gt; will be &lt;code&gt;None&lt;/code&gt;. When code using a &lt;code&gt;Cacher&lt;/code&gt; asks for the &lt;em&gt;result&lt;/em&gt; of the closure, the &lt;code&gt;Cacher&lt;/code&gt; will execute the closure at that time and store the result within a &lt;code&gt;Some&lt;/code&gt; variant in the &lt;code&gt;value&lt;/code&gt; field. Then if the code asks for the result of the closure again, instead of executing the closure again, the &lt;code&gt;Cacher&lt;/code&gt; will return the result held in the &lt;code&gt;Some&lt;/code&gt; variant.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 필드는 유형이다 &lt;code&gt;Option&amp;lt;u32&amp;gt;&lt;/code&gt; . 클로저를 실행하기 전에 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;None&lt;/code&gt; 입니다. &lt;code&gt;Cacher&lt;/code&gt; 사용하는 코드 가 클로저 &lt;em&gt;결과&lt;/em&gt; 를 요청 하면, &lt;code&gt;Cacher&lt;/code&gt; 는 그 시점에 클로저를 실행하고 결과를 &lt;code&gt;value&lt;/code&gt; 필드 의 &lt;code&gt;Some&lt;/code&gt; 변형 내에 저장합니다 . 그런 다음 코드가 클로저 결과를 다시 요청하면 클로저를 다시 실행하는 대신 &lt;code&gt;Cacher&lt;/code&gt; 는 &lt;code&gt;Some&lt;/code&gt; 변형 에서 보유한 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5defa2a7e24b93d29be444c6bce3655062b73aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vtable&lt;/code&gt; customizes the behavior of a &lt;code&gt;Waker&lt;/code&gt; which gets created from a &lt;code&gt;RawWaker&lt;/code&gt;. For each operation on the &lt;code&gt;Waker&lt;/code&gt;, the associated function in the &lt;code&gt;vtable&lt;/code&gt; of the underlying &lt;code&gt;RawWaker&lt;/code&gt; will be called.</source>
          <target state="translated">&lt;code&gt;vtable&lt;/code&gt; a의 동작을 사용자 정의 &lt;code&gt;Waker&lt;/code&gt; A로부터 작성되는 &lt;code&gt;RawWaker&lt;/code&gt; 을 . &lt;code&gt;Waker&lt;/code&gt; 의 각 작업에 대해 기본 &lt;code&gt;RawWaker&lt;/code&gt; 의 &lt;code&gt;vtable&lt;/code&gt; 에있는 관련 함수 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="58deddf572f1c05716c0aff255109ee68c618f77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wasm_import_module&lt;/code&gt; key may be used to specify the &lt;a href=&quot;https://webassembly.github.io/spec/core/syntax/modules.html&quot;&gt;WebAssembly module&lt;/a&gt; name for the items within an &lt;code&gt;extern&lt;/code&gt; block when importing symbols from the host environment. The default module name is &lt;code&gt;env&lt;/code&gt; if &lt;code&gt;wasm_import_module&lt;/code&gt; is not specified.</source>
          <target state="translated">&lt;code&gt;wasm_import_module&lt;/code&gt; 의 키를 지정하는데 사용될 수있다 &lt;a href=&quot;https://webassembly.github.io/spec/core/syntax/modules.html&quot;&gt;WebAssembly 모듈&lt;/a&gt; 내의 항목 이름 &lt;code&gt;extern&lt;/code&gt; 호스트 환경에서 심볼을 가져올 때 블록. &lt;code&gt;wasm_import_module&lt;/code&gt; 이 지정되지 않은 경우 기본 모듈 이름은 &lt;code&gt;env&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="03b2e1ae71fdcbd9ffac8eca408ab8d4e8472f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt; fields on &lt;code&gt;Button&lt;/code&gt; will differ from the fields on other components, such as a &lt;code&gt;TextField&lt;/code&gt; type, that might have those fields plus a &lt;code&gt;placeholder&lt;/code&gt; field instead. Each of the types we want to draw on the screen will implement the &lt;code&gt;Draw&lt;/code&gt; trait but will use different code in the &lt;code&gt;draw&lt;/code&gt; method to define how to draw that particular type, as &lt;code&gt;Button&lt;/code&gt; has here (without the actual GUI code, which is beyond the scope of this chapter). The &lt;code&gt;Button&lt;/code&gt; type, for instance, might have an additional &lt;code&gt;impl&lt;/code&gt; block containing methods related to what happens when a user clicks the button. These kinds of methods won&amp;rsquo;t apply to types like &lt;code&gt;TextField&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Button&lt;/code&gt; 의 &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; 및 &lt;code&gt;label&lt;/code&gt; 필드 는 &lt;code&gt;TextField&lt;/code&gt; 유형 과 같은 다른 구성 요소의 필드와 다른 필드 및 &lt;code&gt;placeholder&lt;/code&gt; 필드 가있는 필드와 다릅니다 . 우리가 화면에 그리려는 각 유형은 &lt;code&gt;Draw&lt;/code&gt; 특성 을 구현 하지만 &lt;code&gt;Button&lt;/code&gt; 이 여기에있는 것처럼 (범위를 벗어난 실제 GUI 코드없이) 특정 유형을 그리는 방법을 정의하기 위해 &lt;code&gt;draw&lt;/code&gt; 메소드 에서 다른 코드 를 사용합니다 이 장의). &lt;code&gt;Button&lt;/code&gt; 타입은, 예를 들어, 추가 할 수도 있습니다 &lt;code&gt;impl&lt;/code&gt; 사용자가 버튼을 클릭 할 때 발생하는 것과 관련된 방법을 포함하는 블록. 이러한 종류의 메소드는 &lt;code&gt;TextField&lt;/code&gt; 와 같은 유형에는 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="49fef96b0756f10c5fd5c7fedcccb9ee963b501d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;windows_subsystem&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;windows_subsystem&lt;/code&gt; 의 속성</target>
        </trans-unit>
        <trans-unit id="fe674a5495eedc22d7ae598194abec96fa238a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; function takes an output stream, and an &lt;code&gt;Arguments&lt;/code&gt; struct that can be precompiled with the &lt;code&gt;format_args!&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 기능은 출력 스트림을 얻어, 및 &lt;code&gt;Arguments&lt;/code&gt; 프리 컴파일 될 수있는 구조체 &lt;code&gt;format_args!&lt;/code&gt; 매크로.</target>
        </trans-unit>
        <trans-unit id="5644d7245fdec36266e15ee66f56202b01bc587d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt; part is a pattern! As we did with &lt;code&gt;let&lt;/code&gt;, we could match a tuple in a function&amp;rsquo;s arguments to the pattern. Listing 18-7 splits the values in a tuple as we pass it to a function.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 부분은 패턴이다! &lt;code&gt;let&lt;/code&gt; 으로 했던 것처럼 함수 인수의 튜플을 패턴과 일치시킬 수 있습니다. 코드 18-7은 값을 함수에 전달할 때 튜플의 값을 분할합니다.</target>
        </trans-unit>
        <trans-unit id="90c7cb6860c6df5927660a73f110e2f9166750a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt; value is moved into the closure when the closure is defined, because we added the &lt;code&gt;move&lt;/code&gt; keyword. The closure then has ownership of &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;main&lt;/code&gt; isn&amp;rsquo;t allowed to use &lt;code&gt;x&lt;/code&gt; anymore in the &lt;code&gt;println!&lt;/code&gt; statement. Removing &lt;code&gt;println!&lt;/code&gt; will fix this example.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 폐쇄를 정의 할 때 우리는 추가 때문에 값이 폐쇄로 이동 &lt;code&gt;move&lt;/code&gt; 키워드를. 폐쇄는 다음의 소유권이 &lt;code&gt;x&lt;/code&gt; 하고, &lt;code&gt;main&lt;/code&gt; 사용 용도에 사용할 수 없습니다 &lt;code&gt;x&lt;/code&gt; 에 더 이상 &lt;code&gt;println!&lt;/code&gt; 성명서. &lt;code&gt;println!&lt;/code&gt; 제거하는 중 ! 이 예제를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="693d3b957625a8e3df8f4384a832c7be5cfa15d0" translate="yes" xml:space="preserve">
          <source>The &lt;em id=&quot;the-tests-directory&quot;&gt;tests&lt;/em&gt; Directory</source>
          <target state="translated">는 &lt;em id=&quot;the-tests-directory&quot;&gt;테스트&lt;/em&gt; 디렉토리</target>
        </trans-unit>
        <trans-unit id="2382217293f35827ef839ef57a6e0636f3faa56f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;automatically_derived&lt;/code&gt; attribute&lt;/em&gt; is automatically added to &lt;a href=&quot;../items/implementations&quot;&gt;implementations&lt;/a&gt; created by the &lt;code&gt;derive&lt;/code&gt; attribute for built-in traits. It has no direct effect, but it may be used by tools and diagnostic lints to detect these automatically generated implementations.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;automatically_derived&lt;/code&gt; 속성이&lt;/em&gt; 자동으로 추가됩니다 &lt;a href=&quot;../items/implementations&quot;&gt;구현&lt;/a&gt; 에 의해 생성 된 &lt;code&gt;derive&lt;/code&gt; 에 대한 속성 내장 특성. 직접적인 영향은 없지만 자동으로 생성 된 구현을 감지하기 위해 도구 및 진단 린트에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d372f8b0a676dc2ae354b920b56c31e1ed0230f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;cold&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; suggests that the attributed function is unlikely to be called.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;cold&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;속성은&lt;/a&gt;&lt;/em&gt; 특성 사용 함수가 호출 될 가능성이 있음을 시사한다.</target>
        </trans-unit>
        <trans-unit id="c8dd94fd6bb692bd54e04ee95744533de367bad8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;crate_name&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to specify the name of the crate with the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;crate_name&lt;/code&gt; 의 &lt;a href=&quot;attributes&quot;&gt;특성&lt;/a&gt;&lt;/em&gt; 와 상자의 이름 지정 상자 레벨에 적용될 수있다 &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr의&lt;/em&gt;&lt;/a&gt; 구문.</target>
        </trans-unit>
        <trans-unit id="2db8e6439808a243c5fa24e648c2e0fab8ef4d83" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;deprecated&lt;/code&gt; attribute&lt;/em&gt; marks an item as deprecated. &lt;code&gt;rustc&lt;/code&gt; will issue warnings on usage of &lt;code&gt;#[deprecated]&lt;/code&gt; items. &lt;code&gt;rustdoc&lt;/code&gt; will show item deprecation, including the &lt;code&gt;since&lt;/code&gt; version and &lt;code&gt;note&lt;/code&gt;, if available.</source>
          <target state="translated">더 &lt;em&gt; &lt;code&gt;deprecated&lt;/code&gt; 속성&lt;/em&gt; 은 항목을 더 &lt;em&gt;이상 사용되지 않는&lt;/em&gt;&lt;em&gt; 것으로&lt;/em&gt; 표시합니다. &lt;code&gt;rustc&lt;/code&gt; 는 &lt;code&gt;#[deprecated]&lt;/code&gt; 항목 사용에 대한 경고를 발행 합니다. &lt;code&gt;rustdoc&lt;/code&gt; 은 &lt;code&gt;since&lt;/code&gt; 버전 및 &lt;code&gt;note&lt;/code&gt; 를 포함하여 사용되지 않는 항목을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="fa15bab6a083f19d9ae9cd7eaa338e697eaf4832" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;derive&lt;/code&gt; attribute&lt;/em&gt; allows new &lt;a href=&quot;../items&quot;&gt;items&lt;/a&gt; to be automatically generated for data structures. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; syntax to specify a list of traits to implement or paths to &lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;derive macros&lt;/a&gt; to process.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;derive&lt;/code&gt; 속성은&lt;/em&gt; 새로운 수 있습니다 &lt;a href=&quot;../items&quot;&gt;항목이&lt;/a&gt; 자동으로 데이터 구조를 생성 할 수 있습니다. 그것은 사용 &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths의&lt;/em&gt;&lt;/a&gt; 에 구현하는 특성 또는 경로의 목록을 지정하는 구문을 &lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;파생 매크로&lt;/a&gt; 프로세스를.</target>
        </trans-unit>
        <trans-unit id="a97c3213ab817ab892d8f6e5c3157736e74b3b32" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;export_name&lt;/code&gt; attribute&lt;/em&gt; specifies the name of the symbol that will be exported on a &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; or &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt;. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the symbol name.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;export_name&lt;/code&gt; 의 특성&lt;/em&gt; (A)에 내보낼 심볼 이름 지정 &lt;a href=&quot;items/functions&quot;&gt;기능&lt;/a&gt; 또는 &lt;a href=&quot;items/static-items&quot;&gt;정적&lt;/a&gt; . 그것은 사용 &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr의&lt;/em&gt;&lt;/a&gt; 심볼 이름을 지정하는 구문을.</target>
        </trans-unit>
        <trans-unit id="9d1fbcf19af41adeefc0b92335ae4b007c4dadfa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;global_allocator&lt;/code&gt; attribute&lt;/em&gt; is used on a &lt;a href=&quot;items/static-items&quot;&gt;static item&lt;/a&gt; implementing the &lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait to set the global allocator.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;global_allocator&lt;/code&gt; 의 속성은&lt;/em&gt; A의 사용 &lt;a href=&quot;items/static-items&quot;&gt;정적 항목을&lt;/a&gt; 구현하는 &lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; 에&lt;/a&gt; 글로벌 할당을 설정하는 특성을.</target>
        </trans-unit>
        <trans-unit id="eb4af8649334dd85e9ba7979a0a444e3961c900a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; suggests that a copy of the attributed function should be placed in the caller, rather than generating code to call the function where it is defined.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;속성&lt;/a&gt;&lt;/em&gt; 특성 사용 함수의 사본 오히려 정의 된 함수를 호출하는 코드를 생성하기보다는, 발신자에 배치되어야 함을 제안한다.</target>
        </trans-unit>
        <trans-unit id="1d9a7b1456b98dca1d8fed53edde3318db90e4c5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;link&lt;/code&gt; attribute&lt;/em&gt; specifies the name of a native library that the compiler should link with for the items within an &lt;code&gt;extern&lt;/code&gt; block. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify its inputs. The &lt;code&gt;name&lt;/code&gt; key is the name of the native library to link. The &lt;code&gt;kind&lt;/code&gt; key is an optional value which specifies the kind of library with the following possible values:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;link&lt;/code&gt; 속성은&lt;/em&gt; 컴파일러가 내 항목과 연결해야하는 기본 라이브러리의 이름을 지정 &lt;code&gt;extern&lt;/code&gt; 블록을. 그것은 사용 &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr에&lt;/em&gt;&lt;/a&gt; 의 입력을 지정하는 구문을. &lt;code&gt;name&lt;/code&gt; 키 링크 네이티브 라이브러리의 이름입니다. &lt;code&gt;kind&lt;/code&gt; 키 값을 가질 수 라이브러리의 종류를 지정하는 임의의 값이다 :</target>
        </trans-unit>
        <trans-unit id="6603167a8a5aa9df2deb989c68e33b760144ac17" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;link_section&lt;/code&gt; attribute&lt;/em&gt; specifies the section of the object file that a &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; or &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt;'s content will be placed into. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the section name.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;link_section&lt;/code&gt; 의 특성&lt;/em&gt; 하는 대상 파일의 부분 지정 &lt;a href=&quot;items/functions&quot;&gt;기능&lt;/a&gt; 또는 &lt;a href=&quot;items/static-items&quot;&gt;정적&lt;/a&gt; 의 콘텐츠에 배치 될 것이다. 그것은 사용 &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr의&lt;/em&gt;&lt;/a&gt; 섹션 이름을 지정하는 구문을.</target>
        </trans-unit>
        <trans-unit id="806935dfacd2a07be8b57f073dcdf39509c2b1f7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;macro_use&lt;/code&gt; attribute&lt;/em&gt; has two purposes. First, it can be used to make a module's macro scope not end when the module is closed, by applying it to a module:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;macro_use&lt;/code&gt; 의 속성은&lt;/em&gt; 두 가지 목적이있다. 먼저, 모듈에 모듈을 적용하여 모듈을 닫을 때 모듈의 매크로 범위가 끝나지 않도록하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05f0042fe91a37001bd65ea0d74fd9143e55659c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;must_use&lt;/code&gt; attribute&lt;/em&gt; is used to issue a diagnostic warning when a value is not &quot;used&quot;. It can be applied to user-defined composite types (&lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;s&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;s&lt;/a&gt;, and &lt;a href=&quot;../items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt;s&lt;/a&gt;), &lt;a href=&quot;../items/functions&quot;&gt;functions&lt;/a&gt;, and &lt;a href=&quot;../items/traits&quot;&gt;traits&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;must_use&lt;/code&gt; 의 속성은&lt;/em&gt; 값이 &quot;사용&quot;하지 않는 경우 진단 경고를 발행하는 데 사용됩니다. 이는 사용자 정의 복합 형 (적용 할 수있다 &lt;a href=&quot;../items/structs&quot;&gt; &lt;code&gt;struct&lt;/code&gt; 들&lt;/a&gt; , &lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; 들&lt;/a&gt; 및 &lt;a href=&quot;../items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; 들&lt;/a&gt; ), &lt;a href=&quot;../items/functions&quot;&gt;기능&lt;/a&gt; 및 &lt;a href=&quot;../items/traits&quot;&gt;특성&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df0d5b935c63e0d5d09ad34649237d79db006af9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_builtins&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to disable optimizing certain code patterns to invocations of library functions that are assumed to exist.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;no_builtins&lt;/code&gt; 의 &lt;a href=&quot;../attributes&quot;&gt;속성이&lt;/a&gt;&lt;/em&gt; 존재하는 가정 라이브러리 함수의 호출을 비활성화 최적화 특정 코드 패턴에 상자 수준에서 적용 할 수있다.</target>
        </trans-unit>
        <trans-unit id="1c5fb5c17e1ae5e93c491f3ff3864f7cf3700a82" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_link&lt;/code&gt; attribute&lt;/em&gt; may be specified on an &lt;code&gt;extern crate&lt;/code&gt; item to prevent linking the crate into the output. This is commonly used to load a crate to access only its macros.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;no_link&lt;/code&gt; 특성&lt;/em&gt; 온 지정할 수 &lt;code&gt;extern crate&lt;/code&gt; 출력에 연결 상자 방지하는 항목. 이것은 일반적으로 상자에만 적재하여 매크로에만 접근하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a894d89850015842793e60fc8f351c2309ee5ef4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_main&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to disable emitting the &lt;code&gt;main&lt;/code&gt; symbol for an executable binary. This is useful when some other object being linked to defines &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;no_main&lt;/code&gt; 의 &lt;a href=&quot;attributes&quot;&gt;특성은&lt;/a&gt;&lt;/em&gt; 발광 비활성화 크레이트 레벨에 적용될 수있다 &lt;code&gt;main&lt;/code&gt; 실행 파일에 대한 이진 심볼. 이것은 연결된 다른 객체가 &lt;code&gt;main&lt;/code&gt; 을 정의 할 때 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="f3bcfb88f5c979d523b3f1a38c5f5b56a611b895" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_mangle&lt;/code&gt; attribute&lt;/em&gt; may be used on any &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; to disable standard symbol name mangling. The symbol for the item will be the identifier of the item's name.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;no_mangle&lt;/code&gt; 속성은&lt;/em&gt; 어떤에서 사용할 수 있습니다 &lt;a href=&quot;items&quot;&gt;항목을&lt;/a&gt; 비활성화 표준 기호 이름 맹 글링합니다. 항목의 기호는 항목 이름의 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="0bb656555b55ed7c2f8a3087c34efb6ed0ed4cf4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;non_exhaustive&lt;/code&gt; attribute&lt;/em&gt; indicates that a type or variant may have more fields or variants added in the future. It can be applied to &lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;s&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;s&lt;/a&gt;, and &lt;code&gt;enum&lt;/code&gt; variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a982d72d2f0894ccb0ac1653ff149a9b51224c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;panic_handler&lt;/code&gt; attribute&lt;/em&gt; can only be applied to a function with signature &lt;code&gt;fn(&amp;amp;PanicInfo) -&amp;gt; !&lt;/code&gt;. The function marked with this &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; defines the behavior of panics. The &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.PanicInfo.html&quot;&gt;&lt;code&gt;PanicInfo&lt;/code&gt;&lt;/a&gt; struct contains information about the location of the panic. There must be a single &lt;code&gt;panic_handler&lt;/code&gt; function in the dependency graph of a binary, dylib or cdylib crate.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;panic_handler&lt;/code&gt; 의 속성&lt;/em&gt; 에만 서명과 함수에 적용 할 수있는 &lt;code&gt;fn(&amp;amp;PanicInfo) -&amp;gt; !&lt;/code&gt; . 이 &lt;a href=&quot;attributes&quot;&gt;속성으로&lt;/a&gt; 표시된 기능 은 패닉의 동작을 정의합니다. &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.PanicInfo.html&quot;&gt; &lt;code&gt;PanicInfo&lt;/code&gt; 의&lt;/a&gt; 구조체는 공황의 위치에 대한 정보가 포함되어 있습니다. 이진, dylib 또는 cdylib 상자의 종속성 그래프 에는 단일 &lt;code&gt;panic_handler&lt;/code&gt; 함수 가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="12cdf01a779d8c77135d5a609c4b4e6849f40d6f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;recursion_limit&lt;/code&gt; attribute&lt;/em&gt; may be applied at the &lt;a href=&quot;../crates-and-source-files&quot;&gt;crate&lt;/a&gt; level to set the maximum depth for potentially infinitely-recursive compile-time operations like macro expansion or auto-dereference. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the recursion depth.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;recursion_limit&lt;/code&gt; 의 속성은&lt;/em&gt; 상기 적용될 수 &lt;a href=&quot;../crates-and-source-files&quot;&gt;크레이트&lt;/a&gt; 매크로 확장 또는 자동 역 참조와 같은 잠재적으로 무한히 반복적 컴파일시 동작에 대한 최대 깊이를 설정하는 단계. 그것은 사용 &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr의&lt;/em&gt;&lt;/a&gt; 재귀 수준을 지정하는 구문을.</target>
        </trans-unit>
        <trans-unit id="a7c71f7f4ce5a08ecec5e3cb423add9b9986d9b2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;target_feature&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied to an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt; to enable code generation of that function for specific platform architecture features. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax with a single key of &lt;code&gt;enable&lt;/code&gt; whose value is a string of comma-separated feature names to enable.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;target_feature&lt;/code&gt; 의 &lt;a href=&quot;../attributes&quot;&gt;속성은&lt;/a&gt;&lt;/em&gt; 에 적용 할 수 있습니다 &lt;a href=&quot;../unsafe-functions&quot;&gt;안전하지 않은 기능&lt;/a&gt; 특정 플랫폼 아키텍처 기능에 대한 그 함수의 코드 생성을 가능하게 할 수 있습니다. 이 값은 &lt;code&gt;enable&lt;/code&gt; 단일 쉼표로 구분 된 기능 이름의 문자열 인 단일 키 enable 과 함께 &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; 구문 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3aa1c2ce8a0a269a928c5414e9b6749a40da4909" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;test&lt;/code&gt; attribute&lt;/em&gt; marks a function to be executed as a test. These functions are only compiled when in test mode. Test functions must be free, monomorphic functions that take no arguments, and the return type must be one of the following:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;test&lt;/code&gt; 속성&lt;/em&gt; 은 &lt;em&gt;테스트&lt;/em&gt; 로 실행될 기능을 표시합니다. 이 기능은 테스트 모드에서만 컴파일됩니다. 테스트 함수는 인수를 사용하지 않는 자유롭고 단일 한 함수 여야하며 리턴 유형은 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="8e32e2a7306abe757340b9bbe77da987dbdce7fd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;type_length_limit&lt;/code&gt; attribute&lt;/em&gt; limits the maximum number of type substitutions made when constructing a concrete type during monomorphization. It is applied at the &lt;a href=&quot;../crates-and-source-files&quot;&gt;crate&lt;/a&gt; level, and uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to set the limit based on the number of type substitutions.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;type_length_limit&lt;/code&gt; 속성&lt;/em&gt; 은 &lt;em&gt;단형 화&lt;/em&gt; 중에 콘크리트 유형을 구성 할 때 수행되는 최대 유형 대체 수를 제한합니다. &lt;a href=&quot;../crates-and-source-files&quot;&gt;크레이트&lt;/a&gt; 수준 에서 적용되며 &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; 구문을 사용하여 유형 대체 수에 따라 한계를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6e74f839ef9f1efad1a8f9c7c9bbeff2f9cc5cae" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;used&lt;/code&gt; attribute&lt;/em&gt; can only be applied to &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;. This &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; forces the compiler to keep the variable in the output object file (.o, .rlib, etc. excluding final binaries) even if the variable is not used, or referenced, by any other item in the crate. However, the linker is still free to remove such an item.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;used&lt;/code&gt; 속성&lt;/em&gt; 에만 적용 할 수있는 &lt;a href=&quot;items/static-items&quot;&gt; &lt;code&gt;static&lt;/code&gt; 항목&lt;/a&gt; . 이 &lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 은 변수가 크레이트의 다른 항목에서 사용되지 않거나 참조되지 않더라도 컴파일러가 출력 개체 파일 (최종 바이너리를 제외한 .o, .rlib 등)에 변수를 유지하도록합니다. 그러나 링커는 이러한 항목을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9f3929d821839852e44df6684413a39c02b618f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;used&lt;/code&gt; attribute&lt;/em&gt; can only be applied to &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;. This &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; forces the compiler to keep the variable in the output object file (.o, .rlib, etc.) even if the variable is not used, or referenced, by any other item in the crate.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;used&lt;/code&gt; 속성&lt;/em&gt; 에만 적용 할 수있는 &lt;a href=&quot;items/static-items&quot;&gt; &lt;code&gt;static&lt;/code&gt; 항목&lt;/a&gt; . 이 &lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 은 변수가 상자의 다른 항목에 의해 사용되거나 참조되지 않더라도 컴파일러가 변수를 출력 객체 파일 (.o, .rlib 등)에 유지하도록합니다.</target>
        </trans-unit>
        <trans-unit id="cabd9dd1fe1f065b8657354c25edb014ad53f468" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;windows_subsystem&lt;/code&gt; attribute&lt;/em&gt; may be applied at the crate level to set the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx&quot;&gt;subsystem&lt;/a&gt; when linking on a Windows target. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the subsystem with a value of either &lt;code&gt;console&lt;/code&gt; or &lt;code&gt;windows&lt;/code&gt;. This attribute is ignored on non-Windows targets, and for non-&lt;code&gt;bin&lt;/code&gt;&lt;a href=&quot;linkage&quot;&gt;crate types&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;windows_subsystem&lt;/code&gt; 의 속성&lt;/em&gt; 세트에 나무 상자 수준에서 적용 할 수있다 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx&quot;&gt;서브 시스템을&lt;/a&gt; 윈도우 대상에 연결할 때. 그것은 사용 &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr의&lt;/em&gt;&lt;/a&gt; 하나의 값으로 서브 시스템을 지정하는 구문을 &lt;code&gt;console&lt;/code&gt; 이나 &lt;code&gt;windows&lt;/code&gt; . 이 속성은 비 Windows 대상에서 무시하고 비 대한되는 &lt;code&gt;bin&lt;/code&gt; &lt;a href=&quot;linkage&quot;&gt;상자 유형&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="637d9dddc1ad4617a0c58ddffc3922ae87e9baab" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;alignment&lt;/em&gt; of a value specifies what addresses are valid to store the value at. A value of alignment &lt;code&gt;n&lt;/code&gt; must only be stored at an address that is a multiple of n. For example, a value with an alignment of 2 must be stored at an even address, while a value with an alignment of 1 can be stored at any address. Alignment is measured in bytes, and must be at least 1, and always a power of 2. The alignment of a value can be checked with the &lt;a href=&quot;../std/mem/fn.align_of_val&quot;&gt;&lt;code&gt;align_of_val&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">값 의 &lt;em&gt;정렬&lt;/em&gt; 은 값을 저장할 수있는 주소를 지정합니다. 정렬 &lt;code&gt;n&lt;/code&gt; 값은 n 의 배수 인 주소에만 저장해야합니다. 예를 들어, 정렬이 2 인 값은 짝수 주소에 저장되어야하고, 정렬이 1 인 값은 모든 주소에 저장 될 수 있습니다. 정렬은 바이트 단위로 측정되며 1 이상이어야하며 항상 2의 &lt;a href=&quot;../std/mem/fn.align_of_val&quot;&gt; &lt;code&gt;align_of_val&lt;/code&gt; &lt;/a&gt; 합니다. 값의 정렬은 align_of_val 함수 로 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="caa4287ee2eae29f4b7097731528e2f984499328" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;at&lt;/em&gt; operator (&lt;code&gt;@&lt;/code&gt;) lets us create a variable that holds a value at the same time we&amp;rsquo;re testing that value to see whether it matches a pattern. Listing 18-29 shows an example where we want to test that a &lt;code&gt;Message::Hello&lt;/code&gt;&lt;code&gt;id&lt;/code&gt; field is within the range &lt;code&gt;3...7&lt;/code&gt;. But we also want to bind the value to the variable &lt;code&gt;id_variable&lt;/code&gt; so we can use it in the code associated with the arm. We could name this variable &lt;code&gt;id&lt;/code&gt;, the same as the field, but for this example we&amp;rsquo;ll use a different name.</source>
          <target state="translated">&lt;em&gt;에서&lt;/em&gt; 연산자 ( &lt;code&gt;@&lt;/code&gt; ) 우리가이 패턴과 일치 여부를 확인하기 위해 그 값을 테스트하는 동시에 값을 유지하는 변수를 만들 수 있습니다. Listing 18-29는 &lt;code&gt;Message::Hello&lt;/code&gt; &lt;code&gt;id&lt;/code&gt; 필드가 &lt;code&gt;3...7&lt;/code&gt; 범위 내에 있는지 테스트하려는 예제를 보여준다 . 그러나 값을 변수 &lt;code&gt;id_variable&lt;/code&gt; 에 바인딩 하여 arm과 관련된 코드에서 값을 사용할 수도 있습니다. 이 변수의 이름을 필드와 동일하게 &lt;code&gt;id&lt;/code&gt; 수 있지만이 예제에서는 다른 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6fe3095ea3510353b505863afd4ade90995e4e2e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;at&lt;/em&gt; operator (&lt;code&gt;@&lt;/code&gt;) lets us create a variable that holds a value at the same time we&amp;rsquo;re testing that value to see whether it matches a pattern. Listing 18-29 shows an example where we want to test that a &lt;code&gt;Message::Hello&lt;/code&gt;&lt;code&gt;id&lt;/code&gt; field is within the range &lt;code&gt;3..=7&lt;/code&gt;. But we also want to bind the value to the variable &lt;code&gt;id_variable&lt;/code&gt; so we can use it in the code associated with the arm. We could name this variable &lt;code&gt;id&lt;/code&gt;, the same as the field, but for this example we&amp;rsquo;ll use a different name.</source>
          <target state="translated">&lt;em&gt;에서&lt;/em&gt; 연산자 ( &lt;code&gt;@&lt;/code&gt; ) 우리가이 패턴과 일치 여부를 확인하기 위해 그 값을 테스트하는 동시에 값을 유지하는 변수를 만들 수 있습니다. Listing 18-29는 &lt;code&gt;Message::Hello&lt;/code&gt; &lt;code&gt;id&lt;/code&gt; 필드가 &lt;code&gt;3..=7&lt;/code&gt; 범위 내에 있는지 테스트하려는 예제를 보여줍니다 . 그러나 우리는 또한 값을 변수 &lt;code&gt;id_variable&lt;/code&gt; 에 바인딩 하여 팔과 관련된 코드에서 사용할 수 있기를 원합니다 . 이 변수의 이름을 필드와 동일하게 &lt;code&gt;id&lt;/code&gt; 수 있지만이 예에서는 다른 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="491e011fde2c63e7287e5968a958f99a0e0608ea" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;backslash escape&lt;/em&gt; is the character &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) which must be escaped in order to denote its ASCII encoding &lt;code&gt;0x5C&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;백 슬래시 이스케이프는&lt;/em&gt; 문자 인 &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; 의 ASCII 인코딩 나타 내기 위해 이스케이프해야합니다) &lt;code&gt;0x5C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e78bebf05e1ce9e264a960c4a634448ed6a163c1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;backslash escape&lt;/em&gt; is the character &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) which must be escaped in order to denote itself.</source>
          <target state="translated">&lt;em&gt;백 슬래시 이스케이프는&lt;/em&gt; 문자 인 &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; 자체를 나타 내기 위해 이스케이프해야합니다).</target>
        </trans-unit>
        <trans-unit id="863e56925d2ff8675a4dd9c4a460d825a809b69e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;heap&lt;/em&gt; is a general term that describes boxes. The lifetime of an allocation in the heap depends on the lifetime of the box values pointing to it. Since box values may themselves be passed in and out of frames, or stored in the heap, heap allocations may outlive the frame they are allocated within. An allocation in the heap is guaranteed to reside at a single location in the heap for the whole lifetime of the allocation - it will never be relocated as a result of moving a box value.</source>
          <target state="translated">&lt;em&gt;힙&lt;/em&gt; 상자를 설명하는 일반적인 용어입니다. 힙에서 할당 수명은이를 가리키는 상자 값의 수명에 따라 다릅니다. 상자 값 자체가 프레임 안팎으로 전달되거나 힙에 저장 될 수 있으므로 힙 할당은 할당 된 프레임보다 오래 지속될 수 있습니다. 힙의 할당은 할당의 전체 수명 동안 힙의 단일 위치에 상주하게됩니다. 이는 상자 값을 이동 한 결과로 절대 재배치되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21ffe4f08baa3ee5d8fcae0ac2b2640039bc170b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;items&lt;/em&gt; of a program are those functions, modules and types that have their value calculated at compile-time and stored uniquely in the memory image of the rust process. Items are neither dynamically allocated nor freed.</source>
          <target state="translated">프로그램 의 &lt;em&gt;항목&lt;/em&gt; 은 컴파일 타임에 계산되고 녹 프로세스의 메모리 이미지에 고유하게 저장되는 기능, 모듈 및 유형입니다. 항목은 동적으로 할당되거나 해제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f297b31862071391a99da1af535c50f23bb4ea5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;items&lt;/em&gt; of a program are those functions, modules, and types that have their value calculated at compile-time and stored uniquely in the memory image of the rust process. Items are neither dynamically allocated nor freed.</source>
          <target state="translated">프로그램 의 &lt;em&gt;항목&lt;/em&gt; 은 컴파일 시간에 값이 계산되고 rust 프로세스의 메모리 이미지에 고유하게 저장되는 함수, 모듈 및 유형입니다. 항목은 동적으로 할당되거나 해제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="867bacda5c963969dd78331f878c031b22f73cbb" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;null escape&lt;/em&gt; is the character &lt;code&gt;U+0030&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) and denotes the Unicode value &lt;code&gt;U+0000&lt;/code&gt; (NUL).</source>
          <target state="translated">&lt;em&gt;널 탈출&lt;/em&gt; 문자 인 &lt;code&gt;U+0030&lt;/code&gt; ( &lt;code&gt;0&lt;/code&gt; )과 유니 코드 값을 나타내고, &lt;code&gt;U+0000&lt;/code&gt; (NUL 참조).</target>
        </trans-unit>
        <trans-unit id="c0460a3f4832868522908bad2876d5f8fef36d49" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;null escape&lt;/em&gt; is the character &lt;code&gt;U+0030&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) and denotes the byte value &lt;code&gt;0x00&lt;/code&gt; (ASCII NUL).</source>
          <target state="translated">&lt;em&gt;널 탈출&lt;/em&gt; 문자 인 &lt;code&gt;U+0030&lt;/code&gt; ( &lt;code&gt;0&lt;/code&gt; )와 바이트 값 의미 &lt;code&gt;0x00&lt;/code&gt; 으로 (ASCII의 NUL 참조).</target>
        </trans-unit>
        <trans-unit id="b4b356718e399f8a05dc4012731a26a28084f252" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;prelude&lt;/em&gt; is the list of things that Rust automatically imports into every Rust program. It's kept as small as possible, and is focused on things, particularly traits, which are used in almost every single Rust program.</source>
          <target state="translated">&lt;em&gt;전주곡은&lt;/em&gt; 사물의 목록입니다 모든 녹 프로그램에 녹 자동 수입. 가능한 한 작게 유지되며 거의 모든 Rust 프로그램에서 사용되는 특성, 특히 특성에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="c5fc79bf9688aa8e786959c2742e411818e5d89a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;primitive representations&lt;/em&gt; are the representations with the same names as the primitive integer types. That is: &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;u16&lt;/code&gt;, &lt;code&gt;u32&lt;/code&gt;, &lt;code&gt;u64&lt;/code&gt;, &lt;code&gt;u128&lt;/code&gt;, &lt;code&gt;usize&lt;/code&gt;, &lt;code&gt;i8&lt;/code&gt;, &lt;code&gt;i16&lt;/code&gt;, &lt;code&gt;i32&lt;/code&gt;, &lt;code&gt;i64&lt;/code&gt;, &lt;code&gt;i128&lt;/code&gt;, and &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;원시적 인 표현은&lt;/em&gt; 원시 정수 타입과 동일한 이름을 가진 표현입니다. 즉 : &lt;code&gt;u8&lt;/code&gt; , &lt;code&gt;u16&lt;/code&gt; , &lt;code&gt;u32&lt;/code&gt; , &lt;code&gt;u64&lt;/code&gt; , &lt;code&gt;u128&lt;/code&gt; , &lt;code&gt;usize&lt;/code&gt; , &lt;code&gt;i8&lt;/code&gt; , &lt;code&gt;i16&lt;/code&gt; , &lt;code&gt;i32&lt;/code&gt; , &lt;code&gt;i64&lt;/code&gt; , &lt;code&gt;i128&lt;/code&gt; 및 &lt;code&gt;isize&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a3ce8f949608b1daede8105623fa327eab5c410b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;rest pattern&lt;/em&gt; (the &lt;code&gt;..&lt;/code&gt; token) acts as a variable-length pattern which matches zero or more elements that haven't been matched already before and after. It may only be used in &lt;a href=&quot;#tuple-patterns&quot;&gt;tuple&lt;/a&gt;, &lt;a href=&quot;#tuple-struct-patterns&quot;&gt;tuple struct&lt;/a&gt;, and &lt;a href=&quot;#slice-patterns&quot;&gt;slice&lt;/a&gt; patterns, and may only appear once as one of the elements in those patterns. It is also allowed in an &lt;a href=&quot;#identifier-patterns&quot;&gt;identifier pattern&lt;/a&gt; for &lt;a href=&quot;#slice-patterns&quot;&gt;slice patterns&lt;/a&gt; only.</source>
          <target state="translated">&lt;em&gt;나머지 패턴&lt;/em&gt; 합니다 ( &lt;code&gt;..&lt;/code&gt; 토큰) 전후 아직 매칭되지 않은 영 이상의 요소와 일치하는, 가변 길이 패턴으로서 작용한다. 이는 단지 사용될 수있다 &lt;a href=&quot;#tuple-patterns&quot;&gt;튜플&lt;/a&gt; , &lt;a href=&quot;#tuple-struct-patterns&quot;&gt;튜플 구조체&lt;/a&gt; 및 &lt;a href=&quot;#slice-patterns&quot;&gt;슬라이스&lt;/a&gt; 패턴에만 그 패턴의 요소의 하나로서 한 번에 표시 할 수있다. 그것은 또한 허용되는 &lt;a href=&quot;#identifier-patterns&quot;&gt;식별자 패턴&lt;/a&gt; 에 대한 &lt;a href=&quot;#slice-patterns&quot;&gt;슬라이스 패턴&lt;/a&gt; 만.</target>
        </trans-unit>
        <trans-unit id="4971362f3b5f40470a74c81b64c44c61022c0ae5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;size&lt;/em&gt; of a value is the offset in bytes between successive elements in an array with that item type including alignment padding. The size of a value is always a multiple of its alignment. The size of a value can be checked with the &lt;a href=&quot;../std/mem/fn.size_of_val&quot;&gt;&lt;code&gt;size_of_val&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">값 의 &lt;em&gt;크기&lt;/em&gt; 는 정렬 패딩을 포함하여 해당 항목 유형의 배열에서 연속 요소 사이의 바이트 단위 오프셋입니다. 값의 크기는 항상 정렬의 배수입니다. &lt;a href=&quot;../std/mem/fn.size_of_val&quot;&gt; &lt;code&gt;size_of_val&lt;/code&gt; &lt;/a&gt; 함수 로 값의 크기를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="608607007d0795edd59e30f51aeabc80ca46b5f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;state pattern&lt;/em&gt; is an object-oriented design pattern. The crux of the pattern is that a value has some internal state, which is represented by a set of &lt;em&gt;state objects&lt;/em&gt;, and the value&amp;rsquo;s behavior changes based on the internal state. The state objects share functionality: in Rust, of course, we use structs and traits rather than objects and inheritance. Each state object is responsible for its own behavior and for governing when it should change into another state. The value that holds a state object knows nothing about the different behavior of the states or when to transition between states.</source>
          <target state="translated">&lt;em&gt;상태 패턴은&lt;/em&gt; 객체 지향 디자인 패턴입니다. 패턴의 요점은 값에 &lt;em&gt;상태 객체&lt;/em&gt; 세트로 표시되는 내부 상태가 있고 내부 상태에 따라 값의 동작이 변경 된다는 것입니다 . 상태 객체는 기능을 공유합니다. 물론 Rust에서는 객체와 상속보다는 구조체와 특성을 사용합니다. 각 상태 개체는 자체 동작과 다른 상태로 변경 될시기를 관리합니다. 상태 객체를 보유하는 값은 상태의 다른 동작 또는 상태 간 전환시기에 대해 전혀 알지 못합니다.</target>
        </trans-unit>
        <trans-unit id="ec835310b404eed2cb3a60731c66a0fc7069cf96" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;successor&lt;/em&gt; operation moves towards values that compare greater. The &lt;em&gt;predecessor&lt;/em&gt; operation moves towards values that compare lesser.</source>
          <target state="translated">&lt;em&gt;후속&lt;/em&gt; 큰 값과 비교 연산을 향해 이동한다. &lt;em&gt;이전의&lt;/em&gt; 낮은 비교 값에 대한 작업을 이동합니다.</target>
        </trans-unit>
        <trans-unit id="71b31d9fd96bdd059ab3da8b882ee0c455f89891" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;temporary scope&lt;/em&gt; of an expression is the scope that is used for the temporary variable that holds the result of that expression when used in a &lt;a href=&quot;expressions#place-expressions-and-value-expressions&quot;&gt;place context&lt;/a&gt;, unless it is &lt;a href=&quot;destructors#constant-promotion&quot;&gt;promoted&lt;/a&gt;.</source>
          <target state="translated">표현식 의 &lt;em&gt;임시 범위&lt;/em&gt; 는 &lt;a href=&quot;destructors#constant-promotion&quot;&gt;승격&lt;/a&gt; 되지 않는 한 &lt;a href=&quot;expressions#place-expressions-and-value-expressions&quot;&gt;장소 컨텍스트&lt;/a&gt; 에서 사용될 때 해당 표현식의 결과를 보유하는 임시 변수에 사용되는 범위입니다 .</target>
        </trans-unit>
        <trans-unit id="da892b01ccbdf152bb00bb5fb34ad8db3069d651" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;tuple type&lt;/em&gt; is a structural type&lt;sup&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; for heterogeneous lists of other types. Each entry in the list is an &lt;em&gt;element&lt;/em&gt;&lt;sup&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; of the tuple. The position of the element makes it the &lt;em&gt;nth element&lt;/em&gt; using zero (&lt;code&gt;0&lt;/code&gt;) as the initial index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c8131f661492ad3eb04d5338d01ccf9f429562" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wildcard pattern&lt;/em&gt; (an underscore symbol) matches any value. It is used to ignore values when they don't matter. Inside other patterns it matches a single data field (as opposed to the &lt;code&gt;..&lt;/code&gt; which matches the remaining fields). Unlike identifier patterns, it does not copy, move or borrow the value it matches.</source>
          <target state="translated">&lt;em&gt;와일드 패턴&lt;/em&gt; (밑줄 심볼)의 값과 일치. 중요하지 않은 값을 무시하는 데 사용됩니다. 다른 패턴 내에서는 단일 데이터 필드 와 일치합니다 (나머지 필드와 일치하는 &lt;code&gt;..&lt;/code&gt; 와 반대 ). 식별자 패턴과 달리 일치하는 값을 복사, 이동 또는 차용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c707e6c38639fd82e39cc81120827bce74e177e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wildcard pattern&lt;/em&gt; matches any value. It is used to ignore values when they don't matter. Inside other patterns it matches a single data field (as opposed to the &lt;code&gt;..&lt;/code&gt; which matches the remaining fields). Unlike identifier patterns, it does not copy, move or borrow the value it matches.</source>
          <target state="translated">&lt;em&gt;와일드 카드 패턴은&lt;/em&gt; 임의의 값과 일치합니다. 중요하지 않을 때 값을 무시하는 데 사용됩니다. 다른 패턴 내에서는 단일 데이터 필드 와 일치합니다 (나머지 필드와 일치하는 &lt;code&gt;..&lt;/code&gt; 와 반대 ). 식별자 패턴과 달리 일치하는 값을 복사, 이동 또는 차용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75f0595163c83b48141e476739787cd1006a8d33" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;channel&lt;/strong&gt;'s sending half has become disconnected, and there will never be any more data received on it.</source>
          <target state="translated">&lt;strong&gt;채널은&lt;/strong&gt; '절반의 연결이 끊어되었다 보내는 S, 그것에받은 더 많은 데이터가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d020769b0b6d90680db8e09c6dc6e9b663dc909" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;compiler&lt;/strong&gt; reordering instructions: If the compiler can issue an instruction at an earlier point, it will try to do so. For example, it might hoist memory loads at the top of a code block, so that the CPU can start &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_prefetching&quot;&gt;prefetching&lt;/a&gt; the values from memory.</source>
          <target state="translated">&lt;strong&gt;컴파일러&lt;/strong&gt; 지침을 재정렬 : 컴파일러가 이전 시점에서 명령을 발행 할 수 있다면, 그것은 그렇게하려고합니다. 예를 들어, CPU가 메모리에서 값을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_prefetching&quot;&gt;프리 페치&lt;/a&gt; 하기 시작할 수 있도록 코드 블록의 맨 위에 메모리로드를 들어 올릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="314b68cd7b660a21edb44d2117cd4a156ae245a5" translate="yes" xml:space="preserve">
          <source>The API documentation that &lt;code&gt;cargo doc&lt;/code&gt; generates for this crate will now list and link re-exports on the front page, as shown in Figure 14-4, making the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;SecondaryColor&lt;/code&gt; types and the &lt;code&gt;mix&lt;/code&gt; function easier to find.</source>
          <target state="translated">&lt;code&gt;cargo doc&lt;/code&gt; 상자가이 상자에 대해 생성 하는 API 문서 는 이제 그림 14-4에 표시된 것처럼 첫 페이지에 다시 내보내기를 나열하고 연결하여 &lt;code&gt;PrimaryColor&lt;/code&gt; 및 &lt;code&gt;SecondaryColor&lt;/code&gt; 유형과 &lt;code&gt;mix&lt;/code&gt; 기능을보다 쉽게 ​​찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe97d53a4341ff985473c7759453c7f0b6f51809" translate="yes" xml:space="preserve">
          <source>The API is typically used by acquiring a handle to the current thread, placing that handle in a shared data structure so that other threads can find it, and then &lt;code&gt;park&lt;/code&gt;ing in a loop. When some desired condition is met, another thread calls &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; on the handle.</source>
          <target state="translated">API는 일반적으로 다른 스레드를 찾을 수 있도록 공유 데이터 구조에 그 핸들을 배치, 현재 스레드에 대한 핸들을 획득하여 사용하고있다 &lt;code&gt;park&lt;/code&gt; 루프에서 보내고. 원하는 조건이 충족되면 다른 스레드가 핸들에서 &lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="bdef16eb0aad1c8443510daaf0eaf64f22da449f" translate="yes" xml:space="preserve">
          <source>The API of &lt;code id=&quot;the-api-of-mutext&quot;&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;the-api-of-mutext&quot;&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 의 API</target>
        </trans-unit>
        <trans-unit id="da2fca5419425bb1dfeff3a19e5e6b522b71b9f7" translate="yes" xml:space="preserve">
          <source>The Anatomy of a Test Function</source>
          <target state="translated">테스트 함수의 분석</target>
        </trans-unit>
        <trans-unit id="6ff9dd46af7ebe72f506f56aea2ffd15b7f82cfe" translate="yes" xml:space="preserve">
          <source>The Array Type</source>
          <target state="translated">배열 유형</target>
        </trans-unit>
        <trans-unit id="4c7fdb8a442bced7fcc6b743d86e4b178b1bc140" translate="yes" xml:space="preserve">
          <source>The Boolean Type</source>
          <target state="translated">부울 타입</target>
        </trans-unit>
        <trans-unit id="7a47e0b8b6b1bfa40f74993b9ed02984c335782d" translate="yes" xml:space="preserve">
          <source>The Boolean type, &lt;code&gt;bool&lt;/code&gt;, with values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">부울 유형 &lt;code&gt;bool&lt;/code&gt; 은 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="d554fe4c508301c7dd79586706f031038650a679" translate="yes" xml:space="preserve">
          <source>The Borrow Checker</source>
          <target state="translated">차용 검사기</target>
        </trans-unit>
        <trans-unit id="706bc5bdd045092d3c34365727a87c607d4ff3a3" translate="yes" xml:space="preserve">
          <source>The C side must &lt;strong&gt;not&lt;/strong&gt; modify the length of the string (by writing a &lt;code&gt;NULL&lt;/code&gt; somewhere inside the string or removing the final one) before it makes it back into Rust using &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt;. See the safety section in &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C 측은 &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt; &lt;code&gt;CString::from_raw&lt;/code&gt; &lt;/a&gt; 사용하여 Rust로 다시 만들기 전에 문자열의 길이를 수정 해서는 &lt;strong&gt;안됩니다&lt;/strong&gt; (문자열 어딘가에 &lt;code&gt;NULL&lt;/code&gt; 을 쓰거나 마지막 문자열을 제거하여) . &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt; &lt;code&gt;CString::from_raw&lt;/code&gt; &lt;/a&gt; 의 안전 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="096fc2c3eb95fb5d0ee6aa092c0689c069929e6f" translate="yes" xml:space="preserve">
          <source>The C-main function only supports to return integers as return type. So, every type implementing the &lt;code&gt;Termination&lt;/code&gt; trait has to be converted to an integer.</source>
          <target state="translated">C-main 함수는 반환 유형으로 정수 반환 만 지원합니다. 따라서 &lt;code&gt;Termination&lt;/code&gt; 특성을 구현하는 모든 유형 은 정수로 변환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="da6976366f57ccb20ad430117c89098f7fb1348a" translate="yes" xml:space="preserve">
          <source>The C-variadic type &lt;code&gt;...&lt;/code&gt; has been nested inside another type.</source>
          <target state="translated">C-variadic 유형 &lt;code&gt;...&lt;/code&gt; 이 다른 유형 내에 중첩되었습니다.</target>
        </trans-unit>
        <trans-unit id="86641abf85c69d8c4f7c9c71c79144e3a2832005" translate="yes" xml:space="preserve">
          <source>The Character Type</source>
          <target state="translated">캐릭터 타입</target>
        </trans-unit>
        <trans-unit id="35e39875eebfabcb5b0b8cd30288767fc0b6add8" translate="yes" xml:space="preserve">
          <source>The Clippy tool is a collection of lints to analyze your code so you can catch common mistakes and improve your Rust code.</source>
          <target state="translated">Clippy 도구는 코드를 분석하여 일반적인 실수를 발견하고 Rust 코드를 개선 할 수있는 보풀 모음입니다.</target>
        </trans-unit>
        <trans-unit id="bb08bad287d0caba2752b58d322b62f2942d38e6" translate="yes" xml:space="preserve">
          <source>The Default Representation</source>
          <target state="translated">기본 표현</target>
        </trans-unit>
        <trans-unit id="f9e1a59444e395f067802b105261ac31a11eac66" translate="yes" xml:space="preserve">
          <source>The Difference Between Macros and Functions</source>
          <target state="translated">매크로와 함수의 차이점</target>
        </trans-unit>
        <trans-unit id="7241096a248faf0667959dae2f7e6a0390d29dce" translate="yes" xml:space="preserve">
          <source>The GID part of the peer credential. This is the effective GID of the process at the domain socket's endpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f6987535ee435e225cb875fe024ba6f3b75e49" translate="yes" xml:space="preserve">
          <source>The Glob Operator</source>
          <target state="translated">글로벌 운영자</target>
        </trans-unit>
        <trans-unit id="a0a1aaf98c3bce57246183f1baadfe83da9b49cd" translate="yes" xml:space="preserve">
          <source>The HTML format is available online at &lt;a href=&quot;https://doc.rust-lang.org/stable/book/index.html&quot;&gt;https://doc.rust-lang.org/stable/book/&lt;/a&gt; and offline with installations of Rust made with &lt;code&gt;rustup&lt;/code&gt;; run &lt;code&gt;rustup docs --book&lt;/code&gt; to open.</source>
          <target state="translated">HTML 형식은 &lt;a href=&quot;https://doc.rust-lang.org/stable/book/index.html&quot;&gt;https://doc.rust-lang.org/stable/book/&lt;/a&gt; 에서 온라인으로 사용할 수 있으며 &lt;code&gt;rustup&lt;/code&gt; 으로 만든 Rust를 설치하면 오프라인으로 사용할 수 있습니다 . &lt;code&gt;rustup docs --book&lt;/code&gt; to open을 실행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="00df77514c97d921fca4a972435309219a163a06" translate="yes" xml:space="preserve">
          <source>The I/O Prelude</source>
          <target state="translated">I / O 서곡</target>
        </trans-unit>
        <trans-unit id="6979c051972c7d2da3658847fabbf6a31d84bdb5" translate="yes" xml:space="preserve">
          <source>The I/O operation's timeout expired, causing it to be canceled.</source>
          <target state="translated">I / O 조작의 시간 종료가 만료되어 취소되었습니다.</target>
        </trans-unit>
        <trans-unit id="dc9c14a7eb4854c512e7ed69d5ba6a43f9c253aa" translate="yes" xml:space="preserve">
          <source>The IEEE 754-2008 &quot;binary32&quot; and &quot;binary64&quot; floating-point types are &lt;code&gt;f32&lt;/code&gt; and &lt;code&gt;f64&lt;/code&gt;, respectively.</source>
          <target state="translated">는 IEEE 754-2008 &quot;binary32&quot;와 &quot;binary64&quot;부동 소수점 유형은 &lt;code&gt;f32&lt;/code&gt; 및 &lt;code&gt;f64&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="a46bc695392f8c742f4e678a79ed2375790074cb" translate="yes" xml:space="preserve">
          <source>The Matcher Invariants</source>
          <target state="translated">매처 불변</target>
        </trans-unit>
        <trans-unit id="5eece4981b24083c68ecabd071b66fe17ba1ce62" translate="yes" xml:space="preserve">
          <source>The Never Type that Never Returns</source>
          <target state="translated">결코 반환하지 않는 Never Type</target>
        </trans-unit>
        <trans-unit id="388566f1f9117600ae22e2ebff51f82d448e95e2" translate="yes" xml:space="preserve">
          <source>The PID part of the peer credential. This field is optional because the PID part of the peer credentials is not supported on every platform. On platforms where the mechanism to discover the PID exists, this field will be populated to the PID of the process at the domain socket's endpoint. Otherwise, it will be set to None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b8e7692f976fe91f0cb8053dcf33a7090a4f8c" translate="yes" xml:space="preserve">
          <source>The Pattern API provides a generic mechanism for using different pattern types when searching through a string.</source>
          <target state="translated">패턴 API는 문자열을 통해 검색 할 때 다양한 패턴 유형을 사용하기위한 일반 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ba8021c95f458659340856b34b5ce555bddda300" translate="yes" xml:space="preserve">
          <source>The RFC Process and Teams</source>
          <target state="translated">RFC 프로세스 및 팀</target>
        </trans-unit>
        <trans-unit id="667bd8e20b1ba8153f27c9ff6c220024562a73c6" translate="yes" xml:space="preserve">
          <source>The Rules of References</source>
          <target state="translated">참조 규칙</target>
        </trans-unit>
        <trans-unit id="161ef3f14aee5229baf3e48cdbbdab5a784349b3" translate="yes" xml:space="preserve">
          <source>The Rust Language Server powers Integrated Development Environment (IDE) integration for code completion and inline error messages.</source>
          <target state="translated">Rust Language Server는 코드 완성 및 인라인 오류 메시지를 위해 IDE (Integrated Development Environment) 통합을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="efbadde43b4ea2876af269fef5bbeff660435dad" translate="yes" xml:space="preserve">
          <source>The Rust Prelude</source>
          <target state="translated">녹 서곡</target>
        </trans-unit>
        <trans-unit id="1e47c327d13b68cc315d8c0718500294854d4bd4" translate="yes" xml:space="preserve">
          <source>The Rust Prelude.</source>
          <target state="translated">녹 서곡.</target>
        </trans-unit>
        <trans-unit id="64d4853b323b63d9ca56f4771bf913212d9ace7a" translate="yes" xml:space="preserve">
          <source>The Rust Programming Language</source>
          <target state="translated">녹 프로그래밍 언어</target>
        </trans-unit>
        <trans-unit id="0bb645ae646711df91105c5e5d03daf9c88ee91b" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library</source>
          <target state="translated">녹 표준 라이브러리</target>
        </trans-unit>
        <trans-unit id="9c789ddc154274d796ddc2e963326017f63c2958" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;vec/index&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;#primitives&quot;&gt;operations on language primitives&lt;/a&gt;, &lt;a href=&quot;#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;io/index&quot;&gt;I/O&lt;/a&gt; and &lt;a href=&quot;thread/index&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.</source>
          <target state="translated">Rust 표준 라이브러리는 휴대용 Rust 소프트웨어의 토대이며, &lt;a href=&quot;https://crates.io&quot;&gt;광범위한 Rust 생태계를&lt;/a&gt; 위해 최소한의 전투 테스트 공유 공유 세트입니다 . 그것은, 핵심 유형을 제공합니다 같은 &lt;a href=&quot;vec/index&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , 라이브러리 정의 &lt;a href=&quot;#primitives&quot;&gt;언어의 기본 요소에 대한 작업&lt;/a&gt; , &lt;a href=&quot;#macros&quot;&gt;표준 매크로&lt;/a&gt; , &lt;a href=&quot;io/index&quot;&gt;I / O&lt;/a&gt; 및 &lt;a href=&quot;thread/index&quot;&gt;멀티 스레딩&lt;/a&gt; , 중 &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;많은 다른 것들&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d3f2d23ee5d88e5e35ea9e8e79bcbc0fd6e3b11" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;#primitives&quot;&gt;operations on language primitives&lt;/a&gt;, &lt;a href=&quot;#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;io/index&quot;&gt;I/O&lt;/a&gt; and &lt;a href=&quot;thread/index&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.</source>
          <target state="translated">Rust 표준 라이브러리는 &lt;a href=&quot;https://crates.io&quot;&gt;더 넓은 Rust 생태계를&lt;/a&gt; 위한 최소한의 전투 테스트를 거친 공유 추상화 세트 인 휴대용 Rust 소프트웨어의 기초입니다 . 그것은, 핵심 유형을 제공합니다 같은 &lt;a href=&quot;vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , 라이브러리 정의 &lt;a href=&quot;#primitives&quot;&gt;언어의 기본 요소에 대한 작업&lt;/a&gt; , &lt;a href=&quot;#macros&quot;&gt;표준 매크로&lt;/a&gt; , &lt;a href=&quot;io/index&quot;&gt;I / O&lt;/a&gt; 및 &lt;a href=&quot;thread/index&quot;&gt;멀티 스레딩&lt;/a&gt; , 중 &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;많은 다른 것들&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c3853d774e4956749b7c91653db336f2eec58d4" translate="yes" xml:space="preserve">
          <source>The Rust compiler does not consider the following behaviors &lt;em&gt;unsafe&lt;/em&gt;, though a programmer may (should) find them undesirable, unexpected, or erroneous.</source>
          <target state="translated">Rust 컴파일러는 다음과 같은 동작을 &lt;em&gt;안전&lt;/em&gt; 하지 않은 것으로 간주하지 않지만 프로그래머는 바람직하지 않거나 예상치 못한 또는 잘못된 동작을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21b3dd0203ec587beb1963c1f4feb0c5c3e73b91" translate="yes" xml:space="preserve">
          <source>The Rust compiler has a &lt;em&gt;borrow checker&lt;/em&gt; that compares scopes to determine whether all borrows are valid. Listing 10-18 shows the same code as Listing 10-17 but with annotations showing the lifetimes of the variables.</source>
          <target state="translated">Rust 컴파일러에는 범위를 비교하여 모든 차용이 유효한지 확인 하는 &lt;em&gt;차용 검사기&lt;/em&gt; 가 있습니다. Listing 10-18은 Listing 10-17과 동일한 코드이지만 변수의 수명을 나타내는 주석이있다.</target>
        </trans-unit>
        <trans-unit id="bac79421ac7e7f4a69670a43a87279fa1ea360c9" translate="yes" xml:space="preserve">
          <source>The Rust compiler is always invoked with a single source file as input, and always produces a single output crate. The processing of that source file may result in other source files being loaded as modules. Source files have the extension &lt;code&gt;.rs&lt;/code&gt;.</source>
          <target state="translated">Rust 컴파일러는 항상 단일 소스 파일을 입력으로 호출하고 항상 단일 출력 상자를 생성합니다. 해당 소스 파일을 처리하면 다른 소스 파일이 모듈로로드 될 수 있습니다. 소스 파일의 확장자는 &lt;code&gt;.rs&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="edecdb50208b6b73bf12c25a96c41ebd3a559a66" translate="yes" xml:space="preserve">
          <source>The Rust language and compiler have a six-week release cycle, meaning users get a constant stream of new features. Other programming languages release larger changes less often; Rust releases smaller updates more frequently. After a while, all of these tiny changes add up. But from release to release, it can be difficult to look back and say, &amp;ldquo;Wow, between Rust 1.10 and Rust 1.31, Rust has changed a lot!&amp;rdquo;</source>
          <target state="translated">Rust 언어와 컴파일러는 6 주 릴리스주기를 가지며 이는 사용자가 새로운 기능을 지속적으로 제공한다는 것을 의미합니다. 다른 프로그래밍 언어는 더 큰 변경을 덜 자주 릴리스합니다. 녹은 더 작은 업데이트를 더 자주 릴리스합니다. 잠시 후,이 작은 변화들이 모두 합쳐집니다. 그러나 릴리스에서 릴리스까지&amp;ldquo;와트 1.10과 Rust 1.31 사이에서 Rust가 많이 바뀌 었습니다!&amp;rdquo;라고 회상하기가 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb670b9e802863986c803bc2c279a2c3ad127d26" translate="yes" xml:space="preserve">
          <source>The Rust language has a set of &lt;em&gt;keywords&lt;/em&gt; that are reserved for use by the language only, much as in other languages. Keep in mind that you cannot use these words as names of variables or functions. Most of the keywords have special meanings, and you&amp;rsquo;ll be using them to do various tasks in your Rust programs; a few have no current functionality associated with them but have been reserved for functionality that might be added to Rust in the future. You can find a list of the keywords in &lt;a href=&quot;appendix-01-keywords&quot;&gt;Appendix A&lt;/a&gt;.</source>
          <target state="translated">Rust 언어에는 다른 언어와 마찬가지로 해당 언어에서만 사용하도록 예약 된 &lt;em&gt;키워드&lt;/em&gt; 세트가 있습니다. 이러한 단어는 변수 나 함수의 이름으로 사용할 수 없습니다. 대부분의 키워드는 특별한 의미를 가지고 있으며,이를 사용하여 Rust 프로그램에서 다양한 작업을 수행하게됩니다. 몇몇은 그들과 관련된 현재 기능이 없지만 향후 Rust에 추가 될 기능을 위해 예약되어 있습니다. &lt;a href=&quot;appendix-01-keywords&quot;&gt;부록 A&lt;/a&gt; 에서 키워드 목록을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4db8a730c896d57ac8ae13218ced391891bc4c9e" translate="yes" xml:space="preserve">
          <source>The Rust language has a set of &lt;em&gt;keywords&lt;/em&gt; that are reserved for use by the language only, much as in other languages. Keep in mind that you cannot use these words as names of variables or functions. Most of the keywords have special meanings, and you&amp;rsquo;ll be using them to do various tasks in your Rust programs; a few have no current functionality associated with them but have been reserved for functionality that might be added to Rust in the future. You can find a list of the keywords in Appendix A.</source>
          <target state="translated">Rust 언어에는 다른 언어와 마찬가지로 해당 언어에서만 사용하도록 예약 된 &lt;em&gt;키워드&lt;/em&gt; 세트가 있습니다. 이 단어를 변수 또는 함수의 이름으로 사용할 수 없습니다. 대부분의 키워드는 특별한 의미를 지니고 있으며 Rust 프로그램에서 다양한 작업을 수행 할 때 사용합니다. 일부는 현재 기능과 관련이 없지만 향후 Rust에 추가 될 수있는 기능을 위해 예약되었습니다. 부록 A에서 키워드 목록을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c421a36adf32e1316c136776ce05dd83536c6c8" translate="yes" xml:space="preserve">
          <source>The Rust language hopes to support many other users as well; those mentioned here are merely some of the biggest stakeholders. Overall, Rust&amp;rsquo;s greatest ambition is to eliminate the trade-offs that programmers have accepted for decades by providing safety &lt;em&gt;and&lt;/em&gt; productivity, speed &lt;em&gt;and&lt;/em&gt; ergonomics. Give Rust a try and see if its choices work for you.</source>
          <target state="translated">Rust 언어는 다른 많은 사용자들도 지원하기를 희망합니다. 여기에 언급 된 것은 가장 큰 이해 관계자 중 일부일뿐입니다. 전반적으로 Rust의 가장 큰 야심은 안전 &lt;em&gt;과&lt;/em&gt; 생산성, 속도 &lt;em&gt;및&lt;/em&gt; 인체 공학 을 제공함으로써 프로그래머가 수십 년 동안 받아온 트레이드 오프를 제거하는 것 입니다. Rust를 시험 해보고 그 선택이 당신에게 적합한 지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="596e2b7dbc791cd3cfc77236ae00a927665967e2" translate="yes" xml:space="preserve">
          <source>The Rust runtime</source>
          <target state="translated">녹 런타임</target>
        </trans-unit>
        <trans-unit id="6be65bd73ad861e62f3888e1cc3672c017c1636b" translate="yes" xml:space="preserve">
          <source>The Rust standard library provides channels for message passing and smart pointer types, such as &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;, that are safe to use in concurrent contexts. The type system and the borrow checker ensure that the code using these solutions won&amp;rsquo;t end up with data races or invalid references. Once you get your code to compile, you can rest assured that it will happily run on multiple threads without the kinds of hard-to-track-down bugs common in other languages. Concurrent programming is no longer a concept to be afraid of: go forth and make your programs concurrent, fearlessly!</source>
          <target state="translated">Rust 표준 라이브러리는 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 와 같이 동시 컨텍스트에서 사용하기에 안전한 메시지 전달 및 스마트 포인터 유형을위한 채널을 제공 합니다. 유형 시스템과 차용 검사기는 이러한 솔루션을 사용하는 코드가 데이터 경쟁이나 유효하지 않은 참조로 끝나지 않도록합니다. 코드를 컴파일하면 다른 언어에서 흔히 볼 수있는 추적하기 어려운 버그없이 여러 스레드에서 행복하게 실행될 수 있습니다. 동시 프로그래밍은 더 이상 두려워 할 개념이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ca0e948d58962dbdfe194b991ab15a2f509a074c" translate="yes" xml:space="preserve">
          <source>The Rust type system has some features that we&amp;rsquo;ve mentioned in this book but haven&amp;rsquo;t yet discussed. We&amp;rsquo;ll start by discussing newtypes in general as we examine why newtypes are useful as types. Then we&amp;rsquo;ll move on to type aliases, a feature similar to newtypes but with slightly different semantics. We&amp;rsquo;ll also discuss the &lt;code&gt;!&lt;/code&gt; type and dynamically sized types.</source>
          <target state="translated">Rust 타입 시스템은이 책에서 언급했지만 아직 논의하지 않은 기능을 가지고 있습니다. 새로운 유형이 유형으로 유용한 이유를 조사하면서 일반적으로 새로운 유형에 대해 논의하는 것으로 시작하겠습니다. 그런 다음 새로운 유형과 비슷하지만 의미가 약간 다른 기능인 유형 별칭으로 넘어갑니다. 우리는 또한 논의 할 것입니다 &lt;code&gt;!&lt;/code&gt; 유형 및 동적 크기 유형.</target>
        </trans-unit>
        <trans-unit id="1e24d83679bf4a662ce93151d4c79beb7bc3d976" translate="yes" xml:space="preserve">
          <source>The Slice Type</source>
          <target state="translated">슬라이스 타입</target>
        </trans-unit>
        <trans-unit id="b60a9b411326be4b7b78e74a3c2736078d2cb936" translate="yes" xml:space="preserve">
          <source>The Stack and the Heap</source>
          <target state="translated">스택과 힙</target>
        </trans-unit>
        <trans-unit id="ea9187c27f13ce2d0fda228c7804b1eacb2a7df4" translate="yes" xml:space="preserve">
          <source>The Static Lifetime</source>
          <target state="translated">정적 수명</target>
        </trans-unit>
        <trans-unit id="dcc1bdcf64d9ba08b8c546b48a03373f9d896f1a" translate="yes" xml:space="preserve">
          <source>The Tests Module and &lt;code id=&quot;the-tests-module-and-cfgtest&quot;&gt;#[cfg(test)]&lt;/code&gt;</source>
          <target state="translated">테스트 모듈 및 &lt;code id=&quot;the-tests-module-and-cfgtest&quot;&gt;#[cfg(test)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43d375d205a43568d44e006351aba054a3a6df0e" translate="yes" xml:space="preserve">
          <source>The Trade-Offs of Using &lt;code id=&quot;the-trade-offs-of-using-clone&quot;&gt;clone&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;the-trade-offs-of-using-clone&quot;&gt;clone&lt;/code&gt; 사용의 단점</target>
        </trans-unit>
        <trans-unit id="874f680f597dff734725c0edb8d1cdbdc1c687fb" translate="yes" xml:space="preserve">
          <source>The Transmission Control Protocol is specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="translated">전송 제어 프로토콜은 &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793에&lt;/a&gt; 지정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d2bc0207cf3386e89a8ff90f2a45c74d008dd6b" translate="yes" xml:space="preserve">
          <source>The Tuple Type</source>
          <target state="translated">튜플 타입</target>
        </trans-unit>
        <trans-unit id="a1fe62622ad4944befb6b7cd3fbf5afe74512445" translate="yes" xml:space="preserve">
          <source>The UID part of the peer credential. This is the effective UID of the process at the domain socket's endpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="720acae72ae852d88680bc6199aaf2a3185402bd" translate="yes" xml:space="preserve">
          <source>The Unsize trait should not be implemented directly. All implementations of Unsize are provided automatically by the compiler.</source>
          <target state="translated">Unsize 특성은 직접 구현해서는 안됩니다. Unsize의 모든 구현은 컴파일러에 의해 자동으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="9d8c2343fd3b49fd50014f949ed7698cf46aba4f" translate="yes" xml:space="preserve">
          <source>The ability to return a type that is only specified by the trait it implements is especially useful in the context of closures and iterators, which we cover in Chapter 13. Closures and iterators create types that only the compiler knows or types that are very long to specify. The &lt;code&gt;impl Trait&lt;/code&gt; syntax lets you concisely specify that a function returns some type that implements the &lt;code&gt;Iterator&lt;/code&gt; trait without needing to write out a very long type.</source>
          <target state="translated">구현 한 특성에 의해서만 지정된 유형을 반환하는 기능은 13 장에서 다루는 클로저 및 반복기의 컨텍스트에서 특히 유용합니다. 클로저 및 반복기는 컴파일러가 알고있는 유형 또는 매우 긴 유형 지정하십시오. &lt;code&gt;impl Trait&lt;/code&gt; 구문은 간결하게하는 기능이 몇 가지 유형을 반환 지정할 수 있습니다 그 구현 &lt;code&gt;Iterator&lt;/code&gt; 매우 긴 타입을 쓸 필요없이 특성.</target>
        </trans-unit>
        <trans-unit id="8344955111fdc074c9729e11010ee2eab0af03c1" translate="yes" xml:space="preserve">
          <source>The above example can be resolved by either reducing the number of lifetime bounds to one or by making the trait object lifetime explicit, like so:</source>
          <target state="translated">위의 예는 수명 경계의 수를 1로 줄이거 나 특성 객체 수명을 명시 적으로 만들면 해결 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cde40ac9fea8ec2f55d9ca0d422fc89008496087" translate="yes" xml:space="preserve">
          <source>The above indirection is the additional runtime cost of calling a function on a &lt;code&gt;dyn Trait&lt;/code&gt;. Methods called by dynamic dispatch generally cannot be inlined by the compiler.</source>
          <target state="translated">위의 간접적 인 &lt;code&gt;dyn Trait&lt;/code&gt; 는 dyn Trait 에서 함수를 호출하는 추가 런타임 비용입니다 . 일반적으로 동적 디스패치에 의해 호출되는 메서드는 컴파일러에서 인라인 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="deb20b7d624d1708cb7603af7f7d5931910cd966" translate="yes" xml:space="preserve">
          <source>The above is &lt;em&gt;still&lt;/em&gt; an expression but it will always evaluate to &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">위는 &lt;em&gt;여전히&lt;/em&gt; 표현식이지만 항상 &lt;code&gt;()&lt;/code&gt; 로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="ede9c72b891dfc1d92b0b9fffc4f21007f9ae902" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i128::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i128&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i128::MIN&lt;/code&gt; without a panic.</source>
          <target state="translated">의 절대 값 &lt;code&gt;i128::MIN&lt;/code&gt; int로서 표현할 수없는 &lt;code&gt;i128&lt;/code&gt; 하고, 오버 플로우가 발생할 계산하려고. 즉, 디버그 모드의 코드는이 경우 패닉을 유발하고 최적화 된 코드는 패닉없이 &lt;code&gt;i128::MIN&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e4ff7b2880604f74445f905b71fdee96836fc628" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i128::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i128&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i128::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">의 절대 값 &lt;code&gt;i128::min_value()&lt;/code&gt; int로서 표현할 수없는 &lt;code&gt;i128&lt;/code&gt; 하고, 오버 플로우가 발생할 계산하려고. 즉, 디버그 모드의 코드는이 경우 패닉을 트리거하고 최적화 된 코드는 패닉없이 &lt;code&gt;i128::min_value()&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="68e6f1c95dcf27a099d3d4e155f55896bf8faf93" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i16::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i16&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i16::MIN&lt;/code&gt; without a panic.</source>
          <target state="translated">의 절대 값 &lt;code&gt;i16::MIN&lt;/code&gt; int로서 표현할 수없는 &lt;code&gt;i16&lt;/code&gt; 하고 오버 플로우가 발생할 계산하려고. 즉, 디버그 모드의 코드는이 경우 패닉을 유발하고 최적화 된 코드는 패닉없이 &lt;code&gt;i16::MIN&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c6634b50eb0aa3afe906f4e13b4800cc26454c92" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i16::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i16&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i16::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">의 절대 값 &lt;code&gt;i16::min_value()&lt;/code&gt; int로서 표현할 수없는 &lt;code&gt;i16&lt;/code&gt; 하고 오버 플로우가 발생할 계산하려고. 즉, 디버그 모드의 코드는이 경우 패닉을 트리거하고 최적화 된 코드는 패닉없이 &lt;code&gt;i16::min_value()&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="37e2f0833c2e3fce2e0d86c6e578d1435f9c3b8f" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i32::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i32&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i32::MIN&lt;/code&gt; without a panic.</source>
          <target state="translated">의 절대 값 &lt;code&gt;i32::MIN&lt;/code&gt; int로서 표현할 수없는 &lt;code&gt;i32&lt;/code&gt; 하고 오버 플로우가 발생할 계산하려고. 즉, 디버그 모드의 코드는이 경우 패닉을 유발하고 최적화 된 코드는 패닉없이 &lt;code&gt;i32::MIN&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="91a991a9b7dce7a35eefa5dff81ee4a280a7e4f1" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i32::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i32&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i32::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">의 절대 값 &lt;code&gt;i32::min_value()&lt;/code&gt; int로서 표현할 수없는 &lt;code&gt;i32&lt;/code&gt; 하고 오버 플로우가 발생할 계산하려고. 즉, 디버그 모드의 코드는이 경우 패닉을 트리거하고 최적화 된 코드는 패닉없이 &lt;code&gt;i32::min_value()&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="2ddae722d1b9330d37bd61655516374aae130695" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i64::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i64&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i64::MIN&lt;/code&gt; without a panic.</source>
          <target state="translated">의 절대 값 &lt;code&gt;i64::MIN&lt;/code&gt; int로서 표현할 수없는 &lt;code&gt;i64&lt;/code&gt; 하고 오버 플로우가 발생할 계산하려고. 즉, 디버그 모드의 코드는이 경우 패닉을 유발하고 최적화 된 코드는 패닉없이 &lt;code&gt;i64::MIN&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4c50c4d71fa72eabc1e0818c0a858ae1903c1c3c" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i64::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i64&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i64::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">의 절대 값 &lt;code&gt;i64::min_value()&lt;/code&gt; int로서 표현할 수없는 &lt;code&gt;i64&lt;/code&gt; 하고 오버 플로우가 발생할 계산하려고. 즉, 디버그 모드의 코드는이 경우 패닉을 트리거하고 최적화 된 코드는 패닉없이 &lt;code&gt;i64::min_value()&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="94540f2ba32a8d4e2123f1b683b0ff15f6511fa8" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i8::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i8&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i8::MIN&lt;/code&gt; without a panic.</source>
          <target state="translated">의 절대 값 &lt;code&gt;i8::MIN&lt;/code&gt; int로서 표현할 수없는 &lt;code&gt;i8&lt;/code&gt; 하고, 오버 플로우가 발생할 계산하려고. 즉, 디버그 모드의 코드는이 경우 패닉을 유발하고 최적화 된 코드는 패닉없이 &lt;code&gt;i8::MIN&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="5adbbbaac9cedf98e39759b8920bdb3431d04107" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i8::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i8&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i8::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">의 절대 값 &lt;code&gt;i8::min_value()&lt;/code&gt; int로서 표현할 수없는 &lt;code&gt;i8&lt;/code&gt; 하고, 오버 플로우가 발생할 계산하려고. 즉, 디버그 모드의 코드는이 경우 패닉을 트리거하고 최적화 된 코드는 패닉없이 &lt;code&gt;i8::min_value()&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="f3616827787c274826d0feb8bc695ca0f90e8398" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;isize::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;isize&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;isize::MIN&lt;/code&gt; without a panic.</source>
          <target state="translated">의 절대 값 &lt;code&gt;isize::MIN&lt;/code&gt; int로서 표현할 수없는 &lt;code&gt;isize&lt;/code&gt; 하고, 오버 플로우가 발생할 계산하려고. 즉, 디버그 모드의 코드는이 경우 패닉을 유발하고 최적화 된 코드는 패닉없이 &lt;code&gt;isize::MIN&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="5fa62dd0a50bd4c5554cb57272ae5164c2e1f601" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;isize::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;isize&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;isize::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">의 절대 값 &lt;code&gt;isize::min_value()&lt;/code&gt; int로서 표현할 수없는 &lt;code&gt;isize&lt;/code&gt; 하고, 오버 플로우가 발생할 계산하려고. 즉, 디버그 모드의 코드는이 경우 패닉을 트리거하고 최적화 된 코드는 패닉없이 &lt;code&gt;isize::min_value()&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="409fd764bcabc3595ffe004849ff8f4e30564756" translate="yes" xml:space="preserve">
          <source>The actual desugaring is more complex:</source>
          <target state="translated">실제 탈당은 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="88133b615f1381b0a02c487a3edbc253bc8ee09f" translate="yes" xml:space="preserve">
          <source>The actual stack size may be greater than this value if the platform specifies a minimal stack size.</source>
          <target state="translated">플랫폼에서 최소 스택 크기를 지정하면 실제 스택 크기가이 값보다 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e09eb4195a6425d3d0a7b968cb406d8968af9926" translate="yes" xml:space="preserve">
          <source>The addition assignment operator &lt;code&gt;+=&lt;/code&gt;.</source>
          <target state="translated">더하기 대입 연산자 &lt;code&gt;+=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="097ca9dd7ade97007d85b522a25e6d04cefa5c67" translate="yes" xml:space="preserve">
          <source>The addition operator &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">더하기 연산자 &lt;code&gt;+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="161b60a028315218a44d6ebb4a0a56ea64addb73" translate="yes" xml:space="preserve">
          <source>The address of temporary value was taken.</source>
          <target state="translated">임시 값의 주소를 가져 왔습니다.</target>
        </trans-unit>
        <trans-unit id="67b3b3b11425c46c946b0ed067dfaec63ac739cb" translate="yes" xml:space="preserve">
          <source>The address type can be any implementor of &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt; trait. See its documentation for concrete examples.</source>
          <target state="translated">주소 유형은 &lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt; 특성의 구현 자일 수 있습니다 . 구체적인 예는 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="554a0871d5bd274c4e9a4646e480108243a7e12e" translate="yes" xml:space="preserve">
          <source>The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, whereas they are disallowed by the compile-time checks. Static analysis, like the Rust compiler, is inherently conservative. Some properties of code are impossible to detect by analyzing the code: the most famous example is the Halting Problem, which is beyond the scope of this book but is an interesting topic to research.</source>
          <target state="translated">런타임시 차용 규칙을 확인하는 이점은 특정 메모리 안전 시나리오가 허용되는 반면 컴파일 타임 검사에서는 허용되지 않는다는 것입니다. Rust 컴파일러와 같은 정적 분석은 본질적으로 보수적입니다. 코드의 일부 특성은 코드를 분석하여 감지 할 수 없습니다. 가장 유명한 예는 Halting Problem이며,이 책의 범위를 벗어나지 만 연구하기에 흥미로운 주제입니다.</target>
        </trans-unit>
        <trans-unit id="cf97cfec24f32bdc09751ee8bbb19e7117656381" translate="yes" xml:space="preserve">
          <source>The advantage of using trait objects and Rust&amp;rsquo;s type system to write code similar to code using duck typing is that we never have to check whether a value implements a particular method at runtime or worry about getting errors if a value doesn&amp;rsquo;t implement a method but we call it anyway. Rust won&amp;rsquo;t compile our code if the values don&amp;rsquo;t implement the traits that the trait objects need.</source>
          <target state="translated">덕 타이핑을 사용하여 코드와 유사한 코드를 작성하기 위해 특성 객체와 Rust 유형 시스템을 사용하는 이점은 런타임에 값이 특정 메소드를 구현하는지 여부를 확인할 필요가 없으며 값이 메소드를 구현하지 않으면 오류가 발생할 염려가 없다는 것입니다. 우리는 어쨌든 그것을 부릅니다. 값이 특성 오브젝트에 필요한 특성을 구현하지 않으면 Rust는 코드를 컴파일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f36aabbacdf9ecb5c08c91a08fabb8510a201b8" translate="yes" xml:space="preserve">
          <source>The advantages of checking the borrowing rules at compile time are that errors will be caught sooner in the development process, and there is no impact on runtime performance because all the analysis is completed beforehand. For those reasons, checking the borrowing rules at compile time is the best choice in the majority of cases, which is why this is Rust&amp;rsquo;s default.</source>
          <target state="translated">컴파일 타임에 차용 규칙을 확인하는 이점은 개발 프로세스에서 오류가 더 빨리 포착되며 모든 분석이 사전에 완료되므로 런타임 성능에 영향을 미치지 않는다는 것입니다. 이러한 이유로 대부분의 경우 컴파일 타임에 차용 규칙을 확인하는 것이 최선의 선택이므로 이것이 Rust의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="802cd88adc867c6ed95af7c7632a5b9312da114b" translate="yes" xml:space="preserve">
          <source>The alignment is specified as an integer parameter in the form of &lt;code&gt;#[repr(align(x))]&lt;/code&gt; or &lt;code&gt;#[repr(packed(x))]&lt;/code&gt;. The alignment value must be a power of two from 1 up to 2&lt;sup&gt;29&lt;/sup&gt;. For &lt;code&gt;packed&lt;/code&gt;, if no value is given, as in &lt;code&gt;#[repr(packed)]&lt;/code&gt;, then the value is 1.</source>
          <target state="translated">정렬은 &lt;code&gt;#[repr(align(x))]&lt;/code&gt; 또는 &lt;code&gt;#[repr(packed(x))]&lt;/code&gt; 형식으로 정수 매개 변수로 지정됩니다 . 정렬 값은 1에서 2 &lt;sup&gt;29&lt;/sup&gt; 사이의 2의 거듭 제곱이어야합니다 . 들면 &lt;code&gt;packed&lt;/code&gt; , 값이 같이 주어지지 않으면 &lt;code&gt;#[repr(packed)]&lt;/code&gt; , 그 값은 1이다.</target>
        </trans-unit>
        <trans-unit id="4210b5f1c3a4d7626a8282b8b0091e3127367f26" translate="yes" xml:space="preserve">
          <source>The alignment may be raised or lowered with the &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers respectively. They alter the representation specified in the attribute. If no representation is specified, the default one is altered.</source>
          <target state="translated">정렬은 &lt;code&gt;align&lt;/code&gt; 및 &lt;code&gt;packed&lt;/code&gt; 수정 자로 각각 증가 또는 감소 될 수있다 . 속성에 지정된 표현을 변경합니다. 표현을 지정하지 않으면 기본 표현이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="0bbd4814e74e1731ea096a3e29eb0e49a6112a9b" translate="yes" xml:space="preserve">
          <source>The alignment modifiers</source>
          <target state="translated">정렬 수정 자</target>
        </trans-unit>
        <trans-unit id="9a801ec59d9d78b1342286bf3c47cdf72d8754c9" translate="yes" xml:space="preserve">
          <source>The alignment of a value specifies what addresses values are preferred to start at. Always a power of two. References to a value must be aligned. &lt;a href=&quot;type-layout#size-and-alignment&quot;&gt;More&lt;/a&gt;.</source>
          <target state="translated">값의 정렬은 시작하는 데 선호되는 주소 값을 지정합니다. 항상 2의 거듭 제곱. 값에 대한 참조는 정렬되어야합니다. &lt;a href=&quot;type-layout#size-and-alignment&quot;&gt;더&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7d8131883a9466d9495401638572f0f7002cb80" translate="yes" xml:space="preserve">
          <source>The alignment of the struct is the alignment of the most-aligned field in it.</source>
          <target state="translated">구조체의 정렬은 가장 정렬 된 필드의 정렬입니다.</target>
        </trans-unit>
        <trans-unit id="cb2d786ce814f96269971824a7ca8c85b85a4a91" translate="yes" xml:space="preserve">
          <source>The allocated block of memory may or may not be initialized.</source>
          <target state="translated">할당 된 메모리 블록은 초기화되거나 초기화되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a853460caf9660ad50bba38269de71834329efaf" translate="yes" xml:space="preserve">
          <source>The allocation error hook is a global resource.</source>
          <target state="translated">할당 오류 후크는 글로벌 리소스입니다.</target>
        </trans-unit>
        <trans-unit id="dd622480c0a0d020ad0c83e155629929c531f8bd" translate="yes" xml:space="preserve">
          <source>The allocation error hook is invoked when an infallible memory allocation fails, before the runtime aborts. The default hook prints a message to standard error, but this behavior can be customized with the &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt;&lt;code&gt;set_alloc_error_hook&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt;&lt;code&gt;take_alloc_error_hook&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">런타임 오류가 발생하기 전에 오류가없는 메모리 할당이 실패하면 할당 오류 후크가 호출됩니다. 기본 후크는 메시지를 표준 오류로 인쇄하지만이 동작은 &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt; &lt;code&gt;set_alloc_error_hook&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt; &lt;code&gt;take_alloc_error_hook&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="460b0be997a504bd93f9a5f2102be17a4fe4f237" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0b&lt;/code&gt; in front of the output.</source>
          <target state="translated">대체 플래그 &lt;code&gt;#&lt;/code&gt; 는 출력 앞에 &lt;code&gt;0b&lt;/code&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="b053ed1e6052a16bbf0f4a89d40e16ee9bf6a88d" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0o&lt;/code&gt; in front of the output.</source>
          <target state="translated">대체 플래그 &lt;code&gt;#&lt;/code&gt; 는 출력 앞에 &lt;code&gt;0o&lt;/code&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="1a67677d2b4895bdc1fb6847161bf39c61cb99f4" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0x&lt;/code&gt; in front of the output.</source>
          <target state="translated">대체 플래그 &lt;code&gt;#&lt;/code&gt; 는 출력 앞에 &lt;code&gt;0x&lt;/code&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="11ba8acfe40883baf3a25418d4023d5eeae6eb43" translate="yes" xml:space="preserve">
          <source>The answer to this problem is the &lt;em&gt;Cargo.lock&lt;/em&gt; file, which was created the first time you ran &lt;code&gt;cargo build&lt;/code&gt; and is now in your &lt;em&gt;guessing_game&lt;/em&gt; directory. When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the &lt;em&gt;Cargo.lock&lt;/em&gt; file. When you build your project in the future, Cargo will see that the &lt;em&gt;Cargo.lock&lt;/em&gt; file exists and use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically. In other words, your project will remain at &lt;code&gt;0.3.14&lt;/code&gt; until you explicitly upgrade, thanks to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="translated">이 문제에 대한 답은 &lt;em&gt;Cargo.lock&lt;/em&gt; 파일입니다.이 파일은 &lt;code&gt;cargo build&lt;/code&gt; 처음 실행할 때 만들어졌으며 이제 &lt;em&gt;guessing_game&lt;/em&gt; 디렉토리에 있습니다. 처음으로 프로젝트를 빌드 할 때 Cargo는 기준에 맞는 모든 버전의 종속성을 파악한 다음 &lt;em&gt;Cargo.lock&lt;/em&gt; 파일에 씁니다 . 나중에 프로젝트를 빌드 할 때 Cargo는 &lt;em&gt;Cargo.lock&lt;/em&gt; 파일이 존재 함을 확인하고 버전을 다시 알아내는 모든 작업을 수행하는 대신 지정된 버전을 사용합니다. 이를 통해 자동으로 재현 가능한 빌드를 만들 수 있습니다. 즉, 당신의 프로젝트에 남아 &lt;code&gt;0.3.14&lt;/code&gt; , 당신은 명시 적으로 업그레이드 할 때까지 덕분에 &lt;em&gt;Cargo.lock을&lt;/em&gt; 파일.</target>
        </trans-unit>
        <trans-unit id="8fb95ccc8cbb2b44a80d4d0a731ecb5bea70e713" translate="yes" xml:space="preserve">
          <source>The answer to this problem is the &lt;em&gt;Cargo.lock&lt;/em&gt; file, which was created the first time you ran &lt;code&gt;cargo build&lt;/code&gt; and is now in your &lt;em&gt;guessing_game&lt;/em&gt; directory. When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the &lt;em&gt;Cargo.lock&lt;/em&gt; file. When you build your project in the future, Cargo will see that the &lt;em&gt;Cargo.lock&lt;/em&gt; file exists and use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically. In other words, your project will remain at &lt;code&gt;0.5.5&lt;/code&gt; until you explicitly upgrade, thanks to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="translated">이 문제에 대한 답은 &lt;em&gt;Cargo.lock&lt;/em&gt; 파일입니다.이 파일은 &lt;code&gt;cargo build&lt;/code&gt; 처음 실행할 때 생성되었으며 이제 &lt;em&gt;guessing_game&lt;/em&gt; 디렉토리에 있습니다. 처음으로 프로젝트를 빌드 할 때 Cargo는 기준에 맞는 모든 버전의 종속성을 파악한 다음이를 &lt;em&gt;Cargo.lock&lt;/em&gt; 파일에 기록합니다 . 나중에 프로젝트를 빌드 할 때 Cargo는 &lt;em&gt;Cargo.lock&lt;/em&gt; 파일이 있음을 확인하고 버전을 다시 파악하는 모든 작업을 수행하는 대신 여기에 지정된 버전을 사용합니다. 이를 통해 자동으로 재현 가능한 빌드를 가질 수 있습니다. 즉, 당신의 프로젝트에 남아 &lt;code&gt;0.5.5&lt;/code&gt; , 명시 적으로 업그레이드 할 때까지 덕분에 &lt;em&gt;Cargo.lock을&lt;/em&gt; 파일.</target>
        </trans-unit>
        <trans-unit id="c50839f5b75ebf2449202c65bd78e83e2a04633c" translate="yes" xml:space="preserve">
          <source>The argument order should be changed to match the parameter declaration order, as in the following:</source>
          <target state="translated">인수 순서는 다음과 같이 매개 변수 선언 순서와 일치하도록 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff3b9111423732cd0796ed3af4340d1aeaddff87" translate="yes" xml:space="preserve">
          <source>The argument to the &lt;code&gt;llvm_asm&lt;/code&gt; macro is not well-formed.</source>
          <target state="translated">&lt;code&gt;llvm_asm&lt;/code&gt; 매크로에 대한 인수의 형식 이 올바르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d5e37bb48121061d7a9d1253e50cf299206b8ed" translate="yes" xml:space="preserve">
          <source>The argument, &lt;code&gt;mid&lt;/code&gt;, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</source>
          <target state="translated">&lt;code&gt;mid&lt;/code&gt; 인수 는 문자열의 시작 부분에서 바이트 오프셋이어야합니다. 또한 UTF-8 코드 포인트의 경계에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="843c167795952476fd4949d773d09e67f37bae5c" translate="yes" xml:space="preserve">
          <source>The arguments will be formatted according to the specified format string into the output stream provided.</source>
          <target state="translated">인수는 지정된 형식 문자열에 따라 제공된 출력 스트림으로 형식화됩니다.</target>
        </trans-unit>
        <trans-unit id="47d8ae2e6d2ad4b4b9256e9f4136431f5f0ee17f" translate="yes" xml:space="preserve">
          <source>The array index expression can be implemented for types other than arrays and slices by implementing the &lt;a href=&quot;../../std/ops/trait.index&quot;&gt;Index&lt;/a&gt; and &lt;a href=&quot;../../std/ops/trait.indexmut&quot;&gt;IndexMut&lt;/a&gt; traits.</source>
          <target state="translated">&lt;a href=&quot;../../std/ops/trait.index&quot;&gt;Index&lt;/a&gt; 및 &lt;a href=&quot;../../std/ops/trait.indexmut&quot;&gt;IndexMut&lt;/a&gt; 특성 을 구현하여 배열 및 슬라이스 이외의 유형에 대해 배열 색인 표현식을 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43b42b264d53f00eb4d50d966bdebfe503d9e502" translate="yes" xml:space="preserve">
          <source>The array named &lt;code&gt;a&lt;/code&gt; will contain &lt;code&gt;5&lt;/code&gt; elements that will all be set to the value &lt;code&gt;3&lt;/code&gt; initially. This is the same as writing &lt;code&gt;let a = [3, 3, 3, 3, 3];&lt;/code&gt; but in a more concise way.</source>
          <target state="translated">이름이 &lt;code&gt;a&lt;/code&gt; 인 배열 에는 처음에 값 &lt;code&gt;3&lt;/code&gt; 으로 설정되는 &lt;code&gt;5&lt;/code&gt; 개의 요소 가 포함 됩니다 . 이것은 &lt;code&gt;let a = [3, 3, 3, 3, 3];&lt;/code&gt; 을 쓰는 것과 같습니다 . 그러나 더 간결한 방식으로.</target>
        </trans-unit>
        <trans-unit id="bda6f38466d2f9f90243514e2e1d1d622e872f82" translate="yes" xml:space="preserve">
          <source>The associated error which can be returned from parsing.</source>
          <target state="translated">구문 분석에서 리턴 될 수있는 연관된 오류입니다.</target>
        </trans-unit>
        <trans-unit id="264397f1a1d81bc0bfb862d1058ae5d080545332" translate="yes" xml:space="preserve">
          <source>The associated type used was not defined in the trait.</source>
          <target state="translated">사용 된 관련 유형이 특성에 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="95b071fe52a22a379b9072dba9b8116f1e91d5e0" translate="yes" xml:space="preserve">
          <source>The assumed lifetime of references held by a &lt;a href=&quot;types/trait-object&quot;&gt;trait object&lt;/a&gt; is called its &lt;em&gt;default object lifetime bound&lt;/em&gt;. These were defined in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md&quot;&gt;RFC 599&lt;/a&gt; and amended in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;types/trait-object&quot;&gt;특성 오브젝트&lt;/a&gt; 가 보유하는 가정 된 참조 수명을 &lt;em&gt;기본 오브젝트 수명 바운드&lt;/em&gt; 라고합니다 . 이들은 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md&quot;&gt;RFC 599&lt;/a&gt; 에서 정의 되었고 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt; 에서 수정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4a633a670846190d4e317682018f539e771650d4" translate="yes" xml:space="preserve">
          <source>The atomic intrinsics provide common atomic operations on machine words, with multiple possible memory orderings. They obey the same semantics as C++11. See the LLVM documentation on [&lt;a href=&quot;http://llvm.org/docs/Atomics.html&quot;&gt;atomics&lt;/a&gt;].</source>
          <target state="translated">원자 내장 함수는 여러 가능한 메모리 순서와 함께 기계어에 대한 일반적인 원자 연산을 제공합니다. 그들은 C ++ 11과 동일한 의미를 따릅니다. [ &lt;a href=&quot;http://llvm.org/docs/Atomics.html&quot;&gt;atomics&lt;/a&gt; ] 에 대한 LLVM 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4eacfc8c255cb1ef132a6a65b58c2019ebea9baf" translate="yes" xml:space="preserve">
          <source>The atomic types in this module may not be available on all platforms. The atomic types here are all widely available, however, and can generally be relied upon existing. Some notable exceptions are:</source>
          <target state="translated">이 모듈의 원자 유형은 모든 플랫폼에서 사용 가능하지 않을 수 있습니다. 그러나 여기서 원자 유형은 모두 널리 사용 가능하며 일반적으로 기존 유형에 의존 할 수 있습니다. 몇 가지 주목할만한 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="71cc0f45759d249e1ba21744ede7b9ef7445260e" translate="yes" xml:space="preserve">
          <source>The attribute consists of a path to the attribute, followed by an optional delimited token tree whose interpretation is defined by the attribute. Attributes other than macro attributes also allow the input to be an equals sign (&lt;code&gt;=&lt;/code&gt;) followed by a literal expression. See the &lt;a href=&quot;#meta-item-attribute-syntax&quot;&gt;meta item syntax&lt;/a&gt; below for more details.</source>
          <target state="translated">속성은 속성에 대한 경로와 속성에 의해 해석이 정의 된 선택적 구분 토큰 트리로 구성됩니다. 매크로 속성 이외의 속성은 입력이 등호 ( &lt;code&gt;=&lt;/code&gt; ) 뒤에 리터럴 표현식이 되도록 허용합니다 . 자세한 내용은 아래 &lt;a href=&quot;#meta-item-attribute-syntax&quot;&gt;메타 항목 구문&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c5f89ad9ce66636388cf7509f930392e52eeb867" translate="yes" xml:space="preserve">
          <source>The attribute consists of a path to the attribute, followed by an optional delimited token tree whose interpretation is defined by the attribute. Attributes other than macro attributes also allow the input to be an equals sign (&lt;code&gt;=&lt;/code&gt;) followed by a literal expression. See the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;meta item syntax&lt;/a&gt; below for more details.</source>
          <target state="translated">속성은 속성에 대한 경로와 속성으로 해석이 정의 된 선택적 구분 토큰 트리로 구성됩니다. 매크로 속성 이외의 속성을 사용하면 입력이 등호 ( &lt;code&gt;=&lt;/code&gt; ) 다음에 리터럴 표현식이 될 수도 있습니다. 자세한 내용은 아래 &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;메타 항목 구문&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b79be106b3314bbccaaacf6171952db704c5419b" translate="yes" xml:space="preserve">
          <source>The attribute is used on a &lt;code&gt;static&lt;/code&gt; item whose type implements the &lt;a href=&quot;https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait. This type can be provided by an external library:</source>
          <target state="translated">이 속성은 유형이 &lt;a href=&quot;https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt; 특성을 구현 하는 &lt;code&gt;static&lt;/code&gt; 항목 에서 사용됩니다 . 이 유형은 외부 라이브러리에서 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="638938ad1b96ca367b1ad29ad316e67748e69b45" translate="yes" xml:space="preserve">
          <source>The attribute is used on a &lt;code&gt;static&lt;/code&gt; item whose type implements the &lt;a href=&quot;trait.globalalloc&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait. This type can be provided by an external library:</source>
          <target state="translated">속성은 유형이 &lt;a href=&quot;trait.globalalloc&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt; 특성을 구현 하는 &lt;code&gt;static&lt;/code&gt; 항목 에 사용됩니다 . 이 유형은 외부 라이브러리에서 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07001b94d9ec08710a57474a9ab6a5a7c57ed031" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a block expression are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;.</source>
          <target state="translated">블록 표현식에서 의미가있는 속성은 &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lint check 속성&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="db84623389bc5fe968094b478ac6446a9f7cd32b" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt;&lt;code&gt;export_name&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt;&lt;code&gt;link_section&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt;&lt;code&gt;no_mangle&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt;&lt;code&gt;must_use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../procedural-macros&quot;&gt;the procedural macro attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/testing&quot;&gt;the testing attributes&lt;/a&gt;, and &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;the optimization hint attributes&lt;/a&gt;. Functions also accept attributes macros.</source>
          <target state="translated">함수에 의미가있는 속성은 &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt; &lt;code&gt;export_name&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt; &lt;code&gt;link_section&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt; &lt;code&gt;no_mangle&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lint check 속성&lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt; &lt;code&gt;must_use&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../procedural-macros&quot;&gt;절차 적 매크로 속성&lt;/a&gt; , &lt;a href=&quot;../attributes/testing&quot;&gt;테스트 속성&lt;/a&gt; 및 &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;최적화 힌트 속성&lt;/a&gt; 입니다. 함수는 속성 매크로도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="622c3bad6ebce7dda9ab10b347056427bd42a746" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation#the-cfg-attribute&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../conditional-compilation#the-cfg_attr-attribute&quot;&gt;&lt;code&gt;cfg_attr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt;&lt;code&gt;export_name&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt;&lt;code&gt;link_section&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt;&lt;code&gt;no_mangle&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt;&lt;code&gt;must_use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../procedural-macros&quot;&gt;the procedural macro attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/testing&quot;&gt;the testing attributes&lt;/a&gt;, and &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;the optimization hint attributes&lt;/a&gt;. Functions also accept attributes macros.</source>
          <target state="translated">함수에 의미가있는 속성은 &lt;a href=&quot;../conditional-compilation#the-cfg-attribute&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../conditional-compilation#the-cfg_attr-attribute&quot;&gt; &lt;code&gt;cfg_attr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt; &lt;code&gt;export_name&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt; &lt;code&gt;link_section&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt; &lt;code&gt;no_mangle&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lint 검사 속성&lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt; &lt;code&gt;must_use&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../procedural-macros&quot;&gt;절차 적 매크로 속성&lt;/a&gt; , &lt;a href=&quot;../attributes/testing&quot;&gt;테스트 속성&lt;/a&gt; 및 &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;최적화 힌트 속성&lt;/a&gt; 입니다. 함수는 속성 매크로도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a9286c2061446f78d1eb0dacb8ad2bed2198b3a3" translate="yes" xml:space="preserve">
          <source>The author of the code in Listing 14-4, which uses the &lt;code&gt;art&lt;/code&gt; crate, had to figure out that &lt;code&gt;PrimaryColor&lt;/code&gt; is in the &lt;code&gt;kinds&lt;/code&gt; module and &lt;code&gt;mix&lt;/code&gt; is in the &lt;code&gt;utils&lt;/code&gt; module. The module structure of the &lt;code&gt;art&lt;/code&gt; crate is more relevant to developers working on the &lt;code&gt;art&lt;/code&gt; crate than to developers using the &lt;code&gt;art&lt;/code&gt; crate. The internal structure that organizes parts of the crate into the &lt;code&gt;kinds&lt;/code&gt; module and the &lt;code&gt;utils&lt;/code&gt; module doesn&amp;rsquo;t contain any useful information for someone trying to understand how to use the &lt;code&gt;art&lt;/code&gt; crate. Instead, the &lt;code&gt;art&lt;/code&gt; crate&amp;rsquo;s module structure causes confusion because developers have to figure out where to look, and the structure is inconvenient because developers must specify the module names in the &lt;code&gt;use&lt;/code&gt; statements.</source>
          <target state="translated">&lt;code&gt;art&lt;/code&gt; 크레이트 를 사용하는 Listing 14-4의 코드 작성자는 &lt;code&gt;PrimaryColor&lt;/code&gt; 가 &lt;code&gt;kinds&lt;/code&gt; 모듈에 있고 &lt;code&gt;mix&lt;/code&gt; 가 &lt;code&gt;utils&lt;/code&gt; 모듈에 있음을 알아 내야했다 . 의 모듈 구조 &lt;code&gt;art&lt;/code&gt; 상자는 작업을 개발자들에게 더 관련이 &lt;code&gt;art&lt;/code&gt; 보다 사용하는 개발자에 상자 &lt;code&gt;art&lt;/code&gt; 상자를. 상자의 일부를 &lt;code&gt;kinds&lt;/code&gt; 모듈과 &lt;code&gt;utils&lt;/code&gt; 모듈 로 구성하는 내부 구조 에는 &lt;code&gt;art&lt;/code&gt; 상자 사용법을 이해하려는 사람에게 유용한 정보가 포함되어 있지 않습니다 . 대신 &lt;code&gt;art&lt;/code&gt; crate의 모듈 구조는 개발자가 어디를 찾아야하는지에 대한 혼란을 야기하고, 개발자가 &lt;code&gt;use&lt;/code&gt; 문 에 모듈 이름을 지정해야하기 때문에 구조가 불편합니다 .</target>
        </trans-unit>
        <trans-unit id="d8ebf8e3de6c2376fc1a32c2614c0e8023f7f60e" translate="yes" xml:space="preserve">
          <source>The author of this code probably wants &lt;code&gt;collect()&lt;/code&gt; to return a &lt;code&gt;Result&amp;lt;Vec&amp;lt;bool&amp;gt;, ()&amp;gt;&lt;/code&gt;, but the compiler can't be sure that there isn't another type &lt;code&gt;T&lt;/code&gt; implementing both &lt;code&gt;Try&lt;/code&gt; and &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; in scope such that &lt;code&gt;T::Ok == Vec&amp;lt;bool&amp;gt;&lt;/code&gt;. Hence, this code is ambiguous and an error is returned.</source>
          <target state="translated">이 코드의 저자는 아마도 원 &lt;code&gt;collect()&lt;/code&gt; 반환하는 &lt;code&gt;Result&amp;lt;Vec&amp;lt;bool&amp;gt;, ()&amp;gt;&lt;/code&gt; 하지만, 컴파일러는 다른 타입이 아니라고 확신 할 수 없다 &lt;code&gt;T&lt;/code&gt; 를 모두 구현하는 &lt;code&gt;Try&lt;/code&gt; 와 &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; &lt;code&gt;T::Ok == Vec&amp;lt;bool&amp;gt;&lt;/code&gt; 범위의 () &amp;gt;&amp;gt; . 따라서이 코드는 모호하며 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="938569367b830c27a570a475e7cb23644f96b802" translate="yes" xml:space="preserve">
          <source>The author of this code probably wants &lt;code&gt;into()&lt;/code&gt; to return a &lt;code&gt;u64&lt;/code&gt;, but the compiler can't be sure that there isn't another type &lt;code&gt;T&lt;/code&gt; where both &lt;code&gt;u32: Into&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;u64: Add&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="946c3c8468dffe1ee08b57091aa458b31b356f72" translate="yes" xml:space="preserve">
          <source>The automatically generated &quot;drop glue&quot; which recursively calls the destructors of the all fields of this value.</source>
          <target state="translated">이 값의 모든 필드에 대한 소멸자를 재귀 적으로 호출하는 자동 생성 &quot;드롭 글루&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="442e142fa9a496c6c2ff3a02ee78aa50e228d6e4" translate="yes" xml:space="preserve">
          <source>The bad state is not something that&amp;rsquo;s &lt;em&gt;expected&lt;/em&gt; to happen occasionally.</source>
          <target state="translated">나쁜 상태는 때때로 일어날 &lt;em&gt;것으로 예상되는&lt;/em&gt; 것이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="1030d03bed1910f08091eb456180338b656dc0aa" translate="yes" xml:space="preserve">
          <source>The base of a &lt;a href=&quot;expressions/struct-expr#functional-update-syntax&quot;&gt;functional update&lt;/a&gt; struct expression.</source>
          <target state="translated">a의 기본 &lt;a href=&quot;expressions/struct-expr#functional-update-syntax&quot;&gt;기능 업데이트&lt;/a&gt; 구조체 식입니다.</target>
        </trans-unit>
        <trans-unit id="1da424ed8fd790e722f71cc50f820022f89f696b" translate="yes" xml:space="preserve">
          <source>The behavior of the returned &lt;code&gt;Waker&lt;/code&gt; is undefined if the contract defined in &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;'s and &lt;a href=&quot;struct.rawwakervtable&quot;&gt;&lt;code&gt;RawWakerVTable&lt;/code&gt;&lt;/a&gt;'s documentation is not upheld. Therefore this method is unsafe.</source>
          <target state="translated">&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.rawwakervtable&quot;&gt; &lt;code&gt;RawWakerVTable&lt;/code&gt; &lt;/a&gt; 설명서에 정의 된 계약이 유지되지 않으면 반환 된 &lt;code&gt;Waker&lt;/code&gt; 의 동작 은 정의되지 않습니다. 따라서이 방법은 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7f5bfcda53c0f0ccac4fbf04091f03de55bc719" translate="yes" xml:space="preserve">
          <source>The behavior of this method must be independent of the state of the &lt;code&gt;Read&lt;/code&gt;er - the method only takes &lt;code&gt;&amp;amp;self&lt;/code&gt; so that it can be used through trait objects.</source>
          <target state="translated">이 방법의 동작은 상태 독립적이어야 &lt;code&gt;Read&lt;/code&gt; 어 -이 방법은 소요 &lt;code&gt;&amp;amp;self&lt;/code&gt; 특성 객체를 통해 사용할 수 있도록.</target>
        </trans-unit>
        <trans-unit id="92a385c5078364ae9300fa907e25a19462c00810" translate="yes" xml:space="preserve">
          <source>The benefit of having this restriction is that Rust can prevent data races at compile time. A &lt;em&gt;data race&lt;/em&gt; is similar to a race condition and happens when these three behaviors occur:</source>
          <target state="translated">이 제한이있는 이점은 Rust가 컴파일시 데이터 경쟁을 막을 수 있다는 것입니다. &lt;em&gt;데이터 레이스&lt;/em&gt; 경쟁 조건과 유사하며이 세 가지 행동이 발생할 때 발생합니다</target>
        </trans-unit>
        <trans-unit id="94345eda8bccf9faca124acc23e9dfc7f68245ec" translate="yes" xml:space="preserve">
          <source>The bits that define the access mode are masked out with &lt;code&gt;O_ACCMODE&lt;/code&gt;, to ensure they do not interfere with the access mode set by Rusts options.</source>
          <target state="translated">액세스 모드를 정의하는 비트는 &lt;code&gt;O_ACCMODE&lt;/code&gt; 로 마스킹 되어 Rusts 옵션에 의해 설정된 액세스 모드를 방해하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eaa8e0a3053148a58d441c5d948ef0afd09016e9" translate="yes" xml:space="preserve">
          <source>The bitwise AND assignment operator &lt;code&gt;&amp;amp;=&lt;/code&gt;.</source>
          <target state="translated">비트 단위 AND 연산자를 대입 &lt;code&gt;&amp;amp;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dd8ef8a8d73fdf98095248d6c0b2047cb203cf0" translate="yes" xml:space="preserve">
          <source>The bitwise AND operator &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">비트 단위 AND 연산자 &lt;code&gt;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bfdab4f43dd337afc8fc0552897bf0d88f4fb0e" translate="yes" xml:space="preserve">
          <source>The bitwise OR assignment operator &lt;code&gt;|=&lt;/code&gt;.</source>
          <target state="translated">비트 OR 대입 연산자 &lt;code&gt;|=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a78ed80e19856e33ead5257328ef19e1b110eb08" translate="yes" xml:space="preserve">
          <source>The bitwise OR operator &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">비트 OR 연산자 &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eafeed4a6ad02f43abd1d07f62b4dea554b3a79c" translate="yes" xml:space="preserve">
          <source>The bitwise XOR assignment operator &lt;code&gt;^=&lt;/code&gt;.</source>
          <target state="translated">비트 XOR 대입 연산자 &lt;code&gt;^=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e805a1bbc089611af418b7bd9e638939dac553c5" translate="yes" xml:space="preserve">
          <source>The bitwise XOR operator &lt;code&gt;^&lt;/code&gt;.</source>
          <target state="translated">비트 단위의 XOR 연산자 &lt;code&gt;^&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9231fb12ba981aafd28f24ac7946a833b22a70e" translate="yes" xml:space="preserve">
          <source>The block must be allocated with the same alignment as &lt;a href=&quot;struct.layout#method.align&quot;&gt;&lt;code&gt;layout.align()&lt;/code&gt;&lt;/a&gt;, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="423b8775203e06b0ca354c4f4e97825a7d00a713" translate="yes" xml:space="preserve">
          <source>The block of a function is conceptually wrapped in a block that binds the argument patterns and then &lt;code&gt;return&lt;/code&gt;s the value of the function's block. This means that the tail expression of the block, if evaluated, ends up being returned to the caller. As usual, an explicit return expression within the body of the function will short-cut that implicit return, if reached.</source>
          <target state="translated">함수의 블록은 개념적으로 인수 패턴을 묶은 블록에 싸여 함수 블록 의 값 을 &lt;code&gt;return&lt;/code&gt; 합니다. 이것은 블록의 테일 표현식이 평가되면 호출자에게 리턴됨을 의미합니다. 평소와 같이 함수 본문 내에서 명시 적 리턴 표현식은 해당 암시 적 리턴에 도달하면이를 단축시킵니다.</target>
        </trans-unit>
        <trans-unit id="761ca0a326eb25085e5f1ebfbcef3b94f323b7c7" translate="yes" xml:space="preserve">
          <source>The block's size must fall in the range &lt;code&gt;[use_min, use_max]&lt;/code&gt;, where:</source>
          <target state="translated">블록의 크기는 &lt;code&gt;[use_min, use_max]&lt;/code&gt; 범위에 있어야합니다 . 여기서 :</target>
        </trans-unit>
        <trans-unit id="0d55dd5d42feb75840d81a2ee396cf125ff6a36f" translate="yes" xml:space="preserve">
          <source>The block's starting address must be aligned to &lt;code&gt;layout.align()&lt;/code&gt;.</source>
          <target state="translated">블록의 시작 주소는 &lt;code&gt;layout.align()&lt;/code&gt; 정렬되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6fb5efe10f486c51a18bce4f54350dd31c9d18ad" translate="yes" xml:space="preserve">
          <source>The bodies of the &lt;code&gt;if let&lt;/code&gt; and the &lt;code&gt;unwrap_or_else&lt;/code&gt; functions are the same in both cases: we print the error and exit.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 및 &lt;code&gt;unwrap_or_else&lt;/code&gt; 함수 의 본문은 두 경우 모두 동일합니다. 오류를 인쇄하고 종료합니다.</target>
        </trans-unit>
        <trans-unit id="a084bd821dcd5af3bead7d20966da99b85c8d3d6" translate="yes" xml:space="preserve">
          <source>The body of a &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/loop-expr#predicate-loops&quot;&gt;&lt;code&gt;while&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;expressions/loop-expr#infinite-loops&quot;&gt;&lt;code&gt;loop&lt;/code&gt;&lt;/a&gt; expression.</source>
          <target state="translated">&lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;expressions/loop-expr#predicate-loops&quot;&gt; &lt;code&gt;while&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;expressions/loop-expr#infinite-loops&quot;&gt; &lt;code&gt;loop&lt;/code&gt; &lt;/a&gt; 표현식 의 본문입니다 .</target>
        </trans-unit>
        <trans-unit id="8d22837f9a0a24391528e1a0b3b2365c1d2579bc" translate="yes" xml:space="preserve">
          <source>The body of the function starts by calling the &lt;code&gt;File::open&lt;/code&gt; function. Then we handle the &lt;code&gt;Result&lt;/code&gt; value returned with a &lt;code&gt;match&lt;/code&gt; similar to the &lt;code&gt;match&lt;/code&gt; in Listing 9-4, only instead of calling &lt;code&gt;panic!&lt;/code&gt; in the &lt;code&gt;Err&lt;/code&gt; case, we return early from this function and pass the error value from &lt;code&gt;File::open&lt;/code&gt; back to the calling code as this function&amp;rsquo;s error value. If &lt;code&gt;File::open&lt;/code&gt; succeeds, we store the file handle in the variable &lt;code&gt;f&lt;/code&gt; and continue.</source>
          <target state="translated">함수의 본문은 &lt;code&gt;File::open&lt;/code&gt; 함수를 호출하여 시작 합니다. 그런 다음 &lt;code&gt;panic!&lt;/code&gt; 을 호출하는 대신 목록 9-4 의 &lt;code&gt;match&lt;/code&gt; &lt;code&gt;match&lt;/code&gt; 유사한 일치 로 반환 된 &lt;code&gt;Result&lt;/code&gt; 값 을 처리합니다 ! 에 &lt;code&gt;Err&lt;/code&gt; 경우, 우리는 초기에이 함수의 반환과에서 오류 값에 합격 &lt;code&gt;File::open&lt;/code&gt; 이 기능의 오류 값으로 호출 코드에 다시. 경우 &lt;code&gt;File::open&lt;/code&gt; 성공, 우리는 변수에 파일 핸들을 저장 &lt;code&gt;f&lt;/code&gt; 계속.</target>
        </trans-unit>
        <trans-unit id="9ba4d0e4523a23a56b57272682f48b03a790c657" translate="yes" xml:space="preserve">
          <source>The body of the method would use &lt;code&gt;self&lt;/code&gt; to get the value that we called the method on. In this example, we&amp;rsquo;ve created a variable &lt;code&gt;m&lt;/code&gt; that has the value &lt;code&gt;Message::Write(String::from(&quot;hello&quot;))&lt;/code&gt;, and that is what &lt;code&gt;self&lt;/code&gt; will be in the body of the &lt;code&gt;call&lt;/code&gt; method when &lt;code&gt;m.call()&lt;/code&gt; runs.</source>
          <target state="translated">메소드의 본문은 &lt;code&gt;self&lt;/code&gt; 를 사용 하여 메소드를 호출 한 값을 얻습니다. 이 예제에서, 우리는 변수 만든 &lt;code&gt;m&lt;/code&gt; 값이 &lt;code&gt;Message::Write(String::from(&quot;hello&quot;))&lt;/code&gt; , 그리고 그 무엇인가 &lt;code&gt;self&lt;/code&gt; 의 몸에있을 것이다 &lt;code&gt;call&lt;/code&gt; 할 때 방법 &lt;code&gt;m.call()&lt;/code&gt; 가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9c00fd6128e2bdd1cc90bd415df84de85499f4fb" translate="yes" xml:space="preserve">
          <source>The book &lt;em&gt;Design Patterns: Elements of Reusable Object-Oriented Software&lt;/em&gt; by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley Professional, 1994) colloquially referred to as &lt;em&gt;The Gang of Four&lt;/em&gt; book, is a catalog of object-oriented design patterns. It defines OOP this way:</source>
          <target state="translated">Erich Gamma, Richard Helm, Ralph Johnson 및 John Vlissides (Addison-Wesley Professional, 1994) 의 책 &lt;em&gt;Design Patterns : Reusable Object-Oriented Software의 요소는&lt;/em&gt; 구어 ( &lt;em&gt;The Gang of Four)의&lt;/em&gt; 책 이라고 불리며 , 객체 지향 카탈로그입니다. 디자인 패턴. 다음과 같이 OOP를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0ab81c05a8d6cbaec3e9dfb9c8caa2a16dab19bf" translate="yes" xml:space="preserve">
          <source>The boolean type.</source>
          <target state="translated">부울 유형입니다.</target>
        </trans-unit>
        <trans-unit id="06283747a377154700dbba912c9e77d60011a87e" translate="yes" xml:space="preserve">
          <source>The borrow lasts until the returned &lt;code&gt;Ref&lt;/code&gt; exits scope. Multiple immutable borrows can be taken out at the same time.</source>
          <target state="translated">대여는 반환 된 &lt;code&gt;Ref&lt;/code&gt; 가 범위를 종료 할 때까지 지속됩니다 . 여러 불변의 차용을 동시에 꺼낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45376451530857b96a10ec4a5e20bb51cfc0ed12" translate="yes" xml:space="preserve">
          <source>The borrow lasts until the returned &lt;code&gt;RefMut&lt;/code&gt; or all &lt;code&gt;RefMut&lt;/code&gt;s derived from it exit scope. The value cannot be borrowed while this borrow is active.</source>
          <target state="translated">대여는 반환 된 &lt;code&gt;RefMut&lt;/code&gt; 또는 &lt;code&gt;RefMut&lt;/code&gt; 부터 파생 된 모든 RefMut 이 종료 범위 까지 지속됩니다 . 이 빌림이 활성화되어있는 동안에는 값을 빌릴 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f968733bf846dacfb002493e18e27a27864a5d95" translate="yes" xml:space="preserve">
          <source>The buffer is written out before returning the writer.</source>
          <target state="translated">버퍼는 기록기를 반환하기 전에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="8d2f5c9c4df44bd26200b02c526dd9675a0b62ea" translate="yes" xml:space="preserve">
          <source>The buffer specified was 0 bytes in length.</source>
          <target state="translated">지정된 버퍼 길이는 0 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="aac2e47b3535d051db39f7a14fa1dba18fc6a121" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;cfg&lt;/code&gt; macro takes in a single configuration predicate and evaluates to the &lt;code&gt;true&lt;/code&gt; literal when the predicate is true and the &lt;code&gt;false&lt;/code&gt; literal when it is false.</source>
          <target state="translated">내장 된 &lt;code&gt;cfg&lt;/code&gt; 매크로는 단일 구성 조건 및 평가하여 취하는 &lt;code&gt;true&lt;/code&gt; 술어가 사실 때 문자 &lt;code&gt;false&lt;/code&gt; 이 거짓 일 때 리터럴.</target>
        </trans-unit>
        <trans-unit id="87ae881f172e3eab463a1dba119d942ed8deaed7" translate="yes" xml:space="preserve">
          <source>The built-in attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;code&gt;path&lt;/code&gt;, and &lt;code&gt;no_implicit_prelude&lt;/code&gt;. Modules also accept macro attributes.</source>
          <target state="translated">함수에 의미가있는 내장 속성은 &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lint check 속성&lt;/a&gt; , &lt;code&gt;path&lt;/code&gt; 및 &lt;code&gt;no_implicit_prelude&lt;/code&gt; 입니다. 모듈은 매크로 속성도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="0658caeac4e6cc6250807a10a1d1127da8f7b8cb" translate="yes" xml:space="preserve">
          <source>The built-in attributes that have meaning on a module are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;code&gt;path&lt;/code&gt;, and &lt;code&gt;no_implicit_prelude&lt;/code&gt;. Modules also accept macro attributes.</source>
          <target state="translated">모듈에서 의미가있는 내장 속성은 &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lint 검사 속성&lt;/a&gt; , &lt;code&gt;path&lt;/code&gt; 및 &lt;code&gt;no_implicit_prelude&lt;/code&gt; 입니다. 모듈은 매크로 속성도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="7917b1e20d5567c345241cec71cc654edebdd434" translate="yes" xml:space="preserve">
          <source>The built-in function traits are generic over a tuple of the function arguments. If one uses angle-bracket notation (&lt;code&gt;Fn&amp;lt;(T,), Output=U&amp;gt;&lt;/code&gt;) instead of parentheses (&lt;code&gt;Fn(T) -&amp;gt; U&lt;/code&gt;) to denote the function trait, the type parameter should be a tuple. Otherwise function call notation cannot be used and the trait will not be implemented by closures.</source>
          <target state="translated">내장 함수 특성은 함수 인수의 튜플에 일반적입니다. 함수 특성을 나타 내기 위해 괄호 ( &lt;code&gt;Fn(T) -&amp;gt; U&lt;/code&gt; ) 대신 꺾쇠 괄호 표기법 ( &lt;code&gt;Fn&amp;lt;(T,), Output=U&amp;gt;&lt;/code&gt; )을 사용하는 경우 유형 매개 변수는 튜플이어야합니다. 그렇지 않으면 함수 호출 표기법을 사용할 수 없으며 특성이 클로저로 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9e1ef14ad9c5016cccb06e0dae0b41ca0441837" translate="yes" xml:space="preserve">
          <source>The c-main function only supports to return integers as return type. So, every type implementing the &lt;code&gt;Termination&lt;/code&gt; trait has to be converted to an integer.</source>
          <target state="translated">c-main 함수는 정수를 반환 유형으로 반환 만 지원합니다. 따라서 &lt;code&gt;Termination&lt;/code&gt; 특성을 구현하는 모든 유형 은 정수로 변환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="98a1e057ef0866ad400391fbf23a2daa11b28012" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;lock&lt;/code&gt; would fail if another thread holding the lock panicked. In that case, no one would ever be able to get the lock, so we&amp;rsquo;ve chosen to &lt;code&gt;unwrap&lt;/code&gt; and have this thread panic if we&amp;rsquo;re in that situation.</source>
          <target state="translated">&lt;code&gt;lock&lt;/code&gt; 을 잡고있는 다른 스레드가 당황한 경우 잠금 호출 이 실패합니다. 이 경우 아무도 잠금을 &lt;code&gt;unwrap&lt;/code&gt; 할 수 없으므로 상황에 처한 경우이 스레드 를 풀고 패닉 상태 로 만들었습니다 .</target>
        </trans-unit>
        <trans-unit id="a399c55a0729e88865a33bb045bf002d26006429" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;panic!&lt;/code&gt; causes the error message contained in the last two lines. The first line shows our panic message and the place in our source code where the panic occurred: &lt;em&gt;src/main.rs:2:5&lt;/em&gt; indicates that it&amp;rsquo;s the second line, fifth character of our &lt;em&gt;src/main.rs&lt;/em&gt; file.</source>
          <target state="translated">&lt;code&gt;panic!&lt;/code&gt; 전화 ! 마지막 두 줄에 포함 된 오류 메시지가 발생합니다. 첫 번째 줄은 패닉 메시지와 패닉이 발생한 소스 코드의 위치를 ​​보여줍니다. &lt;em&gt;src / main.rs : 2 : 5&lt;/em&gt; 는 이것이 &lt;em&gt;src / main.rs&lt;/em&gt; 파일 의 다섯 번째 문자 인 두 번째 &lt;em&gt;줄임을&lt;/em&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="76991560cfa9d5bcd0a2eea05c7ac9259a741680" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;parse&lt;/code&gt; could easily cause an error. If, for example, the string contained &lt;code&gt;A👍%&lt;/code&gt;, there would be no way to convert that to a number. Because it might fail, the &lt;code&gt;parse&lt;/code&gt; method returns a &lt;code&gt;Result&lt;/code&gt; type, much as the &lt;code&gt;read_line&lt;/code&gt; method does (discussed earlier in &lt;a href=&quot;#handling-potential-failure-with-the-result-type&quot;&gt;&amp;ldquo;Handling Potential Failure with the &lt;code&gt;Result&lt;/code&gt; Type&amp;rdquo;&lt;/a&gt;). We&amp;rsquo;ll treat this &lt;code&gt;Result&lt;/code&gt; the same way by using the &lt;code&gt;expect&lt;/code&gt; method again. If &lt;code&gt;parse&lt;/code&gt; returns an &lt;code&gt;Err&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; variant because it couldn&amp;rsquo;t create a number from the string, the &lt;code&gt;expect&lt;/code&gt; call will crash the game and print the message we give it. If &lt;code&gt;parse&lt;/code&gt; can successfully convert the string to a number, it will return the &lt;code&gt;Ok&lt;/code&gt; variant of &lt;code&gt;Result&lt;/code&gt;, and &lt;code&gt;expect&lt;/code&gt; will return the number that we want from the &lt;code&gt;Ok&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;parse&lt;/code&gt; 호출로 인해 쉽게 오류가 발생할 수 있습니다. 예를 들어 문자열에 &lt;code&gt;A👍%&lt;/code&gt; 포함되어 있으면 문자열 을 숫자로 변환 할 방법이 없습니다. 실패 할 수 있기 때문에 &lt;code&gt;parse&lt;/code&gt; 메소드는 &lt;code&gt;read_line&lt;/code&gt; 메소드 와 마찬가지로 &lt;code&gt;Result&lt;/code&gt; 유형을 리턴합니다 (이전의 &lt;a href=&quot;#handling-potential-failure-with-the-result-type&quot;&gt;&quot; &lt;/a&gt; &lt;code&gt;Result&lt;/code&gt; 유형으로 잠재적 실패 처리&quot; 에서 논의 됨 ). &lt;code&gt;expect&lt;/code&gt; 메소드를 다시 사용 하여이 &lt;code&gt;Result&lt;/code&gt; 를 같은 방식으로 처리합니다. 경우 &lt;code&gt;parse&lt;/code&gt; 반환 &lt;code&gt;Err&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; 변종이 (가) 문자열의 숫자를 생성 할 수 있기 때문에 &lt;code&gt;expect&lt;/code&gt; 호출은 게임을 중단시키고 우리가 제공 한 메시지를 인쇄합니다. 경우 &lt;code&gt;parse&lt;/code&gt; 성공적으로 문자열을 숫자로 변환 할 수 있습니다, 그것은 반환 &lt;code&gt;Ok&lt;/code&gt; 의 변형 &lt;code&gt;Result&lt;/code&gt; 및 &lt;code&gt;expect&lt;/code&gt; 으로부터 우리가 원하는 숫자를 반환 &lt;code&gt;Ok&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="7b69e26d39a3f8839842ab3c559f82019ca9b310" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;recv&lt;/code&gt; blocks, so if there is no job yet, the current thread will wait until a job becomes available. The &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; ensures that only one &lt;code&gt;Worker&lt;/code&gt; thread at a time is trying to request a job.</source>
          <target state="translated">&lt;code&gt;recv&lt;/code&gt; 에 대한 호출이 차단되므로 아직 작업이 없으면 현재 스레드는 작업을 사용할 수있을 때까지 기다립니다. &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 보장하지만 단 하나의 그 &lt;code&gt;Worker&lt;/code&gt; 한 번에 스레드가 작업을 요청하기 위해 노력하고있다.</target>
        </trans-unit>
        <trans-unit id="8993444f4968db6cec0c3f76e82220cf7def7574" translate="yes" xml:space="preserve">
          <source>The caller has to ensure that no references in the supplied thread closure or its return type can outlive the spawned thread's lifetime. This can be guaranteed in two ways:</source>
          <target state="translated">호출자는 제공된 스레드 클로저 또는 해당 반환 유형의 참조가 생성 된 스레드 수명보다 오래 걸리지 않도록해야합니다. 이것은 두 가지 방법으로 보장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="093036972d7bffcd0b16a57c6e2ba75deeb1dca1" translate="yes" xml:space="preserve">
          <source>The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use &lt;a href=&quot;#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">호출자는 또한 이 포인터 또는 그 포인터에서 파생 된 포인터를 사용하여 (비전 이적으로) 포인터가 가리키는 메모리가 ( &lt;code&gt;UnsafeCell&lt;/code&gt; 내부 제외 ) 쓰지 않도록해야합니다. 슬라이스의 내용을 변경해야하는 경우 &lt;a href=&quot;#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="fbd8e378206e5ebe48537e21894c0d0196aa5c37" translate="yes" xml:space="preserve">
          <source>The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use &lt;a href=&quot;struct.vec#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">호출자는 또한 포인터가 가리키는 메모리 (비전 이적) 가이 포인터 또는 그로부터 파생 된 포인터를 사용하여 ( &lt;code&gt;UnsafeCell&lt;/code&gt; 내부를 제외하고) 절대 기록되지 않도록해야합니다. 슬라이스의 내용을 변경해야하는 경우 &lt;a href=&quot;struct.vec#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2daa4ea0adccac77e0ee2e5186b78bccb935a23d" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the content of the slice is valid UTF-8 before the borrow ends and the underlying &lt;code&gt;str&lt;/code&gt; is used.</source>
          <target state="translated">호출자는 차용이 끝나고 기본 &lt;code&gt;str&lt;/code&gt; 이 사용 되기 전에 슬라이스의 내용이 유효한 UTF-8인지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ac3ada34e0728cb1a740ac35a9a92bd4109e42c8" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">호출자는 반환 된 포인터가 쓰여지지 않도록해야합니다. 문자열 슬라이스의 내용을 변경해야하는 경우 &lt;a href=&quot;#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c95ecf028004da1510b460935745006e917bea1" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;../primitive.str#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">호출자는 반환 된 포인터가 기록되지 않도록해야합니다. 문자열 슬라이스의 내용을 변경해야하는 경우 &lt;a href=&quot;../primitive.str#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="de2dba4a5088d0450aaa1d7584230c3882b4aa0e" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;primitive.str#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">호출자는 반환 된 포인터가 기록되지 않도록해야합니다. 문자열 슬라이스의 내용을 변경해야하는 경우 &lt;a href=&quot;primitive.str#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0392a3d2bc79f7cc36923d474ab5bb48f657c119" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the slice outlives the pointer this function returns, or else it will end up pointing to garbage.</source>
          <target state="translated">호출자는 슬라이스가이 함수가 반환하는 포인터보다 오래 지속되도록해야합니다. 그렇지 않으면 가비지를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="bf480a8080607d02f4b53d9ea9e935964787c02b" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the vector outlives the pointer this function returns, or else it will end up pointing to garbage. Modifying the vector may cause its buffer to be reallocated, which would also make any pointers to it invalid.</source>
          <target state="translated">호출자는 벡터가이 함수가 반환하는 포인터보다 오래 지속되도록해야합니다. 그렇지 않으면 가비지를 가리 킵니다. 벡터를 수정하면 버퍼가 재 할당 될 수 있으며 이에 대한 포인터도 유효하지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="09005f0066a1b73d30e33e09129bf20aee61c736" translate="yes" xml:space="preserve">
          <source>The calling thread will be blocked until there are no more writers which hold the lock. There may be other readers currently inside the lock when this method returns. This method does not provide any guarantees with respect to the ordering of whether contentious readers or writers will acquire the lock first.</source>
          <target state="translated">잠금을 보유한 더 이상 기록기가 없을 때까지 호출 스레드가 차단됩니다. 이 메소드가 리턴 될 때 현재 잠금 내부에 다른 리더가있을 수 있습니다. 이 방법은 논쟁적인 독자 또는 작가가 우선 잠금을 획득 할 것인지의 순서와 관련하여 어떠한 보장도 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c684d1da6df1a86528a2f3d33b0bb20fea3d352" translate="yes" xml:space="preserve">
          <source>The calls to &lt;code&gt;thread::sleep&lt;/code&gt; force a thread to stop its execution for a short duration, allowing a different thread to run. The threads will probably take turns, but that isn&amp;rsquo;t guaranteed: it depends on how your operating system schedules the threads. In this run, the main thread printed first, even though the print statement from the spawned thread appears first in the code. And even though we told the spawned thread to print until &lt;code&gt;i&lt;/code&gt; is 9, it only got to 5 before the main thread shut down.</source>
          <target state="translated">&lt;code&gt;thread::sleep&lt;/code&gt; 대한 호출은 스레드 가 짧은 시간 동안 실행을 중지하도록하여 다른 스레드가 실행될 수 있도록합니다. 스레드는 교대로 진행될 수 있지만 보장되지는 않습니다. 운영 체제가 스레드를 예약하는 방법에 따라 다릅니다. 이 실행에서는 생성 된 스레드의 인쇄 명령문이 코드에서 첫 번째로 표시 되더라도 기본 스레드가 먼저 인쇄됩니다. 그리고 우리가 &lt;code&gt;i&lt;/code&gt; 가 9가 될 때까지 스폰 된 스레드에 인쇄하도록 지시했지만 주 스레드가 종료되기 전에 5에 도달했습니다.</target>
        </trans-unit>
        <trans-unit id="c7560eebffb8ae3cdb259698d7be211bc4620b7e" translate="yes" xml:space="preserve">
          <source>The canonical ExitCode for successful termination on this platform.</source>
          <target state="translated">이 플랫폼에서 성공적인 종료를위한 표준 종료 코드입니다.</target>
        </trans-unit>
        <trans-unit id="8f6ef1b9ea50b970966541a96ea6f822d628893b" translate="yes" xml:space="preserve">
          <source>The canonical ExitCode for unsuccessful termination on this platform.</source>
          <target state="translated">이 플랫폼에서 종료에 실패한 표준 종료 코드입니다.</target>
        </trans-unit>
        <trans-unit id="edfe5292e463236ad7502b40af63d1dc3846bebd" translate="yes" xml:space="preserve">
          <source>The canonical path is only meaningful within a given crate. There is no global namespace across crates; an item's canonical path merely identifies it within the crate.</source>
          <target state="translated">정식 경로는 주어진 상자 내에서만 의미가 있습니다. 상자에 전역 네임 스페이스가 없습니다. 품목의 정식 경로는 상자 내에서 단순히 항목을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="42b8d1ea1b4247711765802c026fc2d790b1362d" translate="yes" xml:space="preserve">
          <source>The canonical safe use of &lt;code&gt;mem::forget&lt;/code&gt; is to circumvent a value's destructor implemented by the &lt;code&gt;Drop&lt;/code&gt; trait. For example, this will leak a &lt;code&gt;File&lt;/code&gt;, i.e. reclaim the space taken by the variable but never close the underlying system resource:</source>
          <target state="translated">&lt;code&gt;mem::forget&lt;/code&gt; 의 표준 안전한 사용은 &lt;code&gt;Drop&lt;/code&gt; 특성에 의해 구현 된 값의 소멸자를 우회하는 것 입니다 . 예를 들어, 이것은 &lt;code&gt;File&lt;/code&gt; 을 누출합니다 . 즉, 변수가 차지하는 공간을 되찾지 만 기본 시스템 리소스를 닫지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1aa3ddcbed06fec001e59bb6f3f1f1da2ef18ef6" translate="yes" xml:space="preserve">
          <source>The capacity may be increased by more than &lt;code&gt;additional&lt;/code&gt; bytes if it chooses, to prevent frequent reallocations.</source>
          <target state="translated">빈번한 재 할당을 방지하기 위해 원하는 경우 용량을 &lt;code&gt;additional&lt;/code&gt; 바이트 이상 늘릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e527152d8f3ca4ddc869842d5ee9ae2a46a82fb" translate="yes" xml:space="preserve">
          <source>The capacity of a vector is the amount of space allocated for any future elements that will be added onto the vector. This is not to be confused with the &lt;em&gt;length&lt;/em&gt; of a vector, which specifies the number of actual elements within the vector. If a vector's length exceeds its capacity, its capacity will automatically be increased, but its elements will have to be reallocated.</source>
          <target state="translated">벡터의 용량은 벡터에 추가 될 향후 요소에 할당 된 공간의 양입니다. 이것은 벡터 내의 실제 요소의 수를 지정하는 벡터 의 &lt;em&gt;길이&lt;/em&gt; 와 혼동되어서는 안됩니다 . 벡터의 길이가 용량을 초과하면 용량이 자동으로 증가하지만 요소를 재 할당해야합니다.</target>
        </trans-unit>
        <trans-unit id="a70fb21498dabd7b592b7614b4af0ad2efc52b05" translate="yes" xml:space="preserve">
          <source>The capacity will remain at least as large as both the length and the supplied value.</source>
          <target state="translated">용량은 최소한 길이와 제공된 값보다 크게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="f2f4d42ff0e5eed287aac391d229f38ad7615e31" translate="yes" xml:space="preserve">
          <source>The captured values of a &lt;a href=&quot;types/closure&quot;&gt;closure&lt;/a&gt; are dropped in an unspecified order.</source>
          <target state="translated">&lt;a href=&quot;types/closure&quot;&gt;클로저&lt;/a&gt; 의 캡처 된 값은 지정되지 않은 순서로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="138edd42fa740c68b92f8f2886d9a7cfd608a2f8" translate="yes" xml:space="preserve">
          <source>The changes we needed to make to &lt;code&gt;main&lt;/code&gt; to reassign &lt;code&gt;post&lt;/code&gt; mean that this implementation doesn&amp;rsquo;t quite follow the object-oriented state pattern anymore: the transformations between the states are no longer encapsulated entirely within the &lt;code&gt;Post&lt;/code&gt; implementation. However, our gain is that invalid states are now impossible because of the type system and the type checking that happens at compile time! This ensures that certain bugs, such as display of the content of an unpublished post, will be discovered before they make it to production.</source>
          <target state="translated">우리가 만드는 데 필요한 변경 &lt;code&gt;main&lt;/code&gt; 재 할당 &lt;code&gt;post&lt;/code&gt; 상태 사이의 변환이 더 이상 전적으로 내에서 캡슐화 :이 구현은 상당히 더 이상 객체 지향 상태의 패턴을 따라하지 않는 것을 의미 &lt;code&gt;Post&lt;/code&gt; 구현을. 그러나 우리의 이득은 타입 시스템과 컴파일 타임에 발생하는 타입 검사로 인해 무효 상태가 불가능하다는 것입니다! 이렇게하면 게시되지 않은 게시물의 내용 표시와 같은 특정 버그가 프로덕션에 적용되기 전에 발견 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c6978553f5d9c2a253b6007e164ab1e1253e787" translate="yes" xml:space="preserve">
          <source>The character represented by this escape</source>
          <target state="translated">이 탈출로 대표되는 캐릭터</target>
        </trans-unit>
        <trans-unit id="444f11cad1e3ea489affb1093e4cfe00aec033b8" translate="yes" xml:space="preserve">
          <source>The character type, &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">문자 유형, &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2ab8aadbe1c6203ddb8254dc62679ad2d0d6a50" translate="yes" xml:space="preserve">
          <source>The child inherits from the corresponding parent descriptor.</source>
          <target state="translated">자식은 해당 부모 설명자에서 상속합니다.</target>
        </trans-unit>
        <trans-unit id="57f64da60a0aae4c7ca65b39d52634b157698777" translate="yes" xml:space="preserve">
          <source>The chunks are array references and do not overlap. If &lt;code&gt;N&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">청크는 배열 참조이며 겹치지 않습니다. 경우 &lt;code&gt;N&lt;/code&gt; 은 슬라이스의 길이에 그 마지막 나눌 않는 &lt;code&gt;N-1&lt;/code&gt; 생략한다 요소를 상기에서 검색 할 수 &lt;code&gt;remainder&lt;/code&gt; 반복기의 기능.</target>
        </trans-unit>
        <trans-unit id="15fa38fbe64a63fe95b52b94271d4ba554613043" translate="yes" xml:space="preserve">
          <source>The chunks are mutable array references and do not overlap. If &lt;code&gt;N&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;into_remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">청크는 가변 배열 참조이며 겹치지 않습니다. 경우 &lt;code&gt;N&lt;/code&gt; 은 슬라이스의 길이에 그 마지막 나눌 않는 &lt;code&gt;N-1&lt;/code&gt; 생략한다 요소를 상기에서 검색 할 수 &lt;code&gt;into_remainder&lt;/code&gt; 의 반복기의 기능.</target>
        </trans-unit>
        <trans-unit id="22f36eeee32622c7a505cef344bfce71a990d798" translate="yes" xml:space="preserve">
          <source>The chunks are mutable slices, and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last chunk will not have length &lt;code&gt;chunk_size&lt;/code&gt;.</source>
          <target state="translated">청크는 변경 가능한 슬라이스이며 겹치지 않습니다. 경우 &lt;code&gt;chunk_size&lt;/code&gt; 슬라이스의 길이를 분할하지 않고, 다음 마지막 청크 길이가 없습니다 &lt;code&gt;chunk_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a56cc46096f73dcb9c3581ef24840c1b8a52d3e3" translate="yes" xml:space="preserve">
          <source>The chunks are mutable slices, and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;into_remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">청크는 가변 슬라이스이며 겹치지 않습니다. 경우 &lt;code&gt;chunk_size&lt;/code&gt; 슬라이스의 길이를 분할하지 않고, 그 최종 업 할 &lt;code&gt;chunk_size-1&lt;/code&gt; 요소는 생략되며로부터 검색 될 수 &lt;code&gt;into_remainder&lt;/code&gt; 의 반복기의 기능.</target>
        </trans-unit>
        <trans-unit id="b9b82e1f955649f5c987c92e4ad59440a3cb7655" translate="yes" xml:space="preserve">
          <source>The chunks are slices and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last chunk will not have length &lt;code&gt;chunk_size&lt;/code&gt;.</source>
          <target state="translated">청크는 슬라이스이며 겹치지 않습니다. 경우 &lt;code&gt;chunk_size&lt;/code&gt; 슬라이스의 길이를 분할하지 않고, 다음 마지막 청크 길이가 없습니다 &lt;code&gt;chunk_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93ee6025794c31565e33ecdc52225cb4e18501bf" translate="yes" xml:space="preserve">
          <source>The chunks are slices and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">청크는 슬라이스이며 겹치지 않습니다. 경우 &lt;code&gt;chunk_size&lt;/code&gt; 슬라이스의 길이를 분할하지 않고, 그 최종 업 할 &lt;code&gt;chunk_size-1&lt;/code&gt; 요소는 생략되며로부터 검색 될 수있는 &lt;code&gt;remainder&lt;/code&gt; 반복기의 기능.</target>
        </trans-unit>
        <trans-unit id="5ab8cfd0030cc999866ad155de372dfc9a291653" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; is yielded a &lt;a href=&quot;struct.oncestate&quot;&gt;&lt;code&gt;OnceState&lt;/code&gt;&lt;/a&gt; structure which can be used to query the poison status of the &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">클로저 &lt;code&gt;f&lt;/code&gt; 는 &lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt; 의 포이즌 상태를 쿼리하는 데 사용할 수 있는 &lt;a href=&quot;struct.oncestate&quot;&gt; &lt;code&gt;OnceState&lt;/code&gt; &lt;/a&gt; 구조를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="8464cb339a91ac7f9edf87e86826287afbdde678" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; is yielded a &lt;a href=&quot;struct.oncestate&quot;&gt;&lt;code&gt;OnceState&lt;/code&gt;&lt;/a&gt; structure which can be used to query the poison status of the &lt;code&gt;Once&lt;/code&gt;.</source>
          <target state="translated">클로저 &lt;code&gt;f&lt;/code&gt; 는 &lt;code&gt;Once&lt;/code&gt; 의 포이즌 상태를 쿼리하는 데 사용할 수 있는 &lt;a href=&quot;struct.oncestate&quot;&gt; &lt;code&gt;OnceState&lt;/code&gt; &lt;/a&gt; 구조를 산출합니다 .</target>
        </trans-unit>
        <trans-unit id="6122336d1e3dc25f0e6a48ca5c6617d72884ddeb" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; will only be executed once if this is called concurrently amongst many threads. If that closure panics, however, then it will &lt;em&gt;poison&lt;/em&gt; this &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; instance, causing all future invocations of &lt;code&gt;call_once&lt;/code&gt; to also panic.</source>
          <target state="translated">클로저 &lt;code&gt;f&lt;/code&gt; 는 여러 스레드에서 동시에 호출되는 경우 한 번만 실행됩니다. 그 폐쇄 패닉 경우, 그러나, 그것은 것입니다 &lt;em&gt;중독&lt;/em&gt; 이 &lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt; 이후의 모든 호출의 원인, 예를 &lt;code&gt;call_once&lt;/code&gt; 을 또한 공황에.</target>
        </trans-unit>
        <trans-unit id="1151c6060a40c30d933870c684e8f8c1c9ce7a79" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; will only be executed once if this is called concurrently amongst many threads. If that closure panics, however, then it will &lt;em&gt;poison&lt;/em&gt; this &lt;code&gt;Once&lt;/code&gt; instance, causing all future invocations of &lt;code&gt;call_once&lt;/code&gt; to also panic.</source>
          <target state="translated">클로저 &lt;code&gt;f&lt;/code&gt; 는 여러 스레드에서 동시에 호출되는 경우 한 번만 실행됩니다. 그러나 해당 폐쇄 패닉 이 발생 &lt;code&gt;Once&lt;/code&gt; 이 Once 인스턴스 를 &lt;em&gt;중독&lt;/em&gt; 시켜 향후 &lt;code&gt;call_once&lt;/code&gt; 호출이 모두 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="9a9ae7f6f31f6430eeec94354c414e42d745c712" translate="yes" xml:space="preserve">
          <source>The closure can use captures and its environment to track state across iterations. Depending on how the iterator is used, this may require specifying the &lt;a href=&quot;../keyword.move&quot;&gt;&lt;code&gt;move&lt;/code&gt;&lt;/a&gt; keyword on the closure.</source>
          <target state="translated">클로저는 캡처 및 해당 환경을 사용하여 반복에서 상태를 추적 할 수 있습니다. 반복기가 사용되는 방법 에 따라 클로저에 &lt;a href=&quot;../keyword.move&quot;&gt; &lt;code&gt;move&lt;/code&gt; &lt;/a&gt; 키워드를 지정해야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbba645c0f92459c3e584dd2aad4e56b6422ddeb" translate="yes" xml:space="preserve">
          <source>The closure can use captures and its environment to track state across iterations. Depending on how the iterator is used, this may require specifying the &lt;code&gt;move&lt;/code&gt; keyword on the closure.</source>
          <target state="translated">클로저는 캡처와 해당 환경을 사용하여 반복에서 상태를 추적 할 수 있습니다. 반복자가 사용되는 방식 에 따라 클로저에 &lt;code&gt;move&lt;/code&gt; 키워드를 지정해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e57e2087c6fad9eaa8a18bdb745b2ddd95bd84c" translate="yes" xml:space="preserve">
          <source>The closure captures the &lt;code&gt;shoe_size&lt;/code&gt; parameter from the environment and compares the value with each shoe&amp;rsquo;s size, keeping only shoes of the size specified. Finally, calling &lt;code&gt;collect&lt;/code&gt; gathers the values returned by the adapted iterator into a vector that&amp;rsquo;s returned by the function.</source>
          <target state="translated">클로저는 환경에서 &lt;code&gt;shoe_size&lt;/code&gt; 매개 변수를 캡처하고 지정된 크기의 신발 만 유지하면서 각 신발의 크기와 값을 비교합니다. 마지막으로 &lt;code&gt;collect&lt;/code&gt; 를 호출 하면 수정 된 반복자가 반환 한 값을 함수가 반환 한 벡터로 수집합니다.</target>
        </trans-unit>
        <trans-unit id="0112db2feb7312ad3c6512257c24783293514225" translate="yes" xml:space="preserve">
          <source>The closure definition comes after the &lt;code&gt;=&lt;/code&gt; to assign it to the variable &lt;code&gt;expensive_closure&lt;/code&gt;. To define a closure, we start with a pair of vertical pipes (&lt;code&gt;|&lt;/code&gt;), inside which we specify the parameters to the closure; this syntax was chosen because of its similarity to closure definitions in Smalltalk and Ruby. This closure has one parameter named &lt;code&gt;num&lt;/code&gt;: if we had more than one parameter, we would separate them with commas, like &lt;code&gt;|param1, param2|&lt;/code&gt;.</source>
          <target state="translated">클로저 정의는 &lt;code&gt;=&lt;/code&gt; 다음에 와서 변수 &lt;code&gt;expensive_closure&lt;/code&gt; 에 할당합니다 . 클로저를 정의하기 위해 클로저에 대한 매개 변수를 지정 하는 한 쌍의 수직 파이프 ( &lt;code&gt;|&lt;/code&gt; )로 시작합니다. 이 구문은 Smalltalk 및 Ruby의 클로저 정의와 유사하기 때문에 선택되었습니다. 이 클로저에는 &lt;code&gt;num&lt;/code&gt; 이라는 하나의 매개 변수가 있습니다. 하나 이상의 매개 변수가 있으면 &lt;code&gt;|param1, param2|&lt;/code&gt; 와 같이 쉼표로 구분합니다. .</target>
        </trans-unit>
        <trans-unit id="1b467eb6733245bc29dea650b68390c954774c96" translate="yes" xml:space="preserve">
          <source>The closure is allowed to return an I/O error whose OS error code will be communicated back to the parent and returned as an error from when the spawn was requested.</source>
          <target state="translated">클로저는 OS 에러 코드가 부모에게 다시 전달되고 스폰이 요청되었을 때의 에러로 반환되는 I / O 에러를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d07950c5510607459c97a1e9bf4b42e15a155b7" translate="yes" xml:space="preserve">
          <source>The closure must return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;filter()&lt;/code&gt; creates an iterator which calls this closure on each element. If the closure returns &lt;code&gt;true&lt;/code&gt;, then the element is returned. If the closure returns &lt;code&gt;false&lt;/code&gt;, it will try again, and call the closure on the next element, seeing if it passes the test.</source>
          <target state="translated">클로저는 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 를 반환해야합니다 . &lt;code&gt;filter()&lt;/code&gt; 는 각 요소에서이 클로저를 호출하는 반복자를 만듭니다. 클로저가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 요소가 반환됩니다. 클로저가 &lt;code&gt;false&lt;/code&gt; 를 반환하면 다시 시도하고 다음 요소에서 클로저를 호출하여 테스트를 통과했는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="0dfbb8ddc807c0ec7e308a6bcf0502df62203387" translate="yes" xml:space="preserve">
          <source>The closure must return an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;filter_map&lt;/code&gt; creates an iterator which calls this closure on each element. If the closure returns &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(element)&lt;/code&gt;&lt;/a&gt;, then that element is returned. If the closure returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, it will try again, and call the closure on the next element, seeing if it will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">클로저는 &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 반환해야합니다 . &lt;code&gt;filter_map&lt;/code&gt; 은 각 요소에서이 클로저를 호출하는 반복자를 만듭니다. 클로저가 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(element)&lt;/code&gt; &lt;/a&gt; 반환하면 해당 요소가 반환됩니다. 클로저가 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환하면 다시 시도하고 다음 요소에서 클로저를 호출하여 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; 이 반환되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="7a4c6af8980cc5834794f8ba584bb6cebd16567c" translate="yes" xml:space="preserve">
          <source>The closure provided is required to adhere to the &lt;a href=&quot;trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt; trait to ensure that all captured variables are safe to cross this boundary. The purpose of this bound is to encode the concept of &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;exception safety&lt;/a&gt; in the type system. Most usage of this function should not need to worry about this bound as programs are naturally unwind safe without &lt;code&gt;unsafe&lt;/code&gt; code. If it becomes a problem the &lt;a href=&quot;struct.assertunwindsafe&quot;&gt;&lt;code&gt;AssertUnwindSafe&lt;/code&gt;&lt;/a&gt; wrapper struct can be used to quickly assert that the usage here is indeed unwind safe.</source>
          <target state="translated">제공된 폐쇄는 &lt;a href=&quot;trait.unwindsafe&quot;&gt; &lt;code&gt;UnwindSafe&lt;/code&gt; &lt;/a&gt; 특성 을 준수하여 캡처 된 모든 변수가이 경계를 안전하게 통과 할 수 있도록해야합니다. 이 범위의 목적은 형식 시스템에서 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;예외 안전&lt;/a&gt; 개념을 인코딩하는 것입니다 . 프로그램이 안전하지 &lt;code&gt;unsafe&lt;/code&gt; 코드 없이 자연스럽게 안전하기 때문에이 기능의 대부분의 사용은이 한계에 대해 걱정할 필요가 없습니다 . 이것이 문제가 &lt;a href=&quot;struct.assertunwindsafe&quot;&gt; &lt;code&gt;AssertUnwindSafe&lt;/code&gt; &lt;/a&gt; 래퍼 구조체를 사용하여 여기에서 사용법이 실제로 안전하다는 것을 신속하게 주장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1db2515eb35827d3b48808ed11db89506d167098" translate="yes" xml:space="preserve">
          <source>The closure uses &lt;code&gt;v&lt;/code&gt;, so it will capture &lt;code&gt;v&lt;/code&gt; and make it part of the closure&amp;rsquo;s environment. Because &lt;code&gt;thread::spawn&lt;/code&gt; runs this closure in a new thread, we should be able to access &lt;code&gt;v&lt;/code&gt; inside that new thread. But when we compile this example, we get the following error:</source>
          <target state="translated">폐쇄의 용도는 &lt;code&gt;v&lt;/code&gt; 에 이 포착 있도록, &lt;code&gt;v&lt;/code&gt; 과 폐쇄의 환경의 일부합니다. 때문에 &lt;code&gt;thread::spawn&lt;/code&gt; 새 스레드에서이 폐쇄를 실행, 우리는 액세스 할 수 있어야 &lt;code&gt;v&lt;/code&gt; 가 새로운 스레드 내부. 그러나이 예제를 컴파일하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d7aca11a6ac0f9ea5173acf1c9757981e77e687c" translate="yes" xml:space="preserve">
          <source>The code associated with each arm is an expression, and the resulting value of the expression in the matching arm is the value that gets returned for the entire &lt;code&gt;match&lt;/code&gt; expression.</source>
          <target state="translated">각 팔과 관련된 코드는 표현식이며 일치하는 팔의 표현식 결과 값은 전체 &lt;code&gt;match&lt;/code&gt; 표현식에 대해 반환되는 값입니다 .</target>
        </trans-unit>
        <trans-unit id="86ec55efa28e5ccc120a1f5241fba708e750dd58" translate="yes" xml:space="preserve">
          <source>The code in Listing 13-17 doesn&amp;rsquo;t do anything; the closure we&amp;rsquo;ve specified never gets called. The warning reminds us why: iterator adaptors are lazy, and we need to consume the iterator here.</source>
          <target state="translated">Listing 13-17의 코드는 아무것도하지 않는다. 우리가 지정한 클로저는 결코 호출되지 않습니다. 경고는 이유를 알려줍니다. 이터레이터 어댑터가 게으 르며 여기에서 이터레이터를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="27595e3e42c890c6fdee5b82c7f1d2b1399713f0" translate="yes" xml:space="preserve">
          <source>The code in Listing 13-3 has multiple calls to the slow calculation function. The first &lt;code&gt;if&lt;/code&gt; block calls &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; twice, the &lt;code&gt;if&lt;/code&gt; inside the outer &lt;code&gt;else&lt;/code&gt; doesn&amp;rsquo;t call it at all, and the code inside the second &lt;code&gt;else&lt;/code&gt; case calls it once.</source>
          <target state="translated">코드 13-3의 코드에는 느린 계산 함수를 여러 번 호출했습니다. 첫 번째 &lt;code&gt;if&lt;/code&gt; 블록 통화 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 두 배의 &lt;code&gt;if&lt;/code&gt; 외부 내부에 &lt;code&gt;else&lt;/code&gt; 전혀 호출하지 않으며, 제 2 내측 코드 &lt;code&gt;else&lt;/code&gt; 경우가 한 번 호출합니다.</target>
        </trans-unit>
        <trans-unit id="984f7b754ab17440aa0c07b718b002aed1594b7a" translate="yes" xml:space="preserve">
          <source>The code in Listing 16-1 not only stops the spawned thread prematurely most of the time due to the main thread ending, but also can&amp;rsquo;t guarantee that the spawned thread will get to run at all. The reason is that there is no guarantee on the order in which threads run!</source>
          <target state="translated">Listing 16-1의 코드는 메인 스레드 종료로 인해 생성 된 스레드를 대부분 조기에 중지 할뿐만 아니라 생성 된 스레드가 전혀 실행되지 않을 수도 있습니다. 스레드 실행 순서가 보장되지 않기 때문입니다!</target>
        </trans-unit>
        <trans-unit id="4d5adfd375cd377b4763e2eeee96a84687acf4e5" translate="yes" xml:space="preserve">
          <source>The code in Listing 16-8 compiled and ran, but it didn&amp;rsquo;t clearly show us that two separate threads were talking to each other over the channel. In Listing 16-10 we&amp;rsquo;ve made some modifications that will prove the code in Listing 16-8 is running concurrently: the spawned thread will now send multiple messages and pause for a second between each message.</source>
          <target state="translated">Listing 16-8의 코드는 컴파일되어 실행되었지만 두 개의 개별 스레드가 채널을 통해 서로 대화하고 있음을 명확하게 보여주지는 못했다. Listing 16-10에서는 Listing 16-8의 코드가 동시에 실행되고 있음을 나타내는 몇 가지 수정 사항이있다. 스폰 된 스레드는 이제 여러 메시지를 보내고 각 메시지 사이에서 1 초 동안 일시 정지한다.</target>
        </trans-unit>
        <trans-unit id="9e7e0566bf3de2c83a460b61c17bb70770c4b1c5" translate="yes" xml:space="preserve">
          <source>The code in Listing 18-1 shows a series of checks for several conditions that decide what the background color should be. For this example, we&amp;rsquo;ve created variables with hardcoded values that a real program might receive from user input.</source>
          <target state="translated">목록 18-1의 코드는 배경색을 결정하는 몇 가지 조건에 대한 일련의 검사를 보여줍니다. 이 예에서는 실제 프로그램이 사용자 입력으로부터 수신 할 수있는 하드 코드 된 값으로 변수를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="c12405c78a2c0d83f529e2201871e22f52a8474e" translate="yes" xml:space="preserve">
          <source>The code in Listing 18-3 will print the following:</source>
          <target state="translated">목록 18-3의 코드는 다음을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="efe51698d475c0b9864955b57e12d5b79c9bbf35" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-14 will compile but doesn&amp;rsquo;t create any threads yet. We&amp;rsquo;ve changed the definition of &lt;code&gt;ThreadPool&lt;/code&gt; to hold a vector of &lt;code&gt;thread::JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances, initialized the vector with a capacity of &lt;code&gt;size&lt;/code&gt;, set up a &lt;code&gt;for&lt;/code&gt; loop that will run some code to create the threads, and returned a &lt;code&gt;ThreadPool&lt;/code&gt; instance containing them.</source>
          <target state="translated">Listing 20-14의 코드는 컴파일되지만 아직 스레드를 생성하지는 않는다. 우리의 정의 변경했습니다 &lt;code&gt;ThreadPool&lt;/code&gt; 이을 (A)의 벡터 개최 &lt;code&gt;thread::JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; 의 용량 벡터 초기화, 인스턴스 &lt;code&gt;size&lt;/code&gt; 설정하는 &lt;code&gt;for&lt;/code&gt; 스레드를 생성하는 몇 가지 코드를 실행 루프, 및 반환 된 그것들을 포함한 &lt;code&gt;ThreadPool&lt;/code&gt; 인스턴스.</target>
        </trans-unit>
        <trans-unit id="d3a6f7dff2487d4bcc7b7e0489bef3c4a5207416" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-20 is responding to requests asynchronously through the use of a thread pool, as we intended. We get some warnings about the &lt;code&gt;workers&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, and &lt;code&gt;thread&lt;/code&gt; fields that we&amp;rsquo;re not using in a direct way that reminds us we&amp;rsquo;re not cleaning up anything. When we use the less elegant ctrl-c method to halt the main thread, all other threads are stopped immediately as well, even if they&amp;rsquo;re in the middle of serving a request.</source>
          <target state="translated">목록 20-20의 코드는 의도 한대로 스레드 풀을 사용하여 요청에 비동기 적으로 응답합니다. 우리가 아무것도 정리하지 않는다는 것을 상기시키는 직접적인 방식으로 사용하지 않는 &lt;code&gt;workers&lt;/code&gt; , &lt;code&gt;id&lt;/code&gt; 및 &lt;code&gt;thread&lt;/code&gt; 필드 에 대한 경고를받습니다 . 덜 우아한 ctrl-c 메서드를 사용하여 메인 스레드를 중지하면 요청을 처리하는 중에도 다른 모든 스레드도 즉시 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="b9b3fdc249a44ebef0cd41734527cea5bbbbc841" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-21 is responding to requests asynchronously through the use of a thread pool, as we intended. We get some warnings about the &lt;code&gt;workers&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, and &lt;code&gt;thread&lt;/code&gt; fields that we&amp;rsquo;re not using in a direct way that reminds us we&amp;rsquo;re not cleaning up anything. When we use the less elegant ctrl-c method to halt the main thread, all other threads are stopped immediately as well, even if they&amp;rsquo;re in the middle of serving a request.</source>
          <target state="translated">Listing 20-21의 코드는 의도 한대로 스레드 풀을 사용하여 비동기 적으로 요청에 응답합니다. 우리는 아무것도 청소하지 않는다는 것을 상기시켜주는 직접적인 방식으로 사용하지 않는 &lt;code&gt;workers&lt;/code&gt; , &lt;code&gt;id&lt;/code&gt; 및 &lt;code&gt;thread&lt;/code&gt; 필드 에 대한 경고를받습니다 . 덜 우아한 ctrl-c 메소드를 사용하여 기본 스레드를 중단하면 다른 모든 스레드는 요청을 처리하는 중이라도 즉시 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="af00e0657ebb48c72ab0e8023da460e28c0f23c3" translate="yes" xml:space="preserve">
          <source>The code in Listing 5-7 also creates an instance in &lt;code&gt;user2&lt;/code&gt; that has a different value for &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;username&lt;/code&gt; but has the same values for the &lt;code&gt;active&lt;/code&gt; and &lt;code&gt;sign_in_count&lt;/code&gt; fields from &lt;code&gt;user1&lt;/code&gt;.</source>
          <target state="translated">Listing 5-7의 코드는 또한 &lt;code&gt;user2&lt;/code&gt; 에서 &lt;code&gt;email&lt;/code&gt; 및 &lt;code&gt;username&lt;/code&gt; 값은 &lt;code&gt;sign_in_count&lt;/code&gt; &lt;code&gt;user1&lt;/code&gt; 과 &lt;code&gt;active&lt;/code&gt; 및 sign_in_count 필드 값은 동일한 인스턴스를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="0531b3f098e465468fd76e222f809f69ed8edfae" translate="yes" xml:space="preserve">
          <source>The code in Listing 8-7 might look like it should work: why should a reference to the first element care about what changes at the end of the vector? This error is due to the way vectors work: adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn&amp;rsquo;t enough room to put all the elements next to each other where the vector currently is. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation.</source>
          <target state="translated">Listing 8-7의 코드는 작동하는 것처럼 보일 수있다. 왜 첫 번째 요소에 대한 참조가 벡터의 끝에서 어떤 변화를 고려해야 하는가? 이 오류는 벡터가 작동하는 방식 때문입니다. 벡터 끝에 새 요소를 추가하려면 각 요소 옆에 모든 요소를 ​​배치 할 공간이 충분하지 않은 경우 새 메모리를 할당하고 이전 요소를 새 공간에 복사해야합니다. 벡터가 현재있는 다른 곳. 이 경우 첫 번째 요소에 대한 참조는 할당 해제 된 메모리를 가리 킵니다. 차용 규칙은 프로그램이 해당 상황에서 종료되는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="94cc2f51904c3f9ddd0cfd3520b820c4eb301ad4" translate="yes" xml:space="preserve">
          <source>The code in Listing 9-4 will &lt;code&gt;panic!&lt;/code&gt; no matter why &lt;code&gt;File::open&lt;/code&gt; failed. What we want to do instead is take different actions for different failure reasons: if &lt;code&gt;File::open&lt;/code&gt; failed because the file doesn&amp;rsquo;t exist, we want to create the file and return the handle to the new file. If &lt;code&gt;File::open&lt;/code&gt; failed for any other reason&amp;mdash;for example, because we didn&amp;rsquo;t have permission to open the file&amp;mdash;we still want the code to &lt;code&gt;panic!&lt;/code&gt; in the same way as it did in Listing 9-4. Look at Listing 9-5, which adds an inner &lt;code&gt;match&lt;/code&gt; expression.</source>
          <target state="translated">목록 9-4의 코드는 &lt;code&gt;panic!&lt;/code&gt; &lt;code&gt;File::open&lt;/code&gt; 실패한 이유에 관계없이 우리가 대신하고 싶은 것은 다른 실패 이유로 다른 조치를 취하는 것입니다 . 파일이 존재하지 않아 &lt;code&gt;File::open&lt;/code&gt; 실패한 경우 파일 을 작성하고 핸들을 새 파일로 리턴하려고합니다. 경우 &lt;code&gt;File::open&lt;/code&gt; 우리가 열 수있는 권한이 없어서, 다른 이유로 - 예를 들면 실패 파일을-우리는 여전히 코드가 원하는 &lt;code&gt;panic!&lt;/code&gt; Listing 9-4에서와 같은 방식으로. 내부 &lt;code&gt;match&lt;/code&gt; 표현식 을 추가하는 목록 9-5를보십시오 .</target>
        </trans-unit>
        <trans-unit id="e95fa13e369d6a99c35a00c2091e07ffadc180a6" translate="yes" xml:space="preserve">
          <source>The code is trying to pass &lt;code&gt;receiver&lt;/code&gt; to multiple &lt;code&gt;Worker&lt;/code&gt; instances. This won&amp;rsquo;t work, as you&amp;rsquo;ll recall from Chapter 16: the channel implementation that Rust provides is multiple &lt;em&gt;producer&lt;/em&gt;, single &lt;em&gt;consumer&lt;/em&gt;. This means we can&amp;rsquo;t just clone the consuming end of the channel to fix this code. Even if we could, that is not the technique we would want to use; instead, we want to distribute the jobs across threads by sharing the single &lt;code&gt;receiver&lt;/code&gt; among all the workers.</source>
          <target state="translated">코드가 &lt;code&gt;receiver&lt;/code&gt; 를 여러 &lt;code&gt;Worker&lt;/code&gt; 인스턴스 로 전달하려고 합니다. 16 장 : Rust가 제공하는 채널 구현은 여러 &lt;em&gt;생산자&lt;/em&gt; , 단일 &lt;em&gt;소비자&lt;/em&gt; 라는 것을 기억 하겠지만 이것은 작동하지 않습니다 . 즉,이 코드를 수정하기 위해 채널의 소비 측을 복제 할 수는 없습니다. 우리가 할 수 있더라도 그것은 우리가 사용하고 싶은 기술이 아닙니다. 대신, 모든 작업자간에 단일 &lt;code&gt;receiver&lt;/code&gt; 를 공유하여 스레드간에 작업을 분배하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="404cdeaf9f9f5734a0b6eb5da98e14aed6b8934d" translate="yes" xml:space="preserve">
          <source>The code refers to a trait that is not in scope.</source>
          <target state="translated">코드는 범위에없는 특성을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f585d5dc0ef34cc30960f293fe10c97e69068fe3" translate="yes" xml:space="preserve">
          <source>The code that calls this code will then handle getting either an &lt;code&gt;Ok&lt;/code&gt; value that contains a username or an &lt;code&gt;Err&lt;/code&gt; value that contains an &lt;code&gt;io::Error&lt;/code&gt;. We don&amp;rsquo;t know what the calling code will do with those values. If the calling code gets an &lt;code&gt;Err&lt;/code&gt; value, it could call &lt;code&gt;panic!&lt;/code&gt; and crash the program, use a default username, or look up the username from somewhere other than a file, for example. We don&amp;rsquo;t have enough information on what the calling code is actually trying to do, so we propagate all the success or error information upward for it to handle appropriately.</source>
          <target state="translated">이 코드를 호출하는 코드는 사용자 이름이 포함 된 &lt;code&gt;Ok&lt;/code&gt; 값 또는 &lt;code&gt;io::Error&lt;/code&gt; 가 포함 된 &lt;code&gt;Err&lt;/code&gt; 값을 가져 옵니다 . 우리는 호출 코드가 그 값으로 무엇을 할 것인지 모른다. 호출 코드가 &lt;code&gt;Err&lt;/code&gt; 값을 얻으면 &lt;code&gt;panic!&lt;/code&gt; 호출 할 수 있습니다 ! 예를 들어 프로그램을 중단 시키거나 기본 사용자 이름을 사용하거나 파일이 아닌 다른 곳에서 사용자 이름을 검색하십시오. 호출 코드가 실제로 수행하려는 작업에 대한 정보가 충분하지 않으므로 모든 성공 또는 오류 정보를 상향 처리하여 적절하게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="cfac4f190729188f4689af6ae5b0042be7b9afad" translate="yes" xml:space="preserve">
          <source>The collection may reserve more space to avoid frequent reallocations.</source>
          <target state="translated">컬렉션은 빈번한 재 할당을 피하기 위해 더 많은 공간을 예약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a921d34f1378e463d6297235d9b237b6a37c1373" translate="yes" xml:space="preserve">
          <source>The comma following &lt;code&gt;$()&lt;/code&gt; indicates that a literal comma separator character could optionally appear after the code that matches the code in &lt;code&gt;$()&lt;/code&gt;. The &lt;code&gt;*&lt;/code&gt; specifies that the pattern matches zero or more of whatever precedes the &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">쉼표 다음 &lt;code&gt;$()&lt;/code&gt; 리터럴 쉼표 구분 문자가 선택적으로의 코드와 일치하는 코드 뒤에 나타날 수 있음을 나타냅니다 &lt;code&gt;$()&lt;/code&gt; . &lt;code&gt;*&lt;/code&gt; 지정 패턴 일치 제로 것을 이상 무엇이든의 앞에 &lt;code&gt;*&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="1bacb24582ff767b21e31f4cc1ad3d6012f25a0b" translate="yes" xml:space="preserve">
          <source>The command downloads a script and starts the installation of the &lt;code&gt;rustup&lt;/code&gt; tool, which installs the latest stable version of Rust. You might be prompted for your password. If the install is successful, the following line will appear:</source>
          <target state="translated">이 명령은 스크립트를 다운로드 하고 최신 안정 버전의 Rust를 설치하는 &lt;code&gt;rustup&lt;/code&gt; 도구 설치를 시작합니다 . 비밀번호를 묻는 메시지가 표시 될 수 있습니다. 성공적으로 설치되면 다음 줄이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="73b43b32097905758197f28a5b18a2fd54ae6279" translate="yes" xml:space="preserve">
          <source>The common part of these two paths is &lt;code&gt;std::io&lt;/code&gt;, and that&amp;rsquo;s the complete first path. To merge these two paths into one &lt;code&gt;use&lt;/code&gt; statement, we can use &lt;code&gt;self&lt;/code&gt; in the nested path, as shown in Listing 7-20.</source>
          <target state="translated">이 두 경로의 공통 부분은 &lt;code&gt;std::io&lt;/code&gt; 이며 이것이 첫 번째 전체 경로입니다. 이 두 경로를 하나의 &lt;code&gt;use&lt;/code&gt; 문 으로 병합하기 위해 Listing 7-20에 표시된 것처럼 중첩 경로에서 &lt;code&gt;self&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e8778a56f7c16d517be41bfd502f5b861a15290" translate="yes" xml:space="preserve">
          <source>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified. An order is a total order if it is (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="translated">비교기 함수는 슬라이스의 요소에 대한 총 순서를 정의해야합니다. 순서가 총계가 아닌 경우 요소의 순서는 지정되지 않습니다. 주문은 다음과 같은 경우 총 주문입니다 (모든 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aebc23a2aec802159973c4b13320302322bbb426" translate="yes" xml:space="preserve">
          <source>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified. An order is a total order if it is (for all a, b and c):</source>
          <target state="translated">비교기 함수는 슬라이스의 요소에 대한 총 순서를 정의해야합니다. 순서가 총계가 아닌 경우 요소의 순서는 지정되지 않습니다. 주문은 다음과 같은 경우 총 주문입니다 (모든 a, b 및 c에 해당).</target>
        </trans-unit>
        <trans-unit id="25646f45d8bc733d7759e265f95a900ae5f85f26" translate="yes" xml:space="preserve">
          <source>The comparator function should implement an order consistent with the sort order of the underlying &lt;code&gt;VecDeque&lt;/code&gt;, returning an order code that indicates whether its argument is &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Equal&lt;/code&gt; or &lt;code&gt;Greater&lt;/code&gt; than the desired target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ccf3fc61c0a63453fa6ca42d0beca2274f875f" translate="yes" xml:space="preserve">
          <source>The comparator function should implement an order consistent with the sort order of the underlying slice, returning an order code that indicates whether its argument is &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Equal&lt;/code&gt; or &lt;code&gt;Greater&lt;/code&gt; the desired target.</source>
          <target state="translated">비교기 함수는 기본 슬라이스의 정렬 순서와 일치하는 순서를 구현하여 인수가 &lt;code&gt;Less&lt;/code&gt; , &lt;code&gt;Equal&lt;/code&gt; 또는 &lt;code&gt;Greater&lt;/code&gt; 인지 여부를 나타내는 순서 코드를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="45e688bbffc9733765a7b6aca03992e2d5e377a5" translate="yes" xml:space="preserve">
          <source>The comparison must satisfy, for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;:</source>
          <target state="translated">비교는 모든 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 를 충족시켜야합니다 .</target>
        </trans-unit>
        <trans-unit id="0c2765074489dd525efeb165a25dbc97454a652e" translate="yes" xml:space="preserve">
          <source>The compilation didn&amp;rsquo;t produce any errors, but the program resulted in a &lt;em&gt;runtime&lt;/em&gt; error and didn&amp;rsquo;t exit successfully. When you attempt to access an element using indexing, Rust will check that the index you&amp;rsquo;ve specified is less than the array length. If the index is greater than or equal to the array length, Rust will panic.</source>
          <target state="translated">컴파일 &lt;em&gt;시&lt;/em&gt; 오류가 발생하지 않았지만 프로그램에서 &lt;em&gt;런타임&lt;/em&gt; 오류가 발생하여 종료되지 않았습니다. 색인 생성을 사용하여 요소에 액세스하려고하면 Rust는 지정한 색인이 배열 길이보다 작은 지 확인합니다. 인덱스가 배열 길이보다 크거나 같으면 Rust가 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="0a0cf1febd61e4c4aeb0165c7c721394953162c8" translate="yes" xml:space="preserve">
          <source>The compilation model centers on artifacts called &lt;em&gt;crates&lt;/em&gt;. Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or some sort of library.&lt;sup&gt;&lt;a href=&quot;#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">컴파일 모델은 &lt;em&gt;crates&lt;/em&gt; 라는 아티팩트를 중심으로합니다 . 각 컴파일은 소스 형식의 단일 크레이트를 처리하고, 성공하면 실행 파일 또는 일종의 라이브러리와 같은 바이너리 형식의 단일 크레이트를 생성합니다. &lt;sup&gt;&lt;a href=&quot;#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="25f0592827e30de97cacdd81a110584696dcea70" translate="yes" xml:space="preserve">
          <source>The compilation model centers on artifacts called &lt;em&gt;crates&lt;/em&gt;. Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or some sort of library.&lt;sup&gt;&lt;a href=&quot;crates-and-source-files#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">컴파일 모델은 &lt;em&gt;크레이트&lt;/em&gt; 라는 아티팩트를 중심으로합니다 . 각 컴파일은 소스 형태로 단일 상자를 처리하고 성공하면 실행 파일 또는 일종의 라이브러리와 같은 이진 형태로 단일 상자를 생성합니다. &lt;sup&gt;&lt;a href=&quot;crates-and-source-files#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="90596055b20c856dc417525ea133e8b1049b15fa" translate="yes" xml:space="preserve">
          <source>The compiler and standard library generally tries to ensure allocations never reach a size where an offset is a concern. For instance, &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt; ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes, so &lt;code&gt;vec.as_ptr().add(vec.len()).sub(vec.len())&lt;/code&gt; is always safe.</source>
          <target state="translated">컴파일러와 표준 라이브러리는 일반적으로 오프셋이 문제가되는 크기에 도달하지 않도록 할당하려고합니다. 예를 들어, &lt;code&gt;Vec&lt;/code&gt; 및 &lt;code&gt;Box&lt;/code&gt; 는 &lt;code&gt;isize::MAX&lt;/code&gt; 바이트 이상을 할당하지 않으므로 &lt;code&gt;vec.as_ptr().add(vec.len()).sub(vec.len())&lt;/code&gt; 은 항상 안전합니다.</target>
        </trans-unit>
        <trans-unit id="59cbb1cc8a088f98671593c9041c2587a34ab70d" translate="yes" xml:space="preserve">
          <source>The compiler and standard library generally tries to ensure allocations never reach a size where an offset is a concern. For instance, &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt; ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes, so &lt;code&gt;vec.as_ptr().add(vec.len())&lt;/code&gt; is always safe.</source>
          <target state="translated">컴파일러와 표준 라이브러리는 일반적으로 오프셋이 문제가되는 크기에 도달하지 않도록 할당하려고합니다. 예를 들어 &lt;code&gt;Vec&lt;/code&gt; 및 &lt;code&gt;Box&lt;/code&gt; 는 &lt;code&gt;isize::MAX&lt;/code&gt; 바이트 이상을 할당하지 않으므로 &lt;code&gt;vec.as_ptr().add(vec.len())&lt;/code&gt; 은 항상 안전합니다.</target>
        </trans-unit>
        <trans-unit id="5647f6303a746120d1bc013678162600f20688f8" translate="yes" xml:space="preserve">
          <source>The compiler and standard library generally try to ensure allocations never reach a size where an offset is a concern. For instance, &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt; ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes, so &lt;code&gt;ptr_into_vec.offset_from(vec.as_ptr())&lt;/code&gt; is always safe.</source>
          <target state="translated">컴파일러와 표준 라이브러리는 일반적으로 오프셋이 문제가되는 크기에 도달하지 않도록 할당하려고합니다. 예를 들어 &lt;code&gt;Vec&lt;/code&gt; 및 &lt;code&gt;Box&lt;/code&gt; 는 &lt;code&gt;isize::MAX&lt;/code&gt; 바이트 이상을 할당하지 않으므로 &lt;code&gt;ptr_into_vec.offset_from(vec.as_ptr())&lt;/code&gt; 은 항상 안전합니다.</target>
        </trans-unit>
        <trans-unit id="d1adc5111740e7a8d58bceec3601a6e3d4ef92d4" translate="yes" xml:space="preserve">
          <source>The compiler could not infer a type and asked for a type annotation.</source>
          <target state="translated">컴파일러는 유형을 추론 할 수 없으며 유형 주석을 요청했습니다.</target>
        </trans-unit>
        <trans-unit id="030993899960155dfaeaf56819f76523f90d8c36" translate="yes" xml:space="preserve">
          <source>The compiler currently implements no method of hinting what format a library should be linked with. When dynamically linking, the compiler will attempt to maximize dynamic dependencies while still allowing some dependencies to be linked in via an rlib.</source>
          <target state="translated">컴파일러는 현재 라이브러리를 연결해야하는 형식을 암시하는 방법을 구현하지 않습니다. 동적으로 링크 할 때 컴파일러는 일부 종속성을 rlib를 통해 계속 링크하면서 동적 종속성을 최대화하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="fe8298a5d8326c70ef926aa1826e7331454f6a26" translate="yes" xml:space="preserve">
          <source>The compiler doesn't know what method to call because more than one method has the same prototype.</source>
          <target state="translated">둘 이상의 메서드에 동일한 프로토 타입이 있으므로 컴파일러는 호출 할 메서드를 알지 못합니다.</target>
        </trans-unit>
        <trans-unit id="1821ca1d85d61b39565f6e9976cc18b3afce261c" translate="yes" xml:space="preserve">
          <source>The compiler doesn't know what method to call because more than one method has the same prototype. Erroneous code example:</source>
          <target state="translated">둘 이상의 메소드에 동일한 프로토 타입이 있으므로 컴파일러가 호출 할 메소드를 모릅니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="1be1361775707ec1fbdcf50e883b1d7b1bdb5f0d" translate="yes" xml:space="preserve">
          <source>The compiler error is as follows:</source>
          <target state="translated">컴파일러 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b5655bf28c5aee029b50ebff36ecbfc08852001c" translate="yes" xml:space="preserve">
          <source>The compiler even reminds us that this only works with closures!</source>
          <target state="translated">컴파일러는 이것이 클로저에서만 작동한다는 것을 상기시켜줍니다!</target>
        </trans-unit>
        <trans-unit id="b0cba35bf39af6cdfd6b56d4dbe10dbaf77ed516" translate="yes" xml:space="preserve">
          <source>The compiler found a function whose body contains a &lt;code&gt;return;&lt;/code&gt; statement but whose return type is not &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">컴파일러가 본문에 &lt;code&gt;return;&lt;/code&gt; 포함 된 함수를 찾았습니다 . 명령문이지만 반환 유형이 &lt;code&gt;()&lt;/code&gt; 가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="b08f603159dc0eecd0f21f28c07166cefeb69847" translate="yes" xml:space="preserve">
          <source>The compiler found a function whose body contains a &lt;code&gt;return;&lt;/code&gt; statement but whose return type is not &lt;code&gt;()&lt;/code&gt;. An example of this is:</source>
          <target state="translated">컴파일러는 본문에 &lt;code&gt;return;&lt;/code&gt; 포함 된 함수를 찾았습니다 . statement이지만 반환 유형이 &lt;code&gt;()&lt;/code&gt; 이 아닙니다 . 이에 대한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e4713e81e1fe06044671ee83362a3b9a0f5ad86" translate="yes" xml:space="preserve">
          <source>The compiler gives us this error:</source>
          <target state="translated">컴파일러는이 오류를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="b01feef52238a9b5f1daf51373c75b238f421fe8" translate="yes" xml:space="preserve">
          <source>The compiler is allowed to perform any combination of these optimizations, as long as the final optimized code, when executed, produces the same results as the one without optimizations.</source>
          <target state="translated">컴파일러는 최종 최적화 코드가 실행될 때 최적화가없는 코드와 동일한 결과를 생성하는 한 이러한 최적화의 조합을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec5c1119f8e1ac4ec1c89254831939480c03edd7" translate="yes" xml:space="preserve">
          <source>The compiler may allow attributes for external tools where each tool resides in its own namespace. The first segment of the attribute path is the name of the tool, with one or more additional segments whose interpretation is up to the tool.</source>
          <target state="translated">컴파일러는 각 도구가 자체 네임 스페이스에있는 외부 도구의 속성을 허용 할 수 있습니다. 속성 경로의 첫 번째 세그먼트는 도구의 이름이며 해석에 따라 하나 이상의 추가 세그먼트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7720aa4345b4147bab4d25831f37466e57d1fcc" translate="yes" xml:space="preserve">
          <source>The compiler prefers to capture a closed-over variable by immutable borrow, followed by unique immutable borrow (see below), by mutable borrow, and finally by move. It will pick the first choice of these that allows the closure to compile. The choice is made only with regards to the contents of the closure expression; the compiler does not take into account surrounding code, such as the lifetimes of involved variables.</source>
          <target state="translated">컴파일러는 변경 불가능한 차용, 고유 한 변경 불가능한 차용 (아래 참조), 변경 가능한 차용, 마지막으로 이동으로 닫힌 변수를 캡처하는 것을 선호합니다. 클로저를 컴파일 할 수있는 첫 번째 선택을 선택합니다. 클로저 표현의 내용에 대해서만 선택이 이루어집니다. 컴파일러는 관련된 변수의 수명과 같은 주변 코드를 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5212bd9f30887e16d9c074bb9450838a12a0be2d" translate="yes" xml:space="preserve">
          <source>The compiler shouldn't change the relative order or number of volatile memory operations. However, volatile memory operations on zero-sized types (e.g., if a zero-sized type is passed to &lt;code&gt;read_volatile&lt;/code&gt;) are noops and may be ignored.</source>
          <target state="translated">컴파일러는 상대적 순서 나 휘발성 메모리 작업 수를 변경해서는 안됩니다. 그러나 0 크기의 유형에 대한 휘발성 메모리 작업 (예 : 0 크기의 유형이 &lt;code&gt;read_volatile&lt;/code&gt; 에 전달되는 경우 )은 무시할 수 있으며 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="955e9c25a8bb7d2a1fb8b16fdbf5d5e19b107461" translate="yes" xml:space="preserve">
          <source>The compiler shouldn't change the relative order or number of volatile memory operations. However, volatile memory operations on zero-sized types (e.g., if a zero-sized type is passed to &lt;code&gt;write_volatile&lt;/code&gt;) are noops and may be ignored.</source>
          <target state="translated">컴파일러는 상대적 순서 나 휘발성 메모리 작업 수를 변경해서는 안됩니다. 그러나 0 크기의 유형에 대한 휘발성 메모리 작업 (예 : 0 크기의 유형이 &lt;code&gt;write_volatile&lt;/code&gt; 에 전달되는 경우 )은 무시할 수 있으며 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d348a40c0a7a1bd0e6bae37a48c29f90fc773ea5" translate="yes" xml:space="preserve">
          <source>The compiler supports various methods to link crates together both statically and dynamically. This section will explore the various methods to link crates together, and more information about native libraries can be found in the &lt;a href=&quot;https://doc.rust-lang.org/book/ffi.html&quot;&gt;FFI section of the book&lt;/a&gt;.</source>
          <target state="translated">컴파일러는 상자를 정적 및 동적으로 연결하는 다양한 방법을 지원합니다. 이 섹션에서는 상자를 함께 연결하는 다양한 방법을 살펴보고 네이티브 라이브러리에 대한 자세한 정보 &lt;a href=&quot;https://doc.rust-lang.org/book/ffi.html&quot;&gt;는이 책&lt;/a&gt; 의 FFI 섹션 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6a5c185d40ba65d2c0863bc15ff86b37643834d" translate="yes" xml:space="preserve">
          <source>The compiler then knows to not make any incorrect assumptions or optimizations on this code.</source>
          <target state="translated">그런 다음 컴파일러는이 코드에 대해 잘못된 가정이나 최적화를하지 않는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f49b0710fee284944c10fc8dd575c9f675cc65d" translate="yes" xml:space="preserve">
          <source>The compiler uses three rules to figure out what lifetimes references have when there aren&amp;rsquo;t explicit annotations. The first rule applies to input lifetimes, and the second and third rules apply to output lifetimes. If the compiler gets to the end of the three rules and there are still references for which it can&amp;rsquo;t figure out lifetimes, the compiler will stop with an error. These rules apply to &lt;code&gt;fn&lt;/code&gt; definitions as well as &lt;code&gt;impl&lt;/code&gt; blocks.</source>
          <target state="translated">컴파일러는 세 가지 규칙을 사용하여 명시 적 주석이 없을 때의 수명 참조가 무엇인지 파악합니다. 첫 번째 규칙은 입력 수명에 적용되고 두 번째 규칙과 세 번째 규칙은 출력 수명에 적용됩니다. 컴파일러가 세 가지 규칙의 끝까지 도달했지만 여전히 수명을 알 수없는 참조가있는 경우 컴파일러는 오류와 함께 중지됩니다. 이 규칙은 &lt;code&gt;fn&lt;/code&gt; 정의 및 &lt;code&gt;impl&lt;/code&gt; 블록에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="433b36c96c38bd66008e924fa1864ced83fcb794" translate="yes" xml:space="preserve">
          <source>The compiler will complain that it needs lifetime specifiers:</source>
          <target state="translated">컴파일러는 수명 지정자가 필요하다고 불평합니다.</target>
        </trans-unit>
        <trans-unit id="572859abb18057fb674dd21429d06414b40c8275" translate="yes" xml:space="preserve">
          <source>The compiler will determine which of the &lt;a href=&quot;../types/closure#call-traits-and-coercions&quot;&gt;closure traits&lt;/a&gt; the closure's type will implement by how it acts on its captured variables. The closure will also implement &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if all of its captured types do. These traits allow functions to accept closures using generics, even though the exact types can't be named.</source>
          <target state="translated">컴파일러는 클로저 유형이 캡처 된 변수에 작용하는 방식으로 클로저 유형이 구현할 &lt;a href=&quot;../types/closure#call-traits-and-coercions&quot;&gt;클로저 특성&lt;/a&gt; 을 결정 합니다. 클로저는 또한 캡처 된 모든 유형이 수행하는 경우 &lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; 및 / 또는 &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 구현 합니다. 이러한 특성을 통해 정확한 유형의 이름을 지정할 수는 없지만 함수가 제네릭을 사용하여 클로저를 수락 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="948f1a92a83b2e1e3378ae6b818bd73449ba504b" translate="yes" xml:space="preserve">
          <source>The compiler will indicate when you&amp;rsquo;re trying to do something that violates the rules of object safety in regard to trait objects. For example, let&amp;rsquo;s say we tried to implement the &lt;code&gt;Screen&lt;/code&gt; struct in Listing 17-4 to hold types that implement the &lt;code&gt;Clone&lt;/code&gt; trait instead of the &lt;code&gt;Draw&lt;/code&gt; trait, like this:</source>
          <target state="translated">컴파일러는 특성 객체와 관련하여 객체 안전 규칙을 위반하는 작업을 수행하려고 할 때 표시합니다. 예를 들어, 다음 과 같이 &lt;code&gt;Draw&lt;/code&gt; 특성 대신 &lt;code&gt;Clone&lt;/code&gt; 특성 을 구현하는 유형을 보유하기 위해 Listing 17-4 의 &lt;code&gt;Screen&lt;/code&gt; 구조체 를 구현하려했다고 가정 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="0946476a608603480a8c85b783bae37331306e67" translate="yes" xml:space="preserve">
          <source>The compiler, in general, assumes that a variable is properly initialized according to the requirements of the variable's type. For example, a variable of reference type must be aligned and non-NULL. This is an invariant that must &lt;em&gt;always&lt;/em&gt; be upheld, even in unsafe code. As a consequence, zero-initializing a variable of reference type causes instantaneous &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;, no matter whether that reference ever gets used to access memory:</source>
          <target state="translated">일반적으로 컴파일러는 변수 유형의 요구 사항에 따라 변수가 적절하게 초기화되었다고 가정합니다. 예를 들어 참조 유형의 변수는 정렬되고 NULL이 아니어야합니다. 이것은 안전하지 않은 코드에서도 &lt;em&gt;항상&lt;/em&gt; 유지 되어야하는 불변입니다 . 결과적으로 참조 유형의 변수를 0으로 초기화하면 해당 참조가 메모리에 액세스하는 데 사용되는지 여부에 관계없이 즉시 &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;정의되지 않은 동작이&lt;/a&gt; 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="a84c7a7769bfd766452d6377b59bc8d2e574c64c" translate="yes" xml:space="preserve">
          <source>The compiler, in general, assumes that variables are properly initialized at their respective type. For example, a variable of reference type must be aligned and non-NULL. This is an invariant that must &lt;em&gt;always&lt;/em&gt; be upheld, even in unsafe code. As a consequence, zero-initializing a variable of reference type causes instantaneous &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;, no matter whether that reference ever gets used to access memory:</source>
          <target state="translated">컴파일러는 일반적으로 변수가 해당 유형에서 올바르게 초기화되었다고 가정합니다. 예를 들어, 참조 유형의 변수는 정렬되고 NULL이 아니어야합니다. 이것은 안전하지 않은 코드에서도 &lt;em&gt;항상 지켜&lt;/em&gt; 져야 하는 변하지 않는 것입니다 . 결과적으로 참조 유형의 변수를 0으로 초기화하면 해당 참조가 메모리에 액세스하는 데 사용되는지 여부에 관계없이 순간적으로 &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;정의되지 않은 동작이&lt;/a&gt; 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="4ed049edf6523bee71aa6c2cc8dac47d3acb83f3" translate="yes" xml:space="preserve">
          <source>The computed offset cannot exceed &lt;code&gt;isize::MAX&lt;/code&gt;&lt;strong&gt;bytes&lt;/strong&gt;.</source>
          <target state="translated">계산 된 오프셋은 &lt;code&gt;isize::MAX&lt;/code&gt; &lt;strong&gt;bytes를&lt;/strong&gt; 초과 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4f78f76fdf78ce465bd63ef1c725533fd764ba85" translate="yes" xml:space="preserve">
          <source>The computed offset, &lt;strong&gt;in bytes&lt;/strong&gt;, cannot overflow an &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;바이트 단위로&lt;/strong&gt; 계산 된 오프셋 은 &lt;code&gt;isize&lt;/code&gt; 오버 플로우 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="63f5ab3561e8fa530abb7afbb885243679cbd27d" translate="yes" xml:space="preserve">
          <source>The concatenation &amp;alpha; &amp;beta; &amp;gamma; &amp;delta; is a parseable Rust program.</source>
          <target state="translated">연결 &amp;alpha; &amp;beta; &amp;gamma; &amp;delta;는 파싱 가능한 Rust 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="026ad0f5294d67f94938651fe3bfaacf62c15a89" translate="yes" xml:space="preserve">
          <source>The concept of lifetimes is somewhat different from tools in other programming languages, arguably making lifetimes Rust&amp;rsquo;s most distinctive feature. Although we won&amp;rsquo;t cover lifetimes in their entirety in this chapter, we&amp;rsquo;ll discuss common ways you might encounter lifetime syntax so you can become familiar with the concepts.</source>
          <target state="translated">일생의 개념은 다른 프로그래밍 언어의 툴과는 다소 다르며, 아마도 일생 Rust의 가장 독특한 특징을 일 생일 것입니다. 이 장에서는 전체 수명을 다루지 않지만 수명 구문에 직면 할 수있는 일반적인 방법에 대해 논의하여 개념에 익숙해 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf8b3cea5648a2c56269d845203de953f7dc58d3" translate="yes" xml:space="preserve">
          <source>The concepts of ownership, borrowing, and slices ensure memory safety in Rust programs at compile time. The Rust language gives you control over your memory usage in the same way as other systems programming languages, but having the owner of data automatically clean up that data when the owner goes out of scope means you don&amp;rsquo;t have to write and debug extra code to get this control.</source>
          <target state="translated">소유권, 차용 및 슬라이스 개념은 컴파일시 Rust 프로그램에서 메모리 안전성을 보장합니다. Rust 언어를 사용하면 다른 시스템 프로그래밍 언어와 같은 방식으로 메모리 사용을 제어 할 수 있지만 소유자가 범위를 벗어날 때 데이터 소유자가 자동으로 해당 데이터를 정리하면 추가 코드를 작성하고 디버깅 할 필요가 없습니다. 이 컨트롤을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5484608e7530a94c46507f1fbbbe29684e230d84" translate="yes" xml:space="preserve">
          <source>The condition can use variables created in the pattern. Listing 18-26 shows a &lt;code&gt;match&lt;/code&gt; where the first arm has the pattern &lt;code&gt;Some(x)&lt;/code&gt; and also has a match guard of &lt;code&gt;if x &amp;lt; 5&lt;/code&gt;.</source>
          <target state="translated">조건은 패턴에서 작성된 변수를 사용할 수 있습니다. 18-26 쇼 목록 &lt;code&gt;match&lt;/code&gt; 최초의 암 패턴이 &lt;code&gt;Some(x)&lt;/code&gt; 또한의 일치 가드가 &lt;code&gt;if x &amp;lt; 5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c47359692fd118dbc5a64f61c4a95c135750d6d3" translate="yes" xml:space="preserve">
          <source>The condition expression of an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; expression, or a &lt;code&gt;match&lt;/code&gt; guard.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;while&lt;/code&gt; 표현식 또는 &lt;code&gt;match&lt;/code&gt; 가드 의 조건 표현식입니다 .</target>
        </trans-unit>
        <trans-unit id="095096dc5e2804946ad94bae4f75159f2bd38855" translate="yes" xml:space="preserve">
          <source>The condition in an &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; expression must be of type &lt;code&gt;bool&lt;/code&gt;. Whenever that condition evaluates to &lt;strong&gt;true&lt;/strong&gt;, the &lt;code&gt;if&lt;/code&gt; expression takes on the value of the first block. If however, the condition evaluates to &lt;code&gt;false&lt;/code&gt;, the expression takes on value of the &lt;code&gt;else&lt;/code&gt; block if there is one.</source>
          <target state="translated">&lt;a href=&quot;keyword.if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 표현식 의 조건은 &lt;code&gt;bool&lt;/code&gt; 유형이어야합니다 . 그 조건으로 평가 될 때마다 &lt;strong&gt;참&lt;/strong&gt; 의 &lt;code&gt;if&lt;/code&gt; 발현은 첫 번째 블록의 값을 취한다. 그러나 조건이 &lt;code&gt;false&lt;/code&gt; 로 평가 되면 표현식이 &lt;code&gt;else&lt;/code&gt; 블록의 값 (있는 경우)을 취합니다 .</target>
        </trans-unit>
        <trans-unit id="75d37ae80df9e59cac39010c72ed606ee381207c" translate="yes" xml:space="preserve">
          <source>The condition we want to check in the inner match is whether the value returned by &lt;code&gt;error.kind()&lt;/code&gt; is the &lt;code&gt;NotFound&lt;/code&gt; variant of the &lt;code&gt;ErrorKind&lt;/code&gt; enum. If it is, we try to create the file with &lt;code&gt;File::create&lt;/code&gt;. However, because &lt;code&gt;File::create&lt;/code&gt; could also fail, we need a second arm in the inner &lt;code&gt;match&lt;/code&gt; expression. When the file can&amp;rsquo;t be created, a different error message is printed. The second arm of the outer &lt;code&gt;match&lt;/code&gt; stays the same, so the program panics on any error besides the missing file error.</source>
          <target state="translated">내부 일치를 확인하려는 조건은 &lt;code&gt;error.kind()&lt;/code&gt; 의해 반환 된 값 이 &lt;code&gt;ErrorKind&lt;/code&gt; 열거 형 의 &lt;code&gt;NotFound&lt;/code&gt; 변형 인지 여부 입니다. 그렇다면 &lt;code&gt;File::create&lt;/code&gt; 를 사용하여 파일을 만듭니다 . 그러나 &lt;code&gt;File::create&lt;/code&gt; 도 실패 할 수 있으므로 내부 &lt;code&gt;match&lt;/code&gt; 식 에 두 번째 암이 필요합니다 . 파일을 만들 수 없으면 다른 오류 메시지가 인쇄됩니다. 외부 &lt;code&gt;match&lt;/code&gt; 의 두 번째 암은 동일하게 유지되므로 누락 된 파일 오류 외에 오류가 발생하면 프로그램이 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="6c5b1587da56cf50f7a60ae4167ed8ca12fc4a83" translate="yes" xml:space="preserve">
          <source>The conditions in which you&amp;rsquo;re allowed or not allowed to implement the trait</source>
          <target state="translated">특성을 구현할 수있는 조건</target>
        </trans-unit>
        <trans-unit id="1fd449b5671c0c531048bf228bce50b5745274bb" translate="yes" xml:space="preserve">
          <source>The connection was aborted (terminated) by the remote server.</source>
          <target state="translated">원격 서버에 의해 연결이 중단 (종료)되었습니다.</target>
        </trans-unit>
        <trans-unit id="394cd4f1c44fd561007d2b956b477de854f22ebc" translate="yes" xml:space="preserve">
          <source>The connection was refused by the remote server.</source>
          <target state="translated">원격 서버에서 연결을 거부했습니다.</target>
        </trans-unit>
        <trans-unit id="ee9eafc82d73396db6a743b750893f5328ee460c" translate="yes" xml:space="preserve">
          <source>The connection was reset by the remote server.</source>
          <target state="translated">원격 서버가 연결을 재설정했습니다.</target>
        </trans-unit>
        <trans-unit id="c5c0b8221782b43e8764b446a2f5d5156fcf8b34" translate="yes" xml:space="preserve">
          <source>The connection will be closed when the value is dropped. The reading and writing portions of the connection can also be shut down individually with the &lt;a href=&quot;#method.shutdown&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">값이 떨어지면 연결이 닫힙니다. 연결의 읽기 및 쓰기 부분은 &lt;a href=&quot;#method.shutdown&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt; 방법으로 개별적으로 종료 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee6719cfaf61adca10461f2b171bde13e23a4a41" translate="yes" xml:space="preserve">
          <source>The connection will be closed when the value is dropped. The reading and writing portions of the connection can also be shut down individually with the &lt;a href=&quot;struct.tcpstream#method.shutdown&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">값이 삭제되면 연결이 닫힙니다. 연결의 읽기 및 쓰기 부분은 &lt;a href=&quot;struct.tcpstream#method.shutdown&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt; 방법을 사용하여 개별적으로 종료 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98a1585e2f9a061b72de9d4f949a75a416a4fb56" translate="yes" xml:space="preserve">
          <source>The cons function concept has made its way into more general functional programming jargon: &amp;ldquo;to cons &lt;em&gt;x&lt;/em&gt; onto &lt;em&gt;y&lt;/em&gt;&amp;rdquo; informally means to construct a new container instance by putting the element &lt;em&gt;x&lt;/em&gt; at the start of this new container, followed by the container &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">cons 함수 개념은보다 일반적인 기능적 프로그래밍 용어로 발전했습니다. &quot; &lt;em&gt;x&lt;/em&gt; 를 &lt;em&gt;y&lt;/em&gt; 에 &lt;em&gt;대입하는 것&lt;/em&gt; &quot; 은이 새로운 컨테이너의 시작 부분에 요소 &lt;em&gt;x&lt;/em&gt; 를 놓고 컨테이너 &lt;em&gt;y&lt;/em&gt; 를 배치하여 새 컨테이너 인스턴스를 구성하는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="3946118b0e2f7f5ec1675cedbf82ccd7c8d576ce" translate="yes" xml:space="preserve">
          <source>The contents of &lt;em&gt;src/lib.rs&lt;/em&gt; should have the signatures shown in Listing 12-13 (we&amp;rsquo;ve omitted the bodies of the functions for brevity). Note that this won&amp;rsquo;t compile until we modify &lt;em&gt;src/main.rs&lt;/em&gt; in Listing 12-14.</source>
          <target state="translated">&lt;em&gt;src / lib.rs&lt;/em&gt; 의 내용에는 Listing 12-13에 표시된 서명이 있어야한다 (간단하게하기 위해 함수의 본문은 생략했다). Listing 12-14에서 &lt;em&gt;src / main.rs&lt;/em&gt; 를 수정하기 전까지는 컴파일되지 않는다 .</target>
        </trans-unit>
        <trans-unit id="4fb4cd20ff2b04a7f8f088847ce2546308d2b8ce" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;em&gt;src/lib.rs&lt;/em&gt; file in your &lt;code&gt;adder&lt;/code&gt; library should look like Listing 11-1.</source>
          <target state="translated">&lt;code&gt;adder&lt;/code&gt; 라이브러리 에있는 &lt;em&gt;src / lib.rs&lt;/em&gt; 파일 의 내용은 Listing 11-1과 같다.</target>
        </trans-unit>
        <trans-unit id="1735f7c56c57e86fb0b029da9024a55f63cc6d92" translate="yes" xml:space="preserve">
          <source>The contents of the repetition must be able to follow whatever comes before, and whatever comes after must be able to follow the contents of the repetition.</source>
          <target state="translated">반복의 내용은 이전의 모든 내용을 따라갈 수 있어야하며 이후의 모든 내용은 반복의 내용을 따라갈 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="33e5fb5d650df50a2e77352564f0bccccceac217" translate="yes" xml:space="preserve">
          <source>The contents of the returned &lt;a href=&quot;../raw/struct.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; are &lt;strong&gt;not&lt;/strong&gt; consistent across Unix platforms. The &lt;code&gt;os::unix::fs::MetadataExt&lt;/code&gt; trait contains the cross-Unix abstractions contained within the raw stat.</source>
          <target state="translated">반환의 내용 &lt;a href=&quot;../raw/struct.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; 있습니다 &lt;strong&gt;하지&lt;/strong&gt; 유닉스 플랫폼에서 일관된. &lt;code&gt;os::unix::fs::MetadataExt&lt;/code&gt; 특성은 원시 통계에 포함 된 크로스 - 유닉스 추상화가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0770383d0616ee4e47049d055237250b7b2bfaef" translate="yes" xml:space="preserve">
          <source>The conversion allocates on the heap and moves &lt;code&gt;t&lt;/code&gt; from the stack into it.</source>
          <target state="translated">변환은 힙에 할당 하고 스택에서 &lt;code&gt;t&lt;/code&gt; 로 힙을 이동 합니다.</target>
        </trans-unit>
        <trans-unit id="66e8c9afb284902c1e321d76aa570359994fd792" translate="yes" xml:space="preserve">
          <source>The conversion consumes the &lt;a href=&quot;../ffi/struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;, and removes the terminating NUL byte.</source>
          <target state="translated">변환은 &lt;a href=&quot;../ffi/struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; 을&lt;/a&gt; 소비하고 종료 NUL 바이트를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="b49f9ee7f1f30037339c1daa1d1e1cd395843299" translate="yes" xml:space="preserve">
          <source>The conversion consumes the &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;, and removes the terminating NUL byte.</source>
          <target state="translated">변환은 &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; 을&lt;/a&gt; 소비하고 종료 NUL 바이트를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="9ff60369ad0f3cbf8d85443d93a8bb4f7f1f7686" translate="yes" xml:space="preserve">
          <source>The conversion copies the data, and includes an allocation on the heap.</source>
          <target state="translated">변환은 데이터를 복사하고 힙에 대한 할당을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="cbdea02b60597ccd54b5d9dbad9b3681336b3420" translate="yes" xml:space="preserve">
          <source>The core method of future, &lt;code&gt;poll&lt;/code&gt;, &lt;em&gt;attempts&lt;/em&gt; to resolve the future into a final value. This method does not block if the value is not ready. Instead, the current task is scheduled to be woken up when it's possible to make further progress by &lt;code&gt;poll&lt;/code&gt;ing again. The &lt;code&gt;context&lt;/code&gt; passed to the &lt;code&gt;poll&lt;/code&gt; method can provide a &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt;, which is a handle for waking up the current task.</source>
          <target state="translated">미래의 핵심 방법은 &lt;code&gt;poll&lt;/code&gt; , &lt;em&gt;시도는&lt;/em&gt; 최종 값으로 미래를 해결합니다. 이 메서드는 값이 준비되지 않은 경우 차단되지 않습니다. 대신 현재 작업은 다시 &lt;code&gt;poll&lt;/code&gt; 하여 추가 진행이 가능할 때 깨어나도록 예약 됩니다. &lt;code&gt;poll&lt;/code&gt; 메서드에 전달 된 &lt;code&gt;context&lt;/code&gt; 는 현재 작업을 깨우기위한 핸들 인 &lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; 를&lt;/a&gt; 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af0586e1698754134d6653d1c35d55045868b007" translate="yes" xml:space="preserve">
          <source>The core method of future, &lt;code&gt;poll&lt;/code&gt;, &lt;em&gt;attempts&lt;/em&gt; to resolve the future into a final value. This method does not block if the value is not ready. Instead, the current task is scheduled to be woken up when it's possible to make further progress by &lt;code&gt;poll&lt;/code&gt;ing again. The &lt;code&gt;context&lt;/code&gt; passed to the &lt;code&gt;poll&lt;/code&gt; method can provide a &lt;code&gt;Waker&lt;/code&gt;, which is a handle for waking up the current task.</source>
          <target state="translated">미래의 핵심 방법은 &lt;code&gt;poll&lt;/code&gt; , &lt;em&gt;시도는&lt;/em&gt; 최종 값으로 미래를 해결합니다. 값이 준비되지 않은 경우이 방법은 차단되지 않습니다. 대신, 현재 작업은 다시 &lt;code&gt;poll&lt;/code&gt; 하여 추가 진행이 가능할 때 깨어날 예정 입니다. &lt;code&gt;poll&lt;/code&gt; 메소드에 전달 된 &lt;code&gt;context&lt;/code&gt; 는 &lt;code&gt;Waker&lt;/code&gt; 를 제공 할 수 있으며 , 이는 현재 작업을 깨우기위한 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="7cb53e3d2cc08f8c1b0d6306a44e9e0ab47f9511" translate="yes" xml:space="preserve">
          <source>The core of the error states that there are &lt;em&gt;mismatched types&lt;/em&gt;. Rust has a strong, static type system. However, it also has type inference. When we wrote &lt;code&gt;let mut guess = String::new()&lt;/code&gt;, Rust was able to infer that &lt;code&gt;guess&lt;/code&gt; should be a &lt;code&gt;String&lt;/code&gt; and didn&amp;rsquo;t make us write the type. The &lt;code&gt;secret_number&lt;/code&gt;, on the other hand, is a number type. A few number types can have a value between 1 and 100: &lt;code&gt;i32&lt;/code&gt;, a 32-bit number; &lt;code&gt;u32&lt;/code&gt;, an unsigned 32-bit number; &lt;code&gt;i64&lt;/code&gt;, a 64-bit number; as well as others. Rust defaults to an &lt;code&gt;i32&lt;/code&gt;, which is the type of &lt;code&gt;secret_number&lt;/code&gt; unless you add type information elsewhere that would cause Rust to infer a different numerical type. The reason for the error is that Rust cannot compare a string and a number type.</source>
          <target state="translated">오류의 핵심은 &lt;em&gt;유형&lt;/em&gt; 이 &lt;em&gt;일치하지 않음을 나타&lt;/em&gt; 냅니다. Rust는 강력한 정적 타입 시스템을 가지고 있습니다. 그러나 형식 유추도 있습니다. &lt;code&gt;let mut guess = String::new()&lt;/code&gt; 을 쓸 때 Rust는 &lt;code&gt;guess&lt;/code&gt; 이 &lt;code&gt;String&lt;/code&gt; 이어야 한다고 추측 할 수 있었고 유형을 쓰지 않았습니다. 반면에 &lt;code&gt;secret_number&lt;/code&gt; 는 숫자 유형입니다. 몇몇 숫자 유형은 1과 100 사이의 값을 가질 수 있습니다. &lt;code&gt;i32&lt;/code&gt; -32 비트 숫자; 부호없는 32 비트 숫자 인 &lt;code&gt;u32&lt;/code&gt; ; 64 비트 숫자 인 &lt;code&gt;i64&lt;/code&gt; ; 뿐만 아니라 다른 사람. 에 녹 기본값 &lt;code&gt;i32&lt;/code&gt; 의 유형입니다, &lt;code&gt;secret_number&lt;/code&gt; Rust가 다른 숫자 유형을 유추하는 다른 곳에 유형 ​​정보를 추가하지 않는 한. 오류의 원인은 Rust가 문자열과 숫자 유형을 비교할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ddff64ad7c369ce0737f5b8b0b3f4b7511787cca" translate="yes" xml:space="preserve">
          <source>The core primitive for interior mutability in Rust.</source>
          <target state="translated">Rust의 내부 가변성을위한 핵심 기본 요소.</target>
        </trans-unit>
        <trans-unit id="e23a80c74457fb7f3e04241567981840f6b6a5f0" translate="yes" xml:space="preserve">
          <source>The corresponding definitions are in &lt;code&gt;compiler/rustc_codegen_llvm/src/intrinsic.rs&lt;/code&gt;. The corresponding const implementations are in &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt;</source>
          <target state="translated">해당 정의는 &lt;code&gt;compiler/rustc_codegen_llvm/src/intrinsic.rs&lt;/code&gt; 에 있습니다. 해당하는 const 구현은 &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="159b3bf04af466ed5bc13962fe870a560dd18283" translate="yes" xml:space="preserve">
          <source>The corresponding definitions are in &lt;code&gt;librustc_codegen_llvm/intrinsic.rs&lt;/code&gt;.</source>
          <target state="translated">해당 정의는 &lt;code&gt;librustc_codegen_llvm/intrinsic.rs&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="46698ed84aa8c683839a27c0dd70bde9fa62d21c" translate="yes" xml:space="preserve">
          <source>The counts are not affected in any way and the &lt;code&gt;Arc&lt;/code&gt; is not consumed. The pointer is valid for as long as there are strong counts in the &lt;code&gt;Arc&lt;/code&gt;.</source>
          <target state="translated">카운트는 어떤 식 으로든 영향을받지 않으며 &lt;code&gt;Arc&lt;/code&gt; 는 소모되지 않습니다. 포인터는 &lt;code&gt;Arc&lt;/code&gt; 에 강한 개수가있는 한 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="77f706694dca621192d20fdc480b2fbc8fb70f49" translate="yes" xml:space="preserve">
          <source>The counts are not affected in any way and the &lt;code&gt;Rc&lt;/code&gt; is not consumed. The pointer is valid for as long there are strong counts in the &lt;code&gt;Rc&lt;/code&gt;.</source>
          <target state="translated">카운트는 어떤 방식으로도 영향을받지 않으며 &lt;code&gt;Rc&lt;/code&gt; 는 소비되지 않습니다. 포인터는 &lt;code&gt;Rc&lt;/code&gt; 에 강한 개수가있는 한 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="5d69c16c8fa846f1af610002036c48591d43f28f" translate="yes" xml:space="preserve">
          <source>The crate name must not be empty, and must only contain &lt;a href=&quot;../std/primitive.char#method.is_alphanumeric&quot;&gt;Unicode alphanumeric&lt;/a&gt; or &lt;code&gt;-&lt;/code&gt; (U+002D) characters.</source>
          <target state="translated">상자 이름은 비워 둘 수 없으며 &lt;a href=&quot;../std/primitive.char#method.is_alphanumeric&quot;&gt;유니 코드 영숫자&lt;/a&gt; 또는 &lt;code&gt;-&lt;/code&gt; (U + 002D) 문자 만 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="be4dd5125e77acafd163c79956b21bce0b41caf8" translate="yes" xml:space="preserve">
          <source>The created map has the default initial capacity.</source>
          <target state="translated">작성된 맵에는 기본 초기 용량이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9c04b6351b379cccf29eab61f8204218529d934" translate="yes" xml:space="preserve">
          <source>The current algorithm is an adaptive, iterative merge sort inspired by &lt;a href=&quot;https://en.wikipedia.org/wiki/Timsort&quot;&gt;timsort&lt;/a&gt;. It is designed to be very fast in cases where the slice is nearly sorted, or consists of two or more sorted sequences concatenated one after another.</source>
          <target state="translated">현재 알고리즘은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Timsort&quot;&gt;timsort에서&lt;/a&gt; 영감을 얻은 적응적이고 반복적 인 병합 정렬 입니다. 슬라이스가 거의 정렬되거나 두 개 이상의 정렬 된 시퀀스로 구성되어있는 경우 매우 빠르도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="bf4d84cfe0f7a72eb4a521a3a9fe9d6ec790d19e" translate="yes" xml:space="preserve">
          <source>The current algorithm is based on &lt;a href=&quot;https://github.com/orlp/pdqsort&quot;&gt;pattern-defeating quicksort&lt;/a&gt; by Orson Peters, which combines the fast average case of randomized quicksort with the fast worst case of heapsort, while achieving linear time on slices with certain patterns. It uses some randomization to avoid degenerate cases, but with a fixed seed to always provide deterministic behavior.</source>
          <target state="translated">현재 알고리즘은 Orson Peters의 &lt;a href=&quot;https://github.com/orlp/pdqsort&quot;&gt;패턴-파괴 퀵 정렬&lt;/a&gt; 을 기반으로 하며 무작위 퀵 정렬의 빠른 평균 경우와 가장 최악의 힙 정렬의 경우를 결합하고 특정 패턴의 슬라이스에서 선형 시간을 달성합니다. 그것은 변성 사례를 피하기 위해 임의의 무작위 화를 사용하지만 항상 결정 론적 행동을 제공하기 위해 고정 된 시드와 함께.</target>
        </trans-unit>
        <trans-unit id="17185ac0ce099c141b9827d28f04ee4d12e294f8" translate="yes" xml:space="preserve">
          <source>The current algorithm is based on the quickselect portion of the same quicksort algorithm used for &lt;a href=&quot;#method.sort_unstable&quot;&gt;&lt;code&gt;sort_unstable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재의 알고리즘에 사용 된 것과 동일한 퀵 알고리즘 quickselect 부분에 기초 &lt;a href=&quot;#method.sort_unstable&quot;&gt; &lt;code&gt;sort_unstable&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="593e3fc1b65f7b6d06f9c45167b067a1a762655b" translate="yes" xml:space="preserve">
          <source>The current file cursor is not affected by this function.</source>
          <target state="translated">현재 파일 커서는이 기능의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b3777ab23f3b1144c9a96d550ee493d6bc6e2d44" translate="yes" xml:space="preserve">
          <source>The current implementation uses the same infrastructure as compiler diagnostics and debuginfo, but this is not guaranteed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3346ba5eca8038cde57805738abeaa90cd6a63c6" translate="yes" xml:space="preserve">
          <source>The current module path can be thought of as the hierarchy of modules leading back up to the crate root. The first component of the path returned is the name of the crate currently being compiled.</source>
          <target state="translated">현재 모듈 경로는 크레이트 루트로 돌아가는 모듈의 계층 구조로 생각할 수 있습니다. 반환 된 경로의 첫 번째 구성 요소는 현재 컴파일중인 상자의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="bdf915fa340c78bb10eee5926542917da6f9a74d" translate="yes" xml:space="preserve">
          <source>The current process does not have the permission rights to access &lt;code&gt;from&lt;/code&gt; or write &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">현재 프로세스가 액세스 할 수있는 권한 권한이없는 &lt;code&gt;from&lt;/code&gt; 또는 쓰기 &lt;code&gt;to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b9c6f166ff606296d138016ea8392f66f7ed63a" translate="yes" xml:space="preserve">
          <source>The current status of a backtrace, indicating whether it was captured or whether it is empty for some other reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1cdfe5525c9cd270fc9b5826bff19009fb273e" translate="yes" xml:space="preserve">
          <source>The current version of the prelude (version 1) lives in &lt;a href=&quot;v1/index&quot;&gt;&lt;code&gt;std::prelude::v1&lt;/code&gt;&lt;/a&gt;, and re-exports the following.</source>
          <target state="translated">prelude (버전 1)의 현재 버전은 &lt;a href=&quot;v1/index&quot;&gt; &lt;code&gt;std::prelude::v1&lt;/code&gt; &lt;/a&gt; 에 있으며 다음을 다시 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="912528c0cfbd7646c08850f1e407245a6bf7145e" translate="yes" xml:space="preserve">
          <source>The cursor is pointing to the &quot;ghost&quot; non-element if the list is empty.</source>
          <target state="translated">목록이 비어있는 경우 커서는 &quot;유령&quot;비 요소를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="b9ad03e9a3edaaa56118f6fc3f2871f3d642b3c0" translate="yes" xml:space="preserve">
          <source>The data could not be sent on the &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; because it would require that the callee block to send the data.</source>
          <target state="translated">수신자 블록이 데이터를 보내야하기 때문에 &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt; 에서 데이터를 보낼 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="caac8e332d6bed98dbe6a446c232bbf7ded49130" translate="yes" xml:space="preserve">
          <source>The data members that this trait exposes correspond to the members of the &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/ns-fileapi-by_handle_file_information&quot;&gt;&lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="translated">이 특성이 노출하는 데이터 멤버는 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/ns-fileapi-by_handle_file_information&quot;&gt; &lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt; &lt;/a&gt; 구조 의 멤버에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="113312da9f41c00330f3f6a2627f87633cf51181" translate="yes" xml:space="preserve">
          <source>The data members that this trait exposes correspond to the members of the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363788.aspx&quot;&gt;&lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="translated">이 특성이 노출하는 데이터 멤버는 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363788.aspx&quot;&gt; &lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt; &lt;/a&gt; 구조 의 멤버에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="c9421f388aa0f6bda7993e70317be2c01ffcdb74" translate="yes" xml:space="preserve">
          <source>The data protected by the mutex can be accessed through this guard via its &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">뮤텍스로 보호되는 데이터는 &lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; 구현을 통해이 가드를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8b69bce2135d478ffa031311b309f0dc7de4fc2" translate="yes" xml:space="preserve">
          <source>The data that the process wrote to stderr.</source>
          <target state="translated">프로세스가 stderr에 쓴 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="5ad3bfb524d0ca744c539d652ec4054ab0b9dc35" translate="yes" xml:space="preserve">
          <source>The data that the process wrote to stdout.</source>
          <target state="translated">프로세스가 표준 출력에 쓴 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="f0f62565562b0bbca1d9e555b1c167c8869cc294" translate="yes" xml:space="preserve">
          <source>The declaration of &lt;code&gt;another_function&lt;/code&gt; has one parameter named &lt;code&gt;x&lt;/code&gt;. The type of &lt;code&gt;x&lt;/code&gt; is specified as &lt;code&gt;i32&lt;/code&gt;. When &lt;code&gt;5&lt;/code&gt; is passed to &lt;code&gt;another_function&lt;/code&gt;, the &lt;code&gt;println!&lt;/code&gt; macro puts &lt;code&gt;5&lt;/code&gt; where the pair of curly brackets were in the format string.</source>
          <target state="translated">&lt;code&gt;another_function&lt;/code&gt; 선언에는 &lt;code&gt;x&lt;/code&gt; 라는 하나의 매개 변수가 있습니다. &lt;code&gt;x&lt;/code&gt; 의 유형은 &lt;code&gt;i32&lt;/code&gt; 로 지정됩니다 . 때 &lt;code&gt;5&lt;/code&gt; 에 전달 &lt;code&gt;another_function&lt;/code&gt; 의 &lt;code&gt;println!&lt;/code&gt; 매크로 는 중괄호 쌍이 형식 문자열에 있었던 곳에 &lt;code&gt;5&lt;/code&gt; 를 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="f3e2b77707e4042bb7d326cf080f9fda22d6fd02" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#fillalignment&quot;&gt;fill/alignment&lt;/a&gt; for non-numerics is a space and left-aligned. The default for numeric formatters is also a space character but with right-alignment. If the &lt;code&gt;0&lt;/code&gt; flag (see below) is specified for numerics, then the implicit fill character is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">비 숫자에 대한 기본 &lt;a href=&quot;#fillalignment&quot;&gt;채우기 / 정렬&lt;/a&gt; 은 공백이며 왼쪽 정렬입니다. 숫자 포맷터의 기본값은 공백 문자이지만 오른쪽 정렬입니다. 경우 &lt;code&gt;0&lt;/code&gt; 플래그가 (아래 참조) 수치에 대해 지정된 내재 채우기 문자는 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a4c3f3e9f4bf073db3de78ffdfd8f78a08679d0" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#fillalignment&quot;&gt;fill/alignment&lt;/a&gt; for non-numerics is a space and left-aligned. The defaults for numeric formatters is also a space but with right-alignment. If the &lt;code&gt;0&lt;/code&gt; flag is specified for numerics, then the implicit fill character is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">숫자가 아닌 문자 의 기본 &lt;a href=&quot;#fillalignment&quot;&gt;채우기 / 정렬&lt;/a&gt; 은 공백과 왼쪽 정렬입니다. 숫자 포맷터의 기본값은 공백이지만 오른쪽 정렬입니다. 경우 &lt;code&gt;0&lt;/code&gt; 플래그가 수치에 대해 지정된 내재 채우기 문자는 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e71d3da519e1259cb4d0ff052a4082fe544273e4" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;../../hash/trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt; used by &lt;a href=&quot;struct.randomstate&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 &lt;a href=&quot;../../hash/trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; 에서 사용 &lt;a href=&quot;struct.randomstate&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81a33ca44ce969a6a0433a7aff9f0392c46b2e52" translate="yes" xml:space="preserve">
          <source>The default behavior of this function is to print a message to standard error and abort the process. It can be replaced with &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt;&lt;code&gt;set_alloc_error_hook&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt;&lt;code&gt;take_alloc_error_hook&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능의 기본 동작은 메시지를 표준 오류로 인쇄하고 프로세스를 중단하는 것입니다. &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt; &lt;code&gt;set_alloc_error_hook&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt; &lt;code&gt;take_alloc_error_hook&lt;/code&gt; &lt;/a&gt; 로 대체 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1fe48c8009742af8ee8a3efe0842a923bc01bf9d" translate="yes" xml:space="preserve">
          <source>The default generic type in this code is within the &lt;code&gt;Add&lt;/code&gt; trait. Here is its definition:</source>
          <target state="translated">이 코드의 기본 제네릭 형식은 &lt;code&gt;Add&lt;/code&gt; 특성 내에 있습니다. 그 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="697b922437171b9fe1e8c84494c4b161d6fd03d3" translate="yes" xml:space="preserve">
          <source>The default hashing algorithm is currently SipHash 1-3, though this is subject to change at any point in the future. While its performance is very competitive for medium sized keys, other hashing algorithms will outperform it for small keys such as integers as well as large keys such as long strings, though those algorithms will typically &lt;em&gt;not&lt;/em&gt; protect against attacks such as HashDoS.</source>
          <target state="translated">기본 해싱 알고리즘은 현재 SipHash 1-3이지만 향후 언제든지 변경 될 수 있습니다. 중간 크기의 키에 비해 성능이 매우 경쟁력이 있지만 다른 해싱 알고리즘은 정수와 같은 작은 키뿐만 아니라 긴 문자열과 같은 큰 키에 비해 성능이 뛰어나지 만 일반적 으로 HashDoS와 같은 공격으로부터 보호 &lt;em&gt;하지는 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="80e587164750efd5907b562bcc2c0ec8621ca1dc" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="translated">디폴트의 구현 호출 &lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 설치된 제 1 비어 있지 않은 버퍼, 존재하지 않는 경우는 빈 하나 하나에.</target>
        </trans-unit>
        <trans-unit id="73b38e69c912c9cd2a1d35da9b4cb8282e56833f" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;read&lt;/code&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="translated">기본 구현 호출 &lt;code&gt;read&lt;/code&gt; 제공된 첫 번째 비어 있지 않은 버퍼 또는 존재하지 않는 경우 비어있는 버퍼로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="2e19ee8802e471056a9e27a45d3086893e133973" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;write&lt;/code&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="translated">기본 구현은 비어 있지 않은 첫 번째 버퍼 또는 존재하지 않는 경우 비어있는 버퍼로 &lt;code&gt;write&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="917b792910290b9f104f9e9bb1c1c376f6e62a1b" translate="yes" xml:space="preserve">
          <source>The default implementation does nothing.</source>
          <target state="translated">기본 구현은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cda4f183b9995aecf4b0037179612271bde1f6bd" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;(0, &lt;/code&gt;&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; which is correct for any iterator.</source>
          <target state="translated">기본 구현은 모든 반복자에 대해 올바른 &lt;code&gt;(0, &lt;/code&gt; &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e33ad58e76bb269caa1c45076544afb93bb1e40d" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="969fb25f2024192b2aecf3ee3a177be1b86acfb5" translate="yes" xml:space="preserve">
          <source>The default implementation returns an initializer which will zero buffers.</source>
          <target state="translated">기본 구현은 버퍼를 0으로하는 이니셜 라이저를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bb3d803ebf5acd8c1abc49ce5f1cae9b36493095" translate="yes" xml:space="preserve">
          <source>The default implementations are returning &lt;code&gt;libc::EXIT_SUCCESS&lt;/code&gt; to indicate a successful execution. In case of a failure, &lt;code&gt;libc::EXIT_FAILURE&lt;/code&gt; is returned.</source>
          <target state="translated">기본 구현은 성공적인 실행을 나타 내기 위해 &lt;code&gt;libc::EXIT_SUCCESS&lt;/code&gt; 를 반환 합니다. 실패한 경우 &lt;code&gt;libc::EXIT_FAILURE&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="31cdcfae6f2b31eff3f08e0d9f029eeb9ec7bee1" translate="yes" xml:space="preserve">
          <source>The default is chosen with a bias toward producing literals that are legal in a variety of languages, including C++11 and similar C-family languages. The exact rules are:</source>
          <target state="translated">기본값은 C ++ 11 및 유사한 C 계열 언어를 포함하여 다양한 언어로 유효한 리터럴을 생성하는 것에 대한 편견과 함께 선택됩니다. 정확한 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b02cae987658ffb74f03215f87762f2599f0c7eb" translate="yes" xml:space="preserve">
          <source>The default memory allocator provided by the operating system.</source>
          <target state="translated">운영 체제에서 제공 한 기본 메모리 할당 자</target>
        </trans-unit>
        <trans-unit id="1dd4678ade75055f3987aad761b36a01d2353c9f" translate="yes" xml:space="preserve">
          <source>The default stack size for spawned threads is 2 MiB, though this particular stack size is subject to change in the future. There are two ways to manually specify the stack size for spawned threads:</source>
          <target state="translated">생성 된 스레드의 기본 스택 크기는 2MiB이지만이 특정 스택 크기는 나중에 변경 될 수 있습니다. 생성 된 스레드의 스택 크기를 수동으로 지정하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f91c7ab56b392b9e17d4e1e13452f2f412a7407" translate="yes" xml:space="preserve">
          <source>The definition for complex NTs deserves some justification. SEP_SET(M) defines the possibility that the separator could be a valid first token for M, which happens when there is a separator defined and the repeated fragment could be empty. ALPHA_SET(M) defines the possibility that the complex NT could be empty, meaning that M's valid first tokens are those of the following token-tree sequences &lt;code&gt;&amp;alpha;&lt;/code&gt;. This occurs when either &lt;code&gt;\*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; is used, in which case there could be zero repetitions. In theory, this could also occur if &lt;code&gt;+&lt;/code&gt; was used with a potentially-empty repeating fragment, but this is forbidden by the third invariant.</source>
          <target state="translated">복잡한 NT에 대한 정의는 약간의 정당화가 필요합니다. SEP_SET (M)은 분리자가 M에 대해 유효한 첫 번째 토큰 일 수있는 가능성을 정의합니다. 이는 분리자가 정의되고 반복 단편이 비어있을 때 발생합니다. ALPHA_SET (M)은 복합 NT가 비어있을 수있는 가능성을 정의합니다. 즉, M의 유효한 첫 번째 토큰은 다음 토큰 트리 시퀀스 &lt;code&gt;&amp;alpha;&lt;/code&gt; 의 토큰 입니다. 이것은 &lt;code&gt;\*&lt;/code&gt; 또는 &lt;code&gt;?&lt;/code&gt; 이 경우 반복이 0 일 수 있습니다. 이론적으로 이것은 &lt;code&gt;+&lt;/code&gt; 가 잠재적으로 비어있는 반복 조각과 함께 사용 된 경우에도 발생할 수 있지만 세 번째 불변에 의해 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="985a8049c57bbba61492d3048826a9b3471b56f7" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;Config&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Config&lt;/code&gt; 의 정의</target>
        </trans-unit>
        <trans-unit id="830ab684e6b9340db4f9c07a73c12e27ccb95977" translate="yes" xml:space="preserve">
          <source>The dereference operator</source>
          <target state="translated">역 참조 연산자</target>
        </trans-unit>
        <trans-unit id="75ad44a3ef91af0a45f2841a370dda11b833e07f" translate="yes" xml:space="preserve">
          <source>The desired behavior of the &lt;code&gt;generate_workout&lt;/code&gt; function is to first check whether the user wants a low-intensity workout (indicated by a number less than 25) or a high-intensity workout (a number of 25 or greater).</source>
          <target state="translated">&lt;code&gt;generate_workout&lt;/code&gt; 함수 의 원하는 동작은 먼저 사용자가 저 강도 운동 (25 미만의 숫자로 표시) 또는 고강도 운동 (25 이상)을 원하는지 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f11d06267e33f3ae0370e1b473dace96a1d49d65" translate="yes" xml:space="preserve">
          <source>The destructor of a type &lt;code&gt;T&lt;/code&gt; consists of:</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 의 소멸자는 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="be2c8573e9de352b5e8e680cfa4b055e97512426" translate="yes" xml:space="preserve">
          <source>The destructor of a type consists of</source>
          <target state="translated">타입의 소멸자는</target>
        </trans-unit>
        <trans-unit id="c9c60944e1a21001c2063c93ac3b0f4cb46946e2" translate="yes" xml:space="preserve">
          <source>The destructor of the struct must not move structural fields out of its argument. This is the exact point that was raised in the &lt;a href=&quot;#drop-implementation&quot;&gt;previous section&lt;/a&gt;: &lt;code&gt;drop&lt;/code&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but the struct (and hence its fields) might have been pinned before. You have to guarantee that you do not move a field inside your &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; implementation. In particular, as explained previously, this means that your struct must &lt;em&gt;not&lt;/em&gt; be &lt;code&gt;#[repr(packed)]&lt;/code&gt;. See that section for how to write &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; in a way that the compiler can help you not accidentally break pinning.</source>
          <target state="translated">구조체의 소멸자는 인수에서 구조적 필드를 이동해서는 안됩니다. 이것은 &lt;a href=&quot;#drop-implementation&quot;&gt;이전 섹션&lt;/a&gt; 에서 제기 된 정확한 지점입니다 . &lt;code&gt;drop&lt;/code&gt; 은 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 취하지 만 구조체 (및 따라서 해당 필드)는 이전에 고정되었을 수 있습니다. &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt; 구현 내에서 필드를 이동하지 않도록 보장해야합니다 . 특히, 같은 구조체가 있어야, 이전에이 방법을 설명 &lt;em&gt;하지&lt;/em&gt; 수 &lt;code&gt;#[repr(packed)]&lt;/code&gt; . 컴파일러가 실수로 고정을 중단하지 않도록 도와 줄 수있는 방식으로 &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; 을 작성하는 방법은 해당 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="30054f3bf420ad868745eedcb4cc73a1da34e82c" translate="yes" xml:space="preserve">
          <source>The destructor of the struct must not move structural fields out of its argument. This is the exact point that was raised in the &lt;a href=&quot;#drop-implementation&quot;&gt;previous section&lt;/a&gt;: &lt;code&gt;drop&lt;/code&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but the struct (and hence its fields) might have been pinned before. You have to guarantee that you do not move a field inside your &lt;code&gt;Drop&lt;/code&gt; implementation. In particular, as explained previously, this means that your struct must &lt;em&gt;not&lt;/em&gt; be &lt;code&gt;#[repr(packed)]&lt;/code&gt;. See that section for how to write &lt;code&gt;drop&lt;/code&gt; in a way that the compiler can help you not accidentally break pinning.</source>
          <target state="translated">구조체의 소멸자는 구조 필드를 인수 밖으로 이동해서는 안됩니다. 이것은 &lt;a href=&quot;#drop-implementation&quot;&gt;이전 섹션&lt;/a&gt; 에서 제기 된 정확한 점입니다 . &lt;code&gt;drop&lt;/code&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 이지만 구조체 (및 그 필드)는 이전에 고정되었을 수 있습니다. &lt;code&gt;Drop&lt;/code&gt; 구현 내에서 필드를 이동하지 않아야합니다 . 특히, 앞에서 설명한 바와 같이 이것은 구조체 가 &lt;code&gt;#[repr(packed)]&lt;/code&gt; &lt;em&gt;아니&lt;/em&gt; 어야 함을 의미합니다 . 작성하는 방법에 대한 섹션을 참조하십시오 &lt;code&gt;drop&lt;/code&gt; 컴파일러가 실수로 고정 아프게하지 당신을 도울 수있는 방법을.</target>
        </trans-unit>
        <trans-unit id="f85efc5c824a33e7773d4a9703af1abcf28610ef" translate="yes" xml:space="preserve">
          <source>The difference between 'the prelude' and these other preludes is that they are not automatically &lt;code&gt;use&lt;/code&gt;'d, and must be imported manually. This is still easier than importing all of their constituent components.</source>
          <target state="translated">'전주곡'과 다른 전주곡의 차이점은 자동으로 'd를 &lt;code&gt;use&lt;/code&gt; 하지 않으며 수동으로 가져와야한다는 것입니다. 이것은 모든 구성 요소를 가져 오는 것보다 여전히 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="505a24f6c966bf30ebbdd0623555d0248f90c11b" translate="yes" xml:space="preserve">
          <source>The difference between &lt;a href=&quot;macro.unimplemented&quot;&gt;&lt;code&gt;unimplemented!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;todo!&lt;/code&gt; is that while &lt;code&gt;todo!&lt;/code&gt; conveys an intent of implementing the functionality later and the message is &quot;not yet implemented&quot;, &lt;code&gt;unimplemented!&lt;/code&gt; makes no such claims. Its message is &quot;not implemented&quot;. Also some IDEs will mark &lt;code&gt;todo!&lt;/code&gt;s.</source>
          <target state="translated">&lt;a href=&quot;macro.unimplemented&quot;&gt; &lt;code&gt;unimplemented!&lt;/code&gt; &lt;/a&gt; 의 차이 ! 그리고 할 &lt;code&gt;todo!&lt;/code&gt; 그 동안 할 &lt;code&gt;todo!&lt;/code&gt; 나중에 기능을 구현하려는 의도를 전달하고 메시지는 구현되지 않은 &quot;아직 구현되지 않음&quot;입니다 &lt;code&gt;unimplemented!&lt;/code&gt; 그러한 주장을하지 않습니다. 메시지는 &quot;구현되지 않음&quot;입니다. 또한 일부 IDE는 할 &lt;code&gt;todo!&lt;/code&gt; 을 표시합니다 ! 에스.</target>
        </trans-unit>
        <trans-unit id="03297ced74ba958f935a37ee67580ef54eeb9a79" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;unimplemented!&lt;/code&gt; and &lt;a href=&quot;macro.todo&quot;&gt;&lt;code&gt;todo!&lt;/code&gt;&lt;/a&gt; is that while &lt;code&gt;todo!&lt;/code&gt; conveys an intent of implementing the functionality later and the message is &quot;not yet implemented&quot;, &lt;code&gt;unimplemented!&lt;/code&gt; makes no such claims. Its message is &quot;not implemented&quot;. Also some IDEs will mark &lt;code&gt;todo!&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;unimplemented!&lt;/code&gt; 의 차이 ! 그리고 할 &lt;a href=&quot;macro.todo&quot;&gt; &lt;code&gt;todo!&lt;/code&gt; &lt;/a&gt;그 동안 할 &lt;code&gt;todo!&lt;/code&gt; 나중에 기능을 구현하려는 의도를 전달하고 메시지는 구현되지 않은 &quot;아직 구현되지 않음&quot;입니다 &lt;code&gt;unimplemented!&lt;/code&gt; 그러한 주장을하지 않습니다. 메시지는 &quot;구현되지 않음&quot;입니다. 또한 일부 IDE는 할 &lt;code&gt;todo!&lt;/code&gt; 을 표시합니다 ! 에스.</target>
        </trans-unit>
        <trans-unit id="3d53ebfe9f22c1eb14437a5afaa7bab7ac81b640" translate="yes" xml:space="preserve">
          <source>The difference is that when using generics, as in Listing 19-13, we must annotate the types in each implementation; because we can also implement &lt;code&gt;Iterator&amp;lt;String&amp;gt; for Counter&lt;/code&gt; or any other type, we could have multiple implementations of &lt;code&gt;Iterator&lt;/code&gt; for &lt;code&gt;Counter&lt;/code&gt;. In other words, when a trait has a generic parameter, it can be implemented for a type multiple times, changing the concrete types of the generic type parameters each time. When we use the &lt;code&gt;next&lt;/code&gt; method on &lt;code&gt;Counter&lt;/code&gt;, we would have to provide type annotations to indicate which implementation of &lt;code&gt;Iterator&lt;/code&gt; we want to use.</source>
          <target state="translated">차이점은 Listing 19-13에서와 같이 제네릭을 사용할 때 각 구현에서 유형에 주석을 달아야한다는 것이다. 우리는 또한 구현할 수 있기 때문에 &lt;code&gt;Iterator&amp;lt;String&amp;gt; for Counter&lt;/code&gt; 또는 다른 종류의, 우리는 여러 구현 할 수 &lt;code&gt;Iterator&lt;/code&gt; 에 대한 &lt;code&gt;Counter&lt;/code&gt; . 즉, 특성에 일반 매개 변수가있는 경우 매번 일반 유형 매개 변수의 구체적인 유형을 변경하여 유형에 대해 여러 번 구현할 수 있습니다. &lt;code&gt;Counter&lt;/code&gt; 에서 &lt;code&gt;next&lt;/code&gt; 메소드를 사용할 때 사용 하려는 &lt;code&gt;Iterator&lt;/code&gt; 구현을 표시하기 위해 유형 주석을 제공 해야합니다.</target>
        </trans-unit>
        <trans-unit id="5d4f5e1a47f10d66452650a5f161fd164ebd410d" translate="yes" xml:space="preserve">
          <source>The differences about paths and the &lt;code&gt;use&lt;/code&gt; keyword between the 2015 and 2018 editions can also be found in the &lt;a href=&quot;../reference/items/use-declarations&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="translated">2015 년과 2018 년 버전의 경로 및 &lt;code&gt;use&lt;/code&gt; 키워드 에 대한 차이점은 &lt;a href=&quot;../reference/items/use-declarations&quot;&gt;참조&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9b61b2f901725762b56d16bf06bea0055df6804" translate="yes" xml:space="preserve">
          <source>The different behavior of files in the &lt;em&gt;tests&lt;/em&gt; directory is most noticeable when you have a set of helper functions that would be useful in multiple integration test files and you try to follow the steps in the &lt;a href=&quot;ch07-05-separating-modules-into-different-files&quot;&gt;&amp;ldquo;Separating Modules into Different Files&amp;rdquo;&lt;/a&gt; section of Chapter 7 to extract them into a common module. For example, if we create &lt;em&gt;tests/common.rs&lt;/em&gt; and place a function named &lt;code&gt;setup&lt;/code&gt; in it, we can add some code to &lt;code&gt;setup&lt;/code&gt; that we want to call from multiple test functions in multiple test files:</source>
          <target state="translated">여러 통합 테스트 파일에 유용한 일련의 헬퍼 함수가 있고 7 장의 &lt;a href=&quot;ch07-05-separating-modules-into-different-files&quot;&gt;&quot;모듈을 다른 파일로 분리&quot;&lt;/a&gt; 절의 단계를 수행 할 때 &lt;em&gt;tests&lt;/em&gt; 디렉토리 에있는 파일의 다른 동작 이 가장 두드러 집니다. 공통 모듈로 추출하십시오. 예를 들어, &lt;em&gt;tests / common.rs를&lt;/em&gt; 만들고 &lt;code&gt;setup&lt;/code&gt; 이라는 함수를 배치하면 여러 테스트 파일의 여러 테스트 함수에서 호출하려는 코드를 &lt;code&gt;setup&lt;/code&gt; 추가 할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5be1c02c26fe5ef598a5696a274160d696e7977" translate="yes" xml:space="preserve">
          <source>The different meanings of &lt;code&gt;unsafe&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 다른 의미</target>
        </trans-unit>
        <trans-unit id="1fd895f49df6ac41f021206eb05bd5dfbc8e5ada" translate="yes" xml:space="preserve">
          <source>The directories and files used for loading external file modules can be influenced with the &lt;code&gt;path&lt;/code&gt; attribute.</source>
          <target state="translated">외부 파일 모듈을로드하는 데 사용되는 디렉토리 및 파일은 &lt;code&gt;path&lt;/code&gt; 속성에 영향을받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e92ecf8e1ea3e2a6e4c02654c525e112d825547" translate="yes" xml:space="preserve">
          <source>The directory isn't empty.</source>
          <target state="translated">디렉토리가 비어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e9718c5436468359091854f47e29ace6b258c73" translate="yes" xml:space="preserve">
          <source>The discriminant enum from the example &lt;a href=&quot;#reprc-enums-with-fields&quot;&gt;earlier&lt;/a&gt; then becomes:</source>
          <target state="translated">&lt;a href=&quot;#reprc-enums-with-fields&quot;&gt;이전&lt;/a&gt; 예제의 판별 열거 형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5406bf9928b412a24605eecb2ec809ade9b2bfca" translate="yes" xml:space="preserve">
          <source>The discriminant of an enum variant may change if the enum definition changes. A discriminant of some variant will not change between compilations with the same compiler.</source>
          <target state="translated">열거 형 정의가 변경되면 열거 형 변형의 판별자가 변경 될 수 있습니다. 일부 변형의 판별자는 동일한 컴파일러를 사용하는 컴파일간에 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1e71495d678a5d4be21061931a65d8862bd4e7e" translate="yes" xml:space="preserve">
          <source>The distance being in bounds cannot rely on &quot;wrapping around&quot; the address space.</source>
          <target state="translated">경계에있는 거리는 주소 공간 &quot;래핑&quot;에 의존 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6c785ac664fd8d2346ca1bb482fcd8b5593d6af3" translate="yes" xml:space="preserve">
          <source>The distance between the pointers, &lt;strong&gt;in bytes&lt;/strong&gt;, cannot overflow an &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">포인터 사이의 거리 ( &lt;strong&gt;바이트&lt;/strong&gt; )는 &lt;code&gt;isize&lt;/code&gt; 를 오버플로 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bd1487c3b6f63cdfefd3896403e040d0a14037e5" translate="yes" xml:space="preserve">
          <source>The distance between the pointers, in bytes, must be an exact multiple of the size of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">포인터 사이의 거리 (바이트)는 &lt;code&gt;T&lt;/code&gt; 크기의 정확한 배수 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="c85eee3f8fcb1e3d7acfa8c71113a8ed01e9b6ce" translate="yes" xml:space="preserve">
          <source>The division assignment operator &lt;code&gt;/=&lt;/code&gt;.</source>
          <target state="translated">나누기 할당 연산자 &lt;code&gt;/=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fac0cbbb13a4ae4385140ac3ccea99961d57c224" translate="yes" xml:space="preserve">
          <source>The division operator &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">나누기 연산자 &lt;code&gt;/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4bae769945be3db52fcb8fef6b0f5ad9c54eef4" translate="yes" xml:space="preserve">
          <source>The documentation for this keyword is &lt;a href=&quot;https://github.com/rust-lang/rust/issues/34601&quot;&gt;not yet complete&lt;/a&gt;. Pull requests welcome!</source>
          <target state="translated">이 키워드에 대한 문서가 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/34601&quot;&gt;아직 완성되지 않았습니다&lt;/a&gt; . 풀 요청을 환영합니다!</target>
        </trans-unit>
        <trans-unit id="7092af2bcd91c441c2dfc4c8d572a11dfce60e91" translate="yes" xml:space="preserve">
          <source>The double colon (&lt;code&gt;::&lt;/code&gt;) is an operator that allows us to namespace this particular &lt;code&gt;from&lt;/code&gt; function under the &lt;code&gt;String&lt;/code&gt; type rather than using some sort of name like &lt;code&gt;string_from&lt;/code&gt;. We&amp;rsquo;ll discuss this syntax more in the &lt;a href=&quot;ch05-03-method-syntax#method-syntax&quot;&gt;&amp;ldquo;Method Syntax&amp;rdquo;&lt;/a&gt; section of Chapter 5 and when we talk about namespacing with modules in &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&amp;ldquo;Paths for Referring to an Item in the Module Tree&amp;rdquo;&lt;/a&gt; in Chapter 7.</source>
          <target state="translated">이중 콜론 ( &lt;code&gt;::&lt;/code&gt; ) 우리가이 특정 네임 스페이스 할 수있는 연산자 &lt;code&gt;from&lt;/code&gt; 세 이하 기능 &lt;code&gt;String&lt;/code&gt; 이 아니라 같은 이름의 일종 사용하는 것보다 유형 &lt;code&gt;string_from&lt;/code&gt; 을 . 이 구문에 대해서는 5 장의 &lt;a href=&quot;ch05-03-method-syntax#method-syntax&quot;&gt;&quot;방법 구문&quot;&lt;/a&gt; 섹션에서 그리고 7 장의 &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&quot;모듈 트리에서 항목을 참조하기위한 경로&quot;&lt;/a&gt; 에서 모듈로 이름 지정에 대해 이야기 할 때 자세히 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="27b2d1743e157ab144583c8c6b85ea9ad0092f0b" translate="yes" xml:space="preserve">
          <source>The downside of using &lt;code&gt;if let&lt;/code&gt; expressions is that the compiler doesn&amp;rsquo;t check exhaustiveness, whereas with &lt;code&gt;match&lt;/code&gt; expressions it does. If we omitted the last &lt;code&gt;else&lt;/code&gt; block and therefore missed handling some cases, the compiler would not alert us to the possible logic bug.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 표현식 을 사용하는 단점은 컴파일러가 철저한 검사를하지 않는 반면, &lt;code&gt;match&lt;/code&gt; 표현식을 사용하는 것입니다. 마지막 &lt;code&gt;else&lt;/code&gt; 블록 을 생략하고 일부 경우 처리를 놓친 경우 컴파일러는 가능한 논리 버그에 대해 경고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e387e6a833f24807236bb7fd7266c18e39a1df6d" translate="yes" xml:space="preserve">
          <source>The downside of using this technique is that &lt;code&gt;Wrapper&lt;/code&gt; is a new type, so it doesn&amp;rsquo;t have the methods of the value it&amp;rsquo;s holding. We would have to implement all the methods of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; directly on &lt;code&gt;Wrapper&lt;/code&gt; such that the methods delegate to &lt;code&gt;self.0&lt;/code&gt;, which would allow us to treat &lt;code&gt;Wrapper&lt;/code&gt; exactly like a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. If we wanted the new type to have every method the inner type has, implementing the &lt;code&gt;Deref&lt;/code&gt; trait (discussed in Chapter 15 in the &lt;a href=&quot;ch15-02-deref#treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;&amp;ldquo;Treating Smart Pointers Like Regular References with the &lt;code&gt;Deref&lt;/code&gt; Trait&amp;rdquo;&lt;/a&gt; section) on the &lt;code&gt;Wrapper&lt;/code&gt; to return the inner type would be a solution. If we don&amp;rsquo;t want the &lt;code&gt;Wrapper&lt;/code&gt; type to have all the methods of the inner type&amp;mdash;for example, to restrict the &lt;code&gt;Wrapper&lt;/code&gt; type&amp;rsquo;s behavior&amp;mdash;we would have to implement just the methods we do want manually.</source>
          <target state="translated">이 기술을 사용하는 단점은 &lt;code&gt;Wrapper&lt;/code&gt; 가 새로운 유형이므로 보유하고있는 가치의 방법이 없다는 것입니다. &lt;code&gt;Wrapper&lt;/code&gt; 에 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 의 모든 메소드를 직접 구현하여 메소드 가 &lt;code&gt;self.0&lt;/code&gt; 에 위임하도록해야합니다. 그러면 &lt;code&gt;Wrapper&lt;/code&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 처럼 정확하게 취급 할 수 있습니다. 만약 새로운 타입이 내부 타입이 가지고있는 모든 메소드를 갖기를 &lt;code&gt;Deref&lt;/code&gt; , &lt;code&gt;Wrapper&lt;/code&gt; 에 &lt;a href=&quot;ch15-02-deref#treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; 특성 ( Deref 특성을 가진 일반적인 참조와 같은 스마트 포인터 다루기 섹션 에서 15 장에서 논의 됨)을 구현하십시오.내부 유형을 반환하는 것이 해결책이 될 것입니다. &lt;code&gt;Wrapper&lt;/code&gt; 유형에 내부 유형의 모든 메소드 가 포함되지 않도록하려면 ( 예 : &lt;code&gt;Wrapper&lt;/code&gt; 유형의 동작 제한) 수동으로 원하는 메소드 만 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e7aa88c59ccdb8f5ae43f1abe07297a4d7ace58" translate="yes" xml:space="preserve">
          <source>The downside to implementing a macro instead of a function is that macro definitions are more complex than function definitions because you&amp;rsquo;re writing Rust code that writes Rust code. Due to this indirection, macro definitions are generally more difficult to read, understand, and maintain than function definitions.</source>
          <target state="translated">함수 대신 매크로를 구현하는 단점은 Rust 코드를 작성하는 Rust 코드를 작성하기 때문에 매크로 정의가 함수 정의보다 복잡하다는 것입니다. 이러한 간접적 특성으로 인해 매크로 정의는 일반적으로 함수 정의보다 읽고 이해하고 유지하기가 더 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="719fc8d49d59015d6dffe7ccc55e5816d1966b0e" translate="yes" xml:space="preserve">
          <source>The duration of one microsecond.</source>
          <target state="translated">1 마이크로 초의 지속 시간</target>
        </trans-unit>
        <trans-unit id="e68beeeb11183a3ff18abb9e6896356e66b6200f" translate="yes" xml:space="preserve">
          <source>The duration of one millisecond.</source>
          <target state="translated">1 밀리 초의 지속 시간</target>
        </trans-unit>
        <trans-unit id="e9d186359c1c80de39171fea4281a767f86db9c5" translate="yes" xml:space="preserve">
          <source>The duration of one nanosecond.</source>
          <target state="translated">1 나노초의 지속 시간</target>
        </trans-unit>
        <trans-unit id="926b58a37c99c224d9cf0ad023e9e79f2bae5af3" translate="yes" xml:space="preserve">
          <source>The duration of one second.</source>
          <target state="translated">1 초의 지속 시간</target>
        </trans-unit>
        <trans-unit id="51e82336197f20c9062a20d4490259f940ada0fe" translate="yes" xml:space="preserve">
          <source>The easiest fix is to rewrite your closure into a top-level function, or into a method. In some cases, you may also be able to have your closure call itself by capturing a &lt;code&gt;&amp;amp;Fn()&lt;/code&gt; object or &lt;code&gt;fn()&lt;/code&gt; pointer that refers to itself. That is permitting, since the closure would be invoking itself via a virtual call, and hence does not directly reference its own &lt;em&gt;type&lt;/em&gt;.</source>
          <target state="translated">가장 쉬운 해결 방법은 클로저를 최상위 함수 또는 메서드로 다시 작성하는 것입니다. 경우에 따라 자신을 참조하는 &lt;code&gt;&amp;amp;Fn()&lt;/code&gt; 객체 또는 &lt;code&gt;fn()&lt;/code&gt; 포인터를 캡처하여 클로저 호출 자체를 가질 수도 있습니다 . 클로저는 가상 호출을 통해 자체 호출되므로 자체 &lt;em&gt;유형을&lt;/em&gt; 직접 참조하지 않기 때문에 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="8b90152377c4d2fa6a58836b95414b3c64c66683" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashMap&lt;/code&gt; with a custom key type is to derive &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 키 유형으로 &lt;code&gt;HashMap&lt;/code&gt; 을 사용하는 가장 쉬운 방법 은 &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 를 파생시키는 것 입니다. &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; 도 도출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8fdc4a2a7876216a8a5156bcc124c1c5c1d13c54" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashMap&lt;/code&gt; with a custom key type is to derive &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 키 유형으로 &lt;code&gt;HashMap&lt;/code&gt; 을 사용하는 가장 쉬운 방법 은 &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 를 파생시키는 것 입니다. &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; 도 도출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2b835cd73ddea2cd4aee637c4f9c2cd855ee696f" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashSet&lt;/code&gt; with a custom type is to derive &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, this will in the future be implied by &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">커스텀 타입으로 &lt;code&gt;HashSet&lt;/code&gt; 을 사용하는 가장 쉬운 방법 은 &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 를 파생시키는 것 입니다. 우리는 또한 &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; 를 도출해야합니다 . 이것은 나중에 &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; 에&lt;/a&gt; 의해 암시 될 것입니다 .</target>
        </trans-unit>
        <trans-unit id="bcd32a61d8029373ce3811b4c81b01b04e2fcd8a" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashSet&lt;/code&gt; with a custom type is to derive &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, this will in the future be implied by &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">커스텀 타입으로 &lt;code&gt;HashSet&lt;/code&gt; 을 사용하는 가장 쉬운 방법 은 &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 를 파생시키는 것 입니다. 우리는 또한 &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; 를 도출해야합니다 . 이것은 나중에 &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; 에&lt;/a&gt; 의해 암시 될 것입니다 .</target>
        </trans-unit>
        <trans-unit id="4abca09eae529f079207e693c4204e4240160458" translate="yes" xml:space="preserve">
          <source>The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">반복자가 끝까지 소비되지 않더라도 요소 범위는 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="857f1367d5858bf310bc19ad475cfec76822e623" translate="yes" xml:space="preserve">
          <source>The element that was removed is returned, and the cursor is moved to point to the next element in the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17d488f8279ef9d0e051cac2f43dff0a68f18b2b" translate="yes" xml:space="preserve">
          <source>The elements are removed in arbitrary order.</source>
          <target state="translated">요소는 임의의 순서로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5fe5f813b6a2f233abc73bad03a94ec158695239" translate="yes" xml:space="preserve">
          <source>The elements at &lt;code&gt;old_len..new_len&lt;/code&gt; must be initialized.</source>
          <target state="translated">&lt;code&gt;old_len..new_len&lt;/code&gt; 의 요소를 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="2bafc31dee9d33ba4d10ed67ef0f71ab38bfff69" translate="yes" xml:space="preserve">
          <source>The elements of an &lt;a href=&quot;types/array&quot;&gt;array&lt;/a&gt; or owned &lt;a href=&quot;types/array&quot;&gt;slice&lt;/a&gt; are dropped from the first element to the last. *</source>
          <target state="translated">의 소자 &lt;a href=&quot;types/array&quot;&gt;어레이&lt;/a&gt; 또는 소유 &lt;a href=&quot;types/array&quot;&gt;슬라이스&lt;/a&gt; 마지막으로 첫 번째 요소에서 제외된다. *</target>
        </trans-unit>
        <trans-unit id="1e3e69cc26857f9c1293b40c529b047e54164338" translate="yes" xml:space="preserve">
          <source>The elements of an &lt;a href=&quot;types/array&quot;&gt;array&lt;/a&gt; or owned &lt;a href=&quot;types/slice&quot;&gt;slice&lt;/a&gt; are dropped from the first element to the last.</source>
          <target state="translated">의 소자 &lt;a href=&quot;types/array&quot;&gt;어레이&lt;/a&gt; 또는 소유 &lt;a href=&quot;types/slice&quot;&gt;슬라이스&lt;/a&gt; 마지막으로 첫 번째 요소에서 제외된다.</target>
        </trans-unit>
        <trans-unit id="2aa9bb19de05cfdf90da669db74c8f4ff87b16d5" translate="yes" xml:space="preserve">
          <source>The elements yielded by &lt;code&gt;DoubleEndedIterator&lt;/code&gt;'s methods may differ from the ones yielded by &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;'s methods:</source>
          <target state="translated">&lt;code&gt;DoubleEndedIterator&lt;/code&gt; 의 메서드에 의해 생성 된 요소는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 메서드에 의해 생성 된 요소 와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88efd616f1a1b2e8d8f2dcc3a848a8c623471404" translate="yes" xml:space="preserve">
          <source>The elision rules don&amp;rsquo;t provide full inference. If Rust deterministically applies the rules but there is still ambiguity as to what lifetimes the references have, the compiler won&amp;rsquo;t guess what the lifetime of the remaining references should be. In this case, instead of guessing, the compiler will give you an error that you can resolve by adding the lifetime annotations that specify how the references relate to each other.</source>
          <target state="translated">소거 규칙은 완전한 추론을 제공하지 않습니다. Rust가 결정적으로 규칙을 적용하지만 참조의 수명에 대해 모호한 경우 컴파일러는 나머지 참조의 수명이 무엇인지 추측하지 않습니다. 이 경우 컴파일러는 추측하는 대신 참조가 서로 관련되는 방식을 지정하는 수명 주석을 추가하여 해결할 수있는 오류를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3e3b658969dac70797ae99e22406a5919df5b0c6" translate="yes" xml:space="preserve">
          <source>The entire expression uses the given values for the fields that were specified and moves or copies the remaining fields from the base expression. As with all struct expressions, all of the fields of the struct must be &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visible&lt;/a&gt;, even those not explicitly named.</source>
          <target state="translated">전체 표현식은 지정된 필드에 지정된 값을 사용하고 기본 표현식에서 나머지 필드를 이동하거나 복사합니다. 모든 구조체 표현식과 마찬가지로 구조체의 모든 필드를 &lt;a href=&quot;../visibility-and-privacy&quot;&gt;볼 수&lt;/a&gt; 있어야합니다 ( 명시 적으로 이름이 지정되지 않은 필드 도 포함).</target>
        </trans-unit>
        <trans-unit id="a0574dfce03935016b1e7370699d140878e68385" translate="yes" xml:space="preserve">
          <source>The entire file name if the file name begins with &lt;code&gt;.&lt;/code&gt; and has no other &lt;code&gt;.&lt;/code&gt;s within;</source>
          <target state="translated">파일 이름이로 시작하면 전체 파일 이름입니다 &lt;code&gt;.&lt;/code&gt; 그리고 다른 사람이 없습니다 &lt;code&gt;.&lt;/code&gt; 내;</target>
        </trans-unit>
        <trans-unit id="e83cf0228defdcd6e7afea0984d3278d36eab74c" translate="yes" xml:space="preserve">
          <source>The entire file name if there is no embedded &lt;code&gt;.&lt;/code&gt;;</source>
          <target state="translated">포함되지 않은 경우 전체 파일 이름 &lt;code&gt;.&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="3fa274546f438640798ab62aae39ac18398db5cc" translate="yes" xml:space="preserve">
          <source>The entire function</source>
          <target state="translated">전체 기능</target>
        </trans-unit>
        <trans-unit id="8a5d709e7f69a77cb8061cae38e47a941e97332f" translate="yes" xml:space="preserve">
          <source>The entire function body.</source>
          <target state="translated">전체 기능 본문.</target>
        </trans-unit>
        <trans-unit id="5c15c39c685d0906fec325e3d5c2bea1c6eb708a" translate="yes" xml:space="preserve">
          <source>The entire function scope is the outer most scope.</source>
          <target state="translated">전체 함수 범위가 가장 바깥 쪽 범위입니다.</target>
        </trans-unit>
        <trans-unit id="9b8eedec31f30287b3b74ad1f2675a525e2c3cf5" translate="yes" xml:space="preserve">
          <source>The entire hash map is generic over a key type &lt;code&gt;K&lt;/code&gt;. Because these keys are stored with the hash map, this type has to own the key&amp;rsquo;s data. When inserting a key-value pair, the map is given such a &lt;code&gt;K&lt;/code&gt; and needs to find the correct hash bucket and check if the key is already present based on that &lt;code&gt;K&lt;/code&gt;. It therefore requires &lt;code&gt;K: Hash + Eq&lt;/code&gt;.</source>
          <target state="translated">전체 해시 맵은 키 유형 &lt;code&gt;K&lt;/code&gt; 에 일반적 입니다. 이러한 키는 해시 맵과 함께 저장되므로이 유형은 키의 데이터를 소유해야합니다. 키-값 쌍을 삽입 할 때 맵에 이러한 &lt;code&gt;K&lt;/code&gt; 가 지정 되고 올바른 해시 버킷을 찾아 해당 &lt;code&gt;K&lt;/code&gt; 를 기반으로 키가 이미 존재하는지 확인해야합니다 . 따라서 &lt;code&gt;K: Hash + Eq&lt;/code&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="0297c1c788a21e67f6b7fde15406ec3888485937" translate="yes" xml:space="preserve">
          <source>The entire memory range of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects.</source>
          <target state="translated">이 슬라이스의 전체 메모리 범위는 할당 된 단일 객체 내에 포함되어야합니다! 슬라이스는 할당 된 여러 개체에 걸쳐있을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d250d768cfabd095635656557072ab76a1e3cbad" translate="yes" xml:space="preserve">
          <source>The entire memory range of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects. See &lt;a href=&quot;#incorrect-usage&quot;&gt;below&lt;/a&gt; for an example incorrectly not taking this into account.</source>
          <target state="translated">이 슬라이스의 전체 메모리 범위는 할당 된 단일 객체 내에 포함되어야합니다! 슬라이스는 할당 된 여러 개체에 걸쳐있을 수 없습니다. 이를 고려하지 않은 예는 &lt;a href=&quot;#incorrect-usage&quot;&gt;아래&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="97dea0260f138033ef7cf2f5ca57a634d6eea616" translate="yes" xml:space="preserve">
          <source>The entry point of the program was marked as &lt;code&gt;async&lt;/code&gt;.</source>
          <target state="translated">프로그램의 진입 점은 &lt;code&gt;async&lt;/code&gt; 로 표시되었습니다 .</target>
        </trans-unit>
        <trans-unit id="82f98df6718e5a9d6fd411d1cc853597af7467ed" translate="yes" xml:space="preserve">
          <source>The error and the note tell the story: Rust strings don&amp;rsquo;t support indexing. But why not? To answer that question, we need to discuss how Rust stores strings in memory.</source>
          <target state="translated">오류와 메모는 스토리를 알려줍니다. 녹 문자열은 인덱싱을 지원하지 않습니다. 그런데 왜 안 되 겠어요? 이 질문에 답하기 위해 Rust가 어떻게 문자열을 메모리에 저장하는지 논의해야합니다.</target>
        </trans-unit>
        <trans-unit id="41a72aa86a9d9e55bed7f9841f1b9fdc25696e6c" translate="yes" xml:space="preserve">
          <source>The error happens on numeric literals and on numeric bindings without an identified concrete type:</source>
          <target state="translated">이 오류는 식별 된 구체적인 유형이없는 숫자 리터럴 및 숫자 바인딩에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1decc58ff466451824639b9b2033b046dfa94fee" translate="yes" xml:space="preserve">
          <source>The error happens on numeric literals:</source>
          <target state="translated">숫자 리터럴에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="39121a17de405ba30c8238c549d55b70becaf449" translate="yes" xml:space="preserve">
          <source>The error indicates that Rust expected a &lt;code&gt;bool&lt;/code&gt; but got an integer. Unlike languages such as Ruby and JavaScript, Rust will not automatically try to convert non-Boolean types to a Boolean. You must be explicit and always provide &lt;code&gt;if&lt;/code&gt; with a Boolean as its condition. If we want the &lt;code&gt;if&lt;/code&gt; code block to run only when a number is not equal to &lt;code&gt;0&lt;/code&gt;, for example, we can change the &lt;code&gt;if&lt;/code&gt; expression to the following:</source>
          <target state="translated">이 오류는 Rust가 &lt;code&gt;bool&lt;/code&gt; 예상 했지만 정수를 얻었음을 나타냅니다 . Ruby 및 JavaScript와 같은 언어와 달리 Rust는 부울이 아닌 유형을 부울로 자동 변환하지 않습니다. 당신은 명시 적 항상 제공해야 &lt;code&gt;if&lt;/code&gt; 의 조건으로 부울로. 우리가 원하는 경우 &lt;code&gt;if&lt;/code&gt; 숫자가 같지 않은 경우에만 코드 블록을 실행할 &lt;code&gt;0&lt;/code&gt; , 예를 들어, 우리는 변경할 수 &lt;code&gt;if&lt;/code&gt; 다음 식을 :</target>
        </trans-unit>
        <trans-unit id="82fe814b563c83c1ad42c2a44464d60e45abeb59" translate="yes" xml:space="preserve">
          <source>The error message indicates that the cause of the error is that you &lt;code&gt;cannot assign twice to immutable variable x&lt;/code&gt;, because you tried to assign a second value to the immutable &lt;code&gt;x&lt;/code&gt; variable.</source>
          <target state="translated">오류 메시지는 오류의 원인은 당신이 있음을 나타냅니다 &lt;code&gt;cannot assign twice to immutable variable x&lt;/code&gt; 당신은 불변에 두 번째 값을 할당하려하기 때문에, &lt;code&gt;x&lt;/code&gt; 변수를.</target>
        </trans-unit>
        <trans-unit id="1acd99d552c691a91137d21fedf0cc394ac8a4d0" translate="yes" xml:space="preserve">
          <source>The error message states that the &lt;code&gt;counter&lt;/code&gt; value is moved into the closure and then captured when we call &lt;code&gt;lock&lt;/code&gt;. That description sounds like what we wanted, but it&amp;rsquo;s not allowed!</source>
          <target state="translated">오류 메시지는 &lt;code&gt;counter&lt;/code&gt; 값이 클로저로 이동 한 다음 &lt;code&gt;lock&lt;/code&gt; 을 호출 할 때 캡처 되었음을 나타냅니다 . 그 설명은 우리가 원하는 것 같지만 허용되지 않습니다!</target>
        </trans-unit>
        <trans-unit id="5bb7a0ad71457e0f1d6ce226ce7b55ec5697ceba" translate="yes" xml:space="preserve">
          <source>The error message states that the &lt;code&gt;counter&lt;/code&gt; value was moved in the previous iteration of the loop. So Rust is telling us that we can&amp;rsquo;t move the ownership of lock &lt;code&gt;counter&lt;/code&gt; into multiple threads. Let&amp;rsquo;s fix the compiler error with a multiple-ownership method we discussed in Chapter 15.</source>
          <target state="translated">오류 메시지는 &lt;code&gt;counter&lt;/code&gt; 값이 루프의 이전 반복에서 이동 되었음을 나타냅니다 . 따라서 Rust는 잠금 &lt;code&gt;counter&lt;/code&gt; 의 소유권 을 여러 스레드로 이동할 수 없다고 말합니다 . 15 장에서 논의한 다중 소유권 방식으로 컴파일러 오류를 수정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="6326b5d7f5ddab487c6090e5e84a18d25a0a3db6" translate="yes" xml:space="preserve">
          <source>The error messages say that module &lt;code&gt;hosting&lt;/code&gt; is private. In other words, we have the correct paths for the &lt;code&gt;hosting&lt;/code&gt; module and the &lt;code&gt;add_to_waitlist&lt;/code&gt; function, but Rust won&amp;rsquo;t let us use them because it doesn&amp;rsquo;t have access to the private sections.</source>
          <target state="translated">오류 메시지는 모듈 &lt;code&gt;hosting&lt;/code&gt; 이 비공개라는 것을 나타냅니다. 다시 말해, &lt;code&gt;hosting&lt;/code&gt; 모듈과 &lt;code&gt;add_to_waitlist&lt;/code&gt; 함수에 대한 올바른 경로가 있지만 Rust는 개인 섹션에 액세스 할 수 없으므로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8eb6e3e38ad85be87f507639136fdec21b108288" translate="yes" xml:space="preserve">
          <source>The error occurs because &lt;code&gt;foo&lt;/code&gt; accepts a closure that takes an &lt;code&gt;i32&lt;/code&gt; argument, but in &lt;code&gt;main&lt;/code&gt;, it is passed a closure with a &lt;code&gt;&amp;amp;str&lt;/code&gt; argument.</source>
          <target state="translated">오류는 &lt;code&gt;foo&lt;/code&gt; 가 &lt;code&gt;i32&lt;/code&gt; 인수를 받는 클로저를 받아들이지 만 &lt;code&gt;main&lt;/code&gt; 에서는 &lt;code&gt;&amp;amp;str&lt;/code&gt; 인수 와 함께 클로저가 전달 되기 때문에 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="4df536d23e48c26eec2d844083fbc5169ab15de6" translate="yes" xml:space="preserve">
          <source>The error occurs because keyword &lt;code&gt;yield&lt;/code&gt; can only be used inside the generator literal. This can be fixed by constructing the generator correctly.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; 키워드 는 생성기 리터럴 내에서만 사용할 수 있기 때문에 오류가 발생합니다 . 이것은 발전기를 올바르게 구성하여 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bce45a967fbcca42003bd3fc6c351711632526a" translate="yes" xml:space="preserve">
          <source>The error references the &lt;code&gt;Sized&lt;/code&gt; trait again! Rust doesn&amp;rsquo;t know how much space it will need to store the closure. We saw a solution to this problem earlier. We can use a trait object:</source>
          <target state="translated">오류는 &lt;code&gt;Sized&lt;/code&gt; 특성을 다시 참조 합니다! 녹은 클로저를 보관할 공간이 얼마나되는지 모릅니다. 우리는이 문제에 대한 해결책을 일찍 보았습니다. 특성 오브젝트를 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="687172b839a6f9ace430c7922b4119fecbbc273c" translate="yes" xml:space="preserve">
          <source>The error says we&amp;rsquo;re not allowed to mutate a variable&amp;rsquo;s type:</source>
          <target state="translated">오류는 변수 유형을 변경할 수 없다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="4c799801c95c3499262c7f795808c56dd04d3f03" translate="yes" xml:space="preserve">
          <source>The error shows that for &lt;code&gt;result&lt;/code&gt; to be valid for the &lt;code&gt;println!&lt;/code&gt; statement, &lt;code&gt;string2&lt;/code&gt; would need to be valid until the end of the outer scope. Rust knows this because we annotated the lifetimes of the function parameters and return values using the same lifetime parameter &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">오류는 &lt;code&gt;result&lt;/code&gt; 가 &lt;code&gt;println!&lt;/code&gt; 유효 함을 나타냅니다 ! statement, &lt;code&gt;string2&lt;/code&gt; 는 외부 범위가 끝날 때까지 유효해야합니다. Rust는 함수 매개 변수의 수명에 주석을 달고 동일한 수명 매개 변수 &lt;code&gt;'a&lt;/code&gt; 를 사용하여 값을 반환하기 때문에 이것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="81dd6345e63f7b9b970ec324dc927c2a78ce87e8" translate="yes" xml:space="preserve">
          <source>The error shows that you can&amp;rsquo;t use the keyword &lt;code&gt;match&lt;/code&gt; as the function identifier. To use &lt;code&gt;match&lt;/code&gt; as a function name, you need to use the raw identifier syntax, like this:</source>
          <target state="translated">오류는 키워드 &lt;code&gt;match&lt;/code&gt; 을 기능 식별자로 사용할 수 없음을 나타냅니다 . &lt;code&gt;match&lt;/code&gt; 를 함수 이름으로 사용하려면 다음 과 같이 원시 식별자 구문을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="17031b6288809d4b66c77a71348fe05200b2e1e5" translate="yes" xml:space="preserve">
          <source>The error shows this type &amp;ldquo;has infinite size.&amp;rdquo; The reason is that we&amp;rsquo;ve defined &lt;code&gt;List&lt;/code&gt; with a variant that is recursive: it holds another value of itself directly. As a result, Rust can&amp;rsquo;t figure out how much space it needs to store a &lt;code&gt;List&lt;/code&gt; value. Let&amp;rsquo;s break down why we get this error a bit. First, let&amp;rsquo;s look at how Rust decides how much space it needs to store a value of a non-recursive type.</source>
          <target state="translated">오류는이 유형이 &quot;무한 크기&quot;임을 나타냅니다. 그 이유는 우리 가 재귀적인 변형을 사용하여 &lt;code&gt;List&lt;/code&gt; 를 정의했기 때문입니다 . 결과적으로 Rust는 &lt;code&gt;List&lt;/code&gt; 값 을 저장하는 데 필요한 공간을 파악할 수 없습니다 . 이 오류가 발생하는 이유를 자세히 살펴 보겠습니다. 먼저 Rust가 비 재귀 유형의 값을 저장하는 데 필요한 공간의 양을 결정하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ddd69ec9cc85fcc63997c43bed364cf16ee6b3f9" translate="yes" xml:space="preserve">
          <source>The error tells us we can&amp;rsquo;t call &lt;code&gt;join&lt;/code&gt; because we only have a mutable borrow of each &lt;code&gt;worker&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt; takes ownership of its argument. To solve this issue, we need to move the thread out of the &lt;code&gt;Worker&lt;/code&gt; instance that owns &lt;code&gt;thread&lt;/code&gt; so &lt;code&gt;join&lt;/code&gt; can consume the thread. We did this in Listing 17-15: if &lt;code&gt;Worker&lt;/code&gt; holds an &lt;code&gt;Option&amp;lt;thread::JoinHandle&amp;lt;()&amp;gt;&amp;gt;&lt;/code&gt; instead, we can call the &lt;code&gt;take&lt;/code&gt; method on the &lt;code&gt;Option&lt;/code&gt; to move the value out of the &lt;code&gt;Some&lt;/code&gt; variant and leave a &lt;code&gt;None&lt;/code&gt; variant in its place. In other words, a &lt;code&gt;Worker&lt;/code&gt; that is running will have a &lt;code&gt;Some&lt;/code&gt; variant in &lt;code&gt;thread&lt;/code&gt;, and when we want to clean up a &lt;code&gt;Worker&lt;/code&gt;, we&amp;rsquo;ll replace &lt;code&gt;Some&lt;/code&gt; with &lt;code&gt;None&lt;/code&gt; so the &lt;code&gt;Worker&lt;/code&gt; doesn&amp;rsquo;t have a thread to run.</source>
          <target state="translated">이 오류는 각 &lt;code&gt;worker&lt;/code&gt; 의 변경 가능한 차용 만 있고 &lt;code&gt;join&lt;/code&gt; 은 인수에 대한 소유권을 가지기 때문에 &lt;code&gt;join&lt;/code&gt; 호출 할 수 없음을 나타 냅니다. 이 문제를 해결하기 위해, 우리는의 스레드를 이동해야하는 &lt;code&gt;Worker&lt;/code&gt; 소유 예를 &lt;code&gt;thread&lt;/code&gt; 너무 &lt;code&gt;join&lt;/code&gt; 스레드를 소비 할 수 있습니다. 우리는 목록 17-15에서 이런 짓을 : 경우 &lt;code&gt;Worker&lt;/code&gt; 보유 &lt;code&gt;Option&amp;lt;thread::JoinHandle&amp;lt;()&amp;gt;&amp;gt;&lt;/code&gt; 대신에, 우리는 호출 할 수 있습니다 &lt;code&gt;take&lt;/code&gt; 온 방법 &lt;code&gt;Option&lt;/code&gt; 의 값을 이동하는 &lt;code&gt;Some&lt;/code&gt; 변형하고 떠나 &lt;code&gt;None&lt;/code&gt; 에 변형을 그 장소. 다시 말해, &lt;code&gt;Worker&lt;/code&gt; 실행중인 &lt;code&gt;thread&lt;/code&gt; 에는 &lt;code&gt;Some&lt;/code&gt; 변형이 있으며 &lt;code&gt;Worker&lt;/code&gt; 를 정리 하려면 &lt;code&gt;Worker&lt;/code&gt; 에 실행할 스레드가 없도록 &lt;code&gt;Some&lt;/code&gt; 을 &lt;code&gt;None&lt;/code&gt; 으로 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="58b8d8f068cf467e7f55c896bbdf137f3a755bf5" translate="yes" xml:space="preserve">
          <source>The error type for &lt;code&gt;try_reserve&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;try_reserve&lt;/code&gt; 메소드 의 오류 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="458fb320b83d2d5563146d6c64a5e9086c1cdbe5" translate="yes" xml:space="preserve">
          <source>The error type for I/O operations of the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt;, and associated traits.</source>
          <target state="translated">&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt; 및 관련 특성의 I / O 작업에 대한 오류 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="3e8c3a7432541c640c48492379ea610ecb40f6ae" translate="yes" xml:space="preserve">
          <source>The error type for errors that can never happen.</source>
          <target state="translated">절대 발생할 수없는 오류의 오류 유형입니다.</target>
        </trans-unit>
        <trans-unit id="fdb319ec59d1f1964ec642ac851b7301cdf60e57" translate="yes" xml:space="preserve">
          <source>The error type for operations interacting with environment variables. Possibly returned from &lt;a href=&quot;fn.var&quot;&gt;&lt;code&gt;env::var()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">환경 변수와 상호 작용하는 작업의 오류 유형입니다. &lt;a href=&quot;fn.var&quot;&gt; &lt;code&gt;env::var()&lt;/code&gt; &lt;/a&gt; 에서 반환되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="751842d7baf0779231030e01a15db69a4f03c6bc" translate="yes" xml:space="preserve">
          <source>The error type for operations interacting with environment variables. Possibly returned from the &lt;a href=&quot;fn.var&quot;&gt;&lt;code&gt;env::var&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">환경 변수와 상호 작용하는 작업의 오류 유형입니다. &lt;a href=&quot;fn.var&quot;&gt; &lt;code&gt;env::var&lt;/code&gt; &lt;/a&gt; 함수 에서 반환되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11ea1ae6c021101c095eab4ba4b755be8b16c063" translate="yes" xml:space="preserve">
          <source>The error type for operations on the &lt;code&gt;PATH&lt;/code&gt; variable. Possibly returned from &lt;a href=&quot;fn.join_paths&quot;&gt;&lt;code&gt;env::join_paths()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;PATH&lt;/code&gt; 변수 에 대한 작업의 오류 유형입니다 . &lt;a href=&quot;fn.join_paths&quot;&gt; &lt;code&gt;env::join_paths()&lt;/code&gt; &lt;/a&gt; 에서 반환되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04e8342895bd312f045a40780238aabb9ef5de36" translate="yes" xml:space="preserve">
          <source>The error type for operations on the &lt;code&gt;PATH&lt;/code&gt; variable. Possibly returned from the &lt;a href=&quot;fn.join_paths&quot;&gt;&lt;code&gt;env::join_paths&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;PATH&lt;/code&gt; 변수 조작에 대한 오류 유형 . &lt;a href=&quot;fn.join_paths&quot;&gt; &lt;code&gt;env::join_paths&lt;/code&gt; &lt;/a&gt; 함수 에서 반환 되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92c7e92ce900890826a3bdc04f0bdb6f93a2ae4e" translate="yes" xml:space="preserve">
          <source>The error type returned when a checked integral type conversion fails.</source>
          <target state="translated">확인 된 정수 유형 변환에 실패하면 오류 유형이 리턴되었습니다.</target>
        </trans-unit>
        <trans-unit id="7c03030b0922657a2b23ad871594bf872bfa86e8" translate="yes" xml:space="preserve">
          <source>The error type returned when a conversion from a slice to an array fails.</source>
          <target state="translated">슬라이스에서 배열로의 변환에 실패하면 오류 유형이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5bd755e234651b9d8db0dad82d899820eb73c1c6" translate="yes" xml:space="preserve">
          <source>The error type returned when a conversion from u32 to char fails.</source>
          <target state="translated">u32에서 char 로의 변환이 실패하면 오류 유형이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="74bd671788812266d70e1e6379cd71d68b83bdd8" translate="yes" xml:space="preserve">
          <source>The error type that results from applying the try operator (&lt;code&gt;?&lt;/code&gt;) to a &lt;code&gt;None&lt;/code&gt; value. If you wish to allow &lt;code&gt;x?&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;) to be converted into your error type, you can implement &lt;code&gt;impl From&amp;lt;NoneError&amp;gt;&lt;/code&gt; for &lt;code&gt;YourErrorType&lt;/code&gt;. In that case, &lt;code&gt;x?&lt;/code&gt; within a function that returns &lt;code&gt;Result&amp;lt;_, YourErrorType&amp;gt;&lt;/code&gt; will translate a &lt;code&gt;None&lt;/code&gt; value into an &lt;code&gt;Err&lt;/code&gt; result.</source>
          <target state="translated">try 연산자 ( &lt;code&gt;?&lt;/code&gt; )를 &lt;code&gt;None&lt;/code&gt; 값에 적용한 결과 오류 유형입니다 . &lt;code&gt;x?&lt;/code&gt; 를 허용하려면 ? (여기서 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ) 오류 유형으로 변환되어 &lt;code&gt;impl From&amp;lt;NoneError&amp;gt;&lt;/code&gt; 대해 impl From &amp;lt;NoneError&amp;gt; 을 &lt;code&gt;YourErrorType&lt;/code&gt; 있습니다. 이 경우 &lt;code&gt;x?&lt;/code&gt; &lt;code&gt;Result&amp;lt;_, YourErrorType&amp;gt;&lt;/code&gt; 를 반환하는 함수 내 에서 YourErrorType&amp;gt; 은 &lt;code&gt;None&lt;/code&gt; 값을 &lt;code&gt;Err&lt;/code&gt; 결과 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="620e9e66f647e7af133c1492023ad78f941762d1" translate="yes" xml:space="preserve">
          <source>The error type which is returned from formatting a message into a stream.</source>
          <target state="translated">메시지 형식화에서 스트림으로 리턴되는 오류 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d4672a685f085da2d7d7f62486ff4649fbce70a5" translate="yes" xml:space="preserve">
          <source>The errors in Listing 7-6 say that the &lt;code&gt;add_to_waitlist&lt;/code&gt; function is private. The privacy rules apply to structs, enums, functions, and methods as well as modules.</source>
          <target state="translated">목록 7-6의 오류는 &lt;code&gt;add_to_waitlist&lt;/code&gt; 함수가 전용 이라는 것을 나타 냅니다 . 개인 정보 보호 규칙은 모듈뿐만 아니라 구조체, 열거 형, 함수 및 방법에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5c9b02894ffaf56c3eee190bd9f4d3e5a18ff962" translate="yes" xml:space="preserve">
          <source>The exact behavior on locking a mutex in the thread which already holds the lock is left unspecified. However, this function will not return on the second call (it might panic or deadlock, for example).</source>
          <target state="translated">이미 잠금을 보유하고있는 스레드에서 뮤텍스를 잠그는 정확한 동작은 지정되지 않은 채로 있습니다. 그러나이 함수는 두 번째 호출에서 반환되지 않습니다 (예 : 패닉 또는 교착 상태 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="ec573024d9a369fea8772d4967a09d1e972fae0a" translate="yes" xml:space="preserve">
          <source>The exact character(s)</source>
          <target state="translated">정확한 캐릭터</target>
        </trans-unit>
        <trans-unit id="df2f57248767dbedd045941faa73ddbe53944b27" translate="yes" xml:space="preserve">
          <source>The exact order may be useful for tracking external state, like an index.</source>
          <target state="translated">정확한 순서는 색인과 같은 외부 상태를 추적하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fe495e6414bd43e7bea5f0003cca50741a5b59b" translate="yes" xml:space="preserve">
          <source>The exact output printed by this macro should not be relied upon and is subject to future changes.</source>
          <target state="translated">이 매크로에 의해 인쇄 된 정확한 출력은 신뢰할 수 없으며 향후 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="469498f0144088c9a82cccca15de67704811a8dd" translate="yes" xml:space="preserve">
          <source>The exact text, of course, depends on what files you have in &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">정확한 텍스트는 물론 어떤 파일에 있는지에 따라 다릅니다 &lt;code&gt;.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="395c851d3758c4daf594b9f6b458c5ca4cd7434f" translate="yes" xml:space="preserve">
          <source>The example in Listing 13-14 separates the creation of the iterator from the use of the iterator in the &lt;code&gt;for&lt;/code&gt; loop. The iterator is stored in the &lt;code&gt;v1_iter&lt;/code&gt; variable, and no iteration takes place at that time. When the &lt;code&gt;for&lt;/code&gt; loop is called using the iterator in &lt;code&gt;v1_iter&lt;/code&gt;, each element in the iterator is used in one iteration of the loop, which prints out each value.</source>
          <target state="translated">Listing 13-14의 예제는 반복자 작성을 &lt;code&gt;for&lt;/code&gt; 루프 에서 반복자 사용과 분리합니다 . 반복자는 &lt;code&gt;v1_iter&lt;/code&gt; 변수에 저장되며 그 시점 에는 반복이 수행되지 않습니다. 경우 &lt;code&gt;for&lt;/code&gt; 루프의 반복기 사용이라고 &lt;code&gt;v1_iter&lt;/code&gt; 을 , 반복기의 각 요소는 각각의 프린트 아웃 값 루프의 일 반복에서 사용된다.</target>
        </trans-unit>
        <trans-unit id="e88d69a7ee7e1056409be12e179c7703287290b1" translate="yes" xml:space="preserve">
          <source>The exception to this idiom is if we&amp;rsquo;re bringing two items with the same name into scope with &lt;code&gt;use&lt;/code&gt; statements, because Rust doesn&amp;rsquo;t allow that. Listing 7-15 shows how to bring two &lt;code&gt;Result&lt;/code&gt; types into scope that have the same name but different parent modules and how to refer to them.</source>
          <target state="translated">이 관용구의 예외는 Rust가 허용하지 않기 때문에 이름이 같은 두 항목을 &lt;code&gt;use&lt;/code&gt; 문 으로 범위에 넣는 경우 입니다. 목록 7-15는 이름은 같지만 상위 모듈이 다른 두 가지 &lt;code&gt;Result&lt;/code&gt; 유형을 범위 로 가져 오는 방법과이를 참조하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f9ff06ceaf161b4f26d0944c142b9739231935eb" translate="yes" xml:space="preserve">
          <source>The exception to this is the unit tuple (&lt;code&gt;()&lt;/code&gt;) which is guaranteed as a zero-sized type to have a size of 0 and an alignment of 1.</source>
          <target state="translated">단 , 크기가 0이고 정렬이 1 인 크기가 0 인 단위 튜플 ( &lt;code&gt;()&lt;/code&gt; ) 은 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="3dc57cf649d183700b8e68c720c692cad27e1162" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;&amp;amp;'static str&lt;/code&gt;, and the returned file is not the invocation of the &lt;code&gt;file!&lt;/code&gt; macro itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;file!&lt;/code&gt; macro.</source>
          <target state="translated">확장 된 표현식의 유형은 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 이며 리턴 된 파일은 파일의 호출이 아닙니다 &lt;code&gt;file!&lt;/code&gt; 매크로 자체가 아니라 &lt;code&gt;file!&lt;/code&gt; 의 호출로 이어지는 첫 번째 매크로 호출 ! 매크로.</target>
        </trans-unit>
        <trans-unit id="2027bedff965dc7817b0dd952d1fc211920c5f6d" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;u32&lt;/code&gt; and is 1-based, so the first column in each line evaluates to 1, the second to 2, etc. This is consistent with error messages by common compilers or popular editors. The returned column is &lt;em&gt;not necessarily&lt;/em&gt; the line of the &lt;code&gt;column!&lt;/code&gt; invocation itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;column!&lt;/code&gt; macro.</source>
          <target state="translated">확장 된 표현식의 유형은 &lt;code&gt;u32&lt;/code&gt; 이며 1부터 시작하므로 각 행의 첫 번째 열은 1, 두 번째에서 2 등으로 평가됩니다. 이는 일반적인 컴파일러 또는 널리 사용되는 편집기의 오류 메시지와 일치합니다. 반환 된 열은 &lt;em&gt;필요하지&lt;/em&gt; 의 라인 &lt;code&gt;column!&lt;/code&gt; 호출 자체가 아니라 &lt;code&gt;column!&lt;/code&gt; 호출로 이어지는 첫 번째 매크로 호출 ! 매크로.</target>
        </trans-unit>
        <trans-unit id="b0b06f58ec99c372d86a17a34c7166fa5de08c27" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;u32&lt;/code&gt; and is 1-based, so the first line in each file evaluates to 1, the second to 2, etc. This is consistent with error messages by common compilers or popular editors. The returned line is &lt;em&gt;not necessarily&lt;/em&gt; the line of the &lt;code&gt;line!&lt;/code&gt; invocation itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;line!&lt;/code&gt; macro.</source>
          <target state="translated">확장 된 표현식은 &lt;code&gt;u32&lt;/code&gt; 유형 이며 1 기반이므로 각 파일의 첫 번째 줄은 1, 두 번째에서 2 등으로 평가됩니다. 이는 일반적인 컴파일러 또는 일반적인 편집기의 오류 메시지와 일치합니다. 리턴 된 라인이 &lt;em&gt;반드시&lt;/em&gt; 라인의 라인은 &lt;em&gt;아닙니다 &lt;/em&gt; &lt;code&gt;line!&lt;/code&gt; 호출 자체가 아니라 &lt;code&gt;line!&lt;/code&gt; 의 호출로 이어지는 첫 번째 매크로 호출 ! 매크로.</target>
        </trans-unit>
        <trans-unit id="6dec360ada9c00c421ed26b5b352f032e17122ed" translate="yes" xml:space="preserve">
          <source>The expected cost of &lt;code&gt;push&lt;/code&gt;, averaged over every possible ordering of the elements being pushed, and over a sufficiently large number of pushes, is &lt;em&gt;O&lt;/em&gt;(1). This is the most meaningful cost metric when pushing elements that are &lt;em&gt;not&lt;/em&gt; already in any sorted pattern.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; 되는 요소의 가능한 모든 순서와 충분히 많은 푸시 횟수에 대해 평균 을 내는 예상 푸시 비용 은 &lt;em&gt;O&lt;/em&gt; (1)입니다. 이것은 아직 정렬 된 패턴 이 &lt;em&gt;아닌&lt;/em&gt; 요소를 푸시 할 때 가장 의미있는 비용 메트릭 입니다.</target>
        </trans-unit>
        <trans-unit id="606b0f6565bb5e33a7e793c7978e5b02d8b8d28b" translate="yes" xml:space="preserve">
          <source>The expected cost of &lt;code&gt;push&lt;/code&gt;, averaged over every possible ordering of the elements being pushed, and over a sufficiently large number of pushes, is O(1). This is the most meaningful cost metric when pushing elements that are &lt;em&gt;not&lt;/em&gt; already in any sorted pattern.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; 되는 요소의 가능한 모든 순서와 평균적으로 충분히 많은 푸시에 대해 예상되는 푸시 비용 은 O (1)입니다. 이것은 정렬 된 패턴 이 &lt;em&gt;아닌&lt;/em&gt; 요소를 푸시 할 때 가장 의미있는 비용 메트릭 입니다.</target>
        </trans-unit>
        <trans-unit id="a72ec7eef34f0a8ffd7d99e9cfce2da0536188e2" translate="yes" xml:space="preserve">
          <source>The expression above creates a value of type &lt;code&gt;MyUnion&lt;/code&gt; and initializes the storage using field &lt;code&gt;f1&lt;/code&gt;. The union can be accessed using the same syntax as struct fields:</source>
          <target state="translated">위의 표현식은 &lt;code&gt;MyUnion&lt;/code&gt; 유형의 값을 작성하고 필드 &lt;code&gt;f1&lt;/code&gt; 을 사용하여 스토리지를 초기화합니다 . 구조체 필드와 동일한 구문을 사용하여 공용체에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5fa765f11cc060019641c8e75e38c695bdb1bda" translate="yes" xml:space="preserve">
          <source>The expression cannot be a &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean operator expression&lt;/a&gt;. Use of a lazy boolean operator is ambiguous with a planned feature change of the language (the implementation of if-let chains - see &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018&quot;&gt;eRFC 2947&lt;/a&gt;). When lazy boolean operator expression is desired, this can be achieved by using parenthesis as below:</source>
          <target state="translated">표현식은 &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;지연 부울 연산자&lt;/a&gt; 표현식 일 수 없습니다 . 언어의 계획된 기능 변경으로 게으른 부울 연산자의 사용이 모호합니다 (if-let chain 구현 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018&quot;&gt;-eRFC 2947&lt;/a&gt; 참조 ). 게으른 부울 연산자 표현식이 필요한 경우 다음과 같이 괄호를 사용하여이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a608f321648c235bb5c3f09a506a153d6d9a7fa1" translate="yes" xml:space="preserve">
          <source>The expression for a match arm.</source>
          <target state="translated">성냥 팔 표현.</target>
        </trans-unit>
        <trans-unit id="edc402eeeb9a7639cb3c026b59f168e6cd732965" translate="yes" xml:space="preserve">
          <source>The expression immediately following &lt;code&gt;in&lt;/code&gt; must implement the &lt;a href=&quot;../book/ch13-04-performance&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 바로 뒤에 오는 표현식 은 &lt;a href=&quot;../book/ch13-04-performance&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; 트레이 트&lt;/a&gt; 를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="64c3c13114c938924165b32b931fcfa0929a3dad" translate="yes" xml:space="preserve">
          <source>The expression in the &lt;code&gt;if&lt;/code&gt; block evaluates to an integer, and the expression in the &lt;code&gt;else&lt;/code&gt; block evaluates to a string. This won&amp;rsquo;t work because variables must have a single type. Rust needs to know at compile time what type the &lt;code&gt;number&lt;/code&gt; variable is, definitively, so it can verify at compile time that its type is valid everywhere we use &lt;code&gt;number&lt;/code&gt;. Rust wouldn&amp;rsquo;t be able to do that if the type of &lt;code&gt;number&lt;/code&gt; was only determined at runtime; the compiler would be more complex and would make fewer guarantees about the code if it had to keep track of multiple hypothetical types for any variable.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 블록 의 표현식 은 정수로 평가되고 &lt;code&gt;else&lt;/code&gt; 블록 의 표현식 은 문자열로 평가됩니다. 변수는 단일 유형을 가져야하므로 작동하지 않습니다. Rust는 컴파일 할 때 &lt;code&gt;number&lt;/code&gt; 변수가 어떤 유형인지 확실 하게 알 필요가 있으므로 컴파일 타임에 해당 유형이 &lt;code&gt;number&lt;/code&gt; 를 사용하는 모든 곳에서 유효한지 확인할 수 있습니다. &lt;code&gt;number&lt;/code&gt; 유형이 런타임에만 결정된 경우 Rust는이를 수행 할 수 없습니다 . 컴파일러는 더 복잡하고 변수에 대해 여러 가지 가상 유형을 추적해야하는 경우 코드에 대한 보증을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="7947155b0fa5fdbbf2d84b0fb9bff1298adf4bf1" translate="yes" xml:space="preserve">
          <source>The extension is:</source>
          <target state="translated">확장명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea39e7727f6084ef5165d4f9b888542528c3cc1d" translate="yes" xml:space="preserve">
          <source>The external crate is resolved to a specific &lt;code&gt;soname&lt;/code&gt; at compile time, and a runtime linkage requirement to that &lt;code&gt;soname&lt;/code&gt; is passed to the linker for loading at runtime. The &lt;code&gt;soname&lt;/code&gt; is resolved at compile time by scanning the compiler's library path and matching the optional &lt;code&gt;crateid&lt;/code&gt; provided against the &lt;code&gt;crateid&lt;/code&gt; attributes that were declared on the external crate when it was compiled. If no &lt;code&gt;crateid&lt;/code&gt; is provided, a default &lt;code&gt;name&lt;/code&gt; attribute is assumed, equal to the &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt; given in the &lt;code&gt;extern crate&lt;/code&gt; declaration.</source>
          <target state="translated">외부 상자는 특정의에 해결 &lt;code&gt;soname&lt;/code&gt; 컴파일시에, 그에게 런타임 연결 요구 &lt;code&gt;soname&lt;/code&gt; 실행시 로딩을위한 링커에 전달됩니다. &lt;code&gt;soname&lt;/code&gt; 컴파일러의 라이브러리 경로를 검색하고 선택 일치시켜 컴파일 시간에 해결 &lt;code&gt;crateid&lt;/code&gt; 에 제공 &lt;code&gt;crateid&lt;/code&gt; 의 이 컴파일 될 때 외부 상자에 선언 된 속성을. &lt;code&gt;crateid&lt;/code&gt; 가 제공 되지 않으면 &lt;code&gt;extern crate&lt;/code&gt; 선언에 제공된 &lt;a href=&quot;../identifiers&quot;&gt;식별자&lt;/a&gt; 와 동일한 기본 &lt;code&gt;name&lt;/code&gt; 속성이 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="2d4ff9b9a673e6ef5c73fd0d74de95c1584abb9d" translate="yes" xml:space="preserve">
          <source>The failure message indicates that this test did indeed panic as we expected, but the panic message did not include the expected string &lt;code&gt;'Guess value must be less than or equal to 100'&lt;/code&gt;. The panic message that we did get in this case was &lt;code&gt;Guess value must be greater than or equal to 1, got 200.&lt;/code&gt; Now we can start figuring out where our bug is!</source>
          <target state="translated">실패 메시지는이 테스트가 예상대로 공황 상태에 빠졌지 만, 공황 메시지에 예상 문자열 &lt;code&gt;'Guess value must be less than or equal to 100'&lt;/code&gt; 이 포함되지 않았 음을 나타냅니다 . 우리가이 경우에 얻은 패닉 메시지는 &lt;code&gt;Guess value must be greater than or equal to 1, got 200.&lt;/code&gt; 이제 버그가 어디에 있는지 알아낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1264d4255ef5d1877747639a91dce97d95706422" translate="yes" xml:space="preserve">
          <source>The family of the operating system. Example value is &lt;code&gt;unix&lt;/code&gt;.</source>
          <target state="translated">운영 체제 제품군. 예제 값은 &lt;code&gt;unix&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1f19a750b2fcc57343d113fae5c2d35cbbeabd61" translate="yes" xml:space="preserve">
          <source>The field names can be decimal integer values to specify indices for constructing tuple structs. This can be used with base structs to fill out the remaining indices not specified:</source>
          <target state="translated">필드 이름은 튜플 구조체를 구성하기위한 인덱스를 지정하는 10 진 정수 값일 수 있습니다. 이것은 지정되지 않은 나머지 인덱스를 채우기 위해 기본 구조체와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bbc5c6747805ec7b206ff1d7bd4fc19a67e98d4" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt; are dropped in declaration order.</source>
          <target state="translated">&lt;a href=&quot;types/struct&quot;&gt;구조체&lt;/a&gt; 의 필드는 선언 순서대로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="c1e05fef4f32d53e63c8251d9d852a226e0b9d94" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt;, &lt;a href=&quot;types/tuple&quot;&gt;tuple&lt;/a&gt; or &lt;a href=&quot;types/enum&quot;&gt;enum variant&lt;/a&gt; are dropped in declaration order. *</source>
          <target state="translated">&lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt; , &lt;a href=&quot;types/tuple&quot;&gt;tuple&lt;/a&gt; 또는 &lt;a href=&quot;types/enum&quot;&gt;enum 변형&lt;/a&gt; 의 필드는 선언 순서대로 삭제됩니다. *</target>
        </trans-unit>
        <trans-unit id="ad3f74fe8b6e787f7b7254796fcea650c623bbf0" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/tuple&quot;&gt;tuple&lt;/a&gt; are dropped in order.</source>
          <target state="translated">&lt;a href=&quot;types/tuple&quot;&gt;튜플&lt;/a&gt; 의 필드는 순서대로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="985befbf65bb726fbdc7e8fa5788956f4d2e4bf1" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;code&gt;struct&lt;/code&gt; may be qualified by &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visibility modifiers&lt;/a&gt;, to allow access to data in a struct outside a module.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 의 필드는 &lt;a href=&quot;../visibility-and-privacy&quot;&gt;가시성 수정 자에&lt;/a&gt; 의해 규정되어 모듈 외부의 구조체에있는 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d44253ff03665f86e16760d6d12a49f11125c4e2" translate="yes" xml:space="preserve">
          <source>The fields of the active &lt;a href=&quot;types/enum&quot;&gt;enum variant&lt;/a&gt; are dropped in declaration order.</source>
          <target state="translated">활성 &lt;a href=&quot;types/enum&quot;&gt;열거 형 변형&lt;/a&gt; 의 필드는 선언 순서대로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="40ccc036f7a6ce305846dd9b315fdf1f96b15a3b" translate="yes" xml:space="preserve">
          <source>The fields of this struct show that the Rust code we&amp;rsquo;ve parsed is a unit struct with the &lt;code&gt;ident&lt;/code&gt; (identifier, meaning the name) of &lt;code&gt;Pancakes&lt;/code&gt;. There are more fields on this struct for describing all sorts of Rust code; check the &lt;a href=&quot;https://docs.rs/syn/0.14.4/syn/struct.DeriveInput.html&quot;&gt;&lt;code&gt;syn&lt;/code&gt; documentation for &lt;code&gt;DeriveInput&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">이 구조체의 필드는 우리가 파싱 한 Rust 코드가 &lt;code&gt;Pancakes&lt;/code&gt; 의 &lt;code&gt;ident&lt;/code&gt; (이름을 의미하는 식별자)를 가진 단위 구조체임을 보여줍니다 . 이 구조체에는 모든 종류의 Rust 코드를 설명하기위한 더 많은 필드가 있습니다. 자세한 내용 &lt;a href=&quot;https://docs.rs/syn/0.14.4/syn/struct.DeriveInput.html&quot;&gt;은 &lt;/a&gt; &lt;code&gt;DeriveInput&lt;/code&gt; 에 대한 &lt;code&gt;syn&lt;/code&gt; 설명서를 확인 하십시오.</target>
        </trans-unit>
        <trans-unit id="b0794c80e766c7ef30098e79990a99a126d86062" translate="yes" xml:space="preserve">
          <source>The fields of this struct show that the Rust code we&amp;rsquo;ve parsed is a unit struct with the &lt;code&gt;ident&lt;/code&gt; (identifier, meaning the name) of &lt;code&gt;Pancakes&lt;/code&gt;. There are more fields on this struct for describing all sorts of Rust code; check the &lt;a href=&quot;https://docs.rs/syn/1.0/syn/struct.DeriveInput.html&quot;&gt;&lt;code&gt;syn&lt;/code&gt; documentation for &lt;code&gt;DeriveInput&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">이 구조체의 필드는 우리가 파싱 한 Rust 코드가 &lt;code&gt;Pancakes&lt;/code&gt; 의 &lt;code&gt;ident&lt;/code&gt; (식별자, 이름을 의미)를 가진 단위 구조체임을 보여줍니다 . 이 구조체에는 모든 종류의 Rust 코드를 설명하는 더 많은 필드가 있습니다. ~을 체크하다&lt;a href=&quot;https://docs.rs/syn/1.0/syn/struct.DeriveInput.html&quot;&gt; &lt;code&gt;syn&lt;/code&gt; &lt;code&gt;DeriveInput&lt;/code&gt; &lt;/a&gt;자세한 정보 는 DeriveInput에 대한 syn 문서를하십시오.</target>
        </trans-unit>
        <trans-unit id="41f21e4814cce1d92447f83c7dd9a65499d60626" translate="yes" xml:space="preserve">
          <source>The file doesn't exist.</source>
          <target state="translated">파일이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c618b2bfdd921c07e86f2a30b8c3ccd4f98ae789" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file (similarly to how modules are found).</source>
          <target state="translated">파일은 현재 파일을 기준으로 위치합니다 (모듈을 찾는 방법과 유사).</target>
        </trans-unit>
        <trans-unit id="0630128fbb4da19cb239333b356fc43bbab7e18f" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file (similarly to how modules are found). The provided path is interpreted in a platform-specific way at compile time. So, for instance, an invocation with a Windows path containing backslashes &lt;code&gt;\&lt;/code&gt; would not compile correctly on Unix.</source>
          <target state="translated">파일은 현재 파일을 기준으로 위치합니다 (모듈을 찾는 방법과 유사). 제공된 경로는 컴파일 타임에 플랫폼 별 방식으로 해석됩니다. 예를 들어 백 슬래시가 포함 된 Windows 경로를 사용한 호출 &lt;code&gt;\&lt;/code&gt; 유닉스에서 제대로 컴파일하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="a1df7519bc8cdda06f6336bd152ecc0e5b1b6c7c" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file. (similarly to how modules are found)</source>
          <target state="translated">파일은 현재 파일을 기준으로 위치합니다. (모듈을 찾는 방법과 유사)</target>
        </trans-unit>
        <trans-unit id="d6c5af6a5c60f4fa56d05a0fa81955ff57e694aa" translate="yes" xml:space="preserve">
          <source>The file must be opened with write access for truncate to work.</source>
          <target state="translated">자르기가 작동하려면 쓰기 액세스 권한으로 파일을 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="b64dc47988604588017060c77446efa88568cbbc" translate="yes" xml:space="preserve">
          <source>The file must be opened with write or append access in order to create a new file.</source>
          <target state="translated">새 파일을 작성하려면 쓰기 또는 추가 액세스 권한으로 파일을 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="55a4d79c2d543091872b4da347b5d4b201da5902" translate="yes" xml:space="preserve">
          <source>The file's cursor isn't changed. In particular, if the cursor was at the end and the file is shrunk using this operation, the cursor will now be past the end.</source>
          <target state="translated">파일의 커서는 변경되지 않습니다. 특히, 커서가 끝났고이 조작을 사용하여 파일이 축소 된 경우 커서는 이제 끝을지나갑니다.</target>
        </trans-unit>
        <trans-unit id="6c8ba754d920c70b815c96a59ae89e2ab19e9615" translate="yes" xml:space="preserve">
          <source>The fill character is provided normally in conjunction with the &lt;a href=&quot;#width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; parameter. This indicates that if the value being formatted is smaller than &lt;code&gt;width&lt;/code&gt; some extra characters will be printed around it. The extra characters are specified by &lt;code&gt;fill&lt;/code&gt;, and the alignment can be one of the following options:</source>
          <target state="translated">채우기 문자는 일반적으로 &lt;a href=&quot;#width&quot;&gt; &lt;code&gt;width&lt;/code&gt; &lt;/a&gt; 매개 변수 와 함께 제공됩니다 . 이는 형식화되는 값이 &lt;code&gt;width&lt;/code&gt; 보다 작 으면 추가 문자가 그 주위에 인쇄 됨을 나타냅니다 . 추가 문자는 &lt;code&gt;fill&lt;/code&gt; 로 지정되며 정렬은 다음 옵션 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93dbdf12316da4d04bf621e9eb356e67a9dd2780" translate="yes" xml:space="preserve">
          <source>The final action that works only with &lt;code&gt;unsafe&lt;/code&gt; is implementing an unsafe trait. A trait is unsafe when at least one of its methods has some invariant that the compiler can&amp;rsquo;t verify. We can declare that a trait is &lt;code&gt;unsafe&lt;/code&gt; by adding the &lt;code&gt;unsafe&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; and marking the implementation of the trait as &lt;code&gt;unsafe&lt;/code&gt; too, as shown in Listing 19-11.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 경우에만 작동하는 마지막 조치 는 안전하지 않은 특성을 구현하는 것입니다. 특성 중 적어도 하나의 메소드에 컴파일러가 확인할 수없는 일부 불변이있는 경우 특성이 안전하지 않습니다. 우리는 특성이 있음을 선언 할 수 있습니다 &lt;code&gt;unsafe&lt;/code&gt; 가산하여 &lt;code&gt;unsafe&lt;/code&gt; 전에 키워드 &lt;code&gt;trait&lt;/code&gt; 과 같은 특성의 구현 마킹 &lt;code&gt;unsafe&lt;/code&gt; 목록 19-11에서와 같이,도.</target>
        </trans-unit>
        <trans-unit id="49a4f7cf0e0e66e3c555d75f0978be5130fe5dec" translate="yes" xml:space="preserve">
          <source>The final expression of any extending &lt;a href=&quot;expressions/block-expr&quot;&gt;block expression&lt;/a&gt;.</source>
          <target state="translated">확장의 최종 표현 &lt;a href=&quot;expressions/block-expr&quot;&gt; 블록 표현식&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d305704a4fbc5372e6355348bdb324639855c0b" translate="yes" xml:space="preserve">
          <source>The final line ending is optional.</source>
          <target state="translated">마지막 줄 끝은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="7bcad5659fa398bc4723e1a1e4ec534359f32934" translate="yes" xml:space="preserve">
          <source>The final line ending is optional. A string that ends with a final line ending will return the same lines as an otherwise identical string without a final line ending.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d405e4ac4031d3643938bc829210c93b1a171c2a" translate="yes" xml:space="preserve">
          <source>The final line ending isn't required:</source>
          <target state="translated">마지막 줄 끝은 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5271e27e91796af655967c8ffbfa429a17a75cb" translate="yes" xml:space="preserve">
          <source>The final result could be determined just by looking at the code at compile time, so &lt;a href=&quot;https://en.wikipedia.org/wiki/Constant_folding&quot;&gt;constant folding&lt;/a&gt; might turn the whole block into a simple &lt;code&gt;println!(&quot;7 4 4&quot;)&lt;/code&gt;.</source>
          <target state="translated">최종 결과는 컴파일 타임에 코드를 확인하는 것만으로 결정될 수 있으므로, &lt;a href=&quot;https://en.wikipedia.org/wiki/Constant_folding&quot;&gt;일정한 폴딩&lt;/a&gt; 은 전체 블록을 간단한 &lt;code&gt;println!(&quot;7 4 4&quot;)&lt;/code&gt; 로 바꿀 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e59d9d4ed7f661f21e1daf6cf7e1143fd8d7bfa" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;Cons&lt;/code&gt; value holds &lt;code&gt;1&lt;/code&gt; and another &lt;code&gt;List&lt;/code&gt; value. This &lt;code&gt;List&lt;/code&gt; value is another &lt;code&gt;Cons&lt;/code&gt; value that holds &lt;code&gt;2&lt;/code&gt; and another &lt;code&gt;List&lt;/code&gt; value. This &lt;code&gt;List&lt;/code&gt; value is one more &lt;code&gt;Cons&lt;/code&gt; value that holds &lt;code&gt;3&lt;/code&gt; and a &lt;code&gt;List&lt;/code&gt; value, which is finally &lt;code&gt;Nil&lt;/code&gt;, the non-recursive variant that signals the end of the list.</source>
          <target state="translated">첫 번째 &lt;code&gt;Cons&lt;/code&gt; 값에는 &lt;code&gt;1&lt;/code&gt; 과 다른 &lt;code&gt;List&lt;/code&gt; 값이 있습니다. 이 &lt;code&gt;List&lt;/code&gt; 값은 &lt;code&gt;2&lt;/code&gt; 와 다른 &lt;code&gt;List&lt;/code&gt; 값 을 보유하는 또 다른 &lt;code&gt;Cons&lt;/code&gt; 값입니다 . 이 &lt;code&gt;List&lt;/code&gt; 값은 &lt;code&gt;3&lt;/code&gt; 을 보유하는 하나 이상의 &lt;code&gt;Cons&lt;/code&gt; 값 과 &lt;code&gt;List&lt;/code&gt; 값으로, 목록 의 끝을 알리는 비 재귀 변형 인 &lt;code&gt;Nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b8427aa75fccc52f421b7262b47d3cb66ca8ba99" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;length&lt;/code&gt; bytes at &lt;code&gt;buf&lt;/code&gt; need to be valid UTF-8.</source>
          <target state="translated">첫 번째 &lt;code&gt;length&lt;/code&gt; &lt;code&gt;buf&lt;/code&gt; 바이트는 유효한 UTF-8이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b2f6ee38297963ecf451ec169c5ecff0bb88450f" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;format!&lt;/code&gt; receives is a format string. This must be a string literal. The power of the formatting string is in the &lt;code&gt;{}&lt;/code&gt;s contained.</source>
          <target state="translated">첫 번째 인수 &lt;code&gt;format!&lt;/code&gt; 수신은 형식 문자열입니다. 문자열 리터럴이어야합니다. 형식화 문자열의 힘은 &lt;code&gt;{}&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="172d64775742c02b6a5a5317561d4368b0242e63" translate="yes" xml:space="preserve">
          <source>The first argument we gave to the &lt;code&gt;assert_eq!&lt;/code&gt; macro, &lt;code&gt;4&lt;/code&gt;, is equal to the result of calling &lt;code&gt;add_two(2)&lt;/code&gt;. The line for this test is &lt;code&gt;test tests::it_adds_two ... ok&lt;/code&gt;, and the &lt;code&gt;ok&lt;/code&gt; text indicates that our test passed!</source>
          <target state="translated">우리가 &lt;code&gt;assert_eq!&lt;/code&gt; 준 첫 번째 주장 ! 매크로 &lt;code&gt;4&lt;/code&gt; 는 &lt;code&gt;add_two(2)&lt;/code&gt; 호출 결과와 같습니다 . 이 테스트의 라인은 &lt;code&gt;test tests::it_adds_two ... ok&lt;/code&gt; 이며 &lt;code&gt;ok&lt;/code&gt; 텍스트는 테스트가 통과했음을 나타냅니다!</target>
        </trans-unit>
        <trans-unit id="3de15e9c98b000a8208779afdf2f678b58acd245" translate="yes" xml:space="preserve">
          <source>The first arm will match any point that lies on the &lt;code&gt;x&lt;/code&gt; axis by specifying that the &lt;code&gt;y&lt;/code&gt; field matches if its value matches the literal &lt;code&gt;0&lt;/code&gt;. The pattern still creates an &lt;code&gt;x&lt;/code&gt; variable that we can use in the code for this arm.</source>
          <target state="translated">첫 번째 팔은 값이 리터럴 &lt;code&gt;0&lt;/code&gt; 과 일치하는 경우 &lt;code&gt;y&lt;/code&gt; 필드가 일치 하도록 지정 하여 &lt;code&gt;x&lt;/code&gt; 축 에있는 모든 점 과 일치합니다 . 패턴은 여전히이 팔의 코드에서 사용할 수 있는 &lt;code&gt;x&lt;/code&gt; 변수를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="0d5278ef07d533df9f2058795a528bf65f8762b5" translate="yes" xml:space="preserve">
          <source>The first character is &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">첫 번째 문자는 &lt;code&gt;_&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6995348ce355253fb2b3997cb5b666e8341177e1" translate="yes" xml:space="preserve">
          <source>The first character is a letter.</source>
          <target state="translated">첫 번째 문자는 글자입니다.</target>
        </trans-unit>
        <trans-unit id="a8c76b012fc5c6ec5d1d2757128af41ec43b821f" translate="yes" xml:space="preserve">
          <source>The first collection type we&amp;rsquo;ll look at is &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, also known as a &lt;em&gt;vector&lt;/em&gt;. Vectors allow you to store more than one value in a single data structure that puts all the values next to each other in memory. Vectors can only store values of the same type. They are useful when you have a list of items, such as the lines of text in a file or the prices of items in a shopping cart.</source>
          <target state="translated">우리가 살펴볼 첫 번째 컬렉션 유형은 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 이며 &lt;em&gt;vector&lt;/em&gt; 라고도합니다 . 벡터를 사용하면 하나의 데이터 구조에 둘 이상의 값을 저장하여 모든 값을 서로 메모리에 배치 할 수 있습니다. 벡터는 같은 유형의 값만 저장할 수 있습니다. 파일의 텍스트 줄 또는 장바구니의 항목 가격과 같은 항목 목록이있을 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="428cb6a8ac810de3963e02d4205a82867bb3d81a" translate="yes" xml:space="preserve">
          <source>The first command creates a new directory called &lt;em&gt;hello_cargo&lt;/em&gt;. We&amp;rsquo;ve named our project &lt;em&gt;hello_cargo&lt;/em&gt;, and Cargo creates its files in a directory of the same name.</source>
          <target state="translated">첫 번째 명령은 &lt;em&gt;hello_cargo&lt;/em&gt; 라는 새 디렉토리를 만듭니다 . 프로젝트 이름을 &lt;em&gt;hello_cargo&lt;/em&gt; 로 지정했으며 Cargo는 동일한 이름의 디렉토리에 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="63eaa7d21eca5ee74b5e72e48aed31081f441d50" translate="yes" xml:space="preserve">
          <source>The first command, &lt;code&gt;cargo new&lt;/code&gt;, takes the name of the project (&lt;code&gt;guessing_game&lt;/code&gt;) as the first argument. The second command changes to the new project&amp;rsquo;s directory.</source>
          <target state="translated">첫 번째 명령 &lt;code&gt;cargo new&lt;/code&gt; 는 첫 번째 인수로 프로젝트 이름 ( &lt;code&gt;guessing_game&lt;/code&gt; )을 사용합니다. 두 번째 명령은 새 프로젝트의 디렉토리로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="0041dd0d29e2c266e11aba3af3bc7df1a46ad21b" translate="yes" xml:space="preserve">
          <source>The first element is traditionally the path of the executable, but it can be set to arbitrary text, and it may not even exist, so this property should not be relied upon for security purposes.</source>
          <target state="translated">첫 번째 요소는 전통적으로 실행 파일의 경로이지만 임의의 텍스트로 설정 될 수 있으며 존재하지 않을 수도 있으므로 보안 상이 속성에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d1fd88a9bd4f9b97a6544f441d40f72dd7a6a337" translate="yes" xml:space="preserve">
          <source>The first element is traditionally the path of the executable, but it can be set to arbitrary text, and may not even exist. This means this property should not be relied upon for security purposes.</source>
          <target state="translated">첫 번째 요소는 전통적으로 실행 파일의 경로이지만 임의의 텍스트로 설정할 수 있으며 존재하지 않을 수도 있습니다. 즉, 보안상의 이유로이 속성에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="57c13dc1f835e54c634e0d373f7f324807f9c426" translate="yes" xml:space="preserve">
          <source>The first element was moved out of the array, but this is not possible because &lt;code&gt;NonCopy&lt;/code&gt; does not implement the &lt;code&gt;Copy&lt;/code&gt; trait.</source>
          <target state="translated">첫 번째 요소가 배열에서 이동되었지만 &lt;code&gt;NonCopy&lt;/code&gt; 는 &lt;code&gt;Copy&lt;/code&gt; 특성을 구현하지 않기 때문에 불가능합니다 .</target>
        </trans-unit>
        <trans-unit id="7e08bb0a99fdc3cd6e428394eb70ec134e104b16" translate="yes" xml:space="preserve">
          <source>The first enum shown is the usual kind of enum you'd find in a C-style language. The second shows off a hypothetical example of something storing location data, with &lt;code&gt;Coord&lt;/code&gt; being any other type that's needed, for example a struct. The third example demonstrates the kind of data a variant can store, ranging from nothing, to a tuple, to an anonymous struct.</source>
          <target state="translated">첫 번째 열거 형은 C 스타일 언어에서 볼 수있는 일반적인 종류의 열거 형입니다. 두 번째는 위치 데이터를 저장하는 것에 대한 가상의 예를 보여줍니다. &lt;code&gt;Coord&lt;/code&gt; 는 구조체와 같은 필요한 다른 유형입니다. 세 번째 예는 변형에서 저장할 수없는 종류의 데이터에서 튜플, 익명 구조체에 이르기까지 다양합니다.</target>
        </trans-unit>
        <trans-unit id="356931433c23df443c1df1a79c8ba26a23e35bf5" translate="yes" xml:space="preserve">
          <source>The first error is in our &lt;code&gt;Drop&lt;/code&gt; implementation. We mentioned earlier that we intended to call &lt;code&gt;take&lt;/code&gt; on the &lt;code&gt;Option&lt;/code&gt; value to move &lt;code&gt;thread&lt;/code&gt; out of &lt;code&gt;worker&lt;/code&gt;. The following changes will do so:</source>
          <target state="translated">첫 번째 오류는 &lt;code&gt;Drop&lt;/code&gt; 구현에 있습니다. 우리는 우리가 전화를 의도 앞서 언급 &lt;code&gt;take&lt;/code&gt; 온 &lt;code&gt;Option&lt;/code&gt; 이동 값 &lt;code&gt;thread&lt;/code&gt; 밖으로 &lt;code&gt;worker&lt;/code&gt; . 다음과 같이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="65b1330f4d7e9b563ff90a9ab4bea0daa6bb9857" translate="yes" xml:space="preserve">
          <source>The first invariant says that whatever actual token that comes after a matcher, if any, must be somewhere in the predetermined follow set. This ensures that a legal macro definition will continue to assign the same determination as to where &lt;code&gt;... tt&lt;/code&gt; ends and &lt;code&gt;uu ...&lt;/code&gt; begins, even as new syntactic forms are added to the language.</source>
          <target state="translated">첫 번째 불변 값은 매처 뒤에 나오는 실제 토큰이 있으면 사전 결정된 후속 세트의 어딘가에 있어야한다고 말합니다. 이렇게하면 새로운 매크로 형식이 언어에 추가 되더라도 유효한 매크로 정의가 &lt;code&gt;... tt&lt;/code&gt; 끝나고 &lt;code&gt;uu ...&lt;/code&gt; 가 시작 되는 위치와 동일한 결정을 계속 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f19def176a50d6a90af45519ada69ee7f97eb7e" translate="yes" xml:space="preserve">
          <source>The first is that it is how much memory must be allocated to store that value.</source>
          <target state="translated">첫 번째는 해당 값을 저장하기 위해 할당해야하는 메모리 양입니다.</target>
        </trans-unit>
        <trans-unit id="beaa6fcb1bf59defe3de830f4f2763f9980dd889" translate="yes" xml:space="preserve">
          <source>The first is to answer a specific question. If you know which chapter answers that question, you can jump to that chapter in the table of contents. Otherwise, you can press &lt;code&gt;s&lt;/code&gt; or the click the magnifying glass on the top bar to search for keywords related to your question. For example, say you wanted to know when a temporary value created in a let statement is dropped. If you didn't already know that the &lt;a href=&quot;expressions#temporaries&quot;&gt;lifetime of temporaries&lt;/a&gt; is defined in the &lt;a href=&quot;expressions&quot;&gt;expressions chapter&lt;/a&gt;, you could search &quot;temporary let&quot; and the first search result will take you to that section.</source>
          <target state="translated">첫 번째는 특정 질문에 답하는 것입니다. 어떤 장이 그 질문에 답하는지 알고 있다면 목차의 해당 장으로 이동할 수 있습니다. 그렇지 않으면 &lt;code&gt;s&lt;/code&gt; 를 누르 거나 상단 표시 줄의 돋보기를 클릭하여 질문과 관련된 키워드를 검색 할 수 있습니다. 예를 들어 let 문에서 생성 된 임시 값이 언제 삭제되는지 알고 싶다고 가정 해 보겠습니다. &lt;a href=&quot;expressions#temporaries&quot;&gt;임시&lt;/a&gt; 의 수명이 &lt;a href=&quot;expressions&quot;&gt;표현식 장에&lt;/a&gt; 정의되어 있다는 사실을 몰랐을 경우 &quot;temporary let&quot;을 검색하면 첫 번째 검색 결과가 해당 섹션으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="6fc0f539a4da8814ced28ee34b9432e35dbaf3f6" translate="yes" xml:space="preserve">
          <source>The first is to answer a specific question. If you know which chapter answers that question, you can jump to that chapter in the table of contents. Otherwise, you can press &lt;code&gt;s&lt;/code&gt; or the click the magnifying glass on the top bar to search for keywords related to your question. For example, say you wanted to know when a temporary value created in a let statement is dropped. If you didn't already know that the &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;lifetime of temporaries&lt;/a&gt; is defined in the &lt;a href=&quot;expressions&quot;&gt;expressions chapter&lt;/a&gt;, you could search &quot;temporary let&quot; and the first search result will take you to that section.</source>
          <target state="translated">첫 번째는 특정 질문에 답변하는 것입니다. 어떤 장이 그 질문에 답하는지 알고 있다면 목차에서 해당 장으로 이동할 수 있습니다. 그렇지 않으면, 당신은 누를 수 &lt;code&gt;s&lt;/code&gt; 또는 질문과 관련된 키워드를 검색 상단 표시 줄에있는 돋보기를 클릭합니다. 예를 들어, let 문에서 작성된 임시 값이 언제 삭제되는지 알고 싶다고 가정하십시오. &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;임시 장수의 수명이 &lt;/a&gt;&lt;a href=&quot;expressions&quot;&gt;식 장에&lt;/a&gt; 정의되어 있는지 아직 모른다면 &quot;임시 let&quot;을 검색하면 첫 번째 검색 결과가 해당 섹션으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="9d5da3096efb5359ed9929a25c1646ef8f4d3a16" translate="yes" xml:space="preserve">
          <source>The first line is a &lt;em&gt;status line&lt;/em&gt; that contains the HTTP version used in the response, a numeric status code that summarizes the result of the request, and a reason phrase that provides a text description of the status code. After the CRLF sequence are any headers, another CRLF sequence, and the body of the response.</source>
          <target state="translated">첫 번째 라인은 인 &lt;em&gt;상태 라인&lt;/em&gt; 반응에 사용되는 HTTP 버전 요청의 결과를 요약 한 숫자 상태 코드 및 상태 코드의 텍스트 설명을 제공하는 이유 구를 포함한다. CRLF 시퀀스 뒤에는 헤더, 다른 CRLF 시퀀스 및 응답 본문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9ee7ff7ce4ca8fcacdd1bbbd80ae645db3e5b9c" translate="yes" xml:space="preserve">
          <source>The first line is the &lt;em&gt;request line&lt;/em&gt; that holds information about what the client is requesting. The first part of the request line indicates the &lt;em&gt;method&lt;/em&gt; being used, such as &lt;code&gt;GET&lt;/code&gt; or &lt;code&gt;POST&lt;/code&gt;, which describes how the client is making this request. Our client used a &lt;code&gt;GET&lt;/code&gt; request.</source>
          <target state="translated">첫 번째 라인은 클라이언트가 요청하는 것에 대한 정보를 보유 하는 &lt;em&gt;요청 라인&lt;/em&gt; 입니다. 요청 라인의 첫 번째 부분은 클라이언트가이 요청을 수행하는 방법을 설명하는 &lt;code&gt;GET&lt;/code&gt; 또는 &lt;code&gt;POST&lt;/code&gt; 와 같은 사용중인 &lt;em&gt;메소드를&lt;/em&gt; 나타냅니다 . 우리 고객은 &lt;code&gt;GET&lt;/code&gt; 요청을 사용했습니다 .</target>
        </trans-unit>
        <trans-unit id="81a313a5dc649f34279e079a51051be71d71d911" translate="yes" xml:space="preserve">
          <source>The first line shows a function definition, and the second line shows a fully annotated closure definition. The third line removes the type annotations from the closure definition, and the fourth line removes the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they&amp;rsquo;re called.</source>
          <target state="translated">첫 번째 줄은 함수 정의를 보여주고 두 번째 줄은 주석이 달린 클로저 정의를 보여줍니다. 세 번째 줄은 클로저 정의에서 형식 주석을 제거하고 네 번째 줄은 괄호를 제거합니다. 마침표 본문에는식이 하나뿐이므로 선택 사항입니다. 이들은 모두 호출 될 때 동일한 동작을 생성하는 유효한 정의입니다.</target>
        </trans-unit>
        <trans-unit id="ee8e9ca51bced15f598c9116a158790ff9d282d7" translate="yes" xml:space="preserve">
          <source>The first line shows a function definition, and the second line shows a fully annotated closure definition. The third line removes the type annotations from the closure definition, and the fourth line removes the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they&amp;rsquo;re called. Calling the closures is required for &lt;code&gt;add_one_v3&lt;/code&gt; and &lt;code&gt;add_one_v4&lt;/code&gt; to be able to compile because the types will be inferred from their usage.</source>
          <target state="translated">첫 번째 줄은 함수 정의를 보여주고 두 번째 줄은 완전히 주석이 달린 클로저 정의를 보여줍니다. 세 번째 줄은 클로저 정의에서 유형 주석을 제거하고 네 번째 줄은 클로저 본문에 표현식이 하나만 있기 때문에 선택 사항 인 대괄호를 제거합니다. 이들은 모두 호출 될 때 동일한 동작을 생성하는 유효한 정의입니다. &lt;code&gt;add_one_v3&lt;/code&gt; 및 &lt;code&gt;add_one_v4&lt;/code&gt; 가 컴파일 할 수 있으려면 클로저를 호출해야 합니다. 유형이 사용에서 유추되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="98148895ad25eccad7c245ba3595f3571d1d992c" translate="yes" xml:space="preserve">
          <source>The first line, &lt;code&gt;[package]&lt;/code&gt;, is a section heading that indicates that the following statements are configuring a package. As we add more information to this file, we&amp;rsquo;ll add other sections.</source>
          <target state="translated">첫 번째 줄인 &lt;code&gt;[package]&lt;/code&gt; 는 다음 문이 패키지를 구성하고 있음을 나타내는 섹션 제목입니다. 이 파일에 더 많은 정보를 추가하면 다른 섹션도 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="b65c034b9a1653c1664e07497c1d14736ba472ab" translate="yes" xml:space="preserve">
          <source>The first mismatching element defines which sequence is lexicographically less or greater than the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b310676b3019d119c9c467f577a365e7a655455" translate="yes" xml:space="preserve">
          <source>The first new bit here is another &lt;code&gt;use&lt;/code&gt; statement, bringing a type called &lt;code&gt;std::cmp::Ordering&lt;/code&gt; into scope from the standard library. Like &lt;code&gt;Result&lt;/code&gt;, &lt;code&gt;Ordering&lt;/code&gt; is another enum, but the variants for &lt;code&gt;Ordering&lt;/code&gt; are &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Greater&lt;/code&gt;, and &lt;code&gt;Equal&lt;/code&gt;. These are the three outcomes that are possible when you compare two values.</source>
          <target state="translated">첫 번째 새 비트 는 표준 라이브러리에서 &lt;code&gt;std::cmp::Ordering&lt;/code&gt; 범위를 가져 오는 또 다른 &lt;code&gt;use&lt;/code&gt; 문 입니다. 마찬가지로 &lt;code&gt;Result&lt;/code&gt; , &lt;code&gt;Ordering&lt;/code&gt; 다른 열거하지만,의 변종 &lt;code&gt;Ordering&lt;/code&gt; 있습니다 &lt;code&gt;Less&lt;/code&gt; , &lt;code&gt;Greater&lt;/code&gt; , 그리고 &lt;code&gt;Equal&lt;/code&gt; . 두 값을 비교할 때 가능한 세 가지 결과입니다.</target>
        </trans-unit>
        <trans-unit id="cc86c6e2624cc3af0cff65094ba89e9de1e68ebb" translate="yes" xml:space="preserve">
          <source>The first new line defines the &lt;code&gt;response&lt;/code&gt; variable that holds the success message&amp;rsquo;s data. Then we call &lt;code&gt;as_bytes&lt;/code&gt; on our &lt;code&gt;response&lt;/code&gt; to convert the string data to bytes. The &lt;code&gt;write&lt;/code&gt; method on &lt;code&gt;stream&lt;/code&gt; takes a &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; and sends those bytes directly down the connection.</source>
          <target state="translated">첫 번째 새 줄은 성공 메시지의 데이터를 보유하는 &lt;code&gt;response&lt;/code&gt; 변수를 정의합니다 . 그런 다음 &lt;code&gt;response&lt;/code&gt; 에서 &lt;code&gt;as_bytes&lt;/code&gt; 를 호출 하여 문자열 데이터를 바이트로 변환합니다. &lt;code&gt;stream&lt;/code&gt; 의 &lt;code&gt;write&lt;/code&gt; 메소드 는 &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; 하여 해당 바이트를 연결로 직접 보냅니다.</target>
        </trans-unit>
        <trans-unit id="155e4331405457b07f19de5018b6f05e551344c8" translate="yes" xml:space="preserve">
          <source>The first one looks much cleaner. This automatic referencing behavior works because methods have a clear receiver&amp;mdash;the type of &lt;code&gt;self&lt;/code&gt;. Given the receiver and name of a method, Rust can figure out definitively whether the method is reading (&lt;code&gt;&amp;amp;self&lt;/code&gt;), mutating (&lt;code&gt;&amp;amp;mut self&lt;/code&gt;), or consuming (&lt;code&gt;self&lt;/code&gt;). The fact that Rust makes borrowing implicit for method receivers is a big part of making ownership ergonomic in practice.</source>
          <target state="translated">첫 번째는 훨씬 깨끗해 보입니다. 이 자동 참조 동작은 메서드에 &lt;code&gt;self&lt;/code&gt; 유형 인 명확한 수신자가 있기 때문에 작동합니다 . 방법의 수신기와 이름을 감안할 때, 녹 방법은 (읽고 확실히 여부를 알아낼 수 &lt;code&gt;&amp;amp;self&lt;/code&gt; (돌연변이) &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ) 또는 (소모 &lt;code&gt;self&lt;/code&gt; ). Rust가 메소드 수신자에게 차용을 암시한다는 사실은 실제로 소유권을 인체 공학적으로 만드는 데 큰 부분을 차지합니다.</target>
        </trans-unit>
        <trans-unit id="69774098a6b4b7c12621ff37f51e96103a8b7208" translate="yes" xml:space="preserve">
          <source>The first part of the guessing game program will ask for user input, process that input, and check that the input is in the expected form. To start, we&amp;rsquo;ll allow the player to input a guess. Enter the code in Listing 2-1 into &lt;em&gt;src/main.rs&lt;/em&gt;.</source>
          <target state="translated">추측 게임 프로그램의 첫 번째 부분은 사용자 입력을 요청하고 해당 입력을 처리하며 입력이 예상 형식인지 확인합니다. 시작하기 위해 플레이어가 추측을 입력하도록 허용합니다. Listing 2-1의 코드를 &lt;em&gt;src / main.rs&lt;/em&gt; 에 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="2750d61c6d5f6fdb7cf8539aba812571a959c619" translate="yes" xml:space="preserve">
          <source>The first parts of the module system we&amp;rsquo;ll cover are packages and crates. A crate is a binary or library. The &lt;em&gt;crate root&lt;/em&gt; is a source file that the Rust compiler starts from and makes up the root module of your crate (we&amp;rsquo;ll explain modules in depth in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Defining Modules to Control Scope and Privacy&amp;rdquo;&lt;/a&gt; section). A &lt;em&gt;package&lt;/em&gt; is one or more crates that provide a set of functionality. A package contains a &lt;em&gt;Cargo.toml&lt;/em&gt; file that describes how to build those crates.</source>
          <target state="translated">우리가 다룰 모듈 시스템의 첫 번째 부분은 패키지와 상자입니다. 상자는 바이너리 또는 라이브러리입니다. &lt;em&gt;상자 루트가&lt;/em&gt; 녹 컴파일러에서 시작하여 상자의 루트 모듈을 구성하는 소스 파일입니다 (우리는 깊이에 모듈을 설명 할 것이다 &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&quot;정의 모듈 제어에 대한 범위 및 개인 정보 보호&quot;&lt;/a&gt; 절). &lt;em&gt;패키지&lt;/em&gt; 기능 세트를 제공하는 하나 개 이상의 상자입니다. 패키지에는 이러한 상자를 만드는 방법을 설명하는 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84c014079631c14ba610d8bbfcba357c51089179" translate="yes" xml:space="preserve">
          <source>The first parts of the module system we&amp;rsquo;ll cover are packages and crates. A crate is a binary or library. The &lt;em&gt;crate root&lt;/em&gt; is a source file that the Rust compiler starts from and makes up the root module of your crate (we&amp;rsquo;ll explain modules in depth in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Defining Modules to Control Scope and Privacy&amp;rdquo;&lt;/a&gt;) section. A &lt;em&gt;package&lt;/em&gt; is one or more crates that provide a set of functionality. A package contains a &lt;em&gt;Cargo.toml&lt;/em&gt; file that describes how to build those crates.</source>
          <target state="translated">우리가 다룰 모듈 시스템의 첫 번째 부분은 패키지와 상자입니다. 상자는 바이너리 또는 라이브러리입니다. &lt;em&gt;상자 루트는&lt;/em&gt; 녹 컴파일러는 (우리가 깊이에서 모듈을 설명하겠습니다에서 시작하여 상자의 루트 모듈을 구성하는 소스 파일입니다 &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&quot;정의 모듈 제어에 대한 범위 및 개인 정보 보호&quot;&lt;/a&gt; 섹션). &lt;em&gt;패키지는&lt;/em&gt; 기능 세트를 제공하는 하나 개 이상의 상자입니다. 패키지에는 상자를 만드는 방법을 설명하는 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일이 들어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af7ae34fc30a5ff985eeb202b31d100b9995dad4" translate="yes" xml:space="preserve">
          <source>The first problem is that a &lt;code&gt;Cacher&lt;/code&gt; instance assumes it will always get the same value for the parameter &lt;code&gt;arg&lt;/code&gt; to the &lt;code&gt;value&lt;/code&gt; method. That is, this test of &lt;code&gt;Cacher&lt;/code&gt; will fail:</source>
          <target state="translated">첫 번째 문제는 &lt;code&gt;Cacher&lt;/code&gt; 인스턴스가 매개 변수 &lt;code&gt;arg&lt;/code&gt; 에 대해 항상 &lt;code&gt;value&lt;/code&gt; 메소드 와 동일한 값을 얻는다고 가정한다는 것 입니다. 즉,이 &lt;code&gt;Cacher&lt;/code&gt; 테스트 는 실패합니다.</target>
        </trans-unit>
        <trans-unit id="dafa36fcdade4f5ce81d7dee337248690a10ae6d" translate="yes" xml:space="preserve">
          <source>The first purpose is similar to the second but in reverse: if you want to add a type parameter to an existing trait, you can give it a default to allow extension of the functionality of the trait without breaking the existing implementation code.</source>
          <target state="translated">첫 번째 목적은 두 번째와 유사하지만 반대로 기존 특성에 유형 매개 변수를 추가하려는 경우 기존 구현 코드를 손상시키지 않고 특성의 기능을 확장 할 수 있도록 기본값을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f5a900754c112ed82386f584763afdd02db421d" translate="yes" xml:space="preserve">
          <source>The first rule is that each parameter that is a reference gets its own lifetime parameter. In other words, a function with one parameter gets one lifetime parameter: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32)&lt;/code&gt;; a function with two parameters gets two separate lifetime parameters: &lt;code&gt;fn foo&amp;lt;'a, 'b&amp;gt;(x: &amp;amp;'a i32, y: &amp;amp;'b i32)&lt;/code&gt;; and so on.</source>
          <target state="translated">첫 번째 규칙은 참조 인 각 매개 변수가 고유 한 수명 매개 변수를 얻는 것입니다. 다시 말해, 하나의 매개 변수를 가진 함수는 하나의 수명 매개 변수를 가져옵니다. &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32)&lt;/code&gt; ; 두 개의 매개 변수가있는 함수는 두 개의 개별 수명 매개 변수를 얻습니다. &lt;code&gt;fn foo&amp;lt;'a, 'b&amp;gt;(x: &amp;amp;'a i32, y: &amp;amp;'b i32)&lt;/code&gt; ; 등등.</target>
        </trans-unit>
        <trans-unit id="d13f338beec8e6c884aee47f7c30a9f0bc21c5c9" translate="yes" xml:space="preserve">
          <source>The first section of the output shows that the &lt;code&gt;it_works&lt;/code&gt; test in the &lt;code&gt;add-one&lt;/code&gt; crate passed. The next section shows that zero tests were found in the &lt;code&gt;adder&lt;/code&gt; crate, and then the last section shows zero documentation tests were found in the &lt;code&gt;add-one&lt;/code&gt; crate. Running &lt;code&gt;cargo test&lt;/code&gt; in a workspace structured like this one will run the tests for all the crates in the workspace.</source>
          <target state="translated">출력의 첫 번째 섹션은 &lt;code&gt;add-one&lt;/code&gt; 상자 의 &lt;code&gt;it_works&lt;/code&gt; 테스트가 통과 되었음을 보여줍니다 . 다음 섹션에서는 &lt;code&gt;adder&lt;/code&gt; 상자 에서 0 개의 테스트가 발견되었으며 마지막 섹션에서는 &lt;code&gt;add-one&lt;/code&gt; 상자 에서 0 개의 테스트가 발견되었음을 보여줍니다 . 이와 같이 구성된 작업 공간에서 &lt;code&gt;cargo test&lt;/code&gt; 를 실행 하면 작업 공간의 모든 상자에 대한 테스트가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1aa6d921fdf65cd84a902ac9021b32a10817790a" translate="yes" xml:space="preserve">
          <source>The first step is to build a list of candidate receiver types. Obtain these by repeatedly &lt;a href=&quot;operator-expr#the-dereference-operator&quot;&gt;dereferencing&lt;/a&gt; the receiver expression's type, adding each type encountered to the list, then finally attempting an &lt;a href=&quot;../type-coercions#unsized-coercions&quot;&gt;unsized coercion&lt;/a&gt; at the end, and adding the result type if that is successful. Then, for each candidate &lt;code&gt;T&lt;/code&gt;, add &lt;code&gt;&amp;amp;T&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; to the list immediately after &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">첫 번째 단계는 후보 수신자 유형 목록을 작성하는 것입니다. 수신자 표현식의 유형 을 반복적으로 &lt;a href=&quot;operator-expr#the-dereference-operator&quot;&gt;역 참조&lt;/a&gt; 하고, 발견 된 각 유형을 목록에 추가 한 다음 마지막에 &lt;a href=&quot;../type-coercions#unsized-coercions&quot;&gt;크기가없는 강제 변환&lt;/a&gt; 을 시도하고 , 성공한 경우 결과 유형을 추가하여이를 확보하십시오. 그런 다음, 각 후보에 대한 &lt;code&gt;T&lt;/code&gt; , 추가 &lt;code&gt;&amp;amp;T&lt;/code&gt; 및 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 직후 목록에 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7046b8e80cd49555b791ba84b08e3a496f0ebd34" translate="yes" xml:space="preserve">
          <source>The first step is to install Rust. We&amp;rsquo;ll download Rust through &lt;code&gt;rustup&lt;/code&gt;, a command line tool for managing Rust versions and associated tools. You&amp;rsquo;ll need an internet connection for the download.</source>
          <target state="translated">첫 번째 단계는 Rust를 설치하는 것입니다. Rust 버전 및 관련 도구를 관리하기위한 명령 줄 도구 인 &lt;code&gt;rustup&lt;/code&gt; 을 통해 Rust를 다운로드 합니다. 다운로드하려면 인터넷에 연결되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="50ad5f65969d8efb886424560b9363334f047aa4" translate="yes" xml:space="preserve">
          <source>The first store to &lt;code&gt;C&lt;/code&gt; might be moved before the store to &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;, &lt;em&gt;as if&lt;/em&gt; we had written &lt;code&gt;C = 4; A = 3; B = 4&lt;/code&gt;.</source>
          <target state="translated">처음에 저장 &lt;code&gt;C&lt;/code&gt; 는 로 가기 전에 이동 될 수 또는 &lt;code&gt;B&lt;/code&gt; , &lt;em&gt;마치&lt;/em&gt; 우리가 쓴 &lt;code&gt;C = 4; A = 3; B = 4&lt;/code&gt; A = 3; B = 4 입니다. &lt;code&gt;A&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0a6ba14d6296fbc087c2dbd538a2ed25e14b36c1" translate="yes" xml:space="preserve">
          <source>The first task is to make &lt;code&gt;minigrep&lt;/code&gt; accept its two command line arguments: the filename and a string to search for. That is, we want to be able to run our program with &lt;code&gt;cargo run&lt;/code&gt;, a string to search for, and a path to a file to search in, like so:</source>
          <target state="translated">첫 번째 작업은 &lt;code&gt;minigrep&lt;/code&gt; 이 두 개의 명령 줄 인수를 받도록하는 것입니다 : 파일 이름과 검색 할 문자열. 즉, 다음과 같이 &lt;code&gt;cargo run&lt;/code&gt; , 검색 할 문자열 및 검색 할 파일 경로를 사용하여 프로그램을 실행할 수 있기를 원합니다 .</target>
        </trans-unit>
        <trans-unit id="31729bd9aa0c04461ab01bb63b4c75c53baddad1" translate="yes" xml:space="preserve">
          <source>The first time we call &lt;code&gt;example_closure&lt;/code&gt; with the &lt;code&gt;String&lt;/code&gt; value, the compiler infers the type of &lt;code&gt;x&lt;/code&gt; and the return type of the closure to be &lt;code&gt;String&lt;/code&gt;. Those types are then locked in to the closure in &lt;code&gt;example_closure&lt;/code&gt;, and we get a type error if we try to use a different type with the same closure.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 값으로 &lt;code&gt;example_closure&lt;/code&gt; 를 처음 호출 할 때 컴파일러는 &lt;code&gt;x&lt;/code&gt; 유형과 클로저의 반환 유형을 &lt;code&gt;String&lt;/code&gt; 으로 추론합니다 . 그런 다음 이러한 유형은 &lt;code&gt;example_closure&lt;/code&gt; 의 클로저에 고정되며 동일한 클로저로 다른 유형을 사용하려고하면 유형 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bd2776b4ba26113bcf03f01d82d4cc2a793fc112" translate="yes" xml:space="preserve">
          <source>The first time we call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function in &lt;code&gt;eat_at_restaurant&lt;/code&gt;, we use an absolute path. The &lt;code&gt;add_to_waitlist&lt;/code&gt; function is defined in the same crate as &lt;code&gt;eat_at_restaurant&lt;/code&gt;, which means we can use the &lt;code&gt;crate&lt;/code&gt; keyword to start an absolute path.</source>
          <target state="translated">우리가 통화를 처음 &lt;code&gt;add_to_waitlist&lt;/code&gt; 의 함수 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 는 , 우리는 절대 경로를 사용한다. &lt;code&gt;add_to_waitlist&lt;/code&gt; 의 기능과 동일한 상자에 정의 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 우리가 사용할 수있는 수단, &lt;code&gt;crate&lt;/code&gt; 절대 경로를 시작하기 위해 키워드.</target>
        </trans-unit>
        <trans-unit id="fcbd8f43979f6a3f91b2e8d0489ac836799ae483" translate="yes" xml:space="preserve">
          <source>The first two cases are the same except for mutability. The first case states that if you have a &lt;code&gt;&amp;amp;T&lt;/code&gt;, and &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Deref&lt;/code&gt; to some type &lt;code&gt;U&lt;/code&gt;, you can get a &lt;code&gt;&amp;amp;U&lt;/code&gt; transparently. The second case states that the same deref coercion happens for mutable references.</source>
          <target state="translated">변경 가능성을 제외하고 처음 두 경우는 동일합니다. 첫 번째 경우는 &lt;code&gt;&amp;amp;T&lt;/code&gt; 가 있고 &lt;code&gt;T&lt;/code&gt; 가 일부 유형 &lt;code&gt;U&lt;/code&gt; 에 대한 &lt;code&gt;Deref&lt;/code&gt; 를 구현 하면 &lt;code&gt;&amp;amp;U&lt;/code&gt; 투명하게 얻을 수 있다는 것 입니다. 두 번째 경우는 변경 가능한 참조에 대해 동일한 역 참조 강제가 발생 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="286885295f7366f4af40320e50ad88bb3b1732e7" translate="yes" xml:space="preserve">
          <source>The first version of the prelude of The Rust Standard Library.</source>
          <target state="translated">The Rust Standard Library 서곡의 첫 번째 버전.</target>
        </trans-unit>
        <trans-unit id="2833ddd57d8c251f327110ae65b75e17455b9bb3" translate="yes" xml:space="preserve">
          <source>The first will contain all indices from &lt;code&gt;[0, mid)&lt;/code&gt; (excluding the index &lt;code&gt;mid&lt;/code&gt; itself) and the second will contain all indices from &lt;code&gt;[mid, len)&lt;/code&gt; (excluding the index &lt;code&gt;len&lt;/code&gt; itself).</source>
          <target state="translated">첫 번째는 &lt;code&gt;[0, mid)&lt;/code&gt; 모든 인덱스를 포함하고 (인덱스 &lt;code&gt;mid&lt;/code&gt; 자체 제외 ) 두 번째는 &lt;code&gt;[mid, len)&lt;/code&gt; 모든 인덱스를 포함합니다 (인덱스 &lt;code&gt;len&lt;/code&gt; 자체 제외 ).</target>
        </trans-unit>
        <trans-unit id="d13813ed09799c4deb40bb4b4bb042ae0365adde" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; affect compile-time limits.</source>
          <target state="translated">다음 &lt;a href=&quot;../attributes&quot;&gt;속성&lt;/a&gt; 은 컴파일 시간 제한에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="1c0907607a038e19917ef67594e99ddd26567897" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for changing how a type can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b431e371001b409fc98d06f983cdb135709c0f" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for controlling code generation.</source>
          <target state="translated">다음 &lt;a href=&quot;../attributes&quot;&gt;속성&lt;/a&gt; 은 코드 생성을 제어하는 ​​데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="26da618b938f5c0f34421c8ac509923a988969a6" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for controlling or generating diagnostic messages during compilation.</source>
          <target state="translated">다음 &lt;a href=&quot;../attributes&quot;&gt;속성&lt;/a&gt; 은 컴파일 중 진단 메시지를 제어하거나 생성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a094c614790975d250927975ec0fe6928fcd7c3a" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for specifying functions for performing tests. Compiling a crate in &quot;test&quot; mode enables building the test functions along with a test harness for executing the tests. Enabling the test mode also enables the &lt;a href=&quot;../conditional-compilation#test&quot;&gt;&lt;code&gt;test&lt;/code&gt; conditional compilation option&lt;/a&gt;.</source>
          <target state="translated">다음 &lt;a href=&quot;../attributes&quot;&gt;속성&lt;/a&gt; 은 테스트 수행을위한 기능을 지정하는 데 사용됩니다. &quot;테스트&quot;모드에서 크레이트를 컴파일하면 테스트 실행을위한 테스트 하네스와 함께 테스트 기능을 구축 할 수 있습니다. 테스트 모드를 활성화하면 &lt;a href=&quot;../conditional-compilation#test&quot;&gt; &lt;code&gt;test&lt;/code&gt; 조건부 컴파일 옵션&lt;/a&gt; 도 활성화 됩니다.</target>
        </trans-unit>
        <trans-unit id="c6bd6f609f21755a5a941e395bd92f148b7a32a4" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; control the behavior of external blocks.</source>
          <target state="translated">다음 &lt;a href=&quot;../attributes&quot;&gt;속성&lt;/a&gt; 은 외부 블록의 동작을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="e4c3204613b4a8b1aeaa7e0d193d03d0b636c5e8" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;join_slices&lt;/code&gt; function is &lt;strong&gt;unsound&lt;/strong&gt; ⚠️</source>
          <target state="translated">다음 &lt;code&gt;join_slices&lt;/code&gt; 함수는 &lt;strong&gt;불건전합니다&lt;/strong&gt; ⚠️</target>
        </trans-unit>
        <trans-unit id="34e28a9dda5b8f30dd258681b177c05e512cb9ec" translate="yes" xml:space="preserve">
          <source>The following are examples of struct expressions:</source>
          <target state="translated">다음은 구조체 표현식의 예입니다.</target>
        </trans-unit>
        <trans-unit id="0cfa813f73eeb4b3df6024040cdcdc9bf704edb3" translate="yes" xml:space="preserve">
          <source>The following code tries to return a closure directly, but it won&amp;rsquo;t compile:</source>
          <target state="translated">다음 코드는 클로저를 직접 반환하려고 시도하지만 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fdd790090c328b0bac332ac3bf94fd48a22d310" translate="yes" xml:space="preserve">
          <source>The following coercions are called &lt;code&gt;unsized coercions&lt;/code&gt;, since they relate to converting sized types to unsized types, and are permitted in a few cases where other coercions are not, as described above. They can still happen anywhere else a coercion can occur.</source>
          <target state="translated">다음의 강제 변환은 크기가 지정되지 않은 유형으로 변환되지 않는 것과 관련이 있기 때문에 &lt;code&gt;unsized coercions&lt;/code&gt; 되지 않은 강제 변환 이라고하며 , 위에 설명 된대로 다른 강제 변환이 아닌 경우에는 허용됩니다. 그들은 여전히 ​​강제가 발생할 수있는 다른 곳에서 일어날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5faa68338d0213add2f9ec4c067dc00f82eb825f" translate="yes" xml:space="preserve">
          <source>The following contexts are &lt;em&gt;place expression&lt;/em&gt; contexts:</source>
          <target state="translated">다음 컨텍스트는 &lt;em&gt;장소 표현식&lt;/em&gt; 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="a03f434198c8f12dc538595d512c2779094f1534" translate="yes" xml:space="preserve">
          <source>The following example contains a circular dependency between two traits:</source>
          <target state="translated">다음 예제는 두 특성 간의 순환 종속성을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="19cc88ac0ce4f5388077204fb21e73c4ffb89f2d" translate="yes" xml:space="preserve">
          <source>The following example implements &lt;code&gt;Index&lt;/code&gt; on a read-only &lt;code&gt;NucleotideCount&lt;/code&gt; container, enabling individual counts to be retrieved with index syntax.</source>
          <target state="translated">다음 예제 는 읽기 전용 &lt;code&gt;NucleotideCount&lt;/code&gt; 컨테이너에서 &lt;code&gt;Index&lt;/code&gt; 를 구현 하여 인덱스 구문으로 개별 카운트를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e6d78aaf2b8415e3caf24e2fa8603dbd9c8a54c" translate="yes" xml:space="preserve">
          <source>The following example showcases the fact that exclusive access to an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; implies exclusive access to its &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">다음 예제는 &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 대한 배타적 액세스가 &lt;code&gt;T&lt;/code&gt; 에 대한 배타적 액세스를 의미한다는 사실을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="b79316b13dbff6d7faf92f7fbb6c36c3b4504a1c" translate="yes" xml:space="preserve">
          <source>The following example uses &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; to create an optional box of &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;. Notice that in order to use the inner &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; value first, the &lt;code&gt;check_optional&lt;/code&gt; function needs to use pattern matching to determine whether the box has a value (i.e., it is &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(...)&lt;/code&gt;&lt;/a&gt;) or not (&lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">다음 예제에서는 &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 을 사용하여 &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 의 선택적 상자를 만듭니다 . 내부 &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 값을 먼저 사용하려면 &lt;code&gt;check_optional&lt;/code&gt; 함수가 패턴 일치를 사용하여 상자에 값이 있는지 (즉, &lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(...)&lt;/code&gt; &lt;/a&gt; ) 아닌지 ( &lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; ) 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="0098b757352995332c14af09f0677dc80f9a0b00" translate="yes" xml:space="preserve">
          <source>The following expressions are constant expressions, so long as any operands are also constant expressions and do not cause any &lt;a href=&quot;destructors&quot;&gt;&lt;code&gt;Drop::drop&lt;/code&gt;&lt;/a&gt; calls to be run.</source>
          <target state="translated">피연산자가 상수 표현식이고 &lt;a href=&quot;destructors&quot;&gt; &lt;code&gt;Drop::drop&lt;/code&gt; &lt;/a&gt; 호출을 실행 하지 않는 한 다음 표현식은 상수 표현식 입니다.</target>
        </trans-unit>
        <trans-unit id="a4fd2c18c35c909a948ecc39653105d7e64c5323" translate="yes" xml:space="preserve">
          <source>The following expressions are equivalent.</source>
          <target state="translated">다음 표현식은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f79e25578dbebf348320c4abf5b91615c4d5d3bd" translate="yes" xml:space="preserve">
          <source>The following expressions can be mutable place expression contexts:</source>
          <target state="translated">다음 표현식은 변경 가능한 장소 표현식 컨텍스트 일 ​​수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e8e60bb585909210311dad5aced6fb1ca9a2411" translate="yes" xml:space="preserve">
          <source>The following illustrates how tokens can be directly matched after matching a &lt;code&gt;tt&lt;/code&gt; fragment:</source>
          <target state="translated">다음은 &lt;code&gt;tt&lt;/code&gt; 조각을 일치시킨 후 토큰을 직접 일치시키는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="4cba4cc8b1a51987e47e31e5a3e9298ced934caa" translate="yes" xml:space="preserve">
          <source>The following is a list of the available feature names.</source>
          <target state="translated">다음은 사용 가능한 기능 이름의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="7bfbc404b57ece9100ac4d9b168ae9cc179de313" translate="yes" xml:space="preserve">
          <source>The following is an example of a derive macro. Instead of doing anything useful with its input, it just appends a function &lt;code&gt;answer&lt;/code&gt;.</source>
          <target state="translated">다음은 파생 매크로의 예입니다. 입력에 유용한 작업을 수행하는 대신 함수 &lt;code&gt;answer&lt;/code&gt; 만 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="cb90a0db80f40417302eef01e3aacf14fbc10a30" translate="yes" xml:space="preserve">
          <source>The following is an example of declaring &lt;code&gt;Shape&lt;/code&gt; to be a supertrait of &lt;code&gt;Circle&lt;/code&gt;.</source>
          <target state="translated">다음은 &lt;code&gt;Shape&lt;/code&gt; 를 &lt;code&gt;Circle&lt;/code&gt; 의 상위 특성으로 선언하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="0bc86808e703044cc02c714fea381b5d6b4eb104" translate="yes" xml:space="preserve">
          <source>The following is an index of all built-in attributes.</source>
          <target state="translated">다음은 모든 내장 속성의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="7cc1fc6a380ba45eaa1f4f2110280733486f387c" translate="yes" xml:space="preserve">
          <source>The following is an overview of the available synchronization objects:</source>
          <target state="translated">다음은 사용 가능한 동기화 개체에 대한 개요입니다.</target>
        </trans-unit>
        <trans-unit id="e77d4cd3fb5ca40ba38b2400787449b1eb8f401a" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved beginning in the 2018 edition.</source>
          <target state="translated">다음 키워드는 2018 년판부터 예약되었습니다.</target>
        </trans-unit>
        <trans-unit id="88a73d4d23e456f05faa46221aa0e7b9298c7349" translate="yes" xml:space="preserve">
          <source>The following keywords currently have the functionality described.</source>
          <target state="translated">다음 키워드에는 현재 설명 된 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5d973323cad12bb72185383671304dcd5ab9469" translate="yes" xml:space="preserve">
          <source>The following keywords do not have any functionality but are reserved by Rust for potential future use.</source>
          <target state="translated">다음 키워드는 기능이 없지만 나중에 사용할 수 있도록 Rust에 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e441a28a0807978c7d9ce6b3cf8c4bd39296d4e8" translate="yes" xml:space="preserve">
          <source>The following keywords were added beginning in the 2018 edition.</source>
          <target state="translated">2018 년 초부터 다음 키워드가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="7de22ffd047d06a2d94087f0583e69c5de3c8513" translate="yes" xml:space="preserve">
          <source>The following language level features cannot be used in the safe subset of Rust:</source>
          <target state="translated">다음 언어 레벨 기능은 Rust의 안전한 서브 세트에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fa4bbe49e1fb3a478a935beaddada675b665b643" translate="yes" xml:space="preserve">
          <source>The following list contains all non-letters that don&amp;rsquo;t function as operators; that is, they don&amp;rsquo;t behave like a function or method call.</source>
          <target state="translated">다음 목록에는 연산자로 작동하지 않는 모든 비 레터가 포함되어 있습니다. 즉, 함수 또는 메서드 호출처럼 동작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35b04ccb391eee75aac9df7cb7f1bfc81254ebee" translate="yes" xml:space="preserve">
          <source>The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers (except as raw identifiers as we&amp;rsquo;ll discuss in the &amp;ldquo;&lt;a href=&quot;#raw-identifiers&quot;&gt;Raw Identifiers&lt;/a&gt;&amp;rdquo; section), including names of functions, variables, parameters, struct fields, modules, crates, constants, macros, static values, attributes, types, traits, or lifetimes.</source>
          <target state="translated">다음 목록에는 Rust 언어에서 현재 또는 나중에 사용하도록 예약 된 키워드가 포함되어 있습니다. 따라서 함수 이름, 변수, 매개 변수, 구조체 필드, 모듈, 상자, 상수, 매크로, 정적 값을 포함하여 식별자로 사용할 수 없습니다 ( &quot; &lt;a href=&quot;#raw-identifiers&quot;&gt;원시 식별자&lt;/a&gt; &quot;섹션 에서 설명 할 원시 식별자 제외 ). , 속성, 유형, 특성 또는 수명.</target>
        </trans-unit>
        <trans-unit id="92af89abc5b10810cac2bde7c4403090edbb5361" translate="yes" xml:space="preserve">
          <source>The following notations are used by the &lt;em&gt;Lexer&lt;/em&gt; and &lt;em&gt;Syntax&lt;/em&gt; grammar snippets:</source>
          <target state="translated">다음 표기법은 &lt;em&gt;Lexer&lt;/em&gt; 및 &lt;em&gt;구문&lt;/em&gt; 문법 스 니펫 에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6c611de22c83326f1c10498c47d838ad78c2827b" translate="yes" xml:space="preserve">
          <source>The following return &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음은 &lt;a href=&quot;../primitive.bool&quot;&gt; &lt;code&gt;false&lt;/code&gt; 를&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1c03f7174ac895e9b31fae2f8cfc928f6b6b192e" translate="yes" xml:space="preserve">
          <source>The following return &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음은 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt; &lt;code&gt;false&lt;/code&gt; 를&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="452576d6c51a73e57d8181671d67361d1616b8f6" translate="yes" xml:space="preserve">
          <source>The following return false:</source>
          <target state="translated">다음은 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b857efb8bb558af5cdfcfd53ef42f4d49fe84301" translate="yes" xml:space="preserve">
          <source>The following rewritten version of &lt;code&gt;another_function&lt;/code&gt; shows what parameters look like in Rust:</source>
          <target state="translated">다음으로 작성된 &lt;code&gt;another_function&lt;/code&gt; 버전은 Rust에서 어떤 매개 변수가 나타나는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7befecdaf697f20709a802fcb20813e2f422fba6" translate="yes" xml:space="preserve">
          <source>The following sections contain reference material you may find useful in your Rust journey.</source>
          <target state="translated">다음 섹션에는 Rust 여행에 유용한 참조 자료가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d4dd709d05236da16b69a96983ce9c67ce45124" translate="yes" xml:space="preserve">
          <source>The following steps install the latest stable version of the Rust compiler. Rust&amp;rsquo;s stability guarantees ensure that all the examples in the book that compile will continue to compile with newer Rust versions. The output might differ slightly between versions, because Rust often improves error messages and warnings. In other words, any newer, stable version of Rust you install using these steps should work as expected with the content of this book.</source>
          <target state="translated">다음 단계는 최신 안정 버전의 Rust 컴파일러를 설치합니다. Rust의 안정성은이 책의 모든 예제가 새로운 Rust 버전으로 계속 컴파일되도록 보장합니다. Rust는 종종 오류 메시지와 경고를 개선하기 때문에 출력은 버전마다 약간 다를 수 있습니다. 다시 말해,이 단계를 사용하여 설치하는 새롭고 안정적인 버전의 Rust가이 책의 내용에 맞게 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="d23c37bf8f18aef980fb1fbefe90db0a500a0719" translate="yes" xml:space="preserve">
          <source>The following table gives the size for primitives.</source>
          <target state="translated">다음 표는 프리미티브의 크기를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3bc9c0126109b1bad1345c2a1d2c68127ed67d67" translate="yes" xml:space="preserve">
          <source>The following traits are implemented for all &lt;code&gt;&amp;amp;T&lt;/code&gt;, regardless of the type of its referent:</source>
          <target state="translated">참조 유형에 관계없이 모든 &lt;code&gt;&amp;amp;T&lt;/code&gt; 대해 다음과 같은 특성이 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e9fcf457a5e9ecd7495ab63bfd0f41db2476290" translate="yes" xml:space="preserve">
          <source>The following traits are implemented on &lt;code&gt;&amp;amp;T&lt;/code&gt; references if the underlying &lt;code&gt;T&lt;/code&gt; also implements that trait:</source>
          <target state="translated">기본 &lt;code&gt;T&lt;/code&gt; 가 해당 특성을 구현하는 경우 &lt;code&gt;&amp;amp;T&lt;/code&gt; 참조 에 다음 특성이 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="be48c1df52265e0b68ec35bc1f2481219af6ad7a" translate="yes" xml:space="preserve">
          <source>The following will print &quot;Custom panic hook&quot;:</source>
          <target state="translated">다음은 &quot;Custom panic hook&quot;을 인쇄합니다 :</target>
        </trans-unit>
        <trans-unit id="882019462e8fd74a5df1bf54582eb004918743ba" translate="yes" xml:space="preserve">
          <source>The following will print &quot;Normal panic&quot;:</source>
          <target state="translated">다음은 &quot;정상 패닉&quot;을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="7ed71896f2a34a4014ac80c7f9efbde1c744961e" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;(..)&lt;/code&gt; with a single &lt;a href=&quot;#rest-patterns&quot;&gt;&lt;em&gt;RestPattern&lt;/em&gt;&lt;/a&gt; is a special form that does not require a comma, and matches a tuple of any size.</source>
          <target state="translated">단일 &lt;a href=&quot;#rest-patterns&quot;&gt;&lt;em&gt;RestPattern&lt;/em&gt;&lt;/a&gt; 이있는 양식 &lt;code&gt;(..)&lt;/code&gt; 은 쉼표가 필요하지 않은 특수 양식이며 모든 크기의 튜플과 일치합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a310cc6ed2f47da18129871732d4b9900992d6f" translate="yes" xml:space="preserve">
          <source>The formal way of describing this behavior is that expressions of type &lt;code&gt;!&lt;/code&gt; can be coerced into any other type. We&amp;rsquo;re allowed to end this &lt;code&gt;match&lt;/code&gt; arm with &lt;code&gt;continue&lt;/code&gt; because &lt;code&gt;continue&lt;/code&gt; doesn&amp;rsquo;t return a value; instead, it moves control back to the top of the loop, so in the &lt;code&gt;Err&lt;/code&gt; case, we never assign a value to &lt;code&gt;guess&lt;/code&gt;.</source>
          <target state="translated">이 동작을 설명하는 공식적인 방법은 &lt;code&gt;!&lt;/code&gt; 다른 유형으로 강요 할 수 있습니다. &lt;code&gt;continue&lt;/code&gt; 는 값을 반환하지 않기 때문에이 &lt;code&gt;match&lt;/code&gt; arm을 &lt;code&gt;continue&lt;/code&gt; 로 종료 할 수 있습니다 . 대신 제어를 루프의 맨 위로 이동하므로 &lt;code&gt;Err&lt;/code&gt; 의 경우 &lt;code&gt;guess&lt;/code&gt; 에 값을 할당하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="99bcb45d13b51e9ae5259463fdd2a32bb1c9a90e" translate="yes" xml:space="preserve">
          <source>The full circle constant (&amp;tau;)</source>
          <target state="translated">전체 원 상수 (&amp;tau;)</target>
        </trans-unit>
        <trans-unit id="cd8574fedd8387c0dcc9c1aeee32062dd23e8095" translate="yes" xml:space="preserve">
          <source>The full path is created by joining the original path to &lt;code&gt;read_dir&lt;/code&gt; with the filename of this entry.</source>
          <target state="translated">전체 경로는 원래 경로를 &lt;code&gt;read_dir&lt;/code&gt; 에이 항목의 파일 이름과 결합하여 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="32f32b59c17ac39e46a137b79b14f93e65ff40c1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;inner_drop&lt;/code&gt; has the type that &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt;&lt;em&gt;should&lt;/em&gt; have, so this makes sure that you do not accidentally use &lt;code&gt;self&lt;/code&gt;/&lt;code&gt;this&lt;/code&gt; in a way that is in conflict with pinning.</source>
          <target state="translated">&lt;code&gt;inner_drop&lt;/code&gt; 함수 에는 &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 이&lt;/em&gt; 가져야 하는 유형이 있으므로 고정과 충돌하는 방식으로 실수로 &lt;code&gt;self&lt;/code&gt; / &lt;code&gt;this&lt;/code&gt; 를 사용하지 않도록 합니다.</target>
        </trans-unit>
        <trans-unit id="41bd7d7e62e02a905d152c2bd99a0375a7ed8226" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;inner_drop&lt;/code&gt; has the type that &lt;code&gt;drop&lt;/code&gt;&lt;em&gt;should&lt;/em&gt; have, so this makes sure that you do not accidentally use &lt;code&gt;self&lt;/code&gt;/&lt;code&gt;this&lt;/code&gt; in a way that is in conflict with pinning.</source>
          <target state="translated">&lt;code&gt;inner_drop&lt;/code&gt; 함수 에는 &lt;code&gt;drop&lt;/code&gt; 유형이 &lt;em&gt;있어야&lt;/em&gt; 하므로 실수 로 피닝과 충돌하는 방식으로 &lt;code&gt;self&lt;/code&gt; / &lt;code&gt;this&lt;/code&gt; 를 사용하지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="cf14d5d5cd860e1137527a26dcf1970a6fdcd6cb" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; is unsafe because it takes a raw pointer and must trust that this pointer is valid. The &lt;code&gt;add&lt;/code&gt; method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. Therefore, we had to put an &lt;code&gt;unsafe&lt;/code&gt; block around our calls to &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; so we could call them. By looking at the code and by adding the assertion that &lt;code&gt;mid&lt;/code&gt; must be less than or equal to &lt;code&gt;len&lt;/code&gt;, we can tell that all the raw pointers used within the &lt;code&gt;unsafe&lt;/code&gt; block will be valid pointers to data within the slice. This is an acceptable and appropriate use of &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; 함수 는 원시 포인터를 사용하고이 포인터가 유효하다는 것을 신뢰해야하기 때문에 안전하지 않습니다. 원시 포인터 의 &lt;code&gt;add&lt;/code&gt; 메서드도 오프셋 위치가 유효한 포인터임을 신뢰해야하기 때문에 안전하지 않습니다. 따라서, 우리는 넣어 가지고 &lt;code&gt;unsafe&lt;/code&gt; 에 대한 우리의 호출 주변 블록 &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; 및 &lt;code&gt;add&lt;/code&gt; 우리가 그들을 호출 할 수 있도록. 코드를보고 &lt;code&gt;mid&lt;/code&gt; 가 &lt;code&gt;len&lt;/code&gt; 보다 작거나 같아야 한다는 단언을 추가함으로써 &lt;code&gt;unsafe&lt;/code&gt; 블록 내에서 사용되는 모든 원시 포인터 가 슬라이스 내 데이터에 대한 유효한 포인터가 될 것임을 알 수 있습니다. 이것은 &lt;code&gt;unsafe&lt;/code&gt; 것의 허용되고 적절한 사용입니다..</target>
        </trans-unit>
        <trans-unit id="bcc8f276c3240e55b6476f93fee8521728c232e7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; is unsafe because it takes a raw pointer and must trust that this pointer is valid. The &lt;code&gt;offset&lt;/code&gt; method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. Therefore, we had to put an &lt;code&gt;unsafe&lt;/code&gt; block around our calls to &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; so we could call them. By looking at the code and by adding the assertion that &lt;code&gt;mid&lt;/code&gt; must be less than or equal to &lt;code&gt;len&lt;/code&gt;, we can tell that all the raw pointers used within the &lt;code&gt;unsafe&lt;/code&gt; block will be valid pointers to data within the slice. This is an acceptable and appropriate use of &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; 함수 는 원시 포인터를 사용 하므로이 포인터가 유효하다는 것을 신뢰해야하므로 안전하지 않습니다. 원시 포인터 의 &lt;code&gt;offset&lt;/code&gt; 방법도 오프셋 위치가 유효한 포인터임을 신뢰해야하므로 안전하지 않습니다. 따라서 &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; 및 &lt;code&gt;offset&lt;/code&gt; 호출에 &lt;code&gt;unsafe&lt;/code&gt; 블록 을 배치하여 호출 할 수 있도록해야했습니다. 코드를 살펴보고 &lt;code&gt;mid&lt;/code&gt; 가 &lt;code&gt;len&lt;/code&gt; 보다 작거나 같아야 하는 어설 션을 추가 하면 &lt;code&gt;unsafe&lt;/code&gt; 블록 내에서 사용되는 모든 원시 포인터 가 슬라이스 내 데이터에 대한 유효한 포인터 임을 알 수 있습니다 . 이것은 수용 가능하고 적절한 사용입니다 &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e2ea4196275fb1f06fa7661da10e384c365aa9f" translate="yes" xml:space="preserve">
          <source>The function body block is contained within the scope of the entire function.</source>
          <target state="translated">함수 본문 블록은 전체 함수 범위 내에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2cd654b546be7671958f348149444656b0175877" translate="yes" xml:space="preserve">
          <source>The function body uses the &lt;code&gt;assert_eq!&lt;/code&gt; macro to assert that 2 + 2 equals 4. This assertion serves as an example of the format for a typical test. Let&amp;rsquo;s run it to see that this test passes.</source>
          <target state="translated">함수 본문은 &lt;code&gt;assert_eq!&lt;/code&gt; 매크로는 2 + 2가 4와 같다고 주장합니다.이 어설 션은 일반적인 테스트 형식의 예입니다. 이 테스트가 통과했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fce36fec5fc1977be02dde267db493eca3e79d7a" translate="yes" xml:space="preserve">
          <source>The function must be called with valid byte array &lt;code&gt;buf&lt;/code&gt; of sufficient size to hold the message bytes. If a message is too long to fit in the supplied buffer, excess bytes may be discarded.</source>
          <target state="translated">메시지 바이트를 보유하기에 충분한 크기의 유효한 바이트 배열 &lt;code&gt;buf&lt;/code&gt; 로 함수를 호출해야합니다 . 메시지가 너무 길어 제공된 버퍼에 맞지 않으면 초과 바이트가 삭제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e529ccf733a9b5ef8b1c476a20d42d70328c6fe4" translate="yes" xml:space="preserve">
          <source>The function panics if &lt;code&gt;align&lt;/code&gt; is not a power-of-two.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; 이 2의 거듭 제곱이 아닌 경우 함수 패닉이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="3c4c57538d04834ae5173c38a3f23dea7037d387" translate="yes" xml:space="preserve">
          <source>The function signature now tells Rust that for some lifetime &lt;code&gt;'a&lt;/code&gt;, the function takes two parameters, both of which are string slices that live at least as long as lifetime &lt;code&gt;'a&lt;/code&gt;. The function signature also tells Rust that the string slice returned from the function will live at least as long as lifetime &lt;code&gt;'a&lt;/code&gt;. In practice, it means that the lifetime of the reference returned by the &lt;code&gt;longest&lt;/code&gt; function is the same as the smaller of the lifetimes of the references passed in. These constraints are what we want Rust to enforce. Remember, when we specify the lifetime parameters in this function signature, we&amp;rsquo;re not changing the lifetimes of any values passed in or returned. Rather, we&amp;rsquo;re specifying that the borrow checker should reject any values that don&amp;rsquo;t adhere to these constraints. Note that the &lt;code&gt;longest&lt;/code&gt; function doesn&amp;rsquo;t need to know exactly how long &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; will live, only that some scope can be substituted for &lt;code&gt;'a&lt;/code&gt; that will satisfy this signature.</source>
          <target state="translated">함수 서명은 지금 어떤 평생 것을 녹 말한다 &lt;code&gt;'a&lt;/code&gt; 함수가 수명만큼 적어도 살고 문자열 조각입니다 둘 다 두 개의 매개 변수, 소요 &lt;code&gt;'a&lt;/code&gt; . 함수 시그니처는 또한 Rust에게 함수에서 반환 된 문자열 슬라이스가 적어도 수명 &lt;code&gt;'a&lt;/code&gt; 만큼 지속될 것이라고 알립니다 . 실제로는 참조의 수명이 &lt;code&gt;longest&lt;/code&gt; 함수는 전달 된 레퍼런스의 수명이 짧을 때와 동일합니다. 이러한 제약 조건은 Rust가 적용하기를 원하는 것입니다. 이 함수 시그니처에 수명 매개 변수를 지정할 때 전달되거나 리턴 된 값의 수명은 변경되지 않습니다. 대신 차용 검사기가 이러한 제약 조건을 준수하지 않는 값을 거부하도록 지정합니다. 있습니다 &lt;code&gt;longest&lt;/code&gt; 기능이 정확하게 시간을 알 필요가 없습니다 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 어떤 범위를 대체 할 수있는 유일한 것으로, 살 것이다 &lt;code&gt;'a&lt;/code&gt; 이 서명을 만족시킬 것이다.</target>
        </trans-unit>
        <trans-unit id="bdcb7a1c11baa13711e61ba40d7e28572f624f97" translate="yes" xml:space="preserve">
          <source>The function that defines a procedural macro takes a &lt;code&gt;TokenStream&lt;/code&gt; as an input and produces a &lt;code&gt;TokenStream&lt;/code&gt; as an output. The &lt;code&gt;TokenStream&lt;/code&gt; type is defined by the &lt;code&gt;proc_macro&lt;/code&gt; crate that is included with Rust and represents a sequence of tokens. This is the core of the macro: the source code that the macro is operating on makes up the input &lt;code&gt;TokenStream&lt;/code&gt;, and the code the macro produces is the output &lt;code&gt;TokenStream&lt;/code&gt;. The function also has an attribute attached to it that specifies which kind of procedural macro we&amp;rsquo;re creating. We can have multiple kinds of procedural macros in the same crate.</source>
          <target state="translated">절차 적 매크로를 정의하는 함수는 &lt;code&gt;TokenStream&lt;/code&gt; 을 입력으로 사용하고 &lt;code&gt;TokenStream&lt;/code&gt; 을 출력으로 생성합니다 . &lt;code&gt;TokenStream&lt;/code&gt; 의 타입에 의해 정의된다 &lt;code&gt;proc_macro&lt;/code&gt; 녹 포함 토큰의 시퀀스를 나타내고있다 상자. 이것이 매크로의 핵심입니다. 매크로가 작동하는 소스 코드는 입력 &lt;code&gt;TokenStream&lt;/code&gt; 을 구성하고 매크로가 생성하는 코드는 출력 &lt;code&gt;TokenStream&lt;/code&gt; 입니다. 이 함수에는 생성하는 절차 매크로의 종류를 지정하는 속성도 붙어 있습니다. 같은 상자에 여러 종류의 절차 매크로를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf36f24b39c35b8342b2a6251cb9fb9f153537b5" translate="yes" xml:space="preserve">
          <source>The function will never return and will immediately terminate the current process in a platform specific &quot;abnormal&quot; manner.</source>
          <target state="translated">이 함수는 플랫폼 특정 &quot;비정상적인&quot;방식으로 반환되지 않으며 현재 프로세스를 즉시 종료합니다.</target>
        </trans-unit>
        <trans-unit id="0c78d2fcec6d6debbe4ef0124bd9c3f517852fce" translate="yes" xml:space="preserve">
          <source>The functional record update syntax is only allowed for structs (struct-like enum variants don't qualify, for example). To fix the previous code, rewrite the expression without functional record update syntax:</source>
          <target state="translated">기능 레코드 업데이트 구문은 구조체에만 허용됩니다 (예를 들어 구조체와 유사한 열거 형 변형은 한정되지 않음). 이전 코드를 수정하려면 기능 레코드 업데이트 구문없이 표현식을 다시 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="4265d286c4ebab2fa68494c58f7e5472bec6ff8e" translate="yes" xml:space="preserve">
          <source>The functional record update syntax is only allowed for structs. (Struct-like enum variants don't qualify, for example.)</source>
          <target state="translated">기능 레코드 업데이트 구문은 구조체에만 허용됩니다. 예를 들어, 구조와 유사한 열거 형 변형은 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="771371fc3674c285662522a3ce8c91121a8eb8d5" translate="yes" xml:space="preserve">
          <source>The functional record update syntax was used on something other than a struct.</source>
          <target state="translated">기능 레코드 업데이트 구문이 구조체 이외의 다른 항목에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="3064e7a399dc1562d735ddcb75b4d1c141aa6d18" translate="yes" xml:space="preserve">
          <source>The functionality and syntax of Rust can be extended with custom definitions called macros. They are given names, and invoked through a consistent syntax:&lt;code&gt;some_extension!(...)&lt;/code&gt;.</source>
          <target state="translated">Rust의 기능과 구문은 매크로라는 사용자 정의로 확장 할 수 있습니다. 이름이 주어지고 &lt;code&gt;some_extension!(...)&lt;/code&gt; 과 같은 일관된 구문을 통해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="90f6e5d380880e28cc22176bc452d0a2cfb51f5f" translate="yes" xml:space="preserve">
          <source>The functions inside this struct are only intended be called on the &lt;code&gt;data&lt;/code&gt; pointer of a properly constructed &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object from inside the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; implementation. Calling one of the contained functions using any other &lt;code&gt;data&lt;/code&gt; pointer will cause undefined behavior.</source>
          <target state="translated">이 구조체 내부의 함수 는 &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; 구현 내부에서 올바르게 구성된 &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;code&gt;data&lt;/code&gt; 포인터 에서만 호출됩니다 . 다른 &lt;code&gt;data&lt;/code&gt; 포인터를 사용하여 포함 된 함수 중 하나를 호출 하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5d3fe931a60678fe761ffe2bfb5b03361ca50257" translate="yes" xml:space="preserve">
          <source>The functions inside this struct are only intended to be called on the &lt;code&gt;data&lt;/code&gt; pointer of a properly constructed &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object from inside the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; implementation. Calling one of the contained functions using any other &lt;code&gt;data&lt;/code&gt; pointer will cause undefined behavior.</source>
          <target state="translated">이 구조체 내부의 함수 는 &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; 구현 내부에서 적절하게 구성된 &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;code&gt;data&lt;/code&gt; 포인터 에서만 호출됩니다 . 다른 &lt;code&gt;data&lt;/code&gt; 포인터를 사용하여 포함 된 함수 중 하나를 호출 하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="df0966ed788f9044d3bbbf28ed214b74382d234e" translate="yes" xml:space="preserve">
          <source>The general case</source>
          <target state="translated">일반적인 경우</target>
        </trans-unit>
        <trans-unit id="44389c2bb8540f5071dbf79b16d89782c82ab1a7" translate="yes" xml:space="preserve">
          <source>The general categories for numbers (&lt;code&gt;Nd&lt;/code&gt; for decimal digits, &lt;code&gt;Nl&lt;/code&gt; for letter-like numeric characters, and &lt;code&gt;No&lt;/code&gt; for other numeric characters) are specified in the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">숫자의 일반 범주 ( 십진수는 &lt;code&gt;Nd&lt;/code&gt; , 문자와 유사한 숫자는 &lt;code&gt;Nl&lt;/code&gt; , 기타 숫자는 &lt;code&gt;No&lt;/code&gt; )는 &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database &lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt; &lt;code&gt;UnicodeData.txt&lt;/code&gt; 에&lt;/a&gt; 지정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a1ceefd46a3c1a3651802a4204c4c589bc3c7f6" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;PartialEq&lt;/code&gt; is equivalent to</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; 에 대해 생성 된 &lt;code&gt;impl&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b683f5ed135731413c6d034116ca989acf594401" translate="yes" xml:space="preserve">
          <source>The generator completed with a return value.</source>
          <target state="translated">생성기가 리턴 값으로 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="156bc757a593c6f0753b493e20c7157ef75917ae" translate="yes" xml:space="preserve">
          <source>The generator suspended with a value.</source>
          <target state="translated">생성기가 값으로 일시 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="cd45c192be4dc3d892b1ef2f0b632aaff12d6653" translate="yes" xml:space="preserve">
          <source>The generic type &lt;code&gt;T&lt;/code&gt; specified as the type of the &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; parameters constrains the function such that the concrete type of the value passed as an argument for &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; must be the same.</source>
          <target state="translated">일반 타입 &lt;code&gt;T&lt;/code&gt; 는 의 형식으로 지정된 &lt;code&gt;item1&lt;/code&gt; 과 &lt;code&gt;item2&lt;/code&gt; 제약을 께 값의 구체적인 유형에 대한 인수로 전달하도록 기능 파라미터 &lt;code&gt;item1&lt;/code&gt; 과 &lt;code&gt;item2&lt;/code&gt; 동일해야한다.</target>
        </trans-unit>
        <trans-unit id="1bc01fb3a417f3ff749e03a42ff1490b6833bd43" translate="yes" xml:space="preserve">
          <source>The generic type has to be a SIMD type. Example:</source>
          <target state="translated">일반 유형은 SIMD 유형이어야합니다. 예:</target>
        </trans-unit>
        <trans-unit id="e58faf99c3204433210564e65725762b8514494f" translate="yes" xml:space="preserve">
          <source>The given &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;strong&gt;must&lt;/strong&gt; have one nul byte as its last element. This means it cannot be empty nor have any other nul byte anywhere else.</source>
          <target state="translated">주어진 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt;&lt;strong&gt; 은&lt;/strong&gt; 마지막 요소로 하나의 nul 바이트를 가져야 &lt;strong&gt;합니다&lt;/strong&gt; . 이것은 비어 있거나 다른 곳에 다른 nul 바이트를 가질 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b25fdf4b8d15b07b7d25cece8768d803831d5b3d" translate="yes" xml:space="preserve">
          <source>The given block must have been produced by this allocator, and must be suitable for storing a &lt;code&gt;T&lt;/code&gt; (in terms of alignment as well as minimum and maximum size); otherwise yields undefined behavior.</source>
          <target state="translated">주어진 블록은이 할당 자에 의해 생성되어야하고, (최소 및 최대 크기뿐만 아니라 정렬 측면에서) &lt;code&gt;T&lt;/code&gt; 를 저장하기에 적합해야한다 ; 그렇지 않으면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3ef7afeafd2e9737676d96a4cbd3c7dc2e9ffdbc" translate="yes" xml:space="preserve">
          <source>The glob operator is often used when testing to bring everything under test into the &lt;code&gt;tests&lt;/code&gt; module; we&amp;rsquo;ll talk about that in the &lt;a href=&quot;ch11-01-writing-tests#how-to-write-tests&quot;&gt;&amp;ldquo;How to Write Tests&amp;rdquo;&lt;/a&gt; section in Chapter 11. The glob operator is also sometimes used as part of the prelude pattern: see &lt;a href=&quot;../std/prelude/index#other-preludes&quot;&gt;the standard library documentation&lt;/a&gt; for more information on that pattern.</source>
          <target state="translated">글로브 연산자는 테스트 할 때 테스트중인 모든 것을 &lt;code&gt;tests&lt;/code&gt; 모듈 로 가져 오기 위해 종종 사용됩니다 . 11 장의 &lt;a href=&quot;ch11-01-writing-tests#how-to-write-tests&quot;&gt;&quot;테스트 작성 방법&quot;&lt;/a&gt; 섹션 에서 그에 대해 이야기 할 것입니다 . glob 연산자는 때로는 전주곡 패턴의 일부로 사용되기도 합니다. 해당 패턴에 대한 자세한 내용 &lt;a href=&quot;../std/prelude/index#other-preludes&quot;&gt;은 표준 라이브러리 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="edae830710bf3e8598def4042b918afe98bc10c2" translate="yes" xml:space="preserve">
          <source>The global memory allocator.</source>
          <target state="translated">글로벌 메모리 할당 자.</target>
        </trans-unit>
        <trans-unit id="ec4646ba1a1fdd24f47203209a1bde5837e4ed73" translate="yes" xml:space="preserve">
          <source>The good news is that if the structure &lt;em&gt;isn&amp;rsquo;t&lt;/em&gt; convenient for others to use from another library, you don&amp;rsquo;t have to rearrange your internal organization: instead, you can re-export items to make a public structure that&amp;rsquo;s different from your private structure by using &lt;code&gt;pub use&lt;/code&gt;. Re-exporting takes a public item in one location and makes it public in another location, as if it were defined in the other location instead.</source>
          <target state="translated">좋은 소식은 다른 라이브러리에서 다른 사람이 사용하기에 구조 &lt;em&gt;가&lt;/em&gt; 불편한 경우 내부 조직을 재 배열 할 필요가 없다는 것입니다. 대신 개인 구조와 다른 공용 구조를 만들기 위해 항목을 다시 내보낼 수 있습니다. 사용하여 &lt;code&gt;pub use&lt;/code&gt; . 다시 내보내기는 한 위치에서 공개 항목을 가져 와서 다른 위치에서 정의 된 것처럼 다른 위치에서 공개합니다.</target>
        </trans-unit>
        <trans-unit id="9e529cd967841dc9eed1fc815f3a4e6b886e5b38" translate="yes" xml:space="preserve">
          <source>The grammar and lexical structure is in blockquotes with either &quot;Lexer&quot; or &quot;Syntax&quot; in &lt;sup&gt;&lt;strong&gt;bold superscript&lt;/strong&gt;&lt;/sup&gt; as the first line.</source>
          <target state="translated">문법과 어휘 구조는 첫 번째 줄로 &lt;sup&gt;&lt;strong&gt;굵은 위첨자&lt;/strong&gt;&lt;/sup&gt; 에 &quot;Lexer&quot;또는 &quot;Syntax&quot;가 &lt;sup&gt;&lt;strong&gt;붙은&lt;/strong&gt;&lt;/sup&gt; 인용 부호 입니다.</target>
        </trans-unit>
        <trans-unit id="1f36df1235888018fbfcd5153ebfed60de89aef3" translate="yes" xml:space="preserve">
          <source>The grammar production for reference patterns has to match the token &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; to match a reference to a reference because it is a token by itself, not two &lt;code&gt;&amp;amp;&lt;/code&gt; tokens.</source>
          <target state="translated">기준 패턴 문법 생산 토큰이 일치해야 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 은 토큰 자체가 없기 때문에 두 기준 참조 일치 &lt;code&gt;&amp;amp;&lt;/code&gt; 토큰.</target>
        </trans-unit>
        <trans-unit id="ecdb2fc042ccb9955819301d5b939d1fbe330ddf" translate="yes" xml:space="preserve">
          <source>The green-threading M:N model requires a larger language runtime to manage threads. As such, the Rust standard library only provides an implementation of 1:1 threading. Because Rust is such a low-level language, there are crates that implement M:N threading if you would rather trade overhead for aspects such as more control over which threads run when and lower costs of context switching, for example.</source>
          <target state="translated">그린 스레딩 M : N 모델은 스레드를 관리하기 위해 더 큰 언어 런타임이 필요합니다. 따라서 Rust 표준 라이브러리는 1 : 1 스레딩 구현 만 제공합니다. Rust는 저수준 언어이기 때문에 예를 들어 컨텍스트 전환 비용을 낮추고 컨텍스트 전환 비용을 낮추는 스레드 제어에 대한 오버 헤드를 조정하려는 경우 M : N 스레딩을 구현하는 상자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebee4d45f3971e13391e35d52c5a14b0340c1efd" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard error (stderr), if it has been captured.</source>
          <target state="translated">자식의 표준 오류 (stderr)를 읽은 경우이를 읽기위한 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="71a4cc891c9774ed993ea2778e2ec4e78d46aa4f" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard error (stderr), if it has been captured. You might find it helpful to do</source>
          <target state="translated">캡처 된 경우 자식의 표준 오류 (stderr)에서 읽기위한 핸들입니다. 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbdaac9b24bb1d15aadc721c15a3031cb1337d9a" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard output (stdout), if it has been captured.</source>
          <target state="translated">자식의 표준 출력 (stdout)에서 캡처 된 경우 읽기위한 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="5b65d5fd43c0bfac48d483d2399323a0f40fd595" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard output (stdout), if it has been captured. You might find it helpful to do</source>
          <target state="translated">캡처 된 경우 자식의 표준 출력 (stdout)에서 읽기위한 핸들입니다. 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d208573c971bb153ba34475100ea53bd4242537e" translate="yes" xml:space="preserve">
          <source>The handle for writing to the child's standard input (stdin), if it has been captured.</source>
          <target state="translated">아이의 표준 입력 (stdin)에 기록하기위한 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="1008f723c1fd717a94e8a77d7bc5c5ff92ef4700" translate="yes" xml:space="preserve">
          <source>The handle for writing to the child's standard input (stdin), if it has been captured. To avoid partially moving the &lt;code&gt;child&lt;/code&gt; and thus blocking yourself from calling functions on &lt;code&gt;child&lt;/code&gt; while using &lt;code&gt;stdin&lt;/code&gt;, you might find it helpful:</source>
          <target state="translated">캡처 된 경우 자식의 표준 입력 (stdin)에 쓰기위한 핸들입니다. &lt;code&gt;child&lt;/code&gt; 부분적으로 이동 하여 &lt;code&gt;stdin&lt;/code&gt; 을 사용하는 동안 &lt;code&gt;child&lt;/code&gt; 에서 함수를 호출하지 못하도록 차단 하는 것을 방지하려면 다음이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9febcaaba526b722c76a7ab2b805ffd862b6652" translate="yes" xml:space="preserve">
          <source>The hash map is initially created with a capacity of 0, so it will not allocate until it is first inserted into.</source>
          <target state="translated">해시 맵은 처음에 용량이 0으로 만들어 지므로 처음 삽입 될 때까지 할당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee8ffcf3c4827d14350f3675ea8e7360ee55ee19" translate="yes" xml:space="preserve">
          <source>The hash map will be able to hold at least &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the hash map will not allocate.</source>
          <target state="translated">해시 맵은 재 할당없이 최소한의 &lt;code&gt;capacity&lt;/code&gt; 요소 를 보유 할 수 있습니다 . 경우 &lt;code&gt;capacity&lt;/code&gt; 0, 해시 맵이 할당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b56c1bdca2b1b95316afe0ecdd6afdabfe66713" translate="yes" xml:space="preserve">
          <source>The hash set is also created with the default initial capacity.</source>
          <target state="translated">해시 세트도 기본 초기 용량으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="b637bd7a31fb790788f10cfb96ebb867cfd6151d" translate="yes" xml:space="preserve">
          <source>The hash set is initially created with a capacity of 0, so it will not allocate until it is first inserted into.</source>
          <target state="translated">해시 세트는 처음에 용량 0으로 작성되므로 처음 삽입 될 때까지 할당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b099ba43b1ded8417cfcd0145835bc5cf64881f" translate="yes" xml:space="preserve">
          <source>The hash set will be able to hold at least &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the hash set will not allocate.</source>
          <target state="translated">해시 세트는 재 할당없이 최소 &lt;code&gt;capacity&lt;/code&gt; 요소 를 보유 할 수 있습니다 . 경우 &lt;code&gt;capacity&lt;/code&gt; 0, 해시 세트는 할당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8a4e0ea14c5f027cfeb61abdb7d26fe519f8ab6" translate="yes" xml:space="preserve">
          <source>The hash table implementation is a Rust port of Google's &lt;a href=&quot;https://abseil.io/blog/20180927-swisstables&quot;&gt;SwissTable&lt;/a&gt;. The original C++ version of SwissTable can be found &lt;a href=&quot;https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h&quot;&gt;here&lt;/a&gt;, and this &lt;a href=&quot;https://www.youtube.com/watch?v=ncHmEUmJZf4&quot;&gt;CppCon talk&lt;/a&gt; gives an overview of how the algorithm works.</source>
          <target state="translated">해시 테이블 구현은 Google &lt;a href=&quot;https://abseil.io/blog/20180927-swisstables&quot;&gt;SwissTable&lt;/a&gt; 의 Rust 포트입니다 . SwissTable의 원래 C ++ 버전은 &lt;a href=&quot;https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 &lt;a href=&quot;https://www.youtube.com/watch?v=ncHmEUmJZf4&quot;&gt;있으며이 CppCon talk&lt;/a&gt; 는 알고리즘 작동 방식에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="415bb7e03ead8b051422fe277c860425b7ebbf61" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;#method.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">해싱 알고리즘은 &lt;a href=&quot;#method.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#method.with_hasher&quot;&gt; &lt;code&gt;with_hasher&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#method.with_capacity_and_hasher&quot;&gt; &lt;code&gt;with_capacity_and_hasher&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;code&gt;HashMap&lt;/code&gt; 별로 교체 할 수 있습니다 . &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt; &lt;code&gt;fnv&lt;/code&gt; &lt;/a&gt; crate 와 같은 crates.io에서 많은 대체 알고리즘을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="142488b9261462c1e559bf3f2ad49337e31e2ac1" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../struct.hashmap#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../struct.hashmap#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">해싱 알고리즘은 &lt;a href=&quot;../../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../struct.hashmap#method.with_hasher&quot;&gt; &lt;code&gt;with_hasher&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../struct.hashmap#method.with_capacity_and_hasher&quot;&gt; &lt;code&gt;with_capacity_and_hasher&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;code&gt;HashMap&lt;/code&gt; 별로 대체 할 수 있습니다 . &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt; &lt;code&gt;fnv&lt;/code&gt; &lt;/a&gt; 크레이트 와 같은 많은 대체 알고리즘을 crates.io에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="417d67f06aec820d5f0416a0fabba770f0ab5392" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.hashmap#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.hashmap#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">해싱 알고리즘은 &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.hashmap#method.with_hasher&quot;&gt; &lt;code&gt;with_hasher&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.hashmap#method.with_capacity_and_hasher&quot;&gt; &lt;code&gt;with_capacity_and_hasher&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;code&gt;HashMap&lt;/code&gt; 별로 대체 할 수 있습니다 . &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt; &lt;code&gt;fnv&lt;/code&gt; &lt;/a&gt; 크레이트 와 같은 많은 대체 알고리즘을 crates.io에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36e2055f1b7671fa46f87316bf9cf49547025536" translate="yes" xml:space="preserve">
          <source>The heart and soul of this module is the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; trait. The core of &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; looks like this:</source>
          <target state="translated">이 모듈의 핵심은 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 특성입니다. &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 핵심은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f7cf9da11ff393d577012f24f0fd7f9d800c440a" translate="yes" xml:space="preserve">
          <source>The heart of the change is that where &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; used to default to &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'a&amp;gt;&lt;/code&gt;, it now defaults to &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'static&amp;gt;&lt;/code&gt; (here, &lt;code&gt;SomeTrait&lt;/code&gt; is the name of some trait type). Note that the only types which are affected are references to boxes, like &lt;code&gt;&amp;amp;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;[Box&amp;lt;SomeTrait&amp;gt;]&lt;/code&gt;. More common types like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; or &lt;code&gt;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; are unaffected.</source>
          <target state="translated">변경의 핵심은 &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; 이 기본값으로 &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'a&amp;gt;&lt;/code&gt; , 기본값은 &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'static&amp;gt;&lt;/code&gt; (여기서 &lt;code&gt;SomeTrait&lt;/code&gt; 은 일부 특성 유형). 영향을받는 유일한 유형은 &lt;code&gt;&amp;amp;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;[Box&amp;lt;SomeTrait&amp;gt;]&lt;/code&gt; 과 같은 상자에 대한 참조 입니다. &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; 또는 &lt;code&gt;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; 와 같은 더 일반적인 유형 은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b80292943879aaefba4fcd89176f25fb4fe681b" translate="yes" xml:space="preserve">
          <source>The help text reveals that the return type needs a generic lifetime parameter on it because Rust can&amp;rsquo;t tell whether the reference being returned refers to &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;. Actually, we don&amp;rsquo;t know either, because the &lt;code&gt;if&lt;/code&gt; block in the body of this function returns a reference to &lt;code&gt;x&lt;/code&gt; and the &lt;code&gt;else&lt;/code&gt; block returns a reference to &lt;code&gt;y&lt;/code&gt;!</source>
          <target state="translated">러스트 텍스트는 리턴되는 참조가 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 를 참조하는지 여부를 알 수 없으므로 도움말 텍스트에 리턴 유형에 일반 수명 매개 변수가 필요하다는 내용이 표시 됩니다. 실제로이 함수의 본문에 있는 &lt;code&gt;if&lt;/code&gt; 블록은 &lt;code&gt;x&lt;/code&gt; 에 대한 참조를 반환 하고 &lt;code&gt;else&lt;/code&gt; 블록은 &lt;code&gt;y&lt;/code&gt; 에 대한 참조를 반환 하기 때문에 우리도 알 수 없습니다 !</target>
        </trans-unit>
        <trans-unit id="d58a9f4bf1938432cc316db1e69ad2bfca3de5d4" translate="yes" xml:space="preserve">
          <source>The highest valid code point a &lt;code&gt;char&lt;/code&gt; can have.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 가 가질 수있는 가장 유효한 코드 포인트 입니다.</target>
        </trans-unit>
        <trans-unit id="2c0d414ff9adc0b33c0f3d50d800e4ef1b9ec6d2" translate="yes" xml:space="preserve">
          <source>The hook is provided with a &lt;code&gt;Layout&lt;/code&gt; struct which contains information about the allocation that failed.</source>
          <target state="translated">후크 에는 실패한 할당에 대한 정보가 포함 된 &lt;code&gt;Layout&lt;/code&gt; 구조체 가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="c05a8db594383eaa649c0ea9f1230d31e2d9d207" translate="yes" xml:space="preserve">
          <source>The hook is provided with a &lt;code&gt;PanicInfo&lt;/code&gt; struct which contains information about the origin of the panic, including the payload passed to &lt;code&gt;panic!&lt;/code&gt; and the source code location from which the panic originated.</source>
          <target state="translated">후크 에는 패닉에 전달 된 페이로드를 포함하여 패닉의 출처에 대한 정보를 포함 하는 &lt;code&gt;PanicInfo&lt;/code&gt; 구조체 가 제공됩니다 &lt;code&gt;panic!&lt;/code&gt; 패닉이 발생한 소스 코드 위치.</target>
        </trans-unit>
        <trans-unit id="c5e73d7bf13606a783c42b98ca4eecc2c703d2de" translate="yes" xml:space="preserve">
          <source>The identifier is more than one character. &lt;code&gt;_&lt;/code&gt; alone is not an identifier.</source>
          <target state="translated">식별자가 둘 이상의 문자입니다. &lt;code&gt;_&lt;/code&gt; 만으로는 식별자가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="714243f838efe98c2e10bdbb7f1411daa3ecd7a0" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the constant used in the path. The type is the type that the definition has to implement.</source>
          <target state="translated">식별자는 경로에 사용 된 상수의 이름입니다. 유형은 정의가 구현해야하는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="3a2c9033b8c31ad61606f019cbc00c4420b891b9" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the declared type alias. The optional trait bounds must be fulfilled by the implementations of the type alias.</source>
          <target state="translated">식별자는 선언 된 타입 별칭의 이름입니다. 선택적 특성 한계는 유형 별명의 구현으로 충족되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1c83f053af5e622145b3145a7189cafa0c9167a0" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the function. The generics, parameter list, return type, and where clause of the associated function must be the same as the associated function declarations's.</source>
          <target state="translated">식별자는 함수의 이름입니다. 연관된 함수의 generics, 매개 변수 목록, 리턴 유형 및 where 절은 연관된 함수 선언과 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="c54b94a826db4a7c6ce8d411476041b69555f1aa" translate="yes" xml:space="preserve">
          <source>The identity function.</source>
          <target state="translated">정체성 기능.</target>
        </trans-unit>
        <trans-unit id="a0f93995f216b848984f480fd53d07ae2b2c30e6" translate="yes" xml:space="preserve">
          <source>The idiomatic way to write a &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; for its side effects is to use a &lt;code&gt;for&lt;/code&gt; loop instead:</source>
          <target state="translated">부작용에 대한 &lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 을 작성하는 관용적 방법 은 &lt;code&gt;for&lt;/code&gt; 루프를 대신 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="20b4ace5ebaf142e4e8addc0656248d8010dca32" translate="yes" xml:space="preserve">
          <source>The idiomatic way to write a &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; for its side effects is to use a &lt;code&gt;for&lt;/code&gt; loop or call the &lt;a href=&quot;trait.iterator#method.for_each&quot;&gt;&lt;code&gt;for_each&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">부작용에 대한 &lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 을 작성하는 관용적 인 방법 은 &lt;code&gt;for&lt;/code&gt; 루프 를 사용 하거나 &lt;a href=&quot;trait.iterator#method.for_each&quot;&gt; &lt;code&gt;for_each&lt;/code&gt; &lt;/a&gt; 메서드를 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1dc3122c538d92098d293869587f4b3a0100941a" translate="yes" xml:space="preserve">
          <source>The implementation ensures that the iterator will return exactly &lt;code&gt;len()&lt;/code&gt; more times a &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(T)&lt;/code&gt;&lt;/a&gt; value, before returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. This method has a default implementation, so you usually should not implement it directly. However, if you can provide a more efficient implementation, you can do so. See the &lt;a href=&quot;trait.exactsizeiterator&quot;&gt;trait-level&lt;/a&gt; docs for an example.</source>
          <target state="translated">구현은 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 반환하기 전에 반복기가 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(T)&lt;/code&gt; &lt;/a&gt; 값 보다 정확히 &lt;code&gt;len()&lt;/code&gt; 더 많이 반환하도록 합니다. 이 메서드에는 기본 구현이 있으므로 일반적으로 직접 구현하면 안됩니다. 그러나보다 효율적인 구현을 제공 할 수 있다면 그렇게 할 수 있습니다. 예를 보려면 &lt;a href=&quot;trait.exactsizeiterator&quot;&gt;특성 수준&lt;/a&gt; 문서를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="a17be86477c61cc7613b2ed105a5af337a27c206" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;Display&lt;/code&gt; uses &lt;code&gt;self.0&lt;/code&gt; to access the inner &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, because &lt;code&gt;Wrapper&lt;/code&gt; is a tuple struct and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; is the item at index 0 in the tuple. Then we can use the functionality of the &lt;code&gt;Display&lt;/code&gt; type on &lt;code&gt;Wrapper&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Wrapper&lt;/code&gt; 는 튜플 구조체이고 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 는 튜플의 인덱스 0에있는 항목 이므로 &lt;code&gt;Display&lt;/code&gt; 구현 은 &lt;code&gt;self.0&lt;/code&gt; 을 사용하여 내부 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 에 액세스합니다 . 그런 다음 &lt;code&gt;Wrapper&lt;/code&gt; 에서 &lt;code&gt;Display&lt;/code&gt; 유형 의 기능을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64d2ca9bc84ea7c438a453f8d81beffdb2cea48b" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;get&lt;/code&gt; relies in particular on identical implementations of &lt;code&gt;Hash&lt;/code&gt; by determining the key&amp;rsquo;s hash bucket by calling &lt;code&gt;Hash::hash&lt;/code&gt; on the &lt;code&gt;Q&lt;/code&gt; value even though it inserted the key based on the hash value calculated from the &lt;code&gt;K&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 의 구현은 &lt;code&gt;K&lt;/code&gt; 값 에서 계산 된 해시 값을 기반으로 키를 삽입 했더라도 &lt;code&gt;Q&lt;/code&gt; 값 에서 &lt;code&gt;Hash::hash&lt;/code&gt; 를 호출하여 키의 해시 버킷을 결정함으로써 동일한 &lt;code&gt;Hash&lt;/code&gt; 구현에 특히 의존 합니다.</target>
        </trans-unit>
        <trans-unit id="9ddcc339944cbb72b0b66f63ad73cbbefd5f13bf" translate="yes" xml:space="preserve">
          <source>The implementation of this function must make sure to release any resources that are associated with this instance of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; and associated task.</source>
          <target state="translated">이 기능을 구현하면이 &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; 인스턴스 및 관련 작업과 관련된 모든 리소스를 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b2b66f02783344ac4bc18a2fce3954484c2ba8e0" translate="yes" xml:space="preserve">
          <source>The implementation of this function must retain all resources that are required for this additional instance of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; and associated task. Calling &lt;code&gt;wake&lt;/code&gt; on the resulting &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; should result in a wakeup of the same task that would have been awoken by the original &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능의 구현은이 추가 &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; 인스턴스 및 관련 작업에 필요한 모든 리소스를 유지해야합니다 . 결과 &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;wake&lt;/code&gt; 를 호출 하면 원래 &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; 에서 깨어 났던 동일한 작업이 깨워집니다 .</target>
        </trans-unit>
        <trans-unit id="497d98f3948b6fc88a56b8970a7685389e682fb3" translate="yes" xml:space="preserve">
          <source>The implementation of waking a task on an executor.</source>
          <target state="translated">실행자에서 작업 깨우기 구현.</target>
        </trans-unit>
        <trans-unit id="d439e7f4f40d7bfe18d46ea25d8affbdc7117648" translate="yes" xml:space="preserve">
          <source>The implementation using the state pattern is easy to extend to add more functionality. To see the simplicity of maintaining code that uses the state pattern, try a few of these suggestions:</source>
          <target state="translated">상태 패턴을 사용한 구현은 더 많은 기능을 추가하기 위해 쉽게 확장 할 수 있습니다. 상태 패턴을 사용하는 코드를 유지 관리하는 단순성을 보려면 다음 제안 중 일부를 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="57e5372af92c8ddd71806b33dbda4afe86f48e3e" translate="yes" xml:space="preserve">
          <source>The implementing type within a &lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block, or the current type within a type definition.</source>
          <target state="translated">&lt;a href=&quot;keyword.trait&quot;&gt; &lt;code&gt;trait&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &lt;/a&gt; 블록 내의 구현 유형 또는 유형 정의 내의 현재 유형</target>
        </trans-unit>
        <trans-unit id="9972687dbff5abd8f4ecb962303ef66ce3678542" translate="yes" xml:space="preserve">
          <source>The index ranges returned by this trait are not required to exactly match those of the forward search in reverse.</source>
          <target state="translated">이 특성에 의해 반환되는 인덱스 범위는 정방향 검색의 인덱스 범위와 정확히 일치 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="fb8e7f22599fed31a57edfd5bc4f1d4fe1de7766" translate="yes" xml:space="preserve">
          <source>The indexed operand of an array indexing expression.</source>
          <target state="translated">배열 인덱싱 표현식의 인덱싱 된 피연산자입니다.</target>
        </trans-unit>
        <trans-unit id="8a276159145a3d291ba8902040d397309a6a3910" translate="yes" xml:space="preserve">
          <source>The inferred type asks the compiler to infer the type if possible based on the surrounding information available. It cannot be used in item signatures. It is often used in generic arguments:</source>
          <target state="translated">유추 된 유형은 사용 가능한 주변 정보를 기반으로 가능한 경우 유형을 유추하도록 컴파일러에 요청합니다. 항목 서명에는 사용할 수 없습니다. 일반적 인수에서 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1b63924c7210ee52ef50642e7b6012f573489c1d" translate="yes" xml:space="preserve">
          <source>The inherent methods of &lt;code&gt;Rc&lt;/code&gt; are all associated functions, which means that you have to call them as e.g., &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;value.get_mut()&lt;/code&gt;. This avoids conflicts with methods of the inner type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">의 고유 한 방법 &lt;code&gt;Rc&lt;/code&gt; 를이 당신이 예를 들어,로 전화해야 함을 의미 모든 관련 기능입니다 &lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt; &lt;/a&gt; 대신 &lt;code&gt;value.get_mut()&lt;/code&gt; . 이것은 내부 유형 &lt;code&gt;T&lt;/code&gt; 의 메소드와의 충돌을 피 합니다.</target>
        </trans-unit>
        <trans-unit id="cdd48be31dd031602338fabd7f9987080846befd" translate="yes" xml:space="preserve">
          <source>The inherent methods of &lt;code&gt;Rc&lt;/code&gt; are all associated functions, which means that you have to call them as e.g., &lt;a href=&quot;struct.rc#method.get_mut&quot;&gt;&lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;value.get_mut()&lt;/code&gt;. This avoids conflicts with methods of the inner type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9a135c5b11a6bdd25cebdf7bee36ffe6f4a888e" translate="yes" xml:space="preserve">
          <source>The initial value is the value the accumulator will have on the first call.</source>
          <target state="translated">초기 값은 누산기가 첫 번째 호출에서 갖는 값입니다.</target>
        </trans-unit>
        <trans-unit id="05cd051eb5f45770d700d15bc2c291712fe7349d" translate="yes" xml:space="preserve">
          <source>The initial value is the value the accumulator will have on the first call. If applying the closure succeeded against every element of the iterator, &lt;code&gt;try_fold()&lt;/code&gt; returns the final accumulator as success.</source>
          <target state="translated">초기 값은 누산기가 첫 번째 호출에서 갖는 값입니다. 반복자의 모든 요소에 대해 클로저를 적용하면 &lt;code&gt;try_fold()&lt;/code&gt; 는 최종 누산기를 성공으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3215ce085488e89e5b23ed55a5028caf27292850" translate="yes" xml:space="preserve">
          <source>The initializer expression.</source>
          <target state="translated">이니셜 라이저 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="005959a16886789f6cb716c2b5dc5bbb0daa12f9" translate="yes" xml:space="preserve">
          <source>The initializer of</source>
          <target state="translated">이니셜 라이저</target>
        </trans-unit>
        <trans-unit id="37009e2d28047124f91d44e005708dbff225d4db" translate="yes" xml:space="preserve">
          <source>The initializer of a &lt;a href=&quot;statements#let-statements&quot;&gt;let statement&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;statements#let-statements&quot;&gt;let 문의&lt;/a&gt; 초기화 프로그램입니다 .</target>
        </trans-unit>
        <trans-unit id="b9db1fa1a8ca22dc3f22f48be8f2cc5fef02b51c" translate="yes" xml:space="preserve">
          <source>The input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the token stream of the item that has the &lt;code&gt;derive&lt;/code&gt; attribute on it. The output &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; must be a set of items that are then appended to the &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;expressions/block-expr&quot;&gt;block&lt;/a&gt; that the item from the input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">입력 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;derive&lt;/code&gt; 속성 이있는 항목의 토큰 스트림입니다 . 출력 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;items/modules&quot;&gt;모듈에&lt;/a&gt; 추가 되거나 입력 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 의 항목이있는 것을 &lt;a href=&quot;expressions/block-expr&quot;&gt;차단&lt;/a&gt; 하는 일련의 항목이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3584f2f431d39b47066e06bb0ba2d085c77c3d1e" translate="yes" xml:space="preserve">
          <source>The input iterator &lt;code&gt;replace_with&lt;/code&gt; is only consumed when the &lt;code&gt;Splice&lt;/code&gt; value is dropped.</source>
          <target state="translated">입력 반복자 &lt;code&gt;replace_with&lt;/code&gt; 는 &lt;code&gt;Splice&lt;/code&gt; 값이 삭제 된 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5b45dbdf7cc3adb9c8ff29ad732df76183eebf5c" translate="yes" xml:space="preserve">
          <source>The installation of Rust also includes a copy of the documentation locally, so you can read it offline. Run &lt;code&gt;rustup doc&lt;/code&gt; to open the local documentation in your browser.</source>
          <target state="translated">Rust 설치에는 로컬 문서 사본도 포함되어 있으므로 오프라인에서 읽을 수 있습니다. &lt;code&gt;rustup doc&lt;/code&gt; 를 실행 하여 브라우저에서 로컬 문서를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="c198c64d60547785c3da652e9852896f77fa00d7" translate="yes" xml:space="preserve">
          <source>The installation script automatically adds Rust to your system PATH after your next login. If you want to start using Rust right away instead of restarting your terminal, run the following command in your shell to add Rust to your system PATH manually:</source>
          <target state="translated">설치 스크립트는 다음 로그인 후 시스템 경로에 Rust를 자동으로 추가합니다. 터미널을 다시 시작하지 않고 Rust를 즉시 사용하려면 쉘에서 다음 명령을 실행하여 Rust를 시스템 PATH에 수동으로 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a382c15195dddde8bba4823548e75c4adc802c3c" translate="yes" xml:space="preserve">
          <source>The installer also includes a copy of the documentation locally, so you can read it offline. Run &lt;code&gt;rustup doc&lt;/code&gt; to open the local documentation in your browser.</source>
          <target state="translated">설치 프로그램에는 로컬로 설명서 사본이 포함되어 있으므로 오프라인에서 읽을 수 있습니다. &lt;code&gt;rustup doc&lt;/code&gt; 을 실행 하여 브라우저에서 로컬 문서를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="eb4481a6d93414e0e2ed7586ff1e0910b51585be" translate="yes" xml:space="preserve">
          <source>The integral types provide inherent methods to allow programmers explicitly to perform wrapping arithmetic. For example, &lt;code&gt;i32::wrapping_add&lt;/code&gt; provides two's complement, wrapping addition.</source>
          <target state="translated">정수 유형은 프로그래머가 래핑 산술을 명시 적으로 수행 할 수있는 고유 한 방법을 제공합니다. 예를 들어, &lt;code&gt;i32::wrapping_add&lt;/code&gt; 는 래핑 추가라는 2의 보수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a2f153ef163d784268a26bcb041875def3bd700b" translate="yes" xml:space="preserve">
          <source>The integration tests section starts with the line &lt;code&gt;Running target/debug/deps/integration_test-ce99bcc2479f4607&lt;/code&gt; (the hash at the end of your output will be different). Next, there is a line for each test function in that integration test and a summary line for the results of the integration test just before the &lt;code&gt;Doc-tests adder&lt;/code&gt; section starts.</source>
          <target state="translated">통합 테스트 섹션은 &lt;code&gt;Running target/debug/deps/integration_test-ce99bcc2479f4607&lt;/code&gt; 라인으로 시작 합니다 (출력 끝의 해시는 다름). 다음으로 해당 통합 테스트의 각 테스트 기능에 대한 행과 &lt;code&gt;Doc-tests adder&lt;/code&gt; 섹션이 시작 하기 직전에 통합 테스트 결과에 대한 요약 라인 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c8b39dac0f0603ab0205cf2bfd1df712c7506c4" translate="yes" xml:space="preserve">
          <source>The intention is that the underlying data is only valid for the lifetime &lt;code&gt;'a&lt;/code&gt;, so &lt;code&gt;Slice&lt;/code&gt; should not outlive &lt;code&gt;'a&lt;/code&gt;. However, this intent is not expressed in the code, since there are no uses of the lifetime &lt;code&gt;'a&lt;/code&gt; and hence it is not clear what data it applies to. We can correct this by telling the compiler to act &lt;em&gt;as if&lt;/em&gt; the &lt;code&gt;Slice&lt;/code&gt; struct contained a reference &lt;code&gt;&amp;amp;'a T&lt;/code&gt;:</source>
          <target state="translated">의도는 기본 데이터가 수명에 대해서만 유효하다는 것이다 &lt;code&gt;'a&lt;/code&gt; 그래서, &lt;code&gt;Slice&lt;/code&gt; 해야보다 오래되지 &lt;code&gt;'a&lt;/code&gt; . 그러나이 의도는 코드에서 표현되지 않습니다. 왜냐하면 수명 &lt;code&gt;'a&lt;/code&gt; 를 사용 하지 않으므로 어떤 데이터가 적용되는지 명확하지 않습니다. 우리는 행동하는 컴파일러를 말함으로써이 문제를 해결할 수있는 &lt;em&gt;것처럼 &lt;/em&gt; &lt;code&gt;Slice&lt;/code&gt; 구조체에 대한 참조 포함 &lt;code&gt;&amp;amp;'a T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c6ec3ee71b429b0c861d2949630c53c1d4103ef2" translate="yes" xml:space="preserve">
          <source>The internal algorithm is not specified, and so it and its hashes should not be relied upon over releases.</source>
          <target state="translated">내부 알고리즘은 지정되어 있지 않으므로, 릴리스와 그 해시가 초과 릴리스에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="c411eb080c209397146b14ba5a4bb34e75cec138" translate="yes" xml:space="preserve">
          <source>The internal buffer is written out before returning the writer.</source>
          <target state="translated">기록기를 반환하기 전에 내부 버퍼가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="06716cd4a735b362271ebfeb2853eaa89b39ee1b" translate="yes" xml:space="preserve">
          <source>The internal iterator over the argument has not been advanced by the time the first &lt;code&gt;{}&lt;/code&gt; is seen, so it prints the first argument. Then upon reaching the second &lt;code&gt;{}&lt;/code&gt;, the iterator has advanced forward to the second argument. Essentially, parameters that explicitly name their argument do not affect parameters that do not name an argument in terms of positional specifiers.</source>
          <target state="translated">인수에 대한 내부 반복기는 첫 번째 &lt;code&gt;{}&lt;/code&gt; 가 표시 될 때까지 진행되지 않았 으므로 첫 번째 인수를 인쇄합니다. 그런 다음 두 번째 &lt;code&gt;{}&lt;/code&gt; 에 도달하면 반복기가 두 번째 인수로 진행됩니다. 기본적으로 인수 이름을 명시 적으로 지정하는 매개 변수는 위치 지정자 측면에서 인수 이름을 지정하지 않는 매개 변수에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce78ff22afeda7a6f00a6ca8444175752d52c4ff" translate="yes" xml:space="preserve">
          <source>The internal iterator over the argument has not been advanced by the time the first &lt;code&gt;{}&lt;/code&gt; is seen, so it prints the first argument. Then upon reaching the second &lt;code&gt;{}&lt;/code&gt;, the iterator has advanced forward to the second argument. Essentially, parameters which explicitly name their argument do not affect parameters which do not name an argument in terms of positional specifiers.</source>
          <target state="translated">첫 번째 &lt;code&gt;{}&lt;/code&gt; 를 볼 때까지 인수에 대한 내부 반복자가 진행되지 않았 으므로 첫 번째 인수를 인쇄합니다. 그런 다음 두 번째 &lt;code&gt;{}&lt;/code&gt; 에 도달하면 반복자는 두 번째 인수로 진행합니다. 기본적으로 인수의 이름을 명시 적으로 지정하는 매개 변수는 위치 지정자 측면에서 인수의 이름을 지정하지 않는 매개 변수에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c46dda1624f616f75baf2894d6d6e54ab12f317" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법의 반대는 &lt;a href=&quot;#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dbc762f2fb2ae9279c20887c42fbcb66ef8ed68d" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.as_bytes&quot;&gt;&lt;code&gt;as_bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법의 역은 &lt;a href=&quot;struct.string#method.as_bytes&quot;&gt; &lt;code&gt;as_bytes&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2ef5a2c8bf418a538796f28bdc7b3ed8b4214bec" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드의 반대는 &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="00033d91f205bb0450cf7878d82bad2da288007b" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.into_bytes&quot;&gt;&lt;code&gt;into_bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드의 반대는 &lt;a href=&quot;struct.string#method.into_bytes&quot;&gt; &lt;code&gt;into_bytes&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0d5754a49ec3bccb9874e0108120d01b2fee9ec9" translate="yes" xml:space="preserve">
          <source>The issue can be resolved by changing the associated type:</source>
          <target state="translated">관련 유형을 변경하여 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2057c4ad17ebd71c1902c8394bd83a7474bbd6d5" translate="yes" xml:space="preserve">
          <source>The issue in this case is that &lt;code&gt;foo&lt;/code&gt; is defined as accepting a &lt;code&gt;Fn&lt;/code&gt; with one argument of type &lt;code&gt;String&lt;/code&gt;, but the closure we attempted to pass to it requires one arguments of type &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">이 경우의 문제는 &lt;code&gt;foo&lt;/code&gt; 가 &lt;code&gt;String&lt;/code&gt; 유형의 하나의 인수로 &lt;code&gt;Fn&lt;/code&gt; 을 허용하는 것으로 정의 되지만 전달하려는 클로저에는 &lt;code&gt;usize&lt;/code&gt; 유형의 인수가 하나 필요 하다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c02789dc84a563007f1b001c6388d43c1756fd64" translate="yes" xml:space="preserve">
          <source>The issue with the tuple code in Listing 4-5 is that we have to return the &lt;code&gt;String&lt;/code&gt; to the calling function so we can still use the &lt;code&gt;String&lt;/code&gt; after the call to &lt;code&gt;calculate_length&lt;/code&gt;, because the &lt;code&gt;String&lt;/code&gt; was moved into &lt;code&gt;calculate_length&lt;/code&gt;.</source>
          <target state="translated">Listing 4-5의 튜플 코드의 문제점은 &lt;code&gt;String&lt;/code&gt; 을 호출 함수 로 반환해야하기 때문에 &lt;code&gt;String&lt;/code&gt; 이 &lt;code&gt;calculate_length&lt;/code&gt; 로 이동 했기 때문에 &lt;code&gt;calculate_length&lt;/code&gt; 를 호출 한 후에도 여전히 &lt;code&gt;String&lt;/code&gt; 을 사용할 수 있다는 것이다 .</target>
        </trans-unit>
        <trans-unit id="1013a496d8eb9ca295e23a82f7ffaec17e1ba13a" translate="yes" xml:space="preserve">
          <source>The issue with this code is evident in the signature of &lt;code&gt;area&lt;/code&gt;:</source>
          <target state="translated">이 코드의 문제는 &lt;code&gt;area&lt;/code&gt; 의 서명에서 분명 합니다 .</target>
        </trans-unit>
        <trans-unit id="e382444929f7f8a00ff868439efd08f11891e2df" translate="yes" xml:space="preserve">
          <source>The items of marker traits cannot be overridden, so there's no need to have them when they cannot be changed per-type anyway. If you wanted them for ergonomic reasons, consider making an extension trait instead.</source>
          <target state="translated">마커 특성의 항목은 재정의 될 수 없으므로 어쨌든 유형별로 변경할 수없는 경우이를 가질 필요가 없습니다. 인체 공학적 이유로 원한다면 확장 특성을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="5e506ce8ee681f90bb70782d8bb4d2dad5bd0685" translate="yes" xml:space="preserve">
          <source>The iterator element type is &lt;a href=&quot;../path/struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반복자 요소 유형은 &lt;a href=&quot;../path/struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6824e2e2ab7393d35f45cbd58638289d41c35be1" translate="yes" xml:space="preserve">
          <source>The iterator must produce exactly the number of elements it reported or diverge before reaching the end.</source>
          <target state="translated">반복자는 마지막에 도달하기 전에보고하거나 발산 한 요소 수를 정확하게 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="857086b346b7dd5e8adf55ad86cbe1dbbf8cbe54" translate="yes" xml:space="preserve">
          <source>The iterator pattern allows you to perform some task on a sequence of items in turn. An iterator is responsible for the logic of iterating over each item and determining when the sequence has finished. When you use iterators, you don&amp;rsquo;t have to reimplement that logic yourself.</source>
          <target state="translated">반복자 패턴을 사용하면 일련의 항목에 대한 작업을 차례로 수행 할 수 있습니다. 반복자는 각 항목을 반복하고 시퀀스가 ​​완료된 시점을 결정하는 논리를 담당합니다. 반복자를 사용할 때는 해당 논리를 직접 구현할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6db07328b493618fb3fe592624d4f327dc32ce7b" translate="yes" xml:space="preserve">
          <source>The iterator reports a size hint where it is either exact (lower bound is equal to upper bound), or the upper bound is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. The upper bound must only be &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the actual iterator length is larger than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;. In that case, the lower bound must be &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;, resulting in a &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;.size_hint&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;(usize::MAX, None)&lt;/code&gt;.</source>
          <target state="translated">반복자는 크기 힌트가 정확하거나 (하한이 상한과 같거나) 상한이 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 경우 크기 힌트를보고합니다 . 실제 반복자 길이가 &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; 보다 큰 경우 상한 은 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이어야합니다 . 이 경우 하한은 &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; 이어야하며 결과적으로 &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;.size_hint&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;(usize::MAX, None)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="761f99bb11c75b1d69af8441ba4ad3812f9ffc53" translate="yes" xml:space="preserve">
          <source>The iterator reports a size hint where it is either exact (lower bound is equal to upper bound), or the upper bound is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. The upper bound must only be &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the actual iterator length is larger than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;. In that case, the lower bound must be &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;, resulting in a &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint()&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;(usize::MAX, None)&lt;/code&gt;.</source>
          <target state="translated">이터레이터는 정확하거나 (하한이 상한과 같음) 상한이 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 인&lt;/a&gt; 크기 힌트를보고합니다 . 실제 반복기 길이가 &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; 보다 큰 경우 상한값 은 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이어야합니다 . 이 경우 하한은 &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; 여야하며 결과적 으로 &lt;code&gt;(usize::MAX, None)&lt;/code&gt; 의 &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;Iterator::size_hint()&lt;/code&gt; &lt;/a&gt; 가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="f5b68d7a8101dc216e0d59f65c1ebaa471e720b2" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will return instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each vector returned will &lt;em&gt;not&lt;/em&gt; have the delimiter byte at the end.</source>
          <target state="translated">이 함수에서 반환 된 반복자는 인스턴스를 돌려줍니다 &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . 반환 된 각 벡터 에는 끝에 구분 기호 바이트 가 &lt;em&gt;없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="43d518530c9a6385f97f5ea0cf3b95e6447ddfae" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will yield instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each string returned will &lt;em&gt;not&lt;/em&gt; have a newline byte (the 0xA byte) or CRLF (0xD, 0xA bytes) at the end.</source>
          <target state="translated">이 함수에서 반환 된 반복자는 &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 의 인스턴스를 생성합니다 . 것입니다 반환 각 문자열 &lt;em&gt;하지&lt;/em&gt; 개행 바이트합니다 (0xa는 바이트) 또는 CRLF가 마지막에 (0xD는 0xa는 바이트).</target>
        </trans-unit>
        <trans-unit id="11be39dc954e81f8e71f68fa0b756ad22ee17df7" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will yield instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each string returned will &lt;em&gt;not&lt;/em&gt; have a newline byte (the &lt;code&gt;0xA&lt;/code&gt; byte) or &lt;code&gt;CRLF&lt;/code&gt; (&lt;code&gt;0xD&lt;/code&gt;, &lt;code&gt;0xA&lt;/code&gt; bytes) at the end.</source>
          <target state="translated">이 함수에서 반환 된 반복기는 &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 의 인스턴스를 생성합니다 . 것입니다 반환 각 문자열 &lt;em&gt;하지&lt;/em&gt; 개행 바이트합니다 (이 &lt;code&gt;0xA&lt;/code&gt; 바이트) 또는 &lt;code&gt;CRLF&lt;/code&gt; ( &lt;code&gt;0xD&lt;/code&gt; 는 , &lt;code&gt;0xA&lt;/code&gt; 말에 바이트).</target>
        </trans-unit>
        <trans-unit id="d98222c90db1c99a084846a0ad925665e5230738" translate="yes" xml:space="preserve">
          <source>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of ASCII whitespace.</source>
          <target state="translated">반환 된 반복기는 임의의 ASCII 공백으로 구분 된 원래 문자열 슬라이스의 하위 슬라이스 인 문자열 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="406100c150ec04008e29a14c30e99aed0f63af21" translate="yes" xml:space="preserve">
          <source>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of whitespace.</source>
          <target state="translated">반환 된 반복자는 공백으로 분리 된 원래 문자열 슬라이스의 하위 슬라이스 인 문자열 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4221546e7793ded4aa41dc1718c0ee56c99339b5" translate="yes" xml:space="preserve">
          <source>The iterator returned yields pairs &lt;code&gt;(i, val)&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the current index of iteration and &lt;code&gt;val&lt;/code&gt; is the value returned by the iterator.</source>
          <target state="translated">반환 된 반복자는 쌍 &lt;code&gt;(i, val)&lt;/code&gt; 산출합니다 . 여기서 &lt;code&gt;i&lt;/code&gt; 는 현재 반복 색인이고 &lt;code&gt;val&lt;/code&gt; 은 반복자가 반환 한 값입니다.</target>
        </trans-unit>
        <trans-unit id="0d65a2fef7d4c6664fcfb9659495ac349d06a758" translate="yes" xml:space="preserve">
          <source>The iterator starts with the given first item (if any) and calls the given &lt;code&gt;FnMut(&amp;amp;T) -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt; closure to compute each item&amp;rsquo;s successor.</source>
          <target state="translated">반복자는 주어진 첫 번째 항목 (있는 경우)으로 시작하고 주어진 &lt;code&gt;FnMut(&amp;amp;T) -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt; 클로저를 호출하여 각 항목의 후속 항목을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="fe7ef8d083d96a8372351bad5e0da1e04819839b" translate="yes" xml:space="preserve">
          <source>The iterator version was slightly faster! We won&amp;rsquo;t explain the benchmark code here, because the point is not to prove that the two versions are equivalent but to get a general sense of how these two implementations compare performance-wise.</source>
          <target state="translated">반복자 버전이 약간 빨랐습니다! 여기서는 벤치 마크 코드를 설명하지 않을 것입니다. 요점은 두 버전이 동일하다는 것을 증명하는 것이 아니라이 두 구현이 성능 측면에서 어떻게 비교되는지에 대한 일반적인 의미를 갖기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="40a9eac2c27490989d9bce69b525d51e8393ef6d" translate="yes" xml:space="preserve">
          <source>The iterator will never return &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;struct.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="translated">반복자는 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환 하지 않으며 피어의 &lt;a href=&quot;struct.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; 구조 도 생성하지 않습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
