<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="2ec6cd19695748bdc3218a5649d6ac291b66845a" translate="yes" xml:space="preserve">
          <source>BTreeSet::intersection</source>
          <target state="translated">BTreeSet::intersection</target>
        </trans-unit>
        <trans-unit id="d885d81e267a989f9b6f96d27d81a920eec34664" translate="yes" xml:space="preserve">
          <source>BTreeSet::into</source>
          <target state="translated">BTreeSet::into</target>
        </trans-unit>
        <trans-unit id="f09a0e4a6b10a390e2f04fd66332a740593fc953" translate="yes" xml:space="preserve">
          <source>BTreeSet::into_iter</source>
          <target state="translated">BTreeSet::into_iter</target>
        </trans-unit>
        <trans-unit id="a2120b284c22116b26329e55b63c0619a0f8641f" translate="yes" xml:space="preserve">
          <source>BTreeSet::is_disjoint</source>
          <target state="translated">BTreeSet::is_disjoint</target>
        </trans-unit>
        <trans-unit id="fa3982b7c70f77cdc4a183838b7ec4738fe0c535" translate="yes" xml:space="preserve">
          <source>BTreeSet::is_empty</source>
          <target state="translated">BTreeSet::is_empty</target>
        </trans-unit>
        <trans-unit id="f1e3ee85ccb9602474d41d5d154e3e8901defc32" translate="yes" xml:space="preserve">
          <source>BTreeSet::is_subset</source>
          <target state="translated">BTreeSet::is_subset</target>
        </trans-unit>
        <trans-unit id="56a933bbd8f86feb814db247df53b23e17a9695d" translate="yes" xml:space="preserve">
          <source>BTreeSet::is_superset</source>
          <target state="translated">BTreeSet::is_superset</target>
        </trans-unit>
        <trans-unit id="b5818b3b23dd28b80dc81cc819a86f1ec187aacf" translate="yes" xml:space="preserve">
          <source>BTreeSet::iter</source>
          <target state="translated">BTreeSet::iter</target>
        </trans-unit>
        <trans-unit id="de70e88d73a501b174fd29598eceebcee11a3887" translate="yes" xml:space="preserve">
          <source>BTreeSet::le</source>
          <target state="translated">BTreeSet::le</target>
        </trans-unit>
        <trans-unit id="d6f9cf6208fd574420dfb2b2c0da01ae4ce09d55" translate="yes" xml:space="preserve">
          <source>BTreeSet::len</source>
          <target state="translated">BTreeSet::len</target>
        </trans-unit>
        <trans-unit id="b1797fe67e7fb20ec6e3d268d0239e6f0a7e8a35" translate="yes" xml:space="preserve">
          <source>BTreeSet::lt</source>
          <target state="translated">BTreeSet::lt</target>
        </trans-unit>
        <trans-unit id="a9e0d4eb0cfb5c71cb33c6469839efbbe2cc32b4" translate="yes" xml:space="preserve">
          <source>BTreeSet::max</source>
          <target state="translated">BTreeSet::max</target>
        </trans-unit>
        <trans-unit id="05e2ada4eca69c113c843b5a4bf4e82b6cbab803" translate="yes" xml:space="preserve">
          <source>BTreeSet::min</source>
          <target state="translated">BTreeSet::min</target>
        </trans-unit>
        <trans-unit id="1bf7816f409ee91ea7b933df2aa5aafb248eb221" translate="yes" xml:space="preserve">
          <source>BTreeSet::ne</source>
          <target state="translated">BTreeSet::ne</target>
        </trans-unit>
        <trans-unit id="eaf3ecdf9b29068bb6526653c7887b6ce53f95db" translate="yes" xml:space="preserve">
          <source>BTreeSet::new</source>
          <target state="translated">BTreeSet::new</target>
        </trans-unit>
        <trans-unit id="df8c5a54c5b8f9c4c785c5ef82c145a8f51964cb" translate="yes" xml:space="preserve">
          <source>BTreeSet::partial_cmp</source>
          <target state="translated">BTreeSet::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d87bbd755881f1e9919b94d6de0e6bf8ffad49ba" translate="yes" xml:space="preserve">
          <source>BTreeSet::range</source>
          <target state="translated">BTreeSet::range</target>
        </trans-unit>
        <trans-unit id="ef12ebd2434d1cb833ec3822d788df805d7d9bd6" translate="yes" xml:space="preserve">
          <source>BTreeSet::remove</source>
          <target state="translated">BTreeSet::remove</target>
        </trans-unit>
        <trans-unit id="9478913c250333ed4078096ba5b68c78bc2a2420" translate="yes" xml:space="preserve">
          <source>BTreeSet::replace</source>
          <target state="translated">BTreeSet::replace</target>
        </trans-unit>
        <trans-unit id="3c5930911fa948ea3f0f63bb1262c5e03b59d4c8" translate="yes" xml:space="preserve">
          <source>BTreeSet::split_off</source>
          <target state="translated">BTreeSet::split_off</target>
        </trans-unit>
        <trans-unit id="c4362726060659abf8310f7f4e795bc37b50e1bc" translate="yes" xml:space="preserve">
          <source>BTreeSet::sub</source>
          <target state="translated">BTreeSet::sub</target>
        </trans-unit>
        <trans-unit id="1dc28627821fcb677e88cc0779199b1f7545d0d5" translate="yes" xml:space="preserve">
          <source>BTreeSet::symmetric_difference</source>
          <target state="translated">BTreeSet::symmetric_difference</target>
        </trans-unit>
        <trans-unit id="2164e4022af6db54cb98c455e4d65521424dc945" translate="yes" xml:space="preserve">
          <source>BTreeSet::take</source>
          <target state="translated">BTreeSet::take</target>
        </trans-unit>
        <trans-unit id="976d0d251360ff452f9cb215b1b7bd9b85411230" translate="yes" xml:space="preserve">
          <source>BTreeSet::to_owned</source>
          <target state="translated">BTreeSet::to_owned</target>
        </trans-unit>
        <trans-unit id="0992e1b4495c890673b5468165634f32bea3f77d" translate="yes" xml:space="preserve">
          <source>BTreeSet::try_from</source>
          <target state="translated">BTreeSet::try_from</target>
        </trans-unit>
        <trans-unit id="00828429015178852a18ee4ff94e0453f5ca2ad3" translate="yes" xml:space="preserve">
          <source>BTreeSet::try_into</source>
          <target state="translated">BTreeSet::try_into</target>
        </trans-unit>
        <trans-unit id="6292b066b8d0a77ef6636bc177c940749dde0313" translate="yes" xml:space="preserve">
          <source>BTreeSet::type_id</source>
          <target state="translated">BTreeSet::type_id</target>
        </trans-unit>
        <trans-unit id="a20d276d5c8ff0b1126047f789b8548caf5f132d" translate="yes" xml:space="preserve">
          <source>BTreeSet::union</source>
          <target state="translated">BTreeSet::union</target>
        </trans-unit>
        <trans-unit id="a211a3e292d0c406efdf997cbec3abf1f2bc9197" translate="yes" xml:space="preserve">
          <source>BYTE_ESCAPE :</source>
          <target state="translated">BYTE_ESCAPE :</target>
        </trans-unit>
        <trans-unit id="e985813955ef288c8ead5994a2092542fb8c5bfb" translate="yes" xml:space="preserve">
          <source>BYTE_LITERAL :</source>
          <target state="translated">BYTE_LITERAL :</target>
        </trans-unit>
        <trans-unit id="e07c048067fa9215a18b4b2891f03e3f5148f8fe" translate="yes" xml:space="preserve">
          <source>BYTE_STRING_LITERAL :</source>
          <target state="translated">BYTE_STRING_LITERAL :</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="0ad42765ddcf1bcbae887f2d660cffdf1e817617" translate="yes" xml:space="preserve">
          <source>Background:</source>
          <target state="translated">Background:</target>
        </trans-unit>
        <trans-unit id="a826c283ce6a52f2d32eb19de6510cb9098ad99b" translate="yes" xml:space="preserve">
          <source>Backslash</source>
          <target state="translated">Backslash</target>
        </trans-unit>
        <trans-unit id="2df2f36ad1b16c1667285665d27221aa512fe540" translate="yes" xml:space="preserve">
          <source>Backslash is escaped as &lt;code&gt;\&lt;/code&gt;.</source>
          <target state="translated">백 슬래시는 &lt;code&gt;\&lt;/code&gt; 로 이스케이프됩니다 .</target>
        </trans-unit>
        <trans-unit id="a92ed9890561e42d2d0eb715d201f51180f68785" translate="yes" xml:space="preserve">
          <source>Backslash is escaped as &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="translated">백 슬래시는 &lt;code&gt;\\&lt;/code&gt; 로 이스케이프됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb6f955aacbe511f0166d8a199d4db6ed90499a5" translate="yes" xml:space="preserve">
          <source>Backtrace</source>
          <target state="translated">Backtrace</target>
        </trans-unit>
        <trans-unit id="b85c431b74d8d9af7df1e8cd976473ac0177f68e" translate="yes" xml:space="preserve">
          <source>BacktraceStatus</source>
          <target state="translated">BacktraceStatus</target>
        </trans-unit>
        <trans-unit id="6eb0761000f5c4f5765ae1bd324bf97fbcf48d1d" translate="yes" xml:space="preserve">
          <source>Backtraces are attempted to be as accurate as possible, but no guarantees are provided about the exact accuracy of a backtrace. Instruction pointers, symbol names, filenames, line numbers, etc, may all be incorrect when reported. Accuracy is attempted on a best-effort basis, however, and bugs are always welcome to indicate areas of improvement!</source>
          <target state="translated">역 추적은 가능한 한 정확하도록 시도되지만 역 추적의 정확한 정확성에 대한 보장은 제공되지 않습니다. 보고 할 때 명령 포인터, 기호 이름, 파일 이름, 줄 번호 등이 모두 올바르지 않을 수 있습니다. 정확성은 최선의 노력으로 시도되지만 버그는 항상 개선 영역을 나타내는 환영합니다!</target>
        </trans-unit>
        <trans-unit id="10c02649e226d430bd75a5b6315a41c0db9992a2" translate="yes" xml:space="preserve">
          <source>Barrier</source>
          <target state="translated">Barrier</target>
        </trans-unit>
        <trans-unit id="05bc93718262068d5416ebba28511ebef76c4e14" translate="yes" xml:space="preserve">
          <source>Barrier::borrow</source>
          <target state="translated">Barrier::borrow</target>
        </trans-unit>
        <trans-unit id="48d8a6ca5d7ebcc052fa58321357d3bc36aa03a7" translate="yes" xml:space="preserve">
          <source>Barrier::borrow_mut</source>
          <target state="translated">Barrier::borrow_mut</target>
        </trans-unit>
        <trans-unit id="248c7b32ba40054cd50084ccaaff12b9c63d122a" translate="yes" xml:space="preserve">
          <source>Barrier::fmt</source>
          <target state="translated">Barrier::fmt</target>
        </trans-unit>
        <trans-unit id="d7dd85fbb601276305eb0ee52f6cb5d377f1fcc6" translate="yes" xml:space="preserve">
          <source>Barrier::from</source>
          <target state="translated">Barrier::from</target>
        </trans-unit>
        <trans-unit id="b342290a92d4444218a0ad57c6d277b796cd87a3" translate="yes" xml:space="preserve">
          <source>Barrier::into</source>
          <target state="translated">Barrier::into</target>
        </trans-unit>
        <trans-unit id="7468c224f8c905662e2e9c948739eef5bda7db0f" translate="yes" xml:space="preserve">
          <source>Barrier::new</source>
          <target state="translated">Barrier::new</target>
        </trans-unit>
        <trans-unit id="e30be523849f626aaa57ff5ee4069d25af8b70d1" translate="yes" xml:space="preserve">
          <source>Barrier::try_from</source>
          <target state="translated">Barrier::try_from</target>
        </trans-unit>
        <trans-unit id="e446147c6eb4453799cb6b4e470660354d138fed" translate="yes" xml:space="preserve">
          <source>Barrier::try_into</source>
          <target state="translated">Barrier::try_into</target>
        </trans-unit>
        <trans-unit id="97c7cb229080f5ec6d48954bf4e25fbf0b1b07ce" translate="yes" xml:space="preserve">
          <source>Barrier::type_id</source>
          <target state="translated">Barrier::type_id</target>
        </trans-unit>
        <trans-unit id="89f8492b0a8df428938e6f6ec1470925533e2645" translate="yes" xml:space="preserve">
          <source>Barrier::wait</source>
          <target state="translated">Barrier::wait</target>
        </trans-unit>
        <trans-unit id="1fdffd384d740408663001485f7d1d001cd2a0cd" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult</source>
          <target state="translated">BarrierWaitResult</target>
        </trans-unit>
        <trans-unit id="e4a4959fb6b835a4c39d1adf5dc13e01c6574236" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::borrow</source>
          <target state="translated">BarrierWaitResult::borrow</target>
        </trans-unit>
        <trans-unit id="df6d4d2a45b72573796ce25c163ceca562fea277" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::borrow_mut</source>
          <target state="translated">BarrierWaitResult::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ab607187cf3b656038040cc905673df49597a85b" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::fmt</source>
          <target state="translated">BarrierWaitResult::fmt</target>
        </trans-unit>
        <trans-unit id="40c08de59f1f4830ac002ad44e2d3553862e48a4" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::from</source>
          <target state="translated">BarrierWaitResult::from</target>
        </trans-unit>
        <trans-unit id="0ad014a8be36da91076930d7e3b4ff7218ef30aa" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::into</source>
          <target state="translated">BarrierWaitResult::into</target>
        </trans-unit>
        <trans-unit id="24471f5273b1cd68c1f7b8b58afe489ead7b1e9c" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::is_leader</source>
          <target state="translated">BarrierWaitResult::is_leader</target>
        </trans-unit>
        <trans-unit id="30b419cdf31db8213f868433400e90eb5bd6bd09" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::try_from</source>
          <target state="translated">BarrierWaitResult::try_from</target>
        </trans-unit>
        <trans-unit id="917cd48270dee8a42dabe702984f20fa69cc47a8" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::try_into</source>
          <target state="translated">BarrierWaitResult::try_into</target>
        </trans-unit>
        <trans-unit id="29252f73362aacd393a5eec57cfc8edfc91915f8" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::type_id</source>
          <target state="translated">BarrierWaitResult::type_id</target>
        </trans-unit>
        <trans-unit id="0798504393a70fe84f8d6d8445159e80798bd3ac" translate="yes" xml:space="preserve">
          <source>Barriers are re-usable after all threads have rendezvoused once, and can be used continuously.</source>
          <target state="translated">배리어는 모든 스레드가 한 번 랑데부 한 후에 재사용 할 수 있으며 지속적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes" xml:space="preserve">
          <source>Basic Usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="e688514e6e0a6b01ae26314b3eb88e5e53881bcb" translate="yes" xml:space="preserve">
          <source>Basic behavior:</source>
          <target state="translated">기본 행동 :</target>
        </trans-unit>
        <trans-unit id="11bf4d2856fba52165f40435250d1ec2e6c3316a" translate="yes" xml:space="preserve">
          <source>Basic functions for dealing with memory.</source>
          <target state="translated">메모리를 다루기위한 기본 기능.</target>
        </trans-unit>
        <trans-unit id="ec83756dfd527ebf8f2a042db474987a95d353c4" translate="yes" xml:space="preserve">
          <source>Basic implementation of &lt;code&gt;FromStr&lt;/code&gt; on an example &lt;code&gt;Point&lt;/code&gt; type:</source>
          <target state="translated">예제 &lt;code&gt;Point&lt;/code&gt; 유형 에서 &lt;code&gt;FromStr&lt;/code&gt; 의 기본 구현 :</target>
        </trans-unit>
        <trans-unit id="c3d9f55cf67e9ea4d900c6c2497ec5a08343c0a5" translate="yes" xml:space="preserve">
          <source>Basic mathematical constants.</source>
          <target state="translated">기본 수학 상수.</target>
        </trans-unit>
        <trans-unit id="03619f20093f70d07eb4c7482bb00f0ec8e3c3fc" translate="yes" xml:space="preserve">
          <source>Basic pattern matching on &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 기본 패턴 일치 :</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="30a9f8a0441549550539e36ec0f9f9002255cfd0" translate="yes" xml:space="preserve">
          <source>Basic usage example:</source>
          <target state="translated">기본 사용법 예 :</target>
        </trans-unit>
        <trans-unit id="4ba20db65bc2f86fd8313d56d1906d6e40c680fc" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;, a type that implements &lt;code&gt;FromStr&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;FromStr&lt;/code&gt; 을 구현하는 유형 인 &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; 의&lt;/a&gt; 기본 사용법 :</target>
        </trans-unit>
        <trans-unit id="e86fea8c030e7f6d48033a20b07738fb6cc7d1e1" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; 의&lt;/a&gt; 기본 사용법 :</target>
        </trans-unit>
        <trans-unit id="a8f910f3980e5f4caf7f91e6c92b1c5ff7ef8744" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;code&gt;&amp;amp;i32&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&amp;amp;i32&lt;/code&gt; 기본 사용법 :</target>
        </trans-unit>
        <trans-unit id="4b7db61f0810a48b5403cec32d70374937db6803" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;code&gt;f64&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;f64&lt;/code&gt; 의 기본 사용법 :</target>
        </trans-unit>
        <trans-unit id="473dba01450bbaa0ba0aec1bf0715ab6ef2ccb9f" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;code&gt;i32&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;i32&lt;/code&gt; 의 기본 사용법 :</target>
        </trans-unit>
        <trans-unit id="65f639d2a40570f68ed54fc56bf243ceac2035a0" translate="yes" xml:space="preserve">
          <source>Basic usage:</source>
          <target state="translated">기본 사용법 :</target>
        </trans-unit>
        <trans-unit id="ae854127dfb82027c5681daec7e882045161fa8e" translate="yes" xml:space="preserve">
          <source>Be a &lt;a href=&quot;associated-items#methods&quot;&gt;method&lt;/a&gt; that does not use &lt;code&gt;Self&lt;/code&gt; except in the type of the receiver.</source>
          <target state="translated">수신기 유형을 제외하고 &lt;code&gt;Self&lt;/code&gt; 를 사용하지 않는 &lt;a href=&quot;associated-items#methods&quot;&gt;방법&lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a9609503521663742afb4db6d34fce975c5ef790" translate="yes" xml:space="preserve">
          <source>Be aware that operations on seemingly non-ASCII characters can sometimes have unexpected results. Consider this example:</source>
          <target state="translated">ASCII가 아닌 것처럼 보이는 문자에 대한 작업은 때때로 예기치 않은 결과를 초래할 수 있습니다. 이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="f7eed2246078297c7f3c1974fe5ece00f24fc71c" translate="yes" xml:space="preserve">
          <source>Be careful when publishing a crate because a publish is &lt;em&gt;permanent&lt;/em&gt;. The version can never be overwritten, and the code cannot be deleted. One major goal of &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; is to act as a permanent archive of code so that builds of all projects that depend on crates from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; will continue to work. Allowing version deletions would make fulfilling that goal impossible. However, there is no limit to the number of crate versions you can publish.</source>
          <target state="translated">게시가 &lt;em&gt;영구적&lt;/em&gt; 이므로 크레이트를 게시 할 때는주의하십시오 . 버전을 덮어 쓸 수 없으며 코드를 삭제할 수 없습니다. &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io의&lt;/a&gt; 주요 목표 중 하나 는 영구적 인 코드 아카이브 로 작동 하여 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io의&lt;/a&gt; 상자에 의존하는 모든 프로젝트의 빌드 가 계속 작동하도록하는 것입니다. 버전 삭제를 허용하면 해당 목표를 달성 할 수 없습니다. 그러나 게시 할 수있는 크레이트 버전 수에는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="dca86f7e9af3880530e74de899f022486c60c4c6" translate="yes" xml:space="preserve">
          <source>Be representable in the return type &lt;code&gt;Int&lt;/code&gt;, after truncating off its fractional part</source>
          <target state="translated">소수 부분을 자른 후 반환 유형 &lt;code&gt;Int&lt;/code&gt; 로 표현 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="944c776ebe8836f4d5f40423d2d077f777d1f2db" translate="yes" xml:space="preserve">
          <source>Be sure to copy over any bounds as well:</source>
          <target state="translated">경계를 모두 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7d22470344866c1dcd5a2efc22d2e6cb51a1ab2" translate="yes" xml:space="preserve">
          <source>Bear in mind that methods on infinite iterators, even those for which a result can be determined mathematically in finite time, may not terminate. Specifically, methods such as &lt;a href=&quot;trait.iterator#method.min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt;, which in the general case require traversing every element in the iterator, are likely not to return successfully for any infinite iterators.</source>
          <target state="translated">무한 반복기의 결과는 유한 한 시간에 수학적으로 결정될 수있는 방법이라도 종료되지 않을 수 있습니다. 특히, 일반적인 경우 반복자의 모든 요소를 ​​순회해야하는 &lt;a href=&quot;trait.iterator#method.min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt; 과 같은 메소드 는 무한 반복자에 대해 성공적으로 리턴되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d00abb1d72a8bac8ecec238c14739dba53b4125" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Animal::baby_name&lt;/code&gt; is an associated function rather than a method, and thus doesn&amp;rsquo;t have a &lt;code&gt;self&lt;/code&gt; parameter, Rust can&amp;rsquo;t figure out which implementation of &lt;code&gt;Animal::baby_name&lt;/code&gt; we want. We&amp;rsquo;ll get this compiler error:</source>
          <target state="translated">때문에 &lt;code&gt;Animal::baby_name&lt;/code&gt; 이없는, 따라서 관련 기능이 아닌 방법이며, &lt;code&gt;self&lt;/code&gt; 매개 변수를 녹는 구현 알아낼 수 없습니다 &lt;code&gt;Animal::baby_name&lt;/code&gt; 우리가 원하는. 이 컴파일러 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e982f4d1ceaa6ebce2e39ce35fa3517925f4eb60" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Drop::drop&lt;/code&gt; is used to clean up a value, it may be dangerous to use this value after the method has been called. As &lt;code&gt;Drop::drop&lt;/code&gt; does not take ownership of its input, Rust prevents misuse by not allowing you to call &lt;code&gt;Drop::drop&lt;/code&gt; directly.</source>
          <target state="translated">&lt;code&gt;Drop::drop&lt;/code&gt; 은 값을 정리하는 데 사용 되기 때문에 메서드가 호출 된 후이 값을 사용하는 것은 위험 할 수 있습니다. 으로 &lt;code&gt;Drop::drop&lt;/code&gt; 입력의 소유권을하지 않습니다, 녹 방지는 전화를 허용하지 않음으로써 오용 &lt;code&gt;Drop::drop&lt;/code&gt; 직접.</target>
        </trans-unit>
        <trans-unit id="c77d0afa61b96acdbbf5c9bd8c7ad5776b21e2a7" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Kilometers&lt;/code&gt; and &lt;code&gt;i32&lt;/code&gt; are the same type, we can add values of both types and we can pass &lt;code&gt;Kilometers&lt;/code&gt; values to functions that take &lt;code&gt;i32&lt;/code&gt; parameters. However, using this method, we don&amp;rsquo;t get the type checking benefits that we get from the newtype pattern discussed earlier.</source>
          <target state="translated">때문에 &lt;code&gt;Kilometers&lt;/code&gt; 와 &lt;code&gt;i32&lt;/code&gt; 동일한 유형, 우리는 두 가지 유형의 값을 추가 할 수 있습니다 우리는 통과 할 수 &lt;code&gt;Kilometers&lt;/code&gt; 걸릴 기능에 값을 &lt;code&gt;i32&lt;/code&gt; 매개 변수를. 그러나이 방법을 사용하면 앞에서 설명한 새 유형 패턴에서 얻을 수있는 유형 검사 이점을 얻을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6b9cbc9e966e04746993324da12bc0b094791922" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; allows mutable borrows checked at runtime, you can mutate the value inside the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; even when the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is immutable.</source>
          <target state="translated">때문에 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 가변 차용 실행시 체크 허용하면 내부 값 변이 수 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 짝수 때 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 불변이다.</target>
        </trans-unit>
        <trans-unit id="3648820fdd060b2ae98ec9efe9a7aa20de6bd4e7" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;_x&lt;/code&gt; is moved into the function, it is automatically dropped before the function returns.</source>
          <target state="translated">&lt;code&gt;_x&lt;/code&gt; 가 함수로 이동 되었으므로 함수가 반환되기 전에 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="02501fd298567a0388a172b4febd506fefcf8337" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;collect()&lt;/code&gt; is so general, it can cause problems with type inference. As such, &lt;code&gt;collect()&lt;/code&gt; is one of the few times you'll see the syntax affectionately known as the 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt;. This helps the inference algorithm understand specifically which collection you're trying to collect into.</source>
          <target state="translated">때문에 &lt;code&gt;collect()&lt;/code&gt; 매우 일반적이며, 그것은 형식 유추 문제를 일으킬 수 있습니다. 이와 같이 &lt;code&gt;collect()&lt;/code&gt; 는 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt; 로 알려진 구문을 볼 수있는 몇 번의 시간 중 하나입니다 . 이를 통해 추론 알고리즘이 수집하려는 컬렉션을 구체적으로 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="f792523afdd09554f3c4c09b932d34d5d3beab5f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;collect()&lt;/code&gt; only cares about what you're collecting into, you can still use a partial type hint, &lt;code&gt;_&lt;/code&gt;, with the turbofish:</source>
          <target state="translated">&lt;code&gt;collect()&lt;/code&gt; 는 수집하는 내용에만 관심이 있기 때문에 turbofish와 함께 부분 유형 힌트 &lt;code&gt;_&lt;/code&gt; 를 계속 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2e79e04cb1d4d369cbb0462d719cf25107b631b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;fancy_ref&lt;/code&gt; still holds a reference to &lt;code&gt;fancy_num&lt;/code&gt;, &lt;code&gt;fancy_num&lt;/code&gt; can't be assigned to a new value as it would invalidate the reference.</source>
          <target state="translated">때문에 &lt;code&gt;fancy_ref&lt;/code&gt; 는 여전히 참조 보유 &lt;code&gt;fancy_num&lt;/code&gt; 을 , &lt;code&gt;fancy_num&lt;/code&gt; 는 이 참조를 무효화하는 것처럼 새 값에 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ad62e74aea9006b0878a087eb02874ec0ddf69c6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;find()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation where the argument is a double reference. You can see this effect in the examples below, with &lt;code&gt;&amp;amp;&amp;amp;x&lt;/code&gt;.</source>
          <target state="translated">때문에 &lt;code&gt;find()&lt;/code&gt; 에 대한 참조를 받아, 많은 반복자는 인수가 두 번 참조입니다 가능성이 혼란 상황, 참고 문헌을 통해이 리드를 반복. &lt;code&gt;&amp;amp;&amp;amp;x&lt;/code&gt; 와 함께 아래 예에서이 효과를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8154baa71c56f29ade9fab7717781feba4bbd572" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;if&lt;/code&gt; is an expression, we can use it on the right side of a &lt;code&gt;let&lt;/code&gt; statement, as in Listing 3-2.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 가 표현식 이기 때문에 Listing 3-2에서와 같이 &lt;code&gt;let&lt;/code&gt; 문의 오른쪽에 사용할 수있다 .</target>
        </trans-unit>
        <trans-unit id="9997aaaef6017b0cb2af61885b73aab100c2b5f6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;map&lt;/code&gt; takes a closure, we can specify any operation we want to perform on each item. This is a great example of how closures let you customize some behavior while reusing the iteration behavior that the &lt;code&gt;Iterator&lt;/code&gt; trait provides.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 는 폐쇄 되기 때문에 각 항목에 대해 수행하려는 작업을 지정할 수 있습니다. 이것은 &lt;code&gt;Iterator&lt;/code&gt; 특성이 제공 하는 반복 동작을 재사용하면서 클로저가 일부 동작을 사용자 정의하는 방법에 대한 훌륭한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="b6c4314864b0e06485267f3ca664e542a4a9d24f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;map_while()&lt;/code&gt; needs to look at the value in order to see if it should be included or not, consuming iterators will see that it is removed:</source>
          <target state="translated">때문에 &lt;code&gt;map_while()&lt;/code&gt; 이 포함 여부를해야하는지 반복자가 제거되는 것을 볼 수 있습니다 소모 참조하기 위해 값을보고해야합니다 :</target>
        </trans-unit>
        <trans-unit id="3d80f24c4a2216ac3e891c23c7f333250fe61032" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;parse&lt;/code&gt; is so general, it can cause problems with type inference. As such, &lt;code&gt;parse&lt;/code&gt; is one of the few times you'll see the syntax affectionately known as the 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt;. This helps the inference algorithm understand specifically which type you're trying to parse into.</source>
          <target state="translated">때문에 &lt;code&gt;parse&lt;/code&gt; 매우 일반적이며, 그것은 형식 유추 문제를 일으킬 수 있습니다. 따라서 &lt;code&gt;parse&lt;/code&gt; 은 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt; 로 알려진 구문을 볼 수있는 몇 번의 시간 중 하나입니다 . 이는 추론 알고리즘이 구문 분석하려는 유형을 구체적으로 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="f088d61355fe261cd42315fc674f33d7a3ce9310" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;peek()&lt;/code&gt; returns a reference, and many iterators iterate over references, there can be a possibly confusing situation where the return value is a double reference. You can see this effect in the examples below.</source>
          <target state="translated">때문에 &lt;code&gt;peek()&lt;/code&gt; 에 대한 참조를 반환하고, 많은 반복자는 참조를 반복, 반환 값은 이중 참조입니다 가능성이 혼란 상황이있을 수있다. 아래 예제에서이 효과를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a4418890cc2a26bb07a69375b759eb2f8d9d03d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;peek_mut()&lt;/code&gt; returns a reference, and many iterators iterate over references, there can be a possibly confusing situation where the return value is a double reference. You can see this effect in the examples below.</source>
          <target state="translated">때문에 &lt;code&gt;peek_mut()&lt;/code&gt; 에 대한 참조를 반환하고, 많은 반복자는 참조를 반복, 반환 값은 이중 참조입니다 가능성이 혼란 상황이있을 수있다. 아래 예에서이 효과를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7eb647ad22291b28a51fd607cc84aff6f4abc83" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;rfind()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation where the argument is a double reference. You can see this effect in the examples below, with &lt;code&gt;&amp;amp;&amp;amp;x&lt;/code&gt;.</source>
          <target state="translated">때문에 &lt;code&gt;rfind()&lt;/code&gt; 에 대한 참조를 받아, 많은 반복자는 인수가 두 번 참조입니다 가능성이 혼란 상황, 참고 문헌을 통해이 리드를 반복. &lt;code&gt;&amp;amp;&amp;amp;x&lt;/code&gt; 와 함께 아래 예에서이 효과를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ddf1f7383234f0909d810cef598c63fc6f240534" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;s&lt;/code&gt; is created inside &lt;code&gt;dangle&lt;/code&gt;, when the code of &lt;code&gt;dangle&lt;/code&gt; is finished, &lt;code&gt;s&lt;/code&gt; will be deallocated. But we tried to return a reference to it. That means this reference would be pointing to an invalid &lt;code&gt;String&lt;/code&gt;. That&amp;rsquo;s no good! Rust won&amp;rsquo;t let us do this.</source>
          <target state="translated">때문에 &lt;code&gt;s&lt;/code&gt; 내부에 생성 &lt;code&gt;dangle&lt;/code&gt; 의 코드 때 &lt;code&gt;dangle&lt;/code&gt; 완료되면, &lt;code&gt;s&lt;/code&gt; 해제됩니다. 그러나 우리는 그것에 대한 참조를 반환하려고했습니다. 이것은이 참조가 유효하지 않은 &lt;code&gt;String&lt;/code&gt; 을 가리키고 있다는 것을 의미합니다 . 좋지 않아! 녹은 우리가 이것을 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="ad3a4a81012df51bdd1c2d631b8bd2d26a080ac6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;take_while()&lt;/code&gt; needs to look at the value in order to see if it should be included or not, consuming iterators will see that it is removed:</source>
          <target state="translated">때문에 &lt;code&gt;take_while()&lt;/code&gt; 이 포함 여부를해야하는지 반복자가 제거되는 것을 볼 수 있습니다 소모 참조하기 위해 값을보고해야합니다 :</target>
        </trans-unit>
        <trans-unit id="a2c09e5f782c06a87c2e923fecb0abf777de8d4b" translate="yes" xml:space="preserve">
          <source>Because Rust compiles generic code into code that specifies the type in each instance, we pay no runtime cost for using generics. When the code runs, it performs just as it would if we had duplicated each definition by hand. The process of monomorphization makes Rust&amp;rsquo;s generics extremely efficient at runtime.</source>
          <target state="translated">Rust는 일반 코드를 각 인스턴스의 유형을 지정하는 코드로 컴파일하기 때문에 제네릭 사용에 대한 런타임 비용을 지불하지 않습니다. 코드가 실행될 때 각 정의를 직접 복제 한 것처럼 수행합니다. 단일화 프로세스는 Rust의 제네릭을 런타임에 매우 효율적으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cb2c4627fadc957440586a7d9c240acafefffc6b" translate="yes" xml:space="preserve">
          <source>Because a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is a pointer, Rust always knows how much space a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; needs: a pointer&amp;rsquo;s size doesn&amp;rsquo;t change based on the amount of data it&amp;rsquo;s pointing to. This means we can put a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; inside the &lt;code&gt;Cons&lt;/code&gt; variant instead of another &lt;code&gt;List&lt;/code&gt; value directly. The &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; will point to the next &lt;code&gt;List&lt;/code&gt; value that will be on the heap rather than inside the &lt;code&gt;Cons&lt;/code&gt; variant. Conceptually, we still have a list, created with lists &amp;ldquo;holding&amp;rdquo; other lists, but this implementation is now more like placing the items next to one another rather than inside one another.</source>
          <target state="translated">때문에 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 포인터이며, 녹 항상 알고 얼마나 많은 공간 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 의 요구 : 포인터의 크기가 가리키는 데이터의 양에 따라 변경되지 않습니다. 즉 , 다른 &lt;code&gt;List&lt;/code&gt; 값 대신 &lt;code&gt;Cons&lt;/code&gt; 변형 안에 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 직접 넣을 수 있습니다. &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 다음을 가리 킵니다 &lt;code&gt;List&lt;/code&gt; 힙에보다는 내부 될 것 값 &lt;code&gt;Cons&lt;/code&gt; 변형. 개념적으로, 우리는 여전히 다른 목록을&amp;ldquo;보유&amp;rdquo;하는 목록으로 작성된 목록을 가지고 있지만,이 구현은 이제 항목을 서로 내부가 아니라 서로 옆에 배치하는 것과 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="cf81e03b95485ed347873e7e3fe9e72472e6c6b8" translate="yes" xml:space="preserve">
          <source>Because async blocks construct a future, they define an &lt;strong&gt;async context&lt;/strong&gt; which can in turn contain &lt;a href=&quot;await-expr&quot;&gt;&lt;code&gt;await&lt;/code&gt; expressions&lt;/a&gt;. Async contexts are established by async blocks as well as the bodies of async functions, whose semantics are defined in terms of async blocks.</source>
          <target state="translated">비동기 블록은 퓨처를 구성하므로 &lt;a href=&quot;await-expr&quot;&gt; &lt;code&gt;await&lt;/code&gt; &lt;/a&gt; 표현식 을 포함 할 수 있는 &lt;strong&gt;비동기 컨텍스트&lt;/strong&gt; 를 정의합니다 . 비동기 컨텍스트는 의미가 비동기 블록으로 정의되는 비동기 함수의 본문뿐만 아니라 비동기 블록에 의해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1af0938fa6746a245ca497556ef936994388e62f" translate="yes" xml:space="preserve">
          <source>Because captures are often by reference, the following general rules arise:</source>
          <target state="translated">캡처는 종종 참조로 이루어 지므로 다음과 같은 일반적인 규칙이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="48453fbdaf06b97c2a50276382893c7136610cb4" translate="yes" xml:space="preserve">
          <source>Because forgetting a value is allowed, any &lt;code&gt;unsafe&lt;/code&gt; code you write must allow for this possibility. You cannot return a value and expect that the caller will necessarily run the value's destructor.</source>
          <target state="translated">값을 잊어 버리는 것이 허용되므로, 작성하는 &lt;code&gt;unsafe&lt;/code&gt; 코드가이 가능성을 허용해야합니다. 값을 반환 할 수 없으며 호출자가 반드시 값의 소멸자를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="757a75cd5c62512d1ecdcf5444c4066082ba840e" translate="yes" xml:space="preserve">
          <source>Because having variable names match the fields is common and because writing &lt;code&gt;let Point { x: x, y: y } = p;&lt;/code&gt; contains a lot of duplication, there is a shorthand for patterns that match struct fields: you only need to list the name of the struct field, and the variables created from the pattern will have the same names. Listing 18-13 shows code that behaves in the same way as the code in Listing 18-12, but the variables created in the &lt;code&gt;let&lt;/code&gt; pattern are &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; instead of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">변수 이름이 필드와 일치하므로 &lt;code&gt;let Point { x: x, y: y } = p;&lt;/code&gt; 중복이 많이 포함 된 경우, 구조체 필드와 일치하는 패턴의 약어가 있습니다. 구조체 필드의 이름 만 나열하면되고 패턴에서 작성된 변수의 이름은 동일합니다. Listing 18-13은 Listing 18-12의 코드와 동일한 방식으로 동작하는 코드를 보여 주지만 &lt;code&gt;let&lt;/code&gt; 패턴 에서 작성된 변수 는 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 대신 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="83438caeb4e092f6346d53e11e3dc5cc7d15ebb0" translate="yes" xml:space="preserve">
          <source>Because marker traits are allowed to have multiple implementations for the same type, it's not allowed to override anything in those implementations, as it would be ambiguous which override should actually be used.</source>
          <target state="translated">마커 특성은 동일한 유형에 대해 여러 구현을 가질 수 있기 때문에 실제로 사용해야하는 재정의가 모호하기 때문에 해당 구현에서 어떤 것도 재정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e1154d896f41e24691d4a2066a20e9a97b30a6b0" translate="yes" xml:space="preserve">
          <source>Because of the call to the &lt;code&gt;foo&lt;/code&gt; macro, the compiler guesses that the missing module could be inside it and fails because the macro definition cannot be found.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 매크로 에 대한 호출로 인해 컴파일러는 누락 된 모듈이 내부에있을 수 있다고 추측하고 매크로 정의를 찾을 수 없기 때문에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="620af94cb9d051d4dfe9f749a85e09b10b24aa07" translate="yes" xml:space="preserve">
          <source>Because of the early return, &lt;code&gt;try!&lt;/code&gt; can only be used in functions that return &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일찍 돌아 &lt;code&gt;try!&lt;/code&gt; &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 를 반환하는 함수에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c9db3f614804b168272d0d3012c3d9bae7f766b" translate="yes" xml:space="preserve">
          <source>Because of this dual purpose, it is possible to create types that are not useful for interfacing with the C programming language.</source>
          <target state="translated">이 이중 목적으로 인해 C 프로그래밍 언어와의 인터페이스에 유용하지 않은 유형을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eba9459a54a420c4009843eca1a3d7462a26445" translate="yes" xml:space="preserve">
          <source>Because of this recursive dropping, you do not need to implement this trait unless your type needs its own destructor logic.</source>
          <target state="translated">이 재귀 적하 때문에 유형에 자체 소멸자 논리가 필요하지 않으면이 특성을 구현할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="df92f9c80443d85d1d1f8c4ed514d9988ba7345d" translate="yes" xml:space="preserve">
          <source>Because of this, the behavior when both &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; exist differs. On Unix, if &lt;code&gt;from&lt;/code&gt; is a directory, &lt;code&gt;to&lt;/code&gt; must also be an (empty) directory. If &lt;code&gt;from&lt;/code&gt; is not a directory, &lt;code&gt;to&lt;/code&gt; must also be not a directory. In contrast, on Windows, &lt;code&gt;from&lt;/code&gt; can be anything, but &lt;code&gt;to&lt;/code&gt; must &lt;em&gt;not&lt;/em&gt; be a directory.</source>
          <target state="translated">이로 인해 &lt;code&gt;from&lt;/code&gt; 과 &lt;code&gt;to&lt;/code&gt; 의 동작 이 다릅니다. Unix에서 &lt;code&gt;from&lt;/code&gt; 이 디렉토리 인 경우 &lt;code&gt;to&lt;/code&gt; 는 (빈) 디렉토리 여야합니다. &lt;code&gt;from&lt;/code&gt; 이 디렉토리가 아닌 경우 &lt;code&gt;to&lt;/code&gt; 도 디렉토리가 아니 어야합니다. 반면, Windows에서, &lt;code&gt;from&lt;/code&gt; 무엇이든 될 수 있지만, &lt;code&gt;to&lt;/code&gt; 해야 &lt;em&gt;하지&lt;/em&gt; 디렉토리합니다.</target>
        </trans-unit>
        <trans-unit id="edb25a77d997330fe82c62f487b65b2a449f7a57" translate="yes" xml:space="preserve">
          <source>Because of this, you must give the numeric literal or binding a type:</source>
          <target state="translated">이 때문에 숫자 리터럴을 제공하거나 유형을 바인딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5828ddf70feaedc77b7fe1498bca4e7ef61a70f" translate="yes" xml:space="preserve">
          <source>Because ownership is a new concept for many programmers, it does take some time to get used to. The good news is that the more experienced you become with Rust and the rules of the ownership system, the more you&amp;rsquo;ll be able to naturally develop code that is safe and efficient. Keep at it!</source>
          <target state="translated">소유권은 많은 프로그래머에게 새로운 개념이므로 익숙해지는 데 시간이 걸립니다. 좋은 소식은 Rust에 대한 경험이 풍부하고 소유권 시스템의 규칙이 많을수록 안전하고 효율적인 코드를 자연스럽게 개발할 수 있다는 것입니다. 견디어 내다!</target>
        </trans-unit>
        <trans-unit id="e400474ad8de5abb677ee1fb6adda287a3d95af5" translate="yes" xml:space="preserve">
          <source>Because raw entries provide much more low-level control, it's much easier to put the HashMap into an inconsistent state which, while memory-safe, will cause the map to produce seemingly random results. Higher-level and more foolproof APIs like &lt;code&gt;entry&lt;/code&gt; should be preferred when possible.</source>
          <target state="translated">원시 항목은 훨씬 더 낮은 수준의 제어를 제공하기 때문에 HashMap을 일관성이없는 상태로 만드는 것이 훨씬 쉽습니다. 메모리가 안전하지만 맵에서 임의의 결과가 생성됩니다. 가능하면 &lt;code&gt;entry&lt;/code&gt; 와 같은 더 높은 수준의 더 안전한 API 가 선호되어야합니다.</target>
        </trans-unit>
        <trans-unit id="25432f6301bbde0b420035486d49aeb28bde5fd2" translate="yes" xml:space="preserve">
          <source>Because some analysis is impossible, if the Rust compiler can&amp;rsquo;t be sure the code complies with the ownership rules, it might reject a correct program; in this way, it&amp;rsquo;s conservative. If Rust accepted an incorrect program, users wouldn&amp;rsquo;t be able to trust in the guarantees Rust makes. However, if Rust rejects a correct program, the programmer will be inconvenienced, but nothing catastrophic can occur. The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type is useful when you&amp;rsquo;re sure your code follows the borrowing rules but the compiler is unable to understand and guarantee that.</source>
          <target state="translated">일부 분석이 불가능하기 때문에 Rust 컴파일러가 코드가 소유권 규칙을 준수하는지 확신 할 수 없으면 올바른 프로그램을 거부 할 수 있습니다. 이런 식으로 보수적입니다. Rust이 잘못된 프로그램을 수락하면 사용자는 Rust의 보증을 신뢰할 수 없습니다. 그러나 Rust이 올바른 프로그램을 거부하면 프로그래머는 불편을 겪을 수 있지만 치명적인 것은 없습니다. &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 당신은 당신의 코드가 차용 규칙을 따른다 확신 할 때 유형은 유용하지만 컴파일러는 이해하고 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="029a6be2649372b5b88e5ae502ff0638c469c42e" translate="yes" xml:space="preserve">
          <source>Because strings are used for so many things, we can use many different generic APIs for strings, providing us with a lot of options. Some of them can seem redundant, but they all have their place! In this case, &lt;code&gt;String::from&lt;/code&gt; and &lt;code&gt;to_string&lt;/code&gt; do the same thing, so which you choose is a matter of style.</source>
          <target state="translated">문자열은 너무 많은 용도로 사용되므로 문자열에 다양한 일반 API를 사용하여 많은 옵션을 제공 할 수 있습니다. 그들 중 일부는 중복되어 보일 수 있지만 모두 자신의 자리를 차지했습니다! 이 경우 &lt;code&gt;String::from&lt;/code&gt; 및 &lt;code&gt;to_string&lt;/code&gt; 은 동일한 작업을 수행하므로 선택하는 것은 스타일의 문제입니다.</target>
        </trans-unit>
        <trans-unit id="1b950a204977447e5ef7cd3c6942f49baa8eb222" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;enumerate&lt;/code&gt; method returns a tuple, we can use patterns to destructure that tuple, just like everywhere else in Rust. So in the &lt;code&gt;for&lt;/code&gt; loop, we specify a pattern that has &lt;code&gt;i&lt;/code&gt; for the index in the tuple and &lt;code&gt;&amp;amp;item&lt;/code&gt; for the single byte in the tuple. Because we get a reference to the element from &lt;code&gt;.iter().enumerate()&lt;/code&gt;, we use &lt;code&gt;&amp;amp;&lt;/code&gt; in the pattern.</source>
          <target state="translated">&lt;code&gt;enumerate&lt;/code&gt; 메소드는 튜플을 반환 하기 때문에 Rust의 다른 곳에서와 마찬가지로 패턴을 사용하여 해당 튜플을 재구성 할 수 있습니다. 따라서 &lt;code&gt;for&lt;/code&gt; 루프 에서 튜플의 인덱스에 &lt;code&gt;i&lt;/code&gt; 가 있고 튜플 의 단일 바이트에 대한 &lt;code&gt;&amp;amp;item&lt;/code&gt; 이있는 패턴을 지정합니다 . &lt;code&gt;.iter().enumerate()&lt;/code&gt; 에서 요소에 대한 참조를 얻으므로 패턴에 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="4bad4d17c2470c688d65e4cf4cd29dd8d9a6843c" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;fly&lt;/code&gt; method takes a &lt;code&gt;self&lt;/code&gt; parameter, if we had two &lt;em&gt;types&lt;/em&gt; that both implement one &lt;em&gt;trait&lt;/em&gt;, Rust could figure out which implementation of a trait to use based on the type of &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fly&lt;/code&gt; 메서드는 &lt;code&gt;self&lt;/code&gt; 매개 변수를 사용 하기 때문에 하나의 &lt;em&gt;특성을&lt;/em&gt; 구현하는 두 가지 &lt;em&gt;유형&lt;/em&gt; 이있는 경우 Rust는 &lt;code&gt;self&lt;/code&gt; 유형에 따라 사용할 특성의 구현을 파악할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dfa04ea7812d8d0a045650338922229931556bb" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;toast&lt;/code&gt; field in the &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; struct is public, in &lt;code&gt;eat_at_restaurant&lt;/code&gt; we can write and read to the &lt;code&gt;toast&lt;/code&gt; field using dot notation. Notice that we can&amp;rsquo;t use the &lt;code&gt;seasonal_fruit&lt;/code&gt; field in &lt;code&gt;eat_at_restaurant&lt;/code&gt; because &lt;code&gt;seasonal_fruit&lt;/code&gt; is private. Try uncommenting the line modifying the &lt;code&gt;seasonal_fruit&lt;/code&gt; field value to see what error you get!</source>
          <target state="translated">&lt;code&gt;back_of_house::Breakfast&lt;/code&gt; 구조체 의 &lt;code&gt;toast&lt;/code&gt; 필드 는 공용이므로 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 에서는 도트 표기법을 사용하여 &lt;code&gt;toast&lt;/code&gt; 필드에 쓰고 읽을 수 있습니다 . 우리가 사용할 수 없다는 것을주의 &lt;code&gt;seasonal_fruit&lt;/code&gt; 의 에서 필드를 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 때문에 &lt;code&gt;seasonal_fruit&lt;/code&gt; 은 비공개입니다. &lt;code&gt;seasonal_fruit&lt;/code&gt; _ 과일 필드 값을 수정하여 줄의 주석을 해제하여 어떤 오류가 발생했는지 확인하십시오!</target>
        </trans-unit>
        <trans-unit id="185de19b862032b52b28484b2c6cc55792a266c3" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;write&lt;/code&gt; operation could fail, we use &lt;code&gt;unwrap&lt;/code&gt; on any error result as before. Again, in a real application you would add error handling here. Finally, &lt;code&gt;flush&lt;/code&gt; will wait and prevent the program from continuing until all the bytes are written to the connection; &lt;code&gt;TcpStream&lt;/code&gt; contains an internal buffer to minimize calls to the underlying operating system.</source>
          <target state="translated">때문에 &lt;code&gt;write&lt;/code&gt; 작업이 실패 할 수 있습니다, 우리가 사용하는 &lt;code&gt;unwrap&lt;/code&gt; 이전과 오류의 결과에. 실제 응용 프로그램에서는 여기에 오류 처리 기능을 추가합니다. 마지막으로, &lt;code&gt;flush&lt;/code&gt; 는 모든 바이트가 연결에 기록 될 때까지 프로그램이 대기하지 못하도록합니다. &lt;code&gt;TcpStream&lt;/code&gt; 에는 기본 운영 체제에 대한 호출을 최소화하기위한 내부 버퍼가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b1f6fd955e3dd56c20447476cad2f0ff374150c" translate="yes" xml:space="preserve">
          <source>Because the closure passed to &lt;code&gt;filter()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure is a double reference:</source>
          <target state="translated">&lt;code&gt;filter()&lt;/code&gt; 전달 된 클로저 는 참조를 취하고 많은 반복자가 참조를 반복하므로 클로저 유형이 이중 참조 인 혼동 상황이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58c9579a8a89655df95e712d81cbf2a21bf02a65" translate="yes" xml:space="preserve">
          <source>Because the closure passed to &lt;code&gt;skip_while()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure is a double reference:</source>
          <target state="translated">&lt;code&gt;skip_while()&lt;/code&gt; 전달 된 클로저 는 참조를 취하고 많은 반복자가 참조를 반복하므로 클로저의 유형이 이중 참조 인 상황이 혼동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8479afb170cef741fbbcede9d3610679171e5033" translate="yes" xml:space="preserve">
          <source>Because the closure passed to &lt;code&gt;take_while()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure is a double reference:</source>
          <target state="translated">&lt;code&gt;take_while()&lt;/code&gt; 전달 된 클로저 는 참조를 취하고 많은 반복자는 참조를 반복하므로, 클로저 유형이 이중 참조 인 혼동되는 상황이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eb937137f69efc7f4d05e71e805b680ad9ce55c" translate="yes" xml:space="preserve">
          <source>Because the correct result of the &lt;code&gt;can_hold&lt;/code&gt; function in this case is &lt;code&gt;false&lt;/code&gt;, we need to negate that result before we pass it to the &lt;code&gt;assert!&lt;/code&gt; macro. As a result, our test will pass if &lt;code&gt;can_hold&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">이 경우 &lt;code&gt;can_hold&lt;/code&gt; 함수 의 올바른 결과 는 &lt;code&gt;false&lt;/code&gt; 이므로 &lt;code&gt;assert!&lt;/code&gt; 전달하기 전에 해당 결과를 무효화해야합니다 ! 매크로. 결과적으로 &lt;code&gt;can_hold&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 테스트가 통과됩니다 .</target>
        </trans-unit>
        <trans-unit id="90666aa0415ee00d8f72df1807729b34de2b7424" translate="yes" xml:space="preserve">
          <source>Because the function item type explicitly identifies the function, the item types of different functions - different items, or the same item with different generics - are distinct, and mixing them will create a type error:</source>
          <target state="translated">함수 아이템 타입은 함수를 명시 적으로 식별하기 때문에, 다른 함수, 다른 아이템 또는 다른 제네릭을 가진 같은 아이템의 아이템 타입은 구별되며, 그것들을 혼합하면 타입 에러가 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="91472ca2849f01f7f3aadf84c45216c15e72f922" translate="yes" xml:space="preserve">
          <source>Because the goal is to keep all these rules inside the structs that implement &lt;code&gt;State&lt;/code&gt;, we call a &lt;code&gt;content&lt;/code&gt; method on the value in &lt;code&gt;state&lt;/code&gt; and pass the post instance (that is, &lt;code&gt;self&lt;/code&gt;) as an argument. Then we return the value that is returned from using the &lt;code&gt;content&lt;/code&gt; method on the &lt;code&gt;state&lt;/code&gt; value.</source>
          <target state="translated">목표는 이러한 모든 규칙을 &lt;code&gt;State&lt;/code&gt; 를 구현하는 구조체 내에 유지하는 것이므로 &lt;code&gt;state&lt;/code&gt; 의 값에 대해 &lt;code&gt;content&lt;/code&gt; 메소드를 호출 하고 post 인스턴스 (즉, &lt;code&gt;self&lt;/code&gt; )를 인수로 전달합니다. 그런 다음 &lt;code&gt;state&lt;/code&gt; 메소드에서 &lt;code&gt;content&lt;/code&gt; 메소드 를 사용하여 리턴 된 값을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="030b08f8ea47335b102e955f832da8f8f1553c44" translate="yes" xml:space="preserve">
          <source>Because the parameter names and the struct field names are exactly the same in Listing 5-4, we can use the &lt;em&gt;field init shorthand&lt;/em&gt; syntax to rewrite &lt;code&gt;build_user&lt;/code&gt; so that it behaves exactly the same but doesn&amp;rsquo;t have the repetition of &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;username&lt;/code&gt;, as shown in Listing 5-5.</source>
          <target state="translated">매개 변수 이름 및 구조체의 필드 이름은 5-4 목록에서 동일하기 때문에, 우리가 사용할 수있는 &lt;em&gt;필드를 초기화 속기&lt;/em&gt; 구문 재 작성 &lt;code&gt;build_user&lt;/code&gt; 그래서 정확히 같은 동작 만의 반복하지 않는 &lt;code&gt;email&lt;/code&gt; 과 &lt;code&gt;username&lt;/code&gt; 같이 Listing 5-5에 나와있다.</target>
        </trans-unit>
        <trans-unit id="d69419dfb414355067e2d4508090380593ccdd03" translate="yes" xml:space="preserve">
          <source>Because the standard library has this blanket implementation, we can call the &lt;code&gt;to_string&lt;/code&gt; method defined by the &lt;code&gt;ToString&lt;/code&gt; trait on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait. For example, we can turn integers into their corresponding &lt;code&gt;String&lt;/code&gt; values like this because integers implement &lt;code&gt;Display&lt;/code&gt;:</source>
          <target state="translated">표준 라이브러리에는이 블랭킷 구현이 있으므로 &lt;code&gt;Display&lt;/code&gt; 특성 을 구현하는 모든 유형 에서 &lt;code&gt;ToString&lt;/code&gt; 특성으로 정의 된 &lt;code&gt;to_string&lt;/code&gt; 메소드를 호출 할 수 있습니다 . 예를 들어 정수는 &lt;code&gt;Display&lt;/code&gt; 를 구현하기 때문에 정수를 이와 같은 해당 &lt;code&gt;String&lt;/code&gt; 값 으로 바꿀 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37ef1e15d186d9fd04a65d1942d30d946ce68135" translate="yes" xml:space="preserve">
          <source>Because the third rule really only applies in method signatures, we&amp;rsquo;ll look at lifetimes in that context next to see why the third rule means we don&amp;rsquo;t have to annotate lifetimes in method signatures very often.</source>
          <target state="translated">세 번째 규칙은 실제로 메소드 서명에만 적용되므로 다음 컨텍스트에서 수명을 살펴보고 세 번째 규칙이 왜 메소드 서명에서 수명에 주석을 달지 않아도되는지를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70d45c4687665d4e0a5b39f62a85fe258555be07" translate="yes" xml:space="preserve">
          <source>Because the value that &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; references might have been dropped, to do anything with the value that a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; is pointing to, you must make sure the value still exists. Do this by calling the &lt;code&gt;upgrade&lt;/code&gt; method on a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; instance, which will return an &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;. You&amp;rsquo;ll get a result of &lt;code&gt;Some&lt;/code&gt; if the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value has not been dropped yet and a result of &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value has been dropped. Because &lt;code&gt;upgrade&lt;/code&gt; returns an &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, Rust will ensure that the &lt;code&gt;Some&lt;/code&gt; case and the &lt;code&gt;None&lt;/code&gt; case are handled, and there won&amp;rsquo;t be an invalid pointer.</source>
          <target state="translated">&lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 참조 하는 값 이 삭제되었을 수 있으므로 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 가 가리키는 값으로 작업을 수행 하려면 값이 여전히 존재하는지 확인해야합니다. &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;upgrade&lt;/code&gt; 메서드를 호출하면 &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 반환합니다 . 당신의 결과거야 &lt;code&gt;Some&lt;/code&gt; 경우를 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 값이 아직 떨어의 결과되지 않았습니다 &lt;code&gt;None&lt;/code&gt; 경우 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 값이 삭제되었습니다. &lt;code&gt;upgrade&lt;/code&gt; 가 &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 반환 하기 때문에 Rust는 &lt;code&gt;Some&lt;/code&gt; case와 &lt;code&gt;None&lt;/code&gt; 케이스가 처리되고 잘못된 포인터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d8bf4707482fe4f59a8a059222ee5cf8616fe8ba" translate="yes" xml:space="preserve">
          <source>Because the value that &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; references might have been dropped, to do anything with the value that a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; is pointing to, you must make sure the value still exists. Do this by calling the &lt;code&gt;upgrade&lt;/code&gt; method on a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; instance, which will return an &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;. You&amp;rsquo;ll get a result of &lt;code&gt;Some&lt;/code&gt; if the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value has not been dropped yet and a result of &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value has been dropped. Because &lt;code&gt;upgrade&lt;/code&gt; returns an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, Rust will ensure that the &lt;code&gt;Some&lt;/code&gt; case and the &lt;code&gt;None&lt;/code&gt; case are handled, and there won&amp;rsquo;t be an invalid pointer.</source>
          <target state="translated">&lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 참조 하는 값 이 삭제되었으므로 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 가 가리키는 값으로 작업을 수행 하려면 값이 여전히 존재하는지 확인해야합니다. &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;upgrade&lt;/code&gt; 메소드를 호출하여이를 수행 하면 &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 가 리턴됩니다 . 당신의 결과거야 &lt;code&gt;Some&lt;/code&gt; 경우를 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 값이 아직 떨어의 결과되지 않았습니다 &lt;code&gt;None&lt;/code&gt; 경우 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 값이 삭제되었습니다. 때문에 &lt;code&gt;upgrade&lt;/code&gt; 다시 표시 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; , 녹 보장합니다 그 &lt;code&gt;Some&lt;/code&gt; 경우와 &lt;code&gt;None&lt;/code&gt; case가 처리되며 유효하지 않은 포인터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="14741fffc1dc74532e1921d454b0c26246f646ef" translate="yes" xml:space="preserve">
          <source>Because the vast majority of Rust projects use Cargo, the rest of this book assumes that you&amp;rsquo;re using Cargo too. Cargo comes installed with Rust if you used the official installers discussed in the &lt;a href=&quot;ch01-01-installation#installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo;&lt;/a&gt; section. If you installed Rust through some other means, check whether Cargo is installed by entering the following into your terminal:</source>
          <target state="translated">대부분의 Rust 프로젝트는화물을 사용하기 때문에이 책의 나머지 부분에서는화물을 사용한다고 가정합니다. &lt;a href=&quot;ch01-01-installation#installation&quot;&gt;&amp;ldquo;설치&amp;rdquo;&lt;/a&gt; 섹션 에서 설명한 공식 설치 프로그램을 사용하면 Cargo에 Rust가 설치됩니다 . 다른 방법으로 Rust를 설치 한 경우 터미널에 다음을 입력하여 Cargo가 설치되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="50d3009a3e9b08a6e3dea49369c4a3eff85c4a99" translate="yes" xml:space="preserve">
          <source>Because they are traits, &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; are implemented by a number of other types, and you can implement them for your types too. As such, you'll see a few different types of I/O throughout the documentation in this module: &lt;a href=&quot;../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../net/struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt;s, and sometimes even &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;s. For example, &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; adds a &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; method, which we can use on &lt;a href=&quot;../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s:</source>
          <target state="translated">그것들은 특성이기 때문에 &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; 는 다른 많은 유형으로 구현되며, 당신의 유형에도 적용 할 수 있습니다. &lt;a href=&quot;../net/struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; 모듈의 문서 전체에서 &lt;a href=&quot;../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; , TcpStream 및 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 등 몇 가지 다른 유형의 I / O가 표시됩니다 . 예를 들어, &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; 에서&lt;/a&gt; 사용할 수 있는 &lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 메소드를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="e07ae336ff59e9ed0b225ca89429b661de0679cf" translate="yes" xml:space="preserve">
          <source>Because this declaration is in the &lt;code&gt;std::io&lt;/code&gt; module, we can use the fully qualified alias &lt;code&gt;std::io::Result&amp;lt;T&amp;gt;&lt;/code&gt;&amp;mdash;that is, a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; with the &lt;code&gt;E&lt;/code&gt; filled in as &lt;code&gt;std::io::Error&lt;/code&gt;. The &lt;code&gt;Write&lt;/code&gt; trait function signatures end up looking like this:</source>
          <target state="translated">이 선언은 &lt;code&gt;std::io&lt;/code&gt; 모듈 에 있기 때문에 정규화 된 별명 &lt;code&gt;std::io::Result&amp;lt;T&amp;gt;&lt;/code&gt; 즉 &lt;code&gt;E&lt;/code&gt; 가 &lt;code&gt;std::io::Error&lt;/code&gt; 로 채워진 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 를 사용할 수 있습니다. :: 오류 . &lt;code&gt;Write&lt;/code&gt; 특성 기능 서명이처럼 보이는 끝낼 :</target>
        </trans-unit>
        <trans-unit id="4d78cf22aaa22c544c68896425f6652ea68b656d" translate="yes" xml:space="preserve">
          <source>Because this error message starts with the text we specified, &lt;code&gt;Failed to open hello.txt&lt;/code&gt;, it will be easier to find where in the code this error message is coming from. If we use &lt;code&gt;unwrap&lt;/code&gt; in multiple places, it can take more time to figure out exactly which &lt;code&gt;unwrap&lt;/code&gt; is causing the panic because all &lt;code&gt;unwrap&lt;/code&gt; calls that panic print the same message.</source>
          <target state="translated">이 오류 메시지는 지정한 텍스트 인 &lt;code&gt;Failed to open hello.txt&lt;/code&gt; 코드에서이 오류 메시지의 출처를 쉽게 찾을 수 있습니다. 우리가 사용하는 경우 &lt;code&gt;unwrap&lt;/code&gt; 여러 위치에, 정확히 알아낼 더 많은 시간이 걸릴 수 있습니다 &lt;code&gt;unwrap&lt;/code&gt; 모든 때문에 공황의 원인이되는 &lt;code&gt;unwrap&lt;/code&gt; 패닉이 같은 메시지를 인쇄 한 통화를.</target>
        </trans-unit>
        <trans-unit id="f9ecc9d043c4a1c0a98d5acfc2202fd98ea778e6" translate="yes" xml:space="preserve">
          <source>Because this function may panic, its use is generally discouraged. Instead, prefer to use pattern matching and handle the &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; case explicitly, or call &lt;a href=&quot;enum.option#method.unwrap_or&quot;&gt;&lt;code&gt;unwrap_or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.option#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;enum.option#method.unwrap_or_default&quot;&gt;&lt;code&gt;unwrap_or_default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능은 패닉이 발생할 수 있으므로 일반적으로 사용하지 않는 것이 좋습니다. 대신 패턴 일치를 사용하고 &lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 케이스를 명시 적으로 처리 하거나 &lt;a href=&quot;enum.option#method.unwrap_or&quot;&gt; &lt;code&gt;unwrap_or&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;enum.option#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;enum.option#method.unwrap_or_default&quot;&gt; &lt;code&gt;unwrap_or_default&lt;/code&gt; 를&lt;/a&gt; 호출 하는 것을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="324230b46d81d1ff99203ce38c74a82aa7a9a294" translate="yes" xml:space="preserve">
          <source>Because this function may panic, its use is generally discouraged. Instead, prefer to use pattern matching and handle the &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; case explicitly, or call &lt;a href=&quot;enum.result#method.unwrap_or&quot;&gt;&lt;code&gt;unwrap_or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.result#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;enum.result#method.unwrap_or_default&quot;&gt;&lt;code&gt;unwrap_or_default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능은 패닉이 발생할 수 있으므로 일반적으로 사용하지 않는 것이 좋습니다. 대신 패턴 일치를 사용하고 &lt;a href=&quot;enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 케이스를 명시 적으로 처리 하거나 &lt;a href=&quot;enum.result#method.unwrap_or&quot;&gt; &lt;code&gt;unwrap_or&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;enum.result#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;enum.result#method.unwrap_or_default&quot;&gt; &lt;code&gt;unwrap_or_default&lt;/code&gt; 를&lt;/a&gt; 호출 하는 것을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="f4fba9e24de13af0b7e1e106a0a89b1207341158" translate="yes" xml:space="preserve">
          <source>Because this representation delegates type layout to another type, it cannot be used with any other representation.</source>
          <target state="translated">이 표현은 유형 레이아웃을 다른 유형으로 위임하기 때문에 다른 표현과 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="210e09fafaa62c8b440f8de035b1059405d433ec" translate="yes" xml:space="preserve">
          <source>Because transparent enums are represented exactly like one of their variants at run time, said variant must be uniquely determined. If there is no variant, or if there are multiple variants, it is not clear how the enum should be represented.</source>
          <target state="translated">투명한 열거 형은 런타임에 해당 변형 중 하나와 똑같이 표시되므로 해당 변형을 고유하게 결정해야합니다. 변형이 없거나 변형이 여러 개인 경우 열거 형을 어떻게 표현해야하는지 명확하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fcd01a50be2628ee7e2de7196f3290d3a3e7d1ae" translate="yes" xml:space="preserve">
          <source>Because transparent structs are represented exactly like one of their fields at run time, said field must be uniquely determined. If there is no field, or if there are multiple fields, it is not clear how the struct should be represented. Note that fields of zero-sized types (e.g., &lt;code&gt;PhantomData&lt;/code&gt;) can also exist alongside the field that contains the actual data, they do not count for this error. When generic types are involved (as in the above example), an error is reported because the type parameter could be non-zero-sized.</source>
          <target state="translated">투명 구조체는 런타임에 필드 중 하나와 똑같이 표현되기 때문에 해당 필드는 고유하게 결정되어야합니다. 필드가 없거나 여러 필드가있는 경우 구조체를 표현하는 방법이 명확하지 않습니다. 크기가 0 인 유형의 필드 (예 : &lt;code&gt;PhantomData&lt;/code&gt; )도 실제 데이터를 포함하는 필드와 함께 존재할 수 있으며이 오류에 포함되지 않습니다. 제네릭 유형이 관련되면 (위의 예에서와 같이) 유형 매개 변수의 크기가 0이 아닐 수 있으므로 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="986c4abde2bf1faaf2d6c694b66e22c945ede5c1" translate="yes" xml:space="preserve">
          <source>Because transparent structs are represented exactly like one of their fields at run time, said field must be uniquely determined. If there is no field, or if there are multiple fields, it is not clear how the struct should be represented. Note that fields of zero-typed types (e.g., &lt;code&gt;PhantomData&lt;/code&gt;) can also exist alongside the field that contains the actual data, they do not count for this error. When generic types are involved (as in the above example), an error is reported because the type parameter could be non-zero-sized.</source>
          <target state="translated">투명한 구조체는 런타임에 해당 필드 중 하나와 정확히 동일하게 표시되므로 해당 필드는 고유하게 결정되어야합니다. 필드가 없거나 필드가 여러 개인 경우 구조체를 어떻게 표현해야하는지 명확하지 않습니다. 유형이 0 인 유형의 필드 (예 : &lt;code&gt;PhantomData&lt;/code&gt; )도 실제 데이터가 포함 된 필드와 함께 존재할 수 있으며이 오류에 포함되지 않습니다. 일반 유형이 포함 된 경우 (위의 예에서와 같이) 유형 매개 변수의 크기가 0이 아니기 때문에 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="f937fa2c0a9f5f4a819643c4edaf58d80a839cab" translate="yes" xml:space="preserve">
          <source>Because tuple elements don't have a name, they can only be accessed by pattern-matching or by using &lt;code&gt;N&lt;/code&gt; directly as a field to access the &lt;code&gt;N&lt;/code&gt;th element.</source>
          <target state="translated">튜플 요소에는 이름이 없으므로 패턴 일치 또는 &lt;code&gt;N&lt;/code&gt; 을 필드로 직접 사용 하여 &lt;code&gt;N&lt;/code&gt; 번째 요소 에 액세스 해야만 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efb0d44a57a7bf30820d634e0cfe1255770c836f" translate="yes" xml:space="preserve">
          <source>Because two equal values need to produce the same hash value, the implementation of &lt;code&gt;Hash&lt;/code&gt; needs to ignore ASCII case, too:</source>
          <target state="translated">두 개의 동일한 값이 동일한 해시 값을 생성해야하므로 &lt;code&gt;Hash&lt;/code&gt; 구현에서는 ASCII 대 / 소문자도 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="b787dccee7a3448c9761d599ebe1a0e8e174bf88" translate="yes" xml:space="preserve">
          <source>Because types that are made up of &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; traits are automatically also &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt;, we don&amp;rsquo;t have to implement those traits manually. As marker traits, they don&amp;rsquo;t even have any methods to implement. They&amp;rsquo;re just useful for enforcing invariants related to concurrency.</source>
          <target state="translated">&lt;code&gt;Send&lt;/code&gt; 및 &lt;code&gt;Sync&lt;/code&gt; 특성으로 구성된 유형 도 자동으로 &lt;code&gt;Send&lt;/code&gt; 및 &lt;code&gt;Sync&lt;/code&gt; 이므로 이러한 특성을 수동으로 구현할 필요가 없습니다. 마커 특성으로는 구현할 메소드가 없습니다. 동시성과 관련된 불변을 적용하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e80dfd56aee472a3a988ee77f8d092b4c7dec341" translate="yes" xml:space="preserve">
          <source>Because we called the function with &lt;code&gt;5&lt;/code&gt; as the value for &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;6&lt;/code&gt; is passed as the value for &lt;code&gt;y&lt;/code&gt;, the two strings are printed with these values.</source>
          <target state="translated">우리가 함수 호출 때문에 &lt;code&gt;5&lt;/code&gt; 의 값으로 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;6&lt;/code&gt; 에 대한 값으로 전달되는 &lt;code&gt;y&lt;/code&gt; , 두 문자열은 이들 값을 출력한다.</target>
        </trans-unit>
        <trans-unit id="085b82e8e32a790482293e536266e4e46e15732c" translate="yes" xml:space="preserve">
          <source>Because we didn&amp;rsquo;t cover (and couldn&amp;rsquo;t cover!) every valid value with the pattern &lt;code&gt;Some(x)&lt;/code&gt;, Rust rightfully produces a compiler error.</source>
          <target state="translated">우리는 &lt;code&gt;Some(x)&lt;/code&gt; 패턴으로 모든 유효한 값을 커버하지 못했고 커버 할 수 없었기 때문에 Rust는 컴파일러 에러를 당연히 발생시킨다.</target>
        </trans-unit>
        <trans-unit id="c4e7a282ae038191d5b4c16b5d5eaad3c33d3637" translate="yes" xml:space="preserve">
          <source>Because we don&amp;rsquo;t have any code that pauses or delays in the &lt;code&gt;for&lt;/code&gt; loop in the main thread, we can tell that the main thread is waiting to receive values from the spawned thread.</source>
          <target state="translated">메인 스레드 의 &lt;code&gt;for&lt;/code&gt; 루프에서 일시 정지되거나 지연되는 코드가 없기 때문에 메인 스레드가 생성 된 스레드로부터 값을 받기 위해 대기 중임을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a0bac08c9a7a0c19671aaf3dbc27401041da77e" translate="yes" xml:space="preserve">
          <source>Because we don&amp;rsquo;t have any tests we&amp;rsquo;ve marked as ignored, the summary shows &lt;code&gt;0 ignored&lt;/code&gt;. We also haven&amp;rsquo;t filtered the tests being run, so the end of the summary shows &lt;code&gt;0 filtered out&lt;/code&gt;. We&amp;rsquo;ll talk about ignoring and filtering out tests in the next section, &lt;a href=&quot;ch11-02-running-tests#controlling-how-tests-are-run&quot;&gt;&amp;ldquo;Controlling How Tests Are Run.&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">무시 된 것으로 표시된 테스트가 없으므로 요약에 표시됩니다. &lt;code&gt;0 ignored&lt;/code&gt; . 또한 실행중인 테스트를 필터링하지 않았으므로 요약의 끝에 &lt;code&gt;0 filtered out&lt;/code&gt; . 다음 섹션 인 &lt;a href=&quot;ch11-02-running-tests#controlling-how-tests-are-run&quot;&gt;&quot;테스트 실행 방법 제어&quot;&lt;/a&gt; 에서 테스트를 무시하고 필터링하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="19d2af6731059978bb0fd7b94ea0d510b217b381" translate="yes" xml:space="preserve">
          <source>Because we don&amp;rsquo;t need them anymore, let&amp;rsquo;s remove the &lt;code&gt;println!&lt;/code&gt; statements from &lt;em&gt;src/lib.rs&lt;/em&gt; and &lt;em&gt;src/main.rs&lt;/em&gt; that we used to check the program&amp;rsquo;s behavior. Then, in &lt;em&gt;src/lib.rs&lt;/em&gt;, we&amp;rsquo;ll add a &lt;code&gt;tests&lt;/code&gt; module with a test function, as we did in &lt;a href=&quot;ch11-01-writing-tests#the-anatomy-of-a-test-function&quot;&gt;Chapter 11&lt;/a&gt;. The test function specifies the behavior we want the &lt;code&gt;search&lt;/code&gt; function to have: it will take a query and the text to search for the query in, and it will return only the lines from the text that contain the query. Listing 12-15 shows this test, which won&amp;rsquo;t compile yet.</source>
          <target state="translated">더 이상 필요하지 않으므로 &lt;code&gt;println!&lt;/code&gt; 제거합시다 ! &lt;em&gt;src / lib.rs&lt;/em&gt; 및 &lt;em&gt;src / main.rs&lt;/em&gt; 에서 프로그램의 동작을 확인하는 데 사용한 명령문 . 그런 다음 &lt;em&gt;src / lib.rs&lt;/em&gt; 에서 &lt;code&gt;tests&lt;/code&gt; 에서 &lt;a href=&quot;ch11-01-writing-tests#the-anatomy-of-a-test-function&quot;&gt;11 장&lt;/a&gt; 에서와 같이 테스트 기능을 가진 테스트 모듈을 입니다. 테스트 함수는 &lt;code&gt;search&lt;/code&gt; 함수 가 원하는 동작을 지정합니다 . 쿼리와 쿼리를 검색 할 텍스트를 가져오고 쿼리가 포함 된 텍스트의 행만 반환합니다. Listing 12-15는 아직 컴파일되지 않은이 테스트를 보여준다.</target>
        </trans-unit>
        <trans-unit id="27d7fc6d652236fca2f45fe08fc889c62e6d8253" translate="yes" xml:space="preserve">
          <source>Because we just mentioned coins, let&amp;rsquo;s use them as an example using &lt;code&gt;match&lt;/code&gt;! We can write a function that can take an unknown United States coin and, in a similar way as the counting machine, determine which coin it is and return its value in cents, as shown here in Listing 6-3.</source>
          <target state="translated">우리는 방금 동전을 언급 했으므로 &lt;code&gt;match&lt;/code&gt; 를 사용하여 예제로 사용합시다 ! 우리는 알 수없는 미국 동전을 취할 수있는 함수를 작성할 수 있으며, 계산 기계와 유사한 방식으로 동전의 동전을 결정하고 센트 단위로 그 값을 반환합니다 (목록 6-3 참조).</target>
        </trans-unit>
        <trans-unit id="564bbf6a7d7bf6b1e61c40462e20a2bae78026d7" translate="yes" xml:space="preserve">
          <source>Because we made the &lt;code&gt;Appetizer&lt;/code&gt; enum public, we can use the &lt;code&gt;Soup&lt;/code&gt; and &lt;code&gt;Salad&lt;/code&gt; variants in &lt;code&gt;eat_at_restaurant&lt;/code&gt;. Enums aren&amp;rsquo;t very useful unless their variants are public; it would be annoying to have to annotate all enum variants with &lt;code&gt;pub&lt;/code&gt; in every case, so the default for enum variants is to be public. Structs are often useful without their fields being public, so struct fields follow the general rule of everything being private by default unless annotated with &lt;code&gt;pub&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Appetizer&lt;/code&gt; 열거 형을 공개 했기 때문에 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 에서 &lt;code&gt;Soup&lt;/code&gt; 및 &lt;code&gt;Salad&lt;/code&gt; 변형을 사용할 수 있습니다 . 열거 형은 변형이 공개되지 않으면 유용하지 않습니다. &lt;code&gt;pub&lt;/code&gt; 모든 열거 형 변형에 주석을 달아야한다는 것은 성 가실 것입니다.모든 경우에 일이므로 열거 형 변형의 기본값은 공개입니다. Structs는 필드가 공개되지 않은 상태에서 종종 유용하므로 구조체 필드는 &lt;code&gt;pub&lt;/code&gt; 로 주석을 달지 않는 한 기본적으로 모든 것이 개인의 일반 규칙을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="e429697f925edbd87724bb6af67eea48f644c38e" translate="yes" xml:space="preserve">
          <source>Because we need to go through the &lt;code&gt;String&lt;/code&gt; element by element and check whether a value is a space, we&amp;rsquo;ll convert our &lt;code&gt;String&lt;/code&gt; to an array of bytes using the &lt;code&gt;as_bytes&lt;/code&gt; method:</source>
          <target state="translated">우리가 통과해야하기 때문에 &lt;code&gt;String&lt;/code&gt; 요소에 의해 요소와 값에 공백이 있는지 여부를 확인, 우리는 우리의 변환합니다 &lt;code&gt;String&lt;/code&gt; 를 사용하는 바이트의 배열 &lt;code&gt;as_bytes&lt;/code&gt; 의 방법 :</target>
        </trans-unit>
        <trans-unit id="78563068540adbc0f963cccfafb7b2fef86f3a05" translate="yes" xml:space="preserve">
          <source>Because we&amp;rsquo;ve encapsulated the implementation details of the struct &lt;code&gt;AveragedCollection&lt;/code&gt;, we can easily change aspects, such as the data structure, in the future. For instance, we could use a &lt;code&gt;HashSet&amp;lt;i32&amp;gt;&lt;/code&gt; instead of a &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; for the &lt;code&gt;list&lt;/code&gt; field. As long as the signatures of the &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;average&lt;/code&gt; public methods stay the same, code using &lt;code&gt;AveragedCollection&lt;/code&gt; wouldn&amp;rsquo;t need to change. If we made &lt;code&gt;list&lt;/code&gt; public instead, this wouldn&amp;rsquo;t necessarily be the case: &lt;code&gt;HashSet&amp;lt;i32&amp;gt;&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; have different methods for adding and removing items, so the external code would likely have to change if it were modifying &lt;code&gt;list&lt;/code&gt; directly.</source>
          <target state="translated">구조체 &lt;code&gt;AveragedCollection&lt;/code&gt; 의 구현 세부 사항을 캡슐화 했으므로 향후 데이터 구조와 같은 측면을 쉽게 변경할 수 있습니다. 예를 들어, 우리는 사용할 수 &lt;code&gt;HashSet&amp;lt;i32&amp;gt;&lt;/code&gt; 대신의 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 에 대한 &lt;code&gt;list&lt;/code&gt; 필드. &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; 및 &lt;code&gt;average&lt;/code&gt; 공용 메소드 의 서명이 동일하게 유지되는 한 &lt;code&gt;AveragedCollection&lt;/code&gt; 을 사용하는 코드 는 변경할 필요가 없습니다. 우리가 대신 &lt;code&gt;list&lt;/code&gt; 공개 했다면 , 반드시 그런 것은 아닙니다. &lt;code&gt;HashSet&amp;lt;i32&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 항목을 추가하고 제거하는 다른 방법이 있으므로 &lt;code&gt;list&lt;/code&gt; 직접 수정하는 경우 외부 코드를 변경해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="012f083807416b28f83d8847eef6766da2f64d4c" translate="yes" xml:space="preserve">
          <source>Because we&amp;rsquo;ve given initial &lt;code&gt;i32&lt;/code&gt; values, Rust can infer that the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt;, and the type annotation isn&amp;rsquo;t necessary. Next, we&amp;rsquo;ll look at how to modify a vector.</source>
          <target state="translated">초기 &lt;code&gt;i32&lt;/code&gt; 값을 제공 했으므로 Rust는 &lt;code&gt;v&lt;/code&gt; 유형 이 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 이며 유 형 주석이 필요하지 않은 것으로 추론 할 수 있습니다 . 다음으로 벡터를 수정하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="9fe6f6ecc3242b6ec15902f2774b2a48334d7481" translate="yes" xml:space="preserve">
          <source>Because we&amp;rsquo;ve specified that &lt;code&gt;OutlinePrint&lt;/code&gt; requires the &lt;code&gt;Display&lt;/code&gt; trait, we can use the &lt;code&gt;to_string&lt;/code&gt; function that is automatically implemented for any type that implements &lt;code&gt;Display&lt;/code&gt;. If we tried to use &lt;code&gt;to_string&lt;/code&gt; without adding a colon and specifying the &lt;code&gt;Display&lt;/code&gt; trait after the trait name, we&amp;rsquo;d get an error saying that no method named &lt;code&gt;to_string&lt;/code&gt; was found for the type &lt;code&gt;&amp;amp;Self&lt;/code&gt; in the current scope.</source>
          <target state="translated">우리가 있음을 지정한 때문에 &lt;code&gt;OutlinePrint&lt;/code&gt; 이 필요 &lt;code&gt;Display&lt;/code&gt; 특성을, 우리는 사용할 수 &lt;code&gt;to_string&lt;/code&gt; 의 자동 구현이 있음을 모든 유형의 구현 기능 &lt;code&gt;Display&lt;/code&gt; . 콜론을 추가하지 않고 특성 이름 뒤에 &lt;code&gt;Display&lt;/code&gt; 특성을 지정하지 않고 &lt;code&gt;to_string&lt;/code&gt; 을 사용하려고 하면 현재 범위의 &lt;code&gt;&amp;amp;Self&lt;/code&gt; 유형에 대해 &lt;code&gt;to_string&lt;/code&gt; 이라는 메소드 를 찾을 수 없다는 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="627748e661f805aeaed04a41d6aadf854f4f0452" translate="yes" xml:space="preserve">
          <source>Because we're not buffering, we write each one in turn, incurring the overhead of a system call per byte written. We can fix this with a &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">버퍼링이 아니기 때문에 각각을 차례로 작성하여 쓴 바이트 당 시스템 호출의 오버 헤드를 발생시킵니다. &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt; 로이 문제를 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a715fdf861e47ef758515cd362976557a262f981" translate="yes" xml:space="preserve">
          <source>Because we're not buffering, we write each one in turn, incurring the overhead of a system call per byte written. We can fix this with a &lt;code&gt;BufWriter&lt;/code&gt;:</source>
          <target state="translated">우리는 버퍼링을하지 않기 때문에 각 바이트마다 차례로 시스템 호출의 오버 헤드를 발생시켜 각각을 작성합니다. 우리는 이것을 &lt;code&gt;BufWriter&lt;/code&gt; 로 고칠 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cbd558490c4d9352a7af3024ff9549f8d11edc55" translate="yes" xml:space="preserve">
          <source>Because you can stack-allocate a &lt;code&gt;[u8; N]&lt;/code&gt;, and you can take a &lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt; of it, this function is one way to have a stack-allocated string. There is an example of this in the examples section below.</source>
          <target state="translated">당신이 할 수 있기 때문에 스택 - 할당 &lt;code&gt;[u8; N]&lt;/code&gt; , 당신은 걸릴 수 있습니다&lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt; 이 함수는 스택 할당 문자열을 갖는 한 가지 방법입니다. 아래 예제 섹션에 이에 대한 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="abb004f87792d4a102d3232d143d81ed4ffc2ed8" translate="yes" xml:space="preserve">
          <source>Before an expression used as a &lt;a href=&quot;statements&quot;&gt;statement&lt;/a&gt;.</source>
          <target state="translated">A와 사용되는 표현하기 전에 &lt;a href=&quot;statements&quot;&gt;문&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6fb622789c9cc297dc766f85b7b47e7c5b64a4c2" translate="yes" xml:space="preserve">
          <source>Before diving into generics syntax, let&amp;rsquo;s first look at how to remove duplication that doesn&amp;rsquo;t involve generic types by extracting a function. Then we&amp;rsquo;ll apply this technique to extract a generic function! In the same way that you recognize duplicated code to extract into a function, you&amp;rsquo;ll start to recognize duplicated code that can use generics.</source>
          <target state="translated">제네릭 구문으로 들어가기 전에 먼저 함수를 추출하여 제네릭 형식과 관련이없는 중복을 제거하는 방법을 살펴 보겠습니다. 그런 다음이 기술을 적용하여 일반 함수를 추출합니다! 함수로 추출하기 위해 중복 된 코드를 인식하는 것과 같은 방식으로 제네릭을 사용할 수있는 중복 된 코드를 인식하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="beaf5bffc2c85ad951a60c9ddac3eebe2cec9b8f" translate="yes" xml:space="preserve">
          <source>Before explaining more, let's talk about how this module is structured:</source>
          <target state="translated">자세한 내용을 설명하기 전에이 모듈의 구성 방식에 대해 이야기 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="cd09ad07440aee110c115ad35adea181d0515ee9" translate="yes" xml:space="preserve">
          <source>Before running a Rust program, you must compile it using the Rust compiler by entering the &lt;code&gt;rustc&lt;/code&gt; command and passing it the name of your source file, like this:</source>
          <target state="translated">Rust 프로그램을 실행하기 전에 &lt;code&gt;rustc&lt;/code&gt; 를 입력하여 Rust 컴파일러를 사용하여 컴파일해야합니다 명령 과 같이 소스 파일 이름을 전달 .</target>
        </trans-unit>
        <trans-unit id="992020b016b482ffafd2657fccaa8d509f2063e9" translate="yes" xml:space="preserve">
          <source>Before the loop, we declare a variable named &lt;code&gt;counter&lt;/code&gt; and initialize it to &lt;code&gt;0&lt;/code&gt;. Then we declare a variable named &lt;code&gt;result&lt;/code&gt; to hold the value returned from the loop. On every iteration of the loop, we add &lt;code&gt;1&lt;/code&gt; to the &lt;code&gt;counter&lt;/code&gt; variable, and then check whether the counter is equal to &lt;code&gt;10&lt;/code&gt;. When it is, we use the &lt;code&gt;break&lt;/code&gt; keyword with the value &lt;code&gt;counter * 2&lt;/code&gt;. After the loop, we use a semicolon to end the statement that assigns the value to &lt;code&gt;result&lt;/code&gt;. Finally, we print the value in &lt;code&gt;result&lt;/code&gt;, which in this case is 20.</source>
          <target state="translated">루프 전에 &lt;code&gt;counter&lt;/code&gt; 라는 변수를 선언하고 &lt;code&gt;0&lt;/code&gt; 으로 초기화합니다 . 그런 다음 루프에서 반환 된 값을 보유하도록 &lt;code&gt;result&lt;/code&gt; 라는 변수를 선언합니다 . 루프가 반복 될 때마다 &lt;code&gt;counter&lt;/code&gt; 변수 에 &lt;code&gt;1&lt;/code&gt; 을 더한 다음 카운터가 &lt;code&gt;10&lt;/code&gt; 인지 확인합니다 . 그렇다면 &lt;code&gt;break&lt;/code&gt; 키워드를 값 &lt;code&gt;counter * 2&lt;/code&gt; 와 함께 사용합니다 . 루프 후, 세미콜론을 사용하여 &lt;code&gt;result&lt;/code&gt; 값을 할당하는 명령문을 종료합니다 . 마지막으로 &lt;code&gt;result&lt;/code&gt; 값을 출력합니다 .이 경우 20입니다.</target>
        </trans-unit>
        <trans-unit id="31a496e8ed09fdd1bd621c7cc15fdcecbd8eebc7" translate="yes" xml:space="preserve">
          <source>Before we begin implementing a thread pool, let&amp;rsquo;s talk about what using the pool should look like. When you&amp;rsquo;re trying to design code, writing the client interface first can help guide your design. Write the API of the code so it&amp;rsquo;s structured in the way you want to call it; then implement the functionality within that structure rather than implementing the functionality and then designing the public API.</source>
          <target state="translated">스레드 풀 구현을 시작하기 전에 풀 사용의 모양에 대해 이야기하겠습니다. 코드를 디자인하려고 할 때 먼저 클라이언트 인터페이스를 작성하면 디자인을 안내하는 데 도움이 될 수 있습니다. 코드의 API를 작성하여 원하는 방식으로 구성하십시오. 그런 다음 기능을 구현 한 다음 공개 API를 디자인하는 대신 해당 구조 내에서 기능을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="5531bdacd5e27e11cff8fcc2e36e3c004527f8b8" translate="yes" xml:space="preserve">
          <source>Before we discuss this use case for &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, we&amp;rsquo;ll cover the syntax and how to interact with values stored within a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 사용 사례를 논의하기 전에 구문과 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 내에 저장된 값과 상호 작용하는 방법을 다룰 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d85d751d3cdedcf3deebd350f36e7cb28a00a5d2" translate="yes" xml:space="preserve">
          <source>Before we go into more details to explain the guarantees and choices associated with &lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt;, we discuss some examples for how it might be used. Feel free to &lt;a href=&quot;#drop-guarantee&quot;&gt;skip to where the theoretical discussion continues&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; 과 관련된 보증 및 선택 사항을 설명하기 위해 더 자세히 설명하기 전에 사용 방법에 대한 몇 가지 예를 논의합니다. &lt;a href=&quot;#drop-guarantee&quot;&gt;이론적 토론이 계속되는 곳&lt;/a&gt; 으로 건너 뛰어도됩니다 .</target>
        </trans-unit>
        <trans-unit id="1e5cb50dd4a282df49da6b5ffaeda1d9ab676ba8" translate="yes" xml:space="preserve">
          <source>Before you can publish any crates, you need to create an account on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; and get an API token. To do so, visit the home page at &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; and log in via a GitHub account. (The GitHub account is currently a requirement, but the site might support other ways of creating an account in the future.) Once you&amp;rsquo;re logged in, visit your account settings at &lt;a href=&quot;https://crates.io/me/&quot;&gt;https://crates.io/me/&lt;/a&gt; and retrieve your API key. Then run the &lt;code&gt;cargo login&lt;/code&gt; command with your API key, like this:</source>
          <target state="translated">상자를 게시하기 전에 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io에&lt;/a&gt; 계정을 만들고 API 토큰 을 가져와야 합니다. 이렇게하려면 홈페이지 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io를&lt;/a&gt; 방문하여 GitHub 계정을 통해 로그인 하십시오 . (GitHub 계정은 현재 요구 사항이지만 사이트는 나중에 계정을 만드는 다른 방법을 지원할 수 있습니다.) 로그인 한 후 &lt;a href=&quot;https://crates.io/me/&quot;&gt;https://crates.io/me/&lt;/a&gt; 에서 계정 설정을 방문 하여 API 키. 그런 다음 API 키로 다음과 같이 &lt;code&gt;cargo login&lt;/code&gt; 명령을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="842beb51ca9c5417a27f472386d0e0d52dcc074f" translate="yes" xml:space="preserve">
          <source>Before:</source>
          <target state="translated">Before:</target>
        </trans-unit>
        <trans-unit id="bb11daf93347e89962e3d0ed85d6b809ec3ab729" translate="yes" xml:space="preserve">
          <source>Beginning in the 2018 edition, &lt;a href=&quot;use-declarations&quot;&gt;use declarations&lt;/a&gt; can reference crates in the extern prelude, so it is considered unidiomatic to use &lt;code&gt;extern crate&lt;/code&gt;.</source>
          <target state="translated">2018 버전부터 &lt;a href=&quot;use-declarations&quot;&gt;사용 선언&lt;/a&gt; 은 extern prelude에서 상자를 참조 할 수 있으므로 &lt;code&gt;extern crate&lt;/code&gt; 를 사용하는 것은 단오적인 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="f69c63a9aa10f7772ed95a8efc915f42e685135b" translate="yes" xml:space="preserve">
          <source>Beginning in the 2018 edition, &lt;code&gt;dyn&lt;/code&gt; has been promoted to a strict keyword.</source>
          <target state="translated">2018 년 초부터 &lt;code&gt;dyn&lt;/code&gt; 은 엄격한 키워드로 승격되었습니다.</target>
        </trans-unit>
        <trans-unit id="747fb066bbb4af54f78aaa8f212256984b77092b" translate="yes" xml:space="preserve">
          <source>Beginning in the 2018 edition, &lt;code&gt;dyn&lt;/code&gt; is a true keyword and is not allowed in paths, so the parentheses are not necessary.</source>
          <target state="translated">2018 년판부터 &lt;code&gt;dyn&lt;/code&gt; 은 진정한 키워드이며 경로에 사용할 수 없으므로 괄호가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="88113dc243c443e4dd51d39dc5f37a435a2966eb" translate="yes" xml:space="preserve">
          <source>Beginning in the 2018 edition, function or method parameter patterns are no longer optional. Also, all irrefutable patterns are allowed as long as there is a body. Without a body, the limitations listed above are still in effect.</source>
          <target state="translated">2018 년판부터 기능 또는 분석법 매개 변수 패턴은 더 이상 선택 사항이 아닙니다. 또한 신체가있는 한 반박 할 수없는 모든 패턴이 허용됩니다. 본문이 없으면 위에 나열된 제한 사항이 여전히 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="72201b43a6b1623bf8606d5ddd5bead0602a3d00" translate="yes" xml:space="preserve">
          <source>Beginning with the 2018 Edition, paths starting with &lt;code&gt;::&lt;/code&gt; can only reference crates.</source>
          <target state="translated">2018 년판부터 &lt;code&gt;::&lt;/code&gt; 로 시작하는 경로 는 상자 만 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="020cfc8d7ce4473da0deda931f3cf2410d4b4068" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the contents are set to zero before being returned.</source>
          <target state="translated">&lt;code&gt;alloc&lt;/code&gt; 처럼 작동 하지만 반환되기 전에 내용이 0으로 설정되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="26b6dab3100989fb3cbafd53582c862ac5c9f9f9" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the contents are set to zero before being returned. &lt;a href=&quot;trait.alloc#method.alloc_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;alloc&lt;/code&gt; 처럼 작동 하지만 반환되기 전에 내용이 0으로 설정되어 있는지 확인합니다. &lt;a href=&quot;trait.alloc#method.alloc_zeroed&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cebb7ac8ceac00cf4605e1537d21a42ae0a8334d" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the contents are set to zero before being returned. &lt;a href=&quot;trait.globalalloc#method.alloc_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;alloc&lt;/code&gt; 처럼 작동 하지만 반환되기 전에 내용이 0으로 설정되어 있는지 확인합니다. &lt;a href=&quot;trait.globalalloc#method.alloc_zeroed&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e653935f1fa40764a2f934dcfa1f795f0a0636d1" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the returned memory is zero-initialized.</source>
          <target state="translated">&lt;code&gt;alloc&lt;/code&gt; 처럼 동작 하지만 반환 된 메모리가 0으로 초기화되도록합니다.</target>
        </trans-unit>
        <trans-unit id="082a664b538f66f0a51ac4134a98aba6f77d5cde" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the returned memory is zero-initialized. &lt;a href=&quot;alloc/trait.allocref#method.alloc_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;alloc&lt;/code&gt; 처럼 동작 하지만 반환 된 메모리가 0으로 초기화되도록합니다. &lt;a href=&quot;alloc/trait.allocref#method.alloc_zeroed&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be234e6a7de7bb5e73ad2c0df1090886fa61a11b" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the returned memory is zero-initialized. &lt;a href=&quot;trait.allocref#method.alloc_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;alloc&lt;/code&gt; 처럼 동작 하지만 반환 된 메모리가 0으로 초기화되도록합니다. &lt;a href=&quot;trait.allocref#method.alloc_zeroed&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="16853ad48a342bbd03514f294c9cb5b40dbdc15d" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also returns the whole size of the returned block. For some &lt;code&gt;layout&lt;/code&gt; inputs, like arrays, this may include extra storage usable for additional data.</source>
          <target state="translated">&lt;code&gt;alloc&lt;/code&gt; 처럼 동작 하지만 반환 된 블록의 전체 크기도 반환합니다. 어레이와 같은 일부 &lt;code&gt;layout&lt;/code&gt; 입력의 경우 추가 데이터에 사용할 수있는 추가 스토리지가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40c1d1b115b0d7d4586e89d6b5493bd9bd25a35d" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also returns the whole size of the returned block. For some &lt;code&gt;layout&lt;/code&gt; inputs, like arrays, this may include extra storage usable for additional data. &lt;a href=&quot;trait.alloc#method.alloc_excess&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;alloc&lt;/code&gt; 처럼 동작 하지만 반환 된 블록의 전체 크기도 반환합니다. 어레이와 같은 일부 &lt;code&gt;layout&lt;/code&gt; 입력의 경우 추가 데이터에 사용할 수있는 추가 스토리지가 포함될 수 있습니다. &lt;a href=&quot;trait.alloc#method.alloc_excess&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e2179173aab44374db1b01f282be73f03846d7f" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;allocate&lt;/code&gt;, but also ensures that the returned memory is zero-initialized.</source>
          <target state="translated">&lt;code&gt;allocate&lt;/code&gt; 처럼 동작 하지만 반환 된 메모리가 0으로 초기화되도록합니다.</target>
        </trans-unit>
        <trans-unit id="96a2513654f4015a77e125e9a50451e03d6371d9" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;allocate&lt;/code&gt;, but also ensures that the returned memory is zero-initialized. &lt;a href=&quot;alloc/trait.allocator#method.allocate_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;allocate&lt;/code&gt; 처럼 동작 하지만 반환 된 메모리가 0으로 초기화되도록합니다. &lt;a href=&quot;alloc/trait.allocator#method.allocate_zeroed&quot;&gt;더 많은 것을 읽으십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb8d63977cd22736576846575120dedadc2c07c4" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;allocate&lt;/code&gt;, but also ensures that the returned memory is zero-initialized. &lt;a href=&quot;trait.allocator#method.allocate_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;allocate&lt;/code&gt; 처럼 동작 하지만 반환 된 메모리가 0으로 초기화되도록합니다. &lt;a href=&quot;trait.allocator#method.allocate_zeroed&quot;&gt;더 많은 것을 읽으십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="43a391a0a4b347a23ddcc04fdba39ef2f889911c" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;grow&lt;/code&gt;, but also ensures that the new contents are set to zero before being returned.</source>
          <target state="translated">&lt;code&gt;grow&lt;/code&gt; 처럼 동작 하지만 반환되기 전에 새 콘텐츠가 0으로 설정되도록합니다.</target>
        </trans-unit>
        <trans-unit id="27028f3e8d3b71893211313af49a0378a2b4d868" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;grow&lt;/code&gt;, but also ensures that the new contents are set to zero before being returned. &lt;a href=&quot;alloc/trait.allocator#method.grow_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;grow&lt;/code&gt; 처럼 동작 하지만 반환되기 전에 새 콘텐츠가 0으로 설정되도록합니다. &lt;a href=&quot;alloc/trait.allocator#method.grow_zeroed&quot;&gt;더 많은 것을 읽으십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dcc5bb4de65f26b5cfc9c0d306890b6a3dfd8426" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;grow&lt;/code&gt;, but also ensures that the new contents are set to zero before being returned. &lt;a href=&quot;alloc/trait.allocref#method.grow_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;grow&lt;/code&gt; 처럼 동작 하지만 반환되기 전에 새 콘텐츠가 0으로 설정되도록합니다. &lt;a href=&quot;alloc/trait.allocref#method.grow_zeroed&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="744e0952faceb3c028105041422c82f4480ac4f5" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;grow&lt;/code&gt;, but also ensures that the new contents are set to zero before being returned. &lt;a href=&quot;trait.allocator#method.grow_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;grow&lt;/code&gt; 처럼 동작 하지만 반환되기 전에 새 콘텐츠가 0으로 설정되도록합니다. &lt;a href=&quot;trait.allocator#method.grow_zeroed&quot;&gt;더 많은 것을 읽으십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b00b17315ce422677165dd747a2622a3bae967c2" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;grow&lt;/code&gt;, but also ensures that the new contents are set to zero before being returned. &lt;a href=&quot;trait.allocref#method.grow_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;grow&lt;/code&gt; 처럼 동작 하지만 반환되기 전에 새 콘텐츠가 0으로 설정되도록합니다. &lt;a href=&quot;trait.allocref#method.grow_zeroed&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6dee35b4dc6dfa21486bfd27863270c134037f5" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;realloc&lt;/code&gt;, but also returns the whole size of the returned block. For some &lt;code&gt;layout&lt;/code&gt; inputs, like arrays, this may include extra storage usable for additional data.</source>
          <target state="translated">&lt;code&gt;realloc&lt;/code&gt; 과 같이 작동 하지만 반환 된 블록의 전체 크기도 반환합니다. 어레이와 같은 일부 &lt;code&gt;layout&lt;/code&gt; 입력의 경우 추가 데이터에 사용할 수있는 추가 스토리지가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c12028831748d6fe621f72695ab145b2de0f2ea6" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;realloc&lt;/code&gt;, but also returns the whole size of the returned block. For some &lt;code&gt;layout&lt;/code&gt; inputs, like arrays, this may include extra storage usable for additional data. &lt;a href=&quot;trait.alloc#method.realloc_excess&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;realloc&lt;/code&gt; 과 같이 작동 하지만 반환 된 블록의 전체 크기도 반환합니다. 어레이와 같은 일부 &lt;code&gt;layout&lt;/code&gt; 입력의 경우 추가 데이터에 사용할 수있는 추가 스토리지가 포함될 수 있습니다. &lt;a href=&quot;trait.alloc#method.realloc_excess&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="70cb647a88bd7c9c17d225eecdaf0f898261eb60" translate="yes" xml:space="preserve">
          <source>Behavior</source>
          <target state="translated">Behavior</target>
        </trans-unit>
        <trans-unit id="095fb761bd6565ed9b50c488d53be7f174ad6258" translate="yes" xml:space="preserve">
          <source>Behavior considered undefined</source>
          <target state="translated">행동은 정의되지 않은 것으로 간주</target>
        </trans-unit>
        <trans-unit id="387f0e642c525f9f6e8bb2a3ac2dfb1f45db317b" translate="yes" xml:space="preserve">
          <source>Behavior during const evaluation</source>
          <target state="translated">const 평가 중 동작</target>
        </trans-unit>
        <trans-unit id="b1544a3801fc2d10e0c4fa2700cbde205e380188" translate="yes" xml:space="preserve">
          <source>Behavior is undefined if any of the following conditions are violated:</source>
          <target state="translated">다음 조건 중 하나라도 위반하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d1d94b77ecaf322c48c942eb7769975f61f7e1b" translate="yes" xml:space="preserve">
          <source>Behavior not considered &lt;code id=&quot;behavior-not-considered-unsafe&quot;&gt;unsafe&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;behavior-not-considered-unsafe&quot;&gt;unsafe&lt;/code&gt; 않은 것으로 간주되는 행동</target>
        </trans-unit>
        <trans-unit id="3c89d307ed32970842af58f6e49fccbe4976a8de" translate="yes" xml:space="preserve">
          <source>Behavior not considered &lt;code&gt;unsafe&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 않은 것으로 간주되는 동작</target>
        </trans-unit>
        <trans-unit id="56466d174610967ccd7c4e4d2f8e7fb575e6e68b" translate="yes" xml:space="preserve">
          <source>Being unable to change the value of a variable might have reminded you of another programming concept that most other languages have: &lt;em&gt;constants&lt;/em&gt;. Like immutable variables, constants are values that are bound to a name and are not allowed to change, but there are a few differences between constants and variables.</source>
          <target state="translated">: 변수의 값을 변경할 수 없습니다 있다는 것은 대부분의 다른 언어를 가지고 다른 프로그래밍 개념의 당신을 생각 나게 수도 &lt;em&gt;상수&lt;/em&gt; . 불변 변수와 마찬가지로 상수는 이름에 바인딩되어 변경할 수없는 값이지만 상수와 변수에는 약간의 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b1f5f4233d209308eb232700a1ebe15446b03df" translate="yes" xml:space="preserve">
          <source>Believe it or not, there is much more to learn on the topics we discussed in this chapter: Chapter 17 discusses trait objects, which are another way to use traits. Chapter 19 covers more complex scenarios involving lifetime annotations as well as some advanced type system features. But next, you&amp;rsquo;ll learn how to write tests in Rust so you can make sure your code is working the way it should.</source>
          <target state="translated">믿거 나 말거나,이 장에서 논의한 주제에 대해 더 많은 것을 배울 수 있습니다. 17 장에서는 특성을 사용하는 또 다른 방법 인 특성 개체에 대해 설명합니다. 19 장은 평생 주석 및 일부 고급 유형 시스템 기능과 관련된보다 복잡한 시나리오를 다룹니다. 그러나 다음으로 Rust에서 테스트를 작성하는 방법을 배우고 코드가 정상적으로 작동하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58b3731b9aba86dccac77d4faa0d50972846f846" translate="yes" xml:space="preserve">
          <source>Believe it or not, there is much more to learn on the topics we discussed in this chapter: Chapter 17 discusses trait objects, which are another way to use traits. There are also more complex scenarios involving lifetime annotations that you will only need in very advanced scenarios; for those, you should read the &lt;a href=&quot;../reference/index&quot;&gt;Rust Reference&lt;/a&gt;. But next, you&amp;rsquo;ll learn how to write tests in Rust so you can make sure your code is working the way it should.</source>
          <target state="translated">믿거 나 말거나,이 장에서 논의한 주제에 대해 배울 것이 훨씬 더 많습니다. 17 장은 특성을 사용하는 또 다른 방법 인 특성 객체에 대해 설명합니다. 또한 매우 고급 시나리오에서만 필요한 수명 주석과 관련된 더 복잡한 시나리오가 있습니다. 이를 위해서는 &lt;a href=&quot;../reference/index&quot;&gt;Rust Reference를&lt;/a&gt; 읽어야합니다 . 하지만 다음으로 Rust로 테스트를 작성하는 방법을 배우고 코드가 제대로 작동하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d677fae0ad7b93321bdf5902d4670326f019ecfb" translate="yes" xml:space="preserve">
          <source>Below are formal inductive definitions for FIRST and LAST.</source>
          <target state="translated">다음은 FIRST 및 LAST에 대한 공식적인 귀납적 정의입니다.</target>
        </trans-unit>
        <trans-unit id="9aa1c322ef5127bad20114a3c08180f48d6a1ff0" translate="yes" xml:space="preserve">
          <source>Below are some examples of FIRST and LAST. (Note in particular how the special &amp;epsilon; element is introduced and eliminated based on the interaction between the pieces of the input.)</source>
          <target state="translated">다음은 FIRST 및 LAST의 일부 예입니다. (특히 입력 요소 간의 상호 작용을 기반으로 특수 &amp;epsilon; 요소를 도입하고 제거하는 방법에 유의하십시오.)</target>
        </trans-unit>
        <trans-unit id="7b50be87542e5985746393609c4b0d26c14c49a1" translate="yes" xml:space="preserve">
          <source>Below is an example that shows under what conditions the compiler keeps a &lt;code&gt;static&lt;/code&gt; item in the output object file.</source>
          <target state="translated">아래는 컴파일러가 어떤 조건 에서 출력 객체 파일에 &lt;code&gt;static&lt;/code&gt; 항목을 유지하는지 보여주는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="1aa487609f84f4a503144112602dbfe1aef5f203" translate="yes" xml:space="preserve">
          <source>Below is shown a &lt;code&gt;panic_handler&lt;/code&gt; function that logs the panic message and then halts the thread.</source>
          <target state="translated">다음은 패닉 메시지를 기록한 다음 스레드를 정지 시키는 &lt;code&gt;panic_handler&lt;/code&gt; 함수입니다.</target>
        </trans-unit>
        <trans-unit id="2a2f598979a5de21d86b57d75eda1c3bfc34d2c7" translate="yes" xml:space="preserve">
          <source>Besides basic data types, the standard library is largely concerned with abstracting over differences in common platforms, most notably Windows and Unix derivatives.</source>
          <target state="translated">기본 데이터 유형 외에도 표준 라이브러리는 공통 플랫폼, 특히 Windows 및 Unix 파생 상품의 차이점에 대한 추상화와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f03b60f7e52b7ce49ed1e4f9fa511c452a2185bb" translate="yes" xml:space="preserve">
          <source>Beta</source>
          <target state="translated">Beta</target>
        </trans-unit>
        <trans-unit id="234f044b4bf52384fd2873935962aa4a005b114a" translate="yes" xml:space="preserve">
          <source>Beyond that, there are two important traits that are provided: &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.bufread&quot;&gt;&lt;code&gt;BufRead&lt;/code&gt;&lt;/a&gt;. Both of these build on top of a reader to control how the reading happens. &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; lets you control where the next byte is coming from:</source>
          <target state="translated">그 외에도 &lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;trait.bufread&quot;&gt; &lt;code&gt;BufRead&lt;/code&gt; &lt;/a&gt; 라는 두 가지 중요한 특성이 제공됩니다 . 이 두 가지 모두 판독 방식을 기반으로 판독 방식을 제어합니다. &lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; 를&lt;/a&gt; 사용하면 다음 바이트의 출처를 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66639f7d455dd71faa9147f5d69e5ce885d8bebd" translate="yes" xml:space="preserve">
          <source>Binary</source>
          <target state="translated">Binary</target>
        </trans-unit>
        <trans-unit id="528a653c1337877f018509c599539f6092a1c73c" translate="yes" xml:space="preserve">
          <source>Binary integer</source>
          <target state="translated">이진 정수</target>
        </trans-unit>
        <trans-unit id="c45c03039baf74ccb71d2cd15ae8c1ec54d6c3fc" translate="yes" xml:space="preserve">
          <source>Binary operator expressions (&lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;&lt;em&gt;ArithmeticOrLogicalExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;&lt;em&gt;ComparisonExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;&lt;em&gt;LazyBooleanExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;&lt;em&gt;TypeCastExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;&lt;em&gt;AssignmentExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;&lt;em&gt;CompoundAssignmentExpression&lt;/em&gt;&lt;/a&gt;).</source>
          <target state="translated">이진 연산자 표현식 ( &lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;&lt;em&gt;ArithmeticOrLogicalExpression&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;&lt;em&gt;ComparisonExpression&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;&lt;em&gt;LazyBooleanExpression&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;&lt;em&gt;TypeCastExpression&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;&lt;em&gt;AssignmentExpression&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;&lt;em&gt;CompoundAssignmentExpression&lt;/em&gt;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="19f576ed80d6aac8fef3b9d639229b5cf1b86087" translate="yes" xml:space="preserve">
          <source>Binary operators expressions are all written with infix notation. This table summarizes the behavior of arithmetic and logical binary operators on primitive types and which traits are used to overload these operators for other types. Remember that signed integers are always represented using two's complement. The operands of all of these operators are evaluated in &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression context&lt;/a&gt; so are moved or copied.</source>
          <target state="translated">이진 연산자 식은 모두 중위 표기법으로 작성됩니다. 이 표는 기본 유형에 대한 산술 및 논리 이진 연산자의 동작과 다른 유형에 대해 이러한 연산자를 오버로드하는 데 사용되는 특성을 요약합니다. 부호있는 정수는 항상 2의 보수를 사용하여 표현됩니다. 이러한 모든 연산자의 피연산자는 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;값 표현식 컨텍스트&lt;/a&gt; 에서 평가 되므로 이동하거나 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="b6f95426a2cf8937585653a08dca6cfe16953252" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted &lt;code&gt;VecDeque&lt;/code&gt; for a given element.</source>
          <target state="translated">Binary는이 정렬 된 &lt;code&gt;VecDeque&lt;/code&gt; 에서 주어진 요소를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="8777ed96f02081635aa44ae43b6a05d44029601f" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted &lt;code&gt;VecDeque&lt;/code&gt; with a comparator function.</source>
          <target state="translated">Binary 는 비교기 함수를 사용 하여이 정렬 된 &lt;code&gt;VecDeque&lt;/code&gt; 를 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="7f6d0c15889ade3f758276e9309a88e8f0daaa91" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted &lt;code&gt;VecDeque&lt;/code&gt; with a key extraction function.</source>
          <target state="translated">Binary 는 키 추출 기능을 사용 하여이 정렬 된 &lt;code&gt;VecDeque&lt;/code&gt; 를 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="bb24e7a177053effeaa97b02e6e1d53bea903394" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted slice for a given element.</source>
          <target state="translated">이진은이 정렬 된 슬라이스에서 주어진 요소를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="342759ca0bc54fef96ecf37bc0ddadb9e9d73749" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted slice with a comparator function.</source>
          <target state="translated">이진법은이 정렬 된 슬라이스를 비교기 기능으로 검색합니다.</target>
        </trans-unit>
        <trans-unit id="7bc8abd5fd12b3c23822c666fc1626829d2282bf" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted slice with a key extraction function.</source>
          <target state="translated">이진은이 추출 된 슬라이스를 키 추출 기능으로 검색합니다.</target>
        </trans-unit>
        <trans-unit id="0f756fdf55ff6fbf54d5489a870831d4c60ffda7" translate="yes" xml:space="preserve">
          <source>Binary::fmt</source>
          <target state="translated">Binary::fmt</target>
        </trans-unit>
        <trans-unit id="f4b68b2fab22d221207f75497f220c953edad9fd" translate="yes" xml:space="preserve">
          <source>BinaryHeap</source>
          <target state="translated">BinaryHeap</target>
        </trans-unit>
        <trans-unit id="dacf4e220750a1b0f951db1cac365b1b687b357f" translate="yes" xml:space="preserve">
          <source>BinaryHeap::append</source>
          <target state="translated">BinaryHeap::append</target>
        </trans-unit>
        <trans-unit id="237581b8c07d3a6f7c2056bca73d832b0ff9b185" translate="yes" xml:space="preserve">
          <source>BinaryHeap::borrow</source>
          <target state="translated">BinaryHeap::borrow</target>
        </trans-unit>
        <trans-unit id="6cc1c3995d6cbe9775c025f1c009843f3a795e95" translate="yes" xml:space="preserve">
          <source>BinaryHeap::borrow_mut</source>
          <target state="translated">BinaryHeap::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ea651796c70f924cd09768869629d83a528f3966" translate="yes" xml:space="preserve">
          <source>BinaryHeap::capacity</source>
          <target state="translated">BinaryHeap::capacity</target>
        </trans-unit>
        <trans-unit id="4db927bbac3d9fd9afcc396f05abd8a6d2369849" translate="yes" xml:space="preserve">
          <source>BinaryHeap::clear</source>
          <target state="translated">BinaryHeap::clear</target>
        </trans-unit>
        <trans-unit id="44380118a5aafd372e4d29c4729fc27883446a63" translate="yes" xml:space="preserve">
          <source>BinaryHeap::clone</source>
          <target state="translated">BinaryHeap::clone</target>
        </trans-unit>
        <trans-unit id="c4238fb46fd7eaa2a0823eded93fee09138cb72e" translate="yes" xml:space="preserve">
          <source>BinaryHeap::clone_from</source>
          <target state="translated">BinaryHeap::clone_from</target>
        </trans-unit>
        <trans-unit id="b77853e2e7d4b57b08f38a8fa17f28d29076c075" translate="yes" xml:space="preserve">
          <source>BinaryHeap::clone_into</source>
          <target state="translated">BinaryHeap::clone_into</target>
        </trans-unit>
        <trans-unit id="d4e562b332ce963cb95b5b307cb7485615e014fc" translate="yes" xml:space="preserve">
          <source>BinaryHeap::default</source>
          <target state="translated">BinaryHeap::default</target>
        </trans-unit>
        <trans-unit id="fdc5438d4f6cad011f4663afcc9664e54dc0d85e" translate="yes" xml:space="preserve">
          <source>BinaryHeap::drain</source>
          <target state="translated">BinaryHeap::drain</target>
        </trans-unit>
        <trans-unit id="0aaca4d42181f37288aa7e21316d709a6ff71f49" translate="yes" xml:space="preserve">
          <source>BinaryHeap::extend</source>
          <target state="translated">BinaryHeap::extend</target>
        </trans-unit>
        <trans-unit id="f4c67172d6c1cdb39c6636230b079c173cf83f2c" translate="yes" xml:space="preserve">
          <source>BinaryHeap::fmt</source>
          <target state="translated">BinaryHeap::fmt</target>
        </trans-unit>
        <trans-unit id="871dac7b5ceedfbec71447a6d6ed9de357acd044" translate="yes" xml:space="preserve">
          <source>BinaryHeap::from</source>
          <target state="translated">BinaryHeap::from</target>
        </trans-unit>
        <trans-unit id="f175a9eb33f99d6629fe67f65984c4a890519755" translate="yes" xml:space="preserve">
          <source>BinaryHeap::from_iter</source>
          <target state="translated">BinaryHeap::from_iter</target>
        </trans-unit>
        <trans-unit id="abdea679542fd107e906ae5d58ce503cb54c014d" translate="yes" xml:space="preserve">
          <source>BinaryHeap::into</source>
          <target state="translated">BinaryHeap::into</target>
        </trans-unit>
        <trans-unit id="45541a8cf8b33e80b63d4c7b7d8a3acfe03252c0" translate="yes" xml:space="preserve">
          <source>BinaryHeap::into_iter</source>
          <target state="translated">BinaryHeap::into_iter</target>
        </trans-unit>
        <trans-unit id="a4f3a26fa362623ceae23603112262e72024f7b9" translate="yes" xml:space="preserve">
          <source>BinaryHeap::into_sorted_vec</source>
          <target state="translated">BinaryHeap::into_sorted_vec</target>
        </trans-unit>
        <trans-unit id="1db086875600549522e8a9e52684ebd526b5b129" translate="yes" xml:space="preserve">
          <source>BinaryHeap::into_vec</source>
          <target state="translated">BinaryHeap::into_vec</target>
        </trans-unit>
        <trans-unit id="a112ebac833a70561b615451c2e74f51b6f19a74" translate="yes" xml:space="preserve">
          <source>BinaryHeap::is_empty</source>
          <target state="translated">BinaryHeap::is_empty</target>
        </trans-unit>
        <trans-unit id="0ee572360922722532c0921740eb1f614a7ab7ce" translate="yes" xml:space="preserve">
          <source>BinaryHeap::iter</source>
          <target state="translated">BinaryHeap::iter</target>
        </trans-unit>
        <trans-unit id="119b277a11fb08dfc4b80fb6b74bafd3221914e4" translate="yes" xml:space="preserve">
          <source>BinaryHeap::len</source>
          <target state="translated">BinaryHeap::len</target>
        </trans-unit>
        <trans-unit id="227d527ad8e44dcb2418c2e7e8e075d2359fb772" translate="yes" xml:space="preserve">
          <source>BinaryHeap::new</source>
          <target state="translated">BinaryHeap::new</target>
        </trans-unit>
        <trans-unit id="1fed1ee8afbb235ea1f87d7947786969b3a00687" translate="yes" xml:space="preserve">
          <source>BinaryHeap::peek</source>
          <target state="translated">BinaryHeap::peek</target>
        </trans-unit>
        <trans-unit id="23133fcfda988b66f1b73cca51b41c4297acc6b5" translate="yes" xml:space="preserve">
          <source>BinaryHeap::peek_mut</source>
          <target state="translated">BinaryHeap::peek_mut</target>
        </trans-unit>
        <trans-unit id="d6e00b82d35a37cd32b1907ca0812180a4fe6813" translate="yes" xml:space="preserve">
          <source>BinaryHeap::pop</source>
          <target state="translated">BinaryHeap::pop</target>
        </trans-unit>
        <trans-unit id="9d087a89ba80a46d773a7b420f9c4e221911780c" translate="yes" xml:space="preserve">
          <source>BinaryHeap::push</source>
          <target state="translated">BinaryHeap::push</target>
        </trans-unit>
        <trans-unit id="f989d57cf0e0868e0ab3e99ccd663f3feb35ed09" translate="yes" xml:space="preserve">
          <source>BinaryHeap::reserve</source>
          <target state="translated">BinaryHeap::reserve</target>
        </trans-unit>
        <trans-unit id="2c3a34b08e6d7927826662441c85562fbe689c5c" translate="yes" xml:space="preserve">
          <source>BinaryHeap::reserve_exact</source>
          <target state="translated">BinaryHeap::reserve_exact</target>
        </trans-unit>
        <trans-unit id="7748954939d681e885fda180afed19fde978c11a" translate="yes" xml:space="preserve">
          <source>BinaryHeap::shrink_to</source>
          <target state="translated">BinaryHeap::shrink_to</target>
        </trans-unit>
        <trans-unit id="a6cb12e1cadaa03dc4bd1cee0a924e07fbf651bc" translate="yes" xml:space="preserve">
          <source>BinaryHeap::shrink_to_fit</source>
          <target state="translated">BinaryHeap::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="3173fa304efc6acd170d96dcfc16d265f0d5bb04" translate="yes" xml:space="preserve">
          <source>BinaryHeap::to_owned</source>
          <target state="translated">BinaryHeap::to_owned</target>
        </trans-unit>
        <trans-unit id="545a06b62d55dcf95e6aed766f34093361650315" translate="yes" xml:space="preserve">
          <source>BinaryHeap::try_from</source>
          <target state="translated">BinaryHeap::try_from</target>
        </trans-unit>
        <trans-unit id="9ff50e94eaf55b6f7a7c5638416c4db484934500" translate="yes" xml:space="preserve">
          <source>BinaryHeap::try_into</source>
          <target state="translated">BinaryHeap::try_into</target>
        </trans-unit>
        <trans-unit id="337697412c6fd50a3b2ba815044c47d165af3cd6" translate="yes" xml:space="preserve">
          <source>BinaryHeap::type_id</source>
          <target state="translated">BinaryHeap::type_id</target>
        </trans-unit>
        <trans-unit id="8acc5ae886b9efd0dc8fb7d4fc82df425c356c37" translate="yes" xml:space="preserve">
          <source>BinaryHeap::with_capacity</source>
          <target state="translated">BinaryHeap::with_capacity</target>
        </trans-unit>
        <trans-unit id="c33a043d5763d9b3ea7f89a9ac614fa68ca83bc4" translate="yes" xml:space="preserve">
          <source>Bind a TCP listener to an address, listen for connections, and read bytes in nonblocking mode:</source>
          <target state="translated">비 차단 모드에서 TCP 리스너를 주소에 바인딩하고 연결을 청취하며 바이트를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="359dde3378dea26f13c20bf3ab1abd7d31ba2c01" translate="yes" xml:space="preserve">
          <source>Bind a value to a variable.</source>
          <target state="translated">변수에 값을 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="d22542d4de6d5029b1ac0ccd7c008fc51102ba8b" translate="yes" xml:space="preserve">
          <source>Bind by reference during pattern matching.</source>
          <target state="translated">패턴 일치 중에 참조로 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="069dbd36e80b491e8ea0d0898b003375a28c5f42" translate="yes" xml:space="preserve">
          <source>Binding all paths matching a given prefix, using the asterisk wildcard syntax &lt;code&gt;use a::b::*;&lt;/code&gt;.</source>
          <target state="translated">별표 와일드 카드 구문을 &lt;code&gt;use a::b::*;&lt;/code&gt; 하여 지정된 접두사와 일치하는 모든 경로를 바인딩 하면 a :: b :: *; .</target>
        </trans-unit>
        <trans-unit id="edac8dc0f66a2e81b54912d09ade5eca329f5dcd" translate="yes" xml:space="preserve">
          <source>Binding modes</source>
          <target state="translated">바인딩 모드</target>
        </trans-unit>
        <trans-unit id="30c9ed787b1702852e9d605cfb98fe4532008152" translate="yes" xml:space="preserve">
          <source>Binding with a port number of 0 will request that the OS assigns a port to this listener. The port allocated can be queried via the &lt;a href=&quot;#method.local_addr&quot;&gt;&lt;code&gt;local_addr&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">포트 번호가 0 인 바인딩은 OS가이 리스너에 포트를 할당하도록 요청합니다. 할당 된 포트는 &lt;a href=&quot;#method.local_addr&quot;&gt; &lt;code&gt;local_addr&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 조회 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ace7ad2d8af42b873b8f9c931c9515626c9ccb54" translate="yes" xml:space="preserve">
          <source>Binding with a port number of 0 will request that the OS assigns a port to this listener. The port allocated can be queried via the &lt;a href=&quot;struct.tcplistener#method.local_addr&quot;&gt;&lt;code&gt;TcpListener::local_addr&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">포트 번호 0으로 바인딩하면 OS가이 리스너에 포트를 할당하도록 요청합니다. 할당 된 포트는 &lt;a href=&quot;struct.tcplistener#method.local_addr&quot;&gt; &lt;code&gt;TcpListener::local_addr&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c4806bd148356225d8f9e9c34e40c18cd70837a" translate="yes" xml:space="preserve">
          <source>Binds a reference to the &lt;code&gt;name&lt;/code&gt; field to the variable &lt;code&gt;person_name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 필드에 대한 참조를 변수 &lt;code&gt;person_name&lt;/code&gt; 에 바인딩 합니다.</target>
        </trans-unit>
        <trans-unit id="309af9e25956170a810f78e3c71afc45e9766ccf" translate="yes" xml:space="preserve">
          <source>BitAnd</source>
          <target state="translated">BitAnd</target>
        </trans-unit>
        <trans-unit id="597ad73fbf9aa40cebae5f999cfe7db4afecce4e" translate="yes" xml:space="preserve">
          <source>BitAnd::bitand</source>
          <target state="translated">BitAnd::bitand</target>
        </trans-unit>
        <trans-unit id="943b337ab11ab98e677d691725140875e5b353e9" translate="yes" xml:space="preserve">
          <source>BitAndAssign</source>
          <target state="translated">BitAndAssign</target>
        </trans-unit>
        <trans-unit id="f5e3873189453b3d2f6432bcad61a66bb4d9501b" translate="yes" xml:space="preserve">
          <source>BitAndAssign::bitand_assign</source>
          <target state="translated">BitAndAssign::bitand_assign</target>
        </trans-unit>
        <trans-unit id="f64578ede789cb16c75f551e17bc358c839da2a7" translate="yes" xml:space="preserve">
          <source>BitOr</source>
          <target state="translated">BitOr</target>
        </trans-unit>
        <trans-unit id="44191b5eea700acecf61cce1d97b9be216180188" translate="yes" xml:space="preserve">
          <source>BitOr::bitor</source>
          <target state="translated">BitOr::bitor</target>
        </trans-unit>
        <trans-unit id="960e956c7d9aabe97b11d326569299236d4948a9" translate="yes" xml:space="preserve">
          <source>BitOrAssign</source>
          <target state="translated">BitOrAssign</target>
        </trans-unit>
        <trans-unit id="3034c1fbe2a99f07e023c8c2cb9d42ee22ccc4c1" translate="yes" xml:space="preserve">
          <source>BitOrAssign::bitor_assign</source>
          <target state="translated">BitOrAssign::bitor_assign</target>
        </trans-unit>
        <trans-unit id="427e64f1c1cbca75038d127034792de35e048e3d" translate="yes" xml:space="preserve">
          <source>BitXor</source>
          <target state="translated">BitXor</target>
        </trans-unit>
        <trans-unit id="2e397bf0da401d643f9083e54c584225e131c7ca" translate="yes" xml:space="preserve">
          <source>BitXor::bitxor</source>
          <target state="translated">BitXor::bitxor</target>
        </trans-unit>
        <trans-unit id="6a826e6c5b73b200c07a57a2aec1b711ff40e1d4" translate="yes" xml:space="preserve">
          <source>BitXorAssign</source>
          <target state="translated">BitXorAssign</target>
        </trans-unit>
        <trans-unit id="cbbbcfd713c363f58df6976ea8f22e15d59645d6" translate="yes" xml:space="preserve">
          <source>BitXorAssign::bitxor_assign</source>
          <target state="translated">BitXorAssign::bitxor_assign</target>
        </trans-unit>
        <trans-unit id="77e08df74f0783fd374c97b42304776b3399af7d" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;and&quot; with the current value.</source>
          <target state="translated">현재 값을 가진 비트 단위 &quot;and&quot;.</target>
        </trans-unit>
        <trans-unit id="2c404667875b6822ca47e4a6888c165e459b533c" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;nand&quot; with the current value.</source>
          <target state="translated">현재 값을 가진 비트 단위 &quot;nand&quot;.</target>
        </trans-unit>
        <trans-unit id="1f35aa22f6cd34a5220faabf04cbbb20527ee643" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;or&quot; with the current value.</source>
          <target state="translated">현재 값을 가진 비트 단위 &quot;또는&quot;.</target>
        </trans-unit>
        <trans-unit id="5c076254fac7febb41ccccf46680d5e14a161fa4" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;xor&quot; with the current value.</source>
          <target state="translated">현재 값을 가진 비트 단위 &quot;xor&quot;</target>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="translated">비트 AND</target>
        </trans-unit>
        <trans-unit id="4a9a6c94eeeaf50fe1cbac8c1cdc883b234d3b2b" translate="yes" xml:space="preserve">
          <source>Bitwise AND and assignment</source>
          <target state="translated">비트 AND 및 대입</target>
        </trans-unit>
        <trans-unit id="714d6d47971ffbb15128b6a55a03723a5c596cc3" translate="yes" xml:space="preserve">
          <source>Bitwise And assignment</source>
          <target state="translated">비트와 할당</target>
        </trans-unit>
        <trans-unit id="136c3a93310929e09124297eaf66ab9f3782d009" translate="yes" xml:space="preserve">
          <source>Bitwise NOT</source>
          <target state="translated">비트 단위 NOT</target>
        </trans-unit>
        <trans-unit id="f4be0adcfa81c37e1e7bbf2e23630f30974d164f" translate="yes" xml:space="preserve">
          <source>Bitwise OR</source>
          <target state="translated">비트 OR</target>
        </trans-unit>
        <trans-unit id="ea162d3eb732111137dc7e851592f946afbda822" translate="yes" xml:space="preserve">
          <source>Bitwise OR and assignment</source>
          <target state="translated">비트 단위 OR 및 할당</target>
        </trans-unit>
        <trans-unit id="efa8078cf56f653efb920477181cc2fe85068270" translate="yes" xml:space="preserve">
          <source>Bitwise Or assignment</source>
          <target state="translated">비트 단위 또는 할당</target>
        </trans-unit>
        <trans-unit id="74269e9a4eb117ac43a93ed74bc3c8cd96fd4ff4" translate="yes" xml:space="preserve">
          <source>Bitwise XOR</source>
          <target state="translated">비트 XOR</target>
        </trans-unit>
        <trans-unit id="e3e1709ce290a67ec5f21e03a6b6317c9f304436" translate="yes" xml:space="preserve">
          <source>Bitwise XOR assignment</source>
          <target state="translated">비트 XOR 할당</target>
        </trans-unit>
        <trans-unit id="1f5eabb7a575f79f20f4d75b3fa1ac6c470a8bf6" translate="yes" xml:space="preserve">
          <source>Bitwise and Logical XOR</source>
          <target state="translated">비트 및 논리 XOR</target>
        </trans-unit>
        <trans-unit id="f5a1528826bb49fb0b14c31ab4934d10465ebdc5" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value.</source>
          <target state="translated">비트 단위 및 현재 값으로 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ad214175503cf05c10c463c5f6a4d2dbb82dbf24" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 단위 및 현재 값으로 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_and&lt;/code&gt; 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="52dda2454098469eb02e841cfd17da11a1a8b11c" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 단위 및 현재 값으로 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_and&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_and 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0c63ecd3d802b04a4e0e8dfab8248d912515dec0" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 단위 및 현재 값으로 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_and&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_and 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4b6a21a8674eebce391a665fc4970562e774c483" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 단위 및 현재 값으로 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_and&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_and 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="63f47ad2a1e6e1fb335c5dc45db81e8017584432" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 단위 및 현재 값으로 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_and&lt;/code&gt; 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3ba80ac4bf1c4bbad0f4a7d6ddfd25841835e177" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive OR</source>
          <target state="translated">비트 배타적 OR</target>
        </trans-unit>
        <trans-unit id="87474ce9659a0e1b133611bb2ae41c7ede6c0a5d" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive OR and assignment</source>
          <target state="translated">비트 배타적 OR 및 할당</target>
        </trans-unit>
        <trans-unit id="868d075a0dad8cd3d8fb9f9f26964659d2c6164a" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value.</source>
          <target state="translated">현재 값이있는 비트 단위 nand, 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="544da95df04807eeb86f0e070273fd4dd28cb7cf" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값을 가진 비트 단위 낸드는 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_nand&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_nand 메소드 를 통해 &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d773083e9bfa18a72e7f0b0ab1c138c37ef42288" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값을 가진 비트 단위 낸드는 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_nand&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_nand 메소드 를 통해 &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="203338bb702fd121bec1c0bf9d6a954aecd4347e" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값을 가진 비트 단위 낸드는 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_nand&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_nand 메소드 를 통해 &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6134a1fe2a25d4dbb615e6688200dbe8e85fe9f6" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값을 가진 비트 단위 낸드는 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_nand&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_nand 메소드 를 통해 &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f8ddb011394cb17fb806f98da48b371ebbb0870e" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값을 가진 비트 단위 낸드는 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_nand&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_nand 메소드 를 통해 &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="60a4df2d9448161e88049fa61b8cadfe600ad676" translate="yes" xml:space="preserve">
          <source>Bitwise or logical complement</source>
          <target state="translated">비트 또는 논리 보수</target>
        </trans-unit>
        <trans-unit id="7b4a22d8edc7cc62ea1716050e10c7737c8c1e1f" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value.</source>
          <target state="translated">비트 단위 또는 현재 값으로 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="535640642d3aa1c0482deebda0463eaa8ec0186f" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 단위 또는 현재 값으로 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_or&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_or 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5bd0c7ff8a606308243e5fe0283ace8408191438" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 단위 또는 현재 값으로 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_or&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_or 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1d6bccdc0a09c0e78855aa36b6446bb0697edc37" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 단위 또는 현재 값으로 이전 값을 반환합니다. 이 내장 함수의 안정화 버전은 &lt;code&gt;fetch_or&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_or 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7457b18d65f2f07bafb68e32e88a446590597ffd" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 단위 또는 현재 값으로 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_or&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_or 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6a1e96dd5049ad694cd97688db2eb461734bf5e6" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 단위 또는 현재 값으로 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_or&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_or 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="181decb693bb642be494fbe5c52383467e0c228c" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value.</source>
          <target state="translated">현재 값으로 비트 xor를 수행하여 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aa1d7bc97bda02349e1fee1efbf8d66b5e91fc88" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값을 가진 비트 단위 xor, 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_xor&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_xor 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형에서 사용 가능합니다 . 예를 들어 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3805cb63a3c1121fa142484c3b378fcb265aa95c" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값을 가진 비트 단위 xor, 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_xor&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_xor 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형에서 사용 가능합니다 . 예를 들어 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c5ce9f030ae16f9b2b741aab2abe9cb20f55a4eb" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값을 가진 비트 단위 xor, 이전 값을 반환합니다. 이 내장 함수의 안정화 버전은 &lt;code&gt;fetch_xor&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_xor 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="15836191977a94f34a9eedc80d403307d7b6d4ed" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값을 가진 비트 단위 xor, 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_xor&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_xor 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ffe95ab6a76bb352e681774fae150809af8a6615" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값을 가진 비트 단위 xor, 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_xor&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_xor 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형에서 사용 가능합니다 . 예를 들어 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="88de087af89700f4c1004e0042a100c96cfad709" translate="yes" xml:space="preserve">
          <source>Blanket Implementations</source>
          <target state="translated">담요 구현</target>
        </trans-unit>
        <trans-unit id="7ebf10e8c63d15dc33875a65edf15f33311b088f" translate="yes" xml:space="preserve">
          <source>Blanket implementation</source>
          <target state="translated">블랭킷 구현</target>
        </trans-unit>
        <trans-unit id="b62ea629ea517115ba87dea634c655ff0a340dd4" translate="yes" xml:space="preserve">
          <source>Blanket implementations appear in the documentation for the trait in the &amp;ldquo;Implementors&amp;rdquo; section.</source>
          <target state="translated">담요 구현은 &quot;구현 자&quot;섹션의 특성에 대한 문서에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a06bbda0eab9ea08dbe94577274cbb7b473571d4" translate="yes" xml:space="preserve">
          <source>Block comment</source>
          <target state="translated">댓글 차단</target>
        </trans-unit>
        <trans-unit id="684096ae991ba36b90c5953d624c41ac5080dfdf" translate="yes" xml:space="preserve">
          <source>Block expression</source>
          <target state="translated">블록 표현</target>
        </trans-unit>
        <trans-unit id="8b403969dc1821977a4545f2dd574d603b1654fd" translate="yes" xml:space="preserve">
          <source>Block expressions</source>
          <target state="translated">블록 표현</target>
        </trans-unit>
        <trans-unit id="7805c38c778b7b8d59aebeff2b37473f6e635d86" translate="yes" xml:space="preserve">
          <source>Block expressions as elements of &lt;a href=&quot;array-expr&quot;&gt;array expressions&lt;/a&gt;, &lt;a href=&quot;tuple-expr&quot;&gt;tuple expressions&lt;/a&gt;, &lt;a href=&quot;call-expr&quot;&gt;call expressions&lt;/a&gt;, and tuple-style &lt;a href=&quot;struct-expr&quot;&gt;struct&lt;/a&gt; and &lt;a href=&quot;enum-variant-expr&quot;&gt;enum variant&lt;/a&gt; expressions.</source>
          <target state="translated">&lt;a href=&quot;array-expr&quot;&gt;배열 표현식&lt;/a&gt; , &lt;a href=&quot;tuple-expr&quot;&gt;튜플 표현식&lt;/a&gt; , &lt;a href=&quot;call-expr&quot;&gt;호출 표현식&lt;/a&gt; , 튜플 스타일 &lt;a href=&quot;struct-expr&quot;&gt;구조체&lt;/a&gt; 및 &lt;a href=&quot;enum-variant-expr&quot;&gt;열거 형 변형&lt;/a&gt; 표현식의 요소 인 블록 표현식 입니다.</target>
        </trans-unit>
        <trans-unit id="9e069137567cf4c22756c0a181e015e273f3b097" translate="yes" xml:space="preserve">
          <source>Block expressions as elements of &lt;a href=&quot;array-expr&quot;&gt;array expressions&lt;/a&gt;, &lt;a href=&quot;tuple-expr&quot;&gt;tuple expressions&lt;/a&gt;, &lt;a href=&quot;call-expr&quot;&gt;call expressions&lt;/a&gt;, tuple-style &lt;a href=&quot;struct-expr&quot;&gt;struct&lt;/a&gt; and &lt;a href=&quot;enum-variant-expr&quot;&gt;enum variant&lt;/a&gt; expressions.</source>
          <target state="translated">&lt;a href=&quot;array-expr&quot;&gt;배열 표현식&lt;/a&gt; , &lt;a href=&quot;tuple-expr&quot;&gt;튜플 표현식&lt;/a&gt; , &lt;a href=&quot;call-expr&quot;&gt;호출 표현식&lt;/a&gt; , 튜플 스타일 &lt;a href=&quot;struct-expr&quot;&gt;구조체&lt;/a&gt; 및 &lt;a href=&quot;enum-variant-expr&quot;&gt;열거 형 변형&lt;/a&gt; 표현식의 요소로 표현식을 차단하십시오 .</target>
        </trans-unit>
        <trans-unit id="502282ec9c201c5e6057f4beae39b5897d6f29ed" translate="yes" xml:space="preserve">
          <source>Block expressions used as a &lt;a href=&quot;../statements&quot;&gt;statement&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../statements&quot;&gt;명령문으로&lt;/a&gt; 사용되는 블록 표현식 .</target>
        </trans-unit>
        <trans-unit id="d83a4ba900681b1d6bb448e76ababb6b95a22052" translate="yes" xml:space="preserve">
          <source>Blocks are always &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expressions&lt;/a&gt; and evaluate the last expression in value expression context. This can be used to force moving a value if really needed. For example, the following example fails on the call to &lt;code&gt;consume_self&lt;/code&gt; because the struct was moved out of &lt;code&gt;s&lt;/code&gt; in the block expression.</source>
          <target state="translated">블록은 항상 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;값 표현식&lt;/a&gt; 이며 값 표현식 컨텍스트에서 마지막 표현식을 평가합니다. 실제로 필요한 경우 값을 강제로 이동하는 데 사용할 수 있습니다. 예를 들어 다음 예제 는 블록 표현식에서 구조체가 &lt;code&gt;s&lt;/code&gt; 밖으로 이동 되었기 때문에 &lt;code&gt;consume_self&lt;/code&gt; 호출 할 때 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="c18efbe7496c8880dfb8b33f1bb639d10ba9c80d" translate="yes" xml:space="preserve">
          <source>Blocks are written as &lt;code&gt;{&lt;/code&gt;, then any &lt;a href=&quot;../attributes&quot;&gt;inner attributes&lt;/a&gt;, then &lt;a href=&quot;../statements&quot;&gt;statements&lt;/a&gt;, then an optional expression, and finally a &lt;code&gt;}&lt;/code&gt;. Statements are usually required to be followed a semicolon, with two exceptions. Item declaration statements do not need to be followed by a semicolon. Expression statements usually require a following semicolon except if its outer expression is a flow control expression. Furthermore, extra semicolons between statements are allowed, but these semicolons do not affect semantics.</source>
          <target state="translated">블록은 &lt;code&gt;{&lt;/code&gt; , &lt;a href=&quot;../attributes&quot;&gt;내부 속성&lt;/a&gt; , &lt;a href=&quot;../statements&quot;&gt;명령문&lt;/a&gt; , 선택적 표현식 및 마지막으로 &lt;code&gt;}&lt;/code&gt; 로 작성 됩니다. 명령문은 일반적으로 세미콜론을 따라야하며 두 가지 예외가 있습니다. 항목 선언문 뒤에 세미콜론이 올 필요는 없습니다. 표현식 문은 일반적으로 외부 표현식이 플로우 제어 표현식 인 경우를 제외하고 다음 세미콜론이 필요합니다. 또한 명령문 사이에 추가 세미콜론이 허용되지만 이러한 세미콜론은 의미에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae067769ea09e9988dc3c94bd840ffd9a2112129" translate="yes" xml:space="preserve">
          <source>Blocks are written as &lt;code&gt;{&lt;/code&gt;, then any &lt;a href=&quot;../attributes&quot;&gt;inner attributes&lt;/a&gt;, then &lt;a href=&quot;../statements&quot;&gt;statements&lt;/a&gt;, then an optional expression, and finally a &lt;code&gt;}&lt;/code&gt;. Statements are usually required to be followed by a semicolon, with two exceptions. Item declaration statements do not need to be followed by a semicolon. Expression statements usually require a following semicolon except if its outer expression is a flow control expression. Furthermore, extra semicolons between statements are allowed, but these semicolons do not affect semantics.</source>
          <target state="translated">블록은 &lt;code&gt;{&lt;/code&gt; , &lt;a href=&quot;../attributes&quot;&gt;내부 속성&lt;/a&gt; , &lt;a href=&quot;../statements&quot;&gt;명령문&lt;/a&gt; , 선택적 표현식, 마지막으로 &lt;code&gt;}&lt;/code&gt; 로 작성 됩니다. 일반적으로 명령문 뒤에 세미콜론이 와야하지만 두 가지 예외가 있습니다. 항목 선언문 뒤에 세미콜론이 올 필요가 없습니다. 식 문에는 일반적으로 외부식이 흐름 제어 식인 경우를 제외하고 다음 세미콜론이 필요합니다. 또한 문 사이에 추가 세미콜론이 허용되지만 이러한 세미콜론은 의미 체계에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b3b5253f4cf51bfc8b7e410d8b0b217d0e9c0335" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until all threads have rendezvoused here.</source>
          <target state="translated">모든 스레드가 여기에 연결될 때까지 현재 스레드를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="d45aaa4f52bf36a05dbf87c3a8418aac5e1ca210" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until this condition variable receives a notification and the provided condition is false.</source>
          <target state="translated">이 조건 변수가 알림을 받고 제공된 조건이 거짓이 될 때까지 현재 스레드를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="6fa33f5cb6fe4954947bbb580e0c51b7b87a1d8c" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until this condition variable receives a notification and the required condition is met. Spurious wakeups are ignored and this function will only return once the condition has been met.</source>
          <target state="translated">이 조건 변수가 알림을 받고 필요한 조건이 충족 될 때까지 현재 스레드를 차단합니다. 가짜 웨이크 업은 무시되며이 기능은 조건이 충족 된 후에 만 ​​반환됩니다.</target>
        </trans-unit>
        <trans-unit id="80e976210b81b30997de305efb4640d505e6cf39" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until this condition variable receives a notification.</source>
          <target state="translated">이 조건 변수가 알림을받을 때까지 현재 스레드를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="410a3ef0dd4f7761ff571ad2f23d0ad96832450b" translate="yes" xml:space="preserve">
          <source>Blocks unless or until the current thread's token is made available or the specified duration has been reached (may wake spuriously).</source>
          <target state="translated">현재 스레드의 토큰을 사용할 수 없거나 지정된 지속 시간에 도달하지 않을 때까지 또는 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="7e4f7a13eb5259dea6da862f685681bb73f6e91b" translate="yes" xml:space="preserve">
          <source>Blocks unless or until the current thread's token is made available.</source>
          <target state="translated">현재 스레드의 토큰을 사용할 수 없을 때까지 또는 차단합니다.</target>
        </trans-unit>
        <trans-unit id="e81a87a7fdc340ba3287800ef9018a00b1adc455" translate="yes" xml:space="preserve">
          <source>Blocks: if a block has type &lt;code&gt;U&lt;/code&gt;, then the last expression in the block (if it is not semicolon-terminated) is a coercion site to &lt;code&gt;U&lt;/code&gt;. This includes blocks which are part of control flow statements, such as &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;, if the block has a known type.</source>
          <target state="translated">블록 : 블록에 &lt;code&gt;U&lt;/code&gt; 유형이 있으면 블록 의 마지막 표현식 (세미콜론으로 끝나지 않은 경우)은 &lt;code&gt;U&lt;/code&gt; 에 대한 강제 사이트 입니다. 여기에는 블록 에 알려진 유형이있는 경우 &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 등의 제어 흐름 문의 일부인 블록이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="104329f4432c8b8b5d3c19fc3d250dfe2ab027d2" translate="yes" xml:space="preserve">
          <source>Bodies of unsafe functions are effectively &lt;code&gt;unsafe&lt;/code&gt; blocks, so to perform other unsafe operations within an unsafe function, we don&amp;rsquo;t need to add another &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="translated">안전하지 않은 기능의 기관을 효과적으로 있습니다 &lt;code&gt;unsafe&lt;/code&gt; 그렇게 안전하지 않은 함수 내에서 다른 안전하지 않은 작업을 수행하기 위해, 블록, 우리는 또 다른 추가 할 필요가 없습니다 &lt;code&gt;unsafe&lt;/code&gt; 블록을.</target>
        </trans-unit>
        <trans-unit id="c9a26dc7a812c76d486afec462ae9a205a68b3e6" translate="yes" xml:space="preserve">
          <source>Boolean literals</source>
          <target state="translated">부울 리터럴</target>
        </trans-unit>
        <trans-unit id="49f29c844f200eead7503c6d10737135d242ba2b" translate="yes" xml:space="preserve">
          <source>Boolean type</source>
          <target state="translated">부울 타입</target>
        </trans-unit>
        <trans-unit id="cb4702d3f3cd69e09a0563d0dcdc4d54d0023693" translate="yes" xml:space="preserve">
          <source>Borrow</source>
          <target state="translated">Borrow</target>
        </trans-unit>
        <trans-unit id="1fd0a944ea8cfb257b2b56f1afcd67ff9e3b25e2" translate="yes" xml:space="preserve">
          <source>Borrow operators</source>
          <target state="translated">차용자</target>
        </trans-unit>
        <trans-unit id="08ef91a49ea57c4babbbcf16cff803659fb46ac3" translate="yes" xml:space="preserve">
          <source>Borrow::borrow</source>
          <target state="translated">Borrow::borrow</target>
        </trans-unit>
        <trans-unit id="2928c5f6ce470ed45869ce9bc666a02f1b276c3c" translate="yes" xml:space="preserve">
          <source>BorrowError</source>
          <target state="translated">BorrowError</target>
        </trans-unit>
        <trans-unit id="cd83210bbc26f6a86f78acc2c5aab6cb300d7a3f" translate="yes" xml:space="preserve">
          <source>BorrowError::borrow</source>
          <target state="translated">BorrowError::borrow</target>
        </trans-unit>
        <trans-unit id="522f3d26a1b9c184b1451ca62d5ed845e00d0b54" translate="yes" xml:space="preserve">
          <source>BorrowError::borrow_mut</source>
          <target state="translated">BorrowError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="7a951e76d02cd0d1326baee884b3df884ef7505b" translate="yes" xml:space="preserve">
          <source>BorrowError::cause</source>
          <target state="translated">BorrowError::cause</target>
        </trans-unit>
        <trans-unit id="9346d595a8c0688d171353745aeb9cb098c34080" translate="yes" xml:space="preserve">
          <source>BorrowError::description</source>
          <target state="translated">BorrowError::description</target>
        </trans-unit>
        <trans-unit id="89396ee3db16dbcc29597b262afc46558ed2366f" translate="yes" xml:space="preserve">
          <source>BorrowError::fmt</source>
          <target state="translated">BorrowError::fmt</target>
        </trans-unit>
        <trans-unit id="f021a214bcd178a0ea344c71db12231f4f31c50f" translate="yes" xml:space="preserve">
          <source>BorrowError::from</source>
          <target state="translated">BorrowError::from</target>
        </trans-unit>
        <trans-unit id="886751874954c88f3e019db825f51742642c3fcc" translate="yes" xml:space="preserve">
          <source>BorrowError::into</source>
          <target state="translated">BorrowError::into</target>
        </trans-unit>
        <trans-unit id="26e12b28f77d9243f30385a8268af2b47555aa7c" translate="yes" xml:space="preserve">
          <source>BorrowError::source</source>
          <target state="translated">BorrowError::source</target>
        </trans-unit>
        <trans-unit id="13b09f10b5e2154e8e5ae8b9b7bc53371a685504" translate="yes" xml:space="preserve">
          <source>BorrowError::to_string</source>
          <target state="translated">BorrowError::to_string</target>
        </trans-unit>
        <trans-unit id="2ce8439dd5781fe13a435aac312be62b63c7c5be" translate="yes" xml:space="preserve">
          <source>BorrowError::try_from</source>
          <target state="translated">BorrowError::try_from</target>
        </trans-unit>
        <trans-unit id="433ecad73e66b8dc9a31fe37870bbe334a572245" translate="yes" xml:space="preserve">
          <source>BorrowError::try_into</source>
          <target state="translated">BorrowError::try_into</target>
        </trans-unit>
        <trans-unit id="65acd86f1a255edf5a9bf5a76b81126963ed5e13" translate="yes" xml:space="preserve">
          <source>BorrowError::type_id</source>
          <target state="translated">BorrowError::type_id</target>
        </trans-unit>
        <trans-unit id="7ecce6e07f46ad690e4097354d0bc6aaa0f99008" translate="yes" xml:space="preserve">
          <source>BorrowMut</source>
          <target state="translated">BorrowMut</target>
        </trans-unit>
        <trans-unit id="d9285d895ed643451254273bc8c4bbd62b0abca2" translate="yes" xml:space="preserve">
          <source>BorrowMut::borrow_mut</source>
          <target state="translated">BorrowMut::borrow_mut</target>
        </trans-unit>
        <trans-unit id="05ef9e71b85c91963a382e2cbdd7ebb51b1ef2c3" translate="yes" xml:space="preserve">
          <source>BorrowMutError</source>
          <target state="translated">BorrowMutError</target>
        </trans-unit>
        <trans-unit id="6c84f92cc03620eeb60a2a75a6198806e41c99cf" translate="yes" xml:space="preserve">
          <source>BorrowMutError::borrow</source>
          <target state="translated">BorrowMutError::borrow</target>
        </trans-unit>
        <trans-unit id="c9194e522b34f7f0397b113f83851e0a0750ebff" translate="yes" xml:space="preserve">
          <source>BorrowMutError::borrow_mut</source>
          <target state="translated">BorrowMutError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="320189f255d75bf0531f1d4da80752757ad88765" translate="yes" xml:space="preserve">
          <source>BorrowMutError::cause</source>
          <target state="translated">BorrowMutError::cause</target>
        </trans-unit>
        <trans-unit id="5d91335b7a43a382a81f901fb2092637fc2b1b30" translate="yes" xml:space="preserve">
          <source>BorrowMutError::description</source>
          <target state="translated">BorrowMutError::description</target>
        </trans-unit>
        <trans-unit id="de7386f3e6ce0f0541da576e92b462815d327aa2" translate="yes" xml:space="preserve">
          <source>BorrowMutError::fmt</source>
          <target state="translated">BorrowMutError::fmt</target>
        </trans-unit>
        <trans-unit id="0eaaabb7614aee38df98b183695570760d2a3bd8" translate="yes" xml:space="preserve">
          <source>BorrowMutError::from</source>
          <target state="translated">BorrowMutError::from</target>
        </trans-unit>
        <trans-unit id="f361017eeaa59fd5af6e66dc8387dd7623505766" translate="yes" xml:space="preserve">
          <source>BorrowMutError::into</source>
          <target state="translated">BorrowMutError::into</target>
        </trans-unit>
        <trans-unit id="4c422d071ef6d2a11942aa38c90bd2712b395f0a" translate="yes" xml:space="preserve">
          <source>BorrowMutError::source</source>
          <target state="translated">BorrowMutError::source</target>
        </trans-unit>
        <trans-unit id="2eb0e23a66aa4d528bf24f44d0b10d6fbb428403" translate="yes" xml:space="preserve">
          <source>BorrowMutError::to_string</source>
          <target state="translated">BorrowMutError::to_string</target>
        </trans-unit>
        <trans-unit id="b02bd0326962794fede5f5e186f12a2fd926a13b" translate="yes" xml:space="preserve">
          <source>BorrowMutError::try_from</source>
          <target state="translated">BorrowMutError::try_from</target>
        </trans-unit>
        <trans-unit id="6719140c2e78bc9c851d093ca84a7d95a4fe42cf" translate="yes" xml:space="preserve">
          <source>BorrowMutError::try_into</source>
          <target state="translated">BorrowMutError::try_into</target>
        </trans-unit>
        <trans-unit id="aed34dec1357c0aa84876bb9c79b00511d803df2" translate="yes" xml:space="preserve">
          <source>BorrowMutError::type_id</source>
          <target state="translated">BorrowMutError::type_id</target>
        </trans-unit>
        <trans-unit id="5868e9faf108a7771c407ab907889934dd63b50a" translate="yes" xml:space="preserve">
          <source>Borrowed data.</source>
          <target state="translated">차용 한 데이터.</target>
        </trans-unit>
        <trans-unit id="c7098078c609573d3fe94c28cfeb29c10812c3db" translate="yes" xml:space="preserve">
          <source>Borrowed pointer type</source>
          <target state="translated">차용 된 포인터 유형</target>
        </trans-unit>
        <trans-unit id="74d965d163933b4d9c245330d676a9a3a774550a" translate="yes" xml:space="preserve">
          <source>Borrowed reference to an OS string (see &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">OS 문자열에 대한 참조를 차용했습니다 ( &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="885dff407470f8d8cfa69af65835344b4ec2492e" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it.</source>
          <target state="translated">반복자를 소비하지 않고 차용합니다.</target>
        </trans-unit>
        <trans-unit id="e4b68387bd9a788e153fefb151f2e36c5cc3e492" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;../../../iter/trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자를 소비하지 않고 차용합니다. &lt;a href=&quot;../../../iter/trait.iterator#method.by_ref&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c2a592fe9d3573696dcb4e01f0c58c8f29d9729" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;../../iter/trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자를 소비하지 않고 차용합니다. &lt;a href=&quot;../../iter/trait.iterator#method.by_ref&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc9f6098309a428e4660e57ac0d7a128a57eb4f3" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;../iter/trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자를 소비하지 않고 차용합니다. &lt;a href=&quot;../iter/trait.iterator#method.by_ref&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4d7aa1610c7d0263c276944863186c7f5b54aca" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;iter/trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자를 소비하지 않고 차용합니다. &lt;a href=&quot;iter/trait.iterator#method.by_ref&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0448c3473f95cd23244ee44dd3147a10fd3dd487" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자를 소비하지 않고 차용합니다. &lt;a href=&quot;trait.iterator#method.by_ref&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f99b7e6b9280152eedd396f475e3d3c1511ee27c" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&lt;code&gt;dyn Trait&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt; in return types have a an implicit &lt;code&gt;'static&lt;/code&gt; requirement, meaning that the value implementing them that is being returned has to be either a &lt;code&gt;'static&lt;/code&gt; borrow or an owned value.</source>
          <target state="translated">반환 유형의 &lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt; &lt;code&gt;dyn Trait&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt; &lt;code&gt;impl Trait&lt;/code&gt; &lt;/a&gt; 에는 모두 암시 적 &lt;code&gt;'static&lt;/code&gt; 요구 사항 '이 있습니다. 즉, 반환되는 항목을 구현하는 값은 &lt;code&gt;'static&lt;/code&gt; 이어야합니다. 차용 또는 소유 된 값 .</target>
        </trans-unit>
        <trans-unit id="5f521714f9167c57599a72f6be51da170e80a3dd" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;items/constant-items&quot;&gt;constant&lt;/a&gt; and &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt; declarations of reference types have &lt;em&gt;implicit&lt;/em&gt;&lt;code&gt;'static&lt;/code&gt; lifetimes unless an explicit lifetime is specified. As such, the constant declarations involving &lt;code&gt;'static&lt;/code&gt; above may be written without the lifetimes.</source>
          <target state="translated">명시 적 수명을 지정하지 않으면 참조 유형의 &lt;a href=&quot;items/constant-items&quot;&gt;상수&lt;/a&gt; 및 &lt;a href=&quot;items/static-items&quot;&gt;정적&lt;/a&gt; 선언 모두 &lt;em&gt;암시 적 &lt;/em&gt; &lt;code&gt;'static&lt;/code&gt; 수명 '을 갖습니다 . 따라서 &lt;code&gt;'static&lt;/code&gt; static' 과 관련된 상수 선언 은 수명없이 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05a5142bb4165da20e62a15a12a49d69f51e7d7c" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;es and &lt;a href=&quot;struct.rwlock&quot;&gt;&lt;code&gt;RwLock&lt;/code&gt;&lt;/a&gt;s are poisoned whenever a thread fails while the lock is held. The precise semantics for when a lock is poisoned is documented on each lock, but once a lock is poisoned then all future acquisitions will return this error.</source>
          <target state="translated">두 &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; ES 및 &lt;a href=&quot;struct.rwlock&quot;&gt; &lt;code&gt;RwLock&lt;/code&gt; &lt;/a&gt; 잠금이 유지되는 동안 스레드가 실패 할 때마다의 중독된다. 잠금이 피독 될 때의 정확한 의미는 각 잠금에 문서화되어 있지만 일단 잠금이 피독되면 이후의 모든 획득은이 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="92f3e1242e71f216f2553ecade5c0b56c112c46f" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt; must be properly aligned.</source>
          <target state="translated">두 &lt;code&gt;src&lt;/code&gt; 와 &lt;code&gt;dst&lt;/code&gt; 제대로 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c1a304706d4634a69f512f48a553ca6de0a57224" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for both reads and writes of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes.</source>
          <target state="translated">두 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 있어야 &lt;a href=&quot;index#safety&quot;&gt;유효한&lt;/a&gt; 양의 읽기 및 기록을위한 &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 바이트.</target>
        </trans-unit>
        <trans-unit id="62b58df899df91147ad1851a44f1534537b8baae" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for both reads and writes.</source>
          <target state="translated">둘 다 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 해야 &lt;a href=&quot;index#safety&quot;&gt;유효한&lt;/a&gt; 모두 읽기 및 쓰기 위해.</target>
        </trans-unit>
        <trans-unit id="2af274f82063aea319dd50db89daaff81dd41c5b" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes.</source>
          <target state="translated">두 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 있어야 &lt;a href=&quot;index#safety&quot;&gt;유효&lt;/a&gt; 판독 및 쓰기에 대해 &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 바이트.</target>
        </trans-unit>
        <trans-unit id="f6aa81faf4ff06762f89afa21d147f447e5913ea" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 는 모두 읽기와 쓰기에 &lt;a href=&quot;index#safety&quot;&gt;유효&lt;/a&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ab994fd6a56d4038a2b10fa7688bd17375033138" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be properly aligned.</source>
          <target state="translated">둘 다 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 제대로 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c79da800bdef51dcfa75d10a65ea136a827d95b9" translate="yes" xml:space="preserve">
          <source>Both absolute and relative paths are followed by one or more identifiers separated by double colons (&lt;code&gt;::&lt;/code&gt;).</source>
          <target state="translated">절대 경로와 상대 경로 뒤에는 이중 콜론 ( &lt;code&gt;::&lt;/code&gt; :)으로 구분 된 하나 이상의 식별자가옵니다 .</target>
        </trans-unit>
        <trans-unit id="c285e2e79ff8d2abdbcbfce35a32a0f639fd60af" translate="yes" xml:space="preserve">
          <source>Both are equivalent to:</source>
          <target state="translated">둘 다 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d969a72eda5767cc021898e028fbe0fc071270ae" translate="yes" xml:space="preserve">
          <source>Both attributes can be used on &lt;a href=&quot;../items/functions&quot;&gt;functions&lt;/a&gt;. When applied to a function in a &lt;a href=&quot;../items/traits&quot;&gt;trait&lt;/a&gt;, they apply only to that function when used as a default function for a trait implementation and not to all trait implementations. The attributes have no effect on a trait function without a body.</source>
          <target state="translated">두 속성 모두 &lt;a href=&quot;../items/functions&quot;&gt;함수에서&lt;/a&gt; 사용할 수 있습니다 . &lt;a href=&quot;../items/traits&quot;&gt;특성&lt;/a&gt; 의 함수에 적용되는 경우 특성 특성 의 기본 함수로 사용되는 경우 해당 특성 에만 적용되며 모든 특성 구현에는 적용되지 않습니다. 특성은 본문이없는 특성 함수에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="969434c27ab08daa9144a7ddff09f258b6b015fd" translate="yes" xml:space="preserve">
          <source>Both match arms must produce values of type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;, but since &lt;code&gt;break&lt;/code&gt; never produces a value at all we know it can never produce a value which isn't a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;. This illustrates another behaviour of the &lt;code&gt;!&lt;/code&gt; type - expressions with type &lt;code&gt;!&lt;/code&gt; will coerce into any other type.</source>
          <target state="translated">두 매치 암 모두 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 유형의 값을 생성해야 하지만 &lt;code&gt;break&lt;/code&gt; 는 절대 값을 생성하지 않으므로 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 가 아닌 값을 생성 할 수 없다는 것을 알고 있습니다 . 이것은 &lt;code&gt;!&lt;/code&gt; type-type &lt;code&gt;!&lt;/code&gt; 다른 유형으로 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="f415dc3d7d35015fcd0e7c895d9cc2c978758324" translate="yes" xml:space="preserve">
          <source>Both match arms must produce values of type &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;, but since &lt;code&gt;break&lt;/code&gt; never produces a value at all we know it can never produce a value which isn't a &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;. This illustrates another behaviour of the &lt;code&gt;!&lt;/code&gt; type - expressions with type &lt;code&gt;!&lt;/code&gt; will coerce into any other type.</source>
          <target state="translated">두 개의 일치 암은 &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 유형의 값을 생성해야 하지만 &lt;code&gt;break&lt;/code&gt; 는 결코 값을 생성하지 않으므로 &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 가 아닌 값을 생성 할 수 없다는 것을 알고 있습니다 . 이것은 &lt;code&gt;!&lt;/code&gt; 타입 &lt;code&gt;!&lt;/code&gt; 다른 유형으로 강제합니다.</target>
        </trans-unit>
        <trans-unit id="cc4e0abfff334b57590e92cdeed48cb0b5815f3f" translate="yes" xml:space="preserve">
          <source>Both of the following must be true:</source>
          <target state="translated">다음 두 가지가 모두 참이어야합니다.</target>
        </trans-unit>
        <trans-unit id="8047c2fba1b8345d0b2a7bfe41d16519cea0cd82" translate="yes" xml:space="preserve">
          <source>Both pointers must be &lt;em&gt;derived from&lt;/em&gt; a pointer to the same object. (See below for an example.)</source>
          <target state="translated">두 포인터는 동일한 개체에 대한 포인터 &lt;em&gt;에서 파생&lt;/em&gt; 되어야 합니다. (예는 아래를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="2bf778379c09be3c08a3e90c46c05409146c7bf5" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;Post&lt;/code&gt; and &lt;code&gt;DraftPost&lt;/code&gt; structs have a private &lt;code&gt;content&lt;/code&gt; field that stores the blog post text. The structs no longer have the &lt;code&gt;state&lt;/code&gt; field because we&amp;rsquo;re moving the encoding of the state to the types of the structs. The &lt;code&gt;Post&lt;/code&gt; struct will represent a published post, and it has a &lt;code&gt;content&lt;/code&gt; method that returns the &lt;code&gt;content&lt;/code&gt;.</source>
          <target state="translated">모두 &lt;code&gt;Post&lt;/code&gt; 와 &lt;code&gt;DraftPost&lt;/code&gt; 구조체는 개인이 &lt;code&gt;content&lt;/code&gt; 필드가 저장 블로그 게시물의 텍스트를. &lt;code&gt;state&lt;/code&gt; 인코딩을 구조체 유형으로 옮기기 때문에 구조체에 더 이상 상태 필드 가 없습니다 . &lt;code&gt;Post&lt;/code&gt; 구조체는 게시 된 게시물을 나타냅니다, 그리고 그것은이 &lt;code&gt;content&lt;/code&gt; 방법을 반환하는 &lt;code&gt;content&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15171a122c9ce22a8b1a51961d40b1161cecfb6b" translate="yes" xml:space="preserve">
          <source>Both the lower- and upper-bounds (&lt;code&gt;l&lt;/code&gt; and &lt;code&gt;u&lt;/code&gt; respectively) are provided, because an allocator based on size classes could misbehave if one attempts to deallocate a block without providing a correct value for its size (i.e., one within the range &lt;code&gt;[l, u]&lt;/code&gt;).</source>
          <target state="translated">저급 및 상부 경계 (모두 &lt;code&gt;l&lt;/code&gt; 및 &lt;code&gt;u&lt;/code&gt; 중 하나의 시도는 그 크기 (즉, 범위 내의 하나에 대한 정확한 값을 제공하지 않고 블럭의 할당을 해제하는 경우 크기 등급에 기초하여 할당이 오작동 할 수 있으므로, 각각)이 제공된다 &lt;code&gt;[l, u]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="98967fc7894aa4615d5bff073afe78f05a767908" translate="yes" xml:space="preserve">
          <source>Both the reading and the writing portions of the &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; should be shut down.</source>
          <target state="translated">&lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; 의 읽기 및 쓰기 부분을 모두 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7bb49751d5e5b9335e672e163e91914b0f06be3" translate="yes" xml:space="preserve">
          <source>Both the stack and the heap are parts of memory that are available to your code to use at runtime, but they are structured in different ways. The stack stores values in the order it gets them and removes the values in the opposite order. This is referred to as &lt;em&gt;last in, first out&lt;/em&gt;. Think of a stack of plates: when you add more plates, you put them on top of the pile, and when you need a plate, you take one off the top. Adding or removing plates from the middle or bottom wouldn&amp;rsquo;t work as well! Adding data is called &lt;em&gt;pushing onto the stack&lt;/em&gt;, and removing data is called &lt;em&gt;popping off the stack&lt;/em&gt;.</source>
          <target state="translated">스택과 힙은 모두 런타임에 코드에서 사용할 수있는 메모리의 일부이지만 다른 방식으로 구성되어 있습니다. 스택은 값을 가져온 순서대로 저장하고 반대 순서로 값을 제거합니다. 이것을 &lt;em&gt;first in last out이라고&lt;/em&gt; 합니다. 접시 더미를 생각하십시오. 접시를 더 추가 할 때 더미 위에 놓고 접시가 필요할 때 하나를 제거합니다. 중간 또는 바닥에서 플레이트를 추가하거나 제거해도 효과가 없습니다! 데이터를 추가하는 &lt;em&gt;것을 스택으로 푸시하는 것&lt;/em&gt; , 데이터를 제거하는 &lt;em&gt;것을 스택&lt;/em&gt; 에서 &lt;em&gt;팝하는 것&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0d50912827dc83752805291122efdab8614525af" translate="yes" xml:space="preserve">
          <source>Both the starting and other pointer must be either in bounds or one byte past the end of the same allocated object.</source>
          <target state="translated">시작 포인터와 다른 포인터는 모두 같은 할당 된 객체의 끝을 지나는 경계 또는 1 바이트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="d01b29b32d289e0c8b9a18df5a84772808d7bfc2" translate="yes" xml:space="preserve">
          <source>Both the starting and other pointer must be either in bounds or one byte past the end of the same allocated object. Note that in Rust, every (stack-allocated) variable is considered a separate allocated object.</source>
          <target state="translated">시작 포인터와 다른 포인터는 모두 동일한 할당 된 개체의 끝을지나 1 바이트 또는 경계 내에 있어야합니다. Rust에서 모든 (스택 할당) 변수는 별도의 할당 된 객체로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="72784f6c1c0665f0bf4dbcd1fd7585be3cfa702f" translate="yes" xml:space="preserve">
          <source>Both the starting and resulting pointer must be either in bounds or one byte past the end of an allocated object. If either pointer is out of bounds or arithmetic overflow occurs then any further use of the returned value will result in undefined behavior.</source>
          <target state="translated">시작 및 결과 포인터는 모두 범위 내에 있거나 할당 된 객체의 끝을지나 1 바이트 여야합니다. 포인터가 범위를 벗어 났거나 산술 오버플로가 발생하면 반환 된 값을 더 이상 사용하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ab5604b532321bee04b244b342d737f8189eea86" translate="yes" xml:space="preserve">
          <source>Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object.</source>
          <target state="translated">시작 및 결과 포인터는 모두 동일한 할당 된 객체의 끝을 지나는 경계 또는 1 바이트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="b2aa47636e98a60617bcdd3e67a5924dfb004f66" translate="yes" xml:space="preserve">
          <source>Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object. Note that in Rust, every (stack-allocated) variable is considered a separate allocated object.</source>
          <target state="translated">시작 포인터와 결과 포인터는 모두 동일한 할당 된 개체의 끝을지나 1 바이트 또는 범위 내에 있어야합니다. Rust에서 모든 (스택 할당) 변수는 별도의 할당 된 객체로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="66fee1cf29e97c8fc0875ae5e9908b627fd1605d" translate="yes" xml:space="preserve">
          <source>Both types must have the same size. Neither the original, nor the result, may be an &lt;a href=&quot;https://doc.rust-lang.org/nomicon/what-unsafe-does.html&quot;&gt;invalid value&lt;/a&gt;.</source>
          <target state="translated">두 유형의 크기가 같아야합니다. 원본도 결과도 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/what-unsafe-does.html&quot;&gt;유효하지&lt;/a&gt; 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c346acf685cb1f6817015d7708b959e84444f26" translate="yes" xml:space="preserve">
          <source>Bound</source>
          <target state="translated">Bound</target>
        </trans-unit>
        <trans-unit id="6b7a8fef068d73e848dac8523afae549fc821d96" translate="yes" xml:space="preserve">
          <source>Bound::borrow</source>
          <target state="translated">Bound::borrow</target>
        </trans-unit>
        <trans-unit id="18bb2e890d75080b556aef676184c5919be5992a" translate="yes" xml:space="preserve">
          <source>Bound::borrow_mut</source>
          <target state="translated">Bound::borrow_mut</target>
        </trans-unit>
        <trans-unit id="377e882cd7fc9a872bb54ce900229dd706dfc18e" translate="yes" xml:space="preserve">
          <source>Bound::clone</source>
          <target state="translated">Bound::clone</target>
        </trans-unit>
        <trans-unit id="27441f23a3225df9857b23126eebcbeaa6dcfa57" translate="yes" xml:space="preserve">
          <source>Bound::clone_from</source>
          <target state="translated">Bound::clone_from</target>
        </trans-unit>
        <trans-unit id="d4f69fa455be1a2d7f74f09dcf28628a95d81806" translate="yes" xml:space="preserve">
          <source>Bound::clone_into</source>
          <target state="translated">Bound::clone_into</target>
        </trans-unit>
        <trans-unit id="252db2d859de80913734f1d7a97d46b455067071" translate="yes" xml:space="preserve">
          <source>Bound::cloned</source>
          <target state="translated">Bound::cloned</target>
        </trans-unit>
        <trans-unit id="46c76647f9ac933b457df321f87cbafee078c04b" translate="yes" xml:space="preserve">
          <source>Bound::eq</source>
          <target state="translated">Bound::eq</target>
        </trans-unit>
        <trans-unit id="109b368628394a6771e9026bb249cb9a770aa495" translate="yes" xml:space="preserve">
          <source>Bound::fmt</source>
          <target state="translated">Bound::fmt</target>
        </trans-unit>
        <trans-unit id="d2a47e1914c25c25b3e40fc39fb12d33547d7e82" translate="yes" xml:space="preserve">
          <source>Bound::from</source>
          <target state="translated">Bound::from</target>
        </trans-unit>
        <trans-unit id="ba919ff9d1df1744fb627fa7855b8f05cc2b77ed" translate="yes" xml:space="preserve">
          <source>Bound::hash</source>
          <target state="translated">Bound::hash</target>
        </trans-unit>
        <trans-unit id="5a473f87e1bb852dc398c279b415db545cd4b24e" translate="yes" xml:space="preserve">
          <source>Bound::hash_slice</source>
          <target state="translated">Bound::hash_slice</target>
        </trans-unit>
        <trans-unit id="54778a9e486243aa16573515109523bbf492d0d1" translate="yes" xml:space="preserve">
          <source>Bound::into</source>
          <target state="translated">Bound::into</target>
        </trans-unit>
        <trans-unit id="dedfd5e96791c9889a42b174f98bd419bce5e68f" translate="yes" xml:space="preserve">
          <source>Bound::ne</source>
          <target state="translated">Bound::ne</target>
        </trans-unit>
        <trans-unit id="ab242a98c5b08c66ef7dc6a8a0cb34b4b2961e44" translate="yes" xml:space="preserve">
          <source>Bound::to_owned</source>
          <target state="translated">Bound::to_owned</target>
        </trans-unit>
        <trans-unit id="9a69c2090e4312fb09b145cc8cc6bd670302d586" translate="yes" xml:space="preserve">
          <source>Bound::try_from</source>
          <target state="translated">Bound::try_from</target>
        </trans-unit>
        <trans-unit id="763620a7caa5bb18601b6f9a97d64ddf732e2329" translate="yes" xml:space="preserve">
          <source>Bound::try_into</source>
          <target state="translated">Bound::try_into</target>
        </trans-unit>
        <trans-unit id="f370fdaa52e7ec335a260ab2d97b2ca401271f1b" translate="yes" xml:space="preserve">
          <source>Bound::type_id</source>
          <target state="translated">Bound::type_id</target>
        </trans-unit>
        <trans-unit id="c5964dba854ca10e309192dd054d46319ddd1bae" translate="yes" xml:space="preserve">
          <source>Bounds are constraints on a type or trait. For example, if a bound is placed on the argument a function takes, types passed to that function must abide by that constraint.</source>
          <target state="translated">경계는 유형 또는 특성에 대한 제약입니다. 예를 들어, 함수가받는 인수에 바운드가 있으면 해당 함수에 전달 된 형식은 해당 제약 조건을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="ca6bc4b3d93728fa4fe8f6d78ae36c82b188ed72" translate="yes" xml:space="preserve">
          <source>Bounds on an item must be satisfied when using the item. When type checking and borrow checking a generic item, the bounds can be used to determine that a trait is implemented for a type. For example, given &lt;code&gt;Ty: Trait&lt;/code&gt;</source>
          <target state="translated">아이템을 사용할 때 아이템의 경계가 만족되어야합니다. 유형 검사 및 일반 항목 차용 검사시 경계를 사용하여 유형에 대해 특성이 구현되었는지 확인할 수 있습니다. 예를 들어 &lt;code&gt;Ty: Trait&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8db62bb4eebb31a7863a25492026fe5ef94ccb8d" translate="yes" xml:space="preserve">
          <source>Bounds that don't use the item's parameters or higher-ranked lifetimes are checked when the item is defined. It is an error for such a bound to be false.</source>
          <target state="translated">항목을 정의 할 때 항목의 매개 변수 또는 더 높은 순위의 수명을 사용하지 않는 바운드를 확인합니다. 그러한 경계가 거짓 인 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="4b064da5fe9593f583b40c21207783b175e1ebf2" translate="yes" xml:space="preserve">
          <source>Bounds written after declaring a &lt;a href=&quot;items/generics&quot;&gt;generic parameter&lt;/a&gt;: &lt;code&gt;fn f&amp;lt;A: Copy&amp;gt;() {}&lt;/code&gt; is the same as &lt;code&gt;fn f&amp;lt;A&amp;gt; where A: Copy () {}&lt;/code&gt;.</source>
          <target state="translated">선언 후 기록 경계 &lt;a href=&quot;items/generics&quot;&gt;일반 파라미터&lt;/a&gt; : &lt;code&gt;fn f&amp;lt;A: Copy&amp;gt;() {}&lt;/code&gt; 동일하다 &lt;code&gt;fn f&amp;lt;A&amp;gt; where A: Copy () {}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="239ca5767afac9641593464ce02bc454d6ac07a9" translate="yes" xml:space="preserve">
          <source>Box</source>
          <target state="translated">Box</target>
        </trans-unit>
        <trans-unit id="98f85596ae7b9b42504e10a1325d441abcd2486d" translate="yes" xml:space="preserve">
          <source>Box::all</source>
          <target state="translated">Box::all</target>
        </trans-unit>
        <trans-unit id="b639107f3271721c720775da7e802911f662b1b1" translate="yes" xml:space="preserve">
          <source>Box::any</source>
          <target state="translated">Box::any</target>
        </trans-unit>
        <trans-unit id="7c64d4849917073ddc48c9ebb00f360df4c9d7a4" translate="yes" xml:space="preserve">
          <source>Box::as_mut</source>
          <target state="translated">Box::as_mut</target>
        </trans-unit>
        <trans-unit id="6848e42541571d900c21f082d7585fb9168d4af7" translate="yes" xml:space="preserve">
          <source>Box::as_ref</source>
          <target state="translated">Box::as_ref</target>
        </trans-unit>
        <trans-unit id="6d56f42ac2a542e91194b361d21189ab4bd414b3" translate="yes" xml:space="preserve">
          <source>Box::borrow</source>
          <target state="translated">Box::borrow</target>
        </trans-unit>
        <trans-unit id="c99f2a149a7bc2bb960eba8eda77967bcecf0e8d" translate="yes" xml:space="preserve">
          <source>Box::borrow_mut</source>
          <target state="translated">Box::borrow_mut</target>
        </trans-unit>
        <trans-unit id="17f5075e3006cf9d119c727bb0e54e46c7eebaa6" translate="yes" xml:space="preserve">
          <source>Box::by_ref</source>
          <target state="translated">Box::by_ref</target>
        </trans-unit>
        <trans-unit id="61d60a2dfd95d2edba019ae7a505a5a8b6bad430" translate="yes" xml:space="preserve">
          <source>Box::bytes</source>
          <target state="translated">Box::bytes</target>
        </trans-unit>
        <trans-unit id="46fe884decfe5370e5c5fe2408915b53963bbffb" translate="yes" xml:space="preserve">
          <source>Box::call</source>
          <target state="translated">Box::call</target>
        </trans-unit>
        <trans-unit id="374988426e0ba138e6f583dbe0ce037ce343561c" translate="yes" xml:space="preserve">
          <source>Box::call_mut</source>
          <target state="translated">Box::call_mut</target>
        </trans-unit>
        <trans-unit id="221be09338afb54138c6ba69b6155871dd1f1604" translate="yes" xml:space="preserve">
          <source>Box::call_once</source>
          <target state="translated">Box::call_once</target>
        </trans-unit>
        <trans-unit id="212e1a3fbba385ceea9d2d039d37d904ae132bdd" translate="yes" xml:space="preserve">
          <source>Box::cause</source>
          <target state="translated">Box::cause</target>
        </trans-unit>
        <trans-unit id="1eb80191936cdac28f33c70fb0561232cbe1a0ce" translate="yes" xml:space="preserve">
          <source>Box::chain</source>
          <target state="translated">Box::chain</target>
        </trans-unit>
        <trans-unit id="9a890655e788211db3d21c5daf10e4fa6bedbf64" translate="yes" xml:space="preserve">
          <source>Box::clamp</source>
          <target state="translated">Box::clamp</target>
        </trans-unit>
        <trans-unit id="332b16f27092792c1ac7aba3b13ed4a2b647f865" translate="yes" xml:space="preserve">
          <source>Box::clone</source>
          <target state="translated">Box::clone</target>
        </trans-unit>
        <trans-unit id="0511825945441353f0c46a388bf94987ad6afb32" translate="yes" xml:space="preserve">
          <source>Box::clone_from</source>
          <target state="translated">Box::clone_from</target>
        </trans-unit>
        <trans-unit id="df3fac12d073e919e309cdc2ac6374e292180e78" translate="yes" xml:space="preserve">
          <source>Box::clone_into</source>
          <target state="translated">Box::clone_into</target>
        </trans-unit>
        <trans-unit id="6e363e6d0300a78f70074a806f60975e864accad" translate="yes" xml:space="preserve">
          <source>Box::cloned</source>
          <target state="translated">Box::cloned</target>
        </trans-unit>
        <trans-unit id="6c96b7576d584aee2f26ba1a32a3f04121f43e20" translate="yes" xml:space="preserve">
          <source>Box::cmp</source>
          <target state="translated">Box::cmp</target>
        </trans-unit>
        <trans-unit id="eeef833143ebcf0bc697aec2eefdc455624f9e0d" translate="yes" xml:space="preserve">
          <source>Box::collect</source>
          <target state="translated">Box::collect</target>
        </trans-unit>
        <trans-unit id="3d0f23afd6563472c47a167b48b8410fc559e492" translate="yes" xml:space="preserve">
          <source>Box::consume</source>
          <target state="translated">Box::consume</target>
        </trans-unit>
        <trans-unit id="44105eeec746662536d53672c3fb78098daee296" translate="yes" xml:space="preserve">
          <source>Box::copied</source>
          <target state="translated">Box::copied</target>
        </trans-unit>
        <trans-unit id="7ad1e95ce02daa64c1eaef18f06b9d8a7b568791" translate="yes" xml:space="preserve">
          <source>Box::count</source>
          <target state="translated">Box::count</target>
        </trans-unit>
        <trans-unit id="63ba5f4100a0be0c367e10e279bbb76a90044076" translate="yes" xml:space="preserve">
          <source>Box::cycle</source>
          <target state="translated">Box::cycle</target>
        </trans-unit>
        <trans-unit id="3100809b3c22540251ee4d32f870f0ab5d85f812" translate="yes" xml:space="preserve">
          <source>Box::default</source>
          <target state="translated">Box::default</target>
        </trans-unit>
        <trans-unit id="d2afb24813ad916ee3f3c876745772187d20e4b6" translate="yes" xml:space="preserve">
          <source>Box::deref</source>
          <target state="translated">Box::deref</target>
        </trans-unit>
        <trans-unit id="c38310d47b15e572611b4edc0c34463c00ac8351" translate="yes" xml:space="preserve">
          <source>Box::deref_mut</source>
          <target state="translated">Box::deref_mut</target>
        </trans-unit>
        <trans-unit id="4407e689e2360934dc281ec09f440aa221be5ae6" translate="yes" xml:space="preserve">
          <source>Box::description</source>
          <target state="translated">Box::description</target>
        </trans-unit>
        <trans-unit id="3166dd8642b65175a3bd7c7a52199fb715fe0594" translate="yes" xml:space="preserve">
          <source>Box::downcast</source>
          <target state="translated">Box::downcast</target>
        </trans-unit>
        <trans-unit id="daa5d80c59542cc920cd455f7d64b23c983bc609" translate="yes" xml:space="preserve">
          <source>Box::drop</source>
          <target state="translated">Box::drop</target>
        </trans-unit>
        <trans-unit id="1ce09716c9c1deae7f81c32dcf52fa616b12ca02" translate="yes" xml:space="preserve">
          <source>Box::enumerate</source>
          <target state="translated">Box::enumerate</target>
        </trans-unit>
        <trans-unit id="6cf03ef281bd05acc9e8788a558b01545153452e" translate="yes" xml:space="preserve">
          <source>Box::eq</source>
          <target state="translated">Box::eq</target>
        </trans-unit>
        <trans-unit id="4d3c429c86bcb5b6eb5c6bb097bc1d76c3b6d725" translate="yes" xml:space="preserve">
          <source>Box::fill_buf</source>
          <target state="translated">Box::fill_buf</target>
        </trans-unit>
        <trans-unit id="e0cfe090654acd2813dda2cadb04ff611bd40f8c" translate="yes" xml:space="preserve">
          <source>Box::filter</source>
          <target state="translated">Box::filter</target>
        </trans-unit>
        <trans-unit id="883f1c107d0f7a023ce3ace96cd45f32b3a24f77" translate="yes" xml:space="preserve">
          <source>Box::filter_map</source>
          <target state="translated">Box::filter_map</target>
        </trans-unit>
        <trans-unit id="8dba1be2d1b661c2a19ed51cf35f61687ebb811c" translate="yes" xml:space="preserve">
          <source>Box::find</source>
          <target state="translated">Box::find</target>
        </trans-unit>
        <trans-unit id="f1e4c766b00488cdb2e145cf4a27a074f88b9608" translate="yes" xml:space="preserve">
          <source>Box::find_map</source>
          <target state="translated">Box::find_map</target>
        </trans-unit>
        <trans-unit id="c5e9fddfd660282ca666cc6d744b46cd9a98281c" translate="yes" xml:space="preserve">
          <source>Box::finish</source>
          <target state="translated">Box::finish</target>
        </trans-unit>
        <trans-unit id="7698c71e0db1c73d3407ac25452c69edf519bc43" translate="yes" xml:space="preserve">
          <source>Box::flat_map</source>
          <target state="translated">Box::flat_map</target>
        </trans-unit>
        <trans-unit id="59e78e2254012fa056fb63d3af090ff23d9caa18" translate="yes" xml:space="preserve">
          <source>Box::flatten</source>
          <target state="translated">Box::flatten</target>
        </trans-unit>
        <trans-unit id="a6f7e58af02021c1636cef25915365d21c74a8a2" translate="yes" xml:space="preserve">
          <source>Box::flush</source>
          <target state="translated">Box::flush</target>
        </trans-unit>
        <trans-unit id="c6784df312e8ae8f90011ca22e8d36adb66a847a" translate="yes" xml:space="preserve">
          <source>Box::fmt</source>
          <target state="translated">Box::fmt</target>
        </trans-unit>
        <trans-unit id="fddbdef17bce1a8df59157b8fd1db42560d5f3ee" translate="yes" xml:space="preserve">
          <source>Box::fold</source>
          <target state="translated">Box::fold</target>
        </trans-unit>
        <trans-unit id="0a52ad01f142af48e3794dd7e59fc9bc3c7aa5d4" translate="yes" xml:space="preserve">
          <source>Box::for_each</source>
          <target state="translated">Box::for_each</target>
        </trans-unit>
        <trans-unit id="ed62e9121c4c62c0d5ce944ae44d5048012950db" translate="yes" xml:space="preserve">
          <source>Box::from</source>
          <target state="translated">Box::from</target>
        </trans-unit>
        <trans-unit id="91aab981ee80cfea73883f72f3f4a7df87328afd" translate="yes" xml:space="preserve">
          <source>Box::from_iter</source>
          <target state="translated">Box::from_iter</target>
        </trans-unit>
        <trans-unit id="99a56fd56f3eda7092816760238ede7c3fa6109f" translate="yes" xml:space="preserve">
          <source>Box::from_raw</source>
          <target state="translated">Box::from_raw</target>
        </trans-unit>
        <trans-unit id="10348aa1512f4c519b5613b846a2d8d6cfc47b88" translate="yes" xml:space="preserve">
          <source>Box::fuse</source>
          <target state="translated">Box::fuse</target>
        </trans-unit>
        <trans-unit id="530d37fa415cfa7c32ec4b55571698e45da6f959" translate="yes" xml:space="preserve">
          <source>Box::ge</source>
          <target state="translated">Box::ge</target>
        </trans-unit>
        <trans-unit id="4b72a4352f4fe91f47f069cdabc6e6ad95f13b44" translate="yes" xml:space="preserve">
          <source>Box::gt</source>
          <target state="translated">Box::gt</target>
        </trans-unit>
        <trans-unit id="16c6635f4bb22fdb3cea4763415a3155c214ed75" translate="yes" xml:space="preserve">
          <source>Box::hash</source>
          <target state="translated">Box::hash</target>
        </trans-unit>
        <trans-unit id="4c2a4b460b5d8fc9bdda66cc71714fbab479852a" translate="yes" xml:space="preserve">
          <source>Box::hash_slice</source>
          <target state="translated">Box::hash_slice</target>
        </trans-unit>
        <trans-unit id="343ef75a47ac9840e34ddf7a2da0d02c25787582" translate="yes" xml:space="preserve">
          <source>Box::initializer</source>
          <target state="translated">Box::initializer</target>
        </trans-unit>
        <trans-unit id="63ff0ff3838d20603f1ee804508fc3e64e303af2" translate="yes" xml:space="preserve">
          <source>Box::inspect</source>
          <target state="translated">Box::inspect</target>
        </trans-unit>
        <trans-unit id="85607e14d6de81746b803858c2540ca8c6b44bdb" translate="yes" xml:space="preserve">
          <source>Box::into</source>
          <target state="translated">Box::into</target>
        </trans-unit>
        <trans-unit id="f6b1af13daabe54761e736d7c80500ab6b9a1674" translate="yes" xml:space="preserve">
          <source>Box::into_iter</source>
          <target state="translated">Box::into_iter</target>
        </trans-unit>
        <trans-unit id="acbaecb1989ceef80f562e795d009f33656980ca" translate="yes" xml:space="preserve">
          <source>Box::into_pin</source>
          <target state="translated">Box::into_pin</target>
        </trans-unit>
        <trans-unit id="4842429f228dc17504f648e08a5f4f16e0e2062a" translate="yes" xml:space="preserve">
          <source>Box::into_raw</source>
          <target state="translated">Box::into_raw</target>
        </trans-unit>
        <trans-unit id="3f79bc4ecb72c296f646e58c0e20ae529797f781" translate="yes" xml:space="preserve">
          <source>Box::into_raw_non_null</source>
          <target state="translated">Box::into_raw_non_null</target>
        </trans-unit>
        <trans-unit id="3614510072231db3137f0d7aeb928f934f1c493d" translate="yes" xml:space="preserve">
          <source>Box::into_searcher</source>
          <target state="translated">Box::into_searcher</target>
        </trans-unit>
        <trans-unit id="2a8c6b52f333bc0cef92fffa23a800dc8255b691" translate="yes" xml:space="preserve">
          <source>Box::is_contained_in</source>
          <target state="translated">Box::is_contained_in</target>
        </trans-unit>
        <trans-unit id="6f2c2c3465fb0d25bc14172b3cdf438dd8946893" translate="yes" xml:space="preserve">
          <source>Box::is_empty</source>
          <target state="translated">Box::is_empty</target>
        </trans-unit>
        <trans-unit id="5ce85dca8b5589117e52c9eb46ed6631b186778a" translate="yes" xml:space="preserve">
          <source>Box::is_prefix_of</source>
          <target state="translated">Box::is_prefix_of</target>
        </trans-unit>
        <trans-unit id="b2d0a3538bcce4d4341580322555cb175af9e055" translate="yes" xml:space="preserve">
          <source>Box::is_sorted</source>
          <target state="translated">Box::is_sorted</target>
        </trans-unit>
        <trans-unit id="e8bc76461809058c2bf78bd03616e55f959cee1e" translate="yes" xml:space="preserve">
          <source>Box::is_sorted_by</source>
          <target state="translated">Box::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="0a88b0e90b45af6841206b9222039635add3e64f" translate="yes" xml:space="preserve">
          <source>Box::is_sorted_by_key</source>
          <target state="translated">Box::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="a72dc555efdbfa80a6b0d5c0b4f285602f05c856" translate="yes" xml:space="preserve">
          <source>Box::is_suffix_of</source>
          <target state="translated">Box::is_suffix_of</target>
        </trans-unit>
        <trans-unit id="e5727693a6c4cd3248cc40c999eef24607bc94c4" translate="yes" xml:space="preserve">
          <source>Box::last</source>
          <target state="translated">Box::last</target>
        </trans-unit>
        <trans-unit id="d894e0ab37daa6ed36ffcb6dc6f6ae6feafe4d29" translate="yes" xml:space="preserve">
          <source>Box::le</source>
          <target state="translated">Box::le</target>
        </trans-unit>
        <trans-unit id="bb0f72b159e3eafd1c056e394655cd200d490416" translate="yes" xml:space="preserve">
          <source>Box::leak</source>
          <target state="translated">Box::leak</target>
        </trans-unit>
        <trans-unit id="d677d8cc4fbf16dda95f7cc9f6f227fc9bf5458e" translate="yes" xml:space="preserve">
          <source>Box::len</source>
          <target state="translated">Box::len</target>
        </trans-unit>
        <trans-unit id="45bad95b762a8b026bd24017358dab88a4d6860e" translate="yes" xml:space="preserve">
          <source>Box::lines</source>
          <target state="translated">Box::lines</target>
        </trans-unit>
        <trans-unit id="72b25c9787fb55646beeb56c75cec4a153ebed4b" translate="yes" xml:space="preserve">
          <source>Box::lt</source>
          <target state="translated">Box::lt</target>
        </trans-unit>
        <trans-unit id="f2618ca0d7141ef535495cca35bfb5aa17708bc5" translate="yes" xml:space="preserve">
          <source>Box::map</source>
          <target state="translated">Box::map</target>
        </trans-unit>
        <trans-unit id="0bc41a6cab2d616f4a773cadf7a4a0287ec2ab6e" translate="yes" xml:space="preserve">
          <source>Box::max</source>
          <target state="translated">Box::max</target>
        </trans-unit>
        <trans-unit id="b5a62311ec4389dcea655a4a653acc770ae70df8" translate="yes" xml:space="preserve">
          <source>Box::max_by</source>
          <target state="translated">Box::max_by</target>
        </trans-unit>
        <trans-unit id="d0583d8c8a9191551534a635b566f913b18db0e0" translate="yes" xml:space="preserve">
          <source>Box::max_by_key</source>
          <target state="translated">Box::max_by_key</target>
        </trans-unit>
        <trans-unit id="5516ccddf3095fdf20b85d48497a76f13db9f3ab" translate="yes" xml:space="preserve">
          <source>Box::min</source>
          <target state="translated">Box::min</target>
        </trans-unit>
        <trans-unit id="57731c7eaf53528b46c94a8f5b04067977541b8e" translate="yes" xml:space="preserve">
          <source>Box::min_by</source>
          <target state="translated">Box::min_by</target>
        </trans-unit>
        <trans-unit id="5e6b2f4822e5c3d83d1318a14c7f1a3668b8120b" translate="yes" xml:space="preserve">
          <source>Box::min_by_key</source>
          <target state="translated">Box::min_by_key</target>
        </trans-unit>
        <trans-unit id="4df5d8b53f02075451eb004c4d2840a8ab301c06" translate="yes" xml:space="preserve">
          <source>Box::ne</source>
          <target state="translated">Box::ne</target>
        </trans-unit>
        <trans-unit id="1cb94d98d7b75dacb7e7e360644f9c7e2642829f" translate="yes" xml:space="preserve">
          <source>Box::new</source>
          <target state="translated">Box::new</target>
        </trans-unit>
        <trans-unit id="773581cb76ebc7fffb4b726bb7032d772321f18e" translate="yes" xml:space="preserve">
          <source>Box::next</source>
          <target state="translated">Box::next</target>
        </trans-unit>
        <trans-unit id="39a9d8e0d1ae73478ca6c4fc28570233d4f2d14d" translate="yes" xml:space="preserve">
          <source>Box::next_back</source>
          <target state="translated">Box::next_back</target>
        </trans-unit>
        <trans-unit id="ca8b4b8a75b7ab2fc6b63b0e3e0d3d3ac349fcbc" translate="yes" xml:space="preserve">
          <source>Box::nth</source>
          <target state="translated">Box::nth</target>
        </trans-unit>
        <trans-unit id="be1768702f171a2bca631f2dada36573e66e8f4c" translate="yes" xml:space="preserve">
          <source>Box::nth_back</source>
          <target state="translated">Box::nth_back</target>
        </trans-unit>
        <trans-unit id="33b92276543ebbb381ab00cfcca61326250e018b" translate="yes" xml:space="preserve">
          <source>Box::partial_cmp</source>
          <target state="translated">Box::partial_cmp</target>
        </trans-unit>
        <trans-unit id="5b3f3a9486d3aeafde57fba826b8530482d99578" translate="yes" xml:space="preserve">
          <source>Box::partition</source>
          <target state="translated">Box::partition</target>
        </trans-unit>
        <trans-unit id="25aab183ce8da5ce9aed71f8d43b59e269353ccd" translate="yes" xml:space="preserve">
          <source>Box::peekable</source>
          <target state="translated">Box::peekable</target>
        </trans-unit>
        <trans-unit id="7019628ce869ea317ecd4415266260c422269408" translate="yes" xml:space="preserve">
          <source>Box::pin</source>
          <target state="translated">Box::pin</target>
        </trans-unit>
        <trans-unit id="a64f04fc6eed8dea5f38347397b9cc737e345f6e" translate="yes" xml:space="preserve">
          <source>Box::poll</source>
          <target state="translated">Box::poll</target>
        </trans-unit>
        <trans-unit id="66f2f092e4949c0626ea7b22dc1d4ebcf3d8b35e" translate="yes" xml:space="preserve">
          <source>Box::position</source>
          <target state="translated">Box::position</target>
        </trans-unit>
        <trans-unit id="57081d934e6bca1d6c19e21b481ef88439c1ee29" translate="yes" xml:space="preserve">
          <source>Box::product</source>
          <target state="translated">Box::product</target>
        </trans-unit>
        <trans-unit id="ea6a41b1734b82596faa66a349b6d33c1eda5c8d" translate="yes" xml:space="preserve">
          <source>Box::read</source>
          <target state="translated">Box::read</target>
        </trans-unit>
        <trans-unit id="69cd72a2d8a6222800a925198c4edf4f739e25b2" translate="yes" xml:space="preserve">
          <source>Box::read_exact</source>
          <target state="translated">Box::read_exact</target>
        </trans-unit>
        <trans-unit id="59c4bf761ac478484370f960e729c2e181694f6b" translate="yes" xml:space="preserve">
          <source>Box::read_line</source>
          <target state="translated">Box::read_line</target>
        </trans-unit>
        <trans-unit id="225ac79c4a0e4ea7979de019038d83deebd58806" translate="yes" xml:space="preserve">
          <source>Box::read_to_end</source>
          <target state="translated">Box::read_to_end</target>
        </trans-unit>
        <trans-unit id="205cd1994c8e50578c7806614a239f1080cfe645" translate="yes" xml:space="preserve">
          <source>Box::read_to_string</source>
          <target state="translated">Box::read_to_string</target>
        </trans-unit>
        <trans-unit id="4c38943094e12187cb5a7db1759bb984e9e47e21" translate="yes" xml:space="preserve">
          <source>Box::read_until</source>
          <target state="translated">Box::read_until</target>
        </trans-unit>
        <trans-unit id="16e2f9a63976d963a9dadcb35033a821c2fd7839" translate="yes" xml:space="preserve">
          <source>Box::read_vectored</source>
          <target state="translated">Box::read_vectored</target>
        </trans-unit>
        <trans-unit id="be7cce92911dcff76ffbac8e0427e42b77defdcf" translate="yes" xml:space="preserve">
          <source>Box::resume</source>
          <target state="translated">Box::resume</target>
        </trans-unit>
        <trans-unit id="ba5e0dd2c587258859a5333578ab5d32da0e967a" translate="yes" xml:space="preserve">
          <source>Box::rev</source>
          <target state="translated">Box::rev</target>
        </trans-unit>
        <trans-unit id="481e8d3053595c86bd37ed7ee98159dd62804d15" translate="yes" xml:space="preserve">
          <source>Box::rfind</source>
          <target state="translated">Box::rfind</target>
        </trans-unit>
        <trans-unit id="54e7ee564e103a781122b5dcc4e5a645a42b47bd" translate="yes" xml:space="preserve">
          <source>Box::rfold</source>
          <target state="translated">Box::rfold</target>
        </trans-unit>
        <trans-unit id="3a8d8f3503f8d9c26ee23ddbea5e59c9d42ec95c" translate="yes" xml:space="preserve">
          <source>Box::rposition</source>
          <target state="translated">Box::rposition</target>
        </trans-unit>
        <trans-unit id="9ac7a2e2ffe1a294d38f090349bc38f76aec74fc" translate="yes" xml:space="preserve">
          <source>Box::scan</source>
          <target state="translated">Box::scan</target>
        </trans-unit>
        <trans-unit id="96b0a5023a90b5ef63be3a93fee81259968341fc" translate="yes" xml:space="preserve">
          <source>Box::seek</source>
          <target state="translated">Box::seek</target>
        </trans-unit>
        <trans-unit id="74f4a9a8cd31d8cee51b7c80648f8274c91f190c" translate="yes" xml:space="preserve">
          <source>Box::size_hint</source>
          <target state="translated">Box::size_hint</target>
        </trans-unit>
        <trans-unit id="d72a34eac3284a3b3a67c2581cf2c305c16367ed" translate="yes" xml:space="preserve">
          <source>Box::skip</source>
          <target state="translated">Box::skip</target>
        </trans-unit>
        <trans-unit id="ba0e0743f07d0bf5ee26ccb3b8bb456ca5c70a56" translate="yes" xml:space="preserve">
          <source>Box::skip_while</source>
          <target state="translated">Box::skip_while</target>
        </trans-unit>
        <trans-unit id="b4722d8b75a76a5d774eca59914b8e1f4a48cca6" translate="yes" xml:space="preserve">
          <source>Box::source</source>
          <target state="translated">Box::source</target>
        </trans-unit>
        <trans-unit id="6e2bc46519fb279c9f87dbfe9d290154772983d7" translate="yes" xml:space="preserve">
          <source>Box::split</source>
          <target state="translated">Box::split</target>
        </trans-unit>
        <trans-unit id="225ff95675533f61ead8e887a7efbf592dd8a88f" translate="yes" xml:space="preserve">
          <source>Box::step_by</source>
          <target state="translated">Box::step_by</target>
        </trans-unit>
        <trans-unit id="33aa1522a0173cb9f96a98672c2ecf9a96e294c9" translate="yes" xml:space="preserve">
          <source>Box::stream_len</source>
          <target state="translated">Box::stream_len</target>
        </trans-unit>
        <trans-unit id="8371eaea74f952c9831c9ca9261a497c2c38eef9" translate="yes" xml:space="preserve">
          <source>Box::stream_position</source>
          <target state="translated">Box::stream_position</target>
        </trans-unit>
        <trans-unit id="6a478949bfaddf9def7439c2f20d3359d537230c" translate="yes" xml:space="preserve">
          <source>Box::sum</source>
          <target state="translated">Box::sum</target>
        </trans-unit>
        <trans-unit id="3c2abaa93fcb6bfd17a1261c06f7ff566f12ec7e" translate="yes" xml:space="preserve">
          <source>Box::take</source>
          <target state="translated">Box::take</target>
        </trans-unit>
        <trans-unit id="83963a222e9c0ad7e60f41957e4013159d79d919" translate="yes" xml:space="preserve">
          <source>Box::take_while</source>
          <target state="translated">Box::take_while</target>
        </trans-unit>
        <trans-unit id="97ebc881815c3d1efcf8d9cc64f80490df826bb5" translate="yes" xml:space="preserve">
          <source>Box::to_owned</source>
          <target state="translated">Box::to_owned</target>
        </trans-unit>
        <trans-unit id="e508f4dc0d39c5987210d26aebaa3c2b4fce966c" translate="yes" xml:space="preserve">
          <source>Box::to_string</source>
          <target state="translated">Box::to_string</target>
        </trans-unit>
        <trans-unit id="34d3b2ca86670782e3636c41900e981e1db73054" translate="yes" xml:space="preserve">
          <source>Box::try_fold</source>
          <target state="translated">Box::try_fold</target>
        </trans-unit>
        <trans-unit id="4db298c22768eb776696c78cedb8c0ae9382c043" translate="yes" xml:space="preserve">
          <source>Box::try_for_each</source>
          <target state="translated">Box::try_for_each</target>
        </trans-unit>
        <trans-unit id="7ac87b84f99e12af4f84963a001dac862d957033" translate="yes" xml:space="preserve">
          <source>Box::try_from</source>
          <target state="translated">Box::try_from</target>
        </trans-unit>
        <trans-unit id="1190ad3065eb03769687c99bebeafccd52070617" translate="yes" xml:space="preserve">
          <source>Box::try_into</source>
          <target state="translated">Box::try_into</target>
        </trans-unit>
        <trans-unit id="190b967a40f310701525c6f92772eaa4b9d2bd91" translate="yes" xml:space="preserve">
          <source>Box::try_rfold</source>
          <target state="translated">Box::try_rfold</target>
        </trans-unit>
        <trans-unit id="e36c00466fad6adf381b361fedd323c0c0614989" translate="yes" xml:space="preserve">
          <source>Box::type_id</source>
          <target state="translated">Box::type_id</target>
        </trans-unit>
        <trans-unit id="04ea83b7ee01a03b421cd55b0df6992834e06afd" translate="yes" xml:space="preserve">
          <source>Box::unzip</source>
          <target state="translated">Box::unzip</target>
        </trans-unit>
        <trans-unit id="f72865295b955292507dfb70d5c51051dce354f9" translate="yes" xml:space="preserve">
          <source>Box::write</source>
          <target state="translated">Box::write</target>
        </trans-unit>
        <trans-unit id="a94c15e5cef594b7628ec618df5db798a9a567ec" translate="yes" xml:space="preserve">
          <source>Box::write_all</source>
          <target state="translated">Box::write_all</target>
        </trans-unit>
        <trans-unit id="d6fe1ce7bcfe4c269caf62f37074c2cd561a9897" translate="yes" xml:space="preserve">
          <source>Box::write_fmt</source>
          <target state="translated">Box::write_fmt</target>
        </trans-unit>
        <trans-unit id="56912c1495209bdea8854c66cc01bcdf4719afb0" translate="yes" xml:space="preserve">
          <source>Box::write_i128</source>
          <target state="translated">Box::write_i128</target>
        </trans-unit>
        <trans-unit id="d8e0c426cff723fe078d8e082d1a63933f6fa573" translate="yes" xml:space="preserve">
          <source>Box::write_i16</source>
          <target state="translated">Box::write_i16</target>
        </trans-unit>
        <trans-unit id="b68b48a66507e48ff6196e7556e4456e2d325cec" translate="yes" xml:space="preserve">
          <source>Box::write_i32</source>
          <target state="translated">Box::write_i32</target>
        </trans-unit>
        <trans-unit id="1e11f9892c3582d233d19c49b718f4eb56d5716f" translate="yes" xml:space="preserve">
          <source>Box::write_i64</source>
          <target state="translated">Box::write_i64</target>
        </trans-unit>
        <trans-unit id="2c4fbd1565526cebde3d781e65ee574490c3d5c4" translate="yes" xml:space="preserve">
          <source>Box::write_i8</source>
          <target state="translated">Box::write_i8</target>
        </trans-unit>
        <trans-unit id="be62022bb4b9817d94a1db6940ba1ef163a6bd39" translate="yes" xml:space="preserve">
          <source>Box::write_isize</source>
          <target state="translated">Box::write_isize</target>
        </trans-unit>
        <trans-unit id="2096d69d1a029ab28f266f5d6155819f93d05482" translate="yes" xml:space="preserve">
          <source>Box::write_u128</source>
          <target state="translated">Box::write_u128</target>
        </trans-unit>
        <trans-unit id="4bae89c6a373e3f8634ed54d131ceda19618fee5" translate="yes" xml:space="preserve">
          <source>Box::write_u16</source>
          <target state="translated">Box::write_u16</target>
        </trans-unit>
        <trans-unit id="71e4bac27351110d97b5fef0556d35917fbefb90" translate="yes" xml:space="preserve">
          <source>Box::write_u32</source>
          <target state="translated">Box::write_u32</target>
        </trans-unit>
        <trans-unit id="5abd678e805a3ff64f5524701426655948efcbfa" translate="yes" xml:space="preserve">
          <source>Box::write_u64</source>
          <target state="translated">Box::write_u64</target>
        </trans-unit>
        <trans-unit id="cf853a1d87ba811daf4dddf980c6bca3ee9f7551" translate="yes" xml:space="preserve">
          <source>Box::write_u8</source>
          <target state="translated">Box::write_u8</target>
        </trans-unit>
        <trans-unit id="570c96fc9a4d7852a96d0f8be3123d2af8641252" translate="yes" xml:space="preserve">
          <source>Box::write_usize</source>
          <target state="translated">Box::write_usize</target>
        </trans-unit>
        <trans-unit id="8c5f38686db9dd2e3d3338655cf9aa7453b4beec" translate="yes" xml:space="preserve">
          <source>Box::write_vectored</source>
          <target state="translated">Box::write_vectored</target>
        </trans-unit>
        <trans-unit id="58b9235154ec59648f9006bdb375b1a70414fdbc" translate="yes" xml:space="preserve">
          <source>Box::zip</source>
          <target state="translated">Box::zip</target>
        </trans-unit>
        <trans-unit id="1f1c95cf9dbdc5a10d4adddb4bd7ed9693d03299" translate="yes" xml:space="preserve">
          <source>Boxes don&amp;rsquo;t have performance overhead, other than storing their data on the heap instead of on the stack. But they don&amp;rsquo;t have many extra capabilities either. You&amp;rsquo;ll use them most often in these situations:</source>
          <target state="translated">박스는 데이터를 스택 대신 힙에 저장하는 것 외에는 성능 오버 헤드가 없습니다. 그러나 추가 기능이 많지 않습니다. 다음과 같은 상황에서 가장 자주 사용합니다.</target>
        </trans-unit>
        <trans-unit id="aae55045560cd96320cd77d712fdc24ac8ab83dc" translate="yes" xml:space="preserve">
          <source>Boxes provide only the indirection and heap allocation; they don&amp;rsquo;t have any other special capabilities, like those we&amp;rsquo;ll see with the other smart pointer types. They also don&amp;rsquo;t have any performance overhead that these special capabilities incur, so they can be useful in cases like the cons list where the indirection is the only feature we need. We&amp;rsquo;ll look at more use cases for boxes in Chapter 17, too.</source>
          <target state="translated">상자는 간접 및 힙 할당 만 제공합니다. 다른 스마트 포인터 유형에서 볼 수있는 것과 같은 다른 특수 기능은 없습니다. 또한 이러한 특수 기능으로 인해 발생하는 성능 오버 헤드가 없으므로 간접적 인 기능 만 필요한 단점 목록과 같은 경우에 유용 할 수 있습니다. 17 장에서 더 많은 유스 케이스를 살펴볼 것이다.</target>
        </trans-unit>
        <trans-unit id="e42a1e70b4003a66462fd8b1b6f1d551425eedd6" translate="yes" xml:space="preserve">
          <source>Bracket</source>
          <target state="translated">Bracket</target>
        </trans-unit>
        <trans-unit id="acb83a12e9c51df23e23f19306bba0bcb0739442" translate="yes" xml:space="preserve">
          <source>Bracket punctuation is used in various parts of the grammar. An open bracket must always be paired with a close bracket. Brackets and the tokens within them are referred to as &quot;token trees&quot; in &lt;a href=&quot;macros-by-example&quot;&gt;macros&lt;/a&gt;. The three types of brackets are:</source>
          <target state="translated">대괄호 문장 부호는 문법의 다양한 부분에 사용됩니다. 열린 브래킷은 항상 닫힌 브래킷과 쌍을 이루어야합니다. 대괄호와 그 안의 토큰은 &lt;a href=&quot;macros-by-example&quot;&gt;매크로&lt;/a&gt; 에서 &quot;토큰 트리&quot;라고 합니다 . 세 가지 유형의 괄호는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a3ba41cdc1bb875b6f34a0f7504f134b4c82482" translate="yes" xml:space="preserve">
          <source>Breaking cycles with &lt;code&gt;Weak&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 속보 사이클</target>
        </trans-unit>
        <trans-unit id="d3dfd81f5eef2bda69d2fe0e0bb117502ea1d295" translate="yes" xml:space="preserve">
          <source>Breaking the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#pointer-aliasing-rules&quot;&gt;pointer aliasing rules&lt;/a&gt; on accesses through raw pointers; a subset of the rules used by C.</source>
          <target state="translated">원시 포인터를 통한 액세스에 대한 &lt;a href=&quot;http://llvm.org/docs/LangRef.html#pointer-aliasing-rules&quot;&gt;포인터 앨리어싱 규칙&lt;/a&gt; 위반 C가 사용하는 규칙의 하위 집합</target>
        </trans-unit>
        <trans-unit id="f28978f6dd2c2e9099f5d850ca4e0176d065b5c7" translate="yes" xml:space="preserve">
          <source>Breaking the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#pointer-aliasing-rules&quot;&gt;pointer aliasing rules&lt;/a&gt;. &lt;code&gt;&amp;amp;mut T&lt;/code&gt; and &lt;code&gt;&amp;amp;T&lt;/code&gt; follow LLVM&amp;rsquo;s scoped &lt;a href=&quot;http://llvm.org/docs/LangRef.html#noalias&quot;&gt;noalias&lt;/a&gt; model, except if the &lt;code&gt;&amp;amp;T&lt;/code&gt; contains an &lt;a href=&quot;../std/cell/struct.unsafecell&quot;&gt;&lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파괴 &lt;a href=&quot;http://llvm.org/docs/LangRef.html#pointer-aliasing-rules&quot;&gt;포인터 앨리어싱 규칙을&lt;/a&gt; . &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 및 &lt;code&gt;&amp;amp;T&lt;/code&gt; 는 &lt;code&gt;&amp;amp;T&lt;/code&gt; 에 &lt;a href=&quot;../std/cell/struct.unsafecell&quot;&gt; &lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt; 가 포함 된 경우를 제외하고 LLVM의 범위 지정 &lt;a href=&quot;http://llvm.org/docs/LangRef.html#noalias&quot;&gt;noalias&lt;/a&gt; 모델을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="9d59f171a0fa025c3f69ece6ee2db2dff781f37b" translate="yes" xml:space="preserve">
          <source>Breaking the &lt;a href=&quot;https://llvm.org/docs/LangRef.html#pointer-aliasing-rules&quot;&gt;pointer aliasing rules&lt;/a&gt;. &lt;code&gt;&amp;amp;mut T&lt;/code&gt; and &lt;code&gt;&amp;amp;T&lt;/code&gt; follow LLVM&amp;rsquo;s scoped &lt;a href=&quot;https://llvm.org/docs/LangRef.html#noalias&quot;&gt;noalias&lt;/a&gt; model, except if the &lt;code&gt;&amp;amp;T&lt;/code&gt; contains an &lt;a href=&quot;../std/cell/struct.unsafecell&quot;&gt;&lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파괴 &lt;a href=&quot;https://llvm.org/docs/LangRef.html#pointer-aliasing-rules&quot;&gt;포인터 앨리어싱 규칙을&lt;/a&gt; . &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 및 &lt;code&gt;&amp;amp;T&lt;/code&gt; 는 &lt;code&gt;&amp;amp;T&lt;/code&gt; 에 &lt;a href=&quot;../std/cell/struct.unsafecell&quot;&gt; &lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt; 가 포함 된 경우를 제외하고 LLVM의 범위 지정 &lt;a href=&quot;https://llvm.org/docs/LangRef.html#noalias&quot;&gt;noalias&lt;/a&gt; 모델을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="0a02e7efbe4ea860996a720e8eb0268c763977ce" translate="yes" xml:space="preserve">
          <source>Bringing Paths into Scope with the &lt;code id=&quot;bringing-paths-into-scope-with-the-use-keyword&quot;&gt;use&lt;/code&gt; Keyword</source>
          <target state="translated">&lt;code id=&quot;bringing-paths-into-scope-with-the-use-keyword&quot;&gt;use&lt;/code&gt; 키워드를 사용 하여 경로로 범위 가져 오기</target>
        </trans-unit>
        <trans-unit id="de407e52f1ad71f30175ca74f0b3e4d7802969ce" translate="yes" xml:space="preserve">
          <source>BufRead</source>
          <target state="translated">BufRead</target>
        </trans-unit>
        <trans-unit id="8b3cd1796576fb8d47f83bdc75d05d245fd7a0c8" translate="yes" xml:space="preserve">
          <source>BufRead::consume</source>
          <target state="translated">BufRead::consume</target>
        </trans-unit>
        <trans-unit id="4d60e62622ce6e5b2975982fde7166d4b99157d4" translate="yes" xml:space="preserve">
          <source>BufRead::fill_buf</source>
          <target state="translated">BufRead::fill_buf</target>
        </trans-unit>
        <trans-unit id="6454a42afc6b7f969ba1e20a170de8e3b928a4de" translate="yes" xml:space="preserve">
          <source>BufRead::lines</source>
          <target state="translated">BufRead::lines</target>
        </trans-unit>
        <trans-unit id="a22b5e33039f43dd9be253a22ba693c7821fc40d" translate="yes" xml:space="preserve">
          <source>BufRead::read_line</source>
          <target state="translated">BufRead::read_line</target>
        </trans-unit>
        <trans-unit id="138f0ef5dd5df09e1375e2687113f694b0a114b9" translate="yes" xml:space="preserve">
          <source>BufRead::read_until</source>
          <target state="translated">BufRead::read_until</target>
        </trans-unit>
        <trans-unit id="afb4634d5bb2cfba4eca69e0cbaed77038a91269" translate="yes" xml:space="preserve">
          <source>BufRead::split</source>
          <target state="translated">BufRead::split</target>
        </trans-unit>
        <trans-unit id="232d94f57b3293280b5ad36975b73111f3c6dfa0" translate="yes" xml:space="preserve">
          <source>BufReader</source>
          <target state="translated">BufReader</target>
        </trans-unit>
        <trans-unit id="cb39e958e39ef179b2597f4ef6e19c98ca4fc4d5" translate="yes" xml:space="preserve">
          <source>BufReader and BufWriter</source>
          <target state="translated">BufReader와 BufWriter</target>
        </trans-unit>
        <trans-unit id="30498daca312f601d5026a239b4f9877ca9ee7af" translate="yes" xml:space="preserve">
          <source>BufReader::borrow</source>
          <target state="translated">BufReader::borrow</target>
        </trans-unit>
        <trans-unit id="46b667a41b30eb52818f00950425d6b07af15300" translate="yes" xml:space="preserve">
          <source>BufReader::borrow_mut</source>
          <target state="translated">BufReader::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6abdb3c76752714b4a06017a9219fa1f25214580" translate="yes" xml:space="preserve">
          <source>BufReader::buffer</source>
          <target state="translated">BufReader::buffer</target>
        </trans-unit>
        <trans-unit id="8a5b395c3f2044900bdcdf2f9ebf60ebd12d7819" translate="yes" xml:space="preserve">
          <source>BufReader::by_ref</source>
          <target state="translated">BufReader::by_ref</target>
        </trans-unit>
        <trans-unit id="6e8f568e8d439bbf991a8a007e038953a8f83b25" translate="yes" xml:space="preserve">
          <source>BufReader::bytes</source>
          <target state="translated">BufReader::bytes</target>
        </trans-unit>
        <trans-unit id="111bdc9e9c0fa8f11edaf0bb19720dadd4d441c2" translate="yes" xml:space="preserve">
          <source>BufReader::chain</source>
          <target state="translated">BufReader::chain</target>
        </trans-unit>
        <trans-unit id="698d6344bd09525535c43a69fdbd270c56fe0314" translate="yes" xml:space="preserve">
          <source>BufReader::consume</source>
          <target state="translated">BufReader::consume</target>
        </trans-unit>
        <trans-unit id="d753e03e42fea9b39b03754697893d50f45f25ac" translate="yes" xml:space="preserve">
          <source>BufReader::fill_buf</source>
          <target state="translated">BufReader::fill_buf</target>
        </trans-unit>
        <trans-unit id="4002c8a4271852b7c3dc4a005ad07b6218b6d9be" translate="yes" xml:space="preserve">
          <source>BufReader::fmt</source>
          <target state="translated">BufReader::fmt</target>
        </trans-unit>
        <trans-unit id="588a32e3d887d2adc2a42cbd852909e916738169" translate="yes" xml:space="preserve">
          <source>BufReader::from</source>
          <target state="translated">BufReader::from</target>
        </trans-unit>
        <trans-unit id="a565473360a69fedb15e98a54613f95fb3b56dfd" translate="yes" xml:space="preserve">
          <source>BufReader::get_mut</source>
          <target state="translated">BufReader::get_mut</target>
        </trans-unit>
        <trans-unit id="5594c6c6ae64375a5d272ff27f83db1d85077211" translate="yes" xml:space="preserve">
          <source>BufReader::get_ref</source>
          <target state="translated">BufReader::get_ref</target>
        </trans-unit>
        <trans-unit id="1e90aba1df228b628f7c7f3e2ab8e5bae2aa2919" translate="yes" xml:space="preserve">
          <source>BufReader::initializer</source>
          <target state="translated">BufReader::initializer</target>
        </trans-unit>
        <trans-unit id="9dfefe7d50b25c323182190a7738d15409036741" translate="yes" xml:space="preserve">
          <source>BufReader::into</source>
          <target state="translated">BufReader::into</target>
        </trans-unit>
        <trans-unit id="7af433e3bd4af270fc73a60a513c7c29c50b1691" translate="yes" xml:space="preserve">
          <source>BufReader::into_inner</source>
          <target state="translated">BufReader::into_inner</target>
        </trans-unit>
        <trans-unit id="015fca5819c404e186e79049e56378d531c3a868" translate="yes" xml:space="preserve">
          <source>BufReader::lines</source>
          <target state="translated">BufReader::lines</target>
        </trans-unit>
        <trans-unit id="261dc9dd5d56c7bd6b24e8c4987e0bacc36d731b" translate="yes" xml:space="preserve">
          <source>BufReader::new</source>
          <target state="translated">BufReader::new</target>
        </trans-unit>
        <trans-unit id="474a9aceabea88ca192dfa1182137bb4a5716f95" translate="yes" xml:space="preserve">
          <source>BufReader::read</source>
          <target state="translated">BufReader::read</target>
        </trans-unit>
        <trans-unit id="8fb011a69fd96b7a252fae27bab3618d9916ea15" translate="yes" xml:space="preserve">
          <source>BufReader::read_exact</source>
          <target state="translated">BufReader::read_exact</target>
        </trans-unit>
        <trans-unit id="043d1ca9b3f16093053e017427e6b59fce891b84" translate="yes" xml:space="preserve">
          <source>BufReader::read_line</source>
          <target state="translated">BufReader::read_line</target>
        </trans-unit>
        <trans-unit id="0cf3db2b85b3a36c4fe27bb356f920ec381e6a39" translate="yes" xml:space="preserve">
          <source>BufReader::read_to_end</source>
          <target state="translated">BufReader::read_to_end</target>
        </trans-unit>
        <trans-unit id="c014e4bd71ac8b1202507174a0590c77d72041f7" translate="yes" xml:space="preserve">
          <source>BufReader::read_to_string</source>
          <target state="translated">BufReader::read_to_string</target>
        </trans-unit>
        <trans-unit id="bf7f4de24e9cecff5fc9e9886289abdb93482e12" translate="yes" xml:space="preserve">
          <source>BufReader::read_until</source>
          <target state="translated">BufReader::read_until</target>
        </trans-unit>
        <trans-unit id="f1ac9fb503b6a30e103494d5ed7e213639e7e66d" translate="yes" xml:space="preserve">
          <source>BufReader::read_vectored</source>
          <target state="translated">BufReader::read_vectored</target>
        </trans-unit>
        <trans-unit id="b8518cd0ac9ab115738a223331f69d244e196ae1" translate="yes" xml:space="preserve">
          <source>BufReader::seek</source>
          <target state="translated">BufReader::seek</target>
        </trans-unit>
        <trans-unit id="99a5d03be61779b43803bbfee3dbfdce8a113d6d" translate="yes" xml:space="preserve">
          <source>BufReader::seek_relative</source>
          <target state="translated">BufReader::seek_relative</target>
        </trans-unit>
        <trans-unit id="43d93e963620260620093d161241006ece71cae8" translate="yes" xml:space="preserve">
          <source>BufReader::split</source>
          <target state="translated">BufReader::split</target>
        </trans-unit>
        <trans-unit id="e0ac1010e5c4fb0756b34d4592bffff3a410e86d" translate="yes" xml:space="preserve">
          <source>BufReader::stream_len</source>
          <target state="translated">BufReader::stream_len</target>
        </trans-unit>
        <trans-unit id="ca5bf56485cb95f3a60dbe8260139b54147feee2" translate="yes" xml:space="preserve">
          <source>BufReader::stream_position</source>
          <target state="translated">BufReader::stream_position</target>
        </trans-unit>
        <trans-unit id="70fc9c931ae2fc7872314fb275a9549018b33695" translate="yes" xml:space="preserve">
          <source>BufReader::take</source>
          <target state="translated">BufReader::take</target>
        </trans-unit>
        <trans-unit id="4d06dc939cd79e29aeb98db83609f9129bc27937" translate="yes" xml:space="preserve">
          <source>BufReader::try_from</source>
          <target state="translated">BufReader::try_from</target>
        </trans-unit>
        <trans-unit id="9cf0b40fa99c93bde7e68af3011e8e90b8e27ca1" translate="yes" xml:space="preserve">
          <source>BufReader::try_into</source>
          <target state="translated">BufReader::try_into</target>
        </trans-unit>
        <trans-unit id="c0358cb609681901098856ec216b94cf80a87fed" translate="yes" xml:space="preserve">
          <source>BufReader::type_id</source>
          <target state="translated">BufReader::type_id</target>
        </trans-unit>
        <trans-unit id="76a07371464a5bc5c675c8a1103f1bfcdcb90928" translate="yes" xml:space="preserve">
          <source>BufReader::with_capacity</source>
          <target state="translated">BufReader::with_capacity</target>
        </trans-unit>
        <trans-unit id="eb547b03e4fb9da19636fe86aa475ec275f26aea" translate="yes" xml:space="preserve">
          <source>BufWriter</source>
          <target state="translated">BufWriter</target>
        </trans-unit>
        <trans-unit id="c0fe0ec21d292209b8751b7b3bbc325ff8c3dfdd" translate="yes" xml:space="preserve">
          <source>BufWriter::borrow</source>
          <target state="translated">BufWriter::borrow</target>
        </trans-unit>
        <trans-unit id="2adb49e625ca6186b4c41c7d1737d0e2634f05fb" translate="yes" xml:space="preserve">
          <source>BufWriter::borrow_mut</source>
          <target state="translated">BufWriter::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c3ac09907f785459d01129cbdf9eb5797fc53c72" translate="yes" xml:space="preserve">
          <source>BufWriter::buffer</source>
          <target state="translated">BufWriter::buffer</target>
        </trans-unit>
        <trans-unit id="a82155a82c33131bd98d9e864c9f25f36481894a" translate="yes" xml:space="preserve">
          <source>BufWriter::by_ref</source>
          <target state="translated">BufWriter::by_ref</target>
        </trans-unit>
        <trans-unit id="31f24b83e544c2b05b1fbfd0a2b99edbc784d128" translate="yes" xml:space="preserve">
          <source>BufWriter::drop</source>
          <target state="translated">BufWriter::drop</target>
        </trans-unit>
        <trans-unit id="70ed6813c46c4821d4c3ceb922ec9e68c5b46a68" translate="yes" xml:space="preserve">
          <source>BufWriter::flush</source>
          <target state="translated">BufWriter::flush</target>
        </trans-unit>
        <trans-unit id="e322ea4bb3c530e22344a65d6d425dbe30797f57" translate="yes" xml:space="preserve">
          <source>BufWriter::fmt</source>
          <target state="translated">BufWriter::fmt</target>
        </trans-unit>
        <trans-unit id="ae28528b6704424a2fa6c25aacbe28d13e5e2328" translate="yes" xml:space="preserve">
          <source>BufWriter::from</source>
          <target state="translated">BufWriter::from</target>
        </trans-unit>
        <trans-unit id="8f2da80a85c436ae0e170c960857685d65f2c7fa" translate="yes" xml:space="preserve">
          <source>BufWriter::get_mut</source>
          <target state="translated">BufWriter::get_mut</target>
        </trans-unit>
        <trans-unit id="ae8ffbf65314cc80e578ef8e21fd9216b111a598" translate="yes" xml:space="preserve">
          <source>BufWriter::get_ref</source>
          <target state="translated">BufWriter::get_ref</target>
        </trans-unit>
        <trans-unit id="c2bb0d2480650e2a139a3ac97642b7fac7000daf" translate="yes" xml:space="preserve">
          <source>BufWriter::into</source>
          <target state="translated">BufWriter::into</target>
        </trans-unit>
        <trans-unit id="a254cafb67eb39c14e0dd9b99733426aaca0cce1" translate="yes" xml:space="preserve">
          <source>BufWriter::into_inner</source>
          <target state="translated">BufWriter::into_inner</target>
        </trans-unit>
        <trans-unit id="0d50fa17068770487074b33532e6632cdc747a7d" translate="yes" xml:space="preserve">
          <source>BufWriter::new</source>
          <target state="translated">BufWriter::new</target>
        </trans-unit>
        <trans-unit id="8acb320f731050f7faa230a67adf20edf2a91802" translate="yes" xml:space="preserve">
          <source>BufWriter::seek</source>
          <target state="translated">BufWriter::seek</target>
        </trans-unit>
        <trans-unit id="0bc901a9b97e04338c295bff32fc59abb34658a0" translate="yes" xml:space="preserve">
          <source>BufWriter::stream_len</source>
          <target state="translated">BufWriter::stream_len</target>
        </trans-unit>
        <trans-unit id="aef24c4f9e117e8540e0bceb74c3c1079dca3c4a" translate="yes" xml:space="preserve">
          <source>BufWriter::stream_position</source>
          <target state="translated">BufWriter::stream_position</target>
        </trans-unit>
        <trans-unit id="c3a46f518f714d6be6bad831bd9935498f844ddb" translate="yes" xml:space="preserve">
          <source>BufWriter::try_from</source>
          <target state="translated">BufWriter::try_from</target>
        </trans-unit>
        <trans-unit id="d12f6fca054766123bb42142de217202212ff449" translate="yes" xml:space="preserve">
          <source>BufWriter::try_into</source>
          <target state="translated">BufWriter::try_into</target>
        </trans-unit>
        <trans-unit id="8af6d7318c0dbf54915f72f0993742b25781c289" translate="yes" xml:space="preserve">
          <source>BufWriter::type_id</source>
          <target state="translated">BufWriter::type_id</target>
        </trans-unit>
        <trans-unit id="7f3e3e6e70dd67251f7be13ef8952baade49da92" translate="yes" xml:space="preserve">
          <source>BufWriter::with_capacity</source>
          <target state="translated">BufWriter::with_capacity</target>
        </trans-unit>
        <trans-unit id="04509abb12d543e33b20e9a92d6a3a9ce8f7becf" translate="yes" xml:space="preserve">
          <source>BufWriter::write</source>
          <target state="translated">BufWriter::write</target>
        </trans-unit>
        <trans-unit id="7904c0be7d3caaf53c1b1cdb84256218cdaa0206" translate="yes" xml:space="preserve">
          <source>BufWriter::write_all</source>
          <target state="translated">BufWriter::write_all</target>
        </trans-unit>
        <trans-unit id="1656f0c433aa13f34246f1c4269f0f93dd7be7a2" translate="yes" xml:space="preserve">
          <source>BufWriter::write_fmt</source>
          <target state="translated">BufWriter::write_fmt</target>
        </trans-unit>
        <trans-unit id="34b5f10d3b6a9f9a1dbde260a02e2b2206afca57" translate="yes" xml:space="preserve">
          <source>BufWriter::write_vectored</source>
          <target state="translated">BufWriter::write_vectored</target>
        </trans-unit>
        <trans-unit id="930e02964f6bea5730ba5c65d98e4f502a26535a" translate="yes" xml:space="preserve">
          <source>Buffering behavior:</source>
          <target state="translated">버퍼링 동작 :</target>
        </trans-unit>
        <trans-unit id="c236b467cd75457e8973d308434bf8606946e8b7" translate="yes" xml:space="preserve">
          <source>Bugs that happen only in certain situations and are hard to reproduce and fix reliably</source>
          <target state="translated">특정 상황에서만 발생하고 안정적으로 재현 및 수정하기 어려운 버그</target>
        </trans-unit>
        <trans-unit id="c123195418c1603314c7d0aac5cbca5fe90623f5" translate="yes" xml:space="preserve">
          <source>Build the thread with &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; and pass the desired stack size to &lt;a href=&quot;struct.builder#method.stack_size&quot;&gt;&lt;code&gt;Builder::stack_size&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; 로&lt;/a&gt; 스레드를 빌드하고 원하는 스택 크기를 &lt;a href=&quot;struct.builder#method.stack_size&quot;&gt; &lt;code&gt;Builder::stack_size&lt;/code&gt; &lt;/a&gt; 로 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="97ac06ac37241fed7f3a8298db93e9bbc2d242b6" translate="yes" xml:space="preserve">
          <source>BuildHasher</source>
          <target state="translated">BuildHasher</target>
        </trans-unit>
        <trans-unit id="aaba5ed0cc289313d5a04c86f6c4f1a124a0ff97" translate="yes" xml:space="preserve">
          <source>BuildHasher::build_hasher</source>
          <target state="translated">BuildHasher::build_hasher</target>
        </trans-unit>
        <trans-unit id="6972ec88ec81efc886ecfcc5774a514315adaba3" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault</source>
          <target state="translated">BuildHasherDefault</target>
        </trans-unit>
        <trans-unit id="3b3934e3550748f2a7b58e6593d8d16993a3f234" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::borrow</source>
          <target state="translated">BuildHasherDefault::borrow</target>
        </trans-unit>
        <trans-unit id="f55eee0b0d59698190e3d541df7887945783f03c" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::borrow_mut</source>
          <target state="translated">BuildHasherDefault::borrow_mut</target>
        </trans-unit>
        <trans-unit id="9a17d9b6eba5bdb1a3199b04f87f79fe486b4427" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::build_hasher</source>
          <target state="translated">BuildHasherDefault::build_hasher</target>
        </trans-unit>
        <trans-unit id="3378e7d2427ed05874269a577e08932c432618d4" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::clone</source>
          <target state="translated">BuildHasherDefault::clone</target>
        </trans-unit>
        <trans-unit id="010bd4789bebb3ef5a2996e2b1be4fdb5f283ea4" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::clone_from</source>
          <target state="translated">BuildHasherDefault::clone_from</target>
        </trans-unit>
        <trans-unit id="e746cdbc6b12a8b851323bb7c641b3af90edca43" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::clone_into</source>
          <target state="translated">BuildHasherDefault::clone_into</target>
        </trans-unit>
        <trans-unit id="52e1f05a4973d5628107a410168778a062f1bf48" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::default</source>
          <target state="translated">BuildHasherDefault::default</target>
        </trans-unit>
        <trans-unit id="805858a4f2f04c612c4359d30c11b771cbbf2670" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::eq</source>
          <target state="translated">BuildHasherDefault::eq</target>
        </trans-unit>
        <trans-unit id="a489341b69637e6985483361e2ba9bd4e930658e" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::fmt</source>
          <target state="translated">BuildHasherDefault::fmt</target>
        </trans-unit>
        <trans-unit id="7dc7ccadfebe0f90b3109993492f2510fdea1e97" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::from</source>
          <target state="translated">BuildHasherDefault::from</target>
        </trans-unit>
        <trans-unit id="b214b1f4540f86833e16b1674e570a06864bb810" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::into</source>
          <target state="translated">BuildHasherDefault::into</target>
        </trans-unit>
        <trans-unit id="3124ec3e2cb6d3f2d095ae07854f9d9f327708f0" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::ne</source>
          <target state="translated">BuildHasherDefault::ne</target>
        </trans-unit>
        <trans-unit id="3e47f2f0c29a4813a680f3068d5450f9f31a9f4d" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::to_owned</source>
          <target state="translated">BuildHasherDefault::to_owned</target>
        </trans-unit>
        <trans-unit id="36b39c1513469044cd761bd64a80f0c4a9902c0a" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::try_from</source>
          <target state="translated">BuildHasherDefault::try_from</target>
        </trans-unit>
        <trans-unit id="6b3bf2bc5c2ef00504b85f45d8356c19b7018273" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::try_into</source>
          <target state="translated">BuildHasherDefault::try_into</target>
        </trans-unit>
        <trans-unit id="c27d762f5384033048f5c3b6349a62aa6d74a8ff" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::type_id</source>
          <target state="translated">BuildHasherDefault::type_id</target>
        </trans-unit>
        <trans-unit id="4759bf14d7a511508e86c343c934894b6e8db533" translate="yes" xml:space="preserve">
          <source>Builder</source>
          <target state="translated">Builder</target>
        </trans-unit>
        <trans-unit id="004d20f8006198411988eea17651cdf655cc4482" translate="yes" xml:space="preserve">
          <source>Builder methods are provided to change these defaults and otherwise configure the process.</source>
          <target state="translated">이러한 기본값을 변경하고 프로세스를 구성하기 위해 빌더 메소드가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="e817e9752d05edc9cdf54971d106867fe037888c" translate="yes" xml:space="preserve">
          <source>Builder::borrow</source>
          <target state="translated">Builder::borrow</target>
        </trans-unit>
        <trans-unit id="94bb1918ddf68bff15586c79a231491744cc5934" translate="yes" xml:space="preserve">
          <source>Builder::borrow_mut</source>
          <target state="translated">Builder::borrow_mut</target>
        </trans-unit>
        <trans-unit id="f7d73832b38ead1d7c82f9bab9bcef56bfdd3661" translate="yes" xml:space="preserve">
          <source>Builder::fmt</source>
          <target state="translated">Builder::fmt</target>
        </trans-unit>
        <trans-unit id="e7b6a7ffdb6a96182506cdb6f845b1b5f8083113" translate="yes" xml:space="preserve">
          <source>Builder::from</source>
          <target state="translated">Builder::from</target>
        </trans-unit>
        <trans-unit id="c646de2596ac054c72581071ffd5afa499f6b38e" translate="yes" xml:space="preserve">
          <source>Builder::into</source>
          <target state="translated">Builder::into</target>
        </trans-unit>
        <trans-unit id="25158ae2faf4770ff3631697763e4f649748735c" translate="yes" xml:space="preserve">
          <source>Builder::name</source>
          <target state="translated">Builder::name</target>
        </trans-unit>
        <trans-unit id="a2fdc90cb0342f15602e461493244bbda8d11380" translate="yes" xml:space="preserve">
          <source>Builder::new</source>
          <target state="translated">Builder::new</target>
        </trans-unit>
        <trans-unit id="a5c0502ee99c0af55e1f1a9757c75ceb61f0e365" translate="yes" xml:space="preserve">
          <source>Builder::spawn</source>
          <target state="translated">Builder::spawn</target>
        </trans-unit>
        <trans-unit id="d28e4127e494164e81f16f028a028d507078db82" translate="yes" xml:space="preserve">
          <source>Builder::spawn_unchecked</source>
          <target state="translated">Builder::spawn_unchecked</target>
        </trans-unit>
        <trans-unit id="79550b63f469160e0886e9b4b6fb46be05f50a29" translate="yes" xml:space="preserve">
          <source>Builder::stack_size</source>
          <target state="translated">Builder::stack_size</target>
        </trans-unit>
        <trans-unit id="96b55ab18feea8a44f0d0d096d39f3af52a2e131" translate="yes" xml:space="preserve">
          <source>Builder::try_from</source>
          <target state="translated">Builder::try_from</target>
        </trans-unit>
        <trans-unit id="77877ce5fde9f3242e4b6af9ede23afdcb23f7db" translate="yes" xml:space="preserve">
          <source>Builder::try_into</source>
          <target state="translated">Builder::try_into</target>
        </trans-unit>
        <trans-unit id="6247790fc07eec46462f144d1ed4dedc1cb780eb" translate="yes" xml:space="preserve">
          <source>Builder::type_id</source>
          <target state="translated">Builder::type_id</target>
        </trans-unit>
        <trans-unit id="3bf882813c900c304e2632ba4dffda0948193670" translate="yes" xml:space="preserve">
          <source>Building a Single-Threaded Web Server</source>
          <target state="translated">단일 스레드 웹 서버 구축</target>
        </trans-unit>
        <trans-unit id="253443e211e899460868732743aa41ea5e5f944a" translate="yes" xml:space="preserve">
          <source>Building and Running a Cargo Project</source>
          <target state="translated">화물 프로젝트 구축 및 운영</target>
        </trans-unit>
        <trans-unit id="1916501f700c410fd7bea37cffb5b95a293dc381" translate="yes" xml:space="preserve">
          <source>Building for Release</source>
          <target state="translated">출시를위한 건물</target>
        </trans-unit>
        <trans-unit id="0ad2d2fb6e92d2b6c89500bfdd36e70bf53d31d2" translate="yes" xml:space="preserve">
          <source>Building the &lt;code id=&quot;building-the-threadpool-struct-using-compiler-driven-development&quot;&gt;ThreadPool&lt;/code&gt; Struct Using Compiler Driven Development</source>
          <target state="translated">컴파일러 중심 개발을 사용 하여 &lt;code id=&quot;building-the-threadpool-struct-using-compiler-driven-development&quot;&gt;ThreadPool&lt;/code&gt; 구조 구축</target>
        </trans-unit>
        <trans-unit id="20da59d3c16c7bbc43ecdc04a9ed654b4ef329d2" translate="yes" xml:space="preserve">
          <source>Built in &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;negation&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;arithmetic, logical&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;comparison&lt;/a&gt; or &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean&lt;/a&gt; operators used on integer and floating point types, &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">정수, 부동 소수점 유형 &lt;code&gt;bool&lt;/code&gt; 및 &lt;code&gt;char&lt;/code&gt; 에 사용되는 &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;부정&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;산술, 논리&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;비교&lt;/a&gt; 또는 &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;게으른 부울&lt;/a&gt; 연산자가 내장되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89e36b16f75fb9635eac3a25e8d8d0058e587b9c" translate="yes" xml:space="preserve">
          <source>Built-in &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;negation&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;arithmetic&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;logical&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;comparison&lt;/a&gt; or &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean&lt;/a&gt; operators used on integer and floating point types, &lt;code&gt;bool&lt;/code&gt;, and &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">정수 및 부동 소수점 유형, &lt;code&gt;bool&lt;/code&gt; 및 &lt;code&gt;char&lt;/code&gt; 에 사용되는 내장 &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;부정&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;산술&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;논리&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;비교&lt;/a&gt; 또는 &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;지연 부울&lt;/a&gt; 연산자 .</target>
        </trans-unit>
        <trans-unit id="dd0f66ac77e682a233d8ddb635dd00b67a90ab76" translate="yes" xml:space="preserve">
          <source>Built-in attributes</source>
          <target state="translated">내장 속성</target>
        </trans-unit>
        <trans-unit id="1dac87263c85b5a8f82799db9805041e3360af6d" translate="yes" xml:space="preserve">
          <source>Built-in attributes index</source>
          <target state="translated">내장 속성 색인</target>
        </trans-unit>
        <trans-unit id="3b55724056edf0c168a344b916c46cc4f550e2f6" translate="yes" xml:space="preserve">
          <source>Built-in types are tightly integrated into the language, in nontrivial ways that are not possible to emulate in user-defined types. User-defined types have limited capabilities.</source>
          <target state="translated">내장 타입은 사용자 정의 타입으로는 흉내낼 수없는 사소한 방식으로 언어에 밀접하게 통합되어 있습니다. 사용자 정의 유형에는 기능이 제한되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c6bb0e181beb9458279ac502a39fa01da91b8fe" translate="yes" xml:space="preserve">
          <source>But &lt;code&gt;drain_filter&lt;/code&gt; is easier to use. &lt;code&gt;drain_filter&lt;/code&gt; is also more efficient, because it can backshift the elements of the array in bulk.</source>
          <target state="translated">그러나 &lt;code&gt;drain_filter&lt;/code&gt; 가 더 사용하기 쉽습니다. &lt;code&gt;drain_filter&lt;/code&gt; 는 어레이의 요소를 대량으로 백 시프트 할 수 있기 때문에 더욱 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="ab56537680f4a94c82e8bdfe87270e033203a404" translate="yes" xml:space="preserve">
          <source>But Rust isn&amp;rsquo;t limited to low-level systems programming. It&amp;rsquo;s expressive and ergonomic enough to make CLI apps, web servers, and many other kinds of code quite pleasant to write &amp;mdash; you&amp;rsquo;ll find simple examples of both later in the book. Working with Rust allows you to build skills that transfer from one domain to another; you can learn Rust by writing a web app, then apply those same skills to target your Raspberry Pi.</source>
          <target state="translated">그러나 Rust는 저수준 시스템 프로그래밍에만 국한되지 않습니다. CLI 앱, 웹 서버 및 기타 여러 종류의 코드를 작성하기에 충분할 정도로 표현력 있고 인체 공학적입니다.이 책의 뒷부분에서 간단한 예제를 찾을 수 있습니다. Rust를 사용하면 한 도메인에서 다른 도메인으로 이전하는 기술을 개발할 수 있습니다. 웹 앱을 작성하여 Rust를 배우고 동일한 기술을 적용하여 Raspberry Pi를 타겟팅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9bc5d1aa2362cf2e31f1ee01e7de1ef4e0a2d19" translate="yes" xml:space="preserve">
          <source>But again, the compiler gives us a helpful note:</source>
          <target state="translated">그러나 다시 컴파일러는 유용한 메모를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b5737faee592fa19b426fe0f0898f071a967af3e" translate="yes" xml:space="preserve">
          <source>But are the two implementations truly equivalent? The intuitive assumption might be that the more low-level loop will be faster. Let&amp;rsquo;s talk about performance.</source>
          <target state="translated">그러나 두 구현이 실제로 동등한가? 직관적 인 가정은 더 낮은 수준의 루프가 더 빠를 것이라고 가정 할 수 있습니다. 성능에 대해 이야기합시다.</target>
        </trans-unit>
        <trans-unit id="d5233374bc70817ae86cada9a53675c9bf92e0c7" translate="yes" xml:space="preserve">
          <source>But be sure to remember that valid Unicode scalar values may be made up of more than 1 byte.</source>
          <target state="translated">그러나 유효한 유니 코드 스칼라 값은 1 바이트 이상으로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f72ae39afec7a59586e27c05c7b3e5e6adecf93" translate="yes" xml:space="preserve">
          <source>But before we get started, we should mention one detail: the method we&amp;rsquo;ll use won&amp;rsquo;t be the best way to build a web server with Rust. A number of production-ready crates are available on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; that provide more complete web server and thread pool implementations than we&amp;rsquo;ll build.</source>
          <target state="translated">그러나 시작하기 전에 한 가지 세부 사항을 언급해야합니다. 사용할 방법이 Rust로 웹 서버를 구축하는 가장 좋은 방법은 아닙니다. 생산 준비 상자의 숫자에서 사용할 수있는 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; 에서 우리가 구축 할 것보다 더 완벽한 웹 서버 및 스레드 풀 구현을 제공하는 많은 .</target>
        </trans-unit>
        <trans-unit id="2b053f01b33d2a55c1c75c2c507abf7135d9a246" translate="yes" xml:space="preserve">
          <source>But by default, Cargo will only look for versions greater than &lt;code&gt;0.3.0&lt;/code&gt; and less than &lt;code&gt;0.4.0&lt;/code&gt;. If the &lt;code&gt;rand&lt;/code&gt; crate has released two new versions, &lt;code&gt;0.3.15&lt;/code&gt; and &lt;code&gt;0.4.0&lt;/code&gt;, you would see the following if you ran &lt;code&gt;cargo update&lt;/code&gt;:</source>
          <target state="translated">그러나 기본적으로 Cargo는 &lt;code&gt;0.3.0&lt;/code&gt; 보다 크고 &lt;code&gt;0.4.0&lt;/code&gt; 보다 작은 버전 만 찾습니다 . 는 IF &lt;code&gt;rand&lt;/code&gt; 상자는 두 가지 새로운 버전을 출시했습니다 &lt;code&gt;0.3.15&lt;/code&gt; 과 &lt;code&gt;0.4.0&lt;/code&gt; 을 , 당신은 당신이 실행 한 경우 다음을 참조 할 &lt;code&gt;cargo update&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="041215ad4156f8d52d141c6b1d6e0db864c4a8a2" translate="yes" xml:space="preserve">
          <source>But by default, Cargo will only look for versions greater than &lt;code&gt;0.5.5&lt;/code&gt; and less than &lt;code&gt;0.6.0&lt;/code&gt;. If the &lt;code&gt;rand&lt;/code&gt; crate has released two new versions, &lt;code&gt;0.5.6&lt;/code&gt; and &lt;code&gt;0.6.0&lt;/code&gt;, you would see the following if you ran &lt;code&gt;cargo update&lt;/code&gt;:</source>
          <target state="translated">그러나 기본적으로 Cargo는 &lt;code&gt;0.5.5&lt;/code&gt; 보다 크고 &lt;code&gt;0.6.0&lt;/code&gt; 보다 작은 버전 만 찾습니다 . 는 IF &lt;code&gt;rand&lt;/code&gt; 상자는 두 가지 새로운 버전을 출시했습니다 &lt;code&gt;0.5.6&lt;/code&gt; 과 &lt;code&gt;0.6.0&lt;/code&gt; 을 , 당신은 당신이 실행 한 경우 다음을 참조 할 &lt;code&gt;cargo update&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="48958431e414a42071536586c915fe4c3022be36" translate="yes" xml:space="preserve">
          <source>But for now, let&amp;rsquo;s work around this problem using a handy trick. We can tell Rust explicitly that in this case we can take ownership of the value inside the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; using &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;; then, once we have ownership of the closure, we can call it. This involves defining a new trait &lt;code&gt;FnBox&lt;/code&gt; with the method &lt;code&gt;call_box&lt;/code&gt; that will use &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; in its signature, defining &lt;code&gt;FnBox&lt;/code&gt; for any type that implements &lt;code&gt;FnOnce()&lt;/code&gt;, changing our type alias to use the new trait, and changing &lt;code&gt;Worker&lt;/code&gt; to use the &lt;code&gt;call_box&lt;/code&gt; method. These changes are shown in Listing 20-21.</source>
          <target state="translated">그러나 지금은 편리한 트릭을 사용하여이 문제를 해결해 봅시다. Rust에게이 경우 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 사용하여 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 내부의 값을 소유 할 수 있다고 명시 적으로 말할 수 있습니다 . Box &amp;lt;Self&amp;gt; ; 그런 다음 클로저 소유권을 가지면이를 호출 할 수 있습니다. 여기에는 서명에 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 를 사용 하는 &lt;code&gt;call_box&lt;/code&gt; 메소드 를 사용 하여 새 특성 &lt;code&gt;FnBox&lt;/code&gt; 를 정의하고 , &lt;code&gt;FnOnce()&lt;/code&gt; 를 구현하는 모든 유형에 대해 &lt;code&gt;FnBox&lt;/code&gt; 를 정의 하고, 새 특성을 사용하도록 유형 별명을 변경하고, &lt;code&gt;Worker&lt;/code&gt; 를 사용하도록 변경하십시오 &lt;code&gt;call_box&lt;/code&gt; 의 방법. 이러한 변경 사항은 Listing 20-21에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="0be702d32a09b655da72a7b7225dc839aaba10a3" translate="yes" xml:space="preserve">
          <source>But for the following two exceptions, this function is semantically equivalent to &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">그러나 다음 두 가지 예외의 경우이 기능은 의미 적으로 &lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt; 같습니다.</target>
        </trans-unit>
        <trans-unit id="470268269eb0c32844b8d1e2e02e3f2f66584bd8" translate="yes" xml:space="preserve">
          <source>But if we used the different structs, which each have their own type, we couldn&amp;rsquo;t as easily define a function to take any of these kinds of messages as we could with the &lt;code&gt;Message&lt;/code&gt; enum defined in Listing 6-2, which is a single type.</source>
          <target state="translated">그러나 각각 고유 한 유형을 가진 서로 다른 구조체를 사용했다면 Listing 6-2에 정의 된 &lt;code&gt;Message&lt;/code&gt; 열거 형 과 마찬가지로 이러한 종류의 메시지를 가져 오는 함수를 쉽게 정의 할 수 없었습니다. 유형.</target>
        </trans-unit>
        <trans-unit id="79200d10e04d305f55f7036bcbaaafae7d4d999b" translate="yes" xml:space="preserve">
          <source>But if your closure has state, iterating backwards may act in a way you do not expect. Let's go through an example. First, in the forward direction:</source>
          <target state="translated">그러나 클로저에 상태가 있으면 거꾸로 반복하면 예상치 못한 방식으로 작동 할 수 있습니다. 예를 들어 봅시다. 먼저 순방향으로 :</target>
        </trans-unit>
        <trans-unit id="42768b6451354f549c20c5936efbed0901a61a1c" translate="yes" xml:space="preserve">
          <source>But let&amp;rsquo;s see what happens when we instead move &lt;code&gt;handle.join()&lt;/code&gt; before the &lt;code&gt;for&lt;/code&gt; loop in &lt;code&gt;main&lt;/code&gt;, like this:</source>
          <target state="translated">그러나 &lt;code&gt;main&lt;/code&gt; 에서 &lt;code&gt;for&lt;/code&gt; 루프 전에 &lt;code&gt;handle.join()&lt;/code&gt; 을 다음 과 같이 이동하면 어떻게되는지 봅시다 :</target>
        </trans-unit>
        <trans-unit id="1fbf462a87fb38288cb0e833c1357211d81cfbfe" translate="yes" xml:space="preserve">
          <source>But mutability can be very useful. Variables are immutable only by default; as you did in Chapter 2, you can make them mutable by adding &lt;code&gt;mut&lt;/code&gt; in front of the variable name. In addition to allowing this value to change, &lt;code&gt;mut&lt;/code&gt; conveys intent to future readers of the code by indicating that other parts of the code will be changing this variable value.</source>
          <target state="translated">그러나 가변성은 매우 유용 할 수 있습니다. 변수는 기본적으로 만 변경할 수 없습니다. 2 장에서했던 것처럼 변수 이름 앞에 &lt;code&gt;mut&lt;/code&gt; 를 추가하여 변경할 수 있습니다 . &lt;code&gt;mut&lt;/code&gt; 는 이 값을 변경할 수있을뿐만 아니라 코드의 다른 부분이이 변수 값을 변경할 것임을 표시함으로써 코드의 미래 독자에게 의도를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="e1df74418ef370eb96db59d017c1ab1ddf4aab63" translate="yes" xml:space="preserve">
          <source>But mutability can be very useful. Variables are immutable only by default; as you did in Chapter 2, you can make them mutable by adding &lt;code&gt;mut&lt;/code&gt; in front of the variable name. In addition to allowing this value to change, &lt;code&gt;mut&lt;/code&gt; conveys intent to future readers of the code by indicating that other parts of the code will be changing this variable&amp;rsquo;s value.</source>
          <target state="translated">그러나 가변성은 매우 유용 할 수 있습니다. 변수는 기본적으로 만 변경할 수 없습니다. 2 장에서했던 것처럼 변수 이름 앞에 &lt;code&gt;mut&lt;/code&gt; 를 추가하여 변경 가능하게 만들 수 있습니다 . 이 값을 변경할 수 있도록 허용하는 것 외에도 &lt;code&gt;mut&lt;/code&gt; 는 코드의 다른 부분이이 변수의 값을 변경할 것임을 표시하여 향후 코드 독자에게 의도를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="ca01c2ad1998dcba761dee195dffb89226d07502" translate="yes" xml:space="preserve">
          <source>But mutable references have one big restriction: you can have only one mutable reference to a particular piece of data in a particular scope. This code will fail:</source>
          <target state="translated">그러나 변경 가능한 참조에는 하나의 큰 제한이 있습니다. 특정 범위의 특정 데이터 조각에 대한 하나의 변경 가능한 참조 만 가질 수 있습니다. 이 코드는 실패합니다 :</target>
        </trans-unit>
        <trans-unit id="c6250d5ccc2a1416a071df325ba8b22edb3b1273" translate="yes" xml:space="preserve">
          <source>But structs aren&amp;rsquo;t the only way you can create custom types: let&amp;rsquo;s turn to Rust&amp;rsquo;s enum feature to add another tool to your toolbox.</source>
          <target state="translated">그러나 구조체는 사용자 정의 유형을 만들 수있는 유일한 방법은 아닙니다. Rust의 열거 형 기능으로 전환하여 도구 상자에 다른 도구를 추가합시다.</target>
        </trans-unit>
        <trans-unit id="e46bfa80d370a9ed637759cea72a8f30b0485064" translate="yes" xml:space="preserve">
          <source>But this approach is error prone; we could cause the program to panic if the index length is incorrect. It&amp;rsquo;s also slow, because the compiler adds runtime code to perform the conditional check on every element on every iteration through the loop.</source>
          <target state="translated">그러나이 방법은 오류가 발생하기 쉽습니다. 인덱스 길이가 올바르지 않으면 프로그램이 패닉 상태가 될 수 있습니다. 컴파일러는 루프를 통해 모든 반복에서 모든 요소에 대해 조건부 검사를 수행하기 위해 런타임 코드를 추가하기 때문에 느립니다.</target>
        </trans-unit>
        <trans-unit id="de89e89b70a2e3c19b2a830c292d1b9e969da48e" translate="yes" xml:space="preserve">
          <source>But this code does:</source>
          <target state="translated">그러나이 코드는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="52cdbd656052ab3ea671f0d02157a3b7b3a6c824" translate="yes" xml:space="preserve">
          <source>But this code seems to contradict what we just learned: we don&amp;rsquo;t have a call to &lt;code&gt;clone&lt;/code&gt;, but &lt;code&gt;x&lt;/code&gt; is still valid and wasn&amp;rsquo;t moved into &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">그러나이 코드는 우리가 방금 배운 것과 모순되는 것처럼 보입니다 : 우리는 &lt;code&gt;clone&lt;/code&gt; 을 호출하지 않지만 &lt;code&gt;x&lt;/code&gt; 는 여전히 유효하고 &lt;code&gt;y&lt;/code&gt; 로 이동하지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="f041deb6530f49ecfbaae593b78e17efac482d38" translate="yes" xml:space="preserve">
          <source>But this is too much ceremony and a lot of work for a concept that should be common. Luckily for us, Rust has a feature for this concept, called &lt;em&gt;references&lt;/em&gt;.</source>
          <target state="translated">그러나 이것은 너무 많은 행사이며 일반적인 개념에 대한 많은 일입니다. 운 좋게도 Rust는 &lt;em&gt;reference&lt;/em&gt; 라는이 개념의 기능을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ad53668e46657588df9ef2114136e4f4dac0e42" translate="yes" xml:space="preserve">
          <source>But we also have to make some small changes to &lt;code&gt;main&lt;/code&gt;. The &lt;code&gt;request_review&lt;/code&gt; and &lt;code&gt;approve&lt;/code&gt; methods return new instances rather than modifying the struct they&amp;rsquo;re called on, so we need to add more &lt;code&gt;let post =&lt;/code&gt; shadowing assignments to save the returned instances. We also can&amp;rsquo;t have the assertions about the draft and pending review post&amp;rsquo;s contents be empty strings, nor do we need them: we can&amp;rsquo;t compile code that tries to use the content of posts in those states any longer. The updated code in &lt;code&gt;main&lt;/code&gt; is shown in Listing 17-21:</source>
          <target state="translated">그러나 &lt;code&gt;main&lt;/code&gt; 에도 약간의 변경을해야 합니다. &lt;code&gt;request_review&lt;/code&gt; 및 &lt;code&gt;approve&lt;/code&gt; 우리가 더 추가해야하므로 방법은, 오히려 그들이 호출하고있는 구조체를 수정하는 것보다 새로운 인스턴스를 반환 &lt;code&gt;let post =&lt;/code&gt; 반환 된 인스턴스를 저장하는 과제를 그림자. 또한 초안 및 보류중인 검토 게시물의 내용에 대한 어설 션을 빈 문자열로 사용할 수도 없으며 필요하지도 않습니다. 해당 상태의 게시물 내용을 더 이상 사용하려는 코드를 컴파일 할 수 없습니다. &lt;code&gt;main&lt;/code&gt; 에서 업데이트 된 코드는 Listing 17-21에 표시되어있다.</target>
        </trans-unit>
        <trans-unit id="08cb86c283fbceae016dfe9e91e73ec38c2b76a7" translate="yes" xml:space="preserve">
          <source>But we can&amp;rsquo;t implement external traits on external types. For example, we can&amp;rsquo;t implement the &lt;code&gt;Display&lt;/code&gt; trait on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; within our &lt;code&gt;aggregator&lt;/code&gt; crate, because &lt;code&gt;Display&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; are defined in the standard library and aren&amp;rsquo;t local to our &lt;code&gt;aggregator&lt;/code&gt; crate. This restriction is part of a property of programs called &lt;em&gt;coherence&lt;/em&gt;, and more specifically the &lt;em&gt;orphan rule&lt;/em&gt;, so named because the parent type is not present. This rule ensures that other people&amp;rsquo;s code can&amp;rsquo;t break your code and vice versa. Without the rule, two crates could implement the same trait for the same type, and Rust wouldn&amp;rsquo;t know which implementation to use.</source>
          <target state="translated">그러나 외부 유형에는 외부 특성을 구현할 수 없습니다. 예를 들어 &lt;code&gt;Display&lt;/code&gt; 와 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 는 표준 라이브러리에 정의되어 있으며 &lt;code&gt;aggregator&lt;/code&gt; 크레이트에 로컬이 아니므로 &lt;code&gt;aggregator&lt;/code&gt; 상자 내 에서 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 에 &lt;code&gt;Display&lt;/code&gt; 특성을 구현할 수 없습니다 . 이 제한은 &lt;em&gt;일관성 (coherence&lt;/em&gt; ) 이라는 프로그램 속성의 일부이며, 특히 상위 유형이 없기 때문에 이름이 지정된 &lt;em&gt;고아 규칙&lt;/em&gt; 입니다. 이 규칙은 다른 사람의 코드가 코드를 위반할 수 없도록하며 그 반대의 경우도 마찬가지입니다. 규칙이 없으면 두 개의 상자가 같은 유형에 대해 동일한 특성을 구현할 수 있으며 Rust는 어떤 구현을 사용할지 모를 것입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e2def28f767ccc15567e67d96a674194d2cda727" translate="yes" xml:space="preserve">
          <source>But we&amp;rsquo;re not quite done yet! In the worker, our closure being passed to &lt;code&gt;thread::spawn&lt;/code&gt; still only &lt;em&gt;references&lt;/em&gt; the receiving end of the channel. Instead, we need the closure to loop forever, asking the receiving end of the channel for a job and running the job when it gets one. Let&amp;rsquo;s make the change shown in Listing 20-20 to &lt;code&gt;Worker::new&lt;/code&gt;.</source>
          <target state="translated">그러나 아직 끝나지 않았습니다! 작업자에서 &lt;code&gt;thread::spawn&lt;/code&gt; 에 전달되는 클로저는 여전히 채널의 수신 끝만 &lt;em&gt;참조&lt;/em&gt; 합니다. 대신, 채널의 수신 측에 작업을 요청하고 작업이 도착하면 작업을 실행하도록 클로저를 영원히 반복해야합니다. Listing 20-20에 표시된 내용을 &lt;code&gt;Worker::new&lt;/code&gt; 로 변경해 보자 .</target>
        </trans-unit>
        <trans-unit id="91d9b7bfa8f54bae2ca712d22c222ac19da54446" translate="yes" xml:space="preserve">
          <source>But what use is a type you can never create values for? Recall the code from Listing 2-5; we&amp;rsquo;ve reproduced part of it here in Listing 19-26.</source>
          <target state="translated">그러나 결코 값을 만들 수없는 유형은 어떤 용도로 사용됩니까? Listing 2-5의 코드를 생각 해보자. 우리는 여기에 그 일부를 Listing 19-26에 재현했다.</target>
        </trans-unit>
        <trans-unit id="f5817afbaa27eca7b4e5b48d721c41770590cf6f" translate="yes" xml:space="preserve">
          <source>But when it comes to supporting this in traits, there are &lt;a href=&quot;https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/&quot;&gt;a few implementation issues&lt;/a&gt;. One of them is returning &lt;code&gt;impl Trait&lt;/code&gt; in traits is not supported, as it would require &lt;a href=&quot;https://github.com/rust-lang/rust/issues/44265&quot;&gt;Generic Associated Types&lt;/a&gt; to be supported:</source>
          <target state="translated">그러나이를 특성으로 지원할 때 &lt;a href=&quot;https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/&quot;&gt;몇 가지 구현 문제가 있습니다&lt;/a&gt; . 그중 하나는 지원되지 않는 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/44265&quot;&gt;일반 관련 유형&lt;/a&gt; 이 필요하기 때문에 &lt;code&gt;impl Trait&lt;/code&gt; 에서 impl Trait 을 반환 하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="3b1144e8d867db6585bb0fed6af4e27df37f58b6" translate="yes" xml:space="preserve">
          <source>But you&amp;rsquo;ll more often see them used in this format, with the comment on a separate line above the code it&amp;rsquo;s annotating:</source>
          <target state="translated">그러나 주석이 달린 코드 위에 별도의 줄에 주석이있는이 형식으로 사용되는 것을 더 자주 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14c5580ac9c2810afbb01f7bb2cceb390e04edb0" translate="yes" xml:space="preserve">
          <source>By adding &lt;code&gt;--undo&lt;/code&gt; to the command, you can also undo a yank and allow projects to start depending on a version again:</source>
          <target state="translated">명령에 &lt;code&gt;--undo&lt;/code&gt; 를 추가하면 Yank 를 실행 취소하고 버전에 따라 프로젝트를 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57268469c25c87f6ad4c099c6346794a32838869" translate="yes" xml:space="preserve">
          <source>By adding the &lt;code&gt;move&lt;/code&gt; keyword before the closure, we force the closure to take ownership of the values it&amp;rsquo;s using rather than allowing Rust to infer that it should borrow the values. The modification to Listing 16-3 shown in Listing 16-5 will compile and run as we intend:</source>
          <target state="translated">클로저 앞에 &lt;code&gt;move&lt;/code&gt; 키워드 를 추가 함으로써 Rust가 값을 빌려야한다는 것을 유추하는 대신 클로저가 사용중인 값을 소유하게합니다. Listing 16-5에 표시된 Listing 16-3의 수정 사항은 다음과 같이 컴파일되고 실행된다.</target>
        </trans-unit>
        <trans-unit id="24cf831e0672b0a0d0cb2aabe568cf79d0a637c3" translate="yes" xml:space="preserve">
          <source>By changing &lt;code&gt;impl PartialEq for Book&lt;/code&gt; to &lt;code&gt;impl PartialEq&amp;lt;BookFormat&amp;gt; for Book&lt;/code&gt;, we allow &lt;code&gt;BookFormat&lt;/code&gt;s to be compared with &lt;code&gt;Book&lt;/code&gt;s.</source>
          <target state="translated">변경하여 &lt;code&gt;impl PartialEq for Book&lt;/code&gt; 에 &lt;code&gt;impl PartialEq&amp;lt;BookFormat&amp;gt; for Book&lt;/code&gt; , 우리가 할 수 &lt;code&gt;BookFormat&lt;/code&gt; 의이 비교 될 &lt;code&gt;Book&lt;/code&gt; 들.</target>
        </trans-unit>
        <trans-unit id="376ca023c76f3036478e22fdb169869008d8aa9e" translate="yes" xml:space="preserve">
          <source>By controlling which tests run, you can make sure your &lt;code&gt;cargo test&lt;/code&gt; results will be fast. When you&amp;rsquo;re at a point where it makes sense to check the results of the &lt;code&gt;ignored&lt;/code&gt; tests and you have time to wait for the results, you can run &lt;code&gt;cargo test -- --ignored&lt;/code&gt; instead.</source>
          <target state="translated">실행되는 테스트를 제어하여 &lt;code&gt;cargo test&lt;/code&gt; 결과가 빠르도록 할 수 있습니다. &lt;code&gt;ignored&lt;/code&gt; 테스트 의 결과를 확인하는 것이 합리적이며 결과 를 기다릴 시간이있는 경우, 대신 &lt;code&gt;cargo test -- --ignored&lt;/code&gt; 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a2bb1d27a87d404cc9474290490c53d74fd41c0" translate="yes" xml:space="preserve">
          <source>By convention, &lt;code&gt;self.cmp(&amp;amp;other)&lt;/code&gt; returns the ordering matching the expression &lt;code&gt;self &amp;lt;operator&amp;gt; other&lt;/code&gt; if true.</source>
          <target state="translated">일반적으로 &lt;code&gt;self.cmp(&amp;amp;other)&lt;/code&gt; 는 true 인 경우 &lt;code&gt;self &amp;lt;operator&amp;gt; other&lt;/code&gt; 표현식과 일치하는 순서를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="de8a1d92f6dd3bd8db18180b7b2a50fb4ed9f5aa" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;security_qos_flags&lt;/code&gt; is not set. It should be specified when opening a named pipe, to control to which degree a server process can act on behalf of a client process (security impersonation level).</source>
          <target state="translated">기본적으로 &lt;code&gt;security_qos_flags&lt;/code&gt; 는 설정되어 있지 않습니다. 명명 된 파이프를 열 때 서버 프로세스가 클라이언트 프로세스 (보안 가장 수준) 대신 수행 할 수있는 정도를 제어하기 위해 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6095051ff401d433de5d730cac4f12b5941e6537" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;share_mode&lt;/code&gt; is set to &lt;code&gt;FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE&lt;/code&gt;. This allows other processes to read, write, and delete/rename the same file while it is open. Removing any of the flags will prevent other processes from performing the corresponding operation until the file handle is closed.</source>
          <target state="translated">기본적으로 &lt;code&gt;share_mode&lt;/code&gt; 는 &lt;code&gt;FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE&lt;/code&gt; . 이를 통해 다른 프로세스가 열려있는 동안 동일한 파일을 읽고 쓰고 삭제 / 이름을 바꿀 수 있습니다. 플래그를 제거하면 파일 핸들이 닫힐 때까지 다른 프로세스가 해당 작업을 수행하지 못하게됩니다.</target>
        </trans-unit>
        <trans-unit id="45de1662a54cdc16cef2847d72223197060768f7" translate="yes" xml:space="preserve">
          <source>By default external blocks assume that the library they are calling uses the standard C ABI on the specific platform. Other ABIs may be specified using an &lt;code&gt;abi&lt;/code&gt; string, as shown here:</source>
          <target state="translated">기본적으로 외부 블록은 호출하는 라이브러리가 특정 플랫폼에서 표준 C ABI를 사용한다고 가정합니다. 다른 ABI는 다음 과 같이 &lt;code&gt;abi&lt;/code&gt; 문자열을 사용하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc473c24bd4f443ffeef08b0cf6f41ff8de8d915" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;keyword.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; statements consume all they can, which can sometimes be a problem, when you don't really need the value to be moved and owned:</source>
          <target state="translated">기본적으로 &lt;a href=&quot;keyword.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; 문은 값을 이동하고 소유 할 필요가없는 경우 문제가 될 수있는 모든 항목 을 소비합니다.</target>
        </trans-unit>
        <trans-unit id="ad11d86076f62fa9cc433e025f374e132c103f7a" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;HashMap&lt;/code&gt; uses a &amp;ldquo;cryptographically strong&amp;rdquo;&lt;sup&gt;&lt;a href=&quot;#siphash&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; hashing function that can provide resistance to Denial of Service (DoS) attacks. This is not the fastest hashing algorithm available, but the trade-off for better security that comes with the drop in performance is worth it. If you profile your code and find that the default hash function is too slow for your purposes, you can switch to another function by specifying a different &lt;em&gt;hasher&lt;/em&gt;. A hasher is a type that implements the &lt;code&gt;BuildHasher&lt;/code&gt; trait. We&amp;rsquo;ll talk about traits and how to implement them in Chapter 10. You don&amp;rsquo;t necessarily have to implement your own hasher from scratch; &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; has libraries shared by other Rust users that provide hashers implementing many common hashing algorithms.</source>
          <target state="translated">기본적으로 &lt;code&gt;HashMap&lt;/code&gt; 은 서비스 거부 (DoS) 공격에 대한 저항을 제공 할 수 있는 &quot;암호 적으로 강력한&quot; &lt;sup&gt;&lt;a href=&quot;#siphash&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 해싱 기능을 사용합니다. 이것은 사용 가능한 가장 빠른 해싱 알고리즘은 아니지만 성능 저하와 함께 제공되는 더 나은 보안을위한 절충안은 가치가 있습니다. 코드를 프로파일 링하고 기본 해시 함수가 너무 느리다는 것을 발견하면 다른 &lt;em&gt;hasher&lt;/em&gt; 를 지정하여 다른 함수로 전환 할 수 있습니다 . &lt;code&gt;BuildHasher&lt;/code&gt; 는 BuildHasher 특성 을 구현하는 유형입니다 . 특성과 10 장에서 특성을 구현하는 방법에 대해 이야기 할 것입니다. 반드시 자신의 워셔를 처음부터 구현할 필요는 없습니다. &lt;a href=&quot;https://crates.io/&quot;&gt;상자&lt;/a&gt; 많은 공통 해싱 알고리즘을 구현하는 해셔를 제공하는 다른 Rust 사용자가 공유하는 라이브러리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="da46918183f148a703a5dca98e668e41fe0f6742" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;HashMap&lt;/code&gt; uses a hashing algorithm selected to provide resistance against HashDoS attacks. The algorithm is randomly seeded, and a reasonable best-effort is made to generate this seed from a high quality, secure source of randomness provided by the host without blocking the program. Because of this, the randomness of the seed depends on the output quality of the system's random number generator when the seed is created. In particular, seeds generated when the system's entropy pool is abnormally low such as during system boot may be of a lower quality.</source>
          <target state="translated">기본적으로 &lt;code&gt;HashMap&lt;/code&gt; 은 선택된 해싱 알고리즘을 사용하여 HashDoS 공격에 대한 내성을 제공합니다. 알고리즘은 무작위로 시딩되며, 프로그램을 차단하지 않고 호스트가 제공하는 고품질의 안전한 임의성 소스에서이 시드를 생성하기위한 합리적인 최선의 노력이 이루어집니다. 이 때문에 시드의 임의성은 시드가 생성 될 때 시스템의 난수 생성기의 출력 품질에 따라 달라집니다. 특히 시스템의 엔트로피 풀이 비정상적으로 낮을 때 (예 : 시스템 부팅 중) 생성 된 시드의 품질이 떨어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d651c937af4d96b8135fb3517b9d184e89c5453c" translate="yes" xml:space="preserve">
          <source>By default, Rust brings only a few types into the scope of every program in &lt;a href=&quot;../std/prelude/index&quot;&gt;the &lt;em&gt;prelude&lt;/em&gt;&lt;/a&gt;. If a type you want to use isn&amp;rsquo;t in the prelude, you have to bring that type into scope explicitly with a &lt;code&gt;use&lt;/code&gt; statement. Using the &lt;code&gt;std::io&lt;/code&gt; library provides you with a number of useful features, including the ability to accept user input.</source>
          <target state="translated">기본적으로 녹에있는 모든 프로그램의 범위에 단지 몇 가지 유형을 제공합니다 &lt;a href=&quot;../std/prelude/index&quot;&gt;&lt;em&gt;서곡&lt;/em&gt;&lt;/a&gt; . 사용하려는 유형이 서문에 없으면 &lt;code&gt;use&lt;/code&gt; 문을 사용 하여 해당 유형을 범위로 명시 적으로 가져와야합니다 . &lt;code&gt;std::io&lt;/code&gt; 라이브러리를 사용하면 사용자 입력을 받아 들일 수있는 기능을 비롯한 여러 유용한 기능이 제공됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0c4c1f7def0235335f03f717a82baeaf139f3d6d" translate="yes" xml:space="preserve">
          <source>By default, a macro has no path-based scope. However, if it has the &lt;code&gt;#[macro_export]&lt;/code&gt; attribute, then it is declared in the crate root scope and can be referred to normally as such:</source>
          <target state="translated">기본적으로 매크로에는 경로 기반 범위가 없습니다. 그러나 &lt;code&gt;#[macro_export]&lt;/code&gt; 속성이있는 경우 크레이트 루트 범위에서 선언되며 일반적으로 다음과 같이 참조 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cbf310ab8fadfa7c76780733e623179e3214d1c" translate="yes" xml:space="preserve">
          <source>By default, all identifiers referred to in a macro are expanded as-is, and are looked up at the macro's invocation site. This can lead to issues if a macro refers to an item or macro which isn't in scope at the invocation site. To alleviate this, the &lt;code&gt;$crate&lt;/code&gt; metavariable can be used at the start of a path to force lookup to occur inside the crate defining the macro.</source>
          <target state="translated">기본적으로 매크로에서 참조되는 모든 식별자는 그대로 확장되어 매크로의 호출 사이트에서 조회됩니다. 매크로가 호출 사이트에서 범위를 벗어나는 항목 또는 매크로를 참조하는 경우 문제가 발생할 수 있습니다. 이를 완화하기 위해 경로 시작 부분에 &lt;code&gt;$crate&lt;/code&gt; 메타 변수를 사용하여 매크로를 정의하는 상자 내부에서 조회를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="642089d05c107d61f37af46fec5f28d39e938fae" translate="yes" xml:space="preserve">
          <source>By default, all types in Rust are movable. Rust allows passing all types by-value, and common smart-pointer types such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; allow replacing and moving the values they contain: you can move out of a &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, or you can use &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; wraps a pointer type &lt;code&gt;P&lt;/code&gt;, so &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; functions much like a regular &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;: when a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; gets dropped, so do its contents, and the memory gets deallocated. Similarly, &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; is a lot like &lt;code&gt;&amp;amp;mut T&lt;/code&gt;. However, &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; does not let clients actually obtain a &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt; to pinned data, which implies that you cannot use operations such as &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">기본적으로 Rust의 모든 유형은 이동 가능합니다. Rust는 모든 유형을 값으로 전달할 수 있으며 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 와 같은 일반적인 스마트 포인터 유형 은 포함 된 값을 바꾸고 이동할 수 있습니다. &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 밖으로 이동 하거나 &lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있습니다 . : 스왑 . &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 포인터 유형 &lt;code&gt;P&lt;/code&gt; 를 래핑 하므로 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 는 일반 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 와 매우 유사하게 작동 합니다. &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 가 삭제되면 해당 내용도 삭제되고 메모리가 할당 해제됩니다. . 마찬가지로 &lt;code&gt;&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; . 그러나 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 클라이언트 가 고정 된 데이터에 대해 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 를 실제로 얻도록 허용하지 않습니다 . 이는 &lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt; 과 같은 작업을 사용할 수 없음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="85f73f88e9b11f78d793846432896a45a47d865c" translate="yes" xml:space="preserve">
          <source>By default, all types in Rust are movable. Rust allows passing all types by-value, and common smart-pointer types such as &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; allow replacing and moving the values they contain: you can move out of a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, or you can use &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; wraps a pointer type &lt;code&gt;P&lt;/code&gt;, so &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; functions much like a regular &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;: when a &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; gets dropped, so do its contents, and the memory gets deallocated. Similarly, &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; is a lot like &lt;code&gt;&amp;amp;mut T&lt;/code&gt;. However, &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; does not let clients actually obtain a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt; to pinned data, which implies that you cannot use operations such as &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">기본적으로 Rust의 모든 유형은 이동 가능합니다. Rust는 모든 유형을 값으로 전달할 수 있으며 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 와 같은 일반적인 스마트 포인터 유형 은 포함 된 값을 바꾸거나 이동할 수 있습니다. &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 밖으로 이동 하거나 &lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있습니다 . : 스왑 . &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 포인터 유형 &lt;code&gt;P&lt;/code&gt; 를 랩핑 하므로 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 는 일반 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 와 매우 유사하게 기능 합니다. &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 가 떨어지면 내용도 마찬가지이며 메모리가 할당 해제됩니다. . 마찬가지로 고정 된 데이터에 &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; 는 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 와 매우 비슷 합니다. 그러나 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt;클라이언트가 실제로 얻을 수 없습니다 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; &lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="df4968e3432ef000f1bcc3fb95cf2b7eb0f19a6b" translate="yes" xml:space="preserve">
          <source>By default, everything in Rust is &lt;em&gt;private&lt;/em&gt;, with two exceptions: Associated items in a &lt;code&gt;pub&lt;/code&gt; Trait are public by default; Enum variants in a &lt;code&gt;pub&lt;/code&gt; enum are also public by default. When an item is declared as &lt;code&gt;pub&lt;/code&gt;, it can be thought of as being accessible to the outside world. For example:</source>
          <target state="translated">기본적으로 Rust의 모든 항목 은 &lt;em&gt;private&lt;/em&gt; 이며 다음 두 가지 예외가 있습니다. &lt;code&gt;pub&lt;/code&gt; 속성의 관련 항목은 기본적으로 공개입니다. &lt;code&gt;pub&lt;/code&gt; 열거 형의 열거 형 변형 도 기본적으로 공개됩니다. 항목이 &lt;code&gt;pub&lt;/code&gt; 으로 선언 되면 외부 세계에서 액세스 할 수있는 것으로 생각할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e8c258fdae97b1ecf4c355834b8cc2789a53356b" translate="yes" xml:space="preserve">
          <source>By default, generic functions will work only on types that have a known size at compile time. However, you can use the following special syntax to relax this restriction:</source>
          <target state="translated">기본적으로 일반 함수는 컴파일 타임에 알려진 크기의 유형에서만 작동합니다. 그러나 다음과 같은 특수 구문을 사용하여이 제한을 완화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9c4cd7fe13c5d5855eca814505fcc712b580495" translate="yes" xml:space="preserve">
          <source>By default, identifier patterns bind a variable to a copy of or move from the matched value depending on whether the matched value implements &lt;a href=&quot;special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. This can be changed to bind to a reference by using the &lt;code&gt;ref&lt;/code&gt; keyword, or to a mutable reference using &lt;code&gt;ref mut&lt;/code&gt;. For example:</source>
          <target state="translated">기본적으로 식별자 패턴은 일치하는 값이 &lt;a href=&quot;special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; 를&lt;/a&gt; 구현하는지 여부에 따라 변수를 일치하는 값의 복사본에 바인딩하거나 일치하는 값에서 이동합니다 . 이것은 &lt;code&gt;ref&lt;/code&gt; 키워드 를 사용하여 참조에 바인딩 하거나 변경 가능한 참조 에 바인딩하도록 변경할 수 있습니다 &lt;code&gt;ref mut&lt;/code&gt; 를 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="972aa10d3aec7b320258dca3f2fe0bcadcd844ff" translate="yes" xml:space="preserve">
          <source>By default, if a test passes, Rust&amp;rsquo;s test library captures anything printed to standard output. For example, if we call &lt;code&gt;println!&lt;/code&gt; in a test and the test passes, we won&amp;rsquo;t see the &lt;code&gt;println!&lt;/code&gt; output in the terminal; we&amp;rsquo;ll see only the line that indicates the test passed. If a test fails, we&amp;rsquo;ll see whatever was printed to standard output with the rest of the failure message.</source>
          <target state="translated">기본적으로 테스트가 통과되면 Rust의 테스트 라이브러리는 표준 출력으로 인쇄 된 모든 것을 캡처합니다. 예를 들어 &lt;code&gt;println!&lt;/code&gt; 테스트에서 테스트가 통과되면 &lt;code&gt;println!&lt;/code&gt; 이 보이지 않습니다 !터미널에서 출력; 테스트가 통과했음을 나타내는 줄만 표시됩니다. 테스트가 실패하면 나머지 실패 메시지와 함께 표준 출력으로 인쇄 된 내용이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d95184642912361a38b12a6b5acfd4cc05172698" translate="yes" xml:space="preserve">
          <source>By default, stdin, stdout and stderr are inherited from the parent.</source>
          <target state="translated">기본적으로 stdin, stdout 및 stderr은 상위에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="f620f1067d553e3bfb80fd71b1c203148dc846fc" translate="yes" xml:space="preserve">
          <source>By default, stdin, stdout and stderr are inherited from the parent. In order to capture the output into this &lt;code&gt;Result&amp;lt;Output&amp;gt;&lt;/code&gt; it is necessary to create new pipes between parent and child. Use &lt;code&gt;stdout(Stdio::piped())&lt;/code&gt; or &lt;code&gt;stderr(Stdio::piped())&lt;/code&gt;, respectively.</source>
          <target state="translated">기본적으로 stdin, stdout 및 stderr은 상위에서 상속됩니다. 출력을이 &lt;code&gt;Result&amp;lt;Output&amp;gt;&lt;/code&gt; 에 캡처하려면 상위와 하위 사이에 새 파이프를 작성해야합니다. 를 사용하여 &lt;code&gt;stdout(Stdio::piped())&lt;/code&gt; 또는 &lt;code&gt;stderr(Stdio::piped())&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="1a3d2a96946537e440c011c1b793bac6cb6bf93c" translate="yes" xml:space="preserve">
          <source>By default, stdout and stderr are captured (and used to provide the resulting output). Stdin is not inherited from the parent and any attempt by the child process to read from the stdin stream will result in the stream immediately closing.</source>
          <target state="translated">기본적으로 stdout 및 stderr이 캡처되어 결과 출력을 제공하는 데 사용됩니다. Stdin은 부모로부터 상속되지 않으며 자식 프로세스가 stdin 스트림에서 읽으려고하면 스트림이 즉시 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="ef6b7759d538ef3f99e9eadac17fdfe2aa668d92" translate="yes" xml:space="preserve">
          <source>By default, variable bindings have 'move semantics.' In other words:</source>
          <target state="translated">기본적으로 변수 바인딩에는 '이동 의미론'이 있습니다. 다시 말해:</target>
        </trans-unit>
        <trans-unit id="07d2d74e176689aec98a3f3118957a0424dbbe81" translate="yes" xml:space="preserve">
          <source>By default, variables in Rust are immutable. To fix this error, add the keyword &lt;code&gt;mut&lt;/code&gt; after the keyword &lt;code&gt;let&lt;/code&gt; when declaring the variable. For example:</source>
          <target state="translated">기본적으로 Rust의 변수는 변경할 수 없습니다. 이 오류를 해결하려면 키워드 &lt;code&gt;let&lt;/code&gt; 뒤에 키워드 &lt;code&gt;mut&lt;/code&gt; 를 추가하십시오. 변수 선언시 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="878411518946b9f6ea5793ecae83ce111ee3e9e7" translate="yes" xml:space="preserve">
          <source>By default, when a panic occurs, the program starts &lt;em&gt;unwinding&lt;/em&gt;, which means Rust walks back up the stack and cleans up the data from each function it encounters. But this walking back and cleanup is a lot of work. The alternative is to immediately &lt;em&gt;abort&lt;/em&gt;, which ends the program without cleaning up. Memory that the program was using will then need to be cleaned up by the operating system. If in your project you need to make the resulting binary as small as possible, you can switch from unwinding to aborting upon a panic by adding &lt;code&gt;panic = 'abort'&lt;/code&gt; to the appropriate &lt;code&gt;[profile]&lt;/code&gt; sections in your &lt;em&gt;Cargo.toml&lt;/em&gt; file. For example, if you want to abort on panic in release mode, add this:</source>
          <target state="translated">기본적으로 패닉이 발생하면 프로그램이 &lt;em&gt;풀기&lt;/em&gt; 시작합니다. 즉, Rust가 스택을 뒤로 걸어서 발생하는 각 기능에서 데이터를 정리합니다. 그러나이 걷기와 정리는 많은 작업입니다. 대안은 즉시 &lt;em&gt;중단&lt;/em&gt; 하여 정리하지 않고 프로그램을 종료하는 것입니다. 그런 다음 프로그램에서 사용중인 메모리는 운영 체제에서 정리해야합니다. 프로젝트에서 결과 바이너리를 가능한 한 작게 만들어야하는 경우, &lt;em&gt;pango &lt;/em&gt; &lt;code&gt;panic = 'abort'&lt;/code&gt; 를 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일 의 적절한 &lt;code&gt;[profile]&lt;/code&gt; 섹션에 추가하여 패닉 해제시 해제에서 중단으로 전환 할 수 있습니다 . 예를 들어 릴리스 모드에서 패닉을 중단하려면 다음을 추가하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="70961236b49c3241db36d35bd68586bfb070a6d8" translate="yes" xml:space="preserve">
          <source>By implementing &lt;code&gt;FromIterator&lt;/code&gt; for a type, you define how it will be created from an iterator. This is common for types which describe a collection of some kind.</source>
          <target state="translated">&lt;code&gt;FromIterator&lt;/code&gt; 를 구현 함으로써유형에 대해 를 하여 반복자에서 작성되는 방법을 정의합니다. 이것은 어떤 종류의 컬렉션을 설명하는 유형에 공통입니다.</target>
        </trans-unit>
        <trans-unit id="8fe6d2f7538ddf4711df03e9fa6aac2aec872193" translate="yes" xml:space="preserve">
          <source>By implementing &lt;code&gt;IntoIterator&lt;/code&gt; for a type, you define how it will be converted to an iterator. This is common for types which describe a collection of some kind.</source>
          <target state="translated">유형에 &lt;code&gt;IntoIterator&lt;/code&gt; 를 구현 하여 반복자로 변환되는 방법을 정의합니다. 이것은 어떤 종류의 컬렉션을 설명하는 유형에 공통입니다.</target>
        </trans-unit>
        <trans-unit id="a0afc41378ee2d3e0b24873888e49fe44ab2bb88" translate="yes" xml:space="preserve">
          <source>By implementing the state pattern exactly as it&amp;rsquo;s defined for object-oriented languages, we&amp;rsquo;re not taking as full advantage of Rust&amp;rsquo;s strengths as we could. Let&amp;rsquo;s look at some changes we can make to the &lt;code&gt;blog&lt;/code&gt; crate that can make invalid states and transitions into compile time errors.</source>
          <target state="translated">객체 지향 언어에 대해 정의 된 것과 똑같이 상태 패턴을 구현함으로써, 우리는 Rust의 강점을 최대한 활용할 수 없습니다. &lt;code&gt;blog&lt;/code&gt; 에 대한 몇 가지 변경 사항을 살펴 보겠습니다.유효하지 않은 상태로 만들고 컴파일 시간 오류로 전환 할 수 상자 .</target>
        </trans-unit>
        <trans-unit id="46180f00b512e17d9f64273f452da441a283a2bb" translate="yes" xml:space="preserve">
          <source>By inserting the &lt;code&gt;unsafe&lt;/code&gt; block around our call to &lt;code&gt;dangerous&lt;/code&gt;, we&amp;rsquo;re asserting to Rust that we&amp;rsquo;ve read the function&amp;rsquo;s documentation, we understand how to use it properly, and we&amp;rsquo;ve verified that we&amp;rsquo;re fulfilling the contract of the function.</source>
          <target state="translated">&lt;code&gt;dangerous&lt;/code&gt; 대한 우리의 전화 주위에 &lt;code&gt;unsafe&lt;/code&gt; 블록 을 삽입함으로써우리는 Rust에게 함수의 문서를 읽었으며 올바르게 사용하는 방법을 이해하고 함수 계약을 이행하고 있음을 확인했습니다.</target>
        </trans-unit>
        <trans-unit id="ebd43141acc082c32de2ba198e30637d83a5941d" translate="yes" xml:space="preserve">
          <source>By introducing the explicit &lt;code&gt;let value&lt;/code&gt;, we allocate storage that will last until the end of the enclosing block (when &lt;code&gt;value&lt;/code&gt; goes out of scope). When we borrow &lt;code&gt;&amp;amp;value&lt;/code&gt;, we are borrowing a local variable that already exists, and hence no temporary is created.</source>
          <target state="translated">명시적인 &lt;code&gt;let value&lt;/code&gt; 를 도입함으로써 , 우리는 둘러싸는 블록이 끝날 때까지 지속되는 스토리지를 할당합니다 ( &lt;code&gt;value&lt;/code&gt; 이 범위를 벗어날 때 ). &lt;code&gt;&amp;amp;value&lt;/code&gt; 를 빌릴 때 이미 존재하는 지역 변수를 빌리기 때문에 임시가 만들어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69e12568cda798dc4c41d36b6782b17be36886bc" translate="yes" xml:space="preserve">
          <source>By now, you&amp;rsquo;ve learned the most commonly used parts of the Rust programming language. Before we do one more project in Chapter 20, we&amp;rsquo;ll look at a few aspects of the language you might run into every once in a while. You can use this chapter as a reference for when you encounter any unknowns when using Rust. The features you&amp;rsquo;ll learn to use in this chapter are useful in very specific situations. Although you might not reach for them often, we want to make sure you have a grasp of all the features Rust has to offer.</source>
          <target state="translated">지금까지 Rust 프로그래밍 언어에서 가장 일반적으로 사용되는 부분을 배웠습니다. 20 장에서 하나 이상의 프로젝트를 수행하기 전에 가끔씩 한 번 실행할 수있는 언어의 몇 가지 측면을 살펴 보겠습니다. Rust를 사용할 때 알 수없는 문제가 발생할 때이 장을 참조로 사용할 수 있습니다. 이 장에서 배우는 기능은 매우 특정한 상황에서 유용합니다. 자주 접근하지는 않지만 Rust가 제공하는 모든 기능을 파악하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="3b8d2c5ef438bc901d43221175865fde334c590c" translate="yes" xml:space="preserve">
          <source>By opting out of having Rust enforce these guarantees, you can give up guaranteed safety in exchange for greater performance or the ability to interface with another language or hardware where Rust&amp;rsquo;s guarantees don&amp;rsquo;t apply.</source>
          <target state="translated">Rust이 이러한 보증을 시행하지 않도록 선택함으로써, 성능 향상 또는 Rust의 보증이 적용되지 않는 다른 언어 또는 하드웨어와의 인터페이스 기능과 교환하여 안전을 보장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27764f2a26f0e207cc2fb6a676294f8c54a5721a" translate="yes" xml:space="preserve">
          <source>By requesting the current thread, using the &lt;a href=&quot;fn.current&quot;&gt;&lt;code&gt;thread::current&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;fn.current&quot;&gt; &lt;code&gt;thread::current&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 현재 스레드를 요청합니다 .</target>
        </trans-unit>
        <trans-unit id="cbc7153ee55504f6099241a26bcc3f7667184521" translate="yes" xml:space="preserve">
          <source>By spawning a new thread, e.g., using the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; function, and calling &lt;a href=&quot;struct.joinhandle#method.thread&quot;&gt;&lt;code&gt;thread&lt;/code&gt;&lt;/a&gt; on the &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">예를 들어, &lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt; 함수 를 사용하고 &lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; 에서&lt;/a&gt;&lt;a href=&quot;struct.joinhandle#method.thread&quot;&gt; &lt;code&gt;thread&lt;/code&gt; &lt;/a&gt; 를 호출 하여 새 스레드를 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="12606d21fd7d24ec782af86e2fc775ab3b2a1534" translate="yes" xml:space="preserve">
          <source>By the same token, if your slice includes the last byte of the &lt;code&gt;String&lt;/code&gt;, you can drop the trailing number. That means these are equal:</source>
          <target state="translated">마찬가지로 슬라이스에 &lt;code&gt;String&lt;/code&gt; 의 마지막 바이트가 포함 된 경우 후행 번호를 삭제할 수 있습니다. 이는 이들이 동일하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="eed2e06fae66dfdcb759c3aa75071abdbcec3d30" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;impl Summary&lt;/code&gt; for the return type, we specify that the &lt;code&gt;returns_summarizable&lt;/code&gt; function returns some type that implements the &lt;code&gt;Summary&lt;/code&gt; trait without naming the concrete type. In this case, &lt;code&gt;returns_summarizable&lt;/code&gt; returns a &lt;code&gt;Tweet&lt;/code&gt;, but the code calling this function doesn&amp;rsquo;t know that.</source>
          <target state="translated">반환 유형에 &lt;code&gt;impl Summary&lt;/code&gt; 를 사용 하여 &lt;code&gt;returns_summarizable&lt;/code&gt; 함수는 구체적 유형의 이름을 지정하지 않고 &lt;code&gt;Summary&lt;/code&gt; 특성 을 구현하는 일부 유형을 리턴하도록 지정합니다. 이 경우 &lt;code&gt;returns_summarizable&lt;/code&gt; 은 &lt;code&gt;Tweet&lt;/code&gt; 을 반환 하지만이 함수를 호출하는 코드는이를 알지 못합니다.</target>
        </trans-unit>
        <trans-unit id="e9aacb122cfae0a7a0d083ca40090e9b5f6410c8" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;loop&lt;/code&gt; instead and acquiring the lock and a job within the block rather than outside it, the &lt;code&gt;MutexGuard&lt;/code&gt; returned from the &lt;code&gt;lock&lt;/code&gt; method is dropped as soon as the &lt;code&gt;let job&lt;/code&gt; statement ends. This ensures that the lock is held during the call to &lt;code&gt;recv&lt;/code&gt;, but it is released before the call to &lt;code&gt;job.call_box()&lt;/code&gt;, allowing multiple requests to be serviced concurrently.</source>
          <target state="translated">사용하여 &lt;code&gt;loop&lt;/code&gt; 잠금 및 블록 내에서보다는 외부 작업을 대신하고 획득의 &lt;code&gt;MutexGuard&lt;/code&gt; 는 으로부터 반환 &lt;code&gt;lock&lt;/code&gt; 곧만큼 삭제 방법 &lt;code&gt;let job&lt;/code&gt; 문 종료됩니다. 이를 통해 &lt;code&gt;recv&lt;/code&gt; 호출 중에 잠금이 유지 되지만 &lt;code&gt;job.call_box()&lt;/code&gt; 호출 전에 잠금이 해제 되어 여러 요청을 동시에 서비스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1dc62ff68dd92e2b08c605e1735e02b6fb42d3d" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;loop&lt;/code&gt; instead and acquiring the lock without assigning to a variable, the temporary &lt;code&gt;MutexGuard&lt;/code&gt; returned from the &lt;code&gt;lock&lt;/code&gt; method is dropped as soon as the &lt;code&gt;let job&lt;/code&gt; statement ends. This ensures that the lock is held during the call to &lt;code&gt;recv&lt;/code&gt;, but it is released before the call to &lt;code&gt;job()&lt;/code&gt;, allowing multiple requests to be serviced concurrently.</source>
          <target state="translated">사용하여 &lt;code&gt;loop&lt;/code&gt; 대신하고 변수에 할당하지 않고 잠금을 획득, 임시 &lt;code&gt;MutexGuard&lt;/code&gt; 는 으로부터 반환 &lt;code&gt;lock&lt;/code&gt; 즉시로 삭제 방법 &lt;code&gt;let job&lt;/code&gt; 문 종료됩니다. 이렇게하면 &lt;code&gt;recv&lt;/code&gt; 호출 중에 잠금이 유지 되지만 &lt;code&gt;job()&lt;/code&gt; 호출 전에 잠금이 해제 되어 여러 요청을 동시에 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="96a33cddb0085e977a7cbf3fab6625f1af56ae11" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;pub use&lt;/code&gt;, external code can now call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function using &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt;. If we hadn&amp;rsquo;t specified &lt;code&gt;pub use&lt;/code&gt;, the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function could call &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; in its scope, but external code couldn&amp;rsquo;t take advantage of this new path.</source>
          <target state="translated">&lt;code&gt;pub use&lt;/code&gt; 를 사용하여 외부 코드는 이제 &lt;code&gt;add_to_waitlist&lt;/code&gt; &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; 사용하여 add_to_waitlist 함수를 호출 할 수 있습니다 . 우리가 지정되지 않았다면 &lt;code&gt;pub use&lt;/code&gt; 의 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 함수를 호출 할 수 있습니다 &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; 그 범위에 있지만, 외부 코드는이 새로운 경로를 활용할 수 없었다.</target>
        </trans-unit>
        <trans-unit id="433cfee29840720f9bbafd30efe0a38d5e74bfb2" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;unsafe impl&lt;/code&gt;, we&amp;rsquo;re promising that we&amp;rsquo;ll uphold the invariants that the compiler can&amp;rsquo;t verify.</source>
          <target state="translated">&lt;code&gt;unsafe impl&lt;/code&gt; 을 사용 하면 컴파일러가 확인할 수없는 불변을 유지한다고 약속합니다.</target>
        </trans-unit>
        <trans-unit id="9f1a9fce35b987ffd7d1760b4240dc3939988c2c" translate="yes" xml:space="preserve">
          <source>By using a trait bound with an &lt;code&gt;impl&lt;/code&gt; block that uses generic type parameters, we can implement methods conditionally for types that implement the specified traits. For example, the type &lt;code&gt;Pair&amp;lt;T&amp;gt;&lt;/code&gt; in Listing 10-16 always implements the &lt;code&gt;new&lt;/code&gt; function. But &lt;code&gt;Pair&amp;lt;T&amp;gt;&lt;/code&gt; only implements the &lt;code&gt;cmp_display&lt;/code&gt; method if its inner type &lt;code&gt;T&lt;/code&gt; implements the &lt;code&gt;PartialOrd&lt;/code&gt; trait that enables comparison &lt;em&gt;and&lt;/em&gt; the &lt;code&gt;Display&lt;/code&gt; trait that enables printing.</source>
          <target state="translated">제네릭 형식 매개 변수를 사용 하는 &lt;code&gt;impl&lt;/code&gt; 블록이 있는 특성 을 사용하면 지정된 특성을 구현하는 형식에 대해 조건부로 메서드를 구현할 수 있습니다. 예를 들어, 목록 10-16의 &lt;code&gt;Pair&amp;lt;T&amp;gt;&lt;/code&gt; 유형은 항상 &lt;code&gt;new&lt;/code&gt; 기능을 구현합니다 . 그러나 &lt;code&gt;Pair&amp;lt;T&amp;gt;&lt;/code&gt; 는 내부 유형 &lt;code&gt;T&lt;/code&gt; 가 비교를 가능하게 하는 &lt;code&gt;PartialOrd&lt;/code&gt; 특성 &lt;em&gt;과&lt;/em&gt; 인쇄를 가능하게 하는 &lt;code&gt;Display&lt;/code&gt; 특성을 구현하는 경우 에만 &lt;code&gt;cmp_display&lt;/code&gt; 메소드를 구현합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e575a61c7bb4198f04719172d2b19e840714927a" translate="yes" xml:space="preserve">
          <source>By using modules, we can group related definitions together and name why they&amp;rsquo;re related. Programmers using this code would have an easier time finding the definitions they wanted to use because they could navigate the code based on the groups rather than having to read through all the definitions. Programmers adding new functionality to this code would know where to place the code to keep the program organized.</source>
          <target state="translated">모듈을 사용하여 관련 정의를 그룹화하고 관련 이유를 지정할 수 있습니다. 이 코드를 사용하는 프로그래머는 모든 정의를 읽을 필요없이 그룹을 기반으로 코드를 탐색 할 수 있기 때문에 사용하려는 정의를 쉽게 찾을 수 있습니다. 이 코드에 새로운 기능을 추가하는 프로그래머는 프로그램을 구성하기 위해 코드를 배치 할 위치를 알고있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="0b9231ce9a42a6d6d2c8f8b26aa846a1ea4f8ea3" translate="yes" xml:space="preserve">
          <source>By using these and other tools in the Rust ecosystem, developers can be productive while writing systems-level code.</source>
          <target state="translated">Rust 생태계에서 이러한 툴과 다른 툴을 사용함으로써 개발자는 시스템 레벨 코드를 작성하는 동안 생산성을 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b10818a6a4d9d5c0ec3347fc6c8f03ab8bee8b6" translate="yes" xml:space="preserve">
          <source>By using this method, you are making a promise about the &lt;code&gt;P::Deref&lt;/code&gt; and &lt;code&gt;P::DerefMut&lt;/code&gt; implementations, if they exist. Most importantly, they must not move out of their &lt;code&gt;self&lt;/code&gt; arguments: &lt;code&gt;Pin::as_mut&lt;/code&gt; and &lt;code&gt;Pin::as_ref&lt;/code&gt; will call &lt;code&gt;DerefMut::deref_mut&lt;/code&gt; and &lt;code&gt;Deref::deref&lt;/code&gt;&lt;em&gt;on the pinned pointer&lt;/em&gt; and expect these methods to uphold the pinning invariants. Moreover, by calling this method you promise that the reference &lt;code&gt;P&lt;/code&gt; dereferences to will not be moved out of again; in particular, it must not be possible to obtain a &lt;code&gt;&amp;amp;mut P::Target&lt;/code&gt; and then move out of that reference (using, for example &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 방법을 사용하면 &lt;code&gt;P::Deref&lt;/code&gt; 및 &lt;code&gt;P::DerefMut&lt;/code&gt; 구현 (있는 경우)에 대해 약속 합니다. 가장 중요한 것은, 그들이 밖으로 이동하지 않아야 &lt;code&gt;self&lt;/code&gt; 인수 : &lt;code&gt;Pin::as_mut&lt;/code&gt; 및 &lt;code&gt;Pin::as_ref&lt;/code&gt; 호출 &lt;code&gt;DerefMut::deref_mut&lt;/code&gt; 및 &lt;code&gt;Deref::deref&lt;/code&gt; &lt;em&gt;고정 된 포인터&lt;/em&gt; 및 이러한 방법은 고정 불변을 유지하기 위해 기대합니다. 또한,이 메소드를 호출함으로써 참조 &lt;code&gt;P&lt;/code&gt; 역 참조가 다시 빠져 나가지 않을 것이라고 약속 합니다. 특히 &lt;code&gt;&amp;amp;mut P::Target&lt;/code&gt; 을 얻은 다음 해당 참조에서 벗어나는 것은 불가능합니다 (예 :)&lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bcdb56a053eed7c5213a43f696d9db1ac84162fc" translate="yes" xml:space="preserve">
          <source>By using trait bounds we can accept arguments of different types as long as they can be converted to the specified type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">특성 범위를 사용하면 지정된 유형 &lt;code&gt;T&lt;/code&gt; 로 변환 될 수있는 한 다른 유형의 인수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="301603101f50fc1a91e6b20fad60e030ba9789b8" translate="yes" xml:space="preserve">
          <source>By wrapping the stream with a &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt;, these ten writes are all grouped together by the buffer and will all be written out in one system call when the &lt;code&gt;stream&lt;/code&gt; is flushed.</source>
          <target state="translated">스트림을 &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt; 로 래핑하면 이 10 개의 쓰기가 모두 버퍼에 의해 그룹화되고 &lt;code&gt;stream&lt;/code&gt; 이 플러시 될 때 하나의 시스템 호출로 모두 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="8dae0e28ac851e86945ef16395330c4f51fd0970" translate="yes" xml:space="preserve">
          <source>By wrapping the stream with a &lt;code&gt;BufWriter&lt;/code&gt;, these ten writes are all grouped together by the buffer, and will all be written out in one system call when the &lt;code&gt;stream&lt;/code&gt; is dropped.</source>
          <target state="translated">스트림을 &lt;code&gt;BufWriter&lt;/code&gt; 로 랩핑하면 이 10 개의 쓰기가 모두 버퍼에 의해 그룹화되며 &lt;code&gt;stream&lt;/code&gt; 이 삭제 될 때 하나의 시스템 호출에서 모두 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="1548ce31fadb001aea0a12a579d52d9306c7253a" translate="yes" xml:space="preserve">
          <source>Bypasses Rust's normal memory-initialization checks by pretending to produce a value of type &lt;code&gt;T&lt;/code&gt;, while doing nothing at all.</source>
          <target state="translated">아무 것도하지 않고 &lt;code&gt;T&lt;/code&gt; 유형의 값을 생성하는 척하여 Rust의 일반 메모리 초기화 검사를 무시 합니다.</target>
        </trans-unit>
        <trans-unit id="7803ee252527503b67d1eeb0deb252622746cebd" translate="yes" xml:space="preserve">
          <source>Byte</source>
          <target state="translated">Byte</target>
        </trans-unit>
        <trans-unit id="afdbaede89ef0f8a02124c499ef64ef1f0406d22" translate="yes" xml:space="preserve">
          <source>Byte (&lt;code&gt;u8&lt;/code&gt; only)</source>
          <target state="translated">바이트 ( &lt;code&gt;u8&lt;/code&gt; 만 해당)</target>
        </trans-unit>
        <trans-unit id="e461b64db66675f3379c1e15d16c6c99827a8b32" translate="yes" xml:space="preserve">
          <source>Byte and byte string literals</source>
          <target state="translated">바이트 및 바이트 문자열 리터럴</target>
        </trans-unit>
        <trans-unit id="bed6860ca009a5f59b4930b17f9fae2513fd51cb" translate="yes" xml:space="preserve">
          <source>Byte escapes</source>
          <target state="translated">바이트 이스케이프</target>
        </trans-unit>
        <trans-unit id="2bf9a238164dde110e7112a731c7b6d180525024" translate="yes" xml:space="preserve">
          <source>Byte literals</source>
          <target state="translated">바이트 리터럴</target>
        </trans-unit>
        <trans-unit id="65c69de6b60d275943eb0b345c38a4da863d03c4" translate="yes" xml:space="preserve">
          <source>Byte order mark</source>
          <target state="translated">바이트 순서 표시</target>
        </trans-unit>
        <trans-unit id="e7860363275fd51d964677e4db11dc87fb2b83e0" translate="yes" xml:space="preserve">
          <source>Byte string</source>
          <target state="translated">바이트 문자열</target>
        </trans-unit>
        <trans-unit id="7510135fa5665d61b3d40af81c44ebe6703847a9" translate="yes" xml:space="preserve">
          <source>Byte string literal; constructs a &lt;code&gt;[u8]&lt;/code&gt; instead of a string</source>
          <target state="translated">바이트 문자열 리터럴; 문자열 대신 &lt;code&gt;[u8]&lt;/code&gt; 생성</target>
        </trans-unit>
        <trans-unit id="d5501080013d3dce57e266b31385c7ea19dd9672" translate="yes" xml:space="preserve">
          <source>Byte string literals</source>
          <target state="translated">바이트 문자열 리터럴</target>
        </trans-unit>
        <trans-unit id="013842b4ad25a64e13616ea1267e8fb94bd63a6f" translate="yes" xml:space="preserve">
          <source>Byte-based interfaces are unwieldy and can be inefficient, as we'd need to be making near-constant calls to the operating system. To help with this, &lt;code&gt;std::io&lt;/code&gt; comes with two structs, &lt;a href=&quot;struct.bufreader&quot;&gt;&lt;code&gt;BufReader&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.bufwriter&quot;&gt;&lt;code&gt;BufWriter&lt;/code&gt;&lt;/a&gt;, which wrap readers and writers. The wrapper uses a buffer, reducing the number of calls and providing nicer methods for accessing exactly what you want.</source>
          <target state="translated">바이트 기반 인터페이스는 다루기 어려우며 운영 체제를 거의 일정하게 호출해야하므로 비효율적 일 수 있습니다. 이를 돕기 위해 &lt;code&gt;std::io&lt;/code&gt; 에는 리더와 라이터를 래핑하는 &lt;a href=&quot;struct.bufreader&quot;&gt; &lt;code&gt;BufReader&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;struct.bufwriter&quot;&gt; &lt;code&gt;BufWriter&lt;/code&gt; 의&lt;/a&gt; 두 구조체가 있습니다. 랩퍼는 버퍼를 사용하여 호출 수를 줄이고 원하는대로 정확하게 액세스하기위한 더 좋은 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8e5fdab92dece79d7629d6d901687613ddc6ab5a" translate="yes" xml:space="preserve">
          <source>Bytes</source>
          <target state="translated">Bytes</target>
        </trans-unit>
        <trans-unit id="f4b810da1a34c6717e9522d90aa84dd16327cb38" translate="yes" xml:space="preserve">
          <source>Bytes &lt;code&gt;0..old_layout.size()&lt;/code&gt; are preserved from the original allocation.</source>
          <target state="translated">바이트 &lt;code&gt;0..old_layout.size()&lt;/code&gt; 는 원래 할당에서 보존됩니다.</target>
        </trans-unit>
        <trans-unit id="97b74d3f6f2a9ba3378b8d5ad47f1a4ae59fcd37" translate="yes" xml:space="preserve">
          <source>Bytes &lt;code&gt;old_layout.size()..old_size&lt;/code&gt; will either be preserved or zeroed, depending on the allocator implementation. &lt;code&gt;old_size&lt;/code&gt; refers to the size of the memory block prior to the &lt;code&gt;grow_zeroed&lt;/code&gt; call, which may be larger than the size that was originally requested when it was allocated.</source>
          <target state="translated">바이트 &lt;code&gt;old_layout.size()..old_size&lt;/code&gt; 는 할당 자 구현에 따라 유지되거나 0이됩니다. &lt;code&gt;old_size&lt;/code&gt; 는 &lt;code&gt;grow_zeroed&lt;/code&gt; 호출 이전의 메모리 블록 크기를 나타내며 , 할당 될 때 원래 요청 된 크기보다 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5598f7ac23eed1d65ff56a4e36412084f03533d" translate="yes" xml:space="preserve">
          <source>Bytes &lt;code&gt;old_size..new_size&lt;/code&gt; are zeroed. &lt;code&gt;new_size&lt;/code&gt; refers to the size of the memory block returned by the &lt;code&gt;grow_zeroed&lt;/code&gt; call.</source>
          <target state="translated">&lt;code&gt;old_size..new_size&lt;/code&gt; 바이트 는 0이됩니다. &lt;code&gt;new_size&lt;/code&gt; 는 &lt;code&gt;grow_zeroed&lt;/code&gt; 호출에 의해 반환 된 메모리 블록의 크기를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ac774cda628eb294788ac5a8af4246ebdb046c2e" translate="yes" xml:space="preserve">
          <source>Bytes and Scalar Values and Grapheme Clusters! Oh My!</source>
          <target state="translated">바이트와 ​​스칼라 값과 Grapheme 클러스터! 어머!</target>
        </trans-unit>
        <trans-unit id="63a26fef0a88c04dcaa35220a18f6ec6efa06bb9" translate="yes" xml:space="preserve">
          <source>Bytes::all</source>
          <target state="translated">Bytes::all</target>
        </trans-unit>
        <trans-unit id="ce7f0f3ceb8a803663be41eda4062efc6e909fc1" translate="yes" xml:space="preserve">
          <source>Bytes::any</source>
          <target state="translated">Bytes::any</target>
        </trans-unit>
        <trans-unit id="979369045d5514f553522214d3aeb625b48dd8a9" translate="yes" xml:space="preserve">
          <source>Bytes::borrow</source>
          <target state="translated">Bytes::borrow</target>
        </trans-unit>
        <trans-unit id="113f2dc7029b7c717fa9381d4e2943d9b1b2fc76" translate="yes" xml:space="preserve">
          <source>Bytes::borrow_mut</source>
          <target state="translated">Bytes::borrow_mut</target>
        </trans-unit>
        <trans-unit id="34427e43eec5e510b45622026cd37a560d9c2986" translate="yes" xml:space="preserve">
          <source>Bytes::by_ref</source>
          <target state="translated">Bytes::by_ref</target>
        </trans-unit>
        <trans-unit id="f07eec0f48fad142ac4fee1d3559e7e8d852d460" translate="yes" xml:space="preserve">
          <source>Bytes::chain</source>
          <target state="translated">Bytes::chain</target>
        </trans-unit>
        <trans-unit id="e0bf1210a39ee968daf6f1af8bf1ba9b5fc128dd" translate="yes" xml:space="preserve">
          <source>Bytes::clone</source>
          <target state="translated">Bytes::clone</target>
        </trans-unit>
        <trans-unit id="d328e30cabdbfda128a510cf1e8c0e446be3fec8" translate="yes" xml:space="preserve">
          <source>Bytes::clone_from</source>
          <target state="translated">Bytes::clone_from</target>
        </trans-unit>
        <trans-unit id="297e685afff3be463f3a3c3239b3251c10cb9c58" translate="yes" xml:space="preserve">
          <source>Bytes::clone_into</source>
          <target state="translated">Bytes::clone_into</target>
        </trans-unit>
        <trans-unit id="df2a47344e3e5b26dba12c9f96d298455119f06c" translate="yes" xml:space="preserve">
          <source>Bytes::cloned</source>
          <target state="translated">Bytes::cloned</target>
        </trans-unit>
        <trans-unit id="8c02ce01cfc4f2e89b9e4d7eed3369aa07faf8c3" translate="yes" xml:space="preserve">
          <source>Bytes::cmp</source>
          <target state="translated">Bytes::cmp</target>
        </trans-unit>
        <trans-unit id="299642d3a1e23a4fa629457b5fe1a7d7023f1ab5" translate="yes" xml:space="preserve">
          <source>Bytes::collect</source>
          <target state="translated">Bytes::collect</target>
        </trans-unit>
        <trans-unit id="6f693335f9495019383b9eadbf3b449bcfc675f9" translate="yes" xml:space="preserve">
          <source>Bytes::copied</source>
          <target state="translated">Bytes::copied</target>
        </trans-unit>
        <trans-unit id="93d1e678c86a68151617f0b02af7cadb48251558" translate="yes" xml:space="preserve">
          <source>Bytes::count</source>
          <target state="translated">Bytes::count</target>
        </trans-unit>
        <trans-unit id="1e5c00a470b7fc4f8da25723aad0fc52e134f397" translate="yes" xml:space="preserve">
          <source>Bytes::cycle</source>
          <target state="translated">Bytes::cycle</target>
        </trans-unit>
        <trans-unit id="9d81621cbab864e41b9591bee2a211c1e6fb3870" translate="yes" xml:space="preserve">
          <source>Bytes::enumerate</source>
          <target state="translated">Bytes::enumerate</target>
        </trans-unit>
        <trans-unit id="ea17a535e18dd3c17944b57230746af970ccf214" translate="yes" xml:space="preserve">
          <source>Bytes::eq</source>
          <target state="translated">Bytes::eq</target>
        </trans-unit>
        <trans-unit id="491e10ca5d759167723a7ee86c3ca2eea1265ab7" translate="yes" xml:space="preserve">
          <source>Bytes::filter</source>
          <target state="translated">Bytes::filter</target>
        </trans-unit>
        <trans-unit id="9742812b0b1477fbb5396ffff48eb2034a65761d" translate="yes" xml:space="preserve">
          <source>Bytes::filter_map</source>
          <target state="translated">Bytes::filter_map</target>
        </trans-unit>
        <trans-unit id="63e7f3cfad0e9eae54402838e01bfca54ca3afa5" translate="yes" xml:space="preserve">
          <source>Bytes::find</source>
          <target state="translated">Bytes::find</target>
        </trans-unit>
        <trans-unit id="290c24197673b5bfcbef8c08eea1c3d3b80c4622" translate="yes" xml:space="preserve">
          <source>Bytes::find_map</source>
          <target state="translated">Bytes::find_map</target>
        </trans-unit>
        <trans-unit id="9f757e2b209fe7676c23fb7de2d9a9666f266a57" translate="yes" xml:space="preserve">
          <source>Bytes::flat_map</source>
          <target state="translated">Bytes::flat_map</target>
        </trans-unit>
        <trans-unit id="ebffc4bee04033b63ddade2d5c137b7551135bbd" translate="yes" xml:space="preserve">
          <source>Bytes::flatten</source>
          <target state="translated">Bytes::flatten</target>
        </trans-unit>
        <trans-unit id="59f9148fe24ec4969d305fc0671cc3b707da545a" translate="yes" xml:space="preserve">
          <source>Bytes::fmt</source>
          <target state="translated">Bytes::fmt</target>
        </trans-unit>
        <trans-unit id="a8078f4655b1978965a5909b5351cb14c6583a92" translate="yes" xml:space="preserve">
          <source>Bytes::fold</source>
          <target state="translated">Bytes::fold</target>
        </trans-unit>
        <trans-unit id="7f2d08f4da0fc0d0fb55752871e004cb4680946d" translate="yes" xml:space="preserve">
          <source>Bytes::for_each</source>
          <target state="translated">Bytes::for_each</target>
        </trans-unit>
        <trans-unit id="62699a9360bcc212fa6c249680ba5b7f48e3fb42" translate="yes" xml:space="preserve">
          <source>Bytes::from</source>
          <target state="translated">Bytes::from</target>
        </trans-unit>
        <trans-unit id="603aaacbdc014366acd2253fbfbd1087387d3bd3" translate="yes" xml:space="preserve">
          <source>Bytes::fuse</source>
          <target state="translated">Bytes::fuse</target>
        </trans-unit>
        <trans-unit id="ef1515771c9b976e1008ae36cc109565b4569ae9" translate="yes" xml:space="preserve">
          <source>Bytes::ge</source>
          <target state="translated">Bytes::ge</target>
        </trans-unit>
        <trans-unit id="445e8b743c0007a524c7e482f8c83e4f69760410" translate="yes" xml:space="preserve">
          <source>Bytes::gt</source>
          <target state="translated">Bytes::gt</target>
        </trans-unit>
        <trans-unit id="24ede3c149e7de7883c58aaa99ee5d5463be74e6" translate="yes" xml:space="preserve">
          <source>Bytes::inspect</source>
          <target state="translated">Bytes::inspect</target>
        </trans-unit>
        <trans-unit id="8cfa8a5aca1d21185175b454e814b3c9674137dc" translate="yes" xml:space="preserve">
          <source>Bytes::into</source>
          <target state="translated">Bytes::into</target>
        </trans-unit>
        <trans-unit id="28993249bc6a265b1f1403816b2a9c4d5624ad5b" translate="yes" xml:space="preserve">
          <source>Bytes::into_iter</source>
          <target state="translated">Bytes::into_iter</target>
        </trans-unit>
        <trans-unit id="290c12fce35e73f7ad4e780c36b8daeaf1f6eaf9" translate="yes" xml:space="preserve">
          <source>Bytes::is_empty</source>
          <target state="translated">Bytes::is_empty</target>
        </trans-unit>
        <trans-unit id="37772f76db83eabf7ef6ed6382f4a6562ec04eaa" translate="yes" xml:space="preserve">
          <source>Bytes::is_sorted</source>
          <target state="translated">Bytes::is_sorted</target>
        </trans-unit>
        <trans-unit id="63f09c7e5213825da442ff7939106416cc2db665" translate="yes" xml:space="preserve">
          <source>Bytes::is_sorted_by</source>
          <target state="translated">Bytes::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="b26f21acb6f08d8c9a5ac1405c3ead0d4c9a6b00" translate="yes" xml:space="preserve">
          <source>Bytes::is_sorted_by_key</source>
          <target state="translated">Bytes::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="f50aedc8dbbe9f4f7c0a8193c92f7fe881b11817" translate="yes" xml:space="preserve">
          <source>Bytes::last</source>
          <target state="translated">Bytes::last</target>
        </trans-unit>
        <trans-unit id="725cf533de1247b9f7939a230859f03c71c3a394" translate="yes" xml:space="preserve">
          <source>Bytes::le</source>
          <target state="translated">Bytes::le</target>
        </trans-unit>
        <trans-unit id="ae500d3c2531704059d772fbff739f3873572e45" translate="yes" xml:space="preserve">
          <source>Bytes::len</source>
          <target state="translated">Bytes::len</target>
        </trans-unit>
        <trans-unit id="b194acd634d0bc66745521f9549d62c66e9a152e" translate="yes" xml:space="preserve">
          <source>Bytes::lt</source>
          <target state="translated">Bytes::lt</target>
        </trans-unit>
        <trans-unit id="61ba21505c7ffe82b863e8bcbc73617c7e13b85c" translate="yes" xml:space="preserve">
          <source>Bytes::map</source>
          <target state="translated">Bytes::map</target>
        </trans-unit>
        <trans-unit id="fe2bc9537a5830454b8a500254016c0d67be2211" translate="yes" xml:space="preserve">
          <source>Bytes::max</source>
          <target state="translated">Bytes::max</target>
        </trans-unit>
        <trans-unit id="43d95dea33020faf006b7b4de468897537052a42" translate="yes" xml:space="preserve">
          <source>Bytes::max_by</source>
          <target state="translated">Bytes::max_by</target>
        </trans-unit>
        <trans-unit id="f7973f4371d6448647f6bb7f82a3cd4cc0be52b8" translate="yes" xml:space="preserve">
          <source>Bytes::max_by_key</source>
          <target state="translated">Bytes::max_by_key</target>
        </trans-unit>
        <trans-unit id="c3d094313a068051eedc54593c00089e5d5e0eaa" translate="yes" xml:space="preserve">
          <source>Bytes::min</source>
          <target state="translated">Bytes::min</target>
        </trans-unit>
        <trans-unit id="a26247387b6acf6339ec71745edbdff81c2ade56" translate="yes" xml:space="preserve">
          <source>Bytes::min_by</source>
          <target state="translated">Bytes::min_by</target>
        </trans-unit>
        <trans-unit id="f5a98f7f6167a1b442d3efa2009d49ad462460d2" translate="yes" xml:space="preserve">
          <source>Bytes::min_by_key</source>
          <target state="translated">Bytes::min_by_key</target>
        </trans-unit>
        <trans-unit id="be90f56db4ada597b587d016fd327003ea0bc760" translate="yes" xml:space="preserve">
          <source>Bytes::ne</source>
          <target state="translated">Bytes::ne</target>
        </trans-unit>
        <trans-unit id="d23038a4910063cad42deff4ad9cf09d48b283fc" translate="yes" xml:space="preserve">
          <source>Bytes::next</source>
          <target state="translated">Bytes::next</target>
        </trans-unit>
        <trans-unit id="8748f7bca019be483c7116e17eaefea91e8337c8" translate="yes" xml:space="preserve">
          <source>Bytes::next_back</source>
          <target state="translated">Bytes::next_back</target>
        </trans-unit>
        <trans-unit id="1a968f4f100322f4def3905de036617309b7b5ca" translate="yes" xml:space="preserve">
          <source>Bytes::nth</source>
          <target state="translated">Bytes::nth</target>
        </trans-unit>
        <trans-unit id="7015bc5abccea19494e4724bb7c18d8ce992e0ad" translate="yes" xml:space="preserve">
          <source>Bytes::nth_back</source>
          <target state="translated">Bytes::nth_back</target>
        </trans-unit>
        <trans-unit id="984cab5be49f32fc6d25120ded4daae67af8fff5" translate="yes" xml:space="preserve">
          <source>Bytes::partial_cmp</source>
          <target state="translated">Bytes::partial_cmp</target>
        </trans-unit>
        <trans-unit id="c5a60b3f92a5a9558e9901c7ea8df4400c6ec0e1" translate="yes" xml:space="preserve">
          <source>Bytes::partition</source>
          <target state="translated">Bytes::partition</target>
        </trans-unit>
        <trans-unit id="fd964e1b6678d8175a0f6d2defa63df03aeae2a2" translate="yes" xml:space="preserve">
          <source>Bytes::peekable</source>
          <target state="translated">Bytes::peekable</target>
        </trans-unit>
        <trans-unit id="7a779a538f4d43ba65ab857aaed4f38c84785133" translate="yes" xml:space="preserve">
          <source>Bytes::position</source>
          <target state="translated">Bytes::position</target>
        </trans-unit>
        <trans-unit id="e26b896020a4dd543d300e63cedf53c6c693b23f" translate="yes" xml:space="preserve">
          <source>Bytes::product</source>
          <target state="translated">Bytes::product</target>
        </trans-unit>
        <trans-unit id="9520a4396d3dd25e6d144b70f3b61774361a54c7" translate="yes" xml:space="preserve">
          <source>Bytes::rev</source>
          <target state="translated">Bytes::rev</target>
        </trans-unit>
        <trans-unit id="c91ff74ba08c7c6ea28c25fc12b5996c8b1497a4" translate="yes" xml:space="preserve">
          <source>Bytes::rfind</source>
          <target state="translated">Bytes::rfind</target>
        </trans-unit>
        <trans-unit id="6d8c28436a470bc527732d151cc6081f1ba37f43" translate="yes" xml:space="preserve">
          <source>Bytes::rfold</source>
          <target state="translated">Bytes::rfold</target>
        </trans-unit>
        <trans-unit id="952ea423fc26cfa8babe6fc58fba9d219ed14f15" translate="yes" xml:space="preserve">
          <source>Bytes::rposition</source>
          <target state="translated">Bytes::rposition</target>
        </trans-unit>
        <trans-unit id="5ca3ed55d60687599d621bf21650f4ef1969fe93" translate="yes" xml:space="preserve">
          <source>Bytes::scan</source>
          <target state="translated">Bytes::scan</target>
        </trans-unit>
        <trans-unit id="ab036dbdadf0542cb3bddc197d995e0027d66c95" translate="yes" xml:space="preserve">
          <source>Bytes::size_hint</source>
          <target state="translated">Bytes::size_hint</target>
        </trans-unit>
        <trans-unit id="7aea93693f858b30cc323b010a39049b5066d25e" translate="yes" xml:space="preserve">
          <source>Bytes::skip</source>
          <target state="translated">Bytes::skip</target>
        </trans-unit>
        <trans-unit id="1238ebec8be4b2a081cb75d76acedcc89efe036e" translate="yes" xml:space="preserve">
          <source>Bytes::skip_while</source>
          <target state="translated">Bytes::skip_while</target>
        </trans-unit>
        <trans-unit id="9c76a1cf5e4f9d6e469d340364ab845f02735723" translate="yes" xml:space="preserve">
          <source>Bytes::step_by</source>
          <target state="translated">Bytes::step_by</target>
        </trans-unit>
        <trans-unit id="79350f102ae506e77c2e1822a20d032e242e08cf" translate="yes" xml:space="preserve">
          <source>Bytes::sum</source>
          <target state="translated">Bytes::sum</target>
        </trans-unit>
        <trans-unit id="4668fe7f8a3335637251054d9c9c06434224fd9e" translate="yes" xml:space="preserve">
          <source>Bytes::take</source>
          <target state="translated">Bytes::take</target>
        </trans-unit>
        <trans-unit id="8188c9f2c65727da6ad6418e7435a0a4d4ae1b63" translate="yes" xml:space="preserve">
          <source>Bytes::take_while</source>
          <target state="translated">Bytes::take_while</target>
        </trans-unit>
        <trans-unit id="1e3d429d72ab5a83b39ca62419e469d95fab4a82" translate="yes" xml:space="preserve">
          <source>Bytes::to_owned</source>
          <target state="translated">Bytes::to_owned</target>
        </trans-unit>
        <trans-unit id="557ed7e76c591066179253aea6bd6a17cfa01f82" translate="yes" xml:space="preserve">
          <source>Bytes::try_fold</source>
          <target state="translated">Bytes::try_fold</target>
        </trans-unit>
        <trans-unit id="3a174ee7598d8449eeadbf2f070bb9163bfdbeef" translate="yes" xml:space="preserve">
          <source>Bytes::try_for_each</source>
          <target state="translated">Bytes::try_for_each</target>
        </trans-unit>
        <trans-unit id="35ddd98f9595299a1b8243f3586e6b1c8d7fa048" translate="yes" xml:space="preserve">
          <source>Bytes::try_from</source>
          <target state="translated">Bytes::try_from</target>
        </trans-unit>
        <trans-unit id="fdf97aa086611d5f965642e0fa40ebed09455a54" translate="yes" xml:space="preserve">
          <source>Bytes::try_into</source>
          <target state="translated">Bytes::try_into</target>
        </trans-unit>
        <trans-unit id="e81eae2ced7b712e89d1325cb3b29c2687db0961" translate="yes" xml:space="preserve">
          <source>Bytes::try_rfold</source>
          <target state="translated">Bytes::try_rfold</target>
        </trans-unit>
        <trans-unit id="93ac1e902ab13110128cd8b40340c9498d027d14" translate="yes" xml:space="preserve">
          <source>Bytes::type_id</source>
          <target state="translated">Bytes::type_id</target>
        </trans-unit>
        <trans-unit id="b8daa236d91d2a612c5d7612ed9d46cc96bcda6a" translate="yes" xml:space="preserve">
          <source>Bytes::unzip</source>
          <target state="translated">Bytes::unzip</target>
        </trans-unit>
        <trans-unit id="47375bdc573035dbf1f0a151a6ddce0a88145906" translate="yes" xml:space="preserve">
          <source>Bytes::zip</source>
          <target state="translated">Bytes::zip</target>
        </trans-unit>
        <trans-unit id="10de289426da74ae5996820227d1ae99ba3ca1bf" translate="yes" xml:space="preserve">
          <source>C chars are most commonly used to make C strings. Unlike Rust, where the length of a string is included alongside the string, C strings mark the end of a string with the character &lt;code&gt;'\0'&lt;/code&gt;. See &lt;a href=&quot;../../ffi/struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">C 문자는 C 문자열을 만드는 데 가장 일반적으로 사용됩니다. 문자열 길이가 문자열과 함께 포함되는 Rust와 달리 C 문자열은 문자열 끝을 문자 &lt;code&gt;'\0'&lt;/code&gt; 합니다. 자세한 내용은 &lt;a href=&quot;../../ffi/struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ec4ff1ee46ab9f978c49b43b23216a55c335e53d" translate="yes" xml:space="preserve">
          <source>C strings are different from Rust strings:</source>
          <target state="translated">C 문자열은 녹 문자열과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4d0a3cd3d0843046e9dc208601e2f872fffb7682" translate="yes" xml:space="preserve">
          <source>C#: attributes</source>
          <target state="translated">C # : 속성</target>
        </trans-unit>
        <trans-unit id="8f7e71dd73911b35b0704326383804842772d25d" translate="yes" xml:space="preserve">
          <source>C++: references, RAII, smart pointers, move semantics, monomorphization, memory model</source>
          <target state="translated">C ++ : 참조, RAII, 스마트 포인터, 이동 시맨틱, 단일 변형, 메모리 모델</target>
        </trans-unit>
        <trans-unit id="d6f809f9a8c2683f3d057fe632dca0828c0f7e4a" translate="yes" xml:space="preserve">
          <source>C-like enum</source>
          <target state="translated">C 형 열거 형</target>
        </trans-unit>
        <trans-unit id="ce41a223396980a3e03634cbe778c52da0c75b6e" translate="yes" xml:space="preserve">
          <source>CAPITAL</source>
          <target state="translated">CAPITAL</target>
        </trans-unit>
        <trans-unit id="ee6b489f0289728c3819dc331f1663c96ca0785c" translate="yes" xml:space="preserve">
          <source>CHAR_LITERAL</source>
          <target state="translated">CHAR_LITERAL</target>
        </trans-unit>
        <trans-unit id="69b56ccff3a6c4424734f57c05d156739380a264" translate="yes" xml:space="preserve">
          <source>CHAR_LITERAL :</source>
          <target state="translated">CHAR_LITERAL :</target>
        </trans-unit>
        <trans-unit id="c855bb9cac705e9e3b723e75b21f4d07cd808dc4" translate="yes" xml:space="preserve">
          <source>CStr</source>
          <target state="translated">CStr</target>
        </trans-unit>
        <trans-unit id="6d8a542fd21b3338ea60a85ae47f0c199d520fae" translate="yes" xml:space="preserve">
          <source>CStr::as_ptr</source>
          <target state="translated">CStr::as_ptr</target>
        </trans-unit>
        <trans-unit id="1f95e3e4ec8be2f019c66897e9c3b6624d851e96" translate="yes" xml:space="preserve">
          <source>CStr::as_ref</source>
          <target state="translated">CStr::as_ref</target>
        </trans-unit>
        <trans-unit id="d700139dd31629deaacc42e4bc9a9d4d45caef0d" translate="yes" xml:space="preserve">
          <source>CStr::borrow</source>
          <target state="translated">CStr::borrow</target>
        </trans-unit>
        <trans-unit id="cc55b0f7e0eedd59a730a23f4f91745521f7abe7" translate="yes" xml:space="preserve">
          <source>CStr::borrow_mut</source>
          <target state="translated">CStr::borrow_mut</target>
        </trans-unit>
        <trans-unit id="fcca1c0586380cf9ec8aaa4478ef4dea99e9db80" translate="yes" xml:space="preserve">
          <source>CStr::clamp</source>
          <target state="translated">CStr::clamp</target>
        </trans-unit>
        <trans-unit id="95ad44c6acf49d720b284daa7324a4c4e8ee9b77" translate="yes" xml:space="preserve">
          <source>CStr::clone_into</source>
          <target state="translated">CStr::clone_into</target>
        </trans-unit>
        <trans-unit id="17ee9041b05f19b08c9a207a0b264abb06217788" translate="yes" xml:space="preserve">
          <source>CStr::cmp</source>
          <target state="translated">CStr::cmp</target>
        </trans-unit>
        <trans-unit id="ef2eafc91f57240446e72aeaeeb2a32e68e97a8b" translate="yes" xml:space="preserve">
          <source>CStr::default</source>
          <target state="translated">CStr::default</target>
        </trans-unit>
        <trans-unit id="54ffaa14459cec5f2273ff104ef1742c78574036" translate="yes" xml:space="preserve">
          <source>CStr::eq</source>
          <target state="translated">CStr::eq</target>
        </trans-unit>
        <trans-unit id="0c4c69764320e8a42e866e61f90c9ac980102de3" translate="yes" xml:space="preserve">
          <source>CStr::fmt</source>
          <target state="translated">CStr::fmt</target>
        </trans-unit>
        <trans-unit id="e9fd5cc915fb0074a2adb82bcea1b9cf07e8ac22" translate="yes" xml:space="preserve">
          <source>CStr::from</source>
          <target state="translated">CStr::from</target>
        </trans-unit>
        <trans-unit id="fef3690a19e427664444d03dfffa43ae3fa6be59" translate="yes" xml:space="preserve">
          <source>CStr::from_bytes_with_nul</source>
          <target state="translated">CStr::from_bytes_with_nul</target>
        </trans-unit>
        <trans-unit id="75111e68b3cace6dc1f25160989a55c75672d185" translate="yes" xml:space="preserve">
          <source>CStr::from_bytes_with_nul_unchecked</source>
          <target state="translated">CStr::from_bytes_with_nul_unchecked</target>
        </trans-unit>
        <trans-unit id="137aefe4f0efa206a17e644e536709f7164f7036" translate="yes" xml:space="preserve">
          <source>CStr::from_ptr</source>
          <target state="translated">CStr::from_ptr</target>
        </trans-unit>
        <trans-unit id="3445b2e9c6d30848e46a0c458e92c18f5478648a" translate="yes" xml:space="preserve">
          <source>CStr::ge</source>
          <target state="translated">CStr::ge</target>
        </trans-unit>
        <trans-unit id="728fbce40efc66cebd46be16b8f1cf779090113f" translate="yes" xml:space="preserve">
          <source>CStr::gt</source>
          <target state="translated">CStr::gt</target>
        </trans-unit>
        <trans-unit id="be0afeee394794477755e07edeb627b53d61bdf3" translate="yes" xml:space="preserve">
          <source>CStr::hash</source>
          <target state="translated">CStr::hash</target>
        </trans-unit>
        <trans-unit id="bb72c84064e334eba596cbe9844aa70e70ee849a" translate="yes" xml:space="preserve">
          <source>CStr::hash_slice</source>
          <target state="translated">CStr::hash_slice</target>
        </trans-unit>
        <trans-unit id="c6bf567f09e2b2bd042059269552397aad871cae" translate="yes" xml:space="preserve">
          <source>CStr::into_c_string</source>
          <target state="translated">CStr::into_c_string</target>
        </trans-unit>
        <trans-unit id="69ab262092debd4569770196660f4febe98420dc" translate="yes" xml:space="preserve">
          <source>CStr::le</source>
          <target state="translated">CStr::le</target>
        </trans-unit>
        <trans-unit id="f1e9e41f63590d10b51a2a294c025ee665034901" translate="yes" xml:space="preserve">
          <source>CStr::lt</source>
          <target state="translated">CStr::lt</target>
        </trans-unit>
        <trans-unit id="348c458cc35acb0213f545d380dceae16ee7b792" translate="yes" xml:space="preserve">
          <source>CStr::max</source>
          <target state="translated">CStr::max</target>
        </trans-unit>
        <trans-unit id="000883cbb32a65bd5d06415a6ea2b885840b8dea" translate="yes" xml:space="preserve">
          <source>CStr::min</source>
          <target state="translated">CStr::min</target>
        </trans-unit>
        <trans-unit id="9f6acbf3ad450fc26ec407cb9b07020457f45140" translate="yes" xml:space="preserve">
          <source>CStr::ne</source>
          <target state="translated">CStr::ne</target>
        </trans-unit>
        <trans-unit id="7abb5f8b92e7fded6ba1d77d76970093cc652367" translate="yes" xml:space="preserve">
          <source>CStr::partial_cmp</source>
          <target state="translated">CStr::partial_cmp</target>
        </trans-unit>
        <trans-unit id="65caa5cdc2514ebded75efc52eddee11acbc1be0" translate="yes" xml:space="preserve">
          <source>CStr::to_bytes</source>
          <target state="translated">CStr::to_bytes</target>
        </trans-unit>
        <trans-unit id="e4257d44ce77a2f26ac5c252e77fb8c42eef081a" translate="yes" xml:space="preserve">
          <source>CStr::to_bytes_with_nul</source>
          <target state="translated">CStr::to_bytes_with_nul</target>
        </trans-unit>
        <trans-unit id="44ead7aea7dc02cf1786c76006d27afcf9a480c8" translate="yes" xml:space="preserve">
          <source>CStr::to_owned</source>
          <target state="translated">CStr::to_owned</target>
        </trans-unit>
        <trans-unit id="ad62220819d69a73a1b88d26957191be23aa8128" translate="yes" xml:space="preserve">
          <source>CStr::to_str</source>
          <target state="translated">CStr::to_str</target>
        </trans-unit>
        <trans-unit id="f8b6323ef660a7621fafb52f71e3630988494495" translate="yes" xml:space="preserve">
          <source>CStr::to_string_lossy</source>
          <target state="translated">CStr::to_string_lossy</target>
        </trans-unit>
        <trans-unit id="1cc3da01043c1b71efdad57e85215058364b7064" translate="yes" xml:space="preserve">
          <source>CStr::type_id</source>
          <target state="translated">CStr::type_id</target>
        </trans-unit>
        <trans-unit id="10fdabde5da32be8abb7d3568067d963d8ef529e" translate="yes" xml:space="preserve">
          <source>CString</source>
          <target state="translated">CString</target>
        </trans-unit>
        <trans-unit id="52e001b95a1b9cf3308a26a6e981035005eab758" translate="yes" xml:space="preserve">
          <source>CString::as_bytes</source>
          <target state="translated">CString::as_bytes</target>
        </trans-unit>
        <trans-unit id="13cab1dddf5c51f1e61f9eee6b49a5636b9bd814" translate="yes" xml:space="preserve">
          <source>CString::as_bytes_with_nul</source>
          <target state="translated">CString::as_bytes_with_nul</target>
        </trans-unit>
        <trans-unit id="797335508475be49326111108ab36a086a72caa3" translate="yes" xml:space="preserve">
          <source>CString::as_c_str</source>
          <target state="translated">CString::as_c_str</target>
        </trans-unit>
        <trans-unit id="7de000d37b9a976d4527e4c70754ba8afd0351c7" translate="yes" xml:space="preserve">
          <source>CString::as_ptr</source>
          <target state="translated">CString::as_ptr</target>
        </trans-unit>
        <trans-unit id="bc0fb3daa028d7ff58f6946c49b2f5b96bc9d602" translate="yes" xml:space="preserve">
          <source>CString::as_ref</source>
          <target state="translated">CString::as_ref</target>
        </trans-unit>
        <trans-unit id="36a33aa7aa5aa4d2d81432af9a988f0f942736ad" translate="yes" xml:space="preserve">
          <source>CString::borrow</source>
          <target state="translated">CString::borrow</target>
        </trans-unit>
        <trans-unit id="8528461b0edd762ff495176944d805d1dde0f8ec" translate="yes" xml:space="preserve">
          <source>CString::borrow_mut</source>
          <target state="translated">CString::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2a50234e42cd54310e4916caa569a9a5aa96a13c" translate="yes" xml:space="preserve">
          <source>CString::clamp</source>
          <target state="translated">CString::clamp</target>
        </trans-unit>
        <trans-unit id="24f213d2e0d20a811ae38f00f41648ad4c89ab8e" translate="yes" xml:space="preserve">
          <source>CString::clone</source>
          <target state="translated">CString::clone</target>
        </trans-unit>
        <trans-unit id="7f0df7e2af8f0985cf2add0b160cbcac287070e5" translate="yes" xml:space="preserve">
          <source>CString::clone_from</source>
          <target state="translated">CString::clone_from</target>
        </trans-unit>
        <trans-unit id="3cabdc5e34bb6bea49169d33f360d4ee04f6ed25" translate="yes" xml:space="preserve">
          <source>CString::clone_into</source>
          <target state="translated">CString::clone_into</target>
        </trans-unit>
        <trans-unit id="d7277d1a271df4865a6f33570de006450712f4a0" translate="yes" xml:space="preserve">
          <source>CString::cmp</source>
          <target state="translated">CString::cmp</target>
        </trans-unit>
        <trans-unit id="baa89c11dc8118d826240007d81976bd7413a3b6" translate="yes" xml:space="preserve">
          <source>CString::default</source>
          <target state="translated">CString::default</target>
        </trans-unit>
        <trans-unit id="347d98047b56cd9966454be82309f4e8529682ff" translate="yes" xml:space="preserve">
          <source>CString::deref</source>
          <target state="translated">CString::deref</target>
        </trans-unit>
        <trans-unit id="ab34938730f49553f7aecab1bb2c2843aa651704" translate="yes" xml:space="preserve">
          <source>CString::drop</source>
          <target state="translated">CString::drop</target>
        </trans-unit>
        <trans-unit id="60996dc07ecd992dd60d5ceec16cc375ea67d6b9" translate="yes" xml:space="preserve">
          <source>CString::eq</source>
          <target state="translated">CString::eq</target>
        </trans-unit>
        <trans-unit id="e70be0cad84fe664f3a9891f184d6d6a7283a582" translate="yes" xml:space="preserve">
          <source>CString::fmt</source>
          <target state="translated">CString::fmt</target>
        </trans-unit>
        <trans-unit id="cbf381ece793251aee2eeadc010afe3c0f4a86e0" translate="yes" xml:space="preserve">
          <source>CString::from</source>
          <target state="translated">CString::from</target>
        </trans-unit>
        <trans-unit id="a143620acced132aa78acde78ce1bd6ab7b63f7e" translate="yes" xml:space="preserve">
          <source>CString::from_raw</source>
          <target state="translated">CString::from_raw</target>
        </trans-unit>
        <trans-unit id="dc9b49de9e2271c2ed3506615af6e6d8c4861395" translate="yes" xml:space="preserve">
          <source>CString::from_vec_unchecked</source>
          <target state="translated">CString::from_vec_unchecked</target>
        </trans-unit>
        <trans-unit id="1a539736b4bb0e500f677893082fd23c664398df" translate="yes" xml:space="preserve">
          <source>CString::ge</source>
          <target state="translated">CString::ge</target>
        </trans-unit>
        <trans-unit id="668f249df3f7a2e1e7a9e166dd065bd8ea489b01" translate="yes" xml:space="preserve">
          <source>CString::gt</source>
          <target state="translated">CString::gt</target>
        </trans-unit>
        <trans-unit id="e46cf065cca5e3cd1f01cce699aa22189f1cb26b" translate="yes" xml:space="preserve">
          <source>CString::hash</source>
          <target state="translated">CString::hash</target>
        </trans-unit>
        <trans-unit id="0833d863637dfd6ed73ce7a7ea13d011f707f04d" translate="yes" xml:space="preserve">
          <source>CString::hash_slice</source>
          <target state="translated">CString::hash_slice</target>
        </trans-unit>
        <trans-unit id="432d0b1932bbe3eb2d6ef0fa7ec29b9397259ae9" translate="yes" xml:space="preserve">
          <source>CString::index</source>
          <target state="translated">CString::index</target>
        </trans-unit>
        <trans-unit id="cd0ce393340efaa8f18ad5cb50aad07f3d2eeea4" translate="yes" xml:space="preserve">
          <source>CString::into</source>
          <target state="translated">CString::into</target>
        </trans-unit>
        <trans-unit id="59bfaa59d401f415773f033626b7896ccc5c6f79" translate="yes" xml:space="preserve">
          <source>CString::into_boxed_c_str</source>
          <target state="translated">CString::into_boxed_c_str</target>
        </trans-unit>
        <trans-unit id="96b480440e4b607a24895b6512350ea1afafd31c" translate="yes" xml:space="preserve">
          <source>CString::into_bytes</source>
          <target state="translated">CString::into_bytes</target>
        </trans-unit>
        <trans-unit id="cc5eefdedab1063685f507370a9d8ab88c34cbda" translate="yes" xml:space="preserve">
          <source>CString::into_bytes_with_nul</source>
          <target state="translated">CString::into_bytes_with_nul</target>
        </trans-unit>
        <trans-unit id="aefcc1dc128b6b5cd3742344d58563aafb746370" translate="yes" xml:space="preserve">
          <source>CString::into_raw</source>
          <target state="translated">CString::into_raw</target>
        </trans-unit>
        <trans-unit id="f2693a15445d228f3db30100d51e43c8372af6e2" translate="yes" xml:space="preserve">
          <source>CString::into_string</source>
          <target state="translated">CString::into_string</target>
        </trans-unit>
        <trans-unit id="8bee9b3af5aa7e5de7c21a5ebc17b1acccf5ee8e" translate="yes" xml:space="preserve">
          <source>CString::le</source>
          <target state="translated">CString::le</target>
        </trans-unit>
        <trans-unit id="a139512687d9e3c6e3a92b9473958b2f7df1eb47" translate="yes" xml:space="preserve">
          <source>CString::lt</source>
          <target state="translated">CString::lt</target>
        </trans-unit>
        <trans-unit id="eaaa87d3cf20a5d0e070b569e586340d5ecb604f" translate="yes" xml:space="preserve">
          <source>CString::max</source>
          <target state="translated">CString::max</target>
        </trans-unit>
        <trans-unit id="72b7071a2efa7b6ad66daf332571bc9f191bed64" translate="yes" xml:space="preserve">
          <source>CString::min</source>
          <target state="translated">CString::min</target>
        </trans-unit>
        <trans-unit id="2516dc9b57566e8c9c5ced5df9a3f6886f48ed5c" translate="yes" xml:space="preserve">
          <source>CString::ne</source>
          <target state="translated">CString::ne</target>
        </trans-unit>
        <trans-unit id="057c250d247622d3e7250ede8d66d4f4fe5f006a" translate="yes" xml:space="preserve">
          <source>CString::new</source>
          <target state="translated">CString::new</target>
        </trans-unit>
        <trans-unit id="eff1b495447d52f2ff92fe44126c3e0f7e62bd18" translate="yes" xml:space="preserve">
          <source>CString::partial_cmp</source>
          <target state="translated">CString::partial_cmp</target>
        </trans-unit>
        <trans-unit id="ba7cc72bb439ffacb3c246cdf7d4ea38bf7c37ba" translate="yes" xml:space="preserve">
          <source>CString::to_bytes</source>
          <target state="translated">CString::to_bytes</target>
        </trans-unit>
        <trans-unit id="52c93cc3f089d3ead1daed54786cb1adefbefc0e" translate="yes" xml:space="preserve">
          <source>CString::to_bytes_with_nul</source>
          <target state="translated">CString::to_bytes_with_nul</target>
        </trans-unit>
        <trans-unit id="d066a96cc2aeab0a52ff35a69bfade1ebb5b679e" translate="yes" xml:space="preserve">
          <source>CString::to_owned</source>
          <target state="translated">CString::to_owned</target>
        </trans-unit>
        <trans-unit id="2511594a074122956a7b9aac6c3b45531240e7fc" translate="yes" xml:space="preserve">
          <source>CString::to_str</source>
          <target state="translated">CString::to_str</target>
        </trans-unit>
        <trans-unit id="b9d046be15dc8b7b1d4ad0b19b0da5323bf450ae" translate="yes" xml:space="preserve">
          <source>CString::to_string_lossy</source>
          <target state="translated">CString::to_string_lossy</target>
        </trans-unit>
        <trans-unit id="9d84fa601d6e1d36b0d57472ca64c553b64dab03" translate="yes" xml:space="preserve">
          <source>CString::try_from</source>
          <target state="translated">CString::try_from</target>
        </trans-unit>
        <trans-unit id="f11ef73d8e97b738c053ffd9938664b3d2273bd5" translate="yes" xml:space="preserve">
          <source>CString::try_into</source>
          <target state="translated">CString::try_into</target>
        </trans-unit>
        <trans-unit id="1a51fb95b46c52bf3add938b9cfe7d50ef6bacbf" translate="yes" xml:space="preserve">
          <source>CString::type_id</source>
          <target state="translated">CString::type_id</target>
        </trans-unit>
        <trans-unit id="ec9fe493034beaebc0e01624240518933e14a78a" translate="yes" xml:space="preserve">
          <source>Caching values is a generally useful behavior that we might want to use in other parts of our code with different closures. However, there are two problems with the current implementation of &lt;code&gt;Cacher&lt;/code&gt; that would make reusing it in different contexts difficult.</source>
          <target state="translated">캐싱 값은 코드의 다른 부분에서 다른 클로저로 사용하려는 일반적으로 유용한 동작입니다. 그러나 현재의 &lt;code&gt;Cacher&lt;/code&gt; 구현에는 두 가지 문제가있어 다른 컨텍스트에서이를 재사용하기 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="ca70ff3bbc1574ec864e13a85775af1c9fd2dc54" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;self&lt;/code&gt; + &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; + &lt;code&gt;rhs&lt;/code&gt; 를 계산합니다</target>
        </trans-unit>
        <trans-unit id="c60cc01325d6ae275f88e47a24f1234f7eab35f7" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;self&lt;/code&gt; - &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">를 계산의 &lt;code&gt;self&lt;/code&gt; - &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a2ce2b6e7049ed5ebef3ea78f7f49e41b51d70f5" translate="yes" xml:space="preserve">
          <source>Calculates Euclidean division, the matching method for &lt;code&gt;rem_euclid&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rem_euclid&lt;/code&gt; 에 대한 일치 방법 인 유클리드 디비전을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="9f1a1acd0979000f557bd9fe260b8e844069c43f" translate="yes" xml:space="preserve">
          <source>Calculates the distance between two pointers. The returned value is in units of T: the distance in bytes is divided by &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;.</source>
          <target state="translated">두 포인터 사이의 거리를 계산합니다. 리턴 된 값은 T 단위입니다. 바이트 단위의 거리는 &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 로 나뉩니다 .</target>
        </trans-unit>
        <trans-unit id="5127f08bc025120d1faa493287d1d0eee0006108" translate="yes" xml:space="preserve">
          <source>Calculates the divisor when &lt;code&gt;self&lt;/code&gt; is divided by &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 &lt;code&gt;rhs&lt;/code&gt; 로 나누어 질 때 제수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="fc217ee649e4f99c72864fd7fe451c173d18439f" translate="yes" xml:space="preserve">
          <source>Calculates the least nonnegative remainder of &lt;code&gt;self (mod rhs)&lt;/code&gt;.</source>
          <target state="translated">가장 음이 아닌 나머지 &lt;code&gt;self (mod rhs)&lt;/code&gt; 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="aa698abba4132e7de76a90696509e57b698e9680" translate="yes" xml:space="preserve">
          <source>Calculates the least remainder of &lt;code&gt;self (mod rhs)&lt;/code&gt;.</source>
          <target state="translated">가장 적은 나머지 &lt;code&gt;self (mod rhs)&lt;/code&gt; 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="c7ea3c4efe85a6701802881e07221808f6b72f10" translate="yes" xml:space="preserve">
          <source>Calculates the length of the hypotenuse of a right-angle triangle given legs of length &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">길이 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 다리에 대해 직각 삼각형의 빗변의 길이를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="2204ea9d183af2eb3c958e206adf62733fcb72b8" translate="yes" xml:space="preserve">
          <source>Calculates the multiplication of &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 의 곱셈을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="e1f0a45d6193bb4f48999acaf0e6da752bd21197" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer (convenience for &lt;code&gt;.offset((count as isize).wrapping_neg())&lt;/code&gt;).</source>
          <target state="translated">포인터에서 오프셋을 계산합니다 ( &lt;code&gt;.offset((count as isize).wrapping_neg())&lt;/code&gt; 대한 편의 ).</target>
        </trans-unit>
        <trans-unit id="2cdd04036e314797a2d49a1129ff94310c799250" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer (convenience for &lt;code&gt;.offset(count as isize)&lt;/code&gt;).</source>
          <target state="translated">포인터로부터의 오프셋을 계산합니다 ( &lt;code&gt;.offset(count as isize)&lt;/code&gt; 대한 편리함 ).</target>
        </trans-unit>
        <trans-unit id="5c58135d353fa0b65d9d7d232ccec38157ca294b" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer using wrapping arithmetic.</source>
          <target state="translated">줄 바꿈 산술을 사용하여 포인터에서 오프셋을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="3a96ac2990d9d6aa59d405db07b7ab3697d51ab5" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer using wrapping arithmetic. (convenience for &lt;code&gt;.wrapping_offset((count as isize).wrapping_sub())&lt;/code&gt;)</source>
          <target state="translated">줄 바꿈 산술을 사용하여 포인터에서 오프셋을 계산합니다. ( &lt;code&gt;.wrapping_offset((count as isize).wrapping_sub())&lt;/code&gt; 대한 편의 )</target>
        </trans-unit>
        <trans-unit id="4437f7540901d3da485cf44951a321623f5d54ea" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer using wrapping arithmetic. (convenience for &lt;code&gt;.wrapping_offset(count as isize)&lt;/code&gt;)</source>
          <target state="translated">줄 바꿈 산술을 사용하여 포인터에서 오프셋을 계산합니다. ( &lt;code&gt;.wrapping_offset(count as isize)&lt;/code&gt; 대한 편의 )</target>
        </trans-unit>
        <trans-unit id="fced3b907bf59a9a00c1e327030e6d3af8cc26ee" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer using wrapping arithmetic. &lt;code&gt;count&lt;/code&gt; is in units of T; e.g., a &lt;code&gt;count&lt;/code&gt; of 3 represents a pointer offset of &lt;code&gt;3 * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes.</source>
          <target state="translated">줄 바꿈 산술을 사용하여 포인터에서 오프셋을 계산합니다. &lt;code&gt;count&lt;/code&gt; 는 T 단위입니다. 예를 들어, &lt;code&gt;count&lt;/code&gt; 3은 &lt;code&gt;3 * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 바이트 의 포인터 오프셋을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="bb349c3d2b61d501336bb2fe8cf2ff557d376135" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer, potentially wrapping.</source>
          <target state="translated">포인터에서 오프셋을 계산하여 줄 바꿈을합니다.</target>
        </trans-unit>
        <trans-unit id="bceae705a5fda0d95a2adc01d7e85d8d0a2f7b90" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer.</source>
          <target state="translated">포인터로부터 오프셋을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="20e05ec484d26186b0ee114ebaa6c93c15ef1c02" translate="yes" xml:space="preserve">
          <source>Calculates the quotient of Euclidean division &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt;.</source>
          <target state="translated">유클리드 나눗셈 &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt; 의 몫을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="39720ba2c3f54664835e5cfd429b8dbb6ddb3ddb" translate="yes" xml:space="preserve">
          <source>Calculates the quotient of Euclidean division of &lt;code&gt;self&lt;/code&gt; by &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; 에 의한 &lt;code&gt;self&lt;/code&gt; 유클리드 나눗셈의 지수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="f5a8c64bc432948fb8acbf8240c8594765e8fa48" translate="yes" xml:space="preserve">
          <source>Calculates the remainder &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt; as if by Euclidean division.</source>
          <target state="translated">유클리드 디비전에 의한 것처럼 나머지 &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt; 를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="dd73ba699034056b9c5150298e8d456b025d264b" translate="yes" xml:space="preserve">
          <source>Calculates the remainder when &lt;code&gt;self&lt;/code&gt; is divided by &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 &lt;code&gt;rhs&lt;/code&gt; 로 나뉘어 질 때 나머지를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="beb148e8941aab843a69c5323a4e82bfc27fae30" translate="yes" xml:space="preserve">
          <source>Calculations in applications like audio decoders often prioritize performance most highly. Here, we&amp;rsquo;re creating an iterator, using two adaptors, and then consuming the value. What assembly code would this Rust code compile to? Well, as of this writing, it compiles down to the same assembly you&amp;rsquo;d write by hand. There&amp;rsquo;s no loop at all corresponding to the iteration over the values in &lt;code&gt;coefficients&lt;/code&gt;: Rust knows that there are 12 iterations, so it &amp;ldquo;unrolls&amp;rdquo; the loop. &lt;em&gt;Unrolling&lt;/em&gt; is an optimization that removes the overhead of the loop controlling code and instead generates repetitive code for each iteration of the loop.</source>
          <target state="translated">오디오 디코더와 같은 응용 프로그램에서의 계산은 종종 성능을 최우선으로합니다. 여기서 우리는 두 개의 어댑터를 사용하여 반복자를 만들고 값을 소비합니다. 이 Rust 코드는 어떤 어셈블리 코드로 컴파일됩니까? 글을 쓰는 시점에서, 그것은 직접 작성한 것과 같은 어셈블리로 컴파일됩니다. &lt;code&gt;coefficients&lt;/code&gt; 의 값에 대한 반복에 해당하는 루프는 전혀 없습니다 . Rust는 12 개의 반복이 있다는 것을 알고 있으므로 루프를 &quot;풀립니다&quot;. &lt;em&gt;언 롤링&lt;/em&gt; 은 루프 제어 코드의 오버 헤드를 제거하고 루프의 각 반복에 대해 반복 코드를 생성하는 최적화입니다.</target>
        </trans-unit>
        <trans-unit id="f8b36fa1c392c82310456798302780289916c221" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;unsafe&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 함수 호출</target>
        </trans-unit>
        <trans-unit id="21f282ae75f0466a6ba7a1e840066c459209e8a0" translate="yes" xml:space="preserve">
          <source>Call an unsafe function or method</source>
          <target state="translated">안전하지 않은 함수 또는 메소드 호출</target>
        </trans-unit>
        <trans-unit id="0298ffd4d4d74b375411d1b2e3969f0f3205473d" translate="yes" xml:space="preserve">
          <source>Call expressions</source>
          <target state="translated">호출 식</target>
        </trans-unit>
        <trans-unit id="6249f8a9ffd810d4ed69b84e3c802196af864e8b" translate="yes" xml:space="preserve">
          <source>Call traits and coercions</source>
          <target state="translated">특성과 강요를 불러라</target>
        </trans-unit>
        <trans-unit id="0c2ff20766f3c9231511aafd553b6c2bff815c3d" translate="yes" xml:space="preserve">
          <source>Callers in turn must expect the source to be in any state that is consistent with its public API since adapters sitting between it and the source have the same access. In particular an adapter may have consumed more elements than strictly necessary.</source>
          <target state="translated">호출자는 소스와 소스 사이에있는 어댑터가 동일한 액세스 권한을 갖기 때문에 소스가 공개 API와 일치하는 모든 상태에있을 것으로 예상해야합니다. 특히 어댑터는 꼭 필요한 것보다 더 많은 요소를 소비했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c586bbc683322c086eef8701f61479b8313e2e3" translate="yes" xml:space="preserve">
          <source>Callers of memory allocation APIs wishing to abort computation in response to an allocation error are encouraged to call this function, rather than directly invoking &lt;code&gt;panic!&lt;/code&gt; or similar.</source>
          <target state="translated">할당 오류에 대한 응답으로 계산을 중단하려는 메모리 할당 API 호출자는 직접 &lt;code&gt;panic!&lt;/code&gt; 호출하는 대신이 함수를 호출하는 것이 좋습니다 ! 또는 유사합니다.</target>
        </trans-unit>
        <trans-unit id="0a1fed80ce769e9299beec7ef90b5a7b9c915af1" translate="yes" xml:space="preserve">
          <source>Callers of this function are responsible that these preconditions are satisfied:</source>
          <target state="translated">이 기능의 호출자는 다음 전제 조건이 충족되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d1c291d9a0fdcacf48fd819bb42d20e5d81ebaea" translate="yes" xml:space="preserve">
          <source>Callers of this function are responsible that three preconditions are satisfied:</source>
          <target state="translated">이 기능을 호출 한 사람은 세 가지 전제 조건이 충족되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7d8639a217f023f0e5aaf72760a98b8b29436661" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; (or other functions that wrap around it) will make the parent process wait until the child has actually exited before continuing.</source>
          <target state="translated">&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; (또는 그 주위를 감싸는 다른 함수)를 호출 하면 계속하기 전에 자식이 실제로 종료 될 때까지 부모 프로세스가 대기하게됩니다.</target>
        </trans-unit>
        <trans-unit id="481d687176f898ccda26367fc40f1ddb55f0bae7" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;struct.child#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; (or other functions that wrap around it) will make the parent process wait until the child has actually exited before continuing.</source>
          <target state="translated">&lt;a href=&quot;struct.child#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; (또는이를 감싸는 다른 함수)를 호출 하면 계속하기 전에 자식이 실제로 종료 될 때까지 부모 프로세스가 대기하게됩니다.</target>
        </trans-unit>
        <trans-unit id="b5deeaea616be877d309408666a16c136418ff8a" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; guarantees that at least one value of the iterator's underlying source has been moved out and the result of the iterator chain could be inserted in its place, assuming structural constraints of the source allow such an insertion. In other words this trait indicates that an iterator pipeline can be collected in place.</source>
          <target state="translated">&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt; 호출 하면 반복기의 기본 소스 중 적어도 하나의 값이 밖으로 이동되고 반복기 체인의 결과가 소스의 구조적 제약이 그러한 삽입을 허용한다고 가정하여 그 자리에 삽입 될 수 있음을 보장합니다. 즉,이 특성은 반복기 파이프 라인을 제자리에서 수집 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2e7c98d8910ba30f7a29fe334c3bdf59a65f7d25" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; this way gets repetitive. Rust has a construct which can call &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; on your iterator, until it reaches &lt;code&gt;None&lt;/code&gt;. Let's go over that next.</source>
          <target state="translated">이 방법으로 &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 호출 은 반복됩니다. Rust는 &lt;code&gt;None&lt;/code&gt; 에 도달 할 때까지 반복자에서 &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 를 호출 할 수있는 구조를 가지고 있습니다 . 다음에 그것에 대해 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="062a68bd5946d6865cea7336de4cb67da3dd476e" translate="yes" xml:space="preserve">
          <source>Calling &lt;code id=&quot;calling-confignew-and-handling-errors&quot;&gt;Config::new&lt;/code&gt; and Handling Errors</source>
          <target state="translated">&lt;code id=&quot;calling-confignew-and-handling-errors&quot;&gt;Config::new&lt;/code&gt; 호출 및 오류 처리</target>
        </trans-unit>
        <trans-unit id="05271cdf6db26718c2abf90da7409799d4703173" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;advance_back_by(0)&lt;/code&gt; does not consume any elements and always returns &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(())&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;advance_back_by(0)&lt;/code&gt; 호출 은 요소를 소비하지 않고 항상 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(())&lt;/code&gt; &lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f2db88eb30c547ef9dcc31ceb834f1125361cdd6" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;advance_back_by(0)&lt;/code&gt; does not consume any elements and always returns [&lt;code&gt;Ok(())&lt;/code&gt;].</source>
          <target state="translated">&lt;code&gt;advance_back_by(0)&lt;/code&gt; 호출 은 요소를 소비하지 않고 항상 [ &lt;code&gt;Ok(())&lt;/code&gt; ]를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="df6f9e29581ee3a7fb3292d54be3a75552132038" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;advance_by(0)&lt;/code&gt; does not consume any elements and always returns &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(())&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;advance_by(0)&lt;/code&gt; 호출 은 요소를 소비하지 않으며 항상 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(())&lt;/code&gt; &lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="29810a8b26f09a3007bc1a15cd51bd68ab82979c" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;advance_by(0)&lt;/code&gt; does not consume any elements and always returns [&lt;code&gt;Ok(())&lt;/code&gt;].</source>
          <target state="translated">&lt;code&gt;advance_by(0)&lt;/code&gt; 호출 은 요소를 소비하지 않고 항상 [ &lt;code&gt;Ok(())&lt;/code&gt; ]를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e40c65454f5635fc0b10e5666dc4831c6b5a85ea" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;into_owned&lt;/code&gt; on a &lt;code&gt;Cow::Borrowed&lt;/code&gt; clones the underlying data and becomes a &lt;code&gt;Cow::Owned&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Cow::Borrowed&lt;/code&gt; 에서 &lt;code&gt;into_owned&lt;/code&gt; 를 호출 하면 기본 데이터가 복제되고 &lt;code&gt;Cow::Owned&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d45f4417b85022c3db61725f3af3e2cc322eb41e" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;into_owned&lt;/code&gt; on a &lt;code&gt;Cow::Owned&lt;/code&gt; is a no-op:</source>
          <target state="translated">&lt;code&gt;Cow::Owned&lt;/code&gt; &lt;code&gt;into_owned&lt;/code&gt; 에 into_owned 를 호출 하는 것은 아무런 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="695c031ebd8b1d35a483a10782e7c17d879fd0d1" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;join&lt;/code&gt; on the handle blocks the thread currently running until the thread represented by the handle terminates. &lt;em&gt;Blocking&lt;/em&gt; a thread means that thread is prevented from performing work or exiting. Because we&amp;rsquo;ve put the call to &lt;code&gt;join&lt;/code&gt; after the main thread&amp;rsquo;s &lt;code&gt;for&lt;/code&gt; loop, running Listing 16-2 should produce output similar to this:</source>
          <target state="translated">핸들에서 &lt;code&gt;join&lt;/code&gt; 을 호출 하면 핸들이 나타내는 스레드가 종료 될 때까지 현재 실행중인 스레드가 차단됩니다. 스레드를 &lt;em&gt;차단&lt;/em&gt; 하면 스레드가 작업을 수행하거나 종료되지 않습니다. 메인 스레드의 &lt;code&gt;for&lt;/code&gt; 루프 다음 에 &lt;code&gt;join&lt;/code&gt; 을 호출하기 때문에 Listing 16-2를 실행하면 다음과 비슷한 출력이 생성된다.</target>
        </trans-unit>
        <trans-unit id="bba53e5336fa9eed56530a5c7e1f4d704c60b408" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;next()&lt;/code&gt; this way gets repetitive. Rust has a construct which can call &lt;code&gt;next()&lt;/code&gt; on your iterator, until it reaches &lt;code&gt;None&lt;/code&gt;. Let's go over that next.</source>
          <target state="translated">이런 식으로 &lt;code&gt;next()&lt;/code&gt; 호출 하면 반복됩니다. Rust에는 &lt;code&gt;None&lt;/code&gt; 이 될 때까지 반복자에서 &lt;code&gt;next()&lt;/code&gt; 를 호출 할 수있는 구문이 있습니다 . 다음으로 넘어 갑시다.</target>
        </trans-unit>
        <trans-unit id="52eefc013b01e5d9adae0a652dc16672febe75fe" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;nth()&lt;/code&gt; multiple times doesn't rewind the iterator:</source>
          <target state="translated">&lt;code&gt;nth()&lt;/code&gt; 여러 번 호출 해도 반복자가 되 감지 않습니다.</target>
        </trans-unit>
        <trans-unit id="162f7cd67f7da63727e6f1ac3373291fc6afc8f1" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;nth_back()&lt;/code&gt; multiple times doesn't rewind the iterator:</source>
          <target state="translated">&lt;code&gt;nth_back()&lt;/code&gt; 여러 번 호출 해도 반복자가 되 감지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c598d6b0bb84ae897f110d0577b80a5562b3ffe9" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;to_string_lossy&lt;/code&gt; on a &lt;code&gt;CStr&lt;/code&gt; containing invalid UTF-8:</source>
          <target state="translated">잘못된 UTF-8을 포함 하는 &lt;code&gt;CStr&lt;/code&gt; 에서 &lt;code&gt;to_string_lossy&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="7e6835821e80fa4f9f034eef42e8cd6c55d7f554" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;to_string_lossy&lt;/code&gt; on a &lt;code&gt;CStr&lt;/code&gt; containing valid UTF-8:</source>
          <target state="translated">유효한 UTF-8을 포함 하는 &lt;code&gt;CStr&lt;/code&gt; 에서 &lt;code&gt;to_string_lossy&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="7c7011eb1a41a55a7c56907e801179e9dea5b3cf" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;to_string_lossy&lt;/code&gt; on a &lt;code&gt;Path&lt;/code&gt; with valid unicode:</source>
          <target state="translated">유효한 유니 코드가 있는 &lt;code&gt;Path&lt;/code&gt; 에서 &lt;code&gt;to_string_lossy&lt;/code&gt; 호출 :</target>
        </trans-unit>
        <trans-unit id="f31c7c45b0c7aeef2d4d0ffc68da4406c29790a0" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;to_string_lossy&lt;/code&gt; on an &lt;code&gt;OsStr&lt;/code&gt; with invalid unicode:</source>
          <target state="translated">호출 &lt;code&gt;to_string_lossy&lt;/code&gt; 온 &lt;code&gt;OsStr&lt;/code&gt; 잘못된 유니 코드를 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
