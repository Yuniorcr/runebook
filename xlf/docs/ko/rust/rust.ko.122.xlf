<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="d4945a59276bcf1f4830f2a8c1b3defd3c68cde5" translate="yes" xml:space="preserve">
          <source>Namespace path</source>
          <target state="translated">네임 스페이스 경로</target>
        </trans-unit>
        <trans-unit id="59cb29ad5b08231ec027d2b58b07b4db4094a48e" translate="yes" xml:space="preserve">
          <source>Naming hardcoded values used throughout your program as constants is useful in conveying the meaning of that value to future maintainers of the code. It also helps to have only one place in your code you would need to change if the hardcoded value needed to be updated in the future.</source>
          <target state="translated">프로그램 전체에서 사용되는 하드 코딩 된 값의 이름을 상수로 지정하면 해당 값의 의미를 향후 코드 관리자에게 전달하는 데 유용합니다. 또한 나중에 하드 코딩 된 값을 업데이트해야하는 경우 변경해야 할 코드에 코드를 한 곳에 배치하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="4ea0a808e9b003709a882c3eda3364c5952aaed6" translate="yes" xml:space="preserve">
          <source>Naming threads</source>
          <target state="translated">명명 스레드</target>
        </trans-unit>
        <trans-unit id="2773f0d2f9f4e7e59e9c30b201b04dd1a5c30189" translate="yes" xml:space="preserve">
          <source>Native threads.</source>
          <target state="translated">기본 스레드.</target>
        </trans-unit>
        <trans-unit id="f736bf35e196e5f8a2152cf612783a7b401c2cad" translate="yes" xml:space="preserve">
          <source>Ne</source>
          <target state="translated">Ne</target>
        </trans-unit>
        <trans-unit id="ad9041802b2ad5cd647573800f68f895c77cc8fe" translate="yes" xml:space="preserve">
          <source>Neg</source>
          <target state="translated">Neg</target>
        </trans-unit>
        <trans-unit id="64377c7ff3fff06094951f56bcf30132ee73161a" translate="yes" xml:space="preserve">
          <source>Neg::neg</source>
          <target state="translated">Neg::neg</target>
        </trans-unit>
        <trans-unit id="2133424c311abcb51295591d17f0ab0ae52b1f1a" translate="yes" xml:space="preserve">
          <source>Negates self in an overflowing fashion.</source>
          <target state="translated">넘치는 방식으로 자기를 부정합니다.</target>
        </trans-unit>
        <trans-unit id="163f10b84a51abc2d56ad3b9131ea073b011f340" translate="yes" xml:space="preserve">
          <source>Negates self, overflowing if this is equal to the minimum value.</source>
          <target state="translated">이 값이 최소값과 같으면 오버플로됩니다.</target>
        </trans-unit>
        <trans-unit id="24048c04eba343a323fecac37d642445c66f6c28" translate="yes" xml:space="preserve">
          <source>Negation</source>
          <target state="translated">Negation</target>
        </trans-unit>
        <trans-unit id="f43c19cc20dec09f56a336941f1748c0f4c49844" translate="yes" xml:space="preserve">
          <source>Negation operators</source>
          <target state="translated">부정 연산자</target>
        </trans-unit>
        <trans-unit id="17843c0405b3d56c0f1f2a9c5762b3ce7f769007" translate="yes" xml:space="preserve">
          <source>Negation*</source>
          <target state="translated">Negation*</target>
        </trans-unit>
        <trans-unit id="b07705471769113a1673291a380e793691cb93d8" translate="yes" xml:space="preserve">
          <source>Negative implementations are a promise that the trait will never be implemented for the given types. Therefore, both cannot exists at the same time.</source>
          <target state="translated">부정적인 구현은 특성이 주어진 유형에 대해 구현되지 않을 것이라는 약속입니다. 따라서 둘 다 동시에 존재할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b31bd178b9fc5ff620f5314f9aa5aa57ccd4286" translate="yes" xml:space="preserve">
          <source>Negative impls are not allowed to have any items. Negative impls declare that a trait is &lt;strong&gt;not&lt;/strong&gt; implemented (and never will be) and hence there is no need to specify the values for trait methods or other items.</source>
          <target state="translated">네거티브 impl에는 항목이 허용되지 않습니다. 네거티브 impls는 트레이 트가 구현되지 않았고 결코 구현 &lt;strong&gt;되지 않을&lt;/strong&gt; 것이라고 선언하므로 트레이 트 메서드 나 다른 항목에 대한 값을 지정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e113717082f98a849bcb00740af62ca1b508554b" translate="yes" xml:space="preserve">
          <source>Negative impls are only allowed for auto traits. For more information see the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot;&gt;opt-in builtin traits RFC&lt;/a&gt;.</source>
          <target state="translated">네거티브 임펄스는 자동 특성에만 허용됩니다. 자세한 정보는 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot;&gt;옵트 인 내장 특성 RFC를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0615e40800cad75c4988298cdebe16d2bc992b36" translate="yes" xml:space="preserve">
          <source>Negative impls cannot be default impls. A default impl supplies default values for the items within to be used by other impls, whereas a negative impl declares that there are no other impls. Combining it does not make sense.</source>
          <target state="translated">음의 impl은 기본 impl이 될 수 없습니다. 기본 impl은 다른 impl에서 사용할 항목에 대한 기본값을 제공하는 반면 음수 impl은 다른 impl이 없음을 선언합니다. 그것을 결합하는 것은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="075388f0e224328f0ef13d31f89995f6f2c54896" translate="yes" xml:space="preserve">
          <source>Negative infinity</source>
          <target state="translated">음의 무한대</target>
        </trans-unit>
        <trans-unit id="bb6b7b244457f2bc0330b32b4347438278828967" translate="yes" xml:space="preserve">
          <source>Negative infinity (&amp;minus;&amp;infin;).</source>
          <target state="translated">음의 무한대 (&amp;minus;&amp;infin;).</target>
        </trans-unit>
        <trans-unit id="31031ada08602da6a93f5f5a6962d2039849eda8" translate="yes" xml:space="preserve">
          <source>Negative infinity (&amp;minus;&amp;infin;). Use &lt;a href=&quot;../primitive.f32#associatedconstant.NEG_INFINITY&quot;&gt;&lt;code&gt;f32::NEG_INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">음의 무한대 (&amp;minus;&amp;infin;). 대신 &lt;a href=&quot;../primitive.f32#associatedconstant.NEG_INFINITY&quot;&gt; &lt;code&gt;f32::NEG_INFINITY&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f342b4f8475b808f61b1967602254bedfcdc5688" translate="yes" xml:space="preserve">
          <source>Negative infinity (&amp;minus;&amp;infin;). Use &lt;a href=&quot;../primitive.f64#associatedconstant.NEG_INFINITY&quot;&gt;&lt;code&gt;f64::NEG_INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">음의 무한대 (&amp;minus;&amp;infin;). 대신 &lt;a href=&quot;../primitive.f64#associatedconstant.NEG_INFINITY&quot;&gt; &lt;code&gt;f64::NEG_INFINITY&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f0bc318765f26abdc2b2efb29b7106a82fb8fb4b" translate="yes" xml:space="preserve">
          <source>Negative infinity (-&amp;infin;).</source>
          <target state="translated">음의 무한대 (-&amp;infin;).</target>
        </trans-unit>
        <trans-unit id="0b247e3c8355086599e15be9efdc87a68cb4c92b" translate="yes" xml:space="preserve">
          <source>Negative numbers</source>
          <target state="translated">음수</target>
        </trans-unit>
        <trans-unit id="72021c01935802b94d4bcd9c9615be5e2c464ac9" translate="yes" xml:space="preserve">
          <source>Negative quiet NaN</source>
          <target state="translated">네거티브 조용한 NaN</target>
        </trans-unit>
        <trans-unit id="3bb8a4159eba393bec0f206dd4b2eb1942475e21" translate="yes" xml:space="preserve">
          <source>Negative signaling NaN</source>
          <target state="translated">음성 신호 NaN</target>
        </trans-unit>
        <trans-unit id="16ee7bf9e7ed5622172a82905b10c817e30e7444" translate="yes" xml:space="preserve">
          <source>Negative subnormal numbers</source>
          <target state="translated">음의 비정규 숫자</target>
        </trans-unit>
        <trans-unit id="dbee361595328b1b81f0564c184162939e173b0f" translate="yes" xml:space="preserve">
          <source>Negative zero</source>
          <target state="translated">음의 제로</target>
        </trans-unit>
        <trans-unit id="ecf5959ac45ac960a39abb26044226e763422de4" translate="yes" xml:space="preserve">
          <source>Neither value is dropped.</source>
          <target state="translated">두 값 모두 삭제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4826200965c37ead358d19d4ff8ed0153fd42955" translate="yes" xml:space="preserve">
          <source>Neither will this, which is a syntax error:</source>
          <target state="translated">이것도 구문 오류입니다.</target>
        </trans-unit>
        <trans-unit id="665ede9ba12690daf481e44869ce86ddcafb335a" translate="yes" xml:space="preserve">
          <source>Nesting groups of the previous features multiple times, such as &lt;code&gt;use a::b::{self as ab, c, d::{*, e::f}};&lt;/code&gt;</source>
          <target state="translated">이전 기능의 중첩 그룹 (예 &lt;code&gt;use a::b::{self as ab, c, d::{*, e::f}};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c4245fc09474f28a0f0142b9ff14b33a73b77c8f" translate="yes" xml:space="preserve">
          <source>Networking primitives for TCP/UDP communication.</source>
          <target state="translated">TCP / UDP 통신을위한 네트워킹 기본 요소.</target>
        </trans-unit>
        <trans-unit id="0512d9d610f7bd86dbd1ca707603a7ad85ac4816" translate="yes" xml:space="preserve">
          <source>Never type</source>
          <target state="translated">입력하지 마십시오</target>
        </trans-unit>
        <trans-unit id="34989675de773cc2985533af4611fcdec5ac0eea" translate="yes" xml:space="preserve">
          <source>New instances of a &lt;code&gt;struct&lt;/code&gt; can be constructed with a &lt;a href=&quot;../expressions/struct-expr&quot;&gt;struct expression&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 의 새로운 인스턴스 는 &lt;a href=&quot;../expressions/struct-expr&quot;&gt;구조체 식&lt;/a&gt; 으로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="474d969a41224d27a052b2157645ae6ea6fdc69d" translate="yes" xml:space="preserve">
          <source>New instances of an &lt;code&gt;enum&lt;/code&gt; can be constructed in an &lt;a href=&quot;../expressions/enum-variant-expr&quot;&gt;enumeration variant expression&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 의 새 인스턴스 는 &lt;a href=&quot;../expressions/enum-variant-expr&quot;&gt;열거 변형 표현식&lt;/a&gt; 으로 구성 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83c2612a110d45187eac1c39a648ac614b8c7d56" translate="yes" xml:space="preserve">
          <source>New versions of Unicode are released regularly and subsequently all methods in the standard library depending on Unicode are updated. Therefore the behavior of some &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; methods and the value of this constant changes over time. This is &lt;em&gt;not&lt;/em&gt; considered to be a breaking change.</source>
          <target state="translated">새 버전의 유니 코드가 정기적으로 릴리스되고 이후 유니 코드에 따라 표준 라이브러리의 모든 메서드가 업데이트됩니다. 따라서 일부 &lt;code&gt;char&lt;/code&gt; 및 &lt;code&gt;str&lt;/code&gt; 메서드 의 동작 과이 상수의 값은 시간이 지남에 따라 변경됩니다. 이는 주요 변경 사항으로 간주 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d706a7f27906e3a8bf4f4fed0f9c3d7edc4a240a" translate="yes" xml:space="preserve">
          <source>Newline</source>
          <target state="translated">Newline</target>
        </trans-unit>
        <trans-unit id="d783d54db2abcb54d1f3f2d8b19273a6830adb8c" translate="yes" xml:space="preserve">
          <source>Newsqueak, Alef, Limbo: channels, concurrency</source>
          <target state="translated">Newsqueak, Alef, Limbo : 채널, 동시성</target>
        </trans-unit>
        <trans-unit id="9000cfe362fe35a00622dc16de8a42fe71435817" translate="yes" xml:space="preserve">
          <source>Newtypes can also hide internal implementation. For example, we could provide a &lt;code&gt;People&lt;/code&gt; type to wrap a &lt;code&gt;HashMap&amp;lt;i32, String&amp;gt;&lt;/code&gt; that stores a person&amp;rsquo;s ID associated with their name. Code using &lt;code&gt;People&lt;/code&gt; would only interact with the public API we provide, such as a method to add a name string to the &lt;code&gt;People&lt;/code&gt; collection; that code wouldn&amp;rsquo;t need to know that we assign an &lt;code&gt;i32&lt;/code&gt; ID to names internally. The newtype pattern is a lightweight way to achieve encapsulation to hide implementation details, which we discussed in the &lt;a href=&quot;ch17-01-what-is-oo#encapsulation-that-hides-implementation-details&quot;&gt;&amp;ldquo;Encapsulation that Hides Implementation Details&amp;rdquo;&lt;/a&gt; section of Chapter 17.</source>
          <target state="translated">새로운 유형은 내부 구현을 숨길 수도 있습니다. 예를 들어, 이름과 관련된 사람의 ID를 저장하는 &lt;code&gt;HashMap&amp;lt;i32, String&amp;gt;&lt;/code&gt; 을 감싸기 위해 &lt;code&gt;People&lt;/code&gt; 유형을 제공 할 수 있습니다 . &lt;code&gt;People&lt;/code&gt; 을 사용하는 코드 는 &lt;code&gt;People&lt;/code&gt; 컬렉션에 이름 문자열을 추가하는 방법과 같이 우리가 제공하는 공개 API 와만 상호 작용합니다 . 이 코드는 내부적으로 이름에 &lt;code&gt;i32&lt;/code&gt; ID를 할당한다는 것을 알 필요가 없습니다 . 새 유형 패턴은 구현 세부 사항을 숨기기 위해 캡슐화를 달성하는 간단한 방법으로, 17 장의 &lt;a href=&quot;ch17-01-what-is-oo#encapsulation-that-hides-implementation-details&quot;&gt;&quot;구현 세부 사항을 숨기는 캡슐화&quot;&lt;/a&gt; 섹션 에서 논의했습니다 .</target>
        </trans-unit>
        <trans-unit id="7bae91cced3da7b704f84e06989b7947e80e541e" translate="yes" xml:space="preserve">
          <source>Next are the &lt;code&gt;match&lt;/code&gt; arms. An arm has two parts: a pattern and some code. The first arm here has a pattern that is the value &lt;code&gt;Coin::Penny&lt;/code&gt; and then the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator that separates the pattern and the code to run. The code in this case is just the value &lt;code&gt;1&lt;/code&gt;. Each arm is separated from the next with a comma.</source>
          <target state="translated">다음은 &lt;code&gt;match&lt;/code&gt; 팔입니다. 팔에는 패턴과 코드의 두 부분이 있습니다. 제 1 아암 여기 값인 패턴 갖는 &lt;code&gt;Coin::Penny&lt;/code&gt; 다음 &lt;code&gt;=&amp;gt;&lt;/code&gt; 패턴을 실행하는 코드를 분리 연산자. 이 경우 코드는 값 &lt;code&gt;1&lt;/code&gt; 입니다. 각 팔은 쉼표로 다음 팔과 분리됩니다.</target>
        </trans-unit>
        <trans-unit id="bf7420cff34f7205e5c081be758df804f4a3397f" translate="yes" xml:space="preserve">
          <source>Next is the &lt;code&gt;main&lt;/code&gt; function, which contains the parts of the workout app important for this example. This function represents the code that the app will call when a user asks for a workout plan. Because the interaction with the app&amp;rsquo;s frontend isn&amp;rsquo;t relevant to the use of closures, we&amp;rsquo;ll hardcode values representing inputs to our program and print the outputs.</source>
          <target state="translated">다음은 이 예제에서 중요한 운동 앱의 일부를 포함 하는 &lt;code&gt;main&lt;/code&gt; 기능입니다. 이 함수는 사용자가 운동 계획을 요청할 때 앱이 호출하는 코드를 나타냅니다. 앱의 프런트 엔드와의 상호 작용은 클로저 사용과 관련이 없으므로 프로그램의 입력을 나타내는 값을 하드 코딩하고 출력을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="c65bbe969462e1bc44ee3000579ab22fe481fd4c" translate="yes" xml:space="preserve">
          <source>Next, for the penultimate chapter of the book, we&amp;rsquo;ll look at some advanced aspects of a variety of Rust&amp;rsquo;s features.</source>
          <target state="translated">다음으로이 책의 두 번째 장을 위해 다양한 Rust 기능의 고급 측면을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="52208e82490358e0e353201224729d0b32e9211f" translate="yes" xml:space="preserve">
          <source>Next, in the &lt;em&gt;add&lt;/em&gt; directory, we create the &lt;em&gt;Cargo.toml&lt;/em&gt; file that will configure the entire workspace. This file won&amp;rsquo;t have a &lt;code&gt;[package]&lt;/code&gt; section or the metadata we&amp;rsquo;ve seen in other &lt;em&gt;Cargo.toml&lt;/em&gt; files. Instead, it will start with a &lt;code&gt;[workspace]&lt;/code&gt; section that will allow us to add members to the workspace by specifying the path to our binary crate; in this case, that path is &lt;em&gt;adder&lt;/em&gt;:</source>
          <target state="translated">다음으로, &lt;em&gt;add&lt;/em&gt; 디렉토리 에서 전체 작업 공간을 구성 할 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일을 만듭니다 . 이 파일에는 &lt;code&gt;[package]&lt;/code&gt; 섹션이나 다른 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일 에서 본 메타 데이터가 &lt;em&gt;없습니다&lt;/em&gt; . 대신 이진 상자의 경로를 지정하여 작업 영역에 멤버를 추가 할 수 있는 &lt;code&gt;[workspace]&lt;/code&gt; 섹션으로 시작합니다 . 이 경우 해당 경로는 &lt;em&gt;adder입니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cf3583fbb6ba42fdef61381eb0f22f26cc65cb4c" translate="yes" xml:space="preserve">
          <source>Next, in the &lt;em&gt;add&lt;/em&gt; directory, we create the &lt;em&gt;Cargo.toml&lt;/em&gt; file that will configure the entire workspace. This file won&amp;rsquo;t have a &lt;code&gt;[package]&lt;/code&gt; section or the metadata we&amp;rsquo;ve seen in other &lt;em&gt;Cargo.toml&lt;/em&gt; files. Instead, it will start with a &lt;code&gt;[workspace]&lt;/code&gt; section that will allow us to add members to the workspace by specifying the path to the package with our binary crate; in this case, that path is &lt;em&gt;adder&lt;/em&gt;:</source>
          <target state="translated">다음으로 &lt;em&gt;add&lt;/em&gt; 디렉터리 에서 전체 작업 공간을 구성 할 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일을 만듭니다 . 이 파일 에는 다른 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일 에서 본 &lt;code&gt;[package]&lt;/code&gt; 섹션이나 메타 데이터가 &lt;em&gt;없습니다&lt;/em&gt; . 대신 바이너리 크레이트로 패키지 경로를 지정하여 작업 공간에 구성원을 추가 할 수 있는 &lt;code&gt;[workspace]&lt;/code&gt; 섹션으로 시작합니다 . 이 경우 해당 경로는 &lt;em&gt;adder입니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4d5673d4c0782df5e2ab93b6ac7b7285949caf0a" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s create another member crate in the workspace and call it &lt;code&gt;add-one&lt;/code&gt;. Change the top-level &lt;em&gt;Cargo.toml&lt;/em&gt; to specify the &lt;em&gt;add-one&lt;/em&gt; path in the &lt;code&gt;members&lt;/code&gt; list:</source>
          <target state="translated">다음으로, 작업 공간에 다른 멤버 상자를 만들어 &lt;code&gt;add-one&lt;/code&gt; 이라고합시다 . &lt;code&gt;members&lt;/code&gt; 목록 에서 &lt;em&gt;추가&lt;/em&gt; 경로 를 지정하려면 최상위 &lt;em&gt;Cargo.toml&lt;/em&gt; 을 변경하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b3259a6676f65921f501e882bdad69e2021df7f" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s create another member package in the workspace and call it &lt;code&gt;add-one&lt;/code&gt;. Change the top-level &lt;em&gt;Cargo.toml&lt;/em&gt; to specify the &lt;em&gt;add-one&lt;/em&gt; path in the &lt;code&gt;members&lt;/code&gt; list:</source>
          <target state="translated">다음으로 작업 공간에 다른 구성원 패키지를 만들고 &lt;code&gt;add-one&lt;/code&gt; 이라고합니다 . &lt;code&gt;members&lt;/code&gt; 목록 에서 &lt;em&gt;추가&lt;/em&gt; 경로 를 지정하려면 최상위 &lt;em&gt;Cargo.toml&lt;/em&gt; 을 변경하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ba0c012105d9f7e5a4cb08c9812f147ef92fc3f" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s explore how the other kinds of procedural macros differ from custom derive macros.</source>
          <target state="translated">다음으로 다른 종류의 절차 매크로가 사용자 정의 파생 매크로와 어떻게 다른지 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7388ce6c4f87a59e05725876ec1ba13ab5a6c132" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s look at macros!</source>
          <target state="translated">다음으로 매크로를 보자!</target>
        </trans-unit>
        <trans-unit id="a41ab1aeb6ce0234b517ca6ca3124ad3db811d40" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s try an example that shows that the lifetime of the reference in &lt;code&gt;result&lt;/code&gt; must be the smaller lifetime of the two arguments. We&amp;rsquo;ll move the declaration of the &lt;code&gt;result&lt;/code&gt; variable outside the inner scope but leave the assignment of the value to the &lt;code&gt;result&lt;/code&gt; variable inside the scope with &lt;code&gt;string2&lt;/code&gt;. Then we&amp;rsquo;ll move the &lt;code&gt;println!&lt;/code&gt; that uses &lt;code&gt;result&lt;/code&gt; outside the inner scope, after the inner scope has ended. The code in Listing 10-24 will not compile.</source>
          <target state="translated">다음으로 &lt;code&gt;result&lt;/code&gt; 의 참조 수명이 두 인수의 수명보다 작아야 한다는 것을 보여주는 예를 살펴 보겠습니다 . &lt;code&gt;result&lt;/code&gt; 변수 의 선언을 내부 범위 외부 로 이동 하지만 &lt;code&gt;string2&lt;/code&gt; 를 사용 하여 범위 내의 &lt;code&gt;result&lt;/code&gt; 변수에 값을 할당합니다 . 그런 다음 &lt;code&gt;println!&lt;/code&gt; 움직입니다 ! 내부 범위가 종료 된 후 내부 범위 외부의 &lt;code&gt;result&lt;/code&gt; 를 사용합니다 . 코드 10-24의 코드는 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4cd72ee75b765bce66036759ad44f05bffbba3a1" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s use the &lt;code&gt;add_one&lt;/code&gt; function from the &lt;code&gt;add-one&lt;/code&gt; crate in the &lt;code&gt;adder&lt;/code&gt; crate. Open the &lt;em&gt;adder/src/main.rs&lt;/em&gt; file and add a &lt;code&gt;use&lt;/code&gt; line at the top to bring the new &lt;code&gt;add-one&lt;/code&gt; library crate into scope. Then change the &lt;code&gt;main&lt;/code&gt; function to call the &lt;code&gt;add_one&lt;/code&gt; function, as in Listing 14-7.</source>
          <target state="translated">다음으로 &lt;code&gt;adder&lt;/code&gt; crate 의 &lt;code&gt;add-one&lt;/code&gt; crate에서 &lt;code&gt;add_one&lt;/code&gt; 함수를 사용하겠습니다 . &lt;em&gt;adder / src / main.rs&lt;/em&gt; 파일을 열고 맨 위에 &lt;code&gt;use&lt;/code&gt; 줄을 &lt;code&gt;add-one&lt;/code&gt; 하여 새 애드온 라이브러리 상자를 범위에 넣습니다. 그런 다음 Listing 14-7에서와 &lt;code&gt;add_one&lt;/code&gt; &lt;code&gt;main&lt;/code&gt; 함수를 변경하여 add_one 함수를 호출하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e1fe2a2a98ce9e857e8667aa0e6390f716cb1d28" translate="yes" xml:space="preserve">
          <source>Next, make a new source file and call it &lt;em&gt;main.rs&lt;/em&gt;. Rust files always end with the &lt;em&gt;.rs&lt;/em&gt; extension. If you&amp;rsquo;re using more than one word in your filename, use an underscore to separate them. For example, use &lt;em&gt;hello_world.rs&lt;/em&gt; rather than &lt;em&gt;helloworld.rs&lt;/em&gt;.</source>
          <target state="translated">다음으로, 새 소스 파일을 만들어 &lt;em&gt;main.rs&lt;/em&gt; 라고합니다 . 녹 파일은 항상 &lt;em&gt;.rs&lt;/em&gt; 확장자로 끝납니다 . 파일 이름에 둘 이상의 단어를 사용하는 경우 밑줄을 사용하여 구분하십시오. 예를 들어 &lt;em&gt;helloworld.rs&lt;/em&gt; 대신 &lt;em&gt;hello_world.rs를&lt;/em&gt; 사용하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="03d3c37a590f1ae7381c9279be8f7a97b6800076" translate="yes" xml:space="preserve">
          <source>Next, we add a call to &lt;code&gt;to_lowercase&lt;/code&gt; on each &lt;code&gt;line&lt;/code&gt; before we check whether it contains &lt;code&gt;query&lt;/code&gt; to lowercase all characters. Now that we&amp;rsquo;ve converted &lt;code&gt;line&lt;/code&gt; and &lt;code&gt;query&lt;/code&gt; to lowercase, we&amp;rsquo;ll find matches no matter what the case of the query is.</source>
          <target state="translated">다음으로, 모든 문자를 소문자로하는 &lt;code&gt;query&lt;/code&gt; 가 포함되어 있는지 확인하기 전에 각 &lt;code&gt;line&lt;/code&gt; 마다 &lt;code&gt;to_lowercase&lt;/code&gt; 에 대한 호출을 추가합니다 . 이제 &lt;code&gt;line&lt;/code&gt; 과 &lt;code&gt;query&lt;/code&gt; 를 소문자 로 변환 했으므로 쿼리 의 경우에 관계없이 일치하는 항목을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e52d9272848f0823ca640fddf0b693b0608206b" translate="yes" xml:space="preserve">
          <source>Next, we create an iterator over the array of bytes using the &lt;code&gt;iter&lt;/code&gt; method:</source>
          <target state="translated">다음으로 &lt;code&gt;iter&lt;/code&gt; 메소드를 사용하여 바이트 배열에 대해 반복자를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="fbb5669be934c8d9daa09d2fb6f075709e7fa5e2" translate="yes" xml:space="preserve">
          <source>Next, we implement a method named &lt;code&gt;value&lt;/code&gt; that borrows &lt;code&gt;self&lt;/code&gt;, doesn&amp;rsquo;t have any other parameters, and returns an &lt;code&gt;i32&lt;/code&gt;. This kind of method is sometimes called a &lt;em&gt;getter&lt;/em&gt;, because its purpose is to get some data from its fields and return it. This public method is necessary because the &lt;code&gt;value&lt;/code&gt; field of the &lt;code&gt;Guess&lt;/code&gt; struct is private. It&amp;rsquo;s important that the &lt;code&gt;value&lt;/code&gt; field be private so code using the &lt;code&gt;Guess&lt;/code&gt; struct is not allowed to set &lt;code&gt;value&lt;/code&gt; directly: code outside the module &lt;em&gt;must&lt;/em&gt; use the &lt;code&gt;Guess::new&lt;/code&gt; function to create an instance of &lt;code&gt;Guess&lt;/code&gt;, thereby ensuring there&amp;rsquo;s no way for a &lt;code&gt;Guess&lt;/code&gt; to have a &lt;code&gt;value&lt;/code&gt; that hasn&amp;rsquo;t been checked by the conditions in the &lt;code&gt;Guess::new&lt;/code&gt; function.</source>
          <target state="translated">다음으로 &lt;code&gt;self&lt;/code&gt; 를 빌리고 다른 매개 변수가 없으며 &lt;code&gt;i32&lt;/code&gt; 를 반환하는 &lt;code&gt;value&lt;/code&gt; 라는 메서드를 구현합니다 . 이러한 종류의 메소드는 &lt;em&gt;getter&lt;/em&gt; 라고도 합니다. 목적은 필드에서 일부 데이터를 가져 와서 리턴하기 때문입니다. 이 공개 방법은 &lt;code&gt;Guess&lt;/code&gt; 구조체 의 &lt;code&gt;value&lt;/code&gt; 필드 가 private 이므로 필요합니다 . 그것은 것이 중요 &lt;code&gt;value&lt;/code&gt; 필드는 사용하여 개인 그래서 코드가 될 &lt;code&gt;Guess&lt;/code&gt; 세트에 허용되지 않는 구조체 &lt;code&gt;value&lt;/code&gt; 을 직접 : 모듈 외부의 코드가 &lt;em&gt;있어야&lt;/em&gt; 사용 &lt;code&gt;Guess::new&lt;/code&gt; 의 인스턴스를 생성하는 기능을 &lt;code&gt;Guess&lt;/code&gt; &lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;따라서 &lt;code&gt;Guess::new&lt;/code&gt; 함수 의 조건에 의해 확인되지 않은 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;Guess&lt;/code&gt; 할 수있는 방법 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="605d6de7987c12e157a0df6ee5c1a07b22d453f2" translate="yes" xml:space="preserve">
          <source>Next, we implement the &lt;code&gt;FnBox&lt;/code&gt; trait for any type &lt;code&gt;F&lt;/code&gt; that implements the &lt;code&gt;FnOnce()&lt;/code&gt; trait. Effectively, this means that any &lt;code&gt;FnOnce()&lt;/code&gt; closures can use our &lt;code&gt;call_box&lt;/code&gt; method. The implementation of &lt;code&gt;call_box&lt;/code&gt; uses &lt;code&gt;(*self)()&lt;/code&gt; to move the closure out of the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and call the closure.</source>
          <target state="translated">다음으로 &lt;code&gt;FnOnce()&lt;/code&gt; 특성 을 구현하는 모든 유형 &lt;code&gt;F&lt;/code&gt; 에 대해 &lt;code&gt;FnBox&lt;/code&gt; 특성을 구현합니다 . 실제로 이것은 모든 &lt;code&gt;FnOnce()&lt;/code&gt; 클로저가 &lt;code&gt;call_box&lt;/code&gt; 메소드를 사용할 수 있음을 의미합니다 . &lt;code&gt;call_box&lt;/code&gt; 의 구현 은 &lt;code&gt;(*self)()&lt;/code&gt; 를 사용하여 클로저를 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 밖으로 이동시키고 클로저를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="813cf7c3c4cb11a394f89f5d5322e12f202af557" translate="yes" xml:space="preserve">
          <source>Next, we need to actually read from the stream. We do this in two steps: first, we declare a &lt;code&gt;buffer&lt;/code&gt; on the stack to hold the data that is read in. We&amp;rsquo;ve made the buffer 1024 bytes in size, which is big enough to hold the data of a basic request and sufficient for our purposes in this chapter. If we wanted to handle requests of an arbitrary size, buffer management would need to be more complicated; we&amp;rsquo;ll keep it simple for now. We pass the buffer to &lt;code&gt;stream.read&lt;/code&gt;, which will read bytes from the &lt;code&gt;TcpStream&lt;/code&gt; and put them in the buffer.</source>
          <target state="translated">다음으로 실제로 스트림에서 읽어야합니다. 이 작업은 두 단계로 수행합니다. 먼저 읽은 데이터를 보관할 &lt;code&gt;buffer&lt;/code&gt; 를 스택에 선언합니다 . 기본 요청의 데이터를 보관할 수있을만큼 충분히 크고 충분한 크기의 버퍼를 1024 바이트로 만들었습니다. 이 장에서 우리의 목적을 위해. 임의의 크기의 요청을 처리하려면 버퍼 관리가 더 복잡해야합니다. 지금은 간단하게 유지하겠습니다. 우리는에 버퍼 통과 &lt;code&gt;stream.read&lt;/code&gt; 로부터 바이트를 읽어, &lt;code&gt;TcpStream&lt;/code&gt; 을 버퍼에 넣어합니다.</target>
        </trans-unit>
        <trans-unit id="7cc7c952c5d6180788b66b960a497f1bbb0d5cfe" translate="yes" xml:space="preserve">
          <source>Next, we need to actually read from the stream. We do this in two steps: first, we declare a &lt;code&gt;buffer&lt;/code&gt; on the stack to hold the data that is read in. We&amp;rsquo;ve made the buffer 512 bytes in size, which is big enough to hold the data of a basic request and sufficient for our purposes in this chapter. If we wanted to handle requests of an arbitrary size, buffer management would need to be more complicated; we&amp;rsquo;ll keep it simple for now. We pass the buffer to &lt;code&gt;stream.read&lt;/code&gt;, which will read bytes from the &lt;code&gt;TcpStream&lt;/code&gt; and put them in the buffer.</source>
          <target state="translated">다음으로 스트림에서 실제로 읽어야합니다. 먼저 두 단계로이 작업을 수행합니다. 먼저 읽은 데이터를 보유하기 위해 스택에 &lt;code&gt;buffer&lt;/code&gt; 를 선언합니다 . 버퍼를 512 바이트 크기로 만들었습니다. 기본 요청의 데이터를 보유 할 수있을만큼 충분히 크고 이 장에서 우리의 목적을 위해. 임의 크기의 요청을 처리하려면 버퍼 관리가 더 복잡해야합니다. 우리는 지금 간단하게 유지할 것입니다. 버퍼를 &lt;code&gt;stream.read&lt;/code&gt; 에 전달하면 TcpStream 에서 바이트를 읽 &lt;code&gt;TcpStream&lt;/code&gt; 버퍼에 넣어합니다.</target>
        </trans-unit>
        <trans-unit id="76351bb871037a13a112e6c874825b1ebb4611c8" translate="yes" xml:space="preserve">
          <source>Next, we need to add functionality to request a review of a post, which should change its state from &lt;code&gt;Draft&lt;/code&gt; to &lt;code&gt;PendingReview&lt;/code&gt;. Listing 17-15 shows this code:</source>
          <target state="translated">다음으로 게시물 검토를 요청하는 기능을 추가해야합니다.이 상태는 &lt;code&gt;Draft&lt;/code&gt; 에서 &lt;code&gt;PendingReview&lt;/code&gt; 중인 검토로 변경되어야합니다. . 코드 17-15는이 코드를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="92e1faec54108ffc0dae30cd9cc0b93fd8d1895e" translate="yes" xml:space="preserve">
          <source>Next, we need to generate a secret number that the user will try to guess. The secret number should be different every time so the game is fun to play more than once. Let&amp;rsquo;s use a random number between 1 and 100 so the game isn&amp;rsquo;t too difficult. Rust doesn&amp;rsquo;t yet include random number functionality in its standard library. However, the Rust team does provide a &lt;a href=&quot;https://crates.io/crates/rand&quot;&gt;&lt;code&gt;rand&lt;/code&gt; crate&lt;/a&gt;.</source>
          <target state="translated">다음으로, 사용자가 추측하려고하는 비밀 번호를 생성해야합니다. 비밀 번호는 매번 달라야 게임이 두 번 이상 재미있어집니다. 게임이 그렇게 어렵지 않도록 1에서 100 사이의 난수를 사용합시다. Rust는 아직 표준 라이브러리에 난수 기능을 포함하지 않습니다. 그러나 Rust 팀은 &lt;a href=&quot;https://crates.io/crates/rand&quot;&gt; &lt;code&gt;rand&lt;/code&gt; &lt;/a&gt; 상자를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="b3048ae1981e29d8fc7bb24867dd28498448fb02" translate="yes" xml:space="preserve">
          <source>Next, we need to update the definition of &lt;code&gt;Config::new&lt;/code&gt;. In your I/O project&amp;rsquo;s &lt;em&gt;src/lib.rs&lt;/em&gt; file, let&amp;rsquo;s change the signature of &lt;code&gt;Config::new&lt;/code&gt; to look like Listing 13-26. This still won&amp;rsquo;t compile because we need to update the function body.</source>
          <target state="translated">다음으로 &lt;code&gt;Config::new&lt;/code&gt; 정의를 업데이트해야합니다 . I / O 프로젝트의 &lt;em&gt;src / lib.rs&lt;/em&gt; 파일에서 &lt;code&gt;Config::new&lt;/code&gt; 의 서명을 변경하십시오 Listing 13-26과 같이 . 함수 본문을 업데이트해야하기 때문에 여전히 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7002fc97279e473d70d4660362de14f1e116f1c" translate="yes" xml:space="preserve">
          <source>Next, we use &lt;code&gt;format!&lt;/code&gt; to add the file&amp;rsquo;s contents as the body of the success response.</source>
          <target state="translated">다음 &lt;code&gt;format!&lt;/code&gt; 을 사용 합니다!성공 응답 본문으로 파일 내용을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="5f1848680d22a75c771965dd71d24a16003163fc" translate="yes" xml:space="preserve">
          <source>Next, we use &lt;code&gt;format!&lt;/code&gt; to add the file&amp;rsquo;s contents as the body of the success response. To ensure a valid HTTP response, we add the &lt;code&gt;Content-Length&lt;/code&gt; header which is set to the size of our response body, in this case the size of &lt;code&gt;hello.html&lt;/code&gt;.</source>
          <target state="translated">다음 &lt;code&gt;format!&lt;/code&gt; 을 사용 합니다! 성공 응답의 본문으로 파일의 내용을 추가합니다. 유효한 HTTP 응답을 보장하기 위해 응답 본문의 크기 (이 경우 &lt;code&gt;hello.html&lt;/code&gt; 크기)로 설정된 &lt;code&gt;Content-Length&lt;/code&gt; 헤더를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="e1cb8822a67321b8c02da9e7e8c260dc9c0b608d" translate="yes" xml:space="preserve">
          <source>Next, we want to enable a request for a review of the post, and we want &lt;code&gt;content&lt;/code&gt; to return an empty string while waiting for the review. When the post receives approval, it should get published, meaning the text of the post will be returned when &lt;code&gt;content&lt;/code&gt; is called.</source>
          <target state="translated">다음으로 게시물 검토 요청을 활성화하고 검토 를 기다리는 동안 빈 문자열을 반환하는 &lt;code&gt;content&lt;/code&gt; 가 필요합니다. 게시물이 승인을 받으면 게시되어야합니다. 즉, &lt;code&gt;content&lt;/code&gt; 가 게시 될 때 게시물의 텍스트가 반환됩니다. 가 호출 .</target>
        </trans-unit>
        <trans-unit id="dc0c1d1b57e4826864a1d45c2ceee72d00bff7d9" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll check whether the current line contains our query string. Fortunately, strings have a helpful method named &lt;code&gt;contains&lt;/code&gt; that does this for us! Add a call to the &lt;code&gt;contains&lt;/code&gt; method in the &lt;code&gt;search&lt;/code&gt; function, as shown in Listing 12-18. Note this still won&amp;rsquo;t compile yet.</source>
          <target state="translated">다음으로 현재 줄에 쿼리 문자열이 포함되어 있는지 확인합니다. 다행스럽게도 문자열에는 &lt;code&gt;contains&lt;/code&gt; 라는 이름의 유용한 메소드가 있습니다 . &lt;code&gt;search&lt;/code&gt; 에서 &lt;code&gt;contains&lt;/code&gt; 메소드에 대한 호출 추가목록 12-18에 표시된대로 함수 . 아직 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ac1479b99a85012a6bea69ba1759d1f7cc3ad30" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll create a place to store the user input, like this:</source>
          <target state="translated">다음으로 다음과 같이 사용자 입력을 저장할 장소를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e5a328539b3bbff608c05675d0f98ba529495a33" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll create a raw pointer whose validity we can&amp;rsquo;t be so certain of. Listing 19-2 shows how to create a raw pointer to an arbitrary location in memory. Trying to use arbitrary memory is undefined: there might be data at that address or there might not, the compiler might optimize the code so there is no memory access, or the program might error with a segmentation fault. Usually, there is no good reason to write code like this, but it is possible.</source>
          <target state="translated">다음으로 우리는 유효성을 확신 할 수없는 원시 포인터를 만듭니다. 목록 19-2는 메모리의 임의 위치에 대한 원시 포인터를 만드는 방법을 보여줍니다. 임의의 메모리를 사용하려는 시도는 정의되지 않았습니다. 해당 주소에 데이터가 있거나 없을 수 있습니다. 컴파일러가 코드를 최적화하여 메모리 액세스가 없거나 프로그램이 오류로 인해 오류가 발생할 수 있습니다. 일반적으로 이와 같은 코드를 작성해야 할 이유는 없지만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="629644a5201c55cb9634591304da90b26a4571c8" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll create the &lt;code&gt;adder&lt;/code&gt; binary crate by running &lt;code&gt;cargo new&lt;/code&gt; within the &lt;em&gt;add&lt;/em&gt; directory:</source>
          <target state="translated">다음으로 &lt;em&gt;add&lt;/em&gt; 디렉토리 내에서 &lt;code&gt;cargo new&lt;/code&gt; 를 실행 하여 &lt;code&gt;adder&lt;/code&gt; 바이너리 상자를 만듭니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4c8171dc56214044bf871f6ef39d7d39bc7a5954" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll define the &lt;code&gt;HelloMacro&lt;/code&gt; trait and its associated function:</source>
          <target state="translated">다음으로 &lt;code&gt;HelloMacro&lt;/code&gt; 특성과 관련 기능을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a47fb6ac34c3efb030b781d2a69ff8c26654e8b7" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll explore some Rust features that were influenced by functional languages: closures and iterators.</source>
          <target state="translated">다음으로 함수형 언어에 영향을받은 Rust 기능인 클로저 및 반복자를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="de89b671f67de5d1f170a1b7712e3f2c4f2d52b0" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll explore some advanced features related to functions and closures, which include function pointers and returning closures.</source>
          <target state="translated">다음으로, 함수 포인터 및 반환 클로저를 포함하는 함수 및 클로저와 관련된 몇 가지 고급 기능을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="df380b1f8d3c4226cb4356e67a4308029f7b04af" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll fix the body of &lt;code&gt;Config::new&lt;/code&gt;. The standard library documentation also mentions that &lt;code&gt;std::env::Args&lt;/code&gt; implements the &lt;code&gt;Iterator&lt;/code&gt; trait, so we know we can call the &lt;code&gt;next&lt;/code&gt; method on it! Listing 13-27 updates the code from Listing 12-23 to use the &lt;code&gt;next&lt;/code&gt; method:</source>
          <target state="translated">다음으로 &lt;code&gt;Config::new&lt;/code&gt; 본문을 수정합니다 . 표준 라이브러리 문서에는 &lt;code&gt;std::env::Args&lt;/code&gt; 가 &lt;code&gt;Iterator&lt;/code&gt; 특성을 구현 하므로 &lt;code&gt;next&lt;/code&gt; 메소드를 호출 할 수 있음을 알고 있습니다 ! Listing 13-27은 &lt;code&gt;next&lt;/code&gt; 방법 을 사용하도록 Listing 12-23의 코드를 업데이트한다 .</target>
        </trans-unit>
        <trans-unit id="3a19f54b1a11fc876360a8c3cf621da7fa07cef6" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll implement the &lt;code&gt;Iterator&lt;/code&gt; trait for our &lt;code&gt;Counter&lt;/code&gt; type by defining the body of the &lt;code&gt;next&lt;/code&gt; method to specify what we want to happen when this iterator is used, as shown in Listing 13-21:</source>
          <target state="translated">다음 으로 Listing 13-21에 표시된 것처럼이 반복자를 사용할 때 발생하는 작업을 지정하기 위해 &lt;code&gt;next&lt;/code&gt; 메소드 의 본문을 정의하여 &lt;code&gt;Counter&lt;/code&gt; 유형에 대한 &lt;code&gt;Iterator&lt;/code&gt; 특성을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="8192333a1969b9548e0a4b704aec1d71dbd5da8d" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll look at a different kind of reference: slices.</source>
          <target state="translated">다음으로 다른 종류의 참조 : 슬라이스를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="4634a5dae53b28ce905455154ee2c8f9020614d5" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll look at patterns, which are another of Rust&amp;rsquo;s features that enable lots of flexibility. We&amp;rsquo;ve looked at them briefly throughout the book but haven&amp;rsquo;t seen their full capability yet. Let&amp;rsquo;s go!</source>
          <target state="translated">다음으로 많은 유연성을 가능하게하는 Rust의 또 다른 특징 인 패턴을 살펴 보겠습니다. 우리는이 책 전체에서 그것들을 간략히 살펴 보았지만 아직 완전한 기능을 보지 못했습니다. 가자!</target>
        </trans-unit>
        <trans-unit id="c7d28f3c2f2542f898d8da87d4a31466a385d3a6" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll put everything we&amp;rsquo;ve discussed throughout the book into practice and do one more project!</source>
          <target state="translated">다음으로, 우리는 책 전체에 걸쳐 논의한 모든 것을 실용화하고 하나 이상의 프로젝트를 수행 할 것입니다!</target>
        </trans-unit>
        <trans-unit id="b241e1c5f37c0baa3f70582a9ac2883d59e35af5" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll talk about concurrency in Rust. You&amp;rsquo;ll even learn about a few new smart pointers.</source>
          <target state="translated">다음으로 Rust의 동시성에 대해 이야기하겠습니다. 몇 가지 새로운 스마트 포인터에 대해서도 배우게됩니다.</target>
        </trans-unit>
        <trans-unit id="03a59d930c382bd744dde7a012f05351047ee5cc" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll talk about functions and closures!</source>
          <target state="translated">다음으로 함수와 클로저에 대해 이야기하겠습니다!</target>
        </trans-unit>
        <trans-unit id="1fde554107211f23cac1a0bbf25be3203f7855d9" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll talk about idiomatic ways to model problems and structure solutions as your Rust programs get bigger. In addition, we&amp;rsquo;ll discuss how Rust&amp;rsquo;s idioms relate to those you might be familiar with from object-oriented programming.</source>
          <target state="translated">다음으로 Rust 프로그램이 커짐에 따라 문제를 모델링하고 솔루션을 구조화하는 관용적 방법에 대해 이야기하겠습니다. 또한 Rust의 관용구가 객체 지향 프로그래밍에서 익숙 할 수있는 관용구와 어떤 관련이 있는지 논의합니다.</target>
        </trans-unit>
        <trans-unit id="12c381a078ea586c1a6dde5139c1770828ccdb51" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll use our struct definition and create one &lt;code&gt;Node&lt;/code&gt; instance named &lt;code&gt;leaf&lt;/code&gt; with the value 3 and no children, and another instance named &lt;code&gt;branch&lt;/code&gt; with the value 5 and &lt;code&gt;leaf&lt;/code&gt; as one of its children, as shown in Listing 15-27:</source>
          <target state="translated">다음으로 구조체 정의를 사용 하고 값이 3이고 자식이없는 &lt;code&gt;leaf&lt;/code&gt; 라는 &lt;code&gt;Node&lt;/code&gt; 인스턴스를 하나 만들고 값이 5이고 &lt;code&gt;leaf&lt;/code&gt; 인 &lt;code&gt;branch&lt;/code&gt; 라는 다른 인스턴스를 만듭니다. Listing 15-27 참조).</target>
        </trans-unit>
        <trans-unit id="49cce52cf3729ef44c726e5a417fc215b857117b" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll use these same steps with generics to reduce code duplication in different ways. In the same way that the function body can operate on an abstract &lt;code&gt;list&lt;/code&gt; instead of specific values, generics allow code to operate on abstract types.</source>
          <target state="translated">다음으로 제네릭과 동일한 단계를 사용하여 다른 방법으로 코드 중복을 줄입니다. 함수 본문 이 특정 값 대신 추상 &lt;code&gt;list&lt;/code&gt; 에서 작동하는 것과 동일한 방식으로 제네릭을 사용하면 코드가 추상 유형에서 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05f6878762b08e453ff7c9c981e816c32f84aa8d" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;re adding two lines in the middle. The &lt;code&gt;rand::thread_rng&lt;/code&gt; function will give us the particular random number generator that we&amp;rsquo;re going to use: one that is local to the current thread of execution and seeded by the operating system. Then we call the &lt;code&gt;gen_range&lt;/code&gt; method on the random number generator. This method is defined by the &lt;code&gt;Rng&lt;/code&gt; trait that we brought into scope with the &lt;code&gt;use rand::Rng&lt;/code&gt; statement. The &lt;code&gt;gen_range&lt;/code&gt; method takes two numbers as arguments and generates a random number between them. It&amp;rsquo;s inclusive on the lower bound but exclusive on the upper bound, so we need to specify &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;101&lt;/code&gt; to request a number between 1 and 100.</source>
          <target state="translated">다음으로 중간에 두 줄을 추가합니다. &lt;code&gt;rand::thread_rng&lt;/code&gt; 현재 실행 스레드 로컬 및 운영 체제에서 시드 하나 : 기능은 우리에게 우리가 사용 거라고 특정 난수 생성기를 제공 할 것입니다. 그런 다음 난수 생성기 에서 &lt;code&gt;gen_range&lt;/code&gt; 메소드를 호출합니다 . 이 방법은 우리가 &lt;code&gt;use rand::Rng&lt;/code&gt; 문을 사용 하여 &lt;code&gt;Rng&lt;/code&gt; 특성에 의해 정의됩니다 . &lt;code&gt;gen_range&lt;/code&gt; 의 방법은 인수로 두 개의 숫자를 받아 그들 사이의 난수를 생성합니다. 하한에는 포함되지만 상한에는 배타적이므로 1과 100 사이의 숫자를 요청하려면 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;101&lt;/code&gt; 을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="188a1831aead9f2050d9903c88b40256b8d0ba24" translate="yes" xml:space="preserve">
          <source>Nice! Even though spaces were added before the guess, the program still figured out that the user guessed 76. Run the program a few times to verify the different behavior with different kinds of input: guess the number correctly, guess a number that is too high, and guess a number that is too low.</source>
          <target state="translated">좋은! 추측하기 전에 공백이 추가되었지만 프로그램은 여전히 ​​사용자가 76을 추측했다고 생각했습니다. 프로그램을 몇 번 실행하여 다른 종류의 입력으로 다른 동작을 확인하십시오. 숫자를 올바르게 추측하고, 너무 높은 숫자를 추측하십시오. 너무 낮은 숫자를 추측하십시오.</target>
        </trans-unit>
        <trans-unit id="41d756e582a9b7133fefe3aba97d94609533d175" translate="yes" xml:space="preserve">
          <source>Nice! It&amp;rsquo;s not the prettiest output, but it shows the values of all the fields for this instance, which would definitely help during debugging. When we have larger structs, it&amp;rsquo;s useful to have output that&amp;rsquo;s a bit easier to read; in those cases, we can use &lt;code&gt;{:#?}&lt;/code&gt; instead of &lt;code&gt;{:?}&lt;/code&gt; in the &lt;code&gt;println!&lt;/code&gt; string. When we use the &lt;code&gt;{:#?}&lt;/code&gt; style in the example, the output will look like this:</source>
          <target state="translated">좋은! 가장 아름다운 출력은 아니지만이 인스턴스의 모든 필드 값을 표시하므로 디버깅 중에 도움이됩니다. 우리가 더 큰 구조체를 가질 때, 좀 더 읽기 쉬운 출력을 갖는 것이 유용합니다; 이런 경우에는 &lt;code&gt;{:#?}&lt;/code&gt; &lt;code&gt;println!&lt;/code&gt; 에서 &lt;code&gt;{:?}&lt;/code&gt; 대신 {: #?}을 ! 끈. &lt;code&gt;{:#?}&lt;/code&gt; 를 사용할 때 의 예에서 스타일을, 출력은 다음과 같이 표시됩니다</target>
        </trans-unit>
        <trans-unit id="c9e429b1798d0142b8b31e82c1f9da5d8e0c9420" translate="yes" xml:space="preserve">
          <source>Nightly</source>
          <target state="translated">Nightly</target>
        </trans-unit>
        <trans-unit id="0e61ca1796e0a674ec697f05ff94882071738de7" translate="yes" xml:space="preserve">
          <source>No &lt;a href=&quot;../glossary#uncovered-type&quot;&gt;uncovered type&lt;/a&gt; parameters &lt;code&gt;P1..=Pn&lt;/code&gt; may appear in &lt;code&gt;T0..Ti&lt;/code&gt; (excluding &lt;code&gt;Ti&lt;/code&gt;)</source>
          <target state="translated">어떤 &lt;a href=&quot;../glossary#uncovered-type&quot;&gt;노출 된 입력&lt;/a&gt; 파라미터 &lt;code&gt;P1..=Pn&lt;/code&gt; 표시되지있다 &lt;code&gt;T0..Ti&lt;/code&gt; (제외 &lt;code&gt;Ti&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6dabebe1f19f9827a4f8cf661fd813509cd607c6" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;main&lt;/code&gt; function was found in a binary crate.</source>
          <target state="translated">이진 상자에는 &lt;code&gt;main&lt;/code&gt; 기능이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3334d46bace193a18342fe23d9ec73cf45eeee44" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;main&lt;/code&gt; function was found in a binary crate. To fix this error, add a &lt;code&gt;main&lt;/code&gt; function. For example:</source>
          <target state="translated">이진 상자에 &lt;code&gt;main&lt;/code&gt; 기능이 없습니다 . 이 오류를 해결하려면 &lt;code&gt;main&lt;/code&gt; 추가하십시오 기능을 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40e9183fb0e170dc10c265ea9f5ac313b7e7824e" translate="yes" xml:space="preserve">
          <source>No arguments to the program</source>
          <target state="translated">프로그램에 대한 논증 없음</target>
        </trans-unit>
        <trans-unit id="86e59c19b9b6a6d88fc2db18875d3bedb5eeda2c" translate="yes" xml:space="preserve">
          <source>No code is generated for this intrinsic, but the optimizer will try to preserve it (and its condition) between passes, which may interfere with optimization of surrounding code and reduce performance. It should not be used if the invariant can be discovered by the optimizer on its own, or if it does not enable any significant optimizations.</source>
          <target state="translated">이 내장 코드에 대해서는 코드가 생성되지 않지만, 옵티마이 저는 패스간에 코드 (및 해당 조건)를 보존하려고 시도하므로 주변 코드의 최적화를 방해하고 성능이 저하 될 수 있습니다. 옵티마이 저가 불변량을 자체적으로 발견 할 수 있거나 중요한 최적화를 사용하지 않는 경우에는 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6d24aa51295019d1b05b76a7e56a3b4b701ef15c" translate="yes" xml:space="preserve">
          <source>No data is allocated on the heap.</source>
          <target state="translated">힙에는 데이터가 할당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b940936fa4a1fc768ca623a652084963506c1c89" translate="yes" xml:space="preserve">
          <source>No file is allowed to exist at the target location, also no (dangling) symlink. In this way, if the call succeeds, the file returned is guaranteed to be new.</source>
          <target state="translated">대상 위치에 파일이 존재할 수 없으며 (매달린) 심볼릭 링크도 없습니다. 이런 식으로 호출이 성공하면 반환 된 파일은 새 파일이됩니다.</target>
        </trans-unit>
        <trans-unit id="bd44839870a9b58128d358fce877ecbaa11fd40a" translate="yes" xml:space="preserve">
          <source>No formal timeline for turning the warnings into errors has been set. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/58781&quot;&gt;GitHub issue 58781&lt;/a&gt; for more information.</source>
          <target state="translated">경고를 오류로 전환하기위한 공식 일정은 설정되지 않았습니다. 자세한 내용은 &lt;a href=&quot;https://github.com/rust-lang/rust/issues/58781&quot;&gt;GitHub 문제 58781&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f506aac03a59ef1406f6d0689bfcd0dc4c05822a" translate="yes" xml:space="preserve">
          <source>No guarantees are provided about the contents of &lt;code&gt;buf&lt;/code&gt; when this function is called, implementations cannot rely on any property of the contents of &lt;code&gt;buf&lt;/code&gt; being true. It is recommended that &lt;em&gt;implementations&lt;/em&gt; only write data to &lt;code&gt;buf&lt;/code&gt; instead of reading its contents.</source>
          <target state="translated">이 함수가 호출 될 때 &lt;code&gt;buf&lt;/code&gt; 의 내용에 대해 어떠한 보장도 제공 되지 않으며, 구현은 &lt;code&gt;buf&lt;/code&gt; 의 내용에 대한 어떠한 속성도 사실에 의존 할 수 없습니다 . 다음을 권장합니다&lt;em&gt;구현시 &lt;/em&gt; &lt;code&gt;buf&lt;/code&gt; 에만 데이터를 쓰는 내용을 읽는 대신 .</target>
        </trans-unit>
        <trans-unit id="4f0a95bf47b8945eb4629fd1207fec71669b8c5c" translate="yes" xml:space="preserve">
          <source>No guarantees are provided about the contents of &lt;code&gt;buf&lt;/code&gt; when this function is called, implementations cannot rely on any property of the contents of &lt;code&gt;buf&lt;/code&gt; being true. It is recommended that implementations only write data to &lt;code&gt;buf&lt;/code&gt; instead of reading its contents.</source>
          <target state="translated">이 함수가 호출 될 때 &lt;code&gt;buf&lt;/code&gt; 의 내용에 대해 어떠한 보장도 제공 되지 않으며, 구현은 &lt;code&gt;buf&lt;/code&gt; 의 내용에 대한 어떠한 속성도 사실에 의존 할 수 없습니다 . 구현시 내용을 읽는 대신 &lt;code&gt;buf&lt;/code&gt; 에 데이터를 쓰는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="44c3fb55dfa5ac1ea3e6cc8751e2f98b499318f5" translate="yes" xml:space="preserve">
          <source>No guarantees are provided about the contents of &lt;code&gt;buf&lt;/code&gt; when this function is called, implementations cannot rely on any property of the contents of &lt;code&gt;buf&lt;/code&gt; being true. It is recommended that implementations only write data to &lt;code&gt;buf&lt;/code&gt; instead of reading its contents. The documentation on &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; has a more detailed explanation on this subject.</source>
          <target state="translated">이 함수가 호출 될 때 &lt;code&gt;buf&lt;/code&gt; 의 내용에 대한 보장은 제공 되지 않으며, 구현은 &lt;code&gt;buf&lt;/code&gt; 내용의 속성 이 true 인 것에 의존 할 수 없습니다 . 구현시 내용을 읽는 대신 &lt;code&gt;buf&lt;/code&gt; 에만 데이터를 쓰는 것이 좋습니다 . &lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 에 대한 문서 에는이 주제에 대한 자세한 설명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce0692c18a626152270d81a21a828cf37a6f5e5b" translate="yes" xml:space="preserve">
          <source>No matter whether or not you think Rust is an object-oriented language after reading this chapter, you now know that you can use trait objects to get some object-oriented features in Rust. Dynamic dispatch can give your code some flexibility in exchange for a bit of runtime performance. You can use this flexibility to implement object-oriented patterns that can help your code&amp;rsquo;s maintainability. Rust also has other features, like ownership, that object-oriented languages don&amp;rsquo;t have. An object-oriented pattern won&amp;rsquo;t always be the best way to take advantage of Rust&amp;rsquo;s strengths, but is an available option.</source>
          <target state="translated">이 장을 읽은 후 Rust가 객체 지향 언어라고 생각하든, 이제 특성 객체를 사용하여 Rust에서 객체 지향 기능을 얻을 수 있다는 것을 알고 있습니다. 동적 디스패치는 약간의 런타임 성능과 교환하여 코드에 유연성을 제공 할 수 있습니다. 이 유연성을 사용하여 코드 유지 관리에 도움이되는 객체 지향 패턴을 구현할 수 있습니다. Rust에는 소유권과 같은 객체 지향 언어에는없는 다른 기능도 있습니다. 객체 지향 패턴이 Rust의 강점을 활용하는 가장 좋은 방법은 아니지만 사용 가능한 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="11ac1612603c0c3d5163e13082f76411af9ee697" translate="yes" xml:space="preserve">
          <source>No ordering constraints, only atomic operations.</source>
          <target state="translated">순서 제한이없고 원자 연산 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d3c73825e4a8031f1bb82e1a976c1ab255294e6" translate="yes" xml:space="preserve">
          <source>No truncation occurs when &lt;code&gt;len&lt;/code&gt; is greater than the vector's current length:</source>
          <target state="translated">&lt;code&gt;len&lt;/code&gt; 이 벡터의 현재 길이보다 길면 잘림이 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9d9d7a3fa61acc7fab275007c75a11f20d8c99c2" translate="yes" xml:space="preserve">
          <source>No uncovered type parameters &lt;code&gt;P1..=Pm&lt;/code&gt; may appear in &lt;code&gt;T0..Ti&lt;/code&gt; (excluding &lt;code&gt;Ti&lt;/code&gt;).</source>
          <target state="translated">커버되지 않은 유형 매개 변수 &lt;code&gt;P1..=Pm&lt;/code&gt; 은 &lt;code&gt;T0..Ti&lt;/code&gt; 에 나타날 수 없습니다 ( &lt;code&gt;Ti&lt;/code&gt; 제외 ).</target>
        </trans-unit>
        <trans-unit id="1d402441c3b972c1257d41a23a0cf7d56800bfb6" translate="yes" xml:space="preserve">
          <source>No value</source>
          <target state="translated">가치 없음</target>
        </trans-unit>
        <trans-unit id="b8b9f1367ad6269845f5ec54d66262066092883f" translate="yes" xml:space="preserve">
          <source>No.</source>
          <target state="translated">No.</target>
        </trans-unit>
        <trans-unit id="e1e00ea722ddcc62dfc3b69613fb2a2d565490a9" translate="yes" xml:space="preserve">
          <source>Nominal types</source>
          <target state="translated">공칭 유형</target>
        </trans-unit>
        <trans-unit id="cdb02ce94d87fb6259e95b77d6deab219ecd04ba" translate="yes" xml:space="preserve">
          <source>Nominal types &amp;mdash; &lt;a href=&quot;types/struct&quot;&gt;structs&lt;/a&gt;, &lt;a href=&quot;types/enum&quot;&gt;enumerations&lt;/a&gt; and &lt;a href=&quot;types/union&quot;&gt;unions&lt;/a&gt; &amp;mdash; may be recursive. That is, each &lt;code&gt;enum&lt;/code&gt; variant or &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt; field may refer, directly or indirectly, to the enclosing &lt;code&gt;enum&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt; type itself. Such recursion has restrictions:</source>
          <target state="translated">공칭 유형 - &lt;a href=&quot;types/struct&quot;&gt;구조체&lt;/a&gt; , &lt;a href=&quot;types/enum&quot;&gt;열거&lt;/a&gt; 및 &lt;a href=&quot;types/union&quot;&gt;조합은&lt;/a&gt; - 재귀 수 있습니다. 즉, 각 &lt;code&gt;enum&lt;/code&gt; 변형 또는 &lt;code&gt;struct&lt;/code&gt; 또는 &lt;code&gt;union&lt;/code&gt; 필드는 엔 클로징 &lt;code&gt;enum&lt;/code&gt; 또는 &lt;code&gt;struct&lt;/code&gt; 를 직접 또는 간접적으로 참조 할 수 있습니다. 유형 자체 있습니다. 이러한 재귀에는 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4149c46b37e254e72be155dd7b9caf947125984" translate="yes" xml:space="preserve">
          <source>Nominal types &amp;mdash; &lt;a href=&quot;types/struct&quot;&gt;structs&lt;/a&gt;, &lt;a href=&quot;types/enum&quot;&gt;enumerations&lt;/a&gt;, and &lt;a href=&quot;types/union&quot;&gt;unions&lt;/a&gt; &amp;mdash; may be recursive. That is, each &lt;code&gt;enum&lt;/code&gt; variant or &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt; field may refer, directly or indirectly, to the enclosing &lt;code&gt;enum&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt; type itself. Such recursion has restrictions:</source>
          <target state="translated">명목 형 ( &lt;a href=&quot;types/struct&quot;&gt;structs&lt;/a&gt; , &lt;a href=&quot;types/enum&quot;&gt;enumerations&lt;/a&gt; 및 &lt;a href=&quot;types/union&quot;&gt;unions)&lt;/a&gt; 은 재귀적일 수 있습니다. 즉, 각 &lt;code&gt;enum&lt;/code&gt; 변형 또는 &lt;code&gt;struct&lt;/code&gt; 또는 &lt;code&gt;union&lt;/code&gt; 필드는 둘러싸는 &lt;code&gt;enum&lt;/code&gt; 또는 &lt;code&gt;struct&lt;/code&gt; 유형 자체 를 직접 또는 간접적으로 참조 할 수 있습니다. 이러한 재귀에는 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2b8571666155408fb60b3d7bfe218ca438c97ed" translate="yes" xml:space="preserve">
          <source>Nominal types without a &lt;code&gt;repr&lt;/code&gt; attribute have the default representation. Informally, this representation is also called the &lt;code&gt;rust&lt;/code&gt; representation.</source>
          <target state="translated">&lt;code&gt;repr&lt;/code&gt; 속성이 없는 명목 유형 에는 기본 표현이 있습니다. 비공식적으로이 표현을 &lt;code&gt;rust&lt;/code&gt; 표현 이라고도합니다 .</target>
        </trans-unit>
        <trans-unit id="5059fea19d0d88b99facd98e04beb3723c567878" translate="yes" xml:space="preserve">
          <source>Non capturing closures to &lt;code&gt;fn&lt;/code&gt; pointers</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; 포인터에 대한 비 캡처 클로저</target>
        </trans-unit>
        <trans-unit id="a51a0d057519ba84abe774072805e81677bec4c4" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;mut&lt;/code&gt; static items that contain a type that is not &lt;a href=&quot;../interior-mutability&quot;&gt;interior mutable&lt;/a&gt; may be placed in read-only memory.</source>
          <target state="translated">&lt;a href=&quot;../interior-mutability&quot;&gt;내부 변경 가능&lt;/a&gt; 하지 않은 유형을 포함하는 &lt;code&gt;mut&lt;/code&gt; - mut 정적 항목 은 읽기 전용 메모리에 배치 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1983af4c53629f3985aabae2faea197763bce6d6" translate="yes" xml:space="preserve">
          <source>Non-UTF-8 byte sequences in a &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 에서 비 UTF-8 바이트 시퀀스 .</target>
        </trans-unit>
        <trans-unit id="c7afa6ec3e9abfb77b76d7813a424b3a22eeb6a6" translate="yes" xml:space="preserve">
          <source>Non-allocating substring search.</source>
          <target state="translated">비 할당 하위 문자열 검색</target>
        </trans-unit>
        <trans-unit id="918c67058d00d25e0f0f3d637bc930eba67e9f26" translate="yes" xml:space="preserve">
          <source>Non-ascii can be used as module names if it is inlined or if a &lt;code&gt;#[path]&lt;/code&gt; attribute is specified. For example:</source>
          <target state="translated">비 ASCII는 인라인되거나 &lt;code&gt;#[path]&lt;/code&gt; 속성이 지정된 경우 모듈 이름으로 사용할 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="3dcd44915e2ff9a86c47e1f5d9c641f6ca3a035b" translate="yes" xml:space="preserve">
          <source>Non-doc comments</source>
          <target state="translated">비 문서 댓글</target>
        </trans-unit>
        <trans-unit id="824440476584993bab7b4958488eb74ef1df4ce3" translate="yes" xml:space="preserve">
          <source>Non-doc comments are interpreted as a form of whitespace.</source>
          <target state="translated">비 문서 주석은 공백 형태로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="aa21851a9f906887214ca347fd6a9f54a7e9f855" translate="yes" xml:space="preserve">
          <source>Non-exhaustive enums could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm must be added to account for any future variants.</source>
          <target state="translated">포괄적이지 않은 열거 형에는 향후 추가 변형이 추가 될 수 있습니다. 따라서 완전하지 않은 열거 형의 변형과 일치하는 경우 향후 변형을 고려하여 추가 와일드 카드 암을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="10cecc28192fc5e84850b4a3c1cd7bbfd836407b" translate="yes" xml:space="preserve">
          <source>Non-exhaustive enums could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm must be added to account for any future variants.&lt;span id=&quot;variant.Empty&quot;&gt;&lt;code id=&quot;Empty.v&quot;&gt;Empty&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">전체가 아닌 열거 형에는 나중에 추가 변형이 추가 될 수 있습니다. 따라서 전체가 아닌 열거 형의 변형과 일치하는 경우 향후 변형을 설명하기 위해 추가 와일드 카드 암을 추가해야합니다. &lt;span id=&quot;variant.Empty&quot;&gt; &lt;code id=&quot;Empty.v&quot;&gt;Empty&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="c2d926eda1237eaff90e4752c522197b25cce1b5" translate="yes" xml:space="preserve">
          <source>Non-exhaustive enums could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm must be added to account for any future variants.&lt;span id=&quot;variant.NotFound&quot;&gt;&lt;code id=&quot;NotFound.v&quot;&gt;NotFound&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">전체가 아닌 열거 형에는 나중에 추가 변형이 추가 될 수 있습니다. 따라서 전체가 아닌 열거 형의 변형과 일치하는 경우 향후 변형을 설명하기 위해 추가 와일드 카드 암을 추가해야합니다. &lt;span id=&quot;variant.NotFound&quot;&gt; &lt;code id=&quot;NotFound.v&quot;&gt;NotFound&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9ffc5a4a3c3cd6c9da0af373638cb3d4d5bda691" translate="yes" xml:space="preserve">
          <source>Non-exhaustive enums could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm must be added to account for any future variants.&lt;span id=&quot;variant.Relaxed&quot;&gt;&lt;code id=&quot;Relaxed.v&quot;&gt;Relaxed&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">전체가 아닌 열거 형에는 나중에 추가 변형이 추가 될 수 있습니다. 따라서 전체가 아닌 열거 형의 변형과 일치하는 경우 향후 변형을 설명하기 위해 추가 와일드 카드 암을 추가해야합니다. &lt;span id=&quot;variant.Relaxed&quot;&gt; &lt;code id=&quot;Relaxed.v&quot;&gt;Relaxed&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="0eb9bd2ad410dc2a883c07d5cdc83ffe0afd40df" translate="yes" xml:space="preserve">
          <source>Non-exhaustive types are always considered inhabited in downstream crates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1a6b0df00b9143148ae426e200b78dbd7fb89f" translate="yes" xml:space="preserve">
          <source>Non-exhaustive types cannot be constructed outside of the defining crate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f438ec02f71051c0a40ce9311998d29382298836" translate="yes" xml:space="preserve">
          <source>Non-exhaustive variants (&lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt; variant&lt;/a&gt;) cannot be constructed with a &lt;a href=&quot;../expressions/struct-expr&quot;&gt;&lt;em&gt;StructExpression&lt;/em&gt;&lt;/a&gt; (including with &lt;a href=&quot;../expressions/struct-expr#functional-update-syntax&quot;&gt;functional update syntax&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="677ced73d5856aaca0b6f678eabc91c14dca818b" translate="yes" xml:space="preserve">
          <source>Non-operator Symbols</source>
          <target state="translated">비 연산자 기호</target>
        </trans-unit>
        <trans-unit id="4e30c9c45a102a66eb26f8221fcbff4ef463e321" translate="yes" xml:space="preserve">
          <source>NonNull</source>
          <target state="translated">NonNull</target>
        </trans-unit>
        <trans-unit id="4406dddaf8fa2617ceb6cc8c44402048c8cf820a" translate="yes" xml:space="preserve">
          <source>NonNull::as_mut</source>
          <target state="translated">NonNull::as_mut</target>
        </trans-unit>
        <trans-unit id="2114c5e9abc5430a075844ac84cde8dc1be1fea6" translate="yes" xml:space="preserve">
          <source>NonNull::as_ptr</source>
          <target state="translated">NonNull::as_ptr</target>
        </trans-unit>
        <trans-unit id="1cabae6d82425bb900a0d474f79596c63d831307" translate="yes" xml:space="preserve">
          <source>NonNull::as_ref</source>
          <target state="translated">NonNull::as_ref</target>
        </trans-unit>
        <trans-unit id="6ed17b6bc3c37842c56b35d303eedea6a7299966" translate="yes" xml:space="preserve">
          <source>NonNull::borrow</source>
          <target state="translated">NonNull::borrow</target>
        </trans-unit>
        <trans-unit id="7e334211ca12677d4c793a4a4f5aff0a42317022" translate="yes" xml:space="preserve">
          <source>NonNull::borrow_mut</source>
          <target state="translated">NonNull::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d14ea41704eb3153152593ae4083750dca37c043" translate="yes" xml:space="preserve">
          <source>NonNull::cast</source>
          <target state="translated">NonNull::cast</target>
        </trans-unit>
        <trans-unit id="898faa9b1446e51151d3471366dee5a575326bb3" translate="yes" xml:space="preserve">
          <source>NonNull::clamp</source>
          <target state="translated">NonNull::clamp</target>
        </trans-unit>
        <trans-unit id="bf5ade412290b7a0e9f887083d2f7add59f5a5fc" translate="yes" xml:space="preserve">
          <source>NonNull::clone</source>
          <target state="translated">NonNull::clone</target>
        </trans-unit>
        <trans-unit id="d26e757d1bc68cfc66ec9cac7468feab54ad3bf1" translate="yes" xml:space="preserve">
          <source>NonNull::clone_from</source>
          <target state="translated">NonNull::clone_from</target>
        </trans-unit>
        <trans-unit id="ec88376a17645ec47ad005ff58328f13df7dd535" translate="yes" xml:space="preserve">
          <source>NonNull::clone_into</source>
          <target state="translated">NonNull::clone_into</target>
        </trans-unit>
        <trans-unit id="fd33327c1c03c18157e310949eb3ee49adc1b771" translate="yes" xml:space="preserve">
          <source>NonNull::cmp</source>
          <target state="translated">NonNull::cmp</target>
        </trans-unit>
        <trans-unit id="987e425f6d75ea2d5d6595ecf927bb4ee065890c" translate="yes" xml:space="preserve">
          <source>NonNull::dangling</source>
          <target state="translated">NonNull::dangling</target>
        </trans-unit>
        <trans-unit id="c22e4114ed2e98fa57926d0f979b5e4f67cb57d4" translate="yes" xml:space="preserve">
          <source>NonNull::eq</source>
          <target state="translated">NonNull::eq</target>
        </trans-unit>
        <trans-unit id="d00b2d876766572056074e351b4e54188d623d2b" translate="yes" xml:space="preserve">
          <source>NonNull::fmt</source>
          <target state="translated">NonNull::fmt</target>
        </trans-unit>
        <trans-unit id="920d1fd41b172fec04d2e45bb2bdef697e4fe777" translate="yes" xml:space="preserve">
          <source>NonNull::from</source>
          <target state="translated">NonNull::from</target>
        </trans-unit>
        <trans-unit id="e069f30f0197691ef84cfb150cfed51e68e388e1" translate="yes" xml:space="preserve">
          <source>NonNull::ge</source>
          <target state="translated">NonNull::ge</target>
        </trans-unit>
        <trans-unit id="c04dde85527ee18200a552eae552b457a7f99bd6" translate="yes" xml:space="preserve">
          <source>NonNull::gt</source>
          <target state="translated">NonNull::gt</target>
        </trans-unit>
        <trans-unit id="1962f7d627fcf30051ef24ad505c0bc5f914d525" translate="yes" xml:space="preserve">
          <source>NonNull::hash</source>
          <target state="translated">NonNull::hash</target>
        </trans-unit>
        <trans-unit id="947f5524bfbda623a81d3a1c8013f457968a7a86" translate="yes" xml:space="preserve">
          <source>NonNull::hash_slice</source>
          <target state="translated">NonNull::hash_slice</target>
        </trans-unit>
        <trans-unit id="389c43bbeacefc5b6764890179f4b9b2032438f2" translate="yes" xml:space="preserve">
          <source>NonNull::into</source>
          <target state="translated">NonNull::into</target>
        </trans-unit>
        <trans-unit id="47e7802874702c46a2e861846c1495c139c4c850" translate="yes" xml:space="preserve">
          <source>NonNull::le</source>
          <target state="translated">NonNull::le</target>
        </trans-unit>
        <trans-unit id="9345c04e2a031789eec4e0c10625a029c4ae6f61" translate="yes" xml:space="preserve">
          <source>NonNull::lt</source>
          <target state="translated">NonNull::lt</target>
        </trans-unit>
        <trans-unit id="7a29d42be85ea3d359fc0499cfc787631cbd8fc5" translate="yes" xml:space="preserve">
          <source>NonNull::max</source>
          <target state="translated">NonNull::max</target>
        </trans-unit>
        <trans-unit id="61df043b4cb69b06e977ed45aa61b72a55c0c1a7" translate="yes" xml:space="preserve">
          <source>NonNull::min</source>
          <target state="translated">NonNull::min</target>
        </trans-unit>
        <trans-unit id="abded46d5ba3ed8a510f52a6c525d34081184868" translate="yes" xml:space="preserve">
          <source>NonNull::ne</source>
          <target state="translated">NonNull::ne</target>
        </trans-unit>
        <trans-unit id="28098f7280cb4f6eb94dfb98674503d36042312c" translate="yes" xml:space="preserve">
          <source>NonNull::new</source>
          <target state="translated">NonNull::new</target>
        </trans-unit>
        <trans-unit id="faebd85a1d1a684a9974b3cced67816fb864d3e2" translate="yes" xml:space="preserve">
          <source>NonNull::new_unchecked</source>
          <target state="translated">NonNull::new_unchecked</target>
        </trans-unit>
        <trans-unit id="daad03caa96878a899bd74268cdf22f8762238fc" translate="yes" xml:space="preserve">
          <source>NonNull::partial_cmp</source>
          <target state="translated">NonNull::partial_cmp</target>
        </trans-unit>
        <trans-unit id="4a54ca911ffa7ae9c156cb290778a55bb5102986" translate="yes" xml:space="preserve">
          <source>NonNull::to_owned</source>
          <target state="translated">NonNull::to_owned</target>
        </trans-unit>
        <trans-unit id="9c8c974cd30a86ae9347bdcc34e89477c2ec64af" translate="yes" xml:space="preserve">
          <source>NonNull::try_from</source>
          <target state="translated">NonNull::try_from</target>
        </trans-unit>
        <trans-unit id="cbe36570c4b5d03cc4de672aa3768cec6ff79fc7" translate="yes" xml:space="preserve">
          <source>NonNull::try_into</source>
          <target state="translated">NonNull::try_into</target>
        </trans-unit>
        <trans-unit id="5c4656d738141e414301ef5f2fc675edf57dbe67" translate="yes" xml:space="preserve">
          <source>NonNull::type_id</source>
          <target state="translated">NonNull::type_id</target>
        </trans-unit>
        <trans-unit id="3551d2c727366d003ebd8c642167f4ef9debfb26" translate="yes" xml:space="preserve">
          <source>NonZeroI128</source>
          <target state="translated">NonZeroI128</target>
        </trans-unit>
        <trans-unit id="f7717a5e03944c9f7da8d5810a2b468333e1dd38" translate="yes" xml:space="preserve">
          <source>NonZeroI128::borrow</source>
          <target state="translated">NonZeroI128::borrow</target>
        </trans-unit>
        <trans-unit id="f964efe706788bf3868121236c120eec56d477d3" translate="yes" xml:space="preserve">
          <source>NonZeroI128::borrow_mut</source>
          <target state="translated">NonZeroI128::borrow_mut</target>
        </trans-unit>
        <trans-unit id="5ff8443b26f494de74b190931a04e5ad0a0f8bce" translate="yes" xml:space="preserve">
          <source>NonZeroI128::clamp</source>
          <target state="translated">NonZeroI128::clamp</target>
        </trans-unit>
        <trans-unit id="b41821f2bbc6d793e496bf8cf8e0961c8c6cf20e" translate="yes" xml:space="preserve">
          <source>NonZeroI128::clone</source>
          <target state="translated">NonZeroI128::clone</target>
        </trans-unit>
        <trans-unit id="86b0e71b93cf7cfc8d3f88502fefd684a7508a83" translate="yes" xml:space="preserve">
          <source>NonZeroI128::clone_from</source>
          <target state="translated">NonZeroI128::clone_from</target>
        </trans-unit>
        <trans-unit id="e87976c36fbb769fdf82eb4fc79b3850621b2d11" translate="yes" xml:space="preserve">
          <source>NonZeroI128::clone_into</source>
          <target state="translated">NonZeroI128::clone_into</target>
        </trans-unit>
        <trans-unit id="1fbab26faccad65c9594c9912db60595257c834d" translate="yes" xml:space="preserve">
          <source>NonZeroI128::cmp</source>
          <target state="translated">NonZeroI128::cmp</target>
        </trans-unit>
        <trans-unit id="e40f0ecb53bba7364d61eeddde211916e2de23b0" translate="yes" xml:space="preserve">
          <source>NonZeroI128::eq</source>
          <target state="translated">NonZeroI128::eq</target>
        </trans-unit>
        <trans-unit id="06203fb0241e3db251fdbeb37b55ecf55bc73b90" translate="yes" xml:space="preserve">
          <source>NonZeroI128::fmt</source>
          <target state="translated">NonZeroI128::fmt</target>
        </trans-unit>
        <trans-unit id="0fc860ac20708b78eba2f88aebf4c0cae43f1b01" translate="yes" xml:space="preserve">
          <source>NonZeroI128::from</source>
          <target state="translated">NonZeroI128::from</target>
        </trans-unit>
        <trans-unit id="e9225e88cc3a187fc6e8da37813f50d8aace8352" translate="yes" xml:space="preserve">
          <source>NonZeroI128::from_str</source>
          <target state="translated">NonZeroI128::from_str</target>
        </trans-unit>
        <trans-unit id="1060cfd82a1c5a4f9319951b3ccf33667960e338" translate="yes" xml:space="preserve">
          <source>NonZeroI128::ge</source>
          <target state="translated">NonZeroI128::ge</target>
        </trans-unit>
        <trans-unit id="1174fff40e9915f0fddc11dc5e858638caff1eb7" translate="yes" xml:space="preserve">
          <source>NonZeroI128::get</source>
          <target state="translated">NonZeroI128::get</target>
        </trans-unit>
        <trans-unit id="6360aa3b732a77c2367a197d6649d264398a3733" translate="yes" xml:space="preserve">
          <source>NonZeroI128::gt</source>
          <target state="translated">NonZeroI128::gt</target>
        </trans-unit>
        <trans-unit id="74c9ab59cffa5d7149b9a4669f4269b74eeb9074" translate="yes" xml:space="preserve">
          <source>NonZeroI128::hash</source>
          <target state="translated">NonZeroI128::hash</target>
        </trans-unit>
        <trans-unit id="683d8b9cc521cc55c631921795be0979d992e3f0" translate="yes" xml:space="preserve">
          <source>NonZeroI128::hash_slice</source>
          <target state="translated">NonZeroI128::hash_slice</target>
        </trans-unit>
        <trans-unit id="aa52174afecb1310862de00467bdc35c65937a26" translate="yes" xml:space="preserve">
          <source>NonZeroI128::into</source>
          <target state="translated">NonZeroI128::into</target>
        </trans-unit>
        <trans-unit id="148aa4d7eea87fc4622065d40fb8f2ec58899a47" translate="yes" xml:space="preserve">
          <source>NonZeroI128::le</source>
          <target state="translated">NonZeroI128::le</target>
        </trans-unit>
        <trans-unit id="4cab526460d9eafdf6e790d31dfeefc0f6385568" translate="yes" xml:space="preserve">
          <source>NonZeroI128::lt</source>
          <target state="translated">NonZeroI128::lt</target>
        </trans-unit>
        <trans-unit id="c0e0f0d6f1984e61de46b50df3dd15bb2c3be699" translate="yes" xml:space="preserve">
          <source>NonZeroI128::max</source>
          <target state="translated">NonZeroI128::max</target>
        </trans-unit>
        <trans-unit id="afd96d69d525973449f87aee12afd0af77bb90ff" translate="yes" xml:space="preserve">
          <source>NonZeroI128::min</source>
          <target state="translated">NonZeroI128::min</target>
        </trans-unit>
        <trans-unit id="246cde0659cbc3a878d28d1aa05929c570deac33" translate="yes" xml:space="preserve">
          <source>NonZeroI128::ne</source>
          <target state="translated">NonZeroI128::ne</target>
        </trans-unit>
        <trans-unit id="8673425a72ca5491b6fece38839c045e52eb4d36" translate="yes" xml:space="preserve">
          <source>NonZeroI128::new</source>
          <target state="translated">NonZeroI128::new</target>
        </trans-unit>
        <trans-unit id="83c86c3acc20bd4fdf03572b0722c1f12370f0bb" translate="yes" xml:space="preserve">
          <source>NonZeroI128::new_unchecked</source>
          <target state="translated">NonZeroI128::new_unchecked</target>
        </trans-unit>
        <trans-unit id="7d31a0e09cd71a4a287a5059ffc925fb40c7ce05" translate="yes" xml:space="preserve">
          <source>NonZeroI128::partial_cmp</source>
          <target state="translated">NonZeroI128::partial_cmp</target>
        </trans-unit>
        <trans-unit id="608c27b25bdd1b009cc3a24d8a6782000bd55a1c" translate="yes" xml:space="preserve">
          <source>NonZeroI128::to_owned</source>
          <target state="translated">NonZeroI128::to_owned</target>
        </trans-unit>
        <trans-unit id="744cd6d60888a33636a82b0368460edf2109a4f4" translate="yes" xml:space="preserve">
          <source>NonZeroI128::to_string</source>
          <target state="translated">NonZeroI128::to_string</target>
        </trans-unit>
        <trans-unit id="ac99be0bfb14a319fad21b69b5e280921b9604e7" translate="yes" xml:space="preserve">
          <source>NonZeroI128::try_from</source>
          <target state="translated">NonZeroI128::try_from</target>
        </trans-unit>
        <trans-unit id="2abe344dbf2f82320c3d223157d57b6766d23549" translate="yes" xml:space="preserve">
          <source>NonZeroI128::try_into</source>
          <target state="translated">NonZeroI128::try_into</target>
        </trans-unit>
        <trans-unit id="10a577a305c3efc3499cc94da566386465669213" translate="yes" xml:space="preserve">
          <source>NonZeroI128::type_id</source>
          <target state="translated">NonZeroI128::type_id</target>
        </trans-unit>
        <trans-unit id="36f429958b2bd2e0923475b148a0c1f6e808e911" translate="yes" xml:space="preserve">
          <source>NonZeroI16</source>
          <target state="translated">NonZeroI16</target>
        </trans-unit>
        <trans-unit id="18b48de75cdc24dca01c5ee1c28e20115a7eb2a1" translate="yes" xml:space="preserve">
          <source>NonZeroI16::borrow</source>
          <target state="translated">NonZeroI16::borrow</target>
        </trans-unit>
        <trans-unit id="bdbca21815164e23bce622eb47091fb5f9f2176c" translate="yes" xml:space="preserve">
          <source>NonZeroI16::borrow_mut</source>
          <target state="translated">NonZeroI16::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2541826a258687d3b644073478113268e63c74af" translate="yes" xml:space="preserve">
          <source>NonZeroI16::clamp</source>
          <target state="translated">NonZeroI16::clamp</target>
        </trans-unit>
        <trans-unit id="115ee98eb9f17414d1638645fa06af3167003827" translate="yes" xml:space="preserve">
          <source>NonZeroI16::clone</source>
          <target state="translated">NonZeroI16::clone</target>
        </trans-unit>
        <trans-unit id="0278b33294858e10f554d1971ffc6f87bb8f5b09" translate="yes" xml:space="preserve">
          <source>NonZeroI16::clone_from</source>
          <target state="translated">NonZeroI16::clone_from</target>
        </trans-unit>
        <trans-unit id="c7c71d2e0fcced1b160e7459dff80d6f48dcbc4f" translate="yes" xml:space="preserve">
          <source>NonZeroI16::clone_into</source>
          <target state="translated">NonZeroI16::clone_into</target>
        </trans-unit>
        <trans-unit id="850888fdd17f8d9104362438c1677057b27654a4" translate="yes" xml:space="preserve">
          <source>NonZeroI16::cmp</source>
          <target state="translated">NonZeroI16::cmp</target>
        </trans-unit>
        <trans-unit id="f05c890da588a6175c01f462a0b77681853ea3b1" translate="yes" xml:space="preserve">
          <source>NonZeroI16::eq</source>
          <target state="translated">NonZeroI16::eq</target>
        </trans-unit>
        <trans-unit id="afd24843e5add4461be3e24eb291a9cc7627956c" translate="yes" xml:space="preserve">
          <source>NonZeroI16::fmt</source>
          <target state="translated">NonZeroI16::fmt</target>
        </trans-unit>
        <trans-unit id="4858ff995b8e659abd51265d63ea466463440d7f" translate="yes" xml:space="preserve">
          <source>NonZeroI16::from</source>
          <target state="translated">NonZeroI16::from</target>
        </trans-unit>
        <trans-unit id="e029bc06979cac03c696126c7078fc97b9d215f8" translate="yes" xml:space="preserve">
          <source>NonZeroI16::from_str</source>
          <target state="translated">NonZeroI16::from_str</target>
        </trans-unit>
        <trans-unit id="bafd6163144db642a0a88ae9a0d1f67a9aa327c8" translate="yes" xml:space="preserve">
          <source>NonZeroI16::ge</source>
          <target state="translated">NonZeroI16::ge</target>
        </trans-unit>
        <trans-unit id="8aabc8e5c65d44f1317cc2c944b8544a7d7743b4" translate="yes" xml:space="preserve">
          <source>NonZeroI16::get</source>
          <target state="translated">NonZeroI16::get</target>
        </trans-unit>
        <trans-unit id="f4bd402ef0cb908aeee7f003297047e0d4730ffe" translate="yes" xml:space="preserve">
          <source>NonZeroI16::gt</source>
          <target state="translated">NonZeroI16::gt</target>
        </trans-unit>
        <trans-unit id="eea24fe60c2ee511de571b916e274e0b8b9953ea" translate="yes" xml:space="preserve">
          <source>NonZeroI16::hash</source>
          <target state="translated">NonZeroI16::hash</target>
        </trans-unit>
        <trans-unit id="2072b7c0817666ffd6461a331c7f56a7e3159241" translate="yes" xml:space="preserve">
          <source>NonZeroI16::hash_slice</source>
          <target state="translated">NonZeroI16::hash_slice</target>
        </trans-unit>
        <trans-unit id="609c336f653a5586992a687fdc21a4e12e0e5bfc" translate="yes" xml:space="preserve">
          <source>NonZeroI16::into</source>
          <target state="translated">NonZeroI16::into</target>
        </trans-unit>
        <trans-unit id="dcd26dca67e989e320ea7d8ce4a6b4b2f5a19253" translate="yes" xml:space="preserve">
          <source>NonZeroI16::le</source>
          <target state="translated">NonZeroI16::le</target>
        </trans-unit>
        <trans-unit id="764441ce7cfb74845e4e5601e7c04d15cb44d34d" translate="yes" xml:space="preserve">
          <source>NonZeroI16::lt</source>
          <target state="translated">NonZeroI16::lt</target>
        </trans-unit>
        <trans-unit id="ba011aa8171b9001b2fd20e4d332efc5ad115b12" translate="yes" xml:space="preserve">
          <source>NonZeroI16::max</source>
          <target state="translated">NonZeroI16::max</target>
        </trans-unit>
        <trans-unit id="a323327b77c7bebd588241f8e49fcd0eb80d98c1" translate="yes" xml:space="preserve">
          <source>NonZeroI16::min</source>
          <target state="translated">NonZeroI16::min</target>
        </trans-unit>
        <trans-unit id="2ea2360fbbb5c24f384364e47a1ccf667fabf208" translate="yes" xml:space="preserve">
          <source>NonZeroI16::ne</source>
          <target state="translated">NonZeroI16::ne</target>
        </trans-unit>
        <trans-unit id="8a2d9c5311b2f8e5e740b1521cf3f032afe2075a" translate="yes" xml:space="preserve">
          <source>NonZeroI16::new</source>
          <target state="translated">NonZeroI16::new</target>
        </trans-unit>
        <trans-unit id="d31ab8bc0d5d31927c609f1a69be30fb3accda97" translate="yes" xml:space="preserve">
          <source>NonZeroI16::new_unchecked</source>
          <target state="translated">NonZeroI16::new_unchecked</target>
        </trans-unit>
        <trans-unit id="9f248594130914dc8c1850b1503ca6a5baa9ab10" translate="yes" xml:space="preserve">
          <source>NonZeroI16::partial_cmp</source>
          <target state="translated">NonZeroI16::partial_cmp</target>
        </trans-unit>
        <trans-unit id="e47f6505b2ad746102f22ad01953cb709a47b9ca" translate="yes" xml:space="preserve">
          <source>NonZeroI16::to_owned</source>
          <target state="translated">NonZeroI16::to_owned</target>
        </trans-unit>
        <trans-unit id="9e491563b10305c5dc822fc5b251f24741e46929" translate="yes" xml:space="preserve">
          <source>NonZeroI16::to_string</source>
          <target state="translated">NonZeroI16::to_string</target>
        </trans-unit>
        <trans-unit id="f4ff4d972a8c42fa8c0abaffc2f1e2b76fcb4197" translate="yes" xml:space="preserve">
          <source>NonZeroI16::try_from</source>
          <target state="translated">NonZeroI16::try_from</target>
        </trans-unit>
        <trans-unit id="63b8ff5cf42ec223a0adb54868428b7e995a5c22" translate="yes" xml:space="preserve">
          <source>NonZeroI16::try_into</source>
          <target state="translated">NonZeroI16::try_into</target>
        </trans-unit>
        <trans-unit id="c06a21dec83a42f8edb2e0d6693bc0ed2ab66da7" translate="yes" xml:space="preserve">
          <source>NonZeroI16::type_id</source>
          <target state="translated">NonZeroI16::type_id</target>
        </trans-unit>
        <trans-unit id="e97bcb5feaee0189523545e2b1d1eaf6c4e683e0" translate="yes" xml:space="preserve">
          <source>NonZeroI32</source>
          <target state="translated">NonZeroI32</target>
        </trans-unit>
        <trans-unit id="54c92b19f0c002e52d95b9a54c687cabaec7d0c3" translate="yes" xml:space="preserve">
          <source>NonZeroI32::borrow</source>
          <target state="translated">NonZeroI32::borrow</target>
        </trans-unit>
        <trans-unit id="6269e913feb8c230d29ea7ab62da579bdbf5a4eb" translate="yes" xml:space="preserve">
          <source>NonZeroI32::borrow_mut</source>
          <target state="translated">NonZeroI32::borrow_mut</target>
        </trans-unit>
        <trans-unit id="1224c3cd7e71ba3386431b31298d37d70f8c5b82" translate="yes" xml:space="preserve">
          <source>NonZeroI32::clamp</source>
          <target state="translated">NonZeroI32::clamp</target>
        </trans-unit>
        <trans-unit id="84582bf1efcf9bffacf576b2dc9d228ded21783f" translate="yes" xml:space="preserve">
          <source>NonZeroI32::clone</source>
          <target state="translated">NonZeroI32::clone</target>
        </trans-unit>
        <trans-unit id="6d253c4ffdb7629f523cd7bb9f9e369a62759084" translate="yes" xml:space="preserve">
          <source>NonZeroI32::clone_from</source>
          <target state="translated">NonZeroI32::clone_from</target>
        </trans-unit>
        <trans-unit id="1193f158b2ad7d7a268d3f866cb7f7b1315214d1" translate="yes" xml:space="preserve">
          <source>NonZeroI32::clone_into</source>
          <target state="translated">NonZeroI32::clone_into</target>
        </trans-unit>
        <trans-unit id="4b603b1e9d2c2afaaf494daaf899ac95dbaaf60d" translate="yes" xml:space="preserve">
          <source>NonZeroI32::cmp</source>
          <target state="translated">NonZeroI32::cmp</target>
        </trans-unit>
        <trans-unit id="36ea7e2e5a4bb27588581579d297e2d75bde8c04" translate="yes" xml:space="preserve">
          <source>NonZeroI32::eq</source>
          <target state="translated">NonZeroI32::eq</target>
        </trans-unit>
        <trans-unit id="1edda6e591f89ce442f2cb26f60edda071d57e45" translate="yes" xml:space="preserve">
          <source>NonZeroI32::fmt</source>
          <target state="translated">NonZeroI32::fmt</target>
        </trans-unit>
        <trans-unit id="ddd4914f74fdfcbf44e61dac8ed824dc7daf8835" translate="yes" xml:space="preserve">
          <source>NonZeroI32::from</source>
          <target state="translated">NonZeroI32::from</target>
        </trans-unit>
        <trans-unit id="40c6ed7e5bb0241e56fda5056b11bd5c06468ef7" translate="yes" xml:space="preserve">
          <source>NonZeroI32::from_str</source>
          <target state="translated">NonZeroI32::from_str</target>
        </trans-unit>
        <trans-unit id="ade03fa8f0e3d00c9d57318b69563c321a5de2eb" translate="yes" xml:space="preserve">
          <source>NonZeroI32::ge</source>
          <target state="translated">NonZeroI32::ge</target>
        </trans-unit>
        <trans-unit id="1d06e8a039855892a9b222f01348adf7e49edc4d" translate="yes" xml:space="preserve">
          <source>NonZeroI32::get</source>
          <target state="translated">NonZeroI32::get</target>
        </trans-unit>
        <trans-unit id="fa60ed7434a0539f3d9490e5fd97303495e8e4c6" translate="yes" xml:space="preserve">
          <source>NonZeroI32::gt</source>
          <target state="translated">NonZeroI32::gt</target>
        </trans-unit>
        <trans-unit id="f8325277d4aaaad37e3f8e3f7eea57d33a82b14d" translate="yes" xml:space="preserve">
          <source>NonZeroI32::hash</source>
          <target state="translated">NonZeroI32::hash</target>
        </trans-unit>
        <trans-unit id="15d30eee444980fbb702c19bb0e763a3a3edcf54" translate="yes" xml:space="preserve">
          <source>NonZeroI32::hash_slice</source>
          <target state="translated">NonZeroI32::hash_slice</target>
        </trans-unit>
        <trans-unit id="803e758732aa4ff1933498c8c223c849e07ecb60" translate="yes" xml:space="preserve">
          <source>NonZeroI32::into</source>
          <target state="translated">NonZeroI32::into</target>
        </trans-unit>
        <trans-unit id="790804224c71a8a913941fd99262449cfc4eae1f" translate="yes" xml:space="preserve">
          <source>NonZeroI32::le</source>
          <target state="translated">NonZeroI32::le</target>
        </trans-unit>
        <trans-unit id="67201699a9447f0b39d54ba4f84c3b95336721f4" translate="yes" xml:space="preserve">
          <source>NonZeroI32::lt</source>
          <target state="translated">NonZeroI32::lt</target>
        </trans-unit>
        <trans-unit id="ed55b8cb9ce6596e0102020b3149699afc739afa" translate="yes" xml:space="preserve">
          <source>NonZeroI32::max</source>
          <target state="translated">NonZeroI32::max</target>
        </trans-unit>
        <trans-unit id="ea9de8a6d3342c8565ee626a42eaee51ddecb252" translate="yes" xml:space="preserve">
          <source>NonZeroI32::min</source>
          <target state="translated">NonZeroI32::min</target>
        </trans-unit>
        <trans-unit id="b4954c9a76b0d358e8ac80094df9a4364fff4cb7" translate="yes" xml:space="preserve">
          <source>NonZeroI32::ne</source>
          <target state="translated">NonZeroI32::ne</target>
        </trans-unit>
        <trans-unit id="6049048c2192264cafbbf66dce8946d4e59179cf" translate="yes" xml:space="preserve">
          <source>NonZeroI32::new</source>
          <target state="translated">NonZeroI32::new</target>
        </trans-unit>
        <trans-unit id="fffc2d80845e3795deaddee315cce1ed09540038" translate="yes" xml:space="preserve">
          <source>NonZeroI32::new_unchecked</source>
          <target state="translated">NonZeroI32::new_unchecked</target>
        </trans-unit>
        <trans-unit id="da01db7b3738e2a15dd55235e9cf2517c43505ad" translate="yes" xml:space="preserve">
          <source>NonZeroI32::partial_cmp</source>
          <target state="translated">NonZeroI32::partial_cmp</target>
        </trans-unit>
        <trans-unit id="86e152a0c12749dda033dd64bbf2468b20925901" translate="yes" xml:space="preserve">
          <source>NonZeroI32::to_owned</source>
          <target state="translated">NonZeroI32::to_owned</target>
        </trans-unit>
        <trans-unit id="c8e2c1746dcaaf891c7f0924e2a7d50565492f1c" translate="yes" xml:space="preserve">
          <source>NonZeroI32::to_string</source>
          <target state="translated">NonZeroI32::to_string</target>
        </trans-unit>
        <trans-unit id="55a921f848a7b22a94032abe096e9e693c57d8c2" translate="yes" xml:space="preserve">
          <source>NonZeroI32::try_from</source>
          <target state="translated">NonZeroI32::try_from</target>
        </trans-unit>
        <trans-unit id="153dc660977b7dbd63100838a1c1f00c97814fda" translate="yes" xml:space="preserve">
          <source>NonZeroI32::try_into</source>
          <target state="translated">NonZeroI32::try_into</target>
        </trans-unit>
        <trans-unit id="d326f8bf5b1e05bd3e854148e764814dfa31fec6" translate="yes" xml:space="preserve">
          <source>NonZeroI32::type_id</source>
          <target state="translated">NonZeroI32::type_id</target>
        </trans-unit>
        <trans-unit id="47326afc55d69221c5bab6f6fc50b489aa6e615c" translate="yes" xml:space="preserve">
          <source>NonZeroI64</source>
          <target state="translated">NonZeroI64</target>
        </trans-unit>
        <trans-unit id="dc475e1ce0d61071c86badb53c4876f712060aa4" translate="yes" xml:space="preserve">
          <source>NonZeroI64::borrow</source>
          <target state="translated">NonZeroI64::borrow</target>
        </trans-unit>
        <trans-unit id="b34344f17d4f0c2fd181fff34ce7e309683eb1f9" translate="yes" xml:space="preserve">
          <source>NonZeroI64::borrow_mut</source>
          <target state="translated">NonZeroI64::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ed2423a4aa70c798c0ab5645f6d832bd412161f6" translate="yes" xml:space="preserve">
          <source>NonZeroI64::clamp</source>
          <target state="translated">NonZeroI64::clamp</target>
        </trans-unit>
        <trans-unit id="f5d711fdbab29c1437fb83b2a0f49dcbcc2c895c" translate="yes" xml:space="preserve">
          <source>NonZeroI64::clone</source>
          <target state="translated">NonZeroI64::clone</target>
        </trans-unit>
        <trans-unit id="267a861768f4cde9358a3ce3dea2c45f82d2d70c" translate="yes" xml:space="preserve">
          <source>NonZeroI64::clone_from</source>
          <target state="translated">NonZeroI64::clone_from</target>
        </trans-unit>
        <trans-unit id="5cb0bd8479d4a4e335894c67e9f47406638b985a" translate="yes" xml:space="preserve">
          <source>NonZeroI64::clone_into</source>
          <target state="translated">NonZeroI64::clone_into</target>
        </trans-unit>
        <trans-unit id="62c821c3e10a9bc5dda6564e62e097e6d1aaded4" translate="yes" xml:space="preserve">
          <source>NonZeroI64::cmp</source>
          <target state="translated">NonZeroI64::cmp</target>
        </trans-unit>
        <trans-unit id="69e086a251f574f1bcd8ddeee49f798091de65ae" translate="yes" xml:space="preserve">
          <source>NonZeroI64::eq</source>
          <target state="translated">NonZeroI64::eq</target>
        </trans-unit>
        <trans-unit id="4628e95346886a1385b96213a08e94cab6a3e3ec" translate="yes" xml:space="preserve">
          <source>NonZeroI64::fmt</source>
          <target state="translated">NonZeroI64::fmt</target>
        </trans-unit>
        <trans-unit id="fa74211c65ed03702df0d7fec92011a00e46da4e" translate="yes" xml:space="preserve">
          <source>NonZeroI64::from</source>
          <target state="translated">NonZeroI64::from</target>
        </trans-unit>
        <trans-unit id="374c31c818806d2d53cf7d6521ef765de951d640" translate="yes" xml:space="preserve">
          <source>NonZeroI64::from_str</source>
          <target state="translated">NonZeroI64::from_str</target>
        </trans-unit>
        <trans-unit id="716f09379283859a96964aa90f9488fffda7f930" translate="yes" xml:space="preserve">
          <source>NonZeroI64::ge</source>
          <target state="translated">NonZeroI64::ge</target>
        </trans-unit>
        <trans-unit id="2826557154d33d398abcd879206752804a2bdf65" translate="yes" xml:space="preserve">
          <source>NonZeroI64::get</source>
          <target state="translated">NonZeroI64::get</target>
        </trans-unit>
        <trans-unit id="c03423dc02e1ef948358b0f5f0ef5c13016b5d96" translate="yes" xml:space="preserve">
          <source>NonZeroI64::gt</source>
          <target state="translated">NonZeroI64::gt</target>
        </trans-unit>
        <trans-unit id="7c084405e2fa1d7847475c21cc64bd06540a721b" translate="yes" xml:space="preserve">
          <source>NonZeroI64::hash</source>
          <target state="translated">NonZeroI64::hash</target>
        </trans-unit>
        <trans-unit id="bb8f897598ee6dc20d33aa36af3c10e2b97e157a" translate="yes" xml:space="preserve">
          <source>NonZeroI64::hash_slice</source>
          <target state="translated">NonZeroI64::hash_slice</target>
        </trans-unit>
        <trans-unit id="ef8da458756764d04abbf9c4bf5a7d43687e9799" translate="yes" xml:space="preserve">
          <source>NonZeroI64::into</source>
          <target state="translated">NonZeroI64::into</target>
        </trans-unit>
        <trans-unit id="361205d1a32febcfc1190394e636de20cf9980ff" translate="yes" xml:space="preserve">
          <source>NonZeroI64::le</source>
          <target state="translated">NonZeroI64::le</target>
        </trans-unit>
        <trans-unit id="bfa76864905ebec51d3cd7370cb21f3b8325bc2a" translate="yes" xml:space="preserve">
          <source>NonZeroI64::lt</source>
          <target state="translated">NonZeroI64::lt</target>
        </trans-unit>
        <trans-unit id="d05fd485f6f48cbcf9797f21c7f72b7da774ef73" translate="yes" xml:space="preserve">
          <source>NonZeroI64::max</source>
          <target state="translated">NonZeroI64::max</target>
        </trans-unit>
        <trans-unit id="4445fa7cd5899e3dddfe813b834bacaadd0b1f16" translate="yes" xml:space="preserve">
          <source>NonZeroI64::min</source>
          <target state="translated">NonZeroI64::min</target>
        </trans-unit>
        <trans-unit id="0e8b97484e878d06b6ee68465379752feed3cd3d" translate="yes" xml:space="preserve">
          <source>NonZeroI64::ne</source>
          <target state="translated">NonZeroI64::ne</target>
        </trans-unit>
        <trans-unit id="bde2e9f1fb06520bab485b2e3afb4e80b33dba82" translate="yes" xml:space="preserve">
          <source>NonZeroI64::new</source>
          <target state="translated">NonZeroI64::new</target>
        </trans-unit>
        <trans-unit id="f82a0245493af04b7985ed399fa466dc4edc8ced" translate="yes" xml:space="preserve">
          <source>NonZeroI64::new_unchecked</source>
          <target state="translated">NonZeroI64::new_unchecked</target>
        </trans-unit>
        <trans-unit id="ff0c4a829e7306aac0aa333126abf09bbe21f706" translate="yes" xml:space="preserve">
          <source>NonZeroI64::partial_cmp</source>
          <target state="translated">NonZeroI64::partial_cmp</target>
        </trans-unit>
        <trans-unit id="12b3dd3db76faeb57eec7254b2c1977c25f88349" translate="yes" xml:space="preserve">
          <source>NonZeroI64::to_owned</source>
          <target state="translated">NonZeroI64::to_owned</target>
        </trans-unit>
        <trans-unit id="898927cce217ffb93b1463253607e0954996b3fd" translate="yes" xml:space="preserve">
          <source>NonZeroI64::to_string</source>
          <target state="translated">NonZeroI64::to_string</target>
        </trans-unit>
        <trans-unit id="2d19979b95b66165d9cce2a874b5b50774c07fee" translate="yes" xml:space="preserve">
          <source>NonZeroI64::try_from</source>
          <target state="translated">NonZeroI64::try_from</target>
        </trans-unit>
        <trans-unit id="a50be005ecf5a07bc843f676f748462b8adca096" translate="yes" xml:space="preserve">
          <source>NonZeroI64::try_into</source>
          <target state="translated">NonZeroI64::try_into</target>
        </trans-unit>
        <trans-unit id="0134deb92dae159c2082bceaef595cfc9df55dce" translate="yes" xml:space="preserve">
          <source>NonZeroI64::type_id</source>
          <target state="translated">NonZeroI64::type_id</target>
        </trans-unit>
        <trans-unit id="de2b631972cf994d47d76eac38bd59ef1aa6e707" translate="yes" xml:space="preserve">
          <source>NonZeroI8</source>
          <target state="translated">NonZeroI8</target>
        </trans-unit>
        <trans-unit id="02a97b1be1b57111983e0f301eaade35ec979636" translate="yes" xml:space="preserve">
          <source>NonZeroI8::borrow</source>
          <target state="translated">NonZeroI8::borrow</target>
        </trans-unit>
        <trans-unit id="585184585d76b6d884767a1ba1173bf3fdcf9087" translate="yes" xml:space="preserve">
          <source>NonZeroI8::borrow_mut</source>
          <target state="translated">NonZeroI8::borrow_mut</target>
        </trans-unit>
        <trans-unit id="61d82766a6745e76c9a921124d58b68ee8622344" translate="yes" xml:space="preserve">
          <source>NonZeroI8::clamp</source>
          <target state="translated">NonZeroI8::clamp</target>
        </trans-unit>
        <trans-unit id="9639aa6f98547170260a0dbed71fe42368a45037" translate="yes" xml:space="preserve">
          <source>NonZeroI8::clone</source>
          <target state="translated">NonZeroI8::clone</target>
        </trans-unit>
        <trans-unit id="69bea805436f5d9faeecb421d3ad1efbed040ab0" translate="yes" xml:space="preserve">
          <source>NonZeroI8::clone_from</source>
          <target state="translated">NonZeroI8::clone_from</target>
        </trans-unit>
        <trans-unit id="f79563630b90126fa16369923d147a8e6ffaf90f" translate="yes" xml:space="preserve">
          <source>NonZeroI8::clone_into</source>
          <target state="translated">NonZeroI8::clone_into</target>
        </trans-unit>
        <trans-unit id="2e5b078a7705aaa646d49606a0e296d4af0f1acd" translate="yes" xml:space="preserve">
          <source>NonZeroI8::cmp</source>
          <target state="translated">NonZeroI8::cmp</target>
        </trans-unit>
        <trans-unit id="cdfffa6f6db5c090ca460987b1da2d174ad3dd70" translate="yes" xml:space="preserve">
          <source>NonZeroI8::eq</source>
          <target state="translated">NonZeroI8::eq</target>
        </trans-unit>
        <trans-unit id="303fe1ff3066af96ac1869cf4c4fcfeeee433dc7" translate="yes" xml:space="preserve">
          <source>NonZeroI8::fmt</source>
          <target state="translated">NonZeroI8::fmt</target>
        </trans-unit>
        <trans-unit id="77bf7d94ae999f9b201e336425c9ca11763912ae" translate="yes" xml:space="preserve">
          <source>NonZeroI8::from</source>
          <target state="translated">NonZeroI8::from</target>
        </trans-unit>
        <trans-unit id="058ab838a9faa626f87b01a68a1ab8af9ceffa5e" translate="yes" xml:space="preserve">
          <source>NonZeroI8::from_str</source>
          <target state="translated">NonZeroI8::from_str</target>
        </trans-unit>
        <trans-unit id="5ffec8af45e4b9e098c857beafee4bb4710502df" translate="yes" xml:space="preserve">
          <source>NonZeroI8::ge</source>
          <target state="translated">NonZeroI8::ge</target>
        </trans-unit>
        <trans-unit id="39931bb71d49054bdf1fb8e4a5d156766e03a349" translate="yes" xml:space="preserve">
          <source>NonZeroI8::get</source>
          <target state="translated">NonZeroI8::get</target>
        </trans-unit>
        <trans-unit id="47babee6888e0103956b5d6fb324645bab23db7a" translate="yes" xml:space="preserve">
          <source>NonZeroI8::gt</source>
          <target state="translated">NonZeroI8::gt</target>
        </trans-unit>
        <trans-unit id="93874d53399c77a41bf9531800d5f0fa474a4cda" translate="yes" xml:space="preserve">
          <source>NonZeroI8::hash</source>
          <target state="translated">NonZeroI8::hash</target>
        </trans-unit>
        <trans-unit id="29013108ddf40e18600983e97e9034bd5257369c" translate="yes" xml:space="preserve">
          <source>NonZeroI8::hash_slice</source>
          <target state="translated">NonZeroI8::hash_slice</target>
        </trans-unit>
        <trans-unit id="037dc348d54512f4eac4bc525c27d1f766b25a1a" translate="yes" xml:space="preserve">
          <source>NonZeroI8::into</source>
          <target state="translated">NonZeroI8::into</target>
        </trans-unit>
        <trans-unit id="0515501fa1d050e6a321477214d1c4d9c56b0a91" translate="yes" xml:space="preserve">
          <source>NonZeroI8::le</source>
          <target state="translated">NonZeroI8::le</target>
        </trans-unit>
        <trans-unit id="7cad17cf5fce8924f80e26fc0cc84eaa9e833005" translate="yes" xml:space="preserve">
          <source>NonZeroI8::lt</source>
          <target state="translated">NonZeroI8::lt</target>
        </trans-unit>
        <trans-unit id="90330e65e0da907071c3c4c3d6a116bb84c932c4" translate="yes" xml:space="preserve">
          <source>NonZeroI8::max</source>
          <target state="translated">NonZeroI8::max</target>
        </trans-unit>
        <trans-unit id="e20ad8db00b5d962f11dd424a9bc3a6c8e774305" translate="yes" xml:space="preserve">
          <source>NonZeroI8::min</source>
          <target state="translated">NonZeroI8::min</target>
        </trans-unit>
        <trans-unit id="73e8e9fd3f901d81ee2336d6e8ea9cf220fba88b" translate="yes" xml:space="preserve">
          <source>NonZeroI8::ne</source>
          <target state="translated">NonZeroI8::ne</target>
        </trans-unit>
        <trans-unit id="af45d6c29f79e266eb5d7ab85309f358f8208a69" translate="yes" xml:space="preserve">
          <source>NonZeroI8::new</source>
          <target state="translated">NonZeroI8::new</target>
        </trans-unit>
        <trans-unit id="81a02f698c1e4f2332bb4e3e7c3edf4ff27a1c50" translate="yes" xml:space="preserve">
          <source>NonZeroI8::new_unchecked</source>
          <target state="translated">NonZeroI8::new_unchecked</target>
        </trans-unit>
        <trans-unit id="2686fbb343af79a855c02e59fa60522e101b42ae" translate="yes" xml:space="preserve">
          <source>NonZeroI8::partial_cmp</source>
          <target state="translated">NonZeroI8::partial_cmp</target>
        </trans-unit>
        <trans-unit id="cd75ff5beac899fb4e419778f9513cbe1ad0b2a5" translate="yes" xml:space="preserve">
          <source>NonZeroI8::to_owned</source>
          <target state="translated">NonZeroI8::to_owned</target>
        </trans-unit>
        <trans-unit id="2b4fc6493819df1f404760f50612536b8bbfc7bd" translate="yes" xml:space="preserve">
          <source>NonZeroI8::to_string</source>
          <target state="translated">NonZeroI8::to_string</target>
        </trans-unit>
        <trans-unit id="44995331a911be947ba3e877e13ce380ef4d9378" translate="yes" xml:space="preserve">
          <source>NonZeroI8::try_from</source>
          <target state="translated">NonZeroI8::try_from</target>
        </trans-unit>
        <trans-unit id="c6edd8a860f42d4c84935088ebf51ade98d95115" translate="yes" xml:space="preserve">
          <source>NonZeroI8::try_into</source>
          <target state="translated">NonZeroI8::try_into</target>
        </trans-unit>
        <trans-unit id="694926ab4cd6b261f66a7c4ea43bd5a538ca07a5" translate="yes" xml:space="preserve">
          <source>NonZeroI8::type_id</source>
          <target state="translated">NonZeroI8::type_id</target>
        </trans-unit>
        <trans-unit id="39eb2a5ae94e10b055d94f86300fae4bd3a2c861" translate="yes" xml:space="preserve">
          <source>NonZeroIsize</source>
          <target state="translated">NonZeroIsize</target>
        </trans-unit>
        <trans-unit id="4075b4a43affee6576128660a15087ef7d46f01c" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::borrow</source>
          <target state="translated">NonZeroIsize::borrow</target>
        </trans-unit>
        <trans-unit id="ec545959e67fee5329d2293a10abf7982b0e5d27" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::borrow_mut</source>
          <target state="translated">NonZeroIsize::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a61bacb1affb3b3a864b9054448b3c878abd8923" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::clamp</source>
          <target state="translated">NonZeroIsize::clamp</target>
        </trans-unit>
        <trans-unit id="191e1ee11e03e2904eddf99c3224190191357bac" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::clone</source>
          <target state="translated">NonZeroIsize::clone</target>
        </trans-unit>
        <trans-unit id="5dc48b7609417f7ce614e10e63d58e556492bcf9" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::clone_from</source>
          <target state="translated">NonZeroIsize::clone_from</target>
        </trans-unit>
        <trans-unit id="d38a3dead1294ded03ccb72c57ad049cf009cb60" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::clone_into</source>
          <target state="translated">NonZeroIsize::clone_into</target>
        </trans-unit>
        <trans-unit id="ca7ed6d7cb5393e8a7ba6e95fd43e5b4d5bb7809" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::cmp</source>
          <target state="translated">NonZeroIsize::cmp</target>
        </trans-unit>
        <trans-unit id="2fe615f032ce982861bba71b45a232958641a0cd" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::eq</source>
          <target state="translated">NonZeroIsize::eq</target>
        </trans-unit>
        <trans-unit id="d9ec29b8a341c99081d89a3bd91dc15ff5f6812f" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::fmt</source>
          <target state="translated">NonZeroIsize::fmt</target>
        </trans-unit>
        <trans-unit id="817a465d80d81fe1b61c88aca0859799182b0ced" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::from</source>
          <target state="translated">NonZeroIsize::from</target>
        </trans-unit>
        <trans-unit id="d2cfcb21d317b6fab455622f5d899c19b4caab20" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::from_str</source>
          <target state="translated">NonZeroIsize::from_str</target>
        </trans-unit>
        <trans-unit id="955b4cb4cf6dd3e94857ccb753d3fe4d1fb111bb" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::ge</source>
          <target state="translated">NonZeroIsize::ge</target>
        </trans-unit>
        <trans-unit id="94dfb4eb2acf5d4199e2494aa3141f234b7ec552" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::get</source>
          <target state="translated">NonZeroIsize::get</target>
        </trans-unit>
        <trans-unit id="ee800c8db94226df90984d0310a1c3b583e90f13" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::gt</source>
          <target state="translated">NonZeroIsize::gt</target>
        </trans-unit>
        <trans-unit id="36fffe56efef4816a331398e4562a265e92bfb10" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::hash</source>
          <target state="translated">NonZeroIsize::hash</target>
        </trans-unit>
        <trans-unit id="cf00fd8ca399a52d34e9a8feac17a1b26fe0bcee" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::hash_slice</source>
          <target state="translated">NonZeroIsize::hash_slice</target>
        </trans-unit>
        <trans-unit id="882f34faf603e4c98fc372332977f902076ab5a0" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::into</source>
          <target state="translated">NonZeroIsize::into</target>
        </trans-unit>
        <trans-unit id="0d24785358cfb27caebb3a32bf5c7678cb2e30ee" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::le</source>
          <target state="translated">NonZeroIsize::le</target>
        </trans-unit>
        <trans-unit id="f8f7c7c85f4aab3786722bfd2d7aefb8b686bd6e" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::lt</source>
          <target state="translated">NonZeroIsize::lt</target>
        </trans-unit>
        <trans-unit id="19c94dc6fa11f95d35e7c7c4f115e86acb80fc00" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::max</source>
          <target state="translated">NonZeroIsize::max</target>
        </trans-unit>
        <trans-unit id="9bf079159116a040501bb2bee238b98de390d6b7" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::min</source>
          <target state="translated">NonZeroIsize::min</target>
        </trans-unit>
        <trans-unit id="78420580500ef47e7d9c63e510686240542d08c3" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::ne</source>
          <target state="translated">NonZeroIsize::ne</target>
        </trans-unit>
        <trans-unit id="9b5caea647537e28a582a1b68216f403a92bdea7" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::new</source>
          <target state="translated">NonZeroIsize::new</target>
        </trans-unit>
        <trans-unit id="f92bdba42fa66b6909fc4ad5b38b7d0a8808cced" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::new_unchecked</source>
          <target state="translated">NonZeroIsize::new_unchecked</target>
        </trans-unit>
        <trans-unit id="2b55347d5d71b451caf945bb5b1b4cacc28afc98" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::partial_cmp</source>
          <target state="translated">NonZeroIsize::partial_cmp</target>
        </trans-unit>
        <trans-unit id="717d7fcf3dd2db66a5b657bdcd5df3b72e3ca14d" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::to_owned</source>
          <target state="translated">NonZeroIsize::to_owned</target>
        </trans-unit>
        <trans-unit id="1a88ee49d5b8865561ef951ccbe17add31975cf3" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::to_string</source>
          <target state="translated">NonZeroIsize::to_string</target>
        </trans-unit>
        <trans-unit id="aeed335ba630cd0f02972d3792f625986e0da579" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::try_from</source>
          <target state="translated">NonZeroIsize::try_from</target>
        </trans-unit>
        <trans-unit id="3b703381eaac2b4d7c2b865c4b56d5e07385cb0d" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::try_into</source>
          <target state="translated">NonZeroIsize::try_into</target>
        </trans-unit>
        <trans-unit id="cfd236d892fc65a9056aca980b3c2a0c1b08fc90" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::type_id</source>
          <target state="translated">NonZeroIsize::type_id</target>
        </trans-unit>
        <trans-unit id="0044d6a252510995bf93ecb1dd199ad6280b0298" translate="yes" xml:space="preserve">
          <source>NonZeroU128</source>
          <target state="translated">NonZeroU128</target>
        </trans-unit>
        <trans-unit id="d33cdcef0f6bce3ae4d1c100820f29fb8e8de6be" translate="yes" xml:space="preserve">
          <source>NonZeroU128::borrow</source>
          <target state="translated">NonZeroU128::borrow</target>
        </trans-unit>
        <trans-unit id="3f647fdd084e34cb19c62fa95a5df0d0b02f7830" translate="yes" xml:space="preserve">
          <source>NonZeroU128::borrow_mut</source>
          <target state="translated">NonZeroU128::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6dd84c262632c4ce99cd20fd6d4cce46ad766f6c" translate="yes" xml:space="preserve">
          <source>NonZeroU128::clamp</source>
          <target state="translated">NonZeroU128::clamp</target>
        </trans-unit>
        <trans-unit id="54a6620faedc0c0d7296506b17b24167c833f343" translate="yes" xml:space="preserve">
          <source>NonZeroU128::clone</source>
          <target state="translated">NonZeroU128::clone</target>
        </trans-unit>
        <trans-unit id="361f908936891415e62dbb126d73b91cdd535809" translate="yes" xml:space="preserve">
          <source>NonZeroU128::clone_from</source>
          <target state="translated">NonZeroU128::clone_from</target>
        </trans-unit>
        <trans-unit id="95b289a7b3408284866f730f49c7cefc4940ea32" translate="yes" xml:space="preserve">
          <source>NonZeroU128::clone_into</source>
          <target state="translated">NonZeroU128::clone_into</target>
        </trans-unit>
        <trans-unit id="939d6fc64a58c3aad5a29fd29b5cb1ddf18ffa03" translate="yes" xml:space="preserve">
          <source>NonZeroU128::cmp</source>
          <target state="translated">NonZeroU128::cmp</target>
        </trans-unit>
        <trans-unit id="e3d76ecf73e9d2bddfdc690dd3583c65cb4e8c6b" translate="yes" xml:space="preserve">
          <source>NonZeroU128::eq</source>
          <target state="translated">NonZeroU128::eq</target>
        </trans-unit>
        <trans-unit id="cf1f402d3b803071978d5c02ef20145ad5e75f93" translate="yes" xml:space="preserve">
          <source>NonZeroU128::fmt</source>
          <target state="translated">NonZeroU128::fmt</target>
        </trans-unit>
        <trans-unit id="1cb47e3de5cf28c31000e229db50c161ce7a7c28" translate="yes" xml:space="preserve">
          <source>NonZeroU128::from</source>
          <target state="translated">NonZeroU128::from</target>
        </trans-unit>
        <trans-unit id="04a3a610d61c54fe04e5c4fb7dc3736c9608563d" translate="yes" xml:space="preserve">
          <source>NonZeroU128::from_str</source>
          <target state="translated">NonZeroU128::from_str</target>
        </trans-unit>
        <trans-unit id="b8dacf31071a7dcf6913c1d5f60e1467a0c7b52c" translate="yes" xml:space="preserve">
          <source>NonZeroU128::ge</source>
          <target state="translated">NonZeroU128::ge</target>
        </trans-unit>
        <trans-unit id="bc070e9b4c11812f956c2c3942dbeeb60e1907d7" translate="yes" xml:space="preserve">
          <source>NonZeroU128::get</source>
          <target state="translated">NonZeroU128::get</target>
        </trans-unit>
        <trans-unit id="bf61b92a5979f684a74d24d35e7223a980f74915" translate="yes" xml:space="preserve">
          <source>NonZeroU128::gt</source>
          <target state="translated">NonZeroU128::gt</target>
        </trans-unit>
        <trans-unit id="66888226d70c2e49258374545510affc0bdd95ec" translate="yes" xml:space="preserve">
          <source>NonZeroU128::hash</source>
          <target state="translated">NonZeroU128::hash</target>
        </trans-unit>
        <trans-unit id="11f423a193c168fdc5ff7611f300ac57dfd70171" translate="yes" xml:space="preserve">
          <source>NonZeroU128::hash_slice</source>
          <target state="translated">NonZeroU128::hash_slice</target>
        </trans-unit>
        <trans-unit id="b29bc2e8eba682c97ef473e0bd889b9b87439b43" translate="yes" xml:space="preserve">
          <source>NonZeroU128::into</source>
          <target state="translated">NonZeroU128::into</target>
        </trans-unit>
        <trans-unit id="dd97daae9ce7a0b9ab85c6cf73bd03826d2dacad" translate="yes" xml:space="preserve">
          <source>NonZeroU128::le</source>
          <target state="translated">NonZeroU128::le</target>
        </trans-unit>
        <trans-unit id="4c5ffedb155e243e75eb535bd12d40831e3c5755" translate="yes" xml:space="preserve">
          <source>NonZeroU128::lt</source>
          <target state="translated">NonZeroU128::lt</target>
        </trans-unit>
        <trans-unit id="cefe09ff65521779b9f59c83b8f0425d577bc41f" translate="yes" xml:space="preserve">
          <source>NonZeroU128::max</source>
          <target state="translated">NonZeroU128::max</target>
        </trans-unit>
        <trans-unit id="66bc9dddfd54e67077a2f3098f5b87831d049d31" translate="yes" xml:space="preserve">
          <source>NonZeroU128::min</source>
          <target state="translated">NonZeroU128::min</target>
        </trans-unit>
        <trans-unit id="1af4ac1a95b7f36c718aa21d748fb13ce2e824ee" translate="yes" xml:space="preserve">
          <source>NonZeroU128::ne</source>
          <target state="translated">NonZeroU128::ne</target>
        </trans-unit>
        <trans-unit id="774e6ffc8823e6223f1ffa87fab102416ea1637d" translate="yes" xml:space="preserve">
          <source>NonZeroU128::new</source>
          <target state="translated">NonZeroU128::new</target>
        </trans-unit>
        <trans-unit id="80588590ec2ef5a265edf292dba20ca05ed9ff1d" translate="yes" xml:space="preserve">
          <source>NonZeroU128::new_unchecked</source>
          <target state="translated">NonZeroU128::new_unchecked</target>
        </trans-unit>
        <trans-unit id="4f33be7cbf8c678c8187f371f4f5d027a69d0647" translate="yes" xml:space="preserve">
          <source>NonZeroU128::partial_cmp</source>
          <target state="translated">NonZeroU128::partial_cmp</target>
        </trans-unit>
        <trans-unit id="3dea4243dcea470ba4d4f180f81f6eecca14e04e" translate="yes" xml:space="preserve">
          <source>NonZeroU128::to_owned</source>
          <target state="translated">NonZeroU128::to_owned</target>
        </trans-unit>
        <trans-unit id="24acde94eff6342ff2fba2e9d267a2fdb25acd94" translate="yes" xml:space="preserve">
          <source>NonZeroU128::to_string</source>
          <target state="translated">NonZeroU128::to_string</target>
        </trans-unit>
        <trans-unit id="b21ef37ea8ca3269318a2c852c86163df43432be" translate="yes" xml:space="preserve">
          <source>NonZeroU128::try_from</source>
          <target state="translated">NonZeroU128::try_from</target>
        </trans-unit>
        <trans-unit id="6c546400526ea1ed6ea89201862535a6549699f1" translate="yes" xml:space="preserve">
          <source>NonZeroU128::try_into</source>
          <target state="translated">NonZeroU128::try_into</target>
        </trans-unit>
        <trans-unit id="5b4b31430f7adfc4f26872a558ae35d43d7da9ff" translate="yes" xml:space="preserve">
          <source>NonZeroU128::type_id</source>
          <target state="translated">NonZeroU128::type_id</target>
        </trans-unit>
        <trans-unit id="70d9b595abe5e850f484266bc477e3d70b58c790" translate="yes" xml:space="preserve">
          <source>NonZeroU16</source>
          <target state="translated">NonZeroU16</target>
        </trans-unit>
        <trans-unit id="a2e830bdc612e459ecbf94a5d900db9adf22d552" translate="yes" xml:space="preserve">
          <source>NonZeroU16::borrow</source>
          <target state="translated">NonZeroU16::borrow</target>
        </trans-unit>
        <trans-unit id="84a81450427618c9efd99c6046bdcfcb15a8f7bb" translate="yes" xml:space="preserve">
          <source>NonZeroU16::borrow_mut</source>
          <target state="translated">NonZeroU16::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4eb94e8343ecdde314f21ae1472878c2e5be4f43" translate="yes" xml:space="preserve">
          <source>NonZeroU16::clamp</source>
          <target state="translated">NonZeroU16::clamp</target>
        </trans-unit>
        <trans-unit id="4f9cad5198a59312536b10433f5195716121d4f5" translate="yes" xml:space="preserve">
          <source>NonZeroU16::clone</source>
          <target state="translated">NonZeroU16::clone</target>
        </trans-unit>
        <trans-unit id="d8ef4ec4d957a02aaa882335c6f3d0a67035a3c7" translate="yes" xml:space="preserve">
          <source>NonZeroU16::clone_from</source>
          <target state="translated">NonZeroU16::clone_from</target>
        </trans-unit>
        <trans-unit id="3808aec2130dc48a153e5a520294b26744b3e702" translate="yes" xml:space="preserve">
          <source>NonZeroU16::clone_into</source>
          <target state="translated">NonZeroU16::clone_into</target>
        </trans-unit>
        <trans-unit id="9d0062487248621e89b96fe5bf643abe821bb17a" translate="yes" xml:space="preserve">
          <source>NonZeroU16::cmp</source>
          <target state="translated">NonZeroU16::cmp</target>
        </trans-unit>
        <trans-unit id="41a2d5bd4797b2d1eb6b20161786347a9f0dd370" translate="yes" xml:space="preserve">
          <source>NonZeroU16::eq</source>
          <target state="translated">NonZeroU16::eq</target>
        </trans-unit>
        <trans-unit id="4e58083d69fb5df5404d73e024559cb858948a6f" translate="yes" xml:space="preserve">
          <source>NonZeroU16::fmt</source>
          <target state="translated">NonZeroU16::fmt</target>
        </trans-unit>
        <trans-unit id="f40fdab8202fbcb58f6fbdbc2b16303b0de2f1ee" translate="yes" xml:space="preserve">
          <source>NonZeroU16::from</source>
          <target state="translated">NonZeroU16::from</target>
        </trans-unit>
        <trans-unit id="97bb49319fe5098129502422bda785cd16c5234a" translate="yes" xml:space="preserve">
          <source>NonZeroU16::from_str</source>
          <target state="translated">NonZeroU16::from_str</target>
        </trans-unit>
        <trans-unit id="12e676e778fbbdbfffb5d2b98fabd5a4306c10e5" translate="yes" xml:space="preserve">
          <source>NonZeroU16::ge</source>
          <target state="translated">NonZeroU16::ge</target>
        </trans-unit>
        <trans-unit id="1313691aadbfef04a5d2c70132da7c9072b9834a" translate="yes" xml:space="preserve">
          <source>NonZeroU16::get</source>
          <target state="translated">NonZeroU16::get</target>
        </trans-unit>
        <trans-unit id="e4a7103dfe5dfdaccf5405172a6bfb6564cbb39e" translate="yes" xml:space="preserve">
          <source>NonZeroU16::gt</source>
          <target state="translated">NonZeroU16::gt</target>
        </trans-unit>
        <trans-unit id="4843257888dce95e20cf1eaff515263fe997bf35" translate="yes" xml:space="preserve">
          <source>NonZeroU16::hash</source>
          <target state="translated">NonZeroU16::hash</target>
        </trans-unit>
        <trans-unit id="b9c900dd5aa52134650740a33c407b05339dc782" translate="yes" xml:space="preserve">
          <source>NonZeroU16::hash_slice</source>
          <target state="translated">NonZeroU16::hash_slice</target>
        </trans-unit>
        <trans-unit id="83aabdee7d487ec9cb728178e573f802394226b4" translate="yes" xml:space="preserve">
          <source>NonZeroU16::into</source>
          <target state="translated">NonZeroU16::into</target>
        </trans-unit>
        <trans-unit id="7970d0eb118d83ab0b72df82542034727ba2a453" translate="yes" xml:space="preserve">
          <source>NonZeroU16::le</source>
          <target state="translated">NonZeroU16::le</target>
        </trans-unit>
        <trans-unit id="2e5e858925d50659f9b1b6d9aae3740085d6d25b" translate="yes" xml:space="preserve">
          <source>NonZeroU16::lt</source>
          <target state="translated">NonZeroU16::lt</target>
        </trans-unit>
        <trans-unit id="5d3b1652b96c8f150360a583d2605f47b1963560" translate="yes" xml:space="preserve">
          <source>NonZeroU16::max</source>
          <target state="translated">NonZeroU16::max</target>
        </trans-unit>
        <trans-unit id="1e4034b09df30190832a52072bcf8af6041bbf4d" translate="yes" xml:space="preserve">
          <source>NonZeroU16::min</source>
          <target state="translated">NonZeroU16::min</target>
        </trans-unit>
        <trans-unit id="815e8d53bff937d8e0463d3319f42f6179bc0760" translate="yes" xml:space="preserve">
          <source>NonZeroU16::ne</source>
          <target state="translated">NonZeroU16::ne</target>
        </trans-unit>
        <trans-unit id="23ac83515dc8fab41df4280bc33fe4bc456b4ff2" translate="yes" xml:space="preserve">
          <source>NonZeroU16::new</source>
          <target state="translated">NonZeroU16::new</target>
        </trans-unit>
        <trans-unit id="bb140336d169ad21d933a68a3d8746b26d1b8b72" translate="yes" xml:space="preserve">
          <source>NonZeroU16::new_unchecked</source>
          <target state="translated">NonZeroU16::new_unchecked</target>
        </trans-unit>
        <trans-unit id="d8dd3cac934926e6de446e12a7408c3a4890b68e" translate="yes" xml:space="preserve">
          <source>NonZeroU16::partial_cmp</source>
          <target state="translated">NonZeroU16::partial_cmp</target>
        </trans-unit>
        <trans-unit id="93b1877253643b0a75cda9a47fc455fc67b284f7" translate="yes" xml:space="preserve">
          <source>NonZeroU16::to_owned</source>
          <target state="translated">NonZeroU16::to_owned</target>
        </trans-unit>
        <trans-unit id="450d0b2017abf1787e4b40c9180053f5f1c5d6b5" translate="yes" xml:space="preserve">
          <source>NonZeroU16::to_string</source>
          <target state="translated">NonZeroU16::to_string</target>
        </trans-unit>
        <trans-unit id="565d7bfa4f368119e8eb8c597666eee168d3ec36" translate="yes" xml:space="preserve">
          <source>NonZeroU16::try_from</source>
          <target state="translated">NonZeroU16::try_from</target>
        </trans-unit>
        <trans-unit id="c9ffda0c65ec9d2c6dac8e1259fd7cb09818b7a4" translate="yes" xml:space="preserve">
          <source>NonZeroU16::try_into</source>
          <target state="translated">NonZeroU16::try_into</target>
        </trans-unit>
        <trans-unit id="35a3919e55cf0455983744e7e8ab659cda957d3b" translate="yes" xml:space="preserve">
          <source>NonZeroU16::type_id</source>
          <target state="translated">NonZeroU16::type_id</target>
        </trans-unit>
        <trans-unit id="027b94edf209f9b339fcc3f9fcbe95bea73b0fff" translate="yes" xml:space="preserve">
          <source>NonZeroU32</source>
          <target state="translated">NonZeroU32</target>
        </trans-unit>
        <trans-unit id="19103157b2dd994e271093d37a26558f253c1df5" translate="yes" xml:space="preserve">
          <source>NonZeroU32::borrow</source>
          <target state="translated">NonZeroU32::borrow</target>
        </trans-unit>
        <trans-unit id="d5900a35010072cf8f8a0e31e3295500e147138f" translate="yes" xml:space="preserve">
          <source>NonZeroU32::borrow_mut</source>
          <target state="translated">NonZeroU32::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a3d0eea5bcf469a951789307713538f7dd48cc64" translate="yes" xml:space="preserve">
          <source>NonZeroU32::clamp</source>
          <target state="translated">NonZeroU32::clamp</target>
        </trans-unit>
        <trans-unit id="ca9c328d071b73e6fec77d280d2dec16c6afe8be" translate="yes" xml:space="preserve">
          <source>NonZeroU32::clone</source>
          <target state="translated">NonZeroU32::clone</target>
        </trans-unit>
        <trans-unit id="4d0cce4f0af9fe9b58667070ea3aae8608af18fc" translate="yes" xml:space="preserve">
          <source>NonZeroU32::clone_from</source>
          <target state="translated">NonZeroU32::clone_from</target>
        </trans-unit>
        <trans-unit id="beeb1f8a7db4e17dce219e3b75ed85a27a214ce6" translate="yes" xml:space="preserve">
          <source>NonZeroU32::clone_into</source>
          <target state="translated">NonZeroU32::clone_into</target>
        </trans-unit>
        <trans-unit id="66de3d60d49a5fd2460c7fce4fc4af569dea2ea8" translate="yes" xml:space="preserve">
          <source>NonZeroU32::cmp</source>
          <target state="translated">NonZeroU32::cmp</target>
        </trans-unit>
        <trans-unit id="b9a64d225fbd880a1d363e7928600204954c435d" translate="yes" xml:space="preserve">
          <source>NonZeroU32::eq</source>
          <target state="translated">NonZeroU32::eq</target>
        </trans-unit>
        <trans-unit id="d198043d6e6b2dcbdbd140d6e9a9832d41ef00b0" translate="yes" xml:space="preserve">
          <source>NonZeroU32::fmt</source>
          <target state="translated">NonZeroU32::fmt</target>
        </trans-unit>
        <trans-unit id="f99dcfdc314e32f70a453660a94f7ab9fd67185e" translate="yes" xml:space="preserve">
          <source>NonZeroU32::from</source>
          <target state="translated">NonZeroU32::from</target>
        </trans-unit>
        <trans-unit id="298799838c58c16143fcd9e2418534b329517ba2" translate="yes" xml:space="preserve">
          <source>NonZeroU32::from_str</source>
          <target state="translated">NonZeroU32::from_str</target>
        </trans-unit>
        <trans-unit id="6cd1cc0b365f1d3d480575dcbc2de54dae6a1d17" translate="yes" xml:space="preserve">
          <source>NonZeroU32::ge</source>
          <target state="translated">NonZeroU32::ge</target>
        </trans-unit>
        <trans-unit id="1dbe40ea77f784440de6e51cfcfb8778482bc067" translate="yes" xml:space="preserve">
          <source>NonZeroU32::get</source>
          <target state="translated">NonZeroU32::get</target>
        </trans-unit>
        <trans-unit id="e88628f83bc918c532752959c92d4ac82adbf0fd" translate="yes" xml:space="preserve">
          <source>NonZeroU32::gt</source>
          <target state="translated">NonZeroU32::gt</target>
        </trans-unit>
        <trans-unit id="7104f6c9a14d29e93513632fa9934f8edd1d6e95" translate="yes" xml:space="preserve">
          <source>NonZeroU32::hash</source>
          <target state="translated">NonZeroU32::hash</target>
        </trans-unit>
        <trans-unit id="ed57c71253659bc0210251e89d76fbd4f29b25de" translate="yes" xml:space="preserve">
          <source>NonZeroU32::hash_slice</source>
          <target state="translated">NonZeroU32::hash_slice</target>
        </trans-unit>
        <trans-unit id="708299fe453aae6d855b8d5980451e3d6fa01e3f" translate="yes" xml:space="preserve">
          <source>NonZeroU32::into</source>
          <target state="translated">NonZeroU32::into</target>
        </trans-unit>
        <trans-unit id="18cade9c6a5784c63e5e9e3cd947c01187616ffa" translate="yes" xml:space="preserve">
          <source>NonZeroU32::le</source>
          <target state="translated">NonZeroU32::le</target>
        </trans-unit>
        <trans-unit id="258acfab28050bc7bb168cbfd4ef30a6d48665c5" translate="yes" xml:space="preserve">
          <source>NonZeroU32::lt</source>
          <target state="translated">NonZeroU32::lt</target>
        </trans-unit>
        <trans-unit id="030aea2e6963a8f4da13cbc262733cb19ce4afc3" translate="yes" xml:space="preserve">
          <source>NonZeroU32::max</source>
          <target state="translated">NonZeroU32::max</target>
        </trans-unit>
        <trans-unit id="ec7f1e7d4f631759d2fa095faa8ca43552f8684a" translate="yes" xml:space="preserve">
          <source>NonZeroU32::min</source>
          <target state="translated">NonZeroU32::min</target>
        </trans-unit>
        <trans-unit id="1339b30fe6c5981bffbab3f00e68cdd9c9f8a0bc" translate="yes" xml:space="preserve">
          <source>NonZeroU32::ne</source>
          <target state="translated">NonZeroU32::ne</target>
        </trans-unit>
        <trans-unit id="0d42ac2122a8ce6e542130048262c73787d65cfa" translate="yes" xml:space="preserve">
          <source>NonZeroU32::new</source>
          <target state="translated">NonZeroU32::new</target>
        </trans-unit>
        <trans-unit id="53b766be632e74846603297c0e0ac6f9ccfdb9cc" translate="yes" xml:space="preserve">
          <source>NonZeroU32::new_unchecked</source>
          <target state="translated">NonZeroU32::new_unchecked</target>
        </trans-unit>
        <trans-unit id="8d058b61ea076257a2a74125c037a43db242bed9" translate="yes" xml:space="preserve">
          <source>NonZeroU32::partial_cmp</source>
          <target state="translated">NonZeroU32::partial_cmp</target>
        </trans-unit>
        <trans-unit id="daeb2592a753cbd5361feb58a583b78797b11fc9" translate="yes" xml:space="preserve">
          <source>NonZeroU32::to_owned</source>
          <target state="translated">NonZeroU32::to_owned</target>
        </trans-unit>
        <trans-unit id="60aaf34cff920dc42256dc10eec23c5ea806feec" translate="yes" xml:space="preserve">
          <source>NonZeroU32::to_string</source>
          <target state="translated">NonZeroU32::to_string</target>
        </trans-unit>
        <trans-unit id="73f9e4f2ad5073070910a47ac63d54b649f8d6e8" translate="yes" xml:space="preserve">
          <source>NonZeroU32::try_from</source>
          <target state="translated">NonZeroU32::try_from</target>
        </trans-unit>
        <trans-unit id="63d1c4723bc8f38b153bb0f2590c96abef27a5d0" translate="yes" xml:space="preserve">
          <source>NonZeroU32::try_into</source>
          <target state="translated">NonZeroU32::try_into</target>
        </trans-unit>
        <trans-unit id="97923d854095a52b24576bacbd79fc9ba83145d4" translate="yes" xml:space="preserve">
          <source>NonZeroU32::type_id</source>
          <target state="translated">NonZeroU32::type_id</target>
        </trans-unit>
        <trans-unit id="ff9af574bd71ecdb8a94e5c11d8cb03c995c903e" translate="yes" xml:space="preserve">
          <source>NonZeroU64</source>
          <target state="translated">NonZeroU64</target>
        </trans-unit>
        <trans-unit id="9174928c781d84aa02c125b176a43aa320ff0a5d" translate="yes" xml:space="preserve">
          <source>NonZeroU64::borrow</source>
          <target state="translated">NonZeroU64::borrow</target>
        </trans-unit>
        <trans-unit id="84bb893e16a6e53a0c100c76ec3f68a95e3e668d" translate="yes" xml:space="preserve">
          <source>NonZeroU64::borrow_mut</source>
          <target state="translated">NonZeroU64::borrow_mut</target>
        </trans-unit>
        <trans-unit id="fcf340d75d4265672f320969bda5046bdb409e81" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clamp</source>
          <target state="translated">NonZeroU64::clamp</target>
        </trans-unit>
        <trans-unit id="183552bd8482c37ff61fe2a742c9ddb1ea0ca355" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clone</source>
          <target state="translated">NonZeroU64::clone</target>
        </trans-unit>
        <trans-unit id="0eb415342585f28f35047e6cd3c2974cdbbe66bd" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clone_from</source>
          <target state="translated">NonZeroU64::clone_from</target>
        </trans-unit>
        <trans-unit id="6ab29e679c166bbe4bda6532e91d9eeb91acad3c" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clone_into</source>
          <target state="translated">NonZeroU64::clone_into</target>
        </trans-unit>
        <trans-unit id="a63a17006148383604de4d3fcb995f84d18aaa77" translate="yes" xml:space="preserve">
          <source>NonZeroU64::cmp</source>
          <target state="translated">NonZeroU64::cmp</target>
        </trans-unit>
        <trans-unit id="9de4084186275b67715c01bdf2631108a20373b3" translate="yes" xml:space="preserve">
          <source>NonZeroU64::eq</source>
          <target state="translated">NonZeroU64::eq</target>
        </trans-unit>
        <trans-unit id="f701376286f75acabb93bc338425e6cae42fdba1" translate="yes" xml:space="preserve">
          <source>NonZeroU64::fmt</source>
          <target state="translated">NonZeroU64::fmt</target>
        </trans-unit>
        <trans-unit id="e6c78a21f2934d9a2da92dd578a35b8157419529" translate="yes" xml:space="preserve">
          <source>NonZeroU64::from</source>
          <target state="translated">NonZeroU64::from</target>
        </trans-unit>
        <trans-unit id="546bd47a252bfe7b85af380602d87da22806650f" translate="yes" xml:space="preserve">
          <source>NonZeroU64::from_str</source>
          <target state="translated">NonZeroU64::from_str</target>
        </trans-unit>
        <trans-unit id="9aadba2a2b721871fd6af482b4623eee945bd2ca" translate="yes" xml:space="preserve">
          <source>NonZeroU64::ge</source>
          <target state="translated">NonZeroU64::ge</target>
        </trans-unit>
        <trans-unit id="23badb59c2bf64bbfd600b89c65d6464f288c34e" translate="yes" xml:space="preserve">
          <source>NonZeroU64::get</source>
          <target state="translated">NonZeroU64::get</target>
        </trans-unit>
        <trans-unit id="70ba0bfc2ee5de3dc8d77e5c800ac26d942aad60" translate="yes" xml:space="preserve">
          <source>NonZeroU64::gt</source>
          <target state="translated">NonZeroU64::gt</target>
        </trans-unit>
        <trans-unit id="1be0d3fa424fa8f1c9033db1563822faa87d86bc" translate="yes" xml:space="preserve">
          <source>NonZeroU64::hash</source>
          <target state="translated">NonZeroU64::hash</target>
        </trans-unit>
        <trans-unit id="9ef89b20cd332d28440efb1ab8c800e464dbc0c5" translate="yes" xml:space="preserve">
          <source>NonZeroU64::hash_slice</source>
          <target state="translated">NonZeroU64::hash_slice</target>
        </trans-unit>
        <trans-unit id="9cf4c75c1bac7fde4346dcdbc35fda963e585282" translate="yes" xml:space="preserve">
          <source>NonZeroU64::into</source>
          <target state="translated">NonZeroU64::into</target>
        </trans-unit>
        <trans-unit id="7376c3fefec318f3031bdc950d6f8f2a3089d974" translate="yes" xml:space="preserve">
          <source>NonZeroU64::le</source>
          <target state="translated">NonZeroU64::le</target>
        </trans-unit>
        <trans-unit id="9c3837210065694f326259c4c009fcf151ab8938" translate="yes" xml:space="preserve">
          <source>NonZeroU64::lt</source>
          <target state="translated">NonZeroU64::lt</target>
        </trans-unit>
        <trans-unit id="e88a4e86bb9a247b011285115d5e4adc34155d05" translate="yes" xml:space="preserve">
          <source>NonZeroU64::max</source>
          <target state="translated">NonZeroU64::max</target>
        </trans-unit>
        <trans-unit id="3ca2447656d5c5bf7e39124b2a8d6630ff253464" translate="yes" xml:space="preserve">
          <source>NonZeroU64::min</source>
          <target state="translated">NonZeroU64::min</target>
        </trans-unit>
        <trans-unit id="bf2706867bfa59da3e12e574c1c7a042c0c7fa0a" translate="yes" xml:space="preserve">
          <source>NonZeroU64::ne</source>
          <target state="translated">NonZeroU64::ne</target>
        </trans-unit>
        <trans-unit id="2fb761a04a1a28848d5bbb8c94562514f64738e6" translate="yes" xml:space="preserve">
          <source>NonZeroU64::new</source>
          <target state="translated">NonZeroU64::new</target>
        </trans-unit>
        <trans-unit id="a84ebe37c16ccdf34c145d075dd2d1ae8e718fd7" translate="yes" xml:space="preserve">
          <source>NonZeroU64::new_unchecked</source>
          <target state="translated">NonZeroU64::new_unchecked</target>
        </trans-unit>
        <trans-unit id="424d3fd0d71ac1783106c5f073cedfafd2433e33" translate="yes" xml:space="preserve">
          <source>NonZeroU64::partial_cmp</source>
          <target state="translated">NonZeroU64::partial_cmp</target>
        </trans-unit>
        <trans-unit id="689c6172e5e5fa7d743f6d9ea54feb2a2c45360e" translate="yes" xml:space="preserve">
          <source>NonZeroU64::to_owned</source>
          <target state="translated">NonZeroU64::to_owned</target>
        </trans-unit>
        <trans-unit id="0f770ca97d17ac208580e4663b1cb35d1585cd0a" translate="yes" xml:space="preserve">
          <source>NonZeroU64::to_string</source>
          <target state="translated">NonZeroU64::to_string</target>
        </trans-unit>
        <trans-unit id="b3edffffa9ccb083ef6dc98f9a91d2ee62a6a140" translate="yes" xml:space="preserve">
          <source>NonZeroU64::try_from</source>
          <target state="translated">NonZeroU64::try_from</target>
        </trans-unit>
        <trans-unit id="2309bbba28296004c54d80642075d1ce6e4cf120" translate="yes" xml:space="preserve">
          <source>NonZeroU64::try_into</source>
          <target state="translated">NonZeroU64::try_into</target>
        </trans-unit>
        <trans-unit id="ddce3cce76f837592f485e87ab5ddde6cfce8cd0" translate="yes" xml:space="preserve">
          <source>NonZeroU64::type_id</source>
          <target state="translated">NonZeroU64::type_id</target>
        </trans-unit>
        <trans-unit id="93acae18872d78f1044f122c7fa386b8e0790d18" translate="yes" xml:space="preserve">
          <source>NonZeroU8</source>
          <target state="translated">NonZeroU8</target>
        </trans-unit>
        <trans-unit id="6ff1a3cea907e661f3495c1cde07624988c92d18" translate="yes" xml:space="preserve">
          <source>NonZeroU8::borrow</source>
          <target state="translated">NonZeroU8::borrow</target>
        </trans-unit>
        <trans-unit id="63abe3b6e90de29270a227a14eb1cd95090ba8b5" translate="yes" xml:space="preserve">
          <source>NonZeroU8::borrow_mut</source>
          <target state="translated">NonZeroU8::borrow_mut</target>
        </trans-unit>
        <trans-unit id="803a11a99b517fd90ac23a43eefbdfca5457f48a" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clamp</source>
          <target state="translated">NonZeroU8::clamp</target>
        </trans-unit>
        <trans-unit id="5c11d86db1fbb6b9b9c0d8f7f4a28a4bf6afbb24" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clone</source>
          <target state="translated">NonZeroU8::clone</target>
        </trans-unit>
        <trans-unit id="670ad8364fc1871b9629299e869bcbacc5da96b2" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clone_from</source>
          <target state="translated">NonZeroU8::clone_from</target>
        </trans-unit>
        <trans-unit id="6c6784a6e074a57a017f865c39fe9469883e2de8" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clone_into</source>
          <target state="translated">NonZeroU8::clone_into</target>
        </trans-unit>
        <trans-unit id="693fb00ea40fa5aabc302b79d7c8e3718e6c8088" translate="yes" xml:space="preserve">
          <source>NonZeroU8::cmp</source>
          <target state="translated">NonZeroU8::cmp</target>
        </trans-unit>
        <trans-unit id="2158bd65bbc659ddb6d6412bd01916cb5d982ed3" translate="yes" xml:space="preserve">
          <source>NonZeroU8::eq</source>
          <target state="translated">NonZeroU8::eq</target>
        </trans-unit>
        <trans-unit id="3c80d10814d815cf1d99f1b13a12df65b0875877" translate="yes" xml:space="preserve">
          <source>NonZeroU8::fmt</source>
          <target state="translated">NonZeroU8::fmt</target>
        </trans-unit>
        <trans-unit id="7deaab84759c8ba54fbc5d91e72a59bd1aeb6577" translate="yes" xml:space="preserve">
          <source>NonZeroU8::from</source>
          <target state="translated">NonZeroU8::from</target>
        </trans-unit>
        <trans-unit id="2756bc8cdd2a9198a79f5cf73b9e1d572f0f1491" translate="yes" xml:space="preserve">
          <source>NonZeroU8::from_str</source>
          <target state="translated">NonZeroU8::from_str</target>
        </trans-unit>
        <trans-unit id="96e3274a26e461fa91c098ddcfa2558cac9c4747" translate="yes" xml:space="preserve">
          <source>NonZeroU8::ge</source>
          <target state="translated">NonZeroU8::ge</target>
        </trans-unit>
        <trans-unit id="922117f87c8142145cb8b8abbabb7402b5e2bc53" translate="yes" xml:space="preserve">
          <source>NonZeroU8::get</source>
          <target state="translated">NonZeroU8::get</target>
        </trans-unit>
        <trans-unit id="9d9dcce691d917ac54e2661132eb0950cc45d9a7" translate="yes" xml:space="preserve">
          <source>NonZeroU8::gt</source>
          <target state="translated">NonZeroU8::gt</target>
        </trans-unit>
        <trans-unit id="86ed98098229a654859aa731e5195157190e73cb" translate="yes" xml:space="preserve">
          <source>NonZeroU8::hash</source>
          <target state="translated">NonZeroU8::hash</target>
        </trans-unit>
        <trans-unit id="cb3adb90e777f04027a60a7879f9d135f08d1607" translate="yes" xml:space="preserve">
          <source>NonZeroU8::hash_slice</source>
          <target state="translated">NonZeroU8::hash_slice</target>
        </trans-unit>
        <trans-unit id="b79391b251df236d1d6289790b5260179dbdacc9" translate="yes" xml:space="preserve">
          <source>NonZeroU8::into</source>
          <target state="translated">NonZeroU8::into</target>
        </trans-unit>
        <trans-unit id="349980dfec87decceb14ada089c45ad6b63c099a" translate="yes" xml:space="preserve">
          <source>NonZeroU8::le</source>
          <target state="translated">NonZeroU8::le</target>
        </trans-unit>
        <trans-unit id="d736ad9511ba8ef5fa21ea6939ea1822c7d2dcb0" translate="yes" xml:space="preserve">
          <source>NonZeroU8::lt</source>
          <target state="translated">NonZeroU8::lt</target>
        </trans-unit>
        <trans-unit id="a284bcab69108d0fe7e56d5c4b3448e94a95b9b7" translate="yes" xml:space="preserve">
          <source>NonZeroU8::max</source>
          <target state="translated">NonZeroU8::max</target>
        </trans-unit>
        <trans-unit id="5a9a87bf0c351a8fa498461781bb9417c3bc85f9" translate="yes" xml:space="preserve">
          <source>NonZeroU8::min</source>
          <target state="translated">NonZeroU8::min</target>
        </trans-unit>
        <trans-unit id="950681f0c85136301d4d8bc7bd384530cbe0ad13" translate="yes" xml:space="preserve">
          <source>NonZeroU8::ne</source>
          <target state="translated">NonZeroU8::ne</target>
        </trans-unit>
        <trans-unit id="32bcfbfa6acfd6ddd32e20022619e9223f40a94f" translate="yes" xml:space="preserve">
          <source>NonZeroU8::new</source>
          <target state="translated">NonZeroU8::new</target>
        </trans-unit>
        <trans-unit id="c65bae8471e01bcbc9a0141783aef01900f64a4c" translate="yes" xml:space="preserve">
          <source>NonZeroU8::new_unchecked</source>
          <target state="translated">NonZeroU8::new_unchecked</target>
        </trans-unit>
        <trans-unit id="60e3a745d7919f9cebc4387f60a9049fdd9960a9" translate="yes" xml:space="preserve">
          <source>NonZeroU8::partial_cmp</source>
          <target state="translated">NonZeroU8::partial_cmp</target>
        </trans-unit>
        <trans-unit id="814facf57cfd7397aa0ec4ff5934741dc1504d0a" translate="yes" xml:space="preserve">
          <source>NonZeroU8::to_owned</source>
          <target state="translated">NonZeroU8::to_owned</target>
        </trans-unit>
        <trans-unit id="b5e9e73145a1a10790ac2c4b4ee56c85d1e6f97f" translate="yes" xml:space="preserve">
          <source>NonZeroU8::to_string</source>
          <target state="translated">NonZeroU8::to_string</target>
        </trans-unit>
        <trans-unit id="2b735ce2d45697df8d25226cb8808f268d9dad27" translate="yes" xml:space="preserve">
          <source>NonZeroU8::try_from</source>
          <target state="translated">NonZeroU8::try_from</target>
        </trans-unit>
        <trans-unit id="2b02b5ef9beb40480c74f9952d3ce821f4d69911" translate="yes" xml:space="preserve">
          <source>NonZeroU8::try_into</source>
          <target state="translated">NonZeroU8::try_into</target>
        </trans-unit>
        <trans-unit id="8c0fc32ec166f66886b38f57ea7d3cb7a7835fe2" translate="yes" xml:space="preserve">
          <source>NonZeroU8::type_id</source>
          <target state="translated">NonZeroU8::type_id</target>
        </trans-unit>
        <trans-unit id="b35788d3f6ffc592ab0774878cef29486e7e5bd4" translate="yes" xml:space="preserve">
          <source>NonZeroUsize</source>
          <target state="translated">NonZeroUsize</target>
        </trans-unit>
        <trans-unit id="c419d78f65ceafa9adf9a16c8a0459bf66be0bb0" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::borrow</source>
          <target state="translated">NonZeroUsize::borrow</target>
        </trans-unit>
        <trans-unit id="c7ac97a8de687d7597163c213da2788ada2700d7" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::borrow_mut</source>
          <target state="translated">NonZeroUsize::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d423dc3c41f93a9c06c0e4ce6ae7fc621e805056" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clamp</source>
          <target state="translated">NonZeroUsize::clamp</target>
        </trans-unit>
        <trans-unit id="47e7faa665db9da3adc8893ed9e5dcaa815fe4b2" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clone</source>
          <target state="translated">NonZeroUsize::clone</target>
        </trans-unit>
        <trans-unit id="cb938c36bd0b3049477f6ad99f18c0d0ed6bf26f" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clone_from</source>
          <target state="translated">NonZeroUsize::clone_from</target>
        </trans-unit>
        <trans-unit id="030e5620dfbf55afbbfe2d9c96c1e322152959d2" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clone_into</source>
          <target state="translated">NonZeroUsize::clone_into</target>
        </trans-unit>
        <trans-unit id="a38099d022e9104d990e7e4e2d00982504357f0e" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::cmp</source>
          <target state="translated">NonZeroUsize::cmp</target>
        </trans-unit>
        <trans-unit id="57469c189c9f0d01b944369669232584fcab48be" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::eq</source>
          <target state="translated">NonZeroUsize::eq</target>
        </trans-unit>
        <trans-unit id="a3e007978854dfec2ea17781a918799b74afb325" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::fmt</source>
          <target state="translated">NonZeroUsize::fmt</target>
        </trans-unit>
        <trans-unit id="f78a5853c07aa978500a70738e411232664860cc" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::from</source>
          <target state="translated">NonZeroUsize::from</target>
        </trans-unit>
        <trans-unit id="7712061538648151dde34c4415be3b5d61f5877b" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::from_str</source>
          <target state="translated">NonZeroUsize::from_str</target>
        </trans-unit>
        <trans-unit id="f4728f09de22bd70d445970426411f10a0225b43" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::ge</source>
          <target state="translated">NonZeroUsize::ge</target>
        </trans-unit>
        <trans-unit id="b1cdf6cf2409f8c0f48ff7b3ba56ccc5ce5115e9" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::get</source>
          <target state="translated">NonZeroUsize::get</target>
        </trans-unit>
        <trans-unit id="a20bd2dec9d5657f43798c2c990e62953392115c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::gt</source>
          <target state="translated">NonZeroUsize::gt</target>
        </trans-unit>
        <trans-unit id="801d8bc95574bf029e7d684d2cf3f771b60cd725" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::hash</source>
          <target state="translated">NonZeroUsize::hash</target>
        </trans-unit>
        <trans-unit id="6e0922eea57f8699c098adb3c035a1605d38f3df" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::hash_slice</source>
          <target state="translated">NonZeroUsize::hash_slice</target>
        </trans-unit>
        <trans-unit id="fb7586f1fe5330ac7ebbf29da06f142f1a81f679" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::into</source>
          <target state="translated">NonZeroUsize::into</target>
        </trans-unit>
        <trans-unit id="2236d0a73fe65fdff9ad7360c0db597b0672828c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::le</source>
          <target state="translated">NonZeroUsize::le</target>
        </trans-unit>
        <trans-unit id="9347ed4b41dd70587e1703f7c2e07851b56cb2e9" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::lt</source>
          <target state="translated">NonZeroUsize::lt</target>
        </trans-unit>
        <trans-unit id="751ac4d697954b225e6f1616e4b4e0881bb6a41f" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::max</source>
          <target state="translated">NonZeroUsize::max</target>
        </trans-unit>
        <trans-unit id="00f9ea1a8ab80868d5583ca29a5d8f2c152f6d4b" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::min</source>
          <target state="translated">NonZeroUsize::min</target>
        </trans-unit>
        <trans-unit id="a3adc830a3d6e8e1f76b36c1da867853c22f3352" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::ne</source>
          <target state="translated">NonZeroUsize::ne</target>
        </trans-unit>
        <trans-unit id="b482e2411d650436386f31aaaee9d529c27faf6c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::new</source>
          <target state="translated">NonZeroUsize::new</target>
        </trans-unit>
        <trans-unit id="0a63ca14c98c0ba3afecce88c1ee164dbbe678b5" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::new_unchecked</source>
          <target state="translated">NonZeroUsize::new_unchecked</target>
        </trans-unit>
        <trans-unit id="d2e829a9fc8b73a5ec3a806953ba65e782b63e4f" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::partial_cmp</source>
          <target state="translated">NonZeroUsize::partial_cmp</target>
        </trans-unit>
        <trans-unit id="0fc32bf985ee7be65f7708751121df22adec3ee2" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::to_owned</source>
          <target state="translated">NonZeroUsize::to_owned</target>
        </trans-unit>
        <trans-unit id="368109929572f9725530c9b5e66c0770d0254f6c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::to_string</source>
          <target state="translated">NonZeroUsize::to_string</target>
        </trans-unit>
        <trans-unit id="87d57ca9ccbaaeab13b116376180c23efda524d3" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::try_from</source>
          <target state="translated">NonZeroUsize::try_from</target>
        </trans-unit>
        <trans-unit id="f36d6ccda72162b66595cff5afa6abcccb3ef47a" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::try_into</source>
          <target state="translated">NonZeroUsize::try_into</target>
        </trans-unit>
        <trans-unit id="661478a23cc64b875358e2c7f6262c9eb208bcf8" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::type_id</source>
          <target state="translated">NonZeroUsize::type_id</target>
        </trans-unit>
        <trans-unit id="36aa77cbc45a62a558a375b317bc9b3804badfce" translate="yes" xml:space="preserve">
          <source>NoneError</source>
          <target state="translated">NoneError</target>
        </trans-unit>
        <trans-unit id="8def7b12f8f65fd01050dafd05df50f8287c0655" translate="yes" xml:space="preserve">
          <source>NoneError::borrow</source>
          <target state="translated">NoneError::borrow</target>
        </trans-unit>
        <trans-unit id="411f23ffccc2c350e97a02f83bb00bb04a9c1832" translate="yes" xml:space="preserve">
          <source>NoneError::borrow_mut</source>
          <target state="translated">NoneError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a4d6154b1c340d1443c5a20d251329f398af2e11" translate="yes" xml:space="preserve">
          <source>NoneError::clamp</source>
          <target state="translated">NoneError::clamp</target>
        </trans-unit>
        <trans-unit id="555a6fa6139d1928ed4e7fa787af07b254f8f631" translate="yes" xml:space="preserve">
          <source>NoneError::clone</source>
          <target state="translated">NoneError::clone</target>
        </trans-unit>
        <trans-unit id="b7be3f1dfae027d0e36e44675d36fbd402d1e26e" translate="yes" xml:space="preserve">
          <source>NoneError::clone_from</source>
          <target state="translated">NoneError::clone_from</target>
        </trans-unit>
        <trans-unit id="dc67355563b52eb89e32ff38b5504d3dd52d77c9" translate="yes" xml:space="preserve">
          <source>NoneError::clone_into</source>
          <target state="translated">NoneError::clone_into</target>
        </trans-unit>
        <trans-unit id="65e99ec3e2a6e151575264b82499d7f2e38008ff" translate="yes" xml:space="preserve">
          <source>NoneError::cmp</source>
          <target state="translated">NoneError::cmp</target>
        </trans-unit>
        <trans-unit id="0611d16ae0dbf1df9ec05c20e45d31816b7a33e3" translate="yes" xml:space="preserve">
          <source>NoneError::eq</source>
          <target state="translated">NoneError::eq</target>
        </trans-unit>
        <trans-unit id="ddc77b796895a55df93a0b820a464b4aa338d41d" translate="yes" xml:space="preserve">
          <source>NoneError::fmt</source>
          <target state="translated">NoneError::fmt</target>
        </trans-unit>
        <trans-unit id="f69f3c5a7bc9e57ba1c80a5b7f03fced9bacf61f" translate="yes" xml:space="preserve">
          <source>NoneError::from</source>
          <target state="translated">NoneError::from</target>
        </trans-unit>
        <trans-unit id="ea4b13c4f12ac04af5fe2cbffa33fc963c8d5a26" translate="yes" xml:space="preserve">
          <source>NoneError::ge</source>
          <target state="translated">NoneError::ge</target>
        </trans-unit>
        <trans-unit id="80a0b1216e8cf201b9e9391df5c095172374f508" translate="yes" xml:space="preserve">
          <source>NoneError::gt</source>
          <target state="translated">NoneError::gt</target>
        </trans-unit>
        <trans-unit id="3cade823dfb903a695b6582abf8a0356daee7927" translate="yes" xml:space="preserve">
          <source>NoneError::hash</source>
          <target state="translated">NoneError::hash</target>
        </trans-unit>
        <trans-unit id="2c1acaeb04c59b2f4a9a10620721a7a1d4aa42f7" translate="yes" xml:space="preserve">
          <source>NoneError::hash_slice</source>
          <target state="translated">NoneError::hash_slice</target>
        </trans-unit>
        <trans-unit id="46b77ff1d8e23b12f242a6cf68b6e7dd11a9e430" translate="yes" xml:space="preserve">
          <source>NoneError::into</source>
          <target state="translated">NoneError::into</target>
        </trans-unit>
        <trans-unit id="ba9c0b7fd1b90ee18de8e25f5e5340671555fa67" translate="yes" xml:space="preserve">
          <source>NoneError::le</source>
          <target state="translated">NoneError::le</target>
        </trans-unit>
        <trans-unit id="41e697d230de0c7c6e3ccd553c26214e3ef30472" translate="yes" xml:space="preserve">
          <source>NoneError::lt</source>
          <target state="translated">NoneError::lt</target>
        </trans-unit>
        <trans-unit id="02bc1b16e164540afd825f0ab014879760deedcf" translate="yes" xml:space="preserve">
          <source>NoneError::max</source>
          <target state="translated">NoneError::max</target>
        </trans-unit>
        <trans-unit id="03ed85d18288e8c6efca69c28f3c605bc8004901" translate="yes" xml:space="preserve">
          <source>NoneError::min</source>
          <target state="translated">NoneError::min</target>
        </trans-unit>
        <trans-unit id="0cf87dcf59fc2d8f60cce9e0913e3c5ea01c71c6" translate="yes" xml:space="preserve">
          <source>NoneError::ne</source>
          <target state="translated">NoneError::ne</target>
        </trans-unit>
        <trans-unit id="88b27454a88f2b6d19dafb3a30b27e9e4799a66b" translate="yes" xml:space="preserve">
          <source>NoneError::partial_cmp</source>
          <target state="translated">NoneError::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d76800607ec208e0e9251b9a3a41ceabc49a331f" translate="yes" xml:space="preserve">
          <source>NoneError::to_owned</source>
          <target state="translated">NoneError::to_owned</target>
        </trans-unit>
        <trans-unit id="a3e3b0d2121e13d536f0151b0514e0d6c2c50efe" translate="yes" xml:space="preserve">
          <source>NoneError::try_from</source>
          <target state="translated">NoneError::try_from</target>
        </trans-unit>
        <trans-unit id="b6f9326f4f9275b1c9ee9bf38430eb240361bf0b" translate="yes" xml:space="preserve">
          <source>NoneError::try_into</source>
          <target state="translated">NoneError::try_into</target>
        </trans-unit>
        <trans-unit id="2ed007421edc30616530d31dc1a9b886d8f905b6" translate="yes" xml:space="preserve">
          <source>NoneError::type_id</source>
          <target state="translated">NoneError::type_id</target>
        </trans-unit>
        <trans-unit id="59bdf32f963e32403610f535ed38d94ab9fa57b3" translate="yes" xml:space="preserve">
          <source>Nonequality comparison</source>
          <target state="translated">품질 비교</target>
        </trans-unit>
        <trans-unit id="aa380f41959815056bfdd3029c1845bf486477df" translate="yes" xml:space="preserve">
          <source>Nor can you use direct field access to do field-by-field gradual initialization:</source>
          <target state="translated">직접 필드 액세스를 사용하여 필드 별 점진적 초기화를 수행 할 수도 없습니다.</target>
        </trans-unit>
        <trans-unit id="19eddb0e70179b2e619be3068cd8376966632800" translate="yes" xml:space="preserve">
          <source>Nor will this:</source>
          <target state="translated">이것도 마찬가지입니다 :</target>
        </trans-unit>
        <trans-unit id="9b417a21d4e30df48f9cabc1eb07b9ff439a8913" translate="yes" xml:space="preserve">
          <source>Normally, here, one would use &lt;a href=&quot;#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; instead to correctly drop the contents and thus not leak memory.</source>
          <target state="translated">일반적으로, 여기에, 하나는 사용하는 것이 &lt;a href=&quot;#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt; 내용을 올바르게 삭제하기 를 하므로 메모리가 누출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5084dc27f957de7bc8c196b5f20cd9275d3c3a4f" translate="yes" xml:space="preserve">
          <source>Normally, here, one would use &lt;a href=&quot;struct.vec#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; instead to correctly drop the contents and thus not leak memory.</source>
          <target state="translated">일반적으로 여기서는 내용을 올바르게 삭제하기 위해 대신 &lt;a href=&quot;struct.vec#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; 를&lt;/a&gt; 사용하여 메모리 누수를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="ca1dd39379254ab3f3c73dbffb0d03d628b27d20" translate="yes" xml:space="preserve">
          <source>Not</source>
          <target state="translated">Not</target>
        </trans-unit>
        <trans-unit id="7531cdd8037edc1069a4fd743641ffecf0edfa83" translate="yes" xml:space="preserve">
          <source>Not Equal</source>
          <target state="translated">같지 않음</target>
        </trans-unit>
        <trans-unit id="f8548a3657bfc32a33e876b215b140f301134c05" translate="yes" xml:space="preserve">
          <source>Not a Number (NaN).</source>
          <target state="translated">숫자가 아님 (NaN).</target>
        </trans-unit>
        <trans-unit id="d52a965ff185906c6e9fb5c36534475faa112b26" translate="yes" xml:space="preserve">
          <source>Not a Number (NaN). Use &lt;a href=&quot;../primitive.f32#associatedconstant.NAN&quot;&gt;&lt;code&gt;f32::NAN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">NaN (Not a Number). 대신 &lt;a href=&quot;../primitive.f32#associatedconstant.NAN&quot;&gt; &lt;code&gt;f32::NAN&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd484bf7d113fac0a06fa50cec141b09e01e967e" translate="yes" xml:space="preserve">
          <source>Not a Number (NaN). Use &lt;a href=&quot;../primitive.f64#associatedconstant.NAN&quot;&gt;&lt;code&gt;f64::NAN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">NaN (Not a Number). 대신 &lt;a href=&quot;../primitive.f64#associatedconstant.NAN&quot;&gt; &lt;code&gt;f64::NAN&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="64507e89e4bdf04e8f9c77f8ac34253ff22412a5" translate="yes" xml:space="preserve">
          <source>Not all platforms that libstd compiles for support capturing backtraces. Some platforms simply do nothing when capturing a backtrace. To check whether the platform supports capturing backtraces you can consult the &lt;code&gt;BacktraceStatus&lt;/code&gt; enum as a result of &lt;code&gt;Backtrace::status&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="736e9bdbdcdd4b04a6c46d181f239630b7b9a187" translate="yes" xml:space="preserve">
          <source>Not all uses of &lt;code&gt;unsafe&lt;/code&gt; are equivalent: some are here to mark the existence of a contract the programmer must check, others are to say &quot;I have checked the contract, go ahead and do this&quot;. The following &lt;a href=&quot;https://internals.rust-lang.org/t/what-does-unsafe-mean/6696&quot;&gt;discussion on Rust Internals&lt;/a&gt; has more in-depth explanations about this but here is a summary of the main points:</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 모든 사용 이 동일 하지는 않습니다 . 일부는 프로그래머가 확인해야하는 계약의 존재를 표시하기 위해 여기에 있으며, 다른 일부는 &quot;계약을 확인했습니다. &lt;a href=&quot;https://internals.rust-lang.org/t/what-does-unsafe-mean/6696&quot;&gt;Rust Internals에&lt;/a&gt; 대한 다음 토론 은 이것에 대해 더 심층적 인 설명을 가지고 있지만 여기에 주요 요점에 대한 요약이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2508d67aae4fe16b65d89f08837d02c03c4df29" translate="yes" xml:space="preserve">
          <source>Not be &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 이 아님</target>
        </trans-unit>
        <trans-unit id="d13ee2c7e4ca985d57b930eb6ea7f0b33421d3e0" translate="yes" xml:space="preserve">
          <source>Not be infinite</source>
          <target state="translated">무한하지 않음</target>
        </trans-unit>
        <trans-unit id="6eb5b8bcff17673aebb4af5a3aeb0b4ab1932316" translate="yes" xml:space="preserve">
          <source>Not equal</source>
          <target state="translated">같지 않다</target>
        </trans-unit>
        <trans-unit id="a2b674143c807a9d4d57ac721ad16bfa7f8e15e8" translate="yes" xml:space="preserve">
          <source>Not finding the pattern:</source>
          <target state="translated">패턴을 찾지 못했습니다 :</target>
        </trans-unit>
        <trans-unit id="ba8cbd3db6c5866f33c337f17d9969faf64a68a8" translate="yes" xml:space="preserve">
          <source>Not have any type parameters (although lifetime parameters are allowed), and</source>
          <target state="translated">평생 매개 변수가 허용되지만 유형 매개 변수가 없으며</target>
        </trans-unit>
        <trans-unit id="fcaef0deabf89559da493cc8fdbfb1b73c922bc5" translate="yes" xml:space="preserve">
          <source>Not having to worry about incorrectly assuming a not-null value helps you to be more confident in your code. In order to have a value that can possibly be null, you must explicitly opt in by making the type of that value &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;. Then, when you use that value, you are required to explicitly handle the case when the value is null. Everywhere that a value has a type that isn&amp;rsquo;t an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, you &lt;em&gt;can&lt;/em&gt; safely assume that the value isn&amp;rsquo;t null. This was a deliberate design decision for Rust to limit null&amp;rsquo;s pervasiveness and increase the safety of Rust code.</source>
          <target state="translated">널이 아닌 값을 가정한다고 잘못 걱정하지 않아도 코드에 대한 자신감이 높아집니다. 널이 될 수있는 값을 가지려면 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 값의 유형을 지정하여 명시 적으로 선택해야합니다 . 그런 다음 해당 값을 사용할 때 값이 널인 경우를 명시 적으로 처리해야합니다. 값이 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 가 아닌 유형을 갖는 모든 곳 에서 값이 null이 아니라고 가정 할 &lt;em&gt;수 있습니다&lt;/em&gt; . 이는 Rust가 널 (null)의 보급률을 제한하고 Rust 코드의 안전성을 높이기위한 의도적 인 설계 결정이었습니다.</target>
        </trans-unit>
        <trans-unit id="c51294854fb6314b2caed8c3d6d50e7adbd261e2" translate="yes" xml:space="preserve">
          <source>Not running destructors</source>
          <target state="translated">소멸자를 실행하지 않음</target>
        </trans-unit>
        <trans-unit id="b24fd225d5f013f2fa70d00cf4c24dafb25feaf7" translate="yes" xml:space="preserve">
          <source>Not running destructors in Rust is safe even if it has a type that isn't &lt;code&gt;'static&lt;/code&gt;. &lt;a href=&quot;../std/mem/struct.manuallydrop&quot;&gt;&lt;code&gt;std::mem::ManuallyDrop&lt;/code&gt;&lt;/a&gt; provides a wrapper to prevent a variable or field from being dropped automatically.</source>
          <target state="translated">Rust에서 소멸자를 실행하지 않으면 &lt;code&gt;'static&lt;/code&gt; 이 아닌 유형이 있어도 안전 합니다. &lt;a href=&quot;../std/mem/struct.manuallydrop&quot;&gt; &lt;code&gt;std::mem::ManuallyDrop&lt;/code&gt; &lt;/a&gt; 은 변수 또는 필드가 자동으로 삭제되지 않도록 래퍼를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0c7cc856a7f3d9cb5a50a65d04097b3b7b8538aa" translate="yes" xml:space="preserve">
          <source>Not that this function returns NaN if the initial value was NaN as well.</source>
          <target state="translated">초기 값이 NaN 인 경우이 함수는 NaN을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c78919f021b1d754a66fe9891819ec98d0a80ddf" translate="yes" xml:space="preserve">
          <source>Not::not</source>
          <target state="translated">Not::not</target>
        </trans-unit>
        <trans-unit id="67e3ba0677bb45d7937c81385c061373c31498a8" translate="yes" xml:space="preserve">
          <source>Notable exception is made for situations where any of the directories specified in the &lt;code&gt;path&lt;/code&gt; could not be created as it was being created concurrently. Such cases are considered to be successful. That is, calling &lt;code&gt;create_dir_all&lt;/code&gt; concurrently from multiple threads or processes is guaranteed not to fail due to a race condition with itself.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 지정된 디렉토리를 동시에 작성하여 작성할 수없는 상황에서는 예외가 발생 합니다. 이러한 경우는 성공적인 것으로 간주됩니다. 즉, 여러 스레드 또는 프로세스에서 &lt;code&gt;create_dir_all&lt;/code&gt; 을 동시에 호출 하면 경쟁 조건으로 인해 실패하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23a734e9b17de37ddc28f39d989ac717c3bd9ad8" translate="yes" xml:space="preserve">
          <source>Notable features that const contexts have, but const fn haven't are:</source>
          <target state="translated">const 컨텍스트에는 있지만 const fn에는없는 주목할만한 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="215a4bdf475a8ec68726e515897b581b10444b3f" translate="yes" xml:space="preserve">
          <source>Notable traits for &amp;amp;'_ [u8]</source>
          <target state="translated">&amp;amp; '_ [u8]의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="d369df1510ca517b58a49f8cd6e6bb0e489ca52a" translate="yes" xml:space="preserve">
          <source>Notable traits for &amp;amp;'_ mut F</source>
          <target state="translated">&amp;amp; '_ mut F의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="5e37dfc133bc97ebdeab9c07032473d9272189b3" translate="yes" xml:space="preserve">
          <source>Notable traits for &amp;amp;'_ mut I</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb09acdfe424fff47bc90762c736658052520f0" translate="yes" xml:space="preserve">
          <source>Notable traits for Ancestors&amp;lt;'a&amp;gt;</source>
          <target state="translated">조상의 주목할만한 특성 &amp;lt; 'a&amp;gt;</target>
        </trans-unit>
        <trans-unit id="49884a82c86f5e2dcfd40b1838c34bab8f05e373" translate="yes" xml:space="preserve">
          <source>Notable traits for ArrayChunks&amp;lt;'a, T, N&amp;gt;</source>
          <target state="translated">ArrayChunks &amp;lt; 'a, T, N&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="0cd325ab96ff06257d643a3909af2cf159e2fa33" translate="yes" xml:space="preserve">
          <source>Notable traits for ArrayChunksMut&amp;lt;'a, T, N&amp;gt;</source>
          <target state="translated">ArrayChunksMut &amp;lt; 'a, T, N&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="8e4c4055a5d727f7480702b2cc7fa22ff495757b" translate="yes" xml:space="preserve">
          <source>Notable traits for ArrayWindows&amp;lt;'a, T, N&amp;gt;</source>
          <target state="translated">ArrayWindows &amp;lt; 'a, T, N&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="a8627fe98c009205a399c633908682c9a3e1ee4d" translate="yes" xml:space="preserve">
          <source>Notable traits for Box&amp;lt;F&amp;gt;</source>
          <target state="translated">Box &amp;lt;F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="b9870581aecb430500b110feb6009781a8a35709" translate="yes" xml:space="preserve">
          <source>Notable traits for Box&amp;lt;F, A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01102f0879a5c2ca5c62809ffff0c0b0bad939d6" translate="yes" xml:space="preserve">
          <source>Notable traits for BufReader&amp;lt;R&amp;gt;</source>
          <target state="translated">BufReader &amp;lt;R&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="bcafa8b1481fa65c646affea37accfbcf24f6580" translate="yes" xml:space="preserve">
          <source>Notable traits for BufWriter&amp;lt;W&amp;gt;</source>
          <target state="translated">BufWriter &amp;lt;W&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="73e8f6f48862fb0efc8b91d4c920e5075c8f689b" translate="yes" xml:space="preserve">
          <source>Notable traits for Bytes&amp;lt;'_&amp;gt;</source>
          <target state="translated">바이트의 주목할만한 특성 &amp;lt; '_&amp;gt;</target>
        </trans-unit>
        <trans-unit id="be95aee73944208a8cbfa7ffa1a48d80537a439d" translate="yes" xml:space="preserve">
          <source>Notable traits for Bytes&amp;lt;R&amp;gt;</source>
          <target state="translated">Bytes &amp;lt;R&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="e3aa0ca54ac23d2115ba17da930b0b2c7d22ecc0" translate="yes" xml:space="preserve">
          <source>Notable traits for Chain&amp;lt;'a&amp;gt;</source>
          <target state="translated">Chain &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="425c2e101149bb0adbc3f3833b4e9a88563fb4a0" translate="yes" xml:space="preserve">
          <source>Notable traits for Chain&amp;lt;A, B&amp;gt;</source>
          <target state="translated">Chain &amp;lt;A, B&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="2a7e1c82210baf0b46d0937fbf969162cf98c76c" translate="yes" xml:space="preserve">
          <source>Notable traits for Chain&amp;lt;T, U&amp;gt;</source>
          <target state="translated">Chain &amp;lt;T, U&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="cd4d751abd8ab3ab6e55826ec326c6f4c431564f" translate="yes" xml:space="preserve">
          <source>Notable traits for CharIndices&amp;lt;'a&amp;gt;</source>
          <target state="translated">CharIndices의 주목할만한 특성 &amp;lt; 'a&amp;gt;</target>
        </trans-unit>
        <trans-unit id="08171c5effb66b03601f395559057c5c02e5ba5f" translate="yes" xml:space="preserve">
          <source>Notable traits for Chars&amp;lt;'a&amp;gt;</source>
          <target state="translated">Chars의 주목할만한 특성 &amp;lt; 'a&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f9df882063622aa637c014b3eaf06c558ffb8da5" translate="yes" xml:space="preserve">
          <source>Notable traits for Chunks&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">청크의 주목할만한 특성 &amp;lt; 'a, T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7e432bd66d3f874ed890c86d21283df436f2bbd0" translate="yes" xml:space="preserve">
          <source>Notable traits for ChunksExact&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">ChunksExact의 주목할만한 특성 &amp;lt; 'a, T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="584a1b10a62ffb190941baeea973451d496428d5" translate="yes" xml:space="preserve">
          <source>Notable traits for ChunksExactMut&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">ChunksExactMut &amp;lt; 'a, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="95cc072812a01dbd66f6d2c5f3918fc1eecb2a25" translate="yes" xml:space="preserve">
          <source>Notable traits for ChunksMut&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">ChunksMut &amp;lt; 'a, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="fefa79cd49091a7a7a4ec1ce49b7dc2c3e8635da" translate="yes" xml:space="preserve">
          <source>Notable traits for Cloned&amp;lt;I&amp;gt;</source>
          <target state="translated">Cloned &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="ae1c1d71ecdd9048c788733f05c8ee9170150c39" translate="yes" xml:space="preserve">
          <source>Notable traits for CommandArgs&amp;lt;'a&amp;gt;</source>
          <target state="translated">CommandArgs의 주목할만한 특성 &amp;lt; 'a&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d1d93748b1b05464de3995712c8cd56c0fc09338" translate="yes" xml:space="preserve">
          <source>Notable traits for CommandEnvs&amp;lt;'a&amp;gt;</source>
          <target state="translated">CommandEnvs &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="a97de3ec8fdabeefc703a8e7d7547f9f3496a716" translate="yes" xml:space="preserve">
          <source>Notable traits for Components&amp;lt;'a&amp;gt;</source>
          <target state="translated">구성 요소에 대한 주목할만한 특성 &amp;lt; 'a&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d315c976ebb90a2389ef7743e81e7feecc3a3a82" translate="yes" xml:space="preserve">
          <source>Notable traits for Copied&amp;lt;I&amp;gt;</source>
          <target state="translated">Copied &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="baf59bdb6fb943dc984c5feb9e03a98364bc20d8" translate="yes" xml:space="preserve">
          <source>Notable traits for Cursor&amp;lt;T&amp;gt;</source>
          <target state="translated">Cursor &amp;lt;T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="d59f29f61cd42c0f0ff909de6d45f9e90f184a20" translate="yes" xml:space="preserve">
          <source>Notable traits for Cycle&amp;lt;I&amp;gt;</source>
          <target state="translated">Cycle &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="c53b4ea31bf598b85ea40c284bdb3c0198881f8c" translate="yes" xml:space="preserve">
          <source>Notable traits for DecodeUtf16&amp;lt;I&amp;gt;</source>
          <target state="translated">DecodeUtf16 &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="b5127544158054e8bfb051274dd2021f84d9c3e7" translate="yes" xml:space="preserve">
          <source>Notable traits for Difference&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">차이점에 대한 주목할만한 특성 &amp;lt; 'a, T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="49894b4bfbcd9313cd8e1fca37fff62b0d5fe327" translate="yes" xml:space="preserve">
          <source>Notable traits for Difference&amp;lt;'a, T, S&amp;gt;</source>
          <target state="translated">차이점에 대한 주목할만한 특성 &amp;lt; 'a, T, S&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7bc7c96c5bc0e2db809df1de91687bd4053c4024" translate="yes" xml:space="preserve">
          <source>Notable traits for Drain&amp;lt;'_&amp;gt;</source>
          <target state="translated">배수의 주목할만한 특성 &amp;lt; '_&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f0c298a9ee76878fdf90e4aa0fdba569c9110023" translate="yes" xml:space="preserve">
          <source>Notable traits for Drain&amp;lt;'_, T&amp;gt;</source>
          <target state="translated">Drain &amp;lt; '_, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="bfff38769221a3bcf19fc3461189daa684992a6d" translate="yes" xml:space="preserve">
          <source>Notable traits for Drain&amp;lt;'a, K&amp;gt;</source>
          <target state="translated">드레인의 주목할만한 특성 &amp;lt; 'a, K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="958272eb22af639d41c1f50e43d47fb61a6b14ef" translate="yes" xml:space="preserve">
          <source>Notable traits for Drain&amp;lt;'a, K, V&amp;gt;</source>
          <target state="translated">Drain &amp;lt; 'a, K, V&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="0daba3253b1d0ae9af8dc2745c8744b02b11222b" translate="yes" xml:space="preserve">
          <source>Notable traits for DrainFilter&amp;lt;'_, K, F&amp;gt;</source>
          <target state="translated">DrainFilter &amp;lt; '_, K, F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="2385be6e59fcef027951939bd378844cfa66cc4e" translate="yes" xml:space="preserve">
          <source>Notable traits for DrainFilter&amp;lt;'_, K, V, F&amp;gt;</source>
          <target state="translated">DrainFilter &amp;lt; '_, K, V, F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="830f76c13044b7581905cb940dcf417e291d507b" translate="yes" xml:space="preserve">
          <source>Notable traits for DrainFilter&amp;lt;'_, T, F&amp;gt;</source>
          <target state="translated">DrainFilter &amp;lt; '_, T, F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="304a6f343623430e09952339820090a6a8ba207e" translate="yes" xml:space="preserve">
          <source>Notable traits for DrainSorted&amp;lt;'_, T&amp;gt;</source>
          <target state="translated">DrainSorted &amp;lt; '_, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="ac510d8e5089a326a2eb18feaee192a8adc0a137" translate="yes" xml:space="preserve">
          <source>Notable traits for Empty&amp;lt;T&amp;gt;</source>
          <target state="translated">Empty &amp;lt;T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="f3573695011deffd446de805daa200465e4ba04e" translate="yes" xml:space="preserve">
          <source>Notable traits for EncodeUtf16&amp;lt;'a&amp;gt;</source>
          <target state="translated">EncodeUtf16 &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="e43fb28465d3894c2c42629f7fcac035e497cddd" translate="yes" xml:space="preserve">
          <source>Notable traits for EncodeWide&amp;lt;'a&amp;gt;</source>
          <target state="translated">EncodeWide &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="f89d4ae7f36a369049ddb4e7f3c8216010d3419d" translate="yes" xml:space="preserve">
          <source>Notable traits for Enumerate&amp;lt;I&amp;gt;</source>
          <target state="translated">Enumerate &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="df3db15928fc8d95aa51b8ec8568ffb5eabd15ff" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeDebug</source>
          <target state="translated">EscapeDebug의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="4c8ea88e979fa0c14d5d9cdbbd9d161b88b39045" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeDebug&amp;lt;'a&amp;gt;</source>
          <target state="translated">EscapeDebug &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="098a62e8683b0a13c0908e723720ee9c6810fedc" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeDefault</source>
          <target state="translated">EscapeDefault의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="1190462f1941cfb82dacec2de3ad04f7c9541203" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeDefault&amp;lt;'a&amp;gt;</source>
          <target state="translated">EscapeDefault &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="ac599426120513bc277a63e47f672a5774b2c3d2" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeUnicode</source>
          <target state="translated">EscapeUnicode의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="8024ca6f7e281ae2b2c49427386c5bf3564e02b9" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeUnicode&amp;lt;'a&amp;gt;</source>
          <target state="translated">EscapeUnicode &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="09f685f90ec7f2abae36adf82f3e91f906928c37" translate="yes" xml:space="preserve">
          <source>Notable traits for File</source>
          <target state="translated">File의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="c974ed1aff38ed15c92fd39174e5a139046f0e34" translate="yes" xml:space="preserve">
          <source>Notable traits for Filter&amp;lt;I, P&amp;gt;</source>
          <target state="translated">Filter &amp;lt;I, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="0176f9f85bf66bf907565450c64018c10c6cb978" translate="yes" xml:space="preserve">
          <source>Notable traits for FilterMap&amp;lt;I, F&amp;gt;</source>
          <target state="translated">FilterMap &amp;lt;I, F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="6bcdf064b818fb335120a0a13f2aad0c77345394" translate="yes" xml:space="preserve">
          <source>Notable traits for FlatMap&amp;lt;I, U, F&amp;gt;</source>
          <target state="translated">FlatMap &amp;lt;I, U, F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="1073550fde927671db722e47a13215279dc8806e" translate="yes" xml:space="preserve">
          <source>Notable traits for Flatten&amp;lt;I&amp;gt;</source>
          <target state="translated">Flatten &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="c3bb84e817e2df7af3ebf4adf8af3eae4361fbed" translate="yes" xml:space="preserve">
          <source>Notable traits for FromFn&amp;lt;F&amp;gt;</source>
          <target state="translated">FromFn &amp;lt;F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="dab5351ad5f13713d82cab1221966fc7e75e9d94" translate="yes" xml:space="preserve">
          <source>Notable traits for Fuse&amp;lt;I&amp;gt;</source>
          <target state="translated">Fuse &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="98b96e5efed1886b8e4bb59473b0f591f83aa189" translate="yes" xml:space="preserve">
          <source>Notable traits for Incoming&amp;lt;'a&amp;gt;</source>
          <target state="translated">Incoming의 주목할만한 특성 &amp;lt; 'a&amp;gt;</target>
        </trans-unit>
        <trans-unit id="69f0a4d3c756c850a0608c731279e5ac5c5ca49c" translate="yes" xml:space="preserve">
          <source>Notable traits for Inspect&amp;lt;I, F&amp;gt;</source>
          <target state="translated">Inspect &amp;lt;I, F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="9f01a7c49836f7656e92d546f4185d1aefd357b8" translate="yes" xml:space="preserve">
          <source>Notable traits for Intersection&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">교차로의 주목할만한 특성 &amp;lt; 'a, T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="20846e5c04b975b9bee849726ac0019c4f7b197d" translate="yes" xml:space="preserve">
          <source>Notable traits for Intersection&amp;lt;'a, T, S&amp;gt;</source>
          <target state="translated">교차로의 주목할만한 특성 &amp;lt; 'a, T, S&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4917b9b001be9af84b1ad65c2d45310be0927721" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;A&amp;gt;</source>
          <target state="translated">IntoIter &amp;lt;A&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="1104b62a63a5899e12eeb37d5678f9df68b057f0" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;K&amp;gt;</source>
          <target state="translated">IntoIter &amp;lt;K&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="1b19c0d62a927883656bbd747f944a9ce1ae1de8" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;K, V&amp;gt;</source>
          <target state="translated">IntoIter &amp;lt;K, V&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="5480768feb968b4174c1ae6ddf0dcc0e359f66ea" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;T&amp;gt;</source>
          <target state="translated">IntoIter &amp;lt;T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="3722bff12524c5b2d2d05cda59ba23d190ce3bfe" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;T, N&amp;gt;</source>
          <target state="translated">IntoIter &amp;lt;T, N&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="8c2d3479bd2162e028960fa1d767fb2598f2f013" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIterSorted&amp;lt;T&amp;gt;</source>
          <target state="translated">IntoIterSorted &amp;lt;T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="5ad4c5fe36c7d254f4808dae95121b2bb0b54801" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoKeys&amp;lt;K, V&amp;gt;</source>
          <target state="translated">IntoKeys &amp;lt;K, V&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="da31fc5c3cf56bab8c815369c2547a6911c833ba" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoValues&amp;lt;K, V&amp;gt;</source>
          <target state="translated">IntoValues ​​&amp;lt;K, V&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="80895d49113bdb3cb86cfb4506bc6ebd9cd990ad" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a&amp;gt;</source>
          <target state="translated">Iter &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="d36ae4aeecd3653ca01fd74624e132869451eaf4" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a, A&amp;gt;</source>
          <target state="translated">Iter &amp;lt; 'a, A&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="6d5c2ab959e5631dfaa0a10009806935497b8c43" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a, K&amp;gt;</source>
          <target state="translated">Iter의 주목할만한 특성 &amp;lt; 'a, K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6b3bc881963ccadbe18c6746d9bbee3015f5abf1" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a, K, V&amp;gt;</source>
          <target state="translated">Iter &amp;lt; 'a, K, V&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="00b543ae90963f05f96f4dd377980b1713d5159b" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">Iter &amp;lt; 'a, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="2b070bfb60176569efaa6c1a4d324dc380b18332" translate="yes" xml:space="preserve">
          <source>Notable traits for IterMut&amp;lt;'a, A&amp;gt;</source>
          <target state="translated">IterMut &amp;lt; 'a, A&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="c915012f89d1a99c63f545f2ebffcef019fb4f2d" translate="yes" xml:space="preserve">
          <source>Notable traits for IterMut&amp;lt;'a, K, V&amp;gt;</source>
          <target state="translated">IterMut &amp;lt; 'a, K, V&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="c7bfb298a8fa281946d7580611e184273523102f" translate="yes" xml:space="preserve">
          <source>Notable traits for IterMut&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">IterMut &amp;lt; 'a, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="9e5811113cb7885323072cf61d5667a2b362dde2" translate="yes" xml:space="preserve">
          <source>Notable traits for Keys&amp;lt;'a, K, V&amp;gt;</source>
          <target state="translated">Keys의 주목할만한 특성 &amp;lt; 'a, K, V&amp;gt;</target>
        </trans-unit>
        <trans-unit id="99c669d87d53a9eb6f676c0605066d307d9e6144" translate="yes" xml:space="preserve">
          <source>Notable traits for LineWriter&amp;lt;W&amp;gt;</source>
          <target state="translated">LineWriter &amp;lt;W&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="6228658663ccbd3f41a5107629651e3c2771c99b" translate="yes" xml:space="preserve">
          <source>Notable traits for Lines&amp;lt;'a&amp;gt;</source>
          <target state="translated">라인의 주목할만한 특성 &amp;lt; 'a&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9213f8c618faa944ed6f22753d61edcc9d4ecdf2" translate="yes" xml:space="preserve">
          <source>Notable traits for Lines&amp;lt;B&amp;gt;</source>
          <target state="translated">Lines &amp;lt;B&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="f6a5e49b0d0ee24c230282dd8f08580ff2f4ffb7" translate="yes" xml:space="preserve">
          <source>Notable traits for LinesAny&amp;lt;'a&amp;gt;</source>
          <target state="translated">LinesAny &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="b99d80dc293caeb573cce051072ed906b6f15c5e" translate="yes" xml:space="preserve">
          <source>Notable traits for Map&amp;lt;I, F&amp;gt;</source>
          <target state="translated">Map &amp;lt;I, F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="172f87d0793ddf7da88be709a2311741cbd4b363" translate="yes" xml:space="preserve">
          <source>Notable traits for MapWhile&amp;lt;I, P&amp;gt;</source>
          <target state="translated">MapWhile &amp;lt;I, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="64729c888eeabe7cf12e1842e01480ed82b337ff" translate="yes" xml:space="preserve">
          <source>Notable traits for MatchIndices&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">MatchIndices의 주목할만한 특성 &amp;lt; 'a, P&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b0d2b75e66e9e050b8169e3218de5ee791479721" translate="yes" xml:space="preserve">
          <source>Notable traits for Matches&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">Matches의 주목할만한 특성 &amp;lt; 'a, P&amp;gt;</target>
        </trans-unit>
        <trans-unit id="25ae519d64a28536d279768ad769256299621686" translate="yes" xml:space="preserve">
          <source>Notable traits for Once&amp;lt;T&amp;gt;</source>
          <target state="translated">Once &amp;lt;T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="f8b307122c682ff77253a547508bfd2ee6faae04" translate="yes" xml:space="preserve">
          <source>Notable traits for OnceWith&amp;lt;F&amp;gt;</source>
          <target state="translated">OnceWith &amp;lt;F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="ed7b3a034e2d225ecfcc33f32f2f83f5b7d3d90b" translate="yes" xml:space="preserve">
          <source>Notable traits for Peekable&amp;lt;I&amp;gt;</source>
          <target state="translated">Peekable &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="6b8f81a496f377f17826b87b054d41b9d3f6cb71" translate="yes" xml:space="preserve">
          <source>Notable traits for Pending&amp;lt;T&amp;gt;</source>
          <target state="translated">Pending &amp;lt;T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="74be0fa24b2449c87cf0033da73af99abb038226" translate="yes" xml:space="preserve">
          <source>Notable traits for Pin&amp;lt;P&amp;gt;</source>
          <target state="translated">Pin &amp;lt;P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="cf6ce59e954214088a5388d7abe14ace680afd30" translate="yes" xml:space="preserve">
          <source>Notable traits for RChunks&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">RChunks의 주목할만한 특성 &amp;lt; 'a, T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ff0549023d3e07da72d7eaec8fd8c7d3b1bfc8bb" translate="yes" xml:space="preserve">
          <source>Notable traits for RChunksExact&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">RChunksExact의 주목할만한 특성 &amp;lt; 'a, T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1891d732a25cb1a2d6470e2f1e61d90d79932069" translate="yes" xml:space="preserve">
          <source>Notable traits for RChunksExactMut&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">RChunksExactMut &amp;lt; 'a, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="272511b477fb6f4d7e66f455a8927b6aa68fd2ce" translate="yes" xml:space="preserve">
          <source>Notable traits for RChunksMut&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">RChunksMut &amp;lt; 'a, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="4bc67e64b7ea3bfd3fc10ece7ec2491353da6e9d" translate="yes" xml:space="preserve">
          <source>Notable traits for RMatchIndices&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">RMatchIndices의 주목할만한 특성 &amp;lt; 'a, P&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ae7b6da19243fedcfa70bfd82f4cf8717d322f80" translate="yes" xml:space="preserve">
          <source>Notable traits for RMatches&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">RMatches의 주목할만한 특성 &amp;lt; 'a, P&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3aa09ee60858aa32b9e0f1689cc4891931af0d24" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplit&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">RSplit의 주목할만한 특성 &amp;lt; 'a, P&amp;gt;</target>
        </trans-unit>
        <trans-unit id="a0fe88a7318fe9810ff3810f98339d43244a6877" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplit&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">RSplit의 주목할만한 특성 &amp;lt; 'a, T, P&amp;gt;</target>
        </trans-unit>
        <trans-unit id="70be06d4120000b8b8b94371aec7e2580c6b381b" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">RSplitMut &amp;lt; 'a, T, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="7b31a8c9c6cb2046e7ec9e536ce72d0609e4c5c4" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitN&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">RSplitN &amp;lt; 'a, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="19040f24ad7c9687e49caaeab46d848dc263b5ea" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitN&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">RSplitN &amp;lt; 'a, T, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="1988fde6a09875d4b04a7b9e55d197b9d9a90765" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitNMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">RSplitNMut &amp;lt; 'a, T, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="907edfb9c1524174e07ccbc24ecb37a8cbb06d65" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitTerminator&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">RSplitTerminator &amp;lt; 'a, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="9198631706611f9de2afa1f3a5e4389cd7cb8e7a" translate="yes" xml:space="preserve">
          <source>Notable traits for Range&amp;lt;'a, K, V&amp;gt;</source>
          <target state="translated">Range &amp;lt; 'a, K, V&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="3d3fe2b23ebaced9425f58daf076814b8c0291d9" translate="yes" xml:space="preserve">
          <source>Notable traits for Range&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">Range &amp;lt; 'a, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="0614892f74433d616b37d2ae04d67fe7f14ad105" translate="yes" xml:space="preserve">
          <source>Notable traits for Range&amp;lt;A&amp;gt;</source>
          <target state="translated">Range &amp;lt;A&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="beebcbfc8cc5133e5166a3028ebbd90ecdb7055f" translate="yes" xml:space="preserve">
          <source>Notable traits for RangeFrom&amp;lt;A&amp;gt;</source>
          <target state="translated">RangeFrom &amp;lt;A&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="f744d9434a4d9b5c37c99f5c97d2b2cc90b13077" translate="yes" xml:space="preserve">
          <source>Notable traits for RangeInclusive&amp;lt;A&amp;gt;</source>
          <target state="translated">RangeInclusive &amp;lt;A&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="0a4e925f094b7a69f246e42e8b50c5128f8129c7" translate="yes" xml:space="preserve">
          <source>Notable traits for RangeMut&amp;lt;'a, K, V&amp;gt;</source>
          <target state="translated">RangeMut &amp;lt; 'a, K, V&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="abd184a89bc10bea6baedba72d627209bea1056f" translate="yes" xml:space="preserve">
          <source>Notable traits for Ready&amp;lt;T&amp;gt;</source>
          <target state="translated">Ready &amp;lt;T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="64702f1280547e388d11ff5ae890bb729b733d36" translate="yes" xml:space="preserve">
          <source>Notable traits for Repeat&amp;lt;A&amp;gt;</source>
          <target state="translated">Repeat &amp;lt;A&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="49a3b2a3770cc905b8da25f64e140b4ab80c6ffe" translate="yes" xml:space="preserve">
          <source>Notable traits for RepeatWith&amp;lt;F&amp;gt;</source>
          <target state="translated">RepeatWith &amp;lt;F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="b0ad194cda463ad2c6dd1506daf0367114be5c8e" translate="yes" xml:space="preserve">
          <source>Notable traits for Rev&amp;lt;I&amp;gt;</source>
          <target state="translated">Rev &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="1ff8f63be235b7ea2055383c2e9b72b84c7bd07e" translate="yes" xml:space="preserve">
          <source>Notable traits for Scan&amp;lt;I, St, F&amp;gt;</source>
          <target state="translated">Scan &amp;lt;I, St, F&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="985d073dbfe88a46f9a5d9a064d7c96c1a9ddbdb" translate="yes" xml:space="preserve">
          <source>Notable traits for Skip&amp;lt;I&amp;gt;</source>
          <target state="translated">Skip &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="4f0eaba444b8b7b51819626fe7d8a57f993cdf9a" translate="yes" xml:space="preserve">
          <source>Notable traits for SkipWhile&amp;lt;I, P&amp;gt;</source>
          <target state="translated">SkipWhile &amp;lt;I, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="ca8f82912aa693cda641dbb9a8f2619f7e15ddea" translate="yes" xml:space="preserve">
          <source>Notable traits for Splice&amp;lt;'_, I&amp;gt;</source>
          <target state="translated">Splice &amp;lt; '_, I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="ef399e09acd6419098e7cfcabf45df6744dbfbc6" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">Split &amp;lt; 'a, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="e1f967c2a861c03dbdc5cf356551e97bb60b084f" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">Split &amp;lt; 'a, T, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="e39a8c3f513e0738a443ac406858d3b7bc026953" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;B&amp;gt;</source>
          <target state="translated">Split &amp;lt;B&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="d1d5f710d040b4a11a5d716baa68dcf2d617217b" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitAsciiWhitespace&amp;lt;'a&amp;gt;</source>
          <target state="translated">SplitAsciiWhitespace &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="fb7865e840a56b3e0895b5ec1bdbc829b951351d" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitInclusive&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">SplitInclusive &amp;lt; 'a, T, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="9818f4f1fdfe2d933ac6655c5c4953e8aff5a7e1" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitInclusiveMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">SplitInclusiveMut &amp;lt; 'a, T, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="0838dd01ca950ce33cd2058b8d0ff4fd43821113" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">SplitMut &amp;lt; 'a, T, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="e5880f295f9b58cf5125e602e8fae3c01c02bfbe" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitN&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">SplitN &amp;lt; 'a, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="7599a2d009c0938be30293d468e1a75ce65377d5" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitN&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">SplitN &amp;lt; 'a, T, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="37e0cb911750681c09ba0b190a9557e42adc2590" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitNMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="translated">SplitNMut &amp;lt; 'a, T, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="f48dc2915683e916503c8dcf3e59f491126656bf" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitTerminator&amp;lt;'a, P&amp;gt;</source>
          <target state="translated">SplitTerminator &amp;lt; 'a, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="d707147c6fab5cc551e32ce5467c609e374e4f50" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitWhitespace&amp;lt;'a&amp;gt;</source>
          <target state="translated">SplitWhitespace &amp;lt; 'a&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="437caeb56851568308dca5cb78609789356f0853" translate="yes" xml:space="preserve">
          <source>Notable traits for StderrLock&amp;lt;'_&amp;gt;</source>
          <target state="translated">StderrLock &amp;lt; '_&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="48c194fa1f0bd2541f390bd24896165b0c23c7e5" translate="yes" xml:space="preserve">
          <source>Notable traits for StdinLock&amp;lt;'_&amp;gt;</source>
          <target state="translated">StdinLock의 주목할만한 특성 &amp;lt; '_&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ee33f3797cb0a601933ebede73fe50f827c75b6e" translate="yes" xml:space="preserve">
          <source>Notable traits for StdoutLock&amp;lt;'_&amp;gt;</source>
          <target state="translated">StdoutLock의 주목할만한 특성 &amp;lt; '_&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3e0ae991bfa5ac7c9c453dec86d28b7d72d47073" translate="yes" xml:space="preserve">
          <source>Notable traits for StepBy&amp;lt;I&amp;gt;</source>
          <target state="translated">StepBy &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="83f5fe0a710de90155479f39d5f77c153488c0a5" translate="yes" xml:space="preserve">
          <source>Notable traits for Successors&amp;lt;T, F&amp;gt;</source>
          <target state="translated">후임자의 주목할만한 특성 &amp;lt;T, F&amp;gt;</target>
        </trans-unit>
        <trans-unit id="647ebf3b1fc10e80b4ce476f35a75fa114a5fab1" translate="yes" xml:space="preserve">
          <source>Notable traits for SymmetricDifference&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">SymmetricDifference에 대한 주목할만한 특성 &amp;lt; 'a, T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5e0deb017937ef51088c94bb895f3902110ffe16" translate="yes" xml:space="preserve">
          <source>Notable traits for SymmetricDifference&amp;lt;'a, T, S&amp;gt;</source>
          <target state="translated">SymmetricDifference &amp;lt; 'a, T, S&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="6b271862886a9e625b5ac46fc4e49bcce91334f9" translate="yes" xml:space="preserve">
          <source>Notable traits for Take&amp;lt;I&amp;gt;</source>
          <target state="translated">Take &amp;lt;I&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="8d1491004df1c3cd73af985e7889ffe06072d374" translate="yes" xml:space="preserve">
          <source>Notable traits for Take&amp;lt;T&amp;gt;</source>
          <target state="translated">Take &amp;lt;T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="8c484c47892ef31d80e9449405b6a45f7812a953" translate="yes" xml:space="preserve">
          <source>Notable traits for TakeWhile&amp;lt;I, P&amp;gt;</source>
          <target state="translated">TakeWhile &amp;lt;I, P&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="ce43b5e8ae4c3d3abba449747c3b74da4e5cf5b2" translate="yes" xml:space="preserve">
          <source>Notable traits for TcpStream</source>
          <target state="translated">TcpStream의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="0e1590902cedb9997418d686f3b41f48a7faa5a8" translate="yes" xml:space="preserve">
          <source>Notable traits for ToLowercase</source>
          <target state="translated">ToLowercase의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="71cea9ba6a0245158a668390fdcdb390b3ee3a95" translate="yes" xml:space="preserve">
          <source>Notable traits for ToUppercase</source>
          <target state="translated">ToUppercase의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="2bc316517c095ef6246876fb36dafafef8842df0" translate="yes" xml:space="preserve">
          <source>Notable traits for TryIter&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">TryIter &amp;lt; 'a, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="36cd3ac7d99db311332b377e21251e4fba5322ec" translate="yes" xml:space="preserve">
          <source>Notable traits for Union&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">Union &amp;lt; 'a, T&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="a1623bf8aee40498694e04160abcc7cc94e51160" translate="yes" xml:space="preserve">
          <source>Notable traits for Union&amp;lt;'a, T, S&amp;gt;</source>
          <target state="translated">Union &amp;lt; 'a, T, S&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="41fbaa40eb7f00c2be283feaa1fbb38e29701e83" translate="yes" xml:space="preserve">
          <source>Notable traits for UnixStream</source>
          <target state="translated">UnixStream의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="9c50d1662883c24d433db05a688c0aa44526ac2e" translate="yes" xml:space="preserve">
          <source>Notable traits for Values&amp;lt;'a, K, V&amp;gt;</source>
          <target state="translated">가치에 대한 주목할만한 특성 &amp;lt; 'a, K, V&amp;gt;</target>
        </trans-unit>
        <trans-unit id="58c872469ad3d287548b76d4b848eba9a4a4c7d9" translate="yes" xml:space="preserve">
          <source>Notable traits for ValuesMut&amp;lt;'a, K, V&amp;gt;</source>
          <target state="translated">ValuesMut &amp;lt; 'a, K, V&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="34aac67be859564d9e8c0c60e00e2a029f471028" translate="yes" xml:space="preserve">
          <source>Notable traits for Vec&amp;lt;u8&amp;gt;</source>
          <target state="translated">Vec &amp;lt;u8&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="3f1ce7df300d5a68156470029c1320d12946032a" translate="yes" xml:space="preserve">
          <source>Notable traits for Windows&amp;lt;'a, T&amp;gt;</source>
          <target state="translated">Windows의 주목할만한 특성 &amp;lt; 'a, T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="a8ed148e4a8689fea1373b25b6f60ce6eb17047c" translate="yes" xml:space="preserve">
          <source>Notable traits for Zip&amp;lt;A, B&amp;gt;</source>
          <target state="translated">Zip &amp;lt;A, B&amp;gt;의 주목할만한 특성</target>
        </trans-unit>
        <trans-unit id="f8f7449873c705105af159faa9949fb17717e319" translate="yes" xml:space="preserve">
          <source>Notably this function ignores the &lt;code&gt;flag&lt;/code&gt; parameters.</source>
          <target state="translated">특히이 함수는 &lt;code&gt;flag&lt;/code&gt; 매개 변수를 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="0a8a9d000182248a3513e5a205741807831d1022" translate="yes" xml:space="preserve">
          <source>Notably: &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, function parameters, &lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt; and &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt; items must be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="translated">특히 &lt;a href=&quot;variables&quot;&gt;변수&lt;/a&gt; , 함수 매개 변수, &lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt; 및 &lt;a href=&quot;items/static-items&quot;&gt;정적&lt;/a&gt; 항목은 &lt;code&gt;Sized&lt;/code&gt; 되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9f3163ffda0d3418a1866865fdb1ef76cb2dbf4b" translate="yes" xml:space="preserve">
          <source>Notation</source>
          <target state="translated">Notation</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="c3fe4ddff5db29b0cb1f0eb2b355940acc3e474c" translate="yes" xml:space="preserve">
          <source>Note 1: The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">참고 1 : 반복자가 끝까지 소비되지 않더라도 요소 범위는 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="73bad292ab0326c274afe69e790430a32b7dd7b6" translate="yes" xml:space="preserve">
          <source>Note 1: The element range is removed even if the iterator is only partially consumed or not consumed at all.</source>
          <target state="translated">참고 1 : 반복자가 부분적으로 만 소비되거나 전혀 소비되지 않더라도 요소 범위는 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="375f6bc156b4954ecc954926534e181389ad6af2" translate="yes" xml:space="preserve">
          <source>Note 1: The first element of the iterator will always be returned, regardless of the step given.</source>
          <target state="translated">참고 1 : 주어진 단계에 관계없이 반복자의 첫 번째 요소가 항상 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0b81032a73d39d946d8d288ed04acdd88cf53ecf" translate="yes" xml:space="preserve">
          <source>Note 2: It is unspecified how many elements are removed from the deque, if the &lt;code&gt;Drain&lt;/code&gt; value is not dropped, but the borrow it holds expires (e.g., due to &lt;code&gt;mem::forget&lt;/code&gt;).</source>
          <target state="translated">참고 2 : &lt;code&gt;Drain&lt;/code&gt; 값이 삭제되지 않았지만 보유한 차용이 만료되는 경우 (예 : &lt;code&gt;mem::forget&lt;/code&gt; ) 디 케이크 에서 제거되는 요소 수는 지정되어 있지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2ad2f022b2009c4ce2fc1713a74b64ee404e87d1" translate="yes" xml:space="preserve">
          <source>Note 2: It is unspecified how many elements are removed from the vector if the &lt;code&gt;Drain&lt;/code&gt; value is leaked.</source>
          <target state="translated">참고 2 : &lt;code&gt;Drain&lt;/code&gt; 값이 유출 된 경우 벡터에서 얼마나 많은 요소가 제거되는지는 지정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="506d02500f5463906be1bc26ef13102642229ab6" translate="yes" xml:space="preserve">
          <source>Note 2: The time at which ignored elements are pulled is not fixed. &lt;code&gt;StepBy&lt;/code&gt; behaves like the sequence &lt;code&gt;next(), nth(step-1), nth(step-1), &amp;hellip;&lt;/code&gt;, but is also free to behave like the sequence &lt;code&gt;advance_n_and_return_first(step), advance_n_and_return_first(step), &amp;hellip;&lt;/code&gt; Which way is used may change for some iterators for performance reasons. The second way will advance the iterator earlier and may consume more items.</source>
          <target state="translated">참고 2 : 무시 된 요소를 가져 오는 시간은 고정되어 있지 않습니다. &lt;code&gt;StepBy&lt;/code&gt; 는 &lt;code&gt;next(), nth(step-1), nth(step-1), &amp;hellip;&lt;/code&gt; 시퀀스처럼 동작하지만, &lt;code&gt;advance_n_and_return_first(step), advance_n_and_return_first(step), &amp;hellip;&lt;/code&gt; 시퀀스처럼 자유롭게 동작 할 수 있습니다. 성능상의 이유로 일부 반복자에 대해 변경하십시오. 두 번째 방법은 반복기를 더 빨리 진행시키고 더 많은 항목을 소비 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3276127b29ca84c8dd6a3e6919af65a48a707afa" translate="yes" xml:space="preserve">
          <source>Note also that in Listing 19-1 and 19-3, we created &lt;code&gt;*const i32&lt;/code&gt; and &lt;code&gt;*mut i32&lt;/code&gt; raw pointers that both pointed to the same memory location, where &lt;code&gt;num&lt;/code&gt; is stored. If we instead tried to create an immutable and a mutable reference to &lt;code&gt;num&lt;/code&gt;, the code would not have compiled because Rust&amp;rsquo;s ownership rules don&amp;rsquo;t allow a mutable reference at the same time as any immutable references. With raw pointers, we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race. Be careful!</source>
          <target state="translated">또한 Listing 19-1과 19-3 에서 &lt;code&gt;num&lt;/code&gt; 이 저장된 동일한 메모리 위치를 가리키는 &lt;code&gt;*const i32&lt;/code&gt; 및 &lt;code&gt;*mut i32&lt;/code&gt; raw 포인터를 작성했다 . 대신 &lt;code&gt;num&lt;/code&gt; 에 대한 불변 및 변경 가능한 참조를 만들려고 시도하면 Rust의 소유권 규칙이 변경 불가능한 참조와 동시에 변경 가능한 참조를 허용하지 않기 때문에 코드가 컴파일되지 않았을 것입니다. 원시 포인터를 사용하면 변경 가능한 포인터와 동일한 위치에 대한 변경 불가능한 포인터를 만들고 변경 가능한 포인터를 통해 데이터를 변경하여 잠재적으로 데이터 경쟁을 일으킬 수 있습니다. 조심해!</target>
        </trans-unit>
        <trans-unit id="6de37aeaf259b01294052b110f1c5546480ac1df" translate="yes" xml:space="preserve">
          <source>Note also that in the context of this formalism, the term &quot;token&quot; generally &lt;em&gt;includes&lt;/em&gt; simple NTs.</source>
          <target state="translated">이 형식의 맥락에서 &quot;토큰&quot;이라는 용어 &lt;em&gt;에는&lt;/em&gt; 일반적으로 간단한 NT가 &lt;em&gt;포함됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ddbcd5d0f2ca8f557f88753b63844e194aa420bc" translate="yes" xml:space="preserve">
          <source>Note however that:</source>
          <target state="translated">그러나 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="ac8dc1e3e610d665d4339a3068108ed3e4e3d7f2" translate="yes" xml:space="preserve">
          <source>Note however, that &lt;code&gt;black_box&lt;/code&gt; is only (and can only be) provided on a &quot;best-effort&quot; basis. The extent to which it can block optimisations may vary depending upon the platform and code-gen backend used. Programs cannot rely on &lt;code&gt;black_box&lt;/code&gt; for &lt;em&gt;correctness&lt;/em&gt; in any way.</source>
          <target state="translated">그러나 &lt;code&gt;black_box&lt;/code&gt; 는 &quot;최선의 노력&quot;으로 만 제공되며 제공 될 수 있습니다. 최적화를 차단할 수있는 정도는 사용되는 플랫폼 및 코드 생성 백엔드에 따라 다를 수 있습니다. 프로그램은 어떤 식 으로든 &lt;em&gt;정확성&lt;/em&gt; 을 위해 &lt;code&gt;black_box&lt;/code&gt; 에 의존 할 수 없습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09b6433b842ad661442a50c48f705bbda92a3877" translate="yes" xml:space="preserve">
          <source>Note on locale</source>
          <target state="translated">로캘에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="6dac41f357fcb628dff23b9354a4451a8f0457e9" translate="yes" xml:space="preserve">
          <source>Note that &amp;amp;Any is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.</source>
          <target state="translated">&amp;amp; Any는 값이 지정된 콘크리트 유형인지 여부를 테스트하는 것으로 제한되며 유형이 특성을 구현하는지 여부를 테스트하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="57e530ae79447e200db1291082ac88c201431874" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; already performs this check, so if your workload can be reduced to some small number of &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; calls, using this is unnecessary. In particular note that you can &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; a slice, and that will do a single needs_drop check for all the values.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt; &lt;code&gt;drop_in_place&lt;/code&gt; 는&lt;/a&gt; 이미 워크로드의 일부 적은 수의 감소시킬 수있는 경우에는이 검사를 수행 &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt; &lt;code&gt;drop_in_place&lt;/code&gt; 의&lt;/a&gt; 이 불필요하여, 전화. 특히 슬라이스를 &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt; &lt;code&gt;drop_in_place&lt;/code&gt; &lt;/a&gt; 할 수 있으며 모든 값에 대해 단일 needs_drop 검사를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9bf762ffc91bdd3eff38c069a4a949827e702fcc" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt;s for example are implemented using this primitive. Indeed when you call &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;recv&lt;/code&gt;, which are blocking, they will yield if the channel is not available.</source>
          <target state="translated">참고 &lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; , 예를 들어 S는 프리미티브를 이용하여 구현된다. 실제로 &lt;code&gt;send&lt;/code&gt; 또는 &lt;code&gt;recv&lt;/code&gt; 를 호출 할 때 차단되는 채널을 사용할 수 없으면 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b25a38a73d437340101dfed415d44fe9cc8bfeca" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;struct.childstderr&quot;&gt;&lt;code&gt;ChildStderr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.childstdout&quot;&gt;&lt;code&gt;ChildStdout&lt;/code&gt;&lt;/a&gt; implement &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.childstdin&quot;&gt;&lt;code&gt;ChildStdin&lt;/code&gt;&lt;/a&gt; implements &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">참고 &lt;a href=&quot;struct.childstderr&quot;&gt; &lt;code&gt;ChildStderr&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.childstdout&quot;&gt; &lt;code&gt;ChildStdout&lt;/code&gt; 이&lt;/a&gt; 구현 &lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.childstdin&quot;&gt; &lt;code&gt;ChildStdin&lt;/code&gt; &lt;/a&gt; 구현 &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="cb54b0f71bbcbfc437ecfe318e92da06296ef44e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&amp;amp;dyn Any&lt;/code&gt; is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.</source>
          <target state="translated">참고 &lt;code&gt;&amp;amp;dyn Any&lt;/code&gt; 값이 지정된 구체적인 유형인지 여부를 테스트로 제한되며, 테스트에 있는지 여부 타입 구현하는 특성을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="40772281e6e9e65973c825aa35cf8a449645ff88" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(T,)&lt;/code&gt; always denotes the type of a 1-tuple containing an element of type &lt;code&gt;T&lt;/code&gt;. The comma is necessary for syntactic disambiguation.</source>
          <target state="translated">그 주 &lt;code&gt;(T,)&lt;/code&gt; 항상 형의 원소 함유 한 튜플의 유형이고 &lt;code&gt;T&lt;/code&gt; 가 . 쉼표는 구문 명확성을 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="83c24ee2be7e8854e259c9b6dfc4dd85416ed0a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;CoerceUnsized&lt;/code&gt; is mainly used by smart pointers like &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Rc&lt;/code&gt; and &lt;code&gt;Arc&lt;/code&gt; to be able to mark that they can coerce unsized types that they are pointing at.</source>
          <target state="translated">참고 &lt;code&gt;CoerceUnsized&lt;/code&gt; 는 주로 같은 스마트 포인터에 의해 사용되는 &lt;code&gt;Box&lt;/code&gt; , &lt;code&gt;Rc&lt;/code&gt; 를 하고 &lt;code&gt;Arc&lt;/code&gt; 그들이 가리키는 것을 크기를 지정하지 않은 유형을 강요 할 수 있음을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67f3e9957b8f2c4f460edc12ad2bfe3cbc26e031" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is only for use in single-threaded scenarios. When we discuss concurrency in Chapter 16, we&amp;rsquo;ll cover how to do reference counting in multithreaded programs.</source>
          <target state="translated">참고 것을 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 에만 단일 스레드 시나리오에서 사용할 수 있습니다. 16 장에서 동시성에 대해 논의 할 때 다중 스레드 프로그램에서 참조 횟수를 계산하는 방법을 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="5d99e9077b96e1db0f895f5becbb122b93be4c0b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory.</source>
          <target state="translated">참고 &lt;code&gt;Rhs&lt;/code&gt; 있습니다 &lt;code&gt;Self&lt;/code&gt; 기본적으로, 그러나 이것은 필수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2200d088885b3a3d42f0732955184ac9e811ecb3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory. For example, &lt;a href=&quot;../time/struct.systemtime&quot;&gt;&lt;code&gt;std::time::SystemTime&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;Add&amp;lt;Duration&amp;gt;&lt;/code&gt;, which permits operations of the form &lt;code&gt;SystemTime = SystemTime + Duration&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;Rhs&lt;/code&gt; 있습니다 &lt;code&gt;Self&lt;/code&gt; 기본적으로, 그러나 이것은 필수가 아닙니다. 예를 들어 &lt;a href=&quot;../time/struct.systemtime&quot;&gt; &lt;code&gt;std::time::SystemTime&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;Add&amp;lt;Duration&amp;gt;&lt;/code&gt; 구현 하여 &lt;code&gt;SystemTime = SystemTime + Duration&lt;/code&gt; 형식의 작업을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="6326c7ae251a36c65278ccf6246055e8e4c505f9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory. For example, &lt;a href=&quot;../time/struct.systemtime&quot;&gt;&lt;code&gt;std::time::SystemTime&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;Sub&amp;lt;Duration&amp;gt;&lt;/code&gt;, which permits operations of the form &lt;code&gt;SystemTime = SystemTime - Duration&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;Rhs&lt;/code&gt; 있습니다 &lt;code&gt;Self&lt;/code&gt; 기본적으로, 그러나 이것은 필수가 아닙니다. 예를 들어 &lt;a href=&quot;../time/struct.systemtime&quot;&gt; &lt;code&gt;std::time::SystemTime&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;Sub&amp;lt;Duration&amp;gt;&lt;/code&gt; 구현 하여 &lt;code&gt;SystemTime = SystemTime - Duration&lt;/code&gt; 형식의 작업을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="5d4b833ed91bb546ce7e87843871f8e854946fd3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so it can't even clone and reset &lt;code&gt;self.buf&lt;/code&gt;. But &lt;code&gt;replace&lt;/code&gt; can be used to disassociate the original value of &lt;code&gt;self.buf&lt;/code&gt; from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">하는 것으로 &lt;code&gt;T&lt;/code&gt; 가 반드시 구현하지 않는 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , 그렇지 않은 경우에도 복제 및 재설정 할 수 있습니다 &lt;code&gt;self.buf&lt;/code&gt; . 그러나 &lt;code&gt;replace&lt;/code&gt; 의 원래 값 해제 할 수 있습니다 &lt;code&gt;self.buf&lt;/code&gt; 에서 &lt;code&gt;self&lt;/code&gt; 가 반환 될 수 :</target>
        </trans-unit>
        <trans-unit id="ce9900f79b589dea762e357b371f9431cba99bba" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so it can't even clone and reset &lt;code&gt;self.buf&lt;/code&gt;. But &lt;code&gt;take&lt;/code&gt; can be used to disassociate the original value of &lt;code&gt;self.buf&lt;/code&gt; from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">하는 것으로 &lt;code&gt;T&lt;/code&gt; 가 반드시 구현하지 않는 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , 그렇지 않은 경우에도 복제 및 재설정 할 수 있습니다 &lt;code&gt;self.buf&lt;/code&gt; . 그러나 &lt;code&gt;take&lt;/code&gt; 의 원래 값 해제 할 수 있습니다 &lt;code&gt;self.buf&lt;/code&gt; 에서 &lt;code&gt;self&lt;/code&gt; 가 반환 될 수 :</target>
        </trans-unit>
        <trans-unit id="ac00b6421a53f1cb355d37f763df7d0ab6908815" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so we can't even clone &lt;code&gt;self.buf[i]&lt;/code&gt; to avoid the move. But &lt;code&gt;replace&lt;/code&gt; can be used to disassociate the original value at that index from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">참고 것을 &lt;code&gt;T&lt;/code&gt; 는 반드시 구현하지 않는 &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 우리가 심지어 복제 할 수 있도록 &lt;code&gt;self.buf[i]&lt;/code&gt; 이동을 방지하기 위해. 그러나 &lt;code&gt;replace&lt;/code&gt; 를 사용하여 해당 인덱스의 원래 값을 &lt;code&gt;self&lt;/code&gt; 에서 분리하여 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7210db58c23cf5014deeb9448717499ab480d12" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;a &amp;lt;= b&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; imply &lt;code&gt;steps_between(&amp;amp;a, &amp;amp;b) != None&lt;/code&gt;; this is the case when it would require more than &lt;code&gt;usize::MAX&lt;/code&gt; steps to get to &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">참고 &lt;code&gt;a &amp;lt;= b&lt;/code&gt; 않는다 &lt;em&gt;하지&lt;/em&gt; 암시 &lt;code&gt;steps_between(&amp;amp;a, &amp;amp;b) != None&lt;/code&gt; ; 이것은 &lt;code&gt;b&lt;/code&gt; 에 도달하기 위해 &lt;code&gt;usize::MAX&lt;/code&gt; 단계 이상이 필요한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="d217a13df9cefce26828e70c341f97e6fe273cac" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; also lets you mutate every element in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">참고 것을 &lt;code&gt;drain_filter&lt;/code&gt; 는 또한 관계없이 유지하거나 제거 할 수 있는지 여부, 필터 폐쇄의 모든 요소를 변이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98dacb5f160d6bac2dc7474d61b47f1366bd10c0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; lets you mutate every element in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">&lt;code&gt;drain_filter&lt;/code&gt; 를 사용하면 필터 유지 또는 제거 여부에 관계없이 필터 클로저의 모든 요소 를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c2297eec650eb177080c75bea870e375a760bc0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; lets you mutate every value in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">&lt;code&gt;drain_filter&lt;/code&gt; 를 사용하면 유지 또는 제거 여부에 관계없이 필터 클로저의 모든 값 을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="900305edc91345ae356f030caba1b6142733f009" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;iter.filter(f).next()&lt;/code&gt; is equivalent to &lt;code&gt;iter.find(f)&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;iter.filter(f).next()&lt;/code&gt; 에 해당 &lt;code&gt;iter.find(f)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7d482051dadae6146f69f3e213d64c34dd92558" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;iter.find(f)&lt;/code&gt; is equivalent to &lt;code&gt;iter.filter(f).next()&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;iter.find(f)&lt;/code&gt; 동일하다 &lt;code&gt;iter.filter(f).next()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a3d7e41ea7c72a3b5b7e84cc631a89a603d2cd0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ptr::drop_in_place&lt;/code&gt; already performs this check, so if your workload can be reduced to some small number of drop_in_place calls, using this is unnecessary. In particular note that you can drop_in_place a slice, and that will do a single needs_drop check for all the values.</source>
          <target state="translated">하는 것으로 &lt;code&gt;ptr::drop_in_place&lt;/code&gt; 이미이 불필요하여, 작업 부하가 drop_in_place 통화의 일부 적은 수의 감소시킬 수있는 경우에는이 검사를 수행합니다. 특히 슬라이스를 drop_in_place 할 수 있으며 모든 값에 대해 단일 needs_drop 검사를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="437bc8fdeeb2ba2175b3e963d9a28d86c8a4a21f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;query&lt;/code&gt; is now a &lt;code&gt;String&lt;/code&gt; rather than a string slice, because calling &lt;code&gt;to_lowercase&lt;/code&gt; creates new data rather than referencing existing data. Say the query is &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt;, as an example: that string slice doesn&amp;rsquo;t contain a lowercase &lt;code&gt;u&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt; for us to use, so we have to allocate a new &lt;code&gt;String&lt;/code&gt; containing &lt;code&gt;&quot;rust&quot;&lt;/code&gt;. When we pass &lt;code&gt;query&lt;/code&gt; as an argument to the &lt;code&gt;contains&lt;/code&gt; method now, we need to add an ampersand because the signature of &lt;code&gt;contains&lt;/code&gt; is defined to take a string slice.</source>
          <target state="translated">참고 &lt;code&gt;query&lt;/code&gt; 지금이다 &lt;code&gt;String&lt;/code&gt; 호출하기 때문이 아니라 문자열 조각 &lt;code&gt;to_lowercase&lt;/code&gt; 하면 기존 데이터를 참조하는 것이 아니라 새로운 데이터를 생성한다. 예를 들어 쿼리가 &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; 라고 가정하십시오 . 문자열 슬라이스에 소문자 &lt;code&gt;u&lt;/code&gt; 또는 &lt;code&gt;t&lt;/code&gt; 가 포함되어 있지 않으므로 &lt;code&gt;&quot;rust&quot;&lt;/code&gt; 가 포함 된 새 &lt;code&gt;String&lt;/code&gt; 을 할당해야합니다 . 우리가 통과 할 때 &lt;code&gt;query&lt;/code&gt; (가)에 인수로 &lt;code&gt;contains&lt;/code&gt; 지금 방법을, 우리의 서명 때문에 앰퍼샌드를 추가 할 필요가 &lt;code&gt;contains&lt;/code&gt; 문자열 조각을 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d0952252c7abd133f9767b9cae9e5576b814cc56" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;std::env::args&lt;/code&gt; will panic if any argument contains invalid Unicode. If your program needs to accept arguments containing invalid Unicode, use &lt;code&gt;std::env::args_os&lt;/code&gt; instead. That function returns an iterator that produces &lt;code&gt;OsString&lt;/code&gt; values instead of &lt;code&gt;String&lt;/code&gt; values. We&amp;rsquo;ve chosen to use &lt;code&gt;std::env::args&lt;/code&gt; here for simplicity, because &lt;code&gt;OsString&lt;/code&gt; values differ per platform and are more complex to work with than &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">참고 &lt;code&gt;std::env::args&lt;/code&gt; 인수가 유효하지 않은 유니 코드가 포함되어있는 경우 당황 할 것이다. 프로그램이 유효하지 않은 유니 코드를 포함하는 인수를 승인해야하는 경우 &lt;code&gt;std::env::args_os&lt;/code&gt; 대신 사용하십시오. 이 함수는 반복자를 생성합니다. &lt;code&gt;OsString&lt;/code&gt; &lt;code&gt;String&lt;/code&gt; 값 대신 OsString 값 합니다. &lt;code&gt;OsString&lt;/code&gt; 값은 플랫폼마다 다르고 &lt;code&gt;String&lt;/code&gt; 값 보다 다루기 가 더 복잡 하므로 여기서는 단순성 을 위해 &lt;code&gt;std::env::args&lt;/code&gt; 를 사용하기로 선택했습니다 .</target>
        </trans-unit>
        <trans-unit id="46299fa0ac2a6d6905de493039f518d4e56af3e6" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;zip&lt;/code&gt; produces only four pairs; the theoretical fifth pair &lt;code&gt;(5, None)&lt;/code&gt; is never produced because &lt;code&gt;zip&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt; when either of its input iterators return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;zip&lt;/code&gt; 만 4 쌍의 생산; 이론적 다섯 쌍 &lt;code&gt;(5, None)&lt;/code&gt; 때문에 생산되지 않는다 &lt;code&gt;zip&lt;/code&gt; 리턴 &lt;code&gt;None&lt;/code&gt; 입력 반복자 중 반환하지 않는 경우 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df23fedf4cb715b65ef5d705d642f0cedf378647" translate="yes" xml:space="preserve">
          <source>Note that Rust does not have a notion of optional function arguments or variadic functions (except for its C-FFI).</source>
          <target state="translated">Rust에는 선택적 함수 인수 나 가변 함수 (C-FFI 제외)라는 개념이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9dba02396ec6e8b7b0a98dc4c9d2e9628008b426" translate="yes" xml:space="preserve">
          <source>Note that a &quot;best effort&quot; is made to ensure that destructors for types stored in thread local storage are run, but not all platforms can guarantee that destructors will be run for all types in thread local storage. For example, there are a number of known caveats where destructors are not run:</source>
          <target state="translated">스레드 로컬 스토리지에 저장된 유형의 소멸자가 실행되도록하기 위해 &quot;최선의 노력&quot;이 수행되지만 모든 플랫폼이 스레드 로컬 스토리지의 모든 유형에 대해 소멸자가 실행되도록 보장 할 수는 없습니다. 예를 들어, 소멸자가 실행되지 않는 알려진 몇 가지주의 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa61dce391cdbcb5b806d9a3fb49147f0dba491d" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;()&lt;/code&gt;-returning &lt;code&gt;main&lt;/code&gt; implicitly results in a successful termination, so there's no need to return this from &lt;code&gt;main&lt;/code&gt; unless you're also returning other possible codes.</source>
          <target state="translated">참고 &lt;code&gt;()&lt;/code&gt; -returning &lt;code&gt;main&lt;/code&gt; 성공적인 종료에 암시 적으로 결과는, 그래서에서이를 반환 할 필요가 없습니다 &lt;code&gt;main&lt;/code&gt; 당신은 또한 다른 가능한 코드를 반환하지 않는 한이.</target>
        </trans-unit>
        <trans-unit id="8c3f037daacb11aa4c63650c08cd568774329dcc" translate="yes" xml:space="preserve">
          <source>Note that a capture will either move or borrow a variable, but in this situation, the closure is borrowing the variable. Take a look at http://rustbyexample.com/fn/closures/capture.html for more information about capturing.</source>
          <target state="translated">캡처는 변수를 이동하거나 빌리지 만이 상황에서 클로저는 변수를 빌립니다. 캡처에 대한 자세한 내용은 http://rustbyexample.com/fn/closures/capture.html을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d28236ceeda3d941466d94520f9be31d9496ffc8" translate="yes" xml:space="preserve">
          <source>Note that a capture will either move or borrow a variable, but in this situation, the closure is borrowing the variable. Take a look at the chapter on &lt;a href=&quot;https://doc.rust-lang.org/stable/rust-by-example/fn/closures/capture.html&quot;&gt;Capturing&lt;/a&gt; in Rust By Example for more information.</source>
          <target state="translated">캡처는 변수를 이동하거나 차용하지만이 상황에서 클로저는 변수를 차용합니다. 더 많은 정보는 예제로 Rust 에서 &lt;a href=&quot;https://doc.rust-lang.org/stable/rust-by-example/fn/closures/capture.html&quot;&gt;캡처&lt;/a&gt; 하기 장 을보세요.</target>
        </trans-unit>
        <trans-unit id="b647009da3543b51ed32c9ce05f0008653d4bcc6" translate="yes" xml:space="preserve">
          <source>Note that a matcher is merely a token tree. A &quot;simple NT&quot;, as mentioned above, is an meta-variable NT; thus it is a non-repetition. For example, &lt;code&gt;$foo:ty&lt;/code&gt; is a simple NT but &lt;code&gt;$($foo:ty)+&lt;/code&gt; is a complex NT.</source>
          <target state="translated">매처는 단지 토큰 트리 일뿐입니다. 상기 언급 된 &quot;단순 NT&quot;는 메타-변수 NT이고; 따라서 그것은 비 반복입니다. 예를 들어 &lt;code&gt;$foo:ty&lt;/code&gt; 는 단순한 NT이지만 &lt;code&gt;$($foo:ty)+&lt;/code&gt; 는 복잡한 NT입니다.</target>
        </trans-unit>
        <trans-unit id="166c645f512c5060e3e63517e9e2f60db5770e99" translate="yes" xml:space="preserve">
          <source>Note that a reference&amp;rsquo;s scope starts from where it is introduced and continues through the last time that reference is used. For instance, this code will compile because the last usage of the immutable references occurs before the mutable reference is introduced:</source>
          <target state="translated">참조의 범위는 소개 된 곳에서 시작하여 해당 참조가 마지막으로 사용될 때까지 계속됩니다. 예를 들어, 변경 불가능한 참조가 도입되기 전에 변경 불가능한 참조의 마지막 사용이 발생하기 때문에이 코드는 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="f3f4807c52376e81ba95b7f4b622c918a83cf1d4" translate="yes" xml:space="preserve">
          <source>Note that a successful send does &lt;em&gt;not&lt;/em&gt; guarantee that the receiver will ever see the data if there is a buffer on this channel. Items may be enqueued in the internal buffer for the receiver to receive at a later time. If the buffer size is 0, however, the channel becomes a rendezvous channel and it guarantees that the receiver has indeed received the data if this function returns success.</source>
          <target state="translated">성공적인 전송은 &lt;em&gt;&lt;/em&gt; 한다고해서이 채널에 버퍼가있는 경우 수신자가 데이터를 볼 수있는&lt;em&gt; 아닙니다&lt;/em&gt; . 수신기가 나중에 수신 할 수 있도록 내부 버퍼에 항목을 큐에 넣을 수 있습니다. 그러나 버퍼 크기가 0이면 채널이 랑데부 채널이되고이 함수가 성공을 반환하면 수신자가 실제로 데이터를 수신했음을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="1f0335bd5206c4df046874965f0d18fc2183ed51" translate="yes" xml:space="preserve">
          <source>Note that accessing the value inside a &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; is safe. This means that a &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; whose content has been dropped must not be exposed through a public safe API. Correspondingly, &lt;code&gt;ManuallyDrop::drop&lt;/code&gt; is unsafe.</source>
          <target state="translated">&lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; 내부의 값에 액세스하는 것은 안전합니다. 즉 , 콘텐츠가 삭제 된 &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; 는 공용 안전 API를 통해 노출되지 않아야합니다. 따라서, &lt;code&gt;ManuallyDrop::drop&lt;/code&gt; 은 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5885b8aa2d181f8795166dedd7f6344e9a60f6b3" translate="yes" xml:space="preserve">
          <source>Note that alignment may not be implemented by some types. In particular, it is not generally implemented for the &lt;code&gt;Debug&lt;/code&gt; trait. A good way to ensure padding is applied is to format your input, then pad this resulting string to obtain your output:</source>
          <target state="translated">일부 유형에서는 정렬이 구현되지 않을 수 있습니다. 특히 일반적으로 &lt;code&gt;Debug&lt;/code&gt; 특성에 대해서는 구현되지 않습니다 . 패딩이 적용되는지 확인하는 좋은 방법은 입력 형식을 지정한 다음 결과 문자열을 패딩하여 출력을 얻는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e3a19fce9bb891c546eeeb563b1b7a91ed25675f" translate="yes" xml:space="preserve">
          <source>Note that alignment may not be implemented by some types. In particular, it is not generally implemented for the &lt;code&gt;Debug&lt;/code&gt; trait. A good way to ensure padding is applied is to format your input, then use this resulting string to pad your output.</source>
          <target state="translated">일부 유형에서는 정렬이 구현되지 않을 수 있습니다. 특히, 일반적으로 &lt;code&gt;Debug&lt;/code&gt; 특성에 . 패딩이 적용되도록하는 좋은 방법은 입력을 포맷 한 다음이 결과 문자열을 사용하여 출력을 채우는 것입니다.</target>
        </trans-unit>
        <trans-unit id="76db1b0ab7636a80673dac1a141ed05d052cb403" translate="yes" xml:space="preserve">
          <source>Note that all &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s, and can be cast to one with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">모든 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 은 유효한 &lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 이며 다음과 같이 캐스트 할 수 있습니다. &lt;code&gt;as&lt;/code&gt; 다음 같이 .</target>
        </trans-unit>
        <trans-unit id="516c2ce158a14ccb1ab369bf0a62cbade5443e81" translate="yes" xml:space="preserve">
          <source>Note that all &lt;code&gt;char&lt;/code&gt;s are valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s, and can be cast to one with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">참고 모든 것을 &lt;code&gt;char&lt;/code&gt; 의가 유효 &lt;a href=&quot;primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 들, 그리고 하나에 캐스트 할 수 있습니다 &lt;code&gt;as&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f0494b2e843f4a073b41bb1890333a63fc3eaceb" translate="yes" xml:space="preserve">
          <source>Note that all elements between the end and the returned element will be consumed, including the returned element. This also means that calling &lt;code&gt;nth_back(0)&lt;/code&gt; multiple times on the same iterator will return different elements.</source>
          <target state="translated">반환 된 요소를 포함하여 끝과 반환 된 요소 사이의 모든 요소가 사용됩니다. 이것은 또한 &lt;code&gt;nth_back(0)&lt;/code&gt; 동일한 반복자에서 nth_back (0)을 여러 번 하면 다른 요소가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="50ea5f0e3ab7dc58cad2b538ddb240e9c4984ee9" translate="yes" xml:space="preserve">
          <source>Note that all preceding elements, as well as the returned element, will be consumed from the iterator. That means that the preceding elements will be discarded, and also that calling &lt;code&gt;nth(0)&lt;/code&gt; multiple times on the same iterator will return different elements.</source>
          <target state="translated">반환 된 요소뿐만 아니라 모든 이전 요소는 반복자에서 사용됩니다. 즉, 이전 요소는 삭제되고 &lt;code&gt;nth(0)&lt;/code&gt; 동일한 반복자에서 nth (0)을 여러 번 하면 다른 요소가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="491da8d1616c74f297c93c3f76ed9c42830ffa59" translate="yes" xml:space="preserve">
          <source>Note that any code in earlier iterations of &lt;em&gt;The Rust Programming Language&lt;/em&gt; that compiled will continue to compile without &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in the project&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;, even as you update the Rust compiler version you&amp;rsquo;re using. That&amp;rsquo;s Rust&amp;rsquo;s backward compatibility guarantees at work!</source>
          <target state="translated">컴파일 된 &lt;em&gt;Rust 프로그래밍 언어&lt;/em&gt; 의 이전 반복에 &lt;em&gt;있는&lt;/em&gt; 모든 코드 는 사용중인 Rust 컴파일러 버전을 업데이트하더라도 프로젝트의 &lt;em&gt;Cargo.toml&lt;/em&gt; 에서 &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; 없이 계속 컴파일됩니다 . 이것이 바로 Rust의 하위 호환성 보장입니다!&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8557ae8a9f894db68722639fc1170d53ad338fd1" translate="yes" xml:space="preserve">
          <source>Note that any code in the first printing of &lt;em&gt;The Rust Programming Language&lt;/em&gt; that compiled will continue to compile without &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in the project&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;, even as you update the Rust compiler version you&amp;rsquo;re using. That&amp;rsquo;s Rust&amp;rsquo;s backward compatibility guarantees at work!</source>
          <target state="translated">컴파일 된 &lt;em&gt;The Rust Programming Language&lt;/em&gt; 의 첫 번째 인쇄 코드 는 사용중인 Rust 컴파일러 버전을 업데이트하더라도 프로젝트 &lt;em&gt;Cargo.toml&lt;/em&gt; 에서 &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; 없이 계속 컴파일됩니다 . 그것은 직장에서 Rust의 이전 버전과의 호환성을 보장합니다!&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="816a2f31fb1f17b4e41f02fda3eaa37e852b4d6e" translate="yes" xml:space="preserve">
          <source>Note that any leftover data in the internal buffer is lost.</source>
          <target state="translated">내부 버퍼의 남은 데이터는 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="2a041883f7bee5eb6e6f55708c727c8ab3a3ed00" translate="yes" xml:space="preserve">
          <source>Note that any leftover data in the internal buffer is lost. Therefore, a following read from the underlying reader may lead to data loss.</source>
          <target state="translated">내부 버퍼에 남은 데이터는 모두 손실됩니다. 따라서 기본 판독기에서 다음 읽기로 인해 데이터가 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45719b2fc23ab9d812a1864bec0c46011337290e" translate="yes" xml:space="preserve">
          <source>Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run.</source>
          <target state="translated">이 함수는 절대 반환하지 않고 프로세스를 종료하므로 현재 스택 또는 다른 스레드 스택에서 소멸자가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ee637b0f22097f2447433c9e30b0952e702b8b7" translate="yes" xml:space="preserve">
          <source>Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run. If a clean shutdown is needed it is recommended to only call this function at a known point where there are no more destructors left to run.</source>
          <target state="translated">이 함수는 절대 반환하지 않고 프로세스를 종료하므로 현재 스택 또는 다른 스레드 스택에서 소멸자가 실행되지 않습니다. 클린 셧다운이 필요한 경우, 더 이상 소멸자가 남아 있지 않은 알려진 지점에서만이 함수를 호출하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="25d3aa7c2b95febeff16d7f5e6ce36387044d531" translate="yes" xml:space="preserve">
          <source>Note that because we defined the &lt;code&gt;Summary&lt;/code&gt; trait and the &lt;code&gt;NewsArticle&lt;/code&gt; and &lt;code&gt;Tweet&lt;/code&gt; types in the same &lt;em&gt;lib.rs&lt;/em&gt; in Listing 10-13, they&amp;rsquo;re all in the same scope. Let&amp;rsquo;s say this &lt;em&gt;lib.rs&lt;/em&gt; is for a crate we&amp;rsquo;ve called &lt;code&gt;aggregator&lt;/code&gt; and someone else wants to use our crate&amp;rsquo;s functionality to implement the &lt;code&gt;Summary&lt;/code&gt; trait on a struct defined within their library&amp;rsquo;s scope. They would need to bring the trait into their scope first. They would do so by specifying &lt;code&gt;use aggregator::Summary;&lt;/code&gt;, which then would enable them to implement &lt;code&gt;Summary&lt;/code&gt; for their type. The &lt;code&gt;Summary&lt;/code&gt; trait would also need to be a public trait for another crate to implement it, which it is because we put the &lt;code&gt;pub&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; in Listing 10-12.</source>
          <target state="translated">Listing 10-13 의 동일한 &lt;em&gt;lib.rs&lt;/em&gt; 에서 &lt;code&gt;Summary&lt;/code&gt; 특성과 &lt;code&gt;NewsArticle&lt;/code&gt; 및 &lt;code&gt;Tweet&lt;/code&gt; 유형을 정의 &lt;em&gt;했으므로&lt;/em&gt; 모두 동일한 범위에 있습니다. 이 &lt;em&gt;lib.rs&lt;/em&gt; 는 우리가 &lt;code&gt;aggregator&lt;/code&gt; 라고 부르는 상자를위한 것이고 다른 누군가는 우리 상자의 기능을 사용 하여 라이브러리 범위 내에서 정의 된 구조체에 &lt;code&gt;Summary&lt;/code&gt; 특성 을 구현 하려고합니다. 그들은 먼저 특성을 범위로 가져와야합니다. &lt;code&gt;use aggregator::Summary;&lt;/code&gt; 지정 하면 됩니다 . 그러면 해당 유형에 대한 &lt;code&gt;Summary&lt;/code&gt; 을 구현할 수 있습니다 . &lt;code&gt;Summary&lt;/code&gt; trait는 또 다른 상자가 그것을 구현하기 위해 공개적인 trait 일 필요가있을 것이다. 이것은 Listing 10-12에서 &lt;code&gt;pub&lt;/code&gt; 키워드를 &lt;code&gt;trait&lt;/code&gt; 앞에 두기 때문이다 .</target>
        </trans-unit>
        <trans-unit id="5c2746c98858012c4f3f702901d1b8fef09f722f" translate="yes" xml:space="preserve">
          <source>Note that because we&amp;rsquo;ve used only one generic type to define &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;, this definition says that the &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct is generic over some type &lt;code&gt;T&lt;/code&gt;, and the fields &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;em&gt;both&lt;/em&gt; that same type, whatever that type may be. If we create an instance of a &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; that has values of different types, as in Listing 10-7, our code won&amp;rsquo;t compile.</source>
          <target state="translated">우리가 정의하는 하나의 일반적인 유형을 사용했기 때문에 참고 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 이 정의는 말한다 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 구조체는 몇 가지 유형을 통해 제네릭 &lt;code&gt;T&lt;/code&gt; , 그리고 필드는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 있습니다 &lt;em&gt;모두&lt;/em&gt; 같은 유형, 어떤 유형 아마도. Listing 10-7과 같이 다른 유형의 값 을 가진 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 인스턴스를 생성하면 코드가 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee83d2a98a726eb4d0819a08ff35a51d203bcc33" translate="yes" xml:space="preserve">
          <source>Note that capturing a backtrace can be an expensive operation on some platforms, so this should be used with caution in performance-sensitive parts of code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b44ef6f5d455a7524a366399e247106ccce266f" translate="yes" xml:space="preserve">
          <source>Note that dropping a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; will never call &lt;code&gt;T&lt;/code&gt;'s drop code. It is your responsibility to make sure &lt;code&gt;T&lt;/code&gt; gets dropped if it got initialized.</source>
          <target state="translated">&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 를 드롭하면 &lt;code&gt;T&lt;/code&gt; 의 드롭 코드를 호출하지 않습니다 . &lt;code&gt;T&lt;/code&gt; 가 초기화되면 T 가 삭제 되도록하는 것은 귀하의 책임 입니다.</target>
        </trans-unit>
        <trans-unit id="1ca6aa2552d35e463ab42d6ea3dc8e136eb4776f" translate="yes" xml:space="preserve">
          <source>Note that due to method call deref coercion, simply calling a trait method will act like they work on references as well as they do on owned values! The implementations described here are meant for generic contexts, where the final type &lt;code&gt;T&lt;/code&gt; is a type parameter or otherwise not locally known.</source>
          <target state="translated">메소드 호출 참조 강제 변환으로 인해 단순히 특성 메소드를 호출하면 참조 값과 소유 값에서 작동하는 것처럼 작동합니다! 여기에 설명 된 구현은 최종 컨텍스트 &lt;code&gt;T&lt;/code&gt; 가 형식 매개 변수이거나 로컬에 알려지지 않은 일반 컨텍스트를위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="1de74eaeec2a2aa72b741e1bb4ba4ee5991fbccf" translate="yes" xml:space="preserve">
          <source>Note that empty arrays &lt;code&gt;[T; 0]&lt;/code&gt; have the same alignment requirement as the element type &lt;code&gt;T&lt;/code&gt;. Also note that the error is conservatively reported even when the alignment of the zero-sized type is less than or equal to the data field's alignment.</source>
          <target state="translated">빈 배열 &lt;code&gt;[T; 0]&lt;/code&gt; 은 요소 유형 &lt;code&gt;T&lt;/code&gt; 와 동일한 정렬 요구 사항을 갖습니다 . 또한 크기가 0 인 유형의 정렬이 데이터 필드의 정렬보다 작거나 같더라도 오류가 보수적으로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="03aca4023a1e7014a85e0b59db326c1054412c53" translate="yes" xml:space="preserve">
          <source>Note that environment variable names are case-insensitive (but case-preserving) on Windows, and case-sensitive on all other platforms.</source>
          <target state="translated">환경 변수 이름은 Windows에서 대소 문자를 구분하지 않지만 대소 문자를 구분하지만 다른 모든 플랫폼에서는 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="af3176ad62da7d96f31254f9c337151434d91850" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL and properly aligned.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 크기가 &lt;code&gt;0&lt;/code&gt; 인 경우에도 포인터는 NULL이 아니고 올바르게 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="58d2d77f2d5d331bda29fe5d0af29fd62177b001" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 크기가 &lt;code&gt;0&lt;/code&gt; 인 경우에도 포인터는 NULL이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="aca2272e34501c47a8d86a387930c81a45160055" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointers must be non-NULL and properly aligned.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 크기가 &lt;code&gt;0&lt;/code&gt; 인 경우에도 포인터는 NULL이 아니고 올바르게 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9806a4590799343d8c64ae41117a4958b8386ffa" translate="yes" xml:space="preserve">
          <source>Note that even if the effectively copied size (&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;) is &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL and properly aligned.</source>
          <target state="translated">효과적으로 복사 된 크기 ( &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; )가 &lt;code&gt;0&lt;/code&gt; 이라도 포인터는 NULL이 아니고 올바르게 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="851cd0d9eb90b03ed21845664c6d4ace9ece4acd" translate="yes" xml:space="preserve">
          <source>Note that even if the effectively copied size (&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;) is &lt;code&gt;0&lt;/code&gt;, the pointers must be non-NULL and properly aligned.</source>
          <target state="translated">효과적으로 복사 된 크기 ( &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; )가 &lt;code&gt;0&lt;/code&gt; 이라도 포인터는 NULL이 아니고 올바르게 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6c1ad3562574888b0c8c8e999ed33eff7030ffcd" translate="yes" xml:space="preserve">
          <source>Note that even if this panics, the value is considered to be dropped; you must not cause &lt;code&gt;drop&lt;/code&gt; to be called again. This is normally automatically handled by the compiler, but when using unsafe code, can sometimes occur unintentionally, particularly when using &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;ptr::drop_in_place&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 패닉이 발생하더라도 값은 삭제 된 것으로 간주됩니다. &lt;code&gt;drop&lt;/code&gt; 이 다시 호출 되지 않도록해야 합니다. 이것은 일반적으로 컴파일러에 의해 자동으로 처리되지만 안전하지 않은 코드를 사용할 때, 특히 &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt; &lt;code&gt;ptr::drop_in_place&lt;/code&gt; &lt;/a&gt; 사용할 때 의도하지 않게 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e70094585dad750582f0b20dfaa8a3722d32400a" translate="yes" xml:space="preserve">
          <source>Note that even though the standard library contains a definition for &lt;code&gt;IpAddr&lt;/code&gt;, we can still create and use our own definition without conflict because we haven&amp;rsquo;t brought the standard library&amp;rsquo;s definition into our scope. We&amp;rsquo;ll talk more about bringing types into scope in Chapter 7.</source>
          <target state="translated">표준 라이브러리에 &lt;code&gt;IpAddr&lt;/code&gt; 에 대한 정의가 포함되어 있어도 표준 라이브러리 정의를 범위로 가져 오지 않았으므로 충돌없이 자체 정의를 작성하고 사용할 수 있습니다. 우리는 7 장에서 타입을 범위에 포함시키는 것에 대해 더 이야기 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="31c2c0947f08a70cf66a5f5539b0e2dc387b144b" translate="yes" xml:space="preserve">
          <source>Note that future platforms may be added that also do not have support for some atomic operations. Maximally portable code will want to be careful about which atomic types are used. &lt;code&gt;AtomicUsize&lt;/code&gt; and &lt;code&gt;AtomicIsize&lt;/code&gt; are generally the most portable, but even then they're not available everywhere. For reference, the &lt;code&gt;std&lt;/code&gt; library requires pointer-sized atomics, although &lt;code&gt;core&lt;/code&gt; does not.</source>
          <target state="translated">일부 원자 연산을 지원하지 않는 향후 플랫폼이 추가 될 수 있습니다. 이식성이 뛰어난 코드는 어떤 원자 유형이 사용되는지주의를 기울여야합니다. &lt;code&gt;AtomicUsize&lt;/code&gt; 및 &lt;code&gt;AtomicIsize&lt;/code&gt; 는 일반적으로 가장 이식성이 뛰어나지 만 어느 곳에서도 사용할 수 없습니다. 참고로 &lt;code&gt;std&lt;/code&gt; 라이브러리에는 포인터 크기의 원자가 필요하지만 &lt;code&gt;core&lt;/code&gt; 은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59fbfedac3227479331b23c365329ce5aabd1a1b" translate="yes" xml:space="preserve">
          <source>Note that generic arguments for enum variant constructors go after the variant, not after the enum. For example, you would write &lt;code&gt;Option::None::&amp;lt;u32&amp;gt;&lt;/code&gt;, rather than &lt;code&gt;Option::&amp;lt;u32&amp;gt;::None&lt;/code&gt;.</source>
          <target state="translated">열거 형 변형 생성자에 대한 일반 인수는 열거 형이 아닌 변형을 따릅니다. 예를 들어 &lt;code&gt;Option::&amp;lt;u32&amp;gt;::None&lt;/code&gt; 대신 &lt;code&gt;Option::None::&amp;lt;u32&amp;gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b6e3284112fc89aa89918b12b076295886a2da9b" translate="yes" xml:space="preserve">
          <source>Note that here the call to &lt;a href=&quot;mem/fn.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; is for clarity - it indicates that we are done with the given value and it should be destroyed.</source>
          <target state="translated">여기서 &lt;a href=&quot;mem/fn.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; 은 명확성을 기하기위한 것입니다. 이는 주어진 값으로 완료되었으며 파기되어야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0753b6373f6f1d65a2eb747fb24056dce4b9d211" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;Self::Item&lt;/code&gt; is only &lt;code&gt;PartialOrd&lt;/code&gt;, but not &lt;code&gt;Ord&lt;/code&gt;, the above definition implies that this function returns &lt;code&gt;false&lt;/code&gt; if any two consecutive items are not comparable.</source>
          <target state="translated">참고 경우에 것을 &lt;code&gt;Self::Item&lt;/code&gt; 아니라 &lt;code&gt;PartialOrd&lt;/code&gt; 있지만 &lt;code&gt;Ord&lt;/code&gt; , 위의 정의는이 함수가 반환 된 것을 의미한다 &lt;code&gt;false&lt;/code&gt; 두 연속 항목을 비교하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="b91bc8063fbfefef1d18b41e7b347e2c6fec2abd" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; both point to the same file, then the file will likely get truncated by this operation.</source>
          <target state="translated">만약합니다 &lt;code&gt;from&lt;/code&gt; 와 &lt;code&gt;to&lt;/code&gt; 동일한 파일에 두 점, 다음 파일을 가능성이 작업에 의해 잘릴 것입니다.</target>
        </trans-unit>
        <trans-unit id="9d3e37ab6666f6f897eee8b56db717458b005ac3" translate="yes" xml:space="preserve">
          <source>Note that if a function takes multiple type arguments but you want the compiler to infer some of them, you can use type placeholders:</source>
          <target state="translated">함수가 여러 유형의 인수를 취하지 만 컴파일러가 그 중 일부를 유추하도록하려면 유형 플레이스 홀더를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd535d6f6d4b53f3c244d297f7914a6181acf961" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; items include function or closure references, which themselves include references, the compiler will first try the standard elision rules. If it is unable to resolve the lifetimes by its usual rules, then it will error. By way of example:</source>
          <target state="translated">경우 생성합니다 &lt;code&gt;static&lt;/code&gt; 또는 &lt;code&gt;const&lt;/code&gt; 를 항목 자체가 참조를 포함하는 함수 또는 폐쇄 참조를 포함, 컴파일러는 먼저 표준 생략 규칙을 다할 것입니다. 일반적인 규칙으로 수명을 해결할 수 없으면 오류가 발생합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="9ef199153d75a42174c42cff6fb7c6c1476957fd" translate="yes" xml:space="preserve">
          <source>Note that implementations do not necessarily have to provide access to the inner-most source of a pipeline. A stateful intermediate adapter might eagerly evaluate a part of the pipeline and expose its internal storage as source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0702815af49297e37a4e0bb02d65562e392c8a7" translate="yes" xml:space="preserve">
          <source>Note that in Rust, structs can only contain an unsized type if the field containing the unsized type is the last and only unsized type field in the struct.</source>
          <target state="translated">Rust에서 구조체는 크기가 지정되지 않은 유형을 포함하는 필드가 구조체에서 마지막으로 유일한 크기가 지정되지 않은 유형 필드 인 경우 크기가 지정되지 않은 유형 만 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="523c7fb2b8819c356a6b0490b2a0d8371495e11f" translate="yes" xml:space="preserve">
          <source>Note that in some languages and test frameworks, the parameters to the functions that assert two values are equal are called &lt;code&gt;expected&lt;/code&gt; and &lt;code&gt;actual&lt;/code&gt;, and the order in which we specify the arguments matters. However, in Rust, they&amp;rsquo;re called &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;, and the order in which we specify the value we expect and the value that the code under test produces doesn&amp;rsquo;t matter. We could write the assertion in this test as &lt;code&gt;assert_eq!(add_two(2), 4)&lt;/code&gt;, which would result in a failure message that displays &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; and that &lt;code&gt;left&lt;/code&gt; was &lt;code&gt;5&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; was &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">참고 일부 언어와 테스트 프레임 워크, 두 값이 같은 주장이라고하는 기능 매개 변수의 &lt;code&gt;expected&lt;/code&gt; 과 &lt;code&gt;actual&lt;/code&gt; , 우리가 인수 문제를 지정하는 순서. 그러나 Rust에서는 그것들을 &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; 라고 부르며 , 우리가 기대하는 값과 테스트중인 코드가 생성하는 값을 지정하는 순서는 중요하지 않습니다. 이 테스트에서 &lt;code&gt;assert_eq!(add_two(2), 4)&lt;/code&gt; 로 어설 션을 작성할 수 있으며 어설 &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; 를 표시하는 실패 메시지가 나타납니다 :`(left == right)` 그리고 &lt;code&gt;left&lt;/code&gt; 는 &lt;code&gt;5&lt;/code&gt; 이고 &lt;code&gt;right&lt;/code&gt; 는 &lt;code&gt;4&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bd234e5e31b58a835a7427c6ccb9ea99860e96d4" translate="yes" xml:space="preserve">
          <source>Note that introducing another &lt;code&gt;struct&lt;/code&gt; just to have a place for the other attributes may have unintended side effects on the representation:</source>
          <target state="translated">다른 속성을위한 장소를 갖기 위해 다른 &lt;code&gt;struct&lt;/code&gt; 를 도입 하면 의도 치 않은 부작용이 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6abfc6c98c1133dd19e39dfc110c77706058a67e" translate="yes" xml:space="preserve">
          <source>Note that it is impossible to link in native dynamic dependencies to a static library, and in this case warnings will be printed about all unlinked native dynamic dependencies.</source>
          <target state="translated">기본 동적 종속성에서 정적 라이브러리에 링크 할 수 없으며이 경우 연결되지 않은 모든 기본 동적 종속성에 대한 경고가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="213f52c82816211eed8a84af1c6306ce11d2042d" translate="yes" xml:space="preserve">
          <source>Note that it isn&amp;rsquo;t possible to call the default implementation from an overriding implementation of that same method.</source>
          <target state="translated">동일한 메소드의 대체 구현에서 기본 구현을 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="431dfb333d11627033bd73c3c12aac0f9ce02166" translate="yes" xml:space="preserve">
          <source>Note that length of a stream can change over time (for example, when data is appended to a file). So calling this method multiple times does not necessarily return the same length each time.</source>
          <target state="translated">스트림 길이는 시간이 지남에 따라 변경 될 수 있습니다 (예 : 데이터가 파일에 추가 될 때). 따라서이 메소드를 여러 번 호출한다고해서 매번 같은 길이를 리턴 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="313ba1495decd5683c08865a1c2d8bbad489994a" translate="yes" xml:space="preserve">
          <source>Note that negating any positive integer will overflow.</source>
          <target state="translated">양의 정수를 부정하면 오버플로됩니다.</target>
        </trans-unit>
        <trans-unit id="0310d257cad5180cd2a5706628685feb28fa8baa" translate="yes" xml:space="preserve">
          <source>Note that no other normalization takes place; in particular, &lt;code&gt;a/c&lt;/code&gt; and &lt;code&gt;a/b/../c&lt;/code&gt; are distinct, to account for the possibility that &lt;code&gt;b&lt;/code&gt; is a symbolic link (so its parent isn't &lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">다른 정규화는 일어나지 않습니다. 특히, &lt;code&gt;a/c&lt;/code&gt; 및 &lt;code&gt;a/b/../c&lt;/code&gt; 는 &lt;code&gt;b&lt;/code&gt; 가 기호 링크 일 가능성을 설명하기 위해 구별 됩니다 (따라서 부모는 &lt;code&gt;a&lt;/code&gt; 가 아님 ).</target>
        </trans-unit>
        <trans-unit id="0f36d8aec30ccdcaddeba64d187fcf335e3e550e" translate="yes" xml:space="preserve">
          <source>Note that not all errors contain a &lt;code&gt;Backtrace&lt;/code&gt;. Also note that a &lt;code&gt;Backtrace&lt;/code&gt; may actually be empty. For more information consult the &lt;code&gt;Backtrace&lt;/code&gt; type itself.</source>
          <target state="translated">모든 오류에 &lt;code&gt;Backtrace&lt;/code&gt; 가 포함되는 것은 아닙니다 . 또한 &lt;code&gt;Backtrace&lt;/code&gt; 는 실제로 비어있을 수 있습니다. 자세한 내용은 &lt;code&gt;Backtrace&lt;/code&gt; 유형 자체를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6048f485eb4e07bdf2aa23e3dab346aa63dbf7f5" translate="yes" xml:space="preserve">
          <source>Note that not all platforms will keep this field update in a file's metadata, for example Windows has an option to disable updating this time when files are accessed and Linux similarly has &lt;code&gt;noatime&lt;/code&gt;.</source>
          <target state="translated">모든 플랫폼이이 필드 업데이트를 파일의 메타 데이터에 보관하지는 않습니다. 예를 들어 Windows는 파일에 액세스하고 Linux에 &lt;code&gt;noatime&lt;/code&gt; 이있을 때 이번에는 업데이트를 비활성화 할 수있는 옵션이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5ed45efedb5980a8a1a6af222c209c849963838" translate="yes" xml:space="preserve">
          <source>Note that nowhere in this output do we see &lt;code&gt;I got the value 4&lt;/code&gt;, which is what is printed when the test that passes runs. That output has been captured. The output from the test that failed, &lt;code&gt;I got the value 8&lt;/code&gt;, appears in the section of the test summary output, which also shows the cause of the test failure.</source>
          <target state="translated">이 출력의 어느 곳에서도 &lt;code&gt;I got the value 4&lt;/code&gt; 못합니다.이 값 은 통과 테스트가 실행될 때 인쇄됩니다. 출력이 캡처되었습니다. 실패한 테스트의 결과 &lt;code&gt;I got the value 8&lt;/code&gt; 테스트 요약 출력 섹션에 표시하고 테스트 실패의 원인도 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5a80c5201601b7cd22253cd99d33bff329ba0af9" translate="yes" xml:space="preserve">
          <source>Note that on multiple calls to &lt;code&gt;poll&lt;/code&gt;, only the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;../task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; passed to the most recent call should be scheduled to receive a wakeup.</source>
          <target state="translated">&lt;code&gt;poll&lt;/code&gt; 에 대한 여러 호출에서 최근 호출로 전달 된 &lt;a href=&quot;../task/struct.context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; 만 깨우기를 받도록 예약해야합니다.</target>
        </trans-unit>
        <trans-unit id="55bd215fbbafcd54535dc669556609d05462d431" translate="yes" xml:space="preserve">
          <source>Note that one cannot pass &lt;code&gt;CannotReallocInPlace&lt;/code&gt; to the &lt;code&gt;handle_alloc_error&lt;/code&gt; function; clients are expected either to be able to recover from &lt;code&gt;grow_in_place&lt;/code&gt; failures without aborting, or to fall back on another reallocation method before resorting to an abort.</source>
          <target state="translated">&lt;code&gt;CannotReallocInPlace&lt;/code&gt; 를 &lt;code&gt;handle_alloc_error&lt;/code&gt; 함수에 전달할 수는 없습니다 . 클라이언트는 중단없이 &lt;code&gt;grow_in_place&lt;/code&gt; 실패 에서 복구 할 수 있거나 중단에 의지하기 전에 다른 재 할당 방법으로 대체 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9605ecaf6269fd2f9ec9b6cd8fec45c27c798c5" translate="yes" xml:space="preserve">
          <source>Note that one cannot pass &lt;code&gt;CannotReallocInPlace&lt;/code&gt; to the &lt;code&gt;handle_alloc_error&lt;/code&gt; function; clients are expected either to be able to recover from &lt;code&gt;shrink_in_place&lt;/code&gt; failures without aborting, or to fall back on another reallocation method before resorting to an abort.</source>
          <target state="translated">&lt;code&gt;CannotReallocInPlace&lt;/code&gt; 를 &lt;code&gt;handle_alloc_error&lt;/code&gt; 함수에 전달할 수는 없습니다 . 클라이언트는 중단없이 &lt;code&gt;shrink_in_place&lt;/code&gt; 실패 에서 복구 하거나 중단에 의지하기 전에 다른 재 할당 방법으로 대체 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6bbee529e21d8d6f27eb0394a352b9a59dfbecb" translate="yes" xml:space="preserve">
          <source>Note that panics in Rust are not always implemented via unwinding, but they may be implemented by aborting the process. If this function is called when panics are implemented this way then this function will abort the process, not trigger an unwind.</source>
          <target state="translated">Rust의 패닉은 항상 해제를 통해 구현되는 것은 아니지만 프로세스를 중단하여 구현할 수 있습니다. 패닉이 이런 식으로 구현 될 때이 함수가 호출되면이 함수는 프로세스를 중단하고 해제를 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e3c061738b40532446b85ef7e5e80f755eaa54c" translate="yes" xml:space="preserve">
          <source>Note that parts of this block are in use:</source>
          <target state="translated">이 블록의 일부가 사용 중입니다.</target>
        </trans-unit>
        <trans-unit id="fff05e35d755803ade4b50f50d29c987f0007787" translate="yes" xml:space="preserve">
          <source>Note that pinning and &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; only affect the pointed-to type &lt;code&gt;P::Target&lt;/code&gt;, not the pointer type &lt;code&gt;P&lt;/code&gt; itself that got wrapped in &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt;. For example, whether or not &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; has no effect on the behavior of &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (here, &lt;code&gt;T&lt;/code&gt; is the pointed-to type).</source>
          <target state="translated">고정 및 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt; 래핑 된 포인터 유형 &lt;code&gt;P&lt;/code&gt; 자체가 아니라 가리키는 &lt;code&gt;P::Target&lt;/code&gt; 유형에만 영향을줍니다 . 예를 들어 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 인지 여부 는 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 의 동작에 영향을주지 않습니다 (여기서 &lt;code&gt;T&lt;/code&gt; 는 지정 대상 유형).</target>
        </trans-unit>
        <trans-unit id="8df6e9ecf182c2febaad6a991ebf5bacd1fab01f" translate="yes" xml:space="preserve">
          <source>Note that pinning and &lt;code&gt;Unpin&lt;/code&gt; only affect the pointed-to type &lt;code&gt;P::Target&lt;/code&gt;, not the pointer type &lt;code&gt;P&lt;/code&gt; itself that got wrapped in &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;. For example, whether or not &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Unpin&lt;/code&gt; has no effect on the behavior of &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (here, &lt;code&gt;T&lt;/code&gt; is the pointed-to type).</source>
          <target state="translated">고정 및 &lt;code&gt;Unpin&lt;/code&gt; 는 &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; 래핑 된 포인터 유형 &lt;code&gt;P&lt;/code&gt; 자체가 아니라 지정된 &lt;code&gt;P::Target&lt;/code&gt; 유형에만 영향을 미칩니다 . 예를 들어 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 가 &lt;code&gt;Unpin&lt;/code&gt; 인지 여부 는 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 의 동작에 영향을 미치지 않습니다 (여기서 &lt;code&gt;T&lt;/code&gt; 는 pointed to type).</target>
        </trans-unit>
        <trans-unit id="2fe7274dabcb32334d2b65bc1dce4238c4a816f1" translate="yes" xml:space="preserve">
          <source>Note that reading updates the slice to point to the yet unread part. The slice will be empty when EOF is reached.</source>
          <target state="translated">읽기는 아직 읽지 않은 부분을 가리 키도록 슬라이스를 업데이트합니다. EOF에 도달하면 슬라이스가 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4175de8081524003025f4bfc586324edc516ca55" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#method.read&quot;&gt;&lt;code&gt;File::read&lt;/code&gt;&lt;/a&gt;, it is not an error to return with a short read.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.file#method.read&quot;&gt; &lt;code&gt;File::read&lt;/code&gt; &lt;/a&gt; 와 유사하게 짧은 읽기로 리턴하는 것은 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="78d8286e3fe0bd2fe84e388fefe8408d278761d1" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#method.write&quot;&gt;&lt;code&gt;File::write&lt;/code&gt;&lt;/a&gt;, it is not an error to return a short write.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.file#method.write&quot;&gt; &lt;code&gt;File::write&lt;/code&gt; &lt;/a&gt; 와 유사하게 짧은 쓰기를 반환하는 것은 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="18a21f083a37ce3c0667ef89806f56b48c052291" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#write.v&quot;&gt;&lt;code&gt;File::write&lt;/code&gt;&lt;/a&gt;, it is not an error to return a short write.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.file#write.v&quot;&gt; &lt;code&gt;File::write&lt;/code&gt; &lt;/a&gt; 와 유사하게 짧은 쓰기를 리턴하는 것은 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c9ab4b26c6a7bf726c988738e7c68f1f0c9fa972" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;code&gt;File::read&lt;/code&gt;, it is not an error to return with a short read. When returning from such a short read, the file pointer is still updated.</source>
          <target state="translated">&lt;code&gt;File::read&lt;/code&gt; 와 유사하게 짧은 읽기로 리턴하는 것은 오류가 아닙니다. 이러한 짧은 읽기에서 돌아올 때 파일 포인터는 여전히 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="1f1bfbbca00b5726c71935536de215a864a82741" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;code&gt;File::write&lt;/code&gt;, it is not an error to return a short write. When returning from such a short write, the file pointer is still updated.</source>
          <target state="translated">&lt;code&gt;File::write&lt;/code&gt; 와 유사하게 짧은 쓰기를 리턴하는 것은 오류가 아닙니다. 이러한 짧은 쓰기에서 돌아올 때 파일 포인터는 여전히 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="eea44851a548460d198f033df0aa2c78011af765" translate="yes" xml:space="preserve">
          <source>Note that some platforms may simply implement this in terms of &lt;a href=&quot;struct.file#method.sync_all&quot;&gt;&lt;code&gt;sync_all&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일부 플랫폼은 단순히 &lt;a href=&quot;struct.file#method.sync_all&quot;&gt; &lt;code&gt;sync_all&lt;/code&gt; &lt;/a&gt; 측면에서 이를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="903a64802e8ba87174caa993876c0922efd29b51" translate="yes" xml:space="preserve">
          <source>Note that stdout is frequently line-buffered by default so it may be necessary to use &lt;a href=&quot;io/trait.write#tymethod.flush&quot;&gt;&lt;code&gt;io::stdout().flush()&lt;/code&gt;&lt;/a&gt; to ensure the output is emitted immediately.</source>
          <target state="translated">stdout은 기본적으로 종종 라인 버퍼링되므로 출력이 즉시 방출되도록 &lt;a href=&quot;io/trait.write#tymethod.flush&quot;&gt; &lt;code&gt;io::stdout().flush()&lt;/code&gt; &lt;/a&gt; 를 사용해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b78b962ade7d55d80fe60c36c51b53741b559cf7" translate="yes" xml:space="preserve">
          <source>Note that thanks to Rust's safety guarantees, accessing global (static) variables requires &lt;code&gt;unsafe&lt;/code&gt; code, assuming we don't use any of the synchronization primitives in this module.</source>
          <target state="translated">Rust의 안전 보장 덕분 에이 모듈에서 동기화 프리미티브를 사용하지 않는다고 가정 할 때 전역 (정적) 변수에 액세스하려면 &lt;code&gt;unsafe&lt;/code&gt; 코드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7e334bbf7d2932e1e0dab50b1bbb42d3e778d93e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; operators short-circuit, i.e., they only evaluate their second operand if it contributes to the result. Since this behavior is not enforceable by traits, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; are not supported as overloadable operators.</source>
          <target state="translated">참고 그 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 와 &lt;code&gt;||&lt;/code&gt; 연산자 단락, 즉 결과에 기여하는 경우에만 두 번째 피연산자를 평가합니다. 이 동작은 특성으로 시행 할 수 없으므로 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 과부하 연산자로 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eabb54c531ee493a23016d47151401e59c37e082" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;*&lt;/code&gt; operator is replaced with a call to the &lt;code&gt;deref&lt;/code&gt; method and then a call to the &lt;code&gt;*&lt;/code&gt; operator just once, each time we use a &lt;code&gt;*&lt;/code&gt; in our code. Because the substitution of the &lt;code&gt;*&lt;/code&gt; operator does not recurse infinitely, we end up with data of type &lt;code&gt;i32&lt;/code&gt;, which matches the &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;assert_eq!&lt;/code&gt; in Listing 15-9.</source>
          <target state="translated">있습니다 &lt;code&gt;*&lt;/code&gt; 운영자가받는 호출로 대체됩니다 &lt;code&gt;deref&lt;/code&gt; 다음 방법과의 호출 &lt;code&gt;*&lt;/code&gt; 한 번만 운영자, 우리가 사용할 때마다 &lt;code&gt;*&lt;/code&gt; 을 우리의 코드에. 의 대체 때문에 &lt;code&gt;*&lt;/code&gt; 의 운영자가 같이 Recurse 무한, 우리는 타입의 데이터와 끝까지하지 않습니다 &lt;code&gt;i32&lt;/code&gt; 성냥, &lt;code&gt;5&lt;/code&gt; 년 &lt;code&gt;assert_eq!&lt;/code&gt; 리스팅 15-9.</target>
        </trans-unit>
        <trans-unit id="42a41979051d804f1901f27167063da0694efa1d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Backtrace::force_capture&lt;/code&gt; function can be used to ignore these environment variables. Also note that the state of environment variables is cached once the first backtrace is created, so altering &lt;code&gt;RUST_LIB_BACKTRACE&lt;/code&gt; or &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; at runtime may not actually change how backtraces are captured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6dbff824203032252330e130f2e622a82a7979" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;FromFn&lt;/code&gt; iterator doesn&amp;rsquo;t make assumptions about the behavior of the closure, and therefore conservatively does not implement &lt;a href=&quot;trait.fusediterator&quot;&gt;&lt;code&gt;FusedIterator&lt;/code&gt;&lt;/a&gt;, or override &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint()&lt;/code&gt;&lt;/a&gt; from its default &lt;code&gt;(0, None)&lt;/code&gt;.</source>
          <target state="translated">있습니다 &lt;code&gt;FromFn&lt;/code&gt; 반복자가 폐쇄의 행동에 대한 가정을하지 않기 때문에 보수적으로 구현하지 않습니다 &lt;a href=&quot;trait.fusediterator&quot;&gt; &lt;code&gt;FusedIterator&lt;/code&gt; 를&lt;/a&gt; , 또는 무시 &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;Iterator::size_hint()&lt;/code&gt; &lt;/a&gt; 기본에서 &lt;code&gt;(0, None)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f63b935f8ce4492cffe03bd17e920a6c5bccf71" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;FromFn&lt;/code&gt; iterator doesn&amp;rsquo;t make assumptions about the behavior of the closure, and therefore conservatively does not implement &lt;a href=&quot;trait.fusediterator&quot;&gt;&lt;code&gt;FusedIterator&lt;/code&gt;&lt;/a&gt;, or override &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint&lt;/code&gt;&lt;/a&gt; from its default &lt;code&gt;(0, None)&lt;/code&gt;.</source>
          <target state="translated">있습니다 &lt;code&gt;FromFn&lt;/code&gt; 반복자가 폐쇄의 행동에 대한 가정을하지 않기 때문에 보수적으로 구현하지 않습니다 &lt;a href=&quot;trait.fusediterator&quot;&gt; &lt;code&gt;FusedIterator&lt;/code&gt; 을&lt;/a&gt; , 또는 오버라이드 (override) &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;Iterator::size_hint&lt;/code&gt; &lt;/a&gt; 기본에서 &lt;code&gt;(0, None)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bea015d687dff2009a1239b5a7393bd8adb473e8" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;SecondaryColor&lt;/code&gt; types aren&amp;rsquo;t listed on the front page, nor is the &lt;code&gt;mix&lt;/code&gt; function. We have to click &lt;code&gt;kinds&lt;/code&gt; and &lt;code&gt;utils&lt;/code&gt; to see them.</source>
          <target state="translated">있습니다 &lt;code&gt;PrimaryColor&lt;/code&gt; 및 &lt;code&gt;SecondaryColor&lt;/code&gt; 유형이 첫 페이지에 나와있는, 나있다되지 않습니다 &lt;code&gt;mix&lt;/code&gt; 기능. &lt;code&gt;kinds&lt;/code&gt; 와 &lt;code&gt;utils&lt;/code&gt; 를 클릭 하여보아야합니다.</target>
        </trans-unit>
        <trans-unit id="8f49c43ce4bf9debfde5b04db98c0212ba6c8e15" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;SOME_PROPERTY&lt;/code&gt; associated constant would not compile, as its type &lt;code&gt;bool&lt;/code&gt; refers to the struct, rather than to the primitive bool type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659da6617a0c6362038e0166dcdb0fdd380d7b37" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;black&lt;/code&gt; and &lt;code&gt;origin&lt;/code&gt; values are different types, because they&amp;rsquo;re instances of different tuple structs. Each struct you define is its own type, even though the fields within the struct have the same types. For example, a function that takes a parameter of type &lt;code&gt;Color&lt;/code&gt; cannot take a &lt;code&gt;Point&lt;/code&gt; as an argument, even though both types are made up of three &lt;code&gt;i32&lt;/code&gt; values. Otherwise, tuple struct instances behave like tuples: you can destructure them into their individual pieces, you can use a &lt;code&gt;.&lt;/code&gt; followed by the index to access an individual value, and so on.</source>
          <target state="translated">점을 유의 &lt;code&gt;black&lt;/code&gt; 및 &lt;code&gt;origin&lt;/code&gt; 값이 다른 튜플 구조체의 그들이 있기 때문에있는 거 인스턴스가, 다른 유형입니다. 구조체 내 필드의 유형이 동일하더라도 정의한 각 구조체는 고유 한 유형입니다. 예를 들어, 두 가지 유형이 세 개의 &lt;code&gt;i32&lt;/code&gt; 값 으로 구성되어 있어도 &lt;code&gt;Color&lt;/code&gt; 유형의 매개 변수를 사용하는 함수 는 &lt;code&gt;Point&lt;/code&gt; 를 인수로 사용할 수 없습니다 . 그렇지 않으면 튜플 구조체 인스턴스는 튜플처럼 동작합니다. 튜플 구조체 인스턴스를 개별 조각으로 구성 해제 할 수 있습니다 &lt;code&gt;.&lt;/code&gt; 개별 값에 액세스하기위한 색인 등이 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="7585cdf9a53bb6203f72700ad7d5c4700090428d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;internal_adder&lt;/code&gt; function is not marked as &lt;code&gt;pub&lt;/code&gt;, but because tests are just Rust code and the &lt;code&gt;tests&lt;/code&gt; module is just another module, you can bring &lt;code&gt;internal_adder&lt;/code&gt; into a test&amp;rsquo;s scope and call it. If you don&amp;rsquo;t think private functions should be tested, there&amp;rsquo;s nothing in Rust that will compel you to do so.</source>
          <target state="translated">있습니다 &lt;code&gt;internal_adder&lt;/code&gt; 의 함수로 표시되지 &lt;code&gt;pub&lt;/code&gt; ,하지만 테스트는 단지 녹 코드이며, 때문에 &lt;code&gt;tests&lt;/code&gt; 모듈이 또 다른 모듈, 당신은 가져올 수 &lt;code&gt;internal_adder&lt;/code&gt; 테스트의 범위로하고 호출합니다. 개인 기능을 테스트해야한다고 생각하지 않는다면 Rust에는 그렇게하는 것이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1dfcc45249eab2386a4a77c00ed86344264ef031" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;mod common;&lt;/code&gt; declaration is the same as the module declaration we demonstrated in Listing 7-21. Then in the test function, we can call the &lt;code&gt;common::setup()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;mod common;&lt;/code&gt; 유의하십시오 . 선언은 우리가 Listing 7-21에서 보여준 모듈 선언과 동일합니다. 그런 다음 테스트 함수에서 &lt;code&gt;common::setup()&lt;/code&gt; 함수를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2416a0788bd332296b9d3351af29231165e12f7f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;mod common;&lt;/code&gt; declaration is the same as the module declaration we demonstrated in Listing 7-25. Then in the test function, we can call the &lt;code&gt;common::setup()&lt;/code&gt; function.</source>
          <target state="translated">참고이 &lt;code&gt;mod common;&lt;/code&gt; 선언은 Listing 7-25에서 보여준 모듈 선언과 동일하다. 그런 다음 테스트 함수에서 &lt;code&gt;common::setup()&lt;/code&gt; 함수를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b202266f93986284846e418aa656da415bb5e7b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;pub use crate::front_of_house::hosting&lt;/code&gt; statement in &lt;em&gt;src/lib.rs&lt;/em&gt; also hasn&amp;rsquo;t changed, nor does &lt;code&gt;use&lt;/code&gt; have any impact on what files are compiled as part of the crate. The &lt;code&gt;mod&lt;/code&gt; keyword declares modules, and Rust looks in a file with the same name as the module for the code that goes into that module.</source>
          <target state="translated">있습니다 &lt;code&gt;pub use crate::front_of_house::hosting&lt;/code&gt; 에 문 &lt;em&gt;SRC를 / lib.rs는&lt;/em&gt; 또한 변경도하지 않은 &lt;code&gt;use&lt;/code&gt; 파일이 상자의 일환으로 컴파일 무엇에 어떤 영향을 미친다. &lt;code&gt;mod&lt;/code&gt; 키워드는 모듈을 선언하고 녹 해당 모듈에 들어가는 코드 모듈과 동일한 이름의 파일을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="ebf0b34b8114310255f844126e635bca0217f44d" translate="yes" xml:space="preserve">
          <source>Note that the Rust syntax considers &lt;code&gt;-1i8&lt;/code&gt; as an application of the &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;unary minus operator&lt;/a&gt; to an integer literal &lt;code&gt;1i8&lt;/code&gt;, rather than a single integer literal.</source>
          <target state="translated">Rust 구문 은 단일 정수 리터럴 대신 정수 리터럴 &lt;code&gt;1i8&lt;/code&gt; 에 대한 &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;단항 빼기 연산자&lt;/a&gt; 를 적용하는 것으로 &lt;code&gt;-1i8&lt;/code&gt; 을 고려 합니다.</target>
        </trans-unit>
        <trans-unit id="56aae01ce79d910a619efda10dafe9ed6c6133a8" translate="yes" xml:space="preserve">
          <source>Note that the alignment of the resulting layout will be the maximum of those of &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;, in order to ensure alignment of both parts.</source>
          <target state="translated">결과 레이아웃의 정렬은 두 부분의 정렬을 보장하기 위해 &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;next&lt;/code&gt; 의 최대 정렬이됩니다.</target>
        </trans-unit>
        <trans-unit id="d7d6c6c7cc7587fa146a6b97e717ca83d5839bcb" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">할당자는 요청한 것보다 더 많은 공간을 컬렉션에 제공 할 수 있습니다. 따라서 용량을 정확하게 최소화 할 수는 없습니다. 향후 삽입이 예상되는 경우 &lt;a href=&quot;#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt; 선호하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c27c4a17236d84a273debe0206e2acee86fe4f0" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;../struct.binaryheap#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">할당자는 요청한 것보다 더 많은 공간을 컬렉션에 제공 할 수 있습니다. 따라서 용량을 정확하게 최소화 할 수 없습니다. 향후 삽입이 예상되면 &lt;a href=&quot;../struct.binaryheap#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt; 선호하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b0700ca055cbce179ecc3d9a30bb5baa7a6c28e" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;../struct.vecdeque#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">할당자는 요청한 것보다 더 많은 공간을 컬렉션에 제공 할 수 있습니다. 따라서 용량을 정확하게 최소화 할 수 없습니다. 향후 삽입이 예상되면 &lt;a href=&quot;../struct.vecdeque#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt; 선호하십시오 .</target>
        </trans-unit>
        <trans-unit id="088614193a26ec5fa144e1468834aa2d40a502e0" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;struct.binaryheap#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">할당자는 요청한 것보다 더 많은 공간을 컬렉션에 제공 할 수 있습니다. 따라서 용량을 정확하게 최소화 할 수 없습니다. 향후 삽입이 예상되면 &lt;a href=&quot;struct.binaryheap#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt; 선호하십시오 .</target>
        </trans-unit>
        <trans-unit id="e71fe50cc784bf479a83f567c5fb33ac0db88d1d" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;struct.vecdeque#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">할당자는 요청한 것보다 더 많은 공간을 컬렉션에 제공 할 수 있습니다. 따라서 용량을 정확하게 최소화 할 수 없습니다. 향후 삽입이 예상되면 &lt;a href=&quot;struct.vecdeque#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt; 선호하십시오 .</target>
        </trans-unit>
        <trans-unit id="e47a0cb986bfab2cf7630c87b9673550639fc541" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer &lt;code&gt;reserve&lt;/code&gt; if future insertions are expected.</source>
          <target state="translated">할당자는 요청한 것보다 더 많은 공간을 컬렉션에 제공 할 수 있습니다. 따라서 용량을 정확하게 최소화 할 수는 없습니다. 향후 삽입이 예상되는 경우 &lt;code&gt;reserve&lt;/code&gt; 선호하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8effc4910252eded99b791d1c4a5c812a34bdf2" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer reserve if future insertions are expected.</source>
          <target state="translated">할당자는 요청한 것보다 더 많은 공간을 컬렉션에 제공 할 수 있습니다. 따라서 용량을 정확하게 최소화 할 수는 없습니다. 향후 삽입이 예상되는 경우 예비를 선호하십시오.</target>
        </trans-unit>
        <trans-unit id="08c862951a6a3b03e0330454b0efc29b2b754947" translate="yes" xml:space="preserve">
          <source>Note that the argument is not passed through a shell, but given literally to the program. This means that shell syntax like quotes, escaped characters, word splitting, glob patterns, substitution, etc. have no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba0769350c5d5d78015e993d43a239511a252097" translate="yes" xml:space="preserve">
          <source>Note that the arguments are not passed through a shell, but given literally to the program. This means that shell syntax like quotes, escaped characters, word splitting, glob patterns, substitution, etc. have no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c41ef52ce2694587693c73f46ceb1c3c96783c" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time.</source>
          <target state="translated">대기 시간이 모노 토닉 시계로 측정되고 시스템 시간 변경에 영향을받지 않도록 최선의 노력을 다합니다.</target>
        </trans-unit>
        <trans-unit id="0ef4b3d8d9fa38a1ed8bb900aa8106bdb93d4e77" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time. This function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups. Additionally, it is typically desirable for the time-out to not exceed some duration in spite of spurious wakes, thus the sleep-duration is decremented by the amount slept. Alternatively, use the &lt;code&gt;wait_timeout_until&lt;/code&gt; method to wait until a condition is met with a total time-out regardless of spurious wakes.</source>
          <target state="translated">대기 시간이 모노 토닉 시계로 측정되고 시스템 시간 변경에 영향을받지 않도록 최선의 노력을 다합니다. 이 기능은 가짜 웨이크 업에 취약합니다. 조건 변수에는 일반적으로 연관된 부울 술어가 있으며이 함수가 가짜 웨이크 업을 방지하기 위해 리턴 될 때마다 술어를 항상 확인해야합니다. 또한, 허위 웨이크에도 불구하고 타임 아웃이 일부 지속 시간을 초과하지 않는 것이 바람직하므로, 수면 지속 시간은 슬리핑 된 양만큼 감소된다. 또는 &lt;code&gt;wait_timeout_until&lt;/code&gt; 메소드를 사용하여 가짜 깨우기와 상관없이 조건이 총 시간 종료에 도달 할 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="a6a58cc27a5e657fb0a670643552701080e58296" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time. This function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups. Additionally, it is typically desirable for the timeout to not exceed some duration in spite of spurious wakes, thus the sleep-duration is decremented by the amount slept. Alternatively, use the &lt;code&gt;wait_timeout_while&lt;/code&gt; method to wait with a timeout while a predicate is true.</source>
          <target state="translated">대기 시간이 단조로운 시계로 측정되고 시스템 시간 변경의 영향을받지 않도록 최선의 노력을 다합니다. 이 기능은 가짜 웨이크 업에 취약합니다. 조건 변수에는 일반적으로 관련된 부울 술어가 있으며,이 함수가 반환 될 때마다 술어를 항상 확인하여 가짜 깨우기를 방지해야합니다. 추가적으로, 시간 초과가 가짜 웨이크에도 불구하고 일정 기간을 초과하지 않는 것이 일반적으로 바람직하기 때문에 수면 시간은 수면량만큼 감소합니다. 또는 &lt;code&gt;wait_timeout_while&lt;/code&gt; 메소드를 사용하여 술어가 참인 동안 제한 시간을 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="4f53fcb70ba490adf24ce12bac9972be4901a158" translate="yes" xml:space="preserve">
          <source>Note that the capacity of &lt;code&gt;self&lt;/code&gt; does not change.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 능력은 변하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e939a8d32c47b3615c351b8f5ecdfdb4467cf4dc" translate="yes" xml:space="preserve">
          <source>Note that the entire instance must be mutable; Rust doesn&amp;rsquo;t allow us to mark only certain fields as mutable. As with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance.</source>
          <target state="translated">전체 인스턴스는 변경 가능해야합니다. 녹으로 인해 특정 필드 만 변경 가능으로 표시 할 수 없습니다. 다른 식과 마찬가지로 함수 본문에서 마지막 식으로 구조체의 새 인스턴스를 구성하여 해당 새 인스턴스를 암시 적으로 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="893d3a404a478f2bef24f1a4da4b0eecf6cccd02" translate="yes" xml:space="preserve">
          <source>Note that the error here is in the definition of the generic function: Although we only call it with a parameter that does implement &lt;code&gt;Debug&lt;/code&gt;, the compiler still rejects the function: It must work with all possible input types. In order to make this example compile, we need to restrict the generic type we're accepting:</source>
          <target state="translated">여기서 오류는 일반 함수의 정의에 있습니다. 우리는 &lt;code&gt;Debug&lt;/code&gt; 를 구현하는 매개 변수로만 호출하지만 컴파일러는 여전히 함수를 거부합니다. 가능한 모든 입력 유형에서 작동해야합니다. 이 예제를 컴파일하려면 허용하는 제네릭 형식을 제한해야합니다.</target>
        </trans-unit>
        <trans-unit id="06b34748b35f43179a334f500ab5063640caf614" translate="yes" xml:space="preserve">
          <source>Note that the expanded results of the input tokens may change in the future. You should be careful if you rely on the output.</source>
          <target state="translated">입력 토큰의 확장 된 결과는 나중에 변경 될 수 있습니다. 출력에 의존하는 경우주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4d3e131a7a31ae2f39a3a9a0dd9a292fd33ee3f" translate="yes" xml:space="preserve">
          <source>Note that the innermost object sets the bound, so &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo&amp;gt;&lt;/code&gt; is still &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo + 'static&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">가장 안쪽의 객체가 경계를 설정하므로 &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo&amp;gt;&lt;/code&gt; 는 여전히 &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo + 'static&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="20accbf3ad080e6a83efff23cbdda0ba37be7c3a" translate="yes" xml:space="preserve">
          <source>Note that the lowercase dotted 'i' is the same as the Latin. Therefore:</source>
          <target state="translated">소문자 점선 'i'는 라틴어와 동일합니다. 따라서:</target>
        </trans-unit>
        <trans-unit id="0529503c0b783f1fa295149899ee5a9048a3f3e4" translate="yes" xml:space="preserve">
          <source>Note that the macro is intended as a debugging tool and therefore you should avoid having uses of it in version control for long periods. Use cases involving debug output that should be added to version control are better served by macros such as &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt;&lt;code&gt;debug!&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;https://crates.io/crates/log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">매크로는 디버깅 도구로 사용되기 때문에 버전 관리에서 장기간 사용하지 않아야합니다. 버전 제어에 추가해야하는 디버그 출력과 관련된 사용 사례는 &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt; &lt;code&gt;debug!&lt;/code&gt; &lt;/a&gt;로부터 &lt;a href=&quot;https://crates.io/crates/log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; 상자.</target>
        </trans-unit>
        <trans-unit id="33af38a46c0f54bbd2f36a31035d5f75fa5f8705" translate="yes" xml:space="preserve">
          <source>Note that the macro is intended as a debugging tool and therefore you should avoid having uses of it in version control for longer periods. Use cases involving debug output that should be added to version control are better served by macros such as &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt;&lt;code&gt;debug!&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;https://crates.io/crates/log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">이 매크로는 디버깅 도구로 사용되므로 버전 관리에서 장기간 사용하지 않는 것이 좋습니다. 버전 제어에 추가되어야하는 디버그 출력과 관련된 사용 사례는 디버그와 같은 매크로에 의해 더 잘 제공됩니다 &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt; &lt;code&gt;debug!&lt;/code&gt; &lt;/a&gt;로부터 &lt;a href=&quot;https://crates.io/crates/log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; 상자.</target>
        </trans-unit>
        <trans-unit id="f68f549dc0f6cc4029741bd007637b70e59d35a0" translate="yes" xml:space="preserve">
          <source>Note that the output for the tests and the test results are interleaved; the reason is that the tests are running in parallel, as we talked about in the previous section. Try using the &lt;code&gt;--test-threads=1&lt;/code&gt; option and the &lt;code&gt;--nocapture&lt;/code&gt; flag, and see what the output looks like then!</source>
          <target state="translated">테스트 결과와 테스트 결과는 인터리브됩니다. 그 이유는 이전 섹션에서 설명한 것처럼 테스트가 병렬로 실행되기 때문입니다. 사용해보십시오 &lt;code&gt;--test-threads=1&lt;/code&gt; 옵션과 &lt;code&gt;--nocapture&lt;/code&gt; 플래그를, 출력 외모는 다음 좋아하는 것을 볼!</target>
        </trans-unit>
        <trans-unit id="a844a8727324231842256b1e8aa12a2943bbaceb" translate="yes" xml:space="preserve">
          <source>Note that the pointer value may potentially represent a valid pointer to a &lt;code&gt;T&lt;/code&gt;, which means this must not be used as a &quot;not yet initialized&quot; sentinel value. Types that lazily allocate must track initialization by some other means.</source>
          <target state="translated">포인터 값은 잠재적으로 &lt;code&gt;T&lt;/code&gt; 에 대한 유효한 포인터를 나타낼 수 있습니다 . 이는 &quot;초기화되지 않은&quot;센티넬 값으로 사용되어서는 안됩니다. 느리게 할당하는 형식은 다른 방법으로 초기화를 추적해야합니다.</target>
        </trans-unit>
        <trans-unit id="219a901fc4bbd905770e11b959092de46ce1a4b3" translate="yes" xml:space="preserve">
          <source>Note that the pointer value may potentially represent a valid pointer, which means this must not be used as a &quot;not yet initialized&quot; sentinel value. Types that lazily allocate must track initialization by some other means.</source>
          <target state="translated">포인터 값은 잠재적으로 유효한 포인터를 나타낼 수 있습니다. 이는 &quot;아직 초기화되지 않은&quot;센티널 값으로 사용되지 않아야 함을 의미합니다. 느리게 할당되는 유형은 다른 방법으로 초기화를 추적해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e42d22c3d181aaaed5a33c43a08345afdbe2126" translate="yes" xml:space="preserve">
          <source>Note that the stack size of the main thread is &lt;em&gt;not&lt;/em&gt; determined by Rust.</source>
          <target state="translated">메인 스레드의 스택 크기는 Rust에 의해 결정 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5317fa424b787d9e3193b4c178e1e274e73ebdb4" translate="yes" xml:space="preserve">
          <source>Note that the standard library (&lt;code&gt;std&lt;/code&gt;) is also a crate that&amp;rsquo;s external to our package. Because the standard library is shipped with the Rust language, we don&amp;rsquo;t need to change &lt;em&gt;Cargo.toml&lt;/em&gt; to include &lt;code&gt;std&lt;/code&gt;. But we do need to refer to it with &lt;code&gt;use&lt;/code&gt; to bring items from there into our package&amp;rsquo;s scope. For example, with &lt;code&gt;HashMap&lt;/code&gt; we would use this line:</source>
          <target state="translated">표준 라이브러리 ( &lt;code&gt;std&lt;/code&gt; )도 패키지 외부에있는 상자입니다. 표준 라이브러리는 Rust 언어와 함께 제공되므로 &lt;code&gt;std&lt;/code&gt; 를 포함하도록 &lt;em&gt;Cargo.toml&lt;/em&gt; 을 변경할 필요가 없습니다 . 그러나 항목을 패키지 범위로 가져 오는 데 &lt;code&gt;use&lt;/code&gt; 하여 참조해야합니다 . 예를 들어 &lt;code&gt;HashMap&lt;/code&gt; 을 사용하면 다음 줄을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="81d14f271d71ceb8a4e63a395e2c2b18f3026e6e" translate="yes" xml:space="preserve">
          <source>Note that the traits &lt;a href=&quot;../convert/trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../convert/trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; provide similar methods for types that may not be fixed-size arrays. Implementors should prefer those traits instead.</source>
          <target state="translated">&lt;a href=&quot;../convert/trait.asref&quot;&gt; &lt;code&gt;AsRef&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../convert/trait.asmut&quot;&gt; &lt;code&gt;AsMut&lt;/code&gt; &lt;/a&gt; 특성 은 고정 크기 배열이 아닐 수있는 유형에 대해 유사한 메서드를 제공합니다. 구현자는 대신 이러한 특성을 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="405821d50e551ea851eed49e6fdd0bf01f98b46a" translate="yes" xml:space="preserve">
          <source>Note that the traits AsRef and AsMut provide similar methods for types that may not be fixed-size arrays. Implementors should prefer those traits instead.</source>
          <target state="translated">AsRef 및 AsMut 특성은 고정 크기 배열이 아닌 유형에 대해 유사한 방법을 제공합니다. 구현자는 이러한 특성을 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="6289f32f721dc9ae628a24b212ad3154b1e5c872" translate="yes" xml:space="preserve">
          <source>Note that the type of &lt;code&gt;v&lt;/code&gt; can now be inferred from the type of &lt;code&gt;temp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 유형은 이제 &lt;code&gt;temp&lt;/code&gt; 유형에서 유추 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6cb7f36bf472ae404403c7eb996727201edfc32d" translate="yes" xml:space="preserve">
          <source>Note that the underlying iterator is still advanced when &lt;a href=&quot;struct.peekable#method.peek&quot;&gt;&lt;code&gt;peek&lt;/code&gt;&lt;/a&gt; is called for the first time: In order to retrieve the next element, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called on the underlying iterator, hence any side effects (i.e. anything other than fetching the next value) of the &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; method will occur.</source>
          <target state="translated">때 반복자를 기본주의는 여전히 진보 &lt;a href=&quot;struct.peekable#method.peek&quot;&gt; &lt;code&gt;peek&lt;/code&gt; &lt;/a&gt; 다음의 요소를 검색하기 위해, : 처음이라고 &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 의 따라서 부작용 (다음 값을 가져 오는 이외 즉, 아무것도), 기본 반복자에 호출 &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 방법이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5e9890cf8ac181c5bdc0d2e127263d39bf20f96f" translate="yes" xml:space="preserve">
          <source>Note that the utility of the returned value requires &lt;code&gt;align&lt;/code&gt; to be less than or equal to the alignment of the starting address for the whole allocated block of memory. One way to satisfy this constraint is to ensure &lt;code&gt;align &amp;lt;= self.align()&lt;/code&gt;.</source>
          <target state="translated">리턴 값의 유틸리티가 필요 유의 &lt;code&gt;align&lt;/code&gt; 보다 적은 수 또는 메모리의 전체 할당 된 블록의 시작 주소의 배향과 동일한다. 이 제약 조건을 충족시키는 한 가지 방법은 &lt;code&gt;align &amp;lt;= self.align()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2d911cb36c04dcf8463355e9c033efd2983dc723" translate="yes" xml:space="preserve">
          <source>Note that the variants of the enum are namespaced under its identifier, and we use a double colon to separate the two. The reason this is useful is that now both values &lt;code&gt;IpAddrKind::V4&lt;/code&gt; and &lt;code&gt;IpAddrKind::V6&lt;/code&gt; are of the same type: &lt;code&gt;IpAddrKind&lt;/code&gt;. We can then, for instance, define a function that takes any &lt;code&gt;IpAddrKind&lt;/code&gt;:</source>
          <target state="translated">열거 형의 변형은 식별자 아래에 네임 스페이스가 있으며 이중 콜론을 사용하여 둘을 분리합니다. 이것이 유용한 이유는 이제 &lt;code&gt;IpAddrKind::V4&lt;/code&gt; 및 &lt;code&gt;IpAddrKind::V6&lt;/code&gt; 값이 모두 같은 유형 인 &lt;code&gt;IpAddrKind&lt;/code&gt; 이기 때문 입니다. 예를 들어, &lt;code&gt;IpAddrKind&lt;/code&gt; 를 취하는 함수를 정의 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="16c052a3290e3d52e2b4ef43bfa0c661287a1967" translate="yes" xml:space="preserve">
          <source>Note that there is a subtle difference between using only &lt;code&gt;_&lt;/code&gt; and using a name that starts with an underscore. The syntax &lt;code&gt;_x&lt;/code&gt; still binds the value to the variable, whereas &lt;code&gt;_&lt;/code&gt; doesn&amp;rsquo;t bind at all. To show a case where this distinction matters, Listing 18-21 will provide us with an error.</source>
          <target state="translated">&lt;code&gt;_&lt;/code&gt; 만 사용하는 것과 밑줄로 시작하는 이름을 사용하는 것 사이에는 미묘한 차이가 있습니다. 구문 &lt;code&gt;_x&lt;/code&gt; 는 여전히 값을 변수에 바인딩 하지만 &lt;code&gt;_&lt;/code&gt; 는 전혀 바인딩하지 않습니다. 이러한 차이점이 중요한 경우를 보여주기 위해 Listing 18-21은 오류를 제공 할 것이다.</target>
        </trans-unit>
        <trans-unit id="a9f69008c63ee1bbbd3dca68ce2579a7f11ccac4" translate="yes" xml:space="preserve">
          <source>Note that there is no guarantee that the file is immediately deleted (e.g., depending on platform, other open file descriptors may prevent immediate removal).</source>
          <target state="translated">파일이 즉시 삭제된다는 보장은 없습니다 (예 : 플랫폼에 따라 다른 열린 파일 디스크립터가 즉시 제거되지 않을 수 있음).</target>
        </trans-unit>
        <trans-unit id="c1d60a1d35c01b7a3e982971929136941cc6d773" translate="yes" xml:space="preserve">
          <source>Note that there might be more than one &lt;code&gt;Reject&lt;/code&gt; between two &lt;code&gt;Match&lt;/code&gt;es, there is no requirement for them to be combined into one.</source>
          <target state="translated">두 &lt;code&gt;Match&lt;/code&gt; 사이에 &lt;code&gt;Reject&lt;/code&gt; 가 두 개 이상있을 수 있으므로 두 경기 를 하나로 합칠 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="66991018cda906aad5fc546c336b3be880291e4b" translate="yes" xml:space="preserve">
          <source>Note that these outputs are stackable in the sense that if multiple are specified, then the compiler will produce each form of output at once without having to recompile. However, this only applies for outputs specified by the same method. If only &lt;code&gt;crate_type&lt;/code&gt; attributes are specified, then they will all be built, but if one or more &lt;code&gt;--crate-type&lt;/code&gt; command line flags are specified, then only those outputs will be built.</source>
          <target state="translated">이러한 출력은 여러 개를 지정하면 컴파일러가 다시 컴파일하지 않고도 한 번에 각 형태의 출력을 생성한다는 점에서 스택 가능합니다. 그러나 이것은 동일한 방법으로 지정된 출력에만 적용됩니다. 경우에만 &lt;code&gt;crate_type&lt;/code&gt; 의 속성이 지정되어, 그들은 모두 내장되지만, 하나 또는 그 이상의 경우 &lt;code&gt;--crate-type&lt;/code&gt; 명령 줄 플래그가 지정된 후 만 출력이 내장됩니다.</target>
        </trans-unit>
        <trans-unit id="68d9fc76dd03b0153bd61663810434ccc46dcc2c" translate="yes" xml:space="preserve">
          <source>Note that these requirements mean that the trait itself must be implemented symmetrically and transitively: if &lt;code&gt;T: PartialEq&amp;lt;U&amp;gt;&lt;/code&gt; and &lt;code&gt;U: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; then &lt;code&gt;U: PartialEq&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">참고 이러한 요구 사항은 특성 자체가 대칭과 이적으로 구현되어야한다는 것을 의미하는 것이 : 만약 &lt;code&gt;T: PartialEq&amp;lt;U&amp;gt;&lt;/code&gt; 및 &lt;code&gt;U: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; 다음 &lt;code&gt;U: PartialEq&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;T: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68c8d8134a3ad3fb6c3b8c1e1d2d42e5a3391556" translate="yes" xml:space="preserve">
          <source>Note that these requirements mean that the trait itself must be implemented symmetrically and transitively: if &lt;code&gt;T: PartialOrd&amp;lt;U&amp;gt;&lt;/code&gt; and &lt;code&gt;U: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; then &lt;code&gt;U: PartialOrd&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">참고 이러한 요구 사항은 특성 자체가 대칭과 이적으로 구현되어야한다는 것을 의미하는 것이 : 만약 &lt;code&gt;T: PartialOrd&amp;lt;U&amp;gt;&lt;/code&gt; 및 &lt;code&gt;U: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; 다음 &lt;code&gt;U: PartialOrd&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;T: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a875078880a05f44d1479047dbce85f081dc8bf" translate="yes" xml:space="preserve">
          <source>Note that this &lt;code&gt;let&lt;/code&gt; statement means &lt;code&gt;expensive_closure&lt;/code&gt; contains the &lt;em&gt;definition&lt;/em&gt; of an anonymous function, not the &lt;em&gt;resulting value&lt;/em&gt; of calling the anonymous function. Recall that we&amp;rsquo;re using a closure because we want to define the code to call at one point, store that code, and call it at a later point; the code we want to call is now stored in &lt;code&gt;expensive_closure&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;let&lt;/code&gt; 문은 &lt;code&gt;expensive_closure&lt;/code&gt; 에 익명 함수 를 호출 한 &lt;em&gt;결과 값&lt;/em&gt; 이 아니라 익명 함수 의 &lt;em&gt;정의&lt;/em&gt; 가 포함됨을 의미합니다. 한 시점에서 호출 할 코드를 정의하고 해당 코드를 저장 한 후 나중에 호출하기 때문에 클로저를 사용하고 있음을 상기하십시오. 우리가 호출하려는 코드는 이제 &lt;code&gt;expensive_closure&lt;/code&gt; 에 저장됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f79a43777883bf04ed897be6d605f1d017ef8797" translate="yes" xml:space="preserve">
          <source>Note that this approach needs a reference to S with lifetime &lt;code&gt;'a&lt;/code&gt;. Nothing shorter than &lt;code&gt;'a&lt;/code&gt; will suffice: a shorter lifetime would imply that after &lt;code&gt;demo&lt;/code&gt; finishes executing, something else (such as the destructor!) could access &lt;code&gt;s.data&lt;/code&gt; after the end of that shorter lifetime, which would again violate the &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrow's exclusive access.</source>
          <target state="translated">이 방법은 수명이 &lt;code&gt;'a&lt;/code&gt; 인 S에 대한 참조가 필요 합니다 . 보다 짧은 아무것도 &lt;code&gt;'a&lt;/code&gt; 짧은 수명이 후 것을 의미합니다 : 충분 &lt;code&gt;demo&lt;/code&gt; (! 같은 소멸자로) 마감이 다른 것을 실행에 액세스 할 수 &lt;code&gt;s.data&lt;/code&gt; 을 다시 위반하는, 그 짧은 수명의 종료 후 &lt;code&gt;&amp;amp;mut&lt;/code&gt; -borrow의 독점을 접속하다.</target>
        </trans-unit>
        <trans-unit id="c27fe5a5d1e022b605f9e160ee6f188847c0730a" translate="yes" xml:space="preserve">
          <source>Note that this behavior is a consequence of the desugaring to a function that returns an &lt;code&gt;impl Future&lt;/code&gt; -- in this case, the function we desugar to is an &lt;code&gt;unsafe&lt;/code&gt; function, but the return value remains the same.</source>
          <target state="translated">이 동작은 &lt;code&gt;impl Future&lt;/code&gt; 를 반환하는 함수로 desugaring 한 결과입니다.이 경우 desugar 함수 는 &lt;code&gt;unsafe&lt;/code&gt; 함수이지만 반환 값은 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d559316d5513a320d9bd5dde1c5db0aa4a3ef581" translate="yes" xml:space="preserve">
          <source>Note that this differs from the behavior of &lt;a href=&quot;../rc/struct.rc#method.make_mut&quot;&gt;&lt;code&gt;Rc::make_mut&lt;/code&gt;&lt;/a&gt; which disassociates any remaining &lt;code&gt;Weak&lt;/code&gt; pointers.</source>
          <target state="translated">이것은 나머지 &lt;code&gt;Weak&lt;/code&gt; 포인터 를 분리하는 &lt;a href=&quot;../rc/struct.rc#method.make_mut&quot;&gt; &lt;code&gt;Rc::make_mut&lt;/code&gt; &lt;/a&gt; 의 동작과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="3192c9f3997431085906a96d26c01c024cf3788d" translate="yes" xml:space="preserve">
          <source>Note that this does &lt;strong&gt;not&lt;/strong&gt; return the number of bytes in the string in OS string form.</source>
          <target state="translated">이것은 OS 문자열 형식으로 문자열의 바이트 수를 반환 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="80ff79baf2f49c9d290848de9fb000d654394ab7" translate="yes" xml:space="preserve">
          <source>Note that this does not move &lt;code&gt;v&lt;/code&gt; (unlike &lt;code&gt;transmute&lt;/code&gt;), and may need a call to &lt;code&gt;mem::forget(v)&lt;/code&gt; in case you want to avoid destructors being called.</source>
          <target state="translated">&lt;code&gt;transmute&lt;/code&gt; 와 달리 &lt;code&gt;v&lt;/code&gt; 는 이동하지 않으며 소멸자가 호출되는 것을 피하기 위해 &lt;code&gt;mem::forget(v)&lt;/code&gt; 를 호출해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7810f8cddc029bde853e42fc348f1144623db2c4" translate="yes" xml:space="preserve">
          <source>Note that this example uses &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and not &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;s are for single-threaded scenarios. Consider using &lt;code&gt;RwLock&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; if you need shared mutability in a multi-threaded situation.</source>
          <target state="translated">이 예제는 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 아니라 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용합니다 . &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 는 단일 스레드 시나리오를위한 것입니다. 다중 스레드 상황에서 공유 변경 가능성이 필요한 경우 &lt;code&gt;RwLock&amp;lt;T&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdd8e4eb74f462e708e2264904eba6fd4dc6a6a0" translate="yes" xml:space="preserve">
          <source>Note that this example won&amp;rsquo;t compile just yet; we&amp;rsquo;ll explain why in a bit.</source>
          <target state="translated">이 예제는 아직 컴파일되지 않습니다. 우리는 왜 조금 설명 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="5bd9e1731fac8ae0cac27d3b3c2a1bac0e799687" translate="yes" xml:space="preserve">
          <source>Note that this function &lt;strong&gt;may not catch all panics&lt;/strong&gt; in Rust. A panic in Rust is not always implemented via unwinding, but can be implemented by aborting the process as well. This function &lt;em&gt;only&lt;/em&gt; catches unwinding panics, not those that abort the process.</source>
          <target state="translated">이 기능 &lt;strong&gt;은&lt;/strong&gt; Rust에서 &lt;strong&gt;모든 패닉&lt;/strong&gt; 을 &lt;strong&gt;포착하지 못할 수도 있습니다&lt;/strong&gt; . Rust의 패닉은 항상 풀기를 통해 구현되는 것은 아니지만 프로세스를 중단하여 구현할 수도 있습니다. 이 기능 은 풀리는 패닉 &lt;em&gt;만&lt;/em&gt; 잡을 &lt;em&gt;뿐&lt;/em&gt; 프로세스를 중단시키는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d3651367d7bc20ea65e217082fe9e78b8f819776" translate="yes" xml:space="preserve">
          <source>Note that this function does not always agree with the &lt;a href=&quot;cmp/trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt; implementations of &lt;code&gt;f32&lt;/code&gt;. In particular, they regard negative and positive zero as equal, while &lt;code&gt;total_cmp&lt;/code&gt; doesn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6a1415dd489b9fd2f261b68de74159561b45e0" translate="yes" xml:space="preserve">
          <source>Note that this function does not always agree with the &lt;a href=&quot;cmp/trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt; implementations of &lt;code&gt;f64&lt;/code&gt;. In particular, they regard negative and positive zero as equal, while &lt;code&gt;total_cmp&lt;/code&gt; doesn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19f0a1a5449c981a5e246c3b5e6a9fcf303b7fa2" translate="yes" xml:space="preserve">
          <source>Note that this function is distinct from &lt;code&gt;as&lt;/code&gt; casting, which attempts to preserve the &lt;em&gt;numeric&lt;/em&gt; value, and not the bitwise value.</source>
          <target state="translated">이 함수는 구별 된 참고 &lt;code&gt;as&lt;/code&gt; 유지] 시도 캐스팅, &lt;em&gt;숫자&lt;/em&gt; 값이 아닌 비트 값입니다.</target>
        </trans-unit>
        <trans-unit id="d63eb9d4a24784000530071fbe51104de3bf3f2c" translate="yes" xml:space="preserve">
          <source>Note that this function is same as &lt;a href=&quot;#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; except that it is specialized to work with slices instead. If and when Rust gets specialization this function will likely be deprecated (but still available).</source>
          <target state="translated">이 기능은 슬라이스 대신 작업하도록 특수화된다는 점을 제외하면 &lt;a href=&quot;#method.extend&quot;&gt; &lt;code&gt;extend&lt;/code&gt; &lt;/a&gt; 와 동일 합니다. Rust가 전문화를 얻는 경우이 기능은 더 이상 사용되지 않을 수 있지만 여전히 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0f406b6d417033b808228cce14b8dbb1120d5c7d" translate="yes" xml:space="preserve">
          <source>Note that this function is same as &lt;a href=&quot;struct.vec#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; except that it is specialized to work with slices instead. If and when Rust gets specialization this function will likely be deprecated (but still available).</source>
          <target state="translated">이 함수는 대신 슬라이스로 작업하도록 전문화된다는 점을 제외하면 &lt;a href=&quot;struct.vec#method.extend&quot;&gt; &lt;code&gt;extend&lt;/code&gt; &lt;/a&gt; 와 동일 합니다. Rust가 전문화되면이 함수는 더 이상 사용되지 않을 것입니다 (하지만 여전히 사용 가능).</target>
        </trans-unit>
        <trans-unit id="65def495fd9076c99d32e3ed9abc467516100c9b" translate="yes" xml:space="preserve">
          <source>Note that this function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups.</source>
          <target state="translated">이 기능은 가짜 웨이크 업에 취약합니다. 조건 변수에는 일반적으로 연관된 부울 술어가 있으며이 함수가 가짜 웨이크 업을 방지하기 위해 리턴 될 때마다 술어를 항상 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="313e92b88c0b90cea2623eaa38278951f5c4defe" translate="yes" xml:space="preserve">
          <source>Note that this function may block the current thread while resolution is performed.</source>
          <target state="translated">이 기능은 해상도가 수행되는 동안 현재 스레드를 차단할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="380b102b57d47b1e80ead440741eb736cbc5acae" translate="yes" xml:space="preserve">
          <source>Note that this function returns NaN if the initial value was NaN as well.</source>
          <target state="translated">이 함수는 초기 값이 NaN 인 경우에도 NaN을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="041273b62662865c4b0b3972fa9f215d6a183216" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;also&lt;/em&gt; different from Windows-1252 a.k.a. code page 1252, which is a superset ISO/IEC 8859-1 that assigns some (not all!) blanks to punctuation and various Latin characters.</source>
          <target state="translated">이것은 Windows-1252 일명 코드 페이지 1252 &lt;em&gt;와도&lt;/em&gt; 다릅니다. 이 코드 페이지 1252는 구두점 및 다양한 라틴 문자에 일부 (전부는 아님) 공백을 할당하는 수퍼 셋 ISO / IEC 8859-1입니다.</target>
        </trans-unit>
        <trans-unit id="c12e3030c3946db5f00ad56e92693e7a60e9d4f4" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;a href=&quot;#method.rotate_left&quot;&gt;&lt;code&gt;rotate_left&lt;/code&gt;&lt;/a&gt; function, which may be what you want instead.</source>
          <target state="translated">이것은 왼쪽 회전과 같지 &lt;em&gt;않습니다&lt;/em&gt; . 래핑 시프트의 RHS는 LHS에서 시프트 된 비트가 다른 쪽 끝으로 반환되는 것이 아니라 유형의 범위로 제한됩니다. 프리미티브 정수 유형은 모두 &lt;a href=&quot;#method.rotate_left&quot;&gt; &lt;code&gt;rotate_left&lt;/code&gt; &lt;/a&gt; 함수를 구현하며 대신 원하는 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d05d921ff847b716a1e90578f4bb30e691402415" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;[&lt;/code&gt;rotate_left`](#method.rotate_left) function, which may be what you want instead.</source>
          <target state="translated">이것은 왼쪽 회전과 같지 &lt;em&gt;않습니다&lt;/em&gt; . 래핑 시프트의 RHS는 LHS에서 시프트 된 비트가 다른 쪽 끝으로 반환되는 것이 아니라 유형의 범위로 제한됩니다. 프리미티브 정수 유형은 모두 &lt;code&gt;[&lt;/code&gt; rotate_left`] (# method.rotate_left) 함수를 구현합니다 . 대신 원하는 것이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b16eb422b8b7fd380457bb98366ee9e32e4eb27b" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;rotate_left&lt;/code&gt; function, which may be what you want instead.</source>
          <target state="translated">이 것을 참고 &lt;em&gt;하지&lt;/em&gt; 와 동일한 회전 왼쪽; 랩핑 시프트-왼쪽의 RHS는 다른 쪽 끝으로 리턴되는 LHS로부터 시프트 된 비트가 아니라 타입의 범위로 제한된다. 프리미티브 정수 타입은 모두 &lt;code&gt;rotate_left&lt;/code&gt; 함수를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="3efbf7b6ffbe371fa44b1cbc24ab53cb5dc43bf3" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-right; the RHS of a wrapping shift-right is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;a href=&quot;#method.rotate_right&quot;&gt;&lt;code&gt;rotate_right&lt;/code&gt;&lt;/a&gt; function, which may be what you want instead.</source>
          <target state="translated">이것은 오른쪽 회전과 같지 &lt;em&gt;않습니다&lt;/em&gt; . 래핑 오른쪽 시프트의 RHS는 LHS에서 시프트 된 비트가 다른 쪽 끝으로 반환되는 것이 아니라 유형의 범위로 제한됩니다. 프리미티브 정수 유형은 모두 &lt;a href=&quot;#method.rotate_right&quot;&gt; &lt;code&gt;rotate_right&lt;/code&gt; &lt;/a&gt; 함수를 구현하며 대신 원하는 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e2418939b1c8a1ff22ccadf416147fa70a3f1d3" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-right; the RHS of a wrapping shift-right is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;rotate_right&lt;/code&gt; function, which may be what you want instead.</source>
          <target state="translated">이것은 오른쪽 회전과 동일 &lt;em&gt;하지 않습니다&lt;/em&gt; . 랩핑 시프트 우측의 RHS는 다른 쪽 끝으로 리턴되는 LHS로부터 시프트 된 비트가 아니라 타입의 범위로 제한된다. 프리미티브 정수 타입은 모두 &lt;code&gt;rotate_right&lt;/code&gt; 함수를 구현하는데 , 대신 원하는 함수일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e7c41ce1c84929477918f04b930178589599b47" translate="yes" xml:space="preserve">
          <source>Note that this is different from ISO/IEC 8859-1 a.k.a. ISO 8859-1 (with one less hyphen), which leaves some &quot;blanks&quot;, byte values that are not assigned to any character. ISO-8859-1 (the IANA one) assigns them to the C0 and C1 control codes.</source>
          <target state="translated">이는 ISO / IEC 8859-1 (일명 하이픈이 있음)과 다르며 일부 &quot;공백&quot;, 문자에 할당되지 않은 바이트 값을 남겨 둡니다. ISO-8859-1 (IANA 하나)은이를 C0 및 C1 제어 코드에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="8c4108681b9fe84accc050cbc8f424a5d8e729f9" translate="yes" xml:space="preserve">
          <source>Note that this is not fully supported yet.</source>
          <target state="translated">아직 완전히 지원되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="f63d3c3ade69b60f12aa852f379afa06c0c1f9ef" translate="yes" xml:space="preserve">
          <source>Note that this list may get tweaked over time as clarifications are made in the future.</source>
          <target state="translated">이 목록은 나중에 설명이 이루어질수록 시간이 지남에 따라 조정될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03886768677567c6f0e7dd2acec0f3c2f274c587" translate="yes" xml:space="preserve">
          <source>Note that this may not have any affect on IPv6 sockets.</source>
          <target state="translated">IPv6 소켓에는 영향을 미치지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75b3dfc6f40c762d7bf2bac499b7412fe6b10302" translate="yes" xml:space="preserve">
          <source>Note that this may not have any effect on IPv6 sockets.</source>
          <target state="translated">이것은 IPv6 소켓에 영향을 미치지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dd32cd539a7711b8e3e1fa20fa744535b499c0b" translate="yes" xml:space="preserve">
          <source>Note that this method alters the content of the underlying file, even though it takes &lt;code&gt;&amp;amp;self&lt;/code&gt; rather than &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 보다는 &lt;code&gt;&amp;amp;self&lt;/code&gt; 가져도 기본 파일의 내용을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="108aecbc7f980094cc29f71b2bba33a5524e868d" translate="yes" xml:space="preserve">
          <source>Note that this method alters the permissions of the underlying file, even though it takes &lt;code&gt;&amp;amp;self&lt;/code&gt; rather than &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">이 메소드 는 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 아닌 &lt;code&gt;&amp;amp;self&lt;/code&gt; 하더라도 기본 파일의 권한을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="e2935aad8d6fdca6a365f84d6feb6723528101b9" translate="yes" xml:space="preserve">
          <source>Note that this method does not add any padding to the overall size, regardless of whether the returned layout has a different alignment. In other words, if &lt;code&gt;K&lt;/code&gt; has size 16, &lt;code&gt;K.align_to(32)&lt;/code&gt; will &lt;em&gt;still&lt;/em&gt; have size 16.</source>
          <target state="translated">이 메서드는 반환 된 레이아웃의 정렬이 다른지 여부에 관계없이 전체 크기에 여백을 추가하지 않습니다. 경우 즉, &lt;code&gt;K&lt;/code&gt; 는 크기 (16)가, &lt;code&gt;K.align_to(32)&lt;/code&gt; 것이다 &lt;em&gt;여전히&lt;/em&gt; 크기 (16)이있다.</target>
        </trans-unit>
        <trans-unit id="be7d3b69a88f7138cbd894fa652fd4db3b576956" translate="yes" xml:space="preserve">
          <source>Note that this method has no effect on the allocated capacity of the string</source>
          <target state="translated">이 방법은 문자열의 할당 용량에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7737d7dae93fa9ff008b32d416192e1953f17cf" translate="yes" xml:space="preserve">
          <source>Note that this method has no effect on the allocated capacity of the vector.</source>
          <target state="translated">이 방법은 벡터의 할당 된 용량에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89e693fcdc5244de65fc2d6120edee9bdcd4b3ee" translate="yes" xml:space="preserve">
          <source>Note that this structure is &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;repr(C)&lt;/code&gt; and is not recommended to be placed in the signatures of FFI functions. Instead, safe wrappers of FFI functions may leverage the unsafe &lt;a href=&quot;#method.from_ptr&quot;&gt;&lt;code&gt;from_ptr&lt;/code&gt;&lt;/a&gt; constructor to provide a safe interface to other consumers.</source>
          <target state="translated">이 구조는 유의 &lt;strong&gt;하지 &lt;/strong&gt; &lt;code&gt;repr(C)&lt;/code&gt; 와 FFI 함수의 서명에 배치하는 것은 좋지 않습니다. 대신, FFI 함수의 안전한 래퍼는 안전하지 않은 &lt;a href=&quot;#method.from_ptr&quot;&gt; &lt;code&gt;from_ptr&lt;/code&gt; &lt;/a&gt; 생성자를 활용하여 다른 소비자에게 안전한 인터페이스를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9aac27458abae34c90a97df1aff42a3fdeee40a4" translate="yes" xml:space="preserve">
          <source>Note that this structure is &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;repr(C)&lt;/code&gt; and is not recommended to be placed in the signatures of FFI functions. Instead, safe wrappers of FFI functions may leverage the unsafe &lt;a href=&quot;struct.cstr#method.from_ptr&quot;&gt;&lt;code&gt;CStr::from_ptr&lt;/code&gt;&lt;/a&gt; constructor to provide a safe interface to other consumers.</source>
          <target state="translated">이 구조는 유의 &lt;strong&gt;하지 &lt;/strong&gt; &lt;code&gt;repr(C)&lt;/code&gt; 와 FFI 함수의 서명에 배치하는 것은 좋지 않습니다. 대신 FFI 함수의 안전한 래퍼는 안전하지 않은 &lt;a href=&quot;struct.cstr#method.from_ptr&quot;&gt; &lt;code&gt;CStr::from_ptr&lt;/code&gt; &lt;/a&gt; 생성자를 활용하여 다른 소비자에게 안전한 인터페이스를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5da6d2d2aa3f48414658a9bcd539c6d50d1d673" translate="yes" xml:space="preserve">
          <source>Note that this technique can also be used in the arms of a match expression:</source>
          <target state="translated">이 기술은 또한 일치 표현식의 팔에도 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b13210c5a5854d88abb024233653585819c00385" translate="yes" xml:space="preserve">
          <source>Note that this will drop any excess capacity.</source>
          <target state="translated">이렇게하면 초과 용량이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="6affebf246a6b9323b472569ce7b0d2dca1b6504" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;trait.iterator#method.take_while&quot;&gt;&lt;code&gt;take_while&lt;/code&gt;&lt;/a&gt; this iterator is &lt;strong&gt;not&lt;/strong&gt; fused. It is also not specified what this iterator returns after the first&lt;code&gt; None&lt;/code&gt; is returned. If you need fused iterator, use &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;fuse&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;trait.iterator#method.take_while&quot;&gt; &lt;code&gt;take_while&lt;/code&gt; &lt;/a&gt; 과 달리이 반복자는 융합 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 첫 번째 &lt;code&gt; None&lt;/code&gt; 이 반환 된 후이 반복자가 반환하는 내용도 지정되지 않습니다 . 융합 된 반복기가 필요하면 &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt; &lt;code&gt;fuse&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d98fb91c14420919b7eff367a1230b8f150b713" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;wait&lt;/code&gt;, this function will not attempt to drop stdin.</source>
          <target state="translated">&lt;code&gt;wait&lt;/code&gt; 와 달리이 함수는 stdin을 삭제하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb34ec44c63eee46c533ae8549230c0956f06438" translate="yes" xml:space="preserve">
          <source>Note that unlike array expressions this syntax supports all elements which implement &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and the number of elements doesn't have to be a constant.</source>
          <target state="translated">배열 표현식과 달리이 구문은 &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 를 구현하는 모든 요소를 ​​지원하며 요소 수는 상수 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="09bd0257d3adc41b553ee0c1fba837b27ed6d43d" translate="yes" xml:space="preserve">
          <source>Note that unsized types have many possible null pointers, as only the raw data pointer is considered, not their length, vtable, etc. Therefore, two pointers that are null may still not compare equal to each other.</source>
          <target state="translated">크기가 지정되지 않은 유형에는 길이, vtable 등이 아닌 원시 데이터 포인터 만 고려되므로 가능한 많은 널 포인터가 있습니다. 따라서 널인 두 포인터는 여전히 서로 동일하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f2131c92cffd468fb8e9760cfdc9ed5b9347fe9" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;self&lt;/code&gt; in this way might not be necessary in the future; it&amp;rsquo;s an inconsistency in the language that Rust developers are working to eliminate.</source>
          <target state="translated">앞으로 이런 식으로 &lt;code&gt;self&lt;/code&gt; 를 사용하는 것이 필요하지 않을 수도 있습니다. Rust 개발자들이 제거하려고하는 언어의 불일치입니다.</target>
        </trans-unit>
        <trans-unit id="d0ff9c8a29cb263c7447b50b428f4e5035b7a3bd" translate="yes" xml:space="preserve">
          <source>Note that using the &lt;code&gt;type&lt;/code&gt; keyword does not work here because &lt;code&gt;type&lt;/code&gt; only introduces a type alias:</source>
          <target state="translated">사용합니다 &lt;code&gt;type&lt;/code&gt; 때문에 키워드 것은 여기에 작동하지 않는 &lt;code&gt;type&lt;/code&gt; 단지 형 별칭을 소개합니다 :</target>
        </trans-unit>
        <trans-unit id="bb6b42394e9bea5f3f448212418ce1a68b9d76c5" translate="yes" xml:space="preserve">
          <source>Note that using these trait methods will result in a heap allocation per-function-call. This is not a significant cost for the vast majority of applications, but should be considered when deciding whether to use this functionality in the public API of a low-level function that is expected to be called millions of times a second.</source>
          <target state="translated">이러한 특성 메서드를 사용하면 함수 호출 당 힙 할당이 발생합니다. 이는 대부분의 애플리케이션에서 상당한 비용이 아니지만, 초당 수백만 번 호출 될 것으로 예상되는 저수준 함수의 공용 API에서이 기능을 사용할지 여부를 결정할 때 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="96eb45dab421603d86bba0634bd20e8a1fa6f567" translate="yes" xml:space="preserve">
          <source>Note that variants without a manually specified discriminant are numbered from top to bottom starting from 0, so clashes can occur with seemingly unrelated variants.</source>
          <target state="translated">수동으로 지정된 판별 변수가없는 변형은 0부터 시작하여 위에서 아래로 번호가 매겨 지므로 관련이없는 변형으로 충돌이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76fed75fcc53f6083929938f0584d1d34ef49d4d" translate="yes" xml:space="preserve">
          <source>Note that we added a type annotation here. Because we aren&amp;rsquo;t inserting any values into this vector, Rust doesn&amp;rsquo;t know what kind of elements we intend to store. This is an important point. Vectors are implemented using generics; we&amp;rsquo;ll cover how to use generics with your own types in Chapter 10. For now, know that the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type provided by the standard library can hold any type, and when a specific vector holds a specific type, the type is specified within angle brackets. In Listing 8-1, we&amp;rsquo;ve told Rust that the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;v&lt;/code&gt; will hold elements of the &lt;code&gt;i32&lt;/code&gt; type.</source>
          <target state="translated">여기에 유형 주석이 추가되었습니다. 이 벡터에 값을 삽입하지 않기 때문에 Rust는 어떤 종류의 요소를 저장할 것인지 모릅니다. 이것은 중요한 포인트입니다. 벡터는 제네릭을 사용하여 구현됩니다. 우리는 10 장에서 자신 만의 타입으로 제네릭을 사용하는 방법을 다룰 것입니다. 지금, 표준 라이브러리가 제공 하는 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 타입은 모든 타입을 보유 할 수 있으며 특정 벡터가 특정 타입을 보유 할 때 타입은 꺾쇠 괄호 안에 지정됩니다. Listing 8-1 에서 &lt;code&gt;v&lt;/code&gt; 의 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 가 &lt;code&gt;i32&lt;/code&gt; 유형의 요소를 보유 할 것이라고 Rust에 말했다 .</target>
        </trans-unit>
        <trans-unit id="2c79056cb286ed85ac028f7264150a40f531f9d9" translate="yes" xml:space="preserve">
          <source>Note that we added the &lt;code&gt;case_sensitive&lt;/code&gt; field that holds a Boolean. Next, we need the &lt;code&gt;run&lt;/code&gt; function to check the &lt;code&gt;case_sensitive&lt;/code&gt; field&amp;rsquo;s value and use that to decide whether to call the &lt;code&gt;search&lt;/code&gt; function or the &lt;code&gt;search_case_insensitive&lt;/code&gt; function, as shown in Listing 12-22. Note this still won&amp;rsquo;t compile yet.</source>
          <target state="translated">부울을 보유하는 &lt;code&gt;case_sensitive&lt;/code&gt; 필드를 추가했습니다 . 다음으로, &lt;code&gt;case_sensitive&lt;/code&gt; 필드의 값 을 확인하고 이를 사용하여 &lt;code&gt;search&lt;/code&gt; 함수 또는 &lt;code&gt;search_case_insensitive&lt;/code&gt; 함수 를 호출할지 여부를 결정하는 데 &lt;code&gt;run&lt;/code&gt; 함수 가 필요합니다 ( 목록 12-22 참조). 아직 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d033b37f19d17a68bf9778f4a3805418777a67e9" translate="yes" xml:space="preserve">
          <source>Note that we don&amp;rsquo;t need to mark the resulting &lt;code&gt;split_at_mut&lt;/code&gt; function as &lt;code&gt;unsafe&lt;/code&gt;, and we can call this function from safe Rust. We&amp;rsquo;ve created a safe abstraction to the unsafe code with an implementation of the function that uses &lt;code&gt;unsafe&lt;/code&gt; code in a safe way, because it creates only valid pointers from the data this function has access to.</source>
          <target state="translated">결과 &lt;code&gt;split_at_mut&lt;/code&gt; 함수를 &lt;code&gt;unsafe&lt;/code&gt; 로 표시 할 필요가 없으며 safe Rust에서이 함수를 호출 할 수 있습니다. &lt;code&gt;unsafe&lt;/code&gt; 코드를 안전하게 사용하는 함수를 구현하여 안전하지 않은 코드를 안전하게 추상화했습니다. 이 함수는이 함수가 액세스 할 수있는 데이터에서 유효한 포인터 만 생성하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="79f8d5116fd5bb5dc0c20baa33c391d983b3d588" translate="yes" xml:space="preserve">
          <source>Note that we have to declare &lt;code&gt;T&lt;/code&gt; just after &lt;code&gt;impl&lt;/code&gt; so we can use it to specify that we&amp;rsquo;re implementing methods on the type &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;. By declaring &lt;code&gt;T&lt;/code&gt; as a generic type after &lt;code&gt;impl&lt;/code&gt;, Rust can identify that the type in the angle brackets in &lt;code&gt;Point&lt;/code&gt; is a generic type rather than a concrete type.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; 바로 뒤에 &lt;code&gt;T&lt;/code&gt; 를 선언 해야 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 유형에서 메소드를 구현하도록 지정할 수 있습니다 . &lt;code&gt;impl&lt;/code&gt; 뒤에 &lt;code&gt;T&lt;/code&gt; 를 일반 유형으로 선언 하면 Rust는 &lt;code&gt;Point&lt;/code&gt; 의 꺾쇠 괄호 유형이 콘크리트 유형이 아닌 일반 유형 임을 식별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21933f931bffb1331e5d307d3ac351285280040d" translate="yes" xml:space="preserve">
          <source>Note that we must use the fully qualified syntax that we talked about earlier in the &lt;a href=&quot;ch19-03-advanced-traits#advanced-traits&quot;&gt;&amp;ldquo;Advanced Traits&amp;rdquo;&lt;/a&gt; section because there are multiple functions available named &lt;code&gt;to_string&lt;/code&gt;. Here, we&amp;rsquo;re using the &lt;code&gt;to_string&lt;/code&gt; function defined in the &lt;code&gt;ToString&lt;/code&gt; trait, which the standard library has implemented for any type that implements &lt;code&gt;Display&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;to_string&lt;/code&gt; 이라는 여러 함수를 사용할 수 있으므로 앞에서 설명한 &lt;a href=&quot;ch19-03-advanced-traits#advanced-traits&quot;&gt;&quot;고급 특성&quot;&lt;/a&gt; 섹션 에서 설명한 정규화 된 구문을 사용해야합니다 . 여기에서는 표준 라이브러리가 &lt;code&gt;Display&lt;/code&gt; 를 구현하는 모든 유형에 대해 구현 한 &lt;code&gt;ToString&lt;/code&gt; 특성에 정의 된 &lt;code&gt;to_string&lt;/code&gt; 함수를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="096f913e45816f67a5f4300a1107c11162218bda" translate="yes" xml:space="preserve">
          <source>Note that we need lifetime annotations on this method, as we discussed in Chapter 10. We&amp;rsquo;re taking a reference to a &lt;code&gt;post&lt;/code&gt; as an argument and returning a reference to part of that &lt;code&gt;post&lt;/code&gt;, so the lifetime of the returned reference is related to the lifetime of the &lt;code&gt;post&lt;/code&gt; argument.</source>
          <target state="translated">10 장에서 논의한 것처럼이 방법에 대한 수명 주석이 필요합니다. &lt;code&gt;post&lt;/code&gt; 대한 참조를 인수로 사용하여 해당 &lt;code&gt;post&lt;/code&gt; 일부에 대한 참조를 반환하므로 반환 된 참조 의 수명은 &lt;code&gt;post&lt;/code&gt; 인수의 수명 .</target>
        </trans-unit>
        <trans-unit id="0a3ac30cf1c59aeb030a71d5cf7a71a2b0dfbcb7" translate="yes" xml:space="preserve">
          <source>Note that we need to first &lt;code&gt;use&lt;/code&gt; the &lt;code&gt;HashMap&lt;/code&gt; from the collections portion of the standard library. Of our three common collections, this one is the least often used, so it&amp;rsquo;s not included in the features brought into scope automatically in the prelude. Hash maps also have less support from the standard library; there&amp;rsquo;s no built-in macro to construct them, for example.</source>
          <target state="translated">먼저 표준 라이브러리의 collections 부분에서 &lt;code&gt;HashMap&lt;/code&gt; 을 &lt;code&gt;use&lt;/code&gt; 합니다 . 세 가지 공통 모음 중이 모음은 가장 많이 사용되지 않으므로 서곡에 자동으로 포함 된 기능에는 포함되지 않습니다. 해시 맵은 표준 라이브러리의 지원이 적습니다. 예를 들어 내장 매크로가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5da3fc4decf52dc450c6e612f0f2c00362fc9669" translate="yes" xml:space="preserve">
          <source>Note that we needed the &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; on the left-hand side. This is because we could collect into, for example, a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">왼쪽에 &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 가 필요합니다 . 예를 들어 &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 대신 수집 할 수 있기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="75b55fff64dcfe7729e494e2a0b5e033941b67c8" translate="yes" xml:space="preserve">
          <source>Note that we needed to make &lt;code&gt;v1_iter&lt;/code&gt; mutable: calling the &lt;code&gt;next&lt;/code&gt; method on an iterator changes internal state that the iterator uses to keep track of where it is in the sequence. In other words, this code &lt;em&gt;consumes&lt;/em&gt;, or uses up, the iterator. Each call to &lt;code&gt;next&lt;/code&gt; eats up an item from the iterator. We didn&amp;rsquo;t need to make &lt;code&gt;v1_iter&lt;/code&gt; mutable when we used a &lt;code&gt;for&lt;/code&gt; loop because the loop took ownership of &lt;code&gt;v1_iter&lt;/code&gt; and made it mutable behind the scenes.</source>
          <target state="translated">&lt;code&gt;v1_iter&lt;/code&gt; 를 변경 가능 하게 만들어야 했습니다. 반복자 에서 &lt;code&gt;next&lt;/code&gt; 메소드를 호출 하면 반복자가 시퀀스의 위치를 ​​추적하는 데 사용하는 내부 상태가 변경됩니다. 즉,이 코드 &lt;em&gt;는&lt;/em&gt; 반복자를 &lt;em&gt;소비&lt;/em&gt; 하거나 사용합니다. &lt;code&gt;next&lt;/code&gt; 호출 할 때마다 반복기에서 항목을 가져옵니다. 루프가 &lt;code&gt;v1_iter&lt;/code&gt; 의 소유권을 가져 와서 장면 뒤에서 변경 가능하게 했기 때문에 &lt;code&gt;for&lt;/code&gt; 루프를 사용할 때 &lt;code&gt;v1_iter&lt;/code&gt; 를 변경 가능 하게 만들 필요가 없었 습니다 .</target>
        </trans-unit>
        <trans-unit id="5994cd1512c44aaad650a1803fdb7c349136ad1d" translate="yes" xml:space="preserve">
          <source>Note that we want the function to take string slices, which are references, because we don&amp;rsquo;t want the &lt;code&gt;longest&lt;/code&gt; function to take ownership of its parameters. Refer to the &lt;a href=&quot;ch04-03-slices#string-slices-as-parameters&quot;&gt;&amp;ldquo;String Slices as Parameters&amp;rdquo;&lt;/a&gt; section in Chapter 4 for more discussion about why the parameters we use in Listing 10-20 are the ones we want.</source>
          <target state="translated">&lt;code&gt;longest&lt;/code&gt; 함수가 매개 변수의 소유권을 갖기를 원하지 않기 때문에 함수 가 참조 인 문자열 슬라이스를 사용하기를 원합니다 . 목록 10-20에서 사용하는 매개 변수가 우리가 원하는 매개 변수 인 이유에 대한 자세한 내용은 4 장의 &lt;a href=&quot;ch04-03-slices#string-slices-as-parameters&quot;&gt;&quot;문자열 슬라이스를 매개 변수로&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ee6c1ea883902ac8da8cc6969cf6510f9cd8cc8" translate="yes" xml:space="preserve">
          <source>Note that we want the function to take string slices, which are references, because we don&amp;rsquo;t want the &lt;code&gt;longest&lt;/code&gt; function to take ownership of its parameters. We want to allow the function to accept slices of a &lt;code&gt;String&lt;/code&gt; (the type stored in the variable &lt;code&gt;string1&lt;/code&gt;) as well as string literals (which is what variable &lt;code&gt;string2&lt;/code&gt; contains).</source>
          <target state="translated">&lt;code&gt;longest&lt;/code&gt; 함수가 매개 변수의 소유권을 갖기를 원하지 않기 때문에 함수 가 참조 인 문자열 슬라이스를 사용하기를 원합니다 . 우리는 함수가 &lt;code&gt;String&lt;/code&gt; 조각 (변수 &lt;code&gt;string1&lt;/code&gt; 에 저장된 유형 )뿐만 아니라 문자열 리터럴 (변수 &lt;code&gt;string2&lt;/code&gt; 가 포함하는 것) 을 허용하도록하고 싶습니다 .</target>
        </trans-unit>
        <trans-unit id="f37dca568a2a5ec6c0b22f134958fd92838997bb" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve added a new line inside the &lt;code&gt;tests&lt;/code&gt; module: &lt;code&gt;use super::*;&lt;/code&gt;. The &lt;code&gt;tests&lt;/code&gt; module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Modules as the Privacy Boundary&amp;rdquo;&lt;/a&gt; section. Because the &lt;code&gt;tests&lt;/code&gt; module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here so anything we define in the outer module is available to this &lt;code&gt;tests&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;tests&lt;/code&gt; 모듈 안에 새로운 줄을 추가했습니다 : &lt;code&gt;use super::*;&lt;/code&gt; . &lt;code&gt;tests&lt;/code&gt; 모듈은 우리가에서 7 장에서 다루는 보통의 가시성 규칙은 다음과 일반 모듈 &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&quot;개인 정보 보호 경계로 모듈&quot;&lt;/a&gt; 절을 참조하십시오. 때문에 &lt;code&gt;tests&lt;/code&gt; 모듈은 내부 모듈로서, 우리는 내부 모듈의 범위 내로 외부 모듈 테스트중인 코드를 가져와야. 여기서는 glob를 사용하므로 외부 모듈에서 정의한 모든 것을이 &lt;code&gt;tests&lt;/code&gt; 모듈에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e05c11c9aa8615f8372dccd3f7625301eed4295" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve added a new line inside the &lt;code&gt;tests&lt;/code&gt; module: &lt;code&gt;use super::*;&lt;/code&gt;. The &lt;code&gt;tests&lt;/code&gt; module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&amp;ldquo;Paths for Referring to an Item in the Module Tree&amp;rdquo;&lt;/a&gt; section. Because the &lt;code&gt;tests&lt;/code&gt; module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here so anything we define in the outer module is available to this &lt;code&gt;tests&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;tests&lt;/code&gt; 모듈 내부에 새 줄을 추가했습니다 . &lt;code&gt;use super::*;&lt;/code&gt; . &lt;code&gt;tests&lt;/code&gt; 모듈은 우리가 7 장에서 다루는 보통의 가시성 규칙은 다음과 일반 모듈 &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&quot;모듈 트리의 항목을 참조하기위한 경로&quot;&lt;/a&gt; 절을 참조하십시오. 때문에 &lt;code&gt;tests&lt;/code&gt; 모듈은 내부 모듈로서, 우리는 내부 모듈의 범위 내로 외부 모듈 테스트중인 코드를 가져와야. 여기서는 glob을 사용하므로 외부 모듈에서 정의한 모든 것을이 &lt;code&gt;tests&lt;/code&gt; 모듈에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26a0be4b24350107b09144aaaa2ad0fb91731191" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve edited the old test&amp;rsquo;s &lt;code&gt;contents&lt;/code&gt; too. We&amp;rsquo;ve added a new line with the text &lt;code&gt;&quot;Duct tape.&quot;&lt;/code&gt; using a capital D that shouldn&amp;rsquo;t match the query &lt;code&gt;&quot;duct&quot;&lt;/code&gt; when we&amp;rsquo;re searching in a case-sensitive manner. Changing the old test in this way helps ensure that we don&amp;rsquo;t accidentally break the case-sensitive search functionality that we&amp;rsquo;ve already implemented. This test should pass now and should continue to pass as we work on the case-insensitive search.</source>
          <target state="translated">이전 테스트의 &lt;code&gt;contents&lt;/code&gt; 도 편집했습니다 . &lt;code&gt;&quot;Duct tape.&quot;&lt;/code&gt; 라는 텍스트가 새 줄에 추가되었습니다 . 대소 문자 구분 방식으로 검색 할 때 쿼리 &lt;code&gt;&quot;duct&quot;&lt;/code&gt; 와 일치하지 않아야하는 대문자 D를 사용합니다 . 이 방법으로 이전 테스트를 변경하면 이미 구현 한 대소 문자 구분 검색 기능을 실수로 중단하지 않습니다. 이 테스트는 이제 통과해야하며 대소 문자를 구분하지 않는 검색을 수행하면서 계속 통과해야합니다.</target>
        </trans-unit>
        <trans-unit id="2e87959963706a5a2e57c9724a365d2a982bba5d" translate="yes" xml:space="preserve">
          <source>Note that when the wildcard &lt;code&gt;*&lt;/code&gt; is used on a type, it does not import its methods (though for &lt;code&gt;enum&lt;/code&gt;s it imports the variants, as shown in the example below).</source>
          <target state="translated">와일드 카드 &lt;code&gt;*&lt;/code&gt; 가 유형에 사용되는 경우 메서드를 가져 오지 않습니다 ( &lt;code&gt;enum&lt;/code&gt; 의 경우 아래 예에 표시된대로 변형을 가져 오지만).</target>
        </trans-unit>
        <trans-unit id="2b7bbbf14e1bc0dbc3662e9181bd406f83393130" translate="yes" xml:space="preserve">
          <source>Note that where ties occur, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; is generally going to be faster than &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; is generally going to be faster than &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">관계가 발생하는 경우, 유의 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; 일반적으로보다 더 빨리 될 것입니다 &lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; 는&lt;/a&gt; 일반적으로보다 더 빨리 될 것입니다 &lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; 의&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b62f50352e9e786c961cd72638314895b5c9fdfc" translate="yes" xml:space="preserve">
          <source>Note that while concurrent access to environment variables is safe in Rust, some platforms only expose inherently unsafe non-threadsafe APIs for inspecting the environment. As a result extra care needs to be taken when auditing calls to unsafe external FFI functions to ensure that any external environment accesses are properly synchronized with accesses in Rust.</source>
          <target state="translated">Rust에서는 환경 변수에 대한 동시 액세스가 안전하지만 일부 플랫폼은 환경 검사를 위해 본질적으로 안전하지 않은 스레드 안전하지 않은 API 만 노출합니다. 결과적으로 안전하지 않은 외부 FFI 기능에 대한 호출을 감사 할 때 외부 환경 액세스가 Rust의 액세스와 올바르게 동기화되도록주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="d3954c01ae7015c1edc03c422ae6922dcf56ba11" translate="yes" xml:space="preserve">
          <source>Note that while concurrent access to environment variables is safe in Rust, some platforms only expose inherently unsafe non-threadsafe APIs for inspecting the environment. As a result, extra care needs to be taken when auditing calls to unsafe external FFI functions to ensure that any external environment accesses are properly synchronized with accesses in Rust.</source>
          <target state="translated">Rust에서는 환경 변수에 대한 동시 액세스가 안전하지만 일부 플랫폼은 환경을 검사하기 위해 본질적으로 안전하지 않은 스레드 안전하지 않은 API 만 노출합니다. 결과적으로 안전하지 않은 외부 FFI 함수에 대한 호출을 감사 할 때 외부 환경 액세스가 Rust의 액세스와 적절하게 동기화되도록 추가주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="324300377b3c3f353b3f11bc282603959b1e1422" translate="yes" xml:space="preserve">
          <source>Note that while mutating or mutably aliasing the contents of an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is ok (provided you enforce the invariants some other way), it is still undefined behavior to have multiple &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; aliases.</source>
          <target state="translated">&lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 의 내용을 변경하거나 변경 가능하게 앨리어싱하는 것은 괜찮지 만 (다른 방법으로 불변을 적용하는 경우) 여러 개의 &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 별칭 을 갖는 것은 아직 정의되지 않은 동작 입니다.</target>
        </trans-unit>
        <trans-unit id="9eb90457458f8170cc06094675d04f9c0e8116dd" translate="yes" xml:space="preserve">
          <source>Note that whilst mutating the contents of an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; (even while other &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; references alias the cell) is ok (provided you enforce the above invariants some other way), it is still undefined behavior to have multiple &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; aliases. That is, &lt;code&gt;UnsafeCell&lt;/code&gt; is a wrapper designed to have a special interaction with &lt;em&gt;shared&lt;/em&gt; accesses (&lt;em&gt;i.e.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; reference); there is no magic whatsoever when dealing with &lt;em&gt;exclusive&lt;/em&gt; accesses (&lt;em&gt;e.g.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt;): neither the cell nor the wrapped value may be aliased for the duration of that &lt;code&gt;&amp;amp;mut&lt;/code&gt; borrow. This is showcased by the &lt;a href=&quot;struct.unsafecell#method.get_mut&quot;&gt;&lt;code&gt;.get_mut()&lt;/code&gt;&lt;/a&gt; accessor, which is a non-&lt;code&gt;unsafe&lt;/code&gt; getter that yields a &lt;code&gt;&amp;amp;mut T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 의 내용을 변경하는 동안 (다른 &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 가 셀 별칭을 참조 하는 경우에도 ) 괜찮지 만 (위의 불변을 다른 방식으로 적용하는 경우) 여전히 정의되지 않은 동작으로 여러 &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 별칭. 즉, &lt;code&gt;UnsafeCell&lt;/code&gt; 은 &lt;em&gt;공유&lt;/em&gt; 액세스 ( &lt;em&gt;예 : &lt;/em&gt; &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; 참조를 통해) 와 특별한 상호 작용을 갖도록 설계된 래퍼입니다 . 를 처리 할 때 마법은 전혀 없다 &lt;em&gt;독점&lt;/em&gt; (액세스 &lt;em&gt;예&lt;/em&gt; 를 통해, &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; ) :그 기간 동안 셀이나 래핑 된 값 모두 별칭을 지정할 수 없습니다. &lt;code&gt;&amp;amp;mut&lt;/code&gt; 빌려. 이것은 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 를 산출하는 &lt;code&gt;unsafe&lt;/code&gt; getter 인 &lt;a href=&quot;struct.unsafecell#method.get_mut&quot;&gt; &lt;code&gt;.get_mut()&lt;/code&gt; &lt;/a&gt; 접근 자에 의해 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7ea0c44d2eb4a19014b1a6e779035e8b52686247" translate="yes" xml:space="preserve">
          <source>Note that with this function, the new thread will be stopped when the main thread ends, whether or not it has finished running. The output from this program might be a little different every time, but it will look similar to the following:</source>
          <target state="translated">이 기능을 사용하면 메인 스레드가 종료되면 실행이 완료되었는지 여부에 관계없이 새 스레드가 중지됩니다. 이 프로그램의 출력은 매번 약간 씩 다를 수 있지만 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="499913d6f995a629a9ad09275a1ae60af65eff00" translate="yes" xml:space="preserve">
          <source>Note that writing updates the slice to point to the yet unwritten part. The slice will be empty when it has been completely overwritten.</source>
          <target state="translated">쓰면 아직 쓰지 않은 부분을 가리 키도록 슬라이스가 업데이트됩니다. 완전히 덮어 쓰면 슬라이스가 비게됩니다.</target>
        </trans-unit>
        <trans-unit id="30da6e410f76967402353bb250335b332eb88eb5" translate="yes" xml:space="preserve">
          <source>Note that you cannot use the &lt;a href=&quot;../../book/appendix-02-operators&quot;&gt;&lt;code&gt;?&lt;/code&gt; operator&lt;/a&gt; in functions that do not return a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. Instead, you can call &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;.unwrap()&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;match&lt;/code&gt; on the return value to catch any possible errors:</source>
          <target state="translated">&lt;a href=&quot;../../book/appendix-02-operators&quot;&gt; &lt;code&gt;?&lt;/code&gt; 를&lt;/a&gt; 사용할 수 없습니다 . &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; 반환하지 않는 함수의 연산자 . 대신 &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;.unwrap()&lt;/code&gt; &lt;/a&gt; 호출 하거나 반환 값을 &lt;code&gt;match&lt;/code&gt; 시켜 가능한 오류를 잡을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cd9969c1871eeacc0200593b93cdcffbccf3e66" translate="yes" xml:space="preserve">
          <source>Note that, although read and write methods require a &lt;code&gt;&amp;amp;mut File&lt;/code&gt;, because of the interfaces for &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;, the holder of a &lt;code&gt;&amp;amp;File&lt;/code&gt; can still modify the file, either through methods that take &lt;code&gt;&amp;amp;File&lt;/code&gt; or by retrieving the underlying OS object and modifying the file that way. Additionally, many operating systems allow concurrent modification of files by different processes. Avoid assuming that holding a &lt;code&gt;&amp;amp;File&lt;/code&gt; means that the file will not change.</source>
          <target state="translated">read 및 write 메소드에는 &lt;code&gt;&amp;amp;mut File&lt;/code&gt; 필요하지만 &lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; 인터페이스로 인해 &lt;code&gt;&amp;amp;File&lt;/code&gt; 홀더는 &amp;amp; File 을 사용하는 메소드를 통해 또는 기본 OS 오브젝트를 검색하고 &lt;code&gt;&amp;amp;File&lt;/code&gt; 을 수정하여 파일을 계속 수정할 수 있습니다. 그런 식으로. 또한 많은 운영 체제에서 서로 다른 프로세스로 파일을 동시에 수정할 수 있습니다. &lt;code&gt;&amp;amp;File&lt;/code&gt; 을 보유 하면 파일이 변경되지 않는다고 가정하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="1d0cf8461e762586f36c776928c774ad1d9122e5" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;$crate&lt;/code&gt; refers to the current crate, it must be used with a fully qualified module path when referring to non-macro items:</source>
          <target state="translated">&lt;code&gt;$crate&lt;/code&gt; 는 현재 상자를 나타내므로 매크로가 아닌 항목을 참조 할 때 정규화 된 모듈 경로와 함께 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="160864ae0e83232cc21d9f02b2b16fec0e686a4e" translate="yes" xml:space="preserve">
          <source>Note that, like the &lt;code&gt;Option&lt;/code&gt; enum, the &lt;code&gt;Result&lt;/code&gt; enum and its variants have been brought into scope by the prelude, so we don&amp;rsquo;t need to specify &lt;code&gt;Result::&lt;/code&gt; before the &lt;code&gt;Ok&lt;/code&gt; and &lt;code&gt;Err&lt;/code&gt; variants in the &lt;code&gt;match&lt;/code&gt; arms.</source>
          <target state="translated">등, 그 주 &lt;code&gt;Option&lt;/code&gt; 열거의 &lt;code&gt;Result&lt;/code&gt; 우리가 지정할 필요가 없습니다 열거 및 그 변종은 전주곡에 의해 범위를하게 된 &lt;code&gt;Result::&lt;/code&gt; 전과 &lt;code&gt;Ok&lt;/code&gt; 하고 &lt;code&gt;Err&lt;/code&gt; 변종 &lt;code&gt;match&lt;/code&gt; 팔.</target>
        </trans-unit>
        <trans-unit id="669f2ea820772978e72d4c3d94e7389c9756f1a1" translate="yes" xml:space="preserve">
          <source>Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">그 참고이 &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;미래에 변경 될 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="169cf16d0a1c963eafd20679aea07a420f4eaf39" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;code&gt;repeat&lt;/code&gt;, &lt;code&gt;repeat_packed&lt;/code&gt; does not guarantee that the repeated instances of &lt;code&gt;self&lt;/code&gt; will be properly aligned, even if a given instance of &lt;code&gt;self&lt;/code&gt; is properly aligned. In other words, if the layout returned by &lt;code&gt;repeat_packed&lt;/code&gt; is used to allocate an array, it is not guaranteed that all elements in the array will be properly aligned.</source>
          <target state="translated">달리합니다 &lt;code&gt;repeat&lt;/code&gt; , &lt;code&gt;repeat_packed&lt;/code&gt; 수행의 반복 인스턴스 것을하지 보장 &lt;code&gt;self&lt;/code&gt; 올바르게 정렬됩니다의 지정된 인스턴스 경우에도 &lt;code&gt;self&lt;/code&gt; 올바르게 정렬됩니다. 다시 말해서, &lt;code&gt;repeat_packed&lt;/code&gt; 에 의해 리턴 된 레이아웃 이 배열을 할당하는 데 사용되는 경우, 배열의 모든 요소가 올바르게 정렬되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">참고 :</target>
        </trans-unit>
        <trans-unit id="fc7308ef65a4b47d9c6953435d548f4e965b07bd" translate="yes" xml:space="preserve">
          <source>Note the documentation for the primitives &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice/index&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also called 'slice'). Many method calls on &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually calls to methods on &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice/index&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="translated">원시 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;slice/index&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt; ( 'slice'라고도 함)에 대한 문서를 참고하십시오 . &lt;a href=&quot;string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 에 대한 많은 메서드 호출 은 실제로 &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref 강제&lt;/a&gt; 를 통한 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;slice/index&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt; 메서드에 대한 호출 입니다.</target>
        </trans-unit>
        <trans-unit id="d6d8fcef27cc36a94771021effc9ea114018af44" translate="yes" xml:space="preserve">
          <source>Note the documentation for the primitives &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also called 'slice'). Many method calls on &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;vec/index&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually calls to methods on &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="translated">프리미티브 &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt; ( '슬라이스'라고도 함)에 대한 설명서를 참고하십시오 . &lt;a href=&quot;string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;vec/index&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 많은 메소드 호출 은 실제로 &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref coercions&lt;/a&gt; 를 통해 &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; 의&lt;/a&gt; 메소드에 대한 호출 입니다.</target>
        </trans-unit>
        <trans-unit id="9ca3cd3caadb8f1bb227db05f6c5c7202e5bbf2b" translate="yes" xml:space="preserve">
          <source>Note to Implementors</source>
          <target state="translated">구현 자 참고 사항</target>
        </trans-unit>
        <trans-unit id="c4cf4c3bcaeb43c85321fdb977bbc1c650a58e54" translate="yes" xml:space="preserve">
          <source>Note to implementors: If this returns &lt;code&gt;Ok(ptr)&lt;/code&gt;, then &lt;code&gt;ptr&lt;/code&gt; must be considered &quot;currently allocated&quot; and must be acceptable input to methods such as &lt;code&gt;realloc&lt;/code&gt; or &lt;code&gt;dealloc&lt;/code&gt;, &lt;em&gt;even if&lt;/em&gt;&lt;code&gt;T&lt;/code&gt; is a zero-sized type. In other words, if your &lt;code&gt;Alloc&lt;/code&gt; implementation overrides this method in a manner that can return a zero-sized &lt;code&gt;ptr&lt;/code&gt;, then all reallocation and deallocation methods need to be similarly overridden to accept such values as input.</source>
          <target state="translated">구현에주의 :이 복귀하면 &lt;code&gt;Ok(ptr)&lt;/code&gt; , 다음 &lt;code&gt;ptr&lt;/code&gt; 고려해야 &quot;현재 할당 된&quot;과 같은 방식으로 허용 가능한 입력이어야 &lt;code&gt;realloc&lt;/code&gt; 또는 &lt;code&gt;dealloc&lt;/code&gt; , &lt;em&gt;하더라도 &lt;/em&gt; &lt;code&gt;T&lt;/code&gt; 는 제로 - 크기의 유형이다. 즉, &lt;code&gt;Alloc&lt;/code&gt; 구현이 크기가 0 인 &lt;code&gt;ptr&lt;/code&gt; 을 리턴 할 수있는 방식으로이 메소드를 대체하는 경우 입력과 같은 값을 승인하기 위해 모든 재 할당 및 할당 해제 메소드를 유사하게 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="eb0cc1533f57d8d34b3b5bb324e9cedcd986a56b" translate="yes" xml:space="preserve">
          <source>Note two details here. First, we use the index value of &lt;code&gt;2&lt;/code&gt; to get the third element: vectors are indexed by number, starting at zero. Second, the two ways to get the third element are by using &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt;, which gives us a reference, or by using the &lt;code&gt;get&lt;/code&gt; method with the index passed as an argument, which gives us an &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">여기에 두 가지 세부 사항이 있습니다. 먼저 인덱스 값 &lt;code&gt;2&lt;/code&gt; 를 사용하여 세 번째 요소를 가져옵니다. 벡터는 0부터 시작하여 숫자로 인덱스됩니다. 둘째, 세 번째 요소를 얻는 두 가지 방법은 &lt;code&gt;&amp;amp;&lt;/code&gt; 와 &lt;code&gt;[]&lt;/code&gt; 를 사용하여 참조를 제공하거나 인덱스로 인수로 전달 된 &lt;code&gt;get&lt;/code&gt; 메소드를 사용하여 &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; 를 제공하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3c6f9d9871d6089da68d73e5351d58428691fe43" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;OsString&lt;/code&gt; and &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; internally do not necessarily hold strings in the form native to the platform; While on Unix, strings are stored as a sequence of 8-bit values, on Windows, where strings are 16-bit value based as just discussed, strings are also actually stored as a sequence of 8-bit values, encoded in a less-strict variant of UTF-8. This is useful to understand when handling capacity and length values.</source>
          <target state="translated">참고로, &lt;code&gt;OsString&lt;/code&gt; 및 &lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; 은&lt;/a&gt; 내부적으로 플랫폼에 고유 한 형식으로 문자열을 보유 할 필요는 없습니다. Unix에서는 문자열이 8 비트 값의 시퀀스로 저장되는 반면, Windows에서는 방금 설명한대로 문자열이 16 비트 값을 기반으로하며, 문자열은 실제로 8 비트 값의 시퀀스로 저장되며 더 적은 값으로 인코딩됩니다. UTF-8의 엄격한 변형. 이는 용량 및 길이 값을 처리 할 때 이해하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c01e48a0e7e3eba8ed1aa3834f9c910b228bd638" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;OsString&lt;/code&gt; and &lt;code&gt;OsStr&lt;/code&gt; internally do not necessarily hold strings in the form native to the platform; While on Unix, strings are stored as a sequence of 8-bit values, on Windows, where strings are 16-bit value based as just discussed, strings are also actually stored as a sequence of 8-bit values, encoded in a less-strict variant of UTF-8. This is useful to understand when handling capacity and length values.</source>
          <target state="translated">참고 &lt;code&gt;OsString&lt;/code&gt; 및 &lt;code&gt;OsStr&lt;/code&gt; 는 내부적으로 반드시 플랫폼 형태 출신의 문자열을 보유하지 않는다; 유닉스에서는 문자열이 8 비트 값 시퀀스로 저장되고, Windows에서는 문자열이 앞에서 설명한대로 16 비트 값으로 저장되며, 문자열은 실제로 8 비트 값 시퀀스로 저장됩니다. UTF-8의 엄격한 변형. 용량 및 길이 값을 처리 할 때 이해하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1b6562c6a35d081cb513ca527b316f894645e45c" translate="yes" xml:space="preserve">
          <source>Note, however, that instants are not guaranteed to be &lt;strong&gt;steady&lt;/strong&gt;. In other words, each tick of the underlying clock may not be the same length (e.g. some seconds may be longer than others). An instant may jump forwards or experience time dilation (slow down or speed up), but it will never go backwards.</source>
          <target state="translated">그러나 순간이 &lt;strong&gt;안정적&lt;/strong&gt; 임을 보장하지는 않습니다 . 다시 말해, 기본 클록의 각 틱은 동일한 길이가 아닐 수있다 (예를 들어, 몇 초는 다른 것보다 길 수있다). 순간이 앞으로 뛰거나 시간이 느려질 수 있지만 (느리게하거나 속도가 빨라질 수 있지만) 결코 뒤쳐지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fd9dfc12db2bc0dbc56fcf4d3cda55381327924" translate="yes" xml:space="preserve">
          <source>Note, however, that items with the same name are allowed for inherent &lt;code&gt;impl&lt;/code&gt; blocks that don't overlap:</source>
          <target state="translated">그러나 이름이 같은 항목은 겹치지 않는 고유 한 &lt;code&gt;impl&lt;/code&gt; 블록에 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="bba68cd3cf8ae8ea0e35e174666c8e34f0cdd55c" translate="yes" xml:space="preserve">
          <source>Note, however, that this is not an unsafe trait, so there is not a succinct contract that this trait is providing. Instead it is intended as more of a &quot;speed bump&quot; to alert users of &lt;code&gt;catch_unwind&lt;/code&gt; that broken invariants may be witnessed and may need to be accounted for.</source>
          <target state="translated">그러나 이것은 안전하지 않은 특성이 아니므로이 특성이 제공하는 간결한 계약이 없습니다. 대신, 사용자에게 &lt;code&gt;catch_unwind&lt;/code&gt; 에 대해 경고하기 위해 &quot;스피드 범프&quot;를 더 많이 사용하여 깨진 불변이 목격 될 수 있으며이를 고려해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9f40e0b31d5319e2e2946733cad557830f8c197" translate="yes" xml:space="preserve">
          <source>Note, in many cases, the &lt;code&gt;.parse()&lt;/code&gt; method on &lt;code&gt;str&lt;/code&gt; is more proper.</source>
          <target state="translated">많은 경우 &lt;code&gt;str&lt;/code&gt; 의 &lt;code&gt;.parse()&lt;/code&gt; 메소드 가 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="74d10a535a759833af93c81cb97d5c0957382347" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Pin&lt;/code&gt; also implements &lt;code&gt;Deref&lt;/code&gt; to the target, which can be used to access the inner value. However, &lt;code&gt;Deref&lt;/code&gt; only provides a reference that lives for as long as the borrow of the &lt;code&gt;Pin&lt;/code&gt;, not the lifetime of the &lt;code&gt;Pin&lt;/code&gt; itself. This method allows turning the &lt;code&gt;Pin&lt;/code&gt; into a reference with the same lifetime as the original &lt;code&gt;Pin&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;Pin&lt;/code&gt; 은 대상에 대한 &lt;code&gt;Deref&lt;/code&gt; 를 구현 하여 내부 값에 액세스하는 데 사용할 수 있습니다. 그러나 &lt;code&gt;Deref&lt;/code&gt; 는 &lt;code&gt;Pin&lt;/code&gt; 자체 의 수명이 아니라 &lt;code&gt;Pin&lt;/code&gt; 을 빌리는 기간 동안 만 참조 할 수 있습니다 . 이 방법을 사용하면 &lt;code&gt;Pin&lt;/code&gt; 을 원래 &lt;code&gt;Pin&lt;/code&gt; 과 동일한 수명으로 기준으로 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e10aafb3dc6afa8d8827646e5b1be7126b35103b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Pin&lt;/code&gt; also implements &lt;code&gt;DerefMut&lt;/code&gt; to the data, which can be used to access the inner value. However, &lt;code&gt;DerefMut&lt;/code&gt; only provides a reference that lives for as long as the borrow of the &lt;code&gt;Pin&lt;/code&gt;, not the lifetime of the &lt;code&gt;Pin&lt;/code&gt; itself. This method allows turning the &lt;code&gt;Pin&lt;/code&gt; into a reference with the same lifetime as the original &lt;code&gt;Pin&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;Pin&lt;/code&gt; 은 데이터에 &lt;code&gt;DerefMut&lt;/code&gt; 을 구현 하여 내부 값에 액세스하는 데 사용할 수 있습니다. 그러나 &lt;code&gt;DerefMut&lt;/code&gt; 은 &lt;code&gt;Pin&lt;/code&gt; 자체 의 수명이 아니라 &lt;code&gt;Pin&lt;/code&gt; 을 빌린 기간 동안 지속되는 참조 만 제공 합니다. 이 방법을 사용하면 &lt;code&gt;Pin&lt;/code&gt; 을 원래 &lt;code&gt;Pin&lt;/code&gt; 과 동일한 수명으로 기준으로 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe08fa35bb3e2ac30191647bef4f566cd6842a4b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;core&lt;/code&gt; provides &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html#method.caller&quot;&gt;&lt;code&gt;core::panic::Location::caller&lt;/code&gt;&lt;/a&gt; for observing caller locations. It wraps the &lt;a href=&quot;https://doc.rust-lang.org/core/intrinsics/fn.caller_location.html&quot;&gt;&lt;code&gt;core::intrinsics::caller_location&lt;/code&gt;&lt;/a&gt; intrinsic implemented by &lt;code&gt;rustc&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;core&lt;/code&gt; 는 발신자 위치를 관찰하기 위해 &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html#method.caller&quot;&gt; &lt;code&gt;core::panic::Location::caller&lt;/code&gt; &lt;/a&gt; 를 제공합니다 . 그것은 랩 &lt;a href=&quot;https://doc.rust-lang.org/core/intrinsics/fn.caller_location.html&quot;&gt; &lt;code&gt;core::intrinsics::caller_location&lt;/code&gt; &lt;/a&gt; 고유에 의해 구현 &lt;code&gt;rustc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da175d20fbd0f82cb13b82934a46d444a5435526" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;fold()&lt;/code&gt;, and similar methods that traverse the entire iterator, may not terminate for infinite iterators, even on traits for which a result is determinable in finite time.</source>
          <target state="translated">참고 : &lt;code&gt;fold()&lt;/code&gt; 및 전체 반복자를 통과하는 유사한 메소드는 결과가 유한 시간 내에 결정될 수있는 특성에서도 무한 반복자에 대해 종료되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e47db031d7d5048ad3ea3101c6bbce09857b0d75" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;move&lt;/code&gt; closures may still implement &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them.</source>
          <target state="translated">참고 : &lt;code&gt;move&lt;/code&gt; 클로저는 이동으로 변수를 캡처하더라도 여전히 &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; 을&lt;/a&gt; 구현할 수 있습니다 . 클로저 유형으로 구현 된 특성은 클로저가 캡처하는 방식이 아니라 캡처 된 값으로 수행하는 특성에 따라 결정되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ddaee189fcb99b6fc9ed6acd8de34bd62f953e86" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;move&lt;/code&gt; closures may still implement &lt;a href=&quot;ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, even though they capture variables by &lt;code&gt;move&lt;/code&gt;. This is because the traits implemented by a closure type are determined by &lt;em&gt;what&lt;/em&gt; the closure does with captured values, not &lt;em&gt;how&lt;/em&gt; it captures them:</source>
          <target state="translated">참고 : &lt;code&gt;move&lt;/code&gt; 클로저는 &lt;code&gt;move&lt;/code&gt; 로 변수를 캡처하더라도 여전히 &lt;a href=&quot;ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; 을&lt;/a&gt; 구현할 수 있습니다 . 폐쇄 형에 의해 구현되는 특성에 의해 결정되기 때문입니다 &lt;em&gt;무엇을&lt;/em&gt; 폐쇄 캡처 값으로,하지 않는 &lt;em&gt;방법&lt;/em&gt; 은 그들을 캡처 :&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="690213e0deea1a6806299e07c579a3daee97b81a" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;rustc&lt;/code&gt; currently recognizes the tools &quot;clippy&quot; and &quot;rustfmt&quot;.</source>
          <target state="translated">참고 : &lt;code&gt;rustc&lt;/code&gt; 는 현재 &quot;clippy&quot;및 &quot;rustfmt&quot;도구를 인식합니다.</target>
        </trans-unit>
        <trans-unit id="16697ad37b7a39052ef81a40c40ae4ac1a88fc27" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;rustc&lt;/code&gt; has a default set of features enabled for each target and CPU. The CPU may be chosen with the &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu&quot;&gt;&lt;code&gt;-C target-cpu&lt;/code&gt;&lt;/a&gt; flag. Individual features may be enabled or disabled for an entire crate with the &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-feature&quot;&gt;&lt;code&gt;-C target-feature&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">참고 : &lt;code&gt;rustc&lt;/code&gt; 에는 각 대상 및 CPU에 대해 사용 가능한 기본 기능 세트가 있습니다. CPU는 &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu&quot;&gt; &lt;code&gt;-C target-cpu&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 선택할 수 있습니다 . &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-feature&quot;&gt; &lt;code&gt;-C target-feature&lt;/code&gt; &lt;/a&gt; 플래그 를 사용하여 전체 상자에 대해 개별 기능을 활성화 또는 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f9c395bf29ddc7654449b79d4dc0411e7becef5" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;str&lt;/code&gt; in &lt;code&gt;Concat&amp;lt;str&amp;gt;&lt;/code&gt; is not meaningful here. This type parameter of the trait only exists to enable another impl.</source>
          <target state="translated">참고 : &lt;code&gt;str&lt;/code&gt; 에서 &lt;code&gt;Concat&amp;lt;str&amp;gt;&lt;/code&gt; 여기에 의미가 없습니다. 이 특성 유형 매개 변수는 다른 impl을 활성화하기 위해서만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="c0d79cac345f205a82618d9422d71b4ef0b8bd13" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;union&lt;/code&gt;s with non-&lt;code&gt;Copy&lt;/code&gt; fields are unstable, see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/55149&quot;&gt;55149&lt;/a&gt;.</source>
          <target state="translated">참고 : 비 &lt;code&gt;Copy&lt;/code&gt; 필드가있는 &lt;code&gt;union&lt;/code&gt; 는 불안정 합니다. &lt;a href=&quot;https://github.com/rust-lang/rust/issues/55149&quot;&gt;55149를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="03f067cb5c2a75451afd3b78affad51470bfd979" translate="yes" xml:space="preserve">
          <source>Note: A saying you might hear about languages with strict compilers, such as Haskell and Rust, is &amp;ldquo;if the code compiles, it works.&amp;rdquo; But this saying is not universally true. Our project compiles, but it does absolutely nothing! If we were building a real, complete project, this would be a good time to start writing unit tests to check that the code compiles &lt;em&gt;and&lt;/em&gt; has the behavior we want.</source>
          <target state="translated">참고 : Haskell 및 Rust와 같은 엄격한 컴파일러를 사용하는 언어에 대해들을 수 있다는 말은 &quot;코드가 컴파일되면 작동합니다.&quot;입니다. 그러나이 말은 보편적으로 사실이 아닙니다. 우리 프로젝트는 컴파일되지만 전혀 아무것도하지 않습니다! 우리가 실제적이고 완전한 프로젝트를 만들고 있다면, 코드가 컴파일 &lt;em&gt;되고&lt;/em&gt; 원하는 동작을 가지고 있는지 확인하기 위해 단위 테스트 작성을 시작하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="84c66645b448fa01124ab16b053b24421063478c" translate="yes" xml:space="preserve">
          <source>Note: Although Rust, like any other language, can be implemented by an interpreter as well as a compiler, the only existing implementation is a compiler, and the language has always been designed to be compiled. For these reasons, this section assumes a compiler.</source>
          <target state="translated">참고 : Rust는 다른 언어와 마찬가지로 컴파일러뿐만 아니라 인터프리터로도 구현할 수 있지만 기존의 유일한 구현은 컴파일러이며 언어는 항상 컴파일되도록 설계되었습니다. 이러한 이유로이 섹션에서는 컴파일러를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="549bd43e93414c7d2e6a9dbfe6f61cd7449ba2c8" translate="yes" xml:space="preserve">
          <source>Note: As a consequence of the representation being an attribute on the item, the representation does not depend on generic parameters. Any two types with the same name have the same representation. For example, &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; and &lt;code&gt;Foo&amp;lt;Baz&amp;gt;&lt;/code&gt; both have the same representation.</source>
          <target state="translated">참고 : 표현이 항목의 속성이기 때문에 표현은 일반 매개 변수에 의존하지 않습니다. 이름이 같은 두 유형은 모두 같은 표현을 갖습니다. 예를 들어, &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; 와 &lt;code&gt;Foo&amp;lt;Baz&amp;gt;&lt;/code&gt; 모두 동일한 표현을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="4eecc607640ace8103d5bc0d89cfb23325aabecd" translate="yes" xml:space="preserve">
          <source>Note: As a control flow expression, if a block expression is the outer expression of an expression statement, the expected type is &lt;code&gt;()&lt;/code&gt; unless it is followed immediately by a semicolon.</source>
          <target state="translated">주 : 제어 플로우 표현식으로서 블록 표현식이 표현식 명령문의 외부 표현식 인 경우 예상되는 유형은 바로 뒤에 세미콜론이 오지 않는 한 &lt;code&gt;()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="09b47fffa556007259b32260e62d1512eb70865a" translate="yes" xml:space="preserve">
          <source>Note: Due to the representation of &lt;code&gt;repr(C)&lt;/code&gt; structs and unions, if a variant has a single field there is no difference between putting that field directly in the union or wrapping it in a struct; any system which wishes to manipulate such an &lt;code&gt;enum&lt;/code&gt;'s representation may therefore use whichever form is more convenient or consistent for them.</source>
          <target state="translated">참고 : &lt;code&gt;repr(C)&lt;/code&gt; 구조체 및 공용체 의 표현으로 인해 변형에 단일 필드가있는 경우 해당 필드를 공용체에 직접 넣거나 구조체로 래핑하는 것 사이에는 차이가 없습니다. 따라서 이러한 &lt;code&gt;enum&lt;/code&gt; 의 표현 을 조작하려는 시스템 은 더 편리하거나 일관성있는 형식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4faa88d09ab8f796d3c14502d5099ff92578c5dd" translate="yes" xml:space="preserve">
          <source>Note: Except for lints, it is idiomatic to only use outer attributes on function items.</source>
          <target state="translated">참고 : 보푸라기를 제외하고 함수 항목에 외부 속성 만 사용하는 것은 관용적입니다.</target>
        </trans-unit>
        <trans-unit id="6b662a83fcf6e331b5fc245d3658b8a2a3115d43" translate="yes" xml:space="preserve">
          <source>Note: For clarity, it is recommended to always use the &lt;code&gt;dyn&lt;/code&gt; keyword on your trait objects unless your codebase supports compiling with Rust 1.26 or lower.</source>
          <target state="translated">참고 : 명확하게하기 위해 코드베이스가 Rust 1.26 이하로 컴파일하는 것을 지원하지 않는 경우 항상 형질 개체에 &lt;code&gt;dyn&lt;/code&gt; 키워드를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="1aaba7d58782adfa40a3a8e21596376db2da64ca" translate="yes" xml:space="preserve">
          <source>Note: For more on the implementation details of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type, see &amp;ldquo;The Rustonomicon&amp;rdquo; at https://doc.rust-lang.org/stable/nomicon/vec.html.</source>
          <target state="translated">참고 : &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 유형 의 구현 세부 사항에 대한 자세한 내용은 https://doc.rust-lang.org/stable/nomicon/vec.html의&amp;ldquo;Rustonomicon&amp;rdquo;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="12ed0cecef028f179120e48d11efd24c874bfd2d" translate="yes" xml:space="preserve">
          <source>Note: For more on the implementation details of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type, see &lt;a href=&quot;https://doc.rust-lang.org/nomicon/vec.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 유형 의 구현 세부 사항에 대한 자세한 내용 은 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/vec.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e05c47a1f80ea2f9b4aa153e205bdf1032d2902" translate="yes" xml:space="preserve">
          <source>Note: For simplicity&amp;rsquo;s sake, we&amp;rsquo;ll refer to many of the problems as &lt;em&gt;concurrent&lt;/em&gt; rather than being more precise by saying &lt;em&gt;concurrent and/or parallel&lt;/em&gt;. If this book were about concurrency and/or parallelism, we&amp;rsquo;d be more specific. For this chapter, please mentally substitute &lt;em&gt;concurrent and/or parallel&lt;/em&gt; whenever we use &lt;em&gt;concurrent&lt;/em&gt;.</source>
          <target state="translated">참고 : 간단하게하기 위해, 우리는 &lt;em&gt;동시 및 / 또는 병렬&lt;/em&gt; 을 말함으로써 더 많은 문제를 보다 정확하지 않고 &lt;em&gt;동시 적&lt;/em&gt; 으로 언급 할 것 입니다. 이 책이 동시성 및 / 또는 병렬 처리에 관한 것이면 더 구체적입니다. 이 장에서는, 우리가 &lt;em&gt;동시&lt;/em&gt; 를 사용할 때마다 &lt;em&gt;동시 및 / 또는 병렬을&lt;/em&gt; 정신적으로 대체하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2bcd0ee14b84ad9b9e572efa4f60a2cdc02453c" translate="yes" xml:space="preserve">
          <source>Note: Functions can implement all three of the &lt;code&gt;Fn&lt;/code&gt; traits too. If what we want to do doesn&amp;rsquo;t require capturing a value from the environment, we can use a function rather than a closure where we need something that implements an &lt;code&gt;Fn&lt;/code&gt; trait.</source>
          <target state="translated">참고 : 함수는 세 가지 &lt;code&gt;Fn&lt;/code&gt; 특성도 모두 구현할 수 있습니다. 우리가 원하는 것이 환경에서 가치를 포착 할 필요가 없다면, &lt;code&gt;Fn&lt;/code&gt; 특성 을 구현하는 무언가가 필요한 클로저 대신 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d3096da378822b99ae4c5c058d93a4ddaf9860b" translate="yes" xml:space="preserve">
          <source>Note: Git is a common version control system. You can change &lt;code&gt;cargo new&lt;/code&gt; to use a different version control system or no version control system by using the &lt;code&gt;--vcs&lt;/code&gt; flag. Run &lt;code&gt;cargo new --help&lt;/code&gt; to see the available options.</source>
          <target state="translated">참고 : Git은 일반적인 버전 관리 시스템입니다. &lt;code&gt;--vcs&lt;/code&gt; 플래그 를 사용하여 다른 버전 제어 시스템을 사용하거나 버전 제어 시스템을 사용하지 않도록 &lt;code&gt;cargo new&lt;/code&gt; 을 변경할 수 있습니다 . 사용 가능한 옵션을 확인하려면 &lt;code&gt;cargo new --help&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="0df14a643f96169ae07176fb1e5faadaf3d41970" translate="yes" xml:space="preserve">
          <source>Note: Historically, place expressions were called &lt;em&gt;lvalues&lt;/em&gt; and value expressions were called &lt;em&gt;rvalues&lt;/em&gt;.</source>
          <target state="translated">참고 : 역사적으로 장소 표현식은 &lt;em&gt;lvalues&lt;/em&gt; 이고 값 표현식은 &lt;em&gt;rvalues&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="95d17fa37d73d94b4ba6d7a45e2dff4566bcf95b" translate="yes" xml:space="preserve">
          <source>Note: If the &lt;code&gt;PeekMut&lt;/code&gt; value is leaked, the heap may be in an inconsistent state.</source>
          <target state="translated">참고 : &lt;code&gt;PeekMut&lt;/code&gt; 값이 누출되면 힙이 일치하지 않는 상태 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b84582c8d2e5caf9e744d83f9c53f4f316f3938a" translate="yes" xml:space="preserve">
          <source>Note: If you prefer not to use &lt;code&gt;rustup&lt;/code&gt; for some reason, please see &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;the Rust installation page&lt;/a&gt; for other options.</source>
          <target state="translated">참고 : 어떤 이유로 &lt;code&gt;rustup&lt;/code&gt; 사용하지 않으려면 &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;Rust 설치 페이지&lt;/a&gt; 에서 다른 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d58c0919378a7a1e84f8dd3400503ede165358e" translate="yes" xml:space="preserve">
          <source>Note: In C++, this pattern of deallocating resources at the end of an item&amp;rsquo;s lifetime is sometimes called &lt;em&gt;Resource Acquisition Is Initialization (RAII)&lt;/em&gt;. The &lt;code&gt;drop&lt;/code&gt; function in Rust will be familiar to you if you&amp;rsquo;ve used RAII patterns.</source>
          <target state="translated">참고 : C ++에서 항목 수명이 끝날 때 이러한 리소스 할당 해제 패턴을 &lt;em&gt;RAII (Resource Acquisition Is Initialization&lt;/em&gt; )라고도 &lt;em&gt;합니다&lt;/em&gt; . RAII 패턴을 사용한 경우 Rust 의 &lt;code&gt;drop&lt;/code&gt; 기능이 익숙합니다.</target>
        </trans-unit>
        <trans-unit id="54b56211cde322330df3d7c8028b1e66317b030b" translate="yes" xml:space="preserve">
          <source>Note: In general, you should not use &lt;code&gt;FusedIterator&lt;/code&gt; in generic bounds if you need a fused iterator. Instead, you should just call &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;Iterator::fuse()&lt;/code&gt;&lt;/a&gt; on the iterator. If the iterator is already fused, the additional &lt;a href=&quot;struct.fuse&quot;&gt;&lt;code&gt;Fuse&lt;/code&gt;&lt;/a&gt; wrapper will be a no-op with no performance penalty.</source>
          <target state="translated">참고 : 일반적으로 &lt;code&gt;FusedIterator&lt;/code&gt; 반복기가 필요한 경우 제네릭 경계에서 FusedIterator 를 사용하면 안됩니다 . 대신 &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt; &lt;code&gt;Iterator::fuse()&lt;/code&gt; &lt;/a&gt; 를 호출해야 합니다. 반복기가 이미 융합 된 경우 추가 &lt;a href=&quot;struct.fuse&quot;&gt; &lt;code&gt;Fuse&lt;/code&gt; &lt;/a&gt; 래퍼는 성능 저하없이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de232dc8ccf3ad3cf06506f2846d4c5ae30df0ce" translate="yes" xml:space="preserve">
          <source>Note: In general, you should not use &lt;code&gt;FusedIterator&lt;/code&gt; in generic bounds if you need a fused iterator. Instead, you should just call &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;Iterator::fuse&lt;/code&gt;&lt;/a&gt; on the iterator. If the iterator is already fused, the additional &lt;a href=&quot;struct.fuse&quot;&gt;&lt;code&gt;Fuse&lt;/code&gt;&lt;/a&gt; wrapper will be a no-op with no performance penalty.</source>
          <target state="translated">참고 : 일반적으로 융합 반복기가 필요한 경우 일반 범위에서 &lt;code&gt;FusedIterator&lt;/code&gt; 를 사용하지 않아야 합니다. 대신 &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt; &lt;code&gt;Iterator::fuse&lt;/code&gt; &lt;/a&gt; 를 호출해야 합니다. 반복자가 이미 융합 된 경우 추가 &lt;a href=&quot;struct.fuse&quot;&gt; &lt;code&gt;Fuse&lt;/code&gt; &lt;/a&gt; 래퍼는 성능 저하없이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30cece00231291046dd06875e4aca4bb16fbdc74" translate="yes" xml:space="preserve">
          <source>Note: In the edge case where you're seeking with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(n)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; minus the internal buffer length overflows an &lt;code&gt;i64&lt;/code&gt;, two seeks will be performed instead of one. If the second seek returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;, the underlying reader will be left at the same position it would have if you called &lt;code&gt;seek&lt;/code&gt; with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0)&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;SeekFrom::Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(n)&lt;/code&gt; 에서 &lt;code&gt;n&lt;/code&gt; 빼기 내부 버퍼 길이가 &lt;code&gt;i64&lt;/code&gt; 를 오버플로하는 가장자리 의 경우 하나가 아닌 두 번의 탐색이 수행됩니다. 두 번째 검색이 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 을 반환 하면 &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;SeekFrom::Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0)&lt;/code&gt; 을 사용 하여 &lt;code&gt;seek&lt;/code&gt; 를 호출 한 경우와 동일한 위치에 기본 판독기가 유지됩니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
