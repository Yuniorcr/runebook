<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="98d2de96a420de7658219d3f9bda5b24ca2443f7" translate="yes" xml:space="preserve">
          <source>Args::rfind</source>
          <target state="translated">Args::rfind</target>
        </trans-unit>
        <trans-unit id="3cc34e3e8eb1da327b82585d5a13fd8b2bb5890e" translate="yes" xml:space="preserve">
          <source>Args::rfold</source>
          <target state="translated">Args::rfold</target>
        </trans-unit>
        <trans-unit id="3a7a7236e75fdfae5572db48f2aad6e6378da2eb" translate="yes" xml:space="preserve">
          <source>Args::rposition</source>
          <target state="translated">Args::rposition</target>
        </trans-unit>
        <trans-unit id="9fc0f79d5cd6405747d8f5be32af5064749f81b9" translate="yes" xml:space="preserve">
          <source>Args::scan</source>
          <target state="translated">Args::scan</target>
        </trans-unit>
        <trans-unit id="12148001c865165a5de07ba3c727c97aab92c761" translate="yes" xml:space="preserve">
          <source>Args::size_hint</source>
          <target state="translated">Args::size_hint</target>
        </trans-unit>
        <trans-unit id="1189df09a529d4be32c97dfca9793d84611fd824" translate="yes" xml:space="preserve">
          <source>Args::skip</source>
          <target state="translated">Args::skip</target>
        </trans-unit>
        <trans-unit id="764acccc052619da2c47813fd259dab289d9bd67" translate="yes" xml:space="preserve">
          <source>Args::skip_while</source>
          <target state="translated">Args::skip_while</target>
        </trans-unit>
        <trans-unit id="904035ea6ead93ad6bd21ffe6010b797797cfccb" translate="yes" xml:space="preserve">
          <source>Args::step_by</source>
          <target state="translated">Args::step_by</target>
        </trans-unit>
        <trans-unit id="d5a7f219c1fc0a0f719ef62e5e91b056ae17a132" translate="yes" xml:space="preserve">
          <source>Args::sum</source>
          <target state="translated">Args::sum</target>
        </trans-unit>
        <trans-unit id="27af1223e3252d8316e5510ef65c11dd18e7e048" translate="yes" xml:space="preserve">
          <source>Args::take</source>
          <target state="translated">Args::take</target>
        </trans-unit>
        <trans-unit id="70510b85e050ccfd0ca156b8552398d830c8ca29" translate="yes" xml:space="preserve">
          <source>Args::take_while</source>
          <target state="translated">Args::take_while</target>
        </trans-unit>
        <trans-unit id="29671ebf88bfe467b330af20810dd95f14bee716" translate="yes" xml:space="preserve">
          <source>Args::try_fold</source>
          <target state="translated">Args::try_fold</target>
        </trans-unit>
        <trans-unit id="11314668861a5fe3812661a0778a42dd4d60ecc6" translate="yes" xml:space="preserve">
          <source>Args::try_for_each</source>
          <target state="translated">Args::try_for_each</target>
        </trans-unit>
        <trans-unit id="a3e7a43251306d98977b3648cb61a36b6b67f71f" translate="yes" xml:space="preserve">
          <source>Args::try_from</source>
          <target state="translated">Args::try_from</target>
        </trans-unit>
        <trans-unit id="ea7b4151424c750739941030cbfa813500f83861" translate="yes" xml:space="preserve">
          <source>Args::try_into</source>
          <target state="translated">Args::try_into</target>
        </trans-unit>
        <trans-unit id="a09bc59807578d3bfcb3f5e6f7f7b11ca71a5fda" translate="yes" xml:space="preserve">
          <source>Args::try_rfold</source>
          <target state="translated">Args::try_rfold</target>
        </trans-unit>
        <trans-unit id="ef5ea75da51804787206df18b378f5490fe6418b" translate="yes" xml:space="preserve">
          <source>Args::type_id</source>
          <target state="translated">Args::type_id</target>
        </trans-unit>
        <trans-unit id="3e828aa1b5449d683bef869c26ce0986ec45e670" translate="yes" xml:space="preserve">
          <source>Args::unzip</source>
          <target state="translated">Args::unzip</target>
        </trans-unit>
        <trans-unit id="468f2b4280fd073d79df60860923a06807813556" translate="yes" xml:space="preserve">
          <source>Args::zip</source>
          <target state="translated">Args::zip</target>
        </trans-unit>
        <trans-unit id="08a635e24e7197ec936245f74886d0fae256f6f3" translate="yes" xml:space="preserve">
          <source>ArgsOs</source>
          <target state="translated">ArgsOs</target>
        </trans-unit>
        <trans-unit id="1699d7288d57eee287607a5a8cf4daa06cbf36b5" translate="yes" xml:space="preserve">
          <source>ArgsOs::all</source>
          <target state="translated">ArgsOs::all</target>
        </trans-unit>
        <trans-unit id="1845d364695de9046a1a2e308d836950518c8379" translate="yes" xml:space="preserve">
          <source>ArgsOs::any</source>
          <target state="translated">ArgsOs::any</target>
        </trans-unit>
        <trans-unit id="b88db8b95877207b42c5e88cfc5b222b32d38f42" translate="yes" xml:space="preserve">
          <source>ArgsOs::borrow</source>
          <target state="translated">ArgsOs::borrow</target>
        </trans-unit>
        <trans-unit id="6883c744eb4014b5c2b448f2adc1b25a04e5fc9e" translate="yes" xml:space="preserve">
          <source>ArgsOs::borrow_mut</source>
          <target state="translated">ArgsOs::borrow_mut</target>
        </trans-unit>
        <trans-unit id="54a7160bba6f31fb20a2a3b6f79944613335629e" translate="yes" xml:space="preserve">
          <source>ArgsOs::by_ref</source>
          <target state="translated">ArgsOs::by_ref</target>
        </trans-unit>
        <trans-unit id="45e9d062b28c81d2586823abf5265cf79f0f53c3" translate="yes" xml:space="preserve">
          <source>ArgsOs::chain</source>
          <target state="translated">ArgsOs::chain</target>
        </trans-unit>
        <trans-unit id="06a86328c3295b9577a55fd6532e3d512a4376ad" translate="yes" xml:space="preserve">
          <source>ArgsOs::cloned</source>
          <target state="translated">ArgsOs::cloned</target>
        </trans-unit>
        <trans-unit id="aa33a26c7a85d39e633ece2b7ab215364fa8c21f" translate="yes" xml:space="preserve">
          <source>ArgsOs::cmp</source>
          <target state="translated">ArgsOs::cmp</target>
        </trans-unit>
        <trans-unit id="4444bf776c1fcbbef6e3005b548a29289b32ecc4" translate="yes" xml:space="preserve">
          <source>ArgsOs::collect</source>
          <target state="translated">ArgsOs::collect</target>
        </trans-unit>
        <trans-unit id="efa527796ad53e7b95c87dfbab81f527bd59777a" translate="yes" xml:space="preserve">
          <source>ArgsOs::copied</source>
          <target state="translated">ArgsOs::copied</target>
        </trans-unit>
        <trans-unit id="cf8617f607b90e848c8eda2dcecf733646bd740b" translate="yes" xml:space="preserve">
          <source>ArgsOs::count</source>
          <target state="translated">ArgsOs::count</target>
        </trans-unit>
        <trans-unit id="9774f0ee5373559d8ebaf6e270d32276c2460f0f" translate="yes" xml:space="preserve">
          <source>ArgsOs::cycle</source>
          <target state="translated">ArgsOs::cycle</target>
        </trans-unit>
        <trans-unit id="0c42cc7e9e0e5f5dcbc76f351e7fb1817634bb40" translate="yes" xml:space="preserve">
          <source>ArgsOs::enumerate</source>
          <target state="translated">ArgsOs::enumerate</target>
        </trans-unit>
        <trans-unit id="d5b0b5b450101b6daed6089615021285ab2aa9bc" translate="yes" xml:space="preserve">
          <source>ArgsOs::eq</source>
          <target state="translated">ArgsOs::eq</target>
        </trans-unit>
        <trans-unit id="22ebb6f40c3d512ac39613bf4969beaa463bb89c" translate="yes" xml:space="preserve">
          <source>ArgsOs::filter</source>
          <target state="translated">ArgsOs::filter</target>
        </trans-unit>
        <trans-unit id="ec9b19d64b96da14ed417d0d212d3d54ea4a4759" translate="yes" xml:space="preserve">
          <source>ArgsOs::filter_map</source>
          <target state="translated">ArgsOs::filter_map</target>
        </trans-unit>
        <trans-unit id="f90d91bcb86730d9c77f4746181813b55b242a5f" translate="yes" xml:space="preserve">
          <source>ArgsOs::find</source>
          <target state="translated">ArgsOs::find</target>
        </trans-unit>
        <trans-unit id="8c42c2da49296751bd09d90e62d79798dd8f5449" translate="yes" xml:space="preserve">
          <source>ArgsOs::find_map</source>
          <target state="translated">ArgsOs::find_map</target>
        </trans-unit>
        <trans-unit id="8ae8230900a56717520df737b9d2946aa58958f4" translate="yes" xml:space="preserve">
          <source>ArgsOs::flat_map</source>
          <target state="translated">ArgsOs::flat_map</target>
        </trans-unit>
        <trans-unit id="582b0a8882844e707b1b16686981fe8a3215c0f7" translate="yes" xml:space="preserve">
          <source>ArgsOs::flatten</source>
          <target state="translated">ArgsOs::flatten</target>
        </trans-unit>
        <trans-unit id="42a3165a3645e00a5c082e56522288eb3545955a" translate="yes" xml:space="preserve">
          <source>ArgsOs::fmt</source>
          <target state="translated">ArgsOs::fmt</target>
        </trans-unit>
        <trans-unit id="c973a490f8d75776d7cc21ebc26d8640412d8da5" translate="yes" xml:space="preserve">
          <source>ArgsOs::fold</source>
          <target state="translated">ArgsOs::fold</target>
        </trans-unit>
        <trans-unit id="521243a10a5ee6932b3c00a38bb64a1066346423" translate="yes" xml:space="preserve">
          <source>ArgsOs::for_each</source>
          <target state="translated">ArgsOs::for_each</target>
        </trans-unit>
        <trans-unit id="b3beb1c32ac134bd58a5525cb75b6818caadc2e7" translate="yes" xml:space="preserve">
          <source>ArgsOs::from</source>
          <target state="translated">ArgsOs::from</target>
        </trans-unit>
        <trans-unit id="0467b6e7a5907960746adb88f1797855273e5e38" translate="yes" xml:space="preserve">
          <source>ArgsOs::fuse</source>
          <target state="translated">ArgsOs::fuse</target>
        </trans-unit>
        <trans-unit id="8d918573a70aed631b8ef7e464f6978aeac45512" translate="yes" xml:space="preserve">
          <source>ArgsOs::ge</source>
          <target state="translated">ArgsOs::ge</target>
        </trans-unit>
        <trans-unit id="ed7bd18154ad5939e8306b095fe2d6551d9c5960" translate="yes" xml:space="preserve">
          <source>ArgsOs::gt</source>
          <target state="translated">ArgsOs::gt</target>
        </trans-unit>
        <trans-unit id="f6ab996f18c666c657723e3d6b826e9d4f34afa4" translate="yes" xml:space="preserve">
          <source>ArgsOs::inspect</source>
          <target state="translated">ArgsOs::inspect</target>
        </trans-unit>
        <trans-unit id="118a0e4c62985069de5d564f7e5aeaefdb4f3eee" translate="yes" xml:space="preserve">
          <source>ArgsOs::into</source>
          <target state="translated">ArgsOs::into</target>
        </trans-unit>
        <trans-unit id="6fe469f351f3d71c45f5b8b8a01a85ba417f2962" translate="yes" xml:space="preserve">
          <source>ArgsOs::into_iter</source>
          <target state="translated">ArgsOs::into_iter</target>
        </trans-unit>
        <trans-unit id="52e21117a73746309084ded1b85082f14e2f4f3c" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_empty</source>
          <target state="translated">ArgsOs::is_empty</target>
        </trans-unit>
        <trans-unit id="bc22f51d728c32072e58dab02dc3f74a273221da" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted</source>
          <target state="translated">ArgsOs::is_sorted</target>
        </trans-unit>
        <trans-unit id="6ce480c601285e3d630fdd46e557dfb3c792fc47" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted_by</source>
          <target state="translated">ArgsOs::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="1bd6484be8e79119af4f357c6727e9cce127bfb7" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted_by_key</source>
          <target state="translated">ArgsOs::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="2960d55410634dcaa01ebfd4efb87d3210b4b30b" translate="yes" xml:space="preserve">
          <source>ArgsOs::last</source>
          <target state="translated">ArgsOs::last</target>
        </trans-unit>
        <trans-unit id="49cd1005a59ab868a13fc3b698fa037af9e3cc25" translate="yes" xml:space="preserve">
          <source>ArgsOs::le</source>
          <target state="translated">ArgsOs::le</target>
        </trans-unit>
        <trans-unit id="9662bed516b84aec77303964e4aba365d517a6ce" translate="yes" xml:space="preserve">
          <source>ArgsOs::len</source>
          <target state="translated">ArgsOs::len</target>
        </trans-unit>
        <trans-unit id="a4fd3a509313cc726b4eb5e364e66dd0311cbccc" translate="yes" xml:space="preserve">
          <source>ArgsOs::lt</source>
          <target state="translated">ArgsOs::lt</target>
        </trans-unit>
        <trans-unit id="b4ee6f488be886ab0828730edfa187e1158ffbf4" translate="yes" xml:space="preserve">
          <source>ArgsOs::map</source>
          <target state="translated">ArgsOs::map</target>
        </trans-unit>
        <trans-unit id="ae8b8dee55299bdeb6e240152d7d260302e580f0" translate="yes" xml:space="preserve">
          <source>ArgsOs::max</source>
          <target state="translated">ArgsOs::max</target>
        </trans-unit>
        <trans-unit id="f393dc70d5755703ad87bcd703e01acde42fd52e" translate="yes" xml:space="preserve">
          <source>ArgsOs::max_by</source>
          <target state="translated">ArgsOs::max_by</target>
        </trans-unit>
        <trans-unit id="c3d12b23ad084b94bc1bb5877f3a0e669b6dcbe5" translate="yes" xml:space="preserve">
          <source>ArgsOs::max_by_key</source>
          <target state="translated">ArgsOs::max_by_key</target>
        </trans-unit>
        <trans-unit id="1877909fb92070e732d578d5a61015d6567d1c05" translate="yes" xml:space="preserve">
          <source>ArgsOs::min</source>
          <target state="translated">ArgsOs::min</target>
        </trans-unit>
        <trans-unit id="1b9560ee3684ef678a7f2060396e14192ebd977a" translate="yes" xml:space="preserve">
          <source>ArgsOs::min_by</source>
          <target state="translated">ArgsOs::min_by</target>
        </trans-unit>
        <trans-unit id="ce07e6453a52864ecbf5f176d284c9622c84c927" translate="yes" xml:space="preserve">
          <source>ArgsOs::min_by_key</source>
          <target state="translated">ArgsOs::min_by_key</target>
        </trans-unit>
        <trans-unit id="77abc8099c1b361ea642538729c1cfa9c4ad2af8" translate="yes" xml:space="preserve">
          <source>ArgsOs::ne</source>
          <target state="translated">ArgsOs::ne</target>
        </trans-unit>
        <trans-unit id="94df206ce16974feea2fee745eeb9bededb98233" translate="yes" xml:space="preserve">
          <source>ArgsOs::next</source>
          <target state="translated">ArgsOs::next</target>
        </trans-unit>
        <trans-unit id="0b4bd6a54c1bdb1cb1c37909c4bbdf8ee8eedba4" translate="yes" xml:space="preserve">
          <source>ArgsOs::next_back</source>
          <target state="translated">ArgsOs::next_back</target>
        </trans-unit>
        <trans-unit id="32001a37fe7fa6c38a9dab6e3ccac83215a6af0b" translate="yes" xml:space="preserve">
          <source>ArgsOs::nth</source>
          <target state="translated">ArgsOs::nth</target>
        </trans-unit>
        <trans-unit id="eed0fe5e0346646ed8f493e45f87707e6ef665d0" translate="yes" xml:space="preserve">
          <source>ArgsOs::nth_back</source>
          <target state="translated">ArgsOs::nth_back</target>
        </trans-unit>
        <trans-unit id="76d2262b3586a0b114f133d396c15e36cdbd64ee" translate="yes" xml:space="preserve">
          <source>ArgsOs::partial_cmp</source>
          <target state="translated">ArgsOs::partial_cmp</target>
        </trans-unit>
        <trans-unit id="c88ee3f44d1aaf87a7e7075664272abea7e57c22" translate="yes" xml:space="preserve">
          <source>ArgsOs::partition</source>
          <target state="translated">ArgsOs::partition</target>
        </trans-unit>
        <trans-unit id="b772163bfba047ed1ad9679588037cc0b2a982a9" translate="yes" xml:space="preserve">
          <source>ArgsOs::peekable</source>
          <target state="translated">ArgsOs::peekable</target>
        </trans-unit>
        <trans-unit id="28f42c15452e45ff29cd38077309d81cd1bf23ef" translate="yes" xml:space="preserve">
          <source>ArgsOs::position</source>
          <target state="translated">ArgsOs::position</target>
        </trans-unit>
        <trans-unit id="9c54799fe9d66e9fe809d53c0ad35f91d0345b2d" translate="yes" xml:space="preserve">
          <source>ArgsOs::product</source>
          <target state="translated">ArgsOs::product</target>
        </trans-unit>
        <trans-unit id="24d0c67c7635532e04027af92577d329d52e0d8d" translate="yes" xml:space="preserve">
          <source>ArgsOs::rev</source>
          <target state="translated">ArgsOs::rev</target>
        </trans-unit>
        <trans-unit id="9a893fd65a1fd7e4f90c4c16dad18ae09e1e6440" translate="yes" xml:space="preserve">
          <source>ArgsOs::rfind</source>
          <target state="translated">ArgsOs::rfind</target>
        </trans-unit>
        <trans-unit id="2473c6d05109d83b7921dc7c8d9e3fd3e1540366" translate="yes" xml:space="preserve">
          <source>ArgsOs::rfold</source>
          <target state="translated">ArgsOs::rfold</target>
        </trans-unit>
        <trans-unit id="61e2d2493b8b480b1c184877bc7c4508f85f3e68" translate="yes" xml:space="preserve">
          <source>ArgsOs::rposition</source>
          <target state="translated">ArgsOs::rposition</target>
        </trans-unit>
        <trans-unit id="f7c9d7d4183c0e1185d8f756359b7aa52e99dec6" translate="yes" xml:space="preserve">
          <source>ArgsOs::scan</source>
          <target state="translated">ArgsOs::scan</target>
        </trans-unit>
        <trans-unit id="be9f72e6896d64043f92118bf0351dd06875451e" translate="yes" xml:space="preserve">
          <source>ArgsOs::size_hint</source>
          <target state="translated">ArgsOs::size_hint</target>
        </trans-unit>
        <trans-unit id="dfcbf514097e12c73f97a48d644499d52e01f449" translate="yes" xml:space="preserve">
          <source>ArgsOs::skip</source>
          <target state="translated">ArgsOs::skip</target>
        </trans-unit>
        <trans-unit id="b5cea38564a840936b5adf617a54cb9e1705e9a4" translate="yes" xml:space="preserve">
          <source>ArgsOs::skip_while</source>
          <target state="translated">ArgsOs::skip_while</target>
        </trans-unit>
        <trans-unit id="bd31eff15f1513280f3660b278f44b8403fe5bb7" translate="yes" xml:space="preserve">
          <source>ArgsOs::step_by</source>
          <target state="translated">ArgsOs::step_by</target>
        </trans-unit>
        <trans-unit id="b896b50f4e9946df9f811558add55e6c7f4d9c0e" translate="yes" xml:space="preserve">
          <source>ArgsOs::sum</source>
          <target state="translated">ArgsOs::sum</target>
        </trans-unit>
        <trans-unit id="55f7ee9ef7a277d1da50d3847c5267d10c02f3d6" translate="yes" xml:space="preserve">
          <source>ArgsOs::take</source>
          <target state="translated">ArgsOs::take</target>
        </trans-unit>
        <trans-unit id="67ae1d83993d54c201cebc7e961a4745875403a9" translate="yes" xml:space="preserve">
          <source>ArgsOs::take_while</source>
          <target state="translated">ArgsOs::take_while</target>
        </trans-unit>
        <trans-unit id="6feaa7bb16a2f86b2de35c4152c898840e5c73a7" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_fold</source>
          <target state="translated">ArgsOs::try_fold</target>
        </trans-unit>
        <trans-unit id="4de4927e12902d929342841a0f0a05adc02a2b88" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_for_each</source>
          <target state="translated">ArgsOs::try_for_each</target>
        </trans-unit>
        <trans-unit id="ef2e8777c2c6780af369e18d8923c4a5b07b73cc" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_from</source>
          <target state="translated">ArgsOs::try_from</target>
        </trans-unit>
        <trans-unit id="dde21f1986a82cfe6d32ebda71aaf8cffb865725" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_into</source>
          <target state="translated">ArgsOs::try_into</target>
        </trans-unit>
        <trans-unit id="752061f583e2a023f82e25f293fbc12638874e24" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_rfold</source>
          <target state="translated">ArgsOs::try_rfold</target>
        </trans-unit>
        <trans-unit id="9cea18d9f52cf4e66c35caae6f3a3d7426f8ebf1" translate="yes" xml:space="preserve">
          <source>ArgsOs::type_id</source>
          <target state="translated">ArgsOs::type_id</target>
        </trans-unit>
        <trans-unit id="dcc7a51ed1d3dac6d37f7b6f7415fe425b54aac1" translate="yes" xml:space="preserve">
          <source>ArgsOs::unzip</source>
          <target state="translated">ArgsOs::unzip</target>
        </trans-unit>
        <trans-unit id="0477d6e4f174e07114d3143d029569031152c407" translate="yes" xml:space="preserve">
          <source>ArgsOs::zip</source>
          <target state="translated">ArgsOs::zip</target>
        </trans-unit>
        <trans-unit id="bd7faaad666e01c1bc85c0559542193db97f87bb" translate="yes" xml:space="preserve">
          <source>Argument and element separator</source>
          <target state="translated">인수와 요소 구분자</target>
        </trans-unit>
        <trans-unit id="0e653d9296c0f3183cfcfa59576a82649ae7862d" translate="yes" xml:space="preserve">
          <source>Argument types</source>
          <target state="translated">인수 유형</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="a3115a849e9a8fd08f66c020b31248aefac3bb62" translate="yes" xml:space="preserve">
          <source>Arguments for function calls</source>
          <target state="translated">함수 호출에 대한 인수</target>
        </trans-unit>
        <trans-unit id="599f9cef30e51c86c0307365f585d93f4615d4d0" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;map_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.map_or_else&quot;&gt;&lt;code&gt;map_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;map_or&lt;/code&gt; 에 전달 된 인수 는 열심히 평가됩니다. 함수 호출의 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;enum.option#method.map_or_else&quot;&gt; &lt;code&gt;map_or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f0b13e1e9de1f734ef5d809e601926031419d1d8" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;map_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.result#method.map_or_else&quot;&gt;&lt;code&gt;map_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;map_or&lt;/code&gt; 에 전달 된 인수 는 열심히 평가됩니다. 함수 호출의 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;enum.result#method.map_or_else&quot;&gt; &lt;code&gt;map_or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="60b48e4141151169e113485ecab80a4bb3c30bdc" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;ok_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.ok_or_else&quot;&gt;&lt;code&gt;ok_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;ok_or&lt;/code&gt; 에 전달 된 인수 는 간절히 평가됩니다. 함수 호출 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;#method.ok_or_else&quot;&gt; &lt;code&gt;ok_or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c72e63e8acf76e2210299bb8523a4d987e02e598" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;ok_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.ok_or_else&quot;&gt;&lt;code&gt;ok_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;ok_or&lt;/code&gt; 에 전달 된 인수 는 열심히 평가됩니다. 함수 호출의 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;enum.option#method.ok_or_else&quot;&gt; &lt;code&gt;ok_or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b34ba4a25e5cb9253c52e9c96f12b4a3b5b442c1" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.or_else&quot;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">인수 &lt;code&gt;or&lt;/code&gt; 전달 된 인수 는 간절히 평가됩니다. 함수 호출 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;#method.or_else&quot;&gt; &lt;code&gt;or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e8e3ad3f9d440f41a4bced3ec981aa2d05bd534c" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.or_else&quot;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">인수가 전달 &lt;code&gt;or&lt;/code&gt; 열심히 평가됩니다. 함수 호출의 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;enum.option#method.or_else&quot;&gt; &lt;code&gt;or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3fb2e5d47e33897712d4dff15280a3a0c997b492" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.result#method.or_else&quot;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">인수가 전달 &lt;code&gt;or&lt;/code&gt; 열심히 평가됩니다. 함수 호출의 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;enum.result#method.or_else&quot;&gt; &lt;code&gt;or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="81e7e0f40306bc29fb2793ce221652d077995d0b" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;unwrap_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;unwrap_or&lt;/code&gt; 에 전달 된 인수 는 열성적으로 평가됩니다. 함수 호출 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="15ac6e3ce55f8f212059dc3a36cc981d9be8aca1" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;unwrap_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;unwrap_or&lt;/code&gt; 에 전달 된 인수 는 열심히 평가됩니다. 함수 호출의 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;enum.option#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="935c37b281819663d093edd0e6a0df21fc148074" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;unwrap_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.result#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;unwrap_or&lt;/code&gt; 에 전달 된 인수 는 열심히 평가됩니다. 함수 호출의 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;enum.result#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ca682bb604cd951faf7e687e9dc577ccfb4ccbcc" translate="yes" xml:space="preserve">
          <source>Arguments::borrow</source>
          <target state="translated">Arguments::borrow</target>
        </trans-unit>
        <trans-unit id="02b0d59380fa1adbbfa0a4e488839d014c6a84b9" translate="yes" xml:space="preserve">
          <source>Arguments::borrow_mut</source>
          <target state="translated">Arguments::borrow_mut</target>
        </trans-unit>
        <trans-unit id="beee63977406683694c63c877a281368e8498185" translate="yes" xml:space="preserve">
          <source>Arguments::clone</source>
          <target state="translated">Arguments::clone</target>
        </trans-unit>
        <trans-unit id="9b4336ed72fcc8790d465ff622f1ee33ef64dd5f" translate="yes" xml:space="preserve">
          <source>Arguments::clone_from</source>
          <target state="translated">Arguments::clone_from</target>
        </trans-unit>
        <trans-unit id="9f534ce31b28796358e33f058c8f30771441c413" translate="yes" xml:space="preserve">
          <source>Arguments::clone_into</source>
          <target state="translated">Arguments::clone_into</target>
        </trans-unit>
        <trans-unit id="e2264984672013569ff3cb5667d1fb059d3a9aff" translate="yes" xml:space="preserve">
          <source>Arguments::fmt</source>
          <target state="translated">Arguments::fmt</target>
        </trans-unit>
        <trans-unit id="e6967e42010df585387f1e1ee0a1ddd2861644a6" translate="yes" xml:space="preserve">
          <source>Arguments::from</source>
          <target state="translated">Arguments::from</target>
        </trans-unit>
        <trans-unit id="f7110cbfaa9d19f7a1a5d2f96c337419907bb156" translate="yes" xml:space="preserve">
          <source>Arguments::into</source>
          <target state="translated">Arguments::into</target>
        </trans-unit>
        <trans-unit id="f71fad745c8ecba4adbbf940ce0a934c1bbb9409" translate="yes" xml:space="preserve">
          <source>Arguments::to_owned</source>
          <target state="translated">Arguments::to_owned</target>
        </trans-unit>
        <trans-unit id="2f1106daf75575ebf9ff5096d88d4bd32bee8e3a" translate="yes" xml:space="preserve">
          <source>Arguments::to_string</source>
          <target state="translated">Arguments::to_string</target>
        </trans-unit>
        <trans-unit id="44514fad8f521c67acba588fe00d7592016a908f" translate="yes" xml:space="preserve">
          <source>Arguments::try_from</source>
          <target state="translated">Arguments::try_from</target>
        </trans-unit>
        <trans-unit id="8bb902c723ba932ded5aa3da8d68330e0bd8dfdd" translate="yes" xml:space="preserve">
          <source>Arguments::try_into</source>
          <target state="translated">Arguments::try_into</target>
        </trans-unit>
        <trans-unit id="93c384146f511c59251c10079f21618fcc345340" translate="yes" xml:space="preserve">
          <source>Arguments::type_id</source>
          <target state="translated">Arguments::type_id</target>
        </trans-unit>
        <trans-unit id="52ed5399cec328eed1c4d10b234f6d54945d8379" translate="yes" xml:space="preserve">
          <source>Arithmetic addition</source>
          <target state="translated">산술 덧셈</target>
        </trans-unit>
        <trans-unit id="b6a2b173c28c2d32e0f07c5865706f1a0af1dc82" translate="yes" xml:space="preserve">
          <source>Arithmetic addition and assignment</source>
          <target state="translated">산술 덧셈과 대입</target>
        </trans-unit>
        <trans-unit id="481206dd7e4055d67971a43266f17dd6c8acf74d" translate="yes" xml:space="preserve">
          <source>Arithmetic and Logical Binary Operators</source>
          <target state="translated">산술 및 논리 이진 연산자</target>
        </trans-unit>
        <trans-unit id="ba8c163933eb964b78854dfa7b1e1313a4ece109" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operators on integers</source>
          <target state="translated">정수의 산술 및 비교 연산자</target>
        </trans-unit>
        <trans-unit id="3a2ccea0b8aef06fcf5a90ab7c705782be897b40" translate="yes" xml:space="preserve">
          <source>Arithmetic division</source>
          <target state="translated">산술 부서</target>
        </trans-unit>
        <trans-unit id="dfc8f592565726eb9a5251995ebe9c35af2683f2" translate="yes" xml:space="preserve">
          <source>Arithmetic division and assignment</source>
          <target state="translated">산술 나누기와 할당</target>
        </trans-unit>
        <trans-unit id="5e0f6d1b7afc18895e08ec06673e25445eca9bd9" translate="yes" xml:space="preserve">
          <source>Arithmetic multiplication</source>
          <target state="translated">산술 곱셈</target>
        </trans-unit>
        <trans-unit id="aed641007b737ba787b84c11db1a76f81a7265ec" translate="yes" xml:space="preserve">
          <source>Arithmetic multiplication and assignment</source>
          <target state="translated">산술 곱셈과 대입</target>
        </trans-unit>
        <trans-unit id="9501694b83625ba1c4c32e0300c7e3ef0ea5895a" translate="yes" xml:space="preserve">
          <source>Arithmetic negation</source>
          <target state="translated">산술 부정</target>
        </trans-unit>
        <trans-unit id="4b7e345ffd8cb02b4c25248f3c2916dd526e2269" translate="yes" xml:space="preserve">
          <source>Arithmetic remainder</source>
          <target state="translated">산술 나머지</target>
        </trans-unit>
        <trans-unit id="4af14fe332c2fec7e550537a659d27f7672cf52b" translate="yes" xml:space="preserve">
          <source>Arithmetic remainder and assignment</source>
          <target state="translated">산술 나머지 및 할당</target>
        </trans-unit>
        <trans-unit id="54604a8945847efcfbb8925458787851115f9296" translate="yes" xml:space="preserve">
          <source>Arithmetic subtraction</source>
          <target state="translated">산술 빼기</target>
        </trans-unit>
        <trans-unit id="40c2d180ceb1daebfda27a7dc052bf6e18437123" translate="yes" xml:space="preserve">
          <source>Arithmetic subtraction and assignment</source>
          <target state="translated">산술 빼기와 대입</target>
        </trans-unit>
        <trans-unit id="9d9b31e17e60151ad825cdde7693ca0fcca238c9" translate="yes" xml:space="preserve">
          <source>Arity</source>
          <target state="translated">Arity</target>
        </trans-unit>
        <trans-unit id="1fd516c87a7c389dccca9649a7b656d2f047d85d" translate="yes" xml:space="preserve">
          <source>Arity refers to the number of arguments a function or operator takes. For some examples, &lt;code&gt;f(2, 3)&lt;/code&gt; and &lt;code&gt;g(4, 6)&lt;/code&gt; have arity 2, while &lt;code&gt;h(8, 2, 6)&lt;/code&gt; has arity 3. The &lt;code&gt;!&lt;/code&gt; operator has arity 1.</source>
          <target state="translated">Arity는 함수 또는 연산자가 취하는 인수 수를 나타냅니다. 일부 예에서, &lt;code&gt;f(2, 3)&lt;/code&gt; 및 &lt;code&gt;g(4, 6)&lt;/code&gt; 은 arity 2를 갖는 반면 &lt;code&gt;h(8, 2, 6)&lt;/code&gt; 은 arity 3을 갖습니다. &lt;code&gt;!&lt;/code&gt; 연산자는 arity 1이 있습니다</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="e88a1d916bd09fa0781281dd0639410541b1c200" translate="yes" xml:space="preserve">
          <source>Array Layout</source>
          <target state="translated">배열 레이아웃</target>
        </trans-unit>
        <trans-unit id="811e7deb41b753134a124c771bc129d2aad4f69f" translate="yes" xml:space="preserve">
          <source>Array and array index expressions</source>
          <target state="translated">배열 및 배열 인덱스 표현식</target>
        </trans-unit>
        <trans-unit id="0844515b5a634fa1753332ae502ec5bc059c9bf4" translate="yes" xml:space="preserve">
          <source>Array and slice indexing expressions</source>
          <target state="translated">배열 및 슬라이스 인덱싱 표현식</target>
        </trans-unit>
        <trans-unit id="1c901b7185d5b71317418dac8afa7a9edb10a639" translate="yes" xml:space="preserve">
          <source>Array expression attributes</source>
          <target state="translated">배열 표현식 속성</target>
        </trans-unit>
        <trans-unit id="ff659441b84e2964045ca09a8c18a08d44b84a61" translate="yes" xml:space="preserve">
          <source>Array expressions</source>
          <target state="translated">배열 표현식</target>
        </trans-unit>
        <trans-unit id="b4a857fc21bf592938e9dd2ec1d467878b6cf83e" translate="yes" xml:space="preserve">
          <source>Array literal</source>
          <target state="translated">배열 리터럴</target>
        </trans-unit>
        <trans-unit id="4935b8502c9911035c4038af29553fcfde8b5706" translate="yes" xml:space="preserve">
          <source>Array literal containing &lt;code&gt;len&lt;/code&gt; copies of &lt;code&gt;expr&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 의 &lt;code&gt;len&lt;/code&gt; 사본을 포함하는 배열 리터럴</target>
        </trans-unit>
        <trans-unit id="235f924c7c3818aed78845bd2de8791d4d3ba101" translate="yes" xml:space="preserve">
          <source>Array literals with repeating syntax, where the array has type &lt;code&gt;[U; n]&lt;/code&gt;. The repeated sub-expression is a coercion site for coercion to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">반복 구문이있는 배열 리터럴. 여기서 배열의 유형은 &lt;code&gt;[U; n]&lt;/code&gt; . 반복 된 하위-발현은 유형 &lt;code&gt;U&lt;/code&gt; 에 대한 강제에 대한 강제 사이트 이다.</target>
        </trans-unit>
        <trans-unit id="41d08ca772cf664e0e365d09949f5835931ea185" translate="yes" xml:space="preserve">
          <source>Array literals, where the array has type &lt;code&gt;[U; n]&lt;/code&gt;. Each sub-expression in the array literal is a coercion site for coercion to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">배열이 &lt;code&gt;[U; n]&lt;/code&gt; . 배열 리터럴의 각 하위 표현식은 &lt;code&gt;U&lt;/code&gt; 형을 강제로 변환하는 강제 사이트입니다 .</target>
        </trans-unit>
        <trans-unit id="5de52c0cb2ce4e0eb71f0c098408cbd13a499a61" translate="yes" xml:space="preserve">
          <source>Array repeat length expressions</source>
          <target state="translated">배열 반복 길이 표현식</target>
        </trans-unit>
        <trans-unit id="ea9dbd560327931c17a47c31880f0fcea2d052f4" translate="yes" xml:space="preserve">
          <source>Array to pointer cast</source>
          <target state="translated">포인터 캐스트에 대한 배열</target>
        </trans-unit>
        <trans-unit id="45de270a590c4d4b0320d8105310eb72bc4364df" translate="yes" xml:space="preserve">
          <source>Array type containing &lt;code&gt;len&lt;/code&gt; instances of &lt;code&gt;type&lt;/code&gt;</source>
          <target state="translated">유형의 &lt;code&gt;len&lt;/code&gt; 인스턴스를 포함하는 배열 &lt;code&gt;type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51a7c3ed1d5f017cc725067fca3064cb604b7344" translate="yes" xml:space="preserve">
          <source>Array type length expressions</source>
          <target state="translated">배열 유형 길이 표현식</target>
        </trans-unit>
        <trans-unit id="ee988191e1f320445ced1a772858430505143153" translate="yes" xml:space="preserve">
          <source>Array types</source>
          <target state="translated">배열 유형</target>
        </trans-unit>
        <trans-unit id="51fa61d38d898a29b7f71e858ac412133bb4aa78" translate="yes" xml:space="preserve">
          <source>Array types, for all sizes, if the item type also implements &lt;code&gt;Clone&lt;/code&gt; (e.g., &lt;code&gt;[i32; 123456]&lt;/code&gt;)</source>
          <target state="translated">항목 유형이 &lt;code&gt;Clone&lt;/code&gt; 를 구현하는 경우 모든 크기에 대한 배열 유형 (예 : &lt;code&gt;[i32; 123456]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c11c5b2f8cc2056c662bde9d8e7265077775fda2" translate="yes" xml:space="preserve">
          <source>Array types, for all sizes, if the item type also implements &lt;code&gt;Copy&lt;/code&gt; (e.g., &lt;code&gt;[i32; 123456]&lt;/code&gt;)</source>
          <target state="translated">항목 유형이 &lt;code&gt;Copy&lt;/code&gt; 를 구현하는 경우 모든 크기에 대한 배열 유형 (예 : &lt;code&gt;[i32; 123456]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="95c5c33f29f0547a430b0665b6ac583648900bd6" translate="yes" xml:space="preserve">
          <source>ArrayChunks</source>
          <target state="translated">ArrayChunks</target>
        </trans-unit>
        <trans-unit id="5d42cc662a1c24ca3713c4fbd65f30d1d4685e7c" translate="yes" xml:space="preserve">
          <source>ArrayChunksMut</source>
          <target state="translated">ArrayChunksMut</target>
        </trans-unit>
        <trans-unit id="f83b691df0418afaddc970026f4eccfa1541c51f" translate="yes" xml:space="preserve">
          <source>ArrayWindows</source>
          <target state="translated">ArrayWindows</target>
        </trans-unit>
        <trans-unit id="aa557f1be66399eaf12f2be07d75660861cacf56" translate="yes" xml:space="preserve">
          <source>Arrays are laid out so that the &lt;code&gt;nth&lt;/code&gt; element of the array is offset from the start of the array by &lt;code&gt;n * the size of the type&lt;/code&gt; bytes. An array of &lt;code&gt;[T; n]&lt;/code&gt; has a size of &lt;code&gt;size_of::&amp;lt;T&amp;gt;() * n&lt;/code&gt; and the same alignment of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">배열의 &lt;code&gt;nth&lt;/code&gt; 요소가 배열의 시작에서 &lt;code&gt;n * the size of the type&lt;/code&gt; 바이트 의 크기 만큼 오프셋 되도록 배열이 배치됩니다 . 배열 &lt;code&gt;[T; n]&lt;/code&gt; 의 크기를 갖는 &lt;code&gt;size_of::&amp;lt;T&amp;gt;() * n&lt;/code&gt; 과 동일한 배향 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02fe2a892020ef77103f56bebff06ee9353b3385" translate="yes" xml:space="preserve">
          <source>Arrays are useful when you want your data allocated on the stack rather than the heap (we will discuss the stack and the heap more in Chapter 4) or when you want to ensure you always have a fixed number of elements. An array isn&amp;rsquo;t as flexible as the vector type, though. A vector is a similar collection type provided by the standard library that &lt;em&gt;is&lt;/em&gt; allowed to grow or shrink in size. If you&amp;rsquo;re unsure whether to use an array or a vector, you should probably use a vector. Chapter 8 discusses vectors in more detail.</source>
          <target state="translated">배열은 힙이 아닌 스택에 데이터를 할당하려는 경우 (4 장에서 스택 및 힙에 대해 자세히 설명 할 것임) 또는 항상 고정 된 수의 요소가 있는지 확인하려는 경우에 유용합니다. 그러나 배열은 벡터 유형만큼 유연하지 않습니다. 벡터는 표준 라이브러리에서 제공하는 유사한 수집 유형 &lt;em&gt;입니다&lt;/em&gt; 성장 또는 크기 축소 할 수있었습니다. 배열을 사용할지 벡터를 사용할지 확실하지 않으면 벡터를 사용해야합니다. 8 장에서는 벡터에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3b3785f54b6fb9b400ea9ab57c87c42e59186241" translate="yes" xml:space="preserve">
          <source>Arrays coerce to &lt;a href=&quot;primitive.slice&quot;&gt;slices (&lt;code&gt;[T]&lt;/code&gt;)&lt;/a&gt;, so a slice method may be called on an array. Indeed, this provides most of the API for working with arrays. Slices have a dynamic size and do not coerce to arrays.</source>
          <target state="translated">배열은 &lt;a href=&quot;primitive.slice&quot;&gt;슬라이스 ( &lt;code&gt;[T]&lt;/code&gt; )로&lt;/a&gt; 강제 변환 되므로 슬라이스에서 슬라이스 메소드를 호출 할 수 있습니다. 실제로 이것은 배열 작업을위한 대부분의 API를 제공합니다. 슬라이스는 동적 크기를 가지며 배열로 강제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5463b6c378c5a1ce536679177693788d8a488ef" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;em&gt;any&lt;/em&gt; size are &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; if the element type is &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; if the element type is &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;. This works because &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; traits are specially known to the compiler.</source>
          <target state="translated">의 배열 &lt;em&gt;어떤&lt;/em&gt; 크기는 &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 요소의 형태 인 경우 &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 요소의 형태 인 경우 &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; . 이것은 &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 특성이 컴파일러에 특별히 알려져 있기 때문에 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="44fcd591dcf7f314f13f655158af04cf8a3c0c81" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;em&gt;any&lt;/em&gt; size implement the following traits if the element type allows it:</source>
          <target state="translated">&lt;em&gt;모든&lt;/em&gt; 크기의 배열은 요소 유형이 허용하는 경우 다음 특성을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="6563ac44bbb67213c7a3f6f4eeedf9dc732e3220" translate="yes" xml:space="preserve">
          <source>Arrays of sizes from 0 to 32 (inclusive) implement &lt;a href=&quot;default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait if the element type allows it. As a stopgap, trait implementations are statically generated up to size 32.</source>
          <target state="translated">0에서 32 (포함) 사이의 크기 배열은 요소 유형이 허용하는 경우 &lt;a href=&quot;default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; 특성을 구현 합니다. 임시 방편으로 트레이 트 구현은 최대 크기 32까지 정적으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e22eb391f81362ae0eac8c4cd60b81a4562599d8" translate="yes" xml:space="preserve">
          <source>Arrays of sizes from 0 to 32 (inclusive) implement the following traits if the element type allows it:</source>
          <target state="translated">0에서 32까지의 크기의 배열 (포함)은 요소 유형이 허용하는 경우 다음 특성을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="3520f70ba3a61ccc1286dbddd33fb0815248aa0b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;if&lt;/code&gt; expressions have their pattern matching variant in &lt;code&gt;if let&lt;/code&gt;, so too do &lt;code&gt;while&lt;/code&gt; expressions with &lt;code&gt;while let&lt;/code&gt;. The &lt;code&gt;while let&lt;/code&gt; expression matches the pattern against the expression, then runs the loop body if pattern matching succeeds, or exits the loop otherwise. We can use &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; in &lt;code&gt;while let&lt;/code&gt; expressions just like in &lt;code&gt;while&lt;/code&gt;.</source>
          <target state="translated">으로 &lt;code&gt;if&lt;/code&gt; 표현에 자신의 패턴 매칭 변형이 &lt;code&gt;if let&lt;/code&gt; , 이렇게도 할 &lt;code&gt;while&lt;/code&gt; 으로 표현 &lt;code&gt;while let&lt;/code&gt; . &lt;code&gt;while let&lt;/code&gt; 표현은 다음 식에 대한 패턴과 일치하는 패턴 매칭이 성공하면 루프 본문을 실행하거나 루프를 종료합니다. &lt;code&gt;break&lt;/code&gt; 와 &lt;code&gt;continue&lt;/code&gt; in &lt;code&gt;while let&lt;/code&gt; 표현식을 &lt;code&gt;while&lt;/code&gt; 처럼 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2be2422a9ce4d7fe654319fa259c94897e3e7b46" translate="yes" xml:space="preserve">
          <source>As IANA assigns new addresses, this method will be updated. This may result in non-reserved addresses being treated as reserved in code that relies on an outdated version of this method.</source>
          <target state="translated">IANA가 새 주소를 할당하면이 방법이 업데이트됩니다. 이로 인해 예약되지 않은 주소가이 방법의 오래된 버전에 의존하는 코드에서 예약 된 것으로 취급 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="204e461bb880d4d3e097aeac5f123e90d90ae7f0" translate="yes" xml:space="preserve">
          <source>As Rust automatically calls the destructors of all contained fields, you don't have to implement &lt;code&gt;Drop&lt;/code&gt; in most cases. But there are some cases where it is useful, for example for types which directly manage a resource. That resource may be memory, it may be a file descriptor, it may be a network socket. Once a value of that type is no longer going to be used, it should &quot;clean up&quot; its resource by freeing the memory or closing the file or socket. This is the job of a destructor, and therefore the job of &lt;code&gt;Drop::drop&lt;/code&gt;.</source>
          <target state="translated">Rust는 포함 된 모든 필드의 소멸자를 자동으로 호출하므로 대부분의 경우 &lt;code&gt;Drop&lt;/code&gt; 을 구현할 필요가 없습니다 . 그러나 리소스를 직접 관리하는 유형과 같이 유용한 경우가 있습니다. 그 리소스는 메모리, 파일 디스크립터, 네트워크 소켓 일 수 있습니다. 해당 유형의 값이 더 이상 사용되지 않으면 메모리를 해제하거나 파일 또는 소켓을 닫아 리소스를 &quot;정리&quot;해야합니다. 이것은 소멸자의 작업이므로 &lt;code&gt;Drop::drop&lt;/code&gt; 의 작업입니다 .</target>
        </trans-unit>
        <trans-unit id="0e9f144fd6603397ae748bc2c2b95fde2038ac9c" translate="yes" xml:space="preserve">
          <source>As a companion to &lt;a href=&quot;trait.borrow&quot;&gt;&lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; this trait allows a type to borrow as an underlying type by providing a mutable reference. See &lt;a href=&quot;trait.borrow&quot;&gt;&lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for more information on borrowing as another type.</source>
          <target state="translated">&lt;a href=&quot;trait.borrow&quot;&gt; &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 의 동반자 로서이 특성은 유형이 변경 가능한 참조를 제공하여 기본 유형으로 빌릴 수 있도록합니다. 다른 유형으로 대출에 대한 자세한 내용 은 &lt;a href=&quot;trait.borrow&quot;&gt; &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f044338e83e2522cd461ee6d84f7c5ea2e52e486" translate="yes" xml:space="preserve">
          <source>As a consequence, the hash map breaks if a &lt;code&gt;K&lt;/code&gt; wrapping a &lt;code&gt;Q&lt;/code&gt; value produces a different hash than &lt;code&gt;Q&lt;/code&gt;. For instance, imagine you have a type that wraps a string but compares ASCII letters ignoring their case:</source>
          <target state="translated">결과로서, 만약 해시 맵 나누기 &lt;code&gt;K&lt;/code&gt; 랩핑 &lt;code&gt;Q&lt;/code&gt; 의 값은 상이한 해시 생성 &lt;code&gt;Q&lt;/code&gt; 를 . 예를 들어, 문자열을 감싸지 만 대소 문자를 무시하고 ASCII 문자를 비교하는 유형이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="21e6ec20b4bccf73414453b9c7ceac9ffa2614a2" translate="yes" xml:space="preserve">
          <source>As a data collection, &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt; owns both keys and values. If the key&amp;rsquo;s actual data is wrapped in a managing type of some kind, it should, however, still be possible to search for a value using a reference to the key&amp;rsquo;s data. For instance, if the key is a string, then it is likely stored with the hash map as a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, while it should be possible to search using a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. Thus, &lt;code&gt;insert&lt;/code&gt; needs to operate on a &lt;code&gt;String&lt;/code&gt; while &lt;code&gt;get&lt;/code&gt; needs to be able to use a &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">데이터 수집으로서 &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 키와 값을 모두 소유합니다. 그러나 키의 실제 데이터가 일종의 관리 유형으로 래핑 된 경우 키 데이터에 대한 참조를 사용하여 값을 검색 할 수 있어야합니다. 예를 들어, 키가 문자열 인 경우 해시 맵과 함께 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 으로 저장 될 가능성이 높으며 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 사용하여 검색 할 수 있습니다 . 따라서 &lt;code&gt;insert&lt;/code&gt; 는 &lt;code&gt;String&lt;/code&gt; 에서 작동해야 하지만 &lt;code&gt;get&lt;/code&gt; 은 &lt;code&gt;&amp;amp;str&lt;/code&gt; 을 사용할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="72b018e0e36049ad8edb2d9275fa43ffbd253ac2" translate="yes" xml:space="preserve">
          <source>As a first example of ownership, we&amp;rsquo;ll look at the &lt;em&gt;scope&lt;/em&gt; of some variables. A scope is the range within a program for which an item is valid. Let&amp;rsquo;s say we have a variable that looks like this:</source>
          <target state="translated">소유권의 첫 번째 예로, 일부 변수 의 &lt;em&gt;범위&lt;/em&gt; 를 살펴 보겠습니다 . 범위는 항목이 유효한 프로그램 내의 범위입니다. 다음과 같은 변수가 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="0024a0a24aed0a7ac58334f18eea8263ecf48ec1" translate="yes" xml:space="preserve">
          <source>As a language, Rust cares a &lt;em&gt;lot&lt;/em&gt; about the stability of your code. We want Rust to be a rock-solid foundation you can build on, and if things were constantly changing, that would be impossible. At the same time, if we can&amp;rsquo;t experiment with new features, we may not find out important flaws until after their release, when we can no longer change things.</source>
          <target state="translated">언어로서 Rust는 &lt;em&gt; 많은&lt;/em&gt; 코드의 안정성에 대한합니다. 우리는 Rust이 여러분이 지을 수있는 견고한 기반이되기를 원하며, 끊임없이 변화하고 있다면 불가능할 것입니다. 동시에, 새로운 기능을 시험해 볼 수 없다면, 출시 이후까지, 더 이상 변경할 수없는 중요한 결함을 찾지 못할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7163ba6f2bf3417c3c81c5ac8d3af7e28902510" translate="yes" xml:space="preserve">
          <source>As a library author, you should always prefer implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt;, as &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; provide greater flexibility and offer equivalent &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; implementations for free, thanks to a blanket implementation in the standard library. Only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; when a conversion to a type outside the current crate is required.</source>
          <target state="translated">라이브러리 작성자 는 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; 이&lt;/a&gt; 더 큰 유연성을 제공하고 동등한 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt; 구현을 무료로 제공하므로 항상 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 구현을 선호해야 합니다. 표준 라이브러리에서 담요 구현. 현재 상자 이외의 유형으로 변환해야 할 경우 에만 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; 를&lt;/a&gt; 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="c688289e645266d022bd25b11abee98bf47d494f" translate="yes" xml:space="preserve">
          <source>As a library author, you should always prefer implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt;, as &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; provide greater flexibility and offer equivalent &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; implementations for free, thanks to a blanket implementation in the standard library. When targeting a version prior to Rust 1.41, it may be necessary to implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; directly when converting to a type outside the current crate.</source>
          <target state="translated">도서관 저자로서, 당신은 항상 구현을 선호한다 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 보다는 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt; 로 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; &lt;/a&gt; 더 큰 유연성을 제공하며 동등한 제공하는 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt; 무료로 구현, 덕분에 표준 라이브러리의 포괄적 구현. Rust 1.41 이전 버전을 대상 으로 할 때 현재 상자 외부의 유형으로 변환 할 때 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; 를&lt;/a&gt; 직접 구현해야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ff562238e6519efc127fd0f82f8c3d4cbe94172e" translate="yes" xml:space="preserve">
          <source>As a more concise alternative, you can use a &lt;code&gt;for&lt;/code&gt; loop and execute some code for each item in a collection. A &lt;code&gt;for&lt;/code&gt; loop looks like the code in Listing 3-5.</source>
          <target state="translated">더 간결한 대안으로 &lt;code&gt;for&lt;/code&gt; 루프를 사용 하고 컬렉션의 각 항목에 대해 일부 코드를 실행할 수 있습니다 . &lt;code&gt;for&lt;/code&gt; 목록 3-5의 코드와 같은 루프 보인다.</target>
        </trans-unit>
        <trans-unit id="4b5b050c97f5fa423f8a999dca4b012b9c78134c" translate="yes" xml:space="preserve">
          <source>As a result of this code, &lt;code&gt;s&lt;/code&gt; will contain &lt;code&gt;lol&lt;/code&gt;.</source>
          <target state="translated">이 코드의 결과로 &lt;code&gt;s&lt;/code&gt; &lt;code&gt;lol&lt;/code&gt; 이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="b710b8f0107d2ffba9437950b5808cd39ab806b4" translate="yes" xml:space="preserve">
          <source>As a result, this method consider addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; to be unicast link-local addresses, whereas &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;Ipv6Addr::is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt; does not. If you need a strict validation fully compliant with the RFC, use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;Ipv6Addr::is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">결과적으로이 메서드는 &lt;code&gt;fe80:0:0:1::&lt;/code&gt; 또는 &lt;code&gt;fe81::&lt;/code&gt; 과 같은 주소 를 유니 캐스트 링크 로컬 주소로 &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;Ipv6Addr::is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt; 하지만 Ipv6Addr :: is_unicast_link_local_strict () 는 그렇지 않습니다. RFC를 완전히 준수하는 엄격한 유효성 검사가 필요한 경우 &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;Ipv6Addr::is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0f98a89f1abd2dd1d5bfe499fd5b56372a5800c2" translate="yes" xml:space="preserve">
          <source>As a result, this method consider addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; to be unicast link-local addresses, whereas &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt; does not. If you need a strict validation fully compliant with the RFC, use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과적으로이 방법은 &lt;code&gt;fe80:0:0:1::&lt;/code&gt; 또는 &lt;code&gt;fe81::&lt;/code&gt; 와 같은 주소 를 유니 캐스트 링크 로컬 주소로 &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt; 하지만 is_unicast_link_local_strict () 는 그렇지 않습니다. RFC를 완전히 준수하는 엄격한 유효성 검증이 필요한 경우 &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="486c7c23286a7b0e1299ccac2ee0a869b3e82ee5" translate="yes" xml:space="preserve">
          <source>As a string slice consists of a sequence of bytes, we can iterate through a string slice by byte. This method returns such an iterator.</source>
          <target state="translated">문자열 슬라이스는 일련의 바이트로 구성되므로 문자열 슬라이스를 바이트 단위로 반복 할 수 있습니다. 이 메소드는 그러한 반복자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="13230333554cf4f41cab6ad4fc5190eeee2538f2" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">문자열 슬라이스는 유효한 UTF-8로 구성되므로 &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 별로 문자열 슬라이스를 반복 할 수 있습니다 . 이 메소드는이 &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 와 바이트 위치 의 반복자를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="437cfa80202d923ee25f6cf5ad0fd2f02cfb01ea" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">문자열 슬라이스는 유효한 UTF-8로 구성되므로 &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 별로 문자열 슬라이스를 반복 할 수 있습니다 . 이 메소드는 그러한 반복자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5e4e8ad23ff47badf3452433750942f67bdc2881" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">문자열 슬라이스는 유효한 UTF-8로 구성되어 있으므로 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 로 문자열 슬라이스를 반복 할 수 있습니다 . 이 메서드는 이러한 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 의 반복자 와 해당 바이트 위치 를 모두 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b276d81f1ebeb72ef92a468ba3b31b82b8dbf57a" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">문자열 슬라이스는 유효한 UTF-8로 구성되어 있으므로 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 로 문자열 슬라이스를 반복 할 수 있습니다 . 이 메서드는 이러한 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fb40adb4e231d6bdd9f0bd0f9320f4357a2e82ae" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">문자열 슬라이스는 유효한 UTF-8로 구성되므로 &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 별로 문자열 슬라이스를 반복 할 수 있습니다 . 이 메소드는이 &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 와 바이트 위치 의 반복자를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="bf66f1c269d4394c9cb4445fd4fd600e640f2992" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">문자열 슬라이스는 유효한 UTF-8로 구성되므로 &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 별로 문자열 슬라이스를 반복 할 수 있습니다 . 이 메소드는 그러한 반복자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="047a0a2f69f724c14716efaa0063a5ea83e459c4" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">문자열 슬라이스는 유효한 UTF-8로 구성되어 있으므로 &lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 로 문자열 슬라이스를 반복 할 수 있습니다 . 이 메서드는 이러한 &lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 의 반복자 와 해당 바이트 위치 를 모두 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6d408364fefca0ab968a9b16914cf4b387f8e95e" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">문자열 슬라이스는 유효한 UTF-8로 구성되어 있으므로 &lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 로 문자열 슬라이스를 반복 할 수 있습니다 . 이 메서드는 이러한 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b4d78aa978dc16456ba4fafe0a526ad6183e3881" translate="yes" xml:space="preserve">
          <source>As always, remember that a human intuition for 'character' may not map to Unicode's definitions. For example, despite looking similar, the '&amp;eacute;' character is one Unicode code point while 'é' is two Unicode code points:</source>
          <target state="translated">항상 그렇듯이 '문자'에 대한 인간의 직감은 유니 코드의 정의에 매핑되지 않을 수 있습니다. 예를 들어, 비슷한 모양에도 불구하고 '&amp;eacute;'문자는 하나의 유니 코드 코드 포인트이고 '&amp;eacute;'는 두 개의 유니 코드 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="8d82369403176e5c690373478594ff76e764a9ef" translate="yes" xml:space="preserve">
          <source>As always, we can use curly brackets to create a new scope, allowing for multiple mutable references, just not &lt;em&gt;simultaneous&lt;/em&gt; ones:</source>
          <target state="translated">언제나처럼 중괄호를 사용하여 새 범위를 만들어 &lt;em&gt;동시&lt;/em&gt; 참조가 아닌 여러 개의 가변 참조를 허용 할 &lt;em&gt;수&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5be02ef05f525885a914931855842d0bd0941ea" translate="yes" xml:space="preserve">
          <source>As an example of how to use a mutex, let&amp;rsquo;s start by using a mutex in a single-threaded context, as shown in Listing 16-12:</source>
          <target state="translated">뮤텍스를 사용하는 방법의 예로써, Listing 16-12와 같이 단일 스레드 컨텍스트에서 뮤텍스를 사용하여 시작해 보자.</target>
        </trans-unit>
        <trans-unit id="0a2b1532710f708a62d9bd14aa059c7176218c09" translate="yes" xml:space="preserve">
          <source>As an example of methods on a trait, consider the following:</source>
          <target state="translated">특성에 대한 방법의 예로 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="46ce22c9bcccaee92580f06aedfeeb7db04850fe" translate="yes" xml:space="preserve">
          <source>As an example of where you could use either a closure defined inline or a named function, let&amp;rsquo;s look at a use of &lt;code&gt;map&lt;/code&gt;. To use the &lt;code&gt;map&lt;/code&gt; function to turn a vector of numbers into a vector of strings, we could use a closure, like this:</source>
          <target state="translated">인라인으로 정의 된 클로저 또는 명명 된 함수를 사용할 수있는 위치의 예로 &lt;code&gt;map&lt;/code&gt; 사용을 살펴 보겠습니다 . &lt;code&gt;map&lt;/code&gt; 함수 를 사용하여 숫자 벡터를 문자열 벡터로 바꾸려면 다음과 같이 클로저를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37540a09808abda7d1579f892bfd40fb102faf8d" translate="yes" xml:space="preserve">
          <source>As an example, Listing 11-10 has a silly function that prints the value of its parameter and returns 10, as well as a test that passes and a test that fails.</source>
          <target state="translated">예를 들어, 목록 11-10에는 매개 변수의 값을 인쇄하고 10을 반환하는 바보 함수와 통과 테스트 및 실패 테스트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="53691b327422875e6972393627946b878398498e" translate="yes" xml:space="preserve">
          <source>As an example, a macro matcher like &lt;code&gt;$i:expr [ , ]&lt;/code&gt; could in theory be accepted in Rust today, since &lt;code&gt;[,]&lt;/code&gt; cannot be part of a legal expression and therefore the parse would always be unambiguous. However, because &lt;code&gt;[&lt;/code&gt; can start trailing expressions, &lt;code&gt;[&lt;/code&gt; is not a character which can safely be ruled out as coming after an expression. If &lt;code&gt;[,]&lt;/code&gt; were accepted in a later version of Rust, this matcher would become ambiguous or would misparse, breaking working code. Matchers like &lt;code&gt;$i:expr,&lt;/code&gt; or &lt;code&gt;$i:expr;&lt;/code&gt; would be legal, however, because &lt;code&gt;,&lt;/code&gt; and &lt;code&gt;;&lt;/code&gt; are legal expression separators. The specific rules are:</source>
          <target state="translated">예를 들어, &lt;code&gt;$i:expr [ , ]&lt;/code&gt; 와 같은 매크로 매처 는 이론적으로 Rust에서 받아 들일 수 있습니다. &lt;code&gt;[,]&lt;/code&gt; 는 합법적 인 표현의 일부가 될 수 없기 때문에 구문 분석은 항상 모호하지 않습니다. 때문에, &lt;code&gt;[&lt;/code&gt; 이 표현을 후행 시작할 수 있습니다, &lt;code&gt;[&lt;/code&gt; 안전 식 후에 들어오는 배제 할 수있는 문자가 아닙니다. 경우 &lt;code&gt;[,]&lt;/code&gt; 녹 이후 버전에서 사용 가능하고,이 정규 모호한 될 것 또는 작동 코드를 깨는, misparse 것입니다. &lt;code&gt;$i:expr,&lt;/code&gt; 또는 &lt;code&gt;$i:expr;&lt;/code&gt; 과 같은 매처 ; 법적 것이다, 그러나 때문에 &lt;code&gt;,&lt;/code&gt; 그리고 &lt;code&gt;;&lt;/code&gt; 합법적 인 구분 기호입니다. 구체적인 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3c5226f2d8790540dbbe88f9ad68f2409b55a32e" translate="yes" xml:space="preserve">
          <source>As an example, change the &lt;em&gt;src/main.rs&lt;/em&gt; file in your &lt;em&gt;loops&lt;/em&gt; directory to look like this:</source>
          <target state="translated">예를 들어, &lt;em&gt;loops&lt;/em&gt; 디렉토리 에서 &lt;em&gt;src / main.rs&lt;/em&gt; 파일 을 다음과 같이 변경하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f0fd43eedc8fb375dd6813798e9b7e3996a0f09" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s change one of our enum variants to hold data inside it. From 1999 through 2008, the United States minted quarters with different designs for each of the 50 states on one side. No other coins got state designs, so only quarters have this extra value. We can add this information to our &lt;code&gt;enum&lt;/code&gt; by changing the &lt;code&gt;Quarter&lt;/code&gt; variant to include a &lt;code&gt;UsState&lt;/code&gt; value stored inside it, which we&amp;rsquo;ve done here in Listing 6-4.</source>
          <target state="translated">예를 들어, 열거 형 변형 중 하나를 변경하여 내부에 데이터를 보유합시다. 1999 년부터 2008 년까지 미국은 한쪽에 50 개 주마다 각기 다른 디자인으로 분기를 기록했습니다. 다른 동전은 국가 디자인을 얻지 못 했으므로 1/4만이 추가 가치를 갖습니다. 우리는 &lt;code&gt;Quarter&lt;/code&gt; 변형을 수정하여 &lt;code&gt;UsState&lt;/code&gt; 안에 저장된 UsState 값 을 포함 시킴으로써이 정보를 &lt;code&gt;enum&lt;/code&gt; 에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d430493784bb7c38b9bfd2132c640f18ef8a2cfc" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s say we want to implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, which the orphan rule prevents us from doing directly because the &lt;code&gt;Display&lt;/code&gt; trait and the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type are defined outside our crate. We can make a &lt;code&gt;Wrapper&lt;/code&gt; struct that holds an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;; then we can implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Wrapper&lt;/code&gt; and use the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; value, as shown in Listing 19-23.</source>
          <target state="translated">예를 들어, &lt;code&gt;Display&lt;/code&gt; 특성과 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 유형이 상자 외부에 정의되어 있기 때문에 고아 규칙으로 인해 직접 수행 할 수없는 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 에 &lt;code&gt;Display&lt;/code&gt; 를 구현하려고한다고 가정하겠습니다 . &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 인스턴스를 보유하는 &lt;code&gt;Wrapper&lt;/code&gt; 구조체를 만들 수 있습니다 . 그런 다음 &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Wrapper&lt;/code&gt; 를 구현 하고 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 값을 사용할 수 있습니다 ( Listing 19-23).</target>
        </trans-unit>
        <trans-unit id="0a293358ddd19b42df03eeb78c691469d4c0e122" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s write a library crate that provides the functionality of a restaurant. We&amp;rsquo;ll define the signatures of functions but leave their bodies empty to concentrate on the organization of the code, rather than actually implement a restaurant in code.</source>
          <target state="translated">예를 들어 식당의 기능을 제공하는 라이브러리 상자를 작성해 봅시다. 함수의 시그니처를 정의하지만 실제로 코드로 레스토랑을 구현하는 대신 코드 구성에 집중하기 위해 본문을 비워 두십시오.</target>
        </trans-unit>
        <trans-unit id="5e1d4bdb076d3e495d340c82a90a7bc9edd4704c" translate="yes" xml:space="preserve">
          <source>As an example, rather than using a list whose items know only about the next item, we&amp;rsquo;ll create a tree whose items know about their children items &lt;em&gt;and&lt;/em&gt; their parent items.</source>
          <target state="translated">예를 들어 다음 항목에 대해서만 항목을 알고있는 목록을 사용하는 대신 하위 항목 &lt;em&gt;과&lt;/em&gt; 부모 항목에 대해 항목을 알고있는 트리를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="84057f7bc04baf2d73dfbd111ea89a20d0d17089" translate="yes" xml:space="preserve">
          <source>As an example, recall the &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; marker traits we discussed in the &lt;a href=&quot;ch16-04-extensible-concurrency-sync-and-send#extensible-concurrency-with-the-sync-and-send-traits&quot;&gt;&amp;ldquo;Extensible Concurrency with the &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; Traits&amp;rdquo;&lt;/a&gt; section in Chapter 16: the compiler implements these traits automatically if our types are composed entirely of &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; types. If we implement a type that contains a type that is not &lt;code&gt;Send&lt;/code&gt; or &lt;code&gt;Sync&lt;/code&gt;, such as raw pointers, and we want to mark that type as &lt;code&gt;Send&lt;/code&gt; or &lt;code&gt;Sync&lt;/code&gt;, we must use &lt;code&gt;unsafe&lt;/code&gt;. Rust can&amp;rsquo;t verify that our type upholds the guarantees that it can be safely sent across threads or accessed from multiple threads; therefore, we need to do those checks manually and indicate as such with &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 16 장의 &lt;a href=&quot;ch16-04-extensible-concurrency-sync-and-send#extensible-concurrency-with-the-sync-and-send-traits&quot;&gt;&quot; &lt;/a&gt; &lt;code&gt;Sync&lt;/code&gt; 및 &lt;code&gt;Send&lt;/code&gt; 특성 과의 확장 성 동시성 &quot; 섹션에서 논의한 &lt;code&gt;Sync&lt;/code&gt; 및 &lt;code&gt;Send&lt;/code&gt; 마커 특성을 기억하십시오 . 유형이 전체적으로 &lt;code&gt;Send&lt;/code&gt; 및 &lt;code&gt;Sync&lt;/code&gt; 유형 으로 구성된 경우 컴파일러는 이러한 특성을 자동으로 구현 합니다. 원시 포인터와 같이 &lt;code&gt;Send&lt;/code&gt; 또는 &lt;code&gt;Sync&lt;/code&gt; 가 아닌 유형을 포함하는 유형을 구현하고 해당 유형을 &lt;code&gt;Send&lt;/code&gt; 또는 &lt;code&gt;Sync&lt;/code&gt; 로 표시 하려면 &lt;code&gt;unsafe&lt;/code&gt; 것을 사용해야합니다. Rust는 우리 유형이 스레드간에 안전하게 전송되거나 여러 스레드에서 액세스 될 수 있음을 보증하는지 확인할 수 없습니다. 따라서 이러한 검사를 수동으로 수행하고 &lt;code&gt;unsafe&lt;/code&gt; 로 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="38a88a1bad47211ae1a10e5bfcee84726e1f325e" translate="yes" xml:space="preserve">
          <source>As an example, say we write a function called &lt;code&gt;add_two&lt;/code&gt; that adds 2 to whatever number is passed to it. This function&amp;rsquo;s signature accepts an integer as a parameter and returns an integer as a result. When we implement and compile that function, Rust does all the type checking and borrow checking that you&amp;rsquo;ve learned so far to ensure that, for instance, we aren&amp;rsquo;t passing a &lt;code&gt;String&lt;/code&gt; value or an invalid reference to this function. But Rust &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; check that this function will do precisely what we intend, which is return the parameter plus 2 rather than, say, the parameter plus 10 or the parameter minus 50! That&amp;rsquo;s where tests come in.</source>
          <target state="translated">예를 들어, 전달 된 숫자에 2를 더하는 &lt;code&gt;add_two&lt;/code&gt; 라는 함수를 작성한다고 가정 하십시오. 이 함수의 서명은 정수를 매개 변수로 승인하고 결과로 정수를 리턴합니다. 해당 함수를 구현하고 컴파일 할 때 Rust는 예를 들어이 함수에 대한 &lt;code&gt;String&lt;/code&gt; 값이나 잘못된 참조를 전달하지 않도록하기 위해 지금까지 배운 모든 유형 검사 및 대출 검사를 수행합니다. 그러나 Rust &lt;em&gt;는&lt;/em&gt; 이 함수가 우리가 의도 한대로 정확하게 수행하는지 확인할 &lt;em&gt;수 없습니다&lt;/em&gt; . 즉, 매개 변수 더하기 10 또는 매개 변수 빼기 50 대신 매개 변수 더하기 2를 반환합니다! 그곳에서 테스트가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="0c46b40f3e5f774d5bd6d946904f04146f347849" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]&lt;/code&gt;</source>
          <target state="translated">예를 들어, 패턴 &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; 및 건초 더미 &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; 는 스트림 &lt;code&gt;[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6b604f8510907ca9fe9178dfcf2a6874e95e6b5" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;</source>
          <target state="translated">예를 들어, 패턴 &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; 및 건초 더미 &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; 는 스트림 &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4bbd3fe41e9f9da754b12e58c1b62e309d7fedd0" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 패턴 &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; 및 건초 더미 &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; 는 스트림 &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="877bff60769fbc36114e44fb0843def0fdaa302f" translate="yes" xml:space="preserve">
          <source>As an iterator:</source>
          <target state="translated">반복자로서 :</target>
        </trans-unit>
        <trans-unit id="04b8526b20e002ad597cb978c8868c4ab1a90f67" translate="yes" xml:space="preserve">
          <source>As another example, suppose we have a &lt;code&gt;Maker&lt;/code&gt; trait and want to establish a type &lt;code&gt;FooMaker&lt;/code&gt; that makes &lt;code&gt;Foo&lt;/code&gt;s:</source>
          <target state="translated">또 다른 예로, &lt;code&gt;Maker&lt;/code&gt; 특성이 있고 &lt;code&gt;Foo&lt;/code&gt; 를 만드는 &lt;code&gt;FooMaker&lt;/code&gt; 유형을 설정하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="5213c1c4f3b10c9c56042b19c8c0157b715adba7" translate="yes" xml:space="preserve">
          <source>As another example, the following code is taken from an audio decoder. The decoding algorithm uses the linear prediction mathematical operation to estimate future values based on a linear function of the previous samples. This code uses an iterator chain to do some math on three variables in scope: a &lt;code&gt;buffer&lt;/code&gt; slice of data, an array of 12 &lt;code&gt;coefficients&lt;/code&gt;, and an amount by which to shift data in &lt;code&gt;qlp_shift&lt;/code&gt;. We&amp;rsquo;ve declared the variables within this example but not given them any values; although this code doesn&amp;rsquo;t have much meaning outside of its context, it&amp;rsquo;s still a concise, real-world example of how Rust translates high-level ideas to low-level code.</source>
          <target state="translated">다른 예로서, 다음 코드는 오디오 디코더로부터 취해진 다. 디코딩 알고리즘은 선형 예측 수학 연산을 사용하여 이전 샘플의 선형 함수에 기초하여 미래 값을 추정한다. 이 코드는 반복자 체인을 사용하여 데이터 의 &lt;code&gt;buffer&lt;/code&gt; 슬라이스, 12 개의 &lt;code&gt;coefficients&lt;/code&gt; 배열 및 &lt;code&gt;qlp_shift&lt;/code&gt; 에서 데이터를 이동시키는 양의 세 가지 변수에 대해 수학을 수행 합니다. 이 예제에서 변수를 선언했지만 값을 지정하지 않았습니다. 이 코드는 컨텍스트 외부에서 별 의미가 없지만 Rust가 높은 수준의 아이디어를 낮은 수준의 코드로 변환하는 방법에 대한 간결하고 실제적인 예입니다.</target>
        </trans-unit>
        <trans-unit id="50430e10a27b5bcf53132a5539fdc175dfb8f896" translate="yes" xml:space="preserve">
          <source>As can be seen below, &lt;code&gt;else&lt;/code&gt; must be followed by either: &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;if let&lt;/code&gt;, or a block &lt;code&gt;{}&lt;/code&gt; and it will return the value of that expression.</source>
          <target state="translated">아래에서 볼 수 있듯이 &lt;code&gt;else&lt;/code&gt; 뒤에는 &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;if let&lt;/code&gt; 또는 블록 &lt;code&gt;{}&lt;/code&gt; 이 와야하며 해당 표현식의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ceca2c634722fa77d0d672657c5578a7251142a0" translate="yes" xml:space="preserve">
          <source>As described, &lt;a href=&quot;../i32/index&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;TryFrom&amp;lt;i64&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">설명한대로 &lt;a href=&quot;../i32/index&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;TryFrom&amp;lt;i64&amp;gt;&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="7af5c30f33f1fda6dc417defcc8e46844e2584e3" translate="yes" xml:space="preserve">
          <source>As described, &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;TryFrom&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">설명한대로 &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;TryFrom&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="0958482afe9fd3c8317c6c0d343e311be75015c7" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 10, to implement a trait, we need to provide implementations for the trait&amp;rsquo;s required methods. The &lt;code&gt;Deref&lt;/code&gt; trait, provided by the standard library, requires us to implement one method named &lt;code&gt;deref&lt;/code&gt; that borrows &lt;code&gt;self&lt;/code&gt; and returns a reference to the inner data. Listing 15-10 contains an implementation of &lt;code&gt;Deref&lt;/code&gt; to add to the definition of &lt;code&gt;MyBox&lt;/code&gt;:</source>
          <target state="translated">10 장에서 논의한 것처럼 특성을 구현하려면 특성의 필수 메소드에 대한 구현을 제공해야합니다. &lt;code&gt;Deref&lt;/code&gt; 특성, 표준 라이브러리에서 제공하는이라는 하나의 방법 구현하기 위해 우리를 필요로 &lt;code&gt;deref&lt;/code&gt; 그 차용의 &lt;code&gt;self&lt;/code&gt; 반환 내부 데이터에 대한 참조를. Listing 15-10에는 &lt;code&gt;MyBox&lt;/code&gt; 정의에 추가하기위한 &lt;code&gt;Deref&lt;/code&gt; 구현이 포함되어있다 .</target>
        </trans-unit>
        <trans-unit id="d5f5ed3e00ea3332f0559aed11908528d1ba499a" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 17, the &lt;code&gt;take&lt;/code&gt; method on &lt;code&gt;Option&lt;/code&gt; takes the &lt;code&gt;Some&lt;/code&gt; variant out and leaves &lt;code&gt;None&lt;/code&gt; in its place. We&amp;rsquo;re using &lt;code&gt;if let&lt;/code&gt; to destructure the &lt;code&gt;Some&lt;/code&gt; and get the thread; then we call &lt;code&gt;join&lt;/code&gt; on the thread. If a worker&amp;rsquo;s thread is already &lt;code&gt;None&lt;/code&gt;, we know that worker has already had its thread cleaned up, so nothing happens in that case.</source>
          <target state="translated">17 장에서 논의한 것처럼 &lt;code&gt;Option&lt;/code&gt; 의 &lt;code&gt;take&lt;/code&gt; 메소드 는 &lt;code&gt;Some&lt;/code&gt; 변형을 제거하고 대신 &lt;code&gt;None&lt;/code&gt; 을 남겨 둡니다 . 우리가 사용하고있는 &lt;code&gt;if let&lt;/code&gt; destructure하기 위해 &lt;code&gt;Some&lt;/code&gt; 및 스레드를 얻을; 그런 다음 스레드에서 &lt;code&gt;join&lt;/code&gt; 을 호출 합니다. 워커의 스레드가 이미 &lt;code&gt;None&lt;/code&gt; 이면 워커가 이미 스레드를 정리했음을 알 수 있으므로이 경우 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fd5d9a215556134ab45028a161d57190ff678d3" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 6, we use patterns in the arms of &lt;code&gt;match&lt;/code&gt; expressions. Formally, &lt;code&gt;match&lt;/code&gt; expressions are defined as the keyword &lt;code&gt;match&lt;/code&gt;, a value to match on, and one or more match arms that consist of a pattern and an expression to run if the value matches that arm&amp;rsquo;s pattern, like this:</source>
          <target state="translated">6 장에서 논의한 바와 같이, 우리는 &lt;code&gt;match&lt;/code&gt; 표현에 패턴을 사용 합니다. 공식적으로 &lt;code&gt;match&lt;/code&gt; 표현식은 키워드 &lt;code&gt;match&lt;/code&gt; , 일치 할 값 및 패턴으로 구성된 하나 이상의 일치 암 및 값이 해당 팔의 패턴과 일치하는 경우 실행할 식으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b597a68d9b285f7d308e42a0c9a8b37ad1bf7193" translate="yes" xml:space="preserve">
          <source>As for what happens behind the scenes, when optimizations are enabled the final generated machine code might look very different from the code:</source>
          <target state="translated">배후에서 일어나는 일에 대해 최적화가 활성화되면 최종 생성 된 기계 코드가 코드와 매우 다르게 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7061cd66862cc7d4e84cb20891d413f4dbad19d" translate="yes" xml:space="preserve">
          <source>As functions, they must either return syntax, panic, or loop endlessly. Returned syntax either replaces or adds the syntax depending on the kind of procedural macro. Panics are caught by the compiler and are turned into a compiler error. Endless loops are not caught by the compiler which hangs the compiler.</source>
          <target state="translated">함수로서, 구문, 패닉 또는 루프를 끝없이 리턴해야합니다. 반환 된 구문은 절차 적 매크로의 종류에 따라 구문을 대체하거나 추가합니다. 패닉은 컴파일러에 의해 포착되어 컴파일러 오류로 바뀝니다. 컴파일러를 중단시키는 컴파일러는 무한 루프를 포착하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd8f9685a0be8d16b4d260e66976648f0f435f12" translate="yes" xml:space="preserve">
          <source>As humans, we can look at this code and see that &lt;code&gt;string1&lt;/code&gt; is longer than &lt;code&gt;string2&lt;/code&gt; and therefore &lt;code&gt;result&lt;/code&gt; will contain a reference to &lt;code&gt;string1&lt;/code&gt;. Because &lt;code&gt;string1&lt;/code&gt; has not gone out of scope yet, a reference to &lt;code&gt;string1&lt;/code&gt; will still be valid for the &lt;code&gt;println!&lt;/code&gt; statement. However, the compiler can&amp;rsquo;t see that the reference is valid in this case. We&amp;rsquo;ve told Rust that the lifetime of the reference returned by the &lt;code&gt;longest&lt;/code&gt; function is the same as the smaller of the lifetimes of the references passed in. Therefore, the borrow checker disallows the code in Listing 10-24 as possibly having an invalid reference.</source>
          <target state="translated">인간으로서 우리는이 코드를보고 &lt;code&gt;string1&lt;/code&gt; 이 &lt;code&gt;string2&lt;/code&gt; 보다 길 므로 &lt;code&gt;result&lt;/code&gt; 에 &lt;code&gt;string1&lt;/code&gt; 에 대한 참조가 포함된다는 것을 알 수 있습니다 . 때문에 &lt;code&gt;string1&lt;/code&gt; 아직 범위 밖으로 사라하지 않았에 대한 참조 &lt;code&gt;string1&lt;/code&gt; 여전히 유효합니다 &lt;code&gt;println!&lt;/code&gt; 성명서. 그러나 컴파일러는이 경우 참조가 유효한지 확인할 수 없습니다. 우리는 Rust에게 &lt;code&gt;longest&lt;/code&gt; 함수에 의해 리턴 된 참조 의 수명은 전달 된 참조의 수명보다 작은 것과 동일 하다고 이야기 했다. 따라서 빌림 검사기는 Listing 10-24의 코드가 유효하지 않은 참조를 갖는 것을 허용하지 않는다 .</target>
        </trans-unit>
        <trans-unit id="6d9f4910be4026effcf198634df42e1c4041dff1" translate="yes" xml:space="preserve">
          <source>As in most other programming languages, a Boolean type in Rust has two possible values: &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Booleans are one byte in size. The Boolean type in Rust is specified using &lt;code&gt;bool&lt;/code&gt;. For example:</source>
          <target state="translated">대부분의 다른 프로그래밍 언어와 마찬가지로 Rust의 부울 형식에는 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 의 두 가지 가능한 값이 있습니다. 부울의 크기는 1 바이트입니다. Rust의 부울 유형은 &lt;code&gt;bool&lt;/code&gt; 을 사용하여 지정됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="45c7aa166fa09685143658300364b92158ea06fe" translate="yes" xml:space="preserve">
          <source>As is the case in &lt;a href=&quot;if-expr#if-let-expressions&quot;&gt;&lt;code&gt;if let&lt;/code&gt; expressions&lt;/a&gt;, the scrutinee cannot be a &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean operator expression&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;if-expr#if-let-expressions&quot;&gt; &lt;code&gt;if let&lt;/code&gt; 표현식&lt;/a&gt; 의 경우처럼 스크 루틴은 &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;지연 부울 연산자 표현식이&lt;/a&gt; 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="118d39ec67253c2f49ef6f0a1ef21526ef7b61b3" translate="yes" xml:space="preserve">
          <source>As it turns out, though, most traits can have an &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;!&lt;/code&gt;. Take &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; for example:</source>
          <target state="translated">그것이 나오는 것에 따라,하지만, 대부분의 특성은 가질 수 &lt;code&gt;impl&lt;/code&gt; 를 들어 &lt;code&gt;!&lt;/code&gt; . 예를 들어 &lt;a href=&quot;fmt/trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a025b290deb94845050bfa62909fd15fe5ae74be" translate="yes" xml:space="preserve">
          <source>As long as your command line parsing logic is small, it can remain in &lt;em&gt;main.rs&lt;/em&gt;.</source>
          <target state="translated">명령 줄 구문 분석 논리가 작 으면 &lt;em&gt;main.rs에&lt;/em&gt; 남아있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8323a3696731d93f0a84dafc08f2d32df5ef0903" translate="yes" xml:space="preserve">
          <source>As mentioned at the start of the chapter, testing is a complex discipline, and different people use different terminology and organization. The Rust community thinks about tests in terms of two main categories: &lt;em&gt;unit tests&lt;/em&gt; and &lt;em&gt;integration tests&lt;/em&gt;. Unit tests are small and more focused, testing one module in isolation at a time, and can test private interfaces. Integration tests are entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.</source>
          <target state="translated">이 장의 시작 부분에서 언급했듯이 테스트는 복잡한 학문이며 다른 사람들은 다른 용어와 조직을 사용합니다. Rust 커뮤니티는 두 가지 주요 범주 인 &lt;em&gt;단위 테스트&lt;/em&gt; 와 &lt;em&gt;통합 테스트&lt;/em&gt; 측면에서 테스트에 대해 생각 &lt;em&gt;합니다&lt;/em&gt; . 단위 테스트는 작고 집중적이며 한 번에 하나의 모듈을 개별적으로 테스트하며 개인 인터페이스를 테스트 할 수 있습니다. 통합 테스트는 전적으로 라이브러리 외부에 있으며 공용 인터페이스 만 사용하고 테스트 당 여러 모듈을 사용하는 다른 외부 코드와 같은 방식으로 코드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="10eda87545057c2aa683c0bbfe8990122953ece6" translate="yes" xml:space="preserve">
          <source>As mentioned before, trait objects contain pointers to method tables. So, if we have:</source>
          <target state="translated">앞에서 언급했듯이 특성 오브젝트에는 메소드 테이블에 대한 포인터가 포함되어 있습니다. 우리가 가지고 있다면 :</target>
        </trans-unit>
        <trans-unit id="4761017ad6dee318134842b138bc05d35199a594" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, &lt;code&gt;read_line&lt;/code&gt; puts what the user types into the string we&amp;rsquo;re passing it, but it also returns a value&amp;mdash;in this case, an &lt;a href=&quot;../std/io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;. Rust has a number of types named &lt;code&gt;Result&lt;/code&gt; in its standard library: a generic &lt;a href=&quot;../std/result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; as well as specific versions for submodules, such as &lt;code&gt;io::Result&lt;/code&gt;.</source>
          <target state="translated">앞에서 언급했듯이 &lt;code&gt;read_line&lt;/code&gt; 은 사용자가 입력 한 내용을 전달하는 문자열에 넣지 만 값 (이 경우 &lt;a href=&quot;../std/io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; 반환합니다 . 녹 명명 된 유형의 수 있습니다 &lt;code&gt;Result&lt;/code&gt; 일반 : 표준 라이브러리의 &lt;a href=&quot;../std/result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 뿐만 아니라 다음과 같은 하위 모듈에 대한 특정 버전, &lt;code&gt;io::Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f7435a393907a8b1c4a2fc1b69a43772076a5c5" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, because very little of how Rust handles concurrency is part of the language, many concurrency solutions are implemented as crates. These evolve more quickly than the standard library, so be sure to search online for the current, state-of-the-art crates to use in multithreaded situations.</source>
          <target state="translated">앞에서 언급했듯이 Rust가 동시성을 처리하는 방법은 거의 없기 때문에 많은 동시성 솔루션이 상자로 구현됩니다. 이들은 표준 라이브러리보다 더 빠르게 발전하므로 멀티 스레드 상황에서 사용할 최신의 최신 상자를 온라인으로 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="a6f8e14141b394aeafb54cb0af5563e56c04e70c" translate="yes" xml:space="preserve">
          <source>As mentioned in Chapter 2, by default variables are immutable. This is one of many nudges Rust gives you to write your code in a way that takes advantage of the safety and easy concurrency that Rust offers. However, you still have the option to make your variables mutable. Let&amp;rsquo;s explore how and why Rust encourages you to favor immutability and why sometimes you might want to opt out.</source>
          <target state="translated">2 장에서 언급했듯이 기본적으로 변수는 변경할 수 없습니다. 이것은 Rust가 제공하는 안전하고 쉬운 동시성을 활용하는 방식으로 코드를 작성하기 위해 Rust가 제공하는 많은 넛지 중 하나입니다. 그러나 변수를 변경할 수있는 옵션이 여전히 있습니다. Rust가 불변성을 선호하는 방법과 이유, 왜 선택하지 않는지를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7641c8a38df92f9203220e805ba01b7f30732a0c" translate="yes" xml:space="preserve">
          <source>As mentioned in the module documentation, threads are usually made to communicate using &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channels&lt;/code&gt;&lt;/a&gt;, here is how it usually looks.</source>
          <target state="translated">모듈 문서에서 언급했듯이 스레드는 일반적으로 &lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channels&lt;/code&gt; &lt;/a&gt; 사용하여 통신하기 위해 만들어집니다 .</target>
        </trans-unit>
        <trans-unit id="fad7d9a9d62e3d2756844c471849a76502954355" translate="yes" xml:space="preserve">
          <source>As non-Rust calling conventions do not support unwinding, unwinding past the end of an extern function will cause the process to abort. In LLVM, this is implemented by executing an illegal instruction.</source>
          <target state="translated">비 녹음 호출 규칙은 해제를 지원하지 않으므로 extern 함수 끝을 지나서 해제하면 프로세스가 중단됩니다. LLVM에서는 잘못된 명령을 실행하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="10482a83c62e485259adbe51b49060ecef064cde" translate="yes" xml:space="preserve">
          <source>As noted above, coercions mean that most code doesn't have to be concerned with this distinction. However, you can tell the difference when using &lt;strong&gt;transmute&lt;/strong&gt; to convert a fn item into a fn pointer.</source>
          <target state="translated">위에서 언급했듯이 강제는 대부분의 코드가이 구별에 관심을 가질 필요가 없음을 의미합니다. 그러나 &lt;strong&gt;변환식&lt;/strong&gt; 을 사용하여 fn 항목을 fn 포인터로 변환 할 때 차이점을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5cb1839eab079676f60d9f52ac6387e18acb792" translate="yes" xml:space="preserve">
          <source>As noted in the documentation for the type itself, it is essentially an opaque ID, but is guaranteed to be unique for each thread. The returned value is entirely opaque -- only equality testing is stable. Note that it is not guaranteed which values new threads will return, and this may change across Rust versions.</source>
          <target state="translated">유형 자체에 대한 문서에서 언급했듯이 본질적으로 불투명 한 ID이지만 각 스레드에 대해 고유하다는 것이 보장됩니다. 반환 된 값은 완전히 불투명하며 동등성 테스트 만 안정적입니다. 새 스레드가 어떤 값을 반환할지 보장 할 수 없으며 이는 Rust 버전에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7018b1edbbce45316477bb25e1ffd907f9a0adb" translate="yes" xml:space="preserve">
          <source>As one would expect, primitive types like &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt; are all &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, and so are simple aggregate types containing them, like tuples, structs and enums. More examples of basic &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; types include &quot;immutable&quot; types like &lt;code&gt;&amp;amp;T&lt;/code&gt;, and those with simple inherited mutability, such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and most other collection types. (Generic parameters need to be &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; for their container to be &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">예상대로 &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt; 와 같은 기본 유형 은 모두 &lt;a href=&quot;trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 이며 튜플, 구조체 및 열거 형과 같이이를 포함하는 간단한 집계 유형도 마찬가지입니다. 기본 &lt;a href=&quot;trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 유형 의 더 많은 예 에는 &lt;code&gt;&amp;amp;T&lt;/code&gt; 와 같은 &quot;불변&quot;유형과 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 대부분의 다른 컬렉션 유형 과 같이 단순 상속 된 변경 가능성이있는 유형이 포함됩니다. ( 컨테이너 가 &lt;a href=&quot;trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 가 되려면 일반 매개 변수가 Sync 여야 &lt;a href=&quot;trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="78cffef75c7264e29f3831c1d70df7b7db90b085" translate="yes" xml:space="preserve">
          <source>As one would expect, primitive types like &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt; are all &lt;code&gt;Sync&lt;/code&gt;, and so are simple aggregate types containing them, like tuples, structs and enums. More examples of basic &lt;code&gt;Sync&lt;/code&gt; types include &quot;immutable&quot; types like &lt;code&gt;&amp;amp;T&lt;/code&gt;, and those with simple inherited mutability, such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and most other collection types. (Generic parameters need to be &lt;code&gt;Sync&lt;/code&gt; for their container to be &lt;code&gt;Sync&lt;/code&gt;.)</source>
          <target state="translated">예상대로 &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt; 와 같은 기본 유형 은 모두 &lt;code&gt;Sync&lt;/code&gt; 이므로 튜플, 구조체 및 열거 형과 같은 유형을 포함하는 간단한 집계 유형입니다. 기본 &lt;code&gt;Sync&lt;/code&gt; 유형 의 더 많은 예 에는 &lt;code&gt;&amp;amp;T&lt;/code&gt; 와 같은 &quot;불변&quot;유형과 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 대부분의 다른 콜렉션 유형 과 같이 단순하게 상속 된 변경이 가능한 유형이 있습니다. 컨테이너 가 &lt;code&gt;Sync&lt;/code&gt; 가되도록하려면 일반 매개 변수가 Sync 이어야 &lt;code&gt;Sync&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3262fa97dd64c6174eeff7f6dc1bf92e0938ab9" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;https://tools.ietf.org/html/rfc3879&quot;&gt;RFC 3879&lt;/a&gt;, the whole &lt;code&gt;FEC0::/10&lt;/code&gt; prefix is deprecated. New software must not support site-local addresses.</source>
          <target state="translated">당으로 &lt;a href=&quot;https://tools.ietf.org/html/rfc3879&quot;&gt;RFC 3879&lt;/a&gt; , 전체 &lt;code&gt;FEC0::/10&lt;/code&gt; 접두사는 사용되지 않습니다. 새 소프트웨어는 사이트 로컬 주소를 지원하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a8a04accdf6a8ca9fa81bf61cc029868f206046f" translate="yes" xml:space="preserve">
          <source>As said above, the &lt;code&gt;derive&lt;/code&gt; attribute is only allowed on structs, unions or enums:</source>
          <target state="translated">위에서 언급했듯이 &lt;code&gt;derive&lt;/code&gt; 속성은 구조체, 공용체 또는 열거 형에서만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="51aa8d67495f62b66ef894735fcf63e6606dac28" translate="yes" xml:space="preserve">
          <source>As shown in the example above, &lt;code&gt;for&lt;/code&gt; loops (along with all other loops) can be tagged, using similar syntax to lifetimes (only visually similar, entirely distinct in practice). Giving the same tag to &lt;code&gt;break&lt;/code&gt; breaks the tagged loop, which is useful for inner loops. It is definitely not a goto.</source>
          <target state="translated">위의 예에서 볼 수 있듯이 &lt;code&gt;for&lt;/code&gt; 루프 (다른 모든 루프와 함께)는 수명과 유사한 구문을 사용하여 태그를 지정할 수 있습니다 (시각적으로는 시각적으로 유사하며 실제로는 완전히 다릅니다). 동일한 태그를 &lt;code&gt;break&lt;/code&gt; 태그가 지정된 루프 가 끊어 지므로 내부 루프에 유용합니다. 확실히 goto가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ea3901788f56444df8cfba46d8496b7c3ef215ae" translate="yes" xml:space="preserve">
          <source>As slices store the length of the sequence they refer to, they have twice the size of pointers to &lt;a href=&quot;marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; types. Also see the reference on &lt;a href=&quot;../reference/dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt;.</source>
          <target state="translated">슬라이스는 참조하는 시퀀스의 길이를 저장하므로 &lt;a href=&quot;marker/trait.sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt; 유형 에 대한 포인터 크기의 두 배를 갖습니다 . &lt;a href=&quot;../reference/dynamically-sized-types&quot;&gt;동적 크기 유형&lt;/a&gt; 에 대한 참조도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c276f971f322ddf36b0d0a39caeff0e860e6ee88" translate="yes" xml:space="preserve">
          <source>As stated in the User Datagram Protocol's specification in &lt;a href=&quot;https://tools.ietf.org/html/rfc768&quot;&gt;IETF RFC 768&lt;/a&gt;, UDP is an unordered, unreliable protocol; refer to &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; for TCP primitives.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc768&quot;&gt;IETF RFC 768&lt;/a&gt; 의 사용자 데이터 그램 프로토콜 사양에 명시된 바와 같이 UDP는 순서가없고 신뢰할 수없는 프로토콜입니다. TCP 프리미티브에 대해서는 &lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5379cc453111a9586b0e6132f3432e2017bb8946" translate="yes" xml:space="preserve">
          <source>As string slices are a slice of bytes, the raw pointer points to a &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;. This pointer will be pointing to the first byte of the string slice.</source>
          <target state="translated">문자열 조각은 바이트 조각이므로 원시 포인터는 &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; 을&lt;/a&gt; 가리 킵니다 . 이 포인터는 문자열 슬라이스의 첫 번째 바이트를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="54d4fd727ce2657161522c6ae3a06633673c9cbd" translate="yes" xml:space="preserve">
          <source>As string slices are a slice of bytes, the raw pointer points to a &lt;a href=&quot;primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;. This pointer will be pointing to the first byte of the string slice.</source>
          <target state="translated">문자열 슬라이스가 바이트 슬라이스이므로 원시 포인터는 &lt;a href=&quot;primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; 을&lt;/a&gt; 가리 킵니다 . 이 포인터는 문자열 슬라이스의 첫 번째 바이트를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="b757bf93c530db10fdab40d9aeca4c3f17d50ad1" translate="yes" xml:space="preserve">
          <source>As such, the &lt;code&gt;from_utf8&lt;/code&gt; family of functions and methods for both &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s and &lt;a href=&quot;fn.from_utf8&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s make use of this error, for example.</source>
          <target state="translated">따라서 &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fn.from_utf8&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 대한 &lt;code&gt;from_utf8&lt;/code&gt; 함수 및 메소드 계열은 예를 들어이 오류를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a7bae3aa148344b33c64086da16dba6a42474602" translate="yes" xml:space="preserve">
          <source>As the author of a data structure you get to decide for each field whether pinning &quot;propagates&quot; to this field or not. Pinning that propagates is also called &quot;structural&quot;, because it follows the structure of the type. In the following subsections, we describe the considerations that have to be made for either choice.</source>
          <target state="translated">데이터 구조의 작성자는 각 필드에 대해 고정이이 필드에 &quot;전파&quot;되는지 여부를 결정하게됩니다. 전파되는 고정은 유형의 구조를 따르기 때문에 &quot;구조적&quot;이라고도합니다. 다음 하위 섹션에서는 두 가지 선택을 위해 고려해야 할 사항에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0b86e5cf0a558c007bb8a3eed83a07619a169108" translate="yes" xml:space="preserve">
          <source>As the error message indicates, only &lt;code&gt;u8&lt;/code&gt; can be cast into &lt;code&gt;char&lt;/code&gt;. Example:</source>
          <target state="translated">오류 메시지에서 알 수 있듯이 &lt;code&gt;u8&lt;/code&gt; 만 &lt;code&gt;char&lt;/code&gt; 로 캐스트 할 수 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="6c037f01ab1e44c1b49068f96530e00f210988e8" translate="yes" xml:space="preserve">
          <source>As the target platform's native endianness is used, portable code likely wants to use &lt;a href=&quot;#method.from_be_bytes&quot;&gt;&lt;code&gt;from_be_bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.from_le_bytes&quot;&gt;&lt;code&gt;from_le_bytes&lt;/code&gt;&lt;/a&gt;, as appropriate instead.</source>
          <target state="translated">대상 플랫폼의 고유 엔디안이 사용됨에 따라 이식 가능한 코드는 대신 &lt;a href=&quot;#method.from_be_bytes&quot;&gt; &lt;code&gt;from_be_bytes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#method.from_le_bytes&quot;&gt; &lt;code&gt;from_le_bytes&lt;/code&gt; &lt;/a&gt; 를 사용 하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="1c8bfefec8dafcbb055c2ea433ad31a56feecccd" translate="yes" xml:space="preserve">
          <source>As the target platform's native endianness is used, portable code should use &lt;a href=&quot;#method.to_be_bytes&quot;&gt;&lt;code&gt;to_be_bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.to_le_bytes&quot;&gt;&lt;code&gt;to_le_bytes&lt;/code&gt;&lt;/a&gt;, as appropriate, instead.</source>
          <target state="translated">대상 플랫폼의 고유 엔디안이 사용되므로 이식 가능한 코드는 대신 &lt;a href=&quot;#method.to_be_bytes&quot;&gt; &lt;code&gt;to_be_bytes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#method.to_le_bytes&quot;&gt; &lt;code&gt;to_le_bytes&lt;/code&gt; 를&lt;/a&gt; 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c2aae14d23e6b4a7f032b38d8e95a4d1b336b019" translate="yes" xml:space="preserve">
          <source>As this is the only method for this trait, the &lt;a href=&quot;trait.extend&quot;&gt;trait-level&lt;/a&gt; docs contain more details.</source>
          <target state="translated">이것이이 특성에 대한 유일한 방법이므로 &lt;a href=&quot;trait.extend&quot;&gt;특성 수준&lt;/a&gt; 문서에는 자세한 내용이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b3bf99d81b548977e24e38bef4df0cf86423b5b" translate="yes" xml:space="preserve">
          <source>As this is the only required method for this trait, the &lt;a href=&quot;trait.extend&quot;&gt;trait-level&lt;/a&gt; docs contain more details.</source>
          <target state="translated">이것이이 특성에 필요한 유일한 방법이므로 &lt;a href=&quot;trait.extend&quot;&gt;특성 수준&lt;/a&gt; 문서에 자세한 내용이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f292830332806677ad0b0527bf74ceadc350e53c" translate="yes" xml:space="preserve">
          <source>As usual, this output tells us exactly what has gone wrong.</source>
          <target state="translated">평소와 같이,이 결과는 무엇이 잘못되었는지 정확하게 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="6d6b5c58bde3c21428520a679924eb54e0901d4d" translate="yes" xml:space="preserve">
          <source>As we did with structs, we can define enums to hold generic data types in their variants. Let&amp;rsquo;s take another look at the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum that the standard library provides, which we used in Chapter 6:</source>
          <target state="translated">구조체와 마찬가지로 일반적인 데이터 형식을 변형으로 보유하도록 열거 형을 정의 할 수 있습니다. 6 장에서 사용한 표준 라이브러리가 제공 하는 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 열거 형에 대해 다시 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="c9b62e53d822366f9040eaf9632aa096cd8d407c" translate="yes" xml:space="preserve">
          <source>As we saw when we printed the vector, the program&amp;rsquo;s name takes up the first value in the vector at &lt;code&gt;args[0]&lt;/code&gt;, so we&amp;rsquo;re starting at index &lt;code&gt;1&lt;/code&gt;. The first argument &lt;code&gt;minigrep&lt;/code&gt; takes is the string we&amp;rsquo;re searching for, so we put a reference to the first argument in the variable &lt;code&gt;query&lt;/code&gt;. The second argument will be the filename, so we put a reference to the second argument in the variable &lt;code&gt;filename&lt;/code&gt;.</source>
          <target state="translated">벡터를 인쇄 할 때 보았 듯이 프로그램 이름은 &lt;code&gt;args[0]&lt;/code&gt; 의 벡터에서 첫 번째 값을 차지 하므로 인덱스 &lt;code&gt;1&lt;/code&gt; 에서 시작 합니다. &lt;code&gt;minigrep&lt;/code&gt; 이받는 첫 번째 인수 는 검색하는 문자열이므로 변수 &lt;code&gt;query&lt;/code&gt; 의 첫 번째 인수에 대한 참조를 넣습니다 . 두 번째 인수는 파일 이름이되므로 변수 &lt;code&gt;filename&lt;/code&gt; 에 두 번째 인수에 대한 참조를 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="387526bcd86a3d932ce8d276666fe3de9ea36fb2" translate="yes" xml:space="preserve">
          <source>As well as overloading the unary &lt;code&gt;*&lt;/code&gt; operator, &lt;a href=&quot;../std/ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; are also used in &lt;a href=&quot;expressions/method-call-expr&quot;&gt;method resolution&lt;/a&gt; and &lt;a href=&quot;type-coercions#coercion-types&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="translated">단항 &lt;code&gt;*&lt;/code&gt; 연산자에 과부하가 걸리는 것 &lt;a href=&quot;../std/ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../std/ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;expressions/method-call-expr&quot;&gt;메소드 해석&lt;/a&gt; 및 &lt;a href=&quot;type-coercions#coercion-types&quot;&gt;deref 강제&lt;/a&gt; 에도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="00f0078e7027bdd5fb06a3cdb9f947f1a54e08c1" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#method.as_ref&quot;&gt;&lt;code&gt;as_ref&lt;/code&gt;&lt;/a&gt;, this is unsafe because it cannot verify the validity of the returned pointer, nor can it ensure that the lifetime &lt;code&gt;'a&lt;/code&gt; returned is indeed a valid lifetime for the contained data.</source>
          <target state="translated">와 마찬가지로 &lt;a href=&quot;#method.as_ref&quot;&gt; &lt;code&gt;as_ref&lt;/code&gt; &lt;/a&gt; 가 반환 된 포인터의 유효성을 검증 할 수 없으며이 수명 보장 할 수 있기 때문에, 이것은 안전하지 않은 &lt;code&gt;'a&lt;/code&gt; 반환이 실제로 포함 된 데이터의 유효 수명이다.</target>
        </trans-unit>
        <trans-unit id="700b249dcaa7ad65d8fbe7b2f99bd14fed03c63b" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;MaybeUninit::assume_init&lt;/code&gt;&lt;/a&gt;, it is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</source>
          <target state="translated">&lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;MaybeUninit::assume_init&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 내부 값이 실제로 초기화 된 상태인지 확인하는 것은 호출자에게 달려 있습니다. 콘텐츠가 아직 완전히 초기화되지 않은 경우이를 호출하면 즉시 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b569f01826b7a489e1b0df46d3df2feea0987b31" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;MaybeUninit::assume_init&lt;/code&gt;&lt;/a&gt;, it is up to the caller to guarantee that the value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</source>
          <target state="translated">&lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;MaybeUninit::assume_init&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 값이 실제로 초기화 된 상태인지 확인하는 것은 호출자에게 달려 있습니다. 콘텐츠가 아직 완전히 초기화되지 않은 경우이를 호출하면 즉시 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b5a160954fc2e5db9027a60b41aea2242946a496" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;MaybeUninit::assume_init&lt;/code&gt;&lt;/a&gt;, it is up to the caller to guarantee that the values really are in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</source>
          <target state="translated">&lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;MaybeUninit::assume_init&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 값이 실제로 초기화 된 상태인지 확인하는 것은 호출자에게 달려 있습니다. 콘텐츠가 아직 완전히 초기화되지 않은 경우이를 호출하면 즉시 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e824f1a2f05ba862631703f190681d4c2dd2b70b" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;use-declarations#underscore-imports&quot;&gt;underscore imports&lt;/a&gt;, macros may safely emit the same unnamed constant in the same scope more than once. For example, the following should not produce an error:</source>
          <target state="translated">&lt;a href=&quot;use-declarations#underscore-imports&quot;&gt;밑줄 가져 오기&lt;/a&gt; 와 마찬가지로 매크로는 동일한 범위에서 동일한 명명되지 않은 상수를 두 번 이상 안전하게 방출 할 수 있습니다. 예를 들어, 다음은 오류가 발생하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="4c083e9f314596dd1da24d21de9af221cdf99253" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;let&lt;/code&gt; bindings, function arguments are irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt;, so any pattern that is valid in a let binding is also valid as an argument:</source>
          <target state="translated">와 같은 &lt;code&gt;let&lt;/code&gt; 바인딩 함수 인수는 반박 할 수없는 &lt;a href=&quot;../patterns&quot;&gt;패턴&lt;/a&gt; 이므로 let 바인딩에 유효한 모든 패턴도 인수로 유효합니다.</target>
        </trans-unit>
        <trans-unit id="021860f0b9c701b01e24f471ef9064ff787c7fc6" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;split()&lt;/code&gt;, if the first or last element is matched, an empty slice will be the first (or last) item returned by the iterator.</source>
          <target state="translated">&lt;code&gt;split()&lt;/code&gt; 과 마찬가지로 첫 번째 또는 마지막 요소가 일치하면 빈 슬라이스는 반복자가 반환 한 첫 번째 (또는 마지막) 항목이됩니다.</target>
        </trans-unit>
        <trans-unit id="a311c5a68716dfa8ec04c201fd72e1f6bf20977d" translate="yes" xml:space="preserve">
          <source>As with any variable, if we want to be able to change its value, we need to make it mutable using the &lt;code&gt;mut&lt;/code&gt; keyword, as discussed in Chapter 3. The numbers we place inside are all of type &lt;code&gt;i32&lt;/code&gt;, and Rust infers this from the data, so we don&amp;rsquo;t need the &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; annotation.</source>
          <target state="translated">변수와 마찬가지로 값을 변경하려면 3 장에서 설명한대로 &lt;code&gt;mut&lt;/code&gt; 키워드를 사용하여 변수를 변경 가능하게 만들어야합니다. &lt;code&gt;i32&lt;/code&gt; 이며 Rust는 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 주석이 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4275e8a23f25e311b7879f2ca06bcf06be2ae3c3" translate="yes" xml:space="preserve">
          <source>As with many types, we create a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; using the associated function &lt;code&gt;new&lt;/code&gt;. To access the data inside the mutex, we use the &lt;code&gt;lock&lt;/code&gt; method to acquire the lock. This call will block the current thread so it can&amp;rsquo;t do any work until it&amp;rsquo;s our turn to have the lock.</source>
          <target state="translated">많은 종류와 마찬가지로, 우리는 만들 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 관련 기능을 사용하여 &lt;code&gt;new&lt;/code&gt; . 뮤텍스 내부의 데이터에 액세스하기 위해 &lt;code&gt;lock&lt;/code&gt; 메소드를 사용하여 잠금 을 획득합니다. 이 호출은 현재 스레드를 차단하므로 잠금을 설정해야 할 때까지 아무 작업도 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="35a5907e5dda02884b0d94275e42a50fca56e187" translate="yes" xml:space="preserve">
          <source>As with regular variables, we specify mutability using the &lt;code&gt;mut&lt;/code&gt; keyword. Any code that reads or writes from &lt;code&gt;COUNTER&lt;/code&gt; must be within an &lt;code&gt;unsafe&lt;/code&gt; block. This code compiles and prints &lt;code&gt;COUNTER: 3&lt;/code&gt; as we would expect because it&amp;rsquo;s single threaded. Having multiple threads access &lt;code&gt;COUNTER&lt;/code&gt; would likely result in data races.</source>
          <target state="translated">일반 변수와 마찬가지로 &lt;code&gt;mut&lt;/code&gt; 키워드를 사용하여 변경 가능성을 지정 합니다. &lt;code&gt;COUNTER&lt;/code&gt; 에서 읽거나 쓰는 코드 는 &lt;code&gt;unsafe&lt;/code&gt; 블록 내에 있어야합니다 . 이 코드는 &lt;code&gt;COUNTER: 3&lt;/code&gt; 컴파일하고 인쇄합니다 . 는 단일 스레드이기 때문에 을 . 여러 스레드가 &lt;code&gt;COUNTER&lt;/code&gt; 에 액세스 하면 데이터 경쟁이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3db9d1e08dae612689e0b7adf381cac76d2a83bc" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">와 마찬가지로 &lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; 의&lt;/a&gt; 형, &lt;code&gt;HashSet&lt;/code&gt; 의이 요소를 구현하도록 요구 &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 형질. 이는 &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 를 사용하여 자주 달성 할 수 있습니다 . 이를 직접 구현하는 경우 다음 속성이 유지되는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="1fb7b19ef9483e218deb8b0d1a3f5269874b86ed" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">와 마찬가지로 &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; 의&lt;/a&gt; 형, &lt;code&gt;HashSet&lt;/code&gt; 의이 요소를 구현하도록 요구&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 형질. &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 를 사용하여 자주 수행 할 수 있습니다. 이를 직접 구현하는 경우 다음 속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c568bda8aab01e836f5470185110a68fb4739aa1" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">와 마찬가지로 &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; 의&lt;/a&gt; 형, &lt;code&gt;HashSet&lt;/code&gt; 의이 요소를 구현하도록 요구&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 형질. &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 를 사용하여 자주 수행 할 수 있습니다. 이를 직접 구현하는 경우 다음 속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ae28ea4c57639b6218be246b12eabdfb50b7b74a" translate="yes" xml:space="preserve">
          <source>As with variables, we can add type annotations if we want to increase explicitness and clarity at the cost of being more verbose than is strictly necessary. Annotating the types for the closure we defined in Listing 13-5 would look like the definition shown in Listing 13-7.</source>
          <target state="translated">변수와 마찬가지로 엄격하게 필요한 것보다 더 장황한 비용으로 명시 성과 선명도를 높이려면 유형 주석을 추가 할 수 있습니다. Listing 13-5에서 정의한 클로저의 타입에 주석을 달면 Listing 13-7에 나온 정의와 같다.</target>
        </trans-unit>
        <trans-unit id="96c2069203f702eae6427926792a296cebb74618" translate="yes" xml:space="preserve">
          <source>As you add more integration tests, you might want to make more than one file in the &lt;em&gt;tests&lt;/em&gt; directory to help organize them; for example, you can group the test functions by the functionality they&amp;rsquo;re testing. As mentioned earlier, each file in the &lt;em&gt;tests&lt;/em&gt; directory is compiled as its own separate crate.</source>
          <target state="translated">더 많은 통합 테스트를 추가 할 때 &lt;em&gt;tests&lt;/em&gt; 디렉토리 에 둘 이상의 파일을 만들어 구성하는 데 도움이 될 수 있습니다. 예를 들어 테스트중인 기능별로 테스트 기능을 그룹화 할 수 있습니다. 앞에서 언급했듯이 &lt;em&gt;테스트의&lt;/em&gt; 각 파일&lt;em&gt;&lt;/em&gt; 디렉토리의 별도의 상자로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="064638b9138d50bf7a76d4f1fb8907e6d00d4af4" translate="yes" xml:space="preserve">
          <source>As you also learned in Chapter 1, &lt;code&gt;println!&lt;/code&gt; is a macro that prints a string to the screen:</source>
          <target state="translated">1 장에서도 배웠 듯이 &lt;code&gt;println!&lt;/code&gt; 화면에 문자열을 인쇄하는 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="cfbf1a7efc3caed67bc7e41bd453d7589ffb22d8" translate="yes" xml:space="preserve">
          <source>As you can see in the signature of &lt;code&gt;spawn&lt;/code&gt; there are two constraints on both the closure given to &lt;code&gt;spawn&lt;/code&gt; and its return value, let's explain them:</source>
          <target state="translated">당신의 서명에서 볼 수 있듯이 &lt;code&gt;spawn&lt;/code&gt; 에 주어진 폐쇄 양쪽에 두 제약이 있습니다 &lt;code&gt;spawn&lt;/code&gt; 및 반환 값은,의 그들을 설명 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0420fe0c9530d1e1d147961f14b139b3fe83e9e2" translate="yes" xml:space="preserve">
          <source>As you can see, the stable toolchain is the default. Most Rust users use stable most of the time. You might want to use stable most of the time, but use nightly on a specific project, because you care about a cutting-edge feature. To do so, you can use &lt;code&gt;rustup override&lt;/code&gt; in that project&amp;rsquo;s directory to set the nightly toolchain as the one &lt;code&gt;rustup&lt;/code&gt; should use when you&amp;rsquo;re in that directory:</source>
          <target state="translated">보시다시피 안정적인 툴체인이 기본값입니다. 대부분의 Rust 사용자는 대부분 안정적인 시간을 사용합니다. 최첨단 기능을 염두에두고 대부분의 시간을 안정적으로 사용하고 싶지만 특정 프로젝트에서 야간에 사용하는 것이 좋습니다. 그렇게하려면 &lt;code&gt;rustup override&lt;/code&gt; 해당 프로젝트 디렉토리에서 rustup override 를 하여 야간 툴체인을 하나의 &lt;code&gt;rustup&lt;/code&gt; 으로 설정할 수 있습니다. 사용하여 해당 디렉토리에있을 때 이 사용해야 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d87736b18e618ced4be36c042766a61a7024b14" translate="yes" xml:space="preserve">
          <source>As you can see, this will return the expected, valid items.</source>
          <target state="translated">보시다시피 예상 유효 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2afcd0df9449bfb1b32a67c779124a1b65363260" translate="yes" xml:space="preserve">
          <source>As you can see, using the parent modules distinguishes the two &lt;code&gt;Result&lt;/code&gt; types. If instead we specified &lt;code&gt;use std::fmt::Result&lt;/code&gt; and &lt;code&gt;use std::io::Result&lt;/code&gt;, we&amp;rsquo;d have two &lt;code&gt;Result&lt;/code&gt; types in the same scope and Rust wouldn&amp;rsquo;t know which one we meant when we used &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">보시다시피 부모 모듈을 사용하면 두 가지 &lt;code&gt;Result&lt;/code&gt; 유형이 구분 됩니다. 대신 &lt;code&gt;use std::fmt::Result&lt;/code&gt; 를 &lt;code&gt;use std::io::Result&lt;/code&gt; 하면 두 개가됩니다 &lt;code&gt;Result&lt;/code&gt; 하면 동일한 범위에 Result 유형이 있고 Rust는 &lt;code&gt;Result&lt;/code&gt; 를 사용할 때 어떤 결과 유형을 알지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="20722bacbfbb971e3e58847f05a0049adb3a009e" translate="yes" xml:space="preserve">
          <source>As you can see, we&amp;rsquo;ve moved everything into a loop from the guess input prompt onward. Be sure to indent the lines inside the loop another four spaces each and run the program again. Notice that there is a new problem because the program is doing exactly what we told it to do: ask for another guess forever! It doesn&amp;rsquo;t seem like the user can quit!</source>
          <target state="translated">보시다시피, 우리는 추측 입력 프롬프트에서 모든 것을 루프로 옮겼습니다. 루프 내부의 라인을 각각 다른 4 칸씩 들여 쓰기하고 프로그램을 다시 실행하십시오. 프로그램이 우리가 지시 한대로 정확하게 수행하고 있기 때문에 새로운 문제가 있음을 주목하십시오 : 또 다른 추측을 영원히 요청하십시오! 사용자가 종료 할 수없는 것 같습니다!</target>
        </trans-unit>
        <trans-unit id="ac1ee84193bb1d8e87992969494a2311a45eebb9" translate="yes" xml:space="preserve">
          <source>As you can see, you can specify type parameters in curly braces for substitution with the actual types (using the regular format string syntax) in a given situation. Furthermore, &lt;code&gt;{Self}&lt;/code&gt; will substitute to the type (in this case, &lt;code&gt;bool&lt;/code&gt;) that we tried to use.</source>
          <target state="translated">보시다시피, 주어진 상황에서 실제 형식으로 대체하기 위해 중괄호로 형식 매개 변수를 지정할 수 있습니다 (일반 형식 문자열 구문 사용). 또한 &lt;code&gt;{Self}&lt;/code&gt; 는 유형을 대신합니다 (이 경우 &lt;code&gt;bool&lt;/code&gt; 사용하려고 시도한 bool )을 합니다.</target>
        </trans-unit>
        <trans-unit id="b2e9ae4479b0983efbf6a5f5ed8ba7b27ba6777d" translate="yes" xml:space="preserve">
          <source>As you could see, in many aspects (except for layouts, safety and ownership) unions behave exactly like structs, largely as a consequence of inheriting their syntactic shape from structs. This is also true for many unmentioned aspects of Rust language (such as privacy, name resolution, type inference, generics, trait implementations, inherent implementations, coherence, pattern checking, etc etc etc).</source>
          <target state="translated">보시다시피, 많은 측면에서 (레이아웃, 안전 및 소유권 제외) 노조는 구조체에서 구문 형태를 상속 한 결과 구조체와 똑같이 동작합니다. 이는 Rust 언어의 언급되지 않은 많은 측면 (예 : 프라이버시, 이름 확인, 형식 유추, 제네릭, 특성 구현, 고유 구현, 일관성, 패턴 확인 등)에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="82fa816a0b7088673d7a49e7db89040e62362916" translate="yes" xml:space="preserve">
          <source>As you could see, in many aspects (except for layouts, safety, and ownership) unions behave exactly like structs, largely as a consequence of inheriting their syntactic shape from structs. This is also true for many unmentioned aspects of Rust language (such as privacy, name resolution, type inference, generics, trait implementations, inherent implementations, coherence, pattern checking, etc etc etc).</source>
          <target state="translated">보시다시피, 많은 측면에서 (레이아웃, 안전성 및 소유권 제외) 공용체는 구조체에서 구문 모양을 상속 한 결과 구조체와 똑같이 작동합니다. 이것은 또한 Rust 언어의 언급되지 않은 여러 측면 (프라이버시, 이름 확인, 유형 추론, 제네릭, 특성 구현, 고유 구현, 일관성, 패턴 검사 등)에도 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="b701fb6519447ef85d48d0e79a042ed086034a11" translate="yes" xml:space="preserve">
          <source>As you learned in Chapter 16, &lt;code&gt;thread::spawn&lt;/code&gt; will create a new thread and then run the code in the closure in the new thread. If you run this code and load &lt;em&gt;/sleep&lt;/em&gt; in your browser, then &lt;em&gt;/&lt;/em&gt; in two more browser tabs, you&amp;rsquo;ll indeed see that the requests to &lt;em&gt;/&lt;/em&gt; don&amp;rsquo;t have to wait for &lt;em&gt;/sleep&lt;/em&gt; to finish. But as we mentioned, this will eventually overwhelm the system because you&amp;rsquo;d be making new threads without any limit.</source>
          <target state="translated">16 장에서 배운 것처럼 &lt;code&gt;thread::spawn&lt;/code&gt; 은 새 스레드를 생성 한 다음 새 스레드의 클로저에서 코드를 실행합니다. 이 코드 및로드 실행하면 &lt;em&gt;/ 절전&lt;/em&gt; 브라우저에서를 다음 &lt;em&gt;/&lt;/em&gt; 두 개 더 브라우저 탭, 당신은 참으로 요청 것을 볼 수 있습니다 &lt;em&gt;/이&lt;/em&gt; 기다릴 필요가 없습니다&lt;em&gt; / 절전&lt;/em&gt; 마무리. 그러나 우리가 언급했듯이, 제한없이 새로운 스레드를 만들 수 있기 때문에 결국 시스템을 압도합니다.</target>
        </trans-unit>
        <trans-unit id="f4d2e2ae7d1d7339cbe38cf89981448ff9804651" translate="yes" xml:space="preserve">
          <source>As you might have guessed, &lt;code&gt;continue&lt;/code&gt; has a &lt;code&gt;!&lt;/code&gt; value. That is, when Rust computes the type of &lt;code&gt;guess&lt;/code&gt;, it looks at both match arms, the former with a value of &lt;code&gt;u32&lt;/code&gt; and the latter with a &lt;code&gt;!&lt;/code&gt; value. Because &lt;code&gt;!&lt;/code&gt; can never have a value, Rust decides that the type of &lt;code&gt;guess&lt;/code&gt; is &lt;code&gt;u32&lt;/code&gt;.</source>
          <target state="translated">당신이 짐작할 수 있듯이 &lt;code&gt;continue&lt;/code&gt; 하십시오 &lt;code&gt;!&lt;/code&gt; 값. 즉, Rust가 &lt;code&gt;guess&lt;/code&gt; 유형을 계산할 때 일치 팔은 &lt;code&gt;u32&lt;/code&gt; 값이고 다른 하나는 &lt;code&gt;!&lt;/code&gt; 값. 왜냐하면 &lt;code&gt;!&lt;/code&gt; Rust는 &lt;code&gt;guess&lt;/code&gt; 의 유형 이 &lt;code&gt;u32&lt;/code&gt; 라고 결정합니다. .</target>
        </trans-unit>
        <trans-unit id="467cfe4dd8e4d010791398ae5c6bd0fbee6d53ca" translate="yes" xml:space="preserve">
          <source>As you might suspect, &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; is a smart pointer. More accurately, the call to &lt;code&gt;lock&lt;/code&gt;&lt;em&gt;returns&lt;/em&gt; a smart pointer called &lt;code&gt;MutexGuard&lt;/code&gt;, wrapped in a &lt;code&gt;LockResult&lt;/code&gt; that we handled with the call to &lt;code&gt;unwrap&lt;/code&gt;. The &lt;code&gt;MutexGuard&lt;/code&gt; smart pointer implements &lt;code&gt;Deref&lt;/code&gt; to point at our inner data; the smart pointer also has a &lt;code&gt;Drop&lt;/code&gt; implementation that releases the lock automatically when a &lt;code&gt;MutexGuard&lt;/code&gt; goes out of scope, which happens at the end of the inner scope in Listing 16-12. As a result, we don&amp;rsquo;t risk forgetting to release the lock and blocking the mutex from being used by other threads because the lock release happens automatically.</source>
          <target state="translated">의심 할 수 있듯이 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 는 스마트 포인터입니다. 더 정확하게, 호출 &lt;code&gt;lock&lt;/code&gt; &lt;em&gt;반환&lt;/em&gt; 라는 스마트 포인터 &lt;code&gt;MutexGuard&lt;/code&gt; A의 포장, &lt;code&gt;LockResult&lt;/code&gt; 우리를 호출하여 처리하는 것을 &lt;code&gt;unwrap&lt;/code&gt; . &lt;code&gt;MutexGuard&lt;/code&gt; 스마트 포인터 구현 &lt;code&gt;Deref&lt;/code&gt; 우리의 내면 데이터에서 포인트; 스마트 포인터에는 또한 범위를 벗어날 때 자동으로 잠금을 해제 하는 &lt;code&gt;Drop&lt;/code&gt; 구현이 있습니다. &lt;code&gt;MutexGuard&lt;/code&gt; 가이는 목록 16-12의 내부 범위 끝에서 발생합니다. 결과적으로 잠금 해제가 자동으로 이루어지기 때문에 잠금 해제를 잊어 버리고 뮤텍스가 다른 스레드에서 사용되는 것을 차단할 위험이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e4e495363e711b35cf1aef444d4c023b03ec561b" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 1, &lt;code&gt;cargo new&lt;/code&gt; generates a &amp;ldquo;Hello, world!&amp;rdquo; program for you. Check out the &lt;em&gt;src/main.rs&lt;/em&gt; file:</source>
          <target state="translated">1 장에서 보았 듯이 &lt;code&gt;cargo new&lt;/code&gt; 는 &quot;Hello, world!&quot;를 생성합니다. 당신을 위해 프로그램. &lt;em&gt;src / main.rs&lt;/em&gt; 파일을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="acce671b7472bf5e5eaabe31a3ccfe6aca667c9d" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 1, the &lt;code&gt;main&lt;/code&gt; function is the entry point into the program:</source>
          <target state="translated">1 장에서 보았 듯이 &lt;code&gt;main&lt;/code&gt; 기능은 프로그램의 진입 점입니다.</target>
        </trans-unit>
        <trans-unit id="1b995f5c38439d41d9506c07ed8d2188c4fc0f99" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 6, you can match patterns against literals directly. The following code gives some examples:</source>
          <target state="translated">6 장에서 보았 듯이 패턴을 리터럴과 직접 일치시킬 수 있습니다. 다음 코드는 몇 가지 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fa0b472a10784179b99aa6fee609e3cfddb9cc55" translate="yes" xml:space="preserve">
          <source>As you saw in Listing 17-15, we can write methods that use the syntax &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;, which allows the method to take ownership of a &lt;code&gt;Self&lt;/code&gt; value stored in a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. That&amp;rsquo;s exactly what we want to do here, but unfortunately Rust won&amp;rsquo;t let us: the part of Rust that implements behavior when a closure is called isn&amp;rsquo;t implemented using &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;. So Rust doesn&amp;rsquo;t yet understand that it could use &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; in this situation to take ownership of the closure and move the closure out of the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Listing 17-15에서 보듯이 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 구문을 사용하는 메소드를 작성할 수있다 . 이를 통해 메소드 는 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 저장된 &lt;code&gt;Self&lt;/code&gt; 값의 소유권을 가질 수있다 . 이것이 바로 우리가 여기서하고 싶은 일이지만 불행히도 Rust는 우리를 허락하지 않을 것입니다. 클로저가 호출 될 때 동작을 구현하는 Rust의 일부는 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 사용하여 구현되지 않습니다 . 따라서 Rust는 이 상황에서 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 를 사용하여 클로저의 소유권을 가져와 클로저를 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 밖으로 옮길 수 있다는 것을 아직 이해하지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="5d8ebbcc7fc2cf4e602d0e1985852befad2da85e" translate="yes" xml:space="preserve">
          <source>As you saw in the guessing game tutorial in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt; section in Chapter 2, you can declare a new variable with the same name as a previous variable, and the new variable shadows the previous variable. Rustaceans say that the first variable is &lt;em&gt;shadowed&lt;/em&gt; by the second, which means that the second variable&amp;rsquo;s value is what appears when the variable is used. We can shadow a variable by using the same variable&amp;rsquo;s name and repeating the use of the &lt;code&gt;let&lt;/code&gt; keyword as follows:</source>
          <target state="translated">2 장의 &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&quot;비밀번호에 맞춰 추측하기&quot;&lt;/a&gt; 섹션 의 추측 게임 튜토리얼에서 보았 듯이 이전 변수와 동일한 이름을 가진 새 변수를 선언하고 새 변수는 이전 변수를 가리게 할 수 있습니다. Rustaceans는 첫 번째 변수가 두 번째 변수에 의해 &lt;em&gt;음영 처리&lt;/em&gt; 된다고 말하는데 , 이는 두 번째 변수의 값이 변수가 사용될 때 나타나는 값임을 의미합니다. 동일한 변수 이름을 사용 하고 다음과 같이 &lt;code&gt;let&lt;/code&gt; 키워드 사용을 반복하여 변수를 음영 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="c47b398566173be1e06632198f7039025f10ae00" translate="yes" xml:space="preserve">
          <source>As you write large programs, organizing your code will be important because keeping track of your entire program in your head will become impossible. By grouping related functionality and separating code with distinct features, you&amp;rsquo;ll clarify where to find code that implements a particular feature and where to go to change how a feature works.</source>
          <target state="translated">큰 프로그램을 작성할 때는 전체 프로그램을 추적하는 것이 불가능하기 때문에 코드를 구성하는 것이 중요합니다. 관련 기능을 그룹화하고 고유 한 기능으로 코드를 분리하면 특정 기능을 구현하는 코드를 찾는 위치와 기능 작동 방식을 변경할 위치를 명확하게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a48835105e35976d30850d6478e3e8cb37ac0bc5" translate="yes" xml:space="preserve">
          <source>As your project grows, consider using a workspace: it&amp;rsquo;s easier to understand smaller, individual components than one big blob of code. Furthermore, keeping the crates in a workspace can make coordination between them easier if they are often changed at the same time.</source>
          <target state="translated">프로젝트가 성장함에 따라 작업 영역 사용을 고려하십시오. 하나의 큰 코드 덩어리보다 작은 개별 구성 요소를 이해하는 것이 더 쉽습니다. 또한, 상자를 작업 공간에 보관하면 종종 종종 변경되는 경우 더 쉽게 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db2e27ecee3ef7df382d73da5185cf2c81a313eb" translate="yes" xml:space="preserve">
          <source>AsMut</source>
          <target state="translated">AsMut</target>
        </trans-unit>
        <trans-unit id="9dee5144fa49d1023659054cfeb7b935d110f729" translate="yes" xml:space="preserve">
          <source>AsMut::as_mut</source>
          <target state="translated">AsMut::as_mut</target>
        </trans-unit>
        <trans-unit id="fa6cbff29c8fee2a75af18139d6ec5d8bb30e951" translate="yes" xml:space="preserve">
          <source>AsRawFd</source>
          <target state="translated">AsRawFd</target>
        </trans-unit>
        <trans-unit id="bf4b7b3bd11f76d54ac78e508bf69a1df97a73ab" translate="yes" xml:space="preserve">
          <source>AsRawHandle</source>
          <target state="translated">AsRawHandle</target>
        </trans-unit>
        <trans-unit id="bcb7263b347977861cfead462a0183ddbacb93a0" translate="yes" xml:space="preserve">
          <source>AsRawSocket</source>
          <target state="translated">AsRawSocket</target>
        </trans-unit>
        <trans-unit id="ecb4ad32c0bbcb0030bdba05dd0126fda307a2ef" translate="yes" xml:space="preserve">
          <source>AsRef</source>
          <target state="translated">AsRef</target>
        </trans-unit>
        <trans-unit id="ce713a708d26f349ef9d3da2c64c32c52ede1f28" translate="yes" xml:space="preserve">
          <source>AsRef::as_ref</source>
          <target state="translated">AsRef::as_ref</target>
        </trans-unit>
        <trans-unit id="a4ef661b82f652f581223b25a6824dec40ae544d" translate="yes" xml:space="preserve">
          <source>AsciiExt</source>
          <target state="translated">AsciiExt</target>
        </trans-unit>
        <trans-unit id="46e0dda46ad92722f1539fd012c3778f39c3b187" translate="yes" xml:space="preserve">
          <source>AsciiExt::eq_ignore_ascii_case</source>
          <target state="translated">AsciiExt::eq_ignore_ascii_case</target>
        </trans-unit>
        <trans-unit id="afaf433bc6efc0517fc1bdeb6f7c5eafce3e74d4" translate="yes" xml:space="preserve">
          <source>AsciiExt::is_ascii</source>
          <target state="translated">AsciiExt::is_ascii</target>
        </trans-unit>
        <trans-unit id="a117348e90cbeb6580ea282ea76b737d649c0ce2" translate="yes" xml:space="preserve">
          <source>AsciiExt::make_ascii_lowercase</source>
          <target state="translated">AsciiExt::make_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="014f8e9aa886e527dbae3bd8a29a0232814779eb" translate="yes" xml:space="preserve">
          <source>AsciiExt::make_ascii_uppercase</source>
          <target state="translated">AsciiExt::make_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="ac47518e69af0774bb76855d1ba4fd45ba076dbb" translate="yes" xml:space="preserve">
          <source>AsciiExt::to_ascii_lowercase</source>
          <target state="translated">AsciiExt::to_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="e04741744413a75fb42c855cb8f9068dc93b7a29" translate="yes" xml:space="preserve">
          <source>AsciiExt::to_ascii_uppercase</source>
          <target state="translated">AsciiExt::to_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="1b3c2291de90fba8268fb52f3659391950c3a127" translate="yes" xml:space="preserve">
          <source>Aside from the closing curly bracket, there&amp;rsquo;s only one more line to discuss in the code added so far, which is the following:</source>
          <target state="translated">닫는 중괄호를 제외하고 지금까지 추가 된 코드에서 논의 할 줄이 하나 더 있습니다. 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f99c599e0e3924b919cda05ade321af8f7909739" translate="yes" xml:space="preserve">
          <source>Aside from the closing curly brackets, there&amp;rsquo;s only one more line to discuss in the code added so far, which is the following:</source>
          <target state="translated">닫는 중괄호 외에도 지금까지 추가 된 코드에서 논의 할 줄이 하나 더 있습니다. 이는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ccfa1ea33000ed1fdc5e32d6d85a1f23b351c53c" translate="yes" xml:space="preserve">
          <source>Asked how long the string is, you might say 12. However, Rust&amp;rsquo;s answer is 24: that&amp;rsquo;s the number of bytes it takes to encode &amp;ldquo;Здравствуйте&amp;rdquo; in UTF-8, because each Unicode scalar value in that string takes 2 bytes of storage. Therefore, an index into the string&amp;rsquo;s bytes will not always correlate to a valid Unicode scalar value. To demonstrate, consider this invalid Rust code:</source>
          <target state="translated">문자열의 길이를 물으면 12라고 말할 수 있습니다. 그러나 Rust의 대답은 24입니다. 이는 문자열의 각 유니 코드 스칼라 값이 2 바이트의 저장 공간을 차지하기 때문에 UTF-8로 &quot;Здравствуйте&quot;를 인코딩하는 데 필요한 바이트 수입니다. 따라서 문자열 바이트에 대한 인덱스가 항상 유효한 유니 코드 스칼라 값과 상관되지는 않습니다. 시연하려면이 잘못된 녹 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e7689cb162bee3d282a7b39ef7b90263d73428fa" translate="yes" xml:space="preserve">
          <source>Assert the results are what you expect.</source>
          <target state="translated">결과가 당신이 기대하는 것이라고 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="14ec22b40bdfb6faadf461156fa13c1003c498f7" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe</source>
          <target state="translated">AssertUnwindSafe</target>
        </trans-unit>
        <trans-unit id="b22e5cc4bce8496592970be5b25d370d67581697" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::borrow</source>
          <target state="translated">AssertUnwindSafe::borrow</target>
        </trans-unit>
        <trans-unit id="e9b2629172195580950a107f4837fef269c6587e" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::borrow_mut</source>
          <target state="translated">AssertUnwindSafe::borrow_mut</target>
        </trans-unit>
        <trans-unit id="65951f8f36689c68821ae0439274d4a0186d7055" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::call_once</source>
          <target state="translated">AssertUnwindSafe::call_once</target>
        </trans-unit>
        <trans-unit id="846bd763b3f520ae6051ff0597c886f310c2c6ea" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::deref</source>
          <target state="translated">AssertUnwindSafe::deref</target>
        </trans-unit>
        <trans-unit id="0f7f2436811897e328934158a966a543668732f9" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::deref_mut</source>
          <target state="translated">AssertUnwindSafe::deref_mut</target>
        </trans-unit>
        <trans-unit id="df50057fe584f587876a9e064fa1ae0b0acfbda2" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::fmt</source>
          <target state="translated">AssertUnwindSafe::fmt</target>
        </trans-unit>
        <trans-unit id="d34a0fd3c126015a7f7ea1d7a1780f16da8c0c7f" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::from</source>
          <target state="translated">AssertUnwindSafe::from</target>
        </trans-unit>
        <trans-unit id="bc1f4df4473c05cd44c2d50adf3e2f9062513d4c" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::into</source>
          <target state="translated">AssertUnwindSafe::into</target>
        </trans-unit>
        <trans-unit id="3b850d0a322410d738f80adc8cf728ee8170ee1d" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::poll</source>
          <target state="translated">AssertUnwindSafe::poll</target>
        </trans-unit>
        <trans-unit id="daed5606c5d5daf7eeeb4806493948f969bf4f99" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::try_from</source>
          <target state="translated">AssertUnwindSafe::try_from</target>
        </trans-unit>
        <trans-unit id="eb82a427dc920b4169ca7e00269601d2ac319ce2" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::try_into</source>
          <target state="translated">AssertUnwindSafe::try_into</target>
        </trans-unit>
        <trans-unit id="9f7d994301cc07488a1ff2b7d4c3da5dab748286" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::type_id</source>
          <target state="translated">AssertUnwindSafe::type_id</target>
        </trans-unit>
        <trans-unit id="caf84242142f24165f73b39c5c6b3d3bc20e5c26" translate="yes" xml:space="preserve">
          <source>Assertions are always checked in both debug and release builds, and cannot be disabled. See &lt;a href=&quot;macro.debug_assert&quot;&gt;&lt;code&gt;debug_assert!&lt;/code&gt;&lt;/a&gt; for assertions that are not enabled in release builds by default.</source>
          <target state="translated">어설 션은 항상 디버그 및 릴리스 빌드 모두에서 확인되며 비활성화 할 수 없습니다. &lt;a href=&quot;macro.debug_assert&quot;&gt; &lt;code&gt;debug_assert!&lt;/code&gt; &lt;/a&gt; 참조하십시오 !릴리스 빌드에서 기본적으로 사용되지 않는 어설 션의 경우</target>
        </trans-unit>
        <trans-unit id="e17cdfab7869a902dcf07cf1a4cdf602ea080d95" translate="yes" xml:space="preserve">
          <source>Asserts that a boolean expression is &lt;code&gt;true&lt;/code&gt; at runtime.</source>
          <target state="translated">부울 표현식이 &lt;code&gt;true&lt;/code&gt; 임을 주장 합니다. 런타임에 .</target>
        </trans-unit>
        <trans-unit id="2cab5457990719d367e9e18b69d1f9cf567a9ba6" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are equal to each other (using &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; 서로 동일하다고 주장합니다 ( PartialEq 사용) . 합니다.</target>
        </trans-unit>
        <trans-unit id="ebf68c5dd99f7adc415f813d7cd9a9965b251c70" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are equal to each other.</source>
          <target state="translated">두 표현식이 서로 같다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="c856365534a0e73e93b9d798530cb553f48e1b9c" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are not equal to each other (using &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">두 표현식이 서로 같지 &lt;a href=&quot;cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; ( PartialEq 사용 ).</target>
        </trans-unit>
        <trans-unit id="4b3283be054a95811542a229062df29f52cd4b0a" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are not equal to each other.</source>
          <target state="translated">두 표현식이 서로 같지 않다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="6a70c6eb716321451f69851e0a0b3e6de46cfe0a" translate="yes" xml:space="preserve">
          <source>Assignment expressions</source>
          <target state="translated">대입 식</target>
        </trans-unit>
        <trans-unit id="db7b4a247e0cd4b439f9a236f4dd17ca687d0c37" translate="yes" xml:space="preserve">
          <source>Assignment of &lt;code&gt;A + B&lt;/code&gt; to &lt;code&gt;A&lt;/code&gt; might be removed, since the sum can be stored in a temporary location until it gets printed, with the global variable never getting updated.</source>
          <target state="translated">할당 &lt;code&gt;A + B&lt;/code&gt; 에 &lt;code&gt;A&lt;/code&gt; 그것을 인쇄 할 때까지 합계가 결코 업데이트되지 점점 글로벌 변수, 임시 위치에 저장 될 수 있기 때문에, 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb5a2f19ac5c2fbe53a27d32c54a5315d8390b9c" translate="yes" xml:space="preserve">
          <source>Assignment/equivalence</source>
          <target state="translated">Assignment/equivalence</target>
        </trans-unit>
        <trans-unit id="1ec71ff0ba20c7a0026ccba467326b673793511e" translate="yes" xml:space="preserve">
          <source>Assignments are not allowed in pattern guards, because matching cannot have side effects. Side effects could alter the matched object or the environment on which the match depends in such a way, that the match would not be exhaustive. For instance, the following would not match any arm if assignments were allowed:</source>
          <target state="translated">일치는 부작용을 가질 수 없으므로 패턴 가드에는 지정이 허용되지 않습니다. 부작용으로 인해 일치하는 개체 또는 일치하는 환경이 변경되어 일치하는 항목이 완전하지 않을 수 있습니다. 예를 들어, 할당이 허용 된 경우 다음은 팔과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="681eeaa9b3a793bf0806817da80c3be3c3a0567b" translate="yes" xml:space="preserve">
          <source>Assigns a new value to the memory behind the pinned reference.</source>
          <target state="translated">고정 된 참조 뒤의 메모리에 새로운 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="b443e8292f53b80a70f9ceabc76037bb4e254686" translate="yes" xml:space="preserve">
          <source>Associated Constants</source>
          <target state="translated">관련 상수</target>
        </trans-unit>
        <trans-unit id="aea3ba1170590168c2a8d38c0934f41a1081bd96" translate="yes" xml:space="preserve">
          <source>Associated Constants Examples</source>
          <target state="translated">관련 상수 예</target>
        </trans-unit>
        <trans-unit id="eb724e00631164f5e2c7a1805aa66c501706a7b7" translate="yes" xml:space="preserve">
          <source>Associated Functions</source>
          <target state="translated">관련 기능</target>
        </trans-unit>
        <trans-unit id="b9d6b786d3dce88371ca3fec1b3f0f5dcc494947" translate="yes" xml:space="preserve">
          <source>Associated Items</source>
          <target state="translated">관련 아이템</target>
        </trans-unit>
        <trans-unit id="26904b659cb34afa59632d8007e5d7c3c1f7672c" translate="yes" xml:space="preserve">
          <source>Associated Types</source>
          <target state="translated">관련 유형</target>
        </trans-unit>
        <trans-unit id="d854ee9b0fbbb41a1a8293a522b3a7fd759f3935" translate="yes" xml:space="preserve">
          <source>Associated Types Container Example</source>
          <target state="translated">연관된 유형 컨테이너 예제</target>
        </trans-unit>
        <trans-unit id="6176d44495c67b15b26948f8a03f37c611fcd9c1" translate="yes" xml:space="preserve">
          <source>Associated constants, functions, and types</source>
          <target state="translated">관련 상수, 함수 및 유형</target>
        </trans-unit>
        <trans-unit id="bf8fe32d8bff33aaf1adf4d6ce640603da967659" translate="yes" xml:space="preserve">
          <source>Associated functions and methods</source>
          <target state="translated">관련 기능 및 방법</target>
        </trans-unit>
        <trans-unit id="ca7658fbd81144f975e114c63e67d2067128142d" translate="yes" xml:space="preserve">
          <source>Associated functions are often used for constructors that will return a new instance of the struct. For example, we could provide an associated function that would have one dimension parameter and use that as both width and height, thus making it easier to create a square &lt;code&gt;Rectangle&lt;/code&gt; rather than having to specify the same value twice:</source>
          <target state="translated">연관된 함수는 종종 구조체의 새 인스턴스를 반환하는 생성자에 사용됩니다. 예를 들어, 하나의 차원 매개 변수를 가진 관련 함수를 제공하고이를 너비와 높이 로 사용하여 동일한 값을 두 번 지정하지 않고 사각형 &lt;code&gt;Rectangle&lt;/code&gt; 쉽게 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d8027bfb0422adf6fa755c7366da969f12a3f99" translate="yes" xml:space="preserve">
          <source>Associated functions whose first parameter is named &lt;code&gt;self&lt;/code&gt; are called &lt;em&gt;methods&lt;/em&gt; and may be invoked using the &lt;a href=&quot;../expressions/method-call-expr&quot;&gt;method call operator&lt;/a&gt;, for example, &lt;code&gt;x.foo()&lt;/code&gt;, as well as the usual function call notation.</source>
          <target state="translated">첫 번째 매개 변수 이름이 &lt;code&gt;self&lt;/code&gt; 인 연관된 함수를 &lt;em&gt;메소드&lt;/em&gt; 라고하며 , &lt;a href=&quot;../expressions/method-call-expr&quot;&gt;메소드 호출 연산자 &lt;/a&gt; &lt;code&gt;x.foo()&lt;/code&gt; 예 : x.foo () 및 일반 함수 호출 표기법 ) 를 사용하여 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50f4dee25317e303fd0eeee4d556e246ef57db0b" translate="yes" xml:space="preserve">
          <source>Associated item</source>
          <target state="translated">관련 아이템</target>
        </trans-unit>
        <trans-unit id="4627f0f1df7ed7ad7efce2d0583317bf3d8df511" translate="yes" xml:space="preserve">
          <source>Associated item for a type that cannot be directly named (e.g., &lt;code&gt;&amp;lt;&amp;amp;T&amp;gt;::...&lt;/code&gt;, &lt;code&gt;&amp;lt;[T]&amp;gt;::...&lt;/code&gt;, etc.)</source>
          <target state="translated">직접 이름을 지정할 수없는 유형의 관련 항목 (예 : &lt;code&gt;&amp;lt;&amp;amp;T&amp;gt;::...&lt;/code&gt; , &lt;code&gt;&amp;lt;[T]&amp;gt;::...&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="f0dda5ab7ff2aba410ad872aa8c289173200dd02" translate="yes" xml:space="preserve">
          <source>Associated items are useful when the associated item logically is related to the associating item. For example, the &lt;code&gt;is_some&lt;/code&gt; method on &lt;code&gt;Option&lt;/code&gt; is intrinsically related to Options, so should be associated.</source>
          <target state="translated">관련 항목은 관련 항목이 논리적으로 관련 항목과 관련이있을 때 유용합니다. 예를 들어, &lt;code&gt;Option&lt;/code&gt; 의 &lt;code&gt;is_some&lt;/code&gt; 메소드 는 본질적으로 옵션과 관련되어 있으므로 연관되어야합니다.</target>
        </trans-unit>
        <trans-unit id="13ba4a748e2d8dab765ce941e0df6910e63030e1" translate="yes" xml:space="preserve">
          <source>Associated searcher for this pattern</source>
          <target state="translated">이 패턴과 관련된 검색 자</target>
        </trans-unit>
        <trans-unit id="ce35cedae86fe81ca2cf2bcb725660816d309811" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;&amp;amp;[char] as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;amp;[char] as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 대한 연관된 ​​유형 .</target>
        </trans-unit>
        <trans-unit id="e195d76e814dc3f6b09416fe019701da4141e61f" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;&amp;amp;str as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;amp;str as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 대한 관련 유형 .</target>
        </trans-unit>
        <trans-unit id="da9f3600b580da18821fb0932aa55c1e82dc8484" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;F as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;F as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 연관된 유형 .</target>
        </trans-unit>
        <trans-unit id="470b87bc44e9aa3c27db7ff27c851ded51a493f4" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;char as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;char as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 대한 연관된 ​​유형 .</target>
        </trans-unit>
        <trans-unit id="4b2aeb71be1e33f6aef873e1957563d04f8d17e0" translate="yes" xml:space="preserve">
          <source>Associated types from &lt;code&gt;Trait&lt;/code&gt; can be used.</source>
          <target state="translated">&lt;code&gt;Trait&lt;/code&gt; 의 관련 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b94fe8e8235a5eac0ea7986a3bc24833e5f55164" translate="yes" xml:space="preserve">
          <source>Associated types might seem like a similar concept to generics, in that the latter allow us to define a function without specifying what types it can handle. So why use associated types?</source>
          <target state="translated">연관된 유형은 제네릭과 유사한 개념으로 보일 수 있는데, 후자는 처리 할 수있는 유형을 지정하지 않고 함수를 정의 할 수 있다는 점에서 다릅니다. 왜 관련 유형을 사용합니까?</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="434de15a9f2e5951652f37ae43c858535ba0b678" translate="yes" xml:space="preserve">
          <source>Assume there are two files in the same directory with the following contents:</source>
          <target state="translated">동일한 디렉토리에 다음 내용을 가진 두 개의 파일이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="9c07290f30084dee9d612cccf40372822beeda08" translate="yes" xml:space="preserve">
          <source>Assumes that the slice is sorted by the key, for instance with &lt;a href=&quot;#method.sort_by_key&quot;&gt;&lt;code&gt;sort_by_key&lt;/code&gt;&lt;/a&gt; using the same key extraction function.</source>
          <target state="translated">슬라이스가 키를 기준으로 정렬되어 있다고 가정합니다 (예 : 동일한 키 추출 기능을 사용하는 &lt;a href=&quot;#method.sort_by_key&quot;&gt; &lt;code&gt;sort_by_key&lt;/code&gt; &lt;/a&gt; 사용).</target>
        </trans-unit>
        <trans-unit id="7da83b920d859bea1ef24ff98129cc3f739b791b" translate="yes" xml:space="preserve">
          <source>Assuming all the elements are initialized, get a mutable slice to them.</source>
          <target state="translated">모든 요소가 초기화되었다고 가정하면 변경 가능한 슬라이스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0d70f82d569a6dc638a5854fc3e366cb50b91e26" translate="yes" xml:space="preserve">
          <source>Assuming all the elements are initialized, get a slice to them.</source>
          <target state="translated">모든 요소가 초기화되었다고 가정하고 슬라이스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c924c9518b3ab961e095e1c3fb8fc583399ec253" translate="yes" xml:space="preserve">
          <source>Assuming there&amp;rsquo;s a file named &lt;code&gt;foo.txt&lt;/code&gt; with contents &lt;code&gt;abcdef\n&lt;/code&gt;, create two handles, seek one of them, and read the remaining bytes from the other handle:</source>
          <target state="translated">내용이 &lt;code&gt;abcdef\n&lt;/code&gt; 인 &lt;code&gt;foo.txt&lt;/code&gt; 라는 파일이 있다고 가정하고 두 개의 핸들을 작성하고 그 중 하나를 찾고 다른 핸들에서 나머지 바이트를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="31936e0a0d8572ee4060f19296edebc34a7f6f8c" translate="yes" xml:space="preserve">
          <source>Asterisk glob imports will import items imported with &lt;code&gt;_&lt;/code&gt; in their unnameable form.</source>
          <target state="translated">별표 글로브 가져 오기는 &lt;code&gt;_&lt;/code&gt; 로 가져온 항목을 가져옵니다. 는 이름이없는 형태 로 .</target>
        </trans-unit>
        <trans-unit id="940e0ca02bfde86559dac73ad0f3397300f703e1" translate="yes" xml:space="preserve">
          <source>Async blocks act like a function boundary, much like closures. Therefore, the &lt;code&gt;?&lt;/code&gt; operator and &lt;code&gt;return&lt;/code&gt; expressions both affect the output of the future, not the enclosing function or other context. That is, &lt;code&gt;return &amp;lt;expr&amp;gt;&lt;/code&gt; from within a closure will return the result of &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; as the output of the future. Similarly, if &lt;code&gt;&amp;lt;expr&amp;gt;?&lt;/code&gt; propagates an error, that error is propagated as the result of the future.</source>
          <target state="translated">비동기 블록은 클로저처럼 함수 경계처럼 작동합니다. 따라서 &lt;code&gt;?&lt;/code&gt; 연산자 및 &lt;code&gt;return&lt;/code&gt; 식은 둘 다 둘러싸는 함수 나 다른 컨텍스트가 아닌 미래의 출력에 영향을줍니다. 즉, 클로저 내에서 &lt;code&gt;return &amp;lt;expr&amp;gt;&lt;/code&gt; 을 반환 하면 미래의 출력으로 &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; 의 결과가 반환됩니다 . 마찬가지로 &lt;code&gt;&amp;lt;expr&amp;gt;?&lt;/code&gt; 오류를 전파하면 해당 오류는 미래의 결과로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="214d7973c7382a6a34b11e3f97cf5442c859fb3e" translate="yes" xml:space="preserve">
          <source>Async blocks capture variables from their environment using the same &lt;a href=&quot;../types/closure#capture-modes&quot;&gt;capture modes&lt;/a&gt; as closures. Like closures, when written &lt;code&gt;async { .. }&lt;/code&gt; the capture mode for each variable will be inferred from the content of the block. &lt;code&gt;async move { .. }&lt;/code&gt; blocks however will move all referenced variables into the resulting future.</source>
          <target state="translated">비동기 블록 은 클로저 와 동일한 &lt;a href=&quot;../types/closure#capture-modes&quot;&gt;캡처 모드&lt;/a&gt; 를 사용하여 환경에서 변수를 캡처합니다 . 클로저와 마찬가지로 &lt;code&gt;async { .. }&lt;/code&gt; 작성시 각 변수의 캡처 모드는 블록의 내용에서 유추됩니다. 그러나 &lt;code&gt;async move { .. }&lt;/code&gt; 블록은 참조 된 모든 변수를 결과 미래로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="57f9a16fc928066d87c71b1e0690e9ad26edea0a" translate="yes" xml:space="preserve">
          <source>Async context</source>
          <target state="translated">비동기 컨텍스트</target>
        </trans-unit>
        <trans-unit id="5ef2ec7c086db048016785067a80b5c302021dc3" translate="yes" xml:space="preserve">
          <source>Async functions</source>
          <target state="translated">비동기 기능</target>
        </trans-unit>
        <trans-unit id="99471e2fa36e20e9d7193c5529dfbf6f52a711a2" translate="yes" xml:space="preserve">
          <source>Async functions do no work when called: instead, they capture their arguments into a future. When polled, that future will execute the function's body.</source>
          <target state="translated">비동기 함수는 호출시 작동하지 않습니다. 대신 미래에 대한 인수를 캡처합니다. 폴링되면 해당 퓨처는 함수의 본문을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="c318095156a540e68b8cc7d9ad9ab72fce83a154" translate="yes" xml:space="preserve">
          <source>Asynchronous values.</source>
          <target state="translated">비동기 값.</target>
        </trans-unit>
        <trans-unit id="0855009c46728a5c8cb9aa53860e3b38d932c17a" translate="yes" xml:space="preserve">
          <source>At</source>
          <target state="translated">At</target>
        </trans-unit>
        <trans-unit id="6aa8b3387e6ffd75791adbf0065888a4924635f2" translate="yes" xml:space="preserve">
          <source>At a high level, a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; ensures that the pointee of any pointer type &lt;code&gt;P&lt;/code&gt; has a stable location in memory, meaning it cannot be moved elsewhere and its memory cannot be deallocated until it gets dropped. We say that the pointee is &quot;pinned&quot;. Things get more subtle when discussing types that combine pinned with non-pinned data; &lt;a href=&quot;#projections-and-structural-pinning&quot;&gt;see below&lt;/a&gt; for more details.</source>
          <target state="translated">높은 수준에서 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 포인터 유형 &lt;code&gt;P&lt;/code&gt; 의 pointee가 메모리에서 안정적인 위치를 갖도록합니다. 즉, 다른 위치로 이동할 수없고 메모리가 삭제 될 때까지 할당 해제 될 수 없음을 의미합니다. pointee가 &quot;고정&quot;되었다고 말합니다. 고정 된 데이터와 고정되지 않은 데이터를 결합하는 유형을 논의 할 때 상황이 더 미묘 해집니다. 자세한 내용 &lt;a href=&quot;#projections-and-structural-pinning&quot;&gt;은 아래&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d9cacf1832e8829a2c65089757588eeeacfc9330" translate="yes" xml:space="preserve">
          <source>At all times, you must avoid data races. If multiple threads have access to the same &lt;code&gt;UnsafeCell&lt;/code&gt;, then any writes must have a proper happens-before relation to all other accesses (or use atomics).</source>
          <target state="translated">항상 데이터 경쟁을 피해야합니다. 여러 스레드가 동일한 &lt;code&gt;UnsafeCell&lt;/code&gt; 에 액세스 할 수있는 경우 다른 모든 액세스 (또는 원자 사용)와 관련하여 쓰기 작업이 올바르게 수행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c68169e0fac1472856a75bc093cd4e904a65d3b5" translate="yes" xml:space="preserve">
          <source>At any given time, you can have &lt;em&gt;either&lt;/em&gt; (but not both of) one mutable reference or any number of immutable references.</source>
          <target state="translated">주어진 시간에, 당신은 할 수 있습니다 &lt;em&gt;중 하나&lt;/em&gt; (모두는 아니지만) 하나 변경 가능한 참조 또는 불변의 참조의 수입니다.</target>
        </trans-unit>
        <trans-unit id="97c27bc0fbd95b57400fcf731e3e7a7d89c5cf2f" translate="yes" xml:space="preserve">
          <source>At any given time, you can have &lt;em&gt;either&lt;/em&gt; one mutable reference &lt;em&gt;or&lt;/em&gt; any number of immutable references.</source>
          <target state="translated">주어진 시간에, 당신은 할 수 있습니다 &lt;em&gt;중&lt;/em&gt; 하나 변경 가능한 참조 &lt;em&gt;또는&lt;/em&gt; 불변의 참조의 수입니다.</target>
        </trans-unit>
        <trans-unit id="b790d9edc1873ab13071956060a912cd284deda5" translate="yes" xml:space="preserve">
          <source>At compile time each implementation of &lt;code&gt;Trait&lt;/code&gt; will produce a table containing the various methods (and other items) related to the implementation.</source>
          <target state="translated">컴파일 타임에 &lt;code&gt;Trait&lt;/code&gt; 의 각 구현은 구현 과 관련된 다양한 메소드 (및 기타 항목)를 포함하는 테이블을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="26e37b1b35b52ad10610ea1ef12403fe61f658c6" translate="yes" xml:space="preserve">
          <source>At compile time, Rust needs to know how much space a type takes up. One type whose size can&amp;rsquo;t be known at compile time is a &lt;em&gt;recursive type&lt;/em&gt;, where a value can have as part of itself another value of the same type. Because this nesting of values could theoretically continue infinitely, Rust doesn&amp;rsquo;t know how much space a value of a recursive type needs. However, boxes have a known size, so by inserting a box in a recursive type definition, you can have recursive types.</source>
          <target state="translated">컴파일 타임에 Rust는 타입이 차지하는 공간을 알아야합니다. 컴파일 타임에 크기를 알 수없는 유형 중 하나는 &lt;em&gt;재귀 유형입니다&lt;/em&gt; 이며 값은 자체 유형의 일부로 동일한 유형의 다른 값을 가질 수 있습니다. 이 값 중첩은 이론적으로 무한대로 계속 될 수 있기 때문에 Rust는 재귀 유형의 값에 필요한 공간의 양을 모릅니다. 그러나 상자의 크기는 알려진 것이므로 재귀 유형 정의에 상자를 삽입하면 재귀 유형을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2f9b5afe99b75e0f39f01ec88be93443b074a9d" translate="yes" xml:space="preserve">
          <source>At each point in the program where the reference count changes, we print the reference count, which we can get by calling the &lt;code&gt;Rc::strong_count&lt;/code&gt; function. This function is named &lt;code&gt;strong_count&lt;/code&gt; rather than &lt;code&gt;count&lt;/code&gt; because the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type also has a &lt;code&gt;weak_count&lt;/code&gt;; we&amp;rsquo;ll see what &lt;code&gt;weak_count&lt;/code&gt; is used for in the &lt;a href=&quot;ch15-06-reference-cycles#preventing-reference-cycles-turning-an-rct-into-a-weakt&quot;&gt;&amp;ldquo;Preventing Reference Cycles: Turning an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; into a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt;&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">참조 카운트가 변경되는 프로그램의 각 지점에서 &lt;code&gt;Rc::strong_count&lt;/code&gt; 함수를 호출하여 얻을 수있는 참조 카운트를 인쇄합니다 . 이 함수라는 &lt;code&gt;strong_count&lt;/code&gt; 아닌 &lt;code&gt;count&lt;/code&gt; 때문에 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 또한 A 형 갖는다 &lt;code&gt;weak_count&lt;/code&gt; 을 ; &lt;a href=&quot;ch15-06-reference-cycles#preventing-reference-cycles-turning-an-rct-into-a-weakt&quot;&gt;&quot;참조 사이클 방지 : &lt;/a&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; &quot; 섹션 에서 &lt;code&gt;weak_count&lt;/code&gt; 가 사용되는 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2afe7e487c0f1c732676abe97c30fdb7bfd5600" translate="yes" xml:space="preserve">
          <source>At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the &lt;a href=&quot;#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to allocate the correct capacity initially:</source>
          <target state="translated">처음에는 메모리가 전혀 할당되어 있지 않지만 문자열에 추가하면 용량이 적절하게 증가합니다. &lt;a href=&quot;#method.with_capacity&quot;&gt; &lt;code&gt;with_capacity&lt;/code&gt; &lt;/a&gt; 메소드를 대신 사용하여 처음에 올바른 용량을 할당하는 경우 :</target>
        </trans-unit>
        <trans-unit id="dc05814fc863fd7b76fdcfe7f779c72f9533e270" translate="yes" xml:space="preserve">
          <source>At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the &lt;a href=&quot;struct.string#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to allocate the correct capacity initially:</source>
          <target state="translated">처음에는 메모리가 전혀 할당되지 않았지만 문자열에 추가하면 용량이 적절하게 증가합니다. 대신 &lt;a href=&quot;struct.string#method.with_capacity&quot;&gt; &lt;code&gt;with_capacity&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 처음에 올바른 용량을 할당하면 :</target>
        </trans-unit>
        <trans-unit id="0295e56a89c227419234a744fcdff39f54bbbd31" translate="yes" xml:space="preserve">
          <source>At its simplest, a test in Rust is a function that&amp;rsquo;s annotated with the &lt;code&gt;test&lt;/code&gt; attribute. Attributes are metadata about pieces of Rust code; one example is the &lt;code&gt;derive&lt;/code&gt; attribute we used with structs in Chapter 5. To change a function into a test function, add &lt;code&gt;#[test]&lt;/code&gt; on the line before &lt;code&gt;fn&lt;/code&gt;. When you run your tests with the &lt;code&gt;cargo test&lt;/code&gt; command, Rust builds a test runner binary that runs the functions annotated with the &lt;code&gt;test&lt;/code&gt; attribute and reports on whether each test function passes or fails.</source>
          <target state="translated">가장 간단하게 Rust의 &lt;code&gt;test&lt;/code&gt; 는 테스트 속성으로 주석이 달린 함수입니다 . 속성은 Rust 코드에 대한 메타 데이터입니다. 한 가지 예는 5 장의 구조체와 함께 사용 하는 &lt;code&gt;derive&lt;/code&gt; 속성입니다. 함수를 테스트 함수로 변경하려면 &lt;code&gt;fn&lt;/code&gt; 앞에 줄에 &lt;code&gt;#[test]&lt;/code&gt; 를 추가하십시오 . &lt;code&gt;cargo test&lt;/code&gt; 명령으로 테스트를 실행할 때 Rust는 &lt;code&gt;test&lt;/code&gt; 속성으로 주석이 달린 함수를 실행하고 각 테스트 함수의 통과 여부를보고 하는 테스트 러너 바이너리를 빌드 합니다.</target>
        </trans-unit>
        <trans-unit id="37583ea386b39553438667ee1326a11884d8ac4d" translate="yes" xml:space="preserve">
          <source>At least one of either &lt;code&gt;Self&lt;/code&gt; or a generic type parameter of the trait must meet the following grammar, where &lt;code&gt;C&lt;/code&gt; is a nominal type defined within the containing crate:</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; 또는 특성의 일반 유형 매개 변수 중 하나 이상 이 다음 문법을 충족해야합니다. 여기서 &lt;code&gt;C&lt;/code&gt; 는 포함하는 상자 내에 정의 된 공칭 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6340eab1a988a949757faf0b3ab2c9f1d577f929" translate="yes" xml:space="preserve">
          <source>At least one of the pointers is being used to write to the data.</source>
          <target state="translated">포인터 중 하나 이상이 데이터 쓰기에 사용되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5724aa0694940a76277017d916e0999814aa1912" translate="yes" xml:space="preserve">
          <source>At least one of the types &lt;code&gt;T0..=Tn&lt;/code&gt; must be a &lt;a href=&quot;../glossary#local-type&quot;&gt;local type&lt;/a&gt;. Let &lt;code&gt;Ti&lt;/code&gt; be the first such type.</source>
          <target state="translated">&lt;code&gt;T0..=Tn&lt;/code&gt; 유형 중 하나 이상 은 &lt;a href=&quot;../glossary#local-type&quot;&gt;로컬 유형&lt;/a&gt; 이어야합니다 . 하자 &lt;code&gt;Ti&lt;/code&gt; 최초의 유형합니다.</target>
        </trans-unit>
        <trans-unit id="e87e525060c2b4080d7c34755a062916a4109c19" translate="yes" xml:space="preserve">
          <source>At least one of the types &lt;code&gt;T0..=Tn&lt;/code&gt; must be a local type. Let &lt;code&gt;Ti&lt;/code&gt; be the first such type.</source>
          <target state="translated">&lt;code&gt;T0..=Tn&lt;/code&gt; 유형 중 하나 이상 은 로컬 유형이어야합니다. 하자 &lt;code&gt;Ti&lt;/code&gt; 최초의 유형합니다.</target>
        </trans-unit>
        <trans-unit id="a139025cd9d3b2fee71807f78a3b49ac15b212ef" translate="yes" xml:space="preserve">
          <source>At present few predefined ABI's (like Rust, C, system, etc.) can be used in Rust. Verify that the ABI is predefined. For example you can replace the given ABI from 'Rust'.</source>
          <target state="translated">현재 Rust, C, 시스템 등과 같은 사전 정의 된 ABI는 거의 없습니다. ABI가 미리 정의되어 있는지 확인합니다. 예를 들어 'Rust'에서 주어진 ABI를 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2c9357843faff292144d5026ce32c57e9298ff6" translate="yes" xml:space="preserve">
          <source>At present, it is not permitted to have a yield that occurs while a borrow is still in scope. To resolve this error, the borrow must either be &quot;contained&quot; to a smaller scope that does not overlap the yield or else eliminated in another way. So, for example, we might resolve the previous example by removing the borrow and just storing the integer by value:</source>
          <target state="translated">현재, 대출이 여전히 범위 내에있는 동안 발생하는 수익률을 갖는 것은 허용되지 않습니다. 이 오류를 해결하려면 대출금이 수익률과 겹치지 않는 더 작은 범위로 &quot;포함&quot;되거나 다른 방법으로 제거되어야합니다. 예를 들어, 차용을 제거하고 정수를 값으로 저장하여 이전 예를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c58aa6f87c5fb2f5db7b812c6bc9a21b048e36a1" translate="yes" xml:space="preserve">
          <source>At present, it is not permitted to pass more than one explicit parameter for a generator.This can be fixed by using at most 1 parameter for the generator. For example, we might resolve the previous example by passing only one parameter.</source>
          <target state="translated">현재 생성기에 대해 하나 이상의 명시 적 매개 변수를 전달하는 것은 허용되지 않으며 이는 생성기에 대해 최대 1 개의 매개 변수를 사용하여 수정할 수 있습니다. 예를 들어, 하나의 매개 변수 만 전달하여 이전 예제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e36fb08191e884058237321d264d01b5dc6a45f" translate="yes" xml:space="preserve">
          <source>At run-time, when a method needs to be called on the &lt;code&gt;dyn Trait&lt;/code&gt;, the vtable is consulted to get the function pointer and then that function pointer is called.</source>
          <target state="translated">런타임에 &lt;code&gt;dyn Trait&lt;/code&gt; 에서 메서드를 호출해야 할 때 vtable을 참조하여 함수 포인터를 얻은 다음 해당 함수 포인터가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="acf3e76f07038198aca7a45dd9300fbaa0a3ed8a" translate="yes" xml:space="preserve">
          <source>At runtime this function behaves like &lt;code&gt;self != other&lt;/code&gt;. However, in some contexts (e.g., compile-time evaluation), it is not always possible to determine the inequality of two pointers, so this function may spuriously return &lt;code&gt;false&lt;/code&gt; for pointers that later actually turn out to be unequal. But when it returns &lt;code&gt;true&lt;/code&gt;, the pointers are guaranteed to be unequal.</source>
          <target state="translated">런타임에이 함수는 &lt;code&gt;self != other&lt;/code&gt; 처럼 동작 합니다. 그러나 일부 컨텍스트 (예 : 컴파일 타임 평가)에서는 두 포인터의 부등식을 항상 결정할 수있는 것은 아니므로이 함수는 나중에 실제로 부등하다고 &lt;code&gt;false&lt;/code&gt; 된 포인터에 대해 거짓 을 반환 할 수 있습니다. 그러나 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 포인터가 같지 않음이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="3ddac349169d1a744bfbed1eee12e4790040330f" translate="yes" xml:space="preserve">
          <source>At runtime this function behaves like &lt;code&gt;self == other&lt;/code&gt;. However, in some contexts (e.g., compile-time evaluation), it is not always possible to determine equality of two pointers, so this function may spuriously return &lt;code&gt;false&lt;/code&gt; for pointers that later actually turn out to be equal. But when it returns &lt;code&gt;true&lt;/code&gt;, the pointers are guaranteed to be equal.</source>
          <target state="translated">런타임에이 함수는 &lt;code&gt;self == other&lt;/code&gt; 처럼 동작 합니다. 그러나 일부 컨텍스트 (예 : 컴파일 타임 평가)에서는 두 포인터의 동등성을 항상 결정할 수있는 것은 아니므로이 함수는 나중에 실제로 동일한 것으로 &lt;code&gt;false&lt;/code&gt; 되는 포인터에 대해 거짓 을 반환 할 수 있습니다. 그러나 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 포인터가 동일하다는 것이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="880cb1d1611d41944fc45c1105942f35a2cea331" translate="yes" xml:space="preserve">
          <source>At the beginning of this chapter, we said that vectors can only store values that are the same type. This can be inconvenient; there are definitely use cases for needing to store a list of items of different types. Fortunately, the variants of an enum are defined under the same enum type, so when we need to store elements of a different type in a vector, we can define and use an enum!</source>
          <target state="translated">이 장의 시작 부분에서 벡터는 동일한 유형의 값만 저장할 수 있다고 말했습니다. 불편할 수 있습니다. 다른 유형의 항목 목록을 저장 해야하는 유스 케이스가 있습니다. 다행히 열거 형의 변형은 동일한 열거 형으로 정의되므로 벡터에 다른 유형의 요소를 저장해야 할 때 열거 형을 정의하고 사용할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="b0f9f410d4d3f041a8bbac0598dae49519ac5a0f" translate="yes" xml:space="preserve">
          <source>At the moment the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks have a lot of repetition: they&amp;rsquo;re both reading files and writing the contents of the files to the stream. The only differences are the status line and the filename. Let&amp;rsquo;s make the code more concise by pulling out those differences into separate &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; lines that will assign the values of the status line and the filename to variables; we can then use those variables unconditionally in the code to read the file and write the response. Listing 20-9 shows the resulting code after replacing the large &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks.</source>
          <target state="translated">시점의 &lt;code&gt;if&lt;/code&gt; 와 &lt;code&gt;else&lt;/code&gt; 블록 반복을 많이 가지고 : 그들은 두 파일을 읽고 스트림에 파일의 내용을 작성하고 있습니다. 유일한 차이점은 상태 줄과 파일 이름입니다. 상태 라인의 값과 파일 이름을 변수에 할당하는 별도의 &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 라인 으로 이러한 차이를 끌어내어 코드를 더 간결하게 만들어 봅시다 . 그런 다음 코드에서 변수를 무조건 사용하여 파일을 읽고 응답을 작성할 수 있습니다. Listing 20-9는 큰 &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 블록을 교체 한 후의 결과 코드를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="929c7d4e23e7e49a6c726514ca62a32c23fbe8e1" translate="yes" xml:space="preserve">
          <source>At the moment, &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;match&lt;/code&gt;, as well as the looping constructs &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, and &lt;code&gt;loop&lt;/code&gt;, are forbidden inside a &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, or &lt;code&gt;const fn&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;match&lt;/code&gt; 및 &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; 및 &lt;code&gt;loop&lt;/code&gt; 의 루핑 구문 은 &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;static&lt;/code&gt; 또는 &lt;code&gt;const fn&lt;/code&gt; 내에서 금지되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f16df13b8f4c863b823dc86f56453377891952c" translate="yes" xml:space="preserve">
          <source>At the moment, we&amp;rsquo;re writing all of our output to the terminal using the &lt;code&gt;println!&lt;/code&gt; function. Most terminals provide two kinds of output: &lt;em&gt;standard output&lt;/em&gt; (&lt;code&gt;stdout&lt;/code&gt;) for general information and &lt;em&gt;standard error&lt;/em&gt; (&lt;code&gt;stderr&lt;/code&gt;) for error messages. This distinction enables users to choose to direct the successful output of a program to a file but still print error messages to the screen.</source>
          <target state="translated">현재 &lt;code&gt;println!&lt;/code&gt; 사용하여 모든 출력을 터미널에 쓰고 있습니다 ! 함수. 대부분의 터미널은 일반 정보의 경우 &lt;em&gt;표준 출력&lt;/em&gt; ( &lt;code&gt;stdout&lt;/code&gt; )과 오류 메시지의 경우 &lt;em&gt;표준 오류&lt;/em&gt; ( &lt;code&gt;stderr&lt;/code&gt; )의 두 가지 출력을 제공 합니다. 이 구별을 통해 사용자는 프로그램의 성공적인 출력을 파일로 보내지 만 여전히 오류 메시지를 화면에 인쇄하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d5aa8f95e2e92d8aada8f026371cf7b990b2775" translate="yes" xml:space="preserve">
          <source>At the moment, we&amp;rsquo;re writing all of our output to the terminal using the &lt;code&gt;println!&lt;/code&gt; macro. Most terminals provide two kinds of output: &lt;em&gt;standard output&lt;/em&gt; (&lt;code&gt;stdout&lt;/code&gt;) for general information and &lt;em&gt;standard error&lt;/em&gt; (&lt;code&gt;stderr&lt;/code&gt;) for error messages. This distinction enables users to choose to direct the successful output of a program to a file but still print error messages to the screen.</source>
          <target state="translated">현재 우리는 &lt;code&gt;println!&lt;/code&gt; 사용하여 모든 출력을 터미널에 쓰고 있습니다 ! 매크로. 대부분의 터미널은 일반 정보를위한 &lt;em&gt;표준 출력&lt;/em&gt; ( &lt;code&gt;stdout&lt;/code&gt; )과 오류 메시지를위한 &lt;em&gt;표준 오류&lt;/em&gt; ( &lt;code&gt;stderr&lt;/code&gt; )의 두 가지 종류의 출력을 제공 합니다. 이 구별을 통해 사용자는 프로그램의 성공적인 출력을 파일로 지정하지만 여전히 오류 메시지를 화면에 인쇄하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3818ff95eb637709816bb6cd777c917a43bae444" translate="yes" xml:space="preserve">
          <source>At the time of this writing, an automatic formatter tool called &lt;code&gt;rustfmt&lt;/code&gt; is under development. If you want to stick to a standard style across Rust projects, &lt;code&gt;rustfmt&lt;/code&gt; will format your code in a particular style. The Rust team plans to eventually include this tool with the standard Rust distribution, like &lt;code&gt;rustc&lt;/code&gt;. So depending on when you read this book, it might already be installed on your computer! Check the online documentation for more details.</source>
          <target state="translated">이 글을 쓰는 시점에서 &lt;code&gt;rustfmt&lt;/code&gt; 라는 자동 포맷터 도구 가 개발 중입니다. Rust 프로젝트에서 표준 스타일을 고수하려면 &lt;code&gt;rustfmt&lt;/code&gt; 가 특정 스타일로 코드를 포맷합니다. Rust 팀은 결국이 도구를 &lt;code&gt;rustc&lt;/code&gt; 와 같은 표준 Rust 배포판에 포함시킬 계획 입니다. 따라서이 책을 읽는 시점에 따라 컴퓨터에 이미 설치되어있을 수 있습니다! 자세한 내용은 온라인 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1eca2e64861fbf60436be0df95a81ecf4dd4db51" translate="yes" xml:space="preserve">
          <source>At the time of this writing, two Rust editions are available: Rust 2015 and Rust 2018. This book is written using Rust 2018 edition idioms.</source>
          <target state="translated">이 글을 쓰는 시점에서 Rust 2015와 Rust 2018의 두 가지 Rust 에디션을 사용할 수 있습니다.이 책은 Rust 2018 에디션 관용구를 사용하여 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="d0b83ac2e98214df1ca34576f6616d27aede53ff" translate="yes" xml:space="preserve">
          <source>At the time, we said not to worry about the inefficient &lt;code&gt;clone&lt;/code&gt; calls because we would remove them in the future. Well, that time is now!</source>
          <target state="translated">당시 우리는 비효율적 인 &lt;code&gt;clone&lt;/code&gt; 호출 에 대해서는 걱정하지 않겠다고 말했습니다 . 글쎄, 그 시간은 지금이다!</target>
        </trans-unit>
        <trans-unit id="bf023d508177d86413d3379134e446a32a09142c" translate="yes" xml:space="preserve">
          <source>At the time, we skipped over some details in this code. In Chapter 6 in &lt;a href=&quot;ch06-02-match#the-match-control-flow-operator&quot;&gt;&amp;ldquo;The &lt;code&gt;match&lt;/code&gt; Control Flow Operator&amp;rdquo;&lt;/a&gt; section, we discussed that &lt;code&gt;match&lt;/code&gt; arms must all return the same type. So, for example, the following code doesn&amp;rsquo;t work:</source>
          <target state="translated">당시에는이 코드에서 몇 가지 세부 사항을 건너 뛰었습니다. 6 장 &lt;a href=&quot;ch06-02-match#the-match-control-flow-operator&quot;&gt;&quot; &lt;code&gt;match&lt;/code&gt; 제어 흐름 연산자&quot;&lt;/a&gt; 섹션에서 &lt;code&gt;match&lt;/code&gt; 암이 모두 동일한 유형을 반환해야 한다고 논의했습니다 . 예를 들어 다음 코드는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ade322c88e63df6a4a8c865c0fa8c7d63812d90" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;cargo build&lt;/code&gt; should complete successfully in both &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt;. Let&amp;rsquo;s hook up these crates to the code in Listing 19-30 to see the procedural macro in action! Create a new binary project in your &lt;em&gt;projects&lt;/em&gt; directory using &lt;code&gt;cargo new pancakes&lt;/code&gt;. We need to add &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt; as dependencies in the &lt;code&gt;pancakes&lt;/code&gt; crate&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;. If you&amp;rsquo;re publishing your versions of &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt; to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;, they would be regular dependencies; if not, you can specify them as &lt;code&gt;path&lt;/code&gt; dependencies as follows:</source>
          <target state="translated">이 시점 에서 &lt;code&gt;hello_macro&lt;/code&gt; 및 &lt;code&gt;hello_macro_derive&lt;/code&gt; 모두에서 &lt;code&gt;cargo build&lt;/code&gt; 가 성공적으로 완료되어야합니다 . 절차 적 매크로가 실제로 작동하는지 확인하려면이 상자를 Listing 19-30의 코드에 연결해 보자! &lt;code&gt;cargo new pancakes&lt;/code&gt; 를 사용 하여 &lt;em&gt;프로젝트&lt;/em&gt; 디렉토리 에 새 바이너리 프로젝트를 작성하십시오 . &lt;code&gt;pancakes&lt;/code&gt; 상자의 &lt;em&gt;Cargo.toml에&lt;/em&gt; 종속 &lt;code&gt;hello_macro_derive&lt;/code&gt; 으로 &lt;code&gt;hello_macro&lt;/code&gt; 및 hello_macro_derive 를 추가해야합니다 . 다음과 같이 &lt;code&gt;hello_macro&lt;/code&gt; 및 &lt;code&gt;hello_macro_derive&lt;/code&gt; 버전 을 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io &lt;/a&gt; &lt;code&gt;path&lt;/code&gt; 종속성에 게시하는 경우 :&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; , 그들은 정기적으로 종속 될 것이다; 그렇지 않은 경우 다음과 같이 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b945ef4a755c9f52a155f619e7f39f1e0b11da63" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;s&lt;/code&gt; will be &lt;code&gt;tic-tac-toe&lt;/code&gt;. With all of the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; characters, it&amp;rsquo;s difficult to see what&amp;rsquo;s going on. For more complicated string combining, we can use the &lt;code&gt;format!&lt;/code&gt; macro:</source>
          <target state="translated">이 시점에서 &lt;code&gt;s&lt;/code&gt; 는 &lt;code&gt;tic-tac-toe&lt;/code&gt; 가 됩니다. 모든 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;&quot;&lt;/code&gt; 문자를 사용하면 현재 상황을 파악하기가 어렵습니다.보다 복잡한 문자열 결합을 위해서는 &lt;code&gt;format!&lt;/code&gt; 사용할 수 있습니다 ! 매크로 :</target>
        </trans-unit>
        <trans-unit id="bad906bb2d4d513518792ef63a17dbb628e284cd" translate="yes" xml:space="preserve">
          <source>At this point, the first part of the game is done: we&amp;rsquo;re getting input from the keyboard and then printing it.</source>
          <target state="translated">이제 게임의 첫 부분이 완료되었습니다. 키보드에서 입력을받은 다음 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="645fa0bc97b2e92b8b41b6c72b5e6804e2731419" translate="yes" xml:space="preserve">
          <source>At this point, the relationship between scopes and when variables are valid is similar to that in other programming languages. Now we&amp;rsquo;ll build on top of this understanding by introducing the &lt;code&gt;String&lt;/code&gt; type.</source>
          <target state="translated">이 시점에서 범위와 변수가 유효한시기의 관계는 다른 프로그래밍 언어의 관계와 유사합니다. 이제 우리는 &lt;code&gt;String&lt;/code&gt; 타입 을 소개함으로써 이러한 이해를 바탕으로 구축 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="440b2812ba3e248d39262c445df6cb473f1a4cf8" translate="yes" xml:space="preserve">
          <source>At this point, we can build the workspace by running &lt;code&gt;cargo build&lt;/code&gt;. The files in your &lt;em&gt;add&lt;/em&gt; directory should look like this:</source>
          <target state="translated">이제 &lt;code&gt;cargo build&lt;/code&gt; 를 실행하여 작업 공간을 빌드 할 수 있습니다 . &lt;em&gt;add&lt;/em&gt; 디렉토리 의 파일 은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="f644530959c577881d3641aeacacd055e0614725" translate="yes" xml:space="preserve">
          <source>At this point, we could consider opportunities for refactoring the implementation of the search function while keeping the tests passing to maintain the same functionality. The code in the search function isn&amp;rsquo;t too bad, but it doesn&amp;rsquo;t take advantage of some useful features of iterators. We&amp;rsquo;ll return to this example in &lt;a href=&quot;ch13-02-iterators&quot;&gt;Chapter 13&lt;/a&gt;, where we&amp;rsquo;ll explore iterators in detail, and look at how to improve it.</source>
          <target state="translated">이 시점에서 동일한 기능을 유지하기 위해 테스트를 통과하면서 검색 기능의 구현을 리팩토링 할 기회를 고려할 수 있습니다. 검색 기능의 코드는 그리 나쁘지는 않지만 반복자의 유용한 기능을 활용하지 않습니다. 이 예제로 돌아가서 &lt;a href=&quot;ch13-02-iterators&quot;&gt;13 장&lt;/a&gt; 에서 반복자를 자세히 살펴보고 개선 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7be13e6f2293ee19341faecbce38cbce6581638c" translate="yes" xml:space="preserve">
          <source>At this point, we could consider opportunities for refactoring the implementation of the search function while keeping the tests passing to maintain the same functionality. The code in the search function isn&amp;rsquo;t too bad, but it doesn&amp;rsquo;t take advantage of some useful features of iterators. We&amp;rsquo;ll return to this example in [Chapter 13][ch13], where we&amp;rsquo;ll explore iterators in detail, and look at how to improve it.</source>
          <target state="translated">이 시점에서 우리는 동일한 기능을 유지하기 위해 테스트를 통과하면서 검색 기능의 구현을 리팩토링 할 수있는 기회를 고려할 수있었습니다. 검색 기능의 코드는 나쁘지 않지만 반복자의 유용한 기능을 활용하지는 않습니다. 이 예제로 돌아가서 [Chapter 13] [ch13]에서 반복자를 자세히 살펴보고 개선 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="12d2e7392939d54c75dd7be38b3f433458f57624" translate="yes" xml:space="preserve">
          <source>At this point, when we call &lt;code&gt;content&lt;/code&gt; on the &lt;code&gt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt;, deref coercion will take effect on the &lt;code&gt;&amp;amp;&lt;/code&gt; and the &lt;code&gt;Box&lt;/code&gt; so the &lt;code&gt;content&lt;/code&gt; method will ultimately be called on the type that implements the &lt;code&gt;State&lt;/code&gt; trait. That means we need to add &lt;code&gt;content&lt;/code&gt; to the &lt;code&gt;State&lt;/code&gt; trait definition, and that is where we&amp;rsquo;ll put the logic for what content to return depending on which state we have, as shown in Listing 17-18:</source>
          <target state="translated">이 시점 에서 &lt;code&gt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;content&lt;/code&gt; 를 호출 할 때 , deref 강제가 &lt;code&gt;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;Box&lt;/code&gt; 에 영향을 미치 므로 궁극적으로 &lt;code&gt;State&lt;/code&gt; 특성 을 구현하는 유형 에서 &lt;code&gt;content&lt;/code&gt; 메소드가 호출됩니다 . 즉 , &lt;code&gt;State&lt;/code&gt; 특성 정의 에 &lt;code&gt;content&lt;/code&gt; 를 추가해야하며 , 여기서는 상태 17-18에 표시된대로 상태에 따라 리턴 할 컨텐츠에 대한 논리를 배치합니다.</target>
        </trans-unit>
        <trans-unit id="41d03c60eead1f80179e902c1b4d9814280d6245" translate="yes" xml:space="preserve">
          <source>At this point, when we try to get a reference to the parent of &lt;code&gt;leaf&lt;/code&gt; by using the &lt;code&gt;upgrade&lt;/code&gt; method, we get a &lt;code&gt;None&lt;/code&gt; value. We see this in the output from the first &lt;code&gt;println!&lt;/code&gt; statement:</source>
          <target state="translated">이 시점 에서 &lt;code&gt;upgrade&lt;/code&gt; 메소드 를 사용하여 &lt;code&gt;leaf&lt;/code&gt; 의 부모에 대한 참조를 얻으려고하면 &lt;code&gt;None&lt;/code&gt; 값을 얻습니다 . 우리는 이것을 첫 번째 &lt;code&gt;println!&lt;/code&gt; 의 출력에서 ​​볼 수 있습니다 ! 성명서:</target>
        </trans-unit>
        <trans-unit id="3822c3ca41678f3e73f1513ee4103e0d10a48e3d" translate="yes" xml:space="preserve">
          <source>At this point, you would also notice a change in your &lt;em&gt;Cargo.lock&lt;/em&gt; file noting that the version of the &lt;code&gt;rand&lt;/code&gt; crate you are now using is &lt;code&gt;0.3.15&lt;/code&gt;.</source>
          <target state="translated">이 시점에서 현재 사용중인 &lt;code&gt;rand&lt;/code&gt; 크레이트 의 버전이 &lt;em&gt;0.3.15임을 나타내는 Cargo.lock&lt;/em&gt; 파일 이 변경 &lt;code&gt;0.3.15&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="980ca773a0cc1c507c75dc787b2ebd61a83c58ee" translate="yes" xml:space="preserve">
          <source>At this point, you would also notice a change in your &lt;em&gt;Cargo.lock&lt;/em&gt; file noting that the version of the &lt;code&gt;rand&lt;/code&gt; crate you are now using is &lt;code&gt;0.5.6&lt;/code&gt;.</source>
          <target state="translated">이 시점에서 &lt;em&gt;Cargo.lock&lt;/em&gt; 파일 에서 현재 사용중인 &lt;code&gt;rand&lt;/code&gt; 상자 의 버전 이 &lt;code&gt;0.5.6&lt;/code&gt; 이라는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ace63d2aec4c0fa2eb5be485664adddc5d8c8911" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;ve seen several ways of using patterns, but patterns don&amp;rsquo;t work the same in every place we can use them. In some places, the patterns must be irrefutable; in other circumstances, they can be refutable. We&amp;rsquo;ll discuss these two concepts next.</source>
          <target state="translated">이 시점에서 패턴을 사용하는 몇 가지 방법을 보았지만 패턴을 사용할 수있는 모든 곳에서 패턴이 동일하게 작동하지는 않습니다. 어떤 곳에서는 패턴을 반박 할 수 없어야합니다. 다른 상황에서는 반박 할 수 있습니다. 다음에이 두 가지 개념에 대해 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="e19eb30ab901969b293ab5f50d80d0816b9dd309" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;ve successfully built the guessing game. Congratulations!</source>
          <target state="translated">이제 추측 게임을 성공적으로 구축했습니다. 축하합니다!</target>
        </trans-unit>
        <trans-unit id="632731832807bd949f8afaff185b846c11bff1a6" translate="yes" xml:space="preserve">
          <source>Atomic Reference Counting with &lt;code id=&quot;atomic-reference-counting-with-arct&quot;&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;atomic-reference-counting-with-arct&quot;&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 사용한 원자 기준 카운팅</target>
        </trans-unit>
        <trans-unit id="81578fbf1ea44596108fd645f27e6431bf82318a" translate="yes" xml:space="preserve">
          <source>Atomic memory orderings</source>
          <target state="translated">원자 메모리 주문</target>
        </trans-unit>
        <trans-unit id="7d5338021e809e34d20a6b06646a458b5152b9dc" translate="yes" xml:space="preserve">
          <source>Atomic operations may be implemented at the instruction layer with larger-size atomics. For example some platforms use 4-byte atomic instructions to implement &lt;code&gt;AtomicI8&lt;/code&gt;. Note that this emulation should not have an impact on correctness of code, it's just something to be aware of.</source>
          <target state="translated">원자 연산은 더 큰 크기의 원자를 갖는 명령 계층에서 구현 될 수있다. 예를 들어, 일부 플랫폼은 4 바이트 원자 명령어를 사용하여 &lt;code&gt;AtomicI8&lt;/code&gt; 을 구현 합니다 . 이 에뮬레이션은 코드의 정확성에 영향을 미치지 않아야한다는 점에 유의해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e24008909c0fc6f23ca4f4f874bb53512815caa" translate="yes" xml:space="preserve">
          <source>Atomic operations with &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; semantics can also synchronize with a fence.</source>
          <target state="translated">&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 시맨틱을 사용한 원자 작업 은 펜스와 동기화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bd53298c2672a3d3501c1b3d668970f3f55e051" translate="yes" xml:space="preserve">
          <source>Atomic types</source>
          <target state="translated">원자 유형</target>
        </trans-unit>
        <trans-unit id="bd540eaa28be66ef79bdb0e6dc9e7f21a135c077" translate="yes" xml:space="preserve">
          <source>Atomic types may be stored in static variables, initialized using the constant initializers like &lt;a href=&quot;struct.atomicbool#method.new&quot;&gt;&lt;code&gt;AtomicBool::new&lt;/code&gt;&lt;/a&gt;. Atomic statics are often used for lazy global initialization.</source>
          <target state="translated">원자 유형은 정적 변수에 저장 될 수 있으며 &lt;a href=&quot;struct.atomicbool#method.new&quot;&gt; &lt;code&gt;AtomicBool::new&lt;/code&gt; &lt;/a&gt; 와 같은 상수 이니셜 라이저를 사용하여 초기화 됩니다. 원자 정적은 종종 게으른 전역 초기화에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af8191cce263e5511ffa70b9167ccc44038ee579" translate="yes" xml:space="preserve">
          <source>Atomic types provide primitive shared-memory communication between threads, and are the building blocks of other concurrent types.</source>
          <target state="translated">원자 유형은 스레드간에 기본 공유 메모리 통신을 제공하며 다른 동시 유형의 빌딩 블록입니다.</target>
        </trans-unit>
        <trans-unit id="489ec10910f60409e46dc7b2401064ba30bfb22a" translate="yes" xml:space="preserve">
          <source>Atomic variables are safe to share between threads (they implement &lt;a href=&quot;../../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;) but they do not themselves provide the mechanism for sharing and follow the &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;threading model&lt;/a&gt; of Rust. The most common way to share an atomic variable is to put it into an &lt;a href=&quot;../struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; (an atomically-reference-counted shared pointer).</source>
          <target state="translated">원자 변수는 스레드간에 공유하기에 안전 하지만 ( &lt;a href=&quot;../../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 구현 ) 자체적으로 공유 메커니즘을 제공하고 Rust 의 &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;스레딩 모델&lt;/a&gt; 을 따르지는 않습니다 . 원자 변수를 공유하는 가장 일반적인 방법은 원자 변수를 &lt;a href=&quot;../struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; (원자 적으로 참조 계산 된 공유 포인터) 에 넣는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="bdcc7b682e49710ce243d11d666d0605dd24412a" translate="yes" xml:space="preserve">
          <source>Atomic variables are safe to share between threads (they implement &lt;a href=&quot;../../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;) but they do not themselves provide the mechanism for sharing and follow the &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;threading model&lt;/a&gt; of rust. The most common way to share an atomic variable is to put it into an &lt;a href=&quot;../struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; (an atomically-reference-counted shared pointer).</source>
          <target state="translated">원자 변수는 스레드간에 공유하기에 안전 하지만 ( &lt;a href=&quot;../../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 구현 ) 스레드 자체 의 녹 &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;모델&lt;/a&gt; 을 공유하고 따르는 메커니즘을 제공하지는 않습니다 . 원자 변수를 공유하는 가장 일반적인 방법은에 넣어하는 &lt;a href=&quot;../struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; (극히 미세 - 참조 카운트 공유 포인터).</target>
        </trans-unit>
        <trans-unit id="6674d00db7a2e69964175c1325e3eccae698e4d3" translate="yes" xml:space="preserve">
          <source>AtomicBool</source>
          <target state="translated">AtomicBool</target>
        </trans-unit>
        <trans-unit id="c3f581e842f52532b7b151cdbc4ce7233b954e8c" translate="yes" xml:space="preserve">
          <source>AtomicI16</source>
          <target state="translated">AtomicI16</target>
        </trans-unit>
        <trans-unit id="29b774c369d481cc7134a7a13427afa21b7fc9cd" translate="yes" xml:space="preserve">
          <source>AtomicI32</source>
          <target state="translated">AtomicI32</target>
        </trans-unit>
        <trans-unit id="d734b8bd0031516fdc53fb6831e8dec9b067b165" translate="yes" xml:space="preserve">
          <source>AtomicI64</source>
          <target state="translated">AtomicI64</target>
        </trans-unit>
        <trans-unit id="e94562e900680db9e18fda42ce322ce7a5e558bf" translate="yes" xml:space="preserve">
          <source>AtomicI8</source>
          <target state="translated">AtomicI8</target>
        </trans-unit>
        <trans-unit id="c2cc2ca63393294d4014028c732f15eca926e7a2" translate="yes" xml:space="preserve">
          <source>AtomicIsize</source>
          <target state="translated">AtomicIsize</target>
        </trans-unit>
        <trans-unit id="7bc45caa3c8c7a6bbad87dd4b67403e414361ce1" translate="yes" xml:space="preserve">
          <source>AtomicPtr</source>
          <target state="translated">AtomicPtr</target>
        </trans-unit>
        <trans-unit id="17a70c0c14e8b2c47d91d2253122896320428148" translate="yes" xml:space="preserve">
          <source>AtomicU16</source>
          <target state="translated">AtomicU16</target>
        </trans-unit>
        <trans-unit id="8840103173e424948e002b5ffec50c44e404d250" translate="yes" xml:space="preserve">
          <source>AtomicU32</source>
          <target state="translated">AtomicU32</target>
        </trans-unit>
        <trans-unit id="32ac2d92ec899ed90a2638fc480a4297cef99b45" translate="yes" xml:space="preserve">
          <source>AtomicU64</source>
          <target state="translated">AtomicU64</target>
        </trans-unit>
        <trans-unit id="a496370705e1f84302673bc11932128de26a2fea" translate="yes" xml:space="preserve">
          <source>AtomicU8</source>
          <target state="translated">AtomicU8</target>
        </trans-unit>
        <trans-unit id="9d9469a55330492f15842defa35b0f1ef07cac12" translate="yes" xml:space="preserve">
          <source>AtomicUsize</source>
          <target state="translated">AtomicUsize</target>
        </trans-unit>
        <trans-unit id="48c5fb201c75414dd3666a318d954dd873099b2d" translate="yes" xml:space="preserve">
          <source>Atomically makes the handle's token available if it is not already.</source>
          <target state="translated">핸들의 토큰을 아직 사용할 수없는 경우 원자 적으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="22cd0cbd81dee9dcd227285a4fb456261af24ea4" translate="yes" xml:space="preserve">
          <source>Atomics</source>
          <target state="translated">Atomics</target>
        </trans-unit>
        <trans-unit id="fe4c2e56ace1dd5cd16118bb6ad5e5256c61db83" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the &lt;code&gt;Arc&amp;lt;dyn Any + Send + Sync&amp;gt;&lt;/code&gt; to a concrete type.</source>
          <target state="translated">&lt;code&gt;Arc&amp;lt;dyn Any + Send + Sync&amp;gt;&lt;/code&gt; 를 콘크리트 유형 으로 다운 캐스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="92df3d44a91e7d67c064d6d725fec8b2e940cc64" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the &lt;code&gt;Rc&amp;lt;dyn Any&amp;gt;&lt;/code&gt; to a concrete type.</source>
          <target state="translated">&lt;code&gt;Rc&amp;lt;dyn Any&amp;gt;&lt;/code&gt; 를 콘크리트 유형 으로 다운 캐스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="886d23c3fa7b51635fa7bbdd282f2babcd6cb45c" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the box to a concrete type.</source>
          <target state="translated">상자를 콘크리트 유형으로 다운 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="175cf296f94bed8278b4e811c5245f622f67f97c" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available.</source>
          <target state="translated">값을 아직 사용할 수없는 경우 현재 작업을 깨우기 위해 현재 작업을 등록하여 미래를 최종 값으로 해결하려고합니다.</target>
        </trans-unit>
        <trans-unit id="0b1794f780a4845e82f1aa618849777a9e5b6e42" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available. &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">값을 아직 사용할 수없는 경우 현재 작업을 깨우기 위해 현재 작업을 등록하여 미래를 최종 값으로 해결하려고합니다. &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55136df45140cab2915451715291fdde1ced9b25" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available. &lt;a href=&quot;future/trait.future#tymethod.poll&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">값을 아직 사용할 수없는 경우 현재 작업을 깨우기 위해 현재 작업을 등록하여 미래를 최종 값으로 해결하려고합니다. &lt;a href=&quot;future/trait.future#tymethod.poll&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="856e8b63203e04805b09dd95b9d3481ff3097c22" translate="yes" xml:space="preserve">
          <source>Attempt was made to import an item whereas an extern crate with this name has already been imported.</source>
          <target state="translated">아이템을 가져 오려고 시도했지만이 이름의 외계 상자가 이미 가져 왔습니다.</target>
        </trans-unit>
        <trans-unit id="5fc738aa7f6254311ae3614b150f4fe1cec8fe27" translate="yes" xml:space="preserve">
          <source>Attempt was made to import an unimportable value. This can happen when trying to import a method from a trait.</source>
          <target state="translated">가져올 수없는 값을 가져 오려고했습니다. 이것은 특성에서 메소드를 가져 오려고 할 때 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c61d256e7903ca5ede61e01fd8467962bbb349b" translate="yes" xml:space="preserve">
          <source>Attempted to access a field on a primitive type.</source>
          <target state="translated">기본 유형의 필드에 액세스하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="a54332e7df630f85a467d7ec89246d77c007b643" translate="yes" xml:space="preserve">
          <source>Attempted to access a method like a field.</source>
          <target state="translated">필드와 같은 메소드에 액세스하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="48f28400d9c83d5af115ff62dc11ba5e26ca8457" translate="yes" xml:space="preserve">
          <source>Attempted to access a non-existent field in a struct.</source>
          <target state="translated">구조체에서 존재하지 않는 필드에 액세스하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="03b41486da885815831596a9c99e4264efdf5d06" translate="yes" xml:space="preserve">
          <source>Attempted to access a private field on a struct.</source>
          <target state="translated">구조체의 개인 필드에 액세스하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="a1ad3c1a31bd1ae534677401ea798535b99a38e5" translate="yes" xml:space="preserve">
          <source>Attempted to call something which isn't a function nor a method.</source>
          <target state="translated">함수 나 메소드가 아닌 것을 호출하려고 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="19e440b538f0d8907b6a787acfc5bb52be0236f7" translate="yes" xml:space="preserve">
          <source>Attempted to cast to/from a pointer with an unknown kind.</source>
          <target state="translated">알 수없는 종류의 포인터로 /에서 캐스트를 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="eef4156ee856f3204829c854633733e0594d2319" translate="yes" xml:space="preserve">
          <source>Attempted to dereference a variable which cannot be dereferenced.</source>
          <target state="translated">역 참조 할 수없는 변수를 역 참조하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="1372db0ea32a319cb23e92d2e2d51b6cd2d1a4fb" translate="yes" xml:space="preserve">
          <source>Attempted to pass an invalid type of variable into a variadic function.</source>
          <target state="translated">변수 유형이 잘못된 변수에 변수를 전달하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="7adfef6b18f86865559fc727494e616e0b3f7f80" translate="yes" xml:space="preserve">
          <source>Attempting to compile now gives us the following output:</source>
          <target state="translated">컴파일을 시도하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e83036683d0914f18e7de7ebbb8a14c9db8b6c5c" translate="yes" xml:space="preserve">
          <source>Attempting to compile this code results in this type error:</source>
          <target state="translated">이 코드를 컴파일하려고하면 다음과 같은 유형의 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="71aec9a6c07f86af18ab65ed514253e4a11e1117" translate="yes" xml:space="preserve">
          <source>Attempting to create a &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; iterator from an improperly formatted socket address &lt;code&gt;&amp;amp;str&lt;/code&gt; (missing the port):</source>
          <target state="translated">형식이 잘못된 소켓 주소 &lt;code&gt;&amp;amp;str&lt;/code&gt; (포트 누락) 에서 &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; 반복자 를 작성하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="ef35b76897ce014407ed31f4f40475dbcd2bb582" translate="yes" xml:space="preserve">
          <source>Attempting to create a raw pointer to an &lt;code&gt;unaligned&lt;/code&gt; struct field with an expression such as &lt;code&gt;&amp;amp;packed.unaligned as *const FieldType&lt;/code&gt; creates an intermediate unaligned reference before converting that to a raw pointer. That this reference is temporary and immediately cast is inconsequential as the compiler always expects references to be properly aligned. As a result, using &lt;code&gt;&amp;amp;packed.unaligned as *const FieldType&lt;/code&gt; causes immediate &lt;em&gt;undefined behavior&lt;/em&gt; in your program.</source>
          <target state="translated">&lt;code&gt;&amp;amp;packed.unaligned as *const FieldType&lt;/code&gt; 으로 &amp;amp; packed.unaligned 와 같은 표현식 을 사용하여 &lt;code&gt;unaligned&lt;/code&gt; 구조체 필드에 대한 원시 포인터를 만들려고 시도하면 정렬되지 않은 중간 참조가 생성되어 원시 포인터로 변환됩니다. 컴파일러가 항상 참조가 적절하게 정렬 될 것으로 예상하기 때문에이 참조가 임시적이며 즉시 캐스트되는 것은 중요하지 않습니다. 결과적으로 &lt;code&gt;&amp;amp;packed.unaligned as *const FieldType&lt;/code&gt; 하면 프로그램에서 즉시 &lt;em&gt;정의되지 않은 동작이&lt;/em&gt; 발생합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="baf8e0e513c1e7d75d1c56986d1f69437e36903e" translate="yes" xml:space="preserve">
          <source>Attempting to create a trait object for a non object-safe trait will trigger this error.</source>
          <target state="translated">객체 안전이 아닌 형질에 대한 형질 개체를 만들려고하면이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fcaf285fe223ac76c6b6f3a248ca791f9480d826" translate="yes" xml:space="preserve">
          <source>Attempts to acquire this lock.</source>
          <target state="translated">이 잠금을 얻으려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="ed9809bcb2ab4f39482ae3c8ecc3990c35b19e02" translate="yes" xml:space="preserve">
          <source>Attempts to acquire this rwlock with shared read access.</source>
          <target state="translated">공유 읽기 액세스 권한으로이 rwlock을 확보하려고합니다.</target>
        </trans-unit>
        <trans-unit id="855d837817da86285b7a962a1f7fe2fb0ca3b0f2" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory. &lt;a href=&quot;alloc/trait.allocref#tymethod.alloc&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">메모리 블록 할당을 시도합니다. &lt;a href=&quot;alloc/trait.allocref#tymethod.alloc&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cba17f171bdff89eb9e4d13d3205c5589ee7c0ea" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory. &lt;a href=&quot;trait.allocref#tymethod.alloc&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">메모리 블록 할당을 시도합니다. &lt;a href=&quot;trait.allocref#tymethod.alloc&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa06f6d37e15f994598953d5d55e85873c353cbb" translate="yes" xml:space="preserve">
          <source>Attempts to collect the exit status of the child if it has already exited.</source>
          <target state="translated">이미 종료 된 하위의 종료 상태를 수집하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="2ba2351b2e57e9559c0f3714a76ac923ea85c4c4" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i128&lt;/code&gt; to &lt;code&gt;NonZeroI128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i128&lt;/code&gt; 을 &lt;code&gt;NonZeroI128&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="2730452bbdf6d0154f196dd3387e5268fcbaae6d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i16&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i16&lt;/code&gt; 을 &lt;code&gt;NonZeroI16&lt;/code&gt; 으로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="89a676b16e76690126c8c689d7093c8a36a6dc3d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i32&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i32&lt;/code&gt; 를 &lt;code&gt;NonZeroI32&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="af2f75ee1f964bb69b3471df2010cd26d4f8b3c4" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i64&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i64&lt;/code&gt; 를 &lt;code&gt;NonZeroI64&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="c93de3bc4194ab8f5cef5b860227606b9963f2e3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i8&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i8&lt;/code&gt; 을 &lt;code&gt;NonZeroI8&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="6042fa62c1123d272cfaedcf34e40785b595efa5" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;isize&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isize&lt;/code&gt; 를 &lt;code&gt;NonZeroIsize&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="d44685c697bf86bf627255f318a92026c3067b36" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u128&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;u128&lt;/code&gt; 을 &lt;code&gt;NonZeroU128&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="83f6c21bb3f0a85bb02b720c0facffc143df545d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u16&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;u16&lt;/code&gt; 을 &lt;code&gt;NonZeroU16&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="4f25fe04e2aca5c5faadb4cc9021f2c2472cc8a3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u32&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;u32&lt;/code&gt; 를 &lt;code&gt;NonZeroU32&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="dbf97d063f75afad6228d1db287eb0de45a1ab04" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u64&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;u64&lt;/code&gt; 를 &lt;code&gt;NonZeroU64&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="89d08d408000b79c0c0f0951f917eed73ebef3a3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u8&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;u8&lt;/code&gt; 을 &lt;code&gt;NonZeroU8&lt;/code&gt; 로 변환하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="8cee9eaea9548154103d038cde6240ee1cc68830" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;usize&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;usize&lt;/code&gt; 를 &lt;code&gt;NonZeroUsize&lt;/code&gt; 로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="2d9e42b5d35e242781f009f21f3c5ea257d9b8d7" translate="yes" xml:space="preserve">
          <source>Attempts to converts a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;u8&amp;gt;&lt;/code&gt; to a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;u8&amp;gt;&lt;/code&gt; 을 &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; 으로 변환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="8d17c0e55fb5767927f25b2be2aaccc4cffbef7d" translate="yes" xml:space="preserve">
          <source>Attempts to downcast the box to a concrete type.</source>
          <target state="translated">상자를 구체적인 유형으로 다운 캐스트하려고합니다.</target>
        </trans-unit>
        <trans-unit id="2067ade47b4e19fcd748b5622bcd5a578000fa70" translate="yes" xml:space="preserve">
          <source>Attempts to extend the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 이 참조하는 할당 을 &lt;code&gt;new_size&lt;/code&gt; 에 맞게 확장하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="1f0524b8bf45261cb2e5192b808b5a4a85102e03" translate="yes" xml:space="preserve">
          <source>Attempts to extend the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.grow_in_place&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 이 참조하는 할당 을 &lt;code&gt;new_size&lt;/code&gt; 에 맞게 확장하려고 시도합니다 . &lt;a href=&quot;trait.alloc#method.grow_in_place&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="27c873a148fefc84fd64a13dc7df4ae1e7fa3719" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block. &lt;a href=&quot;alloc/trait.allocref#method.grow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">메모리 블록 확장을 시도합니다. &lt;a href=&quot;alloc/trait.allocref#method.grow&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="adef0a0225d086130a40a297ad3ad900429332c4" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block. &lt;a href=&quot;trait.allocref#method.grow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">메모리 블록 확장을 시도합니다. &lt;a href=&quot;trait.allocref#method.grow&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14aa482507a26cdd1d3724ec04b0d14909b4ce76" translate="yes" xml:space="preserve">
          <source>Attempts to lock this rwlock with exclusive write access.</source>
          <target state="translated">독점적 인 쓰기 액세스 권한으로이 rwlock을 잠그려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="3e149a02e4c5943a78110a9fe37e7dfdc1377a23" translate="yes" xml:space="preserve">
          <source>Attempts to open a file in read-only mode.</source>
          <target state="translated">파일을 읽기 전용 모드로 열려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="ce00391cd1170f4f9f1ed2dc7adb3e45ca14e46a" translate="yes" xml:space="preserve">
          <source>Attempts to return a pending value on this receiver without blocking.</source>
          <target state="translated">차단하지 않고이 수신자에서 보류중인 값을 리턴하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="88500c10aaa3c7978ed8857be5643440673d4380" translate="yes" xml:space="preserve">
          <source>Attempts to send a value on this channel without blocking.</source>
          <target state="translated">차단하지 않고이 채널에서 값을 보내려고합니다.</target>
        </trans-unit>
        <trans-unit id="44fed3b4d1c2db46234c4d30a1056c0ccd124c87" translate="yes" xml:space="preserve">
          <source>Attempts to send a value on this channel, returning it back if it could not be sent.</source>
          <target state="translated">이 채널에서 값을 보내려고 시도하여 보낼 수없는 경우 되돌립니다.</target>
        </trans-unit>
        <trans-unit id="6da3e262b2372fb386666634b5d39f9d3f7bb80a" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new_size&lt;/code&gt; 에 맞게 &lt;code&gt;ptr&lt;/code&gt; 이 참조하는 할당을 축소하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="d9dd72c543bd49d83f78f0fdf1367b07147238f9" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.shrink_in_place&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;new_size&lt;/code&gt; 에 맞게 &lt;code&gt;ptr&lt;/code&gt; 이 참조하는 할당을 축소하려고 시도합니다 . &lt;a href=&quot;trait.alloc#method.shrink_in_place&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b70a3bb894ec313a60c83cc036390a2df8753cb7" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block. &lt;a href=&quot;alloc/trait.allocref#method.shrink&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">메모리 블록 축소를 시도합니다. &lt;a href=&quot;alloc/trait.allocref#method.shrink&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96e65f083a95479e0e7fff8e23938d5ab69fdc1f" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block. &lt;a href=&quot;trait.allocref#method.shrink&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">메모리 블록 축소를 시도합니다. &lt;a href=&quot;trait.allocref#method.shrink&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d431ee47732f5fda5d822308d953fb6c4ab546af" translate="yes" xml:space="preserve">
          <source>Attempts to sync all OS-internal metadata to disk.</source>
          <target state="translated">모든 OS 내부 메타 데이터를 디스크에 동기화하려고합니다.</target>
        </trans-unit>
        <trans-unit id="bd1357cf9c16c8860cced8547ac6ac2266fff48b" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, delaying dropping of the inner value if successful.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터를 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 로 업그레이드하려고 시도하여 성공하면 내부 값 삭제를 지연시킵니다.</target>
        </trans-unit>
        <trans-unit id="e1a28bf0ca8943d3102fb17a5f930dbd42c32e93" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, extending the lifetime of the value if successful.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터를 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 로 업그레이드하여 성공하면 값의 수명을 연장합니다.</target>
        </trans-unit>
        <trans-unit id="3f7dd7ca12e8b115613fa365887978f9fb146c24" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, delaying dropping of the inner value if successful.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터를 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 로 업그레이드하려고 시도하여 성공하면 내부 값 삭제를 지연시킵니다.</target>
        </trans-unit>
        <trans-unit id="c10f653d6058260dd8df6597f6fc625f0e90a7a2" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, extending the lifetime of the value if successful.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터를 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 로 업그레이드하여 성공하면 값의 수명을 연장합니다.</target>
        </trans-unit>
        <trans-unit id="4ed9981b4c97d4946f7cc66f3d69625251a285c0" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up, or if &lt;code&gt;deadline&lt;/code&gt; is reached.</source>
          <target state="translated">이 수신기에서 값을 기다리려고 시도하여 해당 채널이 끊어 지거나 &lt;code&gt;deadline&lt;/code&gt; 에 도달 하면 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="eea7708f089d17a724b4fe150c8a5b22b7b7cd15" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up, or if it waits more than &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">이 수신기에서 값을 기다리려고 시도하여 해당 채널이 중단되었거나 &lt;code&gt;timeout&lt;/code&gt; 이상 대기하면 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c5624ed9b3f4c32e9214ed479d11bee18fe54f2a" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up.</source>
          <target state="translated">이 수신기에서 값을 기다리려고 시도하여 해당 채널이 끊어지면 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="66681ba198baa628940b6e0e8d1d21d555ae1a8d" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer.</source>
          <target state="translated">이 기록기에 전체 버퍼를 쓰려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="50c44c33216c75388385c7158cbb2db3b18cd276" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;../../../io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 기록기에 전체 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;../../../io/trait.write#method.write_all&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb65a661c9940f60efcdfd42e570120d00134516" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 기록기에 전체 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7537ca8f100350d628ddd2455b7d2b9261e91786" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 기록기에 전체 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;io/trait.write#method.write_all&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4a079954569cfca76bb04671c6eef0de6f2845b" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 기록기에 전체 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;trait.write#method.write_all&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3a4550331cd75411aa797d05589ea44d59948931" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer starting from a given offset.</source>
          <target state="translated">주어진 오프셋에서 시작하여 전체 버퍼를 쓰려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="bd08d9b38e39a23845ecac7733a7135e68b5844b" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer starting from a given offset. &lt;a href=&quot;../os/unix/fs/trait.fileext#method.write_all_at&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">주어진 오프셋에서 시작하여 전체 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;../os/unix/fs/trait.fileext#method.write_all_at&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3cd154a661d834b07894c77674ab8ed918e6d062" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer.</source>
          <target state="translated">이 기록기에 여러 버퍼를 쓰려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="fc422df0d6aeefc153e9d11191c7acdab0fee066" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;../../../io/trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 기록기에 여러 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;../../../io/trait.write#method.write_all_vectored&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef049b1e411811d76553b0e75329cbd0d79e8485" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;../io/trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 기록기에 여러 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;../io/trait.write#method.write_all_vectored&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59af638438e522a4fe5eaeba810e068e6c90b8b0" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;io/trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 기록기에 여러 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;io/trait.write#method.write_all_vectored&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d6a58aa82ce87e3367d27cafec071fe08afba77" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 기록기에 여러 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;trait.write#method.write_all_vectored&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63578c033690b22f88448dc9020fc65119c91cf5" translate="yes" xml:space="preserve">
          <source>Attribute contains same meta item more than once.</source>
          <target state="translated">속성에 동일한 메타 항목이 두 번 이상 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="645ef54c5f28a9cf578382e9466764d3ebe4899c" translate="yes" xml:space="preserve">
          <source>Attribute macros</source>
          <target state="translated">속성 매크로</target>
        </trans-unit>
        <trans-unit id="1a7e3b192d591463acc213e348e2d3be95158e41" translate="yes" xml:space="preserve">
          <source>Attribute macros are defined by a &lt;a href=&quot;visibility-and-privacy&quot;&gt;public&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; with the &lt;code&gt;proc_macro_attribute&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; that has a signature of &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt;. The first &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the delimited token tree following the attribute's name, not including the outer delimiters. If the attribute is written as a bare attribute name, the attribute &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is empty. The second &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the rest of the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; including other &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; on the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt;. The returned &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; replaces the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; with an arbitrary number of &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">속성 매크로는 &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt; 의 서명이있는 &lt;code&gt;proc_macro_attribute&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 을 사용하여 &lt;a href=&quot;visibility-and-privacy&quot;&gt;공용 &lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;함수에&lt;/a&gt; 의해 정의됩니다 . 첫 번째 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 은 속성 이름 다음에 나오는 구분 된 토큰 트리이며 외부 구분 기호를 포함하지 않습니다. 속성이 베어 속성 이름으로 작성되면 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 속성 이 비어 있습니다. 두 번째 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;items&quot;&gt;항목의&lt;/a&gt; 다른 &lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 을 포함 하는 나머지 &lt;a href=&quot;items&quot;&gt;항목&lt;/a&gt; 입니다. 반환 된 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;items&quot;&gt;항목&lt;/a&gt; 을 임의의 수로 대체합니다.&lt;a href=&quot;items&quot;&gt;항목&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="859156ebbcd8a20df68582e72c9cb8ebb2f8d6d9" translate="yes" xml:space="preserve">
          <source>Attribute macros are defined by a &lt;a href=&quot;visibility-and-privacy&quot;&gt;public&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; with the &lt;code&gt;proc_macro_attribute&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; that has a signature of &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt;. The first &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the delimited token tree following the attribute's name, not including the outer delimiters. If the attribute is written as a bare attribute name, the attribute &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is empty. The second &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the rest of the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; including other &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; on the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt;. The returned &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; replaces the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; with an arbitrary number of &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;. These macros cannot expand to syntax that defines new &lt;code&gt;macro_rules&lt;/code&gt; style macros.</source>
          <target state="translated">속성 매크로는 &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt; 의 서명이있는 &lt;code&gt;proc_macro_attribute&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 을 가진 &lt;a href=&quot;visibility-and-privacy&quot;&gt;공용 &lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;함수에&lt;/a&gt; 의해 정의됩니다 . 첫 번째 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 은 외부 구분자를 포함하지 않고 속성 이름 뒤에 구분 된 토큰 트리입니다. 속성이 기본 속성 이름으로 작성된 경우 속성 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 이 비어 있습니다. 두 번째 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;items&quot;&gt;항목의&lt;/a&gt; 다른 &lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 을 포함한 나머지 &lt;a href=&quot;items&quot;&gt;항목&lt;/a&gt; 입니다. 반환 된 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;items&quot;&gt;항목&lt;/a&gt; 을 임의의 숫자로 바꿉니다.&lt;a href=&quot;items&quot;&gt;품목&lt;/a&gt; . 이러한 매크로는 새로운 &lt;code&gt;macro_rules&lt;/code&gt; 스타일 매크로 를 정의하는 구문으로 확장 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e9cdb4472ce392123fa434d8e8286aab92c7c80b" translate="yes" xml:space="preserve">
          <source>Attribute-like macros</source>
          <target state="translated">속성과 유사한 매크로</target>
        </trans-unit>
        <trans-unit id="59290a10bc07737a4a9b4b98cbfa7a104e8da35e" translate="yes" xml:space="preserve">
          <source>Attribute-like macros are similar to custom derive macros, but instead of generating code for the &lt;code&gt;derive&lt;/code&gt; attribute, they allow you to create new attributes. They&amp;rsquo;re also more flexible: &lt;code&gt;derive&lt;/code&gt; only works for structs and enums; attributes can be applied to other items as well, such as functions. Here&amp;rsquo;s an example of using an attribute-like macro: say you have an attribute named &lt;code&gt;route&lt;/code&gt; that annotates functions when using a web application framework:</source>
          <target state="translated">속성 유사 매크로는 사용자 지정 파생 매크로와 유사하지만 &lt;code&gt;derive&lt;/code&gt; 속성에 대한 코드를 생성하는 대신 새 속성을 만들 수 있습니다. 그들은 또한 더 유연한 위치 : &lt;code&gt;derive&lt;/code&gt; 에만 구조체와 열거 작동; 함수와 같은 다른 항목에도 속성을 적용 할 수 있습니다. 다음은 속성과 유사한 매크로를 사용하는 예입니다 . 웹 애플리케이션 프레임 워크를 사용할 때 함수에 주석을 추가하는 &lt;code&gt;route&lt;/code&gt; 라는 속성이 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec087a512ee5c8fbe6233f1c1cc119ebd6524585" translate="yes" xml:space="preserve">
          <source>Attribute-like macros that define custom attributes usable on any item</source>
          <target state="translated">모든 항목에서 사용 가능한 사용자 정의 속성을 정의하는 속성과 유사한 매크로</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="873679be0cfb954acbd8355a7b353607aec111e8" translate="yes" xml:space="preserve">
          <source>Attributes can be classified into the following kinds:</source>
          <target state="translated">속성은 다음과 같은 종류로 분류 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f75246581fb116635159a5829418eadb80ff6d3d" translate="yes" xml:space="preserve">
          <source>Attributes may be applied to many things in the language:</source>
          <target state="translated">언어의 많은 것들에 속성이 적용될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="54528912cd579e0bc00be1a8a68e351287624bb1" translate="yes" xml:space="preserve">
          <source>Attributes on Implementations</source>
          <target state="translated">구현의 속성</target>
        </trans-unit>
        <trans-unit id="37b3e9d71f1e2b7a16d851acde890909a1eeac05" translate="yes" xml:space="preserve">
          <source>Attributes on Modules</source>
          <target state="translated">모듈의 속성</target>
        </trans-unit>
        <trans-unit id="bd970fc906dcf4e6b3d5342f7f8f7b6b3fc07d29" translate="yes" xml:space="preserve">
          <source>Attributes on Statements</source>
          <target state="translated">진술의 속성</target>
        </trans-unit>
        <trans-unit id="002821d69ecf6475cc851545267b8d3000e1ad75" translate="yes" xml:space="preserve">
          <source>Attributes on block expressions</source>
          <target state="translated">블록 표현식의 속성</target>
        </trans-unit>
        <trans-unit id="9c665fd3a622574987a78d02ed515c34731bae9e" translate="yes" xml:space="preserve">
          <source>Attributes on closure parameters</source>
          <target state="translated">클로저 매개 변수의 속성</target>
        </trans-unit>
        <trans-unit id="9b9724999b0840379dc53e44bc7f9fc3b9f933c5" translate="yes" xml:space="preserve">
          <source>Attributes on closure parameters follow the same rules and restrictions as &lt;a href=&quot;../items/functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="translated">클로저 매개 변수의 속성은 &lt;a href=&quot;../items/functions#attributes-on-function-parameters&quot;&gt;일반 함수 매개 변수&lt;/a&gt; 와 동일한 규칙 및 제한을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="ceeb23e9fab4cfc5da27d608e1b53f610954cf73" translate="yes" xml:space="preserve">
          <source>Attributes on extern blocks</source>
          <target state="translated">인턴 블록의 속성</target>
        </trans-unit>
        <trans-unit id="2b100159215337704a6b1e09760f5eccf7526a5d" translate="yes" xml:space="preserve">
          <source>Attributes on extern function parameters follow the same rules and restrictions as &lt;a href=&quot;functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="translated">extern 함수 매개 변수의 속성은 &lt;a href=&quot;functions#attributes-on-function-parameters&quot;&gt;일반 함수 매개 변수&lt;/a&gt; 와 동일한 규칙 및 제한 사항을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="59c13f89c0293ca7012e37e58c92591846eac3f7" translate="yes" xml:space="preserve">
          <source>Attributes on function parameters</source>
          <target state="translated">함수 매개 변수의 속성</target>
        </trans-unit>
        <trans-unit id="ed27ab14062c4e9a4e3408735f20ce008b94ed1f" translate="yes" xml:space="preserve">
          <source>Attributes on function pointer parameters</source>
          <target state="translated">함수 포인터 매개 변수의 속성</target>
        </trans-unit>
        <trans-unit id="d19964d112392f9f4c6dafbc3caa5ef3b3d5eb10" translate="yes" xml:space="preserve">
          <source>Attributes on function pointer parameters follow the same rules and restrictions as &lt;a href=&quot;../items/functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="translated">함수 포인터 매개 변수의 속성은 &lt;a href=&quot;../items/functions#attributes-on-function-parameters&quot;&gt;일반 함수 매개 변수&lt;/a&gt; 와 동일한 규칙 및 제한을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="3cccaf98e2daf69778514e782644b524ef8bcdb7" translate="yes" xml:space="preserve">
          <source>Attributes on functions</source>
          <target state="translated">함수의 속성</target>
        </trans-unit>
        <trans-unit id="05e9060a13a0e0d138adc8680df67a664480dcc8" translate="yes" xml:space="preserve">
          <source>Attributes on match arms</source>
          <target state="translated">시합 암의 속성</target>
        </trans-unit>
        <trans-unit id="2af6ac2f621f1343b06367e7a182dd005ff55bf7" translate="yes" xml:space="preserve">
          <source>Attributes on method parameters</source>
          <target state="translated">메소드 매개 변수의 속성</target>
        </trans-unit>
        <trans-unit id="09d4e80c9597ea7a33de2f4472d2c8f5b6ac76e0" translate="yes" xml:space="preserve">
          <source>Attributes on method parameters follow the same rules and restrictions as &lt;a href=&quot;functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="translated">메소드 매개 변수의 속성은 &lt;a href=&quot;functions#attributes-on-function-parameters&quot;&gt;일반 함수 매개 변수&lt;/a&gt; 와 동일한 규칙 및 제한 사항을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="4692270821bce03e7c9c56f2250b4d84c0ed4e73" translate="yes" xml:space="preserve">
          <source>Augments &lt;code&gt;AllocErr&lt;/code&gt; with a CapacityOverflow variant.</source>
          <target state="translated">증강 &lt;code&gt;AllocErr&lt;/code&gt; CapacityOverflow 변형과 함께.</target>
        </trans-unit>
        <trans-unit id="18a0388aaf485c373d9fa2601ae76a1e2a8efdf4" translate="yes" xml:space="preserve">
          <source>Austin Group Bugzilla</source>
          <target state="translated">오스틴 그룹 부질 라</target>
        </trans-unit>
        <trans-unit id="e84cdcfde23e335b70dccbea7484975e25932774" translate="yes" xml:space="preserve">
          <source>Auto Trait Implementations</source>
          <target state="translated">자동 특성 구현</target>
        </trans-unit>
        <trans-unit id="3210ce5fd6c71ac203dc3858abcda035931c425a" translate="yes" xml:space="preserve">
          <source>Auto implementors</source>
          <target state="translated">자동 구현 자</target>
        </trans-unit>
        <trans-unit id="883a358e80c549bb53d94b1393e3b00efd025f86" translate="yes" xml:space="preserve">
          <source>Auto traits</source>
          <target state="translated">자동 특성</target>
        </trans-unit>
        <trans-unit id="907a84f140f8fccdc36e6967fab33354d93f68e0" translate="yes" xml:space="preserve">
          <source>Auto traits can also have negative implementations, shown as &lt;code&gt;impl !AutoTrait for T&lt;/code&gt; in the standard library documentation, that override the automatic implementations. For example &lt;code&gt;*mut T&lt;/code&gt; has a negative implementation of &lt;code&gt;Send&lt;/code&gt;, and so &lt;code&gt;*mut T&lt;/code&gt; is not &lt;code&gt;Send&lt;/code&gt;, even if &lt;code&gt;T&lt;/code&gt; is. There is currently no stable way to specify additional negative implementations; they exist only in the standard library.</source>
          <target state="translated">자동 특성은 표준 구현 문서에서 &lt;code&gt;impl !AutoTrait for T&lt;/code&gt; 로 표시되는 자동 구현을 무시하는 부정적인 구현을 가질 수도 있습니다 . 예를 들어 &lt;code&gt;*mut T&lt;/code&gt; 의 음의 구현이 &lt;code&gt;Send&lt;/code&gt; 등 &lt;code&gt;*mut T&lt;/code&gt; 되지 않는다 &lt;code&gt;Send&lt;/code&gt; 경우에도, &lt;code&gt;T&lt;/code&gt; 가 있습니다. 현재 추가적인 부정적인 구현을 지정하는 안정적인 방법은 없습니다. 그것들은 표준 라이브러리에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="eed6125b479d147f9973b57bfcd959c6cdf11e7c" translate="yes" xml:space="preserve">
          <source>Auto traits cannot have methods or associated items. For more information see the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot;&gt;opt-in builtin traits RFC&lt;/a&gt;.</source>
          <target state="translated">자동 특성에는 방법 또는 관련 항목이있을 수 없습니다. 자세한 정보는 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot;&gt;옵트 인 내장 특성 RFC를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="589d3531f6899aa76d5a037b26ecc86cf31af6da" translate="yes" xml:space="preserve">
          <source>Auto traits may be added as an additional bound to any &lt;a href=&quot;types/trait-object&quot;&gt;trait object&lt;/a&gt;, even though normally only one trait is allowed. For instance, &lt;code&gt;Box&amp;lt;dyn Debug + Send + UnwindSafe&amp;gt;&lt;/code&gt; is a valid type.</source>
          <target state="translated">일반적으로 하나의 특성 만 허용 되더라도 자동 특성은 모든 &lt;a href=&quot;types/trait-object&quot;&gt;특성 오브젝트에&lt;/a&gt; 대한 추가 바인딩으로 추가 될 수 있습니다 . 예를 들어 &lt;code&gt;Box&amp;lt;dyn Debug + Send + UnwindSafe&amp;gt;&lt;/code&gt; 는 유효한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="7ab019d8f27eff675f0469b46eedbbd5bc764f0c" translate="yes" xml:space="preserve">
          <source>Auto traits such as Send and Sync are an exception to this rule: It's possible to have bounds of one non-builtin trait, plus any number of auto traits. For example, the following compiles correctly:</source>
          <target state="translated">보내기 및 동기화와 같은 자동 특성은이 규칙에서 예외입니다. 기본 제공되지 않은 특성 하나와 여러 가지 자동 특성을 사용할 수 있습니다. 예를 들어 다음은 올바르게 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="291824a57cec52e3b37ba600a0c8891145191849" translate="yes" xml:space="preserve">
          <source>Auto-&lt;code&gt;deref&lt;/code&gt; is undesirable; for example, distinguishing between methods on a smart pointer itself and the pointer's referent</source>
          <target state="translated">자동 &lt;code&gt;deref&lt;/code&gt; 바람직하지 않다; 예를 들어, 스마트 포인터 자체의 메소드와 포인터의 참조자를 구별</target>
        </trans-unit>
        <trans-unit id="07a06ac20697a76a3d6c77f425115fda11438cdd" translate="yes" xml:space="preserve">
          <source>Automatic Formatting with &lt;code id=&quot;automatic-formatting-with-rustfmt&quot;&gt;rustfmt&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;automatic-formatting-with-rustfmt&quot;&gt;rustfmt&lt;/code&gt; 를 사용한 자동 서식</target>
        </trans-unit>
        <trans-unit id="fd22060c7b367de18d29110de1ffaa7a8381ad30" translate="yes" xml:space="preserve">
          <source>Available features</source>
          <target state="translated">사용 가능한 기능</target>
        </trans-unit>
        <trans-unit id="25bea30bca4696d831be0e14c1144f604b2efac9" translate="yes" xml:space="preserve">
          <source>Awesome! We now have a simple web server in approximately 40 lines of Rust code that responds to one request with a page of content and responds to all other requests with a 404 response.</source>
          <target state="translated">대박! 이제 약 40 줄의 Rust 코드로 된 간단한 웹 서버를 사용하여 한 페이지의 콘텐츠로 하나의 요청에 응답하고 404 응답으로 다른 모든 요청에 ​​응답합니다.</target>
        </trans-unit>
        <trans-unit id="799c6a1aafdeb5752f0a6da17b30526204336545" translate="yes" xml:space="preserve">
          <source>Awesome! With one tiny final tweak, we will finish the guessing game. Recall that the program is still printing the secret number. That worked well for testing, but it ruins the game. Let&amp;rsquo;s delete the &lt;code&gt;println!&lt;/code&gt; that outputs the secret number. Listing 2-6 shows the final code.</source>
          <target state="translated">대박! 하나의 작은 마지막 조정으로, 우리는 추측 게임을 끝낼 것입니다. 프로그램이 여전히 비밀 번호를 인쇄하고 있음을 상기하십시오. 테스트에는 효과가 있었지만 게임을 망쳤습니다. &lt;code&gt;println!&lt;/code&gt; 삭제합시다 ! 비밀 번호를 출력합니다. 코드 2-6은 최종 코드를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="358de401329e3394893b21243300f3a3bf6b4d17" translate="yes" xml:space="preserve">
          <source>B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing the amount of work performed in a search. In theory, a binary search tree (BST) is the optimal choice for a sorted map, as a perfectly balanced BST performs the theoretical minimum amount of comparisons necessary to find an element (log&lt;sub&gt;2&lt;/sub&gt;n). However, in practice the way this is done is &lt;em&gt;very&lt;/em&gt; inefficient for modern computer architectures. In particular, every element is stored in its own individually heap-allocated node. This means that every single insertion triggers a heap-allocation, and every single comparison should be a cache-miss. Since these are both notably expensive things to do in practice, we are forced to at very least reconsider the BST strategy.</source>
          <target state="translated">B- 트리는 캐시 효율성과 검색에서 수행되는 작업량을 최소화하는 것의 근본적인 절충을 나타냅니다. 이론적으로 BST (Binary Search Tree)는 정렬 된 맵에 가장 적합한 선택입니다. BST는 완벽하게 균형 잡힌 BST가 요소를 찾는 데 필요한 이론적 최소량의 비교를 수행하기 때문입니다 (log &lt;sub&gt;2&lt;/sub&gt; n). 그러나 실제로 이것이 수행되는 방식은 최신 컴퓨터 아키텍처 에는 &lt;em&gt;매우&lt;/em&gt; 비효율적입니다. 특히 모든 요소는 자체적으로 힙이 할당 된 노드에 저장됩니다. 이것은 모든 단일 삽입이 힙 할당을 트리거하고 모든 단일 비교가 캐시 누락이어야 함을 의미합니다. 이것들은 실제로 실제로 비싼 일이기 때문에, 우리는 최소한 BST 전략을 재고해야합니다.</target>
        </trans-unit>
        <trans-unit id="4ce046eb7e16ef9995c1ff852988df751464fa48" translate="yes" xml:space="preserve">
          <source>BIN_DIGIT : [&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;1&lt;/code&gt;]</source>
          <target state="translated">BIN_DIGIT : &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;1&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="93c309eceddcd432100b37d2f21aed97ad5516a1" translate="yes" xml:space="preserve">
          <source>BIN_LITERAL :</source>
          <target state="translated">BIN_LITERAL :</target>
        </trans-unit>
        <trans-unit id="1ce23e42f8a0fadda89f03bff4138edc76257e9f" translate="yes" xml:space="preserve">
          <source>BLOCK_COMMENT</source>
          <target state="translated">BLOCK_COMMENT</target>
        </trans-unit>
        <trans-unit id="54d41dd6d7f607cbfdbd93df26df009dd384ea37" translate="yes" xml:space="preserve">
          <source>BLOCK_COMMENT :</source>
          <target state="translated">BLOCK_COMMENT :</target>
        </trans-unit>
        <trans-unit id="46a2a0792f35fba20ff9af816bd7d67867d91ee5" translate="yes" xml:space="preserve">
          <source>BOOLEAN_LITERAL</source>
          <target state="translated">BOOLEAN_LITERAL</target>
        </trans-unit>
        <trans-unit id="984b539364047c18d12aa2a5107f4ca7034f1745" translate="yes" xml:space="preserve">
          <source>BOOLEAN_LITERAL :</source>
          <target state="translated">BOOLEAN_LITERAL :</target>
        </trans-unit>
        <trans-unit id="25ed99c15ff33b077d8ef4f89cfb12043f799e5c" translate="yes" xml:space="preserve">
          <source>BTreeMap</source>
          <target state="translated">BTreeMap</target>
        </trans-unit>
        <trans-unit id="14b812dd3cb5eae3767a2df53640bea358a44ec3" translate="yes" xml:space="preserve">
          <source>BTreeMap::append</source>
          <target state="translated">BTreeMap::append</target>
        </trans-unit>
        <trans-unit id="4439b2dd76bd007a7ee702af3eca0f027a45eb09" translate="yes" xml:space="preserve">
          <source>BTreeMap::borrow</source>
          <target state="translated">BTreeMap::borrow</target>
        </trans-unit>
        <trans-unit id="a411a7ebcb50db356ed987a9d5f1ea3e6fb40efd" translate="yes" xml:space="preserve">
          <source>BTreeMap::borrow_mut</source>
          <target state="translated">BTreeMap::borrow_mut</target>
        </trans-unit>
        <trans-unit id="0e1837335635833d079465e2a07ece32097ef9ee" translate="yes" xml:space="preserve">
          <source>BTreeMap::clamp</source>
          <target state="translated">BTreeMap::clamp</target>
        </trans-unit>
        <trans-unit id="a5095900a69512f07d67a4318ed72ed754b7ec9a" translate="yes" xml:space="preserve">
          <source>BTreeMap::clear</source>
          <target state="translated">BTreeMap::clear</target>
        </trans-unit>
        <trans-unit id="d9dc0be9a162cd4c9a8d0d87ef461b431cc2996f" translate="yes" xml:space="preserve">
          <source>BTreeMap::clone</source>
          <target state="translated">BTreeMap::clone</target>
        </trans-unit>
        <trans-unit id="b18aa414095cedffcf379ff71fa52f0f3e5a2e30" translate="yes" xml:space="preserve">
          <source>BTreeMap::clone_from</source>
          <target state="translated">BTreeMap::clone_from</target>
        </trans-unit>
        <trans-unit id="94cc1d51e045cecb444cb20cb07a89d16ef1abae" translate="yes" xml:space="preserve">
          <source>BTreeMap::clone_into</source>
          <target state="translated">BTreeMap::clone_into</target>
        </trans-unit>
        <trans-unit id="7fc5895f7f2221a66d3e8ff613cbb9e54a398512" translate="yes" xml:space="preserve">
          <source>BTreeMap::cmp</source>
          <target state="translated">BTreeMap::cmp</target>
        </trans-unit>
        <trans-unit id="10f80450d5f9791627fc6f70e8eea8d607e5abc1" translate="yes" xml:space="preserve">
          <source>BTreeMap::contains_key</source>
          <target state="translated">BTreeMap::contains_key</target>
        </trans-unit>
        <trans-unit id="237ebd61fd35b922ed92337aaeb092096989c551" translate="yes" xml:space="preserve">
          <source>BTreeMap::default</source>
          <target state="translated">BTreeMap::default</target>
        </trans-unit>
        <trans-unit id="67360895fa8faeb3288ff2a48f56ac5fb63f6cfa" translate="yes" xml:space="preserve">
          <source>BTreeMap::drop</source>
          <target state="translated">BTreeMap::drop</target>
        </trans-unit>
        <trans-unit id="e35986d9fdbf3de52b6c707270d8af046337a4b7" translate="yes" xml:space="preserve">
          <source>BTreeMap::entry</source>
          <target state="translated">BTreeMap::entry</target>
        </trans-unit>
        <trans-unit id="1fd856b6f3486469ed5b9716d4c0ef16fd26570a" translate="yes" xml:space="preserve">
          <source>BTreeMap::eq</source>
          <target state="translated">BTreeMap::eq</target>
        </trans-unit>
        <trans-unit id="2eb6b59d7803ce34a4aebcb1a5cebd29ebb2ace1" translate="yes" xml:space="preserve">
          <source>BTreeMap::extend</source>
          <target state="translated">BTreeMap::extend</target>
        </trans-unit>
        <trans-unit id="14a4894c2a33cba6f17b28aab882b15d8fa0507e" translate="yes" xml:space="preserve">
          <source>BTreeMap::fmt</source>
          <target state="translated">BTreeMap::fmt</target>
        </trans-unit>
        <trans-unit id="f8ff830626694a395da9bcdf07413636ef382d2a" translate="yes" xml:space="preserve">
          <source>BTreeMap::from</source>
          <target state="translated">BTreeMap::from</target>
        </trans-unit>
        <trans-unit id="40d5df351e6a78b82beed9049802e2600890cdef" translate="yes" xml:space="preserve">
          <source>BTreeMap::from_iter</source>
          <target state="translated">BTreeMap::from_iter</target>
        </trans-unit>
        <trans-unit id="42bc9380f48558951feaee861f324b3e97cc339c" translate="yes" xml:space="preserve">
          <source>BTreeMap::ge</source>
          <target state="translated">BTreeMap::ge</target>
        </trans-unit>
        <trans-unit id="fdc4bec6666f5d3bd604897331fbae31d76e02c5" translate="yes" xml:space="preserve">
          <source>BTreeMap::get</source>
          <target state="translated">BTreeMap::get</target>
        </trans-unit>
        <trans-unit id="10123fe58d4d51981db653bb17bb2c5bd1739f48" translate="yes" xml:space="preserve">
          <source>BTreeMap::get_key_value</source>
          <target state="translated">BTreeMap::get_key_value</target>
        </trans-unit>
        <trans-unit id="77ed844b0571d2308549c11d94f75218d5fc647d" translate="yes" xml:space="preserve">
          <source>BTreeMap::get_mut</source>
          <target state="translated">BTreeMap::get_mut</target>
        </trans-unit>
        <trans-unit id="5aeca596bd768adcad438b3384e1977cf6475276" translate="yes" xml:space="preserve">
          <source>BTreeMap::gt</source>
          <target state="translated">BTreeMap::gt</target>
        </trans-unit>
        <trans-unit id="aef92c85a8fd215fe067e91d2cc54253d395041e" translate="yes" xml:space="preserve">
          <source>BTreeMap::hash</source>
          <target state="translated">BTreeMap::hash</target>
        </trans-unit>
        <trans-unit id="cf9f5d8139a53420363c542bee60960cfdf4b73f" translate="yes" xml:space="preserve">
          <source>BTreeMap::hash_slice</source>
          <target state="translated">BTreeMap::hash_slice</target>
        </trans-unit>
        <trans-unit id="9d0f58d76739deb0afae24d930afc89e886727c1" translate="yes" xml:space="preserve">
          <source>BTreeMap::index</source>
          <target state="translated">BTreeMap::index</target>
        </trans-unit>
        <trans-unit id="495b083c76694857a7d488aae7997ecc9b65b8fd" translate="yes" xml:space="preserve">
          <source>BTreeMap::insert</source>
          <target state="translated">BTreeMap::insert</target>
        </trans-unit>
        <trans-unit id="df183dd97d9b53936c9da9b18c544dcca3159f96" translate="yes" xml:space="preserve">
          <source>BTreeMap::into</source>
          <target state="translated">BTreeMap::into</target>
        </trans-unit>
        <trans-unit id="fc4dae35af80d2a787e9d9736c90c00c41315ce5" translate="yes" xml:space="preserve">
          <source>BTreeMap::into_iter</source>
          <target state="translated">BTreeMap::into_iter</target>
        </trans-unit>
        <trans-unit id="34464fef785cdf817cc72448c6950077bd889a22" translate="yes" xml:space="preserve">
          <source>BTreeMap::is_empty</source>
          <target state="translated">BTreeMap::is_empty</target>
        </trans-unit>
        <trans-unit id="f0cc7817b62e10040c3cb5b80461b8e39c5f0f79" translate="yes" xml:space="preserve">
          <source>BTreeMap::iter</source>
          <target state="translated">BTreeMap::iter</target>
        </trans-unit>
        <trans-unit id="db8aca8da8288f53fcb308f1bc4fd2b4cacd2358" translate="yes" xml:space="preserve">
          <source>BTreeMap::iter_mut</source>
          <target state="translated">BTreeMap::iter_mut</target>
        </trans-unit>
        <trans-unit id="17e2b2189c6d71bc1225646a44b2dd0dedd8f47e" translate="yes" xml:space="preserve">
          <source>BTreeMap::keys</source>
          <target state="translated">BTreeMap::keys</target>
        </trans-unit>
        <trans-unit id="9d8ea9a92f24bfb8408ae08918cf32d255567986" translate="yes" xml:space="preserve">
          <source>BTreeMap::le</source>
          <target state="translated">BTreeMap::le</target>
        </trans-unit>
        <trans-unit id="69fcce80124f37da2a3264b3eb42f4416e80e515" translate="yes" xml:space="preserve">
          <source>BTreeMap::len</source>
          <target state="translated">BTreeMap::len</target>
        </trans-unit>
        <trans-unit id="9d226dd3e31bc04059d6780da00c779d71a0c07b" translate="yes" xml:space="preserve">
          <source>BTreeMap::lt</source>
          <target state="translated">BTreeMap::lt</target>
        </trans-unit>
        <trans-unit id="28cb2cc6fd2d128843e6d248dab95763d1010e94" translate="yes" xml:space="preserve">
          <source>BTreeMap::max</source>
          <target state="translated">BTreeMap::max</target>
        </trans-unit>
        <trans-unit id="e204c8d42ea76d6a7764ea9e58274fe5c3bb002d" translate="yes" xml:space="preserve">
          <source>BTreeMap::min</source>
          <target state="translated">BTreeMap::min</target>
        </trans-unit>
        <trans-unit id="b1f505e6c5b1bc5d067a0962eaa8081602c15a7a" translate="yes" xml:space="preserve">
          <source>BTreeMap::ne</source>
          <target state="translated">BTreeMap::ne</target>
        </trans-unit>
        <trans-unit id="553eafd890c40ffaf003fe540a734e36e0e18621" translate="yes" xml:space="preserve">
          <source>BTreeMap::new</source>
          <target state="translated">BTreeMap::new</target>
        </trans-unit>
        <trans-unit id="145a5aeffe19ab72f79646e0207cf635764ce346" translate="yes" xml:space="preserve">
          <source>BTreeMap::partial_cmp</source>
          <target state="translated">BTreeMap::partial_cmp</target>
        </trans-unit>
        <trans-unit id="db1a963168ea048f3f16233197ab263e60b2b507" translate="yes" xml:space="preserve">
          <source>BTreeMap::range</source>
          <target state="translated">BTreeMap::range</target>
        </trans-unit>
        <trans-unit id="3fee919f6744bdc9b2c87f1284d03bd737c587e9" translate="yes" xml:space="preserve">
          <source>BTreeMap::range_mut</source>
          <target state="translated">BTreeMap::range_mut</target>
        </trans-unit>
        <trans-unit id="f730581dfe02c1cd76fc7cd5f47e7e1ec7741713" translate="yes" xml:space="preserve">
          <source>BTreeMap::remove</source>
          <target state="translated">BTreeMap::remove</target>
        </trans-unit>
        <trans-unit id="a37cec31f9d8447344a2cb11b02572d5369eaecb" translate="yes" xml:space="preserve">
          <source>BTreeMap::split_off</source>
          <target state="translated">BTreeMap::split_off</target>
        </trans-unit>
        <trans-unit id="dd1d37326d92e085a2131397045e5968a461a29d" translate="yes" xml:space="preserve">
          <source>BTreeMap::to_owned</source>
          <target state="translated">BTreeMap::to_owned</target>
        </trans-unit>
        <trans-unit id="f4b12905aac1d13f63c54fa99e15b6d767c0949a" translate="yes" xml:space="preserve">
          <source>BTreeMap::try_from</source>
          <target state="translated">BTreeMap::try_from</target>
        </trans-unit>
        <trans-unit id="8714974f74a34a38551f441ede21c0f7c7518766" translate="yes" xml:space="preserve">
          <source>BTreeMap::try_into</source>
          <target state="translated">BTreeMap::try_into</target>
        </trans-unit>
        <trans-unit id="a562c087f2e1443045e2342f53c040d13fff0500" translate="yes" xml:space="preserve">
          <source>BTreeMap::type_id</source>
          <target state="translated">BTreeMap::type_id</target>
        </trans-unit>
        <trans-unit id="fef95975d5290dbd397d0e8018f6118b5b3445f8" translate="yes" xml:space="preserve">
          <source>BTreeMap::values</source>
          <target state="translated">BTreeMap::values</target>
        </trans-unit>
        <trans-unit id="b2e013070087a41fefec42e8c8812a309f157c48" translate="yes" xml:space="preserve">
          <source>BTreeMap::values_mut</source>
          <target state="translated">BTreeMap::values_mut</target>
        </trans-unit>
        <trans-unit id="529df1988796f2371c28af38a10631626e30c033" translate="yes" xml:space="preserve">
          <source>BTreeSet</source>
          <target state="translated">BTreeSet</target>
        </trans-unit>
        <trans-unit id="8863be2c232d70a5eeb4560459b4be5b2c0073a8" translate="yes" xml:space="preserve">
          <source>BTreeSet::append</source>
          <target state="translated">BTreeSet::append</target>
        </trans-unit>
        <trans-unit id="208528633622bb579ebc99572c1cd5b23c0ff3fe" translate="yes" xml:space="preserve">
          <source>BTreeSet::bitand</source>
          <target state="translated">BTreeSet::bitand</target>
        </trans-unit>
        <trans-unit id="8c7f6d7d0bd709c67b308f34e3fdea1982987576" translate="yes" xml:space="preserve">
          <source>BTreeSet::bitor</source>
          <target state="translated">BTreeSet::bitor</target>
        </trans-unit>
        <trans-unit id="b50a2f00b4df89c4fc2d8b38a2151e87a882ff0b" translate="yes" xml:space="preserve">
          <source>BTreeSet::bitxor</source>
          <target state="translated">BTreeSet::bitxor</target>
        </trans-unit>
        <trans-unit id="cccc4bace80a38b5837fc997cc5c49754d796ac4" translate="yes" xml:space="preserve">
          <source>BTreeSet::borrow</source>
          <target state="translated">BTreeSet::borrow</target>
        </trans-unit>
        <trans-unit id="c3906f6d078061570593f2fe7b73fa2840328771" translate="yes" xml:space="preserve">
          <source>BTreeSet::borrow_mut</source>
          <target state="translated">BTreeSet::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4aa030ae00992ccd9a53652df9153409be56a2a2" translate="yes" xml:space="preserve">
          <source>BTreeSet::clamp</source>
          <target state="translated">BTreeSet::clamp</target>
        </trans-unit>
        <trans-unit id="7dbd4b9a7ec2f778cf457d4c27e677b1357aa7da" translate="yes" xml:space="preserve">
          <source>BTreeSet::clear</source>
          <target state="translated">BTreeSet::clear</target>
        </trans-unit>
        <trans-unit id="5b30f459964be9100787e5939f482cd8d7073397" translate="yes" xml:space="preserve">
          <source>BTreeSet::clone</source>
          <target state="translated">BTreeSet::clone</target>
        </trans-unit>
        <trans-unit id="050795ce2f3842fb14df3b7b6623ddb813ac2ad6" translate="yes" xml:space="preserve">
          <source>BTreeSet::clone_from</source>
          <target state="translated">BTreeSet::clone_from</target>
        </trans-unit>
        <trans-unit id="53b99dc8a6c6498122bd0b00e8114abe2667c8af" translate="yes" xml:space="preserve">
          <source>BTreeSet::clone_into</source>
          <target state="translated">BTreeSet::clone_into</target>
        </trans-unit>
        <trans-unit id="de2ebfb73a4bfaed7ca14354db78235b93dbbcb9" translate="yes" xml:space="preserve">
          <source>BTreeSet::cmp</source>
          <target state="translated">BTreeSet::cmp</target>
        </trans-unit>
        <trans-unit id="3e582a8879cbba7048152fe7baf6d319ff38bc16" translate="yes" xml:space="preserve">
          <source>BTreeSet::contains</source>
          <target state="translated">BTreeSet::contains</target>
        </trans-unit>
        <trans-unit id="21aa5487bfe6b638ff9a362eaa67cb633fc82867" translate="yes" xml:space="preserve">
          <source>BTreeSet::default</source>
          <target state="translated">BTreeSet::default</target>
        </trans-unit>
        <trans-unit id="d7c44959c458f0838dfab77ed6b6f2add8735a14" translate="yes" xml:space="preserve">
          <source>BTreeSet::difference</source>
          <target state="translated">BTreeSet::difference</target>
        </trans-unit>
        <trans-unit id="16f9dc4e686355d372b64a80e877507f0084b34a" translate="yes" xml:space="preserve">
          <source>BTreeSet::eq</source>
          <target state="translated">BTreeSet::eq</target>
        </trans-unit>
        <trans-unit id="9edee760d67dfee35cacd64d97c0b93bcecc3eb7" translate="yes" xml:space="preserve">
          <source>BTreeSet::extend</source>
          <target state="translated">BTreeSet::extend</target>
        </trans-unit>
        <trans-unit id="afc2d0e53bf4c5f63abce2f83b8f542897205aac" translate="yes" xml:space="preserve">
          <source>BTreeSet::fmt</source>
          <target state="translated">BTreeSet::fmt</target>
        </trans-unit>
        <trans-unit id="50633916fcf03b37e42d17b8960dc21b40ef24a7" translate="yes" xml:space="preserve">
          <source>BTreeSet::from</source>
          <target state="translated">BTreeSet::from</target>
        </trans-unit>
        <trans-unit id="caf6d0db82051ce20ec56dd44cb0a17ec0b98d23" translate="yes" xml:space="preserve">
          <source>BTreeSet::from_iter</source>
          <target state="translated">BTreeSet::from_iter</target>
        </trans-unit>
        <trans-unit id="be2acc08fadae340b24bbbb5601dcd11b43af4ff" translate="yes" xml:space="preserve">
          <source>BTreeSet::ge</source>
          <target state="translated">BTreeSet::ge</target>
        </trans-unit>
        <trans-unit id="eebfcd72f45c81fa6bcc82833412cbba7e8dc9f6" translate="yes" xml:space="preserve">
          <source>BTreeSet::get</source>
          <target state="translated">BTreeSet::get</target>
        </trans-unit>
        <trans-unit id="692fcfa52c7940ed1e980094be254853ea4f2c35" translate="yes" xml:space="preserve">
          <source>BTreeSet::gt</source>
          <target state="translated">BTreeSet::gt</target>
        </trans-unit>
        <trans-unit id="0546ef8f63c560e2610c71f5ad1ae889cfa00795" translate="yes" xml:space="preserve">
          <source>BTreeSet::hash</source>
          <target state="translated">BTreeSet::hash</target>
        </trans-unit>
        <trans-unit id="4f6fe8cde85490c116cbac4ed558e1916281d86a" translate="yes" xml:space="preserve">
          <source>BTreeSet::hash_slice</source>
          <target state="translated">BTreeSet::hash_slice</target>
        </trans-unit>
        <trans-unit id="eda956eff955ffd9727eb53f2bf7e0715817c65d" translate="yes" xml:space="preserve">
          <source>BTreeSet::insert</source>
          <target state="translated">BTreeSet::insert</target>
        </trans-unit>
        <trans-unit id="2ec6cd19695748bdc3218a5649d6ac291b66845a" translate="yes" xml:space="preserve">
          <source>BTreeSet::intersection</source>
          <target state="translated">BTreeSet::intersection</target>
        </trans-unit>
        <trans-unit id="d885d81e267a989f9b6f96d27d81a920eec34664" translate="yes" xml:space="preserve">
          <source>BTreeSet::into</source>
          <target state="translated">BTreeSet::into</target>
        </trans-unit>
        <trans-unit id="f09a0e4a6b10a390e2f04fd66332a740593fc953" translate="yes" xml:space="preserve">
          <source>BTreeSet::into_iter</source>
          <target state="translated">BTreeSet::into_iter</target>
        </trans-unit>
        <trans-unit id="a2120b284c22116b26329e55b63c0619a0f8641f" translate="yes" xml:space="preserve">
          <source>BTreeSet::is_disjoint</source>
          <target state="translated">BTreeSet::is_disjoint</target>
        </trans-unit>
        <trans-unit id="fa3982b7c70f77cdc4a183838b7ec4738fe0c535" translate="yes" xml:space="preserve">
          <source>BTreeSet::is_empty</source>
          <target state="translated">BTreeSet::is_empty</target>
        </trans-unit>
        <trans-unit id="f1e3ee85ccb9602474d41d5d154e3e8901defc32" translate="yes" xml:space="preserve">
          <source>BTreeSet::is_subset</source>
          <target state="translated">BTreeSet::is_subset</target>
        </trans-unit>
        <trans-unit id="56a933bbd8f86feb814db247df53b23e17a9695d" translate="yes" xml:space="preserve">
          <source>BTreeSet::is_superset</source>
          <target state="translated">BTreeSet::is_superset</target>
        </trans-unit>
        <trans-unit id="b5818b3b23dd28b80dc81cc819a86f1ec187aacf" translate="yes" xml:space="preserve">
          <source>BTreeSet::iter</source>
          <target state="translated">BTreeSet::iter</target>
        </trans-unit>
        <trans-unit id="de70e88d73a501b174fd29598eceebcee11a3887" translate="yes" xml:space="preserve">
          <source>BTreeSet::le</source>
          <target state="translated">BTreeSet::le</target>
        </trans-unit>
        <trans-unit id="d6f9cf6208fd574420dfb2b2c0da01ae4ce09d55" translate="yes" xml:space="preserve">
          <source>BTreeSet::len</source>
          <target state="translated">BTreeSet::len</target>
        </trans-unit>
        <trans-unit id="b1797fe67e7fb20ec6e3d268d0239e6f0a7e8a35" translate="yes" xml:space="preserve">
          <source>BTreeSet::lt</source>
          <target state="translated">BTreeSet::lt</target>
        </trans-unit>
        <trans-unit id="a9e0d4eb0cfb5c71cb33c6469839efbbe2cc32b4" translate="yes" xml:space="preserve">
          <source>BTreeSet::max</source>
          <target state="translated">BTreeSet::max</target>
        </trans-unit>
        <trans-unit id="05e2ada4eca69c113c843b5a4bf4e82b6cbab803" translate="yes" xml:space="preserve">
          <source>BTreeSet::min</source>
          <target state="translated">BTreeSet::min</target>
        </trans-unit>
        <trans-unit id="1bf7816f409ee91ea7b933df2aa5aafb248eb221" translate="yes" xml:space="preserve">
          <source>BTreeSet::ne</source>
          <target state="translated">BTreeSet::ne</target>
        </trans-unit>
        <trans-unit id="eaf3ecdf9b29068bb6526653c7887b6ce53f95db" translate="yes" xml:space="preserve">
          <source>BTreeSet::new</source>
          <target state="translated">BTreeSet::new</target>
        </trans-unit>
        <trans-unit id="df8c5a54c5b8f9c4c785c5ef82c145a8f51964cb" translate="yes" xml:space="preserve">
          <source>BTreeSet::partial_cmp</source>
          <target state="translated">BTreeSet::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d87bbd755881f1e9919b94d6de0e6bf8ffad49ba" translate="yes" xml:space="preserve">
          <source>BTreeSet::range</source>
          <target state="translated">BTreeSet::range</target>
        </trans-unit>
        <trans-unit id="ef12ebd2434d1cb833ec3822d788df805d7d9bd6" translate="yes" xml:space="preserve">
          <source>BTreeSet::remove</source>
          <target state="translated">BTreeSet::remove</target>
        </trans-unit>
        <trans-unit id="9478913c250333ed4078096ba5b68c78bc2a2420" translate="yes" xml:space="preserve">
          <source>BTreeSet::replace</source>
          <target state="translated">BTreeSet::replace</target>
        </trans-unit>
        <trans-unit id="3c5930911fa948ea3f0f63bb1262c5e03b59d4c8" translate="yes" xml:space="preserve">
          <source>BTreeSet::split_off</source>
          <target state="translated">BTreeSet::split_off</target>
        </trans-unit>
        <trans-unit id="c4362726060659abf8310f7f4e795bc37b50e1bc" translate="yes" xml:space="preserve">
          <source>BTreeSet::sub</source>
          <target state="translated">BTreeSet::sub</target>
        </trans-unit>
        <trans-unit id="1dc28627821fcb677e88cc0779199b1f7545d0d5" translate="yes" xml:space="preserve">
          <source>BTreeSet::symmetric_difference</source>
          <target state="translated">BTreeSet::symmetric_difference</target>
        </trans-unit>
        <trans-unit id="2164e4022af6db54cb98c455e4d65521424dc945" translate="yes" xml:space="preserve">
          <source>BTreeSet::take</source>
          <target state="translated">BTreeSet::take</target>
        </trans-unit>
        <trans-unit id="976d0d251360ff452f9cb215b1b7bd9b85411230" translate="yes" xml:space="preserve">
          <source>BTreeSet::to_owned</source>
          <target state="translated">BTreeSet::to_owned</target>
        </trans-unit>
        <trans-unit id="0992e1b4495c890673b5468165634f32bea3f77d" translate="yes" xml:space="preserve">
          <source>BTreeSet::try_from</source>
          <target state="translated">BTreeSet::try_from</target>
        </trans-unit>
        <trans-unit id="00828429015178852a18ee4ff94e0453f5ca2ad3" translate="yes" xml:space="preserve">
          <source>BTreeSet::try_into</source>
          <target state="translated">BTreeSet::try_into</target>
        </trans-unit>
        <trans-unit id="6292b066b8d0a77ef6636bc177c940749dde0313" translate="yes" xml:space="preserve">
          <source>BTreeSet::type_id</source>
          <target state="translated">BTreeSet::type_id</target>
        </trans-unit>
        <trans-unit id="a20d276d5c8ff0b1126047f789b8548caf5f132d" translate="yes" xml:space="preserve">
          <source>BTreeSet::union</source>
          <target state="translated">BTreeSet::union</target>
        </trans-unit>
        <trans-unit id="a211a3e292d0c406efdf997cbec3abf1f2bc9197" translate="yes" xml:space="preserve">
          <source>BYTE_ESCAPE :</source>
          <target state="translated">BYTE_ESCAPE :</target>
        </trans-unit>
        <trans-unit id="e985813955ef288c8ead5994a2092542fb8c5bfb" translate="yes" xml:space="preserve">
          <source>BYTE_LITERAL :</source>
          <target state="translated">BYTE_LITERAL :</target>
        </trans-unit>
        <trans-unit id="e07c048067fa9215a18b4b2891f03e3f5148f8fe" translate="yes" xml:space="preserve">
          <source>BYTE_STRING_LITERAL :</source>
          <target state="translated">BYTE_STRING_LITERAL :</target>
        </trans-unit>
        <trans-unit id="a826c283ce6a52f2d32eb19de6510cb9098ad99b" translate="yes" xml:space="preserve">
          <source>Backslash</source>
          <target state="translated">Backslash</target>
        </trans-unit>
        <trans-unit id="2df2f36ad1b16c1667285665d27221aa512fe540" translate="yes" xml:space="preserve">
          <source>Backslash is escaped as &lt;code&gt;\&lt;/code&gt;.</source>
          <target state="translated">백 슬래시는 &lt;code&gt;\&lt;/code&gt; 로 이스케이프됩니다 .</target>
        </trans-unit>
        <trans-unit id="a92ed9890561e42d2d0eb715d201f51180f68785" translate="yes" xml:space="preserve">
          <source>Backslash is escaped as &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="translated">백 슬래시는 &lt;code&gt;\\&lt;/code&gt; 로 이스케이프됩니다 .</target>
        </trans-unit>
        <trans-unit id="10c02649e226d430bd75a5b6315a41c0db9992a2" translate="yes" xml:space="preserve">
          <source>Barrier</source>
          <target state="translated">Barrier</target>
        </trans-unit>
        <trans-unit id="05bc93718262068d5416ebba28511ebef76c4e14" translate="yes" xml:space="preserve">
          <source>Barrier::borrow</source>
          <target state="translated">Barrier::borrow</target>
        </trans-unit>
        <trans-unit id="48d8a6ca5d7ebcc052fa58321357d3bc36aa03a7" translate="yes" xml:space="preserve">
          <source>Barrier::borrow_mut</source>
          <target state="translated">Barrier::borrow_mut</target>
        </trans-unit>
        <trans-unit id="248c7b32ba40054cd50084ccaaff12b9c63d122a" translate="yes" xml:space="preserve">
          <source>Barrier::fmt</source>
          <target state="translated">Barrier::fmt</target>
        </trans-unit>
        <trans-unit id="d7dd85fbb601276305eb0ee52f6cb5d377f1fcc6" translate="yes" xml:space="preserve">
          <source>Barrier::from</source>
          <target state="translated">Barrier::from</target>
        </trans-unit>
        <trans-unit id="b342290a92d4444218a0ad57c6d277b796cd87a3" translate="yes" xml:space="preserve">
          <source>Barrier::into</source>
          <target state="translated">Barrier::into</target>
        </trans-unit>
        <trans-unit id="7468c224f8c905662e2e9c948739eef5bda7db0f" translate="yes" xml:space="preserve">
          <source>Barrier::new</source>
          <target state="translated">Barrier::new</target>
        </trans-unit>
        <trans-unit id="e30be523849f626aaa57ff5ee4069d25af8b70d1" translate="yes" xml:space="preserve">
          <source>Barrier::try_from</source>
          <target state="translated">Barrier::try_from</target>
        </trans-unit>
        <trans-unit id="e446147c6eb4453799cb6b4e470660354d138fed" translate="yes" xml:space="preserve">
          <source>Barrier::try_into</source>
          <target state="translated">Barrier::try_into</target>
        </trans-unit>
        <trans-unit id="97c7cb229080f5ec6d48954bf4e25fbf0b1b07ce" translate="yes" xml:space="preserve">
          <source>Barrier::type_id</source>
          <target state="translated">Barrier::type_id</target>
        </trans-unit>
        <trans-unit id="89f8492b0a8df428938e6f6ec1470925533e2645" translate="yes" xml:space="preserve">
          <source>Barrier::wait</source>
          <target state="translated">Barrier::wait</target>
        </trans-unit>
        <trans-unit id="1fdffd384d740408663001485f7d1d001cd2a0cd" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult</source>
          <target state="translated">BarrierWaitResult</target>
        </trans-unit>
        <trans-unit id="e4a4959fb6b835a4c39d1adf5dc13e01c6574236" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::borrow</source>
          <target state="translated">BarrierWaitResult::borrow</target>
        </trans-unit>
        <trans-unit id="df6d4d2a45b72573796ce25c163ceca562fea277" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::borrow_mut</source>
          <target state="translated">BarrierWaitResult::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ab607187cf3b656038040cc905673df49597a85b" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::fmt</source>
          <target state="translated">BarrierWaitResult::fmt</target>
        </trans-unit>
        <trans-unit id="40c08de59f1f4830ac002ad44e2d3553862e48a4" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::from</source>
          <target state="translated">BarrierWaitResult::from</target>
        </trans-unit>
        <trans-unit id="0ad014a8be36da91076930d7e3b4ff7218ef30aa" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::into</source>
          <target state="translated">BarrierWaitResult::into</target>
        </trans-unit>
        <trans-unit id="24471f5273b1cd68c1f7b8b58afe489ead7b1e9c" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::is_leader</source>
          <target state="translated">BarrierWaitResult::is_leader</target>
        </trans-unit>
        <trans-unit id="30b419cdf31db8213f868433400e90eb5bd6bd09" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::try_from</source>
          <target state="translated">BarrierWaitResult::try_from</target>
        </trans-unit>
        <trans-unit id="917cd48270dee8a42dabe702984f20fa69cc47a8" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::try_into</source>
          <target state="translated">BarrierWaitResult::try_into</target>
        </trans-unit>
        <trans-unit id="29252f73362aacd393a5eec57cfc8edfc91915f8" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::type_id</source>
          <target state="translated">BarrierWaitResult::type_id</target>
        </trans-unit>
        <trans-unit id="0798504393a70fe84f8d6d8445159e80798bd3ac" translate="yes" xml:space="preserve">
          <source>Barriers are re-usable after all threads have rendezvoused once, and can be used continuously.</source>
          <target state="translated">배리어는 모든 스레드가 한 번 랑데부 한 후에 재사용 할 수 있으며 지속적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes" xml:space="preserve">
          <source>Basic Usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="e688514e6e0a6b01ae26314b3eb88e5e53881bcb" translate="yes" xml:space="preserve">
          <source>Basic behavior:</source>
          <target state="translated">기본 행동 :</target>
        </trans-unit>
        <trans-unit id="11bf4d2856fba52165f40435250d1ec2e6c3316a" translate="yes" xml:space="preserve">
          <source>Basic functions for dealing with memory.</source>
          <target state="translated">메모리를 다루기위한 기본 기능.</target>
        </trans-unit>
        <trans-unit id="ec83756dfd527ebf8f2a042db474987a95d353c4" translate="yes" xml:space="preserve">
          <source>Basic implementation of &lt;code&gt;FromStr&lt;/code&gt; on an example &lt;code&gt;Point&lt;/code&gt; type:</source>
          <target state="translated">예제 &lt;code&gt;Point&lt;/code&gt; 유형 에서 &lt;code&gt;FromStr&lt;/code&gt; 의 기본 구현 :</target>
        </trans-unit>
        <trans-unit id="c3d9f55cf67e9ea4d900c6c2497ec5a08343c0a5" translate="yes" xml:space="preserve">
          <source>Basic mathematical constants.</source>
          <target state="translated">기본 수학 상수.</target>
        </trans-unit>
        <trans-unit id="03619f20093f70d07eb4c7482bb00f0ec8e3c3fc" translate="yes" xml:space="preserve">
          <source>Basic pattern matching on &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 기본 패턴 일치 :</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="30a9f8a0441549550539e36ec0f9f9002255cfd0" translate="yes" xml:space="preserve">
          <source>Basic usage example:</source>
          <target state="translated">기본 사용법 예 :</target>
        </trans-unit>
        <trans-unit id="4ba20db65bc2f86fd8313d56d1906d6e40c680fc" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;, a type that implements &lt;code&gt;FromStr&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;FromStr&lt;/code&gt; 을 구현하는 유형 인 &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; 의&lt;/a&gt; 기본 사용법 :</target>
        </trans-unit>
        <trans-unit id="e86fea8c030e7f6d48033a20b07738fb6cc7d1e1" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; 의&lt;/a&gt; 기본 사용법 :</target>
        </trans-unit>
        <trans-unit id="a8f910f3980e5f4caf7f91e6c92b1c5ff7ef8744" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;code&gt;&amp;amp;i32&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&amp;amp;i32&lt;/code&gt; 기본 사용법 :</target>
        </trans-unit>
        <trans-unit id="4b7db61f0810a48b5403cec32d70374937db6803" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;code&gt;f64&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;f64&lt;/code&gt; 의 기본 사용법 :</target>
        </trans-unit>
        <trans-unit id="473dba01450bbaa0ba0aec1bf0715ab6ef2ccb9f" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;code&gt;i32&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;i32&lt;/code&gt; 의 기본 사용법 :</target>
        </trans-unit>
        <trans-unit id="65f639d2a40570f68ed54fc56bf243ceac2035a0" translate="yes" xml:space="preserve">
          <source>Basic usage:</source>
          <target state="translated">기본 사용법 :</target>
        </trans-unit>
        <trans-unit id="ae854127dfb82027c5681daec7e882045161fa8e" translate="yes" xml:space="preserve">
          <source>Be a &lt;a href=&quot;associated-items#methods&quot;&gt;method&lt;/a&gt; that does not use &lt;code&gt;Self&lt;/code&gt; except in the type of the receiver.</source>
          <target state="translated">수신기 유형을 제외하고 &lt;code&gt;Self&lt;/code&gt; 를 사용하지 않는 &lt;a href=&quot;associated-items#methods&quot;&gt;방법&lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a9609503521663742afb4db6d34fce975c5ef790" translate="yes" xml:space="preserve">
          <source>Be aware that operations on seemingly non-ASCII characters can sometimes have unexpected results. Consider this example:</source>
          <target state="translated">ASCII가 아닌 것처럼 보이는 문자에 대한 작업은 때때로 예기치 않은 결과를 초래할 수 있습니다. 이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="f7eed2246078297c7f3c1974fe5ece00f24fc71c" translate="yes" xml:space="preserve">
          <source>Be careful when publishing a crate because a publish is &lt;em&gt;permanent&lt;/em&gt;. The version can never be overwritten, and the code cannot be deleted. One major goal of &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; is to act as a permanent archive of code so that builds of all projects that depend on crates from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; will continue to work. Allowing version deletions would make fulfilling that goal impossible. However, there is no limit to the number of crate versions you can publish.</source>
          <target state="translated">게시가 &lt;em&gt;영구적&lt;/em&gt; 이므로 크레이트를 게시 할 때는주의하십시오 . 버전을 덮어 쓸 수 없으며 코드를 삭제할 수 없습니다. &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io의&lt;/a&gt; 주요 목표 중 하나 는 영구적 인 코드 아카이브 로 작동 하여 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io의&lt;/a&gt; 상자에 의존하는 모든 프로젝트의 빌드 가 계속 작동하도록하는 것입니다. 버전 삭제를 허용하면 해당 목표를 달성 할 수 없습니다. 그러나 게시 할 수있는 크레이트 버전 수에는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="dca86f7e9af3880530e74de899f022486c60c4c6" translate="yes" xml:space="preserve">
          <source>Be representable in the return type &lt;code&gt;Int&lt;/code&gt;, after truncating off its fractional part</source>
          <target state="translated">소수 부분을 자른 후 반환 유형 &lt;code&gt;Int&lt;/code&gt; 로 표현 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="944c776ebe8836f4d5f40423d2d077f777d1f2db" translate="yes" xml:space="preserve">
          <source>Be sure to copy over any bounds as well:</source>
          <target state="translated">경계를 모두 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7d22470344866c1dcd5a2efc22d2e6cb51a1ab2" translate="yes" xml:space="preserve">
          <source>Bear in mind that methods on infinite iterators, even those for which a result can be determined mathematically in finite time, may not terminate. Specifically, methods such as &lt;a href=&quot;trait.iterator#method.min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt;, which in the general case require traversing every element in the iterator, are likely not to return successfully for any infinite iterators.</source>
          <target state="translated">무한 반복기의 결과는 유한 한 시간에 수학적으로 결정될 수있는 방법이라도 종료되지 않을 수 있습니다. 특히, 일반적인 경우 반복자의 모든 요소를 ​​순회해야하는 &lt;a href=&quot;trait.iterator#method.min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt; 과 같은 메소드 는 무한 반복자에 대해 성공적으로 리턴되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d00abb1d72a8bac8ecec238c14739dba53b4125" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Animal::baby_name&lt;/code&gt; is an associated function rather than a method, and thus doesn&amp;rsquo;t have a &lt;code&gt;self&lt;/code&gt; parameter, Rust can&amp;rsquo;t figure out which implementation of &lt;code&gt;Animal::baby_name&lt;/code&gt; we want. We&amp;rsquo;ll get this compiler error:</source>
          <target state="translated">때문에 &lt;code&gt;Animal::baby_name&lt;/code&gt; 이없는, 따라서 관련 기능이 아닌 방법이며, &lt;code&gt;self&lt;/code&gt; 매개 변수를 녹는 구현 알아낼 수 없습니다 &lt;code&gt;Animal::baby_name&lt;/code&gt; 우리가 원하는. 이 컴파일러 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e982f4d1ceaa6ebce2e39ce35fa3517925f4eb60" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Drop::drop&lt;/code&gt; is used to clean up a value, it may be dangerous to use this value after the method has been called. As &lt;code&gt;Drop::drop&lt;/code&gt; does not take ownership of its input, Rust prevents misuse by not allowing you to call &lt;code&gt;Drop::drop&lt;/code&gt; directly.</source>
          <target state="translated">&lt;code&gt;Drop::drop&lt;/code&gt; 은 값을 정리하는 데 사용 되기 때문에 메서드가 호출 된 후이 값을 사용하는 것은 위험 할 수 있습니다. 으로 &lt;code&gt;Drop::drop&lt;/code&gt; 입력의 소유권을하지 않습니다, 녹 방지는 전화를 허용하지 않음으로써 오용 &lt;code&gt;Drop::drop&lt;/code&gt; 직접.</target>
        </trans-unit>
        <trans-unit id="c77d0afa61b96acdbbf5c9bd8c7ad5776b21e2a7" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Kilometers&lt;/code&gt; and &lt;code&gt;i32&lt;/code&gt; are the same type, we can add values of both types and we can pass &lt;code&gt;Kilometers&lt;/code&gt; values to functions that take &lt;code&gt;i32&lt;/code&gt; parameters. However, using this method, we don&amp;rsquo;t get the type checking benefits that we get from the newtype pattern discussed earlier.</source>
          <target state="translated">때문에 &lt;code&gt;Kilometers&lt;/code&gt; 와 &lt;code&gt;i32&lt;/code&gt; 동일한 유형, 우리는 두 가지 유형의 값을 추가 할 수 있습니다 우리는 통과 할 수 &lt;code&gt;Kilometers&lt;/code&gt; 걸릴 기능에 값을 &lt;code&gt;i32&lt;/code&gt; 매개 변수를. 그러나이 방법을 사용하면 앞에서 설명한 새 유형 패턴에서 얻을 수있는 유형 검사 이점을 얻을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6b9cbc9e966e04746993324da12bc0b094791922" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; allows mutable borrows checked at runtime, you can mutate the value inside the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; even when the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is immutable.</source>
          <target state="translated">때문에 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 가변 차용 실행시 체크 허용하면 내부 값 변이 수 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 짝수 때 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 불변이다.</target>
        </trans-unit>
        <trans-unit id="3648820fdd060b2ae98ec9efe9a7aa20de6bd4e7" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;_x&lt;/code&gt; is moved into the function, it is automatically dropped before the function returns.</source>
          <target state="translated">&lt;code&gt;_x&lt;/code&gt; 가 함수로 이동 되었으므로 함수가 반환되기 전에 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="02501fd298567a0388a172b4febd506fefcf8337" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;collect()&lt;/code&gt; is so general, it can cause problems with type inference. As such, &lt;code&gt;collect()&lt;/code&gt; is one of the few times you'll see the syntax affectionately known as the 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt;. This helps the inference algorithm understand specifically which collection you're trying to collect into.</source>
          <target state="translated">때문에 &lt;code&gt;collect()&lt;/code&gt; 매우 일반적이며, 그것은 형식 유추 문제를 일으킬 수 있습니다. 이와 같이 &lt;code&gt;collect()&lt;/code&gt; 는 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt; 로 알려진 구문을 볼 수있는 몇 번의 시간 중 하나입니다 . 이를 통해 추론 알고리즘이 수집하려는 컬렉션을 구체적으로 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="f792523afdd09554f3c4c09b932d34d5d3beab5f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;collect()&lt;/code&gt; only cares about what you're collecting into, you can still use a partial type hint, &lt;code&gt;_&lt;/code&gt;, with the turbofish:</source>
          <target state="translated">&lt;code&gt;collect()&lt;/code&gt; 는 수집하는 내용에만 관심이 있기 때문에 turbofish와 함께 부분 유형 힌트 &lt;code&gt;_&lt;/code&gt; 를 계속 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2e79e04cb1d4d369cbb0462d719cf25107b631b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;fancy_ref&lt;/code&gt; still holds a reference to &lt;code&gt;fancy_num&lt;/code&gt;, &lt;code&gt;fancy_num&lt;/code&gt; can't be assigned to a new value as it would invalidate the reference.</source>
          <target state="translated">때문에 &lt;code&gt;fancy_ref&lt;/code&gt; 는 여전히 참조 보유 &lt;code&gt;fancy_num&lt;/code&gt; 을 , &lt;code&gt;fancy_num&lt;/code&gt; 는 이 참조를 무효화하는 것처럼 새 값에 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ad62e74aea9006b0878a087eb02874ec0ddf69c6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;find()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation where the argument is a double reference. You can see this effect in the examples below, with &lt;code&gt;&amp;amp;&amp;amp;x&lt;/code&gt;.</source>
          <target state="translated">때문에 &lt;code&gt;find()&lt;/code&gt; 에 대한 참조를 받아, 많은 반복자는 인수가 두 번 참조입니다 가능성이 혼란 상황, 참고 문헌을 통해이 리드를 반복. &lt;code&gt;&amp;amp;&amp;amp;x&lt;/code&gt; 와 함께 아래 예에서이 효과를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8154baa71c56f29ade9fab7717781feba4bbd572" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;if&lt;/code&gt; is an expression, we can use it on the right side of a &lt;code&gt;let&lt;/code&gt; statement, as in Listing 3-2.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 가 표현식 이기 때문에 Listing 3-2에서와 같이 &lt;code&gt;let&lt;/code&gt; 문의 오른쪽에 사용할 수있다 .</target>
        </trans-unit>
        <trans-unit id="9997aaaef6017b0cb2af61885b73aab100c2b5f6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;map&lt;/code&gt; takes a closure, we can specify any operation we want to perform on each item. This is a great example of how closures let you customize some behavior while reusing the iteration behavior that the &lt;code&gt;Iterator&lt;/code&gt; trait provides.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 는 폐쇄 되기 때문에 각 항목에 대해 수행하려는 작업을 지정할 수 있습니다. 이것은 &lt;code&gt;Iterator&lt;/code&gt; 특성이 제공 하는 반복 동작을 재사용하면서 클로저가 일부 동작을 사용자 정의하는 방법에 대한 훌륭한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="b6c4314864b0e06485267f3ca664e542a4a9d24f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;map_while()&lt;/code&gt; needs to look at the value in order to see if it should be included or not, consuming iterators will see that it is removed:</source>
          <target state="translated">때문에 &lt;code&gt;map_while()&lt;/code&gt; 이 포함 여부를해야하는지 반복자가 제거되는 것을 볼 수 있습니다 소모 참조하기 위해 값을보고해야합니다 :</target>
        </trans-unit>
        <trans-unit id="3d80f24c4a2216ac3e891c23c7f333250fe61032" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;parse&lt;/code&gt; is so general, it can cause problems with type inference. As such, &lt;code&gt;parse&lt;/code&gt; is one of the few times you'll see the syntax affectionately known as the 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt;. This helps the inference algorithm understand specifically which type you're trying to parse into.</source>
          <target state="translated">때문에 &lt;code&gt;parse&lt;/code&gt; 매우 일반적이며, 그것은 형식 유추 문제를 일으킬 수 있습니다. 따라서 &lt;code&gt;parse&lt;/code&gt; 은 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt; 로 알려진 구문을 볼 수있는 몇 번의 시간 중 하나입니다 . 이는 추론 알고리즘이 구문 분석하려는 유형을 구체적으로 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="f088d61355fe261cd42315fc674f33d7a3ce9310" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;peek()&lt;/code&gt; returns a reference, and many iterators iterate over references, there can be a possibly confusing situation where the return value is a double reference. You can see this effect in the examples below.</source>
          <target state="translated">때문에 &lt;code&gt;peek()&lt;/code&gt; 에 대한 참조를 반환하고, 많은 반복자는 참조를 반복, 반환 값은 이중 참조입니다 가능성이 혼란 상황이있을 수있다. 아래 예제에서이 효과를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7eb647ad22291b28a51fd607cc84aff6f4abc83" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;rfind()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation where the argument is a double reference. You can see this effect in the examples below, with &lt;code&gt;&amp;amp;&amp;amp;x&lt;/code&gt;.</source>
          <target state="translated">때문에 &lt;code&gt;rfind()&lt;/code&gt; 에 대한 참조를 받아, 많은 반복자는 인수가 두 번 참조입니다 가능성이 혼란 상황, 참고 문헌을 통해이 리드를 반복. &lt;code&gt;&amp;amp;&amp;amp;x&lt;/code&gt; 와 함께 아래 예에서이 효과를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ddf1f7383234f0909d810cef598c63fc6f240534" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;s&lt;/code&gt; is created inside &lt;code&gt;dangle&lt;/code&gt;, when the code of &lt;code&gt;dangle&lt;/code&gt; is finished, &lt;code&gt;s&lt;/code&gt; will be deallocated. But we tried to return a reference to it. That means this reference would be pointing to an invalid &lt;code&gt;String&lt;/code&gt;. That&amp;rsquo;s no good! Rust won&amp;rsquo;t let us do this.</source>
          <target state="translated">때문에 &lt;code&gt;s&lt;/code&gt; 내부에 생성 &lt;code&gt;dangle&lt;/code&gt; 의 코드 때 &lt;code&gt;dangle&lt;/code&gt; 완료되면, &lt;code&gt;s&lt;/code&gt; 해제됩니다. 그러나 우리는 그것에 대한 참조를 반환하려고했습니다. 이것은이 참조가 유효하지 않은 &lt;code&gt;String&lt;/code&gt; 을 가리키고 있다는 것을 의미합니다 . 좋지 않아! 녹은 우리가 이것을 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="ad3a4a81012df51bdd1c2d631b8bd2d26a080ac6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;take_while()&lt;/code&gt; needs to look at the value in order to see if it should be included or not, consuming iterators will see that it is removed:</source>
          <target state="translated">때문에 &lt;code&gt;take_while()&lt;/code&gt; 이 포함 여부를해야하는지 반복자가 제거되는 것을 볼 수 있습니다 소모 참조하기 위해 값을보고해야합니다 :</target>
        </trans-unit>
        <trans-unit id="a2c09e5f782c06a87c2e923fecb0abf777de8d4b" translate="yes" xml:space="preserve">
          <source>Because Rust compiles generic code into code that specifies the type in each instance, we pay no runtime cost for using generics. When the code runs, it performs just as it would if we had duplicated each definition by hand. The process of monomorphization makes Rust&amp;rsquo;s generics extremely efficient at runtime.</source>
          <target state="translated">Rust는 일반 코드를 각 인스턴스의 유형을 지정하는 코드로 컴파일하기 때문에 제네릭 사용에 대한 런타임 비용을 지불하지 않습니다. 코드가 실행될 때 각 정의를 직접 복제 한 것처럼 수행합니다. 단일화 프로세스는 Rust의 제네릭을 런타임에 매우 효율적으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cb2c4627fadc957440586a7d9c240acafefffc6b" translate="yes" xml:space="preserve">
          <source>Because a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is a pointer, Rust always knows how much space a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; needs: a pointer&amp;rsquo;s size doesn&amp;rsquo;t change based on the amount of data it&amp;rsquo;s pointing to. This means we can put a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; inside the &lt;code&gt;Cons&lt;/code&gt; variant instead of another &lt;code&gt;List&lt;/code&gt; value directly. The &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; will point to the next &lt;code&gt;List&lt;/code&gt; value that will be on the heap rather than inside the &lt;code&gt;Cons&lt;/code&gt; variant. Conceptually, we still have a list, created with lists &amp;ldquo;holding&amp;rdquo; other lists, but this implementation is now more like placing the items next to one another rather than inside one another.</source>
          <target state="translated">때문에 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 포인터이며, 녹 항상 알고 얼마나 많은 공간 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 의 요구 : 포인터의 크기가 가리키는 데이터의 양에 따라 변경되지 않습니다. 즉 , 다른 &lt;code&gt;List&lt;/code&gt; 값 대신 &lt;code&gt;Cons&lt;/code&gt; 변형 안에 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 직접 넣을 수 있습니다. &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 다음을 가리 킵니다 &lt;code&gt;List&lt;/code&gt; 힙에보다는 내부 될 것 값 &lt;code&gt;Cons&lt;/code&gt; 변형. 개념적으로, 우리는 여전히 다른 목록을&amp;ldquo;보유&amp;rdquo;하는 목록으로 작성된 목록을 가지고 있지만,이 구현은 이제 항목을 서로 내부가 아니라 서로 옆에 배치하는 것과 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="cf81e03b95485ed347873e7e3fe9e72472e6c6b8" translate="yes" xml:space="preserve">
          <source>Because async blocks construct a future, they define an &lt;strong&gt;async context&lt;/strong&gt; which can in turn contain &lt;a href=&quot;await-expr&quot;&gt;&lt;code&gt;await&lt;/code&gt; expressions&lt;/a&gt;. Async contexts are established by async blocks as well as the bodies of async functions, whose semantics are defined in terms of async blocks.</source>
          <target state="translated">비동기 블록은 퓨처를 구성하므로 &lt;a href=&quot;await-expr&quot;&gt; &lt;code&gt;await&lt;/code&gt; &lt;/a&gt; 표현식 을 포함 할 수 있는 &lt;strong&gt;비동기 컨텍스트&lt;/strong&gt; 를 정의합니다 . 비동기 컨텍스트는 의미가 비동기 블록으로 정의되는 비동기 함수의 본문뿐만 아니라 비동기 블록에 의해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1af0938fa6746a245ca497556ef936994388e62f" translate="yes" xml:space="preserve">
          <source>Because captures are often by reference, the following general rules arise:</source>
          <target state="translated">캡처는 종종 참조로 이루어 지므로 다음과 같은 일반적인 규칙이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="48453fbdaf06b97c2a50276382893c7136610cb4" translate="yes" xml:space="preserve">
          <source>Because forgetting a value is allowed, any &lt;code&gt;unsafe&lt;/code&gt; code you write must allow for this possibility. You cannot return a value and expect that the caller will necessarily run the value's destructor.</source>
          <target state="translated">값을 잊어 버리는 것이 허용되므로, 작성하는 &lt;code&gt;unsafe&lt;/code&gt; 코드가이 가능성을 허용해야합니다. 값을 반환 할 수 없으며 호출자가 반드시 값의 소멸자를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="757a75cd5c62512d1ecdcf5444c4066082ba840e" translate="yes" xml:space="preserve">
          <source>Because having variable names match the fields is common and because writing &lt;code&gt;let Point { x: x, y: y } = p;&lt;/code&gt; contains a lot of duplication, there is a shorthand for patterns that match struct fields: you only need to list the name of the struct field, and the variables created from the pattern will have the same names. Listing 18-13 shows code that behaves in the same way as the code in Listing 18-12, but the variables created in the &lt;code&gt;let&lt;/code&gt; pattern are &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; instead of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">변수 이름이 필드와 일치하므로 &lt;code&gt;let Point { x: x, y: y } = p;&lt;/code&gt; 중복이 많이 포함 된 경우, 구조체 필드와 일치하는 패턴의 약어가 있습니다. 구조체 필드의 이름 만 나열하면되고 패턴에서 작성된 변수의 이름은 동일합니다. Listing 18-13은 Listing 18-12의 코드와 동일한 방식으로 동작하는 코드를 보여 주지만 &lt;code&gt;let&lt;/code&gt; 패턴 에서 작성된 변수 는 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 대신 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="83438caeb4e092f6346d53e11e3dc5cc7d15ebb0" translate="yes" xml:space="preserve">
          <source>Because marker traits are allowed to have multiple implementations for the same type, it's not allowed to override anything in those implementations, as it would be ambiguous which override should actually be used.</source>
          <target state="translated">마커 특성은 동일한 유형에 대해 여러 구현을 가질 수 있기 때문에 실제로 사용해야하는 재정의가 모호하기 때문에 해당 구현에서 어떤 것도 재정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e1154d896f41e24691d4a2066a20e9a97b30a6b0" translate="yes" xml:space="preserve">
          <source>Because of the call to the &lt;code&gt;foo&lt;/code&gt; macro, the compiler guesses that the missing module could be inside it and fails because the macro definition cannot be found.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 매크로 에 대한 호출로 인해 컴파일러는 누락 된 모듈이 내부에있을 수 있다고 추측하고 매크로 정의를 찾을 수 없기 때문에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="620af94cb9d051d4dfe9f749a85e09b10b24aa07" translate="yes" xml:space="preserve">
          <source>Because of the early return, &lt;code&gt;try!&lt;/code&gt; can only be used in functions that return &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일찍 돌아 &lt;code&gt;try!&lt;/code&gt; &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 를 반환하는 함수에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c9db3f614804b168272d0d3012c3d9bae7f766b" translate="yes" xml:space="preserve">
          <source>Because of this dual purpose, it is possible to create types that are not useful for interfacing with the C programming language.</source>
          <target state="translated">이 이중 목적으로 인해 C 프로그래밍 언어와의 인터페이스에 유용하지 않은 유형을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eba9459a54a420c4009843eca1a3d7462a26445" translate="yes" xml:space="preserve">
          <source>Because of this recursive dropping, you do not need to implement this trait unless your type needs its own destructor logic.</source>
          <target state="translated">이 재귀 적하 때문에 유형에 자체 소멸자 논리가 필요하지 않으면이 특성을 구현할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="df92f9c80443d85d1d1f8c4ed514d9988ba7345d" translate="yes" xml:space="preserve">
          <source>Because of this, the behavior when both &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; exist differs. On Unix, if &lt;code&gt;from&lt;/code&gt; is a directory, &lt;code&gt;to&lt;/code&gt; must also be an (empty) directory. If &lt;code&gt;from&lt;/code&gt; is not a directory, &lt;code&gt;to&lt;/code&gt; must also be not a directory. In contrast, on Windows, &lt;code&gt;from&lt;/code&gt; can be anything, but &lt;code&gt;to&lt;/code&gt; must &lt;em&gt;not&lt;/em&gt; be a directory.</source>
          <target state="translated">이로 인해 &lt;code&gt;from&lt;/code&gt; 과 &lt;code&gt;to&lt;/code&gt; 의 동작 이 다릅니다. Unix에서 &lt;code&gt;from&lt;/code&gt; 이 디렉토리 인 경우 &lt;code&gt;to&lt;/code&gt; 는 (빈) 디렉토리 여야합니다. &lt;code&gt;from&lt;/code&gt; 이 디렉토리가 아닌 경우 &lt;code&gt;to&lt;/code&gt; 도 디렉토리가 아니 어야합니다. 반면, Windows에서, &lt;code&gt;from&lt;/code&gt; 무엇이든 될 수 있지만, &lt;code&gt;to&lt;/code&gt; 해야 &lt;em&gt;하지&lt;/em&gt; 디렉토리합니다.</target>
        </trans-unit>
        <trans-unit id="edb25a77d997330fe82c62f487b65b2a449f7a57" translate="yes" xml:space="preserve">
          <source>Because of this, you must give the numeric literal or binding a type:</source>
          <target state="translated">이 때문에 숫자 리터럴을 제공하거나 유형을 바인딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5828ddf70feaedc77b7fe1498bca4e7ef61a70f" translate="yes" xml:space="preserve">
          <source>Because ownership is a new concept for many programmers, it does take some time to get used to. The good news is that the more experienced you become with Rust and the rules of the ownership system, the more you&amp;rsquo;ll be able to naturally develop code that is safe and efficient. Keep at it!</source>
          <target state="translated">소유권은 많은 프로그래머에게 새로운 개념이므로 익숙해지는 데 시간이 걸립니다. 좋은 소식은 Rust에 대한 경험이 풍부하고 소유권 시스템의 규칙이 많을수록 안전하고 효율적인 코드를 자연스럽게 개발할 수 있다는 것입니다. 견디어 내다!</target>
        </trans-unit>
        <trans-unit id="e400474ad8de5abb677ee1fb6adda287a3d95af5" translate="yes" xml:space="preserve">
          <source>Because raw entries provide much more low-level control, it's much easier to put the HashMap into an inconsistent state which, while memory-safe, will cause the map to produce seemingly random results. Higher-level and more foolproof APIs like &lt;code&gt;entry&lt;/code&gt; should be preferred when possible.</source>
          <target state="translated">원시 항목은 훨씬 더 낮은 수준의 제어를 제공하기 때문에 HashMap을 일관성이없는 상태로 만드는 것이 훨씬 쉽습니다. 메모리가 안전하지만 맵에서 임의의 결과가 생성됩니다. 가능하면 &lt;code&gt;entry&lt;/code&gt; 와 같은 더 높은 수준의 더 안전한 API 가 선호되어야합니다.</target>
        </trans-unit>
        <trans-unit id="25432f6301bbde0b420035486d49aeb28bde5fd2" translate="yes" xml:space="preserve">
          <source>Because some analysis is impossible, if the Rust compiler can&amp;rsquo;t be sure the code complies with the ownership rules, it might reject a correct program; in this way, it&amp;rsquo;s conservative. If Rust accepted an incorrect program, users wouldn&amp;rsquo;t be able to trust in the guarantees Rust makes. However, if Rust rejects a correct program, the programmer will be inconvenienced, but nothing catastrophic can occur. The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type is useful when you&amp;rsquo;re sure your code follows the borrowing rules but the compiler is unable to understand and guarantee that.</source>
          <target state="translated">일부 분석이 불가능하기 때문에 Rust 컴파일러가 코드가 소유권 규칙을 준수하는지 확신 할 수 없으면 올바른 프로그램을 거부 할 수 있습니다. 이런 식으로 보수적입니다. Rust이 잘못된 프로그램을 수락하면 사용자는 Rust의 보증을 신뢰할 수 없습니다. 그러나 Rust이 올바른 프로그램을 거부하면 프로그래머는 불편을 겪을 수 있지만 치명적인 것은 없습니다. &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 당신은 당신의 코드가 차용 규칙을 따른다 확신 할 때 유형은 유용하지만 컴파일러는 이해하고 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="029a6be2649372b5b88e5ae502ff0638c469c42e" translate="yes" xml:space="preserve">
          <source>Because strings are used for so many things, we can use many different generic APIs for strings, providing us with a lot of options. Some of them can seem redundant, but they all have their place! In this case, &lt;code&gt;String::from&lt;/code&gt; and &lt;code&gt;to_string&lt;/code&gt; do the same thing, so which you choose is a matter of style.</source>
          <target state="translated">문자열은 너무 많은 용도로 사용되므로 문자열에 다양한 일반 API를 사용하여 많은 옵션을 제공 할 수 있습니다. 그들 중 일부는 중복되어 보일 수 있지만 모두 자신의 자리를 차지했습니다! 이 경우 &lt;code&gt;String::from&lt;/code&gt; 및 &lt;code&gt;to_string&lt;/code&gt; 은 동일한 작업을 수행하므로 선택하는 것은 스타일의 문제입니다.</target>
        </trans-unit>
        <trans-unit id="1b950a204977447e5ef7cd3c6942f49baa8eb222" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;enumerate&lt;/code&gt; method returns a tuple, we can use patterns to destructure that tuple, just like everywhere else in Rust. So in the &lt;code&gt;for&lt;/code&gt; loop, we specify a pattern that has &lt;code&gt;i&lt;/code&gt; for the index in the tuple and &lt;code&gt;&amp;amp;item&lt;/code&gt; for the single byte in the tuple. Because we get a reference to the element from &lt;code&gt;.iter().enumerate()&lt;/code&gt;, we use &lt;code&gt;&amp;amp;&lt;/code&gt; in the pattern.</source>
          <target state="translated">&lt;code&gt;enumerate&lt;/code&gt; 메소드는 튜플을 반환 하기 때문에 Rust의 다른 곳에서와 마찬가지로 패턴을 사용하여 해당 튜플을 재구성 할 수 있습니다. 따라서 &lt;code&gt;for&lt;/code&gt; 루프 에서 튜플의 인덱스에 &lt;code&gt;i&lt;/code&gt; 가 있고 튜플 의 단일 바이트에 대한 &lt;code&gt;&amp;amp;item&lt;/code&gt; 이있는 패턴을 지정합니다 . &lt;code&gt;.iter().enumerate()&lt;/code&gt; 에서 요소에 대한 참조를 얻으므로 패턴에 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="4bad4d17c2470c688d65e4cf4cd29dd8d9a6843c" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;fly&lt;/code&gt; method takes a &lt;code&gt;self&lt;/code&gt; parameter, if we had two &lt;em&gt;types&lt;/em&gt; that both implement one &lt;em&gt;trait&lt;/em&gt;, Rust could figure out which implementation of a trait to use based on the type of &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fly&lt;/code&gt; 메서드는 &lt;code&gt;self&lt;/code&gt; 매개 변수를 사용 하기 때문에 하나의 &lt;em&gt;특성을&lt;/em&gt; 구현하는 두 가지 &lt;em&gt;유형&lt;/em&gt; 이있는 경우 Rust는 &lt;code&gt;self&lt;/code&gt; 유형에 따라 사용할 특성의 구현을 파악할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dfa04ea7812d8d0a045650338922229931556bb" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;toast&lt;/code&gt; field in the &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; struct is public, in &lt;code&gt;eat_at_restaurant&lt;/code&gt; we can write and read to the &lt;code&gt;toast&lt;/code&gt; field using dot notation. Notice that we can&amp;rsquo;t use the &lt;code&gt;seasonal_fruit&lt;/code&gt; field in &lt;code&gt;eat_at_restaurant&lt;/code&gt; because &lt;code&gt;seasonal_fruit&lt;/code&gt; is private. Try uncommenting the line modifying the &lt;code&gt;seasonal_fruit&lt;/code&gt; field value to see what error you get!</source>
          <target state="translated">&lt;code&gt;back_of_house::Breakfast&lt;/code&gt; 구조체 의 &lt;code&gt;toast&lt;/code&gt; 필드 는 공용이므로 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 에서는 도트 표기법을 사용하여 &lt;code&gt;toast&lt;/code&gt; 필드에 쓰고 읽을 수 있습니다 . 우리가 사용할 수 없다는 것을주의 &lt;code&gt;seasonal_fruit&lt;/code&gt; 의 에서 필드를 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 때문에 &lt;code&gt;seasonal_fruit&lt;/code&gt; 은 비공개입니다. &lt;code&gt;seasonal_fruit&lt;/code&gt; _ 과일 필드 값을 수정하여 줄의 주석을 해제하여 어떤 오류가 발생했는지 확인하십시오!</target>
        </trans-unit>
        <trans-unit id="185de19b862032b52b28484b2c6cc55792a266c3" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;write&lt;/code&gt; operation could fail, we use &lt;code&gt;unwrap&lt;/code&gt; on any error result as before. Again, in a real application you would add error handling here. Finally, &lt;code&gt;flush&lt;/code&gt; will wait and prevent the program from continuing until all the bytes are written to the connection; &lt;code&gt;TcpStream&lt;/code&gt; contains an internal buffer to minimize calls to the underlying operating system.</source>
          <target state="translated">때문에 &lt;code&gt;write&lt;/code&gt; 작업이 실패 할 수 있습니다, 우리가 사용하는 &lt;code&gt;unwrap&lt;/code&gt; 이전과 오류의 결과에. 실제 응용 프로그램에서는 여기에 오류 처리 기능을 추가합니다. 마지막으로, &lt;code&gt;flush&lt;/code&gt; 는 모든 바이트가 연결에 기록 될 때까지 프로그램이 대기하지 못하도록합니다. &lt;code&gt;TcpStream&lt;/code&gt; 에는 기본 운영 체제에 대한 호출을 최소화하기위한 내부 버퍼가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b1f6fd955e3dd56c20447476cad2f0ff374150c" translate="yes" xml:space="preserve">
          <source>Because the closure passed to &lt;code&gt;filter()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure is a double reference:</source>
          <target state="translated">&lt;code&gt;filter()&lt;/code&gt; 전달 된 클로저 는 참조를 취하고 많은 반복자가 참조를 반복하므로 클로저 유형이 이중 참조 인 혼동 상황이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58c9579a8a89655df95e712d81cbf2a21bf02a65" translate="yes" xml:space="preserve">
          <source>Because the closure passed to &lt;code&gt;skip_while()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure is a double reference:</source>
          <target state="translated">&lt;code&gt;skip_while()&lt;/code&gt; 전달 된 클로저 는 참조를 취하고 많은 반복자가 참조를 반복하므로 클로저의 유형이 이중 참조 인 상황이 혼동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8479afb170cef741fbbcede9d3610679171e5033" translate="yes" xml:space="preserve">
          <source>Because the closure passed to &lt;code&gt;take_while()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure is a double reference:</source>
          <target state="translated">&lt;code&gt;take_while()&lt;/code&gt; 전달 된 클로저 는 참조를 취하고 많은 반복자는 참조를 반복하므로, 클로저 유형이 이중 참조 인 혼동되는 상황이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eb937137f69efc7f4d05e71e805b680ad9ce55c" translate="yes" xml:space="preserve">
          <source>Because the correct result of the &lt;code&gt;can_hold&lt;/code&gt; function in this case is &lt;code&gt;false&lt;/code&gt;, we need to negate that result before we pass it to the &lt;code&gt;assert!&lt;/code&gt; macro. As a result, our test will pass if &lt;code&gt;can_hold&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">이 경우 &lt;code&gt;can_hold&lt;/code&gt; 함수 의 올바른 결과 는 &lt;code&gt;false&lt;/code&gt; 이므로 &lt;code&gt;assert!&lt;/code&gt; 전달하기 전에 해당 결과를 무효화해야합니다 ! 매크로. 결과적으로 &lt;code&gt;can_hold&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 테스트가 통과됩니다 .</target>
        </trans-unit>
        <trans-unit id="90666aa0415ee00d8f72df1807729b34de2b7424" translate="yes" xml:space="preserve">
          <source>Because the function item type explicitly identifies the function, the item types of different functions - different items, or the same item with different generics - are distinct, and mixing them will create a type error:</source>
          <target state="translated">함수 아이템 타입은 함수를 명시 적으로 식별하기 때문에, 다른 함수, 다른 아이템 또는 다른 제네릭을 가진 같은 아이템의 아이템 타입은 구별되며, 그것들을 혼합하면 타입 에러가 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="91472ca2849f01f7f3aadf84c45216c15e72f922" translate="yes" xml:space="preserve">
          <source>Because the goal is to keep all these rules inside the structs that implement &lt;code&gt;State&lt;/code&gt;, we call a &lt;code&gt;content&lt;/code&gt; method on the value in &lt;code&gt;state&lt;/code&gt; and pass the post instance (that is, &lt;code&gt;self&lt;/code&gt;) as an argument. Then we return the value that is returned from using the &lt;code&gt;content&lt;/code&gt; method on the &lt;code&gt;state&lt;/code&gt; value.</source>
          <target state="translated">목표는 이러한 모든 규칙을 &lt;code&gt;State&lt;/code&gt; 를 구현하는 구조체 내에 유지하는 것이므로 &lt;code&gt;state&lt;/code&gt; 의 값에 대해 &lt;code&gt;content&lt;/code&gt; 메소드를 호출 하고 post 인스턴스 (즉, &lt;code&gt;self&lt;/code&gt; )를 인수로 전달합니다. 그런 다음 &lt;code&gt;state&lt;/code&gt; 메소드에서 &lt;code&gt;content&lt;/code&gt; 메소드 를 사용하여 리턴 된 값을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="030b08f8ea47335b102e955f832da8f8f1553c44" translate="yes" xml:space="preserve">
          <source>Because the parameter names and the struct field names are exactly the same in Listing 5-4, we can use the &lt;em&gt;field init shorthand&lt;/em&gt; syntax to rewrite &lt;code&gt;build_user&lt;/code&gt; so that it behaves exactly the same but doesn&amp;rsquo;t have the repetition of &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;username&lt;/code&gt;, as shown in Listing 5-5.</source>
          <target state="translated">매개 변수 이름 및 구조체의 필드 이름은 5-4 목록에서 동일하기 때문에, 우리가 사용할 수있는 &lt;em&gt;필드를 초기화 속기&lt;/em&gt; 구문 재 작성 &lt;code&gt;build_user&lt;/code&gt; 그래서 정확히 같은 동작 만의 반복하지 않는 &lt;code&gt;email&lt;/code&gt; 과 &lt;code&gt;username&lt;/code&gt; 같이 Listing 5-5에 나와있다.</target>
        </trans-unit>
        <trans-unit id="d69419dfb414355067e2d4508090380593ccdd03" translate="yes" xml:space="preserve">
          <source>Because the standard library has this blanket implementation, we can call the &lt;code&gt;to_string&lt;/code&gt; method defined by the &lt;code&gt;ToString&lt;/code&gt; trait on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait. For example, we can turn integers into their corresponding &lt;code&gt;String&lt;/code&gt; values like this because integers implement &lt;code&gt;Display&lt;/code&gt;:</source>
          <target state="translated">표준 라이브러리에는이 블랭킷 구현이 있으므로 &lt;code&gt;Display&lt;/code&gt; 특성 을 구현하는 모든 유형 에서 &lt;code&gt;ToString&lt;/code&gt; 특성으로 정의 된 &lt;code&gt;to_string&lt;/code&gt; 메소드를 호출 할 수 있습니다 . 예를 들어 정수는 &lt;code&gt;Display&lt;/code&gt; 를 구현하기 때문에 정수를 이와 같은 해당 &lt;code&gt;String&lt;/code&gt; 값 으로 바꿀 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37ef1e15d186d9fd04a65d1942d30d946ce68135" translate="yes" xml:space="preserve">
          <source>Because the third rule really only applies in method signatures, we&amp;rsquo;ll look at lifetimes in that context next to see why the third rule means we don&amp;rsquo;t have to annotate lifetimes in method signatures very often.</source>
          <target state="translated">세 번째 규칙은 실제로 메소드 서명에만 적용되므로 다음 컨텍스트에서 수명을 살펴보고 세 번째 규칙이 왜 메소드 서명에서 수명에 주석을 달지 않아도되는지를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70d45c4687665d4e0a5b39f62a85fe258555be07" translate="yes" xml:space="preserve">
          <source>Because the value that &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; references might have been dropped, to do anything with the value that a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; is pointing to, you must make sure the value still exists. Do this by calling the &lt;code&gt;upgrade&lt;/code&gt; method on a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; instance, which will return an &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;. You&amp;rsquo;ll get a result of &lt;code&gt;Some&lt;/code&gt; if the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value has not been dropped yet and a result of &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value has been dropped. Because &lt;code&gt;upgrade&lt;/code&gt; returns an &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, Rust will ensure that the &lt;code&gt;Some&lt;/code&gt; case and the &lt;code&gt;None&lt;/code&gt; case are handled, and there won&amp;rsquo;t be an invalid pointer.</source>
          <target state="translated">&lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 참조 하는 값 이 삭제되었을 수 있으므로 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 가 가리키는 값으로 작업을 수행 하려면 값이 여전히 존재하는지 확인해야합니다. &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;upgrade&lt;/code&gt; 메서드를 호출하면 &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 반환합니다 . 당신의 결과거야 &lt;code&gt;Some&lt;/code&gt; 경우를 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 값이 아직 떨어의 결과되지 않았습니다 &lt;code&gt;None&lt;/code&gt; 경우 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 값이 삭제되었습니다. &lt;code&gt;upgrade&lt;/code&gt; 가 &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 반환 하기 때문에 Rust는 &lt;code&gt;Some&lt;/code&gt; case와 &lt;code&gt;None&lt;/code&gt; 케이스가 처리되고 잘못된 포인터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d8bf4707482fe4f59a8a059222ee5cf8616fe8ba" translate="yes" xml:space="preserve">
          <source>Because the value that &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; references might have been dropped, to do anything with the value that a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; is pointing to, you must make sure the value still exists. Do this by calling the &lt;code&gt;upgrade&lt;/code&gt; method on a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; instance, which will return an &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;. You&amp;rsquo;ll get a result of &lt;code&gt;Some&lt;/code&gt; if the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value has not been dropped yet and a result of &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value has been dropped. Because &lt;code&gt;upgrade&lt;/code&gt; returns an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, Rust will ensure that the &lt;code&gt;Some&lt;/code&gt; case and the &lt;code&gt;None&lt;/code&gt; case are handled, and there won&amp;rsquo;t be an invalid pointer.</source>
          <target state="translated">&lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 참조 하는 값 이 삭제되었으므로 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 가 가리키는 값으로 작업을 수행 하려면 값이 여전히 존재하는지 확인해야합니다. &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;upgrade&lt;/code&gt; 메소드를 호출하여이를 수행 하면 &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 가 리턴됩니다 . 당신의 결과거야 &lt;code&gt;Some&lt;/code&gt; 경우를 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 값이 아직 떨어의 결과되지 않았습니다 &lt;code&gt;None&lt;/code&gt; 경우 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 값이 삭제되었습니다. 때문에 &lt;code&gt;upgrade&lt;/code&gt; 다시 표시 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; , 녹 보장합니다 그 &lt;code&gt;Some&lt;/code&gt; 경우와 &lt;code&gt;None&lt;/code&gt; case가 처리되며 유효하지 않은 포인터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="14741fffc1dc74532e1921d454b0c26246f646ef" translate="yes" xml:space="preserve">
          <source>Because the vast majority of Rust projects use Cargo, the rest of this book assumes that you&amp;rsquo;re using Cargo too. Cargo comes installed with Rust if you used the official installers discussed in the &lt;a href=&quot;ch01-01-installation#installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo;&lt;/a&gt; section. If you installed Rust through some other means, check whether Cargo is installed by entering the following into your terminal:</source>
          <target state="translated">대부분의 Rust 프로젝트는화물을 사용하기 때문에이 책의 나머지 부분에서는화물을 사용한다고 가정합니다. &lt;a href=&quot;ch01-01-installation#installation&quot;&gt;&amp;ldquo;설치&amp;rdquo;&lt;/a&gt; 섹션 에서 설명한 공식 설치 프로그램을 사용하면 Cargo에 Rust가 설치됩니다 . 다른 방법으로 Rust를 설치 한 경우 터미널에 다음을 입력하여 Cargo가 설치되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="50d3009a3e9b08a6e3dea49369c4a3eff85c4a99" translate="yes" xml:space="preserve">
          <source>Because they are traits, &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; are implemented by a number of other types, and you can implement them for your types too. As such, you'll see a few different types of I/O throughout the documentation in this module: &lt;a href=&quot;../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../net/struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt;s, and sometimes even &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;s. For example, &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; adds a &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; method, which we can use on &lt;a href=&quot;../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s:</source>
          <target state="translated">그것들은 특성이기 때문에 &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; 는 다른 많은 유형으로 구현되며, 당신의 유형에도 적용 할 수 있습니다. &lt;a href=&quot;../net/struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; 모듈의 문서 전체에서 &lt;a href=&quot;../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; , TcpStream 및 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 등 몇 가지 다른 유형의 I / O가 표시됩니다 . 예를 들어, &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; 에서&lt;/a&gt; 사용할 수 있는 &lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 메소드를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="e07ae336ff59e9ed0b225ca89429b661de0679cf" translate="yes" xml:space="preserve">
          <source>Because this declaration is in the &lt;code&gt;std::io&lt;/code&gt; module, we can use the fully qualified alias &lt;code&gt;std::io::Result&amp;lt;T&amp;gt;&lt;/code&gt;&amp;mdash;that is, a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; with the &lt;code&gt;E&lt;/code&gt; filled in as &lt;code&gt;std::io::Error&lt;/code&gt;. The &lt;code&gt;Write&lt;/code&gt; trait function signatures end up looking like this:</source>
          <target state="translated">이 선언은 &lt;code&gt;std::io&lt;/code&gt; 모듈 에 있기 때문에 정규화 된 별명 &lt;code&gt;std::io::Result&amp;lt;T&amp;gt;&lt;/code&gt; 즉 &lt;code&gt;E&lt;/code&gt; 가 &lt;code&gt;std::io::Error&lt;/code&gt; 로 채워진 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 를 사용할 수 있습니다. :: 오류 . &lt;code&gt;Write&lt;/code&gt; 특성 기능 서명이처럼 보이는 끝낼 :</target>
        </trans-unit>
        <trans-unit id="4d78cf22aaa22c544c68896425f6652ea68b656d" translate="yes" xml:space="preserve">
          <source>Because this error message starts with the text we specified, &lt;code&gt;Failed to open hello.txt&lt;/code&gt;, it will be easier to find where in the code this error message is coming from. If we use &lt;code&gt;unwrap&lt;/code&gt; in multiple places, it can take more time to figure out exactly which &lt;code&gt;unwrap&lt;/code&gt; is causing the panic because all &lt;code&gt;unwrap&lt;/code&gt; calls that panic print the same message.</source>
          <target state="translated">이 오류 메시지는 지정한 텍스트 인 &lt;code&gt;Failed to open hello.txt&lt;/code&gt; 코드에서이 오류 메시지의 출처를 쉽게 찾을 수 있습니다. 우리가 사용하는 경우 &lt;code&gt;unwrap&lt;/code&gt; 여러 위치에, 정확히 알아낼 더 많은 시간이 걸릴 수 있습니다 &lt;code&gt;unwrap&lt;/code&gt; 모든 때문에 공황의 원인이되는 &lt;code&gt;unwrap&lt;/code&gt; 패닉이 같은 메시지를 인쇄 한 통화를.</target>
        </trans-unit>
        <trans-unit id="f9ecc9d043c4a1c0a98d5acfc2202fd98ea778e6" translate="yes" xml:space="preserve">
          <source>Because this function may panic, its use is generally discouraged. Instead, prefer to use pattern matching and handle the &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; case explicitly, or call &lt;a href=&quot;enum.option#method.unwrap_or&quot;&gt;&lt;code&gt;unwrap_or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.option#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;enum.option#method.unwrap_or_default&quot;&gt;&lt;code&gt;unwrap_or_default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능은 패닉이 발생할 수 있으므로 일반적으로 사용하지 않는 것이 좋습니다. 대신 패턴 일치를 사용하고 &lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 케이스를 명시 적으로 처리 하거나 &lt;a href=&quot;enum.option#method.unwrap_or&quot;&gt; &lt;code&gt;unwrap_or&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;enum.option#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;enum.option#method.unwrap_or_default&quot;&gt; &lt;code&gt;unwrap_or_default&lt;/code&gt; 를&lt;/a&gt; 호출 하는 것을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="324230b46d81d1ff99203ce38c74a82aa7a9a294" translate="yes" xml:space="preserve">
          <source>Because this function may panic, its use is generally discouraged. Instead, prefer to use pattern matching and handle the &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; case explicitly, or call &lt;a href=&quot;enum.result#method.unwrap_or&quot;&gt;&lt;code&gt;unwrap_or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.result#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;enum.result#method.unwrap_or_default&quot;&gt;&lt;code&gt;unwrap_or_default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능은 패닉이 발생할 수 있으므로 일반적으로 사용하지 않는 것이 좋습니다. 대신 패턴 일치를 사용하고 &lt;a href=&quot;enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 케이스를 명시 적으로 처리 하거나 &lt;a href=&quot;enum.result#method.unwrap_or&quot;&gt; &lt;code&gt;unwrap_or&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;enum.result#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;enum.result#method.unwrap_or_default&quot;&gt; &lt;code&gt;unwrap_or_default&lt;/code&gt; 를&lt;/a&gt; 호출 하는 것을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="f4fba9e24de13af0b7e1e106a0a89b1207341158" translate="yes" xml:space="preserve">
          <source>Because this representation delegates type layout to another type, it cannot be used with any other representation.</source>
          <target state="translated">이 표현은 유형 레이아웃을 다른 유형으로 위임하기 때문에 다른 표현과 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="210e09fafaa62c8b440f8de035b1059405d433ec" translate="yes" xml:space="preserve">
          <source>Because transparent enums are represented exactly like one of their variants at run time, said variant must be uniquely determined. If there is no variant, or if there are multiple variants, it is not clear how the enum should be represented.</source>
          <target state="translated">투명한 열거 형은 런타임에 해당 변형 중 하나와 똑같이 표시되므로 해당 변형을 고유하게 결정해야합니다. 변형이 없거나 변형이 여러 개인 경우 열거 형을 어떻게 표현해야하는지 명확하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fcd01a50be2628ee7e2de7196f3290d3a3e7d1ae" translate="yes" xml:space="preserve">
          <source>Because transparent structs are represented exactly like one of their fields at run time, said field must be uniquely determined. If there is no field, or if there are multiple fields, it is not clear how the struct should be represented. Note that fields of zero-sized types (e.g., &lt;code&gt;PhantomData&lt;/code&gt;) can also exist alongside the field that contains the actual data, they do not count for this error. When generic types are involved (as in the above example), an error is reported because the type parameter could be non-zero-sized.</source>
          <target state="translated">투명 구조체는 런타임에 필드 중 하나와 똑같이 표현되기 때문에 해당 필드는 고유하게 결정되어야합니다. 필드가 없거나 여러 필드가있는 경우 구조체를 표현하는 방법이 명확하지 않습니다. 크기가 0 인 유형의 필드 (예 : &lt;code&gt;PhantomData&lt;/code&gt; )도 실제 데이터를 포함하는 필드와 함께 존재할 수 있으며이 오류에 포함되지 않습니다. 제네릭 유형이 관련되면 (위의 예에서와 같이) 유형 매개 변수의 크기가 0이 아닐 수 있으므로 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="986c4abde2bf1faaf2d6c694b66e22c945ede5c1" translate="yes" xml:space="preserve">
          <source>Because transparent structs are represented exactly like one of their fields at run time, said field must be uniquely determined. If there is no field, or if there are multiple fields, it is not clear how the struct should be represented. Note that fields of zero-typed types (e.g., &lt;code&gt;PhantomData&lt;/code&gt;) can also exist alongside the field that contains the actual data, they do not count for this error. When generic types are involved (as in the above example), an error is reported because the type parameter could be non-zero-sized.</source>
          <target state="translated">투명한 구조체는 런타임에 해당 필드 중 하나와 정확히 동일하게 표시되므로 해당 필드는 고유하게 결정되어야합니다. 필드가 없거나 필드가 여러 개인 경우 구조체를 어떻게 표현해야하는지 명확하지 않습니다. 유형이 0 인 유형의 필드 (예 : &lt;code&gt;PhantomData&lt;/code&gt; )도 실제 데이터가 포함 된 필드와 함께 존재할 수 있으며이 오류에 포함되지 않습니다. 일반 유형이 포함 된 경우 (위의 예에서와 같이) 유형 매개 변수의 크기가 0이 아니기 때문에 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="f937fa2c0a9f5f4a819643c4edaf58d80a839cab" translate="yes" xml:space="preserve">
          <source>Because tuple elements don't have a name, they can only be accessed by pattern-matching or by using &lt;code&gt;N&lt;/code&gt; directly as a field to access the &lt;code&gt;N&lt;/code&gt;th element.</source>
          <target state="translated">튜플 요소에는 이름이 없으므로 패턴 일치 또는 &lt;code&gt;N&lt;/code&gt; 을 필드로 직접 사용 하여 &lt;code&gt;N&lt;/code&gt; 번째 요소 에 액세스 해야만 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efb0d44a57a7bf30820d634e0cfe1255770c836f" translate="yes" xml:space="preserve">
          <source>Because two equal values need to produce the same hash value, the implementation of &lt;code&gt;Hash&lt;/code&gt; needs to ignore ASCII case, too:</source>
          <target state="translated">두 개의 동일한 값이 동일한 해시 값을 생성해야하므로 &lt;code&gt;Hash&lt;/code&gt; 구현에서는 ASCII 대 / 소문자도 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="b787dccee7a3448c9761d599ebe1a0e8e174bf88" translate="yes" xml:space="preserve">
          <source>Because types that are made up of &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; traits are automatically also &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt;, we don&amp;rsquo;t have to implement those traits manually. As marker traits, they don&amp;rsquo;t even have any methods to implement. They&amp;rsquo;re just useful for enforcing invariants related to concurrency.</source>
          <target state="translated">&lt;code&gt;Send&lt;/code&gt; 및 &lt;code&gt;Sync&lt;/code&gt; 특성으로 구성된 유형 도 자동으로 &lt;code&gt;Send&lt;/code&gt; 및 &lt;code&gt;Sync&lt;/code&gt; 이므로 이러한 특성을 수동으로 구현할 필요가 없습니다. 마커 특성으로는 구현할 메소드가 없습니다. 동시성과 관련된 불변을 적용하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e80dfd56aee472a3a988ee77f8d092b4c7dec341" translate="yes" xml:space="preserve">
          <source>Because we called the function with &lt;code&gt;5&lt;/code&gt; as the value for &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;6&lt;/code&gt; is passed as the value for &lt;code&gt;y&lt;/code&gt;, the two strings are printed with these values.</source>
          <target state="translated">우리가 함수 호출 때문에 &lt;code&gt;5&lt;/code&gt; 의 값으로 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;6&lt;/code&gt; 에 대한 값으로 전달되는 &lt;code&gt;y&lt;/code&gt; , 두 문자열은 이들 값을 출력한다.</target>
        </trans-unit>
        <trans-unit id="085b82e8e32a790482293e536266e4e46e15732c" translate="yes" xml:space="preserve">
          <source>Because we didn&amp;rsquo;t cover (and couldn&amp;rsquo;t cover!) every valid value with the pattern &lt;code&gt;Some(x)&lt;/code&gt;, Rust rightfully produces a compiler error.</source>
          <target state="translated">우리는 &lt;code&gt;Some(x)&lt;/code&gt; 패턴으로 모든 유효한 값을 커버하지 못했고 커버 할 수 없었기 때문에 Rust는 컴파일러 에러를 당연히 발생시킨다.</target>
        </trans-unit>
        <trans-unit id="c4e7a282ae038191d5b4c16b5d5eaad3c33d3637" translate="yes" xml:space="preserve">
          <source>Because we don&amp;rsquo;t have any code that pauses or delays in the &lt;code&gt;for&lt;/code&gt; loop in the main thread, we can tell that the main thread is waiting to receive values from the spawned thread.</source>
          <target state="translated">메인 스레드 의 &lt;code&gt;for&lt;/code&gt; 루프에서 일시 정지되거나 지연되는 코드가 없기 때문에 메인 스레드가 생성 된 스레드로부터 값을 받기 위해 대기 중임을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a0bac08c9a7a0c19671aaf3dbc27401041da77e" translate="yes" xml:space="preserve">
          <source>Because we don&amp;rsquo;t have any tests we&amp;rsquo;ve marked as ignored, the summary shows &lt;code&gt;0 ignored&lt;/code&gt;. We also haven&amp;rsquo;t filtered the tests being run, so the end of the summary shows &lt;code&gt;0 filtered out&lt;/code&gt;. We&amp;rsquo;ll talk about ignoring and filtering out tests in the next section, &lt;a href=&quot;ch11-02-running-tests#controlling-how-tests-are-run&quot;&gt;&amp;ldquo;Controlling How Tests Are Run.&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">무시 된 것으로 표시된 테스트가 없으므로 요약에 표시됩니다. &lt;code&gt;0 ignored&lt;/code&gt; . 또한 실행중인 테스트를 필터링하지 않았으므로 요약의 끝에 &lt;code&gt;0 filtered out&lt;/code&gt; . 다음 섹션 인 &lt;a href=&quot;ch11-02-running-tests#controlling-how-tests-are-run&quot;&gt;&quot;테스트 실행 방법 제어&quot;&lt;/a&gt; 에서 테스트를 무시하고 필터링하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="19d2af6731059978bb0fd7b94ea0d510b217b381" translate="yes" xml:space="preserve">
          <source>Because we don&amp;rsquo;t need them anymore, let&amp;rsquo;s remove the &lt;code&gt;println!&lt;/code&gt; statements from &lt;em&gt;src/lib.rs&lt;/em&gt; and &lt;em&gt;src/main.rs&lt;/em&gt; that we used to check the program&amp;rsquo;s behavior. Then, in &lt;em&gt;src/lib.rs&lt;/em&gt;, we&amp;rsquo;ll add a &lt;code&gt;tests&lt;/code&gt; module with a test function, as we did in &lt;a href=&quot;ch11-01-writing-tests#the-anatomy-of-a-test-function&quot;&gt;Chapter 11&lt;/a&gt;. The test function specifies the behavior we want the &lt;code&gt;search&lt;/code&gt; function to have: it will take a query and the text to search for the query in, and it will return only the lines from the text that contain the query. Listing 12-15 shows this test, which won&amp;rsquo;t compile yet.</source>
          <target state="translated">더 이상 필요하지 않으므로 &lt;code&gt;println!&lt;/code&gt; 제거합시다 ! &lt;em&gt;src / lib.rs&lt;/em&gt; 및 &lt;em&gt;src / main.rs&lt;/em&gt; 에서 프로그램의 동작을 확인하는 데 사용한 명령문 . 그런 다음 &lt;em&gt;src / lib.rs&lt;/em&gt; 에서 &lt;code&gt;tests&lt;/code&gt; 에서 &lt;a href=&quot;ch11-01-writing-tests#the-anatomy-of-a-test-function&quot;&gt;11 장&lt;/a&gt; 에서와 같이 테스트 기능을 가진 테스트 모듈을 입니다. 테스트 함수는 &lt;code&gt;search&lt;/code&gt; 함수 가 원하는 동작을 지정합니다 . 쿼리와 쿼리를 검색 할 텍스트를 가져오고 쿼리가 포함 된 텍스트의 행만 반환합니다. Listing 12-15는 아직 컴파일되지 않은이 테스트를 보여준다.</target>
        </trans-unit>
        <trans-unit id="27d7fc6d652236fca2f45fe08fc889c62e6d8253" translate="yes" xml:space="preserve">
          <source>Because we just mentioned coins, let&amp;rsquo;s use them as an example using &lt;code&gt;match&lt;/code&gt;! We can write a function that can take an unknown United States coin and, in a similar way as the counting machine, determine which coin it is and return its value in cents, as shown here in Listing 6-3.</source>
          <target state="translated">우리는 방금 동전을 언급 했으므로 &lt;code&gt;match&lt;/code&gt; 를 사용하여 예제로 사용합시다 ! 우리는 알 수없는 미국 동전을 취할 수있는 함수를 작성할 수 있으며, 계산 기계와 유사한 방식으로 동전의 동전을 결정하고 센트 단위로 그 값을 반환합니다 (목록 6-3 참조).</target>
        </trans-unit>
        <trans-unit id="564bbf6a7d7bf6b1e61c40462e20a2bae78026d7" translate="yes" xml:space="preserve">
          <source>Because we made the &lt;code&gt;Appetizer&lt;/code&gt; enum public, we can use the &lt;code&gt;Soup&lt;/code&gt; and &lt;code&gt;Salad&lt;/code&gt; variants in &lt;code&gt;eat_at_restaurant&lt;/code&gt;. Enums aren&amp;rsquo;t very useful unless their variants are public; it would be annoying to have to annotate all enum variants with &lt;code&gt;pub&lt;/code&gt; in every case, so the default for enum variants is to be public. Structs are often useful without their fields being public, so struct fields follow the general rule of everything being private by default unless annotated with &lt;code&gt;pub&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Appetizer&lt;/code&gt; 열거 형을 공개 했기 때문에 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 에서 &lt;code&gt;Soup&lt;/code&gt; 및 &lt;code&gt;Salad&lt;/code&gt; 변형을 사용할 수 있습니다 . 열거 형은 변형이 공개되지 않으면 유용하지 않습니다. &lt;code&gt;pub&lt;/code&gt; 모든 열거 형 변형에 주석을 달아야한다는 것은 성 가실 것입니다.모든 경우에 일이므로 열거 형 변형의 기본값은 공개입니다. Structs는 필드가 공개되지 않은 상태에서 종종 유용하므로 구조체 필드는 &lt;code&gt;pub&lt;/code&gt; 로 주석을 달지 않는 한 기본적으로 모든 것이 개인의 일반 규칙을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="e429697f925edbd87724bb6af67eea48f644c38e" translate="yes" xml:space="preserve">
          <source>Because we need to go through the &lt;code&gt;String&lt;/code&gt; element by element and check whether a value is a space, we&amp;rsquo;ll convert our &lt;code&gt;String&lt;/code&gt; to an array of bytes using the &lt;code&gt;as_bytes&lt;/code&gt; method:</source>
          <target state="translated">우리가 통과해야하기 때문에 &lt;code&gt;String&lt;/code&gt; 요소에 의해 요소와 값에 공백이 있는지 여부를 확인, 우리는 우리의 변환합니다 &lt;code&gt;String&lt;/code&gt; 를 사용하는 바이트의 배열 &lt;code&gt;as_bytes&lt;/code&gt; 의 방법 :</target>
        </trans-unit>
        <trans-unit id="78563068540adbc0f963cccfafb7b2fef86f3a05" translate="yes" xml:space="preserve">
          <source>Because we&amp;rsquo;ve encapsulated the implementation details of the struct &lt;code&gt;AveragedCollection&lt;/code&gt;, we can easily change aspects, such as the data structure, in the future. For instance, we could use a &lt;code&gt;HashSet&amp;lt;i32&amp;gt;&lt;/code&gt; instead of a &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; for the &lt;code&gt;list&lt;/code&gt; field. As long as the signatures of the &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;average&lt;/code&gt; public methods stay the same, code using &lt;code&gt;AveragedCollection&lt;/code&gt; wouldn&amp;rsquo;t need to change. If we made &lt;code&gt;list&lt;/code&gt; public instead, this wouldn&amp;rsquo;t necessarily be the case: &lt;code&gt;HashSet&amp;lt;i32&amp;gt;&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; have different methods for adding and removing items, so the external code would likely have to change if it were modifying &lt;code&gt;list&lt;/code&gt; directly.</source>
          <target state="translated">구조체 &lt;code&gt;AveragedCollection&lt;/code&gt; 의 구현 세부 사항을 캡슐화 했으므로 향후 데이터 구조와 같은 측면을 쉽게 변경할 수 있습니다. 예를 들어, 우리는 사용할 수 &lt;code&gt;HashSet&amp;lt;i32&amp;gt;&lt;/code&gt; 대신의 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 에 대한 &lt;code&gt;list&lt;/code&gt; 필드. &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; 및 &lt;code&gt;average&lt;/code&gt; 공용 메소드 의 서명이 동일하게 유지되는 한 &lt;code&gt;AveragedCollection&lt;/code&gt; 을 사용하는 코드 는 변경할 필요가 없습니다. 우리가 대신 &lt;code&gt;list&lt;/code&gt; 공개 했다면 , 반드시 그런 것은 아닙니다. &lt;code&gt;HashSet&amp;lt;i32&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 항목을 추가하고 제거하는 다른 방법이 있으므로 &lt;code&gt;list&lt;/code&gt; 직접 수정하는 경우 외부 코드를 변경해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="012f083807416b28f83d8847eef6766da2f64d4c" translate="yes" xml:space="preserve">
          <source>Because we&amp;rsquo;ve given initial &lt;code&gt;i32&lt;/code&gt; values, Rust can infer that the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt;, and the type annotation isn&amp;rsquo;t necessary. Next, we&amp;rsquo;ll look at how to modify a vector.</source>
          <target state="translated">초기 &lt;code&gt;i32&lt;/code&gt; 값을 제공 했으므로 Rust는 &lt;code&gt;v&lt;/code&gt; 유형 이 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 이며 유 형 주석이 필요하지 않은 것으로 추론 할 수 있습니다 . 다음으로 벡터를 수정하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="9fe6f6ecc3242b6ec15902f2774b2a48334d7481" translate="yes" xml:space="preserve">
          <source>Because we&amp;rsquo;ve specified that &lt;code&gt;OutlinePrint&lt;/code&gt; requires the &lt;code&gt;Display&lt;/code&gt; trait, we can use the &lt;code&gt;to_string&lt;/code&gt; function that is automatically implemented for any type that implements &lt;code&gt;Display&lt;/code&gt;. If we tried to use &lt;code&gt;to_string&lt;/code&gt; without adding a colon and specifying the &lt;code&gt;Display&lt;/code&gt; trait after the trait name, we&amp;rsquo;d get an error saying that no method named &lt;code&gt;to_string&lt;/code&gt; was found for the type &lt;code&gt;&amp;amp;Self&lt;/code&gt; in the current scope.</source>
          <target state="translated">우리가 있음을 지정한 때문에 &lt;code&gt;OutlinePrint&lt;/code&gt; 이 필요 &lt;code&gt;Display&lt;/code&gt; 특성을, 우리는 사용할 수 &lt;code&gt;to_string&lt;/code&gt; 의 자동 구현이 있음을 모든 유형의 구현 기능 &lt;code&gt;Display&lt;/code&gt; . 콜론을 추가하지 않고 특성 이름 뒤에 &lt;code&gt;Display&lt;/code&gt; 특성을 지정하지 않고 &lt;code&gt;to_string&lt;/code&gt; 을 사용하려고 하면 현재 범위의 &lt;code&gt;&amp;amp;Self&lt;/code&gt; 유형에 대해 &lt;code&gt;to_string&lt;/code&gt; 이라는 메소드 를 찾을 수 없다는 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="627748e661f805aeaed04a41d6aadf854f4f0452" translate="yes" xml:space="preserve">
          <source>Because we're not buffering, we write each one in turn, incurring the overhead of a system call per byte written. We can fix this with a &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">버퍼링이 아니기 때문에 각각을 차례로 작성하여 쓴 바이트 당 시스템 호출의 오버 헤드를 발생시킵니다. &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt; 로이 문제를 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a715fdf861e47ef758515cd362976557a262f981" translate="yes" xml:space="preserve">
          <source>Because we're not buffering, we write each one in turn, incurring the overhead of a system call per byte written. We can fix this with a &lt;code&gt;BufWriter&lt;/code&gt;:</source>
          <target state="translated">우리는 버퍼링을하지 않기 때문에 각 바이트마다 차례로 시스템 호출의 오버 헤드를 발생시켜 각각을 작성합니다. 우리는 이것을 &lt;code&gt;BufWriter&lt;/code&gt; 로 고칠 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cbd558490c4d9352a7af3024ff9549f8d11edc55" translate="yes" xml:space="preserve">
          <source>Because you can stack-allocate a &lt;code&gt;[u8; N]&lt;/code&gt;, and you can take a &lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt; of it, this function is one way to have a stack-allocated string. There is an example of this in the examples section below.</source>
          <target state="translated">당신이 할 수 있기 때문에 스택 - 할당 &lt;code&gt;[u8; N]&lt;/code&gt; , 당신은 걸릴 수 있습니다&lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt; 이 함수는 스택 할당 문자열을 갖는 한 가지 방법입니다. 아래 예제 섹션에 이에 대한 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="abb004f87792d4a102d3232d143d81ed4ffc2ed8" translate="yes" xml:space="preserve">
          <source>Before an expression used as a &lt;a href=&quot;statements&quot;&gt;statement&lt;/a&gt;.</source>
          <target state="translated">A와 사용되는 표현하기 전에 &lt;a href=&quot;statements&quot;&gt;문&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6fb622789c9cc297dc766f85b7b47e7c5b64a4c2" translate="yes" xml:space="preserve">
          <source>Before diving into generics syntax, let&amp;rsquo;s first look at how to remove duplication that doesn&amp;rsquo;t involve generic types by extracting a function. Then we&amp;rsquo;ll apply this technique to extract a generic function! In the same way that you recognize duplicated code to extract into a function, you&amp;rsquo;ll start to recognize duplicated code that can use generics.</source>
          <target state="translated">제네릭 구문으로 들어가기 전에 먼저 함수를 추출하여 제네릭 형식과 관련이없는 중복을 제거하는 방법을 살펴 보겠습니다. 그런 다음이 기술을 적용하여 일반 함수를 추출합니다! 함수로 추출하기 위해 중복 된 코드를 인식하는 것과 같은 방식으로 제네릭을 사용할 수있는 중복 된 코드를 인식하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="beaf5bffc2c85ad951a60c9ddac3eebe2cec9b8f" translate="yes" xml:space="preserve">
          <source>Before explaining more, let's talk about how this module is structured:</source>
          <target state="translated">자세한 내용을 설명하기 전에이 모듈의 구성 방식에 대해 이야기 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="cd09ad07440aee110c115ad35adea181d0515ee9" translate="yes" xml:space="preserve">
          <source>Before running a Rust program, you must compile it using the Rust compiler by entering the &lt;code&gt;rustc&lt;/code&gt; command and passing it the name of your source file, like this:</source>
          <target state="translated">Rust 프로그램을 실행하기 전에 &lt;code&gt;rustc&lt;/code&gt; 를 입력하여 Rust 컴파일러를 사용하여 컴파일해야합니다 명령 과 같이 소스 파일 이름을 전달 .</target>
        </trans-unit>
        <trans-unit id="992020b016b482ffafd2657fccaa8d509f2063e9" translate="yes" xml:space="preserve">
          <source>Before the loop, we declare a variable named &lt;code&gt;counter&lt;/code&gt; and initialize it to &lt;code&gt;0&lt;/code&gt;. Then we declare a variable named &lt;code&gt;result&lt;/code&gt; to hold the value returned from the loop. On every iteration of the loop, we add &lt;code&gt;1&lt;/code&gt; to the &lt;code&gt;counter&lt;/code&gt; variable, and then check whether the counter is equal to &lt;code&gt;10&lt;/code&gt;. When it is, we use the &lt;code&gt;break&lt;/code&gt; keyword with the value &lt;code&gt;counter * 2&lt;/code&gt;. After the loop, we use a semicolon to end the statement that assigns the value to &lt;code&gt;result&lt;/code&gt;. Finally, we print the value in &lt;code&gt;result&lt;/code&gt;, which in this case is 20.</source>
          <target state="translated">루프 전에 &lt;code&gt;counter&lt;/code&gt; 라는 변수를 선언하고 &lt;code&gt;0&lt;/code&gt; 으로 초기화합니다 . 그런 다음 루프에서 반환 된 값을 보유하도록 &lt;code&gt;result&lt;/code&gt; 라는 변수를 선언합니다 . 루프가 반복 될 때마다 &lt;code&gt;counter&lt;/code&gt; 변수 에 &lt;code&gt;1&lt;/code&gt; 을 더한 다음 카운터가 &lt;code&gt;10&lt;/code&gt; 인지 확인합니다 . 그렇다면 &lt;code&gt;break&lt;/code&gt; 키워드를 값 &lt;code&gt;counter * 2&lt;/code&gt; 와 함께 사용합니다 . 루프 후, 세미콜론을 사용하여 &lt;code&gt;result&lt;/code&gt; 값을 할당하는 명령문을 종료합니다 . 마지막으로 &lt;code&gt;result&lt;/code&gt; 값을 출력합니다 .이 경우 20입니다.</target>
        </trans-unit>
        <trans-unit id="31a496e8ed09fdd1bd621c7cc15fdcecbd8eebc7" translate="yes" xml:space="preserve">
          <source>Before we begin implementing a thread pool, let&amp;rsquo;s talk about what using the pool should look like. When you&amp;rsquo;re trying to design code, writing the client interface first can help guide your design. Write the API of the code so it&amp;rsquo;s structured in the way you want to call it; then implement the functionality within that structure rather than implementing the functionality and then designing the public API.</source>
          <target state="translated">스레드 풀 구현을 시작하기 전에 풀 사용의 모양에 대해 이야기하겠습니다. 코드를 디자인하려고 할 때 먼저 클라이언트 인터페이스를 작성하면 디자인을 안내하는 데 도움이 될 수 있습니다. 코드의 API를 작성하여 원하는 방식으로 구성하십시오. 그런 다음 기능을 구현 한 다음 공개 API를 디자인하는 대신 해당 구조 내에서 기능을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="5531bdacd5e27e11cff8fcc2e36e3c004527f8b8" translate="yes" xml:space="preserve">
          <source>Before we discuss this use case for &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, we&amp;rsquo;ll cover the syntax and how to interact with values stored within a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 사용 사례를 논의하기 전에 구문과 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 내에 저장된 값과 상호 작용하는 방법을 다룰 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d85d751d3cdedcf3deebd350f36e7cb28a00a5d2" translate="yes" xml:space="preserve">
          <source>Before we go into more details to explain the guarantees and choices associated with &lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt;, we discuss some examples for how it might be used. Feel free to &lt;a href=&quot;#drop-guarantee&quot;&gt;skip to where the theoretical discussion continues&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; 과 관련된 보증 및 선택 사항을 설명하기 위해 더 자세히 설명하기 전에 사용 방법에 대한 몇 가지 예를 논의합니다. &lt;a href=&quot;#drop-guarantee&quot;&gt;이론적 토론이 계속되는 곳&lt;/a&gt; 으로 건너 뛰어도됩니다 .</target>
        </trans-unit>
        <trans-unit id="1e5cb50dd4a282df49da6b5ffaeda1d9ab676ba8" translate="yes" xml:space="preserve">
          <source>Before you can publish any crates, you need to create an account on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; and get an API token. To do so, visit the home page at &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; and log in via a GitHub account. (The GitHub account is currently a requirement, but the site might support other ways of creating an account in the future.) Once you&amp;rsquo;re logged in, visit your account settings at &lt;a href=&quot;https://crates.io/me/&quot;&gt;https://crates.io/me/&lt;/a&gt; and retrieve your API key. Then run the &lt;code&gt;cargo login&lt;/code&gt; command with your API key, like this:</source>
          <target state="translated">상자를 게시하기 전에 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io에&lt;/a&gt; 계정을 만들고 API 토큰 을 가져와야 합니다. 이렇게하려면 홈페이지 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io를&lt;/a&gt; 방문하여 GitHub 계정을 통해 로그인 하십시오 . (GitHub 계정은 현재 요구 사항이지만 사이트는 나중에 계정을 만드는 다른 방법을 지원할 수 있습니다.) 로그인 한 후 &lt;a href=&quot;https://crates.io/me/&quot;&gt;https://crates.io/me/&lt;/a&gt; 에서 계정 설정을 방문 하여 API 키. 그런 다음 API 키로 다음과 같이 &lt;code&gt;cargo login&lt;/code&gt; 명령을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="842beb51ca9c5417a27f472386d0e0d52dcc074f" translate="yes" xml:space="preserve">
          <source>Before:</source>
          <target state="translated">Before:</target>
        </trans-unit>
        <trans-unit id="bb11daf93347e89962e3d0ed85d6b809ec3ab729" translate="yes" xml:space="preserve">
          <source>Beginning in the 2018 edition, &lt;a href=&quot;use-declarations&quot;&gt;use declarations&lt;/a&gt; can reference crates in the extern prelude, so it is considered unidiomatic to use &lt;code&gt;extern crate&lt;/code&gt;.</source>
          <target state="translated">2018 버전부터 &lt;a href=&quot;use-declarations&quot;&gt;사용 선언&lt;/a&gt; 은 extern prelude에서 상자를 참조 할 수 있으므로 &lt;code&gt;extern crate&lt;/code&gt; 를 사용하는 것은 단오적인 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="f69c63a9aa10f7772ed95a8efc915f42e685135b" translate="yes" xml:space="preserve">
          <source>Beginning in the 2018 edition, &lt;code&gt;dyn&lt;/code&gt; has been promoted to a strict keyword.</source>
          <target state="translated">2018 년 초부터 &lt;code&gt;dyn&lt;/code&gt; 은 엄격한 키워드로 승격되었습니다.</target>
        </trans-unit>
        <trans-unit id="747fb066bbb4af54f78aaa8f212256984b77092b" translate="yes" xml:space="preserve">
          <source>Beginning in the 2018 edition, &lt;code&gt;dyn&lt;/code&gt; is a true keyword and is not allowed in paths, so the parentheses are not necessary.</source>
          <target state="translated">2018 년판부터 &lt;code&gt;dyn&lt;/code&gt; 은 진정한 키워드이며 경로에 사용할 수 없으므로 괄호가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="88113dc243c443e4dd51d39dc5f37a435a2966eb" translate="yes" xml:space="preserve">
          <source>Beginning in the 2018 edition, function or method parameter patterns are no longer optional. Also, all irrefutable patterns are allowed as long as there is a body. Without a body, the limitations listed above are still in effect.</source>
          <target state="translated">2018 년판부터 기능 또는 분석법 매개 변수 패턴은 더 이상 선택 사항이 아닙니다. 또한 신체가있는 한 반박 할 수없는 모든 패턴이 허용됩니다. 본문이 없으면 위에 나열된 제한 사항이 여전히 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="72201b43a6b1623bf8606d5ddd5bead0602a3d00" translate="yes" xml:space="preserve">
          <source>Beginning with the 2018 Edition, paths starting with &lt;code&gt;::&lt;/code&gt; can only reference crates.</source>
          <target state="translated">2018 년판부터 &lt;code&gt;::&lt;/code&gt; 로 시작하는 경로 는 상자 만 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="020cfc8d7ce4473da0deda931f3cf2410d4b4068" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the contents are set to zero before being returned.</source>
          <target state="translated">&lt;code&gt;alloc&lt;/code&gt; 처럼 작동 하지만 반환되기 전에 내용이 0으로 설정되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="26b6dab3100989fb3cbafd53582c862ac5c9f9f9" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the contents are set to zero before being returned. &lt;a href=&quot;trait.alloc#method.alloc_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;alloc&lt;/code&gt; 처럼 작동 하지만 반환되기 전에 내용이 0으로 설정되어 있는지 확인합니다. &lt;a href=&quot;trait.alloc#method.alloc_zeroed&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cebb7ac8ceac00cf4605e1537d21a42ae0a8334d" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the contents are set to zero before being returned. &lt;a href=&quot;trait.globalalloc#method.alloc_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;alloc&lt;/code&gt; 처럼 작동 하지만 반환되기 전에 내용이 0으로 설정되어 있는지 확인합니다. &lt;a href=&quot;trait.globalalloc#method.alloc_zeroed&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="082a664b538f66f0a51ac4134a98aba6f77d5cde" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the returned memory is zero-initialized. &lt;a href=&quot;alloc/trait.allocref#method.alloc_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;alloc&lt;/code&gt; 처럼 동작 하지만 반환 된 메모리가 0으로 초기화되도록합니다. &lt;a href=&quot;alloc/trait.allocref#method.alloc_zeroed&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be234e6a7de7bb5e73ad2c0df1090886fa61a11b" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the returned memory is zero-initialized. &lt;a href=&quot;trait.allocref#method.alloc_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;alloc&lt;/code&gt; 처럼 동작 하지만 반환 된 메모리가 0으로 초기화되도록합니다. &lt;a href=&quot;trait.allocref#method.alloc_zeroed&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="16853ad48a342bbd03514f294c9cb5b40dbdc15d" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also returns the whole size of the returned block. For some &lt;code&gt;layout&lt;/code&gt; inputs, like arrays, this may include extra storage usable for additional data.</source>
          <target state="translated">&lt;code&gt;alloc&lt;/code&gt; 처럼 동작 하지만 반환 된 블록의 전체 크기도 반환합니다. 어레이와 같은 일부 &lt;code&gt;layout&lt;/code&gt; 입력의 경우 추가 데이터에 사용할 수있는 추가 스토리지가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40c1d1b115b0d7d4586e89d6b5493bd9bd25a35d" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also returns the whole size of the returned block. For some &lt;code&gt;layout&lt;/code&gt; inputs, like arrays, this may include extra storage usable for additional data. &lt;a href=&quot;trait.alloc#method.alloc_excess&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;alloc&lt;/code&gt; 처럼 동작 하지만 반환 된 블록의 전체 크기도 반환합니다. 어레이와 같은 일부 &lt;code&gt;layout&lt;/code&gt; 입력의 경우 추가 데이터에 사용할 수있는 추가 스토리지가 포함될 수 있습니다. &lt;a href=&quot;trait.alloc#method.alloc_excess&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dcc5bb4de65f26b5cfc9c0d306890b6a3dfd8426" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;grow&lt;/code&gt;, but also ensures that the new contents are set to zero before being returned. &lt;a href=&quot;alloc/trait.allocref#method.grow_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;grow&lt;/code&gt; 처럼 동작 하지만 반환되기 전에 새 콘텐츠가 0으로 설정되도록합니다. &lt;a href=&quot;alloc/trait.allocref#method.grow_zeroed&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b00b17315ce422677165dd747a2622a3bae967c2" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;grow&lt;/code&gt;, but also ensures that the new contents are set to zero before being returned. &lt;a href=&quot;trait.allocref#method.grow_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;grow&lt;/code&gt; 처럼 동작 하지만 반환되기 전에 새 콘텐츠가 0으로 설정되도록합니다. &lt;a href=&quot;trait.allocref#method.grow_zeroed&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6dee35b4dc6dfa21486bfd27863270c134037f5" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;realloc&lt;/code&gt;, but also returns the whole size of the returned block. For some &lt;code&gt;layout&lt;/code&gt; inputs, like arrays, this may include extra storage usable for additional data.</source>
          <target state="translated">&lt;code&gt;realloc&lt;/code&gt; 과 같이 작동 하지만 반환 된 블록의 전체 크기도 반환합니다. 어레이와 같은 일부 &lt;code&gt;layout&lt;/code&gt; 입력의 경우 추가 데이터에 사용할 수있는 추가 스토리지가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c12028831748d6fe621f72695ab145b2de0f2ea6" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;realloc&lt;/code&gt;, but also returns the whole size of the returned block. For some &lt;code&gt;layout&lt;/code&gt; inputs, like arrays, this may include extra storage usable for additional data. &lt;a href=&quot;trait.alloc#method.realloc_excess&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;realloc&lt;/code&gt; 과 같이 작동 하지만 반환 된 블록의 전체 크기도 반환합니다. 어레이와 같은 일부 &lt;code&gt;layout&lt;/code&gt; 입력의 경우 추가 데이터에 사용할 수있는 추가 스토리지가 포함될 수 있습니다. &lt;a href=&quot;trait.alloc#method.realloc_excess&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="70cb647a88bd7c9c17d225eecdaf0f898261eb60" translate="yes" xml:space="preserve">
          <source>Behavior</source>
          <target state="translated">Behavior</target>
        </trans-unit>
        <trans-unit id="095fb761bd6565ed9b50c488d53be7f174ad6258" translate="yes" xml:space="preserve">
          <source>Behavior considered undefined</source>
          <target state="translated">행동은 정의되지 않은 것으로 간주</target>
        </trans-unit>
        <trans-unit id="387f0e642c525f9f6e8bb2a3ac2dfb1f45db317b" translate="yes" xml:space="preserve">
          <source>Behavior during const evaluation</source>
          <target state="translated">const 평가 중 동작</target>
        </trans-unit>
        <trans-unit id="b1544a3801fc2d10e0c4fa2700cbde205e380188" translate="yes" xml:space="preserve">
          <source>Behavior is undefined if any of the following conditions are violated:</source>
          <target state="translated">다음 조건 중 하나라도 위반하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d1d94b77ecaf322c48c942eb7769975f61f7e1b" translate="yes" xml:space="preserve">
          <source>Behavior not considered &lt;code id=&quot;behavior-not-considered-unsafe&quot;&gt;unsafe&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;behavior-not-considered-unsafe&quot;&gt;unsafe&lt;/code&gt; 않은 것으로 간주되는 행동</target>
        </trans-unit>
        <trans-unit id="3c89d307ed32970842af58f6e49fccbe4976a8de" translate="yes" xml:space="preserve">
          <source>Behavior not considered &lt;code&gt;unsafe&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 않은 것으로 간주되는 동작</target>
        </trans-unit>
        <trans-unit id="56466d174610967ccd7c4e4d2f8e7fb575e6e68b" translate="yes" xml:space="preserve">
          <source>Being unable to change the value of a variable might have reminded you of another programming concept that most other languages have: &lt;em&gt;constants&lt;/em&gt;. Like immutable variables, constants are values that are bound to a name and are not allowed to change, but there are a few differences between constants and variables.</source>
          <target state="translated">: 변수의 값을 변경할 수 없습니다 있다는 것은 대부분의 다른 언어를 가지고 다른 프로그래밍 개념의 당신을 생각 나게 수도 &lt;em&gt;상수&lt;/em&gt; . 불변 변수와 마찬가지로 상수는 이름에 바인딩되어 변경할 수없는 값이지만 상수와 변수에는 약간의 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b1f5f4233d209308eb232700a1ebe15446b03df" translate="yes" xml:space="preserve">
          <source>Believe it or not, there is much more to learn on the topics we discussed in this chapter: Chapter 17 discusses trait objects, which are another way to use traits. Chapter 19 covers more complex scenarios involving lifetime annotations as well as some advanced type system features. But next, you&amp;rsquo;ll learn how to write tests in Rust so you can make sure your code is working the way it should.</source>
          <target state="translated">믿거 나 말거나,이 장에서 논의한 주제에 대해 더 많은 것을 배울 수 있습니다. 17 장에서는 특성을 사용하는 또 다른 방법 인 특성 개체에 대해 설명합니다. 19 장은 평생 주석 및 일부 고급 유형 시스템 기능과 관련된보다 복잡한 시나리오를 다룹니다. 그러나 다음으로 Rust에서 테스트를 작성하는 방법을 배우고 코드가 정상적으로 작동하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58b3731b9aba86dccac77d4faa0d50972846f846" translate="yes" xml:space="preserve">
          <source>Believe it or not, there is much more to learn on the topics we discussed in this chapter: Chapter 17 discusses trait objects, which are another way to use traits. There are also more complex scenarios involving lifetime annotations that you will only need in very advanced scenarios; for those, you should read the &lt;a href=&quot;../reference/index&quot;&gt;Rust Reference&lt;/a&gt;. But next, you&amp;rsquo;ll learn how to write tests in Rust so you can make sure your code is working the way it should.</source>
          <target state="translated">믿거 나 말거나,이 장에서 논의한 주제에 대해 배울 것이 훨씬 더 많습니다. 17 장은 특성을 사용하는 또 다른 방법 인 특성 객체에 대해 설명합니다. 또한 매우 고급 시나리오에서만 필요한 수명 주석과 관련된 더 복잡한 시나리오가 있습니다. 이를 위해서는 &lt;a href=&quot;../reference/index&quot;&gt;Rust Reference를&lt;/a&gt; 읽어야합니다 . 하지만 다음으로 Rust로 테스트를 작성하는 방법을 배우고 코드가 제대로 작동하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d677fae0ad7b93321bdf5902d4670326f019ecfb" translate="yes" xml:space="preserve">
          <source>Below are formal inductive definitions for FIRST and LAST.</source>
          <target state="translated">다음은 FIRST 및 LAST에 대한 공식적인 귀납적 정의입니다.</target>
        </trans-unit>
        <trans-unit id="9aa1c322ef5127bad20114a3c08180f48d6a1ff0" translate="yes" xml:space="preserve">
          <source>Below are some examples of FIRST and LAST. (Note in particular how the special &amp;epsilon; element is introduced and eliminated based on the interaction between the pieces of the input.)</source>
          <target state="translated">다음은 FIRST 및 LAST의 일부 예입니다. (특히 입력 요소 간의 상호 작용을 기반으로 특수 &amp;epsilon; 요소를 도입하고 제거하는 방법에 유의하십시오.)</target>
        </trans-unit>
        <trans-unit id="7b50be87542e5985746393609c4b0d26c14c49a1" translate="yes" xml:space="preserve">
          <source>Below is an example that shows under what conditions the compiler keeps a &lt;code&gt;static&lt;/code&gt; item in the output object file.</source>
          <target state="translated">아래는 컴파일러가 어떤 조건 에서 출력 객체 파일에 &lt;code&gt;static&lt;/code&gt; 항목을 유지하는지 보여주는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="1aa487609f84f4a503144112602dbfe1aef5f203" translate="yes" xml:space="preserve">
          <source>Below is shown a &lt;code&gt;panic_handler&lt;/code&gt; function that logs the panic message and then halts the thread.</source>
          <target state="translated">다음은 패닉 메시지를 기록한 다음 스레드를 정지 시키는 &lt;code&gt;panic_handler&lt;/code&gt; 함수입니다.</target>
        </trans-unit>
        <trans-unit id="2a2f598979a5de21d86b57d75eda1c3bfc34d2c7" translate="yes" xml:space="preserve">
          <source>Besides basic data types, the standard library is largely concerned with abstracting over differences in common platforms, most notably Windows and Unix derivatives.</source>
          <target state="translated">기본 데이터 유형 외에도 표준 라이브러리는 공통 플랫폼, 특히 Windows 및 Unix 파생 상품의 차이점에 대한 추상화와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f03b60f7e52b7ce49ed1e4f9fa511c452a2185bb" translate="yes" xml:space="preserve">
          <source>Beta</source>
          <target state="translated">Beta</target>
        </trans-unit>
        <trans-unit id="234f044b4bf52384fd2873935962aa4a005b114a" translate="yes" xml:space="preserve">
          <source>Beyond that, there are two important traits that are provided: &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.bufread&quot;&gt;&lt;code&gt;BufRead&lt;/code&gt;&lt;/a&gt;. Both of these build on top of a reader to control how the reading happens. &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; lets you control where the next byte is coming from:</source>
          <target state="translated">그 외에도 &lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;trait.bufread&quot;&gt; &lt;code&gt;BufRead&lt;/code&gt; &lt;/a&gt; 라는 두 가지 중요한 특성이 제공됩니다 . 이 두 가지 모두 판독 방식을 기반으로 판독 방식을 제어합니다. &lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; 를&lt;/a&gt; 사용하면 다음 바이트의 출처를 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66639f7d455dd71faa9147f5d69e5ce885d8bebd" translate="yes" xml:space="preserve">
          <source>Binary</source>
          <target state="translated">Binary</target>
        </trans-unit>
        <trans-unit id="528a653c1337877f018509c599539f6092a1c73c" translate="yes" xml:space="preserve">
          <source>Binary integer</source>
          <target state="translated">이진 정수</target>
        </trans-unit>
        <trans-unit id="c45c03039baf74ccb71d2cd15ae8c1ec54d6c3fc" translate="yes" xml:space="preserve">
          <source>Binary operator expressions (&lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;&lt;em&gt;ArithmeticOrLogicalExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;&lt;em&gt;ComparisonExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;&lt;em&gt;LazyBooleanExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;&lt;em&gt;TypeCastExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;&lt;em&gt;AssignmentExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;&lt;em&gt;CompoundAssignmentExpression&lt;/em&gt;&lt;/a&gt;).</source>
          <target state="translated">이진 연산자 표현식 ( &lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;&lt;em&gt;ArithmeticOrLogicalExpression&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;&lt;em&gt;ComparisonExpression&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;&lt;em&gt;LazyBooleanExpression&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;&lt;em&gt;TypeCastExpression&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;&lt;em&gt;AssignmentExpression&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;&lt;em&gt;CompoundAssignmentExpression&lt;/em&gt;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="19f576ed80d6aac8fef3b9d639229b5cf1b86087" translate="yes" xml:space="preserve">
          <source>Binary operators expressions are all written with infix notation. This table summarizes the behavior of arithmetic and logical binary operators on primitive types and which traits are used to overload these operators for other types. Remember that signed integers are always represented using two's complement. The operands of all of these operators are evaluated in &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression context&lt;/a&gt; so are moved or copied.</source>
          <target state="translated">이진 연산자 식은 모두 중위 표기법으로 작성됩니다. 이 표는 기본 유형에 대한 산술 및 논리 이진 연산자의 동작과 다른 유형에 대해 이러한 연산자를 오버로드하는 데 사용되는 특성을 요약합니다. 부호있는 정수는 항상 2의 보수를 사용하여 표현됩니다. 이러한 모든 연산자의 피연산자는 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;값 표현식 컨텍스트&lt;/a&gt; 에서 평가 되므로 이동하거나 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="bb24e7a177053effeaa97b02e6e1d53bea903394" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted slice for a given element.</source>
          <target state="translated">이진은이 정렬 된 슬라이스에서 주어진 요소를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="342759ca0bc54fef96ecf37bc0ddadb9e9d73749" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted slice with a comparator function.</source>
          <target state="translated">이진법은이 정렬 된 슬라이스를 비교기 기능으로 검색합니다.</target>
        </trans-unit>
        <trans-unit id="7bc8abd5fd12b3c23822c666fc1626829d2282bf" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted slice with a key extraction function.</source>
          <target state="translated">이진은이 추출 된 슬라이스를 키 추출 기능으로 검색합니다.</target>
        </trans-unit>
        <trans-unit id="0f756fdf55ff6fbf54d5489a870831d4c60ffda7" translate="yes" xml:space="preserve">
          <source>Binary::fmt</source>
          <target state="translated">Binary::fmt</target>
        </trans-unit>
        <trans-unit id="f4b68b2fab22d221207f75497f220c953edad9fd" translate="yes" xml:space="preserve">
          <source>BinaryHeap</source>
          <target state="translated">BinaryHeap</target>
        </trans-unit>
        <trans-unit id="dacf4e220750a1b0f951db1cac365b1b687b357f" translate="yes" xml:space="preserve">
          <source>BinaryHeap::append</source>
          <target state="translated">BinaryHeap::append</target>
        </trans-unit>
        <trans-unit id="237581b8c07d3a6f7c2056bca73d832b0ff9b185" translate="yes" xml:space="preserve">
          <source>BinaryHeap::borrow</source>
          <target state="translated">BinaryHeap::borrow</target>
        </trans-unit>
        <trans-unit id="6cc1c3995d6cbe9775c025f1c009843f3a795e95" translate="yes" xml:space="preserve">
          <source>BinaryHeap::borrow_mut</source>
          <target state="translated">BinaryHeap::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ea651796c70f924cd09768869629d83a528f3966" translate="yes" xml:space="preserve">
          <source>BinaryHeap::capacity</source>
          <target state="translated">BinaryHeap::capacity</target>
        </trans-unit>
        <trans-unit id="4db927bbac3d9fd9afcc396f05abd8a6d2369849" translate="yes" xml:space="preserve">
          <source>BinaryHeap::clear</source>
          <target state="translated">BinaryHeap::clear</target>
        </trans-unit>
        <trans-unit id="44380118a5aafd372e4d29c4729fc27883446a63" translate="yes" xml:space="preserve">
          <source>BinaryHeap::clone</source>
          <target state="translated">BinaryHeap::clone</target>
        </trans-unit>
        <trans-unit id="c4238fb46fd7eaa2a0823eded93fee09138cb72e" translate="yes" xml:space="preserve">
          <source>BinaryHeap::clone_from</source>
          <target state="translated">BinaryHeap::clone_from</target>
        </trans-unit>
        <trans-unit id="b77853e2e7d4b57b08f38a8fa17f28d29076c075" translate="yes" xml:space="preserve">
          <source>BinaryHeap::clone_into</source>
          <target state="translated">BinaryHeap::clone_into</target>
        </trans-unit>
        <trans-unit id="d4e562b332ce963cb95b5b307cb7485615e014fc" translate="yes" xml:space="preserve">
          <source>BinaryHeap::default</source>
          <target state="translated">BinaryHeap::default</target>
        </trans-unit>
        <trans-unit id="fdc5438d4f6cad011f4663afcc9664e54dc0d85e" translate="yes" xml:space="preserve">
          <source>BinaryHeap::drain</source>
          <target state="translated">BinaryHeap::drain</target>
        </trans-unit>
        <trans-unit id="0aaca4d42181f37288aa7e21316d709a6ff71f49" translate="yes" xml:space="preserve">
          <source>BinaryHeap::extend</source>
          <target state="translated">BinaryHeap::extend</target>
        </trans-unit>
        <trans-unit id="f4c67172d6c1cdb39c6636230b079c173cf83f2c" translate="yes" xml:space="preserve">
          <source>BinaryHeap::fmt</source>
          <target state="translated">BinaryHeap::fmt</target>
        </trans-unit>
        <trans-unit id="871dac7b5ceedfbec71447a6d6ed9de357acd044" translate="yes" xml:space="preserve">
          <source>BinaryHeap::from</source>
          <target state="translated">BinaryHeap::from</target>
        </trans-unit>
        <trans-unit id="f175a9eb33f99d6629fe67f65984c4a890519755" translate="yes" xml:space="preserve">
          <source>BinaryHeap::from_iter</source>
          <target state="translated">BinaryHeap::from_iter</target>
        </trans-unit>
        <trans-unit id="abdea679542fd107e906ae5d58ce503cb54c014d" translate="yes" xml:space="preserve">
          <source>BinaryHeap::into</source>
          <target state="translated">BinaryHeap::into</target>
        </trans-unit>
        <trans-unit id="45541a8cf8b33e80b63d4c7b7d8a3acfe03252c0" translate="yes" xml:space="preserve">
          <source>BinaryHeap::into_iter</source>
          <target state="translated">BinaryHeap::into_iter</target>
        </trans-unit>
        <trans-unit id="a4f3a26fa362623ceae23603112262e72024f7b9" translate="yes" xml:space="preserve">
          <source>BinaryHeap::into_sorted_vec</source>
          <target state="translated">BinaryHeap::into_sorted_vec</target>
        </trans-unit>
        <trans-unit id="1db086875600549522e8a9e52684ebd526b5b129" translate="yes" xml:space="preserve">
          <source>BinaryHeap::into_vec</source>
          <target state="translated">BinaryHeap::into_vec</target>
        </trans-unit>
        <trans-unit id="a112ebac833a70561b615451c2e74f51b6f19a74" translate="yes" xml:space="preserve">
          <source>BinaryHeap::is_empty</source>
          <target state="translated">BinaryHeap::is_empty</target>
        </trans-unit>
        <trans-unit id="0ee572360922722532c0921740eb1f614a7ab7ce" translate="yes" xml:space="preserve">
          <source>BinaryHeap::iter</source>
          <target state="translated">BinaryHeap::iter</target>
        </trans-unit>
        <trans-unit id="119b277a11fb08dfc4b80fb6b74bafd3221914e4" translate="yes" xml:space="preserve">
          <source>BinaryHeap::len</source>
          <target state="translated">BinaryHeap::len</target>
        </trans-unit>
        <trans-unit id="227d527ad8e44dcb2418c2e7e8e075d2359fb772" translate="yes" xml:space="preserve">
          <source>BinaryHeap::new</source>
          <target state="translated">BinaryHeap::new</target>
        </trans-unit>
        <trans-unit id="1fed1ee8afbb235ea1f87d7947786969b3a00687" translate="yes" xml:space="preserve">
          <source>BinaryHeap::peek</source>
          <target state="translated">BinaryHeap::peek</target>
        </trans-unit>
        <trans-unit id="23133fcfda988b66f1b73cca51b41c4297acc6b5" translate="yes" xml:space="preserve">
          <source>BinaryHeap::peek_mut</source>
          <target state="translated">BinaryHeap::peek_mut</target>
        </trans-unit>
        <trans-unit id="d6e00b82d35a37cd32b1907ca0812180a4fe6813" translate="yes" xml:space="preserve">
          <source>BinaryHeap::pop</source>
          <target state="translated">BinaryHeap::pop</target>
        </trans-unit>
        <trans-unit id="9d087a89ba80a46d773a7b420f9c4e221911780c" translate="yes" xml:space="preserve">
          <source>BinaryHeap::push</source>
          <target state="translated">BinaryHeap::push</target>
        </trans-unit>
        <trans-unit id="f989d57cf0e0868e0ab3e99ccd663f3feb35ed09" translate="yes" xml:space="preserve">
          <source>BinaryHeap::reserve</source>
          <target state="translated">BinaryHeap::reserve</target>
        </trans-unit>
        <trans-unit id="2c3a34b08e6d7927826662441c85562fbe689c5c" translate="yes" xml:space="preserve">
          <source>BinaryHeap::reserve_exact</source>
          <target state="translated">BinaryHeap::reserve_exact</target>
        </trans-unit>
        <trans-unit id="7748954939d681e885fda180afed19fde978c11a" translate="yes" xml:space="preserve">
          <source>BinaryHeap::shrink_to</source>
          <target state="translated">BinaryHeap::shrink_to</target>
        </trans-unit>
        <trans-unit id="a6cb12e1cadaa03dc4bd1cee0a924e07fbf651bc" translate="yes" xml:space="preserve">
          <source>BinaryHeap::shrink_to_fit</source>
          <target state="translated">BinaryHeap::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="3173fa304efc6acd170d96dcfc16d265f0d5bb04" translate="yes" xml:space="preserve">
          <source>BinaryHeap::to_owned</source>
          <target state="translated">BinaryHeap::to_owned</target>
        </trans-unit>
        <trans-unit id="545a06b62d55dcf95e6aed766f34093361650315" translate="yes" xml:space="preserve">
          <source>BinaryHeap::try_from</source>
          <target state="translated">BinaryHeap::try_from</target>
        </trans-unit>
        <trans-unit id="9ff50e94eaf55b6f7a7c5638416c4db484934500" translate="yes" xml:space="preserve">
          <source>BinaryHeap::try_into</source>
          <target state="translated">BinaryHeap::try_into</target>
        </trans-unit>
        <trans-unit id="337697412c6fd50a3b2ba815044c47d165af3cd6" translate="yes" xml:space="preserve">
          <source>BinaryHeap::type_id</source>
          <target state="translated">BinaryHeap::type_id</target>
        </trans-unit>
        <trans-unit id="8acc5ae886b9efd0dc8fb7d4fc82df425c356c37" translate="yes" xml:space="preserve">
          <source>BinaryHeap::with_capacity</source>
          <target state="translated">BinaryHeap::with_capacity</target>
        </trans-unit>
        <trans-unit id="c33a043d5763d9b3ea7f89a9ac614fa68ca83bc4" translate="yes" xml:space="preserve">
          <source>Bind a TCP listener to an address, listen for connections, and read bytes in nonblocking mode:</source>
          <target state="translated">비 차단 모드에서 TCP 리스너를 주소에 바인딩하고 연결을 청취하며 바이트를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="359dde3378dea26f13c20bf3ab1abd7d31ba2c01" translate="yes" xml:space="preserve">
          <source>Bind a value to a variable.</source>
          <target state="translated">변수에 값을 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="d22542d4de6d5029b1ac0ccd7c008fc51102ba8b" translate="yes" xml:space="preserve">
          <source>Bind by reference during pattern matching.</source>
          <target state="translated">패턴 일치 중에 참조로 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="069dbd36e80b491e8ea0d0898b003375a28c5f42" translate="yes" xml:space="preserve">
          <source>Binding all paths matching a given prefix, using the asterisk wildcard syntax &lt;code&gt;use a::b::*;&lt;/code&gt;.</source>
          <target state="translated">별표 와일드 카드 구문을 &lt;code&gt;use a::b::*;&lt;/code&gt; 하여 지정된 접두사와 일치하는 모든 경로를 바인딩 하면 a :: b :: *; .</target>
        </trans-unit>
        <trans-unit id="edac8dc0f66a2e81b54912d09ade5eca329f5dcd" translate="yes" xml:space="preserve">
          <source>Binding modes</source>
          <target state="translated">바인딩 모드</target>
        </trans-unit>
        <trans-unit id="30c9ed787b1702852e9d605cfb98fe4532008152" translate="yes" xml:space="preserve">
          <source>Binding with a port number of 0 will request that the OS assigns a port to this listener. The port allocated can be queried via the &lt;a href=&quot;#method.local_addr&quot;&gt;&lt;code&gt;local_addr&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">포트 번호가 0 인 바인딩은 OS가이 리스너에 포트를 할당하도록 요청합니다. 할당 된 포트는 &lt;a href=&quot;#method.local_addr&quot;&gt; &lt;code&gt;local_addr&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 조회 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ace7ad2d8af42b873b8f9c931c9515626c9ccb54" translate="yes" xml:space="preserve">
          <source>Binding with a port number of 0 will request that the OS assigns a port to this listener. The port allocated can be queried via the &lt;a href=&quot;struct.tcplistener#method.local_addr&quot;&gt;&lt;code&gt;TcpListener::local_addr&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">포트 번호 0으로 바인딩하면 OS가이 리스너에 포트를 할당하도록 요청합니다. 할당 된 포트는 &lt;a href=&quot;struct.tcplistener#method.local_addr&quot;&gt; &lt;code&gt;TcpListener::local_addr&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c4806bd148356225d8f9e9c34e40c18cd70837a" translate="yes" xml:space="preserve">
          <source>Binds a reference to the &lt;code&gt;name&lt;/code&gt; field to the variable &lt;code&gt;person_name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 필드에 대한 참조를 변수 &lt;code&gt;person_name&lt;/code&gt; 에 바인딩 합니다.</target>
        </trans-unit>
        <trans-unit id="309af9e25956170a810f78e3c71afc45e9766ccf" translate="yes" xml:space="preserve">
          <source>BitAnd</source>
          <target state="translated">BitAnd</target>
        </trans-unit>
        <trans-unit id="597ad73fbf9aa40cebae5f999cfe7db4afecce4e" translate="yes" xml:space="preserve">
          <source>BitAnd::bitand</source>
          <target state="translated">BitAnd::bitand</target>
        </trans-unit>
        <trans-unit id="943b337ab11ab98e677d691725140875e5b353e9" translate="yes" xml:space="preserve">
          <source>BitAndAssign</source>
          <target state="translated">BitAndAssign</target>
        </trans-unit>
        <trans-unit id="f5e3873189453b3d2f6432bcad61a66bb4d9501b" translate="yes" xml:space="preserve">
          <source>BitAndAssign::bitand_assign</source>
          <target state="translated">BitAndAssign::bitand_assign</target>
        </trans-unit>
        <trans-unit id="f64578ede789cb16c75f551e17bc358c839da2a7" translate="yes" xml:space="preserve">
          <source>BitOr</source>
          <target state="translated">BitOr</target>
        </trans-unit>
        <trans-unit id="44191b5eea700acecf61cce1d97b9be216180188" translate="yes" xml:space="preserve">
          <source>BitOr::bitor</source>
          <target state="translated">BitOr::bitor</target>
        </trans-unit>
        <trans-unit id="960e956c7d9aabe97b11d326569299236d4948a9" translate="yes" xml:space="preserve">
          <source>BitOrAssign</source>
          <target state="translated">BitOrAssign</target>
        </trans-unit>
        <trans-unit id="3034c1fbe2a99f07e023c8c2cb9d42ee22ccc4c1" translate="yes" xml:space="preserve">
          <source>BitOrAssign::bitor_assign</source>
          <target state="translated">BitOrAssign::bitor_assign</target>
        </trans-unit>
        <trans-unit id="427e64f1c1cbca75038d127034792de35e048e3d" translate="yes" xml:space="preserve">
          <source>BitXor</source>
          <target state="translated">BitXor</target>
        </trans-unit>
        <trans-unit id="2e397bf0da401d643f9083e54c584225e131c7ca" translate="yes" xml:space="preserve">
          <source>BitXor::bitxor</source>
          <target state="translated">BitXor::bitxor</target>
        </trans-unit>
        <trans-unit id="6a826e6c5b73b200c07a57a2aec1b711ff40e1d4" translate="yes" xml:space="preserve">
          <source>BitXorAssign</source>
          <target state="translated">BitXorAssign</target>
        </trans-unit>
        <trans-unit id="cbbbcfd713c363f58df6976ea8f22e15d59645d6" translate="yes" xml:space="preserve">
          <source>BitXorAssign::bitxor_assign</source>
          <target state="translated">BitXorAssign::bitxor_assign</target>
        </trans-unit>
        <trans-unit id="77e08df74f0783fd374c97b42304776b3399af7d" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;and&quot; with the current value.</source>
          <target state="translated">현재 값을 가진 비트 단위 &quot;and&quot;.</target>
        </trans-unit>
        <trans-unit id="2c404667875b6822ca47e4a6888c165e459b533c" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;nand&quot; with the current value.</source>
          <target state="translated">현재 값을 가진 비트 단위 &quot;nand&quot;.</target>
        </trans-unit>
        <trans-unit id="1f35aa22f6cd34a5220faabf04cbbb20527ee643" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;or&quot; with the current value.</source>
          <target state="translated">현재 값을 가진 비트 단위 &quot;또는&quot;.</target>
        </trans-unit>
        <trans-unit id="5c076254fac7febb41ccccf46680d5e14a161fa4" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;xor&quot; with the current value.</source>
          <target state="translated">현재 값을 가진 비트 단위 &quot;xor&quot;</target>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="translated">비트 AND</target>
        </trans-unit>
        <trans-unit id="4a9a6c94eeeaf50fe1cbac8c1cdc883b234d3b2b" translate="yes" xml:space="preserve">
          <source>Bitwise AND and assignment</source>
          <target state="translated">비트 AND 및 대입</target>
        </trans-unit>
        <trans-unit id="714d6d47971ffbb15128b6a55a03723a5c596cc3" translate="yes" xml:space="preserve">
          <source>Bitwise And assignment</source>
          <target state="translated">비트와 할당</target>
        </trans-unit>
        <trans-unit id="136c3a93310929e09124297eaf66ab9f3782d009" translate="yes" xml:space="preserve">
          <source>Bitwise NOT</source>
          <target state="translated">비트 단위 NOT</target>
        </trans-unit>
        <trans-unit id="f4be0adcfa81c37e1e7bbf2e23630f30974d164f" translate="yes" xml:space="preserve">
          <source>Bitwise OR</source>
          <target state="translated">비트 OR</target>
        </trans-unit>
        <trans-unit id="ea162d3eb732111137dc7e851592f946afbda822" translate="yes" xml:space="preserve">
          <source>Bitwise OR and assignment</source>
          <target state="translated">비트 단위 OR 및 할당</target>
        </trans-unit>
        <trans-unit id="efa8078cf56f653efb920477181cc2fe85068270" translate="yes" xml:space="preserve">
          <source>Bitwise Or assignment</source>
          <target state="translated">비트 단위 또는 할당</target>
        </trans-unit>
        <trans-unit id="74269e9a4eb117ac43a93ed74bc3c8cd96fd4ff4" translate="yes" xml:space="preserve">
          <source>Bitwise XOR</source>
          <target state="translated">비트 XOR</target>
        </trans-unit>
        <trans-unit id="e3e1709ce290a67ec5f21e03a6b6317c9f304436" translate="yes" xml:space="preserve">
          <source>Bitwise XOR assignment</source>
          <target state="translated">비트 XOR 할당</target>
        </trans-unit>
        <trans-unit id="1f5eabb7a575f79f20f4d75b3fa1ac6c470a8bf6" translate="yes" xml:space="preserve">
          <source>Bitwise and Logical XOR</source>
          <target state="translated">비트 및 논리 XOR</target>
        </trans-unit>
        <trans-unit id="f5a1528826bb49fb0b14c31ab4934d10465ebdc5" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value.</source>
          <target state="translated">비트 단위 및 현재 값으로 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ad214175503cf05c10c463c5f6a4d2dbb82dbf24" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 단위 및 현재 값으로 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_and&lt;/code&gt; 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="52dda2454098469eb02e841cfd17da11a1a8b11c" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 단위 및 현재 값으로 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_and&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_and 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0c63ecd3d802b04a4e0e8dfab8248d912515dec0" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 단위 및 현재 값으로 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_and&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_and 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4b6a21a8674eebce391a665fc4970562e774c483" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 단위 및 현재 값으로 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_and&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_and 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="63f47ad2a1e6e1fb335c5dc45db81e8017584432" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 단위 및 현재 값으로 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_and&lt;/code&gt; 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3ba80ac4bf1c4bbad0f4a7d6ddfd25841835e177" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive OR</source>
          <target state="translated">비트 배타적 OR</target>
        </trans-unit>
        <trans-unit id="87474ce9659a0e1b133611bb2ae41c7ede6c0a5d" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive OR and assignment</source>
          <target state="translated">비트 배타적 OR 및 할당</target>
        </trans-unit>
        <trans-unit id="868d075a0dad8cd3d8fb9f9f26964659d2c6164a" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value.</source>
          <target state="translated">현재 값이있는 비트 단위 nand, 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="544da95df04807eeb86f0e070273fd4dd28cb7cf" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값을 가진 비트 단위 낸드는 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_nand&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_nand 메소드 를 통해 &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d773083e9bfa18a72e7f0b0ab1c138c37ef42288" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값을 가진 비트 단위 낸드는 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_nand&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_nand 메소드 를 통해 &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="203338bb702fd121bec1c0bf9d6a954aecd4347e" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값을 가진 비트 단위 낸드는 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_nand&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_nand 메소드 를 통해 &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6134a1fe2a25d4dbb615e6688200dbe8e85fe9f6" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값을 가진 비트 단위 낸드는 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_nand&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_nand 메소드 를 통해 &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f8ddb011394cb17fb806f98da48b371ebbb0870e" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값을 가진 비트 단위 낸드는 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_nand&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_nand 메소드 를 통해 &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="60a4df2d9448161e88049fa61b8cadfe600ad676" translate="yes" xml:space="preserve">
          <source>Bitwise or logical complement</source>
          <target state="translated">비트 또는 논리 보수</target>
        </trans-unit>
        <trans-unit id="7b4a22d8edc7cc62ea1716050e10c7737c8c1e1f" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value.</source>
          <target state="translated">비트 단위 또는 현재 값으로 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="535640642d3aa1c0482deebda0463eaa8ec0186f" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 단위 또는 현재 값으로 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_or&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_or 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5bd0c7ff8a606308243e5fe0283ace8408191438" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 단위 또는 현재 값으로 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_or&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_or 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1d6bccdc0a09c0e78855aa36b6446bb0697edc37" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 단위 또는 현재 값으로 이전 값을 반환합니다. 이 내장 함수의 안정화 버전은 &lt;code&gt;fetch_or&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_or 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7457b18d65f2f07bafb68e32e88a446590597ffd" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 단위 또는 현재 값으로 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_or&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_or 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6a1e96dd5049ad694cd97688db2eb461734bf5e6" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 단위 또는 현재 값으로 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_or&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_or 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="181decb693bb642be494fbe5c52383467e0c228c" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value.</source>
          <target state="translated">현재 값으로 비트 xor를 수행하여 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aa1d7bc97bda02349e1fee1efbf8d66b5e91fc88" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값을 가진 비트 단위 xor, 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_xor&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_xor 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형에서 사용 가능합니다 . 예를 들어 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3805cb63a3c1121fa142484c3b378fcb265aa95c" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값을 가진 비트 단위 xor, 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_xor&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_xor 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형에서 사용 가능합니다 . 예를 들어 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c5ce9f030ae16f9b2b741aab2abe9cb20f55a4eb" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값을 가진 비트 단위 xor, 이전 값을 반환합니다. 이 내장 함수의 안정화 버전은 &lt;code&gt;fetch_xor&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_xor 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="15836191977a94f34a9eedc80d403307d7b6d4ed" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값을 가진 비트 단위 xor, 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_xor&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_xor 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ffe95ab6a76bb352e681774fae150809af8a6615" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값을 가진 비트 단위 xor, 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_xor&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_xor 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형에서 사용 가능합니다 . 예를 들어 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="88de087af89700f4c1004e0042a100c96cfad709" translate="yes" xml:space="preserve">
          <source>Blanket Implementations</source>
          <target state="translated">담요 구현</target>
        </trans-unit>
        <trans-unit id="7ebf10e8c63d15dc33875a65edf15f33311b088f" translate="yes" xml:space="preserve">
          <source>Blanket implementation</source>
          <target state="translated">블랭킷 구현</target>
        </trans-unit>
        <trans-unit id="b62ea629ea517115ba87dea634c655ff0a340dd4" translate="yes" xml:space="preserve">
          <source>Blanket implementations appear in the documentation for the trait in the &amp;ldquo;Implementors&amp;rdquo; section.</source>
          <target state="translated">담요 구현은 &quot;구현 자&quot;섹션의 특성에 대한 문서에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a06bbda0eab9ea08dbe94577274cbb7b473571d4" translate="yes" xml:space="preserve">
          <source>Block comment</source>
          <target state="translated">댓글 차단</target>
        </trans-unit>
        <trans-unit id="684096ae991ba36b90c5953d624c41ac5080dfdf" translate="yes" xml:space="preserve">
          <source>Block expression</source>
          <target state="translated">블록 표현</target>
        </trans-unit>
        <trans-unit id="8b403969dc1821977a4545f2dd574d603b1654fd" translate="yes" xml:space="preserve">
          <source>Block expressions</source>
          <target state="translated">블록 표현</target>
        </trans-unit>
        <trans-unit id="7805c38c778b7b8d59aebeff2b37473f6e635d86" translate="yes" xml:space="preserve">
          <source>Block expressions as elements of &lt;a href=&quot;array-expr&quot;&gt;array expressions&lt;/a&gt;, &lt;a href=&quot;tuple-expr&quot;&gt;tuple expressions&lt;/a&gt;, &lt;a href=&quot;call-expr&quot;&gt;call expressions&lt;/a&gt;, and tuple-style &lt;a href=&quot;struct-expr&quot;&gt;struct&lt;/a&gt; and &lt;a href=&quot;enum-variant-expr&quot;&gt;enum variant&lt;/a&gt; expressions.</source>
          <target state="translated">&lt;a href=&quot;array-expr&quot;&gt;배열 표현식&lt;/a&gt; , &lt;a href=&quot;tuple-expr&quot;&gt;튜플 표현식&lt;/a&gt; , &lt;a href=&quot;call-expr&quot;&gt;호출 표현식&lt;/a&gt; , 튜플 스타일 &lt;a href=&quot;struct-expr&quot;&gt;구조체&lt;/a&gt; 및 &lt;a href=&quot;enum-variant-expr&quot;&gt;열거 형 변형&lt;/a&gt; 표현식의 요소 인 블록 표현식 입니다.</target>
        </trans-unit>
        <trans-unit id="9e069137567cf4c22756c0a181e015e273f3b097" translate="yes" xml:space="preserve">
          <source>Block expressions as elements of &lt;a href=&quot;array-expr&quot;&gt;array expressions&lt;/a&gt;, &lt;a href=&quot;tuple-expr&quot;&gt;tuple expressions&lt;/a&gt;, &lt;a href=&quot;call-expr&quot;&gt;call expressions&lt;/a&gt;, tuple-style &lt;a href=&quot;struct-expr&quot;&gt;struct&lt;/a&gt; and &lt;a href=&quot;enum-variant-expr&quot;&gt;enum variant&lt;/a&gt; expressions.</source>
          <target state="translated">&lt;a href=&quot;array-expr&quot;&gt;배열 표현식&lt;/a&gt; , &lt;a href=&quot;tuple-expr&quot;&gt;튜플 표현식&lt;/a&gt; , &lt;a href=&quot;call-expr&quot;&gt;호출 표현식&lt;/a&gt; , 튜플 스타일 &lt;a href=&quot;struct-expr&quot;&gt;구조체&lt;/a&gt; 및 &lt;a href=&quot;enum-variant-expr&quot;&gt;열거 형 변형&lt;/a&gt; 표현식의 요소로 표현식을 차단하십시오 .</target>
        </trans-unit>
        <trans-unit id="502282ec9c201c5e6057f4beae39b5897d6f29ed" translate="yes" xml:space="preserve">
          <source>Block expressions used as a &lt;a href=&quot;../statements&quot;&gt;statement&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../statements&quot;&gt;명령문으로&lt;/a&gt; 사용되는 블록 표현식 .</target>
        </trans-unit>
        <trans-unit id="d83a4ba900681b1d6bb448e76ababb6b95a22052" translate="yes" xml:space="preserve">
          <source>Blocks are always &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expressions&lt;/a&gt; and evaluate the last expression in value expression context. This can be used to force moving a value if really needed. For example, the following example fails on the call to &lt;code&gt;consume_self&lt;/code&gt; because the struct was moved out of &lt;code&gt;s&lt;/code&gt; in the block expression.</source>
          <target state="translated">블록은 항상 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;값 표현식&lt;/a&gt; 이며 값 표현식 컨텍스트에서 마지막 표현식을 평가합니다. 실제로 필요한 경우 값을 강제로 이동하는 데 사용할 수 있습니다. 예를 들어 다음 예제 는 블록 표현식에서 구조체가 &lt;code&gt;s&lt;/code&gt; 밖으로 이동 되었기 때문에 &lt;code&gt;consume_self&lt;/code&gt; 호출 할 때 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="c18efbe7496c8880dfb8b33f1bb639d10ba9c80d" translate="yes" xml:space="preserve">
          <source>Blocks are written as &lt;code&gt;{&lt;/code&gt;, then any &lt;a href=&quot;../attributes&quot;&gt;inner attributes&lt;/a&gt;, then &lt;a href=&quot;../statements&quot;&gt;statements&lt;/a&gt;, then an optional expression, and finally a &lt;code&gt;}&lt;/code&gt;. Statements are usually required to be followed a semicolon, with two exceptions. Item declaration statements do not need to be followed by a semicolon. Expression statements usually require a following semicolon except if its outer expression is a flow control expression. Furthermore, extra semicolons between statements are allowed, but these semicolons do not affect semantics.</source>
          <target state="translated">블록은 &lt;code&gt;{&lt;/code&gt; , &lt;a href=&quot;../attributes&quot;&gt;내부 속성&lt;/a&gt; , &lt;a href=&quot;../statements&quot;&gt;명령문&lt;/a&gt; , 선택적 표현식 및 마지막으로 &lt;code&gt;}&lt;/code&gt; 로 작성 됩니다. 명령문은 일반적으로 세미콜론을 따라야하며 두 가지 예외가 있습니다. 항목 선언문 뒤에 세미콜론이 올 필요는 없습니다. 표현식 문은 일반적으로 외부 표현식이 플로우 제어 표현식 인 경우를 제외하고 다음 세미콜론이 필요합니다. 또한 명령문 사이에 추가 세미콜론이 허용되지만 이러한 세미콜론은 의미에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae067769ea09e9988dc3c94bd840ffd9a2112129" translate="yes" xml:space="preserve">
          <source>Blocks are written as &lt;code&gt;{&lt;/code&gt;, then any &lt;a href=&quot;../attributes&quot;&gt;inner attributes&lt;/a&gt;, then &lt;a href=&quot;../statements&quot;&gt;statements&lt;/a&gt;, then an optional expression, and finally a &lt;code&gt;}&lt;/code&gt;. Statements are usually required to be followed by a semicolon, with two exceptions. Item declaration statements do not need to be followed by a semicolon. Expression statements usually require a following semicolon except if its outer expression is a flow control expression. Furthermore, extra semicolons between statements are allowed, but these semicolons do not affect semantics.</source>
          <target state="translated">블록은 &lt;code&gt;{&lt;/code&gt; , &lt;a href=&quot;../attributes&quot;&gt;내부 속성&lt;/a&gt; , &lt;a href=&quot;../statements&quot;&gt;명령문&lt;/a&gt; , 선택적 표현식, 마지막으로 &lt;code&gt;}&lt;/code&gt; 로 작성 됩니다. 일반적으로 명령문 뒤에 세미콜론이 와야하지만 두 가지 예외가 있습니다. 항목 선언문 뒤에 세미콜론이 올 필요가 없습니다. 식 문에는 일반적으로 외부식이 흐름 제어 식인 경우를 제외하고 다음 세미콜론이 필요합니다. 또한 문 사이에 추가 세미콜론이 허용되지만 이러한 세미콜론은 의미 체계에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b3b5253f4cf51bfc8b7e410d8b0b217d0e9c0335" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until all threads have rendezvoused here.</source>
          <target state="translated">모든 스레드가 여기에 연결될 때까지 현재 스레드를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="d45aaa4f52bf36a05dbf87c3a8418aac5e1ca210" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until this condition variable receives a notification and the provided condition is false.</source>
          <target state="translated">이 조건 변수가 알림을 받고 제공된 조건이 거짓이 될 때까지 현재 스레드를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="6fa33f5cb6fe4954947bbb580e0c51b7b87a1d8c" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until this condition variable receives a notification and the required condition is met. Spurious wakeups are ignored and this function will only return once the condition has been met.</source>
          <target state="translated">이 조건 변수가 알림을 받고 필요한 조건이 충족 될 때까지 현재 스레드를 차단합니다. 가짜 웨이크 업은 무시되며이 기능은 조건이 충족 된 후에 만 ​​반환됩니다.</target>
        </trans-unit>
        <trans-unit id="80e976210b81b30997de305efb4640d505e6cf39" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until this condition variable receives a notification.</source>
          <target state="translated">이 조건 변수가 알림을받을 때까지 현재 스레드를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="410a3ef0dd4f7761ff571ad2f23d0ad96832450b" translate="yes" xml:space="preserve">
          <source>Blocks unless or until the current thread's token is made available or the specified duration has been reached (may wake spuriously).</source>
          <target state="translated">현재 스레드의 토큰을 사용할 수 없거나 지정된 지속 시간에 도달하지 않을 때까지 또는 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="7e4f7a13eb5259dea6da862f685681bb73f6e91b" translate="yes" xml:space="preserve">
          <source>Blocks unless or until the current thread's token is made available.</source>
          <target state="translated">현재 스레드의 토큰을 사용할 수 없을 때까지 또는 차단합니다.</target>
        </trans-unit>
        <trans-unit id="e81a87a7fdc340ba3287800ef9018a00b1adc455" translate="yes" xml:space="preserve">
          <source>Blocks: if a block has type &lt;code&gt;U&lt;/code&gt;, then the last expression in the block (if it is not semicolon-terminated) is a coercion site to &lt;code&gt;U&lt;/code&gt;. This includes blocks which are part of control flow statements, such as &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;, if the block has a known type.</source>
          <target state="translated">블록 : 블록에 &lt;code&gt;U&lt;/code&gt; 유형이 있으면 블록 의 마지막 표현식 (세미콜론으로 끝나지 않은 경우)은 &lt;code&gt;U&lt;/code&gt; 에 대한 강제 사이트 입니다. 여기에는 블록 에 알려진 유형이있는 경우 &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 등의 제어 흐름 문의 일부인 블록이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="104329f4432c8b8b5d3c19fc3d250dfe2ab027d2" translate="yes" xml:space="preserve">
          <source>Bodies of unsafe functions are effectively &lt;code&gt;unsafe&lt;/code&gt; blocks, so to perform other unsafe operations within an unsafe function, we don&amp;rsquo;t need to add another &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="translated">안전하지 않은 기능의 기관을 효과적으로 있습니다 &lt;code&gt;unsafe&lt;/code&gt; 그렇게 안전하지 않은 함수 내에서 다른 안전하지 않은 작업을 수행하기 위해, 블록, 우리는 또 다른 추가 할 필요가 없습니다 &lt;code&gt;unsafe&lt;/code&gt; 블록을.</target>
        </trans-unit>
        <trans-unit id="c9a26dc7a812c76d486afec462ae9a205a68b3e6" translate="yes" xml:space="preserve">
          <source>Boolean literals</source>
          <target state="translated">부울 리터럴</target>
        </trans-unit>
        <trans-unit id="49f29c844f200eead7503c6d10737135d242ba2b" translate="yes" xml:space="preserve">
          <source>Boolean type</source>
          <target state="translated">부울 타입</target>
        </trans-unit>
        <trans-unit id="cb4702d3f3cd69e09a0563d0dcdc4d54d0023693" translate="yes" xml:space="preserve">
          <source>Borrow</source>
          <target state="translated">Borrow</target>
        </trans-unit>
        <trans-unit id="1fd0a944ea8cfb257b2b56f1afcd67ff9e3b25e2" translate="yes" xml:space="preserve">
          <source>Borrow operators</source>
          <target state="translated">차용자</target>
        </trans-unit>
        <trans-unit id="08ef91a49ea57c4babbbcf16cff803659fb46ac3" translate="yes" xml:space="preserve">
          <source>Borrow::borrow</source>
          <target state="translated">Borrow::borrow</target>
        </trans-unit>
        <trans-unit id="2928c5f6ce470ed45869ce9bc666a02f1b276c3c" translate="yes" xml:space="preserve">
          <source>BorrowError</source>
          <target state="translated">BorrowError</target>
        </trans-unit>
        <trans-unit id="cd83210bbc26f6a86f78acc2c5aab6cb300d7a3f" translate="yes" xml:space="preserve">
          <source>BorrowError::borrow</source>
          <target state="translated">BorrowError::borrow</target>
        </trans-unit>
        <trans-unit id="522f3d26a1b9c184b1451ca62d5ed845e00d0b54" translate="yes" xml:space="preserve">
          <source>BorrowError::borrow_mut</source>
          <target state="translated">BorrowError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="7a951e76d02cd0d1326baee884b3df884ef7505b" translate="yes" xml:space="preserve">
          <source>BorrowError::cause</source>
          <target state="translated">BorrowError::cause</target>
        </trans-unit>
        <trans-unit id="9346d595a8c0688d171353745aeb9cb098c34080" translate="yes" xml:space="preserve">
          <source>BorrowError::description</source>
          <target state="translated">BorrowError::description</target>
        </trans-unit>
        <trans-unit id="89396ee3db16dbcc29597b262afc46558ed2366f" translate="yes" xml:space="preserve">
          <source>BorrowError::fmt</source>
          <target state="translated">BorrowError::fmt</target>
        </trans-unit>
        <trans-unit id="f021a214bcd178a0ea344c71db12231f4f31c50f" translate="yes" xml:space="preserve">
          <source>BorrowError::from</source>
          <target state="translated">BorrowError::from</target>
        </trans-unit>
        <trans-unit id="886751874954c88f3e019db825f51742642c3fcc" translate="yes" xml:space="preserve">
          <source>BorrowError::into</source>
          <target state="translated">BorrowError::into</target>
        </trans-unit>
        <trans-unit id="26e12b28f77d9243f30385a8268af2b47555aa7c" translate="yes" xml:space="preserve">
          <source>BorrowError::source</source>
          <target state="translated">BorrowError::source</target>
        </trans-unit>
        <trans-unit id="13b09f10b5e2154e8e5ae8b9b7bc53371a685504" translate="yes" xml:space="preserve">
          <source>BorrowError::to_string</source>
          <target state="translated">BorrowError::to_string</target>
        </trans-unit>
        <trans-unit id="2ce8439dd5781fe13a435aac312be62b63c7c5be" translate="yes" xml:space="preserve">
          <source>BorrowError::try_from</source>
          <target state="translated">BorrowError::try_from</target>
        </trans-unit>
        <trans-unit id="433ecad73e66b8dc9a31fe37870bbe334a572245" translate="yes" xml:space="preserve">
          <source>BorrowError::try_into</source>
          <target state="translated">BorrowError::try_into</target>
        </trans-unit>
        <trans-unit id="65acd86f1a255edf5a9bf5a76b81126963ed5e13" translate="yes" xml:space="preserve">
          <source>BorrowError::type_id</source>
          <target state="translated">BorrowError::type_id</target>
        </trans-unit>
        <trans-unit id="7ecce6e07f46ad690e4097354d0bc6aaa0f99008" translate="yes" xml:space="preserve">
          <source>BorrowMut</source>
          <target state="translated">BorrowMut</target>
        </trans-unit>
        <trans-unit id="d9285d895ed643451254273bc8c4bbd62b0abca2" translate="yes" xml:space="preserve">
          <source>BorrowMut::borrow_mut</source>
          <target state="translated">BorrowMut::borrow_mut</target>
        </trans-unit>
        <trans-unit id="05ef9e71b85c91963a382e2cbdd7ebb51b1ef2c3" translate="yes" xml:space="preserve">
          <source>BorrowMutError</source>
          <target state="translated">BorrowMutError</target>
        </trans-unit>
        <trans-unit id="6c84f92cc03620eeb60a2a75a6198806e41c99cf" translate="yes" xml:space="preserve">
          <source>BorrowMutError::borrow</source>
          <target state="translated">BorrowMutError::borrow</target>
        </trans-unit>
        <trans-unit id="c9194e522b34f7f0397b113f83851e0a0750ebff" translate="yes" xml:space="preserve">
          <source>BorrowMutError::borrow_mut</source>
          <target state="translated">BorrowMutError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="320189f255d75bf0531f1d4da80752757ad88765" translate="yes" xml:space="preserve">
          <source>BorrowMutError::cause</source>
          <target state="translated">BorrowMutError::cause</target>
        </trans-unit>
        <trans-unit id="5d91335b7a43a382a81f901fb2092637fc2b1b30" translate="yes" xml:space="preserve">
          <source>BorrowMutError::description</source>
          <target state="translated">BorrowMutError::description</target>
        </trans-unit>
        <trans-unit id="de7386f3e6ce0f0541da576e92b462815d327aa2" translate="yes" xml:space="preserve">
          <source>BorrowMutError::fmt</source>
          <target state="translated">BorrowMutError::fmt</target>
        </trans-unit>
        <trans-unit id="0eaaabb7614aee38df98b183695570760d2a3bd8" translate="yes" xml:space="preserve">
          <source>BorrowMutError::from</source>
          <target state="translated">BorrowMutError::from</target>
        </trans-unit>
        <trans-unit id="f361017eeaa59fd5af6e66dc8387dd7623505766" translate="yes" xml:space="preserve">
          <source>BorrowMutError::into</source>
          <target state="translated">BorrowMutError::into</target>
        </trans-unit>
        <trans-unit id="4c422d071ef6d2a11942aa38c90bd2712b395f0a" translate="yes" xml:space="preserve">
          <source>BorrowMutError::source</source>
          <target state="translated">BorrowMutError::source</target>
        </trans-unit>
        <trans-unit id="2eb0e23a66aa4d528bf24f44d0b10d6fbb428403" translate="yes" xml:space="preserve">
          <source>BorrowMutError::to_string</source>
          <target state="translated">BorrowMutError::to_string</target>
        </trans-unit>
        <trans-unit id="b02bd0326962794fede5f5e186f12a2fd926a13b" translate="yes" xml:space="preserve">
          <source>BorrowMutError::try_from</source>
          <target state="translated">BorrowMutError::try_from</target>
        </trans-unit>
        <trans-unit id="6719140c2e78bc9c851d093ca84a7d95a4fe42cf" translate="yes" xml:space="preserve">
          <source>BorrowMutError::try_into</source>
          <target state="translated">BorrowMutError::try_into</target>
        </trans-unit>
        <trans-unit id="aed34dec1357c0aa84876bb9c79b00511d803df2" translate="yes" xml:space="preserve">
          <source>BorrowMutError::type_id</source>
          <target state="translated">BorrowMutError::type_id</target>
        </trans-unit>
        <trans-unit id="5868e9faf108a7771c407ab907889934dd63b50a" translate="yes" xml:space="preserve">
          <source>Borrowed data.</source>
          <target state="translated">차용 한 데이터.</target>
        </trans-unit>
        <trans-unit id="c7098078c609573d3fe94c28cfeb29c10812c3db" translate="yes" xml:space="preserve">
          <source>Borrowed pointer type</source>
          <target state="translated">차용 된 포인터 유형</target>
        </trans-unit>
        <trans-unit id="74d965d163933b4d9c245330d676a9a3a774550a" translate="yes" xml:space="preserve">
          <source>Borrowed reference to an OS string (see &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">OS 문자열에 대한 참조를 차용했습니다 ( &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="885dff407470f8d8cfa69af65835344b4ec2492e" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it.</source>
          <target state="translated">반복자를 소비하지 않고 차용합니다.</target>
        </trans-unit>
        <trans-unit id="e4b68387bd9a788e153fefb151f2e36c5cc3e492" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;../../../iter/trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자를 소비하지 않고 차용합니다. &lt;a href=&quot;../../../iter/trait.iterator#method.by_ref&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c2a592fe9d3573696dcb4e01f0c58c8f29d9729" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;../../iter/trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자를 소비하지 않고 차용합니다. &lt;a href=&quot;../../iter/trait.iterator#method.by_ref&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc9f6098309a428e4660e57ac0d7a128a57eb4f3" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;../iter/trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자를 소비하지 않고 차용합니다. &lt;a href=&quot;../iter/trait.iterator#method.by_ref&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4d7aa1610c7d0263c276944863186c7f5b54aca" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;iter/trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자를 소비하지 않고 차용합니다. &lt;a href=&quot;iter/trait.iterator#method.by_ref&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0448c3473f95cd23244ee44dd3147a10fd3dd487" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자를 소비하지 않고 차용합니다. &lt;a href=&quot;trait.iterator#method.by_ref&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f99b7e6b9280152eedd396f475e3d3c1511ee27c" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&lt;code&gt;dyn Trait&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt; in return types have a an implicit &lt;code&gt;'static&lt;/code&gt; requirement, meaning that the value implementing them that is being returned has to be either a &lt;code&gt;'static&lt;/code&gt; borrow or an owned value.</source>
          <target state="translated">반환 유형의 &lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt; &lt;code&gt;dyn Trait&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt; &lt;code&gt;impl Trait&lt;/code&gt; &lt;/a&gt; 에는 모두 암시 적 &lt;code&gt;'static&lt;/code&gt; 요구 사항 '이 있습니다. 즉, 반환되는 항목을 구현하는 값은 &lt;code&gt;'static&lt;/code&gt; 이어야합니다. 차용 또는 소유 된 값 .</target>
        </trans-unit>
        <trans-unit id="5f521714f9167c57599a72f6be51da170e80a3dd" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;items/constant-items&quot;&gt;constant&lt;/a&gt; and &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt; declarations of reference types have &lt;em&gt;implicit&lt;/em&gt;&lt;code&gt;'static&lt;/code&gt; lifetimes unless an explicit lifetime is specified. As such, the constant declarations involving &lt;code&gt;'static&lt;/code&gt; above may be written without the lifetimes.</source>
          <target state="translated">명시 적 수명을 지정하지 않으면 참조 유형의 &lt;a href=&quot;items/constant-items&quot;&gt;상수&lt;/a&gt; 및 &lt;a href=&quot;items/static-items&quot;&gt;정적&lt;/a&gt; 선언 모두 &lt;em&gt;암시 적 &lt;/em&gt; &lt;code&gt;'static&lt;/code&gt; 수명 '을 갖습니다 . 따라서 &lt;code&gt;'static&lt;/code&gt; static' 과 관련된 상수 선언 은 수명없이 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05a5142bb4165da20e62a15a12a49d69f51e7d7c" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;es and &lt;a href=&quot;struct.rwlock&quot;&gt;&lt;code&gt;RwLock&lt;/code&gt;&lt;/a&gt;s are poisoned whenever a thread fails while the lock is held. The precise semantics for when a lock is poisoned is documented on each lock, but once a lock is poisoned then all future acquisitions will return this error.</source>
          <target state="translated">두 &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; ES 및 &lt;a href=&quot;struct.rwlock&quot;&gt; &lt;code&gt;RwLock&lt;/code&gt; &lt;/a&gt; 잠금이 유지되는 동안 스레드가 실패 할 때마다의 중독된다. 잠금이 피독 될 때의 정확한 의미는 각 잠금에 문서화되어 있지만 일단 잠금이 피독되면 이후의 모든 획득은이 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="92f3e1242e71f216f2553ecade5c0b56c112c46f" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt; must be properly aligned.</source>
          <target state="translated">두 &lt;code&gt;src&lt;/code&gt; 와 &lt;code&gt;dst&lt;/code&gt; 제대로 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c1a304706d4634a69f512f48a553ca6de0a57224" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for both reads and writes of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes.</source>
          <target state="translated">두 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 있어야 &lt;a href=&quot;index#safety&quot;&gt;유효한&lt;/a&gt; 양의 읽기 및 기록을위한 &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 바이트.</target>
        </trans-unit>
        <trans-unit id="62b58df899df91147ad1851a44f1534537b8baae" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for both reads and writes.</source>
          <target state="translated">둘 다 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 해야 &lt;a href=&quot;index#safety&quot;&gt;유효한&lt;/a&gt; 모두 읽기 및 쓰기 위해.</target>
        </trans-unit>
        <trans-unit id="2af274f82063aea319dd50db89daaff81dd41c5b" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes.</source>
          <target state="translated">두 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 있어야 &lt;a href=&quot;index#safety&quot;&gt;유효&lt;/a&gt; 판독 및 쓰기에 대해 &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 바이트.</target>
        </trans-unit>
        <trans-unit id="f6aa81faf4ff06762f89afa21d147f447e5913ea" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 는 모두 읽기와 쓰기에 &lt;a href=&quot;index#safety&quot;&gt;유효&lt;/a&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ab994fd6a56d4038a2b10fa7688bd17375033138" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be properly aligned.</source>
          <target state="translated">둘 다 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 제대로 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c79da800bdef51dcfa75d10a65ea136a827d95b9" translate="yes" xml:space="preserve">
          <source>Both absolute and relative paths are followed by one or more identifiers separated by double colons (&lt;code&gt;::&lt;/code&gt;).</source>
          <target state="translated">절대 경로와 상대 경로 뒤에는 이중 콜론 ( &lt;code&gt;::&lt;/code&gt; :)으로 구분 된 하나 이상의 식별자가옵니다 .</target>
        </trans-unit>
        <trans-unit id="c285e2e79ff8d2abdbcbfce35a32a0f639fd60af" translate="yes" xml:space="preserve">
          <source>Both are equivalent to:</source>
          <target state="translated">둘 다 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d969a72eda5767cc021898e028fbe0fc071270ae" translate="yes" xml:space="preserve">
          <source>Both attributes can be used on &lt;a href=&quot;../items/functions&quot;&gt;functions&lt;/a&gt;. When applied to a function in a &lt;a href=&quot;../items/traits&quot;&gt;trait&lt;/a&gt;, they apply only to that function when used as a default function for a trait implementation and not to all trait implementations. The attributes have no effect on a trait function without a body.</source>
          <target state="translated">두 속성 모두 &lt;a href=&quot;../items/functions&quot;&gt;함수에서&lt;/a&gt; 사용할 수 있습니다 . &lt;a href=&quot;../items/traits&quot;&gt;특성&lt;/a&gt; 의 함수에 적용되는 경우 특성 특성 의 기본 함수로 사용되는 경우 해당 특성 에만 적용되며 모든 특성 구현에는 적용되지 않습니다. 특성은 본문이없는 특성 함수에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="969434c27ab08daa9144a7ddff09f258b6b015fd" translate="yes" xml:space="preserve">
          <source>Both match arms must produce values of type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;, but since &lt;code&gt;break&lt;/code&gt; never produces a value at all we know it can never produce a value which isn't a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;. This illustrates another behaviour of the &lt;code&gt;!&lt;/code&gt; type - expressions with type &lt;code&gt;!&lt;/code&gt; will coerce into any other type.</source>
          <target state="translated">두 매치 암 모두 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 유형의 값을 생성해야 하지만 &lt;code&gt;break&lt;/code&gt; 는 절대 값을 생성하지 않으므로 &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 가 아닌 값을 생성 할 수 없다는 것을 알고 있습니다 . 이것은 &lt;code&gt;!&lt;/code&gt; type-type &lt;code&gt;!&lt;/code&gt; 다른 유형으로 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="f415dc3d7d35015fcd0e7c895d9cc2c978758324" translate="yes" xml:space="preserve">
          <source>Both match arms must produce values of type &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;, but since &lt;code&gt;break&lt;/code&gt; never produces a value at all we know it can never produce a value which isn't a &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;. This illustrates another behaviour of the &lt;code&gt;!&lt;/code&gt; type - expressions with type &lt;code&gt;!&lt;/code&gt; will coerce into any other type.</source>
          <target state="translated">두 개의 일치 암은 &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 유형의 값을 생성해야 하지만 &lt;code&gt;break&lt;/code&gt; 는 결코 값을 생성하지 않으므로 &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 가 아닌 값을 생성 할 수 없다는 것을 알고 있습니다 . 이것은 &lt;code&gt;!&lt;/code&gt; 타입 &lt;code&gt;!&lt;/code&gt; 다른 유형으로 강제합니다.</target>
        </trans-unit>
        <trans-unit id="cc4e0abfff334b57590e92cdeed48cb0b5815f3f" translate="yes" xml:space="preserve">
          <source>Both of the following must be true:</source>
          <target state="translated">다음 두 가지가 모두 참이어야합니다.</target>
        </trans-unit>
        <trans-unit id="8047c2fba1b8345d0b2a7bfe41d16519cea0cd82" translate="yes" xml:space="preserve">
          <source>Both pointers must be &lt;em&gt;derived from&lt;/em&gt; a pointer to the same object. (See below for an example.)</source>
          <target state="translated">두 포인터는 동일한 개체에 대한 포인터 &lt;em&gt;에서 파생&lt;/em&gt; 되어야 합니다. (예는 아래를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="2bf778379c09be3c08a3e90c46c05409146c7bf5" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;Post&lt;/code&gt; and &lt;code&gt;DraftPost&lt;/code&gt; structs have a private &lt;code&gt;content&lt;/code&gt; field that stores the blog post text. The structs no longer have the &lt;code&gt;state&lt;/code&gt; field because we&amp;rsquo;re moving the encoding of the state to the types of the structs. The &lt;code&gt;Post&lt;/code&gt; struct will represent a published post, and it has a &lt;code&gt;content&lt;/code&gt; method that returns the &lt;code&gt;content&lt;/code&gt;.</source>
          <target state="translated">모두 &lt;code&gt;Post&lt;/code&gt; 와 &lt;code&gt;DraftPost&lt;/code&gt; 구조체는 개인이 &lt;code&gt;content&lt;/code&gt; 필드가 저장 블로그 게시물의 텍스트를. &lt;code&gt;state&lt;/code&gt; 인코딩을 구조체 유형으로 옮기기 때문에 구조체에 더 이상 상태 필드 가 없습니다 . &lt;code&gt;Post&lt;/code&gt; 구조체는 게시 된 게시물을 나타냅니다, 그리고 그것은이 &lt;code&gt;content&lt;/code&gt; 방법을 반환하는 &lt;code&gt;content&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
