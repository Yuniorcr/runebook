<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="ca9d7e79f3cd051af83e1b93c6feb0514cb1adc8" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to remove the extraneous associated constant:</source>
          <target state="translated">이 문제에 대한 해결책은 관련없는 상수를 제거하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b66ecfc5844845f6ce826665530fcbac23beb458" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to remove the extraneous associated type:</source>
          <target state="translated">이 문제에 대한 해결책은 관련없는 유형을 제거하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f5e669f80a825dd22d2d4e3f89464bdf72e0692e" translate="yes" xml:space="preserve">
          <source>The solution to this problem is usually to switch to using a &lt;code&gt;move&lt;/code&gt; closure. This approach moves (or copies, where possible) data into the closure, rather than taking references to it. For example:</source>
          <target state="translated">이 문제에 대한 해결책은 일반적으로 &lt;code&gt;move&lt;/code&gt; 을 사용하도록 전환하는 것입니다 클로저 입니다. 이 방법은 데이터를 참조하지 않고 클로저로 데이터를 이동 (또는 가능한 경우 복사)합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4bc18e7ccda6a6b48c7507cdd496e8030bd28ca8" translate="yes" xml:space="preserve">
          <source>The source files from which this book is generated can be found on &lt;a href=&quot;https://github.com/rust-lang/book/tree/master/src&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">이 책이 생성 된 소스 파일은 &lt;a href=&quot;https://github.com/rust-lang/book/tree/master/src&quot;&gt;GitHub&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a49d6b47901cd19039274da891afacb7623398fb" translate="yes" xml:space="preserve">
          <source>The spawned thread may outlive the caller (unless the caller thread is the main thread; the whole process is terminated when the main thread finishes). The join handle can be used to block on termination of the child thread, including recovering its panics.</source>
          <target state="translated">생성 된 스레드는 호출자보다 오래 지속될 수 있습니다 (호출자 스레드가 기본 스레드가 아닌 경우 전체 프로세스는 기본 스레드가 완료되면 종료됩니다). 결합 핸들을 사용하여 패닉 복구를 포함하여 하위 스레드 종료시 차단할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3de206631f62d211730a1cc35e89663e7062bcfa" translate="yes" xml:space="preserve">
          <source>The specified environment variable was found, but it did not contain valid unicode data. The found data is returned as a payload of this variant.</source>
          <target state="translated">지정된 환경 변수를 찾았지만 유효한 유니 코드 데이터가 없습니다. 찾은 데이터는이 변형의 페이로드로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ea36c8e1fa9f0022c16977222444b4a3c0ab84f9" translate="yes" xml:space="preserve">
          <source>The specified environment variable was not present in the current process's environment.</source>
          <target state="translated">지정된 환경 변수가 현재 프로세스 환경에 없습니다.</target>
        </trans-unit>
        <trans-unit id="45eb3e7f185d35fea76d0fcc8feefcf81bfa67b6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../any/fn.type_name&quot;&gt;&lt;code&gt;crate::any::type_name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../any/fn.type_name&quot;&gt; &lt;code&gt;crate::any::type_name&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dd9900dab1e575f89f6a70cab38ccde57d12f174" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../any/struct.typeid#method.of&quot;&gt;&lt;code&gt;crate::any::TypeId::of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../any/struct.typeid#method.of&quot;&gt; &lt;code&gt;crate::any::TypeId::of&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="176610383e559ab75c30b3e60918dcf39baa4491" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;crate::hint::unreachable_unchecked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt; &lt;code&gt;crate::hint::unreachable_unchecked&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="769e7a49a82fbc73600ab216f157a9a4edfed6d2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;std::hint::unreachable_unchecked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt; &lt;code&gt;std::hint::unreachable_unchecked&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5f707ad710f27d4a519df162d93207b489b43663" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.align_of&quot;&gt;&lt;code&gt;crate::mem::align_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../mem/fn.align_of&quot;&gt; &lt;code&gt;crate::mem::align_of&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0bb92f5b8279175442866093e128f5cb80c5d7d4" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.align_of_val&quot;&gt;&lt;code&gt;crate::mem::align_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../mem/fn.align_of_val&quot;&gt; &lt;code&gt;crate::mem::align_of_val&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d0a9a6b3a12732480c74ccdbdd6c6cd441416852" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.discriminant&quot;&gt;&lt;code&gt;crate::mem::discriminant&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../mem/fn.discriminant&quot;&gt; &lt;code&gt;crate::mem::discriminant&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="626a03e32989e459202fcca2e29d114287d2e779" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.needs_drop&quot;&gt;&lt;code&gt;std::mem::needs_drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../mem/fn.needs_drop&quot;&gt; &lt;code&gt;std::mem::needs_drop&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1b581000bfc2472e309baf4b78516cb35a337926" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.size_of&quot;&gt;&lt;code&gt;std::mem::size_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../mem/fn.size_of&quot;&gt; &lt;code&gt;std::mem::size_of&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5867b1e1c4944c1f7ed32488f5be2fa294b4986f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.size_of_val&quot;&gt;&lt;code&gt;std::mem::size_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../mem/fn.size_of_val&quot;&gt; &lt;code&gt;std::mem::size_of_val&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1746aa772dc9c98fd4e848556bc017af5d5a5814" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.abs&quot;&gt;&lt;code&gt;std::f32::abs&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.abs&quot;&gt; &lt;code&gt;std::f32::abs&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd019f674bd918f6d03e4b0946395283db961b78" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.ceil&quot;&gt;&lt;code&gt;std::f32::ceil&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.ceil&quot;&gt; &lt;code&gt;std::f32::ceil&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="26bbd19c72d02740271e9c35e7a28be8dc08d048" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.copysign&quot;&gt;&lt;code&gt;std::f32::copysign&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.copysign&quot;&gt; &lt;code&gt;std::f32::copysign&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="61c494ecc8ddd36d321a87c24568cbae459fddb9" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.cos&quot;&gt;&lt;code&gt;std::f32::cos&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.cos&quot;&gt; &lt;code&gt;std::f32::cos&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94b0a8ab3fca707be3b5a4c013197b6ace7d6752" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.exp&quot;&gt;&lt;code&gt;std::f32::exp&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.exp&quot;&gt; &lt;code&gt;std::f32::exp&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="336a8852727ebc5c24637be3db7e37b682324956" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.exp2&quot;&gt;&lt;code&gt;std::f32::exp2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.exp2&quot;&gt; &lt;code&gt;std::f32::exp2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="46e4b0f6edf39422d28e3db71bd5ccc4aa08c8f3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.floor&quot;&gt;&lt;code&gt;std::f32::floor&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.floor&quot;&gt; &lt;code&gt;std::f32::floor&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c54f6e18bc6b7c8320c4a68ccd5c641025d11b6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.ln&quot;&gt;&lt;code&gt;std::f32::ln&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.ln&quot;&gt; &lt;code&gt;std::f32::ln&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d8fbd8555b23fb5da5a31c3691aceae539093012" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.log10&quot;&gt;&lt;code&gt;std::f32::log10&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.log10&quot;&gt; &lt;code&gt;std::f32::log10&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="163981a463a3f186e653d8b1d906aacc60bb507a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.log2&quot;&gt;&lt;code&gt;std::f32::log2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.log2&quot;&gt; &lt;code&gt;std::f32::log2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aad71542a1a997b3c3c61f5ecfa210cbb95931d8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.max&quot;&gt;&lt;code&gt;f32::max&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.max&quot;&gt; &lt;code&gt;f32::max&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="275c6f9b837c44f59265b27a725f706ea01e4d88" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.min&quot;&gt;&lt;code&gt;f32::min&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.min&quot;&gt; &lt;code&gt;f32::min&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="37a1adc351bf8541ff50457503f42947d2223aa1" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.mul_add&quot;&gt;&lt;code&gt;std::f32::mul_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.mul_add&quot;&gt; &lt;code&gt;std::f32::mul_add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="824767dc22e0a666300f3bbc86838e9e982d5929" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.powf&quot;&gt;&lt;code&gt;std::f32::powf&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.powf&quot;&gt; &lt;code&gt;std::f32::powf&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a9c8c235c9463f3bd3c7f8d97084f0aa09a4e6b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.powi&quot;&gt;&lt;code&gt;std::f32::powi&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.powi&quot;&gt; &lt;code&gt;std::f32::powi&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f7c21362121499d029cb16e6e1a0c1b3f1e8a1a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.round&quot;&gt;&lt;code&gt;std::f32::round&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.round&quot;&gt; &lt;code&gt;std::f32::round&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4af107006e6e31e8e831e5d5f7bf515b2e1cc7d" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.sin&quot;&gt;&lt;code&gt;std::f32::sin&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.sin&quot;&gt; &lt;code&gt;std::f32::sin&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34b79ebb4c8dc7ee3e2e853d2ae83194460b52cd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.sqrt&quot;&gt;&lt;code&gt;std::f32::sqrt&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.sqrt&quot;&gt; &lt;code&gt;std::f32::sqrt&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c2f3efeb8ac74af1f762963525599c78dfb84b4" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.trunc&quot;&gt;&lt;code&gt;std::f32::trunc&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f32#method.trunc&quot;&gt; &lt;code&gt;std::f32::trunc&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f50e2d709a0ab57a5af9a3d0b85809c7253cdbbe" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.abs&quot;&gt;&lt;code&gt;std::f64::abs&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.abs&quot;&gt; &lt;code&gt;std::f64::abs&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b8077c0447a55f70ad3a41280e7cdad8b5a596e3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.ceil&quot;&gt;&lt;code&gt;std::f64::ceil&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.ceil&quot;&gt; &lt;code&gt;std::f64::ceil&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0c784852d478dc5b87ed608a83b4485e61ffaa08" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.copysign&quot;&gt;&lt;code&gt;std::f64::copysign&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.copysign&quot;&gt; &lt;code&gt;std::f64::copysign&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3706879950fc2f859ec3405d83c39468b3d127b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.cos&quot;&gt;&lt;code&gt;std::f64::cos&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.cos&quot;&gt; &lt;code&gt;std::f64::cos&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3fe60787bdb5a14582899986ea8a8eb5151f047a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.exp&quot;&gt;&lt;code&gt;std::f64::exp&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.exp&quot;&gt; &lt;code&gt;std::f64::exp&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d57c3217aae4fa0b39647c7df0a1a27ba3ce04c" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.exp2&quot;&gt;&lt;code&gt;std::f64::exp2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.exp2&quot;&gt; &lt;code&gt;std::f64::exp2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06ec2f6c9475943bd6d7a554d14049a4e570f218" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.floor&quot;&gt;&lt;code&gt;std::f64::floor&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.floor&quot;&gt; &lt;code&gt;std::f64::floor&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95c322d0525dc747c93c991f848c51c52ac90096" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.ln&quot;&gt;&lt;code&gt;std::f64::ln&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.ln&quot;&gt; &lt;code&gt;std::f64::ln&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="85342dac467b551f64948da385b26bae5ec304e2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.log10&quot;&gt;&lt;code&gt;std::f64::log10&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.log10&quot;&gt; &lt;code&gt;std::f64::log10&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1fcf5615e4f3f284291f587c194c0ee80f02e1b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.log2&quot;&gt;&lt;code&gt;std::f64::log2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.log2&quot;&gt; &lt;code&gt;std::f64::log2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a33d40ec03fc6fd7670da5d91bb3dff1514508d8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.max&quot;&gt;&lt;code&gt;f64::max&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.max&quot;&gt; &lt;code&gt;f64::max&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c5caceb4a4959b387b99fbf4eb4112cfa719de9" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.min&quot;&gt;&lt;code&gt;f64::min&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.min&quot;&gt; &lt;code&gt;f64::min&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="184af9c54cafa84b2f1da9d8430a1cc45e2501b8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.mul_add&quot;&gt;&lt;code&gt;std::f64::mul_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.mul_add&quot;&gt; &lt;code&gt;std::f64::mul_add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f8a62ab1447e5a688dfc2804caf90414ec922c3e" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.powf&quot;&gt;&lt;code&gt;std::f64::powf&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.powf&quot;&gt; &lt;code&gt;std::f64::powf&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53fa85dcefba2eba944e099df5e0b7568320b594" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.powi&quot;&gt;&lt;code&gt;std::f64::powi&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.powi&quot;&gt; &lt;code&gt;std::f64::powi&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab11dcc6899cdf3c196ec2500a4f98d80cd92c0f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.round&quot;&gt;&lt;code&gt;std::f64::round&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.round&quot;&gt; &lt;code&gt;std::f64::round&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cbc17db1c9e9aeccadbae543736abc641bf19581" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.sin&quot;&gt;&lt;code&gt;std::f64::sin&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.sin&quot;&gt; &lt;code&gt;std::f64::sin&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9259a474b9633d2c178bcfa8945b9cf932f9b62" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.sqrt&quot;&gt;&lt;code&gt;std::f64::sqrt&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.sqrt&quot;&gt; &lt;code&gt;std::f64::sqrt&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09d46fbb4d6dd94cb20b274b64fb45bedd897ee1" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.trunc&quot;&gt;&lt;code&gt;std::f64::trunc&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.f64#method.trunc&quot;&gt; &lt;code&gt;std::f64::trunc&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e24ba042f8ed9a32e5152ef40108b6331e9ff075" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;std::pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;std::pointer::offset&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a8ef8497ee38f892bb72694c3c391e01cf452f3c" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.pointer#method.wrapping_offset&quot;&gt;&lt;code&gt;std::pointer::wrapping_offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../primitive.pointer#method.wrapping_offset&quot;&gt; &lt;code&gt;std::pointer::wrapping_offset&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="93a878abfa4b4b05965b5ed62c9134a4b23816af" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../process/fn.abort&quot;&gt;&lt;code&gt;std::process::abort&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../process/fn.abort&quot;&gt; &lt;code&gt;std::process::abort&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc0344746e9b397b268af814908260e075e04e91" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.read_volatile&quot;&gt;&lt;code&gt;crate::ptr::read_volatile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../ptr/fn.read_volatile&quot;&gt; &lt;code&gt;crate::ptr::read_volatile&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="118ab008d64be2589235ff02dc721d1434d90f79" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;crate::ptr::write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;crate::ptr::write&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="70902b9a0728e1e3dbaf882574f3b031e91654e0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.write_volatile&quot;&gt;&lt;code&gt;crate::ptr::write_volatile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../ptr/fn.write_volatile&quot;&gt; &lt;code&gt;crate::ptr::write_volatile&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="625b254ad12639bd7cf3b4b8d18b0e6a86ce6669" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;fn.needs_drop&quot;&gt;&lt;code&gt;needs_drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;fn.needs_drop&quot;&gt; &lt;code&gt;needs_drop&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4decf20d903cd057fdbbe638ed8d8e3f26c756a4" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;fn.size_of&quot;&gt;&lt;code&gt;size_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;fn.size_of&quot;&gt; &lt;code&gt;size_of&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e4c9dc52f1e3d1631dde7d53032bcc39a6df9f72" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;fn.size_of_val&quot;&gt;&lt;code&gt;size_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;fn.size_of_val&quot;&gt; &lt;code&gt;size_of_val&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="58429d40c9c7f24b0a6d088073711682d0c11242" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt;&lt;code&gt;atomic::compiler_fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt; &lt;code&gt;atomic::compiler_fence&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5311916c06b10b8c928d0abda98be268ace4e6d6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt;&lt;code&gt;atomic::compiler_fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt; &lt;code&gt;atomic::compiler_fence&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3081645830dba10410e4d31cc6a792e5fa76abfc" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt;&lt;code&gt;atomic::compiler_fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt; &lt;code&gt;atomic::compiler_fence&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e8d39a214853d9287e37063d7cab0006a733cdd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt;&lt;code&gt;atomic::compiler_fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt; &lt;code&gt;atomic::compiler_fence&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2cb2b502c2611a7e2eb731a194ab104f5f862370" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt;&lt;code&gt;atomic::fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt; &lt;code&gt;atomic::fence&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="365e7e84eb752771b266d7d9e0c92f84d3398fe0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt;&lt;code&gt;atomic::fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt; &lt;code&gt;atomic::fence&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f323b62e22f70b85a5b00e81ad1dd75f18bb93e" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt;&lt;code&gt;atomic::fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt; &lt;code&gt;atomic::fence&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1bdf72440b67a4b60d0cb051b353e1a1e5f17d8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt;&lt;code&gt;atomic::fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt; &lt;code&gt;atomic::fence&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfb231858cd4689ec5627a23d29186ff8d439dec" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_max&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 부호있는 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicI32::fetch_max&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ba45a4ad89ca37d142fe08556abef04250897691" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_max&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 부호있는 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicI32::fetch_max&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f793986afe8163ac71ccb416509b9ce1b93b28a7" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_max&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 부호있는 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicI32::fetch_max&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="11f793b659028e7642830af52530c7830ca89493" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_max&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 부호있는 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicI32::fetch_max&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="49aafe40a8bc9c4c0d4799be407063a6be2f80b8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_max&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 부호있는 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicI32::fetch_max&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d1036b996bdd682cf46fc64099bdeb270500f551" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_min&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 부호있는 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicI32::fetch_min&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cb8002438bcf3c0d48b47c6879f85d416ab04436" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_min&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 부호있는 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicI32::fetch_min&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0a7b18952940b9b8182e6a6746cc4d6878e30de3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_min&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 부호있는 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicI32::fetch_min&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b2bf12a3e1dda34bbe1170fb23b2c7e3980fa2e2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_min&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 부호있는 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicI32::fetch_min&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e9e3416a187e1174aeae58104e7efc1c7ee03ff6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_min&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 부호있는 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicI32::fetch_min&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="17459feca9539df018355d8750621e9dbfee25c8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange&lt;/code&gt; 메소드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="84bb6ebc113b49007d6fcfdfafa151470c4d97fb" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange&lt;/code&gt; 메소드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b287de0c6ccb4c255ae592a699ddf51d510069e0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;success&lt;/code&gt; 및 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 전달 하여 &lt;code&gt;compare_exchange&lt;/code&gt; 메소드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dc152c646978658d528a198a309e91d74e54a326" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2c1db276c3b3b4fd7ceb4e380bed1da5745f7ffc" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;success&lt;/code&gt; 및 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 전달 하여 &lt;code&gt;compare_exchange&lt;/code&gt; 메소드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="951c50a3c5ccad37a2e3fca1e84b631f4373b483" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange&lt;/code&gt; 메소드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="128d2037df6a05cf07d2834b7655c68820b3bd26" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;success&lt;/code&gt; 및 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 전달 하여 &lt;code&gt;compare_exchange&lt;/code&gt; 메소드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0ab03d58d5f671c0a0db830b6b05ae77f18309c3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange&lt;/code&gt; 메소드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="88060a6c5fb7a5ab11e95c384921daa2c4d4f5bf" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange&lt;/code&gt; 메소드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bd12eff27bb275374d877eb262054ae1c853f908" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="af1fc10d6447bc6c5afd961766bf358a30dcbdba" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="00f0f125817ae56a57898beaed413be79b5a5f7f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;success&lt;/code&gt; 및 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5a4f22637924c144abe1815857665dade4d3c51b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="862ae83bdd80acbffd544e29d0952bfef39ef310" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;success&lt;/code&gt; 및 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 전달 하여 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 메소드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="301da9988d8a43a17c9bdfe746d0d24a87f91ac5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e408b07db98e8ee6804e680f2894d658fb2f63fb" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;success&lt;/code&gt; 및 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 전달 하여 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 메소드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4d2ce54b599780814ddae4cc41ff6842ce0dffc8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c3c44a7a6b16b40cf235a33892e670e0a8bc5178" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;success&lt;/code&gt; 으로 전달 하고 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;failure&lt;/code&gt; 매개 변수 로 전달 하여 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eae6f5127b74d22ebf6510c20a59c81a3de0cdfc" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_add&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="695ca0d01b208d0e14efcb78593ea9daca909ab8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_add&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e4a2657e5f8e4cdd6d19f74f32446cf634f2c708" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_add&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b27a067a3ca05d7ed184ca857f007a3ba758dcd5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_add&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6f042c7aafd7bdff469934311d53691a7a1a1045" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_add&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="91da36591ebb40c0553e91c9f934d905043cb8a9" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_and&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8e00a651851675118139e87206d58986105c4eb0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_and&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="18a857da52573d4e17b52a7e7c33c2b45cbcba5f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_and&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="af7b5f35485a9f9923b0a484a1951a30bb3a1887" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_and&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="993970aa50aa2516408dfe30230dc45762d3f244" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_and&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="460da953958feb4d29ef7b565f8bb84fe0c27874" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_or&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fe64adf45d801b3817879d281caf34973915fca3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_or&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="30017d261ccaa47677175bc1d115dd370a15f192" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_or&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6b88f8c0000bb8e04847190fb1bea4c60b0d2d4b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_or&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5515cfd3dce0baaa5d0933d153812410aa18e81b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_or&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="94f2a12d751dc3a744709ca812719eed5be6639d" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_sub&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt; &lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a7b08115a886002f8e0b6d94070bb4e793dcb17c" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_sub&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt; &lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="65021746bc3a29e483b54a665e8fe3993f3b7531" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_sub&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt; &lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9074d1309228123f0a179daab86adda956d06578" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_sub&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt; &lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bf31a4dfb044ce9c3c11fede562f450062e8cb70" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_sub&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt; &lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0a08ca4aeb864c545fa763c7c1bc0c6adeca1e10" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_xor&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="23e04028b595d303c299af1a09560b78dc738b23" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_xor&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d03d95dd3b76208c05df63103f2a4773075d06c7" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_xor&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="527ff76b4c308bdfc8590a98e3e2f36b010f0a65" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_xor&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2ecf9233457e6140afc96f591e6de39578ed746f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_xor&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b72330976c1ede5cb1f5f36f1315049842fbbb63" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;load&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt;&lt;code&gt;AtomicBool::load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;load&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt; &lt;code&gt;AtomicBool::load&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="07780502f5ae712c09c48bfbf053afbea4b8cc74" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;load&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt;&lt;code&gt;AtomicBool::load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;load&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt; &lt;code&gt;AtomicBool::load&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="61ddb64e96ce0f4ae971acf4e42bb38eda10bc9a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;load&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt;&lt;code&gt;AtomicBool::load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;load&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt; &lt;code&gt;AtomicBool::load&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dd50153000fdd2e98065597c848234d48c5ae7ef" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;store&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt;&lt;code&gt;AtomicBool::store&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;store&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt; &lt;code&gt;AtomicBool::store&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3a6dbd5587aa433e73f8c34d35d442568a18d942" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;store&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt;&lt;code&gt;AtomicBool::store&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;store&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt; &lt;code&gt;AtomicBool::store&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="83f72e56df4940284d7926cf923d2abdf7ea9bb4" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;store&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt;&lt;code&gt;AtomicBool::store&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;store&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt; &lt;code&gt;AtomicBool::store&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="52da2c5cb5cf0d647cd3855825f192673441bdbd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;swap&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt; &lt;code&gt;AtomicBool::swap&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1b30bfb1f2876b5af31915eef811a342ebcdd3b6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;swap&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt; &lt;code&gt;AtomicBool::swap&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4382bd14df2effe7e74aa90568e6832848eea4e2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;swap&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt; &lt;code&gt;AtomicBool::swap&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c61255cb553ed1c231e1f72bb0423d91f01ae315" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;swap&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt; &lt;code&gt;AtomicBool::swap&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a69be96162b6a1c17ecee094d784c23706a36adc" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;swap&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt; &lt;code&gt;AtomicBool::swap&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f289d7def13530cb2e5c5d7eaa967ea0cbc29ea7" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_max&lt;/code&gt; 메서드 를 통해 부호없는 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicU32::fetch_max&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4eb5f9b2cac38e545e679417e0916b9477cb828c" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_max&lt;/code&gt; 메서드 를 통해 부호없는 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicU32::fetch_max&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aedb9c670fb8b498f17ad50461be8607159cf171" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_max&lt;/code&gt; 메서드 를 통해 부호없는 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicU32::fetch_max&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="044d7d27fe09f49e2ad99740d35c149e3d409936" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_max&lt;/code&gt; 메서드 를 통해 부호없는 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicU32::fetch_max&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0c22889aedce154435ee258d0c40e6448efdbc64" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_max&lt;/code&gt; 메소드 를 통해 부호없는 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicU32::fetch_max&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9a58dd280c30118ad91cca00ca18fbb4a646d3fb" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_min&lt;/code&gt; 메서드 를 통해 부호없는 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicU32::fetch_min&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="89f1a35ffbfc66293f3ecb009316545b57e972fd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_min&lt;/code&gt; 메서드 를 통해 부호없는 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicU32::fetch_min&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6f36baf03828badd5e395776499479459fdf74dd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_min&lt;/code&gt; 메서드 를 통해 부호없는 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicU32::fetch_min&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d7b26c022d9640d58bf0ee1df55fea1127cc8b08" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_min&lt;/code&gt; 메서드 를 통해 부호없는 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicU32::fetch_min&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b715010a7a857987bd13e4e2c7860444d5f72aff" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_min&lt;/code&gt; 메서드 를 통해 부호없는 &lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt; 정수 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicU32::fetch_min&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5f8d269b525f2aa0c49880dc3986476498a5a32" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_nand&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="45b7d1ba04947e0d60fd8323f25d9cb851df4d45" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_nand&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f0f46b18b5f9509f4b838f2cd1cc47b1cca4ac44" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_nand&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6eee377d6930faac324afa2f516a7fca7070547e" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_nand&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c150f5488b1c18a2f570344ce5e7e4fbf333ebdf" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 &lt;code&gt;fetch_nand&lt;/code&gt; 메서드 를 통해 &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt; 유형 에서 사용할 수 있습니다 . 예를 들면 &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4467e4d025c942d0e46a8d42d28e9cb70772aadf" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;count_ones&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.count_ones&quot;&gt;&lt;code&gt;u32::count_ones&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;count_ones&lt;/code&gt; 메소드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.count_ones&quot;&gt; &lt;code&gt;u32::count_ones&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f49764c7bf099d11524ff3ae31ea8122bd687603" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;leading_zeros&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.leading_zeros&quot;&gt;&lt;code&gt;u32::leading_zeros&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;leading_zeros&lt;/code&gt; 메서드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.leading_zeros&quot;&gt; &lt;code&gt;u32::leading_zeros&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94453dce8a2a385d273d4c54481b7123c231b9e1" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;overflowing_add&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.overflowing_add&quot;&gt;&lt;code&gt;u32::overflowing_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;overflowing_add&lt;/code&gt; 메소드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.overflowing_add&quot;&gt; &lt;code&gt;u32::overflowing_add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="975a6bc8f0eb314f9e1b240024dd857b1481fb4f" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;overflowing_mul&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.overflowing_mul&quot;&gt;&lt;code&gt;u32::overflowing_mul&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;overflowing_mul&lt;/code&gt; 메소드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.overflowing_mul&quot;&gt; &lt;code&gt;u32::overflowing_mul&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05ac2c8d4649564823e71195e6e1991816e3c134" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;overflowing_sub&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.overflowing_sub&quot;&gt;&lt;code&gt;u32::overflowing_sub&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;overflowing_sub&lt;/code&gt; 메소드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.overflowing_sub&quot;&gt; &lt;code&gt;u32::overflowing_sub&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cea1555efef9a893424297cca53eccdff2cb4c12" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;reverse_bits&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.reverse_bits&quot;&gt;&lt;code&gt;u32::reverse_bits&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;reverse_bits&lt;/code&gt; 메서드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.reverse_bits&quot;&gt; &lt;code&gt;u32::reverse_bits&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="02b9a60eaad995a8b508e08e5f720afcfb3cdf4f" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;rotate_left&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.rotate_left&quot;&gt;&lt;code&gt;u32::rotate_left&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;rotate_left&lt;/code&gt; 메서드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.rotate_left&quot;&gt; &lt;code&gt;u32::rotate_left&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a39d8d5e922a37bc7cb7a4273c351e3237285524" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;rotate_right&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.rotate_right&quot;&gt;&lt;code&gt;u32::rotate_right&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;rotate_right&lt;/code&gt; 메서드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.rotate_right&quot;&gt; &lt;code&gt;u32::rotate_right&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1c9cb80ab093ca12a015c158de3a354687ef2774" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;saturating_add&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.saturating_add&quot;&gt;&lt;code&gt;u32::saturating_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;saturating_add&lt;/code&gt; 메소드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.saturating_add&quot;&gt; &lt;code&gt;u32::saturating_add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0dfb3fdba827a384aada0939a551d1f733164685" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;saturating_sub&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.saturating_sub&quot;&gt;&lt;code&gt;u32::saturating_sub&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;saturating_sub&lt;/code&gt; 메소드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.saturating_sub&quot;&gt; &lt;code&gt;u32::saturating_sub&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7476e3eb126b1478bcad495831ba6637eb3d2b14" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;swap_bytes&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.swap_bytes&quot;&gt;&lt;code&gt;u32::swap_bytes&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;swap_bytes&lt;/code&gt; 메서드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.swap_bytes&quot;&gt; &lt;code&gt;u32::swap_bytes&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e398694f9fea1333665249a1e9c25a4d94f59367" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;trailing_zeros&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.trailing_zeros&quot;&gt;&lt;code&gt;u32::trailing_zeros&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 내장 함수의 안정화 된 버전은 &lt;code&gt;trailing_zeros&lt;/code&gt; 메서드 를 통해 정수 프리미티브에서 사용할 수 있습니다 . 예 : &lt;a href=&quot;../primitive.u32#method.trailing_zeros&quot;&gt; &lt;code&gt;u32::trailing_zeros&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="07e69ca4af06caf0678a0eb7f58dbb4160ebfce9" translate="yes" xml:space="preserve">
          <source>The standard library API documentation describes methods that vectors, strings, and hash maps have that will be helpful for these exercises!</source>
          <target state="translated">표준 라이브러리 API 설명서에는 벡터, 문자열 및 해시 맵이 이러한 연습에 도움이되는 메소드가 설명되어 있습니다!</target>
        </trans-unit>
        <trans-unit id="ecfac3d3b7b498f942f6cc167a3014bcca50e8db" translate="yes" xml:space="preserve">
          <source>The standard library also provides a &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; newtype which ensures all standard arithmetic operations for &lt;code&gt;T&lt;/code&gt; have wrapping semantics.</source>
          <target state="translated">표준 라이브러리는 또한 &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; newtype을 제공하여 &lt;code&gt;T&lt;/code&gt; 에 대한 모든 표준 산술 연산에 랩핑 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e62bb358494cb55da1b597b5302098f7179da4a8" translate="yes" xml:space="preserve">
          <source>The standard library contains additional 'smart pointer' types beyond references and raw pointers.</source>
          <target state="translated">표준 라이브러리에는 참조 및 원시 포인터 이외의 추가 '스마트 포인터'유형이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aeb001acf27f60d5c3f4949174f0ea7b98815a0" translate="yes" xml:space="preserve">
          <source>The standard library documentation for the &lt;code&gt;env::args&lt;/code&gt; function shows that the type of the iterator it returns is &lt;code&gt;std::env::Args&lt;/code&gt;. We&amp;rsquo;ve updated the signature of the &lt;code&gt;Config::new&lt;/code&gt; function so the parameter &lt;code&gt;args&lt;/code&gt; has the type &lt;code&gt;std::env::Args&lt;/code&gt; instead of &lt;code&gt;&amp;amp;[String]&lt;/code&gt;. Because we&amp;rsquo;re taking ownership of &lt;code&gt;args&lt;/code&gt; and we&amp;rsquo;ll be mutating &lt;code&gt;args&lt;/code&gt; by iterating over it, we can add the &lt;code&gt;mut&lt;/code&gt; keyword into the specification of the &lt;code&gt;args&lt;/code&gt; parameter to make it mutable.</source>
          <target state="translated">&lt;code&gt;env::args&lt;/code&gt; 함수 의 표준 라이브러리 문서는 리턴하는 반복자의 유형이 &lt;code&gt;std::env::Args&lt;/code&gt; 임을 보여줍니다 . &lt;code&gt;args&lt;/code&gt; 매개 변수 의 유형 이 &lt;code&gt;&amp;amp;[String]&lt;/code&gt; 대신 &lt;code&gt;std::env::Args&lt;/code&gt; 형식이 되도록 &lt;code&gt;Config::new&lt;/code&gt; 함수 의 서명을 업데이트했습니다 . 우리는 &lt;code&gt;args&lt;/code&gt; 의 소유권을 취하고 그것을 반복함으로써 &lt;code&gt;args&lt;/code&gt; 를 변경 시킬 것이기 때문에, &lt;code&gt;mut&lt;/code&gt; 키워드를 &lt;code&gt;args&lt;/code&gt; 매개 변수 의 사양에 추가하여 변경 가능하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ac01984afb710ebee7af9fdef959461335b5771" translate="yes" xml:space="preserve">
          <source>The standard library does &lt;em&gt;not&lt;/em&gt; automatically wait on child processes (not even if the &lt;code&gt;Child&lt;/code&gt; is dropped), it is up to the application developer to do so. As a consequence, dropping &lt;code&gt;Child&lt;/code&gt; handles without waiting on them first is not recommended in long-running applications.</source>
          <target state="translated">표준 라이브러리는 자식 프로세스를 자동으로 기다리지 &lt;em&gt;않으며&lt;/em&gt; ( &lt;code&gt;Child&lt;/code&gt; 이 삭제 된 경우에도 ) 응용 프로그램 개발자의 책임입니다. 따라서 장시간 실행되는 응용 프로그램에서는 먼저 핸들을 기다리지 않고 &lt;code&gt;Child&lt;/code&gt; 핸들을 삭제 하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c3da8861a8cd359749d019429f14004546548517" translate="yes" xml:space="preserve">
          <source>The standard library exports many modules &lt;em&gt;with the same name as primitive types&lt;/em&gt;. These define additional items related to the primitive type, but not the all-important methods.</source>
          <target state="translated">표준 라이브러리 &lt;em&gt;는 기본 유형과 이름이 같은&lt;/em&gt; 많은 모듈 &lt;em&gt;을&lt;/em&gt; 내 보냅니다 . 이것들은 기본 유형과 관련된 추가 항목을 정의하지만 모든 중요한 방법은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="be570bfc11d12183d4ccfc099e5e91a1312fadce" translate="yes" xml:space="preserve">
          <source>The standard library exposes three common ways to deal with contiguous regions of memory:</source>
          <target state="translated">표준 라이브러리는 인접한 메모리 영역을 처리하는 세 가지 일반적인 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d66210e7b423f4f4e31543419e308e2c95ac4c07" translate="yes" xml:space="preserve">
          <source>The standard library has other types that provide interior mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;, which is similar except that instead of giving references to the inner value, the value is copied in and out of the &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;. There&amp;rsquo;s also &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;, which offers interior mutability that&amp;rsquo;s safe to use across threads; we&amp;rsquo;ll discuss its use in Chapter 16. Check out the standard library docs for more details on the differences between these types.</source>
          <target state="translated">표준 라이브러리에는 내부 변이성을 제공하는 다른 유형 (예 : &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; )이 있습니다. 이는 내부 값에 대한 참조를 제공하는 대신 값이 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 안팎으로 복사되는 것을 제외하고는 비슷 합니다. 도 있습니다 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 스레드는 스레드간에 안전하게 사용할 수있는 내부 변경 성을 제공합니다. 이러한 유형의 차이점에 대한 자세한 내용은 표준 라이브러리 문서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a3eb5ea324c5e016fa7225e0db42ddd0287496a0" translate="yes" xml:space="preserve">
          <source>The standard library implements some I/O traits on various types which are commonly used as a buffer, like &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;Cursor&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Cursor&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 와 같이 일반적으로 버퍼로 사용되는 다양한 유형의 일부 I / O 특성을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="bac69e8dd1e3e493ce33a798e654cad2d62974e3" translate="yes" xml:space="preserve">
          <source>The standard library implements some I/O traits on various types which are commonly used as a buffer, like &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../slice/index&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;Cursor&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Cursor&amp;lt;&lt;/code&gt; &lt;a href=&quot;../slice/index&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 와 같이 일반적으로 버퍼로 사용되는 다양한 유형에 대한 몇 가지 I / O 특성을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="cd43fc91f30c20105f33015f4862eaa4ba469ffd" translate="yes" xml:space="preserve">
          <source>The standard library in general strives to support both statically linked and dynamically linked C runtimes for targets as appropriate. For example the &lt;code&gt;x86_64-pc-windows-msvc&lt;/code&gt; and &lt;code&gt;x86_64-unknown-linux-musl&lt;/code&gt; targets typically come with both runtimes and the user selects which one they'd like. All targets in the compiler have a default mode of linking to the C runtime. Typically targets are linked dynamically by default, but there are exceptions which are static by default such as:</source>
          <target state="translated">표준 라이브러리는 일반적으로 대상에 대해 정적으로 링크 된 C 런타임과 동적으로 링크 된 C 런타임을 모두 지원하기 위해 노력합니다. 예를 들어 &lt;code&gt;x86_64-pc-windows-msvc&lt;/code&gt; 및 &lt;code&gt;x86_64-unknown-linux-musl&lt;/code&gt; 대상은 일반적으로 런타임과 함께 제공되며 사용자는 원하는 것을 선택합니다. 컴파일러의 모든 대상에는 C 런타임에 연결하는 기본 모드가 있습니다. 일반적으로 대상은 기본적으로 동적으로 연결되지만 기본적으로 정적 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e62009a1ff01cf79d8a5846c788aa68bf271141c" translate="yes" xml:space="preserve">
          <source>The standard library provides an implementation of &lt;code&gt;panic_handler&lt;/code&gt; that defaults to unwinding the stack but that can be &lt;a href=&quot;../book/ch09-01-unrecoverable-errors-with-panic&quot;&gt;changed to abort the process&lt;/a&gt;. The standard library's panic behavior can be modified at runtime with the &lt;a href=&quot;../std/panic/fn.set_hook&quot;&gt;set_hook&lt;/a&gt; function.</source>
          <target state="translated">표준 라이브러리는 스택 해제를 기본으로 설정하지만 &lt;a href=&quot;../book/ch09-01-unrecoverable-errors-with-panic&quot;&gt;프로세스를 중단&lt;/a&gt; 하도록 변경할 수있는 &lt;code&gt;panic_handler&lt;/code&gt; 의 구현을 제공합니다 . 표준 라이브러리의 패닉 동작은 런타임에 &lt;a href=&quot;../std/panic/fn.set_hook&quot;&gt;set_hook&lt;/a&gt; 함수를 사용하여 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6bfe00112d50ce1df3b69fa8e0f97c99e921c7e" translate="yes" xml:space="preserve">
          <source>The standard library&amp;rsquo;s &lt;code&gt;Add&lt;/code&gt; trait is an example of the second purpose: usually, you&amp;rsquo;ll add two like types, but the &lt;code&gt;Add&lt;/code&gt; trait provides the ability to customize beyond that. Using a default type parameter in the &lt;code&gt;Add&lt;/code&gt; trait definition means you don&amp;rsquo;t have to specify the extra parameter most of the time. In other words, a bit of implementation boilerplate isn&amp;rsquo;t needed, making it easier to use the trait.</source>
          <target state="translated">표준 라이브러리의 &lt;code&gt;Add&lt;/code&gt; 특성은 두 번째 목적의 예입니다. 일반적으로 두 가지 유형을 &lt;code&gt;Add&lt;/code&gt; 하지만 Add 특성은 그 이상으로 사용자 정의 할 수있는 기능을 제공합니다. 특성 정의 &lt;code&gt;Add&lt;/code&gt; 에 기본 유형 매개 변수 를 사용하면 추가 매개 변수를 대부분 지정할 필요가 없습니다. 다시 말해, 약간의 구현 상용구가 필요하지 않으므로 특성을보다 쉽게 ​​사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0eb239c2b2b429ca2fb24dfb5a68ef2028451c54" translate="yes" xml:space="preserve">
          <source>The start and end of the string (when &lt;code&gt;index == self.len()&lt;/code&gt;) are considered to be boundaries.</source>
          <target state="translated">문자열의 시작과 끝 ( &lt;code&gt;index == self.len()&lt;/code&gt; )은 경계로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="cc00d65ec1e11702c522241a5699948a50675d34" translate="yes" xml:space="preserve">
          <source>The starting index must come before the ending index;</source>
          <target state="translated">시작 색인은 종료 색인 앞에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="7d09dcb9f35a47d4d0374a51c368ed9570b886f1" translate="yes" xml:space="preserve">
          <source>The starting index must not exceed the ending index;</source>
          <target state="translated">시작 색인은 종료 색인을 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="71f319cd135ed3830fb0df0009e873ba0d9d3bd8" translate="yes" xml:space="preserve">
          <source>The static initializer is a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt; evaluated at compile time. Static initializers may refer to other statics.</source>
          <target state="translated">정적 이니셜 라이저는 컴파일 타임에 평가 되는 &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;상수 식&lt;/a&gt; 입니다. 정적 이니셜 라이저는 다른 정적을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37ec0e6627e56520c118b2a4c9fe270333b4a9ac" translate="yes" xml:space="preserve">
          <source>The status (exit code) of the process.</source>
          <target state="translated">프로세스의 상태 (종료 코드)</target>
        </trans-unit>
        <trans-unit id="2deb263189905df596d3c94b6a6e46fb7fad91f4" translate="yes" xml:space="preserve">
          <source>The status code 200 is the standard success response. The text is a tiny successful HTTP response. Let&amp;rsquo;s write this to the stream as our response to a successful request! From the &lt;code&gt;handle_connection&lt;/code&gt; function, remove the &lt;code&gt;println!&lt;/code&gt; that was printing the request data and replace it with the code in Listing 20-3.</source>
          <target state="translated">상태 코드 200은 표준 성공 응답입니다. 텍스트는 아주 성공적인 HTTP 응답입니다. 성공적인 요청에 대한 응답으로 이것을 스트림에 씁시다! 로부터 &lt;code&gt;handle_connection&lt;/code&gt; 의 기능의 제거 &lt;code&gt;println!&lt;/code&gt; 요청 데이터를 인쇄하고이를 목록 20-3의 코드로 대체했습니다.</target>
        </trans-unit>
        <trans-unit id="121dc7dfe8e1f05a50f59cc42ea3919e004fbd87" translate="yes" xml:space="preserve">
          <source>The stdin handle to the child process, if any, will be closed before waiting. This helps avoid deadlock: it ensures that the child does not block waiting for input from the parent, while the parent waits for the child to exit.</source>
          <target state="translated">자식 프로세스에 대한 stdin 핸들 (있는 경우)은 대기하기 전에 닫힙니다. 교착 상태를 피하는 데 도움이됩니다. 즉, 부모가 자식의 종료를 기다리지 않고 자식이 부모의 입력을 기다리지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="9e925de820aa28eb2278cfb5b172897339fec44e" translate="yes" xml:space="preserve">
          <source>The stem is:</source>
          <target state="translated">줄기는 :</target>
        </trans-unit>
        <trans-unit id="f0b062427634e6f3b4d22b8847d4a85e632115c3" translate="yes" xml:space="preserve">
          <source>The stream of &lt;a href=&quot;enum.searchstep#variant.Match&quot;&gt;&lt;code&gt;Match&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.searchstep#variant.Reject&quot;&gt;&lt;code&gt;Reject&lt;/code&gt;&lt;/a&gt; values up to a &lt;a href=&quot;enum.searchstep#variant.Done&quot;&gt;&lt;code&gt;Done&lt;/code&gt;&lt;/a&gt; will contain index ranges that are adjacent, non-overlapping, covering the whole haystack, and laying on utf8 boundaries.</source>
          <target state="translated">&lt;a href=&quot;enum.searchstep#variant.Done&quot;&gt; &lt;code&gt;Done&lt;/code&gt; &lt;/a&gt; 까지 의 &lt;a href=&quot;enum.searchstep#variant.Match&quot;&gt; &lt;code&gt;Match&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;enum.searchstep#variant.Reject&quot;&gt; &lt;code&gt;Reject&lt;/code&gt; &lt;/a&gt; 값 스트림 에는 인접하고 겹치지 않고 전체 건초 더미를 덮고 utf8 경계에 놓인 인덱스 범위가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="29cd101b0d8222a260b75e7043b8f85140377fdb" translate="yes" xml:space="preserve">
          <source>The stream of &lt;code&gt;Match&lt;/code&gt; and &lt;code&gt;Reject&lt;/code&gt; values up to a &lt;code&gt;Done&lt;/code&gt; will contain index ranges that are adjacent, non-overlapping, covering the whole haystack, and laying on utf8 boundaries.</source>
          <target state="translated">&lt;code&gt;Done&lt;/code&gt; 까지 의 &lt;code&gt;Match&lt;/code&gt; 및 &lt;code&gt;Reject&lt;/code&gt; 값 스트림 에는 인접하고 겹치지 않으며 전체 건초 더미를 덮고 utf8 경계에있는 인덱스 범위가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fe598c8b995968505dc48317e5f0bc507dd1c32a" translate="yes" xml:space="preserve">
          <source>The stream typically has a fixed size, allowing seeking relative to either end or the current offset.</source>
          <target state="translated">스트림은 일반적으로 고정 된 크기를 가지므로 끝 또는 현재 오프셋을 기준으로 탐색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f8a9a233edfd6e32f4b57b8721cdb5b1b1aca0a" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;s3&lt;/code&gt; will contain &lt;code&gt;Hello, world!&lt;/code&gt; as a result of this code. The reason &lt;code&gt;s1&lt;/code&gt; is no longer valid after the addition and the reason we used a reference to &lt;code&gt;s2&lt;/code&gt; has to do with the signature of the method that gets called when we use the &lt;code&gt;+&lt;/code&gt; operator. The &lt;code&gt;+&lt;/code&gt; operator uses the &lt;code&gt;add&lt;/code&gt; method, whose signature looks something like this:</source>
          <target state="translated">문자열 &lt;code&gt;s3&lt;/code&gt; 에는 &lt;code&gt;Hello, world!&lt;/code&gt; 가 포함됩니다 . 이 코드의 결과로. &lt;code&gt;s1&lt;/code&gt; 이유 는 더한 후에 더 이상 유효하지 않으며 &lt;code&gt;s2&lt;/code&gt; 에 대한 참조를 사용한 이유 는 &lt;code&gt;+&lt;/code&gt; 연산자를 사용할 때 호출되는 메소드의 서명과 관련이 있습니다. &lt;code&gt;+&lt;/code&gt; 의 연산자는 사용 &lt;code&gt;add&lt;/code&gt; 누구의 서명과 같은 형태 방법 :</target>
        </trans-unit>
        <trans-unit id="00f2d10e6fe0131d33ac9bca9a600be0160e329e" translate="yes" xml:space="preserve">
          <source>The string Pattern API.</source>
          <target state="translated">문자열 패턴 API</target>
        </trans-unit>
        <trans-unit id="12fed2044893f571a9f644790505d48a15787f1f" translate="yes" xml:space="preserve">
          <source>The string is expected to be an optional &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; sign followed by digits. Leading and trailing whitespace represent an error. Digits are a subset of these characters, depending on &lt;code&gt;radix&lt;/code&gt;:</source>
          <target state="translated">문자열은 선택적인 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 부호와 숫자 가 있어야합니다 . 선행 및 후행 공백은 오류를 나타냅니다. &lt;code&gt;radix&lt;/code&gt; 는 기수 에 따라 이러한 문자의 하위 집합입니다 .</target>
        </trans-unit>
        <trans-unit id="c23316acb8db6205270f951b08328de7cc2d92db" translate="yes" xml:space="preserve">
          <source>The string is expected to be an optional &lt;code&gt;+&lt;/code&gt; sign followed by digits. Leading and trailing whitespace represent an error. Digits are a subset of these characters, depending on &lt;code&gt;radix&lt;/code&gt;:</source>
          <target state="translated">문자열은 선택적인 &lt;code&gt;+&lt;/code&gt; 부호와 숫자 가 있어야합니다 . 선행 및 후행 공백은 오류를 나타냅니다. &lt;code&gt;radix&lt;/code&gt; 는 기수 에 따라 이러한 문자의 하위 집합입니다 .</target>
        </trans-unit>
        <trans-unit id="468f8218bbd425a57c6d5b5fde91fdb78d951a69" translate="yes" xml:space="preserve">
          <source>The string on the right-hand side is only borrowed; its contents are copied into the returned &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">오른쪽의 줄은 빌려온 것입니다. 그 내용은 반환 된 &lt;code&gt;String&lt;/code&gt; 에 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="86da74512bec8006d79316da49e5b54d47ae707d" translate="yes" xml:space="preserve">
          <source>The string will be able to hold exactly &lt;code&gt;capacity&lt;/code&gt; length units of other OS strings without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the string will not allocate.</source>
          <target state="translated">문자열은 재할 당하지 않고 다른 OS 문자열의 &lt;code&gt;capacity&lt;/code&gt; 길이 단위를 정확하게 유지할 수 있습니다 . 경우 &lt;code&gt;capacity&lt;/code&gt; 0 인 문자열이 할당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6f927907143ca3f662c21fec70de91f1f0df225" translate="yes" xml:space="preserve">
          <source>The struct &lt;code&gt;PointList&lt;/code&gt; cannot implement &lt;code&gt;Copy&lt;/code&gt;, because &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is not &lt;code&gt;Copy&lt;/code&gt;. If we attempt to derive a &lt;code&gt;Copy&lt;/code&gt; implementation, we'll get an error:</source>
          <target state="translated">&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;Copy&lt;/code&gt; 가 아니기 때문에 struct &lt;code&gt;PointList&lt;/code&gt; 가 &lt;code&gt;Copy&lt;/code&gt; 를 구현할 수 없습니다 . &lt;code&gt;Copy&lt;/code&gt; 구현 을 시도 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5c8326afa9ea5c7b5b28789d2c040dda354125af" translate="yes" xml:space="preserve">
          <source>The struct is marked &lt;code&gt;pub&lt;/code&gt; so that other code can use it, but the fields within the struct remain private. This is important in this case because we want to ensure that whenever a value is added or removed from the list, the average is also updated. We do this by implementing &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;average&lt;/code&gt; methods on the struct, as shown in Listing 17-2:</source>
          <target state="translated">구조체는 &lt;code&gt;pub&lt;/code&gt; 으로 표시되어 다른 코드에서 사용할 수 있지만 구조체 내의 필드는 비공개로 유지됩니다. 목록에서 값을 추가하거나 제거 할 때마다 평균도 업데이트되도록하려면이 경우 중요합니다. Listing 17-2와 같이 구조체에 &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; 및 &lt;code&gt;average&lt;/code&gt; 메소드를 구현하여이를 수행한다 .</target>
        </trans-unit>
        <trans-unit id="9c1c27f7e80229e155110850a64cfa98b9973379" translate="yes" xml:space="preserve">
          <source>The struct must only be &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; if all the structural fields are &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;. This is the default, but &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; is a safe trait, so as the author of the struct it is your responsibility &lt;em&gt;not&lt;/em&gt; to add something like &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt;. (Notice that adding a projection operation requires unsafe code, so the fact that &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; is a safe trait does not break the principle that you only have to worry about any of this if you use &lt;code&gt;unsafe&lt;/code&gt;.)</source>
          <target state="translated">구조는 모든 구조 필드가 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 경우 에만 고정 해제 여야 합니다 . 이것이 기본값이지만 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 은 안전한 특성이므로 구조체 작성자로서 &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt; 와 같은 것을 추가 &lt;em&gt;하지 않는&lt;/em&gt; 것은 귀하의 책임 입니다. (프로젝션 작업을 추가하려면 안전하지 않은 코드가 필요하므로 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 이 안전한 특성 이라는 사실 은 &lt;code&gt;unsafe&lt;/code&gt; 를 사용하는 경우에만 걱정해야한다는 원칙을 위반하지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="a87dba90688420e84c6cfc3a67588b540866213a" translate="yes" xml:space="preserve">
          <source>The struct must only be &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; if all the structural fields are &lt;code&gt;Unpin&lt;/code&gt;. This is the default, but &lt;code&gt;Unpin&lt;/code&gt; is a safe trait, so as the author of the struct it is your responsibility &lt;em&gt;not&lt;/em&gt; to add something like &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt;. (Notice that adding a projection operation requires unsafe code, so the fact that &lt;code&gt;Unpin&lt;/code&gt; is a safe trait does not break the principle that you only have to worry about any of this if you use &lt;code&gt;unsafe&lt;/code&gt;.)</source>
          <target state="translated">모든 구조 필드가 &lt;code&gt;Unpin&lt;/code&gt; &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 경우 구조체는 고정 해제 여야 합니다 . 이것이 기본값이지만 &lt;code&gt;Unpin&lt;/code&gt; 은 안전한 특성이므로 구조체의 작성자는 &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt; 와 같은 것을 추가 &lt;em&gt;하지 않는&lt;/em&gt; 것은 귀하의 책임 입니다. (주의 투사 작업을 추가하는 것은 안전하지 않은 코드를 필요로한다는 사실 때문에 &lt;code&gt;Unpin&lt;/code&gt; 당신이 사용하는 경우에만이의에 대해 걱정할 필요가 있다는 원칙을 파괴하지 않는 안전 특징이다 &lt;code&gt;unsafe&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="a32a0dfa31f0f0289e823ec593ac2d0e0186cb3f" translate="yes" xml:space="preserve">
          <source>The structure in the &lt;code&gt;vec!&lt;/code&gt; body is similar to the structure of a &lt;code&gt;match&lt;/code&gt; expression. Here we have one arm with the pattern &lt;code&gt;( $( $x:expr ),* )&lt;/code&gt;, followed by &lt;code&gt;=&amp;gt;&lt;/code&gt; and the block of code associated with this pattern. If the pattern matches, the associated block of code will be emitted. Given that this is the only pattern in this macro, there is only one valid way to match; any other pattern will result in an error. More complex macros will have more than one arm.</source>
          <target state="translated">&lt;code&gt;vec!&lt;/code&gt; 의 구조 ! body는 &lt;code&gt;match&lt;/code&gt; 표현식 의 구조와 유사합니다 . 여기서 우리는 패턴이 하나의 아암 &lt;code&gt;( $( $x:expr ),* )&lt;/code&gt; 이어서, &lt;code&gt;=&amp;gt;&lt;/code&gt; 이 패턴과 연관된 코드 블록. 패턴이 일치하면 관련 코드 블록이 생성됩니다. 이것이이 매크로에서 유일한 패턴이라는 것을 감안할 때, 일치하는 유효한 방법은 하나뿐입니다. 다른 패턴은 오류가 발생합니다. 더 복잡한 매크로에는 둘 이상의 팔이 있습니다.</target>
        </trans-unit>
        <trans-unit id="feedd74875f823ef27b80e0ba6fe89baf9a484a0" translate="yes" xml:space="preserve">
          <source>The structure of your public API is a major consideration when publishing a crate. People who use your crate are less familiar with the structure than you are and might have difficulty finding the pieces they want to use if your crate has a large module hierarchy.</source>
          <target state="translated">크레이트를 게시 할 때 퍼블릭 API의 구조를 고려해야합니다. 상자를 사용하는 사람들은 사용자보다 구조에 익숙하지 않으며 상자에 모듈 계층이 큰 경우 사용하려는 조각을 찾기가 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bdec152aa7987052184ceacfeaf61672bfbc336" translate="yes" xml:space="preserve">
          <source>The subtraction assignment operator &lt;code&gt;-=&lt;/code&gt;.</source>
          <target state="translated">감산 대입 연산자 &lt;code&gt;-=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9df0e8a4e443e9ee7a165601e70a6b8ea73f8885" translate="yes" xml:space="preserve">
          <source>The subtraction operator &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">빼기 연산자 &lt;code&gt;-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28fd4d4d9eae938e322b4e3df0e6f419cbd1966d" translate="yes" xml:space="preserve">
          <source>The summary line displays at the end: overall, our test result is &lt;code&gt;FAILED&lt;/code&gt;. We had one test pass and one test fail.</source>
          <target state="translated">마지막 줄에 요약 행이 표시됩니다. 전체적으로 테스트 결과는 &lt;code&gt;FAILED&lt;/code&gt; 입니다. 한 번의 테스트 통과와 한 번의 테스트 실패가있었습니다.</target>
        </trans-unit>
        <trans-unit id="ee42b5387704f2d9fe3e70d6349076680fb579e8" translate="yes" xml:space="preserve">
          <source>The supplied key may be any borrowed form of the map's key type, but &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">제공된 키는지도의 주요 유형의 대출 형태가 될 수 있지만, &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 빌린 양식이 &lt;em&gt;있어야합니다&lt;/em&gt; 키 유형과 일치.</target>
        </trans-unit>
        <trans-unit id="4d0db9da1f6030ddf936168ba198ea7e2ea2a8e7" translate="yes" xml:space="preserve">
          <source>The supplied key may be any borrowed form of the map's key type, but &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">제공된 키는지도의 주요 유형의 대출 형태가 될 수 있지만, &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 빌린 양식이 &lt;em&gt;있어야합니다&lt;/em&gt; 키 유형과 일치.</target>
        </trans-unit>
        <trans-unit id="6157ddf403c8a4c61dced75b578898d85ccde0c2" translate="yes" xml:space="preserve">
          <source>The supplied key may be any borrowed form of the map's key type, but the ordering on the borrowed form &lt;em&gt;must&lt;/em&gt; match the ordering on the key type.</source>
          <target state="translated">제공된 키는지도 키 유형의 빌린 형태 일 수 있지만 빌린 양식 의 순서는 키 유형의 순서와 일치 &lt;em&gt;해야합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9a3120ffbc7b98288aabd741823275a65245701a" translate="yes" xml:space="preserve">
          <source>The symbol &lt;code&gt;^C&lt;/code&gt; represents where you pressed ctrl-c . You may or may not see the word &lt;code&gt;again!&lt;/code&gt; printed after the &lt;code&gt;^C&lt;/code&gt;, depending on where the code was in the loop when it received the interrupt signal.</source>
          <target state="translated">&lt;code&gt;^C&lt;/code&gt; 기호 는 ctrl-c를 누른 위치를 나타냅니다. 단어를 &lt;code&gt;again!&lt;/code&gt; 보거나 보지 못할 수 있습니다 ! 인터럽트 신호를 수신했을 때 코드가 루프에있는 위치에 따라 &lt;code&gt;^C&lt;/code&gt; 뒤에 인쇄 됩니다.</target>
        </trans-unit>
        <trans-unit id="266a6ae6e0b1b671aa6c8cd7616208233ffe3a4b" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;..&lt;/code&gt; will expand to as many values as it needs to be. Listing 18-24 shows how to use &lt;code&gt;..&lt;/code&gt; with a tuple.</source>
          <target state="translated">구문 &lt;code&gt;..&lt;/code&gt; 은 필요한만큼 많은 값으로 확장됩니다. Listing 18-24는 &lt;code&gt;..&lt;/code&gt; 을 튜플과 함께 사용하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="79fc3d3c405b115d38b7334d712d4081f0801fc2" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;if let&lt;/code&gt; takes a pattern and an expression separated by an equal sign. It works the same way as a &lt;code&gt;match&lt;/code&gt;, where the expression is given to the &lt;code&gt;match&lt;/code&gt; and the pattern is its first arm.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 구문 은 등호로 구분 된 패턴과 표현식을 사용합니다. &lt;code&gt;match&lt;/code&gt; 하는 식과 동일한 방식으로 작동합니다 . 여기서 식은 &lt;code&gt;match&lt;/code&gt; 되고 패턴은 첫 번째 팔입니다.</target>
        </trans-unit>
        <trans-unit id="751b24fbac99aa6572c9e1b012dbbe4901f9dd78" translate="yes" xml:space="preserve">
          <source>The syntax and semantics for generators is unstable and will require a further RFC for stabilization. At this time, though, the syntax is closure-like:</source>
          <target state="translated">생성기의 구문과 의미는 불안정하며 안정화를 위해 추가 RFC가 필요합니다. 그러나 현재 구문은 클로저와 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="f94369f4bb8ebdf54603588e1760be815601c761" translate="yes" xml:space="preserve">
          <source>The syntax for the formatting language used is drawn from other languages, so it should not be too alien. Arguments are formatted with Python-like syntax, meaning that arguments are surrounded by &lt;code&gt;{}&lt;/code&gt; instead of the C-like &lt;code&gt;%&lt;/code&gt;. The actual grammar for the formatting syntax is:</source>
          <target state="translated">사용 된 서식 언어의 구문은 다른 언어에서 파생되었으므로 너무 외계인이 아니어야합니다. 인수는 Python과 유사한 구문으로 형식이 지정됩니다. 즉, 인수는 C와 같은 &lt;code&gt;%&lt;/code&gt; 대신 &lt;code&gt;{}&lt;/code&gt; 로 둘러싸여 있습니다. 서식 구문의 실제 문법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b1fb2c0dcb9e4f22d10669f04073e3418ad44567" translate="yes" xml:space="preserve">
          <source>The syntax for using generics in struct definitions is similar to that used in function definitions. First, we declare the name of the type parameter inside angle brackets just after the name of the struct. Then we can use the generic type in the struct definition where we would otherwise specify concrete data types.</source>
          <target state="translated">구조체 정의에서 제네릭을 사용하는 구문은 함수 정의에서 사용되는 구문과 유사합니다. 먼저 구조체 이름 바로 뒤에 꺾쇠 괄호 안에 type 매개 변수의 이름을 선언합니다. 그런 다음 구체적인 데이터 형식을 지정하는 구조체 정의에서 일반 형식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be667267584bb9b3dbb1d7d6c41e7cff90529baf" translate="yes" xml:space="preserve">
          <source>The syntax given to this macro is the same syntax as the &lt;a href=&quot;../reference/conditional-compilation#the-cfg-attribute&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">이 매크로에 제공된 구문은 &lt;a href=&quot;../reference/conditional-compilation#the-cfg-attribute&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; 속성 과 동일한 구문 입니다.</target>
        </trans-unit>
        <trans-unit id="37efe90a09f5adb20955a8d29f6006705ceea1f4" translate="yes" xml:space="preserve">
          <source>The syntax is &lt;code&gt;type Name = ExistingType;&lt;/code&gt;.</source>
          <target state="translated">구문은 &lt;code&gt;type Name = ExistingType;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a952c08ff986f0fd0f90d2e270d99cd3e69c17a4" translate="yes" xml:space="preserve">
          <source>The syntax is the following: &lt;code&gt;dyn BaseTrait + AutoTrait1 + ... AutoTraitN&lt;/code&gt;. Only one &lt;code&gt;BaseTrait&lt;/code&gt; can be used so this will not compile:</source>
          <target state="translated">구문은 다음과 같습니다. &lt;code&gt;dyn BaseTrait + AutoTrait1 + ... AutoTraitN&lt;/code&gt; . &lt;code&gt;BaseTrait&lt;/code&gt; 은 하나만 사용할 수 있으므로 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a5b87227107115d71da53fde65c7898c2f8a55f" translate="yes" xml:space="preserve">
          <source>The tail (elements in the vector after &lt;code&gt;range&lt;/code&gt;) is empty,</source>
          <target state="translated">꼬리 ( &lt;code&gt;range&lt;/code&gt; 후 벡터의 요소 )는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="018e9509238447c67e6197a11d4f5ea0ec53b22e" translate="yes" xml:space="preserve">
          <source>The tail expression of &lt;a href=&quot;expressions/block-expr&quot;&gt;block expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expressions/block-expr&quot;&gt;블록 표현&lt;/a&gt; 의 꼬리 표현 .</target>
        </trans-unit>
        <trans-unit id="8066bd3121283d3517acd4ab40b658c1a009321c" translate="yes" xml:space="preserve">
          <source>The temporary scopes for expressions in &lt;code&gt;let&lt;/code&gt; statements are sometimes &lt;em&gt;extended&lt;/em&gt; to the scope of the block containing the &lt;code&gt;let&lt;/code&gt; statement. This is done when the usual temporary scope would be too small, based on certain syntactic rules. For example:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 문 에있는 식의 임시 범위 는 때때로 &lt;code&gt;let&lt;/code&gt; 문을 포함하는 블록의 범위로 &lt;em&gt;확장&lt;/em&gt; 됩니다 . 특정 구문 규칙에 따라 일반적인 임시 범위가 너무 작을 때 수행됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="c615f1f00b080ca7312a1e8d344f8e1a91bfada3" translate="yes" xml:space="preserve">
          <source>The test shows that when we call &lt;code&gt;shoes_in_my_size&lt;/code&gt;, we get back only shoes that have the same size as the value we specified.</source>
          <target state="translated">테스트 결과 &lt;code&gt;shoes_in_my_size&lt;/code&gt; 를 호출하면 지정한 값과 동일한 크기의 신발 만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6d51660220a74ee89098ef8ef16d38d84170be2b" translate="yes" xml:space="preserve">
          <source>The text &lt;code&gt;Dropping CustomSmartPointer with data `some data`!&lt;/code&gt; is printed between the &lt;code&gt;CustomSmartPointer created.&lt;/code&gt; and &lt;code&gt;CustomSmartPointer dropped before the end of main.&lt;/code&gt; text, showing that the &lt;code&gt;drop&lt;/code&gt; method code is called to drop &lt;code&gt;c&lt;/code&gt; at that point.</source>
          <target state="translated">&lt;code&gt;Dropping CustomSmartPointer with data `some data`!&lt;/code&gt; 텍스트 ! &lt;code&gt;CustomSmartPointer created.&lt;/code&gt; 된 CustomSmartPointer 사이에 인쇄 됩니다. 및 &lt;code&gt;CustomSmartPointer dropped before the end of main.&lt;/code&gt; 텍스트는 것을 보여주는 &lt;code&gt;drop&lt;/code&gt; 방법 코드 드롭이라고 &lt;code&gt;c&lt;/code&gt; 그 시점에서.</target>
        </trans-unit>
        <trans-unit id="c9d885657469b7761a884865d71e05fd15d67a2e" translate="yes" xml:space="preserve">
          <source>The text of this string is stored directly in the program&amp;rsquo;s binary, which is always available. Therefore, the lifetime of all string literals is &lt;code&gt;'static&lt;/code&gt;.</source>
          <target state="translated">이 문자열의 텍스트는 프로그램 바이너리에 직접 저장되며 항상 사용 가능합니다. 따라서 모든 문자열 리터럴의 수명은 &lt;code&gt;'static&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a2418c922b0dbbb7a6749b73d736e8d2a5be9d0c" translate="yes" xml:space="preserve">
          <source>The third argument is a function called if a panic occurs. This function takes the data pointer and a pointer to the target-specific exception object that was caught. For more information see the compiler's source as well as std's catch implementation.</source>
          <target state="translated">세 번째 인수는 패닉이 발생하면 호출되는 함수입니다. 이 함수는 데이터 포인터와 포착 된 대상 특정 예외 개체에 대한 포인터를받습니다. 자세한 내용은 컴파일러의 소스와 std의 catch 구현을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bb9a02cbbbeece965fc06bf102b3dfcc209b80a8" translate="yes" xml:space="preserve">
          <source>The third case is trickier: Rust will also coerce a mutable reference to an immutable one. But the reverse is &lt;em&gt;not&lt;/em&gt; possible: immutable references will never coerce to mutable references. Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn&amp;rsquo;t compile). Converting one mutable reference to one immutable reference will never break the borrowing rules. Converting an immutable reference to a mutable reference would require that the initial immutable reference is the only immutable reference to that data, but the borrowing rules don&amp;rsquo;t guarantee that. Therefore, Rust can&amp;rsquo;t make the assumption that converting an immutable reference to a mutable reference is possible.</source>
          <target state="translated">세 번째 경우는 더 까다 롭습니다. Rust는 또한 변경 불가능한 참조에 대한 변경 가능한 참조를 강제합니다. 그러나 그 반대는 &lt;em&gt;불가능&lt;/em&gt; 합니다. 불변 참조는 절대로 변경 가능한 참조로 강제되지 않습니다. 차용 규칙 때문에 변경 가능한 참조가있는 경우 변경 가능한 참조는 해당 데이터에 대한 유일한 참조 여야합니다 (그렇지 않으면 프로그램이 컴파일되지 않습니다). 하나의 변경 가능한 참조를 하나의 변경 불가능한 참조로 변환하는 것은 차용 규칙을 위반하지 않습니다. 변경 불가능한 참조를 변경 가능한 참조로 변환하려면 초기 변경 불가능한 참조가 해당 데이터에 대한 유일한 변경 불가능한 참조 여야하지만 차용 규칙은이를 보장하지 않습니다. 따라서 Rust는 변경 불가능한 참조를 변경 가능한 참조로 변환하는 것이 가능하다고 가정 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f9782d2dad9c654fee52ed918f0366cbe2abfa6a" translate="yes" xml:space="preserve">
          <source>The third case is trickier: Rust will also coerce a mutable reference to an immutable one. But the reverse is &lt;em&gt;not&lt;/em&gt; possible: immutable references will never coerce to mutable references. Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn&amp;rsquo;t compile). Converting one mutable reference to one immutable reference will never break the borrowing rules. Converting an immutable reference to a mutable reference would require that there is only one immutable reference to that data, and the borrowing rules don&amp;rsquo;t guarantee that. Therefore, Rust can&amp;rsquo;t make the assumption that converting an immutable reference to a mutable reference is possible.</source>
          <target state="translated">세 번째 경우는 더 까다 롭습니다. Rust는 변경 불가능한 참조에 대해 변경 가능한 참조를 강제합니다. 그러나 그 반대는 &lt;em&gt;불가능&lt;/em&gt; 합니다. 불변 참조는 절대 변경 불가능한 참조로 강제되지 않습니다. 차용 규칙으로 인해 변경 가능한 참조가있는 경우 해당 변경 가능한 참조는 해당 데이터에 대한 유일한 참조 여야합니다 (그렇지 않으면 프로그램이 컴파일되지 않음). 하나의 변경 가능한 참조를 하나의 변경 불가능한 참조로 변환해도 절대 차용 규칙을 위반하지 않습니다. 변경 불가능한 참조를 변경 가능한 참조로 변환하려면 해당 데이터에 대한 변경 불가능한 참조가 하나만 있어야하며 차용 규칙은이를 보증하지 않습니다. 따라서 Rust는 불변 참조를 변경 가능한 참조로 변환 할 수 있다고 가정 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="25bc1d6b7d2fd810584a49b63e54dae85fbc7654" translate="yes" xml:space="preserve">
          <source>The third invariant says that when we have a complex NT that can match two or more copies of the same thing with no separation in between, it must be permissible for them to be placed next to each other as per the first invariant. This invariant also requires they be nonempty, which eliminates a possible ambiguity.</source>
          <target state="translated">세 번째 불변은 우리가 분리하지 않고 같은 사물의 둘 이상의 사본과 일치 할 수있는 복잡한 NT를 가질 때, 첫 번째 불변에 따라 서로 옆에 위치하는 것이 허용되어야한다고 말합니다. 이 불변은 또한 비어 있지 않아야하므로 가능한 모호성을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="6858985d6a527c37bd8cd37f82674daea04d146f" translate="yes" xml:space="preserve">
          <source>The third pointer is a target-specific data pointer which is filled in with the specifics of the exception that occurred. For examples on Unix platforms this is a &lt;code&gt;*mut *mut T&lt;/code&gt; which is filled in by the compiler and on MSVC it's &lt;code&gt;*mut [usize; 2]&lt;/code&gt;. For more information see the compiler's source as well as std's catch implementation.</source>
          <target state="translated">세 번째 포인터는 발생한 예외의 세부 사항으로 채워지는 대상별 데이터 포인터입니다. 유닉스 플랫폼에 대한 예제는 &lt;code&gt;*mut *mut T&lt;/code&gt; 이며, 컴파일러에 의해 채워지고 MSVC에서는 &lt;code&gt;*mut [usize; 2]&lt;/code&gt; . 자세한 정보는 컴파일러의 소스와 std의 catch 구현을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="af84a0e541b5cb8aad0df743eb686112ab5e9865" translate="yes" xml:space="preserve">
          <source>The third problem is that we&amp;rsquo;ve used &lt;code&gt;expect&lt;/code&gt; to print an error message when reading the file fails, but the error message just prints &lt;code&gt;Something went wrong reading the file&lt;/code&gt;. Reading a file can fail in a number of ways: for example, the file could be missing, or we might not have permission to open it. Right now, regardless of the situation, we&amp;rsquo;d print the &lt;code&gt;Something went wrong reading the file&lt;/code&gt; error message, which wouldn&amp;rsquo;t give the user any information!</source>
          <target state="translated">세 번째 문제는 우리가 사용했던 것입니다 &lt;code&gt;expect&lt;/code&gt; 파일을 읽는 것은 실패 할 때 오류 메시지를 인쇄 할 수 있지만 오류 메시지가 바로 인쇄 &lt;code&gt;Something went wrong reading the file&lt;/code&gt; . 파일 읽기는 여러 가지 방법으로 실패 할 수 있습니다. 예를 들어 파일이 없거나 파일을 열 수있는 권한이 없을 수 있습니다. 현재 상황에 관계없이 &lt;code&gt;Something went wrong reading the file&lt;/code&gt; 오류 메시지를 읽는 데 오류가 발생하여 사용자에게 정보가 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f9f5c0bd316756e98b375cf7ab85326d6fd86b72" translate="yes" xml:space="preserve">
          <source>The third rule is if there are multiple input lifetime parameters, but one of them is &lt;code&gt;&amp;amp;self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self&lt;/code&gt; because this is a method, the lifetime of &lt;code&gt;self&lt;/code&gt; is assigned to all output lifetime parameters. This third rule makes methods much nicer to read and write because fewer symbols are necessary.</source>
          <target state="translated">세 번째 규칙은 여러 입력 수명 매개 변수가있는 경우 방법 중 하나 이기 때문에이 매개 변수 중 하나는 &lt;code&gt;&amp;amp;self&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 이며, &lt;code&gt;self&lt;/code&gt; 수명은 모든 출력 수명 매개 변수에 지정됩니다. 이 세 번째 규칙은 더 적은 수의 기호가 필요하기 때문에 메소드를 읽고 쓰는 것이 훨씬 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c69636ef08912707db1c3ff91b55a817a8ac72a9" translate="yes" xml:space="preserve">
          <source>The thread may sleep longer than the duration specified due to scheduling specifics or platform-dependent functionality. It will never sleep less.</source>
          <target state="translated">스케줄링 세부 사항 또는 플랫폼 종속 기능으로 인해 스레드가 지정된 지속 시간보다 더 오래 휴면 상태 일 수 있습니다. 결코 잠들지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd58c0bda6dec6815740b7eed1b811cfbd96ccbb" translate="yes" xml:space="preserve">
          <source>The thread name is provided to the OS where applicable (e.g., &lt;code&gt;pthread_setname_np&lt;/code&gt; in unix-like platforms).</source>
          <target state="translated">해당하는 경우 스레드 이름이 OS에 제공됩니다 (예 : 유닉스 계열 플랫폼의 경우 &lt;code&gt;pthread_setname_np&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3218fca211a825167101461324b25d4344214224" translate="yes" xml:space="preserve">
          <source>The threading model</source>
          <target state="translated">스레딩 모델</target>
        </trans-unit>
        <trans-unit id="2518c4f037fbaea8573cb319d8682ea0e18ad153" translate="yes" xml:space="preserve">
          <source>The three forms of iteration</source>
          <target state="translated">세 가지 형태의 반복</target>
        </trans-unit>
        <trans-unit id="6e441e5631d84f73392a981b4df2ae8555997336" translate="yes" xml:space="preserve">
          <source>The three kinds of procedural macros (custom derive, attribute-like, and function-like) all work in a similar fashion.</source>
          <target state="translated">세 가지 종류의 절차 적 매크로 (사용자 지정 파생, 특성 유사 및 기능 유사)는 모두 비슷한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d7a7ac48a6db407723719df4ec95a88c69119a40" translate="yes" xml:space="preserve">
          <source>The three sections of output include the unit tests, the integration test, and the doc tests. The first section for the unit tests is the same as we&amp;rsquo;ve been seeing: one line for each unit test (one named &lt;code&gt;internal&lt;/code&gt; that we added in Listing 11-12) and then a summary line for the unit tests.</source>
          <target state="translated">세 가지 출력 섹션에는 단위 테스트, 통합 테스트 및 문서 테스트가 포함됩니다. 단위 테스트의 첫 번째 섹션 은 살펴본 것과 동일합니다. 각 단위 테스트에 대해 한 줄 ( 목록 11-12에서 추가 한 &lt;code&gt;internal&lt;/code&gt; 이라는 이름의 줄)과 단위 테스트에 대한 요약 줄입니다.</target>
        </trans-unit>
        <trans-unit id="779ae776bee7c2504118b220c1641bc64af7f7ac" translate="yes" xml:space="preserve">
          <source>The time complexity degrades if elements are pushed in predominantly ascending order. In the worst case, elements are pushed in ascending sorted order and the amortized cost per push is &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)) against a heap containing &lt;em&gt;n&lt;/em&gt; elements.</source>
          <target state="translated">요소가 주로 오름차순으로 푸시되면 시간 복잡성이 저하됩니다. 최악의 경우 요소는 오름차순으로 푸시되고 푸시 당 상각 된 비용은 &lt;em&gt;n&lt;/em&gt; 요소를 포함하는 힙에 대해 &lt;em&gt;O&lt;/em&gt; (log ( &lt;em&gt;n&lt;/em&gt; )) 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6df380516e9cdddf51f2d5d2da6e443a2e517824" translate="yes" xml:space="preserve">
          <source>The time complexity degrades if elements are pushed in predominantly ascending order. In the worst case, elements are pushed in ascending sorted order and the amortized cost per push is O(log n) against a heap containing &lt;em&gt;n&lt;/em&gt; elements.</source>
          <target state="translated">요소가 주로 오름차순으로 푸시되면 시간 복잡성이 저하됩니다. 최악의 경우 요소는 오름차순으로 정렬되며 푸시 당 상각 비용은 &lt;em&gt;n 개의&lt;/em&gt; 요소가 포함 된 힙에 대해 O (log n) 입니다.</target>
        </trans-unit>
        <trans-unit id="7075cd0ebc9560a0210fd04b57fb94c1b2316eda" translate="yes" xml:space="preserve">
          <source>The tokens that can begin a type are, as of this writing, {&lt;code&gt;(&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;\*&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, lifetimes, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;::&lt;/code&gt;, any non-keyword identifier, &lt;code&gt;super&lt;/code&gt;, &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;Self&lt;/code&gt;, &lt;code&gt;extern&lt;/code&gt;, &lt;code&gt;crate&lt;/code&gt;, &lt;code&gt;$crate&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;impl&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt;, &lt;code&gt;unsafe&lt;/code&gt;, &lt;code&gt;typeof&lt;/code&gt;, &lt;code&gt;dyn&lt;/code&gt;}, although this list may not be complete because people won't always remember to update the appendix when new ones are added.</source>
          <target state="translated">유형을 시작할 수있는 토큰은이 글을 쓰는 시점에서 { &lt;code&gt;(&lt;/code&gt; , &lt;code&gt;[&lt;/code&gt; , &lt;code&gt;!&lt;/code&gt; , &lt;code&gt;\*&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; , lifes, &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;::&lt;/code&gt; , 키워드가 아닌 식별자, &lt;code&gt;super&lt;/code&gt; , &lt;code&gt;self&lt;/code&gt; , &lt;code&gt;Self&lt;/code&gt; , &lt;code&gt;extern&lt;/code&gt; , &lt;code&gt;crate&lt;/code&gt; , &lt;code&gt;$crate&lt;/code&gt; , &lt;code&gt;_&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;impl&lt;/code&gt; , &lt;code&gt;fn&lt;/code&gt; , &lt;code&gt;unsafe&lt;/code&gt; , &lt;code&gt;typeof&lt;/code&gt; , &lt;code&gt;dyn&lt;/code&gt; } 새 목록이 추가 될 때 항상 부록을 업데이트하는 것을 기억하지 않기 때문에이 목록이 완전하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d918eb4366eadb0401bfe8b5fc6b1b9ce9e5b76" translate="yes" xml:space="preserve">
          <source>The top-level &lt;em&gt;Cargo.lock&lt;/em&gt; now contains information about the dependency of &lt;code&gt;add-one&lt;/code&gt; on &lt;code&gt;rand&lt;/code&gt;. However, even though &lt;code&gt;rand&lt;/code&gt; is used somewhere in the workspace, we can&amp;rsquo;t use it in other crates in the workspace unless we add &lt;code&gt;rand&lt;/code&gt; to their &lt;em&gt;Cargo.toml&lt;/em&gt; files as well. For example, if we add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;adder/src/main.rs&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; crate, we&amp;rsquo;ll get an error:</source>
          <target state="translated">최상위 &lt;em&gt;Cargo.lock&lt;/em&gt; 에는 이제 &lt;code&gt;rand&lt;/code&gt; 에 대한 &lt;code&gt;add-one&lt;/code&gt; 의 종속성에 대한 정보가 포함 됩니다. 그러나 &lt;code&gt;rand&lt;/code&gt; 가 작업 공간 어딘가에 사용 되더라도 &lt;code&gt;rand&lt;/code&gt; 를 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일에 랜드 를 추가하지 않으면 작업 공간의 다른 상자에서 사용할 수 없습니다 . 예를 들어 &lt;code&gt;use rand;&lt;/code&gt; 추가 하면; &lt;code&gt;adder&lt;/code&gt; 상자 의 &lt;em&gt;adder / src / main.rs&lt;/em&gt; 파일에 오류가 발생합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c0d4e33f5ea540060f03c5345b86c179052a0077" translate="yes" xml:space="preserve">
          <source>The top-level &lt;em&gt;Cargo.lock&lt;/em&gt; now contains information about the dependency of &lt;code&gt;add-one&lt;/code&gt; on &lt;code&gt;rand&lt;/code&gt;. However, even though &lt;code&gt;rand&lt;/code&gt; is used somewhere in the workspace, we can&amp;rsquo;t use it in other crates in the workspace unless we add &lt;code&gt;rand&lt;/code&gt; to their &lt;em&gt;Cargo.toml&lt;/em&gt; files as well. For example, if we add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;adder/src/main.rs&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; package, we&amp;rsquo;ll get an error:</source>
          <target state="translated">이제 최상위 &lt;em&gt;Cargo.lock&lt;/em&gt; 에 &lt;code&gt;rand&lt;/code&gt; 에 대한 &lt;code&gt;add-one&lt;/code&gt; 의 종속성에 대한 정보가 포함 됩니다. 그러나 &lt;code&gt;rand&lt;/code&gt; 가 작업 공간의 어딘가에서 사용 되더라도 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일에 &lt;code&gt;rand&lt;/code&gt; 를 추가하지 않는 한 작업 공간의 다른 상자에서 사용할 수 없습니다 . 예를 들어, 우리가 추가하면 &lt;code&gt;use rand;&lt;/code&gt; &lt;code&gt;adder&lt;/code&gt; 패키지 의 &lt;em&gt;adder / src / main.rs&lt;/em&gt; 파일에 오류가 발생합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad3286fb14b7fd80e70223a9fcdf3dbb91a27203" translate="yes" xml:space="preserve">
          <source>The total size &lt;code&gt;len * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;. See the safety documentation of &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">슬라이스 의 총 크기 &lt;code&gt;len * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 는 &lt;code&gt;isize::MAX&lt;/code&gt; 보다 크지 않아야 합니다. &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;pointer::offset&lt;/code&gt; &lt;/a&gt; 의 안전 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb4d3d21f95395d566b73337877fe60f19b91950" translate="yes" xml:space="preserve">
          <source>The total size &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;. See the safety documentation of &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 의 총 크기 ptr.len () * mem :: size_of :: &amp;lt;T&amp;gt; () 는 &lt;code&gt;isize::MAX&lt;/code&gt; 보다 크지 않아야 합니다. &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;pointer::offset&lt;/code&gt; &lt;/a&gt; 의 안전 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f198377d0780cd2ae0fe23c39d58fa6a11c3ce1b" translate="yes" xml:space="preserve">
          <source>The total size &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;. See the safety documentation of &lt;a href=&quot;primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 의 총 크기 ptr.len () * mem :: size_of :: &amp;lt;T&amp;gt; () 는 &lt;code&gt;isize::MAX&lt;/code&gt; 보다 크지 않아야 합니다. &lt;a href=&quot;primitive.pointer#method.offset&quot;&gt; &lt;code&gt;pointer::offset&lt;/code&gt; &lt;/a&gt; 의 안전 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c818e1dc9d477cbb1ce03a32e397d907f841e91" translate="yes" xml:space="preserve">
          <source>The total size of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;&lt;strong&gt;bytes&lt;/strong&gt; in memory. See the safety documentation of &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">슬라이스의 총 크기는 메모리의 &lt;code&gt;isize::MAX&lt;/code&gt; &lt;strong&gt;바이트&lt;/strong&gt; 보다 크지 않아야 합니다. &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;pointer::offset&lt;/code&gt; &lt;/a&gt; 의 안전 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4da1db74e1e609ac8cd961cdfb0fa46bfc3d2c9d" translate="yes" xml:space="preserve">
          <source>The trait also provides convenience methods like &lt;a href=&quot;#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt;, which calls &lt;code&gt;write&lt;/code&gt; in a loop until its entire input has been written.</source>
          <target state="translated">이 특성은 또한 전체 입력이 작성 될 때까지 루프에서 &lt;code&gt;write&lt;/code&gt; 를 호출하는 &lt;a href=&quot;#method.write_all&quot;&gt; &lt;code&gt;write_all&lt;/code&gt; &lt;/a&gt; 과 같은 편리한 메소드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="903fc77fd3444aa853b4918c8904a108213ce8a6" translate="yes" xml:space="preserve">
          <source>The trait also provides convenience methods like &lt;a href=&quot;trait.write#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt;, which calls &lt;code&gt;write&lt;/code&gt; in a loop until its entire input has been written.</source>
          <target state="translated">&lt;a href=&quot;trait.write#method.write_all&quot;&gt; &lt;code&gt;write_all&lt;/code&gt; &lt;/a&gt; 또한 전체 입력이 기록 될 때까지 루프에서 &lt;code&gt;write&lt;/code&gt; 를 호출하는 write_all 과 같은 편리한 메서드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="ddef280ba8303b75d43b99adadcdec8f8b461c8f" translate="yes" xml:space="preserve">
          <source>The trait being implemented is defined in the same crate.</source>
          <target state="translated">구현되는 특성은 동일한 상자에서 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="fe160012593c71ba4d94a64501b55cb584b3c84d" translate="yes" xml:space="preserve">
          <source>The trait cannot contain associated constants</source>
          <target state="translated">특성은 연관된 상수를 포함 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="f49c4617e26c7a90e7ceb5715737675232c71e5c" translate="yes" xml:space="preserve">
          <source>The trait cannot require &lt;code&gt;Self: Sized&lt;/code&gt;</source>
          <target state="translated">특성은 &lt;code&gt;Self: Sized&lt;/code&gt; 요구할 수 없습니다 : 크기</target>
        </trans-unit>
        <trans-unit id="3bbcc07233474a5558580dca4726567afce0f2c1" translate="yes" xml:space="preserve">
          <source>The trait cannot use &lt;code&gt;Self&lt;/code&gt; as a type parameter in the supertrait listing</source>
          <target state="translated">특성은 상위 특성 목록에서 &lt;code&gt;Self&lt;/code&gt; 를 유형 매개 변수로 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="6c46ccc8f602f9dc98f8190aa7e9cb78c7a8a015" translate="yes" xml:space="preserve">
          <source>The trait implemented by builtin generator types.</source>
          <target state="translated">내장 생성기 유형으로 구현 된 특성.</target>
        </trans-unit>
        <trans-unit id="0c6838569af8d3e59a65e8aec127e2d3a1e1e919" translate="yes" xml:space="preserve">
          <source>The trait is known as the &lt;em&gt;implemented trait&lt;/em&gt;. The implementing type implements the implemented trait.</source>
          <target state="translated">이 특성은 &lt;em&gt;구현 된 특성이라고&lt;/em&gt; 합니다. 구현 유형은 구현 된 특성을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="8cf3ab6548fb883dab5c1d88de8c77fdb3ccf054" translate="yes" xml:space="preserve">
          <source>The trait is marked unsafe because the indices returned by the &lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; methods are required to lie on valid utf8 boundaries in the haystack. This enables consumers of this trait to slice the haystack without additional runtime checks.</source>
          <target state="translated">&lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt; 메서드에 의해 반환 된 인덱스 는 건초 더미에서 유효한 utf8 경계에 있어야 하기 때문에 특성은 안전하지 않은 것으로 표시 됩니다. 이를 통해이 특성의 소비자는 추가 런타임 검사없이 건초 더미를 슬라이스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="478884f7bada94b695fbee645bd59c060678235f" translate="yes" xml:space="preserve">
          <source>The trait is marked unsafe because the indices returned by the &lt;code&gt;next()&lt;/code&gt; methods are required to lie on valid utf8 boundaries in the haystack. This enables consumers of this trait to slice the haystack without additional runtime checks.</source>
          <target state="translated">&lt;code&gt;next()&lt;/code&gt; 메소드가 리턴 한 색인 이 건초 더미에서 유효한 utf8 경계에 있어야 하기 때문에 특성이 안전하지 않은 것으로 표시 됩니다. 이를 통해이 특성의 소비자는 추가 런타임 검사없이 건초 더미를 슬라이스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d63a097c314f3198ade51464ed8a948cd1d46d3" translate="yes" xml:space="preserve">
          <source>The trait is marked unsafe in order to restrict implementors to fixed-size arrays. User of this trait can assume that implementors have the exact layout in memory of a fixed size array (for example, for unsafe initialization).</source>
          <target state="translated">특성을 고정 크기 배열로 제한하기 위해 특성이 안전하지 않은 것으로 표시됩니다. 이 특성의 사용자는 구현자가 고정 크기 배열의 메모리에 정확한 레이아웃이 있다고 가정 할 수 있습니다 (예 : 안전하지 않은 초기화).</target>
        </trans-unit>
        <trans-unit id="ffd4884c0b4bf389a086599eb28e009d3c721bad" translate="yes" xml:space="preserve">
          <source>The trait itself acts as a builder for an associated &lt;a href=&quot;trait.searcher&quot;&gt;&lt;code&gt;Searcher&lt;/code&gt;&lt;/a&gt; type, which does the actual work of finding occurrences of the pattern in a string.</source>
          <target state="translated">특성 자체는 연관된 &lt;a href=&quot;trait.searcher&quot;&gt; &lt;code&gt;Searcher&lt;/code&gt; &lt;/a&gt; 유형 의 빌더 역할을 하며 문자열에서 패턴의 발생을 찾는 실제 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="bf58bfdb142c3e3e2fca00b9412242993f764d14" translate="yes" xml:space="preserve">
          <source>The trait itself acts as a builder for an associated &lt;code&gt;Searcher&lt;/code&gt; type, which does the actual work of finding occurrences of the pattern in a string.</source>
          <target state="translated">특성 자체는 문자열에서 패턴의 발생을 찾는 실제 작업을 수행 하는 연관된 &lt;code&gt;Searcher&lt;/code&gt; 유형 의 빌더 역할을 합니다.</target>
        </trans-unit>
        <trans-unit id="4f44d782a6ca223ce6d84156fccfcf74f2f98110" translate="yes" xml:space="preserve">
          <source>The trait with a supertrait is called a &lt;strong&gt;subtrait&lt;/strong&gt; of its supertrait.</source>
          <target state="translated">초 특성이있는 특성을 초 특성의 &lt;strong&gt;하위&lt;/strong&gt; 특성이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="d7357f4482763332c4dcdb5f743346a154d2e9c6" translate="yes" xml:space="preserve">
          <source>The traits in &lt;a href=&quot;../std/ops/index&quot;&gt;&lt;code&gt;std::ops&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/cmp/index&quot;&gt;&lt;code&gt;std::cmp&lt;/code&gt;&lt;/a&gt; are used to overload &lt;a href=&quot;expressions/operator-expr&quot;&gt;operators&lt;/a&gt;, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;indexing expressions&lt;/a&gt; and &lt;a href=&quot;expressions/call-expr&quot;&gt;call expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../std/ops/index&quot;&gt; &lt;code&gt;std::ops&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../std/cmp/index&quot;&gt; &lt;code&gt;std::cmp&lt;/code&gt; &lt;/a&gt; 의 특성은 &lt;a href=&quot;expressions/operator-expr&quot;&gt;연산자&lt;/a&gt; , &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;인덱싱 표현식&lt;/a&gt; 및 &lt;a href=&quot;expressions/call-expr&quot;&gt;호출 표현식&lt;/a&gt; 을 오버로드하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ada4715a52a3666c1e6ea1e317fd6cc2974a5b0" translate="yes" xml:space="preserve">
          <source>The traits in &lt;a href=&quot;../std/ops/index&quot;&gt;&lt;code&gt;std::ops&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/cmp/index&quot;&gt;&lt;code&gt;std::cmp&lt;/code&gt;&lt;/a&gt; are used to overload &lt;a href=&quot;expressions/operator-expr&quot;&gt;operators&lt;/a&gt;, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;indexing expressions&lt;/a&gt;, and &lt;a href=&quot;expressions/call-expr&quot;&gt;call expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../std/ops/index&quot;&gt; &lt;code&gt;std::ops&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../std/cmp/index&quot;&gt; &lt;code&gt;std::cmp&lt;/code&gt; &lt;/a&gt; 의 특성은 &lt;a href=&quot;expressions/operator-expr&quot;&gt;연산자&lt;/a&gt; 오버로드 , &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;식 인덱싱&lt;/a&gt; 및 &lt;a href=&quot;expressions/call-expr&quot;&gt;식 호출에 사용&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="f43292c5d9ba5055790b8cc673c3ce1d90efd4b3" translate="yes" xml:space="preserve">
          <source>The traits in this module are often used as trait bounds for generic functions such that to arguments of multiple types are supported. See the documentation of each trait for examples.</source>
          <target state="translated">이 모듈의 특성은 종종 여러 유형의 인수에 대한 지원이 가능하도록 일반 함수의 특성 경계로 사용됩니다. 예제는 각 특성의 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bbf2160d65d5756f9a6fd20c174d5b77d26006ee" translate="yes" xml:space="preserve">
          <source>The traits in this module provide a way to convert from one type to another type. Each trait serves a different purpose:</source>
          <target state="translated">이 모듈의 특성은 한 유형에서 다른 유형으로 변환하는 방법을 제공합니다. 각 특성은 다른 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="be87d5e421f146f48239b20f0b61521f853fc415" translate="yes" xml:space="preserve">
          <source>The transmitting end has a &lt;code&gt;send&lt;/code&gt; method that takes the value we want to send. The &lt;code&gt;send&lt;/code&gt; method returns a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type, so if the receiving end has already been dropped and there&amp;rsquo;s nowhere to send a value, the send operation will return an error. In this example, we&amp;rsquo;re calling &lt;code&gt;unwrap&lt;/code&gt; to panic in case of an error. But in a real application, we would handle it properly: return to Chapter 9 to review strategies for proper error handling.</source>
          <target state="translated">송신 측에는 송신 하고자하는 값을 취하는 &lt;code&gt;send&lt;/code&gt; 방법이 있습니다. &lt;code&gt;send&lt;/code&gt; 방법의 반환은 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 유형, 수신 측이 이미 삭제 된하고 값을 보낼 곳이 없다했다 그렇다면, 보내기 작업은 오류를 반환합니다. 이 예에서는 오류가 발생하면 &lt;code&gt;unwrap&lt;/code&gt; 을 패닉 상태로 호출 합니다. 그러나 실제 응용 프로그램에서는 제대로 처리합니다. 9 장으로 돌아가서 적절한 오류 처리 전략을 검토하십시오.</target>
        </trans-unit>
        <trans-unit id="358565a5dd8811594d3e7971e93dfbda2791693b" translate="yes" xml:space="preserve">
          <source>The tuple pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">튜플 패턴은 하위 패턴 중 하나가 refutable 일 때 refutable입니다.</target>
        </trans-unit>
        <trans-unit id="8b3273a21950fc06ce8b8962828961e34d0be457" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;gt;&lt;/code&gt; on their inner values.</source>
          <target state="translated">두 값은 내부 값에서 &lt;code&gt;&amp;gt;&lt;/code&gt; 를 호출하여 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="de2c6ddac182efa31cffea571db9b44146fe9838" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;gt;=&lt;/code&gt; on their inner values.</source>
          <target state="translated">두 값은 내부 값에서 &lt;code&gt;&amp;gt;=&lt;/code&gt; 를 호출하여 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c699eaaa968f03f7073bd19cfb4a4bc4c553e9a" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;lt;&lt;/code&gt; on their inner values.</source>
          <target state="translated">두 값은 내부 값에서 &lt;code&gt;&amp;lt;&lt;/code&gt; 를 호출하여 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="169dd7de97da6fed33fb4c7fffa1d0926634fd12" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;lt;=&lt;/code&gt; on their inner values.</source>
          <target state="translated">두 값은 내부 값에서 &lt;code&gt;&amp;lt;=&lt;/code&gt; 를 호출하여 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="4559f811138e10e2014d510114ff2517b250941f" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;cmp()&lt;/code&gt; on their inner values.</source>
          <target state="translated">두 값은 내부 값에서 &lt;code&gt;cmp()&lt;/code&gt; 를 호출하여 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="39163b76dc0823f8bfd4c0f4a8969c804a3f8075" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;partial_cmp()&lt;/code&gt; on their inner values.</source>
          <target state="translated">둘은 내부 값에서 &lt;code&gt;partial_cmp()&lt;/code&gt; 를 호출하여 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="a9f918beee4f5cf9d1253c5c05628d38cf96954a" translate="yes" xml:space="preserve">
          <source>The two configurations available are:</source>
          <target state="translated">사용 가능한 두 가지 구성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="450583e125671dcb6a167d6b29518dd2bf3867fb" translate="yes" xml:space="preserve">
          <source>The two kinds of declaration statements are item declarations and &lt;code&gt;let&lt;/code&gt; statements.</source>
          <target state="translated">두 가지 종류의 선언문은 항목 선언과 &lt;code&gt;let&lt;/code&gt; 문입니다.</target>
        </trans-unit>
        <trans-unit id="29e11129b6c15c504dcd359f5946098de2a818e8" translate="yes" xml:space="preserve">
          <source>The two main protocols involved in web servers are the &lt;em&gt;Hypertext Transfer Protocol&lt;/em&gt;&lt;em&gt;(HTTP)&lt;/em&gt; and the &lt;em&gt;Transmission Control Protocol&lt;/em&gt;&lt;em&gt;(TCP)&lt;/em&gt;. Both protocols are &lt;em&gt;request-response&lt;/em&gt; protocols, meaning a &lt;em&gt;client&lt;/em&gt; initiates requests and a &lt;em&gt;server&lt;/em&gt; listens to the requests and provides a response to the client. The contents of those requests and responses are defined by the protocols.</source>
          <target state="translated">웹 서버와 관련된 두 가지 주요 프로토콜은 &lt;em&gt;HTTP ( &lt;/em&gt;&lt;em&gt;Hypertext Transfer Protocol &lt;/em&gt;&lt;em&gt;)&lt;/em&gt; 와 &lt;em&gt;TCP ( &lt;/em&gt;&lt;em&gt;Transmission Control Protocol &lt;/em&gt;&lt;em&gt;)&lt;/em&gt; 입니다. 두 프로토콜 모두 &lt;em&gt;요청-응답&lt;/em&gt; 프로토콜입니다. 즉, &lt;em&gt;클라이언트&lt;/em&gt; 가 요청을 시작하고 &lt;em&gt;서버&lt;/em&gt; 가 요청을 수신하고 클라이언트에 응답을 제공합니다. 이러한 요청 및 응답의 내용은 프로토콜에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="203df10027d062d490c4fbf35780fe4d1eed13fd" translate="yes" xml:space="preserve">
          <source>The two most common ways to evaluate an iterator are to use a &lt;code&gt;for&lt;/code&gt; loop like this, or using the &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; method to produce a new collection.</source>
          <target state="translated">반복자를 평가하는 가장 일반적인 두 가지 방법은 이와 같은 &lt;code&gt;for&lt;/code&gt; 루프 를 사용 하거나 &lt;a href=&quot;trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 새 콜렉션을 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f0616989ceb9af09d65c6d30395a15645c3fb4ed" translate="yes" xml:space="preserve">
          <source>The two new lines are:</source>
          <target state="translated">새로운 두 줄은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e483fee205c9c53971b14b5a333e04a44a6db99b" translate="yes" xml:space="preserve">
          <source>The two pointed-to values may overlap. If the values do overlap, then the overlapping region of memory from &lt;code&gt;x&lt;/code&gt; will be used. This is demonstrated in the second example below.</source>
          <target state="translated">두 개의 지정된 값이 겹칠 수 있습니다. 값이 겹치면 &lt;code&gt;x&lt;/code&gt; 에서 겹치는 메모리 영역 이 사용됩니다. 아래 두 번째 예에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7540e3538a7ee2b354c6ad5eceba51e063d25c18" translate="yes" xml:space="preserve">
          <source>The two slices returned go from the start of the string slice to &lt;code&gt;mid&lt;/code&gt;, and from &lt;code&gt;mid&lt;/code&gt; to the end of the string slice.</source>
          <target state="translated">두 조각에 문자열 조각의 시작부터 이동 반환 &lt;code&gt;mid&lt;/code&gt; , 그리고에서 &lt;code&gt;mid&lt;/code&gt; 문자열 조각의 끝.</target>
        </trans-unit>
        <trans-unit id="643186e43b6d06589052d125f62e5365b9c9a558" translate="yes" xml:space="preserve">
          <source>The two threads continue alternating, but the main thread waits because of the call to &lt;code&gt;handle.join()&lt;/code&gt; and does not end until the spawned thread is finished.</source>
          <target state="translated">두 스레드는 계속 교대로 나타나지만 기본 스레드는 &lt;code&gt;handle.join()&lt;/code&gt; 호출로 인해 대기 하며 생성 된 스레드가 완료 될 때까지 끝나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6005b5c0e8b9fae85cf0f2f496cddef96188c2e3" translate="yes" xml:space="preserve">
          <source>The two values of the boolean type are written &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">부울 유형의 두 값은 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 로 작성 됩니다.</target>
        </trans-unit>
        <trans-unit id="8b6bd47b4f42af9e321626a41d3ac1a949889256" translate="yes" xml:space="preserve">
          <source>The type &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; produces a new pointer to the same allocation in the heap. When the last &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer to a given allocation is destroyed, the value stored in that allocation (often referred to as &quot;inner value&quot;) is also dropped.</source>
          <target state="translated">유형 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 유형의 값의 소유권 공유 제공 &lt;code&gt;T&lt;/code&gt; 힙 할당을. &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; 에서&lt;/a&gt;&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 을 호출하면 힙의 동일한 할당에 대한 새 포인터가 생성됩니다. 주어진 할당에 대한 마지막 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터가 삭제되면 해당 할당에 저장된 값 ( &quot;내부 값&quot;이라고도 함)도 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="372e682a79086a952e254015d9198d707b3497b2" translate="yes" xml:space="preserve">
          <source>The type &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; produces a new pointer to the same value in the heap. When the last &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer to a given value is destroyed, the pointed-to value is also destroyed.</source>
          <target state="translated">유형 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 유형의 값의 소유권 공유 제공 &lt;code&gt;T&lt;/code&gt; 힙 할당을. &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; 에서&lt;/a&gt;&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 을 호출하면 힙에서 동일한 값에 대한 새로운 포인터가 생성됩니다. 주어진 값에 대한 마지막 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터가 파괴되면 지정된 값도 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="061bd0bf671c2d672c454254d90151c86753f8be" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;code&gt;Arc&lt;/code&gt; produces a new &lt;code&gt;Arc&lt;/code&gt; instance, which points to the same allocation on the heap as the source &lt;code&gt;Arc&lt;/code&gt;, while increasing a reference count. When the last &lt;code&gt;Arc&lt;/code&gt; pointer to a given allocation is destroyed, the value stored in that allocation (often referred to as &quot;inner value&quot;) is also dropped.</source>
          <target state="translated">유형 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 유형의 값의 소유권 공유 제공 &lt;code&gt;T&lt;/code&gt; 힙 할당을. &lt;code&gt;Arc&lt;/code&gt; 에서&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 을 호출하면 참조 횟수를 늘리면서 소스 &lt;code&gt;Arc&lt;/code&gt; 와 동일한 힙 할당을 가리키는 새로운 &lt;code&gt;Arc&lt;/code&gt; 인스턴스가 생성 됩니다. 주어진 할당에 대한 마지막 &lt;code&gt;Arc&lt;/code&gt; 포인터가 삭제되면 해당 할당에 저장된 값 ( &quot;내부 값&quot;이라고도 함)도 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6e13391af6d4685735ce2468fa0b2df950149996" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;code&gt;Arc&lt;/code&gt; produces a new &lt;code&gt;Arc&lt;/code&gt; instance, which points to the same value on the heap as the source &lt;code&gt;Arc&lt;/code&gt;, while increasing a reference count. When the last &lt;code&gt;Arc&lt;/code&gt; pointer to a given value is destroyed, the pointed-to value is also destroyed.</source>
          <target state="translated">유형 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 유형의 값의 소유권 공유 제공 &lt;code&gt;T&lt;/code&gt; 힙 할당을. &lt;code&gt;Arc&lt;/code&gt; 에서&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 을 호출하면 새로운 &lt;code&gt;Arc&lt;/code&gt; 인스턴스가 생성 되는데,이 인스턴스는 힙에서 소스 &lt;code&gt;Arc&lt;/code&gt; 와 동일한 값을 가리키고 참조 횟수는 증가시킵니다. 주어진 값에 대한 마지막 &lt;code&gt;Arc&lt;/code&gt; 포인터가 파괴 될 때, 지정된 값 또한 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="c30f5ce28986d51c472e8b2cb793889a1cf9299e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Cow&lt;/code&gt; is a smart pointer providing clone-on-write functionality: it can enclose and provide immutable access to borrowed data, and clone the data lazily when mutation or ownership is required. The type is designed to work with general borrowed data via the &lt;code&gt;Borrow&lt;/code&gt; trait.</source>
          <target state="translated">&lt;code&gt;Cow&lt;/code&gt; 유형 은 쓰기시 복제 기능을 제공하는 스마트 포인터입니다. 차용 된 데이터에 대한 변경 및 액세스를 제공하고 돌연변이 또는 소유권이 필요한 경우 데이터를 느리게 복제 할 수 있습니다. 이 유형은 &lt;code&gt;Borrow&lt;/code&gt; 특성을 통해 빌린 일반 데이터를 처리하도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="9f7d7514bdc86a24a5ff52dd05fe5c13a9b5c0e6" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Item&lt;/code&gt; is a placeholder type, and the &lt;code&gt;next&lt;/code&gt; method&amp;rsquo;s definition shows that it will return values of type &lt;code&gt;Option&amp;lt;Self::Item&amp;gt;&lt;/code&gt;. Implementors of the &lt;code&gt;Iterator&lt;/code&gt; trait will specify the concrete type for &lt;code&gt;Item&lt;/code&gt;, and the &lt;code&gt;next&lt;/code&gt; method will return an &lt;code&gt;Option&lt;/code&gt; containing a value of that concrete type.</source>
          <target state="translated">&lt;code&gt;Item&lt;/code&gt; 형식 은 자리 표시 자 형식이며 &lt;code&gt;next&lt;/code&gt; 메서드 정의에서는 &lt;code&gt;Option&amp;lt;Self::Item&amp;gt;&lt;/code&gt; 형식의 값을 반환한다는 것을 보여줍니다 . 의 구현 &lt;code&gt;Iterator&lt;/code&gt; 특성은 대한 구체적인 유형을 지정합니다 &lt;code&gt;Item&lt;/code&gt; 하고 &lt;code&gt;next&lt;/code&gt; 방법은 반환 &lt;code&gt;Option&lt;/code&gt; 이 구체적인 유형의 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="b50c152c5140d221fbe925adaec14a20d6c4527c" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Self&lt;/code&gt; acts as an alias to the type of the current trait implementer, or &quot;receiver type&quot;. Besides the already mentioned &lt;code&gt;Self&lt;/code&gt;, &lt;code&gt;&amp;amp;Self&lt;/code&gt; and &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; valid receiver types, the following are also valid: &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;, &lt;code&gt;self: Rc&amp;lt;Self&amp;gt;&lt;/code&gt;, &lt;code&gt;self: Arc&amp;lt;Self&amp;gt;&lt;/code&gt;, and &lt;code&gt;self: Pin&amp;lt;P&amp;gt;&lt;/code&gt; (where P is one of the previous types except &lt;code&gt;Self&lt;/code&gt;). Note that &lt;code&gt;Self&lt;/code&gt; can also be the underlying implementing type, like &lt;code&gt;Foo&lt;/code&gt; in the following example:</source>
          <target state="translated">유형의 &lt;code&gt;Self&lt;/code&gt; 하여 현재 특성의 구현의 종류, 또는 &quot;수신기 유형&quot;에 대한 별칭으로 역할을합니다. 이미 언급 한 &lt;code&gt;Self&lt;/code&gt; , &lt;code&gt;&amp;amp;Self&lt;/code&gt; 및 &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; 유효한 수신자 유형 외에도 다음도 유효합니다. &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; , &lt;code&gt;self: Rc&amp;lt;Self&amp;gt;&lt;/code&gt; , &lt;code&gt;self: Arc&amp;lt;Self&amp;gt;&lt;/code&gt; 및 &lt;code&gt;self: Pin&amp;lt;P&amp;gt;&lt;/code&gt; (여기서 P는 &lt;code&gt;Self&lt;/code&gt; 를 제외한 이전 유형 중 하나입니다 . 참고 것을 &lt;code&gt;Self&lt;/code&gt; 또한 같은 기본 구현 형식이 될 수 있습니다 &lt;code&gt;Foo&lt;/code&gt; 다음 예제 :</target>
        </trans-unit>
        <trans-unit id="86f527297d32ae3d914332f31c2f8f0967b4e336" translate="yes" xml:space="preserve">
          <source>The type alias helps in two ways: it makes code easier to write &lt;em&gt;and&lt;/em&gt; it gives us a consistent interface across all of &lt;code&gt;std::io&lt;/code&gt;. Because it&amp;rsquo;s an alias, it&amp;rsquo;s just another &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, which means we can use any methods that work on &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; with it, as well as special syntax like the &lt;code&gt;?&lt;/code&gt; operator.</source>
          <target state="translated">이 쓰기에 코드를 쉽게 : 유형의 별명은 두 가지 방법으로 도움이 &lt;em&gt;및&lt;/em&gt; 그것은 우리 모두 일관된 인터페이스를 제공합니다 &lt;code&gt;std::io&lt;/code&gt; . 이 별칭이기 때문에, 그것은 또 다른의 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; , 우리가 어떤 방법을 사용할 수있는 수단이 그 일에 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 그뿐만 아니라 같은 특수 구문 &lt;code&gt;?&lt;/code&gt; 운영자.</target>
        </trans-unit>
        <trans-unit id="ea0e2aaa51d45e0a422d27f3c58e30936523ccce" translate="yes" xml:space="preserve">
          <source>The type annotation &lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; is needed here because it&amp;rsquo;s possible to &lt;code&gt;collect&lt;/code&gt; into many different data structures and Rust doesn&amp;rsquo;t know which you want unless you specify. For the parameters for the key and value types, however, we use underscores, and Rust can infer the types that the hash map contains based on the types of the data in the vectors.</source>
          <target state="translated">&lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; 타입 주석은 여기에 필요합니다. 많은 다른 데이터 구조 로 &lt;code&gt;collect&lt;/code&gt; 할 수 있고 Rust는 사용자가 지정하지 않으면 원하는 것을 알 수 없기 때문입니다. 그러나 키 및 값 유형에 대한 매개 변수의 경우 밑줄을 사용하며 Rust는 벡터의 데이터 유형에 따라 해시 맵에 포함 된 유형을 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19887ad86a95d19b831c6b68bb5aee99f3125dcd" translate="yes" xml:space="preserve">
          <source>The type annotation &lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; is needed here because it&amp;rsquo;s possible to &lt;code&gt;collect&lt;/code&gt; into many different data structures and Rust doesn&amp;rsquo;t know which you want unless you specify. For the parameters for the key and value types, however, we use underscores, and Rust can infer the types that the hash map contains based on the types of the data in the vectors. In Listing 8-21, the key type will be &lt;code&gt;String&lt;/code&gt; and the value type will be &lt;code&gt;i32&lt;/code&gt;, just as the types were in Listing 8-20.</source>
          <target state="translated">&lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; 타입 어노테이션 은 여기에 필요합니다. 왜냐하면 다양한 데이터 구조 로 &lt;code&gt;collect&lt;/code&gt; 이 가능 하고 사용자가 지정하지 않는 한 Rust는 원하는 것이 무엇인지 알지 못하기 때문입니다. 그러나 키 및 값 유형에 대한 매개 변수의 경우 밑줄을 사용하고 Rust는 벡터의 데이터 유형에 따라 해시 맵에 포함 된 유형을 추론 할 수 있습니다. 목록 8-21에서 키 유형은 &lt;code&gt;String&lt;/code&gt; 이고 값 유형은 목록 8-20 에서처럼 유형이 &lt;code&gt;i32&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fdf52c33ab9420faf47eea0ae86189b509c83d56" translate="yes" xml:space="preserve">
          <source>The type definition contains some field whose type requires an outlives annotation. Outlives annotations (e.g., &lt;code&gt;T: 'a&lt;/code&gt;) are used to guarantee that all the data in T is valid for at least the lifetime &lt;code&gt;'a&lt;/code&gt;. This scenario most commonly arises when the type contains an associated type reference like &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt;, as shown in the previous code.</source>
          <target state="translated">유형 정의에는 유형이 수명 주석이 필요한 일부 필드가 포함되어 있습니다. Outlives 주석 (예 &lt;code&gt;T: 'a&lt;/code&gt; )은 T의 모든 데이터가 적어도 수명 &lt;code&gt;'a&lt;/code&gt; 동안 유효 함을 보장하는 데 사용됩니다 . 이 시나리오 는 이전 코드에 표시된 것처럼 형식에 &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt; 과 같은 관련 형식 참조가 포함되어있을 때 가장 일반적으로 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="06a3cc90dfa59efcb3be0ad0da5e31c3b001a903" translate="yes" xml:space="preserve">
          <source>The type definition contains some field whose type requires an outlives annotation. Outlives annotations (e.g., &lt;code&gt;T: 'a&lt;/code&gt;) are used to guarantee that all the data in T is valid for at least the lifetime &lt;code&gt;'a&lt;/code&gt;. This scenario most commonly arises when the type contains an associated type reference like &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt;, as shown in this example:</source>
          <target state="translated">유형 정의에는 유형에 수명 주석이 필요한 일부 필드가 포함됩니다. 수명이 다한 주석 (예 &lt;code&gt;T: 'a&lt;/code&gt; )은 T의 모든 데이터가 적어도 수명 &lt;code&gt;'a&lt;/code&gt; 동안 유효하다는 것을 보장하는 데 사용됩니다 . 이 시나리오 는이 예에 표시된 것처럼 유형에 &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt; 과 같은 연관된 유형 참조가 포함 된 경우에 가장 일반적으로 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="fc99bc0924bfaeb5da14796b8d2b7f81fb11367e" translate="yes" xml:space="preserve">
          <source>The type does not fulfill the required lifetime.</source>
          <target state="translated">유형이 필요한 수명을 충족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e9c0bf21d5e45e81b33f072a97367bb2e667f29" translate="yes" xml:space="preserve">
          <source>The type must have the &lt;code&gt;Sync&lt;/code&gt; trait bound to allow thread-safe access.</source>
          <target state="translated">스레드 안전 액세스를 허용 하려면 유형에 &lt;code&gt;Sync&lt;/code&gt; 특성이 바인딩되어 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="8abd0fc7da623f26ad9fecceeea94f5bfc1f633a" translate="yes" xml:space="preserve">
          <source>The type name used is not in scope.</source>
          <target state="translated">사용 된 유형 이름이 범위에 없습니다.</target>
        </trans-unit>
        <trans-unit id="89e2360bf1d9e23be29f6ad88e266a77e3f4f82f" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;guess&lt;/code&gt; in this code would have to be an integer &lt;em&gt;and&lt;/em&gt; a string, and Rust requires that &lt;code&gt;guess&lt;/code&gt; have only one type. So what does &lt;code&gt;continue&lt;/code&gt; return? How were we allowed to return a &lt;code&gt;u32&lt;/code&gt; from one arm and have another arm that ends with &lt;code&gt;continue&lt;/code&gt; in Listing 19-26?</source>
          <target state="translated">이 코드에서 &lt;code&gt;guess&lt;/code&gt; 유형은 정수 &lt;em&gt;와&lt;/em&gt; 문자열 이어야 하며 Rust는 &lt;code&gt;guess&lt;/code&gt; 한 유형 만 요구합니다 . 그래서 &lt;code&gt;continue&lt;/code&gt; 돌아 오는 것은 무엇 입니까? 우리는 어떻게 한 팔에서 &lt;code&gt;u32&lt;/code&gt; 를 반환하고 목록 19-26에서 &lt;code&gt;continue&lt;/code&gt; 끝나는 다른 팔을 가질 수 있었습니까?</target>
        </trans-unit>
        <trans-unit id="ae6cd25ffa500de06212f0c2207844d88b02a6be" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;s&lt;/code&gt; here is &lt;code&gt;&amp;amp;str&lt;/code&gt;: it&amp;rsquo;s a slice pointing to that specific point of the binary. This is also why string literals are immutable; &lt;code&gt;&amp;amp;str&lt;/code&gt; is an immutable reference.</source>
          <target state="translated">여기서 &lt;code&gt;s&lt;/code&gt; 의 유형 은 &lt;code&gt;&amp;amp;str&lt;/code&gt; 입니다. 바이너리의 특정 지점을 가리키는 슬라이스입니다. 이것이 바로 문자열 리터럴이 불변 인 이유이기도합니다. &lt;code&gt;&amp;amp;str&lt;/code&gt; 은 불변의 참조입니다.</target>
        </trans-unit>
        <trans-unit id="34ca2b2668ed637a52d925af5ee324f0385b2620" translate="yes" xml:space="preserve">
          <source>The type of a block is the type of the final expression, or &lt;code&gt;()&lt;/code&gt; if the final expression is omitted.</source>
          <target state="translated">블록의 유형은 최종 표현식의 유형이거나 최종 표현식이 생략 된 경우 &lt;code&gt;()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="04575cb944f5ba2523fe623e2ff7231ff81edabc" translate="yes" xml:space="preserve">
          <source>The type of a const parameter references other generic parameters.</source>
          <target state="translated">const 매개 변수의 유형은 다른 일반 매개 변수를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="ed47b86a36c39f67b1e05de4464008d8a1956f2c" translate="yes" xml:space="preserve">
          <source>The type of an &lt;em&gt;unsuffixed&lt;/em&gt; floating-point literal is determined by type inference:</source>
          <target state="translated">의 유형 &lt;em&gt;unsuffixed&lt;/em&gt; 부동 소수점 리터럴 타입 추론에 의해 결정된다 :</target>
        </trans-unit>
        <trans-unit id="6114cd343a30b85f17666d6fd494268587f7b8ea" translate="yes" xml:space="preserve">
          <source>The type of an &lt;em&gt;unsuffixed&lt;/em&gt; integer literal is determined by type inference:</source>
          <target state="translated">&lt;em&gt;접미사가없는&lt;/em&gt; 정수 리터럴 의 유형은 유형 유추에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="f7d869126e3c264254879784374ee68ec03547b9" translate="yes" xml:space="preserve">
          <source>The type of the elements being iterated over.</source>
          <target state="translated">반복되는 요소의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="af8245e533db8494bb30cc9dc28768887bbb8570" translate="yes" xml:space="preserve">
          <source>The type of the value that &lt;code&gt;File::open&lt;/code&gt; returns inside the &lt;code&gt;Err&lt;/code&gt; variant is &lt;code&gt;io::Error&lt;/code&gt;, which is a struct provided by the standard library. This struct has a method &lt;code&gt;kind&lt;/code&gt; that we can call to get an &lt;code&gt;io::ErrorKind&lt;/code&gt; value. The enum &lt;code&gt;io::ErrorKind&lt;/code&gt; is provided by the standard library and has variants representing the different kinds of errors that might result from an &lt;code&gt;io&lt;/code&gt; operation. The variant we want to use is &lt;code&gt;ErrorKind::NotFound&lt;/code&gt;, which indicates the file we&amp;rsquo;re trying to open doesn&amp;rsquo;t exist yet. So we match on &lt;code&gt;f&lt;/code&gt;, but we also have an inner match on &lt;code&gt;error.kind()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;File::open&lt;/code&gt; 이 &lt;code&gt;Err&lt;/code&gt; 변형 내에서 반환 하는 값의 유형은 표준 라이브러리에서 제공하는 구조체 인 &lt;code&gt;io::Error&lt;/code&gt; 입니다. 이 구조체에는 &lt;code&gt;io::ErrorKind&lt;/code&gt; 값 을 얻기 위해 호출 할 수 있는 메서드 &lt;code&gt;kind&lt;/code&gt; 가 있습니다 . 열거 형 &lt;code&gt;io::ErrorKind&lt;/code&gt; 는 표준 라이브러리에서 제공하며 &lt;code&gt;io&lt;/code&gt; 작업으로 인해 발생할 수있는 다양한 종류의 오류를 나타내는 변형이 있습니다 . 우리가 사용하려는 변형은 &lt;code&gt;ErrorKind::NotFound&lt;/code&gt; 이며, 열려고하는 파일이 아직 존재하지 않음을 나타냅니다. 따라서 &lt;code&gt;f&lt;/code&gt; 에 일치 하지만 &lt;code&gt;error.kind()&lt;/code&gt; 에 대한 내부 일치도 있습니다.</target>
        </trans-unit>
        <trans-unit id="545510a669763ef63063641881497bf7dd3f481a" translate="yes" xml:space="preserve">
          <source>The type of this value when viewed as failed.</source>
          <target state="translated">실패한 것으로 볼 때이 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="8b60f120f0bca222851815dfc6ed07a4a0520575" translate="yes" xml:space="preserve">
          <source>The type of this value when viewed as successful.</source>
          <target state="translated">성공한 것으로 볼 때이 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bf039a86046c9f49aceed05895007223ced0c5ff" translate="yes" xml:space="preserve">
          <source>The type of value produced on completion.</source>
          <target state="translated">완료시 생성되는 가치 유형입니다.</target>
        </trans-unit>
        <trans-unit id="16751927675b4a2fde8980932985c3b025559cb0" translate="yes" xml:space="preserve">
          <source>The type of value this generator returns.</source>
          <target state="translated">이 생성기가 반환하는 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bf293514c386bb6e45033b7b50e4549a332b83ad" translate="yes" xml:space="preserve">
          <source>The type of value this generator returns. &lt;a href=&quot;../ops/trait.generator#associatedtype.Return&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 생성기가 반환하는 값의 유형입니다. &lt;a href=&quot;../ops/trait.generator#associatedtype.Return&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fcbd5cd653d3daa61c5d5d30831f8972d04f844c" translate="yes" xml:space="preserve">
          <source>The type of value this generator returns. &lt;a href=&quot;ops/trait.generator#associatedtype.Return&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 생성기가 반환하는 값의 유형입니다. &lt;a href=&quot;ops/trait.generator#associatedtype.Return&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5e0eda41ab22396cfa2f1334045d1746f855426" translate="yes" xml:space="preserve">
          <source>The type of value this generator yields.</source>
          <target state="translated">이 생성기가 산출하는 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b8cb8237cc8b58247dbdfe05ac4618d5ded726d1" translate="yes" xml:space="preserve">
          <source>The type of value this generator yields. &lt;a href=&quot;../ops/trait.generator#associatedtype.Yield&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 생성기가 산출하는 값의 유형입니다. &lt;a href=&quot;../ops/trait.generator#associatedtype.Yield&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="becf5070fa5e52c8db7c1d497d6f97d2d8cc4f48" translate="yes" xml:space="preserve">
          <source>The type of value this generator yields. &lt;a href=&quot;ops/trait.generator#associatedtype.Yield&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 생성기가 산출하는 값의 유형입니다. &lt;a href=&quot;ops/trait.generator#associatedtype.Yield&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="586fe8d7efe2a1acc6c511b646a3a08c88efbb26" translate="yes" xml:space="preserve">
          <source>The type parameter &lt;code&gt;T&lt;/code&gt; represents the data that this lock protects. It is required that &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; to be shared across threads and &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; to allow concurrent access through readers. The RAII guards returned from the locking methods implement &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;../ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;write&lt;/code&gt; methods) to allow access to the content of the lock.</source>
          <target state="translated">유형 매개 변수 &lt;code&gt;T&lt;/code&gt; 는이 잠금이 보호하는 데이터를 나타냅니다. 필요가있다 &lt;code&gt;T&lt;/code&gt; 의 만족을 &lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; 스레드와간에 공유 할 수 &lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 독자를 통해 동시 액세스를 허용 할 수 있습니다. 잠금 메소드에서 리턴 된 RAII 가드는 잠금 의 컨텐츠에 액세스 할 수 있도록 &lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; (및 &lt;code&gt;write&lt;/code&gt; 메소드의 경우 &lt;a href=&quot;../ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; )&lt;/a&gt; 를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="f6f9ae50a3ab94a8cf9005786a7b9af006ffe517" translate="yes" xml:space="preserve">
          <source>The type parameters can also be explicitly supplied in a trailing &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; component after the function name. This might be necessary if there is not sufficient context to determine the type parameters. For example, &lt;code&gt;mem::size_of::&amp;lt;u32&amp;gt;() == 4&lt;/code&gt;.</source>
          <target state="translated">함수 이름 다음에 후행 &lt;a href=&quot;../paths&quot;&gt;경로&lt;/a&gt; 구성 요소 에 유형 매개 변수를 명시 적으로 제공 할 수도 있습니다 . 유형 매개 변수를 판별하기위한 컨텍스트가 충분하지 않은 경우에 필요할 수 있습니다. 예를 들어, &lt;code&gt;mem::size_of::&amp;lt;u32&amp;gt;() == 4&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="618c44497e554625efd295f7702914ef5292c792" translate="yes" xml:space="preserve">
          <source>The type placeholder &lt;code&gt;_&lt;/code&gt; can be used outside item's signature as follows:</source>
          <target state="translated">유형 자리 표시 자 &lt;code&gt;_&lt;/code&gt; 는 다음과 같이 항목의 서명 외부에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba2931173dcc6550d705628d261c402eccc53232" translate="yes" xml:space="preserve">
          <source>The type placeholder &lt;code&gt;_&lt;/code&gt; was used within a type on an item's signature.</source>
          <target state="translated">유형 자리 표시 자 &lt;code&gt;_&lt;/code&gt; 는 항목 서명의 유형 내에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="11d805f97c85ceb05a75d626e5740cb0e2204f44" translate="yes" xml:space="preserve">
          <source>The type returned by formatter methods.</source>
          <target state="translated">포맷터 메소드가 리턴 한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1c16d9adfa415d1c3d1e4550b932c426a82800c2" translate="yes" xml:space="preserve">
          <source>The type returned in the event of a conversion error.</source>
          <target state="translated">변환 오류가 발생하면 반환되는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="2d7863bb088ba575c630ae75df049f3bc518eb6c" translate="yes" xml:space="preserve">
          <source>The type that the &lt;code&gt;else&lt;/code&gt; blocks evaluate to must be compatible with the type that the &lt;code&gt;if&lt;/code&gt; block evaluates to.</source>
          <target state="translated">하는 유형 &lt;code&gt;else&lt;/code&gt; 블록 평가는 그 유형과 호환 가능해야하는 &lt;code&gt;if&lt;/code&gt; 블록들을 평가한다.</target>
        </trans-unit>
        <trans-unit id="6b611879bfea657d3652c629b736393c4b650211" translate="yes" xml:space="preserve">
          <source>The type you are trying to impl &lt;code&gt;CoerceUnsized&lt;/code&gt; for is not a struct. &lt;code&gt;CoerceUnsized&lt;/code&gt; can only be implemented for a struct. Unsized types are already able to be coerced without an implementation of &lt;code&gt;CoerceUnsized&lt;/code&gt; whereas a struct containing an unsized type needs to know the unsized type field it's containing is able to be coerced. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">&lt;code&gt;CoerceUnsized&lt;/code&gt; 에 영향 을 주려는 유형 은 구조체가 아닙니다. &lt;code&gt;CoerceUnsized&lt;/code&gt; 는 구조체에 대해서만 구현할 수 있습니다. 크기가 조정되지 않은 유형은 &lt;code&gt;CoerceUnsized&lt;/code&gt; 를 구현하지 않고도 이미 강제 변환 할 수 있지만 크기가 조정되지 않은 유형을 포함하는 구조체는 포함 된 크기가 조정되지 않은 유형 필드를 강제 변환 할 수 있어야합니다. &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;크기를 지정하지 않은 타입은&lt;/a&gt; 컴파일러가 컴파일시에 길이 또는 정렬을 알고하지 않습니다 어떤 유형입니다. 크기가 조정되지 않은 유형을 포함하는 모든 구조체도 크기가 조정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63c27305b7150da660772855aa4571d697d89b10" translate="yes" xml:space="preserve">
          <source>The type you can compare with is controlled by &lt;code&gt;PartialEq&lt;/code&gt;'s type parameter. For example, let's tweak our previous code a bit:</source>
          <target state="translated">비교할 수있는 유형은 &lt;code&gt;PartialEq&lt;/code&gt; 의 유형 매개 변수에 의해 제어됩니다 . 예를 들어, 이전 코드를 약간 조정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="93ef2caad28212460c75d9146f8dc4d0899b2d98" translate="yes" xml:space="preserve">
          <source>The type-checker needed to know the type of an expression, but that type had not yet been inferred.</source>
          <target state="translated">형식 검사기는 식의 형식을 알아야하지만 해당 형식은 아직 유추되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="f584bedf990c038f22247101ab8b097fb3a593e8" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;*const T&lt;/code&gt;, &lt;code&gt;&amp;amp;T&lt;/code&gt;, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;Option&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; all have the same size. If &lt;code&gt;T&lt;/code&gt; is Sized, all of those types have the same size as &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;code&gt;*const T&lt;/code&gt; , &lt;code&gt;&amp;amp;T&lt;/code&gt; , &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Option&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 모두 동일한 크기를 갖는다. 경우 &lt;code&gt;T&lt;/code&gt; 가 있는 크기, 그 종류는 모두 같은 크기가 &lt;code&gt;usize&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="5722d857751fd92f7cd76388f248410597abc535" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; hold textual data.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 및 &lt;code&gt;str&lt;/code&gt; 유형 은 텍스트 데이터를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="99894423e354dd0b37e0c9ced81c62b48fcf23b2" translate="yes" xml:space="preserve">
          <source>The types of any associated constants in a trait implementation must match the types in the trait definition.</source>
          <target state="translated">트레이 트 구현의 모든 관련 상수 유형은 트레이 트 정의의 유형과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff52a3715390889940af516c60b08b678feeadf3" translate="yes" xml:space="preserve">
          <source>The types of any associated constants in a trait implementation must match the types in the trait definition. This error indicates that there was a mismatch.</source>
          <target state="translated">특성 구현에서 연관된 상수의 유형은 특성 정의의 유형과 일치해야합니다. 이 오류는 불일치가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2a9653c2b160c32821b432c07707efaa597921f1" translate="yes" xml:space="preserve">
          <source>The typical way to obtain a &lt;code&gt;Weak&lt;/code&gt; pointer is to call &lt;a href=&quot;struct.arc#method.downgrade&quot;&gt;&lt;code&gt;Arc::downgrade&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터 를 얻는 일반적인 방법 은 &lt;a href=&quot;struct.arc#method.downgrade&quot;&gt; &lt;code&gt;Arc::downgrade&lt;/code&gt; &lt;/a&gt; 를 호출하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d7670bf148a2a36a6287e0959f849df36450aeea" translate="yes" xml:space="preserve">
          <source>The typical way to obtain a &lt;code&gt;Weak&lt;/code&gt; pointer is to call &lt;a href=&quot;struct.rc#method.downgrade&quot;&gt;&lt;code&gt;Rc::downgrade&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터 를 얻는 일반적인 방법 은 &lt;a href=&quot;struct.rc#method.downgrade&quot;&gt; &lt;code&gt;Rc::downgrade&lt;/code&gt; &lt;/a&gt; 를 호출하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e38264f429668f9c24babca8440ad652db0e6325" translate="yes" xml:space="preserve">
          <source>The unary logical negation operator &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">단항 논리 부정 연산자 &lt;code&gt;!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6144b29ea1cdce68ecac471463a0fdc0639b34f9" translate="yes" xml:space="preserve">
          <source>The unary negation operator &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">단항 부정 연산자 &lt;code&gt;-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7181a66c31dbb848d4da8d3e96055db8ae78d130" translate="yes" xml:space="preserve">
          <source>The underlying &lt;a href=&quot;struct.metadata&quot;&gt;&lt;code&gt;Metadata&lt;/code&gt;&lt;/a&gt; struct needs to be retrieved with the &lt;a href=&quot;fn.symlink_metadata&quot;&gt;&lt;code&gt;fs::symlink_metadata&lt;/code&gt;&lt;/a&gt; function and not the &lt;a href=&quot;fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; function. The &lt;a href=&quot;fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; function follows symbolic links, so &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt;&lt;code&gt;is_symlink&lt;/code&gt;&lt;/a&gt; would always return &lt;code&gt;false&lt;/code&gt; for the target file.</source>
          <target state="translated">기본 &lt;a href=&quot;struct.metadata&quot;&gt; &lt;code&gt;Metadata&lt;/code&gt; &lt;/a&gt; 구조체 는 &lt;a href=&quot;fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt; 함수가 아니라 &lt;a href=&quot;fn.symlink_metadata&quot;&gt; &lt;code&gt;fs::symlink_metadata&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 검색해야 합니다. &lt;a href=&quot;fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt; 있도록 기능은 심볼릭 링크를 다음과 &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt; &lt;code&gt;is_symlink&lt;/code&gt; 이&lt;/a&gt; 항상 반환 &lt;code&gt;false&lt;/code&gt; 대상 파일.</target>
        </trans-unit>
        <trans-unit id="5ba52bb287979fcbe21a62414e5cba80ede6c6c5" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;RefCell&lt;/code&gt; can never be mutably borrowed from again and will always appear already immutably borrowed. It is not a good idea to leak more than a constant number of references. The &lt;code&gt;RefCell&lt;/code&gt; can be immutably borrowed again if only a smaller number of leaks have occurred in total.</source>
          <target state="translated">기본 &lt;code&gt;RefCell&lt;/code&gt; 은 다시는 변경 불가능하게 빌릴 수 없으며 항상 이미 변경 불가능하게 빌린 것처럼 보입니다. 일정한 수 이상의 참조를 유출하는 것은 좋은 생각이 아닙니다. &lt;code&gt;RefCell&lt;/code&gt; 은 누수의 적은 수의 합계가 발생한 경우 불변 다시 대여 될 수있다.</target>
        </trans-unit>
        <trans-unit id="16573dc48843cb6201240052d6b60dde180482de" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;RefCell&lt;/code&gt; can not be borrowed from again and will always appear already mutably borrowed, making the returned reference the only to the interior.</source>
          <target state="translated">기본 &lt;code&gt;RefCell&lt;/code&gt; 은 다시 빌릴 수 없으며 항상 이미 변경 가능하게 빌려서 표시되므로 반환 된 참조는 내부에 대한 유일한 참조가됩니다.</target>
        </trans-unit>
        <trans-unit id="485a92064bc4fcb63908fa7e1b3b1ad970b9f88b" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;RefCell&lt;/code&gt; will remain mutably borrowed until both returned &lt;code&gt;RefMut&lt;/code&gt;s go out of scope.</source>
          <target state="translated">기본 &lt;code&gt;RefCell&lt;/code&gt; 은 반환 된 &lt;code&gt;RefMut&lt;/code&gt; 이 범위를 벗어날 때까지 변경없이 빌린 상태로 유지 됩니다.</target>
        </trans-unit>
        <trans-unit id="9efa2c9dbfc51e4660e725c77fd7efb185f3f6ff" translate="yes" xml:space="preserve">
          <source>The underlying value can be retrieved through the &lt;code&gt;.0&lt;/code&gt; index of the &lt;code&gt;Wrapping&lt;/code&gt; tuple.</source>
          <target state="translated">&lt;code&gt;Wrapping&lt;/code&gt; 튜플 의 &lt;code&gt;.0&lt;/code&gt; 인덱스를 통해 기본 값을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1be4ec15824529c7ce6527861e8c2980ac38212f" translate="yes" xml:space="preserve">
          <source>The unique, unnameable symbols are created after macro expansion so that macros may safely emit multiple references to &lt;code&gt;_&lt;/code&gt; imports. For example, the following should not produce an error:</source>
          <target state="translated">매크로가 확장 된 후 고유하고 이름이 지정되지 않은 기호가 만들어 지므로 매크로가 &lt;code&gt;_&lt;/code&gt; imports에 대한 여러 참조를 안전하게 방출 할 수 있습니다 . 예를 들어, 다음은 오류가 발생하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="f4f440ca9518cd96f0fe9c31f85a61d77e18e0f3" translate="yes" xml:space="preserve">
          <source>The unsafe counterpart of this macro is the &lt;a href=&quot;hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;unreachable_unchecked&lt;/code&gt;&lt;/a&gt; function, which will cause undefined behavior if the code is reached.</source>
          <target state="translated">이 매크로의 안전하지 않은 부분은 &lt;a href=&quot;hint/fn.unreachable_unchecked&quot;&gt; &lt;code&gt;unreachable_unchecked&lt;/code&gt; &lt;/a&gt; 함수이며, 코드에 도달하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c1a83814a7bcbd2091dc90767bec8f24c5d3f1e3" translate="yes" xml:space="preserve">
          <source>The unsigned integer types consist of:</source>
          <target state="translated">부호없는 정수 유형은 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2d2ce136339d709e77fd2d67b03ff1b69af40d44" translate="yes" xml:space="preserve">
          <source>The upper bound of the range (exclusive).</source>
          <target state="translated">범위의 상한입니다 (제외).</target>
        </trans-unit>
        <trans-unit id="20d82b105410f2577709f06e6539062262a0ca81" translate="yes" xml:space="preserve">
          <source>The upper bound of the range (inclusive)</source>
          <target state="translated">범위의 상한 (포함)</target>
        </trans-unit>
        <trans-unit id="e68185f2e9603472a1563c4f776b66b2c6a3b822" translate="yes" xml:space="preserve">
          <source>The use of the &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; keyword in this position allows the function writer to hide the concrete type as an implementation detail which can change without breaking user's code.</source>
          <target state="translated">의 사용 &lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &lt;/a&gt; 이 위치에있는 키워드는 함수 작가가 사용자의 코드를 깨는없이 변경 될 수 있습니다 구현 세부 사항 등의 구체적인 유형을 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39cef1794b05feb8ec892ea4cd89efe908da35c8" translate="yes" xml:space="preserve">
          <source>The user could always interrupt the program by using the keyboard shortcut ctrl-c. But there&amp;rsquo;s another way to escape this insatiable monster, as mentioned in the &lt;code&gt;parse&lt;/code&gt; discussion in &lt;a href=&quot;#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt;: if the user enters a non-number answer, the program will crash. The user can take advantage of that in order to quit, as shown here:</source>
          <target state="translated">사용자는 키보드 단축키 ctrl-c를 사용하여 항상 프로그램을 중단 할 수 있습니다. 에서 언급하지만,이 탐욕스러운 괴물을 탈출하는 또 다른 방법이 &lt;code&gt;parse&lt;/code&gt; 에 대한 논의 &lt;a href=&quot;#comparing-the-guess-to-the-secret-number&quot;&gt;&quot;비밀 번호에 맞춰 비교&quot;&lt;/a&gt; : 사용자가 아닌 숫자의 답을 입력하면, 프로그램이 충돌합니다. 사용자는 다음과 같이 종료하기 위해이를 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e62c088fdd6cf7f93babb9263d9008d71eaadccf" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to perform &lt;code&gt;metadata&lt;/code&gt; call on &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">사용자에게 &lt;code&gt;path&lt;/code&gt; 에 대한 &lt;code&gt;metadata&lt;/code&gt; 호출 을 수행 할 권한이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0dc65bb53b7876e2a52ec0de6c50b31a471724ba" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to remove the directory at the provided &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">제공된 &lt;code&gt;path&lt;/code&gt; 에서 디렉토리를 제거 할 권한이 사용자에게 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4ed8999bb1ca133f6f343fbba9eb07d31db22560" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to remove the file.</source>
          <target state="translated">사용자에게 파일을 제거 할 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="da243dceea5f741ec03e2474a95470f701358e02" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to view contents.</source>
          <target state="translated">사용자에게 내용을 볼 수있는 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a0ceecf91cf3de088e4866146d667401fc9825c7" translate="yes" xml:space="preserve">
          <source>The user lacks the permission to change attributes of the file.</source>
          <target state="translated">사용자에게 파일 속성을 변경할 수있는 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0728943e3f9e2dd60ac0860b5efc3c86277bbcf8" translate="yes" xml:space="preserve">
          <source>The user of &lt;code&gt;from_raw&lt;/code&gt; has to make sure a specific value of &lt;code&gt;T&lt;/code&gt; is only dropped once.</source>
          <target state="translated">&lt;code&gt;from_raw&lt;/code&gt; 사용자는 &lt;code&gt;T&lt;/code&gt; 의 특정 값이 한 번만 삭제 되었는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8bc0d661ff73b2e7b2da5a4e28c09493dbabbf98" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;to_drop&lt;/code&gt; points to must be valid for dropping, which may mean it must uphold additional invariants - this is type-dependent.</source>
          <target state="translated">&lt;code&gt;to_drop&lt;/code&gt; 포인트 값 은 드롭에 유효해야합니다. 이는 추가 불변을 유지해야 함을 의미 할 수 있습니다. 이는 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9ef61ff6808c20e3aee33111c7be00b7f9eb3ce9" translate="yes" xml:space="preserve">
          <source>The value being coerced is the actual parameter, and it is coerced to the type of the formal parameter.</source>
          <target state="translated">강제되는 값은 실제 매개 변수이며 공식 매개 변수의 유형으로 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="a4543ae96f3c210a98b1abf8fa6e1fffb99a3a60" translate="yes" xml:space="preserve">
          <source>The value contained in the &lt;code&gt;Result::Err&lt;/code&gt; variant is the value the thread panicked with; that is, the argument the &lt;code&gt;panic!&lt;/code&gt; macro was called with. Unlike with normal errors, this value doesn't implement the &lt;a href=&quot;../error/trait.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">에 포함 된 값 &lt;code&gt;Result::Err&lt;/code&gt; 변형 스레드에 당황 값이고; 즉, 논쟁은 &lt;code&gt;panic!&lt;/code&gt; 매크로가 호출되었습니다. 일반 오류와 달리이 값은 &lt;a href=&quot;../error/trait.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 특성을 구현하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3a5a7553814237ff25467a69b929b269b579c5c7" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;push&lt;/code&gt; is an expected cost; the method documentation gives a more detailed analysis.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; 의 가치 는 예상 비용입니다. 분석법 문서는보다 자세한 분석을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7655c33f10da48be510d779b36c1473fc0c444da" translate="yes" xml:space="preserve">
          <source>The value for the width can also be provided as a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; in the list of parameters by adding a postfix &lt;code&gt;$&lt;/code&gt;, indicating that the second argument is a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; specifying the width.</source>
          <target state="translated">폭의 값은 또한 제공 할 수 &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; 후위 가산함으로써 파라미터의 목록 &lt;code&gt;$&lt;/code&gt; 번째 인수는 것을 나타내는, &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; 폭을 지정.</target>
        </trans-unit>
        <trans-unit id="d7971e26c81d228c6b498e7c0267b27f63e3a2f0" translate="yes" xml:space="preserve">
          <source>The value for the width can also be provided as a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; in the list of parameters by using the dollar syntax indicating that the second argument is a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; specifying the width, for example:</source>
          <target state="translated">너비 값 은 두 번째 인수가 너비를 지정 하는 &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; 임을 나타내는 달러 구문을 사용하여 매개 변수 목록에서 &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; 로 제공 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a708656013343fb0ab99fafd8d21e4229d39b962" translate="yes" xml:space="preserve">
          <source>The value may be any borrowed form of the set's value type, but &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the value type.</source>
          <target state="translated">값은 세트의 값 유형의 대출 형태가 될 수 있지만, &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 빌린 양식이 &lt;em&gt;있어야합니다&lt;/em&gt; 값 유형에 대한 일치.</target>
        </trans-unit>
        <trans-unit id="6f10fa6eb368dac898013f2276c185e31dd968d4" translate="yes" xml:space="preserve">
          <source>The value may be any borrowed form of the set's value type, but &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the value type.</source>
          <target state="translated">값은 세트의 값 유형의 대출 형태가 될 수 있지만, &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 빌린 양식이 &lt;em&gt;있어야합니다&lt;/em&gt; 값 유형에 대한 일치.</target>
        </trans-unit>
        <trans-unit id="cc1bf7113b6ffebee8a5cbda9953ce0f46aa8389" translate="yes" xml:space="preserve">
          <source>The value may be any borrowed form of the set's value type, but the ordering on the borrowed form &lt;em&gt;must&lt;/em&gt; match the ordering on the value type.</source>
          <target state="translated">값은 세트 값 유형의 빌린 형식 일 수 있지만 빌린 양식 의 순서는 값 유형의 순서와 일치 &lt;em&gt;해야합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5386004ae808f6aad83668aa6e791c4916959b45" translate="yes" xml:space="preserve">
          <source>The value must not be zero.</source>
          <target state="translated">값은 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="72b7ccc4c541479713442aeb6f9117133107de5e" translate="yes" xml:space="preserve">
          <source>The value must:</source>
          <target state="translated">값은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="fe1619fc66fbf6e80510234756b7616df221cbcc" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;N&lt;/code&gt; that was specified for &lt;code&gt;repr(align(N))&lt;/code&gt; was not a power of two, or was greater than 2^29.</source>
          <target state="translated">&lt;code&gt;repr(align(N))&lt;/code&gt; 에 지정된 &lt;code&gt;N&lt;/code&gt; 값이 2의 거듭 제곱이 아니거나 2 ^ 29보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="744a6000b03885b8f256f7629c96527779c5f909" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;upper_i&lt;/code&gt; here relies on the language of the text: if we're in &lt;code&gt;en-US&lt;/code&gt;, it should be &lt;code&gt;&quot;I&quot;&lt;/code&gt;, but if we're in &lt;code&gt;tr_TR&lt;/code&gt;, it should be &lt;code&gt;&quot;İ&quot;&lt;/code&gt;. &lt;code&gt;to_uppercase()&lt;/code&gt; does not take this into account, and so:</source>
          <target state="translated">&lt;code&gt;upper_i&lt;/code&gt; 의 값은 텍스트 언어에 의존합니다. &lt;code&gt;en-US&lt;/code&gt; 인 경우 &lt;code&gt;&quot;I&quot;&lt;/code&gt; 이어야 하지만 &lt;code&gt;tr_TR&lt;/code&gt; 인 경우 &lt;code&gt;&quot;İ&quot;&lt;/code&gt; 이어야합니다 . &lt;code&gt;to_uppercase()&lt;/code&gt; 는 이것을 고려하지 않으므로 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5ddda6614ea7e3e67438b2aae41a24ac0eb3ff50" translate="yes" xml:space="preserve">
          <source>The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time.</source>
          <target state="translated">정적 및 상수의 값은 컴파일 타임에 알아야하며 프로그램의 전체 수명 동안 유지됩니다. boxed 값을 만들면 런타임에 힙에 메모리가 할당되므로 컴파일 타임에 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b739d6552c67cec966b03a294f348b71a38926c7" translate="yes" xml:space="preserve">
          <source>The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time. Erroneous code example:</source>
          <target state="translated">정적 및 상수의 값은 컴파일 타임에 알고 있어야하며 프로그램의 전체 수명 동안 지속됩니다. 박스형 값을 작성하면 런타임시 힙에 메모리가 할당되므로 컴파일시 수행 할 수 없습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="4b2ff9e347c3c08ba8e806ad69a147ed48871d42" translate="yes" xml:space="preserve">
          <source>The value returned is equivalent to &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt; but does not flush the internal buffer. Due to this optimization the function does not guarantee that calling &lt;code&gt;.into_inner()&lt;/code&gt; immediately afterwards will yield the underlying reader at the same position. Use &lt;a href=&quot;struct.bufreader#method.seek&quot;&gt;&lt;code&gt;BufReader::seek&lt;/code&gt;&lt;/a&gt; instead if you require that guarantee.</source>
          <target state="translated">반환 된 값은 &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt; 동일하지만 내부 버퍼를 플러시하지 않습니다. 이 최적화로 인해 함수는 &lt;code&gt;.into_inner()&lt;/code&gt; 즉시 호출 하면 동일한 위치에있는 기본 판독기가 생성 된다는 것을 보장하지 않습니다 . 보증이 필요한 경우 대신 &lt;a href=&quot;struct.bufreader#method.seek&quot;&gt; &lt;code&gt;BufReader::seek&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="39c061cf746d3ba8e95a5a5598de09efb58fb7b8" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;s&lt;/code&gt; has type &lt;code&gt;String&lt;/code&gt;, and its use in the guard is as a variable of type &lt;code&gt;String&lt;/code&gt;. The guard code effectively executes in a separate scope to the body of the arm, so the value would be moved into this anonymous scope and therefore becomes unavailable in the body of the arm.</source>
          <target state="translated">변수 &lt;code&gt;s&lt;/code&gt; 에는 &lt;code&gt;String&lt;/code&gt; 유형 이 있으며 Guard에서 사용되는 것은 &lt;code&gt;String&lt;/code&gt; 유형의 변수입니다 . 보호 코드는 팔의 몸체에 대해 별도의 범위에서 효과적으로 실행되므로 값이이 익명 범위로 이동되어 팔의 몸체에서 사용할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="8e557a8691f00e33607a16e96773df5a29940a13" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;s&lt;/code&gt; refers to a string literal, where the value of the string is hardcoded into the text of our program. The variable is valid from the point at which it&amp;rsquo;s declared until the end of the current &lt;em&gt;scope&lt;/em&gt;. Listing 4-1 has comments annotating where the variable &lt;code&gt;s&lt;/code&gt; is valid.</source>
          <target state="translated">변수 &lt;code&gt;s&lt;/code&gt; 는 문자열 리터럴을 나타내며, 여기서 문자열 값은 프로그램의 텍스트에 하드 코딩됩니다. 변수는 선언 된 시점부터 현재 &lt;em&gt;범위&lt;/em&gt; 끝까지 유효합니다 . 목록 4-1에는 변수 &lt;code&gt;s&lt;/code&gt; 가 유효한 위치에 주석 이 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e699bc2ac5d00c87b2c7f3b8e3a9da4a553a5d0" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;tup&lt;/code&gt; binds to the entire tuple, because a tuple is considered a single compound element. To get the individual values out of a tuple, we can use pattern matching to destructure a tuple value, like this:</source>
          <target state="translated">튜플은 단일 복합 요소로 간주되므로 변수 &lt;code&gt;tup&lt;/code&gt; 은 전체 튜플에 바인딩됩니다. 튜플에서 개별 값을 가져 오려면 다음과 같이 패턴 일치를 사용하여 튜플 값을 구성 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b81aa2b0402a0e499f7595712bef15edfd23e380" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;x&lt;/code&gt; doesn&amp;rsquo;t &amp;ldquo;live long enough.&amp;rdquo; The reason is that &lt;code&gt;x&lt;/code&gt; will be out of scope when the inner scope ends on line 7. But &lt;code&gt;r&lt;/code&gt; is still valid for the outer scope; because its scope is larger, we say that it &amp;ldquo;lives longer.&amp;rdquo; If Rust allowed this code to work, &lt;code&gt;r&lt;/code&gt; would be referencing memory that was deallocated when &lt;code&gt;x&lt;/code&gt; went out of scope, and anything we tried to do with &lt;code&gt;r&lt;/code&gt; wouldn&amp;rsquo;t work correctly. So how does Rust determine that this code is invalid? It uses a borrow checker.</source>
          <target state="translated">변수 &lt;code&gt;x&lt;/code&gt; 는 &quot;충분히 오래 살지&quot;않습니다. 그 이유는 내부 범위가 라인 7에서 끝날 때 &lt;code&gt;x&lt;/code&gt; 가 범위를 벗어나기 때문입니다 . 그러나 &lt;code&gt;r&lt;/code&gt; 은 여전히 ​​외부 범위에 유효합니다. 그 범위가 더 넓기 때문에&amp;ldquo;더 오래 산다&amp;rdquo;고 말합니다. 녹 작업이 코드를 사용할 경우, &lt;code&gt;r&lt;/code&gt; 은 때 해제 된 메모리를 참조 할 것 &lt;code&gt;x&lt;/code&gt; 가 범위를 벗어나 갔다, 그리고 우리가하려고 노력 아무것도 &lt;code&gt;r&lt;/code&gt; 은 제대로 작동하지 않을 것입니다. 그렇다면 Rust는이 코드가 유효하지 않다고 어떻게 판단합니까? 빌리 체커를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b4588e360f79d1cb0e5f79f31bf6e7bc2ece8336" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;x&lt;/code&gt; holds an &lt;code&gt;i32&lt;/code&gt; value, &lt;code&gt;5&lt;/code&gt;. We set &lt;code&gt;y&lt;/code&gt; equal to a reference to &lt;code&gt;x&lt;/code&gt;. We can assert that &lt;code&gt;x&lt;/code&gt; is equal to &lt;code&gt;5&lt;/code&gt;. However, if we want to make an assertion about the value in &lt;code&gt;y&lt;/code&gt;, we have to use &lt;code&gt;*y&lt;/code&gt; to follow the reference to the value it&amp;rsquo;s pointing to (hence &lt;em&gt;dereference&lt;/em&gt;). Once we dereference &lt;code&gt;y&lt;/code&gt;, we have access to the integer value &lt;code&gt;y&lt;/code&gt; is pointing to that we can compare with &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">변수 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;i32&lt;/code&gt; 값 &lt;code&gt;5&lt;/code&gt; 를 보유합니다 . &lt;code&gt;y&lt;/code&gt; 를 &lt;code&gt;x&lt;/code&gt; 에 대한 참조 와 동일하게 설정 합니다. &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;5&lt;/code&gt; 와 같다고 주장 할 수 있습니다 . 그러나 &lt;code&gt;y&lt;/code&gt; 의 값에 대한 어설 션을 만들려면 &lt;code&gt;*y&lt;/code&gt; 를 사용 하여 가리키는 값에 대한 참조를 따라야합니다 (따라서 &lt;em&gt;dereference&lt;/em&gt; ). &lt;code&gt;y&lt;/code&gt; 를 역 참조 하면 정수 값 &lt;code&gt;y&lt;/code&gt; 에 액세스 할 수 있습니다 . y 는 &lt;code&gt;5&lt;/code&gt; 와 비교할 수 있음을 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="b7511a7213b8989f428e5bec2c5234f95d46bda2" translate="yes" xml:space="preserve">
          <source>The variables that a &lt;a href=&quot;types/closure&quot;&gt;closure&lt;/a&gt; captures by move are dropped in an unspecified order.</source>
          <target state="translated">&lt;a href=&quot;types/closure&quot;&gt;클로저&lt;/a&gt; 가 이동으로 캡처하는 변수 는 지정되지 않은 순서로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f517012aa2f18b099c9314a6c9154f5976be9a45" translate="yes" xml:space="preserve">
          <source>The variance of other &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; and tuple types is decided by looking at the variance of the types of their fields. If the parameter is used in positions with different variances then the parameter is invariant. For example the following struct is covariant in &lt;code&gt;'a&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and invariant in &lt;code&gt;'b&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">다른 &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;enum&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; 및 튜플 유형의 분산은 해당 필드 유형의 분산을보고 결정됩니다. 변수가 분산이 다른 위치에서 사용되면 변수가 변하지 않습니다. 예를 들어 다음 구조체는 &lt;code&gt;'a&lt;/code&gt; 및 &lt;code&gt;T&lt;/code&gt; 에서 공변량 이고 &lt;code&gt;'b&lt;/code&gt; 및 &lt;code&gt;U&lt;/code&gt; 에서 불변량입니다 .</target>
        </trans-unit>
        <trans-unit id="edea3e36560d105a970958779d2fd8e9db94e633" translate="yes" xml:space="preserve">
          <source>The variance of other &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, and tuple types is decided by looking at the variance of the types of their fields. If the parameter is used in positions with different variances then the parameter is invariant. For example the following struct is covariant in &lt;code&gt;'a&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and invariant in &lt;code&gt;'b&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">다른 &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;enum&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; 및 tuple 유형의 분산은 해당 필드 유형의 분산을 살펴봄으로써 결정됩니다. 매개 변수가 분산이 다른 위치에서 사용되는 경우 매개 변수는 불변입니다. 예를 들어 다음 구조체는 &lt;code&gt;'a&lt;/code&gt; 와 &lt;code&gt;T&lt;/code&gt; 에서는 공변 이고 &lt;code&gt;'b&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; 에서는 불변입니다 .</target>
        </trans-unit>
        <trans-unit id="a2a9da86bd97667912e395039b2e850ba36a8d1a" translate="yes" xml:space="preserve">
          <source>The vector will be able to hold exactly &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the vector will not allocate.</source>
          <target state="translated">벡터는 재 할당없이 정확히 &lt;code&gt;capacity&lt;/code&gt; 요소 를 보유 할 수 있습니다 . 경우 &lt;code&gt;capacity&lt;/code&gt; 0, 벡터가 할당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a1a063010e523349572dfe2f3d4599fdbf7faf0" translate="yes" xml:space="preserve">
          <source>The vector will not allocate until elements are pushed onto it.</source>
          <target state="translated">벡터는 요소가 푸시 될 때까지 할당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d0b594b3c2a18ead8ab96882d29be04515f3b55" translate="yes" xml:space="preserve">
          <source>The version numbering scheme is explained in &lt;a href=&quot;https://www.unicode.org/versions/Unicode11.0.0/ch03.pdf#page=4&quot;&gt;Unicode 11.0 or later, Section 3.1 Versions of the Unicode Standard&lt;/a&gt;.</source>
          <target state="translated">버전 번호 지정 체계는 &lt;a href=&quot;https://www.unicode.org/versions/Unicode11.0.0/ch03.pdf#page=4&quot;&gt;유니 코드 11.0 이상, 유니 코드 표준의 3.1 버전 섹션에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0be7c75604b320ccdf03b29c2cf5dc9816b16f93" translate="yes" xml:space="preserve">
          <source>The version of &lt;a href=&quot;http://www.unicode.org/&quot;&gt;Unicode&lt;/a&gt; that the Unicode parts of &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; methods are based on.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 및 &lt;code&gt;str&lt;/code&gt; 메서드 의 유니 코드 부분 이 기반으로 하는 유니 &lt;a href=&quot;http://www.unicode.org/&quot;&gt;코드&lt;/a&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="2e7d7937a98ae8b5db75096586d34257981a3b35" translate="yes" xml:space="preserve">
          <source>The version of the call operator that takes a by-value receiver.</source>
          <target state="translated">값별 수신자를 취하는 호출 연산자의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="98bb0c84eb64933810db44150740704106b58e5b" translate="yes" xml:space="preserve">
          <source>The version of the call operator that takes a mutable receiver.</source>
          <target state="translated">변경 가능한 수신자를 취하는 호출 연산자의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="a10ea779af62c4002732377426c5466fd9b100f8" translate="yes" xml:space="preserve">
          <source>The version of the call operator that takes an immutable receiver.</source>
          <target state="translated">변경 불가능한 수신자를 취하는 호출 연산자의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="69df36660018fe57f4bfd6fa17c4ad5d9397540f" translate="yes" xml:space="preserve">
          <source>The volatile intrinsics provide operations intended to act on I/O memory, which are guaranteed to not be reordered by the compiler across other volatile intrinsics. See the LLVM documentation on [&lt;a href=&quot;http://llvm.org/docs/LangRef.html#volatile-memory-accesses&quot;&gt;volatile&lt;/a&gt;].</source>
          <target state="translated">휘발성 내장 함수는 I / O 메모리에서 작동하도록 의도 된 작업을 제공하며 다른 휘발성 내장 함수에서 컴파일러가 순서를 다시 지정할 수는 없습니다. [ &lt;a href=&quot;http://llvm.org/docs/LangRef.html#volatile-memory-accesses&quot;&gt;volatile&lt;/a&gt; ] 에 대한 LLVM 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3879e8ab569a056c97968189092bda667116aee8" translate="yes" xml:space="preserve">
          <source>The volatile parameter is set to &lt;code&gt;true&lt;/code&gt;, so it will not be optimized out unless size is equal to zero.</source>
          <target state="translated">휘발성 매개 변수가 &lt;code&gt;true&lt;/code&gt; 로 설정 되므로 크기가 0이 아닌 한 최적화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="545e192087f2dee8a1244b50285f56354faded13" translate="yes" xml:space="preserve">
          <source>The warning suggests that we use &lt;code&gt;_i&lt;/code&gt; as a name instead: the underscore indicates that we intend for this variable to be unused. We can automatically apply that suggestion using the &lt;code&gt;rustfix&lt;/code&gt; tool by running the command &lt;code&gt;cargo fix&lt;/code&gt;:</source>
          <target state="translated">경고는 &lt;code&gt;_i&lt;/code&gt; 를 대신 이름으로 사용하도록 제안합니다 . 밑줄은이 변수를 사용하지 않을 것임을 나타냅니다. &lt;code&gt;cargo fix&lt;/code&gt; 명령을 실행하여 &lt;code&gt;rustfix&lt;/code&gt; 도구를 사용하여 제안을 자동으로 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="71e5980a6bfd716abaaef858ffaa58512cff6b9e" translate="yes" xml:space="preserve">
          <source>The warning we get is this:</source>
          <target state="translated">우리가 얻는 경고는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01d3cf24ed7ac31e045df84ed43b543301d5071c" translate="yes" xml:space="preserve">
          <source>The way in which you need to specify lifetime parameters depends on what your function is doing. For example, if we changed the implementation of the &lt;code&gt;longest&lt;/code&gt; function to always return the first parameter rather than the longest string slice, we wouldn&amp;rsquo;t need to specify a lifetime on the &lt;code&gt;y&lt;/code&gt; parameter. The following code will compile:</source>
          <target state="translated">수명 매개 변수를 지정해야하는 방법은 함수가 수행하는 작업에 따라 다릅니다. 예를 들어 가장 긴 문자열 슬라이스 대신 항상 첫 번째 매개 변수를 반환 하도록 &lt;code&gt;longest&lt;/code&gt; 함수 의 구현을 변경 한 경우 &lt;code&gt;y&lt;/code&gt; 매개 변수 에 수명을 지정할 필요가 없습니다 . 다음 코드는 컴파일됩니다 :</target>
        </trans-unit>
        <trans-unit id="5b549318fc3f4ca028012969aeab8043ad858528" translate="yes" xml:space="preserve">
          <source>The way privacy works in Rust is that all items (functions, methods, structs, enums, modules, and constants) are private by default. Items in a parent module can&amp;rsquo;t use the private items inside child modules, but items in child modules can use the items in their ancestor modules. The reason is that child modules wrap and hide their implementation details, but the child modules can see the context in which they&amp;rsquo;re defined. To continue with the restaurant metaphor, think of the privacy rules as being like the back office of a restaurant: what goes on in there is private to restaurant customers, but office managers can see and do everything in the restaurant in which they operate.</source>
          <target state="translated">Rust에서 프라이버시가 작동하는 방식은 모든 아이템 (함수, 메소드, 구조체, 열거 형, 모듈 및 상수)이 기본적으로 비공개입니다. 상위 모듈의 항목은 하위 모듈 내부의 개인 항목을 사용할 수 없지만 하위 모듈의 항목은 상위 모듈의 항목을 사용할 수 있습니다. 그 이유는 자식 모듈이 구현 세부 사항을 감싸고 숨기지 만 자식 모듈은 자신이 정의 된 컨텍스트를 볼 수 있기 때문입니다. 식당의 은유를 계속하려면 개인 정보 보호 규칙을 식당의 백 오피스와 같다고 생각하십시오. 식당 고객에게는 개인이 있지만 사무실 관리자는 식당이 운영하는 식당에서 모든 것을보고 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c954766baf952dffb19514bc82ccc04508ad4747" translate="yes" xml:space="preserve">
          <source>The way to define helper attributes is to put an &lt;code&gt;attributes&lt;/code&gt; key in the &lt;code&gt;proc_macro_derive&lt;/code&gt; macro with a comma separated list of identifiers that are the names of the helper attributes.</source>
          <target state="translated">헬퍼 속성을 정의하는 방법은 헬퍼 속성 의 이름 인 쉼표로 구분 된 식별자 목록과 함께 &lt;code&gt;attributes&lt;/code&gt; 키를 &lt;code&gt;proc_macro_derive&lt;/code&gt; 매크로 에 넣는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b4ad5969b00a7de4e50dcfbec4f420300a121d22" translate="yes" xml:space="preserve">
          <source>The way to demonstrate this behavior is by running the program with &lt;code&gt;&amp;gt;&lt;/code&gt; and the filename, &lt;em&gt;output.txt&lt;/em&gt;, that we want to redirect the standard output stream to. We won&amp;rsquo;t pass any arguments, which should cause an error:</source>
          <target state="translated">이 동작을 보여주는 방법 은 표준 출력 스트림을 리디렉션하려는 &lt;code&gt;&amp;gt;&lt;/code&gt; 및 파일 이름 &lt;em&gt;output.txt로&lt;/em&gt; 프로그램을 실행하는 것입니다. 인수를 전달하지 않으므로 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4860fccc5b2b1b15ffbccd4a99af016a4e435d30" translate="yes" xml:space="preserve">
          <source>The wildcard pattern is always irrefutable.</source>
          <target state="translated">와일드 카드 패턴은 항상 반박 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6ed876d97357afb4218b62acc26e1fb7fcb7f367" translate="yes" xml:space="preserve">
          <source>The workspace has one &lt;em&gt;target&lt;/em&gt; directory at the top level for the compiled artifacts to be placed into; the &lt;code&gt;adder&lt;/code&gt; crate doesn&amp;rsquo;t have its own &lt;em&gt;target&lt;/em&gt; directory. Even if we were to run &lt;code&gt;cargo build&lt;/code&gt; from inside the &lt;em&gt;adder&lt;/em&gt; directory, the compiled artifacts would still end up in &lt;em&gt;add/target&lt;/em&gt; rather than &lt;em&gt;add/adder/target&lt;/em&gt;. Cargo structures the &lt;em&gt;target&lt;/em&gt; directory in a workspace like this because the crates in a workspace are meant to depend on each other. If each crate had its own &lt;em&gt;target&lt;/em&gt; directory, each crate would have to recompile each of the other crates in the workspace to have the artifacts in its own &lt;em&gt;target&lt;/em&gt; directory. By sharing one &lt;em&gt;target&lt;/em&gt; directory, the crates can avoid unnecessary rebuilding.</source>
          <target state="translated">작업 공간에는 컴파일 된 아티팩트를 배치 할 하나의 &lt;em&gt;대상&lt;/em&gt; 디렉토리가 최상위 레벨에 있습니다. &lt;code&gt;adder&lt;/code&gt; 상자 자체가없는 &lt;em&gt;대상&lt;/em&gt; 디렉토리를. &lt;em&gt;adder&lt;/em&gt; 디렉토리 내부에서 &lt;code&gt;cargo build&lt;/code&gt; 를 실행하더라도 컴파일 된 아티팩트는 여전히 &lt;em&gt;add / adder / target&lt;/em&gt; 대신 &lt;em&gt;add / target으로&lt;/em&gt; 끝납니다 . 화물 은 작업 공간의 상자가 서로 의존하기 때문에 작업 공간에서 &lt;em&gt;대상&lt;/em&gt; 디렉토리를 구조화합니다 . 각 상자에 자체 &lt;em&gt;대상&lt;/em&gt; 디렉토리 가있는 경우 각 상자는 작업 공간에서 다른 상자를 각각 다시 컴파일하여 아티팩트를 소유해야합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;대상&lt;/em&gt; 디렉토리. 하나의 &lt;em&gt;대상&lt;/em&gt; 디렉토리 를 공유함으로써 상자는 불필요한 재 구축을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94338f88d478ec6b62411179604be0f6a0e553b2" translate="yes" xml:space="preserve">
          <source>The workspace has one &lt;em&gt;target&lt;/em&gt; directory at the top level for the compiled artifacts to be placed into; the &lt;code&gt;adder&lt;/code&gt; package doesn&amp;rsquo;t have its own &lt;em&gt;target&lt;/em&gt; directory. Even if we were to run &lt;code&gt;cargo build&lt;/code&gt; from inside the &lt;em&gt;adder&lt;/em&gt; directory, the compiled artifacts would still end up in &lt;em&gt;add/target&lt;/em&gt; rather than &lt;em&gt;add/adder/target&lt;/em&gt;. Cargo structures the &lt;em&gt;target&lt;/em&gt; directory in a workspace like this because the crates in a workspace are meant to depend on each other. If each crate had its own &lt;em&gt;target&lt;/em&gt; directory, each crate would have to recompile each of the other crates in the workspace to have the artifacts in its own &lt;em&gt;target&lt;/em&gt; directory. By sharing one &lt;em&gt;target&lt;/em&gt; directory, the crates can avoid unnecessary rebuilding.</source>
          <target state="translated">작업 공간에는 컴파일 된 아티팩트를 배치 할 최상위 레벨에 하나의 &lt;em&gt;대상&lt;/em&gt; 디렉토리가 있습니다. &lt;code&gt;adder&lt;/code&gt; 패키지 자체가없는 &lt;em&gt;대상&lt;/em&gt; 디렉토리를. 우리가 실행하더라도 &lt;code&gt;cargo build&lt;/code&gt; 내부에서 &lt;em&gt;가산&lt;/em&gt; 디렉토리, 컴파일 된 유물은 여전히에서 끝날 것이다 &lt;em&gt;추가 / 대상&lt;/em&gt; 이 아닌 &lt;em&gt;추가 / 가산기 / 대상&lt;/em&gt; . Cargo 는 작업 공간의 상자가 서로 의존하기 때문에 이와 같은 작업 공간에서 &lt;em&gt;대상&lt;/em&gt; 디렉토리를 구성합니다 . 각 상자에 자체 &lt;em&gt;대상&lt;/em&gt; 디렉터리 가있는 경우 각 상자는 작업 공간에서 다른 상자를 다시 컴파일하여 자체에 아티팩트를 가져야합니다.&lt;em&gt;대상&lt;/em&gt; 디렉토리. 하나의 &lt;em&gt;대상&lt;/em&gt; 디렉토리 를 공유함으로써 상자는 불필요한 재 구축을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77f8b60c8bbd1e207542248a0d2f457b8e7e406f" translate="yes" xml:space="preserve">
          <source>The worst case cost of &lt;code&gt;pop&lt;/code&gt; on a heap containing &lt;em&gt;n&lt;/em&gt; elements is &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)).</source>
          <target state="translated">&lt;em&gt;n 개의&lt;/em&gt; 요소를 포함하는 힙 에서 &lt;code&gt;pop&lt;/code&gt; 의 최악의 비용 은 &lt;em&gt;O&lt;/em&gt; (log ( &lt;em&gt;n&lt;/em&gt; ))입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99d51b0abe084f304807f0bb44acfa16e7f4af5a" translate="yes" xml:space="preserve">
          <source>The worst case cost of &lt;code&gt;pop&lt;/code&gt; on a heap containing &lt;em&gt;n&lt;/em&gt; elements is O(log n).</source>
          <target state="translated">&lt;em&gt;n 개의&lt;/em&gt; 요소를 포함하는 힙에서 최악의 &lt;code&gt;pop&lt;/code&gt; 비용 은 O (log n)입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc0b397ce3728851f33d0ec0d540c025798521e0" translate="yes" xml:space="preserve">
          <source>The worst case cost of a &lt;em&gt;single&lt;/em&gt; call to &lt;code&gt;push&lt;/code&gt; is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;). The worst case occurs when capacity is exhausted and needs a resize. The resize cost has been amortized in the previous figures.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; &lt;em&gt;단일&lt;/em&gt; 호출 의 최악의 경우 비용 은 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; )입니다. 최악의 경우는 용량이 소진되어 크기 조정이 필요할 때 발생합니다. 크기 조정 비용은 이전 수치에서 상각되었습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="238b65c05553bd00df49cce92fea6a1b783b67b3" translate="yes" xml:space="preserve">
          <source>The worst case cost of a &lt;em&gt;single&lt;/em&gt; call to &lt;code&gt;push&lt;/code&gt; is O(n). The worst case occurs when capacity is exhausted and needs a resize. The resize cost has been amortized in the previous figures.</source>
          <target state="translated">&lt;em&gt;단일&lt;/em&gt; 호출 &lt;code&gt;push&lt;/code&gt; 의 최악의 경우 비용 은 O (n)입니다. 최악의 경우는 용량이 소진되어 크기를 조정해야 할 때 발생합니다. 크기 조정 비용은 이전 수치에서 상각되었습니다.</target>
        </trans-unit>
        <trans-unit id="9abd2f24e6d1b46930e8a99311ffd002b596e31a" translate="yes" xml:space="preserve">
          <source>The writing portion of the &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; should be shut down.</source>
          <target state="translated">&lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; 의 쓰기 부분을 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a689baec3acd327f6907f5ce5547d1d13e010a8" translate="yes" xml:space="preserve">
          <source>Their definition should always match the ABI defined in &lt;code&gt;rustc::back::abi&lt;/code&gt;.</source>
          <target state="translated">그들의 정의는 항상 &lt;code&gt;rustc::back::abi&lt;/code&gt; 정의 된 ABI와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1e1df95ca1bc76e0d356b0c10d06f6035304f599" translate="yes" xml:space="preserve">
          <source>Their definition should always match the ABI defined in &lt;code&gt;rustc_middle::ty::layout&lt;/code&gt;.</source>
          <target state="translated">그들의 정의는 항상 &lt;code&gt;rustc_middle::ty::layout&lt;/code&gt; 정의 된 ABI와 일치해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="534bcf9b4ee06ae0b390b746db849c9e3d0f83df" translate="yes" xml:space="preserve">
          <source>Then create a new directory, &lt;em&gt;src/bin&lt;/em&gt;, and move the binary crate rooted in &lt;em&gt;src/main.rs&lt;/em&gt; into &lt;em&gt;src/bin/main.rs&lt;/em&gt;. Doing so will make the library crate the primary crate in the &lt;em&gt;hello&lt;/em&gt; directory; we can still run the binary in &lt;em&gt;src/bin/main.rs&lt;/em&gt; using &lt;code&gt;cargo run&lt;/code&gt;. After moving the &lt;em&gt;main.rs&lt;/em&gt; file, edit it to bring the library crate in and bring &lt;code&gt;ThreadPool&lt;/code&gt; into scope by adding the following code to the top of &lt;em&gt;src/bin/main.rs&lt;/em&gt;:</source>
          <target state="translated">그런 다음 새 디렉토리 인 &lt;em&gt;src / bin을&lt;/em&gt; 작성하고 &lt;em&gt;src / main.rs&lt;/em&gt; 에있는 2 진 크레이트 를 &lt;em&gt;src / bin / main.rs로 이동하십시오&lt;/em&gt; . 이렇게하면 라이브러리 상자가 &lt;em&gt;hello&lt;/em&gt; 디렉토리 의 기본 상자가됩니다 . &lt;code&gt;cargo run&lt;/code&gt; 사용하여 &lt;em&gt;src / bin / main.rs&lt;/em&gt; 에서 바이너리를 계속 실행할 수 있습니다 . &lt;em&gt;main.rs&lt;/em&gt; 파일을 옮긴 후 &lt;em&gt;src / bin / main.rs&lt;/em&gt; 맨 위에 다음 코드를 추가하여 라이브러리 상자를 가져오고 &lt;code&gt;ThreadPool&lt;/code&gt; 을 범위 로 가져 &lt;em&gt;오려면&lt;/em&gt; 파일을 편집하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="848cf8d4f1542ccd5c9500b227f162479dfe2c8c" translate="yes" xml:space="preserve">
          <source>Then generate a new library crate named &lt;code&gt;add-one&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;add-one&lt;/code&gt; 이라는 새 라이브러리 상자를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="02ec96ae1b226ff410efb69c0d4d60e58a7042ce" translate="yes" xml:space="preserve">
          <source>Then implementing the &lt;code&gt;OutlinePrint&lt;/code&gt; trait on &lt;code&gt;Point&lt;/code&gt; will compile successfully, and we can call &lt;code&gt;outline_print&lt;/code&gt; on a &lt;code&gt;Point&lt;/code&gt; instance to display it within an outline of asterisks.</source>
          <target state="translated">그런 다음 &lt;code&gt;Point&lt;/code&gt; 에서 &lt;code&gt;OutlinePrint&lt;/code&gt; 특성을 구현하면 성공적으로 컴파일 되며 &lt;code&gt;Point&lt;/code&gt; 인스턴스에서 &lt;code&gt;outline_print&lt;/code&gt; 를 호출 하여 별표로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3aac37973a618f0b45f35c262a8297327ce65a0e" translate="yes" xml:space="preserve">
          <source>Then install the language server support in your particular IDE; you&amp;rsquo;ll gain abilities such as autocompletion, jump to definition, and inline errors.</source>
          <target state="translated">그런 다음 특정 IDE에 언어 서버 지원을 설치하십시오. 자동 완성, 정의로 이동 및 인라인 오류와 같은 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="636019afbd1be275dc1f855f27602c31a7743704" translate="yes" xml:space="preserve">
          <source>Then run &lt;code&gt;cargo test&lt;/code&gt; again. The output now shows &lt;code&gt;exploration&lt;/code&gt; instead of &lt;code&gt;it_works&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;cargo test&lt;/code&gt; 다시 실행 하십시오. 이제 출력 에 &lt;code&gt;it_works&lt;/code&gt; 대신 &lt;code&gt;exploration&lt;/code&gt; 됩니다 .</target>
        </trans-unit>
        <trans-unit id="7eae4a5123d629fb5914cfbce2d33e244889b442" translate="yes" xml:space="preserve">
          <source>Then the compiler applies the first rule, which specifies that each parameter gets its own lifetime. We&amp;rsquo;ll call it &lt;code&gt;'a&lt;/code&gt; as usual, so now the signature is this:</source>
          <target state="translated">그런 다음 컴파일러는 첫 번째 규칙을 적용합니다.이 규칙은 각 매개 변수가 고유 한 수명을 갖도록 지정합니다. 우리는 그것을 전화 할게 &lt;code&gt;'a&lt;/code&gt; 평소와 같이, 이제 서명이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="fe1bb69db1725d721fdb3af05034044cb61cb940" translate="yes" xml:space="preserve">
          <source>Then we add five new lines at the bottom that use the &lt;code&gt;Ordering&lt;/code&gt; type. The &lt;code&gt;cmp&lt;/code&gt; method compares two values and can be called on anything that can be compared. It takes a reference to whatever you want to compare with: here it&amp;rsquo;s comparing the &lt;code&gt;guess&lt;/code&gt; to the &lt;code&gt;secret_number&lt;/code&gt;. Then it returns a variant of the &lt;code&gt;Ordering&lt;/code&gt; enum we brought into scope with the &lt;code&gt;use&lt;/code&gt; statement. We use a &lt;a href=&quot;ch06-02-match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; expression to decide what to do next based on which variant of &lt;code&gt;Ordering&lt;/code&gt; was returned from the call to &lt;code&gt;cmp&lt;/code&gt; with the values in &lt;code&gt;guess&lt;/code&gt; and &lt;code&gt;secret_number&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;Ordering&lt;/code&gt; 유형 을 사용하는 맨 아래에 5 개의 새 줄을 추가 합니다. &lt;code&gt;cmp&lt;/code&gt; 방법은 두 값을 비교하고 비교 될 수있는 일에 호출 할 수 있습니다. 비교하려는 대상에 대한 참조가 필요합니다. 여기에서 &lt;code&gt;guess&lt;/code&gt; 을 &lt;code&gt;secret_number&lt;/code&gt; 와 비교합니다 . 그런 다음 &lt;code&gt;use&lt;/code&gt; 문을 사용 하여 범위에 넣은 &lt;code&gt;Ordering&lt;/code&gt; 열거 형 의 변형을 반환합니다 . &lt;a href=&quot;ch06-02-match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; 표현식을 사용하여 &lt;code&gt;guess&lt;/code&gt; 및 &lt;code&gt;secret_number&lt;/code&gt; 값을 사용하여 &lt;code&gt;cmp&lt;/code&gt; 호출에서 반환 된 &lt;code&gt;Ordering&lt;/code&gt; 변형을 기반으로 다음에 수행 할 작업을 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="42504942265ee7c7c73ee70d30a7653d906cc136" translate="yes" xml:space="preserve">
          <source>Then we create a &lt;em&gt;src/front_of_house&lt;/em&gt; directory and a file &lt;em&gt;src/front_of_house/hosting.rs&lt;/em&gt; to contain the definitions made in the &lt;code&gt;hosting&lt;/code&gt; module:</source>
          <target state="translated">그런 다음 &lt;em&gt;src / front_of_house&lt;/em&gt; 디렉토리와 &lt;em&gt;src / front_of_house / hosting.rs&lt;/em&gt; 파일을 작성하여 &lt;code&gt;hosting&lt;/code&gt; 모듈 에서 &lt;em&gt;작성된&lt;/em&gt; 정의를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="8c054131a62b68de933e0bf587b858ee6793392b" translate="yes" xml:space="preserve">
          <source>Then we create a new &lt;code&gt;String&lt;/code&gt; in variable &lt;code&gt;s&lt;/code&gt; and call the &lt;code&gt;read_to_string&lt;/code&gt; method on the file handle in &lt;code&gt;f&lt;/code&gt; to read the contents of the file into &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;read_to_string&lt;/code&gt; method also returns a &lt;code&gt;Result&lt;/code&gt; because it might fail, even though &lt;code&gt;File::open&lt;/code&gt; succeeded. So we need another &lt;code&gt;match&lt;/code&gt; to handle that &lt;code&gt;Result&lt;/code&gt;: if &lt;code&gt;read_to_string&lt;/code&gt; succeeds, then our function has succeeded, and we return the username from the file that&amp;rsquo;s now in &lt;code&gt;s&lt;/code&gt; wrapped in an &lt;code&gt;Ok&lt;/code&gt;. If &lt;code&gt;read_to_string&lt;/code&gt; fails, we return the error value in the same way that we returned the error value in the &lt;code&gt;match&lt;/code&gt; that handled the return value of &lt;code&gt;File::open&lt;/code&gt;. However, we don&amp;rsquo;t need to explicitly say &lt;code&gt;return&lt;/code&gt;, because this is the last expression in the function.</source>
          <target state="translated">그런 다음 변수 &lt;code&gt;s&lt;/code&gt; 에 새 &lt;code&gt;String&lt;/code&gt; 을 만들고 &lt;code&gt;f&lt;/code&gt; 의 파일 핸들에서 &lt;code&gt;read_to_string&lt;/code&gt; 메서드를 호출 하여 파일 의 내용을 &lt;code&gt;s&lt;/code&gt; 로 읽습니다 . &lt;code&gt;read_to_string&lt;/code&gt; 방법도 반환 &lt;code&gt;Result&lt;/code&gt; 는 실패 할 수 있기 때문에, 비록 &lt;code&gt;File::open&lt;/code&gt; 성공했다. 우리가 또 다른 필요 그래서 &lt;code&gt;match&lt;/code&gt; 그 처리 &lt;code&gt;Result&lt;/code&gt; 다음과 같은 경우 &lt;code&gt;read_to_string&lt;/code&gt; 이 성공하고 우리의 기능은 성공, 우리는 지금의 파일에서 사용자 이름을 반환 한 &lt;code&gt;s&lt;/code&gt; 에 싸여 &lt;code&gt;Ok&lt;/code&gt; . &lt;code&gt;read_to_string&lt;/code&gt; 인 경우실패하면 &lt;code&gt;File::open&lt;/code&gt; 의 반환 값을 처리 한 &lt;code&gt;match&lt;/code&gt; 에서 오류 값을 반환 한 것과 같은 방식으로 오류 값을 반환합니다 . 그러나 함수에서 마지막 표현식이므로 &lt;code&gt;return&lt;/code&gt; 이라고 명시 적으로 말할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="deae9012508053fe94f96907583eae7e4c8a687f" translate="yes" xml:space="preserve">
          <source>Then we implement an associated function named &lt;code&gt;new&lt;/code&gt; on &lt;code&gt;Guess&lt;/code&gt; that creates instances of &lt;code&gt;Guess&lt;/code&gt; values. The &lt;code&gt;new&lt;/code&gt; function is defined to have one parameter named &lt;code&gt;value&lt;/code&gt; of type &lt;code&gt;i32&lt;/code&gt; and to return a &lt;code&gt;Guess&lt;/code&gt;. The code in the body of the &lt;code&gt;new&lt;/code&gt; function tests &lt;code&gt;value&lt;/code&gt; to make sure it&amp;rsquo;s between 1 and 100. If &lt;code&gt;value&lt;/code&gt; doesn&amp;rsquo;t pass this test, we make a &lt;code&gt;panic!&lt;/code&gt; call, which will alert the programmer who is writing the calling code that they have a bug they need to fix, because creating a &lt;code&gt;Guess&lt;/code&gt; with a &lt;code&gt;value&lt;/code&gt; outside this range would violate the contract that &lt;code&gt;Guess::new&lt;/code&gt; is relying on. The conditions in which &lt;code&gt;Guess::new&lt;/code&gt; might panic should be discussed in its public-facing API documentation; we&amp;rsquo;ll cover documentation conventions indicating the possibility of a &lt;code&gt;panic!&lt;/code&gt; in the API documentation that you create in Chapter 14. If &lt;code&gt;value&lt;/code&gt; does pass the test, we create a new &lt;code&gt;Guess&lt;/code&gt; with its &lt;code&gt;value&lt;/code&gt; field set to the &lt;code&gt;value&lt;/code&gt; parameter and return the &lt;code&gt;Guess&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;Guess&lt;/code&gt; 값의 인스턴스를 생성 하는 &lt;code&gt;Guess&lt;/code&gt; 에 &lt;code&gt;new&lt;/code&gt; 라는 관련 함수를 구현 합니다. &lt;code&gt;new&lt;/code&gt; 함수라는 하나의 파라미터가 정의된다 &lt;code&gt;value&lt;/code&gt; 유형의 &lt;code&gt;i32&lt;/code&gt; 하고 반환 &lt;code&gt;Guess&lt;/code&gt; . &lt;code&gt;new&lt;/code&gt; 함수 본문의 코드는 &lt;code&gt;value&lt;/code&gt; 을 1에서 100 사이의 값 으로 테스트 합니다 . &lt;code&gt;value&lt;/code&gt; 이이 테스트를 통과하지 못하면 &lt;code&gt;panic!&lt;/code&gt; 호출 코드를 작성하는 프로그래머에게 수정해야 할 버그가 있음을 경고합니다 . &lt;code&gt;value&lt;/code&gt; 으로 &lt;code&gt;Guess&lt;/code&gt; 을 작성하기 때문 입니다.이 범위를 벗어나면 &lt;code&gt;Guess::new&lt;/code&gt; 가 의존 하는 계약을 위반하게 됩니다. &lt;code&gt;Guess::new&lt;/code&gt; might panic 의 조건은 공개 API 문서에서 논의해야합니다. &lt;code&gt;panic!&lt;/code&gt; 가능성을 나타내는 문서 규칙을 다룰 것입니다 ! 경우에는 제 14 장에서 생성되는 API 문서에 &lt;code&gt;value&lt;/code&gt; 테스트를 통과 않습니다, 우리는 새로운 만들 &lt;code&gt;Guess&lt;/code&gt; 그와 &lt;code&gt;value&lt;/code&gt; 받는 사람 필드 설정 &lt;code&gt;value&lt;/code&gt; 매개 변수와 반환 &lt;code&gt;Guess&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06b6b70a87228a4df8ed0e498c6c809f243dabd9" translate="yes" xml:space="preserve">
          <source>Then we return two mutable slices in a tuple: one from the start of the original slice to the &lt;code&gt;mid&lt;/code&gt; index and another from &lt;code&gt;mid&lt;/code&gt; to the end of the slice.</source>
          <target state="translated">그런 다음 튜플에서 두 개의 가변 슬라이스를 반환합니다. 하나는 원래 슬라이스의 시작에서 &lt;code&gt;mid&lt;/code&gt; 인덱스로, 다른 하나 는 슬라이스의 &lt;code&gt;mid&lt;/code&gt; 에서 끝까지입니다.</target>
        </trans-unit>
        <trans-unit id="d29498b87e97b7beddcde1cb5378fcb2cbabe3a8" translate="yes" xml:space="preserve">
          <source>Then you must define an implementation for &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/a&gt;. You may find it useful to use &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/a&gt; on your type's fields.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt; &lt;code&gt;cmp&lt;/code&gt; &lt;/a&gt; 구현을 정의해야합니다 . 유형의 필드에 &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt; &lt;code&gt;cmp&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="884190657324310c04e2504f5fc0e76845d895ae" translate="yes" xml:space="preserve">
          <source>Then you must define an implementation for &lt;code&gt;cmp()&lt;/code&gt;. You may find it useful to use &lt;code&gt;cmp()&lt;/code&gt; on your type's fields.</source>
          <target state="translated">그런 다음 &lt;code&gt;cmp()&lt;/code&gt; 구현을 정의해야합니다 . 타입 필드에 &lt;code&gt;cmp()&lt;/code&gt; 를 사용하면 유용 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0d177ce772cf21906084a9438690b47406434422" translate="yes" xml:space="preserve">
          <source>Then you&amp;rsquo;ll learn how to use &lt;em&gt;traits&lt;/em&gt; to define behavior in a generic way. You can combine traits with generic types to constrain a generic type to only those types that have a particular behavior, as opposed to just any type.</source>
          <target state="translated">그런 다음 &lt;em&gt;특성&lt;/em&gt; 을 사용하여 일반적인 방식으로 동작을 정의 하는 방법을 배웁니다 . 특성을 일반 유형과 결합하여 일반 유형을 특정 유형이 아닌 특정 동작이있는 유형으로 만 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddeec83a6e1ebd77d0b40c2a12564ec960334a02" translate="yes" xml:space="preserve">
          <source>Then, for each candidate type &lt;code&gt;T&lt;/code&gt;, search for a &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visible&lt;/a&gt; method with a receiver of that type in the following places:</source>
          <target state="translated">그런 다음 각 후보 유형 &lt;code&gt;T&lt;/code&gt; 에 대해 다음 위치에서 해당 유형의 수신자로 &lt;a href=&quot;../visibility-and-privacy&quot;&gt;가시적 인&lt;/a&gt; 메소드를 검색 하십시오.</target>
        </trans-unit>
        <trans-unit id="c7f32ff9ae959e326529e5b742ae1c333e7b2254" translate="yes" xml:space="preserve">
          <source>Then, in your new &lt;em&gt;variables&lt;/em&gt; directory, open &lt;em&gt;src/main.rs&lt;/em&gt; and replace its code with the following code that won&amp;rsquo;t compile just yet:</source>
          <target state="translated">그런 다음 새 &lt;em&gt;변수&lt;/em&gt; 디렉토리에서 &lt;em&gt;src / main.rs를&lt;/em&gt; 열고 아직 컴파일되지 않은 다음 코드로 해당 코드를 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="0c8f840e153942ef31581018e9e810864accdec7" translate="yes" xml:space="preserve">
          <source>Then, to bring &lt;code&gt;rand&lt;/code&gt; definitions into the scope of our package, we added a &lt;code&gt;use&lt;/code&gt; line starting with the name of the crate, &lt;code&gt;rand&lt;/code&gt;, and listed the items we wanted to bring into scope. Recall that in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;&amp;ldquo;Generating a Random Number&amp;rdquo;&lt;/a&gt; section in Chapter 2, we brought the &lt;code&gt;Rng&lt;/code&gt; trait into scope and called the &lt;code&gt;rand::thread_rng&lt;/code&gt; function:</source>
          <target state="translated">그런 다음 &lt;code&gt;rand&lt;/code&gt; 정의를 패키지 범위로 가져 오기 위해 상자 이름 &lt;code&gt;rand&lt;/code&gt; 로 시작 하는 &lt;code&gt;use&lt;/code&gt; 줄 을 추가하고 범위로 가져 오려는 항목을 나열했습니다. 리콜은에 있음 &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;&quot;난수 발생&quot;&lt;/a&gt; 제 2 장 섹션, 우리는 가져 &lt;code&gt;Rng&lt;/code&gt; 범위에 특성 및 호출 &lt;code&gt;rand::thread_rng&lt;/code&gt; 기능 :</target>
        </trans-unit>
        <trans-unit id="cbbc8078ba28a9ecb4224d46afd42558773fa640" translate="yes" xml:space="preserve">
          <source>Then, to bring &lt;code&gt;rand&lt;/code&gt; definitions into the scope of our package, we added a &lt;code&gt;use&lt;/code&gt; line starting with the name of the package, &lt;code&gt;rand&lt;/code&gt;, and listed the items we wanted to bring into scope. Recall that in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;&amp;ldquo;Generating a Random Number&amp;rdquo;&lt;/a&gt; section in Chapter 2, we brought the &lt;code&gt;Rng&lt;/code&gt; trait into scope and called the &lt;code&gt;rand::thread_rng&lt;/code&gt; function:</source>
          <target state="translated">그런 다음 &lt;code&gt;rand&lt;/code&gt; 정의를 패키지 범위로 가져 오기 위해 패키지 이름 &lt;code&gt;rand&lt;/code&gt; 로 시작 하는 &lt;code&gt;use&lt;/code&gt; 라인 을 추가하고 범위로 가져 오려는 항목을 나열했습니다. 리콜은에 있음 &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;&quot;난수 발생&quot;&lt;/a&gt; 제 2 장 섹션, 우리는 가져 &lt;code&gt;Rng&lt;/code&gt; 범위에 특성 및 호출 &lt;code&gt;rand::thread_rng&lt;/code&gt; 기능 :</target>
        </trans-unit>
        <trans-unit id="ea0671790854fadbc007a7d3ab3c99a7a0c53f74" translate="yes" xml:space="preserve">
          <source>Theoretically, this code should compile. Unfortunately, the Rust compiler isn&amp;rsquo;t perfect yet, and we get this error:</source>
          <target state="translated">이론적으로이 코드는 컴파일되어야합니다. 불행히도 Rust 컴파일러는 아직 완벽하지 않으며 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7bb0fb711ce84d52df9718e0b2a2ec2dabc6a07f" translate="yes" xml:space="preserve">
          <source>There are a couple of solutions for this.</source>
          <target state="translated">이를위한 몇 가지 솔루션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="530488aa6f064fc1ecb7dc7a5a0bf4b2dc63964c" translate="yes" xml:space="preserve">
          <source>There are a few things that &lt;code&gt;transmute&lt;/code&gt; is really useful for.</source>
          <target state="translated">&lt;code&gt;transmute&lt;/code&gt; 이 실제로 유용한 몇 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e38257a0874550d292627aecb2605763613ccaf1" translate="yes" xml:space="preserve">
          <source>There are a handful of shortcuts provided to make writing constructors more convenient, most common of which is the Field Init shorthand. When there is a variable and a field of the same name, the assignment can be simplified from &lt;code&gt;field: field&lt;/code&gt; into simply &lt;code&gt;field&lt;/code&gt;. The following example of a hypothetical constructor demonstrates this:</source>
          <target state="translated">생성자를보다 편리하게 작성하기 위해 제공되는 몇 가지 단축키가 있으며, 가장 일반적인 것은 Field Init 속기입니다. 변수와 이름이 같은 필드가 있으면 &lt;code&gt;field: field&lt;/code&gt; 에서 simply &lt;code&gt;field&lt;/code&gt; 로 할당을 단순화 할 수 있습니다 . 가상 생성자의 다음 예는이를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="63a966968ec2346aede6a0d18395aa406c237072" translate="yes" xml:space="preserve">
          <source>There are a number of &lt;a href=&quot;#functions-1&quot;&gt;functions&lt;/a&gt; that offer access to various features. For example, we can use three of these functions to copy everything from standard input to standard output:</source>
          <target state="translated">가 있습니다 &lt;a href=&quot;#functions-1&quot;&gt;기능&lt;/a&gt; 다양한 기능에 대한 액세스를 제공합니다. 예를 들어, 다음 세 가지 함수를 사용하여 표준 입력에서 표준 출력으로 모든 것을 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f79d0ffb253cf5d15cccef1c760f3edf4c3cd7b" translate="yes" xml:space="preserve">
          <source>There are a number of &lt;code&gt;debug_*&lt;/code&gt; methods on &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; to help you with manual implementations, such as &lt;a href=&quot;struct.formatter#method.debug_struct&quot;&gt;&lt;code&gt;debug_struct&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 에는 &lt;a href=&quot;struct.formatter#method.debug_struct&quot;&gt; &lt;code&gt;debug_struct&lt;/code&gt; &lt;/a&gt; 와 같은 수동 구현에 도움 이되는 많은 &lt;code&gt;debug_*&lt;/code&gt; 메소드 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e1d6f0ae7b1514d15119ee9f085506bcbaba7ce" translate="yes" xml:space="preserve">
          <source>There are a number of helper methods on the &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; struct to help you with manual implementations, such as &lt;a href=&quot;struct.formatter#method.debug_struct&quot;&gt;&lt;code&gt;debug_struct&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; struct에는 &lt;a href=&quot;struct.formatter#method.debug_struct&quot;&gt; &lt;code&gt;debug_struct&lt;/code&gt; &lt;/a&gt; 와 같은 수동 구현에 도움 이되는 여러 도우미 메서드 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="087920b8740a66ec282180bff3885f708e5bb842" translate="yes" xml:space="preserve">
          <source>There are a number of related macros in the &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; family. The ones that are currently implemented are:</source>
          <target state="translated">&lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt; 에는 여러 관련 매크로가 있습니다 ! 가족. 현재 구현 된 것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="28043d56de08a63f7e30e165bfcf6d512b961039" translate="yes" xml:space="preserve">
          <source>There are also some platform-specific ABI strings:</source>
          <target state="translated">플랫폼 별 ABI 문자열도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e3263bd4c02d9329fee29d313cf8ea903653894" translate="yes" xml:space="preserve">
          <source>There are both a positive and negative trait implementation for the same type.</source>
          <target state="translated">동일한 유형에 대해 긍정 및 부정적 특성 구현이 모두 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dfc0ac14db9531a0dcf3d9f3c7feabed396e9c2" translate="yes" xml:space="preserve">
          <source>There are conflicting trait implementations for the same type.</source>
          <target state="translated">동일한 유형에 대해 충돌하는 특성 구현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb600a231699778e7c442e8d1b0c5af1c6ce3e98" translate="yes" xml:space="preserve">
          <source>There are conflicting trait implementations for the same type. Example of erroneous code:</source>
          <target state="translated">동일한 유형에 대해 충돌하는 특성 구현이 있습니다. 잘못된 코드의 예 :</target>
        </trans-unit>
        <trans-unit id="c7d32d1dc6c93776049af2c0d8da18ad1a5c107b" translate="yes" xml:space="preserve">
          <source>There are insufficient permissions to access the current directory.</source>
          <target state="translated">현재 디렉토리에 액세스 할 수있는 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c57d9d7a8463095f936949e3bd422fd7ce763db3" translate="yes" xml:space="preserve">
          <source>There are multiple trade-offs to consider in addition to the prevention of bugs. For example, in cases where you&amp;rsquo;re using large data structures, mutating an instance in place may be faster than copying and returning newly allocated instances. With smaller data structures, creating new instances and writing in a more functional programming style may be easier to think through, so lower performance might be a worthwhile penalty for gaining that clarity.</source>
          <target state="translated">버그 방지 외에도 고려해야 할 여러 가지 상충 관계가 있습니다. 예를 들어, 큰 데이터 구조를 사용하는 경우 인스턴스를 변경하는 것이 새로 할당 된 인스턴스를 복사하고 반환하는 것보다 빠를 수 있습니다. 더 작은 데이터 구조를 사용하면 새로운 인스턴스를 작성하고 더 기능적인 프로그래밍 스타일로 작성하는 것이 생각하기가 쉬울 수 있으므로 성능을 낮추면 명확성을 얻는 데 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d53022046c1585c76ce2c3d1de0757bc5d58a5d7" translate="yes" xml:space="preserve">
          <source>There are multiple ways to create a new &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; from a string literal:</source>
          <target state="translated">문자열 리터럴에서 새 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 을 만드는 방법에는 여러 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b89e39f486cb11ae236a0c1ba092d84b1be61d5a" translate="yes" xml:space="preserve">
          <source>There are multiple ways we could change how our web server works to avoid having more requests back up behind a slow request; the one we&amp;rsquo;ll implement is a thread pool.</source>
          <target state="translated">느린 요청 뒤에 더 많은 요청을 백업하지 않도록 웹 서버의 작동 방식을 변경할 수있는 여러 가지 방법이 있습니다. 우리가 구현할 것은 스레드 풀입니다.</target>
        </trans-unit>
        <trans-unit id="cbbb8fb2683dd85eb0ca22283c9bb44fdd37598e" translate="yes" xml:space="preserve">
          <source>There are no function calls, macros, or even &lt;code&gt;let&lt;/code&gt; statements in the &lt;code&gt;five&lt;/code&gt; function&amp;mdash;just the number &lt;code&gt;5&lt;/code&gt; by itself. That&amp;rsquo;s a perfectly valid function in Rust. Note that the function&amp;rsquo;s return type is specified too, as &lt;code&gt;-&amp;gt; i32&lt;/code&gt;. Try running this code; the output should look like this:</source>
          <target state="translated">&lt;code&gt;five&lt;/code&gt; 함수 에는 함수 호출, 매크로 또는 &lt;code&gt;let&lt;/code&gt; 문 이 없으며 숫자 &lt;code&gt;5&lt;/code&gt; 만 있습니다. 그것은 Rust에서 완벽하게 유효한 기능입니다. 함수의 리턴 유형도 &lt;code&gt;-&amp;gt; i32&lt;/code&gt; 로 지정됩니다 . 이 코드를 실행 해보십시오. 출력은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="e3048305fc74fc67f0b28e1af09fa647633b200c" translate="yes" xml:space="preserve">
          <source>There are no generic type parameters.</source>
          <target state="translated">일반 유형 매개 변수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6dc334d98456ba931a1cb0e3e3cebe2b287fda18" translate="yes" xml:space="preserve">
          <source>There are no guarantees of data layout made by this representation.</source>
          <target state="translated">이 표현에 의한 데이터 레이아웃은 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73292d3af30172448139b6d5386689eb5562d30e" translate="yes" xml:space="preserve">
          <source>There are no guarantees whatsoever that offsetting the pointer will not overflow or go beyond the allocation that the pointer points into. It is up to the caller to ensure that the returned offset is correct in all terms other than alignment.</source>
          <target state="translated">포인터를 오프셋하는 것이 오버플로되거나 포인터가 가리키는 할당을 초과하지 않는다는 보장은 없습니다. 반환 된 오프셋이 정렬 이외의 모든 측면에서 올바른지 확인하는 것은 호출자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="a86100f636fbb472fb5b1863356f0448a9ae85a5" translate="yes" xml:space="preserve">
          <source>There are no guarantees whatsover that offsetting the pointer will not overflow or go beyond the allocation that the pointer points into. It is up to the caller to ensure that the returned offset is correct in all terms other than alignment.</source>
          <target state="translated">포인터를 오프셋하면 포인터가 가리키는 할당량을 초과하거나 초과하지 않는다는 보장이 없습니다. 반환 된 오프셋이 정렬 이외의 모든 용어에서 올바른지 확인하는 것은 호출자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="19e4b768de5872c5fc351b9acc570966e33874d6" translate="yes" xml:space="preserve">
          <source>There are several functions and structs in this module that have a counterpart ending in &lt;code&gt;os&lt;/code&gt;. Those ending in &lt;code&gt;os&lt;/code&gt; will return an &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and those without will be returning a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈에는 &lt;code&gt;os&lt;/code&gt; 로 끝나는 대응 기능이있는 몇 가지 기능과 구조체가 있습니다 . &lt;code&gt;os&lt;/code&gt; 로 끝나는 사람들 은 &lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 을 반환 하고 그렇지 않은 사람들은 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dc0876b472387aa80fcef964fda60c94ca27eb85" translate="yes" xml:space="preserve">
          <source>There are several functions and structs in this module that have a counterpart ending in &lt;code&gt;os&lt;/code&gt;. Those ending in &lt;code&gt;os&lt;/code&gt; will return an &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and those without will return a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈에는 &lt;code&gt;os&lt;/code&gt; 로 끝나는 대응 요소가있는 몇 가지 함수와 구조체가 있습니다 . &lt;code&gt;os&lt;/code&gt; 로 끝나는 것은 &lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 을 반환하고없는 것은 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="171ee597fab4c6d0bdea510dd3f56d6a9c12c0b6" translate="yes" xml:space="preserve">
          <source>There are several implementations of common traits for slices. Some examples include:</source>
          <target state="translated">슬라이스에 대한 공통 특성의 몇 가지 구현이 있습니다. 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f5d6b4dc4e0f0d18f10b896c43b04863d873b17" translate="yes" xml:space="preserve">
          <source>There are several kinds of items:</source>
          <target state="translated">여러 종류의 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ab16cf7d574dfc1dbe1b281f7a85326a916ba94" translate="yes" xml:space="preserve">
          <source>There are several structs that are useful for slices, such as &lt;a href=&quot;struct.iter&quot;&gt;&lt;code&gt;Iter&lt;/code&gt;&lt;/a&gt;, which represents iteration over a slice.</source>
          <target state="translated">슬라이스에 대한 반복을 나타내는 &lt;a href=&quot;struct.iter&quot;&gt; &lt;code&gt;Iter&lt;/code&gt; &lt;/a&gt; 와 같이 슬라이스에 유용한 여러 구조체가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="567ae72d32f4d2be3989eaf8a9904e62f889b537" translate="yes" xml:space="preserve">
          <source>There are six &lt;code&gt;char&lt;/code&gt; values here, but the fourth and sixth are not letters: they&amp;rsquo;re diacritics that don&amp;rsquo;t make sense on their own. Finally, if we look at them as grapheme clusters, we&amp;rsquo;d get what a person would call the four letters that make up the Hindi word:</source>
          <target state="translated">여기에는 6 개의 &lt;code&gt;char&lt;/code&gt; 값이 있지만 4 번째와 6 번째 문자는 글자가 아닙니다.이 문자는 이해가되지 않는 분음 부호입니다. 마지막으로, 우리가 그것들을 grapheme 클러스터로 본다면, 우리는 힌디어 단어를 구성하는 4 개의 글자를 사람들이 얻게 될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="6ce75e9d71dbebf75ae807b3a16056d1528fd37b" translate="yes" xml:space="preserve">
          <source>There are some known bugs that trigger this message.</source>
          <target state="translated">이 메시지를 유발하는 알려진 버그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="926439ef5401fe133e30f193394b46730a6ce040" translate="yes" xml:space="preserve">
          <source>There are some strange edge cases with &lt;code&gt;macro_rules!&lt;/code&gt;. In the future, Rust will have a second kind of declarative macro that will work in a similar fashion but fix some of these edge cases. After that update, &lt;code&gt;macro_rules!&lt;/code&gt; will be effectively deprecated. With this in mind, as well as the fact that most Rust programmers will &lt;em&gt;use&lt;/em&gt; macros more than &lt;em&gt;write&lt;/em&gt; macros, we won&amp;rsquo;t discuss &lt;code&gt;macro_rules!&lt;/code&gt; any further. To learn more about how to write macros, consult the online documentation or other resources, such as &lt;a href=&quot;https://danielkeep.github.io/tlborm/book/index.html&quot;&gt;&amp;ldquo;The Little Book of Rust Macros&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;macro_rules!&lt;/code&gt; 와 함께 몇 가지 이상한 경우가 있습니다! . 앞으로 Rust는 비슷한 방식으로 작동하지만 이러한 엣지 케이스 중 일부를 수정하는 두 번째 종류의 선언적 매크로를 갖게 될 것입니다. 업데이트 후 &lt;code&gt;macro_rules!&lt;/code&gt; 효과적으로 사용되지 않습니다. 이 점을 염두에두고 대부분의 Rust 프로그래머가 매크로를 &lt;em&gt;쓰는&lt;/em&gt; 것보다 매크로를 더 많이 &lt;em&gt;사용&lt;/em&gt; 한다는 사실과 함께 &lt;code&gt;macro_rules!&lt;/code&gt; 않습니다 ! 더. 매크로를 작성하는 방법에 대한 자세한 내용은 온라인 설명서 또는 &lt;a href=&quot;https://danielkeep.github.io/tlborm/book/index.html&quot;&gt;&amp;ldquo;The Rusbook of Rust Macros&amp;rdquo;&lt;/a&gt; 와 같은 기타 자료를 참조하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="720348f040959c3669acec057ca2d47ad7fb3d69" translate="yes" xml:space="preserve">
          <source>There are three ABI strings which are cross-platform, and which all compilers are guaranteed to support:</source>
          <target state="translated">크로스 플랫폼 인 3 개의 ABI 문자열이 있으며 모든 컴파일러에서 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0142bb3f41cab04708310e3fe823a323c32ee0b3" translate="yes" xml:space="preserve">
          <source>There are three common methods which can create iterators from a collection:</source>
          <target state="translated">컬렉션에서 반복자를 만들 수있는 일반적인 세 ​​가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="987579e087a6ff5bbf6e70931c97c8842a5d0e0c" translate="yes" xml:space="preserve">
          <source>There are three possible ways to specify the desired &lt;code&gt;precision&lt;/code&gt;:</source>
          <target state="translated">원하는 &lt;code&gt;precision&lt;/code&gt; 를 지정하는 세 가지 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a65e426e444ff8c29bebad4488c8514ade91574" translate="yes" xml:space="preserve">
          <source>There are three ways to use the inline attribute:</source>
          <target state="translated">인라인 속성을 사용하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="481486972e8a90ddff463b54cf1c4f208b0477e6" translate="yes" xml:space="preserve">
          <source>There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both &lt;code&gt;&amp;amp;self&lt;/code&gt; and &lt;code&gt;announcement&lt;/code&gt; their own lifetimes. Then, because one of the parameters is &lt;code&gt;&amp;amp;self&lt;/code&gt;, the return type gets the lifetime of &lt;code&gt;&amp;amp;self&lt;/code&gt;, and all lifetimes have been accounted for.</source>
          <target state="translated">두 개의 입력 수명이 있으므로 Rust는 첫 번째 수명 제거 규칙을 적용하고 &lt;code&gt;&amp;amp;self&lt;/code&gt; 와 &lt;code&gt;announcement&lt;/code&gt; 에 자체 수명을 제공합니다. 그런 다음 매개 변수 중 하나가 &lt;code&gt;&amp;amp;self&lt;/code&gt; 이므로 리턴 유형은 &lt;code&gt;&amp;amp;self&lt;/code&gt; 의 수명을 가져오고 모든 수명이 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="ffdf24d7c3a95e9cacfa7c11d178ec9960ec72fd" translate="yes" xml:space="preserve">
          <source>There are two issues with the above example:</source>
          <target state="translated">위의 예에는 두 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1575bd4949a087cd0961e57e825f5b7d2464821" translate="yes" xml:space="preserve">
          <source>There are two main ways to read this document.</source>
          <target state="translated">이 문서를 읽는 데는 두 가지 주요 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="86663982f114c71c4b638d9b0fa35d92d8fc55c4" translate="yes" xml:space="preserve">
          <source>There are two options that would work instead. The first would be to change the line &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; to &lt;code&gt;example_func(example_string.as_str());&lt;/code&gt;, using the method &lt;a href=&quot;struct.string#method.as_str&quot;&gt;&lt;code&gt;as_str()&lt;/code&gt;&lt;/a&gt; to explicitly extract the string slice containing the string. The second way changes &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; to &lt;code&gt;example_func(&amp;amp;*example_string);&lt;/code&gt;. In this case we are dereferencing a &lt;code&gt;String&lt;/code&gt; to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, then referencing the &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; back to &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. The second way is more idiomatic, however both work to do the conversion explicitly rather than relying on the implicit conversion.</source>
          <target state="translated">대신 작동하는 두 가지 옵션이 있습니다. 첫 번째는 &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; 행을 변경하는 것입니다 . 행 &lt;code&gt;example_func(example_string.as_str());&lt;/code&gt; &lt;a href=&quot;struct.string#method.as_str&quot;&gt; &lt;code&gt;as_str()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 문자열이 포함 된 문자열 슬라이스를 명시 적으로 추출하십시오. 두 번째 방법은 &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; 에 &lt;code&gt;example_func(&amp;amp;*example_string);&lt;/code&gt; . 이 경우 &lt;code&gt;String&lt;/code&gt; 을 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 로 참조한 다음 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 다시 참조합니다 . 두 번째 방법은 관용적이지만 암시 적 변환에 의존하기보다는 명시 적으로 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="022a56e5687a1a83c185eae56c2be99a7be6379c" translate="yes" xml:space="preserve">
          <source>There are two options to work around this issue. The first is simply to rename one of the types. Alternatively, one can specify the intended type using the following syntax:</source>
          <target state="translated">이 문제를 해결하려면 두 가지 옵션이 있습니다. 첫 번째는 단순히 유형 중 하나의 이름을 바꾸는 것입니다. 또는 다음 구문을 사용하여 원하는 유형을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7601f9a3aa302729abcf51730ab0dacad11e1f7d" translate="yes" xml:space="preserve">
          <source>There are two possible solutions:</source>
          <target state="translated">가능한 두 가지 해결책이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f08d38f311f1d8aebf1cc8c4c04305ba58884d5" translate="yes" xml:space="preserve">
          <source>There are two syntactic forms for creating an array:</source>
          <target state="translated">배열을 생성하는 두 가지 구문 양식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="63a18bac877b16a7425895e1b31ade8a29a01453" translate="yes" xml:space="preserve">
          <source>There are two types of &lt;code&gt;static&lt;/code&gt; items: those declared in association with the &lt;a href=&quot;keyword.mut&quot;&gt;&lt;code&gt;mut&lt;/code&gt;&lt;/a&gt; keyword and those without.</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 항목에는 &lt;a href=&quot;keyword.mut&quot;&gt; &lt;code&gt;mut&lt;/code&gt; &lt;/a&gt; 키워드와 관련하여 선언 된 항목과없는 항목 의 두 가지 유형이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86a631e5c1cd817983c93f98903db4ea59d68db2" translate="yes" xml:space="preserve">
          <source>There are two types of implementations:</source>
          <target state="translated">두 가지 유형의 구현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa155718008a683c96cef5cc6a71a54ea03f305c" translate="yes" xml:space="preserve">
          <source>There are two ways to define new macros:</source>
          <target state="translated">새로운 매크로를 정의하는 두 가지 방법이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="9880ebdf9a583de2d652297bd89e0b5ff4d36ffb" translate="yes" xml:space="preserve">
          <source>There are two ways to implement &lt;code&gt;Copy&lt;/code&gt; on your type. The simplest is to use &lt;code&gt;derive&lt;/code&gt;:</source>
          <target state="translated">유형에 &lt;code&gt;Copy&lt;/code&gt; 를 구현하는 방법에는 두 가지가 있습니다. 가장 간단한 방법은 &lt;code&gt;derive&lt;/code&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="b2a9fbbbcf33cff3a0df902072d56db76dfeaf3c" translate="yes" xml:space="preserve">
          <source>There are two ways to solve this error. The first is to make the public type signature only public to a module that also has access to the private type. This is done by using pub(crate) or pub(in crate::my_mod::etc) Example:</source>
          <target state="translated">이 오류를 해결하는 방법에는 두 가지가 있습니다. 첫 번째는 공용 형식 서명을 전용 형식에 대한 액세스 권한도있는 모듈에만 공용으로 만드는 것입니다. 이것은 pub (crate) 또는 pub (in crate :: my_mod :: etc)를 사용하여 수행됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="dc647999e3aa70d53b9f18def550d41889259047" translate="yes" xml:space="preserve">
          <source>There are various restrictions on transmuting between types in Rust; for example types being transmuted must have the same size. To apply all these restrictions, the compiler must know the exact types that may be transmuted. When type parameters are involved, this cannot always be done.</source>
          <target state="translated">Rust에서 유형 간 변환에 대한 다양한 제한이 있습니다. 예를 들어, 변형 된 유형은 크기가 같아야합니다. 이러한 모든 제한을 적용하려면 컴파일러는 변환 될 수있는 정확한 유형을 알고 있어야합니다. 유형 매개 변수가 관련된 경우 항상 수행 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="0019607d06d61b11d32e87172ee0ea679ebbb977" translate="yes" xml:space="preserve">
          <source>There are various rules:</source>
          <target state="translated">다양한 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d6ed4037ecbcc5953e35640da903ed6a8a40981" translate="yes" xml:space="preserve">
          <source>There can only be one owner at a time.</source>
          <target state="translated">한 번에 한 명의 소유자 만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4471e590e73989497aca327361dde4b0c93c59c" translate="yes" xml:space="preserve">
          <source>There is a difference between what the &lt;code&gt;match&lt;/code&gt; expression from Listing 9-6 and the &lt;code&gt;?&lt;/code&gt; operator do: error values that have the &lt;code&gt;?&lt;/code&gt; operator called on them go through the &lt;code&gt;from&lt;/code&gt; function, defined in the &lt;code&gt;From&lt;/code&gt; trait in the standard library, which is used to convert errors from one type into another. When the &lt;code&gt;?&lt;/code&gt; operator calls the &lt;code&gt;from&lt;/code&gt; function, the error type received is converted into the error type defined in the return type of the current function. This is useful when a function returns one error type to represent all the ways a function might fail, even if parts might fail for many different reasons. As long as each error type implements the &lt;code&gt;from&lt;/code&gt; function to define how to convert itself to the returned error type, the &lt;code&gt;?&lt;/code&gt; operator takes care of the conversion automatically.</source>
          <target state="translated">Listing 9-6 의 &lt;code&gt;match&lt;/code&gt; 표현식과 &lt;code&gt;?&lt;/code&gt; 연산자 수행 : &lt;code&gt;?&lt;/code&gt; 호출 된 연산자 는 표준 라이브러리 의 &lt;code&gt;From&lt;/code&gt; 특성에 정의 된 &lt;code&gt;from&lt;/code&gt; 함수를 통해 오류를 한 유형에서 다른 유형으로 변환하는 데 사용됩니다. 언제 &lt;code&gt;?&lt;/code&gt; 연산자가 &lt;code&gt;from&lt;/code&gt; 함수를 호출하면 수신 된 오류 유형이 현재 함수의 반환 유형에 정의 된 오류 유형으로 변환됩니다. 이는 여러 가지 이유로 파트가 실패하더라도 함수가 하나의 오류 유형을 리턴하여 함수가 실패 할 수있는 모든 방법을 나타내는 경우에 유용합니다. 각 오류 유형이 &lt;code&gt;from&lt;/code&gt; 을 구현하는 한반환 된 오류 유형으로 변환하는 방법을 정의하는 함수 &lt;code&gt;?&lt;/code&gt; 교환 원이 자동으로 변환을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="42bfb7d2a182c3982d4afcf52f4999394d469590" translate="yes" xml:space="preserve">
          <source>There is a difference between what the &lt;code&gt;match&lt;/code&gt; expression from Listing 9-6 does and what the &lt;code&gt;?&lt;/code&gt; operator does: error values that have the &lt;code&gt;?&lt;/code&gt; operator called on them go through the &lt;code&gt;from&lt;/code&gt; function, defined in the &lt;code&gt;From&lt;/code&gt; trait in the standard library, which is used to convert errors from one type into another. When the &lt;code&gt;?&lt;/code&gt; operator calls the &lt;code&gt;from&lt;/code&gt; function, the error type received is converted into the error type defined in the return type of the current function. This is useful when a function returns one error type to represent all the ways a function might fail, even if parts might fail for many different reasons. As long as each error type implements the &lt;code&gt;from&lt;/code&gt; function to define how to convert itself to the returned error type, the &lt;code&gt;?&lt;/code&gt; operator takes care of the conversion automatically.</source>
          <target state="translated">Listing 9-6 의 &lt;code&gt;match&lt;/code&gt; 표현식이하는 일과 &lt;code&gt;?&lt;/code&gt; 연산자는 다음을 수행합니다. &lt;code&gt;?&lt;/code&gt; 호출 된 연산자 는 한 유형에서 다른 유형으로 오류를 변환하는 데 사용되는 표준 라이브러리 의 &lt;code&gt;From&lt;/code&gt; 특성에 정의 된 &lt;code&gt;from&lt;/code&gt; 함수를 통과합니다 . 언제 &lt;code&gt;?&lt;/code&gt; 연산자가 &lt;code&gt;from&lt;/code&gt; 함수를 호출하면 수신 된 오류 유형이 현재 함수의 반환 유형에 정의 된 오류 유형으로 변환됩니다. 이는 함수가 여러 가지 이유로 인해 일부가 실패하더라도 함수가 실패 할 수있는 모든 방법을 나타내는 하나의 오류 유형을 반환 할 때 유용합니다. 각 오류 유형이 &lt;code&gt;from&lt;/code&gt; 함수는 반환 된 오류 유형 자체를 변환하는 방법을 정의하는 &lt;code&gt;?&lt;/code&gt; 연산자는 변환을 자동으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="6b478d4cf3daf7fb5af886fd070b460cffb3f99a" translate="yes" xml:space="preserve">
          <source>There is a large variety of prefix types, see &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt;'s documentation for more.</source>
          <target state="translated">접두사 유형은 매우 다양 합니다. 자세한 내용은 &lt;a href=&quot;enum.prefix&quot;&gt; &lt;code&gt;Prefix&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b6a45e45d5b815dc5996fef1ade397970afb9eee" translate="yes" xml:space="preserve">
          <source>There is a natural point at which we can return the memory our &lt;code&gt;String&lt;/code&gt; needs to the allocator: when &lt;code&gt;s&lt;/code&gt; goes out of scope. When a variable goes out of scope, Rust calls a special function for us. This function is called &lt;code&gt;drop&lt;/code&gt;, and it&amp;rsquo;s where the author of &lt;code&gt;String&lt;/code&gt; can put the code to return the memory. Rust calls &lt;code&gt;drop&lt;/code&gt; automatically at the closing curly bracket.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 범위를 벗어날 때 &lt;code&gt;String&lt;/code&gt; 이 할당 자에게 필요한 메모리를 반환 할 수있는 자연스러운 지점이 있습니다 . 변수가 범위를 벗어나면 Rust는 우리를 위해 특별한 함수를 호출합니다. 이 함수를 &lt;code&gt;drop&lt;/code&gt; 이라고 하며 &lt;code&gt;String&lt;/code&gt; 작성자가 메모리를 반환하는 코드를 넣을 수 있는 곳 입니다. Rust 호출 은 닫는 중괄호에서 자동으로 &lt;code&gt;drop&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="9b02d233f669a1e206e4e2c20ce1d2df695bab4c" translate="yes" xml:space="preserve">
          <source>There is a natural point at which we can return the memory our &lt;code&gt;String&lt;/code&gt; needs to the operating system: when &lt;code&gt;s&lt;/code&gt; goes out of scope. When a variable goes out of scope, Rust calls a special function for us. This function is called &lt;code&gt;drop&lt;/code&gt;, and it&amp;rsquo;s where the author of &lt;code&gt;String&lt;/code&gt; can put the code to return the memory. Rust calls &lt;code&gt;drop&lt;/code&gt; automatically at the closing curly bracket.</source>
          <target state="translated">우리는 우리의 메모리 반환 할 수있는 자연 지점이 &lt;code&gt;String&lt;/code&gt; 운영 체제에 필요는 :시 &lt;code&gt;s&lt;/code&gt; 범위를 벗어나. 변수가 범위를 벗어날 때 Rust는 우리를 위해 특별한 함수를 호출합니다. 이 함수를 &lt;code&gt;drop&lt;/code&gt; 이라고 하며 &lt;code&gt;String&lt;/code&gt; 작성자가 메모리를 반환하도록 코드를 넣을 수 있습니다. 녹 통화 &lt;code&gt;drop&lt;/code&gt; 닫는 중괄호 자동으로.</target>
        </trans-unit>
        <trans-unit id="f99c36775b0b7e1c59faa2f7b94f6fd5d85206bb" translate="yes" xml:space="preserve">
          <source>There is a small difference between the two: the &lt;code&gt;derive&lt;/code&gt; strategy will also place a &lt;code&gt;Copy&lt;/code&gt; bound on type parameters, which isn't always desired.</source>
          <target state="translated">이 둘 사이에는 약간의 차이 가 있습니다 . &lt;code&gt;derive&lt;/code&gt; 전략은 항상 바람직하지 않은 유형 매개 변수에 &lt;code&gt;Copy&lt;/code&gt; 바인딩을 배치합니다 .</target>
        </trans-unit>
        <trans-unit id="ba88e1e16f5f4f6fd310c5a8bb2e8dd5b7b7dc78" translate="yes" xml:space="preserve">
          <source>There is currently a known issue (see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/39364&quot;&gt;&lt;code&gt;#39364&lt;/code&gt;&lt;/a&gt;) that causes &lt;code&gt;recv_timeout&lt;/code&gt; to panic unexpectedly with the following example:</source>
          <target state="translated">다음 예제에서 &lt;code&gt;recv_timeout&lt;/code&gt; 이 예기치 않게 패닉 되게 하는 알려진 문제 ( &lt;a href=&quot;https://github.com/rust-lang/rust/issues/39364&quot;&gt; &lt;code&gt;#39364&lt;/code&gt; &lt;/a&gt; 참조 )가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac69e37cd6f18587422e7c6b701f3aed59b4a925" translate="yes" xml:space="preserve">
          <source>There is currently no supported way to create a raw pointer or reference to a field of a struct inside &lt;code&gt;MaybeUninit&amp;lt;Struct&amp;gt;&lt;/code&gt;. That means it is not possible to create a struct by calling &lt;code&gt;MaybeUninit::uninit::&amp;lt;Struct&amp;gt;()&lt;/code&gt; and then writing to its fields.</source>
          <target state="translated">현재 &lt;code&gt;MaybeUninit&amp;lt;Struct&amp;gt;&lt;/code&gt; 안에 구조체의 필드에 대한 원시 포인터 또는 참조를 만드는 방법은 지원되지 않습니다 . 이는 &lt;code&gt;MaybeUninit::uninit::&amp;lt;Struct&amp;gt;()&lt;/code&gt; 를 호출 한 다음 해당 필드에 쓰면 구조체 를 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="06e1ced9251455647a44280e8880c2f024531277" translate="yes" xml:space="preserve">
          <source>There is no consensus in the programming community about what features a language must have to be considered object oriented. Rust is influenced by many programming paradigms, including OOP; for example, we explored the features that came from functional programming in Chapter 13. Arguably, OOP languages share certain common characteristics, namely objects, encapsulation, and inheritance. Let&amp;rsquo;s look at what each of those characteristics means and whether Rust supports it.</source>
          <target state="translated">프로그래밍 커뮤니티에서 언어가 객체 지향으로 간주되어야하는 기능에 대한 합의는 없습니다. 녹은 OOP를 포함한 많은 프로그래밍 패러다임의 영향을받습니다. 예를 들어, 13 장의 함수형 프로그래밍에서 제공되는 기능을 살펴 보았습니다. 물론 OOP 언어는 특정 공통 특성, 즉 객체, 캡슐화 및 상속을 공유합니다. 이러한 각 특성의 의미와 Rust가이를 지원하는지 여부를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="3940029042247daa011ed3a6db287dfc70d15650" translate="yes" xml:space="preserve">
          <source>There is no guarantee that an all-zero byte-pattern represents a valid value of some type &lt;code&gt;T&lt;/code&gt;. For example, the all-zero byte-pattern is not a valid value for reference types (&lt;code&gt;&amp;amp;T&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt;). Using &lt;code&gt;zeroed&lt;/code&gt; on such types causes immediate &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; because &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;the Rust compiler assumes&lt;/a&gt; that there always is a valid value in a variable it considers initialized.</source>
          <target state="translated">0이 아닌 바이트 패턴이 일부 유형 &lt;code&gt;T&lt;/code&gt; 의 유효한 값을 나타내는 것은 아닙니다 . 예를 들어, 0이 아닌 바이트 패턴은 참조 유형 ( &lt;code&gt;&amp;amp;T&lt;/code&gt; 및 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; )에 유효한 값이 아닙니다 . 이러한 유형에서 &lt;code&gt;zeroed&lt;/code&gt; 을 사용 &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;하면 Rust 컴파일러는&lt;/a&gt; 초기화 된 것으로 간주되는 변수에 항상 유효한 값이 있다고 가정 하기 때문에 즉시 &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;정의되지 않은 동작이&lt;/a&gt; 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="3d516718a20e6c51e7b81919f2ed7f10da7e19e0" translate="yes" xml:space="preserve">
          <source>There is no guarantee that an all-zero byte-pattern represents a valid value of some type &lt;code&gt;T&lt;/code&gt;. For example, the all-zero byte-pattern is not a valid value for reference types (&lt;code&gt;&amp;amp;T&lt;/code&gt;, &lt;code&gt;&amp;amp;mut T&lt;/code&gt;) and functions pointers. Using &lt;code&gt;zeroed&lt;/code&gt; on such types causes immediate &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; because &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;the Rust compiler assumes&lt;/a&gt; that there always is a valid value in a variable it considers initialized.</source>
          <target state="translated">모두 0 바이트 패턴이 &lt;code&gt;T&lt;/code&gt; 유형의 유효한 값을 나타낸다는 보장은 없습니다 . 예를 들어, 모두 0 바이트 패턴은 참조 유형 ( &lt;code&gt;&amp;amp;T&lt;/code&gt; , &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ) 및 함수 포인터에 대해 유효한 값이 아닙니다 . 이러한 유형에서 &lt;code&gt;zeroed&lt;/code&gt; 을 사용 &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;하면 Rust 컴파일러&lt;/a&gt; 가 초기화 된 것으로 간주하는 변수에 항상 유효한 값이 있다고 가정 하기 때문에 즉시 &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;정의되지 않은 동작이&lt;/a&gt; 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="77cd938f61b73cdc8199024bd862cf47becca43c" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the memory pointed to by &lt;code&gt;ptr&lt;/code&gt; contains a valid nul terminator byte at the end of the string.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 이 가리키는 메모리 에 문자열 끝에 유효한 널 종결 자 바이트가 포함되어 있다고 보장 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="37d385330ea581c420be55585ac9b53b42ed4426" translate="yes" xml:space="preserve">
          <source>There is no guarantee to the validity of &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 의 유효성을 보장하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="90b4dcdc90eb015a6d81f3692edc057c91c2b6f8" translate="yes" xml:space="preserve">
          <source>There is no implementation of &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; for child processes, so if you do not ensure the &lt;code&gt;Child&lt;/code&gt; has exited then it will continue to run, even after the &lt;code&gt;Child&lt;/code&gt; handle to the child process has gone out of scope.</source>
          <target state="translated">자식 프로세스에 대한 &lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt; 구현이 없으므로 &lt;code&gt;Child&lt;/code&gt; 이 종료 되었는지 확인하지 않으면 자식 프로세스에 대한 &lt;code&gt;Child&lt;/code&gt; 핸들이 범위를 벗어난 후에도 계속 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="96d59d760142fd31188eb3940b02911fcbc69887" translate="yes" xml:space="preserve">
          <source>There is no implementation of &lt;a href=&quot;https://doc.rust-lang.org/core/ops/trait.Drop.html&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; for child processes, so if you do not ensure the &lt;code&gt;Child&lt;/code&gt; has exited then it will continue to run, even after the &lt;code&gt;Child&lt;/code&gt; handle to the child process has gone out of scope.</source>
          <target state="translated">하위 프로세스에 대한 &lt;a href=&quot;https://doc.rust-lang.org/core/ops/trait.Drop.html&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; 의&lt;/a&gt; 구현은 없으므로 &lt;code&gt;Child&lt;/code&gt; 가 종료 되었는지 확인하지 않으면 하위 프로세스 의 &lt;code&gt;Child&lt;/code&gt; 핸들이 범위를 벗어난 후에도 계속 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="f7865277b670de1ac383b78686d6c6c3ef225ff1" translate="yes" xml:space="preserve">
          <source>There is no implicit capture of the containing function's generic parameters, parameters, and local variables. For example, &lt;code&gt;inner&lt;/code&gt; may not access &lt;code&gt;outer_var&lt;/code&gt;.</source>
          <target state="translated">포함하는 함수의 일반 매개 변수, 매개 변수 및 로컬 변수에 대한 암시 적 캡처는 없습니다. 예를 들어, &lt;code&gt;inner&lt;/code&gt; 는 &lt;code&gt;outer_var&lt;/code&gt; 에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="98bc5a98bb823e7a07123a40b084c3311e58d239" translate="yes" xml:space="preserve">
          <source>There is no meaningful value to associate with your keys.</source>
          <target state="translated">키와 연관시킬 의미있는 값은 없습니다.</target>
        </trans-unit>
        <trans-unit id="e47f071471a1ed59d24ce5598360fe16b663897e" translate="yes" xml:space="preserve">
          <source>There is no syntax that directly refers to a function item type, but the compiler will display the type as something like &lt;code&gt;fn(u32) -&amp;gt; i32 {fn_name}&lt;/code&gt; in error messages.</source>
          <target state="translated">함수 항목 유형을 직접 참조하는 구문은 없지만 컴파일러는 오류 메시지에서 유형을 &lt;code&gt;fn(u32) -&amp;gt; i32 {fn_name}&lt;/code&gt; 과 같은 형식으로 표시 합니다.</target>
        </trans-unit>
        <trans-unit id="6352ff90262f746d2ceb9b5382b99f239203c508" translate="yes" xml:space="preserve">
          <source>There is no way to express the &lt;code&gt;if x &amp;lt; 5&lt;/code&gt; condition within a pattern, so the match guard gives us the ability to express this logic.</source>
          <target state="translated">패턴 내 에서 &lt;code&gt;if x &amp;lt; 5&lt;/code&gt; 조건 을 표현할 수있는 방법이 없으므로 매치 가드는이 논리를 표현할 수있는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f04c5e1cecb9254e859f18bc80c9ad5ecd03b1f1" translate="yes" xml:space="preserve">
          <source>There is no way to refer to all trait objects generically, so the only way to create values of this type is with functions like &lt;a href=&quot;../intrinsics/fn.transmute&quot;&gt;&lt;code&gt;std::mem::transmute&lt;/code&gt;&lt;/a&gt;. Similarly, the only way to create a true trait object from a &lt;code&gt;TraitObject&lt;/code&gt; value is with &lt;code&gt;transmute&lt;/code&gt;.</source>
          <target state="translated">모든 특성 객체를 일반적으로 참조하는 방법은 없으므로이 유형의 값을 작성하는 유일한 방법은 &lt;a href=&quot;../intrinsics/fn.transmute&quot;&gt; &lt;code&gt;std::mem::transmute&lt;/code&gt; &lt;/a&gt; 와 같은 함수를 사용하는 것 입니다. 마찬가지로 &lt;code&gt;TraitObject&lt;/code&gt; 값 에서 진정한 특성 객체를 생성하는 유일한 방법 은 &lt;code&gt;transmute&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0ac27f2fb34cee3cbd54d9db13f601fadc62dc92" translate="yes" xml:space="preserve">
          <source>There is no way to refer to all trait objects generically, so the only way to create values of this type is with functions like &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;std::mem::transmute&lt;/code&gt;&lt;/a&gt;. Similarly, the only way to create a true trait object from a &lt;code&gt;TraitObject&lt;/code&gt; value is with &lt;code&gt;transmute&lt;/code&gt;.</source>
          <target state="translated">모든 특성 객체를 일반적으로 참조 할 수있는 방법이 &lt;a href=&quot;../mem/fn.transmute&quot;&gt; &lt;code&gt;std::mem::transmute&lt;/code&gt; &lt;/a&gt; 유형의 값을 생성하는 유일한 방법은 std :: mem :: transmute 와 같은 함수를 사용하는 것 입니다. 마찬가지로 &lt;code&gt;TraitObject&lt;/code&gt; 값 에서 진정한 특성 객체를 만드는 유일한 방법 은 &lt;code&gt;transmute&lt;/code&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e9f689cb8e372a1fb3e4dbcf70bbf33a833163e2" translate="yes" xml:space="preserve">
          <source>There is no wrong way to read this book: if you want to skip ahead, go for it! You might have to jump back to earlier chapters if you experience any confusion. But do whatever works for you.</source>
          <target state="translated">이 책을 읽는 잘못된 방법은 없습니다. 앞으로 건너 뛰고 싶다면 가십시오! 혼동이 발생하면 이전 장으로 되돌아 가야 할 수도 있습니다. 그러나 당신에게 효과가있는 것은 무엇이든하십시오</target>
        </trans-unit>
        <trans-unit id="f89524ca0c10b9d4f1257c768a5b98aab1c4ca9b" translate="yes" xml:space="preserve">
          <source>There is one more similarity between enums and structs: just as we&amp;rsquo;re able to define methods on structs using &lt;code&gt;impl&lt;/code&gt;, we&amp;rsquo;re also able to define methods on enums. Here&amp;rsquo;s a method named &lt;code&gt;call&lt;/code&gt; that we could define on our &lt;code&gt;Message&lt;/code&gt; enum:</source>
          <target state="translated">열거 형과 구조체 사이에 하나의 유사성 이 있습니다. &lt;code&gt;impl&lt;/code&gt; 을 사용하여 구조체에 메소드를 정의 할 수있는 것처럼 열거 형에 메소드를 정의 할 수도 있습니다. &lt;code&gt;Message&lt;/code&gt; 열거 형 에서 정의 할 수있는 &lt;code&gt;call&lt;/code&gt; 이라는 메소드가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd5de49f07fcfe0b32f34685bec57fc973c95f95" translate="yes" xml:space="preserve">
          <source>There is possibly no limit to the number of &lt;code&gt;else&lt;/code&gt; blocks that could follow an &lt;code&gt;if&lt;/code&gt; expression however if you have several then a &lt;a href=&quot;keyword.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; expression might be preferable.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 표현식 다음에 올 수있는 &lt;code&gt;else&lt;/code&gt; 블록 의 수에는 제한이 없을 수 있지만 여러 개가있는 경우 &lt;a href=&quot;keyword.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; 표현식이 더 좋을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="602b0e48a3f43914053d4b199337461ae231047f" translate="yes" xml:space="preserve">
          <source>There is usually no need to create a &lt;code&gt;Thread&lt;/code&gt; struct yourself, one should instead use a function like &lt;code&gt;spawn&lt;/code&gt; to create new threads, see the docs of &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">일반적으로 &lt;code&gt;Thread&lt;/code&gt; 구조체를 직접 만들 필요는 없습니다. 대신 &lt;code&gt;spawn&lt;/code&gt; 과 같은 함수 를 사용하여 새 스레드를 만들어야 합니다. 자세한 내용 은 &lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt; 문서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f5aa017ba54ffa17080a39771f2c83f220593384" translate="yes" xml:space="preserve">
          <source>There will be an error about &lt;code&gt;bool&lt;/code&gt; not implementing &lt;code&gt;Index&amp;lt;u8&amp;gt;&lt;/code&gt;, followed by a note saying &quot;the type &lt;code&gt;bool&lt;/code&gt; cannot be indexed by &lt;code&gt;u8&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 이 &lt;code&gt;Index&amp;lt;u8&amp;gt;&lt;/code&gt; 구현하지 않는 것에 대한 오류가 있고 &quot; &lt;code&gt;bool&lt;/code&gt; 유형 을 &lt;code&gt;u8&lt;/code&gt; 로 색인화 할 수 없습니다 &quot;라는 메모가 나옵니다 .</target>
        </trans-unit>
        <trans-unit id="7649fb68743c30fa670731965f40aa4090d73b82" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a lot more to say about &lt;a href=&quot;http://doc.crates.io&quot;&gt;Cargo&lt;/a&gt; and &lt;a href=&quot;http://doc.crates.io/crates-io.html&quot;&gt;its ecosystem&lt;/a&gt; which we&amp;rsquo;ll discuss in Chapter 14, but for now, that&amp;rsquo;s all you need to know. Cargo makes it very easy to reuse libraries, so Rustaceans are able to write smaller projects that are assembled from a number of packages.</source>
          <target state="translated">14 장에서 논의 할 &lt;a href=&quot;http://doc.crates.io&quot;&gt;Cargo&lt;/a&gt; 와 &lt;a href=&quot;http://doc.crates.io/crates-io.html&quot;&gt;그 생태계&lt;/a&gt; 에 대해 더 많은 이야기를 할 것이지만 지금은 당신이 알아야 할 전부입니다. Cargo를 사용하면 라이브러리를 매우 쉽게 재사용 할 수 있으므로 Rustaceans는 여러 패키지로 구성된 소규모 프로젝트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bf65550ac389c6cc7469a24526e0ae8bf661af9" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a tendency among many Rustaceans to avoid using &lt;code&gt;clone&lt;/code&gt; to fix ownership problems because of its runtime cost. In &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;, you&amp;rsquo;ll learn how to use more efficient methods in this type of situation. But for now, it&amp;rsquo;s okay to copy a few strings to continue making progress because you&amp;rsquo;ll make these copies only once and your filename and query string are very small. It&amp;rsquo;s better to have a working program that&amp;rsquo;s a bit inefficient than to try to hyperoptimize code on your first pass. As you become more experienced with Rust, it&amp;rsquo;ll be easier to start with the most efficient solution, but for now, it&amp;rsquo;s perfectly acceptable to call &lt;code&gt;clone&lt;/code&gt;.</source>
          <target state="translated">많은 Rustaceans 는 런타임 비용으로 인해 소유권 문제를 해결 하기 위해 &lt;code&gt;clone&lt;/code&gt; 을 사용하지 않는 경향이 있습니다 . &lt;a href=&quot;ch13-00-functional-features&quot;&gt;13 장&lt;/a&gt; 에서는 이러한 상황에서보다 효율적인 방법을 사용하는 방법을 배웁니다. 그러나 지금은 한 번만 복사하면 파일 이름과 쿼리 문자열이 매우 작으므로 몇 개의 문자열을 복사하여 계속 진행할 수 있습니다. 첫 번째 패스에서 코드를 과도하게 최적화하는 것보다 약간 비효율적 인 작업 프로그램을 사용하는 것이 좋습니다. Rust에 익숙해지면 가장 효율적인 솔루션으로 시작하는 것이 더 쉬울 것이지만 지금은 &lt;code&gt;clone&lt;/code&gt; 을 호출하는 것이 완벽 합니다.</target>
        </trans-unit>
        <trans-unit id="66fb5ab158cd4be714eaa0eeb00d2ccbb6eb7bd5" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another advantage to using an enum rather than a struct: each variant can have different types and amounts of associated data. Version four type IP addresses will always have four numeric components that will have values between 0 and 255. If we wanted to store &lt;code&gt;V4&lt;/code&gt; addresses as four &lt;code&gt;u8&lt;/code&gt; values but still express &lt;code&gt;V6&lt;/code&gt; addresses as one &lt;code&gt;String&lt;/code&gt; value, we wouldn&amp;rsquo;t be able to with a struct. Enums handle this case with ease:</source>
          <target state="translated">구조체 대신 열거 형을 사용하면 또 다른 이점이 있습니다. 각 변형은 서로 다른 유형과 양의 관련 데이터를 가질 수 있습니다. 버전 4 유형 IP 주소는 항상 0과 255 사이의 값을 갖는 4 개의 숫자 구성 요소를 갖습니다. &lt;code&gt;V4&lt;/code&gt; 주소를 4 개의 &lt;code&gt;u8&lt;/code&gt; 값 으로 저장하고 &lt;code&gt;V6&lt;/code&gt; 주소를 하나의 &lt;code&gt;String&lt;/code&gt; 값 으로 표현 하려는 경우에는 구조체. 열거 형은이 경우를 쉽게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="a401bf0a884425f212fc0c2849df8bdacf839a70" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another solution to the problem of bringing two types of the same name into the same scope with &lt;code&gt;use&lt;/code&gt;: after the path, we can specify &lt;code&gt;as&lt;/code&gt; and a new local name, or alias, for the type. Listing 7-16 shows another way to write the code in Listing 7-15 by renaming one of the two &lt;code&gt;Result&lt;/code&gt; types using &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">와 동일한 범위에 같은 이름의 두 가지 유형을 가져 오는 문제에 대한 또 다른 해결 방법이 있습니다 &lt;code&gt;use&lt;/code&gt; : 경로 후, 우리는 지정할 수 있습니다 &lt;code&gt;as&lt;/code&gt; 유형에 대한, 새로운 지역의 이름 또는 별명을. Listing 7-16은 &lt;code&gt;as&lt;/code&gt; 를 사용하여 두 개의 &lt;code&gt;Result&lt;/code&gt; 타입 중 하나의 이름을 바꾸어 Listing 7-15에서 코드를 작성하는 다른 방법을 보여준다 .</target>
        </trans-unit>
        <trans-unit id="e2494d175673de3a22a42c411f830ff3208f6ec7" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another wrinkle we haven&amp;rsquo;t talked about yet. This code using integers &amp;ndash; part of which was shown in Listing 4-2 &amp;ndash; works and is valid:</source>
          <target state="translated">우리가 아직 말하지 않은 또 다른 주름이 있습니다. 정수를 사용하는이 코드 (목록 4-2에 표시된 일부)는 작동하며 유효합니다.</target>
        </trans-unit>
        <trans-unit id="04733e00c121b49528c905aab2fa6e90d06dc6c3" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another wrinkle we haven&amp;rsquo;t talked about yet. This code using integers, part of which was shown in Listing 4-2, works and is valid:</source>
          <target state="translated">아직 이야기하지 않은 또 다른 주름이 있습니다. 정수를 사용하는이 코드는 목록 4-2에 표시된 일부가 작동하며 유효합니다.</target>
        </trans-unit>
        <trans-unit id="6058c5e16c87f1a91c60dc38f9f510ce010e9805" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s debate within the testing community about whether or not private functions should be tested directly, and other languages make it difficult or impossible to test private functions. Regardless of which testing ideology you adhere to, Rust&amp;rsquo;s privacy rules do allow you to test private functions. Consider the code in Listing 11-12 with the private function &lt;code&gt;internal_adder&lt;/code&gt;.</source>
          <target state="translated">테스트 커뮤니티 내에서 개인 기능을 직접 테스트해야하는지 여부에 대한 토론이 있으며 다른 언어로 인해 개인 기능을 테스트하기가 어렵거나 불가능합니다. 어떤 테스트 이념을 준수하든 Rust의 개인 정보 보호 규칙을 통해 개인 기능을 테스트 할 수 있습니다. private 함수 &lt;code&gt;internal_adder&lt;/code&gt; 를 사용하여 목록 11-12의 코드를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="908f1205edb5e08b15769591fe9ecf304d371a0b" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no mechanism being used to synchronize access to the data.</source>
          <target state="translated">데이터에 대한 액세스를 동기화하는 데 사용되는 메커니즘은 없습니다.</target>
        </trans-unit>
        <trans-unit id="8e1fa626ffc94c26aaee1b60bc06a3539eef3bfd" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no reason to separate these methods into multiple &lt;code&gt;impl&lt;/code&gt; blocks here, but this is valid syntax. We&amp;rsquo;ll see a case in which multiple &lt;code&gt;impl&lt;/code&gt; blocks are useful in Chapter 10, where we discuss generic types and traits.</source>
          <target state="translated">이 메소드를 여러 개의 &lt;code&gt;impl&lt;/code&gt; 블록 으로 분리 할 이유 는 없지만 이것이 유효한 구문입니다. 제 10 장에서 일반적인 유형과 특성에 대해 설명 하는 여러 &lt;code&gt;impl&lt;/code&gt; 블록이 유용한 경우를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="68d4631903746cfba7c6e6864ab36c77a56f918c" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no strong reason behind this idiom: it&amp;rsquo;s just the convention that has emerged, and folks have gotten used to reading and writing Rust code this way.</source>
          <target state="translated">이 관용구 뒤에는 강력한 이유가 없습니다. 그것은 단지 나타난 관습 일 뿐이며, 사람들은 이런 식으로 녹 코드를 읽고 쓰는 데 익숙해졌습니다.</target>
        </trans-unit>
        <trans-unit id="c6cc13f913f5af22a31d9a866ef0ab4e915bc64e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s not a good way to encode this information in the types you use.</source>
          <target state="translated">이 정보를 사용하는 형식으로 인코딩하는 좋은 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="42ede15289d883de11e0a80cc68d82337478321c" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one more catch with this release model: unstable features. Rust uses a technique called &amp;ldquo;feature flags&amp;rdquo; to determine what features are enabled in a given release. If a new feature is under active development, it lands on &lt;code&gt;master&lt;/code&gt;, and therefore, in nightly, but behind a &lt;em&gt;feature flag&lt;/em&gt;. If you, as a user, wish to try out the work-in-progress feature, you can, but you must be using a nightly release of Rust and annotate your source code with the appropriate flag to opt in.</source>
          <target state="translated">이 릴리스 모델에는 불안정한 기능이 하나 더 있습니다. Rust는&amp;ldquo;feature flags&amp;rdquo;라는 기술을 사용하여 특정 릴리스에서 어떤 기능을 사용할 수 있는지 결정합니다. 새로운 기능이 활발하게 개발중인 경우 &lt;code&gt;master&lt;/code&gt; 에 도착 하므로 야간에 &lt;em&gt;기능 플래그&lt;/em&gt; 뒤에있게 됩니다. 사용자가 진행중인 작업 기능을 사용해보고 싶다면 할 수 있지만 Rust의 야간 릴리스를 사용하고 적절한 플래그로 소스 코드에 주석을 달아 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="daaeaab720a0d66e562ebf5f2bea02ac0a5abbb2" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one more situation involving &lt;code&gt;pub&lt;/code&gt; that we haven&amp;rsquo;t covered, and that is our last module system feature: the &lt;code&gt;use&lt;/code&gt; keyword. We&amp;rsquo;ll cover &lt;code&gt;use&lt;/code&gt; by itself first, and then we&amp;rsquo;ll show how to combine &lt;code&gt;pub&lt;/code&gt; and &lt;code&gt;use&lt;/code&gt;.</source>
          <target state="translated">우리가 다루지 않은 &lt;code&gt;pub&lt;/code&gt; 과 관련된 또 하나의 상황이 있으며, 이것이 마지막 모듈 시스템 기능인 &lt;code&gt;use&lt;/code&gt; 키워드입니다. 먼저 &lt;code&gt;use&lt;/code&gt; 자체를 다루고 &lt;code&gt;pub&lt;/code&gt; 와 &lt;code&gt;use&lt;/code&gt; 를 결합하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="5e8c77371d51b56070c8afcedaaaf9336a342d93" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one other aspect of &lt;code&gt;match&lt;/code&gt; we need to discuss. Consider this version of our &lt;code&gt;plus_one&lt;/code&gt; function that has a bug and won&amp;rsquo;t compile:</source>
          <target state="translated">우리가 논의해야 할 또 다른 &lt;code&gt;match&lt;/code&gt; 측면이 있습니다. 버그가 있고 컴파일되지 않는 이 버전의 &lt;code&gt;plus_one&lt;/code&gt; 함수를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cab02a3373b42bd604f431d95c5d649fedd71e0" translate="yes" xml:space="preserve">
          <source>There's a trait in the standard library for converting something into an iterator: &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;. This trait has one method, &lt;a href=&quot;trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt;, which converts the thing implementing &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; into an iterator. Let's take a look at that &lt;code&gt;for&lt;/code&gt; loop again, and what the compiler converts it into:</source>
          <target state="translated">표준 라이브러리에는 무언가를 반복자로 변환하는 특성이 있습니다 : &lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; . 이 특성에는 &lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; 를 구현하는 것을 iterator로 변환하는 &lt;a href=&quot;trait.intoiterator#tymethod.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt; 메소드가 있습니다. &lt;code&gt;for&lt;/code&gt; 루프를 다시 살펴보고 컴파일러가이를 루프로 변환하는 내용 을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="126dd99b7c8920c551aa5435d3f5f50326fcb2aa" translate="yes" xml:space="preserve">
          <source>There's no easy fix for this, generally code will need to be refactored so that you no longer need to derive from &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이에 대한 쉬운 해결책은 없으며 일반적으로 코드를 리팩터링하여 더 이상 &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt; 에서 파생시킬 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="488dc2b946582ce5502bb699e0ad78fcce8b394c" translate="yes" xml:space="preserve">
          <source>There's one more subtle bit here: the standard library contains an interesting implementation of &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">표준 라이브러리에는 흥미로운 &lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; 구현이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd800f0b62b0c62a6a6fb9b356e68d3a2d4685be" translate="yes" xml:space="preserve">
          <source>There, the where clause &lt;code&gt;T: 'a&lt;/code&gt; that appears on the impl is not known to be satisfied on the struct. To make this example compile, you have to add a where-clause like &lt;code&gt;T: 'a&lt;/code&gt; to the struct definition:</source>
          <target state="translated">거기에서 where 절 &lt;code&gt;T: 'a&lt;/code&gt; 가 impl에 나타나는 것은 struct에서 충족되는 것으로 알려져 있지 않습니다. 이 예제를 컴파일하려면 &lt;code&gt;T: 'a&lt;/code&gt; 와 같은 where 절 을 구조체 정의에 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="943a55d68bc8d1a8af15546966743386da3f91a8" translate="yes" xml:space="preserve">
          <source>Therefore, Rust&amp;rsquo;s type system and trait bounds ensure that you can never accidentally send an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value across threads unsafely. When we tried to do this in Listing 16-14, we got the error &lt;code&gt;the trait Send is not implemented for Rc&amp;lt;Mutex&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt;. When we switched to &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;, which is &lt;code&gt;Send&lt;/code&gt;, the code compiled.</source>
          <target state="translated">따라서 Rust의 유형 시스템 및 특성 경계는 실수로 스레드를 통해 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 값을 안전하지 않게 보낼 수 없도록합니다 . Listing 16-14에서이 작업을 시도했을 때 &lt;code&gt;the trait Send is not implemented for Rc&amp;lt;Mutex&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt; 오류가 발생 했습니다 . 우리가 스위치를 켜면 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 되고, &lt;code&gt;Send&lt;/code&gt; , 코드는 컴파일.</target>
        </trans-unit>
        <trans-unit id="92887ab1d8d0b7fee43ce74855c566c18dd9ff66" translate="yes" xml:space="preserve">
          <source>Therefore, pinning also comes with a &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt;-related guarantee.</source>
          <target state="translated">따라서 고정에는 &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; 관련 보증 도 함께 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="a965d0af2f94e5f3318be18d630d6ce398f8ad8c" translate="yes" xml:space="preserve">
          <source>Therefore, pinning also comes with a &lt;code&gt;drop&lt;/code&gt;-related guarantee.</source>
          <target state="translated">따라서 고정에는 &lt;code&gt;drop&lt;/code&gt; 관련 보증이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f3da5db36b6a5c8b63c646979b9f9638e2ffed72" translate="yes" xml:space="preserve">
          <source>These abstractions can be built out of lower-level primitives. For efficiency, the sync objects in the standard library are usually implemented with help from the operating system's kernel, which is able to reschedule the threads while they are blocked on acquiring a lock.</source>
          <target state="translated">이러한 추상화는 하위 레벨 기본 요소로 빌드 될 수 있습니다. 효율성을 높이기 위해 표준 라이브러리의 동기화 객체는 일반적으로 운영 체제 커널의 도움을 받아 구현되며, 잠금을 획득 할 때 스레드를 다시 예약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b4543381c3d34027ca13b9d929f743b5e4c9c39" translate="yes" xml:space="preserve">
          <source>These also point to memory owned by some other value. A mutable reference type is written &lt;code&gt;&amp;amp;mut type&lt;/code&gt; or &lt;code&gt;&amp;amp;'a mut type&lt;/code&gt;. A mutable reference (that hasn't been borrowed) is the only way to access the value it points to, so is not &lt;code&gt;Copy&lt;/code&gt;.</source>
          <target state="translated">이것들은 다른 값이 소유 한 메모리를 가리 킵니다. 변경 가능한 참조 유형은 &lt;code&gt;&amp;amp;mut type&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;'a mut type&lt;/code&gt; 입니다. 빌려지지 않은 변경 가능한 참조는 그것이 가리키는 값에 액세스하는 유일한 방법이므로 &lt;code&gt;Copy&lt;/code&gt; 는 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="1edbd620f4ea3fb93fdd0d7dd71adad12120dfa7" translate="yes" xml:space="preserve">
          <source>These ampersands are &lt;em&gt;references&lt;/em&gt;, and they allow you to refer to some value without taking ownership of it. Figure 4-5 shows a diagram.</source>
          <target state="translated">이 앰퍼샌드는 &lt;em&gt;참조&lt;/em&gt; 이며, 소유권을 가지지 않고 일부 값을 참조 할 수 있습니다. 그림 4-5는 다이어그램을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c26ef3d23f517e371ad3e5a198bcf65faf103392" translate="yes" xml:space="preserve">
          <source>These are all flags altering the behavior of the formatter.</source>
          <target state="translated">이들은 모두 포맷터의 동작을 변경하는 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="4fbf8436660d61da218272cb68549a2354d27ae0" translate="yes" xml:space="preserve">
          <source>These are equivalent to the following explicit lifetime annotations:</source>
          <target state="translated">이는 다음과 같은 명시 적 수명 주석과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3f42eae85e77f8aae9c5335f688c216fd7101df0" translate="yes" xml:space="preserve">
          <source>These are fairly high-level and quick break-downs of when each collection should be considered. Detailed discussions of strengths and weaknesses of individual collections can be found on their own documentation pages.</source>
          <target state="translated">이는 각 컬렉션을 고려해야 할시기에 대한 상당히 높은 수준의 빠른 분석입니다. 개별 컬렉션의 장단점에 대한 자세한 내용은 해당 설명서 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f5b38a7809c6c63bf242f85f557b82e6e93c16bc" translate="yes" xml:space="preserve">
          <source>These are often used in combination with &lt;a href=&quot;external-blocks&quot;&gt;external block&lt;/a&gt; items which provide function &lt;em&gt;declarations&lt;/em&gt; that can be used to call functions without providing their &lt;em&gt;definition&lt;/em&gt;:</source>
          <target state="translated">이들은 종종 &lt;em&gt;정의&lt;/em&gt; 를 제공하지 않고 함수를 호출하는 데 사용할 수있는 함수 &lt;em&gt;선언&lt;/em&gt; 을 제공하는 &lt;a href=&quot;external-blocks&quot;&gt;외부 블록&lt;/a&gt; 항목 과 함께 사용됩니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="69b2114a065741874c57309ba27c70784c7ddedd" translate="yes" xml:space="preserve">
          <source>These are the last two unary operators. This table summarizes the behavior of them on primitive types and which traits are used to overload these operators for other types. Remember that signed integers are always represented using two's complement. The operands of all of these operators are evaluated in &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression context&lt;/a&gt; so are moved or copied.</source>
          <target state="translated">이들은 마지막 두 개의 단항 연산자입니다. 이 표는 기본 유형에 대한 해당 동작과 다른 유형에 대해 이러한 연산자를 오버로드하는 데 사용되는 특성을 요약합니다. 부호있는 정수는 항상 2의 보수를 사용하여 표현됩니다. 이러한 모든 연산자의 피연산자는 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;값 표현식 컨텍스트&lt;/a&gt; 에서 평가 되므로 이동하거나 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="25cb76396a6daa0dab5184b03f4b6697d1acd40a" translate="yes" xml:space="preserve">
          <source>These attributes are meant to only be used by the standard library and are rejected in your own crates.</source>
          <target state="translated">이러한 속성은 표준 라이브러리에서만 사용하기위한 것이며 자신의 상자에서 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="b6db5a380dbbbf8a2cd7b3c9d1a9637a5d119ab4" translate="yes" xml:space="preserve">
          <source>These attributes do not work on typedefs, since typedefs are just aliases.</source>
          <target state="translated">typedef는 별명 일 뿐이므로 이러한 속성은 typedef에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45e9c8e478d7d23050c1bb7760888996d75acd57" translate="yes" xml:space="preserve">
          <source>These axioms, along with careful use of &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt; for pointer arithmetic, are enough to correctly implement many useful things in unsafe code. Stronger guarantees will be provided eventually, as the &lt;a href=&quot;https://doc.rust-lang.org/nomicon/aliasing.html&quot;&gt;aliasing&lt;/a&gt; rules are being determined. For more information, see the &lt;a href=&quot;../../book/ch19-01-unsafe-rust#dereferencing-a-raw-pointer&quot;&gt;book&lt;/a&gt; as well as the section in the reference devoted to &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;.</source>
          <target state="translated">포인터 산술 에 &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt; 을 신중하게 사용하는 것과 같은 이러한 공리 는 안전하지 않은 코드에서 많은 유용한 것들을 올바르게 구현하기에 충분합니다. &lt;a href=&quot;https://doc.rust-lang.org/nomicon/aliasing.html&quot;&gt;앨리어싱&lt;/a&gt; 규칙이 결정 되면 더 강력한 보증이 제공 될 것 입니다. 자세한 내용은 &lt;a href=&quot;../../book/ch19-01-unsafe-rust#dereferencing-a-raw-pointer&quot;&gt;책&lt;/a&gt; 과 &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;정의되지 않은 동작&lt;/a&gt; 에 관한 참조 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7913b3c72a22fc6b243e0539a47297d89428aedf" translate="yes" xml:space="preserve">
          <source>These can all be interpreted as flags for a particular formatter.</source>
          <target state="translated">이들은 모두 특정 포맷터에 대한 플래그로 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e39a0bd16ba8ecfd732cbb117c3248fda60a735" translate="yes" xml:space="preserve">
          <source>These can be fixed by declaring lifetime parameters:</source>
          <target state="translated">수명 매개 변수를 선언하여이를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d454f3116d0aed2fb7a537cae1b229f52b361113" translate="yes" xml:space="preserve">
          <source>These channels come in two flavors:</source>
          <target state="translated">이 채널은 두 가지 맛이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c31b94922e5b65f02fef2f529b0b7e4859486143" translate="yes" xml:space="preserve">
          <source>These components describe the shape of the data we&amp;rsquo;re working with, which we then match against values to determine whether our program has the correct data to continue running a particular piece of code.</source>
          <target state="translated">이 컴포넌트들은 우리가 작업하고있는 데이터의 형태를 기술 한 다음, 특정 코드를 계속 실행하기 위해 프로그램에 올바른 데이터가 있는지를 결정하기 위해 값과 비교합니다.</target>
        </trans-unit>
        <trans-unit id="01d073371ba3433dace28c44e03a57f2a2d8dbcd" translate="yes" xml:space="preserve">
          <source>These default object lifetime bounds are used instead of the lifetime parameter elision rules defined above when the lifetime bound is omitted entirely. If &lt;code&gt;'_&lt;/code&gt; is used as the lifetime bound then the bound follows the usual elision rules.</source>
          <target state="translated">이러한 기본 객체 수명 범위는 수명 한계가 완전히 생략 될 때 위에서 정의 된 수명 매개 변수 제거 규칙 대신 사용됩니다. 경우 &lt;code&gt;'_&lt;/code&gt; 바인딩 수명으로 사용 후 바운드는 보통 생략 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="3cb556ed4e688a43a755806e0180a1ae20f4245d" translate="yes" xml:space="preserve">
          <source>These enumerations can be cast to integer types with the &lt;code&gt;as&lt;/code&gt; operator by a &lt;a href=&quot;../expressions/operator-expr#semantics&quot;&gt;numeric cast&lt;/a&gt;. The enumeration can optionally specify which integer each discriminant gets by following the variant name with &lt;code&gt;=&lt;/code&gt; followed by a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;. If the first variant in the declaration is unspecified, then it is set to zero. For every other unspecified discriminant, it is set to one higher than the previous variant in the declaration.</source>
          <target state="translated">이러한 열거 형은 &lt;a href=&quot;../expressions/operator-expr#semantics&quot;&gt;숫자 캐스트 &lt;/a&gt; &lt;code&gt;as&lt;/code&gt; 연산자를 사용하여 정수 유형으로 캐스트 할 수 있습니다 . 열거 형은 선택적으로 각 식별 변수에 &lt;code&gt;=&lt;/code&gt; 가 포함 된 변형 이름 뒤에 &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;상수 표현식이&lt;/a&gt; 오는 정수를 지정할 수 있습니다 . 선언의 첫 번째 변형이 지정되지 않은 경우 0으로 설정됩니다. 다른 모든 지정되지 않은 판별 변수에 대해서는 선언에서 이전 변형보다 하나 더 높게 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="56f44a74054755cd230d668bfd5dc0a8f5aa2ac0" translate="yes" xml:space="preserve">
          <source>These keywords aren't used yet, but they are reserved for future use. They have the same restrictions as strict keywords. The reasoning behind this is to make current programs forward compatible with future versions of Rust by forbidding them to use these keywords.</source>
          <target state="translated">이 키워드는 아직 사용되지 않지만 나중에 사용하기 위해 예약되어 있습니다. 엄격한 키워드와 동일한 제한 사항이 있습니다. 그 이유는 현재 프로그램이 이러한 키워드를 사용하지 못하도록하여 향후 프로그램의 Rust와 호환되도록하기 위해서입니다.</target>
        </trans-unit>
        <trans-unit id="f2eab53396d35c8dd4df2e3ab58dfee415a7015e" translate="yes" xml:space="preserve">
          <source>These keywords can only be used in their correct contexts. They cannot be used as the names of:</source>
          <target state="translated">이 키워드는 올바른 컨텍스트에서만 사용할 수 있습니다. 다음 이름으로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="aec421e6db4795c07bbf5e8ae6411e119af0b089" translate="yes" xml:space="preserve">
          <source>These keywords have special meaning only in certain contexts. For example, it is possible to declare a variable or method with the name &lt;code&gt;union&lt;/code&gt;.</source>
          <target state="translated">이러한 키워드는 특정 상황에서만 특별한 의미를 갖습니다. 예를 들어 이름이 &lt;code&gt;union&lt;/code&gt; 인 변수 또는 메소드를 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24355b40ed9274fe2bce5ed7512a65c55ffdfb11" translate="yes" xml:space="preserve">
          <source>These lines define a function in Rust. The &lt;code&gt;main&lt;/code&gt; function is special: it is always the first code that runs in every executable Rust program. The first line declares a function named &lt;code&gt;main&lt;/code&gt; that has no parameters and returns nothing. If there were parameters, they would go inside the parentheses, &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">이 라인들은 Rust에서 함수를 정의합니다. &lt;code&gt;main&lt;/code&gt; 기능은 특별하다 : 그것은 항상 첫 번째 코드는 그 모든 실행 녹 프로그램에서 실행됩니다. 첫 번째 줄은 매개 변수가없는 &lt;code&gt;main&lt;/code&gt; 함수를 선언하고 아무것도 반환하지 않습니다. 매개 변수가 있으면 괄호 안에 &lt;code&gt;()&lt;/code&gt; 가 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="78ee21b3b578a8828b900a4d7bb5e92af7fdfb9f" translate="yes" xml:space="preserve">
          <source>These lines show Cargo only updates the build with your tiny change to the &lt;em&gt;src/main.rs&lt;/em&gt; file. Your dependencies haven&amp;rsquo;t changed, so Cargo knows it can reuse what it has already downloaded and compiled for those. It just rebuilds your part of the code.</source>
          <target state="translated">이 줄은 Cargo가 &lt;em&gt;src / main.rs&lt;/em&gt; 파일 을 약간 변경하여 빌드 만 업데이트 함을 보여줍니다 . 의존성은 변경되지 않았으므로 Cargo는 이미 다운로드하여 컴파일 한 것을 재사용 할 수 있다는 것을 알고 있습니다. 코드의 일부만 다시 작성합니다.</target>
        </trans-unit>
        <trans-unit id="ba54db094123009e0eb01fa8adef8c82df9419e8" translate="yes" xml:space="preserve">
          <source>These macros are defined by a &lt;a href=&quot;visibility-and-privacy&quot;&gt;public&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; with the &lt;code&gt;proc_macro&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; and a signature of &lt;code&gt;(TokenStream) -&amp;gt; TokenStream&lt;/code&gt;. The input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is what is inside the delimiters of the macro invocation and the output &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; replaces the entire macro invocation.</source>
          <target state="translated">이 매크로는에 의해 정의 된 &lt;a href=&quot;visibility-and-privacy&quot;&gt;공공 &lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;기능&lt;/a&gt; 와 &lt;code&gt;proc_macro&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 및 서명 &lt;code&gt;(TokenStream) -&amp;gt; TokenStream&lt;/code&gt; . 입력 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 은 매크로 호출의 구분 기호 안에있는 것이며 출력 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 은 전체 매크로 호출을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="c77584f3dda90ac8527f5ef32d9ad1f6daeca4c8" translate="yes" xml:space="preserve">
          <source>These macros are defined by a &lt;a href=&quot;visibility-and-privacy&quot;&gt;public&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; with the &lt;code&gt;proc_macro&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; and a signature of &lt;code&gt;(TokenStream) -&amp;gt; TokenStream&lt;/code&gt;. The input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is what is inside the delimiters of the macro invocation and the output &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; replaces the entire macro invocation. It may contain an arbitrary number of &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;. These macros cannot expand to syntax that defines new &lt;code&gt;macro_rules&lt;/code&gt; style macros.</source>
          <target state="translated">이 매크로는에 의해 정의 된 &lt;a href=&quot;visibility-and-privacy&quot;&gt;공공 &lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;기능&lt;/a&gt; 와 &lt;code&gt;proc_macro&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 및 서명 &lt;code&gt;(TokenStream) -&amp;gt; TokenStream&lt;/code&gt; . 입력 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 은 매크로 호출의 분리 문자 안에 있으며 출력 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 은 전체 매크로 호출을 대체합니다. 임의의 수의 &lt;a href=&quot;items&quot;&gt;항목을&lt;/a&gt; 포함 할 수 있습니다 . 이러한 매크로는 새로운 &lt;code&gt;macro_rules&lt;/code&gt; 스타일 매크로 를 정의하는 구문으로 확장 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="254739acb173823a2863a1c41d3ebb09cfa13aeb" translate="yes" xml:space="preserve">
          <source>These macros are only invokable in &lt;a href=&quot;items/modules&quot;&gt;modules&lt;/a&gt;. They cannot even be invoked to create &lt;a href=&quot;statements#item-declarations&quot;&gt;item declaration statements&lt;/a&gt;. Furthermore, they must either be invoked with curly braces and no semicolon or a different delimiter followed by a semicolon. For example, &lt;code&gt;make_answer&lt;/code&gt; from the previous example can be invoked as &lt;code&gt;make_answer!{}&lt;/code&gt;, &lt;code&gt;make_answer!();&lt;/code&gt; or &lt;code&gt;make_answer![];&lt;/code&gt;.</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;items/modules&quot;&gt;모듈&lt;/a&gt; 에서만 호출 할 수 있습니다. &lt;a href=&quot;statements#item-declarations&quot;&gt;항목 선언문&lt;/a&gt; 을 작성하기 위해 호출 할 수도 없습니다 . 또한 중괄호없이 세미콜론이나 다른 구분 기호 뒤에 세미콜론을 사용하여 호출해야합니다. 예를 들어, &lt;code&gt;make_answer&lt;/code&gt; 이전 예제는 다음과 같이 호출 할 수 있습니다 &lt;code&gt;make_answer!{}&lt;/code&gt; , &lt;code&gt;make_answer!();&lt;/code&gt; 또는 &lt;code&gt;make_answer![];&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5391198458bfd8d81a447bc30f66734e6f03394d" translate="yes" xml:space="preserve">
          <source>These markers can be combined, so &lt;code&gt;unsafe extern &quot;stdcall&quot; fn()&lt;/code&gt; is a valid type.</source>
          <target state="translated">이러한 마커를 결합 할 수 있으므로 &lt;code&gt;unsafe extern &quot;stdcall&quot; fn()&lt;/code&gt; 은 유효한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="8c3ea3ec32e230deeef1943701b442105e65b661" translate="yes" xml:space="preserve">
          <source>These operators cannot be overloaded.</source>
          <target state="translated">이 연산자는 오버로드 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="12f02bfbd76d4dd6ccf6a1d0f95634f64537447a" translate="yes" xml:space="preserve">
          <source>These point to memory &lt;em&gt;owned by some other value&lt;/em&gt;. When a shared reference to a value is created it prevents direct mutation of the value. &lt;a href=&quot;../interior-mutability&quot;&gt;Interior mutability&lt;/a&gt; provides an exception for this in certain circumstances. As the name suggests, any number of shared references to a value may exist. A shared reference type is written &lt;code&gt;&amp;amp;type&lt;/code&gt;, or &lt;code&gt;&amp;amp;'a type&lt;/code&gt; when you need to specify an explicit lifetime. Copying a reference is a &quot;shallow&quot; operation: it involves only copying the pointer itself, that is, pointers are &lt;code&gt;Copy&lt;/code&gt;. Releasing a reference has no effect on the value it points to, but referencing of a &lt;a href=&quot;../expressions#temporaries&quot;&gt;temporary value&lt;/a&gt; will keep it alive during the scope of the reference itself.</source>
          <target state="translated">이것들은 &lt;em&gt;다른 값이 소유 한&lt;/em&gt; 메모리를 가리 킵니다 . 값에 대한 공유 참조가 생성되면 값의 직접적인 변형을 방지합니다. &lt;a href=&quot;../interior-mutability&quot;&gt;내부 가변성&lt;/a&gt; 은 특정 상황에서 이에 대한 예외를 제공합니다. 이름에서 알 수 있듯이 값에 대한 공유 참조가 얼마든지 존재할 수 있습니다. 공유 참조 유형은 명시 적 수명을 지정해야 할 때 &lt;code&gt;&amp;amp;type&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;'a type&lt;/code&gt; 됩니다. 참조 복사는 &quot;얕은&quot;작업입니다. 포인터 자체 만 복사합니다. 즉, 포인터는 &lt;code&gt;Copy&lt;/code&gt; 입니다. 참조를 해제해도 가리키는 값에는 영향을 미치지 않지만 &lt;a href=&quot;../expressions#temporaries&quot;&gt;임시 값&lt;/a&gt; 을 참조하면 참조 자체의 범위 동안 계속 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="3fc236a778b843e2aeed416fa4b2cc9e1a08823c" translate="yes" xml:space="preserve">
          <source>These point to memory &lt;em&gt;owned by some other value&lt;/em&gt;. When a shared reference to a value is created it prevents direct mutation of the value. &lt;a href=&quot;../interior-mutability&quot;&gt;Interior mutability&lt;/a&gt; provides an exception for this in certain circumstances. As the name suggests, any number of shared references to a value may exist. A shared reference type is written &lt;code&gt;&amp;amp;type&lt;/code&gt;, or &lt;code&gt;&amp;amp;'a type&lt;/code&gt; when you need to specify an explicit lifetime. Copying a reference is a &quot;shallow&quot; operation: it involves only copying the pointer itself, that is, pointers are &lt;code&gt;Copy&lt;/code&gt;. Releasing a reference has no effect on the value it points to, but referencing of a &lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;temporary value&lt;/a&gt; will keep it alive during the scope of the reference itself.</source>
          <target state="translated">이것들은 &lt;em&gt;다른 가치가 소유 한&lt;/em&gt; 메모리를 가리킨다 . 값에 대한 공유 참조가 작성되면 값의 직접적인 돌연변이가 방지됩니다. &lt;a href=&quot;../interior-mutability&quot;&gt;내부 변경&lt;/a&gt; 은 특정 상황에서 이에 대한 예외를 제공합니다. 이름에서 알 수 있듯이 값에 대한 공유 참조는 여러 개 존재할 수 있습니다. 공유 참조 유형은 &lt;code&gt;&amp;amp;type&lt;/code&gt; 또는 명시적인 수명을 지정해야 할 경우 &lt;code&gt;&amp;amp;'a type&lt;/code&gt; 입니다. 참조 복사는 &quot;얕은&quot;작업입니다. 포인터 자체 만 복사하면됩니다. 즉 포인터는 &lt;code&gt;Copy&lt;/code&gt; 입니다. 참조를 해제해도 해당 값에 영향을 미치지 않지만 &lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;임시 값&lt;/a&gt; 을 참조하면 참조 자체의 범위 내에서 참조가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="e5e8141a80455494c8061b88eb7d52c5630351cf" translate="yes" xml:space="preserve">
          <source>These profile names might be familiar from the output of your builds:</source>
          <target state="translated">이 프로파일 이름은 빌드 결과에 익숙 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ad28c50cb4ab16e536724b4f61aca4d7477f454" translate="yes" xml:space="preserve">
          <source>These safety checks can be relaxed for a section of the code by wrapping the unsafe instructions with an &lt;code&gt;unsafe&lt;/code&gt; block. For instance:</source>
          <target state="translated">안전하지 않은 명령어를 &lt;code&gt;unsafe&lt;/code&gt; 블록 으로 감싸서 코드 섹션에 대해 이러한 안전 점검을 완화 할 수 있습니다 . 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="7c9be14b653ccb0fc4412a262bd32a7bb0662862" translate="yes" xml:space="preserve">
          <source>These traits, along with &lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt;, work in conjunction so that it is possible to &lt;strong&gt;round-trip&lt;/strong&gt; strings from Windows and back, with no loss of data, even if the strings are ill-formed UTF-16.</source>
          <target state="translated">이러한 특성은 &lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; 과 함께 작동 하여 문자열이 잘못 구성된 UTF-16 인 경우에도 데이터 손실없이 Windows에서 문자열을 &lt;strong&gt;왕복&lt;/strong&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0cc726c49519e90aab3de25bfe65c626d294217a" translate="yes" xml:space="preserve">
          <source>These two cases are surprisingly powerful for creating module hierarchies exposing public APIs while hiding internal implementation details. To help explain, here's a few use cases and what they would entail:</source>
          <target state="translated">이 두 가지 경우는 내부 구현 세부 정보를 숨기고 공개 API를 노출하는 모듈 계층을 만드는 데 놀랍도록 강력합니다. 설명을 돕기 위해 다음은 몇 가지 사용 사례와 그에 따른 내용입니다.</target>
        </trans-unit>
        <trans-unit id="8ac19292e9dd15d2d45f1f79b996a19bf6206f30" translate="yes" xml:space="preserve">
          <source>These two examples illustrate the problem:</source>
          <target state="translated">이 두 예는 문제를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="dca9d4b1de7c5a2be4c4d5727e7917fd8aab654c" translate="yes" xml:space="preserve">
          <source>These two formatting traits have distinct purposes:</source>
          <target state="translated">이 두 가지 서식 특성은 고유 한 용도가 있습니다.</target>
        </trans-unit>
        <trans-unit id="742fffc208f85aff3d0f6f3059eddfffa585c4ab" translate="yes" xml:space="preserve">
          <source>These two functions might be implemented in Rust as follows. Here, the &lt;code&gt;struct Foo*&lt;/code&gt; type from C is translated to &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt;, which captures the ownership constraints. Note also that the nullable argument to &lt;code&gt;foo_delete&lt;/code&gt; is represented in Rust as &lt;code&gt;Option&amp;lt;Box&amp;lt;Foo&amp;gt;&amp;gt;&lt;/code&gt;, since &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; cannot be null.</source>
          <target state="translated">이 두 기능은 Rust에서 다음과 같이 구현 될 수 있습니다. 여기 에서 C 의 &lt;code&gt;struct Foo*&lt;/code&gt; 유형 은 소유권 제약 조건을 캡처하는 &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; 변환됩니다 . 에 널 (NULL) 인수도 있습니다 &lt;code&gt;foo_delete&lt;/code&gt; 가 로 녹에 표시되는 &lt;code&gt;Option&amp;lt;Box&amp;lt;Foo&amp;gt;&amp;gt;&lt;/code&gt; , 이후 &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; null 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6f982f08c4e46524b8318daa35d1f6508b56f9c5" translate="yes" xml:space="preserve">
          <source>These two terms are often used interchangeably, and what they are attempting to convey is the answer to the question &quot;Can this item be used at this location?&quot;</source>
          <target state="translated">이 두 용어는 종종 같은 의미로 사용되며,이 항목을 &quot;이 위치에서 사용할 수 있습니까?&quot;라는 질문에 대한 답이 전달하려고합니다.</target>
        </trans-unit>
        <trans-unit id="327e657798ef3a0fe98594c42be8998daff24b69" translate="yes" xml:space="preserve">
          <source>These types provide access to the underlying data through references to the type of that data. They are said to be &amp;lsquo;borrowed as&amp;rsquo; that type. For instance, a &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; can be borrowed as &lt;code&gt;T&lt;/code&gt; while a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; can be borrowed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">이러한 유형은 해당 데이터 유형에 대한 참조를 통해 기본 데이터에 대한 액세스를 제공합니다. 그들은 그 유형으로 '차용 된'것으로 알려져 있습니다. 예를 들어, &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 로 대여 할 수 &lt;code&gt;T&lt;/code&gt; 잠시 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 로 빌릴 수 있습니다 &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a24b18110788da060d08a87d6e0370b2f3f11b2d" translate="yes" xml:space="preserve">
          <source>These will always be ORed with &lt;code&gt;CREATE_UNICODE_ENVIRONMENT&lt;/code&gt;.</source>
          <target state="translated">이들은 항상 &lt;code&gt;CREATE_UNICODE_ENVIRONMENT&lt;/code&gt; 로 OR됩니다 .</target>
        </trans-unit>
        <trans-unit id="4d9283345c9b012905e98bac4c4ff6bf77874d49" translate="yes" xml:space="preserve">
          <source>They are &lt;code&gt;'static&lt;/code&gt; because they're stored directly in the final binary, and so will be valid for the &lt;code&gt;'static&lt;/code&gt; duration.</source>
          <target state="translated">그들은는 &lt;code&gt;'static&lt;/code&gt; 들이 최종 바이너리에 직접 저장하고, 그래서 유효합니다 때문에 &lt;code&gt;'static&lt;/code&gt; 기간입니다.</target>
        </trans-unit>
        <trans-unit id="86b3fa967e9ddc952d15703cad09add6ed0fe12c" translate="yes" xml:space="preserve">
          <source>They are never allowed before:</source>
          <target state="translated">그들은 전에 허용되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="a91c6bc4d714ec79e34b3b499dac181a1c8a5b61" translate="yes" xml:space="preserve">
          <source>They are written as &lt;code&gt;impl&lt;/code&gt; followed by a set of trait bounds.</source>
          <target state="translated">그것들은 일련의 특성 범위에 따라 &lt;code&gt;impl&lt;/code&gt; 으로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="d6f10b3f0570fbded7ab662d2bff2e38078266a6" translate="yes" xml:space="preserve">
          <source>They can be used as targets of transmutes in unsafe code for manipulating the raw representations directly.</source>
          <target state="translated">원시 표현을 직접 조작하기 위해 안전하지 않은 코드에서 변환 대상으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81857ae63bf1641ca750521f716199457233e82d" translate="yes" xml:space="preserve">
          <source>They never take parameters and never return types.</source>
          <target state="translated">매개 변수를 취하지 않으며 유형을 반환하지도 않습니다.</target>
        </trans-unit>
        <trans-unit id="3eb09871747750e3ee06b75fa9a63f7cfbbd1d29" translate="yes" xml:space="preserve">
          <source>Thin pointers are &quot;simple&quot; pointers: they are purely a reference to a memory address.</source>
          <target state="translated">얇은 포인터는 &quot;간단한&quot;포인터입니다. 순전히 메모리 주소에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="4d4a58caf1c3fd49804715c525d371aaf6cc87c9" translate="yes" xml:space="preserve">
          <source>Things can get a little tricky once you start intermingling the two types of positional specifiers. The &quot;next argument&quot; specifier can be thought of as an iterator over the argument. Each time a &quot;next argument&quot; specifier is seen, the iterator advances. This leads to behavior like this:</source>
          <target state="translated">두 가지 유형의 위치 지정자를 혼합하기 시작하면 약간 까다로울 수 있습니다. &quot;다음 인수&quot;지정자는 인수에 대한 반복자로 생각할 수 있습니다. &quot;다음 인수&quot;지정자가 보일 때마다 반복자가 진행됩니다. 이것은 다음과 같은 동작으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="9af9ddcb5af382b3006b61fbf3f41b42b2b57797" translate="yes" xml:space="preserve">
          <source>Think of a &lt;code&gt;match&lt;/code&gt; expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a &lt;code&gt;match&lt;/code&gt;, and at the first pattern the value &amp;ldquo;fits,&amp;rdquo; the value falls into the associated code block to be used during execution.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 표현은 동전 분류 기계와 같다고 생각하십시오 . 동전은 다양한 크기의 구멍이있는 트랙을 따라 내려 가고 각 동전은 맞은 첫 번째 구멍을 통해 떨어집니다. 같은 방식으로 값은 &lt;code&gt;match&lt;/code&gt; 에서 각 패턴을 통과 하고 첫 번째 패턴에서 값이 &quot;적합&quot;합니다. 값은 실행 중에 사용되는 관련 코드 블록에 속합니다.</target>
        </trans-unit>
        <trans-unit id="1fdd8b4a97ce68f59e33b3f6b509748be1aa6f2f" translate="yes" xml:space="preserve">
          <source>Think of being seated at a restaurant. When you enter, you state the number of people in your group, and the staff finds an empty table that fits everyone and leads you there. If someone in your group comes late, they can ask where you&amp;rsquo;ve been seated to find you.</source>
          <target state="translated">식당에 앉는 것을 생각하십시오. 입장하면 그룹의 인원 수를 알려주고 직원이 모든 사람에게 적합한 빈 테이블을 찾아서 안내합니다. 그룹의 누군가가 늦게 오면 내 자리를 찾은 위치를 물어볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0748eff7f6f3425a675a552a35d84af9fe1be56c" translate="yes" xml:space="preserve">
          <source>Thinking about the relationships another way, a parent node should own its children: if a parent node is dropped, its child nodes should be dropped as well. However, a child should not own its parent: if we drop a child node, the parent should still exist. This is a case for weak references!</source>
          <target state="translated">관계를 다른 방식으로 생각할 때 부모 노드는 자식을 소유해야합니다. 부모 노드를 삭제하면 자식 노드도 삭제해야합니다. 그러나 자식은 부모를 소유해서는 안됩니다. 자식 노드를 삭제해도 부모는 여전히 존재해야합니다. 이것은 약한 참조의 경우입니다!</target>
        </trans-unit>
        <trans-unit id="399cffdf26999603bae93a3715241addff90c419" translate="yes" xml:space="preserve">
          <source>Thinking in Terms of Lifetimes</source>
          <target state="translated">평생의 생각</target>
        </trans-unit>
        <trans-unit id="7407b5aadd0d88118f5b7bf8fb59e7e1d6d93882" translate="yes" xml:space="preserve">
          <source>Third, the &lt;code&gt;run&lt;/code&gt; function now returns an &lt;code&gt;Ok&lt;/code&gt; value in the success case. We&amp;rsquo;ve declared the &lt;code&gt;run&lt;/code&gt; function&amp;rsquo;s success type as &lt;code&gt;()&lt;/code&gt; in the signature, which means we need to wrap the unit type value in the &lt;code&gt;Ok&lt;/code&gt; value. This &lt;code&gt;Ok(())&lt;/code&gt; syntax might look a bit strange at first, but using &lt;code&gt;()&lt;/code&gt; like this is the idiomatic way to indicate that we&amp;rsquo;re calling &lt;code&gt;run&lt;/code&gt; for its side effects only; it doesn&amp;rsquo;t return a value we need.</source>
          <target state="translated">셋째, &lt;code&gt;run&lt;/code&gt; 함수는 이제 성공 사례에서 &lt;code&gt;Ok&lt;/code&gt; 값을 반환합니다 . &lt;code&gt;run&lt;/code&gt; 함수의 성공 유형을 서명에서 &lt;code&gt;()&lt;/code&gt; 로 선언했습니다. 즉, 단위 유형 값을 &lt;code&gt;Ok&lt;/code&gt; 값 으로 줄 바꿈해야 합니다. 이 &lt;code&gt;Ok(())&lt;/code&gt; 구문은 처음에는 조금 이상하게 보일 수 있지만, 이와 같이 &lt;code&gt;()&lt;/code&gt; 를 사용 하면 부작용에 대해서만 &lt;code&gt;run&lt;/code&gt; 을 호출한다는 것을 나타내는 관용적 방법입니다 . 필요한 값을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ed975d1877254eff4f647cec29b338bbca64ef4" translate="yes" xml:space="preserve">
          <source>Third, the standard library defines &lt;a href=&quot;prelude/index&quot;&gt;The Rust Prelude&lt;/a&gt;, a small collection of items - mostly traits - that are imported into every module of every crate. The traits in the prelude are pervasive, making the prelude documentation a good entry point to learning about the library.</source>
          <target state="translated">셋째, 표준 라이브러리는 모든 상자의 모든 모듈로 가져 오는 소량의 항목 (주로 특성)의 컬렉션 인 &lt;a href=&quot;prelude/index&quot;&gt;Rust Prelude를&lt;/a&gt; 정의합니다 . 전주곡의 특성이 널리 퍼져있어서 전주 문서를 도서관에 대해 배우기에 좋은 진입 점으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2c016402b0d7abec88d04b55dd5a8f4c018ceb4a" translate="yes" xml:space="preserve">
          <source>Third, you see the &lt;code&gt;&quot;Hello, world!&quot;&lt;/code&gt; string. We pass this string as an argument to &lt;code&gt;println!&lt;/code&gt;, and the string is printed to the screen.</source>
          <target state="translated">셋째, &lt;code&gt;&quot;Hello, world!&quot;&lt;/code&gt; 끈. 이 문자열을 &lt;code&gt;println!&lt;/code&gt; 대한 인수로 전달합니다 ! 문자열이 화면에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="756c69ab3ae5844d50aa9add76723030b90c2e84" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt; will be an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if there's some sort of intermittent IO error during iteration.</source>
          <target state="translated">이 &lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; 될 것입니다 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 반복하는 동안 간헐적 인 IO 오류의 일종이 있다면.</target>
        </trans-unit>
        <trans-unit id="45e5b6731a2eea68db70299dc76799ac1e3d8403" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;'s receiving half has disconnected, so the data could not be sent. The data is returned back to the callee in this case.</source>
          <target state="translated">이 &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt; 의 수신 절반이 연결 해제되어 데이터를 전송할 수 없습니다. 이 경우 데이터는 수신자에게 다시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e029dc532e12308a313b095f5b88bb0b2db85884" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;#[route]&lt;/code&gt; attribute would be defined by the framework as a procedural macro. The signature of the macro definition function would look like this:</source>
          <target state="translated">이 &lt;code&gt;#[route]&lt;/code&gt; 속성은 프레임 워크에 의해 절차 적 매크로로 정의됩니다. 매크로 정의 함수의 서명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc8fa4acf3fa662b100c7f01811572d66ca46b05" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Message&lt;/code&gt; enum will either be a &lt;code&gt;NewJob&lt;/code&gt; variant that holds the &lt;code&gt;Job&lt;/code&gt; the thread should run, or it will be a &lt;code&gt;Terminate&lt;/code&gt; variant that will cause the thread to exit its loop and stop.</source>
          <target state="translated">이 &lt;code&gt;Message&lt;/code&gt; 열거 형은 스레드가 실행해야하는 &lt;code&gt;Job&lt;/code&gt; 을 보유 하는 &lt;code&gt;NewJob&lt;/code&gt; 변형 이거나 스레드가 루프를 종료하고 정지 하게하는 &lt;code&gt;Terminate&lt;/code&gt; 변형입니다.</target>
        </trans-unit>
        <trans-unit id="2ac2c44f291b0094f7e740b5540fe932bd4487e6" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed from the &lt;a href=&quot;../struct.btreemap#method.entry&quot;&gt;&lt;code&gt;entry&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;enum&lt;/code&gt; 은 &lt;a href=&quot;../struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.btreemap#method.entry&quot;&gt; &lt;code&gt;entry&lt;/code&gt; &lt;/a&gt; 메서드에서 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="c64bdd9b3fc3f77ac39443372876ff3d0846511f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed from the &lt;a href=&quot;../struct.hashmap#method.entry&quot;&gt;&lt;code&gt;entry&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;enum&lt;/code&gt; 은 &lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.hashmap#method.entry&quot;&gt; &lt;code&gt;entry&lt;/code&gt; &lt;/a&gt; 메서드에서 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="df201a49abc9a95b4b9db82dff3855ec3856b74c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed from the &lt;a href=&quot;struct.btreemap#method.entry&quot;&gt;&lt;code&gt;entry&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;enum&lt;/code&gt; 은 &lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.btreemap#method.entry&quot;&gt; &lt;code&gt;entry&lt;/code&gt; &lt;/a&gt; 방법으로 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="78b77c0bae34af9fbe0dd6db2b8a03354e7c6a07" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed from the &lt;a href=&quot;struct.hashmap#method.entry&quot;&gt;&lt;code&gt;entry&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;enum&lt;/code&gt; 은 &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.hashmap#method.entry&quot;&gt; &lt;code&gt;entry&lt;/code&gt; &lt;/a&gt; 메소드로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e4ed5614390f8cd7c309ba2eff1ecf5972023c00" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed through the &lt;a href=&quot;../struct.hashmap#method.raw_entry_mut&quot;&gt;&lt;code&gt;raw_entry_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;, then calling one of the methods of that &lt;a href=&quot;struct.rawentrybuildermut&quot;&gt;&lt;code&gt;RawEntryBuilderMut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;enum&lt;/code&gt; 은 &lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.hashmap#method.raw_entry_mut&quot;&gt; &lt;code&gt;raw_entry_mut&lt;/code&gt; &lt;/a&gt; 메서드를 통해 생성 된 다음 해당 &lt;a href=&quot;struct.rawentrybuildermut&quot;&gt; &lt;code&gt;RawEntryBuilderMut&lt;/code&gt; &lt;/a&gt; 의 메서드 중 하나를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="e49b2cde36d96ef41241461160aaa7f39ffe4733" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed through the &lt;a href=&quot;struct.hashmap#method.raw_entry_mut&quot;&gt;&lt;code&gt;raw_entry_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;, then calling one of the methods of that &lt;a href=&quot;struct.rawentrybuildermut&quot;&gt;&lt;code&gt;RawEntryBuilderMut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;enum&lt;/code&gt; 은 &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.hashmap#method.raw_entry_mut&quot;&gt; &lt;code&gt;raw_entry_mut&lt;/code&gt; &lt;/a&gt; 메소드를 통해 생성 된 다음 해당 &lt;a href=&quot;struct.rawentrybuildermut&quot;&gt; &lt;code&gt;RawEntryBuilderMut&lt;/code&gt; &lt;/a&gt; 의 메소드 중 하나를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="484cddb60aced3f0fd2c66d36c2d02b11434898c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is created by iterating over &lt;a href=&quot;struct.components&quot;&gt;&lt;code&gt;Components&lt;/code&gt;&lt;/a&gt;, which in turn is created by the &lt;a href=&quot;struct.path#method.components&quot;&gt;&lt;code&gt;components&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;enum&lt;/code&gt; 은 &lt;a href=&quot;struct.components&quot;&gt; &lt;code&gt;Components&lt;/code&gt; &lt;/a&gt; 를 반복하여 만들어지며,이 &lt;a href=&quot;struct.path#method.components&quot;&gt; &lt;code&gt;components&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 의 구성 요소 메서드로 만들어집니다 .</target>
        </trans-unit>
        <trans-unit id="94a9ddcdadd6c80893c9aa067a5c5342d16c5ca8" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is slightly awkward: it will never actually exist. This error is part of the type signature of the implementation of &lt;a href=&quot;../str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;. The return type of &lt;a href=&quot;../str/trait.fromstr#tymethod.from_str&quot;&gt;&lt;code&gt;from_str&lt;/code&gt;&lt;/a&gt;, requires that an error be defined, but, given that a &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; can always be made into a new &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; without error, this type will never actually be returned. As such, it is only here to satisfy said signature, and is useless otherwise.</source>
          <target state="translated">이 &lt;code&gt;enum&lt;/code&gt; 은 약간 어색합니다. 실제로는 존재하지 않습니다. 이 오류는 &lt;a href=&quot;../str/trait.fromstr&quot;&gt; &lt;code&gt;FromStr&lt;/code&gt; &lt;/a&gt; on &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 구현의 형식 서명의 일부입니다 . &lt;a href=&quot;../str/trait.fromstr#tymethod.from_str&quot;&gt; &lt;code&gt;from_str&lt;/code&gt; &lt;/a&gt; 의 반환 유형은 오류를 정의해야하지만, 오류없이 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 을 항상 새 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 로 만들 수있는 경우이 유형은 실제로 반환되지 않습니다. 따라서, 상기 서명을 만족시키는 것은 단지 여기에 있으며, 그렇지 않으면 쓸모가 없다.</target>
        </trans-unit>
        <trans-unit id="7bafcd26f5f930140b3a1e3e5a967a8f857b2aca" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is used as the return type for &lt;a href=&quot;../primitive.f32#method.classify&quot;&gt;&lt;code&gt;f32::classify&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64#method.classify&quot;&gt;&lt;code&gt;f64::classify&lt;/code&gt;&lt;/a&gt;. See their documentation for more.</source>
          <target state="translated">이 &lt;code&gt;enum&lt;/code&gt; 은 &lt;a href=&quot;../primitive.f32#method.classify&quot;&gt; &lt;code&gt;f32::classify&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../primitive.f64#method.classify&quot;&gt; &lt;code&gt;f64::classify&lt;/code&gt; &lt;/a&gt; 의 반환 유형으로 사용됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="779a09142baa1b4c0c25a858cbd603a82e00fb14" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;new&lt;/code&gt; function creates a new, empty string. You&amp;rsquo;ll find a &lt;code&gt;new&lt;/code&gt; function on many types, because it&amp;rsquo;s a common name for a function that makes a new value of some kind.</source>
          <target state="translated">이 &lt;code&gt;new&lt;/code&gt; 함수는 새로운 빈 문자열을 만듭니다. 어떤 종류의 새로운 가치를 만드는 함수의 일반적인 이름이기 때문에 많은 유형에서 &lt;code&gt;new&lt;/code&gt; 함수를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87637c77d83fe48f3ea16980edd287161d7c7814" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;../struct.binaryheap#method.drain&quot;&gt;&lt;code&gt;BinaryHeap::drain()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.binaryheap#method.drain&quot;&gt; &lt;code&gt;BinaryHeap::drain()&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4f1beb7abacff5cc6b2aa66c11f692cb37b24895" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;../struct.binaryheap#method.into_iter&quot;&gt;&lt;code&gt;BinaryHeap::into_iter()&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.binaryheap#method.into_iter&quot;&gt; &lt;code&gt;BinaryHeap::into_iter()&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;IntoIterator&lt;/code&gt; 트레이 트 에 의해 제공됨 )에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="19187356eb493c3adfe1d6a3c45949ebe90718ce" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;../struct.binaryheap#method.iter&quot;&gt;&lt;code&gt;BinaryHeap::iter()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.binaryheap#method.iter&quot;&gt; &lt;code&gt;BinaryHeap::iter()&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ea9db5c8e782224fe1f85e1a720f71f672146c1f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;../struct.linkedlist#method.iter&quot;&gt;&lt;code&gt;LinkedList::iter()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.linkedlist#method.iter&quot;&gt; &lt;code&gt;LinkedList::iter()&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="365f4e6ab5c3e3c131d4abcf66926cc6d747c3d0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;../struct.linkedlist#method.iter_mut&quot;&gt;&lt;code&gt;LinkedList::iter_mut()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.linkedlist#method.iter_mut&quot;&gt; &lt;code&gt;LinkedList::iter_mut()&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ffa5a9dc90635ee7464510b7b23324baed884a35" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;struct.cstring#method.into_string&quot;&gt;&lt;code&gt;CString::into_string()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.cstring#method.into_string&quot;&gt; &lt;code&gt;CString::into_string()&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3a98a7a0b86bcb3ca3daaeceee9ee6241f18b9ac" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;struct.vec#method.drain&quot;&gt;&lt;code&gt;Vec::drain&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.vec#method.drain&quot;&gt; &lt;code&gt;Vec::drain&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bc70d905416c075e472dedc5615406f53740db49" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;Iterator::chain&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;Iterator::chain&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="05ed5bb9307267a5e340c3a66e14a4d93b6b2120" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;trait.iterator#method.flat_map&quot;&gt;&lt;code&gt;Iterator::flat_map&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator#method.flat_map&quot;&gt; &lt;code&gt;Iterator::flat_map&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f04b21219d876a2efb53733e31a16e7043a08a65" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;Iterator::fuse&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt; &lt;code&gt;Iterator::fuse&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b34a5adfa6d1f401a24be7fc9f321c6bf3e63061" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;trait.iterator#method.zip&quot;&gt;&lt;code&gt;Iterator::zip&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator#method.zip&quot;&gt; &lt;code&gt;Iterator::zip&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7f5b4ce43667b25dc7c0338aa4a9d348ba82ad8b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../../iter/trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 에 의해 생성 &lt;a href=&quot;../../iter/trait.intoiterator#tymethod.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; 용&lt;/a&gt; 에있어서 &lt;a href=&quot;../struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt; (의해 제공 &lt;code&gt;IntoIterator&lt;/code&gt; 의 특성). 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c15db34b76ad48367be1e50fb80a630f7544ccea" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../../iter/trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 에 의해 생성 &lt;a href=&quot;../../iter/trait.intoiterator#tymethod.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; 용&lt;/a&gt; 에있어서 &lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; (의해 제공 &lt;code&gt;IntoIterator&lt;/code&gt; 의 특성). 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8af255e3f384d8c63465da3dc3dea71b03731e21" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../../iter/trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 에 의해 생성 &lt;a href=&quot;../../iter/trait.intoiterator#tymethod.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; 용&lt;/a&gt; 에있어서 &lt;a href=&quot;../struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; 의&lt;/a&gt; (의해 제공 &lt;code&gt;IntoIterator&lt;/code&gt; 의 특성). 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="04527249225c0957b4a2dad0cb713b606320b989" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../primitive.char#method.escape_debug&quot;&gt;&lt;code&gt;escape_debug&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.char#method.escape_debug&quot;&gt; &lt;code&gt;escape_debug&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="db12edeeb870acc98aa06b33b39a8bb3d306d517" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../primitive.char#method.escape_default&quot;&gt;&lt;code&gt;escape_default&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.char#method.escape_default&quot;&gt; &lt;code&gt;escape_default&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cc81870e647a4c66d45285572c3d1fa6c0473baa" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../primitive.char#method.escape_unicode&quot;&gt;&lt;code&gt;escape_unicode&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.char#method.escape_unicode&quot;&gt; &lt;code&gt;escape_unicode&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1fe84815a63364d86bf9311c9ac78e8bdb20701b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../primitive.char#method.to_lowercase&quot;&gt;&lt;code&gt;to_lowercase&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.char#method.to_lowercase&quot;&gt; &lt;code&gt;to_lowercase&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="27eb64d64fc617e07c6f09849f8a1efd113c9e7c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../primitive.char#method.to_uppercase&quot;&gt;&lt;code&gt;to_uppercase&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.char#method.to_uppercase&quot;&gt; &lt;code&gt;to_uppercase&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="23afadfd08d170366a910c9a9eb67a47d53c58e4" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.binaryheap#method.peek_mut&quot;&gt;&lt;code&gt;peek_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.binaryheap&quot;&gt; &lt;code&gt;BinaryHeap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.binaryheap#method.peek_mut&quot;&gt; &lt;code&gt;peek_mut&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3045bd58f26065df50d0790fb43c60769a4e62d7" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.btreemap#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="946c012883128ea40231fbdcbdc1a628bae08f1e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 에 의해 생성 &lt;a href=&quot;../struct.btreemap#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt; 에 방법 &lt;a href=&quot;../struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt; . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="74b659096d73f7bbdedbdc8e5c8915fc609d68c8" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.keys&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.btreemap#method.keys&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7dc938cc7827ae09ff7a33e57fec9dc1ea67e47b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.btreemap#method.range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d48ee20f7abe01686d61e8b564a9e2e8709cc261" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.range_mut&quot;&gt;&lt;code&gt;range_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 에 의해 생성 &lt;a href=&quot;../struct.btreemap#method.range_mut&quot;&gt; &lt;code&gt;range_mut&lt;/code&gt; 의&lt;/a&gt; 에 방법 &lt;a href=&quot;../struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt; . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7a6de9bc6d12983868c379e76acf4b7b905e3489" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.values&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.btreemap#method.values&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d705a35c8c3bfa5da6919c4661f259de8364f195" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.values_mut&quot;&gt;&lt;code&gt;values_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 에 의해 생성 &lt;a href=&quot;../struct.btreemap#method.values_mut&quot;&gt; &lt;code&gt;values_mut&lt;/code&gt; 의&lt;/a&gt; 에 방법 &lt;a href=&quot;../struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt; . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="61f91f31f3bd872cb2fbd24fadf5b75ed09458a4" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.difference&quot;&gt;&lt;code&gt;difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.btreeset#method.difference&quot;&gt; &lt;code&gt;difference&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2e1d52e053b2cbaba0cc8f9612b34ec9509994b9" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.intersection&quot;&gt;&lt;code&gt;intersection&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.btreeset#method.intersection&quot;&gt; &lt;code&gt;intersection&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="954e936cd5243200003d839739bf6bf3e1d2ccbf" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 에 의해 생성 &lt;a href=&quot;../struct.btreeset#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; 용&lt;/a&gt; 에있어서 &lt;a href=&quot;../struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt; (의해 제공 &lt;code&gt;IntoIterator&lt;/code&gt; 의 특성). 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3c45f5db49cb3dd47f14e3527ee6323bafd674c6" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.btreeset#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="53de499d6a94e0c9ad1a96537dd61a0c1c130aff" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.btreeset#method.range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c55b8ab08d80bad9c8193338715f67b024c7ee2c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.symmetric_difference&quot;&gt;&lt;code&gt;symmetric_difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.btreeset#method.symmetric_difference&quot;&gt; &lt;code&gt;symmetric_difference&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="34001f1785210d90fc10385cb9a1251eed89d761" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.btreeset#method.union&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6645dd14e44dee8f928de9c50e60665ec2facacc" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.hashmap#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="50fc5746ddfb14a344eb233b7116066c64b4c8c4" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.hashmap#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a09bcc28d870cda3d50f44865ac154f6c773dbcc" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.hashmap#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b3485f5d7a78d5f8bb97e7e58730359d2b64777f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.keys&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.hashmap#method.keys&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b03cef3dcf96a8183c51975b4910dd74475edf71" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.values&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.hashmap#method.values&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="53c20090054cf2ac21ecbfded86e3ada5a3c452b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.values_mut&quot;&gt;&lt;code&gt;values_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.hashmap#method.values_mut&quot;&gt; &lt;code&gt;values_mut&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="92667a13f4b88964b565e8c1428280771a1f58ae" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashset#method.difference&quot;&gt;&lt;code&gt;difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.hashset#method.difference&quot;&gt; &lt;code&gt;difference&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8b53023bc8c2f123d3aa8476357c0065c17e5bc5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashset#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.hashset#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e0c7b733ae497921c7ee1e58f9d3737d0bc5abf0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashset#method.intersection&quot;&gt;&lt;code&gt;intersection&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.hashset#method.intersection&quot;&gt; &lt;code&gt;intersection&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7faf396162375db95ee521b7f44471b3dddb5889" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashset#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.hashset#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="14c7d030bde45fb3ec268ba764828f4e1837eb77" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashset#method.symmetric_difference&quot;&gt;&lt;code&gt;symmetric_difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.hashset#method.symmetric_difference&quot;&gt; &lt;code&gt;symmetric_difference&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fce08bc41dc77fbc27830928bbf1bf5b41c36d96" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashset#method.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.hashset#method.union&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="265bcebc25d757509c4b717937ff253a8b8647e5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.linkedlist#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 에 의해 생성 &lt;a href=&quot;../struct.linkedlist#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; 용&lt;/a&gt; 에있어서 &lt;a href=&quot;../struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; 의&lt;/a&gt; (의해 제공 &lt;code&gt;IntoIterator&lt;/code&gt; 의 특성). 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ae30ff0dcb4ca01b32359edc18207fe2e8799225" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.vecdeque#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.vecdeque#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d0622f000a63c5582f4bf61c6400ba69e79c3e9b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.vecdeque#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 에 의해 생성 &lt;a href=&quot;../struct.vecdeque#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; 용&lt;/a&gt; 에있어서 &lt;a href=&quot;../struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt; (의해 제공 &lt;code&gt;IntoIterator&lt;/code&gt; 의 특성). 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9c39e95770f6e995aeb4f6547fcd0d3b5d042bb7" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.vecdeque#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;../struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../struct.vecdeque#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a2950ed2e16c6715dede3635ac1905a727cb8d87" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.vecdeque#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 에 의해 생성 &lt;a href=&quot;../struct.vecdeque#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt; 에 방법 &lt;a href=&quot;../struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt; . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="df020e51f3f4500bc1f8be7714b7e55fb7923be6" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;enum.option#method.into_iter&quot;&gt;&lt;code&gt;Option::into_iter&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;enum.option#method.into_iter&quot;&gt; &lt;code&gt;Option::into_iter&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ed85839c71b9b41d697c086ba092e08ee354cb7a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;enum.option#method.iter&quot;&gt;&lt;code&gt;Option::iter&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;enum.option#method.iter&quot;&gt; &lt;code&gt;Option::iter&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="f832fbc0a1897989e972bccbdf14ab8c06df2a8b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;enum.option#method.iter_mut&quot;&gt;&lt;code&gt;Option::iter_mut&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;enum.option#method.iter_mut&quot;&gt; &lt;code&gt;Option::iter_mut&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="29c33d9d981b66ee3e763795fb7a865338012f4a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty()&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f3c09e42d5e7d0d1aee87da5c6a31ae546137c1a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="583b1959fdeeb9dda8ffebe215f3e85158c8bc2e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.escape_default&quot;&gt;&lt;code&gt;escape_default&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;fn.escape_default&quot;&gt; &lt;code&gt;escape_default&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2441b8d854782799a5af16365bc544396e7a30e1" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.from_fn&quot;&gt;&lt;code&gt;iter::from_fn()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;fn.from_fn&quot;&gt; &lt;code&gt;iter::from_fn()&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="be7c13071482b2c3923f2e736bd014b0019bfa3c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.from_fn&quot;&gt;&lt;code&gt;iter::from_fn&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;fn.from_fn&quot;&gt; &lt;code&gt;iter::from_fn&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="94d40c5fdbd8b948ffc41faa923b27505f807e3f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.once&quot;&gt;&lt;code&gt;once()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;fn.once&quot;&gt; &lt;code&gt;once()&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b2d0d0c848c068f0195f43a41a604e9ed15435ea" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.once&quot;&gt;&lt;code&gt;once&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;fn.once&quot;&gt; &lt;code&gt;once&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8bb25d152dad7b00112a30e9ef34eaf19e870657" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.once_with&quot;&gt;&lt;code&gt;once_with()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;fn.once_with&quot;&gt; &lt;code&gt;once_with()&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="582110272ac53674cd7341259d0b80e92c531007" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.once_with&quot;&gt;&lt;code&gt;once_with&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;fn.once_with&quot;&gt; &lt;code&gt;once_with&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c2e53dc5041d32296d06a4432a5dc5ef029bc8fa" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat()&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f750c0f224dd89d4b261959a2e6c2e0e53f46764" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="66f063558b4204049186f9de5672edf7bb33b08f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;fn.repeat_with&quot;&gt; &lt;code&gt;repeat_with()&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="937c3c66fd7a919cfaca746517ec0915d37c92b5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;fn.repeat_with&quot;&gt; &lt;code&gt;repeat_with&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aab81d3f94443c5e362d592846bb5f615688f696" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; function and the &lt;a href=&quot;struct.builder#method.spawn&quot;&gt;&lt;code&gt;thread::Builder::spawn&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt; 함수와 &lt;a href=&quot;struct.builder#method.spawn&quot;&gt; &lt;code&gt;thread::Builder::spawn&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="721e1f5adffa977a66b66d77bbfc4af0a336248f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.successors&quot;&gt;&lt;code&gt;iter::successors()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;fn.successors&quot;&gt; &lt;code&gt;iter::successors()&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2bba3b7b1d3ddee116465f88074412d173b46ad3" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.successors&quot;&gt;&lt;code&gt;successors&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;fn.successors&quot;&gt; &lt;code&gt;successors&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="750025df63cee4f9476b600e410c271d4dc26282" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.binaryheap#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.binaryheap&quot;&gt; &lt;code&gt;BinaryHeap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.binaryheap#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e18a9e9bb705ac20d27c1b54b01a06909af9f5aa" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.binaryheap#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.binaryheap&quot;&gt; &lt;code&gt;BinaryHeap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.binaryheap#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt; 메소드 ( &lt;code&gt;IntoIterator&lt;/code&gt; 특성으로 제공)에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="41506355b29f22e9b8811a8d2b60d92fed5ea6d5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.binaryheap#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.binaryheap&quot;&gt; &lt;code&gt;BinaryHeap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.binaryheap#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e9675a6cb1b893dbb78e5cb9089bf79a6f234027" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.binaryheap#method.peek_mut&quot;&gt;&lt;code&gt;peek_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.binaryheap&quot;&gt; &lt;code&gt;BinaryHeap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.binaryheap#method.peek_mut&quot;&gt; &lt;code&gt;peek_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a3e0e69a8fe926bff3713eb4f60caf8069defb24" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 에 의해 생성 &lt;a href=&quot;struct.btreemap#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; 용&lt;/a&gt; 에있어서 &lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt; (의해 제공 &lt;code&gt;IntoIterator&lt;/code&gt; 의 특성). 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="514e5b56a0002147cc9f7ac8a43433a6a65225d9" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.btreemap#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다. . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f716d42a3e459fcee9b6f36db5dc5c8168d480b5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 에 의해 생성 &lt;a href=&quot;struct.btreemap#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt; 에 방법 &lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt; . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1f4535b44687ead67d4ff87d0edaec473f93f580" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.keys&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.btreemap#method.keys&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다. . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d31858adce6dfcdec67ca057f391304b96efe373" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.btreemap#method.range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="beff4242dfe6af7e412bdc0cbf43b9ab3e974e59" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.range_mut&quot;&gt;&lt;code&gt;range_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 에 의해 생성 &lt;a href=&quot;struct.btreemap#method.range_mut&quot;&gt; &lt;code&gt;range_mut&lt;/code&gt; 의&lt;/a&gt; 에 방법 &lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt; . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="61ccad7bbc2caef64224c9df6c46da6d30f71236" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.values&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.btreemap#method.values&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다. . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="32f656567e75b1c61207668fdcd4fee681fb158f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.values_mut&quot;&gt;&lt;code&gt;values_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 에 의해 생성 &lt;a href=&quot;struct.btreemap#method.values_mut&quot;&gt; &lt;code&gt;values_mut&lt;/code&gt; 의&lt;/a&gt; 에 방법 &lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt; . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="954c25018729177ec5a7cd425af966f38ad45de9" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.difference&quot;&gt;&lt;code&gt;difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.btreeset#method.difference&quot;&gt; &lt;code&gt;difference&lt;/code&gt; &lt;/a&gt; 방법으로 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="311036e0ac34eb0ce755d849d1ee9dcf0da2fa6d" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.intersection&quot;&gt;&lt;code&gt;intersection&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.btreeset#method.intersection&quot;&gt; &lt;code&gt;intersection&lt;/code&gt; &lt;/a&gt; 방법에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cd64d67da228b8471603fbb0b2df44241b404edf" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 에 의해 생성 &lt;a href=&quot;struct.btreeset#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; 용&lt;/a&gt; 에있어서 &lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt; (의해 제공된 &lt;code&gt;IntoIterator&lt;/code&gt; 의 특성). 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b2d51f3eed3f11c0fe92a56c05aa30ba63101b5b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.btreeset#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다. . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4952396a08a80db78884e7472ef4fcdc98f30b89" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.btreeset#method.range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="03065ec43e94189db8db5b6c22bcd04c4d9e3d5f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.symmetric_difference&quot;&gt;&lt;code&gt;symmetric_difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.btreeset#method.symmetric_difference&quot;&gt; &lt;code&gt;symmetric_difference&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다. . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="06c95a89e54823ffe6dff81406fba47c36a4dc6c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.btreeset#method.union&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="512853e49000d203253875f2ca8249d15ea7353e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.cstring#method.into_string&quot;&gt;&lt;code&gt;into_string&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.cstring#method.into_string&quot;&gt; &lt;code&gt;into_string&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="faa8b1395fad10dcbfc423094256b61e6d205866" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.hashmap#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0800ef408d255e0937c01c82d43d77be20d45343" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.hashmap#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 ( &lt;code&gt;IntoIterator&lt;/code&gt; 특성으로 제공). 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0608e2c033c0bbc3bd28c971540c2b970498e946" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.hashmap#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다. . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0d3d57080a3c9ea2da73c2cffa1d26e9e4a02705" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.hashmap#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="24475378883de5203105dba62856d4abf99e3544" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.keys&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.hashmap#method.keys&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9d0295f8ffe26eaa9c9d5777a9c742f561e9829a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.values&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.hashmap#method.values&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다. . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="29c5ae45f57800a030c9d11a0a477ba58c24833e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.values_mut&quot;&gt;&lt;code&gt;values_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.hashmap#method.values_mut&quot;&gt; &lt;code&gt;values_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 됩니다. 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7513d477a389bb5cb5a430e327122b1af796c3fd" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.difference&quot;&gt;&lt;code&gt;difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.hashset#method.difference&quot;&gt; &lt;code&gt;difference&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="86301ec13deb5075922cbd995e23feac257a9d81" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.hashset#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3ebb8dfa5cf525c05fe6f08d21ee543480482796" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.intersection&quot;&gt;&lt;code&gt;intersection&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.hashset#method.intersection&quot;&gt; &lt;code&gt;intersection&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b4fe9a5189ce4199be4828187c5779ad99c77194" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.hashset#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 ( IntoIterator 에 의해 &lt;code&gt;IntoIterator&lt;/code&gt; 특성에서 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d0c83c37cc0812ff3b4a5b7bded4f379cae37eda" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.hashset#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다. . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2eb620627c49c8366b81c168c1e2da24ad0ba352" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.symmetric_difference&quot;&gt;&lt;code&gt;symmetric_difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.hashset#method.symmetric_difference&quot;&gt; &lt;code&gt;symmetric_difference&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="150f20ec4e603307925c0aee02dfd449f9a510cf" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.hashset#method.union&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2d89966c70887a327798b302de57b322446d731d" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.linkedlist#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.linkedlist#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt; 메소드 ( &lt;code&gt;IntoIterator&lt;/code&gt; 특성으로 제공)에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="58115891c3a0ac7312c6ea2a52ac61968cc4906c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.linkedlist#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.linkedlist#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다. . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f0659eea6bed999fa3680d324080162cd5e8a132" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.linkedlist#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.linkedlist#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0aae0dd86db056d40eff085617d4cf75e5ca4cd1" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.path#method.ancestors&quot;&gt;&lt;code&gt;ancestors&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.path#method.ancestors&quot;&gt; &lt;code&gt;ancestors&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="678416258ee794f65fdd4a1cd12a337537c5938c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.path#method.components&quot;&gt;&lt;code&gt;components&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.path#method.components&quot;&gt; &lt;code&gt;components&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f7998e185f302bc549a882f13518743e61ee46ed" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.path#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.path#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2cd612b3807ec02a5c6d66e1f1c48af60492df83" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.path#method.strip_prefix&quot;&gt;&lt;code&gt;strip_prefix&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.path#method.strip_prefix&quot;&gt; &lt;code&gt;strip_prefix&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="088542ff6ce5390ea17e8720dd59c0a74e6b5452" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.tcplistener#method.incoming&quot;&gt;&lt;code&gt;TcpListener::incoming&lt;/code&gt;&lt;/a&gt; method. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.tcplistener#method.incoming&quot;&gt; &lt;code&gt;TcpListener::incoming&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1b5816e88e64a2f2821568b7180ce9b608c65d11" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.tcplistener#method.incoming&quot;&gt;&lt;code&gt;incoming&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;struct.tcplistener#method.incoming&quot;&gt; &lt;code&gt;incoming&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1f4d8367fad76ae04d5e19a5385a27f59c0aaf13" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.vec#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.vec#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="5f3bc5ceaa1713a6dc6144c9424b5691a097a496" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.vecdeque#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.vecdeque#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b345fb68ea41cbf5a17dfb308f9d1a6e9820cc06" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.vecdeque#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 에 의해 생성 &lt;a href=&quot;struct.vecdeque#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; 용&lt;/a&gt; 에있어서 &lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt; (의해 제공 &lt;code&gt;IntoIterator&lt;/code&gt; 의 특성). 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5c15922d5946c2fdadf8c55e5b28d91817f56274" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.vecdeque#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.vecdeque#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6dcf16ee1a7554354a5a44529cc2c194dcf3a513" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.vecdeque#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 에 의해 생성 &lt;a href=&quot;struct.vecdeque#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt; 에 방법 &lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt; . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c378dde9d0a6525bd047bdf905231180a99f3491" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b7e65fcf3ce565260fcf0013397e867c30f8522f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.cloned&quot;&gt;&lt;code&gt;cloned&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.cloned&quot;&gt; &lt;code&gt;cloned&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f5b898ca8f830f2683dbb470bc2669fdcc151557" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.copied&quot;&gt;&lt;code&gt;copied&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.copied&quot;&gt; &lt;code&gt;copied&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6792715370c3a92e84d28374f5832cff5986bd03" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.cycle&quot;&gt;&lt;code&gt;cycle&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.cycle&quot;&gt; &lt;code&gt;cycle&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eef34875ae92021a31b6bedf0e5ef3ef03a55346" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.enumerate&quot;&gt;&lt;code&gt;enumerate&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.enumerate&quot;&gt; &lt;code&gt;enumerate&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9fb0d2f619194cb6fd2c5912cd0ab4f8aa1436b0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7b10e5f9bf83042ee3e1d8a41324ee574deb204c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.filter_map&quot;&gt;&lt;code&gt;filter_map&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.filter_map&quot;&gt; &lt;code&gt;filter_map&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e8efe5c2b3a46412d14b079c4efde7503ec17047" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.flat_map&quot;&gt;&lt;code&gt;flat_map&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.flat_map&quot;&gt; &lt;code&gt;flat_map&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="06ac94503cae6df0f4ea2938d28112afa01fe8f9" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.flatten&quot;&gt;&lt;code&gt;flatten&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.flatten&quot;&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b8c0c8898fdf0a69bb894be3b262576aa94693ed" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;fuse&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt; &lt;code&gt;fuse&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="16538eabad39936ba061176498ea306e212f6f92" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.inspect&quot;&gt;&lt;code&gt;inspect&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.inspect&quot;&gt; &lt;code&gt;inspect&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a0b5389b001bb0bbe98e28bcb36e5aebd8a66723" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2a63b8c96bdf4e631228dfff76c51a72895aa1c2" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.peekable&quot;&gt;&lt;code&gt;peekable&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.peekable&quot;&gt; &lt;code&gt;peekable&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="77b9d3dc967cfc65e7923a1d25d998d0359bf8da" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.rev&quot;&gt;&lt;code&gt;rev&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.rev&quot;&gt; &lt;code&gt;rev&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다. . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0c534d67b85da417a0620daeb199532327c51e03" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.scan&quot;&gt;&lt;code&gt;scan&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.scan&quot;&gt; &lt;code&gt;scan&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d55ea7e68cc78050a3929f56a9674ef3cbe9031c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.skip&quot;&gt;&lt;code&gt;skip&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.skip&quot;&gt; &lt;code&gt;skip&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="752b3b9ee442b1ede4f01e7280612ee155b893b6" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.skip_while&quot;&gt;&lt;code&gt;skip_while&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.skip_while&quot;&gt; &lt;code&gt;skip_while&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e4194d8e81f0d479a0971b522dc10170de8177ce" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.step_by&quot;&gt;&lt;code&gt;step_by&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.step_by&quot;&gt; &lt;code&gt;step_by&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ae2f32a2383fa23779c3295dfc6285ad6be64c98" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다. . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="431a8793b970c81fcc0ab5b7d979a63311ac642a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.take_while&quot;&gt;&lt;code&gt;take_while&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.take_while&quot;&gt; &lt;code&gt;take_while&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f6420f53e024dcbfd568efb25b94839f7a579e39" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;trait.iterator#method.zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8be96a57f8e063c35aa0cfee79161d9fbe1f4027" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;code&gt;into_iter&lt;/code&gt; method on &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; (provided by the &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; trait).</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 &lt;a href=&quot;struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;into_iter&lt;/code&gt; 메소드 ( &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; 특성으로 제공)에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="75da1f33c5a1b29ca9ce3084de81aca63a2c8c06" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is used to represent the exit status of a child process. Child processes are created via the &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt; struct and their exit status is exposed through the &lt;a href=&quot;struct.command#method.status&quot;&gt;&lt;code&gt;status&lt;/code&gt;&lt;/a&gt; method, or the &lt;a href=&quot;struct.child#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt; process.</source>
          <target state="translated">이 &lt;code&gt;struct&lt;/code&gt; 는 자식 프로세스의 종료 상태를 나타내는 데 사용됩니다. 하위 프로세스는 &lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt; 구조체 를 통해 작성되며 종료 상태는 &lt;a href=&quot;struct.command#method.status&quot;&gt; &lt;code&gt;status&lt;/code&gt; &lt;/a&gt; 메소드 또는 &lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt; 프로세스 의 &lt;a href=&quot;struct.child#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 메소드를 통해 노출 됩니다.</target>
        </trans-unit>
        <trans-unit id="5f5bb1decbaa26846cd44955c2f8ab7127199a37" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;use&lt;/code&gt; statement brings all public items defined in &lt;code&gt;std::collections&lt;/code&gt; into the current scope. Be careful when using the glob operator! Glob can make it harder to tell what names are in scope and where a name used in your program was defined.</source>
          <target state="translated">이 &lt;code&gt;use&lt;/code&gt; 문은 &lt;code&gt;std::collections&lt;/code&gt; 에 정의 된 모든 공용 항목을 현재 범위로 가져옵니다 . glob 연산자를 사용할 때주의하십시오! Glob은 범위에 속하는 이름과 프로그램에서 사용 된 이름이 정의 된 위치를 파악하기 어렵게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="caecafb5a4fb0937d47c4a448338d709acd25fe7" translate="yes" xml:space="preserve">
          <source>This &lt;strong&gt;channel&lt;/strong&gt; is currently empty, but the &lt;strong&gt;Sender&lt;/strong&gt;(s) have not yet disconnected, so data may yet become available.</source>
          <target state="translated">이 &lt;strong&gt;채널&lt;/strong&gt; 은 현재 비어 있지만 &lt;strong&gt;발신자&lt;/strong&gt; 연결이 아직 끊어지지 않아 데이터를 아직 사용할 수 없게 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8266d9d9a47bf63d7284fb3019e831be816c08a4" translate="yes" xml:space="preserve">
          <source>This Greek letter convention is usually just employed when the presence of a sequence is a technical detail; in particular, when we wish to &lt;em&gt;emphasize&lt;/em&gt; that we are operating on a sequence of token-trees, we will use the notation &quot;tt ...&quot; for the sequence, not a Greek letter.</source>
          <target state="translated">이 그리스 문자 표기법은 일반적으로 시퀀스의 존재가 기술적 세부 사항 일 때 사용됩니다. 특히, 일련의 토큰 트리에서 작업 &lt;em&gt;하고&lt;/em&gt; 있음 을 &lt;em&gt;강조&lt;/em&gt; 하고 싶다면 그리스 문자가 아닌 시퀀스에 &quot;tt ...&quot;표기법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="75b75d5ae6c1390e9d9181dd6cf33a8dbc7fda14" translate="yes" xml:space="preserve">
          <source>This alias exists for backwards compatibility, and may be eventually deprecated.</source>
          <target state="translated">이 별칭은 이전 버전과의 호환성을 위해 존재하며 결국 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b20bc4e00b7823d1d79ae42b369f4aec802629c" translate="yes" xml:space="preserve">
          <source>This allows a program to terminate immediately and provide feedback to the caller of the program. &lt;code&gt;panic!&lt;/code&gt; should be used when a program reaches an unrecoverable state.</source>
          <target state="translated">이를 통해 프로그램이 즉시 종료되고 프로그램 호출자에게 피드백을 제공 할 수 있습니다. &lt;code&gt;panic!&lt;/code&gt; 프로그램이 복구 불가능한 상태에 도달하면 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="720612fc48419da4fea633357e945fe3ab75a62a" translate="yes" xml:space="preserve">
          <source>This allows creating a custom iterator with any behavior without using the more verbose syntax of creating a dedicated type and implementing the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; trait for it.</source>
          <target state="translated">이를 통해 전용 유형을 생성하고 이에 대한 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 특성을 구현하는보다 자세한 구문을 사용하지 않고도 모든 동작으로 사용자 지정 반복기를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8257259a712f5169c7b4c3c0a8b238e35c31bcfe" translate="yes" xml:space="preserve">
          <source>This allows creating a custom iterator with any behavior without using the more verbose syntax of creating a dedicated type and implementing the &lt;code&gt;Iterator&lt;/code&gt; trait for it.</source>
          <target state="translated">이를 통해 전용 유형을 작성하고 이에 대한 &lt;code&gt;Iterator&lt;/code&gt; 특성을 구현하는 더 자세한 구문을 사용하지 않고도 모든 동작으로 사용자 정의 반복자를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df65a862360a6e0bd203ebc75d215550a55a7ec8" translate="yes" xml:space="preserve">
          <source>This allows the value to be dropped again.</source>
          <target state="translated">이를 통해 값을 다시 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f7c82b24f94be6c3280942f62546df8a8a85985" translate="yes" xml:space="preserve">
          <source>This allows writing a projection that creates a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt;, thus witnessing that the field is pinned:</source>
          <target state="translated">이렇게하면 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; 를 생성하는 프로젝션을 작성할 수 있으므로 필드가 고정되었는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e583956f9df46a2ff992eeadbf1d346839209a48" translate="yes" xml:space="preserve">
          <source>This allows writing a projection that creates a &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt;, thus witnessing that the field is pinned:</source>
          <target state="translated">이를 통해 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; 를 생성하는 투영을 작성 하여 필드가 고정되었음을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ed737638d9ae3e5d76efaebf6336aa8e810e97d" translate="yes" xml:space="preserve">
          <source>This allows your code to type-check, which is useful if you are prototyping or implementing a trait that requires multiple methods which you don't plan of using all of.</source>
          <target state="translated">이를 통해 코드의 유형 검사를 수행 할 수 있으며, 이는 모두 사용할 계획이없는 여러 메서드가 필요한 특성을 프로토 타이핑하거나 구현하는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d056f20cad4a501761c404be3055779184b1614f" translate="yes" xml:space="preserve">
          <source>This also in turn requires the annotation &lt;code&gt;T: 'a&lt;/code&gt;, indicating that any references in &lt;code&gt;T&lt;/code&gt; are valid over the lifetime &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">이것은 또한 주석 &lt;code&gt;T: 'a&lt;/code&gt; 필요로 하며 , 이는 &lt;code&gt;T&lt;/code&gt; 의 모든 참조 가 수명 동안 유효하다는 &lt;code&gt;'a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60e1ada09db527973a7bebfb74dc7b9bbc576185" translate="yes" xml:space="preserve">
          <source>This also means that all resources such as file descriptors and memory-mapped regions got duplicated. It is your responsibility to make sure that the closure does not violate library invariants by making invalid use of these duplicates.</source>
          <target state="translated">이는 또한 파일 디스크립터 및 메모리 매핑 영역과 같은 모든 리소스가 복제되었음을 의미합니다. 이러한 복제본을 잘못 사용하여 클로저가 라이브러리 변형을 위반하지 않도록하는 것은 귀하의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="c5dab5f83abd965944fb4f235779eceb37146b12" translate="yes" xml:space="preserve">
          <source>This and &lt;a href=&quot;../macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt; emit their output to stdout. Similarly to the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro, the goal of these macros is to avoid intermediate allocations when printing output. Example usage is:</source>
          <target state="translated">이것과 &lt;a href=&quot;../macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt;출력을 stdout으로 내 보냅니다. &lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt; 비슷합니다 ! 매크로, 이러한 매크로의 목표는 출력을 인쇄 할 때 중간 할당을 피하는 것입니다. 사용 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="acaf201fd6cc02b279b5987151a707c144a7e5c9" translate="yes" xml:space="preserve">
          <source>This and &lt;a href=&quot;../macro.writeln&quot;&gt;&lt;code&gt;writeln!&lt;/code&gt;&lt;/a&gt; are two macros which are used to emit the format string to a specified stream. This is used to prevent intermediate allocations of format strings and instead directly write the output. Under the hood, this function is actually invoking the &lt;a href=&quot;../io/trait.write#method.write_fmt&quot;&gt;&lt;code&gt;write_fmt&lt;/code&gt;&lt;/a&gt; function defined on the &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;std::io::Write&lt;/code&gt;&lt;/a&gt; trait. Example usage is:</source>
          <target state="translated">이것과 &lt;a href=&quot;../macro.writeln&quot;&gt; &lt;code&gt;writeln!&lt;/code&gt; &lt;/a&gt;형식 문자열을 지정된 스트림으로 내보내는 데 사용되는 두 개의 매크로입니다. 형식 문자열의 중간 할당을 방지하고 대신 출력을 직접 작성하는 데 사용됩니다. 후드에서이 함수는 실제로 &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;std::io::Write&lt;/code&gt; &lt;/a&gt; 특성 에 정의 된 &lt;a href=&quot;../io/trait.write#method.write_fmt&quot;&gt; &lt;code&gt;write_fmt&lt;/code&gt; &lt;/a&gt; 함수 를 호출합니다 . 사용 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7dd14a6dd33e863c7c3a9afcbc1b94db44474940" translate="yes" xml:space="preserve">
          <source>This appendix contains a glossary of Rust&amp;rsquo;s syntax, including operators and other symbols that appear by themselves or in the context of paths, generics, trait bounds, macros, attributes, comments, tuples, and brackets.</source>
          <target state="translated">이 부록에는 그 자체로 또는 경로, 제네릭, 특성 범위, 매크로, 속성, 주석, 튜플 및 괄호와 관련하여 나타나는 연산자 및 기타 기호를 포함하여 Rust 구문에 대한 용어집이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="98f7d37c50386fc1a7bc45c602df60e2a6b2f88d" translate="yes" xml:space="preserve">
          <source>This appendix is about how Rust is made and how that affects you as a Rust developer.</source>
          <target state="translated">이 부록은 Rust의 제작 방법과 Rust 개발자로서의 영향에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="0a5a5ca6ad8b433739f4a95c725e50e77d092d65" translate="yes" xml:space="preserve">
          <source>This applies even if the result of this method is unused!</source>
          <target state="translated">이 방법의 결과가 사용되지 않은 경우에도 적용됩니다!</target>
        </trans-unit>
        <trans-unit id="2b1ddafbbcba87aafd5e8ce9688cb9d0214c48d2" translate="yes" xml:space="preserve">
          <source>This applies even if the result of this method is unused! (The part about being initialized is not yet fully decided, but until it is, the only safe approach is to ensure that they are indeed initialized.)</source>
          <target state="translated">이 방법의 결과가 사용되지 않은 경우에도 적용됩니다! (초기화에 대한 부분은 아직 완전히 결정되지 않았지만, 그것이 될 때까지 유일하게 안전한 방법은 초기화되었는지 확인하는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="cf4d5070c48104546a550c9a051a5f05bc584068" translate="yes" xml:space="preserve">
          <source>This associated type corresponds to the &lt;code&gt;yield&lt;/code&gt; expression and the values which are allowed to be returned each time a generator yields. For example an iterator-as-a-generator would likely have this type as &lt;code&gt;T&lt;/code&gt;, the type being iterated over.</source>
          <target state="translated">이 연관된 유형은 &lt;code&gt;yield&lt;/code&gt; 표현식 및 생성기가 생성 할 때마다 리턴 될 수있는 값에 해당합니다. 예를 들어, 반복자로서의 반복자는이 유형이 &lt;code&gt;T&lt;/code&gt; 로 반복 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="fe55ae487fde4fa4dff7b2d6d6cdbe76cfbf6518" translate="yes" xml:space="preserve">
          <source>This attribute allows configuring the choice of global allocator. You can use this to implement a completely custom global allocator to route all default allocation requests to a custom object.</source>
          <target state="translated">이 속성을 사용하면 글로벌 할당 자의 선택을 구성 할 수 있습니다. 이를 사용하여 모든 기본 할당 요청을 사용자 정의 오브젝트로 라우트하기 위해 완전히 사용자 정의 된 전역 할당자를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef26e5c3cab23c11bb733ef68934315ad78b85fb" translate="yes" xml:space="preserve">
          <source>This avoids reallocating where possible, but the conditions for that are strict, and subject to change, and so shouldn't be relied upon unless the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; came from &lt;code&gt;From&amp;lt;VecDeque&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and hasn't been reallocated.</source>
          <target state="translated">이렇게하면 가능한 경우 재 할당을 피할 수 있지만 조건은 엄격하고 변경 될 수 있으므로 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 가 &lt;code&gt;From&amp;lt;VecDeque&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 왔으며 재 할당되지 않은 경우에만 의존해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="83aca27198b7bcda96ac6aa2d82d76c078c81a23" translate="yes" xml:space="preserve">
          <source>This behavior is no longer valid in edition 2018.</source>
          <target state="translated">이 동작은 2018 에디션에서 더 이상 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c09355cbc8b51304e7c4f53224a50044b1a70814" translate="yes" xml:space="preserve">
          <source>This book also does not serve as a reference to the &lt;a href=&quot;../std/index&quot;&gt;standard library&lt;/a&gt; included in the language distribution. Those libraries are documented separately by extracting documentation attributes from their source code. Many of the features that one might expect to be language features are library features in Rust, so what you're looking for may be there, not here.</source>
          <target state="translated">이 책은 또한 언어 분배에 포함 된 &lt;a href=&quot;../std/index&quot;&gt;표준 라이브러리에&lt;/a&gt; 대한 참조로 사용되지 않습니다 . 해당 라이브러리는 소스 코드에서 문서 속성을 추출하여 별도로 문서화됩니다. 언어 기능으로 예상되는 많은 기능은 Rust의 라이브러리 기능이므로 원하는 것은 여기에 없을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e20080fb8e1699ed580bf1c766151d2b69a59c9" translate="yes" xml:space="preserve">
          <source>This book also only serves as a reference to what is available in stable Rust. For unstable features being worked on, see the &lt;a href=&quot;https://doc.rust-lang.org/nightly/unstable-book/index.html&quot;&gt;Unstable Book&lt;/a&gt;.</source>
          <target state="translated">이 책은 또한 안정된 녹에서 사용할 수있는 것에 대한 참조로만 사용됩니다. 작업중인 불안정한 기능에 대해서는 &lt;a href=&quot;https://doc.rust-lang.org/nightly/unstable-book/index.html&quot;&gt;불안정한 책을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="32b7e021bdc132a2756c978c8a1d27d9e8d25d04" translate="yes" xml:space="preserve">
          <source>This book assumes that you&amp;rsquo;ve written code in another programming language but doesn&amp;rsquo;t make any assumptions about which one. We&amp;rsquo;ve tried to make the material broadly accessible to those from a wide variety of programming backgrounds. We don&amp;rsquo;t spend a lot of time talking about what programming &lt;em&gt;is&lt;/em&gt; or how to think about it. If you&amp;rsquo;re entirely new to programming, you would be better served by reading a book that specifically provides an introduction to programming.</source>
          <target state="translated">이 책은 다른 프로그래밍 언어로 코드를 작성했지만 어떤 언어로 가정하지는 않는다고 가정합니다. 우리는 다양한 프로그래밍 배경을 가진 사람들이 자료에 광범위하게 접근 할 수 있도록 노력했습니다. 우리는 프로그래밍 &lt;em&gt;이&lt;/em&gt; 무엇인지 또는 어떻게 생각하는지에 대해 많은 시간을 소비하지 않습니다 . 프로그래밍에 익숙하지 않다면 프로그래밍에 대한 소개를 제공하는 책을 읽으면 더 나은 서비스를받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb8d9819998123cf06ddd8f5a1ff9953b5c7298e" translate="yes" xml:space="preserve">
          <source>This book does not assume you are reading this book sequentially. Each chapter generally can be read standalone, but will cross-link to other chapters for facets of the language they refer to, but do not discuss.</source>
          <target state="translated">이 책은이 책을 순차적으로 읽는 것으로 가정하지 않습니다. 각 챕터는 일반적으로 독립형으로 읽을 수 있지만 참조하는 언어의 측면에 대해서는 다른 챕터와 상호 링크됩니다.</target>
        </trans-unit>
        <trans-unit id="74d346bfc5c0837e4df013dba9f47fd4b57ffe9b" translate="yes" xml:space="preserve">
          <source>This book does not serve as an introduction to the language. Background familiarity with the language is assumed. A separate &lt;a href=&quot;../index&quot;&gt;book&lt;/a&gt; is available to help acquire such background familiarity.</source>
          <target state="translated">이 책은 언어를 소개하는 역할을하지 않습니다. 언어에 대한 배경 지식이 있다고 가정합니다. 그러한 배경 지식을 얻는 데 도움이 되는 별도의 &lt;a href=&quot;../index&quot;&gt;책&lt;/a&gt; 을 이용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4589512ba2ae3140ba2d5cf22da84c708acf0a3c" translate="yes" xml:space="preserve">
          <source>This book fully embraces the potential of Rust to empower its users. It&amp;rsquo;s a friendly and approachable text intended to help you level up not just your knowledge of Rust, but also your reach and confidence as a programmer in general. So dive in, get ready to learn&amp;mdash;and welcome to the Rust community!</source>
          <target state="translated">이 책은 Rust가 사용자에게 권한을 부여 할 수있는 잠재력을 충분히 수용합니다. Rust에 대한 지식뿐만 아니라 프로그래머로서의 범위와 자신감을 높이는 데 도움이되는 친근하고 접근하기 쉬운 텍스트입니다. 그러니 뛰어 들어 배울 준비를 하시고 Rust 커뮤니티에 오신 것을 환영합니다!</target>
        </trans-unit>
        <trans-unit id="5eac84b162d067e7c7224575575cec18251ae81c" translate="yes" xml:space="preserve">
          <source>This book is the primary reference for the Rust programming language. It provides three kinds of material:</source>
          <target state="translated">이 책은 Rust 프로그래밍 언어에 대한 기본 참고서입니다. 세 가지 종류의 자료를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4dac54ff1b6d498bb0e5ad5ca44a29d6b2c3c87b" translate="yes" xml:space="preserve">
          <source>This book only contains information about stable features, as in-progress features are still changing, and surely they&amp;rsquo;ll be different between when this book was written and when they get enabled in stable builds. You can find documentation for nightly-only features online.</source>
          <target state="translated">이 책에는 진행중인 기능이 계속 변경되므로 안정적인 기능에 대한 정보 만 포함되어 있으며이 책이 작성된 시점과 안정적인 빌드에서 사용 가능한 시점에 따라 달라질 수 있습니다. 야간 전용 기능에 대한 설명서는 온라인에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b40452b3457baf6eb9c9eb4c95b596dc78a3493" translate="yes" xml:space="preserve">
          <source>This broken invariant is then later observed.</source>
          <target state="translated">이 깨진 불변은 나중에 관찰됩니다.</target>
        </trans-unit>
        <trans-unit id="626674212943f16d78b9c64b216d4813683d4bcd" translate="yes" xml:space="preserve">
          <source>This buffer is always stored on the heap.</source>
          <target state="translated">이 버퍼는 항상 힙에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="533f834501c9981cf01926064551726140f691d1" translate="yes" xml:space="preserve">
          <source>This builder also supports platform-specific options.</source>
          <target state="translated">이 빌더는 플랫폼 별 옵션도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="828127de31395e4a312b7fc3b3384b3f2a31aa51" translate="yes" xml:space="preserve">
          <source>This builder exposes the ability to configure how a &lt;a href=&quot;struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; is opened and what operations are permitted on the open file. The &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.file#method.create&quot;&gt;&lt;code&gt;File::create&lt;/code&gt;&lt;/a&gt; methods are aliases for commonly used options using this builder.</source>
          <target state="translated">이 빌더는 &lt;a href=&quot;struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; 을 여는 방법 및 열린 파일에서 허용되는 조작 을 구성하는 기능을 제공 합니다. &lt;a href=&quot;struct.file#method.open&quot;&gt; &lt;code&gt;File::open&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.file#method.create&quot;&gt; &lt;code&gt;File::create&lt;/code&gt; &lt;/a&gt; 방법이 빌더를 사용하여 일반적으로 사용되는 옵션에 대한 별칭이다.</target>
        </trans-unit>
        <trans-unit id="e3a75e262b3ddd48064e08eaf81396d4af4ef1e5" translate="yes" xml:space="preserve">
          <source>This call borrows &lt;code&gt;Cell&lt;/code&gt; mutably (at compile-time) which guarantees that we possess the only reference.</source>
          <target state="translated">이 호출은 &lt;code&gt;Cell&lt;/code&gt; 가변적으로 빌려 (컴파일 타임에) 우리가 유일한 참조를 가지고 있음을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="5a4e17ce4bfa3ac12c6fb727cdafac307c2e7b00" translate="yes" xml:space="preserve">
          <source>This call borrows &lt;code&gt;RefCell&lt;/code&gt; mutably (at compile-time) so there is no need for dynamic checks.</source>
          <target state="translated">이 호출은 &lt;code&gt;RefCell&lt;/code&gt; 을 (컴파일 타임에) 가변적으로 빌리 므로 동적 검사가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f04390b2a6147633d5eca54b6b75468f6c87ab6" translate="yes" xml:space="preserve">
          <source>This call borrows the &lt;code&gt;UnsafeCell&lt;/code&gt; mutably (at compile-time) which guarantees that we possess the only reference.</source>
          <target state="translated">이 호출은 &lt;code&gt;UnsafeCell&lt;/code&gt; 을 가변적으로 (컴파일시) 차용하여 우리가 유일한 참조를 보유하도록 보장합니다.</target>
        </trans-unit>
        <trans-unit id="07dea4d9325843f5f46d2875aa2d7fc09a6140cf" translate="yes" xml:space="preserve">
          <source>This call is similar to &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt; but more specialized. It borrows &lt;code&gt;RefCell&lt;/code&gt; mutably to ensure no borrows exist and then resets the state tracking shared borrows. This is relevant if some &lt;code&gt;Ref&lt;/code&gt; or &lt;code&gt;RefMut&lt;/code&gt; borrows have been leaked.</source>
          <target state="translated">이 호출은 &lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 더 전문적입니다. 차용이 &lt;code&gt;RefCell&lt;/code&gt; 확인하기 위해 RefCell을 가변적으로 차용 한 다음 공유 차용을 추적하는 상태를 재설정합니다. 일부 &lt;code&gt;Ref&lt;/code&gt; 또는 &lt;code&gt;RefMut&lt;/code&gt; 차용이 유출 된 경우 관련됩니다 .</target>
        </trans-unit>
        <trans-unit id="bafb9cba9c70e76a1a3bb46e83a3fb5e4a1e4a73" translate="yes" xml:space="preserve">
          <source>This can also be thought of as the fallible form of &lt;a href=&quot;#method.for_each&quot;&gt;&lt;code&gt;for_each()&lt;/code&gt;&lt;/a&gt; or as the stateless version of &lt;a href=&quot;#method.try_fold&quot;&gt;&lt;code&gt;try_fold()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#method.for_each&quot;&gt; &lt;code&gt;for_each()&lt;/code&gt; &lt;/a&gt; 의 잘못된 형식 또는 &lt;a href=&quot;#method.try_fold&quot;&gt; &lt;code&gt;try_fold()&lt;/code&gt; &lt;/a&gt; 의 상태 비 저장 버전으로 생각할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="561a3555fef68cbba4ae35243cef025c7f810a34" translate="yes" xml:space="preserve">
          <source>This can also be thought of as the fallible form of &lt;a href=&quot;trait.iterator#method.for_each&quot;&gt;&lt;code&gt;for_each()&lt;/code&gt;&lt;/a&gt; or as the stateless version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;try_fold()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 또한 &lt;a href=&quot;trait.iterator#method.for_each&quot;&gt; &lt;code&gt;for_each()&lt;/code&gt; &lt;/a&gt; 의 잘못된 형태 또는 &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;try_fold()&lt;/code&gt; &lt;/a&gt; 의 상태 비 저장 버전으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc5e7768aa508543b82b361f251df561c08e6d32" translate="yes" xml:space="preserve">
          <source>This can also be used in multithreaded applications, in order to send a message to other threads warning that a thread has panicked (e.g., for monitoring purposes).</source>
          <target state="translated">스레드가 패닉되었다는 경고 메시지를 다른 스레드에 보내기 위해 멀티 스레드 응용 프로그램에서도 사용할 수 있습니다 (예 : 모니터링 목적으로).</target>
        </trans-unit>
        <trans-unit id="3ff7f3a5aeb76318844d8c8fdfdc79fcab462b99" translate="yes" xml:space="preserve">
          <source>This can also happen when using a type implementing &lt;code&gt;Fn&lt;/code&gt; or &lt;code&gt;FnMut&lt;/code&gt;, as neither allows moving out of them (they usually represent closures which can be called more than once). Much of the text following applies equally well to non-&lt;code&gt;FnOnce&lt;/code&gt; closure bodies.</source>
          <target state="translated">이것은 &lt;code&gt;Fn&lt;/code&gt; 또는 &lt;code&gt;FnMut&lt;/code&gt; 을 구현하는 유형을 사용할 때도 발생할 수 있습니다. 둘 다 밖으로 이동할 수 없기 때문입니다 (일반적으로 두 번 이상 호출 될 수있는 클로저를 나타냄). 다음 텍스트의 대부분은 비 &lt;code&gt;FnOnce&lt;/code&gt; 클로저 본문에 동일하게 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="115ef26a79f6ceeca6376e7547342f4fb025dc8d" translate="yes" xml:space="preserve">
          <source>This can be cast to a pointer of any kind. Ensure that the access is unique (no active references, mutable or not) when casting to &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, and ensure that there are no mutations or mutable aliases going on when casting to &lt;code&gt;&amp;amp;T&lt;/code&gt;</source>
          <target state="translated">이것은 모든 종류의 포인터로 캐스트 될 수 있습니다. &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 캐스팅 할 때 액세스가 고유한지 (활성 참조가 없는지, 변경 가능한지 아닌지) 확인하고 &lt;code&gt;&amp;amp;T&lt;/code&gt; 캐스팅 할 때 진행중인 돌연변이 또는 변경 가능한 별명이 없는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="214edc09ead3c27edfef862878240910ed92a93e" translate="yes" xml:space="preserve">
          <source>This can be constructed by the &lt;a href=&quot;struct.formatter#method.debug_list&quot;&gt;&lt;code&gt;Formatter::debug_list&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이것은 &lt;a href=&quot;struct.formatter#method.debug_list&quot;&gt; &lt;code&gt;Formatter::debug_list&lt;/code&gt; &lt;/a&gt; 메소드 로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7514961910752b90460d88f227b5817215d7f6e" translate="yes" xml:space="preserve">
          <source>This can be constructed by the &lt;a href=&quot;struct.formatter#method.debug_map&quot;&gt;&lt;code&gt;Formatter::debug_map&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이것은 &lt;a href=&quot;struct.formatter#method.debug_map&quot;&gt; &lt;code&gt;Formatter::debug_map&lt;/code&gt; &lt;/a&gt; 메소드 로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db45b1697100bb4357e93b4848fb22d93091bccd" translate="yes" xml:space="preserve">
          <source>This can be constructed by the &lt;a href=&quot;struct.formatter#method.debug_set&quot;&gt;&lt;code&gt;Formatter::debug_set&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이것은 &lt;a href=&quot;struct.formatter#method.debug_set&quot;&gt; &lt;code&gt;Formatter::debug_set&lt;/code&gt; &lt;/a&gt; 메소드 로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efbf03337e671dc0f2d75f1c2d72ed7746b99e34" translate="yes" xml:space="preserve">
          <source>This can be constructed by the &lt;a href=&quot;struct.formatter#method.debug_struct&quot;&gt;&lt;code&gt;Formatter::debug_struct&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이것은 &lt;a href=&quot;struct.formatter#method.debug_struct&quot;&gt; &lt;code&gt;Formatter::debug_struct&lt;/code&gt; &lt;/a&gt; 메소드 로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="daed88198496b5861ca72aa01db8f1e07a7a1fbc" translate="yes" xml:space="preserve">
          <source>This can be constructed by the &lt;a href=&quot;struct.formatter#method.debug_tuple&quot;&gt;&lt;code&gt;Formatter::debug_tuple&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이것은 &lt;a href=&quot;struct.formatter#method.debug_tuple&quot;&gt; &lt;code&gt;Formatter::debug_tuple&lt;/code&gt; &lt;/a&gt; 메소드 로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f00711c55f275b9886eb0ce781693c9e5c9caed4" translate="yes" xml:space="preserve">
          <source>This can be resolved by changing the type annotation or removing it entirely if it can be inferred.</source>
          <target state="translated">유형 주석을 변경하거나 추론 할 수있는 경우 완전히 제거하여 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21c003ed23b457ffebe1b7112c3e64636889beae" translate="yes" xml:space="preserve">
          <source>This can be used to avoid allocations in the most trivial case.</source>
          <target state="translated">이것은 가장 사소한 경우 할당을 피하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2479ae89d6780ca289ef37404c0461658bc53872" translate="yes" xml:space="preserve">
          <source>This can be used to compare &lt;code&gt;&amp;amp;T&lt;/code&gt; references (which coerce to &lt;code&gt;*const T&lt;/code&gt; implicitly) by their address rather than comparing the values they point to (which is what the &lt;code&gt;PartialEq for &amp;amp;T&lt;/code&gt; implementation does).</source>
          <target state="translated">이것은 ( &lt;code&gt;PartialEq for &amp;amp;T&lt;/code&gt; 구현을 위한 PartialEq가하는) 비교하는 값을 비교하는 대신 주소로 &lt;code&gt;&amp;amp;T&lt;/code&gt; 참조 ( 암시 적 으로 &lt;code&gt;*const T&lt;/code&gt; 로 강제 하는)를 비교하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3720c96ba6b1476408a923be1876044bc567298" translate="yes" xml:space="preserve">
          <source>This can be used to compare enums that carry data, while disregarding the actual data:</source>
          <target state="translated">실제 데이터를 무시하면서 데이터를 전달하는 열거 형을 비교하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27925db5758baea8a7b4ada29852f78f4d3d7a94" translate="yes" xml:space="preserve">
          <source>This can be used to handle errors that would otherwise only be caught when the &lt;code&gt;File&lt;/code&gt; is closed. Dropping a file will ignore errors in synchronizing this in-memory data.</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; 을 닫을 때만 발생하는 오류를 처리하는 데 사용할 수 있습니다 . 파일을 삭제하면이 메모리 내 데이터 동기화시 오류가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9856559b29a29e0f25c3e61f2c093f50c7905e19" translate="yes" xml:space="preserve">
          <source>This can be used to hash a &lt;code&gt;&amp;amp;T&lt;/code&gt; reference (which coerces to &lt;code&gt;*const T&lt;/code&gt; implicitly) by its address rather than the value it points to (which is what the &lt;code&gt;Hash for &amp;amp;T&lt;/code&gt; implementation does).</source>
          <target state="translated">이것은 ( &lt;code&gt;Hash for &amp;amp;T&lt;/code&gt; 구현에 대한 해시 가 수행하는) 값이 가리키는 값이 아닌 주소 로 &lt;code&gt;&amp;amp;T&lt;/code&gt; 참조 ( 암시 적 으로 &lt;code&gt;*const T&lt;/code&gt; 로 강제 변환) 를 해시하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13a7b507773148ef054095424c9d9ac4d8251d3e" translate="yes" xml:space="preserve">
          <source>This can be used to safely get a strong reference (by calling &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt; later) or to deallocate the weak count by dropping the &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이를 통해 강력한 참조를 안전하게 얻 거나 (나중에 &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt; &lt;code&gt;upgrade&lt;/code&gt; &lt;/a&gt; 를 호출 하여) &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 삭제하여 약한 수를 할당 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb4c5fc4f14344c508855aa0c67808589d2ea5df" translate="yes" xml:space="preserve">
          <source>This can be useful if you are prototyping and are just looking to have your code type-check, or if you're implementing a trait that requires multiple methods, and you're only planning on using one of them.</source>
          <target state="translated">프로토 타입을 작성하고 코드 유형을 확인하려고하거나 여러 방법이 필요한 특성을 구현하고 있고 그 중 하나만 사용하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1ab14e32989b6a2b12b8a3fb1b8ae13359f650e9" translate="yes" xml:space="preserve">
          <source>This can be useful if you are prototyping and are just looking to have your code typecheck.</source>
          <target state="translated">프로토 타이핑 중이고 코드 유형 검사를 원하는 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13e97c3892555defded3caf3fd786d6a9bf7c197" translate="yes" xml:space="preserve">
          <source>This can be useful if you are prototyping and are just looking to have your code typecheck. &lt;code&gt;todo!&lt;/code&gt; works exactly like &lt;code&gt;unimplemented!&lt;/code&gt;. The only difference between the two macros is the name.</source>
          <target state="translated">프로토 타입을 작성하고 코드 유형을 확인하려는 경우 유용합니다. &lt;code&gt;todo!&lt;/code&gt; &lt;code&gt;unimplemented!&lt;/code&gt; 것처럼 정확하게 작동합니다 ! . 두 매크로의 유일한 차이점은 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8c8e1855be0fe981425a92585a82ff10846bce81" translate="yes" xml:space="preserve">
          <source>This can be useful when we want to access a &lt;code&gt;MaybeUninit&lt;/code&gt; that has been initialized but don't have ownership of the &lt;code&gt;MaybeUninit&lt;/code&gt; (preventing the use of &lt;code&gt;.assume_init()&lt;/code&gt;).</source>
          <target state="translated">이것은 초기화되었지만 &lt;code&gt;MaybeUninit&lt;/code&gt; 의 소유권이없는 &lt;code&gt;MaybeUninit&lt;/code&gt; 에 접근하고자 할 때 유용 할 수 있습니다 ( &lt;code&gt;.assume_init()&lt;/code&gt; 사용 방지 ).</target>
        </trans-unit>
        <trans-unit id="1ab94494ce69e91c90f0acb5a81528e74b707291" translate="yes" xml:space="preserve">
          <source>This can never cause a problem in safe code because implementing a type that relies on pinning requires unsafe code, but be aware that deciding to make use of pinning in your type (for example by implementing some operation on &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;Self&amp;gt;&lt;/code&gt; or &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt;) has consequences for your &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; implementation as well: if an element of your type could have been pinned, you must treat &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; as implicitly taking &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">고정에 의존하는 유형을 구현하려면 안전하지 않은 코드가 필요하기 때문에 안전 코드에서 문제가 발생하지 않습니다. 그러나 유형에서 고정을 사용하기로 결정하는 경우 (예 : &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;Self&amp;gt;&lt;/code&gt; 또는 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; )는 &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt; 구현에도 영향을 미칩니다 . 유형의 요소가 고정되었을 수있는 경우 &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt; 을 암시 적으로 &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; 하는 것으로 취급해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b8075fc432fec0682f4342dc70f37276a8d8a19f" translate="yes" xml:space="preserve">
          <source>This can never cause a problem in safe code because implementing a type that relies on pinning requires unsafe code, but be aware that deciding to make use of pinning in your type (for example by implementing some operation on &lt;code&gt;Pin&amp;lt;&amp;amp;Self&amp;gt;&lt;/code&gt; or &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt;) has consequences for your &lt;code&gt;Drop&lt;/code&gt; implementation as well: if an element of your type could have been pinned, you must treat Drop as implicitly taking &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">피닝에 의존하는 유형을 구현하려면 안전하지 않은 코드가 필요하기 때문에 안전 코드에서 문제를 일으킬 수는 없지만 유형에 고정을 사용하기로 결정하는 경우 (예 : &lt;code&gt;Pin&amp;lt;&amp;amp;Self&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; )는 &lt;code&gt;Drop&lt;/code&gt; 구현에도 영향을 미칩니다 . 유형의 요소를 고정 할 수 있으면 Drop을 암시 적으로 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; 하는 것으로 간주해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cadc6079abb6a4bbc592c234ce0da222e1a2fdc1" translate="yes" xml:space="preserve">
          <source>This change unifies all the calls to &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; and solves the problem of the first &lt;code&gt;if&lt;/code&gt; block unnecessarily calling the function twice. Unfortunately, we&amp;rsquo;re now calling this function and waiting for the result in all cases, which includes the inner &lt;code&gt;if&lt;/code&gt; block that doesn&amp;rsquo;t use the result value at all.</source>
          <target state="translated">이 변경은 모든 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; _expensive_calculation 호출을 통합하고 불필요하게 함수를 두 번 호출하는 첫 번째 &lt;code&gt;if&lt;/code&gt; 블록 의 문제를 해결합니다 . 불행하게도, 우리는 이제이 함수를 호출 하고 결과 값을 전혀 사용하지 않는 내부 &lt;code&gt;if&lt;/code&gt; 블록을 포함하여 모든 경우에 결과를 기다리고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d160910b055fc36b0155788ef2b0b90383b734d2" translate="yes" xml:space="preserve">
          <source>This channel has an internal buffer on which messages will be queued. &lt;code&gt;bound&lt;/code&gt; specifies the buffer size. When the internal buffer becomes full, future sends will &lt;em&gt;block&lt;/em&gt; waiting for the buffer to open up. Note that a buffer size of 0 is valid, in which case this becomes &quot;rendezvous channel&quot; where each &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; will not return until a &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; is paired with it.</source>
          <target state="translated">이 채널에는 메시지가 대기 할 내부 버퍼가 있습니다. &lt;code&gt;bound&lt;/code&gt; 는 버퍼 크기를 지정합니다. 내부 버퍼가 가득 차면 향후 송신은 버퍼가 열리기를 기다리는 것을 &lt;em&gt;차단&lt;/em&gt; 합니다. 버퍼 크기 0은 유효합니다.이 경우 &quot; &lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 채널&quot;이 되어 &lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; 와 페어링 될 때까지 각 전송 이 반환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fb1d7eb08fcc70de9ba8181af70c6fc4dce88829" translate="yes" xml:space="preserve">
          <source>This chapter covered how to use smart pointers to make different guarantees and trade-offs from those Rust makes by default with regular references. The &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; type has a known size and points to data allocated on the heap. The &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type keeps track of the number of references to data on the heap so that data can have multiple owners. The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type with its interior mutability gives us a type that we can use when we need an immutable type but need to change an inner value of that type; it also enforces the borrowing rules at runtime instead of at compile time.</source>
          <target state="translated">이 장에서는 스마트 포인터를 사용하여 Rust가 정기적으로 참조하는 것과 다른 보증 및 상충 관계를 만드는 방법을 다루었습니다. &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 타입은 힙에 할당 된 데이터에 알려진 크기와 포인트를 가지고있다. &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 데이터가 여러 소유자를 가질 수 있도록 유형은 힙의 데이터에 대한 참조의 수를 추적합니다. 내부 변경이 가능한 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 유형은 변경 불가능한 유형이 필요하지만 해당 유형의 내부 값을 변경해야 할 때 사용할 수있는 유형을 제공합니다. 또한 컴파일 타임이 아닌 런타임시 차용 규칙을 시행합니다.</target>
        </trans-unit>
        <trans-unit id="d76b58ff9e32a83f32bdf3cb1438b47bc33ded06" translate="yes" xml:space="preserve">
          <source>This chapter covers concepts that appear in almost every programming language and how they work in Rust. Many programming languages have much in common at their core. None of the concepts presented in this chapter are unique to Rust, but we&amp;rsquo;ll discuss them in the context of Rust and explain the conventions around using these concepts.</source>
          <target state="translated">이 장에서는 거의 모든 프로그래밍 언어로 나타나는 개념과 Rust에서 작동하는 방식에 대해 설명합니다. 많은 프로그래밍 언어가 핵심에서 공통점이 많습니다. 이 장에서 제시된 개념 중 어느 것도 Rust에 고유 한 것은 아니지만 Rust와 관련하여 논의하고 이러한 개념을 사용하는 것에 관한 규칙을 설명 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="29ea0fbfb2601396e36f35e6ef2ff2eccf09482a" translate="yes" xml:space="preserve">
          <source>This chapter is a recap of the many skills you&amp;rsquo;ve learned so far and an exploration of a few more standard library features. We&amp;rsquo;ll build a command line tool that interacts with file and command line input/output to practice some of the Rust concepts you now have under your belt.</source>
          <target state="translated">이 장에서는 지금까지 배운 많은 기술과 몇 가지 표준 라이브러리 기능에 대해 살펴 봅니다. 파일 및 명령 줄 입력 / 출력과 상호 작용하여 현재 사용중인 Rust 개념 중 일부를 연습하는 명령 줄 도구를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="ba9d120769583a2b06ff5bcafb1b013c4c1c420a" translate="yes" xml:space="preserve">
          <source>This chapter is a reference on all things related to patterns. We&amp;rsquo;ll cover the valid places to use patterns, the difference between refutable and irrefutable patterns, and the different kinds of pattern syntax that you might see. By the end of the chapter, you&amp;rsquo;ll know how to use patterns to express many concepts in a clear way.</source>
          <target state="translated">이 장은 패턴과 관련된 모든 것에 대한 참조입니다. 패턴을 사용할 수있는 유효한 장소, 반박 가능 패턴과 반박 불가능 패턴의 차이점 및 표시되는 다양한 패턴 구문에 대해 다룰 것입니다. 이 장을 마치면 패턴을 사용하여 많은 개념을 분명하게 표현하는 방법을 알게됩니다.</target>
        </trans-unit>
        <trans-unit id="4ca695707d3d924a4c7520a559258f62a52be801" translate="yes" xml:space="preserve">
          <source>This chapter recapped some of the major concepts you&amp;rsquo;ve learned so far and covered how to perform common I/O operations in Rust. By using command line arguments, files, environment variables, and the &lt;code&gt;eprintln!&lt;/code&gt; macro for printing errors, you&amp;rsquo;re now prepared to write command line applications. By using the concepts in previous chapters, your code will be well organized, store data effectively in the appropriate data structures, handle errors nicely, and be well tested.</source>
          <target state="translated">이 장에서는 지금까지 배운 주요 개념 중 일부를 살펴보고 Rust에서 일반적인 I / O 작업을 수행하는 방법을 설명했습니다. 명령 행 인수, 파일, 환경 변수 및 &lt;code&gt;eprintln!&lt;/code&gt; 인쇄 오류에 대한 매크로를 사용하면 이제 명령 줄 응용 프로그램을 작성할 준비가되었습니다. 이전 장의 개념을 사용하면 코드를 체계적으로 구성하고 데이터를 적절한 데이터 구조에 효과적으로 저장하며 오류를 잘 처리하고 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f14f23451903925edc1325ae4f6812d472301ab" translate="yes" xml:space="preserve">
          <source>This closure will be run in the context of the child process after a &lt;code&gt;fork&lt;/code&gt;. This primarily means that any modifications made to memory on behalf of this closure will &lt;strong&gt;not&lt;/strong&gt; be visible to the parent process. This is often a very constrained environment where normal operations like &lt;code&gt;malloc&lt;/code&gt; or acquiring a mutex are not guaranteed to work (due to other threads perhaps still running when the &lt;code&gt;fork&lt;/code&gt; was run).</source>
          <target state="translated">이 폐쇄는 &lt;code&gt;fork&lt;/code&gt; 후 자식 프로세스의 컨텍스트에서 실행됩니다 . 이는 주로이 클로저를 대신하여 메모리를 수정 한 내용이 부모 프로세스에 표시 &lt;strong&gt;되지 않음을&lt;/strong&gt; 의미합니다. 이것은 &lt;code&gt;malloc&lt;/code&gt; 이나 mutex를 얻는 것과 같은 정상적인 작업이 ( &lt;code&gt;fork&lt;/code&gt; 가 실행될 때 여전히 실행중인 다른 스레드로 인해) 작동하지 않는 매우 제한된 환경 입니다.</target>
        </trans-unit>
        <trans-unit id="22a1461b442324db65b2ce2aa52db0c09471bd28" translate="yes" xml:space="preserve">
          <source>This code also sets &lt;code&gt;s&lt;/code&gt; to &lt;code&gt;tic-tac-toe&lt;/code&gt;. The &lt;code&gt;format!&lt;/code&gt; macro works in the same way as &lt;code&gt;println!&lt;/code&gt;, but instead of printing the output to the screen, it returns a &lt;code&gt;String&lt;/code&gt; with the contents. The version of the code using &lt;code&gt;format!&lt;/code&gt; is much easier to read and doesn&amp;rsquo;t take ownership of any of its parameters.</source>
          <target state="translated">이 코드는 또한 &lt;code&gt;s&lt;/code&gt; 를 &lt;code&gt;tic-tac-toe&lt;/code&gt; 로 설정 합니다. &lt;code&gt;format!&lt;/code&gt; 매크로는 &lt;code&gt;println!&lt;/code&gt; 과 같은 방식으로 작동합니다 ! 출력을 화면에 인쇄하는 대신 내용이 포함 된 &lt;code&gt;String&lt;/code&gt; 을 반환합니다 . &lt;code&gt;format!&lt;/code&gt; 사용하는 코드 버전 ! 읽기 쉽고 매개 변수의 소유권을 가지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d361c400527932085f404cf9d818fa511cfc4bc4" translate="yes" xml:space="preserve">
          <source>This code block contains unsafe code.</source>
          <target state="translated">이 코드 블록에는 안전하지 않은 코드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2b577d02f895994167db7646bcb5bc51980294d" translate="yes" xml:space="preserve">
          <source>This code compiles and runs but doesn&amp;rsquo;t result in the desired threading behavior: a slow request will still cause other requests to wait to be processed. The reason is somewhat subtle: the &lt;code&gt;Mutex&lt;/code&gt; struct has no public &lt;code&gt;unlock&lt;/code&gt; method because the ownership of the lock is based on the lifetime of the &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt; within the &lt;code&gt;LockResult&amp;lt;MutexGuard&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; that the &lt;code&gt;lock&lt;/code&gt; method returns. At compile time, the borrow checker can then enforce the rule that a resource guarded by a &lt;code&gt;Mutex&lt;/code&gt; cannot be accessed unless we hold the lock. But this implementation can also result in the lock being held longer than intended if we don&amp;rsquo;t think carefully about the lifetime of the &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt;. Because the values in the &lt;code&gt;while let&lt;/code&gt; expression remain in scope for the duration of the block, the lock remains held for the duration of the call to &lt;code&gt;job()&lt;/code&gt;, meaning other workers cannot receive jobs.</source>
          <target state="translated">이 코드는 컴파일 및 실행되지만 원하는 스레딩 동작이 발생하지 않습니다. 느린 요청으로 인해 다른 요청이 처리되기를 기다리게됩니다. 그 이유는 다소 미묘합니다. &lt;code&gt;unlock&lt;/code&gt; 소유권 이 &lt;code&gt;lock&lt;/code&gt; 메서드가 반환 하는 &lt;code&gt;LockResult&amp;lt;MutexGuard&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 내의 &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt; 수명을 기반으로하기 때문에 &lt;code&gt;Mutex&lt;/code&gt; 구조체에는 공용 잠금 해제 메서드 가 없습니다 . 컴파일 타임에 차용 검사기는 잠금을 유지하지 않는 한 &lt;code&gt;Mutex&lt;/code&gt; 가 보호하는 리소스에 액세스 할 수 없다는 규칙을 적용 할 수 있습니다. 그러나이 구현은 &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt; 의 수명에 대해 신중하게 생각하지 않으면 의도 한 것보다 더 오래 잠금을 유지할 수 있습니다.. &lt;code&gt;while let&lt;/code&gt; 식 의 값 은 블록 기간 동안 범위에 남아 있기 때문에 &lt;code&gt;job()&lt;/code&gt; 호출 기간 동안 잠금이 유지되어 다른 작업자가 작업을받을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8be923288a70fe6e854b5bc75a5a5f3ea2e87376" translate="yes" xml:space="preserve">
          <source>This code compiles and runs but doesn&amp;rsquo;t result in the desired threading behavior: a slow request will still cause other requests to wait to be processed. The reason is somewhat subtle: the &lt;code&gt;Mutex&lt;/code&gt; struct has no public &lt;code&gt;unlock&lt;/code&gt; method because the ownership of the lock is based on the lifetime of the &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt; within the &lt;code&gt;LockResult&amp;lt;MutexGuard&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; that the &lt;code&gt;lock&lt;/code&gt; method returns. At compile time, the borrow checker can then enforce the rule that a resource guarded by a &lt;code&gt;Mutex&lt;/code&gt; cannot be accessed unless we hold the lock. But this implementation can also result in the lock being held longer than intended if we don&amp;rsquo;t think carefully about the lifetime of the &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt;. Because the values in the &lt;code&gt;while&lt;/code&gt; expression remain in scope for the duration of the block, the lock remains held for the duration of the call to &lt;code&gt;job.call_box()&lt;/code&gt;, meaning other workers cannot receive jobs.</source>
          <target state="translated">이 코드는 컴파일 및 실행되지만 원하는 스레딩 동작이 발생하지 않습니다. 느린 요청은 여전히 ​​다른 요청이 처리되기를 기다립니다. 그 이유는 다소 미묘한 다음 &lt;code&gt;Mutex&lt;/code&gt; 구조체는 공용이없는 &lt;code&gt;unlock&lt;/code&gt; 방법을 잠금의 소유권이의 수명을 기반으로하기 때문에 &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt; 내 &lt;code&gt;LockResult&amp;lt;MutexGuard&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 그 &lt;code&gt;lock&lt;/code&gt; 방식으로 돌아갑니다. 컴파일 타임에 차용 검사기는 잠금을 유지하지 않으면 &lt;code&gt;Mutex&lt;/code&gt; 에 의해 보호되는 리소스에 액세스 할 수 없다는 규칙을 시행 할 수 있습니다. 그러나이 구현으로 인해 &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt; 의 수명에 대해 신중하게 생각하지 않으면 잠금이 의도 한 것보다 오래 유지 될 수 있습니다.. &lt;code&gt;while&lt;/code&gt; 표현식 의 값 은 블록 기간 동안 범위 내에 있으므로, &lt;code&gt;job.call_box()&lt;/code&gt; 호출 기간 동안 잠금이 유지 되므로 다른 작업자가 작업을 수신 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a9ddcc8d0db1cdd5bd0507394434501db1a0bedf" translate="yes" xml:space="preserve">
          <source>This code contains a lot of information, so let&amp;rsquo;s go over it line by line. To obtain user input and then print the result as output, we need to bring the &lt;code&gt;io&lt;/code&gt; (input/output) library into scope. The &lt;code&gt;io&lt;/code&gt; library comes from the standard library (which is known as &lt;code&gt;std&lt;/code&gt;):</source>
          <target state="translated">이 코드에는 많은 정보가 포함되어 있으므로 한 줄씩 살펴 보겠습니다. 사용자 입력을 얻은 다음 결과를 출력으로 인쇄하려면 &lt;code&gt;io&lt;/code&gt; (입력 / 출력) 라이브러리를 범위 로 가져와야합니다 . &lt;code&gt;io&lt;/code&gt; 라이브러리 (로 알려진 표준 라이브러리에서 제공 &lt;code&gt;std&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="a2cf7c9b3ea591cd958e0136c121e6bf9f333d13" translate="yes" xml:space="preserve">
          <source>This code creates a string containing &lt;code&gt;initial contents&lt;/code&gt;.</source>
          <target state="translated">이 코드는 &lt;code&gt;initial contents&lt;/code&gt; 포함하는 문자열을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="37eb73353618177bcb3ef1d909b78d97976287b7" translate="yes" xml:space="preserve">
          <source>This code creates the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; that match the values of the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; fields of the &lt;code&gt;p&lt;/code&gt; struct. This example shows that the names of the variables in the pattern don&amp;rsquo;t have to match the field names of the struct. But it&amp;rsquo;s common to want the variable names to match the field names to make it easier to remember which variables came from which fields.</source>
          <target state="translated">이 코드 는 &lt;code&gt;p&lt;/code&gt; 구조체 의 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 필드 값과 일치 하는 변수 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 를 만듭니다 . 이 예제는 패턴의 변수 이름이 구조체의 필드 이름과 일치하지 않아도됨을 보여줍니다. 그러나 변수 이름이 필드 이름과 일치하여 어떤 변수가 어떤 필드에서 왔는지 기억하기 쉽도록하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="4c6b27e7fab9563bf2abcf70ff023ebf232f1887" translate="yes" xml:space="preserve">
          <source>This code creates the variables &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; that match the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; fields of the &lt;code&gt;p&lt;/code&gt; variable. The outcome is that the variables &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; contain the values from the &lt;code&gt;p&lt;/code&gt; struct.</source>
          <target state="translated">이 코드 는 &lt;code&gt;p&lt;/code&gt; 변수 의 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 필드 와 일치 하는 변수 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 를 만듭니다 . 결과적으로 변수 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 에는 &lt;code&gt;p&lt;/code&gt; 구조체 의 값이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="519fd3df45d223b502667d31300a65c73f22de3a" translate="yes" xml:space="preserve">
          <source>This code does not compile!</source>
          <target state="translated">이 코드는 컴파일되지 않습니다!</target>
        </trans-unit>
        <trans-unit id="a8563da8c7fd875eb235c5cf17bc917dd4b6aba0" translate="yes" xml:space="preserve">
          <source>This code does not produce the desired behavior.</source>
          <target state="translated">이 코드는 원하는 동작을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0426964d440764948892b9452f7b1a751866e79c" translate="yes" xml:space="preserve">
          <source>This code illustrates that you can put any kind of data inside an enum variant: strings, numeric types, or structs, for example. You can even include another enum! Also, standard library types are often not much more complicated than what you might come up with.</source>
          <target state="translated">이 코드는 문자열, 숫자 유형 또는 구조체와 같은 열거 형 변형 안에 모든 종류의 데이터를 넣을 수 있음을 보여줍니다. 다른 열거 형을 포함시킬 수도 있습니다! 또한 표준 라이브러리 유형은 종종 여러분이 생각하는 것보다 훨씬 복잡하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23d4be6e177cb0763cfd5315e376249487e60755" translate="yes" xml:space="preserve">
          <source>This code is a bit messy, but it&amp;rsquo;s good enough for simulation purposes. We created a second request &lt;code&gt;sleep&lt;/code&gt;, whose data our server recognizes. We added an &lt;code&gt;else if&lt;/code&gt; after the &lt;code&gt;if&lt;/code&gt; block to check for the request to &lt;em&gt;/sleep&lt;/em&gt;. When that request is received, the server will sleep for 5 seconds before rendering the successful HTML page.</source>
          <target state="translated">이 코드는 약간 지저분하지만 시뮬레이션 목적으로 충분합니다. 우리는 서버가 인식하는 데이터를 두 번째 요청 &lt;code&gt;sleep&lt;/code&gt; 으로 만들었습니다 . &lt;code&gt;if&lt;/code&gt; 블록 뒤에 &lt;code&gt;else if&lt;/code&gt; 추가하여 &lt;em&gt;/ sleep&lt;/em&gt; 요청을 확인했습니다 . 해당 요청이 수신되면 서버는 5 초 동안 휴면 상태가되어 HTML 페이지를 렌더링합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9400019c8ed3d0b61a4a67558c972e785c9498d4" translate="yes" xml:space="preserve">
          <source>This code is a bit nicer, isn&amp;rsquo;t it?</source>
          <target state="translated">이 코드는 조금 더 낫지 않습니까?</target>
        </trans-unit>
        <trans-unit id="a9d573288ab51576cf8efa92e3fc2409e71975a4" translate="yes" xml:space="preserve">
          <source>This code is for an animal shelter that wants to name all puppies Spot, which is implemented in the &lt;code&gt;baby_name&lt;/code&gt; associated function that is defined on &lt;code&gt;Dog&lt;/code&gt;. The &lt;code&gt;Dog&lt;/code&gt; type also implements the trait &lt;code&gt;Animal&lt;/code&gt;, which describes characteristics that all animals have. Baby dogs are called puppies, and that is expressed in the implementation of the &lt;code&gt;Animal&lt;/code&gt; trait on &lt;code&gt;Dog&lt;/code&gt; in the &lt;code&gt;baby_name&lt;/code&gt; function associated with the &lt;code&gt;Animal&lt;/code&gt; trait.</source>
          <target state="translated">이 코드는 &lt;code&gt;Dog&lt;/code&gt; 에 정의 된 &lt;code&gt;baby_name&lt;/code&gt; 관련 함수 에서 구현되는 모든 강아지 스팟의 이름을 지정하려는 동물 보호소를위한 것입니다 . &lt;code&gt;Dog&lt;/code&gt; 유형은 또한 특성 구현 &lt;code&gt;Animal&lt;/code&gt; 모든 동물이 가지고 특성을 설명합니다. 아기 강아지는 강아지라고하며, 그는의 구현에 표현되는 &lt;code&gt;Animal&lt;/code&gt; 에 대한 특성 &lt;code&gt;Dog&lt;/code&gt; 에서 &lt;code&gt;baby_name&lt;/code&gt; 의 과 관련된 기능 &lt;code&gt;Animal&lt;/code&gt; 특징.</target>
        </trans-unit>
        <trans-unit id="28ab5f7e147cb2d4d661943464a31c7e543917cd" translate="yes" xml:space="preserve">
          <source>This code is much easier to read and write! Choosing a meaningful name for a type alias can help communicate your intent as well (&lt;em&gt;thunk&lt;/em&gt; is a word for code to be evaluated at a later time, so it&amp;rsquo;s an appropriate name for a closure that gets stored).</source>
          <target state="translated">이 코드는 읽고 쓰는 것이 훨씬 쉽습니다! 유형 별명에 대해 의미있는 이름을 선택하면 의도를 전달하는 데 도움 이 될 수 있습니다. 나중에 &lt;em&gt;썽 크는&lt;/em&gt; 코드를 평가하는 단어이므로 저장되는 클로저에 적합한 이름입니다.</target>
        </trans-unit>
        <trans-unit id="49a0f8f422e51179065e97042cbf65579f27fccc" translate="yes" xml:space="preserve">
          <source>This code is not legal: it is not possible to specialize &lt;code&gt;Drop&lt;/code&gt; to a subset of implementations of a generic type. In order for this code to work, &lt;code&gt;MyStruct&lt;/code&gt; must also require that &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Foo&lt;/code&gt;. Alternatively, another option is to wrap the generic type in another that specializes appropriately:</source>
          <target state="translated">이 코드는 합법적이지 않습니다. &lt;code&gt;Drop&lt;/code&gt; 을 제네릭 형식의 구현 하위 집합으로 특수화 할 수는 없습니다 . 이 코드가 작동 하려면 &lt;code&gt;MyStruct&lt;/code&gt; 에서 &lt;code&gt;T&lt;/code&gt; 도 &lt;code&gt;Foo&lt;/code&gt; 를 구현 해야합니다 . 또는 다른 옵션은 제네릭 형식을 적절하게 다른 형식으로 래핑하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e6419e6d86ad5d4d771d701592b7c8059bf718cc" translate="yes" xml:space="preserve">
          <source>This code is not legal: it is not possible to specialize &lt;code&gt;Drop&lt;/code&gt; to a subset of implementations of a generic type. One workaround for this is to wrap the generic type, as shown below:</source>
          <target state="translated">이 코드는 합법적이지 않습니다. &lt;code&gt;Drop&lt;/code&gt; 을 제네릭 형식의 구현 하위 집합으로 특수화 할 수는 없습니다 . 이에 대한 한 가지 해결 방법은 다음과 같이 제네릭 형식을 래핑하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7561545f94912a4c2f636ef3be71bf5e25ba09fc" translate="yes" xml:space="preserve">
          <source>This code is printing a prompt stating what the game is and requesting input from the user.</source>
          <target state="translated">이 코드는 게임이 무엇인지 알려주고 사용자에게 입력을 요청하는 프롬프트를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="7103520ca1aa03619df8713fc5365e846d9c5ad3" translate="yes" xml:space="preserve">
          <source>This code is read as &amp;ldquo;the function &lt;code&gt;bar&lt;/code&gt; returns never.&amp;rdquo; Functions that return never are called &lt;em&gt;diverging functions&lt;/em&gt;. We can&amp;rsquo;t create values of the type &lt;code&gt;!&lt;/code&gt; so &lt;code&gt;bar&lt;/code&gt; can never possibly return.</source>
          <target state="translated">이 코드는 &quot;기능 &lt;code&gt;bar&lt;/code&gt; 반환되지 않음 &quot;으로 읽습니다 . 리턴 &lt;em&gt;하는 함수를 분기 함수&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; . 유형의 값을 만들 수 없습니다 &lt;code&gt;!&lt;/code&gt; 그래서 &lt;code&gt;bar&lt;/code&gt; 는 결코 돌아올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bcd0c3078c2294c0e6fda3c229de0e1561bef882" translate="yes" xml:space="preserve">
          <source>This code is similar to &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#creating-custom-types-for-validation&quot;&gt;the &lt;code&gt;Guess::new&lt;/code&gt; function we wrote in Listing 9-10&lt;/a&gt;, where we called &lt;code&gt;panic!&lt;/code&gt; when the &lt;code&gt;value&lt;/code&gt; argument was out of the range of valid values. Instead of checking for a range of values here, we&amp;rsquo;re checking that the length of &lt;code&gt;args&lt;/code&gt; is at least 3 and the rest of the function can operate under the assumption that this condition has been met. If &lt;code&gt;args&lt;/code&gt; has fewer than three items, this condition will be true, and we call the &lt;code&gt;panic!&lt;/code&gt; macro to end the program immediately.</source>
          <target state="translated">이 코드는 비슷합니다 &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#creating-custom-types-for-validation&quot;&gt; &lt;code&gt;Guess::new&lt;/code&gt; &lt;/a&gt; 우리는 목록 9-10에 쓴 기능 , 우리는라는 곳 &lt;code&gt;panic!&lt;/code&gt; 때 &lt;code&gt;value&lt;/code&gt; 인자는 유효 값 범위 밖이었다. 여기서 값의 범위를 확인하는 대신 &lt;code&gt;args&lt;/code&gt; 의 길이가 3 이상인지 확인 하고 나머지 조건은이 조건이 충족되었다는 가정하에 작동 할 수 있습니다. 경우 &lt;code&gt;args&lt;/code&gt; 세 개 미만의 항목이,이 조건이 만족되어야하며, 우리는 전화 &lt;code&gt;panic!&lt;/code&gt; 매크로를 사용하여 프로그램을 즉시 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="7a83ac1e4ecf68353438d16df2a11f1d38c56035" translate="yes" xml:space="preserve">
          <source>This code is the automatically generated test module. The attribute &lt;code&gt;cfg&lt;/code&gt; stands for &lt;em&gt;configuration&lt;/em&gt; and tells Rust that the following item should only be included given a certain configuration option. In this case, the configuration option is &lt;code&gt;test&lt;/code&gt;, which is provided by Rust for compiling and running tests. By using the &lt;code&gt;cfg&lt;/code&gt; attribute, Cargo compiles our test code only if we actively run the tests with &lt;code&gt;cargo test&lt;/code&gt;. This includes any helper functions that might be within this module, in addition to the functions annotated with &lt;code&gt;#[test]&lt;/code&gt;.</source>
          <target state="translated">이 코드는 자동으로 생성 된 테스트 모듈입니다. &lt;code&gt;cfg&lt;/code&gt; 속성 은 &lt;em&gt;구성을&lt;/em&gt; 나타내며 Rust에게 특정 구성 옵션이 주어지면 다음 항목 만 포함되어야 함을 알려줍니다. 이 경우 구성 옵션은 &lt;code&gt;test&lt;/code&gt; 이며 이는 테스트 컴파일 및 실행을 위해 Rust에서 제공합니다. &lt;code&gt;cfg&lt;/code&gt; 속성 을 사용하여 Cargo는 &lt;code&gt;cargo test&lt;/code&gt; 로 테스트를 적극적으로 실행하는 경우에만 테스트 코드를 컴파일합니다 . 여기에는 &lt;code&gt;#[test]&lt;/code&gt; 로 주석이 달린 함수 외에도이 모듈 내에있을 수있는 모든 도우미 함수가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="fb14b558eed9a012f6129027202f61756e6e0b8d" translate="yes" xml:space="preserve">
          <source>This code lets us break complex types into their component parts so we can use the values we&amp;rsquo;re interested in separately.</source>
          <target state="translated">이 코드를 사용하면 복잡한 유형을 구성 요소 부분으로 나눌 수 있으므로 관심있는 값을 별도로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf80b97b3cceef068893acf5a419fa57178f1aed" translate="yes" xml:space="preserve">
          <source>This code means the type &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; will have a method named &lt;code&gt;distance_from_origin&lt;/code&gt; and other instances of &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is not of type &lt;code&gt;f32&lt;/code&gt; will not have this method defined. The method measures how far our point is from the point at coordinates (0.0, 0.0) and uses mathematical operations that are available only for floating point types.</source>
          <target state="translated">이 코드는 입력 수단 &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; 하는 방법이라는 것이다 &lt;code&gt;distance_from_origin&lt;/code&gt; 그리고 다른 경우 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; 가 타입이 아닌 &lt;code&gt;f32&lt;/code&gt; 정의 된 본 방법이 없을 것이다. 이 방법은 좌표 (0.0, 0.0)에서 점과의 거리를 측정하고 부동 소수점 유형에만 사용할 수있는 수학 연산을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="edb9c9f6097f3c4e5bd16a047b4ef0c91c5eda3e" translate="yes" xml:space="preserve">
          <source>This code overrides the default setting of &lt;code&gt;0&lt;/code&gt;. Now when we run &lt;code&gt;cargo build&lt;/code&gt;, Cargo will use the defaults for the &lt;code&gt;dev&lt;/code&gt; profile plus our customization to &lt;code&gt;opt-level&lt;/code&gt;. Because we set &lt;code&gt;opt-level&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt;, Cargo will apply more optimizations than the default, but not as many as in a release build.</source>
          <target state="translated">이 코드는 기본 설정 인 &lt;code&gt;0&lt;/code&gt; 을 무시합니다 . &lt;code&gt;cargo build&lt;/code&gt; 실행 하면 Cargo는 &lt;code&gt;dev&lt;/code&gt; 프로파일 의 기본값 과 &lt;code&gt;opt-level&lt;/code&gt; 에 대한 사용자 정의를 사용 합니다 . &lt;code&gt;opt-level&lt;/code&gt; 을 &lt;code&gt;1&lt;/code&gt; 로 설정했기 때문에 Cargo는 기본값보다 더 많은 최적화를 적용하지만 릴리스 빌드만큼 많지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="cbd474aff68e6272a4d817ab514ba2ba338dc2b1" translate="yes" xml:space="preserve">
          <source>This code panics!</source>
          <target state="translated">이 코드는 패닉 상태입니다!</target>
        </trans-unit>
        <trans-unit id="1520d0fd722c3577359ba16db239ceb0ddeebd5f" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;1 new tweet: (Read more from @horse_ebooks...)&lt;/code&gt;.</source>
          <target state="translated">이 코드는 인쇄 &lt;code&gt;1 new tweet: (Read more from @horse_ebooks...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d78693e95ef2bffb056748f86ea7d4fd87f6784" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;1 new tweet: horse_ebooks: of course, as you probably already know, people&lt;/code&gt;.</source>
          <target state="translated">이 코드는 &lt;code&gt;1 new tweet: horse_ebooks: of course, as you probably already know, people&lt;/code&gt; 출력합니다 : horse_ebooks : 물론 이미 알고 있듯이 people .</target>
        </trans-unit>
        <trans-unit id="a4e90b820e3471ed9be465d87743c5461551a7f0" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;Current location: (3, 5)&lt;/code&gt;. The values &lt;code&gt;&amp;amp;(3, 5)&lt;/code&gt; match the pattern &lt;code&gt;&amp;amp;(x, y)&lt;/code&gt;, so &lt;code&gt;x&lt;/code&gt; is the value &lt;code&gt;3&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is the value &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">이 코드는 &lt;code&gt;Current location: (3, 5)&lt;/code&gt; 인쇄합니다 . 값 &lt;code&gt;&amp;amp;(3, 5)&lt;/code&gt; 는 패턴 &lt;code&gt;&amp;amp;(x, y)&lt;/code&gt; ) 와 일치 하므로 &lt;code&gt;x&lt;/code&gt; 는 값 &lt;code&gt;3&lt;/code&gt; 이고 &lt;code&gt;y&lt;/code&gt; 는 값 &lt;code&gt;5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fb3c413eeb04880ff8b53ff489dddef4151c97bb" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;New article available! (Read more...)&lt;/code&gt;.</source>
          <target state="translated">이 코드는 &lt;code&gt;New article available! (Read more...)&lt;/code&gt; 인쇄 합니다! (더 읽기 ...) .</target>
        </trans-unit>
        <trans-unit id="4bdc1d17208e27666bda4fd318b994f6acf7818b" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;The answer is: 12&lt;/code&gt;. We specify that the parameter &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;do_twice&lt;/code&gt; is an &lt;code&gt;fn&lt;/code&gt; that takes one parameter of type &lt;code&gt;i32&lt;/code&gt; and returns an &lt;code&gt;i32&lt;/code&gt;. We can then call &lt;code&gt;f&lt;/code&gt; in the body of &lt;code&gt;do_twice&lt;/code&gt;. In &lt;code&gt;main&lt;/code&gt;, we can pass the function name &lt;code&gt;add_one&lt;/code&gt; as the first argument to &lt;code&gt;do_twice&lt;/code&gt;.</source>
          <target state="translated">이 코드는 &lt;code&gt;The answer is: 12&lt;/code&gt; . 우리는 매개 변수 지정 &lt;code&gt;f&lt;/code&gt; 에서 &lt;code&gt;do_twice&lt;/code&gt; 가 이다 &lt;code&gt;fn&lt;/code&gt; 타입의 하나 개의 매개 변수 소요 &lt;code&gt;i32&lt;/code&gt; 하고 반환 &lt;code&gt;i32&lt;/code&gt; . 그런 다음 &lt;code&gt;do_twice&lt;/code&gt; 본문에서 &lt;code&gt;f&lt;/code&gt; 를 호출 할 수 있습니다 . 에서 &lt;code&gt;main&lt;/code&gt; , 우리는 함수 이름을 전달할 수 있습니다 &lt;code&gt;add_one&lt;/code&gt; 에 첫 번째 인수로 &lt;code&gt;do_twice&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="f51af940300a3743a5ab26b4b6248a93015d25fc" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;one or two&lt;/code&gt;.</source>
          <target state="translated">이 코드는 &lt;code&gt;one or two&lt;/code&gt; 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="fa3fc2ca0fc1e2ca4079f6b9c2e26f148c6f028f" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;one&lt;/code&gt; because the value in &lt;code&gt;x&lt;/code&gt; is 1. This syntax is useful when you want your code to take an action if it gets a particular concrete value.</source>
          <target state="translated">이 코드 는 &lt;code&gt;x&lt;/code&gt; 의 값 이 &lt;code&gt;one&lt;/code&gt; 이기 때문에 하나를 인쇄합니다 .이 구문은 코드가 특정한 구체적 값을 얻는 경우 조치를 취하려고 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f76e20cf8d5177f5195a6770ae0f2388492d5a80" translate="yes" xml:space="preserve">
          <source>This code prints the following:</source>
          <target state="translated">이 코드는 다음을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="2da1adcf6ac7d40ff872dbb16e9f7a36210c0c52" translate="yes" xml:space="preserve">
          <source>This code should compile and produce the result we want when we use it with the &lt;code&gt;main&lt;/code&gt; function in Listing 10-20.</source>
          <target state="translated">이 코드는 Listing 10-20 의 &lt;code&gt;main&lt;/code&gt; 함수 와 함께 사용할 때 원하는 결과를 컴파일하고 생성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fc992e6806cb1bd5a9c534e91522711af45f4b36" translate="yes" xml:space="preserve">
          <source>This code should look generally familiar: a trait with one method and an associated type. The new part is &lt;code&gt;RHS=Self&lt;/code&gt;: this syntax is called &lt;em&gt;default type parameters&lt;/em&gt;. The &lt;code&gt;RHS&lt;/code&gt; generic type parameter (short for &amp;ldquo;right hand side&amp;rdquo;) defines the type of the &lt;code&gt;rhs&lt;/code&gt; parameter in the &lt;code&gt;add&lt;/code&gt; method. If we don&amp;rsquo;t specify a concrete type for &lt;code&gt;RHS&lt;/code&gt; when we implement the &lt;code&gt;Add&lt;/code&gt; trait, the type of &lt;code&gt;RHS&lt;/code&gt; will default to &lt;code&gt;Self&lt;/code&gt;, which will be the type we&amp;rsquo;re implementing &lt;code&gt;Add&lt;/code&gt; on.</source>
          <target state="translated">이 코드는 일반적으로 친숙해 보일 것입니다. 하나의 메소드와 관련 유형이있는 특성입니다. 새로운 부분은 &lt;code&gt;RHS=Self&lt;/code&gt; 입니다 .이 구문을 &lt;em&gt;기본 유형 매개 변수&lt;/em&gt; 라고 합니다. &lt;code&gt;RHS&lt;/code&gt; (줄여서 &quot;우측&quot;에 대한) 일반적인 타입 파라미터의 타입을 정의 &lt;code&gt;rhs&lt;/code&gt; 파라미터에 &lt;code&gt;add&lt;/code&gt; 방법. 우리가에 대한 구체적인 유형을 지정하지 않으면 &lt;code&gt;RHS&lt;/code&gt; 우리가 구현할 때 &lt;code&gt;Add&lt;/code&gt; 특성을의 종류 &lt;code&gt;RHS&lt;/code&gt; 는 기본값으로 사용됩니다 &lt;code&gt;Self&lt;/code&gt; 우리가 구현하고있는 유형이 될 것이다, &lt;code&gt;Add&lt;/code&gt; 에.</target>
        </trans-unit>
        <trans-unit id="58a84861deaa80c4db75f055d7277e059fbe6bb3" translate="yes" xml:space="preserve">
          <source>This code should look generally familiar: a trait with one method and an associated type. The new part is &lt;code&gt;Rhs=Self&lt;/code&gt;: this syntax is called &lt;em&gt;default type parameters&lt;/em&gt;. The &lt;code&gt;Rhs&lt;/code&gt; generic type parameter (short for &amp;ldquo;right hand side&amp;rdquo;) defines the type of the &lt;code&gt;rhs&lt;/code&gt; parameter in the &lt;code&gt;add&lt;/code&gt; method. If we don&amp;rsquo;t specify a concrete type for &lt;code&gt;Rhs&lt;/code&gt; when we implement the &lt;code&gt;Add&lt;/code&gt; trait, the type of &lt;code&gt;Rhs&lt;/code&gt; will default to &lt;code&gt;Self&lt;/code&gt;, which will be the type we&amp;rsquo;re implementing &lt;code&gt;Add&lt;/code&gt; on.</source>
          <target state="translated">이 코드는 일반적으로 익숙한 것처럼 보일 것입니다. 하나의 메서드와 관련 유형이있는 특성입니다. 새 부분은 &lt;code&gt;Rhs=Self&lt;/code&gt; 입니다 .이 구문을 &lt;em&gt;기본 유형 매개 변수&lt;/em&gt; 라고 합니다. &lt;code&gt;Rhs&lt;/code&gt; (줄여서 &quot;우측&quot;에 대한) 일반적인 타입 파라미터의 타입을 정의 &lt;code&gt;rhs&lt;/code&gt; 파라미터에 &lt;code&gt;add&lt;/code&gt; 방법. 우리가에 대한 구체적인 유형을 지정하지 않으면 &lt;code&gt;Rhs&lt;/code&gt; 우리가 구현할 때 &lt;code&gt;Add&lt;/code&gt; 특성을의 종류 &lt;code&gt;Rhs&lt;/code&gt; 기본값으로 사용됩니다 &lt;code&gt;Self&lt;/code&gt; 우리가 구현하고있는 유형이 될 것이다, &lt;code&gt;Add&lt;/code&gt; 에.</target>
        </trans-unit>
        <trans-unit id="9916bd76554811c91bac8fdab30ae1e7bf834537" translate="yes" xml:space="preserve">
          <source>This code still won&amp;rsquo;t work, but let&amp;rsquo;s check it again to get the next error that we need to address:</source>
          <target state="translated">이 코드는 여전히 작동하지 않지만 해결해야 할 다음 오류가 발생하는지 다시 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d27513508379ea6cd339c0bb4a46ef6e82c466b9" translate="yes" xml:space="preserve">
          <source>This code stores a list of integers in the variable &lt;code&gt;number_list&lt;/code&gt; and places the first number in the list in a variable named &lt;code&gt;largest&lt;/code&gt;. Then it iterates through all the numbers in the list, and if the current number is greater than the number stored in &lt;code&gt;largest&lt;/code&gt;, it replaces the number in that variable. However, if the current number is less than or equal to the largest number seen so far, the variable doesn&amp;rsquo;t change, and the code moves on to the next number in the list. After considering all the numbers in the list, &lt;code&gt;largest&lt;/code&gt; should hold the largest number, which in this case is 100.</source>
          <target state="translated">이 코드는 변수 &lt;code&gt;number_list&lt;/code&gt; 에 정수 목록을 저장하고 &lt;code&gt;largest&lt;/code&gt; 변수에 목록의 첫 번째 숫자를 배치합니다 . 그런 다음 목록의 모든 숫자를 반복하고 현재 숫자가 &lt;code&gt;largest&lt;/code&gt; 저장된 숫자보다 큰 경우 해당 변수의 숫자를 대체합니다. 그러나 현재 숫자가 지금까지 표시된 최대 숫자보다 작거나 같으면 변수가 변경되지 않고 코드가 목록의 다음 숫자로 이동합니다. 목록에있는 모든 숫자를 고려하면, &lt;code&gt;largest&lt;/code&gt; 이 경우 100 가장 큰 수를 유지해야한다.</target>
        </trans-unit>
        <trans-unit id="65e3fdd29c21c5766164366857eab04eba8f916b" translate="yes" xml:space="preserve">
          <source>This code will compile and will store the number of &lt;code&gt;Worker&lt;/code&gt; instances we specified as an argument to &lt;code&gt;ThreadPool::new&lt;/code&gt;. But we&amp;rsquo;re &lt;em&gt;still&lt;/em&gt; not processing the closure that we get in &lt;code&gt;execute&lt;/code&gt;. Let&amp;rsquo;s look at how to do that next.</source>
          <target state="translated">이 코드는 &lt;code&gt;ThreadPool::new&lt;/code&gt; 대한 인수로 지정한 &lt;code&gt;Worker&lt;/code&gt; 인스턴스 수를 컴파일하고 저장합니다 . 그러나 우리는 &lt;em&gt;여전히 &lt;/em&gt; &lt;code&gt;execute&lt;/code&gt; 중인 클로저를 처리하지 않습니다 . 다음에 어떻게해야하는지 봅시다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="045fdd180c10e009660c1c81e0cc6eab5a5aa968" translate="yes" xml:space="preserve">
          <source>This code will compile just fine. For more about trait objects, refer to the section &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; in Chapter 17.</source>
          <target state="translated">이 코드는 잘 컴파일됩니다. 형질 개체에 대한 자세한 내용은 17 장의 &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&quot;다른 유형의 값을 허용하는 특성 개체 사용&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="457c8af0abaf5c3ca5e095102658cc6466fc1c3e" translate="yes" xml:space="preserve">
          <source>This code will compile without any errors. Note the &lt;code&gt;r#&lt;/code&gt; prefix on the function name in its definition as well as where the function is called in &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">이 코드는 오류없이 컴파일됩니다. 함수 정의에서 함수 이름 의 &lt;code&gt;r#&lt;/code&gt; 접두어와 &lt;code&gt;main&lt;/code&gt; 에서 함수가 호출되는 위치에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="a4e6558f8bd1055ab8e1efd4008b36e362cb01bc" translate="yes" xml:space="preserve">
          <source>This code will completely ignore the value passed as the first argument, &lt;code&gt;3&lt;/code&gt;, and will print &lt;code&gt;This code only uses the y parameter: 4&lt;/code&gt;.</source>
          <target state="translated">이 코드는 완전히 첫 번째 인수로서 전달 된 값을 무시하고 &lt;code&gt;3&lt;/code&gt; 및 인쇄 될 &lt;code&gt;This code only uses the y parameter: 4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f597cb1c1231379b4a9ac9b16a64f6f09dac15f9" translate="yes" xml:space="preserve">
          <source>This code will now print &lt;code&gt;Default case, x = Some(5)&lt;/code&gt;. The pattern in the second match arm doesn&amp;rsquo;t introduce a new variable &lt;code&gt;y&lt;/code&gt; that would shadow the outer &lt;code&gt;y&lt;/code&gt;, meaning we can use the outer &lt;code&gt;y&lt;/code&gt; in the match guard. Instead of specifying the pattern as &lt;code&gt;Some(y)&lt;/code&gt;, which would have shadowed the outer &lt;code&gt;y&lt;/code&gt;, we specify &lt;code&gt;Some(n)&lt;/code&gt;. This creates a new variable &lt;code&gt;n&lt;/code&gt; that doesn&amp;rsquo;t shadow anything because there is no &lt;code&gt;n&lt;/code&gt; variable outside the &lt;code&gt;match&lt;/code&gt;.</source>
          <target state="translated">이 코드는 이제 &lt;code&gt;Default case, x = Some(5)&lt;/code&gt; 합니다. 두 번째 매치 암의 패턴 은 외부 &lt;code&gt;y&lt;/code&gt; 를 가리는 새로운 변수 &lt;code&gt;y&lt;/code&gt; 를 도입하지 않습니다 . 즉, 우리는 매치 가드에서 외부 &lt;code&gt;y&lt;/code&gt; 를 사용할 수 있습니다 . 외부 &lt;code&gt;y&lt;/code&gt; 를 음영 처리 한 &lt;code&gt;Some(y)&lt;/code&gt; 로 패턴을 지정하는 대신 &lt;code&gt;Some(n)&lt;/code&gt; 지정 합니다. 이것은 &lt;code&gt;match&lt;/code&gt; 외부에 &lt;code&gt;n&lt;/code&gt; 변수 가 없기 때문에 아무것도 가리지 않는 새로운 변수 &lt;code&gt;n&lt;/code&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1bcf93c595538a9e0c98606ec2aa75cae859981c" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;Can't overwrite an existing customized value&lt;/code&gt; and then &lt;code&gt;setting is Some(5)&lt;/code&gt;. In the first match arm, we don&amp;rsquo;t need to match on or use the values inside either &lt;code&gt;Some&lt;/code&gt; variant, but we do need to test for the case when &lt;code&gt;setting_value&lt;/code&gt; and &lt;code&gt;new_setting_value&lt;/code&gt; are the &lt;code&gt;Some&lt;/code&gt; variant. In that case, we print why we&amp;rsquo;re not changing &lt;code&gt;setting_value&lt;/code&gt;, and it doesn&amp;rsquo;t get changed.</source>
          <target state="translated">이 코드는 인쇄됩니다 &lt;code&gt;Can't overwrite an existing customized value&lt;/code&gt; 다음 &lt;code&gt;setting is Some(5)&lt;/code&gt; . 첫 번째 일치 항목에서는 &lt;code&gt;Some&lt;/code&gt; 변형 내에서 값을 일치 시키거나 사용할 필요가 없지만 &lt;code&gt;setting_value&lt;/code&gt; 및 &lt;code&gt;new_setting_value&lt;/code&gt; 가 &lt;code&gt;Some&lt;/code&gt; 변형 인 경우를 테스트해야합니다 . 이 경우 &lt;code&gt;setting_value&lt;/code&gt; 를 변경하지 않는 이유를 인쇄하고 변경 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59fe6f0c2e0e4f24920973a91f227ffd825f4348" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;Change the color to red 0, green 160, and blue 255&lt;/code&gt;. Try changing the value of &lt;code&gt;msg&lt;/code&gt; to see the code from the other arms run.</source>
          <target state="translated">이 코드는 &lt;code&gt;Change the color to red 0, green 160, and blue 255&lt;/code&gt; . 다른 arm 실행 코드를 보려면 &lt;code&gt;msg&lt;/code&gt; 값을 변경 하십시오.</target>
        </trans-unit>
        <trans-unit id="3c54f68158af593ed8370c89b1e792c808e333b9" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;Hello, Macro! My name is Pancakes!&lt;/code&gt; when we&amp;rsquo;re done. The first step is to make a new library crate, like this:</source>
          <target state="translated">이 코드는 &lt;code&gt;Hello, Macro! My name is Pancakes!&lt;/code&gt; 우리가 끝나면. 첫 번째 단계는 다음과 같이 새 라이브러리 상자를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6ef0c24b1ac6e78f32662fb7a47aa078602f7661" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;Some numbers: 2, 8, 32&lt;/code&gt;, and the values 4 and 16 will be ignored.</source>
          <target state="translated">이 코드는 &lt;code&gt;Some numbers: 2, 8, 32&lt;/code&gt; 를 인쇄 하며 값 4와 16은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6e7f6cc166031d911beb7caaef0389c2805500c8" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;{&quot;Blue&quot;: 25}&lt;/code&gt;. The original value of &lt;code&gt;10&lt;/code&gt; has been overwritten.</source>
          <target state="translated">이 코드는 &lt;code&gt;{&quot;Blue&quot;: 25}&lt;/code&gt; 인쇄 합니다. 원래 값인 &lt;code&gt;10&lt;/code&gt; 을 덮어 썼습니다.</target>
        </trans-unit>
        <trans-unit id="4c7854ef3442e5dc7384d2ebe52264fddb2a172b" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}&lt;/code&gt;. The &lt;code&gt;or_insert&lt;/code&gt; method actually returns a mutable reference (&lt;code&gt;&amp;amp;mut V&lt;/code&gt;) to the value for this key. Here we store that mutable reference in the &lt;code&gt;count&lt;/code&gt; variable, so in order to assign to that value, we must first dereference &lt;code&gt;count&lt;/code&gt; using the asterisk (&lt;code&gt;*&lt;/code&gt;). The mutable reference goes out of scope at the end of the &lt;code&gt;for&lt;/code&gt; loop, so all of these changes are safe and allowed by the borrowing rules.</source>
          <target state="translated">이 코드는 &lt;code&gt;{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}&lt;/code&gt; 합니다. &lt;code&gt;or_insert&lt;/code&gt; 의 방법은 실제로 가변 레퍼런스 (반환 &lt;code&gt;&amp;amp;mut V&lt;/code&gt; 이 키 값을 참조). 여기서는 가변 변수 참조를 &lt;code&gt;count&lt;/code&gt; 변수에 저장하므로 해당 값에 할당하려면 먼저 별표 ( &lt;code&gt;*&lt;/code&gt; )를 사용하여 &lt;code&gt;count&lt;/code&gt; 를 역 참조해야합니다 . 변경 가능한 참조는 &lt;code&gt;for&lt;/code&gt; 루프 가 끝날 때 범위를 벗어남에 따라 이러한 모든 변경 사항이 안전하고 차용 규칙에 의해 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d2527fb52597f9416819ef1fc01a194d639282f6" translate="yes" xml:space="preserve">
          <source>This code will print each pair in an arbitrary order:</source>
          <target state="translated">이 코드는 각 쌍을 임의의 순서로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="bacd4441a056463b6c76d4dcb3493a2106b165e0" translate="yes" xml:space="preserve">
          <source>This code will print the 18 bytes that make up this &lt;code&gt;String&lt;/code&gt;:</source>
          <target state="translated">이 코드는이 &lt;code&gt;String&lt;/code&gt; 을 구성하는 18 바이트를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="df66479dcc3e1d9cca2a55caf3dadeea76d13542" translate="yes" xml:space="preserve">
          <source>This code will print the following:</source>
          <target state="translated">이 코드는 다음을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="6cf1c1dee0071b4d526326a9881c97e561ec0f1a" translate="yes" xml:space="preserve">
          <source>This code will result in the following error:</source>
          <target state="translated">이 코드는 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bd9279581006b04d3fb15d53d9a31240a9bda944" translate="yes" xml:space="preserve">
          <source>This code works just fine because we never bind &lt;code&gt;s&lt;/code&gt; to anything; it isn&amp;rsquo;t moved.</source>
          <target state="translated">이 코드는 &lt;code&gt;s&lt;/code&gt; 를 절대로 바인딩하지 않기 때문에 제대로 작동합니다 . 움직이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a72012f28327d683a9fda9d6b4835b6ec97dd74b" translate="yes" xml:space="preserve">
          <source>This code works the way the business wants it to now, but let&amp;rsquo;s say the data science team decides that we need to make some changes to the way we call the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function in the future. To simplify the update when those changes happen, we want to refactor this code so it calls the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function only once. We also want to cut the place where we&amp;rsquo;re currently unnecessarily calling the function twice without adding any other calls to that function in the process. That is, we don&amp;rsquo;t want to call it if the result isn&amp;rsquo;t needed, and we still want to call it only once.</source>
          <target state="translated">이 코드는 현재 비즈니스가 원하는 방식으로 작동하지만 데이터 과학 팀 이 향후 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 함수를 호출하는 방식을 일부 변경해야한다고 결정합니다 . 이러한 변경이 발생할 때 업데이트를 단순화하기 위해이 코드를 리팩터링하여이 코드를 다시 한 번 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 함수를 호출하려고합니다 . 또한 프로세스에서 해당 함수에 다른 호출을 추가하지 않고 현재 불필요하게 함수를 두 번 호출하는 위치를 줄이고 싶습니다. 즉, 결과가 필요하지 않은 경우 호출하지 않고 여전히 한 번만 호출하려고합니다.</target>
        </trans-unit>
        <trans-unit id="29594b80ae15e7f3a6760f8d699f1007a88ab197" translate="yes" xml:space="preserve">
          <source>This code would attempt to link with &lt;code&gt;libmy_c_library.so&lt;/code&gt; on unix-like systems and &lt;code&gt;my_c_library.dll&lt;/code&gt; on Windows at runtime, and panic if it can't find something to link to. Rust code could then use &lt;code&gt;my_c_function&lt;/code&gt; as if it were any other unsafe Rust function. Working with non-Rust languages and FFI is inherently unsafe, so wrappers are usually built around C APIs.</source>
          <target state="translated">이 코드와 링크를 시도 할 것 &lt;code&gt;libmy_c_library.so&lt;/code&gt; 에 유닉스 계열 시스템 및 &lt;code&gt;my_c_library.dll&lt;/code&gt; Windows에서 실행시, 그리고 그것을 링크에 뭔가를 찾을 수없는 경우 당황. 그러면 Rust 코드는 다른 안전하지 않은 Rust 함수 인 것처럼 &lt;code&gt;my_c_function&lt;/code&gt; 을 사용할 수 있습니다. 비 Rust 언어 및 FFI로 작업하는 것은 본질적으로 안전하지 않으므로 래퍼는 일반적으로 C API를 중심으로 구축됩니다.</target>
        </trans-unit>
        <trans-unit id="94ac7a59ef0f9f139e040ad72861c14b2eb19308" translate="yes" xml:space="preserve">
          <source>This code would print &lt;code&gt;x = 5 and y = 10&lt;/code&gt;.</source>
          <target state="translated">이 코드는 &lt;code&gt;x = 5 and y = 10&lt;/code&gt; 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="0be10b63965c309b87ed0545b477401b58dc21cb" translate="yes" xml:space="preserve">
          <source>This command creates an executable file in &lt;em&gt;target/debug/hello_cargo&lt;/em&gt; (or &lt;em&gt;target\debug\hello_cargo.exe&lt;/em&gt; on Windows) rather than in your current directory. You can run the executable with this command:</source>
          <target state="translated">이 명령은 현재 디렉토리가 아닌 &lt;em&gt;target / debug / hello_cargo&lt;/em&gt; (또는 Windows의 경우 &lt;em&gt;target \ debug \ hello_cargo.exe)&lt;/em&gt; 에 실행 파일을 만듭니다 . 이 명령으로 실행 파일을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dd02fcb167dbab5d0f3cc67c54c6c5da2a62c5e" translate="yes" xml:space="preserve">
          <source>This command gives you &lt;code&gt;rustfmt&lt;/code&gt; and &lt;code&gt;cargo-fmt&lt;/code&gt;, similar to how Rust gives you both &lt;code&gt;rustc&lt;/code&gt; and &lt;code&gt;cargo&lt;/code&gt;. To format any Cargo project, enter the following:</source>
          <target state="translated">이 명령은 &lt;code&gt;rustfmt&lt;/code&gt; 및 &lt;code&gt;cargo-fmt&lt;/code&gt; 를 제공합니다. Rust가 &lt;code&gt;rustc&lt;/code&gt; 및 &lt;code&gt;cargo&lt;/code&gt; 를 제공하는 방식과 유사합니다 . 화물 프로젝트를 형식화하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="616fc540cd704c55f34b7ddb4249c489ab431fea" translate="yes" xml:space="preserve">
          <source>This command ran all tests with &lt;code&gt;add&lt;/code&gt; in the name and filtered out the test named &lt;code&gt;one_hundred&lt;/code&gt;. Also note that the module in which a test appears becomes part of the test&amp;rsquo;s name, so we can run all the tests in a module by filtering on the module&amp;rsquo;s name.</source>
          <target state="translated">이 명령은 이름 이 &lt;code&gt;add&lt;/code&gt; 인 모든 테스트를 실행하고 이름이 &lt;code&gt;one_hundred&lt;/code&gt; 인 테스트를 필터링했습니다 . 또한 테스트가 나타나는 모듈은 테스트 이름의 일부가되므로 모듈 이름을 필터링하여 모듈에서 모든 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ea7582e38a836907de1d30ee5b58334fa20a196" translate="yes" xml:space="preserve">
          <source>This command runs only the tests in the &lt;em&gt;tests/integration_test.rs&lt;/em&gt; file.</source>
          <target state="translated">이 명령은 &lt;em&gt;tests / integration_test.rs&lt;/em&gt; 파일 의 &lt;em&gt;테스트&lt;/em&gt; 만 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="0760093e6150870ee34facc6b7a5327edc5dc69d" translate="yes" xml:space="preserve">
          <source>This command will inform Cargo of your API token and store it locally in &lt;em&gt;~/.cargo/credentials&lt;/em&gt;. Note that this token is a &lt;em&gt;secret&lt;/em&gt;: do not share it with anyone else. If you do share it with anyone for any reason, you should revoke it and generate a new token on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;.</source>
          <target state="translated">이 명령은 Cargo에 API 토큰을 알리고 &lt;em&gt;~ / .cargo / credentials에&lt;/em&gt; 로컬로 저장합니다 . 이 토큰은 &lt;em&gt;비밀&lt;/em&gt; 입니다. 다른 사람과 공유하지 마십시오. 어떤 이유로 든 다른 사람과 공유하는 경우이를 취소하고 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; 에서 새 토큰을 생성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5e88705efdf159f3ff9b6126f1c10159a182f8df" translate="yes" xml:space="preserve">
          <source>This compiles because &lt;code&gt;longer&lt;/code&gt; outlives &lt;code&gt;shorter&lt;/code&gt;, thus the constraint is respected:</source>
          <target state="translated">이 컴파일이 있기 때문에 &lt;code&gt;longer&lt;/code&gt; 들보 다 오래 남았습니다 &lt;code&gt;shorter&lt;/code&gt; , 따라서 제약 존경 :</target>
        </trans-unit>
        <trans-unit id="3f29dc82f5ad5c21f66ea4c65c4df005f9bfa118" translate="yes" xml:space="preserve">
          <source>This computes the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self = n * rhs + self.rem_euclid(rhs)&lt;/code&gt;, with &lt;code&gt;0 &amp;lt;= self.rem_euclid(rhs) &amp;lt; rhs&lt;/code&gt;.</source>
          <target state="translated">이것은 정수 계산 &lt;code&gt;n&lt;/code&gt; 등 그 &lt;code&gt;self = n * rhs + self.rem_euclid(rhs)&lt;/code&gt; 와 &lt;code&gt;0 &amp;lt;= self.rem_euclid(rhs) &amp;lt; rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92466c99e75537fb86fdcb8b6177060d58e36e85" translate="yes" xml:space="preserve">
          <source>This computes the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self = n * rhs + self.rem_euclid(rhs)&lt;/code&gt;. In other words, the result is &lt;code&gt;self / rhs&lt;/code&gt; rounded to the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt;.</source>
          <target state="translated">이것은 정수 계산 &lt;code&gt;n&lt;/code&gt; 되도록 &lt;code&gt;self = n * rhs + self.rem_euclid(rhs)&lt;/code&gt; . 즉, 결과는 &lt;code&gt;self / rhs&lt;/code&gt; 정수로 반올림 &lt;code&gt;n&lt;/code&gt; 되도록 &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30ff452f5fae3358ab149e5ae5cfa16c08f607d2" translate="yes" xml:space="preserve">
          <source>This concept&amp;mdash;of being concerned only with the messages a value responds to rather than the value&amp;rsquo;s concrete type&amp;mdash;is similar to the concept &lt;em&gt;duck typing&lt;/em&gt; in dynamically typed languages: if it walks like a duck and quacks like a duck, then it must be a duck! In the implementation of &lt;code&gt;run&lt;/code&gt; on &lt;code&gt;Screen&lt;/code&gt; in Listing 17-5, &lt;code&gt;run&lt;/code&gt; doesn&amp;rsquo;t need to know what the concrete type of each component is. It doesn&amp;rsquo;t check whether a component is an instance of a &lt;code&gt;Button&lt;/code&gt; or a &lt;code&gt;SelectBox&lt;/code&gt;, it just calls the &lt;code&gt;draw&lt;/code&gt; method on the component. By specifying &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt; as the type of the values in the &lt;code&gt;components&lt;/code&gt; vector, we&amp;rsquo;ve defined &lt;code&gt;Screen&lt;/code&gt; to need values that we can call the &lt;code&gt;draw&lt;/code&gt; method on.</source>
          <target state="translated">값의 구체적인 유형이 아닌 값이 응답하는 메시지에만 관심이있는이 개념 은 동적으로 유형이 지정된 언어로 &lt;em&gt;입력&lt;/em&gt; 하는 &lt;em&gt;오리&lt;/em&gt; 개념과 유사합니다. &lt;em&gt;오리&lt;/em&gt; 처럼 걷고 오리처럼 like 거리면 오리! 의 구현에서 &lt;code&gt;run&lt;/code&gt; 에 &lt;code&gt;Screen&lt;/code&gt; 목록 17-5에서, &lt;code&gt;run&lt;/code&gt; 각 구성 요소의 구체적인 유형이 무엇인지 알 필요가 없습니다. 구성 요소가 &lt;code&gt;Button&lt;/code&gt; 또는 &lt;code&gt;SelectBox&lt;/code&gt; 인스턴스인지 확인하지 않고 구성 요소 에서 &lt;code&gt;draw&lt;/code&gt; 메서드를 호출 하기 만합니다 . 지정하여 &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt; 의 값의 유형으로 &lt;code&gt;components&lt;/code&gt; 벡터, 우리가 정의한 &lt;code&gt;Screen&lt;/code&gt; &lt;code&gt;draw&lt;/code&gt; 메소드를 호출 할 수있는 값이 필요한 화면</target>
        </trans-unit>
        <trans-unit id="80fbf38c87a2fe3d71541d31605bf9ab62ed6238" translate="yes" xml:space="preserve">
          <source>This concept&amp;mdash;of being concerned only with the messages a value responds to rather than the value&amp;rsquo;s concrete type&amp;mdash;is similar to the concept of &lt;em&gt;duck typing&lt;/em&gt; in dynamically typed languages: if it walks like a duck and quacks like a duck, then it must be a duck! In the implementation of &lt;code&gt;run&lt;/code&gt; on &lt;code&gt;Screen&lt;/code&gt; in Listing 17-5, &lt;code&gt;run&lt;/code&gt; doesn&amp;rsquo;t need to know what the concrete type of each component is. It doesn&amp;rsquo;t check whether a component is an instance of a &lt;code&gt;Button&lt;/code&gt; or a &lt;code&gt;SelectBox&lt;/code&gt;, it just calls the &lt;code&gt;draw&lt;/code&gt; method on the component. By specifying &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt; as the type of the values in the &lt;code&gt;components&lt;/code&gt; vector, we&amp;rsquo;ve defined &lt;code&gt;Screen&lt;/code&gt; to need values that we can call the &lt;code&gt;draw&lt;/code&gt; method on.</source>
          <target state="translated">값의 구체적인 유형이 아니라 값이 응답하는 메시지에만 관심을 갖는이 개념은 동적 유형 언어 의 &lt;em&gt;오리 입력&lt;/em&gt; 개념과 유사합니다. &lt;em&gt;오리&lt;/em&gt; 처럼 걷고 오리처럼 꽥꽥 거리는 경우 오리! 의 구현에서 &lt;code&gt;run&lt;/code&gt; 에 &lt;code&gt;Screen&lt;/code&gt; 목록 17-5에서, &lt;code&gt;run&lt;/code&gt; 각 구성 요소의 구체적인 유형이 무엇인지 알 필요가 없습니다. 구성 요소가 &lt;code&gt;Button&lt;/code&gt; 또는 &lt;code&gt;SelectBox&lt;/code&gt; 의 인스턴스인지 확인하지 않고 구성 요소 에서 &lt;code&gt;draw&lt;/code&gt; 메서드를 호출합니다 . 지정하여 &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt; 의 값의 유형으로 &lt;code&gt;components&lt;/code&gt; 벡터, 우리가 정의한 &lt;code&gt;Screen&lt;/code&gt; &lt;code&gt;draw&lt;/code&gt; 메서드를 호출 할 수있는 값이 필요한 화면 입니다.</target>
        </trans-unit>
        <trans-unit id="918897f830b93edc22b990902ff69a6fc36b08cc" translate="yes" xml:space="preserve">
          <source>This conditional structure lets us support complex requirements. With the hardcoded values we have here, this example will print &lt;code&gt;Using purple as the background color&lt;/code&gt;.</source>
          <target state="translated">이 조건부 구조를 통해 복잡한 요구 사항을 지원할 수 있습니다. 여기에 하드 코딩 된 값을 &lt;code&gt;Using purple as the background color&lt;/code&gt; 이 예제는 자주색을 배경색으로 사용하여 인쇄 합니다 .</target>
        </trans-unit>
        <trans-unit id="3dcd38b0035fd15b13996ae1be8e3f24e8144a2a" translate="yes" xml:space="preserve">
          <source>This constant is defined to be &quot;1970-01-01 00:00:00 UTC&quot; on all systems with respect to the system clock. Using &lt;code&gt;duration_since&lt;/code&gt; on an existing &lt;a href=&quot;struct.systemtime&quot;&gt;&lt;code&gt;SystemTime&lt;/code&gt;&lt;/a&gt; instance can tell how far away from this point in time a measurement lies, and using &lt;code&gt;UNIX_EPOCH + duration&lt;/code&gt; can be used to create a &lt;a href=&quot;struct.systemtime&quot;&gt;&lt;code&gt;SystemTime&lt;/code&gt;&lt;/a&gt; instance to represent another fixed point in time.</source>
          <target state="translated">이 상수는 시스템 시계와 관련하여 모든 시스템에서 &quot;1970-01-01 00:00:00 UTC&quot;로 정의됩니다. 기존 &lt;a href=&quot;struct.systemtime&quot;&gt; &lt;code&gt;SystemTime&lt;/code&gt; &lt;/a&gt; 인스턴스 에서 &lt;code&gt;duration_since&lt;/code&gt; 를 사용하면 이 시점에서 얼마나 멀리 떨어져 있는지 알 수 있으며 &lt;code&gt;UNIX_EPOCH + duration&lt;/code&gt; 을 사용하여 다른 고정 된 특정 시점을 나타내는 &lt;a href=&quot;struct.systemtime&quot;&gt; &lt;code&gt;SystemTime&lt;/code&gt; &lt;/a&gt; 인스턴스를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5d0e066df6c05d48b8ed4d894544fa1aeed7cdf" translate="yes" xml:space="preserve">
          <source>This constant is defined to be &quot;1970-01-01 00:00:00 UTC&quot; on all systems with respect to the system clock. Using &lt;code&gt;duration_since&lt;/code&gt; on an existing &lt;code&gt;SystemTime&lt;/code&gt; instance can tell how far away from this point in time a measurement lies, and using &lt;code&gt;UNIX_EPOCH + duration&lt;/code&gt; can be used to create a &lt;code&gt;SystemTime&lt;/code&gt; instance to represent another fixed point in time.</source>
          <target state="translated">이 상수는 시스템 시계와 관련하여 모든 시스템에서 &quot;1970-01-01 00:00:00 UTC&quot;로 정의됩니다. 기존 &lt;code&gt;SystemTime&lt;/code&gt; 인스턴스 에서 &lt;code&gt;duration_since&lt;/code&gt; 를 사용하면 이 시점에서 얼마나 멀리 떨어져 있는지 알 수 있으며 &lt;code&gt;UNIX_EPOCH + duration&lt;/code&gt; 을 사용하여 다른 고정 된 특정 시점을 나타내는 &lt;code&gt;SystemTime&lt;/code&gt; 인스턴스를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2173ef48f94c265cfdd9db0c9cedd205cdc4005" translate="yes" xml:space="preserve">
          <source>This construct eliminates a lot of nesting that would be necessary if you used &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, and &lt;code&gt;break&lt;/code&gt;, and it&amp;rsquo;s clearer. While a condition holds true, the code runs; otherwise, it exits the loop.</source>
          <target state="translated">이 구문은 &lt;code&gt;loop&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;break&lt;/code&gt; 를 사용했을 때 필요한 많은 중첩을 제거하며 더 명확합니다. 조건이 충족되는 동안 코드가 실행됩니다. 그렇지 않으면 루프를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="0f3921b041a98aaf2f8084439e4ed88136086a63" translate="yes" xml:space="preserve">
          <source>This construct is allowed because the first &lt;code&gt;spaces&lt;/code&gt; variable is a string type and the second &lt;code&gt;spaces&lt;/code&gt; variable, which is a brand-new variable that happens to have the same name as the first one, is a number type. Shadowing thus spares us from having to come up with different names, such as &lt;code&gt;spaces_str&lt;/code&gt; and &lt;code&gt;spaces_num&lt;/code&gt;; instead, we can reuse the simpler &lt;code&gt;spaces&lt;/code&gt; name. However, if we try to use &lt;code&gt;mut&lt;/code&gt; for this, as shown here, we&amp;rsquo;ll get a compile-time error:</source>
          <target state="translated">제 때문에 구조가 허용되는 &lt;code&gt;spaces&lt;/code&gt; 변수 문자열 유형 및 두 번째 &lt;code&gt;spaces&lt;/code&gt; 처음과 동일한 이름이 우연히 아주 새로운 변수 변수는 숫자 형이다. 따라서 섀도 잉은 &lt;code&gt;spaces_str&lt;/code&gt; 및 &lt;code&gt;spaces_num&lt;/code&gt; 과 같은 다른 이름을 사용 하지 않아도됩니다 . 대신 간단한 &lt;code&gt;spaces&lt;/code&gt; 이름을 재사용 할 수 있습니다 . 그러나 여기에 표시된 것처럼 &lt;code&gt;mut&lt;/code&gt; 를 사용하려고 하면 컴파일 타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2fc6477635d5d363ee444b003b473b1635177727" translate="yes" xml:space="preserve">
          <source>This constructor is unsafe because we cannot guarantee that the data pointed to by &lt;code&gt;pointer&lt;/code&gt; is pinned, meaning that the data will not be moved or its storage invalidated until it gets dropped. If the constructed &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; does not guarantee that the data &lt;code&gt;P&lt;/code&gt; points to is pinned, that is a violation of the API contract and may lead to undefined behavior in later (safe) operations.</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; 가 가리키는 데이터 가 고정 되었음을 보장 할 수 없으므로이 생성자는 안전하지 않습니다. 즉, 데이터 가 삭제 될 때까지 데이터가 이동되지 않거나 스토리지가 무효화됩니다. 생성 된 &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; 가 데이터 &lt;code&gt;P&lt;/code&gt; 가 가리키는 것을 보장하지 않으면 이는 API 계약을 위반하는 것이며 이후 (안전한) 작업에서 정의되지 않은 동작으로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff43397602787e15a0f1ce39d92c367ec0e4e2ba" translate="yes" xml:space="preserve">
          <source>This constructor will panic if &lt;code&gt;secs&lt;/code&gt; is not finite, negative or overflows &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;secs&lt;/code&gt; 가 유한, 음수 또는 오버플로 &lt;code&gt;Duration&lt;/code&gt; 이 아닌 경우이 생성자는 패닉 상태가됩니다 .</target>
        </trans-unit>
        <trans-unit id="62c6e72ea916575b1c7e9925b7cd6a1ec78f970b" translate="yes" xml:space="preserve">
          <source>This constructor will panic if the carry from the nanoseconds overflows the seconds counter.</source>
          <target state="translated">이 생성자는 나노초의 캐리가 초 카운터를 초과하면 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="6b22e102a899811cfc691dccd223a5bfd8615f73" translate="yes" xml:space="preserve">
          <source>This consumes the &lt;code&gt;String&lt;/code&gt; on the left-hand side and re-uses its buffer (growing it if necessary). This is done to avoid allocating a new &lt;code&gt;String&lt;/code&gt; and copying the entire contents on every operation, which would lead to &lt;code&gt;O(n^2)&lt;/code&gt; running time when building an &lt;code&gt;n&lt;/code&gt;-byte string by repeated concatenation.</source>
          <target state="translated">이것은 왼쪽 에서 &lt;code&gt;String&lt;/code&gt; 을 소비 하고 버퍼를 재사용합니다 (필요한 경우 커짐). 이것은 새로운 &lt;code&gt;String&lt;/code&gt; 할당하고 모든 작업에서 전체 내용을 복사하는 것을 피하기 위해 수행되며 , 반복 연결로 &lt;code&gt;n&lt;/code&gt; 바이트 문자열을 작성할 때 &lt;code&gt;O(n^2)&lt;/code&gt; 실행 시간 으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="ff15f14738d56f849296682dc30e5c72af4309e0" translate="yes" xml:space="preserve">
          <source>This consumes the &lt;code&gt;String&lt;/code&gt; on the left-hand side and re-uses its buffer (growing it if necessary). This is done to avoid allocating a new &lt;code&gt;String&lt;/code&gt; and copying the entire contents on every operation, which would lead to &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;^2) running time when building an &lt;em&gt;n&lt;/em&gt;-byte string by repeated concatenation.</source>
          <target state="translated">이것은 왼쪽 의 &lt;code&gt;String&lt;/code&gt; 을 소비 하고 버퍼를 재사용합니다 (필요한 경우 확장). 이는 새 &lt;code&gt;String&lt;/code&gt; 할당하고 모든 작업에서 전체 내용을 복사하는 것을 방지하기 위해 수행되며 , 반복 된 연결로 &lt;em&gt;n&lt;/em&gt; 바이트 문자열을 빌드 할 때 실행 시간 이 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; ^ 2)가됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9c1a59da820eab802e08d64caefd05fd88b5910a" translate="yes" xml:space="preserve">
          <source>This consumes the &lt;code&gt;String&lt;/code&gt;, so we do not need to copy its contents.</source>
          <target state="translated">이것은 &lt;code&gt;String&lt;/code&gt; 을 소비 하므로 내용을 복사 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bdf3d0a305b0dd41c0720025809f7bbdfc2e29a7" translate="yes" xml:space="preserve">
          <source>This conversion allocates a new error with a simple representation of error kind.</source>
          <target state="translated">이 변환은 간단한 오류 종류 표현으로 새 오류를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="680616b748f55e8f2a3a0b7bc442fa697101f3ab" translate="yes" xml:space="preserve">
          <source>This conversion allocates on the heap and performs a copy of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">이 변환은 힙에 할당하고 &lt;code&gt;s&lt;/code&gt; 사본을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="9a31c836c91541651df449cd7fae82a0fb324fe3" translate="yes" xml:space="preserve">
          <source>This conversion allocates on the heap and performs a copy of &lt;code&gt;slice&lt;/code&gt;.</source>
          <target state="translated">이 변환은 힙에 할당하고 &lt;code&gt;slice&lt;/code&gt; 사본을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="9fa8116281488d60de9f3c4d7eaa019ecce22d9b" translate="yes" xml:space="preserve">
          <source>This conversion always returns &lt;code&gt;RecvTimeoutError::Disconnected&lt;/code&gt;.</source>
          <target state="translated">이 변환은 항상 &lt;code&gt;RecvTimeoutError::Disconnected&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a1ed0a334eeab7a53114c9e9ec5ed0ef897b2581" translate="yes" xml:space="preserve">
          <source>This conversion always returns &lt;code&gt;TryRecvError::Disconnected&lt;/code&gt;.</source>
          <target state="translated">이 변환은 항상 &lt;code&gt;TryRecvError::Disconnected&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="82865c3f0e8956130ac1b56ac62e2b0276fe13c6" translate="yes" xml:space="preserve">
          <source>This conversion always returns a &lt;code&gt;TrySendError::Disconnected&lt;/code&gt; containing the data in the &lt;code&gt;SendError&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 변환은 항상 &lt;code&gt;SendError&amp;lt;T&amp;gt;&lt;/code&gt; 의 데이터를 포함 하는 &lt;code&gt;TrySendError::Disconnected&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="191fbbeba587abac9c4a996c422eb2e1a86f8da6" translate="yes" xml:space="preserve">
          <source>This conversion creates a &lt;a href=&quot;../net/enum.socketaddr#variant.V4&quot;&gt;&lt;code&gt;SocketAddr::V4&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;../net/enum.ipaddr#variant.V4&quot;&gt;&lt;code&gt;IpAddr::V4&lt;/code&gt;&lt;/a&gt; and creates a &lt;a href=&quot;../net/enum.socketaddr#variant.V6&quot;&gt;&lt;code&gt;SocketAddr::V6&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;../net/enum.ipaddr#variant.V6&quot;&gt;&lt;code&gt;IpAddr::V6&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 변환은 &lt;a href=&quot;../net/enum.ipaddr#variant.V4&quot;&gt; &lt;code&gt;IpAddr::V4&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../net/enum.socketaddr#variant.V4&quot;&gt; &lt;code&gt;SocketAddr::V4&lt;/code&gt; &lt;/a&gt; 대해 SocketAddr :: V4 를 작성 하고 &lt;a href=&quot;../net/enum.ipaddr#variant.V6&quot;&gt; &lt;code&gt;IpAddr::V6&lt;/code&gt; &lt;/a&gt; 대해 &lt;a href=&quot;../net/enum.socketaddr#variant.V6&quot;&gt; &lt;code&gt;SocketAddr::V6&lt;/code&gt; &lt;/a&gt; 을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="e3e202dba3c3f87c15f9baf72668c6b89f20fb13" translate="yes" xml:space="preserve">
          <source>This conversion creates a &lt;a href=&quot;enum.socketaddr#variant.V4&quot;&gt;&lt;code&gt;SocketAddr::V4&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;enum.ipaddr#variant.V4&quot;&gt;&lt;code&gt;IpAddr::V4&lt;/code&gt;&lt;/a&gt; and creates a &lt;a href=&quot;enum.socketaddr#variant.V6&quot;&gt;&lt;code&gt;SocketAddr::V6&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;enum.ipaddr#variant.V6&quot;&gt;&lt;code&gt;IpAddr::V6&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 변환은 &lt;a href=&quot;enum.ipaddr#variant.V4&quot;&gt; &lt;code&gt;IpAddr::V4&lt;/code&gt; &lt;/a&gt; 대한 &lt;a href=&quot;enum.socketaddr#variant.V4&quot;&gt; &lt;code&gt;SocketAddr::V4&lt;/code&gt; &lt;/a&gt; 를 작성하고 &lt;a href=&quot;enum.socketaddr#variant.V6&quot;&gt; &lt;code&gt;SocketAddr::V6&lt;/code&gt; &lt;/a&gt; 작성합니다. 하고 &lt;a href=&quot;enum.ipaddr#variant.V6&quot;&gt; &lt;code&gt;IpAddr::V6&lt;/code&gt; &lt;/a&gt; 대해 을 .</target>
        </trans-unit>
        <trans-unit id="3b1a65936a10e1c346d064991eab656396fb2bba" translate="yes" xml:space="preserve">
          <source>This conversion currently should not allocate memory, but this behavior is not guaranteed on all platforms or in all future versions.</source>
          <target state="translated">이 변환은 현재 메모리를 할당하지 않아야하지만이 동작이 모든 플랫폼 또는 모든 향후 버전에서 보장되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e7f2cebd3b32b1fc620100acfba14583ac5721f8" translate="yes" xml:space="preserve">
          <source>This conversion does not allocate on the heap and happens in place.</source>
          <target state="translated">이 변환은 힙에 할당되지 않으며 제자리에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ece3abafa7c5e7855afc6b2c712b92113a0c3cfa" translate="yes" xml:space="preserve">
          <source>This conversion does not allocate or copy memory.</source>
          <target state="translated">이 변환은 메모리를 할당하거나 복사하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bfaed574bc93990621932481bdc991a5d31277ba" translate="yes" xml:space="preserve">
          <source>This conversion happens in-place, and has &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) time complexity.</source>
          <target state="translated">이 변환은 제자리에서 발생하며 &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; ) 시간 복잡도를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="eb0a6b0407963e31db76813c54686486ddeb6e67" translate="yes" xml:space="preserve">
          <source>This conversion may entail doing a check for UTF-8 validity.</source>
          <target state="translated">이 변환에는 UTF-8 유효성 검사가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fd6ab28cb16ba2dd2d81ceb7549687e9cec1f65" translate="yes" xml:space="preserve">
          <source>This conversion may entail doing a check for UTF-8 validity. Note that validation is performed because non-UTF-8 strings are perfectly valid for some OS.</source>
          <target state="translated">이 변환에는 UTF-8 유효성 검사가 필요할 수 있습니다. 비 UTF-8 문자열은 일부 OS에서 완벽하게 유효하기 때문에 유효성 검사가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8330bc0df78d6eb52dcc8484b74d30aa78ea3703" translate="yes" xml:space="preserve">
          <source>This conversion moves the array to newly heap-allocated memory.</source>
          <target state="translated">이 변환은 배열을 새로 힙 할당 메모리로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="0d8209ee4e143c8cb222975b9c2887b40d4af1c6" translate="yes" xml:space="preserve">
          <source>This conversion requires no data movement or allocation, and has constant time complexity.</source>
          <target state="translated">이 변환에는 데이터 이동이나 할당이 필요하지 않으며 일정한 시간 복잡성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2f146b8b2fc9fbff68e3aacb1296a0b784db40b" translate="yes" xml:space="preserve">
          <source>This converts the weak pointer into a raw pointer, preserving the original weak count. It can be turned back into the &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; with &lt;a href=&quot;struct.weak#method.from_raw&quot;&gt;&lt;code&gt;from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 약한 포인터를 원래의 약한 수를 유지하면서 원시 포인터로 변환합니다. 그것은 다시 설정할 수 있습니다 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 와 &lt;a href=&quot;struct.weak#method.from_raw&quot;&gt; &lt;code&gt;from_raw&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="068161e531a8b3af305ba6f7bb36fd2b7ca30a9c" translate="yes" xml:space="preserve">
          <source>This converts the weak pointer into a raw pointer, while still preserving the ownership of one weak reference (the weak count is not modified by this operation). It can be turned back into the &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; with &lt;a href=&quot;struct.weak#method.from_raw&quot;&gt;&lt;code&gt;from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이는 약한 포인터를 원시 포인터로 변환하는 동시에 하나의 약한 참조의 소유권을 유지합니다 (약한 수는이 작업에 의해 수정되지 않음). &lt;a href=&quot;struct.weak#method.from_raw&quot;&gt; &lt;code&gt;from_raw&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 로 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c699db8a5191d953bd2f9a766d34a17f9fc7bd1" translate="yes" xml:space="preserve">
          <source>This corresponds to the type returned from a generator either with a &lt;code&gt;return&lt;/code&gt; statement or implicitly as the last expression of a generator literal. For example futures would use this as &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; as it represents a completed future.</source>
          <target state="translated">이는 &lt;code&gt;return&lt;/code&gt; 문을 사용하거나 암시 적으로 생성기 리터럴의 마지막 표현식으로 생성기에서 반환 된 유형에 해당합니다 . 예를 들어 선물은 완료된 미래를 나타내므로이를 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4049b3c18034165d976b921c99656187a99b1c48" translate="yes" xml:space="preserve">
          <source>This could be called as &lt;code&gt;&amp;lt;Foo as Foo&amp;gt;::foo()&lt;/code&gt;, which would not be able to pick an implementation.</source>
          <target state="translated">이를 &lt;code&gt;&amp;lt;Foo as Foo&amp;gt;::foo()&lt;/code&gt; 호출 하면 구현을 선택할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="287539a4f23b39a26818b82e9ae17d404cfd326d" translate="yes" xml:space="preserve">
          <source>This could be caused by a typo. Did you misspell the macro's name?</source>
          <target state="translated">오타가 원인 일 수 있습니다. 매크로 이름의 철자가 틀렸습니까?</target>
        </trans-unit>
        <trans-unit id="13b235947bdbb45d737ce6790102efc941982f83" translate="yes" xml:space="preserve">
          <source>This crate primarily contains a &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; type. Procedural macros operate over &lt;em&gt;token streams&lt;/em&gt; instead of AST nodes, which is a far more stable interface over time for both the compiler and for procedural macros to target. A &lt;em&gt;token stream&lt;/em&gt; is roughly equivalent to &lt;code&gt;Vec&amp;lt;TokenTree&amp;gt;&lt;/code&gt; where a &lt;code&gt;TokenTree&lt;/code&gt; can roughly be thought of as lexical token. For example &lt;code&gt;foo&lt;/code&gt; is an &lt;code&gt;Ident&lt;/code&gt; token, &lt;code&gt;.&lt;/code&gt; is a &lt;code&gt;Punct&lt;/code&gt; token, and &lt;code&gt;1.2&lt;/code&gt; is a &lt;code&gt;Literal&lt;/code&gt; token. The &lt;code&gt;TokenStream&lt;/code&gt; type, unlike &lt;code&gt;Vec&amp;lt;TokenTree&amp;gt;&lt;/code&gt;, is cheap to clone.</source>
          <target state="translated">이 상자에는 주로 &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt; 유형이 포함됩니다. 절차 적 매크로는 AST 노드 대신 &lt;em&gt;토큰 스트림을&lt;/em&gt; 통해 작동합니다 . 이는 컴파일러와 절차 적 매크로가 대상으로하는 시간이 지남에 따라 훨씬 안정적인 인터페이스입니다. &lt;em&gt;토큰 스트림은&lt;/em&gt; 대략 동등 &lt;code&gt;Vec&amp;lt;TokenTree&amp;gt;&lt;/code&gt; &lt;code&gt;TokenTree&lt;/code&gt; 가 대략 어휘 토큰으로 간주 될 수있다. 예를 들어 &lt;code&gt;foo&lt;/code&gt; 는 &lt;code&gt;Ident&lt;/code&gt; 토큰 &lt;code&gt;.&lt;/code&gt; A는 &lt;code&gt;Punct&lt;/code&gt; 토큰 및 &lt;code&gt;1.2&lt;/code&gt; A는 &lt;code&gt;Literal&lt;/code&gt; 토큰. &lt;code&gt;TokenStream&lt;/code&gt; 의 유형은, 달리 &lt;code&gt;Vec&amp;lt;TokenTree&amp;gt;&lt;/code&gt; , 복제에 도착하는 저렴한이다.</target>
        </trans-unit>
        <trans-unit id="5fc5d0b91b345a05b4241830102cb300bf80ef47" translate="yes" xml:space="preserve">
          <source>This creates another pointer to the same allocation, increasing the strong reference count.</source>
          <target state="translated">이것은 동일한 할당에 대한 또 다른 포인터를 생성하여 강력한 참조 횟수를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="cff1a339d3f6091f32453655f9ee1f32c7930920" translate="yes" xml:space="preserve">
          <source>This creates another pointer to the same inner value, increasing the strong reference count.</source>
          <target state="translated">이렇게하면 동일한 내부 값에 대한 다른 포인터가 만들어져 강력한 참조 횟수가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="c793b99248db7ed16f6d7097d8baba33c4688bf2" translate="yes" xml:space="preserve">
          <source>This defines a trait with two methods. All values that have &lt;a href=&quot;implementations&quot;&gt;implementations&lt;/a&gt; of this trait while the trait is in scope can have their &lt;code&gt;draw&lt;/code&gt; and &lt;code&gt;bounding_box&lt;/code&gt; methods called.</source>
          <target state="translated">이것은 두 가지 방법으로 특성을 정의합니다. 특성이 범위 내에있는 동안이 특성을 &lt;a href=&quot;implementations&quot;&gt;구현&lt;/a&gt; 하는 모든 값은 &lt;code&gt;draw&lt;/code&gt; 및 &lt;code&gt;bounding_box&lt;/code&gt; 메소드를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d48ec195193e5a8a6ddc6d7306e5931fc440ce0" translate="yes" xml:space="preserve">
          <source>This definition is similar to the custom derive macro&amp;rsquo;s signature: we receive the tokens that are inside the parentheses and return the code we wanted to generate.</source>
          <target state="translated">이 정의는 사용자 지정 파생 매크로의 서명과 유사합니다. 괄호 안에있는 토큰을 받고 생성하려는 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7ec7ae52304bec8c18c92988cc904eba30640fe1" translate="yes" xml:space="preserve">
          <source>This definition should now make more sense to you. As you can see, &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is an enum that is generic over type &lt;code&gt;T&lt;/code&gt; and has two variants: &lt;code&gt;Some&lt;/code&gt;, which holds one value of type &lt;code&gt;T&lt;/code&gt;, and a &lt;code&gt;None&lt;/code&gt; variant that doesn&amp;rsquo;t hold any value. By using the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum, we can express the abstract concept of having an optional value, and because &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is generic, we can use this abstraction no matter what the type of the optional value is.</source>
          <target state="translated">이 정의는 이제 더 의미가 있습니다. 당신이 볼 수 있듯이, &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 종류 이상의 제네릭 열거입니다 &lt;code&gt;T&lt;/code&gt; : 두 개의 변종이 &lt;code&gt;Some&lt;/code&gt; 한 종류의 값 보유 &lt;code&gt;T&lt;/code&gt; 및 &lt;code&gt;None&lt;/code&gt; 모든 값을 유지하지 않는 변형을. 사용하여 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 열거, 우리는 옵션 값을 가지고있는 추상적 인 개념을 표현할 수 있고, 때문에 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 일반, 우리는이 추상화는 어떤 옵션 값의 유형이 무엇인지는 중요 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a1dc77bf501a21c3fcf8fcfdb984f36618d4b9d8" translate="yes" xml:space="preserve">
          <source>This demonstrates that we&amp;rsquo;re now using standard output for successful output and standard error for error output as appropriate.</source>
          <target state="translated">이는 이제 성공적인 출력을 위해 표준 출력을 사용하고 오류 출력을 위해 표준 오류를 적절하게 사용하고 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5155c706e717eca62f9640a389101247c0cf2c80" translate="yes" xml:space="preserve">
          <source>This destructor consists of two components:</source>
          <target state="translated">이 소멸자는 두 가지 구성 요소로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="0501267bf2be740a305fdf189b227a4c7486d27e" translate="yes" xml:space="preserve">
          <source>This distinction would also exist in an interpreter. Static checks like syntactic analysis, type checking, and lints should happen before the program is executed regardless of when it is executed.</source>
          <target state="translated">이 차이는 통역사에도 존재합니다. 구문 분석, 유형 검사 및 보푸라기와 같은 정적 검사는 프로그램 실행시기에 관계없이 프로그램이 실행되기 전에 수행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f074ad4712bf36f567466c2e78802eda538edf52" translate="yes" xml:space="preserve">
          <source>This documentation describes a number of methods and trait implementations on the &lt;code&gt;char&lt;/code&gt; type. For technical reasons, there is additional, separate documentation in &lt;a href=&quot;char/index&quot;&gt;the &lt;code&gt;std::char&lt;/code&gt; module&lt;/a&gt; as well.</source>
          <target state="translated">이 문서는 &lt;code&gt;char&lt;/code&gt; 유형 에 대한 여러 가지 메소드 및 특성 구현에 대해 설명합니다 . 기술적 인 이유로 &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;std::char&lt;/code&gt; &lt;/a&gt; 모듈 에는 별도의 추가 설명서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="68839ac29f4116303cf30db2371868d96097990a" translate="yes" xml:space="preserve">
          <source>This does call the argument's implementation of &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 인수의 &lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt; 구현을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e9a625eacba45783e02d255cb539fbdd648ae63a" translate="yes" xml:space="preserve">
          <source>This does not include the path to the program as the first argument; it only includes the arguments specified with &lt;a href=&quot;struct.command#method.arg&quot;&gt;&lt;code&gt;Command::arg&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.command#method.args&quot;&gt;&lt;code&gt;Command::args&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">여기에는 첫 번째 인수로 프로그램 경로가 포함되지 않습니다. &lt;a href=&quot;struct.command#method.arg&quot;&gt; &lt;code&gt;Command::arg&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.command#method.args&quot;&gt; &lt;code&gt;Command::args&lt;/code&gt; &lt;/a&gt; 지정된 인수 만 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="46fdf1d9a29edff79b3169310e8e3c74c04e6cd6" translate="yes" xml:space="preserve">
          <source>This does not preserve ordering, but is &lt;em&gt;O&lt;/em&gt;(1).</source>
          <target state="translated">이것은 순서를 유지하지 않지만 &lt;em&gt;O&lt;/em&gt; (1)입니다.</target>
        </trans-unit>
        <trans-unit id="cc3143ca0c8ed5c4ad51a7f5632b38d278a744be" translate="yes" xml:space="preserve">
          <source>This does not preserve ordering, but is O(1).</source>
          <target state="translated">이것은 순서를 유지하지 않지만 O (1)입니다.</target>
        </trans-unit>
        <trans-unit id="302cbd1c584e8c39bda1206e23be2bed7460cc52" translate="yes" xml:space="preserve">
          <source>This does not take ownership of the original allocation and requires no resource management later, but you must not use the pointer after its lifetime.</source>
          <target state="translated">이것은 원래 할당의 소유권을 가지지 않으며 나중에 리소스 관리가 필요하지 않지만 수명이 지난 후에는 포인터를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="601f0aa53280d7fb3fab96e73d4cc042d197513d" translate="yes" xml:space="preserve">
          <source>This does so by calling the argument's implementation of &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수의 &lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt; 구현을 호출하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="7ec03adb1087f5abb7a8507c877e74407679b28c" translate="yes" xml:space="preserve">
          <source>This doesn't actually allocate if &lt;code&gt;T&lt;/code&gt; is zero-sized.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 크기가 0 인 경우 실제로 할당되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1a27813265527dd550d73a565f67475ec4a26516" translate="yes" xml:space="preserve">
          <source>This effectively does nothing for types which implement &lt;code&gt;Copy&lt;/code&gt;, e.g. integers. Such values are copied and &lt;em&gt;then&lt;/em&gt; moved into the function, so the value persists after this function call.</source>
          <target state="translated">이것은 정수를 포함하여 &lt;code&gt;Copy&lt;/code&gt; 를 구현하는 유형에 대해서는 아무런 효과가 없습니다 . 이러한 값은 복사 된 &lt;em&gt;후&lt;/em&gt; 함수로 이동되므로이 함수 호출 후에도 값이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="eb1f652575dd2244737e0203d7e6859c386e1f92" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroI128&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;i128&lt;/code&gt;:</source>
          <target state="translated">이것은 일부 메모리 레이아웃 최적화를 가능하게합니다. 예를 들어 &lt;code&gt;Option&amp;lt;NonZeroI128&amp;gt;&lt;/code&gt; 은 i128 과 크기가 &lt;code&gt;i128&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f67f6cc0c2c10dc19997b3839443098a644f1d26" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroI16&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;i16&lt;/code&gt;:</source>
          <target state="translated">이것은 일부 메모리 레이아웃 최적화를 가능하게합니다. 예를 들어, &lt;code&gt;Option&amp;lt;NonZeroI16&amp;gt;&lt;/code&gt; 은 i16 과 크기가 &lt;code&gt;i16&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="734061adf87b0795fad2886322ea47c0aec2f2ad" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroI32&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;i32&lt;/code&gt;:</source>
          <target state="translated">이것은 일부 메모리 레이아웃 최적화를 가능하게합니다. 예를 들어 &lt;code&gt;Option&amp;lt;NonZeroI32&amp;gt;&lt;/code&gt; 는 &lt;code&gt;i32&lt;/code&gt; 와 크기가 같습니다.</target>
        </trans-unit>
        <trans-unit id="00340c6c435ce7c1fdb4cf194be81cf07905d3dd" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroI64&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;i64&lt;/code&gt;:</source>
          <target state="translated">이것은 일부 메모리 레이아웃 최적화를 가능하게합니다. 예를 들어, &lt;code&gt;Option&amp;lt;NonZeroI64&amp;gt;&lt;/code&gt; 는 i64 와 크기가 &lt;code&gt;i64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="278e3b6e04cd3eac83950c68db7f2e8e510eb775" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroI8&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;i8&lt;/code&gt;:</source>
          <target state="translated">이것은 일부 메모리 레이아웃 최적화를 가능하게합니다. 예를 들어, &lt;code&gt;Option&amp;lt;NonZeroI8&amp;gt;&lt;/code&gt; 은 &lt;code&gt;i8&lt;/code&gt; 과 크기가 같습니다.</target>
        </trans-unit>
        <trans-unit id="d6a41567af1e9968e9c90e92ec21b8804316cfe8" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroIsize&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;isize&lt;/code&gt;:</source>
          <target state="translated">이것은 일부 메모리 레이아웃 최적화를 가능하게합니다. 예를 들어, &lt;code&gt;Option&amp;lt;NonZeroIsize&amp;gt;&lt;/code&gt; 는 isize 와 크기가 &lt;code&gt;isize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf2e6ed40009c7af3e4c82c9a64e0f2f0797bce2" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU128&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u128&lt;/code&gt;:</source>
          <target state="translated">이것은 일부 메모리 레이아웃 최적화를 가능하게합니다. 예를 들어, &lt;code&gt;Option&amp;lt;NonZeroU128&amp;gt;&lt;/code&gt; 은 u128 과 크기가 &lt;code&gt;u128&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76da8b2ba60cec40f8f5e62e107f1dbcb755bbbb" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU16&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u16&lt;/code&gt;:</source>
          <target state="translated">이것은 일부 메모리 레이아웃 최적화를 가능하게합니다. 예를 들어, &lt;code&gt;Option&amp;lt;NonZeroU16&amp;gt;&lt;/code&gt; 은 u16 과 크기가 &lt;code&gt;u16&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccbf5b5bf97bc9198c28f18b82543d27c5b27285" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU32&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u32&lt;/code&gt;:</source>
          <target state="translated">이것은 일부 메모리 레이아웃 최적화를 가능하게합니다. 예를 들어, &lt;code&gt;Option&amp;lt;NonZeroU32&amp;gt;&lt;/code&gt; 는 &lt;code&gt;u32&lt;/code&gt; 와 크기가 같습니다.</target>
        </trans-unit>
        <trans-unit id="538d2876995cecf5e64928ddfeb01ab1a800bbde" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU64&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u64&lt;/code&gt;:</source>
          <target state="translated">이것은 일부 메모리 레이아웃 최적화를 가능하게합니다. 예를 들어, &lt;code&gt;Option&amp;lt;NonZeroU64&amp;gt;&lt;/code&gt; 는 u64 와 크기가 &lt;code&gt;u64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0129491a9c802e31402a256b2ed3248526999bd" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU8&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u8&lt;/code&gt;:</source>
          <target state="translated">이것은 일부 메모리 레이아웃 최적화를 가능하게합니다. 예를 들어, &lt;code&gt;Option&amp;lt;NonZeroU8&amp;gt;&lt;/code&gt; 은 &lt;code&gt;u8&lt;/code&gt; 과 크기가 같습니다.</target>
        </trans-unit>
        <trans-unit id="444ef8a1b6149aa40edb45ac918d2fcc6dd0e6a5" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroUsize&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;usize&lt;/code&gt;:</source>
          <target state="translated">이것은 일부 메모리 레이아웃 최적화를 가능하게합니다. 예를 들어 &lt;code&gt;Option&amp;lt;NonZeroUsize&amp;gt;&lt;/code&gt; 는 usize 와 크기가 &lt;code&gt;usize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05b9c29faea2a683215e0b23ceda6c29cb84253c" translate="yes" xml:space="preserve">
          <source>This enum can contain either an &lt;a href=&quot;struct.ipv4addr&quot;&gt;&lt;code&gt;Ipv4Addr&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;struct.ipv6addr&quot;&gt;&lt;code&gt;Ipv6Addr&lt;/code&gt;&lt;/a&gt;, see their respective documentation for more details.</source>
          <target state="translated">이 열거 형은 하나 포함 할 수 &lt;a href=&quot;struct.ipv4addr&quot;&gt; &lt;code&gt;Ipv4Addr&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.ipv6addr&quot;&gt; &lt;code&gt;Ipv6Addr&lt;/code&gt; 이&lt;/a&gt; , 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="760b8f1ec007bba813777fc9f56dd941c92b8841" translate="yes" xml:space="preserve">
          <source>This enum has four variants with different types:</source>
          <target state="translated">이 열거 형에는 유형이 다른 네 가지 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ced6caa3ad1703b55bcd5c2e59bf560b6691cb01" translate="yes" xml:space="preserve">
          <source>This enum has the same role as &lt;a href=&quot;../primitive.never&quot;&gt;the &lt;code&gt;!&lt;/code&gt; &amp;ldquo;never&amp;rdquo; type&lt;/a&gt;, which is unstable in this version of Rust. When &lt;code&gt;!&lt;/code&gt; is stabilized, we plan to make &lt;code&gt;Infallible&lt;/code&gt; a type alias to it:</source>
          <target state="translated">이 열거 형과 같은 역할이 &lt;a href=&quot;../primitive.never&quot;&gt;을 &lt;code&gt;!&lt;/code&gt; &lt;/a&gt;이 버전의 Rust에서는 불안정한 &quot;never&quot;type 입니다. 언제 &lt;code&gt;!&lt;/code&gt; &lt;code&gt;Infallible&lt;/code&gt; 을 유형 별명으로 만들 계획입니다 .</target>
        </trans-unit>
        <trans-unit id="6ee104c9c1676af30fcb1ff39c18e2ed9e455f59" translate="yes" xml:space="preserve">
          <source>This enum is returned from the &lt;code&gt;Generator::resume&lt;/code&gt; method and indicates the possible return values of a generator. Currently this corresponds to either a suspension point (&lt;code&gt;Yielded&lt;/code&gt;) or a termination point (&lt;code&gt;Complete&lt;/code&gt;).</source>
          <target state="translated">이 열거 형은 &lt;code&gt;Generator::resume&lt;/code&gt; 메소드 에서 리턴되며 생성기 의 가능한 리턴 값을 나타냅니다. 현재 이것은 일시 중단 지점 ( &lt;code&gt;Yielded&lt;/code&gt; ) 또는 종료 지점 ( &lt;code&gt;Complete&lt;/code&gt; )에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="1703fcf1fccea6643fefc20e49e4c80e84f95499" translate="yes" xml:space="preserve">
          <source>This enumeration is the list of possible errors that made &lt;a href=&quot;struct.receiver#method.recv_timeout&quot;&gt;&lt;code&gt;recv_timeout&lt;/code&gt;&lt;/a&gt; unable to return data when called. This can occur with both a &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 열거는 &lt;a href=&quot;struct.receiver#method.recv_timeout&quot;&gt; &lt;code&gt;recv_timeout&lt;/code&gt; 이&lt;/a&gt; 호출 될 때 데이터를 리턴 할 수 없게 만든 가능한 오류 목록입니다 . &lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt; 모두에서 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbe05c4f5a229c7e20d58b03f49460f0df3da02f" translate="yes" xml:space="preserve">
          <source>This enumeration is the list of the possible error outcomes for the &lt;a href=&quot;struct.syncsender#method.try_send&quot;&gt;&lt;code&gt;try_send&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 열거는 &lt;a href=&quot;struct.syncsender#method.try_send&quot;&gt; &lt;code&gt;try_send&lt;/code&gt; &lt;/a&gt; 메소드에 가능한 오류 결과 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="6dc63139830daa8f080f2bf636d153d6ed98ad21" translate="yes" xml:space="preserve">
          <source>This enumeration is the list of the possible reasons that &lt;a href=&quot;struct.receiver#method.try_recv&quot;&gt;&lt;code&gt;try_recv&lt;/code&gt;&lt;/a&gt; could not return data when called. This can occur with both a &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 열거는 &lt;a href=&quot;struct.receiver#method.try_recv&quot;&gt; &lt;code&gt;try_recv&lt;/code&gt; &lt;/a&gt; 가 호출 될 때 데이터를 리턴 할 수없는 가능한 이유의 목록입니다 . &lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt; 모두에서 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1093396faf4de8ad558d41dcf5187f56b3280a8" translate="yes" xml:space="preserve">
          <source>This error also frequently arises with iteration:</source>
          <target state="translated">이 오류는 반복과 함께 자주 발생합니다.</target>
        </trans-unit>
        <trans-unit id="94b9a993ad00befb67d90a954bbd93d2df863b1b" translate="yes" xml:space="preserve">
          <source>This error appears when the curly braces contain an identifier which doesn't match with any of the type parameters or the string &lt;code&gt;Self&lt;/code&gt;. This might happen if you misspelled a type parameter, or if you intended to use literal curly braces. If it is the latter, escape the curly braces with a second curly brace of the same type; e.g., a literal &lt;code&gt;{&lt;/code&gt; is &lt;code&gt;{{&lt;/code&gt;.</source>
          <target state="translated">이 오류는 중괄호에 형식 매개 변수 또는 문자열 &lt;code&gt;Self&lt;/code&gt; 와 일치하지 않는 식별자가 포함 된 경우에 나타납니다 . 유형 매개 변수의 철자가 틀리거나 리터럴 중괄호를 사용하려는 경우에 발생할 수 있습니다. 후자 인 경우 동일한 유형의 두 번째 중괄호를 사용하여 중괄호를 이스케이프 처리하십시오. 예를 들어 리터럴 &lt;code&gt;{&lt;/code&gt; 은 &lt;code&gt;{{&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="584182c12fbcdc7236283566d4fe892f8514a84a" translate="yes" xml:space="preserve">
          <source>This error appears when the curly braces do not contain an identifier. Please add one of the same name as a type parameter. If you intended to use literal braces, use &lt;code&gt;{{&lt;/code&gt; and &lt;code&gt;}}&lt;/code&gt; to escape them.</source>
          <target state="translated">중괄호에 식별자가없는 경우이 오류가 나타납니다. 유형 매개 변수와 동일한 이름 중 하나를 추가하십시오. 리터럴 괄호를 사용하려면 &lt;code&gt;{{&lt;/code&gt; 및 &lt;code&gt;}}&lt;/code&gt; 를 사용하여 괄호 를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="0250b09263b0cf211b3144438a4935e1e43d799a" translate="yes" xml:space="preserve">
          <source>This error can be fixed by changing &lt;code&gt;demo&lt;/code&gt; so that the destructor does not run while the string-data is borrowed; for example by taking &lt;code&gt;S&lt;/code&gt; by reference:</source>
          <target state="translated">문자열 데이터를 빌리는 동안 소멸자가 실행되지 않도록 &lt;code&gt;demo&lt;/code&gt; 를 변경 하여이 오류를 해결할 수 있습니다 . 예를 들어 &lt;code&gt;S&lt;/code&gt; 를 참조로 사용하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cf00137495add2df4af51c96509efb72f8de11bd" translate="yes" xml:space="preserve">
          <source>This error can be fixed by creating a reference to the fields of a struct, enum, or tuple using the &lt;code&gt;ref&lt;/code&gt; keyword:</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 키워드를 사용하여 구조체, 열거 형 또는 튜플의 필드에 대한 참조를 작성하면이 오류를 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0dff7bc132443224671e948d9ffe4c7e1624395f" translate="yes" xml:space="preserve">
          <source>This error can be fixed by fully reinitializing the structure in question:</source>
          <target state="translated">이 오류는 해당 구조를 완전히 다시 초기화하여 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c719c44866ac61477960cb8b276b7f76f8c6533" translate="yes" xml:space="preserve">
          <source>This error can be fixed by making the container mutable:</source>
          <target state="translated">이 오류는 컨테이너를 변경 가능하게 만들어 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="413b5d16e5f0759b900c5fe5dc8c6c4f80d50366" translate="yes" xml:space="preserve">
          <source>This error can be solved by adding type annotations that provide the missing information to the compiler. In this case, the solution is to use a concrete type:</source>
          <target state="translated">이 오류는 누락 된 정보를 컴파일러에 제공하는 유형 주석을 추가하여 해결할 수 있습니다. 이 경우 해결책은 구체적인 유형을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f0e10eb9c6b47c452a0e1f4fb8a082452a2d703" translate="yes" xml:space="preserve">
          <source>This error code indicates a mismatch between the lifetimes appearing in the function signature (i.e., the parameter types and the return type) and the data-flow found in the function body.</source>
          <target state="translated">이 오류 코드는 함수 시그니처 (예 : 매개 변수 유형 및 반환 유형)에 나타나는 수명과 함수 본문에있는 데이터 흐름이 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="21caa47590bc7c04cd88dfba7269f8c13368e7a3" translate="yes" xml:space="preserve">
          <source>This error generally appears when two items with the same name are imported into a module. Here, the &lt;code&gt;foo&lt;/code&gt; functions are imported and reexported from the &lt;code&gt;collider&lt;/code&gt; module and therefore, when we're using &lt;code&gt;collider::foo()&lt;/code&gt;, both functions collide.</source>
          <target state="translated">이 오류는 일반적으로 이름이 같은 두 항목을 모듈로 가져올 때 나타납니다. 여기서 &lt;code&gt;foo&lt;/code&gt; 함수는 &lt;code&gt;collider&lt;/code&gt; 모듈 에서 가져오고 다시 내보내 므로 &lt;code&gt;collider::foo()&lt;/code&gt; 하면 두 함수가 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="3dfae522bf711393bcf17e2c72e0d218bd40909c" translate="yes" xml:space="preserve">
          <source>This error indicates a type mismatch in closure arguments.</source>
          <target state="translated">이 오류는 클로저 인수의 유형 불일치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1f7e9e73655654d551ddbe67dfdca41396aade3d" translate="yes" xml:space="preserve">
          <source>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule concerns the use of type parameters in an implementation of a foreign trait (a trait defined in another crate), and states that type parameters must be &quot;covered&quot; by a local type.</source>
          <target state="translated">이 오류는 특성 구현에 대한 Rust의 고아 규칙 중 하나를 위반했음을 나타냅니다. 이 규칙은 외부 특성 (다른 크레이트에 정의 된 특성)의 구현에서 유형 매개 변수의 사용과 관련이 있으며 유형 매개 변수는 로컬 유형에 의해 &quot;덮여&quot;되어야한다고 명시합니다.</target>
        </trans-unit>
        <trans-unit id="5926fa6825473ce8b14051d29bff524913459d93" translate="yes" xml:space="preserve">
          <source>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule concerns the use of type parameters in an implementation of a foreign trait (a trait defined in another crate), and states that type parameters must be &quot;covered&quot; by a local type. To understand what this means, it is perhaps easiest to consider a few examples.</source>
          <target state="translated">이 오류는 특성 구현에 대한 Rust의 고아 규칙 중 하나를 위반했음을 나타냅니다. 이 규칙은 외래 특성 (다른 상자에 정의 된 특성)을 구현할 때 형식 매개 변수를 사용하는 것과 관련이 있으며 형식 매개 변수는 로컬 형식으로 &quot;덮어야&quot;합니다. 이것이 의미하는 바를 이해하려면 몇 가지 예를 고려하는 것이 가장 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="62c66f8f6d53d3993670c86c1f09308676282e5b" translate="yes" xml:space="preserve">
          <source>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule prohibits any implementation of a foreign trait (a trait defined in another crate) where</source>
          <target state="translated">이 오류는 특성 구현에 대한 Rust의 고아 규칙 중 하나를 위반했음을 나타냅니다. 이 규칙은 외국 특성 (다른 상자에 정의 된 특성)의 구현을 금지합니다.</target>
        </trans-unit>
        <trans-unit id="447a5e9fa4c8cf25c5cd5302f4311b3fbd33ec5e" translate="yes" xml:space="preserve">
          <source>This error indicates that a &lt;code&gt;#[lang = &quot;..&quot;]&lt;/code&gt; attribute was placed on the wrong type of item.</source>
          <target state="translated">이 오류는 &lt;code&gt;#[lang = &quot;..&quot;]&lt;/code&gt; 속성이 잘못된 유형의 항목에 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="04b6c6e07e059a0181ccbe377eeeabdfa436d081" translate="yes" xml:space="preserve">
          <source>This error indicates that a &lt;code&gt;#[non_exhaustive]&lt;/code&gt; attribute was incorrectly placed on something other than a struct or enum.</source>
          <target state="translated">이 오류는 &lt;code&gt;#[non_exhaustive]&lt;/code&gt; 속성이 구조체 나 열거 형 이외의 항목에 잘못 배치 되었음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="7022f431bbd32573cf9101aaa229f54136c6e815" translate="yes" xml:space="preserve">
          <source>This error indicates that a &lt;code&gt;#[repr(..)]&lt;/code&gt; attribute was placed on an unsupported item.</source>
          <target state="translated">이 오류는 &lt;code&gt;#[repr(..)]&lt;/code&gt; 속성이 지원되지 않는 항목에 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ca9d1588d95295137d9296e3cc73990ee881720a" translate="yes" xml:space="preserve">
          <source>This error indicates that a binary assignment operator like &lt;code&gt;+=&lt;/code&gt; or &lt;code&gt;^=&lt;/code&gt; was applied to a type that doesn't support it. For example:</source>
          <target state="translated">이 오류는 &lt;code&gt;+=&lt;/code&gt; 또는 &lt;code&gt;^=&lt;/code&gt; 와 같은 이진 대입 연산자 가 지원하지 않는 형식에 적용 되었음을 나타냅니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="942586ad68f246da14ea422c40de5e3f0b9face6" translate="yes" xml:space="preserve">
          <source>This error indicates that a incorrect visibility restriction was specified.</source>
          <target state="translated">이 오류는 잘못된 가시성 제한이 지정되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0ed5220e5bb81a5a254920c1211412f9ef92a217" translate="yes" xml:space="preserve">
          <source>This error indicates that a lifetime is missing from a type. If it is an error inside a function signature, the problem may be with failing to adhere to the lifetime elision rules (see below).</source>
          <target state="translated">이 오류는 유형에서 수명이 누락되었음을 나타냅니다. 함수 서명 내부에 오류가있는 경우 수명 제거 규칙을 준수하지 못하는 문제 일 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="163c07e3082230bfd9dd310e7a36d455707b90b1" translate="yes" xml:space="preserve">
          <source>This error indicates that a mutable variable is being used while it is still captured by a closure. Because the closure has borrowed the variable, it is not available for use until the closure goes out of scope.</source>
          <target state="translated">이 오류는 변수 변수가 클로저에 의해 여전히 캡처되는 동안 사용되고 있음을 나타냅니다. 클로저가 변수를 빌려 왔기 때문에 클로저가 범위를 벗어날 때까지 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f5aeaeedbb41e69e7d361beb7e7f664611c650d" translate="yes" xml:space="preserve">
          <source>This error indicates that a mutable variable is used while it is still captured by a closure. Because the closure has borrowed the variable, it is not available until the closure goes out of scope.</source>
          <target state="translated">이 오류는 클로저에 의해 캡처되는 동안 변경 가능한 변수가 사용됨을 나타냅니다. 클로저가 변수를 차용했기 때문에 클로저가 범위를 벗어날 때까지 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f276e617d109dc1e2831917bc3e9ec17e8a46ef1" translate="yes" xml:space="preserve">
          <source>This error indicates that a pattern for a struct fails to specify a sub-pattern for every one of the struct's fields. Ensure that each field from the struct's definition is mentioned in the pattern, or use &lt;code&gt;..&lt;/code&gt; to ignore unwanted fields.</source>
          <target state="translated">이 오류는 구조체의 패턴이 구조체의 모든 필드에 대해 하위 패턴을 지정하지 못했음을 나타냅니다. 구조체 정의의 각 필드가 패턴에 언급되어 있는지 확인하거나 &lt;code&gt;..&lt;/code&gt; 을 사용 하여 원하지 않는 필드를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="cf2673db078cb233aef2cf4d975d04209851d888" translate="yes" xml:space="preserve">
          <source>This error indicates that a pointer to a trait type cannot be implicitly dereferenced by a pattern. Every trait defines a type, but because the size of trait implementors isn't fixed, this type has no compile-time size. Therefore, all accesses to trait types must be through pointers. If you encounter this error you should try to avoid dereferencing the pointer.</source>
          <target state="translated">이 오류는 특성 유형에 대한 포인터를 패턴으로 내재적으로 역 참조 할 수 없음을 나타냅니다. 모든 특성은 유형을 정의하지만 특성 구현 자의 크기는 고정되어 있지 않기 때문에이 유형에는 컴파일 타임 크기가 없습니다. 따라서 형질 유형에 대한 모든 액세스는 포인터를 통해 이루어져야합니다. 이 오류가 발생하면 포인터 역 참조를 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="828017bc333a648d7ba2ba05b6d8defb66538498" translate="yes" xml:space="preserve">
          <source>This error indicates that a struct pattern attempted to extract a non-existent field from a struct. Struct fields are identified by the name used before the colon &lt;code&gt;:&lt;/code&gt; so struct patterns should resemble the declaration of the struct type being matched.</source>
          <target state="translated">이 오류는 구조체 패턴이 구조체에서 존재하지 않는 필드를 추출하려고 시도했음을 나타냅니다. 구조체 필드는 콜론 전에 사용 된 이름에 의해 식별됩니다 &lt;code&gt;:&lt;/code&gt; 구조체 패턴이 구조체 형식의 선언이 일치되고 유사합니다 그래서.</target>
        </trans-unit>
        <trans-unit id="8fe4ff510197fbaaaaa06c8b33b203c1e4dc7f1a" translate="yes" xml:space="preserve">
          <source>This error indicates that a temporary value is being dropped while a borrow is still in active use.</source>
          <target state="translated">이 오류는 대출이 여전히 사용중인 동안 임시 값이 삭제됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="29f636e2d8527491e9c968890f3142a6d2d79a49" translate="yes" xml:space="preserve">
          <source>This error indicates that a type or lifetime parameter has been declared but not actually used. Here is an example that demonstrates the error:</source>
          <target state="translated">이 오류는 유형 또는 수명 매개 변수가 선언되었지만 실제로 사용되지 않았 음을 나타냅니다. 다음은 오류를 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="021899c7481112f5b1115194dfebb6c6433d75e6" translate="yes" xml:space="preserve">
          <source>This error indicates that a variable usage inside an inner function is invalid because the variable comes from a dynamic environment. Inner functions do not have access to their containing environment.</source>
          <target state="translated">이 오류는 변수가 동적 환경에서 제공되므로 내부 함수 내부의 변수 사용법이 유효하지 않음을 나타냅니다. 내부 함수는 포함 환경에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ee2b7895f62fe245340d50c3f8c134d38d139ea0" translate="yes" xml:space="preserve">
          <source>This error indicates that an &lt;code&gt;#[inline(..)]&lt;/code&gt; attribute was incorrectly placed on something other than a function or method.</source>
          <target state="translated">이 오류는 &lt;code&gt;#[inline(..)]&lt;/code&gt; 속성이 함수 나 메소드 이외의 것에 잘못 배치 되었음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="b354ce81cf352c1f70206a250c5709ec2f51795d" translate="yes" xml:space="preserve">
          <source>This error indicates that an attempted implementation of a trait method has the wrong number of function parameters.</source>
          <target state="translated">이 오류는 특성 메소드의 구현 시도에 잘못된 수의 함수 매개 변수가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e0c31ba5c6bda555cd8ea81a836bf176c496c77b" translate="yes" xml:space="preserve">
          <source>This error indicates that an attempted implementation of a trait method has the wrong number of type or const parameters.</source>
          <target state="translated">이 오류는 특성 메소드의 구현 시도에 잘못된 유형 또는 const 매개 변수 수가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b75e5fdc31d31d1c4e71b1b39da466c4c14335c3" translate="yes" xml:space="preserve">
          <source>This error indicates that an empty match expression is invalid because the type it is matching on is non-empty (there exist values of this type). In safe code it is impossible to create an instance of an empty type, so empty match expressions are almost never desired. This error is typically fixed by adding one or more cases to the match expression.</source>
          <target state="translated">이 오류는 일치하는 유형이 비어 있지 않기 때문에 빈 일치 표현식이 유효하지 않음을 나타냅니다 (이 유형의 값이 있음). 안전한 코드에서는 빈 형식의 인스턴스를 만드는 것이 불가능하므로 빈 일치 식은 거의 필요하지 않습니다. 이 오류는 일반적으로 하나 이상의 사례를 일치 표현식에 추가하여 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="aa5d0ed3544dd02116d741311bf5dc31cbf1e877" translate="yes" xml:space="preserve">
          <source>This error indicates that during an attempt to build a struct or struct-like enum variant, one of the fields was not provided. Erroneous code example:</source>
          <target state="translated">이 오류는 구조체 또는 구조체와 유사한 열거 형 변형을 작성하려고 시도하는 동안 필드 중 하나가 제공되지 않았 음을 나타냅니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="4fe613edd2e0d9ed1781cdd172cb95fcc86dda95" translate="yes" xml:space="preserve">
          <source>This error indicates that during an attempt to build a struct or struct-like enum variant, one of the fields was specified more than once. Each field should be specified exactly one time. Example:</source>
          <target state="translated">이 오류는 구조체 또는 구조체와 유사한 열거 형 변형을 빌드하는 동안 필드 중 하나가 두 번 이상 지정되었음을 나타냅니다. 각 필드는 정확히 한 번 지정해야합니다. 예:</target>
        </trans-unit>
        <trans-unit id="3e8ed17cc79bcd070351fc2c779882f025c94d0d" translate="yes" xml:space="preserve">
          <source>This error indicates that during an attempt to build a struct or struct-like enum variant, one of the fields was specified more than once. Erroneous code example:</source>
          <target state="translated">이 오류는 구조체 또는 구조체와 같은 열거 형 변형을 작성하는 중에 필드 중 하나가 두 번 이상 지정되었음을 나타냅니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="184a0c9f21c2159367397ab03b1af11810a4b7a9" translate="yes" xml:space="preserve">
          <source>This error indicates that next we need to create an associated function named &lt;code&gt;new&lt;/code&gt; for &lt;code&gt;ThreadPool&lt;/code&gt;. We also know that &lt;code&gt;new&lt;/code&gt; needs to have one parameter that can accept &lt;code&gt;4&lt;/code&gt; as an argument and should return a &lt;code&gt;ThreadPool&lt;/code&gt; instance. Let&amp;rsquo;s implement the simplest &lt;code&gt;new&lt;/code&gt; function that will have those characteristics:</source>
          <target state="translated">이 오류는 다음 에 &lt;code&gt;ThreadPool&lt;/code&gt; 에 대해 &lt;code&gt;new&lt;/code&gt; 라는 관련 함수를 작성해야 함을 나타냅니다 . 또한 &lt;code&gt;new&lt;/code&gt; 에는 인수로 &lt;code&gt;4&lt;/code&gt; 를 허용 하고 &lt;code&gt;ThreadPool&lt;/code&gt; 인스턴스를 반환 해야하는 하나의 매개 변수가 있어야한다는 것도 알고 있습니다 . 이러한 특성을 가진 가장 간단한 &lt;code&gt;new&lt;/code&gt; 기능을 구현해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="2dad13e650883f25d2104ae52eca1fef407497bf" translate="yes" xml:space="preserve">
          <source>This error indicates that not enough type parameters were found in a type or trait.</source>
          <target state="translated">이 오류는 유형 또는 특성에서 유형 매개 변수가 충분하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ca21a72c98d3df2023442d374a3dadbb098c691b" translate="yes" xml:space="preserve">
          <source>This error indicates that some types or traits depend on each other and therefore cannot be constructed.</source>
          <target state="translated">이 오류는 일부 유형 또는 특성이 서로 종속되어 구성 할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="04671a501f0a2d188e9fcc11f1a02fbc634b9fe6" translate="yes" xml:space="preserve">
          <source>This error indicates that the bindings in a match arm would require a value to be moved into more than one location, thus violating unique ownership. Code like the following is invalid as it requires the entire &lt;code&gt;Option&amp;lt;String&amp;gt;&lt;/code&gt; to be moved into a variable called &lt;code&gt;op_string&lt;/code&gt; while simultaneously requiring the inner &lt;code&gt;String&lt;/code&gt; to be moved into a variable called &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">이 오류는 일치 암의 바인딩이 하나 이상의 위치로 값을 이동해야하므로 고유 소유권을 위반 함을 나타냅니다. 다음과 같은 코드는 전체 &lt;code&gt;Option&amp;lt;String&amp;gt;&lt;/code&gt; 을 &lt;code&gt;op_string&lt;/code&gt; 이라는 변수로 이동 해야하는 동시에 내부 &lt;code&gt;String&lt;/code&gt; 을 &lt;code&gt;s&lt;/code&gt; 라는 변수로 이동 해야하므로 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0593569b391769294fc0cbd6c435421f4f05566e" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler cannot guarantee a matching pattern for one or more possible inputs to a match expression. Guaranteed matches are required in order to assign values to match expressions, or alternatively, determine the flow of execution.</source>
          <target state="translated">이 오류는 컴파일러가 일치 식에 대한 하나 이상의 가능한 입력에 대해 일치 패턴을 보장 할 수 없음을 나타냅니다. 식과 일치하는 값을 할당하거나 실행 흐름을 결정하려면 보장 된 일치가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e6ec80fb058ca19fb5e7892d541e007d08b04d8f" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler cannot guarantee a matching pattern for one or more possible inputs to a match expression. Guaranteed matches are required in order to assign values to match expressions, or alternatively, determine the flow of execution. Erroneous code example:</source>
          <target state="translated">이 오류는 컴파일러가 일치 표현식에 대한 하나 이상의 가능한 입력에 대한 일치 패턴을 보장 할 수 없음을 나타냅니다. 표현식과 일치하는 값을 할당하거나 실행 흐름을 결정하려면 보장 된 일치가 필요합니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="561856cda5e25152013aec070f3d54bab7aa1df8" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler found multiple functions with the &lt;code&gt;#[main]&lt;/code&gt; attribute. This is an error because there must be a unique entry point into a Rust program. Example:</source>
          <target state="translated">이 오류는 컴파일러가 &lt;code&gt;#[main]&lt;/code&gt; 속성을 가진 여러 함수를 찾았 음을 나타냅니다 . Rust 프로그램에 고유 한 진입 점이 있어야하기 때문에 이는 오류입니다. 예:</target>
        </trans-unit>
        <trans-unit id="5bea3375dcc80f531e3766516bd9f6d7115c2ccf" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler found multiple functions with the &lt;code&gt;#[start]&lt;/code&gt; attribute. This is an error because there must be a unique entry point into a Rust program. Example:</source>
          <target state="translated">이 오류는 컴파일러가 &lt;code&gt;#[start]&lt;/code&gt; 속성을 가진 여러 함수를 찾았 음을 나타냅니다 . Rust 프로그램에 고유 한 진입 점이 있어야하기 때문에 이는 오류입니다. 예:</target>
        </trans-unit>
        <trans-unit id="8f30ae6ab3b3757a6fafd59d7ba821bfd1db82b1" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler was unable to sensibly evaluate a constant expression that had to be evaluated. Attempting to divide by 0 or causing an integer overflow are two ways to induce this error.</source>
          <target state="translated">이 오류는 컴파일러가 평가해야하는 상수 식을 현명하게 평가할 수 없음을 나타냅니다. 0으로 나누거나 정수 오버플로를 유발하는 것은이 오류를 유발하는 두 가지 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f36d8b8d1d8446198729b807cb2a4a2419af004e" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler was unable to sensibly evaluate an constant expression that had to be evaluated. Attempting to divide by 0 or causing integer overflow are two ways to induce this error. For example:</source>
          <target state="translated">이 오류는 컴파일러가 평가해야하는 상수 표현식을 현명하게 평가할 수 없음을 나타냅니다. 0으로 나누거나 정수 오버플로를 발생시키는 것은이 오류를 유발하는 두 가지 방법입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6a1e2255560b86b2d9499ff55662d827b519b332" translate="yes" xml:space="preserve">
          <source>This error indicates that the numeric value for the method being passed exists but the type of the numeric value or binding could not be identified.</source>
          <target state="translated">이 오류는 전달중인 메소드의 숫자 값이 존재하지만 숫자 값 또는 바인딩 유형을 식별 할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="148347b598d68fa69c31f92c37c1da55d76c0063" translate="yes" xml:space="preserve">
          <source>This error indicates that the struct, enum or enum variant cannot be instantiated from outside of the defining crate as it has been marked as &lt;code&gt;non_exhaustive&lt;/code&gt; and as such more fields/variants may be added in future that could cause adverse side effects for this code.</source>
          <target state="translated">이 오류는 struct, enum 또는 enum 변형이 정의되지 않은 크레이트 외부에서 인스턴스화 할 수 없음을 나타냅니다. 이는 비 &lt;code&gt;non_exhaustive&lt;/code&gt; 이라고 표시되어 향후이 코드에 부작용을 일으킬 수있는 더 많은 필드 / 변형이 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcad2c51ea5b37a57bae2601eed616fe3e726b2e" translate="yes" xml:space="preserve">
          <source>This error indicates that the struct, enum or enum variant must be matched non-exhaustively as it has been marked as &lt;code&gt;non_exhaustive&lt;/code&gt;.</source>
          <target state="translated">이 오류는 구조체, 열거 형 또는 열거 형 변형이 &lt;code&gt;non_exhaustive&lt;/code&gt; 로 표시 되었으므로 전체적으로 일치하지 않아야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="37c7a2a28ca533246457e808e16c999f3f050492" translate="yes" xml:space="preserve">
          <source>This error indicates that there is a mismatch between generic parameters and impl Trait parameters in a trait declaration versus its impl.</source>
          <target state="translated">이 오류는 특성 선언에서 일반 매개 변수와 impl 특성 매개 변수와 해당 impl간에 불일치가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="51a28020fb3170ca33d27d23beb6ff4c2ae9ce5c" translate="yes" xml:space="preserve">
          <source>This error indicates that too many type parameters were found in a type or trait.</source>
          <target state="translated">이 오류는 유형 또는 특성에서 너무 많은 유형 매개 변수가 발견되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="52a40c02e70b32e434b6bbe135867f805601219b" translate="yes" xml:space="preserve">
          <source>This error indicates that type inference did not result in one unique possible type, and extra information is required. In most cases this can be provided by adding a type annotation. Sometimes you need to specify a generic type parameter manually.</source>
          <target state="translated">이 오류는 형식 유추로 인해 하나의 고유 한 형식이 만들어지지 않았으며 추가 정보가 필요함을 나타냅니다. 대부분의 경우 유형 주석을 추가하여 제공 할 수 있습니다. 때로는 일반 유형 매개 변수를 수동으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4c3b94702358e1162bf8effa04b8b4b7e098714c" translate="yes" xml:space="preserve">
          <source>This error indicates that you are trying to borrow a variable as mutable when it has already been borrowed as immutable.</source>
          <target state="translated">이 오류는 변수가 이미 변경 불가능한 것으로 빌려 졌을 때 변수를 변경 가능으로 빌리려고 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5d266dd2a168d28b90102ea5f40d828bae3909b4" translate="yes" xml:space="preserve">
          <source>This error indicates the use of a loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) inside a closure but outside of any loop. Erroneous code example:</source>
          <target state="translated">이 오류는 클로저 내부에서 루프 외부 에서 루프 키워드 ( &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;continue&lt;/code&gt; )를 사용함을 나타냅니다 . 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="a14d78d3da966b89fe122674705e062ddb4c4c41" translate="yes" xml:space="preserve">
          <source>This error indicates the use of a loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) outside of a loop. Without a loop to break out of or continue in, no sensible action can be taken. Erroneous code example:</source>
          <target state="translated">이 오류는 루프 외부 에서 루프 키워드 ( &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;continue&lt;/code&gt; )를 사용함을 나타냅니다 . 루프가 끊어 지거나 계속 진행되지 않으면 현명한 조치를 취할 수 없습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="50520313e8b1d1b1c6569c98ff40cb57f7812069" translate="yes" xml:space="preserve">
          <source>This error is created by the &lt;a href=&quot;struct.cstr#method.from_bytes_with_nul&quot;&gt;&lt;code&gt;CStr::from_bytes_with_nul&lt;/code&gt;&lt;/a&gt; method. See its documentation for more.</source>
          <target state="translated">이 오류는 &lt;a href=&quot;struct.cstr#method.from_bytes_with_nul&quot;&gt; &lt;code&gt;CStr::from_bytes_with_nul&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1b9e91e9541342a47e9d0b1ac521444fa8e68a88" translate="yes" xml:space="preserve">
          <source>This error is created by the &lt;a href=&quot;struct.cstr#method.from_bytes_with_nul&quot;&gt;&lt;code&gt;from_bytes_with_nul&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 오류는 &lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.cstr#method.from_bytes_with_nul&quot;&gt; &lt;code&gt;from_bytes_with_nul&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7f88231c82f77383d008a182af5374b0e8d20578" translate="yes" xml:space="preserve">
          <source>This error is created by the &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 에러는 &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.cstring#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e66887716e5bc2fbc972f3ffc3450120cd6c7b7e" translate="yes" xml:space="preserve">
          <source>This error is fairly cryptic because the problem is fairly cryptic. To call a &lt;code&gt;FnOnce&lt;/code&gt; closure that is stored in a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; (which is what our &lt;code&gt;Job&lt;/code&gt; type alias is), the closure needs to move itself &lt;em&gt;out&lt;/em&gt; of the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; because the closure takes ownership of &lt;code&gt;self&lt;/code&gt; when we call it. In general, Rust doesn&amp;rsquo;t allow us to move a value out of a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; because Rust doesn&amp;rsquo;t know how big the value inside the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; will be: recall in Chapter 15 that we used &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; precisely because we had something of an unknown size that we wanted to store in a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to get a value of a known size.</source>
          <target state="translated">이 오류는 문제가 상당히 복잡하기 때문에 상당히 복잡합니다. 통화에 &lt;code&gt;FnOnce&lt;/code&gt; 의 (A)에 저장되어있는 폐쇄 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; (우리의 것입니다 &lt;code&gt;Job&lt;/code&gt; 유형의 별칭입니다), 폐쇄 요구 자체를 이동 &lt;em&gt;밖으로&lt;/em&gt; 의 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 폐쇄가의 소유권을하기 때문에 &lt;code&gt;self&lt;/code&gt; 우리가 그것을 호출 할 때. 일반적으로, 녹 우리가 밖으로 값을 이동하는 것을 허용하지 않습니다 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 녹 알고하지 않기 때문에 얼마나 큰 내부 값 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 될 것입니다 장 : 우리가 사용했던 15 리콜 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 정확히 알려지지 않은 크기의 무언가가 있었기 때문에 알려진 크기의 값을 얻기 위해 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 에 저장하려고했습니다 .</target>
        </trans-unit>
        <trans-unit id="ac1c7bfe67c403881a0d5e5220daf766f18ab15b" translate="yes" xml:space="preserve">
          <source>This error is used as the error type for the &lt;a href=&quot;../str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; implementation for &lt;a href=&quot;../primitive.f32&quot;&gt;&lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 오류는 대한 오류 유형으로 사용되는 &lt;a href=&quot;../str/trait.fromstr&quot;&gt; &lt;code&gt;FromStr&lt;/code&gt; 에&lt;/a&gt; 대한 구현 &lt;a href=&quot;../primitive.f32&quot;&gt; &lt;code&gt;f32&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a413bd30b0780353f6f0cb9ec7112a60510b4c1b" translate="yes" xml:space="preserve">
          <source>This error is used as the error type for the &lt;a href=&quot;../str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; implementation for &lt;a href=&quot;enum.ipaddr&quot;&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.ipv4addr&quot;&gt;&lt;code&gt;Ipv4Addr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.ipv6addr&quot;&gt;&lt;code&gt;Ipv6Addr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.socketaddrv4&quot;&gt;&lt;code&gt;SocketAddrV4&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.socketaddrv6&quot;&gt;&lt;code&gt;SocketAddrV6&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 오류는 &lt;a href=&quot;enum.ipaddr&quot;&gt; &lt;code&gt;IpAddr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.ipv4addr&quot;&gt; &lt;code&gt;Ipv4Addr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.ipv6addr&quot;&gt; &lt;code&gt;Ipv6Addr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.socketaddrv4&quot;&gt; &lt;code&gt;SocketAddrV4&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.socketaddrv6&quot;&gt; &lt;code&gt;SocketAddrV6&lt;/code&gt; &lt;/a&gt; 에 대한 &lt;a href=&quot;../str/trait.fromstr&quot;&gt; &lt;code&gt;FromStr&lt;/code&gt; &lt;/a&gt; 구현 의 오류 유형으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="dbd5a817ebd0158354fc9b6704f3a0f2b0fc517f" translate="yes" xml:space="preserve">
          <source>This error is used as the error type for the &lt;code&gt;from_str_radix()&lt;/code&gt; functions on the primitive integer types, such as &lt;a href=&quot;../primitive.i8#method.from_str_radix&quot;&gt;&lt;code&gt;i8::from_str_radix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 오류는 기본 정수 유형 (예 : &lt;a href=&quot;../primitive.i8#method.from_str_radix&quot;&gt; &lt;code&gt;i8::from_str_radix&lt;/code&gt; &lt;/a&gt; &lt;code&gt;from_str_radix()&lt;/code&gt; 에서 from_str_radix () 함수 의 오류 유형으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="022d759f57798a79780636ae9f03f6fedf32312c" translate="yes" xml:space="preserve">
          <source>This error lets us know that either we&amp;rsquo;re passing something to &lt;code&gt;Screen&lt;/code&gt; we didn&amp;rsquo;t mean to pass and we should pass a different type or we should implement &lt;code&gt;Draw&lt;/code&gt; on &lt;code&gt;String&lt;/code&gt; so that &lt;code&gt;Screen&lt;/code&gt; is able to call &lt;code&gt;draw&lt;/code&gt; on it.</source>
          <target state="translated">이 오류는 우리가 하나 우리가 무언가를 전달하는 것을 알 수 있습니다 &lt;code&gt;Screen&lt;/code&gt; 우리가 전달하는 의미하지 않았다 우리는 다른 종류의를 통과해야 또는 우리가 구현해야 &lt;code&gt;Draw&lt;/code&gt; 에 &lt;code&gt;String&lt;/code&gt; 있도록 &lt;code&gt;Screen&lt;/code&gt; 호출 할 수있다 &lt;code&gt;draw&lt;/code&gt; 그 위에.</target>
        </trans-unit>
        <trans-unit id="7089a49860a1eeefd308980067bc3b5e6f3e5841" translate="yes" xml:space="preserve">
          <source>This error lets you know that Rust has this constant defined more precisely and that your program would be more correct if you used the constant instead. You would then change your code to use the &lt;code&gt;PI&lt;/code&gt; constant. The following code doesn&amp;rsquo;t result in any errors or warnings from Clippy:</source>
          <target state="translated">이 오류는 Rust가이 상수를보다 정확하게 정의했으며 상수를 대신 사용하면 프로그램이 더 정확하다는 것을 알려줍니다. 그런 다음 &lt;code&gt;PI&lt;/code&gt; 상수 를 사용하도록 코드를 변경합니다 . 다음 코드는 Clippy에서 오류나 경고를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7527f99b3dbab9d3281da26cc0de240205ca3ed7" translate="yes" xml:space="preserve">
          <source>This error may also commonly be found when working with unsafe code. For example, when using raw pointers one may wish to specify the lifetime for which the pointed-at data is valid. An initial attempt (below) causes this error:</source>
          <target state="translated">안전하지 않은 코드로 작업 할 때이 오류가 일반적으로 발견 될 수 있습니다. 예를 들어, 원시 포인터를 사용할 때 지정된 데이터가 유효한 수명을 지정할 수 있습니다. 초기 시도 (아래)는이 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="1e7204b5ea49e32896ab0ba12a29a6e3937bc0f3" translate="yes" xml:space="preserve">
          <source>This error means that an attempt was made to match a struct type enum variant as a non-struct type:</source>
          <target state="translated">이 오류는 구조체 형식 열거 형 변형을 구조체 이외의 형식으로 일치 시키려고 시도했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="76d97f884e0ba6f5c3488397207d55a3b212ce21" translate="yes" xml:space="preserve">
          <source>This error means that an attempt was made to match something which is neither a tuple struct nor a tuple variant. Only these two elements are allowed as a pattern:</source>
          <target state="translated">이 오류는 튜플 구조체도 아니고 튜플 변형도 아닌 것을 일치 시키려고 시도했음을 의미합니다. 다음 두 요소 만 패턴으로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c1988ee636e2a4d68092372fb6c89de2473339d3" translate="yes" xml:space="preserve">
          <source>This error means that an incorrect number of generic arguments were provided:</source>
          <target state="translated">이 오류는 잘못된 수의 일반 인수가 제공되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="368e8d1bf22974707354d4d21e3f6ab34ed1757e" translate="yes" xml:space="preserve">
          <source>This error means you can&amp;rsquo;t use this trait as a trait object in this way. If you&amp;rsquo;re interested in more details on object safety, see &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;Rust RFC 255&lt;/a&gt;.</source>
          <target state="translated">이 오류는이 특성을 이런 방식으로 특성 오브젝트로 사용할 수 없음을 의미합니다. 객체 안전에 대한 자세한 내용은 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;Rust RFC 255를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="027a2fdf6a3f9948a9c92b0f1c99c26f859c6929" translate="yes" xml:space="preserve">
          <source>This error message refers to a feature we haven&amp;rsquo;t covered yet: lifetimes. We&amp;rsquo;ll discuss lifetimes in detail in Chapter 10. But, if you disregard the parts about lifetimes, the message does contain the key to why this code is a problem:</source>
          <target state="translated">이 오류 메시지는 아직 다루지 않은 기능인 수명을 나타냅니다. 수명에 대해서는 10 장에서 자세히 설명 할 것입니다. 그러나 수명에 대한 부분을 무시하면이 코드가 왜 문제가 되는가에 대한 메시지가 메시지에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b934f7e266f094b4b999e8bf2f04c71dea6d6829" translate="yes" xml:space="preserve">
          <source>This error message states that we&amp;rsquo;re not allowed to explicitly call &lt;code&gt;drop&lt;/code&gt;. The error message uses the term &lt;em&gt;destructor&lt;/em&gt;, which is the general programming term for a function that cleans up an instance. A &lt;em&gt;destructor&lt;/em&gt; is analogous to a &lt;em&gt;constructor&lt;/em&gt;, which creates an instance. The &lt;code&gt;drop&lt;/code&gt; function in Rust is one particular destructor.</source>
          <target state="translated">이 오류 메시지는 &lt;code&gt;drop&lt;/code&gt; 호출을 명시 적으로 호출 할 수 없음을 나타 냅니다. 오류 메시지에는 &lt;em&gt;소멸 자라는&lt;/em&gt; 용어가 사용 되는데, 이는 인스턴스를 정리하는 함수의 일반적인 프로그래밍 용어입니다. &lt;em&gt;소멸자&lt;/em&gt; A와 유사 &lt;em&gt;생성자&lt;/em&gt; 인스턴스를 생성한다. Rust 의 &lt;code&gt;drop&lt;/code&gt; 함수는 특정 소멸자입니다.</target>
        </trans-unit>
        <trans-unit id="2c2b32b5586db42f3b0dff4da46b1782d86e698e" translate="yes" xml:space="preserve">
          <source>This error occurs because a borrow in a generator persists across a yield point.</source>
          <target state="translated">이 오류는 생성기의 차용이 항복점에 걸쳐 지속되기 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1e6bf835d8f1dd37c8b25ebb4f51cc6621c79aa9" translate="yes" xml:space="preserve">
          <source>This error occurs because a borrow of a thread-local variable was made inside a function which outlived the lifetime of the function.</source>
          <target state="translated">이 오류는 함수의 수명보다 오래 지속되는 함수 내에서 스레드 로컬 변수를 빌려 왔기 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="249f7bc8f6d82a80564f1c3f396aa42dbc6e451f" translate="yes" xml:space="preserve">
          <source>This error occurs because a value was dropped while it was still borrowed</source>
          <target state="translated">이 오류는 여전히 빌린 동안 값이 삭제 되었기 때문에 발생합니다</target>
        </trans-unit>
        <trans-unit id="074bebec9bc1d161aacdccb6e09fa091949d4c0d" translate="yes" xml:space="preserve">
          <source>This error occurs because you tried to mutably borrow a non-mutable variable.</source>
          <target state="translated">이 오류는 변경 불가능한 변수를 변경 가능하게 차용하려고했기 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1c3db0f8ef7d737dfd4c2dc90ac02bc9a5c77f3f" translate="yes" xml:space="preserve">
          <source>This error occurs when a bound in an implementation of a trait does not match the bounds specified in the original trait. For example:</source>
          <target state="translated">이 오류는 특성 구현에서 바운드가 원래 특성에 지정된 범위와 일치하지 않을 때 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="093dfc68eae74dcc328a7c8a1a3d68f0b36d7fb4" translate="yes" xml:space="preserve">
          <source>This error occurs when a method is used on a type which doesn't implement it:</source>
          <target state="translated">이 오류는 메소드를 구현하지 않는 유형에서 메소드를 사용할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="da941b6947e460e43f6112767122feb782f16207" translate="yes" xml:space="preserve">
          <source>This error occurs when an &lt;code&gt;if&lt;/code&gt; expression without an &lt;code&gt;else&lt;/code&gt; block is used in a context where a type other than &lt;code&gt;()&lt;/code&gt; is expected, for example a &lt;code&gt;let&lt;/code&gt; expression:</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt; 블록이 없는 &lt;code&gt;if&lt;/code&gt; 표현식 이 &lt;code&gt;()&lt;/code&gt; 이외의 유형 ( 예 : &lt;code&gt;let&lt;/code&gt; ) 이 필요한 컨텍스트에서 사용될 경우이 오류가 발생합니다. : 표현식 .</target>
        </trans-unit>
        <trans-unit id="5a28a2c48baba84d59c80917ee2d999515b5d378" translate="yes" xml:space="preserve">
          <source>This error occurs when an &lt;code&gt;if&lt;/code&gt; expression without an &lt;code&gt;else&lt;/code&gt; block is used in a context where a type other than &lt;code&gt;()&lt;/code&gt; is expected. In the previous code example, the &lt;code&gt;let&lt;/code&gt; expression was expecting a value but since there was no &lt;code&gt;else&lt;/code&gt;, no value was returned.</source>
          <target state="translated">이 오류 는 &lt;code&gt;else&lt;/code&gt; 블록이 없는 &lt;code&gt;if&lt;/code&gt; 표현식 이 &lt;code&gt;()&lt;/code&gt; 이외의 유형 이 예상되는 컨텍스트에서 사용될 때 발생합니다 . 이전 코드 예제에서 &lt;code&gt;let&lt;/code&gt; 식은 값을 예상했지만 &lt;code&gt;else&lt;/code&gt; 값이 없기 때문에 값이 반환되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d0370ddda8b1bb558216506bbbbafb414b273904" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to assign to a borrowed value.</source>
          <target state="translated">이 오류는 빌린 값에 할당하려고 할 때 발생합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
