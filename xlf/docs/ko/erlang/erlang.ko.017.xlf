<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="7ba69074df191132a5aee72b7de68af231ccb23b" translate="yes" xml:space="preserve">
          <source>A fun is a functional object. Funs make it possible to create an anonymous function and pass the function itself -- not its name -- as argument to other functions.</source>
          <target state="translated">재미는 기능적인 대상입니다. 재미있는 기능을 통해 익명 함수를 만들고 이름이 아닌 함수 자체를 다른 함수의 인수로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a83e179e2a0b967f058ad516cb4229a827e95fd9" translate="yes" xml:space="preserve">
          <source>A fun is applied to the wrong number of arguments. &lt;code&gt;F&lt;/code&gt; describes the fun and the arguments.</source>
          <target state="translated">잘못된 수의 인수에 재미가 적용됩니다. &lt;code&gt;F&lt;/code&gt; 는 재미와 논쟁을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="331ce727ff0b82a2baa3eca467f7f047acb2688e" translate="yes" xml:space="preserve">
          <source>A fun refers into a fun table, which also consumes memory.</source>
          <target state="translated">재미는 메모리를 소비하는 재미 테이블을 말합니다.</target>
        </trans-unit>
        <trans-unit id="4fc6c3b004a9c28596e264b75abedbe106e6b063" translate="yes" xml:space="preserve">
          <source>A fun that takes the socket info and returns a &lt;code&gt;boolean()&lt;/code&gt; (&lt;code&gt;true&lt;/code&gt; if the socket sould be included and &lt;code&gt;false&lt;/code&gt; if should not).</source>
          <target state="translated">소켓 정보를 받아 &lt;code&gt;boolean()&lt;/code&gt; 반환하는 재미입니다 ( 소켓 소울이 포함되면 &lt;code&gt;true&lt;/code&gt; 이고 포함 되지 않으면 &lt;code&gt;false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c25c37b8117f77137d7a7610d86f37adc3dd7d32" translate="yes" xml:space="preserve">
          <source>A fun which converts a &lt;code&gt;&lt;a href=&quot;#type-report&quot;&gt;report() &lt;/a&gt;&lt;/code&gt; to a format string and arguments, or directly to a string. See section &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; in the User's Guide for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-report&quot;&gt;report() &lt;/a&gt;&lt;/code&gt; 를 형식 문자열과 인수로 또는 직접 문자열 로 변환하는 재미입니다 . 자세한 내용 은 사용자 가이드의 &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="917f02c1a076a8a47ebb3722785173da993cb101" translate="yes" xml:space="preserve">
          <source>A fun with the following signature:</source>
          <target state="translated">다음과 같은 시그니처가 재미 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c0db4550739af00d32b0dfa12f09adabde22929" translate="yes" xml:space="preserve">
          <source>A function (&lt;code&gt;fun/0&lt;/code&gt; or &lt;code&gt;{Mod,Func,Args}&lt;/code&gt; (MFA) tuple) can be specified as timetrap value in the suite-, group- and test case information function, and as argument to function &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">함수 ( &lt;code&gt;fun/0&lt;/code&gt; 또는 &lt;code&gt;{Mod,Func,Args}&lt;/code&gt; (MFA) 튜플)는 스위트, 그룹 및 테스트 사례 정보 함수에서 타임 트랩 값으로 지정하고 함수 &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt; 에 대한 인수로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07a3cf7ceca0e362fe2af257283edf78084fc160" translate="yes" xml:space="preserve">
          <source>A function breakpoint is a set of line breakpoints, one at the first line of each clause in the specified function.</source>
          <target state="translated">함수 중단 점은 지정된 함수에서 각 절의 첫 번째 줄에 하나씩있는 일련의 줄 중단 점입니다.</target>
        </trans-unit>
        <trans-unit id="5f0fd871bd70c7514030529afb1f484443906fd8" translate="yes" xml:space="preserve">
          <source>A function can have many arguments. Let us expand the module &lt;code&gt;tut1&lt;/code&gt; with the function to multiply two numbers:</source>
          <target state="translated">함수는 많은 인수를 가질 수 있습니다. 두 개의 숫자를 곱하는 함수로 &lt;code&gt;tut1&lt;/code&gt; 모듈을 확장 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="fede52edfc71f21c837f79f6a8e9fb78f0248b2b" translate="yes" xml:space="preserve">
          <source>A function compliant with these functions. For details, see the &lt;code&gt;supervisor(3)&lt;/code&gt; manual page.</source>
          <target state="translated">이러한 기능을 준수하는 기능입니다. 자세한 내용은 &lt;code&gt;supervisor(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="26f617733f33e20e330ebc8aa6d33e7c36f5c2a1" translate="yes" xml:space="preserve">
          <source>A function constraint Fc is a non-empty sequence of constraints &lt;code&gt;C_1, ..., C_k&lt;/code&gt;, and Rep(Fc) = &lt;code&gt;[Rep(C_1), ..., Rep(C_k)]&lt;/code&gt;.</source>
          <target state="translated">함수 제약 조건 Fc는 제약 조건 &lt;code&gt;C_1, ..., C_k&lt;/code&gt; 및 Rep (Fc) = &lt;code&gt;[Rep(C_1), ..., Rep(C_k)]&lt;/code&gt; 비어 있지 않은 시퀀스입니다 .</target>
        </trans-unit>
        <trans-unit id="2dfcd76722f3584d620315b3cb799ba807ca502f" translate="yes" xml:space="preserve">
          <source>A function for an exclusive decode, whose name the user decides in the configuration file</source>
          <target state="translated">구성 파일에서 사용자가 결정한 배타적 디코딩 기능</target>
        </trans-unit>
        <trans-unit id="be3487c9bce760681de79e5934bed4a4861cc982" translate="yes" xml:space="preserve">
          <source>A function in a test suite that is meant to be used for setting up, cleaning up, and/or verifying the state and environment on the System Under Test (SUT) and/or the &lt;code&gt;Common Test&lt;/code&gt; host node, so that a test case (or a set of test cases) can execute correctly.</source>
          <target state="translated">SUT (System Under Test) 및 / 또는 &lt;code&gt;Common Test&lt;/code&gt; 호스트 노드 에서 상태 및 환경을 설정, 정리 및 / 또는 확인하는 데 사용되는 테스트 스위트의 기능으로, 테스트 케이스 ( 또는 일련의 테스트 사례)가 올바르게 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a453d0634dfbb426f81f44cc7d5fb202b518059" translate="yes" xml:space="preserve">
          <source>A function in a test suite that returns a list of properties (read by the &lt;code&gt;Common Test&lt;/code&gt; server) that describes the conditions for executing the test cases in the suite.</source>
          <target state="translated">스위트 에서 테스트 케이스를 실행하기위한 조건을 설명하는 특성 목록 ( &lt;code&gt;Common Test&lt;/code&gt; 서버 에서 읽음)을 리턴하는 테스트 스위트의 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="bee93e2fd141ac952df7640f626d3d10f1e92fbd" translate="yes" xml:space="preserve">
          <source>A function in the &lt;code&gt;proc_lib&lt;/code&gt; module is to be used to start the process. Several functions are available, for example, &lt;code&gt;spawn_link/3,4&lt;/code&gt; for asynchronous start and &lt;code&gt;start_link/3,4,5&lt;/code&gt; for synchronous start.</source>
          <target state="translated">&lt;code&gt;proc_lib&lt;/code&gt; 모듈 의 함수 는 프로세스를 시작하는 데 사용됩니다. 비동기 시작의 경우 &lt;code&gt;spawn_link/3,4&lt;/code&gt; 및 동기 시작의 경우 start_link &lt;code&gt;start_link/3,4,5&lt;/code&gt; 와 같은 여러 기능을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ea8125453a1f5033d8778318612575164d3d3ce" translate="yes" xml:space="preserve">
          <source>A function is called using the &lt;code&gt;M:F&lt;/code&gt; syntax, where &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;F&lt;/code&gt; are atoms or expressions.</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; 과 &lt;code&gt;F&lt;/code&gt; 가 원자 또는 표현식 인 &lt;code&gt;M:F&lt;/code&gt; 구문을 사용하여 함수를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="f874e0a252012bc547a3211dd48e03d0c6554317" translate="yes" xml:space="preserve">
          <source>A function named &lt;code&gt;f&lt;/code&gt; in the module &lt;code&gt;m&lt;/code&gt; and with arity &lt;code&gt;N&lt;/code&gt; is often denoted as &lt;code&gt;m:f/N&lt;/code&gt;.</source>
          <target state="translated">모듈 &lt;code&gt;m&lt;/code&gt; 에서 &lt;code&gt;f&lt;/code&gt; 라는 이름의 함수 와 arity &lt;code&gt;N&lt;/code&gt; 을 갖는 함수 는 종종 &lt;code&gt;m:f/N&lt;/code&gt; 으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="74e2076ece482295f13f43d68037c1f2992b8f9a" translate="yes" xml:space="preserve">
          <source>A function not explicitly documented as thread-safe can, at some point in time, have a thread-safe implementation in the runtime system. Such an implementation can however change to a thread &lt;strong&gt;unsafe&lt;/strong&gt; implementation at any time &lt;strong&gt;without any notice&lt;/strong&gt;.</source>
          <target state="translated">스레드 안전으로 명시 적으로 문서화되지 않은 함수는 특정 시점에 런타임 시스템에서 스레드 안전 구현을 가질 수 있습니다. 그러나 이러한 구현은 &lt;strong&gt;사전 통지없이 언제든지&lt;/strong&gt; 스레드 &lt;strong&gt;안전하지 않은&lt;/strong&gt; 구현으로 변경 될 수 있습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad55a8c4f2fdc2e2ad52ed3c0264567f558d6c9a" translate="yes" xml:space="preserve">
          <source>A function of one argument can be specified as output. The results of sorting or merging the input is collected in a non-empty sequence of variable length lists of binaries or terms depending on the format. The output function is called with one list at a time, and is assumed to return a new output function. Any other return value is immediately returned as value of the current call to the sort or merge function. Each output function is called exactly once. When some output function has been applied to all of the results or an error occurs, the last function is called with argument &lt;code&gt;close&lt;/code&gt;, and the reply is returned as value of the current call to the sort or merge function.</source>
          <target state="translated">하나의 인수의 함수를 출력으로 지정할 수 있습니다. 입력을 정렬하거나 병합 한 결과는 형식에 따라 2 진 또는 항의 가변 길이 목록의 비어 있지 않은 순서로 수집됩니다. 출력 함수는 한 번에 하나의 목록으로 호출되며 새 출력 함수를 리턴한다고 가정합니다. 다른 반환 값은 즉시 sort 또는 merge 함수에 대한 현재 호출의 값으로 반환됩니다. 각 출력 함수는 정확히 한 번 호출됩니다. 일부 출력 함수가 모든 결과에 적용되었거나 오류가 발생하면 마지막 함수가 인수 &lt;code&gt;close&lt;/code&gt; 로 호출되고 sort 또는 merge 함수에 대한 현재 호출의 값으로 응답이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="59fe57d80e3ef9db4ebd49c663824a7be50c8252" translate="yes" xml:space="preserve">
          <source>A function specification can be overloaded. That is, it can have several types, separated by a semicolon (&lt;code&gt;;&lt;/code&gt;):</source>
          <target state="translated">기능 사양이 오버로드 될 수 있습니다. 즉, 세미콜론 ( &lt;code&gt;;&lt;/code&gt; ) 으로 구분 된 여러 유형을 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa95908fabb759c7e5694e79bc74d7fa4cb9cab8" translate="yes" xml:space="preserve">
          <source>A function that adds a family to the database can be written as follows if there is a structure &lt;code&gt;{family, Father, Mother, ChildrenList}&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;{family, Father, Mother, ChildrenList}&lt;/code&gt; 구조가 있으면 데이터베이스에 패밀리를 추가하는 함수를 다음과 같이 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd3a3a3eaa7687c88a4600f70861728b853757b4" translate="yes" xml:space="preserve">
          <source>A function that is intended to be traced.</source>
          <target state="translated">추적 할 기능입니다.</target>
        </trans-unit>
        <trans-unit id="84f14d74551f2c944f4c5fc40a31a1120c5642d9" translate="yes" xml:space="preserve">
          <source>A function type Ft is one of the following:</source>
          <target state="translated">함수 유형 Ft는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="f2ed1d7e05b7d9f3e384891d361b5e9e23e3a041" translate="yes" xml:space="preserve">
          <source>A function which has been called with &lt;code&gt;is_set_ok&lt;/code&gt; will be called again, either with &lt;code&gt;set&lt;/code&gt; if there was no error, or with &lt;code&gt;undo&lt;/code&gt;, if an error occurred. In this way, resources can be reserved in the &lt;code&gt;is_set_ok&lt;/code&gt; operation, released in the &lt;code&gt;undo&lt;/code&gt; operation, or made permanent in the &lt;code&gt;set&lt;/code&gt; operation.</source>
          <target state="translated">&lt;code&gt;is_set_ok&lt;/code&gt; 를 사용하여 호출 된 함수는 오류가없는 경우 &lt;code&gt;set&lt;/code&gt; 을 사용하거나 오류가 발생한 경우 &lt;code&gt;undo&lt;/code&gt; 를 사용하여 다시 호출됩니다 . 이런 식으로, 자원은 &lt;code&gt;is_set_ok&lt;/code&gt; 작업 에서 예약 되거나 &lt;code&gt;undo&lt;/code&gt; 작업 에서 해제 되거나 &lt;code&gt;set&lt;/code&gt; 작업 에서 영구적이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd8be8e88421b65c5785dda3b74a299c4437c971" translate="yes" xml:space="preserve">
          <source>A function with a name ending in &lt;code&gt;..._test()&lt;/code&gt; is recognized by EUnit as a simple test function - it takes no arguments, and its execution either succeeds (returning some arbitrary value that EUnit will throw away), or fails by throwing an exception of some kind (or by not terminating, in which case it will be aborted after a while).</source>
          <target state="translated">이름이 &lt;code&gt;..._test()&lt;/code&gt; 끝나는 함수 는 EUnit에 의해 간단한 테스트 함수로 인식됩니다. 인수가없고 실행이 성공하거나 (EUnit이 버릴 임의의 값을 반환 함) 어떤 종류의 예외 (또는 종료하지 않으면 잠시 후에 중단됩니다).</target>
        </trans-unit>
        <trans-unit id="6cb5bb4750e96bdf1cb4a018b0ae8f0c42348f8c" translate="yes" xml:space="preserve">
          <source>A function with a name ending in &lt;code&gt;..._test_()&lt;/code&gt; (note the final underscore) is recognized by EUnit as a &lt;strong&gt;test generator&lt;/strong&gt; function. Test generators return a &lt;strong&gt;representation&lt;/strong&gt; of a &lt;strong&gt;set of tests&lt;/strong&gt; to be executed by EUnit.</source>
          <target state="translated">이름이 &lt;code&gt;..._test_()&lt;/code&gt; 로 끝나는 함수 (최종 밑줄 참고)는 EUnit에서 &lt;strong&gt;테스트 생성기&lt;/strong&gt; 함수 로 인식 합니다. 테스트는 발전기 복귀 &lt;strong&gt;표현&lt;/strong&gt; (A)의 &lt;strong&gt;테스트 세트&lt;/strong&gt; EUNIT에 의해 실행된다.</target>
        </trans-unit>
        <trans-unit id="1a48507b735622ceff0ef19da321ab8f330d7565" translate="yes" xml:space="preserve">
          <source>A functional interface to system messages.</source>
          <target state="translated">시스템 메시지에 대한 기능 인터페이스.</target>
        </trans-unit>
        <trans-unit id="5718538818085276e24476684d081fe2c16ac1e8" translate="yes" xml:space="preserve">
          <source>A functional object (fun) is called.</source>
          <target state="translated">기능적 객체 (fun)가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a77ae01d0047b90d93e3127e8ab05f3c2f271265" translate="yes" xml:space="preserve">
          <source>A functional, extendible array. The representation is not documented and is subject to change without notice. Notice that arrays cannot be directly compared for equality.</source>
          <target state="translated">기능적이고 확장 가능한 배열입니다. 표현은 문서화되어 있지 않으며 사전 통지없이 변경 될 수 있습니다. 배열이 동일한 지 직접 비교할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="e1e00f7b7a96013a7ac2150829df3b65546f70ca" translate="yes" xml:space="preserve">
          <source>A general address format on the form &lt;code&gt;{Family, Destination}&lt;/code&gt; where &lt;code&gt;Family&lt;/code&gt; is an atom such as &lt;code&gt;local&lt;/code&gt; and the format of &lt;code&gt;Destination&lt;/code&gt; depends on &lt;code&gt;Family&lt;/code&gt;, and is a complete address (for example an IP address including port number).</source>
          <target state="translated">&lt;code&gt;{Family, Destination}&lt;/code&gt; 형식의 일반 주소 형식입니다. 여기서 &lt;code&gt;Family&lt;/code&gt; 는 &lt;code&gt;local&lt;/code&gt; 과 같은 원자 이고 &lt;code&gt;Destination&lt;/code&gt; 의 형식은 &lt;code&gt;Family&lt;/code&gt; 에 따라 달라지며 완전한 주소 (예 : 포트 번호를 포함한 IP 주소)입니다.</target>
        </trans-unit>
        <trans-unit id="54ada27e365cb4a22611cb6a9989b7fa6327cde2" translate="yes" xml:space="preserve">
          <source>A general balanced set iterator.</source>
          <target state="translated">일반적인 밸런스 세트 반복자.</target>
        </trans-unit>
        <trans-unit id="abd2d7ccb70af9192a88e9078363ed031f3357e6" translate="yes" xml:space="preserve">
          <source>A general balanced set.</source>
          <target state="translated">일반적인 밸런스 세트.</target>
        </trans-unit>
        <trans-unit id="8cf5f3092481aa2537de6a0b5a55a3c05a0431e5" translate="yes" xml:space="preserve">
          <source>A general balanced tree iterator.</source>
          <target state="translated">균형 잡힌 트리 반복자.</target>
        </trans-unit>
        <trans-unit id="9983fa582405ead1dae547bcbe84a7f86c9c2c6a" translate="yes" xml:space="preserve">
          <source>A general balanced tree.</source>
          <target state="translated">균형 잡힌 나무.</target>
        </trans-unit>
        <trans-unit id="ef9ed8ddc12844f0870bb4f089487a9445710baf" translate="yes" xml:space="preserve">
          <source>A general function for creating Erlang terms using a format specifier and a corresponding set of arguments, much in the way &lt;code&gt;printf()&lt;/code&gt; works.</source>
          <target state="translated">&lt;code&gt;printf()&lt;/code&gt; 작동 하는 방식과 같이 형식 지정자와 해당 인수 세트를 사용하여 Erlang 용어를 작성하는 일반 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="2e207a92b9beca5dbcb01f63b66742b4b78e66b3" translate="yes" xml:space="preserve">
          <source>A general function for retrieving any kind of object from the registry.</source>
          <target state="translated">레지스트리에서 모든 종류의 객체를 검색하는 일반적인 기능입니다.</target>
        </trans-unit>
        <trans-unit id="59cb7a53195dd959efa385b2b1d8e6b04a5e665a" translate="yes" xml:space="preserve">
          <source>A generated error is when the code itself calls &lt;code&gt;exit/1&lt;/code&gt; or &lt;code&gt;throw/1&lt;/code&gt;. Notice that emulated run-time errors are not denoted as generated errors here.</source>
          <target state="translated">생성 된 오류는 코드 자체가 &lt;code&gt;exit/1&lt;/code&gt; 또는 &lt;code&gt;throw/1&lt;/code&gt; 을 호출하는 경우 입니다. 에뮬레이트 된 런타임 오류는 여기에서 생성 된 오류로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8faf45d14b7e5fe4683d094888fbeeed4fc63af0" translate="yes" xml:space="preserve">
          <source>A generic pretty printer library.</source>
          <target state="translated">일반적인 예쁜 프린터 라이브러리.</target>
        </trans-unit>
        <trans-unit id="96309c20b89273ad4e96e038b104fd007caed27f" translate="yes" xml:space="preserve">
          <source>A generic pretty printer library. This module uses a strict-style context passing implementation of John Hughes algorithm, described in &quot;The design of a Pretty-printing Library&quot;. The paragraph-style formatting, empty documents, floating documents, and null strings are my own additions to the algorithm.</source>
          <target state="translated">일반적인 예쁜 프린터 라이브러리. 이 모듈은 &quot;Pretty-Printing Library의 디자인&quot;에 설명 된 John Hughes 알고리즘의 엄격한 스타일 컨텍스트 전달 구현을 사용합니다. 단락 스타일 서식, 빈 문서, 부동 문서 및 null 문자열은 알고리즘에 추가 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="ac6a4400b941cc8bdd539f01f5213eda72cb86dc" translate="yes" xml:space="preserve">
          <source>A generic single object compare-and-swap operation:</source>
          <target state="translated">일반적인 단일 객체 비교 및 ​​스왑 작업 :</target>
        </trans-unit>
        <trans-unit id="3f766bd2ae406c1622999afa0312a1512bd99928" translate="yes" xml:space="preserve">
          <source>A generic state machine process (&lt;code&gt;gen_statem&lt;/code&gt;) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">이 모듈을 사용하여 구현 된 일반 상태 머신 프로세스 ( &lt;code&gt;gen_statem&lt;/code&gt; )에는 표준 인터페이스 기능 세트가 있으며 추적 및 오류보고 기능이 포함되어 있습니다. 또한 OTP 감독 트리에도 적합합니다. 자세한 내용은 &lt;code&gt;OTP Design Principles&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="17deb413c89fd01affc6582636308eea7c33a228" translate="yes" xml:space="preserve">
          <source>A generic state machine server process (&lt;code&gt;gen_statem&lt;/code&gt;) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">이 모듈을 사용하여 구현 된 일반 상태 머신 서버 프로세스 ( &lt;code&gt;gen_statem&lt;/code&gt; )에는 표준 인터페이스 기능 세트가 있으며 추적 및 오류보고 기능을 포함합니다. 또한 OTP 감독 트리에 적합합니다. 자세한 내용은 &lt;code&gt;OTP Design Principles&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a97b266d23ce2fe3a69cfab0ece23a4c06694585" translate="yes" xml:space="preserve">
          <source>A global group defined with &lt;code&gt;PublishType&lt;/code&gt; equal to &lt;code&gt;hidden&lt;/code&gt; is said to be a hidden global group. All nodes in a hidden global group are hidden nodes, whether they are started with command-line flag &lt;code&gt;-hidden&lt;/code&gt; or not.</source>
          <target state="translated">&lt;code&gt;hidden&lt;/code&gt; 과 같은 &lt;code&gt;PublishType&lt;/code&gt; 으로 정의 된 글로벌 그룹 은 숨겨진 글로벌 그룹이라고합니다. 숨겨진 글로벌 그룹의 모든 노드는 명령 행 플래그 &lt;code&gt;-hidden&lt;/code&gt; 으로 시작했는지 여부에 관계없이 숨겨진 노드 입니다.</target>
        </trans-unit>
        <trans-unit id="be16c14a618ebfab9ed6b6a24231e3d1ce85555b" translate="yes" xml:space="preserve">
          <source>A global name registration facility.</source>
          <target state="translated">세계적인 이름 등록 시설.</target>
        </trans-unit>
        <trans-unit id="5ca996b1105de3e2c7c27a0f7cfb576400f98429" translate="yes" xml:space="preserve">
          <source>A global trace flag for the Erlang node that makes all trace time stamps using flag &lt;code&gt;timestamp&lt;/code&gt; to be in CPU time, not wall clock time. That is, &lt;code&gt;cpu_timestamp&lt;/code&gt; is not be used if &lt;code&gt;monotonic_timestamp&lt;/code&gt; or &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; is enabled. Only allowed with &lt;code&gt;PidPortSpec==all&lt;/code&gt;. If the host machine OS does not support high-resolution CPU time measurements, &lt;code&gt;trace/3&lt;/code&gt; exits with &lt;code&gt;badarg&lt;/code&gt;. Notice that most OS do not synchronize this value across cores, so be prepared that time can seem to go backwards when using this option.</source>
          <target state="translated">플래그 &lt;code&gt;timestamp&lt;/code&gt; 스탬프를 사용하는 모든 추적 타임 스탬프를 벽시계 시간이 아닌 CPU 시간으로 만드는 Erlang 노드의 글로벌 추적 플래그입니다 . 즉, &lt;code&gt;cpu_timestamp&lt;/code&gt; 는 경우에 사용되지 &lt;code&gt;monotonic_timestamp&lt;/code&gt; 또는 &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; 이 활성화됩니다. &lt;code&gt;PidPortSpec==all&lt;/code&gt; 에만 허용됩니다 . 호스트 시스템 OS가 고해상도 CPU 시간 측정을 지원하지 않으면 &lt;code&gt;trace/3&lt;/code&gt; 가 &lt;code&gt;badarg&lt;/code&gt; 로 종료됩니다 . 대부분의 OS는 코어간에이 값을 동기화하지 않으므로이 옵션을 사용할 때 시간이 거꾸로 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a35f6209ff3e97a1fbff24a3ba0f5b7de01c5979" translate="yes" xml:space="preserve">
          <source>A good book explaining those reference texts is Dubuisson: ASN.1 - Communication Between Heterogeneous Systems, is free to download at &lt;code&gt;&lt;a href=&quot;http://www.oss.com/asn1/dubuisson.html&quot;&gt;http://www.oss.com/asn1/dubuisson.html&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">참고 문헌을 설명하는 좋은 책은 Dubuisson입니다. ASN.1-이기종 시스템 간 통신은 &lt;code&gt;&lt;a href=&quot;http://www.oss.com/asn1/dubuisson.html&quot;&gt;http://www.oss.com/asn1/dubuisson.html&lt;/a&gt;&lt;/code&gt; 에서 무료로 다운로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cb427e2a68f8e5f95a66a1dfb82ade3b982ce6f" translate="yes" xml:space="preserve">
          <source>A good start when programming efficiently is to know how much memory different data types and operations require. It is implementation-dependent how much memory the Erlang data types and other items consume, but the following table shows some figures for the &lt;code&gt;erts-8.0&lt;/code&gt; system in OTP 19.0.</source>
          <target state="translated">효율적으로 프로그래밍 할 때 좋은 시작은 서로 다른 데이터 유형과 작업에 필요한 메모리 양을 아는 것입니다. Erlang 데이터 유형 및 기타 항목이 소비하는 메모리 양은 구현에 따라 다르지만 다음 표는 OTP 19.0 의 &lt;code&gt;erts-8.0&lt;/code&gt; 시스템에 대한 일부 수치를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="104d4b7a2a11dda4f50138a2b0c530944556b6b2" translate="yes" xml:space="preserve">
          <source>A good way to check if more IO poll threads are needed is to use &lt;code&gt;microstate accounting&lt;/code&gt; and see what the load of the IO poll thread is. If it is high it could be a good idea to add more threads.</source>
          <target state="translated">더 많은 IO 폴 스레드가 필요한지 확인하는 좋은 방법은 &lt;code&gt;microstate accounting&lt;/code&gt; 을 사용 하고 IO 폴 스레드의로드가 무엇인지 확인하는 것입니다. 높으면 스레드를 더 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="902246acf44b902caba68cbdbd165ab3a85407bd" translate="yes" xml:space="preserve">
          <source>A grammar to parse list expressions (with empty associated code):</source>
          <target state="translated">목록 표현식을 구문 분석하는 문법 (빈 관련 코드 포함) :</target>
        </trans-unit>
        <trans-unit id="1046b82d616c92a5ac3eba8ae29c8d175e6a998a" translate="yes" xml:space="preserve">
          <source>A group nested under a parallel group starts executing in parallel with previous (parallel) test cases (no matter what properties the nested group has). However, as test cases are never executed in parallel with &lt;code&gt;init_per_group/2&lt;/code&gt; or &lt;code&gt;end_per_group/2&lt;/code&gt; of the same group, it is only after a nested group has finished that remaining parallel cases in the previous group become spawned.</source>
          <target state="translated">병렬 그룹 아래에 중첩 된 그룹은 중첩 된 그룹의 속성에 관계없이 이전 (병렬) 테스트 사례와 병렬로 실행을 시작합니다. 그러나 테스트 케이스는 동일한 그룹의 &lt;code&gt;init_per_group/2&lt;/code&gt; 또는 &lt;code&gt;end_per_group/2&lt;/code&gt; 와 병렬로 실행되지 않으므로 중첩 그룹이 완료된 후에 만 ​​이전 그룹의 나머지 병렬 케이스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2bac3d793bd4b0481740f078d1dd54e8fa1f7130" translate="yes" xml:space="preserve">
          <source>A group of functions or processes can be called within a transaction. A transaction can include statements that read, write, or delete data from the DBMS. Many such transactions can run concurrently, and the programmer does not need to explicitly synchronize the processes that manipulate the data.</source>
          <target state="translated">트랜잭션 내에서 함수 또는 프로세스 그룹을 호출 할 수 있습니다. 트랜잭션에는 DBMS에서 데이터를 읽거나 쓰거나 삭제하는 명령문이 포함될 수 있습니다. 이러한 많은 트랜잭션이 동시에 실행될 수 있으며 프로그래머는 데이터를 조작하는 프로세스를 명시 적으로 동기화 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="05cb23555bdd306501c7337362942fb611d143f7" translate="yes" xml:space="preserve">
          <source>A group of processes can be accessed by a common name. For example, if there is a group named &lt;code&gt;foobar&lt;/code&gt;, there can be a set of processes (which can be located on different nodes) that are all members of the group &lt;code&gt;foobar&lt;/code&gt;. There are no special functions for sending a message to the group. Instead, client functions are to be written with the functions &lt;code&gt;&lt;a href=&quot;#get_members-1&quot;&gt;get_members/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_local_members-1&quot;&gt;get_local_members/1&lt;/a&gt;&lt;/code&gt; to determine which processes are members of the group. Then the message can be sent to one or more group members.</source>
          <target state="translated">프로세스 그룹은 공통 이름으로 액세스 할 수 있습니다. 예를 들어, &lt;code&gt;foobar&lt;/code&gt; 라는 그룹이 있으면 그룹 &lt;code&gt;foobar&lt;/code&gt; 의 모든 구성원 인 프로세스 세트 (다른 ​​노드에 위치 할 수 있음)가있을 수 있습니다 . 그룹에 메시지를 보내기위한 특별한 기능은 없습니다. 대신 클라이언트 함수를 &lt;code&gt;&lt;a href=&quot;#get_members-1&quot;&gt;get_members/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#get_local_members-1&quot;&gt;get_local_members/1&lt;/a&gt;&lt;/code&gt; 함수로 작성 하여 그룹의 구성원 인 프로세스를 판별하십시오. 그런 다음 메시지를 하나 이상의 그룹 구성원에게 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a3229fa1db1fe8eed7e1f7d567d0b55b01718ab" translate="yes" xml:space="preserve">
          <source>A group that starts with (?| resets the capturing parentheses numbers in each alternative (see section &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt;). The assertions at the start of each branch check the next UTF-8 character for values whose encoding uses 1, 2, 3, or 4 bytes, respectively. The individual bytes of the character are then captured by the appropriate number of groups.</source>
          <target state="translated">(? |로 시작하는 그룹은 각 대안에서 캡처 괄호 번호를 재설정합니다 (섹션 &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; 참조 ). 각 분기의 시작 부분에있는 어설 션은 다음 UTF-8 문자에서 인코딩이 1, 2, 3, 그런 다음 문자의 개별 바이트는 적절한 수의 그룹에 의해 캡처됩니다.</target>
        </trans-unit>
        <trans-unit id="6db07dc0cd651815b5c72435ed2208f519f62680" translate="yes" xml:space="preserve">
          <source>A guard G is a non-empty sequence of guard tests &lt;code&gt;Gt_1, ..., Gt_k&lt;/code&gt;, and Rep(G) = &lt;code&gt;[Rep(Gt_1), ..., Rep(Gt_k)]&lt;/code&gt;.</source>
          <target state="translated">가드 G는 비어 있지 않은 가드 테스트 &lt;code&gt;Gt_1, ..., Gt_k&lt;/code&gt; 및 Rep (G) = &lt;code&gt;[Rep(Gt_1), ..., Rep(Gt_k)]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9da1b8fcba29590ca36e99b9fdb91354688f306d" translate="yes" xml:space="preserve">
          <source>A guard sequence Gs is a sequence of guards &lt;code&gt;G_1; ...; G_k&lt;/code&gt;, and Rep(Gs) = &lt;code&gt;[Rep(G_1), ..., Rep(G_k)]&lt;/code&gt;. If the guard sequence is empty, then Rep(Gs) = &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">가드 시퀀스 Gs는 가드 시퀀스 &lt;code&gt;G_1; ...; G_k&lt;/code&gt; 및 Rep (Gs) = &lt;code&gt;[Rep(G_1), ..., Rep(G_k)]&lt;/code&gt; 입니다. 가드 시퀀스가 ​​비어 있으면 Rep (Gs) = &lt;code&gt;[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2e607c9ab56bd394d6c9eeddb457df24a34026a6" translate="yes" xml:space="preserve">
          <source>A guard test Gt is one of the following:</source>
          <target state="translated">가드 테스트 Gt는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="0958ebfcb794773c3476244fc72f207f83085686" translate="yes" xml:space="preserve">
          <source>A handle to driver-specific data, passed to the driver callbacks. It is a pointer, and is most often type cast to a specific pointer in the driver.</source>
          <target state="translated">드라이버 별 데이터에 대한 핸들로 드라이버 콜백에 전달됩니다. 포인터이며 대부분 드라이버의 특정 포인터로 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="fdc243bdb933b5a71a48ce564407f75cabaaebaf" translate="yes" xml:space="preserve">
          <source>A handler callback module must export:</source>
          <target state="translated">핸들러 콜백 모듈은 다음을 내 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="678e5d07b0fa73bdf7fd807616029bb8f1f11655" translate="yes" xml:space="preserve">
          <source>A handler can be removed by calling &lt;code&gt;&lt;a href=&quot;logger#remove_handler-1&quot;&gt; logger:remove_handler(Id)&lt;/a&gt;&lt;/code&gt;. Logger calls &lt;code&gt;HModule:removing_handler(Config)&lt;/code&gt;, and removes the handler's configuration from the configuration database.</source>
          <target state="translated">핸들러는 &lt;code&gt;&lt;a href=&quot;logger#remove_handler-1&quot;&gt; logger:remove_handler(Id)&lt;/a&gt;&lt;/code&gt; 호출하여 제거 할 수 있습니다 . Logger는 &lt;code&gt;HModule:removing_handler(Config)&lt;/code&gt; 호출 하고 구성 데이터베이스에서 핸들러의 구성을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="31be10ebd1dea0e036e6cc2ff50b43986eb9b610" translate="yes" xml:space="preserve">
          <source>A handler can be removed by calling &lt;code&gt;&lt;a href=&quot;logger#remove_handler-1&quot;&gt;logger:remove_handler(Id)&lt;/a&gt;&lt;/code&gt;. Logger calls &lt;code&gt;HModule:removing_handler(Config)&lt;/code&gt;, and removes the handler's configuration from the configuration database.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;logger#remove_handler-1&quot;&gt;logger:remove_handler(Id)&lt;/a&gt;&lt;/code&gt; 호출하여 핸들러를 제거 할 수 있습니다 . 로거는 &lt;code&gt;HModule:removing_handler(Config)&lt;/code&gt; 호출 하고 구성 데이터베이스에서 처리기 구성을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="8b450cb00cc7d0fceaaaa8e163bad6a1a09d773b" translate="yes" xml:space="preserve">
          <source>A handler is defined as a module exporting at least the following callback function:</source>
          <target state="translated">핸들러는 최소한 다음 콜백 함수를 내보내는 모듈로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a23d43ddf6d207f81a92e3f11ea5d88e0322baa2" translate="yes" xml:space="preserve">
          <source>A hidden node is a node started with the command-line flag &lt;code&gt;-hidden&lt;/code&gt;. Connections between hidden nodes and other nodes are not transitive, they must be set up explicitly. Also, hidden nodes does not show up in the list of nodes returned by &lt;code&gt;nodes()&lt;/code&gt;. Instead, &lt;code&gt;nodes(hidden)&lt;/code&gt; or &lt;code&gt;nodes(connected)&lt;/code&gt; must be used. This means, for example, that the hidden node is not added to the set of nodes that &lt;code&gt;global&lt;/code&gt; is keeping track of.</source>
          <target state="translated">숨겨진 노드는 명령 행 플래그 &lt;code&gt;-hidden&lt;/code&gt; 으로 시작된 노드입니다 . 숨겨진 노드와 다른 노드 사이의 연결은 전 이적이지 않으므로 명시 적으로 설정해야합니다. 또한 숨겨진 노드는 &lt;code&gt;nodes()&lt;/code&gt; 반환 한 노드 목록에 나타나지 않습니다 . 대신 &lt;code&gt;nodes(hidden)&lt;/code&gt; 또는 &lt;code&gt;nodes(connected)&lt;/code&gt; 사용해야합니다. 이는 예를 들어 숨겨진 노드가 &lt;code&gt;global&lt;/code&gt; 이 추적하는 노드 세트에 추가되지 않음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="3ad527cdee0b441182ba0bc41ca62d2081d24f24" translate="yes" xml:space="preserve">
          <source>A histogram of block sizes where each interval's upper bound is twice as high as the one before it.</source>
          <target state="translated">각 간격의 상한이 이전보다 두 배 높은 블록 크기의 히스토그램입니다.</target>
        </trans-unit>
        <trans-unit id="ad63f98e4ec8a5df7f88023c80bfbc7bf7d5bd26" translate="yes" xml:space="preserve">
          <source>A hook function (cf. the &lt;code&gt;&lt;a href=&quot;#type-hook&quot;&gt;hook()&lt;/a&gt;&lt;/code&gt; type) is passed the current syntax tree node, the context, and a continuation. The context can be examined and manipulated by functions such as &lt;code&gt;get_ctxt_user/1&lt;/code&gt; and &lt;code&gt;set_ctxt_user/2&lt;/code&gt;. The hook must return a &quot;document&quot; data structure (see &lt;code&gt;&lt;a href=&quot;#layout-2&quot;&gt;layout/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#best-2&quot;&gt;best/2&lt;/a&gt;&lt;/code&gt;); this may be constructed in part or in whole by applying the continuation function. For example, the following is a trivial hook:</source>
          <target state="translated">후크 함수 ( &lt;code&gt;&lt;a href=&quot;#type-hook&quot;&gt;hook()&lt;/a&gt;&lt;/code&gt; 유형)는 현재 구문 트리 노드, 컨텍스트 및 연속으로 전달됩니다. 컨텍스트는 &lt;code&gt;get_ctxt_user/1&lt;/code&gt; 및 &lt;code&gt;set_ctxt_user/2&lt;/code&gt; 와 같은 함수로 검사하고 조작 할 수 있습니다 . 후크는 &quot;문서&quot;데이터 구조를 리턴해야합니다 ( &lt;code&gt;&lt;a href=&quot;#layout-2&quot;&gt;layout/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#best-2&quot;&gt;best/2&lt;/a&gt;&lt;/code&gt; 참조 ). 이것은 연속 기능을 적용함으로써 부분적으로 또는 전체적으로 구성 될 수있다. 예를 들어, 다음은 사소한 후크입니다.</target>
        </trans-unit>
        <trans-unit id="1edf358d74594d5d0d07749392202e53a874bde3" translate="yes" xml:space="preserve">
          <source>A job that alternates between I/O bound and CPU bound can be reclassified and rescheduled using &lt;code&gt;enif_schedule_nif&lt;/code&gt; so that it executes on the correct type of dirty scheduler at all times. For more information see the documentation of the &lt;code&gt;erl(1)&lt;/code&gt; command line arguments &lt;code&gt;&lt;a href=&quot;erl#+SDcpu&quot;&gt;+SDcpu&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;erl#+SDio&quot;&gt;+SDio&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enif_schedule_nif&lt;/code&gt; 를 사용하여 I / O 바운드와 CPU 바운드를 번갈아가는 작업을 다시 분류하고 다시 예약하여 항상 올바른 유형의 더티 스케줄러에서 실행할 수 있습니다 . 자세한 내용은 &lt;code&gt;erl(1)&lt;/code&gt; 명령 줄 인수 &lt;code&gt;&lt;a href=&quot;erl#+SDcpu&quot;&gt;+SDcpu&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;erl#+SDio&quot;&gt;+SDio&lt;/a&gt;&lt;/code&gt; 의 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="da4d22f9cc705b47b11f5556a6a98d52ebdf94f6" translate="yes" xml:space="preserve">
          <source>A key for des3 is a list of three iolists</source>
          <target state="translated">des3의 핵심은 세 가지 iolist의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="43bc46bb25920857aea5ff4cc78f13c35d6caf0e" translate="yes" xml:space="preserve">
          <source>A key to an entry in the session cache.</source>
          <target state="translated">세션 캐시의 항목에 대한 키입니다.</target>
        </trans-unit>
        <trans-unit id="58867f002dc318ccf9bce1131e2694062d5333ed" translate="yes" xml:space="preserve">
          <source>A larger buffer limit allows processes to buffer more outgoing messages over the distribution. When the buffer limit has been reached, sending processes will be suspended until the buffer size has shrunk. The buffer limit is per distribution channel. A higher limit gives lower latency and higher throughput at the expense of higher memory use.</source>
          <target state="translated">버퍼 제한이 크면 프로세스가 분배를 통해 더 많은 발신 메시지를 버퍼링 할 수 있습니다. 버퍼 제한에 도달하면 버퍼 크기가 줄어들 때까지 전송 프로세스가 일시 중단됩니다. 버퍼 한계는 분배 채널당입니다. 더 높은 한계는 더 높은 메모리 사용을 희생하면서 대기 시간을 줄이고 처리량을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="06a81726c24b8781e74e0cf024d9ccac67383c44" translate="yes" xml:space="preserve">
          <source>A level in term &lt;code&gt;CpuTopology&lt;/code&gt; can be omitted if only one entry exists and &lt;code&gt;InfoList&lt;/code&gt; is empty.</source>
          <target state="translated">항목이 하나만 있고 &lt;code&gt;InfoList&lt;/code&gt; 가 비어 있으면 &lt;code&gt;CpuTopology&lt;/code&gt; 라는 용어의 레벨을 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dce227656c4a97473171d894829d7b5055a34016" translate="yes" xml:space="preserve">
          <source>A library application that cannot be started or stopped, does not need any application callback module.</source>
          <target state="translated">시작하거나 중지 할 수없는 라이브러리 응용 프로그램은 응용 프로그램 콜백 모듈이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95d53ac43bdcd275e024568761344b42b310394a" translate="yes" xml:space="preserve">
          <source>A lightweight lookup in the table was the most important feature, but we also wanted to improve modifications of the table. The process table is modified when a new process is spawned, i.e. a new pointer is inserted into the table, and when a process terminates, i.e. a pointer is deleted in the table.</source>
          <target state="translated">테이블의 간단한 조회가 가장 중요한 기능 이었지만 테이블 수정도 개선하고 싶었습니다. 프로세스 테이블은 새 프로세스가 생성 될 때 수정됩니다. 즉, 새 포인터가 테이블에 삽입되고 프로세스가 종료 될 때 즉, 포인터가 테이블에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f1237e5b11078ec794450ace16c7850dee19ffaa" translate="yes" xml:space="preserve">
          <source>A line breakpoint can also be created (and deleted) by double-clicking the line when the module is displayed in the View Module window or Attach Process window.</source>
          <target state="translated">모듈이 모듈보기 창 또는 프로세스 연결 창에 표시 될 때 줄을 두 번 클릭하여 줄 바꿈 지점을 만들거나 삭제할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="25e27b31c8e51ff696a72775acff4cd63fac142f" translate="yes" xml:space="preserve">
          <source>A line breakpoint is created at a certain line in a module.</source>
          <target state="translated">줄 바꿈 지점은 모듈의 특정 줄에 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="98ca655fbbfd2af69c799f1de396c9692c8ffecf" translate="yes" xml:space="preserve">
          <source>A line level calls analysis of &lt;code&gt;channel&lt;/code&gt; can be written to a file using &lt;code&gt;cover:analysis_to_file/1&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;channel&lt;/code&gt; 의 라인 레벨 호출 분석은 &lt;code&gt;cover:analysis_to_file/1&lt;/code&gt; 을 사용하여 파일에 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="71f85c48df8221b4058723c56c5fee97655b5db6" translate="yes" xml:space="preserve">
          <source>A line with &lt;code&gt;//&lt;/code&gt; is also a comment. It is recommended to only use this style of comments in files that define implementations of instructions.</source>
          <target state="translated">&lt;code&gt;//&lt;/code&gt; 가 있는 줄 도 주석입니다. 명령 구현을 정의하는 파일에서만이 스타일의 주석을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="42c244651147c5c8032fa00f6a8115a6bb5b8002" translate="yes" xml:space="preserve">
          <source>A link between &lt;code&gt;To&lt;/code&gt; and &lt;code&gt;Result&lt;/code&gt; was set up on the node where &lt;code&gt;Result&lt;/code&gt; resides.</source>
          <target state="translated">사이의 연결 &lt;code&gt;To&lt;/code&gt; 및 &lt;code&gt;Result&lt;/code&gt; 노드에 설치 한 &lt;code&gt;Result&lt;/code&gt; 상주.</target>
        </trans-unit>
        <trans-unit id="30f9e5debe76dcfd36d855503d282295078ca73b" translate="yes" xml:space="preserve">
          <source>A link can be removed by calling the BIF &lt;code&gt;unlink(Pid)&lt;/code&gt;.</source>
          <target state="translated">BIF &lt;code&gt;unlink(Pid)&lt;/code&gt; 호출하여 링크를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8b621ff75576ed0db731737d0b2db8dd71853fd" translate="yes" xml:space="preserve">
          <source>A link existed between the local process and the remote process at the time of the crash.</source>
          <target state="translated">충돌시 로컬 프로세스와 원격 프로세스 사이에 링크가 존재했습니다.</target>
        </trans-unit>
        <trans-unit id="71334f2a43a0426d62a5d4505c43986a1e04107a" translate="yes" xml:space="preserve">
          <source>A link is broken. &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; contain the pids of the linked processes, and &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; contains the reason for the exit.</source>
          <target state="translated">링크가 끊어졌습니다. &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; 및 &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; 에는 링크 된 프로세스의 pid가 포함되고 &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; 에는 종료 이유가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ff85adc5284cadbc93a39945b54d30501de96451" translate="yes" xml:space="preserve">
          <source>A link or monitor to a remote process was broken because a connection between the nodes could not be established or was severed.</source>
          <target state="translated">노드 간의 연결을 설정할 수 없거나 끊어 졌기 때문에 원격 프로세스에 대한 링크 또는 모니터가 끊어졌습니다.</target>
        </trans-unit>
        <trans-unit id="f6d5b20cc777398a2954a5f904e0c368fb34c735" translate="yes" xml:space="preserve">
          <source>A link to all runs executed from a certain directory is written in the log named &lt;code&gt;all_runs.html&lt;/code&gt; and direct links to all tests (the latest results) are written to the top-level &lt;code&gt;index.html&lt;/code&gt;.</source>
          <target state="translated">특정 디렉토리에서 실행 된 모든 실행에 대한 링크는 &lt;code&gt;all_runs.html&lt;/code&gt; 로그에 작성되며 모든 테스트 (최신 결과)에 대한 직접 링크는 최상위 &lt;code&gt;index.html&lt;/code&gt; 에 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="c9ed186e6c9cb98bafec7585f14769f53a755b9c" translate="yes" xml:space="preserve">
          <source>A list comprehension returns a list, where the elements are the result of evaluating &lt;code&gt;Expr&lt;/code&gt; for each combination of generator list elements and bit string generator elements, for which all filters are true.</source>
          <target state="translated">목록 이해는 목록을 반환합니다. 여기서 요소는 모든 필터가 참인 생성기 목록 요소와 비트 문자열 생성기 요소의 각 조합에 대해 &lt;code&gt;Expr&lt;/code&gt; 을 평가 한 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="02a87e72df2e9591f46019f9ed75098ceee2e35d" translate="yes" xml:space="preserve">
          <source>A list comprehension:</source>
          <target state="translated">목록 이해 :</target>
        </trans-unit>
        <trans-unit id="7085d8980ae301152b6ee803668c44a99ddba230" translate="yes" xml:space="preserve">
          <source>A list is a compound data type with a variable number of terms.</source>
          <target state="translated">리스트는 가변 개수의 용어가 포함 된 복합 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="cdf78c94ee3134a5064c3958c1d7c8e4a3de8736" translate="yes" xml:space="preserve">
          <source>A list must be specified with the number of elements, including the tail, which is the last term preceding &lt;code&gt;ERL_DRV_LIST&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ERL_DRV_LIST&lt;/code&gt; 앞에 오는 마지막 용어 인 꼬리를 포함하여 여러 요소로 목록을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="70b8617890707dfd903ea1026d415236f1bdc921" translate="yes" xml:space="preserve">
          <source>A list of 'ActionReply' records possibly containing error indications.</source>
          <target state="translated">오류 표시가 포함 된 'ActionReply'레코드 목록입니다.</target>
        </trans-unit>
        <trans-unit id="51c375d52fb989d38f521acbea65939966bc14e9" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;UpdateOp&lt;/code&gt; can be supplied to do many update operations within the object. The operations are carried out in the order specified in the list. If the same counter position occurs more than once in the list, the corresponding counter is thus updated many times, each time based on the previous result. The return value is a list of the new counter values from each update operation in the same order as in the operation list. If an empty list is specified, nothing is updated and an empty list is returned. If the function fails, no updates are done.</source>
          <target state="translated">개체 내에서 많은 업데이트 작업을 수행하기 위해 &lt;code&gt;UpdateOp&lt;/code&gt; 목록을 제공 할 수 있습니다. 작업은 목록에 지정된 순서대로 수행됩니다. 동일한 카운터 위치가 목록에서 두 번 이상 나타나면 해당 카운터가 이전 결과에 따라 매번 여러 번 업데이트됩니다. 반환 값은 작업 목록과 동일한 순서로 각 업데이트 작업의 새 카운터 값 목록입니다. 빈 목록이 지정되면 아무것도 업데이트되지 않고 빈 목록이 반환됩니다. 기능이 실패하면 업데이트가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="030f0cbd94947cdf93b77d371b60c32ef8fca036" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;{Name, Memory}&lt;/code&gt; tuples, where &lt;code&gt;Name&lt;/code&gt; is a fragment &lt;code&gt;Name&lt;/code&gt;, and &lt;code&gt;Memory&lt;/code&gt; is how much memory it occupies</source>
          <target state="translated">&lt;code&gt;{Name, Memory}&lt;/code&gt; 튜플 의 목록 . 여기서 &lt;code&gt;Name&lt;/code&gt; 은 조각 &lt;code&gt;Name&lt;/code&gt; 이며 &lt;code&gt;Memory&lt;/code&gt; 는 차지하는 메모리 양입니다.</target>
        </trans-unit>
        <trans-unit id="c72f78c95adc9eeb9cf8ccea551cf18350671fbd" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;{Name, Size}&lt;/code&gt; tuples, where &lt;code&gt;Name&lt;/code&gt; is a fragment &lt;code&gt;Name&lt;/code&gt;, and &lt;code&gt;Size&lt;/code&gt; is how many records it contains</source>
          <target state="translated">&lt;code&gt;{Name, Size}&lt;/code&gt; 튜플 의 목록 . 여기서 &lt;code&gt;Name&lt;/code&gt; 은 조각 &lt;code&gt;Name&lt;/code&gt; 이며 &lt;code&gt;Size&lt;/code&gt; 는 포함 된 레코드 수입니다.</target>
        </trans-unit>
        <trans-unit id="e2180b4c9facbabd3ef7f26e9137ff364cfb6bb1" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;{Pos,Value}&lt;/code&gt; can be supplied to update many elements within the same object. If the same position occurs more than once in the list, the last value in the list is written. If the list is empty or the function fails, no updates are done. The function is also atomic in the sense that other processes can never see any intermediate results.</source>
          <target state="translated">&lt;code&gt;{Pos,Value}&lt;/code&gt; 목록을 제공하여 동일한 오브젝트 내에서 많은 요소를 업데이트 할 수 있습니다. 동일한 위치가 목록에서 두 번 이상 나타나면 목록의 마지막 값이 기록됩니다. 목록이 비어 있거나 기능이 실패하면 업데이트가 수행되지 않습니다. 이 기능은 다른 프로세스가 중간 결과를 볼 수 없다는 의미에서 원자 적입니다.</target>
        </trans-unit>
        <trans-unit id="b3c0a15b7c94f033790cb5a9578215ba2c5eb2b7" translate="yes" xml:space="preserve">
          <source>A list of &lt;strong&gt;release upgrade instructions&lt;/strong&gt;, see &lt;code&gt;&lt;a href=&quot;#Release%20Upgrade%20Instructions&quot;&gt;Release Upgrade Instructions&lt;/a&gt;&lt;/code&gt;. It is recommended to use high-level instructions only. These are automatically translated to low-level instructions by &lt;code&gt;systools&lt;/code&gt; when creating the &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">목록 &lt;strong&gt;릴리스 업그레이드 지침은&lt;/strong&gt; 참조 &lt;code&gt;&lt;a href=&quot;#Release%20Upgrade%20Instructions&quot;&gt;Release Upgrade Instructions&lt;/a&gt;&lt;/code&gt; . 고급 지침 만 사용하는 것이 좋습니다. 이것은 &lt;code&gt;relup&lt;/code&gt; 파일을 생성 할 때 &lt;code&gt;systools&lt;/code&gt; 에 의해 자동으로 저수준 명령어로 변환 됩니다 .</target>
        </trans-unit>
        <trans-unit id="9313069dff4ca94cf23c29546a7ad4ed8220831c" translate="yes" xml:space="preserve">
          <source>A list of DER-encoded certificates in trust order ending with the peer certificate.</source>
          <target state="translated">피어 인증서로 끝나는 신뢰 순서로 DER로 인코딩 된 인증서의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="cfdc5fa9c2f2d452137349f08f0ebdc7cd06e86e" translate="yes" xml:space="preserve">
          <source>A list of active checkpoints can be obtained with the following functions:</source>
          <target state="translated">활성 체크 포인트 목록은 다음 기능을 통해 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22e1cd424af636813424f38dcaf9d38efccd215c" translate="yes" xml:space="preserve">
          <source>A list of all valid Erlang Top configuration parameters is available in module &lt;code&gt;&lt;a href=&quot;etop&quot;&gt;etop&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">유효한 모든 Erlang Top 구성 매개 변수의 목록은 모듈 &lt;code&gt;&lt;a href=&quot;etop&quot;&gt;etop&lt;/a&gt;&lt;/code&gt; 에서 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="84f87e145849ab0fff970812ed60b4958a7995b9" translate="yes" xml:space="preserve">
          <source>A list of alternate dictionary modules with which to encode/decode AVPs that are not defined by the dictionary of the application in question. At decode, such AVPs are represented as diameter_avp records in the &lt;code&gt;'AVP'&lt;/code&gt; field of a decoded message or Grouped AVP, the first alternate that succeeds in decoding the AVP setting the record's value field. At encode, values in an &lt;code&gt;'AVP'&lt;/code&gt; list can be passed as AVP name/value 2-tuples, and it is an encode error for no alternate to define the AVP of such a tuple.</source>
          <target state="translated">해당 응용 프로그램의 사전에 의해 정의되지 않은 AVP를 인코딩 / 디코딩 할 대체 사전 모듈 목록입니다. 디코딩시, 그러한 &lt;code&gt;'AVP'&lt;/code&gt; 는 디코딩 된 메시지 의 'AVP' 필드 또는 그룹화 된 AVP의 레코드 _ 값 필드를 디코딩하는 첫 번째 대안 인 그룹화 된 AVP 에서 diameter_avp 레코드로 표현된다 . 인코딩시 &lt;code&gt;'AVP'&lt;/code&gt; 목록의 값은 AVP 이름 / 값 2 튜플로 전달 될 수 있으며 이러한 튜플의 AVP를 대체하는 것은 대체 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bcb8af967c3f5df09119723a75e7c020769c5e61" translate="yes" xml:space="preserve">
          <source>A list of application versions that the application depends on. An example of such an application version is &lt;code&gt;&quot;kernel-3.0&quot;&lt;/code&gt;. Application versions specified as runtime dependencies are minimum requirements. That is, a larger application version than the one specified in the dependency satisfies the requirement. For information about how to compare application versions, see section &lt;code&gt;Versions&lt;/code&gt; in the System Principles User's Guide.</source>
          <target state="translated">응용 프로그램이 의존하는 응용 프로그램 버전 목록. 이러한 응용 프로그램 버전의 예는 &lt;code&gt;&quot;kernel-3.0&quot;&lt;/code&gt; 입니다. 런타임 종속성으로 지정된 응용 프로그램 버전은 최소 요구 사항입니다. 즉, 종속성에 지정된 버전보다 큰 애플리케이션 버전이 요구 사항을 충족시킵니다. 응용 프로그램 버전을 비교하는 방법에 대한 자세한 내용은 시스템 원칙 사용 설명서의 &lt;code&gt;Versions&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85bcb2be6c30593796c07db13b64536f31aab04f" translate="yes" xml:space="preserve">
          <source>A list of applications that are included by an application included in the release. The list must be a subset of the included applications specified in the application resource file (&lt;code&gt;Application.app&lt;/code&gt;) and overrides this value. Defaults to the same value as in the application resource file.</source>
          <target state="translated">릴리스에 포함 된 응용 프로그램에 포함 된 응용 프로그램 목록입니다. 목록은 애플리케이션 자원 파일 ( &lt;code&gt;Application.app&lt;/code&gt; )에 지정된 포함 된 애플리케이션의 서브 세트 여야 하며이 값을 대체합니다. 기본적으로 응용 프로그램 자원 파일과 같은 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7501d56e7513156f76383768c05bf058cd48248a" translate="yes" xml:space="preserve">
          <source>A list of arbitrary socket options.</source>
          <target state="translated">임의의 소켓 옵션 목록입니다.</target>
        </trans-unit>
        <trans-unit id="73a81a79f1a7098f6cb205944af55c35f111d222" translate="yes" xml:space="preserve">
          <source>A list of atoms corresponding to atoms in the &lt;code&gt;NamedBitList&lt;/code&gt; in the &lt;code&gt;BIT STRING&lt;/code&gt; definition. A &lt;code&gt;BIT STRING&lt;/code&gt; with symbolic names is always decoded to the format shown in the following example:</source>
          <target state="translated">&lt;code&gt;BIT STRING&lt;/code&gt; 정의 에서 &lt;code&gt;NamedBitList&lt;/code&gt; 의 원자에 해당하는 원자 목록 . 기호 이름이 있는 &lt;code&gt;BIT STRING&lt;/code&gt; 은 항상 다음 예제에 표시된 형식으로 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="dad15913daed65e8f5cbb546acf62e2eac396099" translate="yes" xml:space="preserve">
          <source>A list of binaries. This datatype is useful to use together with &lt;code&gt;&lt;a href=&quot;erl_nif#enif_inspect_iovec&quot;&gt; enif_inspect_iovec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">바이너리 목록입니다. 이 데이터 유형은 &lt;code&gt;&lt;a href=&quot;erl_nif#enif_inspect_iovec&quot;&gt; enif_inspect_iovec&lt;/a&gt;&lt;/code&gt; 와 함께 사용하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="4416e89ecd0bec31a83597e47f21c9429cab1bb6" translate="yes" xml:space="preserve">
          <source>A list of binaries. This datatype is useful to use together with &lt;code&gt;&lt;a href=&quot;erl_nif#enif_inspect_iovec&quot;&gt;enif_inspect_iovec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">바이너리 목록. 이 데이터 유형은 &lt;code&gt;&lt;a href=&quot;erl_nif#enif_inspect_iovec&quot;&gt;enif_inspect_iovec&lt;/a&gt;&lt;/code&gt; 와 함께 사용하면 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="cc21ad3fb691b61137a500e7fa67b8eec7cc2074" translate="yes" xml:space="preserve">
          <source>A list of cipher suites that should be supported</source>
          <target state="translated">지원되어야하는 암호 그룹 목록</target>
        </trans-unit>
        <trans-unit id="64654646df6b843e592f4468159e2fedaaec3b28" translate="yes" xml:space="preserve">
          <source>A list of functions specified in option &lt;code&gt;Startup&lt;/code&gt; are executed after startup of the node. Notice that all used modules are to be present in the code path on &lt;code&gt;Host&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Startup&lt;/code&gt; 옵션에 지정된 기능 목록은 노드 시작 후 실행됩니다. 사용 된 모든 모듈이 &lt;code&gt;Host&lt;/code&gt; 의 코드 경로에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="33ed581a843666d74741e3c3b88fa9be23335a3f" translate="yes" xml:space="preserve">
          <source>A list of identifiers for all the processes, ports and NIF resources, that are monitoring the process.</source>
          <target state="translated">프로세스를 모니터링하는 모든 프로세스, 포트 및 NIF 리소스에 대한 식별자 목록입니다.</target>
        </trans-unit>
        <trans-unit id="b8da2df3aade9466893560d8879580f6ac7224df" translate="yes" xml:space="preserve">
          <source>A list of integers sets the generator's internal state directly, after algorithm-dependent checks of the value and masking to the proper word size.</source>
          <target state="translated">정수 목록은 알고리즘에 따라 값을 확인하고 적절한 단어 크기로 마스킹 한 후 생성기의 내부 상태를 직접 설정합니다.</target>
        </trans-unit>
        <trans-unit id="79b9f4cc16d6de8c7e19f996e3ff20895acaba69" translate="yes" xml:space="preserve">
          <source>A list of key-value tuples (that is, a property list) containing runtime configuration data passed from the configuration functions to the test cases.</source>
          <target state="translated">구성 함수에서 테스트 케이스로 전달 된 런타임 구성 데이터를 포함하는 키-값 튜플 목록 (즉, 특성 목록)입니다.</target>
        </trans-unit>
        <trans-unit id="53072cdf6c2b3e1f0ce0b618f29746a989ccb6e4" translate="yes" xml:space="preserve">
          <source>A list of low-level release upgrade instructions, see &lt;code&gt;&lt;a href=&quot;appup&quot;&gt;appup(4)&lt;/a&gt;&lt;/code&gt;. It consists of the release upgrade instructions from the respective application upgrade files (high-level instructions are translated to low-level instructions), in the same order as in the start script.</source>
          <target state="translated">저수준 릴리스 업그레이드 지침의 목록은 &lt;code&gt;&lt;a href=&quot;appup&quot;&gt;appup(4)&lt;/a&gt;&lt;/code&gt; 참조하십시오 . 시작 스크립트와 동일한 순서로 각 응용 프로그램 업그레이드 파일의 릴리스 업그레이드 지침 (높은 수준의 지침이 낮은 수준의 지침으로 변환 됨)으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="07cd63bd8b8a5bee2676cad933dc31cee7b4f8e9" translate="yes" xml:space="preserve">
          <source>A list of match specifications. An empty list is equivalent to &lt;code&gt;true&lt;/code&gt;. For a description of match specifications, see section &lt;code&gt; Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">일치 사양 목록입니다. 빈 목록은 &lt;code&gt;true&lt;/code&gt; 와 동일 합니다 . 일치 사양에 대한 설명은 사용자 가이드의 &lt;code&gt; Match Specifications in Erlang&lt;/code&gt; 에서 일치 사양 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5458cb9ed4430c9a1044722c1c9f0ec73351850" translate="yes" xml:space="preserve">
          <source>A list of match specifications. An empty list is equivalent to &lt;code&gt;true&lt;/code&gt;. For a description of match specifications, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">일치 사양 목록입니다. 빈 목록은 &lt;code&gt;true&lt;/code&gt; 와 같습니다 . 일치 사양에 대한 설명은 사용자 안내서 &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="139fe9d39aad421da9b537eadc3c0d0b13b2c1fe" translate="yes" xml:space="preserve">
          <source>A list of match specifications. The matching is done on the list &lt;code&gt;[Node, Sender, Msg]&lt;/code&gt;. &lt;code&gt;Node&lt;/code&gt; is the node name of the sender. &lt;code&gt;Sender&lt;/code&gt; is the process or port identity of the sender, or the atom &lt;code&gt;undefined&lt;/code&gt; if the sender is not known (which can be the case for remote senders). &lt;code&gt;Msg&lt;/code&gt; is the message term. The pid of the receiving process can be accessed with the guard function &lt;code&gt;self/0&lt;/code&gt;. An empty list is the same as &lt;code&gt;true&lt;/code&gt;. For more information, see section &lt;code&gt; Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">일치 사양 목록입니다. &lt;code&gt;[Node, Sender, Msg]&lt;/code&gt; 목록에서 일치가 수행됩니다 . &lt;code&gt;Node&lt;/code&gt; 는 보낸 사람의 노드 이름입니다. &lt;code&gt;Sender&lt;/code&gt; 는 보낸 사람 의 프로세스 또는 포트 ID이거나 보낸 사람을 알 수없는 경우 &lt;code&gt;undefined&lt;/code&gt; 원자 (원격 보낸 사람의 경우 일 수 있음)입니다. &lt;code&gt;Msg&lt;/code&gt; 는 메시지 용어입니다. 수신 프로세스의 pid는 가드 기능 &lt;code&gt;self/0&lt;/code&gt; 으로 액세스 할 수 있습니다 . 빈 목록은 &lt;code&gt;true&lt;/code&gt; 와 동일 합니다 . 자세한 내용 은 사용자 가이드의 &lt;code&gt; Match Specifications in Erlang&lt;/code&gt; 에서 일치 사양 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f24e9180cc135394011e3f9e98998139bc43ae7" translate="yes" xml:space="preserve">
          <source>A list of match specifications. The matching is done on the list &lt;code&gt;[Node, Sender, Msg]&lt;/code&gt;. &lt;code&gt;Node&lt;/code&gt; is the node name of the sender. &lt;code&gt;Sender&lt;/code&gt; is the process or port identity of the sender, or the atom &lt;code&gt;undefined&lt;/code&gt; if the sender is not known (which can be the case for remote senders). &lt;code&gt;Msg&lt;/code&gt; is the message term. The pid of the receiving process can be accessed with the guard function &lt;code&gt;self/0&lt;/code&gt;. An empty list is the same as &lt;code&gt;true&lt;/code&gt;. For more information, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">일치 사양 목록입니다. &lt;code&gt;[Node, Sender, Msg]&lt;/code&gt; 목록에서 일치 합니다. &lt;code&gt;Node&lt;/code&gt; 는 발신자의 노드 이름입니다. &lt;code&gt;Sender&lt;/code&gt; 은 보낸 사람 의 프로세스 또는 포트 ID이거나 , 보낸 사람을 알 수없는 경우 &lt;code&gt;undefined&lt;/code&gt; 아톰 (원격 보낸 사람의 경우 일 수 있음)입니다. &lt;code&gt;Msg&lt;/code&gt; 메시지 용어입니다. 수신 프로세스의 pid는 보호 기능 &lt;code&gt;self/0&lt;/code&gt; 으로 액세스 할 수 있습니다 . 빈 목록은 &lt;code&gt;true&lt;/code&gt; 와 동일 합니다 . 자세한 내용 은 사용 설명서의 &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d87f996d594a00d6035f5f5ee9ddba88e768355e" translate="yes" xml:space="preserve">
          <source>A list of match specifications. The matching is done on the list &lt;code&gt;[Receiver, Msg]&lt;/code&gt;. &lt;code&gt;Receiver&lt;/code&gt; is the process or port identity of the receiver and &lt;code&gt;Msg&lt;/code&gt; is the message term. The pid of the sending process can be accessed with the guard function &lt;code&gt;self/0&lt;/code&gt;. An empty list is the same as &lt;code&gt;true&lt;/code&gt;. For more information, see section &lt;code&gt; Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">일치 사양 목록입니다. &lt;code&gt;[Receiver, Msg]&lt;/code&gt; 목록에서 일치가 수행됩니다 . &lt;code&gt;Receiver&lt;/code&gt; 는 수신자 의 프로세스 또는 포트 ID이고 &lt;code&gt;Msg&lt;/code&gt; 는 메시지 용어입니다. 보내는 프로세스의 pid는 가드 함수 &lt;code&gt;self/0&lt;/code&gt; 으로 액세스 할 수 있습니다 . 빈 목록은 &lt;code&gt;true&lt;/code&gt; 와 동일 합니다 . 자세한 내용 은 사용자 가이드의 &lt;code&gt; Match Specifications in Erlang&lt;/code&gt; 에서 일치 사양 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ae6c5016a51b941ea9b569f5d1e616278b56ff4" translate="yes" xml:space="preserve">
          <source>A list of match specifications. The matching is done on the list &lt;code&gt;[Receiver, Msg]&lt;/code&gt;. &lt;code&gt;Receiver&lt;/code&gt; is the process or port identity of the receiver and &lt;code&gt;Msg&lt;/code&gt; is the message term. The pid of the sending process can be accessed with the guard function &lt;code&gt;self/0&lt;/code&gt;. An empty list is the same as &lt;code&gt;true&lt;/code&gt;. For more information, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">일치 사양 목록입니다. 일치는 &lt;code&gt;[Receiver, Msg]&lt;/code&gt; 목록에서 수행됩니다 . &lt;code&gt;Receiver&lt;/code&gt; 는 수신자 의 프로세스 또는 포트 ID이고 &lt;code&gt;Msg&lt;/code&gt; 는 메시지 용어입니다. 전송 프로세스의 pid는 보호 기능 &lt;code&gt;self/0&lt;/code&gt; 으로 액세스 할 수 있습니다 . 빈 목록은 &lt;code&gt;true&lt;/code&gt; 와 동일 합니다 . 자세한 내용 은 사용 설명서의 &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f891abb57f22c043046c0acca9828e5f72f099a9" translate="yes" xml:space="preserve">
          <source>A list of monitors (started by &lt;code&gt;monitor/2&lt;/code&gt;) that are active for the process. For a local process monitor or a remote process monitor by a process identifier, the list consists of:</source>
          <target state="translated">프로세스에 대해 활성 인 모니터 목록 ( &lt;code&gt;monitor/2&lt;/code&gt; 로 시작 ). 프로세스 ID 별 로컬 프로세스 모니터 또는 원격 프로세스 모니터의 경우 목록은 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="1e09e85b1d23a2d1904ace9e97601c063a94ad34" translate="yes" xml:space="preserve">
          <source>A list of node names (atoms), the group nodes.</source>
          <target state="translated">노드 이름 (원자), 그룹 노드 목록.</target>
        </trans-unit>
        <trans-unit id="f513e60b833a271eafeea13f285937ef60a9f36a" translate="yes" xml:space="preserve">
          <source>A list of node names, the group nodes currently synchronized with the local node.</source>
          <target state="translated">현재 노드 이름과 로컬 노드와 동기화 된 노드 이름 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d5813c5a7e310a9d07043782acc2491f544da810" translate="yes" xml:space="preserve">
          <source>A list of node names, the group nodes to which there are currently no connections.</source>
          <target state="translated">현재 연결이없는 그룹 노드 인 노드 이름 목록.</target>
        </trans-unit>
        <trans-unit id="ede2a365270db1734a514f8930fed986e258eb67" translate="yes" xml:space="preserve">
          <source>A list of node names, the group nodes with which the local node has failed to synchronize.</source>
          <target state="translated">로컬 노드가 동기화하지 못한 그룹 노드 인 노드 이름 목록.</target>
        </trans-unit>
        <trans-unit id="68320e1e6e32580922546695a30d4ffc50df4758" translate="yes" xml:space="preserve">
          <source>A list of objects and a continuation is returned, unless the table is empty, in which case &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. The continuation is to be used when matching further objects by calling &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테이블이 비어 있지 않으면 개체 목록과 연속이 반환됩니다.이 경우 &lt;code&gt;'$end_of_table'&lt;/code&gt; 이 반환됩니다. &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt; 을 호출하여 추가 객체를 일치시킬 때 연속이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="795b45a529dceb8a27da1be92835aa76262ca94d" translate="yes" xml:space="preserve">
          <source>A list of pids, specifying the processes that have subscribed to &lt;code&gt;nodeup&lt;/code&gt; and &lt;code&gt;nodedown&lt;/code&gt; messages.</source>
          <target state="translated">&lt;code&gt;nodeup&lt;/code&gt; 및 &lt;code&gt;nodedown&lt;/code&gt; 메시지를 구독 한 프로세스를 지정하는 pid 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="bbc2862b14b19fa3c52a7c39935bdc51459df8ec" translate="yes" xml:space="preserve">
          <source>A list of process identifiers monitoring the process (with &lt;code&gt;monitor/2&lt;/code&gt;).</source>
          <target state="translated">프로세스를 모니터링하는 프로세스 식별자 목록 ( &lt;code&gt;monitor/2&lt;/code&gt; 포함 )</target>
        </trans-unit>
        <trans-unit id="798f3c6d606c88936e16d8fb3e746a3c0d7e414f" translate="yes" xml:space="preserve">
          <source>A list of start phases and corresponding start arguments for the application. If this key is present, the application master, in addition to the usual call to &lt;code&gt;Module:start/2&lt;/code&gt;, also calls &lt;code&gt;Module:start_phase(Phase,Type,PhaseArgs)&lt;/code&gt; for each start phase defined by key &lt;code&gt;start_phases&lt;/code&gt;. Only after this extended start procedure, &lt;code&gt;application:start(Application)&lt;/code&gt; returns.</source>
          <target state="translated">응용 프로그램의 시작 단계 및 해당 시작 인수 목록. 이 키가 존재하는 경우, 응용 프로그램의 마스터에 일반 전화뿐만 아니라 &lt;code&gt;Module:start/2&lt;/code&gt; , 또한 호출 &lt;code&gt;Module:start_phase(Phase,Type,PhaseArgs)&lt;/code&gt; 키에 의해 정의 된 각 시작 단계에 &lt;code&gt;start_phases&lt;/code&gt; . 이 확장 된 시작 절차 후에 만 &lt;code&gt;application:start(Application)&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="edf21767ef6072f1fd3b3c1a6a4c7c161dc74414" translate="yes" xml:space="preserve">
          <source>A list of the characters in the matched token.</source>
          <target state="translated">일치하는 토큰의 문자 목록.</target>
        </trans-unit>
        <trans-unit id="8133b9a65a9c55bb804a98f418e83c6fd30bd2dd" translate="yes" xml:space="preserve">
          <source>A list of the nodes that do not exist</source>
          <target state="translated">존재하지 않는 노드 목록</target>
        </trans-unit>
        <trans-unit id="4787cc71f8b45d2d5a1e6a23232994156e3e6848" translate="yes" xml:space="preserve">
          <source>A list of the nodes where the server does not exist</source>
          <target state="translated">서버가 존재하지 않는 노드 목록</target>
        </trans-unit>
        <trans-unit id="23fbc37251525e0fbe5e6808d56771dd9e1bb61d" translate="yes" xml:space="preserve">
          <source>A list of the nodes where the server terminated before sending any reply.</source>
          <target state="translated">응답을 보내기 전에 서버가 종료 된 노드 목록.</target>
        </trans-unit>
        <trans-unit id="86b3af01504c95f1ff0a3bad6e86965e662943b1" translate="yes" xml:space="preserve">
          <source>A list of tokens produced by the scanner should end with a special &lt;code&gt;end_of_input&lt;/code&gt; tuple which the parser is looking for. The format of this tuple should be &lt;code&gt;{Endsymbol, LastLineNumber}&lt;/code&gt;, where &lt;code&gt;Endsymbol&lt;/code&gt; is an identifier that is distinguished from all the terminal and non-terminal categories of the syntax rules. The &lt;code&gt;Endsymbol&lt;/code&gt; may be declared in the grammar file (see below).</source>
          <target state="translated">스캐너가 생성 한 토큰 목록은 파서가 찾고 있는 특별한 &lt;code&gt;end_of_input&lt;/code&gt; 튜플로 끝나야 합니다. 이 튜플의 형식은 &lt;code&gt;{Endsymbol, LastLineNumber}&lt;/code&gt; 이어야합니다 . 여기서 &lt;code&gt;Endsymbol&lt;/code&gt; 은 구문 규칙의 모든 터미널 및 비 터미널 범주와 구별되는 식별자입니다. &lt;code&gt;Endsymbol&lt;/code&gt; 은 문법 파일에 선언 할 수있다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="c2109516cde7b07bab03027450759556426aff7c" translate="yes" xml:space="preserve">
          <source>A list of tuples containing results for individual schedulers as well as aggregated averages. &lt;code&gt;Util&lt;/code&gt; is the scheduler utilization as a floating point value between 0.0 and 1.0. &lt;code&gt;Percent&lt;/code&gt; is the same utilization as a more human readable string expressed in percent.</source>
          <target state="translated">개별 스케줄러의 결과와 집계 평균이 포함 된 튜플 목록입니다. &lt;code&gt;Util&lt;/code&gt; 은 0.0과 1.0 사이의 부동 소수점 값으로 스케줄러 사용률입니다. &lt;code&gt;Percent&lt;/code&gt; 은 백분율 로 표현 된 사람이 읽을 수있는 문자열과 동일한 활용률입니다.</target>
        </trans-unit>
        <trans-unit id="2ea742332d3293e5cbb6278b7055ef5cb1f029ed" translate="yes" xml:space="preserve">
          <source>A list of tuples, one for each function in a module, in decreasing &lt;code&gt;FuncCallCount&lt;/code&gt; order.</source>
          <target state="translated">&lt;code&gt;FuncCallCount&lt;/code&gt; 순서 를 줄이면서 모듈의 각 함수에 대해 하나씩 튜플 목록 .</target>
        </trans-unit>
        <trans-unit id="d414f3936cc6ab0feb3f8f3f242331f59448312d" translate="yes" xml:space="preserve">
          <source>A list of tuples, one for each module except &lt;code&gt;cprof&lt;/code&gt;, in decreasing &lt;code&gt;ModCallCount&lt;/code&gt; order.</source>
          <target state="translated">튜플들의 목록을 제외한 각 모듈에 대한 하나 &lt;code&gt;cprof&lt;/code&gt; 감소 시키는데, &lt;code&gt;ModCallCount&lt;/code&gt; 의 순서.</target>
        </trans-unit>
        <trans-unit id="2a515d4554cb24670f64c931a7f1c050e2d9f77e" translate="yes" xml:space="preserve">
          <source>A list representing the tail elements of list &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">list &lt;code&gt;t&lt;/code&gt; 의 tail 요소를 나타내는 목록 입니다.</target>
        </trans-unit>
        <trans-unit id="49c534723b00f62164b408805f640dc737cc5620" translate="yes" xml:space="preserve">
          <source>A list sorted as follows:</source>
          <target state="translated">다음과 같이 정렬 된 목록 :</target>
        </trans-unit>
        <trans-unit id="f5ef252277490863011469cba50309fcc2a552c0" translate="yes" xml:space="preserve">
          <source>A list where the tail is a list is sometimes called a &lt;strong&gt;proper list&lt;/strong&gt;. It is allowed to have a list where the tail is not a list, for example, &lt;code&gt;[a|b]&lt;/code&gt;. However, this type of list is of little practical use.</source>
          <target state="translated">꼬리가 목록 인 목록을 &lt;strong&gt;적절한 목록&lt;/strong&gt; 이라고도 &lt;strong&gt;합니다&lt;/strong&gt; . 테일이 목록이 아닌 목록을 가질 수 있습니다 (예 : &lt;code&gt;[a|b]&lt;/code&gt; . 그러나이 유형의 목록은 거의 실용적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="efe540ae45894e0fdbc313179169b5e104e7d954" translate="yes" xml:space="preserve">
          <source>A list with as many elements as the &lt;code&gt;Cols&lt;/code&gt; list Each element can be:</source>
          <target state="translated">&lt;code&gt;Cols&lt;/code&gt; 목록 만큼 많은 요소가있는 목록 각 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b2d1080e5c727bcb4180b6c054a8305dfd68dfc" translate="yes" xml:space="preserve">
          <source>A list with as many elements as the &lt;code&gt;Cols&lt;/code&gt; list, where each element is the value of the corresponding column. Each element can be:</source>
          <target state="translated">&lt;code&gt;Cols&lt;/code&gt; 목록 만큼의 요소가있는 목록. 각 요소는 해당 열의 값입니다. 각 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f4d38e7e775065b86b76958019e087be5338c72" translate="yes" xml:space="preserve">
          <source>A list with integers &amp;gt; 255 is considered an error if the Unicode translation modifier is not specified:</source>
          <target state="translated">유니 코드 변환 수정자를 지정하지 않으면 정수가 255보다 큰 목록은 오류로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="56ba062b97d1eab0e07bd7682980396fa3439b42" translate="yes" xml:space="preserve">
          <source>A list, empty or not</source>
          <target state="translated">비어 있거나없는 목록</target>
        </trans-unit>
        <trans-unit id="14565d44a02de06df96d7cafd4c87d042823638e" translate="yes" xml:space="preserve">
          <source>A listbox containing the names of all interpreted modules</source>
          <target state="translated">해석 된 모든 모듈의 이름이 포함 된 목록 상자</target>
        </trans-unit>
        <trans-unit id="d04bc0e41b8be3fc83734efd80c9fb1225163fbf" translate="yes" xml:space="preserve">
          <source>A listening transport presents its information slightly differently since there may be multiple accepted connections for the same &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;. The &lt;code&gt;transport&lt;/code&gt; info returned by a server with a single client connection might look as follows.</source>
          <target state="translated">수신 전송은 동일한 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 대해 여러 개의 허용 된 연결이있을 수 있으므로 정보가 약간 다르게 표시 됩니다. &lt;code&gt;transport&lt;/code&gt; 으로 보일 수 있습니다 단일 클라이언트 연결을 서버에 의해 반환되는 정보는 다음과 같다.</target>
        </trans-unit>
        <trans-unit id="9f635b77fbd8f2fa61daabd2f18c04196f559460" translate="yes" xml:space="preserve">
          <source>A literal &lt;code&gt;&lt;a href=&quot;#query_list_comprehension&quot;&gt;query list comprehension&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">리터럴 &lt;code&gt;&lt;a href=&quot;#query_list_comprehension&quot;&gt;query list comprehension&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17c58bfa57cd941d6af606b21964e3471f8b0dec" translate="yes" xml:space="preserve">
          <source>A literal data character</source>
          <target state="translated">리터럴 데이터 문자</target>
        </trans-unit>
        <trans-unit id="b9eff8ef6bae96d4d99cb1d0d45944faf85b28e0" translate="yes" xml:space="preserve">
          <source>A literal string can be written instead of an element:</source>
          <target state="translated">요소 대신 리터럴 문자열을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5bb25cde669006f83df9c8db3230c71118a01ae" translate="yes" xml:space="preserve">
          <source>A loaded NIF library is tied to the Erlang module instance that loaded it. If the module is upgraded, the new module instance needs to load its own NIF library (or maybe choose not to). The new module instance can, however, choose to load the exact same NIF library as the old code if it wants to. Sharing the dynamic library means that static data defined by the library is shared as well. To avoid unintentionally shared static data between module instances, each Erlang module version can keep its own private data. This private data can be set when the NIF library is loaded and later retrieved by calling &lt;code&gt;&lt;a href=&quot;#enif_priv_data&quot;&gt;enif_priv_data&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로드 된 NIF 라이브러리는이를로드 한 Erlang 모듈 인스턴스에 연결됩니다. 모듈이 업그레이드되면 새 모듈 인스턴스는 자체 NIF 라이브러리를로드해야합니다 (또는 선택하지 않을 수도 있음). 그러나 새 모듈 인스턴스는 원하는 경우 이전 코드와 동일한 NIF 라이브러리를로드하도록 선택할 수 있습니다. 동적 라이브러리를 공유한다는 것은 라이브러리에 의해 정의 된 정적 데이터도 공유됨을 의미합니다. 모듈 인스턴스간에 의도하지 않게 공유되는 정적 데이터를 피하기 위해 각 Erlang 모듈 버전은 고유 한 개인 데이터를 유지할 수 있습니다. 이 개인 데이터는 NIF 라이브러리가로드 된 후 &lt;code&gt;&lt;a href=&quot;#enif_priv_data&quot;&gt;enif_priv_data&lt;/a&gt;&lt;/code&gt; 를 호출하여 나중에 검색 될 때 설정 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b6d76f899d39de86797bece2df0524e5c5bc58f" translate="yes" xml:space="preserve">
          <source>A log file can be opened more than once by giving different values to option &lt;code&gt;name&lt;/code&gt; or by using the same file when distributing a log on different nodes. It is up to the user of module &lt;code&gt;disk_log&lt;/code&gt; to ensure that not more than one disk log process has write access to any file, otherwise the file can be corrupted.</source>
          <target state="translated">옵션 &lt;code&gt;name&lt;/code&gt; 다른 값을 지정 하거나 다른 노드에 로그를 분배 할 때 동일한 파일을 사용하여 로그 파일을 두 번 이상 열 수 있습니다 . 하나 이상의 디스크 로그 프로세스가 파일에 대한 쓰기 액세스 권한을 갖지 않도록하는 것은 &lt;code&gt;disk_log&lt;/code&gt; 모듈 사용자의 책임 입니다. 그렇지 않으면 파일이 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f75009c18af2951c814381c778a999ec618f179" translate="yes" xml:space="preserve">
          <source>A log file for one particular test case. Also called the test case log file.</source>
          <target state="translated">하나의 특정 테스트 사례에 대한 로그 파일. 테스트 케이스 로그 파일이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="6a0809efff21f90864c4f42725c904032725ee3b" translate="yes" xml:space="preserve">
          <source>A logical error is when a program does not behave as intended, but does not crash. An example is that nothing happens when a button in a graphical user interface is clicked.</source>
          <target state="translated">논리적 오류는 프로그램이 의도 한대로 작동하지 않지만 충돌하지 않는 경우입니다. 그래픽 사용자 인터페이스의 버튼을 클릭해도 아무런 변화가 없습니다.</target>
        </trans-unit>
        <trans-unit id="874913df600124a6285f4364c4fbf70b34e930c1" translate="yes" xml:space="preserve">
          <source>A long line can be broken into shorter lines by a placing a &lt;code&gt;\&lt;/code&gt; before the newline.</source>
          <target state="translated">줄 바꿈 앞에 &lt;code&gt;\&lt;/code&gt; 를 두면 긴 줄을 짧은 줄로 나눌 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ca61b37a0ea4d7b34c40913d6020ff25d24aa5f" translate="yes" xml:space="preserve">
          <source>A long queue of requests can cause a user-perceived delay, as earlier requests can take a long time to complete. The HTTP/1.1 specification suggests a limit of two persistent connections per server, which is the default value of option &lt;code&gt;max_sessions&lt;/code&gt;.</source>
          <target state="translated">이전 요청이 완료되는 데 시간이 오래 걸리므로 요청 대기열이 길면 사용자 인식 지연이 발생할 수 있습니다. HTTP / 1.1 스펙은 서버 당 두 개의 영구 연결 제한을 제안합니다. 이는 &lt;code&gt;max_sessions&lt;/code&gt; 옵션의 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="4935bb183b98bea21599c5ff3981cab6721e4f54" translate="yes" xml:space="preserve">
          <source>A macro &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; is replaced with &lt;code&gt;Replacement&lt;/code&gt;, where all occurrences of a variable &lt;code&gt;Var&lt;/code&gt; from the macro definition are replaced with the corresponding argument &lt;code&gt;Arg&lt;/code&gt;.</source>
          <target state="translated">매크로 &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; 로 대체되는 &lt;code&gt;Replacement&lt;/code&gt; 변수의 모든 항목, &lt;code&gt;Var&lt;/code&gt; 매크로 정의에서의 대응하는 인자로 대체 &lt;code&gt;Arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d257ea7c2cd44ef76446306fb9244bed68bdcdf" translate="yes" xml:space="preserve">
          <source>A macro &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; with a (possibly empty) list of arguments results in an error message if there is at least one definition of &lt;code&gt;Func&lt;/code&gt; with arguments, but none with N arguments.</source>
          <target state="translated">&lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; 있는 (비어있을 수있는) 인수 목록이 있는 매크로 ? Func (Arg1, ..., ArgN) 는 인수가 있는 &lt;code&gt;Func&lt;/code&gt; 정의가 하나 이상 있지만 N 개의 인수가없는 경우 오류 메시지를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="b1a7684d730263c657e047ab83e0ed99db2901a8" translate="yes" xml:space="preserve">
          <source>A macro can also be invoked from within another macro. For example, &lt;code&gt;move_deallocate_return/2&lt;/code&gt; avoids repeating code by invoking &lt;code&gt;$deallocate_return()&lt;/code&gt; as a macro:</source>
          <target state="translated">다른 매크로 내에서 매크로를 호출 할 수도 있습니다. 예를 들어 &lt;code&gt;move_deallocate_return/2&lt;/code&gt; 는 &lt;code&gt;$deallocate_return()&lt;/code&gt; 을 매크로로 호출하여 코드 반복을 방지합니다 .</target>
        </trans-unit>
        <trans-unit id="73f534c58d9ea31eaf8fb9427562c3ead1595373" translate="yes" xml:space="preserve">
          <source>A macro definition can be placed anywhere among the attributes and function declarations of a module, but the definition must come before any usage of the macro.</source>
          <target state="translated">매크로 정의는 모듈의 속성 및 함수 선언 중 어디에나 배치 할 수 있지만 정의는 매크로를 사용하기 전에 이루어져야합니다.</target>
        </trans-unit>
        <trans-unit id="98be1362f60e2ee14c3e74a98f904123979eba5e" translate="yes" xml:space="preserve">
          <source>A macro definition whose name and arity matches a family of specific instructions is assumed to be the implementation of that instruction.</source>
          <target state="translated">이름과 배열이 특정 명령어 제품군과 일치하는 매크로 정의는 해당 명령어의 구현으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="5ba3e72543889c84d73759d1071163c5b4427577" translate="yes" xml:space="preserve">
          <source>A macro definitions must start at the beginning of the line (no spaces allowed), the opening curly bracket must be on the same line, and the finishing curly bracket must be at the beginning of a line. It is recommended that the macro body is properly indented.</source>
          <target state="translated">매크로 정의는 줄의 시작 부분에서 시작해야하며 (공백은 허용되지 않음) 여는 중괄호는 같은 줄에 있어야하며 끝 중괄호는 줄의 시작 부분에 있어야합니다. 매크로 본문을 적절하게 들여 쓰기하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b023cfdfd3e8c944def982069911746c56dbb5ff" translate="yes" xml:space="preserve">
          <source>A macro is also used when spawning the server process:</source>
          <target state="translated">서버 프로세스를 생성 할 때에도 매크로가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7f21e1aec85a7381be96d5bfbfec7f097bd47be9" translate="yes" xml:space="preserve">
          <source>A macro is defined as follows:</source>
          <target state="translated">매크로는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="ce03814050d5f8680e3201e0fe96acef21b95f3d" translate="yes" xml:space="preserve">
          <source>A macro is used as follows:</source>
          <target state="translated">매크로는 다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="88726427099902153bb75f43bd476a92b9488c2a" translate="yes" xml:space="preserve">
          <source>A manager generates commands and receives notifications from agents. There usually are only a few managers in a system.</source>
          <target state="translated">관리자는 명령을 생성하고 에이전트로부터 알림을받습니다. 일반적으로 시스템에는 관리자가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="11e6d2013425970bf367a17f1b0c89bb48e7ff98" translate="yes" xml:space="preserve">
          <source>A map containing information about a specific thread. The percentages in the map can be either run-time or real-time depending on if &lt;code&gt;runtime&lt;/code&gt; or &lt;code&gt;realtime&lt;/code&gt; was requested from &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;system&lt;/code&gt; is the percentage of total system time for this specific thread.</source>
          <target state="translated">특정 스레드에 대한 정보가 포함 된 맵입니다. 맵의 백분율 은 &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;runtime&lt;/code&gt; 또는 &lt;code&gt;realtime&lt;/code&gt; 이 요청 되었는지에 따라 런타임 또는 실시간 일 수 있습니다. &lt;code&gt;system&lt;/code&gt; 은이 특정 스레드에 대한 총 시스템 시간의 백분율입니다.</target>
        </trans-unit>
        <trans-unit id="c1a5aa45e09b54b7bc479445ee3316a7d38b6bc0" translate="yes" xml:space="preserve">
          <source>A map containing the different microstate accounting states and the number of microseconds spent in it.</source>
          <target state="translated">다양한 마이크로 스테이트 회계 상태 및 마이크로 초 수를 포함하는 맵.</target>
        </trans-unit>
        <trans-unit id="55baef3a4a4f36d3a95ce66a57813b6156ada372" translate="yes" xml:space="preserve">
          <source>A map containing the different microstate accounting states. Each value in the map contains another map with the percentage of time that this thread has spent in the specific state. Both the percentage of &lt;code&gt;system&lt;/code&gt; time and the time for that specific &lt;code&gt;thread&lt;/code&gt; is part of the map.</source>
          <target state="translated">다른 마이크로 스테이트 회계 상태를 포함하는 맵. 맵의 각 값에는이 스레드가 특정 상태에서 보낸 시간의 백분율을 가진 다른 맵이 포함됩니다. &lt;code&gt;system&lt;/code&gt; 시간 의 백분율 과 해당 특정 &lt;code&gt;thread&lt;/code&gt; 의 시간 은 모두 맵의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="55c86ea1a266f601e2fcf39f41d436ed4bb1d415" translate="yes" xml:space="preserve">
          <source>A map is a compound data type with a variable number of key-value associations:</source>
          <target state="translated">맵은 가변 개수의 키-값 연관을 갖는 복합 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d505ce33814e76ba28c2120be515c6067e3749b3" translate="yes" xml:space="preserve">
          <source>A map iterator is only useful during the lifetime of environment &lt;code&gt;env&lt;/code&gt; that the &lt;code&gt;map&lt;/code&gt; belongs to. The iterator must be destroyed by calling &lt;code&gt;&lt;a href=&quot;#enif_map_iterator_destroy&quot;&gt; enif_map_iterator_destroy&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">지도 반복자는 환경의 수명 동안에만 유용 &lt;code&gt;env&lt;/code&gt; 것을 &lt;code&gt;map&lt;/code&gt; 에 속한다. 이터레이터는 &lt;code&gt;&lt;a href=&quot;#enif_map_iterator_destroy&quot;&gt; enif_map_iterator_destroy&lt;/a&gt;&lt;/code&gt; 를 호출하여 제거 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6df3d7501dc214f5a620dc3e70ec00231ed3a7da" translate="yes" xml:space="preserve">
          <source>A map iterator is only useful during the lifetime of environment &lt;code&gt;env&lt;/code&gt; that the &lt;code&gt;map&lt;/code&gt; belongs to. The iterator must be destroyed by calling &lt;code&gt;&lt;a href=&quot;#enif_map_iterator_destroy&quot;&gt;enif_map_iterator_destroy&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">지도 반복자는 환경의 수명 동안에만 유용 &lt;code&gt;env&lt;/code&gt; 것을 &lt;code&gt;map&lt;/code&gt; 에 속한다. &lt;code&gt;&lt;a href=&quot;#enif_map_iterator_destroy&quot;&gt;enif_map_iterator_destroy&lt;/a&gt;&lt;/code&gt; 를 호출하여 반복자를 제거해야합니다 .</target>
        </trans-unit>
        <trans-unit id="48183a4afcb12654d2835dae35952f5ae81cc70f" translate="yes" xml:space="preserve">
          <source>A map must be specified with the number of key-value pairs &lt;code&gt;N&lt;/code&gt;. The key-value pairs must precede the &lt;code&gt;ERL_DRV_MAP&lt;/code&gt; in this order: &lt;code&gt;key1,value1,key2,value2,...,keyN,valueN&lt;/code&gt;. Duplicate keys are not allowed.</source>
          <target state="translated">키-값 쌍 &lt;code&gt;N&lt;/code&gt; 의 수로 맵을 지정해야합니다 . 키-값 쌍은 &lt;code&gt;key1,value1,key2,value2,...,keyN,valueN&lt;/code&gt; 순서로 &lt;code&gt;ERL_DRV_MAP&lt;/code&gt; 앞에 와야합니다 . 중복 키는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31783f08d32874056a3057b68b1693f84e957994" translate="yes" xml:space="preserve">
          <source>A match specification can turn on or off sequential tracing. This function returns a match specification, which turns on sequential tracing with the specified &lt;code&gt;Flags&lt;/code&gt;.</source>
          <target state="translated">일치 스펙은 순차 추적을 켜거나 끌 수 있습니다. 이 함수는 일치 스펙을 리턴하며 지정된 &lt;code&gt;Flags&lt;/code&gt; 사용하여 순차 추적을 켭니다 .</target>
        </trans-unit>
        <trans-unit id="a6ddfb750b1e05982e25e257ab27afe27127e930" translate="yes" xml:space="preserve">
          <source>A match specification for &lt;code&gt;'receive'&lt;/code&gt; trace can use all guard and body functions except &lt;code&gt;caller&lt;/code&gt;, &lt;code&gt;is_seq_trace&lt;/code&gt;, &lt;code&gt;get_seq_token&lt;/code&gt;, &lt;code&gt;set_seq_token&lt;/code&gt;, &lt;code&gt;enable_trace&lt;/code&gt;, &lt;code&gt;disable_trace&lt;/code&gt;, &lt;code&gt;trace&lt;/code&gt;, &lt;code&gt;silent&lt;/code&gt;, and &lt;code&gt;process_dump&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'receive'&lt;/code&gt; 추적에 대한 일치 스펙은 &lt;code&gt;caller&lt;/code&gt; , &lt;code&gt;is_seq_trace&lt;/code&gt; , &lt;code&gt;get_seq_token&lt;/code&gt; , &lt;code&gt;set_seq_token&lt;/code&gt; , &lt;code&gt;enable_trace&lt;/code&gt; , &lt;code&gt;disable_trace&lt;/code&gt; , &lt;code&gt;trace&lt;/code&gt; , &lt;code&gt;silent&lt;/code&gt; 및 &lt;code&gt;process_dump&lt;/code&gt; 를 제외한 모든 가드 및 본문 기능을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c1a2a4c3c454f94b1fa52f933e896cf4b6f1dcf" translate="yes" xml:space="preserve">
          <source>A match specification for &lt;code&gt;send&lt;/code&gt; trace can use all guard and body functions except &lt;code&gt;caller&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; 추적에 대한 일치 스펙은 &lt;code&gt;caller&lt;/code&gt; 제외한 모든 가드 및 본문 기능을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="775d888e22b3e82c594b4190a83e5f1b3950e566" translate="yes" xml:space="preserve">
          <source>A match specification used in &lt;code&gt;ets(3)&lt;/code&gt; can be described in the following &lt;strong&gt;informal&lt;/strong&gt; grammar:</source>
          <target state="translated">&lt;code&gt;ets(3)&lt;/code&gt; 사용 된 일치 사양 은 다음과 같은 &lt;strong&gt;비공식&lt;/strong&gt; 문법 으로 설명 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83306dec354257cfad7ed48f591c0ff422b66b68" translate="yes" xml:space="preserve">
          <source>A match specification used in tracing can be described in the following &lt;strong&gt;informal&lt;/strong&gt; grammar:</source>
          <target state="translated">추적에 사용 된 일치 스펙은 다음과 같은 &lt;strong&gt;비공식&lt;/strong&gt; 문법에 설명 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3565e8901b4b3516619d211f5de1eb7c7f5a2de" translate="yes" xml:space="preserve">
          <source>A match specification, see above.</source>
          <target state="translated">일치 사양은 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="abb2961d578d0b3c60f269fc6add18fea6c7cde0" translate="yes" xml:space="preserve">
          <source>A match specifications with excessive nesting will cause a &lt;code&gt;&lt;a href=&quot;#ets_failures&quot;&gt;system_limit&lt;/a&gt;&lt;/code&gt; error exception to be raised.</source>
          <target state="translated">중첩이 과도하게 지정된 일치 스펙으로 인해 &lt;code&gt;&lt;a href=&quot;#ets_failures&quot;&gt;system_limit&lt;/a&gt;&lt;/code&gt; 오류 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bfda4d3ad9a01b6a5ad6d226917a35814c884393" translate="yes" xml:space="preserve">
          <source>A match with the string &quot;aaaa&quot; always fails, but the callout is taken before each backtrack occurs (in this example, 10 times).</source>
          <target state="translated">문자열 &quot;aaaa&quot;와의 일치는 항상 실패하지만 각 역 추적이 발생하기 전에 콜 아웃이 수행됩니다 (이 예에서는 10 번).</target>
        </trans-unit>
        <trans-unit id="6f29c903e3589affa8d324ed95b31c5c61e91931" translate="yes" xml:space="preserve">
          <source>A memory segment allocator. It is used by other allocators for allocating memory segments and is only available on systems that have the &lt;code&gt;mmap&lt;/code&gt; system call. Memory segments that are deallocated are kept for a while in a segment cache before they are destroyed. When segments are allocated, cached segments are used if possible instead of creating new segments. This to reduce the number of system calls made.</source>
          <target state="translated">메모리 세그먼트 할당 자. 다른 할당자가 메모리 세그먼트를 할당하는 데 사용하며 &lt;code&gt;mmap&lt;/code&gt; 시스템 호출 이있는 시스템에서만 사용할 수 있습니다 . 할당이 해제 된 메모리 세그먼트는 삭제되기 전에 세그먼트 캐시에 잠시 동안 유지됩니다. 세그먼트가 할당되면 가능한 경우 새 세그먼트를 작성하는 대신 캐시 된 세그먼트가 사용됩니다. 시스템 호출 횟수를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="12c52bcf9d23dfb0dbc1111b21b3e77c0d64c7e0" translate="yes" xml:space="preserve">
          <source>A middlebox which forwards ClientHello parameters it does not understand MUST NOT process any messages beyond that ClientHello. It MUST forward all subsequent traffic unmodified. Otherwise, it may fail to interoperate with newer clients and servers.</source>
          <target state="translated">이해하지 못하는 ClientHello 매개 변수를 전달하는 미들 박스는 ClientHello 이외의 메시지를 처리해서는 안됩니다. 모든 후속 트래픽을 수정하지 않고 전달해야합니다. 그렇지 않으면 최신 클라이언트 및 서버와 상호 운용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22559646ed04a3865a223cef10ef45e28e857451" translate="yes" xml:space="preserve">
          <source>A middlebox which terminates a TLS connection MUST behave as a compliant TLS server</source>
          <target state="translated">TLS 연결을 종료하는 미들 박스는 반드시 준수 TLS 서버로 동작해야합니다.</target>
        </trans-unit>
        <trans-unit id="95c010e88e46ea60a66fde46681834435a05128c" translate="yes" xml:space="preserve">
          <source>A minimal example of a NIF library can look as follows:</source>
          <target state="translated">NIF 라이브러리의 최소 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="87e74e52d3b9087104d60a0e55cc35f5604c3259" translate="yes" xml:space="preserve">
          <source>A minimum Windows NT installation with networking needs 250 MB, and an extra 130 MB for the swap file.</source>
          <target state="translated">네트워킹이 포함 된 최소 Windows NT 설치에는 250MB가 필요하고 스왑 파일에는 추가 130MB가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ccca12c026cce7e56e7fa3fc8b384f432861042d" translate="yes" xml:space="preserve">
          <source>A misbehaving filter will be removed.</source>
          <target state="translated">오작동하는 필터가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="06a13e586eee527b77c49434cc8f50ec42065c62" translate="yes" xml:space="preserve">
          <source>A module attribute consists of a tag and a value:</source>
          <target state="translated">모듈 속성은 태그와 값으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="dab39b0e69b099bf9e59a93c7991371da0a76b13" translate="yes" xml:space="preserve">
          <source>A module can also be used to represent a test set; see &lt;code&gt;ModuleName&lt;/code&gt; under &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; below.</source>
          <target state="translated">테스트 세트를 나타내는 데 모듈을 사용할 수도 있습니다. 아래 &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; 아래의 &lt;code&gt;ModuleName&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c521c6a7b79de7232798a925aa632173f772fa44" translate="yes" xml:space="preserve">
          <source>A module can be specified by its module name (atom) or filename.</source>
          <target state="translated">모듈은 모듈 이름 (아톰) 또는 파일 이름으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d45b4986dc3244ccb1e4bc16129b111cc4334f7" translate="yes" xml:space="preserve">
          <source>A module can export some types to declare that other modules are allowed to refer to them as &lt;strong&gt;remote types&lt;/strong&gt;. This declaration has the following form:</source>
          <target state="translated">모듈은 일부 유형을 내보내 다른 모듈이 해당 유형을 &lt;strong&gt;원격 유형&lt;/strong&gt; 으로 참조 할 수 있음을 선언 할 수 &lt;strong&gt;있습니다&lt;/strong&gt; . 이 선언의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7142355abe56d1cdac6e2f4354e4ece086ad515" translate="yes" xml:space="preserve">
          <source>A module can use data generated by previous modules in the Erlang webserver API module sequence or generate data to be used by consecutive Erlang Web Server API modules. This is possible owing to an internal list of key-value tuples, referred to as interaction data.</source>
          <target state="translated">모듈은 Erlang 웹 서버 API 모듈 순서에서 이전 모듈에 의해 생성 된 데이터를 사용하거나 연속적인 Erlang 웹 서버 API 모듈에 의해 사용될 데이터를 생성 할 수 있습니다. 상호 작용 데이터라고하는 내부 키-값 튜플 목록으로 인해 가능합니다.</target>
        </trans-unit>
        <trans-unit id="18900dbf59944d973af029df61cc566921cfdcc4" translate="yes" xml:space="preserve">
          <source>A module contains an &lt;code&gt;-on_load function&lt;/code&gt;.</source>
          <target state="translated">모듈에는 &lt;code&gt;-on_load function&lt;/code&gt; 가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93157c2c246b2925926264e6f2195084f98fb551" translate="yes" xml:space="preserve">
          <source>A module declaration consists of a sequence of forms, which are either function declarations or attributes.</source>
          <target state="translated">모듈 선언은 함수 선언 또는 속성 인 일련의 양식으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="610a0d8699dc82d5f83c6e9ce3301c3d01553b3b" translate="yes" xml:space="preserve">
          <source>A module implementing the &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; behaviour. The info functions of this module will be called at various stages of delivery.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; 동작을 구현하는 모듈 . 이 모듈의 정보 기능은 다양한 전달 단계에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c6984ab40887600f2a1370e3539c8ccdba1c5de4" translate="yes" xml:space="preserve">
          <source>A module is included more than once in &lt;code&gt;Modules&lt;/code&gt;.</source>
          <target state="translated">모듈은 더에 한 번 이상 포함되어있는 &lt;code&gt;Modules&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd8890dc272bd36c3a480c734c6925501fff4e99" translate="yes" xml:space="preserve">
          <source>A module specified as a &lt;code&gt;transport_module&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; must implement the interface documented here. The interface consists of a function with which diameter starts a transport process and a message interface with which the transport process communicates with the process that starts it (aka its parent).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; &lt;code&gt;transport_module&lt;/code&gt; 로 지정된 모듈은 여기에 문서화 된 인터페이스를 구현해야합니다. 인터페이스는 직경이 전송 프로세스를 시작하는 기능과 전송 프로세스가 시작 프로세스 (일명 상위)와 통신하는 메시지 인터페이스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="492b06093c2441b11284458e2b4d042f4ba5283d" translate="yes" xml:space="preserve">
          <source>A monitor can be removed by calling &lt;code&gt;erlang:demonitor(Ref)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:demonitor(Ref)&lt;/code&gt; 호출하여 모니터를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c985866a716b1f38553284b766cb9d078544843" translate="yes" xml:space="preserve">
          <source>A monitor created as &lt;code&gt;unloaded_only&lt;/code&gt; behaves exactly as one created as &lt;code&gt;unloaded&lt;/code&gt; except that the &lt;code&gt;{'UP', reference(), driver, Name, unload_cancelled}&lt;/code&gt; message is never sent, but the monitor instead persists until the driver &lt;strong&gt;really&lt;/strong&gt; gets unloaded.</source>
          <target state="translated">&lt;code&gt;unloaded_only&lt;/code&gt; 로 생성 된 모니터 는 &lt;code&gt;{'UP', reference(), driver, Name, unload_cancelled}&lt;/code&gt; 메시지가 전송되지 않는다는 점을 제외하고는 &lt;code&gt;unloaded&lt;/code&gt; 생성 된 것과 동일하게 동작 하지만 대신 모니터는 드라이버가 &lt;strong&gt;실제로&lt;/strong&gt; 언로드 될 때까지 지속 됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f4b0ba77513970218ad1a2b88d07cb4eef5317e" translate="yes" xml:space="preserve">
          <source>A monitor from &lt;code&gt;To&lt;/code&gt; to &lt;code&gt;Result&lt;/code&gt; was set up on the node where &lt;code&gt;Result&lt;/code&gt; resides.</source>
          <target state="translated">에서 모니터 &lt;code&gt;To&lt;/code&gt; 에 대한 &lt;code&gt;Result&lt;/code&gt; 노드에 설치 한 &lt;code&gt;Result&lt;/code&gt; 상주.</target>
        </trans-unit>
        <trans-unit id="0dcac2207e183cb309e308e8c36f24d54ce1572c" translate="yes" xml:space="preserve">
          <source>A monotonically increasing time provided by the Erlang runtime system. Erlang monotonic time increases since some unspecified point in time. To retrieve it, call &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt; erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 런타임 시스템에서 제공하는 단조롭게 증가하는 시간입니다. 어랭 단조 시간은 지정되지 않은 시점 이후로 증가합니다. 이를 검색하려면 &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt; erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="e224d8a9f9c0d94e691cbfa15fef0b1fe2f4e60f" translate="yes" xml:space="preserve">
          <source>A monotonically increasing time provided by the Erlang runtime system. Erlang monotonic time increases since some unspecified point in time. To retrieve it, call &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 런타임 시스템이 제공하는 단조 증가 시간. 얼랭 단조 시간은 지정되지 않은 특정 시점부터 증가합니다. 이를 검색하려면 &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="1bcff3bd090752a02621fd3d2ad9e629fddd5e95" translate="yes" xml:space="preserve">
          <source>A monotonically increasing time provided by the OS. This time does not leap and has a relatively steady frequency although not completely correct. However, it is not uncommon that OS monotonic time stops if the system is suspended. This time typically increases since some unspecified point in time that is not connected to &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt;. This type of time is not necessarily provided by all OSs.</source>
          <target state="translated">OS가 제공하는 단조 증가 시간. 이 시간은 완전히 정확하지는 않지만 도약하지 않고 상대적으로 안정적인 주파수를 갖습니다. 그러나 시스템이 일시 중단 된 경우 OS 단조로운 시간이 중지되는 것은 드문 일이 아닙니다. 이 시간은 일반적으로 &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 연결되지 않은 지정되지 않은 특정 시점이기 때문에 증가 합니다 . 이 유형의 시간이 모든 OS에서 제공되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5712c1400575e91c9656e681e7475784bdfd9eda" translate="yes" xml:space="preserve">
          <source>A more complicated example with two quad core processors, each processor in its own NUMA node. The ordering of logical processors is a bit weird. This to give a better example of identifier lists:</source>
          <target state="translated">두 개의 쿼드 코어 프로세서 (각각 자체 프로세서는 NUMA 노드에 있음)가있는보다 복잡한 예입니다. 논리 프로세서의 순서는 약간 이상합니다. 이것은 식별자 목록의 더 좋은 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a0d3ff79b050cf4e67f5f12480ec66e526e82e53" translate="yes" xml:space="preserve">
          <source>A more detailed internal representation of the state of this process.</source>
          <target state="translated">이 프로세스의 상태에 대한 자세한 내부 표현.</target>
        </trans-unit>
        <trans-unit id="2c7b4f8b72fc3001a39709ba6f707df737f50704" translate="yes" xml:space="preserve">
          <source>A more explicit way to cancel a timer is to use a &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; on the form &lt;code&gt; {TimeoutType, cancel} &lt;/code&gt; which is a feature introduced in OTP 22.1.</source>
          <target state="translated">타이머를 취소하는보다 명확한 방법 은 OTP 22.1에 도입 된 기능인 &lt;code&gt; {TimeoutType, cancel} &lt;/code&gt; 형식 의 &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; 을 사용하는 것 입니다. &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f3c43b55cc6e4ec72f53a82fa0f070f9038b700e" translate="yes" xml:space="preserve">
          <source>A more precise language for MIB specification</source>
          <target state="translated">MIB 사양을위한보다 정확한 언어</target>
        </trans-unit>
        <trans-unit id="d9a6a54885c00dec728fc7fc51d18dd588db7351" translate="yes" xml:space="preserve">
          <source>A more refined version of this format handler is function &lt;code&gt;handle_gc/4&lt;/code&gt; in module &lt;code&gt;multitrace.erl&lt;/code&gt; included in directory &lt;code&gt;src&lt;/code&gt; of the Observer application.</source>
          <target state="translated">이 형식 핸들러의보다 세련된 버전은 관찰자 애플리케이션의 디렉토리 &lt;code&gt;src&lt;/code&gt; 에 포함 된 &lt;code&gt;multitrace.erl&lt;/code&gt; 모듈의 &lt;code&gt;handle_gc/4&lt;/code&gt; 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="5d37f040ad3ea680b60e046bb149872d221815ff" translate="yes" xml:space="preserve">
          <source>A multi-lingual SNMP manager.</source>
          <target state="translated">다국어 SNMP 관리자.</target>
        </trans-unit>
        <trans-unit id="9e37a488733c4647d4a17da583fd3b03c8d0d81b" translate="yes" xml:space="preserve">
          <source>A name (an Erlang atom) associated with a data value read from a configuration file.</source>
          <target state="translated">구성 파일에서 읽은 데이터 값과 연관된 이름 (Erlang atom)입니다.</target>
        </trans-unit>
        <trans-unit id="2416bd3c84f93d0172f4762c1b29e0836c7a7539" translate="yes" xml:space="preserve">
          <source>A name and association to configuration data introduced through a require statement, or a call to &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;ct:require(mynodename,{node,[telnet]})&lt;/code&gt;.</source>
          <target state="translated">A는 문을 통해 필요한 구성 데이터 이름과 연관 도입하거나 호출 &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; 예를 들어, &lt;code&gt;ct:require(mynodename,{node,[telnet]})&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64a56d53bccebb00764e45b858a26b5ebf2ade91" translate="yes" xml:space="preserve">
          <source>A name constructed from the name of the function in which they are created</source>
          <target state="translated">생성 된 함수의 이름으로 구성된 이름</target>
        </trans-unit>
        <trans-unit id="ccf5e0e4e127bfae4bef5668c5a9b13172a11e7a" translate="yes" xml:space="preserve">
          <source>A name for the data must be allocated in the suite using &lt;code&gt;require&lt;/code&gt; (see the example above). Pass this name as argument &lt;code&gt;SnmpAppConfName&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;ct_snmp:start/3&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ct_snmp&lt;/code&gt; specifies default values for some &lt;code&gt;SNMP&lt;/code&gt; application configuration parameters (such as &lt;code&gt;{verbosity,trace}&lt;/code&gt; for parameter &lt;code&gt;config&lt;/code&gt;). This set of defaults is merged with the parameters specified by the user. The user values override &lt;code&gt;ct_snmp&lt;/code&gt; defaults.</source>
          <target state="translated">데이터 이름은 &lt;code&gt;require&lt;/code&gt; 를 사용하여 제품군에 할당해야 합니다 (위 예 참조). 인수로이 이름을 통과 &lt;code&gt;SnmpAppConfName&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;ct_snmp:start/3&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ct_snmp&lt;/code&gt; 는 일부 &lt;code&gt;SNMP&lt;/code&gt; 응용 프로그램 구성 매개 변수의 기본값을 지정합니다 (예 : 매개 변수 &lt;code&gt;config&lt;/code&gt; 의 &lt;code&gt;{verbosity,trace}&lt;/code&gt; ). 이 기본값 세트는 사용자가 지정한 매개 변수와 병합됩니다. 사용자 값은 &lt;code&gt;ct_snmp&lt;/code&gt; 기본값 보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="5489bf9abf580e46c80a7d46f5c6b357c56bfd5f" translate="yes" xml:space="preserve">
          <source>A name is always required with this verb. There can be as many instances of (*MARK) as you like in a pattern, and their names do not have to be unique.</source>
          <target state="translated">이 동사에는 항상 이름이 필요합니다. 패턴에서 원하는만큼 (* MARK) 인스턴스가있을 수 있으며 해당 이름은 고유하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="37561d5bd1b8f3c3ed788a8368cee35cffb7641d" translate="yes" xml:space="preserve">
          <source>A native function doing &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; before returning degrades responsiveness of the VM, and can cause miscellaneous strange behaviors. Such strange behaviors include, but are not limited to, extreme memory usage, and bad load balancing between schedulers. Strange behaviors that can occur because of lengthy work can also vary between Erlang/OTP releases.</source>
          <target state="translated">돌아 오기 전에 &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; 수행하는 기본 함수 는 VM의 응답 성을 저하 시키며 기타 이상한 동작을 유발할 수 있습니다. 이러한 이상한 동작에는 과도한 메모리 사용 및 스케줄러 간의 잘못된로드 밸런싱이 포함되지만 이에 국한되지는 않습니다. 긴 작업으로 인해 발생할 수있는 이상한 동작도 Erlang / OTP 릴리스마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="054cf9ceb563ed6f90ffbc9bbce068da6480e085" translate="yes" xml:space="preserve">
          <source>A native function is executed as a direct extension of the native code of the VM. Execution is not made in a safe environment. The VM &lt;strong&gt;cannot&lt;/strong&gt; provide the same services as provided when executing Erlang code, such as pre-emptive scheduling or memory protection. If the native function does not behave well, the whole VM will misbehave.</source>
          <target state="translated">기본 기능은 VM의 기본 코드를 직접 확장하여 실행됩니다. 안전한 환경에서 실행되지 않습니다. 선점 예약 또는 메모리 보호와 같이 Erlang 코드를 실행할 때 VM에서 제공 한 것과 동일한 서비스를 제공 할 &lt;strong&gt;수 없습니다&lt;/strong&gt; . 기본 기능이 제대로 작동하지 않으면 전체 VM이 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d7156f3c126c629744aa907155b989bd0af5b92" translate="yes" xml:space="preserve">
          <source>A native function that crash will crash the whole VM.</source>
          <target state="translated">충돌하는 기본 기능은 전체 VM을 중단시킵니다.</target>
        </trans-unit>
        <trans-unit id="1b2752eee15054c7525aaed65d65bee26e41c9b7" translate="yes" xml:space="preserve">
          <source>A native function that crashes will crash the whole VM.</source>
          <target state="translated">충돌하는 기본 기능은 전체 VM을 충돌시킵니다.</target>
        </trans-unit>
        <trans-unit id="a596b85ce60a4ebd518468dd4ada66946ee5ba8d" translate="yes" xml:space="preserve">
          <source>A native signed 64-bit integer type.</source>
          <target state="translated">기본 부호있는 64 비트 정수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d333b99d2c176e6cef29cdbe662fff2fc82351f6" translate="yes" xml:space="preserve">
          <source>A native unsigned 64-bit integer type.</source>
          <target state="translated">네이티브 부호없는 64 비트 정수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1a25fa736ef55d7f9c1d89a3af60f13910153e4c" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;WindowBits&lt;/code&gt; value makes zlib ignore the zlib header (and checksum) from the stream. Notice that the zlib source mentions this only as a undocumented feature.</source>
          <target state="translated">음의 &lt;code&gt;WindowBits&lt;/code&gt; 값은 zlib가 스트림에서 zlib 헤더 (및 체크섬)를 무시하게합니다. zlib 소스는이를 문서화되지 않은 기능으로 만 언급합니다.</target>
        </trans-unit>
        <trans-unit id="bff6f239743ba458b6fef3d31577263304f30dcc" translate="yes" xml:space="preserve">
          <source>A negative length can be used to extract bytes at the end of a binary:</source>
          <target state="translated">2 진의 끝에서 바이트를 추출하는 데 음수 길이를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a5647dc70e502438e63ae1f528d8168602285f6" translate="yes" xml:space="preserve">
          <source>A negative response can look as follows:</source>
          <target state="translated">부정적인 반응은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="acfd9f30ed035c8f515380634a9f49e2e6305307" translate="yes" xml:space="preserve">
          <source>A negative value causes the termination of the runtime system to wait indefinitely until the crash dump file has been completly written. This is the default if option &lt;code&gt;-heart&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; passed to &lt;code&gt;erl&lt;/code&gt; and &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; is not set.</source>
          <target state="translated">값이 음수이면 크래시 덤프 파일이 완전히 작성 될 때까지 런타임 시스템 종료가 무기한 대기합니다. 이 옵션의 경우 기본값은 &lt;code&gt;-heart&lt;/code&gt; 되어 &lt;strong&gt;하지&lt;/strong&gt; 에 전달 &lt;code&gt;erl&lt;/code&gt; 과 &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; 가 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ad2ef1372f693b05aa57e2e774e90e14b42ac7f" translate="yes" xml:space="preserve">
          <source>A network interface filter can e.g. be used during testing or for load regulation.</source>
          <target state="translated">네트워크 인터페이스 필터는 예를 들어 테스트 또는로드 레귤레이션에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0081be6ade151701784fff921945a2cc10ab3867" translate="yes" xml:space="preserve">
          <source>A network interface filter can e.g. be used during testing or for load regulation. If the intended use is load regulation, see also &lt;code&gt;&lt;a href=&quot;snmp_config#agent_ni_req_limit&quot;&gt;req_limit&lt;/a&gt;&lt;/code&gt; and the function &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;register_notification_filter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">네트워크 인터페이스 필터는 예를 들어 테스트 중에 또는 부하 조절에 사용할 수 있습니다. 의도 된 용도가 부하 조절 인 경우 &lt;code&gt;&lt;a href=&quot;snmp_config#agent_ni_req_limit&quot;&gt;req_limit&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;register_notification_filter&lt;/a&gt;&lt;/code&gt; 함수 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5da2ab0a310bd02dc005df1f2a390906381786a" translate="yes" xml:space="preserve">
          <source>A network interface filter can e.g. be used during testing or for load regulation. If the intended use is load regulation, see also &lt;code&gt;req_limit&lt;/code&gt; and the function &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;register_notification_filter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">네트워크 인터페이스 필터는 예를 들어 테스트 또는로드 레귤레이션에 사용될 수 있습니다. 의도 된 용도가 부하 조절 인 경우 &lt;code&gt;req_limit&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;register_notification_filter&lt;/a&gt;&lt;/code&gt; 함수 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7a37e856dd2d89d23cca0a3d2993676ef15b297" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;person&lt;/code&gt; record is created as follows:</source>
          <target state="translated">다음과 같이 새 &lt;code&gt;person&lt;/code&gt; 레코드가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="0cb57df1a585271753d77c0b683d96263a8aeb0a" translate="yes" xml:space="preserve">
          <source>A new boot script was generated, without the &lt;code&gt;local&lt;/code&gt; option set, before the release package was made. In the release package, all application directories are placed under &lt;code&gt;lib&lt;/code&gt;. You do not know where the release package will be installed, so no hard-coded absolute paths are allowed.</source>
          <target state="translated">릴리스 패키지가 작성되기 전에 &lt;code&gt;local&lt;/code&gt; 옵션이 설정 되지 않은 새 부트 스크립트가 생성 되었습니다. 릴리스 패키지에서 모든 응용 프로그램 디렉토리는 &lt;code&gt;lib&lt;/code&gt; 아래에 있습니다. 릴리스 패키지를 설치할 위치를 모르므로 하드 코드 된 절대 경로는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="207531ae5013e77eabff64456ffa724e18f8f181" translate="yes" xml:space="preserve">
          <source>A new config file format was introduced.</source>
          <target state="translated">새로운 구성 파일 형식이 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="0cd3d52715f74b16be431ae39bdcad7432af2c3a" translate="yes" xml:space="preserve">
          <source>A new interface &lt;code&gt;delete/1&lt;/code&gt; is now added to handle the case when a process wants to discard an index table (i.e. to build a completely new). Any application using transient snmp indexes has to be modified to handle this.</source>
          <target state="translated">프로세스가 인덱스 테이블을 버리려고 할 때 (즉, 완전히 새로운 것을 구축하려는 경우)를 처리하기 위해 새로운 인터페이스 &lt;code&gt;delete/1&lt;/code&gt; 이 추가되었습니다. 이를 처리하려면 임시 snmp 색인을 사용하는 모든 응용 프로그램을 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="f3852a09c1ed59005d5821e005f965364a5620d8" translate="yes" xml:space="preserve">
          <source>A new process is started by the application of &lt;code&gt;Module:Function&lt;/code&gt; to &lt;code&gt;Args&lt;/code&gt; on the node &lt;code&gt;Node&lt;/code&gt;. The process is monitored at the same time. Returns the process identifier and a reference for the monitor. Otherwise works like &lt;code&gt;&lt;a href=&quot;#spawn-3&quot;&gt;spawn/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 의 &lt;code&gt;Args&lt;/code&gt; 에 &lt;code&gt;Module:Function&lt;/code&gt; 을 적용하면 새 프로세스가 시작됩니다 . 프로세스는 동시에 모니터링됩니다. 프로세스 식별자와 모니터에 대한 참조를 반환합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;#spawn-3&quot;&gt;spawn/3&lt;/a&gt;&lt;/code&gt; 처럼 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="7813433a94ab5122a108632d44422a9630945f8c" translate="yes" xml:space="preserve">
          <source>A new process is started by the application of &lt;code&gt;Module:Function&lt;/code&gt; to &lt;code&gt;Args&lt;/code&gt;. The process is monitored at the same time. Returns the process identifier and a reference for the monitor. Otherwise works like &lt;code&gt;&lt;a href=&quot;#spawn-3&quot;&gt;spawn/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Module:Function&lt;/code&gt; to &lt;code&gt;Args&lt;/code&gt; 를 적용하면 새로운 프로세스가 시작됩니다 . 프로세스가 동시에 모니터링됩니다. 프로세스 식별자와 모니터에 대한 참조를 반환합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;#spawn-3&quot;&gt;spawn/3&lt;/a&gt;&lt;/code&gt; 처럼 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="4c6aeb17dbb1f994107439b1a93fe0bdeabaadd7" translate="yes" xml:space="preserve">
          <source>A new record has been written. &lt;code&gt;NewRecord&lt;/code&gt; contains the new record value and &lt;code&gt;OldRecords&lt;/code&gt; contains the records before the operation is performed. Notice that the new content depends on the table type.</source>
          <target state="translated">새로운 기록이 작성되었습니다. &lt;code&gt;NewRecord&lt;/code&gt; 는 새 레코드 값을 포함 하고 &lt;code&gt;OldRecords&lt;/code&gt; 는 작업이 수행되기 전에 레코드를 포함합니다. 새 내용은 테이블 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="eecdd1aca65c090cd037cecb43b60372b3e2d23d" translate="yes" xml:space="preserve">
          <source>A new record has been written. &lt;code&gt;NewRecord&lt;/code&gt; contains the new record value.</source>
          <target state="translated">새로운 기록이 작성되었습니다. &lt;code&gt;NewRecord&lt;/code&gt; 는 새로운 레코드 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="45c9322699414697ef1b7c8765e8214aef90bc96" translate="yes" xml:space="preserve">
          <source>A new tuple with the tag &lt;code&gt;available_memory&lt;/code&gt; will be added to the result when this value is provided by the kernel. The &lt;code&gt;available_memory&lt;/code&gt; value informs about the amount memory that is available for use if there is an increased memory need. This value is not based on a calculation of the other provided values and should give a better value of the amount of memory that actually is available than calculating a value based on the other values reported.</source>
          <target state="translated">이 값이 커널에 의해 제공되면 &lt;code&gt;available_memory&lt;/code&gt; 태그가있는 새 튜플 이 결과에 추가됩니다. &lt;code&gt;available_memory&lt;/code&gt; 증가 메모리 필요가있는 경우 사용할 수 있습니다 양의 메모리에 대한 값에 통지합니다. 이 값은 제공된 다른 값의 계산을 기반으로하지 않으며보고 된 다른 값을 기반으로 값을 계산하는 것보다 실제로 사용 가능한 메모리 양의 더 나은 값을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="bcbee27c7629c70c521974bc4a2ef6365b44965e" translate="yes" xml:space="preserve">
          <source>A new version of the &lt;code&gt;ch_app.app&lt;/code&gt; file must now be created, where the version is updated:</source>
          <target state="translated">&lt;code&gt;ch_app.app&lt;/code&gt; 파일 의 새 버전 이 생성되어 버전이 업데이트됩니다 :</target>
        </trans-unit>
        <trans-unit id="207842ca1ef434b687fe891079409854db11ce8f" translate="yes" xml:space="preserve">
          <source>A newline convention can also be specified by starting a pattern string with one of the following five sequences:</source>
          <target state="translated">다음 다섯 가지 시퀀스 중 하나를 사용하여 패턴 문자열을 시작하여 줄 바꿈 규칙을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="810a5966eb1e7ee3bb3f54687643fa10446c0bcc" translate="yes" xml:space="preserve">
          <source>A newly spawned Erlang process uses 309 words of memory in the non-SMP emulator without HiPE support. (SMP support and HiPE support both add to this size.) The size can be found as follows:</source>
          <target state="translated">새로 생성 된 Erlang 프로세스는 HiPE 지원없이 비 SMP 에뮬레이터에서 309 워드의 메모리를 사용합니다. (SMP 지원 및 HiPE 지원 모두이 크기에 추가됩니다.) 크기는 다음과 같이 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1297f35b745c72bd20c54efe3dd92735d746a15b" translate="yes" xml:space="preserve">
          <source>A newly started erlang shell shows that no &lt;code&gt;'ssh-dss'&lt;/code&gt; is present in the &lt;code&gt;public_key&lt;/code&gt; entry:</source>
          <target state="translated">새로 시작된 erlang 쉘은 &lt;code&gt;public_key&lt;/code&gt; 항목 에 &lt;code&gt;'ssh-dss'&lt;/code&gt; 가 없음을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="06c8c9ea0c1555c71b7dd9ae8ee6da8f6b7d0bc2" translate="yes" xml:space="preserve">
          <source>A nice feature is that a test specification that includes node information can still be used as input to the regular &lt;code&gt;Common Test&lt;/code&gt; server (as described in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt;). The result is that any test specified to run on a node with the same name as the &lt;code&gt;Common Test&lt;/code&gt; node in question (typically &lt;code&gt;ct@somehost&lt;/code&gt; if started with the &lt;code&gt;ct_run&lt;/code&gt; program), is performed. Tests without explicit node association are always performed too, of course.</source>
          <target state="translated">좋은 특징은 노드 정보를 포함하는 테스트 사양을 여전히 일반 &lt;code&gt;Common Test&lt;/code&gt; 서버 에 대한 입력으로 사용할 수 있다는 것 입니다 ( &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 섹션에 설명 된대로 ). 결과적으로 문제의 &lt;code&gt;Common Test&lt;/code&gt; 노드 와 동일한 이름을 가진 노드 (일반적으로 &lt;code&gt;ct_run&lt;/code&gt; 프로그램으로 시작한 경우 &lt;code&gt;ct@somehost&lt;/code&gt; 에서 실행되도록 지정된 테스트 가 수행됩니다. 물론 명시적인 노드 연결이없는 테스트도 항상 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7ee9953adae41a7655f8d2084b4fa873e00e82bf" translate="yes" xml:space="preserve">
          <source>A node can crash (probably a buggy one, hence traced). Use &lt;code&gt;resume&lt;/code&gt; to resume tracing on the node automatically when it gets back. The failing node then tries to reconnect to trace control node when &lt;code&gt;Runtime_Tools&lt;/code&gt; is started. This implies that &lt;code&gt;Runtime_Tools&lt;/code&gt; must be included in the startup chain of other nodes (if not, you can still resume tracing by starting &lt;code&gt;Runtime_Tools&lt;/code&gt; manually, that is, by an RPC call).</source>
          <target state="translated">노드가 충돌 할 수 있습니다 (아마도 버그가있는 노드이므로 추적 됨). 노드가 다시 돌아올 때 자동으로 노드에서 추적을 재개 하려면 &lt;code&gt;resume&lt;/code&gt; 을 사용하십시오 . 실패한 노드 는 &lt;code&gt;Runtime_Tools&lt;/code&gt; 가 시작될 때 추적 제어 노드에 다시 연결을 시도합니다 . 이는 &lt;code&gt;Runtime_Tools&lt;/code&gt; 가 다른 노드의 시작 체인에 포함되어 있어야 함을 의미합니다 (그렇지 않은 경우, RPC 호출에 의해 &lt;code&gt;Runtime_Tools&lt;/code&gt; 를 수동으로 시작하여 추적을 재개 할 수 있습니다 ).</target>
        </trans-unit>
        <trans-unit id="e9ed4743bc1cec802b20617a0fd885483b2dd9dc" translate="yes" xml:space="preserve">
          <source>A node fetches the port number of another node through the EPMD (at the other host) to initiate a connection request.</source>
          <target state="translated">노드는 EPMD를 통해 (다른 호스트에서) 다른 노드의 포트 번호를 가져와 연결 요청을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="4faa439d4cf9e40f5ce1dc04ca048d241e286cf4" translate="yes" xml:space="preserve">
          <source>A node of type &lt;code&gt;map_expr&lt;/code&gt; is a leaf node if and only if it has no argument and no fields. A node of type &lt;code&gt;map_type&lt;/code&gt; is a leaf node if and only if it has no fields (&lt;code&gt;any_size&lt;/code&gt;). A node of type &lt;code&gt;tuple&lt;/code&gt; is a leaf node if and only if its arity is zero. A node of type &lt;code&gt;tuple_type&lt;/code&gt; is a leaf node if and only if it has no elements (&lt;code&gt;any_size&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;map_expr&lt;/code&gt; 유형의 노드는 인수가 없고 필드가없는 경우에만 리프 노드입니다. &lt;code&gt;map_type&lt;/code&gt; 유형의 노드는 필드 ( &lt;code&gt;any_size&lt;/code&gt; ) 가없는 경우에만 리프 노드 입니다. &lt;code&gt;tuple&lt;/code&gt; 유형의 노드는 arity가 0 인 경우에만 리프 노드입니다. &lt;code&gt;tuple_type&lt;/code&gt; 유형의 노드는 요소가없는 경우 ( &lt;code&gt;any_size&lt;/code&gt; ) 리프 노드 입니다.</target>
        </trans-unit>
        <trans-unit id="cb52c93cebdeac0dab7fcc67ec63e9553ad8a863" translate="yes" xml:space="preserve">
          <source>A node running on Windows can only start slave nodes on the host on which it is running.</source>
          <target state="translated">Windows에서 실행중인 노드는 실행중인 호스트에서만 슬레이브 노드를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d21f5fbd84596b473f63ef2991ce0e43cba7cfb" translate="yes" xml:space="preserve">
          <source>A node started in this way is fully functional, using TLS as the distribution protocol.</source>
          <target state="translated">이 방법으로 시작된 노드는 분배 프로토콜로 TLS를 사용하여 완전히 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fc7f66a0ac45a7c84f0bb5f9e9d30342b7788580" translate="yes" xml:space="preserve">
          <source>A node started in this way will only be able to communicate with other nodes using SSL/TLS distribution over IPv6.</source>
          <target state="translated">이 방법으로 시작된 노드는 IPv6을 통한 SSL / TLS 배포를 사용하는 다른 노드와 만 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="943b5fd70c0828774c26840cbeb96989a96b92f2" translate="yes" xml:space="preserve">
          <source>A node started in this way will only be able to communicate with other nodes using TLS distribution over IPv6.</source>
          <target state="translated">이러한 방식으로 시작된 노드는 IPv6를 통한 TLS 배포를 사용하는 다른 노드와 만 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15e879d0b785427426139719e5c9dfe725a5b841" translate="yes" xml:space="preserve">
          <source>A node started with command-line flag &lt;code&gt;-hidden&lt;/code&gt; (see &lt;code&gt;erl(1)&lt;/code&gt;) is said to be a &lt;strong&gt;hidden&lt;/strong&gt; node. A hidden node establishes hidden connections to nodes not part of the same global group, but normal (visible) connections to nodes part of the same global group.</source>
          <target state="translated">명령 행 플래그 &lt;code&gt;-hidden&lt;/code&gt; ( &lt;code&gt;erl(1)&lt;/code&gt; 참조)으로 시작된 노드 는 &lt;strong&gt;숨겨진&lt;/strong&gt; 노드 라고 합니다. 숨겨진 노드는 동일한 글로벌 그룹의 일부가 아닌 동일한 글로벌 그룹의 노드에 대한 일반 (보이는) 연결에 대한 숨겨진 연결을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="20c980faeffa1454b2f85d7502b23e1c0b0103b4" translate="yes" xml:space="preserve">
          <source>A node unregisters itself from the EPMD by closing the TCP connection to EPMD established when the node was registered.</source>
          <target state="translated">노드는 등록시 설정된 EPMD에 대한 TCP 연결을 닫아 EPMD에서 자체 등록을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="d42befae27c8be5c2d1b9032dc8b9a0535e6021b" translate="yes" xml:space="preserve">
          <source>A node with a long node name cannot communicate with a node with a short node name.</source>
          <target state="translated">노드 이름이 긴 노드는 노드 이름이 짧은 노드와 통신 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5608a2aa0096e2c431c4d688274c5bfed3dfbe6a" translate="yes" xml:space="preserve">
          <source>A node with name &lt;code&gt;Name@Host&lt;/code&gt; already exists.</source>
          <target state="translated">&lt;code&gt;Name@Host&lt;/code&gt; 라는 이름 의 노드가 이미 존재합니다.</target>
        </trans-unit>
        <trans-unit id="9de4833cf4636cc7347017906607c0375ae36fb9" translate="yes" xml:space="preserve">
          <source>A non-local return from a function. If evaluated within a &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt; returns value &lt;code&gt;Any&lt;/code&gt;. Example:</source>
          <target state="translated">함수에서 로컬이 아닌 리턴. &lt;code&gt;catch&lt;/code&gt; 내에서 평가 되면 &lt;code&gt;catch&lt;/code&gt; 는 &lt;code&gt;Any&lt;/code&gt; 값을 반환합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="3104d91a116c49b17930265301a213974b99a618" translate="yes" xml:space="preserve">
          <source>A non-terminal category can be used at the left hand side (= &lt;code&gt;lhs&lt;/code&gt;, or &lt;code&gt;head&lt;/code&gt;) of a grammar rule. It can also appear at the right hand side of rules.</source>
          <target state="translated">비단 자 범주는 문법 규칙 의 왼쪽 (= &lt;code&gt;lhs&lt;/code&gt; 또는 &lt;code&gt;head&lt;/code&gt; ) 에서 사용할 수 있습니다 . 규칙의 오른쪽에 나타날 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="522676de41bafa253c8f310dce88c669f1124e1c" translate="yes" xml:space="preserve">
          <source>A nonempty list &lt;code&gt;[E1, ..., Ej]&lt;/code&gt; of syntax trees. This is equivalent to passing &lt;code&gt;conjunction([E1, ..., Ej])&lt;/code&gt;.</source>
          <target state="translated">구문 트리 의 비어 있지 않은 목록 &lt;code&gt;[E1, ..., Ej]&lt;/code&gt; 이것은 &lt;code&gt;conjunction([E1, ..., Ej])&lt;/code&gt; 를 전달하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a728b05450ce93eb12d475c06f9983d66527797f" translate="yes" xml:space="preserve">
          <source>A nonempty list of lists of syntax trees &lt;code&gt;[[E1_1, ..., E1_k1], ..., [Ej_1, ..., Ej_kj]]&lt;/code&gt;, which is equivalent to passing &lt;code&gt;disjunction([conjunction([E1_1, ..., E1_k1]), ..., conjunction([Ej_1, ..., Ej_kj])])&lt;/code&gt;.</source>
          <target state="translated">구문 트리의 목록 비어 있지 않은 목록 &lt;code&gt;[[E1_1, ..., E1_k1], ..., [Ej_1, ..., Ej_kj]]&lt;/code&gt; , 통과에 상당하는 &lt;code&gt;disjunction([conjunction([E1_1, ..., E1_k1]), ..., conjunction([Ej_1, ..., Ej_kj])])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfe0accad3b0782ec5f58066cb4e83f925efd4a7" translate="yes" xml:space="preserve">
          <source>A normal file is really a process so it can be used as an I/O device (see &lt;code&gt;io&lt;/code&gt;). Therefore, when data is written to a normal file, the sending of the data to the file process, copies all data that are not binaries. Opening the file in binary mode and writing binaries is therefore recommended. If the file is opened on another node, or if the file server runs as slave to the file server of another node, also binaries are copied.</source>
          <target state="translated">일반 파일은 실제로 프로세스이므로 I / O 장치로 사용할 수 있습니다 ( &lt;code&gt;io&lt;/code&gt; 참조 ). 따라서 데이터가 일반 파일에 기록 될 때 파일 프로세스로 데이터를 보내면 이진이 아닌 모든 데이터가 복사됩니다. 따라서 바이너리 모드에서 파일을 열고 바이너리를 작성하는 것이 좋습니다. 파일이 다른 노드에서 열리거나 파일 서버가 다른 노드의 파일 서버에 대한 슬레이브로 실행되는 경우 바이너리도 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="c470da7bdfad13769766d01b29332c73881e0c5a" translate="yes" xml:space="preserve">
          <source>A normal installation of Windows NT 4.0, with Service Pack 4 or later, is required for an embedded Windows NT running OTP.</source>
          <target state="translated">OTP를 실행하는 내장 된 Windows NT에는 서비스 팩 4 이상과 함께 Windows NT 4.0을 정상적으로 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9be4139254b3d41e2b3331c9e7f9cdccd473c9d" translate="yes" xml:space="preserve">
          <source>A normal scheduler thread.</source>
          <target state="translated">일반적인 스케줄러 스레드입니다.</target>
        </trans-unit>
        <trans-unit id="1ba3e6a43cfdf42b7ee92131fc56ef43d47532de" translate="yes" xml:space="preserve">
          <source>A notable return value is &lt;code&gt;{error, closed}&lt;/code&gt; indicating that the socket is closed.</source>
          <target state="translated">주목할만한 리턴 값은 소켓이 닫 혔음을 나타내는 &lt;code&gt;{error, closed}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3b3bb227d33cdecc5e31e4a78df3f54b111efcf9" translate="yes" xml:space="preserve">
          <source>A notation that tells which part of the type to be decoded</source>
          <target state="translated">디코딩 할 형식의 부분을 알려주는 표기법</target>
        </trans-unit>
        <trans-unit id="d7dc1e195006c9ad7d9414abaacea8ee8034b8fa" translate="yes" xml:space="preserve">
          <source>A notation that tells which parts of the message structure to be excluded from decode</source>
          <target state="translated">메시지 구조에서 디코딩에서 제외 할 부분을 알려주는 표기법</target>
        </trans-unit>
        <trans-unit id="027b96af0679f806c12b49fa73f516241d045fca" translate="yes" xml:space="preserve">
          <source>A note of warning: Igor cannot do anything about the case when the name of a remote function is passed to the built-in functions &lt;code&gt;apply&lt;/code&gt; and &lt;code&gt;spawn&lt;/code&gt;&lt;strong&gt;unless&lt;/strong&gt; the module and function names are explicitly stated in the call, as in e.g. &lt;code&gt;apply(lists, reverse, [Xs])&lt;/code&gt;. In all other cases, Igor leaves such calls unchanged, and warns the user that manual editing might be necessary.</source>
          <target state="translated">경고주의 사항 : 원격 함수의 이름이 내장 함수에 전달 될 때 이고르 사건에 대해 아무것도 할 수 없습니다 &lt;code&gt;apply&lt;/code&gt; 하고 &lt;code&gt;spawn&lt;/code&gt; &lt;strong&gt;하지 않는&lt;/strong&gt; 모듈 및 기능 이름이 명시 적으로 호출에 명시되어 예에서와 같이하는 &lt;code&gt;apply(lists, reverse, [Xs])&lt;/code&gt; . 다른 모든 경우에 Igor는 이러한 호출을 변경하지 않고 수동 편집이 필요할 수 있음을 사용자에게 경고합니다.</target>
        </trans-unit>
        <trans-unit id="bb34c061995c9bd9c3bf3fd5336b0597518696e6" translate="yes" xml:space="preserve">
          <source>A notification filter is a module implementing the &lt;code&gt;&lt;a href=&quot;snmpa_notification_filter&quot;&gt;snmpa_notification_filter&lt;/a&gt;&lt;/code&gt; behaviour. A filter is added/deleted using the functions: &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;snmpa:register_notification_filter&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmpa#unregister_notification_filter&quot;&gt;snmpa:unregister_notification_filter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">알림 필터는 &lt;code&gt;&lt;a href=&quot;snmpa_notification_filter&quot;&gt;snmpa_notification_filter&lt;/a&gt;&lt;/code&gt; 동작을 구현하는 모듈 입니다. &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;snmpa:register_notification_filter&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;snmpa#unregister_notification_filter&quot;&gt;snmpa:unregister_notification_filter&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 필터가 추가 / 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="23a7337393f51adec78486c788d793b331d07279" translate="yes" xml:space="preserve">
          <source>A nullary functional value (i.e., a fun that takes zero arguments). Examples:</source>
          <target state="translated">nullary 기능 값 (즉, 인수가 0 인 재미) 예 :</target>
        </trans-unit>
        <trans-unit id="e5362e0c25c0703bb5ca7c53501e9fabd30aa894" translate="yes" xml:space="preserve">
          <source>A number (starting with 0) indicating the number of that fun within that function</source>
          <target state="translated">해당 함수 내에서 해당 재미의 숫자를 나타내는 숫자 (0으로 시작)</target>
        </trans-unit>
        <trans-unit id="cf27cfd569963d1d3e948b114051da6fdcf3d00a" translate="yes" xml:space="preserve">
          <source>A number of objects must be present for the SSH application to work. Thoose objects are per default stored in files. The default names, paths and file formats are the same as for &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt;. Keys could be generated with the &lt;code&gt;ssh-keygen&lt;/code&gt; program from OpenSSH. See the &lt;code&gt;&lt;a href=&quot;using_ssh#running-an-erlang-ssh-daemon&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SSH 응용 프로그램이 작동하려면 많은 개체가 있어야합니다. 선택한 객체는 기본적으로 파일에 저장됩니다. 기본 이름, 경로 및 파일 형식은 &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt; 와 동일 합니다 . OpenSSH 의 &lt;code&gt;ssh-keygen&lt;/code&gt; 프로그램으로 키를 생성 할 수 있습니다 . 사용 &lt;code&gt;&lt;a href=&quot;using_ssh#running-an-erlang-ssh-daemon&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba15943266d8f4ba14bfaf35d8549aabc72bd73a" translate="yes" xml:space="preserve">
          <source>A number of objects must be present for the SSH application to work. Those objects are per default stored in files. The default names, paths and file formats are the same as for &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt;. Keys could be generated with the &lt;code&gt;ssh-keygen&lt;/code&gt; program from OpenSSH. See the &lt;code&gt;&lt;a href=&quot;using_ssh#running-an-erlang-ssh-daemon&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SSH 응용 프로그램이 작동하려면 여러 개체가 있어야합니다. 이러한 개체는 기본적으로 파일에 저장됩니다. 기본 이름, 경로 및 파일 형식은 &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt; 와 동일 합니다 . OpenSSH 의 &lt;code&gt;ssh-keygen&lt;/code&gt; 프로그램으로 키를 생성 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;using_ssh#running-an-erlang-ssh-daemon&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c32086c997452421cf26bca4ec5f8f37980a88f" translate="yes" xml:space="preserve">
          <source>A one-line description of the application.</source>
          <target state="translated">응용 프로그램에 대한 한 줄 설명.</target>
        </trans-unit>
        <trans-unit id="7676e10e4c0c5db81948c82045b717673602dd63" translate="yes" xml:space="preserve">
          <source>A one-shot timer, that is, a timer created by evaluating any of the functions &lt;code&gt;&lt;a href=&quot;#apply_after-4&quot;&gt;apply_after/4&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#send_after-3&quot;&gt;send_after/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#send_after-2&quot;&gt;send_after/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#exit_after-3&quot;&gt;exit_after/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#exit_after-2&quot;&gt;exit_after/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#kill_after-2&quot;&gt;kill_after/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#kill_after-1&quot;&gt;kill_after/1&lt;/a&gt;&lt;/code&gt; is not linked to any process. Hence, such a timer is removed only when it reaches its time-out, or if it is explicitly removed by a call to &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">one-shot 타이머, 즉 &lt;code&gt;&lt;a href=&quot;#apply_after-4&quot;&gt;apply_after/4&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#send_after-3&quot;&gt;send_after/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#send_after-2&quot;&gt;send_after/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#exit_after-3&quot;&gt;exit_after/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#exit_after-2&quot;&gt;exit_after/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#kill_after-2&quot;&gt;kill_after/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#kill_after-1&quot;&gt;kill_after/1&lt;/a&gt;&lt;/code&gt; 함수를 평가하여 작성된 타이머 가 연결되지 않았습니다. 어떤 프로세스. 따라서 이러한 타이머는 시간 초과에 도달하거나 &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt; 호출로 명시 적으로 제거 된 경우에만 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="652f0a6b7da70ccce812924b966b0be33a66985d" translate="yes" xml:space="preserve">
          <source>A packet is a line-terminated by a delimiter byte, default is the latin-1 newline character. The delimiter byte is included in the returned packet unless the line was truncated according to option &lt;code&gt;line_length&lt;/code&gt;.</source>
          <target state="translated">패킷은 구분 기호 바이트로 끝나는 행이며 기본값은 라틴 -1 개행 문자입니다. &lt;code&gt;line_length&lt;/code&gt; 옵션에 따라 행이 잘리지 않으면 분리 문자 바이트가 리턴 된 패킷에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="243cae021af59d36fb2ba67a11310414b8344606" translate="yes" xml:space="preserve">
          <source>A pair &lt;code&gt;{LineNumber, SimpleTest}&lt;/code&gt;, where &lt;code&gt;LineNumber&lt;/code&gt; is a nonnegative integer and &lt;code&gt;SimpleTest&lt;/code&gt; is another simple test object. &lt;code&gt;LineNumber&lt;/code&gt; should indicate the source line of the test. Pairs like this are usually only created via &lt;code&gt;?_test(...)&lt;/code&gt; macros; see &lt;code&gt;&lt;a href=&quot;#Basic_macros&quot;&gt;Basic macros&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{LineNumber, SimpleTest}&lt;/code&gt; 쌍 . 여기서 &lt;code&gt;LineNumber&lt;/code&gt; 는 음이 아닌 정수이고 &lt;code&gt;SimpleTest&lt;/code&gt; 는 또 다른 간단한 테스트 오브젝트입니다. &lt;code&gt;LineNumber&lt;/code&gt; 는 테스트의 소스 라인을 나타내야합니다. 이와 같은 쌍은 일반적으로 &lt;code&gt;?_test(...)&lt;/code&gt; 매크로 를 통해서만 생성됩니다 . &lt;code&gt;&lt;a href=&quot;#Basic_macros&quot;&gt;Basic macros&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="defb50c3733240a6d3613348a3d9ea0d5e3378d6" translate="yes" xml:space="preserve">
          <source>A parallel test case has a private I/O server as its group leader. (For a description of the group leader concept, see &lt;code&gt;ERTS&lt;/code&gt;). The central I/O server process, which handles the output from regular test cases and configuration functions, does not respond to I/O messages during execution of parallel groups. This is important to understand to avoid certain traps, like the following:</source>
          <target state="translated">병렬 테스트 케이스에는 그룹 리더로서 개인 I / O 서버가 있습니다. (그룹 리더 개념에 대한 설명은 &lt;code&gt;ERTS&lt;/code&gt; 를 참조하십시오 ). 일반 테스트 케이스 및 구성 기능의 출력을 처리하는 중앙 I / O 서버 프로세스는 병렬 그룹을 실행하는 동안 I / O 메시지에 응답하지 않습니다. 다음과 같은 특정 트랩을 피하려면 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="59ee8343e4e789ac929459cd04d582cafeb246fb" translate="yes" xml:space="preserve">
          <source>A parameterized type is to be considered as an embedded type. Each time such a type is referenced, an instance of it is defined. Thus, in the following example a record with name &lt;code&gt;'Seq_b'&lt;/code&gt; is generated in the &lt;code&gt;.hrl&lt;/code&gt; file and is used to hold values:</source>
          <target state="translated">매개 변수화 된 유형은 임베디드 유형으로 간주됩니다. 이러한 유형이 참조 될 때마다 해당 유형의 인스턴스가 정의됩니다. 따라서 다음 예에서 이름이 &lt;code&gt;'Seq_b'&lt;/code&gt; 인 레코드 는 &lt;code&gt;.hrl&lt;/code&gt; 파일 에서 생성되며 값을 보유하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="024ff9d111af56355737a8c26860d8a633650503" translate="yes" xml:space="preserve">
          <source>A parenthesized subpattern (including assertions)</source>
          <target state="translated">괄호로 묶인 하위 패턴 (어설 션 포함)</target>
        </trans-unit>
        <trans-unit id="3ea3805acd22f42cb11f366b367ef59a1e1dc7d4" translate="yes" xml:space="preserve">
          <source>A parse transformation that translates fun syntax into match specifications.</source>
          <target state="translated">재미있는 구문을 일치 스펙으로 변환하는 구문 분석 변환입니다.</target>
        </trans-unit>
        <trans-unit id="991f645ed0dc31daba5645f487f69d46fc37f314" translate="yes" xml:space="preserve">
          <source>A partial delivery failure. In the current implementation of the Erlang/SCTP binding, this event is internally converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">부분 배달 실패 Erlang / SCTP 바인딩의 현재 구현에서이 이벤트는 내부적 으로 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; 에 의해 리턴 된 &lt;code&gt;error&lt;/code&gt; 용어로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="fb726df29d93231b466c44dbe8038aa91fcb314b" translate="yes" xml:space="preserve">
          <source>A pattern can be selected to narrow the profiling. For instance a specific module can be selected, and only the code executed in that module will be profiled.</source>
          <target state="translated">프로파일 링 범위를 좁히기 위해 패턴을 선택할 수 있습니다. 예를 들어 특정 모듈을 선택할 수 있으며 해당 모듈에서 실행 된 코드 만 프로파일 링됩니다.</target>
        </trans-unit>
        <trans-unit id="387373efa88307dec031353d353693de37d89f74" translate="yes" xml:space="preserve">
          <source>A pattern for an instruction consists of its name, followed by a pattern for each of its operands. The operand patterns are separated by spaces.</source>
          <target state="translated">명령어의 패턴은 이름과 각 피연산자에 대한 패턴으로 구성됩니다. 피연산자 패턴은 공백으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="c67b6c7226586d1f049336989af73704b318b899" translate="yes" xml:space="preserve">
          <source>A pattern has the same structure as a term but can contain unbound variables.</source>
          <target state="translated">패턴은 용어와 구조는 동일하지만 언 바운드 변수를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="430efb2a85da18740aa7226ea60c97fb378ca179" translate="yes" xml:space="preserve">
          <source>A pattern is a term that can contain:</source>
          <target state="translated">패턴은 다음을 포함 할 수있는 용어입니다.</target>
        </trans-unit>
        <trans-unit id="17c671d86e70778fccd78b1c171062748a656776" translate="yes" xml:space="preserve">
          <source>A pattern that matches a certain record is created in the same way as a record is created:</source>
          <target state="translated">특정 레코드와 일치하는 패턴은 레코드가 작성되는 것과 같은 방식으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="086559c23f422f88dfb22263e5064971fda50484" translate="yes" xml:space="preserve">
          <source>A peer's DiameterIdentity is not required when initiating a connection: the identify is received at capabilities exchange, at which time the connection can be rejected if the identity is objectionable.</source>
          <target state="translated">연결을 시작할 때 피어의 DiameterIdentity는 필요하지 않습니다. 식별은 기능 교환시 수신되며,이 때 ID가 불쾌 할 경우 연결을 거부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ac1afaee6db30631244af22883394c04ea016de" translate="yes" xml:space="preserve">
          <source>A piece of data of any data type is called a &lt;strong&gt;term&lt;/strong&gt;.</source>
          <target state="translated">모든 데이터 유형의 데이터를 &lt;strong&gt;용어&lt;/strong&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="27a9280a59a327bcaa7fa4531cf4080082cc2a4d" translate="yes" xml:space="preserve">
          <source>A pointer to a function to execute in the created thread.</source>
          <target state="translated">작성된 스레드에서 실행할 함수에 대한 포인터.</target>
        </trans-unit>
        <trans-unit id="2425be4490c62b2d9ac48f8dfb6dca6c94bc6de8" translate="yes" xml:space="preserve">
          <source>A pointer to a thread identifier variable.</source>
          <target state="translated">스레드 식별자 변수에 대한 포인터</target>
        </trans-unit>
        <trans-unit id="bdca82216af70bfb4f52fcc1c479301f1b25be42" translate="yes" xml:space="preserve">
          <source>A pointer to an integer. The integer is used both for passing input and output sizes (see below).</source>
          <target state="translated">정수를 가리키는 포인터. 정수는 입력 및 출력 크기를 전달하는 데 사용됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="9e7bc1ca5fcc169a07a734702da7afb3a87a923b" translate="yes" xml:space="preserve">
          <source>A pointer to an output buffer.</source>
          <target state="translated">출력 버퍼에 대한 포인터.</target>
        </trans-unit>
        <trans-unit id="78c2fb1c9ead9f20103777b7ae3edafb6a2eea4e" translate="yes" xml:space="preserve">
          <source>A pointer to another port structure, which is either the listen port from which this port is accepting a connection or conversely. The &quot;partner relation&quot; is always bidirectional.</source>
          <target state="translated">다른 포트 구조에 대한 포인터.이 포트는 연결을 허용하는 청취 포트이거나 반대로입니다. &quot;파트너 관계&quot;는 항상 양방향입니다.</target>
        </trans-unit>
        <trans-unit id="aae44b20ecd8d8611c610749c380b8aec87c9bfa" translate="yes" xml:space="preserve">
          <source>A pointer to argument to the &lt;code&gt;func&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 함수 에 대한 인수를 가리키는 포인터 .</target>
        </trans-unit>
        <trans-unit id="2f4cacb4211d371a86050f3b2bf4514f77eeffa8" translate="yes" xml:space="preserve">
          <source>A pointer to the contents of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 의 내용에 대한 포인터 .</target>
        </trans-unit>
        <trans-unit id="ec5991945ec65c59205cb652ca3121b479552f42" translate="yes" xml:space="preserve">
          <source>A pointer to the function that implements the NIF.</source>
          <target state="translated">NIF를 구현하는 함수에 대한 포인터.</target>
        </trans-unit>
        <trans-unit id="d4bf94b670a866ff43aac180a11292d00d614edb" translate="yes" xml:space="preserve">
          <source>A pointer to thread options to use or &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">사용할 스레드 옵션에 대한 포인터 또는 &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1206cda26f132192edd3659328975e4d3cafd278" translate="yes" xml:space="preserve">
          <source>A port can be set to use binaries instead of lists of bytes. It is then not necessary to invent any encoding/decoding scheme. Erl_Interface functions are used for unpacking the binary and convert it into a struct similar to an Erlang term. Such a struct can be manipulated in different ways, be converted to the Erlang external format, and sent to Erlang.</source>
          <target state="translated">바이트 목록 대신 바이너리를 사용하도록 포트를 설정할 수 있습니다. 그러면 인코딩 / 디코딩 체계를 발명 할 필요가 없습니다. Erl_Interface 함수는 바이너리 압축을 풀고 Erlang 용어와 유사한 구조체로 변환하는 데 사용됩니다. 이러한 구조체는 다른 방식으로 조작하고 Erlang 외부 형식으로 변환하여 Erlang으로 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a9af688d21b53184095c38ddf61f01deed4f70c" translate="yes" xml:space="preserve">
          <source>A port data lock is reference counted, and when the reference count reaches zero, it is destroyed. The emulator at least increments the reference count once when the lock is created and decrements it once the port associated with the lock terminates. The emulator also increments the reference count when an async job is enqueued and decrements it when an async job has been invoked. Also, the driver is responsible for ensuring that the reference count does not reach zero before the last use of the lock by the driver has been made. The reference count can be read, incremented, and decremented by &lt;code&gt;&lt;a href=&quot;#driver_pdl_get_refc&quot;&gt; driver_pdl_get_refc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#driver_pdl_inc_refc&quot;&gt; driver_pdl_inc_refc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_pdl_dec_refc&quot;&gt; driver_pdl_dec_refc&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">포트 데이터 잠금은 참조 카운트이며 참조 카운트가 0에 도달하면 파괴됩니다. 에뮬레이터는 잠금이 생성 될 때 적어도 한 번 참조 횟수를 증가시키고 잠금과 연관된 포트가 종료되면이를 감소시킵니다. 에뮬레이터는 또한 비동기 작업이 대기열에 추가 될 때 참조 횟수를 증가시키고 비동기 작업이 호출되면이를 감소시킵니다. 또한 드라이버는 마지막으로 잠금을 사용하기 전에 참조 횟수가 0에 도달하지 않도록해야합니다. 참조 카운트는 각각 &lt;code&gt;&lt;a href=&quot;#driver_pdl_get_refc&quot;&gt; driver_pdl_get_refc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#driver_pdl_inc_refc&quot;&gt; driver_pdl_inc_refc&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#driver_pdl_dec_refc&quot;&gt; driver_pdl_dec_refc&lt;/a&gt;&lt;/code&gt; 에 의해 읽기, 증가 및 감소 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c39dd0f30e9a0ba72b5dacc6b581f2019abf49ac" translate="yes" xml:space="preserve">
          <source>A port data lock is reference counted, and when the reference count reaches zero, it is destroyed. The emulator at least increments the reference count once when the lock is created and decrements it once the port associated with the lock terminates. The emulator also increments the reference count when an async job is enqueued and decrements it when an async job has been invoked. Also, the driver is responsible for ensuring that the reference count does not reach zero before the last use of the lock by the driver has been made. The reference count can be read, incremented, and decremented by &lt;code&gt;&lt;a href=&quot;#driver_pdl_get_refc&quot;&gt;driver_pdl_get_refc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#driver_pdl_inc_refc&quot;&gt;driver_pdl_inc_refc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_pdl_dec_refc&quot;&gt;driver_pdl_dec_refc&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">포트 데이터 잠금은 참조 카운트되며 참조 카운트가 0에 도달하면 소멸됩니다. 에뮬레이터는 잠금이 작성 될 때 최소한 참조 횟수를 한 번 증가시키고 잠금과 연관된 포트가 종료되면이를 감소시킵니다. 또한 에뮬레이터는 비동기 작업이 대기열에있을 때 참조 횟수를 증가시키고 비동기 작업이 호출 될 때 참조 횟수를 감소시킵니다. 또한 드라이버는 드라이버가 마지막으로 잠금을 사용하기 전에 참조 카운트가 0에 도달하지 않도록해야합니다. 참조 카운트는 각각 &lt;code&gt;&lt;a href=&quot;#driver_pdl_get_refc&quot;&gt;driver_pdl_get_refc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#driver_pdl_inc_refc&quot;&gt;driver_pdl_inc_refc&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#driver_pdl_dec_refc&quot;&gt;driver_pdl_dec_refc&lt;/a&gt;&lt;/code&gt; 에 의해 읽히고, 증가하고, 감소 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="293c8a353a9462ae3b6bfddcb9d1223abb498be9" translate="yes" xml:space="preserve">
          <source>A port driver is a linked-in driver that is accessible as a port from an Erlang program. It is a shared library (SO in UNIX, DLL in Windows), with special entry points. The Erlang runtime system calls these entry points when the driver is started and when data is sent to the port. The port driver can also send data to Erlang.</source>
          <target state="translated">포트 드라이버는 Erlang 프로그램에서 포트로 액세스 할 수있는 링크 된 드라이버입니다. 특별한 진입 점이있는 공유 라이브러리 (UNIX의 SO, Windows의 DLL)입니다. Erlang 런타임 시스템은 드라이버가 시작되고 데이터가 포트로 전송 될 때 이러한 진입 점을 호출합니다. 포트 드라이버는 데이터를 Erlang으로 전송할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c0708dd623cb47c7df1202d9dbfe1fbb7d19e65" translate="yes" xml:space="preserve">
          <source>A port identifier identifies an Erlang port.</source>
          <target state="translated">포트 식별자는 Erlang 포트를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="19b3ddd399fc086f92748ad13d0d6c9f12e76af1" translate="yes" xml:space="preserve">
          <source>A port identifier refers into a port table and a node table, which also consumes memory.</source>
          <target state="translated">포트 식별자는 포트 테이블과 노드 테이블을 나타내며 메모리도 사용합니다.</target>
        </trans-unit>
        <trans-unit id="18856ffa7bc1d834314eb745f89d3f4ac81cef62" translate="yes" xml:space="preserve">
          <source>A port identifier. In contrast to port ID terms (instances of &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;), &lt;code&gt;ErlNifPort&lt;/code&gt;s are self-contained and not bound to any &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ErlNifPort&lt;/code&gt; is an opaque type.</source>
          <target state="translated">포트 식별자. 포트 ID 조건 (인스턴스 달리 &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; ) &lt;code&gt;ErlNifPort&lt;/code&gt; 의 S 자 급식하고 결합하지 않은 &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ErlNifPort&lt;/code&gt; 는 불투명 한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ea470bfa2ec4cfaf642ebb2fc7a49f8233c8c023" translate="yes" xml:space="preserve">
          <source>A port identifier. In contrast to port ID terms (instances of &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;), &lt;code&gt;ErlNifPort&lt;/code&gt;s are self-contained and not bound to any &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ErlNifPort&lt;/code&gt; is an opaque type. It can be copied, moved in memory, forgotten, and so on.</source>
          <target state="translated">포트 식별자. 포트 ID 조건 (인스턴스 달리 &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; ) &lt;code&gt;ErlNifPort&lt;/code&gt; 의 S 자 급식하고 결합하지 않은 &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ErlNifPort&lt;/code&gt; 는 불투명 한 유형입니다. 복사, 메모리 이동, 잊음 등이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a5794b57a917a22a654e45737ed3a63e4f792f19" translate="yes" xml:space="preserve">
          <source>A port that is connected to a listen socket. This port does not do much, no data pumping is done on this socket, but read data is available when one is trying to do an accept on the port.</source>
          <target state="translated">청취 소켓에 연결된 포트입니다. 이 포트는 많은 작업을 수행하지 않고이 소켓에서 데이터 펌핑이 수행되지 않지만 포트에서 수락을 시도 할 때 데이터를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e728f787c7fc14ca780c0ed99792cf4bab0d04bc" translate="yes" xml:space="preserve">
          <source>A positive integer or &lt;code&gt;infinity&lt;/code&gt;, defaults to &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">양의 정수 또는 &lt;code&gt;infinity&lt;/code&gt; 는 기본적으로 &lt;code&gt;infinity&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2ff16a10dbcc92f0a90f938ecb26a69d5a07cb38" translate="yes" xml:space="preserve">
          <source>A positive integer or the atom &lt;code&gt;undefined_serial&lt;/code&gt; (in case no messages has been sent).</source>
          <target state="translated">양의 정수 또는 원자 &lt;code&gt;undefined_serial&lt;/code&gt; (메시지가 전송 되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="a0b0b2de29f48def22ce618959435b19ac7becd8" translate="yes" xml:space="preserve">
          <source>A positive integer representing the absolute maximum size a string returned from this formatter can have. If the formatted string is longer, after possibly being limited by &lt;code&gt;chars_limit&lt;/code&gt; or &lt;code&gt;depth&lt;/code&gt;, it is truncated.</source>
          <target state="translated">이 포맷터에서 반환 된 문자열이 가질 수있는 절대 최대 크기를 나타내는 양의 정수입니다. 형식화 된 문자열이 더 길면 가능한 경우 &lt;code&gt;chars_limit&lt;/code&gt; 또는 &lt;code&gt;depth&lt;/code&gt; 로 제한된 후 잘립니다.</target>
        </trans-unit>
        <trans-unit id="8432f1221b4e6180daa30dde8c243b5ace3ee8ed" translate="yes" xml:space="preserve">
          <source>A positive integer representing the maximum depth to which terms shall be printed by this formatter. Format strings passed to this formatter are rewritten. The format controls ~p and ~w are replaced with ~P and ~W, respectively, and the value is used as the depth parameter. For details, see &lt;code&gt;io:format/2,3&lt;/code&gt; in STDLIB.</source>
          <target state="translated">용어가이 포맷터에 의해 인쇄 될 최대 깊이를 나타내는 양의 정수. 이 포맷터에 전달 된 형식 문자열이 다시 작성됩니다. 형식 제어 ~ p 및 ~ w는 각각 ~ P 및 ~ W로 대체되며 값은 깊이 매개 변수로 사용됩니다. 자세한 내용 은 STDLIB의 &lt;code&gt;io:format/2,3&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0c5f0649daa5aaf66aa8692a46961fb52172dd0" translate="yes" xml:space="preserve">
          <source>A positive integer representing the value of the option with the same name to be used when calling &lt;code&gt; io_lib:format/3&lt;/code&gt;. This value limits the total number of characters printed for each log event. Notice that this is a soft limit. For a hard truncation limit, see option &lt;code&gt;max_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt; io_lib:format/3&lt;/code&gt; 을 호출 할 때 사용할 동일한 이름을 가진 옵션 값을 나타내는 양의 정수 입니다. 이 값은 각 로그 이벤트에 대해 인쇄되는 총 문자 수를 제한합니다. 이것은 소프트 한계입니다. 하드 자르기 제한은 &lt;code&gt;max_size&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b666ac2b38c4545ad7cf98d3da66419760a1f1f" translate="yes" xml:space="preserve">
          <source>A positive integer representing the value of the option with the same name to be used when calling &lt;code&gt;io_lib:format/3&lt;/code&gt;. This value limits the total number of characters printed for each log event. Notice that this is a soft limit. For a hard truncation limit, see option &lt;code&gt;max_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;io_lib:format/3&lt;/code&gt; 을 호출 할 때 사용할 이름과 동일한 옵션 값을 나타내는 양의 정수 . 이 값은 각 로그 이벤트에 대해 인쇄되는 총 문자 수를 제한합니다. 이것은 소프트 한계입니다. 하드 자르기 제한에 대해서는 &lt;code&gt;max_size&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="00810275831c468fa832818d7831816d4d68cc76" translate="yes" xml:space="preserve">
          <source>A positive integer, defaults to 1.</source>
          <target state="translated">양의 정수이며 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="eae0729316a72e8195f927b7d08f3a3e873b0f72" translate="yes" xml:space="preserve">
          <source>A possible output from the system's &lt;code&gt;sequential_tracer&lt;/code&gt; can be like this:</source>
          <target state="translated">시스템의 &lt;code&gt;sequential_tracer&lt;/code&gt; 에서 가능한 출력은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af7898411039ac7f27c7f7c532905e5b1d3ef4a9" translate="yes" xml:space="preserve">
          <source>A predicate &lt;code&gt;Big(X)&lt;/code&gt; is defined, which is &lt;code&gt;true&lt;/code&gt; if its argument is greater that 10:</source>
          <target state="translated">술어 &lt;code&gt;Big(X)&lt;/code&gt; 가 정의되며, 인수가 10보다 크면 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e7d9312c9e6373085b2581d401f52947630c30ca" translate="yes" xml:space="preserve">
          <source>A predicate is a function that returns &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;any&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if there is a term &lt;code&gt;X&lt;/code&gt; in the list such that &lt;code&gt;P(X)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">술어는 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 를 리턴하는 함수입니다 . &lt;code&gt;any&lt;/code&gt; 이다 &lt;code&gt;true&lt;/code&gt; 텀이 경우 &lt;code&gt;X&lt;/code&gt; 되도록리스트 &lt;code&gt;P(X)&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a559512ddfd19a254b3dc8766e06627c3cf21e5" translate="yes" xml:space="preserve">
          <source>A prefix is optional but can be be used to disambiguate between record and constant names resulting from similarly named messages and AVPs in different Diameter applications.</source>
          <target state="translated">접두어는 선택 사항이지만 다른 Diameter 응용 프로그램에서 비슷한 이름의 메시지와 AVP로 인해 레코드와 상수 이름을 명확하게 구분하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c17bae9646cdd5e9bda0a78a3791df32fbe7c33e" translate="yes" xml:space="preserve">
          <source>A previously loaded module contains an &lt;code&gt;-on_load&lt;/code&gt; function that never finished.</source>
          <target state="translated">이전에로드 된 모듈에는 완료되지 않은 &lt;code&gt;-on_load&lt;/code&gt; 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b8f8657029f4d6aa6e01af505f0ff328ca9512f" translate="yes" xml:space="preserve">
          <source>A problem can arise if a replicated table on one node is initiated, but &lt;code&gt;Mnesia&lt;/code&gt; deduces that another (remote) replica is more recent than the replica existing on the local node, and the initialization procedure does not proceed. In this situation, a call to &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables/2&lt;/a&gt;&lt;/code&gt;, suspends the caller until the remote node has initialized the table from its local disc and the node has copied the table over the network to the local node.</source>
          <target state="translated">한 노드에서 복제 된 테이블이 시작되었지만 &lt;code&gt;Mnesia&lt;/code&gt; 는 다른 (원격) 복제본이 로컬 노드에있는 복제본보다 최신 버전이라고 추론하고 초기화 절차가 진행되지 않는 경우 문제가 발생할 수 있습니다 . 이 상황에서 &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables/2&lt;/a&gt;&lt;/code&gt; 에 대한 호출은 원격 노드가 로컬 디스크에서 테이블을 초기화하고 노드가 네트워크를 통해 테이블을 로컬 노드에 복사 할 때까지 호출자를 일시 중단합니다.</target>
        </trans-unit>
        <trans-unit id="6f4802cb3c2b14a3f4d0a0759994b3bcff8bf5ac" translate="yes" xml:space="preserve">
          <source>A process bound environment contains transient information about the calling Erlang process. The environment is only valid in the thread where it was supplied as argument until the NIF returns. It is thus useless and dangerous to store pointers to process bound environments between NIF calls.</source>
          <target state="translated">프로세스 바운드 환경에는 호출 Erlang 프로세스에 대한 일시적인 정보가 포함되어 있습니다. 환경은 NIF가 리턴 할 때까지 인수로 제공된 스레드에서만 유효합니다. 따라서 NIF 호출간에 바인딩 된 환경을 처리하기 위해 포인터를 저장하는 것은 쓸모없고 위험합니다.</target>
        </trans-unit>
        <trans-unit id="8ebbb1fef06e8f55da3f26cfd1b065a870dd9421" translate="yes" xml:space="preserve">
          <source>A process calling &lt;code&gt;spawn&lt;/code&gt;, &lt;code&gt;spawn_link&lt;/code&gt;, &lt;code&gt;spawn_monitor&lt;/code&gt;, or &lt;code&gt;spawn_opt&lt;/code&gt; is scheduled out immediately after completing the call. When higher modified timing levels are used, the caller also sleeps for a while after it is scheduled out.</source>
          <target state="translated">&lt;code&gt;spawn&lt;/code&gt; , &lt;code&gt;spawn_link&lt;/code&gt; , &lt;code&gt;spawn_monitor&lt;/code&gt; 또는 &lt;code&gt;spawn_opt&lt;/code&gt; 호출 프로세스는 호출 완료 후 즉시 스케줄됩니다. 더 높은 수정 된 타이밍 레벨이 사용되면, 호출자는 스케줄 된 후 잠시 동안 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="072b0b4dc3c07ad9ff81bf5af27f95232daef7d4" translate="yes" xml:space="preserve">
          <source>A process can also be terminated if it receives an exit signal with another exit reason than &lt;code&gt;normal&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로세스가 &lt;code&gt;normal&lt;/code&gt; 아닌 다른 종료 이유가있는 종료 신호를 수신하면 프로세스를 종료 할 수도 있습니다 ( &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="f16a41a56038d323a59c139120b39c4d98df3227" translate="yes" xml:space="preserve">
          <source>A process can also call the function &lt;code&gt;exit(Pid,Reason)&lt;/code&gt;. This results in an exit signal with exit reason &lt;code&gt;Reason&lt;/code&gt; being emitted to &lt;code&gt;Pid&lt;/code&gt;, but does not affect the calling process.</source>
          <target state="translated">프로세스는 함수 &lt;code&gt;exit(Pid,Reason)&lt;/code&gt; 호출 할 수도 있습니다 . 종료 이유 &lt;code&gt;Reason&lt;/code&gt; 가 &lt;code&gt;Pid&lt;/code&gt; 로 방출되는 종료 신호 가 발생 하지만 호출 프로세스에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6966f7ea916abf9765baf180b15bfc451003b50" translate="yes" xml:space="preserve">
          <source>A process can be set to trap exit signals by calling:</source>
          <target state="translated">다음을 호출하여 종료 신호를 트랩하도록 프로세스를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49077ba72c45965099e62393fc4505d1bc5f8e7a" translate="yes" xml:space="preserve">
          <source>A process can be suspended by multiple processes and can be suspended multiple times by a single process. A suspended process does not leave the suspended state until its suspend count reaches zero. The suspend count of &lt;code&gt;Suspendee&lt;/code&gt; is decreased when &lt;code&gt;&lt;a href=&quot;#resume_process-1&quot;&gt; erlang:resume_process(Suspendee)&lt;/a&gt;&lt;/code&gt; is called by the same process that called &lt;code&gt;erlang:suspend_process(Suspendee)&lt;/code&gt;. All increased suspend counts on other processes acquired by a process are automatically decreased when the process terminates.</source>
          <target state="translated">프로세스는 여러 프로세스에 의해 일시 중단 될 수 있으며 단일 프로세스에 의해 여러 번 일시 중단 될 수 있습니다. 일시 중단 된 프로세스는 일시 중단 횟수가 0이 될 때까지 일시 중단 상태를 벗어나지 않습니다. &lt;code&gt;erlang:suspend_process(Suspendee)&lt;/code&gt; 를 호출 한 것과 동일한 프로세스에서 &lt;code&gt;&lt;a href=&quot;#resume_process-1&quot;&gt; erlang:resume_process(Suspendee)&lt;/a&gt;&lt;/code&gt; 를 호출 하면 &lt;code&gt;Suspendee&lt;/code&gt; 의 일시 중지 횟수 가 감소 합니다. 프로세스가 획득 한 다른 프로세스에 대한 모든 증가 된 일시 중지 수는 프로세스가 종료 될 때 자동으로 감소합니다.</target>
        </trans-unit>
        <trans-unit id="51d9fe10dcef55d7d44c0442f222152ab34ddbe3" translate="yes" xml:space="preserve">
          <source>A process can be suspended by multiple processes and can be suspended multiple times by a single process. A suspended process does not leave the suspended state until its suspend count reaches zero. The suspend count of &lt;code&gt;Suspendee&lt;/code&gt; is decreased when &lt;code&gt;&lt;a href=&quot;#resume_process-1&quot;&gt;erlang:resume_process(Suspendee)&lt;/a&gt;&lt;/code&gt; is called by the same process that called &lt;code&gt;erlang:suspend_process(Suspendee)&lt;/code&gt;. All increased suspend counts on other processes acquired by a process are automatically decreased when the process terminates.</source>
          <target state="translated">프로세스는 여러 프로세스에 의해 일시 중단 될 수 있으며 단일 프로세스에 의해 여러 번 일시 중단 될 수 있습니다. 일시 중단 된 프로세스는 일시 중단 횟수가 0에 도달 할 때까지 일시 중단 된 상태를 벗어나지 않습니다. &lt;code&gt;erlang:suspend_process(Suspendee)&lt;/code&gt; 와 동일한 프로세스에서 &lt;code&gt;&lt;a href=&quot;#resume_process-1&quot;&gt;erlang:resume_process(Suspendee)&lt;/a&gt;&lt;/code&gt; 를 호출 하면 &lt;code&gt;Suspendee&lt;/code&gt; 의 일시 중단 횟수 가 줄어 듭니다 . 프로세스에 의해 획득 된 다른 프로세스에 대한 증가 된 일시 중단 횟수는 프로세스가 종료 될 때 자동으로 감소합니다.</target>
        </trans-unit>
        <trans-unit id="32f69066cd227a9815efdfec6c96cb7e6e8de0aa" translate="yes" xml:space="preserve">
          <source>A process can terminate itself by calling one of the following BIFs:</source>
          <target state="translated">프로세스는 다음 BIF 중 하나를 호출하여 자체적으로 종료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b321553d2b5e342e2d1b929ffc0921e013068c69" translate="yes" xml:space="preserve">
          <source>A process created due to a spawn request that has been abandoned may communicate with its parent as any other process. It is &lt;strong&gt;only&lt;/strong&gt; the direct effects on the parent of the actual spawn request, that will be canceled by abandoning a spawn request.</source>
          <target state="translated">중단 된 생성 요청으로 인해 생성 된 프로세스는 다른 프로세스와 마찬가지로 부모와 통신 할 수 있습니다. 그것은입니다 &lt;strong&gt;만&lt;/strong&gt; 스폰 요청을 포기으로 취소됩니다 실제 스폰 요청의 부모에 직접적인 영향.</target>
        </trans-unit>
        <trans-unit id="bd5238f73e1d44a290b4f80529059292d57da507" translate="yes" xml:space="preserve">
          <source>A process fixes a table by calling &lt;code&gt;safe_fixtable(Tab, true)&lt;/code&gt;. The table remains fixed until the process releases it by calling &lt;code&gt;safe_fixtable(Tab, false)&lt;/code&gt;, or until the process terminates.</source>
          <target state="translated">프로세스는 &lt;code&gt;safe_fixtable(Tab, true)&lt;/code&gt; 호출하여 테이블을 수정합니다 . &lt;code&gt;safe_fixtable(Tab, false)&lt;/code&gt; 를 호출하여 프로세스가 해제 할 때까지 또는 프로세스가 종료 될 때까지 테이블은 고정 된 상태로 유지 됩니다.</target>
        </trans-unit>
        <trans-unit id="42b2c1b73ec6ef9ef96e79e9e9449854c76818bb" translate="yes" xml:space="preserve">
          <source>A process identifier (pid). In contrast to pid terms (instances of &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;), &lt;code&gt;ErlNifPid&lt;/code&gt;s are self-contained and not bound to any &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ErlNifPid&lt;/code&gt; is an opaque type.</source>
          <target state="translated">프로세스 식별자 (pid) PID 용어는 달리 (인스턴스 &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; 는 ) &lt;code&gt;ErlNifPid&lt;/code&gt; 의 S 자 급식하고 결합하지 않은 &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ErlNifPid&lt;/code&gt; 는 불투명 한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ba9734ec123feb8eec22b585c124792c0472e055" translate="yes" xml:space="preserve">
          <source>A process identifier (pid). In contrast to pid terms (instances of &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;), &lt;code&gt;ErlNifPid&lt;/code&gt;s are self-contained and not bound to any &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ErlNifPid&lt;/code&gt; is an opaque type. It can be copied, moved in memory, forgotten, and so on.</source>
          <target state="translated">프로세스 식별자 (pid). PID 용어는 달리 (인스턴스 &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; 는 ) &lt;code&gt;ErlNifPid&lt;/code&gt; 의 S 자 급식하고 결합하지 않은 &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ErlNifPid&lt;/code&gt; 는 불투명 한 유형입니다. 복사, 메모리 이동, 잊음 등이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="37148f5c507ec0173b138452557614229468263f" translate="yes" xml:space="preserve">
          <source>A process identifier as in &lt;code&gt;&lt;a href=&quot;#PID_EXT&quot;&gt;PID_EXT&lt;/a&gt;&lt;/code&gt;. Represents the process in which the fun was created.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#PID_EXT&quot;&gt;PID_EXT&lt;/a&gt;&lt;/code&gt; 와 같은 프로세스 식별자 . 재미가 만들어진 과정을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="10461d2fc7608d820f0dfe163bcb992712ebe48a" translate="yes" xml:space="preserve">
          <source>A process identifier refers into a process table and a node table, which also consumes memory.</source>
          <target state="translated">프로세스 식별자는 메모리를 소비하는 프로세스 테이블과 노드 테이블을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="69b2f4b3ae91aebe493ff76d27f3c271b8cfb661" translate="yes" xml:space="preserve">
          <source>A process identifier, pid, identifies a process.</source>
          <target state="translated">프로세스 식별자 인 pid는 프로세스를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="98c8d95b2cf9ab7d1d26152983625cb3f9b34934" translate="yes" xml:space="preserve">
          <source>A process in a supervision tree is expected to terminate with the same reason as its parent.</source>
          <target state="translated">감독 트리의 프로세스는 상위와 같은 이유로 종료 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="d6ba7c3c946bdd4b03479883e86c12f1505bd1d6" translate="yes" xml:space="preserve">
          <source>A process is created by calling &lt;code&gt;spawn&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;spawn&lt;/code&gt; 을 호출하여 프로세스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="655669bae8fcf2c6bd4e506e48fb385c11ebcc8b" translate="yes" xml:space="preserve">
          <source>A process is said to &lt;strong&gt;use&lt;/strong&gt; a module &lt;code&gt;Mod&lt;/code&gt; if &lt;code&gt;Mod&lt;/code&gt; is listed in the &lt;code&gt;Modules&lt;/code&gt; part of the child specification used to start the process, see &lt;code&gt;supervisor(3)&lt;/code&gt;. In the case of &lt;code&gt;gen_event&lt;/code&gt;, an event manager process is said to use &lt;code&gt;Mod&lt;/code&gt; if &lt;code&gt;Mod&lt;/code&gt; is an installed event handler.</source>
          <target state="translated">프로세스가 프로세스 를 시작하는 데 사용 된 하위 스펙 의 &lt;code&gt;Modules&lt;/code&gt; 부분에 &lt;code&gt;Mod&lt;/code&gt; 가 나열된 경우 프로세스는 모듈 &lt;code&gt;Mod&lt;/code&gt; 를 &lt;strong&gt;사용&lt;/strong&gt; 한다고합니다 &lt;code&gt;supervisor(3)&lt;/code&gt; 참조 ) . &lt;code&gt;gen_event&lt;/code&gt; 의 경우 , &lt;code&gt;Mod&lt;/code&gt; 가 설치된 이벤트 핸들러 인 경우 이벤트 관리자 프로세스는 &lt;code&gt;Mod&lt;/code&gt; 를 사용한다고 합니다.</target>
        </trans-unit>
        <trans-unit id="6ce5d54306fa5b34ccef5a88ec9ab67fc328d882" translate="yes" xml:space="preserve">
          <source>A process is said to terminate &lt;strong&gt;normally&lt;/strong&gt;, if the exit reason is the atom &lt;code&gt;normal&lt;/code&gt;. A process with no more code to execute terminates normally.</source>
          <target state="translated">종료 이유가 원자 &lt;code&gt;normal&lt;/code&gt; 경우 프로세스가 &lt;strong&gt;정상적으로&lt;/strong&gt; 종료된다고합니다 . 실행할 코드가 더 이상없는 프로세스는 정상적으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="fb8a0c82e2b3e6de1b3a292697b7dd18d1ac9e70" translate="yes" xml:space="preserve">
          <source>A process may join multiple groups. It may join the same group multiple times. It is only allowed to join processes running on local node.</source>
          <target state="translated">프로세스는 여러 그룹을 결합 할 수 있습니다. 같은 그룹에 여러 번 가입 할 수 있습니다. 로컬 노드에서 실행중인 프로세스 만 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5476607e3cda2543b898df9573ff320bd9b1b5a4" translate="yes" xml:space="preserve">
          <source>A process must complete the sending of a fragmented message before it can start sending any other message on the same distribution channel.</source>
          <target state="translated">프로세스는 동일한 배포 채널에서 다른 메시지 전송을 시작하기 전에 조각난 메시지 전송을 완료해야합니다.</target>
        </trans-unit>
        <trans-unit id="262937e9bbf32c8d0ea317c09244f8bdfd384e14" translate="yes" xml:space="preserve">
          <source>A process spawn is represented as multiple information transfers. At least one spawn request and one spawn reply. The actual amount of information transfers depends on what type of spawn it is and may also change in future implementations. Note that this is more or less an internal protocol that you are peeking at. The spawn request will be represented as a tuple with the first element containing the atom &lt;code&gt;spawn_request&lt;/code&gt;, but this is more or less all that you can depend on.</source>
          <target state="translated">프로세스 생성은 여러 정보 전송으로 표시됩니다. 적어도 하나의 스폰 요청과 하나의 스폰 응답. 실제 정보 전송량은 생성 유형에 따라 다르며 향후 구현에서도 변경 될 수 있습니다. 이것은 당신이 엿보는 내부 프로토콜입니다. spawn 요청은 &lt;code&gt;spawn_request&lt;/code&gt; 원자를 포함하는 첫 번째 요소가있는 튜플로 표시 되지만, 이것은 어느 정도 의존 할 수있는 전부입니다.</target>
        </trans-unit>
        <trans-unit id="c38c68c3f6186a6925602a46f9f750d6d6a871ba" translate="yes" xml:space="preserve">
          <source>A process started using one of these functions stores information (for example, about the ancestors and initial call) that is needed for a process in a supervision tree.</source>
          <target state="translated">이러한 기능 중 하나를 사용하여 시작된 프로세스는 감독 트리의 프로세스에 필요한 정보 (예 : 조상 및 초기 호출)를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="8a720c57ae355af10862b0bdc7f574cf5fde79d5" translate="yes" xml:space="preserve">
          <source>A process terminates when there is nothing more for it to do, that is, the last function it calls simply returns and does not call another function. Another way for a process to terminate is for it to call &lt;code&gt;exit/1&lt;/code&gt;. The argument to &lt;code&gt;exit/1&lt;/code&gt; has a special meaning, which is discussed later. In this example, &lt;code&gt;exit(normal)&lt;/code&gt; is done, which has the same effect as a process running out of functions to call.</source>
          <target state="translated">더 이상 할 일이 없으면 프로세스가 종료됩니다. 즉, 마지막으로 호출하는 함수는 단순히 반환하고 다른 함수를 호출하지 않습니다. 프로세스를 종료하는 또 다른 방법은 &lt;code&gt;exit/1&lt;/code&gt; 을 호출하는 것 입니다. &lt;code&gt;exit/1&lt;/code&gt; 에 대한 인수 는 특별한 의미를 갖습니다. 이는 나중에 설명합니다. 이 예에서는 &lt;code&gt;exit(normal)&lt;/code&gt; 가 수행되며 호출 할 함수가 부족한 프로세스와 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b7284987fd39b3d4aa792c2690fb0c00bf937e45" translate="yes" xml:space="preserve">
          <source>A process terminates with an exit reason &lt;code&gt;{Reason,Stack}&lt;/code&gt; when a run-time error occurs. See &lt;code&gt;&lt;a href=&quot;errors#exit_reasons&quot;&gt;Exit Reasons&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">런타임 오류가 발생 하면 종료 이유 &lt;code&gt;{Reason,Stack}&lt;/code&gt; 으로 프로세스가 종료 됩니다. &lt;code&gt;&lt;a href=&quot;errors#exit_reasons&quot;&gt;Exit Reasons&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3f5ab350433257813ae5457fda256563bb26173" translate="yes" xml:space="preserve">
          <source>A process that has subscribed receives the messages &lt;code&gt;{nodeup, Node}&lt;/code&gt; and &lt;code&gt;{nodedown, Node}&lt;/code&gt; when a group node connects or disconnects, respectively.</source>
          <target state="translated">가입 한 프로세스 는 그룹 노드가 각각 연결 또는 연결 해제 될 때 &lt;code&gt;{nodeup, Node}&lt;/code&gt; 및 &lt;code&gt;{nodedown, Node}&lt;/code&gt; 메시지를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="88f957222cd12e5811bc10dccb60ff786260ced6" translate="yes" xml:space="preserve">
          <source>A process that mostly have short-lived data is fullsweeped seldom or never, that is, the old heap contains mostly garbage. To ensure a fullsweep occasionally, set &lt;code&gt;Number&lt;/code&gt; to a suitable value, such as 10 or 20.</source>
          <target state="translated">수명이 짧은 데이터를 주로 사용하는 프로세스는 거의 사용되지 않거나 전혀 사용되지 않습니다. 즉, 이전 힙에는 대부분 가비지가 포함됩니다. 풀 스윕을 가끔씩하려면 &lt;code&gt;Number&lt;/code&gt; 를 10 또는 20과 같은 적절한 값으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="b02ce9655d7ee12a68cc9c922758cfe90268e361" translate="yes" xml:space="preserve">
          <source>A process that terminates emits an &lt;strong&gt;exit signal&lt;/strong&gt; with an &lt;strong&gt;exit reason&lt;/strong&gt; that says something about which error has occurred. Normally, some information about the error is printed to the terminal.</source>
          <target state="translated">종료하는 프로세스는 종료 오류가 발생한 것에 대해 &lt;strong&gt;종료 이유&lt;/strong&gt; 가 있는 &lt;strong&gt;종료 신호&lt;/strong&gt; 를 방출합니다 . 일반적으로 오류에 대한 일부 정보는 터미널에 인쇄됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c1ad1b1dc6212b6747cc5b78c88b6a9bc5616a4" translate="yes" xml:space="preserve">
          <source>A process uses a module if the name is listed in &lt;code&gt;Modules&lt;/code&gt; in the child specification for the process.</source>
          <target state="translated">프로세스의 이름이 프로세스의 하위 스펙에있는 &lt;code&gt;Modules&lt;/code&gt; 에 나열된 경우 프로세스는 모듈을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d52b7cef11e2674343ad2926d3e4df68d2f02770" translate="yes" xml:space="preserve">
          <source>A process which encounters a runtime error (for example, divide by zero, bad match, trying to call a function that does not exist and so on) exits with an error, that is, has an &lt;strong&gt;abnormal&lt;/strong&gt; exit. A process which executes &lt;code&gt;exit(Reason)&lt;/code&gt; where &lt;code&gt;Reason&lt;/code&gt; is any Erlang term except the atom &lt;code&gt;normal&lt;/code&gt;, also has an abnormal exit.</source>
          <target state="translated">런타임 오류 (예 : 0으로 나누기, 일치하지 않음, 존재하지 않는 함수를 호출하려고 시도하는 등)가 발생하는 프로세스는 오류로 종료됩니다. 즉, &lt;strong&gt;비정상&lt;/strong&gt; 종료입니다. 실행하는 프로세스 &lt;code&gt;exit(Reason)&lt;/code&gt; &lt;code&gt;Reason&lt;/code&gt; 원자를 제외한 얼랑 용어 &lt;code&gt;normal&lt;/code&gt; 또한 비정상적인 종료를 갖는다.</target>
        </trans-unit>
        <trans-unit id="d8cf739fd5b866124284242faae0350386ccbc38" translate="yes" xml:space="preserve">
          <source>A process which executes &lt;code&gt;exit(normal)&lt;/code&gt; or simply runs out of things to do has a &lt;strong&gt;normal&lt;/strong&gt; exit.</source>
          <target state="translated">&lt;code&gt;exit(normal)&lt;/code&gt; 를 실행하거나 단순히 수행 할 작업이 부족한 프로세스 에는 &lt;strong&gt;정상&lt;/strong&gt; 종료가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d70973a9129b09df85556ba1f21b22c9c9188ac7" translate="yes" xml:space="preserve">
          <source>A process-bound environment contains transient information about the calling Erlang process. The environment is only valid in the thread where it was supplied as argument until the NIF returns. It is thus useless and dangerous to store pointers to process-bound environments between NIF calls.</source>
          <target state="translated">프로세스 바운드 환경에는 호출 Erlang 프로세스에 대한 임시 정보가 포함됩니다. 환경은 NIF가 리턴 될 때까지 인수로 제공된 스레드에서만 유효합니다. 따라서 NIF 호출 사이에 프로세스 바운드 환경에 대한 포인터를 저장하는 것은 쓸모없고 위험합니다.</target>
        </trans-unit>
        <trans-unit id="8439869a5f898e9ec34e7c4ce1fd0dfa05b36050" translate="yes" xml:space="preserve">
          <source>A program development technique where you continuously write tests &lt;strong&gt;before&lt;/strong&gt; you implement the code that is supposed to pass those tests. This can help you focus on solving the right problems, and not make a more complicated implementation than necessary, by letting the unit tests determine when a program is &quot;done&quot;: if it fulfils its specifications, there is no need to keep adding functionality.</source>
          <target state="translated">해당 테스트를 통과해야하는 코드를 구현 &lt;strong&gt;하기 전에&lt;/strong&gt; 테스트를 지속적으로 작성하는 프로그램 개발 기술 입니다. 이를 통해 단위 테스트를 통해 프로그램이 &quot;완료&quot;된시기를 결정할 수 있으므로 올바른 문제를 해결하는 데 집중하고 필요 이상으로 복잡한 구현을 수행 할 수 없습니다. 사양이 충족되면 기능을 계속 추가 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="31698109f367fecfe3048c58496050f0b7013f39" translate="yes" xml:space="preserve">
          <source>A program works regardless of the data location. It makes no difference whether the data resides on the local node or on a remote node.</source>
          <target state="translated">프로그램은 데이터 위치에 관계없이 작동합니다. 데이터가 로컬 노드 또는 원격 노드에 있는지 여부는 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="31abad1a30c128c77e1602c287c4f23c333d4d5c" translate="yes" xml:space="preserve">
          <source>A programming language is not much use if you only can run code from the shell. So here is a small Erlang program. Enter it into a file named &lt;code&gt;tut.erl&lt;/code&gt; using a suitable text editor. The file name &lt;code&gt;tut.erl&lt;/code&gt; is important, and also that it is in the same directory as the one where you started &lt;code&gt;erl&lt;/code&gt;). If you are lucky your editor has an Erlang mode that makes it easier for you to enter and format your code nicely (see &lt;code&gt;The Erlang mode for Emacs&lt;/code&gt; in Tools User's Guide), but you can manage perfectly well without. Here is the code to enter:</source>
          <target state="translated">쉘에서 코드를 실행할 수만 있다면 프로그래밍 언어는 많이 사용되지 않습니다. 여기 작은 Erlang 프로그램이 있습니다. 적절한 텍스트 편집기를 사용하여 &lt;code&gt;tut.erl&lt;/code&gt; 파일에 파일을 입력하십시오 . 파일 이름 &lt;code&gt;tut.erl&lt;/code&gt; 은 중요하며 또한 &lt;code&gt;erl&lt;/code&gt; 을 시작한 디렉토리와 동일한 디렉토리에 있습니다 . 운이 좋으면 편집기에 코드를 쉽게 입력하고 형식을 쉽게 지정할 수 &lt;code&gt;The Erlang mode for Emacs&lt;/code&gt; 있지만 (도구 사용자 안내서의 Emacs 용 Erlang 모드 참조), 완벽하게 관리 할 수 ​​있습니다. 입력 할 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01bea3eff51113f444f36e486039be93438b9aa1" translate="yes" xml:space="preserve">
          <source>A progress report is issued when a supervisor starts or restarts a child. A progress report contains the following items:</source>
          <target state="translated">감독자가 자녀를 시작하거나 다시 시작할 때 진행 보고서가 발행됩니다. 진행 보고서에는 다음 항목이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7a2323a209e1a22ed12fa10ec6f9c3cae4a441ed" translate="yes" xml:space="preserve">
          <source>A proper list of arguments to use in the call to the entry point.</source>
          <target state="translated">진입 점 호출에 사용할 적절한 인수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="6fc5b72e9976f09f432e0a687f016f57f9a5aece" translate="yes" xml:space="preserve">
          <source>A proper list of spawn options to use when spawning.</source>
          <target state="translated">스폰시 사용할 적절한 스폰 옵션 목록입니다.</target>
        </trans-unit>
        <trans-unit id="dfa1a1d7586f8b047c09414dbfe4922da8132644" translate="yes" xml:space="preserve">
          <source>A protocol-independent equivalent of &lt;code&gt;tos&lt;/code&gt; above. Setting priority implies setting &lt;code&gt;tos&lt;/code&gt; as well.</source>
          <target state="translated">위 의 &lt;code&gt;tos&lt;/code&gt; 와 같은 프로토콜 독립적 . 우선 순위를 설정하면 설정을 의미한다 &lt;code&gt;tos&lt;/code&gt; 뿐만 아니라.</target>
        </trans-unit>
        <trans-unit id="4dcc85d5e6a8d3b2dabc11b50011d74738e45c9a" translate="yes" xml:space="preserve">
          <source>A proxy-authorization header using the provided username and password is added to the request.</source>
          <target state="translated">제공된 사용자 이름과 비밀번호를 사용하는 프록시 인증 헤더가 요청에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="fca72e9fdf4fbe435757ecdf4f89e484c25bdd95" translate="yes" xml:space="preserve">
          <source>A pseudo-terminal has been requested for the session. &lt;code&gt;Terminal&lt;/code&gt; is the value of the TERM environment variable value, that is, &lt;code&gt;vt100&lt;/code&gt;. Zero dimension parameters must be ignored. The character/row dimensions override the pixel dimensions (when non-zero). Pixel dimensions refer to the drawable area of the window. &lt;code&gt;Opcode&lt;/code&gt; in the &lt;code&gt;TerminalModes&lt;/code&gt; list is the mnemonic name, represented as a lowercase Erlang atom, defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt;, Section 8. It can also be an &lt;code&gt;Opcode&lt;/code&gt; if the mnemonic name is not listed in the RFC. Example: &lt;code&gt;OP code: 53, mnemonic name ECHO erlang atom: echo&lt;/code&gt;. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#ptty_alloc-4&quot;&gt;ssh_connection:ptty_alloc/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의사 터미널이 세션에 요청되었습니다. &lt;code&gt;Terminal&lt;/code&gt; 은 TERM 환경 변수 값의 값, 즉 &lt;code&gt;vt100&lt;/code&gt; 입니다. 제로 치수 매개 변수는 무시해야합니다. 문자 / 행 치수는 픽셀 치수보다 우선합니다 (0이 아닌 경우). 픽셀 치수는 창의 드로어 블 영역을 나타냅니다. &lt;code&gt;Opcode&lt;/code&gt; 에 &lt;code&gt;TerminalModes&lt;/code&gt; 의 목록을 정의 소문자 얼랑 원자로서 나타낸 호명 인 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; , 8. 그것은 또한 될 수 &lt;code&gt;Opcode&lt;/code&gt; 니모닉 이름이 RFC에 없으면. 예 : &lt;code&gt;OP code: 53, mnemonic name ECHO erlang atom: echo&lt;/code&gt; . 이 이벤트는 &lt;code&gt;&lt;a href=&quot;ssh_connection#ptty_alloc-4&quot;&gt;ssh_connection:ptty_alloc/4&lt;/a&gt;&lt;/code&gt; 를 호출 한 결과로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="1fc5e44171b910f411dd9eff54be6144ce19b764" translate="yes" xml:space="preserve">
          <source>A pseudo-terminal has been requested for the session. &lt;code&gt;Terminal&lt;/code&gt; is the value of the TERM environment variable value, that is, &lt;code&gt;vt100&lt;/code&gt;. Zero dimension parameters must be ignored. The character/row dimensions override the pixel dimensions (when non-zero). Pixel dimensions refer to the drawable area of the window. &lt;code&gt;Opcode&lt;/code&gt; in the &lt;code&gt;TerminalModes&lt;/code&gt; list is the mnemonic name, represented as a lowercase Erlang atom, defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4254#section/8&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt;, Section 8. It can also be an &lt;code&gt;Opcode&lt;/code&gt; if the mnemonic name is not listed in the RFC. Example: &lt;code&gt;OP code: 53, mnemonic name ECHO erlang atom: echo&lt;/code&gt;. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#ptty_alloc-4&quot;&gt;ssh_connection:ptty_alloc/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">세션에 대해 의사 터미널이 요청되었습니다. &lt;code&gt;Terminal&lt;/code&gt; 은 TERM 환경 변수 값, 즉 &lt;code&gt;vt100&lt;/code&gt; 의 값 입니다. 0 치수 매개 변수는 무시해야합니다. 문자 / 행 치수는 픽셀 치수보다 우선합니다 (0이 아닌 경우). 픽셀 치수는 창의 그리기 가능 영역을 나타냅니다. &lt;code&gt;TerminalModes&lt;/code&gt; 목록의 &lt;code&gt;Opcode&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4254#section/8&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; , Section 8에 정의 된 소문자 Erlang 원자로 표시되는 니모닉 이름입니다. 니모닉 이름이 RFC에 나열되지 않은 경우 &lt;code&gt;Opcode&lt;/code&gt; 일 수도 있습니다 . 예 : &lt;code&gt;OP code: 53, mnemonic name ECHO erlang atom: echo&lt;/code&gt; . 이 이벤트는 &lt;code&gt;&lt;a href=&quot;ssh_connection#ptty_alloc-4&quot;&gt;ssh_connection:ptty_alloc/4&lt;/a&gt;&lt;/code&gt; 호출의 결과로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="d53dd83df64a4aed582356aeff9d756b34b98db4" translate="yes" xml:space="preserve">
          <source>A qualifier Q is one of the following:</source>
          <target state="translated">한정자 Q는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="16e918dd54f68fd1cee2a154501ced6dc2ab06fa" translate="yes" xml:space="preserve">
          <source>A query handle is evaluated in the following order:</source>
          <target state="translated">쿼리 핸들은 다음 순서로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="0e8baf0d28cdf7d93d387dd8846b5f6b10083008" translate="yes" xml:space="preserve">
          <source>A raw option request &lt;code&gt;RawOptReq = {raw, Protocol, OptionNum, ValueSpec}&lt;/code&gt; can be used to get information about socket options not (explicitly) supported by the emulator. The use of raw socket options makes the code non-portable, but allows the Erlang programmer to take advantage of unusual features present on a particular platform.</source>
          <target state="translated">원시 옵션 요청 &lt;code&gt;RawOptReq = {raw, Protocol, OptionNum, ValueSpec}&lt;/code&gt; 을 사용하여 에뮬레이터에서 (명시 적으로) 지원되지 않는 소켓 옵션에 대한 정보를 얻을 수 있습니다. 원시 소켓 옵션을 사용하면 코드를 이식 할 수 없지만 Erlang 프로그래머가 특정 플랫폼에있는 비정상적인 기능을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f61712a9538d9f895b83ffb3d3be147091cb2096" translate="yes" xml:space="preserve">
          <source>A raw option request &lt;code&gt;RawOptReq = {raw, Protocol, OptionNum, ValueSpec}&lt;/code&gt; can be used to get information about socket options not (explicitly) supported by the emulator. The use of raw socket options makes the code non-portable, but allows the Erlang programmer to take advantage of unusual features present on the current platform.</source>
          <target state="translated">Raw 옵션 요청 &lt;code&gt;RawOptReq = {raw, Protocol, OptionNum, ValueSpec}&lt;/code&gt; 을 사용하여 에뮬레이터에서 지원하지 않는 소켓 옵션에 대한 정보를 얻을 수 있습니다. 원시 소켓 옵션을 사용하면 코드를 이식 할 수 없지만 Erlang 프로그래머는 현재 플랫폼에있는 비정상적인 기능을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ebff0e214120dc5d32ac8a4a0637ce5cce89676" translate="yes" xml:space="preserve">
          <source>A read event was cancelled by &lt;code&gt;ERL_NIF_SELECT_CANCEL&lt;/code&gt; or &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; and is guaranteed not to generate a &lt;code&gt;ready_input&lt;/code&gt; notification message.</source>
          <target state="translated">읽기 이벤트가 &lt;code&gt;ERL_NIF_SELECT_CANCEL&lt;/code&gt; 또는 &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; 에 의해 취소되었으며 &lt;code&gt;ready_input&lt;/code&gt; 알림 메시지 를 생성하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8ff008f39f98c26bb673531ccb371655a692f01c" translate="yes" xml:space="preserve">
          <source>A recommended starting point for the first-time user is the documentation of the &lt;code&gt;&lt;a href=&quot;#type-syntaxTree&quot;&gt;syntaxTree()&lt;/a&gt;&lt;/code&gt; data type, and the function &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">처음 사용하는 사용자에게 권장되는 시작점은 &lt;code&gt;&lt;a href=&quot;#type-syntaxTree&quot;&gt;syntaxTree()&lt;/a&gt;&lt;/code&gt; 데이터 유형 및 함수 &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eb56dddcb8b70cd19ebdc2bcc639e335bb693c26" translate="yes" xml:space="preserve">
          <source>A recommended starting point for the first-time user is the documentation of the function &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">처음 사용자에게 권장되는 시작점은 함수 &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt; 에 대한 문서입니다 .</target>
        </trans-unit>
        <trans-unit id="1e58752debf6eb10b77ef1dd1dbb8c914a8de4f8" translate="yes" xml:space="preserve">
          <source>A record definition can be placed anywhere among the attributes and function declarations of a module, but the definition must come before any usage of the record.</source>
          <target state="translated">레코드 정의는 모듈의 속성 및 함수 선언 중 어디에나 배치 될 수 있지만 정의는 레코드를 사용하기 전에 이루어져야합니다.</target>
        </trans-unit>
        <trans-unit id="ba583d421bbddc518a0b6122d30465ab600660d3" translate="yes" xml:space="preserve">
          <source>A record definition consists of the name of the record, followed by the field names of the record. Record and field names must be atoms. Each field can be given an optional default value. If no default value is supplied, &lt;code&gt;undefined&lt;/code&gt; is used.</source>
          <target state="translated">레코드 정의는 레코드 이름과 레코드의 필드 이름으로 구성됩니다. 레코드 및 필드 이름은 원자 여야합니다. 각 필드에는 선택적 기본값이 제공 될 수 있습니다. 기본값이 제공 &lt;code&gt;undefined&lt;/code&gt; 않으면 undefined 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1bbaae8298ac3d9e6e938e77fc79043b34deaf0a" translate="yes" xml:space="preserve">
          <source>A record has possibly been deleted with &lt;code&gt;&lt;a href=&quot;mnesia#delete_object-1&quot;&gt;mnesia:delete_object/1&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;OldRecord&lt;/code&gt; contains the value of the old record, as stated as argument by the application. Notice that other records with the same key can remain in the table if it is of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#delete_object-1&quot;&gt;mnesia:delete_object/1&lt;/a&gt;&lt;/code&gt; 로 레코드가 삭제되었을 수 있습니다 . &lt;code&gt;OldRecord&lt;/code&gt; 는 응용 프로그램에서 인수로 언급 한대로 이전 레코드의 값을 포함합니다. &lt;code&gt;bag&lt;/code&gt; 유형 인 경우 동일한 키를 가진 다른 레코드가 테이블에 남아있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72d63fe5211c7ae3ef0a86204219aaaa2f059f47" translate="yes" xml:space="preserve">
          <source>A record is a data structure for storing a fixed number of elements. It has named fields and is similar to a struct in C. However, a record is not a true data type. Instead, record expressions are translated to tuple expressions during compilation. Therefore, record expressions are not understood by the shell unless special actions are taken. For details, see the &lt;code&gt;shell(3)&lt;/code&gt; manual page in STDLIB).</source>
          <target state="translated">레코드는 고정 된 수의 요소를 저장하기위한 데이터 구조입니다. 필드의 이름을 지정했으며 C의 구조체와 비슷하지만 레코드는 실제 데이터 형식이 아닙니다. 대신, 레코드 표현식은 컴파일 중에 튜플 표현식으로 변환됩니다. 따라서 특별한 조치를 취하지 않으면 쉘은 레코드 표현식을 이해하지 못합니다. 자세한 내용 은 STDLIB 의 &lt;code&gt;shell(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="10b1bbed2ccfee04b70ac0a61eb0d3ccdccb28c7" translate="yes" xml:space="preserve">
          <source>A record is a data structure for storing a fixed number of elements. It has named fields and is similar to a struct in C. Record expressions are translated to tuple expressions during compilation. Therefore, record expressions are not understood by the shell unless special actions are taken. For details, see the &lt;code&gt;shell(3)&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">레코드는 고정 된 수의 요소를 저장하기위한 데이터 구조입니다. 필드 이름이 지정되었으며 C의 구조체와 유사합니다. 레코드 표현식은 컴파일 중에 튜플 표현식으로 변환됩니다. 따라서 특별한 조치를 취하지 않으면 쉘은 레코드 표현식을 이해하지 못합니다. 자세한 내용 은 STDLIB 의 &lt;code&gt;shell(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c08da4f4936f6c7ef6c5c849615f4e5aa16f8d6a" translate="yes" xml:space="preserve">
          <source>A record is defined as:</source>
          <target state="translated">레코드는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="2caff8ac97a88a40d8081c22ddabb3164e9d8ee2" translate="yes" xml:space="preserve">
          <source>A record that describes an employee can look as follows:</source>
          <target state="translated">직원을 설명하는 레코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea49bf259e7f3ffbeb1c63e53edd2986c4da3837" translate="yes" xml:space="preserve">
          <source>A reference is a term that is unique in an Erlang runtime system, created by calling &lt;code&gt;make_ref/0&lt;/code&gt;.</source>
          <target state="translated">참조는 Erlang 런타임 시스템에서 고유 한 용어로 &lt;code&gt;make_ref/0&lt;/code&gt; 을 호출하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="14e8331cdb8c151b2856ff19909f37919f2942e9" translate="yes" xml:space="preserve">
          <source>A reference refers into a node table, which also consumes memory.</source>
          <target state="translated">참조는 메모리를 소비하는 노드 테이블을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f5a40d0612040493ede164c97573dfd19a4e473a" translate="yes" xml:space="preserve">
          <source>A reference that uniquely identifies the (select) operation.</source>
          <target state="translated">(선택) 작업을 고유하게 식별하는 참조입니다.</target>
        </trans-unit>
        <trans-unit id="0a4f0d6f1f9b5df543605d7bc8edbd15d630e93c" translate="yes" xml:space="preserve">
          <source>A registered name.</source>
          <target state="translated">등록 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4417be038ecab856e8399ba11dec3102f33f7d40" translate="yes" xml:space="preserve">
          <source>A registered send operation has occurred and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; contains the pid of the sender. The message is in &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt;.</source>
          <target state="translated">등록 된 전송 조작이 발생했으며 &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; 에 발신자의 pid가 포함되어 있습니다. 메시지는 &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e77a6a05b56401cd9d0ab970f691941ff41f5126" translate="yes" xml:space="preserve">
          <source>A registered send operation occurred. &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; contains the pid of the sender.</source>
          <target state="translated">등록 된 전송 조작이 발생했습니다. &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; 은 발신자의 pid 를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="f8d3748e235b7729da3350a0d2920104b36dba36" translate="yes" xml:space="preserve">
          <source>A registry that has previously been created with &lt;code&gt;ei_reg_open()&lt;/code&gt; is closed, and all the objects it contains are freed.</source>
          <target state="translated">이전에 &lt;code&gt;ei_reg_open()&lt;/code&gt; 으로 작성된 레지스트리 가 닫히고 여기에 포함 된 모든 오브젝트가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="d54a6449f65944104c58b103284695849e8fb0c0" translate="yes" xml:space="preserve">
          <source>A regular expression based lexical analyzer generator for Erlang, similar to lex or flex.</source>
          <target state="translated">Erlang 용 정규 표현식 기반 어휘 분석기 생성기 (lex 또는 flex)와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="d1dac6b0a35eaa9eeb715296367bf1003d8ca372" translate="yes" xml:space="preserve">
          <source>A regular expression is a pattern that is matched against a subject string from left to right. Most characters stand for themselves in a pattern and match the corresponding characters in the subject. As a trivial example, the following pattern matches a portion of a subject string that is identical to itself:</source>
          <target state="translated">정규식은 왼쪽에서 오른쪽으로 제목 문자열과 일치하는 패턴입니다. 대부분의 문자는 패턴으로 표시되며 주제의 해당 문자와 ​​일치합니다. 사소한 예로서, 다음 패턴은 자신과 동일한 주제 문자열의 일부와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="72879a85f0e7c023321bf2bf93898f7dd0d964ea" translate="yes" xml:space="preserve">
          <source>A relation R in X is &lt;strong&gt;reflexive&lt;/strong&gt; if x R x for every element x of X, it is &lt;strong&gt;symmetric&lt;/strong&gt; if x R y implies that y R x, and it is &lt;strong&gt;transitive&lt;/strong&gt; if x R y and y R z imply that x R z.</source>
          <target state="translated">X에 관계 R은 &lt;strong&gt;재귀&lt;/strong&gt; X의 각 원소 (X)에 대한 X의 R X가,이 경우 &lt;strong&gt;대칭&lt;/strong&gt; X는 Y가 Y R의 X를 의미 R 경우하고는 &lt;strong&gt;전이&lt;/strong&gt; (X)의 R의 Y 및 Y R의 Z가 X의 R의 Z를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d4e299db49e468c2bde2833d058721d987434955" translate="yes" xml:space="preserve">
          <source>A relation in a set is an &lt;strong&gt;equivalence relation&lt;/strong&gt; if it is reflexive, symmetric, and transitive.</source>
          <target state="translated">세트의 관계는 그것이 반사적이고 대칭 적이며 전 이적이라면 &lt;strong&gt;등가 관계&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0ebab014aefe1952987eeb358deade3e55cb740e" translate="yes" xml:space="preserve">
          <source>A relational/object hybrid data model that is suitable for telecommunications applications.</source>
          <target state="translated">통신 애플리케이션에 적합한 관계형 / 개체 하이브리드 데이터 모델.</target>
        </trans-unit>
        <trans-unit id="bdbc21562cd7fcdf1a6c8c8fdaf7713b768b8540" translate="yes" xml:space="preserve">
          <source>A release package can also contain:</source>
          <target state="translated">릴리스 패키지에는 다음이 포함될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="70a237d6b6ad6eae7ebaff5d81629ed2d641cc80" translate="yes" xml:space="preserve">
          <source>A release package is always to contain:</source>
          <target state="translated">릴리즈 패키지는 항상 다음을 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec17e9f9c454053a070fd20ff7eeb8af0a65c4c3" translate="yes" xml:space="preserve">
          <source>A release resource file, &lt;code&gt;Name.rel&lt;/code&gt;</source>
          <target state="translated">릴리즈 리소스 파일 인 &lt;code&gt;Name.rel&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa054e2d79bd8ac06f390024625251631581f417" translate="yes" xml:space="preserve">
          <source>A release upgrade file, &lt;code&gt;relup&lt;/code&gt;</source>
          <target state="translated">이형 업그레이드 파일, &lt;code&gt;relup&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fe2e6189285d97d6577d1e21b467c08a9445c7c" translate="yes" xml:space="preserve">
          <source>A released application must follow a certain structure.</source>
          <target state="translated">출시 된 응용 프로그램은 특정 구조를 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="1ffc64bafad7783a2c6df745a520b71eddb2ea11" translate="yes" xml:space="preserve">
          <source>A relup script can only have one &lt;code&gt;restart_emulator&lt;/code&gt; instruction and it must always be placed at the end. If the relup is generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;, this is automatically ensured.</source>
          <target state="translated">relup 스크립트는 하나의 &lt;code&gt;restart_emulator&lt;/code&gt; 명령 만 가질 수 있으며 항상 끝에 배치해야합니다. reltools가 &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; 에 의해 생성되면 자동으로 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="c55e43ee14cb55c89c46dda7dd3c64e06ed074e9" translate="yes" xml:space="preserve">
          <source>A remote Erlang file server cannot be used. The computer on which the Erlang node is running must have access to the file system (directly or through NFS).</source>
          <target state="translated">원격 Erlang 파일 서버를 사용할 수 없습니다. Erlang 노드가 실행중인 컴퓨터는 파일 시스템에 직접 또는 NFS를 통해 액세스 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a57b69cf3ad43e824a3831ee7e57db92ae3dde80" translate="yes" xml:space="preserve">
          <source>A remote execution can terminate violently because of a signal. Then this message can be received. For details on valid string values, see &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; Section 6.10, which shows a special case of these signals.</source>
          <target state="translated">신호로 인해 원격 실행이 심하게 종료 될 수 있습니다. 그러면이 메시지를받을 수 있습니다. 유효한 문자열 값에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; 섹션 6.10을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c596892eeac26bffdaa259eeeee428644ec4341" translate="yes" xml:space="preserve">
          <source>A remote execution can terminate violently because of a signal. Then this message can be received. For details on valid string values, see &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4254#section-6.10&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; Section 6.10, which shows a special case of these signals.</source>
          <target state="translated">원격 실행은 신호로 인해 심하게 종료 될 수 있습니다. 그러면이 메시지를받을 수 있습니다. 유효한 문자열 값에 대한 자세한 내용 은 이러한 신호의 특수 사례를 보여주는 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4254#section-6.10&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; 섹션 6.10을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cfa0f3b36cc97b41ae10c4a61219216ab07da247" translate="yes" xml:space="preserve">
          <source>A remote node Y must be known to node X if there exists any pids, ports, references, or funs (Erlang data types) from Y on X, or if X and Y are connected. The maximum number of remote nodes simultaneously/ever known to a node is limited by the &lt;code&gt;&lt;a href=&quot;#atoms&quot;&gt;maximum number of atoms&lt;/a&gt;&lt;/code&gt; available for node names. All data concerning remote nodes, except for the node name atom, are garbage-collected.</source>
          <target state="translated">X의 Y에 pid, 포트, 참조 또는 fun (Erlang 데이터 유형)이 있거나 X와 Y가 연결된 경우 원격 노드 Y를 노드 X에 알려야합니다. 동시에 / 노드에 알려진 최대 원격 노드 수는 노드 이름에 사용 가능한 &lt;code&gt;&lt;a href=&quot;#atoms&quot;&gt;maximum number of atoms&lt;/a&gt;&lt;/code&gt; 수에 의해 제한됩니다 . 노드 이름 atom을 제외한 원격 노드와 관련된 모든 데이터는 가비지 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="2ef0e40b8a94e3602eaf0a08318e503302907b08" translate="yes" xml:space="preserve">
          <source>A reply sent with this function is not visible in &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; debug output.</source>
          <target state="translated">이 기능과 함께 전송 된 응답은 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; 디버그 출력에 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="968b931f26a7eb0a1ce8e38bc2b4799ef2fd705f" translate="yes" xml:space="preserve">
          <source>A report callback is used by the formatter to transform log messages on report form to a format string and arguments. The report callback can be specified in the metadata for the log event. If no report callback exists in metadata, &lt;code&gt;logger_formatter&lt;/code&gt; will use &lt;code&gt;&lt;a href=&quot;logger#format_report-1&quot;&gt; logger:format_report/1&lt;/a&gt;&lt;/code&gt; as default callback.</source>
          <target state="translated">보고서 콜백은 포맷터에서 보고서 양식의 로그 메시지를 형식 문자열 및 인수로 변환하는 데 사용됩니다. 보고서 콜백은 로그 이벤트의 메타 데이터에 지정할 수 있습니다. 메타 데이터에 보고서 콜백이없는 경우 &lt;code&gt;logger_formatter&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;logger#format_report-1&quot;&gt; logger:format_report/1&lt;/a&gt;&lt;/code&gt; 을 기본 콜백으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d65b57be2761081067ca64ced4646ffe5f623f66" translate="yes" xml:space="preserve">
          <source>A report callback is used by the formatter to transform log messages on report form to a format string and arguments. The report callback can be specified in the metadata for the log event. If no report callback exists in metadata, &lt;code&gt;logger_formatter&lt;/code&gt; will use &lt;code&gt;&lt;a href=&quot;logger#format_report-1&quot;&gt;logger:format_report/1&lt;/a&gt;&lt;/code&gt; as default callback.</source>
          <target state="translated">포맷터는 보고서 콜백을 사용하여 보고서 양식의 로그 메시지를 형식 문자열 및 인수로 변환합니다. 보고서 콜백은 로그 이벤트의 메타 데이터에 지정할 수 있습니다. 메타 데이터에 보고서 콜백이 없으면 &lt;code&gt;logger_formatter&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;logger#format_report-1&quot;&gt;logger:format_report/1&lt;/a&gt;&lt;/code&gt; 을 기본 콜백으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3cb325283449bed9030a0b8eb054228f9049d2fb" translate="yes" xml:space="preserve">
          <source>A representaion of a part (or range) in a binary. &lt;code&gt;Start&lt;/code&gt; is a zero-based offset into a &lt;code&gt;binary()&lt;/code&gt; and &lt;code&gt;Length&lt;/code&gt; is the length of that part. As input to functions in this module, a reverse part specification is allowed, constructed with a negative &lt;code&gt;Length&lt;/code&gt;, so that the part of the binary begins at &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; and is -&lt;code&gt;Length&lt;/code&gt; long. This is useful for referencing the last &lt;code&gt;N&lt;/code&gt; bytes of a binary as &lt;code&gt;{size(Binary), -N}&lt;/code&gt;. The functions in this module always return &lt;code&gt;part()&lt;/code&gt;s with positive &lt;code&gt;Length&lt;/code&gt;.</source>
          <target state="translated">이진에서 부품 (또는 범위)을 나타냅니다. &lt;code&gt;Start&lt;/code&gt; 은 &lt;code&gt;binary()&lt;/code&gt; 대한 0부터 시작 하는 오프셋 이며 &lt;code&gt;Length&lt;/code&gt; 는 해당 부분의 길이입니다. 이 모듈의 기능에 대한 입력으로, 음수 &lt;code&gt;Length&lt;/code&gt; 로 구성된 반전 부품 지정이 허용 되므로 2 진 부분이 &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; 에서 시작 하고 &lt;code&gt;Length&lt;/code&gt; 길어집니다. 이진 의 마지막 &lt;code&gt;N&lt;/code&gt; 바이트를 &lt;code&gt;{size(Binary), -N}&lt;/code&gt; 참조 할 때 유용합니다 . 이 모듈의 함수는 항상 양의 &lt;code&gt;Length&lt;/code&gt; 를 가진 &lt;code&gt;part()&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="2f1aa5116d3fb4b00376ef8dcd3fa6e2ce235d63" translate="yes" xml:space="preserve">
          <source>A representation of a part (or range) in a binary. &lt;code&gt;Start&lt;/code&gt; is a zero-based offset into a &lt;code&gt;binary()&lt;/code&gt; and &lt;code&gt;Length&lt;/code&gt; is the length of that part. As input to functions in this module, a reverse part specification is allowed, constructed with a negative &lt;code&gt;Length&lt;/code&gt;, so that the part of the binary begins at &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; and is -&lt;code&gt;Length&lt;/code&gt; long. This is useful for referencing the last &lt;code&gt;N&lt;/code&gt; bytes of a binary as &lt;code&gt;{size(Binary), -N}&lt;/code&gt;. The functions in this module always return &lt;code&gt;part()&lt;/code&gt;s with positive &lt;code&gt;Length&lt;/code&gt;.</source>
          <target state="translated">바이너리로 된 부품 (또는 범위)의 표현입니다. &lt;code&gt;Start&lt;/code&gt; 는 0부터 시작 하여 &lt;code&gt;binary()&lt;/code&gt; 로의 오프셋 이고 &lt;code&gt;Length&lt;/code&gt; 는 해당 부분의 길이입니다. 이 모듈의 함수에 대한 입력으로 음의 &lt;code&gt;Length&lt;/code&gt; 구성된 역 부분 사양이 허용 되므로 바이너리 부분은 &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; 에서 시작 하고 &lt;code&gt;Length&lt;/code&gt; 입니다. 이것은 바이너리 의 마지막 &lt;code&gt;N&lt;/code&gt; 바이트를 &lt;code&gt;{size(Binary), -N}&lt;/code&gt; 로 참조하는 데 유용합니다 . 이 모듈의 함수는 항상 양의 &lt;code&gt;Length&lt;/code&gt; 로 &lt;code&gt;part()&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3cd076e54cc70b0a6f690c2fbc8ae7eee141d7ed" translate="yes" xml:space="preserve">
          <source>A representation of the current context of the pretty-printer. Can be accessed in hook functions.</source>
          <target state="translated">프리티 프린터의 현재 컨텍스트를 나타냅니다. 후크 기능으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2faa414df8b457497c58bbac25134eed33ca746" translate="yes" xml:space="preserve">
          <source>A request handle, see &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt; send_request/2 &lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">요청 핸들, 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt; send_request/2 &lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="060acb73f9bf52d61dfcf27189e091e2a0ff80f3" translate="yes" xml:space="preserve">
          <source>A request handle, see &lt;code&gt;&lt;a href=&quot;#send_request-3&quot;&gt; send_request/3 &lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">요청 핸들, 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#send_request-3&quot;&gt; send_request/3 &lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="489f7c9165ae17355e87065058b1cd9bf9bd345f" translate="yes" xml:space="preserve">
          <source>A request to http://your.server.org/cgi-bin/example/httpd_example:yahoo would refer to httpd_example:yahoo/3 or, if that does not exist, httpd_example:yahoo/2 and http://your.server.org/cgi-bin/example/other:yahoo would not be allowed to execute.</source>
          <target state="translated">http://your.server.org/cgi-bin/example/httpd_example:yahoo에 대한 요청은 httpd_example : yahoo / 3를 참조하거나 존재하지 않는 경우 httpd_example : yahoo / 2 및 http : // your를 나타냅니다. server.org/cgi-bin/example/other:yahoo는 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="aa222544811c186e688c873a3b1f9169cad3037b" translate="yes" xml:space="preserve">
          <source>A request to terminate the transport process after having received DPA in response to DPR. The transport process should exit. &lt;code&gt;Pid&lt;/code&gt; is the pid() of the parent process.</source>
          <target state="translated">DPR에 대한 응답으로 DPA를받은 후 전송 프로세스 종료 요청. 전송 프로세스가 종료되어야합니다. &lt;code&gt;Pid&lt;/code&gt; 는 부모 프로세스의 pid ()입니다.</target>
        </trans-unit>
        <trans-unit id="7e78eeac55809d5c5a5db06a988ff97769682bea" translate="yes" xml:space="preserve">
          <source>A required variable can also be given a default value to be used if the variable is not found in any configuration file. To specify a default value, add a tuple on the form &lt;code&gt;{default_config,ConfigVariableName,Value}&lt;/code&gt; to the test case information list (the position in the list is irrelevant).</source>
          <target state="translated">구성 파일에서 변수를 찾을 수없는 경우 필요한 변수에 기본값을 지정할 수도 있습니다. 기본값을 지정하려면 &lt;code&gt;{default_config,ConfigVariableName,Value}&lt;/code&gt; 형식의 튜플을 테스트 케이스 정보 목록에 추가하십시오 (목록의 위치는 관련이 없음).</target>
        </trans-unit>
        <trans-unit id="c1229803283f11562375509c222552c10accf62d" translate="yes" xml:space="preserve">
          <source>A resource term can be serialized with &lt;code&gt;term_to_binary&lt;/code&gt; and later be fully recreated if the resource object is still alive when &lt;code&gt;binary_to_term&lt;/code&gt; is called. A &lt;strong&gt;stale&lt;/strong&gt; resource term will be returned from &lt;code&gt;binary_to_term&lt;/code&gt; if the resource object has been deallocated. &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; will return false for stale resource terms.</source>
          <target state="translated">자원 용어는 &lt;code&gt;term_to_binary&lt;/code&gt; 로 직렬화 할 수 있으며 &lt;code&gt;binary_to_term&lt;/code&gt; 이 호출 될 때 자원 오브젝트가 여전히 활성 상태이면 나중에 완전히 다시 작성됩니다 . &lt;strong&gt;부실&lt;/strong&gt; 리소스 용어에서 반환됩니다 &lt;code&gt;binary_to_term&lt;/code&gt; 자원 객체가 해제 된 경우. 오래된 자원 용어에 대해서는 &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; 가 false를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="50ae922c622293c13dbc2965d257c86fc95a1f21" translate="yes" xml:space="preserve">
          <source>A resource to be managed is represented by a managed object, which resides in the MIB. In an SNMP MIB, the managed objects are either:</source>
          <target state="translated">관리 할 자원은 MIB에 상주하는 관리 대상 오브젝트로 표시됩니다. SNMP MIB에서 관리 대상 객체는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="8e4eb7e095c0c09d5767bd5279f5cdff3096b732" translate="yes" xml:space="preserve">
          <source>A restricted set of &lt;code&gt;&lt;a href=&quot;#type-spawn_option&quot;&gt;spawn options&lt;/a&gt;&lt;/code&gt;. Most notably &lt;code&gt;monitor&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; part of these options.</source>
          <target state="translated">제한된 &lt;code&gt;&lt;a href=&quot;#type-spawn_option&quot;&gt;spawn options&lt;/a&gt;&lt;/code&gt; 세트 . 특히 &lt;code&gt;monitor&lt;/code&gt; 는 이러한 옵션의 일부 가 &lt;strong&gt;아닙니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d797a366df3377e950dd7503223fc79e6918d3ba" translate="yes" xml:space="preserve">
          <source>A returned error reason can be converted into a readable string using &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">리턴 된 오류 이유는 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 을 사용하여 읽을 수있는 문자열로 변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1717e1bc6c4fa58d53cbf11fb5819e00bdd83ca" translate="yes" xml:space="preserve">
          <source>A rudimentary DNS client.</source>
          <target state="translated">기초적인 DNS 클라이언트.</target>
        </trans-unit>
        <trans-unit id="59d2054b44ad5d0ec1cf63133801ae0786ec3996" translate="yes" xml:space="preserve">
          <source>A rule is recognized by its right-pointer arrow: &lt;code&gt;=&amp;gt;&lt;/code&gt;. To the left of the arrow is one or more instruction patterns, separated by &lt;code&gt;|&lt;/code&gt;. To the right of the arrow is zero or more instructions, separated by &lt;code&gt;|&lt;/code&gt;. If the instructions from the BEAM code matches the instruction patterns on the left side, they will be replaced with instructions on the right side (or removed if there are no instructions on the right).</source>
          <target state="translated">규칙은 오른쪽 포인터 화살표 &lt;code&gt;=&amp;gt;&lt;/code&gt; 로 인식됩니다 . 화살표 왼쪽에는 &lt;code&gt;|&lt;/code&gt; 로 구분 된 하나 이상의 명령 패턴이 있습니다. . 화살표 오른쪽에는 &lt;code&gt;|&lt;/code&gt; 로 구분 된 0 개 이상의 명령이 있습니다. . BEAM 코드의 명령어가 왼쪽의 명령어 패턴과 일치하면 오른쪽의 명령어로 대체됩니다 (또는 오른쪽에 명령어가없는 경우 제거됨).</target>
        </trans-unit>
        <trans-unit id="23ab6d0ea4f0599f5b342196442f9968fded07ef" translate="yes" xml:space="preserve">
          <source>A run queue has four queues for processes of different priority and one queue for ports. The scheduler thread associated with the run queue switch evenly between execution of processes and execution of ports while both processes and ports exist in the queue. This is not completely true, but not important for this discussion. A port that is in a run queue also has a queue of tasks to execute. Each task corresponds to an in- or outgoing signal. When the port is selected for execution each task will be executed in sequence. The run queue locks not only protected the queues of ports, but also the queues of port tasks.</source>
          <target state="translated">실행 대기열에는 우선 순위가 다른 프로세스에 대한 4 개의 대기열과 포트에 대한 1 개의 대기열이 있습니다. 실행 큐와 연관된 스케줄러 스레드는 프로세스와 포트가 모두 큐에 존재하는 동안 프로세스 실행과 포트 실행간에 균등하게 전환됩니다. 이것은 완전히 사실은 아니지만이 논의에서 중요하지 않습니다. 실행 대기열에있는 포트에는 실행할 작업 대기열도 있습니다. 각 작업은 수신 또는 발신 신호에 해당합니다. 실행을 위해 포트를 선택하면 각 작업이 순서대로 실행됩니다. 실행 대기열 잠금은 포트 대기열뿐만 아니라 포트 작업 대기열도 보호합니다.</target>
        </trans-unit>
        <trans-unit id="dd25b98d67a3d5acbff27d930ee3340ca6349672" translate="yes" xml:space="preserve">
          <source>A run-time error can also be emulated by calling &lt;code&gt;erlang:error(Reason)&lt;/code&gt; or &lt;code&gt;erlang:error(Reason, Args)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:error(Reason)&lt;/code&gt; 또는 &lt;code&gt;erlang:error(Reason, Args)&lt;/code&gt; 를 호출하여 런타임 오류를 에뮬레이션 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb56303785fbc88fcc2408a8fd31a4003ffe1f34" translate="yes" xml:space="preserve">
          <source>A run-time error is another name for an exception of class &lt;code&gt;error&lt;/code&gt;.</source>
          <target state="translated">런타임 오류는 class &lt;code&gt;error&lt;/code&gt; 예외의 다른 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="608acd283e8c59f26f33232a215b266093ace6dd" translate="yes" xml:space="preserve">
          <source>A run-time error is when a crash occurs. An example is when an operator is applied to arguments of the wrong type. The Erlang programming language has built-in features for handling of run-time errors.</source>
          <target state="translated">런타임 오류는 충돌이 발생했을 때입니다. 예를 들어 연산자가 잘못된 유형의 인수에 적용되는 경우가 있습니다. Erlang 프로그래밍 언어에는 런타임 오류 처리를위한 기능이 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe2de4d023b6ff93a7868d6e63e1e0f0f608db09" translate="yes" xml:space="preserve">
          <source>A runtime error occurred which raised and error exception while applying the function, and the applied function did not catch the exception. The error reason &lt;code&gt;ErrorReason&lt;/code&gt; indicates the type of error that occurred. &lt;code&gt;StackTrace&lt;/code&gt; is formatted as when caught in a &lt;code&gt;try/catch&lt;/code&gt; construct. The &lt;code&gt;StackTrace&lt;/code&gt; is limited to the applied function and functions called by it.</source>
          <target state="translated">함수를 적용하는 동안 예외가 발생하고 오류가 발생한 런타임 오류가 발생하여 적용된 함수가 예외를 포착하지 못했습니다. 오류 이유 &lt;code&gt;ErrorReason&lt;/code&gt; 은 발생한 오류 유형을 나타냅니다. &lt;code&gt;StackTrace&lt;/code&gt; 는 &lt;code&gt;try/catch&lt;/code&gt; 구문 에서 발견 될 때 형식이 지정됩니다 . &lt;code&gt;StackTrace&lt;/code&gt; 그것에 의해인가라는 함수 및 함수에 한정된다.</target>
        </trans-unit>
        <trans-unit id="1f38ec391b2ae32351853cf5569dd5468c7febd8" translate="yes" xml:space="preserve">
          <source>A runtime system Lock Profiling tool.</source>
          <target state="translated">런타임 시스템 잠금 프로파일 링 도구.</target>
        </trans-unit>
        <trans-unit id="95c23e7c0085aa6a0c7d2ad3fa2a9bf1781844a4" translate="yes" xml:space="preserve">
          <source>A second use of backslash provides a way of encoding non-printing characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters, apart from the binary zero that terminates a pattern. When a pattern is prepared by text editing, it is often easier to use one of the following escape sequences than the binary character it represents:</source>
          <target state="translated">백 슬래시를 두 번째로 사용하면 비 인쇄 문자를 패턴으로 시각적으로 인코딩하는 방법이 제공됩니다. 패턴을 종료하는 2 진 0을 제외하고 비 인쇄 문자의 모양에는 제한이 없습니다. 텍스트 편집으로 패턴을 준비 할 때, 이진 문자보다 다음 이스케이프 시퀀스 중 하나를 사용하는 것이 더 쉬운 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="a201830f8803ef3e185325b4733be9adee2043a8" translate="yes" xml:space="preserve">
          <source>A second way to specify the configuration file is to set environment variable &lt;code&gt;ERL_INETRC&lt;/code&gt; to the full name of the file. Example (bash):</source>
          <target state="translated">구성 파일을 지정하는 두 번째 방법은 환경 변수 &lt;code&gt;ERL_INETRC&lt;/code&gt; 를 파일의 전체 이름으로 설정하는 것입니다. 예 (bash) :</target>
        </trans-unit>
        <trans-unit id="7c03bbcb91f237153974d54fa53f5db174271fa2" translate="yes" xml:space="preserve">
          <source>A seed value for the generator.</source>
          <target state="translated">생성기의 시드 값입니다.</target>
        </trans-unit>
        <trans-unit id="3ab326930bafdf3ccbffeefe99fd3e37e21b2a36" translate="yes" xml:space="preserve">
          <source>A segment of type &lt;code&gt;utf16&lt;/code&gt; can match 2 or 4 bytes in the binary. The match fails if the binary at the match position does not contain a legal UTF-16 encoding of a Unicode code point. (See RFC-2781 or the Unicode standard.)</source>
          <target state="translated">&lt;code&gt;utf16&lt;/code&gt; 유형의 세그먼트는 2 진에서 2 또는 4 바이트와 일치 할 수 있습니다. 일치 위치의 바이너리에 유니 코드 코드 포인트의 유효한 UTF-16 인코딩이 포함되어 있지 않으면 일치가 실패합니다. RFC-2781 또는 유니 코드 표준을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="39d79b140754fe8ea4a56be0590e56af2f7d1ffd" translate="yes" xml:space="preserve">
          <source>A segment of type &lt;code&gt;utf32&lt;/code&gt; can match 4 bytes in the binary in the same way as an &lt;code&gt;integer&lt;/code&gt; segment matches 32 bits. The match fails if the resulting integer is outside the legal ranges mentioned above.</source>
          <target state="translated">&lt;code&gt;utf32&lt;/code&gt; 유형의 세그먼트 는 &lt;code&gt;integer&lt;/code&gt; 세그먼트가 32 비트와 동일한 방식으로 2 진에서 4 바이트를 일치 시킬 수 있습니다 . 결과 정수가 위에서 언급 한 법적 범위를 벗어나면 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9984182f8f78656080573a1d2d8804143caf4c98" translate="yes" xml:space="preserve">
          <source>A segment of type &lt;code&gt;utf8&lt;/code&gt; matches 1-4 bytes in the binary, if the binary at the match position contains a valid UTF-8 sequence. (See RFC-3629 or the Unicode standard.)</source>
          <target state="translated">일치 위치의 이진에 유효한 UTF-8 시퀀스가 ​​포함 된 경우 &lt;code&gt;utf8&lt;/code&gt; 유형의 세그먼트가 이진의 1-4 바이트와 일치합니다. RFC-3629 또는 유니 코드 표준을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a68e30a75c41fb283b1d801f37a87f7e17458fd0" translate="yes" xml:space="preserve">
          <source>A selective receive cannot be used from a &lt;code&gt;gen_statem&lt;/code&gt; behavior as for any &lt;code&gt;gen_*&lt;/code&gt; behavior, as the receive statement is within the &lt;code&gt;gen_*&lt;/code&gt; engine itself. It must be there because all &lt;code&gt;sys&lt;/code&gt; compatible behaviors must respond to system messages and therefore do that in their engine receive loop, passing non-system messages to the callback module.</source>
          <target state="translated">receive 문이 &lt;code&gt;gen_*&lt;/code&gt; 엔진 자체에 있기 때문에 &lt;code&gt;gen_*&lt;/code&gt; 동작에 대해서는 &lt;code&gt;gen_statem&lt;/code&gt; 동작 에서 선택적 수신을 사용할 수 없습니다 . 모든 &lt;code&gt;sys&lt;/code&gt; 호환 가능 동작은 시스템 메시지에 응답해야하므로 엔진 수신 루프에서 비 시스템 메시지를 콜백 모듈로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="0745a97f08a27b99c095a4208fa9ad69e20c8725" translate="yes" xml:space="preserve">
          <source>A selective receive cannot be used from a &lt;code&gt;gen_statem&lt;/code&gt; behaviour (or from any &lt;code&gt;gen_*&lt;/code&gt; behaviour), as the receive statement is within the &lt;code&gt;gen_*&lt;/code&gt; engine itself. It must be there because all &lt;code&gt;sys&lt;/code&gt; compatible behaviours must respond to system messages and therefore do that in their engine receive loop, passing non-system messages to the &lt;strong&gt;callback module&lt;/strong&gt;.</source>
          <target state="translated">receive 문이 &lt;code&gt;gen_*&lt;/code&gt; 엔진 자체 내에 있기 때문에 &lt;code&gt;gen_statem&lt;/code&gt; 동작 (또는 &lt;code&gt;gen_*&lt;/code&gt; 동작) 에서 선택적 수신을 사용할 수 없습니다 . 모든 &lt;code&gt;sys&lt;/code&gt; 호환 동작은 시스템 메시지에 응답해야하므로 엔진 수신 루프에서이를 수행하여 시스템이 아닌 메시지를 &lt;strong&gt;콜백 모듈로&lt;/strong&gt; 전달해야합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="784ef7e594348fdd6dc02214ab3a2844aad416d3" translate="yes" xml:space="preserve">
          <source>A sequence group can have subgroups. Such subgroups can have any property, that is, they are not required to also be sequences. If you want the status of the subgroup to affect the sequence on the level above, return &lt;code&gt;{return_group_result,Status}&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt;, as described in section &lt;code&gt;&lt;a href=&quot;write_test_chapter#repeated_groups&quot;&gt;Repeated Groups&lt;/a&gt;&lt;/code&gt; in Writing Test Suites. A failed subgroup (&lt;code&gt;Status == failed&lt;/code&gt;) causes the execution of a sequence to fail in the same way a test case does.</source>
          <target state="translated">시퀀스 그룹에는 하위 그룹이있을 수 있습니다. 이러한 부분 군은 임의의 특성을 가질 수 있는데, 즉 이들은 또한 서열 일 필요는 없다. 하위 그룹의 상태가 위 레벨의 순서에 영향을 미치려면 테스트 스위트 작성의 &lt;code&gt;&lt;a href=&quot;write_test_chapter#repeated_groups&quot;&gt;Repeated Groups&lt;/a&gt;&lt;/code&gt; 섹션에 설명 된대로 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;{return_group_result,Status}&lt;/code&gt; 를 리턴 하십시오 . 실패한 하위 그룹 ( &lt;code&gt;Status == failed&lt;/code&gt; )으로 인해 테스트 사례와 동일한 방식으로 시퀀스 실행이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="93d62b825639ee7da64906b6efb6ddcaeabea4e9" translate="yes" xml:space="preserve">
          <source>A sequence group can have subgroups. Such subgroups can have any property, that is, they are not required to also be sequences. If you want the status of the subgroup to affect the sequence on the level above, return &lt;code&gt;{return_group_result,Status}&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt;, as described in section &lt;code&gt;&lt;a href=&quot;write_test_chapter#repeated_groups&quot;&gt;Repeated Groups&lt;/a&gt;&lt;/code&gt; in Writing Test Suites. A failed subgroup (&lt;code&gt;Status == failed&lt;/code&gt;) causes the execution of a sequence to fail in the same way a test case does.</source>
          <target state="translated">시퀀스 그룹에는 하위 그룹이있을 수 있습니다. 이러한 하위 그룹은 모든 속성을 가질 수 있습니다. 즉, 시퀀스 일 필요도 없습니다. 하위 그룹의 상태가 위 수준의 시퀀스에 영향을 미치도록하려면 테스트 스위트 작성의 &lt;code&gt;&lt;a href=&quot;write_test_chapter#repeated_groups&quot;&gt;Repeated Groups&lt;/a&gt;&lt;/code&gt; 섹션에 설명 된대로 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;{return_group_result,Status}&lt;/code&gt; 를 반환 합니다. 실패한 하위 그룹 ( &lt;code&gt;Status == failed&lt;/code&gt; )은 테스트 케이스와 동일한 방식으로 시퀀스 실행을 실패하게합니다.</target>
        </trans-unit>
        <trans-unit id="3b0188d5cbf054170629f3b385114881c263276f" translate="yes" xml:space="preserve">
          <source>A sequence of &lt;code&gt;Len&lt;/code&gt; big-endian unsigned integers (4 bytes each, so &lt;code&gt;N'&lt;/code&gt; = 4 * &lt;code&gt;Len&lt;/code&gt;), but is to be regarded as uninterpreted data.</source>
          <target state="translated">&lt;code&gt;Len&lt;/code&gt; big-endian 부호없는 정수 시퀀스 (각각 4 바이트이므로 &lt;code&gt;N'&lt;/code&gt; = 4 * &lt;code&gt;Len&lt;/code&gt; )이지만 해석되지 않은 데이터로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d3c229a36faac40695a5902fc9fc7dd25d6c2813" translate="yes" xml:space="preserve">
          <source>A sequence of test cases is defined as a test case group with a &lt;code&gt;sequence&lt;/code&gt; property. Test case groups are defined through function &lt;code&gt;groups/0&lt;/code&gt; in the test suite (for details, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일련의 테스트 사례는 &lt;code&gt;sequence&lt;/code&gt; 속성이 있는 테스트 사례 그룹으로 정의됩니다 . 테스트 케이스 그룹은 테스트 스위트에서 기능 &lt;code&gt;groups/0&lt;/code&gt; 을 통해 정의됩니다 (자세한 내용은 &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt; 섹션 참조) .</target>
        </trans-unit>
        <trans-unit id="c3bba90a5446a96b415be975533162f2c93173c4" translate="yes" xml:space="preserve">
          <source>A server (daemon) is started with &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/3&lt;/a&gt;&lt;/code&gt;. Possible channel handlers (subsystems) are declared with the &lt;code&gt;&lt;a href=&quot;#type-subsystem_daemon_option&quot;&gt;subsystem&lt;/a&gt;&lt;/code&gt; option when the daemon is started.</source>
          <target state="translated">서버 (데몬)는 &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/3&lt;/a&gt;&lt;/code&gt; 로 시작 됩니다. 데몬이 시작될 때 가능한 채널 핸들러 (서브 시스템)가 &lt;code&gt;&lt;a href=&quot;#type-subsystem_daemon_option&quot;&gt;subsystem&lt;/a&gt;&lt;/code&gt; 옵션으로 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="c393c06211d748a66541912f6034dffb6bc6e68b" translate="yes" xml:space="preserve">
          <source>A server (daemon) will use the user name &lt;code&gt;foo&lt;/code&gt;, and a client will use the name &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">서버 (데몬)는 사용자 이름 &lt;code&gt;foo&lt;/code&gt; 를 사용하고 클라이언트는 이름 &lt;code&gt;bar&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="7591fe377fd82c97d5cbe48dffa3dba89975a255" translate="yes" xml:space="preserve">
          <source>A server only does x509-path validation in mode &lt;code&gt;verify_peer&lt;/code&gt;, as it then sends a certificate request to the client (this message is not sent if the verify option is &lt;code&gt;verify_none&lt;/code&gt;). You can then also want to specify option &lt;code&gt;fail_if_no_peer_cert&lt;/code&gt;.</source>
          <target state="translated">서버는 &lt;code&gt;verify_peer&lt;/code&gt; 모드에서 x509-path 유효성 검사 만 수행 하고 클라이언트에게 인증서 요청을 보냅니다 (이 옵션은 verify 옵션이 &lt;code&gt;verify_none&lt;/code&gt; 이면 전송되지 않습니다 ). 그런 다음 &lt;code&gt;fail_if_no_peer_cert&lt;/code&gt; 옵션을 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e1655ac106f00ec7e87a3349502f0ed6e2829f5" translate="yes" xml:space="preserve">
          <source>A server receiving a ClientHello MUST correctly ignore all unrecognized cipher suites, extensions, and other parameters. Otherwise, it may fail to interoperate with newer clients. In TLS 1.3, a client receiving a CertificateRequest or NewSessionTicket MUST also ignore all unrecognized extensions.</source>
          <target state="translated">ClientHello를 수신하는 서버는 인식되지 않는 모든 암호 스위트, 확장 및 기타 매개 변수를 올바르게 무시해야합니다. 그렇지 않으면 최신 클라이언트와 상호 운용되지 않을 수 있습니다. TLS 1.3에서 CertificateRequest 또는 NewSessionTicket을 수신하는 클라이언트는 인식되지 않는 모든 확장을 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="d55cabe8354d1d604d4df37a3e5535ff9d3abddc" translate="yes" xml:space="preserve">
          <source>A server which receives just enough requests to never become idle will score a CPU utilization of 100%. If the server receives 50% more requests, it will still score 100%. When the system load is calculated with the percentage formula shown previously, the load will increase from 80% to 87%.</source>
          <target state="translated">결코 유휴 상태가되지 않을만큼의 요청 만받는 서버는 CPU 사용률이 100 %입니다. 서버가 50 % 더 많은 요청을 받으면 여전히 100 %의 점수를받습니다. 앞에서 설명한 백분율 공식을 사용하여 시스템로드를 계산하면로드가 80 %에서 87 %로 증가합니다.</target>
        </trans-unit>
        <trans-unit id="49249370ad03c7d756d03cbc940860544a07d772" translate="yes" xml:space="preserve">
          <source>A server- or client-channel process can choose to close their session by sending a close event.</source>
          <target state="translated">서버 또는 클라이언트 채널 프로세스는 닫기 이벤트를 전송하여 세션을 닫도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80df1578413d7127e8d72a01fdf816a3b3d60cac" translate="yes" xml:space="preserve">
          <source>A server-side subssystem (channel) server is requested by the client with &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">서버 측 &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt; (채널) 서버는 클라이언트가 ssh_connection : subsystem / 4를 사용 하여 요청합니다 .</target>
        </trans-unit>
        <trans-unit id="6d3204ae6a9c144bcf2930bab159f079cdea0012" translate="yes" xml:space="preserve">
          <source>A service defines a locally-implemented Diameter node, specifying the capabilities to be advertised during capabilities exchange. Transports are added to a service using &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">서비스는 로컬로 구현 된 Diameter 노드를 정의하여 기능 교환 중에 보급 할 기능을 지정합니다. &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 전송이 서비스에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="b4b0724093ca8cf67b42fd8065ef62234f98ab2d" translate="yes" xml:space="preserve">
          <source>A service must configure one tuple for each Diameter application it intends to support. For an outgoing request, the relevant &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#application_alias&quot;&gt;application_alias()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; is passed to &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt;, while for an incoming request the application identifier in the message header determines the application, the identifier being specified in the application's &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary&lt;/a&gt;&lt;/code&gt; file.</source>
          <target state="translated">서비스는 지원하려는 각 Diameter 응용 프로그램마다 하나의 튜플을 구성해야합니다. 발신 요청의 경우 관련 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#application_alias&quot;&gt;application_alias()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 로 전달되는 반면 수신 요청의 경우 메시지 헤더의 애플리케이션 식별자가 애플리케이션을 결정하며 애플리케이션의 &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary&lt;/a&gt;&lt;/code&gt; 파일 에 지정된 식별자 입니다.</target>
        </trans-unit>
        <trans-unit id="aaffe8ed9bffeb5034f89141848d697c4f8ddf46" translate="yes" xml:space="preserve">
          <source>A service started as &lt;code&gt;stand_alone&lt;/code&gt;, that is, the service is not started as part of the &lt;code&gt;Inets&lt;/code&gt; application, lose all OTP application benefits, such as soft upgrade. The &lt;code&gt;stand_alone&lt;/code&gt;-service is linked to the process that started it. Usually some supervision functionality is still in place and in some sense the calling process becomes the top supervisor.</source>
          <target state="translated">&lt;code&gt;stand_alone&lt;/code&gt; 으로 시작된 서비스 , 즉 서비스가 &lt;code&gt;Inets&lt;/code&gt; 응용 프로그램의 일부로 시작되지 않으면 소프트 업그레이드와 같은 모든 OTP 응용 프로그램의 이점을 잃게됩니다. &lt;code&gt;stand_alone&lt;/code&gt; 의 - 서비스가 먼저 시작 프로세스에 연결되어 있습니다. 일반적으로 일부 감독 기능이 여전히 존재하며 어떤 의미에서는 통화 프로세스가 최고 감독자가됩니다.</target>
        </trans-unit>
        <trans-unit id="e8a6a012891bda48b015b0c9afa1553acf746ed9" translate="yes" xml:space="preserve">
          <source>A service that does not use shared peers will always pass the empty list as the second argument of &lt;code&gt;pick_peer/4&lt;/code&gt; callbacks.</source>
          <target state="translated">공유 피어를 사용하지 않는 서비스는 항상 빈 목록을 &lt;code&gt;pick_peer/4&lt;/code&gt; 콜백 의 두 번째 인수로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="10b22bcc7e1248f51cdd1cbb03116a8abb78e603" translate="yes" xml:space="preserve">
          <source>A service to read internally formatted wrap disk logs.</source>
          <target state="translated">내부적으로 포맷 된 랩 디스크 로그를 읽는 서비스입니다.</target>
        </trans-unit>
        <trans-unit id="948069c04efacc3c5dcde4803a65b30408e7f31d" translate="yes" xml:space="preserve">
          <source>A session opened in this way is closed using function &lt;code&gt;&lt;a href=&quot;#close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이런 방식으로 열린 세션은 함수 &lt;code&gt;&lt;a href=&quot;#close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 를 사용하여 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="f8dce1ed875eff8e76251a001abc25f652960e66" translate="yes" xml:space="preserve">
          <source>A set of calls between strongly connected components is a sorted list without duplicates of &lt;code&gt;ComponentCall&lt;/code&gt;.</source>
          <target state="translated">강력하게 연결된 컴포넌트 간 호출 세트는 &lt;code&gt;ComponentCall&lt;/code&gt; 과 중복되지 않은 정렬 된 목록 입니다.</target>
        </trans-unit>
        <trans-unit id="710107e57e111e349884878304dfebbb60768c1a" translate="yes" xml:space="preserve">
          <source>A set of calls is represented by a sorted list without duplicates of &lt;code&gt;call()&lt;/code&gt;.</source>
          <target state="translated">일련의 호출은 &lt;code&gt;call()&lt;/code&gt; 중복없이 정렬 된 목록으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a5ec339bfafa729e7589bcb584094f5693b62949" translate="yes" xml:space="preserve">
          <source>A set of constants is represented by a sorted list without duplicates of &lt;code&gt;constant()&lt;/code&gt;.</source>
          <target state="translated">상수 세트는 &lt;code&gt;constant()&lt;/code&gt; 중복없이 정렬 된 목록으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="b8184ec1b26baabe0df7138952aceaf16df4b13b" translate="yes" xml:space="preserve">
          <source>A set of functions is provided for sending and receiving contiguous parts of a file to be stored in a remote file. For send, see &lt;code&gt;send_chunk_start/2&lt;/code&gt;, &lt;code&gt;send_chunk/2&lt;/code&gt;, and &lt;code&gt;send_chunk_end/1&lt;/code&gt;. For receive, see &lt;code&gt;recv_chunk_start/2&lt;/code&gt; and &lt;code&gt;recv_chunk/&lt;/code&gt;).</source>
          <target state="translated">원격 파일에 저장할 파일의 연속적인 부분을 송수신하기위한 기능 세트가 제공됩니다. 보내기의 경우 &lt;code&gt;send_chunk_start/2&lt;/code&gt; , &lt;code&gt;send_chunk/2&lt;/code&gt; 및 &lt;code&gt;send_chunk_end/1&lt;/code&gt; 을 참조하십시오 . 수신에 대해서는 &lt;code&gt;recv_chunk_start/2&lt;/code&gt; 및 &lt;code&gt;recv_chunk/&lt;/code&gt; )를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="46692ec19a49b0489e3ac224ff31df52bd24aef0" translate="yes" xml:space="preserve">
          <source>A set of functions is provvided for sending and receiving contiguous parts of a file to be stored in a remote file. For send, see &lt;code&gt;send_chunk_start/2&lt;/code&gt;, &lt;code&gt;send_chunk/2&lt;/code&gt;, and &lt;code&gt;send_chunk_end/1&lt;/code&gt;. For receive, see &lt;code&gt;recv_chunk_start/2&lt;/code&gt; and &lt;code&gt;recv_chunk/&lt;/code&gt;).</source>
          <target state="translated">원격 파일에 저장 될 파일의 ​​연속 부분을 송수신하기위한 기능 세트가 제공됩니다. send에 대해서는 &lt;code&gt;send_chunk_start/2&lt;/code&gt; , &lt;code&gt;send_chunk/2&lt;/code&gt; 및 &lt;code&gt;send_chunk_end/1&lt;/code&gt; 을 참조하십시오 . 수신은 &lt;code&gt;recv_chunk_start/2&lt;/code&gt; 및 &lt;code&gt;recv_chunk/&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a9d7c3dd3508b04f4667584c78e7f619f9eb1de" translate="yes" xml:space="preserve">
          <source>A set of line numbered function calls is represented by a sorted list without duplicates of &lt;code&gt;CallAt&lt;/code&gt;.</source>
          <target state="translated">일련 번호가 지정된 함수 호출은 &lt;code&gt;CallAt&lt;/code&gt; 와 중복되지 않은 정렬 된 목록으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b7c151fe3e99d8bd5f4ffa52f47c3f04812cf74" translate="yes" xml:space="preserve">
          <source>A set of line numbered functions and function calls is represented by a sorted list without duplicates of &lt;code&gt;AllLines&lt;/code&gt;.</source>
          <target state="translated">라인 번호가 지정된 함수 및 함수 호출 세트는 &lt;code&gt;AllLines&lt;/code&gt; 와 중복되지 않고 정렬 된 목록으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="840dbd2f93a5198291444ddc8bbccef2c8f9c9ff" translate="yes" xml:space="preserve">
          <source>A set of line numbered functions is represented by a sorted list without duplicates of &lt;code&gt;DefineAt&lt;/code&gt;.</source>
          <target state="translated">행 번호가 매겨진 함수 세트는 &lt;code&gt;DefineAt&lt;/code&gt; 와 중복되지 않은 정렬 된 목록으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a5c61082d9404d5c0adf57236aa5f42fbc02337" translate="yes" xml:space="preserve">
          <source>A set of strongly connected components is a sorted list without duplicates of &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">강력하게 연결된 컴포넌트 세트는 &lt;code&gt;Component&lt;/code&gt; 와 중복되지 않은 정렬 된 목록 입니다.</target>
        </trans-unit>
        <trans-unit id="ac0087ee308abd483706f991654adce8870956a6" translate="yes" xml:space="preserve">
          <source>A set of tables is created. The function &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; creates the required database tables. The options available with &lt;code&gt;ArgList&lt;/code&gt; are explained in &lt;code&gt;&lt;a href=&quot;mnesia_chap3#create_tables&quot;&gt;Create New Tables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테이블 세트가 작성됩니다. &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; 함수 는 필요한 데이터베이스 테이블을 작성합니다. &lt;code&gt;ArgList&lt;/code&gt; 와 함께 사용할 수있는 옵션 은 &lt;code&gt;&lt;a href=&quot;mnesia_chap3#create_tables&quot;&gt;Create New Tables&lt;/a&gt;&lt;/code&gt; 에서 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="19f06211d11839665e84e1ea20d520a0f11afac6" translate="yes" xml:space="preserve">
          <source>A set of test cases sharing configuration functions and execution properties. The execution properties specify if the test cases in the group are to be executed in random order, in parallel, or in sequence, and if the execution of the group is be repeated. Test case groups can also be nested. That is, a group can, besides test cases, contain subgroups.</source>
          <target state="translated">구성 기능 및 실행 특성을 공유하는 테스트 케이스 세트입니다. 실행 속성은 그룹의 테스트 사례가 무작위 순서로, 병렬로 또는 순서대로 실행 될지 여부와 그룹의 실행이 반복되는지 여부를 지정합니다. 테스트 사례 그룹도 중첩 될 수 있습니다. 즉, 그룹은 테스트 사례 외에 하위 그룹을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12949a595f1f2f62a415607d8b62df7565321239" translate="yes" xml:space="preserve">
          <source>A short form for both &lt;code&gt;report_errors&lt;/code&gt; and &lt;code&gt;report_warnings&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;report_errors&lt;/code&gt; 및 &lt;code&gt;report_warnings&lt;/code&gt; 에 대한 짧은 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="63beb5981caaa740ca850381d113e7457110327c" translate="yes" xml:space="preserve">
          <source>A short form for both &lt;code&gt;return_errors&lt;/code&gt; and &lt;code&gt;return_warnings&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;return_errors&lt;/code&gt; 및 &lt;code&gt;return_warnings&lt;/code&gt; 에 대한 짧은 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="7ea5611de1365c235cc088e3d33261341dcca035" translate="yes" xml:space="preserve">
          <source>A signal can be delivered to the remote process/service using the following message. Some systems do not support signals, in which case they are to ignore this message. There is currently no function to generate this event as the signals referred to are on OS-level and not something generated by an Erlang program.</source>
          <target state="translated">다음 메시지를 사용하여 원격 프로세스 / 서비스에 신호를 전달할 수 있습니다. 일부 시스템은 신호를 지원하지 않으므로이 메시지를 무시해야합니다. 참조 된 신호가 Erlang 프로그램에 의해 생성 된 것이 아니라 OS 레벨에 있으므로이 이벤트를 생성하는 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="42eda09ed588353be26cc09cfa2d978f18b6e4d1" translate="yes" xml:space="preserve">
          <source>A signed 64-bit integer type for representation of time.</source>
          <target state="translated">시간 표현을위한 부호있는 64 비트 정수 유형.</target>
        </trans-unit>
        <trans-unit id="2ec4fc4bbc8342af35d07fe169518f0743782cba" translate="yes" xml:space="preserve">
          <source>A signed 64-bit integer type for time representation.</source>
          <target state="translated">시간 표현을위한 부호있는 64 비트 정수 유형.</target>
        </trans-unit>
        <trans-unit id="38a842896cfe88c4a3ddef8d3cf91788c49c732c" translate="yes" xml:space="preserve">
          <source>A signed integer type, the size of &lt;code&gt;ErlDrvSizeT&lt;/code&gt;.</source>
          <target state="translated">부호있는 정수 유형으로, &lt;code&gt;ErlDrvSizeT&lt;/code&gt; 크기입니다 .</target>
        </trans-unit>
        <trans-unit id="1024fdaa70807f16fbbe54892e86672633b5e291" translate="yes" xml:space="preserve">
          <source>A significant number of middleboxes misbehave when a TLS 1.3 connection is negotiated. Implementations can increase the chance of making connections through those middleboxes by making the TLS 1.3 handshake more like a TLS 1.2 handshake.</source>
          <target state="translated">TLS 1.3 연결이 협상 될 때 상당수의 미들 박스가 오작동합니다. 구현은 TLS 1.3 핸드 셰이크를 TLS 1.2 핸드 셰이크와 비슷하게 만들어 해당 미들 박스를 통해 연결할 가능성을 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a0fe9a2b6f1d0a57855755f4b057af6a3783f46" translate="yes" xml:space="preserve">
          <source>A similar syntax as for module attributes is used for specifying types and function specifications:</source>
          <target state="translated">모듈 속성과 유사한 구문이 유형 및 기능 사양을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8a8c55df8388e2c8abf4b42d441b92ec7fc5ed46" translate="yes" xml:space="preserve">
          <source>A simple Call Count Profiling Tool using breakpoints for minimal runtime performance impact.</source>
          <target state="translated">런타임 성능에 미치는 영향을 최소화하기 위해 중단 점을 사용하는 간단한 통화 수 프로파일 링 도구입니다.</target>
        </trans-unit>
        <trans-unit id="c5cb837e5d2ca7e262291078f0d5802db7966be5" translate="yes" xml:space="preserve">
          <source>A simple Erlang SCTP client that uses the &lt;code&gt;connect_init&lt;/code&gt; API:</source>
          <target state="translated">&lt;code&gt;connect_init&lt;/code&gt; API 를 사용하는 간단한 Erlang SCTP 클라이언트 :</target>
        </trans-unit>
        <trans-unit id="d0c9a192d81f4fa039cbd886ce4bd4a73ce2b099" translate="yes" xml:space="preserve">
          <source>A simple configuration handling driver, asking an external server for configuration data, can be implemented as follows:</source>
          <target state="translated">외부 서버에 구성 데이터를 요청하는 간단한 구성 처리 드라이버는 다음과 같이 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94159518c423ba9ecd622c20fd73db453e69d787" translate="yes" xml:space="preserve">
          <source>A simple distributed agent can be managed without sub-agents. The instrumentation functions can use distributed Erlang to communicate with other parts of the application. However, a sub-agent can be used on each node if this generates too much unnecessary traffic. A sub-agent processes requests per incoming SNMP request, not per variable. Therefore the network traffic is minimized.</source>
          <target state="translated">하위 에이전트없이 간단한 분산 에이전트를 관리 할 수 ​​있습니다. 인스 트루먼 테이션 기능은 분산 Erlang을 사용하여 응용 프로그램의 다른 부분과 통신 할 수 있습니다. 그러나 불필요한 트래픽을 너무 많이 생성하면 각 노드에서 하위 에이전트를 사용할 수 있습니다. 하위 에이전트는 변수가 아닌 들어오는 SNMP 요청마다 요청을 처리합니다. 따라서 네트워크 트래픽이 최소화됩니다.</target>
        </trans-unit>
        <trans-unit id="37a291b9ccd26ae2e858205df24cc14753b44a96" translate="yes" xml:space="preserve">
          <source>A simple example of how to use the manager component of the SNMP Development Toolkit.</source>
          <target state="translated">SNMP Development Toolkit의 관리자 구성 요소를 사용하는 방법에 대한 간단한 예.</target>
        </trans-unit>
        <trans-unit id="e0d43223e0be204bdc5f431e2cd09f2620cd3cba" translate="yes" xml:space="preserve">
          <source>A simple example of how to write agent test cases, using the new manager.</source>
          <target state="translated">새 관리자를 사용하여 에이전트 테스트 사례를 작성하는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="a47de2d4ec5f53818458005215063c067e9f2a3e" translate="yes" xml:space="preserve">
          <source>A simple example. A single quad core processor can be described as follows:</source>
          <target state="translated">간단한 예입니다. 단일 쿼드 코어 프로세서는 다음과 같이 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd61143e005b303fe8d62ae782f18058638458a2" translate="yes" xml:space="preserve">
          <source>A simple handler that prints to the terminal can be implemented as follows:</source>
          <target state="translated">터미널에 인쇄하는 간단한 핸들러는 다음과 같이 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d231f36ed1b4dce67cc3b50e0ae15aa4df7e9395" translate="yes" xml:space="preserve">
          <source>A simple interactive configuration tool. Simple configuration files can be generated, but more complex configurations still have to be edited manually.</source>
          <target state="translated">간단한 대화식 구성 도구입니다. 간단한 구성 파일을 생성 할 수는 있지만 더 복잡한 구성은 여전히 ​​수동으로 편집해야합니다.</target>
        </trans-unit>
        <trans-unit id="9bb0a791b7816e17ce1b48c1aee66bf6abe2e694" translate="yes" xml:space="preserve">
          <source>A simple solution would be to use the &lt;code&gt;name&lt;/code&gt; field as the key instead of the &lt;code&gt;idno&lt;/code&gt; field, but that would cause problems if the names were not unique. A more general solution would be to create a second table with &lt;code&gt;name&lt;/code&gt; as key and &lt;code&gt;idno&lt;/code&gt; as data, that is, to index (invert) the table regarding the &lt;code&gt;name&lt;/code&gt; field. Clearly, the second table would have to be kept consistent with the master table. Mnesia can do this for you, but a home brew index table can be very efficient compared to the overhead involved in using Mnesia.</source>
          <target state="translated">간단한 해결책은 &lt;code&gt;name&lt;/code&gt; 필드를 &lt;code&gt;idno&lt;/code&gt; 필드 대신 키로 사용 하는 것이지만 이름이 고유하지 않으면 문제가 발생할 수 있습니다. 보다 일반적인 해결책은 &lt;code&gt;name&lt;/code&gt; 을 key로, &lt;code&gt;idno&lt;/code&gt; 를 데이터 로 사용하여 두 번째 테이블을 작성하는 것 입니다. 즉, &lt;code&gt;name&lt;/code&gt; 필드 와 관련된 테이블을 색인화 (반전)하는 것 입니다. 분명히 두 번째 테이블은 마스터 테이블과 일관성을 유지해야합니다. Mnesia가이 작업을 수행 할 수 있지만 Mbrewia 사용과 관련된 오버 헤드에 비해 가정용 추출 인덱스 테이블이 매우 효율적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a677c35bea852cdbf8756b158d2b8bcbf8d2e71c" translate="yes" xml:space="preserve">
          <source>A simple way to do this is to issue the following commands:</source>
          <target state="translated">이를 수행하는 간단한 방법은 다음 명령을 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="464b91e40e2a3cb96819c357b1617d8db059e71c" translate="yes" xml:space="preserve">
          <source>A simple way to do this is to issue these commands:</source>
          <target state="translated">이를 수행하는 간단한 방법은 다음 명령을 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eea77823d49a9512680d9b481e0a65ed1b7a8abb" translate="yes" xml:space="preserve">
          <source>A single &lt;code&gt;~&lt;/code&gt; is expected in the input.</source>
          <target state="translated">입력에서 단일 &lt;code&gt;~&lt;/code&gt; 가 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="8d3145e708c1deab465a16f4608e04895d3f01b3" translate="yes" xml:space="preserve">
          <source>A single atom represents a module name, and is equivalent to &lt;code&gt;{module, ModuleName}&lt;/code&gt;. This is often used as in the call &lt;code&gt;eunit:test(some_module)&lt;/code&gt;.</source>
          <target state="translated">단일 아톰은 모듈 이름을 나타내며 &lt;code&gt;{module, ModuleName}&lt;/code&gt; . 이것은 종종 &lt;code&gt;eunit:test(some_module)&lt;/code&gt; 호출에서와 같이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="437abe5f66fc807f023b84e5b53bea27300039ac" translate="yes" xml:space="preserve">
          <source>A single binary can be sent with &lt;code&gt;driver_output_binary()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;driver_output_binary()&lt;/code&gt; 로 단일 바이너리를 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d82ab9afcf3b874d81d1b01e2b29a3023c6ead3c" translate="yes" xml:space="preserve">
          <source>A single line (as in former example) is requested with the following &lt;code&gt;Request&lt;/code&gt;:</source>
          <target state="translated">이전 요청에서와 같이 한 줄은 다음 &lt;code&gt;Request&lt;/code&gt; 과 함께 요청됩니다 .</target>
        </trans-unit>
        <trans-unit id="91eb11dd51a7d947aa277af7b00518dd07ecd8dd" translate="yes" xml:space="preserve">
          <source>A single string represents the path of a file or directory, and is equivalent to &lt;code&gt;{file, Path}&lt;/code&gt;, or &lt;code&gt;{dir, Path}&lt;/code&gt;, respectively, depending on what &lt;code&gt;Path&lt;/code&gt; refers to in the file system.</source>
          <target state="translated">단일 문자열은 파일 또는 디렉토리의 &lt;code&gt;Path&lt;/code&gt; 나타내며 파일 시스템에서 Path가 참조하는 내용에 따라 각각 &lt;code&gt;{file, Path}&lt;/code&gt; 또는 &lt;code&gt;{dir, Path}&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f128070bab19006a2ef91c51aaca808921167bc6" translate="yes" xml:space="preserve">
          <source>A single test included in a test suite. A test case is implemented as a function in a test suite module.</source>
          <target state="translated">테스트 스위트에 포함 된 단일 테스트. 테스트 케이스는 테스트 스위트 모듈에서 함수로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="c6134a35a4b3aed44a3d6f996738074a3183b087" translate="yes" xml:space="preserve">
          <source>A single, well-defined test, that somehow can be uniquely identified. When executed, the test case either &lt;strong&gt;passes&lt;/strong&gt; or &lt;strong&gt;fails&lt;/strong&gt;; the test report should identify exactly which test cases failed.</source>
          <target state="translated">어떻게 든 고유하게 식별 할 수있는 잘 정의 된 단일 테스트입니다. 테스트 케이스가 실행되면 &lt;strong&gt;통과&lt;/strong&gt; 하거나 &lt;strong&gt;실패합니다&lt;/strong&gt; . 테스트 보고서는 실패한 테스트 사례를 정확히 식별해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff7e932fb59b9670681676d154f390a5b9707270" translate="yes" xml:space="preserve">
          <source>A situation where it might be useful to add an algorithm is when one need to use a supported but disabled one. An example is the &lt;code&gt;'diffie-hellman-group1-sha1'&lt;/code&gt; which nowadays is very unsecure and therefore disabled. It is however still supported and might be used.</source>
          <target state="translated">알고리즘을 추가하는 것이 유용한 상황은 지원되지만 비활성화 된 알고리즘을 사용해야하는 경우입니다. 예를 들어 &lt;code&gt;'diffie-hellman-group1-sha1'&lt;/code&gt; 은 오늘날 매우 안전하지 않으므로 비활성화되어 있습니다. 그러나 여전히 지원되며 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8a737055966988fa33536560d8ee3886f563bb5" translate="yes" xml:space="preserve">
          <source>A skeleton is a piece of pre-written code that can be inserted into the buffer. Erlang mode comes with a set of predefined skeletons. The skeletons can be accessed either from the Erlang menu of from commands named &lt;code&gt;tempo-template-erlang-*&lt;/code&gt;, as the skeletons is defined using the standard Emacs package &quot;tempo&quot;. Here follows a brief description of the available skeletons:</source>
          <target state="translated">스켈레톤은 버퍼에 삽입 할 수있는 미리 작성된 코드입니다. 얼랭 모드는 사전 정의 된 스켈레톤 세트와 함께 제공됩니다. 스켈레톤은 표준 Emacs 패키지 &quot;tempo&quot;를 사용하여 정의 &lt;code&gt;tempo-template-erlang-*&lt;/code&gt; 라는 명령의 Erlang 메뉴에서 스켈레톤에 액세스 할 수 있습니다 . 다음은 사용 가능한 스켈레톤에 대한 간략한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="3fbeb5f6d202d2f6a94d6926e8772e60f8395d0b" translate="yes" xml:space="preserve">
          <source>A sketch of the procedure employed:</source>
          <target state="translated">사용 된 절차의 스케치 :</target>
        </trans-unit>
        <trans-unit id="347ad9db1092bfae38de28e8384c541f8eda0f16" translate="yes" xml:space="preserve">
          <source>A slogan indicating the reason for the dump</source>
          <target state="translated">덤프 이유를 나타내는 슬로건</target>
        </trans-unit>
        <trans-unit id="c82db0ac725e371be4e92cf842d525309be1a960" translate="yes" xml:space="preserve">
          <source>A small &lt;code&gt;ssh&lt;/code&gt; subsystem that echoes N bytes can be implemented as shown in the following example:</source>
          <target state="translated">N 바이트를 에코 하는 작은 &lt;code&gt;ssh&lt;/code&gt; 서브 시스템은 다음 예제와 같이 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee793e88b05c2c54637d37d2dc3b6df251a95612" translate="yes" xml:space="preserve">
          <source>A small note about each failed test case.</source>
          <target state="translated">실패한 각 테스트 사례에 대한 작은 메모.</target>
        </trans-unit>
        <trans-unit id="89269626521455c0533dcc1024e681dcdd2fe91d" translate="yes" xml:space="preserve">
          <source>A small number of &quot;-&quot; flags exist, which now actually are emulator flags, see the description below.</source>
          <target state="translated">실제로는 에뮬레이터 플래그 인 소수의 &quot;-&quot;플래그가 존재합니다 (아래 설명 참조).</target>
        </trans-unit>
        <trans-unit id="b8571dea892b8010a396168429a316241eeb9263" translate="yes" xml:space="preserve">
          <source>A soft limit on the number of characters returned. When the number of characters is reached, remaining structures are replaced by &quot;&lt;code&gt;...&lt;/code&gt;&quot;. &lt;code&gt;CharsLimit&lt;/code&gt; defaults to -1, which means no limit on the number of characters returned.</source>
          <target state="translated">반환되는 문자 수에 대한 소프트 제한입니다. 문자 수에 도달하면 나머지 구조는 &quot; &lt;code&gt;...&lt;/code&gt; &quot; 로 바뀝니다 . &lt;code&gt;CharsLimit&lt;/code&gt; 의 기본값은 -1이며 반환되는 문자 수에 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c5403e8588747737164215b85effd60defff4f50" translate="yes" xml:space="preserve">
          <source>A sorted list of &lt;code&gt;{Node, Count}&lt;/code&gt; tuples that are sorted in increasing &lt;code&gt;Count&lt;/code&gt; order. &lt;code&gt;Count&lt;/code&gt; is the total number of replicas that this fragmented table hosts on each &lt;code&gt;Node&lt;/code&gt;. The list always contains at least all nodes in &lt;code&gt;node_pool&lt;/code&gt;. Nodes that do not belong to &lt;code&gt;node_pool&lt;/code&gt; are put last in the list even if their &lt;code&gt;Count&lt;/code&gt; is lower.</source>
          <target state="translated">A는 목록 분류 &lt;code&gt;{Node, Count}&lt;/code&gt; 증가에 분류되어 튜플 &lt;code&gt;Count&lt;/code&gt; 순서를. &lt;code&gt;Count&lt;/code&gt; 는이 조각난 테이블이 각 &lt;code&gt;Node&lt;/code&gt; 호스트하는 총 복제본 수입니다 . 목록에는 항상 &lt;code&gt;node_pool&lt;/code&gt; 의 모든 노드가 포함 됩니다 . &lt;code&gt;node_pool&lt;/code&gt; 에 속하지 않은 노드는 &lt;code&gt;Count&lt;/code&gt; 가 더 낮 더라도 목록의 마지막에 놓 입니다.</target>
        </trans-unit>
        <trans-unit id="920a6a7e45bffb0b7a8b87d5da85daae27b47541" translate="yes" xml:space="preserve">
          <source>A space-separated string specifying the program to be executed. The second field is typically a command name such as &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">실행할 프로그램을 지정하는 공백으로 구분 된 문자열입니다. 두 번째 필드는 일반적으로 &lt;code&gt;erl&lt;/code&gt; 과 같은 명령 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="1636d9fe46ac8e8fc16a7c4f98f7781df515d1ba" translate="yes" xml:space="preserve">
          <source>A spawn reply message will be sent to the caller regardless of whether the operation succeeds or not. If the call to &lt;code&gt;spawn_request()&lt;/code&gt; returns without raising an exception and the &lt;code&gt;reply&lt;/code&gt; option is set to &lt;code&gt;yes&lt;/code&gt;, the caller is guaranteed to be delivered either a &lt;code&gt;&lt;a href=&quot;#spawn_request_success_message&quot;&gt;&lt;i&gt;success message&lt;/i&gt;&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;#spawn_request_error_message&quot;&gt;&lt;i&gt;error message&lt;/i&gt;&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;reply&lt;/code&gt; option is by default set to &lt;code&gt;yes&lt;/code&gt;.</source>
          <target state="translated">작업의 성공 여부에 관계없이 호출 응답 메시지가 호출자에게 전송됩니다. &lt;code&gt;spawn_request()&lt;/code&gt; 호출이 예외를 발생시키지 않고 반환되고 &lt;code&gt;reply&lt;/code&gt; 옵션이 &lt;code&gt;yes&lt;/code&gt; 로 설정되어 있으면 호출자에게 &lt;code&gt;&lt;a href=&quot;#spawn_request_success_message&quot;&gt;&lt;i&gt;success message&lt;/i&gt;&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#spawn_request_error_message&quot;&gt;&lt;i&gt;error message&lt;/i&gt;&lt;/a&gt;&lt;/code&gt; 됩니다. &lt;code&gt;reply&lt;/code&gt; 옵션은 기본적 세트입니다 &lt;code&gt;yes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d70a605fe0829e66ec6bd35120d29d1093a9d34" translate="yes" xml:space="preserve">
          <source>A spawn request can be abandoned by calling &lt;code&gt;&lt;a href=&quot;#spawn_request_abandon-1&quot;&gt;spawn_request_abandon/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#spawn_request_abandon-1&quot;&gt;spawn_request_abandon/1&lt;/a&gt;&lt;/code&gt; 을 호출하여 생성 요청을 취소 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8db8ca18baf39ee044af1edfffece3234114b4cf" translate="yes" xml:space="preserve">
          <source>A spawn request can only be successfully abandoned until the spawn request has completed. When a spawn request has been successfully abandoned, the caller will not be effected by future direct effects of the spawn request itself. For example, it will not receive a spawn reply message. The request is however not withdrawn, so a new process may or may not be created due to the request. If a new process is created after the spawn request was abandoned, no monitors nor links will be set up to the caller of &lt;code&gt;spawn_request_abandon/1&lt;/code&gt; due to the spawn request. If the spawn request included the &lt;code&gt;link&lt;/code&gt; option, the process created due to this request will be sent an exit signal from its parent with the exit reason &lt;code&gt;abandoned&lt;/code&gt; when it is detected that the spawn operation has succeeded.</source>
          <target state="translated">스폰 요청은 스폰 요청이 완료 될 때까지만 성공적으로 취소 할 수 있습니다. 스폰 요청이 성공적으로 취소되면 호출자는 스폰 요청 자체의 향후 직접적인 영향에 영향을받지 않습니다. 예를 들어, 스폰 응답 메시지를 수신하지 않습니다. 그러나 요청은 철회되지 않으므로 요청으로 인해 새 프로세스가 생성되거나 생성되지 않을 수 있습니다. spawn 요청이 중단 된 후 새 프로세스가 생성되면 spawn 요청으로 인해 &lt;code&gt;spawn_request_abandon/1&lt;/code&gt; 호출자에 대한 모니터 나 링크가 설정되지 않습니다 . spawn 요청에 &lt;code&gt;link&lt;/code&gt; 옵션이 포함 된 경우이 요청으로 인해 생성 된 프로세스는 종료 이유가 &lt;code&gt;abandoned&lt;/code&gt; 부모로부터 종료 신호를 보냅니다. 스폰 작업이 성공한 것으로 감지 될 때.</target>
        </trans-unit>
        <trans-unit id="5bbb00e915060a377363fa9765e2fd6a815cb4ee" translate="yes" xml:space="preserve">
          <source>A special item that consists of (? followed by a number &amp;gt; 0 and a closing parenthesis is a recursive subroutine call of the subpattern of the given number, if it occurs inside that subpattern. (If not, it is a non-recursive subroutine call, which is described in the next section.) The special item (?R) or (?0) is a recursive call of the entire regular expression.</source>
          <target state="translated">(? 뒤에 숫자&amp;gt; 0 및 닫는 괄호로 구성되는 특수 항목은 해당 서브 패턴 내부에서 발생하는 경우 주어진 번호의 서브 패턴에 대한 재귀 서브 루틴 호출입니다 (그렇지 않은 경우 비 재귀 서브 루틴 호출입니다). 특수 항목 (? R) 또는 (? 0)은 전체 정규식을 재귀 적으로 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="61cc845c2afb7bd85647ca3d1e06f065258da29c" translate="yes" xml:space="preserve">
          <source>A special routine invoked with &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt;. It works a little like an &quot;ioctl&quot; for Erlang drivers. The data specified to &lt;code&gt;port_control/3&lt;/code&gt; arrives in &lt;code&gt;buf&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt;. The driver can send data back, using &lt;code&gt;*rbuf&lt;/code&gt; and &lt;code&gt;rlen&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 로 호출되는 특수 루틴 . Erlang 드라이버의 경우 &quot;ioctl&quot;처럼 작동합니다. &lt;code&gt;port_control/3&lt;/code&gt; 에 지정된 데이터 는 &lt;code&gt;buf&lt;/code&gt; 및 &lt;code&gt;len&lt;/code&gt; 에 도착합니다 . 드라이버는 &lt;code&gt;*rbuf&lt;/code&gt; 및 &lt;code&gt;rlen&lt;/code&gt; 을 사용하여 데이터를 다시 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5d7d4630bf6e699f86315587f52b147af8c7634" translate="yes" xml:space="preserve">
          <source>A special routine invoked with &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt;. It works a little like an &quot;ioctl&quot; for Erlang drivers. The data specified to &lt;code&gt;port_control/3&lt;/code&gt; arrives in &lt;code&gt;buf&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt;. The driver can send data back, using &lt;code&gt;*rbuf&lt;/code&gt; and &lt;code&gt;rlen&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 으로 호출 된 특수 루틴 . Erlang 드라이버의 &quot;ioctl&quot;과 약간 비슷합니다. &lt;code&gt;port_control/3&lt;/code&gt; 에 지정된 데이터 는 &lt;code&gt;buf&lt;/code&gt; 및 &lt;code&gt;len&lt;/code&gt; 에 도착합니다 . 드라이버는 &lt;code&gt;*rbuf&lt;/code&gt; 및 &lt;code&gt;rlen&lt;/code&gt; 을 사용하여 데이터를 다시 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="818bed6690afd85a8e837d5ce544a94b65462268" translate="yes" xml:space="preserve">
          <source>A special type of error is when no actual invalid integers or bytes are found, but a trailing &lt;code&gt;binary()&lt;/code&gt; consists of too few bytes to decode the last character. This error can occur if bytes are read from a file in chunks or if binaries in other ways are split on non-UTF character boundaries. An &lt;code&gt;incomplete&lt;/code&gt; tuple is then returned instead of the &lt;code&gt;error&lt;/code&gt; tuple. It consists of the same parts as the &lt;code&gt;error&lt;/code&gt; tuple, but the tag is &lt;code&gt;incomplete&lt;/code&gt; instead of &lt;code&gt;error&lt;/code&gt; and the last element is always guaranteed to be a binary consisting of the first part of a (so far) valid UTF character.</source>
          <target state="translated">특수한 유형의 오류는 실제로 유효하지 않은 정수 나 바이트를 찾을 수 없지만 후행 &lt;code&gt;binary()&lt;/code&gt; 가 너무 적은 바이트로 구성되어 마지막 문자를 디코딩 할 수 없습니다. 이 오류는 파일에서 청크 단위로 바이트를 읽거나 다른 방법으로 바이너리가 비 UTF 문자 경계에서 분할 된 경우 발생할 수 있습니다. &lt;code&gt;incomplete&lt;/code&gt; 튜플은 다음 대신의 반환되는 &lt;code&gt;error&lt;/code&gt; 튜플. &lt;code&gt;error&lt;/code&gt; 튜플 과 동일한 부분으로 구성 되지만 &lt;code&gt;error&lt;/code&gt; 대신 태그가 &lt;code&gt;incomplete&lt;/code&gt; 하며 마지막 요소는 항상 유효한 UTF 문자의 첫 부분으로 구성된 이진이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3916fb4d3122880bb80b867dc9d2527f278db29f" translate="yes" xml:space="preserve">
          <source>A specific instruction can have at most 6 operands.</source>
          <target state="translated">특정 명령어에는 최대 6 개의 피연산자가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5eb0a5535ecc63bd01763b04dca57f5130132dad" translate="yes" xml:space="preserve">
          <source>A specific instruction is defined by first giving its name followed by the types for each operand. For example:</source>
          <target state="translated">특정 명령어는 먼저 해당 이름과 각 피연산자의 유형을 제공하여 정의됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="eebe590a8a4fd637cbd36f90802e9523ed6a4512" translate="yes" xml:space="preserve">
          <source>A specification (or contract) for a function is given using the &lt;code&gt;-spec&lt;/code&gt; attribute. The general format is as follows:</source>
          <target state="translated">함수의 스펙 (또는 계약)은 &lt;code&gt;-spec&lt;/code&gt; 속성을 사용하여 제공됩니다 . 일반적인 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7dc4ccb3d8ddcce0db9cf1c2ea5d5fda23fcb4be" translate="yes" xml:space="preserve">
          <source>A state change cancels a &lt;code&gt;&lt;a href=&quot;#type-state_timeout&quot;&gt;state_timeout()&lt;/a&gt;&lt;/code&gt; and any new transition option of this type belongs to the new state.</source>
          <target state="translated">상태 변경은 &lt;code&gt;&lt;a href=&quot;#type-state_timeout&quot;&gt;state_timeout()&lt;/a&gt;&lt;/code&gt; 취소 하고이 유형의 새로운 전환 옵션은 새로운 상태에 속합니다.</target>
        </trans-unit>
        <trans-unit id="c48da406465f6ed9b4beb63690dac21a0092fc89" translate="yes" xml:space="preserve">
          <source>A stateful session ticket is a database reference to internal state information. A stateless session ticket is a self-encrypted binary that contains both cryptographic keying material and state data.</source>
          <target state="translated">상태 저장 세션 티켓은 내부 상태 정보에 대한 데이터베이스 참조입니다. 상태 비 저장 세션 티켓은 암호화 키 자료와 상태 데이터를 모두 포함하는 자체 암호화 된 바이너리입니다.</target>
        </trans-unit>
        <trans-unit id="1ce1fae1923f3d7397b496fc579d7f7f29266cd7" translate="yes" xml:space="preserve">
          <source>A status, which is &lt;strong&gt;active&lt;/strong&gt; or &lt;strong&gt;inactive&lt;/strong&gt;. An inactive breakpoint is ignored.</source>
          <target state="translated">인 상태, &lt;strong&gt;활성&lt;/strong&gt; 또는 &lt;strong&gt;비활성&lt;/strong&gt; . 비활성 중단 점은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="cb3254f6f71d42ad5babf60af6c4beadc5fe794a" translate="yes" xml:space="preserve">
          <source>A sticky lock is a lock that stays in place at a node, after the transaction that first acquired the lock has terminated. To illustrate this, assume that the following transaction is executed:</source>
          <target state="translated">고정 잠금은 잠금을 처음 획득 한 트랜잭션이 종료 된 후 노드에서 유지되는 잠금입니다. 이를 설명하기 위해 다음 트랜잭션이 실행되었다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="167c0844b749b5b3dade41e2fb760895a3da7567" translate="yes" xml:space="preserve">
          <source>A string containing the OTP release number (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_otp_release&quot;&gt; erlang:system_info(otp_release)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">OTP 릴리스 번호를 포함하는 문자열 ( &lt;code&gt;&lt;a href=&quot;erlang#system_info_otp_release&quot;&gt; erlang:system_info(otp_release)&lt;/a&gt;&lt;/code&gt; 반환 된 것과 동일 ).</target>
        </trans-unit>
        <trans-unit id="0d036eed01d979d152da2689054b2a8a3616ab3b" translate="yes" xml:space="preserve">
          <source>A string containing the OTP release number (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_otp_release&quot;&gt;erlang:system_info(otp_release)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">OTP 릴리스 번호가 포함 된 문자열입니다 ( &lt;code&gt;&lt;a href=&quot;erlang#system_info_otp_release&quot;&gt;erlang:system_info(otp_release)&lt;/a&gt;&lt;/code&gt; 리턴 한 것과 동일 ).</target>
        </trans-unit>
        <trans-unit id="7a887f90504538f7764832dfb1ec18f08b3d4d4e" translate="yes" xml:space="preserve">
          <source>A string containing the regular expression</source>
          <target state="translated">정규식을 포함하는 문자열</target>
        </trans-unit>
        <trans-unit id="6a30a94b91175e13eab64a9eaaf574ffd247249b" translate="yes" xml:space="preserve">
          <source>A string containing the version number of the runtime system (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_version&quot;&gt; erlang:system_info(version)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">런타임 시스템의 버전 ​​번호를 포함하는 문자열 ( &lt;code&gt;&lt;a href=&quot;erlang#system_info_version&quot;&gt; erlang:system_info(version)&lt;/a&gt;&lt;/code&gt; 반환 된 것과 동일 ).</target>
        </trans-unit>
        <trans-unit id="e0f49966a17385c888cdd7ff3581d6cc3b4a55ee" translate="yes" xml:space="preserve">
          <source>A string containing the version number of the runtime system (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_version&quot;&gt;erlang:system_info(version)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">런타임 시스템의 버전 ​​번호를 포함하는 문자열입니다 ( &lt;code&gt;&lt;a href=&quot;erlang#system_info_version&quot;&gt;erlang:system_info(version)&lt;/a&gt;&lt;/code&gt; 리턴 한 것과 동일 ).</target>
        </trans-unit>
        <trans-unit id="a067c189aea167f729e4e4094e5cef684c3ebe5a" translate="yes" xml:space="preserve">
          <source>A string containing valid characters on the specific OS for environment variable names using &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; encoding. Note that specifically null characters (integer value zero) and &lt;code&gt;$=&lt;/code&gt; characters are not allowed. However, note that not all invalid characters necessarily will cause the primitiv operations to fail, but may instead produce invalid results.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; 인코딩을 사용하는 환경 변수 이름에 대해 특정 OS에서 유효한 문자를 포함하는 문자열 입니다. 특히 null 문자 (정수 값 0) 및 &lt;code&gt;$=&lt;/code&gt; 문자는 허용되지 않습니다. 그러나 모든 유효하지 않은 문자가 반드시 primitiv 조작을 실패하게하는 것은 아니지만 대신 유효하지 않은 결과를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70f78f37d5d4757bbdf76a8e2359db2143d09529" translate="yes" xml:space="preserve">
          <source>A string containing valid characters on the specific OS for environment variable values using &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; encoding. Note that specifically null characters (integer value zero) are not allowed. However, note that not all invalid characters necessarily will cause the primitiv operations to fail, but may instead produce invalid results.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; 인코딩을 사용하는 환경 변수 값에 대해 특정 OS에서 유효한 문자를 포함하는 문자열 입니다. 특히 널 문자 (정수 값 0)는 허용되지 않습니다. 그러나 모든 유효하지 않은 문자가 반드시 primitiv 조작을 실패하게하는 것은 아니지만 대신 유효하지 않은 결과를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9de478315c2065a78cf4db328a67478bae83694c" translate="yes" xml:space="preserve">
          <source>A string describing the error is obtained with the following call:</source>
          <target state="translated">오류를 설명하는 문자열은 다음 호출로 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ee46978e6166eeae1dd2570aa404c6015d82f71d" translate="yes" xml:space="preserve">
          <source>A string identifying the created thread. It is used to identify the thread in planned future debug functionality.</source>
          <target state="translated">작성된 스레드를 식별하는 문자열입니다. 계획된 향후 디버그 기능에서 스레드를 식별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="759a963eafd4f199bcd9d735f8b965dcd00ef19c" translate="yes" xml:space="preserve">
          <source>A string in this module is represented by &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt; unicode:chardata()&lt;/a&gt;&lt;/code&gt;, that is, a list of codepoints, binaries with UTF-8-encoded codepoints (&lt;strong&gt;UTF-8 binaries&lt;/strong&gt;), or a mix of the two.</source>
          <target state="translated">이 모듈의 문자열은 &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt; unicode:chardata()&lt;/a&gt;&lt;/code&gt; , 즉 코드 포인트 목록, UTF-8로 인코딩 된 코드 포인트가있는 &lt;strong&gt;바이너리&lt;/strong&gt; ( &lt;strong&gt;UTF-8 바이너리&lt;/strong&gt; ) 또는 둘의 혼합으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a6d553d44ab1b8299b71777d9750b77ba466363e" translate="yes" xml:space="preserve">
          <source>A string in this module is represented by &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt;, that is, a list of codepoints, binaries with UTF-8-encoded codepoints (&lt;strong&gt;UTF-8 binaries&lt;/strong&gt;), or a mix of the two.</source>
          <target state="translated">이 모듈의 문자열은 &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; 즉, 코드 포인트 목록, UTF-8 인코딩 코드 포인트가있는 &lt;strong&gt;바이너리&lt;/strong&gt; ( &lt;strong&gt;UTF-8 바이너리&lt;/strong&gt; ) 또는이 둘의 혼합으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d11f0427336c725f5ed476d29c20afbd08fe897b" translate="yes" xml:space="preserve">
          <source>A string of non-whitespace characters is read. If a field width has been specified, this number of characters are read and all trailing whitespace characters are stripped. An Erlang string (list of characters) is returned.</source>
          <target state="translated">공백이 아닌 문자열을 읽습니다. 필드 너비가 지정된 경우이 문자 수를 읽고 모든 후행 공백 문자가 제거됩니다. Erlang 문자열 (문자 목록)이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="64783b9aab5a7910a29cafe20f9a64dc124f28e3" translate="yes" xml:space="preserve">
          <source>A string representing atom &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">원자 나타내는 문자열 &lt;code&gt;t&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="3d7e23be6d1d7577f504730a2152e66a4301352e" translate="yes" xml:space="preserve">
          <source>A string that describes the error is obtained with the following call:</source>
          <target state="translated">오류를 설명하는 문자열은 다음 호출로 확보됩니다.</target>
        </trans-unit>
        <trans-unit id="6b058a7796b9b771b09e5ec69321b91ea4d6b069" translate="yes" xml:space="preserve">
          <source>A string version of &lt;code&gt;&lt;a href=&quot;#q-1&quot;&gt;q/1,2&lt;/a&gt;&lt;/code&gt;. When the query handle is evaluated, the fun created by the parse transform is interpreted by &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt;. The query string is to be one single QLC terminated by a period.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#q-1&quot;&gt;q/1,2&lt;/a&gt;&lt;/code&gt; 의 문자열 버전입니다 . 쿼리 핸들이 평가 될 때 구문 분석 변환으로 작성된 재미는 &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt; 의해 해석됩니다 . 쿼리 문자열은 마침표로 끝나는 하나의 단일 QLC입니다.</target>
        </trans-unit>
        <trans-unit id="e691523a7275fa4ec7b2002f9ce045f810aebbb7" translate="yes" xml:space="preserve">
          <source>A string with no adjacent dots.</source>
          <target state="translated">인접한 점이없는 문자열</target>
        </trans-unit>
        <trans-unit id="7b45ae634d5f2aacf52f18c9890284a21d2682fc" translate="yes" xml:space="preserve">
          <source>A stub module descriptor contains the module name, a list of exported functions, and a list of module attributes. Each function is described by its name (which includes its arity), and the corresponding module and function that it calls. (The arities should always match.) The attributes are simply described by key-value pairs.</source>
          <target state="translated">스텁 모듈 설명자는 모듈 이름, 내 보낸 함수 목록 및 모듈 속성 목록을 포함합니다. 각 함수는 이름 (arity 포함)과 해당 모듈과 함수가 호출합니다. 속성은 항상 일치해야합니다. 속성은 단순히 키-값 쌍으로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="8dff76e790c867438fab881dad7f0b72bb5ec367" translate="yes" xml:space="preserve">
          <source>A subpattern that does not contain a | character is just a part of the enclosing alternative; it is not a nested alternation with only one alternative. The effect of (*THEN) extends beyond such a subpattern to the enclosing alternative. Consider the following pattern, where A, B, and so on, are complex pattern fragments that do not contain any | characters at this level:</source>
          <target state="translated">|를 포함하지 않는 서브 패턴 성격은 둘러싸는 대안의 일부일뿐입니다. 단 하나의 대안으로 중첩 된 대안이 아닙니다. (* THEN)의 효과는 이러한 서브 패턴을 넘어 대체 대안으로 확장됩니다. A, B 등이 다음을 포함하지 않는 복잡한 패턴 조각 인 다음 패턴을 고려하십시오. 이 레벨의 문자 :</target>
        </trans-unit>
        <trans-unit id="359594612c2eb9a5932465070d74beae6a372eb0" translate="yes" xml:space="preserve">
          <source>A subpattern that is referenced by name can appear in the pattern before or after the reference.</source>
          <target state="translated">이름으로 참조되는 하위 패턴은 참조 전후 패턴에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8554111ace0a51aa20ae047b50f0d90058ec0d6" translate="yes" xml:space="preserve">
          <source>A subroutine call to a subpattern (recursive or otherwise)</source>
          <target state="translated">서브 패턴에 대한 서브 루틴 호출 (재귀 적 또는 기타)</target>
        </trans-unit>
        <trans-unit id="1e9e2570d27c2595d94b29222dcc52f4683b8c79" translate="yes" xml:space="preserve">
          <source>A subset of all semantic checks on types are implemented. For example, strictly the &lt;code&gt;TimeTicks&lt;/code&gt; may not be sub-classed but the compiler allows this (standard MIBs must pass through the compiler) (deviates from SMIv2 only).</source>
          <target state="translated">형식에 대한 모든 의미 검사의 하위 집합이 구현됩니다. 예를 들어, 엄격하게 &lt;code&gt;TimeTicks&lt;/code&gt; 는 서브 클래스로 분류되지 않을 수 있지만 컴파일러는이를 허용합니다 (표준 MIB는 컴파일러를 통과해야 함) (SMIv2에서만 다름).</target>
        </trans-unit>
        <trans-unit id="29bc759fe88a2b272d7f7e146c9840a7ce6ba6f5" translate="yes" xml:space="preserve">
          <source>A successful match of a segment of a &lt;code&gt;utf&lt;/code&gt; type, results in an integer in the range 0..16#D7FF or 16#E000..16#10FFFF. The match fails if the returned value falls outside those ranges.</source>
          <target state="translated">&lt;code&gt;utf&lt;/code&gt; 유형 의 세그먼트가 성공적으로 일치 하면 0..16 # D7FF 또는 16 # E000..16 # 10FFFF 범위의 정수가됩니다. 반환 된 값이 해당 범위를 벗어나면 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0dd5399d68fd62c8aa61dea1b9cd129c66c4e135" translate="yes" xml:space="preserve">
          <source>A suggestion, in kilowords, on how large a stack to use. A value &amp;lt; 0 means default size.</source>
          <target state="translated">사용할 스택의 크기에 대한 제안 (킬로 단어)입니다. &amp;lt;0 값은 기본 크기를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d2bcf77bf32e3c737f6132f4ba89272aa61deb33" translate="yes" xml:space="preserve">
          <source>A suitable &lt;code&gt;erlang_pid&lt;/code&gt; can be constructed from the &lt;code&gt;ei_cnode&lt;/code&gt; structure by the following example code:</source>
          <target state="translated">다음 예제 코드 를 통해 &lt;code&gt;ei_cnode&lt;/code&gt; 구조 에서 적절한 &lt;code&gt;erlang_pid&lt;/code&gt; 를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c330db35fee146e2f49165430e3031752b587566" translate="yes" xml:space="preserve">
          <source>A suitable &lt;code&gt;erlang_pid&lt;/code&gt; can be retrieved from the &lt;code&gt;ei_cnode&lt;/code&gt; structure by calling &lt;code&gt;ei_self(cnode_pointer)&lt;/code&gt;.</source>
          <target state="translated">적절한 &lt;code&gt;erlang_pid&lt;/code&gt; 는 &lt;code&gt;ei_self(cnode_pointer)&lt;/code&gt; 호출 하여 &lt;code&gt;ei_cnode&lt;/code&gt; 구조 에서 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e635ab7a6524cfed54f5074b2c5f201fa29a542e" translate="yes" xml:space="preserve">
          <source>A summary of all the run test cases.</source>
          <target state="translated">모든 실행 된 테스트 사례 요약</target>
        </trans-unit>
        <trans-unit id="490b87fb70901b3cf146b436d3ad3d6969ae85d3" translate="yes" xml:space="preserve">
          <source>A summary of allocated block sizes (including their headers) grouped by their &lt;code&gt;Origin&lt;/code&gt; and &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Origin&lt;/code&gt; 및 &lt;code&gt;Type&lt;/code&gt; 별로 그룹화 된 할당 된 블록 크기 (헤더 포함) 요약 .</target>
        </trans-unit>
        <trans-unit id="555b82edcc9a51ba9b0a8648b94fe2cee0f8eb4a" translate="yes" xml:space="preserve">
          <source>A super carrier is large memory area, allocated at VM start, which can be used during runtime to allocate normal carriers from.</source>
          <target state="translated">슈퍼 캐리어는 VM 시작시 할당되는 대용량 메모리 영역으로 런타임 중에 일반 캐리어를 할당하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c019e1f1b48948e812995eacd1c55f50920bdf21" translate="yes" xml:space="preserve">
          <source>A super carrier needs to satisfy two slightly different kinds of allocation requests; multi block carriers (MBC) and single block carriers (SBC). They are both rather large blocks of continious memory, but MBCs and SBCs have different demands on alignment and size.</source>
          <target state="translated">수퍼 캐리어는 약간 다른 두 종류의 할당 요청을 충족해야합니다. 다중 블록 캐리어 (MBC) 및 단일 블록 캐리어 (SBC). 둘 다 상당히 큰 연속 메모리 블록이지만 MBC와 SBC는 정렬 및 크기에 대한 요구 사항이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="42e4170b78b8fb9e3847e667242b4de5cec174c5" translate="yes" xml:space="preserve">
          <source>A supervisor bridge assumes the functions for starting and stopping the subsystem to be located in a callback module exporting a predefined set of functions.</source>
          <target state="translated">수퍼바이저 브리지는 사전 정의 된 기능 세트를 내보내는 콜백 모듈에서 서브 시스템을 시작 및 중지하기위한 기능을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f8e585f469018050c24b2320c6df8c355fe43361" translate="yes" xml:space="preserve">
          <source>A supervisor can have one of the following &lt;strong&gt;restart strategies&lt;/strong&gt; specified with the &lt;code&gt;strategy&lt;/code&gt; key in the above map:</source>
          <target state="translated">감독자는 위의 맵에서 &lt;code&gt;strategy&lt;/code&gt; 키로 지정된 다음 &lt;strong&gt;재시작 전략&lt;/strong&gt; 중 하나를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b7d18f5eb25e50d03987db777d14f147e150acb" translate="yes" xml:space="preserve">
          <source>A supervisor expects the definition of which child processes to supervise to be specified in a callback module exporting a predefined set of functions.</source>
          <target state="translated">감독자는 사전 정의 된 함수 세트를 내보내는 콜백 모듈에서 감독 할 하위 프로세스의 정의를 예상합니다.</target>
        </trans-unit>
        <trans-unit id="f82d3f2d9f94a9fc80489eaf4729fa8c31535cf1" translate="yes" xml:space="preserve">
          <source>A supervisor for the SNMP agent Processes</source>
          <target state="translated">SNMP 에이전트 프로세스의 감독자</target>
        </trans-unit>
        <trans-unit id="07d7e065bf97522ff7b29841ee97a5f3abaaa707" translate="yes" xml:space="preserve">
          <source>A supervisor is responsible for starting, stopping, and monitoring its child processes. The basic idea of a supervisor is that it is to keep its child processes alive by restarting them when necessary.</source>
          <target state="translated">감독자는 자식 프로세스의 시작, 중지 및 모니터링을 담당합니다. 감독자의 기본 아이디어는 필요할 때 다시 시작하여 자식 프로세스를 활성 상태로 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8efae13f8c7942b2ac38b9a2a73eb196c3d0a6ff" translate="yes" xml:space="preserve">
          <source>A supervisor report is issued when a supervised child terminates unexpectedly. A supervisor report contains the following items:</source>
          <target state="translated">감독 자녀가 예기치 않게 종료되면 감독자 보고서가 발행됩니다. 감독자 보고서에는 다음 항목이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d5726e30c2bfdd999c9a419984c8b7f106bff81" translate="yes" xml:space="preserve">
          <source>A supervisor with restart strategy &lt;code&gt;simple_one_for_one&lt;/code&gt; is a simplified &lt;code&gt;one_for_one&lt;/code&gt; supervisor, where all child processes are dynamically added instances of the same process.</source>
          <target state="translated">재시작 전략이 &lt;code&gt;simple_one_for_one&lt;/code&gt; 인 수퍼바이저 는 단순화 된 &lt;code&gt;one_for_one&lt;/code&gt; 수퍼바이저이며 모든 하위 프로세스가 동일한 프로세스의 인스턴스에 동적으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4a17c6d57373e353ac6abb1cd3af415a947ff039" translate="yes" xml:space="preserve">
          <source>A suspend request is sent to the process identified by &lt;code&gt;Suspendee&lt;/code&gt;. &lt;code&gt;Suspendee&lt;/code&gt; eventually suspends unless it is resumed before it could suspend. The caller of &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; returns immediately, regardless of whether &lt;code&gt;Suspendee&lt;/code&gt; has suspended yet or not. The point in time when &lt;code&gt;Suspendee&lt;/code&gt; suspends cannot be deduced from other events in the system. It is only guaranteed that &lt;code&gt;Suspendee&lt;/code&gt;&lt;strong&gt;eventually&lt;/strong&gt; suspends (unless it is resumed). If no &lt;code&gt;asynchronous&lt;/code&gt; options has been passed, the caller of &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; is blocked until &lt;code&gt;Suspendee&lt;/code&gt; has suspended.</source>
          <target state="translated">일시 중단 요청은 &lt;code&gt;Suspendee&lt;/code&gt; 가 식별 한 프로세스로 전송됩니다 . &lt;code&gt;Suspendee&lt;/code&gt; 는 중단되기 전에 재개되지 않는 한 결국 중단됩니다. &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; 의 호출자는 &lt;code&gt;Suspendee&lt;/code&gt; 의 일시 중단 여부에 관계없이 즉시 반환합니다 . &lt;code&gt;Suspendee&lt;/code&gt; 가 일시 중단 되는 시점 은 시스템의 다른 이벤트에서 추론 할 수 없습니다. &lt;code&gt;Suspendee&lt;/code&gt; 가 재개되지 않는 한 &lt;strong&gt;결국 &lt;/strong&gt;Suspendee &lt;strong&gt;가&lt;/strong&gt; 일시 중단 되는 것이 보장 됩니다. &lt;code&gt;asynchronous&lt;/code&gt; 옵션이 전달 되지 않은 경우 &lt;code&gt;Suspendee&lt;/code&gt; 가 일시 중단 될 때까지 &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; 의 호출자 가 차단 됩니다.</target>
        </trans-unit>
        <trans-unit id="25b4e7d3e689427411ff502e735d917aa357caf7" translate="yes" xml:space="preserve">
          <source>A suspend request is sent to the process identified by &lt;code&gt;Suspendee&lt;/code&gt;. When the suspend request has been processed, a reply message is sent to the caller of this function. The reply is on the form &lt;code&gt;{ReplyTag, State}&lt;/code&gt; where &lt;code&gt;State&lt;/code&gt; is either:</source>
          <target state="translated">일시 중단 요청은 &lt;code&gt;Suspendee&lt;/code&gt; 가 식별 한 프로세스로 전송됩니다 . 일시 중단 요청이 처리되면이 기능의 호출자에게 응답 메시지가 전송됩니다. 회신은 &lt;code&gt;{ReplyTag, State}&lt;/code&gt; 이며 &lt;code&gt;State&lt;/code&gt; 는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="aa31c4e6104829ed1e5940c6b760d5e5f8223aa4" translate="yes" xml:space="preserve">
          <source>A symbolic link in the path points above the root of the relative path.</source>
          <target state="translated">경로의 심볼릭 링크는 상대 경로의 루트 위를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="dab5b92521d5334adcd3b34a7cd584da12e53036" translate="yes" xml:space="preserve">
          <source>A syntax tree can be transformed to the &lt;code&gt;&lt;a href=&quot;#type-erl_parse&quot;&gt;erl_parse()&lt;/a&gt;&lt;/code&gt; representation with the &lt;code&gt;&lt;a href=&quot;#revert-1&quot;&gt;revert/1&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">구문 트리는 &lt;code&gt;&lt;a href=&quot;#revert-1&quot;&gt;revert/1&lt;/a&gt;&lt;/code&gt; 함수 를 사용하여 &lt;code&gt;&lt;a href=&quot;#type-erl_parse&quot;&gt;erl_parse()&lt;/a&gt;&lt;/code&gt; 표현 으로 변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fe7a01f61caca49ad408b9e314c2eab8ae04b7a" translate="yes" xml:space="preserve">
          <source>A system I/O vector, as used by &lt;code&gt;writev&lt;/code&gt; on Unix and &lt;code&gt;WSASend&lt;/code&gt; on Win32. It is used in &lt;code&gt;ErlIOVec&lt;/code&gt;.</source>
          <target state="translated">Unix의 &lt;code&gt;writev&lt;/code&gt; 와 Win32의 &lt;code&gt;WSASend&lt;/code&gt; 에 사용되는 시스템 I / O 벡터 . &lt;code&gt;ErlIOVec&lt;/code&gt; 에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0af2eabcce5a60d4fed7164c28fadc9a20e4493d" translate="yes" xml:space="preserve">
          <source>A system I/O vector, as used by &lt;code&gt;writev&lt;/code&gt; on Unix and &lt;code&gt;WSASend&lt;/code&gt; on Win32. It is used in &lt;code&gt;ErlNifIOVec&lt;/code&gt; and by &lt;code&gt;&lt;a href=&quot;#enif_ioq_peek&quot;&gt;enif_ioq_peek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Unix의 &lt;code&gt;writev&lt;/code&gt; 와 Win32의 &lt;code&gt;WSASend&lt;/code&gt; 에 사용되는 시스템 I / O 벡터 . &lt;code&gt;ErlNifIOVec&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#enif_ioq_peek&quot;&gt;enif_ioq_peek&lt;/a&gt;&lt;/code&gt; 에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="616d063d630bdaee784166c5d2aa3d7079333cc2" translate="yes" xml:space="preserve">
          <source>A system configuration file, &lt;code&gt;sys.config&lt;/code&gt;</source>
          <target state="translated">시스템 구성 파일 인 &lt;code&gt;sys.config&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a27085bf58c10c3bac131eedf2381b0839b7998" translate="yes" xml:space="preserve">
          <source>A system configuration source file, &lt;code&gt;sys.config.src&lt;/code&gt;</source>
          <target state="translated">시스템 구성 소스 파일 &lt;code&gt;sys.config.src&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="475c3957e8fbb0321adf13488719ce7f864fd2ec" translate="yes" xml:space="preserve">
          <source>A system limit has been reached. See &lt;code&gt; Efficiency Guide&lt;/code&gt; for information about system limits.</source>
          <target state="translated">시스템 한계에 도달했습니다. 시스템 제한에 대한 정보는 &lt;code&gt; Efficiency Guide&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c879d34c3ec9d9665df9efe9db8cf8d5df6abde2" translate="yes" xml:space="preserve">
          <source>A system limit has been reached. See &lt;code&gt;Efficiency Guide&lt;/code&gt; for information about system limits.</source>
          <target state="translated">시스템 한도에 도달했습니다. 시스템 한계에 대한 정보는 &lt;code&gt;Efficiency Guide&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b8fdecfc617b9fa3706b79edfcf234ce5f241ff" translate="yes" xml:space="preserve">
          <source>A tab followed by character &quot;3&quot;</source>
          <target state="translated">탭 뒤에 문자 &quot;3&quot;</target>
        </trans-unit>
        <trans-unit id="7d11781c842639135820e9eada3b27c9a8d0d9ad" translate="yes" xml:space="preserve">
          <source>A table called &lt;code&gt;myTable&lt;/code&gt; has five columns. The first two are keys (not accessible), and the table has three rows. The instrumentation function for this table is called &lt;code&gt;my_table&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;myTable&lt;/code&gt; 이라는 테이블 에는 5 개의 열이 있습니다. 처음 두 개는 키 (액세스 할 수 없음)이며 테이블에는 세 개의 행이 있습니다. 이 테이블의 인스 트루먼 테이션 함수는 &lt;code&gt;my_table&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="75534734c58db0aa05f9239f37f6428de398c20c" translate="yes" xml:space="preserve">
          <source>A table identifier, as returned by &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt; 에 의해 반환되는 테이블 식별자 입니다.</target>
        </trans-unit>
        <trans-unit id="9f0fe364ceb37c8d8dc5f9217f78c519dc139c59" translate="yes" xml:space="preserve">
          <source>A table may contain columns that are used internally, but should not be visible to a manager. These internal columns must be the last columns in the table. The &lt;code&gt;set&lt;/code&gt; operation will not work with this arrangement, because there are columns that the agent does not know about. This situation is handled by adding values for the internal columns in the &lt;code&gt;set&lt;/code&gt; function.</source>
          <target state="translated">테이블에는 내부적으로 사용되는 열이 포함될 수 있지만 관리자에게는 보이지 않아야합니다. 이 내부 열은 테이블의 마지막 열이어야합니다. &lt;code&gt;set&lt;/code&gt; 열이 있기 때문에 작업이 배치하지 작업, 에이전트가 알지 못하는 것이다. 이 상황은 &lt;code&gt;set&lt;/code&gt; 함수 에서 내부 열의 값을 추가하여 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ccf87ca282ead9bb584834a165823229be63f73" translate="yes" xml:space="preserve">
          <source>A table object</source>
          <target state="translated">테이블 객체</target>
        </trans-unit>
        <trans-unit id="57b2065e432402661ed8ccb643e2901e6965c10a" translate="yes" xml:space="preserve">
          <source>A table of type &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;ordered_set&lt;/code&gt; has either zero or one record per key, whereas a table of type &lt;code&gt;bag&lt;/code&gt; can have an arbitrary number of records per key. The key for each record is always the first attribute of the record.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 또는 &lt;code&gt;ordered_set&lt;/code&gt; 유형의 테이블에는 키당 0 개 또는 1 개의 레코드가있는 반면 &lt;code&gt;bag&lt;/code&gt; 유형의 테이블 에는 키당 임의의 수의 레코드가있을 수 있습니다. 각 레코드의 키는 항상 레코드의 첫 번째 특성입니다.</target>
        </trans-unit>
        <trans-unit id="a88c8b440b3f81b0c6b1eb623a7b8614ba6ccb2c" translate="yes" xml:space="preserve">
          <source>A table traversal is &lt;strong&gt;safe&lt;/strong&gt; if either</source>
          <target state="translated">테이블 순회는 다음과 같은 경우 에 &lt;strong&gt;안전&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8be8a69bc11325d2a87005532e2b29bbd011c378" translate="yes" xml:space="preserve">
          <source>A tag that describes the (select) operation.</source>
          <target state="translated">(선택) 작업을 설명하는 태그입니다.</target>
        </trans-unit>
        <trans-unit id="338d3dd5c9171dcfa74ab3490bd081525d78c330" translate="yes" xml:space="preserve">
          <source>A tail-recursive function that does not need to reverse the list at the end is faster than a body-recursive function, as are tail-recursive functions that do not construct any terms at all (for example, a function that sums all integers in a list).</source>
          <target state="translated">용어를 전혀 구성하지 않는 꼬리 재귀 함수 (예 : 모든 정수를 합산하는 함수)와 같이 끝에서 목록을 뒤집을 필요가없는 꼬리 재귀 함수는 신체 재귀 함수보다 빠릅니다. 목록).</target>
        </trans-unit>
        <trans-unit id="6ed306bfabb588bedad1a38ebc28c88dc1ee79a9" translate="yes" xml:space="preserve">
          <source>A target system may have several releases but the one given as &lt;code&gt;boot_rel&lt;/code&gt; will be used as default when the system is booting up.</source>
          <target state="translated">대상 시스템에 여러 릴리스가있을 수 있지만 시스템을 부팅 할 때 &lt;code&gt;boot_rel&lt;/code&gt; 로 지정된 릴리스 가 기본값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af9eae26f481905b914e12255a1f498f1501fe7a" translate="yes" xml:space="preserve">
          <source>A task that can be aborted is referred via another data structure from other parts of the system, so that a thread that needs to abort the task can reach it. In order to be sure to safely deallocate a task that is no longer used, we first clear this reference and then use the thread progress functionality in order to make sure no references can exist to the task. Unfortunately, also unmanaged threads might abort tasks. This is very infrequent, but might occur. This could be handled locally for each port, but would require extra information in each port structure which very infrequently would be used. Instead of implementing this in each port, we implemented general functionality that can be used from unmanaged threads to delay thread progress.</source>
          <target state="translated">중단 될 수있는 작업은 시스템의 다른 부분에서 다른 데이터 구조를 통해 참조되므로 작업을 중단해야하는 스레드가 도달 할 수 있습니다. 더 이상 사용되지 않는 작업을 안전하게 할당 해제하려면 먼저이 참조를 지운 다음 스레드 진행 기능을 사용하여 작업에 대한 참조가 존재하지 않도록합니다. 불행히도 관리되지 않는 스레드도 작업을 중단 할 수 있습니다. 이것은 매우 드물지만 발생할 수 있습니다. 이것은 각 포트에 대해 로컬로 처리 될 수 있지만 각 포트 구조에서 매우 드물게 사용되는 추가 정보가 필요합니다. 각 포트에서이를 구현하는 대신 관리되지 않는 스레드에서 스레드 진행을 지연시키는 데 사용할 수있는 일반 기능을 구현했습니다.</target>
        </trans-unit>
        <trans-unit id="3ba0e9f6775914dcfade32d5d8265e1ed8ccd90d" translate="yes" xml:space="preserve">
          <source>A temporary process will be created for each callback call.</source>
          <target state="translated">각 콜백 호출에 대해 임시 프로세스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="92a162c972e0a2da1ef36842b8e1183dc63976d3" translate="yes" xml:space="preserve">
          <source>A term in which the state machine implementation is to store any server data it needs. The difference between this and the &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; itself is that a change in this data does not cause postponed events to be retried. Hence, if a change in this data would change the set of events that are handled, then that data item is to be made a part of the state.</source>
          <target state="translated">상태 머신 구현이 필요한 서버 데이터를 저장하는 용어입니다. 이것과 &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; 자체 의 차이점은이 데이터의 변경으로 인해 연기 된 이벤트가 재 시도되지 않는다는 것입니다. 따라서이 데이터의 변경으로 인해 처리되는 이벤트 세트가 변경되면 해당 데이터 항목이 상태의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="3c82bdf9ca846d33c59020cff263330ebd6a6321" translate="yes" xml:space="preserve">
          <source>A term of type &lt;code&gt;&lt;a href=&quot;#type-iovec&quot;&gt;iovec()&lt;/a&gt;&lt;/code&gt;, structured according to the Erlang external term format.</source>
          <target state="translated">Erlang 외부 용어 형식에 따라 구조화 된 &lt;code&gt;&lt;a href=&quot;#type-iovec&quot;&gt;iovec()&lt;/a&gt;&lt;/code&gt; 유형의 용어입니다.</target>
        </trans-unit>
        <trans-unit id="f59430379cf9648470c25a50d2a2c81bb2b89218" translate="yes" xml:space="preserve">
          <source>A term, if the event handler is removed because of an error. Which term depends on the error.</source>
          <target state="translated">오류로 인해 이벤트 핸들러가 제거 된 경우의 용어입니다. 어떤 용어는 오류에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9594dc172a1a303c23e2c7f885380aa1c05fad93" translate="yes" xml:space="preserve">
          <source>A test case can handle several connections to one or more target systems, instruments, and traffic generators in parallel to perform the necessary actions for a test. The handling of many connections in parallel is one of the major strengths of &lt;code&gt;Common Test&lt;/code&gt;, thanks to the efficient support for concurrency in the Erlang runtime system, which &lt;code&gt;Common Test&lt;/code&gt; users can take great advantage of.</source>
          <target state="translated">테스트 케이스는 테스트에 필요한 조치를 수행하기 위해 하나 이상의 대상 시스템, 계측기 및 트래픽 생성기에 대한 여러 연결을 병렬로 처리 할 수 ​​있습니다. &lt;code&gt;Common Test&lt;/code&gt; 사용자가 활용할 수 있는 Erlang 런타임 시스템의 동시성에 대한 효율적인 지원 덕분 에 많은 연결을 병렬로 처리하는 것이 &lt;code&gt;Common Test&lt;/code&gt; 의 주요 강점 중 하나 입니다.</target>
        </trans-unit>
        <trans-unit id="3f0276c5d34cae70dd7c0725d3127cfdb7e17a06" translate="yes" xml:space="preserve">
          <source>A test case failure is specified as a runtime error (a crash), no matter what the reason for termination is. If you use Erlang pattern matching effectively, you can take advantage of this property. The result is concise and readable test case functions that look much more like scripts than actual programs. A simple example:</source>
          <target state="translated">테스트 케이스 실패는 종료 이유가 무엇이든 런타임 오류 (충돌)로 지정됩니다. Erlang 패턴 일치를 효과적으로 사용하면이 속성을 활용할 수 있습니다. 결과는 실제 프로그램보다 훨씬 스크립트처럼 보이는 간결하고 읽기 쉬운 테스트 케이스 함수입니다. 간단한 예 :</target>
        </trans-unit>
        <trans-unit id="57803d84844b81148f638909cfbdf834fb63a201" translate="yes" xml:space="preserve">
          <source>A test case group can be repeated a certain number of times (specified by an integer) or indefinitely (specified by &lt;code&gt;forever&lt;/code&gt;). The repetition can also be stopped too early if any or all cases fail or succeed, that is, if any of the properties &lt;code&gt;repeat_until_any_fail&lt;/code&gt;, &lt;code&gt;repeat_until_any_ok&lt;/code&gt;, &lt;code&gt;repeat_until_all_fail&lt;/code&gt;, or &lt;code&gt;repeat_until_all_ok&lt;/code&gt; is used. If the basic &lt;code&gt;repeat&lt;/code&gt; property is used, status of test cases is irrelevant for the repeat operation.</source>
          <target state="translated">테스트 케이스 그룹은 특정 횟수 (정수로 지정됨) 또는 무한정 ( &lt;code&gt;forever&lt;/code&gt; 하게 지정됨)으로 반복 될 수 있습니다 . 어떤 경우 나 모든 경우에 실패하거나 성공한 경우, 즉 &lt;code&gt;repeat_until_any_fail&lt;/code&gt; , &lt;code&gt;repeat_until_any_ok&lt;/code&gt; , &lt;code&gt;repeat_until_all_fail&lt;/code&gt; 또는 &lt;code&gt;repeat_until_all_ok&lt;/code&gt; 특성 중 하나 가 사용되는 경우 반복을 너무 일찍 중지 할 수도 있습니다 . 기본 &lt;code&gt;repeat&lt;/code&gt; 속성을 사용하는 경우 테스트 사례의 상태는 반복 작업과 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="70f3b406878b1ad27d06f47209f488fb0090bedb" translate="yes" xml:space="preserve">
          <source>A test case group is a set of test cases sharing configuration functions and execution properties. Test case groups are defined by function &lt;code&gt;&lt;a href=&quot;common_test#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; according to the following syntax:</source>
          <target state="translated">테스트 케이스 그룹은 구성 기능 및 실행 특성을 공유하는 테스트 케이스 세트입니다. 테스트 케이스 그룹은 다음 구문에 따라 기능 &lt;code&gt;&lt;a href=&quot;common_test#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="6615fe68020574c9d51502afda77dbb501f32348" translate="yes" xml:space="preserve">
          <source>A test case group is a set of test cases sharing configuration functions and execution properties. Test case groups are defined by function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; according to the following syntax:</source>
          <target state="translated">테스트 케이스 그룹은 구성 기능 및 실행 특성을 공유하는 테스트 케이스 세트입니다. 테스트 케이스 그룹은 다음 구문에 따라 기능 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; 에 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="e797bd2be17f58c7efe8dfeff204b02c5adaa5d5" translate="yes" xml:space="preserve">
          <source>A test case is considered successful if it returns to the caller, no matter what the returned value is. However, a few return values have special meaning as follows:</source>
          <target state="translated">테스트 케이스는 리턴 된 값이 무엇이든 호출자에게 리턴되면 성공한 것으로 간주됩니다. 그러나 일부 반환 값은 다음과 같은 특별한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="dcc50de966066784aa8d897c8ffe49a70bbe3620" translate="yes" xml:space="preserve">
          <source>A test is performed by running one or more test suites. A test suite consists of test cases, configuration functions, and information functions. Test cases can be grouped in so called test case groups. A test suite is an Erlang module and test cases are implemented as Erlang functions. Test suites are stored in test directories.</source>
          <target state="translated">테스트는 하나 이상의 테스트 스위트를 실행하여 수행됩니다. 테스트 스위트는 테스트 케이스, 구성 기능 및 정보 기능으로 구성됩니다. 테스트 케이스는 테스트 케이스 그룹으로 그룹화 할 수 있습니다. 테스트 스위트는 Erlang 모듈이며 테스트 케이스는 Erlang 함수로 구현됩니다. 테스트 스위트는 테스트 디렉토리에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="82b0d4348a040296baa971a336f70137d0143756" translate="yes" xml:space="preserve">
          <source>A test set can be easily created by placing a sequence of test objects in a list. If &lt;code&gt;T_1&lt;/code&gt;, ..., &lt;code&gt;T_N&lt;/code&gt; are individual test objects, then &lt;code&gt;[T_1, ..., T_N]&lt;/code&gt; is a test set consisting of those objects (in that order).</source>
          <target state="translated">일련의 테스트 개체를 목록에 배치하여 테스트 세트를 쉽게 만들 수 있습니다. 경우 &lt;code&gt;T_1&lt;/code&gt; 이 , ..., &lt;code&gt;T_N&lt;/code&gt; 이 후 개별 테스트 객체이다 &lt;code&gt;[T_1, ..., T_N]&lt;/code&gt; (순서)에 해당 개체로 이루어진 테스트 세트이다.</target>
        </trans-unit>
        <trans-unit id="850a2b153e54fe3302effc5897fd48daf6d71d85" translate="yes" xml:space="preserve">
          <source>A test suite is an ordinary Erlang module that contains test cases. It is recommended that the module has a name on the form &lt;code&gt;*_SUITE.erl&lt;/code&gt;. Otherwise, the directory and auto compilation function in &lt;code&gt;Common Test&lt;/code&gt; cannot locate it (at least not by default).</source>
          <target state="translated">테스트 스위트는 테스트 케이스를 포함하는 일반적인 Erlang 모듈입니다. 모듈은 &lt;code&gt;*_SUITE.erl&lt;/code&gt; 형식의 이름을 갖는 것이 좋습니다 . 그렇지 않으면 &lt;code&gt;Common Test&lt;/code&gt; 의 디렉토리 및 자동 컴파일 기능이 이를 찾을 수 없습니다 (적어도 기본적으로는 아님).</target>
        </trans-unit>
        <trans-unit id="c6a46a09bfa35f6d6a3e0deef8196b3ea6cd2281" translate="yes" xml:space="preserve">
          <source>A test term can also specify one or more test suites, groups, or test cases to be skipped. Skipped suites, groups, and cases are not executed and show up in the HTML log files as &lt;code&gt;SKIPPED&lt;/code&gt;.</source>
          <target state="translated">테스트 용어는 건너 뛸 하나 이상의 테스트 스위트, 그룹 또는 테스트 케이스를 지정할 수도 있습니다. 건너 뛴 제품군, 그룹 및 사례는 실행되지 않으며 HTML 로그 파일에 &lt;code&gt;SKIPPED&lt;/code&gt; 로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="fc9a7da069ee22047038749756cf97523761175f" translate="yes" xml:space="preserve">
          <source>A textual comment describing the service. Not mandatory, but shows up as the service description in the Windows service manager.</source>
          <target state="translated">서비스를 설명하는 텍스트 설명입니다. 필수는 아니지만 Windows 서비스 관리자에서 서비스 설명으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1b69647db9e6ba8a0e002c236579c1374755b41d" translate="yes" xml:space="preserve">
          <source>A the time of writing this, the latest released version of SystemTap is version 1.6. Erlang's DTrace support requires a MACRO that was introduced after that release. So either get a newer release or build SystemTap from git yourself (see: http://sourceware.org/systemtap/getinvolved.html)</source>
          <target state="translated">이 글을 쓰는 시점에서 SystemTap의 최신 릴리스 버전은 1.6입니다. Erlang의 DTrace 지원에는 해당 릴리스 이후에 도입 된 MACRO가 필요합니다. 따라서 최신 릴리스를 얻거나 직접 git에서 SystemTap을 빌드하십시오 (http://sourceware.org/systemtap/getinvolved.html 참조)</target>
        </trans-unit>
        <trans-unit id="9b18f6bb3b01d76a4dfa566d98c87a28d7f6b44e" translate="yes" xml:space="preserve">
          <source>A third alternative is to download and install MSYS2 from:</source>
          <target state="translated">세 번째 대안은 다음에서 MSYS2를 다운로드하여 설치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1d370bfacb3e303ae0b301510d2fd8f9fe73b2f2" translate="yes" xml:space="preserve">
          <source>A third feature is to have the super carrier limit the &lt;strong&gt;maximum&lt;/strong&gt; amount of memory used by the VM. If +MMsco (Super Carrier Only) is set to true, which is default, allocations will only be done from the super carrier. When the super carrier gets full, the VM will fail due to out of memory. If +MMsco is false, allocations will use mmap directly if the super carrier is full.</source>
          <target state="translated">세 번째 기능은 수퍼 캐리어 가 VM에서 사용 하는 &lt;strong&gt;최대&lt;/strong&gt; 메모리 양을 제한하도록 하는 것입니다. + MMsco (Super Carrier Only)가 기본값 인 true로 설정되면 할당은 수퍼 캐리어에서만 수행됩니다. 슈퍼 캐리어가 가득 차면 메모리 부족으로 인해 VM이 실패합니다. + MMsco가 false이면 수퍼 캐리어가 가득 차면 할당에서 mmap을 직접 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a52be3095703dc09da3f8d9ef4629a28e6444954" translate="yes" xml:space="preserve">
          <source>A third problem was management of low memory in the halfword emulator. The implementation used a naive linear search structure to hold free segments which would lead to poor performance when fragmentation increased.</source>
          <target state="translated">세 번째 문제는 하프 워드 에뮬레이터의 메모리 부족 관리였습니다. 구현은 순진한 선형 검색 구조를 사용하여 조각화가 증가 할 때 성능이 저하되는 자유 세그먼트를 보유했습니다.</target>
        </trans-unit>
        <trans-unit id="f9c4754ee9c691b3be255533c56967a9f65767a3" translate="yes" xml:space="preserve">
          <source>A third usage is to block login attempts from a missbehaving peer. The &lt;code&gt;State&lt;/code&gt; described above can be used for this. The return value &lt;code&gt;disconnect&lt;/code&gt; is useful for this.</source>
          <target state="translated">세 번째 사용법은 잘못 동작하는 피어의 로그인 시도를 차단하는 것입니다. &lt;code&gt;State&lt;/code&gt; 위의 설명이 사용할 수 있습니다. 반환 값 &lt;code&gt;disconnect&lt;/code&gt; 은 이것에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="dd9a2152eb9572e05f0a61d8511698051e7c78f8" translate="yes" xml:space="preserve">
          <source>A thread can only be joined once. The behavior of joining more than once is undefined, an emulator crash is likely. If &lt;code&gt;exit_value == NULL&lt;/code&gt;, the exit value of the terminated thread is ignored, otherwise the exit value of the terminated thread is stored at &lt;code&gt;*exit_value&lt;/code&gt;.</source>
          <target state="translated">스레드는 한 번만 결합 될 수 있습니다. 두 번 이상 결합하는 동작은 정의되어 있지 않으며 에뮬레이터 충돌이 발생할 수 있습니다. 경우 &lt;code&gt;exit_value == NULL&lt;/code&gt; , 종료 된 스레드의 종료 값이 무시되고, 그렇지 않으면 종료 된 스레드의 종료 값이 저장됩니다 &lt;code&gt;*exit_value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="713f4e1d5b50f7df039ee9fe6e1996e2572d7a3a" translate="yes" xml:space="preserve">
          <source>A thread identifier can be reused very quickly after a thread has terminated. Therefore, if a thread corresponding to one of the involved thread identifiers has terminated since the thread identifier was saved, the result of &lt;code&gt;erl_drv_equal_tids&lt;/code&gt; does possibly not give the expected result.</source>
          <target state="translated">스레드 식별자는 스레드가 종료 된 후 매우 빠르게 재사용 할 수 있습니다. 따라서 스레드 식별자를 저장 한 후 관련된 스레드 식별자 중 하나에 해당하는 스레드가 종료 된 경우 &lt;code&gt;erl_drv_equal_tids&lt;/code&gt; 의 결과 는 예상 된 결과를 제공하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cad763d5e07983c99c13f14998b109764ecd9488" translate="yes" xml:space="preserve">
          <source>A time stamp as returned by the BIF &lt;code&gt;now()&lt;/code&gt;.</source>
          <target state="translated">BIF &lt;code&gt;now()&lt;/code&gt; 에서 리턴 한 시간 소인 .</target>
        </trans-unit>
        <trans-unit id="09f8c7e2d1b4631a8a0fd8e3a936590e5cfc3d7c" translate="yes" xml:space="preserve">
          <source>A time warp is a leap forwards or backwards in time. That is, the difference of time values taken before and after the time warp does not correspond to the actual elapsed time.</source>
          <target state="translated">타임 워프는 시간이 앞뒤로 도약하는 것입니다. 즉, 시간 왜곡 전후의 시간 값 차이는 실제 경과 시간과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd86c3e0b5292795cee07d9ad33f244af7a25314" translate="yes" xml:space="preserve">
          <source>A time-out feature inherited from &lt;code&gt;gen_statem&lt;/code&gt;'s predecessor &lt;code&gt;gen_fsm&lt;/code&gt;, is an event time-out, that is, if an event arrives the timer is cancelled. You get either an event or a time-out, but not both.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 의 선행 작업 &lt;code&gt;gen_fsm&lt;/code&gt; 에서 상속 된 시간 초과 기능 은 이벤트 시간 초과입니다. 즉, 이벤트가 도착하면 타이머가 취소됩니다. 이벤트 또는 시간 제한이 있지만 둘다는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e4e7c858b3f4a06a0ae20e24345812eb57867da0" translate="yes" xml:space="preserve">
          <source>A time-out value of &lt;code&gt;0&lt;/code&gt; (zero) means that time-outs are disabled. Calling a &lt;code&gt;_tmo&lt;/code&gt; function with the last argument as &lt;code&gt;0&lt;/code&gt; is therefore the same thing as calling the function without the &lt;code&gt;_tmo&lt;/code&gt; suffix.</source>
          <target state="translated">시간 종료 값이 &lt;code&gt;0&lt;/code&gt; 이면 시간 종료가 사용 불가능 함을 의미합니다. 따라서 마지막 인수를 &lt;code&gt;0&lt;/code&gt; 으로하여 &lt;code&gt;_tmo&lt;/code&gt; 함수를 호출하는 것은 &lt;code&gt;_tmo&lt;/code&gt; 접미사 없이 함수를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e51396500c23760a237e8c8ce1759124abbdb2b6" translate="yes" xml:space="preserve">
          <source>A timeout, in seconds, for how long the &lt;code&gt;memsup&lt;/code&gt; process should wait for a result from a memory check. If the timeout expires, a warning message &lt;code&gt;&quot;OS_MON (memsup) timeout&quot;&lt;/code&gt; is issued via &lt;code&gt;error_logger&lt;/code&gt; and any pending, synchronous client calls will return a dummy value. Normally, this situation should not occur. There have been cases on Linux, however, where the pseudo file from which system data is read is temporarily unavailable when the system is heavily loaded.</source>
          <target state="translated">&lt;code&gt;memsup&lt;/code&gt; 프로세스가 메모리 검사 결과를 기다리는 시간 (초)입니다 . 시간 종료가 만료되면 &lt;code&gt;error_logger&lt;/code&gt; 를 통해 경고 메시지 &lt;code&gt;&quot;OS_MON (memsup) timeout&quot;&lt;/code&gt; 가 발행 되고 보류중인 모든 동기 클라이언트 호출은 더미 값을 리턴합니다. 일반적으로이 상황은 발생하지 않아야합니다. 그러나 Linux에는 시스템 데이터가 많이로드 될 때 시스템 데이터를 읽는 의사 파일을 일시적으로 사용할 수없는 경우가있었습니다.</target>
        </trans-unit>
        <trans-unit id="68ff3c996ac6d98f27aaaac3ca2c11d67e8039ea" translate="yes" xml:space="preserve">
          <source>A timer can always be removed by calling &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt; 을 호출하여 타이머를 항상 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="726a053f638d7072079d375380c92439b2bbdb5e" translate="yes" xml:space="preserve">
          <source>A timer reference.</source>
          <target state="translated">타이머 참조.</target>
        </trans-unit>
        <trans-unit id="fb8ee6e4fe82a072a334ccee3c68e3012d95b6b8" translate="yes" xml:space="preserve">
          <source>A timestamp produced with &lt;code&gt;&lt;a href=&quot;#timestamp-0&quot;&gt; logger:timestamp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#timestamp-0&quot;&gt; logger:timestamp()&lt;/a&gt;&lt;/code&gt; 생성 된 타임 스탬프 .</target>
        </trans-unit>
        <trans-unit id="94ea6da4ccb85a54c3d9ad09e70c59b90ddafcec" translate="yes" xml:space="preserve">
          <source>A timestamp produced with &lt;code&gt;erlang:system_time(microsecond)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:system_time(microsecond)&lt;/code&gt; 생성 된 타임 스탬프 입니다.</target>
        </trans-unit>
        <trans-unit id="224b47a99ccb8f9ad2636eb28064f8326a8f1842" translate="yes" xml:space="preserve">
          <source>A timetrap can also be set or reset dynamically during the execution of a test case, or configuration function. This is done by calling &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt;. This function cancels the current timetrap and starts a new one (that stays active until time-out, or end of the current function).</source>
          <target state="translated">테스트 케이스 또는 구성 기능을 실행하는 동안 타임 트랩을 동적으로 설정하거나 재설정 할 수도 있습니다. &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt; 을 호출하면됩니다 . 이 기능은 현재 타임 트랩을 취소하고 새로운 타임 트랩을 시작합니다 (타임 아웃 또는 현재 기능이 끝날 때까지 활성 상태로 유지됨).</target>
        </trans-unit>
        <trans-unit id="8f213ae236a5f4c3df724a5656b6f24789d1f1a8" translate="yes" xml:space="preserve">
          <source>A tool for applying XSLT stylesheets to XML documents. Download xsltproc from &lt;code&gt;&lt;a href=&quot;http://xmlsoft.org/XSLT/xsltproc2.html&quot;&gt;http://xmlsoft.org/XSLT/xsltproc2.html&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">XSLT 스타일 시트를 XML 문서에 적용하기위한 도구입니다. &lt;code&gt;&lt;a href=&quot;http://xmlsoft.org/XSLT/xsltproc2.html&quot;&gt;http://xmlsoft.org/XSLT/xsltproc2.html&lt;/a&gt;&lt;/code&gt; 에서 xsltproc을 다운로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="08f1e7c2bddf5c69b2f61fa1070545348579586c" translate="yes" xml:space="preserve">
          <source>A trace port is an Erlang port to a dynamically linked in driver that handles trace messages directly, without the overhead of sending them as messages in the Erlang virtual machine.</source>
          <target state="translated">추적 포트는 추적 메시지를 Erlang 가상 머신에서 메시지로 전송하지 않고 직접 추적 메시지를 처리하는 동적으로 연결된 드라이버에 대한 Erlang 포트입니다.</target>
        </trans-unit>
        <trans-unit id="12ee06a6ceec6852b8fcedb1fbb55e6e9c5f6756" translate="yes" xml:space="preserve">
          <source>A trace server started in this way will simply display the trace messages in a formatted way in the Erlang shell (i. e. use io:format). See &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; for a description of how the trace message handler can be customized.</source>
          <target state="translated">이런 방식으로 시작된 추적 서버는 추적 메시지를 Erlang 셸에서 형식화 된 방식으로 표시합니다 (예 : io : format 사용). 추적 메시지 핸들러를 사용자 정의하는 방법에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c312d23149bf55415c7facde91760776534bda23" translate="yes" xml:space="preserve">
          <source>A trace token contains a label and a set of flags. Both the label and the flags are set in both alternatives above.</source>
          <target state="translated">추적 토큰에는 레이블과 플래그 세트가 포함됩니다. 레이블과 플래그 모두 위의 두 가지 대안으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a0a3ada2bd3e540543826094f00fde5f11b86200" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables a strict monotonic timestamp to be generated for each traced event. Default is &lt;code&gt;false&lt;/code&gt;. Timestamps will consist of &lt;code&gt;Erlang monotonic time&lt;/code&gt; and a monotonically increasing integer. The time-stamp has the same format and value as produced by &lt;code&gt;{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}&lt;/code&gt;.</source>
          <target state="translated">각 추적 이벤트에 대해 엄격한 단조 시간 소인을 생성 / 비활성화하는 추적 토큰 플래그 ( &lt;code&gt;true | false&lt;/code&gt; ). 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. 타임 스탬프는 &lt;code&gt;Erlang monotonic time&lt;/code&gt; 과 단조 증가 정수로 구성됩니다. 타임 스탬프는 &lt;code&gt;{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}&lt;/code&gt; 의해 생성 된 것과 동일한 형식과 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="60097663814cb4e095c2a6a722349f6b5a5bf437" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables a strict monotonic timestamp to be generated for each traced event. Default is &lt;code&gt;false&lt;/code&gt;. Timestamps will use &lt;code&gt;Erlang monotonic time&lt;/code&gt;. The time-stamp has the same format and value as produced by &lt;code&gt;erlang:monotonic_time(nanosecond)&lt;/code&gt;.</source>
          <target state="translated">각 추적 이벤트에 대해 엄격한 단조 시간 소인을 생성 / 비활성화하는 추적 토큰 플래그 ( &lt;code&gt;true | false&lt;/code&gt; ). 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. 타임 스탬프는 &lt;code&gt;Erlang monotonic time&lt;/code&gt; 합니다. 타임 스탬프는 &lt;code&gt;erlang:monotonic_time(nanosecond)&lt;/code&gt; 의해 생성 된 것과 동일한 형식과 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="82d8ecb25fb90aa7ddd424dd220b83a7b34ebd81" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables a timestamp to be generated for each traced event. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">각 추적 이벤트에 대해 타임 스탬프를 생성 / 비활성화하는 추적 토큰 플래그 ( &lt;code&gt;true | false&lt;/code&gt; )입니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c3e634022f908badf152e1987898bd0b2c230015" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on explicit calls to &lt;code&gt;seq_trace:print/1&lt;/code&gt;. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;seq_trace:print/1&lt;/code&gt; 에 대한 명시 적 호출에서 추적을 활성화 / 비활성화 하는 추적 토큰 플래그 ( &lt;code&gt;true | false&lt;/code&gt; )입니다 . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f928f7c9e2d7e89a32e5aa2b16d563a9022c4418" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on information reception. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">정보 수신에 대한 추적을 활성화 / 비활성화 하는 추적 토큰 플래그 ( &lt;code&gt;true | false&lt;/code&gt; ). 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="44f03f78eba803fb7a7f1c41468a0fa1580e2a31" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on information sending. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">정보 전송에 대한 추적을 활성화 / 비활성화 하는 추적 토큰 플래그 ( &lt;code&gt;true | false&lt;/code&gt; ). 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bde9aedc5e9c949b0aa2b17f37ee8c40d03b21b6" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on message reception. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">메시지 수신시 추적을 활성화 / 비활성화 하는 추적 토큰 플래그 ( &lt;code&gt;true | false&lt;/code&gt; ). 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d9c367670f41b59db0e6ecd2630bb172d3da0c69" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on message sending. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">메시지 전송에 대한 추적을 활성화 / 비활성화 하는 추적 토큰 플래그 ( &lt;code&gt;true | false&lt;/code&gt; ). 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bb16a1ee7cb5dc148d050fd7c6dc758d85f029eb" translate="yes" xml:space="preserve">
          <source>A traditional 3-tuple of integers seed is passed through algorithm-dependent hashing functions to create the generator's initial state.</source>
          <target state="translated">기존의 3 튜플 정수 시드는 알고리즘 종속 해싱 함수를 통해 전달되어 생성기의 초기 상태를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="fef110e2f0ab9e0376d172bcb7bfe8b65a404cd6" translate="yes" xml:space="preserve">
          <source>A transaction system makes it possible to execute two or more processes concurrently that manipulate the same record. The programmer does not need to check that the updates are synchronous; this is overseen by the transaction handler. All programs accessing the database through the transaction system can be written as if they had sole access to the data.</source>
          <target state="translated">트랜잭션 시스템을 사용하면 동일한 레코드를 조작하는 둘 이상의 프로세스를 동시에 실행할 수 있습니다. 프로그래머는 업데이트가 동기 적인지 확인할 필요가 없습니다. 이것은 트랜잭션 핸들러가 감독합니다. 트랜잭션 시스템을 통해 데이터베이스에 액세스하는 모든 프로그램은 마치 데이터에 단독으로 액세스하는 것처럼 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="040494e8706d570977340364653c32d0f74758d8" translate="yes" xml:space="preserve">
          <source>A transport can both override its service's capabilities and restrict its supported Diameter applications so &quot;service = Diameter node as identified by Origin-Host&quot; is not necessarily the case.</source>
          <target state="translated">트랜스 포트는 서비스 기능을 재정의하고 지원되는 직경 애플리케이션을 제한 할 수 있으므로 &quot;서비스 = Origin-Host로 식별 된 직경 노드&quot;가 반드시 그런 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="023338b0c93aa9ea43a308354e8c6cb312d2e262" translate="yes" xml:space="preserve">
          <source>A transport process can expect messages of the following types from its parent.</source>
          <target state="translated">전송 프로세스는 상위에서 다음 유형의 메시지를 예상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c02ea719b68545a61ef8005dfcb9fa67f5f85090" translate="yes" xml:space="preserve">
          <source>A transport process must implement the message interface documented below. It should retain the pid of its parent, monitor the parent and terminate if it dies. It should not link to the parent. It should exit if its transport connection with its peer is lost.</source>
          <target state="translated">전송 프로세스는 아래에 설명 된 메시지 인터페이스를 구현해야합니다. 부모의 pid를 유지하고 부모를 모니터링하고 죽으면 종료해야합니다. 부모에게 연결해서는 안됩니다. 피어와의 전송 연결이 끊어지면 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="22cab074839dd6633c044492cf9e00d79ad7b9b9" translate="yes" xml:space="preserve">
          <source>A transport process should send messages of the following types to its parent.</source>
          <target state="translated">전송 프로세스는 다음 유형의 메시지를 부모에게 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="90161712010dfd82bbaf6035b7ca236a047b2d07" translate="yes" xml:space="preserve">
          <source>A trigger action. When a breakpoint is reached, the trigger action specifies if the breakpoint is to continue as active (&lt;strong&gt;enable&lt;/strong&gt;), or to become inactive (&lt;strong&gt;disable&lt;/strong&gt;), or to be removed (&lt;strong&gt;delete&lt;/strong&gt;).</source>
          <target state="translated">방아쇠 행동. 중단 점에 도달하면 트리거 조치는 중단 점이 활성으로 계속되는지 ( &lt;strong&gt;enable&lt;/strong&gt; ) 또는 비활성 상태 가되는지 ( &lt;strong&gt;disable&lt;/strong&gt; ) 또는 제거 되는지 ( &lt;strong&gt;delete&lt;/strong&gt; )를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f841f79d498699c727c107e3b0ca4c79fda4714f" translate="yes" xml:space="preserve">
          <source>A true embedded system must start when the system boots. This section accounts for the necessary configurations needed to achieve that.</source>
          <target state="translated">시스템이 부팅 될 때 진정한 임베디드 시스템이 시작되어야합니다. 이 섹션에서는이를 달성하는 데 필요한 구성을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1e80ac87b4ba604d5c15b3ca4c06f00704683ae7" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{HashAlgoSpec, accept_callback}&lt;/code&gt;. The &lt;code&gt;HashAlgoSpec&lt;/code&gt; specifies which hash algorithm shall be used to calculate the fingerprint used in the call of the &lt;code&gt;accept_callback()&lt;/code&gt;. The &lt;code&gt;HashALgoSpec&lt;/code&gt; is either an atom or a list of atoms as the first argument in &lt;code&gt;public_key:ssh_hostkey_fingerprint/2&lt;/code&gt;. If it is a list of hash algorithm names, the &lt;code&gt;FingerPrint&lt;/code&gt; argument in the &lt;code&gt;accept_callback()&lt;/code&gt; will be a list of fingerprints in the same order as the corresponding name in the &lt;code&gt;HashAlgoSpec&lt;/code&gt; list.</source>
          <target state="translated">튜플 &lt;code&gt;{HashAlgoSpec, accept_callback}&lt;/code&gt; . &lt;code&gt;HashAlgoSpec&lt;/code&gt; 의 지문을 계산하는 데 사용되어야한다 해시 알고리즘의 지정이 호출에 사용 &lt;code&gt;accept_callback()&lt;/code&gt; . &lt;code&gt;HashALgoSpec&lt;/code&gt; 는 원자 또는 제 인수 원자들의 목록이다 &lt;code&gt;public_key:ssh_hostkey_fingerprint/2&lt;/code&gt; . 해시 알고리즘 이름 목록 인 경우 &lt;code&gt;accept_callback()&lt;/code&gt; 의 &lt;code&gt;FingerPrint&lt;/code&gt; 인수 는 &lt;code&gt;HashAlgoSpec&lt;/code&gt; 목록 의 해당 이름과 동일한 순서로 지문 목록이됩니다.</target>
        </trans-unit>
        <trans-unit id="cf7e5e9de3bf6f4c7060bdc6cec37d2c3b2e6d0c" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{Major,Minor}&lt;/code&gt; containing the major and minor version of the file format for ETS table dumps. This version field was added beginning with STDLIB 1.5.1. Files dumped with older versions return &lt;code&gt;{0,0}&lt;/code&gt; in this field.</source>
          <target state="translated">ETS 테이블 덤프에 대한 파일 형식의 주 버전과 부 버전을 포함 하는 튜플 &lt;code&gt;{Major,Minor}&lt;/code&gt; . 이 버전 필드는 STDLIB 1.5.1부터 추가되었습니다. 이전 버전으로 덤프 된 파일 은이 필드에서 &lt;code&gt;{0,0}&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="07bab1189c6299dfc8d87b9698a9d20069024cab" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; for function calls</source>
          <target state="translated">함수 호출을위한 튜플 &lt;code&gt;{Module, Function, Arity}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85c425ef8b5c09edd293415683557a467b94cc4b" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{registered_name,node_name}&lt;/code&gt; is used instead of just the &lt;code&gt;registered_name&lt;/code&gt;.</source>
          <target state="translated">튜플 &lt;code&gt;{registered_name,node_name}&lt;/code&gt; 대신 상대의 사용 &lt;code&gt;registered_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f3f0f1a112bc371fc9fac3b642164488b8dd6fb" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{test, ModuleName, FunctionName}&lt;/code&gt;, where &lt;code&gt;ModuleName&lt;/code&gt; and &lt;code&gt;FunctionName&lt;/code&gt; are atoms, referring to the function &lt;code&gt;ModuleName:FunctionName/0&lt;/code&gt;</source>
          <target state="translated">튜플 &lt;code&gt;{test, ModuleName, FunctionName}&lt;/code&gt; (여기서 &lt;code&gt;ModuleName&lt;/code&gt; 및 &lt;code&gt;FunctionName&lt;/code&gt; 은 원 자임) , &lt;code&gt;ModuleName:FunctionName/0&lt;/code&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7faaaea4addaa524ef387ae744a4927d4b84f230" translate="yes" xml:space="preserve">
          <source>A tuple is a compound data type with a fixed number of terms:</source>
          <target state="translated">튜플은 고정 된 수의 항을 갖는 복합 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="df982bb074bb2bcc07a3f3574312720f45bcca1f" translate="yes" xml:space="preserve">
          <source>A tuple must be specified with the number of elements. (The elements precede the &lt;code&gt;ERL_DRV_TUPLE&lt;/code&gt; term.)</source>
          <target state="translated">튜플은 요소 수와 함께 지정해야합니다. (요소는 &lt;code&gt;ERL_DRV_TUPLE&lt;/code&gt; 용어 앞에옵니다 .)</target>
        </trans-unit>
        <trans-unit id="694f68c6889d3f88be664ff0fedc1704129e38dd" translate="yes" xml:space="preserve">
          <source>A tuple of a size equal to &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt; erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; is returned. The tuple elements are integers or the atom &lt;code&gt;unbound&lt;/code&gt;. Logical processor identifiers are represented as integers. The &lt;code&gt;N&lt;/code&gt;th element of the tuple equals the current binding for the scheduler with the scheduler identifier equal to &lt;code&gt;N&lt;/code&gt;. For example, if the schedulers are bound, &lt;code&gt;element(erlang:system_info(scheduler_id), erlang:system_info(scheduler_bindings))&lt;/code&gt; returns the identifier of the logical processor that the calling process is executing on.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt; erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; 와 같은 크기의 튜플 이 반환됩니다. 튜플 요소는 정수 또는 &lt;code&gt;unbound&lt;/code&gt; 원자 입니다. 논리 프로세서 식별자는 정수로 표시됩니다. 튜플 의 &lt;code&gt;N&lt;/code&gt; 번째 요소는 스케줄러 식별자가 &lt;code&gt;N&lt;/code&gt; 인 스케줄러의 현재 바인딩과 같습니다 . 예를 들어, 스케줄러가 바인딩 된 경우 &lt;code&gt;element(erlang:system_info(scheduler_id), erlang:system_info(scheduler_bindings))&lt;/code&gt; 는 호출 프로세스가 실행중인 논리 프로세서의 식별자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d813ebdb5f103f06a944c56ba2c1950a8ea79499" translate="yes" xml:space="preserve">
          <source>A tuple of a size equal to &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; is returned. The tuple elements are integers or the atom &lt;code&gt;unbound&lt;/code&gt;. Logical processor identifiers are represented as integers. The &lt;code&gt;N&lt;/code&gt;th element of the tuple equals the current binding for the scheduler with the scheduler identifier equal to &lt;code&gt;N&lt;/code&gt;. For example, if the schedulers are bound, &lt;code&gt;element(erlang:system_info(scheduler_id), erlang:system_info(scheduler_bindings))&lt;/code&gt; returns the identifier of the logical processor that the calling process is executing on.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; 동일한 크기의 튜플 이 반환됩니다. 튜플 요소는 정수 또는 원자 &lt;code&gt;unbound&lt;/code&gt; 입니다. 논리 프로세서 식별자는 정수로 표시됩니다. 튜플 의 &lt;code&gt;N&lt;/code&gt; 번째 요소는 스케줄러 식별자가 &lt;code&gt;N&lt;/code&gt; 인 스케줄러의 현재 바인딩과 같습니다 . 예를 들어 스케줄러가 바인딩 된 경우 &lt;code&gt;element(erlang:system_info(scheduler_id), erlang:system_info(scheduler_bindings))&lt;/code&gt; 는 호출 프로세스가 실행중인 논리 프로세서의 식별자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="810d5b526b8906970f984c1b3db62a6c47f80147" translate="yes" xml:space="preserve">
          <source>A tuple of size three containing: the segment number, the &lt;code&gt;last segment indicator&lt;/code&gt; and finally a list of 'ActionReply' records possibly containing error indications. This is of course only possible if the reply was segmented.</source>
          <target state="translated">크기 3의 튜플 : 세그먼트 번호, &lt;code&gt;last segment indicator&lt;/code&gt; 및 마지막으로 오류 표시를 포함 할 수있는 'ActionReply'레코드 목록. 이것은 물론 답장이 분할 된 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3dd7bc1a3405fbef606b572d8949507a33cc4df9" translate="yes" xml:space="preserve">
          <source>A tuple of the bindings and a continuation is returned, unless the table is empty, in which case &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. The continuation is to be used when matching further objects by calling &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테이블이 비어 있지 않으면 바인딩의 튜플과 연속이 반환됩니다.이 경우 &lt;code&gt;'$end_of_table'&lt;/code&gt; 이 반환됩니다. &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; 을 호출하여 추가 객체를 일치시킬 때 연속이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6c722068339f5605671934079ecb1e3f17e82123" translate="yes" xml:space="preserve">
          <source>A tuple of the results of applying the match specification and a continuation is returned, unless the table is empty, in which case &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. The continuation is to be used when matching more objects by calling &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테이블이 비어 있지 않으면 일치 스펙 및 연속을 적용한 결과의 튜플이 리턴 &lt;code&gt;'$end_of_table'&lt;/code&gt; 경우 '$ end_of_table' 이 리턴됩니다. 연속체는 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 을 호출 하여 더 많은 객체를 일치시킬 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="24035af62a2fdeb2d8901fd0ee530961ccde951f" translate="yes" xml:space="preserve">
          <source>A tuple passed using the external format of Erlang.</source>
          <target state="translated">튜플은 외부 형식의 Erlang을 사용하여 전달되었습니다.</target>
        </trans-unit>
        <trans-unit id="8690cf67b400404bcc0f4ff1dceb7bb83944c22f" translate="yes" xml:space="preserve">
          <source>A tuple where the elements are of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">요소가 &lt;code&gt;T&lt;/code&gt; 형인 튜플 .</target>
        </trans-unit>
        <trans-unit id="b4c3a805c0c5a81f38e677fa3cd9def6b983c21d" translate="yes" xml:space="preserve">
          <source>A tuple with the string and the options for compilation</source>
          <target state="translated">문자열과 컴파일 옵션이있는 튜플</target>
        </trans-unit>
        <trans-unit id="151bd15a2cb84f42df927246cfbe8c0dd7313819" translate="yes" xml:space="preserve">
          <source>A type specifier list TSL for a bitstring element is a sequence of type specifiers &lt;code&gt;TS_1 - ... - TS_k&lt;/code&gt;, and Rep(TSL) = &lt;code&gt;[Rep(TS_1), ..., Rep(TS_k)]&lt;/code&gt;.</source>
          <target state="translated">비트 열 요소의 형식 지정자 목록 TSL은 형식 지정자 &lt;code&gt;TS_1 - ... - TS_k&lt;/code&gt; 및 Rep (TSL) = &lt;code&gt;[Rep(TS_1), ..., Rep(TS_k)]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="08976fc5cbfe03343391c63ca50f5f50c10b8d0b" translate="yes" xml:space="preserve">
          <source>A typical (compress) usage is as follows:</source>
          <target state="translated">일반적인 (압축) 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="126a0170061e6a79a71ccf9406ef6f3af55349d4" translate="yes" xml:space="preserve">
          <source>A typical &lt;code&gt;.erlang&lt;/code&gt; file contains a set of search paths, for example:</source>
          <target state="translated">일반적인 &lt;code&gt;.erlang&lt;/code&gt; 파일에는 다음과 같은 검색 경로 세트가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="72082aa56cd4d1e59057d7f28996bf925833376c" translate="yes" xml:space="preserve">
          <source>A typical &lt;code&gt;Common Test&lt;/code&gt; test suite using &lt;code&gt;ct_property_test&lt;/code&gt; is organized as follows:</source>
          <target state="translated">&lt;code&gt;ct_property_test&lt;/code&gt; 를 사용 하는 일반적인 &lt;code&gt;Common Test&lt;/code&gt; 테스트 스위트 는 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6ef96d247bf0039ba1ccb9fddcabd0176ac0a0c3" translate="yes" xml:space="preserve">
          <source>A typical error reason is:</source>
          <target state="translated">일반적인 오류 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="05d8d9f5d6888b35439d18b6e544520b23957a25" translate="yes" xml:space="preserve">
          <source>A typical error reason:</source>
          <target state="translated">일반적인 오류 이유 :</target>
        </trans-unit>
        <trans-unit id="9061494e205704eb0cdfcf7a4c046c23d96666b9" translate="yes" xml:space="preserve">
          <source>A typical implementation on Unix is to do &lt;code&gt;close((int)event)&lt;/code&gt;.</source>
          <target state="translated">유닉스에서 일반적인 구현은 &lt;code&gt;close((int)event)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="541396ef46ffec4bf5fa435c55b2863004f29300" translate="yes" xml:space="preserve">
          <source>A typical operation could include the following steps:</source>
          <target state="translated">일반적인 작업에는 다음 단계가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="50f89c2180f830349252137c0faf845e512001e7" translate="yes" xml:space="preserve">
          <source>A typical overload situation occurs when the applications perform more updates on disc resident tables than &lt;code&gt;Mnesia&lt;/code&gt; can handle. Ignoring this kind of overload can lead to a situation where the disc space is exhausted (regardless of the size of the tables stored on disc).</source>
          <target state="translated">응용 프로그램이 디스크 상주 테이블에서 &lt;code&gt;Mnesia&lt;/code&gt; 가 처리 할 수있는 것보다 많은 업데이트를 수행 할 때 일반적인 과부하 상황이 발생합니다 . 이러한 종류의 과부하를 무시하면 디스크에 저장된 테이블 크기에 관계없이 디스크 공간이 부족한 상황이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acb703e9dec014081d4b1835cb51aaeb3d0b76b2" translate="yes" xml:space="preserve">
          <source>A typical use of this function is to replace unbounded-size control sequences like &lt;code&gt;~w&lt;/code&gt; and &lt;code&gt;~p&lt;/code&gt; with the depth-limited variants &lt;code&gt;~W&lt;/code&gt; and &lt;code&gt;~P&lt;/code&gt; before formatting to text in, for example, a logger.</source>
          <target state="translated">이 기능은 일반적 으로 로거와 같이 텍스트로 포맷하기 전에 &lt;code&gt;~w&lt;/code&gt; 및 &lt;code&gt;~p&lt;/code&gt; 와 같은 무한 크기 제어 시퀀스를 깊이 제한 변형 인 &lt;code&gt;~W&lt;/code&gt; 및 &lt;code&gt;~P&lt;/code&gt; 로 바꾸는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3807873b97b8b82278afb2ef76e8ea8f9bb29594" translate="yes" xml:space="preserve">
          <source>A unique identifier for a filter.</source>
          <target state="translated">필터의 고유 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="aeb6160c71f6b3c49b7dc45e065a90d43611f9a7" translate="yes" xml:space="preserve">
          <source>A unique identifier for a handler instance.</source>
          <target state="translated">핸들러 인스턴스의 고유 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="35c6d039fac0be1661199d1ae0d64a6d99224787" translate="yes" xml:space="preserve">
          <source>A useful dispatch function that can be used from client functions. It returns a process on the local node, if such a process exists. Otherwise, it selects one randomly.</source>
          <target state="translated">클라이언트 함수에서 사용할 수있는 유용한 디스패치 함수입니다. 프로세스가 존재하는 경우 로컬 노드에서 프로세스를 리턴합니다. 그렇지 않으면 무작위로 하나를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="f5bfc38acae2f40bfaee12c264aaf4416d8847f9" translate="yes" xml:space="preserve">
          <source>A useful number.</source>
          <target state="translated">유용한 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="5f280d2fcfe90c0ab1a22509cb3602587fb270ec" translate="yes" xml:space="preserve">
          <source>A useful way of looking at parts of lists, is by using &quot;|&quot;. This is best explained by an example using the shell:</source>
          <target state="translated">목록의 일부를 보는 유용한 방법은 &quot;|&quot;를 사용하는 것입니다. 이것은 쉘을 사용한 예제로 가장 잘 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="14fd4e6872c372a6c8cb217dbc2352699bd53754" translate="yes" xml:space="preserve">
          <source>A user defined identity representing this notification send operation.</source>
          <target state="translated">이 알림 전송 작업을 나타내는 사용자 정의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="2a353ec2b424bd07df4385f13b10e3ea7d64ca54" translate="yes" xml:space="preserve">
          <source>A user is being blocked from access.</source>
          <target state="translated">사용자의 액세스가 차단되었습니다.</target>
        </trans-unit>
        <trans-unit id="0c5079fbb762cb2270895845abfb45816e3f4e3e" translate="yes" xml:space="preserve">
          <source>A user is being removed from the block list.</source>
          <target state="translated">차단 목록에서 사용자가 제거되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="101ba63129c1dab0968eb1083541b31cda478b02" translate="yes" xml:space="preserve">
          <source>A user is identified by its UserMid, which must be a legal Megaco MID.</source>
          <target state="translated">사용자는 유효한 Megaco MID 여야하는 UserMid로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="fd3a9f3997e885cf7dcc7677ac20d4c9631d90cc" translate="yes" xml:space="preserve">
          <source>A user may either be statically configured in a .config file according to the application concept of Erlang/OTP or dynamically started with the configuration settings as arguments to megaco:start_user/2. These configuration settings may be updated later on with megaco:update_conn_info/2.</source>
          <target state="translated">사용자는 Erlang / OTP의 애플리케이션 개념에 따라 .config 파일에서 정적으로 구성되거나 megaco : start_user / 2에 대한 인수로 구성 설정으로 동적으로 시작될 수 있습니다. 이러한 구성 설정은 나중에 megaco : update_conn_info / 2로 업데이트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1504430f3d4afc3f6c812eb47a15e10f01419f56" translate="yes" xml:space="preserve">
          <source>A user may have a number of &quot;virtual&quot; connections to other users. An MG is connected to at most one MGC, while an MGC may be connected to any number of MG's. For each connection the user selects a transport service, an encoding scheme and a user callback module.</source>
          <target state="translated">사용자는 다른 사용자와 다수의 &quot;가상&quot;연결을 가질 수 있습니다. MG는 최대 하나의 MGC에 연결되는 반면 MGC는 여러 개의 MG에 연결될 수 있습니다. 각 연결에 대해 사용자는 전송 서비스, 인코딩 체계 및 사용자 콜백 모듈을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="e67f458b7905dc65a23e9c34758bfcdd553eff54" translate="yes" xml:space="preserve">
          <source>A user process can subscribe on the events generated by &lt;code&gt;Mnesia&lt;/code&gt;. The following two functions are provided:</source>
          <target state="translated">사용자 프로세스는 &lt;code&gt;Mnesia&lt;/code&gt; 가 생성 한 이벤트를 구독 할 수 있습니다 . 다음 두 가지 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a930c1684ddd9a6efd75c38df17f190cbc0c2e7d" translate="yes" xml:space="preserve">
          <source>A user variable is employed for holding the &lt;code&gt;digraph&lt;/code&gt; representation of the function graph for use in many queries. The reason is efficiency. As opposed to the &lt;code&gt;=&lt;/code&gt; operator, the &lt;code&gt;:=&lt;/code&gt; operator saves a value for subsequent analyses. Here might be the place to note that equal subexpressions within a query are evaluated only once; &lt;code&gt;=&lt;/code&gt; cannot be used for speeding things up.</source>
          <target state="translated">많은 쿼리에서 사용하기 위해 함수 그래프 의 &lt;code&gt;digraph&lt;/code&gt; 표현 을 보유하기 위해 사용자 변수가 사용됩니다 . 그 이유는 효율성입니다. 받는 반대로 &lt;code&gt;=&lt;/code&gt; 연산자는 &lt;code&gt;:=&lt;/code&gt; 연산자는 후속 분석에 대한 값을 저장한다. 쿼리 내에서 동일한 하위 표현식이 한 번만 평가된다는 점에 주목할 수 있습니다. &lt;code&gt;=&lt;/code&gt; 속도를 높이는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5dca3db2b5e814aa2f8b6c5ddad967e0eb6d4fd1" translate="yes" xml:space="preserve">
          <source>A user-defined instrumentation function for each object attaches the managed objects to real resources. This function is called by the agent on a &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; operation. The function could read some hardware register, perform a calculation, or whatever is necessary to implement the semantics associated with the conceptual variable. These functions must be written both for scalar variables and for tables. They are specified in the association file, which is a text file. In this file, the &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt;, or symbolic name for each managed object, is associated with an Erlang tuple &lt;code&gt;{Module,&lt;/code&gt;&lt;code&gt;Function&lt;/code&gt;, &lt;code&gt;ListOfExtraArguments}&lt;/code&gt;.</source>
          <target state="translated">각 객체에 대한 사용자 정의 계측 기능은 관리 객체를 실제 리소스에 연결합니다. 이 기능은 에이전트가 &lt;code&gt;get&lt;/code&gt; 또는 &lt;code&gt;set&lt;/code&gt; 조작 에서 호출 합니다. 이 함수는 일부 하드웨어 레지스터를 읽거나 계산을 수행하거나 개념적 변수와 관련된 의미를 구현하는 데 필요한 모든 것을 수행 할 수 있습니다. 이 함수는 스칼라 변수와 테이블 모두에 대해 작성해야합니다. 텍스트 파일 인 연관 파일에 지정됩니다. 이 파일에서 &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 또는 각 관리 오브젝트의 기호 이름은 Erlang 튜플 &lt;code&gt;{Module,&lt;/code&gt; &lt;code&gt;Function&lt;/code&gt; , &lt;code&gt;ListOfExtraArguments}&lt;/code&gt; 와 연관됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c4272ec5ada9781d28edc9d23bde5292b08de6e" translate="yes" xml:space="preserve">
          <source>A user-defined parameter passed from the function &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt;. It is used in the return value of &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; 함수에서 전달 된 사용자 정의 매개 변수 입니다. &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1,2&lt;/a&gt;&lt;/code&gt; 의 반환 값에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ab19e68c658754f6d616e8a9359af12c979f8b2d" translate="yes" xml:space="preserve">
          <source>A user-perceived character, consisting of one or more codepoints.</source>
          <target state="translated">하나 이상의 코드 포인트로 구성된 사용자 인식 문자입니다.</target>
        </trans-unit>
        <trans-unit id="b6da77940e722515281bb6aabce021b2bbcff9af" translate="yes" xml:space="preserve">
          <source>A valid chain must have at least a ROOT and a peer cert. The root cert can be given either as a cert pre-generated by &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt; pkix_test_root_cert/2 &lt;/a&gt;&lt;/code&gt;, or as root cert generation options.    A root certificate generated by &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt; pkix_test_root_cert/2 &lt;/a&gt;&lt;/code&gt;.   For available options see &lt;code&gt;&lt;a href=&quot;#cert_opt&quot;&gt; cert_opt()&lt;/a&gt;&lt;/code&gt; below.    This is a subset of the type &lt;code&gt; ssl:tls_option()&lt;/code&gt;. &lt;code&gt;PrivateKey&lt;/code&gt; is what &lt;code&gt;&lt;a href=&quot;#generate_key-1&quot;&gt;generate_key/1&lt;/a&gt;&lt;/code&gt; returns.</source>
          <target state="translated">유효한 체인에는 최소한 ROOT와 피어 인증서가 있어야합니다. 루트 인증서는 &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt; pkix_test_root_cert/2 &lt;/a&gt;&lt;/code&gt; 에 의해 사전 생성 된 인증서 또는 루트 인증서 생성 옵션으로 제공 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt; pkix_test_root_cert/2 &lt;/a&gt;&lt;/code&gt; 에 의해 생성 된 루트 인증서 . 사용 가능한 옵션은 아래의 &lt;code&gt;&lt;a href=&quot;#cert_opt&quot;&gt; cert_opt()&lt;/a&gt;&lt;/code&gt; 참조하십시오. 이것은 &lt;code&gt; ssl:tls_option()&lt;/code&gt; 유형의 하위 집합입니다 . &lt;code&gt;PrivateKey&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#generate_key-1&quot;&gt;generate_key/1&lt;/a&gt;&lt;/code&gt; 이 반환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8c487c4839c1da9e5bc76ca352a5448a09547f8c" translate="yes" xml:space="preserve">
          <source>A valid chain must have at least a ROOT and a peer cert. The root cert can be given either as a cert pre-generated by &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt;, or as root cert generation options.    A root certificate generated by &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt;.   For available options see &lt;code&gt;&lt;a href=&quot;#cert_opt&quot;&gt;cert_opt()&lt;/a&gt;&lt;/code&gt; below.    This is a subset of the type &lt;code&gt;ssl:ssl_option()&lt;/code&gt;. &lt;code&gt;PrivateKey&lt;/code&gt; is what &lt;code&gt;&lt;a href=&quot;#generate_key-1&quot;&gt;generate_key/1&lt;/a&gt;&lt;/code&gt; returns.</source>
          <target state="translated">유효한 체인에는 최소한 ROOT와 피어 인증서가 있어야합니다. 루트 인증서는 &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt; 에 의해 미리 생성 된 인증서 또는 루트 인증서 생성 옵션으로 제공 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt; 에 의해 생성 된 루트 인증서 . 사용 가능한 옵션은 아래 &lt;code&gt;&lt;a href=&quot;#cert_opt&quot;&gt;cert_opt()&lt;/a&gt;&lt;/code&gt; 참조하십시오. 이것은 &lt;code&gt;ssl:ssl_option()&lt;/code&gt; 유형의 서브 세트입니다 . &lt;code&gt;PrivateKey&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#generate_key-1&quot;&gt;generate_key/1&lt;/a&gt;&lt;/code&gt; 이 리턴하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d8b7f3becec263c2ea738b6691bf529e9d0210ac" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;!= 0&lt;/code&gt; if the runtime system has SMP support; otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">런타임 시스템이 SMP를 지원하는 경우 값은 &lt;code&gt;!= 0&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6ac91e865bee333c1075b80d53873b9d3418a7c3" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;!= 0&lt;/code&gt; if the runtime system has support for dirty scheduler threads; otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">런타임 시스템이 더티 스케줄러 스레드를 지원하는 경우 값은 &lt;code&gt;!= 0&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7ec437d87d8ab2a59f963ce8195782385431267f" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;!= 0&lt;/code&gt; if the runtime system has thread support; otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">런타임 시스템에 스레드 지원이있는 경우 값은 &lt;code&gt;!= 0&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d4ba959b8daba0b753bc8f2d86eb3f9db8c6578e" translate="yes" xml:space="preserve">
          <source>A value in the &lt;code&gt;msg&lt;/code&gt; field does &lt;strong&gt;not&lt;/strong&gt; imply an absence of decode errors. The &lt;code&gt;errors&lt;/code&gt; field should also be examined.</source>
          <target state="translated">&lt;code&gt;msg&lt;/code&gt; 필드 의 값 이 디코드 오류 가 &lt;strong&gt;없음을&lt;/strong&gt; 의미하지는 &lt;strong&gt;않습니다&lt;/strong&gt; . &lt;code&gt;errors&lt;/code&gt; 필드도 검토되어야한다.</target>
        </trans-unit>
        <trans-unit id="24b9fc9ee791392b2ee5f6e020d0a3fa901804d7" translate="yes" xml:space="preserve">
          <source>A value must be provided for all variables, which lack default values in the MIB.</source>
          <target state="translated">MIB에 기본값이없는 모든 변수에 값을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="c6977869e984d6fd810d1cba7c1d446b28da9624" translate="yes" xml:space="preserve">
          <source>A value must have length at least 1.</source>
          <target state="translated">값의 길이는 1 이상이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5445236ba06b6cb9e9bcd38ff5b377fb1c4caffb" translate="yes" xml:space="preserve">
          <source>A value of this type is encoded as an &lt;code&gt;open type&lt;/code&gt;.</source>
          <target state="translated">이 유형의 값은 &lt;code&gt;open type&lt;/code&gt; 인코딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="c03ee0717973a910f7c750d1a0679fb27eb9cdb9" translate="yes" xml:space="preserve">
          <source>A variable cannot be assigned a new value unless first removed. Variables assigned to by the &lt;code&gt;=&lt;/code&gt; operator are removed at the end of the query, while variables assigned to by the &lt;code&gt;:=&lt;/code&gt; operator can only be removed by calls to &lt;code&gt;forget&lt;/code&gt;. There are no user variables when module data need to be set up again; if any of the functions that make it necessary to set up module data again is called, all user variables are forgotten.</source>
          <target state="translated">변수를 먼저 제거하지 않으면 새 값을 할당 할 수 없습니다. &lt;code&gt;=&lt;/code&gt; 연산자 에 의해 할당 된 변수 는 쿼리 끝에서 제거되는 반면 &lt;code&gt;:=&lt;/code&gt; 연산자 에 의해 할당 된 변수 는 &lt;code&gt;forget&lt;/code&gt; 호출로만 제거 할 수 있습니다 . 모듈 데이터를 다시 설정해야 할 때 사용자 변수가 없습니다. 모듈 데이터를 다시 설정하는 데 필요한 기능이 호출되면 모든 사용자 변수를 잊어 버립니다.</target>
        </trans-unit>
        <trans-unit id="cebe1918886957c15927cc44d43277357c762515" translate="yes" xml:space="preserve">
          <source>A variable definition binds a variable to a Perl variable. It is only meaningful to add a new definition if &lt;strong&gt;beam_makeops&lt;/strong&gt; is updated at the same time to use the variable. A variable definition looks this:</source>
          <target state="translated">변수 정의는 변수를 Perl 변수에 바인딩합니다. 변수를 사용하기 위해 &lt;strong&gt;beam_makeops&lt;/strong&gt; 가 동시에 업데이트되는 경우 새 정의를 추가하는 것이 의미가 있습니다 . 변수 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5646fa290bab26490d3e95c3eda24f90bfb3cb85" translate="yes" xml:space="preserve">
          <source>A variable is an expression. If a variable is bound to a value, the return value is this value. Unbound variables are only allowed in patterns.</source>
          <target state="translated">변수는 표현식입니다. 변수가 값에 바인드되면 리턴 값이이 값입니다. 언 바운드 변수는 패턴에서만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="ad98bc5cb949befd1ed83fe57c5fe19294f99fe2" translate="yes" xml:space="preserve">
          <source>A variable name that is not in the environment results in an error.</source>
          <target state="translated">환경에없는 변수 이름은 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="d4d78baa7493d760df88a559b3a2f6209c0e9bbb" translate="yes" xml:space="preserve">
          <source>A variant of this is to use a &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;Complex State&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;#One%20Event%20Handler&quot;&gt;One Event Handler&lt;/a&gt;&lt;/code&gt;. The state is then modeled with for example a tuple &lt;code&gt;{MainFSMState,SubFSMState}&lt;/code&gt;.</source>
          <target state="translated">이것의 변형은 사용하는 &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;Complex State&lt;/a&gt;&lt;/code&gt; 로 &lt;code&gt;&lt;a href=&quot;#One%20Event%20Handler&quot;&gt;One Event Handler&lt;/a&gt;&lt;/code&gt; . 그런 다음 상태는 예를 들어 튜플 &lt;code&gt;{MainFSMState,SubFSMState}&lt;/code&gt; 로 모델링됩니다 .</target>
        </trans-unit>
        <trans-unit id="bde8699f3ff9312f778d465383636d7d89e8acf7" translate="yes" xml:space="preserve">
          <source>A variant of this is to use a &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;complex state&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;#One%20State%20Callback&quot;&gt;&lt;strong&gt;one state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;. The state is then modeled with for example a tuple &lt;code&gt;{MainFSMState,SubFSMState}&lt;/code&gt;.</source>
          <target state="translated">이것의 변형은 &lt;code&gt;&lt;a href=&quot;#One%20State%20Callback&quot;&gt;&lt;strong&gt;one state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 과 함께 &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;complex state&lt;/a&gt;&lt;/code&gt; 를 사용하는 것 입니다. 그런 다음 상태는 예를 들어 튜플 &lt;code&gt;{MainFSMState,SubFSMState}&lt;/code&gt; 로 모델링됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d89b8938a6cae035d7fea046259542e22b9f6ee1" translate="yes" xml:space="preserve">
          <source>A web server can be configured to start when starting the &lt;code&gt;Inets&lt;/code&gt; application, or dynamically in runtime by calling the &lt;code&gt;Inets&lt;/code&gt; application API &lt;code&gt;inets:start(httpd, ServiceConfig)&lt;/code&gt; or &lt;code&gt;inets:start(httpd, ServiceConfig, How)&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;inets&quot;&gt;inets(3)&lt;/a&gt;&lt;/code&gt;. The configuration options, also called properties, are as follows:</source>
          <target state="translated">웹 서버는 &lt;code&gt;Inets&lt;/code&gt; 응용 프로그램 을 시작할 때 시작 하거나 &lt;code&gt;Inets&lt;/code&gt; 응용 프로그램 API &lt;code&gt;inets:start(httpd, ServiceConfig)&lt;/code&gt; 또는 &lt;code&gt;inets:start(httpd, ServiceConfig, How)&lt;/code&gt; 를 호출하여 런타임에 동적으로 시작되도록 구성 할 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;inets&quot;&gt;inets(3)&lt;/a&gt;&lt;/code&gt; 참조 ) . 속성이라고도하는 구성 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b7054606b43999cf69240d9ae96069173e833e99" translate="yes" xml:space="preserve">
          <source>A word boundary is a position in the subject string where the current character and the previous character do not both match \w or \W (that is, one matches \w and the other matches \W), or the start or end of the string if the first or last character matches \w, respectively. In UTF mode, the meanings of \w and \W can be changed by setting option &lt;code&gt;ucp&lt;/code&gt;. When this is done, it also affects \b and \B. PCRE and Perl do not have a separate &quot;start of word&quot; or &quot;end of word&quot; metasequence. However, whatever follows \b normally determines which it is. For example, the fragment \ba matches &quot;a&quot; at the start of a word.</source>
          <target state="translated">단어 경계는 제목 문자열에서 현재 문자와 이전 문자가 모두 \ w 또는 \ W와 일치하지 않거나 (즉, 하나는 \ w와 일치하고 다른 하나는 \ W와 일치), 또는 시작 또는 끝의 위치입니다. 첫 번째 또는 마지막 문자가 각각 \ w와 일치하면 문자열입니다. UTF 모드에서 옵션 &lt;code&gt;ucp&lt;/code&gt; 를 설정하여 \ w 및 \ W의 의미를 변경할 수 있습니다 . 이 작업이 완료되면 \ b 및 \ B에도 영향을줍니다. PCRE와 Perl에는 별도의 &quot;단어 시작&quot;또는 &quot;단어 끝&quot;메타 시퀀스가 ​​없습니다. 그러나 \ b 뒤에 오는 것은 일반적으로 그것이 무엇인지 결정합니다. 예를 들어, \ ba 조각은 단어의 시작 부분에서 &quot;a&quot;와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="62d9a28c75bb240da271eb7051702080009f9364" translate="yes" xml:space="preserve">
          <source>A wrap disk log file consists of many files, called index files. A log file can be opened and closed. Also, a single index file can be opened separately. If a non-existent or non-internally formatted file is opened, an error message is returned. If the file is corrupt, no attempt is made to repair it, but an error message is returned.</source>
          <target state="translated">랩 디스크 로그 파일은 인덱스 파일이라는 많은 파일로 구성됩니다. 로그 파일을 열고 닫을 수 있습니다. 또한 단일 인덱스 파일을 별도로 열 수 있습니다. 존재하지 않거나 내부 형식이 아닌 파일을 열면 오류 메시지가 반환됩니다. 파일이 손상되면 복구를 시도하지 않지만 오류 메시지가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0eb179692808865df9fddfd61d123acd14ceb6dd" translate="yes" xml:space="preserve">
          <source>A wrap files specification is used to limit the disk space consumed by the trace. The trace is written to a limited number of files each with a limited size. The actual filenames are &lt;code&gt;Filename ++ SeqCnt ++ Suffix&lt;/code&gt;, where &lt;code&gt;SeqCnt&lt;/code&gt; counts as a decimal string from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;WrapCnt&lt;/code&gt; and then around again from &lt;code&gt;0&lt;/code&gt;. When a trace term written to the current file makes it longer than &lt;code&gt;WrapSize&lt;/code&gt;, that file is closed, if the number of files in this wrap trace is as many as &lt;code&gt;WrapCnt&lt;/code&gt; the oldest file is deleted then a new file is opened to become the current. Thus, when a wrap trace has been stopped, there are at most &lt;code&gt;WrapCnt&lt;/code&gt; trace files saved with a size of at least &lt;code&gt;WrapSize&lt;/code&gt; (but not much bigger), except for the last file that might even be empty. The default values are &lt;code&gt;WrapSize = 128*1024&lt;/code&gt; and &lt;code&gt;WrapCnt = 8&lt;/code&gt;.</source>
          <target state="translated">랩 파일 스펙은 추적에 사용되는 디스크 공간을 제한하는 데 사용됩니다. 추적은 각각 크기가 제한된 제한된 수의 파일에 기록됩니다. 실제 파일 이름은 &lt;code&gt;Filename ++ SeqCnt ++ Suffix&lt;/code&gt; , 어디 &lt;code&gt;SeqCnt&lt;/code&gt; 의 에서 진수 문자열로 카운트를 &lt;code&gt;0&lt;/code&gt; 으로 &lt;code&gt;WrapCnt&lt;/code&gt; 다시 주위에서 다음과 &lt;code&gt;0&lt;/code&gt; . 현재 파일에 작성된 추적 용어가 &lt;code&gt;WrapSize&lt;/code&gt; 보다 길어지면 해당 파일이 닫힙니다.이 랩 추적의 파일 수가 가장 오래된 파일이 &lt;code&gt;WrapCnt&lt;/code&gt; 만큼 삭제되면 새 파일이 현재 파일로 열립니다. 따라서 랩 추적이 중지되면 최대 &lt;code&gt;WrapCnt&lt;/code&gt; 가 있습니다.비어있을 수도있는 마지막 파일을 제외하고 적어도 &lt;code&gt;WrapSize&lt;/code&gt; (그러나 더 크지 않은) 크기로 저장된 추적 파일 . 기본값은 &lt;code&gt;WrapSize = 128*1024&lt;/code&gt; 및 &lt;code&gt;WrapCnt = 8&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d6a037e42e51e318b55fc1948fa5a1661147cd7c" translate="yes" xml:space="preserve">
          <source>A wrapper function for &lt;code&gt;mnesia:create_table/2&lt;/code&gt;, which creates a table (if there is no existing table) with an appropriate set of &lt;code&gt;attributes&lt;/code&gt;. The attributes and &lt;code&gt;TabDef&lt;/code&gt; are forwarded to &lt;code&gt;mnesia:create_table/2&lt;/code&gt;. For example, if the table is to reside as &lt;code&gt;disc_only_copies&lt;/code&gt; on all nodes, a call looks as follows:</source>
          <target state="translated">&lt;code&gt;mnesia:create_table/2&lt;/code&gt; 에 대한 랩퍼 함수 . 적절한 &lt;code&gt;attributes&lt;/code&gt; 세트로 테이블을 작성합니다 (기존 테이블이없는 경우) . 속성과 &lt;code&gt;TabDef&lt;/code&gt; 는 &lt;code&gt;mnesia:create_table/2&lt;/code&gt; 로 전달됩니다 . 예를 들어, 테이블이 모든 노드에서 &lt;code&gt;disc_only_copies&lt;/code&gt; 로 상주 하는 경우 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="36b94a437ad5d966a2bc660ff3e1289bcc1b9fd7" translate="yes" xml:space="preserve">
          <source>A wrapper function for &lt;code&gt;mnesia:create_table/2&lt;/code&gt;, which creates a table (if there is no existing table) with an appropriate set of &lt;code&gt;attributes&lt;/code&gt;. The table only resides on the local node and its storage type is the same as the &lt;code&gt;schema&lt;/code&gt; table on the local node, that is, &lt;code&gt;{ram_copies,[node()]}&lt;/code&gt; or &lt;code&gt;{disc_copies,[node()]}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:create_table/2&lt;/code&gt; 에 대한 랩퍼 함수 . 적절한 &lt;code&gt;attributes&lt;/code&gt; 세트로 테이블을 작성합니다 (기존 테이블이없는 경우) . 테이블은 로컬 노드에만 상주하며 해당 스토리지 유형은 로컬 노드의 &lt;code&gt;schema&lt;/code&gt; 테이블 과 같습니다 ( 즉, &lt;code&gt;{ram_copies,[node()]}&lt;/code&gt; 또는 &lt;code&gt;{disc_copies,[node()]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fbfb3b2a70e7676f439e216ddfb41c8f42fcb5d" translate="yes" xml:space="preserve">
          <source>A write event was cancelled by &lt;code&gt;ERL_NIF_SELECT_CANCEL&lt;/code&gt; or &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; and is guaranteed not to generate a &lt;code&gt;ready_output&lt;/code&gt; notification message.</source>
          <target state="translated">쓰기 이벤트가 &lt;code&gt;ERL_NIF_SELECT_CANCEL&lt;/code&gt; 또는 &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; 에 의해 취소되었으며 &lt;code&gt;ready_output&lt;/code&gt; 알림 메시지 를 생성하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7bab14cb554b0f0419a6e027fa857770d1ae7636" translate="yes" xml:space="preserve">
          <source>A write operation on a &lt;code&gt;disc_copies&lt;/code&gt; table replica is performed in two steps. First the write operation is appended to a log file, then the actual operation is performed in RAM.</source>
          <target state="translated">&lt;code&gt;disc_copies&lt;/code&gt; 테이블 복제본 에 대한 쓰기 작업 은 두 단계로 수행됩니다. 먼저 쓰기 작업이 로그 파일에 추가 된 다음 실제 작업이 RAM에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="d9843d85d25b1bd741fdb98939b327e3138b2bfb" translate="yes" xml:space="preserve">
          <source>A zlib stream, see &lt;code&gt;&lt;a href=&quot;#open-0&quot;&gt;open/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ZLIB 스트림은 참조 &lt;code&gt;&lt;a href=&quot;#open-0&quot;&gt;open/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17afbf6d1d5b871c5ae0cee1ba18a4f7071dc38b" translate="yes" xml:space="preserve">
          <source>A: Cygwin, MSYS or MSYS2 is the environment, which closely resembles the environment found on any Unix machine. It's almost like you had a virtual Unix machine inside Windows. Configure, given certain parameters, then creates makefiles that are used by the environment's gnu-make to built the system. Most of the actual compilers etc are not, however, Cygwin/MSYS/MSYS2 tools, so we've written a couple of wrappers (Bourne-shell scripts), which reside in &lt;code&gt;$ERL_TOP/etc/win32/cygwin_tools&lt;/code&gt; and &lt;code&gt;$ERL_TOP/etc/win32/msys_tools&lt;/code&gt;. They all do conversion of parameters and switches common in the Unix environment to fit the native Windows tools. Most notable is of course the paths, which in Cygwin/MSYS/MSYS2 are Unix-like paths with &quot;forward slashes&quot; (/) and no drive letters. The Cygwin specific command &lt;code&gt;cygpath&lt;/code&gt; is used for most of the path conversions in a Cygwin environment. Other tools are used (when needed) in the corresponding MSYS and MSYS2 environment. Luckily most compilers accept forward slashes instead of backslashes as path separators, but one still have to get the drive letters etc right, though. The wrapper scripts are not general in the sense that, for example, cc.sh would understand and translate every possible gcc option and pass correct options to cl.exe. The principle is that the scripts are powerful enough to allow building of Erlang/OTP, no more, no less. They might need extensions to cope with changes during the development of Erlang, and that's one of the reasons we made them into shell-scripts and not Perl-scripts. We believe they are easier to understand and change that way.</source>
          <target state="translated">A : Cygwin, MSYS 또는 MSYS2는 Unix 머신에서 발견되는 환경과 매우 유사한 환경입니다. Windows에 가상 Unix 컴퓨터가있는 것과 거의 같습니다. 특정 매개 변수가 주어지면 환경의 gnu-make가 시스템을 빌드하는 데 사용하는 make 파일을 작성하십시오. 그러나 대부분의 실제 컴파일러는 Cygwin / MSYS / MSYS2 도구가 아니므로 &lt;code&gt;$ERL_TOP/etc/win32/cygwin_tools&lt;/code&gt; 및 &lt;code&gt;$ERL_TOP/etc/win32/msys_tools&lt;/code&gt; 있는 몇 개의 래퍼 (Bourne-shell 스크립트)를 작성했습니다. / win32 / msys_tools. 이들은 모두 기본 Windows 도구에 맞게 Unix 환경에서 공통적 인 매개 변수 및 스위치를 변환합니다. 물론 가장 주목할만한 경로는 Cygwin / MSYS / MSYS2에서 &quot;슬래시&quot;(/)가 있고 드라이브 문자가없는 Unix와 유사한 경로입니다. Cygwin 특정 명령 &lt;code&gt;cygpath&lt;/code&gt; Cygwin 환경에서 대부분의 경로 변환에 사용됩니다. 해당하는 MSYS 및 MSYS2 환경에서 다른 도구가 사용됩니다 (필요한 경우). 운 좋게도 대부분의 컴파일러는 백 슬래시 대신 슬래시를 경로 구분 기호로 사용하지만 여전히 드라이브 문자 등을 가져와야합니다. 래퍼 스크립트는 cc.sh가 가능한 모든 gcc 옵션을 이해하고 번역하고 올바른 옵션을 cl.exe에 전달한다는 의미에서 일반적이지 않습니다. 원칙은 스크립트가 Erlang / OTP를 구축 할 수있을만큼 강력하다는 것입니다. Erlang 개발 과정에서 변경 사항을 처리하기 위해 확장 기능이 필요할 수 있으며 이것이 Perl 스크립트가 아닌 쉘 스크립트로 만든 이유 중 하나입니다. 우리는 그들이 이해하고 변경하는 것이 더 쉽다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="4d1ee8b13defdb6f13a0a5e7daa4cf8a74b29540" translate="yes" xml:space="preserve">
          <source>A: For Cygwin, MSYS and MSYS2 alike, we try to use the latest releases available when building. What versions you use shouldn't really matter. We try to include workarounds for the bugs we've found in different Cygwin/MSYS/MSYS2 releases. Please help us add workarounds for new Cygwin/MSYS/MSYS2-related bugs as soon as you encounter them. Also please do submit bug reports to the appropriate Cygwin, MSYS and/or MSYS2 developers. The GCC we used for 21 was version 4.8.1 (MinGW 32bit) and 4.8.5 (MSYS2 64bit). We used VC++ 12.0 (i.e. Visual studio 2013), Sun's JDK 1.6.0_45 (32bit) and Sun's JDK 1.7.0_1 (64bit), NSIS 2.46, and Win32 OpenSSL 1.0.2d. Please read the next section for details on what you need.</source>
          <target state="translated">A : Cygwin, MSYS 및 MSYS2 모두 빌드 할 때 사용 가능한 최신 릴리스를 사용하려고합니다. 사용하는 버전은 중요하지 않습니다. 다른 Cygwin / MSYS / MSYS2 릴리스에서 발견 된 버그에 대한 해결 방법을 포함 시키려고합니다. 새로운 Cygwin / MSYS / MSYS2 관련 버그가 발생하자마자 해결 방법을 추가하도록 도와주세요. 또한 적절한 Cygwin, MSYS 및 / 또는 MSYS2 개발자에게 버그 보고서를 제출하십시오. 21에 사용한 GCC는 버전 4.8.1 (MinGW 32 비트) 및 4.8.5 (MSYS2 64 비트)입니다. VC ++ 12.0 (예 : Visual Studio 2013), Sun의 JDK 1.6.0_45 (32 비트) 및 Sun의 JDK 1.7.0_1 (64 비트), NSIS 2.46 및 Win32 OpenSSL 1.0.2d를 사용했습니다. 필요한 사항에 대한 자세한 내용은 다음 섹션을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="731d5bc0547d3ee14b9d073a740322bb562e4b26" translate="yes" xml:space="preserve">
          <source>A: No, never. The hassle of keeping the project files up to date and do all the steps that constitute an OTP build from within the VC++ GUI is simply not worth it, maybe even impossible. A VC++ project file for Erlang/OTP will never happen.</source>
          <target state="translated">A : 아닙니다. 프로젝트 파일을 최신 상태로 유지하고 VC ++ GUI 내에서 OTP 빌드를 구성하는 모든 단계를 수행하는 번거 로움은 그다지 가치가 없으며 어쩌면 불가능할 수도 있습니다. Erlang / OTP 용 VC ++ 프로젝트 파일은 절대 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="521d37ede1551a08a3beff1206807c9cd55ca94a" translate="yes" xml:space="preserve">
          <source>A: No, not really, but see this as a step in the right direction.</source>
          <target state="translated">A : 아니요, 실제로는 아니지만 올바른 방향의 단계라고 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="58e458048a7a9548592140528083c14b19023a3f" translate="yes" xml:space="preserve">
          <source>A: No, the result will be a pure Windows binary, and as far as I know, it's not possible to make a Cygwin binary yet. That is of course something desirable, but there are still some problems with the dynamic linking (dynamic Erlang driver loading) as well as the TCP/IP emulation in Cygwin, which, I'm sure of, will improve, but still has some problems. Fixing those problems might be easy or might be hard. I suggest you try yourself and share your experience. No one would be happier if a simple &lt;code&gt;./configure &amp;amp;&amp;amp; make&lt;/code&gt; would produce a fully fledged Cygwin binary.</source>
          <target state="translated">A : 아니요. 결과는 순수한 Windows 바이너리이며, 내가 아는 한 Cygwin 바이너리를 만들 수는 없습니다. 물론 바람직한 일이지만 Cygwin의 TCP / IP 에뮬레이션뿐만 아니라 동적 링크 (동적 Erlang 드라이버 로딩)에는 여전히 몇 가지 문제가 있습니다. . 이러한 문제를 해결하는 것은 쉽지 않거나 어려울 수 있습니다. 나는 당신이 자신을 시도하고 경험을 공유하는 것이 좋습니다. 단순한 &lt;code&gt;./configure &amp;amp;&amp;amp; make&lt;/code&gt; 가 완전한 Cygwin 바이너리를 생성 한다면 아무도 행복하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="f58ec10da79cf14638b87d58a71fefc5754e9d5f" translate="yes" xml:space="preserve">
          <source>A: No, unfortunately not. You'll need Microsoft's Visual C++ still. A Bourne-shell script (cc.sh) wraps the Visual C++ compiler and runs it from within the Cygwin environment. All other tools needed to build Erlang are free-ware/open source, but not the C compiler. The Windows SDK is however enough to build Erlang, you do not need to buy Visual C++, just download the SDK (SDK version 8.1 == Visual studio 2013).</source>
          <target state="translated">A : 안타깝게도 아닙니다. 여전히 Microsoft의 Visual C ++이 필요합니다. Bourne-shell 스크립트 (cc.sh)는 Visual C ++ 컴파일러를 래핑하여 Cygwin 환경에서 실행합니다. Erlang을 빌드하는 데 필요한 다른 모든 도구는 프리웨어 / 오픈 소스이지만 C 컴파일러는 아닙니다. 그러나 Windows SDK는 Erlang을 구축하기에 충분합니다. Visual C ++를 구입할 필요가 없으며 SDK (SDK 버전 8.1 == Visual studio 2013) 만 다운로드하면됩니다.</target>
        </trans-unit>
        <trans-unit id="85724e56e3dcb9f76cc960c4345313a7227e07b7" translate="yes" xml:space="preserve">
          <source>A: No, unfortunately not. You'll need Microsoft's Visual C++ still. A Bourne-shell script (cc.sh) wraps the Visual C++ compiler and runs it from within the WSL environment. All other tools needed to build Erlang are free-ware/open source, but not the C compiler.</source>
          <target state="translated">A : 아니요, 안타깝게도 아닙니다. 여전히 Microsoft의 Visual C ++가 필요합니다. Bourne-shell 스크립트 (cc.sh)는 Visual C ++ 컴파일러를 래핑하고 WSL 환경 내에서 실행합니다. Erlang을 빌드하는 데 필요한 다른 모든 도구는 프리웨어 / 오픈 소스이지만 C 컴파일러는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a599e8e13ccfd4f3e0504f6192bcbcf31a59938f" translate="yes" xml:space="preserve">
          <source>A: No, unfortunately we haven't got time to help with Cygwin/MSYS/MSYS2 related user problems, please read related websites, newsgroups and mailing lists.</source>
          <target state="translated">A : 아니요, 불행히도 Cygwin / MSYS / MSYS2 관련 사용자 문제를 도와 드릴 시간이 없습니다. 관련 웹 사이트, 뉴스 그룹 및 메일 링리스트를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="210dcbb21de47a153ba938b86b20600d7d480a0c" translate="yes" xml:space="preserve">
          <source>A: OK, I admit, one of the files is compiled using Cygwin's or MinGW's GCC and the resulting object code is then converted to MS VC++ compatible coff using a small C hack. It's because that particular file, &lt;code&gt;beam_emu.c&lt;/code&gt; benefits immensely from being able to use the GCC labels-as-values extension, which boosts emulator performance by up to 50%. That does unfortunately not (yet) mean that all of OTP could be compiled using GCC. That particular source code does not do anything system specific and actually is adopted to the fact that GCC is used to compile it on Windows.</source>
          <target state="translated">A : 좋습니다. 파일 중 하나가 Cygwin 또는 MinGW의 GCC를 사용하여 컴파일 된 후 결과 개체 코드가 작은 C 핵을 사용하여 MS VC ++ 호환 coff로 변환됩니다. 특정 파일 인 &lt;code&gt;beam_emu.c&lt;/code&gt; 는 GCC 레이블 값 확장을 사용할 수있게되므로 에뮬레이터 성능을 최대 50 % 향상시킵니다. 불행히도 (아직) 모든 OTP가 GCC를 사용하여 컴파일 될 수 있음을 의미하지는 않습니다. 이 특정 소스 코드는 시스템 특정 작업을 수행하지 않으며 실제로 GCC가 Windows에서 컴파일하는 데 사용된다는 사실에 채택되었습니다.</target>
        </trans-unit>
        <trans-unit id="81af1c0ed56bada7f1365c496431c92fc23f483c" translate="yes" xml:space="preserve">
          <source>A: OK, I admit, one of the files is compiled using MinGW's GCC and the resulting object code is then converted to MS VC++ compatible coff using a small C hack. It's because that particular file, &lt;code&gt;beam_emu.c&lt;/code&gt; benefits immensely from being able to use the GCC labels-as-values extension, which boosts emulator performance by up to 50%. That does unfortunately not (yet) mean that all of OTP could be compiled using GCC. That particular source code does not do anything system specific and actually is adopted to the fact that GCC is used to compile it on Windows.</source>
          <target state="translated">A : 좋습니다. 파일 중 하나는 MinGW의 GCC를 사용하여 컴파일되고 결과 개체 코드는 작은 C 해킹을 사용하여 MS VC ++ 호환 coff로 변환됩니다. 특정 파일 인 &lt;code&gt;beam_emu.c&lt;/code&gt; 는 GCC 값으로 레이블 확장을 사용할 수 있다는 점에서 막대한 이점을 제공하여 에뮬레이터 성능을 최대 50 %까지 높일 수 있기 때문입니다 . 불행히도 (아직) 모든 OTP가 GCC를 사용하여 컴파일 될 수 있음을 의미하지는 않습니다. 특정 소스 코드는 시스템에 특정한 어떤 것도 수행하지 않으며 실제로 Windows에서 컴파일하는 데 GCC가 사용된다는 사실에 채택됩니다.</target>
        </trans-unit>
        <trans-unit id="f9e36bf356b0e8d7e06efee09f6d96691782df63" translate="yes" xml:space="preserve">
          <source>A: WSL/Ubuntu is the environment, it's almost like you had a virtual Unix machine inside Windows. Configure, given certain parameters, then creates makefiles that are used by the environment's gnu-make to built the system. Most of the actual compilers etc are not, however, WSL tools, so we've written a couple of wrappers (Bourne-shell scripts), which reside in &lt;code&gt;$ERL_TOP/etc/win32/wsl_tools&lt;/code&gt;. They all do conversion of parameters and switches common in the Unix environment to fit the native Windows tools. Most notable is of course the paths, which in WSL are Unix-like paths with &quot;forward slashes&quot; (/) and no drive letters. The WSL specific command &lt;code&gt;wslpath&lt;/code&gt; is used for most of the path conversions in a WSL environment. Luckily most compilers accept forward slashes instead of backslashes as path separators, but one still have to get the drive letters etc right, though. The wrapper scripts are not general in the sense that, for example, cc.sh would understand and translate every possible gcc option and pass correct options to cl.exe. The principle is that the scripts are powerful enough to allow building of Erlang/OTP, no more, no less. They might need extensions to cope with changes during the development of Erlang, and that's one of the reasons we made them into shell-scripts and not Perl-scripts. We believe they are easier to understand and change that way.</source>
          <target state="translated">A : WSL / Ubuntu는 환경입니다. Windows 내부에 가상 Unix 머신이있는 것과 거의 같습니다. 특정 매개 변수가 주어지면 구성한 다음 환경의 gnu-make가 시스템을 구축하는 데 사용하는 메이크 파일을 만듭니다. 그러나 대부분의 실제 컴파일러 등은 WSL 도구가 아니므로 &lt;code&gt;$ERL_TOP/etc/win32/wsl_tools&lt;/code&gt; 있는 두 개의 래퍼 (Bourne-shell 스크립트)를 작성 했습니다 . 그들은 모두 기본 Windows 도구에 맞게 Unix 환경에서 공통된 매개 변수 및 스위치를 변환합니다. 가장 주목할만한 것은 물론 WSL에서 &quot;슬래시&quot;(/)가 있고 드라이브 문자가없는 Unix와 유사한 경로 인 경로입니다. WSL 특정 명령 &lt;code&gt;wslpath&lt;/code&gt; WSL 환경에서 대부분의 경로 변환에 사용됩니다. 운 좋게도 대부분의 컴파일러는 경로 구분 기호로 백 슬래시 대신 슬래시를 허용하지만 여전히 드라이브 문자 등을 올바르게 가져와야합니다. 래퍼 스크립트는 예를 들어 cc.sh가 가능한 모든 gcc 옵션을 이해하고 번역하고 올바른 옵션을 cl.exe에 전달한다는 점에서 일반적이지 않습니다. 원칙은 스크립트가 Erlang / OTP를 구축 할 수있을만큼 강력하다는 것입니다. Erlang을 개발하는 동안 변경 사항에 대처하기 위해 확장이 필요할 수 있으며, 이것이 Perl 스크립트가 아닌 쉘 스크립트로 만든 이유 중 하나입니다. 우리는 그들이 그렇게 이해하고 변경하기가 더 쉽다고 믿습니다.</target>
        </trans-unit>
        <trans-unit id="7b2634e5d15aa84185c8c93ac17bc4f970898371" translate="yes" xml:space="preserve">
          <source>A: We use WSL 1 with Ubuntu 18.04. The GCC we used for 23 was version 7.3-win32. We used Visual studio 2019, Sun's JDK 1.8.0_241, NSIS 3.05, Win32 OpenSSL 1.1.1d and wxWidgets-3.1.3.</source>
          <target state="translated">A : Ubuntu 18.04와 함께 WSL 1을 사용합니다. 23에 사용한 GCC는 버전 7.3-win32였습니다. Visual studio 2019, Sun의 JDK 1.8.0_241, NSIS 3.05, Win32 OpenSSL 1.1.1d 및 wxWidgets-3.1.3을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="97fcb970b445ac9a87b96b37bf7ea3a4ab4cab29" translate="yes" xml:space="preserve">
          <source>A: Well, it's not expensive, it's free (as in free beer). Just download and install the latest Windows SDK from Microsoft and all the tools you need are there. The included debugger (WinDbg) is also quite usable. That's what I used when porting Erlang to 64bit Windows. Another reason to use later Microsoft compilers is DLL compatibility. DLL's using a new version of the standard library might not load if the VM is compiled with an old VC++ version. So we should aim to use the latest freely available SDK and compiler.</source>
          <target state="translated">A : 글쎄요, 비싸지 않고 무료입니다 (무료 맥주 에서처럼). Microsoft에서 최신 Windows SDK와 필요한 모든 도구를 다운로드하여 설치하십시오. 포함 된 디버거 (WinDbg)도 사용할 수 있습니다. 이것이 Erlang을 64 비트 Windows로 포팅 할 때 사용한 것입니다. 이후 Microsoft 컴파일러를 사용해야하는 또 다른 이유는 DLL 호환성입니다. VM이 이전 VC ++ 버전으로 컴파일 된 경우 새 버전의 표준 라이브러리를 사용하는 DLL이로드되지 않을 수 있습니다. 따라서 무료로 제공되는 최신 SDK 및 컴파일러를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c041ae7e57578688a11137a9916f0588de32a73f" translate="yes" xml:space="preserve">
          <source>A: Well, partly because it's a good compiler - really! Actually it's been possible in late R11-releases to build using mingw instead of visual C++ (you might see the remnants of that in some scripts and directories). Unfortunately the development of the SMP version for Windows broke the mingw build and we chose to focus on the VC++ build as the performance has been much better in the VC++ versions. The mingw build will possibly be back, but as long as VC++ gives better performance, the commercial build will be a VC++ one.</source>
          <target state="translated">A : 글쎄요, 부분적으로는 좋은 컴파일러이기 때문입니다. 정말로! 실제로 R11 이후 릴리스에서는 시각적 C ++ 대신 mingw를 사용하여 빌드 할 수있었습니다 (일부 스크립트 및 디렉토리에서 나머지를 볼 수 있음). 불행히도 Windows 용 SMP 버전의 개발은 mingw 빌드를 중단했으며 VC ++ 버전에서 성능이 훨씬 향상되었으므로 VC ++ 빌드에 중점을두기로 선택했습니다. mingw 빌드가 다시 시작될 수 있지만 VC ++가 더 나은 성능을 제공하는 한 상용 빌드는 VC ++ 빌드입니다.</target>
        </trans-unit>
        <trans-unit id="8315e42a391d74c84bc127e20d99aa2c7b6bc114" translate="yes" xml:space="preserve">
          <source>A: Yes, we use the exact same build procedure.</source>
          <target state="translated">A : 그렇습니다. 우리는 똑같은 빌드 절차를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c88a17178680779495642b56e9c7d27ea864c737" translate="yes" xml:space="preserve">
          <source>AH(NeedStack, NeedHeap, Live)</source>
          <target state="translated">AH(NeedStack, NeedHeap, Live)</target>
        </trans-unit>
        <trans-unit id="be36dfbb5116564a40ed7d5b4cbdf3999ccff9dc" translate="yes" xml:space="preserve">
          <source>API Description</source>
          <target state="translated">API 설명</target>
        </trans-unit>
        <trans-unit id="436942b9131313ac7f725ef0106016a7cb814a52" translate="yes" xml:space="preserve">
          <source>API for a SSL/TLS CRL (Certificate Revocation List) cache.</source>
          <target state="translated">SSL / TLS CRL (인증서 해지 목록) 캐시 용 API.</target>
        </trans-unit>
        <trans-unit id="01fc1fc29ee3bdfac97c802f999cf7358e251132" translate="yes" xml:space="preserve">
          <source>API for a TLS CRL (Certificate Revocation List) cache.</source>
          <target state="translated">TLS CRL (인증서 해지 목록) 캐시 용 API입니다.</target>
        </trans-unit>
        <trans-unit id="a23c8e20572073978952d048d9433a8575f6a97d" translate="yes" xml:space="preserve">
          <source>API functions for an Erlang NIF library.</source>
          <target state="translated">Erlang NIF 라이브러리를위한 API 함수.</target>
        </trans-unit>
        <trans-unit id="361d551affb47befd80fca6479fe8a167dc7036d" translate="yes" xml:space="preserve">
          <source>API functions for an Erlang driver.</source>
          <target state="translated">Erlang 드라이버를위한 API 함수.</target>
        </trans-unit>
        <trans-unit id="e80b30d77b2cab01b81ccc87fb312659f6e0dd98" translate="yes" xml:space="preserve">
          <source>API functions in the module &lt;code&gt;httpd_conf&lt;/code&gt; was deprecated in favor of standard modules such as &lt;code&gt;lists&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;filelib&lt;/code&gt;, and &lt;code&gt;erlang&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;httpd_conf&lt;/code&gt; 모듈의 API 함수는 &lt;code&gt;lists&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;filelib&lt;/code&gt; 및 &lt;code&gt;erlang&lt;/code&gt; 과 같은 표준 모듈 대신 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d310425c434730e2f59306f932cf1691ae572d78" translate="yes" xml:space="preserve">
          <source>API functions to write customized SSH clients and servers applications</source>
          <target state="translated">사용자 정의 SSH 클라이언트 및 서버 애플리케이션을 작성하기위한 API 기능</target>
        </trans-unit>
        <trans-unit id="de210df0a505b46fa42dc263d10d332cce666788" translate="yes" xml:space="preserve">
          <source>API kept from previous versions</source>
          <target state="translated">이전 버전에서 보관 된 API</target>
        </trans-unit>
        <trans-unit id="72bf5fea06a2041d232930267f67048618c99f45" translate="yes" xml:space="preserve">
          <source>API module for Logger, the standard logging facility in Erlang/OTP.</source>
          <target state="translated">Erlang / OTP의 표준 로깅 기능인 Logger 용 API 모듈.</target>
        </trans-unit>
        <trans-unit id="0be52be7a0efe4a62d99e98efb97a08aef84fe41" translate="yes" xml:space="preserve">
          <source>API module for public-key infrastructure.</source>
          <target state="translated">공개 키 인프라 용 API 모듈.</target>
        </trans-unit>
        <trans-unit id="76827dde5bd6ab1accea3ccbe25374a63afc24e6" translate="yes" xml:space="preserve">
          <source>ARM: ARMv5TE (i.e. XScale) processors should work. Both big-endian and little-endian modes are supported.</source>
          <target state="translated">ARM : ARMv5TE (예 : XScale) 프로세서가 작동해야합니다. 빅 엔디안 및 리틀 엔디안 모드가 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ca8c02ce6c85a255754680e86371209b9b2680ce" translate="yes" xml:space="preserve">
          <source>ARM: Linux</source>
          <target state="translated">ARM : 리눅스</target>
        </trans-unit>
        <trans-unit id="d9932f6f9e0505be61dc8fcd25736c1bf8cf818f" translate="yes" xml:space="preserve">
          <source>ASCII value or unicode code-point of the character &lt;strong&gt;&lt;code&gt;char&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">ASCII 값 또는 문자의 유니 코드 코드 포인트 &lt;strong&gt; &lt;code&gt;char&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="196ab313cd92b6ea93995c7fc93f081f77b30992" translate="yes" xml:space="preserve">
          <source>ASN.1 DER-encoded entity as an Erlang binary.</source>
          <target state="translated">Erlang 바이너리로 ASN.1 DER 인코딩 된 엔터티.</target>
        </trans-unit>
        <trans-unit id="5fa4ef6c7f4c743ebd97fa57feafd946e53e8d8c" translate="yes" xml:space="preserve">
          <source>ASN.1 Specifications, Messages, and Configuration</source>
          <target state="translated">ASN.1 사양, 메시지 및 구성</target>
        </trans-unit>
        <trans-unit id="368efd7c5142e650553f401aa461d1b76d069901" translate="yes" xml:space="preserve">
          <source>ASN.1 compiler and compile-time support functions</source>
          <target state="translated">ASN.1 컴파일러 및 컴파일 타임 지원 기능</target>
        </trans-unit>
        <trans-unit id="c009d6d020f91e9075e192687145f1f9183e3b17" translate="yes" xml:space="preserve">
          <source>ASN.1 has both primitive and constructed types:</source>
          <target state="translated">ASN.1에는 기본 유형과 생성 된 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfcd66d008f9b63d7b919bdf916303779861fe19" translate="yes" xml:space="preserve">
          <source>ASN.1 is a formal language for describing data structures to be exchanged between distributed computer systems. The purpose of ASN.1 is to have a platform and programming language independent notation to express types using a standardized set of rules for the transformation of values of a defined type into a stream of bytes. This stream of bytes can then be sent on any type of communication channel. This way, two applications written in different programming languages running on different computers, and with different internal representation of data, can exchange instances of structured data types.</source>
          <target state="translated">ASN.1은 분산 컴퓨터 시스템간에 교환 될 데이터 구조를 설명하기위한 공식 언어입니다. ASN.1의 목적은 정의 된 유형의 값을 바이트 스트림으로 변환하기 위해 표준화 된 규칙 세트를 사용하여 유형을 표현하는 플랫폼 및 프로그래밍 언어 독립적 표기법을 갖는 것입니다. 이 바이트 스트림은 모든 유형의 통신 채널에서 전송 될 수 있습니다. 이러한 방식으로, 서로 다른 컴퓨터에서 실행되는 서로 다른 프로그래밍 언어로 작성된 두 개의 응용 프로그램과 서로 다른 내부 데이터 표현으로 구조화 된 데이터 유형의 인스턴스를 교환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b1ea2d9df3b25e2e5fe146441abf268990d9a8f" translate="yes" xml:space="preserve">
          <source>ASN.1 is used in two different ways in SNMP. The SMI is based on ASN.1, and the messages in the protocol are defined by using ASN.1.</source>
          <target state="translated">ASN.1은 SNMP에서 두 가지 방식으로 사용됩니다. SMI는 ASN.1을 기반으로하며 프로토콜의 메시지는 ASN.1을 사용하여 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="18afe0241096372d9207a097906f4cc9e96ca40a" translate="yes" xml:space="preserve">
          <source>ASN.1 itself specifies indefinitely large integers. Erlang systems with version 4.3 and higher support very large integers, in practice indefinitely large integers.</source>
          <target state="translated">ASN.1 자체는 무한정 큰 정수를 지정합니다. 버전 4.3 이상의 Erlang 시스템은 실제로 무한정 큰 정수를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1b5feca556ffbb7ecdf53e29fcc97d476a5bf5f3" translate="yes" xml:space="preserve">
          <source>ASN.1 module &lt;code&gt;People&lt;/code&gt; is now accepted and the abstract syntax tree is saved in file &lt;code&gt;People.asn1db&lt;/code&gt;. The generated Erlang code is compiled using the Erlang compiler and loaded into the Erlang runtime system. There is now an API for &lt;code&gt;encode/2&lt;/code&gt; and &lt;code&gt;decode/2&lt;/code&gt; in module &lt;code&gt;People&lt;/code&gt;, which is called like:</source>
          <target state="translated">ASN.1 모듈 &lt;code&gt;People&lt;/code&gt; 이 승인되었으며 추상 구문 트리가 &lt;code&gt;People.asn1db&lt;/code&gt; 파일에 저장됩니다 . 생성 된 Erlang 코드는 Erlang 컴파일러를 사용하여 컴파일되어 Erlang 런타임 시스템에로드됩니다. &lt;code&gt;People&lt;/code&gt; 모듈 에 &lt;code&gt;encode/2&lt;/code&gt; 및 &lt;code&gt;decode/2&lt;/code&gt; 를 위한 API가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="38ab94405d2e97c97a998a6475af5251fa89b825" translate="yes" xml:space="preserve">
          <source>ASN.1 supports a wide variety of character sets. The main difference between an &lt;code&gt;OCTET STRING&lt;/code&gt; and a character string is that the &lt;code&gt;OCTET STRING&lt;/code&gt; has no imposed semantics on the bytes delivered.</source>
          <target state="translated">ASN.1은 다양한 문자 집합을 지원합니다. &lt;code&gt;OCTET STRING&lt;/code&gt; 과 문자열 간의 주요 차이점 은 &lt;code&gt;OCTET STRING&lt;/code&gt; 이 전달 된 바이트에 의미를 부과하지 않았다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="00118b8d7398e0597bbf5e3a9b1a946f91c275ba" translate="yes" xml:space="preserve">
          <source>ASN.1 type present in the Public Key applications ASN.1 specifications.</source>
          <target state="translated">공개 키 응용 프로그램 ASN.1 사양에 ASN.1 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="999234c8b850d2864e4971ba3f6a923f854d60c2" translate="yes" xml:space="preserve">
          <source>ASN1 file. It creates an &lt;code&gt;.erl&lt;/code&gt;, &lt;code&gt;.hrl&lt;/code&gt;, and &lt;code&gt;.asn1db&lt;/code&gt; file from an &lt;code&gt;.asn1&lt;/code&gt; file. Also compiles the &lt;code&gt;.erl&lt;/code&gt; using the Erlang compiler unless option &lt;code&gt;+noobj&lt;/code&gt; is specified.</source>
          <target state="translated">ASN1 파일. 그것은 생성 &lt;code&gt;.erl&lt;/code&gt; , &lt;code&gt;.hrl&lt;/code&gt; 및 &lt;code&gt;.asn1db&lt;/code&gt; 에서 파일 &lt;code&gt;.asn1&lt;/code&gt; 의 파일을. 옵션 &lt;code&gt;+noobj&lt;/code&gt; 를 지정 하지 않으면 Erlang 컴파일러를 사용 하여 &lt;code&gt;.erl&lt;/code&gt; 을 컴파일 합니다.</target>
        </trans-unit>
        <trans-unit id="3f4ea8e8df4b539a09e4694a57b64fe87acc6aa2" translate="yes" xml:space="preserve">
          <source>AVP Codes</source>
          <target state="translated">AVP 코드</target>
        </trans-unit>
        <trans-unit id="5f07924d7df0ed6c7a91768f9fe2d84ed905e783" translate="yes" xml:space="preserve">
          <source>AVP Considerations</source>
          <target state="translated">AVP 고려 사항</target>
        </trans-unit>
        <trans-unit id="358dba47c0c1d2a1ab4897c5be6e756cf7939cf1" translate="yes" xml:space="preserve">
          <source>AVP Flags</source>
          <target state="translated">AVP 플래그</target>
        </trans-unit>
        <trans-unit id="147e947b2ccddb2127e44e91cd77c7172c834c87" translate="yes" xml:space="preserve">
          <source>AVP Header</source>
          <target state="translated">AVP 헤더</target>
        </trans-unit>
        <trans-unit id="db689f171790fb1bc972a968ef05e4c119e28132" translate="yes" xml:space="preserve">
          <source>AVP Occurrence Tables</source>
          <target state="translated">AVP 발생 테이블</target>
        </trans-unit>
        <trans-unit id="7b38fc4069f3bc947361bf1d7d5e19953586e35e" translate="yes" xml:space="preserve">
          <source>AVP Values</source>
          <target state="translated">AVP 값</target>
        </trans-unit>
        <trans-unit id="c483ce0c3913a6678d954f208b0703dcb0e25b18" translate="yes" xml:space="preserve">
          <source>AVP values sent in outgoing CER or CEA messages during capabilities exchange. Can be configured both on a service and a transport, values on the latter taking precedence. Has one of the following types.</source>
          <target state="translated">기능 교환 중에 발신 CER 또는 CEA 메시지로 전송 된 AVP 값. 서비스와 전송 모두에서 구성 될 수 있으며, 후자가 우선합니다. 다음 유형 중 하나가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c0e57636791ead050a384bc77e79f8d2fe33260" translate="yes" xml:space="preserve">
          <source>AVPs are decoded into a list of diameter_avp records in &lt;code&gt;avps&lt;/code&gt; field of diameter_packet records independently of &lt;code&gt;decode_format&lt;/code&gt;.</source>
          <target state="translated">AVPs에 diameter_avp는 레코드의리스트로 디코딩 &lt;code&gt;avps&lt;/code&gt; 독립적 diameter_packet 레코드 필드 &lt;code&gt;decode_format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84bf21f5193b0af6e24655608ac0e30ceef7e07a" translate="yes" xml:space="preserve">
          <source>AVPs defined in the RFC are defined in dictionaries provided by diameter. Their proper use in application messages is the responsibility of the user.</source>
          <target state="translated">RFC에 정의 된 AVP는 직경으로 제공되는 사전으로 정의됩니다. 응용 프로그램 메시지에서의 올바른 사용은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="6734299ae0f748faa6b52d7e11abf2d0c25ca64f" translate="yes" xml:space="preserve">
          <source>AVPs used to construct outgoing CER/CEA messages. Values take precedence over any specified on the service in question.</source>
          <target state="translated">발신 CER / CEA 메시지를 작성하는 데 사용되는 AVP. 해당 서비스에 지정된 값보다 값이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="5816a66e2c13a6d76644d2e1d9520bcb6dbe4591" translate="yes" xml:space="preserve">
          <source>Aa a list of binary digits (0 or 1). This format is accepted as input to the encode functions, and a &lt;code&gt;BIT STRING&lt;/code&gt; is decoded to this format if option &lt;strong&gt;legacy_bit_string&lt;/strong&gt; is given.</source>
          <target state="translated">이진 숫자 목록 (0 또는 1) 이 형식은 인코딩 함수에 대한 입력으로 허용되며 &lt;strong&gt;legacy_bit_string&lt;/strong&gt; 옵션이 제공되면 &lt;code&gt;BIT STRING&lt;/code&gt; 이이 형식으로 디코딩됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2fc2e3239e8ec3bf7008184c81466440651887a" translate="yes" xml:space="preserve">
          <source>Abandon a previously issued spawn request. &lt;code&gt;ReqId&lt;/code&gt; corresponds to a request identifier previously returned by &lt;code&gt;&lt;a href=&quot;#spawn_request-5&quot;&gt;spawn_request()&lt;/a&gt;&lt;/code&gt; in a call from current process. That is, only the process that has made the request can abandon the request.</source>
          <target state="translated">이전에 발행 된 스폰 요청을 버립니다. &lt;code&gt;ReqId&lt;/code&gt; 는 현재 프로세스의 호출에서 &lt;code&gt;&lt;a href=&quot;#spawn_request-5&quot;&gt;spawn_request()&lt;/a&gt;&lt;/code&gt; 에 의해 이전에 반환 된 요청 식별자에 해당합니다 . 즉, 요청을 한 프로세스 만 요청을 포기할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5bdc897b18ae8c316a38939d3d1d0e98477ad32" translate="yes" xml:space="preserve">
          <source>Abandon carrier free block min limit. A valid &lt;code&gt;&amp;lt;bytes&amp;gt;&lt;/code&gt; is a positive integer representing a block size limit. The largest free block in a carrier must be at least &lt;code&gt;bytes&lt;/code&gt; large, for the carrier to be abandoned. The default is zero but can be changed in the future.</source>
          <target state="translated">캐리어 프리 블록 최소 한계를 포기하십시오. 유효한 &lt;code&gt;&amp;lt;bytes&amp;gt;&lt;/code&gt; 는 블록 크기 제한을 나타내는 양의 정수입니다. 반송파를 폐기하려면 반송파 에서 가장 큰 여유 블록이 &lt;code&gt;bytes&lt;/code&gt; 이상이어야합니다 . 기본값은 0이지만 나중에 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e058521811c5ddbaf236521691a6aac5c91e2d2" translate="yes" xml:space="preserve">
          <source>Abandon carrier number limit. A valid &lt;code&gt;&amp;lt;amount&amp;gt;&lt;/code&gt; is a positive integer representing max number of abandoned carriers per allocator instance. Defaults to 1000 which will practically disable the limit, but this can be changed in the future.</source>
          <target state="translated">운송 업체 수 제한을 포기합니다. 유효한 &lt;code&gt;&amp;lt;amount&amp;gt;&lt;/code&gt; 는 할당 자 인스턴스 당 최대 포기 된 반송파 수를 나타내는 양의 정수입니다. 기본값은 1000으로 설정되어 실제로 제한을 비활성화하지만 나중에 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddd8504b781a1a9f6d7b92f1aa500221a0c4787e" translate="yes" xml:space="preserve">
          <source>Abandon carrier utilization limit. A valid &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt; is an integer in the range &lt;code&gt;[0, 100]&lt;/code&gt; representing utilization in percent. When a utilization value &amp;gt; 0 is used, allocator instances are allowed to abandon multiblock carriers. If &lt;code&gt;de&lt;/code&gt; (default enabled) is passed instead of a &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt;, a recommended non-zero utilization value is used. The value chosen depends on the allocator type and can be changed between ERTS versions. Defaults to &lt;code&gt;de&lt;/code&gt;, but this can be changed in the future.</source>
          <target state="translated">이동 통신사 사용 한도를 포기합니다. 유효한 &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt; 은 사용률을 백분율로 나타내는 &lt;code&gt;[0, 100]&lt;/code&gt; 범위의 정수입니다 . 활용도 값&amp;gt; 0을 사용하면 할당 자 인스턴스가 멀티 블록 캐리어를 포기할 수 있습니다. 경우 &lt;code&gt;de&lt;/code&gt; (기본값은 활성화)를 대신 전달 &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt; , 권장되는 비 제로 사용 값이 사용됩니다. 선택한 값은 할당 자 유형에 따라 다르며 ERTS 버전간에 변경 될 수 있습니다. 기본값은 &lt;code&gt;de&lt;/code&gt; 이지만 나중에 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99ed550f3cfb54b7e586b3d6dae1d5c6c29740db" translate="yes" xml:space="preserve">
          <source>Ability to start an Erlang emulator with more flags (any flags supported by &lt;code&gt;erl&lt;/code&gt; are supported).</source>
          <target state="translated">더 많은 플래그를 사용하여 Erlang 에뮬레이터를 시작하는 기능 ( &lt;code&gt;erl&lt;/code&gt; 에서 지원하는 모든 플래그 가 지원됨).</target>
        </trans-unit>
        <trans-unit id="31592e98a78da975e62737d1409cd4fb77bffb8e" translate="yes" xml:space="preserve">
          <source>Abnormally terminates the association specified by &lt;code&gt;Assoc&lt;/code&gt;, without flushing of unsent data. The socket itself remains open. Other associations opened on this socket are still valid, and the socket can be used in new associations.</source>
          <target state="translated">보내지 않은 데이터를 플러시하지 않고 &lt;code&gt;Assoc&lt;/code&gt; 에 의해 지정된 연관을 비정상적으로 종료합니다 . 소켓 자체는 열려 있습니다. 이 소켓에서 열린 다른 연관은 여전히 ​​유효하며 소켓은 새 연관에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54e07c4e032173c30d3e1d7eccc1fc09c4351b63" translate="yes" xml:space="preserve">
          <source>Abort-Session-Answer</source>
          <target state="translated">Abort-Session-Answer</target>
        </trans-unit>
        <trans-unit id="aa6a977eb79f01d2748881fca70eaba063d40819" translate="yes" xml:space="preserve">
          <source>Abort-Session-Request</source>
          <target state="translated">Abort-Session-Request</target>
        </trans-unit>
        <trans-unit id="53f8d6aa2f451847b8dbd7813ad859f16188a7eb" translate="yes" xml:space="preserve">
          <source>Aborting a Session</source>
          <target state="translated">세션 중단</target>
        </trans-unit>
        <trans-unit id="19fdf66eca72538f9393a1351c5653c5dbe6dba0" translate="yes" xml:space="preserve">
          <source>Aborts the connection when it is closed. Discards any data still remaining in the send buffers and sends RST to the peer.</source>
          <target state="translated">닫히면 연결을 중단합니다. 송신 버퍼에 남아있는 모든 데이터를 버리고 RST를 피어로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="b90030936dbb152015b9486771f1ada8423bb6a8" translate="yes" xml:space="preserve">
          <source>Aborts the current association without flushing any unsent data</source>
          <target state="translated">보내지 않은 데이터를 플러시하지 않고 현재 연결을 중단합니다</target>
        </trans-unit>
        <trans-unit id="32505d42e4f66e192dcee78817ac876d40a66d28" translate="yes" xml:space="preserve">
          <source>Aborts the currently executing test case. The user must know with certainty which test case is currently executing. The function is therefore only safe to call from a function that has been called (or synchronously invoked) by the test case.</source>
          <target state="translated">현재 실행중인 테스트 사례를 중단합니다. 사용자는 현재 실행중인 테스트 사례를 확실하게 알고 있어야합니다. 따라서 함수는 테스트 케이스에 의해 호출 된 (또는 동 기적으로 호출 된) 함수에서만 호출하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="d5a894573c68d878cab4cb98be562e26f9a7f0d1" translate="yes" xml:space="preserve">
          <source>Aborts the test run if one or more suites fail to compile (described earlier).</source>
          <target state="translated">하나 이상의 스위트가 컴파일에 실패한 경우 (앞서 설명) 테스트 실행을 중단합니다.</target>
        </trans-unit>
        <trans-unit id="0744eff0f05c525e12f11abc8717d631608439c4" translate="yes" xml:space="preserve">
          <source>Absolute &lt;code&gt;Time&lt;/code&gt; value. The &lt;code&gt;Time&lt;/code&gt; value is interpreted as an absolute Erlang monotonic time in milliseconds.</source>
          <target state="translated">절대 &lt;code&gt;Time&lt;/code&gt; 값. &lt;code&gt;Time&lt;/code&gt; 값은 밀리 초로 절대 얼랑 단조 시간으로 해석된다.</target>
        </trans-unit>
        <trans-unit id="6f0553231a05faffe297bc7acf9cdaa15d3ad0d6" translate="yes" xml:space="preserve">
          <source>Absolute maximum cache bad fit (in kilobytes). A segment in the memory segment cache is not reused if its size exceeds the requested size with more than the value of this parameter. Defaults to &lt;code&gt;4096&lt;/code&gt;.</source>
          <target state="translated">절대 최대 캐시에 맞지 않음 (킬로바이트). 메모리 세그먼트 캐시의 세그먼트는 크기가이 매개 변수 값보다 큰 값으로 요청 된 크기를 초과하는 경우 재사용되지 않습니다. 기본값은 &lt;code&gt;4096&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="06e7393a1c9fa0746c02d1ffbcea8603bb27631f" translate="yes" xml:space="preserve">
          <source>Absolute offset.</source>
          <target state="translated">절대 오프셋.</target>
        </trans-unit>
        <trans-unit id="44496adc987c03d870e59213dad3144a175329ee" translate="yes" xml:space="preserve">
          <source>Absolute singleblock carrier shrink threshold (in kilobytes). When a block located in an &lt;code&gt;mseg_alloc&lt;/code&gt; singleblock carrier is shrunk, the carrier is left unchanged if the amount of unused memory is less than this threshold, otherwise the carrier is shrunk. See also &lt;code&gt;&lt;a href=&quot;#M_rsbcst&quot;&gt;rsbcst&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">절대 단일 블록 캐리어 축소 임계 값 (KB). &lt;code&gt;mseg_alloc&lt;/code&gt; 단일 블록 캐리어 에 위치한 블록 이 축소 될 때, 사용되지 않은 메모리의 양이이 임계 값보다 작 으면 캐리어가 변경되지 않은 채로 남아 있고, 그렇지 않으면 캐리어가 축소됩니다. &lt;code&gt;&lt;a href=&quot;#M_rsbcst&quot;&gt;rsbcst&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff57be685f71df6825a00bb0dd0675ff72e59819" translate="yes" xml:space="preserve">
          <source>Absolute time-out time</source>
          <target state="translated">절대 시간 초과 시간</target>
        </trans-unit>
        <trans-unit id="87b7af24fbc7dca667aaef7cedf788bba72797a9" translate="yes" xml:space="preserve">
          <source>Abstract Data Type for SNMP Indexing</source>
          <target state="translated">SNMP 인덱싱을위한 추상 데이터 유형</target>
        </trans-unit>
        <trans-unit id="5609a156333d78829625afc9b9f892be80c713da" translate="yes" xml:space="preserve">
          <source>Abstract Erlang syntax trees.</source>
          <target state="translated">Erlang 구문 트리를 추상화합니다.</target>
        </trans-unit>
        <trans-unit id="0fc0a26f5661ecd86fced093abdeb714aebff28c" translate="yes" xml:space="preserve">
          <source>Abstract data type for FIFO queues.</source>
          <target state="translated">FIFO 대기열에 대한 추상 데이터 유형.</target>
        </trans-unit>
        <trans-unit id="0036b597c9166dc75f5f416f3d4f8e2976e568cd" translate="yes" xml:space="preserve">
          <source>Abstract datatype for the annotations of the Erlang Compiler.</source>
          <target state="translated">Erlang 컴파일러의 주석에 대한 추상 데이터 유형.</target>
        </trans-unit>
        <trans-unit id="60de543c8b0a2bf7a7b2b18c9b9c6e2e54182daa" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang clause.</source>
          <target state="translated">Erlang 절의 추상 형식.</target>
        </trans-unit>
        <trans-unit id="d6672e8badf7c19620dd4aaaf05ad582f5d5750e" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang expression.</source>
          <target state="translated">Erlang 표현식의 추상 형태.</target>
        </trans-unit>
        <trans-unit id="39fe847d06d62d8e80b55d37a59200693c709fd2" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang form.</source>
          <target state="translated">Erlang 양식의 추상 양식.</target>
        </trans-unit>
        <trans-unit id="b2f998c312eeafe0281400d148af41f390922671" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang type.</source>
          <target state="translated">Erlang 타입의 추상 형태.</target>
        </trans-unit>
        <trans-unit id="5a9b296f4df7477eb5b5b50aeb9d835778376408" translate="yes" xml:space="preserve">
          <source>Abstract representation of a generator or a bitstring generator.</source>
          <target state="translated">생성기 또는 비트 스트링 생성기의 추상 표현입니다.</target>
        </trans-unit>
        <trans-unit id="492e4e253beefd260963df05d99c417ca4290bfc" translate="yes" xml:space="preserve">
          <source>Abstract representation of a record field.</source>
          <target state="translated">레코드 필드의 추상 표현입니다.</target>
        </trans-unit>
        <trans-unit id="c00f2a5860c99ba7cb396e03f0dc272d78b0cc94" translate="yes" xml:space="preserve">
          <source>Abstract representation of a remote function call.</source>
          <target state="translated">원격 함수 호출의 추상 표현입니다.</target>
        </trans-unit>
        <trans-unit id="8f5c131fe9c0f70e4b39d2d2baddcf228a489a93" translate="yes" xml:space="preserve">
          <source>Abstract representation of an element of a bitstring.</source>
          <target state="translated">비트 문자열 요소의 추상 표현.</target>
        </trans-unit>
        <trans-unit id="06c262fbcd830c7cce729c33d7fe8e67175762f3" translate="yes" xml:space="preserve">
          <source>Accept a connection on a socket.</source>
          <target state="translated">소켓에서 연결을 수락합니다.</target>
        </trans-unit>
        <trans-unit id="cf4a58616d72eca00517c5490fb42e2012ac253a" translate="yes" xml:space="preserve">
          <source>Accept connections on the listen socket identified by &lt;code&gt;*ctx&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*ctx&lt;/code&gt; 로 식별되는 청취 소켓에서 연결을 수락합니다 .</target>
        </trans-unit>
        <trans-unit id="9e50abdb48c5e81f25cc8ea3044d328ca8ac2fce" translate="yes" xml:space="preserve">
          <source>Accept the connection.</source>
          <target state="translated">연결을 수락하십시오.</target>
        </trans-unit>
        <trans-unit id="f62959ef635bf54ce8db016df3aaff0dd63a1788" translate="yes" xml:space="preserve">
          <source>Accepts an incoming connection request on a listen socket. &lt;code&gt;ListenSocket&lt;/code&gt; must be a socket returned from &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt; listen/2&lt;/a&gt;&lt;/code&gt;. The socket returned is to be passed to &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt; handshake/[2,3]&lt;/a&gt;&lt;/code&gt; to complete handshaking, that is, establishing the TLS/DTLS connection.</source>
          <target state="translated">청취 소켓에서 들어오는 연결 요청을 수락합니다. &lt;code&gt;ListenSocket&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt; listen/2&lt;/a&gt;&lt;/code&gt; 에서 반환 된 소켓이어야합니다 . 반환 된 소켓은 &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt; handshake/[2,3]&lt;/a&gt;&lt;/code&gt; 에 전달되어 핸드 셰이크 를 완료합니다. 즉, TLS / DTLS 연결을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="632efb93ff14184018a35197a6178c2417c5bf58" translate="yes" xml:space="preserve">
          <source>Accepts an incoming connection request on a listen socket. &lt;code&gt;ListenSocket&lt;/code&gt; must be a socket returned from &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt;. The socket returned is to be passed to &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt; to complete handshaking, that is, establishing the SSL/TLS/DTLS connection.</source>
          <target state="translated">청취 소켓에서 들어오는 연결 요청을 수락합니다. &lt;code&gt;ListenSocket&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; 에서 반환 된 소켓이어야합니다 . 리턴 된 소켓은 &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt; 을 완료하기 위해, 즉 SSL / TLS / DTLS 연결을 설정 하기 위해 handshake / [2,3] 으로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="69d043ef57e7745987475e175cb8e488f0827aa5" translate="yes" xml:space="preserve">
          <source>Accepts an incoming connection request on a listening socket. &lt;code&gt;Socket&lt;/code&gt; must be a socket returned from &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;Timeout&lt;/code&gt; specifies a time-out value in milliseconds. Defaults to &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">청취 소켓에서 들어오는 연결 요청을 수락합니다. &lt;code&gt;Socket&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; 에서 반환 된 소켓 이어야합니다 . &lt;code&gt;Timeout&lt;/code&gt; 는 시간 초과 값을 밀리 초 단위로 지정합니다. 기본값은 &lt;code&gt;infinity&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0cebb4f984dd0627e66700aca28cb0e1a5e9b377" translate="yes" xml:space="preserve">
          <source>Accepts from the listen socket identified by the specified identification number. The identification number is retrieved with the &lt;code&gt;uds_control&lt;/code&gt; routine.</source>
          <target state="translated">지정된 식별 번호로 식별 된 청취 소켓에서 승인합니다. 식별 번호는 &lt;code&gt;uds_control&lt;/code&gt; 루틴으로 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="376e9046cc5fd2842ce29e30d9b75eab2742e487" translate="yes" xml:space="preserve">
          <source>Access Restrictions</source>
          <target state="translated">접근 제한</target>
        </trans-unit>
        <trans-unit id="804ff6a7ca49a544473ae24cb9339afd2154136e" translate="yes" xml:space="preserve">
          <source>Access globally registered names.</source>
          <target state="translated">세계적으로 등록 된 이름에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="119dea3e192ecc9326f47133ed54d5f5ec4367c3" translate="yes" xml:space="preserve">
          <source>Access rights must be set so that all nodes in the pool have the authority to access each other.</source>
          <target state="translated">풀의 모든 노드가 서로 액세스 할 수있는 권한을 갖도록 액세스 권한을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7a783c4df63409ddf4859d4d9c63884928a701bd" translate="yes" xml:space="preserve">
          <source>Access to TCP/IP protocols.</source>
          <target state="translated">TCP / IP 프로토콜에 액세스</target>
        </trans-unit>
        <trans-unit id="cb621788e34fed8e0f28301fdda0b265d5b636b7" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/cgi-bin/17/foo would cause the server to run the script /web/17/cgi-bin/foo.</source>
          <target state="translated">http://your.server.org/cgi-bin/17/foo에 액세스하면 서버가 / web / 17 / cgi-bin / foo 스크립트를 실행하게됩니다.</target>
        </trans-unit>
        <trans-unit id="a462746b4ce0075f7024ce8c93ee0d727108ca1e" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/cgi-bin/foo would cause the server to run the script /web/cgi-bin/foo.</source>
          <target state="translated">http://your.server.org/cgi-bin/foo에 액세스하면 서버가 / web / cgi-bin / foo 스크립트를 실행하게됩니다.</target>
        </trans-unit>
        <trans-unit id="50c06117af6e8e6670291bbfd27326b9ace3849a" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/docs/ would return http://your.server.org/docs/index.html or http://your.server.org/docs/welcome.html if index.html does not exist.</source>
          <target state="translated">http://your.server.org/docs/에 액세스하면 색인 인 경우 http://your.server.org/docs/index.html 또는 http://your.server.org/docs/welcome.html을 반환합니다. html이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55663d7fd0c514824e934bdabda94079e8fc90bd" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/image/foo.gif would refer to the file /ftp/pub/image/foo.gif.</source>
          <target state="translated">http://your.server.org/image/foo.gif에 대한 액세스는 /ftp/pub/image/foo.gif 파일을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="427eed565a2163db52b5b617c51105003a80c4da" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/~bob/foo.gif would refer to the file /home/bob/public/foo.gif.</source>
          <target state="translated">http://your.server.org/~bob/foo.gif에 대한 액세스는 /home/bob/public/foo.gif 파일을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="7455d0c1b31ee765842e7d4c484ec0f7dd272b9e" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/~bob/foo.gif would refer to the file /home/bob/public/foo.gif. In an Apache-like configuration file, &lt;code&gt;Re&lt;/code&gt; is separated from &lt;code&gt;Replacement&lt;/code&gt; with one single space, and as expected backslashes do not need to be backslash escaped, the same example would become:</source>
          <target state="translated">http://your.server.org/~bob/foo.gif에 대한 액세스는 /home/bob/public/foo.gif 파일을 참조합니다. Apache와 같은 구성 파일에서 &lt;code&gt;Re&lt;/code&gt; 는 하나의 단일 공간으로 &lt;code&gt;Replacement&lt;/code&gt; 와 분리 되며 예상되는 백 슬래시를 백 슬래시 이스케이프 할 필요가 없으므로 동일한 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5376bb41fa3654f4b966a3b6b6e89c5279df85f" translate="yes" xml:space="preserve">
          <source>AccessMod:all_keys(ActivityId, Opaque, Tab, LockKind)</source>
          <target state="translated">AccessMod : all_keys (ActivityId, 불투명, 탭, LockKind)</target>
        </trans-unit>
        <trans-unit id="6f94df94a3e7a36d86e327efa5167226380b0374" translate="yes" xml:space="preserve">
          <source>AccessMod:delete(ActivityId, Opaque, Tab, Key, LockKind)</source>
          <target state="translated">AccessMod : delete (ActivityId, 불투명, 탭, 키, LockKind)</target>
        </trans-unit>
        <trans-unit id="b5445c5aafa2ff9673bac795581de2bbc41c0c0f" translate="yes" xml:space="preserve">
          <source>AccessMod:delete_object(ActivityId, Opaque, Tab, RecXS, LockKind)</source>
          <target state="translated">AccessMod : delete_object (ActivityId, Opaque, Tab, RecXS, LockKind)</target>
        </trans-unit>
        <trans-unit id="3e7316c12d79f02736aee472f82ff47536afd350" translate="yes" xml:space="preserve">
          <source>AccessMod:first(ActivityId, Opaque, Tab)</source>
          <target state="translated">AccessMod : first (ActivityId, 불투명, 탭)</target>
        </trans-unit>
        <trans-unit id="b3f5ad115c23452c24775618b9441d204cbd0d17" translate="yes" xml:space="preserve">
          <source>AccessMod:index_match_object(ActivityId, Opaque, Tab, Pattern, Attr, LockKind)</source>
          <target state="translated">AccessMod : index_match_object (ActivityId, 불투명, 탭, 패턴, 속성, LockKind)</target>
        </trans-unit>
        <trans-unit id="64b8364a718a756d7a35ce5b28a17687b5f7875e" translate="yes" xml:space="preserve">
          <source>AccessMod:index_read(ActivityId, Opaque, Tab, SecondaryKey, Attr, LockKind)</source>
          <target state="translated">AccessMod : index_read (ActivityId, Opaque, Tab, SecondaryKey, Attr, LockKind)</target>
        </trans-unit>
        <trans-unit id="405ecfd3752c77ca520244aedede4b5587dbac66" translate="yes" xml:space="preserve">
          <source>AccessMod:last(ActivityId, Opaque, Tab)</source>
          <target state="translated">AccessMod : last (ActivityId, 불투명, 탭)</target>
        </trans-unit>
        <trans-unit id="0fe0be60df449ead6d34747d5036ed4f5deeb071" translate="yes" xml:space="preserve">
          <source>AccessMod:lock(ActivityId, Opaque, LockItem, LockKind)</source>
          <target state="translated">AccessMod : lock (ActivityId, 불투명, LockItem, LockKind)</target>
        </trans-unit>
        <trans-unit id="7f89b76e80a1cb03dd0d79dad619cfd7ed1b75a0" translate="yes" xml:space="preserve">
          <source>AccessMod:match_object(ActivityId, Opaque, Tab, Pattern, LockKind)</source>
          <target state="translated">AccessMod : match_object (ActivityId, 불투명, 탭, 패턴, LockKind)</target>
        </trans-unit>
        <trans-unit id="2eb39b70c8643684acb852d676bca64e66ecf08b" translate="yes" xml:space="preserve">
          <source>AccessMod:next(ActivityId, Opaque, Tab, Key)</source>
          <target state="translated">AccessMod : next (ActivityId, 불투명, 탭, 키)</target>
        </trans-unit>
        <trans-unit id="377e160f1491a996cf09b6412ddf1f19b01e4596" translate="yes" xml:space="preserve">
          <source>AccessMod:prev(ActivityId, Opaque, Tab, Key)</source>
          <target state="translated">AccessMod : prev (ActivityId, 불투명, 탭, 키)</target>
        </trans-unit>
        <trans-unit id="3240408ebba47649936190643d81115a2facdad7" translate="yes" xml:space="preserve">
          <source>AccessMod:read(ActivityId, Opaque, Tab, Key, LockKind)</source>
          <target state="translated">AccessMod : read (ActivityId, 불투명, 탭, 키, LockKind)</target>
        </trans-unit>
        <trans-unit id="f4ae75249d02d33c6b19d3db539b11ddf2e8c3b7" translate="yes" xml:space="preserve">
          <source>AccessMod:table_info(ActivityId, Opaque, Tab, InfoItem)</source>
          <target state="translated">AccessMod : table_info (ActivityId, Opaque, Tab, InfoItem)</target>
        </trans-unit>
        <trans-unit id="593b1df980f5bc3e0025a26bd60fd36b84ab2a86" translate="yes" xml:space="preserve">
          <source>AccessMod:write(ActivityId, Opaque, Tab, Rec, LockKind)</source>
          <target state="translated">AccessMod : write (ActivityId, Opaque, Tab, Rec, LockKind)</target>
        </trans-unit>
        <trans-unit id="21658514a1a49042d074927498970b49e42450f1" translate="yes" xml:space="preserve">
          <source>AccessMode :: write | read,</source>
          <target state="translated">AccessMode :: 쓰기 | 읽다,</target>
        </trans-unit>
        <trans-unit id="38bb0b3771b790d4a4246ea93a50f0538d3b9ae5" translate="yes" xml:space="preserve">
          <source>Accessing &lt;code&gt;Mnesia&lt;/code&gt; tables from a QLC list comprehension must always be done within a transaction. Consider the following function:</source>
          <target state="translated">QLC 목록 이해에서 &lt;code&gt;Mnesia&lt;/code&gt; 테이블에 액세스 하는 것은 항상 트랜잭션 내에서 수행해야합니다. 다음 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d4e0ceeb0457db320ec7c5e806ad2aa7f79465dd" translate="yes" xml:space="preserve">
          <source>Accessing an entry beyond the last set entry also returns the default value, if the array does not have fixed size:</source>
          <target state="translated">배열의 크기가 고정되어 있지 않으면 마지막 설정 항목 이외의 항목에 액세스하면 기본값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="555bba9fd6c14d06717b8dc43b3cc1f3a8debed5" translate="yes" xml:space="preserve">
          <source>Accessing an unset entry returns default value:</source>
          <target state="translated">설정되지 않은 항목에 액세스하면 기본값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="436be26b911d05b439e447f05501826f189bbbef" translate="yes" xml:space="preserve">
          <source>According to good practices certificates should not use IP-addresses as &quot;server names&quot;. It would be very surprising if this happen outside a closed network.</source>
          <target state="translated">모범 사례에 따르면 인증서는 IP 주소를 &quot;서버 이름&quot;으로 사용해서는 안됩니다. 폐쇄 된 네트워크 외부에서 이런 일이 발생하면 매우 놀랍습니다.</target>
        </trans-unit>
        <trans-unit id="89a4478d0cf104e90423519324b8b69d771bbee7" translate="yes" xml:space="preserve">
          <source>According to the myth, using a tail-recursive function that builds a list in reverse followed by a call to &lt;code id=&quot;tail_recursive&quot;&gt;lists:reverse/1&lt;/code&gt; is faster than a body-recursive function that builds the list in correct order; the reason being that body-recursive functions use more memory than tail-recursive functions.</source>
          <target state="translated">신화에 따르면, 역순으로 목록을 작성하는 꼬리 재귀 함수를 사용하고 그 다음에 목록을 호출하면 &lt;code id=&quot;tail_recursive&quot;&gt;lists:reverse/1&lt;/code&gt; 은 올바른 순서로 목록을 작성하는 본문 재귀 함수보다 빠릅니다. body-recursive 함수가 tail-recursive 함수보다 더 많은 메모리를 사용하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2c1de79f36acb95726c8b2c2f40931be25c53188" translate="yes" xml:space="preserve">
          <source>Accounting</source>
          <target state="translated">Accounting</target>
        </trans-unit>
        <trans-unit id="576eaeceb1da93e9cd8653f97cabbf793c67007b" translate="yes" xml:space="preserve">
          <source>Accounting AVP Table</source>
          <target state="translated">회계 AVP 테이블</target>
        </trans-unit>
        <trans-unit id="76507b1aa8142b5faffaa0f07c625ec43966a2b9" translate="yes" xml:space="preserve">
          <source>Accounting AVPs</source>
          <target state="translated">회계 AVP</target>
        </trans-unit>
        <trans-unit id="9a7ff18e07e31b5c000920070a2994c9d40115bb" translate="yes" xml:space="preserve">
          <source>Accounting Application Extension and Requirements</source>
          <target state="translated">회계 응용 프로그램 확장 및 요구 사항</target>
        </trans-unit>
        <trans-unit id="e635c0e384e30717aefe63c449ad41cb13b32539" translate="yes" xml:space="preserve">
          <source>Accounting Command Codes</source>
          <target state="translated">회계 명령 코드</target>
        </trans-unit>
        <trans-unit id="50de3db981430abf69687c31bfddbc582f239b78" translate="yes" xml:space="preserve">
          <source>Accounting Records</source>
          <target state="translated">회계 기록</target>
        </trans-unit>
        <trans-unit id="44b909aba948aa304a039b3c325904ad3054b180" translate="yes" xml:space="preserve">
          <source>Accounting Session State Machine</source>
          <target state="translated">회계 세션 상태 머신</target>
        </trans-unit>
        <trans-unit id="c15004aaef4f7a17d065e02f132efa0a95238fb5" translate="yes" xml:space="preserve">
          <source>Accounting is the responsibility of the user: diameter does not implement this state machine.</source>
          <target state="translated">회계는 사용자의 책임입니다. 직경은이 상태 머신을 구현하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3abb791315e4021643390d032dcd3ee861202b30" translate="yes" xml:space="preserve">
          <source>Accounting-Answer</source>
          <target state="translated">Accounting-Answer</target>
        </trans-unit>
        <trans-unit id="348fbc285b20d73c4251ffc831b8fc2daa3046c1" translate="yes" xml:space="preserve">
          <source>Accounting-Realtime-Required AVP</source>
          <target state="translated">회계 실시간 필수 AVP</target>
        </trans-unit>
        <trans-unit id="4913676d8f98f760d1dc436d2423796cf2783306" translate="yes" xml:space="preserve">
          <source>Accounting-Realtime-Required AVP Values</source>
          <target state="translated">회계 실시간 필수 AVP 값</target>
        </trans-unit>
        <trans-unit id="a41e3ac9cf5023d32cd91b4a3e716042b6c367b5" translate="yes" xml:space="preserve">
          <source>Accounting-Record-Number AVP</source>
          <target state="translated">회계 기록 번호 AVP</target>
        </trans-unit>
        <trans-unit id="b804c4b652a1521f5cb9135277fefe013043b5f6" translate="yes" xml:space="preserve">
          <source>Accounting-Record-Type AVP</source>
          <target state="translated">회계 기록 유형 AVP</target>
        </trans-unit>
        <trans-unit id="8df79aebdffebcd5564a4906eb6116d78fd976e9" translate="yes" xml:space="preserve">
          <source>Accounting-Record-Type AVP Values</source>
          <target state="translated">회계 기록 유형 AVP 값</target>
        </trans-unit>
        <trans-unit id="3f4954249bb9c6c0d9946303733718179dac9afc" translate="yes" xml:space="preserve">
          <source>Accounting-Request</source>
          <target state="translated">Accounting-Request</target>
        </trans-unit>
        <trans-unit id="cb2f33108011b0c4743b447ccd4a9acfb53d2777" translate="yes" xml:space="preserve">
          <source>Accounting-Sub-Session-Id AVP</source>
          <target state="translated">회계 서브 세션 ID AVP</target>
        </trans-unit>
        <trans-unit id="356f92ff6ca6eed8d6a653c61fd409eb10ae68df" translate="yes" xml:space="preserve">
          <source>Accounting-related messages and AVPs are defined in provided dictionaries. Their proper use is the user's responsibility.</source>
          <target state="translated">회계 관련 메시지 및 AVP는 제공된 사전에 정의되어 있습니다. 올바른 사용은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="4b31db96c0a841f9a7113ac5bbc52a214e1829fa" translate="yes" xml:space="preserve">
          <source>Acct-Application-Id AVP</source>
          <target state="translated">계정 신청 ID AVP</target>
        </trans-unit>
        <trans-unit id="4cabe3c0597d0d6af37709b22cdb0a59a5dae54e" translate="yes" xml:space="preserve">
          <source>Acct-Interim-Interval AVP</source>
          <target state="translated">계정-간격-간격 AVP</target>
        </trans-unit>
        <trans-unit id="1e0b1bf1afd755a9ceed94d413ee8713ddf31cc4" translate="yes" xml:space="preserve">
          <source>Acct-Multi-Session-Id AVP</source>
          <target state="translated">계정 다중 세션 ID AVP</target>
        </trans-unit>
        <trans-unit id="73a3b6a3e03bc80ba04f6bde167f6434da42cc10" translate="yes" xml:space="preserve">
          <source>Acct-Session-Id AVP</source>
          <target state="translated">계정 세션 ID AVP</target>
        </trans-unit>
        <trans-unit id="1a968060d9b2a6b964d729cfbd1eea55cfdc2c19" translate="yes" xml:space="preserve">
          <source>Accumulated waiting time for this lock. This could be greater than actual wall clock time, it is accumulated for all threads. Trylock conflicts does not accumulate time.</source>
          <target state="translated">이 잠금에 대한 누적 대기 시간입니다. 이것은 실제 벽시계 시간보다 클 수 있으며 모든 스레드에 대해 누적됩니다. Trylock 충돌은 시간을 누적하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9ecd9efddc0ef5836c8bbbde646a0d66732f097" translate="yes" xml:space="preserve">
          <source>Accumulates cover results over multiple tests. See section &lt;code&gt;&lt;a href=&quot;cover_chapter#cross_cover&quot;&gt;Cross Cover Analysis&lt;/a&gt;&lt;/code&gt; in the Users's Guide.</source>
          <target state="translated">여러 테스트에 대한 커버 결과를 누적합니다. 사용자 안내서의 &lt;code&gt;&lt;a href=&quot;cover_chapter#cross_cover&quot;&gt;Cross Cover Analysis&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="be2701277b8bc3bbce61a03a361606bf878d1187" translate="yes" xml:space="preserve">
          <source>Accuracy and precision of &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt; 의 정확성 및 정밀도</target>
        </trans-unit>
        <trans-unit id="875e7dcdc327d43caf0dcdf9d04b310d14d9feaf" translate="yes" xml:space="preserve">
          <source>Accuracy and precision of &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 의 정확성 및 정밀도</target>
        </trans-unit>
        <trans-unit id="58eae709361b11b3ca7bd3fc358b5d94391cf26b" translate="yes" xml:space="preserve">
          <source>Acknowledges the start of the port.</source>
          <target state="translated">포트의 시작을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="788233b34a130f2756fb1eaafa64431bb5c3d2da" translate="yes" xml:space="preserve">
          <source>Acknowledgment of a successful TLS handshake. &lt;code&gt;Ref&lt;/code&gt; is the reference() received in the &lt;code&gt;{diameter, {tls, Ref, Type, Bool}}&lt;/code&gt; message in response to which the reply is sent. A transport must exit if a handshake is not successful.</source>
          <target state="translated">성공적인 TLS 핸드 셰이크 승인. &lt;code&gt;Ref&lt;/code&gt; 는 응답이 전송 된 &lt;code&gt;{diameter, {tls, Ref, Type, Bool}}&lt;/code&gt; 메시지에 수신 된 reference () 입니다. 핸드 셰이크에 실패하면 전송을 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="f975f613537adf39477a68ad11e1dc4894dd6870" translate="yes" xml:space="preserve">
          <source>Action Mappings</source>
          <target state="translated">액션 매핑</target>
        </trans-unit>
        <trans-unit id="2440fec108b517d1d709ba90c75d4f7a63c7e81f" translate="yes" xml:space="preserve">
          <source>ActionCall ::= {ActionFunction} | {ActionFunction, ActionTerm, ...}</source>
          <target state="translated">ActionCall :: = {ActionFunction} | {ActionFunction, ActionTerm, ...}</target>
        </trans-unit>
        <trans-unit id="5590c86022b5bc14c1ea74cf910bca92aa274578" translate="yes" xml:space="preserve">
          <source>ActionFunction ::= &lt;code&gt;set_seq_token&lt;/code&gt; | &lt;code&gt;get_seq_token&lt;/code&gt; | &lt;code&gt;message&lt;/code&gt; | &lt;code&gt;return_trace&lt;/code&gt; | &lt;code&gt;exception_trace&lt;/code&gt; | &lt;code&gt;process_dump&lt;/code&gt; | &lt;code&gt;enable_trace&lt;/code&gt; | &lt;code&gt;disable_trace&lt;/code&gt; | &lt;code&gt;trace&lt;/code&gt; | &lt;code&gt;display&lt;/code&gt; | &lt;code&gt;caller&lt;/code&gt; | &lt;code&gt;set_tcw&lt;/code&gt; | &lt;code&gt;silent&lt;/code&gt;</source>
          <target state="translated">ActionFunction :: = &lt;code&gt;set_seq_token&lt;/code&gt; | &lt;code&gt;get_seq_token&lt;/code&gt; | &lt;code&gt;message&lt;/code&gt; | &lt;code&gt;return_trace&lt;/code&gt; | &lt;code&gt;exception_trace&lt;/code&gt; | &lt;code&gt;process_dump&lt;/code&gt; | &lt;code&gt;enable_trace&lt;/code&gt; | &lt;code&gt;disable_trace&lt;/code&gt; | &lt;code&gt;trace&lt;/code&gt; | &lt;code&gt;display&lt;/code&gt; | &lt;code&gt;caller&lt;/code&gt; | &lt;code&gt;set_tcw&lt;/code&gt; | &lt;code&gt;silent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51c493fd8bfe5291ac344e060529e5b42558f385" translate="yes" xml:space="preserve">
          <source>ActionTerm ::= ConditionExpression | ActionCall</source>
          <target state="translated">ActionTerm :: = ConditionExpression | 액션 콜</target>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="89ff6dbfdb936ca69e6587ae4d22e9a120904bf2" translate="yes" xml:space="preserve">
          <source>Actions :: [&lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt;] | &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt;) -&amp;gt;</source>
          <target state="translated">동작 :: [ &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt; ] | &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt; )-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="61334da16104ac9d91a8736e913a8cbee03e40e6" translate="yes" xml:space="preserve">
          <source>Actions are executed in the containing list order.</source>
          <target state="translated">작업은 포함 목록 순서로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4975204a056c5025b62a4a29c1e32e8f3dc531af" translate="yes" xml:space="preserve">
          <source>Actions that set &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt; transition options &lt;/a&gt;&lt;/code&gt; override any previous of the same type, so the last in the containing list wins. For example, the last &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; overrides any previous &lt;code&gt;postpone()&lt;/code&gt; in the list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt; transition options &lt;/a&gt;&lt;/code&gt; 을 설정하는 작업 은 동일한 유형의 이전 항목을 재정의하므로 포함 목록의 마지막 항목이 우선합니다. 예를 들어 마지막 &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; 은 목록의 이전 &lt;code&gt;postpone()&lt;/code&gt; 을 재정의 합니다.</target>
        </trans-unit>
        <trans-unit id="6ef0f3b4c93f31bddb43b327dd452b51df2f0936" translate="yes" xml:space="preserve">
          <source>Actions that set &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; override any previous of the same type, so the last in the containing list wins. For example, the last &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt; overrides any previous &lt;code&gt;event_timeout()&lt;/code&gt; in the list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; 을 설정하는 작업 은 동일한 유형의 이전 항목보다 우선하므로 포함 목록의 마지막 항목이 우선합니다. 예를 들어, 마지막 &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt; 은 목록의 이전 &lt;code&gt;event_timeout()&lt;/code&gt; 을 재정의 합니다.</target>
        </trans-unit>
        <trans-unit id="b1964869d062538b54d1a15f6f4171d706fef3d8" translate="yes" xml:space="preserve">
          <source>Actions that set &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; override any previous of the same type, so the last in the containing list wins. For example, the last &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; overrides any previous &lt;code&gt;postpone()&lt;/code&gt; in the list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; 을 설정하는 작업 은 동일한 유형의 이전 항목보다 우선하므로 포함 목록의 마지막 항목이 우선합니다. 예를 들어 마지막 &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; 은 목록의 이전 &lt;code&gt;postpone()&lt;/code&gt; 을 재정의 합니다.</target>
        </trans-unit>
        <trans-unit id="13b1df2d40bde8a02c4921e1004b0065de68e10c" translate="yes" xml:space="preserve">
          <source>Activates a connection to a remote user. When this is done the connection can be used to send messages (with SendMod:send_message/2). The ControlPid is the identifier of a process that controls the connection. That process will be supervised and if it dies, this will be detected and the UserMod:handle_disconnect/2 callback function will be invoked. See the megaco_user module for more info about the callback arguments. The connection may also explicitly be deactivated by invoking megaco:disconnect/2.</source>
          <target state="translated">원격 사용자에 대한 연결을 활성화합니다. 이 작업이 끝나면 연결을 사용하여 메시지를 보낼 수 있습니다 (SendMod : send_message / 2 사용). ControlPid는 연결을 제어하는 ​​프로세스의 식별자입니다. 해당 프로세스가 감독되고 프로세스가 종료되면이를 감지하고 UserMod : handle_disconnect / 2 콜백 함수가 호출됩니다. 콜백 인수에 대한 자세한 정보는 megaco_user 모듈을 참조하십시오. megaco : disconnect / 2를 호출하여 연결을 명시 적으로 비활성화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f69ba29b1f84217c9d2ca2dc152317da71e06308" translate="yes" xml:space="preserve">
          <source>Activates a new checkpoint covering all Mnesia tables, including the schema, with maximum degree of redundancy, and performs a backup using &lt;code&gt;backup_checkpoint/2/3&lt;/code&gt;. The default value of the backup callback module &lt;code&gt;BackupMod&lt;/code&gt; is obtained by &lt;code&gt;mnesia:system_info(backup_module)&lt;/code&gt;.</source>
          <target state="translated">최대 중복 정도로 스키마를 포함한 모든 Mnesia 테이블을 포괄하는 새로운 검사 점을 활성화하고 &lt;code&gt;backup_checkpoint/2/3&lt;/code&gt; 를 사용하여 백업을 수행합니다 . 백업 콜백 모듈 &lt;code&gt;BackupMod&lt;/code&gt; 의 기본값 은 &lt;code&gt;mnesia:system_info(backup_module)&lt;/code&gt; 의해 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="0574212bd6baf73e32ac9c415b72677146bade9b" translate="yes" xml:space="preserve">
          <source>Activates all events at the debug level. On this level, the &lt;code&gt;Mnesia&lt;/code&gt; event handler starts subscribing to updates on all &lt;code&gt;Mnesia&lt;/code&gt; tables. This level is intended only for debugging small toy systems, as many large events can be generated.</source>
          <target state="translated">디버그 수준에서 모든 이벤트를 활성화합니다. 이 레벨에서 &lt;code&gt;Mnesia&lt;/code&gt; 이벤트 핸들러는 모든 &lt;code&gt;Mnesia&lt;/code&gt; 테이블의 업데이트 구독을 시작합니다 . 이 레벨은 많은 큰 이벤트가 생성 될 수 있으므로 작은 장난감 시스템을 디버깅하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1473502b15ef43d2fc312f7968ec2627f8afe701" translate="yes" xml:space="preserve">
          <source>Activates all events at the debug level. On this level, the Mnesia event handler starts subscribing to updates on all Mnesia tables. This level is intended only for debugging small toy systems, as many large events can be generated.</source>
          <target state="translated">디버그 수준에서 모든 이벤트를 활성화합니다. 이 레벨에서 Mnesia 이벤트 핸들러는 모든 Mnesia 테이블의 업데이트 구독을 시작합니다. 이 레벨은 많은 큰 이벤트가 생성 될 수 있으므로 작은 장난감 시스템을 디버깅하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a11fef95fdd152ac782e603cddf000bf9537358d" translate="yes" xml:space="preserve">
          <source>Activates all events at the verbose level plus full trace of all debug events. These debug events generate &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; system events. Processes can subscribe to these events with &lt;code&gt;mnesia:subscribe/1&lt;/code&gt;. The events are always sent to the Mnesia event handler. On this debug level, the Mnesia event handler starts subscribing to updates in the schema table.</source>
          <target state="translated">자세한 수준의 모든 이벤트와 모든 디버그 이벤트의 전체 추적을 활성화합니다. 이러한 디버그 이벤트는 &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; 시스템 이벤트를 생성 합니다. 프로세스는 &lt;code&gt;mnesia:subscribe/1&lt;/code&gt; 로 이러한 이벤트를 구독 할 수 있습니다 . 이벤트는 항상 Mnesia 이벤트 핸들러로 전송됩니다. 이 디버그 레벨에서 Mnesia 이벤트 핸들러는 스키마 테이블의 업데이트 구독을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d10f11346b4f9c94838ab97da164ecb5b326c009" translate="yes" xml:space="preserve">
          <source>Activates all events at the verbose level plus traces of all debug events. These debug events generate &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; system events. Processes can subscribe to these events with &lt;code&gt;mnesia:subscribe/1&lt;/code&gt;. The events are always sent to the &lt;code&gt;Mnesia&lt;/code&gt; event handler. On this debug level, the &lt;code&gt;Mnesia&lt;/code&gt; event handler starts subscribing to updates in the schema table.</source>
          <target state="translated">상세 레벨의 모든 이벤트와 모든 디버그 이벤트의 추적을 활성화합니다. 이러한 디버그 이벤트는 &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; 시스템 이벤트를 생성 합니다. 프로세스는 &lt;code&gt;mnesia:subscribe/1&lt;/code&gt; 로 이러한 이벤트를 구독 할 수 있습니다 . 이벤트는 항상 &lt;code&gt;Mnesia&lt;/code&gt; 이벤트 핸들러로 전송됩니다 . 이 디버그 레벨에서 &lt;code&gt;Mnesia&lt;/code&gt; 이벤트 핸들러는 스키마 테이블의 업데이트 구독을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="6ded0de3f180c32378392899db72b086ca5f1741" translate="yes" xml:space="preserve">
          <source>Activates read data buffering. If &lt;code&gt;read/2&lt;/code&gt; calls are for significantly less than &lt;code&gt;Size&lt;/code&gt; bytes, read operations to the operating system are still performed for blocks of &lt;code&gt;Size&lt;/code&gt; bytes. The extra data is buffered and returned in subsequent &lt;code&gt;read/2&lt;/code&gt; calls, giving a performance gain as the number of operating system calls is reduced.</source>
          <target state="translated">읽기 데이터 버퍼링을 활성화합니다. 경우 &lt;code&gt;read/2&lt;/code&gt; 호출이 크게 미만위한 &lt;code&gt;Size&lt;/code&gt; 바이트, 여전히 블록에 대해 수행중인 운영 체제에 읽기 작업 &lt;code&gt;Size&lt;/code&gt; 바이트. 추가 데이터는 버퍼링되어 후속 &lt;code&gt;read/2&lt;/code&gt; 호출 에서 반환 되므로 운영 체제 호출 수가 줄어들면 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="eb6a9b28d658257a2883ec371985ebb9360570ed" translate="yes" xml:space="preserve">
          <source>Activates the fragmentation properties of an existing table. &lt;code&gt;FragProps&lt;/code&gt; is either to contain &lt;code&gt;{node_pool, Nodes}&lt;/code&gt; or be empty.</source>
          <target state="translated">기존 테이블의 조각화 속성을 활성화합니다. &lt;code&gt;FragProps&lt;/code&gt; 는 &lt;code&gt;{node_pool, Nodes}&lt;/code&gt; 를 포함 하거나 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="532f0aa046ec26e3e6682e682916731e989482e8" translate="yes" xml:space="preserve">
          <source>Activates tracing of important debug events. These events generate &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; system events. Processes can subscribe to these events with &lt;code&gt;mnesia:subscribe/1&lt;/code&gt;. The events are always sent to the Mnesia event handler.</source>
          <target state="translated">중요한 디버그 이벤트 추적을 활성화합니다. 이 이벤트는 &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; 시스템 이벤트를 생성 합니다. 프로세스는 &lt;code&gt;mnesia:subscribe/1&lt;/code&gt; 로 이러한 이벤트를 구독 할 수 있습니다 . 이벤트는 항상 Mnesia 이벤트 핸들러로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="e0f95d91404d34111854383ce61fa17d9871d976" translate="yes" xml:space="preserve">
          <source>Activates tracing of important debug events. These events generate &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; system events. Processes can subscribe to these events with the function &lt;code&gt;&lt;a href=&quot;mnesia#subscribe-1&quot;&gt;mnesia:subscribe/1&lt;/a&gt;&lt;/code&gt;. The events are always sent to the &lt;code&gt;Mnesia&lt;/code&gt; event handler.</source>
          <target state="translated">중요한 디버그 이벤트 추적을 활성화합니다. 이 이벤트는 &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; 시스템 이벤트를 생성 합니다. 프로세스는 &lt;code&gt;&lt;a href=&quot;mnesia#subscribe-1&quot;&gt;mnesia:subscribe/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 이러한 이벤트를 구독 할 수 있습니다 . 이벤트는 항상 &lt;code&gt;Mnesia&lt;/code&gt; 이벤트 핸들러로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="7f2c331b898e66e4e4d774932df99c6432852c98" translate="yes" xml:space="preserve">
          <source>Activates/deactivates tracing by changing the current trace pattern.</source>
          <target state="translated">현재 추적 패턴을 변경하여 추적을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="29f45195e4be19fb8b96702dcdd15944ea37fdad" translate="yes" xml:space="preserve">
          <source>Active breakpoints are displayed in red and inactive breakpoints in blue.</source>
          <target state="translated">활성 중단 점은 빨간색으로 표시되고 비활성 중단 점은 파란색으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2ec1ddc09f5f20f205f66ac493ee50b1fd7b2567" translate="yes" xml:space="preserve">
          <source>Activity Events</source>
          <target state="translated">활동 이벤트</target>
        </trans-unit>
        <trans-unit id="a903c4b66a2fb224f4d96a51df759ac9a67bfc6d" translate="yes" xml:space="preserve">
          <source>Activity concept and various access contexts</source>
          <target state="translated">활동 개념 및 다양한 액세스 컨텍스트</target>
        </trans-unit>
        <trans-unit id="713a8072ef62aa0b1fde6095af47e4a910316756" translate="yes" xml:space="preserve">
          <source>Actual protocol version.</source>
          <target state="translated">실제 프로토콜 버전.</target>
        </trans-unit>
        <trans-unit id="c3e87cfb1bb3f9be88098c653af2df64757bc8b0" translate="yes" xml:space="preserve">
          <source>Actual ticket age shall be less than the ticket lifetime (stateless session tickets contain the servers timestamp when the ticket was issued).</source>
          <target state="translated">실제 티켓 수명은 티켓 수명보다 짧아야합니다 (상태 비 저장 세션 티켓에는 티켓이 발행되었을 때 서버 타임 스탬프가 포함됨).</target>
        </trans-unit>
        <trans-unit id="91282b72e27e9203f0008e0bb427b78168c9ee89" translate="yes" xml:space="preserve">
          <source>Add 'makensis.exe' to your path environment:</source>
          <target state="translated">경로 환경에 'makensis.exe'를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="134344cda8fb9734c656b66e40554d208ac6e58b" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;-ct_hooks&lt;/code&gt; as an argument to &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt;. To add multiple CTHs using this method, append them to each other using the keyword &lt;code&gt;and&lt;/code&gt;, that is, &lt;code&gt;ct_run -ct_hooks cth1 [{debug,true}] and cth2 ...&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-ct_hooks&lt;/code&gt; 에 인수로 &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 추가하십시오 . 이 방법을 사용하여 여러 CTHs를 추가하려면, 키워드를 사용하여 서로를 추가 &lt;code&gt;and&lt;/code&gt; 있다, &lt;code&gt;ct_run -ct_hooks cth1 [{debug,true}] and cth2 ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c736205df679d1eb6863a5f647010553ce017bf9" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;Incr&lt;/code&gt; to atomic.</source>
          <target state="translated">원자에 &lt;code&gt;Incr&lt;/code&gt; 을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="d03f5ebcb056f1a256b52c0c938b58b71f342864" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;Incr&lt;/code&gt; to counter at index &lt;code&gt;Ix&lt;/code&gt;.</source>
          <target state="translated">인덱스 &lt;code&gt;Ix&lt;/code&gt; 에서 카운터에 &lt;code&gt;Incr&lt;/code&gt; 을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="d8718d4f36d948a3675c6bdc12db7b8c27966873" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;return_trace&lt;/code&gt; message if the function is of arity 3:</source>
          <target state="translated">함수가 arity 3 인 경우 &lt;code&gt;return_trace&lt;/code&gt; 메시지를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="dcfe51c34611d10c0d112932679c857d2a6476fa" translate="yes" xml:space="preserve">
          <source>Add a filter to the specified handler.</source>
          <target state="translated">지정된 핸들러에 필터를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="95b618e55bafddbb2a2984de23f6ce57bb36d2c0" translate="yes" xml:space="preserve">
          <source>Add a handler that prints &lt;code&gt;debug&lt;/code&gt; log events to a file, while the default handler prints only up to &lt;code&gt;notice&lt;/code&gt; level events to standard out.</source>
          <target state="translated">&lt;code&gt;debug&lt;/code&gt; 로그 이벤트를 파일에 인쇄하는 핸들러를 추가하는 반면 기본 핸들러는 &lt;code&gt;notice&lt;/code&gt; 수준 이벤트 까지만 표준 출력으로 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="988a7e297bf981c7e71c06b09b7717bd00d611be" translate="yes" xml:space="preserve">
          <source>Add a handler with the given configuration.</source>
          <target state="translated">주어진 구성으로 핸들러를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="07e4c199b9f19567f7bbd64299d17b2cc8c094ac" translate="yes" xml:space="preserve">
          <source>Add a primary filter to Logger.</source>
          <target state="translated">로거에 기본 필터를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="1970f7a8e650aa5473c699a8c07cc9a162ef1004" translate="yes" xml:space="preserve">
          <source>Add address (and port, if other than default) of the primary nameserver to use for &lt;code&gt;inet_res(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inet_res(3)&lt;/code&gt; 에 사용할 기본 네임 서버의 주소 (및 기본 포트가 아닌 경우 포트)를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="1cfc1bd9fd579f7622617b9af78a944445ba8847" translate="yes" xml:space="preserve">
          <source>Add address (and port, if other than default) of the secondary nameserver for &lt;code&gt;inet_res(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inet_res(3)&lt;/code&gt; 대한 보조 네임 서버의 주소 (및 기본값이 아닌 경우 포트)를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8a12963c05fa3aec6cf7012ff1f7fc0a2d99e08" translate="yes" xml:space="preserve">
          <source>Add an entry. The entry must not exist.</source>
          <target state="translated">항목을 추가하십시오. 항목이 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="6652a41804b950794ec5752c7d6fd942b05025cf" translate="yes" xml:space="preserve">
          <source>Add file and line number to log entries</source>
          <target state="translated">로그 항목에 파일 및 줄 번호 추가</target>
        </trans-unit>
        <trans-unit id="1e310729251dbd2e2aab36a457e446b150b20e5e" translate="yes" xml:space="preserve">
          <source>Add host entry to the hosts table.</source>
          <target state="translated">호스트 테이블에 호스트 항목을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="064eb4472489455e1a24510aa444bd6d5e585d65" translate="yes" xml:space="preserve">
          <source>Add javac &lt;strong&gt;LAST&lt;/strong&gt; to your path environment in bash, in my case this means:</source>
          <target state="translated">bash의 경로 환경에 javac &lt;strong&gt;LAST&lt;/strong&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="246e6fb32e5a050387dbde2f21177185267ea2d6" translate="yes" xml:space="preserve">
          <source>Add javac to your path environment, in my case this means:</source>
          <target state="translated">경로 환경에 javac를 추가하십시오. 제 경우에는 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3c0bb0d661a36f1c95bc663da03400bb07c43351" translate="yes" xml:space="preserve">
          <source>Add or update configuration data for the specified handler. If the given &lt;code&gt;Key&lt;/code&gt; already exists, its associated value will be changed to &lt;code&gt;Value&lt;/code&gt;. If it does not exist, it will be added.</source>
          <target state="translated">지정된 핸들러에 대한 구성 데이터를 추가하거나 업데이트하십시오. 주어진 &lt;code&gt;Key&lt;/code&gt; 이미 존재하면 연관된 값이 &lt;code&gt;Value&lt;/code&gt; 로 변경됩니다 . 존재하지 않는 경우 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7bc4a78cb8fcc809731f59f9c373269672f429fa" translate="yes" xml:space="preserve">
          <source>Add or update configuration data for the specified handler. If the given &lt;code&gt;Key&lt;/code&gt; already exists, its associated value will be changed to the given value. If it does not exist, it will be added.</source>
          <target state="translated">지정된 핸들러에 대한 구성 데이터를 추가하거나 업데이트합니다. 주어진 &lt;code&gt;Key&lt;/code&gt; 이미 존재하는 경우 연관된 값이 주어진 값으로 변경됩니다. 존재하지 않는 경우 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2e23ac8cf9bd396ad94605da91fe04cfdf9b6acd" translate="yes" xml:space="preserve">
          <source>Add or update primary configuration data for Logger. If the given &lt;code&gt;Key&lt;/code&gt; already exists, its associated value will be changed to &lt;code&gt;Value&lt;/code&gt;. If it does not exist, it will be added.</source>
          <target state="translated">로거의 기본 구성 데이터를 추가하거나 업데이트하십시오. 주어진 &lt;code&gt;Key&lt;/code&gt; 이미 존재하면 연관된 값이 &lt;code&gt;Value&lt;/code&gt; 로 변경됩니다 . 존재하지 않는 경우 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="21e8ff5c385c237ae3065c84dd8d4d8e0844640c" translate="yes" xml:space="preserve">
          <source>Add or update primary configuration data for Logger. If the given &lt;code&gt;Key&lt;/code&gt; already exists, its associated value will be changed to the given value. If it does not exist, it will be added.</source>
          <target state="translated">Logger에 대한 기본 구성 데이터를 추가하거나 업데이트합니다. 주어진 &lt;code&gt;Key&lt;/code&gt; 이미 존재하는 경우 연관된 값이 주어진 값으로 변경됩니다. 존재하지 않는 경우 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="fa1f218791abec296d536eef9aee8fee9c4907e8" translate="yes" xml:space="preserve">
          <source>Add search domains for &lt;code&gt;inet_res(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inet_res(3)&lt;/code&gt; 대한 검색 도메인을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ed69d0e5ae060c18a4527cc0780a8f4a4070ca5" translate="yes" xml:space="preserve">
          <source>Add tag &lt;code&gt;ct_hooks&lt;/code&gt; to your &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt; Test Specification&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt; Test Specification&lt;/a&gt;&lt;/code&gt; &lt;code&gt;ct_hooks&lt;/code&gt; 태그를 추가 합니다 .</target>
        </trans-unit>
        <trans-unit id="fd1016b584a0c08284e356371e0b67d2c6544a4a" translate="yes" xml:space="preserve">
          <source>Add tag &lt;code&gt;ct_hooks&lt;/code&gt; to your &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specification&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ct_hooks&lt;/code&gt; 태그 를 &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specification&lt;/a&gt;&lt;/code&gt; 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="62bfcf8bed94dcc27f1ebd702bd7df63f5908679" translate="yes" xml:space="preserve">
          <source>Add tag &lt;code&gt;ct_hooks&lt;/code&gt; to your call to &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 호출에 &lt;code&gt;ct_hooks&lt;/code&gt; 태그를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb8bd196c7c5b5791600663f12d69529068e2cf5" translate="yes" xml:space="preserve">
          <source>Add the &lt;code&gt;{scanner, flex}&lt;/code&gt; (or similar) directive to an Erlang system config file for the megaco app (see &lt;code&gt;&lt;a href=&quot;megaco_run#initial_config&quot;&gt;initial configuration&lt;/a&gt;&lt;/code&gt; chapter for details).</source>
          <target state="translated">추가 &lt;code&gt;{scanner, flex}&lt;/code&gt; (참조 MEGACO 응용 프로그램에 대한 얼랑 시스템 설정 파일 (또는 유사) 지침을 &lt;code&gt;&lt;a href=&quot;megaco_run#initial_config&quot;&gt;initial configuration&lt;/a&gt;&lt;/code&gt; 자세한 내용은 장).</target>
        </trans-unit>
        <trans-unit id="a2012ba10173073b8d6e03fc90ee362531d7db30" translate="yes" xml:space="preserve">
          <source>Add the applications Crypto, Public Key, and SSL with their current version numbers after the STDLIB application.</source>
          <target state="translated">STDLIB 애플리케이션 다음에 현재 버전 번호와 함께 애플리케이션 Crypto, 공개 키 및 SSL을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="3f47e924c15f0cebe23f7a60a12208b6f3fe188b" translate="yes" xml:space="preserve">
          <source>Add the engine to OpenSSL's internal list.</source>
          <target state="translated">OpenSSL의 내부 목록에 엔진을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="fc1eaff143827738e997da2b572220e89eec79fb" translate="yes" xml:space="preserve">
          <source>Add the filter</source>
          <target state="translated">필터 추가</target>
        </trans-unit>
        <trans-unit id="cf34fb9a5fda73afda9f1d571b702839ff2f58b3" translate="yes" xml:space="preserve">
          <source>Add the following directive to the module:</source>
          <target state="translated">다음 지시문을 모듈에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="497564ebabd956c895ba8a4ea1a4bb25e8ed7093" translate="yes" xml:space="preserve">
          <source>Add transport capability to a service.</source>
          <target state="translated">서비스에 전송 기능을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ae43487688376dc95ae859ba01f32a0ade700fa9" translate="yes" xml:space="preserve">
          <source>Add-On Application</source>
          <target state="translated">애드온 애플리케이션</target>
        </trans-unit>
        <trans-unit id="a34d04c7e63a5b637ab5047d8987b49d86783a46" translate="yes" xml:space="preserve">
          <source>Added in OTP 23.2</source>
          <target state="translated">OTP 23.2에 추가됨</target>
        </trans-unit>
        <trans-unit id="e83212da8655f0855cd75f303dd85d4cf0dc4e2d" translate="yes" xml:space="preserve">
          <source>Adding Own Actions</source>
          <target state="translated">자신의 작업 추가</target>
        </trans-unit>
        <trans-unit id="6a12811718bf0eb0d5f20cc44584c455597c9de0" translate="yes" xml:space="preserve">
          <source>Adding Patches</source>
          <target state="translated">패치 추가</target>
        </trans-unit>
        <trans-unit id="e1377afcaa6077fc60c3ef67a50fc7f61a7ad112" translate="yes" xml:space="preserve">
          <source>Adding Records and Relationships to Database</source>
          <target state="translated">데이터베이스에 레코드 및 관계 추가</target>
        </trans-unit>
        <trans-unit id="22ba7777616ece673914dfbc3af9096a68b87e29" translate="yes" xml:space="preserve">
          <source>Adding an application means that the modules defined by the &lt;code&gt;modules&lt;/code&gt; key in the &lt;code&gt;.app&lt;/code&gt; file are loaded using &lt;code&gt;add_module&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램을 추가한다는 것은 &lt;code&gt;.app&lt;/code&gt; 파일 에서 &lt;code&gt;modules&lt;/code&gt; 키로 정의 된 모듈 이 &lt;code&gt;add_module&lt;/code&gt; 을 사용하여로드 됨을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="19baa62e86ec3c161512eb728cf268b6e381fb8a" translate="yes" xml:space="preserve">
          <source>Adding an application means that the modules defined by the &lt;code&gt;modules&lt;/code&gt; key in the &lt;code&gt;.app&lt;/code&gt; file are loaded using a number of &lt;code&gt;add_module&lt;/code&gt; instructions, and then the application is started.</source>
          <target state="translated">응용 프로그램을 추가한다는 것은 &lt;code&gt;.app&lt;/code&gt; 파일 에서 &lt;code&gt;modules&lt;/code&gt; 키로 정의 된 모듈 이 여러 &lt;code&gt;add_module&lt;/code&gt; 명령어를 사용하여로드 된 다음 응용 프로그램이 시작됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6dd28665b92c3d1eafe29d80d8f4b9041dfdeca0" translate="yes" xml:space="preserve">
          <source>Adding and Deleting Child Processes</source>
          <target state="translated">하위 프로세스 추가 및 삭제</target>
        </trans-unit>
        <trans-unit id="4a2fed64edcf79517387cddb884610573fd90ba1" translate="yes" xml:space="preserve">
          <source>Adding patches</source>
          <target state="translated">패치 추가</target>
        </trans-unit>
        <trans-unit id="9aa3df6db85161c52e69b8f34d6e3268949dc0a1" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;fop&lt;/code&gt; script (in &lt;code&gt;$FOP_HOME&lt;/code&gt;) to your &lt;code&gt;$PATH&lt;/code&gt;, either by adding &lt;code&gt;$FOP_HOME&lt;/code&gt; to &lt;code&gt;$PATH&lt;/code&gt;, or by copying the &lt;code&gt;fop&lt;/code&gt; script to a directory already in your &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">추가 중 &lt;code&gt;fop&lt;/code&gt; 스크립트 (에서 &lt;code&gt;$FOP_HOME&lt;/code&gt; 당신에게) &lt;code&gt;$PATH&lt;/code&gt; , 하나 추가하여 &lt;code&gt;$FOP_HOME&lt;/code&gt; 에 &lt;code&gt;$PATH&lt;/code&gt; 또는 복사하여 &lt;code&gt;fop&lt;/code&gt; 당신의 이미 디렉토리에 스크립트를 &lt;code&gt;$PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38751bf8e4b616e26910db8b22c357a8c20a53f2" translate="yes" xml:space="preserve">
          <source>Adding the location of your installation of &lt;code&gt;fop&lt;/code&gt; in &lt;code&gt;$FOP_HOME&lt;/code&gt;.</source>
          <target state="translated">의 설치 위치 추가 &lt;code&gt;fop&lt;/code&gt; 에 &lt;code&gt;$FOP_HOME&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab0b27d891b1318285ee4899ad6b140de6e4ed3b" translate="yes" xml:space="preserve">
          <source>Additional information and links of interest for Erlang programmers can be found on the Erlang Open Source site &lt;a href=&quot;http://www.erlang.org/&quot;&gt;http://www.erlang.org&lt;/a&gt;.</source>
          <target state="translated">Erlang 프로그래머를위한 추가 정보 및 관심 링크는 Erlang 오픈 소스 사이트 &lt;a href=&quot;http://www.erlang.org/&quot;&gt;http://www.erlang.org&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6afdeb8447e9059c599becedc9101b844f957850" translate="yes" xml:space="preserve">
          <source>Additionally, values that can be encoded are limited by way of their encoding as four octets as required by RFC 6733 with the required extension from RFC 2030. In particular, only values between &lt;code&gt;{{1968,1,20},{3,14,8}}&lt;/code&gt; and &lt;code&gt;{{2104,2,26},{9,42,23}}&lt;/code&gt; (both inclusive) can be encoded.</source>
          <target state="translated">또한 인코딩 할 수있는 값은 RFC 2030의 필수 확장을 사용하여 RFC 6733에 필요한대로 4 옥텟으로 인코딩하여 제한됩니다. 특히 &lt;code&gt;{{1968,1,20},{3,14,8}}&lt;/code&gt; 및 &lt;code&gt;{{2104,2,26},{9,42,23}}&lt;/code&gt; (모두 포함)을 인코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb4f94d5cabe0fc39f4035959e69499b50e9e3b2" translate="yes" xml:space="preserve">
          <source>Address-to-name translation in a protocol-independant manner.</source>
          <target state="translated">프로토콜 독립적 인 방식으로 주소-이름 변환.</target>
        </trans-unit>
        <trans-unit id="74fda4b3ec4ffdc7738f6833bc3191a5b59bbcea" translate="yes" xml:space="preserve">
          <source>Addresses as inputs to functions can be either a string or a tuple. For example, the IP address 150.236.20.73 can be passed to &lt;code&gt;gethostbyaddr/1&lt;/code&gt;, either as string &lt;code&gt;&quot;150.236.20.73&quot;&lt;/code&gt; or as tuple &lt;code&gt;{150, 236, 20, 73}&lt;/code&gt;.</source>
          <target state="translated">함수에 대한 입력으로서의 주소는 문자열 또는 튜플 일 수 있습니다. 예를 들어, IP 주소 150.236.20.73은 문자열 &lt;code&gt;&quot;150.236.20.73&quot;&lt;/code&gt; 또는 튜플 &lt;code&gt;{150, 236, 20, 73}&lt;/code&gt; 으로 &lt;code&gt;gethostbyaddr/1&lt;/code&gt; 에 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6ffba73db48bc15c7ed64cbfce1198067c6f6ff" translate="yes" xml:space="preserve">
          <source>Addresses besides &lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt; ip_address() &lt;/a&gt;&lt;/code&gt; ones that are returned from socket API functions. See in particular &lt;code&gt;&lt;a href=&quot;#type-local_address&quot;&gt; local_address(). &lt;/a&gt;&lt;/code&gt; The &lt;code&gt;unspec&lt;/code&gt; family corresponds to AF_UNSPEC and can occur if the other side has no socket address. The &lt;code&gt;undefined&lt;/code&gt; family can only occur in the unlikely event of an address family that the VM does not recognize.</source>
          <target state="translated">소켓 API 함수에서 반환되는 &lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt; ip_address() &lt;/a&gt;&lt;/code&gt; 외의 주소 . 특히 &lt;code&gt;&lt;a href=&quot;#type-local_address&quot;&gt; local_address(). &lt;/a&gt;&lt;/code&gt; 참조하십시오 . &lt;code&gt;unspec&lt;/code&gt; 가족은 AF_UNSPEC에 해당하고, 다른 쪽이 더 소켓 주소가없는 경우 발생할 수 있습니다. &lt;code&gt;undefined&lt;/code&gt; 가족은 VM이 인식하지 못하는 주소 가족의 드문 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="919ffc168cee16019d09aa5279148893d8d24a34" translate="yes" xml:space="preserve">
          <source>Addresses besides &lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt;ip_address()&lt;/a&gt;&lt;/code&gt; ones that are returned from socket API functions. See in particular &lt;code&gt;&lt;a href=&quot;#type-local_address&quot;&gt;local_address().&lt;/a&gt;&lt;/code&gt; The &lt;code&gt;unspec&lt;/code&gt; family corresponds to AF_UNSPEC and can occur if the other side has no socket address. The &lt;code&gt;undefined&lt;/code&gt; family can only occur in the unlikely event of an address family that the VM does not recognize.</source>
          <target state="translated">소켓 API 함수에서 반환되는 &lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt;ip_address()&lt;/a&gt;&lt;/code&gt; 이외의 주소 특히 &lt;code&gt;&lt;a href=&quot;#type-local_address&quot;&gt;local_address().&lt;/a&gt;&lt;/code&gt; 참조하십시오 . &lt;code&gt;unspec&lt;/code&gt; 가족은 AF_UNSPEC에 해당하고, 다른 쪽이 더 소켓 주소가없는 경우 발생할 수 있습니다. &lt;code&gt;undefined&lt;/code&gt; 가족은 VM이 인식하지 못하는 주소 가족의 드문 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5d78a2b44c9f8c46bb6a05a403783dea60e8b77" translate="yes" xml:space="preserve">
          <source>Addresses to the test plant or other instruments</source>
          <target state="translated">테스트 플랜트 또는 기타 기기에 대한 주소</target>
        </trans-unit>
        <trans-unit id="e2dc16d39802f8e13757680f2285e270d512d4d0" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Dir&lt;/code&gt; to the beginning of the code path. If &lt;code&gt;Dir&lt;/code&gt; exists, it is removed from the old position in the code path.</source>
          <target state="translated">코드 경로의 시작 부분에 &lt;code&gt;Dir&lt;/code&gt; 을 추가합니다 . &lt;code&gt;Dir&lt;/code&gt; 이 있으면 코드 경로의 이전 위치에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="926f262a813d5bf3968371cfef08e827663b2a16" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Dir&lt;/code&gt; to the code path. The directory is added as the last directory in the new path. If &lt;code&gt;Dir&lt;/code&gt; already exists in the path, it is not added.</source>
          <target state="translated">코드 경로에 &lt;code&gt;Dir&lt;/code&gt; 을 추가합니다 . 디렉토리는 새 경로의 마지막 디렉토리로 추가됩니다. 경우 &lt;code&gt;Dir&lt;/code&gt; 이미 경로에 존재, 그것은 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca41b9b5a14be7cc19bac8bafe3b381efcc40caa" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Dir&lt;/code&gt; to the list of directories to be searched when including a file. When encountering an &lt;code&gt;-include&lt;/code&gt; or &lt;code&gt;-include_lib&lt;/code&gt; directive, the compiler searches for header files in the following directories:</source>
          <target state="translated">파일을 포함 할 때 검색 할 디렉토리 목록에 &lt;code&gt;Dir&lt;/code&gt; 을 추가합니다 . &lt;code&gt;-include&lt;/code&gt; 또는 &lt;code&gt;-include_lib&lt;/code&gt; 지시문 이 발생하면 컴파일러는 다음 디렉토리에서 헤더 파일을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="5307e57c8c5d61db386c45a450b3023f9b59e82e" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;IncludeDir&lt;/code&gt; to the search-path for &lt;code&gt;.asn1db&lt;/code&gt; and &lt;code&gt;ASN.1&lt;/code&gt; source files. The compiler tries to open an &lt;code&gt;.asn1db&lt;/code&gt; file when a module imports definitions from another &lt;code&gt;ASN.1&lt;/code&gt; module. If no &lt;code&gt;.asn1db&lt;/code&gt; file is found, the &lt;code&gt;ASN.1&lt;/code&gt; source file is parsed. Several &lt;code&gt;{i, IncludeDir}&lt;/code&gt; can be given.</source>
          <target state="translated">&lt;code&gt;.asn1db&lt;/code&gt; 및 &lt;code&gt;ASN.1&lt;/code&gt; 소스 파일 의 검색 경로에 &lt;code&gt;IncludeDir&lt;/code&gt; 을 추가합니다 . 모듈이 다른 &lt;code&gt;ASN.1&lt;/code&gt; 모듈 에서 정의를 &lt;code&gt;.asn1db&lt;/code&gt; 때 컴파일러는 .asn1db 파일 을 열려고 시도 합니다. &lt;code&gt;.asn1db&lt;/code&gt; 파일이 없으면 &lt;code&gt;ASN.1&lt;/code&gt; 소스 파일이 구문 분석됩니다. 여러 개의 &lt;code&gt;{i, IncludeDir}&lt;/code&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="595c4b05c70f5ee3afd4c0ee71bd2a9507a8d8e9" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Increment&lt;/code&gt; to the value associated with &lt;code&gt;Key&lt;/code&gt; and store this value. If &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary, &lt;code&gt;Increment&lt;/code&gt; is stored as the first value.</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; 와 연관된 값에 &lt;code&gt;Increment&lt;/code&gt; 을 추가 하고이 값을 저장하십시오. 경우 &lt;code&gt;Key&lt;/code&gt; 사전에 존재하지 않는, &lt;code&gt;Increment&lt;/code&gt; 최초 값으로 저장된다.</target>
        </trans-unit>
        <trans-unit id="9cf5a5933a7780d09616786318d8b162063b8502" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Increment&lt;/code&gt; to the value associated with &lt;code&gt;Key&lt;/code&gt; and stores this value. If &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary, &lt;code&gt;Increment&lt;/code&gt; is stored as the first value.</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; 와 연관된 값에 &lt;code&gt;Increment&lt;/code&gt; 을 추가 하고이 값을 저장합니다. 경우 &lt;code&gt;Key&lt;/code&gt; 사전에 존재하지 않는, &lt;code&gt;Increment&lt;/code&gt; 최초 값으로 저장된다.</target>
        </trans-unit>
        <trans-unit id="608d4ac3b1f40dea43a70f3ee04cd69ef181057c" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;Slave&lt;/code&gt; node to the list of allowed slave hosts.</source>
          <target state="translated">허용 된 슬레이브 호스트 목록에 &lt;code&gt;Slave&lt;/code&gt; 노드를 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="c8419b1c93b9fd6c91cbede4425bbc8634cca3f1" translate="yes" xml:space="preserve">
          <source>Adds a USM security data (user) to the agent config. Equivalent to one line in the &lt;code&gt;usm.conf&lt;/code&gt; file.</source>
          <target state="translated">USM 보안 데이터 (사용자)를 에이전트 구성에 추가합니다. &lt;code&gt;usm.conf&lt;/code&gt; 파일의 한 줄과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="608718b6fe3ec7101404f6c3f283054c442dd2b4" translate="yes" xml:space="preserve">
          <source>Adds a access definition to the agent config. Equivalent to one vacmAccess-line in the &lt;code&gt;vacm.conf&lt;/code&gt; file.</source>
          <target state="translated">에이전트 구성에 액세스 정의를 추가합니다. &lt;code&gt;vacm.conf&lt;/code&gt; 파일 에있는 하나의 vacmAccess-line과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="56be82c63eeffefdb9fecc96c8582dde485169c1" translate="yes" xml:space="preserve">
          <source>Adds a comment to the zip archive.</source>
          <target state="translated">Zip 아카이브에 주석을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="43e098c039b116cd95896a1756a343c44df7c071" translate="yes" xml:space="preserve">
          <source>Adds a community to the agent config. Equivalent to one line in the &lt;code&gt;community.conf&lt;/code&gt; file.</source>
          <target state="translated">에이전트 구성에 커뮤니티를 추가합니다. &lt;code&gt;community.conf&lt;/code&gt; 파일의 한 줄과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="45955c71ab38b246ddf99aa7e08be1cf306c82b3" translate="yes" xml:space="preserve">
          <source>Adds a context to the agent config. Equivalent to one line in the &lt;code&gt;context.conf&lt;/code&gt; file.</source>
          <target state="translated">에이전트 구성에 컨텍스트를 추가합니다. &lt;code&gt;context.conf&lt;/code&gt; 파일의 한 줄과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6c32cf7ccbd49be4e1811292b2c307f4eba42f61" translate="yes" xml:space="preserve">
          <source>Adds a driver entry to the list of drivers known by Erlang. The &lt;code&gt;&lt;a href=&quot;driver_entry#init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; function of parameter &lt;code&gt;de&lt;/code&gt; is called.</source>
          <target state="translated">Erlang에 알려진 드라이버 목록에 드라이버 항목을 추가합니다. 매개 변수 &lt;code&gt;de&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;driver_entry#init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 기능 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d07970fe182b9d81897e40e78d3b14e7a4e7a0d7" translate="yes" xml:space="preserve">
          <source>Adds a file to a tar file that has been opened for writing by &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; 로 쓰기 위해 열린 tar 파일에 파일을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="b2fca474d01b00ce9ba861cfe769df64577ac35b" translate="yes" xml:space="preserve">
          <source>Adds a file to a tar file that has been opened for writing by &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;. This function accepts the same options as &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 로 쓰기 위해 열린 tar 파일에 파일을 추가합니다 . 이 함수는 &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3&lt;/a&gt;&lt;/code&gt; 와 동일한 옵션을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="5eccbecba42ae4288806c579ad8b8fbf3b51a728" translate="yes" xml:space="preserve">
          <source>Adds a fragment to a fragmented table. All records in one of the old fragments are rehashed and about half of them are moved to the new (last) fragment. All other fragmented tables, which refer to this table in their foreign key, automatically get a new fragment. Also, their records are dynamically rehashed in the same manner as for the main table.</source>
          <target state="translated">조각난 테이블에 조각을 추가합니다. 오래된 조각 중 하나의 모든 레코드가 다시 해시되고 그 중 절반이 새로운 (마지막) 조각으로 이동됩니다. 외래 키에서이 테이블을 참조하는 다른 모든 조각화 된 테이블은 자동으로 새 조각을 가져옵니다. 또한 해당 레코드는 기본 테이블과 동일한 방식으로 동적으로 다시 해시됩니다.</target>
        </trans-unit>
        <trans-unit id="d84d2fb93ae834309e6167a0b3e43d9fab2545e1" translate="yes" xml:space="preserve">
          <source>Adds a host key to the set of trusted host keys.</source>
          <target state="translated">신뢰할 수있는 호스트 키 세트에 호스트 키를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2d77c18b4124fe87017036ce4362ca94cf644272" translate="yes" xml:space="preserve">
          <source>Adds a module and its &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;. The module will not be member of any application. Returns the name of the module.</source>
          <target state="translated">모듈 및 해당 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; . 모듈은 응용 프로그램의 구성원이 아닙니다. 모듈 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="32c8a7869e19433d754f5fcd1913f72de6ee2803" translate="yes" xml:space="preserve">
          <source>Adds a new &lt;code&gt;Key&lt;/code&gt; to the process dictionary, associated with the value &lt;code&gt;Val&lt;/code&gt;, and returns &lt;code&gt;undefined&lt;/code&gt;. If &lt;code&gt;Key&lt;/code&gt; exists, the old value is deleted and replaced by &lt;code&gt;Val&lt;/code&gt;, and the function returns the old value. Example:</source>
          <target state="translated">값 &lt;code&gt;Val&lt;/code&gt; 과 연관된 프로세스 &lt;code&gt;Key&lt;/code&gt; 에 새 키 를 추가하고 &lt;code&gt;undefined&lt;/code&gt; 를 리턴합니다 . 경우 &lt;code&gt;Key&lt;/code&gt; 존재 이전 값은 삭제로 대체 &lt;code&gt;Val&lt;/code&gt; 하고,이 함수는, 이전의 값을 돌려줍니다. 예:</target>
        </trans-unit>
        <trans-unit id="72a77907fe15211efb4ac1705211f4a6082a3750" translate="yes" xml:space="preserve">
          <source>Adds a new event handler in the same way as &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt;, but also supervises the connection between the event handler and the calling process.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; 와 같은 방식으로 새 이벤트 핸들러를 추가 하고 이벤트 핸들러와 호출 프로세스 간의 연결을 감독합니다.</target>
        </trans-unit>
        <trans-unit id="e9446fd51850eeb6666eac3dc67fdb3d82b72082" translate="yes" xml:space="preserve">
          <source>Adds a new event handler to event manager &lt;code&gt;EventMgrRef&lt;/code&gt;. The event manager calls &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; to initiate the event handler and its internal state.</source>
          <target state="translated">이벤트 관리자 &lt;code&gt;EventMgrRef&lt;/code&gt; 에 새 이벤트 핸들러를 추가합니다 . 이벤트 관리자는 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 을 호출 하여 이벤트 핸들러 및 내부 상태를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="be923232cecb872d45d1007a0378c8bbbe25c6cc" translate="yes" xml:space="preserve">
          <source>Adds a new event handler to the error logger. The event handler must be implemented as a &lt;code&gt;gen_event&lt;/code&gt; callback module, see &lt;code&gt;gen_event(3)&lt;/code&gt;.</source>
          <target state="translated">오류 로거에 새 이벤트 핸들러를 추가합니다. 이벤트 핸들러는 &lt;code&gt;gen_event&lt;/code&gt; 콜백 모듈 로 구현되어야합니다 &lt;code&gt;gen_event(3)&lt;/code&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="346f98f933f954790f0ea34b8324039679ac74dd" translate="yes" xml:space="preserve">
          <source>Adds a node to &lt;code&gt;node_pool&lt;/code&gt;. The new node pool affects the list returned from the function &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_dist)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;node_pool&lt;/code&gt; 에 노드를 추가합니다 . 새 노드 풀은 &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_dist)&lt;/a&gt;&lt;/code&gt; 함수에서 리턴 된 목록에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="35b3eb9263608d380a272fe1f7c6c1eafd65bf84" translate="yes" xml:space="preserve">
          <source>Adds a notify definition to the agent config. Equivalent to one line in the &lt;code&gt;notify.conf&lt;/code&gt; file.</source>
          <target state="translated">에이전트 구성에 알림 정의를 추가합니다. &lt;code&gt;notify.conf&lt;/code&gt; 파일의 한 줄과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="13890bf5b34b3baf9845e8775db87c295022c6ec" translate="yes" xml:space="preserve">
          <source>Adds a phony target for each dependency.</source>
          <target state="translated">각 종속성에 대한 가짜 대상을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="07656b9ba19395d09fa6add9f69eacc86c1efcdf" translate="yes" xml:space="preserve">
          <source>Adds a reference to resource object &lt;code&gt;obj&lt;/code&gt; obtained from &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt; enif_alloc_resource&lt;/a&gt;&lt;/code&gt;. Each call to &lt;code&gt;enif_keep_resource&lt;/code&gt; for an object must be balanced by a call to &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt; enif_release_resource&lt;/a&gt;&lt;/code&gt; before the object is destructed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt; enif_alloc_resource&lt;/a&gt;&lt;/code&gt; 에서 얻은 자원 객체 &lt;code&gt;obj&lt;/code&gt; 에 대한 참조를 추가합니다 . 개체에 대한 &lt;code&gt;enif_keep_resource&lt;/code&gt; 에 대한 각 호출 은 개체가 소멸되기 전에 &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt; enif_release_resource&lt;/a&gt;&lt;/code&gt; 에 대한 호출로 균형을 이루어야합니다 .</target>
        </trans-unit>
        <trans-unit id="29b1ac0ca171003684f30d397e314620318042ec" translate="yes" xml:space="preserve">
          <source>Adds a reference to resource object &lt;code&gt;obj&lt;/code&gt; obtained from &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt;. Each call to &lt;code&gt;enif_keep_resource&lt;/code&gt; for an object must be balanced by a call to &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; before the object is destructed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt; 에서 확보 한 자원 오브젝트 &lt;code&gt;obj&lt;/code&gt; 에 대한 참조를 추가합니다 . 를 호출 할 때마다 &lt;code&gt;enif_keep_resource&lt;/code&gt; 객체에 대한이의 호출에 의해 균형을 이루어야한다 &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; 객체가 파괴되기 전에.</target>
        </trans-unit>
        <trans-unit id="ac2aa5a6a26bf2accad0209a44849095d34310fd" translate="yes" xml:space="preserve">
          <source>Adds a release, the applications of the release, the modules of the applications, and &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; of the modules to an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;. The applications will be members of the release, and the modules will be members of the applications. The default is to use the base name of the directory as release name, but this can be overridden by the &lt;code&gt;name&lt;/code&gt; option. Returns the name of the release.</source>
          <target state="translated">릴리스, 릴리스의 응용 프로그램, 응용 프로그램의 모듈 및 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; . 응용 프로그램은 릴리스의 구성원이되고 모듈은 응용 프로그램의 구성원이됩니다. 기본적으로 디렉토리의 기본 이름을 릴리스 이름으로 사용하지만 &lt;code&gt;name&lt;/code&gt; 옵션으로 이를 대체 할 수 있습니다 . 릴리스 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5963e0eadddadc6570ac86b11276f6f4e83b3156" translate="yes" xml:space="preserve">
          <source>Adds a security to group definition to the agent config. Equivalent to one vacmSecurityToGroup-line in the &lt;code&gt;vacm.conf&lt;/code&gt; file.</source>
          <target state="translated">에이전트 구성에 그룹 정의에 보안을 추가합니다. &lt;code&gt;vacm.conf&lt;/code&gt; 파일 에서 하나의 vacmSecurityToGroup-line과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d4f785833568b0e86ada1e532e1405f500e20a42" translate="yes" xml:space="preserve">
          <source>Adds a small tag to each allocated block that contains basic information about what it is and who allocated it. See &lt;code&gt;&lt;a href=&quot;#M_atags&quot;&gt;+M&amp;lt;S&amp;gt;atags&lt;/a&gt;&lt;/code&gt; for a more complete description.</source>
          <target state="translated">정의 된 내용과 할당 된 사람에 대한 기본 정보가 포함 된 각 할당 된 블록에 작은 태그를 추가합니다. 더 자세한 설명 은 &lt;code&gt;&lt;a href=&quot;#M_atags&quot;&gt;+M&amp;lt;S&amp;gt;atags&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0dfd9dbecdeed6491e670fb60727a24505e80431" translate="yes" xml:space="preserve">
          <source>Adds a small tag to each allocated block that contains basic information about what it is and who allocated it. Use the &lt;code&gt;instrument&lt;/code&gt; module to inspect this information.</source>
          <target state="translated">정의 된 내용과 할당 된 사람에 대한 기본 정보가 포함 된 각 할당 된 블록에 작은 태그를 추가합니다. &lt;code&gt;instrument&lt;/code&gt; 모듈을 사용 하여이 정보를 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="e4864b206394f8b2d7b76e4230a5c12a58cc9d0e" translate="yes" xml:space="preserve">
          <source>Adds a target address definition to the agent config. Equivalent to one line in the &lt;code&gt;target_addr.conf&lt;/code&gt; file.</source>
          <target state="translated">에이전트 구성에 대상 주소 정의를 추가합니다. &lt;code&gt;target_addr.conf&lt;/code&gt; 파일의 한 줄과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="82b2d6b8384860d53fc589e045f4515d51086799" translate="yes" xml:space="preserve">
          <source>Adds a target parameter definition to the agent config. Equivalent to one line in the &lt;code&gt;target_params.conf&lt;/code&gt; file.</source>
          <target state="translated">에이전트 구성에 대상 매개 변수 정의를 추가합니다. &lt;code&gt;target_params.conf&lt;/code&gt; 파일의 한 줄과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5794b16429f3c188c00edeb3043c4596518ea624" translate="yes" xml:space="preserve">
          <source>Adds a view tree family definition to the agent config. Equivalent to one vacmViewTreeFamily-line in the &lt;code&gt;vacm.conf&lt;/code&gt; file.</source>
          <target state="translated">에이전트 트리 구성에 뷰 트리 제품군 정의를 추가합니다. &lt;code&gt;vacm.conf&lt;/code&gt; 파일 에서 하나의 vacmViewTreeFamily-line과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="10d0b1e780ad0788836f31276e65ce6efb15e764" translate="yes" xml:space="preserve">
          <source>Adds an application, the modules of the application and &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; of the modules to an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;. The modules will be members of the application. The default is to use the base name of the directory with the version removed as application name, but this can be overridden by the &lt;code&gt;name&lt;/code&gt; option. Returns the name of the application.</source>
          <target state="translated">응용 프로그램, 응용 프로그램 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 및 모듈의 모듈 데이터 를 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; . 모듈은 응용 프로그램의 구성원이됩니다. 기본값은 버전이 응용 프로그램 이름으로 제거 된 디렉토리의 기본 이름을 사용하지만 &lt;code&gt;name&lt;/code&gt; 옵션 으로 대체 될 수 있습니다 . 응용 프로그램의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="110ffd01521ffa85d725f633c684562720f4ba39" translate="yes" xml:space="preserve">
          <source>Adds binding &lt;code&gt;Name=Value&lt;/code&gt; to &lt;code&gt;BindingStruct&lt;/code&gt;. Returns an updated binding structure.</source>
          <target state="translated">바인딩 &lt;code&gt;Name=Value&lt;/code&gt; 를 &lt;code&gt;BindingStruct&lt;/code&gt; 에 추가합니다 . 업데이트 된 바인딩 구조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="166b6b5a44b378b7ef528300e6dd1ab66edcbe83" translate="yes" xml:space="preserve">
          <source>Adds nodes to current cover test. Notice that this only works if cover support is active.</source>
          <target state="translated">현재 커버 테스트에 노드를 추가합니다. 이것은 표지 지원이 활성화 된 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ebbd57f6aab385f9f5cefe84013bbde0f94bd2a8" translate="yes" xml:space="preserve">
          <source>Adds optional capabilities and sends a &lt;code&gt;hello&lt;/code&gt; message to the server and waits for the return.</source>
          <target state="translated">선택적 기능을 추가 하고 서버에 &lt;code&gt;hello&lt;/code&gt; 메시지를 보내고 리턴을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="f4e867c0e696fbab1087c9d79da2f2d90aa8bb6f" translate="yes" xml:space="preserve">
          <source>Adds or updates annotations on nodes in a syntax tree. &lt;code&gt;Bindings&lt;/code&gt; specifies the set of bound variables in the environment of the top level node. The following annotations are affected:</source>
          <target state="translated">구문 트리에서 노드의 주석을 추가하거나 업데이트합니다. &lt;code&gt;Bindings&lt;/code&gt; 은 최상위 노드 환경에서 바인딩 된 변수 세트를 지정합니다. 다음 주석이 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="b3ac712b8a650dd6e42451afed1ca538238431c7" translate="yes" xml:space="preserve">
          <source>Adds or updates annotations on nodes in a syntax tree. Equivalent to &lt;code&gt;annotate_bindings(Tree, Bindings)&lt;/code&gt; where the top-level environment &lt;code&gt;Bindings&lt;/code&gt; is taken from the annotation &lt;code&gt;{env, Bindings}&lt;/code&gt; on the root node of &lt;code&gt;Tree&lt;/code&gt;. An exception is thrown if no such annotation should exist.</source>
          <target state="translated">구문 트리에서 노드의 주석을 추가하거나 업데이트합니다. 최상위 환경 &lt;code&gt;Bindings&lt;/code&gt; 이 &lt;code&gt;Tree&lt;/code&gt; 의 루트 노드에있는 주석 &lt;code&gt;{env, Bindings}&lt;/code&gt; 에서 가져온 &lt;code&gt;annotate_bindings(Tree, Bindings)&lt;/code&gt; 와 같습니다 . 그러한 주석이 존재하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7bbf9ca1c736db15763a8239f95f4d5c1b66558d" translate="yes" xml:space="preserve">
          <source>Adds the directories in &lt;code&gt;Dirs&lt;/code&gt; to the end of the code path. If a &lt;code&gt;Dir&lt;/code&gt; exists, it is not added.</source>
          <target state="translated">&lt;code&gt;Dirs&lt;/code&gt; 의 디렉토리를 코드 경로의 끝에 추가합니다 . &lt;code&gt;Dir&lt;/code&gt; 이 있으면 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8d419cc2314f6341b04eb8bad24bf2f277d7f87" translate="yes" xml:space="preserve">
          <source>Adds the modules found in the given directory and the &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;modules' data&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;. The default is not to examine subdirectories, but if the option &lt;code&gt;recurse&lt;/code&gt; has the value &lt;code&gt;true&lt;/code&gt;, modules are searched for in subdirectories on all levels as well as in the given directory. Returns a sorted list of the names of the added modules.</source>
          <target state="translated">주어진 디렉토리에서 찾은 모듈과 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;modules' data&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; . 기본값은 서브 디렉토리를 검사하는 것이 아니지만 옵션 &lt;code&gt;recurse&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 값을 갖는 경우 , 주어진 디렉토리뿐만 아니라 모든 레벨의 서브 디렉토리에서 모듈을 검색합니다. 추가 된 모듈 이름의 정렬 된 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="34d712dcc34471fdb6acaa22554dc0975d1f5dc6" translate="yes" xml:space="preserve">
          <source>Adds the registered name of the process. This can be useful when tracing on many nodes, as processes with that name are then traced on all traced nodes.</source>
          <target state="translated">프로세스의 등록 된 이름을 추가합니다. 이 이름을 가진 프로세스가 모든 추적 노드에서 추적되므로 많은 노드에서 추적 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bbf14dbe70908fe6ce0549e066a68aa359629b3" translate="yes" xml:space="preserve">
          <source>Adds the selected process and all processes below, right of it, to tab &lt;strong&gt;Trace Overview&lt;/strong&gt;.</source>
          <target state="translated">선택된 프로세스 및 프로세스 아래의 모든 프로세스를 &lt;strong&gt;추적 개요&lt;/strong&gt; 탭에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="3fcbc67018c8db0d7d54f40db7c26439211fb94f" translate="yes" xml:space="preserve">
          <source>Adds the selected process identifier to tab &lt;strong&gt;Trace Overview&lt;/strong&gt; plus the node that the process resides on.</source>
          <target state="translated">선택된 프로세스 식별자를 &lt;strong&gt;추적 개요&lt;/strong&gt; 탭 과 프로세스가 상주하는 노드에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="31b3e1e7afc7441a8de7e4b30d8d409a2bd10a0f" translate="yes" xml:space="preserve">
          <source>Adds the specified directories to the beginning of the code path, similar to &lt;code&gt; code:add_pathsa/1&lt;/code&gt;. Note that the order of the given directories will be reversed in the resulting path.</source>
          <target state="translated">&lt;code&gt; code:add_pathsa/1&lt;/code&gt; 과 유사하게 코드 경로의 시작 부분에 지정된 디렉토리를 추가합니다 . 주어진 디렉토리의 순서는 결과 경로에서 반전됩니다.</target>
        </trans-unit>
        <trans-unit id="3aebb82fdca9aa95c0538fef0af13a3b616d5fe2" translate="yes" xml:space="preserve">
          <source>Adds the specified directories to the beginning of the code path, similar to &lt;code&gt;code:add_pathsa/1&lt;/code&gt;. Note that the order of the given directories will be reversed in the resulting path.</source>
          <target state="translated">&lt;code&gt;code:add_pathsa/1&lt;/code&gt; 과 유사하게 지정된 경로를 코드 경로의 시작 부분에 추가합니다 . 주어진 디렉토리의 순서는 결과 경로에서 반전됩니다.</target>
        </trans-unit>
        <trans-unit id="0a1c883186e0d00a77adaf41f013ddc82c811398" translate="yes" xml:space="preserve">
          <source>Adds the specified directories to the end of the code path, similar to &lt;code&gt;code:add_pathsz/1&lt;/code&gt;; see &lt;code&gt;code(3)&lt;/code&gt;.</source>
          <target state="translated">code와 유사하게 &lt;code&gt;code:add_pathsz/1&lt;/code&gt; 경로 끝에 지정된 디렉토리를 추가합니다 . add_pathsz / 1 ; &lt;code&gt;code(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d2e0e96fcba01247b2f834ed2a0365db181f6d4" translate="yes" xml:space="preserve">
          <source>Adds the specified primary filters.</source>
          <target state="translated">지정된 기본 필터를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d613e82163d56d8326249e8169f52e84f75a04cb" translate="yes" xml:space="preserve">
          <source>Adds these extensions to the list of compress extensions.</source>
          <target state="translated">이러한 확장을 압축 확장 목록에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="25822e567273ecdc04d1dd713da5a9ee0671d675" translate="yes" xml:space="preserve">
          <source>Adds these extensions to the list of uncompress extensions.</source>
          <target state="translated">이 확장을 압축 해제 확장 목록에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2f502d97e1ab810c3754afd45a8594c92efa30f8" translate="yes" xml:space="preserve">
          <source>Adds to &lt;code&gt;Forms&lt;/code&gt; the code for the standard pre-defined functions (such as &lt;code&gt;module_info/0&lt;/code&gt;) that are to be included in every module.</source>
          <target state="translated">추가로 &lt;code&gt;Forms&lt;/code&gt; (예컨대 표준 사전 정의 된 함수 코드 &lt;code&gt;module_info/0&lt;/code&gt; 모든 모듈을 포함하여야한다).</target>
        </trans-unit>
        <trans-unit id="bb8f1512f2d702beeef48e8c7223a0b1dde1e4a0" translate="yes" xml:space="preserve">
          <source>Adjust the process(&quot;beam&quot;) reference to your beam version and attach the script to a running &quot;beam&quot; instance:</source>
          <target state="translated">빔 버전에 대한 프로세스 ( &quot;beam&quot;) 참조를 조정하고 실행중인 &quot;beam&quot;인스턴스에 스크립트를 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="c57f256463601b2a2c62f254f5126bfecb16a4d2" translate="yes" xml:space="preserve">
          <source>Adjusts the SSH flow control window. This is to be done by both the client- and server-side channel processes.</source>
          <target state="translated">SSH 흐름 제어 창을 조정합니다. 이는 클라이언트 및 서버 측 채널 프로세스 모두에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="980e8823b26ab3a416e4eec330a78a5f567d8a4d" translate="yes" xml:space="preserve">
          <source>Affects SSL-3.0 and TLS-1.0 connections only. Used to change the BEAST mitigation strategy to interoperate with legacy software. Defaults to &lt;code&gt;one_n_minus_one&lt;/code&gt;.</source>
          <target state="translated">SSL-3.0 및 TLS-1.0 연결에만 영향을줍니다. 기존 소프트웨어와 상호 운용되도록 BEAST 완화 전략을 변경하는 데 사용됩니다. 기본값은 &lt;code&gt;one_n_minus_one&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c6004ea02cc23d09682422b618c26d349782aa93" translate="yes" xml:space="preserve">
          <source>Affects TLS-1.0 connections only. If set to &lt;code&gt;false&lt;/code&gt;, it disables the block cipher padding check to be able to interoperate with legacy software.</source>
          <target state="translated">TLS-1.0 연결에만 영향을줍니다. &lt;code&gt;false&lt;/code&gt; 로 설정 하면 블록 암호 패딩 검사를 비활성화하여 레거시 소프트웨어와 상호 운용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="debeed9026878cefb793f6e84d87d4b3c12ed8e6" translate="yes" xml:space="preserve">
          <source>Affects TLS-1.0 connections only. Used to change the BEAST mitigation strategy to interoperate with legacy software. Defaults to &lt;code&gt;one_n_minus_one&lt;/code&gt;.</source>
          <target state="translated">TLS-1.0 연결에만 영향을줍니다. 기존 소프트웨어와 상호 운용되도록 BEAST 완화 전략을 변경하는 데 사용됩니다. 기본값은 &lt;code&gt;one_n_minus_one&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4b6ffc59171bd18b8e61a3e781dab573deabf10a" translate="yes" xml:space="preserve">
          <source>Affects ports to external programs on Windows only. The standard input and standard output handles of the port program are, if this option is supplied, opened with flag &lt;code&gt;FILE_FLAG_OVERLAPPED&lt;/code&gt;, so that the port program can (and must) do overlapped I/O on its standard handles. This is not normally the case for simple port programs, but an option of value for the experienced Windows programmer. &lt;strong&gt;On all other platforms, this option is silently discarded.&lt;/strong&gt;</source>
          <target state="translated">Windows의 외부 프로그램에 대한 포트에만 영향을줍니다. 포트 프로그램의 표준 입력 및 표준 출력 핸들은이 옵션이 제공되면 플래그 &lt;code&gt;FILE_FLAG_OVERLAPPED&lt;/code&gt; 와 함께 열리 므로 포트 프로그램은 표준 핸들에서 겹친 I / O를 수행 할 수 있습니다. 이것은 일반적으로 간단한 포트 프로그램의 경우가 아니라 숙련 된 Windows 프로그래머에게 유용한 옵션입니다. &lt;strong&gt;다른 모든 플랫폼에서는이 옵션이 자동으로 삭제됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf4fb0d4263b60ac21dc80f51c2dec3dcfb5747e" translate="yes" xml:space="preserve">
          <source>Affects ports to external programs. The executed program gets its standard error file redirected to its standard output file. &lt;code&gt;stderr_to_stdout&lt;/code&gt; and &lt;code&gt;nouse_stdio&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">외부 프로그램에 대한 포트에 영향을줍니다. 실행 된 프로그램은 표준 오류 파일을 표준 출력 파일로 리디렉션합니다. &lt;code&gt;stderr_to_stdout&lt;/code&gt; 과 &lt;code&gt;nouse_stdio&lt;/code&gt; 는 상호 배타적입니다.</target>
        </trans-unit>
        <trans-unit id="1e538da53759cfec60cd8a151505e38fb92a9633" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1089&quot;&gt;all terms&lt;/a&gt;&lt;/code&gt; referenced by the root-set have been copied, the collector scans the &lt;strong&gt;to space&lt;/strong&gt; and copies all terms that these terms reference. When scanning, the collector steps through each term on the &lt;strong&gt;to space&lt;/strong&gt; and any term still referencing the &lt;strong&gt;from space&lt;/strong&gt; is copied over to the &lt;strong&gt;to space&lt;/strong&gt;. Some terms contain non-term data (the payload of a on heap binary for instance). When encountered by the collector, these values are simply skipped.</source>
          <target state="translated">후 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1089&quot;&gt;all terms&lt;/a&gt;&lt;/code&gt; 루트 세트에 의해 참조가 복사 된, 콜렉터는 스캔 &lt;strong&gt;공간&lt;/strong&gt; 이 용어는 참조 할 것을 복사 모든 조건을. 스캔 할 때 수집기는 &lt;strong&gt;to 공간의&lt;/strong&gt; 각 용어를 단계별로 살펴 보고 &lt;strong&gt;from 공간을&lt;/strong&gt; 참조하는 용어 는 &lt;strong&gt;to &lt;/strong&gt;&lt;strong&gt;공간&lt;/strong&gt; 으로 복사 &lt;strong&gt;됩니다&lt;/strong&gt; . 일부 용어에는 비 기간 데이터 (예 : 힙 바이너리의 페이로드)가 포함됩니다. 수집기에서 이러한 값을 발견하면 단순히 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="76c066b0f9a1e6496e99cead0881b8f872728f45" translate="yes" xml:space="preserve">
          <source>After LTTng is properly installed on the system Erlang/OTP can be built with LTTng support.</source>
          <target state="translated">시스템에 LTTng을 올바르게 설치 한 후 LTTng를 지원하여 Erlang / OTP를 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="093311043e9bea9fbc9705d1e98f8e3acfd08364" translate="yes" xml:space="preserve">
          <source>After STDLIB 3.4 (OTP 20.0) compiled match specifications have an external representation as a node specific reference to the original compiled match specification. If passed through &lt;code&gt;binary_to_term(term_to_binary(CMS))&lt;/code&gt; or sent to another node and back, the result &lt;strong&gt;may or may not&lt;/strong&gt; be a valid compiled match specification depending on if the original compiled match specification was still alive.</source>
          <target state="translated">STDLIB 3.4 (OTP 20.0) 이후 컴파일 된 일치 스펙에는 원래 컴파일 된 일치 스펙에 대한 노드 특정 참조로 외부 표현이 있습니다. &lt;code&gt;binary_to_term(term_to_binary(CMS))&lt;/code&gt; 통해 전달 되거나 다른 노드로 전송 된 경우 원래 컴파일 된 일치 사양이 아직 살아 있는지 여부에 따라 결과 &lt;strong&gt;가&lt;/strong&gt; 유효한 컴파일 된 일치 사양 &lt;strong&gt;일 수도 있고 아닐&lt;/strong&gt; 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1facbcf11ae5793aa1bc80ef16d286aebd0fc34d" translate="yes" xml:space="preserve">
          <source>After \0 up to two further octal digits are read. If there are fewer than two digits, just those that are present are used. Thus the sequence \0\x\015 specifies two binary zeros followed by a CR character (code value 13). Make sure you supply two digits after the initial zero if the pattern character that follows is itself an octal digit.</source>
          <target state="translated">\ 0 이후에 최대 두 개의 8 진수를 더 읽습니다. 두 자리 미만의 숫자가 있으면 존재하는 숫자 만 사용됩니다. 따라서 \ 0 \ x \ 015 시퀀스는 2 개의 이진수 0과 CR 문자 (코드 값 13)를 차례로 지정합니다. 뒤 따르는 패턴 문자가 8 진수 인 경우 초기 0 뒤에 두 자리 숫자를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec54f9531929f3cd1ca22e8febfcaf52fc58636a" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;&lt;a href=&quot;#crypto_final-1&quot;&gt;crypto_final/1&lt;/a&gt;&lt;/code&gt; it contains the number of bytes padded. Otherwise 0.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#crypto_final-1&quot;&gt;crypto_final/1&lt;/a&gt;&lt;/code&gt; 호출 후 패딩 된 바이트 수가 포함됩니다. 그렇지 않으면 0.</target>
        </trans-unit>
        <trans-unit id="d732389ea2448ab3a2fa3d0a36ca3e321f1eb8c8" translate="yes" xml:space="preserve">
          <source>After a partial match or a failed match, the last encountered name in the entire match process is returned, for example:</source>
          <target state="translated">부분 일치 또는 실패한 일치 후 전체 일치 프로세스에서 마지막으로 발생한 이름이 반환됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5fc9546102b17d8235883e41d7c9f9c95505b3d1" translate="yes" xml:space="preserve">
          <source>After a succesful incoming authentication, a new process runs as the just authenticated user.</source>
          <target state="translated">수신 인증이 성공적으로 완료되면 방금 인증 된 사용자로 새 프로세스가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a46c18eae1ac24b22616197a0acee7d1074a413c" translate="yes" xml:space="preserve">
          <source>After a successful authentication an</source>
          <target state="translated">성공적인 인증 후</target>
        </trans-unit>
        <trans-unit id="18ee0e3703c2647b03b1406f234f9cc3d123429d" translate="yes" xml:space="preserve">
          <source>After adding more records to the &lt;code&gt;Company&lt;/code&gt; database, the result can be the following records:</source>
          <target state="translated">&lt;code&gt;Company&lt;/code&gt; 데이터베이스에 더 많은 레코드를 추가 한 후 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="93fdc04d975de9f436b576b59d005bc9bf8bf315" translate="yes" xml:space="preserve">
          <source>After all name servers have been tried, there is a timeout before the name servers are tried again. This is to prevent the server from answering the query with what's in the servfail cache, &lt;code&gt;inet_res(3)&lt;/code&gt;. Defaults to 1500 milli seconds .</source>
          <target state="translated">모든 이름 서버를 시도한 후 이름 서버를 다시 시도하기 전에 시간 초과가 있습니다. 이것은 서버가 servfail 캐시 &lt;code&gt;inet_res(3)&lt;/code&gt; 에있는 내용으로 쿼리에 응답하는 것을 방지하기위한 것 입니다. 기본값은 1500 밀리 초입니다.</target>
        </trans-unit>
        <trans-unit id="22669be288b8402f937e20a5b4c0d8be02ada8ae" translate="yes" xml:space="preserve">
          <source>After an analysis, you can inspect this information. In the &lt;strong&gt;PLT&lt;/strong&gt; menu you can choose to either search the PLT or inspect the contents of the whole PLT. The information is presented in &lt;code&gt;EDoc&lt;/code&gt; format.</source>
          <target state="translated">분석 후이 정보를 검사 할 수 있습니다. &lt;strong&gt;PLT&lt;/strong&gt; 메뉴 에서 &lt;strong&gt;PLT&lt;/strong&gt; 를 검색하거나 전체 PLT의 내용을 검사하도록 선택할 수 있습니다. 정보는 &lt;code&gt;EDoc&lt;/code&gt; 형식으로 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="6ef9c0c6bbe4e27c696f859b427107c4e849d03c" translate="yes" xml:space="preserve">
          <source>After any post hook has been executed for all installed CTHs, &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:on_tc_fail-4&quot;&gt;on_tc_fail&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:on_tc_skip-4&quot;&gt;on_tc_skip&lt;/a&gt;&lt;/code&gt; is called if the testcase failed or was skipped, respectively. You cannot affect the outcome of the tests any further at this point.</source>
          <target state="translated">설치된 모든 CTH에 대해 포스트 후크가 실행 된 후 테스트 케이스가 각각 실패하거나 건너 뛴 경우 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:on_tc_fail-4&quot;&gt;on_tc_fail&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:on_tc_skip-4&quot;&gt;on_tc_skip&lt;/a&gt;&lt;/code&gt; 가 호출됩니다. 이 시점에서 더 이상 테스트 결과에 영향을 줄 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f056750b4e33f30fb9d5942f6265a2d4f346b9dc" translate="yes" xml:space="preserve">
          <source>After at least one tab-character, the line added is to contain the full name of the named pipe where &lt;code&gt;syslogd&lt;/code&gt; writes its information. The path must be the same as for the files &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; and &lt;code&gt;syslog.conf.OTP&lt;/code&gt;. The filename must be &lt;code&gt;syslog.otp&lt;/code&gt;.</source>
          <target state="translated">하나 이상의 탭 문자 다음에 추가되는 행에는 &lt;code&gt;syslogd&lt;/code&gt; 가 정보를 쓰는 이름 지정된 파이프의 전체 이름이 포함 됩니다. 경로는 &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; 및 &lt;code&gt;syslog.conf.OTP&lt;/code&gt; 파일의 경로와 같아야합니다 . 파일 이름은 &lt;code&gt;syslog.otp&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5ce4ab81087082fd95156bdaf8c2e0786410e8e3" translate="yes" xml:space="preserve">
          <source>After completing all the normal building steps described above a debug enabled runtime system can be built. To do this you have to change directory to &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; and execute:</source>
          <target state="translated">위에서 설명한 모든 일반적인 빌드 단계를 완료 한 후 디버그 가능 런타임 시스템을 빌드 할 수 있습니다. 이렇게하려면 디렉토리를 &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; 하고 다음을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="9cd742cd300933dfb65e0a535f4d15de36d37f01" translate="yes" xml:space="preserve">
          <source>After decoding a message various user callback functions are invoked in order to allow the user to act properly. See the megaco_user module for more info about the callback arguments.</source>
          <target state="translated">메시지를 디코딩 한 후, 사용자가 올바르게 행동 할 수 있도록 다양한 사용자 콜백 함수가 호출됩니다. 콜백 인수에 대한 자세한 정보는 megaco_user 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dc240b1130d5df1612bf5772e5400cd74e1cad80" translate="yes" xml:space="preserve">
          <source>After flag fields for atom cache references, another half byte flag field is located with the following format:</source>
          <target state="translated">아톰 캐시 참조에 대한 플래그 필드 뒤에 다른 하프 바이트 플래그 필드는 다음 형식으로 위치합니다.</target>
        </trans-unit>
        <trans-unit id="8aca18c81b4ecc6e98bd69677c9d22a41d1f8407" translate="yes" xml:space="preserve">
          <source>After initialization, you set up the connection to the Erlang node. To specify the Erlang node you want to connect to, use &lt;code&gt;erl_connect()&lt;/code&gt;. The following example sets up the connection and is to result in a valid socket file descriptor:</source>
          <target state="translated">초기화 후 Erlang 노드에 대한 연결을 설정합니다. 연결하려는 Erlang 노드를 지정하려면 &lt;code&gt;erl_connect()&lt;/code&gt; 사용 하십시오 . 다음 예제는 연결을 설정하고 유효한 소켓 파일 설명자를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d230e040d4a295e72e3f66c85d88ac7727295ab3" translate="yes" xml:space="preserve">
          <source>After initialization, you set up the connection to the Erlang node. To specify the Erlang node you want to connect to, use the &lt;code&gt;ei_connect_*()&lt;/code&gt; family of functions. The following example sets up the connection and is to result in a valid socket file descriptor:</source>
          <target state="translated">초기화 후 Erlang 노드에 대한 연결을 설정합니다. 연결하려는 Erlang 노드를 지정하려면 &lt;code&gt;ei_connect_*()&lt;/code&gt; 함수 계열을 사용하십시오. 다음 예제는 연결을 설정하고 유효한 소켓 파일 설명자를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="71297d463c83eda2a6c9154b983ee09e837036ff" translate="yes" xml:space="preserve">
          <source>After installation you can access the documentation by</source>
          <target state="translated">설치 후 다음 방법으로 설명서에 액세스 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6b0c5270a184c48e498da3c725b4712069c50f99" translate="yes" xml:space="preserve">
          <source>After matching all six digits and then failing to match &quot;foo&quot;, the normal action of the matcher is to try again with only five digits matching item \d+, and then with four, and so on, before ultimately failing. &quot;Atomic grouping&quot; (a term taken from Jeffrey Friedl's book) provides the means for specifying that once a subpattern has matched, it is not to be re-evaluated in this way.</source>
          <target state="translated">6 자리 숫자를 모두 일치시킨 다음 &quot;foo&quot;와 일치하지 않으면, 일치하는 사람의 정상적인 동작은 항목 \ d +와 일치하는 5 자리 숫자 만 사용한 다음 다시 4 자리 숫자 만 사용하여 다시 시도하는 것입니다. &quot;원자 그룹화&quot;(Jeffrey Friedl의 책에서 사용 된 용어)는 하위 패턴이 일치하면이를 다시 평가하지 않도록 지정하는 수단을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ae043d6d909deeb13bd861dc2fdf16fc111c0f4f" translate="yes" xml:space="preserve">
          <source>After reading the &lt;code&gt;erts_alloc(3)&lt;/code&gt; documentation, the returned information more or less speaks for itself, but it can be worth explaining some things. Call counts are presented by two values, the first value is giga calls, and the second value is calls. &lt;code&gt;mbcs&lt;/code&gt; and &lt;code&gt;sbcs&lt;/code&gt; denote multi-block carriers, and single-block carriers, respectively. Sizes are presented in bytes. When a size is not presented, it is the amount of something. Sizes and amounts are often presented by three values:</source>
          <target state="translated">&lt;code&gt;erts_alloc(3)&lt;/code&gt; 문서를 읽은 후 , 반환 된 정보는 그 자체로 말하지만, 몇 가지를 설명 할 가치가 있습니다. 통화 수는 두 가지 값으로 표시됩니다. 첫 번째 값은 기가 통화이고 두 번째 값은 통화입니다. &lt;code&gt;mbcs&lt;/code&gt; 및 &lt;code&gt;sbcs&lt;/code&gt; 는 각각 다중 블록 반송파 및 단일 블록 반송파를 나타낸다. 크기는 바이트로 표시됩니다. 크기가 표시되지 않으면 크기입니다. 크기와 양은 종종 세 가지 값으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="90a4520417596de12836632d1f1ef59e2dcef82d" translate="yes" xml:space="preserve">
          <source>After registering the name, use &lt;code&gt;&lt;a href=&quot;ei_connect#ei_accept&quot;&gt; ei_accept&lt;/a&gt;&lt;/code&gt; to wait for incoming connections.</source>
          <target state="translated">이름을 등록한 후 &lt;code&gt;&lt;a href=&quot;ei_connect#ei_accept&quot;&gt; ei_accept&lt;/a&gt;&lt;/code&gt; 를 사용 하여 들어오는 연결을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="e9095c6393c06f16504fcb2b9e560f38a38a063b" translate="yes" xml:space="preserve">
          <source>After registering the name, use &lt;code&gt;&lt;a href=&quot;erl_connect#erl_accept&quot;&gt;erl_connect:erl_accept&lt;/a&gt;&lt;/code&gt; to wait for incoming connections.</source>
          <target state="translated">이름을 등록한 후 &lt;code&gt;&lt;a href=&quot;erl_connect#erl_accept&quot;&gt;erl_connect:erl_accept&lt;/a&gt;&lt;/code&gt; 를 사용 하여 들어오는 연결을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="d3c38468398c9f7ba65583a0574f32622bbcf3f0" translate="yes" xml:space="preserve">
          <source>After sending the message &lt;code&gt;pong&lt;/code&gt; to the process &quot;ping&quot;, &quot;pong&quot; calls the &lt;code&gt;pong&lt;/code&gt; function again, which causes it to get back to the &lt;code&gt;receive&lt;/code&gt; again and wait for another message.</source>
          <target state="translated">메시지 &lt;code&gt;pong&lt;/code&gt; 을 프로세스 &quot;ping&quot;으로 보낸 후 &quot;pong&quot;은 &lt;code&gt;pong&lt;/code&gt; 기능을 다시 호출 하여 &lt;code&gt;receive&lt;/code&gt; 다시 돌아가서 다른 메시지를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="e36306045d856ed44b3178bdde7ee2e0ace1e9c1" translate="yes" xml:space="preserve">
          <source>After setting the dictionary the inflate operation should be retried without new input.</source>
          <target state="translated">사전을 설정 한 후 새 입력없이 팽창 조작을 재 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="46b2484894cf1b418bcc258ea3f4b87e3bcd685f" translate="yes" xml:space="preserve">
          <source>After testing that the client process exists:</source>
          <target state="translated">클라이언트 프로세스가 존재하는지 테스트 한 후 :</target>
        </trans-unit>
        <trans-unit id="22756028dc88f951673801206c8f0149ec02c1b4" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;Flags&lt;/code&gt; field follow the &lt;code&gt;AtomCacheRefs&lt;/code&gt;. The first &lt;code&gt;AtomCacheRef&lt;/code&gt; is the one corresponding to &lt;code&gt;AtomCacheReferenceIndex&lt;/code&gt; 0. Higher indices follow in sequence up to index &lt;code&gt;NumberOfAtomCacheRefs - 1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Flags&lt;/code&gt; 필드 다음에는 &lt;code&gt;AtomCacheRefs&lt;/code&gt; 를 따릅니다 . 첫 번째 &lt;code&gt;AtomCacheRef&lt;/code&gt; 는 &lt;code&gt;AtomCacheReferenceIndex&lt;/code&gt; 0에 해당하는 인덱스입니다. 높은 인덱스는 순서대로 인덱스 &lt;code&gt;NumberOfAtomCacheRefs - 1&lt;/code&gt; 집니다.</target>
        </trans-unit>
        <trans-unit id="dca4e4c96c0a14c7be226e5bd7489709c72d0c43" translate="yes" xml:space="preserve">
          <source>After the application specifications have been updated, the instructions in the script are evaluated and the function returns &lt;code&gt;{ok,OtherVsn,Descr}&lt;/code&gt; if successful. &lt;code&gt;OtherVsn&lt;/code&gt; and &lt;code&gt;Descr&lt;/code&gt; are the version (&lt;code&gt;UpFromVsn&lt;/code&gt; or &lt;code&gt;Vsn&lt;/code&gt;) and description (&lt;code&gt;Descr1&lt;/code&gt; or &lt;code&gt;Descr2&lt;/code&gt;) as specified in the script.</source>
          <target state="translated">응용 프로그램 스펙이 갱신 된 후 스크립트의 지시 사항이 평가되고 성공 하면 함수는 &lt;code&gt;{ok,OtherVsn,Descr}&lt;/code&gt; 을 리턴합니다 . &lt;code&gt;OtherVsn&lt;/code&gt; 및 &lt;code&gt;Descr&lt;/code&gt; 은 스크립트에 지정된 버전 ( &lt;code&gt;UpFromVsn&lt;/code&gt; 또는 &lt;code&gt;Vsn&lt;/code&gt; ) 및 설명 ( &lt;code&gt;Descr1&lt;/code&gt; 또는 &lt;code&gt;Descr2&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="0d4f7a31773a30c9ab44ee914a380f7ad8d9358d" translate="yes" xml:space="preserve">
          <source>After the change, 5 lines are presented as follows:</source>
          <target state="translated">변경 후 다음과 같이 5 줄이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="2c691aee72f4af2559c4df9a131c0a55a89cadf0" translate="yes" xml:space="preserve">
          <source>After the database is deleted, it can still be possible to start Mnesia as a disc-less node. This depends on how configuration parameter &lt;code&gt;schema_location&lt;/code&gt; is set.</source>
          <target state="translated">데이터베이스가 삭제 된 후에도 Mnesia를 디스크없는 노드로 시작할 수 있습니다. 이는 구성 매개 변수 &lt;code&gt;schema_location&lt;/code&gt; 이 설정 되는 방법에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="d5839b9af149f08b9df4808444dfa4c5b3879065" translate="yes" xml:space="preserve">
          <source>After the handshake is performed, the user process receives messages with the tickets sent by the server.</source>
          <target state="translated">핸드 셰이크가 수행 된 후 사용자 프로세스는 서버에서 보낸 티켓이 포함 된 메시지를받습니다.</target>
        </trans-unit>
        <trans-unit id="4298986c5c1910d7ad391031923615fdac4c6079" translate="yes" xml:space="preserve">
          <source>After the header word has been copied a &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.h#L45-L46&quot;&gt;move marker&lt;/a&gt;&lt;/code&gt; is destructively placed in it pointing to the term in the &lt;strong&gt;to space&lt;/strong&gt;. Any other term that points to the already moved term will &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1125&quot;&gt;see this move marker&lt;/a&gt;&lt;/code&gt; and copy the referring pointer instead. For example, if the have the following Erlang code:</source>
          <target state="translated">헤더 단어가 복사 된 후 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.h#L45-L46&quot;&gt;move marker&lt;/a&gt;&lt;/code&gt; 는 &lt;strong&gt;to 공간&lt;/strong&gt; 의 용어를 가리키는 파괴적으로 배치됩니다 . 이미 이동 된 용어를 가리키는 다른 용어는 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1125&quot;&gt;see this move marker&lt;/a&gt;&lt;/code&gt; 를 보고 대신 참조 포인터를 복사합니다. 예를 들어에 다음 Erlang 코드가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="e4e458fe2735510f2a3f94986ee2e1c2798b1558" translate="yes" xml:space="preserve">
          <source>After the insertion of the employee named &lt;code&gt;klacke&lt;/code&gt;, the database has the following records:</source>
          <target state="translated">이름이 &lt;code&gt;klacke&lt;/code&gt; 인 직원을 삽입 한 후 데이터베이스에는 다음 레코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="014d2e6e6b7efad4c0429a37b959bc880d48f38c" translate="yes" xml:space="preserve">
          <source>After the installation, the application controller compares the old and new configuration parameters for all running applications and call the callback function:</source>
          <target state="translated">설치 후 애플리케이션 컨트롤러는 실행중인 모든 애플리케이션의 이전 및 새 구성 매개 변수를 비교하고 콜백 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="8b5bb17b2c511826d46800999f421579e3ca514c" translate="yes" xml:space="preserve">
          <source>After the restore operation, the entire contents of the registry is marked as unmodified. Notice that this includes any objects that were modified before the restore and not overwritten by the restore.</source>
          <target state="translated">복원 작업 후 레지스트리의 전체 내용이 수정되지 않은 것으로 표시됩니다. 여기에는 복원 전에 수정되었고 복원으로 덮어 쓰지 않은 모든 개체가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c4f3acb2fc60165a466769fee1869d300231ddf6" translate="yes" xml:space="preserve">
          <source>After the rootsymbol declaration comes an optional declaration of the &lt;code&gt;end_of_input&lt;/code&gt; symbol that your scanner is expected to use. For example:</source>
          <target state="translated">rootsymbol 선언 후 스캐너가 사용할 것으로 예상되는 &lt;code&gt;end_of_input&lt;/code&gt; 기호를 선언적으로 선언 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2770f0bd427f63fd51d60a2a398782f6d81807ca" translate="yes" xml:space="preserve">
          <source>After the successful build it's time to patch. The source tree directory, the directory of the installation and the applications to patch are given as arguments to &lt;code&gt;otp_patch_apply&lt;/code&gt;. The dependencies of each application are validated against the applications in the installation and the other applications given as arguments. If a dependency error is detected, the script will be aborted.</source>
          <target state="translated">성공적인 빌드 후 패치 할 시간입니다. 소스 트리 디렉토리, 설치 디렉토리 및 패치 할 애플리케이션이 &lt;code&gt;otp_patch_apply&lt;/code&gt; 에 대한 인수로 제공 됩니다. 각 응용 프로그램의 종속성은 설치의 응용 프로그램 및 인수로 지정된 다른 응용 프로그램에 대해 검증됩니다. 종속성 오류가 감지되면 스크립트가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="59c978cfe3812d62d5db4509ebca4d4c5513e4b6" translate="yes" xml:space="preserve">
          <source>After the system has been cross built you can build and install the documentation the same way as after a native build of the system. See the &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP_How-to-Build-the-Documentation&quot;&gt;How to Build the Documentation&lt;/a&gt;&lt;/code&gt; section in the &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; document for information on how to build the documentation.</source>
          <target state="translated">시스템이 교차 빌드 된 후 시스템의 기본 빌드와 같은 방식으로 문서를 빌드하고 설치할 수 있습니다. &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP_How-to-Build-the-Documentation&quot;&gt;How to Build the Documentation&lt;/a&gt;&lt;/code&gt; 대한 정보 는 &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; 문서 의 문서 작성 방법 섹션 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0aad644b2254828a652fc4d00f391c4ee2e9798e" translate="yes" xml:space="preserve">
          <source>After these steps, the intermediate data structure, an &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt;, is fully normalized. The last step is applying &lt;code&gt;&lt;a href=&quot;uri_string#recompose-1&quot;&gt;uri_string:recompose/1&lt;/a&gt;&lt;/code&gt; that converts the intermediate structure into a valid canonical URI string.</source>
          <target state="translated">이 단계 후에 중간 데이터 구조 인 &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt; 이 완전히 정규화됩니다. 마지막 단계는 중간 구조를 유효한 표준 URI 문자열로 변환하는 &lt;code&gt;&lt;a href=&quot;uri_string#recompose-1&quot;&gt;uri_string:recompose/1&lt;/a&gt;&lt;/code&gt; 을 적용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9b3f9b5771b4280d0c55a70767959a27ea46eb52" translate="yes" xml:space="preserve">
          <source>After this is compiled and the file &lt;code&gt;tut19.beam&lt;/code&gt; is copied to the necessary directories, the following is seen on (pong@kosken):</source>
          <target state="translated">이것이 컴파일되고 &lt;code&gt;tut19.beam&lt;/code&gt; 파일 이 필요한 디렉토리에 복사 된 후 , (pong @ kosken)에 다음이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c6e5f33003aed8582bf379cb6df791e38f259eef" translate="yes" xml:space="preserve">
          <source>After thread progress, commit the staging area by assigning &lt;code&gt;the_staging_code_index&lt;/code&gt; to &lt;code&gt;the_active_code_index&lt;/code&gt;.</source>
          <target state="translated">스레드가 진행된 후 &lt;code&gt;the_active_code_index&lt;/code&gt; 에 &lt;code&gt;the_staging_code_index&lt;/code&gt; 를 할당하여 스테이징 영역을 커밋합니다 .</target>
        </trans-unit>
        <trans-unit id="e0717a39ec07e9aad70e9e475eae5bb9f752c8e1" translate="yes" xml:space="preserve">
          <source>Again, the &lt;code&gt;relup&lt;/code&gt; file is created manually. Either from scratch or by editing a generated version. Load all code for &lt;code&gt;ch_app&lt;/code&gt; first, and also load the application specification, before &lt;code&gt;prim_sup&lt;/code&gt; is updated. When downgrading, &lt;code&gt;prim_sup&lt;/code&gt; is to updated first, before the code for &lt;code&gt;ch_app&lt;/code&gt; and its application specification are unloaded.</source>
          <target state="translated">다시 &lt;code&gt;relup&lt;/code&gt; 파일이 수동으로 작성됩니다. 처음부터 또는 생성 된 버전을 편집하여. 모든 코드로드 &lt;code&gt;ch_app&lt;/code&gt; 을 먼저하고 전에 또한, 응용 프로그램 사양을로드 &lt;code&gt;prim_sup&lt;/code&gt; 가 업데이트됩니다. 다운 그레이드 할 때 &lt;code&gt;ch_app&lt;/code&gt; 및 해당 애플리케이션 스펙 의 코드 가 언로드 되기 전에 &lt;code&gt;prim_sup&lt;/code&gt; 이 먼저 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="1b5e61e0895721c0ebf450f07d288833226aa589" translate="yes" xml:space="preserve">
          <source>Again, this works in Perl, but not in PCRE, and for the same reason. When a deeper recursion has matched a single character, it cannot be entered again to match an empty string. The solution is to separate the two cases, and write out the odd and even cases as alternatives at the higher level:</source>
          <target state="translated">다시, 이것은 Perl에서는 작동하지만 PCRE에서는 작동하지 않으며 같은 이유로 작동합니다. 더 깊은 재귀가 단일 문자와 일치하면 빈 문자열과 일치하도록 다시 입력 할 수 없습니다. 해결책은 두 경우를 분리하고 홀수 및 짝수 사례를 상위 레벨의 대안으로 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3b2767e308e62a98e4db59a3a9f824fa516512cb" translate="yes" xml:space="preserve">
          <source>Agent configuration:</source>
          <target state="translated">에이전트 구성 :</target>
        </trans-unit>
        <trans-unit id="3ec3b79e0abd28ca38f812dac049f7131b92ea23" translate="yes" xml:space="preserve">
          <source>Agent semantics</source>
          <target state="translated">에이전트 시맨틱</target>
        </trans-unit>
        <trans-unit id="292ef3c4e0286769b6dbb07a9c3a55d1d989a61e" translate="yes" xml:space="preserve">
          <source>Agent specific config options and types:</source>
          <target state="translated">에이전트 별 구성 옵션 및 유형 :</target>
        </trans-unit>
        <trans-unit id="9183ce25ce4e057cce5e3b5d3d28a86f4aa93b15" translate="yes" xml:space="preserve">
          <source>Agents to be accessed by the manager needs to be registered by a user. Once registered, they can be accessed by all registered users.</source>
          <target state="translated">관리자가 액세스 할 에이전트는 사용자가 등록해야합니다. 등록되면 등록 된 모든 사용자가 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b321e7cb00697b98b1069def622912b90e34756e" translate="yes" xml:space="preserve">
          <source>Aho &amp;amp; Johnson: 'LR Parsing', ACM Computing Surveys, vol. 6:2, 1974.</source>
          <target state="translated">Aho &amp;amp; Johnson : 'LR Parsing', ACM 컴퓨팅 설문 조사, vol. 1974 년 6 월 2 일.</target>
        </trans-unit>
        <trans-unit id="8314c1bccd7fbe31d59f08ffd330d112f0923137" translate="yes" xml:space="preserve">
          <source>Aim for finding bugs. Write whatever test that has the highest probability of finding a bug, now or in the future. Concentrate more on the critical parts. Bugs in critical subsystems are much more expensive than others.</source>
          <target state="translated">버그 찾기를 목표로합니다. 현재 또는 미래에 버그를 발견 할 가능성이 가장 높은 테스트를 작성하십시오. 중요한 부분에 더 집중하십시오. 중요한 서브 시스템의 버그는 다른 것보다 훨씬 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="2e73e04c930e7b3b6a12e1613006c2d06e333b4f" translate="yes" xml:space="preserve">
          <source>Aim for functionality testing rather than implementation details. Implementation details change quite often, and the test suites are to be long lived. Implementation details often differ on different platforms and versions. If implementation details must be tested, try to factor them out into separate test cases. These test cases can later be rewritten or skipped.</source>
          <target state="translated">구현 세부 사항보다는 기능 테스트를 목표로합니다. 구현 세부 사항은 자주 변경되며 테스트 스위트는 오래 지속됩니다. 구현 세부 사항은 종종 플랫폼과 버전에 따라 다릅니다. 구현 세부 사항을 테스트해야하는 경우 별도의 테스트 케이스로이를 고려하십시오. 이 테스트 사례는 나중에 다시 쓰거나 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5204c24c2356e334c01209b09953d29e8b1c732c" translate="yes" xml:space="preserve">
          <source>Alarm handling</source>
          <target state="translated">경보 처리</target>
        </trans-unit>
        <trans-unit id="07994d0d2fea2b8ccddc2fe4a57609e0e8cf0605" translate="yes" xml:space="preserve">
          <source>Alarm, that is, the BEL character (hex 07)</source>
          <target state="translated">알람, 즉 BEL 문자 (16 진 07)</target>
        </trans-unit>
        <trans-unit id="44b68bd3aa7ebc745c49072e3fc9224605032491" translate="yes" xml:space="preserve">
          <source>Alarms are reported to the SASL alarm handler, see &lt;code&gt;alarm_handler(3)&lt;/code&gt;. To set an alarm, &lt;code&gt;alarm_handler:set_alarm(Alarm)&lt;/code&gt; is called where &lt;code&gt;Alarm&lt;/code&gt; is either of the alarms specified above.</source>
          <target state="translated">경보는 SASL 경보 핸들러에보고 &lt;code&gt;alarm_handler(3)&lt;/code&gt; 참조 ) . 알람을 설정하기 위해 &lt;code&gt;alarm_handler:set_alarm(Alarm)&lt;/code&gt; 이 호출됩니다. 여기서 &lt;code&gt;Alarm&lt;/code&gt; 은 위에 지정된 알람 중 하나입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
