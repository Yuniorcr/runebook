<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="2b4dcd80a65565039360cb58b9873fb3744a25eb" translate="yes" xml:space="preserve">
          <source>Log the given message.</source>
          <target state="translated">주어진 메시지를 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="257f9074dd9a3273e0ecc0bf2277c09f48d1ab6f" translate="yes" xml:space="preserve">
          <source>Logger API functions that apply to handler configuration are:</source>
          <target state="translated">핸들러 구성에 적용되는 로거 API 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5304ec3e6860fd753d440e00b333f7b7952e2873" translate="yes" xml:space="preserve">
          <source>Logger API functions that apply to the primary Logger configuration are:</source>
          <target state="translated">기본 로거 구성에 적용되는 로거 API 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="459822e04b58487fbab71512de0c13bbcb5802d9" translate="yes" xml:space="preserve">
          <source>Logger adds the following metadata to each log event:</source>
          <target state="translated">로거는 각 로그 이벤트에 다음 메타 데이터를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="37165244e9071117a04c3897531cff43e65233d3" translate="yes" xml:space="preserve">
          <source>Logger allows adding multiple instances of a handler callback. That is, if a callback module implementation allows it, you can add multiple handler instances using the same callback module. The different instances are identified by unique handler identities.</source>
          <target state="translated">로거를 사용하면 처리기 콜백의 여러 인스턴스를 추가 할 수 있습니다. 즉, 콜백 모듈 구현에서 허용하는 경우 동일한 콜백 모듈을 사용하여 여러 핸들러 인스턴스를 추가 할 수 있습니다. 다른 인스턴스는 고유 한 핸들러 ID로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="32814cbaff4ab32f839a5572bf470491707d186f" translate="yes" xml:space="preserve">
          <source>Logger does, to a certain extent, check its input data before forwarding a log event to filters and handlers. It does, however, not evaluate report callbacks, or check the validity of format strings and arguments. This means that all filters and handlers must be careful when formatting the data of a log event, making sure that it does not crash due to bad input data or faulty callbacks.</source>
          <target state="translated">로거는 로그 이벤트를 필터 및 핸들러에 전달하기 전에 입력 데이터를 어느 정도 점검합니다. 그러나 보고서 콜백을 평가하거나 형식 문자열 및 인수의 유효성을 검사하지는 않습니다. 즉, 로그 이벤트의 데이터를 형식화 할 때 모든 필터와 핸들러가주의를 기울여야하며 입력 데이터가 잘못되거나 콜백이 잘못되어 충돌이 발생하지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="81f578032fd43b4ad866def6cb23e116c34a3a72" translate="yes" xml:space="preserve">
          <source>Logger functions</source>
          <target state="translated">로거 기능</target>
        </trans-unit>
        <trans-unit id="5a30a202ff6e7537109cfe3ce75b8beb4047b16f" translate="yes" xml:space="preserve">
          <source>Logger merges all the metadata maps before forwarding the log event to the handlers. If the same keys occur, values from the log call overwrite process metadata, which in turn overwrite values set by Logger.</source>
          <target state="translated">로거는 로그 이벤트를 핸들러로 전달하기 전에 모든 메타 데이터 맵을 병합합니다. 동일한 키가 발생하면 로그 호출의 값이 프로세스 메타 데이터를 덮어 쓰고 로거가 설정 한 값을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="12780a5781ba0da418e4440c2f80cf58b1993381" translate="yes" xml:space="preserve">
          <source>Logger provides backwards compatibility with &lt;code&gt;error_logger&lt;/code&gt; in the following ways:</source>
          <target state="translated">로거는 다음과 같은 방법으로 &lt;code&gt;error_logger&lt;/code&gt; 와의 호환성을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="1dd635d9867292503b89dea88db780ad83186225" translate="yes" xml:space="preserve">
          <source>Logging API functions</source>
          <target state="translated">API 함수 로깅</target>
        </trans-unit>
        <trans-unit id="a4cf2d82c9d86421275e3d731c6c1f28619eb2da" translate="yes" xml:space="preserve">
          <source>Logging of events during execution</source>
          <target state="translated">실행 중 이벤트 로깅</target>
        </trans-unit>
        <trans-unit id="70d888e147aabaf8fa1dfb2483f315253b5163ed" translate="yes" xml:space="preserve">
          <source>Logging to file with &lt;code&gt;ct:log/1,2,3,4,5&lt;/code&gt; or &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt; only works when &lt;code&gt;Common Test&lt;/code&gt; is running. Printouts with &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt; are however always displayed on screen.</source>
          <target state="translated">&lt;code&gt;ct:log/1,2,3,4,5&lt;/code&gt; 또는 &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt; 를 사용하여 파일에 로깅 하면 &lt;code&gt;Common Test&lt;/code&gt; 가 실행중인 경우에만 작동 합니다. 그러나 &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt; 인 출력물 은 항상 화면에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f2e14633e86adb02560262087e31589175004916" translate="yes" xml:space="preserve">
          <source>Logging.</source>
          <target state="translated">Logging.</target>
        </trans-unit>
        <trans-unit id="c5d5c5fb2a8798e4f962780fba63386de96b07b6" translate="yes" xml:space="preserve">
          <source>Logical AND</source>
          <target state="translated">논리 AND</target>
        </trans-unit>
        <trans-unit id="e9b0aefdf7ed2c67abbfc572bbc5743979450674" translate="yes" xml:space="preserve">
          <source>Logical OR</source>
          <target state="translated">논리 OR</target>
        </trans-unit>
        <trans-unit id="93425a1fb1ee61afdd5c8bde53ad3e437fa5c378" translate="yes" xml:space="preserve">
          <source>Logical XOR</source>
          <target state="translated">논리 XOR</target>
        </trans-unit>
        <trans-unit id="189c88af11bff23eaa5470818ba782219adfeb6c" translate="yes" xml:space="preserve">
          <source>Logical errors</source>
          <target state="translated">논리적 오류</target>
        </trans-unit>
        <trans-unit id="b639be33714dfa7d1e5de7c8923f3afaa6ea2eb2" translate="yes" xml:space="preserve">
          <source>Logs a warning message. See &lt;code&gt;error_logger:warning_msg/2&lt;/code&gt; for details.</source>
          <target state="translated">경고 메시지를 기록합니다. 자세한 내용은 &lt;code&gt;error_logger:warning_msg/2&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5c7284beba7b87f4db66029f580195bdcb14e18a" translate="yes" xml:space="preserve">
          <source>Logs an error message. See &lt;code&gt;error_logger:error_msg/2&lt;/code&gt; for details.</source>
          <target state="translated">오류 메시지를 기록합니다. 자세한 내용은 &lt;code&gt;error_logger:error_msg/2&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="181bd8b6829579eef29a5e97835c83f4d8736de3" translate="yes" xml:space="preserve">
          <source>Logs an info message. See &lt;code&gt;error_logger:info_msg/2&lt;/code&gt; for details.</source>
          <target state="translated">정보 메시지를 기록합니다. 자세한 내용은 &lt;code&gt;error_logger:info_msg/2&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="631539dc5343898549c85b01b6e598967f305bce" translate="yes" xml:space="preserve">
          <source>Logs can be found in &lt;code&gt;/usr/local/erl-target/log&lt;/code&gt;. This directory is specified as an argument to &lt;code&gt;run_erl&lt;/code&gt;in the start script listed above.</source>
          <target state="translated">로그는 &lt;code&gt;/usr/local/erl-target/log&lt;/code&gt; 에 있습니다. 이 디렉토리는 위에 나열된 시작 스크립트에서 &lt;code&gt;run_erl&lt;/code&gt; 의 인수로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="bee8d520364ca487a1e8615fbc5892acb2cf4610" translate="yes" xml:space="preserve">
          <source>Look for &lt;code&gt;example.beam&lt;/code&gt; in the code path, parse the BEAM file and retrieve the &lt;code&gt;Docs&lt;/code&gt; chunk. If the chunk is not available, it should look for &quot;example.beam&quot; in the code path and find the &lt;code&gt;doc/chunks/example.chunk&lt;/code&gt; file in the application that defines the &lt;code&gt;example&lt;/code&gt; module. If a .chunk file is not available, then documentation is not available.</source>
          <target state="translated">을 찾아 &lt;code&gt;example.beam&lt;/code&gt; 코드 경로는 BEAM 파일을 구문 분석하고 검색 할 &lt;code&gt;Docs&lt;/code&gt; 덩어리를. 청크를 사용할 수없는 경우 코드 경로에서 &quot;example.beam&quot;을 찾고 &lt;code&gt;example&lt;/code&gt; 모듈 을 정의하는 응용 프로그램에서 &lt;code&gt;doc/chunks/example.chunk&lt;/code&gt; 파일을 찾아야합니다 . .chunk 파일을 사용할 수없는 경우 설명서를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d394eaa2c896b383401e9868f1f1c7fd394042f0" translate="yes" xml:space="preserve">
          <source>Look up all current Logger configuration, including primary and handler configuration, and module level settings.</source>
          <target state="translated">기본 및 핸들러 구성, 모듈 레벨 설정을 포함한 모든 현재 로거 구성을 찾아보십시오.</target>
        </trans-unit>
        <trans-unit id="1ae68bf451cf6f0d3a38eb520585141004fe0c88" translate="yes" xml:space="preserve">
          <source>Look up all current Logger configuration, including primary, handler, and proxy configuration, and module level settings.</source>
          <target state="translated">기본, 처리기 및 프록시 구성, 모듈 수준 설정을 포함하여 모든 현재 로거 구성을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="2f067d3e406691e75fba8d1ab1c80c002673266e" translate="yes" xml:space="preserve">
          <source>Look up all current module levels. Returns a list containing one &lt;code&gt;{Module,Level}&lt;/code&gt; element for each module for which the module level was previously set with &lt;code&gt;&lt;a href=&quot;#set_module_level-2&quot;&gt; set_module_level/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모든 현재 모듈 수준을 찾습니다. 모듈 레벨이 이전에 &lt;code&gt;&lt;a href=&quot;#set_module_level-2&quot;&gt; set_module_level/2&lt;/a&gt;&lt;/code&gt; 로 설정된 각 모듈에 대해 하나의 &lt;code&gt;{Module,Level}&lt;/code&gt; 요소가 포함 된 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="467add5a91389ace0fffa89049ee83d9c088b039" translate="yes" xml:space="preserve">
          <source>Look up all current module levels. Returns a list containing one &lt;code&gt;{Module,Level}&lt;/code&gt; element for each module for which the module level was previously set with &lt;code&gt;&lt;a href=&quot;#set_module_level-2&quot;&gt;set_module_level/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모든 현재 모듈 레벨을 찾으십시오. 모듈 레벨이 이전에 &lt;code&gt;&lt;a href=&quot;#set_module_level-2&quot;&gt;set_module_level/2&lt;/a&gt;&lt;/code&gt; 로 설정된 모듈마다 하나의 &lt;code&gt;{Module,Level}&lt;/code&gt; 요소가 포함 된 목록을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ed68e7f8cb77748b3410c3da1ddc86795dc0c780" translate="yes" xml:space="preserve">
          <source>Look up the current configuration for all handlers.</source>
          <target state="translated">모든 핸들러의 현재 구성을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="a5084ee32b982850716660225421b03ec5c65767" translate="yes" xml:space="preserve">
          <source>Look up the current configuration for the Logger proxy.</source>
          <target state="translated">Logger 프록시의 현재 구성을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="67650debe1e8550cab53ba9b912a888f4830fbd0" translate="yes" xml:space="preserve">
          <source>Look up the current configuration for the given handler.</source>
          <target state="translated">주어진 핸들러에 대한 현재 구성을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="9f081df8fdfea5d9826fc29f0d5b6a73152406c1" translate="yes" xml:space="preserve">
          <source>Look up the current level for the given modules. Returns a list containing one &lt;code&gt;{Module,Level}&lt;/code&gt; element for each of the given modules for which the module level was previously set with &lt;code&gt;&lt;a href=&quot;#set_module_level-2&quot;&gt; set_module_level/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">주어진 모듈에 대한 현재 레벨을 찾으십시오. 모듈 레벨이 이전에 &lt;code&gt;&lt;a href=&quot;#set_module_level-2&quot;&gt; set_module_level/2&lt;/a&gt;&lt;/code&gt; 로 설정된 주어진 모듈 각각에 대해 하나의 &lt;code&gt;{Module,Level}&lt;/code&gt; 요소를 포함하는 목록을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="5b7fd66f8792b2995650ec41a426440bdc8c6525" translate="yes" xml:space="preserve">
          <source>Look up the current level for the given modules. Returns a list containing one &lt;code&gt;{Module,Level}&lt;/code&gt; element for each of the given modules for which the module level was previously set with &lt;code&gt;&lt;a href=&quot;#set_module_level-2&quot;&gt;set_module_level/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">주어진 모듈의 현재 레벨을 찾으십시오. 모듈 레벨이 이전에 &lt;code&gt;&lt;a href=&quot;#set_module_level-2&quot;&gt;set_module_level/2&lt;/a&gt;&lt;/code&gt; 로 설정된 모듈 각각에 대해 하나의 &lt;code&gt;{Module,Level}&lt;/code&gt; 요소를 포함하는 목록을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="28a2ce6edf729b5984078bb368a73e647f062c59" translate="yes" xml:space="preserve">
          <source>Look up the current primary configuration for Logger.</source>
          <target state="translated">로거의 현재 기본 구성을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="48789371fd54ac83d13e3db9cfce2e95be6bb545" translate="yes" xml:space="preserve">
          <source>Look up the identities for all installed handlers.</source>
          <target state="translated">설치된 모든 핸들러의 ID를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="9eafe480d9cb3d8a690b9224bbee0ac5a9549b6e" translate="yes" xml:space="preserve">
          <source>Lookahead assertions start with (?= for positive assertions and (?! for negative assertions. For example, the following matches a word followed by a semicolon, but does not include the semicolon in the match:</source>
          <target state="translated">Lookahead 어설 션은 (? = 긍정 어설 션의 경우 (?!)로 시작하고 (?!</target>
        </trans-unit>
        <trans-unit id="c07ff987e22dccf5863c21c8249616b8a6ed83fb" translate="yes" xml:space="preserve">
          <source>Lookbehind assertions start with (?&amp;lt;= for positive assertions and (?&amp;lt;! for negative assertions. For example, the following finds an occurrence of &quot;bar&quot; that is not preceded by &quot;foo&quot;:</source>
          <target state="translated">Lookbehind 어설 션은 (? &amp;lt;= 긍정 어설 션의 경우 (? &amp;lt;!)로 시작합니다. 예를 들어 다음은 &quot;foo&quot;앞에 오지 않는 &quot;bar&quot;를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="0b4292b6dd1e4f4ea19e5757b522cc47b1f50858" translate="yes" xml:space="preserve">
          <source>Looking at how &lt;code&gt;lists:append/1&lt;/code&gt; or &lt;code&gt;++&lt;/code&gt; would be implemented in plain Erlang, clearly the first list is copied:</source>
          <target state="translated">&lt;code&gt;lists:append/1&lt;/code&gt; 또는 &lt;code&gt;++&lt;/code&gt; 가 일반 Erlang으로 구현되는 방법을 살펴보면 첫 번째 목록이 분명히 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="ae8011d7d2dbc5d36c38aa015da2647371e61405" translate="yes" xml:space="preserve">
          <source>Looking at the &lt;code&gt;tut17&lt;/code&gt; code, you see that the &lt;code&gt;pong&lt;/code&gt; function itself is unchanged, the following lines work in the same way irrespective of on which node the &quot;ping&quot; process is executes:</source>
          <target state="translated">&lt;code&gt;tut17&lt;/code&gt; 코드를 살펴보면 , &lt;code&gt;pong&lt;/code&gt; 함수 자체가 변경되지 않은 것을 볼 수 있습니다 . &quot;ping&quot;프로세스가 실행되는 노드에 관계없이 다음 행이 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="555c7665597e54d469c381ad38552ff5090271dc" translate="yes" xml:space="preserve">
          <source>Looking at the assembler code we can see three things: The heap requirement in this function turns out to be only six words, as seen by the &lt;code&gt;{test_heap,6,1}&lt;/code&gt; instruction. All the allocations are combined to a single instruction. The bulk of the data &lt;code&gt;{text, &quot;hello world!&quot;}&lt;/code&gt; is a &lt;strong&gt;literal&lt;/strong&gt;. Literals, sometimes referred to as constants, are not allocated in the function since they are a part of the module and allocated at load time.</source>
          <target state="translated">어셈블러 코드를 살펴보면 세 가지를 볼 수 있습니다.이 함수의 힙 요구 사항은 &lt;code&gt;{test_heap,6,1}&lt;/code&gt; 명령 에서 볼 수 있듯이 6 단어에 불과 합니다. 모든 할당은 단일 명령어로 결합됩니다. 데이터의 대량 &lt;code&gt;{text, &quot;hello world!&quot;}&lt;/code&gt; A는 &lt;strong&gt;문자&lt;/strong&gt; . 상수라고도하는 리터럴은 모듈의 일부이고로드 시간에 할당되기 때문에 함수에 할당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc4ea395786cdf2a9b882e1323bffb04f3d43ded" translate="yes" xml:space="preserve">
          <source>Looking at the function &lt;code&gt;ping/2&lt;/code&gt;, the second clause of &lt;code&gt;ping/2&lt;/code&gt; is executed since the value of the first argument is 3 (not 0) (first clause head is &lt;code&gt;ping(0,Pong_PID)&lt;/code&gt;, second clause head is &lt;code&gt;ping(N,Pong_PID)&lt;/code&gt;, so &lt;code&gt;N&lt;/code&gt; becomes 3).</source>
          <target state="translated">&lt;code&gt;ping/2&lt;/code&gt; 함수를 보면 첫 번째 인수의 값이 3이 아니기 때문에 &lt;code&gt;ping/2&lt;/code&gt; 의 두 번째 절이 실행됩니다 (0이 아님) (첫 번째 절 머리글은 &lt;code&gt;ping(0,Pong_PID)&lt;/code&gt; 이고 두 번째 절 머리글은 &lt;code&gt;ping(N,Pong_PID)&lt;/code&gt; 이므로 &lt;code&gt;N&lt;/code&gt; 은 3)이됩니다.</target>
        </trans-unit>
        <trans-unit id="bb76af27b840c114115effd83744ad34a439d0c6" translate="yes" xml:space="preserve">
          <source>Looking up only &lt;code&gt;{2,2}&lt;/code&gt; would not return &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{2,2}&lt;/code&gt; 만 찾으면 &lt;code&gt;b&lt;/code&gt; 와 &lt;code&gt;c&lt;/code&gt; 가 리턴되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="79cecfb0f48fcf27b9c36092d68f350e007736e3" translate="yes" xml:space="preserve">
          <source>Looks for a file of the given name by applying suffix rules to the given directory path. For example, a rule &lt;code&gt;{&quot;ebin&quot;, &quot;src&quot;}&lt;/code&gt; means that if the directory path ends with &lt;code&gt;&quot;ebin&quot;&lt;/code&gt;, the corresponding path ending in &lt;code&gt;&quot;src&quot;&lt;/code&gt; should be searched.</source>
          <target state="translated">주어진 디렉토리 경로에 접미사 규칙을 적용하여 주어진 이름의 파일을 찾습니다. 예를 들어 규칙 &lt;code&gt;{&quot;ebin&quot;, &quot;src&quot;}&lt;/code&gt; 은 디렉토리 경로가 &lt;code&gt;&quot;ebin&quot;&lt;/code&gt; 으로 끝나는 경우 &lt;code&gt;&quot;src&quot;&lt;/code&gt; 로 끝나는 해당 경로를 검색해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="572250e9df056859af227d0dcd9f4fa92b7ecd08" translate="yes" xml:space="preserve">
          <source>Looks up &lt;code&gt;Key&lt;/code&gt; in &lt;code&gt;Tree&lt;/code&gt;. Returns &lt;code&gt;{value, Value}&lt;/code&gt;, or &lt;code&gt;none&lt;/code&gt; if &lt;code&gt;Key&lt;/code&gt; is not present.</source>
          <target state="translated">조회 &lt;code&gt;Key&lt;/code&gt; 의 &lt;code&gt;Tree&lt;/code&gt; . 반환 &lt;code&gt;{value, Value}&lt;/code&gt; , 또는 &lt;code&gt;none&lt;/code&gt; 경우 &lt;code&gt;Key&lt;/code&gt; 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb9dfef148e9ec6b8cf8c2740447332c851aec8e" translate="yes" xml:space="preserve">
          <source>Looks up a cache entry. Is to be callable from any process.</source>
          <target state="translated">캐시 항목을 찾습니다. 모든 프로세스에서 호출 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a52acb767c4795552ad229633861bc31c72674b" translate="yes" xml:space="preserve">
          <source>Looks up a name in &lt;code&gt;global&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt; 에서 이름을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="78101c6cc3d27d2ba6e58fe21274768cb0746cd8" translate="yes" xml:space="preserve">
          <source>Looks up a port by its registered name.</source>
          <target state="translated">등록 된 이름으로 포트를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="30d78191ce5ffb897b0972e9eb8f6d616fa60717" translate="yes" xml:space="preserve">
          <source>Looks up a process by its registered name.</source>
          <target state="translated">등록 된 이름으로 프로세스를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="1d157b4e78c7c3e66517498884591593ccc59f89" translate="yes" xml:space="preserve">
          <source>Looks up the OBJECT IDENTIFIER of a MIB object, given the symbolic name. Note, the OBJECT IDENTIFIER is given for the object, not for an instance.</source>
          <target state="translated">심볼 이름이 지정된 MIB 객체의 객체 식별자를 찾습니다. OBJECT IDENTIFIER는 인스턴스가 아닌 객체에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6c5bf56fd6ef4f1df6829e5e6bfa87397c2baa95" translate="yes" xml:space="preserve">
          <source>Looks up the symbolic name of a MIB object, given OBJECT IDENTIFIER.</source>
          <target state="translated">OBJECT IDENTIFIER가 주어지면 MIB 객체의 기호 이름을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="08b0f2af44d0672e5833994d490452fc72a7fb05" translate="yes" xml:space="preserve">
          <source>Lookup a dictionary entry and return zero or one value.</source>
          <target state="translated">사전 항목을 찾아 0 또는 하나의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ae6f5a731780983b4856c7c170673fb5330edbc2" translate="yes" xml:space="preserve">
          <source>Lookup information about an active connection</source>
          <target state="translated">활성 연결에 대한 조회 정보</target>
        </trans-unit>
        <trans-unit id="045c842e1d6e6cd467265d71631ecd62a55e3333" translate="yes" xml:space="preserve">
          <source>Lookup join is handled analogously to lookup of constants in a table: if the join operator is &lt;code&gt;==/2&lt;/code&gt;, and the table where constants are to be looked up uses &lt;code&gt;=:=/2&lt;/code&gt; when testing keys for equality, then the &lt;code&gt;qlc&lt;/code&gt; module does not consider lookup join for that table.</source>
          <target state="translated">조회 조인은 테이블에서 상수를 조회하는 것과 유사하게 처리됩니다. 조인 연산자가 &lt;code&gt;==/2&lt;/code&gt; 이고 상수를 조회 할 테이블이 키를 테스트 할 때 &lt;code&gt;=:=/2&lt;/code&gt; 를 사용하는 경우 &lt;code&gt;qlc&lt;/code&gt; 모듈은 해당 테이블에 대한 조회 조인을 고려하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="35bb462b9b5d0daab8ea39fbe0dc5389a6f8b9fe" translate="yes" xml:space="preserve">
          <source>Lookup method</source>
          <target state="translated">조회 방법</target>
        </trans-unit>
        <trans-unit id="067bc036849c0ea9f3a88839506df146bbb74c53" translate="yes" xml:space="preserve">
          <source>Lookup system information</source>
          <target state="translated">조회 시스템 정보</target>
        </trans-unit>
        <trans-unit id="95287f575a0e7411367945df70317705255f8115" translate="yes" xml:space="preserve">
          <source>Lookup the CRLs belonging to the distribution point &lt;code&gt;Distributionpoint&lt;/code&gt;. This function may choose to only look in the cache or to follow distribution point links depending on how the cache is administrated.</source>
          <target state="translated">배포 지점 &lt;code&gt;Distributionpoint&lt;/code&gt; 에 속하는 CRL을 조회하십시오 . 이 기능은 캐시 관리 방법에 따라 캐시 만 보거나 배포 지점 링크를 따르도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6fa78d0fd70423aadd6b451927544578762dd1d" translate="yes" xml:space="preserve">
          <source>Lookup user information</source>
          <target state="translated">조회 사용자 정보</target>
        </trans-unit>
        <trans-unit id="19942bda356f106b651a5a8f34c9a238875451dc" translate="yes" xml:space="preserve">
          <source>Loops are detected by diameter when the return value of a request callback asks that a request be forwarded. Loop detection in other cases is the responsibility of the user.</source>
          <target state="translated">요청 콜백의 반환 값이 요청을 전달하도록 요청할 때 직경으로 루프가 감지됩니다. 다른 경우 루프 감지는 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="ad31b4a45582d492103decc7ce7a4a81c5c0e3e9" translate="yes" xml:space="preserve">
          <source>Loss of Sharing</source>
          <target state="translated">공유 손실</target>
        </trans-unit>
        <trans-unit id="3dd4c3b37165b69206ec0c19aa805a2a0483a821" translate="yes" xml:space="preserve">
          <source>Low-Level Instructions</source>
          <target state="translated">저수준 지침</target>
        </trans-unit>
        <trans-unit id="3ac7f763ea9e07bb988a045d46a8d40a6820054e" translate="yes" xml:space="preserve">
          <source>Low-level Erlang loader.</source>
          <target state="translated">저수준 Erlang 로더.</target>
        </trans-unit>
        <trans-unit id="5b779e63c115b7d4a7dfed98a4b6ed54c59b2bcc" translate="yes" xml:space="preserve">
          <source>Low-level socket connection (1)</source>
          <target state="translated">저수준 소켓 연결 (1)</target>
        </trans-unit>
        <trans-unit id="72c1e1d78aed59b6fe1fe5b89bf5d964d2c9be82" translate="yes" xml:space="preserve">
          <source>Lowercase letter</source>
          <target state="translated">소문자</target>
        </trans-unit>
        <trans-unit id="26e7bfca24fa187e97eeb696c1c3b5c2e4216480" translate="yes" xml:space="preserve">
          <source>Lowercase letters</source>
          <target state="translated">소문자</target>
        </trans-unit>
        <trans-unit id="71a644cdf0cedda6a1fe30c2848ffe7f7691a9bf" translate="yes" xml:space="preserve">
          <source>Luckily there is a simplified way to start tracing of &lt;code&gt;et:trace_me/5&lt;/code&gt; function calls. The idea is that you should instrument your code with calls to &lt;code&gt;et:trace_me/5&lt;/code&gt; in strategic places where you have interesting information available in your program. Then you just start the &lt;code&gt;Collector&lt;/code&gt; with global tracing enabled:</source>
          <target state="translated">다행히 &lt;code&gt;et:trace_me/5&lt;/code&gt; 함수 호출을 추적하는 간단한 방법이 있습니다. 아이디어는 프로그램에서 유용한 정보를 얻을 수있는 전략적인 장소에서 &lt;code&gt;et:trace_me/5&lt;/code&gt; 를 호출하여 코드를 계측해야한다는 것 입니다. 그런 다음 전역 추적을 사용 하여 &lt;code&gt;Collector&lt;/code&gt; 를 시작 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f9156a05ab3755f6c7a6aab965a12bc73fd9cc2c" translate="yes" xml:space="preserve">
          <source>Lycian</source>
          <target state="translated">Lycian</target>
        </trans-unit>
        <trans-unit id="253fa34d4b816ad16ebad60a0945ef037709d0b8" translate="yes" xml:space="preserve">
          <source>Lydian</source>
          <target state="translated">Lydian</target>
        </trans-unit>
        <trans-unit id="dfec75d824ab931885b10c2deb8b602ddf385540" translate="yes" xml:space="preserve">
          <source>M-b</source>
          <target state="translated">M-b</target>
        </trans-unit>
        <trans-unit id="a213eb1de2d97fd8ab6c0c8486e553f7cdc3e521" translate="yes" xml:space="preserve">
          <source>M-d</source>
          <target state="translated">M-d</target>
        </trans-unit>
        <trans-unit id="add69bf7aa5e86e6ac1a17b8047a626986b67564" translate="yes" xml:space="preserve">
          <source>M-f</source>
          <target state="translated">M-f</target>
        </trans-unit>
        <trans-unit id="151f313215c3295e0ad33723c8a62d7e46bf10b6" translate="yes" xml:space="preserve">
          <source>MACs (Message Authentication Codes)</source>
          <target state="translated">MAC (메시지 인증 코드)</target>
        </trans-unit>
        <trans-unit id="d6a7c28d96631e7edde69c8cc5ffb71acda67d91" translate="yes" xml:space="preserve">
          <source>MANDATORY</source>
          <target state="translated">MANDATORY</target>
        </trans-unit>
        <trans-unit id="fdfcee3d700fd62abd643079cd9ee1e3425dd0be" translate="yes" xml:space="preserve">
          <source>MAY choose to pad</source>
          <target state="translated">패드를 선택할 수 있음</target>
        </trans-unit>
        <trans-unit id="d24661d0d54387c538a6352f93f35bdc335534bf" translate="yes" xml:space="preserve">
          <source>MBCs are more restricted. They can only have a number of fixed sizes that are powers of 2. The start address need to have a very large aligment (currently 256 kb, called &quot;super alignment&quot;). This is a design choice that allows very low overhead per allocated block in the MBC.</source>
          <target state="translated">MBC는 더 제한적입니다. 2의 거듭 제곱 인 고정 된 크기 만 가질 수 있습니다. 시작 주소는 매우 큰 결합 (현재 256kb, &quot;수퍼 정렬&quot;이라고 함)을 가져야합니다. 이것은 MBC에서 할당 된 블록 당 매우 낮은 오버 헤드를 허용하는 설계 선택입니다.</target>
        </trans-unit>
        <trans-unit id="86e9fff1d00c68995ba96d3b00b707d9685f6995" translate="yes" xml:space="preserve">
          <source>MD4</source>
          <target state="translated">MD4</target>
        </trans-unit>
        <trans-unit id="b773bed04a48de200b96981bb79467413a222066" translate="yes" xml:space="preserve">
          <source>MD5</source>
          <target state="translated">MD5</target>
        </trans-unit>
        <trans-unit id="2a10b6977b13d4b417a565ad4f26126926a4a59b" translate="yes" xml:space="preserve">
          <source>MFA ::= &lt;code&gt;{&lt;/code&gt;Module&lt;code&gt;,&lt;/code&gt; Function&lt;code&gt;,&lt;/code&gt; Arity&lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">MFA :: = &lt;code&gt;{&lt;/code&gt; 모듈 &lt;code&gt;,&lt;/code&gt; 기능 &lt;code&gt;,&lt;/code&gt; Arity &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3a37583e66cb48e239f5143bba8733ec51efe1b" translate="yes" xml:space="preserve">
          <source>MIB Structure</source>
          <target state="translated">MIB 구조</target>
        </trans-unit>
        <trans-unit id="3d945d68cd16cd86023529b0ae4e4b00d3131a1f" translate="yes" xml:space="preserve">
          <source>MIB View Semantics</source>
          <target state="translated">MIB 뷰 의미론</target>
        </trans-unit>
        <trans-unit id="04c6a062dba8d860ecd8d08014fad091eaa98372" translate="yes" xml:space="preserve">
          <source>MIB for SNMP. It generates a &lt;code&gt;.bin&lt;/code&gt; file.</source>
          <target state="translated">SNMP 용 MIB. &lt;code&gt;.bin&lt;/code&gt; 파일을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="c4de5d52a9bb8b810300afe15b33e4b1a582332d" translate="yes" xml:space="preserve">
          <source>MIBs for agent configuration are defined.</source>
          <target state="translated">에이전트 구성을위한 MIB가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="ff5ab6fdf3d48b5ee7242edd434ed0f3c0b7ee4f" translate="yes" xml:space="preserve">
          <source>MUST NOT be interleaved with other record types</source>
          <target state="translated">다른 레코드 유형과 인터리브되면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="89855aeb4ba3a4e2501c3ac2832fb7ff1adb9028" translate="yes" xml:space="preserve">
          <source>MUST NOT send Handshake and Alert records that have a zero-length TLSInnerPlaintext.content</source>
          <target state="translated">길이가 0 인 TLSInnerPlaintext.content가있는 Handshake 및 Alert 레코드를 보내면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0781fd32b1c90fe445ee273639b623824e3a14f5" translate="yes" xml:space="preserve">
          <source>MUST NOT send zero-length fragments</source>
          <target state="translated">길이가 0 인 조각을 보내면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="fb478b059be626a8463cdde3d8c5a79b80af0ebd" translate="yes" xml:space="preserve">
          <source>MUST NOT span key changes</source>
          <target state="translated">주요 변경 사항에 걸쳐서는 ​​안됩니다.</target>
        </trans-unit>
        <trans-unit id="7361ea9122404701017ae76f89f305178bc46709" translate="yes" xml:space="preserve">
          <source>MUST implement the TLS_AES_128_GCM_SHA256</source>
          <target state="translated">TLS_AES_128_GCM_SHA256을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="4ed4e46e7ea8c8dcc17449bbb14f42ffea88f86b" translate="yes" xml:space="preserve">
          <source>MUST support ecdsa_secp256r1_sha256</source>
          <target state="translated">ecdsa_secp256r1_sha256을 지원해야합니다 (MUST)</target>
        </trans-unit>
        <trans-unit id="6cd9f925d98388558742ca449a1ccf4823b4ff39" translate="yes" xml:space="preserve">
          <source>MUST support key exchange with secp256r1</source>
          <target state="translated">secp256r1과의 키 교환을 지원해야합니다 (MUST)</target>
        </trans-unit>
        <trans-unit id="2222260842f566ee437c8aa4bc02c5a1cedbd937" translate="yes" xml:space="preserve">
          <source>MUST support rsa_pkcs1_sha256 (for certificates)</source>
          <target state="translated">rsa_pkcs1_sha256 (인증서 용)을 지원해야합니다 (MUST).</target>
        </trans-unit>
        <trans-unit id="2d0def43c1da453010af74fe324f2c04b878ed38" translate="yes" xml:space="preserve">
          <source>MUST support rsa_pss_rsae_sha256 (for CertificateVerify and certificates)</source>
          <target state="translated">rsa_pss_rsae_sha256 (CertificateVerify 및 인증서 용)을 지원해야합니다 (MUST).</target>
        </trans-unit>
        <trans-unit id="6ffd738ce904c33fbbb9ded8005bc90491fa4b7b" translate="yes" xml:space="preserve">
          <source>MUST support the use of the &quot;server_name&quot; extension</source>
          <target state="translated">&quot;server_name&quot;확장의 사용을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d083bf9151a4dce0d477062bb5b2c45afa91d7b" translate="yes" xml:space="preserve">
          <source>Mac | &lt;code&gt;&lt;a href=&quot;#type-descriptive_error&quot;&gt;descriptive_error()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">맥 | &lt;code&gt;&lt;a href=&quot;#type-descriptive_error&quot;&gt;descriptive_error()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="490ac4f548272126971fbad865a9e5c77d3dd621" translate="yes" xml:space="preserve">
          <source>MacOS X reorganizes the filenames so that the representation of accents, and so on, uses the &quot;combining characters&quot;. For example, character &lt;code&gt;&amp;ouml;&lt;/code&gt; is represented as code points &lt;code&gt;[111,776]&lt;/code&gt;, where &lt;code&gt;111&lt;/code&gt; is character &lt;code&gt;o&lt;/code&gt; and &lt;code&gt;776&lt;/code&gt; is the special accent character &quot;Combining Diaeresis&quot;. This way of normalizing Unicode is otherwise very seldom used. Erlang normalizes those filenames in the opposite way upon retrieval, so that filenames using combining accents are not passed up to the Erlang application. In Erlang, filename &quot;bj&amp;ouml;rn&quot; is retrieved as &lt;code&gt;[98,106,246,114,110]&lt;/code&gt;, not as &lt;code&gt;[98,106,117,776,114,110]&lt;/code&gt;, although the file system can think differently. The normalization into combining accents is redone when accessing files, so this can usually be ignored by the Erlang programmer.</source>
          <target state="translated">MacOS X은 파일 이름을 재구성하여 악센트 등을 표현할 때 &quot;조합 문자&quot;를 사용합니다. 예를 들어, 문자 &lt;code&gt;&amp;ouml;&lt;/code&gt; 는 코드 포인트 &lt;code&gt;[111,776]&lt;/code&gt; 로 표시됩니다 . 여기서 &lt;code&gt;111&lt;/code&gt; 은 문자 &lt;code&gt;o&lt;/code&gt; 이고 &lt;code&gt;776&lt;/code&gt; 은 특수 악센트 문자 &quot;Combining Diaeresis&quot;입니다. 유니 코드를 정규화하는이 방법은 매우 드물게 사용됩니다. Erlang은 검색시 반대 방향으로 해당 파일 이름을 정규화하여 결합 악센트를 사용하는 파일 이름이 Erlang 응용 프로그램으로 전달되지 않도록합니다. Erlang에서 파일 이름 &quot;bj&amp;ouml;rn&quot;은 &lt;code&gt;[98,106,246,114,110]&lt;/code&gt; 이 아닌 [98,106,246,114,110]으로 검색됩니다 &lt;code&gt;[98,106,117,776,114,110]&lt;/code&gt; 파일 시스템은 다르게 생각할 수 있지만. 악센트 결합에 대한 정규화는 파일에 액세스 할 때 다시 수행되므로 일반적으로 Erlang 프로그래머는이를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="768e486d6aa5224dfa45f14bc7b92f9b71384261" translate="yes" xml:space="preserve">
          <source>Macro definitions have the following format:</source>
          <target state="translated">매크로 정의의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="c21df95bcab5149fd0542e1989e579553cef5ea9" translate="yes" xml:space="preserve">
          <source>Macros are expanded during compilation. A simple macro &lt;code&gt;?Const&lt;/code&gt; is replaced with &lt;code&gt;Replacement&lt;/code&gt;.</source>
          <target state="translated">컴파일 중에 매크로가 확장됩니다. 간단한 매크로 &lt;code&gt;?Const&lt;/code&gt; 가 &lt;code&gt;Replacement&lt;/code&gt; 로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="5ec67ef3c01b88ea7d04419a08a29e5d6ee738c6" translate="yes" xml:space="preserve">
          <source>Macros in the macros.tab file</source>
          <target state="translated">macros.tab 파일의 매크로</target>
        </trans-unit>
        <trans-unit id="bafb56f75026725c63578890f318e2634ca3f79f" translate="yes" xml:space="preserve">
          <source>Magically notice traces of the &lt;code&gt;et:trace_me/5&lt;/code&gt; function and make appropriate &lt;code&gt;Events&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;et:trace_me/5&lt;/code&gt; 함수의 흔적을 마술 처럼 보고 적절한 &lt;code&gt;Events&lt;/code&gt; 만듭니다.</target>
        </trans-unit>
        <trans-unit id="607c4f3f1fc132b892e746284e6f6a2a7788ff50" translate="yes" xml:space="preserve">
          <source>Mahajani</source>
          <target state="translated">Mahajani</target>
        </trans-unit>
        <trans-unit id="ce03a922df1904d63b3c52366acd1e4d5dfa8f72" translate="yes" xml:space="preserve">
          <source>Main API of the Event Trace (ET) application</source>
          <target state="translated">ET (Event Trace) 애플리케이션의 기본 API</target>
        </trans-unit>
        <trans-unit id="c9a8168cc646feb22f71f8973ad3e9998dbfe20e" translate="yes" xml:space="preserve">
          <source>Main API of the Megaco application</source>
          <target state="translated">Megaco 애플리케이션의 주요 API</target>
        </trans-unit>
        <trans-unit id="7290931f77376ec9118ea4cf32caad5589c36ebf" translate="yes" xml:space="preserve">
          <source>Main API of the Reltool application</source>
          <target state="translated">Reltool 애플리케이션의 기본 API</target>
        </trans-unit>
        <trans-unit id="014771aa765bee2f30af23c70717253cfb96da9f" translate="yes" xml:space="preserve">
          <source>Main API of the diameter application.</source>
          <target state="translated">직경 적용의 주요 API.</target>
        </trans-unit>
        <trans-unit id="4fcfcea0b000eea06fc6d4ed4be0088adbe04013" translate="yes" xml:space="preserve">
          <source>Main API of the ssh application</source>
          <target state="translated">ssh 애플리케이션의 기본 API</target>
        </trans-unit>
        <trans-unit id="4140ba76dde001a1b5b6d82503aaee2fca05b0aa" translate="yes" xml:space="preserve">
          <source>Main multiblock carrier size. Sets the size of the main multiblock carrier for allocator &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt;. The main multiblock carrier is allocated through &lt;code&gt;sys_alloc&lt;/code&gt; and is never deallocated.</source>
          <target state="translated">메인 멀티 블록 캐리어 크기. 할당 자 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 의 기본 멀티 블록 캐리어 크기를 설정합니다 . 기본 &lt;code&gt;sys_alloc&lt;/code&gt; 블록 캐리어는 sys_alloc을 통해 할당되며 할당 해제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98d070980c8de15123661b75681a9415be24bed3" translate="yes" xml:space="preserve">
          <source>Main user interface for the &lt;code&gt;Common Test&lt;/code&gt; framework.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 프레임 워크 의 기본 사용자 인터페이스</target>
        </trans-unit>
        <trans-unit id="34c6a81f8a68bddb86631e45d9f0b3b6bd8f93e5" translate="yes" xml:space="preserve">
          <source>Main user interface for the Common Test framework.</source>
          <target state="translated">공통 테스트 프레임 워크의 기본 사용자 인터페이스</target>
        </trans-unit>
        <trans-unit id="caf95b7396f0360a962cd9ce06b569c833ad967e" translate="yes" xml:space="preserve">
          <source>Maintenance of the fully connected network</source>
          <target state="translated">완전히 연결된 네트워크의 유지 관리</target>
        </trans-unit>
        <trans-unit id="97b7b36933fc3b0a0416b2f556a08cd0e6213e92" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;Deferred&lt;/code&gt; suites become the least preferred suites, that is put them at the end of the cipher suite list &lt;code&gt;Suites&lt;/code&gt; after removing them from &lt;code&gt;Suites&lt;/code&gt; if present. &lt;code&gt;Deferred&lt;/code&gt; may be a list of cipher suites or a list of filters in which case the filters are use on &lt;code&gt;Suites&lt;/code&gt; to extract the Deferred cipher list.</source>
          <target state="translated">확인 &lt;code&gt;Deferred&lt;/code&gt; 스위트 암호 스위트 목록의 마지막에 넣어 즉, 가장 선호하는 스위트 룸이 될 &lt;code&gt;Suites&lt;/code&gt; 에서 그들을 제거한 후 &lt;code&gt;Suites&lt;/code&gt; 있는 경우. &lt;code&gt;Deferred&lt;/code&gt; 는 암호 스위트 목록이거나 필터가 &lt;code&gt;Suites&lt;/code&gt; 에서 지연된 암호 목록을 추출하는 데 사용되는 필터 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="683ba771dba7958f68fbac6a0cabbea4e324174e" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;Deferred&lt;/code&gt; suites become the least preferred suites, that is put them at the end of the cipher suite list &lt;code&gt;Suites&lt;/code&gt; after removing them from &lt;code&gt;Suites&lt;/code&gt; if present. &lt;code&gt;Deferred&lt;/code&gt; may be a list of cipher suits or a list of filters in which case the filters are use on &lt;code&gt;Suites&lt;/code&gt; to extract the Deferred cipher list.</source>
          <target state="translated">&lt;code&gt;Deferred&lt;/code&gt; 스위트를 가장 선호하지 않는 스위트로 만드십시오. 스위트 스위트가있는 경우 &lt;code&gt;Suites&lt;/code&gt; 에서 스위트 &lt;code&gt;Suites&lt;/code&gt; 를 제거한 후 스위트 스위트 목록 끝에 배치합니다 . &lt;code&gt;Deferred&lt;/code&gt; 암호 목록 또는 필터 목록 일 수 있으며,이 경우 필터가 &lt;code&gt;Suites&lt;/code&gt; 에서 연기 된 암호 목록을 추출하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="26c15d02af3e15dd010130baee6fab8be956145d" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;Preferred&lt;/code&gt; suites become the most preferred suites that is put them at the head of the cipher suite list &lt;code&gt;Suites&lt;/code&gt; after removing them from &lt;code&gt;Suites&lt;/code&gt; if present. &lt;code&gt;Preferred&lt;/code&gt; may be a list of cipher suites or a list of filters in which case the filters are use on &lt;code&gt;Suites&lt;/code&gt; to extract the preferred cipher list.</source>
          <target state="translated">확인 &lt;code&gt;Preferred&lt;/code&gt; 스위트 룸은 암호 스위트 목록의 머리를 넣어 가장 선호하는 제품군이 될 &lt;code&gt;Suites&lt;/code&gt; 에서 그들을 제거한 후 &lt;code&gt;Suites&lt;/code&gt; 있는 경우. &lt;code&gt;Preferred&lt;/code&gt; 는 선호하는 암호 목록을 추출하기 위해 필터가 &lt;code&gt;Suites&lt;/code&gt; 에서 사용되는 경우 암호 스위트 목록 또는 필터 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d09c0a2ffb9d90565c340512a769d32848189c99" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;Preferred&lt;/code&gt; suites become the most preferred suites that is put them at the head of the cipher suite list &lt;code&gt;Suites&lt;/code&gt; after removing them from &lt;code&gt;Suites&lt;/code&gt; if present. &lt;code&gt;Preferred&lt;/code&gt; may be a list of cipher suits or a list of filters in which case the filters are use on &lt;code&gt;Suites&lt;/code&gt; to extract the preferred cipher list.</source>
          <target state="translated">확인 &lt;code&gt;Preferred&lt;/code&gt; 스위트 룸은 암호 스위트 목록의 머리를 넣어 가장 선호하는 제품군이 될 &lt;code&gt;Suites&lt;/code&gt; 에서 그들을 제거한 후 &lt;code&gt;Suites&lt;/code&gt; 있는 경우. &lt;code&gt;Preferred&lt;/code&gt; 는 암호 슈트 (cipher suit)의 목록 또는 필터가 선호하는 암호 목록을 추출하기 위해 &lt;code&gt;Suites&lt;/code&gt; 에서 필터를 사용하는 필터의 목록 일 수있다.</target>
        </trans-unit>
        <trans-unit id="b9ea499659acd96747d610ef617848faf8002c00" translate="yes" xml:space="preserve">
          <source>Make Dialyzer a bit more quiet.</source>
          <target state="translated">Dialyzer를 좀 더 조용하게 만드십시오.</target>
        </trans-unit>
        <trans-unit id="ee2cafda4f9116a303a421f649a4f70f2f925a8d" translate="yes" xml:space="preserve">
          <source>Make Dialyzer a bit more verbose.</source>
          <target state="translated">Dialyzer를 좀 더 장황하게 만드십시오.</target>
        </trans-unit>
        <trans-unit id="10ba2efeabebf0489b4847ad8643fcdf0992e15a" translate="yes" xml:space="preserve">
          <source>Make Dialyzer emit warnings even when manipulating the PLT. Warnings are only emitted for files that are analyzed.</source>
          <target state="translated">PLT를 조작 할 때도 Dialyzer에서 경고를 표시합니다. 경고는 분석 된 파일에 대해서만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7715175917b7a7d605296680b1ca41edb30157cf" translate="yes" xml:space="preserve">
          <source>Make Dialyzer print information about the PLT and then quit. The PLT can be specified with &lt;code&gt;--plt(s)&lt;/code&gt;.</source>
          <target state="translated">Dialyzer가 PLT에 대한 정보를 인쇄 한 다음 종료하십시오. PLT는 &lt;code&gt;--plt(s)&lt;/code&gt; 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f5adb962b2fbef3d7acd737ca5f836fe51e4afa" translate="yes" xml:space="preserve">
          <source>Make a copy of the Solaris standard configuration file for &lt;code&gt;syslogd&lt;/code&gt;. This file is usually named &lt;code&gt;syslog.conf&lt;/code&gt; and found in directory &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;syslogd&lt;/code&gt; 용 Solaris 표준 구성 파일의 사본을 작성하십시오 . 이 파일의 이름은 일반적으로 &lt;code&gt;syslog.conf&lt;/code&gt; 이며 &lt;code&gt;/etc&lt;/code&gt; 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="dafd7bb78e3c0fc4210ac348a96cd2dd1d2c78ff" translate="yes" xml:space="preserve">
          <source>Make a full copy of all the active access structures. This copy is called the staging area and is identified by the global atomic variable &lt;code&gt;the_staging_code_index&lt;/code&gt;.</source>
          <target state="translated">모든 활성 액세스 구조의 전체 사본을 작성하십시오. 이 복사본을 스테이징 영역이라고하며 전역 원자 변수 &lt;code&gt;the_staging_code_index&lt;/code&gt; 로 식별됩니다 .</target>
        </trans-unit>
        <trans-unit id="0e586a8c6ff263d0afce189a56818cee918e1347" translate="yes" xml:space="preserve">
          <source>Make a key out of an event record or an old key.</source>
          <target state="translated">이벤트 레코드 또는 이전 키에서 키를 만드십시오.</target>
        </trans-unit>
        <trans-unit id="1415885484de34303a471ea6db61c1acc9cb54f8" translate="yes" xml:space="preserve">
          <source>Make a simple hello world and try to compile it with the &lt;code&gt;cl&lt;/code&gt; command from within bash. If that does not work, your environment needs fixing. Remember, there should be no backslashes in your path environment variable in Cygwin bash, but LIB and INCLUDE should contain Windows style paths with semicolon, drive letters and backslashes.</source>
          <target state="translated">간단한 hello world를 만들고 bash 내 에서 &lt;code&gt;cl&lt;/code&gt; 명령 으로 컴파일하십시오 . 그래도 작동하지 않으면 환경을 수정해야합니다. Cygwin bash의 경로 환경 변수에는 백 슬래시가 없어야하지만 LIB 및 INCLUDE에는 세미콜론, 드라이브 문자 및 백 슬래시가있는 Windows 스타일 경로가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1dcb4e238263c7a5afbedf884d34e60decef3679" translate="yes" xml:space="preserve">
          <source>Make an edited copy of the backup copy previously made.</source>
          <target state="translated">이전에 작성된 백업 사본의 편집 사본을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="bfc8145db5663246acf8191e3d36605eb676990d" translate="yes" xml:space="preserve">
          <source>Make process &lt;code&gt;Pid&lt;/code&gt; the new owner of table &lt;code&gt;Tab&lt;/code&gt;. If successful, message &lt;code&gt;{'ETS-TRANSFER',Tab,FromPid,GiftData}&lt;/code&gt; is sent to the new owner.</source>
          <target state="translated">프로세스 &lt;code&gt;Pid&lt;/code&gt; 를 테이블 &lt;code&gt;Tab&lt;/code&gt; 의 새 소유자로 설정하십시오 . 성공하면 &lt;code&gt;{'ETS-TRANSFER',Tab,FromPid,GiftData}&lt;/code&gt; 메시지 가 새 소유자에게 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="7b44f78041d63c29886fd3ab915b1c7a217bbe5f" translate="yes" xml:space="preserve">
          <source>Make some particular suites the most preferred, or least preferred by changing prepend to append.</source>
          <target state="translated">prepend를 append로 변경하여 특정 스위트를 가장 선호하거나 가장 선호하는 스위트로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c2ba192403adbb128258a263d55b31ddd0872ee8" translate="yes" xml:space="preserve">
          <source>Make sure that the command &lt;code&gt;hostname&lt;/code&gt; returns a valid fully qualified host name (this is configured in &lt;code&gt;/etc/hostconfig&lt;/code&gt;). Otherwise you might experience problems when running distributed systems.</source>
          <target state="translated">&lt;code&gt;hostname&lt;/code&gt; 명령 이 유효한 완전한 호스트 이름을 리턴 하는지 확인하십시오 (이 이름은 &lt;code&gt;/etc/hostconfig&lt;/code&gt; 에 구성됨 ). 그렇지 않으면 분산 시스템을 실행할 때 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="605b087786603fea0d76e7acb85a392c7a2ca554" translate="yes" xml:space="preserve">
          <source>Make sure to install the basic dev tools, but avoid the MinGW autoconf and install the msys one instead.</source>
          <target state="translated">기본 개발 도구를 설치해야하지만 MinGW autoconf를 피하고 대신 msys 도구를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="f71b08b9686f12317202560047739ba3b1216b0e" translate="yes" xml:space="preserve">
          <source>Make sure to set the PATH so that NSIS and Microsoft SDK is found before the MSYS/Cygwin tools and that Java is last in the PATH.</source>
          <target state="translated">MSIS / Cygwin 도구 이전에 NSIS 및 Microsoft SDK가 있고 PATH에서 Java가 마지막이되도록 PATH를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="bf36bcf4ace9356a062d8090033e2ca09b36f682" translate="yes" xml:space="preserve">
          <source>Make sure you're in the top directory in the source tree.</source>
          <target state="translated">소스 트리의 최상위 디렉토리에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c7432411584b2a6828a2cfe381ef427f482a9a7d" translate="yes" xml:space="preserve">
          <source>Make that series of NIF calls from the Erlang level.</source>
          <target state="translated">Erlang 레벨에서 일련의 NIF 호출을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1f5db744ecb6a5d733780b21850a0e20203a81db" translate="yes" xml:space="preserve">
          <source>Make the client tell the server that the client accepts extension negotiation, that is, include &lt;code&gt;ext-info-c&lt;/code&gt; in the kexinit message sent. See &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8308&quot;&gt;RFC 8308&lt;/a&gt;&lt;/code&gt; for details and &lt;code&gt;ssh(6)&lt;/code&gt; for a list of currently implemented extensions.</source>
          <target state="translated">클라이언트가 클라이언트에게 확장 협상을 수락 함을 알리도록합니다. 즉, 보낸 kexinit 메시지에 &lt;code&gt;ext-info-c&lt;/code&gt; 를 포함시킵니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8308&quot;&gt;RFC 8308&lt;/a&gt;&lt;/code&gt; 을 참조하고 현재 구현 된 확장 목록은 &lt;code&gt;ssh(6)&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f086742bdd779ab84c5ff9b5ee2da13b93823b4f" translate="yes" xml:space="preserve">
          <source>Make the handling of large files fast by setting &lt;code&gt;time&lt;/code&gt;, but this will use more memory. The &lt;code&gt;space&lt;/code&gt; variant shrinks the memory requirements, but with a higher time consumption.</source>
          <target state="translated">&lt;code&gt;time&lt;/code&gt; 을 설정하여 대용량 파일을 빠르게 처리 할 수 있지만 이렇게하면 더 많은 메모리가 사용됩니다. &lt;code&gt;space&lt;/code&gt; 변형은 메모리 요구 사항을 축소하지만, 더 높은 시간 소비.</target>
        </trans-unit>
        <trans-unit id="d5035cf3f169978e011505d0d2efbb3700dc36cf" translate="yes" xml:space="preserve">
          <source>Make the server (daemon) tell the client that the server accepts extension negotiation, that is, include &lt;code&gt;ext-info-s&lt;/code&gt; in the kexinit message sent. See &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8308&quot;&gt;RFC 8308&lt;/a&gt;&lt;/code&gt; for details and &lt;code&gt;ssh(6)&lt;/code&gt; for a list of currently implemented extensions.</source>
          <target state="translated">서버 (데몬)가 클라이언트에게 서버가 확장 협상을 수락 함을 알려줍니다 (즉, 보낸 kexinit 메시지에 &lt;code&gt;ext-info-s&lt;/code&gt; 포함) . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8308&quot;&gt;RFC 8308&lt;/a&gt;&lt;/code&gt; 을 참조하고 현재 구현 된 확장 목록은 &lt;code&gt;ssh(6)&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="93635322e3d683204b0ba689a72acc16c2071f8e" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;init&lt;/code&gt; call the specified function. &lt;code&gt;Func&lt;/code&gt; defaults to &lt;code&gt;start&lt;/code&gt;. If no arguments are provided, the function is assumed to be of arity 0. Otherwise it is assumed to be of arity 1, taking the list &lt;code&gt;[Arg1,Arg2,...]&lt;/code&gt; as argument. All arguments are passed as atoms. See &lt;code&gt;&lt;a href=&quot;init&quot;&gt; init(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">차종은 &lt;code&gt;init&lt;/code&gt; 지정된 함수를 호출합니다. &lt;code&gt;Func&lt;/code&gt; 의 기본값은 &lt;code&gt;start&lt;/code&gt; 입니다. 인수가 제공되지 않으면 함수는 arity 0으로 간주됩니다. 그렇지 않으면 인수로 &lt;code&gt;[Arg1,Arg2,...]&lt;/code&gt; 목록을 사용하여 arity 1로 간주됩니다 . 모든 인수는 원자로 전달됩니다. &lt;code&gt;&lt;a href=&quot;init&quot;&gt; init(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="93aa92102b400ac9f00b97c87885b225d1e6c53c" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;init&lt;/code&gt; call the specified function. &lt;code&gt;Func&lt;/code&gt; defaults to &lt;code&gt;start&lt;/code&gt;. If no arguments are provided, the function is assumed to be of arity 0. Otherwise it is assumed to be of arity 1, taking the list &lt;code&gt;[Arg1,Arg2,...]&lt;/code&gt; as argument. All arguments are passed as atoms. See &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">차종은 &lt;code&gt;init&lt;/code&gt; 지정된 함수를 호출합니다. 기본적으로 &lt;code&gt;Func&lt;/code&gt; 가 &lt;code&gt;start&lt;/code&gt; 됩니다. 인수가 제공되지 않으면 함수는 arity 0 인 것으로 가정합니다. 그렇지 않으면 목록 &lt;code&gt;[Arg1,Arg2,...]&lt;/code&gt; 를 인수로 사용 하여 arity 1 인 것으로 가정합니다 . 모든 인수는 원자로 전달됩니다. &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9ea1b4687eb85a92b7f1801d82c53a8f83c6123" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;init&lt;/code&gt; call the specified function. &lt;code&gt;Func&lt;/code&gt; defaults to &lt;code&gt;start&lt;/code&gt;. If no arguments are provided, the function is assumed to be of arity 0. Otherwise it is assumed to be of arity 1, taking the list &lt;code&gt;[Arg1,Arg2,...]&lt;/code&gt; as argument. All arguments are passed as strings. See &lt;code&gt;&lt;a href=&quot;init&quot;&gt; init(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">차종은 &lt;code&gt;init&lt;/code&gt; 지정된 함수를 호출합니다. &lt;code&gt;Func&lt;/code&gt; 의 기본값은 &lt;code&gt;start&lt;/code&gt; 입니다. 인수가 제공되지 않으면 함수는 arity 0으로 간주됩니다. 그렇지 않으면 인수로 &lt;code&gt;[Arg1,Arg2,...]&lt;/code&gt; 목록을 사용하여 arity 1로 간주됩니다 . 모든 인수는 문자열로 전달됩니다. &lt;code&gt;&lt;a href=&quot;init&quot;&gt; init(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc491ef04c29a912ad13bb0dab3aa78550c1a0b0" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;init&lt;/code&gt; call the specified function. &lt;code&gt;Func&lt;/code&gt; defaults to &lt;code&gt;start&lt;/code&gt;. If no arguments are provided, the function is assumed to be of arity 0. Otherwise it is assumed to be of arity 1, taking the list &lt;code&gt;[Arg1,Arg2,...]&lt;/code&gt; as argument. All arguments are passed as strings. See &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">차종은 &lt;code&gt;init&lt;/code&gt; 지정된 함수를 호출합니다. 기본적으로 &lt;code&gt;Func&lt;/code&gt; 가 &lt;code&gt;start&lt;/code&gt; 됩니다. 인수가 제공되지 않으면 함수는 arity 0 인 것으로 가정합니다. 그렇지 않으면 목록 &lt;code&gt;[Arg1,Arg2,...]&lt;/code&gt; 를 인수로 사용 하여 arity 1 인 것으로 가정합니다 . 모든 인수는 문자열로 전달됩니다. &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="effbaf150909b5681b041c7c93ee8c1dd9234e3b" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;init&lt;/code&gt; evaluate the expression &lt;code&gt;Expr&lt;/code&gt;; see &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">만듭니다 &lt;code&gt;init&lt;/code&gt; 식 평가 &lt;code&gt;Expr&lt;/code&gt; ; &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f6e437de83ae71822d270a49d45206d77f45c59" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;init&lt;/code&gt; write some debug information while interpreting the boot script.</source>
          <target state="translated">차종은 &lt;code&gt;init&lt;/code&gt; 부트 스크립트를 해석하면서 일부 디버그 정보를 기록.</target>
        </trans-unit>
        <trans-unit id="1c12aa164fb9326a07158879ddf33e08ec2da65e" translate="yes" xml:space="preserve">
          <source>Makes a &lt;code&gt;badarg&lt;/code&gt; exception to be returned from a NIF, and associates it with environment &lt;code&gt;env&lt;/code&gt;. Once a NIF or any function it calls invokes &lt;code&gt;enif_make_badarg&lt;/code&gt;, the runtime ensures that a &lt;code&gt;badarg&lt;/code&gt; exception is raised when the NIF returns, even if the NIF attempts to return a non-exception term instead.</source>
          <target state="translated">만든다 &lt;code&gt;badarg&lt;/code&gt; 의 NIF로부터 반환되는 예외 및 환경과 관련 짓 &lt;code&gt;env&lt;/code&gt; . NIF 또는 호출하는 함수가 &lt;code&gt;enif_make_badarg&lt;/code&gt; 를 호출하면 런타임은 NIF가 예외가 아닌 용어를 대신 리턴하려고 시도하더라도 NIF가 리턴 될 때 &lt;code&gt;badarg&lt;/code&gt; 예외가 발생하도록합니다.</target>
        </trans-unit>
        <trans-unit id="237c55ef12224693f0ea9298c5b4012406e52202" translate="yes" xml:space="preserve">
          <source>Makes a binary term from &lt;code&gt;bin&lt;/code&gt;. Any ownership of the binary data is transferred to the created term and &lt;code&gt;bin&lt;/code&gt; is to be considered read-only for the rest of the NIF call and then as released.</source>
          <target state="translated">&lt;code&gt;bin&lt;/code&gt; 에서 이진 용어를 만듭니다 . 이진 데이터의 소유권은 생성 된 용어로 이전되며 나머지 NIF 호출에 대해서는 &lt;code&gt;bin&lt;/code&gt; 이 읽기 전용으로 간주되어 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="b692874a74db2c05c40ad42ce60cf8791216d646" translate="yes" xml:space="preserve">
          <source>Makes a copy of map &lt;code&gt;map_in&lt;/code&gt; and inserts &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; already exists in &lt;code&gt;map_in&lt;/code&gt;, the old associated value is replaced by &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map_in&lt;/code&gt; 맵의 복사본을 만들고 &lt;code&gt;value&lt;/code&gt; 가있는 &lt;code&gt;key&lt;/code&gt; 를 삽입 합니다 . 경우 &lt;code&gt;key&lt;/code&gt; 이미 존재 &lt;code&gt;map_in&lt;/code&gt; 이전 관련 값으로 대체 &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bdd484fa8278609492e238310d156b1e791c1d1" translate="yes" xml:space="preserve">
          <source>Makes a copy of map &lt;code&gt;map_in&lt;/code&gt; and replace the old associated value for &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;new_value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map_in&lt;/code&gt; 맵의 사본을 작성 하고 &lt;code&gt;key&lt;/code&gt; 에 대한 이전 연관된 값을 &lt;code&gt;new_value&lt;/code&gt; 로바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="ca6b1dc8e5e0672574d5436088c1dcb75a32cecf" translate="yes" xml:space="preserve">
          <source>Makes a copy of term &lt;code&gt;src_term&lt;/code&gt;. The copy is created in environment &lt;code&gt;dst_env&lt;/code&gt;. The source term can be located in any environment.</source>
          <target state="translated">용어 &lt;code&gt;src_term&lt;/code&gt; 의 사본을 작성 합니다. 사본은 환경 &lt;code&gt;dst_env&lt;/code&gt; 에 작성됩니다 . 소스 용어는 모든 환경에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f47a6753bc06d4318555d47c144bd14353686e3" translate="yes" xml:space="preserve">
          <source>Makes a hard link from &lt;code&gt;Existing&lt;/code&gt; to &lt;code&gt;New&lt;/code&gt; on platforms supporting links (Unix and Windows). This function returns &lt;code&gt;ok&lt;/code&gt; if the link was successfully created, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;. On platforms not supporting links, &lt;code&gt;{error,enotsup}&lt;/code&gt; is returned.</source>
          <target state="translated">링크를 지원하는 플랫폼 (Unix 및 Windows) 에서 &lt;code&gt;Existing&lt;/code&gt; 에서 &lt;code&gt;New&lt;/code&gt; 로 하드 링크를 만듭니다 . 링크가 성공적으로 작성되면 이 함수는 &lt;code&gt;ok&lt;/code&gt; 를 리턴 하고, 그렇지 않으면 &lt;code&gt;{error, Reason}&lt;/code&gt; 리턴합니다 . 링크를 지원하지 않는 플랫폼에서는 &lt;code&gt;{error,enotsup}&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="31595caf2c636a46957c7deabbd5e7359493a864" translate="yes" xml:space="preserve">
          <source>Makes a map term from the given keys and values.</source>
          <target state="translated">주어진 키와 값으로 맵 용어를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5faa6d950f146c4cea5b655391ad27bfb6046562" translate="yes" xml:space="preserve">
          <source>Makes a node into a hidden node.</source>
          <target state="translated">노드를 숨겨진 노드로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bff410db84d22381d23b1c5efa073c2289972394" translate="yes" xml:space="preserve">
          <source>Makes a pid term from &lt;code&gt;*pid&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*pid&lt;/code&gt; 에서 pid 용어를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="89a04157c6789f62d77b3947257f75e905e4072a" translate="yes" xml:space="preserve">
          <source>Makes a pid term or the atom &lt;code&gt;&lt;a href=&quot;#enif_set_pid_undefined&quot;&gt; undefined&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;*pid&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*pid&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;#enif_set_pid_undefined&quot;&gt; undefined&lt;/a&gt;&lt;/code&gt; pid 용어 또는 원자를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="7dd7181219d969635c334047d9c09a9edcb4c4b1" translate="yes" xml:space="preserve">
          <source>Makes a printout of all interpreted modules. Modules are printed together with the full path name of the corresponding source code file.</source>
          <target state="translated">해석 된 모든 모듈을 인쇄합니다. 모듈은 해당 소스 코드 파일의 전체 경로 이름과 함께 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="401f2043961677427104b10d6d8254a7b9499556" translate="yes" xml:space="preserve">
          <source>Makes a runtime system into a node, using long node names.</source>
          <target state="translated">긴 노드 이름을 사용하여 런타임 시스템을 노드로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bcf8732784b73fa9047c7ff22861f746856adbaa" translate="yes" xml:space="preserve">
          <source>Makes a runtime system into a node, using short node names.</source>
          <target state="translated">짧은 노드 이름을 사용하여 런타임 시스템을 노드로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="dd9eb421a3c6821005298718ecb81d1924332eb6" translate="yes" xml:space="preserve">
          <source>Makes a subbinary of binary &lt;code&gt;bin_term&lt;/code&gt;, starting at zero-based position &lt;code&gt;pos&lt;/code&gt; with a length of &lt;code&gt;size&lt;/code&gt; bytes. &lt;code&gt;bin_term&lt;/code&gt; must be a binary or bitstring. &lt;code&gt;pos+size&lt;/code&gt; must be less or equal to the number of whole bytes in &lt;code&gt;bin_term&lt;/code&gt;.</source>
          <target state="translated">이진의 subbinary 만든다 &lt;code&gt;bin_term&lt;/code&gt; 제로 위치에서 시작하여, &lt;code&gt;pos&lt;/code&gt; 의 길이와 &lt;code&gt;size&lt;/code&gt; 바이트. &lt;code&gt;bin_term&lt;/code&gt; 은 이진 또는 비트 열 이어야합니다. &lt;code&gt;pos+size&lt;/code&gt; 는 &lt;code&gt;bin_term&lt;/code&gt; 의 전체 바이트 수보다 작거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="7262155d7bc31943fbd8dc38a73406384f311be3" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to all &lt;code&gt;gen_server&lt;/code&gt; processes locally registered as &lt;code&gt;Name&lt;/code&gt; at the specified nodes by first sending a request to every node and then waits for the replies. The &lt;code&gt;gen_server&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt; Module:handle_call/3&lt;/a&gt;&lt;/code&gt; to handle the request.</source>
          <target state="translated">먼저 모든 노드에 요청을 보내고 응답을 기다림으로써 지정된 노드에서 &lt;code&gt;Name&lt;/code&gt; 으로 로컬로 등록 된 모든 &lt;code&gt;gen_server&lt;/code&gt; 프로세스에 대한 동기 호출을 수행합니다. &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스를 호출 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt; Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 요청을 처리 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1da6e2cfd5a96004af2990791a93360f29c745d3" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to all &lt;code&gt;gen_server&lt;/code&gt; processes locally registered as &lt;code&gt;Name&lt;/code&gt; at the specified nodes by first sending a request to every node and then waits for the replies. The &lt;code&gt;gen_server&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; to handle the request.</source>
          <target state="translated">먼저 모든 노드에 요청을 보낸 다음 지정된 노드에서 &lt;code&gt;Name&lt;/code&gt; 으로 로컬로 등록 된 모든 &lt;code&gt;gen_server&lt;/code&gt; 프로세스 를 동기 호출 하여 응답을 기다립니다. &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스를 호출 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 요청을 처리 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="378a856d28e2805c7ccd54bf685ba494b6362dc9" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to event handler &lt;code&gt;Handler&lt;/code&gt; installed in event manager &lt;code&gt;EventMgrRef&lt;/code&gt; by sending a request and waiting until a reply arrives or a time-out occurs. The event manager calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-2&quot;&gt; Module:handle_call/2&lt;/a&gt;&lt;/code&gt; to handle the request.</source>
          <target state="translated">요청을 보내고 응답이 도착하거나 시간 초과가 발생할 때까지 대기하여 이벤트 관리자 &lt;code&gt;EventMgrRef&lt;/code&gt; 에 설치된 이벤트 처리기 &lt;code&gt;Handler&lt;/code&gt; 를 동 기적으로 호출 합니다. 이벤트 관리자는 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-2&quot;&gt; Module:handle_call/2&lt;/a&gt;&lt;/code&gt; 를 호출 하여 요청을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="ea1c1ab573f83f8ab3377d2d58aa5424f46f4767" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to event handler &lt;code&gt;Handler&lt;/code&gt; installed in event manager &lt;code&gt;EventMgrRef&lt;/code&gt; by sending a request and waiting until a reply arrives or a time-out occurs. The event manager calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-2&quot;&gt;Module:handle_call/2&lt;/a&gt;&lt;/code&gt; to handle the request.</source>
          <target state="translated">요청을 보내고 응답이 도착하거나 시간 종료가 발생할 때까지 대기하여 이벤트 관리자 &lt;code&gt;EventMgrRef&lt;/code&gt; 에 설치된 이벤트 핸들러 &lt;code&gt;Handler&lt;/code&gt; 대한 동기 호출을 작성 합니다. 이벤트 관리자는 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-2&quot;&gt;Module:handle_call/2&lt;/a&gt;&lt;/code&gt; 를 호출 하여 요청을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="73018f52a5d37426cbfbcafd584e4bff3254755a" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to the &lt;code&gt;ServerRef&lt;/code&gt; of the &lt;code&gt;gen_server&lt;/code&gt; process by sending a request and waiting until a reply arrives or a time-out occurs. The &lt;code&gt;gen_server&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt; Module:handle_call/3&lt;/a&gt;&lt;/code&gt; to handle the request.</source>
          <target state="translated">요청을 보내고 응답이 도착하거나 시간 초과가 발생할 때까지 대기 하여 &lt;code&gt;gen_server&lt;/code&gt; 프로세스 의 &lt;code&gt;ServerRef&lt;/code&gt; 에 대한 동기 호출을 작성 합니다. &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스를 호출 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt; Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 요청을 처리 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f82c270c0090923069cb76b8c5ac5d301204fbd0" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to the &lt;code&gt;ServerRef&lt;/code&gt; of the &lt;code&gt;gen_server&lt;/code&gt; process by sending a request and waiting until a reply arrives or a time-out occurs. The &lt;code&gt;gen_server&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; to handle the request.</source>
          <target state="translated">요청을 보내고 응답이 도착하거나 시간 종료가 발생할 때까지 대기 하여 &lt;code&gt;gen_server&lt;/code&gt; 프로세스 의 &lt;code&gt;ServerRef&lt;/code&gt; 에 대한 동기 호출을 작성 합니다. &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스를 호출 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 요청을 처리 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f2c5c0d01b79b1beb9e9e9be1f42f74eb88acd6" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to the &lt;code&gt;gen_statem&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;ServerRef&lt;/a&gt;&lt;/code&gt; by sending a request and waiting until its reply arrives. The &lt;code&gt;gen_statem&lt;/code&gt; calls the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;{call,From}&lt;/code&gt; and event content &lt;code&gt;Request&lt;/code&gt;.</source>
          <target state="translated">요청을 보내고 응답이 도착할 때까지 기다림으로써 &lt;code&gt;gen_statem&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;ServerRef&lt;/a&gt;&lt;/code&gt; 에 대한 동기 호출을 수행 합니다. &lt;code&gt;gen_statem&lt;/code&gt; 가 부르는 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;{call,From}&lt;/code&gt; 및 이벤트 콘텐츠 &lt;code&gt;Request&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e047abadcd4125bf1a47c5e3a18f5763c2f66409" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to the &lt;code&gt;gen_statem&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;ServerRef&lt;/a&gt;&lt;/code&gt; by sending a request and waiting until its reply arrives. The &lt;code&gt;gen_statem&lt;/code&gt; calls the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;{call,From}&lt;/code&gt; and event content &lt;code&gt;Request&lt;/code&gt;.</source>
          <target state="translated">요청을 보내고 응답이 도착할 때까지 대기 하여 &lt;code&gt;gen_statem&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;ServerRef&lt;/a&gt;&lt;/code&gt; 에 대한 동기 호출을 작성합니다 . &lt;code&gt;gen_statem&lt;/code&gt; 가 부르는 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;{call,From}&lt;/code&gt; 및 이벤트 콘텐츠 &lt;code&gt;Request&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5e97befb3fc0e650a9c087f592d9705da519e48" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to the channel process by sending a message and waiting until a reply arrives, or a time-out occurs. The channel calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; to handle the message. If the channel process does not exist, &lt;code&gt;{error, closed}&lt;/code&gt; is returned.</source>
          <target state="translated">메시지를 보내고 응답이 도착할 때까지 또는 시간 종료가 발생할 때까지 대기하여 채널 프로세스에 대한 동기 호출을 작성합니다. 채널 은 메시지를 처리하기 위해 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 을 호출 합니다. 채널 프로세스가 존재하지 않으면 &lt;code&gt;{error, closed}&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="eb060cc8d8a3df5d96be3f4fcf2d8f7d2bded14f" translate="yes" xml:space="preserve">
          <source>Makes a trace pattern suitable to feed change_pattern/1</source>
          <target state="translated">트레이스 패턴을 change_pattern / 1에 공급하기에 적합하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ea447adb75c049935be0ade2d24d0e02a46cb4ff" translate="yes" xml:space="preserve">
          <source>Makes all the preprocessor macros of EUnit available, to help writing tests</source>
          <target state="translated">테스트 작성을 돕기 위해 EUnit의 모든 전 처리기 매크로를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97e3039873bad96bb14bae33094fcd93e52bc160" translate="yes" xml:space="preserve">
          <source>Makes all warnings into errors.</source>
          <target state="translated">모든 경고를 오류로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="247956d646f73c5083d686557419faaf07611729" translate="yes" xml:space="preserve">
          <source>Makes an empty map term.</source>
          <target state="translated">빈 맵 용어를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="48107dc847232e089a1763920ba9c6eb752826f4" translate="yes" xml:space="preserve">
          <source>Makes an existing process an &lt;code&gt;ssh_client_channel&lt;/code&gt; (replaces ssh_channel) process. Does not return, instead the calling process enters the &lt;code&gt;ssh_client_channel&lt;/code&gt; (replaces ssh_channel) process receive loop and become an &lt;code&gt;ssh_client_channel&lt;/code&gt; process. The process must have been started using one of the start functions in &lt;code&gt;proc_lib&lt;/code&gt;, see the &lt;code&gt;proc_lib(3)&lt;/code&gt; manual page in STDLIB. The user is responsible for any initialization of the process and must call &lt;code&gt;&lt;a href=&quot;#init-1&quot;&gt;init/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기존 프로세스를 &lt;code&gt;ssh_client_channel&lt;/code&gt; (ssh_channel 대체) 프로세스로 만듭니다. 리턴하지 않고 대신 호출 프로세스는 &lt;code&gt;ssh_client_channel&lt;/code&gt; (ssh_channel을 대체 함) 프로세스 수신 루프로 &lt;code&gt;ssh_client_channel&lt;/code&gt; 프로세스가됩니다. 프로세스는 &lt;code&gt;proc_lib&lt;/code&gt; 의 시작 함수 중 하나를 사용하여 시작해야합니다 . &lt;code&gt;proc_lib(3)&lt;/code&gt; 의 proc_lib (3) 매뉴얼 페이지를 참조하십시오. 사용자는 프로세스 초기화에 대한 책임이 있으며 &lt;code&gt;&lt;a href=&quot;#init-1&quot;&gt;init/1&lt;/a&gt;&lt;/code&gt; 을 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="22bc96ed22188f42e5c515e5da6efb8258670300" translate="yes" xml:space="preserve">
          <source>Makes an existing process into a &lt;code&gt;gen_server&lt;/code&gt; process. Does not return, instead the calling process enters the &lt;code&gt;gen_server&lt;/code&gt; process receive loop and becomes a &lt;code&gt;gen_server&lt;/code&gt; process. The process &lt;strong&gt;must&lt;/strong&gt; have been started using one of the start functions in &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib(3)&lt;/a&gt;&lt;/code&gt;. The user is responsible for any initialization of the process, including registering a name for it.</source>
          <target state="translated">기존 프로세스를 &lt;code&gt;gen_server&lt;/code&gt; 프로세스 로 만듭니다 . 리턴하지 않고 대신 호출 프로세스는 &lt;code&gt;gen_server&lt;/code&gt; 프로세스 수신 루프로 &lt;code&gt;gen_server&lt;/code&gt; 프로세스가됩니다. 프로세스 &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib(3)&lt;/a&gt;&lt;/code&gt; 의 시작 함수 중 하나를 사용하여 시작 &lt;strong&gt;해야합니다&lt;/strong&gt; . 사용자는 프로세스의 이름 등록을 포함하여 프로세스의 초기화에 대한 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca23188a55ed798e178a8cdc711ee096dc651317" translate="yes" xml:space="preserve">
          <source>Makes another copy of a table at the node &lt;code&gt;Node&lt;/code&gt;. Argument &lt;code&gt;Type&lt;/code&gt; must be either of the atoms &lt;code&gt;ram_copies&lt;/code&gt;, &lt;code&gt;disc_copies&lt;/code&gt;, or &lt;code&gt;disc_only_copies&lt;/code&gt;. For example, the following call ensures that a disc replica of the &lt;code&gt;person&lt;/code&gt; table also exists at node &lt;code&gt;Node&lt;/code&gt;:</source>
          <target state="translated">노드 &lt;code&gt;Node&lt;/code&gt; 에 테이블의 다른 사본을 만듭니다 . 인수 &lt;code&gt;Type&lt;/code&gt; 은 원자 &lt;code&gt;ram_copies&lt;/code&gt; , &lt;code&gt;disc_copies&lt;/code&gt; 또는 &lt;code&gt;disc_only_copies&lt;/code&gt; 중 하나 여야합니다 . 예를 들어, 다음 호출은 &lt;code&gt;person&lt;/code&gt; 테이블 의 디스크 복제본이 노드 &lt;code&gt;Node&lt;/code&gt; 에도 존재 하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="aa974f84878c85c9522eb437dfa9236890e3b59a" translate="yes" xml:space="preserve">
          <source>Makes any process created by a traced process inherit its trace flags, including flag &lt;code&gt;set_on_spawn&lt;/code&gt;.</source>
          <target state="translated">추적 된 프로세스로 작성된 프로세스가 플래그 &lt;code&gt;set_on_spawn&lt;/code&gt; 을 포함하여 추적 플래그를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="d6fe67417b1a2349e7be32124ba5fe55fba98791" translate="yes" xml:space="preserve">
          <source>Makes any process linked by a traced process inherit its trace flags, including flag &lt;code&gt;set_on_link&lt;/code&gt;.</source>
          <target state="translated">추적 된 프로세스로 링크 된 프로세스가 플래그 &lt;code&gt;set_on_link&lt;/code&gt; 를 포함하여 해당 추적 플래그를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="81962eacd7a836ddf3c4da74a5b02410645fe00a" translate="yes" xml:space="preserve">
          <source>Makes copies of the source file for the given modules, where it for each executable line is specified how many times it has been executed.</source>
          <target state="translated">주어진 모듈에 대한 소스 파일의 사본을 작성합니다. 여기서 각 실행 파일 라인에 대해 실행 횟수가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="91fe360029900348adebe5c87f81ee0c4d1d7bfa" translate="yes" xml:space="preserve">
          <source>Makes it possible to handle removal of releases outside the release handler. Tells the release handler that the release is removed from the system. This function does not delete any files.</source>
          <target state="translated">릴리스 핸들러 외부에서 릴리스 제거를 처리 할 수 ​​있습니다. 릴리스 핸들러가 릴리스가 시스템에서 제거되었음을 알려줍니다. 이 기능은 파일을 삭제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8d3cd6f1fa13ad3388a331a2a27038c3db886f4" translate="yes" xml:space="preserve">
          <source>Makes it possible to handle unpacking of releases outside the release handler. Tells the release handler that the release is unpacked. &lt;code&gt;Vsn&lt;/code&gt; is extracted from the release resource file &lt;code&gt;RelFile&lt;/code&gt;.</source>
          <target state="translated">릴리스 핸들러 외부에서 릴리스 풀기를 처리 할 수 ​​있습니다. 릴리스 처리기에 릴리스가 압축 해제되었음을 알립니다. 릴리스 자원 파일 &lt;code&gt;RelFile&lt;/code&gt; 에서 &lt;code&gt;Vsn&lt;/code&gt; 이 추출됩니다 .</target>
        </trans-unit>
        <trans-unit id="550cc3842fa85cd7551150ef1a3ffbb8ecf08f4e" translate="yes" xml:space="preserve">
          <source>Makes it possible to read or write gzip compressed files. Option &lt;code&gt;compressed&lt;/code&gt; must be combined with &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt;, but not both. Notice that the file size obtained with &lt;code&gt;&lt;a href=&quot;#read_file_info-1&quot;&gt;read_file_info/1&lt;/a&gt;&lt;/code&gt; does probably not match the number of bytes that can be read from a compressed file.</source>
          <target state="translated">gzip 압축 파일을 읽거나 쓸 수 있습니다. &lt;code&gt;compressed&lt;/code&gt; 옵션 은 &lt;code&gt;read&lt;/code&gt; 또는 &lt;code&gt;write&lt;/code&gt; 와 결합해야 하지만 둘다는 아닙니다. &lt;code&gt;&lt;a href=&quot;#read_file_info-1&quot;&gt;read_file_info/1&lt;/a&gt;&lt;/code&gt; 로 얻은 파일 크기 는 압축 파일에서 읽을 수있는 바이트 수와 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47c408fbb745313fb815eff80dafd2c1c61a239e" translate="yes" xml:space="preserve">
          <source>Makes necessary initializations and returns the initial channel state if the initializations succeed.</source>
          <target state="translated">초기화가 성공하면 필요한 초기화를 수행하고 초기 채널 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fa89cf81f10044b652f143f54fcc25e4b34fd715" translate="yes" xml:space="preserve">
          <source>Makes the &lt;code&gt;efile&lt;/code&gt; loader write some debug information, such as the reason for failures, while it handles files.</source>
          <target state="translated">차종 &lt;code&gt;efile&lt;/code&gt; 이 파일을 처리하는 동안, 이러한 실패에 대한 이유와 같은 일부 디버그 정보를 작성 로더.</target>
        </trans-unit>
        <trans-unit id="d304b67681b86e2abd50ebc5b49fc156fedec9bb" translate="yes" xml:space="preserve">
          <source>Makes the Erlang emulator be restarted (with whatever parameters are registered for the service at the occasion) when it stops. If the emulator stops again within 10 seconds, it is not restarted to avoid an infinite loop, which could hang the Windows system.</source>
          <target state="translated">Erlang 에뮬레이터가 중지 될 때 서비스에 등록 된 매개 변수를 사용하여 다시 시작합니다. 에뮬레이터가 10 초 내에 다시 중지되면 무한 루프를 피하기 위해 다시 시작되지 않아 Windows 시스템이 정지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3a7e58acd1b6273937af4828973ccfe2aa9acaf" translate="yes" xml:space="preserve">
          <source>Makes the Erlang runtime system into a distributed node, similar to &lt;code&gt;-name&lt;/code&gt;, but the host name portion of the node name &lt;code&gt;Name@Host&lt;/code&gt; will be the short name, not fully qualified.</source>
          <target state="translated">Erlang 런타임 시스템을 &lt;code&gt;-name&lt;/code&gt; 과 유사한 분산 노드로 만들지 만 노드 이름 &lt;code&gt;Name@Host&lt;/code&gt; 의 호스트 이름 부분은 완전한 이름이 아닌 짧은 이름입니다.</target>
        </trans-unit>
        <trans-unit id="40ffd151e829beb987a01b9018b4b4d87ff04f18" translate="yes" xml:space="preserve">
          <source>Makes the Erlang runtime system into a distributed node, similar to &lt;code&gt;&lt;a href=&quot;#name&quot;&gt;-name&lt;/a&gt;&lt;/code&gt;, but the host name portion of the node name &lt;code&gt;Name@Host&lt;/code&gt; will be the short name, not fully qualified.</source>
          <target state="translated">Erlang 런타임 시스템을 &lt;code&gt;&lt;a href=&quot;#name&quot;&gt;-name&lt;/a&gt;&lt;/code&gt; 과 유사한 분산 노드로 만들지 만 노드 이름 &lt;code&gt;Name@Host&lt;/code&gt; 의 호스트 이름 부분은 정규화되지 않은 짧은 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c9cf5142abfabd14124fcdb58d0036a8bd902fda" translate="yes" xml:space="preserve">
          <source>Makes the Erlang runtime system into a distributed node. This flag invokes all network servers necessary for a node to become distributed; see &lt;code&gt; net_kernel(3)&lt;/code&gt;. It is also ensured that &lt;code&gt;epmd&lt;/code&gt; runs on the current host before Erlang is started; see &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd(1)&lt;/a&gt;&lt;/code&gt;.and the &lt;code&gt;&lt;a href=&quot;#start_epmd&quot;&gt;-start_epmd&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">Erlang 런타임 시스템을 분산 노드로 만듭니다. 이 플래그는 노드가 분산되는 데 필요한 모든 네트워크 서버를 호출합니다. &lt;code&gt; net_kernel(3)&lt;/code&gt; 참조하십시오 . 또한 Erlang이 시작되기 전에 &lt;code&gt;epmd&lt;/code&gt; 가 현재 호스트에서 실행 되도록합니다 . &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd(1)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#start_epmd&quot;&gt;-start_epmd&lt;/a&gt;&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7aa031d2e4d7c3b20a440dd107fb282795ac6f0" translate="yes" xml:space="preserve">
          <source>Makes the Erlang runtime system into a distributed node. This flag invokes all network servers necessary for a node to become distributed; see &lt;code&gt;net_kernel(3)&lt;/code&gt;. It is also ensured that &lt;code&gt;epmd&lt;/code&gt; runs on the current host before Erlang is started; see &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd(1)&lt;/a&gt;&lt;/code&gt;.and the &lt;code&gt;&lt;a href=&quot;#start_epmd&quot;&gt;-start_epmd&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">Erlang 런타임 시스템을 분산 노드로 만듭니다. 이 플래그는 노드가 분배되는 데 필요한 모든 네트워크 서버를 호출합니다. &lt;code&gt;net_kernel(3)&lt;/code&gt; 참조하십시오 . Erlang이 시작되기 전에 &lt;code&gt;epmd&lt;/code&gt; 가 현재 호스트에서 실행 되도록 보장합니다 . &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd(1)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#start_epmd&quot;&gt;-start_epmd&lt;/a&gt;&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8a750500054d695ef79dc67c8e3f89388948a20" translate="yes" xml:space="preserve">
          <source>Makes the Erlang runtime system invoke &lt;code&gt;make:all()&lt;/code&gt; in the current working directory and then terminate; see &lt;code&gt;make(3)&lt;/code&gt;. Implies &lt;code&gt;-noinput&lt;/code&gt;.</source>
          <target state="translated">Erlang 런타임 시스템 이 현재 작업 디렉토리에서 &lt;code&gt;make:all()&lt;/code&gt; 을 호출 한 다음 종료합니다. &lt;code&gt;make(3)&lt;/code&gt; 참조하십시오 . &lt;code&gt;-noinput&lt;/code&gt; 을 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="c606e85ac2aed92be8eb1ce19cdcab5a15e4f9b9" translate="yes" xml:space="preserve">
          <source>Makes the array resizable. (Reverses the effects of &lt;code&gt;&lt;a href=&quot;#fix-1&quot;&gt;fix/1&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">배열 크기를 조정할 수 있습니다. ( &lt;code&gt;&lt;a href=&quot;#fix-1&quot;&gt;fix/1&lt;/a&gt;&lt;/code&gt; 의 효과를 되돌 립니다.)</target>
        </trans-unit>
        <trans-unit id="ab845853493a2c837853fd6b3e8f0aaa392fd64f" translate="yes" xml:space="preserve">
          <source>Makes the breakpoint at &lt;code&gt;Line&lt;/code&gt; in &lt;code&gt;Module&lt;/code&gt; active.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; &lt;code&gt;Line&lt;/code&gt; 에서 중단 점을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="66efe312d73a33922588677a593f505e5441c8f3" translate="yes" xml:space="preserve">
          <source>Makes the breakpoint at &lt;code&gt;Line&lt;/code&gt; in &lt;code&gt;Module&lt;/code&gt; inactive.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; &lt;code&gt;Line&lt;/code&gt; 에서 중단 점을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="4197e2c90774db9c9ce91b8b094791dfa882c29c" translate="yes" xml:space="preserve">
          <source>Makes the calling process become a &lt;code&gt;gen_statem&lt;/code&gt;. Does not return, instead the calling process enters the &lt;code&gt;gen_statem&lt;/code&gt; receive loop and becomes a &lt;code&gt;gen_statem&lt;/code&gt; server. The process &lt;strong&gt;must&lt;/strong&gt; have been started using one of the start functions in &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt;. The user is responsible for any initialization of the process, including registering a name for it.</source>
          <target state="translated">호출 프로세스가 &lt;code&gt;gen_statem&lt;/code&gt; 이되도록합니다 . 리턴하지 않고 호출 프로세스는 &lt;code&gt;gen_statem&lt;/code&gt; 수신 루프로 &lt;code&gt;gen_statem&lt;/code&gt; 서버가됩니다. 프로세스 &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; 의 시작 함수 중 하나를 사용하여 시작 &lt;strong&gt;해야합니다&lt;/strong&gt; . 사용자는 프로세스의 이름 등록을 포함하여 프로세스의 초기화에 대한 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7816dd7bfd9f71c9801ecdf559eb8559d1fd39dd" translate="yes" xml:space="preserve">
          <source>Makes the current code for &lt;code&gt;Module&lt;/code&gt; become old code and deletes all references for this module from the export table. Returns &lt;code&gt;undefined&lt;/code&gt; if the module does not exist, otherwise &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 의 현재 코드를 오래된 코드로 만들고 내보내기 모듈에서이 모듈에 대한 모든 참조를 삭제합니다. 모듈이 존재하지 않으면 &lt;code&gt;undefined&lt;/code&gt; 를 반환 하고, 그렇지 않으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="2ffc4bee79fb8820e1fdd4f31e40972ffd12cfcd" translate="yes" xml:space="preserve">
          <source>Makes the current version of &lt;code&gt;Mod&lt;/code&gt; old. &lt;code&gt;PrePurge&lt;/code&gt; is ignored. For a description of &lt;code&gt;PostPurge&lt;/code&gt;, see the high-level instruction &lt;code&gt;update&lt;/code&gt; earlier.</source>
          <target state="translated">&lt;code&gt;Mod&lt;/code&gt; 의 현재 버전을 이전 버전으로 만듭니다 . &lt;code&gt;PrePurge&lt;/code&gt; 는 무시됩니다. &lt;code&gt;PostPurge&lt;/code&gt; 에 대한 설명은 앞서 고급 명령 &lt;code&gt;update&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="75ccf5b40e3c580610c11910676d267ac96338b9" translate="yes" xml:space="preserve">
          <source>Makes the emulator print its version number.</source>
          <target state="translated">에뮬레이터의 버전 번호를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="03fcc3406838240ad7e71ecfcf6e7cb062a03c52" translate="yes" xml:space="preserve">
          <source>Makes the emulator print its version number. The same as &lt;code&gt;erl +V&lt;/code&gt;.</source>
          <target state="translated">에뮬레이터의 버전 번호를 인쇄합니다. &lt;code&gt;erl +V&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="0c6eda41af82625c188e23faff139b871d0dc271" translate="yes" xml:space="preserve">
          <source>Makes the file perform automatic translation of characters to and from a specific (Unicode) encoding. Notice that the data supplied to &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; or returned by &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; still is byte-oriented; this option denotes only how data is stored in the disk file.</source>
          <target state="translated">파일이 특정 (유니 코드) 인코딩과의 문자 자동 변환을 수행하도록합니다. &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; 에 제공 되거나 &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; 에 의해 리턴 된 데이터 는 바이트 지향입니다. 이 옵션은 디스크 파일에 데이터가 저장되는 방법 만 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ce1b5535c27729e37b24da5577a1e2edda190797" translate="yes" xml:space="preserve">
          <source>Makes the first process created by a traced process inherit its trace flags, excluding flag &lt;code&gt;set_on_first_spawn&lt;/code&gt;.</source>
          <target state="translated">추적 된 프로세스로 작성된 첫 번째 프로세스가 플래그 &lt;code&gt;set_on_first_spawn&lt;/code&gt; 을 제외한 추적 플래그를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="51a7e91b712508eac0b349f8e399224c503bf1a3" translate="yes" xml:space="preserve">
          <source>Makes the first process linked to by a traced process inherit its trace flags, excluding flag &lt;code&gt;set_on_first_link&lt;/code&gt;.</source>
          <target state="translated">추적 된 프로세스에 의해 링크 된 첫 번째 프로세스가 플래그 &lt;code&gt;set_on_first_link&lt;/code&gt; 를 제외하고 추적 플래그를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="699e692edb812c99776e6de21b71da2e27456acb" translate="yes" xml:space="preserve">
          <source>Makes the function &lt;code&gt;F/A&lt;/code&gt; no longer being auto-imported from the &lt;code&gt;erlang&lt;/code&gt; module, which resolves BIF name clashes. This option must be used to resolve name clashes with BIFs auto-imported before R14A, if it is needed to call the local function with the same name as an auto-imported BIF without module prefix.</source>
          <target state="translated">&lt;code&gt;erlang&lt;/code&gt; 모듈 에서 &lt;code&gt;F/A&lt;/code&gt; 기능을 더 이상 자동으로 가져 오지 않게하여 BIF 이름 충돌을 해결합니다. 모듈 접두어없이 자동 가져온 BIF와 동일한 이름의 로컬 함수를 호출해야하는 경우이 옵션을 사용하여 R14A 이전에 자동으로 가져온 BIF와 이름 충돌을 해결해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ad0c7129eb3658b1728b9b552dafdedadbc94c1" translate="yes" xml:space="preserve">
          <source>Makes the process &lt;code&gt;Pid&lt;/code&gt; leave the group &lt;code&gt;Name&lt;/code&gt;. If the process is not a member of the group, &lt;code&gt;ok&lt;/code&gt; is returned.</source>
          <target state="translated">프로세스 &lt;code&gt;Pid&lt;/code&gt; 가 그룹 &lt;code&gt;Name&lt;/code&gt; 을 떠나도록합니다 . 프로세스가 그룹의 구성원이 아닌 경우 &lt;code&gt;ok&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="bd055dbda48a993a104503584a8249f43561a9d2" translate="yes" xml:space="preserve">
          <source>Makes the process &lt;code&gt;PidOrPids&lt;/code&gt; leave the group &lt;code&gt;Name&lt;/code&gt;. If the process is not a member of the group, &lt;code&gt;not_joined&lt;/code&gt; is returned.</source>
          <target state="translated">프로세스 &lt;code&gt;PidOrPids&lt;/code&gt; 가 &lt;code&gt;Name&lt;/code&gt; 그룹을 떠나도록합니다 . 프로세스가 그룹의 구성원이 아닌 경우 &lt;code&gt;not_joined&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="45ad2871084bc4b367921bd684d396b4d847881d" translate="yes" xml:space="preserve">
          <source>Makes the specified release version &lt;code&gt;Vsn&lt;/code&gt; permanent.</source>
          <target state="translated">지정된 릴리스 버전 &lt;code&gt;Vsn&lt;/code&gt; 을 영구적으로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="2f4cd63c2b38297a9b1944489ca49b98d5502133" translate="yes" xml:space="preserve">
          <source>Makes the transaction silently return the tuple &lt;code&gt;{aborted, Reason}&lt;/code&gt;. Termination of a Mnesia transaction means that an exception is thrown to an enclosing &lt;code&gt;catch&lt;/code&gt;. Thus, the expression &lt;code&gt;catch mnesia:abort(x)&lt;/code&gt; does not terminate the transaction.</source>
          <target state="translated">트랜잭션이 자동으로 튜플 &lt;code&gt;{aborted, Reason}&lt;/code&gt; 리턴하도록합니다 . Mnesia 트랜잭션이 종료되면 예외를 둘러싼 &lt;code&gt;catch&lt;/code&gt; 던집니다 . 따라서 &lt;code&gt;catch mnesia:abort(x)&lt;/code&gt; 표현식 은 트랜잭션을 종료하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a92284d3fd76d4749295a03455474b61c19acbee" translate="yes" xml:space="preserve">
          <source>Making Hardware Watchdog Available</source>
          <target state="translated">하드웨어 워치 독을 사용 가능하게 만들기</target>
        </trans-unit>
        <trans-unit id="c3c361414f40468ac17c2fe68754d480ca1bcf62" translate="yes" xml:space="preserve">
          <source>Making a hardware watchdog available</source>
          <target state="translated">하드웨어 워치 독 사용 가능</target>
        </trans-unit>
        <trans-unit id="a6b950fad26bf1993d43209bd38ff1959147aa83" translate="yes" xml:space="preserve">
          <source>Making calls from a &lt;code&gt;high&lt;/code&gt; priority process into code that you has no control over can cause the &lt;code&gt;high&lt;/code&gt; priority process to wait for a process with lower priority. That is, effectively decreasing the priority of the &lt;code&gt;high&lt;/code&gt; priority process during the call. Even if this is not the case with one version of the code that you have no control over, it can be the case in a future version of it. This can, for example, occur if a &lt;code&gt;high&lt;/code&gt; priority process triggers code loading, as the code server runs on priority &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">우선 순위 가 &lt;code&gt;high&lt;/code&gt; 프로세스 에서 제어 할 수없는 코드로 호출 하면 우선 순위 가 &lt;code&gt;high&lt;/code&gt; 프로세스가 우선 순위가 낮은 프로세스를 기다릴 수 있습니다 . 즉 , 통화 중 우선 순위 가 &lt;code&gt;high&lt;/code&gt; 프로세스 의 우선 순위를 효과적으로 낮추는 것 입니다. 제어 할 수없는 한 버전의 코드에서는 그렇지 않은 경우에도 다음 버전에서는 가능할 수 있습니다. 예를 들어, 코드 서버가 우선 순위 &lt;code&gt;normal&lt;/code&gt; 로 실행될 때 &lt;code&gt;high&lt;/code&gt; 우선 순위 프로세스가 코드로드를 트리거 하는 경우 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31c6d1769fe27f5b364867a2ba03a8a0ce740773" translate="yes" xml:space="preserve">
          <source>Making requests without checking that the return value indicates success can be OK if the test case fails later, but it is never acceptable just to print an error message (into the log file) and return successfully. Such test cases do harm, as they create a false sense of security when overviewing the test results.</source>
          <target state="translated">테스트 케이스가 나중에 실패하면 리턴 값이 성공을 나타내는 지 확인하지 않고 요청하는 것이 좋지만, 오류 메시지를 로그 파일에 인쇄하여 성공적으로 리턴하는 것은 결코 허용되지 않습니다. 이러한 테스트 사례는 테스트 결과를 개괄 할 때 잘못된 보안 감각을 생성하므로 피해를줍니다.</target>
        </trans-unit>
        <trans-unit id="2d4f453eee7e2dd34a8e386a2b75375fa105539c" translate="yes" xml:space="preserve">
          <source>Making several calls to &lt;code&gt;monitor/2&lt;/code&gt; for the same &lt;code&gt;Item&lt;/code&gt; and/or &lt;code&gt;Type&lt;/code&gt; is not an error; it results in as many independent monitoring instances.</source>
          <target state="translated">동일한 &lt;code&gt;Item&lt;/code&gt; 및 / 또는 &lt;code&gt;Type&lt;/code&gt; 대해 &lt;code&gt;monitor/2&lt;/code&gt; 를 여러 번 호출하는 것은 오류가 아닙니다. 독립적 인 모니터링 인스턴스가 많이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="466c358751442005c7e7d386e4d7e639cbf1ac39" translate="yes" xml:space="preserve">
          <source>Making several calls to &lt;code&gt;monitor_node(Node, true)&lt;/code&gt; for the same &lt;code&gt;Node&lt;/code&gt; is not an error; it results in as many independent monitoring instances.</source>
          <target state="translated">동일한 &lt;code&gt;Node&lt;/code&gt; 대해 &lt;code&gt;monitor_node(Node, true)&lt;/code&gt; 를 여러 번 호출 해도 오류가 아닙니다. 독립적 인 모니터링 인스턴스가 많이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c730df3afaaac142f305e8f798eca241f12abf9f" translate="yes" xml:space="preserve">
          <source>Malayalam</source>
          <target state="translated">Malayalam</target>
        </trans-unit>
        <trans-unit id="8b70bb3a4d458cf297ab7b3a3b07b63b5ca07de9" translate="yes" xml:space="preserve">
          <source>Man</source>
          <target state="translated">Man</target>
        </trans-unit>
        <trans-unit id="eef68d8ca2c02e4bd3d5725888ca18ccdc7ca252" translate="yes" xml:space="preserve">
          <source>Manage a &lt;code&gt;Trace Pattern&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Trace Pattern&lt;/code&gt; 관리</target>
        </trans-unit>
        <trans-unit id="eca3bc872fab76a0e1f06e59d94263eaf1ea2a3a" translate="yes" xml:space="preserve">
          <source>Managed threads frequently need to update their thread progress by calling the following functions:</source>
          <target state="translated">관리되는 스레드는 다음 함수를 호출하여 스레드 진행률을 자주 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="94ed4ca267e8c86206518dfa468e6a4dccf31403" translate="yes" xml:space="preserve">
          <source>Management of Fragmented Tables</source>
          <target state="translated">조각난 테이블 관리</target>
        </trans-unit>
        <trans-unit id="b9ba49c22120fc0a45e8578b1bb98cbe3f8dd731" translate="yes" xml:space="preserve">
          <source>Management of processes internally in the runtime system suffered from these problems. When changing state on a process, for example from &lt;code&gt;waiting&lt;/code&gt; to &lt;code&gt;runnable&lt;/code&gt;, a lock on the process needed to be locked. When inserting a process into a run queue also a lock protecting the run queue had to be locked. When migrating a process from one run queue to another run queue, locks on both run queues and on the process had to be locked.</source>
          <target state="translated">런타임 시스템에서 내부적으로 프로세스를 관리하는 데 이러한 문제가 발생했습니다. 예를 들어 &lt;code&gt;waiting&lt;/code&gt; 에서 &lt;code&gt;runnable&lt;/code&gt; 으로 프로세스의 상태를 변경할 때 프로세스에 대한 잠금을 잠 가야했습니다. 프로세스를 실행 큐에 삽입 할 때 실행 큐를 보호하는 잠금도 잠 가야했습니다. 한 실행 큐에서 다른 실행 큐로 프로세스를 마이그레이션 할 때 실행 큐와 프로세스에 대한 잠금을 모두 잠 가야했습니다.</target>
        </trans-unit>
        <trans-unit id="ff5123b141ff090ff835a7f30332c3740b2707e5" translate="yes" xml:space="preserve">
          <source>Manager configuration:</source>
          <target state="translated">관리자 구성 :</target>
        </trans-unit>
        <trans-unit id="65a4a223a80dcdb4faa701bab0904a7145c7139e" translate="yes" xml:space="preserve">
          <source>Manager specific config options and types:</source>
          <target state="translated">관리자 별 구성 옵션 및 유형 :</target>
        </trans-unit>
        <trans-unit id="63617cfe427854e42387ca5fb2dd42a8d02042c4" translate="yes" xml:space="preserve">
          <source>Mandaic</source>
          <target state="translated">Mandaic</target>
        </trans-unit>
        <trans-unit id="4c2ea2d10dc0ede0423eff4ee1aac7300cd7cc28" translate="yes" xml:space="preserve">
          <source>Mandatory</source>
          <target state="translated">Mandatory</target>
        </trans-unit>
        <trans-unit id="55779720bd078b43fecc03c38a4dee19d2f0260c" translate="yes" xml:space="preserve">
          <source>Mandatory RAM. The schema resides in RAM only. At startup, a tiny new schema is generated. This default schema contains only the definition of the schema table and resides on the local node only. Since no other nodes are found in the default schema, configuration parameter &lt;code&gt;extra_db_nodes&lt;/code&gt; must be used to let the node share its table definitions with other nodes. (Parameter &lt;code&gt;extra_db_nodes&lt;/code&gt; can also be used on disc-full nodes.)</source>
          <target state="translated">필수 RAM. 스키마는 RAM에만 있습니다. 시작할 때 작은 새 스키마가 생성됩니다. 이 기본 스키마는 스키마 테이블의 정의 만 포함하며 로컬 노드에만 상주합니다. 기본 스키마에 다른 노드가 없으므로 구성 매개 변수 &lt;code&gt;extra_db_nodes&lt;/code&gt; 를 사용하여 노드가 테이블 정의를 다른 노드와 공유 할 수 있도록해야합니다. 디스크 &lt;code&gt;extra_db_nodes&lt;/code&gt; 노드에서 extra_db_nodes 매개 변수를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef7f5fd2af32ce149c0ca960148e8bf3bd0f1d1a" translate="yes" xml:space="preserve">
          <source>Mandatory RAM. The schema resides in RAM only. At startup, a tiny new schema is generated. This default schema only contains the definition of the schema table and only resides on the local node. Since no other nodes are found in the default schema, configuration parameter &lt;code&gt;extra_db_nodes&lt;/code&gt; must be used to let the node share its table definitions with other nodes.</source>
          <target state="translated">필수 RAM. 스키마는 RAM에만 있습니다. 시작할 때 작은 새 스키마가 생성됩니다. 이 기본 스키마는 스키마 테이블의 정의 만 포함하며 로컬 노드에만 상주합니다. 기본 스키마에 다른 노드가 없으므로 구성 매개 변수 &lt;code&gt;extra_db_nodes&lt;/code&gt; 를 사용하여 노드가 테이블 정의를 다른 노드와 공유 할 수 있도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd245892c4cf7481ff0b76736f06f016f9538140" translate="yes" xml:space="preserve">
          <source>Mandatory disc. The schema is assumed to be located in the &lt;code&gt;Mnesia&lt;/code&gt; directory. If the schema cannot be found, &lt;code&gt;Mnesia&lt;/code&gt; refuses to start.</source>
          <target state="translated">필수 디스크. 스키마는 &lt;code&gt;Mnesia&lt;/code&gt; 디렉토리 에 있다고 가정합니다 . 스키마를 찾을 수 없으면 &lt;code&gt;Mnesia&lt;/code&gt; 는 시작을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="056c789bb6261a61e562f98c5294a028b2c27e2a" translate="yes" xml:space="preserve">
          <source>Mandatory disc. The schema is assumed to be located in the Mnesia directory. If the schema cannot be found, Mnesia refuses to start. This is the old behavior.</source>
          <target state="translated">필수 디스크. 스키마는 Mnesia 디렉토리에 있다고 가정합니다. 스키마를 찾을 수 없으면 Mnesia는 시작을 거부합니다. 이것은 오래된 행동입니다.</target>
        </trans-unit>
        <trans-unit id="9bf3e3f7107080f2dd0decda36be42d7dcd887d3" translate="yes" xml:space="preserve">
          <source>Mandatory if &lt;code&gt;-reldir&lt;/code&gt; is not specified and no &lt;code&gt;RELDIR&lt;/code&gt; exists in the environment. This specifies the Erlang installation root directory (under which the &lt;code&gt;lib&lt;/code&gt;, &lt;code&gt;releases&lt;/code&gt;, and &lt;code&gt;erts-&amp;lt;Version&amp;gt;&lt;/code&gt; directories are located). If only &lt;code&gt;-reldir&lt;/code&gt; (or environment variable &lt;code&gt;RELDIR&lt;/code&gt;) is specified, the Erlang root is assumed to be the directory exactly one level above the release directory.</source>
          <target state="translated">필수 경우 &lt;code&gt;-reldir&lt;/code&gt; 가 지정되지 않고 &lt;code&gt;RELDIR&lt;/code&gt; 이 환경에 존재하지 않습니다. 이것은 Erlang 설치 루트 디렉토리 ( &lt;code&gt;lib&lt;/code&gt; , &lt;code&gt;releases&lt;/code&gt; 및 &lt;code&gt;erts-&amp;lt;Version&amp;gt;&lt;/code&gt; 디렉토리가있는 디렉토리)를 지정합니다. 경우에만 &lt;code&gt;-reldir&lt;/code&gt; (또는 환경 변수 &lt;code&gt;RELDIR&lt;/code&gt; 가 ) 지정, 얼랭 루트는 디렉토리 릴리즈 디렉토리 위 정확히 하나 개의 레벨로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="27228686f00efd9069abdd5d3e934b51d59f64a9" translate="yes" xml:space="preserve">
          <source>Mandatory if environment variable &lt;code&gt;RELDIR&lt;/code&gt; is not specified and no &lt;code&gt;-rootdir&lt;/code&gt; option is specified. Tells &lt;code&gt;start_erl&lt;/code&gt; where the root of the release tree is located in the file system (typically &amp;lt;Erlang root&amp;gt;\\releases). The &lt;code&gt;start_erl.data&lt;/code&gt; file is expected to be located in this directory (unless otherwise specified). If only option &lt;code&gt;-rootdir&lt;/code&gt; is specified, the directory is assumed to be &amp;lt;Erlang root&amp;gt;\\releases.</source>
          <target state="translated">환경 변수 &lt;code&gt;RELDIR&lt;/code&gt; 이 지정되지 않고 &lt;code&gt;-rootdir&lt;/code&gt; 옵션이 지정 되지 않은 경우 필수 입니다. 파일 시스템에서 릴리스 트리의 루트가있는 위치 (일반적으로 &amp;lt;Erlang root&amp;gt; \\ releases)를 &lt;code&gt;start_erl&lt;/code&gt; 에 알려줍니다 . &lt;code&gt;start_erl.data&lt;/code&gt; 파일 (달리 명시되지 않는 한)이 디렉토리에 위치 할 것으로 예상된다. &lt;code&gt;-rootdir&lt;/code&gt; 옵션 만 지정하면 디렉토리는 &amp;lt;Erlang root&amp;gt; \\ releases로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d51f3b74b92dcfdb5b928a635f84a5f51200457c" translate="yes" xml:space="preserve">
          <source>Mandatory. Delimits &lt;code&gt;start_erl&lt;/code&gt; options from normal Erlang options. Everything on the command line &lt;strong&gt;before&lt;/strong&gt;&lt;code&gt;++&lt;/code&gt; is interpreted as options to be sent to the &lt;code&gt;erl&lt;/code&gt; program. Everything &lt;strong&gt;after&lt;/strong&gt;&lt;code&gt;++&lt;/code&gt; is interpreted as options to &lt;code&gt;start_erl&lt;/code&gt; itself.</source>
          <target state="translated">필수. 구분합니다은 &lt;code&gt;start_erl&lt;/code&gt; 정상 얼랑 옵션에서 옵션을. &lt;code&gt;++&lt;/code&gt; &lt;strong&gt;이전&lt;/strong&gt; 의 명령 행에있는 모든 것은 &lt;code&gt;erl&lt;/code&gt; 프로그램에 전송되는 옵션으로 해석됩니다 . &lt;code&gt;++&lt;/code&gt; &lt;strong&gt;이후의&lt;/strong&gt; 모든 것은 &lt;code&gt;start_erl&lt;/code&gt; 자체에 대한 옵션으로 해석 됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fc48591fe7588ae910f82a8e32e5898f8b677543" translate="yes" xml:space="preserve">
          <source>Mandatory: one or more</source>
          <target state="translated">필수 : 하나 이상</target>
        </trans-unit>
        <trans-unit id="40331ec2ec252f48c8769280f8a9d0addf85621c" translate="yes" xml:space="preserve">
          <source>Manichaean</source>
          <target state="translated">Manichaean</target>
        </trans-unit>
        <trans-unit id="1a83f62a1c9d2ea7c7b76528168eeb1027e1c303" translate="yes" xml:space="preserve">
          <source>Manipulate the return of all suite configuration calls and by extension the result of the test themselves.</source>
          <target state="translated">모든 스위트 구성 호출의 리턴 및 확장하여 테스트 결과를 조작하십시오.</target>
        </trans-unit>
        <trans-unit id="a70642b028568014a36d3c8b54782719d4573d07" translate="yes" xml:space="preserve">
          <source>Manipulate the return of all suite configuration calls, and in extension, the result of the tests themselves.</source>
          <target state="translated">모든 스위트 구성 호출의 리턴 및 확장 된 테스트 결과를 조작하십시오.</target>
        </trans-unit>
        <trans-unit id="28533b136858ffce59b77b52f8bc0d5d5c92201b" translate="yes" xml:space="preserve">
          <source>Manipulate the runtime configuration before each suite configuration call.</source>
          <target state="translated">각 스위트 구성 호출 전에 런타임 구성을 조작하십시오.</target>
        </trans-unit>
        <trans-unit id="a777446b5191e48dad7cad24722806c79d3f271e" translate="yes" xml:space="preserve">
          <source>Manipulation of data represented as Erlang data types</source>
          <target state="translated">Erlang 데이터 유형으로 표시되는 데이터 조작</target>
        </trans-unit>
        <trans-unit id="8d09db94e4c55d4786f4570130a4d22ac51744f7" translate="yes" xml:space="preserve">
          <source>Manner in which incoming answer messages containing decode errors are handled.</source>
          <target state="translated">디코드 오류가 포함 된 수신 응답 메시지가 처리되는 방식.</target>
        </trans-unit>
        <trans-unit id="6284d04575c3819f39fde9f65fd471b9435e0ad1" translate="yes" xml:space="preserve">
          <source>Manner in which incoming requests are handled when an error other than 3007 (DIAMETER_APPLICATION_UNSUPPORTED, which cannot be associated with an application callback module), is detected.</source>
          <target state="translated">3007 이외의 오류 (DIAMETER_APPLICATION_UNSUPPORTED, 응용 프로그램 콜백 모듈과 연결될 수 없음)가 감지 될 때 들어오는 요청이 처리되는 방식.</target>
        </trans-unit>
        <trans-unit id="33b69b29ea474749d0da92aa4fbd4214e3920f4e" translate="yes" xml:space="preserve">
          <source>Manual handling of session tickets is also supported. In manual mode, it is the responsibility of the client to handle received session tickets.</source>
          <target state="translated">세션 티켓의 수동 처리도 지원됩니다. 수동 모드에서 수신 된 세션 티켓을 처리하는 것은 클라이언트의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="5351cf3c5581dd875efa06c896ad751d99613d56" translate="yes" xml:space="preserve">
          <source>Manually performs a mib server cache gc. This can be done regardless of the value of the &lt;code&gt;autogc&lt;/code&gt; option. The &lt;code&gt;NumElementsGCed&lt;/code&gt; value indicates how many elements where actually removed from the cache.</source>
          <target state="translated">mib 서버 캐시 gc를 수동으로 수행합니다. &lt;code&gt;autogc&lt;/code&gt; 옵션 의 값에 관계없이 수행 할 수 있습니다 . &lt;code&gt;NumElementsGCed&lt;/code&gt; 의 값은 실제로 캐시에서 제거 얼마나 많은 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c5c7ebf32bd378c4ba16c49e6124169115f258a7" translate="yes" xml:space="preserve">
          <source>Many assertions (of any sort) can occur in succession. For example, the following matches &quot;foo&quot; preceded by three digits that are not &quot;999&quot;:</source>
          <target state="translated">많은 종류의 주장이 연속적으로 발생할 수 있습니다. 예를 들어, 다음은 &quot;foo&quot;앞에 &quot;999&quot;가 아닌 세 자리 숫자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7f887661a9b51d0d5237dac908440eb7b836be70" translate="yes" xml:space="preserve">
          <source>Many driver API functions have changed argument type and/or return value to &lt;code&gt;ErlDrvSizeT&lt;/code&gt; from mostly &lt;code&gt;int&lt;/code&gt;. Automatic type-casting probably makes these changes necessary only for a driver that encounters sizes &amp;gt; 32 bits.</source>
          <target state="translated">많은 드라이버 API 함수가 인수 유형 및 / 또는 반환 값을 대부분 &lt;code&gt;int&lt;/code&gt; 에서 &lt;code&gt;ErlDrvSizeT&lt;/code&gt; 로 변경했습니다 . 자동 유형 캐스팅은 크기가 32 비트보다 큰 드라이버에만 이러한 변경이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae795bffdcb1fe7cf5ecc8403f7d637849040545" translate="yes" xml:space="preserve">
          <source>Many have been in contact with the command 'ssh' on a Linux machine (or similar) to remotly log in on another machine. One types</source>
          <target state="translated">많은 사람들이 다른 컴퓨터에 원격으로 로그인하기 위해 Linux 컴퓨터 (또는 유사한 컴퓨터)에서 'ssh'명령을 사용했습니다. 한 가지 유형</target>
        </trans-unit>
        <trans-unit id="56029af12913d9bc7ea74d4914ee32e80f6707df" translate="yes" xml:space="preserve">
          <source>Many list comprehension expressions can be evaluated by the &lt;code&gt;qlc&lt;/code&gt; module. Exceptions are expressions, such that variables introduced in patterns (or filters) are used in some generator later in the list comprehension. As an example, consider an implementation of &lt;code&gt;lists:append(L)&lt;/code&gt;: &lt;code&gt;[X ||Y &amp;lt;- L, X &amp;lt;- Y]&lt;/code&gt;. &lt;code&gt;Y&lt;/code&gt; is introduced in the first generator and used in the second. The ordinary list comprehension is normally to be preferred when there is a choice as to which to use. One difference is that &lt;code&gt;&lt;a href=&quot;#eval-1&quot;&gt;eval/1,2&lt;/a&gt;&lt;/code&gt; collects answers in a list that is finally reversed, while list comprehensions collect answers on the stack that is finally unwound.</source>
          <target state="translated">&lt;code&gt;qlc&lt;/code&gt; 모듈 은 많은 목록 이해 표현식을 평가할 수 있습니다 . 예외는 패턴 (또는 필터)에 도입 된 변수가 나중에 목록 이해의 일부 생성기에서 사용되도록하는 표현식입니다. 예를 들어, &lt;code&gt;lists:append(L)&lt;/code&gt; : &lt;code&gt;[X ||Y &amp;lt;- L, X &amp;lt;- Y]&lt;/code&gt; 구현을 고려하십시오 . &lt;code&gt;Y&lt;/code&gt; 는 첫 번째 발전기에 도입되어 두 번째 발전기에 사용됩니다. 일반적인 목록 이해는 일반적으로 사용할 선택이있을 때 선호됩니다. 한 가지 차이점은 &lt;code&gt;&lt;a href=&quot;#eval-1&quot;&gt;eval/1,2&lt;/a&gt;&lt;/code&gt; 는 최종적으로 뒤집힌 목록에서 답변을 수집하고 목록 이해력은 최종적으로 풀린 스택에서 답변을 수집한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4a3eae152029d738a0ebe7e23d689a8ac8f03946" translate="yes" xml:space="preserve">
          <source>Many nice things can be done with the iterator functions but take some caution about performance and memory use for large tables.</source>
          <target state="translated">반복자 함수를 사용하여 많은 유용한 작업을 수행 할 수 있지만 큰 테이블의 성능 및 메모리 사용에주의를 기울이십시오.</target>
        </trans-unit>
        <trans-unit id="9fdf7f9f32446c75f533a26900329aea292fc48d" translate="yes" xml:space="preserve">
          <source>Many of the operators can only be applied to arguments of a certain type. For example, arithmetic operators can only be applied to numbers. An argument of the wrong type causes a &lt;code&gt;badarg&lt;/code&gt; runtime error.</source>
          <target state="translated">많은 연산자는 특정 유형의 인수에만 적용될 수 있습니다. 예를 들어, 산술 연산자는 숫자에만 적용 할 수 있습니다. 잘못된 유형의 인수는 원인 &lt;code&gt;badarg&lt;/code&gt; 런타임 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="f2f1df17f07587c5055c0ce8c9221879d8708726" translate="yes" xml:space="preserve">
          <source>Many of the output functions have a &quot;header buffer&quot;, with &lt;code&gt;hbuf&lt;/code&gt; and &lt;code&gt;hlen&lt;/code&gt; parameters. This buffer is sent as a list before the binary (or list, depending on port mode) that is sent. This is convenient when matching on messages received from the port. (Although in the latest Erlang versions there is the binary syntax, which enables you to match on the beginning of a binary.)</source>
          <target state="translated">많은 출력 함수에는 &lt;code&gt;hbuf&lt;/code&gt; 및 &lt;code&gt;hlen&lt;/code&gt; 매개 변수 와 함께 &quot;헤더 버퍼&quot;가 있습니다. 이 버퍼는 전송 된 바이너리 (또는 포트 모드에 따라 목록) 이전에 목록으로 전송됩니다. 포트에서받은 메시지를 일치시킬 때 편리합니다. (최신 Erlang 버전에는 바이너리 구문이있어 바이너리의 시작 부분과 일치시킬 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="2ff407509d30c8b3a82bd0672d36e2f5b3903c78" translate="yes" xml:space="preserve">
          <source>Many operations communicating with a process executing a dirty NIF can, however, complete while it executes the dirty NIF. For example, retrieving information about it through &lt;code&gt;&lt;a href=&quot;erlang#process_info-1&quot;&gt; process_info&lt;/a&gt;&lt;/code&gt;, setting its group leader, register/unregister its name, and so on.</source>
          <target state="translated">그러나 더티 NIF를 실행하는 프로세스와 통신하는 많은 작업은 더티 NIF를 실행하는 동안 완료 될 수 있습니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;erlang#process_info-1&quot;&gt; process_info&lt;/a&gt;&lt;/code&gt; 를 통해 정보 검색 , 그룹 리더 설정, 이름 등록 / 등록 해제 등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="21b179b8985ad61d572fc99ea80a2e913e1d0bdd" translate="yes" xml:space="preserve">
          <source>Many operations communicating with a process executing a dirty NIF can, however, complete while it executes the dirty NIF. For example, retrieving information about it through &lt;code&gt;erlang:process_info&lt;/code&gt;, setting its group leader, register/unregister its name, and so on.</source>
          <target state="translated">그러나 더티 NIF를 실행하는 프로세스와 통신하는 많은 작업은 더티 NIF를 실행하는 동안 완료 될 수 있습니다. 예를 들어, &lt;code&gt;erlang:process_info&lt;/code&gt; 를 통해 정보를 검색 하고 그룹 리더를 설정하고 이름을 등록 / 등록 취소하는 등의 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="f86703eb2414253099183ba096ef8f59d855dec4" translate="yes" xml:space="preserve">
          <source>Many restrictions apply to the fun that is translated into a match specification. To put it simple: you cannot use anything in the fun that you cannot use in a match specification. This means that, among others, the following restrictions apply to the fun itself:</source>
          <target state="translated">일치 사양으로 변환되는 재미에는 많은 제한이 적용됩니다. 간단히 말하면 : 일치 사양에서 사용할 수없는 재미로는 아무것도 사용할 수 없습니다. 이는 특히 재미 자체에 다음과 같은 제한 사항이 적용됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b3277af475a535b5e15ac96f9ce422da3543b8bc" translate="yes" xml:space="preserve">
          <source>Many small test cases tend to result in extra, and possibly duplicated code, as well as slow test execution because of large overhead for initializations and cleanups. Avoid duplicated code, for example, by using common help functions. Otherwise, the resulting suite becomes difficult to read and understand, and expensive to maintain.</source>
          <target state="translated">많은 작은 테스트 사례는 초기화 및 정리에 대한 오버 헤드가 커서 테스트 실행 속도가 느릴뿐만 아니라 추가 코드 및 중복 코드를 생성하는 경향이 있습니다. 예를 들어 일반적인 도움말 기능을 사용하여 중복 코드를 피하십시오. 그렇지 않으면 결과 제품군은 읽고 이해하기 어렵고 유지 관리 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="f4757731a17b024e345545fcb6d59364979c23d4" translate="yes" xml:space="preserve">
          <source>Many telecommunications applications have unique requirements on lookup times for certain types of records. If the &lt;code&gt;Company&lt;/code&gt; database had been a part of a telecommunications system, it could be to minimize the lookup time of an employee &lt;strong&gt;together&lt;/strong&gt; with a list of the projects the employee is working on. If this is the case, a drastically different data model without direct relationships can be chosen. You would then have only the records themselves, and different records could contain either direct references to other records, or contain other records that are not part of the &lt;code&gt;Mnesia&lt;/code&gt; schema.</source>
          <target state="translated">많은 통신 응용 프로그램에는 특정 유형의 레코드에 대한 조회 시간에 대한 고유 한 요구 사항이 있습니다. 경우 &lt;code&gt;Company&lt;/code&gt; 데이터베이스가 통신 시스템의 한 부분이었다, 그것은 직원의 조회 시간을 최소화 할 수 있었다 &lt;strong&gt;함께&lt;/strong&gt; 직원이 작업하는 프로젝트의 목록. 이 경우 직접적인 관계가없는 매우 다른 데이터 모델을 선택할 수 있습니다. 그러면 레코드 자체 만 있고 다른 레코드에 다른 레코드에 대한 직접 참조가 포함되거나 &lt;code&gt;Mnesia&lt;/code&gt; 스키마 에 속하지 않은 다른 레코드가 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68017d6821eb323d2063e3ce0fd2add46797e7ea" translate="yes" xml:space="preserve">
          <source>Many telecommunications applications must be controlled and reconfigured remotely. It is sometimes an advantage to perform this remote control with an open protocol such as the Simple Network Management Protocol (SNMP). The alternatives to this would be the following:</source>
          <target state="translated">많은 통신 응용 프로그램을 원격으로 제어하고 재구성해야합니다. SNMP (Simple Network Management Protocol)와 같은 개방형 프로토콜로이 원격 제어를 수행하는 것이 때로는 유리합니다. 이에 대한 대안은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="76d244eb5695df75281d39dbf3ed66bd8b67982c" translate="yes" xml:space="preserve">
          <source>Many thanks to Sebastiano Vigna for his help with the 58 bit adaption.</source>
          <target state="translated">58 비트 적응에 도움을 주신 Sebastiano Vigna에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="e7b004a583d02bc15f8db5aaa5239ed752c86ac6" translate="yes" xml:space="preserve">
          <source>Map holding the main components of a URI.</source>
          <target state="translated">URI의 주요 컴포넌트를 보유한 맵.</target>
        </trans-unit>
        <trans-unit id="f9636957ea9c74ef69d5b705de848b9cde84373e" translate="yes" xml:space="preserve">
          <source>Mapping of SNMPv2 error message to SNMPv1:</source>
          <target state="translated">SNMPv2 오류 메시지를 SNMPv1에 매핑 :</target>
        </trans-unit>
        <trans-unit id="2eb0d74870184c7f673bb050cdd8b5d41a869ece" translate="yes" xml:space="preserve">
          <source>Mapping the 28-bit integer to an index into the array.</source>
          <target state="translated">28 비트 정수를 인덱스에 배열로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="a84d64ae1d03f9ff9bd84aab36be92ff55171896" translate="yes" xml:space="preserve">
          <source>Mappings between network interface index and names.</source>
          <target state="translated">네트워크 인터페이스 색인과 이름 간의 매핑.</target>
        </trans-unit>
        <trans-unit id="94b57e1a0a21353f0acb8fe2dfd2f7899d2deac1" translate="yes" xml:space="preserve">
          <source>Mappings between network interface names and indexes.</source>
          <target state="translated">네트워크 인터페이스 이름과 인덱스 간의 매핑.</target>
        </trans-unit>
        <trans-unit id="6b8ce83c2e2c5a484157b664057c2b8bdf654df2" translate="yes" xml:space="preserve">
          <source>Maps a function onto the nodes of a tree. This replaces each node in the tree by the result of applying the given function on the original node, bottom-up.</source>
          <target state="translated">함수를 트리의 노드에 매핑합니다. 이것은 원래 노드에 주어진 함수를 상향식으로 적용한 결과로 트리의 각 노드를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="c286942228a25588025573f075da4c09d52b9607" translate="yes" xml:space="preserve">
          <source>Maps are a set of key to value associations. These associations are encapsulated with &quot;#{&quot; and &quot;}&quot;. To create an association from &quot;key&quot; to value 42:</source>
          <target state="translated">지도는 가치 연관의 핵심입니다. 이러한 연결은 &quot;# {&quot;및 &quot;}&quot;로 캡슐화됩니다. &quot;키&quot;에서 값 42 로의 연관을 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="04b5c5dbf8eab96a0231ea5b92737fd2b0a1ce74" translate="yes" xml:space="preserve">
          <source>Maps are allowed in guards as long as all subexpressions are valid guard expressions.</source>
          <target state="translated">모든 하위 표현식이 유효한 가드 표현식 인 한 가드에서 맵이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="363ad38891c14a93a51e759557264fd84b9d27cc" translate="yes" xml:space="preserve">
          <source>Maps are considered to be experimental during Erlang/OTP R17.</source>
          <target state="translated">Erlang / OTP R17에서 맵은 실험적인 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d13027fd4ebe765466d95071c641f5db67b026f6" translate="yes" xml:space="preserve">
          <source>Maps are ordered by size, two maps with the same size are compared by keys in ascending term order and then by values in key order. In maps key order integers types are considered less than floats types.</source>
          <target state="translated">맵은 크기별로 정렬되며 크기가 같은 두 맵은 키를 기준으로 오름차순으로 키를 기준으로 키순으로 값을 비교합니다. 맵에서 키 순서 정수 유형은 부동 유형보다 작은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d3761b3f052ddea8579fdb64072c5ede6d3ff627" translate="yes" xml:space="preserve">
          <source>Maps function F(K, V1) -&amp;gt; V2 to all key-value pairs of tree &lt;code&gt;Tree1&lt;/code&gt;. Returns a new tree &lt;code&gt;Tree2&lt;/code&gt; with the same set of keys as &lt;code&gt;Tree1&lt;/code&gt; and the new set of values &lt;code&gt;V2&lt;/code&gt;.</source>
          <target state="translated">함수 F (K, V1)-&amp;gt; V2를 &lt;code&gt;Tree1&lt;/code&gt; 트리의 모든 키-값 쌍에 매핑 합니다. 새로운 트리를 돌려 &lt;code&gt;Tree2&lt;/code&gt; 은 같은 키의 동일한 세트 &lt;code&gt;Tree1&lt;/code&gt; 과 값의 새로운 &lt;code&gt;V2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04a0ed588e558dfeb24dbb776767b9768927953d" translate="yes" xml:space="preserve">
          <source>Maps in Guards</source>
          <target state="translated">경비원의지도</target>
        </trans-unit>
        <trans-unit id="63d572d3b65816384952bcc7c3b9b3b9faea1088" translate="yes" xml:space="preserve">
          <source>Maps in Patterns</source>
          <target state="translated">패턴의 맵</target>
        </trans-unit>
        <trans-unit id="729cd71fbff021f36308a64f8ae94d9a49e5da1b" translate="yes" xml:space="preserve">
          <source>Maps processing</source>
          <target state="translated">지도 처리</target>
        </trans-unit>
        <trans-unit id="7ea86ddec10f80bb2c7782afe4921fda0718970f" translate="yes" xml:space="preserve">
          <source>Maps processing functions.</source>
          <target state="translated">지도 처리 기능.</target>
        </trans-unit>
        <trans-unit id="6501b098152b10c2d1fd7868786d299194e00b4a" translate="yes" xml:space="preserve">
          <source>Maps the specified function onto each array element, skipping default-valued entries. The elements are visited in order from the lowest index to the highest. If &lt;code&gt;Function&lt;/code&gt; is not a function, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">지정된 함수를 각 배열 요소에 매핑하고 기본값이 지정된 항목을 건너 뜁니다. 요소는 가장 낮은 인덱스에서 가장 높은 순서대로 방문합니다. &lt;code&gt;Function&lt;/code&gt; 이 함수 가 아닌 경우 reason &lt;code&gt;badarg&lt;/code&gt; 로 호출이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="7d1791268d9973c2080f7cdeef13debd8dce8751" translate="yes" xml:space="preserve">
          <source>Maps the specified function onto each array element. The elements are visited in order from the lowest index to the highest. If &lt;code&gt;Function&lt;/code&gt; is not a function, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">지정된 함수를 각 배열 요소에 매핑합니다. 요소는 가장 낮은 인덱스에서 가장 높은 순서대로 방문합니다. &lt;code&gt;Function&lt;/code&gt; 이 함수 가 아닌 경우 reason &lt;code&gt;badarg&lt;/code&gt; 로 호출이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="31e9697d43a1a66f2e45db652019fb9a6216df22" translate="yes" xml:space="preserve">
          <source>Mark</source>
          <target state="translated">Mark</target>
        </trans-unit>
        <trans-unit id="10a075120eb484727a09f2f3701ac80c559eec39" translate="yes" xml:space="preserve">
          <source>Mark the directories/modules you want to analyze for discrepancies and click &lt;strong&gt;Add&lt;/strong&gt;. You can either add the &lt;code&gt;.beam&lt;/code&gt; and &lt;code&gt;.erl&lt;/code&gt; files directly, or add directories that contain these kind of files. Notice that you are only allowed to add the type of files that can be analyzed in the current mode of operation (see below), and that you cannot mix &lt;code&gt;.beam&lt;/code&gt; and &lt;code&gt;.erl&lt;/code&gt; files.</source>
          <target state="translated">불일치에 대해 분석하려는 디렉토리 / 모듈을 표시하고 &lt;strong&gt;추가를&lt;/strong&gt; 클릭 &lt;strong&gt;하십시오&lt;/strong&gt; . 당신이 중 하나를 추가 할 수 있습니다 &lt;code&gt;.beam&lt;/code&gt; 및 &lt;code&gt;.erl&lt;/code&gt; 파일을 직접, 또는 파일의 이러한 종류를 포함하는 디렉토리를 추가합니다. 현재 작동 모드 (아래 참조)에서 분석 할 수있는 파일 유형 만 추가 할 수 있으며 &lt;code&gt;.beam&lt;/code&gt; 및 &lt;code&gt;.erl&lt;/code&gt; 파일을 혼합 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="197dfa50ea4b8649cb35689f0decbb6c374c77b7" translate="yes" xml:space="preserve">
          <source>Marks &lt;code&gt;Dir&lt;/code&gt; as sticky.</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 를 끈적 거리는 것으로 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="7b5406131a661f19f4b14f972097e09771980111" translate="yes" xml:space="preserve">
          <source>Marks a registry object as dirty. This ensures that it is included in the next backup to &lt;code&gt;Mnesia&lt;/code&gt;. Normally this operation is not necessary, as all of the normal registry 'set' functions do this automatically. However, if you have retrieved the value of a string or binary object from the registry and modified the contents, then the change is invisible to the registry and the object is assumed to be unmodified. This function allows you to make such modifications and then let the registry know about them.</source>
          <target state="translated">레지스트리 객체를 더티로 표시합니다. 이를 통해 다음 번 &lt;code&gt;Mnesia&lt;/code&gt; 백업에 포함됩니다 . 모든 일반 레지스트리 'set'기능이 자동으로 수행하므로 일반적으로이 작업은 필요하지 않습니다. 그러나 레지스트리에서 문자열 또는 이진 개체의 값을 검색하고 내용을 수정 한 경우 레지스트리에 변경 사항이 표시되지 않고 개체가 수정되지 않은 것으로 간주됩니다. 이 기능을 사용하면 이러한 수정 작업을 수행 한 다음 레지스트리에 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1709de2e6065059c80b7bb75d222b5ba4f0c8c88" translate="yes" xml:space="preserve">
          <source>Marks that driver instances can handle being called in the &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; callbacks although a driver instance has marked itself as busy (see &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt; erl_driver:set_busy_port&lt;/a&gt;&lt;/code&gt;). As from ERTS 5.7.4 this flag is required for drivers used by the Erlang distribution (the behavior has always been required by drivers used by the distribution).</source>
          <target state="translated">드라이버 인스턴스가 자체를 사용 &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt; erl_driver:set_busy_port&lt;/a&gt;&lt;/code&gt; 표시했지만 드라이버 인스턴스가 &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; 및 / 또는 &lt;code&gt;&lt;a href=&quot;#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; 콜백 에서 호출되는 것을 처리 할 수 ​​있음 을 표시합니다 ( erl_driver : set_busy_port 참조 ). ERTS 5.7.4에서와 같이이 플래그는 Erlang 배포판에서 사용하는 드라이버에 필요합니다 (배포판에서 사용하는 드라이버에서는 항상 동작이 필요했습니다).</target>
        </trans-unit>
        <trans-unit id="bcbfc3c88f06b01ad7c3cccfab1c852094317788" translate="yes" xml:space="preserve">
          <source>Marks that driver instances can handle being called in the &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; callbacks although a driver instance has marked itself as busy (see &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt;erl_driver:set_busy_port&lt;/a&gt;&lt;/code&gt;). As from ERTS 5.7.4 this flag is required for drivers used by the Erlang distribution (the behavior has always been required by drivers used by the distribution).</source>
          <target state="translated">드라이버 인스턴스가 사용 중으로 표시되었지만 드라이버 인스턴스가 &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; 및 / 또는 &lt;code&gt;&lt;a href=&quot;#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; 콜백 에서 호출되는 것을 처리 할 수 ​​있음 을 표시합니다 ( &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt;erl_driver:set_busy_port&lt;/a&gt;&lt;/code&gt; 참조 ). ERTS 5.7.4부터이 플래그는 Erlang 배포에 사용되는 드라이버에 필요합니다 (배포에 사용되는 드라이버에 의해 동작이 항상 필요했습니다).</target>
        </trans-unit>
        <trans-unit id="44a77f06fe20eb0136352abea280e4ae8f164595" translate="yes" xml:space="preserve">
          <source>Marshall T. Rose (1991), &quot;The Simple Book - An Introduction to Internet Management&quot;, Prentice-Hall</source>
          <target state="translated">Marshall T. Rose (1991), &quot;간단한 책-인터넷 관리 소개&quot;, Prentice-Hall</target>
        </trans-unit>
        <trans-unit id="eb16e2eaaa41a17fa7c2ea2240cca72be26d1651" translate="yes" xml:space="preserve">
          <source>Match Context</source>
          <target state="translated">컨텍스트 일치</target>
        </trans-unit>
        <trans-unit id="e292a510978ff43c30aad8eecbcdd9404449eef9" translate="yes" xml:space="preserve">
          <source>Match Operator = in Patterns</source>
          <target state="translated">일치 연산자 = 패턴</target>
        </trans-unit>
        <trans-unit id="ff171d7e2ec66d8d77776b728f30299bf8e3e6c9" translate="yes" xml:space="preserve">
          <source>Match a pattern against a syntax tree (or patterns against syntax trees) returning an environment mapping variable names to subtrees; the environment is always sorted on keys. Note that multiple occurrences of metavariables in the pattern is not allowed, but is not checked.</source>
          <target state="translated">환경 맵핑 변수 이름을 서브 트리에 리턴하는 구문 트리에 대한 패턴 (또는 구문 트리에 대한 패턴)을 일치시킵니다. 환경은 항상 키로 정렬됩니다. 패턴에서 여러 번 발생하는 메타 변수는 허용되지 않지만 확인되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2de4afa174487d24d4a58ea206ea53aeb3c9f62" translate="yes" xml:space="preserve">
          <source>Match against one or more clauses with patterns and optional guards.</source>
          <target state="translated">패턴과 옵션 가드가있는 하나 이상의 절과 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="509635766fe25fda0e8fcb1e73a1a4900a524a90" translate="yes" xml:space="preserve">
          <source>Match all objects in an ETS table with arity &amp;gt; 1 and the first element is 'gandalf', and return element 2:</source>
          <target state="translated">ETS 테이블의 모든 오브젝트를 arity&amp;gt; 1로 일치시키고 첫 번째 요소는 'gandalf'이고 요소 2를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="5cb24c4903ed09ea4659ce737242ec2cae99a47b" translate="yes" xml:space="preserve">
          <source>Match all objects in an ETS table, where the first element is the atom &lt;code&gt;'strider'&lt;/code&gt; and the tuple arity is 3, and return the whole object:</source>
          <target state="translated">첫 번째 요소가 원자 &lt;code&gt;'strider'&lt;/code&gt; 이고 튜플 arity가 3 인 ETS 테이블의 모든 오브젝트를 일치 시키고 전체 오브젝트를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="7edee42de18d23f1dd88981c1e38214f04375e1b" translate="yes" xml:space="preserve">
          <source>Match an argument list of three, where the first and third arguments are equal:</source>
          <target state="translated">첫 번째와 세 번째 인수가 동일한 세 개의 인수 목록을 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="007b6fe417206569cf211bcff5829b2fb375ff62" translate="yes" xml:space="preserve">
          <source>Match an argument list of three, where the second argument is a number &amp;gt; 3:</source>
          <target state="translated">세 번째 인수가 3보다 큰 인수 목록과 일치합니다. 두 번째 인수는 3보다 큰 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="aaa654601a0768fd3a5ea8e1f4e632cb6ef820a5" translate="yes" xml:space="preserve">
          <source>Match an argument list of three, where the third argument is either a tuple containing argument one and two, &lt;strong&gt;or&lt;/strong&gt; a list beginning with argument one and two (that is, &lt;code&gt;[a,b,[a,b,c]]&lt;/code&gt; or &lt;code&gt;[a,b,{a,b}]&lt;/code&gt;):</source>
          <target state="translated">세 번째 인수는 인수 중 하나와 두 포함하는 튜플 셋의 인수리스트 일치 &lt;strong&gt;또는&lt;/strong&gt; 인수 한 두 (인로 시작 목록 &lt;code&gt;[a,b,[a,b,c]]&lt;/code&gt; 또는 &lt;code&gt;[a,b,{a,b}]&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="92514756645fe7077028fc14821601f7e85836da" translate="yes" xml:space="preserve">
          <source>Match any character except newline (by default)</source>
          <target state="translated">줄 바꿈을 제외한 모든 문자와 일치 (기본적으로)</target>
        </trans-unit>
        <trans-unit id="62e56bea29683834bf7ec08fb1eb30aa1828744a" translate="yes" xml:space="preserve">
          <source>Match some dictionary entries</source>
          <target state="translated">일부 사전 항목과 일치</target>
        </trans-unit>
        <trans-unit id="311fb719c2d9cb64132a0b11b661fb396a3a0223" translate="yes" xml:space="preserve">
          <source>Match specification, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the ERTS User's Guide and &lt;code&gt;&lt;a href=&quot;ms_transform&quot;&gt;ms_transform(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일치 사양 은 ERTS 사용 설명서 및 &lt;code&gt;&lt;a href=&quot;ms_transform&quot;&gt;ms_transform(3)&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c08d65581b61fabe23402aa00e8ab9a94f3ae9ef" translate="yes" xml:space="preserve">
          <source>Match specifications are used more or less as filters. They resemble usual Erlang matching in a list comprehension or in a fun used with &lt;code&gt;&lt;a href=&quot;lists#foldl-3&quot;&gt;lists:foldl/3&lt;/a&gt;&lt;/code&gt;, and so on. However, the syntax of pure match specifications is awkward, as they are made up purely by Erlang terms, and the language has no syntax to make the match specifications more readable.</source>
          <target state="translated">일치 사양은 필터로 사용됩니다. 그것들은리스트 이해 또는리스트와 함께 사용되는 재미에서 일반적인 Erlang 매칭과 비슷 &lt;code&gt;&lt;a href=&quot;lists#foldl-3&quot;&gt;lists:foldl/3&lt;/a&gt;&lt;/code&gt; 등. 그러나 순수 일치 스펙의 구문은 Erlang 용어로 순수하게 구성되므로 일치 스펙을 더 읽기 쉽게하기위한 구문이 없습니다.</target>
        </trans-unit>
        <trans-unit id="28103d4192f64923a9e433e5c840bc4e8b567bda" translate="yes" xml:space="preserve">
          <source>Match specifications used can be saved in a file (if a read-write file system is present) for use in later debugging sessions, see &lt;code&gt;&lt;a href=&quot;#wtp-1&quot;&gt;wtp/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">사용 된 일치 스펙은 나중에 디버깅 세션에서 사용하기 위해 파일 (읽기-쓰기 파일 시스템이있는 경우)에 저장할 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;#wtp-1&quot;&gt;wtp/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="8b4396a07794713ae25d8191b311ff7059dec215" translate="yes" xml:space="preserve">
          <source>Match specifications, see section &lt;code&gt; Match Specification in Erlang&lt;/code&gt; in ERTS User's Guide and the &lt;code&gt;&lt;a href=&quot;ms_transform&quot;&gt;ms_transform(3)&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">일치 사양 은 ERTS 사용자 가이드 및 &lt;code&gt;&lt;a href=&quot;ms_transform&quot;&gt;ms_transform(3)&lt;/a&gt;&lt;/code&gt; 모듈 의 &lt;code&gt; Match Specification in Erlang&lt;/code&gt; 에서 일치 사양 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1229fff8a073694fbfc1092526ee8748365e4bdf" translate="yes" xml:space="preserve">
          <source>Match specifications, see section &lt;code&gt;Match Specification in Erlang&lt;/code&gt; in ERTS User's Guide and the &lt;code&gt;&lt;a href=&quot;ms_transform&quot;&gt;ms_transform(3)&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">일치 사양 은 ERTS 사용 설명서의 &lt;code&gt;Match Specification in Erlang&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ms_transform&quot;&gt;ms_transform(3)&lt;/a&gt;&lt;/code&gt; 모듈 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c45c41f60cedeecdd4b1c366db7e307e66a6a606" translate="yes" xml:space="preserve">
          <source>Match target</source>
          <target state="translated">경기 대상</target>
        </trans-unit>
        <trans-unit id="58de7407dcefed17ecbb0f0f0caecc0925acc26e" translate="yes" xml:space="preserve">
          <source>Match the &lt;code&gt;MatchHead&lt;/code&gt; part against the match target term, binding the &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt; variables (much like in &lt;code&gt;ets:match/2&lt;/code&gt;). If the &lt;code&gt;MatchHead&lt;/code&gt; part cannot match the arguments, the match fails.</source>
          <target state="translated">&lt;code&gt;ets:match/2&lt;/code&gt; 와 유사하게 &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt; 변수를 바인딩 하여 &lt;code&gt;MatchHead&lt;/code&gt; 부분을 ​​일치 대상 용어 와 일치 시킵니다. 는 IF &lt;code&gt;MatchHead&lt;/code&gt; 의 일부가 인수와 일치 할 수없는, 경기가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d0bb026735ab1b1a560327096ea49590520df5c7" translate="yes" xml:space="preserve">
          <source>Match three arguments. When all three are equal and are numbers, append the process dump to the trace message, otherwise let the trace message be &quot;as is&quot;, but set the sequential trace token label to 4711:</source>
          <target state="translated">세 가지 주장을 일치시킵니다. 세 개가 모두 같고 숫자 인 경우 프로세스 덤프를 추적 메시지에 추가하십시오. 그렇지 않으면 추적 메시지를 &quot;있는 그대로&quot;두고 순차 추적 토큰 레이블을 4711로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="50d2b574a0b4bf14c816284735e4a32f6738492f" translate="yes" xml:space="preserve">
          <source>Match tuples of three elements, where the second element is either &lt;code&gt;'merry'&lt;/code&gt; or &lt;code&gt;'pippin'&lt;/code&gt;, and return the whole objects:</source>
          <target state="translated">두 번째 요소가 &lt;code&gt;'merry'&lt;/code&gt; 또는 &lt;code&gt;'pippin'&lt;/code&gt; 인 세 요소의 튜플을 일치 시키고 전체 오브젝트를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="b52bb892dfc03f66052c156357fd98f06f6d6ad0" translate="yes" xml:space="preserve">
          <source>Match two arguments, where the first is a tuple beginning with a list that in turn begins with the second argument times two (that is, &lt;code&gt;[{[4,x],y},2]&lt;/code&gt; or &lt;code&gt;[{[8], y, z},4])&lt;/code&gt;:</source>
          <target state="translated">두 개의 인수를 일치시킵니다. 첫 번째는 두 번째 인수로 시작하는 목록으로 시작하는 튜플입니다. 두 번째 인수는 &lt;code&gt;[{[4,x],y},2]&lt;/code&gt; 또는 &lt;code&gt;[{[8], y, z},4])&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da3931950dd632f760d810b04a1dfee915ca645d" translate="yes" xml:space="preserve">
          <source>MatchBody ::= [ ActionTerm ]</source>
          <target state="translated">MatchBody :: = [액션 용어]</target>
        </trans-unit>
        <trans-unit id="49eed79dc355081fc78c915df6e6741691fad326" translate="yes" xml:space="preserve">
          <source>MatchBody ::= [ ConditionExpression, ... ]</source>
          <target state="translated">MatchBody :: = [ConditionExpression, ...]</target>
        </trans-unit>
        <trans-unit id="e7543ce8b4424850514899929477fd3fd4bc7586" translate="yes" xml:space="preserve">
          <source>MatchCondition ::= { GuardFunction } | { GuardFunction, ConditionExpression, ... }</source>
          <target state="translated">MatchCondition :: = {GuardFunction} | {GuardFunction, ConditionExpression, ...}</target>
        </trans-unit>
        <trans-unit id="7a1238f4170ab727b947ac14efc193f8277c9e1a" translate="yes" xml:space="preserve">
          <source>MatchConditions ::= [ MatchCondition, ...] | &lt;code&gt;[]&lt;/code&gt;</source>
          <target state="translated">MatchConditions :: = [MatchCondition, ...] | &lt;code&gt;[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="95bf5fe6015be79d0f9353ed2e6ebd9f6f5c1aaf" translate="yes" xml:space="preserve">
          <source>MatchExpression ::= [ MatchFunction, ... ]</source>
          <target state="translated">MatchExpression :: = [MatchFunction, ...]</target>
        </trans-unit>
        <trans-unit id="4362346f5ab9c3e849d7a732cb6f7149b013ecea" translate="yes" xml:space="preserve">
          <source>MatchFunction ::= { MatchHead, MatchConditions, MatchBody }</source>
          <target state="translated">MatchFunction :: = {MatchHead, MatchConditions, MatchBody}</target>
        </trans-unit>
        <trans-unit id="62fe68ac64e3f31f3bc26fda2674c9914f299bee" translate="yes" xml:space="preserve">
          <source>MatchHead ::= MatchVariable | &lt;code&gt;'_'&lt;/code&gt; | [ MatchHeadPart, ... ]</source>
          <target state="translated">MatchHead :: = MatchVariable | &lt;code&gt;'_'&lt;/code&gt; | [MatchHeadPart, ...]</target>
        </trans-unit>
        <trans-unit id="8d11a2590b00416cc7fd21aa567f9dc7dcd1e80a" translate="yes" xml:space="preserve">
          <source>MatchHead ::= MatchVariable | &lt;code&gt;'_'&lt;/code&gt; | { MatchHeadPart, ... }</source>
          <target state="translated">MatchHead :: = MatchVariable | &lt;code&gt;'_'&lt;/code&gt; | {MatchHeadPart, ...}</target>
        </trans-unit>
        <trans-unit id="4c3dc5459e996623b4e979c498a0b4c1d7e9b686" translate="yes" xml:space="preserve">
          <source>MatchHeadPart ::= term() | MatchVariable | &lt;code&gt;'_'&lt;/code&gt;</source>
          <target state="translated">MatchHeadPart :: = 용어 () | MatchVariable | &lt;code&gt;'_'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b5c57568dca7b0bd330575231a9b4b598aa5de7d" translate="yes" xml:space="preserve">
          <source>MatchVariable ::= '$&amp;lt;number&amp;gt;'</source>
          <target state="translated">MatchVariable :: = '$ &amp;lt;숫자&amp;gt;'</target>
        </trans-unit>
        <trans-unit id="e03f215314c88dd829465d19bf121cc264d405e1" translate="yes" xml:space="preserve">
          <source>Matches a pattern against an expression. The returned value is &lt;code&gt;none&lt;/code&gt; if a match is impossible, &lt;code&gt;{true, Bindings}&lt;/code&gt; if &lt;code&gt;Pattern&lt;/code&gt; definitely matches &lt;code&gt;Expr&lt;/code&gt;, and &lt;code&gt;{false, Bindings}&lt;/code&gt; if a match is not definite, but cannot be excluded. &lt;code&gt;Bindings&lt;/code&gt; is then a list of pairs &lt;code&gt;{Var, SubExpr}&lt;/code&gt;, associating each variable in the pattern with either the corresponding subexpression of &lt;code&gt;Expr&lt;/code&gt;, or with the atom &lt;code&gt;any&lt;/code&gt; if no matching subexpression exists. (Recall that variables may not be repeated in a Core Erlang pattern.) The list of bindings is given in innermost-first order; this should only be of interest if &lt;code&gt;Pattern&lt;/code&gt; contains one or more alias patterns. If the returned value is &lt;code&gt;{true, []}&lt;/code&gt;, it implies that the pattern and the expression are syntactically identical.</source>
          <target state="translated">표현식과 패턴을 일치시킵니다. 일치가 불가능한 경우 반환되는 값은 &lt;code&gt;none&lt;/code&gt; &lt;code&gt;{true, Bindings}&lt;/code&gt; &lt;code&gt;Pattern&lt;/code&gt; 이 &lt;code&gt;Expr&lt;/code&gt; 과 확실히 일치하는 경우 &lt;code&gt;{false, Bindings}&lt;/code&gt; , 일치가 명확하지 않지만 제외 될 수없는 경우 {false, Bindings} 입니다. &lt;code&gt;Bindings&lt;/code&gt; 은 &lt;code&gt;{Var, SubExpr}&lt;/code&gt; 쌍의 목록으로 , 패턴의 각 변수를 &lt;code&gt;Expr&lt;/code&gt; 의 해당 하위 표현식 또는 일치하는 하위 표현식이없는 경우 원자 &lt;code&gt;any&lt;/code&gt; 와 연관시킵니다 . (핵심 Erlang 패턴에서는 변수가 반복되지 않을 수 있음을 기억하십시오.) 바인딩 목록은 가장 안쪽부터 순서대로 제공됩니다. 이것은 &lt;code&gt;Pattern&lt;/code&gt; 하나 이상의 별칭 패턴을 포함합니다. 반환 된 값이 &lt;code&gt;{true, []}&lt;/code&gt; 이면 패턴과 표현식이 구문 적으로 동일 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0086ec33bc64b94a17c1488954c54ae1f0850ff5" translate="yes" xml:space="preserve">
          <source>Matches any character.</source>
          <target state="translated">모든 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b0bce32c5a3c3fc3ed0e703a29ce005a9a59c17b" translate="yes" xml:space="preserve">
          <source>Matches any number of characters up to the end of the filename, the next dot, or the next slash.</source>
          <target state="translated">파일 이름 끝, 다음 점 또는 다음 슬래시까지 문자 수를 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="f115e2cfefeef7ee50e81931c874414b0559f037" translate="yes" xml:space="preserve">
          <source>Matches any of the characters listed. Two characters separated by a hyphen match a range of characters. Example: &lt;code&gt;[A-Z]&lt;/code&gt; matches any uppercase letter.</source>
          <target state="translated">나열된 문자와 일치합니다. 하이픈으로 구분 된 두 문자는 문자 범위와 일치합니다. 예 : &lt;code&gt;[A-Z]&lt;/code&gt; 는 대문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="50795a0a08132b80e78d1e76523a0677ba80c9ba" translate="yes" xml:space="preserve">
          <source>Matches any peer. This is a convenience that provides a filter equivalent to no filter.</source>
          <target state="translated">모든 피어와 일치합니다. 이것은 필터가없는 것과 동등한 필터를 제공하는 편의성입니다.</target>
        </trans-unit>
        <trans-unit id="45303a6504cacc79e7d23b3bbb52fa9c500e5dd8" translate="yes" xml:space="preserve">
          <source>Matches at a word boundary.</source>
          <target state="translated">단어 경계에서 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7ac95a7b57dc892c5cbccecec503375cd8b75457" translate="yes" xml:space="preserve">
          <source>Matches at the end of the subject, and before a newline at the end of the subject.</source>
          <target state="translated">주제의 끝에 그리고 주제의 끝에 개행 전에 일치합니다.</target>
        </trans-unit>
        <trans-unit id="dfe97d17ef60dfa95587204790b8e7a03401165c" translate="yes" xml:space="preserve">
          <source>Matches at the first matching position in the subject.</source>
          <target state="translated">주제의 첫 번째 일치 위치에서 일치합니다.</target>
        </trans-unit>
        <trans-unit id="30957d7eb006582b971d8e18207879a7a2e62a2f" translate="yes" xml:space="preserve">
          <source>Matches at the start of the subject.</source>
          <target state="translated">주제의 시작 부분과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c20e2cfc85fd5962f00bfd1aab37748d15201d74" translate="yes" xml:space="preserve">
          <source>Matches one character.</source>
          <target state="translated">한 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="bf384d7f3f9dc4a8d07f9032759bd099ac99af1e" translate="yes" xml:space="preserve">
          <source>Matches one or more &lt;code&gt;rs&lt;/code&gt;.</source>
          <target state="translated">하나 이상의 &lt;code&gt;rs&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="95b0a058c78027f9b36554648c7e31c06df213b3" translate="yes" xml:space="preserve">
          <source>Matches only at the end of the subject.</source>
          <target state="translated">주제의 끝에서만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="bce02edb2750c6f7e1edccc714e57113b0b26a46" translate="yes" xml:space="preserve">
          <source>Matches only those peers for which the specified &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; when applied to the connection's &lt;code&gt;diameter_caps&lt;/code&gt; record. Any other return value or exception is equivalent to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">연결의 &lt;code&gt;diameter_caps&lt;/code&gt; 레코드에 적용될 때 지정된 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 를 반환 하는 피어 만 일치합니다 . 다른 반환 값 또는 예외는 &lt;code&gt;false&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c84c071e773e0343110738922ba722b0e2af3f2c" translate="yes" xml:space="preserve">
          <source>Matches only those peers matched by at least one filter in the specified list. The resulting list will be in match order, peers matching the first filter of the list sorting before those matched by the second, and so on.</source>
          <target state="translated">지정된 목록에서 하나 이상의 필터와 일치하는 피어 만 일치시킵니다. 결과 목록은 일치 순서이며, 목록 정렬의 첫 번째 필터와 일치하는 피어는 두 번째 필터와 일치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f2592920b5282895068215ce350574baf645c52" translate="yes" xml:space="preserve">
          <source>Matches only those peers matched by each filter in the specified list.</source>
          <target state="translated">지정된 목록의 각 필터와 일치하는 피어 만 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="589f2d5ff54077f4e7ded5e562f61c1d207b2d40" translate="yes" xml:space="preserve">
          <source>Matches only those peers not matched by the specified filter.</source>
          <target state="translated">지정된 필터와 일치하지 않는 피어 만 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="a63639f69671438d06e3a88ceb05c2fd6d45b827" translate="yes" xml:space="preserve">
          <source>Matches only those peers whose Origin-Host has the same value as Destination-Host in the outgoing request in question, or any peer if the request does not contain a Destination-Host AVP.</source>
          <target state="translated">발신 요청에서 Origin-Host 값이 대상 호스트와 동일한 피어 또는 요청에 대상 호스트 AVP가 포함되지 않은 피어와 만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7246e14a8a2a6df71afafbd3a74a8b44cdfbd531" translate="yes" xml:space="preserve">
          <source>Matches only those peers whose Origin-Host has the specified value, or all peers if the atom &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Origin-Host에 지정된 값이있는 피어 또는 원자가 &lt;code&gt;any&lt;/code&gt; 인 경우 모든 피어와 일치 합니다 .</target>
        </trans-unit>
        <trans-unit id="95597417bac7dc49af239c255741702c0c22bdaf" translate="yes" xml:space="preserve">
          <source>Matches only those peers whose Origin-Realm has the same value as Destination-Realm in the outgoing request in question, or any peer if the request does not contain a Destination-Realm AVP.</source>
          <target state="translated">해당 발신 요청에서 Origin-Realm이 Destination-Realm과 동일한 값을 갖는 피어 또는 요청에 Destination-Realm AVP가 포함되지 않은 피어와 만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="4616ccf0ec60315c7670131e4744903a3aa36484" translate="yes" xml:space="preserve">
          <source>Matches only those peers whose Origin-Realm has the specified value, or all peers if the atom &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Origin-Realm이 지정된 값을 갖는 피어 또는 원자가 &lt;code&gt;any&lt;/code&gt; 인 모든 피어와 일치 합니다 .</target>
        </trans-unit>
        <trans-unit id="8a4e16b1f64f5c039f506ff58b839fd8686c547b" translate="yes" xml:space="preserve">
          <source>Matches some objects stored in a table and returns a non-empty list of the bindings matching a specified pattern in some unspecified order. The table, the pattern, and the number of objects that are matched are all defined by &lt;code&gt;Continuation&lt;/code&gt;, which has been returned by a previous call to &lt;code&gt;match/1&lt;/code&gt; or &lt;code&gt;match/3&lt;/code&gt;.</source>
          <target state="translated">테이블에 저장된 일부 오브젝트를 일치시키고 지정되지 않은 순서로 지정된 패턴과 일치하는 비어 있지 않은 바인딩 목록을 리턴합니다. 일치하는 테이블, 패턴 및 오브젝트 수는 모두 &lt;code&gt;Continuation&lt;/code&gt; 에 의해 정의되며 이는 &lt;code&gt;match/1&lt;/code&gt; 또는 &lt;code&gt;match/3&lt;/code&gt; 에 대한 이전 호출에 의해 리턴되었습니다 .</target>
        </trans-unit>
        <trans-unit id="fd0109e8c46b7b74ad55d61eaa83a0d60c1cd8f8" translate="yes" xml:space="preserve">
          <source>Matches some or all objects of table &lt;code&gt;Name&lt;/code&gt; and returns a non-empty list of the bindings that match &lt;code&gt;Pattern&lt;/code&gt; in some unspecified order. For a description of patterns, see &lt;code&gt;&lt;a href=&quot;ets#match-2&quot;&gt;ets:match/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 테이블의 일부 또는 모든 객체 를 일치시키고 &lt;code&gt;Pattern&lt;/code&gt; 과 일치하는 바인딩의 비어 있지 않은 목록을 지정되지 않은 순서로 반환합니다 . 패턴에 대한 설명은 &lt;code&gt;&lt;a href=&quot;ets#match-2&quot;&gt;ets:match/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7450adfcb4b169def8a4607352e723d68bd86b34" translate="yes" xml:space="preserve">
          <source>Matches some or all objects stored in table &lt;code&gt;Name&lt;/code&gt; and returns a non-empty list of the objects that match &lt;code&gt;Pattern&lt;/code&gt; in some unspecified order. For a description of patterns, see &lt;code&gt;&lt;a href=&quot;ets#match-2&quot;&gt;ets:match/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 테이블에 저장된 일부 또는 모든 오브젝트 를 일치시키고 지정되지 않은 순서로 &lt;code&gt;Pattern&lt;/code&gt; 과 일치하는 비어 있지 않은 오브젝트 목록을 리턴합니다 . 패턴에 대한 설명은 &lt;code&gt;&lt;a href=&quot;ets#match-2&quot;&gt;ets:match/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="adb3e1824193dafdae7a5fd33b8ea49f66c2c1dd" translate="yes" xml:space="preserve">
          <source>Matches the beginning of a string.</source>
          <target state="translated">문자열의 시작과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="4c548c831bb16f2a3bc17e5430fb0fb7ff876eb6" translate="yes" xml:space="preserve">
          <source>Matches the end of a string.</source>
          <target state="translated">문자열의 끝과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2cdef85f0928e6e8b1028572e8dc40e0e560c24e" translate="yes" xml:space="preserve">
          <source>Matches the escape sequence or literal character c.</source>
          <target state="translated">이스케이프 시퀀스 또는 리터럴 문자와 일치합니다. c.</target>
        </trans-unit>
        <trans-unit id="0435b1eedb79970f4013fe9211b9ebe7da670511" translate="yes" xml:space="preserve">
          <source>Matches the non-metacharacter c.</source>
          <target state="translated">메타 문자가 아닌 문자와 일치합니다. c.</target>
        </trans-unit>
        <trans-unit id="e28e6ed212ebaee585530d5991166a71f8b48a86" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; against pattern &lt;code&gt;Pattern&lt;/code&gt;.</source>
          <target state="translated">테이블의 개체 일치 &lt;code&gt;Tab&lt;/code&gt; 패턴에 대한 &lt;code&gt;Pattern&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d29aca058cbf8d1d0f58db77974d455fcaada07" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; against pattern &lt;code&gt;Pattern&lt;/code&gt;. For a description of patterns, see &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt;. The function returns a list of all objects that match the pattern.</source>
          <target state="translated">테이블의 개체 일치 &lt;code&gt;Tab&lt;/code&gt; 패턴에 대한 &lt;code&gt;Pattern&lt;/code&gt; . 패턴에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 . 이 함수는 패턴과 일치하는 모든 객체의 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="db735a0007cc043e4574b21e24e3a6e8e46b90e2" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; using a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt;. If the match specification returns &lt;code&gt;true&lt;/code&gt; for an object, that object considered a match and is counted. For any other result from the match specification the object is not considered a match and is therefore not counted.</source>
          <target state="translated">일치 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 사용하여 테이블 &lt;code&gt;Tab&lt;/code&gt; 의 개체를 일치시킵니다 . 일치 스펙 이 오브젝트에 대해 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 해당 오브젝트는 일치로 간주되어 계산됩니다. 일치 사양의 다른 결과에 대해서는 개체가 일치하는 것으로 간주되지 않으므로 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="455a15388f0d3001f88cee281c911981a69199e3" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; using a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt;. If the match specification returns &lt;code&gt;true&lt;/code&gt; for an object, that object is removed from the table. For any other result from the match specification the object is retained. This is a more general call than the &lt;code&gt;&lt;a href=&quot;#match_delete-2&quot;&gt; match_delete/2&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">일치 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 사용하여 테이블 &lt;code&gt;Tab&lt;/code&gt; 의 개체를 일치시킵니다 . 일치 사양 이 개체에 대해 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 해당 개체가 테이블에서 제거됩니다. 일치 사양의 다른 결과에 대해서는 객체가 유지됩니다. 이것은 &lt;code&gt;&lt;a href=&quot;#match_delete-2&quot;&gt; match_delete/2&lt;/a&gt;&lt;/code&gt; 호출 보다 더 일반적인 호출입니다.</target>
        </trans-unit>
        <trans-unit id="6b012b167808e61a37f3f13edeb00bcf37acbcee" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; using a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt;. If the match specification returns &lt;code&gt;true&lt;/code&gt; for an object, that object is removed from the table. For any other result from the match specification the object is retained. This is a more general call than the &lt;code&gt;&lt;a href=&quot;#match_delete-2&quot;&gt;match_delete/2&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">일치 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 사용하여 테이블 &lt;code&gt;Tab&lt;/code&gt; 의 개체를 일치시킵니다 . 일치 스펙 이 오브젝트에 대해 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 해당 오브젝트가 테이블에서 제거됩니다. 일치 사양의 다른 결과에 대해서는 개체가 유지됩니다. 이것은 &lt;code&gt;&lt;a href=&quot;#match_delete-2&quot;&gt;match_delete/2&lt;/a&gt;&lt;/code&gt; 호출 보다 더 일반적인 호출입니다.</target>
        </trans-unit>
        <trans-unit id="f314d3d7e1fd748578a641bfbf6311159aed1316" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; using a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt;. This is a more general call than &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match_object-2&quot;&gt;match_object/2&lt;/a&gt;&lt;/code&gt; calls. In its simplest form, the match specification is as follows:</source>
          <target state="translated">일치 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 사용하여 테이블 &lt;code&gt;Tab&lt;/code&gt; 의 개체를 일치시킵니다 . 이것은 &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#match_object-2&quot;&gt;match_object/2&lt;/a&gt;&lt;/code&gt; 호출 보다 일반적인 호출입니다. 가장 간단한 형식으로 일치 사양은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8dfac617898b79dd2741468d1513c14a6c53d233" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; using a &lt;code&gt;match_spec&lt;/code&gt; as described in the &lt;code&gt;ERTS&lt;/code&gt; User's Guide, and returns a chunk of terms and a continuation. The wanted number of returned terms is specified by argument &lt;code&gt;NObjects&lt;/code&gt;. The lock argument can be &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt;. The continuation is to be used as argument to &lt;code&gt;mnesia:select/1&lt;/code&gt;, if more or all answers are needed.</source>
          <target state="translated">&lt;code&gt;ERTS&lt;/code&gt; 사용 설명서에 설명 된대로 &lt;code&gt;match_spec&lt;/code&gt; 을 사용하여 테이블 &lt;code&gt;Tab&lt;/code&gt; 의 개체를 일치시키고 용어와 연속을 반환합니다. 원하는 수의 반환되는 항은 인수 &lt;code&gt;NObjects&lt;/code&gt; 에 의해 지정됩니다 . 잠금 인수는 &lt;code&gt;read&lt;/code&gt; 거나 &lt;code&gt;write&lt;/code&gt; 수 있습니다 . 더 많은 또는 모든 답변이 필요한 경우 연속은 &lt;code&gt;mnesia:select/1&lt;/code&gt; 의 인수로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e64640be20ca493c8fc40edf41b5b9186f3b2197" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; using a &lt;code&gt;match_spec&lt;/code&gt; as described in the &lt;code&gt;ets:select/3&lt;/code&gt;. Optionally a lock &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt; can be given as the third argument. Default is &lt;code&gt;read&lt;/code&gt;. The return value depends on &lt;code&gt;MatchSpec&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ets:select/3&lt;/code&gt; 에 설명 된대로 &lt;code&gt;match_spec&lt;/code&gt; 을 사용하여 테이블 &lt;code&gt;Tab&lt;/code&gt; 의 객체를 일치시킵니다 . 선택적으로 잠금 &lt;code&gt;read&lt;/code&gt; 또는 &lt;code&gt;write&lt;/code&gt; 가 세 번째 인수로 제공 될 수 있습니다. 기본값은 &lt;code&gt;read&lt;/code&gt; 입니다. 반환 값은 &lt;code&gt;MatchSpec&lt;/code&gt; 에 의존합니다 .</target>
        </trans-unit>
        <trans-unit id="a1f9639126fbeb35a28a58c64b5cdf217294a65f" translate="yes" xml:space="preserve">
          <source>Matches the objects in the table &lt;code&gt;Tab&lt;/code&gt; using a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt;. For each matched object, the existing object is replaced with the match specification result.</source>
          <target state="translated">일치 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 사용하여 테이블 &lt;code&gt;Tab&lt;/code&gt; 의 개체를 일치시킵니다 . 일치하는 각 개체에 대해 기존 개체는 일치 사양 결과로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="473b51b88af255ce39d9fa5d375d31e69528b449" translate="yes" xml:space="preserve">
          <source>Matches when not at a word boundary.</source>
          <target state="translated">단어 경계에 없을 때 일치합니다.</target>
        </trans-unit>
        <trans-unit id="ff59d4c3d244f3cad2fc9a4df684903b72e3fa73" translate="yes" xml:space="preserve">
          <source>Matches zero or more &lt;code&gt;rs&lt;/code&gt;.</source>
          <target state="translated">0 개 이상의 &lt;code&gt;rs&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="bf4e77ebb7ccf37afab91a38875933929de61e50" translate="yes" xml:space="preserve">
          <source>Matches zero or one &lt;code&gt;rs&lt;/code&gt;.</source>
          <target state="translated">0 또는 1 개의 &lt;code&gt;rs&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="5bcae9e03d2abf08b09e53c355319ed13551bd27" translate="yes" xml:space="preserve">
          <source>Matching &lt;code&gt;{foo, X = {bar, Y}}&lt;/code&gt; against expression &quot;&lt;code&gt;{foo, {bar, baz}}&lt;/code&gt;&quot; yields &lt;code&gt;{true, Bindings}&lt;/code&gt; where &lt;code&gt;Bindings&lt;/code&gt; associates &quot;&lt;code&gt;Y&lt;/code&gt;&quot; with &quot;&lt;code&gt;baz&lt;/code&gt;&quot;, and &quot;&lt;code&gt;X&lt;/code&gt;&quot; with &quot;&lt;code&gt;{bar, baz}&lt;/code&gt;&quot;.</source>
          <target state="translated">&quot; &lt;code&gt;{foo, {bar, baz}}&lt;/code&gt; &quot; 표현식에 대해 &lt;code&gt;{foo, X = {bar, Y}}&lt;/code&gt; 를 일치 시키면 &lt;code&gt;{true, Bindings}&lt;/code&gt; 여기서 &lt;code&gt;Bindings&lt;/code&gt; 는 &quot; &lt;code&gt;Y&lt;/code&gt; &quot;를 &quot; &lt;code&gt;baz&lt;/code&gt; &quot;와 연결하고 &quot; &lt;code&gt;X&lt;/code&gt; &quot;를 &quot; &lt;code&gt;{bar, baz}&lt;/code&gt; 와 연결 합니다. , baz} &quot;.</target>
        </trans-unit>
        <trans-unit id="b60d1249c4c758556a1d227c9f807ee709be4c34" translate="yes" xml:space="preserve">
          <source>Matching Syntax</source>
          <target state="translated">일치 구문</target>
        </trans-unit>
        <trans-unit id="71e571ae9130ba825368a44ee875bfb358022107" translate="yes" xml:space="preserve">
          <source>Matching a binary will also cause it to shrink and the next append operation will copy the binary data:</source>
          <target state="translated">이진을 일치 시키면 축소되고 다음 추가 작업으로 이진 데이터가 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="04c82124a2a309af1e4d0004642386e1fa87f06d" translate="yes" xml:space="preserve">
          <source>Matching a pattern &quot;&lt;code&gt;{X, Y}&lt;/code&gt;&quot; against &lt;code&gt;any&lt;/code&gt; yields &lt;code&gt;{false, Bindings}&lt;/code&gt; where &lt;code&gt;Bindings&lt;/code&gt; associates both &quot;&lt;code&gt;X&lt;/code&gt;&quot; and &quot;&lt;code&gt;Y&lt;/code&gt;&quot; with &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">&quot; &lt;code&gt;{X, Y}&lt;/code&gt; &quot; 패턴 을 &lt;code&gt;any&lt;/code&gt; 의 패턴과 일치 시키면 &lt;code&gt;{false, Bindings}&lt;/code&gt; 여기서 &lt;code&gt;Bindings&lt;/code&gt; 는 &quot; &lt;code&gt;X&lt;/code&gt; &quot;와 &quot; &lt;code&gt;Y&lt;/code&gt; &quot;를 &lt;code&gt;any&lt;/code&gt; 와 연관시킵니다 .</target>
        </trans-unit>
        <trans-unit id="ad2bcb27e7add44b28aa94618d57a047fab264ce" translate="yes" xml:space="preserve">
          <source>Matching a pattern &quot;&lt;code&gt;{X, Y}&lt;/code&gt;&quot; against the expression &quot;&lt;code&gt;{foo, f(Z)}&lt;/code&gt;&quot; yields &lt;code&gt;{true, Bindings}&lt;/code&gt; where &lt;code&gt;Bindings&lt;/code&gt; associates &quot;&lt;code&gt;X&lt;/code&gt;&quot; with the subtree &quot;&lt;code&gt;foo&lt;/code&gt;&quot; and &quot;&lt;code&gt;Y&lt;/code&gt;&quot; with the subtree &quot;&lt;code&gt;f(Z)&lt;/code&gt;&quot;.</source>
          <target state="translated">&quot; &lt;code&gt;{foo, f(Z)}&lt;/code&gt; &quot; 표현식에 대해 &quot; &lt;code&gt;{X, Y}&lt;/code&gt; &quot; 패턴을 일치 시키면 &lt;code&gt;{true, Bindings}&lt;/code&gt; 여기서 &lt;code&gt;Bindings&lt;/code&gt; 는 &quot; &lt;code&gt;X&lt;/code&gt; &quot;를 하위 트리 &quot; &lt;code&gt;foo&lt;/code&gt; &quot;에 연결하고 &quot; &lt;code&gt;Y&lt;/code&gt; &quot;를 하위 트리 &quot; &lt;code&gt;f(Z)&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="36481aa97a951a1dcf7d8486d523f317dc45f5dc" translate="yes" xml:space="preserve">
          <source>Matching an expression against an empty map literal, matches its type but no variables are bound:</source>
          <target state="translated">빈 맵 리터럴에 대해 표현식을 일치 시키면 해당 유형과 일치하지만 변수는 바인딩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d117b8c447d4889a004e4beb80ae87b3b9f61b4" translate="yes" xml:space="preserve">
          <source>Matching can be used in combination with records, as shown in the following example:</source>
          <target state="translated">다음 예와 같이 일치는 레코드와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21db0315aaeea4915646c1ba5a3af148311bbc82" translate="yes" xml:space="preserve">
          <source>Matching characters by Unicode property is not fast, as PCRE must do a multistage table lookup to find a character property. That is why the traditional escape sequences such as \d and \w do not use Unicode properties in PCRE by default. However, you can make them do so by setting option &lt;code&gt;ucp&lt;/code&gt; or by starting the pattern with (*UCP).</source>
          <target state="translated">PCRE가 문자 특성을 찾기 위해 다단계 테이블 검색을 수행해야하므로 유니 코드 특성으로 문자를 일치시키는 것은 빠르지 않습니다. 따라서 \ d 및 \ w와 같은 기존 이스케이프 시퀀스는 기본적으로 PCRE에서 유니 코드 속성을 사용하지 않습니다. 그러나 옵션 &lt;code&gt;ucp&lt;/code&gt; 를 설정 하거나 (* UCP)로 패턴을 시작하여 이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="daa0e37dc758ae15a4e0e7ac7d8a0c3a7422c8e2" translate="yes" xml:space="preserve">
          <source>Matching in maps only allows for &lt;code&gt;:=&lt;/code&gt; as delimiters of associations.</source>
          <target state="translated">맵에서 일치하면 연관 구분 기호로 &lt;code&gt;:=&lt;/code&gt; 만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e0b3439d7561cb2dee16bc2f99dd957cfc474df0" translate="yes" xml:space="preserve">
          <source>Matching of key-value associations from maps is done as follows:</source>
          <target state="translated">맵에서 키-값 연관의 일치는 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e9cba95bb8e1514e71368d11f0995ae0398f3886" translate="yes" xml:space="preserve">
          <source>Matching of literals as keys are allowed in function heads:</source>
          <target state="translated">함수 헤드에서 키로 리터럴 일치가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="74c212bf6fa09d18e1ec277db201559eabf9e7c0" translate="yes" xml:space="preserve">
          <source>Matching on the top-level of the fun head can be a more natural way to access &lt;code&gt;'$_'&lt;/code&gt;, see above.</source>
          <target state="translated">펀 헤드의 최상위 레벨에 일치하는 것은 &lt;code&gt;'$_'&lt;/code&gt; 에 액세스하는보다 자연스러운 방법이 될 수 있습니다 ( 위 참조).</target>
        </trans-unit>
        <trans-unit id="049506329261487bb3976b3275edff9e35424978" translate="yes" xml:space="preserve">
          <source>Matching pattern &quot;&lt;code&gt;{X, {bar, Y}}&lt;/code&gt;&quot; against expression &quot;&lt;code&gt;{foo, f(Z)}&lt;/code&gt;&quot; yields &lt;code&gt;{false, Bindings}&lt;/code&gt; where &lt;code&gt;Bindings&lt;/code&gt; associates &quot;&lt;code&gt;X&lt;/code&gt;&quot; with the subtree &quot;&lt;code&gt;foo&lt;/code&gt;&quot; and &quot;&lt;code&gt;Y&lt;/code&gt;&quot; with &lt;code&gt;any&lt;/code&gt; (because it is not known if &quot;&lt;code&gt;{foo, Y}&lt;/code&gt;&quot; might match the run-time value of &quot;&lt;code&gt;f(Z)&lt;/code&gt;&quot; or not).</source>
          <target state="translated">&quot; &lt;code&gt;{foo, f(Z)}&lt;/code&gt; &quot; 표현식에 대해 &quot; &lt;code&gt;{X, {bar, Y}}&lt;/code&gt; &quot; 패턴을 일치 시키면 &lt;code&gt;{false, Bindings}&lt;/code&gt; 여기서 &lt;code&gt;Bindings&lt;/code&gt; 는 &quot; &lt;code&gt;X&lt;/code&gt; &quot;를 하위 트리 &quot; &lt;code&gt;foo&lt;/code&gt; &quot;와 연결하고 &quot; &lt;code&gt;Y&lt;/code&gt; &quot;를 &lt;code&gt;any&lt;/code&gt; ( &quot; &lt;code&gt;{foo, Y}&lt;/code&gt; &quot;가 &quot; &lt;code&gt;f(Z)&lt;/code&gt; &quot; 의 런타임 값과 일치 하는지 여부를 알 수 없기 때문입니다 ).</target>
        </trans-unit>
        <trans-unit id="41eadb2a54882c5622d4b38b554e5de62b2f70fb" translate="yes" xml:space="preserve">
          <source>Matching pattern &quot;&lt;code&gt;{foo, bar}&lt;/code&gt;&quot; against expression &quot;&lt;code&gt;{foo, f()}&lt;/code&gt;&quot; yields &lt;code&gt;{false, []}&lt;/code&gt;, telling us that there might be a match, but we cannot deduce any bindings.</source>
          <target state="translated">&quot; &lt;code&gt;{foo, f()}&lt;/code&gt; &quot; 표현식에 대해 &quot; &lt;code&gt;{foo, bar}&lt;/code&gt; &quot; 패턴을 일치 시키면 &lt;code&gt;{false, []}&lt;/code&gt; 생성 하여 일치가있을 수 있지만 바인딩을 추론 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="565f0418bb5db88e5d8e94d04658199d8610d3a3" translate="yes" xml:space="preserve">
          <source>Matching with &lt;code&gt;=&lt;/code&gt; cannot be used in the body. It can only be used on the top-level in the head of the fun. Example from the shell again:</source>
          <target state="translated">본문에서 &lt;code&gt;=&lt;/code&gt; 와 일치하는 것은 사용할 수 없습니다. 그것은 재미의 머리에서 최상위 수준에서만 사용할 수 있습니다. 쉘의 예 :</target>
        </trans-unit>
        <trans-unit id="a3b81034e705bd05b97727252f92caaa6d4b0b26" translate="yes" xml:space="preserve">
          <source>Mathematical functions.</source>
          <target state="translated">수학 함수.</target>
        </trans-unit>
        <trans-unit id="a06a77cda1f0fe480299649af647924142a54fb7" translate="yes" xml:space="preserve">
          <source>Mathematical symbol</source>
          <target state="translated">수학 기호</target>
        </trans-unit>
        <trans-unit id="c58ea4f87745ada36a92fb71c082ea8bc73755ba" translate="yes" xml:space="preserve">
          <source>Max detail level activates tracing of all calls to &lt;code&gt;et:trace_me/4,5&lt;/code&gt;</source>
          <target state="translated">최대 세부 수준은 &lt;code&gt;et:trace_me/4,5&lt;/code&gt; 에 대한 모든 호출의 추적을 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="11d44674eb08f7f43d0a32b42fd60d63d0160c36" translate="yes" xml:space="preserve">
          <source>Max message size. If the encoded message (PDU) exceeds this size, the message should be segmented, and then encoded.</source>
          <target state="translated">최대 메시지 크기 인코딩 된 메시지 (PDU)가이 크기를 초과하면 메시지를 분할 한 다음 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d97f56b8e291a3ee3880e81646a3d47ce560d1f" translate="yes" xml:space="preserve">
          <source>Max number of reconnection attempts = 3</source>
          <target state="translated">최대 재 연결 시도 횟수 = 3</target>
        </trans-unit>
        <trans-unit id="8f6fcbc1873209046a71e4646a7bf770c375c7d7" translate="yes" xml:space="preserve">
          <source>Max number of simultaneous requests handled by the agent.</source>
          <target state="translated">에이전트가 처리 한 최대 동시 요청 수</target>
        </trans-unit>
        <trans-unit id="67ecefff02b1fa60a3ed3d34a164e5b55ca3b553" translate="yes" xml:space="preserve">
          <source>MaxHeapSize :: &lt;code&gt;&lt;a href=&quot;#type-max_heap_size&quot;&gt;max_heap_size()&lt;/a&gt;&lt;/code&gt;}</source>
          <target state="translated">MaxHeapSize :: &lt;code&gt;&lt;a href=&quot;#type-max_heap_size&quot;&gt;max_heap_size()&lt;/a&gt;&lt;/code&gt;}</target>
        </trans-unit>
        <trans-unit id="134ec94ac95c6d28341162fd550979562d4d3df9" translate="yes" xml:space="preserve">
          <source>MaxHeapSize :: max_heap_size()}</source>
          <target state="translated">MaxHeapSize :: max_heap_size ()}</target>
        </trans-unit>
        <trans-unit id="7fb79c4fc5ed76bf0ff64ddd38b1f62fc36d71a2" translate="yes" xml:space="preserve">
          <source>Maximum &lt;code&gt;mseg_alloc&lt;/code&gt; carriers. Maximum number of carriers placed in separate memory segments. When this limit is reached, new carriers are placed in memory retrieved from &lt;code&gt;sys_alloc&lt;/code&gt;.</source>
          <target state="translated">최대 &lt;code&gt;mseg_alloc&lt;/code&gt; 캐리어. 별도의 메모리 세그먼트에 배치 된 최대 캐리어 수. 이 한계에 도달하면 &lt;code&gt;sys_alloc&lt;/code&gt; 에서 검색된 메모리에 새 캐리어가 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6eacd663f585efc475070891fcbc20a37ca64c6" translate="yes" xml:space="preserve">
          <source>Maximum &lt;code&gt;mseg_alloc&lt;/code&gt; multiblock carriers. Maximum number of multiblock carriers allocated through &lt;code&gt;mseg_alloc&lt;/code&gt; by allocator &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt;. When this limit is reached, new multiblock carriers are allocated through &lt;code&gt;sys_alloc&lt;/code&gt;.</source>
          <target state="translated">최대 &lt;code&gt;mseg_alloc&lt;/code&gt; 멀티 블록 캐리어. 할당 자 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 에 의해 &lt;code&gt;mseg_alloc&lt;/code&gt; 을 통해 할당 된 최대 멀티 블록 캐리어 수 . 이 한계에 도달하면 새 &lt;code&gt;sys_alloc&lt;/code&gt; 블록 캐리어가 sys_alloc을 통해 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd2141dfa85073c5d5d798b526c7807965d10406" translate="yes" xml:space="preserve">
          <source>Maximum &lt;code&gt;mseg_alloc&lt;/code&gt; singleblock carriers. Maximum number of singleblock carriers allocated through &lt;code&gt;mseg_alloc&lt;/code&gt; by allocator &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt;. When this limit is reached, new singleblock carriers are allocated through &lt;code&gt;sys_alloc&lt;/code&gt;.</source>
          <target state="translated">최대 &lt;code&gt;mseg_alloc&lt;/code&gt; 단일 블록 반송파. 할당 자 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 가 &lt;code&gt;mseg_alloc&lt;/code&gt; 을 통해 할당 한 최대 단일 블록 캐리어 수입니다 . 이 한계에 도달하면 새로운 singleblock 캐리어를 통해 할당 &lt;code&gt;sys_alloc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2560b86e3ae10f6289deb0fb563e661e33d86418" translate="yes" xml:space="preserve">
          <source>Maximum block search depth. This flag has effect only if the good fit strategy is selected for allocator &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt;. When the good fit strategy is used, free blocks are placed in segregated free-lists. Each free-list contains blocks of sizes in a specific range. The maxiumum block search depth sets a limit on the maximum number of blocks to inspect in a free-list during a search for suitable block satisfying the request.</source>
          <target state="translated">최대 블록 검색 깊이. 이 플래그는 할당 자 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 에 대해 적합 전략을 선택한 경우에만 적용됩니다 . 적합 전략을 사용하면 자유 블록이 분리 된 자유 목록에 배치됩니다. 각 자유 목록에는 특정 범위의 크기 블록이 포함됩니다. 최대 블록 탐색 깊이는 요청을 만족시키는 적합한 블록을 탐색하는 동안 자유 목록에서 검사 할 최대 블록 수의 한계를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d51cca9df00fb6d2d33b5042e7197395c4a8e7ed" translate="yes" xml:space="preserve">
          <source>Maximum cached segments. The maximum number of memory segments stored in the memory segment cache. Valid range is &lt;code&gt;[0, 30]&lt;/code&gt;. Defaults to &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">캐시 된 최대 세그먼트. 메모리 세그먼트 캐시에 저장된 최대 메모리 세그먼트 수입니다. 유효한 범위는 &lt;code&gt;[0, 30]&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;10&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3aacd33489c919c3259f3def36a32db78de3dce1" translate="yes" xml:space="preserve">
          <source>Maximum content-length in an incoming request, in bytes. Requests with content larger than this are answered with status 413. Default is &lt;code&gt;100000000&lt;/code&gt; (100 MB).</source>
          <target state="translated">수신 요청의 최대 컨텐츠 길이 (바이트). 이보다 큰 내용의 요청은 상태 413으로 응답됩니다. 기본값은 &lt;code&gt;100000000&lt;/code&gt; (100MB)입니다.</target>
        </trans-unit>
        <trans-unit id="a1f8a644c87141329a80f40e8e889c2fcd6e043d" translate="yes" xml:space="preserve">
          <source>Maximum depth to which terms are printed in case of error.</source>
          <target state="translated">오류 발생시 용어가 인쇄되는 최대 깊이입니다.</target>
        </trans-unit>
        <trans-unit id="3d28b59ad57e9489a6f4dacef960badc6138d55c" translate="yes" xml:space="preserve">
          <source>Maximum number of accumulated ack's. At most this many ack's will be accumulated by the transaction sender (if started and configured to accumulate ack's).</source>
          <target state="translated">누적 된 최대 ack 수입니다. 기껏해야이 ack가 많은 수의 트랜잭션 발신자가 누적됩니다 (시작하고 ack을 축적하도록 구성된 경우).</target>
        </trans-unit>
        <trans-unit id="3fd6bff2681eda77c96a1c420386709c1976443f" translate="yes" xml:space="preserve">
          <source>Maximum number of accumulated requests. At most this many requests will be accumulated by the transaction sender (if started and configured to accumulate requests).</source>
          <target state="translated">누적 된 최대 요청 수 기껏해야이 많은 요청이 트랜잭션 전송자에 의해 누적됩니다 (요청을 누적하도록 시작 및 구성된 경우).</target>
        </trans-unit>
        <trans-unit id="266851f73fafaca0bf2a7c683bc5bb3b6087f7f7" translate="yes" xml:space="preserve">
          <source>Maximum number of inbound streams</source>
          <target state="translated">최대 인바운드 스트림 수</target>
        </trans-unit>
        <trans-unit id="8e8430ded43149745cb3e173c59fd623e6e072ee" translate="yes" xml:space="preserve">
          <source>Maximum number of locks printed or no limit with &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">최대 인쇄 잠금 번호 나에 제한이 &lt;code&gt;none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32bf44bb5328eccf585529f07558abf83b7b8e84" translate="yes" xml:space="preserve">
          <source>Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 1.</source>
          <target state="translated">유효한 인증 경로에서 피어 인증서를 따를 수있는 자체 발급되지 않은 중간 인증서의 최대 수 따라서 깊이가 0이면 신뢰할 수있는 ROOT-CA가 PEER에 직접 서명해야합니다. 1 인 경우 경로는 PEER, CA, ROOT-CA 일 수 있습니다. 2 인 경우 경로는 PEER, CA, CA, ROOT-CA 등일 수 있습니다. 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="99fff8db195ccd6c7a048657d30498c73cc01e79" translate="yes" xml:space="preserve">
          <source>Maximum number of processes allowed in the application.</source>
          <target state="translated">응용 프로그램에서 허용되는 최대 프로세스 수.</target>
        </trans-unit>
        <trans-unit id="2aaab3dedee65069b116c73b83377fb65720dd78" translate="yes" xml:space="preserve">
          <source>Maximum number of retransmissions before this address is considered unreachable (and an alternative address is selected)</source>
          <target state="translated">이 주소 이전에 도달 할 수없는 최대 재전송 횟수 (및 다른 주소가 선택됨)</target>
        </trans-unit>
        <trans-unit id="f9241fef7fbe8fcf32ca009d6ccfebe5481eab50" translate="yes" xml:space="preserve">
          <source>Maximum retransmissions while establishing an association</source>
          <target state="translated">연결을 설정하는 동안 최대 재전송</target>
        </trans-unit>
        <trans-unit id="48fdfa1e1dccf2224acc92084ff1e406b0b85d9e" translate="yes" xml:space="preserve">
          <source>Maximum size of the accumulated requests. At most this much requests will be accumulated by the transaction sender (if started and configured to accumulate requests).</source>
          <target state="translated">누적 된 요청의 최대 크기 기껏해야이 많은 요청이 트랜잭션 전송자에 의해 누적됩니다 (요청을 누적하도록 시작 및 구성된 경우).</target>
        </trans-unit>
        <trans-unit id="28c7bf59062e8e7b399ad75612dd36c886f2132d" translate="yes" xml:space="preserve">
          <source>Maximum time in milliseconds for the authentication negotiation. Defaults to 120000 ms (2 minutes). If the client fails to log in within this time, the connection is closed.</source>
          <target state="translated">인증 협상을위한 최대 시간 (밀리 초)입니다. 기본값은 120000ms (2 분)입니다. 이 시간 내에 클라이언트가 로그인에 실패하면 연결이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="d14bf4fb6ca42413fd5488014cf2a641dac8fb5a" translate="yes" xml:space="preserve">
          <source>Maximum time in milliseconds for the authentication negotiation. If the client fails to log in within this time, the connection is closed. The default value is 2 minutes. It is quite a long time, but can lowered if the client is supposed to be fast like if it is a program logging in.</source>
          <target state="translated">인증 협상의 최대 시간 (밀리 초)입니다. 클라이언트가이 시간 내에 로그인에 실패하면 연결이 종료됩니다. 기본값은 2 분입니다. 꽤 긴 시간이지만 로그인하는 프로그램처럼 클라이언트가 빠르면 낮출 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4eb54965303d76ed44f2699d6c6c107cb1d43611" translate="yes" xml:space="preserve">
          <source>Maximum time in milliseconds for the first part of the ssh session setup, the hello message exchange. Defaults to 30000 ms (30 seconds). If the client fails to send the first message within this time, the connection is closed.</source>
          <target state="translated">ssh 세션 설정의 첫 번째 부분 인 hello 메시지 교환에 대한 최대 시간 (밀리 초)입니다. 기본값은 30000ms (30 초)입니다. 클라이언트가이 시간 내에 첫 번째 메시지를 보내지 못하면 연결이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="5ed8876370f72890efa02c30deff24e537f34e66" translate="yes" xml:space="preserve">
          <source>Maximum time, in milliseconds, that the application is allowed to run. After the specified time, the application terminates automatically.</source>
          <target state="translated">애플리케이션이 실행되는 최대 시간 (밀리 초)입니다. 지정된 시간이 지나면 응용 프로그램이 자동으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="03a8609c95b88388f510edabb0f8dfa6fd3c54d0" translate="yes" xml:space="preserve">
          <source>May raise exception &lt;code&gt;error:low_entropy&lt;/code&gt; in case the random generator failed due to lack of secure &quot;randomness&quot;.</source>
          <target state="translated">보안 &quot;무작위성&quot;부족으로 인해 임의 생성기가 실패한 경우 예외 &lt;code&gt;error:low_entropy&lt;/code&gt; 가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23a279860156131505cf4f4d1f1bcaf4decacdec" translate="yes" xml:space="preserve">
          <source>May raise exception &lt;code&gt;error:notsup&lt;/code&gt; in case engine functionality is not supported by the underlying OpenSSL implementation.</source>
          <target state="translated">기본 OpenSSL 구현에서 엔진 기능을 지원하지 않는 경우 예외 &lt;code&gt;error:notsup&lt;/code&gt; 이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29a2af3a497fa54b209d1a74654b69dca236080c" translate="yes" xml:space="preserve">
          <source>May raise exception &lt;code&gt;error:notsup&lt;/code&gt; in case the chosen &lt;code&gt;Type&lt;/code&gt; is not supported by the underlying libcrypto implementation.</source>
          <target state="translated">선택한 &lt;code&gt;Type&lt;/code&gt; 이 기본 libcrypto 구현에서 지원되지 않는 경우 예외 &lt;code&gt;error:notsup&lt;/code&gt; 이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c8a55a92a5e0b80769310573f2935c9817cc3ed" translate="yes" xml:space="preserve">
          <source>May raise exception &lt;code&gt;error:notsup&lt;/code&gt; in case there is no engine support in the underlying OpenSSL implementation.</source>
          <target state="translated">기본 OpenSSL 구현에서 엔진 지원이없는 경우 예외 &lt;code&gt;error:notsup&lt;/code&gt; 이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d10e5666a4350d3a74dfeb650aa6e788de3d69f" translate="yes" xml:space="preserve">
          <source>May throw exception &lt;code&gt;low_entropy&lt;/code&gt; in case the random generator failed due to lack of secure &quot;randomness&quot;.</source>
          <target state="translated">안전한 &quot;무작위성&quot;부족으로 인해 랜덤 생성기가 실패한 경우 &lt;code&gt;low_entropy&lt;/code&gt; 예외 가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="646deba2eac00f7933fd5cbe027cc187e501a16e" translate="yes" xml:space="preserve">
          <source>May throw exception &lt;code&gt;notsup&lt;/code&gt; in case the chosen &lt;code&gt;Type&lt;/code&gt; is not supported by the underlying OpenSSL implementation.</source>
          <target state="translated">선택한 &lt;code&gt;Type&lt;/code&gt; 이 기본 OpenSSL 구현에서 지원되지 않는 경우 예외를 발생 &lt;code&gt;notsup&lt;/code&gt; 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de3eaac3de9e89ba4866a20aae2b339c0035484b" translate="yes" xml:space="preserve">
          <source>May throw exception notsup in case there is no engine support in the underlying OpenSSL implementation.</source>
          <target state="translated">기본 OpenSSL 구현에서 엔진이 지원되지 않는 경우 예외를 발생시키지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74a5150721719a6283a47c9cfb72e9bc9bff9f71" translate="yes" xml:space="preserve">
          <source>Md5 is a popular choice as a hash function, but it is not secure enough to be validated. Try to use sha instead wherever possible.</source>
          <target state="translated">Md5는 해시 함수로 널리 사용되지만 유효성을 검증 할만큼 안전하지는 않습니다. 가능하면 항상 sha를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d947c601b953e99cf3b99eb1e54ea06bc8cd7368" translate="yes" xml:space="preserve">
          <source>Meaning that you don't care if the reply is acknowledged or not.</source>
          <target state="translated">응답이 승인되었는지 여부는 상관하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c14c209285d898ae15b996256e223eda68f99fc" translate="yes" xml:space="preserve">
          <source>Meaning that you want an acknowledgement &lt;strong&gt;sometime&lt;/strong&gt;. When the acknowledgement eventually is received, the handle_trans_ack/4 callback function will be invoked with the ack_data() as one of its arguments. ack_data() may be any Erlang term.</source>
          <target state="translated">당신이 &lt;strong&gt;언젠가&lt;/strong&gt; 인정을 원한다는 것을 의미합니다 . 승인이 최종적으로 수신되면, handle_trans_ack / 4 콜백 함수가 인수 중 하나로 ack_data ()를 사용하여 호출됩니다. ack_data ()는 Erlang 용어 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a6a0ba0223a6ae2bd06adfc210359ea6aab4c09" translate="yes" xml:space="preserve">
          <source>Meaning that you want an immediate acknowledgement when the other part receives this transaction reply. When the acknowledgement eventually is received, the handle_trans_ack/4 callback function will be invoked with the ack_data() as one of its arguments. ack_data() may be any Erlang term.</source>
          <target state="translated">다른 부분이이 트랜잭션 응답을 수신하면 즉시 승인을 원한다는 의미입니다. 승인이 최종적으로 수신되면, handle_trans_ack / 4 콜백 함수가 인수 중 하나로 ack_data ()를 사용하여 호출됩니다. ack_data ()는 Erlang 용어 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f498b784a10213b6d5daff6b5f8c433f00ab391" translate="yes" xml:space="preserve">
          <source>Meaningful atoms, not specified above, are the ssl option names.</source>
          <target state="translated">위에 지정되지 않은 의미있는 원자는 ssl 옵션 이름입니다.</target>
        </trans-unit>
        <trans-unit id="04a146d79042e9bb8204c7ef5d4ff5347d02259b" translate="yes" xml:space="preserve">
          <source>Meas results</source>
          <target state="translated">측정 결과</target>
        </trans-unit>
        <trans-unit id="04424ff7354672ffdc45258bd640170e14936cbb" translate="yes" xml:space="preserve">
          <source>Measure Elapsed Time</source>
          <target state="translated">경과 시간 측정</target>
        </trans-unit>
        <trans-unit id="f049a7f84606387c1f036369b9d17679bb303ce9" translate="yes" xml:space="preserve">
          <source>Measure scheduler utilization</source>
          <target state="translated">스케줄러 활용도 측정</target>
        </trans-unit>
        <trans-unit id="7f45833b5c1ba2a9c0ab4a66fccfcb8ca4b25b6f" translate="yes" xml:space="preserve">
          <source>Measure utilization for normal and dirty-cpu schedulers during &lt;code&gt;Seconds&lt;/code&gt; seconds, and then return the result.</source>
          <target state="translated">&lt;code&gt;Seconds&lt;/code&gt; 초 동안 정상 및 더티 CPU 스케줄러의 사용률을 측정 한 다음 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="abb7023ce648e065965ab27aefcab22defabb76e" translate="yes" xml:space="preserve">
          <source>Measurement tool directory name</source>
          <target state="translated">측정 도구 디렉토리 이름</target>
        </trans-unit>
        <trans-unit id="28e896074d31c2da6938ce8b9dd8662ed8369129" translate="yes" xml:space="preserve">
          <source>Measurement(s)</source>
          <target state="translated">Measurement(s)</target>
        </trans-unit>
        <trans-unit id="d404968ea90b07f16774ce75c7978d6ff60962f2" translate="yes" xml:space="preserve">
          <source>Medium</source>
          <target state="translated">Medium</target>
        </trans-unit>
        <trans-unit id="d4bb05883bb5a243cfcc4f9296f5649fd60af7f8" translate="yes" xml:space="preserve">
          <source>Medium mathematical space</source>
          <target state="translated">중간 수학적 공간</target>
        </trans-unit>
        <trans-unit id="a66ec7d3e2375014d1ffe12adf1704c1f323a128" translate="yes" xml:space="preserve">
          <source>Meetei_Mayek</source>
          <target state="translated">Meetei_Mayek</target>
        </trans-unit>
        <trans-unit id="291fdbd8f605e558c302e6b671f37cb0a11631da" translate="yes" xml:space="preserve">
          <source>Megaco and peer protocols are complementary in nature and entirely compatible within the same system. At a system level, Megaco allows for</source>
          <target state="translated">Megaco 및 피어 프로토콜은 본질적으로 보완 적이며 동일한 시스템 내에서 완전히 호환됩니다. 시스템 수준에서 Megaco는</target>
        </trans-unit>
        <trans-unit id="efb29db4c9a5b8efca98c20c485c0a71a7d66580" translate="yes" xml:space="preserve">
          <source>Megaco encoder behaviour.</source>
          <target state="translated">Megaco 엔코더 동작.</target>
        </trans-unit>
        <trans-unit id="1ab0d5d513da1a6a7bc7432ddbc64c528b364f30" translate="yes" xml:space="preserve">
          <source>Megaco erlang dist compress behaviour.</source>
          <target state="translated">Megaco erlang dist 압축 동작.</target>
        </trans-unit>
        <trans-unit id="220d827864f1e91dd8d479ee473263ef26b35de7" translate="yes" xml:space="preserve">
          <source>Megaco is a (master/slave) protocol for control of gateway functions at the edge of the packet network. Examples of this is IP-PSTN trunking gateways and analog line gateways. The main function of Megaco is to allow gateway decomposition into a call agent (call control) part (known as Media Gateway Controller, MGC) - master, and an gateway interface part (known as Media Gateway, MG) - slave. The MG has no call control knowledge and only handle making the connections and simple configurations.</source>
          <target state="translated">Megaco는 패킷 네트워크의 가장자리에서 게이트웨이 기능을 제어하기위한 (마스터 / 슬레이브) 프로토콜입니다. IP-PSTN 트렁킹 게이트웨이 및 아날로그 회선 게이트웨이가 이에 해당합니다. Megaco의 주요 기능은 게이트웨이 에이전트를 콜 에이전트 (통화 제어) 파트 (MGC라고도 함)-마스터 및 게이트웨이 인터페이스 파트 (매체 게이트웨이, MG)-슬레이브로 분해하는 것입니다. MG는 통화 제어 지식이 없으며 연결 및 간단한 구성 만 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5bffe747cacf35d066423541d229ecb49cc0807e" translate="yes" xml:space="preserve">
          <source>Megaco message transformation utility.</source>
          <target state="translated">Megaco 메시지 변환 유틸리티.</target>
        </trans-unit>
        <trans-unit id="20993d68c2198a64d2417ac2d87867b327655a8f" translate="yes" xml:space="preserve">
          <source>Megaco transport behaviour.</source>
          <target state="translated">Megaco 운송 행동.</target>
        </trans-unit>
        <trans-unit id="ca3af7e570175c4264bb51201980217711f1fa1b" translate="yes" xml:space="preserve">
          <source>Megaco version 3 encoding config</source>
          <target state="translated">Megaco 버전 3 인코딩 구성</target>
        </trans-unit>
        <trans-unit id="234c693a674eb5d604a026611a56402135865454" translate="yes" xml:space="preserve">
          <source>Megaco/H.248 is a protocol for control of elements in a physically decomposed multimedia gateway, enabling separation of call control from media conversion. A Media Gateway Controller (MGC) controls one or more Media Gateways (MG).</source>
          <target state="translated">Megaco / H.248은 물리적으로 분해 된 멀티미디어 게이트웨이에서 요소를 제어하기위한 프로토콜로, 미디어 제어에서 통화 제어를 분리 할 수 ​​있습니다. MGC (Media Gateway Controller)는 하나 이상의 MG (Media Gateway)를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="cda9df8ada294fa5717dc7c1fc6e9914b12f8c01" translate="yes" xml:space="preserve">
          <source>Megaco/H.248 version 1 (RFC3525) updated according to Implementors Guide version 10-13.</source>
          <target state="translated">Megaco / H.248 버전 1 (RFC3525)은 Implementors Guide 버전 10-13에 따라 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="8857c1ee6501c5ec79a912365370d5a6a0f747fc" translate="yes" xml:space="preserve">
          <source>Megaco/H.248 version 2 as defined by draft-ietf-megaco-h248v2-04 updated according to Implementors Guide version 10-13.</source>
          <target state="translated">draft-ietf-megaco-h248v2-04로 정의 된 Megaco / H.248 버전 2는 구현 자 안내서 버전 10-13에 따라 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="56058cc7ccdad804c1b70639153c0e96607997f8" translate="yes" xml:space="preserve">
          <source>Megaco/H.248 version 3 as defined by ITU H.248.1 (09/2005).</source>
          <target state="translated">ITU H.248.1 (09/2005)에 의해 정의 된 Megaco / H.248 버전 3</target>
        </trans-unit>
        <trans-unit id="88287078a76b16499606b0eda112892d7c56b922" translate="yes" xml:space="preserve">
          <source>Membership of an object instance in an MIB view is determined by the following algorithm:</source>
          <target state="translated">MIB 뷰에서 객체 인스턴스의 멤버 자격은 다음 알고리즘에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="e0f688c59c802fa1afb6c57fd1cbe6c48ddef5de" translate="yes" xml:space="preserve">
          <source>Membership view is not transitive. If &lt;code&gt;node1&lt;/code&gt; is not directly connected to &lt;code&gt;node2&lt;/code&gt;, they will not see each other groups. But if both are connected to &lt;code&gt;node3&lt;/code&gt;, &lt;code&gt;node3&lt;/code&gt; will have the full view.</source>
          <target state="translated">멤버십보기는 전이되지 않습니다. 경우 &lt;code&gt;node1&lt;/code&gt; 직접 연결되지 않은 &lt;code&gt;node2&lt;/code&gt; , 그들은 서로 다른 그룹을 볼 수 없습니다. 모두에 연결되어있는 경우 그러나 &lt;code&gt;node3&lt;/code&gt; , &lt;code&gt;node3&lt;/code&gt; 전체보기를해야합니다.</target>
        </trans-unit>
        <trans-unit id="30350d30f29ea3b12a784ca65d59e4a1c44504dd" translate="yes" xml:space="preserve">
          <source>Memory allocated must be explicitly freed with a corresponding call to &lt;code&gt;&lt;a href=&quot;#driver_free&quot;&gt;driver_free&lt;/a&gt;&lt;/code&gt; (unless otherwise stated).</source>
          <target state="translated">별도의 언급이없는 한 , 할당 된 메모리는 &lt;code&gt;&lt;a href=&quot;#driver_free&quot;&gt;driver_free&lt;/a&gt;&lt;/code&gt; 에 대한 해당 호출로 명시 적으로 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8a7c93315d7681329a5299a5f17af5e70109e588" translate="yes" xml:space="preserve">
          <source>Memory allocation failed</source>
          <target state="translated">메모리 할당 실패</target>
        </trans-unit>
        <trans-unit id="e570bc956a4274803362d894f6047828e5106277" translate="yes" xml:space="preserve">
          <source>Memory allocation functions.</source>
          <target state="translated">메모리 할당 기능.</target>
        </trans-unit>
        <trans-unit id="2684c7e649eb37683099bd99b0ac2e74ac12a361" translate="yes" xml:space="preserve">
          <source>Memory allocation information. Equivalent to &lt;code&gt;erlang:memory/0&lt;/code&gt;.</source>
          <target state="translated">메모리 할당 정보. 등가 &lt;code&gt;erlang:memory/0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="158a065a76be26284f9a9200a508e6ac49bd3965" translate="yes" xml:space="preserve">
          <source>Memory allocation information. Equivalent to &lt;code&gt;erlang:memory/1&lt;/code&gt;.</source>
          <target state="translated">메모리 할당 정보. 등가 &lt;code&gt;erlang:memory/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="909293f836f9e597ec4a004c609be9b42bb7b1af" translate="yes" xml:space="preserve">
          <source>Memory allocator system flags have the following syntax: &lt;code&gt;+M&amp;lt;S&amp;gt;&amp;lt;P&amp;gt; &amp;lt;V&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; is a letter identifying a subsystem, &lt;code&gt;&amp;lt;P&amp;gt;&lt;/code&gt; is a parameter, and &lt;code&gt;&amp;lt;V&amp;gt;&lt;/code&gt; is the value to use. The flags can be passed to the Erlang emulator (&lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;) as command-line arguments.</source>
          <target state="translated">메모리 할당 자 시스템 플래그의 구문은 &lt;code&gt;+M&amp;lt;S&amp;gt;&amp;lt;P&amp;gt; &amp;lt;V&amp;gt;&lt;/code&gt; . 여기서 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 는 하위 시스템을 식별하는 문자이고 &lt;code&gt;&amp;lt;P&amp;gt;&lt;/code&gt; 는 매개 변수이며 &lt;code&gt;&amp;lt;V&amp;gt;&lt;/code&gt; 는 사용할 값입니다. 플래그는 명령 행 인수로 Erlang 에뮬레이터 ( &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; )에 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8dd2eade140452aa8bdce3e4ed57281be8adbbab" translate="yes" xml:space="preserve">
          <source>Memory allocator-specific flags. For more information, see &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메모리 할당 자 특정 플래그. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fdb6e5cf15d341e3aa96990976dacd306d089ec3" translate="yes" xml:space="preserve">
          <source>Memory consumption, system limits</source>
          <target state="translated">메모리 소비, 시스템 제한</target>
        </trans-unit>
        <trans-unit id="7527155aa02588eea7da969db8693cc9ca0cf4a9" translate="yes" xml:space="preserve">
          <source>Memory types:</source>
          <target state="translated">메모리 유형 :</target>
        </trans-unit>
        <trans-unit id="1ac17298e965f8785571301bd292200f1c1741e9" translate="yes" xml:space="preserve">
          <source>Memory use for the loaded code, in bytes.</source>
          <target state="translated">로드 된 코드의 메모리 사용 (바이트)</target>
        </trans-unit>
        <trans-unit id="4dd0c06f98123356440797c194d0014596cf4b1f" translate="yes" xml:space="preserve">
          <source>Memory use for the old code, if any.</source>
          <target state="translated">이전 코드에 메모리 사용 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="9b8e4f1f3e91d8f85eeac155da9f5cb32aabeb22" translate="yes" xml:space="preserve">
          <source>Memory use for the old code, in bytes.</source>
          <target state="translated">이전 코드의 메모리 사용량 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="2bbb76271791ef8b2e5ac70d40f275e4232f3424" translate="yes" xml:space="preserve">
          <source>Mende_Kikakui</source>
          <target state="translated">Mende_Kikakui</target>
        </trans-unit>
        <trans-unit id="119e8b7d23fe6df42b1eaf06cf2b4d696139b05c" translate="yes" xml:space="preserve">
          <source>Merge the specified PLTs to create the initial PLT. This requires that the PLTs are disjoint (that is, do not have any module appearing in more than one PLT). The PLTs are created in the usual way:</source>
          <target state="translated">지정된 PLT를 병합하여 초기 PLT를 작성하십시오. 이를 위해서는 PLT가 분리되어 있어야합니다 (즉, 둘 이상의 PLT에 모듈이 나타나지 않음). PLT는 일반적인 방법으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="e3929df6cd4273ec09922ee67ab9ff5aa6b66122" translate="yes" xml:space="preserve">
          <source>Merges source code files and syntax trees to a single syntax tree. This is a file-reading front end to &lt;code&gt;merge_sources/3&lt;/code&gt;. &lt;code&gt;Name&lt;/code&gt; specifies the name of the resulting module - not the name of the output file. &lt;code&gt;Sources&lt;/code&gt; is a list of syntax trees and/or lists of &quot;source code form&quot; syntax trees, each entry representing a module definition. &lt;code&gt;Files&lt;/code&gt; is a list of file names and/or module names of source modules to be read and included. All the input modules must be distinctly named.</source>
          <target state="translated">소스 코드 파일과 구문 트리를 단일 구문 트리로 병합합니다. 이것은 &lt;code&gt;merge_sources/3&lt;/code&gt; 의 파일 읽기 프론트 엔드 입니다. &lt;code&gt;Name&lt;/code&gt; 은 결과 파일의 이름이 아니라 결과 모듈의 이름을 지정합니다. &lt;code&gt;Sources&lt;/code&gt; 는 구문 트리 목록 및 / 또는 &quot;소스 코드 형식&quot;구문 트리 목록으로, 각 항목은 모듈 정의를 나타냅니다. &lt;code&gt;Files&lt;/code&gt; 은 읽고 포함 할 소스 모듈의 파일 이름 및 / 또는 모듈 이름 목록입니다. 모든 입력 모듈의 이름이 명확해야합니다.</target>
        </trans-unit>
        <trans-unit id="914f8309af3ca6cfa2e83d7e921c466e8a40172d" translate="yes" xml:space="preserve">
          <source>Merges source code files to a single file. &lt;code&gt;Name&lt;/code&gt; specifies the name of the resulting module - not the name of the output file. &lt;code&gt;Files&lt;/code&gt; is a list of file names and/or module names of source modules to be read and merged (see &lt;code&gt;merge_files/4&lt;/code&gt; for details). All the input modules must be distinctly named.</source>
          <target state="translated">소스 코드 파일을 단일 파일로 병합합니다. &lt;code&gt;Name&lt;/code&gt; 은 결과 파일의 이름이 아니라 결과 모듈의 이름을 지정합니다. &lt;code&gt;Files&lt;/code&gt; 은 읽고 병합 할 소스 모듈의 파일 이름 및 / 또는 모듈 이름 목록입니다 (자세한 내용은 &lt;code&gt;merge_files/4&lt;/code&gt; 참조). 모든 입력 모듈의 이름을 명확하게 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="61ef0f26ed0f675da05d869af4a295417123a3d7" translate="yes" xml:space="preserve">
          <source>Merges syntax trees to a single syntax tree. This is the main code merging &quot;engine&quot;. &lt;code&gt;Name&lt;/code&gt; specifies the name of the resulting module. &lt;code&gt;Sources&lt;/code&gt; is a list of syntax trees of type &lt;code&gt;form_list&lt;/code&gt; and/or lists of &quot;source code form&quot; syntax trees, each entry representing a module definition. All the input modules must be distinctly named.</source>
          <target state="translated">구문 트리를 단일 구문 트리로 병합합니다. &quot;엔진&quot;을 병합하는 주요 코드입니다. &lt;code&gt;Name&lt;/code&gt; 은 결과 모듈의 이름을 지정합니다. &lt;code&gt;Sources&lt;/code&gt; 는 &lt;code&gt;form_list&lt;/code&gt; 유형의 구문 트리 목록 및 / 또는 &quot;소스 코드 양식&quot;구문 트리 목록으로, 각 항목은 모듈 정의를 나타냅니다. 모든 입력 모듈의 이름을 명확하게 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d2a293b058966cf02ea5fa803aede107a277d1e" translate="yes" xml:space="preserve">
          <source>Merges terms on files. Each input file is assumed to be sorted.</source>
          <target state="translated">파일에 용어를 병합합니다. 각 입력 파일은 정렬 된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ca627cc38a16c0db5470a1230525775bd4b5efc4" translate="yes" xml:space="preserve">
          <source>Merges tuples on files. Each input file is assumed to be sorted on key(s).</source>
          <target state="translated">파일에서 튜플을 병합합니다. 각 입력 파일은 키별로 정렬되어 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6351ca1bc7f6afb34d654f76c66afcef185ec40c" translate="yes" xml:space="preserve">
          <source>Merges two dictionaries, &lt;code&gt;Dict1&lt;/code&gt; and &lt;code&gt;Dict2&lt;/code&gt;, to create a new dictionary. All the &lt;code&gt;Key&lt;/code&gt;-&lt;code&gt;Value&lt;/code&gt; pairs from both dictionaries are included in the new dictionary. If a key occurs in both dictionaries, &lt;code&gt;Fun&lt;/code&gt; is called with the key and both values to return a new value. &lt;code&gt;merge&lt;/code&gt; can be defined as follows, but is faster:</source>
          <target state="translated">&lt;code&gt;Dict1&lt;/code&gt; 과 &lt;code&gt;Dict2&lt;/code&gt; 두 사전을 병합 하여 새 사전을 만듭니다. 두 사전의 모든 &lt;code&gt;Key&lt;/code&gt; - &lt;code&gt;Value&lt;/code&gt; 쌍이 새 사전에 포함됩니다. 두 사전에서 키가 발생 하면 키와 두 값으로 &lt;code&gt;Fun&lt;/code&gt; 을 호출하여 새 값을 반환합니다. &lt;code&gt;merge&lt;/code&gt; 은 다음과 같이 정의 할 수 있지만 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="d26d2ded712b884fedeee08ada284ef051b3b38a" translate="yes" xml:space="preserve">
          <source>Merges two dictionaries, &lt;code&gt;Orddict1&lt;/code&gt; and &lt;code&gt;Orddict2&lt;/code&gt;, to create a new dictionary. All the &lt;code&gt;Key&lt;/code&gt;-&lt;code&gt;Value&lt;/code&gt; pairs from both dictionaries are included in the new dictionary. If a key occurs in both dictionaries, &lt;code&gt;Fun&lt;/code&gt; is called with the key and both values to return a new value. &lt;code&gt;merge/3&lt;/code&gt; can be defined as follows, but is faster:</source>
          <target state="translated">두 개의 사전 인 &lt;code&gt;Orddict1&lt;/code&gt; 및 &lt;code&gt;Orddict2&lt;/code&gt; 를 병합 하여 새 사전을 작성하십시오. 두 사전의 모든 &lt;code&gt;Key&lt;/code&gt; - &lt;code&gt;Value&lt;/code&gt; 쌍이 새 사전에 포함됩니다. 두 사전에서 키가 발생 하면 키와 두 값으로 &lt;code&gt;Fun&lt;/code&gt; 을 호출하여 새 값을 반환합니다. &lt;code&gt;merge/3&lt;/code&gt; 는 다음과 같이 정의 할 수 있지만 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ec7e01625093b63d2959063dd1a662a878ea5c0e" translate="yes" xml:space="preserve">
          <source>Merges two maps into a single map &lt;code&gt;Map3&lt;/code&gt;. If two keys exist in both maps, the value in &lt;code&gt;Map1&lt;/code&gt; is superseded by the value in &lt;code&gt;Map2&lt;/code&gt;.</source>
          <target state="translated">두 개의 맵을 단일 맵 &lt;code&gt;Map3&lt;/code&gt; 에 병합합니다 . 두 맵에 두 개의 키가 있으면 &lt;code&gt;Map1&lt;/code&gt; 의 값이 &lt;code&gt;Map2&lt;/code&gt; 의 값으로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="6735763c165e3286d74b4273c933f33e3f5ec752" translate="yes" xml:space="preserve">
          <source>Merging different versions of the schema table does not always require the cookies to be the same. If the storage type of the schema table is &lt;code&gt;disc_copies&lt;/code&gt;, the cookie is immutable, and all other &lt;code&gt;db_nodes&lt;/code&gt; must have the same cookie. When the schema is stored as type &lt;code&gt;ram_copies&lt;/code&gt;, its cookie can be replaced with a cookie from another node (&lt;code&gt;ram_copies&lt;/code&gt; or &lt;code&gt;disc_copies&lt;/code&gt;). The cookie replacement (during merge of the schema table definition) is performed each time a RAM node connects to another node.</source>
          <target state="translated">다른 버전의 스키마 테이블을 병합 할 때 항상 쿠키가 동일 할 필요는 없습니다. 스키마 테이블의 스토리지 유형이 &lt;code&gt;disc_copies&lt;/code&gt; 인 경우 쿠키는 변경할 수 &lt;code&gt;db_nodes&lt;/code&gt; 다른 모든 db_node 는 동일한 쿠키를 가져야합니다. 스키마가 &lt;code&gt;ram_copies&lt;/code&gt; 유형으로 저장 되면 해당 쿠키는 다른 노드 ( &lt;code&gt;ram_copies&lt;/code&gt; 또는 &lt;code&gt;disc_copies&lt;/code&gt; ) 의 쿠키로 대체 될 수 있습니다 . RAM 노드가 다른 노드에 연결될 때마다 쿠키 교체 (스키마 테이블 정의 병합 중)가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="41b5e66fa06088a4b56fe703bb862a285dff3ab5" translate="yes" xml:space="preserve">
          <source>Merl can only parse a fragment of text if it follows the basic syntactical rules of Erlang. In most places, a normal Erlang variable can be used as metavariable, for example:</source>
          <target state="translated">Merl은 Erlang의 기본 구문 규칙을 따르는 경우에만 텍스트 조각을 구문 분석 할 수 있습니다. 대부분의 경우 일반적인 Erlang 변수를 다음과 같이 메타 변수로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fad43e700acf724fbc03a57e905d1e33999d5a95" translate="yes" xml:space="preserve">
          <source>Meroitic_Cursive</source>
          <target state="translated">Meroitic_Cursive</target>
        </trans-unit>
        <trans-unit id="16256e81ed15ae584494444b4607752969d09a87" translate="yes" xml:space="preserve">
          <source>Meroitic_Hieroglyphs</source>
          <target state="translated">Meroitic_Hieroglyphs</target>
        </trans-unit>
        <trans-unit id="0d77c6f0a440925729997c58732eb390465bad0a" translate="yes" xml:space="preserve">
          <source>Message Processing and Dispatch module for the SNMP agent</source>
          <target state="translated">SNMP 에이전트의 메시지 처리 및 디스패치 모듈</target>
        </trans-unit>
        <trans-unit id="834a3b3a12d9955dd19120adc9ef57807900ee6d" translate="yes" xml:space="preserve">
          <source>Message Processing and Dispatch module for the SNMP manager</source>
          <target state="translated">SNMP 관리자 용 메시지 처리 및 디스패치 모듈</target>
        </trans-unit>
        <trans-unit id="02371a390b8862f0fb277fe1f69a5aec05d5978c" translate="yes" xml:space="preserve">
          <source>Message Queue Length</source>
          <target state="translated">메시지 큐 길이</target>
        </trans-unit>
        <trans-unit id="dfb051fb0d4beb2aa1f14d08e0e4d39de55bd026" translate="yes" xml:space="preserve">
          <source>Message Transformation</source>
          <target state="translated">메시지 변환</target>
        </trans-unit>
        <trans-unit id="79df93b3eaeb4cccfb42f6840f1b4d449096cc8e" translate="yes" xml:space="preserve">
          <source>Message authentication code</source>
          <target state="translated">메시지 인증 코드</target>
        </trans-unit>
        <trans-unit id="c6d065b029fde73824807bcb7a4f88522968466d" translate="yes" xml:space="preserve">
          <source>Message errors are detected remotely on the other side of the protocol. And you probably don't want to reply to it, but it may indicate that you have outstanding transactions that not will get any response (request -&amp;gt; reply; reply -&amp;gt; ack).</source>
          <target state="translated">프로토콜의 다른 쪽에서 원격으로 메시지 오류가 감지됩니다. 그리고 답장하고 싶지 않을 수도 있지만 응답이없는 미결 거래가 있음을 나타낼 수 있습니다 (요청-&amp;gt; 답장; 답장-&amp;gt; ack).</target>
        </trans-unit>
        <trans-unit id="19842f503704a8912fdf5969e80cd251a7b79c11" translate="yes" xml:space="preserve">
          <source>Message package file</source>
          <target state="translated">메시지 패키지 파일</target>
        </trans-unit>
        <trans-unit id="03bf9094ba44ce8eb3a756071ecbb6363ddf4c1c" translate="yes" xml:space="preserve">
          <source>Message reception detects 5001, 5004, 5005, 5008, 5009, 5010, 5011, 5014, 5015, and 5017 errors. It ignores 5013 errors at the admonition of sections 3 and 4.1.</source>
          <target state="translated">메시지 수신은 5001, 5004, 5005, 5008, 5009, 5010, 5011, 5014, 5015 및 5017 오류를 감지합니다. 섹션 3과 4.1의 권고에서 5013 오류를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="2297ecf9967e2341ba11a1ac6137bfeff96d6f16" translate="yes" xml:space="preserve">
          <source>Message records</source>
          <target state="translated">메시지 기록</target>
        </trans-unit>
        <trans-unit id="31deece58687e26fd50c8809af9d97cfb48aa92a" translate="yes" xml:space="preserve">
          <source>Message sending is asynchronous and safe, the message is guaranteed to eventually reach the recipient, provided that the recipient exists.</source>
          <target state="translated">메시지 전송은 비동기적이고 안전하며, 수신자가 존재하는 경우 메시지는 결국 수신자에게 도달 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7c63e918af7eff798c82c0e88aefb50d97f2578" translate="yes" xml:space="preserve">
          <source>Message size at which SCTP fragmentation occurs</source>
          <target state="translated">SCTP 조각화가 발생하는 메시지 크기</target>
        </trans-unit>
        <trans-unit id="b750d8fad975d29078dc3817706283c95d7080b2" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_call&quot;&gt; call&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_from&quot;&gt; return_from&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_call&quot;&gt; call&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_from&quot;&gt; return_from&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2284766da0e8eee8510824e820fbb024eeb2e85a" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_call&quot;&gt; call&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_from&quot;&gt; return_from&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_to&quot;&gt; return_to&lt;/a&gt;&lt;/code&gt;. Or rather, the absence of.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_call&quot;&gt; call&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_from&quot;&gt; return_from&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_to&quot;&gt; return_to&lt;/a&gt;&lt;/code&gt; . 또는 오히려 부재.</target>
        </trans-unit>
        <trans-unit id="7bf49996d9fb115e00764acfda8430d93e84eb42" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_from&quot;&gt;return_from&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_from&quot;&gt;return_from&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac347e4302154cf539a13312237b96cc114cdfa9" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_call&quot;&gt;call&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_from&quot;&gt;return_from&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_to&quot;&gt;return_to&lt;/a&gt;&lt;/code&gt;. Or rather, the absence of.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_from&quot;&gt;return_from&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_to&quot;&gt;return_to&lt;/a&gt;&lt;/code&gt; . 또는 오히려.</target>
        </trans-unit>
        <trans-unit id="d55b10e6602cdac34aaaf0e3cdd87ae3eba9e3c4" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_minor_start&quot;&gt; gc_minor_start&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_max_heap_size&quot;&gt; gc_max_heap_size&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_minor_end&quot;&gt; gc_minor_end&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_minor_start&quot;&gt; gc_minor_start&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_max_heap_size&quot;&gt; gc_max_heap_size&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_minor_end&quot;&gt; gc_minor_end&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="861b1c2d1e66807add82f45f362fb827341c6bc5" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_minor_start&quot;&gt;gc_minor_start&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_max_heap_size&quot;&gt;gc_max_heap_size&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_minor_end&quot;&gt;gc_minor_end&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_minor_start&quot;&gt;gc_minor_start&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_max_heap_size&quot;&gt;gc_max_heap_size&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_minor_end&quot;&gt;gc_minor_end&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0e7108836afb16e38c44c652a4e62d909356441" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_exiting_proc&quot;&gt; in_exiting&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_exiting_proc&quot;&gt; out_exiting&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_exited_proc&quot;&gt; out_exited&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_exiting_proc&quot;&gt; in_exiting&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_exiting_proc&quot;&gt; out_exiting&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_exited_proc&quot;&gt; out_exited&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64249446e1241b8f9d4c261cdb93987c31f20de2" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_exiting_proc&quot;&gt;in_exiting&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_exiting_proc&quot;&gt;out_exiting&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_exited_proc&quot;&gt;out_exited&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_exiting_proc&quot;&gt;in_exiting&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_exiting_proc&quot;&gt;out_exiting&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_exited_proc&quot;&gt;out_exited&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbd3f651bc7160b6a497c91cf5402436859647af" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_port&quot;&gt; in&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_port&quot;&gt; out&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_port&quot;&gt; in&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_port&quot;&gt; out&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d456b159601bfe4ba88f4b3b670553e61afb6b4d" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_port&quot;&gt;in&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_port&quot;&gt;out&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_port&quot;&gt;in&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_port&quot;&gt;out&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="416881b9d5540cfe9873bf0ebffec446874cdd3d" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_proc&quot;&gt; in&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_proc&quot;&gt; out&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_proc&quot;&gt; in&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_proc&quot;&gt; out&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="498dd804ab57af76daece1cf044904cff1eb753f" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_proc&quot;&gt;in&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_proc&quot;&gt;out&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_proc&quot;&gt;in&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_proc&quot;&gt;out&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68930d265f4db910af9eba0b28146a7b7899c6bc" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_open&quot;&gt; open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_closed&quot;&gt; closed&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_register&quot;&gt; register&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unregister&quot;&gt; unregister&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_linked&quot;&gt; getting_linked&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_unlinked&quot;&gt; getting_unlinked&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_open&quot;&gt; open&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_closed&quot;&gt; closed&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_register&quot;&gt; register&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unregister&quot;&gt; unregister&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_linked&quot;&gt; getting_linked&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_unlinked&quot;&gt; getting_unlinked&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fef22350b8b577df133e3cb6cedbf6dc60aaa87c" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_closed&quot;&gt;closed&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_register&quot;&gt;register&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unregister&quot;&gt;unregister&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_linked&quot;&gt;getting_linked&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_unlinked&quot;&gt;getting_unlinked&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_closed&quot;&gt;closed&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_register&quot;&gt;register&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unregister&quot;&gt;unregister&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_linked&quot;&gt;getting_linked&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_unlinked&quot;&gt;getting_unlinked&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6512f01d3c770be7226241736812f0d69fa4514" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_receive&quot;&gt; 'receive'&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_receive&quot;&gt; 'receive'&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d00e4b40aebde71fd90f9fddfebc8612e44ddb8f" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_receive&quot;&gt;'receive'&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_receive&quot;&gt;'receive'&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c491f5bf100ca2885d053c861f62400fb713ad9" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_to&quot;&gt; return_to&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_to&quot;&gt; return_to&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef5f53652270bb984920cbfaaa3925022a3b6e1c" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_to&quot;&gt;return_to&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_to&quot;&gt;return_to&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa13bce159f2aec6f79783cc4440e2c288e0bab0" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_send&quot;&gt; send&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_send_to_non_existing_process&quot;&gt; send_to_non_existing_process&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_send&quot;&gt; send&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_send_to_non_existing_process&quot;&gt; send_to_non_existing_process&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7160c31113f5c016d9d063ac1996aecb61589a8a" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_send&quot;&gt;send&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_send_to_non_existing_process&quot;&gt;send_to_non_existing_process&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_send&quot;&gt;send&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_send_to_non_existing_process&quot;&gt;send_to_non_existing_process&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53366600ccc75a4be0906a21afaa84e288188f3d" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_spawn&quot;&gt; spawn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_spawned&quot;&gt; spawned&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_exit&quot;&gt; exit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_register&quot;&gt; register&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unregister&quot;&gt; unregister&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_link&quot;&gt; link&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unlink&quot;&gt; unlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_linked&quot;&gt; getting_linked&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_unlinked&quot;&gt; getting_unlinked&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_spawn&quot;&gt; spawn&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_spawned&quot;&gt; spawned&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_exit&quot;&gt; exit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_register&quot;&gt; register&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unregister&quot;&gt; unregister&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_link&quot;&gt; link&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unlink&quot;&gt; unlink&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_linked&quot;&gt; getting_linked&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_unlinked&quot;&gt; getting_unlinked&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ff3b1c2d91914176c2ace60ad5ed8c3dbe8dfb0" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_spawn&quot;&gt;spawn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_spawned&quot;&gt;spawned&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_register&quot;&gt;register&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unregister&quot;&gt;unregister&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_link&quot;&gt;link&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_linked&quot;&gt;getting_linked&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_unlinked&quot;&gt;getting_unlinked&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_spawn&quot;&gt;spawn&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_spawned&quot;&gt;spawned&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_register&quot;&gt;register&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unregister&quot;&gt;unregister&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_linked&quot;&gt;getting_linked&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_unlinked&quot;&gt;getting_unlinked&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c83c1bde9d4d8aa8318863a5d51aa34ce5bfc795" translate="yes" xml:space="preserve">
          <source>Messages are delivered on a per line basis. Each line (delimited by the OS-dependent newline sequence) is delivered in a single message. The message data format is &lt;code&gt;{Flag, Line}&lt;/code&gt;, where &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;eol&lt;/code&gt; or &lt;code&gt;noeol&lt;/code&gt;, and &lt;code&gt;Line&lt;/code&gt; is the data delivered (without the newline sequence).</source>
          <target state="translated">메시지는 라인 단위로 전달됩니다. 각 라인 (OS 종속적 인 개행 시퀀스로 구분)은 단일 메시지로 전달됩니다. 메시지 데이터 형식은 &lt;code&gt;{Flag, Line}&lt;/code&gt; 이며, 여기서 &lt;code&gt;Flag&lt;/code&gt; 는 &lt;code&gt;eol&lt;/code&gt; 또는 &lt;code&gt;noeol&lt;/code&gt; 이며 &lt;code&gt;Line&lt;/code&gt; 은 개행 시퀀스없이 전달 된 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="4efc9f43ab150329eedfc4f946099f0a5f3094d9" translate="yes" xml:space="preserve">
          <source>Messages are preceded by their length, sent in &lt;code&gt;N&lt;/code&gt; bytes, with the most significant byte first. The valid values for &lt;code&gt;N&lt;/code&gt; are 1, 2, and 4.</source>
          <target state="translated">메시지의 길이는 &lt;code&gt;N&lt;/code&gt; 바이트 단위로 전송되며 가장 중요한 바이트가 먼저 표시됩니다. &lt;code&gt;N&lt;/code&gt; 의 유효한 값 은 1, 2 및 4입니다.</target>
        </trans-unit>
        <trans-unit id="6b07457b9a14b5fa6fa1cbfe7c24fba2d20941a5" translate="yes" xml:space="preserve">
          <source>Messages are sent to this process in the format &lt;code&gt;{http, ReplyInfo}&lt;/code&gt;.</source>
          <target state="translated">메시지는 &lt;code&gt;{http, ReplyInfo}&lt;/code&gt; 형식으로이 프로세스로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="dea0176313f64667ac747bcda6d934ed85bcd005" translate="yes" xml:space="preserve">
          <source>Messages between Erlang processes are simply valid Erlang terms. That is, they can be lists, tuples, integers, atoms, pids, and so on.</source>
          <target state="translated">Erlang 프로세스 간의 메시지는 단순히 유효한 Erlang 용어입니다. 즉, 목록, 튜플, 정수, 원자, pid 등이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43e3fbb1d87e293b330ad523caa73111b3400f23" translate="yes" xml:space="preserve">
          <source>Messages can become a part of the process heap at different times. This depends on how the process is configured. We can configure the behaviour of each process using &lt;code&gt;process_flag(message_queue_data, off_heap | on_heap)&lt;/code&gt; or we can set a default for all processes at start using the option &lt;code&gt;+hmqd&lt;/code&gt;.</source>
          <target state="translated">메시지는 다른 시간에 프로세스 힙의 일부가 될 수 있습니다. 이것은 프로세스가 구성되는 방법에 따라 다릅니다. &lt;code&gt;process_flag(message_queue_data, off_heap | on_heap)&lt;/code&gt; 사용하여 각 프로세스의 동작을 구성 하거나 &lt;code&gt;+hmqd&lt;/code&gt; 옵션을 사용하여 시작시 모든 프로세스의 기본값을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ba3a1c108d58aee0ff81fd9ec2d1208708c9bdb" translate="yes" xml:space="preserve">
          <source>Messages encoded before the connection has been set up may still use the &lt;code&gt;SEND&lt;/code&gt; control message. However, once a &lt;code&gt;SEND_SENDER&lt;/code&gt; or &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; control message has been sent, no more &lt;code&gt;SEND&lt;/code&gt; control messages will be sent in the same direction on the connection.</source>
          <target state="translated">연결이 설정되기 전에 인코딩 된 메시지는 여전히 &lt;code&gt;SEND&lt;/code&gt; 제어 메시지를 사용할 수 있습니다 . 그러나 &lt;code&gt;SEND_SENDER&lt;/code&gt; 또는 &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; 제어 메시지가 전송되면 연결에서 동일한 방향으로 더 이상 &lt;code&gt;SEND&lt;/code&gt; 제어 메시지가 전송 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="21f2cc5097a001d22180191c6222e6d580784485" translate="yes" xml:space="preserve">
          <source>Messages encoded before the connection has been set up may still use the &lt;code&gt;SEND_TT&lt;/code&gt; control message. However, once a &lt;code&gt;SEND_SENDER&lt;/code&gt; or &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; control message has been sent, no more &lt;code&gt;SEND_TT&lt;/code&gt; control messages will be sent in the same direction on the connection.</source>
          <target state="translated">연결이 설정되기 전에 인코딩 된 메시지는 여전히 &lt;code&gt;SEND_TT&lt;/code&gt; 제어 메시지를 사용할 수 있습니다 . 그러나 &lt;code&gt;SEND_SENDER&lt;/code&gt; 또는 &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; 제어 메시지가 전송되면 연결에서 동일한 방향으로 더 이상 &lt;code&gt;SEND_TT&lt;/code&gt; 제어 메시지가 전송 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a9a00bffcae348db8ab4ea736b2a2912ab5091c8" translate="yes" xml:space="preserve">
          <source>Messages encoded before the connection has been set up may still use the non-PAYLOAD variant. However, once a PAYLOAD control message has been sent, no more non-PAYLOAD control messages will be sent in the same direction on the connection.</source>
          <target state="translated">연결이 설정되기 전에 인코딩 된 메시지는 여전히 비 PAYLOAD 변형을 사용할 수 있습니다. 그러나 PAYLOAD 제어 메시지가 전송되면 더 이상 비 PAYLOAD 제어 메시지가 연결에서 동일한 방향으로 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b450d9a68961ebef8efd8c7dece1b02f8d8dab97" translate="yes" xml:space="preserve">
          <source>Messages received from the operating system results in an user defined callback function being called. This function can do whatever filtering and formatting is necessary and then deploy any type of logging suitable for the user's application.</source>
          <target state="translated">운영 체제에서 수신 한 메시지는 사용자 정의 콜백 함수가 호출됩니다. 이 기능은 필요한 필터링 및 형식 지정을 수행 한 다음 사용자 응용 프로그램에 적합한 모든 유형의 로깅을 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d76ced0d32a80d8214bb32cc24e01e1631f869fe" translate="yes" xml:space="preserve">
          <source>Messages sent between Erlang nodes can sometimes be quite large. Since OTP-22 it is possible to split large messages into smaller fragments in order to allow smaller messages to be interleaved between larges messages. It is only the &lt;code&gt;message&lt;/code&gt; part of each &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;distributed message&lt;/a&gt;&lt;/code&gt; that may be split using fragmentation. Therefore it is recommended to use the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#new-ctrlmessages-for-erlang-otp-22&quot;&gt; PAYLOAD control messages&lt;/a&gt;&lt;/code&gt; introduced in OTP-22.</source>
          <target state="translated">Erlang 노드간에 전송되는 메시지는 때때로 상당히 클 수 있습니다. OTP-22 이후 큰 메시지간에 작은 메시지를 인터리브 할 수 있도록 큰 메시지를 작은 조각으로 분할 할 수 있습니다. 조각화를 사용하여 분할 할 수있는 것은 각 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;distributed message&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;message&lt;/code&gt; 부분 일뿐 입니다. 따라서 OTP-22에 도입 된 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#new-ctrlmessages-for-erlang-otp-22&quot;&gt; PAYLOAD control messages&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="83ae0fa23c0d7748fed32601f2608880147c1ffa" translate="yes" xml:space="preserve">
          <source>Messages that include a &lt;code&gt;WantReply&lt;/code&gt; expect the channel handling process to call &lt;code&gt;&lt;a href=&quot;ssh_connection#reply_request-4&quot;&gt; ssh_connection:reply_request/4&lt;/a&gt;&lt;/code&gt; with the boolean value of &lt;code&gt;WantReply&lt;/code&gt; as the second argument.</source>
          <target state="translated">&lt;code&gt;WantReply&lt;/code&gt; 를 포함하는 메시지 는 채널 처리 프로세스가 두 번째 인수로 &lt;code&gt;WantReply&lt;/code&gt; 의 부울 값을 사용하여 &lt;code&gt;&lt;a href=&quot;ssh_connection#reply_request-4&quot;&gt; ssh_connection:reply_request/4&lt;/a&gt;&lt;/code&gt; 를 호출 할 것으로 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="7a53365e992adfd42db65c7720bf07ff4ac1814b" translate="yes" xml:space="preserve">
          <source>Messing up for subsequent test cases:</source>
          <target state="translated">후속 테스트 사례에 대한 혼란 :</target>
        </trans-unit>
        <trans-unit id="30041e23a0f72a119313b16f9b3d4df540137e77" translate="yes" xml:space="preserve">
          <source>Meta-tracing traces all processes and does not care about the process trace flags set by &lt;code&gt;erlang:trace/3&lt;/code&gt;, the trace flags are instead fixed to &lt;code&gt;[call, timestamp]&lt;/code&gt;.</source>
          <target state="translated">메타 추적은 모든 프로세스를 추적하고 &lt;code&gt;erlang:trace/3&lt;/code&gt; 에 의해 설정된 프로세스 추적 플래그를 신경 쓰지 않고 추적 플래그는 대신 &lt;code&gt;[call, timestamp]&lt;/code&gt; 고정됩니다 .</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="1d674c23267ff3e893a9e1474fed16ac7f558c49" translate="yes" xml:space="preserve">
          <source>Metadata associated with one specific log event is given as the last parameter to the log macro or Logger API function when the event is issued. For example:</source>
          <target state="translated">하나의 특정 로그 이벤트와 연관된 메타 데이터는 이벤트가 발행 될 때 로그 매크로 또는 로거 API 함수에 대한 마지막 매개 변수로 제공됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="885e65968ef7efdba81656ad741bbd6682841ebf" translate="yes" xml:space="preserve">
          <source>Metadata contains additional data associated with a log message. Logger inserts some metadata fields by default, and the client can add custom metadata in two different ways:</source>
          <target state="translated">메타 데이터에는 로그 메시지와 관련된 추가 데이터가 포함됩니다. 로거는 기본적으로 일부 메타 데이터 필드를 삽입하며 클라이언트는 두 가지 방법으로 사용자 정의 메타 데이터를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1e44a13044d8e9cd06618d7ce5207e1fbeec00f" translate="yes" xml:space="preserve">
          <source>Metadata for the log event.</source>
          <target state="translated">로그 이벤트의 메타 데이터.</target>
        </trans-unit>
        <trans-unit id="4342240162e294c2bc03db17fdee5ddbc87876d8" translate="yes" xml:space="preserve">
          <source>Metaprogramming in Erlang.</source>
          <target state="translated">Erlang의 메타 프로그래밍.</target>
        </trans-unit>
        <trans-unit id="87ced016c5bb1aba95f8f208a0c630b0abd89fd8" translate="yes" xml:space="preserve">
          <source>Metaprogramming in Erlang. Merl is a more user friendly interface to the &lt;code&gt;erl_syntax&lt;/code&gt; module, making it easy both to build new ASTs from scratch and to match and decompose existing ASTs. For details that are outside the scope of Merl itself, please see the documentation of &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang의 메타 프로그래밍. Merl은 &lt;code&gt;erl_syntax&lt;/code&gt; 모듈 에 대한 사용자 친화적 인 인터페이스로, 새로운 AST를 처음부터 새로 작성하고 기존 AST를 일치시키고 분해 할 수 있습니다. Merl 자체의 범위를 벗어난 세부 사항은 &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc7e0e02c16756d9acee15cd9d7a7473daeb068d" translate="yes" xml:space="preserve">
          <source>Miao</source>
          <target state="translated">Miao</target>
        </trans-unit>
        <trans-unit id="1ead8ccfae61c22af5dea71102bcf319bd3b337a" translate="yes" xml:space="preserve">
          <source>Micka&amp;euml;l R&amp;eacute;mond mickael.remond@process-one.net</source>
          <target state="translated">Micka&amp;euml;l R&amp;eacute;mond mickael.remond@process-one.net</target>
        </trans-unit>
        <trans-unit id="e3161feceeebbf2efa94b967c31c3a533e827d4e" translate="yes" xml:space="preserve">
          <source>Micka&amp;euml;l R&amp;eacute;mond mickael.remond@process-one.net Richard Carlsson carlsson.richard@gmail.com</source>
          <target state="translated">Micka&amp;euml;l R&amp;eacute;mond mickael.remond@process-one.net Richard Carlsson carlsson.richard@gmail.com</target>
        </trans-unit>
        <trans-unit id="c51b97dfe72702f7a4db88668d6bbc27ffd18957" translate="yes" xml:space="preserve">
          <source>Microseconds</source>
          <target state="translated">Microseconds</target>
        </trans-unit>
        <trans-unit id="ad4d37efa374335ef5074617d100776dbcc4796b" translate="yes" xml:space="preserve">
          <source>Microsofts Windows SDK version 8.1 (corresponding to VC++ 12.0 and Visual Studio 2013). You'll find it here:</source>
          <target state="translated">Microsoft의 Windows SDK 버전 8.1 (VC ++ 12.0 및 Visual Studio 2013에 해당) 여기에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24a147f8ecf3e3ea0e4e34c911ef22efe0ff4546" translate="yes" xml:space="preserve">
          <source>Microstate accounting can be used to measure how much time the Erlang runtime system spends doing various tasks. It is designed to be as lightweight as possible, but some overhead exists when this is enabled. Microstate accounting is meant to be a profiling tool to help finding performance bottlenecks. To &lt;code&gt;start&lt;/code&gt;/&lt;code&gt;stop&lt;/code&gt;/&lt;code&gt;reset&lt;/code&gt; microstate accounting, use system flag &lt;code&gt;&lt;a href=&quot;#system_flag_microstate_accounting&quot;&gt; microstate_accounting&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Microstate 회계는 Erlang 런타임 시스템이 다양한 작업을 수행하는 데 소비하는 시간을 측정하는 데 사용할 수 있습니다. 가능한 한 경량으로 설계되었지만이 기능을 사용하면 약간의 오버 헤드가 발생합니다. Microstate 회계는 성능 병목 현상을 찾는 데 도움이되는 프로파일 링 도구입니다. microstate 계정 을 &lt;code&gt;start&lt;/code&gt; / &lt;code&gt;stop&lt;/code&gt; / &lt;code&gt;reset&lt;/code&gt; 하려면 시스템 플래그 &lt;code&gt;&lt;a href=&quot;#system_flag_microstate_accounting&quot;&gt; microstate_accounting&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5fe50fa08740afc3a20f9d3d442ba75955fee423" translate="yes" xml:space="preserve">
          <source>Microstate accounting can be used to measure how much time the Erlang runtime system spends doing various tasks. It is designed to be as lightweight as possible, but some overhead exists when this is enabled. Microstate accounting is meant to be a profiling tool to help finding performance bottlenecks. To &lt;code&gt;start&lt;/code&gt;/&lt;code&gt;stop&lt;/code&gt;/&lt;code&gt;reset&lt;/code&gt; microstate accounting, use system flag &lt;code&gt;&lt;a href=&quot;#system_flag_microstate_accounting&quot;&gt;microstate_accounting&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">마이크로 스테이트 계정은 Erlang 런타임 시스템이 다양한 작업을 수행하는 데 걸리는 시간을 측정하는 데 사용할 수 있습니다. 가능한 한 경량으로 설계되었지만이 기능을 사용하면 약간의 오버 헤드가 있습니다. 마이크로 스테이트 회계는 성능 병목 현상을 찾는 데 도움이되는 프로파일 링 도구입니다. 마이크로 스테이트 계정 을 &lt;code&gt;start&lt;/code&gt; / &lt;code&gt;stop&lt;/code&gt; / &lt;code&gt;reset&lt;/code&gt; 하려면 시스템 플래그 &lt;code&gt;&lt;a href=&quot;#system_flag_microstate_accounting&quot;&gt;microstate_accounting&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5bc93878c3ba17340102ebf0f740f8c3302add0b" translate="yes" xml:space="preserve">
          <source>Milliseconds</source>
          <target state="translated">Milliseconds</target>
        </trans-unit>
        <trans-unit id="fb85391c2c8505ba20e51e3d8c6b33571699f58c" translate="yes" xml:space="preserve">
          <source>Min detail level deactivates tracing of calls to &lt;code&gt;et:trace_me/4,5&lt;/code&gt;</source>
          <target state="translated">최소 세부 사항 레벨은 &lt;code&gt;et:trace_me/4,5&lt;/code&gt; 에 대한 호출 추적을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="68daf61d5874aaae0cf757e3faf2f324a6515679" translate="yes" xml:space="preserve">
          <source>MinBinVHeapSize :: integer() &amp;gt;= 1}</source>
          <target state="translated">MinBinVHeapSize :: 정수 ()&amp;gt; = 1}</target>
        </trans-unit>
        <trans-unit id="4fed7661f4d42301d68ec8563e610bd36ddbbfe8" translate="yes" xml:space="preserve">
          <source>MinHeapSize :: integer() &amp;gt;= 1}</source>
          <target state="translated">MinHeapSize :: 정수 ()&amp;gt; = 1}</target>
        </trans-unit>
        <trans-unit id="d75c514e27a03879ebcd47b9d5dc273dcad02469" translate="yes" xml:space="preserve">
          <source>Minimal Example</source>
          <target state="translated">최소 예</target>
        </trans-unit>
        <trans-unit id="f25a88ac3eb732d57dc4ba0d3e990489173fb9aa" translate="yes" xml:space="preserve">
          <source>Minimizes the representation of all entries in the list. This is equivalent to &lt;code&gt;[property(P) || P &amp;lt;- ListIn]&lt;/code&gt;.</source>
          <target state="translated">목록에있는 모든 항목의 표현을 최소화합니다. 이것은 &lt;code&gt;[property(P) || P &amp;lt;- ListIn]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="baa687b4835396d9bf1f310f2267dc46209a08e5" translate="yes" xml:space="preserve">
          <source>Miscellaneous API functions</source>
          <target state="translated">기타 API 기능</target>
        </trans-unit>
        <trans-unit id="32e23d465d0629b84d76e5f09fb507ede0cb1461" translate="yes" xml:space="preserve">
          <source>Miscellaneous flags:</source>
          <target state="translated">기타 플래그 :</target>
        </trans-unit>
        <trans-unit id="3e70a7515b00e7c226a15edab218fd1f4dd573e0" translate="yes" xml:space="preserve">
          <source>Miscellaneous utility functions to be used when implementing Erlang web server API modules.</source>
          <target state="translated">Erlang 웹 서버 API 모듈을 구현할 때 사용되는 기타 유틸리티 기능.</target>
        </trans-unit>
        <trans-unit id="e28720b55817fffaed736aa55d8047afa4cf1137" translate="yes" xml:space="preserve">
          <source>Missing permission for reading the file or searching one of the parent directories.</source>
          <target state="translated">파일을 읽거나 상위 디렉토리 중 하나를 검색 할 수있는 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7aa38c37efdf79a5acef9cef7e555976f20e2ad9" translate="yes" xml:space="preserve">
          <source>Missing permission for reading the file, or for searching one of the parent directories.</source>
          <target state="translated">파일을 읽거나 상위 디렉토리 중 하나를 검색하기위한 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9efd7c6d83c7981adb874ec7297e295c58042b1f" translate="yes" xml:space="preserve">
          <source>Missing permission for the directory or one of its parents.</source>
          <target state="translated">디렉토리 또는 상위 디렉토리 중 하나에 대한 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3baa40bad1885eea32466c0be3b003163935955e" translate="yes" xml:space="preserve">
          <source>Missing permission for the file or one of its parents.</source>
          <target state="translated">파일 또는 상위 파일 중 하나에 대한 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="da94f56d96d2d085bea8dd51d423535445ba4d6f" translate="yes" xml:space="preserve">
          <source>Missing permission for writing the file or searching one of the parent directories.</source>
          <target state="translated">파일을 쓰거나 상위 디렉토리 중 하나를 검색 할 수있는 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="061e8bb20890cbf13271d93b5804b980c9a0f90b" translate="yes" xml:space="preserve">
          <source>Missing read or write permissions for the parent directories of &lt;code&gt;Existing&lt;/code&gt; or &lt;code&gt;New&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Existing&lt;/code&gt; 또는 &lt;code&gt;New&lt;/code&gt; 의 상위 디렉토리에 대한 읽기 또는 쓰기 권한이 누락되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6b9b56e3be8c9130a50f7b4b55f58db626553ba0" translate="yes" xml:space="preserve">
          <source>Missing read or write permissions for the parent directories of &lt;code&gt;Source&lt;/code&gt; or &lt;code&gt;Destination&lt;/code&gt;. On some platforms, this error is given if either &lt;code&gt;Source&lt;/code&gt; or &lt;code&gt;Destination&lt;/code&gt; is open.</source>
          <target state="translated">&lt;code&gt;Source&lt;/code&gt; 또는 &lt;code&gt;Destination&lt;/code&gt; 의 상위 디렉토리에 대한 읽기 또는 쓰기 권한이 없습니다 . 일부 플랫폼에서 &lt;code&gt;Source&lt;/code&gt; 또는 &lt;code&gt;Destination&lt;/code&gt; 이 열려 있으면이 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="28336423496ccaf52c7936f6b41a6f9ad88604eb" translate="yes" xml:space="preserve">
          <source>Missing read permission for one of the parents of the current directory.</source>
          <target state="translated">현재 디렉토리의 부모 중 하나에 대한 읽기 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d5005e02795d55eb02a3f6a112157b99bce1e935" translate="yes" xml:space="preserve">
          <source>Missing search or write permissions for &lt;code&gt;Dir&lt;/code&gt; or one of its parent directories.</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 또는 상위 디렉토리 중 하나에 대한 검색 또는 쓰기 권한이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="dc45e80a5b65727123e0ebc0703fe14768293b68" translate="yes" xml:space="preserve">
          <source>Missing search or write permissions for the parent directories of &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 의 상위 디렉토리에 대한 검색 또는 쓰기 권한이 누락되었습니다 .</target>
        </trans-unit>
        <trans-unit id="dc1c55c040e5f0948f15231f73c916f3526d9f6e" translate="yes" xml:space="preserve">
          <source>Missing search permission for one of the parent directories of the file.</source>
          <target state="translated">파일의 상위 디렉토리 중 하나에 대한 검색 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3450bbc34d200da9fb5b92b5c6f6571a71324a0a" translate="yes" xml:space="preserve">
          <source>Mnesia As Authentication Database</source>
          <target state="translated">인증 데이터베이스로서의 Mnesia</target>
        </trans-unit>
        <trans-unit id="3e14767dc1dedaea0f193b494b8754d578aec896" translate="yes" xml:space="preserve">
          <source>Mnesia contains the following features that combine to produce a fault-tolerant, distributed DBMS written in Erlang:</source>
          <target state="translated">Mnesia에는 Erlang으로 작성된 내결함성 분산 DBMS를 생성하기 위해 결합 된 다음 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d270fde8f4afa30deacf2e5ac64258dc95380f4" translate="yes" xml:space="preserve">
          <source>Mnesia forwards calls to the following functions:</source>
          <target state="translated">Mnesia는 다음 기능으로 전화를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="e89dea5925db30b38ca5a4a01818590924fb2279" translate="yes" xml:space="preserve">
          <source>Mnesia has no special counter records. However, records of the form &lt;code&gt;{Tab, Key, Integer}&lt;/code&gt; can be used as (possibly disc-resident) counters when &lt;code&gt;Tab&lt;/code&gt; is a &lt;code&gt;set&lt;/code&gt;. This function updates a counter with a positive or negative number. However, counters can never become less than zero. There are two significant differences between this function and the action of first reading the record, performing the arithmetics, and then writing the record:</source>
          <target state="translated">Mnesia에는 특별한 카운터 기록이 없습니다. 그러나 형태의 기록 &lt;code&gt;{Tab, Key, Integer}&lt;/code&gt; 때와 (아마도 디스크 상주) 카운터를 사용할 수있는 &lt;code&gt;Tab&lt;/code&gt; A는 &lt;code&gt;set&lt;/code&gt; . 이 기능은 양수 또는 음수로 카운터를 업데이트합니다. 그러나 카운터는 절대로 0보다 작아 질 수 없습니다. 이 함수와 먼저 레코드를 읽고, 산술을 수행 한 다음, 레코드를 작성하는 동작에는 두 가지 중요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a2c5988b423c05d899728a690476666f426fc19" translate="yes" xml:space="preserve">
          <source>Mnesia is a multiuser distributed DBMS specially made for industrial telecommunications applications written in Erlang, which is also the intended target language. Mnesia tries to address all the data management issues required for typical telecommunications systems. It has a number of features that are not normally found in traditional databases.</source>
          <target state="translated">Mnesia는 Erlang으로 작성된 산업용 통신 응용 프로그램을 위해 특별히 제작 된 다중 사용자 분산 DBMS이며, 대상 언어이기도합니다. Mnesia는 일반적인 통신 시스템에 필요한 모든 데이터 관리 문제를 해결하려고합니다. 기존 데이터베이스에는 일반적으로 제공되지 않는 많은 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0af7e030b61efa3af7bcba4659fb088190690f3" translate="yes" xml:space="preserve">
          <source>Mnesia is also interesting because of its tight coupling to Erlang, thus almost turning Erlang into a database programming language. This has many benefits, the foremost is that the impedance mismatch between the data format used by the DBMS and the data format used by the programming language, which is used to manipulate the data, completely disappears.</source>
          <target state="translated">Mnesia는 Erlang과의 긴밀한 결합으로 인해 Erlang을 데이터베이스 프로그래밍 언어로 거의 바꾸어 놓기 때문에 흥미 롭습니다. 이는 많은 이점이 있으며, 무엇보다도 DBMS에서 사용하는 데이터 형식과 데이터를 조작하는 데 사용되는 프로그래밍 언어에서 사용하는 데이터 형식 사이의 임피던스 불일치가 완전히 사라집니다.</target>
        </trans-unit>
        <trans-unit id="44aa259738f2f02d017fee9119158e2bcbe7c0c2" translate="yes" xml:space="preserve">
          <source>Mnesia is designed with the typical data management problems of telecommunications applications in mind. This sets Mnesia apart from most other DBMS. Hence Mnesia combines many concepts found in traditional databases such as transactions and queries with concepts found in data management systems for telecommunications applications, for example:</source>
          <target state="translated">Mnesia는 통신 애플리케이션의 일반적인 데이터 관리 문제를 염두에두고 설계되었습니다. 이것은 대부분의 다른 DBMS와는 별도로 Mnesia를 설정합니다. 따라서 Mnesia는 트랜잭션 및 쿼리와 같은 기존 데이터베이스에서 볼 수있는 많은 개념을 통신 응용 프로그램의 데이터 관리 시스템에서 볼 수있는 개념과 결합합니다.</target>
        </trans-unit>
        <trans-unit id="df09d370f13b24dc32d72bd352185aa6d3460032" translate="yes" xml:space="preserve">
          <source>Mnesia is implemented in, and tightly connected to Erlang. It provides the functionality that is necessary for the implementation of fault tolerant telecommunications systems.</source>
          <target state="translated">Mnesia는 Erlang에 구현되어 있으며 Erlang과 밀접하게 연결되어 있습니다. 내결함성 통신 시스템의 구현에 필요한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fc6fa382209f2c0fc7fcb32177c787306e164f05" translate="yes" xml:space="preserve">
          <source>Mnesia is not as appropriate with the following types of applications:</source>
          <target state="translated">Mnesia는 다음 유형의 응용 프로그램에 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="845e3498f5ba4596f8fba48d33cc6a74bac4d6f0" translate="yes" xml:space="preserve">
          <source>Mnesia is started on a node. &lt;code&gt;Node&lt;/code&gt; is the node name. By default this event is ignored.</source>
          <target state="translated">Mnesia는 노드에서 시작됩니다. &lt;code&gt;Node&lt;/code&gt; 는 노드 이름입니다. 기본적으로이 이벤트는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b3e1fa53e8464658bfcdc7fbdecb69fa1444e78e" translate="yes" xml:space="preserve">
          <source>Mnesia is stopped on a node. &lt;code&gt;Node&lt;/code&gt; is the node name. By default this event is ignored.</source>
          <target state="translated">Mnesia는 노드에서 중지됩니다. &lt;code&gt;Node&lt;/code&gt; 는 노드 이름입니다. 기본적으로이 이벤트는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7c1dcaece45ef92fbe42e06c5252abce132af739" translate="yes" xml:space="preserve">
          <source>Mnesia reads the following application configuration parameters:</source>
          <target state="translated">Mnesia는 다음 애플리케이션 구성 매개 변수를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="0726b2991715ca8d77350ad4cbf6cf39dd4a573d" translate="yes" xml:space="preserve">
          <source>Mnesia startup is asynchronous. The function call &lt;code&gt;mnesia:start()&lt;/code&gt; returns the atom &lt;code&gt;ok&lt;/code&gt; and then starts to initialize the different tables. Depending on the size of the database, this can take some time, and the application programmer must wait for the tables that the application needs before they can be used. This is achieved by using the function &lt;code&gt;mnesia:wait_for_tables/2&lt;/code&gt;.</source>
          <target state="translated">Mnesia 시작은 비동기식입니다. &lt;code&gt;mnesia:start()&lt;/code&gt; 함수 호출 은 원자 &lt;code&gt;ok&lt;/code&gt; 를 반환 한 다음 다른 테이블을 초기화하기 시작합니다. 데이터베이스의 크기에 따라 시간이 걸릴 수 있으며 애플리케이션 프로그래머는 애플리케이션에 필요한 테이블이 사용되기 전에 기다려야합니다. 이는 &lt;code&gt;mnesia:wait_for_tables/2&lt;/code&gt; 함수를 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="6d914dda751476720c28b61ae3bd0ff8b42cfeb7" translate="yes" xml:space="preserve">
          <source>Mode = &lt;code&gt;active | passive&lt;/code&gt;</source>
          <target state="translated">모드 = &lt;code&gt;active | passive&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99f50e7814fad5179000cd91fa4e8ee4f72c44ef" translate="yes" xml:space="preserve">
          <source>Mode for running multiple independent test sessions in parallel with central control and configuration</source>
          <target state="translated">중앙 제어 및 구성과 동시에 여러 개의 독립적 인 테스트 세션을 실행하기위한 모드</target>
        </trans-unit>
        <trans-unit id="2620d89dab477718fe6a6ecadb48be52562f1585" translate="yes" xml:space="preserve">
          <source>Modi</source>
          <target state="translated">Modi</target>
        </trans-unit>
        <trans-unit id="6de26bd1e99650e13b775d6b454183fe80a5672b" translate="yes" xml:space="preserve">
          <source>Modification of a value causes it to not be representable internally in the VM. For example, incrementation of a counter past the largest integer representable.</source>
          <target state="translated">값을 수정하면 VM에서 내부적으로 표현할 수 없습니다. 예를 들어, 표현 가능한 가장 큰 정수를 지나는 카운터의 증분.</target>
        </trans-unit>
        <trans-unit id="347a94d0029aefe56171fcf91033436e5c682c85" translate="yes" xml:space="preserve">
          <source>Modified timing affects the following:</source>
          <target state="translated">수정 된 타이밍은 다음에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="bad23ea5529c0f8c6c8d290e83637676c692c2dd" translate="yes" xml:space="preserve">
          <source>Modifier letter</source>
          <target state="translated">수정 자 편지</target>
        </trans-unit>
        <trans-unit id="253879158d55c56d709e1481da82674291cad63a" translate="yes" xml:space="preserve">
          <source>Modifier symbol</source>
          <target state="translated">수정 자 기호</target>
        </trans-unit>
        <trans-unit id="a0cfb5739548a4dc910c1db16690c1ef42b6dcf6" translate="yes" xml:space="preserve">
          <source>Modifies the &lt;code&gt;erl_parse&lt;/code&gt; tree &lt;code&gt;Abstr&lt;/code&gt; by applying &lt;code&gt;Fun&lt;/code&gt; on each collection of annotations of the nodes of the &lt;code&gt;erl_parse&lt;/code&gt; tree, while at the same time updating an accumulator. The first call to &lt;code&gt;Fun&lt;/code&gt; has &lt;code&gt;AccIn&lt;/code&gt; as second argument, the returned accumulator &lt;code&gt;AccOut&lt;/code&gt; is passed to the next call, and so on. The modified &lt;code&gt;erl_parse&lt;/code&gt; tree and the final value of the accumulator are returned. The &lt;code&gt;erl_parse&lt;/code&gt; tree is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">수정합니다 &lt;code&gt;erl_parse&lt;/code&gt; 트리 &lt;code&gt;Abstr&lt;/code&gt; 적용하여 &lt;code&gt;Fun&lt;/code&gt; 의 노드의 주석을 각 컬렉션 &lt;code&gt;erl_parse&lt;/code&gt; 를 동시에 어큐뮬레이터를 업데이트하는 동안, 나무. &lt;code&gt;Fun&lt;/code&gt; 에 대한 첫 번째 호출 은 두 번째 인수로 &lt;code&gt;AccIn&lt;/code&gt; 을 가지며 , 반환 된 누산기 &lt;code&gt;AccOut&lt;/code&gt; 은 다음 호출로 전달됩니다. 수정 된 &lt;code&gt;erl_parse&lt;/code&gt; 트리와 누산기의 최종 값이 반환됩니다. &lt;code&gt;erl_parse&lt;/code&gt; 의 나무는 깊이 우선, 왼쪽에서 오른쪽 방식으로 이송됩니다.</target>
        </trans-unit>
        <trans-unit id="ada6b07489b4caa86b644d594e210d3d7df73a75" translate="yes" xml:space="preserve">
          <source>Modifies the &lt;code&gt;erl_parse&lt;/code&gt; tree &lt;code&gt;Abstr&lt;/code&gt; by applying &lt;code&gt;Fun&lt;/code&gt; on each collection of annotations of the nodes of the &lt;code&gt;erl_parse&lt;/code&gt; tree. The &lt;code&gt;erl_parse&lt;/code&gt; tree is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">수정합니다 &lt;code&gt;erl_parse&lt;/code&gt; 트리 &lt;code&gt;Abstr&lt;/code&gt; 적용하여 &lt;code&gt;Fun&lt;/code&gt; 의 노드의 주석을 각 컬렉션 &lt;code&gt;erl_parse&lt;/code&gt; 의 나무. &lt;code&gt;erl_parse&lt;/code&gt; 의 나무는 깊이 우선, 왼쪽에서 오른쪽 방식으로 이송됩니다.</target>
        </trans-unit>
        <trans-unit id="d6767e7b3024caf3c0392eb069c62606173a9f1a" translate="yes" xml:space="preserve">
          <source>Modifies the filename of the annotations Anno.</source>
          <target state="translated">주석 Anno의 파일 이름을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="f5817a19c5f89b9a4e372f141f435c1a42a9dd33" translate="yes" xml:space="preserve">
          <source>Modifies the generated marker of the annotations Anno.</source>
          <target state="translated">주석 Anno의 생성 된 마커를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="037defcfe58535f15797aebbd1fbb203e7cd9af8" translate="yes" xml:space="preserve">
          <source>Modifies the line of the annotations Anno.</source>
          <target state="translated">주석 Anno의 행을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="c6cc4351008b5ab2535c804b7cd295d8836544e6" translate="yes" xml:space="preserve">
          <source>Modifies the list of algorithms to use in the algorithm negotiation. The modifications are applied after the option &lt;code&gt;preferred_algorithms&lt;/code&gt; (if existing) is applied.</source>
          <target state="translated">알고리즘 협상에 사용할 알고리즘 목록을 수정합니다. &lt;code&gt;preferred_algorithms&lt;/code&gt; (존재하는 경우) 옵션이 적용된 후에 수정 사항이 적용 됩니다.</target>
        </trans-unit>
        <trans-unit id="c1311f97ce347997edad775a69d938fac98b1ab7" translate="yes" xml:space="preserve">
          <source>Modifies the location of the annotations Anno.</source>
          <target state="translated">주석 Anno의 위치를 ​​수정합니다.</target>
        </trans-unit>
        <trans-unit id="cf1b78ca3bb67cc73d9a5ef2e74df6aa835b463e" translate="yes" xml:space="preserve">
          <source>Modifies the record marker of the annotations Anno.</source>
          <target state="translated">주석 Anno의 레코드 마커를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="7eb7754f43a795536f0ab7aea723cfd8a2dcf954" translate="yes" xml:space="preserve">
          <source>Modifies the text of the annotations Anno.</source>
          <target state="translated">주석 Anno의 텍스트를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="fad6e92bd8f724516530123632d526536ce733e0" translate="yes" xml:space="preserve">
          <source>Modify PATH and other environment variables so that all these tools are runnable from a bash shell. Still standing in &lt;code&gt;$ERL_TOP&lt;/code&gt;, issue the following commands (for 32-bit Windows, remove the x64 from the first row and change &lt;code&gt;otp_win64_21&lt;/code&gt; to &lt;code&gt;otp_win32_21&lt;/code&gt; on the last row):</source>
          <target state="translated">PATH 및 기타 환경 변수를 수정하여 이러한 모든 도구를 bash 쉘에서 실행할 수 있도록하십시오. 여전히 &lt;code&gt;$ERL_TOP&lt;/code&gt; 서서 다음 명령을 실행하십시오 (32 비트 Windows의 경우 첫 번째 행에서 x64를 제거 하고 마지막 행에서 &lt;code&gt;otp_win64_21&lt;/code&gt; 을 &lt;code&gt;otp_win32_21&lt;/code&gt; 로 변경 하십시오 ).</target>
        </trans-unit>
        <trans-unit id="ba5f42ab3559a652255f5e966c07cfbd4d94e9fe" translate="yes" xml:space="preserve">
          <source>Modify PATH and other environment variables so that all these tools are runnable from a bash shell. Still standing in &lt;code&gt;$ERL_TOP&lt;/code&gt;, issue the following commands (for 32-bit Windows, remove the x64 from the first row and change &lt;code&gt;otp_win64_23&lt;/code&gt; to &lt;code&gt;otp_win32_23&lt;/code&gt; on the last row):</source>
          <target state="translated">이러한 모든 도구가 bash 쉘에서 실행될 수 있도록 PATH 및 기타 환경 변수를 수정하십시오. 여전히 &lt;code&gt;$ERL_TOP&lt;/code&gt; 서서 다음 명령을 실행합니다 (32 비트 Windows의 경우 첫 번째 행에서 x64를 제거 하고 마지막 행에서 &lt;code&gt;otp_win64_23&lt;/code&gt; 을 &lt;code&gt;otp_win32_23&lt;/code&gt; 으로 변경 ).</target>
        </trans-unit>
        <trans-unit id="12f926fde51df220b3a44737fd7a8d3f5f5cf650" translate="yes" xml:space="preserve">
          <source>Modify an entry.</source>
          <target state="translated">항목을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="10f726edf41c57d1e88f9e6b3584066a593e9aea" translate="yes" xml:space="preserve">
          <source>Modify the DN of an entry. &lt;code&gt;DeleteOldRDN&lt;/code&gt; indicates whether the current RDN should be removed from the attribute list after the after operation. &lt;code&gt;NewSupDN&lt;/code&gt; is the new parent that the RDN shall be moved to. If the old parent should remain as parent, &lt;code&gt;NewSupDN&lt;/code&gt; shall be &quot;&quot;.</source>
          <target state="translated">항목의 DN을 수정하십시오. &lt;code&gt;DeleteOldRDN&lt;/code&gt; 은 이후 작업 후 속성 목록에서 현재 RDN을 제거 해야하는지 여부를 나타냅니다. &lt;code&gt;NewSupDN&lt;/code&gt; 은 RDN이 이동 될 새로운 부모입니다. 이전 부모를 부모로 유지해야하는 경우 &lt;code&gt;NewSupDN&lt;/code&gt; 은 &quot;&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="1acf68e46d209b11d8d1dd169940e50cad8dd506" translate="yes" xml:space="preserve">
          <source>Modify the DN of an entry. &lt;code&gt;DeleteOldRDN&lt;/code&gt; indicates whether the current RDN should be removed from the attribute list after the operation. &lt;code&gt;NewSupDN&lt;/code&gt; is the new parent that the RDN shall be moved to. If the old parent should remain as parent, &lt;code&gt;NewSupDN&lt;/code&gt; shall be &quot;&quot;.</source>
          <target state="translated">항목의 DN을 수정합니다. &lt;code&gt;DeleteOldRDN&lt;/code&gt; 은 작업 후 현재 RDN을 속성 목록에서 제거 해야하는지 여부를 나타냅니다. &lt;code&gt;NewSupDN&lt;/code&gt; 은 RDN이 이동 될 새 상위입니다. 이전 상위가 상위로 유지되어야하는 경우 &lt;code&gt;NewSupDN&lt;/code&gt; 은 &quot;&quot;가됩니다.</target>
        </trans-unit>
        <trans-unit id="aaa722d609855294fcc06f9f555621df06ec84a5" translate="yes" xml:space="preserve">
          <source>Modify the default handler to only print errors and more severe log events to &quot;log/erlang.log&quot;, and add another handler to print all log events to &quot;log/debug.log&quot;.</source>
          <target state="translated">&quot;log / erlang.log&quot;에 오류 및 더 심각한 로그 이벤트 만 인쇄하도록 기본 핸들러를 수정하고 모든 로그 이벤트를 &quot;log / debug.log&quot;에 인쇄 할 다른 핸들러를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d3fd275091bd2e943ed17a3e09212992146dc33a" translate="yes" xml:space="preserve">
          <source>Modify the default handler to print each log event as a single line:</source>
          <target state="translated">기본 처리기를 수정하여 각 로그 이벤트를 한 줄로 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="dd1a86ac0a2c106289b6452634be890061d7e0ee" translate="yes" xml:space="preserve">
          <source>Modify the default handler to print the pid of the logging process for each log event:</source>
          <target state="translated">각 로그 이벤트에 대한 로깅 프로세스의 pid를 인쇄하도록 기본 핸들러를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="78a2b877311ab0e1542d92e5d0d77e8835127859" translate="yes" xml:space="preserve">
          <source>Modify the default handler to print to a file instead of &lt;code&gt;standard_io&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;standard_io&lt;/code&gt; 대신 파일로 인쇄하도록 기본 핸들러를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="60ff3ee60fb042d23c742fd31feed7fec7ed6a1c" translate="yes" xml:space="preserve">
          <source>Modify the password of a user.</source>
          <target state="translated">사용자의 비밀번호를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="78971b16f8399500c31431d1ca9618f6dee87669" translate="yes" xml:space="preserve">
          <source>Modify the password of a user. See &lt;code&gt;&lt;a href=&quot;#modify_password-4&quot;&gt;modify_password/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용자의 비밀번호를 수정하십시오. &lt;code&gt;&lt;a href=&quot;#modify_password-4&quot;&gt;modify_password/4&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51b459ec8aabe598314683815cd6576876569d8f" translate="yes" xml:space="preserve">
          <source>Modifying answers is the responsibility of the user in callbacks from diameter.</source>
          <target state="translated">응답을 수정하는 것은 직경에서 콜백 할 때 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="b8ff02892916ff59f7fbd4e617fccd01f6bca576" translate="yes" xml:space="preserve">
          <source>Module</source>
          <target state="translated">Module</target>
        </trans-unit>
        <trans-unit id="e38d402d9b28b267f7bbb774745d5b1326cac05a" translate="yes" xml:space="preserve">
          <source>Module :: module(),</source>
          <target state="translated">모듈 :: module (),</target>
        </trans-unit>
        <trans-unit id="e2422bff0b69502b127f4dbc4235fb67ea1f739d" translate="yes" xml:space="preserve">
          <source>Module ::= Atom</source>
          <target state="translated">모듈 :: = 원자</target>
        </trans-unit>
        <trans-unit id="7da910aa1163387303b43f2f30ab78aed84ec504" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;&lt;a href=&quot;ssh_client_key_api&quot;&gt;ssh_client_key_api&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모듈 &lt;code&gt;&lt;a href=&quot;ssh_client_key_api&quot;&gt;ssh_client_key_api&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="734c7672bf31a9ad24405d2c26dfc8c63ce96e2a" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;&lt;a href=&quot;ssh_server_key_api&quot;&gt;ssh_server_key_api&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모듈 &lt;code&gt;&lt;a href=&quot;ssh_server_key_api&quot;&gt;ssh_server_key_api&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5bda4d30c8d6fa83505f2d8e9d0cca830b01ddf" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;multitrace&lt;/code&gt; in directory &lt;code&gt;src&lt;/code&gt; of the Observer application provides a small tool with three possible trace settings. The trace messages are written to binary files, which can be formatted with function &lt;code&gt;multitrace:format/1,2&lt;/code&gt;:</source>
          <target state="translated">Observer 응용 프로그램의 디렉토리 &lt;code&gt;src&lt;/code&gt; 에있는 모듈 &lt;code&gt;multitrace&lt;/code&gt; 트레이스는 세 가지 가능한 추적 설정을 가진 작은 도구를 제공합니다. 추적 메시지는 바이너리 파일에 기록되며 &lt;code&gt;multitrace:format/1,2&lt;/code&gt; 함수로 형식화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fadc79bb4f4079275ed96cbc52aaafb49fe144c9" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;ttb&lt;/code&gt; is the interface to all functions in Trace Tool Builder.</source>
          <target state="translated">모듈 &lt;code&gt;ttb&lt;/code&gt; 는 Trace Tool Builder의 모든 기능에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="0f51d8b77d3dc630a64fa03791646f65e006ef89" translate="yes" xml:space="preserve">
          <source>Module Dependencies</source>
          <target state="translated">모듈 종속성</target>
        </trans-unit>
        <trans-unit id="b1299646aab374780f3464f47be41a7599458cc8" translate="yes" xml:space="preserve">
          <source>Module Edges. All module calls.</source>
          <target state="translated">모듈 에지. 모든 모듈 호출.</target>
        </trans-unit>
        <trans-unit id="25c39cd87ce1e8902744b9d921475fb58d5d669b" translate="yes" xml:space="preserve">
          <source>Module Menu</source>
          <target state="translated">모듈 메뉴</target>
        </trans-unit>
        <trans-unit id="ced0e862b16bd4e8e4a82b06efe646e55fe1c54e" translate="yes" xml:space="preserve">
          <source>Module Summary</source>
          <target state="translated">모듈 요약</target>
        </trans-unit>
        <trans-unit id="4de0a6a0634d489b9158f70004696bcc4b277613" translate="yes" xml:space="preserve">
          <source>Module and application names are atoms, while file and directory names are strings. For backward compatibility reasons, some functions accept both strings and atoms, but a future release will probably only allow the arguments that are documented.</source>
          <target state="translated">모듈 및 응용 프로그램 이름은 원자 인 반면 파일 및 디렉토리 이름은 문자열입니다. 이전 버전과의 호환성을 위해 일부 함수는 문자열과 원자를 모두 허용하지만 향후 릴리스에서는 아마도 문서화 된 인수 만 허용 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="98d340d054026300c96f6d0c3d9034ee4899cc53" translate="yes" xml:space="preserve">
          <source>Module atomics was introduced in OTP 21.2.</source>
          <target state="translated">모듈 원 자학은 OTP 21.2에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="53bcb5e4dbe6774226d92c1d8796a8dd249ddb9a" translate="yes" xml:space="preserve">
          <source>Module attributes for the current code. This field is decoded when looked at by the Crashdump Viewer tool.</source>
          <target state="translated">현재 코드의 모듈 속성. 이 필드는 Crashdump Viewer 도구에서 볼 때 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="f7f9e0f5b07f095dde5495f6ff4abc79cb69752f" translate="yes" xml:space="preserve">
          <source>Module attributes for the old code, if any. This field is decoded when looked at by the Crashdump Viewer tool.</source>
          <target state="translated">이전 코드의 모듈 속성 (있는 경우). 이 필드는 Crashdump Viewer 도구에서 볼 때 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="e3a2b561ade9a1dd5f8967dfaccdbb1ed9cc9dd4" translate="yes" xml:space="preserve">
          <source>Module binary was introduced in OTP R14B.</source>
          <target state="translated">모듈 바이너리는 OTP R14B에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="42bc5742ba4cf708fc095b36dac3c3d69cf85223" translate="yes" xml:space="preserve">
          <source>Module counters was introduced in OTP 21.2.</source>
          <target state="translated">모듈 카운터는 OTP 21.2에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="d300479faeca730c8a2edff00ae488f9dbd90edc" translate="yes" xml:space="preserve">
          <source>Module ct_hooks was introduced in OTP R14B02.</source>
          <target state="translated">모듈 ct_hooks는 OTP R14B02에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="d8654aa3f69b8803429d2756555ab92f9a06f3f2" translate="yes" xml:space="preserve">
          <source>Module ct_netconfc was introduced in OTP R15B02.</source>
          <target state="translated">모듈 ct_netconfc는 OTP R15B02에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="bb8f670cf7ca3b5196482b7892cd895e28618601" translate="yes" xml:space="preserve">
          <source>Module ct_property_test was introduced in OTP 17.3.</source>
          <target state="translated">모듈 ct_property_test는 OTP 17.3에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="cd1985927abe27a2940645bdcf2c01634f896588" translate="yes" xml:space="preserve">
          <source>Module ct_slave was introduced in OTP R14B.</source>
          <target state="translated">모듈 ct_slave는 OTP R14B에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="71757788af33c89da2724ac0be59def60e579311" translate="yes" xml:space="preserve">
          <source>Module ct_testspec was introduced in OTP 19.3.</source>
          <target state="translated">모듈 ct_testspec은 OTP 19.3에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="9ec0fffee38c98db4b9f15f636dd6e2046e7c657" translate="yes" xml:space="preserve">
          <source>Module declaration, defining the name of the module. The name &lt;code&gt;Module&lt;/code&gt;, an atom, is to be same as the file name minus the extension &lt;code&gt;.erl&lt;/code&gt;. Otherwise &lt;code&gt;&lt;a href=&quot;code_loading#loading&quot;&gt;code loading&lt;/a&gt;&lt;/code&gt; does not work as intended.</source>
          <target state="translated">모듈의 이름을 정의하는 모듈 선언. 원자 이름 인 &lt;code&gt;Module&lt;/code&gt; 이름 은 파일 이름에서 확장자 &lt;code&gt;.erl&lt;/code&gt; 을 뺀 것과 같습니다 . 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;code_loading#loading&quot;&gt;code loading&lt;/a&gt;&lt;/code&gt; 가 의도 한대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9f410e5b1b65a73903dd4626c286783c1bfbc2a" translate="yes" xml:space="preserve">
          <source>Module dependencies</source>
          <target state="translated">모듈 의존성</target>
        </trans-unit>
        <trans-unit id="c4de41b866e4495590e15d7c4a7b74f33f765b7e" translate="yes" xml:space="preserve">
          <source>Module diameter was introduced in OTP R14B03.</source>
          <target state="translated">모듈 직경은 OTP R14B03에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="6998b7f5007c0f34c3b91765b2d49b9e909b15d9" translate="yes" xml:space="preserve">
          <source>Module diameter_codec was introduced in OTP R15B03.</source>
          <target state="translated">모듈 diameter_codec은 OTP R15B03에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="e1781d9a9cfea982093f1d123e6e61590d06c935" translate="yes" xml:space="preserve">
          <source>Module diameter_make was introduced in OTP R14B03.</source>
          <target state="translated">모듈 diameter_make는 OTP R14B03에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="e8db744877f88892a28379110dae10e240b2a6e7" translate="yes" xml:space="preserve">
          <source>Module diameter_sctp was introduced in OTP R14B03.</source>
          <target state="translated">모듈 diameter_sctp는 OTP R14B03에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="27eff594940bc25f1e99bfd84ee3fb6c4154e5d6" translate="yes" xml:space="preserve">
          <source>Module diameter_tcp was introduced in OTP R14B03.</source>
          <target state="translated">모듈 diameter_tcp는 OTP R14B03에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="f4643ea3d5e93df18457f3816130a86a4cb67c84" translate="yes" xml:space="preserve">
          <source>Module diameter_transport was introduced in OTP R14B03.</source>
          <target state="translated">모듈 diameter_transport는 OTP R14B03에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="a05a780b6f39019fcc9e863afd833ffd6fa0637a" translate="yes" xml:space="preserve">
          <source>Module dyntrace was introduced in OTP R15B01.</source>
          <target state="translated">모듈 dyntrace는 OTP R15B01에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="d1960cdf98aa936a227554c01e07f847482cb927" translate="yes" xml:space="preserve">
          <source>Module eldap was introduced in OTP R15B01.</source>
          <target state="translated">모듈 eldap은 OTP R15B01에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="6b41bc65fac019eeb84f457522e15550888a0c1d" translate="yes" xml:space="preserve">
          <source>Module erl_anno was introduced in OTP 18.0.</source>
          <target state="translated">모듈 erl_anno는 OTP 18.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="a03ddeb54cfdc35710842e3d8532a4f17c4650a0" translate="yes" xml:space="preserve">
          <source>Module erl_epmd was introduced in OTP R14B.</source>
          <target state="translated">모듈 erl_epmd는 OTP R14B에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="9f0baad627fb53cb766ea5990049b80e397bd783" translate="yes" xml:space="preserve">
          <source>Module erl_tracer was introduced in OTP 19.0.</source>
          <target state="translated">모듈 erl_tracer는 OTP 19.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="3a9344f7e59758da1995c11adfd8c34f62c8de06" translate="yes" xml:space="preserve">
          <source>Module erpc was introduced in OTP 23.0.</source>
          <target state="translated">모듈 erpc는 OTP 23.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="6d5e21488abfc382926728e15dad73e13de36aa3" translate="yes" xml:space="preserve">
          <source>Module gen_statem was introduced in OTP 19.0.</source>
          <target state="translated">모듈 gen_statem은 OTP 19.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="d8448c6a252cc708f8ac2682727d5382278405f4" translate="yes" xml:space="preserve">
          <source>Module http_uri was introduced in OTP R15B01.</source>
          <target state="translated">모듈 http_uri는 OTP R15B01에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="6e2810043d820a944ddb633953afd8052c0ce6ef" translate="yes" xml:space="preserve">
          <source>Module httpc was introduced in OTP R13B04.</source>
          <target state="translated">모듈 httpc는 OTP R13B04에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="8634e8bf781897309210834c63a15c29db7618ed" translate="yes" xml:space="preserve">
          <source>Module httpd_custom_api was introduced in OTP 17.5.6.</source>
          <target state="translated">모듈 httpd_custom_api는 OTP 17.5.6에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="29831323c7df8a96814b2f509d3ff6857f030f35" translate="yes" xml:space="preserve">
          <source>Module implementing a transport process as defined in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;. Defaults to &lt;code&gt;diameter_tcp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 정의 된 전송 프로세스를 구현하는 모듈 . 기본값은 &lt;code&gt;diameter_tcp&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e4e38a18f0719919f3c40ded9bbdfc81eabab76a" translate="yes" xml:space="preserve">
          <source>Module implementing the behaviour &lt;code&gt;&lt;a href=&quot;ssh_client_key_api&quot;&gt;ssh_client_key_api&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;ssh_server_key_api&quot;&gt;ssh_server_key_api&lt;/a&gt;&lt;/code&gt;. Can be used to customize the handling of public keys. If callback options are provided along with the module name, they are made available to the callback module via the options passed to it under the key 'key_cb_private'.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh_client_key_api&quot;&gt;ssh_client_key_api&lt;/a&gt;&lt;/code&gt; 및 / 또는 &lt;code&gt;&lt;a href=&quot;ssh_server_key_api&quot;&gt;ssh_server_key_api&lt;/a&gt;&lt;/code&gt; 동작을 구현하는 모듈 . 공개 키 처리를 사용자 정의하는 데 사용할 수 있습니다. 콜백 옵션이 모듈 이름과 함께 제공되면 'key_cb_private'키 아래에 전달 된 옵션을 통해 콜백 모듈에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35eeaf69ae679cc6ded3a7a1fc0ebe15bf8b481c" translate="yes" xml:space="preserve">
          <source>Module implementing the callback interface defined in &lt;code&gt;diameter_app(3)&lt;/code&gt;, along with any extra arguments to be appended to those documented. Note that extra arguments specific to an outgoing request can be specified to &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt;, in which case those are appended to any module-specific extra arguments.</source>
          <target state="translated">&lt;code&gt;diameter_app(3)&lt;/code&gt; 정의 된 콜백 인터페이스를 구현하는 모듈 과 문서화 된 추가 인수와 함께 추가 인수입니다. 발신 요청에 특정한 추가 인수는 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 로 지정할 수 있으며 ,이 경우 인수는 모듈 별 추가 인수에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ed10eea74bdfe74fc718b32265df8faa84bb27bd" translate="yes" xml:space="preserve">
          <source>Module lcnt was introduced in OTP R13B04.</source>
          <target state="translated">모듈 lcnt는 OTP R13B04에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="f76dccaeb308983d0ab2086843bbd0324e8a1f3b" translate="yes" xml:space="preserve">
          <source>Module logger was introduced in OTP 21.0.</source>
          <target state="translated">모듈 로거는 OTP 21.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="77ed1b4c9f1ec7add037110c6b44d492cbfb56ac" translate="yes" xml:space="preserve">
          <source>Module logger_disk_log_h was introduced in OTP 21.0.</source>
          <target state="translated">모듈 logger_disk_log_h는 OTP 21.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="ad79037def86c5caece0e0f70a8728b4f1386a27" translate="yes" xml:space="preserve">
          <source>Module logger_filters was introduced in OTP 21.0.</source>
          <target state="translated">모듈 logger_filters는 OTP 21.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="6d4a95e265a533fcdfc83d36567c4d6d3b690652" translate="yes" xml:space="preserve">
          <source>Module logger_formatter was introduced in OTP 21.0.</source>
          <target state="translated">모듈 logger_formatter는 OTP 21.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="c50ee9b3cbc5bd184a9c25bc215d101ba11a5592" translate="yes" xml:space="preserve">
          <source>Module logger_std_h was introduced in OTP 21.0.</source>
          <target state="translated">모듈 logger_std_h는 OTP 21.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="f2f7add00a5fc14394421a99d67553e865a40d25" translate="yes" xml:space="preserve">
          <source>Module maps was introduced in OTP 17.0.</source>
          <target state="translated">모듈 맵은 OTP 17.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="e5c5f2cab8107c7a9e4bec2343033279f34b5f64" translate="yes" xml:space="preserve">
          <source>Module msacc was introduced in OTP 19.0.</source>
          <target state="translated">모듈 msacc는 OTP 19.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="8ac3ab9dcc2e8cb2a00c7b4ced3af3f822b18ebf" translate="yes" xml:space="preserve">
          <source>Module net was introduced in OTP 22.0.</source>
          <target state="translated">Module net은 OTP 22.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="4d139b86ec78e2818e601c5322274086b1b15ed7" translate="yes" xml:space="preserve">
          <source>Module observer was introduced in OTP R15B.</source>
          <target state="translated">모듈 옵저버는 OTP R15B에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="39b9e9a97d1c4649a00289e3047bd1dabea168f6" translate="yes" xml:space="preserve">
          <source>Module persistent_term was introduced in OTP 21.2.</source>
          <target state="translated">모듈 persistence_term은 OTP 21.2에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="dd286c283f38f2ad248b0537a881b820d16f22d1" translate="yes" xml:space="preserve">
          <source>Module pg was introduced in OTP 23.0.</source>
          <target state="translated">모듈 pg는 OTP 23.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="39eb77688a27b94673c3c07215c1826cb63c9bae" translate="yes" xml:space="preserve">
          <source>Module rand was introduced in OTP 18.0.</source>
          <target state="translated">모듈 rand는 OTP 18.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="b390807d1e54ffa01182b3c85c577695ce4c0197" translate="yes" xml:space="preserve">
          <source>Module scheduler was introduced in OTP 21.0.</source>
          <target state="translated">모듈 스케줄러는 OTP 21.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="276beee08cc3300520de13eb90fe0711d380edd4" translate="yes" xml:space="preserve">
          <source>Module shell_docs was introduced in OTP 23.0.</source>
          <target state="translated">모듈 shell_docs는 OTP 23.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="bebf5352b9be67e031b37602eea4f1cb5c0304bb" translate="yes" xml:space="preserve">
          <source>Module snmpa_mib_data was introduced in OTP R16B01.</source>
          <target state="translated">모듈 snmpa_mib_data는 OTP R16B01에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="0e70a8ea85ca84be44893d82b6c3a280a38540f8" translate="yes" xml:space="preserve">
          <source>Module snmpa_mib_storage was introduced in OTP R16B01.</source>
          <target state="translated">모듈 snmpa_mib_storage는 OTP R16B01에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="ace0e955e027d0b0000299b51fa7e9c1b021ff27" translate="yes" xml:space="preserve">
          <source>Module socket was introduced in OTP 22.0.</source>
          <target state="translated">모듈 소켓은 OTP 22.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="3b1e11776366f8fb2d72c2cb79f09bb4fa24e742" translate="yes" xml:space="preserve">
          <source>Module specific configuration. A module has a mandatory name and module level options that are described below.</source>
          <target state="translated">모듈 별 구성. 모듈에는 아래 설명 된 필수 이름 및 모듈 수준 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="72dc920d6466f3a51ff148a6c22c0149e736b012" translate="yes" xml:space="preserve">
          <source>Module ssh_agent was introduced in OTP 23.0.</source>
          <target state="translated">모듈 ssh_agent는 OTP 23.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="5b536e7ce1fd7488bfc6ee5456bc8fa4439ff032" translate="yes" xml:space="preserve">
          <source>Module ssh_client_channel was introduced in OTP 21.0.</source>
          <target state="translated">모듈 ssh_client_channel은 OTP 21.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="2f869e3e3bb6f5ddde6f36f71cb3a4d4cec6836e" translate="yes" xml:space="preserve">
          <source>Module ssh_client_key_api was introduced in OTP R16B.</source>
          <target state="translated">모듈 ssh_client_key_api는 OTP R16B에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="6a18eb111cdd15328a4e1f834f89cd65be3ee034" translate="yes" xml:space="preserve">
          <source>Module ssh_file was introduced in OTP 21.2.</source>
          <target state="translated">모듈 ssh_file은 OTP 21.2에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="57feb238e6679d7b5b4205e5260bb2378fe1534f" translate="yes" xml:space="preserve">
          <source>Module ssh_server_channel was introduced in OTP 21.0.</source>
          <target state="translated">모듈 ssh_server_channel은 OTP 21.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="ec9c71a107f47f6dda0c427212ee44e14c11900f" translate="yes" xml:space="preserve">
          <source>Module ssh_server_key_api was introduced in OTP R16B.</source>
          <target state="translated">모듈 ssh_server_key_api는 OTP R16B에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="2dd245aa2de3105d5d30fc67148a14bc85ad6386" translate="yes" xml:space="preserve">
          <source>Module ssl_crl_cache was introduced in OTP 18.0.</source>
          <target state="translated">모듈 ssl_crl_cache는 OTP 18.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="7196fbbf96abe91ca288980df4ef82ab8959fe8c" translate="yes" xml:space="preserve">
          <source>Module ssl_crl_cache_api was introduced in OTP 18.0.</source>
          <target state="translated">모듈 ssl_crl_cache_api는 OTP 18.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="1be353989bfb013991c9a0ee8d97a17097a338f0" translate="yes" xml:space="preserve">
          <source>Module ssl_session_cache_api was introduced in OTP R14B.</source>
          <target state="translated">모듈 ssl_session_cache_api는 OTP R14B에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="cacaca54d1da5bb7e4da7be2e842da46f15421fe" translate="yes" xml:space="preserve">
          <source>Module system_information was introduced in OTP 17.0.</source>
          <target state="translated">모듈 system_information은 OTP 17.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="315a38a0921c5df7ca4ea57d01f6e3c02d81b5a7" translate="yes" xml:space="preserve">
          <source>Module table. One entry for each loaded module.</source>
          <target state="translated">모듈 테이블. 로드 된 각 모듈에 대해 하나의 항목.</target>
        </trans-unit>
        <trans-unit id="798bbcabe6f7c0a85968c3aa75968373336b7c59" translate="yes" xml:space="preserve">
          <source>Module uri_string was introduced in OTP 21.0.</source>
          <target state="translated">모듈 uri_string은 OTP 21.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="f9b60e96ee40b88550cfc1f8c7fcfd25f0c8cd62" translate="yes" xml:space="preserve">
          <source>Module version. &lt;code&gt;Vsn&lt;/code&gt; is any literal term and can be retrieved using &lt;code&gt;beam_lib:version/1&lt;/code&gt;, see the &lt;code&gt;beam_lib(3)&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">모듈 버전. &lt;code&gt;Vsn&lt;/code&gt; 은 리터럴 용어이며 &lt;code&gt;beam_lib:version/1&lt;/code&gt; 을 사용하여 검색 할 수 있습니다 . &lt;code&gt;beam_lib(3)&lt;/code&gt; 의 beam_lib (3) 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="44a12cea34941c3636ff9a5c6f66929acd277169" translate="yes" xml:space="preserve">
          <source>Module which handles the network interface filter part for the SNMP agent. Must implement the &lt;code&gt;&lt;a href=&quot;snmpa_network_interface_filter&quot;&gt;snmpa_network_interface_filter &lt;/a&gt;&lt;/code&gt; behaviour.</source>
          <target state="translated">SNMP 에이전트의 네트워크 인터페이스 필터 부분을 처리하는 모듈입니다. &lt;code&gt;&lt;a href=&quot;snmpa_network_interface_filter&quot;&gt;snmpa_network_interface_filter &lt;/a&gt;&lt;/code&gt; 동작을 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="503ebafe676df7f757d99bf2c13d2488fb6ebde6" translate="yes" xml:space="preserve">
          <source>Module which handles the network interface filter part for the SNMP agent. Must implement the &lt;code&gt;&lt;a href=&quot;snmpa_network_interface_filter&quot;&gt;snmpa_network_interface_filter&lt;/a&gt;&lt;/code&gt; behaviour.</source>
          <target state="translated">SNMP 에이전트의 네트워크 인터페이스 필터 부분을 처리하는 모듈입니다. &lt;code&gt;&lt;a href=&quot;snmpa_network_interface_filter&quot;&gt;snmpa_network_interface_filter&lt;/a&gt;&lt;/code&gt; 동작을 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1abddb44834be834e4e4bfa19c743e11a954f223" translate="yes" xml:space="preserve">
          <source>Module which handles the network interface filter part for the SNMP manager. Must implement the &lt;code&gt;&lt;a href=&quot;snmpm_network_interface_filter&quot;&gt;snmpm_network_interface_filter&lt;/a&gt;&lt;/code&gt; behaviour.</source>
          <target state="translated">SNMP 관리자 용 네트워크 인터페이스 필터 부분을 처리하는 모듈입니다. &lt;code&gt;&lt;a href=&quot;snmpm_network_interface_filter&quot;&gt;snmpm_network_interface_filter&lt;/a&gt;&lt;/code&gt; 동작을 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e44abc149b672de3d2e38a78a614dd0b902536c9" translate="yes" xml:space="preserve">
          <source>Module which handles the network interface part for the SNMP agent. Must implement the &lt;code&gt;&lt;a href=&quot;snmpa_network_interface&quot;&gt;snmpa_network_interface&lt;/a&gt;&lt;/code&gt; behaviour.</source>
          <target state="translated">SNMP 에이전트의 네트워크 인터페이스 부분을 처리하는 모듈입니다. &lt;code&gt;&lt;a href=&quot;snmpa_network_interface&quot;&gt;snmpa_network_interface&lt;/a&gt;&lt;/code&gt; 동작을 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e55ad072ead98bed5f6005b9ebdc8c72b3e6734f" translate="yes" xml:space="preserve">
          <source>Module-local type, that is, with a definition that is present in the code of the module</source>
          <target state="translated">모듈-로컬 유형, 즉 모듈의 코드에 존재하는 정의</target>
        </trans-unit>
        <trans-unit id="3bb18ecc75afce04897d2fff035677396581e539" translate="yes" xml:space="preserve">
          <source>ModuleName = atom()</source>
          <target state="translated">ModuleName = atom ()</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="91edcf2737edcc491331e2f8bedfb98b3d292c2d" translate="yes" xml:space="preserve">
          <source>Modules are auto loaded when they are first referenced if the runtime system runs in &lt;code&gt;interactive&lt;/code&gt; mode, which is the default. In &lt;code&gt;embedded&lt;/code&gt; mode modules are not auto loaded. The latter is recommended when the boot script preloads all modules, as conventionally happens in OTP releases. See &lt;code&gt;code(3)&lt;/code&gt;</source>
          <target state="translated">런타임 시스템이 &lt;code&gt;interactive&lt;/code&gt; 모드 (기본값) 에서 실행될 경우 처음 참조 될 때 모듈이 자동으로로드됩니다 . 에 &lt;code&gt;embedded&lt;/code&gt; 모드 모듈로드되지 않습니다 자동. 후자는 일반적으로 OTP 릴리스에서 발생하는 것처럼 부트 스크립트가 모든 모듈을 사전로드 할 때 권장됩니다. &lt;code&gt;code(3)&lt;/code&gt; 참조 (3)</target>
        </trans-unit>
        <trans-unit id="bb1481c22b555900c17ca93bb499831901e632cf" translate="yes" xml:space="preserve">
          <source>Modules for which these requirements are not fulfilled are not interpretable and are therefore displayed within parentheses.</source>
          <target state="translated">이러한 요구 사항이 충족되지 않은 모듈은 해석 할 수 없으므로 괄호 안에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3655dff16c3acb075f3aa4eb83a55de4222d8dcd" translate="yes" xml:space="preserve">
          <source>Modules handling textual data (such as &lt;code&gt;io_lib&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt; are sometimes subject to conversion or extension to be able to handle Unicode characters.</source>
          <target state="translated">텍스트 데이터를 처리하는 모듈 (예 : &lt;code&gt;io_lib&lt;/code&gt; 및 &lt;code&gt;string&lt;/code&gt; 은 유니 코드 문자를 처리 할 수 ​​있도록 변환 또는 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4c3f31c3058b3e9540e1619be8ab2562d234db4" translate="yes" xml:space="preserve">
          <source>Modules that can use match specifications for optimized traversal of tables are to call &lt;code&gt;qlc:table/2&lt;/code&gt; with an unary &lt;code&gt;TraverseFun&lt;/code&gt;. An example is &lt;code&gt;&lt;a href=&quot;ets#table-2&quot;&gt; ets:table/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">최적화 된 테이블 순회를 위해 일치 스펙을 사용할 수있는 모듈 은 단항 &lt;code&gt;TraverseFun&lt;/code&gt; 으로 &lt;code&gt;qlc:table/2&lt;/code&gt; 를 호출 하는 것 입니다. 예는 &lt;code&gt;&lt;a href=&quot;ets#table-2&quot;&gt; ets:table/2&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5f2ee43d36d04a016e320f127714934e6c2e4d80" translate="yes" xml:space="preserve">
          <source>Modules that can use match specifications for optimized traversal of tables are to call &lt;code&gt;qlc:table/2&lt;/code&gt; with an unary &lt;code&gt;TraverseFun&lt;/code&gt;. An example is &lt;code&gt;&lt;a href=&quot;ets#table-2&quot;&gt;ets:table/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테이블 순회 최적화를 위해 일치 스펙을 사용할 수있는 모듈 은 단항 &lt;code&gt;TraverseFun&lt;/code&gt; 으로 &lt;code&gt;qlc:table/2&lt;/code&gt; 를 호출 해야합니다 . 예는 &lt;code&gt;&lt;a href=&quot;ets#table-2&quot;&gt;ets:table/2&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="422ffac5358de536fa7258027d227737932e212a" translate="yes" xml:space="preserve">
          <source>Modules to be debugged must include debug information, for example, &lt;code&gt;erlc +debug_info MODULE.erl&lt;/code&gt;.</source>
          <target state="translated">디버깅 할 모듈에는 디버그 정보가 포함되어야합니다 (예 : &lt;code&gt;erlc +debug_info MODULE.erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad051bc5d863047321817c8bcfbe0c4f0ad41d7f" translate="yes" xml:space="preserve">
          <source>Modules. All modules: analyzed modules, used library modules, and unknown modules.</source>
          <target state="translated">모듈. 모든 모듈 : 분석 된 모듈, 사용 된 라이브러리 모듈 및 알 수없는 모듈.</target>
        </trans-unit>
        <trans-unit id="c3bdbab40a4be4ac1b8eb1ccb2dbb2eaf8ed480f" translate="yes" xml:space="preserve">
          <source>Mongolian</source>
          <target state="translated">Mongolian</target>
        </trans-unit>
        <trans-unit id="787f0f344756f8edefb0e5d7c62ebb26c5a4a55b" translate="yes" xml:space="preserve">
          <source>Mongolian Vowel Separator</source>
          <target state="translated">몽골어 모음 분리기</target>
        </trans-unit>
        <trans-unit id="600aa04e59197f341b9f4d4f4b67aac5860b9298" translate="yes" xml:space="preserve">
          <source>Mongolian vowel separator</source>
          <target state="translated">몽골어 모음 분리기</target>
        </trans-unit>
        <trans-unit id="01e57fc0fd45173cbed0acd0fdb7a3a5528fd3cf" translate="yes" xml:space="preserve">
          <source>Monitor the SNMP manager. In case of a crash, the calling (monitoring) process will get a 'DOWN' message (see the erlang module for more info).</source>
          <target state="translated">SNMP 관리자를 모니터하십시오. 충돌이 발생하면 호출 (모니터링) 프로세스에 'DOWN'메시지가 표시됩니다 (자세한 내용은 erlang 모듈 참조).</target>
        </trans-unit>
        <trans-unit id="344910a8e2960c1213ce5adc8d4e0d2e7e946399" translate="yes" xml:space="preserve">
          <source>Monitor the current status of all processes executing code in interpreted modules, also processes at other Erlang nodes.</source>
          <target state="translated">해석 된 모듈에서 코드를 실행하는 모든 프로세스의 현재 상태를 모니터링하고 다른 Erlang 노드의 프로세스도 모니터링하십시오.</target>
        </trans-unit>
        <trans-unit id="861055aa27b6909c706d63bc66a51be73f91acc2" translate="yes" xml:space="preserve">
          <source>Monitor the status of the node &lt;code&gt;Node&lt;/code&gt;. If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, monitoring is turned on. If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, monitoring is turned off.</source>
          <target state="translated">노드 &lt;code&gt;Node&lt;/code&gt; 의 상태를 모니터하십시오 . 경우 &lt;code&gt;Flag&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , 모니터링이 켜집니다. 경우 &lt;code&gt;Flag&lt;/code&gt; 입니다 &lt;code&gt;false&lt;/code&gt; , 모니터가 꺼집니다.</target>
        </trans-unit>
        <trans-unit id="ebcb5e6cac0f295c708f39a3c4a6170117db14de" translate="yes" xml:space="preserve">
          <source>MonitorRef</source>
          <target state="translated">MonitorRef</target>
        </trans-unit>
        <trans-unit id="470c3f4925fdbce53327014ba80ea684bb7bb834" translate="yes" xml:space="preserve">
          <source>Monitoring of the master node by the slaves. A slave node can be stopped if the master node terminates. (Configurable.)</source>
          <target state="translated">슬레이브에 의한 마스터 노드 모니터링. 마스터 노드가 종료되면 슬레이브 노드를 중지 할 수 있습니다. (구성 가능)</target>
        </trans-unit>
        <trans-unit id="0f28429d58b7c5efe00cd63a0b3f938a3c652898" translate="yes" xml:space="preserve">
          <source>Monitors are unidirectional. Repeated calls to &lt;code&gt;erlang:monitor(process, Pid)&lt;/code&gt; creates several independent monitors, and each one sends a 'DOWN' message when &lt;code&gt;Pid&lt;/code&gt; terminates.</source>
          <target state="translated">모니터는 단방향입니다. &lt;code&gt;erlang:monitor(process, Pid)&lt;/code&gt; 를 반복해서 호출 하면 여러 개의 독립적 인 모니터가 생성되며 &lt;code&gt;Pid&lt;/code&gt; 가 종료 되면 각각 'DOWN'메시지를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="cdb09466cb66d0cbd945a8e99ed6c52ea020f0ad" translate="yes" xml:space="preserve">
          <source>Monitors can be created for processes with registered names, also at other nodes.</source>
          <target state="translated">다른 노드에서도 등록 된 이름의 프로세스에 대한 모니터를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01bc156298d3c730abf64a20c2aed5c87c1f305c" translate="yes" xml:space="preserve">
          <source>Monitors changes in &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;time offset&lt;/a&gt;&lt;/code&gt; between &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt;. One valid &lt;code&gt;Item&lt;/code&gt; exists in combination with the &lt;code&gt;time_offset Type&lt;/code&gt;, namely the atom &lt;code&gt;clock_service&lt;/code&gt;. Notice that the atom &lt;code&gt;clock_service&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; the registered name of a process. In this case it serves as an identifier of the runtime system internal clock service at current runtime system instance.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt; 사이의 &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;time offset&lt;/a&gt;&lt;/code&gt; 변경을 모니터링 합니다 . &lt;code&gt;time_offset Type&lt;/code&gt; 과 함께 하나의 유효한 &lt;code&gt;Item&lt;/code&gt; , 즉 atom &lt;code&gt;clock_service&lt;/code&gt; 가 존재 합니다. atom &lt;code&gt;clock_service&lt;/code&gt; 는 프로세스의 등록 된 이름 이 &lt;strong&gt;아닙니다&lt;/strong&gt; . 이 경우 현재 런타임 시스템 인스턴스에서 런타임 시스템 내부 시계 서비스의 식별자로 사용됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6278940d00dc973b9fac020727e51dbaff5a2934" translate="yes" xml:space="preserve">
          <source>Monitors the new process (like &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt; does).</source>
          <target state="translated">새로운 프로세스를 모니터합니다 ( &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt; 처럼 ).</target>
        </trans-unit>
        <trans-unit id="cad13ed7bd36f4e4080c9a5204dc6f837cb3bfe8" translate="yes" xml:space="preserve">
          <source>Monitors the status of &lt;code&gt;Node&lt;/code&gt;. A message&lt;code&gt;{nodedown, Node}&lt;/code&gt; is received if the connection to it is lost.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 상태를 모니터합니다 . 연결이 끊어지면 &lt;code&gt;{nodedown, Node}&lt;/code&gt; 메시지 가 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="c216ef5762c4c0ce5f8e7770265d785983bc6ae3" translate="yes" xml:space="preserve">
          <source>Monitors when a driver gets unloaded. If one monitors a driver that is not present in the system, one immediately gets notified that the driver got unloaded. There is no guarantee that the driver was ever loaded.</source>
          <target state="translated">드라이버가 언로드 될 때 모니터링합니다. 시스템에없는 드라이버를 모니터하면 즉시 드라이버가 언로드되었다는 알림을받습니다. 드라이버가로드되었다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="054691f4ee3b3917016ebbaa64173208c28be20d" translate="yes" xml:space="preserve">
          <source>Monotonically Increasing</source>
          <target state="translated">단조롭게 증가</target>
        </trans-unit>
        <trans-unit id="bd9b10ee2a0012e1817ee26b4049755fcb0ac1ff" translate="yes" xml:space="preserve">
          <source>More &lt;code&gt;Option&lt;/code&gt;s can be added in the future.</source>
          <target state="translated">앞으로 더 많은 &lt;code&gt;Option&lt;/code&gt; 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d00ed339af89630d658502ba6fa422f63b92791b" translate="yes" xml:space="preserve">
          <source>More &lt;code&gt;Option&lt;/code&gt;s may be added in the future.</source>
          <target state="translated">앞으로 더 많은 &lt;code&gt;Option&lt;/code&gt; 이 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5800ca3d1d23bed63e706fafc9995e33a99a9d14" translate="yes" xml:space="preserve">
          <source>More &lt;strong&gt;Examples:&lt;/strong&gt;</source>
          <target state="translated">더 많은 &lt;strong&gt;예 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65607507695dbb68853f7200e33956e39fd6a15d" translate="yes" xml:space="preserve">
          <source>More Examples</source>
          <target state="translated">더 많은 예</target>
        </trans-unit>
        <trans-unit id="d583518560cd4a6b87be9bc7d0b5d20f375dd723" translate="yes" xml:space="preserve">
          <source>More about schema management</source>
          <target state="translated">스키마 관리에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="084d33c5ffa622aae8b80c260f0553ad2cf85f5d" translate="yes" xml:space="preserve">
          <source>More about this mapping later.</source>
          <target state="translated">나중에이 매핑에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="6f6b5d611fb9be7645dc68d59bbad9a1cb5dc15a" translate="yes" xml:space="preserve">
          <source>More complicated assertions are coded as subpatterns. There are two kinds: those that look ahead of the current position in the subject string, and those that look behind it. An assertion subpattern is matched in the normal way, except that it does not cause the current matching position to be changed.</source>
          <target state="translated">더 복잡한 어설 션은 하위 패턴으로 코딩됩니다. 두 가지 종류가 있습니다 : 제목 문자열에서 현재 위치보다 먼저 보이는 것과 뒤에서 보는 것. 어설 션 하위 패턴은 현재 일치 위치가 변경되지 않는 것을 제외하고는 일반적인 방식으로 일치됩니다.</target>
        </trans-unit>
        <trans-unit id="dc0707bf61bc70dcb1ccf38732ab029880726d5a" translate="yes" xml:space="preserve">
          <source>More complicated filters must be applied to all objects returned by &lt;code&gt;select/3&lt;/code&gt; given a match specification that matches all objects.</source>
          <target state="translated">모든 오브젝트 와 일치하는 일치 스펙이 지정된 경우 &lt;code&gt;select/3&lt;/code&gt; 가 리턴 한 모든 오브젝트에 더 복잡한 필터를 적용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="bc35fb8a88b65701f3530def0b268e553aeb3acf" translate="yes" xml:space="preserve">
          <source>More data is required for building a term. &lt;code&gt;Continuation1&lt;/code&gt; must be passed in a new call to &lt;code&gt;tokens/3,4&lt;/code&gt; when more data is available.</source>
          <target state="translated">용어를 작성하려면 더 많은 데이터가 필요합니다. 더 많은 데이터를 사용할 수있는 경우 &lt;code&gt;Continuation1&lt;/code&gt; 은 &lt;code&gt;tokens/3,4&lt;/code&gt; 에 대한 새로운 호출로 전달되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="61d71bef3701b166a8820075cfe5c6b25a998a5a" translate="yes" xml:space="preserve">
          <source>More data is required to build a term. &lt;code&gt;Continuation&lt;/code&gt; must be passed to &lt;code&gt;fread/3&lt;/code&gt; when more data becomes available.</source>
          <target state="translated">용어를 작성하려면 더 많은 데이터가 필요합니다. 더 많은 데이터를 사용할 수있게되면 &lt;code&gt;Continuation&lt;/code&gt; 을 &lt;code&gt;fread/3&lt;/code&gt; 로 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="39cdc5b92133a83e1358f08b311f1434a7fd0514" translate="yes" xml:space="preserve">
          <source>More examples are provided in &lt;code&gt; Programming Examples.&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt; Programming Examples.&lt;/code&gt; 에 더 많은 예제가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="b81ad47803878c0c922b614506252ef0f78c294e" translate="yes" xml:space="preserve">
          <source>More examples are provided in &lt;code&gt; Programming Examples&lt;/code&gt;.</source>
          <target state="translated">더 많은 예제는 &lt;code&gt; Programming Examples&lt;/code&gt; 에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="724f9066e927cf5e78aa33ce4b0b56cdb2c9bad0" translate="yes" xml:space="preserve">
          <source>More examples are provided in &lt;code&gt;Programming Examples.&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Programming Examples.&lt;/code&gt; 에 더 많은 예제가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ed94e5cafdef76e06a28a02d1fb7d9d847eb489" translate="yes" xml:space="preserve">
          <source>More examples are provided in &lt;code&gt;Programming Examples&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Programming Examples&lt;/code&gt; 에 더 많은 예제가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="0f0c04bd8d50bdec5467c598e0a5b535a66ddbd3" translate="yes" xml:space="preserve">
          <source>More fine-grained &lt;code&gt;MSAcc_Thread_State&lt;/code&gt;s can be added through configure (such as &lt;code&gt;./configure --with-microstate-accounting=extra&lt;/code&gt;). Enabling these states causes performance degradation when microstate accounting is turned off and increases the overhead when it is turned on.</source>
          <target state="translated">보다 세분화 된 &lt;code&gt;MSAcc_Thread_State&lt;/code&gt; 는 &lt;code&gt;./configure --with-microstate-accounting=extra&lt;/code&gt; 통해 추가 할 수 있습니다 (예 : ./configure --with-microstate-accounting = extra ). 이러한 상태를 사용하면 마이크로 스테이트 계정이 꺼질 때 성능이 저하되고 켜질 때 오버 헤드가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="a2265fcb92dc15d3c0d1088cf4a7cda3cf89b5a9" translate="yes" xml:space="preserve">
          <source>More flags may be introduced in the future.</source>
          <target state="translated">앞으로 더 많은 플래그가 도입 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2acb3fbd866339988fd39b1c284e6c3b2ab38a8d" translate="yes" xml:space="preserve">
          <source>More identifiers can exist, for example, server-side namespace.</source>
          <target state="translated">서버 측 네임 스페이스와 같은 더 많은 식별자가 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1694f778d2be24087b41889858ea210d0111ac2d" translate="yes" xml:space="preserve">
          <source>More information can be found at</source>
          <target state="translated">자세한 내용은 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="64269325714a31b2baa9a9331c4f44390f41f060" translate="yes" xml:space="preserve">
          <source>More information is provided by the &lt;code&gt;ms_transform&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">자세한 정보는 &lt;code&gt;ms_transform&lt;/code&gt; 의 ms_transform 매뉴얼 페이지에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="88f4919d857f59d8c447803f4828a40dd5c28e81" translate="yes" xml:space="preserve">
          <source>More information, if any. If the process is stopped at a breakpoint, the field contains information about the location &lt;code&gt;{Module,Line}&lt;/code&gt;. If the process has terminated, the field contains the exit reason.</source>
          <target state="translated">더 많은 정보. 프로세스가 중단 점에서 중지되면 필드에 &lt;code&gt;{Module,Line}&lt;/code&gt; 위치에 대한 정보가 포함 됩니다. 프로세스가 종료 된 경우 필드에 종료 이유가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ee6de05aba35fe8266245c0993bc1f9805274eb9" translate="yes" xml:space="preserve">
          <source>More options can be added in a future release.</source>
          <target state="translated">향후 릴리스에서 더 많은 옵션을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="624affd09f46bdb2e3938ac33ddbe38974e12c14" translate="yes" xml:space="preserve">
          <source>More than three parts are not possible with this indata, so</source>
          <target state="translated">이 데이터에는 세 부분 이상이 불가능하므로</target>
        </trans-unit>
        <trans-unit id="b885fb398d558b327a8bb15c26cf1ab822a084fa" translate="yes" xml:space="preserve">
          <source>More tuples in the returned list can be added in a future release.</source>
          <target state="translated">리턴 된리스트에 더 많은 튜플이 다음 릴리스에서 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8221a6661a6dd450a6a5dfd76d4419180368d29" translate="yes" xml:space="preserve">
          <source>Moreover, traversals not done in a &lt;strong&gt;safe&lt;/strong&gt; way, on tables where keys are inserted or deleted during the traversal, may yield the following undesired effects:</source>
          <target state="translated">또한 순회 중에 키가 삽입되거나 삭제되는 테이블에서 &lt;strong&gt;안전한&lt;/strong&gt; 방식으로 순회가 수행되지 않으면 다음과 같은 원치 않는 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da67cb977d2af46ee848b2a1678e58ecf46a909c" translate="yes" xml:space="preserve">
          <source>Most API functions require that the TLS/DTLS connection is established to work as expected.</source>
          <target state="translated">대부분의 API 함수는 TLS / DTLS 연결이 예상대로 작동하도록 설정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d2f77ff3575a46c8961aaa5e120590c63bc009a2" translate="yes" xml:space="preserve">
          <source>Most Unix operating systems have adopted a simpler approach, namely that Unicode file naming is not enforced, but by convention. Those systems usually use UTF-8 encoding for Unicode filenames, but do not enforce it. On such a system, a filename containing characters with code points from 128 through 255 can be named as plain ISO Latin-1 or use UTF-8 encoding. As no consistency is enforced, the Erlang VM cannot do consistent translation of all filenames.</source>
          <target state="translated">대부분의 유닉스 운영 체제는 더 단순한 접근 방식을 채택했습니다. 즉, 유니 코드 파일 이름 지정이 적용되는 것이 아니라 관례입니다. 이러한 시스템은 일반적으로 유니 코드 파일 이름에 UTF-8 인코딩을 사용하지만 적용하지는 않습니다. 이러한 시스템에서 128에서 255까지의 코드 포인트를 가진 문자를 포함하는 파일 이름은 일반 ISO Latin-1로 명명되거나 UTF-8 인코딩을 사용할 수 있습니다. 일관성이 적용되지 않으므로 Erlang VM은 모든 파일 이름을 일관되게 번역 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f0ba27548898cb4c334f12ba233f3dfd33b35de6" translate="yes" xml:space="preserve">
          <source>Most applications only need the Master Agent because an agent can have multiple MIBs loaded at the same time.</source>
          <target state="translated">에이전트는 동시에 여러 MIB를로드 할 수 있으므로 대부분의 응용 프로그램에는 마스터 에이전트 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f4dc046cd951e52d7b06645a8907d9bc64484dc4" translate="yes" xml:space="preserve">
          <source>Most drivers written before the runtime system with SMP support existed can run in the runtime system with SMP support, without being rewritten, if driver level locking is used.</source>
          <target state="translated">SMP를 지원하는 런타임 시스템 이전에 작성된 대부분의 드라이버는 드라이버 레벨 잠금이 사용되는 경우 다시 쓰지 않고 SMP를 지원하는 런타임 시스템에서 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36d595b42429aa7673a2aecb223ad49cf5a73ec5" translate="yes" xml:space="preserve">
          <source>Most functions appear in a version with the suffix &lt;code&gt;_tmo&lt;/code&gt; appended to the function name. Those functions take an extra argument, a time-out in &lt;strong&gt;milliseconds&lt;/strong&gt;. The semantics is this: for each communication primitive involved in the operation, if the primitive does not complete within the time specified, the function returns an error and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;ETIMEDOUT&lt;/code&gt;. With communication primitive is meant an operation on the socket, like &lt;code&gt;connect&lt;/code&gt;, &lt;code&gt;accept&lt;/code&gt;, &lt;code&gt;recv&lt;/code&gt;, or &lt;code&gt;send&lt;/code&gt;.</source>
          <target state="translated">대부분의 함수 는 함수 이름에 접미사 &lt;code&gt;_tmo&lt;/code&gt; 가 추가 된 버전으로 나타납니다 . 이러한 함수는 추가 인수 ( &lt;strong&gt;밀리 초 단위&lt;/strong&gt; 의 시간 초과)를 받습니다. 시맨틱은 다음과 같습니다. 조작과 관련된 각 통신 기본 요소에 대해 지정된 시간 내에 기본 요소가 완료되지 않으면 함수는 오류를 리턴하고 &lt;code&gt;erl_errno&lt;/code&gt; 가 &lt;code&gt;ETIMEDOUT&lt;/code&gt; 으로 설정됩니다 . 통신 프리미티브 란 &lt;code&gt;connect&lt;/code&gt; , &lt;code&gt;accept&lt;/code&gt; , &lt;code&gt;recv&lt;/code&gt; 또는 &lt;code&gt;send&lt;/code&gt; 와 같은 소켓에서의 작업을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="a85fc0308845fa5554e3cce6dc65bbf6089cf9b5" translate="yes" xml:space="preserve">
          <source>Most functions in &lt;code&gt;Erl_Interface&lt;/code&gt; report failures to the caller by returning some otherwise meaningless value (typically &lt;code&gt;NULL&lt;/code&gt; or a negative number). As this only tells you that things did not go well, examine the error code in &lt;code&gt;erl_errno&lt;/code&gt; if you want to find out more about the failure.</source>
          <target state="translated">&lt;code&gt;Erl_Interface&lt;/code&gt; 의 대부분의 함수는 의미가없는 값 (일반적으로 &lt;code&gt;NULL&lt;/code&gt; 또는 음수) 을 반환하여 호출자에게 실패를보고 합니다. 이것만으로는 문제가 해결되지 않았으므로 실패에 대해 더 자세히 알고 싶다면 &lt;code&gt;erl_errno&lt;/code&gt; 의 오류 코드를 검사하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b9a8701c6eef5e39f2cf96b687e2ad091233f9f" translate="yes" xml:space="preserve">
          <source>Most functions in this API are &lt;strong&gt;not&lt;/strong&gt; thread-safe, that is, they &lt;strong&gt;cannot&lt;/strong&gt; be called from arbitrary threads. Functions that are not documented as thread-safe can only be called from driver callbacks or function calls descending from a driver callback call. Notice that driver callbacks can be called from different threads. This, however, is not a problem for any function in this API, as the emulator has control over these threads.</source>
          <target state="translated">이 API의 대부분의 함수는 스레드로부터 안전 &lt;strong&gt;하지 않습니다&lt;/strong&gt; . 즉, 임의의 스레드에서 호출 할 &lt;strong&gt;수 없습니다&lt;/strong&gt; . 스레드 안전으로 문서화되지 않은 함수는 드라이버 콜백 또는 드라이버 콜백 호출에서 내림차순으로 만 호출 할 수 있습니다. 다른 스레드에서 드라이버 콜백을 호출 할 수 있습니다. 그러나 에뮬레이터가 이러한 스레드를 제어하므로이 API의 기능에는 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66cf9f2e24e97469377d6bb06bc86d3532009574" translate="yes" xml:space="preserve">
          <source>Most importantly, the object must have been created with a single call to &lt;code&gt;malloc()&lt;/code&gt; (or similar), so that it can later be removed by a single call to &lt;code&gt;free()&lt;/code&gt;. Objects are freed by the registry when it is closed, or when you assign a new value to an object that previously contained a string or binary.</source>
          <target state="translated">가장 중요한 것은 객체는 &lt;code&gt;malloc()&lt;/code&gt; (또는 이와 유사한)에 대한 단일 호출로 생성되었으므로 나중에 &lt;code&gt;free()&lt;/code&gt; 에 대한 단일 호출로 제거 할 수 있습니다 . 레지스트리가 닫히거나 이전에 문자열 또는 이진이 포함 된 오브젝트에 새 값을 지정하면 레지스트리가 오브젝트를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="259d848432008a34f52bb0dbba925c35f2c8e9d8" translate="yes" xml:space="preserve">
          <source>Most likely, some type of table coordinator already exists. This process should take care of the instrumentation for the table.</source>
          <target state="translated">대부분의 유형의 테이블 코디네이터가 이미 존재합니다. 이 프로세스는 테이블의 계측을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0e2d6f01b9b328d4a5f37c7cbd2074b9468e6ea" translate="yes" xml:space="preserve">
          <source>Most modern operating systems support Unicode filenames in some way. There are many different ways to do this and Erlang by default treats the different approaches differently:</source>
          <target state="translated">대부분의 최신 운영 체제는 어떤 방식 으로든 유니 코드 파일 이름을 지원합니다. 이를 수행하는 방법에는 여러 가지가 있으며 Erlang은 기본적으로 다른 방법을 다르게 취급합니다.</target>
        </trans-unit>
        <trans-unit id="42ea3df0b70c1046c7bcf6523dedc152b3d519c9" translate="yes" xml:space="preserve">
          <source>Most of the functions expect all input to be normalized to one form, see for example &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt; unicode:characters_to_nfc_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 함수는 모든 입력이 하나의 형식으로 정규화 될 것으로 예상합니다 (예 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt; unicode:characters_to_nfc_list/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94bf990af8b5bba4715948822b6d909da6a73a07" translate="yes" xml:space="preserve">
          <source>Most of the functions expect all input to be normalized to one form, see for example &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt;unicode:characters_to_nfc_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 함수는 모든 입력이 한 형식으로 정규화 될 것으로 예상합니다 (예 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt;unicode:characters_to_nfc_list/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3acc15056b9b45c5a0b8bb83b1ecaadb55f64f07" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module have one variant with a &lt;code&gt;Timeout&lt;/code&gt; parameter, and one without. If nothing else is specified, the default value &lt;code&gt;infinity&lt;/code&gt; is used when the &lt;code&gt;Timeout&lt;/code&gt; parameter is not given.</source>
          <target state="translated">이 모듈의 대부분의 함수에는 &lt;code&gt;Timeout&lt;/code&gt; 매개 변수 가있는 변형과 없는 매개 변수가 있습니다. 다른 것을 지정하지 않으면 &lt;code&gt;Timeout&lt;/code&gt; 매개 변수가 제공되지 않을 때 기본값 &lt;code&gt;infinity&lt;/code&gt; 가 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1c21332b5de08b2fbd3d7faeca43f33090fab572" translate="yes" xml:space="preserve">
          <source>Most of the modules in Erlang/OTP are Unicode-unaware in the sense that they have no notion of Unicode and should not have. Typically they handle non-textual or byte-oriented data (such as &lt;code&gt;gen_tcp&lt;/code&gt;).</source>
          <target state="translated">Erlang / OTP에있는 대부분의 모듈은 유니 코드에 대한 개념이없고 가져서는 안된다는 점에서 유니 코드를 인식하지 못합니다. 일반적으로 비 텍스트 또는 바이트 지향 데이터 (예 : &lt;code&gt;gen_tcp&lt;/code&gt; )를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="76641edebd3126877e42070a39301c6bf778343f" translate="yes" xml:space="preserve">
          <source>Most of the options are common for both the client and the server side, but some of them differs a little. The available &lt;code&gt;option()&lt;/code&gt;s are as follows:</source>
          <target state="translated">대부분의 옵션은 클라이언트와 서버 측 모두에 공통적이지만 일부는 약간 다릅니다. 사용 가능한 &lt;code&gt;option()&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e0d4e811a2f740e5d587160a505db4b80acdc72" translate="yes" xml:space="preserve">
          <source>Most of these flags are highly implementation-dependent and can be changed or removed without prior notice.</source>
          <target state="translated">이러한 플래그는 대부분 구현에 따라 다르며 사전 통지없이 변경하거나 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7cba0447d8d7195a8296a095d999aca792c4346" translate="yes" xml:space="preserve">
          <source>Most operating systems have a command interpreter or shell, UNIX and Linux have many, Windows has the command prompt. Erlang has its own shell where bits of Erlang code can be written directly, and be evaluated to see what happens (see the &lt;code&gt;shell(3)&lt;/code&gt; manual page in STDLIB).</source>
          <target state="translated">대부분의 운영 체제에는 명령 인터프리터 또는 쉘이 있고 UNIX 및 Linux에는 많은 것이 있으며 Windows에는 명령 프롬프트가 있습니다. Erlang에는 Erlang 코드 비트를 직접 작성할 수있는 자체 쉘이 있으며 어떤 일이 발생하는지 평가합니다 ( STDLIB 의 &lt;code&gt;shell(3)&lt;/code&gt; 매뉴얼 페이지 참조).</target>
        </trans-unit>
        <trans-unit id="39c2fb5ddc35fb498363b9b722fc5915d7d947f6" translate="yes" xml:space="preserve">
          <source>Most programmers also expect time to be reliable, at least until they realize that the wall clock time on their workstation is off by a minute. Then they set it to the correct time, but most probably not in a smooth way.</source>
          <target state="translated">또한 대부분의 프로그래머는 최소한 워크 스테이션의 벽시계 시간이 1 분 정도 지났다는 사실을 깨닫기까지는 시간이 안정적이라고 생각합니다. 그런 다음 그들은 정확한 시간으로 설정했지만 대부분은 매끄럽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d49d2009b77de7ac08a0afaec3a6bddcd20dae8e" translate="yes" xml:space="preserve">
          <source>Most programs will be modified during their lifetime: bugs will be fixed, features will be added, optimizations may become necessary, or the code will need to be refactored or cleaned up in other ways to make it easier to work with. But every change to a working program is a risk of introducing new bugs - or reintroducing bugs that had previously been fixed. Having a set of unit tests that you can run with very little effort makes it easy to know that the code still works as it should (this use is called &lt;strong&gt;regression testing&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt;). This goes a long way to reduce the resistance to changing and refactoring code.</source>
          <target state="translated">대부분의 프로그램은 일생 동안 수정됩니다 : 버그가 수정되거나, 기능이 추가되거나, 최적화가 필요할 수 있으며, 코드 작업을 쉽게하기 위해 다른 방식으로 코드를 리팩터링하거나 정리해야합니다. 그러나 작동중인 프로그램을 변경할 때마다 새로운 버그가 발생하거나 이전에 수정 된 버그가 다시 발생할 위험이 있습니다. 적은 노력으로 실행할 수있는 단위 테스트 세트를 사용하면 코드가 여전히 정상적으로 작동하는지 쉽게 알 수 있습니다 (이 용도를 &lt;strong&gt;회귀 테스트&lt;/strong&gt; 라고 합니다. &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt; 참조 ). 이는 코드 변경 및 리팩토링에 대한 저항을 줄이는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="22312ab51d7c6c1f35dbc3ee3223deb0c786bd3e" translate="yes" xml:space="preserve">
          <source>Most role-specific behaviour is implemented by the user. How a node advertises itself at capabilities exchange is determined by user configuration.</source>
          <target state="translated">대부분의 역할 별 동작은 사용자가 구현합니다. 기능 교환시 노드가 자신을 알리는 방법은 사용자 구성에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="86e32c3cb060fb634a619eef0dd5d1eef4747958" translate="yes" xml:space="preserve">
          <source>Most systems handle variable &lt;code&gt;LC_CTYPE&lt;/code&gt; before &lt;code&gt;LANG&lt;/code&gt;, so if that is set, it must be set to &lt;code&gt;UTF-8&lt;/code&gt;:</source>
          <target state="translated">대부분의 시스템은 &lt;code&gt;LANG&lt;/code&gt; 전에 변수 &lt;code&gt;LC_CTYPE&lt;/code&gt; 을 처리 하므로 설정되면 &lt;code&gt;UTF-8&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="56244bcac54ef39e9d4826088a4c9d7b27054731" translate="yes" xml:space="preserve">
          <source>Moves the copy of table &lt;code&gt;Tab&lt;/code&gt; from node &lt;code&gt;From&lt;/code&gt; to node &lt;code&gt;To&lt;/code&gt;.</source>
          <target state="translated">이동 테이블의 복사본 &lt;code&gt;Tab&lt;/code&gt; 노드 &lt;code&gt;From&lt;/code&gt; 노드 &lt;code&gt;To&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b30cc0ae00fc3d8210b07f3cf78930cce84bbd4" translate="yes" xml:space="preserve">
          <source>Mro</source>
          <target state="translated">Mro</target>
        </trans-unit>
        <trans-unit id="b1fee5a1630c4cf74b49738a6b5de770a03930a2" translate="yes" xml:space="preserve">
          <source>Much of the work involved is automated. This includes &lt;code&gt;get-next&lt;/code&gt; processing and &lt;code&gt;RowStatus&lt;/code&gt; handling.</source>
          <target state="translated">관련된 많은 작업이 자동화됩니다. 여기에는 &lt;code&gt;get-next&lt;/code&gt; 처리 및 &lt;code&gt;RowStatus&lt;/code&gt; 처리가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="28dd4fba871bafc6251102ec641d8e20bb52017b" translate="yes" xml:space="preserve">
          <source>Multi-Round-Time-Out AVP</source>
          <target state="translated">멀티 라운드 타임 아웃 AVP</target>
        </trans-unit>
        <trans-unit id="6fa491dd40bfcdce2b73e2657ea80c4608fb14b5" translate="yes" xml:space="preserve">
          <source>Multi-Time Warp Mode</source>
          <target state="translated">멀티 타임 워프 모드</target>
        </trans-unit>
        <trans-unit id="e1f017ea475a1c73e4195e0bff09e16cde8df8aa" translate="yes" xml:space="preserve">
          <source>Multi-file error report logging is used to store error messages received by &lt;code&gt;error_logger&lt;/code&gt;. The error messages are stored in several files and each file is smaller than a specified number of kilobytes. No more than a specified number of files exist at the same time. The logging is very fast, as each error message is written as a binary term.</source>
          <target state="translated">다중 파일 오류 보고서 로깅은 &lt;code&gt;error_logger&lt;/code&gt; 가 수신 한 오류 메시지를 저장하는 데 사용됩니다 . 오류 메시지는 여러 파일에 저장되며 각 파일은 지정된 킬로바이트보다 작습니다. 동시에 지정된 수의 파일 만 존재합니다. 각 오류 메시지가 이진 용어로 작성되므로 로깅이 매우 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="d5421d352983c0b9fc43e3a80915204a161e3a58" translate="yes" xml:space="preserve">
          <source>Multiblock carriers are used for storage of several blocks.</source>
          <target state="translated">멀티 블록 캐리어는 여러 블록을 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1fec23604015b2ecb5fcc1e2452ac43e2d5d2bf0" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;--inherits&lt;/code&gt; options can be specified.</source>
          <target state="translated">여러- &lt;code&gt;--inherits&lt;/code&gt; 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41efb021af75ddc40ae618d768069c0d301604b2" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;-i&lt;/code&gt; options can be specified.</source>
          <target state="translated">여러 개의 &lt;code&gt;-i&lt;/code&gt; 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdf347cf86397485cf04a5bdb8b11bd1e69ffecc" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;&lt;a href=&quot;#disconnect_cb&quot;&gt;disconnect_cb&lt;/a&gt;&lt;/code&gt; options can be specified, in which case the corresponding callbacks are applied until one of them returns a value other than &lt;code&gt;ignore&lt;/code&gt;. All callbacks returning &lt;code&gt;ignore&lt;/code&gt; is equivalent to not having configured them.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#disconnect_cb&quot;&gt;disconnect_cb&lt;/a&gt;&lt;/code&gt; 옵션을 여러 개 지정할 수 있으며,이 경우 해당 콜백 중 하나가 &lt;code&gt;ignore&lt;/code&gt; 이외의 값을 반환 할 때까지 적용됩니다 . &lt;code&gt;ignore&lt;/code&gt; 를 반환 하는 모든 콜백 은 콜백 을 구성하지 않은 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="204798c1114f47e98e981a537b711d39b1311eda" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;include&lt;/code&gt; options can be specified.</source>
          <target state="translated">여러 &lt;code&gt;include&lt;/code&gt; 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e0d1680057ecce93b665efdb88bfc3e3c1e5449" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;inherits&lt;/code&gt; options can be specified.</source>
          <target state="translated">여러 &lt;code&gt;inherits&lt;/code&gt; 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce8d65e7ae8dec4ab75e8c06bdc2eceb56c1abf6" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;ip&lt;/code&gt; options can be specified for a multihomed peer. If none are specified then the values of &lt;code&gt;Host-IP-Address&lt;/code&gt; in the &lt;code&gt;diameter_service&lt;/code&gt; record are used. Option &lt;code&gt;port&lt;/code&gt; defaults to 3868 for a listening transport and 0 for a connecting transport.</source>
          <target state="translated">멀티 홈 피어에 대해 여러 &lt;code&gt;ip&lt;/code&gt; 옵션을 지정할 수 있습니다. 아무도는 다음의 값을 지정하지 않으면 &lt;code&gt;Host-IP-Address&lt;/code&gt; 에 &lt;code&gt;diameter_service&lt;/code&gt; 의 기록 사용된다. 옵션 전송 &lt;code&gt;port&lt;/code&gt; 는 청취 전송의 경우 3868이고 연결 전송의 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="088c280ad46a55ad788090a74438dc30fa9e951f" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;sys&lt;/code&gt; traceable replies</source>
          <target state="translated">여러 &lt;code&gt;sys&lt;/code&gt; 추적 가능 회신</target>
        </trans-unit>
        <trans-unit id="f06b4f8d09b8eaee5c332e885ceba194958a51dc" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;transport_module&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#transport_config&quot;&gt;transport_config&lt;/a&gt;&lt;/code&gt; options are allowed. The order of these is significant in this case (and only in this case), a &lt;code&gt;transport_module&lt;/code&gt; being paired with the first &lt;code&gt;&lt;a href=&quot;#transport_config&quot;&gt;transport_config&lt;/a&gt;&lt;/code&gt; following it in the options list, or the default value for trailing modules. Transport starts will be attempted with each of the modules in order until one establishes a connection within the corresponding timeout (see below) or all fail.</source>
          <target state="translated">여러 &lt;code&gt;transport_module&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#transport_config&quot;&gt;transport_config&lt;/a&gt;&lt;/code&gt; 옵션이 허용됩니다. 이들의 순서는이 경우 (이 경우에만), &lt;code&gt;transport_module&lt;/code&gt; 이 옵션 목록에서 첫 번째 &lt;code&gt;&lt;a href=&quot;#transport_config&quot;&gt;transport_config&lt;/a&gt;&lt;/code&gt; 와 쌍을 이루 거나 후행 모듈의 기본값으로 중요합니다. 해당 타임 아웃 (아래 참조) 내에 연결을 설정하거나 모두 실패 할 때까지 각 모듈에서 전송 시작이 순서대로 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="8a333a79ebe5ff34c8d76c9900da678f2524bef2" translate="yes" xml:space="preserve">
          <source>Multiple Erlang nodes implementing the same Diameter node should be configured with different sequence masks to ensure that each node uses a unique range of End-to-End and Hop-by-Hop Identifiers for outgoing requests.</source>
          <target state="translated">동일한 지름 노드를 구현하는 여러 Erlang 노드는 서로 다른 시퀀스 마스크로 구성하여 각 노드가 발신 요청에 대해 고유 한 엔드-투-엔드 및 홉별 식별자를 사용하도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="918e90f086f758494202e7c1057dc9d090319e70" translate="yes" xml:space="preserve">
          <source>Multiple connections are independent and governed by their own peer and watchdog state machines.</source>
          <target state="translated">여러 연결은 독립적이며 자체 피어 및 워치 독 상태 시스템에 의해 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="39c7dc292ea6c4ca667c03d03c78abb261ad3cd3" translate="yes" xml:space="preserve">
          <source>Multiple connections to the same peer is possible. ICMP messages are not interpreted.</source>
          <target state="translated">동일한 피어에 여러 연결이 가능합니다. ICMP 메시지는 해석되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47cd1d5d6231055845e7ad6743d6544e8318516d" translate="yes" xml:space="preserve">
          <source>Multiple entries of this type are allowed.</source>
          <target state="translated">이 유형의 여러 항목이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="38d744a92105856b5a02b866c88de04b40d669df" translate="yes" xml:space="preserve">
          <source>Multiple generic named time-outs</source>
          <target state="translated">여러 일반 명명 된 시간 초과</target>
        </trans-unit>
        <trans-unit id="8b65c69f112a6d8c5b4685ec30e6ffdcf36c27c8" translate="yes" xml:space="preserve">
          <source>Multiple, thread-specific instances of the allocator. This option has only effect on the runtime system with SMP support. Default behavior on the runtime system with SMP support is &lt;code&gt;NoSchedulers+1&lt;/code&gt; instances. Each scheduler uses a lock-free instance of its own and other threads use a common instance.</source>
          <target state="translated">할당 자의 여러 스레드 별 인스턴스. 이 옵션은 SMP를 지원하는 런타임 시스템에만 영향을줍니다. SMP를 지원하는 런타임 시스템의 기본 동작은 &lt;code&gt;NoSchedulers+1&lt;/code&gt; 인스턴스입니다. 각 스케줄러는 자체 잠금없는 인스턴스를 사용하고 다른 스레드는 공통 인스턴스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2f6d5d47eb24e552ff49945236f4445a4cf174f2" translate="yes" xml:space="preserve">
          <source>Multiple-line comments as in C, &lt;code&gt;/* ... */&lt;/code&gt;, are supported.</source>
          <target state="translated">C와 같은 여러 줄 주석, &lt;code&gt;/* ... */&lt;/code&gt; 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1914a937f0807f0283547ebd09066fb830cf5d9a" translate="yes" xml:space="preserve">
          <source>Must be seconds since or before Unix time epoch, which is 1970-01-01 00:00 UTC.</source>
          <target state="translated">1970 년 1 월 1 일 00:00 UTC 인 유닉스 시간 시대 이후 또는 초 단위 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0a004964de291cbe488f9f8bc3e151f3bcd7aa7b" translate="yes" xml:space="preserve">
          <source>Must be set to &lt;code&gt;0&lt;/code&gt; for a regular NIF. If the emulator was built with dirty scheduler support enabled, &lt;code&gt;flags&lt;/code&gt; can be set to either &lt;code&gt;ERL_NIF_DIRTY_JOB_CPU_BOUND&lt;/code&gt; if the job is expected to be CPU-bound, or &lt;code&gt;ERL_NIF_DIRTY_JOB_IO_BOUND&lt;/code&gt; for jobs that will be I/O-bound. If dirty scheduler threads are not available in the emulator, an attempt to schedule such a job results in a &lt;code&gt;notsup&lt;/code&gt; exception.</source>
          <target state="translated">일반 NIF의 경우 &lt;code&gt;0&lt;/code&gt; 으로 설정해야합니다 . 에뮬레이터가 더러운 스케줄러 지원이 활성화가 내장되어있는 경우 &lt;code&gt;flags&lt;/code&gt; 로 설정할 수 있습니다 &lt;code&gt;ERL_NIF_DIRTY_JOB_CPU_BOUND&lt;/code&gt; 작업이 CPU 바운드, 또는 것으로 예상되는 경우 &lt;code&gt;ERL_NIF_DIRTY_JOB_IO_BOUND&lt;/code&gt; I / O에 바인딩 될 것입니다 작업에. 더러운 스케줄러 스레드가 에뮬레이터에서 사용할 수없는 경우, 시도는에 이러한 작업의 결과를 예약하는 &lt;code&gt;notsup&lt;/code&gt; 의 예외.</target>
        </trans-unit>
        <trans-unit id="d99a3b8cea5bf9690f0427b0ac08c915ac93008c" translate="yes" xml:space="preserve">
          <source>Must be used with and be later than &lt;code&gt;StartTime&lt;/code&gt;. Values of &lt;code&gt;StopTime&lt;/code&gt; in the future are valid. This parameter is of type &lt;code&gt;dateTime&lt;/code&gt; and compliant to RFC 3339. Implementations must support time zones.</source>
          <target state="translated">&lt;code&gt;StartTime&lt;/code&gt; 이상과 함께 사용해야 합니다. 향후 &lt;code&gt;StopTime&lt;/code&gt; 값 이 유효합니다. 이 매개 변수는 &lt;code&gt;dateTime&lt;/code&gt; 유형 이며 RFC 3339를 준수합니다. 구현은 시간대를 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="343d9e25c8247ada5612875ca81c9f7947f3e480" translate="yes" xml:space="preserve">
          <source>Must denote a valid date and time.</source>
          <target state="translated">유효한 날짜와 시간을 나타내야합니다.</target>
        </trans-unit>
        <trans-unit id="1fa6f6533bff6aa5b9533df23cf9344981b03f0c" translate="yes" xml:space="preserve">
          <source>Must initiate data for a port. We do not create any sockets here, only initialize data structures.</source>
          <target state="translated">포트에 대한 데이터를 시작해야합니다. 여기서는 소켓을 만들지 않고 데이터 구조 만 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="ac5b330f1d3ccf5e6f1d498219f9f2b403798468" translate="yes" xml:space="preserve">
          <source>Must of the functions below has an optional &lt;code&gt;Extra&lt;/code&gt; argument (e.g. &lt;code&gt;&lt;a href=&quot;#unexpected_trans&quot;&gt;handle_unexpected_trans/4&lt;/a&gt;&lt;/code&gt;). The functions which takes this argument will be called if and only if one of the functions &lt;code&gt;&lt;a href=&quot;megaco#receive_message&quot;&gt;receive_message/5&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;megaco#process_received_message&quot;&gt;process_received_message/5&lt;/a&gt;&lt;/code&gt; was called with the &lt;code&gt;Extra&lt;/code&gt; argument different than &lt;code&gt;ignore_extra&lt;/code&gt;.</source>
          <target state="translated">아래 함수 중 선택적인 &lt;code&gt;Extra&lt;/code&gt; 인수 가 있어야합니다 (예 : &lt;code&gt;&lt;a href=&quot;#unexpected_trans&quot;&gt;handle_unexpected_trans/4&lt;/a&gt;&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;megaco#receive_message&quot;&gt;receive_message/5&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;megaco#process_received_message&quot;&gt;process_received_message/5&lt;/a&gt;&lt;/code&gt; 함수 중 하나 가 &lt;code&gt;ignore_extra&lt;/code&gt; 와 다른 &lt;code&gt;Extra&lt;/code&gt; 인수 로 호출 된 경우에만이 인수를 사용하는 함수 가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="7ffc4b83d53a4262e348ddeab52e859129df93ad" translate="yes" xml:space="preserve">
          <source>Mutual exclusion lock. Used for synchronizing access to shared data. Only one thread at a time can lock a mutex.</source>
          <target state="translated">상호 배제 잠금. 공유 데이터에 대한 액세스를 동기화하는 데 사용됩니다. 한 번에 하나의 스레드 만 뮤텍스를 잠글 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="928b7c48a60ad93b81bc3bee9d274c5f2aed9ad3" translate="yes" xml:space="preserve">
          <source>Myanmar</source>
          <target state="translated">Myanmar</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="19a21faf21159c116d212d930e958b4e48e27561" translate="yes" xml:space="preserve">
          <source>N | 0</source>
          <target state="translated">N | 0</target>
        </trans-unit>
        <trans-unit id="53110edb9232b435b7ecd44976ac1b46ea9cd99d" translate="yes" xml:space="preserve">
          <source>N'</source>
          <target state="translated">N'</target>
        </trans-unit>
        <trans-unit id="5372a9a248f9a06cc2f439c7194a9046904b1126" translate="yes" xml:space="preserve">
          <source>N/A means not accessible.</source>
          <target state="translated">N / A는 액세스 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0604b491f5fa41cfffff730fb0a22dcd65418e3f" translate="yes" xml:space="preserve">
          <source>N1</source>
          <target state="translated">N1</target>
        </trans-unit>
        <trans-unit id="65bb4fc755e8bb11ccb0ee8cbfedee5528535446" translate="yes" xml:space="preserve">
          <source>N2</source>
          <target state="translated">N2</target>
        </trans-unit>
        <trans-unit id="70c7d4c52124c93b637e59dd435f7ca991164c3f" translate="yes" xml:space="preserve">
          <source>N3</source>
          <target state="translated">N3</target>
        </trans-unit>
        <trans-unit id="ce71d863e71837e0ee26dc56978e19026728b6e0" translate="yes" xml:space="preserve">
          <source>N4</source>
          <target state="translated">N4</target>
        </trans-unit>
        <trans-unit id="d3406dc507b393378bb88f5316f07b7c31cea1fd" translate="yes" xml:space="preserve">
          <source>N5</source>
          <target state="translated">N5</target>
        </trans-unit>
        <trans-unit id="ee2493b90e1342d0219ace167d7fdfeb9ab6a044" translate="yes" xml:space="preserve">
          <source>NC</source>
          <target state="translated">NC</target>
        </trans-unit>
        <trans-unit id="c03fd3d8effb17b3c70ec90a280bc5eddbf1a748" translate="yes" xml:space="preserve">
          <source>NETCONF client module compliant with RFC 6241, NETCONF Configuration Protocol, and RFC 6242, Using the NETCONF Configuration Protocol over Secure SHell (SSH), and with support for RFC 5277, NETCONF Event Notifications.</source>
          <target state="translated">NETCONF 클라이언트 모듈은 RFC 6241, NETCONF 구성 프로토콜 및 RFC 6242, SSH (보안 SHell)를 통한 NETCONF 구성 프로토콜 사용 및 RFC 5277, NETCONF 이벤트 알림을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="66bebc7980918515be0940e1250f00a7cdb2a30c" translate="yes" xml:space="preserve">
          <source>NETCONF client module.</source>
          <target state="translated">NETCONF 클라이언트 모듈.</target>
        </trans-unit>
        <trans-unit id="b64c6c7cdb62874f32c03bc2fb48dabf64192bed" translate="yes" xml:space="preserve">
          <source>NETCONF sessions can either be opened by a single call to &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; or by a call to &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1,2&lt;/a&gt;&lt;/code&gt; followed by one or more calls to &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1,2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">NETCONF 세션은 &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; 에 대한 단일 호출 또는 &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1,2&lt;/a&gt;&lt;/code&gt; 에 대한 호출에 이어 &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1,2,3&lt;/a&gt;&lt;/code&gt; 에 대한 하나 이상의 호출에 의해 열립니다 .</target>
        </trans-unit>
        <trans-unit id="6cc17604486656396f55bda1048a9ca72c9fb9fd" translate="yes" xml:space="preserve">
          <source>NETCONF traffic is not logged.</source>
          <target state="translated">NETCONF 트래픽이 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57b93faae8cfee3611b3f0966ad1cb1ad092f30f" translate="yes" xml:space="preserve">
          <source>NIF libraries are loaded by calling &lt;code&gt;erlang:load_nif/2&lt;/code&gt;, with the name of the shared library as argument. The second argument can be any term that will be passed on to the library and used for initialization:</source>
          <target state="translated">NIF 라이브러리는 공유 라이브러리의 이름을 인수로 사용하여 &lt;code&gt;erlang:load_nif/2&lt;/code&gt; 를 호출하여로드됩니다 . 두 번째 인수는 라이브러리로 전달되어 초기화에 사용될 모든 용어 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7f5adb8aa2205182a8ae0d0874dfd09d3d15439" translate="yes" xml:space="preserve">
          <source>NIFs were introduced in Erlang/OTP R13B03 as an experimental feature. It is a simpler and more efficient way of calling C-code than using port drivers. NIFs are most suitable for synchronous functions, such as &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; in the example, that do some relatively short calculations without side effects and return the result.</source>
          <target state="translated">실험 기능으로 Erlang / OTP R13B03에 NIF가 도입되었습니다. 포트 드라이버를 사용하는 것보다 C 코드를 호출하는보다 간단하고 효율적인 방법입니다. NIF는 예제에서 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 와 같은 동기 함수에 가장 적합하며 부작용없이 비교적 짧은 계산을 수행하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="56815d5677a168f7684f66e9c1b9a9615a0991c1" translate="yes" xml:space="preserve">
          <source>NOTE: It is important that source on the windows disk.</source>
          <target state="translated">참고 : Windows 디스크의 소스가 중요합니다.</target>
        </trans-unit>
        <trans-unit id="dc50c726c2ad84ad90f8b5f7018cdda7d604c92c" translate="yes" xml:space="preserve">
          <source>NPTL glibc is strongly preferred, or a LinuxThreads glibc configured for &quot;floating stacks&quot;. Old non-floating stacks glibcs have a fundamental problem that makes HiPE support and threads support mutually exclusive.</source>
          <target state="translated">NPTL glibc가 강력하게 선호되거나 &quot;부동 스택&quot;을 위해 구성된 LinuxThreads glibc. 오래된 비 부동 스택 glibcs는 HiPE 지원과 스레드 지원이 상호 배타적이라는 근본적인 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a707e05e3576a19dcc3c4c0b3a0f37a4d4a79406" translate="yes" xml:space="preserve">
          <source>NUMA node identifiers are system wide. That is, each NUMA node on the system must have a unique identifier. Processor identifiers are also system wide. Core identifiers are processor wide. Thread identifiers are core wide.</source>
          <target state="translated">NUMA 노드 식별자는 시스템 전체입니다. 즉, 시스템의 각 NUMA 노드에는 고유 식별자가 있어야합니다. 프로세서 식별자도 시스템 전체에 적용됩니다. 코어 식별자는 프로세서 전체에 적용됩니다. 스레드 식별자는 코어 전체입니다.</target>
        </trans-unit>
        <trans-unit id="96ca732e61f2bdd45036bc7061a358ac23542609" translate="yes" xml:space="preserve">
          <source>NUMERIC (precision, scale), DECIMAL (precision, scale), DEC (precision, scale ) precision - total number of digits, scale - total number of decimal places</source>
          <target state="translated">NUMERIC (정밀도, 스케일), DECIMAL (정밀도, 스케일), DEC (정밀도, 스케일) 정밀도-총 자릿수, 스케일-총 소수점 자릿수</target>
        </trans-unit>
        <trans-unit id="5c4cdee3ac47988555d2e4826cdf0ce2779c7bcd" translate="yes" xml:space="preserve">
          <source>Nabataean</source>
          <target state="translated">Nabataean</target>
        </trans-unit>
        <trans-unit id="49842eacbc9108e11c13f4f1a82e44c7d5e94e3e" translate="yes" xml:space="preserve">
          <source>Name = atom()</source>
          <target state="translated">이름 = atom ()</target>
        </trans-unit>
        <trans-unit id="26e8e343acf0543965774a3ea971fea3f354d4ad" translate="yes" xml:space="preserve">
          <source>Name Resolving</source>
          <target state="translated">이름 확인</target>
        </trans-unit>
        <trans-unit id="09b603578ce92bd3efd6f652e0314619369218a8" translate="yes" xml:space="preserve">
          <source>Name and value of a TFTP option.</source>
          <target state="translated">TFTP 옵션의 이름과 값.</target>
        </trans-unit>
        <trans-unit id="c0f9e377e9e709bae968b8e8e63298cf66b15bba" translate="yes" xml:space="preserve">
          <source>Name collisions is another unwanted effect that can occur in multi file-compilation. The compiler solves this problem in one of two ways:</source>
          <target state="translated">이름 충돌은 다중 파일 컴파일에서 발생할 수있는 다른 원치 않는 효과입니다. 컴파일러는 다음 두 가지 방법 중 하나로이 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="8fcf8ecda81b9b18e00c6dd548525fd833fd2355" translate="yes" xml:space="preserve">
          <source>Name identifying a Diameter application in service configuration. Passed to &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; when sending requests defined by the application.</source>
          <target state="translated">서비스 구성에서 직경 애플리케이션을 식별하는 이름입니다. 응용 프로그램에서 정의한 요청을 보낼 때 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="71819df6815dce60c7b749d24399fc212153d954" translate="yes" xml:space="preserve">
          <source>Name listing, that is, gives a list of all names registered on the host</source>
          <target state="translated">이름 목록, 즉 호스트에 등록 된 모든 이름 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8558c62ee07217f1a409e574c1eed556f16d0d5a" translate="yes" xml:space="preserve">
          <source>Name of a configuration parameter.</source>
          <target state="translated">구성 매개 변수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="fdd675b8843afe95f166148e521e9af5572f2c5b" translate="yes" xml:space="preserve">
          <source>Name of a service as passed to &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; and with which the service is identified. There can be at most one service with a given name on a given node. Note that &lt;code&gt;erlang:make_ref/0&lt;/code&gt; can be used to generate a service name that is somewhat unique.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; 에 전달되고 서비스가 식별되는 서비스의 이름입니다. 주어진 노드에는 주어진 이름을 가진 서비스가 하나만있을 수 있습니다. 참고 &lt;code&gt;erlang:make_ref/0&lt;/code&gt; 다소 고유 한 서비스 이름을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9e1cf8d6c3186f4d60ebb503a782d0a2af71404" translate="yes" xml:space="preserve">
          <source>Name of an application included in the release.</source>
          <target state="translated">릴리스에 포함 된 응용 프로그램의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8f09bbb27e998d8b4e1d54c80a6e9f9e419ecbbe" translate="yes" xml:space="preserve">
          <source>Name of an encode/decode module for the Diameter messages defined by the application. These modules are generated from files whose format is documented in &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램에서 정의한 직경 메시지에 대한 인코딩 / 디코딩 모듈의 이름입니다. 이 모듈은 형식이 &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; 문서화 된 파일에서 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="fea55da9488bc6b080a2d195d952706c2922e0f1" translate="yes" xml:space="preserve">
          <source>Name of another &lt;code&gt;.config&lt;/code&gt; file. Extension &lt;code&gt;.config&lt;/code&gt; can be omitted. It is recommended to use absolute paths. If a relative path is used, &lt;code&gt;File&lt;/code&gt; is searched, first, relative from &lt;code&gt;sys.config&lt;/code&gt; directory, then relative to the current working directory of the emulator, for backward compatibility. This allow to use a &lt;code&gt;sys.config&lt;/code&gt; pointing out other &lt;code&gt;.config&lt;/code&gt; files in a release or in a node started manually using &lt;code&gt;-config ...&lt;/code&gt; with same result whatever the current working directory.</source>
          <target state="translated">다른 &lt;code&gt;.config&lt;/code&gt; 파일의 이름 확장자 &lt;code&gt;.config&lt;/code&gt; 는 생략 할 수 있습니다. 절대 경로를 사용하는 것이 좋습니다. 상대 경로가 사용되는 경우, &lt;code&gt;File&lt;/code&gt; 은 먼저 &lt;code&gt;sys.config&lt;/code&gt; 디렉토리를 기준으로 검색 한 후 에뮬레이터의 현재 작업 디렉토리를 기준으로 이전 버전과의 호환성을 위해 검색됩니다. 이를 통해 &lt;code&gt;sys.config&lt;/code&gt; 를 사용하여 릴리스의 다른 &lt;code&gt;.config&lt;/code&gt; 파일을 가리 키 거나 &lt;code&gt;-config ...&lt;/code&gt; 를 사용하여 수동으로 시작한 노드 에서 현재 작업 디렉토리에 관계없이 동일한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6861f1ccaff61ef5f193977a356660fc3597d944" translate="yes" xml:space="preserve">
          <source>Name of the module implementing the service-specific parts of the channel.</source>
          <target state="translated">채널의 서비스 별 부분을 구현하는 모듈의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="22d1ae1c673a94829dfb8e83a7bb9cf9e8965d80" translate="yes" xml:space="preserve">
          <source>Name of the node that the event originated from (only relevant for &lt;code&gt;Common Test&lt;/code&gt; Master event handlers).</source>
          <target state="translated">이벤트가 시작된 노드의 이름입니다 ( &lt;code&gt;Common Test&lt;/code&gt; 마스터 이벤트 핸들러 에만 해당 ).</target>
        </trans-unit>
        <trans-unit id="b760b08100c634abc56d0ded647804bdc7f195fd" translate="yes" xml:space="preserve">
          <source>Name of the other node. This field is only mandatory when this node initiates the connection. That is, when connection is set up via &lt;code&gt;&lt;a href=&quot;#setup&quot;&gt;setup/5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 노드의 이름 이 필드는이 노드가 연결을 시작할 때만 필수입니다. 즉, &lt;code&gt;&lt;a href=&quot;#setup&quot;&gt;setup/5&lt;/a&gt;&lt;/code&gt; 를 통해 연결이 설정된 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="dc0f0987cfc3071fee54739de9248fcf0b3b84b9" translate="yes" xml:space="preserve">
          <source>Name of the profile, see &lt;code&gt;&lt;a href=&quot;#DATA_TYPES&quot;&gt;DATA TYPES&lt;/a&gt;&lt;/code&gt;. This option is mandatory.</source>
          <target state="translated">프로파일의 이름은 &lt;code&gt;&lt;a href=&quot;#DATA_TYPES&quot;&gt;DATA TYPES&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 . 이 옵션은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="7ca26e64b9064a42da13098416e3e7bb4bf4ed2c" translate="yes" xml:space="preserve">
          <source>Name of the reporting supervisor.</source>
          <target state="translated">보고 감독자의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="dfdc16cf0a3aafa431b5fbcdc7de5f060dd8e75e" translate="yes" xml:space="preserve">
          <source>Name of the security data file. The filename can either be absolute or relative to the &lt;code&gt;server_root&lt;/code&gt;. This file is used to store persistent data for module &lt;code&gt;mod_security&lt;/code&gt;.</source>
          <target state="translated">보안 데이터 파일의 이름입니다. 파일 이름은 &lt;code&gt;server_root&lt;/code&gt; 에 대해 절대적이거나 상대적 일 수 있습니다 . 이 파일은 &lt;code&gt;mod_security&lt;/code&gt; 모듈의 영구 데이터를 저장하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="815591c3d2946d084be9c0e9370d8e5d2a5e8031" translate="yes" xml:space="preserve">
          <source>Name of the user callback module. See the the reference manual for megaco_user for more info.</source>
          <target state="translated">사용자 콜백 모듈의 이름입니다. 자세한 내용은 megaco_user의 참조 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f29ab265b46a1c65a2110325442c0296db3b5e7b" translate="yes" xml:space="preserve">
          <source>Name specification to use when starting a &lt;code&gt;gen_statem&lt;/code&gt; server. See &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;server_ref()&lt;/a&gt;&lt;/code&gt; below.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 서버를 시작할 때 사용할 이름 스펙 . 아래의 &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;server_ref()&lt;/a&gt;&lt;/code&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b8f752f803e242b87f3c03a4082c687998ac3da7" translate="yes" xml:space="preserve">
          <source>Named lock or named set of locks (classes). The same name used for initializing the lock in the VM.</source>
          <target state="translated">명명 된 잠금 또는 명명 된 잠금 세트 (클래스). VM에서 잠금을 초기화하는 데 사용 된 것과 동일한 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2b7c08c3ab75f37e2da656c1aab228f5f3a793b1" translate="yes" xml:space="preserve">
          <source>Names</source>
          <target state="translated">Names</target>
        </trans-unit>
        <trans-unit id="28c4c1865ec1cbfe19fb070c31f8a53818589235" translate="yes" xml:space="preserve">
          <source>Names consist of up to 32 alphanumeric characters and underscores, but must start with a non-digit. Named capturing parentheses are still allocated numbers as well as names, exactly as if the names were not present. The &lt;code&gt;capture&lt;/code&gt; specification to &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt; run/3&lt;/a&gt;&lt;/code&gt; can use named values if they are present in the regular expression.</source>
          <target state="translated">이름은 최대 32 자의 영숫자와 밑줄로 구성되지만 숫자가 아닌 문자로 시작해야합니다. 이름이 지정된 캡처 링 괄호는 이름이없는 것처럼 정확히 이름과 함께 할당 된 숫자입니다. &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt; run/3&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;capture&lt;/code&gt; 스펙 은 정규식에있는 경우 명명 된 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9dd77b6e1709773eb7654ae6b320bce9c21508d" translate="yes" xml:space="preserve">
          <source>Names consist of up to 32 alphanumeric characters and underscores, but must start with a non-digit. Named capturing parentheses are still allocated numbers as well as names, exactly as if the names were not present. The &lt;code&gt;capture&lt;/code&gt; specification to &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; can use named values if they are present in the regular expression.</source>
          <target state="translated">이름은 최대 32 자의 영숫자와 밑줄로 구성되지만 숫자가 아닌 숫자로 시작해야합니다. 명명 된 캡처 괄호에는 이름이없는 것처럼 정확하게 이름뿐만 아니라 숫자도 할당됩니다. &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;capture&lt;/code&gt; 스펙은 명명 된 값이 정규식에있는 경우 명명 된 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7093792812d2bcab51e7c92258df5d9e6b4b018a" translate="yes" xml:space="preserve">
          <source>Names of files needed by the test</source>
          <target state="translated">테스트에 필요한 파일 이름</target>
        </trans-unit>
        <trans-unit id="7257f798528c7c674ee2f8465b8c5680983ef6ca" translate="yes" xml:space="preserve">
          <source>Names of programs to be executed during the test</source>
          <target state="translated">테스트 중에 실행될 프로그램의 이름</target>
        </trans-unit>
        <trans-unit id="8df9c18f0f6605c9864c1c03438f7d9bd20d3dfe" translate="yes" xml:space="preserve">
          <source>Names used to identify capturing subpatterns need not be unique. This can be helpful for certain types of pattern when it is known that only one instance of the named subpattern can ever be matched. More details of named subpatterns are provided below.</source>
          <target state="translated">캡처 하위 패턴을 식별하는 데 사용되는 이름은 고유하지 않아도됩니다. 명명 된 하위 패턴의 인스턴스 하나만 일치 할 수있는 것으로 알려진 경우 특정 유형의 패턴에 유용합니다. 명명 된 하위 패턴에 대한 자세한 내용은 아래에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="400c3476c738eefb94528ac0d99970ee7cad1461" translate="yes" xml:space="preserve">
          <source>Nameservers</source>
          <target state="translated">Nameservers</target>
        </trans-unit>
        <trans-unit id="d081bf458b12ded79224fc426e9b704fda3eb830" translate="yes" xml:space="preserve">
          <source>Nanoseconds</source>
          <target state="translated">Nanoseconds</target>
        </trans-unit>
        <trans-unit id="69fd8f514808c906504e870b76d0ad25cb1a2810" translate="yes" xml:space="preserve">
          <source>Narrow no-break space</source>
          <target state="translated">좁은 휴식 공간</target>
        </trans-unit>
        <trans-unit id="19cf0fcc0b86f78ec04f6f1388bfa92de80267cc" translate="yes" xml:space="preserve">
          <source>Native atomic implementation in the order preferred:</source>
          <target state="translated">선호 순서대로 기본 원자 구현 :</target>
        </trans-unit>
        <trans-unit id="f4ceb03af949e9762ac45be133b29937865498db" translate="yes" xml:space="preserve">
          <source>Native lookup (system calls) is always the default resolver method. This is true for all platforms, except VxWorks and OSE Delta where &lt;code&gt;'file'&lt;/code&gt; or &lt;code&gt;'dns'&lt;/code&gt; is used (in that priority order).</source>
          <target state="translated">기본 조회 (시스템 호출)는 항상 기본 해결 방법입니다. 이는 &lt;code&gt;'file'&lt;/code&gt; 또는 &lt;code&gt;'dns'&lt;/code&gt; 가 사용되는 VxWorks 및 OSE Delta를 제외한 모든 플랫폼에 적용 됩니다 (우선 순위 순).</target>
        </trans-unit>
        <trans-unit id="2f3e991d2e06301019e7df6974c400874b1e24a9" translate="yes" xml:space="preserve">
          <source>Native-endian means that the endianness is resolved at load time to be either big-endian or little-endian, depending on what is native for the CPU that the Erlang machine is run on. Endianness only matters when the Type is either &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, &lt;code&gt;utf32&lt;/code&gt;, or &lt;code&gt;float&lt;/code&gt;. The default is &lt;code&gt;big&lt;/code&gt;.</source>
          <target state="translated">기본 엔디안은 Erlang 시스템이 실행되는 CPU의 기본 설정에 따라로드시 엔디안이 빅 엔디안 또는 리틀 엔디안으로 해석됨을 의미합니다. 엔디안은 Type이 &lt;code&gt;integer&lt;/code&gt; , &lt;code&gt;utf16&lt;/code&gt; , &lt;code&gt;utf32&lt;/code&gt; 또는 &lt;code&gt;float&lt;/code&gt; 인 경우에만 중요합니다 . 기본값은 &lt;code&gt;big&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="88ec7eb1fe551ab56659dcb328c9e9308618cdd5" translate="yes" xml:space="preserve">
          <source>Need 10 bytes, plus the space for the node name, which is an atom.</source>
          <target state="translated">10 바이트와 노드 이름을위한 공간 (아톰)이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="dfe1c4e24186450c5c19fcf8debfad6318586391" translate="yes" xml:space="preserve">
          <source>Need 3 bytes, plus 1 byte for each character (the terminating 0 is not encoded). Really long strings (more than 64k characters) are encoded as lists. Atoms cannot contain more than 256 characters.</source>
          <target state="translated">각 문자에 3 바이트와 1 바이트가 필요합니다 (종료 0은 인코딩되지 않음). 실제로 긴 문자열 (64k 문자 이상)은 목록으로 인코딩됩니다. 원자는 256자를 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6a2629810e6dae5fd2ed18399d49c9f6234b2d75" translate="yes" xml:space="preserve">
          <source>Need 32 bytes.</source>
          <target state="translated">32 바이트가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="dd1ab6a463a6a8cb3b094e2a5ffe579607280a5c" translate="yes" xml:space="preserve">
          <source>Need 5 bytes, plus the space for each element, and 1 more byte for the empty list at the end.</source>
          <target state="translated">5 바이트와 각 요소에 공백이 필요하고 끝에 빈 목록에 1 바이트가 더 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0331bba0a243dd4f934fa2e9828a630bcd871f86" translate="yes" xml:space="preserve">
          <source>Need 5 bytes, plus the space for each element.</source>
          <target state="translated">5 바이트와 각 요소에 대한 공간이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c0aabf92511a79ab04e6d0216eff8b4f3d2d00af" translate="yes" xml:space="preserve">
          <source>Need 5 bytes.</source>
          <target state="translated">5 바이트가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="175e1f869033a45b5e96e2f6f2ecaeb8e97b007a" translate="yes" xml:space="preserve">
          <source>Need 6 bytes, plus the space for the node name, which is an atom.</source>
          <target state="translated">6 바이트와 노드 이름을위한 공간 (아톰)이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1156c7af2383ba07233854d7dd710d317bc45336" translate="yes" xml:space="preserve">
          <source>Negate a filter.</source>
          <target state="translated">필터를 무효화하십시오.</target>
        </trans-unit>
        <trans-unit id="20692085423110f20958119048a05722032e1bc2" translate="yes" xml:space="preserve">
          <source>Negate the class, but only if the first character</source>
          <target state="translated">첫 번째 캐릭터 인 경우에만 클래스 무효화</target>
        </trans-unit>
        <trans-unit id="f153dc3672bdd71d80e9c27aa57b80cf24f1ae5f" translate="yes" xml:space="preserve">
          <source>Negated character class, which matches any character except &lt;code&gt;abc...&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;abc...&lt;/code&gt; 제외한 모든 문자와 일치하는 부정 문자 클래스 .</target>
        </trans-unit>
        <trans-unit id="de3797823858d972e58f40676bf0b9c8044164ac" translate="yes" xml:space="preserve">
          <source>Negated versions, such as [:^alpha:], use \P instead of \p. Three other POSIX classes are handled specially in UCP mode:</source>
          <target state="translated">[: ^ alpha :]와 같은 부정 버전은 \ p 대신 \ P를 사용합니다. 다른 세 가지 POSIX 클래스는 UCP 모드에서 특별히 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="ea9c2b442d3489fafed30d313fd4bb83f3a5f3ae" translate="yes" xml:space="preserve">
          <source>Negates its single argument (anything other than &lt;code&gt;false&lt;/code&gt; gives &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">그 하나의 인자 (보다 다른 것을 부정 &lt;code&gt;false&lt;/code&gt; 제공 &lt;code&gt;false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9ed6e5275d882c1d7a3e78254834d37cdc3ae869" translate="yes" xml:space="preserve">
          <source>Negative assertions are, however, different, to ensure that changing a positive assertion into a negative assertion changes its result. Backtracking into (*COMMIT), (*SKIP), or (*PRUNE) causes a negative assertion to be true, without considering any further alternative branches in the assertion. Backtracking into (*THEN) causes it to skip to the next enclosing alternative within the assertion (the normal behavior), but if the assertion does not have such an alternative, (*THEN) behaves like (*PRUNE).</source>
          <target state="translated">그러나 긍정 주장을 부정 주장으로 변경하면 결과가 변경되도록 부정 주장이 다릅니다. (* COMMIT), (* SKIP) 또는 (* PRUNE)으로 역 추적하면 어설 션의 추가 대체 분기를 고려하지 않고 부정적인 어설 션이 적용됩니다. (* THEN)으로 역 추적하면 어설 션 내의 다음 둘러싸는 대체 (일반 동작)로 건너 뛰지 만 어설 션에 이러한 대체가없는 경우 (* THEN)은 (* PRUNE)과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ebf32ee53eee5495ff25445bebe98e3b2f6d93ca" translate="yes" xml:space="preserve">
          <source>Negative length can be used to extract bytes at the end of a binary, for example:</source>
          <target state="translated">음수 길이는 이진이 끝날 때 바이트를 추출하는 데 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef697431c2b7bdf995c5f37d8fc7eec02af8d561" translate="yes" xml:space="preserve">
          <source>Negotiated Groups</source>
          <target state="translated">협상 된 그룹</target>
        </trans-unit>
        <trans-unit id="b5a05483241f86212e46d2efad89e6999eecd1d1" translate="yes" xml:space="preserve">
          <source>Nested test cases:</source>
          <target state="translated">중첩 된 테스트 사례 :</target>
        </trans-unit>
        <trans-unit id="127f49081f658cece5f3811cf0dc1334ffa1512f" translate="yes" xml:space="preserve">
          <source>Nested transactions</source>
          <target state="translated">중첩 된 거래</target>
        </trans-unit>
        <trans-unit id="9d178bd65e3d29cc6434618a4937bb2f5c582992" translate="yes" xml:space="preserve">
          <source>Net if must send the following message when it receives an SNMP PDU from the network that is aimed for the MasterAgent:</source>
          <target state="translated">MasterAgent를 대상으로하는 네트워크에서 SNMP PDU를 수신 할 때 다음 메시지를 보내야하는 경우 Net :</target>
        </trans-unit>
        <trans-unit id="8f62bf25b466c186d1af5cfde979303cd21e7891" translate="yes" xml:space="preserve">
          <source>Net load mode. Loads all recompiled modules on all known nodes.</source>
          <target state="translated">순 하중 모드. 알려진 모든 노드에서 재 컴파일 된 모든 모듈을로드합니다.</target>
        </trans-unit>
        <trans-unit id="0114e1a690d0d3b69edf39a672c8130542ac6aac" translate="yes" xml:space="preserve">
          <source>Net tick time-out.</source>
          <target state="translated">순 틱 시간 초과.</target>
        </trans-unit>
        <trans-unit id="3ee6be7a9d02660b3a4c34bd8c49e09d465d52a8" translate="yes" xml:space="preserve">
          <source>Network address and service translation.</source>
          <target state="translated">네트워크 주소 및 서비스 변환.</target>
        </trans-unit>
        <trans-unit id="80b9638cdf66c48bf06a6a5ecf503be992cbcebf" translate="yes" xml:space="preserve">
          <source>Network interface.</source>
          <target state="translated">네트워크 인터페이스.</target>
        </trans-unit>
        <trans-unit id="110548035d847260e8d0a9e8d8ce3832b7e46903" translate="yes" xml:space="preserve">
          <source>Never derefrence aliases, treat aliases as entries.</source>
          <target state="translated">별칭을 무시하지 말고 별칭을 항목으로 취급하십시오.</target>
        </trans-unit>
        <trans-unit id="225ec74e73e8bc4eb82cef59bdadd070f326267c" translate="yes" xml:space="preserve">
          <source>New / Delete Operations</source>
          <target state="translated">신규 / 삭제 작업</target>
        </trans-unit>
        <trans-unit id="daa1ec0c63bdc175afef3521716bd266db3aa640" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;InfoItem&lt;/code&gt;s can be added and old undocumented &lt;code&gt;InfoItem&lt;/code&gt;s can be removed without notice.</source>
          <target state="translated">새로운 &lt;code&gt;InfoItem&lt;/code&gt; 을 추가 할 수 있고, 문서화되지 않은 오래된 &lt;code&gt;InfoItem&lt;/code&gt; 을 예고없이 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65a81bf26d684841baa361ac6ddd6963f7889e13" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;InfoKey&lt;/code&gt;s can be added and old undocumented &lt;code&gt;InfoKey&lt;/code&gt;s can be removed without notice.</source>
          <target state="translated">새로운 &lt;code&gt;InfoKey&lt;/code&gt; 를 추가 할 수 있으며, 문서화되지 않은 오래된 &lt;code&gt;InfoKey&lt;/code&gt; 를 예고없이 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04d21f5a0f5485bf2ef2e4808496c8082ff1168d" translate="yes" xml:space="preserve">
          <source>New API</source>
          <target state="translated">새로운 API</target>
        </trans-unit>
        <trans-unit id="25dfab9ef64421c944663406fd9382ff81ddcbe8" translate="yes" xml:space="preserve">
          <source>New AVPs can be defined using the dictionary interface. Both RFC data formats and extensions are supported.</source>
          <target state="translated">사전 인터페이스를 사용하여 새로운 AVP를 정의 할 수 있습니다. RFC 데이터 형식 및 확장이 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6f85697e78940a14b00420d0acefc501d482f7c5" translate="yes" xml:space="preserve">
          <source>New Erlang Monotonic Time</source>
          <target state="translated">새로운 얼랑 단조로운 시간</target>
        </trans-unit>
        <trans-unit id="5416773a10d805e30e6f5bc99d1554c94eafc798" translate="yes" xml:space="preserve">
          <source>New applications can be defined using the dictionary interface.</source>
          <target state="translated">사전 인터페이스를 사용하여 새로운 응용 프로그램을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="416932539df1b3d2d48bade29a12d73c261c20c5" translate="yes" xml:space="preserve">
          <source>New commands can be defined using the dictionary interface.</source>
          <target state="translated">사전 인터페이스를 사용하여 새 명령을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03915f753991cfd0758ccd0006c587629ef3a527" translate="yes" xml:space="preserve">
          <source>New instructions must be added at the end of the file, with higher numbers than the previous instructions.</source>
          <target state="translated">새 지침은 이전 지침보다 높은 번호로 파일 끝에 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="b21bafe5e2b543d12417c1f410bfa49ddc920dfa" translate="yes" xml:space="preserve">
          <source>New maps can include multiple associations at construction by listing every association:</source>
          <target state="translated">새 맵에는 모든 연관을 나열하여 구성시 여러 연관을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6664f56a53edf8b2fadc61d9507782caf98822df" translate="yes" xml:space="preserve">
          <source>New replicas can be added before all other replicas of the table have been loaded, provided that at least one other replica is active.</source>
          <target state="translated">하나 이상의 다른 복제본이 활성화되어 있으면 테이블의 다른 모든 복제본을로드하기 전에 새 복제본을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d04bdf4b4e76aa242a32e437a5883cf844d9d4b7" translate="yes" xml:space="preserve">
          <source>New schemas are created explicitly with the function &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema/1&lt;/a&gt;&lt;/code&gt; or implicitly by starting &lt;code&gt;Mnesia&lt;/code&gt; without a disc resident schema. Whenever a table (including the schema table) is created, it is assigned its own unique cookie. The schema table is not created with the function &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table/2&lt;/a&gt;&lt;/code&gt; as normal tables.</source>
          <target state="translated">새 스키마는 &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 명시 적으로 작성 하거나 디스크 상주 스키마없이 &lt;code&gt;Mnesia&lt;/code&gt; 를 시작하여 내재적으로 작성 합니다. 테이블 (스키마 테이블 포함)을 만들 때마다 고유 한 쿠키가 할당됩니다. 스키마 테이블은 &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table/2&lt;/a&gt;&lt;/code&gt; 함수 를 일반 테이블로 사용하여 작성되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b998dd3bf2b993a54515b2681267a6568c0a6475" translate="yes" xml:space="preserve">
          <source>New shell (&lt;code&gt;erlang-shell&lt;/code&gt;) - Starts a new Erlang shell.</source>
          <target state="translated">새 쉘 ( &lt;code&gt;erlang-shell&lt;/code&gt; )-새 Erlang 쉘을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d6fab7333579c2c88a17284641c16835218f93ad" translate="yes" xml:space="preserve">
          <source>New tagged tuples may be added in the resulting list at any time.</source>
          <target state="translated">새로운 태그 된 튜플은 언제든지 결과 목록에 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="536da4d36da096022ab2eba3a4c7b2072e6bab86" translate="yes" xml:space="preserve">
          <source>New time functionality and a new time API was introduced. For more information see the &lt;code&gt;Time and Time Correction&lt;/code&gt; chapter in the ERTS User's guide and specifically the &lt;code&gt;Dos and Donts&lt;/code&gt; section on how to replace usage of &lt;code&gt;erlang:now/0&lt;/code&gt;.</source>
          <target state="translated">새로운 시간 기능과 새로운 시간 API가 도입되었습니다. 자세한 내용 은 ERTS 사용자 가이드 의 &lt;code&gt;Time and Time Correction&lt;/code&gt; 장과 특히 &lt;code&gt;erlang:now/0&lt;/code&gt; 사용을 대체하는 방법에 대한해야 할 &lt;code&gt;Dos and Donts&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa4c2977862e2e3f49c4b7dd716229ca641b9204" translate="yes" xml:space="preserve">
          <source>New warnings may be issued between releases.</source>
          <target state="translated">릴리스간에 새로운 경고가 발행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e065f7f968be75fb2dabe72e66ffd9f54ef07c5e" translate="yes" xml:space="preserve">
          <source>NewVal :: integer()</source>
          <target state="translated">NewVal :: 정수 ()</target>
        </trans-unit>
        <trans-unit id="47cc38a5f6affc6fd9f8a8683e76dfafa574aed8" translate="yes" xml:space="preserve">
          <source>New_Tai_Lue</source>
          <target state="translated">New_Tai_Lue</target>
        </trans-unit>
        <trans-unit id="d706a7f27906e3a8bf4f4fed0f9c3d7edc4a240a" translate="yes" xml:space="preserve">
          <source>Newline</source>
          <target state="translated">Newline</target>
        </trans-unit>
        <trans-unit id="808b78209485244b8997d57758391c54f156212c" translate="yes" xml:space="preserve">
          <source>Newline (line feed).</source>
          <target state="translated">줄 바꿈 (줄 바꿈).</target>
        </trans-unit>
        <trans-unit id="5afff985ebf32e8270418f54db6417fb06d959ae" translate="yes" xml:space="preserve">
          <source>Newline is indicated by a single character &lt;code&gt;cr&lt;/code&gt; (ASCII 13).</source>
          <target state="translated">줄 바꿈은 단일 문자 &lt;code&gt;cr&lt;/code&gt; (ASCII 13)로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e0b583b651d9a2285954a06341ac73241bded628" translate="yes" xml:space="preserve">
          <source>Newline is indicated by a single character CR (ASCII 13).</source>
          <target state="translated">줄 바꿈은 단일 문자 CR (ASCII 13)로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9187e5ffa24cd194b0938789b60c4fc382a957ab" translate="yes" xml:space="preserve">
          <source>Newline is indicated by a single character LF (ASCII 10), the default.</source>
          <target state="translated">줄 바꿈은 기본적으로 단일 문자 LF (ASCII 10)로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d601bad3ec62c50f75f6a3ba9573e21733220395" translate="yes" xml:space="preserve">
          <source>Newline is indicated by the two-character CRLF (ASCII 13 followed by ASCII 10) sequence.</source>
          <target state="translated">줄 바꿈은 두 문자 CRLF (ASCII 13 뒤에 ASCII 10) 순서로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="18d8a520a75d3617fd621fe2e386b1424f0b50e7" translate="yes" xml:space="preserve">
          <source>Next come the &lt;code&gt;grammar rules&lt;/code&gt;. Each rule has the general form</source>
          <target state="translated">다음은 &lt;code&gt;grammar rules&lt;/code&gt; 입니다. 각 규칙에는 일반적인 형식이 있습니다</target>
        </trans-unit>
        <trans-unit id="857695141b6b6a959a5e9f08218ec562945d5a77" translate="yes" xml:space="preserve">
          <source>Next comes a declaration of the &lt;code&gt;nonterminal categories&lt;/code&gt; to be used in the rules. For example:</source>
          <target state="translated">다음은 규칙에 사용될 &lt;code&gt;nonterminal categories&lt;/code&gt; 의 선언입니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e83a4b5708be5e10a3a091382f374fd5808b3211" translate="yes" xml:space="preserve">
          <source>Next comes a declaration of the &lt;code&gt;rootsymbol&lt;/code&gt;, or start category of the grammar. For example:</source>
          <target state="translated">다음은 &lt;code&gt;rootsymbol&lt;/code&gt; 또는 문법의 시작 범주에 대한 선언입니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fef9750a2a463281a998e47d19f0d0871be00c7d" translate="yes" xml:space="preserve">
          <source>Next comes a declaration of the &lt;code&gt;terminal categories&lt;/code&gt;, which are the categories of tokens produced by the scanner. For example:</source>
          <target state="translated">다음은 스캐너가 생성 한 토큰의 범주 인 &lt;code&gt;terminal categories&lt;/code&gt; 의 선언입니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9e370493e9e17b4819d6f79d261d079cacde553" translate="yes" xml:space="preserve">
          <source>Next comes one or more declarations of &lt;code&gt;operator precedences&lt;/code&gt;, if needed. These are used to resolve shift/reduce conflicts (see &lt;code&gt;yacc&lt;/code&gt; documentation).</source>
          <target state="translated">다음은 필요한 경우 &lt;code&gt;operator precedences&lt;/code&gt; 선언을 하나 이상 제공 합니다. 이들은 교대 / 감소 충돌을 해결하는 데 사용됩니다 ( &lt;code&gt;yacc&lt;/code&gt; 설명서 참조 ).</target>
        </trans-unit>
        <trans-unit id="0f7553f74bd8b74cc4fcc22ad756157cb5776f2f" translate="yes" xml:space="preserve">
          <source>Next is an example of using &lt;code&gt;after&lt;/code&gt;. This closes the file, even in the event of exceptions in &lt;code&gt;file:read/2&lt;/code&gt; or in &lt;code&gt;binary_to_term/1&lt;/code&gt;. The exceptions are the same as without the &lt;code&gt;try&lt;/code&gt;...&lt;code&gt;after&lt;/code&gt;...&lt;code&gt;end&lt;/code&gt; expression:</source>
          <target state="translated">다음은 &lt;code&gt;after&lt;/code&gt; 를 사용하는 예입니다 . &lt;code&gt;file:read/2&lt;/code&gt; 또는 &lt;code&gt;binary_to_term/1&lt;/code&gt; 에서 예외가 발생하더라도 파일을 닫습니다 . 예외는 &lt;code&gt;try&lt;/code&gt; ... &lt;code&gt;after&lt;/code&gt; ... &lt;code&gt;end&lt;/code&gt; 표현식이 없는 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="baf40b5d188d7e3554eac9acbf598ea4267e238b" translate="yes" xml:space="preserve">
          <source>Next is an example of using &lt;code&gt;try&lt;/code&gt; to emulate &lt;code&gt;catch Expr&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;catch Expr&lt;/code&gt; 에뮬레이션 &lt;code&gt;try&lt;/code&gt; 를 사용하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="d4a825048b23dd21dd4cd211258efcc4e2e6dbd4" translate="yes" xml:space="preserve">
          <source>Next let's look at how we can do some optimizations using transformation rules. For simple instructions such as &lt;code&gt;move/2&lt;/code&gt;, the instruction dispatch overhead can be substantial. A simple optimization is to combine common instructions sequences to a single instruction. One such common sequence is multiple &lt;code&gt;move&lt;/code&gt; instructions moving X registers to Y registers.</source>
          <target state="translated">다음으로 변환 규칙을 사용하여 최적화를 수행하는 방법을 살펴 보겠습니다. &lt;code&gt;move/2&lt;/code&gt; 와 같은 간단한 명령어의 경우 명령어 디스패치 오버 헤드가 상당 할 수 있습니다. 간단한 최적화는 공통 명령어 시퀀스를 단일 명령어로 결합하는 것입니다. 이러한 공통 시퀀스 중 하나는 X 레지스터를 Y 레지스터로 이동하는 다중 &lt;code&gt;move&lt;/code&gt; 명령어입니다.</target>
        </trans-unit>
        <trans-unit id="c4092f0a830b3e6796bef07ac155e4adee4739ca" translate="yes" xml:space="preserve">
          <source>Next line (NEL)</source>
          <target state="translated">다음 줄 (NEL)</target>
        </trans-unit>
        <trans-unit id="2f96dddd46b5dcb9c4396f98ae433fa9b86dd63a" translate="yes" xml:space="preserve">
          <source>Next step is to start a service according to the ssh request. In case of a request of a shell, a new one is started which handles the OS-commands that arrives from the client (that's &quot;you&quot;).</source>
          <target state="translated">다음 단계는 ssh 요청에 따라 서비스를 시작하는 것입니다. 셸 요청의 경우 클라이언트 (즉, &quot;사용자&quot;)에서 도착하는 OS 명령을 처리하는 새 쉘이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="49c36c588e423f9755f10724b38b806cab7bb00b" translate="yes" xml:space="preserve">
          <source>Next the system to be analyzed is added to the Xref server. Here the system will be OTP, so no library path will be needed. Otherwise, when analyzing a system that uses OTP, the OTP modules are typically made library modules by setting the library path to the default OTP code path (or to &lt;code&gt;code_path&lt;/code&gt;, see the &lt;code&gt;&lt;a href=&quot;xref#code_path&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt;). By default, the names of read BEAM files and warnings are output when adding analyzed modules, but these messages can be avoided by setting default values of some options:</source>
          <target state="translated">다음으로 분석 할 시스템이 외부 참조 서버에 추가됩니다. 여기서 시스템은 OTP이므로 라이브러리 경로가 필요하지 않습니다. 그렇지 않으면 OTP를 사용하는 시스템을 분석 할 때 일반적으로 라이브러리 경로를 기본 OTP 코드 경로 (또는 &lt;code&gt;code_path&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;xref#code_path&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt; ) 로 설정하여 OTP 모듈을 라이브러리 모듈로 만듭니다 . 기본적으로, 분석 된 모듈을 추가 할 때 읽은 BEAM 파일 및 경고의 이름이 출력되지만 일부 옵션의 기본값을 설정하면 이러한 메시지를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80d521b3788a65371a641f56d5e8d11c4ad08f4b" translate="yes" xml:space="preserve">
          <source>Next transaction id. A positive integer or the atom &lt;code&gt;undefined_serial&lt;/code&gt; (only in case of error).</source>
          <target state="translated">다음 거래 ID. 양의 정수 또는 원자 &lt;code&gt;undefined_serial&lt;/code&gt; (오류 인 경우에만).</target>
        </trans-unit>
        <trans-unit id="dd6bc460b4d14d33fe3d511ad06eeecb72c9edc0" translate="yes" xml:space="preserve">
          <source>Next we define the fragment that will pick up the value from the register from the first operand:</source>
          <target state="translated">다음으로 첫 번째 피연산자의 레지스터에서 값을 가져올 조각을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2bcc2284b1bbb94c0e744639578496a06f1ff6a1" translate="yes" xml:space="preserve">
          <source>Next we define the main part of the code that do the actual incrementing.</source>
          <target state="translated">다음으로 실제 증가를 수행하는 코드의 주요 부분을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0defe52a66513a79940e5ab6dc6388b2167016ac" translate="yes" xml:space="preserve">
          <source>Next we handle the different requests, first the fairly generic multi-request type:</source>
          <target state="translated">다음으로 다른 요청을 처리합니다. 먼저 일반적인 다중 요청 유형입니다.</target>
        </trans-unit>
        <trans-unit id="45243a2c405fc73eda33c63058c67d022a0c9f29" translate="yes" xml:space="preserve">
          <source>Next we will look at when the &lt;code&gt;-no_next&lt;/code&gt; directive can be used. Here is the &lt;code&gt;jump/1&lt;/code&gt; instruction:</source>
          <target state="translated">다음으로 &lt;code&gt;-no_next&lt;/code&gt; 지시어를 언제 사용할 수 있는지 살펴 보겠습니다 . 다음은 &lt;code&gt;jump/1&lt;/code&gt; 명령어입니다.</target>
        </trans-unit>
        <trans-unit id="d2101e96703268b0a370202e8ee193996232f211" translate="yes" xml:space="preserve">
          <source>Next, the two higher order functions &lt;code&gt;pand&lt;/code&gt; and &lt;code&gt;por&lt;/code&gt; are defined. They combine primitive parsers to produce more complex parsers.</source>
          <target state="translated">다음으로, &lt;code&gt;pand&lt;/code&gt; 와 &lt;code&gt;por&lt;/code&gt; 의 두 가지 고차 함수 가 정의됩니다. 이들은 원시 파서를 결합하여 더 복잡한 파서를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="55674258a28777513c3ee8a1247d68d39b7e5128" translate="yes" xml:space="preserve">
          <source>Nko</source>
          <target state="translated">Nko</target>
        </trans-unit>
        <trans-unit id="cf9ccefe9fbda77917b667cca9134ccee3903031" translate="yes" xml:space="preserve">
          <source>Nlen</source>
          <target state="translated">Nlen</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="b75cac20c58d75851a13dd19c8019111fb0da9c8" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;CLASSPATH&lt;/code&gt; or anything is needed. Type &lt;code&gt;javac.exe&lt;/code&gt; in the bash prompt and you should get a list of available Java options.</source>
          <target state="translated">아니 &lt;code&gt;CLASSPATH&lt;/code&gt; 또는 아무것도 필요하다. bash 프롬프트에 &lt;code&gt;javac.exe&lt;/code&gt; 를 입력 하면 사용 가능한 Java 옵션 목록이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="306df27b0e9baa7048471bce2f90b4c62b83a515" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;CLASSPATH&lt;/code&gt; or anything is needed. Type &lt;code&gt;javac&lt;/code&gt; in the bash prompt and you should get a list of available Java options. Make sure, e.g by typing &lt;code&gt;type java&lt;/code&gt;, that you use the Java you installed. Note however that Cygwin's/MinGW's/MSYS2's &lt;code&gt;jar.exe&lt;/code&gt; is used. That's why the JDK bin-directory should be added last in the &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">아니 &lt;code&gt;CLASSPATH&lt;/code&gt; 또는 아무것도 필요하다. bash 프롬프트에 &lt;code&gt;javac&lt;/code&gt; 를 입력 하면 사용 가능한 Java 옵션 목록이 표시됩니다. 예를 들어 &lt;code&gt;type java&lt;/code&gt; 을 입력하여 설치 한 Java를 사용 하는지 확인하십시오 . 그러나 Cygwin 's / MinGW 's / MSYS2 's &lt;code&gt;jar.exe&lt;/code&gt; 가 사용됩니다. 그렇기 때문에 JDK bin 디렉토리가 &lt;code&gt;PATH&lt;/code&gt; 의 마지막에 추가되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="20123f437cbed011ee99b107692f5a0de92f5b78" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;OTP_VERSION&lt;/code&gt; file is placed in a &lt;code&gt;&lt;a href=&quot;create_target&quot;&gt;target system&lt;/a&gt;&lt;/code&gt; created by OTP tools. This since one easily can create a target system where it is hard to even determine the base OTP version. You can, however, place such a file there if you know the OTP version.</source>
          <target state="translated">OTP 도구로 작성된 &lt;code&gt;&lt;a href=&quot;create_target&quot;&gt;target system&lt;/a&gt;&lt;/code&gt; 에는 &lt;code&gt;OTP_VERSION&lt;/code&gt; 파일이 없습니다 . 이것은 기본 OTP 버전을 결정하기 어려운 대상 시스템을 쉽게 만들 수 있기 때문입니다. 그러나 OTP 버전을 알고있는 경우 이러한 파일을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2c45cced64f7eeac215e46b87b5f0266dfddf0d" translate="yes" xml:space="preserve">
          <source>No Time Warp Mode</source>
          <target state="translated">시간 왜곡 모드 없음</target>
        </trans-unit>
        <trans-unit id="96af42e99b6235700bd5fb58880e48e6032a35fe" translate="yes" xml:space="preserve">
          <source>No active supervision of the net-if process.</source>
          <target state="translated">net-if 프로세스에 대한 적극적인 감독이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b26bf8ba2172d52337372f5408c0374da428f07b" translate="yes" xml:space="preserve">
          <source>No available CPU topology. That is, the runtime system was not able to detect the CPU topology automatically, and no &lt;code&gt;&lt;a href=&quot;#+sct&quot;&gt;user-defined CPU topology&lt;/a&gt;&lt;/code&gt; was set.</source>
          <target state="translated">사용 가능한 CPU 토폴로지가 없습니다. 즉, 런타임 시스템이 CPU 토폴로지를 자동으로 감지 할 수 없었으며 &lt;code&gt;&lt;a href=&quot;#+sct&quot;&gt;user-defined CPU topology&lt;/a&gt;&lt;/code&gt; 가 설정 되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="3b10bd61863afa70db914b4200f2158aa1e35253" translate="yes" xml:space="preserve">
          <source>No channel is started. This is done by calling &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt; ssh_connection:session_channel/[2, 4]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시작된 채널이 없습니다. &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt; ssh_connection:session_channel/[2, 4]&lt;/a&gt;&lt;/code&gt; 를 호출하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="a85ad1a848cbb91f4217ade2f8af6dd92f90a8ce" translate="yes" xml:space="preserve">
          <source>No channel is started. This is done by calling &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/[2, 4]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">채널이 시작되지 않았습니다. &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/[2, 4]&lt;/a&gt;&lt;/code&gt; 를 호출하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="fddf0f31436a33dc7eb65b7e662b0a272aad9fa5" translate="yes" xml:space="preserve">
          <source>No character in the Unicode table has the Cn (unassigned) property. This property is instead assumed for any code point that is not in the Unicode table.</source>
          <target state="translated">유니 코드 테이블에는 Cn (지정되지 않은) 속성이있는 문자가 없습니다. 대신이 속성은 유니 코드 테이블에없는 코드 포인트에 대해 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="d72c3c7afe7adf0ff8406edeea270902ae726752" translate="yes" xml:space="preserve">
          <source>No exec-requests are executed but shell-requests are not affected, they follow the &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell_spec&lt;/a&gt;&lt;/code&gt;'s value.</source>
          <target state="translated">실행 요청은 실행되지 않지만 셸 요청은 영향을받지 않으며 &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell_spec&lt;/a&gt;&lt;/code&gt; 의 값 을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="dc57d984725306844c55a6e549f5434351f897bb" translate="yes" xml:space="preserve">
          <source>No execution mode. Just prints the name of each module that needs to be compiled.</source>
          <target state="translated">실행 모드가 없습니다. 컴파일해야 할 각 모듈의 이름 만 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="4f359a331e2d8e32338d669077706cc69d91dc7c" translate="yes" xml:space="preserve">
          <source>No file with object code exists.</source>
          <target state="translated">객체 코드가있는 파일이 없습니다.</target>
        </trans-unit>
        <trans-unit id="13241af56c130b238829c77fe317f13857c53de0" translate="yes" xml:space="preserve">
          <source>No file with object code was found.</source>
          <target state="translated">오브젝트 코드가있는 파일이 없습니다.</target>
        </trans-unit>
        <trans-unit id="440071f450e51e9d450fcc9382feef4bf2695f38" translate="yes" xml:space="preserve">
          <source>No files are compressed.</source>
          <target state="translated">압축 된 파일이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0dc01295326d7bbe83d6152968ff814da6bb7e65" translate="yes" xml:space="preserve">
          <source>No form of peer discovery is implemented. The user can implement this independently of diameter if required.</source>
          <target state="translated">어떤 형태의 피어 발견도 구현되지 않습니다. 사용자는 필요한 경우 직경과 무관하게이를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72c55b9244448dbb0de0232a0eac2de1afdad171" translate="yes" xml:space="preserve">
          <source>No garbage collection was performed, as the process identified by &lt;code&gt;Pid&lt;/code&gt; terminated before the request could be satisfied.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 에 의해 식별 된 프로세스 가 요청을 충족시키기 전에 종료 되었으므로 가비지 콜렉션이 수행되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="2f23a91f9bb422d0761d2bc7e964443f6476d113" translate="yes" xml:space="preserve">
          <source>No locks are released when child transactions terminate. Locks created by a sequence of nested transactions are kept until the topmost transaction terminates. Furthermore, any update performed by a nested transaction is only propagated in such a manner so that the parent of the nested transaction sees the updates. No final commitment is done until the top-level transaction terminates. So, although a nested transaction returns &lt;code&gt;{atomic, Val}&lt;/code&gt;, if the enclosing parent transaction terminates, the entire nested operation terminates.</source>
          <target state="translated">하위 트랜잭션이 종료 될 때 잠금이 해제되지 않습니다. 중첩 된 트랜잭션 시퀀스로 생성 된 잠금은 최상위 트랜잭션이 종료 될 때까지 유지됩니다. 또한 중첩 트랜잭션에 의해 수행 된 모든 업데이트는 중첩 트랜잭션의 부모가 업데이트를 볼 수있는 방식으로 만 전파됩니다. 최상위 트랜잭션이 종료 될 때까지 최종 커밋이 수행되지 않습니다. 따라서 중첩 된 트랜잭션이 &lt;code&gt;{atomic, Val}&lt;/code&gt; 리턴하지만, 상위 상위 트랜잭션이 종료되면 전체 중첩 조작이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f674a37123f0ffc3506454e7b55512d60713fa52" translate="yes" xml:space="preserve">
          <source>No matching branch is found when evaluating a &lt;code&gt;case&lt;/code&gt; expression. The value &lt;code&gt;V&lt;/code&gt; did not match.</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 표현식을 평가할 때 일치하는 분기가 없습니다 . 값 &lt;code&gt;V&lt;/code&gt; 가 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7043cf82452e810d5c16d3e477ed93f700205d66" translate="yes" xml:space="preserve">
          <source>No matching branch is found when evaluating the of-section of a &lt;code&gt;try&lt;/code&gt; expression. The value &lt;code&gt;V&lt;/code&gt; did not match.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 표현식의 섹션을 평가할 때 일치하는 분기가 없습니다 . 값 &lt;code&gt;V&lt;/code&gt; 가 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bafda3e67a73a9fac5366e727d20ddc61884e3fb" translate="yes" xml:space="preserve">
          <source>No matching function clause is found when evaluating a function call.</source>
          <target state="translated">함수 호출을 평가할 때 일치하는 함수 절이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b154fd09fbcc9049abbeb9b2cae25aa1de56f340" translate="yes" xml:space="preserve">
          <source>No more available OS processes.</source>
          <target state="translated">더 이상 사용 가능한 OS 프로세스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="30a54d12705f7304413a1180c01d997ab6369210" translate="yes" xml:space="preserve">
          <source>No more available file descriptors (for the OS process that the Erlang emulator runs in).</source>
          <target state="translated">더 이상 사용 가능한 파일 디스크립터가 없습니다 (Erlang 에뮬레이터가 실행되는 OS 프로세스 용).</target>
        </trans-unit>
        <trans-unit id="a8ffa3b27d199208e567b9f7e6b61c30d8a4fd15" translate="yes" xml:space="preserve">
          <source>No more memory is available.</source>
          <target state="translated">더 이상 사용 가능한 메모리가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf3f0d88be368d141ccef5093be9613bf0c9230c" translate="yes" xml:space="preserve">
          <source>No network is available.</source>
          <target state="translated">사용 가능한 네트워크가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c489474600adaec621c887ab5f0e2e6aff78625a" translate="yes" xml:space="preserve">
          <source>No new options can be added, but those present in &lt;code&gt;SuggestedOptions&lt;/code&gt; can be omitted or replaced with new values in &lt;code&gt;AcceptedOptions&lt;/code&gt;.</source>
          <target state="translated">새 옵션을 추가 할 수 없지만 &lt;code&gt;SuggestedOptions&lt;/code&gt; 에 있는 옵션은 생략하거나 &lt;code&gt;AcceptedOptions&lt;/code&gt; 에 새 값으로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cccb01175197e57cc2cc371d3deb57037c621f92" translate="yes" xml:space="preserve">
          <source>No object code is found. It is assumed that the source code and object code are located either in the same directory, or in &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;ebin&lt;/code&gt; directories next to each other.</source>
          <target state="translated">객체 코드가 없습니다. 소스 코드와 객체 코드는 같은 디렉토리에 있거나 &lt;code&gt;src&lt;/code&gt; 와 &lt;code&gt;ebin&lt;/code&gt; 디렉토리 에 위치하고 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="a11ca60fca56c33b2c64441ebd0092b5a2034edf" translate="yes" xml:space="preserve">
          <source>No object with the correct key exists and no default object was supplied.</source>
          <target state="translated">올바른 키를 가진 오브젝트가 없으며 기본 오브젝트가 제공되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="01bb309c51c64719a36ff0535eb3f933818be49b" translate="yes" xml:space="preserve">
          <source>No optimization was found. A match specification matching all objects is used if &lt;code&gt;TraverseFun&lt;/code&gt; is unary.</source>
          <target state="translated">최적화가 없습니다. &lt;code&gt;TraverseFun&lt;/code&gt; 이 단항 인 경우 모든 객체와 일치하는 일치 사양이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="cd5da193599373a0a6119b861beeeab1a8bf22a1" translate="yes" xml:space="preserve">
          <source>No other support is available within this module that would guarantee consistency between objects. However, function &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; can be used to guarantee that a sequence of &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; calls traverse the table without errors and that each existing object in the table is visited exactly once, even if another (or the same) process simultaneously deletes or inserts objects into the table. Nothing else is guaranteed; in particular objects that are inserted or deleted during such a traversal can be visited once or not at all. Functions that internally traverse over a table, like &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match&lt;/a&gt;&lt;/code&gt;, give the same guarantee as &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈 내에서 개체 간 일관성을 보장하는 다른 지원은 없습니다. 그러나 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하면 일련의 &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; 호출이 오류없이 테이블을 순회하고 다른 (또는 동일한) 프로세스 인 경우에도 테이블에있는 기존의 각 오브젝트를 정확히 한 번 방문 하도록 보장 할 수 있습니다. 동시에 테이블에 객체를 삭제하거나 삽입합니다. 다른 것은 보장되지 않습니다. 특히 이러한 순회 중에 삽입되거나 삭제 된 객체는 한 번 방문하거나 전혀 방문하지 않을 수 있습니다. &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match&lt;/a&gt;&lt;/code&gt; 와 같이 내부적으로 테이블을 가로 지르는 함수는 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable&lt;/a&gt;&lt;/code&gt; 과 동일한 보증을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="cd17e64205667c500758839414e3602b81b56476" translate="yes" xml:space="preserve">
          <source>No packaging is done.</source>
          <target state="translated">포장이 완료되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ba80c47298de4f4f293a1e5e303c27b3b69db4f4" translate="yes" xml:space="preserve">
          <source>No packet handling is done. The entire binary is returned unless it is empty.</source>
          <target state="translated">패킷 처리가 수행되지 않습니다. 비어 있지 않으면 전체 바이너리가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ca6f2c7da1bb311124b43ce0e8411af0807caf66" translate="yes" xml:space="preserve">
          <source>No persistent information is updated, so these functions can be used on any Erlang node, embedded or not. Also, using these functions does not affect which code is loaded if there is a reboot.</source>
          <target state="translated">영구 정보가 업데이트되지 않으므로 이러한 기능은 내장 또는 포함되지 않은 Erlang 노드에서 사용할 수 있습니다. 또한이 기능을 사용해도 재부팅이있는 경우로드되는 코드에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05eb06aea519cecedac753c3c3fc222e914de94b" translate="yes" xml:space="preserve">
          <source>No problems were found during the analysis and no warnings were emitted.</source>
          <target state="translated">분석 중에 문제가 발견되지 않았으며 경고가 발생하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c647cf715eac6879d4c3134da30ff7c15996866b" translate="yes" xml:space="preserve">
          <source>No problems were found during the analysis, but warnings were emitted.</source>
          <target state="translated">분석 중에 문제가 발견되지 않았지만 경고가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="7a7ee8e9ab08c0d3ec811abad79a71a98bba9463" translate="yes" xml:space="preserve">
          <source>No remote shell program was found on the computer. Note that &lt;code&gt;ssh&lt;/code&gt; is used by default, but this can be overridden with the &lt;code&gt;-rsh&lt;/code&gt; flag.</source>
          <target state="translated">컴퓨터에서 원격 셸 프로그램을 찾을 수 없습니다. 주의 &lt;code&gt;ssh&lt;/code&gt; 기본적으로 사용됩니다, 그러나 이것은으로 대체 할 수 있습니다 &lt;code&gt;-rsh&lt;/code&gt; 플래그.</target>
        </trans-unit>
        <trans-unit id="bd4d5686ec105c4061bf6d87bd047c5882b61b8e" translate="yes" xml:space="preserve">
          <source>No separate (variable) packages are generated. Applications that are found underneath a variable directory are ignored.</source>
          <target state="translated">별도의 (가변) 패키지가 생성되지 않습니다. 변수 디렉토리 아래에있는 응용 프로그램은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c2645af938c8d0d4b9ae8e002cf483a4d95efd04" translate="yes" xml:space="preserve">
          <source>No source code is found. It is assumed that the source code and object code are located either in the same directory, or in &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;ebin&lt;/code&gt; directories next to each other.</source>
          <target state="translated">소스 코드가 없습니다. 소스 코드와 객체 코드는 같은 디렉토리에 있거나 &lt;code&gt;src&lt;/code&gt; 와 &lt;code&gt;ebin&lt;/code&gt; 디렉토리 에 위치하고 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="c80de0efbf261d9e095f902e0f2d665fd88ad9d3" translate="yes" xml:space="preserve">
          <source>No space is left on the device.</source>
          <target state="translated">장치에 공간이 남아 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b964042be0f5b6a57a3eff551407bd909108832" translate="yes" xml:space="preserve">
          <source>No spawn reply message will be sent to the caller if the spawn operation fails, but a &lt;code&gt;&lt;a href=&quot;#spawn_request_success_message&quot;&gt;&lt;i&gt;success message&lt;/i&gt;&lt;/a&gt;&lt;/code&gt; will be sent to the caller if the operation succeeds.</source>
          <target state="translated">spawn 작업이 실패하면 호출자에게 spawn 응답 메시지가 전송되지 않지만 작업이 성공하면 호출자에게 &lt;code&gt;&lt;a href=&quot;#spawn_request_success_message&quot;&gt;&lt;i&gt;success message&lt;/i&gt;&lt;/a&gt;&lt;/code&gt; 가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="041742c7ea87a9c88a4b7cf7b446431513db18bb" translate="yes" xml:space="preserve">
          <source>No spawn reply message will be sent to the caller if the spawn operation succeeds, but an &lt;code&gt;&lt;a href=&quot;#spawn_request_error_message&quot;&gt;&lt;i&gt;error message&lt;/i&gt;&lt;/a&gt;&lt;/code&gt; will be sent to the caller if the operation fails.</source>
          <target state="translated">spawn 작업이 성공하면 호출자에게 spawn 응답 메시지가 전송되지 않지만 작업이 실패하면 호출자에게 &lt;code&gt;&lt;a href=&quot;#spawn_request_error_message&quot;&gt;&lt;i&gt;error message&lt;/i&gt;&lt;/a&gt;&lt;/code&gt; 가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="752d4c648b51ab1613cae015ad187b4a22a9e618" translate="yes" xml:space="preserve">
          <source>No spawn reply message will be sent to the caller when the spawn operation completes. This regardless of whether the operation succeeds or not.</source>
          <target state="translated">스폰 작업이 완료되면 스폰 응답 메시지가 호출자에게 전송되지 않습니다. 이것은 작업의 성공 여부에 관계없이.</target>
        </trans-unit>
        <trans-unit id="f9fa080f482a6c7afdf11e32c95599e768cf1721" translate="yes" xml:space="preserve">
          <source>No spawn request was abandoned. The &lt;code&gt;ReqId&lt;/code&gt; request identifier did not correspond to an outstanding spawn request issued by the calling process. The reason for this is either:</source>
          <target state="translated">스폰 요청이 취소되지 않았습니다. &lt;code&gt;ReqId&lt;/code&gt; 하지 않았다 식별자 요청은 호출 프로세스에 의해 발행 뛰어난 스폰 요청에 해당합니다. 그 이유는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="db50afb4ab4c477aba8edc312545bbe5ac56992b" translate="yes" xml:space="preserve">
          <source>No such file or directory, or directory already exists, or permission denied.</source>
          <target state="translated">해당 파일이나 디렉토리 또는 디렉토리가 이미 없거나 권한이 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="861215d646ab11b3c7364a81ae9819205bd22341" translate="yes" xml:space="preserve">
          <source>No such type.</source>
          <target state="translated">그런 유형은 없습니다.</target>
        </trans-unit>
        <trans-unit id="6f3f7a13db71f33cfa022de055c35c8dce0c2f17" translate="yes" xml:space="preserve">
          <source>No syntax rule definitions or other declarations may follow this section. To avoid conflicts with internal variables, do not use variable names beginning with two underscore characters ('__') in the Erlang code in this section, or in the code associated with the individual syntax rules.</source>
          <target state="translated">이 섹션 뒤에는 구문 규칙 정의 나 다른 선언이있을 수 없습니다. 내부 변수와의 충돌을 피하려면이 섹션의 Erlang 코드 또는 개별 구문 규칙과 관련된 코드에서 두 개의 밑줄 문자 ( '__')로 시작하는 변수 이름을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="aa48fa9b98593eafebf1b9c977ec3beb73292810" translate="yes" xml:space="preserve">
          <source>No table traversal will guarantee a consistent snapshot of the entire table if the table is also updated by concurrent processes during the traversal. The result of each concurrently updated object may be seen (or not) depending on if it has happened when the traversal visits that part of the table. The only way to guarantee a full consistent table snapshot (if you really need that) is to disallow concurrent updates during the entire traversal.</source>
          <target state="translated">순회 중에 테이블이 동시 프로세스에 의해 업데이트되는 경우 테이블 순회는 전체 테이블의 일관된 스냅 샷을 보장하지 않습니다. 동시에 업데이트 된 각 개체의 결과는 순회가 테이블의 해당 부분을 방문 할 때 발생했는지 여부에 따라 표시되거나 표시되지 않을 수 있습니다. 전체 일관된 테이블 스냅 샷을 보장하는 유일한 방법 (정말 필요한 경우)은 전체 순회 동안 동시 업데이트를 허용하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="56bd79ad5b51fb7729ca3566ff1b2fd96321741b" translate="yes" xml:space="preserve">
          <source>No trace outputs. This is the default.</source>
          <target state="translated">추적 출력이 없습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="1bcae2b67b6703a4dda088ac83adf2fa3c139258" translate="yes" xml:space="preserve">
          <source>No true branch is found when evaluating an &lt;code&gt;if&lt;/code&gt; expression.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 표현식을 평가할 때 실제 분기가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="eda586f9e6ba047d97471f1bf9867a4ab7b5c6e7" translate="yes" xml:space="preserve">
          <source>No trusted CA was found in the trusted store. The trusted CA is normally a so called ROOT CA, which is a self-signed certificate. Trust can be claimed for an intermediate CA (trusted anchor does not have to be self-signed according to X-509) by using option &lt;code&gt;partial_chain&lt;/code&gt;.</source>
          <target state="translated">신뢰할 수있는 저장소에 신뢰할 수있는 CA가 없습니다. 트러스트 된 CA는 일반적으로 자체 서명 된 인증서 인 ROOT CA입니다. &lt;code&gt;partial_chain&lt;/code&gt; 옵션을 사용하여 중간 CA에 대한 신뢰를 청구 할 수 있습니다 (신뢰할 수있는 앵커는 X-509에 따라 자체 서명 할 필요가 없습니다) .</target>
        </trans-unit>
        <trans-unit id="51620f6ec27898e6c0fbd64ab1461dbab02323bd" translate="yes" xml:space="preserve">
          <source>No way of finding all possible answers by looking up keys was found, but the filters could be transformed into a match specification. All answers are found by calling &lt;code&gt;TraverseFun(MatchExpression)&lt;/code&gt;.</source>
          <target state="translated">키를 조회하여 가능한 모든 답변을 찾을 수있는 방법을 찾지 못했지만 필터를 일치 사양으로 변환 할 수 있습니다. 모든 답변은 &lt;code&gt;TraverseFun(MatchExpression)&lt;/code&gt; 을 호출하여 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49473ae5e307a442940553470cec56549ee7d425" translate="yes" xml:space="preserve">
          <source>Node :: node(),</source>
          <target state="translated">노드 :: node (),</target>
        </trans-unit>
        <trans-unit id="54c13c8fd7aa90de3fb8911bcf7fa43f2889a260" translate="yes" xml:space="preserve">
          <source>Node name of remote node. To be passed along to &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">원격 노드의 노드 이름. &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="777c88d4603f4203bbb592ad1459cf50c6255ac4" translate="yes" xml:space="preserve">
          <source>Node name of this node. To be passed along to &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">이 노드의 노드 이름. &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="9eae106cd79565d2506dacd99d934bb27987eb1e" translate="yes" xml:space="preserve">
          <source>Node name of this node. To be passed along to &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">이 노드의 노드 이름. &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4609ded8720acb4a14254c4923dd53fe7c48e94" translate="yes" xml:space="preserve">
          <source>Node name, &lt;code&gt;node&lt;/code&gt;</source>
          <target state="translated">노드 이름, &lt;code&gt;node&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07577846f355b02783c690185edc121991468e96" translate="yes" xml:space="preserve">
          <source>Node table entries that are not referred linger in the table for at least the amount of time that this parameter determines. The lingering prevents repeated deletions and insertions in the tables from occurring.</source>
          <target state="translated">이 매개 변수가 결정하는 시간 동안 테이블에서 참조되지 않는 노드 테이블 항목. 시간이 오래 걸리면 테이블에서 삭제 및 삽입이 반복되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="609dd2f5616d5def969c38a398d805318ea1a788" translate="yes" xml:space="preserve">
          <source>Nodes can be added to and removed from a &lt;code&gt;Mnesia&lt;/code&gt; system. This can be done by adding a copy of the schema to those nodes.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 시스템에 노드를 추가하거나 제거 할 수 있습니다 . 이는 해당 노드에 스키마 사본을 추가하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6747accaf683f772944ea14fe4c794ccba9b86a1" translate="yes" xml:space="preserve">
          <source>Nodes connected through hidden connections can be monitored as any other nodes.</source>
          <target state="translated">숨겨진 연결을 통해 연결된 노드는 다른 노드로 모니터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41e6879915cbf13a3b60e8d7f1f912973f81167b" translate="yes" xml:space="preserve">
          <source>Nodes connected to this node through hidden connections.</source>
          <target state="translated">숨겨진 연결을 통해이 노드에 연결된 노드</target>
        </trans-unit>
        <trans-unit id="cc5d70b541f8501e9d01ec3e0e4e3fde1b4be2ae" translate="yes" xml:space="preserve">
          <source>Nodes connected to this node through normal connections.</source>
          <target state="translated">정상 연결을 통해이 노드에 연결된 노드</target>
        </trans-unit>
        <trans-unit id="57c1df2289899b41768f671fc1b5ee2f1c0b48d9" translate="yes" xml:space="preserve">
          <source>Nodes from which communicated peers are made available in the remote candidates list of &lt;code&gt;pick_peer/4&lt;/code&gt; callbacks.</source>
          <target state="translated">&lt;code&gt;pick_peer/4&lt;/code&gt; 콜백 의 원격 후보 목록에서 통신 피어를 사용할 수있는 노드입니다 .</target>
        </trans-unit>
        <trans-unit id="ba142752b13504899f6e0583213af78a0deb9255" translate="yes" xml:space="preserve">
          <source>Nodes that are known to this node. That is, connected nodes and nodes referred to by process identifiers, port identifiers, and references located on this node. The set of known nodes is garbage collected. Notice that this garbage collection can be delayed. For more information, see &lt;code&gt;&lt;a href=&quot;erlang#system_info_delayed_node_table_gc&quot;&gt; erlang:system_info(delayed_node_table_gc)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 노드에 알려진 노드입니다. 즉,이 노드에있는 프로세스 식별자, 포트 식별자 및 참조에 의해 참조되는 연결된 노드 및 노드입니다. 알려진 노드 집합은 가비지 수집됩니다. 이 가비지 수집이 지연 될 수 있습니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;erlang#system_info_delayed_node_table_gc&quot;&gt; erlang:system_info(delayed_node_table_gc)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="506bf95685aeda7d65c4825675264344d9902300" translate="yes" xml:space="preserve">
          <source>Nodes that are known to this node. That is, connected nodes and nodes referred to by process identifiers, port identifiers, and references located on this node. The set of known nodes is garbage collected. Notice that this garbage collection can be delayed. For more information, see &lt;code&gt;&lt;a href=&quot;erlang#system_info_delayed_node_table_gc&quot;&gt;erlang:system_info(delayed_node_table_gc)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 노드에 알려진 노드 즉, 연결된 노드와 노드는이 노드에있는 프로세스 식별자, 포트 식별자 및 참조로 참조됩니다. 알려진 노드 세트는 가비지 수집됩니다. 이 가비지 수집이 지연 될 수 있습니다. 자세한 정보는 &lt;code&gt;&lt;a href=&quot;erlang#system_info_delayed_node_table_gc&quot;&gt;erlang:system_info(delayed_node_table_gc)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7afefd4eb39dfd1fda9f65fc8df0dedddd2ab71e" translate="yes" xml:space="preserve">
          <source>Nodes to which peer connections established on the local Erlang node are communicated. Shared peers become available in the remote candidates list passed to &lt;code&gt;pick_peer/4&lt;/code&gt; callbacks on remote nodes whose services are configured to use them: see &lt;code&gt;use_shared_peers&lt;/code&gt; below.</source>
          <target state="translated">로컬 Erlang 노드에서 피어 연결이 설정된 노드가 통신됩니다. 공유 피어 는 서비스를 사용하도록 구성된 원격 노드의 &lt;code&gt;pick_peer/4&lt;/code&gt; 콜백에 전달 된 원격 후보 목록 에서 사용할 수 있습니다 ( 아래의 &lt;code&gt;use_shared_peers&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="67987925527526d6c9ece6f89eadcf6f992becee" translate="yes" xml:space="preserve">
          <source>Nodes with an ERTS version earlier than 5.7.2 (OTP R13B) does not pass the distribution flag that enables the distribution header. Messages passed between nodes have in this case the following format:</source>
          <target state="translated">ERTS 버전이 5.7.2 (OTP R13B) 이전 인 노드는 배포 헤더를 활성화하는 배포 플래그를 전달하지 않습니다. 이 경우 노드간에 전달되는 메시지의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ad3afeccc2c07ec40ffda2f6fe1a23dce971210" translate="yes" xml:space="preserve">
          <source>Nodes with an ERTS version earlier than 5.7.2 does not pass the distribution flag that enables the distribution header. Messages passed between nodes have in this case the following format:</source>
          <target state="translated">ERTS 5.7.2 이전 버전의 노드는 분배 헤더를 사용하는 분배 플래그를 전달하지 않습니다. 이 경우 노드간에 전달 된 메시지는 다음 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="8d28e8cb93663f40b3e02d5f32274b7bcf92428c" translate="yes" xml:space="preserve">
          <source>Nodes with disc database schema must be defined and implemented with the function &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema(NodeList)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">디스크 데이터베이스 스키마가있는 노드는 &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema(NodeList)&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 정의하고 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9b1284ec6c573e51f2ee9f680fc573581c6be9d1" translate="yes" xml:space="preserve">
          <source>Noise has a high level as opposed to essentials.</source>
          <target state="translated">소음은 기본과는 반대로 높은 수준입니다.</target>
        </trans-unit>
        <trans-unit id="1fc01fac8604f4aff7927b10b69d74ea30f3ab0a" translate="yes" xml:space="preserve">
          <source>Non-Persistent Database Storage</source>
          <target state="translated">비 영구 데이터베이스 저장소</target>
        </trans-unit>
        <trans-unit id="a72b2ae853945e5b8956182bbfb749378e193bfd" translate="yes" xml:space="preserve">
          <source>Non-blocking version of &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt;. It returns the tuple &lt;code&gt;{value, Val}&lt;/code&gt; when the computation is finished, or &lt;code&gt;timeout&lt;/code&gt; when &lt;code&gt;Timeout&lt;/code&gt; milliseconds has elapsed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; 의 비 차단 버전 . 계산이 완료되면 튜플 &lt;code&gt;{value, Val}&lt;/code&gt; 반환 하거나 &lt;code&gt;timeout&lt;/code&gt; &lt;code&gt;Timeout&lt;/code&gt; 밀리 초가 경과 하면 타임 아웃을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5f87b67027ba8d1bf675b11281146e26fb2801e6" translate="yes" xml:space="preserve">
          <source>Non-break space</source>
          <target state="translated">휴식 공간</target>
        </trans-unit>
        <trans-unit id="9786bbd5d9ae8aa15cfdb070c883540a4bc7d290" translate="yes" xml:space="preserve">
          <source>Non-default cipher suites including anonymous cipher suites (PRE TLS-1.3) are supported for interop/testing purposes and may be used by adding them to your cipher suite list. Note that they must also be supported/enabled by the peer to actually be used.</source>
          <target state="translated">익명 암호 제품군 (PRE TLS-1.3)을 포함한 기본이 아닌 암호 제품군은 상호 운용 / 테스트 목적으로 지원되며 암호 제품군 목록에 추가하여 사용할 수 있습니다. 실제로 사용하려면 피어에서 지원 / 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ea42666026a195787b7284149d9b03550517a0d" translate="yes" xml:space="preserve">
          <source>Non-portable hash function that only guarantees the same hash for the same term within one Erlang VM instance.</source>
          <target state="translated">하나의 Erlang VM 인스턴스 내에서 동일한 용어에 대해 동일한 해시만을 보장하는 이식 불가능한 해시 기능.</target>
        </trans-unit>
        <trans-unit id="234a623f6ba9a7ff287ed003837119c0295841fe" translate="yes" xml:space="preserve">
          <source>Non-spacing mark</source>
          <target state="translated">비 간격 마크</target>
        </trans-unit>
        <trans-unit id="26b2867ce328c59018c79a884756714da802589b" translate="yes" xml:space="preserve">
          <source>NonCompositeTerm ::= term() (not list or tuple or map)</source>
          <target state="translated">NonCompositeTerm :: = term () (목록 또는 튜플 또는 맵이 아님)</target>
        </trans-unit>
        <trans-unit id="4c6ddabca28c82e409457c62e73c0bb7ebc8fa48" translate="yes" xml:space="preserve">
          <source>NonLocalFunctionHandler) -&amp;gt;</source>
          <target state="translated">NonLocalFunctionHandler)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="18ebf28795ec5199819d1e5ac39fe97c6224fefd" translate="yes" xml:space="preserve">
          <source>NonLocalFunctionHandler,</source>
          <target state="translated">NonLocalFunctionHandler,</target>
        </trans-unit>
        <trans-unit id="55d124f30f131b3e3c6067792a7521dc039a3924" translate="yes" xml:space="preserve">
          <source>NonLocalFunctionHandler, ReturnFormat) -&amp;gt;</source>
          <target state="translated">NonLocalFunctionHandler, ReturnFormat) -&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d6ae77cee906d18da7aaf78a7c7ab33073d61cbe" translate="yes" xml:space="preserve">
          <source>None, but the version number was increased anyway.</source>
          <target state="translated">그러나 버전 번호는 어쨌든 증가했습니다.</target>
        </trans-unit>
        <trans-unit id="e27fd656202878645a6eba759532293545f66d3d" translate="yes" xml:space="preserve">
          <source>Normal Distribution Header</source>
          <target state="translated">정규 분포 헤더</target>
        </trans-unit>
        <trans-unit id="cc969dc2084d0c57d3c3f18672b1cb587110032f" translate="yes" xml:space="preserve">
          <source>Normal Windows NT installation is performed. No additional application programs are needed, such as Internet Explorer or web server. Networking with TCP/IP is required.</source>
          <target state="translated">정상적인 Windows NT 설치가 수행됩니다. Internet Explorer 또는 웹 서버와 같은 추가 응용 프로그램이 필요하지 않습니다. TCP / IP와의 네트워킹이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e00a61616c0ebb576daec9ce3da5c44b01d68c1a" translate="yes" xml:space="preserve">
          <source>Normal locking requires the following:</source>
          <target state="translated">일반 잠금에는 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c968deef42bc269fc435a9f4d346232704145288" translate="yes" xml:space="preserve">
          <source>Normal mode, in which text lines can be edited and sent to the shell.</source>
          <target state="translated">텍스트 모드를 편집하여 쉘로 보낼 수있는 일반 모드.</target>
        </trans-unit>
        <trans-unit id="d1edc765ff24644e61756ff101878b69d65d58a3" translate="yes" xml:space="preserve">
          <source>Normal schedulers will have scheduler identifiers in the range &lt;code&gt;1 =&amp;lt; SchedulerId =&amp;lt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt; erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt;. Dirty CPU schedulers will have scheduler identifiers in the range &lt;code&gt;erlang:system_info(schedulers) &amp;lt; SchedulerId =&amp;lt; erlang:system_info(schedulers) +&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_dirty_cpu_schedulers&quot;&gt; erlang:system_info(dirty_cpu_schedulers)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반 스케줄러에는 &lt;code&gt;1 =&amp;lt; SchedulerId =&amp;lt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt; erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; 범위의 스케줄러 식별자가 있습니다 . Dirty CPU 스케줄러에는 &lt;code&gt;erlang:system_info(schedulers) &amp;lt; SchedulerId =&amp;lt; erlang:system_info(schedulers) +&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_dirty_cpu_schedulers&quot;&gt; erlang:system_info(dirty_cpu_schedulers)&lt;/a&gt;&lt;/code&gt; 범위의 스케줄러 식별자가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c72d62413b1b0e473e04d83afe069f0e8f1245a9" translate="yes" xml:space="preserve">
          <source>Normal schedulers will have scheduler identifiers in the range &lt;code&gt;1 =&amp;lt; SchedulerId =&amp;lt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt;. Dirty CPU schedulers will have scheduler identifiers in the range &lt;code&gt;erlang:system_info(schedulers) &amp;lt; SchedulerId =&amp;lt; erlang:system_info(schedulers) +&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_dirty_cpu_schedulers&quot;&gt;erlang:system_info(dirty_cpu_schedulers)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반 스케줄러는 &lt;code&gt;1 =&amp;lt; SchedulerId =&amp;lt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; 범위의 스케줄러 식별자를 갖습니다 . 더티 CPU 스케줄러는 &lt;code&gt;erlang:system_info(schedulers) &amp;lt; SchedulerId =&amp;lt; erlang:system_info(schedulers) +&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_dirty_cpu_schedulers&quot;&gt;erlang:system_info(dirty_cpu_schedulers)&lt;/a&gt;&lt;/code&gt; 범위의 스케줄러 식별자를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="63856520df5f6e7c2b81ba0324073ec61c706fa4" translate="yes" xml:space="preserve">
          <source>Normal-form XML elements can thus be included in the simple-form representation. Note that content lists must be flat. An &lt;code&gt;IOString&lt;/code&gt; is a (possibly deep) list of characters and/or binaries.</source>
          <target state="translated">따라서 일반 양식 XML 요소는 단순 양식 표현에 포함될 수 있습니다. 컨텐츠 목록은 평평해야합니다. &lt;code&gt;IOString&lt;/code&gt; 는 문자 및 / 또는 바이너리 (아마도 깊이) 목록입니다.</target>
        </trans-unit>
        <trans-unit id="79f12813d5d24944ba41387d476392f4c8e44e2e" translate="yes" xml:space="preserve">
          <source>Normalization has 6 distinct steps. First the input URI is parsed into an intermediate form that can handle &lt;code&gt;&lt;a href=&quot;unicode_usage#what-unicode-is&quot;&gt;Unicode&lt;/a&gt;&lt;/code&gt; characters. This datatype is the &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt;, that can hold the components of the URI in map elements of type &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt;. After having the intermediate form, a sequence of normalization algorithms are applied to the individual URI components:</source>
          <target state="translated">정규화에는 6 가지 단계가 있습니다. 먼저 입력 URI가 &lt;code&gt;&lt;a href=&quot;unicode_usage#what-unicode-is&quot;&gt;Unicode&lt;/a&gt;&lt;/code&gt; 문자를 처리 할 수있는 중간 형식으로 구문 분석됩니다 . 이 데이터 유형은 &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt; 이며 &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; 유형의 맵 요소에 URI의 구성 요소를 보유 할 수 있습니다 . 중간 형식을 얻은 후 일련의 정규화 알고리즘이 개별 URI 구성 요소에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="35ce673e0f3c6f12cce80180092d208ba37aa4a0" translate="yes" xml:space="preserve">
          <source>Normalization is the operation of converting the input URI into a</source>
          <target state="translated">정규화는 입력 URI를</target>
        </trans-unit>
        <trans-unit id="a74e793a642e0b2e3ac1ab81016078fc7282ff3d" translate="yes" xml:space="preserve">
          <source>Normalizes an issuer name so that it can be easily compared to another issuer name.</source>
          <target state="translated">다른 발급자 이름과 쉽게 비교할 수 있도록 발급자 이름을 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="123bb07c3020981f40b2d515466fa01c393f5d17" translate="yes" xml:space="preserve">
          <source>Normally a Media Gateway (MG) connects explicitly while a Media Gateway Controller (MGC) connects implicitly.</source>
          <target state="translated">일반적으로 MG (Media Gateway)는 명시 적으로 연결되는 반면 MMG (Media Gateway Controller)는 암시 적으로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="9313afe2d7de25d7b0b5bfa53250c311418c0f2d" translate="yes" xml:space="preserve">
          <source>Normally a driver instance has no port data lock. If the driver instance wants to use a port data lock, it must create the port data lock by calling &lt;code&gt;&lt;a href=&quot;#driver_pdl_create&quot;&gt; driver_pdl_create&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반적으로 드라이버 인스턴스에는 포트 데이터 잠금이 없습니다. 드라이버 인스턴스가 포트 데이터 잠금을 사용하려면 &lt;code&gt;&lt;a href=&quot;#driver_pdl_create&quot;&gt; driver_pdl_create&lt;/a&gt;&lt;/code&gt; 를 호출하여 포트 데이터 잠금을 생성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="62b21d6a5acaba334f3b92e5191990bacc474890" translate="yes" xml:space="preserve">
          <source>Normally a driver instance has no port data lock. If the driver instance wants to use a port data lock, it must create the port data lock by calling &lt;code&gt;&lt;a href=&quot;#driver_pdl_create&quot;&gt;driver_pdl_create&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반적으로 드라이버 인스턴스에는 포트 데이터 잠금이 없습니다. 드라이버 인스턴스가 포트 데이터 잠금을 사용하려면 &lt;code&gt;&lt;a href=&quot;#driver_pdl_create&quot;&gt;driver_pdl_create&lt;/a&gt;&lt;/code&gt; 를 호출하여 포트 데이터 잠금을 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c68be6d33361ec0e77716005c64c0f636bd81f1e" translate="yes" xml:space="preserve">
          <source>Normally a trusted certificate, but it can also be a path-validation error that can be discovered while constructing the input to this function and that is to be run through the &lt;code&gt;verify_fun&lt;/code&gt;. Examples are &lt;code&gt;unknown_ca&lt;/code&gt; and &lt;code&gt;selfsigned_peer.&lt;/code&gt;</source>
          <target state="translated">일반적으로 신뢰할 수있는 인증서이지만이 함수에 대한 입력을 구성하는 동안 발견 될 수 있고 &lt;code&gt;verify_fun&lt;/code&gt; 을 통해 실행되는 경로 유효성 검증 오류 일 수도 있습니다 . 예는 &lt;code&gt;unknown_ca&lt;/code&gt; 및 &lt;code&gt;selfsigned_peer.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c1e2b2f12271535c195bd263adbd772fd1b1450" translate="yes" xml:space="preserve">
          <source>Normally an RSA, DSA or ECDSA public key, but handling of other public keys can be added</source>
          <target state="translated">일반적으로 RSA, DSA 또는 ECDSA 공개 키이지만 다른 공개 키 처리를 추가 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="32e8583c2f35a0fb6147ddcbc88cc5b16ce06fba" translate="yes" xml:space="preserve">
          <source>Normally an RSA, DSA or ECDSA public key, but handling of other public keys can be added.</source>
          <target state="translated">일반적으로 RSA, DSA 또는 ECDSA 공개 키이지만 다른 공개 키 처리를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a323154df5db7c6023a4765a91c3d178bc3620d" translate="yes" xml:space="preserve">
          <source>Normally an allocator creates a &quot;main multiblock carrier&quot;. Main multiblock carriers are never deallocated. The size of the main multiblock carrier is determined by the value of parameter &lt;code&gt;&lt;a href=&quot;#M_mmbcs&quot;&gt;mmbcs&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반적으로 할당자는 &quot;주 멀티 블록 캐리어&quot;를 만듭니다. 메인 멀티 블록 캐리어는 할당 해제되지 않습니다. 메인 &lt;code&gt;&lt;a href=&quot;#M_mmbcs&quot;&gt;mmbcs&lt;/a&gt;&lt;/code&gt; 블록 캐리어의 크기는 파라미터 mmbcs 의 값에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b4c50780b89a61508f82bc073504b8cf437882c" translate="yes" xml:space="preserve">
          <source>Normally in the range &lt;code&gt;-15..-8 | 8..15&lt;/code&gt;.</source>
          <target state="translated">일반적으로 &lt;code&gt;-15..-8 | 8..15&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a3591546de23ffebac17f3c960ad1cc664b2e7e" translate="yes" xml:space="preserve">
          <source>Normally it is the programmer's responsibility to free each Erlang term that has been returned from any of the &lt;code&gt;Erl_Interface&lt;/code&gt; functions. However, as many of the functions that build new Erlang terms in fact share objects with other existing terms, it can be difficult for the programmer to maintain pointers to all such terms to free them individually.</source>
          <target state="translated">일반적으로 &lt;code&gt;Erl_Interface&lt;/code&gt; 함수 에서 리턴 된 각 Erlang 용어를 해제하는 것은 프로그래머의 책임 입니다. 그러나 실제로 새로운 Erlang 용어를 작성하는 많은 함수가 다른 기존 용어와 객체를 공유하므로 프로그래머가 이러한 모든 용어에 대한 포인터를 유지하여 개별적으로 해제하는 것이 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1516500c60371d958d26c4174d5a863989b039fb" translate="yes" xml:space="preserve">
          <source>Normally the compiler treats calls to &lt;code&gt;is_record/2&lt;/code&gt; especially. It emits code to verify that &lt;code&gt;Term&lt;/code&gt; is a tuple, that its first element is &lt;code&gt;RecordTag&lt;/code&gt;, and that the size is correct. However, if &lt;code&gt;RecordTag&lt;/code&gt; is not a literal atom, the BIF &lt;code&gt;is_record/2&lt;/code&gt; is called instead and the size of the tuple is not verified.</source>
          <target state="translated">일반적으로 컴파일러는 특히 &lt;code&gt;is_record/2&lt;/code&gt; 에 대한 호출을 처리합니다 . &lt;code&gt;Term&lt;/code&gt; 이 터플이고 첫 번째 요소가 &lt;code&gt;RecordTag&lt;/code&gt; 이고 크기가 올바른지 확인하는 코드를 생성 합니다. 그러나 &lt;code&gt;RecordTag&lt;/code&gt; 가 리터럴 아톰이 아닌 경우 BIF &lt;code&gt;is_record/2&lt;/code&gt; 가 대신 호출되고 튜플의 크기가 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca1a7de4987b858f3cc368eec0c0c2caaad58778" translate="yes" xml:space="preserve">
          <source>Normally the compiler verifies that the module name given in the source code is the same as the base name of the output file and refuses to generate an output file if there is a mismatch. If you have a good reason (or other reason) for having a module name unrelated to the name of the output file, this option disables that verification (there will not even be a warning if there is a mismatch).</source>
          <target state="translated">일반적으로 컴파일러는 소스 코드에 지정된 모듈 이름이 출력 파일의 기본 이름과 동일한 지 확인하고 일치하지 않는 경우 출력 파일 생성을 거부합니다. 출력 파일 이름과 관련이없는 모듈 이름을 갖는 적절한 이유 (또는 다른 이유)가있는 경우이 옵션은 해당 검증을 비활성화합니다 (일치하지 않는 경우 경고도 표시되지 않음).</target>
        </trans-unit>
        <trans-unit id="c85cefd516f432dd52d61776ad47ad9e932cefa9" translate="yes" xml:space="preserve">
          <source>Normally the top directory of an application is located in library directory &lt;code&gt;$OTPROOT/lib&lt;/code&gt; or in a directory referred to by environment variable &lt;code&gt;ERL_LIBS&lt;/code&gt;. At startup, when the initial code path is computed, the code server also looks for archive files in these directories and possibly adds &lt;code&gt;ebin&lt;/code&gt; directories in archives to the code path. The code path then contains paths to directories that look like &lt;code&gt;$OTPROOT/lib/mnesia.ez/mnesia/ebin&lt;/code&gt; or &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin&lt;/code&gt;.</source>
          <target state="translated">일반적으로 애플리케이션의 최상위 디렉토리는 라이브러리 디렉토리 &lt;code&gt;$OTPROOT/lib&lt;/code&gt; 또는 환경 변수 &lt;code&gt;ERL_LIBS&lt;/code&gt; 에 의해 참조되는 디렉토리에 있습니다 . 시작시 초기 코드 경로가 계산 될 때 코드 서버는 이러한 디렉토리에서 아카이브 파일을 찾고 아카이브의 &lt;code&gt;ebin&lt;/code&gt; 디렉토리를 코드 경로에 추가 할 수도 있습니다 . 코드 경로에는 &lt;code&gt;$OTPROOT/lib/mnesia.ez/mnesia/ebin&lt;/code&gt; 또는 &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin&lt;/code&gt; 과 같은 디렉토리 경로가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="16dc8854601f473350bd4444afad1c3e95d0bfe6" translate="yes" xml:space="preserve">
          <source>Normally these are minimal stub implementations that throw an exception. But they can also be used as fallback implementations for functions that do not have native implemenations on some architectures.</source>
          <target state="translated">일반적으로 이들은 예외를 발생시키는 최소한의 스텁 구현입니다. 그러나 일부 아키텍처에서는 기본 구현이없는 함수에 대한 대체 구현으로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7e199a9abb107c5708b3c551b3f4ac7d6bc7e25" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;Loaded&lt;/code&gt; is the absolute filename &lt;code&gt;Filename&lt;/code&gt; from which the code is obtained. If the module is preloaded (see &lt;code&gt;script(4)&lt;/code&gt;), &lt;code&gt;Loaded==preloaded&lt;/code&gt;. If the module is Cover-compiled (see &lt;code&gt;cover(3)&lt;/code&gt;), &lt;code&gt;Loaded==cover_compiled&lt;/code&gt;.</source>
          <target state="translated">일반적으로 &lt;code&gt;Loaded&lt;/code&gt; 는 코드를 얻는 절대 파일 &lt;code&gt;Filename&lt;/code&gt; 파일 이름 입니다. 모듈은 프리로드되는 경우 (참조 &lt;code&gt;script(4)&lt;/code&gt; ) &lt;code&gt;Loaded==preloaded&lt;/code&gt; . 모듈이 Cover-compiled ( &lt;code&gt;cover(3)&lt;/code&gt; 참조 )이면 &lt;code&gt;Loaded==cover_compiled&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b5203fe540eb93014569c65ea374e32f208fcdb8" translate="yes" xml:space="preserve">
          <source>Normally, after a pending message has been received, the request is not resent (since a pending message is an indication that the request has been received). But since the reply (to the request) can be lost, this behaviour has its values.</source>
          <target state="translated">일반적으로 보류중인 메시지가 수신 된 후에는 요청이 재전송되지 않습니다 (대기중인 메시지는 요청이 수신되었다는 표시이므로). 그러나 (요청에 대한) 응답을 잃을 수 있으므로이 동작에는 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b537284cd04df03d36bf92033e8259f158494ca4" translate="yes" xml:space="preserve">
          <source>Normally, connections are established automatically when another node is referenced. This functionality can be disabled by setting Kernel configuration parameter &lt;code&gt;dist_auto_connect&lt;/code&gt; to &lt;code&gt;never&lt;/code&gt;, see &lt;code&gt;kernel(6)&lt;/code&gt;. In this case, connections must be established explicitly by calling &lt;code&gt;&lt;a href=&quot;#connect_node-1&quot;&gt;connect_node/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반적으로 다른 노드를 참조하면 연결이 자동으로 설정됩니다. 이 기능은 커널 구성 매개 변수 &lt;code&gt;dist_auto_connect&lt;/code&gt; 를 &lt;code&gt;never&lt;/code&gt; 로 설정하여 비활성화 할 수 있습니다 &lt;code&gt;kernel(6)&lt;/code&gt; 참조 ) . 이 경우 &lt;code&gt;&lt;a href=&quot;#connect_node-1&quot;&gt;connect_node/1&lt;/a&gt;&lt;/code&gt; 을 호출하여 연결을 명시 적으로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="637694f595e135bf986d734041974495ca2f7d71" translate="yes" xml:space="preserve">
          <source>Normally, the &lt;code&gt;/etc/ssh&lt;/code&gt; directory is only readable by root.</source>
          <target state="translated">일반적으로 &lt;code&gt;/etc/ssh&lt;/code&gt; 디렉토리는 루트 만 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c133a4bf588437e7a024274a632985a8eb26b1b7" translate="yes" xml:space="preserve">
          <source>Normally, the functions described above behave exactly as shown, but they are free to perform other actions. For example, a get-request may have side effects such as setting some other variable, perhaps a global &lt;code&gt;lastAccessed&lt;/code&gt; variable.</source>
          <target state="translated">일반적으로 위에서 설명한 기능은 표시된대로 정확하게 작동하지만 다른 작업을 자유롭게 수행 할 수 있습니다. 예를 들어, get-request는 글로벌 &lt;code&gt;lastAccessed&lt;/code&gt; 변수 와 같은 다른 변수 설정과 같은 부작용이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="544ca2481d30ca25eb88bc4478419d207c6b42f3" translate="yes" xml:space="preserve">
          <source>Normally, there is no need to worry about the speed of &lt;code&gt;length/1&lt;/code&gt;, because it is efficiently implemented in C. In time-critical code, you might want to avoid it if the input list could potentially be very long.</source>
          <target state="translated">일반적으로 &lt;code&gt;length/1&lt;/code&gt; 의 속도는 C로 효율적으로 구현되므로 걱정할 필요가 없습니다 . 시간이 중요한 코드에서는 입력 목록이 매우 길면 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="432c6c8cb64925afd6f974d52af838a844075bba" translate="yes" xml:space="preserve">
          <source>Normally, when an Erlang process sends to a socket, the driver tries to send the data immediately. If that fails, the driver uses any means available to queue up the message to be sent whenever the operating system says it can handle it. Setting &lt;code&gt;{delay_send, true}&lt;/code&gt; makes &lt;strong&gt;all&lt;/strong&gt; messages queue up. The messages sent to the network are then larger but fewer. The option affects the scheduling of send requests versus Erlang processes instead of changing any real property of the socket. The option is implementation-specific. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">일반적으로 Erlang 프로세스가 소켓으로 보내면 드라이버는 즉시 데이터를 보내려고합니다. 실패하면 드라이버는 운영 체제에서 메시지를 처리 ​​할 수 ​​있다고 표시 될 때마다 메시지를 큐에 대기시키는 데 사용할 수있는 수단을 사용합니다. &lt;code&gt;{delay_send, true}&lt;/code&gt; 설정 하면 &lt;strong&gt;모든&lt;/strong&gt; 메시지가 대기열에있게됩니다. 네트워크로 전송 된 메시지는 더 크지 만 더 적습니다. 이 옵션은 소켓의 실제 속성을 변경하는 대신 송신 요청과 Erlang 프로세스의 스케줄링에 영향을줍니다. 옵션은 구현에 따라 다릅니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8fad0923dba8395d1d335b96e476819a3a071dc5" translate="yes" xml:space="preserve">
          <source>Normative References</source>
          <target state="translated">규범 참조</target>
        </trans-unit>
        <trans-unit id="4c829414eaf27118bfedf26c7e8237c300423db1" translate="yes" xml:space="preserve">
          <source>Not a &lt;code&gt;pid()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pid()&lt;/code&gt; 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="deed9da173527db14150ff0b085131feec28ae66" translate="yes" xml:space="preserve">
          <source>Not all fields of this map has to be present. The flags field can be used to test for some of the fields. For example &lt;code&gt;broadaddr&lt;/code&gt; will only be present if the &lt;code&gt;broadcast&lt;/code&gt; flag is present in flags.</source>
          <target state="translated">이 맵의 모든 필드가 있어야하는 것은 아닙니다. 플래그 필드는 일부 필드를 테스트하는 데 사용할 수 있습니다. 예를 들어 &lt;code&gt;broadaddr&lt;/code&gt; 은 &lt;code&gt;broadcast&lt;/code&gt; 플래그가 플래그에 있는 경우에만 존재합니다 .</target>
        </trans-unit>
        <trans-unit id="c737921363d7d8bbbfc2bf38000b57e386aed1b1" translate="yes" xml:space="preserve">
          <source>Not all functions are provided on all platforms. In particular, the &lt;code&gt;&lt;a href=&quot;#erf-1&quot;&gt;erf/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#erfc-1&quot;&gt;erfc/1&lt;/a&gt;&lt;/code&gt; functions are not provided on Windows.</source>
          <target state="translated">모든 기능이 모든 플랫폼에서 제공되는 것은 아닙니다. 특히, &lt;code&gt;&lt;a href=&quot;#erf-1&quot;&gt;erf/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#erfc-1&quot;&gt;erfc/1&lt;/a&gt;&lt;/code&gt; 기능은 Windows에서 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="50eeaa129a18f1db0ba0b1a0b68ec33d5a9d6b03" translate="yes" xml:space="preserve">
          <source>Not all options are valid on all platforms. That is, even if &quot;we&quot; support an option, that does not mean that the underlying OS does.</source>
          <target state="translated">모든 옵션이 모든 플랫폼에서 유효한 것은 아닙니다. 즉, &quot;우리&quot;가 옵션을 지원하더라도 기본 OS가 지원한다는 의미는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f60564ddfb74e83034e43211b6dc56c962f055f4" translate="yes" xml:space="preserve">
          <source>Not all systems send signals. For details on valid string values, see RFC 4254, Section 6.10</source>
          <target state="translated">모든 시스템이 신호를 보내는 것은 아닙니다. 유효한 문자열 값에 대한 자세한 내용은 RFC 4254, 섹션 6.10을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a834a9b315fc2a330e09ba52fb9c66fcf454a31e" translate="yes" xml:space="preserve">
          <source>Not being able to control the application remotely</source>
          <target state="translated">애플리케이션을 원격으로 제어 할 수 없음</target>
        </trans-unit>
        <trans-unit id="1a46fcc227b8efe8fe76d1f3917346701207d128" translate="yes" xml:space="preserve">
          <source>Not built-in</source>
          <target state="translated">내장되지 않음</target>
        </trans-unit>
        <trans-unit id="e5c26cb1806bfcc16aba23e2bcd43b6fab4a7dce" translate="yes" xml:space="preserve">
          <source>Not enough memory to create the port.</source>
          <target state="translated">포트를 생성하기위한 메모리가 부족합니다.</target>
        </trans-unit>
        <trans-unit id="5a93ba71c6009e894f071984d5a041fabb7da94e" translate="yes" xml:space="preserve">
          <source>Not enough space left to write the file.</source>
          <target state="translated">파일을 쓸 공간이 부족합니다.</target>
        </trans-unit>
        <trans-unit id="b498326e15a92ae0d8b8c9b12f4c1b41ff6d4998" translate="yes" xml:space="preserve">
          <source>Not equal to</source>
          <target state="translated">같지 않음</target>
        </trans-unit>
        <trans-unit id="46885249352a064243a6dddeac62ab075a4dd8a5" translate="yes" xml:space="preserve">
          <source>Not recommended, as the machine will possibly be inaccessible to interactive users.</source>
          <target state="translated">대화 형 사용자가 머신에 액세스 할 수 없으므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="943fa3c1c3bedd251cb678cfcff592882249becf" translate="yes" xml:space="preserve">
          <source>Not recommended; use &lt;code&gt;&lt;a href=&quot;erlc&quot;&gt;erlc&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">권장하지 않습니다. 사용 &lt;code&gt;&lt;a href=&quot;erlc&quot;&gt;erlc&lt;/a&gt;&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="a35d63cc7db198d75edb76a9f80fbc617cd6daa6" translate="yes" xml:space="preserve">
          <source>Not unexpectedly, we see that &lt;code&gt;file:write/2&lt;/code&gt; was called from &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; and &lt;code&gt;foo:create_file_slow/2&lt;/code&gt;. The number of calls in each case as well as the used time are also just confirms the previous results.</source>
          <target state="translated">예기치 않게, &lt;code&gt;file:write/2&lt;/code&gt; 가 &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; 및 &lt;code&gt;foo:create_file_slow/2&lt;/code&gt; 에서 호출 된 것을 볼 수 있습니다 . 각 경우의 통화 횟수와 사용 시간도 이전 결과를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="844262b1792d0ef92bc2117e202d50d8b150ea0d" translate="yes" xml:space="preserve">
          <source>Not using the code loading generations (or any other code duplication) means that &lt;code&gt;trace_pattern&lt;/code&gt; must at some point write to the active beam code in order for running processes to reach the staged breakpoints structures. This can be done with one single atomic write operation per instrumented function. The beam instruction words are however read with normal memory loads and not through the atomic API. The only guarantee we need is that the written instruction word is seen as atomic. Either fully written or not at all. This is true for word aligned write operation on all hardware architectures we use.</source>
          <target state="translated">코드 로딩 생성 (또는 다른 코드 중복)을 사용하지 않는 것은 실행중인 프로세스가 단계적 중단 점 구조에 도달하기 위해 &lt;code&gt;trace_pattern&lt;/code&gt; 이 어느 시점에서 활성 빔 코드에 기록해야 함을 의미합니다 . 이는 계측 된 함수 당 하나의 단일 원자 쓰기 작업으로 수행 할 수 있습니다. 그러나 빔 명령어는 원자 API를 통하지 않고 정상적인 메모리로드로 읽습니다. 우리가 필요로하는 유일한 보증은 서면 지시어가 원자로 간주된다는 것입니다. 완전히 작성되었거나 전혀 작성되지 않았습니다. 이것은 우리가 사용하는 모든 하드웨어 아키텍처에서 단어 정렬 쓰기 작업에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="5e2bc95e45520449726b41dddaa10d65e1171c4f" translate="yes" xml:space="preserve">
          <source>Not yet supported</source>
          <target state="translated">아직 지원되지 않음</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="fb48271e25bdfecded1918413e5015fa92ec99a7" translate="yes" xml:space="preserve">
          <source>Note again that a successfull decode only returns a partially initiated message.</source>
          <target state="translated">디코딩이 성공하면 부분적으로 시작된 메시지 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8bb5fcd3ca24d41d35ec2f21eaba5915f96c6ec6" translate="yes" xml:space="preserve">
          <source>Note also that the &lt;code&gt;Options&lt;/code&gt; argument comes from the &lt;code&gt;options&lt;/code&gt; config option of the mib-storage config option, and is passed on as is.</source>
          <target state="translated">또한 &lt;code&gt;Options&lt;/code&gt; 인수는 mib-storage config 옵션 의 &lt;code&gt;options&lt;/code&gt; config 옵션 에서 제공 되며 그대로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0627636f71c6f80361b94f0198da347d52ca866f" translate="yes" xml:space="preserve">
          <source>Note also that the shared group leader (&lt;code&gt;SharedGL&lt;/code&gt;) must never be terminated by the user, only by Common Test. Group leader processes for parallel test case groups (&lt;code&gt;OtherGLs&lt;/code&gt;) may however be terminated in post_end_per_group hook functions.</source>
          <target state="translated">또한 공유 그룹 리더 ( &lt;code&gt;SharedGL&lt;/code&gt; )는 사용자가 공통 테스트를 통해서만 종료해서는 안됩니다. 그러나 병렬 테스트 케이스 그룹 ( &lt;code&gt;OtherGLs&lt;/code&gt; )의 그룹 리더 프로세스 는 post_end_per_group 후크 함수에서 종료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edc2e031b8dd55503b20741805cebfb2cf07a730" translate="yes" xml:space="preserve">
          <source>Note cleanup time. When storing a note in the note store, each note is given lifetime. Every &lt;code&gt;timeout&lt;/code&gt; the note_store process performs a GC to remove the expired note's. Time in milli-seconds.</source>
          <target state="translated">정리 시간을 참고하십시오. 메모 저장소에 메모를 저장하면 각 메모에 수명이 주어집니다. 모든 &lt;code&gt;timeout&lt;/code&gt; note_store 프로세스가 행하는 GC가 만료 된 주의를 제거합니다. 밀리 초 단위의 시간입니다.</target>
        </trans-unit>
        <trans-unit id="0728c4c2bab748430bb05050c43d78407cdbf77b" translate="yes" xml:space="preserve">
          <source>Note of caution</source>
          <target state="translated">주의 사항</target>
        </trans-unit>
        <trans-unit id="b6e15564a2d085965b6a647a62b080ce57e8687b" translate="yes" xml:space="preserve">
          <source>Note support for legacy configuration file with Apache syntax is dropped in OTP-23.</source>
          <target state="translated">Apache 구문을 사용하는 레거시 구성 파일에 대한 지원은 OTP-23에서 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="ec5960d916e9578d7d801b0cab9fba678951306b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;LIMIT_MATCH&lt;/code&gt; and &lt;code&gt;LIMIT_RECURSION&lt;/code&gt; can only reduce the value of the limits set by the caller, not increase them.</source>
          <target state="translated">참고 것을 &lt;code&gt;LIMIT_MATCH&lt;/code&gt; 및 &lt;code&gt;LIMIT_RECURSION&lt;/code&gt; 는 단지 발신자가 설정 한 한계 값을 줄일 수를 증가하지.</target>
        </trans-unit>
        <trans-unit id="5fcd20ceeac028edcb91c3032d79c7d19a743557" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;daemon_info/1&lt;/code&gt; and &lt;code&gt;daemon_info/2&lt;/code&gt; returns different types due to compatibility reasons.</source>
          <target state="translated">참고 &lt;code&gt;daemon_info/1&lt;/code&gt; 및 &lt;code&gt;daemon_info/2&lt;/code&gt; 인해 호환성 이유로 반환 다른 종류.</target>
        </trans-unit>
        <trans-unit id="d24e50ca0ad0e8aeae5b135428467a7fb92766a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;verify_fun&lt;/code&gt; needs to be written in a different form than the corresponding SSL/TLS option, since funs are not accepted on the command line.</source>
          <target state="translated">참고 &lt;code&gt;verify_fun&lt;/code&gt; 의 funs입니다 명령 행에 허용되지 않기 때문에 요구는, 대응하는 SSL / TLS 옵션과는 다른 형태로 기록 될.</target>
        </trans-unit>
        <trans-unit id="52b662fe1f129e8596062fb70fec226b6c4a68bf" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;verify_fun&lt;/code&gt; needs to be written in a different form than the corresponding TLS option, since funs are not accepted on the command line.</source>
          <target state="translated">참고 &lt;code&gt;verify_fun&lt;/code&gt; 의 funs입니다 명령 행에 허용되지 않기 때문에 요구는, 해당 TLS 옵션과는 다른 형태로 기록 될.</target>
        </trans-unit>
        <trans-unit id="1d1c85c3f2e3a52e04f26f9459fd07fac45960dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;watchdog&lt;/code&gt;, &lt;code&gt;peer&lt;/code&gt;, &lt;code&gt;apps&lt;/code&gt;, &lt;code&gt;caps&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; entries depend on connectivity with the peer and may not be present. Note also that the &lt;code&gt;statistics&lt;/code&gt; entry presents values accumulated during the lifetime of the transport configuration.</source>
          <target state="translated">참고 &lt;code&gt;watchdog&lt;/code&gt; , &lt;code&gt;peer&lt;/code&gt; , &lt;code&gt;apps&lt;/code&gt; , &lt;code&gt;caps&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 항목이 피어와의 연결에 의존되지 않을 수 있습니다. 또한 &lt;code&gt;statistics&lt;/code&gt; 항목은 전송 구성 수명 동안 누적 된 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="336af6e83620751fb885cf9732b59c5d61916d15" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;{error,encode}&lt;/code&gt; is the only return value which guarantees that the request has &lt;strong&gt;not&lt;/strong&gt; been sent over the transport connection.</source>
          <target state="translated">참고 것을 &lt;code&gt;{error,encode}&lt;/code&gt; 요청이 것을 보장하는 유일한 반환 값이 &lt;strong&gt;없습니다&lt;/strong&gt; 전송 연결을 통해 전송되어가.</target>
        </trans-unit>
        <trans-unit id="c43786df6d68a9130e86553a3fb94cd475618c7f" translate="yes" xml:space="preserve">
          <source>Note that EdDSA passhrases (Curves 25519 and 448) are not implemented.</source>
          <target state="translated">EdDSA 암호 (Curves 25519 및 448)는 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90fbe442617bf7481c90ae87dcf9bb86893f3220" translate="yes" xml:space="preserve">
          <source>Note that Erlang shell specific functions and control sequences like for example &lt;code&gt;h().&lt;/code&gt; are not supported.</source>
          <target state="translated">예를 들어 &lt;code&gt;h().&lt;/code&gt; 와 같은 Erlang 쉘 특정 함수 및 제어 시퀀스에 유의하십시오 . 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0fdecc142de3ad70dcbabaed28cc8ece32529ae" translate="yes" xml:space="preserve">
          <source>Note that RFC 3588 did not allow 5xxx result codes in answers setting the E-bit, while RFC 6733 does. This is a potential interoperability problem since the Diameter protocol version has not changed.</source>
          <target state="translated">RFC 3588은 E- 비트 설정에 5xxx 결과 코드를 허용하지 않지만 RFC 6733은 응답하지 않습니다. Diameter 프로토콜 버전이 변경되지 않았기 때문에 잠재적 인 상호 운용성 문제입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
