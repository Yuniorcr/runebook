<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="35c6e799b94495d942c887de378767b8bf60fab5" translate="yes" xml:space="preserve">
          <source>Call Statistics</source>
          <target state="translated">통화 통계</target>
        </trans-unit>
        <trans-unit id="39312e806d3f1ec58faae16ac790feff4beeac35" translate="yes" xml:space="preserve">
          <source>Call a NIF that first performs a chunk of the work, then invokes the &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt; enif_schedule_nif&lt;/a&gt;&lt;/code&gt; function to schedule another NIF call to perform the next chunk. The final call scheduled in this manner can then return the overall result.</source>
          <target state="translated">먼저 작업 청크를 수행하는 NIF를 호출 한 다음 &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt; enif_schedule_nif&lt;/a&gt;&lt;/code&gt; 함수를 호출하여 다음 청크를 수행하기 위해 다른 NIF 호출을 예약합니다. 이러한 방식으로 예약 된 최종 통화는 전체 결과를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4517bf0f809aaf1e241952932bd6d071e97a1670" translate="yes" xml:space="preserve">
          <source>Call a NIF that first performs a chunk of the work, then invokes the &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt;enif_schedule_nif&lt;/a&gt;&lt;/code&gt; function to schedule another NIF call to perform the next chunk. The final call scheduled in this manner can then return the overall result.</source>
          <target state="translated">먼저 작업 덩어리를 수행하는 NIF를 호출 한 후 &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt;enif_schedule_nif&lt;/a&gt;&lt;/code&gt; 함수를 호출하여 다음 덩어리를 수행하도록 다른 NIF 호출을 스케줄하십시오. 이러한 방식으로 예약 된 최종 통화는 전체 결과를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e64aca1cbd78581418480040f30e164b840d03b" translate="yes" xml:space="preserve">
          <source>Call back function to accumulate contents of entity.</source>
          <target state="translated">엔티티의 내용을 축적하는 함수를 콜백하십시오.</target>
        </trans-unit>
        <trans-unit id="25cbcf90fa280c9778e7621dfdd70289b3357c4e" translate="yes" xml:space="preserve">
          <source>Call back function to decide what to do if the scanner runs into EOF before the document is complete.</source>
          <target state="translated">문서가 완성되기 전에 스캐너가 EOF에 도달 할 경우 수행 할 작업을 결정하는 기능을 콜백합니다.</target>
        </trans-unit>
        <trans-unit id="305e72ce9d0178fb37627379b7066e3998f1aaff" translate="yes" xml:space="preserve">
          <source>Call back function to fetch an external resource.</source>
          <target state="translated">외부 리소스를 가져 오려면 함수를 콜백하십시오.</target>
        </trans-unit>
        <trans-unit id="f1d17c05f561817d9262782ed4703874ffa16a47" translate="yes" xml:space="preserve">
          <source>Call back function to handle scanner events.</source>
          <target state="translated">스캐너 이벤트를 처리하기위한 콜백 기능.</target>
        </trans-unit>
        <trans-unit id="967a892c17aad400146f3cd8a0b41cd0e008b98d" translate="yes" xml:space="preserve">
          <source>Call back function to process the document entities once identified.</source>
          <target state="translated">식별 된 문서 엔티티를 처리하는 함수를 콜백하십시오.</target>
        </trans-unit>
        <trans-unit id="e43990d9029a1b5faffe47cfb2a73c40d38948b7" translate="yes" xml:space="preserve">
          <source>Call count tracing is very lightweight compared to other forms of tracing since no trace message has to be generated. Some measurements indicates performance degradation in the vicinity of 10 percent.</source>
          <target state="translated">추적 메시지를 생성 할 필요가 없기 때문에 통화 수 추적은 다른 형식의 추적에 비해 매우 가볍습니다. 일부 측정 결과는 10 % 부근에서 성능 저하를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1d9d8ff2abc216537369a4f6c51252cf41bb671a" translate="yes" xml:space="preserve">
          <source>Call count tracing is very lightweight compared to other forms of tracing since no trace message has to be generated. Some measurements indicates performance degradations in the vicinity of 10 percent.</source>
          <target state="translated">추적 메시지를 생성 할 필요가 없기 때문에 통화 수 추적은 다른 형식의 추적에 비해 매우 가볍습니다. 일부 측정 결과는 10 % 부근에서 성능 저하를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9ed8c88acf1e0b8225e507d6c8cef5617c61d6b6" translate="yes" xml:space="preserve">
          <source>Call these iteration functions on nodes that contain a replica of the table. Each call to the function &lt;code&gt;Fun&lt;/code&gt; access the table and if the table resides on another node it generates much unnecessary network traffic.</source>
          <target state="translated">테이블의 복제본이 포함 된 노드에서 이러한 반복 함수를 호출하십시오. &lt;code&gt;Fun&lt;/code&gt; 함수를 호출 할 때마다 테이블에 액세스하고 테이블이 다른 노드에 있으면 불필요한 네트워크 트래픽이 많이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2a5f2658aeaf93347d628cb22d1c27eae9164e5d" translate="yes" xml:space="preserve">
          <source>Call this function in order to cancel a previous asynchronous call to, e.g. &lt;code&gt;&lt;a href=&quot;#recv-3&quot;&gt;recv/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;&lt;a href=&quot;#recv-3&quot;&gt;recv/3&lt;/a&gt;&lt;/code&gt; 에 대한 이전 비동기 호출을 취소하려면이 함수를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="92a83b9ff602a28ae97d4ee0c90eb3fa1240e7fa" translate="yes" xml:space="preserve">
          <source>Call this function to stop cover test on nodes previously added with &lt;code&gt;&lt;a href=&quot;#add_nodes-1&quot;&gt;ct_cover:add_nodes/1&lt;/a&gt;&lt;/code&gt;. Results on the remote node are transferred to the &lt;code&gt;Common Test&lt;/code&gt; node.</source>
          <target state="translated">이전에 &lt;code&gt;&lt;a href=&quot;#add_nodes-1&quot;&gt;ct_cover:add_nodes/1&lt;/a&gt;&lt;/code&gt; 로 추가 된 노드에서 커버 테스트를 중지하려면이 함수를 호출하십시오 . 원격 노드의 결과는 &lt;code&gt;Common Test&lt;/code&gt; 노드 로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="37045b168b3bc333ac8bca52ef56747d12a1101f" translate="yes" xml:space="preserve">
          <source>Call this function when profiling has been stopped to display the results per process, that is:</source>
          <target state="translated">프로세스 당 결과를 표시하기 위해 프로파일 링이 중지 된 경우이 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="c7eed74fd1bbb46205f4a5686245f8e5040d0026" translate="yes" xml:space="preserve">
          <source>Call tracing with &lt;code&gt;global&lt;/code&gt; option only affects external function calls. This was earlier handled by inserting a special trace instruction in export entries without the use of breakpoints. With the new non-blocking tracing we want to avoid special handling for global tracing and make use of the staging and atomic switching within the breakpoint mechanism. The solution was to create the same type of breakpoint structure for a global call trace. The difference to local tracing is that we insert the &lt;code&gt;op_i_generic_breakpoint&lt;/code&gt; instruction (with its pointer at offset -4) in the export entry rather than in the code.</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt; 옵션을 사용한 호출 추적 은 외부 함수 호출에만 영향을줍니다. 이전에는 중단 점을 사용하지 않고 내보내기 항목에 특수 추적 명령을 삽입하여 처리했습니다. 새로운 비 차단 추적을 통해 글로벌 추적에 대한 특수 처리를 피하고 중단 점 메커니즘 내에서 스테이징 및 원자 적 전환을 사용하려고합니다. 해결책은 전역 호출 추적에 대해 동일한 유형의 중단 점 구조를 만드는 것이 었습니다. 로컬 추적과의 차이점은 &lt;code&gt;op_i_generic_breakpoint&lt;/code&gt; 명령어 (포인터가 오프셋 -4에 있음)를 코드가 아닌 내보내기 항목에 삽입한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eea8e2a2479f703038c465d2c2ffcd082e88cb6f" translate="yes" xml:space="preserve">
          <source>Callback = atom()</source>
          <target state="translated">콜백 = atom ()</target>
        </trans-unit>
        <trans-unit id="9c55daf6e61f9dc1556f1ec913e0ca99b7e0ea38" translate="yes" xml:space="preserve">
          <source>Callback Functions</source>
          <target state="translated">콜백 함수</target>
        </trans-unit>
        <trans-unit id="ad8da05d8ad38ed7c0c50c2aa6868aeca72727cb" translate="yes" xml:space="preserve">
          <source>Callback Module</source>
          <target state="translated">콜백 모듈</target>
        </trans-unit>
        <trans-unit id="61dfb922d9f46c947d009d0fb95ea292779f3dc7" translate="yes" xml:space="preserve">
          <source>Callback for &lt;code&gt;ct_telnet.erl&lt;/code&gt;.</source>
          <target state="translated">대한 콜백 &lt;code&gt;ct_telnet.erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e45c8484398e4aeac5267b27d0e1fb6f862e303" translate="yes" xml:space="preserve">
          <source>Callback function &lt;code&gt;TraverseFun&lt;/code&gt; is used for traversing the table. It is to return a list of objects terminated by either &lt;code&gt;[]&lt;/code&gt; or a nullary fun to be used for traversing the not yet traversed objects of the table. Any other return value is immediately returned as value of the query evaluation. Unary &lt;code&gt;TraverseFun&lt;/code&gt;s are to accept a match specification as argument. The match specification is created by the parse transform by analyzing the pattern of the generator calling &lt;code&gt;qlc:table/2&lt;/code&gt; and filters using variables introduced in the pattern. If the parse transform cannot find a match specification equivalent to the pattern and filters, &lt;code&gt;TraverseFun&lt;/code&gt; is called with a match specification returning every object.</source>
          <target state="translated">콜백 함수 &lt;code&gt;TraverseFun&lt;/code&gt; 은 테이블을 순회하는 데 사용됩니다. 아직 트래버스되지 않은 테이블의 개체를 순회하는 데 사용하기 위해 &lt;code&gt;[]&lt;/code&gt; 또는 널 (null) 재미로 종료 된 개체 목록을 반환 합니다. 다른 반환 값은 즉시 쿼리 평가 값으로 반환됩니다. 단항 &lt;code&gt;TraverseFun&lt;/code&gt; 은 일치 스펙을 인수로 승인해야합니다. 일치 스펙은 &lt;code&gt;qlc:table/2&lt;/code&gt; 를 호출하는 생성기의 패턴을 분석하고 패턴에 도입 된 변수를 사용하여 필터를 분석하여 구문 분석 변환에 의해 작성됩니다 . 구문 분석 변환이 패턴 및 필터와 동등한 일치 스펙을 찾을 수없는 경우 &lt;code&gt;TraverseFun&lt;/code&gt; 은 모든 오브젝트를 리턴하는 일치 스펙으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="04f9a377a5245adf1c0c727ef509b19ea04d764a" translate="yes" xml:space="preserve">
          <source>Callback functions</source>
          <target state="translated">콜백 함수</target>
        </trans-unit>
        <trans-unit id="37556ac19058ca5c17bab63cd838a12f2880d206" translate="yes" xml:space="preserve">
          <source>Callback functions that are optional for the user of the behaviour to implement are specified by use of the &lt;code&gt;-optional_callbacks&lt;/code&gt; attribute:</source>
          <target state="translated">구현할 동작 사용자에게 선택적인 콜백 함수는 &lt;code&gt;-optional_callbacks&lt;/code&gt; 속성 을 사용하여 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="a04bb6692677302b06dcc4155d24ffed7a1d8b90" translate="yes" xml:space="preserve">
          <source>Callback invoked prior to terminating the transport process of a transport connection having watchdog state &lt;code&gt;OKAY&lt;/code&gt;. Applied to &lt;code&gt;application|service|transport&lt;/code&gt; and the &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; and &lt;code&gt;&lt;code&gt;diameter_app:peer()&lt;/code&gt;&lt;/code&gt; in question: &lt;code&gt;application&lt;/code&gt; indicates that the diameter application is being stopped, &lt;code&gt;service&lt;/code&gt; that the service in question is being stopped by &lt;code&gt;&lt;a href=&quot;#stop_service-1&quot;&gt;stop_service/1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;transport&lt;/code&gt; that the transport in question is being removed by &lt;code&gt;&lt;a href=&quot;#remove_transport-2&quot;&gt;remove_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">워치 독 상태가 &lt;code&gt;OKAY&lt;/code&gt; 인 전송 연결의 전송 프로세스를 종료하기 전에 콜백이 호출되었습니다 . 에 적용 &lt;code&gt;application|service|transport&lt;/code&gt; 과 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;code&gt;diameter_app:peer()&lt;/code&gt;&lt;/code&gt; 문제 : &lt;code&gt;application&lt;/code&gt; , 직경 응용 프로그램이 중지되고 있음을 나타냅니다 &lt;code&gt;service&lt;/code&gt; 해당 서비스가 중지되고 있음을 &lt;code&gt;&lt;a href=&quot;#stop_service-1&quot;&gt;stop_service/1&lt;/a&gt;&lt;/code&gt; , 및 &lt;code&gt;transport&lt;/code&gt; 수송가 문제는 &lt;code&gt;&lt;a href=&quot;#remove_transport-2&quot;&gt;remove_transport/2&lt;/a&gt;&lt;/code&gt; 에 의해 제거되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="66eade566a1aabb00b9616d9f85c98561a92d0e8" translate="yes" xml:space="preserve">
          <source>Callback invoked upon reception of CER/CEA during capabilities exchange in order to ask whether or not the connection should be accepted. Applied to the &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; and &lt;code&gt;#diameter_caps{}&lt;/code&gt; record of the connection.</source>
          <target state="translated">연결 허용 여부를 묻기 위해 기능 교환 중 CER / CEA 수신시 콜백이 호출되었습니다. 연결의 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 및 &lt;code&gt;#diameter_caps{}&lt;/code&gt; 레코드에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8170a9b43176c43c83ab38fea10e4e72c195d1f2" translate="yes" xml:space="preserve">
          <source>Callback module for &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt;, for connecting to a Telnet server on a UNIX host.</source>
          <target state="translated">UNIX 호스트의 Telnet 서버에 연결하기 위한 &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; 의 콜백 모듈 .</target>
        </trans-unit>
        <trans-unit id="723d576b61f4090ef99d45ef635768456422a654" translate="yes" xml:space="preserve">
          <source>Callback module for ct_telnet, for connecting to a Telnet server on a UNIX host.</source>
          <target state="translated">UNIX 호스트의 Telnet 서버에 연결하기위한 ct_telnet의 콜백 모듈.</target>
        </trans-unit>
        <trans-unit id="c6227e8f008e1e3653b7695696953858c51a783a" translate="yes" xml:space="preserve">
          <source>Callback module for customized logging of errors, warnings, and info messages. The callback module must implement the &lt;code&gt;tftp_logger&lt;/code&gt; behavior, see &lt;code&gt;&lt;a href=&quot;#tftp_logger&quot;&gt;LOGGER FUNCTIONS&lt;/a&gt;&lt;/code&gt;. The default module is &lt;code&gt;tftp_logger&lt;/code&gt;.</source>
          <target state="translated">오류, 경고 및 정보 메시지의 사용자 정의 로깅을위한 콜백 모듈. 콜백 모듈은 &lt;code&gt;tftp_logger&lt;/code&gt; 동작을 구현해야합니다 ( &lt;code&gt;&lt;a href=&quot;#tftp_logger&quot;&gt;LOGGER FUNCTIONS&lt;/a&gt;&lt;/code&gt; 참조) . 기본 모듈은 &lt;code&gt;tftp_logger&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac834d27797dbad127ce8fd6d8a2319b5f46c402" translate="yes" xml:space="preserve">
          <source>Callback module for users of the Megaco application</source>
          <target state="translated">Megaco 애플리케이션 사용자를위한 콜백 모듈</target>
        </trans-unit>
        <trans-unit id="b474f7579efe489c47dcf78d665d0cd713f942e9" translate="yes" xml:space="preserve">
          <source>Callback module for using an SSH agent instead of the default ssh_file callback.</source>
          <target state="translated">기본 ssh_file 콜백 대신 SSH 에이전트를 사용하기위한 콜백 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="55798c61abfa41a7a5297d6740d1e64b1d565485" translate="yes" xml:space="preserve">
          <source>Callback module in which messages of the Diameter application are handled. See &lt;code&gt;diameter_app(3)&lt;/code&gt; for the required interface and semantics.</source>
          <target state="translated">직경 응용 프로그램의 메시지가 처리되는 콜백 모듈. 필요한 인터페이스 및 시맨틱에 대해서는 &lt;code&gt;diameter_app(3)&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b07b4a00700ebf2a1936cd09849d3229f8cea9e" translate="yes" xml:space="preserve">
          <source>Callback modules for &lt;code&gt;gen_server&lt;/code&gt;, &lt;code&gt;gen_statem&lt;/code&gt;, and &lt;code&gt;gen_event&lt;/code&gt; can also change the value of &lt;code&gt;Misc&lt;/code&gt; by exporting a function &lt;code&gt;format_status/2&lt;/code&gt;, which contributes module-specific information. For details, see &lt;code&gt;&lt;a href=&quot;gen_server#Module:format_status-2&quot;&gt; gen_server:format_status/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_statem#Module:format_status-2&quot;&gt; gen_statem:format_status/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;gen_event#Module:format_status-2&quot;&gt; gen_event:format_status/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; , &lt;code&gt;gen_statem&lt;/code&gt; 및 &lt;code&gt;gen_event&lt;/code&gt; 에 대한 콜백 모듈은 모듈 별 정보를 제공 하는 함수 &lt;code&gt;format_status/2&lt;/code&gt; 를 내보내 &lt;code&gt;Misc&lt;/code&gt; 값을 변경할 수도 있습니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;gen_server#Module:format_status-2&quot;&gt; gen_server:format_status/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;gen_statem#Module:format_status-2&quot;&gt; gen_statem:format_status/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;gen_event#Module:format_status-2&quot;&gt; gen_event:format_status/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="63edefe6aafdd040e89d039ff830e8a61ffa1b95" translate="yes" xml:space="preserve">
          <source>Callback modules for &lt;code&gt;gen_server&lt;/code&gt;, &lt;code&gt;gen_statem&lt;/code&gt;, and &lt;code&gt;gen_event&lt;/code&gt; can also change the value of &lt;code&gt;Misc&lt;/code&gt; by exporting a function &lt;code&gt;format_status/2&lt;/code&gt;, which contributes module-specific information. For details, see &lt;code&gt;&lt;a href=&quot;gen_server#Module:format_status-2&quot;&gt;gen_server:format_status/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_statem#Module:format_status-2&quot;&gt;gen_statem:format_status/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;gen_event#Module:format_status-2&quot;&gt;gen_event:format_status/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; , &lt;code&gt;gen_statem&lt;/code&gt; 및 &lt;code&gt;gen_event&lt;/code&gt; 에 대한 콜백 모듈은 모듈 별 정보를 제공하는 &lt;code&gt;format_status/2&lt;/code&gt; 함수를 내보내 &lt;code&gt;Misc&lt;/code&gt; 의 값을 변경할 수도 있습니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;gen_server#Module:format_status-2&quot;&gt;gen_server:format_status/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;gen_statem#Module:format_status-2&quot;&gt;gen_statem:format_status/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;gen_event#Module:format_status-2&quot;&gt;gen_event:format_status/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a42e9b08e0786b523d53e7aaa69806b6b4c7c7b" translate="yes" xml:space="preserve">
          <source>Callback timeouts</source>
          <target state="translated">콜백 시간 초과</target>
        </trans-unit>
        <trans-unit id="9fdc2cfe374fa5bde1e4e458854875e1709add1c" translate="yes" xml:space="preserve">
          <source>Callbacks</source>
          <target state="translated">Callbacks</target>
        </trans-unit>
        <trans-unit id="5393b6e7c5c51638adb55313f4e4ecf06a0243fc" translate="yes" xml:space="preserve">
          <source>Callbacks functions for a &lt;code&gt;&lt;a href=&quot;#ussi&quot;&gt;&lt;i&gt;User Supplied Socket Implementation&lt;/i&gt;&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;#ei_socket_callbacks_fields&quot;&gt;Documentation of each field&lt;/a&gt;&lt;/code&gt; can be found in the</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#ussi&quot;&gt;&lt;i&gt;User Supplied Socket Implementation&lt;/i&gt;&lt;/a&gt;&lt;/code&gt; 위한 콜백 함수 . &lt;code&gt;&lt;a href=&quot;#ei_socket_callbacks_fields&quot;&gt;Documentation of each field&lt;/a&gt;&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="0388e8bb7b30f62d43703b0a0c0a90fc579a8ead" translate="yes" xml:space="preserve">
          <source>Called after an asynchronous call has completed. The asynchronous call is started with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_async&quot;&gt; erl_driver:driver_async&lt;/a&gt;&lt;/code&gt;. This function is called from the Erlang emulator thread, as opposed to the asynchronous function, which is called in some thread (if multi-threading is enabled).</source>
          <target state="translated">비동기 호출이 완료된 후에 호출됩니다. 비동기 호출은 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_async&quot;&gt; erl_driver:driver_async&lt;/a&gt;&lt;/code&gt; 로 시작됩니다 . 이 함수는 일부 스레드에서 호출되는 비동기 함수와는 달리 Erlang 에뮬레이터 스레드에서 호출됩니다 (멀티 스레딩이 활성화 된 경우).</target>
        </trans-unit>
        <trans-unit id="1424d68bc26afe36f6e438d92e2344fe5359e183" translate="yes" xml:space="preserve">
          <source>Called after an asynchronous call has completed. The asynchronous call is started with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_async&quot;&gt;erl_driver:driver_async&lt;/a&gt;&lt;/code&gt;. This function is called from the Erlang emulator thread, as opposed to the asynchronous function, which is called in some thread (if multi-threading is enabled).</source>
          <target state="translated">비동기 호출이 완료된 후 호출됩니다. 비동기 호출은 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_async&quot;&gt;erl_driver:driver_async&lt;/a&gt;&lt;/code&gt; 로 시작됩니다 . 이 함수는 일부 스레드에서 호출되는 비동기 함수와 달리 Erlang 에뮬레이터 스레드에서 호출됩니다 (멀티 스레딩이 활성화 된 경우).</target>
        </trans-unit>
        <trans-unit id="308f76c161337017286f205aef3ab09cb6ea041d" translate="yes" xml:space="preserve">
          <source>Called after the basic message processing (MPD) has been done, but before the pdu is handed over to the master-agent for primary processing.</source>
          <target state="translated">기본 메시지 처리 (MPD)가 완료된 후, 그러나 pdu가 1 차 처리를 위해 마스터 에이전트로 전달되기 전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a313d3073d9eea56873be11a826fd840a7e0d86d" translate="yes" xml:space="preserve">
          <source>Called after the basic message processing (MPD) has been done, but before the pdu is handed over to the server for primary processing.</source>
          <target state="translated">MPD (Basic Message Processing)가 완료된 후, pdu가 1 차 처리를 위해 서버로 전달되기 전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ff191d8e8919401c02df5d752c7753bbfc148a86" translate="yes" xml:space="preserve">
          <source>Called any time after the driver's timer reaches &lt;code&gt;0&lt;/code&gt;. The timer is activated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_set_timer&quot;&gt; erl_driver:driver_set_timer&lt;/a&gt;&lt;/code&gt;. No priorities or ordering exist among drivers, so if several drivers time out at the same time, anyone of them is called first.</source>
          <target state="translated">운전자의 타이머가 &lt;code&gt;0&lt;/code&gt; 에 도달 한 후 언제든지 호출 됩니다. 타이머는 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_set_timer&quot;&gt; erl_driver:driver_set_timer&lt;/a&gt;&lt;/code&gt; 로 활성화됩니다 . 드라이버간에 우선 순위 나 순서가 존재하지 않으므로 여러 드라이버가 동시에 시간 초과되면 그중 누구라도 먼저 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e5fe3aacb675f5586e55ac426e9e29a0553867e0" translate="yes" xml:space="preserve">
          <source>Called any time after the driver's timer reaches &lt;code&gt;0&lt;/code&gt;. The timer is activated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_set_timer&quot;&gt;erl_driver:driver_set_timer&lt;/a&gt;&lt;/code&gt;. No priorities or ordering exist among drivers, so if several drivers time out at the same time, anyone of them is called first.</source>
          <target state="translated">운전자 타이머가 &lt;code&gt;0&lt;/code&gt; 에 도달 한 후 언제든지 호출 됩니다. 타이머는 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_set_timer&quot;&gt;erl_driver:driver_set_timer&lt;/a&gt;&lt;/code&gt; 로 활성화됩니다 . 드라이버간에 우선 순위 나 순서가 없으므로 여러 드라이버가 동시에 시간 초과되면 해당 드라이버를 먼저 호출합니다.</target>
        </trans-unit>
        <trans-unit id="81eabbdc5601ceaa0bccb714043c53b451726d6f" translate="yes" xml:space="preserve">
          <source>Called at the reception of a message (before &lt;strong&gt;any&lt;/strong&gt; processing has been done).</source>
          <target state="translated">메시지의 수신시 호출 (이전에 &lt;strong&gt;어떤&lt;/strong&gt; 처리를 수행하고있다).</target>
        </trans-unit>
        <trans-unit id="bf59df7706e69db3cc159c1ee57e97f02070c14b" translate="yes" xml:space="preserve">
          <source>Called before the basic message processing (MPD) is done, when a pdu has been received from the master-agent.</source>
          <target state="translated">마스터 에이전트로부터 pdu를 수신하면 MPD (기본 메시지 처리)가 완료되기 전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="67cc06ab5c5cdaf22f4e18059ff7135bed75b26e" translate="yes" xml:space="preserve">
          <source>Called before the fun is unregistered. Here any cleaning up can be done. The return value is not important, but is passed back to the caller of &lt;code&gt;clear_crypto_key_fun/0&lt;/code&gt; as part of its return value.</source>
          <target state="translated">재미가 등록 해제되기 전에 호출됩니다. 여기에서 모든 정리를 수행 할 수 있습니다. 반환 값은 중요하지 않지만 반환 값의 일부로 &lt;code&gt;clear_crypto_key_fun/0&lt;/code&gt; 호출자에게 다시 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="60cc53ceda191e4c7c43073a2ca95d2429376ca7" translate="yes" xml:space="preserve">
          <source>Called before the sending of a message (after &lt;strong&gt;all&lt;/strong&gt; processing has been done).</source>
          <target state="translated">메시지를 보내기 전에 호출합니다 ( &lt;strong&gt;모든&lt;/strong&gt; 처리가 완료된 후 ).</target>
        </trans-unit>
        <trans-unit id="411e859542f736dac045f8721e0a466752068640" translate="yes" xml:space="preserve">
          <source>Called by &lt;code&gt;&lt;a href=&quot;net_adm&quot;&gt;net_adm:names/0&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;Host&lt;/code&gt; defaults to the localhost. Returns the names and associated port numbers of the Erlang nodes that &lt;code&gt;epmd&lt;/code&gt; registered at the specified host. Returns &lt;code&gt;{error, address}&lt;/code&gt; if &lt;code&gt;epmd&lt;/code&gt; is not operational.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;net_adm&quot;&gt;net_adm:names/0&lt;/a&gt;&lt;/code&gt; 에 의해 호출됩니다 . &lt;code&gt;Host&lt;/code&gt; 기본적으로 localhost입니다. 지정된 호스트에 &lt;code&gt;epmd&lt;/code&gt; 가 등록한 Erlang 노드의 이름과 관련 포트 번호를 반환합니다 . 반환 &lt;code&gt;{error, address}&lt;/code&gt; 경우 &lt;code&gt;epmd&lt;/code&gt; 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="754186ab8b7082c0674d04f3bdaf7fcddc1ab3a3" translate="yes" xml:space="preserve">
          <source>Called by the &lt;code&gt;erl_ddll&lt;/code&gt; driver when the driver is unloaded. (It is only called in dynamic drivers.)</source>
          <target state="translated">드라이버가 언로드 될 때 &lt;code&gt;erl_ddll&lt;/code&gt; 드라이버에 의해 호출됩니다 . (동적 드라이버에서만 호출됩니다.)</target>
        </trans-unit>
        <trans-unit id="655d271abcfd7d76d286a17dda2d7657206096c8" translate="yes" xml:space="preserve">
          <source>Called by the distribution module to get which port the local node should listen to when accepting new distribution requests.</source>
          <target state="translated">새 배포 요청을 수락 할 때 로컬 노드가 수신해야하는 포트를 가져 오기 위해 배포 모듈에서 호출합니다.</target>
        </trans-unit>
        <trans-unit id="e0f458d70c750018b87e9944e64a8528f08c2ec7" translate="yes" xml:space="preserve">
          <source>Called by the distribution module to resolves the &lt;code&gt;Host&lt;/code&gt; to an IP address of a remote node.</source>
          <target state="translated">&lt;code&gt;Host&lt;/code&gt; 를 원격 노드의 IP 주소로 확인하기 위해 배포 모듈에서 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="650a5975977f531507f62d29a2ce95a7a1cfb83f" translate="yes" xml:space="preserve">
          <source>Called by the distribution module. Resolves the &lt;code&gt;Host&lt;/code&gt; to an IP address.</source>
          <target state="translated">배포 모듈에서 호출합니다. 해결 &lt;code&gt;Host&lt;/code&gt; 의 IP 주소를.</target>
        </trans-unit>
        <trans-unit id="85b869badf1456352f06af55e42a19b0066bf142" translate="yes" xml:space="preserve">
          <source>Called directly after the driver has been loaded by &lt;code&gt; erl_ddll:load_driver/2&lt;/code&gt; (actually when the driver is added to the driver list). The driver is to return &lt;code&gt;0&lt;/code&gt;, or, if the driver cannot initialize, &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt; erl_ddll:load_driver/2&lt;/code&gt; 에 의해 드라이버가로드 된 직후에 호출됩니다 (실제로 드라이버가 드라이버 목록에 추가 될 때). 드라이버는 &lt;code&gt;0&lt;/code&gt; 을 반환 하거나 드라이버가 초기화 할 수없는 경우 &lt;code&gt;-1&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e6e67ee5139f5c3d24c6add77615125e4e640a01" translate="yes" xml:space="preserve">
          <source>Called directly after the driver has been loaded by &lt;code&gt;erl_ddll:load_driver/2&lt;/code&gt; (actually when the driver is added to the driver list). The driver is to return &lt;code&gt;0&lt;/code&gt;, or, if the driver cannot initialize, &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erl_ddll:load_driver/2&lt;/code&gt; 에 의해 드라이버가로드 된 직후에 호출됩니다 (실제로 드라이버가 드라이버 목록에 추가 될 때). 드라이버는 &lt;code&gt;0&lt;/code&gt; 을 반환 하거나 드라이버를 초기화 할 수없는 경우 &lt;code&gt;-1&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="987000d4d4006dd9dc12f7c300ae64273a69aeb6" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to continue its execution (for example, after it has been suspended). This function never returns.</source>
          <target state="translated">프로세스가 실행을 계속할 때 (예 : 일시 중단 된 후) &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 에서 호출됩니다 . 이 함수는 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98e9ec7ab4eccd3e4ae575952428dd16c1ea3ec0" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to perform a code change. The code change is used when the internal data structure has changed. This function converts argument &lt;code&gt;Misc&lt;/code&gt; to the new data structure. &lt;code&gt;OldVsn&lt;/code&gt; is attribute &lt;strong&gt;vsn&lt;/strong&gt; of the old version of the &lt;code&gt;Module&lt;/code&gt;. If no such attribute is defined, the atom &lt;code&gt;undefined&lt;/code&gt; is sent.</source>
          <target state="translated">프로세스가 코드 변경을 수행 할 때 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 에서 호출됩니다 . 코드 변경은 내부 데이터 구조가 변경되었을 때 사용됩니다. 이 함수는 &lt;code&gt;Misc&lt;/code&gt; 인수 를 새 데이터 구조 로 변환 합니다. &lt;code&gt;OldVsn&lt;/code&gt; 은 이전 버전의 &lt;code&gt;Module&lt;/code&gt; 속성 &lt;strong&gt;vsn&lt;/strong&gt; 입니다 . 이러한 속성이 정의되어 있지 않으면 정의 &lt;code&gt;undefined&lt;/code&gt; 원자가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="419bfc7b5724ea2b2f35b364df0a94b7fb0dc40f" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to replace its current state. &lt;code&gt;NState&lt;/code&gt; is the value returned by &lt;code&gt;&lt;a href=&quot;#replace_state-3&quot;&gt;replace_state/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로세스가 현재 상태를 대체 할 때 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 에서 호출됩니다 . &lt;code&gt;NState&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#replace_state-3&quot;&gt;replace_state/3&lt;/a&gt;&lt;/code&gt; 에서 반환 된 값 입니다.</target>
        </trans-unit>
        <trans-unit id="bfa9e2f41a9f72c39043fd4f54a03f6d2aa7c6c5" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to return a term that reflects its current state. &lt;code&gt;State&lt;/code&gt; is the value returned by &lt;code&gt;&lt;a href=&quot;#get_state-2&quot;&gt;get_state/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로세스가 현재 상태를 반영하는 용어를 반환 할 때 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 에서 호출됩니다 . &lt;code&gt;State&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#get_state-2&quot;&gt;get_state/2&lt;/a&gt;&lt;/code&gt; 가 반환하는 값 입니다.</target>
        </trans-unit>
        <trans-unit id="9a05f5f13a8adcd5f39e22e499b3c5e09ab8f8ff" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to terminate. For example, this function is called when the process is suspended and its parent orders shutdown. It gives the process a chance to do a cleanup. This function never returns.</source>
          <target state="translated">프로세스가 종료 될 때 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 에서 호출 됩니다. 예를 들어,이 함수는 프로세스가 일시 중지되고 상위 주문이 종료 될 때 호출됩니다. 프로세스가 정리를 수행 할 수있는 기회를 제공합니다. 이 함수는 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="262d7b78c6487d8a39946866f1d11a39d5496a09" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to continue its execution (for example, after it has been suspended). This function never returns.</source>
          <target state="translated">프로세스가 실행을 계속할 때 (예 : 일시 중단 된 후) &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 에서 호출됩니다 . 이 함수는 절대 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73172cc1a7cb2d69c85f4a96da6765b4101ba755" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to perform a code change. The code change is used when the internal data structure has changed. This function converts argument &lt;code&gt;Misc&lt;/code&gt; to the new data structure. &lt;code&gt;OldVsn&lt;/code&gt; is attribute &lt;strong&gt;vsn&lt;/strong&gt; of the old version of the &lt;code&gt;Module&lt;/code&gt;. If no such attribute is defined, the atom &lt;code&gt;undefined&lt;/code&gt; is sent.</source>
          <target state="translated">프로세스가 코드 변경을 수행 할 때 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 에서 호출됩니다 . 내부 데이터 구조가 변경되면 코드 변경이 사용됩니다. 이 함수는 &lt;code&gt;Misc&lt;/code&gt; 인수 를 새로운 데이터 구조 로 변환 합니다. &lt;code&gt;OldVsn&lt;/code&gt; 은 이전 버전의 &lt;code&gt;Module&lt;/code&gt; 에 대한 속성 &lt;strong&gt;vsn&lt;/strong&gt; 입니다 . 그러한 속성이 정의되어 있지 않으면 정의 &lt;code&gt;undefined&lt;/code&gt; 아톰 이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="594143f9a65ae1c6fe10c4f338068b8a9f905601" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to replace its current state. &lt;code&gt;NState&lt;/code&gt; is the value returned by &lt;code&gt;&lt;a href=&quot;#replace_state-3&quot;&gt;replace_state/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로세스가 현재 상태를 교체 할 때 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 에서 호출됩니다 . &lt;code&gt;NState&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#replace_state-3&quot;&gt;replace_state/3&lt;/a&gt;&lt;/code&gt; 가 반환 한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="d9b3e834b715a254168526e411e95a8a48713b20" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to return a term that reflects its current state. &lt;code&gt;State&lt;/code&gt; is the value returned by &lt;code&gt;&lt;a href=&quot;#get_state-2&quot;&gt;get_state/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로세스가 현재 상태를 반영하는 용어를 리턴 할 때 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 에서 호출됩니다 . &lt;code&gt;State&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#get_state-2&quot;&gt;get_state/2&lt;/a&gt;&lt;/code&gt; 가 반환 한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="e4c98925793456e56a2d33122eb6a311fa293f3d" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to terminate. For example, this function is called when the process is suspended and its parent orders shutdown. It gives the process a chance to do a cleanup. This function never returns.</source>
          <target state="translated">프로세스가 종료 될 때 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 에서 호출 됩니다. 예를 들어,이 기능은 프로세스가 일시 중단되고 상위 주문이 종료 될 때 호출됩니다. 프로세스가 정리를 수행 할 수있는 기회를 제공합니다. 이 함수는 절대 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d565039ea45d2e2d8bf629df70695d8e577068a" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 에서 호출되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c6ebf9fbba1927e0169999540aede92ba5d2b9d7" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;erlang#port_call-3&quot;&gt; erlang:port_call/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#port_call-3&quot;&gt; erlang:port_call/3&lt;/a&gt;&lt;/code&gt; 에서 호출되었습니다 .</target>
        </trans-unit>
        <trans-unit id="239af18064c670c227882eb2c0195d0784143a68" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;erlang#port_call-3&quot;&gt; erlang:port_call/3&lt;/a&gt;&lt;/code&gt;. It works a lot like the &lt;code&gt;control&lt;/code&gt; callback, but uses the external term format for input and output.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#port_call-3&quot;&gt; erlang:port_call/3&lt;/a&gt;&lt;/code&gt; 에서 호출되었습니다 . &lt;code&gt;control&lt;/code&gt; 콜백 과 매우 유사하게 작동 하지만 입력 및 출력에 외부 용어 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ee779128abb96dcaaa77c4845eb5b58fcbdf4ab2" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;erlang#port_call-3&quot;&gt;erlang:port_call/3&lt;/a&gt;&lt;/code&gt;. It works a lot like the &lt;code&gt;control&lt;/code&gt; callback, but uses the external term format for input and output.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#port_call-3&quot;&gt;erlang:port_call/3&lt;/a&gt;&lt;/code&gt; 에서 호출합니다 . &lt;code&gt;control&lt;/code&gt; 콜백 과 매우 유사 하지만 입력 및 출력에 외부 용어 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="647803d0d0c160b1b32fafd3407a185b78e69a6c" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a7a6da0d32374d704f66fa64639e5942279833d" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;erlang#send-2&quot;&gt; erlang:send/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt; erlang:port_command/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#send-2&quot;&gt; erlang:send/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt; erlang:port_command/2&lt;/a&gt;&lt;/code&gt; 에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="eda5333bad3b8e6536c6e400a545bf0c68561f86" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;erlang:open_port/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:open_port/2&lt;/code&gt; 에서 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="52c95806576ffd5c6e9bda3738995849c83e6d48" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;erlang:port_call/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:port_call/3&lt;/code&gt; 에서 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="37967ef10d51ab9623c55cce347e8ac82ffaa69f" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;erlang:port_control/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:port_control/3&lt;/code&gt; 에서 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="76a9c293f08a9964ffe8949415ea15fcd479022c" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;erlang:send/2&lt;/code&gt; and &lt;code&gt;erlang:port_command/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:send/2&lt;/code&gt; 및 &lt;code&gt;erlang:port_command/2&lt;/code&gt; 에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="5b7712d2af65521477e16f6013575117d34b96c0" translate="yes" xml:space="preserve">
          <source>Called in order to close the &lt;code&gt;Listen&lt;/code&gt; handle that originally was passed from the &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; callback.</source>
          <target state="translated">원래 &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; 콜백 에서 전달 된 &lt;code&gt;Listen&lt;/code&gt; 핸들 을 닫기 위해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="ed0e2e44fa4e2d7ed6caea388ba567c2aadfb380" translate="yes" xml:space="preserve">
          <source>Called on behalf of &lt;code&gt;&lt;a href=&quot;erl_driver#driver_select&quot;&gt; erl_driver:driver_select&lt;/a&gt;&lt;/code&gt; when it is safe to close an event object.</source>
          <target state="translated">이벤트 객체를 닫아도 안전 할 때 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_select&quot;&gt; erl_driver:driver_select&lt;/a&gt;&lt;/code&gt; 를 대신하여 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="470a1c0ce98f90a6c63285d61ce7082f47f6706f" translate="yes" xml:space="preserve">
          <source>Called on behalf of &lt;code&gt;&lt;a href=&quot;erl_driver#driver_select&quot;&gt;erl_driver:driver_select&lt;/a&gt;&lt;/code&gt; when it is safe to close an event object.</source>
          <target state="translated">이벤트 객체를 닫는 것이 안전 할 때 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_select&quot;&gt;erl_driver:driver_select&lt;/a&gt;&lt;/code&gt; 를 대신하여 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="23ff0ae2399ea44f77132823a27ee56494ae7347" translate="yes" xml:space="preserve">
          <source>Called to instruct the manager that this agent shall be handled. This function is used when the user knows in advance which agents the manager shall handle. Note that there is an alternate way to do the same thing: Add the agent to the manager config files (see &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files#agents&quot;&gt;agents.conf&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이 에이전트를 처리하도록 관리자에게 지시하기 위해 호출됩니다. 이 기능은 사용자가 관리자가 처리 할 에이전트를 미리 알고있을 때 사용됩니다. 동일한 작업을 수행하는 다른 방법이 있습니다. 에이전트를 관리자 구성 파일에 추가하십시오 ( &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files#agents&quot;&gt;agents.conf&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2c4e12b2b87e916464a480eeba6c90e011990c07" translate="yes" xml:space="preserve">
          <source>Called when a driver event (specified in parameter &lt;code&gt;event&lt;/code&gt;) is signaled. This is used to help asynchronous drivers &quot;wake up&quot; when something occurs.</source>
          <target state="translated">드라이버 이벤트 (매개 변수 &lt;code&gt;event&lt;/code&gt; 에 지정 )가 신호를 받으면 호출됩니다 . 이것은 무언가 발생했을 때 비동기 드라이버가 &quot;일어나도록&quot;돕는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b36813d53908741b8362c286580e5e8b637ec710" translate="yes" xml:space="preserve">
          <source>Called when a locally started handshake has completed successfully.</source>
          <target state="translated">로컬에서 시작된 핸드 셰이크가 성공적으로 완료되었을 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8574d5472a3027867d3ec87879fb27cdaab45a80" translate="yes" xml:space="preserve">
          <source>Called when a monitored process exits. The &lt;code&gt;drv_data&lt;/code&gt; is the data associated with the port for which the process is monitored (using &lt;code&gt;&lt;a href=&quot;erl_driver#driver_monitor_process&quot;&gt; erl_driver:driver_monitor_process&lt;/a&gt;&lt;/code&gt;) and the &lt;code&gt;monitor&lt;/code&gt; corresponds to the &lt;code&gt;ErlDrvMonitor&lt;/code&gt; structure filled in when creating the monitor. The driver interface function &lt;code&gt;&lt;a href=&quot;erl_driver#driver_get_monitored_process&quot;&gt; erl_driver:driver_get_monitored_process&lt;/a&gt;&lt;/code&gt; can be used to retrieve the process ID of the exiting process as an &lt;code&gt;ErlDrvTermData&lt;/code&gt;.</source>
          <target state="translated">모니터링 된 프로세스가 종료 될 때 호출됩니다. &lt;code&gt;drv_data&lt;/code&gt; 는 (사용하는 프로세스 모니터링하는 포트와 연관된 데이터이다 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_monitor_process&quot;&gt; erl_driver:driver_monitor_process&lt;/a&gt;&lt;/code&gt; )와 &lt;code&gt;monitor&lt;/code&gt; 에 해당합니다 &lt;code&gt;ErlDrvMonitor&lt;/code&gt; 의 모니터를 만들 때 충전 구조. 함수 인터페이스 드라이버 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_get_monitored_process&quot;&gt; erl_driver:driver_get_monitored_process&lt;/a&gt;&lt;/code&gt; 는 AS를 유출되는 프로세스의 프로세스 ID 검색하는 데 사용할 수 &lt;code&gt;ErlDrvTermData&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="f5f6a024fd8f77a2ea9867d6adcf09937e5b321e" translate="yes" xml:space="preserve">
          <source>Called when a monitored process exits. The &lt;code&gt;drv_data&lt;/code&gt; is the data associated with the port for which the process is monitored (using &lt;code&gt;&lt;a href=&quot;erl_driver#driver_monitor_process&quot;&gt;erl_driver:driver_monitor_process&lt;/a&gt;&lt;/code&gt;) and the &lt;code&gt;monitor&lt;/code&gt; corresponds to the &lt;code&gt;ErlDrvMonitor&lt;/code&gt; structure filled in when creating the monitor. The driver interface function &lt;code&gt;&lt;a href=&quot;erl_driver#driver_get_monitored_process&quot;&gt;erl_driver:driver_get_monitored_process&lt;/a&gt;&lt;/code&gt; can be used to retrieve the process ID of the exiting process as an &lt;code&gt;ErlDrvTermData&lt;/code&gt;.</source>
          <target state="translated">모니터링 된 프로세스가 종료 될 때 호출됩니다. &lt;code&gt;drv_data&lt;/code&gt; 는 (사용하는 프로세스 모니터링하는 포트와 연관된 데이터이다 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_monitor_process&quot;&gt;erl_driver:driver_monitor_process&lt;/a&gt;&lt;/code&gt; )와 &lt;code&gt;monitor&lt;/code&gt; 에 해당합니다 &lt;code&gt;ErlDrvMonitor&lt;/code&gt; 의 모니터를 만들 때 충전 구조. 함수 인터페이스 드라이버 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_get_monitored_process&quot;&gt;erl_driver:driver_get_monitored_process&lt;/a&gt;&lt;/code&gt; 는 AS를 유출되는 프로세스의 프로세스 ID 검색하는 데 사용할 수 &lt;code&gt;ErlDrvTermData&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="d67e2aa0c472d7e1f331918d874d82a46a103385" translate="yes" xml:space="preserve">
          <source>Called when a port is closed.</source>
          <target state="translated">포트가 닫힐 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="af5703e1882d09239d1d042a60353e00eb2d7742" translate="yes" xml:space="preserve">
          <source>Called when a remotely started handshake has completed successfully.</source>
          <target state="translated">원격으로 시작된 핸드 셰이크가 성공적으로 완료되었을 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="260ba11c56b3301de010c7bb46f13a8d01000aa0" translate="yes" xml:space="preserve">
          <source>Called when an Erlang process has sent data to the port. The data is pointed to by &lt;code&gt;buf&lt;/code&gt;, and is &lt;code&gt;len&lt;/code&gt; bytes. Data is sent to the port with &lt;code&gt;Port ! {self(), {command, Data}}&lt;/code&gt; or with &lt;code&gt;erlang:port_command/2&lt;/code&gt;. Depending on how the port was opened, it is to be either a list of integers &lt;code&gt;0...255&lt;/code&gt; or a binary. See &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt; erlang:port_command/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 프로세스가 데이터를 포트로 보낼 때 호출됩니다. 데이터는이 가리키는 &lt;code&gt;buf&lt;/code&gt; , 및 &lt;code&gt;len&lt;/code&gt; 바이트. 데이터는 &lt;code&gt;Port ! {self(), {command, Data}}&lt;/code&gt; 또는 &lt;code&gt;erlang:port_command/2&lt;/code&gt; . 포트가 어떻게 열렸는지에 따라 정수 &lt;code&gt;0...255&lt;/code&gt; 목록 또는 이진수가됩니다. &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt; erlang:port_command/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9f79f35f10e231c1c5d46754dcc831f0124571c5" translate="yes" xml:space="preserve">
          <source>Called when an Erlang process has sent data to the port. The data is pointed to by &lt;code&gt;buf&lt;/code&gt;, and is &lt;code&gt;len&lt;/code&gt; bytes. Data is sent to the port with &lt;code&gt;Port ! {self(), {command, Data}}&lt;/code&gt; or with &lt;code&gt;erlang:port_command/2&lt;/code&gt;. Depending on how the port was opened, it is to be either a list of integers &lt;code&gt;0...255&lt;/code&gt; or a binary. See &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt;erlang:port_command/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 프로세스가 포트로 데이터를 보냈을 때 호출됩니다. 데이터는이 가리키는 &lt;code&gt;buf&lt;/code&gt; , 및 &lt;code&gt;len&lt;/code&gt; 바이트. 데이터는 &lt;code&gt;Port ! {self(), {command, Data}}&lt;/code&gt; 를 사용하여 포트로 전송됩니다 . {자기 () {명령, 데이터}} 이상에서 &lt;code&gt;erlang:port_command/2&lt;/code&gt; . 포트가 열린 방법에 따라, 정수 &lt;code&gt;0...255&lt;/code&gt; 또는 이진 목록이 됩니다. &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt;erlang:port_command/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fefd076009119dd92492aabc22699c37cd1acfde" translate="yes" xml:space="preserve">
          <source>Called when document has been completely parsed.</source>
          <target state="translated">문서가 완전히 파싱되었을 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d9d5c990ed44bfe60f747ede5eb6362b963aa6ee" translate="yes" xml:space="preserve">
          <source>Called when it is possible to write to a socket.</source>
          <target state="translated">소켓에 쓸 수있을 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="dc2fc86f42c4e06dc8824ff7ab20959ce4ee0279" translate="yes" xml:space="preserve">
          <source>Called when the driver is instantiated, when &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt; is called. The driver is to return a number &amp;gt;= 0 or a pointer, or, if the driver cannot be started, one of three error codes:</source>
          <target state="translated">드라이버가 인스턴스화 될 때 &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 가 호출 될 때 호출됩니다 . 드라이버는 숫자&amp;gt; = 0 또는 포인터를 반환하거나 드라이버를 시작할 수없는 경우 다음 세 가지 오류 코드 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ea08619d53f9130eaa9e346bb5fa5aec56010fde" translate="yes" xml:space="preserve">
          <source>Called when the driver is instantiated, when &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; is called. The driver is to return a number &amp;gt;= 0 or a pointer, or, if the driver cannot be started, one of three error codes:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 가 호출 될 때 드라이버가 인스턴스화 될 때 호출됩니다 . 드라이버는 숫자&amp;gt; = 0 또는 포인터를 반환하거나 드라이버를 시작할 수없는 경우 다음 세 가지 오류 코드 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c7878482ce6f10c4027034352ce73f5aaa4ce9cf" translate="yes" xml:space="preserve">
          <source>Called when the driver is unloaded. A distribution driver will never be unloaded, but we include this for completeness. To be able to clean up after oneself is always a good thing.</source>
          <target state="translated">드라이버가 언로드 될 때 호출됩니다. 배포 드라이버는 언로드되지 않지만 완전성을 위해 이것을 포함합니다. 자신을 정리 한 후에는 항상 좋은 일입니다.</target>
        </trans-unit>
        <trans-unit id="e9777a1b7d37a6943bc53bf03a6d0e91d50d751f" translate="yes" xml:space="preserve">
          <source>Called when the fun is registered, in the process that holds the fun. Here the crypto key fun can do any necessary initializations. If &lt;code&gt;{ok, NewCryptoKeyFun}&lt;/code&gt; is returned, &lt;code&gt;NewCryptoKeyFun&lt;/code&gt; is registered instead of &lt;code&gt;CryptoKeyFun&lt;/code&gt;. If &lt;code&gt;{error, Term}&lt;/code&gt; is returned, the registration is aborted and &lt;code&gt;crypto_key_fun/1&lt;/code&gt; also returns &lt;code&gt;{error, Term}&lt;/code&gt;.</source>
          <target state="translated">재미가있는 프로세스에서 재미가 등록 될 때 호출됩니다. 여기서 암호 키 재미는 필요한 초기화를 수행 할 수 있습니다. 경우 &lt;code&gt;{ok, NewCryptoKeyFun}&lt;/code&gt; 반환되고, &lt;code&gt;NewCryptoKeyFun&lt;/code&gt; 는 대신 등록 &lt;code&gt;CryptoKeyFun&lt;/code&gt; . 경우 &lt;code&gt;{error, Term}&lt;/code&gt; 반환, 등록이 중단되고 &lt;code&gt;crypto_key_fun/1&lt;/code&gt; 도 반환 &lt;code&gt;{error, Term}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98ad7a8527ae38bbbd2d4e06002457415af632b3" translate="yes" xml:space="preserve">
          <source>Called when the key is needed for module &lt;code&gt;Module&lt;/code&gt; in the file named &lt;code&gt;Filename&lt;/code&gt;. &lt;code&gt;Mode&lt;/code&gt; is the type of crypto algorithm; currently, the only possible value is &lt;code&gt;des3_cbc&lt;/code&gt;. The call is to fail (raise an exception) if no key is available.</source>
          <target state="translated">&lt;code&gt;Filename&lt;/code&gt; 이라는 파일 에서 모듈 &lt;code&gt;Module&lt;/code&gt; 에 키가 필요할 때 호출됩니다 . &lt;code&gt;Mode&lt;/code&gt; 는 암호화 알고리즘의 유형입니다. 현재 가능한 유일한 값은 &lt;code&gt;des3_cbc&lt;/code&gt; 입니다. 사용 가능한 키가 없으면 호출이 실패합니다 (예외 발생).</target>
        </trans-unit>
        <trans-unit id="0dcbf03fb42831c6723cb1715f47765453867f67" translate="yes" xml:space="preserve">
          <source>Called when the port is about to be closed, and there is data in the driver queue that must be flushed before 'stop' can be called.</source>
          <target state="translated">포트를 닫으려고 할 때 호출되며 '중지'를 호출하기 전에 플러시해야하는 데이터가 드라이버 큐에 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c1f621a84111ea117dcad5ab2dda0907aba7d59" translate="yes" xml:space="preserve">
          <source>Called when the port is closed, with &lt;code&gt;&lt;a href=&quot;erlang#port_close-1&quot;&gt; erlang:port_close/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;Port ! {self(), close}&lt;/code&gt;. Notice that terminating the port owner process also closes the port. If &lt;code&gt;drv_data&lt;/code&gt; is a pointer to memory allocated in &lt;code&gt;start&lt;/code&gt;, then &lt;code&gt;stop&lt;/code&gt; is the place to deallocate that memory.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#port_close-1&quot;&gt; erlang:port_close/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;Port ! {self(), close}&lt;/code&gt; 와 함께 포트가 닫힐 때 호출됩니다 . {self (), close} . 포트 소유자 프로세스를 종료하면 포트도 닫힙니다. 경우 &lt;code&gt;drv_data&lt;/code&gt; 가 에 할당 된 메모리에 대한 포인터로 &lt;code&gt;start&lt;/code&gt; , 다음 &lt;code&gt;stop&lt;/code&gt; 이 메모리 할당을 해제 할 수있는 장소입니다.</target>
        </trans-unit>
        <trans-unit id="8919d79f584bde48131fa0a13624f5f0b5dd1e5e" translate="yes" xml:space="preserve">
          <source>Called when the port is closed, with &lt;code&gt;&lt;a href=&quot;erlang#port_close-1&quot;&gt;erlang:port_close/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;Port ! {self(), close}&lt;/code&gt;. Notice that terminating the port owner process also closes the port. If &lt;code&gt;drv_data&lt;/code&gt; is a pointer to memory allocated in &lt;code&gt;start&lt;/code&gt;, then &lt;code&gt;stop&lt;/code&gt; is the place to deallocate that memory.</source>
          <target state="translated">포트가 닫히면 &lt;code&gt;&lt;a href=&quot;erlang#port_close-1&quot;&gt;erlang:port_close/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;Port ! {self(), close}&lt;/code&gt; 입니다. 포트 소유자 프로세스를 종료하면 포트가 닫힙니다. 경우 &lt;code&gt;drv_data&lt;/code&gt; 가 에 할당 된 메모리에 대한 포인터로 &lt;code&gt;start&lt;/code&gt; , 다음 &lt;code&gt;stop&lt;/code&gt; 이 메모리 할당을 해제 할 수있는 장소입니다.</target>
        </trans-unit>
        <trans-unit id="bce5d5b2decf756f58e8642c565207befb9d1e4c" translate="yes" xml:space="preserve">
          <source>Called when there is something to read from a socket.</source>
          <target state="translated">소켓에서 읽을 것이있을 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="af3ef6e1f6da39c57e0246dc6e4aad3b06e17a5b" translate="yes" xml:space="preserve">
          <source>Called whenever the port is written to. If it is &lt;code&gt;NULL&lt;/code&gt;, the &lt;code&gt;output&lt;/code&gt; function is called instead. This function is faster than &lt;code&gt;output&lt;/code&gt;, as it takes an &lt;code&gt;ErlIOVec&lt;/code&gt; directly, which requires no copying of the data. The port is to be in binary mode, see &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">포트가 기록 될 때마다 호출됩니다. 이 경우 &lt;code&gt;NULL&lt;/code&gt; 의 &lt;code&gt;output&lt;/code&gt; 기능을 대신이라고합니다. 이 함수는 데이터를 복사 할 필요가없는 &lt;code&gt;ErlIOVec&lt;/code&gt; 을 직접 가져 오므 로 &lt;code&gt;output&lt;/code&gt; 보다 빠릅니다 . 포트는 바이너리 모드가됩니다. &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb06eda8927a232da24c20e732e3e2949f2b101f" translate="yes" xml:space="preserve">
          <source>Called whenever the port is written to. If it is &lt;code&gt;NULL&lt;/code&gt;, the &lt;code&gt;output&lt;/code&gt; function is called instead. This function is faster than &lt;code&gt;output&lt;/code&gt;, as it takes an &lt;code&gt;ErlIOVec&lt;/code&gt; directly, which requires no copying of the data. The port is to be in binary mode, see &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">포트가 쓰여질 때마다 호출됩니다. &lt;code&gt;NULL&lt;/code&gt; 인 경우 대신 &lt;code&gt;output&lt;/code&gt; 함수가 호출됩니다. 이 함수는 &lt;code&gt;ErlIOVec&lt;/code&gt; 을 직접 가져 오기 때문에 &lt;code&gt;output&lt;/code&gt; 보다 빠르 므로 데이터를 복사 할 필요가 없습니다. 포트는 이진 모드에 있습니다 ( &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="156f735aabd8995d92638174e190f108bd8cf6cb" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;&lt;a href=&quot;erlang#halt-1&quot;&gt; erlang:halt/1&lt;/a&gt;&lt;/code&gt; with a string argument still produces a crash dump. On Unix systems, sending an emulator process a &lt;code&gt;SIGUSR1&lt;/code&gt; signal also forces a crash dump.</source>
          <target state="translated">문자열 인수로 &lt;code&gt;&lt;a href=&quot;erlang#halt-1&quot;&gt; erlang:halt/1&lt;/a&gt;&lt;/code&gt; 을 호출 하면 여전히 크래시 덤프가 생성됩니다. Unix 시스템에서 에뮬레이터 프로세스를 보내면 &lt;code&gt;SIGUSR1&lt;/code&gt; 신호도 크래시 덤프를 강제합니다.</target>
        </trans-unit>
        <trans-unit id="8c4da0ebceae11eff6b7919b2ddd46f27587b04d" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;&lt;a href=&quot;erlang#halt-1&quot;&gt;erlang:halt/1&lt;/a&gt;&lt;/code&gt; with a string argument still produces a crash dump. On Unix systems, sending an emulator process a &lt;code&gt;SIGUSR1&lt;/code&gt; signal also forces a crash dump.</source>
          <target state="translated">문자열 인수로 &lt;code&gt;&lt;a href=&quot;erlang#halt-1&quot;&gt;erlang:halt/1&lt;/a&gt;&lt;/code&gt; 을 호출 하면 여전히 크래시 덤프가 생성됩니다. Unix 시스템에서 &lt;code&gt;SIGUSR1&lt;/code&gt; 신호를 에뮬레이터 프로세스로 보내면 크래시 덤프가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="655a22092d77d88145d5c50ca50e242cddc91b3d" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;demonitor(MonitorRef, [flush])&lt;/code&gt; is equivalent to the following, but more efficient:</source>
          <target state="translated">&lt;code&gt;demonitor(MonitorRef, [flush])&lt;/code&gt; 호출 은 다음과 같지만보다 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="754ff095185e90c1599a6e196b476c1470159daf" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;erlang:system_time()&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt; erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt; erlang:time_offset()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:system_time()&lt;/code&gt; 호출 은 &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt; erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt; erlang:time_offset()&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8abf86e315d47dada23e450fdd1a6d2f9ae320c2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;erlang:system_time()&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;erlang:time_offset()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:system_time()&lt;/code&gt; 호출 은 &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;erlang:time_offset()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d46cab9ce133f988a0314784232f1c7f5a5b51d" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;erlang:system_time(Unit)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt; erlang:convert_time_unit&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;, native, Unit)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:system_time(Unit)&lt;/code&gt; 호출 은 &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt; erlang:convert_time_unit&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;, native, Unit)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8b083a75a2460c0a8048c36cd9fefa43e466519e" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;erlang:system_time(Unit)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt;erlang:convert_time_unit&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;, native, Unit)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:system_time(Unit)&lt;/code&gt; 호출 은 &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt;erlang:convert_time_unit&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;, native, Unit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac8161866033e5fba00c9f967a358dd87e252b77" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;merl:print(Call)&lt;/code&gt; will then print the following code:</source>
          <target state="translated">호출 &lt;code&gt;merl:print(Call)&lt;/code&gt; 다음 코드를 인쇄합니다 :</target>
        </trans-unit>
        <trans-unit id="2cedca3701bb5e353b3d951a1078a1fe4f284c28" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;os:system_time(Unit)&lt;/code&gt; is equivalent to &lt;code&gt;erlang:convert_time_unit&lt;/code&gt;(&lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;os:system_time()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;, native, Unit)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os:system_time(Unit)&lt;/code&gt; 호출 은 &lt;code&gt;erlang:convert_time_unit&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;os:system_time()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;, native, Unit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afeabfe36eaf236b85f9317a022e3a32b2c67b0d" translate="yes" xml:space="preserve">
          <source>Calling and applying a fun does not involve any hash-table lookup. A fun contains an (indirect) pointer to the function that implements the fun.</source>
          <target state="translated">재미를 부르고 적용하는 것은 해시 테이블 조회를 포함하지 않습니다. 재미는 재미를 구현하는 함수에 대한 (간접) 포인터를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="90124b2b5c5e8b577f502d3a36088e606891a366" translate="yes" xml:space="preserve">
          <source>Calling or applying a fun (&lt;code&gt;Fun()&lt;/code&gt;, &lt;code&gt;apply(Fun, [])&lt;/code&gt;) is about &lt;strong&gt;three times&lt;/strong&gt; as expensive as calling a local function.</source>
          <target state="translated">&lt;code&gt;Fun()&lt;/code&gt; , &lt;code&gt;apply(Fun, [])&lt;/code&gt; 호출하거나 적용하는 것은 로컬 함수를 호출하는 것 &lt;strong&gt;보다&lt;/strong&gt; 약 &lt;strong&gt;3 배&lt;/strong&gt; 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="1bdcae36deade4d4d3da84b2d5104437391e84c5" translate="yes" xml:space="preserve">
          <source>Calling the function with &lt;code&gt;{MonitorPid, Options}&lt;/code&gt; as argument is the same as calling &lt;code&gt;&lt;a href=&quot;#system_monitor-2&quot;&gt; erlang:system_monitor(MonitorPid, Options)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{MonitorPid, Options}&lt;/code&gt; 를 인수로 사용하여 함수를 호출하는 것은 &lt;code&gt;&lt;a href=&quot;#system_monitor-2&quot;&gt; erlang:system_monitor(MonitorPid, Options)&lt;/a&gt;&lt;/code&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4977f905b190f9bbe202e2e85576e00836e9734e" translate="yes" xml:space="preserve">
          <source>Calling the function with &lt;code&gt;{MonitorPid, Options}&lt;/code&gt; as argument is the same as calling &lt;code&gt;&lt;a href=&quot;#system_monitor-2&quot;&gt;erlang:system_monitor(MonitorPid,Options)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{MonitorPid, Options}&lt;/code&gt; 를 인수로 사용하여 함수를 호출하는 것은 &lt;code&gt;&lt;a href=&quot;#system_monitor-2&quot;&gt;erlang:system_monitor(MonitorPid,Options)&lt;/a&gt;&lt;/code&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4b42cc7ad99418c1a03de8a69add23747a547065" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message containing all the integer()'s and string()'s provided, as well as any user tag set in the current process.</source>
          <target state="translated">이 함수를 호출하면 dyntrace NIF 모듈에서 &quot;user&quot;추적 프로브 user_trace_i4s4가 트리거되어 제공된 모든 integer () 및 string () 및 현재 프로세스에 설정된 모든 사용자 태그를 포함하는 추적 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="444f79602e491b38e25cb8c13003f56f8345ff63" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message containing the user tag and the integer or string parameter in the first integer/string field.</source>
          <target state="translated">이 함수를 호출하면 dyntrace NIF 모듈에서 &quot;user&quot;추적 프로브 user_trace_i4s4가 트리거되어 첫 번째 정수 / 문자열 필드에 사용자 태그와 정수 또는 문자열 매개 변수가 포함 된 추적 메시지가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="ca84bd13b57ed20dc137036dea97bc867dd9acff" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message containing the user tag and the integer() or string() parameters as the first fields of respective type. integer() parameters should be put before any string() parameters, as in &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수를 호출하면 dyntrace NIF 모듈에서 &quot;user&quot;추적 프로브 user_trace_i4s4가 트리거되고 각 유형의 첫 번째 필드로 user 태그 및 integer () 또는 string () 매개 변수를 포함하는 추적 메시지가 전송됩니다. &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; 와 같이 integer () 매개 변수는 string () 매개 변수 앞에 놓아야합니다 .</target>
        </trans-unit>
        <trans-unit id="3d6504b8ed29fe9b52bfa13411a0abbd154f8e3e" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message containing the user tag and the integer() or string() parameters as the first fields of respective type. integer() parameters should be put before any string() parameters. I.e. &lt;code&gt;p(1,&quot;Hello&quot;)&lt;/code&gt; is ok, as is &lt;code&gt;p(1,1)&lt;/code&gt; and &lt;code&gt;p(&quot;Hello&quot;,&quot;Again&quot;)&lt;/code&gt;, but not &lt;code&gt;p(&quot;Hello&quot;,1)&lt;/code&gt;.</source>
          <target state="translated">이 함수를 호출하면 dyntrace NIF 모듈에서 &quot;user&quot;추적 프로브 user_trace_i4s4가 트리거되고 각 유형의 첫 번째 필드로 user 태그 및 integer () 또는 string () 매개 변수를 포함하는 추적 메시지가 전송됩니다. integer () 매개 변수는 string () 매개 변수 앞에 놓아야합니다. 즉 &lt;code&gt;p(1,&quot;Hello&quot;)&lt;/code&gt; 는 &lt;code&gt;p(1,1)&lt;/code&gt; 및 &lt;code&gt;p(&quot;Hello&quot;,&quot;Again&quot;)&lt;/code&gt; 과 같이 괜찮지 만 &lt;code&gt;p(&quot;Hello&quot;,1)&lt;/code&gt; 는 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="ba80ef3622f6d7266790c78fbbdd6b4544d6f3ea" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message only containing the user tag and zeroes/empty strings in all other fields.</source>
          <target state="translated">이 함수를 호출하면 dyntrace NIF 모듈에서 &quot;user&quot;추적 프로브 user_trace_i4s4가 트리거되어 다른 모든 필드의 사용자 태그와 0 / 빈 문자열 만 포함하는 추적 메시지가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="fc31c095d153129fc853cf06c728a75bf3b46c60" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;#resolve-3&quot;&gt;resolve/*&lt;/a&gt;&lt;/code&gt; with the same arguments and filters the result, so &lt;code&gt;Opts&lt;/code&gt; is described for those functions.</source>
          <target state="translated">동일한 인수로 &lt;code&gt;&lt;a href=&quot;#resolve-3&quot;&gt;resolve/*&lt;/a&gt;&lt;/code&gt; 를 호출 하고 결과를 필터링하므로 해당 기능에 대해 &lt;code&gt;Opts&lt;/code&gt; 가 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="64e4f69ad9125f63ba8df8f7d7d250f3cecda4ae" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;F(K, V, AccIn)&lt;/code&gt; for every &lt;code&gt;K&lt;/code&gt; to value &lt;code&gt;V&lt;/code&gt; association in &lt;code&gt;MapOrIter&lt;/code&gt; in any order. Function &lt;code&gt;fun F/3&lt;/code&gt; must return a new accumulator, which is passed to the next successive call. This function returns the final value of the accumulator. The initial accumulator value &lt;code&gt;Init&lt;/code&gt; is returned if the map is empty.</source>
          <target state="translated">매 순서대로 &lt;code&gt;MapOrIter&lt;/code&gt; 에서 &lt;code&gt;V&lt;/code&gt; 연관을 평가 하기 위해 모든 &lt;code&gt;K&lt;/code&gt; 에 대해 &lt;code&gt;F(K, V, AccIn)&lt;/code&gt; 를 호출 합니다. 기능 &lt;code&gt;fun F/3&lt;/code&gt; 는 다음 누적 호출로 전달되는 새 누산기를 반환해야합니다. 이 함수는 누산기의 최종 값을 반환합니다. 맵이 비어 있으면 초기 누산기 값 &lt;code&gt;Init&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2c22c12363a38985d309e6b7686e339831be7ae7" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;F(Key, Value, AccIn)&lt;/code&gt; for every &lt;code&gt;Key&lt;/code&gt; to value &lt;code&gt;Value&lt;/code&gt; association in &lt;code&gt;MapOrIter&lt;/code&gt; in any order. Function &lt;code&gt;fun F/3&lt;/code&gt; must return a new accumulator, which is passed to the next successive call. This function returns the final value of the accumulator. The initial accumulator value &lt;code&gt;Init&lt;/code&gt; is returned if the map is empty.</source>
          <target state="translated">임의의 순서 로 &lt;code&gt;MapOrIter&lt;/code&gt; 의 모든 &lt;code&gt;Key&lt;/code&gt; to value &lt;code&gt;Value&lt;/code&gt; 연관에 대해 &lt;code&gt;F(Key, Value, AccIn)&lt;/code&gt; 을 호출 합니다. &lt;code&gt;fun F/3&lt;/code&gt; 함수 는 다음 연속 호출로 전달되는 새 누산기를 반환해야합니다. 이 함수는 누산기의 최종 값을 반환합니다. 맵이 비어 있으면 초기 누산기 값 &lt;code&gt;Init&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4295c8a20ece7cf06d43d6ebf25e275c406c6e5f" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(Elem)&lt;/code&gt; for each element &lt;code&gt;Elem&lt;/code&gt; in &lt;code&gt;List&lt;/code&gt;. This function is used for its side effects and the evaluation order is defined to be the same as the order of the elements in the list.</source>
          <target state="translated">&lt;code&gt;List&lt;/code&gt; 의 각 요소 &lt;code&gt;Elem&lt;/code&gt; 에 대해 &lt;code&gt;Fun(Elem)&lt;/code&gt; 을 호출 합니다. 이 기능은 부작용에 사용되며 평가 순서는 목록의 요소 순서와 동일하도록 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="63f2bd2bc7b570ff8e3f588bc3a35e7f39bb021c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(Elem)&lt;/code&gt; on successive elements &lt;code&gt;Elem&lt;/code&gt; of &lt;code&gt;List1&lt;/code&gt;. &lt;code&gt;Fun/1&lt;/code&gt; must return either a Boolean or a tuple &lt;code&gt;{true, Value}&lt;/code&gt;. The function returns the list of elements for which &lt;code&gt;Fun&lt;/code&gt; returns a new value, where a value of &lt;code&gt;true&lt;/code&gt; is synonymous with &lt;code&gt;{true, Elem}&lt;/code&gt;.</source>
          <target state="translated">호출 &lt;code&gt;Fun(Elem)&lt;/code&gt; 연속적인 요소에 &lt;code&gt;Elem&lt;/code&gt; 모델 의 &lt;code&gt;List1&lt;/code&gt; 입니다 . &lt;code&gt;Fun/1&lt;/code&gt; 은 부울 또는 튜플 &lt;code&gt;{true, Value}&lt;/code&gt; 반환해야합니다 . 이 함수는 &lt;code&gt;Fun&lt;/code&gt; 이 새 값을 리턴하는 요소 목록을 리턴합니다. 여기서 &lt;code&gt;true&lt;/code&gt; 값은 &lt;code&gt;{true, Elem}&lt;/code&gt; 과 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="50d89c32ea4d0c6ee1b26f9c66ad9e11c8879726" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(Elem, AccIn)&lt;/code&gt; on successive elements &lt;code&gt;A&lt;/code&gt; of &lt;code&gt;List&lt;/code&gt;, starting with &lt;code&gt;AccIn == Acc0&lt;/code&gt;. &lt;code&gt;Fun/2&lt;/code&gt; must return a new accumulator, which is passed to the next call. The function returns the final value of the accumulator. &lt;code&gt;Acc0&lt;/code&gt; is returned if the list is empty.</source>
          <target state="translated">통화 &lt;code&gt;Fun(Elem, AccIn)&lt;/code&gt; 가 연속 한 요소에 의 &lt;code&gt;List&lt;/code&gt; 을 시작으로 &lt;code&gt;AccIn == Acc0&lt;/code&gt; . &lt;code&gt;Fun/2&lt;/code&gt; 는 새 어큐뮬레이터를 반환해야하며, 다음 어큐뮬레이터로 전달됩니다. 이 함수는 누산기의 최종 값을 반환합니다. 목록이 비어 있으면 &lt;code&gt;Acc0&lt;/code&gt; 이 반환됩니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d14f785e84c0e45ac023a87056c299dcc94c604" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(Elem, AccIn)&lt;/code&gt; on successive elements of the cache, starting with &lt;code&gt;AccIn == Acc0&lt;/code&gt;. &lt;code&gt;Fun/2&lt;/code&gt; must return a new accumulator, which is passed to the next call. The function returns the final value of the accumulator. &lt;code&gt;Acc0&lt;/code&gt; is returned if the cache is empty.</source>
          <target state="translated">호출 &lt;code&gt;Fun(Elem, AccIn)&lt;/code&gt; 로 시작하는 캐시의 연속적인 요소에 &lt;code&gt;AccIn == Acc0&lt;/code&gt; . &lt;code&gt;Fun/2&lt;/code&gt; 는 새 어큐뮬레이터를 반환해야하며, 다음 어큐뮬레이터로 전달됩니다. 이 함수는 누산기의 최종 값을 반환합니다. 캐시가 비어 있으면 &lt;code&gt;Acc0&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d85b7bf8f7b8acf4c9a5d164bbe2b412bc74ce98" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(FileInArchive, GetInfo, GetBin, AccIn)&lt;/code&gt; on successive files in the &lt;code&gt;Archive&lt;/code&gt;, starting with &lt;code&gt;AccIn == Acc0&lt;/code&gt;.</source>
          <target state="translated">호출 &lt;code&gt;Fun(FileInArchive, GetInfo, GetBin, AccIn)&lt;/code&gt; 의 연속 파일에 &lt;code&gt;Archive&lt;/code&gt; 를 시작으로 &lt;code&gt;AccIn == Acc0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecb1b12376680c06a8dcd6a14c87f88b97c0f362" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun&lt;/code&gt; on successive keys and values of &lt;code&gt;Orddict1&lt;/code&gt; tvo return a new value for each key.</source>
          <target state="translated">연속 키에 대한 &lt;code&gt;Fun&lt;/code&gt; 호출 및 &lt;code&gt;Orddict1&lt;/code&gt; tvo의 값은 각 키에 대해 새로운 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="41cc957320ee93c3d6a8d2c0cf887c390c051f0c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun&lt;/code&gt; on successive keys and values of &lt;code&gt;Orddict&lt;/code&gt; together with an extra argument &lt;code&gt;Acc&lt;/code&gt; (short for accumulator). &lt;code&gt;Fun&lt;/code&gt; must return a new accumulator that is passed to the next call. &lt;code&gt;Acc0&lt;/code&gt; is returned if the list is empty.</source>
          <target state="translated">추가 인수 &lt;code&gt;Acc&lt;/code&gt; 와 함께 &lt;code&gt;Orddict&lt;/code&gt; 의 연속 키 및 값에 대해 &lt;code&gt;Fun&lt;/code&gt; 을 호출합니다 (누산기의 약어). &lt;code&gt;Fun&lt;/code&gt; 는 다음 호출로 전달되는 새 누산기를 반환해야합니다. 목록이 비어 있으면 &lt;code&gt;Acc0&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="db2c15c0e80df0b70d2a4c08c9328f07d292a334" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun&lt;/code&gt; on successive keys and values of dictionary &lt;code&gt;Dict1&lt;/code&gt; to return a new value for each key. The evaluation order is undefined.</source>
          <target state="translated">연속되는 키와 사전 &lt;code&gt;Dict1&lt;/code&gt; 의 값에 대해 &lt;code&gt;Fun&lt;/code&gt; 을 호출 하여 각 키에 대한 새 값을 반환합니다. 평가 순서는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51e98c878f8461c82b19b807000534c1ee895d35" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun&lt;/code&gt; on successive keys and values of dictionary &lt;code&gt;Dict&lt;/code&gt; together with an extra argument &lt;code&gt;Acc&lt;/code&gt; (short for accumulator). &lt;code&gt;Fun&lt;/code&gt; must return a new accumulator that is passed to the next call. &lt;code&gt;Acc0&lt;/code&gt; is returned if the dictionary is empty. The evaluation order is undefined.</source>
          <target state="translated">추가 인수 &lt;code&gt;Acc&lt;/code&gt; 와 함께 사전 &lt;code&gt;Dict&lt;/code&gt; 의 연속 키와 값에 대해 &lt;code&gt;Fun&lt;/code&gt; 을 호출합니다 (누산기의 약어). &lt;code&gt;Fun&lt;/code&gt; 는 다음 호출로 전달되는 새 누산기를 반환해야합니다. 사전이 비어 있으면 &lt;code&gt;Acc0&lt;/code&gt; 이 반환됩니다. 평가 순서는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e38b9bc9aa02fa070ce4650030edfd32a81b7dd" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Function&lt;/code&gt; on successive answers to the query handle together with an extra argument &lt;code&gt;AccIn&lt;/code&gt;. The query handle and the function are evaluated in the calling process. &lt;code&gt;Function&lt;/code&gt; must return a new accumulator, which is passed to the next call. &lt;code&gt;Acc0&lt;/code&gt; is returned if there are no answers to the query handle.</source>
          <target state="translated">추가 인수 &lt;code&gt;AccIn&lt;/code&gt; 과 함께 쿼리 핸들에 대한 연속적인 응답에 대해 &lt;code&gt;Function&lt;/code&gt; 를 호출 합니다. 쿼리 핸들과 함수는 호출 프로세스에서 평가됩니다. &lt;code&gt;Function&lt;/code&gt; 는 다음 누산으로 전달되는 새 누산기를 반환해야합니다. 쿼리 핸들에 대한 답변이 없으면 &lt;code&gt;Acc0&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="411261c708a55893631cad145cf652a3f25bc6dd" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Function&lt;/code&gt; on successive elements of table &lt;code&gt;Name&lt;/code&gt; together with an extra argument &lt;code&gt;AccIn&lt;/code&gt;. The table elements are traversed in unspecified order. &lt;code&gt;Function&lt;/code&gt; must return a new accumulator that is passed to the next call. &lt;code&gt;Acc0&lt;/code&gt; is returned if the table is empty.</source>
          <target state="translated">추가 인수 &lt;code&gt;AccIn&lt;/code&gt; 과 함께 테이블 &lt;code&gt;Name&lt;/code&gt; 의 연속 요소에 대한 &lt;code&gt;Function&lt;/code&gt; 를 호출 합니다. 테이블 요소는 지정되지 않은 순서로 순회됩니다. &lt;code&gt;Function&lt;/code&gt; 는 다음 호출로 전달되는 새 누산기를 반환해야합니다. 테이블이 비어 있으면 &lt;code&gt;Acc0&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e4d0f89deb9513a8ea8d66e61b19ec50cb6a197f" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;erlang:apply(Func, Args)&lt;/code&gt; surrounded by &lt;code&gt;trace([start, ...])&lt;/code&gt; and &lt;code&gt;trace(stop)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;trace([start, ...])&lt;/code&gt; 및 &lt;code&gt;trace(stop)&lt;/code&gt; 둘러싸인 &lt;code&gt;erlang:apply(Func, Args)&lt;/code&gt; 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="c8e905cfa5d08f37d1d656135714c1381b168281" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:activity(AccessContext, Fun, Args, AccessMod)&lt;/code&gt;, where &lt;code&gt;AccessMod&lt;/code&gt; is the default access callback module obtained by &lt;code&gt;mnesia:system_info(access_module)&lt;/code&gt;. &lt;code&gt;Args&lt;/code&gt; defaults to &lt;code&gt;[]&lt;/code&gt; (empty list).</source>
          <target state="translated">통화 &lt;code&gt;mnesia:activity(AccessContext, Fun, Args, AccessMod)&lt;/code&gt; , &lt;code&gt;AccessMod&lt;/code&gt; 이 얻을 기본 액세스 콜백 모듈입니다 &lt;code&gt;mnesia:system_info(access_module)&lt;/code&gt; . &lt;code&gt;Args&lt;/code&gt; 의 기본값은 &lt;code&gt;[]&lt;/code&gt; (빈 목록)입니다.</target>
        </trans-unit>
        <trans-unit id="7ba5ad987837e04f29a6e17ab4165c3bf8a13ef5" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:async_dirty(Fun, Args)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:async_dirty(Fun, Args)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="ffcbed2136c4dbb9cb540ca3e3bb945d48a84489" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:delete(Tab, Key, write)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:delete(Tab, Key, write)&lt;/code&gt; 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="6cd2ad960a91e2c7b84aad8b8cab2b4af89af1d4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:delete_object(Tab, Record, write)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:delete_object(Tab, Record, write)&lt;/code&gt; 호출 합니다. 여기서 &lt;code&gt;Tab&lt;/code&gt; 은 &lt;code&gt;element(1, Record)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b1619836284281d3b4ace7f8138860d37a317d20" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_delete(Tab, Key)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:dirty_delete(Tab, Key)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f7eff8e0d0f21895a3712d8b82ab68aad9ff93c2" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_delete_object(Tab, Record)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:dirty_delete_object(Tab, Record)&lt;/code&gt; 호출 합니다. 여기서 &lt;code&gt;Tab&lt;/code&gt; 은 &lt;code&gt;element(1, Record)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b968f64643fdd3ef4196ca7f2353074d34a25592" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_match_object(Tab, Pattern)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Pattern)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:dirty_match_object(Tab, Pattern)&lt;/code&gt; 호출 합니다. 여기서 &lt;code&gt;Tab&lt;/code&gt; 은 &lt;code&gt;element(1, Pattern)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dc9bba8191f80d74baf71dc1c6ce5482c73891a5" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_read(Tab, Key)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:dirty_read(Tab, Key)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="672698b739738396e1aaa279f1425416fa4ed4d3" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_update_counter(Tab, Key, Incr)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:dirty_update_counter(Tab, Key, Incr)&lt;/code&gt; 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="f15de5c4989490ba445d84120b63ae4fef3a10da" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_write(Tab, Record)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:dirty_write(Tab, Record)&lt;/code&gt; 호출 합니다. 여기서 &lt;code&gt;Tab&lt;/code&gt; 은 &lt;code&gt;element(1, Record)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a49f85d237c7a52c5025bd7a45bcefecee838aed" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:ets(Fun, Args)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:ets(Fun, Args)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="d1e1b27f2b3d32c30f1a9af2546f7ff28be30d84" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:install_fallback(Opaque, Args)&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; is &lt;code&gt;[{scope, global}, {module, BackupMod}]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:install_fallback(Opaque, Args)&lt;/code&gt; 호출 합니다. 여기서 &lt;code&gt;Args&lt;/code&gt; 는 &lt;code&gt;[{scope, global}, {module, BackupMod}]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="adefbd4d29b6f99f9c5284fcea99a93af40e2354" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:install_fallback(Opaque, Args)&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; is &lt;code&gt;[{scope, global}]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:install_fallback(Opaque, Args)&lt;/code&gt; 호출 합니다. 여기서 &lt;code&gt;Args&lt;/code&gt; 는 &lt;code&gt;[{scope, global}]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6371048f46424da76665133d09722d29e17eb95d" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:match_object(Tab, Pattern, read)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Pattern)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:match_object(Tab, Pattern, read)&lt;/code&gt; 호출 합니다. 여기서 &lt;code&gt;Tab&lt;/code&gt; 은 &lt;code&gt;element(1, Pattern)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="506bd136b0f38c6b5c4e9aba7994479cbf8607c2" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:sync_dirty(Fun, Args)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:sync_dirty(Fun, Args)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="4768e4194eaa19668e98e8297432714da38f80fe" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:sync_transaction(Fun, Args, Retries)&lt;/code&gt;. Notice that the result from &lt;code&gt;Fun&lt;/code&gt; is returned if the transaction is successful (atomic), otherwise the function exits with an abort reason.</source>
          <target state="translated">&lt;code&gt;mnesia:sync_transaction(Fun, Args, Retries)&lt;/code&gt; 호출 합니다. 트랜잭션이 성공하면 (원자) &lt;code&gt;Fun&lt;/code&gt; 의 결과 가 리턴되고 그렇지 않으면 중단 이유로 함수가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f4238a5e661c7a2d85c9a77b9854e4b9f7ca29a9" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:transaction(Fun, Args, Retries)&lt;/code&gt;. Notice that the result from &lt;code&gt;Fun&lt;/code&gt; is returned if the transaction is successful (atomic), otherwise the function exits with an abort reason.</source>
          <target state="translated">&lt;code&gt;mnesia:transaction(Fun, Args, Retries)&lt;/code&gt; 호출 합니다. 트랜잭션이 성공하면 (원자) &lt;code&gt;Fun&lt;/code&gt; 의 결과 가 리턴되고 그렇지 않으면 중단 이유로 함수가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4bef8126b535186f1c6f440c4f89eb4f6b6acd97" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:transform_table(Tab, Fun, NewAttributeList, RecName)&lt;/code&gt;, where &lt;code&gt;RecName&lt;/code&gt; is &lt;code&gt;mnesia:table_info(Tab, record_name)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:transform_table(Tab, Fun, NewAttributeList, RecName)&lt;/code&gt; 호출 합니다. 여기서 &lt;code&gt;RecName&lt;/code&gt; 은 &lt;code&gt;mnesia:table_info(Tab, record_name)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8f8dac520c4ed465440262ceedf36f6b5ee392b4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;names(Host)&lt;/code&gt; for all hosts that are specified in the Erlang host file &lt;code&gt;.hosts.erlang&lt;/code&gt;, collects the replies, and then evaluates &lt;code&gt;ping(Node)&lt;/code&gt; on all those nodes. Returns the list of all nodes that are successfully pinged.</source>
          <target state="translated">Erlang 호스트 파일 &lt;code&gt;.hosts.erlang&lt;/code&gt; 에 지정된 모든 호스트에 대해 &lt;code&gt;names(Host)&lt;/code&gt; 를 호출 하고 응답을 수집 한 다음 모든 해당 노드에서 &lt;code&gt;ping(Node)&lt;/code&gt; 을 평가 합니다. 성공적으로 핑된 모든 노드의 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6f89caf1a58d70de4bc1545d4d2c63f722e1134d" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;pseudo(Master, ServerList)&lt;/code&gt;. If you want to start a node from the command line and set up a number of pseudo servers, an Erlang runtime system can be started as follows:</source>
          <target state="translated">&lt;code&gt;pseudo(Master, ServerList)&lt;/code&gt; 호출합니다 . 명령 행에서 노드를 시작하고 여러 의사 서버를 설정하려는 경우 다음과 같이 Erlang 런타임 시스템을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fd282143317f0c95d38258aa5488afaefacb19b" translate="yes" xml:space="preserve">
          <source>Calls a fun, passing the elements in &lt;code&gt;Args&lt;/code&gt; as arguments.</source>
          <target state="translated">&lt;code&gt;Args&lt;/code&gt; 의 요소를 인수 로 전달하여 재미를 부릅니다 .</target>
        </trans-unit>
        <trans-unit id="bc1df90caee2a0f744537886d1a4a5d884e3a1f0" translate="yes" xml:space="preserve">
          <source>Calls between functions are either  &lt;strong id=&quot;local_call&quot;&gt;local calls&lt;/strong&gt; like &lt;code&gt;f()&lt;/code&gt;, or  &lt;strong id=&quot;external_call&quot;&gt;external calls&lt;/strong&gt; like &lt;code&gt;m:f()&lt;/code&gt;.  &lt;strong id=&quot;module_data&quot;&gt;Module data&lt;/strong&gt;, which are extracted from BEAM files, include local functions, exported functions, local calls and external calls. By default, calls to built-in functions (BIF) are ignored, but if the option &lt;code&gt;builtins&lt;/code&gt;, accepted by some of this module's functions, is set to &lt;code&gt;true&lt;/code&gt;, calls to BIFs are included as well. It is the analyzing OTP version that decides what functions are BIFs. Functional objects are assumed to be called where they are created (and nowhere else).  &lt;strong id=&quot;unresolved_call&quot;&gt;Unresolved calls&lt;/strong&gt; are calls to &lt;code&gt;apply&lt;/code&gt; or &lt;code&gt;spawn&lt;/code&gt; with variable module, variable function, or variable arguments. Examples are &lt;code&gt;M:F(a)&lt;/code&gt;, &lt;code&gt;apply(M,&amp;nbsp;f,&amp;nbsp;[a])&lt;/code&gt;, and &lt;code&gt;spawn(m,&amp;nbsp;f(),&amp;nbsp;Args)&lt;/code&gt;. Unresolved calls are represented by calls where variable modules have been replaced with the atom &lt;code&gt;'$M_EXPR'&lt;/code&gt;, variable functions have been replaced with the atom &lt;code&gt;'$F_EXPR'&lt;/code&gt;, and variable number of arguments have been replaced with the number &lt;code&gt;-1&lt;/code&gt;. The above mentioned examples are represented by calls to &lt;code&gt;'$M_EXPR':'$F_EXPR'/1&lt;/code&gt;, &lt;code&gt;'$M_EXPR':f/1&lt;/code&gt;, and &lt;code&gt;m:'$F_EXPR'/-1&lt;/code&gt;. The unresolved calls are a subset of the external calls.</source>
          <target state="translated">함수 간의 &lt;strong id=&quot;local_call&quot;&gt;호출&lt;/strong&gt; 은 &lt;code&gt;f()&lt;/code&gt; 와 같은 &lt;strong id=&quot;local_call&quot;&gt;로컬 호출&lt;/strong&gt; 이거나 &lt;code&gt;m:f()&lt;/code&gt; 와 같은 &lt;strong id=&quot;external_call&quot;&gt;외부 호출&lt;/strong&gt; 입니다. BEAM 파일에서 추출 된 &lt;strong id=&quot;module_data&quot;&gt;모듈 데이터&lt;/strong&gt; 에는 로컬 기능, 내 보낸 기능, 로컬 호출 및 외부 호출이 포함됩니다. 기본적으로 내장 함수 (BIF)에 대한 호출은 무시되지만 이 모듈의 일부 기능에 의해 승인 된 &lt;code&gt;builtins&lt;/code&gt; 옵션 이 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 BIF에 대한 호출도 포함됩니다. 어떤 기능이 BIF인지를 결정하는 것은 분석 OTP 버전입니다. 기능적 객체는 생성 된 곳 (및 다른 곳)에 있다고 가정합니다. &lt;strong id=&quot;unresolved_call&quot;&gt;해결되지 않은 호출&lt;/strong&gt; 하는 전화입니다 &lt;code&gt;apply&lt;/code&gt; 또는&lt;strong id=&quot;module_data&quot;&gt;&lt;/strong&gt;&lt;strong id=&quot;unresolved_call&quot;&gt;&lt;/strong&gt; &lt;code&gt;spawn&lt;/code&gt; 변수 모듈, 변수 함수 또는 변수 인수로 스폰 됩니다. 예는 &lt;code&gt;M:F(a)&lt;/code&gt; , &lt;code&gt;apply(M,&amp;nbsp;f,&amp;nbsp;[a])&lt;/code&gt; 및 &lt;code&gt;spawn(m,&amp;nbsp;f(),&amp;nbsp;Args)&lt;/code&gt; 입니다. &lt;code&gt;'$M_EXPR'&lt;/code&gt; 되지 않은 호출은 변수 모듈이 원자 '$ M_EXPR' 로 대체되고 변수 함수가 원자 &lt;code&gt;'$F_EXPR'&lt;/code&gt; 로 대체되었으며 변수의 인수 수가 숫자 &lt;code&gt;-1&lt;/code&gt; 로 대체 된 호출로 표시됩니다 . 위에서 언급 한 예는 &lt;code&gt;'$M_EXPR':'$F_EXPR'/1&lt;/code&gt; , &lt;code&gt;'$M_EXPR':f/1&lt;/code&gt; 및 &lt;code&gt;m:'$F_EXPR'/-1&lt;/code&gt; 됩니다. 해결되지 않은 통화는 외부 통화의 하위 집합입니다.</target>
        </trans-unit>
        <trans-unit id="e175a0645ad31688c1ad90ebe51d1f98332790c8" translate="yes" xml:space="preserve">
          <source>Calls between modules, applications and releases are also directed graphs. The  &lt;strong id=&quot;type&quot;&gt;types&lt;/strong&gt; of the vertices and edges of these graphs are (ranging from the most special to the most general): &lt;code&gt;Fun&lt;/code&gt; for functions; &lt;code&gt;Mod&lt;/code&gt; for modules; &lt;code&gt;App&lt;/code&gt; for applications; and &lt;code&gt;Rel&lt;/code&gt; for releases. The following paragraphs will describe the different constructs of the language used for selecting and analyzing parts of the graphs, beginning with the  &lt;strong id=&quot;constants&quot;&gt;constants&lt;/strong&gt;:</source>
          <target state="translated">모듈, 응용 프로그램 및 릴리스 간 호출도 직접 그래프입니다. &lt;strong id=&quot;type&quot;&gt;종류의&lt;/strong&gt; 정점와이 그래프의 가장자리는 (가장 특별한 가장 일반에 이르기까지)되어 &lt;code&gt;Fun&lt;/code&gt; 기능; 모듈 &lt;code&gt;Mod&lt;/code&gt; ; &lt;code&gt;App&lt;/code&gt; 위한 앱 ; 및 &lt;code&gt;Rel&lt;/code&gt; 릴리스. 다음 단락에서는 &lt;strong id=&quot;constants&quot;&gt;상수로&lt;/strong&gt; 시작하여 그래프의 일부를 선택하고 분석하는 데 사용되는 언어의 다양한 구성에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="be43177e95bbd471940bc32f6f4691d58dabae5d" translate="yes" xml:space="preserve">
          <source>Calls function &lt;code&gt;mnesia:read(Tab, Key, read)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:read(Tab, Key, read)&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e1ab266a520f0fa15f418f121757a95a2f87b8a3" translate="yes" xml:space="preserve">
          <source>Calls quickcheck and returns the result in a form suitable for &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">빠른 검사를 호출하고 &lt;code&gt;Common Test&lt;/code&gt; 적합한 형식으로 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8c7c891f9853016ddc130d88be49b034108f4922" translate="yes" xml:space="preserve">
          <source>Calls the &lt;code&gt;Fun&lt;/code&gt; in a context that is not protected by a transaction. The Mnesia function calls performed in the &lt;code&gt;Fun&lt;/code&gt; are mapped to the corresponding dirty functions. It is performed in almost the same context as &lt;code&gt;mnesia:async_dirty/1,2&lt;/code&gt;. The difference is that the operations are performed synchronously. The caller waits for the updates to be performed on all active replicas before the &lt;code&gt;Fun&lt;/code&gt; returns. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt; and the User's Guide.</source>
          <target state="translated">트랜잭션으로 보호되지 않는 컨텍스트 에서 &lt;code&gt;Fun&lt;/code&gt; 을 호출합니다 . &lt;code&gt;Fun&lt;/code&gt; 에서 수행 된 Mnesia 함수 호출 은 해당 더티 함수에 매핑됩니다. &lt;code&gt;mnesia:async_dirty/1,2&lt;/code&gt; 와 거의 동일한 컨텍스트에서 수행됩니다 . 차이점은 작업이 동 기적으로 수행된다는 것입니다. 발신자는 &lt;code&gt;Fun&lt;/code&gt; 이 복귀 하기 전에 모든 활성 복제본에서 업데이트가 수행되기를 기다립니다 . 자세한 내용은 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 및 사용 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7f3ec8be69b09a2c810b010167a3f606775918ce" translate="yes" xml:space="preserve">
          <source>Calls the &lt;code&gt;Fun&lt;/code&gt; in a context that is not protected by a transaction. The Mnesia function calls performed in the &lt;code&gt;Fun&lt;/code&gt; are mapped to the corresponding dirty functions. This still involves logging, replication, and subscriptions, but there is no locking, local transaction storage, or commit protocols involved. Checkpoint retainers and indexes are updated, but they are updated dirty. As for normal &lt;code&gt;mnesia:dirty_*&lt;/code&gt; operations, the operations are performed semi-asynchronously. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt; and the User's Guide.</source>
          <target state="translated">트랜잭션으로 보호되지 않는 컨텍스트 에서 &lt;code&gt;Fun&lt;/code&gt; 을 호출합니다 . &lt;code&gt;Fun&lt;/code&gt; 에서 수행 된 Mnesia 함수 호출 은 해당 더티 함수에 매핑됩니다. 여기에는 여전히 로깅, 복제 및 구독이 포함되지만 잠금, 로컬 트랜잭션 스토리지 또는 커밋 프로토콜은 없습니다. 체크 포인트 보유자와 색인은 업데이트되지만 더티 업데이트됩니다. 일반적인 &lt;code&gt;mnesia:dirty_*&lt;/code&gt; 작업의 경우 작업이 반 비동기식으로 수행됩니다. 자세한 내용은 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 및 사용 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d819d67bdd8cdeb2caeeb18f61988b23312e64a2" translate="yes" xml:space="preserve">
          <source>Calls the &lt;code&gt;Fun&lt;/code&gt; in a raw context that is not protected by a transaction. The Mnesia function call is performed in the &lt;code&gt;Fun&lt;/code&gt; and performed directly on the local ETS tables on the assumption that the local storage type is &lt;code&gt;ram_copies&lt;/code&gt; and the tables are not replicated to other nodes. Subscriptions are not triggered and checkpoints are not updated, but it is extremely fast. This function can also be applied to &lt;code&gt;disc_copies&lt;/code&gt; tables if all operations are read only. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt; and the User's Guide.</source>
          <target state="translated">트랜잭션으로 보호되지 않은 원시 컨텍스트에서 &lt;code&gt;Fun&lt;/code&gt; 을 호출합니다 . Mnesia 함수 호출은 &lt;code&gt;Fun&lt;/code&gt; 에서 수행되고 로컬 스토리지 유형이 &lt;code&gt;ram_copies&lt;/code&gt; 이고 테이블이 다른 노드에 복제되지 않는다는 가정하에 로컬 ETS 테이블에서 직접 수행 됩니다. 구독이 트리거되지 않고 체크 포인트가 업데이트되지 않지만 매우 빠릅니다. 모든 작업이 읽기 전용 인 경우이 함수는 &lt;code&gt;disc_copies&lt;/code&gt; 테이블 에도 적용 할 수 있습니다 . 자세한 내용은 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 및 사용 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a8a784dd04ba58d02965f17a28a416dac496f4c6" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:delete(Tab, Key, sticky_write)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mnesia:delete(Tab, Key, sticky_write)&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="ecca9949a5635aaf8c27410eea7636e30e459fb0" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:delete_object(Tab, Record, sticky_write)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:delete_object(Tab, Record, sticky_write)&lt;/code&gt; 함수를 호출합니다 . 여기서 &lt;code&gt;Tab&lt;/code&gt; 은 &lt;code&gt;element(1, Record)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="949e11ed9c4c541b273d5f803d7f14e93decf845" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:lock({table, Tab}, read)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:lock({table, Tab}, read)&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="7a8c4bc10158fea84b8bc4d0f51afdb0e35c5827" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:lock({table, Tab}, write)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:lock({table, Tab}, write)&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="cddc0b283837cd9cf6bfc5ffbfc0d1ab69ceebc5" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:read(Tab, Key, write)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:read(Tab, Key, write)&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="55f266ac7f0a7fd8339f6a382397f015c2d00cb9" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:uninstall_fallback([{scope, global}])&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:uninstall_fallback([{scope, global}])&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a04316f127b21a90e451cb0328b531e879c5c8a6" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:write(Tab, Record, sticky_write)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:write(Tab, Record, sticky_write)&lt;/code&gt; 함수를 호출합니다 . 여기서 &lt;code&gt;Tab&lt;/code&gt; 은 &lt;code&gt;element(1, Record)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6619bcc0446814c6bc36959f774872812e839577" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:write(Tab, Record, write)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:write(Tab, Record, write)&lt;/code&gt; 함수를 호출합니다 . 여기서 &lt;code&gt;Tab&lt;/code&gt; 은 &lt;code&gt;element(1, Record)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="802a6c538e37a7050a99435e4b91321de49b481f" translate="yes" xml:space="preserve">
          <source>Calls the selected tool's function for running the &lt;code&gt;Property&lt;/code&gt;. It is usually and by historical reasons called quickcheck, and that is why that name is used in this module (&lt;code&gt;ct_property_test&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Property&lt;/code&gt; 를 실행하기 위해 선택한 도구의 함수를 호출합니다 . 일반적으로 빠른 검사라고하는 역사적인 이유 때문에이 모듈 ( &lt;code&gt;ct_property_test&lt;/code&gt; ) 에서 해당 이름이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b9dce33ce75c3e0cd20ec5b024a2864ee93e989" translate="yes" xml:space="preserve">
          <source>Calls the standard &lt;code&gt;free()&lt;/code&gt; function.</source>
          <target state="translated">표준 &lt;code&gt;free()&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="b90d8d44b261c3e05c2a69f75c7d0d01e3b518f9" translate="yes" xml:space="preserve">
          <source>Calls the standard &lt;code&gt;malloc()&lt;/code&gt; function.</source>
          <target state="translated">표준 &lt;code&gt;malloc()&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="61d6494376d82c6585e92497eb43814699b60b7e" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;&lt;a href=&quot;error_logger#error_report-1&quot;&gt; error_logger:error_report/1,2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;error_logger#error_msg-1&quot;&gt; error_logger:error_msg/1,2&lt;/a&gt;&lt;/code&gt;, and corresponding functions for warning and info messages, are all forwarded to Logger as calls to &lt;code&gt;&lt;a href=&quot;logger#log-3&quot;&gt; logger:log(Level,Report,Metadata)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">를 호출 &lt;code&gt;&lt;a href=&quot;error_logger#error_report-1&quot;&gt; error_logger:error_report/1,2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;error_logger#error_msg-1&quot;&gt; error_logger:error_msg/1,2&lt;/a&gt;&lt;/code&gt; , 경고 및 정보 메시지에 대한 기능을 해당하는 모든 호출로 로거로 전달됩니다 &lt;code&gt;&lt;a href=&quot;logger#log-3&quot;&gt; logger:log(Level,Report,Metadata)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f325b7e41b1fdb81e7bc7cb001482dfdf57640d" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;&lt;a href=&quot;error_logger#error_report-1&quot;&gt;error_logger:error_report/1,2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;error_logger#error_msg-1&quot;&gt;error_logger:error_msg/1,2&lt;/a&gt;&lt;/code&gt;, and corresponding functions for warning and info messages, are all forwarded to Logger as calls to &lt;code&gt;&lt;a href=&quot;logger#log-3&quot;&gt;logger:log(Level,Report,Metadata)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">를 호출 &lt;code&gt;&lt;a href=&quot;error_logger#error_report-1&quot;&gt;error_logger:error_report/1,2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;error_logger#error_msg-1&quot;&gt;error_logger:error_msg/1,2&lt;/a&gt;&lt;/code&gt; , 경고 및 정보 메시지에 대한 기능을 해당하는 모든 호출로 로거로 전달됩니다 &lt;code&gt;&lt;a href=&quot;logger#log-3&quot;&gt;logger:log(Level,Report,Metadata)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="681ce3661a9a40c6caccc2250ea6929229c7aac3" translate="yes" xml:space="preserve">
          <source>Calls to functions defined by evaluating fun expressions &lt;code&gt;&quot;fun ... end&quot;&lt;/code&gt; are also hidden from non-local function handlers.</source>
          <target state="translated">fun 표현식 &lt;code&gt;&quot;fun ... end&quot;&lt;/code&gt; 를 평가하여 정의 된 함수에 대한 호출 도 로컬이 아닌 함수 핸들러에서 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="a78c70fc8985fb6668305436210f739782826d6b" translate="yes" xml:space="preserve">
          <source>Calls to local or external functions (&lt;code&gt;foo()&lt;/code&gt;, &lt;code&gt;m:foo()&lt;/code&gt;) are the fastest calls.</source>
          <target state="translated">로컬 또는 외부 함수 ( &lt;code&gt;foo()&lt;/code&gt; , &lt;code&gt;m:foo()&lt;/code&gt; )에 대한 호출이 가장 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="c1368b924e595a7f64353a1c8704cd02aa9b58af" translate="yes" xml:space="preserve">
          <source>Calls to the BIFs specified in table &lt;code&gt;Type Test BIFs&lt;/code&gt;</source>
          <target state="translated">테이블 &lt;code&gt;Type Test BIFs&lt;/code&gt; 지정된 BIF 호출</target>
        </trans-unit>
        <trans-unit id="c476a11e38143a5ca54c749f0467a4a34a7b9e99" translate="yes" xml:space="preserve">
          <source>Calls to the BIFs specified in tables &lt;strong&gt;Type Test BIFs&lt;/strong&gt; and &lt;strong&gt;Other BIFs Allowed in Guard Expressions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;가드 표현식에서 허용되는 &lt;/strong&gt;&lt;strong&gt;테스트 BIF&lt;/strong&gt; 및 &lt;strong&gt;기타 BIF &lt;/strong&gt;&lt;strong&gt;유형&lt;/strong&gt; 테이블에 지정된 BIF에 대한 호출&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c5e2dbf1a74a301e38682ebfa666c1939e25bd23" translate="yes" xml:space="preserve">
          <source>Can another internal data representation be used to make things more efficient?</source>
          <target state="translated">보다 효율적인 내부 작업을 위해 다른 내부 데이터 표현을 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="ce2b0460aad57730836f17162000a27e6d1988d5" translate="yes" xml:space="preserve">
          <source>Can any redundant tests be removed?</source>
          <target state="translated">중복 테스트를 제거 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="14d70599293b8e413ef952c38a0440843056f84c" translate="yes" xml:space="preserve">
          <source>Can any test be run less often if the order of tests is changed?</source>
          <target state="translated">테스트 순서가 변경되면 테스트를 덜 자주 실행할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="1dbbd23b5878e1a733c169db6ec8393bc170cde2" translate="yes" xml:space="preserve">
          <source>Can be a back reference, or another way of writing a tab</source>
          <target state="translated">역 참조 또는 다른 탭 작성 방법 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ff3af864aead7cd729fa897ed19cd40dd3bea5a" translate="yes" xml:space="preserve">
          <source>Can be a back reference, otherwise the character with octal code 113</source>
          <target state="translated">역 참조 일 수 있으며, 그렇지 않으면 8 진 코드 113의 문자</target>
        </trans-unit>
        <trans-unit id="ca748588186d1a7e973cd887d71235755974030e" translate="yes" xml:space="preserve">
          <source>Can be a back reference, otherwise value 255 (decimal)</source>
          <target state="translated">역 참조 일 수 있음, 그렇지 않은 경우 값 255 (10 진수)</target>
        </trans-unit>
        <trans-unit id="7d7475380f4be07d179c7231bb2dd90fbd5279b2" translate="yes" xml:space="preserve">
          <source>Can be called by a process to unregister a specified node from EPMD on the local host. This is, however, usually not allowed, unless EPMD was started with flag &lt;code&gt;-relaxed_command_check&lt;/code&gt;, which it normally is not.</source>
          <target state="translated">프로세스가 로컬 호스트의 EPMD에서 지정된 노드를 등록 해제하기 위해 호출 할 수 있습니다. 그러나 EPMD가 플래그 &lt;code&gt;-relaxed_command_check&lt;/code&gt; 로 시작되지 않는 한 일반적으로 허용 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f44b4080b46d42a3270b0b18ff48ce34cd9d5ec2" translate="yes" xml:space="preserve">
          <source>Can be implemented as:</source>
          <target state="translated">다음과 같이 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="435b9419e03f7e525befa539fe46b7b2779ce303" translate="yes" xml:space="preserve">
          <source>Can be one of the following:</source>
          <target state="translated">다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18e0b766363b36ea716659f6503b3ddde9e7ec85" translate="yes" xml:space="preserve">
          <source>Can be removed in a future release of the halfword emulator.</source>
          <target state="translated">하프 워드 에뮬레이터의 다음 릴리스에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a329dd98b578890314d90cd00ae46894da7e6ba8" translate="yes" xml:space="preserve">
          <source>Can be set to &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;relaxed&lt;/code&gt;. It controls how each directory in the code path is to be interpreted:</source>
          <target state="translated">&lt;code&gt;strict&lt;/code&gt; 하거나 &lt;code&gt;relaxed&lt;/code&gt; 설정할 수 있습니다 . 코드 경로의 각 디렉토리를 해석하는 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="61d2fdff92dff8eebb470df37755eb8b633955c3" translate="yes" xml:space="preserve">
          <source>Can be set to a comma-separated list of IP addresses, in which case the &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt; daemon listens only on the specified address(es) and on the loopback address (which is implicitly added to the list if it has not been specified).</source>
          <target state="translated">쉼표로 구분 된 IP 주소 목록으로 설정할 수 있습니다.이 경우 &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt; 데몬은 지정된 주소와 루프백 주소 (지정되지 않은 경우 목록에 암시 적으로 추가됨)에서만 수신합니다.</target>
        </trans-unit>
        <trans-unit id="1d6e47517b6960079a15e323f8e14b95671cfd59" translate="yes" xml:space="preserve">
          <source>Can be set to a comma-separated list of IP addresses, in which case the &lt;code&gt;epmd&lt;/code&gt; daemon will listen only on the specified address(es) and on the loopback address (which is implicitly added to the list if it has not been specified). The default behavior is to listen on all available IP addresses.</source>
          <target state="translated">쉼표로 구분 된 IP 주소 목록으로 설정할 수 있습니다.이 경우 &lt;code&gt;epmd&lt;/code&gt; 데몬은 지정된 주소와 루프백 주소 (지정되지 않은 경우 목록에 암시 적으로 추가됨)에서만 수신합니다. 기본 동작은 사용 가능한 모든 IP 주소를 수신하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="32027351ef478fb666878cfb7ea809e9ec8104be" translate="yes" xml:space="preserve">
          <source>Can be used as a name resolving function for &lt;code&gt;&lt;a href=&quot;#register_name-3&quot;&gt;register_name/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#re_register_name-3&quot;&gt;re_register_name/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#register_name-3&quot;&gt;register_name/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#re_register_name-3&quot;&gt;re_register_name/3&lt;/a&gt;&lt;/code&gt; 의 이름 해석 기능으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a41238ba1ffe4cd44c8669bf5362c16badbd6e66" translate="yes" xml:space="preserve">
          <source>Can be used by a process that initiates a debug structure from a list of options. The values of argument &lt;code&gt;Opt&lt;/code&gt; are the same as for the corresponding functions.</source>
          <target state="translated">옵션 목록에서 디버그 구조를 시작하는 프로세스에서 사용할 수 있습니다. 인수 &lt;code&gt;Opt&lt;/code&gt; 의 값은 해당 기능과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e44e4550227750d3133233de3b9ab784df8d5876" translate="yes" xml:space="preserve">
          <source>Can be used if interactive performance is not to be affected by the emulator process.</source>
          <target state="translated">대화식 성능이 에뮬레이터 프로세스의 영향을받지 않는 경우 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4554428a28a365553523e827200f0a4801491275" translate="yes" xml:space="preserve">
          <source>Can be used if the size of the trace logs must be limited. Default values are &lt;code&gt;Size=128*1024&lt;/code&gt; and &lt;code&gt;Count=8&lt;/code&gt;.</source>
          <target state="translated">추적 로그의 크기를 제한해야하는 경우 사용할 수 있습니다. 기본값은 &lt;code&gt;Size=128*1024&lt;/code&gt; 및 &lt;code&gt;Count=8&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="52514699bbc5fce906ba4874a907b457ea6b2ad1" translate="yes" xml:space="preserve">
          <source>Can be used if two Erlang nodes are to reside on one dedicated system and one is to have precedence over the other.</source>
          <target state="translated">두 개의 Erlang 노드가 하나의 전용 시스템에 상주하고 다른 하나보다 우선하는 경우에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cfd6096580c6f0fc105f7dae283a846f824ac79" translate="yes" xml:space="preserve">
          <source>Can be used to determine which crypto algorithms that are supported by the underlying OpenSSL library</source>
          <target state="translated">기본 OpenSSL 라이브러리가 지원하는 암호화 알고리즘을 결정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a809d60db9759dca31c0adaa3ee892b7d609a6ef" translate="yes" xml:space="preserve">
          <source>Can be used to determine which crypto algorithms that are supported by the underlying libcrypto library</source>
          <target state="translated">기본 libcrypto 라이브러리에서 지원하는 암호화 알고리즘을 결정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ac2e838e28c4e79b7b0173c19b32b3299e09f77" translate="yes" xml:space="preserve">
          <source>Can be used to determine which named elliptic curves are supported.</source>
          <target state="translated">지원되는 명명 된 타원 곡선을 결정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0139eb1de3d0a9614c9b210a184d4b0320912f6e" translate="yes" xml:space="preserve">
          <source>Can be used to make the client act as an &lt;code&gt;HTTP/1.0&lt;/code&gt; or &lt;code&gt;HTTP/0.9&lt;/code&gt; client. By default this is an &lt;code&gt;HTTP/1.1&lt;/code&gt; client. When using &lt;code&gt;HTTP/1.0&lt;/code&gt; persistent connections are not used.</source>
          <target state="translated">클라이언트를 &lt;code&gt;HTTP/1.0&lt;/code&gt; 또는 &lt;code&gt;HTTP/0.9&lt;/code&gt; 클라이언트 로 작동시키는 데 사용할 수 있습니다 . 기본적으로 이것은 &lt;code&gt;HTTP/1.1&lt;/code&gt; 클라이언트입니다. 사용하는 경우 &lt;code&gt;HTTP/1.0&lt;/code&gt; 영구 연결은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9de6dfb4b293a374f8bbe2fd001451aff895674" translate="yes" xml:space="preserve">
          <source>Can be used to retrieve information about the C-node. These values are initially set with &lt;code&gt;ei_connect_init()&lt;/code&gt; or &lt;code&gt;ei_connect_xinit()&lt;/code&gt;.</source>
          <target state="translated">C 노드에 대한 정보를 검색하는 데 사용할 수 있습니다. 이 값은 처음에 &lt;code&gt;ei_connect_init()&lt;/code&gt; 또는 &lt;code&gt;ei_connect_xinit()&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="b6b6b3b3a5a2150a389c6b25e1e84aa23960992c" translate="yes" xml:space="preserve">
          <source>Can be used when interacting with a server called &lt;code&gt;Name&lt;/code&gt; on node &lt;code&gt;Node&lt;/code&gt;. It is assumed that the server receives messages in the format &lt;code&gt;{From, Msg}&lt;/code&gt; and replies using &lt;code&gt;From ! {ReplyWrapper, Node, Reply}&lt;/code&gt;. This function makes such a server call and ensures that the entire call is packed into an atomic transaction, which either succeeds or fails. It never hangs, unless the server itself hangs.</source>
          <target state="translated">노드 &lt;code&gt;Node&lt;/code&gt; 에서 &lt;code&gt;Name&lt;/code&gt; 이라는 서버와 상호 작용할 때 사용할 수 있습니다 . 서버가 &lt;code&gt;{From, Msg}&lt;/code&gt; 형식의 메시지를 수신 하고 &lt;code&gt;From ! {ReplyWrapper, Node, Reply}&lt;/code&gt; 사용하여 응답 한다고 가정합니다 . {ReplyWrapper는, 노드, 회신} . 이 기능은 이러한 서버 호출을 수행하고 전체 호출이 원자 트랜잭션으로 묶여 성공 또는 실패를 보장합니다. 서버 자체가 멈추지 않는 한 절대 멈추지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb8693797500f3627529857787e0f8552cc7d7b2" translate="yes" xml:space="preserve">
          <source>Can be used when interacting with servers called &lt;code&gt;Name&lt;/code&gt; on the specified nodes. It is assumed that the servers receive messages in the format &lt;code&gt;{From, Msg}&lt;/code&gt; and reply using &lt;code&gt;From ! {Name, Node, Reply}&lt;/code&gt;, where &lt;code&gt;Node&lt;/code&gt; is the name of the node where the server is located. The function returns &lt;code&gt;{Replies, BadNodes}&lt;/code&gt;, where &lt;code&gt;Replies&lt;/code&gt; is a list of all &lt;code&gt;Reply&lt;/code&gt; values, and &lt;code&gt;BadNodes&lt;/code&gt; is one of the following:</source>
          <target state="translated">지정된 노드에서 &lt;code&gt;Name&lt;/code&gt; 이라는 서버와 상호 작용할 때 사용할 수 있습니다 . 서버는 &lt;code&gt;{From, Msg}&lt;/code&gt; 형식의 메시지를 수신 하고 &lt;code&gt;From ! {Name, Node, Reply}&lt;/code&gt; 사용하여 응답 한다고 가정합니다 . {Name, Node, Reply} (여기서 &lt;code&gt;Node&lt;/code&gt; 는 서버가있는 노드의 이름입니다. 이 함수는 &lt;code&gt;{Replies, BadNodes}&lt;/code&gt; 리턴합니다 . 여기서 &lt;code&gt;Replies&lt;/code&gt; 는 모든 &lt;code&gt;Reply&lt;/code&gt; 값 의 목록 이며 &lt;code&gt;BadNodes&lt;/code&gt; 는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="413a11e06a5cc3367aeaca579508da6cce5c360b" translate="yes" xml:space="preserve">
          <source>Can be used with &lt;code&gt;chunk/2,3&lt;/code&gt; and &lt;code&gt;bchunk/2,3&lt;/code&gt; to search through an internally formatted wrap log. It takes as argument a continuation as returned by &lt;code&gt;chunk/2,3&lt;/code&gt;, &lt;code&gt;bchunk/2,3&lt;/code&gt;, or &lt;code&gt;chunk_step/3&lt;/code&gt;, and steps forward (or backward) &lt;code&gt;Step&lt;/code&gt; files in the wrap log. The continuation returned, points to the first log item in the new current file.</source>
          <target state="translated">&lt;code&gt;chunk/2,3&lt;/code&gt; 및 &lt;code&gt;bchunk/2,3&lt;/code&gt; / 2,3 과 함께 사용 하여 내부 형식화 된 랩 로그를 검색 할 수 있습니다 . &lt;code&gt;chunk/2,3&lt;/code&gt; , &lt;code&gt;bchunk/2,3&lt;/code&gt; 또는 &lt;code&gt;chunk_step/3&lt;/code&gt; 에서 리턴 한대로 연속을 인수 로 사용하고 랩 로그에서 &lt;code&gt;Step&lt;/code&gt; 파일을 앞으로 (또는 뒤로) 단계 화 합니다. 리턴 된 연속은 새 현재 파일의 첫 번째 로그 항목을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="54b689659783bb6b4ac1454db70e48394a638a38" translate="yes" xml:space="preserve">
          <source>Can contain the port number &lt;code&gt;epmd&lt;/code&gt; will use. The default port will work fine in most cases. A different port can be specified to allow several instances of &lt;code&gt;epmd&lt;/code&gt;, representing independent clusters of nodes, to co-exist on the same host. All nodes in a cluster must use the same &lt;code&gt;epmd&lt;/code&gt; port number.</source>
          <target state="translated">&lt;code&gt;epmd&lt;/code&gt; 가 사용할 포트 번호를 포함 할 수 있습니다 . 대부분의 경우 기본 포트가 제대로 작동합니다. 독립적 인 노드 클러스터를 나타내는 &lt;code&gt;epmd&lt;/code&gt; 의 여러 인스턴스가 동일한 호스트에 공존 할 수 있도록 다른 포트를 지정할 수 있습니다 . 클러스터의 모든 노드는 동일한 &lt;code&gt;epmd&lt;/code&gt; 포트 번호를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d1d4e8ff3c787597c2cdf851d9445ac7a46d3eec" translate="yes" xml:space="preserve">
          <source>Can contain the port number to use when communicating with &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt;. The default port works fine in most cases. A different port can be specified to allow nodes of independent clusters to co-exist on the same host. All nodes in a cluster must use the same &lt;code&gt;epmd&lt;/code&gt; port number.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt; 와 통신 할 때 사용할 포트 번호를 포함 할 수 있습니다 . 대부분의 경우 기본 포트가 제대로 작동합니다. 독립 클러스터의 노드가 동일한 호스트에 공존 할 수 있도록 다른 포트를 지정할 수 있습니다. 클러스터의 모든 노드는 동일한 &lt;code&gt;epmd&lt;/code&gt; 포트 번호를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="763e2024cfbffcaa35312ea836b3ce5e41e09735" translate="yes" xml:space="preserve">
          <source>Can either be the originals passed into the calling NIF, or can be values created by the calling NIF.</source>
          <target state="translated">호출하는 NIF로 전달 된 원본이거나 호출하는 NIF에 의해 작성된 값일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1762b945a07d7a0928b055cdfb86c61f5e180a18" translate="yes" xml:space="preserve">
          <source>Can enable trace on all functions or only exported functions on chosen modules.</source>
          <target state="translated">모든 기능에서 추적을 사용하거나 선택한 모듈에서 내 보낸 기능 만 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6d98498dcb02bc77d5362ec71948bf4dcb80403" translate="yes" xml:space="preserve">
          <source>Can only be used to check the local time of day if the time-zone information of the underlying OS is properly configured.</source>
          <target state="translated">기본 OS의 시간대 정보가 올바르게 구성된 경우에만 현지 시간을 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b665cc5f87b4b96a8b89bb4858d5c6ded666e00" translate="yes" xml:space="preserve">
          <source>Can only be used with TLS/DTLS connections; &lt;code&gt;{error, undefined}&lt;/code&gt; is returned for SSLv3 connections.</source>
          <target state="translated">TLS / DTLS 연결에만 사용할 수 있습니다. SSLv3 연결에 대해 &lt;code&gt;{error, undefined}&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="65065adca48747308c795b0ca8e2fa3439ca68c0" translate="yes" xml:space="preserve">
          <source>Canadian_Aboriginal</source>
          <target state="translated">Canadian_Aboriginal</target>
        </trans-unit>
        <trans-unit id="0ce7f9b48109071ca45af63e2c7f4cded74fe895" translate="yes" xml:space="preserve">
          <source>Cancel a previous asynchronous request.</source>
          <target state="translated">이전 비동기 요청을 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="8c0d517ae93b9275421781af37452eec4bb2fa47" translate="yes" xml:space="preserve">
          <source>Cancel a previous request to be notified of SNMP manager start.</source>
          <target state="translated">SNMP 관리자 시작을 알리는 이전 요청을 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="a9a0f30cfff3cf2f7919e74d440e32f436d7292c" translate="yes" xml:space="preserve">
          <source>Cancel all outstanding messages for this connection</source>
          <target state="translated">이 연결에 대한 모든 미해결 메시지 취소</target>
        </trans-unit>
        <trans-unit id="5aba33ae4d23c8305d0ff9ae3f760f6d7bc6c018" translate="yes" xml:space="preserve">
          <source>Cancel an asynchronous request.</source>
          <target state="translated">비동기 요청을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="2e83179d769a2b44650615f9d44ca78b37a04604" translate="yes" xml:space="preserve">
          <source>Cancel the handshake with a fatal &lt;code&gt;USER_CANCELED&lt;/code&gt; alert.</source>
          <target state="translated">치명적인 &lt;code&gt;USER_CANCELED&lt;/code&gt; 경고로 악수를 취소하십시오 .</target>
        </trans-unit>
        <trans-unit id="512e48b731dfabfc2f052978658a8655b252b710" translate="yes" xml:space="preserve">
          <source>Cancels a monitor created earlier with &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt; enif_monitor_process&lt;/a&gt;&lt;/code&gt;. Argument &lt;code&gt;obj&lt;/code&gt; is a pointer to the resource holding the monitor and &lt;code&gt;*mon&lt;/code&gt; identifies the monitor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt; enif_monitor_process&lt;/a&gt;&lt;/code&gt; 를 사용 하여 이전에 만든 모니터를 취소합니다 . 인수 &lt;code&gt;obj&lt;/code&gt; 는 모니터를 보유하는 자원에 대한 포인터이고 &lt;code&gt;*mon&lt;/code&gt; 은 모니터를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="5e51a49231000a90b74f84cb0f1813b99bdab3f4" translate="yes" xml:space="preserve">
          <source>Cancels a monitor created earlier with &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt;. Argument &lt;code&gt;obj&lt;/code&gt; is a pointer to the resource holding the monitor and &lt;code&gt;*mon&lt;/code&gt; identifies the monitor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt; 로 이전에 작성된 모니터를 취소합니다 . 인수 &lt;code&gt;obj&lt;/code&gt; 는 모니터를 보유한 자원에 대한 포인터이며 &lt;code&gt;*mon&lt;/code&gt; 은 모니터를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="96cae339d2d57bc5c2386eed4ecb967d6f0a23af" translate="yes" xml:space="preserve">
          <source>Cancels a monitor created earlier.</source>
          <target state="translated">앞에서 만든 모니터를 취소합니다.</target>
        </trans-unit>
        <trans-unit id="1f0665372f0c058f76dc85627e4390cc9a27b91a" translate="yes" xml:space="preserve">
          <source>Cancels a previously requested time-out. &lt;code&gt;TRef&lt;/code&gt; is a unique timer reference returned by the related timer function.</source>
          <target state="translated">이전에 요청한 시간 초과를 취소합니다. &lt;code&gt;TRef&lt;/code&gt; 는 관련 타이머 기능에 의해 반환되는 고유 한 타이머 참조입니다.</target>
        </trans-unit>
        <trans-unit id="be2d617334028ba42207577f2c0c4db3092e85de" translate="yes" xml:space="preserve">
          <source>Cancels a timer set with &lt;code&gt;&lt;a href=&quot;#driver_set_timer&quot;&gt; driver_set_timer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#driver_set_timer&quot;&gt; driver_set_timer&lt;/a&gt;&lt;/code&gt; 로 설정된 타이머를 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="2dfd6843c1a8e9b558c9edbe4d27191bbd822b29" translate="yes" xml:space="preserve">
          <source>Cancels a timer set with &lt;code&gt;&lt;a href=&quot;#driver_set_timer&quot;&gt;driver_set_timer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#driver_set_timer&quot;&gt;driver_set_timer&lt;/a&gt;&lt;/code&gt; 로 설정된 타이머를 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="b17a85c7c341fb9ad575021c84d0507b60def106" translate="yes" xml:space="preserve">
          <source>Cancels a timer that has been created by &lt;code&gt;&lt;a href=&quot;#start_timer-4&quot;&gt; erlang:start_timer&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#send_after-4&quot;&gt;erlang:send_after&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;TimerRef&lt;/code&gt; identifies the timer, and was returned by the BIF that created the timer.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#start_timer-4&quot;&gt; erlang:start_timer&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#send_after-4&quot;&gt;erlang:send_after&lt;/a&gt;&lt;/code&gt; 에 의해 생성 된 타이머를 취소합니다 . &lt;code&gt;TimerRef&lt;/code&gt; 는 타이머를 식별하고 타이머를 만든 BIF에서 반환되었습니다.</target>
        </trans-unit>
        <trans-unit id="f1c27441b4577bb7df82953733b9a8895adaaf42" translate="yes" xml:space="preserve">
          <source>Cancels a timer that has been created by &lt;code&gt;&lt;a href=&quot;#start_timer-4&quot;&gt;erlang:start_timer&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#send_after-4&quot;&gt;erlang:send_after&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;TimerRef&lt;/code&gt; identifies the timer, and was returned by the BIF that created the timer.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#start_timer-4&quot;&gt;erlang:start_timer&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#send_after-4&quot;&gt;erlang:send_after&lt;/a&gt;&lt;/code&gt; 에 의해 작성된 타이머를 취소합니다 . &lt;code&gt;TimerRef&lt;/code&gt; 는 타이머를 식별하며 타이머를 만든 BIF에 의해 반환되었습니다.</target>
        </trans-unit>
        <trans-unit id="0df1541c96a30a0731a1c3888c1e2faced1631ac" translate="yes" xml:space="preserve">
          <source>Cancels a timer. The same as calling &lt;code&gt;&lt;a href=&quot;#cancel_timer-2&quot;&gt; erlang:cancel_timer(TimerRef, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">타이머를 취소합니다. &lt;code&gt;&lt;a href=&quot;#cancel_timer-2&quot;&gt; erlang:cancel_timer(TimerRef, [])&lt;/a&gt;&lt;/code&gt; 호출과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="515e3b82893f87b97d2f6951c20fe359a4a9690f" translate="yes" xml:space="preserve">
          <source>Cancels a timer. The same as calling &lt;code&gt;&lt;a href=&quot;#cancel_timer-2&quot;&gt;erlang:cancel_timer(TimerRef, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">타이머를 취소합니다. &lt;code&gt;&lt;a href=&quot;#cancel_timer-2&quot;&gt;erlang:cancel_timer(TimerRef, [])&lt;/a&gt;&lt;/code&gt; 호출과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="df65de63f9858575da41cfa50c0a1015308635d0" translate="yes" xml:space="preserve">
          <source>Cancels an asynchronous HTTP request. Notice that this does not guarantee that the request response is not delivered. Because it is asynchronous, the request can already have been completed when the cancellation arrives.</source>
          <target state="translated">비동기 HTTP 요청을 취소합니다. 이로 인해 요청 응답이 전달되지는 않습니다. 비동기식이므로 취소가 도착하면 요청이 이미 완료되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b541e4bb9b743ccb5ae258df54a4b47b94078144" translate="yes" xml:space="preserve">
          <source>Cancels any active timetrap and pauses the execution of the current test case until the user calls function &lt;code&gt;continue/0&lt;/code&gt;. The user can then interact with the Erlang node running the tests, for example, for debugging purposes or for manually executing a part of the test case. If a parallel group is executing, &lt;code&gt;&lt;a href=&quot;#break-2&quot;&gt;ct:break/2&lt;/a&gt;&lt;/code&gt; is to be called instead.</source>
          <target state="translated">활성 타임 트랩을 취소하고 사용자가 function &lt;code&gt;continue/0&lt;/code&gt; 을 호출 할 때까지 현재 테스트 케이스의 실행을 일시 중지합니다 . 그런 다음 사용자는 테스트를 실행하는 Erlang 노드와 상호 작용할 수 있습니다 (예 : 디버깅 목적 또는 테스트 케이스의 일부를 수동으로 실행). 병렬 그룹이 실행 &lt;code&gt;&lt;a href=&quot;#break-2&quot;&gt;ct:break/2&lt;/a&gt;&lt;/code&gt; 가 대신 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ef0062b553bef5e57661343010bd1663e123fb3c" translate="yes" xml:space="preserve">
          <source>Cannot find a script for upgrading/downgrading between &lt;code&gt;CurrentVsn&lt;/code&gt; and &lt;code&gt;Vsn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CurrentVsn&lt;/code&gt; 과 &lt;code&gt;Vsn&lt;/code&gt; 간 업그레이드 / 다운 그레이드를위한 스크립트를 찾을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="59c2c275dbff28468b338a2a1d74abfdb2ab249d" translate="yes" xml:space="preserve">
          <source>Capabilities Exchange</source>
          <target state="translated">기능 교환</target>
        </trans-unit>
        <trans-unit id="6f815b9cd6720fa896907fcc11d7b3e052d3034d" translate="yes" xml:space="preserve">
          <source>Capabilities exchange has failed. &lt;code&gt;Reason&lt;/code&gt; can have one of the following types.</source>
          <target state="translated">기능 교환에 실패했습니다. &lt;code&gt;Reason&lt;/code&gt; 는 다음 유형 중 하나를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="650fc093260c1b58ae5fd02c80725cb6220c8159" translate="yes" xml:space="preserve">
          <source>Capabilities-Exchange-Answer</source>
          <target state="translated">Capabilities-Exchange-Answer</target>
        </trans-unit>
        <trans-unit id="acf14eeece446c5904b65bad9ec3f274e5e6164c" translate="yes" xml:space="preserve">
          <source>Capabilities-Exchange-Request</source>
          <target state="translated">Capabilities-Exchange-Request</target>
        </trans-unit>
        <trans-unit id="b2b40c5778d35eb5bdc2d77add606c0d6436b77d" translate="yes" xml:space="preserve">
          <source>Capability options are ignored by connect/1-3 and only_open/1-2, which don't result in an outgoing hello message.</source>
          <target state="translated">기능 옵션은 connect / 1-3 및 only_open / 1-2에서 무시되며, 이는 나가는 hello 메시지를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7409a4b0f3b37f1008c113fb6e626f5103a444b1" translate="yes" xml:space="preserve">
          <source>Capitalized &lt;strong&gt;Diameter&lt;/strong&gt; refers to the protocol, lowercase &lt;strong&gt;diameter&lt;/strong&gt; to the Erlang application.</source>
          <target state="translated">대문자 &lt;strong&gt;직경&lt;/strong&gt; 은 프로토콜, 소문자 &lt;strong&gt;직경&lt;/strong&gt; 은 Erlang 응용 프로그램을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6454a649d8a2356d9dddbd06143083fa5db5fee7" translate="yes" xml:space="preserve">
          <source>Captures all log events that would normally be printed by the default logger handler, and prints them to the current test case log. If an event cannot be associated with a test case, it is printed in the &lt;code&gt;Common Test&lt;/code&gt; framework log. This happens for test cases running in parallel and events occuring in-between test cases.</source>
          <target state="translated">기본 로거 핸들러에 의해 일반적으로 인쇄되는 모든 로그 이벤트를 캡처하여 현재 테스트 케이스 로그에 인쇄합니다. 이벤트가 테스트 케이스와 연관 될 수없는 경우 &lt;code&gt;Common Test&lt;/code&gt; 프레임 워크 로그에 인쇄됩니다 . 이것은 병렬로 실행되는 테스트 케이스와 테스트 케이스 사이에서 발생하는 이벤트에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3faea7a0af305bcea0e8fcf9cf99c51068a261b7" translate="yes" xml:space="preserve">
          <source>Captures all log events that would normally be printed by the default logger handler, and prints them to the current test case log. If an event cannot be associated with a test case, it is printed in the &lt;code&gt;Common Test&lt;/code&gt; framework log. This happens for test cases running in parallel and events occuring in-between test cases. You can configure the level of &lt;code&gt;SASL&lt;/code&gt; reports using the normal SASL mechanisms.</source>
          <target state="translated">기본 로거 핸들러가 일반적으로 인쇄하는 모든 로그 이벤트를 캡처하여 현재 테스트 케이스 로그에 인쇄합니다. 이벤트가 테스트 케이스와 연관 될 수없는 경우 &lt;code&gt;Common Test&lt;/code&gt; 프레임 워크 로그에 인쇄됩니다 . 이것은 병렬로 실행되는 테스트 케이스와 테스트 케이스간에 발생하는 이벤트에 대해 발생합니다. 일반적인 SASL 메커니즘을 사용하여 &lt;code&gt;SASL&lt;/code&gt; 보고서 레벨을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46bfe99abf367a44ddc81f52e9b2dd6714cf8a38" translate="yes" xml:space="preserve">
          <source>Captures all test results and outputs them as surefire XML into a file. The created file is by default called &lt;code&gt;junit_report.xml&lt;/code&gt;. The file name can be changed by setting option &lt;code&gt;path&lt;/code&gt; for this hook, for example:</source>
          <target state="translated">모든 테스트 결과를 캡처하여 확실한 XML로 파일로 출력합니다. 작성된 파일은 기본적으로 &lt;code&gt;junit_report.xml&lt;/code&gt; 입니다. 이 후크에 대한 옵션 &lt;code&gt;path&lt;/code&gt; 를 설정하여 파일 이름을 변경할 수 있습니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="d07225edcafc11a68f3d5eb9b90023be29cd700a" translate="yes" xml:space="preserve">
          <source>Carefully prevent translating the &lt;code&gt;Raw Trace Data&lt;/code&gt; twice</source>
          <target state="translated">&lt;code&gt;Raw Trace Data&lt;/code&gt; 가 두 번 번역되지 않도록주의하십시오</target>
        </trans-unit>
        <trans-unit id="6e0d5cedfdd10366517f607a93eeeef9b4785a51" translate="yes" xml:space="preserve">
          <source>Carian</source>
          <target state="translated">Carian</target>
        </trans-unit>
        <trans-unit id="df10067f5a8780a3c7f1ce6b060b8d78df100b22" translate="yes" xml:space="preserve">
          <source>Carriage return</source>
          <target state="translated">캐리지 리턴</target>
        </trans-unit>
        <trans-unit id="6816a4bcee325f605828c9a0983b400ec2b0b807" translate="yes" xml:space="preserve">
          <source>Carriage return (CR)</source>
          <target state="translated">캐리지 리턴 (CR)</target>
        </trans-unit>
        <trans-unit id="4788a491bde10053f4b29b72d3ab33319a6fa543" translate="yes" xml:space="preserve">
          <source>Carriage return (hex 0D)</source>
          <target state="translated">캐리지 리턴 (16 진 0D)</target>
        </trans-unit>
        <trans-unit id="730f6dc38b735a30bd3b01925e8207103f8f081e" translate="yes" xml:space="preserve">
          <source>Carriage return.</source>
          <target state="translated">캐리지 리턴.</target>
        </trans-unit>
        <trans-unit id="ac86d2f38a97ba396ecc606e85913560b9394190" translate="yes" xml:space="preserve">
          <source>Carrier pool associated with &lt;code&gt;binary_alloc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;binary_alloc&lt;/code&gt; 과 관련된 캐리어 풀 .</target>
        </trans-unit>
        <trans-unit id="136d8537250d31ffae733f8d73dfb88d027c7ac9" translate="yes" xml:space="preserve">
          <source>Carrier pool associated with &lt;code&gt;driver_alloc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;driver_alloc&lt;/code&gt; 과 연관된 캐리어 풀 .</target>
        </trans-unit>
        <trans-unit id="b657ca0fde8e2f710828753eb201ccdcd5d06860" translate="yes" xml:space="preserve">
          <source>Carrier pool associated with &lt;code&gt;eheap_alloc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eheap_alloc&lt;/code&gt; 과 연관된 캐리어 풀 .</target>
        </trans-unit>
        <trans-unit id="af7e183f95d0d26975c1437f27c82e38a4d870eb" translate="yes" xml:space="preserve">
          <source>Carrier pool associated with &lt;code&gt;ets_alloc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ets_alloc&lt;/code&gt; 와 관련된 캐리어 풀 .</target>
        </trans-unit>
        <trans-unit id="a0c2c6f39532ac6a69f54b45c1eed8e7d02ee768" translate="yes" xml:space="preserve">
          <source>Carrier pool associated with &lt;code&gt;fix_alloc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fix_alloc&lt;/code&gt; 과 연관된 캐리어 풀 .</target>
        </trans-unit>
        <trans-unit id="5472ccb63504cc29da8f79c43e9078ef65d5ea61" translate="yes" xml:space="preserve">
          <source>Carrier pool associated with &lt;code&gt;ll_alloc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ll_alloc&lt;/code&gt; 와 연관된 캐리어 풀 .</target>
        </trans-unit>
        <trans-unit id="01b7000fafc3012b828e16b84f71bfa568e1ae3c" translate="yes" xml:space="preserve">
          <source>Carrier pool associated with &lt;code&gt;sl_alloc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sl_alloc&lt;/code&gt; 과 연관된 캐리어 풀 .</target>
        </trans-unit>
        <trans-unit id="ceb54b6df2e43a144c15799ad5adbf3de30533a4" translate="yes" xml:space="preserve">
          <source>Carrier pool associated with &lt;code&gt;std_alloc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std_alloc&lt;/code&gt; 과 연관된 캐리어 풀 .</target>
        </trans-unit>
        <trans-unit id="c7aab2373100333dca607e632e879d37cb0f2d2f" translate="yes" xml:space="preserve">
          <source>Carrier pool associated with the system as a whole.</source>
          <target state="translated">시스템 전체와 관련된 캐리어 풀.</target>
        </trans-unit>
        <trans-unit id="dc8d706f8d246ecbcbc193deb6d5f3e407c9522d" translate="yes" xml:space="preserve">
          <source>Carriers are abandoned when memory utilization in the allocator instance falls below the utilization value used. Once a carrier is abandoned, no new allocations are made in it. When an allocator instance gets an increased multiblock carrier need, it first tries to fetch an abandoned carrier from an allocator instance of the same allocator type. If no abandoned carrier can be fetched, it creates a new empty carrier. When an abandoned carrier has been fetched, it will function as an ordinary carrier. This feature has special requirements on the &lt;code&gt;&lt;a href=&quot;#M_as&quot;&gt;allocation strategy&lt;/a&gt;&lt;/code&gt; used. Only the strategies &lt;code&gt;aoff&lt;/code&gt;, &lt;code&gt;aoffcbf&lt;/code&gt;, &lt;code&gt;aoffcaobf&lt;/code&gt;, &lt;code&gt;ageffcaoff&lt;/code&gt;m, &lt;code&gt;ageffcbf&lt;/code&gt; and &lt;code&gt;ageffcaobf&lt;/code&gt; support abandoned carriers.</source>
          <target state="translated">할당 자 인스턴스의 메모리 사용률이 사용 된 사용률 미만으로 떨어지면 캐리어가 중단됩니다. 운송 업체가 포기되면 새로운 할당이 이루어지지 않습니다. 할당 자 인스턴스가 증가 된 멀티 블록 캐리어 요구를 받으면 먼저 동일한 할당 자 유형의 할당 자 인스턴스에서 버려진 캐리어를 가져 오려고 시도합니다. 버려진 운송 업체를 가져올 수없는 경우 비어있는 새로운 운송 업체가 생성됩니다. 폐기 된 운송 업체를 가져 오면 일반 운송 업체로 작동합니다. 이 기능에는 사용 된 &lt;code&gt;&lt;a href=&quot;#M_as&quot;&gt;allocation strategy&lt;/a&gt;&lt;/code&gt; 에 대한 특별한 요구 사항이 있습니다 . 전략 &lt;code&gt;aoff&lt;/code&gt; , &lt;code&gt;aoffcbf&lt;/code&gt; , &lt;code&gt;aoffcaobf&lt;/code&gt; , &lt;code&gt;ageffcaoff&lt;/code&gt; m, &lt;code&gt;ageffcbf&lt;/code&gt; 및 &lt;code&gt;ageffcaobf&lt;/code&gt; 만 버려진 사업자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="caef8d032299864b49e02c5e2220052e5b8ad212" translate="yes" xml:space="preserve">
          <source>Carriers are abandoned when memory utilization in the allocator instance falls below the utilization value used. Once a carrier is abandoned, no new allocations are made in it. When an allocator instance gets an increased multiblock carrier need, it first tries to fetch an abandoned carrier from another allocator instance. If no abandoned carrier can be fetched, it creates a new empty carrier. When an abandoned carrier has been fetched, it will function as an ordinary carrier. This feature has special requirements on the &lt;code&gt;&lt;a href=&quot;#M_as&quot;&gt;allocation strategy&lt;/a&gt;&lt;/code&gt; used. Only the strategies &lt;code&gt;aoff&lt;/code&gt;, &lt;code&gt;aoffcbf&lt;/code&gt;, &lt;code&gt;aoffcaobf&lt;/code&gt;, &lt;code&gt;ageffcaoff&lt;/code&gt;m, &lt;code&gt;ageffcbf&lt;/code&gt; and &lt;code&gt;ageffcaobf&lt;/code&gt; support abandoned carriers.</source>
          <target state="translated">할당 자 인스턴스의 메모리 사용률이 사용 된 사용률 값 아래로 떨어지면 캐리어가 중단됩니다. 운송 업체가 포기되면 새로운 할당이 이루어지지 않습니다. 할당 자 인스턴스가 증가 된 다중 블록 캐리어 요구를 받으면 먼저 다른 할당 자 인스턴스에서 버려진 캐리어를 가져 오려고합니다. 버려진 운송 업체를 가져올 수없는 경우 비어있는 새 운송 업체를 생성합니다. 버려진 캐리어를 가져 오면 일반 캐리어로 작동합니다. 이 기능에는 사용 된 &lt;code&gt;&lt;a href=&quot;#M_as&quot;&gt;allocation strategy&lt;/a&gt;&lt;/code&gt; 에 대한 특별한 요구 사항이 있습니다 . &lt;code&gt;aoff&lt;/code&gt; , &lt;code&gt;aoffcbf&lt;/code&gt; , &lt;code&gt;aoffcaobf&lt;/code&gt; , &lt;code&gt;ageffcaoff&lt;/code&gt; m, &lt;code&gt;ageffcbf&lt;/code&gt; 및 &lt;code&gt;ageffcaobf&lt;/code&gt; 전략 만이 버려진 이동 통신사를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="248440260111abecc898e4704059b3f4b5c930ae" translate="yes" xml:space="preserve">
          <source>Case-related information is sent to the minor log file.</source>
          <target state="translated">사례 관련 정보가 부 로그 파일로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="553cb7afb2839db8e29aca4e968f3b1d24ea5656" translate="yes" xml:space="preserve">
          <source>Categories in a CSS file installed with flag &lt;code&gt;-stylesheet&lt;/code&gt; are on a global test level in the sense that they can be used in any suite that is part of the test run.</source>
          <target state="translated">flag &lt;code&gt;-stylesheet&lt;/code&gt; 와 함께 설치된 CSS 파일의 범주 는 테스트 실행의 일부인 모든 제품군에서 사용할 수 있다는 의미에서 전역 테스트 수준에 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fd68e15271b50917550f2816bf00e0a52193319" translate="yes" xml:space="preserve">
          <source>Caucasian_Albanian</source>
          <target state="translated">Caucasian_Albanian</target>
        </trans-unit>
        <trans-unit id="e2d6fad43a0498df568c18e20abea6e5fa09545f" translate="yes" xml:space="preserve">
          <source>Cause &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; to return &lt;code&gt;ok&lt;/code&gt; as soon as the request in question has been encoded, instead of waiting for and returning the result from a subsequent &lt;code&gt;handle_answer/4&lt;/code&gt; or &lt;code&gt;handle_error/4&lt;/code&gt; callback.</source>
          <target state="translated">원인 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 돌아갑니다 &lt;code&gt;ok&lt;/code&gt; 대신 다음에서 결과를 기다리고 반환하는, 곧 문제의 요청이 인코딩 된만큼 &lt;code&gt;handle_answer/4&lt;/code&gt; 또는 &lt;code&gt;handle_error/4&lt;/code&gt; 콜백.</target>
        </trans-unit>
        <trans-unit id="570360f716edc9b6804b7e0a9d5afd7c16e0085a" translate="yes" xml:space="preserve">
          <source>Causes a &lt;code&gt;return_from&lt;/code&gt; trace message to be sent upon return from the current function. Takes no arguments, returns &lt;code&gt;true&lt;/code&gt; and can only be used in the &lt;code&gt;MatchBody&lt;/code&gt; part when tracing. If the process trace flag &lt;code&gt;silent&lt;/code&gt; is active, the &lt;code&gt;return_from&lt;/code&gt; trace message is inhibited.</source>
          <target state="translated">원인 &lt;code&gt;return_from&lt;/code&gt; 의 현재 함수에서 반환에 보낼 추적 메시지를. 인수를 취하지 않고 &lt;code&gt;true&lt;/code&gt; 를 반환 하며 추적시 &lt;code&gt;MatchBody&lt;/code&gt; 부분 에서만 사용할 수 있습니다 . 프로세스 추적 플래그 &lt;code&gt;silent&lt;/code&gt; 이 활성화되면 &lt;code&gt;return_from&lt;/code&gt; 추적 메시지가 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="0f83a449788035c5daddd3c7cc544bc89f92b0e1" translate="yes" xml:space="preserve">
          <source>Causes all functions in the module to be exported.</source>
          <target state="translated">모듈의 모든 기능을 내보내도록합니다.</target>
        </trans-unit>
        <trans-unit id="fe332b700f28356ff8a5f78d81f00f95837a3633" translate="yes" xml:space="preserve">
          <source>Causes all functions whose names match &lt;code&gt;..._test()&lt;/code&gt; or &lt;code&gt;..._test_()&lt;/code&gt; to be automatically exported from the module (unless testing is turned off, or the &lt;code&gt;EUNIT_NOAUTO&lt;/code&gt; macro is defined)</source>
          <target state="translated">이름이 &lt;code&gt;..._test()&lt;/code&gt; 또는 &lt;code&gt;..._test_()&lt;/code&gt; 와 일치하는 모든 함수를 모듈에서 자동으로 내보내도록합니다 (테스트가 꺼 지거나 &lt;code&gt;EUNIT_NOAUTO&lt;/code&gt; 매크로가 정의 되지 않은 경우 )</target>
        </trans-unit>
        <trans-unit id="cbf5a345cd73ab13c594b9386ee0ccc9585d1458" translate="yes" xml:space="preserve">
          <source>Causes an incoming CER to be answered with the specified Result-Code.</source>
          <target state="translated">지정된 결과 코드로 수신 CER에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="bfdce3d3f20fa4bdb35120d035e253a72f1f27ab" translate="yes" xml:space="preserve">
          <source>Causes an incoming CER to be discarded without CEA being sent.</source>
          <target state="translated">CEA를 보내지 않고 들어오는 CER을 버립니다.</target>
        </trans-unit>
        <trans-unit id="1c84a25f88cef95a969186ffd086cc21cc0bdce3" translate="yes" xml:space="preserve">
          <source>Causes errors to be printed as they occur. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">오류가 발생하면 인쇄됩니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8faf1fc25487a79ecf11509cc8431e2ab3c9529c" translate="yes" xml:space="preserve">
          <source>Causes errors/warnings to be printed as they occur.</source>
          <target state="translated">오류 / 경고가 발생할 때 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="77b4c47a390eff838ecbf5032f6fac69686fec82" translate="yes" xml:space="preserve">
          <source>Causes more verbose information from the compiler describing what it is doing.</source>
          <target state="translated">컴파일러가 수행하는 작업을 설명하는 자세한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="00e83a1aaa3324cf8e746707d300d67e05f61a48" translate="yes" xml:space="preserve">
          <source>Causes more verbose information from the compiler, describing what it is doing.</source>
          <target state="translated">컴파일러가 수행하는 작업을 설명하는 자세한 정보를 컴파일러에서 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="0147f8a181b5f581485dbe15e687595d798e64d1" translate="yes" xml:space="preserve">
          <source>Causes parsing of the dictionary to terminate: any remaining content is ignored.</source>
          <target state="translated">사전 구문 분석이 종료되도록합니다. 남아있는 내용은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d9b63b06428fd02872f1b766f95c730b7cc03fb1" translate="yes" xml:space="preserve">
          <source>Causes the UserMod:handle_disconnect/2 callback function to be invoked. See the megaco_user module for more info about the callback arguments.</source>
          <target state="translated">UserMod : handle_disconnect / 2 콜백 함수가 호출되도록합니다. 콜백 인수에 대한 자세한 정보는 megaco_user 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="19040404a924124b084f13439cbc9fccbe3088f6" translate="yes" xml:space="preserve">
          <source>Causes the analysis to be appended to the destination file. This option is only allowed with the &lt;code&gt;{dest, Destfile}&lt;/code&gt; option.</source>
          <target state="translated">분석이 대상 파일에 추가되도록합니다. 이 옵션은 &lt;code&gt;{dest, Destfile}&lt;/code&gt; 옵션 에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b817b5ff6a5ae6d79528aae932bd44bb7e51b112" translate="yes" xml:space="preserve">
          <source>Causes the macro to behave as if it had never been defined.</source>
          <target state="translated">매크로가 정의되지 않은 것처럼 동작하도록합니다.</target>
        </trans-unit>
        <trans-unit id="de3d942d1cb015f65f7810221dee3bf9248a3179" translate="yes" xml:space="preserve">
          <source>Causes the parse transformation function &lt;code&gt;Module:parse_transform/2&lt;/code&gt; to be applied to the parsed code before the code is checked for errors.</source>
          <target state="translated">코드가 오류를 검사하기 전에 구문 분석 변환 함수 &lt;code&gt;Module:parse_transform/2&lt;/code&gt; 가 구문 분석 된 코드에 적용되도록합니다.</target>
        </trans-unit>
        <trans-unit id="9b957bc52c303103671e3fd8a1393097cbb4ac1b" translate="yes" xml:space="preserve">
          <source>Causes the trace text dump to be appended to the destination file. This option is only allowed with the &lt;code&gt;{dump, Dumpfile}&lt;/code&gt; option.</source>
          <target state="translated">추적 텍스트 덤프가 대상 파일에 추가됩니다. 이 옵션은 &lt;code&gt;{dump, Dumpfile}&lt;/code&gt; 옵션 에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="897e3b8b3636eede78c888d979db2f52548fa5c1" translate="yes" xml:space="preserve">
          <source>Causes warnings to be emitted for malformed format strings as arguments to &lt;code&gt;io:format&lt;/code&gt; and similar functions.</source>
          <target state="translated">잘못된 형식 문자열에 대해 &lt;code&gt;io:format&lt;/code&gt; 및 유사한 함수에 대한 인수로 경고가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="468df461393d6efb98c52bfe23ce339db17eda3e" translate="yes" xml:space="preserve">
          <source>Causes warnings to be printed as they occur. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경고가 발생하면 인쇄됩니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0264d4e983281d4906c3269105e1222b5bb44053" translate="yes" xml:space="preserve">
          <source>Causes warnings to be treated as errors.</source>
          <target state="translated">경고를 오류로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="3d0409736faa64f257591577d0f14d0f47ce2247" translate="yes" xml:space="preserve">
          <source>Causes warnings to be treated as errors. This option is supported since R13B04.</source>
          <target state="translated">경고를 오류로 취급합니다. 이 옵션은 R13B04부터 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f259ea23d772c19d8bca466e8d68aee439724a78" translate="yes" xml:space="preserve">
          <source>Caveats: It is possible that in some intricate uses of macros, the automatic addition or removal of parentheses around uses or arguments could cause the resulting program to be rejected by the compiler; however, we have found no such case in existing code. Programs defining strange macros can usually not be read by this program, and in those cases, no changes will be made.</source>
          <target state="translated">주의 사항 : 매크로의 복잡한 사용에서 사용 또는 인수 주위에 괄호를 자동으로 추가하거나 제거하면 결과 프로그램이 컴파일러에 의해 거부 될 수 있습니다. 그러나 기존 코드에서는 그러한 경우를 찾지 못했습니다. 이상한 매크로를 정의하는 프로그램은 일반적으로이 프로그램에서 읽을 수 없으며 이러한 경우에는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd09cc5afdfaee26581cf1607b738318f0a04c65" translate="yes" xml:space="preserve">
          <source>Certain number ranges are unused in the Unicode standard and certain ranges are even deemed invalid. The most notable invalid range is 16#D800-16#DFFF, as the UTF-16 encoding does not allow for encoding of these numbers. This is possibly because the UTF-16 encoding standard, from the beginning, was expected to be able to hold all Unicode characters in one 16-bit entity, but was then extended, leaving a hole in the Unicode range to handle backward compatibility.</source>
          <target state="translated">특정 숫자 범위는 유니 코드 표준에서 사용되지 않으며 특정 범위는 유효하지 않은 것으로 간주됩니다. UTF-16 인코딩은 이러한 숫자의 인코딩을 허용하지 않으므로 가장 주목할만한 유효하지 않은 범위는 16 # D800-16 # DFFF입니다. 이것은 UTF-16 인코딩 표준이 처음부터 하나의 16 비트 엔터티에 모든 유니 코드 문자를 보유 할 수있을 것으로 예상되었지만 확장되어 역 호환성을 처리 할 수 ​​있도록 유니 코드 범위에 구멍을 남겼 기 때문일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d3c10b1e796e5a14360b76e7498544801074c9d" translate="yes" xml:space="preserve">
          <source>Certain rules are assigned precedence: each rule gets its precedence from the last terminal symbol mentioned in the right hand side of the rule. It is also possible to declare precedence for non-terminals, &quot;one level up&quot;. This is practical when an operator is overloaded (see also example 3 below).</source>
          <target state="translated">특정 규칙에 우선 순위가 지정됩니다. 각 규칙은 규칙의 오른쪽에 언급 된 마지막 터미널 기호에서 우선 순위를 갖습니다. 비 단말기에 우선 순위를 선언하는 것도 가능하다. 이것은 연산자에 과부하가 걸리면 실용적입니다 (아래 예 3 참조).</target>
        </trans-unit>
        <trans-unit id="3180f1c1f32b65006b85da77cea65d80026bae04" translate="yes" xml:space="preserve">
          <source>Certain test cases can be skipped, for example, if you know beforehand that a specific test case fails. The reason can be functionality that is not yet implemented, a bug that is known but not yet fixed, or some functionality that does not work or is not applicable on a specific platform.</source>
          <target state="translated">예를 들어 특정 테스트 사례가 실패한 것을 미리 알고 있으면 특정 테스트 사례를 건너 뛸 수 있습니다. 이유는 아직 구현되지 않은 기능, 알려졌지만 아직 수정되지 않은 버그 또는 작동하지 않거나 특정 플랫폼에 적용 할 수없는 일부 기능 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="999e5e7507ba94a1d7631bcf4c10334915590194" translate="yes" xml:space="preserve">
          <source>Certificate has been revoked.</source>
          <target state="translated">인증서가 해지되었습니다.</target>
        </trans-unit>
        <trans-unit id="0b6eec6ad7c2348607b9e4b41754fcd255f1c17a" translate="yes" xml:space="preserve">
          <source>Certificate is no longer valid as its expiration date has passed.</source>
          <target state="translated">만료 날짜가 지났으므로 인증서가 더 이상 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69417444a01d0d453bf4da2f0da7701629e5a93c" translate="yes" xml:space="preserve">
          <source>Certificate issuer name does not match the name of the issuer certificate in the chain.</source>
          <target state="translated">인증서 발급자 이름이 체인의 발급자 인증서 이름과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ab1754189014a0bc3712d551c0d0331beb34096" translate="yes" xml:space="preserve">
          <source>Certificate key is used in an invalid way according to the key-usage extension.</source>
          <target state="translated">키 사용 확장에 따라 인증서 키가 잘못 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="680c591d0862d9b1063d06f96b583acb5de4ebd3" translate="yes" xml:space="preserve">
          <source>Certificate was not signed by its issuer certificate in the chain.</source>
          <target state="translated">체인의 발급자 인증서로 인증서에 서명하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a9bc03e07fc3770d504d681b695e6fed1e572534" translate="yes" xml:space="preserve">
          <source>Certificate, required to have the basic constraints extension, does not have a basic constraints extension.</source>
          <target state="translated">기본 제약 조건 확장이 필요한 인증서에는 기본 제약 확장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="59b70cee319b6c2654812c5bf036b5f85bf580e7" translate="yes" xml:space="preserve">
          <source>Certificates and encrypted keys</source>
          <target state="translated">인증서 및 암호화 된 키</target>
        </trans-unit>
        <trans-unit id="cb6957d832f13c5b979dae257330fa5af06b6aa5" translate="yes" xml:space="preserve">
          <source>Certificates are issued by Certification Authorities (CAs) only. A handful of top CAs in the world issue root certificates. You can examine several of these certificates by clicking through the menus of your web browser.</source>
          <target state="translated">인증서는 인증 기관 (CA)에서만 발급합니다. 세계 최고의 소수의 CA가 루트 인증서를 발급합니다. 웹 브라우저의 메뉴를 클릭하여 이러한 인증서 중 몇 가지를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ce54cf97f873be5bebccb8e6c1d864f3b0db087" translate="yes" xml:space="preserve">
          <source>Certificates can be decoded as usual:</source>
          <target state="translated">평소와 같이 인증서를 해독 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92db73edd7e65422b778bdc23c60b96a0a395ba3" translate="yes" xml:space="preserve">
          <source>Certificates using weak (md5) digests may also cause problems in TLS. Although TLS 1.2 has an extension for specifying which type of signatures are accepted, and in FIPS mode the ssl application will use it properly, most TLS implementations ignore this extension and simply send whatever certificates they were configured with.</source>
          <target state="translated">약한 (md5) 다이제스트를 사용하는 인증서도 TLS에서 문제를 일으킬 수 있습니다. TLS 1.2에는 어떤 유형의 서명이 허용되는지 지정하는 확장 기능이 있으며 FIPS 모드에서 SSL 응용 프로그램이이를 올바르게 사용하지만 대부분의 TLS 구현은이 확장을 무시하고 구성된 인증서를 간단히 보냅니다.</target>
        </trans-unit>
        <trans-unit id="003f0acfc90ac4e6ff2e70f00b581c216de026fc" translate="yes" xml:space="preserve">
          <source>Certificates: RSA and ECDSA keys</source>
          <target state="translated">인증서 : RSA 및 ECDSA 키</target>
        </trans-unit>
        <trans-unit id="6a803e5d1d5407c176b6adb93c4ec23f4ef3c32f" translate="yes" xml:space="preserve">
          <source>Chakma</source>
          <target state="translated">Chakma</target>
        </trans-unit>
        <trans-unit id="5e052ac9c7fd6c9d46817ea48b907dbb7047ae81" translate="yes" xml:space="preserve">
          <source>Cham</source>
          <target state="translated">Cham</target>
        </trans-unit>
        <trans-unit id="7286ab5f88d6d6d36d7cd5f44676cfc60c5f9003" translate="yes" xml:space="preserve">
          <source>Change active trace pattern globally on all trace nodes.</source>
          <target state="translated">모든 추적 노드에서 전체적으로 활성 추적 패턴을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="3dd3f919f82791c255901c8a00754ab8bbb9e876" translate="yes" xml:space="preserve">
          <source>Change configuration parameter &lt;code&gt;lines&lt;/code&gt; with text-based presentation. Before the change, 10 lines are presented as follows:</source>
          <target state="translated">텍스트 기반 프리젠 테이션으로 구성 매개 변수 &lt;code&gt;lines&lt;/code&gt; 을 변경하십시오 . 변경하기 전에 다음과 같이 10 줄이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c48fe199607ed82477a3bc92a81b82652b6351b0" translate="yes" xml:space="preserve">
          <source>Change directory into the top directory of the Erlang/OTP source tree.</source>
          <target state="translated">디렉토리를 Erlang / OTP 소스 트리의 최상위 디렉토리로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="c23d69ee8e32cac337611be5b332231d09c49939" translate="yes" xml:space="preserve">
          <source>Change the &lt;code&gt;&lt;a href=&quot;#Callback%20Module&quot;&gt; &lt;strong&gt;callback module&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; for the running server. This can be done during any &lt;strong&gt;state transition&lt;/strong&gt;, whether it is a &lt;strong&gt;state change&lt;/strong&gt; or not, but it can</source>
          <target state="translated">실행중인 서버 의 &lt;code&gt;&lt;a href=&quot;#Callback%20Module&quot;&gt; &lt;strong&gt;callback module&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; 을 변경 합니다. 이는 &lt;strong&gt;상태 변경&lt;/strong&gt; 여부에 관계없이 모든 &lt;strong&gt;상태 전환&lt;/strong&gt; 중에 수행 할 수 있지만 &lt;strong&gt;&lt;/strong&gt; &lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72d924e009393c56b1a8ab6dc037cbebf547a8a1" translate="yes" xml:space="preserve">
          <source>Change the array size. If &lt;code&gt;Size&lt;/code&gt; is not a non-negative integer, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;. If the specified array has fixed size, also the resulting array has fixed size.</source>
          <target state="translated">배열 크기를 변경하십시오. &lt;code&gt;Size&lt;/code&gt; 가 음수가 아닌 정수가 아닌 경우 reason &lt;code&gt;badarg&lt;/code&gt; 로 호출이 실패합니다 . 지정된 배열의 크기가 고정 된 경우 결과 배열의 크기도 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="e7a199ef9b5d9d2c5eb0397d8b3600da554f2bdd" translate="yes" xml:space="preserve">
          <source>Change the mib server cache &lt;code&gt;age&lt;/code&gt; property.</source>
          <target state="translated">mib 서버 캐시 &lt;code&gt;age&lt;/code&gt; 특성을 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9751694da7f73924c4340976c6c033e21cb85c3" translate="yes" xml:space="preserve">
          <source>Change the mib server cache &lt;code&gt;gclimit&lt;/code&gt; property.</source>
          <target state="translated">mib 서버 캐시 &lt;code&gt;gclimit&lt;/code&gt; 특성을 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="e084ea3f5824de0afa0039d0b4e556968aed9ea5" translate="yes" xml:space="preserve">
          <source>Change the pid of the note-store process. This is used when the server re-starts the note_store (e.g. after a crach).</source>
          <target state="translated">메모 저장 프로세스의 pid를 변경하십시오. 서버가 note_store를 다시 시작할 때 사용됩니다 (예 : crach 뒤).</target>
        </trans-unit>
        <trans-unit id="f662c37eeb5824eb8f0f0ddeca89cbddc590f1f1" translate="yes" xml:space="preserve">
          <source>Change the table variable of last identifier used. Since multiple writes might occur at the same time this value may already have been changed by to an identifier larger that the one we got. In this case we can continue; otherwise, we need to change it to the identifier we got.</source>
          <target state="translated">마지막으로 사용한 식별자의 테이블 변수를 변경합니다. 여러 쓰기가 동시에 발생할 수 있으므로이 값은 이미 우리가 얻은 것보다 더 큰 식별자로 변경되었을 수 있습니다. 이 경우 계속할 수 있습니다. 그렇지 않으면 우리가 얻은 식별자로 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="341bfe617120dadefc9fcb3d22fe992700ca08f9" translate="yes" xml:space="preserve">
          <source>Change the verbosity of a running network interface process.</source>
          <target state="translated">실행중인 네트워크 인터페이스 프로세스의 세부 정보를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="02a9b0ba8593dbfae3c339a44c3092bcba3b8671" translate="yes" xml:space="preserve">
          <source>Change the verbosity of the network interface process.</source>
          <target state="translated">네트워크 인터페이스 프로세스의 상세 정도를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="ff6b6a8f375eca0b9e425530fea55372fbd3365c" translate="yes" xml:space="preserve">
          <source>Changes configuration for a TFTP daemon, server, or client process.</source>
          <target state="translated">TFTP 데몬, 서버 또는 클라이언트 프로세스의 구성을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="f16ea5025d3ec69b9225203c8d7c9acd2b6b84ea" translate="yes" xml:space="preserve">
          <source>Changes configuration for all TFTP daemon processes.</source>
          <target state="translated">모든 TFTP 데몬 프로세스의 구성을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="b32da3ba11eaa3c316e57b6c769c2daab761c896" translate="yes" xml:space="preserve">
          <source>Changes configuration for all TFTP server processes.</source>
          <target state="translated">모든 TFTP 서버 프로세스의 구성을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="8482f68d74594da4f2fd3456f32fb4a41a18bd39" translate="yes" xml:space="preserve">
          <source>Changes directory on remote host.</source>
          <target state="translated">원격 호스트의 디렉토리를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="d281ca109e76e6981bff271db8f62dc625be8e9c" translate="yes" xml:space="preserve">
          <source>Changes file information. Returns &lt;code&gt;ok&lt;/code&gt; if successful, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;. &lt;code&gt;FileInfo&lt;/code&gt; is a record &lt;code&gt;file_info&lt;/code&gt;, defined in the Kernel include file &lt;code&gt;file.hrl&lt;/code&gt;. Include the following directive in the module from which the function is called:</source>
          <target state="translated">파일 정보를 변경합니다. 성공하면 &lt;code&gt;ok&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;{error, Reason}&lt;/code&gt; 반환 합니다. &lt;code&gt;FileInfo&lt;/code&gt; 기록이다 &lt;code&gt;file_info&lt;/code&gt; 커널에 정의는, 파일 포함 &lt;code&gt;file.hrl&lt;/code&gt; 을 . 함수가 호출되는 모듈에 다음 지시문을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="c8cf0fa0868a33f5588f4a5b5170d1fcd8206179" translate="yes" xml:space="preserve">
          <source>Changes from RFC 3588</source>
          <target state="translated">RFC 3588의 변경 사항</target>
        </trans-unit>
        <trans-unit id="2185d4fc37add3289e7fc270b3db893f925e8611" translate="yes" xml:space="preserve">
          <source>Changes group of a file. See &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일 그룹을 변경합니다. &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="03a9c85cc9b1feb4f5518bdc78b94b4ea466deb3" translate="yes" xml:space="preserve">
          <source>Changes owner and group of a file. See &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일의 소유자와 그룹을 변경합니다. &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="405ee5678303f5e16347afc4ce653405b2bad93d" translate="yes" xml:space="preserve">
          <source>Changes owner of a file. See &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일 소유자를 변경합니다. &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="073a53e6a3aecdc3f5cd1a10f6cb02b7c344399c" translate="yes" xml:space="preserve">
          <source>Changes permissions of a file. See &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일의 권한을 변경합니다. &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bbd474b5d467916b0bc9e853a88f7bd55bc3b1dd" translate="yes" xml:space="preserve">
          <source>Changes the array size to that reported by &lt;code&gt;&lt;a href=&quot;#sparse_size-1&quot;&gt;sparse_size/1&lt;/a&gt;&lt;/code&gt;. If the specified array has fixed size, also the resulting array has fixed size.</source>
          <target state="translated">배열 크기를 &lt;code&gt;&lt;a href=&quot;#sparse_size-1&quot;&gt;sparse_size/1&lt;/a&gt;&lt;/code&gt; 에 의해보고 된 크기로 변경합니다 . 지정된 배열의 크기가 고정 된 경우 결과 배열의 크기도 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="42e8e1bf8b6b458b020c58f0d7cf5e61ace38032" translate="yes" xml:space="preserve">
          <source>Changes the callback module to &lt;code&gt;NewModule&lt;/code&gt; which will be used when calling all subsequent &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callbacks&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">콜백 모듈을 모든 후속 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callbacks&lt;/a&gt;&lt;/code&gt; 호출 할 때 사용할 &lt;code&gt;NewModule&lt;/code&gt; 로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="16b1291ef2ad9b4aec43c99d7e1e7cba0334731f" translate="yes" xml:space="preserve">
          <source>Changes the configuration parameters of the tool during runtime. Allowed parameters are &lt;code&gt;lines&lt;/code&gt;, &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;accumulate&lt;/code&gt;, and &lt;code&gt;sort&lt;/code&gt;.</source>
          <target state="translated">런타임 동안 도구의 구성 매개 변수를 변경합니다. 허용되는 매개 변수는 &lt;code&gt;lines&lt;/code&gt; , &lt;code&gt;interval&lt;/code&gt; , &lt;code&gt;accumulate&lt;/code&gt; 및 &lt;code&gt;sort&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="23248a37a3d67f459527886d08feb41c5630ae58" translate="yes" xml:space="preserve">
          <source>Changes the controlling process of &lt;code&gt;Z&lt;/code&gt; to &lt;code&gt;Pid&lt;/code&gt;, which must be a local process.</source>
          <target state="translated">&lt;code&gt;Z&lt;/code&gt; 의 제어 프로세스 를 &lt;code&gt;Pid&lt;/code&gt; 로 변경합니다 . 로컬 프로세스 여야합니다.</target>
        </trans-unit>
        <trans-unit id="b2bcd01e499841b88e35ebb5e2f95e2bb587e363" translate="yes" xml:space="preserve">
          <source>Changes the current key to another key. Works like &lt;code&gt;cd&lt;/code&gt;. The key can be specified as a relative path or as an absolute path, starting with &lt;code&gt;\.&lt;/code&gt;</source>
          <target state="translated">현재 키를 다른 키로 변경합니다. &lt;code&gt;cd&lt;/code&gt; 처럼 작동합니다 . 키는 &lt;code&gt;\.&lt;/code&gt; 시작하는 상대 경로 또는 절대 경로로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="81dc09e780693aae3b8c40d802b20f2d68ebb91f" translate="yes" xml:space="preserve">
          <source>Changes the engine id for a target in the &lt;code&gt;snmpTargetAddrTable&lt;/code&gt;. If notifications are sent as Inform requests to a target, its engine id must be set.</source>
          <target state="translated">&lt;code&gt;snmpTargetAddrTable&lt;/code&gt; 에서 대상의 엔진 ID를 변경합니다 . 알림을 대상에 알림 요청으로 보내면 엔진 ID를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="82f302677f18eacd93a3f042d9f2ce8910208cf5" translate="yes" xml:space="preserve">
          <source>Changes the file transfer type.</source>
          <target state="translated">파일 전송 유형을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="3c0a7cde930b2e8e077e329dea2a405f76520b4a" translate="yes" xml:space="preserve">
          <source>Changes the internal debug level of Mnesia. For details, see &lt;code&gt;&lt;a href=&quot;#configuration_parameters&quot;&gt;Section Configuration Parameters&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Mnesia의 내부 디버그 레벨을 변경합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#configuration_parameters&quot;&gt;Section Configuration Parameters&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27ead72514dc8602f8f4d4399518e861eb941dcb" translate="yes" xml:space="preserve">
          <source>Changes the log size of the Audit Trail Log. The application must be configured to use the audit trail log function. Please refer to disk_log(3) in Kernel Reference Manual for a description of how to change the log size.</source>
          <target state="translated">감사 추적 로그의 로그 크기를 변경합니다. 감사 추적 로그 기능을 사용하도록 애플리케이션을 구성해야합니다. 로그 크기를 변경하는 방법에 대한 설명은 커널 참조 설명서의 disk_log (3)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="edf0f52ab6ef854a099ffb48ffcc61abe0679fbd" translate="yes" xml:space="preserve">
          <source>Changes the minimum binary virtual heap size for the calling process.</source>
          <target state="translated">호출 프로세스의 최소 이진 가상 힙 크기를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="cd62e646ddb7759d296c1116e9d9b99ab0d39a03" translate="yes" xml:space="preserve">
          <source>Changes the minimum heap size for the calling process.</source>
          <target state="translated">호출 프로세스의 최소 힙 크기를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="02d140eecd4ba1c23ab94e5ac346ef7891994f87" translate="yes" xml:space="preserve">
          <source>Changes the modification and access times of a file. See &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일의 수정 및 액세스 시간을 변경합니다. &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="17bbc9dee276ef0c87d8c99c66cd5c924b4de477" translate="yes" xml:space="preserve">
          <source>Changes the modification and last access times of a file. See &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일의 수정 및 최종 액세스 시간을 변경합니다. &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="67cc7746cb125f758137fcc8fa2dcf5873b3c571" translate="yes" xml:space="preserve">
          <source>Changes the name of the rule emitted to &lt;code&gt;Target&lt;/code&gt;.</source>
          <target state="translated">생성 된 규칙의 이름을 &lt;code&gt;Target&lt;/code&gt; 으로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="193917ddeda5009fd378d28653931edd2c5181f2" translate="yes" xml:space="preserve">
          <source>Changes the permission for &lt;code&gt;Application&lt;/code&gt; to run at the current node. The application must be loaded using &lt;code&gt;load/1,2&lt;/code&gt; for the function to have effect.</source>
          <target state="translated">현재 노드에서 &lt;code&gt;Application&lt;/code&gt; 실행 권한을 변경 합니다. 함수가 적용 되려면 &lt;code&gt;load/1,2&lt;/code&gt; 를 사용하여 응용 프로그램을로드해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d8bf655f410bfe8330e2a69ecdd33a05eb4542f2" translate="yes" xml:space="preserve">
          <source>Changes the request limit.</source>
          <target state="translated">요청 한도를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="19a54b6d38821902fb1eacf32e853750b8478776" translate="yes" xml:space="preserve">
          <source>Changes the return value to &lt;code&gt;{Term, Used}&lt;/code&gt; where &lt;code&gt;Used&lt;/code&gt; is the number of bytes actually read from &lt;code&gt;Binary&lt;/code&gt;.</source>
          <target state="translated">리턴 값을 &lt;code&gt;{Term, Used}&lt;/code&gt; 로 변경합니다. 여기서 &lt;code&gt;Used&lt;/code&gt; 는 &lt;code&gt;Binary&lt;/code&gt; 에서 실제로 읽은 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="8da18ff00c71fe469f9ac5c3e80397ef5102bcce" translate="yes" xml:space="preserve">
          <source>Changes the run-time Audit Trail log type.</source>
          <target state="translated">런타임 감사 추적 로그 유형을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="fa6a33e3a50eb4e8a5a042f9d67e51582d656e1d" translate="yes" xml:space="preserve">
          <source>Changes the size of a binary &lt;code&gt;bin&lt;/code&gt;. The source binary can be read-only, in which case it is left untouched and a mutable copy is allocated and assigned to &lt;code&gt;*bin&lt;/code&gt;.</source>
          <target state="translated">이진 &lt;code&gt;bin&lt;/code&gt; 의 크기를 변경합니다 . 소스 바이너리는 읽기 전용 일 수 있으며,이 경우 그대로 유지되며 변경 가능한 사본이 할당되어 &lt;code&gt;*bin&lt;/code&gt; 에 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec2c109c81bf34df1be6bcc026fe60d99cef5d65" translate="yes" xml:space="preserve">
          <source>Changes the size of a registry.</source>
          <target state="translated">레지스트리 크기를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="fc6e6d129d793f579ed4c60aaaa171440d20a874" translate="yes" xml:space="preserve">
          <source>Changes the size of an open log. For a halt log, the size can always be increased, but it cannot be decreased to something less than the current file size.</source>
          <target state="translated">열린 로그의 크기를 변경합니다. 정지 로그의 경우 크기를 항상 늘릴 수 있지만 현재 파일 크기보다 작게 줄일 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="f82528ca1f8c8d719ac1700782b4a886e8ae597b" translate="yes" xml:space="preserve">
          <source>Changes the threshold, given as a float, for disk space utilization.</source>
          <target state="translated">디스크 공간 활용을 위해 부동 소수점으로 제공된 임계 값을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="498a56145635b463f4ddad568ba393252e6c5530" translate="yes" xml:space="preserve">
          <source>Changes the threshold, given as a float, for process memory allocation.</source>
          <target state="translated">프로세스 메모리 할당을 위해 부동 소수점으로 제공된 임계 값을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="d712fca6e04f8ba9e0d7ee48d15c49c58e523a70" translate="yes" xml:space="preserve">
          <source>Changes the threshold, given as a float, for system memory allocation.</source>
          <target state="translated">시스템 메모리 할당을 위해 부동 소수점으로 제공된 임계 값을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="d9d3dfce0dcea93c7310c068f8122230c707b3b0" translate="yes" xml:space="preserve">
          <source>Changes the time interval, given in minutes, for the periodic disk space check.</source>
          <target state="translated">주기적 디스크 공간 점검을위한 시간 간격 (분)을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="fb5aaf2a5afc4687e64062ff6b8607ab256e62d0" translate="yes" xml:space="preserve">
          <source>Changes the time interval, given in minutes, for the periodic memory check.</source>
          <target state="translated">주기적 메모리 점검을위한 시간 간격 (분)을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="f7648c6c0af0fc343ab1c979f02974a75f2a5ba0" translate="yes" xml:space="preserve">
          <source>Changes the timeout value, given in seconds, for memory checks.</source>
          <target state="translated">메모리 검사에 대한 시간 초과 값을 초 단위로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="fa3f83c43cceb3bbc4bbcac9c93e8ca54d05df5d" translate="yes" xml:space="preserve">
          <source>Changes the value of option &lt;code&gt;head&lt;/code&gt; or &lt;code&gt;head_func&lt;/code&gt; for an owner of a disk log.</source>
          <target state="translated">디스크 로그 소유자의 &lt;code&gt;head&lt;/code&gt; 또는 &lt;code&gt;head_func&lt;/code&gt; 옵션 값을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="c3716e44ad0eada2a249938e42128b73f10a2e61" translate="yes" xml:space="preserve">
          <source>Changes the value of option &lt;code&gt;notify&lt;/code&gt; for an owner of a disk log.</source>
          <target state="translated">디스크 로그 소유자 의 옵션 &lt;code&gt;notify&lt;/code&gt; 값을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="4ca015ff8fe3a6b3251a2977c4f3b1787fb7732a" translate="yes" xml:space="preserve">
          <source>Changes the working directory at the remote server to &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">원격 서버의 작업 디렉토리를 &lt;code&gt;Dir&lt;/code&gt; 로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="b86e20a82126b1241541a7af991aecce7c5f5203" translate="yes" xml:space="preserve">
          <source>Changes the working directory to &lt;code&gt;Dir&lt;/code&gt; for the local client.</source>
          <target state="translated">로컬 클라이언트 의 작업 디렉토리를 &lt;code&gt;Dir&lt;/code&gt; 로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="146996eed1440f5e90b1b4de2e12e077b5250c53" translate="yes" xml:space="preserve">
          <source>Changes working directory to &lt;code&gt;Dir&lt;/code&gt;, which can be a relative name, and then prints the name of the new working directory.</source>
          <target state="translated">작업 디렉토리를 &lt;code&gt;Dir&lt;/code&gt; 로 변경 합니다.이 이름은 상대 이름 일 수 있으며 새 작업 디렉토리의 이름을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b7c76b46af51ccf8d7f82302ce30470e158c167b" translate="yes" xml:space="preserve">
          <source>Changing Child Specifications</source>
          <target state="translated">하위 사양 변경</target>
        </trans-unit>
        <trans-unit id="a8a338fd17450383f174fd97f7c474118d4b1671" translate="yes" xml:space="preserve">
          <source>Changing Permissions for Reboot</source>
          <target state="translated">재부팅 권한 변경</target>
        </trans-unit>
        <trans-unit id="563a2787ce4f962782f878a83da7b186e82a5ab6" translate="yes" xml:space="preserve">
          <source>Changing Properties</source>
          <target state="translated">속성 변경</target>
        </trans-unit>
        <trans-unit id="c4ae19e16c08b52e2d4b044865ab21e4ec8819f8" translate="yes" xml:space="preserve">
          <source>Changing a zip archive is not supported. To add or remove a file from an archive, the whole archive must be recreated.</source>
          <target state="translated">Zip 아카이브 변경은 지원되지 않습니다. 아카이브에서 파일을 추가하거나 제거하려면 전체 아카이브를 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="266e726d9d7185cbcaf36e4f24317e4e232beefc" translate="yes" xml:space="preserve">
          <source>Changing an application configuration by updating the &lt;code&gt;env&lt;/code&gt; key in the &lt;code&gt;.app&lt;/code&gt; file is an instance of changing an application specification, see the previous section.</source>
          <target state="translated">&lt;code&gt;.app&lt;/code&gt; 파일 에서 &lt;code&gt;env&lt;/code&gt; 키를 업데이트하여 응용 프로그램 구성 변경은 응용 프로그램 사양을 변경하는 인스턴스입니다 (이전 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="312f68bb8dd2023932d8d7051ef64e029badbae2" translate="yes" xml:space="preserve">
          <source>Changing code for a program written in another programming language than Erlang, for example, a port program, is application-dependent and OTP provides no special support for it.</source>
          <target state="translated">포트 프로그램과 같이 Erlang 이외의 다른 프로그래밍 언어로 작성된 프로그램의 코드 변경은 응용 프로그램에 따라 다르며 OTP는 특별한 지원을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1a45efbe4b876cddaf41c842c638f7af4dac4f7" translate="yes" xml:space="preserve">
          <source>Changing code in running systems.</source>
          <target state="translated">실행중인 시스템에서 코드 변경</target>
        </trans-unit>
        <trans-unit id="89bc28f50275938cf54774b906a072619b7b5f17" translate="yes" xml:space="preserve">
          <source>Changing inbound binary and percent-encoding of URIs</source>
          <target state="translated">URI의 인바운드 이진 및 퍼센트 인코딩 변경</target>
        </trans-unit>
        <trans-unit id="0069b33f35595350f463876e0dc7cd74bd7efb23" translate="yes" xml:space="preserve">
          <source>Changing permission for reboot</source>
          <target state="translated">재부팅 권한 변경</target>
        </trans-unit>
        <trans-unit id="f26661251195e16b4f64b3465e31c5c61fc4f591" translate="yes" xml:space="preserve">
          <source>Changing the &lt;code&gt;Modules&lt;/code&gt; field of the child specification can affect the release handling process itself, as this field is used to identify which processes are affected when doing a synchronized code replacement.</source>
          <target state="translated">하위 스펙 의 &lt;code&gt;Modules&lt;/code&gt; 필드를 변경하면 동기화 된 코드 교체를 수행 할 때 영향을받는 프로세스를 식별하는 데 사용되므로 릴리스 처리 프로세스 자체에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2102ea37ff2bfb3fffd7cfdd154c334ce7f36524" translate="yes" xml:space="preserve">
          <source>Changing the callback module</source>
          <target state="translated">콜백 모듈 변경</target>
        </trans-unit>
        <trans-unit id="004667a156f84352e632a54416d314f1fab8c554" translate="yes" xml:space="preserve">
          <source>Changing the callback module does not affect the &lt;strong&gt;state transition&lt;/strong&gt; in any way, it only changes which module that handles the events. Be aware that all relevant callback functions in &lt;code&gt;NewModule&lt;/code&gt; such as the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;NewModule:code_change/4&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#Module:format_status-2&quot;&gt; NewModule:format_status/2 &lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt; NewModule:terminate/3 &lt;/a&gt;&lt;/code&gt; must be able to handle the state and data from the old module.</source>
          <target state="translated">콜백 모듈을 변경해도 &lt;strong&gt;상태 전환&lt;/strong&gt; 에는 영향을주지 않으며 이벤트를 처리하는 모듈 만 변경됩니다. &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;NewModule:code_change/4&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#Module:format_status-2&quot;&gt; NewModule:format_status/2 &lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt; NewModule:terminate/3 &lt;/a&gt;&lt;/code&gt; 와 같은 &lt;code&gt;NewModule&lt;/code&gt; 의 모든 관련 콜백 함수 는 이전 모듈의 상태 및 데이터를 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4d50c67fe4288961fc50484941baf88059761148" translate="yes" xml:space="preserve">
          <source>Changing the values can make a connection less secure. Do not change unless you know exactly what you are doing. If you do not understand the values then you are not supposed to change them.</source>
          <target state="translated">값을 변경하면 연결의 안전성이 떨어질 수 있습니다. 자신이하는 일을 정확히 알지 않는 한 변경하지 마십시오. 값을 이해하지 못하면 값을 변경하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="18e03e2a37ba37df713f9665ef752fb8b40fc1e8" translate="yes" xml:space="preserve">
          <source>Channels</source>
          <target state="translated">Channels</target>
        </trans-unit>
        <trans-unit id="0d3ea4e72253a3df4980efbacc5b0334f751af27" translate="yes" xml:space="preserve">
          <source>Channels come in the following three flavors:</source>
          <target state="translated">채널은 다음과 같은 세 가지 방식으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c7c394b0a636c8b1d30cc5034081e1f766db234d" translate="yes" xml:space="preserve">
          <source>Channels implemented with the &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt; ssh_client_channel&lt;/a&gt;&lt;/code&gt; behavior do not normally need to call this function as flow control is handled by the behavior. The behavior adjusts the window every time the callback &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt; handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt; returns after processing channel data.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt; ssh_client_channel&lt;/a&gt;&lt;/code&gt; 동작으로 구현 된 채널 은 흐름 제어가 동작에 의해 처리되므로 일반적으로이 함수를 호출 할 필요가 없습니다. 이 동작은 채널 데이터를 처리 한 후 콜백 &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt; handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt; 가 반환 될 때마다 창을 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="b08ff67d0c406c6c0b9f34b81df7ae485e892c7b" translate="yes" xml:space="preserve">
          <source>Channels implemented with the &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; behavior do not normally need to call this function as flow control is handled by the behavior. The behavior adjusts the window every time the callback &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt;handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt; returns after processing channel data.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; 비헤이비어로 구현 된 채널 은 흐름 제어가 비헤이비어에 의해 처리되므로 일반적으로이 함수를 호출 할 필요가 없습니다. 이 동작은 채널 데이터 처리 후 콜백 &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt;handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt; 가 반환 될 때마다 창을 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="a048c40435a29a09ca42526de00adf2b52f9c645" translate="yes" xml:space="preserve">
          <source>Channels implementing a shell and command execution on the server side are to handle the following messages that can be sent by client- channel processes.</source>
          <target state="translated">서버 측에서 셸 및 명령 실행을 구현하는 채널은 클라이언트 채널 프로세스에서 보낼 수있는 다음 메시지를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="699ab27900d549007002c44489fb26aaaf5d735a" translate="yes" xml:space="preserve">
          <source>Chapter 10: &quot;Definition of Agent Net if&quot; is a reference chapter, which describes the Agent Net if function in detail.</source>
          <target state="translated">10 장 : &quot;Agent Net if 정의&quot;는 Agent Net if 기능에 대해 자세히 설명하는 참조 장입니다.</target>
        </trans-unit>
        <trans-unit id="d34e1f73f52205aaa9e4a31eb68adc37cfabffb5" translate="yes" xml:space="preserve">
          <source>Chapter 11: &quot;Definition of Manager Net if&quot; is a reference chapter, which describes the Manager Net if function in detail.</source>
          <target state="translated">11 장 : &quot;Manager Net if의 정의&quot;는 Manager Net if 기능에 대해 자세히 설명하는 참조 장입니다.</target>
        </trans-unit>
        <trans-unit id="87eb31c5080d6da36ceb543fef1eea0ccd9ee696" translate="yes" xml:space="preserve">
          <source>Chapter 12: &quot;Advanced Agent Topics&quot; describes sub-agents, agent semantics, audit trail logging, and the consideration of distributed tables.</source>
          <target state="translated">12 장 : &quot;고급 에이전트 주제&quot;에서는 하위 에이전트, 에이전트 시맨틱, 감사 추적 로깅 및 분산 테이블 고려 사항에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fab3d91f87ac4c249e13bd0f9eaddaf278f8cb46" translate="yes" xml:space="preserve">
          <source>Chapter 2: &quot;Architecture&quot; describes the architecture and typical usage of the application.</source>
          <target state="translated">2 장 : &quot;아키텍처&quot;에서는 애플리케이션의 아키텍처와 일반적인 사용법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4dec362af8eb375be39ac35a314af9fde73a60c2" translate="yes" xml:space="preserve">
          <source>Chapter 2: &quot;Functional Description&quot; describes the features and operation of the SNMP development toolkit. It includes topics on Sub-agents and MIB loading, Internal MIBs, and Traps.</source>
          <target state="translated">2 장 : &quot;기능 설명&quot;에서는 SNMP 개발 툴킷의 기능과 작동에 대해 설명합니다. 서브 에이전트 및 MIB로드, 내부 MIB 및 트랩에 대한 주제가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="12470b53b219dfdab4f5572fb7579b7c8e09036a" translate="yes" xml:space="preserve">
          <source>Chapter 2: &quot;Tutorial&quot; provides a walk-through of the various parts of the application. The tutorial is based on &lt;code&gt;Jayson Vantuyl's&lt;/code&gt; article &lt;code&gt;http://souja.net/2009/04/making-sense-of-erlangs-event-tracer.html&lt;/code&gt;.</source>
          <target state="translated">2 장 : &quot;자습서&quot;는 응용 프로그램의 다양한 부분에 대한 연습을 제공합니다. 이 튜토리얼은 &lt;code&gt;Jayson Vantuyl's&lt;/code&gt; 기사 &lt;code&gt;http://souja.net/2009/04/making-sense-of-erlangs-event-tracer.html&lt;/code&gt; 을 기반으로 합니다.</target>
        </trans-unit>
        <trans-unit id="12fbe7a83897c503b79e7a85d14c7998722230ed" translate="yes" xml:space="preserve">
          <source>Chapter 2: &quot;Usage&quot; describes the architecture and typical usage of the application.</source>
          <target state="translated">2 장 : &quot;사용&quot;에서는 응용 프로그램의 아키텍처와 일반적인 사용법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f6750cafe062f4ffdbda997dc97d248a13107163" translate="yes" xml:space="preserve">
          <source>Chapter 3: &quot;Description&quot; describes the architecture and typical usage of the application.</source>
          <target state="translated">3 장 : &quot;설명&quot;에서는 응용 프로그램의 아키텍처와 일반적인 사용법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7071f2577cd1de4aee0fdf89922409a7b2f03ef6" translate="yes" xml:space="preserve">
          <source>Chapter 3: &quot;Examples&quot; gives some usage examples</source>
          <target state="translated">3 장 : &quot;예&quot;에서는 몇 가지 사용 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a799b757db57e54879af9f691a80d5a9a20be410" translate="yes" xml:space="preserve">
          <source>Chapter 3: &quot;Internal form and its encodings&quot; describes the internal form of Megaco/H.248 messages and its various encodings.</source>
          <target state="translated">3 장 : &quot;내부 형식 및 인코딩&quot;에서는 Megaco / H.248 메시지의 내부 형식과 다양한 인코딩에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6320c85576ee31d5c4d265a2793966bf19bacd19" translate="yes" xml:space="preserve">
          <source>Chapter 3: &quot;The MIB Compiler&quot; describes the features and the operation of the MIB compiler.</source>
          <target state="translated">3 장 : &quot;MIB 컴파일러&quot;에서는 MIB 컴파일러의 기능과 작동에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="54e610bf40a1883eb20d03a8c18d591dc86edf67" translate="yes" xml:space="preserve">
          <source>Chapter 4: &quot;Advanced examples&quot; gives some usage examples</source>
          <target state="translated">4 장 : &quot;고급 예제&quot;에서는 몇 가지 사용법 예제를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="25697c71de4f60fa3bac0727ea27496419a038db" translate="yes" xml:space="preserve">
          <source>Chapter 4: &quot;Running the application&quot; describes how to start and configure the application. Topics on how to debug the application are also included.</source>
          <target state="translated">4 장 &quot;응용 프로그램 실행&quot;에서는 응용 프로그램을 시작하고 구성하는 방법에 대해 설명합니다. 응용 프로그램을 디버깅하는 방법에 대한 주제도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="338e15bef9d6416cdf17b7925f4f2e350826208d" translate="yes" xml:space="preserve">
          <source>Chapter 4: &quot;Transport mechanisms&quot; describes how different mechanisms can be used to transport the Megaco/H.248 messages.</source>
          <target state="translated">4 장 : &quot;전송 메커니즘&quot;에서는 Megaco / H.248 메시지를 전송하는 데 다른 메커니즘을 사용하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="597f072185d84ad8cc17379cf8e56394d84907cb" translate="yes" xml:space="preserve">
          <source>Chapter 5: &quot;Debugging&quot; describes tracing and debugging.</source>
          <target state="translated">5 장 : &quot;디버깅&quot;에서는 추적 및 디버깅에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e7479821f3441c9357b1ca00c1e36bbd27cf97aa" translate="yes" xml:space="preserve">
          <source>Chapter 5: &quot;Definition of Agent Configuration Files&quot; is a reference chapter, which contains more detailed information about the agent configuration files.</source>
          <target state="translated">5 장 : &quot;에이전트 구성 파일 정의&quot;는 에이전트 구성 파일에 대한 자세한 정보가 포함 된 참조 장입니다.</target>
        </trans-unit>
        <trans-unit id="22020ea76e2aac433ecfad203219d4675b24e48f" translate="yes" xml:space="preserve">
          <source>Chapter 6: &quot;Definition of Manager Configuration Files&quot; is a reference chapter, which contains more detailed information about the manager configuration files.</source>
          <target state="translated">6 장 : &quot;Manager 구성 파일 정의&quot;는 Manager 구성 파일에 대한 자세한 정보가 포함 된 참조 장입니다.</target>
        </trans-unit>
        <trans-unit id="6cbf0856c33c9ecb975047c82a028295d945630c" translate="yes" xml:space="preserve">
          <source>Chapter 7: &quot;Agent Implementation Example&quot; describes how an MIB can be implemented with the SNMP Development Toolkit. Implementation examples are included.</source>
          <target state="translated">7 장 : &quot;에이전트 구현 예&quot;는 SNMP Development Toolkit으로 MIB를 구현하는 방법을 설명합니다. 구현 예가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="076f34961e0e1c7d0516f0f540ffe3d6973fc2a2" translate="yes" xml:space="preserve">
          <source>Chapter 8: &quot;Instrumentation Functions&quot; describes how instrumentation functions should be defined in Erlang for the different operations.</source>
          <target state="translated">8 장 : &quot;계측 기능&quot;에서는 Erlang에서 각기 다른 작업을 위해 계측 기능을 정의하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3d0f1ca136eed306def0b8a62ab682c35309444f" translate="yes" xml:space="preserve">
          <source>Chapter 9: &quot;Definition of Instrumentation Functions&quot; is a reference chapter which contains more detailed information about the instrumentation functions.</source>
          <target state="translated">9 장 : &quot;계측 기능 정의&quot;는 계측 기능에 대한 자세한 정보가 포함 된 참조 장입니다.</target>
        </trans-unit>
        <trans-unit id="d53a53309918b4def88f4690959360fcb2d765d6" translate="yes" xml:space="preserve">
          <source>Character &lt;code&gt;*&lt;/code&gt; is an optional return suppression character. It provides a method to specify a field that is to be omitted.</source>
          <target state="translated">문자 &lt;code&gt;*&lt;/code&gt; 는 선택적 리턴 억제 문자입니다. 생략 할 필드를 지정하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="10dc4e431a177556e53df60369a9fb871c823ce1" translate="yes" xml:space="preserve">
          <source>Character &lt;code&gt;~&lt;/code&gt; is written.</source>
          <target state="translated">문자 &lt;code&gt;~&lt;/code&gt; 가 쓰여집니다.</target>
        </trans-unit>
        <trans-unit id="d4b7b30647ed82c58a1589c60ae3f8434718542a" translate="yes" xml:space="preserve">
          <source>Character class, which matches any of the characters &lt;code&gt;abc...&lt;/code&gt;. Character ranges are specified by a pair of characters separated by a &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">모든 문자와 일치하는 문자 클래스, &lt;code&gt;abc...&lt;/code&gt; . 문자 범위는 &lt;code&gt;-&lt;/code&gt; 로 구분 된 문자 쌍으로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="f62e465bcd7cce1acdf714047daba90806ba8a22" translate="yes" xml:space="preserve">
          <source>Character codes 0-127</source>
          <target state="translated">문자 코드 0-127</target>
        </trans-unit>
        <trans-unit id="f3958ab5088befd2a44054cf1546542615ec1ba3" translate="yes" xml:space="preserve">
          <source>Character data can be combined from many sources, sometimes available in a mix of strings and binaries. Erlang has for long had the concept of &lt;code&gt;iodata&lt;/code&gt; or &lt;code&gt;iolist&lt;/code&gt;s, where binaries and lists can be combined to represent a sequence of bytes. In the same way, the Unicode-aware modules often allow for combinations of binaries and lists, where the binaries have characters encoded in UTF-8 and the lists contain such binaries or numbers representing Unicode code points:</source>
          <target state="translated">문자 데이터는 여러 소스에서 결합 할 수 있으며 때로는 문자열과 이진을 혼합하여 사용할 수 있습니다. Erlang은 오랫동안 &lt;code&gt;iodata&lt;/code&gt; 또는 &lt;code&gt;iolist&lt;/code&gt; 개념을 가지고 있었는데, 바이너리와 목록을 결합하여 일련의 바이트를 나타낼 수 있습니다. 같은 방식으로, 유니 코드 인식 모듈은 바이너리와리스트의 조합을 허용하는데, 바이너리에는 UTF-8로 인코딩 된 문자가 있고리스트에는 이러한 바이너리 나 유니 코드 코드 포인트를 나타내는 숫자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b4a9d35669803e9f5dc2e6f444b82b65bbd17f0" translate="yes" xml:space="preserve">
          <source>Character with hex code hh</source>
          <target state="translated">16 진 코드 hh가있는 문자</target>
        </trans-unit>
        <trans-unit id="a5cfa12fd688cc50f0a4a2e82bc4a14c913cc7d9" translate="yes" xml:space="preserve">
          <source>Character with hex code hhh..</source>
          <target state="translated">16 진 코드 hhh ..</target>
        </trans-unit>
        <trans-unit id="dbfc09d76b2751348746f5d0f726fbdddf63e42d" translate="yes" xml:space="preserve">
          <source>Character with hexadecimal representation XY</source>
          <target state="translated">16 진 표현 XY가있는 문자</target>
        </trans-unit>
        <trans-unit id="9fb138816ff7cd1b28dff9249e50ecaf7aafc8d8" translate="yes" xml:space="preserve">
          <source>Character with hexadecimal representation; X... is one or more hexadecimal characters</source>
          <target state="translated">16 진 표현이있는 문자; X ...는 하나 이상의 16 진 문자입니다.</target>
        </trans-unit>
        <trans-unit id="85b6e08c1a055049545eb425b3ef82c285b56bad" translate="yes" xml:space="preserve">
          <source>Character with octal code 0dd</source>
          <target state="translated">8 진 코드가 0dd 인 문자</target>
        </trans-unit>
        <trans-unit id="8c531bc02f5a4557270d589919d8d9d1c33dd84a" translate="yes" xml:space="preserve">
          <source>Character with octal code ddd, or back reference</source>
          <target state="translated">8 진 코드 ddd 또는 역 참조가있는 문자</target>
        </trans-unit>
        <trans-unit id="49c6c585b475f6a53492340855982d63e7868324" translate="yes" xml:space="preserve">
          <source>Character with octal representation XYZ, YZ or Z</source>
          <target state="translated">8 진 표현 XYZ, YZ 또는 Z가있는 문자</target>
        </trans-unit>
        <trans-unit id="4d8bbe4ae1dec6f4b66388f0e7417e43a5ee9841" translate="yes" xml:space="preserve">
          <source>Characters are translated to and from UTF-8 encoding before they are written to or read from the file. A file opened in this way can be readable using function &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt;, as long as no data stored on the file lies beyond the ISO Latin-1 range (0..255), but failure occurs if the data contains Unicode code points beyond that range. The file is best read with the functions in the Unicode aware module &lt;code&gt;io(3)&lt;/code&gt;.</source>
          <target state="translated">문자는 파일에 쓰거나 파일에서 읽기 전에 UTF-8 인코딩으로 변환됩니다. 파일에 저장된 데이터가 ISO Latin-1 범위 (0..255)를 초과하지 않는 한, &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하여이 방식으로 열린 파일을 읽을 수 있지만, 데이터에 유니 코드 코드 포인트를 초과하는 데이터가 있으면 실패가 발생합니다. 그 범위. 파일은 유니 코드 인식 모듈 &lt;code&gt;io(3)&lt;/code&gt; 의 함수로 가장 잘 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="9f41db94f3c3858526bf2d9c0e2c82c748eb1ddb" translate="yes" xml:space="preserve">
          <source>Characters in &lt;code&gt;Target&lt;/code&gt; special to make(1) are quoted.</source>
          <target state="translated">&lt;code&gt;Target&lt;/code&gt; (1)에 특수한 문자 가 인용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa1179541f8808f873db5c57ac0dd4861f2fed75" translate="yes" xml:space="preserve">
          <source>Characters in an atom</source>
          <target state="translated">원자의 문자</target>
        </trans-unit>
        <trans-unit id="483e7ec90fc725ea406b056294f684edfa8f5f09" translate="yes" xml:space="preserve">
          <source>Characters that are specified using octal or hexadecimal numbers are limited to certain values, as follows:</source>
          <target state="translated">8 진수 또는 16 진수를 사용하여 지정된 문자는 다음과 같이 특정 값으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="3b349ab83608db909f06144931bf465a076a5d43" translate="yes" xml:space="preserve">
          <source>Characters that can indicate line breaks are never treated in any special way when matching character classes, whatever line-ending sequence is in use, and whatever setting of options &lt;code&gt;PCRE_DOTALL&lt;/code&gt; and &lt;code&gt;PCRE_MULTILINE&lt;/code&gt; is used. A class such as [^a] always matches one of these characters.</source>
          <target state="translated">줄 바꿈을 나타낼 수있는 문자는 문자 클래스를 일치시킬 때, 행 끝 순서가 무엇이든, &lt;code&gt;PCRE_DOTALL&lt;/code&gt; 및 &lt;code&gt;PCRE_MULTILINE&lt;/code&gt; 옵션 설정 이 사용될 때 특별한 방식으로 처리되지 않습니다 . [^ a]와 같은 클래스는 항상 이러한 문자 중 하나와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2d1edf9c232be69d7a016a8a3ba2ae3e44f4f6a1" translate="yes" xml:space="preserve">
          <source>Characters whose value is less than 256 can be defined by either of the two syntaxes for \x. There is no difference in the way they are handled. For example, \xdc is exactly the same as \x{dc}.</source>
          <target state="translated">값이 256보다 작은 문자는 \ x에 대한 두 구문 중 하나에 의해 정의 될 수 있습니다. 처리 방식에는 차이가 없습니다. 예를 들어, \ xdc는 \ x {dc}와 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="2b130fd7c648fe09d9088ac10a3fa6dfa01ba612" translate="yes" xml:space="preserve">
          <source>Check if a message is a response to a &lt;code&gt;call&lt;/code&gt; request previously made by the calling process using &lt;code&gt;&lt;a href=&quot;#send_request-4&quot;&gt;erpc:send_request/4&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;RequestId&lt;/code&gt; should be the value returned from the previously made &lt;code&gt;erpc:send_request()&lt;/code&gt; call, and the corresponding response should not already have been received and handled to completion by &lt;code&gt;erpc:check_response()&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#receive_response-2&quot;&gt;erpc:receive_response()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#wait_response-2&quot;&gt;erpc:wait_response()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;Message&lt;/code&gt; is the message to check.</source>
          <target state="translated">메시지가 &lt;code&gt;&lt;a href=&quot;#send_request-4&quot;&gt;erpc:send_request/4&lt;/a&gt;&lt;/code&gt; 를 사용하여 이전에 호출 프로세스에서 만든 &lt;code&gt;call&lt;/code&gt; 요청에 대한 응답인지 확인합니다 . &lt;code&gt;RequestId&lt;/code&gt; 는 이전에 수행 한 &lt;code&gt;erpc:send_request()&lt;/code&gt; 호출 에서 반환 된 값이어야하며 해당 응답이 &lt;code&gt;erpc:check_response()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#receive_response-2&quot;&gt;erpc:receive_response()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#wait_response-2&quot;&gt;erpc:wait_response()&lt;/a&gt;&lt;/code&gt; 의해 이미 수신 및 처리되지 않아야합니다. . &lt;code&gt;Message&lt;/code&gt; 는 확인할 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="636269b21ec64e1b4c57781fd483b1f6eb014ef4" translate="yes" xml:space="preserve">
          <source>Check that you got the correct wx-config</source>
          <target state="translated">올바른 wx-config를 가지고 있는지 확인하십시오</target>
        </trans-unit>
        <trans-unit id="abcea80cce60fbe20f77494ee80ffc9af8a04be8" translate="yes" xml:space="preserve">
          <source>Check the PLT for consistency and rebuild it if it is not up-to-date.</source>
          <target state="translated">PLT의 일관성을 확인하고 최신이 아닌 경우 다시 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="268c1187a5d1ae2b90f5cdc9f4cb275c9ad70ab4" translate="yes" xml:space="preserve">
          <source>Check the releases again:</source>
          <target state="translated">릴리스를 다시 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="906cba3b4a7b65d13acff94d584d482a4041b4f6" translate="yes" xml:space="preserve">
          <source>Check the result codes from &lt;code&gt;ei_decode_-calls&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ei_decode_-calls&lt;/code&gt; 의 결과 코드를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3006d5fda96585cbeb13605068585873b6a87f1" translate="yes" xml:space="preserve">
          <source>Check to see if an Erlang process is alive:</source>
          <target state="translated">Erlang 프로세스가 활성화되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="20402d173d20fdbc8de1eb922d8ebb7baecddece" translate="yes" xml:space="preserve">
          <source>Check what data types the database assigned for the columns. Hopefully this is not a surprise, some times it can be! These are the data types that you should use if you want to do a parameterized query.</source>
          <target state="translated">데이터베이스가 열에 할당 한 데이터 유형을 확인하십시오. 잘만되면 이것은 놀라운 일이 아닙니다. 매개 변수화 된 쿼리를 수행하려는 경우 사용해야하는 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="35d0ee1ea7a80bd1369cdd8deff771169f1ff621" translate="yes" xml:space="preserve">
          <source>Check which releases there are in the system:</source>
          <target state="translated">시스템에 어떤 릴리스가 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a2b3a59adb81ffe32d8631c171b886f3d460360a" translate="yes" xml:space="preserve">
          <source>Checkpoints</source>
          <target state="translated">Checkpoints</target>
        </trans-unit>
        <trans-unit id="e87ce1926feddf058db26307093e491ce24b9536" translate="yes" xml:space="preserve">
          <source>Checkpoints are activated with the function &lt;code&gt;&lt;a href=&quot;mnesia#activate_checkpoint-1&quot;&gt;mnesia:activate_checkpoint(Args)&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; is a list of the following tuples:</source>
          <target state="translated">검사 점은 &lt;code&gt;&lt;a href=&quot;mnesia#activate_checkpoint-1&quot;&gt;mnesia:activate_checkpoint(Args)&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 활성화됩니다. 여기서 &lt;code&gt;Args&lt;/code&gt; 는 다음 튜플의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9f802420bf755ebc628b011ddcdcefbea605aaca" translate="yes" xml:space="preserve">
          <source>Checkpoints can be explicitly deactivated with the function &lt;code&gt;&lt;a href=&quot;mnesia#deactivate_checkpoint-1&quot;&gt;mnesia:deactivate_checkpoint(Name)&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Name&lt;/code&gt; is the name of an active checkpoint. This function returns &lt;code&gt;ok&lt;/code&gt; if successful or &lt;code&gt;{error, Reason}&lt;/code&gt; if there is an error. All tables in a checkpoint must be attached to at least one checkpoint retainer. The checkpoint is automatically deactivated by &lt;code&gt;Mnesia&lt;/code&gt;, when any table lacks a checkpoint retainer. This can occur when a node goes down or when a replica is deleted. Use arguments &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; (described in the following list) to control the degree of checkpoint retainer redundancy.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#deactivate_checkpoint-1&quot;&gt;mnesia:deactivate_checkpoint(Name)&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 검사 점을 명시 적으로 비활성화 할 수 있습니다 . 여기서 &lt;code&gt;Name&lt;/code&gt; 은 활성 검사 점의 이름입니다. 이 함수는 성공하면 &lt;code&gt;ok&lt;/code&gt; 를 반환 하고 오류가 있으면 &lt;code&gt;{error, Reason}&lt;/code&gt; 반환합니다. 체크 포인트의 모든 테이블은 하나 이상의 체크 포인트 보유자에 첨부되어야합니다. 테이블에 검사 점 보유자가없는 경우 검사 점은 &lt;code&gt;Mnesia&lt;/code&gt; 에 의해 자동으로 비활성화됩니다 . 노드가 다운되거나 복제본이 삭제 될 때 발생할 수 있습니다. 체크 포인트 보유자 리던던시의 정도를 제어 하려면 인수 &lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;max&lt;/code&gt; (다음 목록에서 설명)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bd05a7f92b1f124795301d9f37652056ff883754" translate="yes" xml:space="preserve">
          <source>Checks all the forms in a module for errors. It returns:</source>
          <target state="translated">모듈의 모든 양식에서 오류가 있는지 확인합니다. 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a856949551133f4d621c8f983c0ff72dd04c2c2b" translate="yes" xml:space="preserve">
          <source>Checks files for sortedness. If a file is not sorted, the first out-of-order element is returned. The first term on a file has position 1.</source>
          <target state="translated">파일이 정렬되어 있는지 확인합니다. 파일이 정렬되지 않은 경우 첫 번째 순서가 아닌 요소가 반환됩니다. 파일의 첫 번째 용어는 위치 1입니다.</target>
        </trans-unit>
        <trans-unit id="7ba4b1e2a4ab295c5008b5d16d7d26b47a038a4b" translate="yes" xml:space="preserve">
          <source>Checks for a UTF Byte Order Mark (BOM) in the beginning of a binary. If the supplied binary &lt;code&gt;Bin&lt;/code&gt; begins with a valid BOM for either UTF-8, UTF-16, or UTF-32, the function returns the encoding identified along with the BOM length in bytes.</source>
          <target state="translated">이진의 시작 부분에서 UTF 바이트 순서 표시 (BOM)를 점검합니다. 제공된 2 진 &lt;code&gt;Bin&lt;/code&gt; 이 UTF-8, UTF-16 또는 UTF-32에 대해 유효한 BOM으로 시작하면이 함수는 BOM 길이와 함께 식별 된 인코딩을 바이트 단위로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="510ec36114ebdc62e86252016e95f26f6d7a1f20" translate="yes" xml:space="preserve">
          <source>Checks for multiple usage of object identifiers and traps between MIBs.</source>
          <target state="translated">MIB 간 오브젝트 식별자 및 트랩의 다중 사용을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="747232dc3b591c50580e517e7cc803fb9e025a85" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;DateAndTime&lt;/code&gt; is a correct DateAndTime value, as specified in RFC2579. This function can be used in instrumentation functions to validate a DateAndTime value.</source>
          <target state="translated">RFC2579에 지정된대로 &lt;code&gt;DateAndTime&lt;/code&gt; 이 올바른 DateAndTime 값 인지 확인합니다 . 이 함수는 계측 함수에서 DateAndTime 값의 유효성을 검사하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95a79a074380e965f210f3b0d26fcbfdb4da8239" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;IssuerCert&lt;/code&gt; issued &lt;code&gt;Cert&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IssuerCert&lt;/code&gt; 가 &lt;code&gt;Cert&lt;/code&gt; 를 발행 했는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="2772e2a03c6bc7bbd4020bdc175792271c77180e" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;Module&lt;/code&gt; is loaded. If it is, &lt;code&gt;{file, Loaded}&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 이로드 되었는지 확인합니다 . 이 경우 &lt;code&gt;{file, Loaded}&lt;/code&gt; 가 반환되고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5818a0956c65d40a8ff10edf8906b485fbeb4030" translate="yes" xml:space="preserve">
          <source>Checks if a certificate is a fixed Diffie-Hellman certificate.</source>
          <target state="translated">인증서가 고정 Diffie-Hellman 인증서인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="8386578fed134d83c251c55e8ce2a02a7ef77dfe" translate="yes" xml:space="preserve">
          <source>Checks if a certificate is self-signed.</source>
          <target state="translated">인증서가 자체 서명되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="605d073b25cd13abdaa22621a8c142cdd64e0fde" translate="yes" xml:space="preserve">
          <source>Checks if a host key is trusted.</source>
          <target state="translated">호스트 키가 신뢰할 수 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d711ffc10e42ab11346653fdef9d9261168fbde9" translate="yes" xml:space="preserve">
          <source>Checks if a module can be interpreted. The module can be specified by its module name &lt;code&gt;Module&lt;/code&gt; or its source filename &lt;code&gt;File&lt;/code&gt;. If specified by a module name, the module is searched for in the code path.</source>
          <target state="translated">모듈을 해석 할 수 있는지 확인합니다. 모듈은 모듈 이름 &lt;code&gt;Module&lt;/code&gt; 또는 소스 파일 이름 &lt;code&gt;File&lt;/code&gt; 로 지정할 수 있습니다 . 모듈 이름으로 지정된 경우 코드 경로에서 모듈을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="6f37d2fd8311965e33637b99d11518d610b4fb8e" translate="yes" xml:space="preserve">
          <source>Checks if a port is a flex scanner port or not (useful when if a port exits).</source>
          <target state="translated">포트가 플렉스 스캐너 포트인지 확인합니다 (포트가 종료 될 때 유용함).</target>
        </trans-unit>
        <trans-unit id="272d82259d08ece025286e406b6b11b2f72fae79" translate="yes" xml:space="preserve">
          <source>Checks if a row in a table exists.</source>
          <target state="translated">테이블의 행이 존재하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="0ce83f3264ff58bca6cc35dfd8e19ea482e8523e" translate="yes" xml:space="preserve">
          <source>Checks if a table exists.</source>
          <target state="translated">테이블이 존재하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d18309113b1c9a8ffcfd3bdb7df082f48addf70f" translate="yes" xml:space="preserve">
          <source>Checks if a term is a valid compiled &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt;. The compiled match specification is an opaque datatype that &lt;strong&gt;cannot&lt;/strong&gt; be sent between Erlang nodes or be stored on disk. Any attempt to create an external representation of a compiled match specification results in an empty binary (&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">용어가 유효한 컴파일 된 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 인지 확인합니다 . 컴파일 된 일치 스펙은 Erlang 노드간에 전송되거나 디스크에 저장 될 &lt;strong&gt;수없는&lt;/strong&gt; 불투명 한 데이터 유형입니다 . 컴파일 된 일치 스펙의 외부 표현을 작성하려고하면 빈 이진 ( &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; )이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dc25eb5f990617d8a0bd7a27e851e73ad3bc8008" translate="yes" xml:space="preserve">
          <source>Checks if a term represent a valid compiled &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt;. A compiled match specifications is only valid on the Erlang node where it was compiled by calling &lt;code&gt;&lt;a href=&quot;#match_spec_compile-1&quot;&gt; match_spec_compile/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">용어가 유효한 컴파일 된 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 나타내는 지 확인합니다 . 컴파일 된 일치 사양은 &lt;code&gt;&lt;a href=&quot;#match_spec_compile-1&quot;&gt; match_spec_compile/1&lt;/a&gt;&lt;/code&gt; 을 호출하여 컴파일 된 Erlang 노드에서만 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="49fe5d38c23822c89b1d14265222013e7aa623f5" translate="yes" xml:space="preserve">
          <source>Checks if the array has fixed size. Returns &lt;code&gt;true&lt;/code&gt; if the array is fixed, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">배열의 크기가 고정되어 있는지 확인합니다. 배열이 고정되어 있으면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="6528fc754f99e98b06bda36322e569db3f8f1fc0" translate="yes" xml:space="preserve">
          <source>Checks if the node local process identified by &lt;code&gt;Pid&lt;/code&gt; executes old code for &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 로 식별 된 노드 로컬 프로세스 가 &lt;code&gt;Module&lt;/code&gt; 에 대한 이전 코드를 실행 하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="71e47cd564a205cb1bf9ca547a2026f1c46fec4f" translate="yes" xml:space="preserve">
          <source>Checks if the required configuration is available and gives it a name. The semantics for &lt;code&gt;Required&lt;/code&gt; is the same as in &lt;code&gt;&lt;a href=&quot;#require-1&quot;&gt;ct:require/1&lt;/a&gt;&lt;/code&gt; except that a list of &lt;code&gt;SubKey&lt;/code&gt;s cannot be specified.</source>
          <target state="translated">필요한 구성이 사용 가능한지 확인하고 이름을 지정하십시오. &lt;code&gt;Required&lt;/code&gt; 의 의미 는 &lt;code&gt;SubKey&lt;/code&gt; 목록을 지정할 수 없다는 점을 제외하고 는 &lt;code&gt;&lt;a href=&quot;#require-1&quot;&gt;ct:require/1&lt;/a&gt;&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="428578d9af241c74e1a7a32730a10d5366082c85" translate="yes" xml:space="preserve">
          <source>Checks if the required configuration is available. Arbitrarily deep tuples can be specified as &lt;code&gt;Required&lt;/code&gt;. Only the last element of the tuple can be a list of &lt;code&gt;SubKey&lt;/code&gt;s.</source>
          <target state="translated">필요한 구성이 사용 가능한지 확인합니다. 임의로 깊은 튜플을 &lt;code&gt;Required&lt;/code&gt; 로 지정할 수 있습니다 . 튜플의 마지막 요소 만이 &lt;code&gt;SubKey&lt;/code&gt; 목록이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec238f5cb03703ee0f12bade417608420f9de09c" translate="yes" xml:space="preserve">
          <source>Checks if the specified version &lt;code&gt;Vsn&lt;/code&gt; of the release can be installed. The release must not have status &lt;code&gt;current&lt;/code&gt;. Issues warnings if &lt;code&gt;relup&lt;/code&gt; file or &lt;code&gt;sys.config&lt;/code&gt; is not present. If &lt;code&gt;relup&lt;/code&gt; file is present, its contents are checked and &lt;code&gt;{error,Reason}&lt;/code&gt; is returned if an error is found. Also checks that all required applications are present and that all new code can be loaded; &lt;code&gt;{error,Reason}&lt;/code&gt; is returned if an error is found.</source>
          <target state="translated">지정된 버전 의 릴리스 &lt;code&gt;Vsn&lt;/code&gt; 을 설치할 수 있는지 확인합니다. 릴리스 상태가 &lt;code&gt;current&lt;/code&gt; 상태가 아니어야합니다 . &lt;code&gt;relup&lt;/code&gt; 파일 또는 &lt;code&gt;sys.config&lt;/code&gt; 가없는 경우 경고를 발행 합니다 . 경우 &lt;code&gt;relup&lt;/code&gt; 의 파일이 존재하고, 그 내용을 확인하고 &lt;code&gt;{error,Reason}&lt;/code&gt; 오류가 발견되면 반환됩니다. 또한 필요한 모든 응용 프로그램이 있고 모든 새 코드를로드 할 수 있는지 확인합니다. 오류가 발견되면 &lt;code&gt;{error,Reason}&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="479a9580343413c1f22bd06f4593b79fb04b0a75" translate="yes" xml:space="preserve">
          <source>Checks if the specified year is a leap year.</source>
          <target state="translated">지정된 연도가 윤년인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="078e47111a5ec4795ece814100ad93da9a091cfb" translate="yes" xml:space="preserve">
          <source>Checks if the user key is authorized.</source>
          <target state="translated">사용자 키가 인증되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="ff7d8e386c89192aae77ae12e3d1fd328088412c" translate="yes" xml:space="preserve">
          <source>Checks the validity of the configuration options before saving them in the internal database. This function can also have a side effect, that is, setup of necessary extra resources implied by the configuration option. It can also resolve possible dependencies among configuration options by changing the value of the option. This function only needs clauses for the options implemented by this particular callback module.</source>
          <target state="translated">내부 데이터베이스에 저장하기 전에 구성 옵션의 유효성을 확인하십시오. 이 기능은 또한 부작용, 즉 구성 옵션에 의해 암시 된 필요한 추가 자원의 설정을 가질 수 있습니다. 옵션 값을 변경하여 구성 옵션 간의 가능한 종속성을 해결할 수도 있습니다. 이 함수는이 특정 콜백 모듈에 의해 구현 된 옵션에 대한 절만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f318de51ea171b0f11fe8ffcba324d6cb2f56901" translate="yes" xml:space="preserve">
          <source>Checks whether the given distribution point matches the Issuing Distribution Point of the CRL, as described in RFC 5280. If the CRL doesn't have an Issuing Distribution Point extension, the distribution point always matches.</source>
          <target state="translated">RFC 5280에 설명 된대로 지정된 배포 지점이 CRL의 발급 배포 지점과 일치하는지 확인합니다. CRL에 발급 배포 지점 확장이 없으면 배포 지점이 항상 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6927568c692c1534ead0f5a190223a7149662ac5" translate="yes" xml:space="preserve">
          <source>Cherokee</source>
          <target state="translated">Cherokee</target>
        </trans-unit>
        <trans-unit id="135e7ebc010b592ec029e827d5bc3670e96d3552" translate="yes" xml:space="preserve">
          <source>Child processes added using &lt;code&gt;start_child/2&lt;/code&gt; behave in the same way as the other child processes, with the an important exception: if a supervisor dies and is recreated, then all child processes that were dynamically added to the supervisor are lost.</source>
          <target state="translated">&lt;code&gt;start_child/2&lt;/code&gt; 를 사용하여 추가 된 하위 프로세스 는 중요한 예외를 제외하고 다른 하위 프로세스와 동일한 방식으로 작동합니다. 관리자가 사망하여 다시 작성하면 관리자에 동적으로 추가 된 모든 하위 프로세스가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="d31165313a669b6455ea6e9ad085bc20f3afad95" translate="yes" xml:space="preserve">
          <source>Child processes can be added or deleted, but this is not handled automatically. Instructions must be given by in the &lt;code&gt;.appup&lt;/code&gt; file.</source>
          <target state="translated">자식 프로세스는 추가하거나 삭제할 수 있지만 자동으로 처리되지는 않습니다. 지침은 &lt;code&gt;.appup&lt;/code&gt; 파일 에서 제공해야 합니다.</target>
        </trans-unit>
        <trans-unit id="6ab10a3f0f32c3f2675ecf809a38ba27ac8a5f1a" translate="yes" xml:space="preserve">
          <source>Choice of encoding rules. If omitted, &lt;code&gt;ber&lt;/code&gt; is the default.</source>
          <target state="translated">인코딩 규칙 선택 생략하면 &lt;code&gt;ber&lt;/code&gt; 가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="7f3ea2b24209a266dcef3e5a9bb60cc369d1de87" translate="yes" xml:space="preserve">
          <source>Choose TLS or DTLS protocol for the transport layer security. Defaults to &lt;code&gt;tls&lt;/code&gt; Introduced in OTP 20, DTLS support is considered experimental in this release. Other transports than UDP are not yet supported.</source>
          <target state="translated">전송 계층 보안을 위해 TLS 또는 DTLS 프로토콜을 선택하십시오. 기본값은 &lt;code&gt;tls&lt;/code&gt; 입니다. OTP 20에 도입 된이 릴리스에서는 DTLS 지원이 실험적인 것으로 간주됩니다. UDP 이외의 다른 전송은 아직 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c31c4041fea7dcf570fd6e4cf1e2c962d365bbbf" translate="yes" xml:space="preserve">
          <source>Choose TLS or DTLS protocol for the transport layer security. Defaults to &lt;code&gt;tls&lt;/code&gt;. For DTLS other transports than UDP are not yet supported.</source>
          <target state="translated">전송 계층 보안을 위해 TLS 또는 DTLS 프로토콜을 선택하십시오. 기본값은 &lt;code&gt;tls&lt;/code&gt; 입니다. DTLS의 경우 UDP 이외의 다른 전송은 아직 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25f5d4d9f2caa81d094ad75fec450f1a06c95420" translate="yes" xml:space="preserve">
          <source>Choose to handle only the desired ones.</source>
          <target state="translated">원하는 항목 만 처리하도록 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="46b52861d4608446563acf9a958bc3592901aff0" translate="yes" xml:space="preserve">
          <source>Choosing the Applications or Modules</source>
          <target state="translated">응용 프로그램 또는 모듈 선택</target>
        </trans-unit>
        <trans-unit id="ee581d45d9fc1d0520325bee52149114d648b385" translate="yes" xml:space="preserve">
          <source>Chunk continuation returned by &lt;code&gt;chunk/2,3&lt;/code&gt;, &lt;code&gt;bchunk/2,3&lt;/code&gt;, or &lt;code&gt;chunk_step/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;chunk/2,3&lt;/code&gt; , &lt;code&gt;bchunk/2,3&lt;/code&gt; 또는 &lt;code&gt;chunk_step/3&lt;/code&gt; 에서 청크 연속을 리턴했습니다 .</target>
        </trans-unit>
        <trans-unit id="e4ba655b15f106275903bcb76ff0e9f9a248da7f" translate="yes" xml:space="preserve">
          <source>Chunk data can be returned as binaries or as compound terms. Compound terms are returned when chunks are referenced by names (atoms) rather than identifiers (strings). The recognized names and the corresponding identifiers are as follows:</source>
          <target state="translated">청크 데이터는 이진 또는 복합 용어로 반환 될 수 있습니다. 청크가 식별자 (문자열)가 아닌 이름 (원자)으로 참조 될 때 복합 용어가 리턴됩니다. 인식되는 이름과 해당 식별자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6764e5053e3fe95b1f7c11980b37b710d2758df5" translate="yes" xml:space="preserve">
          <source>Cipher and Mode</source>
          <target state="translated">암호 및 모드</target>
        </trans-unit>
        <trans-unit id="30642178bcc449614b9f83d55814b1527c22a7a9" translate="yes" xml:space="preserve">
          <source>CipherText</source>
          <target state="translated">CipherText</target>
        </trans-unit>
        <trans-unit id="bc7425233d01ba6a7be602ba1752667ca73eae3a" translate="yes" xml:space="preserve">
          <source>Ciphers known by the CRYPTO application when using the &lt;code&gt;new API&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new API&lt;/code&gt; 사용할 때 CRYPTO 응용 프로그램에서 알고있는 암호 .</target>
        </trans-unit>
        <trans-unit id="3c0c4fa76aea2937a0998c363ea02686cbd6a9ee" translate="yes" xml:space="preserve">
          <source>Ciphers known by the CRYPTO application when using the &lt;code&gt;old API&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;old API&lt;/code&gt; 사용할 때 CRYPTO 애플리케이션에서 알고있는 암호 .</target>
        </trans-unit>
        <trans-unit id="c823bc9e6919d1a6ec1ee621618d405b63ae02b7" translate="yes" xml:space="preserve">
          <source>Ciphers with AEAD - cipher_aead()</source>
          <target state="translated">AEAD를 사용하는 암호-cipher_aead ()</target>
        </trans-unit>
        <trans-unit id="52e903786f3aa5e38839b6ced188e00a2978392f" translate="yes" xml:space="preserve">
          <source>Ciphers with an IV - cipher_iv()</source>
          <target state="translated">IV가있는 암호-cipher_iv ()</target>
        </trans-unit>
        <trans-unit id="edf572b5e6cd15e9e8481efe4e07ee81f9831714" translate="yes" xml:space="preserve">
          <source>Ciphers without an IV - cipher_no_iv()</source>
          <target state="translated">IV가없는 암호-cipher_no_iv ()</target>
        </trans-unit>
        <trans-unit id="6f21a899bfeb7fda2cfbbe7b1fc7403ccdab3ded" translate="yes" xml:space="preserve">
          <source>Ciphers, new API</source>
          <target state="translated">암호, 새 API</target>
        </trans-unit>
        <trans-unit id="8c8c272e11f799bb1c36704a8bd1038391e72fd2" translate="yes" xml:space="preserve">
          <source>Ciphers, old API</source>
          <target state="translated">암호, 이전 API</target>
        </trans-unit>
        <trans-unit id="fa89c2516f6a5145ca57d8e994ab91799551cef7" translate="yes" xml:space="preserve">
          <source>Ciphers: all cipher suites are supported</source>
          <target state="translated">암호 : 모든 암호 제품군이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6ff9b96266db1f3dd7beca013ae70083f5bd259c" translate="yes" xml:space="preserve">
          <source>Circular logs wrap too quickly so that important data is overwritten.</source>
          <target state="translated">순환 로그가 너무 빨리 랩핑되어 중요한 데이터를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="d12a819b1aae084ceb5aef6add0b54bb3383e602" translate="yes" xml:space="preserve">
          <source>Circumflex (only at the start)</source>
          <target state="translated">서 컴플렉스 (시작시에만)</target>
        </trans-unit>
        <trans-unit id="581342987169d6671fc5bf0cc93afadd1b835b06" translate="yes" xml:space="preserve">
          <source>Circumflex needs not to be the first character of the pattern if some alternatives are involved, but it is to be the first thing in each alternative in which it appears if the pattern is ever to match that branch. If all possible alternatives start with a circumflex, that is, if the pattern is constrained to match only at the start of the subject, it is said to be an &quot;anchored&quot; pattern. (There are also other constructs that can cause a pattern to be anchored.)</source>
          <target state="translated">Circumflex는 일부 대안이 포함 된 경우 패턴의 첫 번째 문자 일 필요는 없지만 패턴이 해당 분기와 일치하는 경우 각 대안에서 첫 번째 문자가되어야합니다. 가능한 모든 대안이 곡절로 시작하는 경우, 즉 패턴이 피사체의 시작 부분에서만 일치하도록 제한되면 &quot;고정&quot;패턴이라고합니다. 패턴을 고정시킬 수있는 다른 구성도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c55dd6a054b7094ae3dc1abafba45b8010c44542" translate="yes" xml:space="preserve">
          <source>Circumstances That Force Copying</source>
          <target state="translated">복제를 강요하는 상황</target>
        </trans-unit>
        <trans-unit id="9d200e05d2a156deec0beba2b22e83cff255bcb3" translate="yes" xml:space="preserve">
          <source>Claim an intermediate CA in the chain as trusted. TLS then performs &lt;code&gt;public_key:pkix_path_validation/3&lt;/code&gt; with the selected CA as trusted anchor and the rest of the chain.</source>
          <target state="translated">체인에서 중간 CA를 신뢰할 수있는 것으로 주장하십시오. 그런 다음 TLS 는 선택한 CA를 신뢰할 수있는 앵커로 사용하고 나머지 체인 은 &lt;code&gt;public_key:pkix_path_validation/3&lt;/code&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="39de48c8fa760feda5802b521d8bf939316bf4c2" translate="yes" xml:space="preserve">
          <source>Class AVP</source>
          <target state="translated">클래스 AVP</target>
        </trans-unit>
        <trans-unit id="6eacfebc1c0925b3f9fb95e3de34cdc474ca5242" translate="yes" xml:space="preserve">
          <source>Clean start of lttng in a bash shell.</source>
          <target state="translated">bash 쉘에서 lttng의 클린 시작.</target>
        </trans-unit>
        <trans-unit id="9a4a1562053eb1e1218a691a6c953f8f4062d055" translate="yes" xml:space="preserve">
          <source>Clear the event table.</source>
          <target state="translated">이벤트 테이블을 지우십시오.</target>
        </trans-unit>
        <trans-unit id="cf79802203160fb2e047023927c66043f0069869" translate="yes" xml:space="preserve">
          <source>Clear the hosts table.</source>
          <target state="translated">호스트 테이블을 지우십시오.</target>
        </trans-unit>
        <trans-unit id="9bff2b01c2e7f297768e7e1de9b32b6dece5d32c" translate="yes" xml:space="preserve">
          <source>Clear the internal counters. Same as &lt;code&gt;lcnt:clear(Node)&lt;/code&gt;.</source>
          <target state="translated">내부 카운터를 비 웁니다. &lt;code&gt;lcnt:clear(Node)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2b2367a410d59fa17678db3463ba5a821481dc69" translate="yes" xml:space="preserve">
          <source>Clear the list of recorded nameservers (primary and secondary).</source>
          <target state="translated">기록 된 이름 서버 목록을 지우십시오 (1 차 및 2 차).</target>
        </trans-unit>
        <trans-unit id="369fb44362e0de877ecb493ee42cb0dc0bd0e79c" translate="yes" xml:space="preserve">
          <source>Clear the list of search domains.</source>
          <target state="translated">검색 도메인 목록을 지우십시오.</target>
        </trans-unit>
        <trans-unit id="5780206257275a6d0e675772efcba6937710072a" translate="yes" xml:space="preserve">
          <source>Clearly the time-outs are for implementing fault tolerance, not to keep hard real-time promises. The &lt;code&gt;_tmo&lt;/code&gt; functions are for detecting non-responsive peers and to avoid blocking on socket operations.</source>
          <target state="translated">타임 아웃은 분명히 확실한 실시간 약속을 지키지 않고 내결함성을 구현하기위한 것입니다. &lt;code&gt;_tmo&lt;/code&gt; 의 기능은 응답하지 않는 동료를 감지하고 소켓 작업에 막지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="b8b55894a3a573e9c169f2784eaa3824d8dc1f41" translate="yes" xml:space="preserve">
          <source>Clearly, &lt;code&gt;get_chars&lt;/code&gt; and &lt;code&gt;get_line&lt;/code&gt; could be implemented with the &lt;code&gt;get_until&lt;/code&gt; request (and indeed they were originally), but demands for efficiency have made these additions necessary.</source>
          <target state="translated">분명히 &lt;code&gt;get_chars&lt;/code&gt; 및 &lt;code&gt;get_line&lt;/code&gt; 은 &lt;code&gt;get_until&lt;/code&gt; 요청 (실제로 원래 요청) 으로 구현 될 수 있지만 효율성에 대한 요구로 인해 이러한 추가가 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="104ddb5596b2b3c6bb809b4e7942686129ee7afb" translate="yes" xml:space="preserve">
          <source>Clearly, the second &lt;code&gt;io:format/2&lt;/code&gt; gives undesired output, as the UTF-8 binary is not in &lt;code&gt;latin1&lt;/code&gt;. For backward compatibility, the non-prefixed control character &lt;code&gt;s&lt;/code&gt; expects bytewise-encoded ISO Latin-1 characters in binaries and lists containing only code points &amp;lt; 256.</source>
          <target state="translated">UTF-8 바이너리가 &lt;code&gt;latin1&lt;/code&gt; 이 아니기 때문에 두 번째 &lt;code&gt;io:format/2&lt;/code&gt; 는 바람직하지 않은 출력을 제공합니다 . 이전 버전과의 호환성을 위해 비 접두어 제어 문자 는 바이트 &lt;code&gt;s&lt;/code&gt; 로 인코딩 된 ISO Latin-1 문자를 바이너리로, 코드 포인트 &amp;lt;256 만 포함하는 목록을 기대합니다.</target>
        </trans-unit>
        <trans-unit id="ac68fc3d2a1c66a24efacfe356996e3f36da43ed" translate="yes" xml:space="preserve">
          <source>Clearly, the text is badly formatted. Instead of formatting this paragraph line by line, let's try &lt;code&gt;erlang-fill-paragraph&lt;/code&gt; by pressing &lt;strong&gt;&lt;code&gt;M-q&lt;/code&gt;&lt;/strong&gt;. The result is:</source>
          <target state="translated">분명히 텍스트의 형식이 잘못되었습니다. 이 단락을 한 줄씩 형식화하는 대신 &lt;strong&gt; &lt;code&gt;M-q&lt;/code&gt; &lt;/strong&gt; 를 눌러 &lt;code&gt;erlang-fill-paragraph&lt;/code&gt; 를 시도해보십시오 . 결과는 다음과 같습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="86f0101226f5f81bb0f27692ae9b01618069c017" translate="yes" xml:space="preserve">
          <source>Clears a node from the list of traced nodes. Subsequent calls to &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; will not consider that node, but tracing already activated on the node will continue to be in effect.</source>
          <target state="translated">추적 된 노드 목록에서 노드를 지 웁니다. &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; 에 대한 후속 호출 은 해당 노드를 고려하지 않지만 노드에서 이미 활성화 된 추적은 계속 유효합니다.</target>
        </trans-unit>
        <trans-unit id="0b13ce8b44b6644dd7e70d2aa9ea4a770cfcfe42" translate="yes" xml:space="preserve">
          <source>Clears all flags.</source>
          <target state="translated">모든 플래그를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="467456a156c8089790f8fcb07286226580f312c2" translate="yes" xml:space="preserve">
          <source>Clears all tracing from the node and starts a new &lt;code&gt;fprof&lt;/code&gt; trace. Either option &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;stop&lt;/code&gt; must be specified, but not both.</source>
          <target state="translated">노드에서 모든 추적을 지우고 새 &lt;code&gt;fprof&lt;/code&gt; 추적을 시작합니다 . 옵션 &lt;code&gt;start&lt;/code&gt; 또는 &lt;code&gt;stop&lt;/code&gt; 를 지정해야하지만 둘 다 지정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2442f3d1d0666c552ddd200f6f80efa37ba1d36f" translate="yes" xml:space="preserve">
          <source>Clears information about processes executing interpreted code by removing all information about terminated processes.</source>
          <target state="translated">종료 된 프로세스에 대한 모든 정보를 제거하여 해석 된 코드를 실행하는 프로세스에 대한 정보를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="19ca408ce500ce988f93c1127be6072ab57dbf07" translate="yes" xml:space="preserve">
          <source>Clears the associated comments of &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 의 연관된 주석을 지 웁니다 .</target>
        </trans-unit>
        <trans-unit id="ca93ac6b0dd536d4e5f2ea8448f979122bed328d" translate="yes" xml:space="preserve">
          <source>Clears the freelist, where blocks are placed when they are released by &lt;code&gt;erl_free_term()&lt;/code&gt; and &lt;code&gt;erl_free_compound()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erl_free_term()&lt;/code&gt; 및 &lt;code&gt;erl_free_compound()&lt;/code&gt; 의해 해제 될 때 블록이 배치되는 자유 목록을 지 웁니다 .</target>
        </trans-unit>
        <trans-unit id="bf95008d3bf29f6ae931c4a1447def2c26138965" translate="yes" xml:space="preserve">
          <source>Clears the internal lock statistics from the runtime system. This does not clear the data on the server only on runtime system. All counters for static locks are zeroed, all dynamic locks currently alive are zeroed and all saved locks now destroyed are removed. It also resets the duration timer.</source>
          <target state="translated">런타임 시스템에서 내부 잠금 통계를 지 웁니다. 런타임 시스템에서만 서버의 데이터를 지우지는 않습니다. 정적 잠금에 대한 모든 카운터가 제로화되고 현재 활성화 된 모든 동적 잠금이 제로화되고 현재 저장된 모든 잠금이 제거됩니다. 지속 시간 타이머도 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="f984b760bad5d198926e4961e47fdf78889ec801" translate="yes" xml:space="preserve">
          <source>Clears the lock counters and then setups the instrumentation to save all destroyed locks. After setup the function is called, passing the elements in &lt;code&gt;Args&lt;/code&gt; as arguments. When the function returns the statistics are immediately collected to the server. After the collection the instrumentation is returned to its previous behavior. The result of the applied function is returned.</source>
          <target state="translated">잠금 카운터를 지운 다음 파손 된 잠금을 모두 저장하도록 계측을 설정합니다. 설정 후 함수가 호출되어 &lt;code&gt;Args&lt;/code&gt; 의 요소를 인수 로 전달합니다. 함수가 리턴하면 통계가 서버에 즉시 수집됩니다. 수집 후 계측은 이전 동작으로 돌아갑니다. 적용된 함수의 결과가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="37dcdd456e3c2b69c6b0d8ce4b98fc1d4210c009" translate="yes" xml:space="preserve">
          <source>Clears the temporary boot command. If the system terminates, the normal &lt;code&gt;HEART_COMMAND&lt;/code&gt; is used to reboot.</source>
          <target state="translated">임시 부팅 명령을 지 웁니다. 시스템이 종료되면 정상적인 &lt;code&gt;HEART_COMMAND&lt;/code&gt; 를 사용하여 재부팅합니다.</target>
        </trans-unit>
        <trans-unit id="2577cb3633fef5aad5a84c896c2c6f81b1bca437" translate="yes" xml:space="preserve">
          <source>Clears trace patterns on global function calls.</source>
          <target state="translated">전역 함수 호출에서 추적 패턴을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="11b01ab35fecb88a64d47127f48dfdab0c530753" translate="yes" xml:space="preserve">
          <source>Clears trace patterns on local and global function calls.</source>
          <target state="translated">로컬 및 글로벌 함수 호출에서 추적 패턴을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="5e9e55a4beacaabaa7e4c5fc4cd8ca1cff7f3d79" translate="yes" xml:space="preserve">
          <source>Clears trace patterns on local function calls.</source>
          <target state="translated">로컬 함수 호출에서 추적 패턴을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="d6d6ba23a63720746cd129c4ddd78a9ce8b9db70" translate="yes" xml:space="preserve">
          <source>Clears trace patterns on messages.</source>
          <target state="translated">메시지의 추적 패턴을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="0fec5dd690b7876869007fa4dc8e05b88546abf4" translate="yes" xml:space="preserve">
          <source>Click button &lt;strong&gt;Start Trace&lt;/strong&gt; to start the trace. By default, trace output is written to a new window. Tracing is stopped when the window is closed, or when clicking button &lt;strong&gt;Stop Trace&lt;/strong&gt;. Trace output can be changed with menu &lt;strong&gt;Options &amp;gt; Output&lt;/strong&gt;. The trace settings, including match specifications, can be saved to, or loaded from, a file.</source>
          <target state="translated">&lt;strong&gt;추적 시작&lt;/strong&gt; 버튼을 클릭 하여 &lt;strong&gt;추적&lt;/strong&gt; 을 시작하십시오. 기본적으로 추적 출력은 새 창에 작성됩니다. 창을 &lt;strong&gt;닫거나 Stop Trace&lt;/strong&gt; 버튼을 클릭하면 추적이 중지됩니다 . 추적 &lt;strong&gt;옵션은 옵션&amp;gt; 출력&lt;/strong&gt; 메뉴를 사용하여 변경할 수 있습니다 . 일치 스펙을 포함한 추적 설정을 파일에 저장하거나 파일에서로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcef5f474ab1f60b5d9bc1fcf7ce96b36faec402" translate="yes" xml:space="preserve">
          <source>Click on a name tag to display its page.</source>
          <target state="translated">이름표를 클릭하면 해당 페이지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="04d51c8f44c15e0a1e9cd8d40fce6f0329fdae6b" translate="yes" xml:space="preserve">
          <source>Clicking a line highlights it and selects it to be the target of the breakpoint functions available from the &lt;strong&gt;Break&lt;/strong&gt; menu. To set a line breakpoint on a line, double-click it. To remove the breakpoint, double-click the line with an existing breakpoint.</source>
          <target state="translated">줄을 클릭하면 해당 줄이 강조 표시되고 &lt;strong&gt;Break&lt;/strong&gt; 메뉴 에서 사용할 수있는 중단 점 기능의 대상으로 선택됩니다 . 줄에 줄 바꿈을 설정하려면 두 번 클릭하십시오. 중단 점을 제거하려면 기존 중단 점이있는 줄을 두 번 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="b3d312baec2796712d75d4a4d40d52f7bba6028b" translate="yes" xml:space="preserve">
          <source>Client Options</source>
          <target state="translated">클라이언트 옵션</target>
        </trans-unit>
        <trans-unit id="28e22fe3dde53ce03b40861a4b22d205384bde66" translate="yes" xml:space="preserve">
          <source>Clients</source>
          <target state="translated">Clients</target>
        </trans-unit>
        <trans-unit id="5d0bb5fe7a5e961e5880f93d711f0e38dc532408" translate="yes" xml:space="preserve">
          <source>Clients are started with &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;connect/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#connect-4&quot;&gt;connect/4&lt;/a&gt;&lt;/code&gt;. They open an encrypted connection on top of TCP/IP. In that encrypted connection one or more channels could be opened with &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/2,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">클라이언트는 &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;connect/3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#connect-4&quot;&gt;connect/4&lt;/a&gt;&lt;/code&gt; 로 시작 됩니다. TCP / IP 위에서 암호화 된 연결을 엽니 다. 암호화 된 연결에서 &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/2,4&lt;/a&gt;&lt;/code&gt; 로 하나 이상의 채널을 열 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca3bc6fb91b02b317e470f58c63c4f0940df8f0d" translate="yes" xml:space="preserve">
          <source>Clients can request to reuse a session established by a previous full handshake between that client and server by sending the id of the session in the initial handshake message. The server may or may not agree to reuse it. If agreed the server will send back the id and if not it will send a new id. The ssl application has several options for handling session reuse.</source>
          <target state="translated">클라이언트는 초기 핸드 셰이크 메시지에 세션 ID를 전송하여 해당 클라이언트와 서버 간의 이전 전체 핸드 셰이크에 의해 설정된 세션을 재사용하도록 요청할 수 있습니다. 서버는 재사용에 동의하거나 동의하지 않을 수 있습니다. 동의하면 서버는 ID를 다시 보내고 그렇지 않으면 새 ID를 보냅니다. SSL 애플리케이션에는 세션 재사용을 처리하기위한 몇 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ec0af9b01d531f2c1e91f2576ecad57b1002807" translate="yes" xml:space="preserve">
          <source>Clients uses all files stored in the &lt;code&gt;&lt;a href=&quot;#USERDIR&quot;&gt;USERDIR&lt;/a&gt;&lt;/code&gt; directory.</source>
          <target state="translated">클라이언트는 &lt;code&gt;&lt;a href=&quot;#USERDIR&quot;&gt;USERDIR&lt;/a&gt;&lt;/code&gt; 디렉토리에 저장된 모든 파일을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="c9afbd6ca86ca26af0ee4601de8d33e0e3db301d" translate="yes" xml:space="preserve">
          <source>Close punctuation</source>
          <target state="translated">구두점 닫기</target>
        </trans-unit>
        <trans-unit id="c24bd6354c11beadb396720d375c93335e15a7ec" translate="yes" xml:space="preserve">
          <source>Close the mib-storage table.</source>
          <target state="translated">mib-storage 테이블을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="592b9786d83b25c310e25098ffbb1c8d8d35ce68" translate="yes" xml:space="preserve">
          <source>Close the mib-storage.</source>
          <target state="translated">mib-storage를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="dc569b6b856c7427e167157a74113626f12814c7" translate="yes" xml:space="preserve">
          <source>Close the socket identified by &lt;code&gt;ctx&lt;/code&gt; and destroy the context.</source>
          <target state="translated">&lt;code&gt;ctx&lt;/code&gt; 로 식별되는 소켓을 닫고 컨텍스트를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="a01bd159b8f373e3abf9028301a1b651c7e12f62" translate="yes" xml:space="preserve">
          <source>Closes a TCP socket.</source>
          <target state="translated">TCP 소켓을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="e937c538908fd420cad6e2a18d22a1ccd28c5e7d" translate="yes" xml:space="preserve">
          <source>Closes a TLS/DTLS connection.</source>
          <target state="translated">TLS / DTLS 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="9496f4074e8f35d723149747305a4b83e6a2e080" translate="yes" xml:space="preserve">
          <source>Closes a UDP socket.</source>
          <target state="translated">UDP 소켓을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="c3012268c89638e549e91dc1baa96b886e28b2a0" translate="yes" xml:space="preserve">
          <source>Closes a connection to a database. This will also terminate all processes that may have been spawned when the connection was opened. This call will always succeed. If the connection can not be disconnected gracefully it will be brutally killed. However you may receive an error message as result if you try to disconnect a connection started by another process.</source>
          <target state="translated">데이터베이스에 대한 연결을 닫습니다. 또한 연결을 열 때 생성되었을 수있는 모든 프로세스가 종료됩니다. 이 전화는 항상 성공할 것입니다. 연결을 정상적으로 분리 할 수 ​​없으면 잔인하게 종료됩니다. 그러나 다른 프로세스에서 시작한 연결을 끊으려고하면 오류 메시지가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68bbaec5e74f6047f0e5abcbc8a727621d01ec20" translate="yes" xml:space="preserve">
          <source>Closes a connection to a database. This will also terminate all processes that may have been spawned when the connection was opened. This call will always succeed. If the connection cannot be disconnected gracefully it will be brutally killed. However you may receive an error message as result if you try to disconnect a connection started by another process.</source>
          <target state="translated">데이터베이스에 대한 연결을 닫습니다. 또한 연결이 열렸을 때 생성되었을 수있는 모든 프로세스를 종료합니다. 이 호출은 항상 성공합니다. 연결이 정상적으로 끊어지지 않으면 잔인하게 종료됩니다. 그러나 다른 프로세스에서 시작한 연결을 끊으려고하면 오류 메시지가 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fedaf7e7f755777e61b444ad3388a8908bb68e49" translate="yes" xml:space="preserve">
          <source>Closes a handle to an open file or directory on the server.</source>
          <target state="translated">서버에서 열린 파일 또는 디렉토리에 대한 핸들을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="215485c4befae922eb5a5d5935fd733652b4ce47" translate="yes" xml:space="preserve">
          <source>Closes a local or distributed disk log properly. An internally formatted log must be closed before the Erlang system is stopped. Otherwise, the log is regarded as unclosed and the automatic repair procedure is activated next time the log is opened.</source>
          <target state="translated">로컬 또는 분산 디스크 로그를 올바르게 닫습니다. Erlang 시스템을 중지하기 전에 내부 형식의 로그를 닫아야합니다. 그렇지 않으면 로그가 닫히지 않은 것으로 간주되고 다음에 로그를 열 때 자동 복구 절차가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="29e73ff6b566a953cef38a1f7457365c29503626" translate="yes" xml:space="preserve">
          <source>Closes a log file properly.</source>
          <target state="translated">로그 파일을 올바르게 닫습니다.</target>
        </trans-unit>
        <trans-unit id="07fc420ec95adbf7d0f9265d705ee3ece3f06902" translate="yes" xml:space="preserve">
          <source>Closes a previously opened connection or listen socket.</source>
          <target state="translated">이전에 열린 연결 또는 청취 소켓을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="e4fe071a7ae3117ab43dd5cebfb15042d7d75064" translate="yes" xml:space="preserve">
          <source>Closes a socket in one or two directions.</source>
          <target state="translated">한 방향 또는 두 방향으로 소켓을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="34f9bfce04a30dbf2d2a5d3ff2b9de4343426661" translate="yes" xml:space="preserve">
          <source>Closes a socket of any type.</source>
          <target state="translated">모든 유형의 소켓을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="07d2d8b051eae4fe9f47eb82e8322135c86a9d13" translate="yes" xml:space="preserve">
          <source>Closes a table. Only processes that have opened a table are allowed to close it.</source>
          <target state="translated">테이블을 닫습니다. 테이블을 연 프로세스 만 닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58e1063100c7c97dfae0ff35da3735d6d25aaa8a" translate="yes" xml:space="preserve">
          <source>Closes a tar file opened by &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 로 열린 tar 파일을 닫습니다 .</target>
        </trans-unit>
        <trans-unit id="f90b891ab0b807043fe4d07d621237e76f50a2a8" translate="yes" xml:space="preserve">
          <source>Closes a zip archive, previously opened with &lt;code&gt;&lt;a href=&quot;#zip_open-1&quot;&gt;zip_open/1,2&lt;/a&gt;&lt;/code&gt;. All resources are closed, and the handle is not to be used after closing.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#zip_open-1&quot;&gt;zip_open/1,2&lt;/a&gt;&lt;/code&gt; 로 이전에 열린 zip 아카이브를 닫습니다 . 모든 리소스가 닫히고 닫은 후에는 핸들을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="225c79c841a7ef2d9c14cfd8b6c0560b734eccdf" translate="yes" xml:space="preserve">
          <source>Closes an SSH connection.</source>
          <target state="translated">SSH 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="45417a381f59258abc297027e3e6dd25f02cd21d" translate="yes" xml:space="preserve">
          <source>Closes an SSH session channel.</source>
          <target state="translated">SSH 세션 채널을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="e5e229797e97b628c04b38a55fb8e68b7a123f74" translate="yes" xml:space="preserve">
          <source>Closes an SSH/SFTP connection.</source>
          <target state="translated">SSH / SFTP 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="fb37d2a48e4ea7de8281d62da1148d80ddf77a3c" translate="yes" xml:space="preserve">
          <source>Closes an TLS/DTLS connection.</source>
          <target state="translated">TLS / DTLS 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="6e2c93e1cd8faf1313158041890dec046b7c45af" translate="yes" xml:space="preserve">
          <source>Closes an open connection to an Erlang node.</source>
          <target state="translated">Erlang 노드에 대한 열린 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="93f51f1e052bdccb2b5819a8e385ea79a02eae4e" translate="yes" xml:space="preserve">
          <source>Closes an open port. Roughly the same as &lt;code&gt;Port ! {self(), close}&lt;/code&gt; except for the error behavior (see below), being synchronous, and that the port does &lt;strong&gt;not&lt;/strong&gt; reply with &lt;code&gt;{Port, closed}&lt;/code&gt;. Any process can close a port with &lt;code&gt;port_close/1&lt;/code&gt;, not only the port owner (the connected process). If the calling process is linked to the port identified by &lt;code&gt;Port&lt;/code&gt;, the exit signal from the port is guaranteed to be delivered before &lt;code&gt;port_close/1&lt;/code&gt; returns.</source>
          <target state="translated">열린 포트를 닫습니다. &lt;code&gt;Port ! {self(), close}&lt;/code&gt; 와 거의 동일합니다 ! {자기 (), 가까운} 오류 동작을 제외하고는, (아래 참조) 동기되고, 그리고 포트는 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 회신 &lt;code&gt;{Port, closed}&lt;/code&gt; . 모든 프로세스는 포트 소유자 (연결된 프로세스)뿐만 아니라 &lt;code&gt;port_close/1&lt;/code&gt; 로 포트를 닫을 수 있습니다 . 호출 프로세스가 &lt;code&gt;Port&lt;/code&gt; 로 식별 된 포트에 링크되면 &lt;code&gt;port_close/1&lt;/code&gt; 이 리턴 되기 전에 포트의 종료 신호가 전달되도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="b00fa3ba7559016fbe2ca5768febc2df9174ce3f" translate="yes" xml:space="preserve">
          <source>Closes or downgrades a TLS connection. In the latter case the transport connection will be handed over to the &lt;code&gt;NewController&lt;/code&gt; process after receiving the TLS close alert from the peer. The returned transport socket will have the following options set: &lt;code&gt;[{active, false}, {packet, 0}, {mode, binary}]&lt;/code&gt;</source>
          <target state="translated">TLS 연결을 닫거나 다운 그레이드합니다. 후자의 경우 전송 연결은 피어로부터 TLS 닫기 경고를 수신 한 후 &lt;code&gt;NewController&lt;/code&gt; 프로세스 로 넘겨 집니다. 반환 된 전송 소켓에는 다음 옵션이 설정됩니다. &lt;code&gt;[{active, false}, {packet, 0}, {mode, binary}]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e9d4bec3e73259bf8d39d5cd28968440d21e59d" translate="yes" xml:space="preserve">
          <source>Closes or downgrades an TLS connection. In the latter case the transport connection will be handed over to the &lt;code&gt;NewController&lt;/code&gt; process after receiving the TLS close alert from the peer. The returned transport socket will have the following options set: &lt;code&gt;[{active, false}, {packet, 0}, {mode, binary}]&lt;/code&gt;</source>
          <target state="translated">TLS 연결을 닫거나 다운 그레이드합니다. 후자의 경우, 전송 연결은 피어로부터 TLS 닫기 경고를 수신 한 후 &lt;code&gt;NewController&lt;/code&gt; 프로세스로 전달됩니다. 반환 된 전송 소켓에는 &lt;code&gt;[{active, false}, {packet, 0}, {mode, binary}]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="751e30fd02da6e32788d4a5c145fde188cf46230" translate="yes" xml:space="preserve">
          <source>Closes the FTP connection.</source>
          <target state="translated">FTP 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="18d541512ada7266d080309162b7730417e656c5" translate="yes" xml:space="preserve">
          <source>Closes the Telnet connection and stops the process managing it.</source>
          <target state="translated">Telnet 연결을 닫고이를 관리하는 프로세스를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="1d8aa591e076329a5cff023401fe06aa6fea372b" translate="yes" xml:space="preserve">
          <source>Closes the access.</source>
          <target state="translated">액세스를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="61217cd859d4e901638e1c1975335762abb86efd" translate="yes" xml:space="preserve">
          <source>Closes the current log file. Returns &lt;code&gt;ok&lt;/code&gt;, or &lt;code&gt;{error, module_not_found}&lt;/code&gt;.</source>
          <target state="translated">현재 로그 파일을 닫습니다. &lt;code&gt;ok&lt;/code&gt; 또는 &lt;code&gt;{error, module_not_found}&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ec24623729c70fb6bea95b4e625a0da9a7e8c998" translate="yes" xml:space="preserve">
          <source>Closes the file referenced by &lt;code&gt;IoDevice&lt;/code&gt;. It mostly returns &lt;code&gt;ok&lt;/code&gt;, except for some severe errors such as out of memory.</source>
          <target state="translated">&lt;code&gt;IoDevice&lt;/code&gt; 가 참조하는 파일을 닫습니다 . 메모리 부족과 같은 심각한 오류를 제외하고 는 대부분 &lt;code&gt;ok&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="684f684454d3e1635a242373232771bb9dda7424" translate="yes" xml:space="preserve">
          <source>Closes the given SSH connection.</source>
          <target state="translated">주어진 SSH 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="27c0419dbdad16fe1e643dacd2401a129f7bd772" translate="yes" xml:space="preserve">
          <source>Closes the log file. The output from the RB tool is directed to &lt;code&gt;standard_io&lt;/code&gt;.</source>
          <target state="translated">로그 파일을 닫습니다. RB 도구의 출력은 &lt;code&gt;standard_io&lt;/code&gt; 로 지정 됩니다.</target>
        </trans-unit>
        <trans-unit id="504626654a412e4798e7dd4e7f5ea514b7c55cf7" translate="yes" xml:space="preserve">
          <source>Closes the port.</source>
          <target state="translated">포트를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="b69157f4131c8138ac5adf29a5ca6f8c9971773d" translate="yes" xml:space="preserve">
          <source>Closes the port. Unless the port is already closed, the port replies with &lt;code&gt;{Port,closed}&lt;/code&gt; when all buffers have been flushed and the port really closes.</source>
          <target state="translated">포트를 닫습니다. 포트가 이미 닫혀 있지 않으면 포트는 모든 버퍼가 플러시되고 포트가 실제로 닫힐 때 &lt;code&gt;{Port,closed}&lt;/code&gt; 로 응답 합니다.</target>
        </trans-unit>
        <trans-unit id="ec9e12048014ec45278b599d7514a7f58d812a5d" translate="yes" xml:space="preserve">
          <source>Closes the preprocessing of a file.</source>
          <target state="translated">파일의 전처리를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="269356b8822c1fff23690ce723ac4f1ed4460bf8" translate="yes" xml:space="preserve">
          <source>Closes the registry. After that, the &lt;code&gt;RegHandle&lt;/code&gt; cannot be used.</source>
          <target state="translated">레지스트리를 닫습니다. 그 후에는 &lt;code&gt;RegHandle&lt;/code&gt; 을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f12faa3ebf225ccbe7cdef983e0e76eeecdf113" translate="yes" xml:space="preserve">
          <source>Closes the socket and all associations on it. The unsent data is flushed as in &lt;code&gt;&lt;a href=&quot;#eof-2&quot;&gt;eof/2&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;close/1&lt;/code&gt; call is blocking or otherwise depending of the value of the &lt;code&gt;&lt;a href=&quot;inet#option-linger&quot;&gt;linger&lt;/a&gt;&lt;/code&gt; socket &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;option&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;close&lt;/code&gt; does not linger or linger time-out expires, the call returns and the data is flushed in the background.</source>
          <target state="translated">소켓과 소켓의 모든 연결을 닫습니다. 보내지 않은 데이터는 &lt;code&gt;&lt;a href=&quot;#eof-2&quot;&gt;eof/2&lt;/a&gt;&lt;/code&gt; 에서와 같이 플러시됩니다 . &lt;code&gt;close/1&lt;/code&gt; 호출은 차단 또는 기타의 값에 따라됩니다 &lt;code&gt;&lt;a href=&quot;inet#option-linger&quot;&gt;linger&lt;/a&gt;&lt;/code&gt; 소켓 &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;option&lt;/a&gt;&lt;/code&gt; . 경우 &lt;code&gt;close&lt;/code&gt; 하지 않습니다 링거 또는 링거 타임 아웃은, 호출이 반환을 만료 데이터는 백그라운드에서 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="d088ba46947a0a90bc08a101b18b61eb57bcdcb7" translate="yes" xml:space="preserve">
          <source>Closes the socket.</source>
          <target state="translated">소켓을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="7bffc0467918675e50dec5df0e6816862c61c4aa" translate="yes" xml:space="preserve">
          <source>Closes the stream referenced by &lt;code&gt;Z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Z&lt;/code&gt; 가 참조하는 스트림을 닫습니다 .</target>
        </trans-unit>
        <trans-unit id="99973cebcb8af97213e10f909e8acc88b7dd1ef1" translate="yes" xml:space="preserve">
          <source>Closes this window and detach from the process.</source>
          <target state="translated">이 창을 닫고 프로세스에서 분리하십시오.</target>
        </trans-unit>
        <trans-unit id="34a868e0a12f0bd3b0076e904023cd21157c12b0" translate="yes" xml:space="preserve">
          <source>Closing a Channel (RFC 4254, section 5.3)</source>
          <target state="translated">채널 닫기 (RFC 4254, 섹션 5.3)</target>
        </trans-unit>
        <trans-unit id="dfd86873672c10f114caa15b02aa5a859162a796" translate="yes" xml:space="preserve">
          <source>ClosureOp ::= &lt;code&gt;closure&lt;/code&gt;</source>
          <target state="translated">ClosureOp :: = &lt;code&gt;closure&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e90a0d75842a148bf39ca837cd5f740d36c1a9b" translate="yes" xml:space="preserve">
          <source>Cmac functions - &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4493.txt&quot;&gt;The AES-CMAC Algorithm (RFC 4493)&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Cmac 기능-AES &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4493.txt&quot;&gt;The AES-CMAC Algorithm (RFC 4493)&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49cdd0ecba2f4a1cf6ab5d194ad0b2feeb7627e0" translate="yes" xml:space="preserve">
          <source>Co-located callback code for each state, for all &lt;code&gt;&lt;a href=&quot;#Event%20Types%20and%20Event%20Content&quot;&gt; &lt;strong&gt;Event Types&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; (such as &lt;strong&gt;call&lt;/strong&gt;, &lt;strong&gt;cast&lt;/strong&gt; and &lt;strong&gt;info&lt;/strong&gt;)</source>
          <target state="translated">모든 &lt;code&gt;&lt;a href=&quot;#Event%20Types%20and%20Event%20Content&quot;&gt; &lt;strong&gt;Event Types&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; (예 : &lt;strong&gt;call&lt;/strong&gt; , &lt;strong&gt;cast&lt;/strong&gt; 및 &lt;strong&gt;info&lt;/strong&gt; )에 대해 각 상태에 대해 함께 배치 된 콜백 코드 &lt;strong&gt;&lt;/strong&gt; &lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3401a3d9fe92078f97d8cfcd69cd94295181a349" translate="yes" xml:space="preserve">
          <source>Co-located callback code for each state, regardless of &lt;code&gt;&lt;a href=&quot;#Event%20Types&quot;&gt;Event Type&lt;/a&gt;&lt;/code&gt; (such as &lt;strong&gt;call&lt;/strong&gt;, &lt;strong&gt;cast&lt;/strong&gt; and &lt;strong&gt;info&lt;/strong&gt;)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#Event%20Types&quot;&gt;Event Type&lt;/a&gt;&lt;/code&gt; (예 : &lt;strong&gt;call&lt;/strong&gt; , &lt;strong&gt;cast&lt;/strong&gt; 및 &lt;strong&gt;info&lt;/strong&gt; )에 관계없이 각 상태에 대해 배치 된 콜백 코드</target>
        </trans-unit>
        <trans-unit id="dce76c393d27cb2285a888bed5709e098f9c85a0" translate="yes" xml:space="preserve">
          <source>Co-located state code</source>
          <target state="translated">함께 위치한 상태 코드</target>
        </trans-unit>
        <trans-unit id="071b4a868a8b79b6bd06d47e2377e594598062a5" translate="yes" xml:space="preserve">
          <source>Coalescing of free blocks are always performed immediately. Boundary tags (headers and footers) in free blocks are used, which makes the time complexity for coalescing constant.</source>
          <target state="translated">자유 블록의 병합은 항상 즉시 수행됩니다. 자유 블록의 경계 태그 (헤더 및 바닥 글)가 사용되므로 병합 시간이 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="f82863ada61185750ed2535d5af42aa575352c0d" translate="yes" xml:space="preserve">
          <source>Code Path</source>
          <target state="translated">코드 경로</target>
        </trans-unit>
        <trans-unit id="2cbcb8d71aaf189c59401ae6220a8fde81d304a8" translate="yes" xml:space="preserve">
          <source>Code changes that seem small can cause a deadlock, as unforeseen consequences can occur. The use of &lt;code&gt;input&lt;/code&gt; is dangerous in this type of code.</source>
          <target state="translated">예상치 못한 결과가 발생할 수 있으므로 작은 코드 변경은 교착 상태를 유발할 수 있습니다. 이 유형의 코드에서는 &lt;code&gt;input&lt;/code&gt; 사용하는 것이 위험합니다.</target>
        </trans-unit>
        <trans-unit id="f6f0001667925b51aaa144c8555cdf56ab04f2c1" translate="yes" xml:space="preserve">
          <source>Code executing only in the final phase does not have to be able to cope with the time warp.</source>
          <target state="translated">최종 단계에서만 실행되는 코드는 타임 워프에 대처할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7da5ff52f9c2e858ddeba30acb14c98399f10834" translate="yes" xml:space="preserve">
          <source>Code generation directives</source>
          <target state="translated">코드 생성 지시문</target>
        </trans-unit>
        <trans-unit id="7517d2173bc408241c9c961ca6ed13ae1bf3cf95" translate="yes" xml:space="preserve">
          <source>Code like the following will also be optimized:</source>
          <target state="translated">다음과 같은 코드도 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="a42f74f1f02a3aa3006bb5a047e88b03e340b66f" translate="yes" xml:space="preserve">
          <source>Code loading</source>
          <target state="translated">코드 로딩</target>
        </trans-unit>
        <trans-unit id="e6e4cfb9758510abbc95d1476acfff025d1aadab" translate="yes" xml:space="preserve">
          <source>Code loading mode.</source>
          <target state="translated">코드 로딩 모드.</target>
        </trans-unit>
        <trans-unit id="8ac67b9a438c843103e19b5b4579252c71ad56fe" translate="yes" xml:space="preserve">
          <source>Code loading works almost as usual, except that interpreted modules are also stored in a database and debugged processes use only this stored code. Reinterpreting an interpreted module results in the new version being stored as well, but does not affect existing processes executing an older version of the code. This means that the code replacement mechanism of Erlang does not work for debugged processes.</source>
          <target state="translated">해석 된 모듈도 데이터베이스에 저장되고 디버깅 된 프로세스는이 저장된 코드 만 사용한다는 점을 제외하면 코드 로딩은 거의 평소와 같이 작동합니다. 해석 된 모듈을 재 해석하면 새 버전도 저장되지만 이전 버전의 코드를 실행하는 기존 프로세스에는 영향을 미치지 않습니다. 이것은 Erlang의 코드 대체 메커니즘이 디버깅 된 프로세스에서 작동하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="56c19e16bac5b16970cd9ff83784b17afefb33d0" translate="yes" xml:space="preserve">
          <source>Code point 16#FEFF is used for Byte Order Marks (BOMs) and use of that character is not encouraged in other contexts. It is valid though, as the character &quot;ZWNBS&quot; (Zero Width Non Breaking Space). BOMs are used to identify encodings and byte order for programs where such parameters are not known in advance. BOMs are more seldom used than expected, but can become more widely spread as they provide the means for programs to make educated guesses about the Unicode format of a certain file.</source>
          <target state="translated">코드 포인트 16 # FEFF는 BOM (Byte Order Marks)에 사용되며 다른 컨텍스트에서는 해당 문자를 사용하지 않는 것이 좋습니다. 문자 &quot;ZWNBS&quot;(제로 폭 비 분리 공간)로 유효합니다. BOM은 이러한 매개 변수를 미리 알 수없는 프로그램의 인코딩 및 바이트 순서를 식별하는 데 사용됩니다. BOM은 예상보다 드물게 사용되지만 프로그램이 특정 파일의 유니 코드 형식에 대해 교육 된 추측을 할 수있는 수단을 제공하므로 더 널리 퍼질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63c15bd60bea5d826d7523a85dc068734b1a1ba4" translate="yes" xml:space="preserve">
          <source>Code such as these examples is inherently non-portable, even different versions of the same OS on the same platform can respond differently to this kind of option manipulation. Use with care.</source>
          <target state="translated">이러한 예제와 같은 코드는 기본적으로 이식성이 없으며 동일한 플랫폼에서 동일한 OS의 다른 버전이라도 이러한 종류의 옵션 조작에 다르게 응답 할 수 있습니다. 주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5f527646d672b093be1a4098fc6814606d464bbd" translate="yes" xml:space="preserve">
          <source>Code that is the current latest version of the modules.</source>
          <target state="translated">현재 최신 버전의 모듈 인 코드입니다.</target>
        </trans-unit>
        <trans-unit id="70f90dd78e0b0fb23852ab6b2688deed73f5c02c" translate="yes" xml:space="preserve">
          <source>Code that manipulates the same data records can be run concurrently without the different processes interfering with each other.</source>
          <target state="translated">서로 다른 프로세스가 서로 간섭하지 않고 동일한 데이터 레코드를 조작하는 코드를 동시에 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ee529db22d08c438f2f9211e70f671de376615a" translate="yes" xml:space="preserve">
          <source>Code using the same layout is easy to read and maintain.</source>
          <target state="translated">동일한 레이아웃을 사용하는 코드는 읽고 유지 관리하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="aaa79e3d7390f36f2c6656fca85bff5690139844" translate="yes" xml:space="preserve">
          <source>Code where there exists a newer version in the system, but the old version is not yet purged.</source>
          <target state="translated">시스템에 최신 버전이 있지만 이전 버전은 아직 제거되지 않은 코드입니다.</target>
        </trans-unit>
        <trans-unit id="dda1e35cb5eaf5544e935767c1b869708c6466c8" translate="yes" xml:space="preserve">
          <source>Code written without using behaviours can be more efficient, but the increased efficiency is at the expense of generality. The ability to manage all applications in the system in a consistent manner is important.</source>
          <target state="translated">동작을 사용하지 않고 작성된 코드는 더 효율적일 수 있지만 효율성이 높아지면 일반성이 떨어집니다. 시스템의 모든 응용 프로그램을 일관된 방식으로 관리하는 기능이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="aabf94dda285f7b2ce559c0a81d2821b9125e926" translate="yes" xml:space="preserve">
          <source>Collect digit map letters according to the digit map.</source>
          <target state="translated">숫자 맵에 따라 숫자 맵 문자를 수집하십시오.</target>
        </trans-unit>
        <trans-unit id="d5c4376d706e0e0926ed6b917a93992a5fa5fd3f" translate="yes" xml:space="preserve">
          <source>Collect trace events and provide a backing storage appropriate for iteration</source>
          <target state="translated">추적 이벤트를 수집하고 반복에 적합한 백업 스토리지를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="e33d648c88485b5e3445ec85a48ee3a200918fb7" translate="yes" xml:space="preserve">
          <source>Collector menu:</source>
          <target state="translated">수집기 메뉴 :</target>
        </trans-unit>
        <trans-unit id="2cc767ef47379b0118564589be24769b7d52f979" translate="yes" xml:space="preserve">
          <source>Collects and analyses the call counters presently in the node for either module &lt;code&gt;Mod&lt;/code&gt;, or for all modules (except &lt;code&gt;cprof&lt;/code&gt; itself), and returns:</source>
          <target state="translated">현재 &lt;code&gt;Mod&lt;/code&gt; 모듈 또는 모든 모듈 ( &lt;code&gt;cprof&lt;/code&gt; 자체 제외 ) 의 노드에있는 콜 카운터를 수집하고 분석하여 다음을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5b532be13bb4823dedcb40365e8ab9adfcc43c5f" translate="yes" xml:space="preserve">
          <source>Collects call counters and computes the result.</source>
          <target state="translated">콜 카운터를 수집하고 결과를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="2d339d9851615bae000afcd6bc3156d0c65cf55a" translate="yes" xml:space="preserve">
          <source>Collects lock statistics from the runtime system. The function starts a server if it is not already started. It then populates the server with lock statistics. If the server held any lock statistics data before the collect then that data is lost.</source>
          <target state="translated">런타임 시스템에서 잠금 통계를 수집합니다. 이 기능은 서버가 아직 시작되지 않은 경우 서버를 시작합니다. 그런 다음 서버를 잠금 통계로 채 웁니다. 서버가 수집 전에 잠금 통계 데이터를 보유한 경우 해당 데이터가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="114d6372609006dd470fd4948b225b11b9aee096" translate="yes" xml:space="preserve">
          <source>Collects several segments of data, referenced by &lt;code&gt;ev&lt;/code&gt;, by copying them in order to the buffer &lt;code&gt;buf&lt;/code&gt;, of the size &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;len&lt;/code&gt; 크기 의 버퍼 &lt;code&gt;buf&lt;/code&gt; 에 순서대로 복사하여 &lt;code&gt;ev&lt;/code&gt; 가 참조하는 여러 데이터 세그먼트를 수집 합니다 .</target>
        </trans-unit>
        <trans-unit id="bdf0b5bed937c19a708d35d32ebd309882131285" translate="yes" xml:space="preserve">
          <source>Column &lt;strong&gt;Memory&lt;/strong&gt; shows the 'Memory' field that was added to crashdumps in Erlang/OTP R16B01. This is the total amount of memory used by the process. For crashdumps from earlier releases, this column shows the 'Stack+heap' field. The value is always in bytes.</source>
          <target state="translated">열 &lt;strong&gt;메모리&lt;/strong&gt; 는 Erlang / OTP R16B01의 충돌 덤프에 추가 된 '메모리'필드를 보여줍니다. 프로세스에서 사용하는 총 메모리 양입니다. 이전 릴리스의 충돌 덤프의 경우이 열에는 '스택 + 힙'필드가 표시됩니다. 값은 항상 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="f89976c8c47c9f7de7e2ac197cd3c1add9759dd2" translate="yes" xml:space="preserve">
          <source>Column sorting orders.</source>
          <target state="translated">열 정렬 순서.</target>
        </trans-unit>
        <trans-unit id="bbcaf86c57cd6bdf869b7c67b5080193d82b8647" translate="yes" xml:space="preserve">
          <source>Combine the statistics from different instances of a lock class.</source>
          <target state="translated">잠금 클래스의 다른 인스턴스에서 통계를 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="17fcaa24e071e5e36935cbcb3562866374761c3a" translate="yes" xml:space="preserve">
          <source>Combined instructions</source>
          <target state="translated">결합 된 지침</target>
        </trans-unit>
        <trans-unit id="7dfd2d72e4720e2879330fef4226ea30d546b398" translate="yes" xml:space="preserve">
          <source>Combines &lt;code&gt;position/2&lt;/code&gt; and &lt;code&gt;read/2&lt;/code&gt; in one operation, which is more efficient than calling them one at a time.</source>
          <target state="translated">한 번에 하나씩 호출하는 것보다 더 효율적인 하나의 작업에서 &lt;code&gt;position/2&lt;/code&gt; 와 &lt;code&gt;read/2&lt;/code&gt; 를 결합 합니다.</target>
        </trans-unit>
        <trans-unit id="dc20251782236128d549d6ebb0e54869f51ae3db" translate="yes" xml:space="preserve">
          <source>Combines &lt;code&gt;position/2&lt;/code&gt; and &lt;code&gt;read/2&lt;/code&gt; in one operation, which is more efficient than calling them one at a time. If &lt;code&gt;IoDevice&lt;/code&gt; is opened in &lt;code&gt;raw&lt;/code&gt; mode, some restrictions apply:</source>
          <target state="translated">콤바인의 &lt;code&gt;position/2&lt;/code&gt; 및 &lt;code&gt;read/2&lt;/code&gt; 한 번에 하나를 호출하는 것보다 더 효율적인 하나의 작업에서. &lt;code&gt;IoDevice&lt;/code&gt; 가 &lt;code&gt;raw&lt;/code&gt; 모드 로 열린 경우 몇 가지 제한 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4267bca1f40191888eec6c3429c09752efc2d66c" translate="yes" xml:space="preserve">
          <source>Combines &lt;code&gt;position/2&lt;/code&gt; and &lt;code&gt;write/2&lt;/code&gt; in one operation, which is more efficient than calling them one at a time.</source>
          <target state="translated">한 번에 하나씩 호출하는 것보다 더 효율적인 하나의 작업에서 &lt;code&gt;position/2&lt;/code&gt; 와 &lt;code&gt;write/2&lt;/code&gt; 를 결합 합니다.</target>
        </trans-unit>
        <trans-unit id="4fca0bb2dc4fbd4f474148dae6a3d233006a85be" translate="yes" xml:space="preserve">
          <source>Combines &lt;code&gt;position/2&lt;/code&gt; and &lt;code&gt;write/2&lt;/code&gt; in one operation, which is more efficient than calling them one at a time. If &lt;code&gt;IoDevice&lt;/code&gt; has been opened in &lt;code&gt;raw&lt;/code&gt; mode, some restrictions apply:</source>
          <target state="translated">콤바인의 &lt;code&gt;position/2&lt;/code&gt; 및 &lt;code&gt;write/2&lt;/code&gt; 한 번에 하나를 호출하는 것보다 더 효율적이다에서 하나의 작업. &lt;code&gt;IoDevice&lt;/code&gt; 가 &lt;code&gt;raw&lt;/code&gt; 모드 로 열린 경우 몇 가지 제한 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="60a59ba0758293ba79d03e3211f6ab8c3cf7a44b" translate="yes" xml:space="preserve">
          <source>Combines map and fold in a single operation. This is similar to &lt;code&gt;map/2&lt;/code&gt;, but also propagates an extra value from each application of the &lt;code&gt;Function&lt;/code&gt; to the next, while doing a post-order traversal of the tree like &lt;code&gt;fold/3&lt;/code&gt;. The value &lt;code&gt;Start&lt;/code&gt; is passed to the first function application, and the final result is the result of the last application.</source>
          <target state="translated">단일 작업으로 맵과 접기를 결합합니다. 이것은 &lt;code&gt;map/2&lt;/code&gt; 와 유사 하지만 &lt;code&gt;fold/3&lt;/code&gt; 와 같은 트리의 post-order traversal을 수행하면서 &lt;code&gt;Function&lt;/code&gt; 의 각 응용 프로그램 에서 다음으로 추가 값을 전파합니다 . &lt;code&gt;Start&lt;/code&gt; 값 이 첫 번째 기능 응용 프로그램으로 전달되고 최종 결과는 마지막 응용 프로그램의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="b3df522de4ef77bd85fda7b30fd4231f0b29e129" translate="yes" xml:space="preserve">
          <source>Combines the elements of three lists of equal length into one list. For each triple &lt;code&gt;X, Y, Z&lt;/code&gt; of list elements from the three lists, the element in the result list is &lt;code&gt;Combine(X, Y, Z)&lt;/code&gt;.</source>
          <target state="translated">길이가 같은 3 개의 목록 요소를 하나의 목록으로 결합합니다. 세 목록에서 목록 요소의 각 트리플 &lt;code&gt;X, Y, Z&lt;/code&gt; 에 대해 결과 목록의 요소는 &lt;code&gt;Combine(X, Y, Z)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b63fcc6cc8116ab8ae92cf34ec638f3a76d35764" translate="yes" xml:space="preserve">
          <source>Combines the elements of two lists of equal length into one list. For each pair &lt;code&gt;X, Y&lt;/code&gt; of list elements from the two lists, the element in the result list is &lt;code&gt;Combine(X, Y)&lt;/code&gt;.</source>
          <target state="translated">길이가 같은 두 목록의 요소를 하나의 목록으로 결합합니다. 두 목록에서 목록 요소의 각 쌍 &lt;code&gt;X, Y&lt;/code&gt; 에 대해 결과 목록의 요소는 &lt;code&gt;Combine(X, Y)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="df39e33c36c20503114fdd2e4361dfbd8a144da1" translate="yes" xml:space="preserve">
          <source>Combines the operations of &lt;code&gt;&lt;a href=&quot;#map-2&quot;&gt;map/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt; into one pass.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#map-2&quot;&gt;map/2&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt; 의 연산 을 하나의 패스로 결합합니다 .</target>
        </trans-unit>
        <trans-unit id="9eb3883b2969f22a840c76b882086f1400662f06" translate="yes" xml:space="preserve">
          <source>Combines the operations of &lt;code&gt;&lt;a href=&quot;#map-2&quot;&gt;map/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#foldr-3&quot;&gt;foldr/3&lt;/a&gt;&lt;/code&gt; into one pass.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#map-2&quot;&gt;map/2&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;#foldr-3&quot;&gt;foldr/3&lt;/a&gt;&lt;/code&gt; 의 연산 을 하나의 패스로 결합합니다 .</target>
        </trans-unit>
        <trans-unit id="001f12c2f7fc722059d0ee491fe8c8b28186a093" translate="yes" xml:space="preserve">
          <source>Combines two Adler-32 checksums into one. For two binaries or iolists, &lt;code&gt;Data1&lt;/code&gt; and &lt;code&gt;Data2&lt;/code&gt; with sizes of &lt;code&gt;Size1&lt;/code&gt; and &lt;code&gt;Size2&lt;/code&gt;, with Adler-32 checksums &lt;code&gt;Adler1&lt;/code&gt; and &lt;code&gt;Adler2&lt;/code&gt;.</source>
          <target state="translated">두 개의 Adler-32 체크섬을 하나로 결합합니다. 두 바이너리 또는 iolists 대한 &lt;code&gt;Data1&lt;/code&gt; 과 &lt;code&gt;Data2&lt;/code&gt; 의 크기가 &lt;code&gt;Size1&lt;/code&gt; 및 &lt;code&gt;Size2&lt;/code&gt; 애들러-32 체크섬, &lt;code&gt;Adler1&lt;/code&gt; 및 &lt;code&gt;Adler2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08c1251d5cd30a4c857ece6865b552f1070674cf" translate="yes" xml:space="preserve">
          <source>Combines two CRC checksums into one. For two binaries or iolists, &lt;code&gt;Data1&lt;/code&gt; and &lt;code&gt;Data2&lt;/code&gt; with sizes of &lt;code&gt;Size1&lt;/code&gt; and &lt;code&gt;Size2&lt;/code&gt;, with CRC checksums &lt;code&gt;CRC1&lt;/code&gt; and &lt;code&gt;CRC2&lt;/code&gt;.</source>
          <target state="translated">두 개의 CRC 체크섬을 하나로 결합합니다. 이 바이너리 또는 iolists, 대한 &lt;code&gt;Data1&lt;/code&gt; 과 &lt;code&gt;Data2&lt;/code&gt; 의 크기가 &lt;code&gt;Size1&lt;/code&gt; 및 &lt;code&gt;Size2&lt;/code&gt; CRC 체크섬과, &lt;code&gt;CRC1&lt;/code&gt; 및 &lt;code&gt;CRC2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1746126ff205a59844a881a51b112a8b53e83b98" translate="yes" xml:space="preserve">
          <source>Combines two previously computed adler32 checksums. This computation requires the size of the data object for the second checksum to be known.</source>
          <target state="translated">이전에 계산 된 2 개의 adler32 체크섬을 결합합니다. 이 계산을 위해서는 두 번째 체크섬에 대한 데이터 개체의 크기를 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="b5a84d5edd7f748866e54345659773ed891e4ac9" translate="yes" xml:space="preserve">
          <source>Combines two previously computed crc32 checksums. This computation requires the size of the data object for the second checksum to be known.</source>
          <target state="translated">이전에 계산 된 두 crc32 체크섬을 결합합니다. 이 계산을 위해서는 두 번째 체크섬에 대한 데이터 개체의 크기를 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="7c547b4f5559e9e848f6e074436dd454e9700281" translate="yes" xml:space="preserve">
          <source>Combining maps and filters enables writing of very succinct code. For example, to define a set difference function &lt;code&gt;diff(L1, L2)&lt;/code&gt; to be the difference between the lists &lt;code&gt;L1&lt;/code&gt; and &lt;code&gt;L2&lt;/code&gt;, the code can be written as follows:</source>
          <target state="translated">맵과 필터를 결합하면 매우 간결한 코드를 작성할 수 있습니다. 예를 들어, 설정 차이 함수 &lt;code&gt;diff(L1, L2)&lt;/code&gt; 를 목록 &lt;code&gt;L1&lt;/code&gt; 과 &lt;code&gt;L2&lt;/code&gt; 사이의 차이 로 정의 하려면 코드를 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbd234d5db623301ed626dbc5f5a4befa82d3bdc" translate="yes" xml:space="preserve">
          <source>Comma-separated string that determines which authentication methods that the client shall support and in which order they are tried. Defaults to &lt;code&gt;&quot;publickey,keyboard-interactive,password&quot;&lt;/code&gt;</source>
          <target state="translated">클라이언트가 지원할 인증 방법과 시도 순서를 결정하는 쉼표로 구분 된 문자열입니다. 기본값은 &lt;code&gt;&quot;publickey,keyboard-interactive,password&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8901895fb1b1d4c4ea2fec368c25176bf73e2f7e" translate="yes" xml:space="preserve">
          <source>Command</source>
          <target state="translated">Command</target>
        </trans-unit>
        <trans-unit id="342da5a2f1813920c1bbfc4e852eea12f5063e4a" translate="yes" xml:space="preserve">
          <source>Command 1 sets variable &lt;code&gt;Str&lt;/code&gt; to string &lt;code&gt;&quot;abcd&quot;&lt;/code&gt;.</source>
          <target state="translated">명령 1은 변수 &lt;code&gt;Str&lt;/code&gt; 을 문자열 &lt;code&gt;&quot;abcd&quot;&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="fd9251dc262d6cfde540ad0cd5c6d370876df98b" translate="yes" xml:space="preserve">
          <source>Command 10 prints the current value of &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">명령 10은 현재 값 &lt;code&gt;L&lt;/code&gt; 을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="549199ae9bb6e901fc9258b242e067c754071753" translate="yes" xml:space="preserve">
          <source>Command 11 tries to match &lt;code&gt;{P, Q, R}&lt;/code&gt; against &lt;code&gt;Descriptor&lt;/code&gt;, which is &lt;code&gt;{4, abc}&lt;/code&gt;. The match fails and none of the new variables become bound. The printout starting with &quot;&lt;code&gt;** exception error:&lt;/code&gt;&quot; is not the value of the expression (the expression had no value because its evaluation failed), but a warning printed by the system to inform the user that an error has occurred. The values of the other variables (&lt;code&gt;L&lt;/code&gt;, &lt;code&gt;Str&lt;/code&gt;, and so on) are unchanged.</source>
          <target state="translated">명령 (11)은 시도하였습니다 &lt;code&gt;{P, Q, R}&lt;/code&gt; 에 대한 &lt;code&gt;Descriptor&lt;/code&gt; 인, &lt;code&gt;{4, abc}&lt;/code&gt; . 일치가 실패하고 새 변수가 바인딩되지 않습니다. &quot; &lt;code&gt;** exception error:&lt;/code&gt; &quot;로 시작하는 인쇄물 은 표현식의 값이 아니며 (평가에 실패했기 때문에 표현식에 값이 없음) 오류가 발생했음을 사용자에게 알리기 위해 시스템에서 경고를 인쇄합니다. 다른 변수 ( &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;Str&lt;/code&gt; 등)의 값은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="691b9bcaa6996c92d90bae097639c4314d240f78" translate="yes" xml:space="preserve">
          <source>Command 16 clears all bindings.</source>
          <target state="translated">명령 16은 모든 바인딩을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="05c70d2234df4548b33a38e52389722995c34012" translate="yes" xml:space="preserve">
          <source>Command 19 evaluates &lt;code&gt;test1:demo(1)&lt;/code&gt;. The evaluation succeeds and the changes made in the process dictionary become visible to the shell. The new value of dictionary item &lt;code&gt;aa&lt;/code&gt; can be seen in command 20.</source>
          <target state="translated">명령 19는 &lt;code&gt;test1:demo(1)&lt;/code&gt; 평가 합니다. 평가가 성공하고 프로세스 사전에서 작성된 변경 사항이 쉘에 표시됩니다. 사전 항목 &lt;code&gt;aa&lt;/code&gt; 의 새로운 값은 명령 20에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="571320cb8183e22d95e0984d3435eed120eb8182" translate="yes" xml:space="preserve">
          <source>Command 2 sets &lt;code&gt;L&lt;/code&gt; to the length of string &lt;code&gt;Str&lt;/code&gt;.</source>
          <target state="translated">명령 2는 &lt;code&gt;L&lt;/code&gt; 을 문자열 &lt;code&gt;Str&lt;/code&gt; 의 길이로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="b305cf69a5307579ebf549236a1a79deee898174" translate="yes" xml:space="preserve">
          <source>Command 3 builds the tuple &lt;code&gt;Descriptor&lt;/code&gt;, evaluating the BIF &lt;code&gt;list_to_atom/1 &lt;/code&gt;.</source>
          <target state="translated">명령 3은 BIF &lt;code&gt;list_to_atom/1 &lt;/code&gt; 을 평가 하는 튜플 &lt;code&gt;Descriptor&lt;/code&gt; 자를 빌드합니다 .</target>
        </trans-unit>
        <trans-unit id="6a5da20736f5aa69db276e3a85c9eb3bf4a9c347" translate="yes" xml:space="preserve">
          <source>Command 3 builds the tuple &lt;code&gt;Descriptor&lt;/code&gt;, evaluating the BIF &lt;code&gt;list_to_atom/1&lt;/code&gt;.</source>
          <target state="translated">명령 3은 BIF &lt;code&gt;list_to_atom/1&lt;/code&gt; 을 평가 하여 튜플 &lt;code&gt;Descriptor&lt;/code&gt; 빌드합니다 .</target>
        </trans-unit>
        <trans-unit id="51d00e3abf06e503663d94b19230b0cc26a72c2f" translate="yes" xml:space="preserve">
          <source>Command 33 prints the definition of the record named &lt;code&gt;rec&lt;/code&gt;.</source>
          <target state="translated">명령 33은 &lt;code&gt;rec&lt;/code&gt; 라는 레코드의 정의를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="45bc49c790b43237868293d2dd2e2edd61652121" translate="yes" xml:space="preserve">
          <source>Command 34 tries to create a &lt;code&gt;rec&lt;/code&gt; record, but fails as function &lt;code&gt;val/0&lt;/code&gt; is undefined.</source>
          <target state="translated">명령 34는 &lt;code&gt;rec&lt;/code&gt; 레코드 를 작성하려고 하지만 함수 &lt;code&gt;val/0&lt;/code&gt; 이 정의되지 않아 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="72dcc67df9bbfa51a0492808644209d31bbd7f2f" translate="yes" xml:space="preserve">
          <source>Command 35 shows the workaround: explicitly assign values to record fields that cannot otherwise be initialized.</source>
          <target state="translated">명령 35는 해결 방법을 보여줍니다. 달리 초기화 할 수없는 레코드 필드에 값을 명시 적으로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="fa2515e3e9587434ad52b14ccfc30883e7022dde" translate="yes" xml:space="preserve">
          <source>Command 36 prints the newly created record using record definitions maintained by the shell.</source>
          <target state="translated">명령 36은 쉘에서 유지 보수하는 레코드 정의를 사용하여 새로 작성된 레코드를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="9154fd77dee8fff9e9758b70c934a42fa72f2fda" translate="yes" xml:space="preserve">
          <source>Command 37 defines a record directly in the shell. The definition replaces the one read from file &lt;code&gt;ex.beam&lt;/code&gt;.</source>
          <target state="translated">명령 37은 쉘에서 직접 레코드를 정의합니다. 정의는 &lt;code&gt;ex.beam&lt;/code&gt; 파일에서 읽은 것을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="1f8eb1cd9b3187f9b754c49fd8314986efc7792e" translate="yes" xml:space="preserve">
          <source>Command 38 creates a record using the new definition, and prints the result.</source>
          <target state="translated">명령 38은 새로운 정의를 사용하여 레코드를 작성하고 결과를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="505fd82812bb30eb7dc21bc2b04f27b3d82e3401" translate="yes" xml:space="preserve">
          <source>Command 39 and 40 show that record definitions are updated as side effects. The evaluation of the command fails, but the definition of &lt;code&gt;rec&lt;/code&gt; has been carried out.</source>
          <target state="translated">명령 39 및 40은 레코드 정의가 부작용으로 업데이트되었음을 ​​보여줍니다. 명령 평가에 실패했지만 &lt;code&gt;rec&lt;/code&gt; 정의 가 수행되었습니다.</target>
        </trans-unit>
        <trans-unit id="c942ae59ce728287fe12cdbf8492f720f289065f" translate="yes" xml:space="preserve">
          <source>Command 4 prints the value of variable &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">명령 4는 변수 &lt;code&gt;L&lt;/code&gt; 의 값을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="e7d5c11f36c6ad9e416101362d83e867e199c699" translate="yes" xml:space="preserve">
          <source>Command 41 evaluates &lt;code&gt;test1:loop(0)&lt;/code&gt;, which puts the system into an infinite loop. At this point the user types &lt;code&gt;^G&lt;/code&gt; (Control G), which suspends output from the current process, which is stuck in a loop, and activates &lt;code&gt;JCL&lt;/code&gt; mode. In &lt;code&gt;JCL&lt;/code&gt; mode the user can start and stop jobs.</source>
          <target state="translated">명령 41은 &lt;code&gt;test1:loop(0)&lt;/code&gt; 평가 하여 시스템을 무한 루프에 넣습니다. 이 시점에서 사용자는 &lt;code&gt;^G&lt;/code&gt; (Control G)를 입력합니다. 이것은 현재 프로세스의 출력을 중단하고 루프에 &lt;code&gt;JCL&lt;/code&gt; 있으며 JCL 모드를 활성화 합니다. 에서 &lt;code&gt;JCL&lt;/code&gt; 의 모드 사용자 시작하고 작업을 중지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="027e48c60bf06fa02b13ef5f87c61d9d7dbea65c" translate="yes" xml:space="preserve">
          <source>Command 42 creates an ETS table.</source>
          <target state="translated">명령 42는 ETS 테이블을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="bb7e5f60b5a386b27383613df99699547215a065" translate="yes" xml:space="preserve">
          <source>Command 43 tries to insert a tuple into the ETS table, but the first argument (the table) is missing. The exception kills the evaluator process.</source>
          <target state="translated">명령 43은 ETS 테이블에 튜플을 삽입하려고 시도하지만 첫 번째 인수 (테이블)가 누락되었습니다. 예외로 인해 평가자 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="13e1680dee0b31442dfcf7d8dd715d5303935741" translate="yes" xml:space="preserve">
          <source>Command 44 corrects the mistake, but the ETS table has been destroyed as it was owned by the killed evaluator process.</source>
          <target state="translated">명령 44는 실수를 정정하지만 ETS 테이블은 종료 된 평가자 프로세스가 소유 한대로 파괴되었습니다.</target>
        </trans-unit>
        <trans-unit id="249b0132245dd6a948f325230d14fb2abcebf877" translate="yes" xml:space="preserve">
          <source>Command 46 sets the exception handling of the evaluator process to &lt;code&gt;true&lt;/code&gt;. The exception handling can also be set when starting Erlang by &lt;code&gt;erl -stdlib shell_catch_exception true&lt;/code&gt;.</source>
          <target state="translated">명령 46은 평가 기 프로세스의 예외 처리를 &lt;code&gt;true&lt;/code&gt; 로 설정 합니다 . &lt;code&gt;erl -stdlib shell_catch_exception true&lt;/code&gt; 로 Erlang을 시작할 때 예외 처리를 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0109c9c2951329001d2c921ef35da35fce643d09" translate="yes" xml:space="preserve">
          <source>Command 48 makes the same mistake as in command 43, but this time the evaluator process lives on. The single star at the beginning of the printout signals that the exception has been caught.</source>
          <target state="translated">사령부 48은 사령부 43에서와 같은 실수를 범하지만 이번에는 평가자 프로세스가 진행됩니다. 출력 시작 부분의 단일 별은 예외가 포착되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="89ddd1b26e2c81d79a061e40a387cb68327ed7e7" translate="yes" xml:space="preserve">
          <source>Command 49 successfully inserts the tuple into the ETS table.</source>
          <target state="translated">명령 49는 터플을 ETS 테이블에 성공적으로 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="21e9b8de7612160c8ff6fb2d218d6871c257d22f" translate="yes" xml:space="preserve">
          <source>Command 5 evaluates the internal shell command &lt;code&gt;b()&lt;/code&gt;, which is an abbreviation of &quot;bindings&quot;. This prints the current shell variables and their bindings. &lt;code&gt;ok&lt;/code&gt; at the end is the return value of function &lt;code&gt;b()&lt;/code&gt;.</source>
          <target state="translated">명령 5 는 &quot;바인딩&quot;의 약어 인 내부 쉘 명령 &lt;code&gt;b()&lt;/code&gt; 평가합니다 . 현재 쉘 변수와 바인딩을 인쇄합니다. &lt;code&gt;ok&lt;/code&gt; 끝에 함수의 리턴 값이고 &lt;code&gt;b()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b87908b907dbfdaf4cc2680aaedac60ec072bdb0" translate="yes" xml:space="preserve">
          <source>Command 50 inserts another tuple into the ETS table. This time the first argument is the table identifier itself. The shell can parse commands with pids (&lt;code&gt;&amp;lt;0.60.0&amp;gt;&lt;/code&gt;), ports (&lt;code&gt;#Port&amp;lt;0.536&amp;gt;&lt;/code&gt;), references (&lt;code&gt;#Ref&amp;lt;0.1662103692.2407792644.214210&amp;gt;&lt;/code&gt;), and external functions (&lt;code&gt;#Fun&amp;lt;a.b.1&amp;gt;&lt;/code&gt;), but the command fails unless the corresponding pid, port, reference, or function can be created in the running system.</source>
          <target state="translated">명령 50은 다른 튜플을 ETS 테이블에 삽입합니다. 이번에는 첫 번째 인수가 테이블 식별자 자체입니다. 셸은 pid ( &lt;code&gt;&amp;lt;0.60.0&amp;gt;&lt;/code&gt; ), 포트 ( &lt;code&gt;#Port&amp;lt;0.536&amp;gt;&lt;/code&gt; ), 참조 ( &lt;code&gt;#Ref&amp;lt;0.1662103692.2407792644.214210&amp;gt;&lt;/code&gt; ) 및 외부 함수 ( &lt;code&gt;#Fun&amp;lt;a.b.1&amp;gt;&lt;/code&gt; )로 명령을 구문 분석 할 수 있지만 명령이 실패합니다. 해당 pid, 포트, 참조 또는 기능을 실행중인 시스템에서 작성할 수 없으면</target>
        </trans-unit>
        <trans-unit id="ef6bff45f7d38fc1ad0f06951a1076b939b05b98" translate="yes" xml:space="preserve">
          <source>Command 51 exits the Erlang runtime system.</source>
          <target state="translated">명령 51은 Erlang 런타임 시스템을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="4a47187be4d245fbaca39a02661c9beb2fb74371" translate="yes" xml:space="preserve">
          <source>Command 6 evaluates the internal shell command &lt;code&gt;f(L)&lt;/code&gt; (abbreviation of &quot;forget&quot;). The value of variable &lt;code&gt;L&lt;/code&gt; is removed.</source>
          <target state="translated">명령 6은 내부 쉘 명령 &lt;code&gt;f(L)&lt;/code&gt; 평가합니다 ( &quot;forget&quot;의 약어). 변수 &lt;code&gt;L&lt;/code&gt; 의 값 이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="e30b7179ba181a3b5c6b762ceede630731c07eb2" translate="yes" xml:space="preserve">
          <source>Command 7 prints the new bindings.</source>
          <target state="translated">명령 7은 새 바인딩을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="5eb872b4d589d1c1c6adf7d4262edec9d05d3813" translate="yes" xml:space="preserve">
          <source>Command 8 has no effect, as &lt;code&gt;L&lt;/code&gt; has no value.</source>
          <target state="translated">&lt;code&gt;L&lt;/code&gt; 에는 값 이 없으므로 명령 8은 효과 가 없습니다.</target>
        </trans-unit>
        <trans-unit id="da435e51bb957a0dcba4d9de8dece9444557cd34" translate="yes" xml:space="preserve">
          <source>Command 9 performs a pattern matching operation on &lt;code&gt;Descriptor&lt;/code&gt;, binding a new value to &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">명령 9는 &lt;code&gt;Descriptor&lt;/code&gt; 에서 패턴 일치 작업을 수행하여 새 값을 &lt;code&gt;L&lt;/code&gt; 에 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="4da205fa9e33785888d3b45cf6c93fdfda35424f" translate="yes" xml:space="preserve">
          <source>Command &lt;code&gt;epmd -stop&lt;/code&gt; (and the corresponding messages to &lt;code&gt;epmd&lt;/code&gt;, as can be specified using &lt;code&gt;erl_interface:ei(3)&lt;/code&gt;) is normally always ignored. This because it can cause a strange situation where two nodes of the same name can be alive at the same time. A node unregisters itself by only closing the connection to &lt;code&gt;epmd&lt;/code&gt;, which is why command &lt;code&gt;stop&lt;/code&gt; was only intended for use in debugging situations.</source>
          <target state="translated">&lt;code&gt;epmd -stop&lt;/code&gt; 명령 (및 &lt;code&gt;erl_interface:ei(3)&lt;/code&gt; 사용하여 지정할 수있는 &lt;code&gt;epmd&lt;/code&gt; 에 해당하는 메시지 )은 항상 무시됩니다. 같은 이름의 두 노드가 동시에 살아있을 수있는 이상한 상황이 발생할 수 있기 때문입니다. 노드 는 &lt;code&gt;epmd&lt;/code&gt; 에 대한 연결 만 닫아서 자체적으로 등록을 해제 하므로 명령 &lt;code&gt;stop&lt;/code&gt; 는 디버깅 상황에서만 사용하도록되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="810d0b44379ad61dcf659535b75db6d8cc44230a" translate="yes" xml:space="preserve">
          <source>Command &lt;code&gt;erl -boot Name&lt;/code&gt; starts the system with a boot file called &lt;code&gt;Name.boot&lt;/code&gt;, which is generated from the &lt;code&gt;Name.script&lt;/code&gt; file, using &lt;code&gt;&lt;a href=&quot;systools#script2boot-1&quot;&gt;systools:script2boot/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">명령 &lt;code&gt;erl -boot Name&lt;/code&gt; 라는 부트 파일로 시스템 시작 &lt;code&gt;Name.boot&lt;/code&gt; 으로부터 생성, &lt;code&gt;Name.script&lt;/code&gt; 의 사용, 파일 &lt;code&gt;&lt;a href=&quot;systools#script2boot-1&quot;&gt;systools:script2boot/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39de423c03daee2f71651de9ffea305f36be9120" translate="yes" xml:space="preserve">
          <source>Command &lt;code&gt;ttb:tracer(dbg)&lt;/code&gt; is a shortcut for the pure &lt;code&gt;dbg&lt;/code&gt; mode (&lt;code&gt;{shell, only}&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ttb:tracer(dbg)&lt;/code&gt; 명령 은 순수 &lt;code&gt;dbg&lt;/code&gt; 모드 ( &lt;code&gt;{shell, only}&lt;/code&gt; ) 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="c555f15dcf6bb7adaf5f9b063efb4b7e7e6e2ea1" translate="yes" xml:space="preserve">
          <source>Command Code Format Specification</source>
          <target state="translated">명령 코드 형식 사양</target>
        </trans-unit>
        <trans-unit id="41fea0af8135b09c720af76c92576ba1ce8cab06" translate="yes" xml:space="preserve">
          <source>Command Codes</source>
          <target state="translated">명령 코드</target>
        </trans-unit>
        <trans-unit id="44cece384081cdaf653289bf8b1abbd517cb270c" translate="yes" xml:space="preserve">
          <source>Command Flags</source>
          <target state="translated">명령 플래그</target>
        </trans-unit>
        <trans-unit id="fcf4ea77789a76f9d1ec8ed42f1e7a3d9fea92e5" translate="yes" xml:space="preserve">
          <source>Command Summary</source>
          <target state="translated">명령 요약</target>
        </trans-unit>
        <trans-unit id="f4262805dee42a91c3420fb0de8038f14ed1851c" translate="yes" xml:space="preserve">
          <source>Command interface</source>
          <target state="translated">명령 인터페이스</target>
        </trans-unit>
        <trans-unit id="0ba4d2337dce485f24bbc063f5690cdcfc4ac079" translate="yes" xml:space="preserve">
          <source>Command interface module.</source>
          <target state="translated">명령 인터페이스 모듈.</target>
        </trans-unit>
        <trans-unit id="e659d2d4c58b502e091a664b53727f4cb778e670" translate="yes" xml:space="preserve">
          <source>Command timeout (time to wait for a command to return) = 10 seconds</source>
          <target state="translated">명령 시간 초과 (명령이 반환되기를 기다리는 시간) = 10 초</target>
        </trans-unit>
        <trans-unit id="3e767b383c6d82a7de3a36422b75eb6ce8c0967f" translate="yes" xml:space="preserve">
          <source>Command-Line Flags</source>
          <target state="translated">명령 줄 플래그</target>
        </trans-unit>
        <trans-unit id="b276b756560f04ce3d0917009cdbe122769b89ec" translate="yes" xml:space="preserve">
          <source>Command-line arguments &lt;code&gt;-App Par Val&lt;/code&gt;</source>
          <target state="translated">명령 줄 인수 &lt;code&gt;-App Par Val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c738a0bbafd852c8a585fb1f2ac29479f5b2dc37" translate="yes" xml:space="preserve">
          <source>Command-line arguments are read from the file &lt;code&gt;FileName&lt;/code&gt;. The arguments read from the file replace flag '&lt;code&gt;-args_file FileName&lt;/code&gt;' on the resulting command line.</source>
          <target state="translated">명령 행 인수는 &lt;code&gt;FileName&lt;/code&gt; 파일에서 읽습니다 . 파일에서 읽은 인수 는 결과 명령 행에서 플래그 ' &lt;code&gt;-args_file FileName&lt;/code&gt; '을 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="0815c6d95bf87f31b25e345653bfa997429b0e96" translate="yes" xml:space="preserve">
          <source>Command-line flag &lt;code&gt;-code_path_choice Choice&lt;/code&gt; also affects how module &lt;code&gt;init&lt;/code&gt; interprets the &lt;code&gt;boot script&lt;/code&gt;. The interpretation of the explicit code paths in the &lt;code&gt;boot script&lt;/code&gt; can be &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;relaxed&lt;/code&gt;. It is particularly useful to set the flag to &lt;code&gt;relaxed&lt;/code&gt; when elaborating with code loading from archives without editing the &lt;code&gt;boot script&lt;/code&gt;. The default is &lt;code&gt;relaxed&lt;/code&gt;. See &lt;code&gt;erts:init(3)&lt;/code&gt;.</source>
          <target state="translated">명령 행 플래그 &lt;code&gt;-code_path_choice Choice&lt;/code&gt; 는 또한 모듈 &lt;code&gt;init&lt;/code&gt; 가 &lt;code&gt;boot script&lt;/code&gt; 해석하는 방법에 영향을줍니다 . &lt;code&gt;boot script&lt;/code&gt; 에서 명시 적 코드 경로의 해석은 &lt;code&gt;strict&lt;/code&gt; 하거나 &lt;code&gt;relaxed&lt;/code&gt; 될 수 있습니다 . &lt;code&gt;boot script&lt;/code&gt; 를 편집하지 않고 아카이브에서 코드를로드 할 때 플래그를 &lt;code&gt;relaxed&lt;/code&gt; 하도록 설정하는 것이 특히 유용합니다 . 기본값은 &lt;code&gt;relaxed&lt;/code&gt; 입니다. &lt;code&gt;erts:init(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e6b935146c98f3aa1d4c9b71666cb047822e2b6" translate="yes" xml:space="preserve">
          <source>Command-line flag &lt;code&gt;-loader Loader&lt;/code&gt; can be used to choose the method used by &lt;code&gt;erl_prim_loader&lt;/code&gt;. Two &lt;code&gt;Loader&lt;/code&gt; methods are supported by the Erlang runtime system: &lt;code&gt;efile&lt;/code&gt; and &lt;code&gt;inet&lt;/code&gt;.</source>
          <target state="translated">명령 행 플래그 &lt;code&gt;-loader Loader&lt;/code&gt; 를 사용하여 &lt;code&gt;erl_prim_loader&lt;/code&gt; 가 사용하는 메소드를 선택할 수 있습니다 . Erlang 런타임 시스템은 &lt;code&gt;efile&lt;/code&gt; 및 &lt;code&gt;inet&lt;/code&gt; 의 두 가지 &lt;code&gt;Loader&lt;/code&gt; 메소드를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="19ab3f6695abd2d1efac509f3805ab65802f6cd0" translate="yes" xml:space="preserve">
          <source>Commands 12 and 13 show that &lt;code&gt;P&lt;/code&gt; is unbound because the previous command failed, and that &lt;code&gt;Descriptor&lt;/code&gt; has not changed.</source>
          <target state="translated">명령 12 및 13 은 이전 명령이 실패하여 &lt;code&gt;P&lt;/code&gt; 가 바인드 되지 않았 으며 &lt;code&gt;Descriptor&lt;/code&gt; 가 변경되지 않았 음을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="0808717ab8537267fc0acf980e9bc7e73f8a3115" translate="yes" xml:space="preserve">
          <source>Commands 14 and 15 show a correct match where &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;Q&lt;/code&gt; are bound.</source>
          <target state="translated">명령 14와 15는 &lt;code&gt;P&lt;/code&gt; 와 &lt;code&gt;Q&lt;/code&gt; 가 바인드 된 정확한 일치를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="ba40d80207918719cb767da4bd28be6e2206b511" translate="yes" xml:space="preserve">
          <source>Commands 17 and 18 set and inspect the value of item &lt;code&gt;aa&lt;/code&gt; in the process dictionary.</source>
          <target state="translated">명령 17과 18 은 프로세스 사전에서 항목 &lt;code&gt;aa&lt;/code&gt; 의 값을 설정하고 검사합니다 .</target>
        </trans-unit>
        <trans-unit id="294bcd96ab5ae5465ab190eddd23f0db5bdd9eb1" translate="yes" xml:space="preserve">
          <source>Commands 21 and 22 change the value of dictionary item &lt;code&gt;aa&lt;/code&gt; to &lt;code&gt;hello&lt;/code&gt; and call &lt;code&gt;test1:demo(2)&lt;/code&gt;. Evaluation fails and the changes made to the dictionary in &lt;code&gt;test1:demo(2)&lt;/code&gt;, before the error occurred, are discarded.</source>
          <target state="translated">명령 21과 22는 사전 항목 &lt;code&gt;aa&lt;/code&gt; 의 값 을 &lt;code&gt;hello&lt;/code&gt; 로 변경하고 &lt;code&gt;test1:demo(2)&lt;/code&gt; 호출 합니다. 오류가 발생하기 전에 평가가 실패하고 &lt;code&gt;test1:demo(2)&lt;/code&gt; 의 사전 변경 사항 이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="92740ec7f4a6db2c5a8fde98073bc5eafb9b184e" translate="yes" xml:space="preserve">
          <source>Commands 23 and 24 show that &lt;code&gt;Z&lt;/code&gt; was not bound and that dictionary item &lt;code&gt;aa&lt;/code&gt; has retained its original value.</source>
          <target state="translated">명령 23과 24는 &lt;code&gt;Z&lt;/code&gt; 가 바인딩되지 않았고 사전 항목 &lt;code&gt;aa&lt;/code&gt; 가 원래 값을 유지 했음을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="b56b527b4c21ea0ffd3d260fc661f80779b628fe" translate="yes" xml:space="preserve">
          <source>Commands 25, 26, and 27 show the effect of evaluating &lt;code&gt;test1:demo(1)&lt;/code&gt; in the background. In this case, the expression is evaluated in a newly spawned process. Any changes made in the process dictionary are local to the newly spawned process and therefore not visible to the shell.</source>
          <target state="translated">명령 25, 26 및 27 은 백그라운드에서 &lt;code&gt;test1:demo(1)&lt;/code&gt; 을 평가 한 효과를 보여줍니다 . 이 경우 표현식은 새로 생성 된 프로세스에서 평가됩니다. 프로세스 사전에서 변경 한 내용은 새로 생성 된 프로세스에 국한되므로 쉘에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fbb8fbc989037cd45a07764908684c0276b72d77" translate="yes" xml:space="preserve">
          <source>Commands 28, 29 and 30 use the history facilities of the shell. Command 29 re-evaluates command 28. Command 30 uses the value (result) of command 28. In the cases of a pure function (a function with no side effects), the result is the same. For a function with side effects, the result can be different.</source>
          <target state="translated">명령 28, 29 및 30은 쉘의 히스토리 기능을 사용합니다. 명령 29는 명령 28을 다시 평가합니다. 명령 30은 명령 28의 값 (결과)을 사용합니다. 순수한 기능 (부작용이없는 기능)의 경우 결과는 동일합니다. 부작용이있는 기능의 경우 결과가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bd98506526970354b254ba19f4b457ffe78c8b5" translate="yes" xml:space="preserve">
          <source>Commands 31 and 32 compile file &lt;code&gt;ex.erl&lt;/code&gt; and read the record definitions in &lt;code&gt;ex.beam&lt;/code&gt;. If the compiler did not output any record definitions on the BEAM file, &lt;code&gt;rr(ex)&lt;/code&gt; tries to read record definitions from the source file instead.</source>
          <target state="translated">명령 31 및 32는 &lt;code&gt;ex.erl&lt;/code&gt; 파일을 컴파일 하고 ex.beam 의 레코드 정의를 &lt;code&gt;ex.beam&lt;/code&gt; . 컴파일러가 BEAM 파일에 대한 레코드 정의를 출력하지 않은 경우 &lt;code&gt;rr(ex)&lt;/code&gt; 는 대신 소스 파일에서 레코드 정의를 읽으려고합니다.</target>
        </trans-unit>
        <trans-unit id="22230fce6738635959fe1cc4ea2c847698c33886" translate="yes" xml:space="preserve">
          <source>Commands are defined as CCF specifications in dictionary files.</source>
          <target state="translated">명령은 사전 파일에서 CCF 스펙으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="56e84290b5e3388fcdfc58e1d2baa8a6fd8e4461" translate="yes" xml:space="preserve">
          <source>Comments are embedded in the following example:</source>
          <target state="translated">주석은 다음 예제에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ef3de97bdba18fc781a05004ec85c394079388d" translate="yes" xml:space="preserve">
          <source>Comments can be included in a dictionary file using semicolon: characters from a semicolon to end of line are ignored.</source>
          <target state="translated">세미콜론을 사용하여 주석을 사전 파일에 포함시킬 수 있습니다. 세미콜론에서 줄 끝까지의 문자는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="26288d5796241c87a8f3348937c33f8c190beec7" translate="yes" xml:space="preserve">
          <source>Comments can be placed anywhere in a module except within strings and quoted atoms. A comment begins with the character &quot;%&quot;, continues up to, but does not include the next end-of-line, and has no effect. Notice that the terminating end-of-line has the effect of white space.</source>
          <target state="translated">주석은 줄과 인용 된 원자를 제외하고 모듈의 어느 곳에 나 배치 할 수 있습니다. 주석은 &quot;%&quot;문자로 시작하여 계속되지만 다음 줄 끝은 포함되지 않으며 효과가 없습니다. 종료 라인 끝은 공백의 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="5d789847a2caf02c727ca7174b8c42d0924876dc" translate="yes" xml:space="preserve">
          <source>Comments for individual files are not supported when creating zip archives. The zip archive comment for the whole zip archive is supported.</source>
          <target state="translated">Zip 아카이브를 생성 할 때 개별 파일에 대한 주석은 지원되지 않습니다. 전체 zip 아카이브에 대한 zip 아카이브 주석이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8b3a62c8e579699ba00397d2c80ef8144243fbdd" translate="yes" xml:space="preserve">
          <source>Comments on the code:</source>
          <target state="translated">코드에 대한 의견 :</target>
        </trans-unit>
        <trans-unit id="da35acebd529266c273972c7b3c68d5c1a9be9ff" translate="yes" xml:space="preserve">
          <source>Commit all staged breadpoints by switching &lt;code&gt;erts_active_bp_index&lt;/code&gt;.</source>
          <target state="translated">모든 전환 breadpoints 단계적 커밋 &lt;code&gt;erts_active_bp_index&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="b35af8f67f1302434542fab82b17be91dbc51450" translate="yes" xml:space="preserve">
          <source>Commit the breadpoint by switching &lt;code&gt;erts_active_bp_index&lt;/code&gt;.</source>
          <target state="translated">전환하여 breadpoint 커밋 &lt;code&gt;erts_active_bp_index&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="17bde591b45f1956739cdae90f230bf60f533d89" translate="yes" xml:space="preserve">
          <source>Commits or rollbacks a transaction. Needed on connections where automatic commit is turned off.</source>
          <target state="translated">트랜잭션을 커밋하거나 롤백합니다. 자동 커밋이 해제 된 연결에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7de90a65241a6cdbd9ade485d777715d99285a1e" translate="yes" xml:space="preserve">
          <source>Common</source>
          <target state="translated">Common</target>
        </trans-unit>
        <trans-unit id="241df9920cfb933c5f225205b64b534fff5b5501" translate="yes" xml:space="preserve">
          <source>Common Data Types</source>
          <target state="translated">일반적인 데이터 유형</target>
        </trans-unit>
        <trans-unit id="41d21606dcebe663d602a1344de2a8fca02f49a9" translate="yes" xml:space="preserve">
          <source>Common Derived AVP Data Formats</source>
          <target state="translated">공통 파생 AVP 데이터 형식</target>
        </trans-unit>
        <trans-unit id="0b5334f1456ad098a790e7f352286314bbed47a2" translate="yes" xml:space="preserve">
          <source>Common Gateway Interface (CGI)</source>
          <target state="translated">공통 게이트웨이 인터페이스 (CGI)</target>
        </trans-unit>
        <trans-unit id="db485912bf25572661767ebba87897fc877dcd95" translate="yes" xml:space="preserve">
          <source>Common Gateway Interface (CGI) scripts can be written in any programming language. CGI scripts are standardized and supported by most web servers. The drawback with CGI scripts is that they are resource-intensive because of their design. CGI requires the server to fork a new OS process for each executable it needs to start.</source>
          <target state="translated">CGI (Common Gateway Interface) 스크립트는 모든 프로그래밍 언어로 작성할 수 있습니다. CGI 스크립트는 대부분의 웹 서버에서 표준화되고 지원됩니다. CGI 스크립트의 단점은 디자인 때문에 리소스를 많이 사용한다는 것입니다. CGI는 서버가 시작해야 할 각 실행 파일마다 새로운 OS 프로세스를 분기해야합니다.</target>
        </trans-unit>
        <trans-unit id="19ab22d81ec0ae9cb58d33a88861ce6ef1708b24" translate="yes" xml:space="preserve">
          <source>Common Logfile Format (with or without disk_log(3) support)</source>
          <target state="translated">공통 로그 파일 형식 (disk_log (3) 지원 유무)</target>
        </trans-unit>
        <trans-unit id="4ce20004c1f29ec0692407ac2b38ca6bf8d31367" translate="yes" xml:space="preserve">
          <source>Common Records and ASN.1 Types</source>
          <target state="translated">공통 기록 및 ASN.1 유형</target>
        </trans-unit>
        <trans-unit id="6308629ddea5ddb4f6206238004dacdb96f8740d" translate="yes" xml:space="preserve">
          <source>Common Test framework code coverage support module.</source>
          <target state="translated">공통 테스트 프레임 워크 코드 범위 지원 모듈.</target>
        </trans-unit>
        <trans-unit id="1e2caf325721b603d0dd5b17a62280a7ef4be10c" translate="yes" xml:space="preserve">
          <source>Common Test framework functions for starting and stopping nodes for Large-Scale Testing.</source>
          <target state="translated">대규모 테스트를위한 노드 시작 및 중지를위한 공통 테스트 프레임 워크 기능.</target>
        </trans-unit>
        <trans-unit id="30f1b95bb6a879de9c40633f0536016402c329c6" translate="yes" xml:space="preserve">
          <source>Common Test prints the text from &lt;code&gt;ct:log/3,4,5&lt;/code&gt; or &lt;code&gt;ct:pal/3,4,5&lt;/code&gt; inside a &lt;code&gt;pre&lt;/code&gt; element nested under the named &lt;code&gt;div&lt;/code&gt; element. Since the &lt;code&gt;pre&lt;/code&gt; selector has a predefined CSS rule (in file &lt;code&gt;ct_default.css&lt;/code&gt;) for the attributes &lt;code&gt;color&lt;/code&gt;, &lt;code&gt;font-family&lt;/code&gt; and &lt;code&gt;font-size&lt;/code&gt;, if a user wants to change any of the predefined attribute settings, a new rule for &lt;code&gt;pre&lt;/code&gt; must be added to the user stylesheet. Example:</source>
          <target state="translated">공통 테스트는 &lt;code&gt;ct:log/3,4,5&lt;/code&gt; 또는 &lt;code&gt;ct:pal/3,4,5&lt;/code&gt; 의 텍스트를 명명 된 &lt;code&gt;div&lt;/code&gt; 요소 아래에 중첩 된 &lt;code&gt;pre&lt;/code&gt; 요소 안에 인쇄합니다 . 때문에 &lt;code&gt;pre&lt;/code&gt; 선택기 (파일에 미리 정의 된 CSS 규칙이 &lt;code&gt;ct_default.css&lt;/code&gt; 을 (가) 속성에 대한) &lt;code&gt;color&lt;/code&gt; , &lt;code&gt;font-family&lt;/code&gt; 및 &lt;code&gt;font-size&lt;/code&gt; 사용자가 미리 정의 된 속성 설정을 변경하고자하는 경우, 대한 새 규칙 &lt;code&gt;pre&lt;/code&gt; 추가해야합니다 사용자 스타일 시트에. 예:</target>
        </trans-unit>
        <trans-unit id="c04acbea30ab701b6c1687bc2c2baef0bc8d8ac3" translate="yes" xml:space="preserve">
          <source>Common Test specific layer on Erlang/OTP rpc.</source>
          <target state="translated">Erlang / OTP rpc의 공통 테스트 특정 계층.</target>
        </trans-unit>
        <trans-unit id="6200c508ceec372ce5e6d3dd908d4e9056a88ece" translate="yes" xml:space="preserve">
          <source>Common Test specific layer on top of Telnet client ct_telnet_client.erl</source>
          <target state="translated">Telnet 클라이언트 ct_telnet_client.erl 위에있는 공통 테스트 특정 계층</target>
        </trans-unit>
        <trans-unit id="795765c3a6937dd14e3f9e84bbc1516b51d98f84" translate="yes" xml:space="preserve">
          <source>Common Test user interface module for the SNMP application.</source>
          <target state="translated">SNMP 어플리케이션을위한 공통 테스트 사용자 인터페이스 모듈.</target>
        </trans-unit>
        <trans-unit id="c915caf0b5cf6faff380a7f8100663b681679e13" translate="yes" xml:space="preserve">
          <source>Common Test will escape special HTML characters (&amp;lt;, &amp;gt; and &amp;amp;) in printouts to the log file made with &lt;code&gt;ct:pal/4&lt;/code&gt; and &lt;code&gt;io:format/2&lt;/code&gt;. In order to print strings with HTML tags to the log, use the &lt;code&gt;ct:log/3,4,5&lt;/code&gt; function. The character escaping feature is per default disabled for &lt;code&gt;ct:log/3,4,5&lt;/code&gt; but can be enabled with the &lt;code&gt;esc_chars&lt;/code&gt; option in the &lt;code&gt;Opts&lt;/code&gt; list, see &lt;code&gt;&lt;a href=&quot;ct#log-5&quot;&gt; ct:log/3,4,5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Common Test는 인쇄물에서 특수 HTML 문자 (&amp;lt;,&amp;gt; 및 &amp;amp;)를 &lt;code&gt;ct:pal/4&lt;/code&gt; 및 &lt;code&gt;io:format/2&lt;/code&gt; 로 만든 로그 파일로 이스케이프 합니다 . HTML 태그가있는 문자열을 로그에 인쇄하려면 &lt;code&gt;ct:log/3,4,5&lt;/code&gt; 함수를 사용하십시오. 문자 이스케이프 기능은 &lt;code&gt;ct:log/3,4,5&lt;/code&gt; 에 대해 기본적으로 비활성화되어 있지만 &lt;code&gt;Opts&lt;/code&gt; 목록 의 &lt;code&gt;esc_chars&lt;/code&gt; 옵션 으로 활성화 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;ct#log-5&quot;&gt; ct:log/3,4,5&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4750bbba9bfe2efefedd87368239bf3b9742e5f4" translate="yes" xml:space="preserve">
          <source>Common Test will escape special HTML characters (&amp;lt;, &amp;gt; and &amp;amp;) in printouts to the log file made with &lt;code&gt;ct:pal/4&lt;/code&gt; and &lt;code&gt;io:format/2&lt;/code&gt;. In order to print strings with HTML tags to the log, use the &lt;code&gt;ct:log/3,4,5&lt;/code&gt; function. The character escaping feature is per default disabled for &lt;code&gt;ct:log/3,4,5&lt;/code&gt; but can be enabled with the &lt;code&gt;esc_chars&lt;/code&gt; option in the &lt;code&gt;Opts&lt;/code&gt; list, see &lt;code&gt;&lt;a href=&quot;ct#log-5&quot;&gt;ct:log/3,4,5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Common Test는 &lt;code&gt;ct:pal/4&lt;/code&gt; 및 &lt;code&gt;io:format/2&lt;/code&gt; 로 작성된 로그 파일로 출력되는 특수 HTML 문자 (&amp;lt;,&amp;gt; 및 &amp;amp;)를 이스케이프 처리 합니다 . HTML 태그가있는 문자열을 로그에 인쇄하려면 &lt;code&gt;ct:log/3,4,5&lt;/code&gt; 함수를 사용하십시오. 문자 이스케이프 기능은 기본적으로 &lt;code&gt;ct:log/3,4,5&lt;/code&gt; 에 대해 비활성화되어 있지만 &lt;code&gt;Opts&lt;/code&gt; 목록 의 &lt;code&gt;esc_chars&lt;/code&gt; 옵션을 사용하여 활성화 할 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;ct#log-5&quot;&gt;ct:log/3,4,5&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="acedb2a295655cedf03a6d64f7a4770f00468a7c" translate="yes" xml:space="preserve">
          <source>Common Test will not escape special HTML characters (&amp;lt;, &amp;gt; and &amp;amp;) in the text printed with this function, unless the &lt;code&gt;esc_chars&lt;/code&gt; option is used.</source>
          <target state="translated">&lt;code&gt;esc_chars&lt;/code&gt; 옵션을 사용 하지 않으면 Common Test는이 함수로 인쇄 된 텍스트에서 특수 HTML 문자 (&amp;lt;,&amp;gt; 및 &amp;amp;)를 이스케이프하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="dadf2071e7b21987ca0708b9d6985520d78f3217" translate="yes" xml:space="preserve">
          <source>Common config types:</source>
          <target state="translated">일반적인 구성 유형 :</target>
        </trans-unit>
        <trans-unit id="ac09f939510f1230449f2487860d2c31044efcc5" translate="yes" xml:space="preserve">
          <source>Common data types</source>
          <target state="translated">일반적인 데이터 유형</target>
        </trans-unit>
        <trans-unit id="d94691a074c7593f911e3dc52f3f8f13032dc40a" translate="yes" xml:space="preserve">
          <source>Common non-standard Erlang data types used to describe the record fields in the following sections and which are not defined in the Public Key &lt;code&gt;&lt;a href=&quot;public_key&quot;&gt;Reference Manual&lt;/a&gt;&lt;/code&gt; follows here:</source>
          <target state="translated">다음 섹션의 레코드 필드를 설명하는 데 사용되며 공개 키 &lt;code&gt;&lt;a href=&quot;public_key&quot;&gt;Reference Manual&lt;/a&gt;&lt;/code&gt; 정의되지 않은 일반적인 비표준 Erlang 데이터 유형은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c0f63b574b67c6705b08577c533549ceb705554" translate="yes" xml:space="preserve">
          <source>Communicate with distributed Erlang.</source>
          <target state="translated">분산 된 Erlang과 통신하십시오.</target>
        </trans-unit>
        <trans-unit id="bd72983883a714962b7215d3a3f5aee15e422d63" translate="yes" xml:space="preserve">
          <source>Communicates with a running port mapper daemon.</source>
          <target state="translated">실행중인 포트 매퍼 데몬과 통신합니다.</target>
        </trans-unit>
        <trans-unit id="70cdbfe70a51bbd63ce1591394b2d32e526d83f8" translate="yes" xml:space="preserve">
          <source>Communicating with the running &lt;code&gt;epmd&lt;/code&gt; daemon by the &lt;code&gt;epmd&lt;/code&gt; program is done primarily for debugging purposes.</source>
          <target state="translated">&lt;code&gt;epmd&lt;/code&gt; 프로그램이 실행중인 &lt;code&gt;epmd&lt;/code&gt; 데몬 과 통신하는 것은 주로 디버깅 목적으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="62b1109168a638234d95928543c75a350159ad8e" translate="yes" xml:space="preserve">
          <source>Communication between C nodes and Erlang processes</source>
          <target state="translated">C 노드와 Erlang 프로세스 간의 통신</target>
        </trans-unit>
        <trans-unit id="210328a62ba74dfc81e096c28bc1dd2f82995f3e" translate="yes" xml:space="preserve">
          <source>Communication in Erlang is conceptually performed using asynchronous signaling. All different executing entities, such as processes and ports, communicate through asynchronous signals. The most commonly used signal is a message. Other common signals are exit, link, unlink, monitor, and demonitor signals.</source>
          <target state="translated">Erlang의 통신은 개념적으로 비동기 신호를 사용하여 수행됩니다. 프로세스 및 포트와 같은 다른 모든 실행 엔티티는 비동기 신호를 통해 통신합니다. 가장 일반적으로 사용되는 신호는 메시지입니다. 다른 공통 신호는 종료, 링크, 링크 해제, 모니터 및 모니터 해제 신호입니다.</target>
        </trans-unit>
        <trans-unit id="4183b090fb1af0688c00077a895de35dc21295ae" translate="yes" xml:space="preserve">
          <source>Communication utility functions to be used by the Erlang web server API programmer.</source>
          <target state="translated">Erlang 웹 서버 API 프로그래머가 사용하는 통신 유틸리티 기능.</target>
        </trans-unit>
        <trans-unit id="80afd53213b9e40ec5102490cac90c9e596e23ff" translate="yes" xml:space="preserve">
          <source>Communication with sockets</source>
          <target state="translated">소켓과의 통신</target>
        </trans-unit>
        <trans-unit id="82de2dfc6db5d20f900f698ba6e19de7560c30d1" translate="yes" xml:space="preserve">
          <source>Compare the severity of two log levels. Returns &lt;code&gt;gt&lt;/code&gt; if &lt;code&gt;Level1&lt;/code&gt; is more severe than &lt;code&gt;Level2&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt; if &lt;code&gt;Level1&lt;/code&gt; is less severe, and &lt;code&gt;eq&lt;/code&gt; if the levels are equal.</source>
          <target state="translated">두 로그 레벨의 심각도를 비교하십시오. 반환 &lt;code&gt;gt&lt;/code&gt; 경우 &lt;code&gt;Level1&lt;/code&gt; 보다 심각한 &lt;code&gt;Level2&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; 경우 &lt;code&gt;Level1&lt;/code&gt; 덜 심각하고 &lt;code&gt;eq&lt;/code&gt; 수준이 동일한 경우.</target>
        </trans-unit>
        <trans-unit id="b4829635ff8b264cec3be490a754062e423a0438" translate="yes" xml:space="preserve">
          <source>Compare two port identifiers. The comparison is done the same way as Erlang does.</source>
          <target state="translated">두 포트 식별자를 비교합니다. 비교는 Erlang과 동일한 방식으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="dc33d4612f53d09e85f3f59e9a2fb150d86afb5d" translate="yes" xml:space="preserve">
          <source>Compare two process identifiers. The comparison is done the same way as Erlang does.</source>
          <target state="translated">두 프로세스 식별자를 비교합니다. 비교는 Erlang과 동일한 방식으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="62e9bf54b39e624437b799beda0e7a99d2c76831" translate="yes" xml:space="preserve">
          <source>Compare two references. The comparison is done the same way as Erlang does.</source>
          <target state="translated">두 참조를 비교하십시오. 비교는 Erlang과 동일한 방식으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="151c5d07514ac40bad0d13f9b26b2443190972b1" translate="yes" xml:space="preserve">
          <source>Compared to other SNMP agent packages, there is a significant difference in this way of using sub-agents. Other packages normally use sub-agents to load and unload MIBs in run-time. In Erlang, it is easy to load code in run-time and it is possible to load an MIB into an existing sub-agent. It is not necessary to create a new process for handling a new MIB.</source>
          <target state="translated">다른 SNMP 에이전트 패키지와 비교하여이 방법으로 하위 에이전트를 사용하는 데는 상당한 차이가 있습니다. 다른 패키지는 일반적으로 하위 에이전트를 사용하여 런타임에 MIB를로드 및 언로드합니다. Erlang에서는 런타임에 코드를 쉽게로드 할 수 있으며 기존 하위 에이전트에 MIB를로드 할 수 있습니다. 새 MIB를 처리하기 위해 새 프로세스를 만들 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="0c52ead5590f8067968c45ad847b25a4d463504b" translate="yes" xml:space="preserve">
          <source>Compared to the C program in &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt;, using only the plain port, the &lt;code&gt;while&lt;/code&gt;-loop must be rewritten. Messages coming from the port is on the Erlang external term format. They must be converted into an &lt;code&gt;ETERM&lt;/code&gt; struct, which is a C struct similar to an Erlang term. The result of calling &lt;code&gt;foo()&lt;/code&gt; or &lt;code&gt;bar()&lt;/code&gt; must be converted to the Erlang external term format before being sent back to the port. But before calling any other Erl_Interface function, the memory handling must be initiated:</source>
          <target state="translated">일반 포트만 사용 하는 &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt; 의 C 프로그램과 비교할 때 &lt;code&gt;while&lt;/code&gt; 루프를 다시 작성해야합니다. 포트에서 오는 메시지는 Erlang 외부 용어 형식입니다. 그것들은 &lt;code&gt;ETERM&lt;/code&gt; 구조체 로 변환되어야하며 , 이것은 Erlang 용어와 유사한 C 구조체입니다. &lt;code&gt;foo()&lt;/code&gt; 또는 &lt;code&gt;bar()&lt;/code&gt; 호출 결과 는 포트로 다시 보내기 전에 Erlang 외부 용어 형식으로 변환되어야합니다. 그러나 다른 Erl_Interface 함수를 호출하기 전에 메모리 처리를 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="c178437fef0499e44fe458af65742e21d4b116d4" translate="yes" xml:space="preserve">
          <source>Compares the BEAM files in two directories as &lt;code&gt;&lt;a href=&quot;#cmp_dirs-2&quot;&gt;cmp_dirs/2&lt;/a&gt;&lt;/code&gt;, but the names of files that exist in only one directory or are different are presented on standard output.</source>
          <target state="translated">두 디렉토리의 BEAM 파일을 &lt;code&gt;&lt;a href=&quot;#cmp_dirs-2&quot;&gt;cmp_dirs/2&lt;/a&gt;&lt;/code&gt; 로 비교 하지만 한 디렉토리에만 존재하거나 다른 파일 이름은 표준 출력에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d98bf1bf3f126212e19565bfe2441f8eca0296a5" translate="yes" xml:space="preserve">
          <source>Compares the BEAM files in two directories. Only files with extension &lt;code&gt;&quot;.beam&quot;&lt;/code&gt; are compared. BEAM files that exist only in directory &lt;code&gt;Dir1&lt;/code&gt; (&lt;code&gt;Dir2&lt;/code&gt;) are returned in &lt;code&gt;Only1&lt;/code&gt; (&lt;code&gt;Only2&lt;/code&gt;). BEAM files that exist in both directories but are considered different by &lt;code&gt;cmp/2&lt;/code&gt; are returned as pairs {&lt;code&gt;Filename1&lt;/code&gt;, &lt;code&gt;Filename2&lt;/code&gt;}, where &lt;code&gt;Filename1&lt;/code&gt; (&lt;code&gt;Filename2&lt;/code&gt;) exists in directory &lt;code&gt;Dir1&lt;/code&gt; (&lt;code&gt;Dir2&lt;/code&gt;).</source>
          <target state="translated">두 디렉토리에서 BEAM 파일을 비교합니다. 확장자가 &lt;code&gt;&quot;.beam&quot;&lt;/code&gt; 인 파일 만 비교됩니다. &lt;code&gt;Dir1&lt;/code&gt; 디렉토리 ( &lt;code&gt;Dir2&lt;/code&gt; ) 에만 존재하는 BEAM 파일 은 &lt;code&gt;Only1&lt;/code&gt; ( &lt;code&gt;Only2&lt;/code&gt; ) 로 리턴됩니다 . 두 디렉토리에 존재하지만 &lt;code&gt;cmp/2&lt;/code&gt; 에 의해 다른 것으로 간주되는 BEAM 파일은 { &lt;code&gt;Filename1&lt;/code&gt; , &lt;code&gt;Filename2&lt;/code&gt; } 쌍으로 리턴되며 , 여기서 &lt;code&gt;Filename1&lt;/code&gt; ( &lt;code&gt;Filename2&lt;/code&gt; )은 &lt;code&gt;Dir1&lt;/code&gt; ( &lt;code&gt;Dir2&lt;/code&gt; ) 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="553a5eb717c257ef16ac7d4161ee3822b465e3e7" translate="yes" xml:space="preserve">
          <source>Compares the contents of two BEAM files. If the module names are the same, and all chunks except for chunk &lt;code&gt;&quot;CInf&quot;&lt;/code&gt; (the chunk containing the compilation information that is returned by &lt;code&gt;Module:module_info(compile)&lt;/code&gt;) have the same contents in both files, &lt;code&gt;ok&lt;/code&gt; is returned. Otherwise an error message is returned.</source>
          <target state="translated">두 BEAM 파일의 내용을 비교합니다. 모듈 이름이 동일하고 청크 &lt;code&gt;&quot;CInf&quot;&lt;/code&gt; ( &lt;code&gt;Module:module_info(compile)&lt;/code&gt; 의해 리턴되는 컴파일 정보를 포함하는 청크)를 제외한 모든 청크 가 두 파일에서 동일한 내용을 갖는 경우 &lt;code&gt;ok&lt;/code&gt; 가 리턴됩니다. 그렇지 않으면 오류 메시지가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1371fc9819183da776aa8b206d27ecaadad51181" translate="yes" xml:space="preserve">
          <source>Compares two &lt;code&gt;&lt;a href=&quot;#ErlNifMonitor&quot;&gt;ErlNifMonitor&lt;/a&gt;&lt;/code&gt;s. Can also be used to imply some artificial order on monitors, for whatever reason.</source>
          <target state="translated">두 개의 &lt;code&gt;&lt;a href=&quot;#ErlNifMonitor&quot;&gt;ErlNifMonitor&lt;/a&gt;&lt;/code&gt; 를 비교합니다 . 어떤 이유로 든 모니터에 인공 명령을 내릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7422cbed4d976bf1196e3065965309b4656fcd35" translate="yes" xml:space="preserve">
          <source>Compares two &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid &lt;/a&gt;&lt;/code&gt;s according to term order.</source>
          <target state="translated">용어 순서에 따라 두 &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid &lt;/a&gt;&lt;/code&gt; 를 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="5229791f8671e196d2b82edc4c7e2f917dd47d48" translate="yes" xml:space="preserve">
          <source>Compares two &lt;code&gt;ErlDrvMonitor&lt;/code&gt;s. Can also be used to imply some artificial order on monitors, for whatever reason.</source>
          <target state="translated">두 개의 &lt;code&gt;ErlDrvMonitor&lt;/code&gt; 를 비교합니다 . 어떤 이유로 든 모니터에 인공 명령을 내릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00c8883b1a2eb607b39cecd8cab305675f55c676" translate="yes" xml:space="preserve">
          <source>Compares two encoded terms.</source>
          <target state="translated">두 개의 인코딩 된 용어를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="4db48e071567d5840fbc4f9ce1403c03ce1085eb" translate="yes" xml:space="preserve">
          <source>Compares two thread identifiers, &lt;code&gt;tid1&lt;/code&gt; and &lt;code&gt;tid2&lt;/code&gt;, for equality.</source>
          <target state="translated">두 스레드 식별자 &lt;code&gt;tid1&lt;/code&gt; 과 &lt;code&gt;tid2&lt;/code&gt; 를 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">Compatibility</target>
        </trans-unit>
        <trans-unit id="a8a612a1cee1a099e60c55bb976d9e9c6e46b755" translate="yes" xml:space="preserve">
          <source>Compatible between releases.</source>
          <target state="translated">릴리스간에 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="7a3e29c10f00281440509daef8170e445e3cdb30" translate="yes" xml:space="preserve">
          <source>Compatible flow control. Ports have for a very long time had the possibility to use the busy port functionality when implementing flow control. One may argue that this functionality fits very bad with the conceptually completely asynchronous signaling, but the functionality has been there for ages and is expected to be there. When a port sets itself into a busy state, &lt;code&gt;command&lt;/code&gt; signals should not be delivered, and senders of such signals should suspend until the port sets itself in a not busy state.</source>
          <target state="translated">호환되는 흐름 제어. 포트는 매우 오랫동안 흐름 제어를 구현할 때 사용중인 포트 기능을 사용할 수있었습니다. 이 기능은 개념적으로 완전히 비동기식 시그널링에 매우 적합하지 않다고 주장 할 수 있지만, 기능은 오랫동안 존재 해 왔으며 거기에있을 것으로 예상됩니다. 포트가 자신을 사용 중 상태로 설정하면 &lt;code&gt;command&lt;/code&gt; 신호가 전달되지 않아야하며 이러한 신호의 발신자는 포트가 사용 중이 아닌 상태로 설정 될 때까지 일시 중지해야합니다.</target>
        </trans-unit>
        <trans-unit id="bc2ecfdad25dfb789330b4fb6ce1f190fa4a6009" translate="yes" xml:space="preserve">
          <source>Compilation information (options) for the current code. This field is decoded when looked at by the Crashdump Viewer tool.</source>
          <target state="translated">현재 코드에 대한 컴파일 정보 (옵션). 이 필드는 Crashdump Viewer 도구에서 볼 때 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="a25315637952f3b953fbd470f3a3c029d30dbf7d" translate="yes" xml:space="preserve">
          <source>Compilation information (options) for the old code, if any. This field is decoded when looked at by the Crashdump Viewer tool.</source>
          <target state="translated">이전 코드에 대한 컴파일 정보 (옵션) 이 필드는 Crashdump Viewer 도구에서 볼 때 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="d203fe989b06cd0b7f625aaf8b091fd82d85ba33" translate="yes" xml:space="preserve">
          <source>Compilation of Latin-1 Encoded Erlang Files</source>
          <target state="translated">Latin-1로 인코딩 된 Erlang 파일 컴파일</target>
        </trans-unit>
        <trans-unit id="c2f3e610efaad31893ca9eea02ebda3f70c91261" translate="yes" xml:space="preserve">
          <source>Compile</source>
          <target state="translated">Compile</target>
        </trans-unit>
        <trans-unit id="f42e39dc3bb6eb7ec13af5ff3a369d976c404115" translate="yes" xml:space="preserve">
          <source>Compile a single dictionary file to Erlang source. Valid options are as follows.</source>
          <target state="translated">단일 사전 파일을 Erlang 소스로 컴파일하십시오. 유효한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5dd3dcb33be1e0a1c396852da6964c746cfd4a25" translate="yes" xml:space="preserve">
          <source>Compile a single dictionary file. The input &lt;code&gt;File&lt;/code&gt; can be either a path or a literal dictionary, the occurrence of newline (ascii NL) or carriage return (ascii CR) identifying the latter. &lt;code&gt;Opt&lt;/code&gt; determines the format of the results and whether they are written to file or returned, and can have the following types.</source>
          <target state="translated">단일 사전 파일을 컴파일하십시오. 입력 &lt;code&gt;File&lt;/code&gt; 은 경로 또는 리터럴 사전, 개행 (ascii NL) 또는 후자를 식별하는 캐리지 리턴 (ascii CR) 일 수 있습니다. &lt;code&gt;Opt&lt;/code&gt; 는 결과 형식과 결과를 파일에 기록할지 또는 리턴 할지를 결정하며 다음 유형을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea40bcb5b571a74df14353da32099a206afadd67" translate="yes" xml:space="preserve">
          <source>Compile a syntax tree or list of syntax trees representing a module and load the resulting module into memory.</source>
          <target state="translated">모듈을 나타내는 구문 트리 또는 구문 트리 목록을 컴파일하고 결과 모듈을 메모리에로드하십시오.</target>
        </trans-unit>
        <trans-unit id="d9cce07b3061f732b7e01783d96813c2407e1405" translate="yes" xml:space="preserve">
          <source>Compile a syntax tree or list of syntax trees representing a module into a binary BEAM object.</source>
          <target state="translated">모듈을 나타내는 구문 트리 또는 구문 트리 목록을 이진 BEAM 객체로 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="a375aba3b710980768146495139b7af7d643a217" translate="yes" xml:space="preserve">
          <source>Compile and test can look as follows (on Linux):</source>
          <target state="translated">컴파일 및 테스트는 다음과 같습니다 (Linux).</target>
        </trans-unit>
        <trans-unit id="efeb9236240ba18a33a232714ad55f1346882865" translate="yes" xml:space="preserve">
          <source>Compile and test:</source>
          <target state="translated">컴파일 및 테스트 :</target>
        </trans-unit>
        <trans-unit id="009e13386fb7dcb403518ae79beff433bc904f14" translate="yes" xml:space="preserve">
          <source>Compile the file:</source>
          <target state="translated">파일을 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="aac1b086ee049c8040c4f4f36d211fd3ac0e1a0c" translate="yes" xml:space="preserve">
          <source>Compile-Time Functions</source>
          <target state="translated">컴파일 시간 함수</target>
        </trans-unit>
        <trans-unit id="95ffe53acbea5b747afd3e7842a4f96dca8af0d9" translate="yes" xml:space="preserve">
          <source>Compile-time errors</source>
          <target state="translated">컴파일 타임 에러</target>
        </trans-unit>
        <trans-unit id="db2b08b37977716ce6fab5afd8fb8ea79479ade1" translate="yes" xml:space="preserve">
          <source>Compile:</source>
          <target state="translated">Compile:</target>
        </trans-unit>
        <trans-unit id="0cb4d20a7b6c25fd2b85e979b6e35af9c0c13cf6" translate="yes" xml:space="preserve">
          <source>Compiled HiPE code can be loaded on the exact same build of ERTS that was used when compiling the code. It might however work on other builds, the emulator verifies checksums in order to determine if it can load the code or not. Note that HiPE has some limitations. For more information see the documentation of the &lt;code&gt;HiPE&lt;/code&gt; application.</source>
          <target state="translated">컴파일 된 HiPE 코드는 코드를 컴파일 할 때 사용한 것과 동일한 ERTS 빌드에로드 할 수 있습니다. 그러나 다른 빌드에서는 작동 할 수 있으며 에뮬레이터는 코드를로드 할 수 있는지 여부를 확인하기 위해 체크섬을 확인합니다. HiPE에는 몇 가지 제한 사항이 있습니다. 자세한 내용은 &lt;code&gt;HiPE&lt;/code&gt; 응용 프로그램 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="af4e4bc880ca00160a867f75ea5f3ae2220aada2" translate="yes" xml:space="preserve">
          <source>Compiled code can be loaded on at least two subsequent releases.</source>
          <target state="translated">컴파일 된 코드는 두 개 이상의 후속 릴리스에서로드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="341a20e237ff5c4b89204a3d4d8c8af5f8aa63bb" translate="yes" xml:space="preserve">
          <source>Compiler</source>
          <target state="translated">Compiler</target>
        </trans-unit>
        <trans-unit id="d95945f4aa5cbbd91cada4bcabf68e0085672573" translate="yes" xml:space="preserve">
          <source>Compiler -- GNU C Compiler, &lt;code&gt;gcc&lt;/code&gt; or the C compiler frontend for LLVM, &lt;code&gt;clang&lt;/code&gt;.</source>
          <target state="translated">컴파일러-GNU C 컴파일러, &lt;code&gt;gcc&lt;/code&gt; 또는 LLVM 용 c 컴파일러 프론트 엔드 &lt;code&gt;clang&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af2c88bc48b05cd87b47590ea9db1fa862bf9e68" translate="yes" xml:space="preserve">
          <source>Compiler options. &lt;code&gt;Options&lt;/code&gt; is a single option or a list of options. This attribute is added to the option list when compiling the module. See the &lt;code&gt; compile(3)&lt;/code&gt; manual page in Compiler.</source>
          <target state="translated">컴파일러 옵션. &lt;code&gt;Options&lt;/code&gt; 은 단일 옵션 또는 옵션 목록입니다. 이 속성은 모듈을 컴파일 할 때 옵션 목록에 추가됩니다. 컴파일러 의 &lt;code&gt; compile(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1fd7d8f9a4971282aa3f0cede9ec0a2e34e9a6cd" translate="yes" xml:space="preserve">
          <source>Compiler options. &lt;code&gt;Options&lt;/code&gt; is a single option or a list of options. This attribute is added to the option list when compiling the module. See the &lt;code&gt;compile(3)&lt;/code&gt; manual page in Compiler.</source>
          <target state="translated">컴파일러 옵션. &lt;code&gt;Options&lt;/code&gt; 은 단일 옵션 또는 옵션 목록입니다. 이 속성은 모듈을 컴파일 할 때 옵션 목록에 추가됩니다. 컴파일러 의 &lt;code&gt;compile(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a97122f5c3385cf8819c76cad4ef6fc4b08ceea9" translate="yes" xml:space="preserve">
          <source>Compiles a list of files by calling &lt;code&gt;compile:file(File, [report_errors, report_warnings])&lt;/code&gt; for each &lt;code&gt;File&lt;/code&gt; in &lt;code&gt;Files&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Files&lt;/code&gt; 의 각 &lt;code&gt;File&lt;/code&gt; 에 대해 &lt;code&gt;compile:file(File, [report_errors, report_warnings])&lt;/code&gt; 을 호출하여 파일 목록을 컴파일합니다 .</target>
        </trans-unit>
        <trans-unit id="e2047a2918cfe55f2b26d89d11edcfd3cd059df3" translate="yes" xml:space="preserve">
          <source>Compiles a module for Cover analysis. The module is given by its module name &lt;code&gt;Module&lt;/code&gt; or by its file name &lt;code&gt;File&lt;/code&gt;. The &lt;code&gt;.erl&lt;/code&gt; extension may be omitted. If the module is located in another directory, the path has to be specified.</source>
          <target state="translated">커버 분석을위한 모듈을 컴파일합니다. 모듈은 모듈 이름 &lt;code&gt;Module&lt;/code&gt; 또는 파일 이름 &lt;code&gt;File&lt;/code&gt; 로 제공 됩니다. &lt;code&gt;.erl&lt;/code&gt; 의 확장은 생략 될 수있다. 모듈이 다른 디렉토리에있는 경우 경로를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0d35e2cea0ebf58ea7da0c0e5ae037788aeac63" translate="yes" xml:space="preserve">
          <source>Compiles a regular expression, with the syntax described below, into an internal format to be used later as a parameter to &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">아래에 설명 된 구문을 사용하여 정규 표현식을 내부 형식으로 컴파일하여 나중에 &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 의 매개 변수로 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="b4b4b69ed812b4e7ab7f1e6412e22181177a9748" translate="yes" xml:space="preserve">
          <source>Compiles a trace into raw profile data held by the &lt;code&gt;fprof&lt;/code&gt; server.</source>
          <target state="translated">추적을 &lt;code&gt;fprof&lt;/code&gt; 서버가 보유한 원시 프로파일 데이터로 컴파일 합니다.</target>
        </trans-unit>
        <trans-unit id="496d11b730a6b29cbd65fce7dff2e32330c8cd8d" translate="yes" xml:space="preserve">
          <source>Compiles all modules (&lt;code&gt;.beam&lt;/code&gt; files) in a directory &lt;code&gt;Dir&lt;/code&gt; for Cover analysis the same way as &lt;code&gt;compile_beam/1&lt;/code&gt; and returns a list with the return values.</source>
          <target state="translated">&lt;code&gt;compile_beam/1&lt;/code&gt; 과 같은 방식으로 디렉토리 분석을 위해 디렉토리 &lt;code&gt;Dir&lt;/code&gt; 의 모든 모듈 ( &lt;code&gt;.beam&lt;/code&gt; 파일)을 컴파일 하고 리턴 값이있는 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c5f842551ac6a97b456ee17b4a34923a2c160458" translate="yes" xml:space="preserve">
          <source>Compiles all modules (&lt;code&gt;.erl&lt;/code&gt; files) in a directory &lt;code&gt;Dir&lt;/code&gt; for Cover analysis the same way as &lt;code&gt;compile_module/1,2&lt;/code&gt; and returns a list with the return values.</source>
          <target state="translated">&lt;code&gt;compile_module/1,2&lt;/code&gt; 와 같은 방식으로 디렉토리 분석을 위해 디렉토리 &lt;code&gt;Dir&lt;/code&gt; 의 모든 모듈 ( &lt;code&gt;.erl&lt;/code&gt; 파일)을 컴파일 하고 리턴 값이있는 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="309f0ca1eb953e1fbbdcae7b61062e795ffa7fa7" translate="yes" xml:space="preserve">
          <source>Compiles and then loads the code for a file on all nodes. &lt;code&gt;Options&lt;/code&gt; defaults to &lt;code&gt;[]&lt;/code&gt;. Compilation is equivalent to:</source>
          <target state="translated">모든 노드에서 파일의 코드를 컴파일 한 다음로드합니다. &lt;code&gt;Options&lt;/code&gt; 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다. 컴파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="221e138541a5626106fb43c92947e2167555dd13" translate="yes" xml:space="preserve">
          <source>Compiles and then purges and loads the code for a module. &lt;code&gt;Module&lt;/code&gt; can be either a module name or a source file path, with or without &lt;code&gt;.erl&lt;/code&gt; extension. &lt;code&gt;Options&lt;/code&gt; defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">모듈의 코드를 컴파일 한 후 제거하고로드합니다. &lt;code&gt;Module&lt;/code&gt; 은 &lt;code&gt;.erl&lt;/code&gt; 확장자 가 있거나없는 모듈 이름 또는 소스 파일 경로 일 수 있습니다 . &lt;code&gt;Options&lt;/code&gt; 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b52f93d9afc3e00c08182aa65070b9ab7d1d8892" translate="yes" xml:space="preserve">
          <source>Compiles one or more files. The files must include the extension, for example, &lt;code&gt;.erl&lt;/code&gt; for Erlang source code, or &lt;code&gt;.yrl&lt;/code&gt; for Yecc source code. &lt;code&gt;Erlc&lt;/code&gt; uses the extension to invoke the correct compiler.</source>
          <target state="translated">하나 이상의 파일을 컴파일합니다. 파일은 예를 들어 확장, 포함해야 &lt;code&gt;.erl&lt;/code&gt; 얼랑 소스 코드에 대한, 또는 &lt;code&gt;.yrl&lt;/code&gt; Yecc 소스 코드를. &lt;code&gt;Erlc&lt;/code&gt; 는 확장을 사용하여 올바른 컴파일러를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="34fed5154618994778a93f6748ba20015380e577" translate="yes" xml:space="preserve">
          <source>Compiles the &lt;code&gt;ASN.1&lt;/code&gt; module &lt;code&gt;Asn1module&lt;/code&gt; and generates an Erlang module &lt;code&gt;Asn1module.erl&lt;/code&gt; with encode and decode functions for the types defined in &lt;code&gt;Asn1module&lt;/code&gt;. For each ASN.1 value defined in the module, an Erlang function that returns the value in Erlang representation is generated.</source>
          <target state="translated">컴파일 &lt;code&gt;ASN.1&lt;/code&gt; 의 모듈 &lt;code&gt;Asn1module&lt;/code&gt; 을 하고 얼랑 생성 모듈 &lt;code&gt;Asn1module.erl&lt;/code&gt; 를 정의 된 유형의 인코딩 및 디코딩 기능 &lt;code&gt;Asn1module&lt;/code&gt; . 모듈에 정의 된 각 ASN.1 값에 대해 Erlang 표현으로 값을 리턴하는 Erlang 함수가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="9bedf3a45a5ce0a8899ba240ac388512ac570574" translate="yes" xml:space="preserve">
          <source>Compiles the code in the file &lt;code&gt;File&lt;/code&gt;, which is an Erlang source code file without the &lt;code&gt;.erl&lt;/code&gt; extension. &lt;code&gt;Options&lt;/code&gt; determine the behavior of the compiler.</source>
          <target state="translated">&lt;code&gt;.erl&lt;/code&gt; 확장자가 없는 Erlang 소스 코드 파일 인 &lt;code&gt;File&lt;/code&gt; 파일 의 코드를 컴파일합니다 . &lt;code&gt;Options&lt;/code&gt; 은 컴파일러의 동작을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="b15b4a0ca80870d899887848b2b561183d48d68e" translate="yes" xml:space="preserve">
          <source>Compiles the escript regardless of the value of the mode attribute.</source>
          <target state="translated">mode 속성 값에 관계없이 escript를 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="69570f1327b6c981b9e63bb2091b8f905c42561a" translate="yes" xml:space="preserve">
          <source>Compiles the escript using flag &lt;code&gt;+native&lt;/code&gt;.</source>
          <target state="translated">flag &lt;code&gt;+native&lt;/code&gt; 를 사용하여 escript를 컴파일합니다 .</target>
        </trans-unit>
        <trans-unit id="eac85df8f89173db1370c40338429031ded73b0b" translate="yes" xml:space="preserve">
          <source>Compiles the files with property tests in the subdirectory &lt;code&gt;property_test&lt;/code&gt;</source>
          <target state="translated">하위 디렉토리의 속성 테스트와 파일을 컴파일 &lt;code&gt;property_test&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e841c656ad6e0af5f7245e7bfda8da0570795473" translate="yes" xml:space="preserve">
          <source>Compiles the specified MIB file &lt;code&gt;&amp;lt;File&amp;gt;.mib&lt;/code&gt;. The compiled file &lt;code&gt;BinFileName&lt;/code&gt; is called &lt;code&gt;&amp;lt;File&amp;gt;.bin&lt;/code&gt;.</source>
          <target state="translated">지정된 MIB 파일 &lt;code&gt;&amp;lt;File&amp;gt;.mib&lt;/code&gt; 를 컴파일합니다 . 컴파일 된 파일 &lt;code&gt;BinFileName&lt;/code&gt; 은 &lt;code&gt;&amp;lt;File&amp;gt;.bin&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1dbd42cde4e636dbd5d9f39210c69452d50ba1ef" translate="yes" xml:space="preserve">
          <source>Compiles the specified modules and then terminates (with non-zero exit code if the compilation of some file did not succeed). Implies &lt;code&gt;-noinput&lt;/code&gt;.</source>
          <target state="translated">지정된 모듈을 컴파일 한 다음 종료합니다 (일부 파일의 컴파일에 실패한 경우 0이 아닌 종료 코드로). &lt;code&gt;-noinput&lt;/code&gt; 을 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="79f1604d887e21632c6157fb43c6ea0b3900d23f" translate="yes" xml:space="preserve">
          <source>Compiles using the SMP emulator. This is mainly useful for compiling native code, which must be compiled with the same runtime system that it is to be run on.</source>
          <target state="translated">SMP 에뮬레이터를 사용하여 컴파일합니다. 이는 기본 코드를 컴파일 할 때 유용하며, 실행되는 동일한 런타임 시스템으로 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="e47fc7a0773cbda86f40b163702495db6f23084c" translate="yes" xml:space="preserve">
          <source>Compiling &lt;code&gt;GUI.asn&lt;/code&gt; including the configuration file is done as follows:</source>
          <target state="translated">구성 파일을 포함한 &lt;code&gt;GUI.asn&lt;/code&gt; 컴파일 은 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a3590c7d935d1337384ebe30d0a63b8449a7f0a4" translate="yes" xml:space="preserve">
          <source>Compiling the code:</source>
          <target state="translated">코드 컴파일</target>
        </trans-unit>
        <trans-unit id="c5d3843d2d607e7b8047f8ec33a050336d9069e4" translate="yes" xml:space="preserve">
          <source>Compiling the regular expression before matching is useful if the same expression is to be used in matching against multiple subjects during the lifetime of the program. Compiling once and executing many times is far more efficient than compiling each time one wants to match.</source>
          <target state="translated">일치하는 정규식을 컴파일하는 것은 프로그램 수명 동안 여러 주제에 대해 동일한 표현식을 사용하는 경우에 유용합니다. 한 번 컴파일하고 여러 번 실행하는 것이 일치 할 때마다 컴파일하는 것보다 훨씬 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="39f435fa5106d5274aa216c6cabba9fe1af576c6" translate="yes" xml:space="preserve">
          <source>Compiling this code to beam assembly (&lt;code&gt;erlc -S&lt;/code&gt;) shows exactly what is happening.</source>
          <target state="translated">이 코드를 빔 어셈블리 ( &lt;code&gt;erlc -S&lt;/code&gt; ) 로 컴파일하면 정확히 무슨 일이 일어나고 있는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="fc4c343469cc1bbf3a31e4474cfc268fdaa2a44f" translate="yes" xml:space="preserve">
          <source>Compiling this gives the following diagnostic:</source>
          <target state="translated">이것을 컴파일하면 다음과 같은 진단이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3930914f8b99e680a55bb03e16d8af9eb69ff2ea" translate="yes" xml:space="preserve">
          <source>Compiling your code for use with &lt;code&gt;Erl_Interface&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Erl_Interface&lt;/code&gt; 와 함께 사용할 코드 컴파일</target>
        </trans-unit>
        <trans-unit id="2ee8aa4143f8abfd86b424e473e8462be5d52390" translate="yes" xml:space="preserve">
          <source>Complex objects</source>
          <target state="translated">복잡한 객체</target>
        </trans-unit>
        <trans-unit id="06e63f260804216a398baf6f2e442df9c9a6cef2" translate="yes" xml:space="preserve">
          <source>Complexity Note</source>
          <target state="translated">복잡성 참고</target>
        </trans-unit>
        <trans-unit id="9fb27df4e27c00aa8eb364ebe6cbe8b7f432000e" translate="yes" xml:space="preserve">
          <source>Complicated non-real-time queries mainly for operation and maintenance</source>
          <target state="translated">주로 운영 및 유지 관리를위한 복잡한 비 실시간 쿼리</target>
        </trans-unit>
        <trans-unit id="ce8d8f8862e358aa8505e89d95cb74cadb849673" translate="yes" xml:space="preserve">
          <source>Complicated or circular dependencies can make it difficult or even impossible to decide in which order things must be done without risking runtime errors during an upgrade or downgrade. Dependencies can be:</source>
          <target state="translated">복잡하거나 순환적인 종속성으로 인해 업그레이드 또는 다운 그레이드 중 런타임 오류의 위험없이 수행 할 순서를 결정하기 어렵거나 불가능할 수 있습니다. 종속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59fca003467aad58f9b2b7e565b2ce3c84cd8c99" translate="yes" xml:space="preserve">
          <source>Composes a form-urlencoded &lt;code&gt;QueryString&lt;/code&gt; based on a &lt;code&gt;QueryList&lt;/code&gt;, a list of non-percent-encoded key-value pairs. Form-urlencoding is defined in section 4.10.21.6 of the &lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html52/&quot;&gt;HTML 5.2&lt;/a&gt;&lt;/code&gt; specification and in section 4.10.22.6 of the &lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html50/&quot;&gt;HTML 5.0&lt;/a&gt;&lt;/code&gt; specification for non-UTF-8 encodings.</source>
          <target state="translated">퍼센트가 인코딩되지 않은 키-값 쌍의 목록 인 &lt;code&gt;QueryList&lt;/code&gt; 를 기반으로 양식 -urlencoded &lt;code&gt;QueryString&lt;/code&gt; 을 구성합니다 . Form-urlencoding은 &lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html52/&quot;&gt;HTML 5.2&lt;/a&gt;&lt;/code&gt; 사양의 4.10.21.6 섹션과 비 UTF-8 인코딩에 대한 &lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html50/&quot;&gt;HTML 5.0&lt;/a&gt;&lt;/code&gt; 사양의 4.10.22.6 섹션에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1c2faea65f93de909779259387dfd62954a59b1" translate="yes" xml:space="preserve">
          <source>Composing form-urlencoded query strings from a list of key-value pairs</source>
          <target state="translated">키-값 쌍의 목록에서 양식으로 인코딩 된 쿼리 문자열 작성</target>
        </trans-unit>
        <trans-unit id="c0f6771c0b4ff62b75c5e9a377f7512f8a2eb0a7" translate="yes" xml:space="preserve">
          <source>Composite terms can be constructed in the &lt;code&gt;Result&lt;/code&gt; part either by simply writing a list, so that the following code:</source>
          <target state="translated">다음 코드를 작성하기 위해 목록을 작성 하여 &lt;code&gt;Result&lt;/code&gt; 부분 에 복합 용어를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1fe0eda1d9e3db81360d76b01700f1fc22578fac" translate="yes" xml:space="preserve">
          <source>Compress a megaco component. The erlang dist encoder makes no assumption on the how or even if the component is compressed.</source>
          <target state="translated">megaco 구성 요소를 압축하십시오. erlang dist 엔코더는 구성 요소가 압축되는 방법 또는 경우에 대해 가정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a0fa988cf443cd1d375271986427ec83de3c3de" translate="yes" xml:space="preserve">
          <source>Compresses as much data as possible, and stops when the input buffer becomes empty. It can introduce some output latency (reading input without producing any output) except when forced to flush.</source>
          <target state="translated">가능한 많은 데이터를 압축하고 입력 버퍼가 비면 중지합니다. 강제로 플러시 할 때를 제외하고 출력 대기 시간 (출력을 생성하지 않고 입력 읽기)이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca1de065e72e8ca9af3242c8e400cc65d7c65430" translate="yes" xml:space="preserve">
          <source>Compresses data with gz headers and checksum.</source>
          <target state="translated">gz 헤더와 체크섬으로 데이터를 압축합니다.</target>
        </trans-unit>
        <trans-unit id="5c0f619cd36dba9bac61586e413cccabc45aa3bd" translate="yes" xml:space="preserve">
          <source>Compresses data with zlib headers and checksum.</source>
          <target state="translated">zlib 헤더와 체크섬으로 데이터를 압축합니다.</target>
        </trans-unit>
        <trans-unit id="f32171029d67c841b304fa7802dd10659367b936" translate="yes" xml:space="preserve">
          <source>Compresses data without zlib headers and checksum.</source>
          <target state="translated">zlib 헤더 및 체크섬없이 데이터를 압축합니다.</target>
        </trans-unit>
        <trans-unit id="3dd49034da5c932029f1472e527e8712ce79873f" translate="yes" xml:space="preserve">
          <source>Compression is not supported.</source>
          <target state="translated">압축은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db573c49060217e5ae7cad606cbcc07e7a832439" translate="yes" xml:space="preserve">
          <source>Compression level to use:</source>
          <target state="translated">사용할 압축 수준 :</target>
        </trans-unit>
        <trans-unit id="e004f4ec54c1bdeeaf01ade20386a509b0f50f4b" translate="yes" xml:space="preserve">
          <source>Compression method to use, currently the only supported method is &lt;code&gt;deflated&lt;/code&gt;.</source>
          <target state="translated">사용하는 압축 방법은 현재 지원되는 유일한 방법은 &lt;code&gt;deflated&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6150f090d8e22866c8af7ff2aba307952a5dde62" translate="yes" xml:space="preserve">
          <source>Computers in general</source>
          <target state="translated">일반적으로 컴퓨터</target>
        </trans-unit>
        <trans-unit id="8617e2409a9b5d81fedafe4823179428b5db9db3" translate="yes" xml:space="preserve">
          <source>Computes a CMAC of type &lt;code&gt;Type&lt;/code&gt; from &lt;code&gt;Data&lt;/code&gt; using &lt;code&gt;Key&lt;/code&gt; as the authentication key.</source>
          <target state="translated">형의 CMAC 계산 &lt;code&gt;Type&lt;/code&gt; 에서 &lt;code&gt;Data&lt;/code&gt; 사용하여 &lt;code&gt;Key&lt;/code&gt; 인증 키로는.</target>
        </trans-unit>
        <trans-unit id="5ef091378f6011f32b08cfa86037d11d3811847d" translate="yes" xml:space="preserve">
          <source>Computes a HMAC of type &lt;code&gt;Type&lt;/code&gt; from &lt;code&gt;Data&lt;/code&gt; using &lt;code&gt;Key&lt;/code&gt; as the authentication key.</source>
          <target state="translated">형의 HMAC 계산 &lt;code&gt;Type&lt;/code&gt; 에서 &lt;code&gt;Data&lt;/code&gt; 사용하여 &lt;code&gt;Key&lt;/code&gt; 인증 키로는.</target>
        </trans-unit>
        <trans-unit id="57b5d4d63f3cc072fe01656f61d82df0a950c2ad" translate="yes" xml:space="preserve">
          <source>Computes a MAC (Message Authentication Code) as &lt;code&gt;&lt;a href=&quot;#mac-3&quot;&gt;mac/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#mac-4&quot;&gt;mac/4&lt;/a&gt;&lt;/code&gt; but &lt;code&gt;MacLength&lt;/code&gt; will limit the size of the resultant &lt;code&gt;Mac&lt;/code&gt; to at most &lt;code&gt;MacLength&lt;/code&gt; bytes. Note that if &lt;code&gt;MacLength&lt;/code&gt; is greater than the actual number of bytes returned from the underlying hash, the returned hash will have that shorter length instead.</source>
          <target state="translated">MAC (메시지 인증 코드)를 &lt;code&gt;&lt;a href=&quot;#mac-3&quot;&gt;mac/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#mac-4&quot;&gt;mac/4&lt;/a&gt;&lt;/code&gt; 로 계산 하지만 &lt;code&gt;MacLength&lt;/code&gt; 는 결과 &lt;code&gt;Mac&lt;/code&gt; 의 크기 를 최대 &lt;code&gt;MacLength&lt;/code&gt; 바이트 로 제한 합니다. 경우주의 &lt;code&gt;MacLength&lt;/code&gt; 은 기본 해시에서 반환 된 실제 바이트 수보다 큰 경우, 반환 된 해시 대신에 짧은 길이있을 것이다.</target>
        </trans-unit>
        <trans-unit id="b42e2ec67691e90be353f3e69f72f115d660a04c" translate="yes" xml:space="preserve">
          <source>Computes a MAC (Message Authentication Code) of type &lt;code&gt;Type&lt;/code&gt; from &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Data&lt;/code&gt; 에서 유형 &lt;code&gt;Type&lt;/code&gt; 의 MAC (메시지 인증 코드)를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="53549f7a7603013142bc34dff7ebedfb36946cc7" translate="yes" xml:space="preserve">
          <source>Computes a POLY1305 message authentication code (&lt;code&gt;Mac&lt;/code&gt;) from &lt;code&gt;Data&lt;/code&gt; using &lt;code&gt;Key&lt;/code&gt; as the authentication key.</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; 를 인증 키로 사용하여 &lt;code&gt;Data&lt;/code&gt; 에서 POLY1305 메시지 인증 코드 ( &lt;code&gt;Mac&lt;/code&gt; )를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="e7c1891feac89cb6aa9a784a894b9b7b9608ba45" translate="yes" xml:space="preserve">
          <source>Computes a layout for a document and returns the corresponding text. See &lt;code&gt;&lt;a href=&quot;#type-document&quot;&gt;document()&lt;/a&gt;&lt;/code&gt; for further information. Throws &lt;code&gt;no_layout&lt;/code&gt; if no layout could be selected.</source>
          <target state="translated">문서의 레이아웃을 계산하고 해당 텍스트를 반환합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#type-document&quot;&gt;document()&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 . 예외 &lt;code&gt;no_layout&lt;/code&gt; 어떤 레이아웃을 선택하지 수 있다면.</target>
        </trans-unit>
        <trans-unit id="f4a91015bc370126d2bc5a10fd6fba142f0c14d1" translate="yes" xml:space="preserve">
          <source>Computes a message digest of type &lt;code&gt;Type&lt;/code&gt; from &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Data&lt;/code&gt; 에서 &lt;code&gt;Type&lt;/code&gt; 유형 의 메시지 요약을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="cf90dde8a0d4f759f93b97dc9e424324bb51d514" translate="yes" xml:space="preserve">
          <source>Computes an MD5 message digest from &lt;code&gt;Data&lt;/code&gt;, where the length of the digest is 128 bits (16 bytes). &lt;code&gt;Data&lt;/code&gt; is a binary or a list of small integers and binaries.</source>
          <target state="translated">&lt;code&gt;Data&lt;/code&gt; 에서 MD5 메시지 다이제스트를 계산합니다. 다이제스트 의 길이는 128 비트 (16 바이트)입니다. &lt;code&gt;Data&lt;/code&gt; 는 이진 또는 작은 정수 및 이진의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="c22b3bee40e516d5a07e21c574ff4a1f0971eb34" translate="yes" xml:space="preserve">
          <source>Computes and returns the adler32 checksum for &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Data&lt;/code&gt; 의 adler32 체크섬을 계산하고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a2abd766c0d5933f47abe70569d16c6d23d728d1" translate="yes" xml:space="preserve">
          <source>Computes and returns the crc32 (IEEE 802.3 style) checksum for &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Data&lt;/code&gt; 의 crc32 (IEEE 802.3 스타일) 체크섬을 계산하고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5bc8ee5e263121b926d2d7cc593061f196c30372" translate="yes" xml:space="preserve">
          <source>Computes shared secret.</source>
          <target state="translated">공유 비밀을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="acb13ad633fa39b9539693d88f8804c8d59f95c0" translate="yes" xml:space="preserve">
          <source>Computes the date and time from the specified number of gregorian seconds.</source>
          <target state="translated">지정된 gregorian 초 수에서 날짜와 시간을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="1a60d1d8512d9b43f58c2fa78c69c36bd98988a7" translate="yes" xml:space="preserve">
          <source>Computes the date from the specified number of gregorian days.</source>
          <target state="translated">지정된 gregorian 일 수에서 날짜를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="6fd928a5422a42545d3f8009960a129cf04f4b60" translate="yes" xml:space="preserve">
          <source>Computes the day of the week from the specified &lt;code&gt;Year&lt;/code&gt;, &lt;code&gt;Month&lt;/code&gt;, and &lt;code&gt;Day&lt;/code&gt;. Returns the day of the week as &lt;code&gt;1&lt;/code&gt;: Monday, &lt;code&gt;2&lt;/code&gt;: Tuesday, and so on.</source>
          <target state="translated">지정된 &lt;code&gt;Year&lt;/code&gt; , &lt;code&gt;Month&lt;/code&gt; 및 &lt;code&gt;Day&lt;/code&gt; 에서 요일을 계산합니다 . 요일을 &lt;code&gt;1&lt;/code&gt; : 월요일, &lt;code&gt;2&lt;/code&gt; : 화요일 등 으로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6bb723f7731befec282ae7ca53f445d61b40a18f" translate="yes" xml:space="preserve">
          <source>Computes the function &lt;code&gt;N^P mod M&lt;/code&gt;.</source>
          <target state="translated">함수 &lt;code&gt;N^P mod M&lt;/code&gt; 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="99dc499279c70ed65d6985615f527cb1c6eca26f" translate="yes" xml:space="preserve">
          <source>Computes the number of days in a month.</source>
          <target state="translated">한 달의 일 수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="1fa973e390e7f2a427dcdf5a3027ba7dbec27578" translate="yes" xml:space="preserve">
          <source>Computes the number of gregorian days starting with year 0 and ending at the specified date.</source>
          <target state="translated">0 년부터 시작하여 지정된 날짜에 끝나는 gregorian 일 수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="460e100ab696f364fd9d5ba6fb8d34bc03d60b0c" translate="yes" xml:space="preserve">
          <source>Computes the number of gregorian seconds starting with year 0 and ending at the specified date and time.</source>
          <target state="translated">0 년부터 시작하여 지정된 날짜와 시간에 끝나는 그레고리 안 초 수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="c47a52a2c77fbf69039f5e7a1c102eeafa864720" translate="yes" xml:space="preserve">
          <source>Computes the shared secret from the private key and the other party's public key. See also &lt;code&gt;public_key:compute_key/2&lt;/code&gt;</source>
          <target state="translated">개인 키와 상대방의 공개 키에서 공유 비밀을 계산합니다. &lt;code&gt;public_key:compute_key/2&lt;/code&gt; 도 참조하십시오</target>
        </trans-unit>
        <trans-unit id="19647b47d421a4ceb33442c666abcffa1275beb1" translate="yes" xml:space="preserve">
          <source>Computes the time from the specified number of seconds. &lt;code&gt;Seconds&lt;/code&gt; must be less than the number of seconds per day (86400).</source>
          <target state="translated">지정된 시간 (초)에서 시간을 계산합니다. &lt;code&gt;Seconds&lt;/code&gt; 는 하루 초 수 (86400)보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="72e55071de1b7db1194725444c44c89aad5472b9" translate="yes" xml:space="preserve">
          <source>Concatenates &lt;code&gt;String1&lt;/code&gt; and &lt;code&gt;String2&lt;/code&gt; to form a new string &lt;code&gt;String3&lt;/code&gt;, which is returned.</source>
          <target state="translated">&lt;code&gt;String1&lt;/code&gt; 과 &lt;code&gt;String2&lt;/code&gt; 를 연결 하여 새로운 문자열 &lt;code&gt;String3&lt;/code&gt; 을 형성합니다 .</target>
        </trans-unit>
        <trans-unit id="c2fd259e1eeb55c9d34cb9be26a6c2f75fe45818" translate="yes" xml:space="preserve">
          <source>Concatenates all text nodes within the tree.</source>
          <target state="translated">트리 내의 모든 텍스트 노드를 연결합니다.</target>
        </trans-unit>
        <trans-unit id="9abfe77881130796df1a67c0daaf938195db3463" translate="yes" xml:space="preserve">
          <source>Concatenates documents horizontally. Returns a document representing the concatenation of the documents &lt;code&gt;D1&lt;/code&gt; and &lt;code&gt;D2&lt;/code&gt; such that the last character of &lt;code&gt;D1&lt;/code&gt; is horizontally adjacent to the first character of &lt;code&gt;D2&lt;/code&gt;, in all possible layouts. (Note: any indentation of &lt;code&gt;D2&lt;/code&gt; is lost.)</source>
          <target state="translated">문서를 가로로 연결합니다. 가능한 모든 레이아웃에서 &lt;code&gt;D1&lt;/code&gt; 의 마지막 문자가 &lt;code&gt;D2&lt;/code&gt; 의 첫 번째 문자에 수평으로 인접하도록 문서 &lt;code&gt;D1&lt;/code&gt; 및 &lt;code&gt;D2&lt;/code&gt; 의 연결을 나타내는 문서를 리턴합니다 . (참고 : &lt;code&gt;D2&lt;/code&gt; 들여 쓰기 가 손실됩니다.)</target>
        </trans-unit>
        <trans-unit id="04e1c1fcf3ff57f50627e79ee514ef9c378133db" translate="yes" xml:space="preserve">
          <source>Concatenates documents vertically. Returns a document representing the concatenation of the documents &lt;code&gt;D1&lt;/code&gt; and &lt;code&gt;D2&lt;/code&gt; such that the first line of &lt;code&gt;D2&lt;/code&gt; follows directly below the last line of &lt;code&gt;D1&lt;/code&gt;, and the first character of &lt;code&gt;D2&lt;/code&gt; is in the same horizontal column as the first character of &lt;code&gt;D1&lt;/code&gt;, in all possible layouts.</source>
          <target state="translated">문서를 세로로 연결합니다. 문서의 연결을 나타내는 문서를 반환 &lt;code&gt;D1&lt;/code&gt; 과 &lt;code&gt;D2&lt;/code&gt; 가 첫 행하도록 &lt;code&gt;D2&lt;/code&gt; 가 직접 마지막 선 아래 다음 &lt;code&gt;D1&lt;/code&gt; 을 , 그리고 첫 문자 &lt;code&gt;D2&lt;/code&gt; 는 첫 문자와 동일한 수평 열에있는 &lt;code&gt;D1&lt;/code&gt; 모든 가능한에서 레이아웃.</target>
        </trans-unit>
        <trans-unit id="d15df121840905ed24abf69eb1607851f11fd815" translate="yes" xml:space="preserve">
          <source>Concatenates the text representation of the elements of &lt;code&gt;Things&lt;/code&gt;. The elements of &lt;code&gt;Things&lt;/code&gt; can be atoms, integers, floats, or strings.</source>
          <target state="translated">&lt;code&gt;Things&lt;/code&gt; 요소의 텍스트 표현을 연결합니다 . &lt;code&gt;Things&lt;/code&gt; 의 요소는 원자, 정수, 부동 또는 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fbd67c45b9474556de6e975213929d8a6a47459" translate="yes" xml:space="preserve">
          <source>Concatenates two Erlang terms, prepending &lt;code&gt;head&lt;/code&gt; onto &lt;code&gt;tail&lt;/code&gt; and thereby creating a &lt;code&gt;cons&lt;/code&gt; cell. To make a proper list, &lt;code&gt;tail&lt;/code&gt; is always to be a list or an empty list. Notice that &lt;code&gt;NULL&lt;/code&gt; is not a valid list.</source>
          <target state="translated">두 개의 Erlang 용어를 연결 하여 &lt;code&gt;head&lt;/code&gt; 를 &lt;code&gt;tail&lt;/code&gt; 에 붙여 &lt;code&gt;cons&lt;/code&gt; 셀 을 만듭니다 . 올바른 목록을 만들려면 &lt;code&gt;tail&lt;/code&gt; 는 항상 목록이거나 빈 목록이어야합니다. 통지 &lt;code&gt;NULL&lt;/code&gt; 이 유효한 목록이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2c186b6b1deba8a770e9e1695542ea581f1d331a" translate="yes" xml:space="preserve">
          <source>Concatenation. It matches &lt;code&gt;r1&lt;/code&gt; and then &lt;code&gt;r2&lt;/code&gt;.</source>
          <target state="translated">연쇄. &lt;code&gt;r1&lt;/code&gt; 과 일치 하고 &lt;code&gt;r2&lt;/code&gt; 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="c05bafdb56031bb64da1f1d1861f60118932c605" translate="yes" xml:space="preserve">
          <source>Concept</source>
          <target state="translated">Concept</target>
        </trans-unit>
        <trans-unit id="4666ff1177aa06dcf2e2acf53d84de400036ddc9" translate="yes" xml:space="preserve">
          <source>Conceptually, a random real number &lt;code&gt;R&lt;/code&gt; is generated from the interval &lt;code&gt;0 =&amp;lt; R &amp;lt; 1&lt;/code&gt; and then the closest rounded down normalized number in the IEEE 754 Double precision format is returned.</source>
          <target state="translated">개념적으로, 난수 &lt;code&gt;R&lt;/code&gt; 은 간격 &lt;code&gt;0 =&amp;lt; R &amp;lt; 1&lt;/code&gt; 에서 생성 된 다음 IEEE 754 배정도 형식에서 가장 가까운 반올림 된 정규화 된 숫자가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d59061815936968cd27ee5eeaae408a473490a5f" translate="yes" xml:space="preserve">
          <source>Conceptually, call tracing works as follows. Inside the Erlang virtual machine, a set of processes and a set of functions are to be traced. If a traced process calls a traced function, the trace action is taken. Otherwise, nothing happens.</source>
          <target state="translated">개념적으로 콜 추적은 다음과 같이 작동합니다. Erlang 가상 머신 내에서 일련의 프로세스 및 기능 세트가 추적됩니다. 추적 된 프로세스가 추적 된 함수를 호출하면 추적 조치가 수행됩니다. 그렇지 않으면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c999b08d7c22c76e1e6dc0faa05064eba3a0394" translate="yes" xml:space="preserve">
          <source>Conceptually, the SSH protocol can be partitioned into four layers:</source>
          <target state="translated">개념적으로 SSH 프로토콜은 4 개의 계층으로 분할 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="74b54106acc00f9f724fe295423167276db3a6a8" translate="yes" xml:space="preserve">
          <source>Conclusion: Avoid values 8 and -8 unless you know your zlib version supports them.</source>
          <target state="translated">결론 : zlib 버전이 값을 지원한다는 것을 모르면 값 8과 -8을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="bca39e22d6b36f574329075fd07dd2629638ff2f" translate="yes" xml:space="preserve">
          <source>Concurrent Programming in Erlang, 2nd Edition (1996), Prentice-Hall, ISBN 0-13-508301-X.</source>
          <target state="translated">Erlang의 동시 프로그래밍, 2 판 (1996), Prentice-Hall, ISBN 0-13-508301-X.</target>
        </trans-unit>
        <trans-unit id="f6aff0ecefa8fcdacfbed141ac66c352f04cf650" translate="yes" xml:space="preserve">
          <source>Concurrent processes in &lt;code&gt;Mnesia&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 의 동시 프로세스</target>
        </trans-unit>
        <trans-unit id="c5814c8062d15de57203bd84567426b16df3f497" translate="yes" xml:space="preserve">
          <source>Condition variable. Used when threads must wait for a specific condition to appear before continuing execution. Condition variables must be used with associated mutexes.</source>
          <target state="translated">조건 변수. 스레드가 실행을 계속하기 전에 특정 조건이 나타날 때까지 기다려야 할 때 사용됩니다. 조건 변수는 관련된 뮤텍스와 함께 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3030b91f9ac5c385e0e5ba58d0f9e9743296576f" translate="yes" xml:space="preserve">
          <source>ConditionExpression ::= ExprMatchVariable | { GuardFunction } | { GuardFunction, ConditionExpression, ... } | TermConstruct</source>
          <target state="translated">ConditionExpression :: = ExprMatchVariable | {GuardFunction} | {GuardFunction, ConditionExpression, ...} | 용어 구성</target>
        </trans-unit>
        <trans-unit id="bbdc9c98e3ac79ef6aaff8d954cf32028d6e4917" translate="yes" xml:space="preserve">
          <source>Conditional Breakpoints</source>
          <target state="translated">조건부 중단 점</target>
        </trans-unit>
        <trans-unit id="290e0b23c3082ece19e13061650a81ca4e400aba" translate="yes" xml:space="preserve">
          <source>Conditional compilation directives</source>
          <target state="translated">조건부 컴파일 지시문</target>
        </trans-unit>
        <trans-unit id="e659f221c6e3ec580224ba7c1c7b2ad09c848aac" translate="yes" xml:space="preserve">
          <source>Config is a list of {Item, Value} tuples. See megaco:user_info/2 about which items and values that are valid.</source>
          <target state="translated">구성은 {Item, Value} 튜플의 목록입니다. 유효한 항목과 값은 megaco : user_info / 2를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6aa237b9ad391aadf182df8ed22f8e2958d1b069" translate="yes" xml:space="preserve">
          <source>Configurable degree of fault tolerance (by replication)</source>
          <target state="translated">구성 가능한 내결함성 수준 (복제)</target>
        </trans-unit>
        <trans-unit id="646e69fcaff68aa4bd99d792ff12c1ed636760b8" translate="yes" xml:space="preserve">
          <source>Configuration API functions</source>
          <target state="translated">구성 API 기능</target>
        </trans-unit>
        <trans-unit id="8d87e87971a9b480182707da39f6dc7de52524b0" translate="yes" xml:space="preserve">
          <source>Configuration Parameters</source>
          <target state="translated">구성 매개 변수</target>
        </trans-unit>
        <trans-unit id="57b4835664f870ac8b56a60f7a98cea5878873e7" translate="yes" xml:space="preserve">
          <source>Configuration data for the formatter. See &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt; logger_formatter(3)&lt;/a&gt;&lt;/code&gt; for an example of a formatter implementation.</source>
          <target state="translated">포맷터의 구성 데이터입니다. 포맷터 구현의 예는 &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt; logger_formatter(3)&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5fe8143de2bd407b7318a9b914132afaf723fced" translate="yes" xml:space="preserve">
          <source>Configuration data for the formatter. See &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; for an example of a formatter implementation.</source>
          <target state="translated">포맷터의 구성 데이터 포맷터 구현 예제는 &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="657e7546b354cf171eeba078e0a7f96bcfb3d842" translate="yes" xml:space="preserve">
          <source>Configuration data may be included in configuration files that is located in the configuration directory. The name of this directory is given in the &lt;code&gt;config_dir&lt;/code&gt; configuration parameter. These files are read at start-up.</source>
          <target state="translated">구성 데이터는 구성 디렉토리에있는 구성 파일에 포함될 수 있습니다. 이 디렉토리의 이름은 &lt;code&gt;config_dir&lt;/code&gt; 구성 매개 변수에 제공됩니다. 이 파일들은 시작할 때 읽습니다.</target>
        </trans-unit>
        <trans-unit id="1df26c4218fb3cc15e90c12f33ffed59b35b1ae8" translate="yes" xml:space="preserve">
          <source>Configuration data values in the CTH can be read by calling &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt;ct:get_config/1,2,3&lt;/a&gt;&lt;/code&gt; (as explained in section &lt;code&gt;&lt;a href=&quot;config_file_chapter#require_config_data&quot;&gt;Requiring and Reading Configuration Data&lt;/a&gt;&lt;/code&gt;). The configuration variables in question must, as always, first have been required by a suite-, group-, or test case information function, or by function &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1/2&lt;/a&gt;&lt;/code&gt;. The latter can also be used in CT hook functions.</source>
          <target state="translated">CTH의 구성 데이터 값은 &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt;ct:get_config/1,2,3&lt;/a&gt;&lt;/code&gt; 을 호출하여 읽을 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;config_file_chapter#require_config_data&quot;&gt;Requiring and Reading Configuration Data&lt;/a&gt;&lt;/code&gt; 섹션에 설명 된대로 ). 문제가되는 구성 변수는 항상 스위트, 그룹 또는 테스트 사례 정보 함수 또는 &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1/2&lt;/a&gt;&lt;/code&gt; 함수에 의해 필요 했어야합니다 . 후자는 CT 후크 기능에도 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acdba8395423767de730ee1b75436df3a0ebc87e" translate="yes" xml:space="preserve">
          <source>Configuration file</source>
          <target state="translated">구성 파일</target>
        </trans-unit>
        <trans-unit id="856e8e09448b31c0b19cccc7d2f429463a65a741" translate="yes" xml:space="preserve">
          <source>Configuration file.</source>
          <target state="translated">구성 파일.</target>
        </trans-unit>
        <trans-unit id="cac911d99944c8d8de85519d3c8353adfa4909ed" translate="yes" xml:space="preserve">
          <source>Configuration files containing sensitive data can be encrypted if they must be stored in open and shared directories.</source>
          <target state="translated">중요한 데이터가 포함 된 구성 파일은 열려있는 공유 디렉토리에 저장해야하는 경우 암호화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="983f322fab3effb7b0bc8474c3b652c0529b254b" translate="yes" xml:space="preserve">
          <source>Configuration function for a group, executed after the last test case. (Optional)</source>
          <target state="translated">마지막 테스트 사례 이후에 실행 된 그룹의 구성 기능. (선택 과목)</target>
        </trans-unit>
        <trans-unit id="4837fc4e4200eba9faee7e5d7a160f74631dd940" translate="yes" xml:space="preserve">
          <source>Configuration function for a group, executed before the first test case. (Optional)</source>
          <target state="translated">첫 번째 테스트 사례 전에 실행 된 그룹의 구성 기능. (선택 과목)</target>
        </trans-unit>
        <trans-unit id="0446d4a5ed9002889e3fcbdb5be7abd84be2a99c" translate="yes" xml:space="preserve">
          <source>Configuration function for a testcase, executed after each test case. (Optional)</source>
          <target state="translated">테스트 케이스에 대한 구성 기능으로, 각 테스트 케이스 후에 실행됩니다. (선택 과목)</target>
        </trans-unit>
        <trans-unit id="bd3c7dde0d6b835f389712e4b422204622e6bba3" translate="yes" xml:space="preserve">
          <source>Configuration function for a testcase, executed before each test case. (Optional)</source>
          <target state="translated">테스트 케이스에 대한 구성 기능으로, 각 테스트 케이스 전에 실행됩니다. (선택 과목)</target>
        </trans-unit>
        <trans-unit id="54eab7708a8f9ac8e547396221ceb06e955d8621" translate="yes" xml:space="preserve">
          <source>Configuration parameter &lt;code&gt;-mnesia dump_log_update_in_place &amp;lt;bool&amp;gt;&lt;/code&gt; controls the safety level of the function &lt;code&gt;&lt;a href=&quot;mnesia#dump_log-0&quot;&gt;mnesia:dump_log()&lt;/a&gt;&lt;/code&gt; By default, &lt;code&gt;Mnesia&lt;/code&gt; dumps the transaction log directly into the &lt;code&gt;DAT&lt;/code&gt; files. If a power failure occurs during the dump, this can cause the randomly accessed &lt;code&gt;DAT&lt;/code&gt; files to become corrupt. If the parameter is set to &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;Mnesia&lt;/code&gt; copies the &lt;code&gt;DAT&lt;/code&gt; files and target the dump to the new temporary files. If the dump is successful, the temporary files are renamed to their normal &lt;code&gt;DAT&lt;/code&gt; suffixes. The possibility for unrecoverable inconsistencies in the data files becomes much smaller with this strategy. However, the actual dumping of the transaction log becomes considerably slower. The system designer must decide whether speed or safety is the higher priority.</source>
          <target state="translated">구성 매개 변수 &lt;code&gt;-mnesia dump_log_update_in_place &amp;lt;bool&amp;gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;mnesia#dump_log-0&quot;&gt;mnesia:dump_log()&lt;/a&gt;&lt;/code&gt; 함수의 안전 레벨을 제어합니다 . 기본적으로 &lt;code&gt;Mnesia&lt;/code&gt; 는 트랜잭션 로그를 &lt;code&gt;DAT&lt;/code&gt; 파일에 직접 덤프 합니다. 덤프 도중 정전이 발생하면 임의로 액세스 한 &lt;code&gt;DAT&lt;/code&gt; 파일이 손상 될 수 있습니다 . 매개 변수가 &lt;code&gt;false&lt;/code&gt; 로 설정 되면 &lt;code&gt;Mnesia&lt;/code&gt; 는 &lt;code&gt;DAT&lt;/code&gt; 파일을 복사 하고 덤프를 새 임시 파일로 대상화 합니다. 덤프가 성공하면 임시 파일 이름이 일반 &lt;code&gt;DAT&lt;/code&gt; 로 바뀝니다.접미사. 이 전략을 사용하면 데이터 파일에서 복구 할 수없는 불일치가 발생할 가능성이 훨씬 줄어 듭니다. 그러나 트랜잭션 로그의 실제 덤프는 상당히 느려집니다. 시스템 설계자는 속도 또는 안전이 우선 순위가 높은지 여부를 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="dbd4d4d025501c16c7f2ccb2570c2099b823b966" translate="yes" xml:space="preserve">
          <source>Configuration parameter values in the configuration file override the values in the application resource files (see &lt;code&gt;&lt;a href=&quot;app&quot;&gt;app(4)&lt;/a&gt;&lt;/code&gt;). The values in the configuration file can be overridden by command-line flags (see &lt;code&gt;erts:erl(1)&lt;/code&gt;).</source>
          <target state="translated">구성 파일의 구성 매개 변수 값은 애플리케이션 자원 파일의 값을 대체합니다 ( &lt;code&gt;&lt;a href=&quot;app&quot;&gt;app(4)&lt;/a&gt;&lt;/code&gt; 참조 ). 구성 파일의 값은 명령 행 플래그로 대체 할 수 있습니다 ( &lt;code&gt;erts:erl(1)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="152137ca072ede4f7367cf2d0089190cd0e9f36f" translate="yes" xml:space="preserve">
          <source>Configuration parameters used by the application. The value of a configuration parameter is retrieved by calling &lt;code&gt;application:get_env/1,2&lt;/code&gt;. The values in the application resource file can be overridden by values in a configuration file (see &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt;) or by command-line flags (see &lt;code&gt;erts:erl(1)&lt;/code&gt;).</source>
          <target state="translated">응용 프로그램이 사용하는 구성 매개 변수. 구성 매개 변수의 값은 &lt;code&gt;application:get_env/1,2&lt;/code&gt; 를 호출하여 검색됩니다 . 애플리케이션 자원 파일의 값은 구성 파일의 값 ( &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt; 참조 ) 또는 명령 행 플래그 ( &lt;code&gt;erts:erl(1)&lt;/code&gt; 참조) 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f167a5ff05614d588913f2a3ea7b803864f94594" translate="yes" xml:space="preserve">
          <source>Configuration problems - Everything from that the database was not set up right to that the c-program that should be run through the erlang port was not compiled for your platform.</source>
          <target state="translated">구성 문제점-데이터베이스의 모든 것이 erlang 포트를 통해 실행되어야하는 c- 프로그램이 사용자 플랫폼 용으로 컴파일되지 않았 음을 올바르게 설정하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="adfc00d45d90320f98d4a8966dd99b612af98936" translate="yes" xml:space="preserve">
          <source>Configuration terms can be combined with &lt;code&gt;ct_run&lt;/code&gt; start flags or &lt;code&gt;ct:run_test/1&lt;/code&gt; options. The result is, for some flags/options and terms, that the values are merged (for example, configuration files, include directories, verbosity levels, and silent connections) and for others that the start flags/options override the test specification terms (for example, log directory, label, style sheet, and auto-compilation).</source>
          <target state="translated">구성 용어는 &lt;code&gt;ct_run&lt;/code&gt; 시작 플래그 또는 &lt;code&gt;ct:run_test/1&lt;/code&gt; 옵션 과 결합 될 수 있습니다. 결과적으로 일부 플래그 / 옵션 및 용어의 경우 값이 병합되고 (예 : 구성 파일, 디렉토리, 상세 레벨 및 자동 연결 포함) 시작 플래그 / 옵션이 테스트 스펙 용어 (예 : 예 : 로그 디렉토리, 레이블, 스타일 시트 및 자동 컴파일).</target>
        </trans-unit>
        <trans-unit id="111aadb1527fab0c3a3d9158364fe8fbe059dd4b" translate="yes" xml:space="preserve">
          <source>Configuration that alters the behaviour of the watchdog state machine. On key &lt;code&gt;okay&lt;/code&gt;, the non-negative number of answered DWR messages before transitioning from REOPEN to OKAY. On key &lt;code&gt;suspect&lt;/code&gt;, the number of watchdog timeouts before transitioning from OKAY to SUSPECT when DWR is unanswered, or 0 to not make the transition.</source>
          <target state="translated">워치 독 상태 시스템의 동작을 변경하는 구성 키에 &lt;code&gt;okay&lt;/code&gt; , 천이 전에 대답 DWR 메시지의 비 음수 OKAY에 재 개설에서. 주요 &lt;code&gt;suspect&lt;/code&gt; 경우 DWR에 응답이 없을 때 OKAY에서 SUSPECT로 전환하기 전에 감시 시간 초과 횟수가 발생하거나 0으로 전환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="88225db23aed8095cba3daadea46a8efc09bcf97" translate="yes" xml:space="preserve">
          <source>Configuration tool for erts_alloc</source>
          <target state="translated">erts_alloc 구성 도구</target>
        </trans-unit>
        <trans-unit id="a5fa127b18e20d9b955af8441e526ef00d776b55" translate="yes" xml:space="preserve">
          <source>Configure and build Erlang with LTTng support:</source>
          <target state="translated">LTTng 지원을 사용하여 Erlang을 구성하고 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="6b190ce5efd5aa3a5159cbfc60014c630270e8e5" translate="yes" xml:space="preserve">
          <source>Configure and build Erlang with SystemTap support:</source>
          <target state="translated">SystemTap 지원을 사용하여 Erlang을 구성하고 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="5d4f8831764e8303911e86ac723330a29d408566" translate="yes" xml:space="preserve">
          <source>Configure and build Erlang/OTP with FIPS support:</source>
          <target state="translated">FIPS 지원을 사용하여 Erlang / OTP를 구성하고 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="b69539c636b739dc3d9c18ef898b44516eab0391" translate="yes" xml:space="preserve">
          <source>Configure and build all applications in OTP:</source>
          <target state="translated">OTP에서 모든 애플리케이션을 구성하고 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="8b2484c0c315deeb2ad1807b28fd424c7f06c488" translate="yes" xml:space="preserve">
          <source>Configure and build wxWidgets (on Mavericks - 10.9):</source>
          <target state="translated">wxWidget 구성 및 빌드 (매버릭스-10.9) :</target>
        </trans-unit>
        <trans-unit id="39d69829cac4583c026b7dac06cd342838c15fea" translate="yes" xml:space="preserve">
          <source>Configure and build wxWidgets (shared library on linux):</source>
          <target state="translated">wxWidgets 구성 및 빌드 (Linux의 공유 라이브러리) :</target>
        </trans-unit>
        <trans-unit id="67a1257909b72f3008c5378fbca12636e7276e2e" translate="yes" xml:space="preserve">
          <source>Configure and build wxWidgets (static library on linux):</source>
          <target state="translated">wxWidgets 구성 및 빌드 (Linux의 정적 라이브러리) :</target>
        </trans-unit>
        <trans-unit id="c38bfc21b593ce7dfdec5fb0054e7673a03afdbf" translate="yes" xml:space="preserve">
          <source>Configure how wide the target documentation should be rendered. By default &lt;code&gt;shell_docs&lt;/code&gt; used the value returned by &lt;code&gt;&lt;a href=&quot;io#columns-0&quot;&gt;io:columns()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대상 문서를 렌더링 할 폭을 구성하십시오. 기본적으로 &lt;code&gt;shell_docs&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;io#columns-0&quot;&gt;io:columns()&lt;/a&gt;&lt;/code&gt; 반환 된 값을 사용했습니다 .</target>
        </trans-unit>
        <trans-unit id="45882985975ef9fac87f192f6e545cf51766f699" translate="yes" xml:space="preserve">
          <source>Configure the &lt;code&gt;server_node()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;server_node()&lt;/code&gt; 함수를 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="bce9428e6d9edc0287bc7c097cb864aea994b4a1" translate="yes" xml:space="preserve">
          <source>Configure the application (agent).</source>
          <target state="translated">애플리케이션 (에이전트)을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="51a6fc0c6fbca524ff962159da3f3049edca0826" translate="yes" xml:space="preserve">
          <source>Configure the application (manager).</source>
          <target state="translated">응용 프로그램 (관리자)을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="e46814ef7294ecaf5dc1092fc3316c476f79636e" translate="yes" xml:space="preserve">
          <source>Configure the encoding that should be used by the renderer for graphical details such as bullet-points. By default &lt;code&gt;shell_docs&lt;/code&gt; uses the value returned by &lt;code&gt;&lt;a href=&quot;io#getopts-0&quot;&gt;io:getopts()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">글 머리 기호와 같은 그래픽 세부 정보를 위해 렌더러에서 사용해야하는 인코딩을 구성합니다. 기본적으로 &lt;code&gt;shell_docs&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;io#getopts-0&quot;&gt;io:getopts()&lt;/a&gt;&lt;/code&gt; 반환 된 값을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="cd4cfa952c7cb1b3fb9049874d99e02d7fd694ce" translate="yes" xml:space="preserve">
          <source>Configure whether &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ANSI_escape_code&quot;&gt; ansi escape codes&lt;/a&gt;&lt;/code&gt; should be used to render graphical details such as bold and underscore. By default &lt;code&gt;shell_docs&lt;/code&gt; will try to determine if the receiving shell supports ansi escape codes. It is possible to override the automated check by setting the kernel configuration parameter &lt;code&gt;shell_docs_ansi&lt;/code&gt; to a &lt;code&gt;boolean()&lt;/code&gt; value.</source>
          <target state="translated">굵게 및 밑줄과 같은 그래픽 세부 정보를 렌더링하는 데 &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ANSI_escape_code&quot;&gt; ansi escape codes&lt;/a&gt;&lt;/code&gt; 를 사용 해야하는지 여부를 구성합니다 . 기본적으로 &lt;code&gt;shell_docs&lt;/code&gt; 는 수신 셸이 ANSI 이스케이프 코드를 지원하는지 확인합니다. 커널 구성 매개 변수 &lt;code&gt;shell_docs_ansi&lt;/code&gt; 를 &lt;code&gt;boolean()&lt;/code&gt; 값 으로 설정하여 자동화 된 검사를 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9998129edb861a2783fd9f2d983f3b8f9c04883" translate="yes" xml:space="preserve">
          <source>Configures a TLS 1.3 connection for keylogging</source>
          <target state="translated">키 로깅을위한 TLS 1.3 연결 구성</target>
        </trans-unit>
        <trans-unit id="27054e2972268be83aba680767c39676d6755bb8" translate="yes" xml:space="preserve">
          <source>Configures all allocators as they were configured in respective Erlang/OTP release. These will eventually be removed.</source>
          <target state="translated">모든 할당자가 각 Erlang / OTP 릴리스에서 구성된대로 구성합니다. 이것들은 결국 제거 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="e1fa096044e69ac6a707fff4851145fb0bf622ec" translate="yes" xml:space="preserve">
          <source>Configures the maximum amount of bytes that can be sent on a TLS 1.3 connection before an automatic key update is performed.</source>
          <target state="translated">자동 키 업데이트를 수행하기 전에 TLS 1.3 연결에서 보낼 수있는 최대 바이트 수를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="493e81d559f9007329e29af0dfb0f57e7a4f1093" translate="yes" xml:space="preserve">
          <source>Configures the middlebox compatibility mode on a TLS 1.3 connection.</source>
          <target state="translated">TLS 1.3 연결에서 미들 박스 호환성 모드를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="caaf0a0801b3a7b065a2bc9b4de4bf8d0218db05" translate="yes" xml:space="preserve">
          <source>Configures the module responsible to communicate to &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt;. Defaults to &lt;code&gt;erl_epmd&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt; 와 통신 해야하는 모듈을 구성합니다 . 기본값은 &lt;code&gt;erl_epmd&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bd503813fc0045da6207273af5b0357c11782f4a" translate="yes" xml:space="preserve">
          <source>Configures the port used by erl_epmd to listen for connection and connect to other nodes. See &lt;code&gt;erl_epmd&lt;/code&gt; for more details. Defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">연결을 수신하고 다른 노드에 연결하기 위해 erl_epmd에서 사용하는 포트를 구성합니다. 자세한 내용은 &lt;code&gt;erl_epmd&lt;/code&gt; 를 참조하십시오. 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="86997217852f7599e58f2424f86945f3b956ee02" translate="yes" xml:space="preserve">
          <source>Configures the server's built-in anti replay feature based on Bloom filters.</source>
          <target state="translated">Bloom 필터를 기반으로 서버에 내장 된 재생 방지 기능을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="c9e5587526bf34e0c44a725edb0ac01a0dbf94bc" translate="yes" xml:space="preserve">
          <source>Configures the session ticket functionality. Allowed values are &lt;code&gt;disabled&lt;/code&gt;, &lt;code&gt;manual&lt;/code&gt; and &lt;code&gt;auto&lt;/code&gt;. If it is set to &lt;code&gt;manual&lt;/code&gt; the client will send the ticket information to user process in a 3-tuple:</source>
          <target state="translated">세션 티켓 기능을 구성합니다. 허용되는 값은 &lt;code&gt;disabled&lt;/code&gt; , &lt;code&gt;manual&lt;/code&gt; 및 &lt;code&gt;auto&lt;/code&gt; 입니다. &lt;code&gt;manual&lt;/code&gt; 으로 설정된 경우 클라이언트는 티켓 정보를 3- 튜플의 사용자 프로세스로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="0d71c8eadc43b0d0c1aac71b43d64a1624014b9d" translate="yes" xml:space="preserve">
          <source>Configures the session ticket functionality. Allowed values are &lt;code&gt;disabled&lt;/code&gt;, &lt;code&gt;stateful&lt;/code&gt; and &lt;code&gt;stateless&lt;/code&gt;.</source>
          <target state="translated">세션 티켓 기능을 구성합니다. 허용되는 값은 &lt;code&gt;disabled&lt;/code&gt; , &lt;code&gt;stateful&lt;/code&gt; 및 &lt;code&gt;stateless&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a467e0f743057863caa3e159aa6a46f3dd678d5e" translate="yes" xml:space="preserve">
          <source>Configures the session ticket functionalty in TLS 1.3 client and server.</source>
          <target state="translated">TLS 1.3 클라이언트 및 서버에서 세션 티켓 기능을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="dff79d039481de88c5036e525e09e7da9c1ef7c7" translate="yes" xml:space="preserve">
          <source>Configures the session tickets to be used for session resumption. It is a mandatory option in &lt;code&gt;manual&lt;/code&gt; mode (&lt;code&gt;session_tickets = manual&lt;/code&gt;).</source>
          <target state="translated">세션 재개에 사용할 세션 티켓을 구성합니다. &lt;code&gt;manual&lt;/code&gt; 모드 ( &lt;code&gt;session_tickets = manual&lt;/code&gt; ) 에서는 필수 옵션입니다 .</target>
        </trans-unit>
        <trans-unit id="c76054bf57b43f642c168e37a0c4892b7f72916d" translate="yes" xml:space="preserve">
          <source>Configuring Automatic Start at Boot</source>
          <target state="translated">부팅시 자동 시작 구성</target>
        </trans-unit>
        <trans-unit id="6ba44bc8ee2b71bde340df435bd441a9952d9f23" translate="yes" xml:space="preserve">
          <source>Configuring automatic start at boot</source>
          <target state="translated">부팅시 자동 시작 구성</target>
        </trans-unit>
        <trans-unit id="f49a4931e1853a0fe4fa0602792023cbc59353be" translate="yes" xml:space="preserve">
          <source>Configuring the server</source>
          <target state="translated">서버 구성</target>
        </trans-unit>
        <trans-unit id="f5c913b04ded8b2ffe36ec199b0399bc4e16854e" translate="yes" xml:space="preserve">
          <source>Configuring the server's (daemon's) command execution</source>
          <target state="translated">서버 (데몬)의 명령 실행 구성</target>
        </trans-unit>
        <trans-unit id="503bfa6b8b4cecf020c1a30e6445166dec1a4440" translate="yes" xml:space="preserve">
          <source>Conflicting lock requests are automatically queued if there is no risk of a deadlock. Otherwise the transaction must be terminated and executed again. Mnesia does this automatically as long as the upper limit of the maximum &lt;code&gt;retries&lt;/code&gt; is not reached. For details, see &lt;code&gt;mnesia:transaction/3&lt;/code&gt;.</source>
          <target state="translated">교착 상태의 위험이없는 경우 충돌 잠금 요청이 자동으로 대기합니다. 그렇지 않으면 트랜잭션을 종료하고 다시 실행해야합니다. Mnesia는 최대 &lt;code&gt;retries&lt;/code&gt; 상한에 도달 하지 않는 한이를 자동으로 수행합니다 . 자세한 내용은 &lt;code&gt;mnesia:transaction/3&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2080b07c9b432005750511e775ff7af7fc0ee76b" translate="yes" xml:space="preserve">
          <source>Connect the socket identified by &lt;code&gt;ctx&lt;/code&gt; to the address identified by &lt;code&gt;addr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ctx&lt;/code&gt; 로 식별 된 소켓 을 &lt;code&gt;addr&lt;/code&gt; 로 식별 된 주소 에 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="cfb84c7d5e0e6a9a5fc9a1a633d1fff5ce509970" translate="yes" xml:space="preserve">
          <source>Connect to a suspended shell</source>
          <target state="translated">일시 중단 된 쉘에 연결</target>
        </trans-unit>
        <trans-unit id="a8a7191deb9b3f0244a3453f396383743b739a70" translate="yes" xml:space="preserve">
          <source>Connect to the database</source>
          <target state="translated">데이터베이스에 연결</target>
        </trans-unit>
        <trans-unit id="dfb47972cff0f154a2285644e3f0befc8c5e2893" translate="yes" xml:space="preserve">
          <source>Connect/session options can be specified in a configuration file with entries like the following.</source>
          <target state="translated">연결 / 세션 옵션은 다음과 같은 항목을 사용하여 구성 파일에 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68c228838ef934f7196305d997754e8802035987" translate="yes" xml:space="preserve">
          <source>ConnectToHost, ConnectToPort) -&amp;gt;</source>
          <target state="translated">ConnectToHost, ConnectToPort) -&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2437d145ba906224318478ddfa7f5cf7b3436b38" translate="yes" xml:space="preserve">
          <source>ConnectToHost, ConnectToPort, Timeout) -&amp;gt;</source>
          <target state="translated">ConnectToHost, ConnectToPort, 시간 초과)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f2b22ea7c73a23c792930a01a0f5400a135abcc5" translate="yes" xml:space="preserve">
          <source>Connected (4)</source>
          <target state="translated">연결됨 (4)</target>
        </trans-unit>
        <trans-unit id="36a66c74a711b5012f4f766353ddd52a449b5a5e" translate="yes" xml:space="preserve">
          <source>Connected nodes</source>
          <target state="translated">연결된 노드</target>
        </trans-unit>
        <trans-unit id="2ca30b01eb101978f596dfb4c83992a57c6fb882" translate="yes" xml:space="preserve">
          <source>Connecting a client to the server</source>
          <target state="translated">클라이언트를 서버에 연결</target>
        </trans-unit>
        <trans-unit id="1ed330faf0978f7019e3726be2b5f99e046a3f4c" translate="yes" xml:space="preserve">
          <source>Connecting to a distributed Erlang node</source>
          <target state="translated">분산 Erlang 노드에 연결</target>
        </trans-unit>
        <trans-unit id="1f32eba569c9805c42f3eab7b2d07fbd5c071012" translate="yes" xml:space="preserve">
          <source>Connecting to other nodes</source>
          <target state="translated">다른 노드에 연결</target>
        </trans-unit>
        <trans-unit id="e3a4dd291e41bb38e1db11e5af64f5a26ce5f00c" translate="yes" xml:space="preserve">
          <source>Connection Protocol</source>
          <target state="translated">연결 프로토콜</target>
        </trans-unit>
        <trans-unit id="4fd62a8d97ad5549bbf8348232d0d6b0c35c3395" translate="yes" xml:space="preserve">
          <source>Connection handle</source>
          <target state="translated">연결 핸들</target>
        </trans-unit>
        <trans-unit id="2a819b372c3b2a49974a53da0826f1bc5ad2d2c2" translate="yes" xml:space="preserve">
          <source>Connection info - Information regarding connections. Read/Write.</source>
          <target state="translated">연결 정보-연결에 관한 정보. 읽기 / 쓰기</target>
        </trans-unit>
        <trans-unit id="acc13ac478b7f7a6df5cb010281833816acda090" translate="yes" xml:space="preserve">
          <source>Connection termination - If a connection is terminated in an abnormal way, or if you try to use a connection that you have already terminated in a normal way by calling disconnect/1, the return value will be&lt;code&gt;{error, connection_closed}&lt;/code&gt;. A connection could end abnormally because of an programming error in the Erlang ODBC application, but also if the ODBC driver crashes.</source>
          <target state="translated">연결 종료-연결이 비정상적인 방식으로 종료되거나 disconnect / 1을 호출하여 이미 정상적인 방식으로 종료 된 연결을 사용하려고하면 리턴 값은 &lt;code&gt;{error, connection_closed}&lt;/code&gt; 입니다. Erlang ODBC 응용 프로그램의 프로그래밍 오류로 인해 연결이 비정상적으로 종료 될 수 있지만 ODBC 드라이버가 충돌 할 경우</target>
        </trans-unit>
        <trans-unit id="f630d306abbe920d5aff2c2e026867de87df60cb" translate="yes" xml:space="preserve">
          <source>Connection time-out time, used during the initial request, when the client is &lt;strong&gt;connecting&lt;/strong&gt; to the server.</source>
          <target state="translated">클라이언트가 서버에 &lt;strong&gt;연결할&lt;/strong&gt; 때 초기 요청 중에 사용되는 연결 시간 종료 시간 .</target>
        </trans-unit>
        <trans-unit id="db6dfee0a523a63827ad3c6d672bff28e305c559" translate="yes" xml:space="preserve">
          <source>Connection time-out.</source>
          <target state="translated">접속 시간 초과.</target>
        </trans-unit>
        <trans-unit id="84f24a79f02b5f5432cf025209afa84534522b4e" translate="yes" xml:space="preserve">
          <source>Connection timeout (time to wait for connection) = 10 seconds</source>
          <target state="translated">연결 시간 초과 (연결 대기 시간) = 10 초</target>
        </trans-unit>
        <trans-unit id="3e9db74206291fe256a5fc7ef954e969d3ba0113" translate="yes" xml:space="preserve">
          <source>Connection to the remote server is prematurely closed.</source>
          <target state="translated">원격 서버에 대한 연결이 조기에 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="9c0cd0e7b81e317003b4ab011ba52828e5f13f08" translate="yes" xml:space="preserve">
          <source>Connection type. To be passed along to &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">연결 타입. &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="5e82eede979765f65e15123d56fb52f12de95d73" translate="yes" xml:space="preserve">
          <source>Connection-less socket communication (UDP) consists of an initiator socket at a certain host with a certain port number and a connector socket sending data to it.</source>
          <target state="translated">비 연결 소켓 통신 (UDP)은 특정 포트 번호를 가진 특정 호스트의 이니시에이터 소켓과 데이터를 보내는 커넥터 소켓으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="8923bf50fe66824eb73b05f930aafcd92a3498db" translate="yes" xml:space="preserve">
          <source>Connections are by default transitive. If a node A connects to node B, and node B has a connection to node C, then node A also tries to connect to node C. This feature can be turned off by using the command-line flag &lt;code&gt;-connect_all false&lt;/code&gt;, see the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">연결은 기본적으로 전 이적입니다. 노드 A가 노드 B에 연결하고 노드 B가 노드 C에 연결되면 노드 A도 노드 C에 연결을 시도합니다.이 기능은 명령 행 플래그 &lt;code&gt;-connect_all false&lt;/code&gt; 를 사용하여 끌 수 있습니다 . &lt;code&gt;erl(1)&lt;/code&gt; 참조 (1) ERTS 매뉴얼 페이지.</target>
        </trans-unit>
        <trans-unit id="df7a96b9d1ab852162c55262ef869436a1f43920" translate="yes" xml:space="preserve">
          <source>Connections are realized by configuring transport. Sessions are the responsibility of the user.</source>
          <target state="translated">전송을 구성하여 연결을 구현합니다. 세션은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="3ac050aca2ac7a4aec63a1a71d8f09959bd07582" translate="yes" xml:space="preserve">
          <source>Connections may either be established by an explicit call to megaco:connect/4 or implicitly at the first invocation of megaco:receive_message/3.</source>
          <target state="translated">megaco : connect / 4를 명시 적으로 호출하거나 megaco : receive_message / 3를 처음 호출 할 때 암시 적으로 연결을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69b63834c530ccc921274b1f6732ad102c4bd9dd" translate="yes" xml:space="preserve">
          <source>Connections must be opened as follows:</source>
          <target state="translated">다음과 같이 연결을 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="72980df161edb38af837eab92658c3a3e6caba2a" translate="yes" xml:space="preserve">
          <source>Connections vs. Sessions</source>
          <target state="translated">연결 대 세션</target>
        </trans-unit>
        <trans-unit id="6db35336552131a827a4b1a45bea2ad8b7cf5dce" translate="yes" xml:space="preserve">
          <source>Connector punctuation</source>
          <target state="translated">커넥터 구두점</target>
        </trans-unit>
        <trans-unit id="f7170a28f440536cf3718ba7465f311ddd5a8f4f" translate="yes" xml:space="preserve">
          <source>Connects to a server on TCP port &lt;code&gt;Port&lt;/code&gt; on the host with IP address &lt;code&gt;Address&lt;/code&gt;. Argument &lt;code&gt;Address&lt;/code&gt; can be a hostname or an IP address.</source>
          <target state="translated">IP 주소 &lt;code&gt;Address&lt;/code&gt; 호스트의 TCP 포트 &lt;code&gt;Port&lt;/code&gt; 에 있는 서버에 연결합니다 . 인수 &lt;code&gt;Address&lt;/code&gt; 는 호스트 이름 또는 IP 주소 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd4d77ecb9ea0beb70c140dfe5e069727cc27239" translate="yes" xml:space="preserve">
          <source>Connects to an SSH server at &lt;code&gt;Host&lt;/code&gt; and &lt;code&gt;Port&lt;/code&gt; (defaults to 22) and starts an interactive shell on that remote host.</source>
          <target state="translated">&lt;code&gt;Host&lt;/code&gt; 및 &lt;code&gt;Port&lt;/code&gt; 의 SSH 서버 (기본값은 22)에 연결하고 해당 원격 호스트에서 대화식 쉘을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="3901b0235178a62a083958cef9aa253e7ded5f4e" translate="yes" xml:space="preserve">
          <source>Connects to an SSH server at the &lt;code&gt;Host&lt;/code&gt; on &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Host&lt;/code&gt; on &lt;code&gt;Port&lt;/code&gt; 의 SSH 서버에 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="d8b7cd7e1ddd732f728c53cb316632742f51fdb5" translate="yes" xml:space="preserve">
          <source>Connects to job number &lt;code&gt;&amp;lt;nn&amp;gt;&lt;/code&gt; or the current job. The standard shell is resumed. Operations that use standard I/O by the current job are interleaved with user inputs to the shell.</source>
          <target state="translated">작업 번호 &lt;code&gt;&amp;lt;nn&amp;gt;&lt;/code&gt; 또는 현재 작업에 연결합니다 . 표준 쉘이 재개됩니다. 현재 작업에서 표준 I / O를 사용하는 작업은 셸에 대한 사용자 입력과 함께 인터리브됩니다.</target>
        </trans-unit>
        <trans-unit id="a90f171af7aaadbc8a2111970a10fc3906a1623c" translate="yes" xml:space="preserve">
          <source>Connects to the socket named &amp;lt;socket name&amp;gt;.</source>
          <target state="translated">&amp;lt;소켓 이름&amp;gt;이라는 소켓에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="12c4c6846d065c87773544d3b07ce317d854f9c3" translate="yes" xml:space="preserve">
          <source>Consider a &quot;pure&quot; &lt;code&gt;ets:select/2&lt;/code&gt; call that does what &lt;code&gt;ets:foldr&lt;/code&gt; does:</source>
          <target state="translated">&lt;code&gt;ets:foldr&lt;/code&gt; 의 기능을 수행 하는 &quot;순수한&quot; &lt;code&gt;ets:select/2&lt;/code&gt; 호출을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="efde5834872be2ae75b153813fdd7ce1668940f2" translate="yes" xml:space="preserve">
          <source>Consider a &lt;code&gt;code_length/0&lt;/code&gt; function that returns the length of the correct code. We dispatch all events that are not state-specific to the common function &lt;code&gt;handle_common/3&lt;/code&gt;:</source>
          <target state="translated">올바른 코드의 길이를 리턴 하는 &lt;code&gt;code_length/0&lt;/code&gt; 함수를 고려하십시오 . 상태 별이 아닌 모든 이벤트를 공통 함수 &lt;code&gt;handle_common/3&lt;/code&gt; 에 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="4b8e15fd9a0bd525abf05ad20a9f77d24e2e9bec" translate="yes" xml:space="preserve">
          <source>Consider a Linux machine where option &lt;code&gt;TCP_INFO&lt;/code&gt; can be used to collect TCP statistics for a socket. Assume you are interested in field &lt;code&gt;tcpi_sacked&lt;/code&gt; of &lt;code&gt;struct tcp_info&lt;/code&gt; filled in when asking for &lt;code&gt;TCP_INFO&lt;/code&gt;. To be able to access this information, you need to know the following:</source>
          <target state="translated">&lt;code&gt;TCP_INFO&lt;/code&gt; 옵션을 사용하여 소켓에 대한 TCP 통계를 수집 할 수 있는 Linux 시스템을 고려하십시오 . 이 분야에 관심이있는 가정 &lt;code&gt;tcpi_sacked&lt;/code&gt; 의 &lt;code&gt;struct tcp_info&lt;/code&gt; 를 요구하는 경우에 작성 &lt;code&gt;TCP_INFO&lt;/code&gt; . 이 정보에 액세스하려면 다음을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="8d96d58366d35570e4b5a61813232b9e498b1343" translate="yes" xml:space="preserve">
          <source>Consider a directory containing a file named &quot;bj&amp;ouml;rn&quot; in ISO Latin-1, while the Erlang VM is operating in Unicode filename mode (and therefore expects UTF-8 file naming). The ISO Latin-1 name is not valid UTF-8 and one can be tempted to think that automatic conversion in, for example, &lt;code&gt;file:list_dir/1&lt;/code&gt; is a good idea. But what would happen if we later tried to open the file and have the name as a Unicode list (magically converted from the ISO Latin-1 filename)? The VM converts the filename to UTF-8, as this is the encoding expected. Effectively this means trying to open the file named &amp;lt;&amp;lt;&quot;bj&amp;ouml;rn&quot;/utf8&amp;gt;&amp;gt;. This file does not exist, and even if it existed it would not be the same file as the one that was listed. We could even create two files named &quot;bj&amp;ouml;rn&quot;, one named in UTF-8 encoding and one not. If &lt;code&gt;file:list_dir/1&lt;/code&gt; would automatically convert the ISO Latin-1 filename to a list, we would get two identical filenames as the result. To avoid this, we must differentiate between filenames that are properly encoded according to the Unicode file naming convention (that is, UTF-8) and filenames that are invalid under the encoding. By the common function &lt;code&gt;file:list_dir/1&lt;/code&gt;, the wrongly encoded filenames are ignored in Unicode filename translation mode, but by function &lt;code&gt;file:list_dir_all/1&lt;/code&gt; the filenames with invalid encoding are returned as &quot;raw&quot; filenames, that is, as binaries.</source>
          <target state="translated">Erlang VM은 유니 코드 파일 이름 모드에서 작동하므로 UTF-8 파일 이름이 예상되는 동안 ISO Latin-1에 &quot;bj&amp;ouml;rn&quot;이라는 파일이 포함 된 디렉토리를 고려하십시오. ISO Latin-1 이름은 유효한 UTF-8이 아니며 &lt;code&gt;file:list_dir/1&lt;/code&gt; 과 같은 자동 변환 이 좋은 생각 이라고 생각할 수 있습니다 . 그러나 나중에 파일을 열고 이름을 유니 코드 목록 (ISO Latin-1 파일 이름에서 마술로 변환)로 사용하면 어떻게됩니까? VM은 파일 이름을 UTF-8로 변환합니다. 이는 인코딩이 예상 된 것입니다. 사실상 이것은 &amp;lt;&amp;lt; &quot;bj&amp;ouml;rn&quot;/ utf8 &amp;gt;&amp;gt;라는 파일을 열려는 것을 의미합니다. 이 파일은 존재하지 않으며 존재하더라도 나열된 파일과 동일한 파일이 아닙니다. &quot;bj&amp;ouml;rn&quot;이라는 두 개의 파일을 만들 수도 있습니다.하나는 UTF-8 인코딩으로 명명되고 다른 하나는 그렇지 않습니다. 만약 &lt;code&gt;file:list_dir/1&lt;/code&gt; 은 ISO Latin-1 파일 이름을 자동으로 목록으로 변환합니다. 결과적으로 두 개의 동일한 파일 이름을 얻게됩니다. 이를 피하려면 유니 코드 파일 명명 규칙에 따라 올바르게 인코딩 된 파일 이름 (UTF-8)과 인코딩에서 유효하지 않은 파일 이름을 구분해야합니다. 공통 함수 &lt;code&gt;file:list_dir/1&lt;/code&gt; 에서는 잘못 인코딩 된 파일 이름이 유니 코드 파일 이름 변환 모드에서 무시되지만 함수 &lt;code&gt;file:list_dir_all/1&lt;/code&gt; 의해 인코딩이 잘못된 파일 이름은 &quot;원시&quot;파일 이름, 즉 이진으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="85ff3c7e5e58dcfda30947417cbf03dc221285f7" translate="yes" xml:space="preserve">
          <source>Consider a function that adds a subscriber to a telephony system:</source>
          <target state="translated">전화 통신 시스템에 가입자를 추가하는 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d67d867e1a2c0d3f72d5fed36d8199068542319f" translate="yes" xml:space="preserve">
          <source>Consider a process that receives data from a client process to be forwarded to a server on the network. The process is connected to the server through TCP/IP and does not get any acknowledge for each message it sends, but has to rely on the send time-out option to detect that the other end is unresponsive. Option &lt;code&gt;send_timeout&lt;/code&gt; can be used when connecting:</source>
          <target state="translated">클라이언트 프로세스에서 데이터를 수신하여 네트워크의 서버로 전달하는 프로세스를 고려하십시오. 프로세스는 TCP / IP를 통해 서버에 연결되며 전송하는 각 메시지에 대한 승인을받지 않지만 상대방이 응답하지 않는 것을 감지하려면 보내기 시간 제한 옵션을 사용해야합니다. &lt;code&gt;send_timeout&lt;/code&gt; 옵션 은 다음을 연결할 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e2691c6fb672c519517e1290458846e6ef5963a" translate="yes" xml:space="preserve">
          <source>Consider a simple table of employees:</source>
          <target state="translated">간단한 직원 테이블을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="f4c75d1817bfaec0e89222a276e69880bbb048f7" translate="yes" xml:space="preserve">
          <source>Consider how &lt;code&gt;Reversed_List&lt;/code&gt; is built. It starts as [], then successively the heads are taken off of the list to be reversed and added to the the &lt;code&gt;Reversed_List&lt;/code&gt;, as shown in the following:</source>
          <target state="translated">&lt;code&gt;Reversed_List&lt;/code&gt; 가 작성 되는 방법을 고려하십시오 . 다음과 같이 []로 시작한 다음 헤드가 목록에서 제거되어 &lt;code&gt;Reversed_List&lt;/code&gt; 에 추가되고 역으로 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="6ab7f6a1bb41fb01d5cd20aaa578826fc00067f9" translate="yes" xml:space="preserve">
          <source>Consider that you have a module that handles the abstract data type &lt;code&gt;Person&lt;/code&gt;. You export the interface function &lt;code&gt;print_person/1&lt;/code&gt;, which uses the internal functions &lt;code&gt;print_name/1&lt;/code&gt;, &lt;code&gt;print_age/1&lt;/code&gt;, and &lt;code&gt;print_occupation/1&lt;/code&gt;.</source>
          <target state="translated">추상 데이터 유형 &lt;code&gt;Person&lt;/code&gt; 을 처리하는 모듈이 있다고 가정하십시오 . 내부 함수 &lt;code&gt;print_name/1&lt;/code&gt; , &lt;code&gt;print_age/1&lt;/code&gt; 및 &lt;code&gt;print_occupation/1&lt;/code&gt; 을 사용 하는 인터페이스 함수 &lt;code&gt;print_person/1&lt;/code&gt; 을 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="e832f8403c198de61e833e7a480735f4053e43ff" translate="yes" xml:space="preserve">
          <source>Consider the example in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analysing Results, now extended with node information and intended to be executed by &lt;code&gt;Common Test&lt;/code&gt; Master:</source>
          <target state="translated">이제 노드 정보로 확장되고 &lt;code&gt;Common Test&lt;/code&gt; Master에 의해 실행되도록 테스트 실행 및 결과 분석 섹션의 &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 섹션에있는 예제를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="39f2b57b5281a62ac0370db4ff59b10198d6ae26" translate="yes" xml:space="preserve">
          <source>Consider the following pattern, which contains non-significant whitespace to make it more readable (assume option &lt;code&gt;extended&lt;/code&gt;) and to divide it into three parts for ease of discussion:</source>
          <target state="translated">이해하기 쉽도록 ( &lt;code&gt;extended&lt;/code&gt; 옵션으로 가정 ) 토론을 쉽게하기 위해 세 부분으로 나누 려면 중요하지 않은 공백이 포함 된 다음 패턴을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="46bc9d71b555a5f11b94b4eeb5c560673be71af6" translate="yes" xml:space="preserve">
          <source>Consider the following schema for a table of company employees. Each employee is identified by department number and name. The other table column stores the telephone number:</source>
          <target state="translated">회사 직원 테이블에 대해 다음 스키마를 고려하십시오. 각 직원은 부서 번호와 이름으로 식별됩니다. 다른 테이블 열에는 전화 번호가 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="cb55da6206ee40073782daa342fe492d6d61166c" translate="yes" xml:space="preserve">
          <source>Consider the function &lt;code&gt;fact&lt;/code&gt;:</source>
          <target state="translated">기능 &lt;code&gt;fact&lt;/code&gt; 고려하십시오 :</target>
        </trans-unit>
        <trans-unit id="ef174d60bac701fec9e09c290d0d3b90c3cf6f8c" translate="yes" xml:space="preserve">
          <source>Consider the problem of matching a string in parentheses, allowing for unlimited nested parentheses. Without the use of recursion, the best that can be done is to use a pattern that matches up to some fixed depth of nesting. It is not possible to handle an arbitrary nesting depth.</source>
          <target state="translated">무제한 중첩 괄호를 허용하여 괄호 안에 문자열을 일치시키는 문제를 고려하십시오. 재귀를 사용하지 않고 수행 할 수있는 최선의 방법은 고정 된 중첩 깊이와 일치하는 패턴을 사용하는 것입니다. 임의의 중첩 깊이를 처리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="270cf4c7cb812d80c2aeafefcba021db14b5c9b0" translate="yes" xml:space="preserve">
          <source>Consider the same regular expression, but with the subpattern explicitly named 'FOO':</source>
          <target state="translated">동일한 정규 표현식을 고려하지만 명시 적으로 이름이 'FOO'인 하위 패턴이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="11609cf73bda34f9c32c6a76c718328a0992ccb9" translate="yes" xml:space="preserve">
          <source>Consider, for example, a server application under test. The following functionality is to be tested:</source>
          <target state="translated">예를 들어 테스트중인 서버 응용 프로그램을 고려하십시오. 다음 기능을 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="d91f897bb6a72091261f7b531a2eb9e3cb354e53" translate="yes" xml:space="preserve">
          <source>Consider, for example, the pattern \d+foo when applied to the following subject line:</source>
          <target state="translated">예를 들어 다음 제목 줄에 적용될 때 \ d + foo 패턴을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="fad23a16477e328da2bd8980efb7502b447bd6f6" translate="yes" xml:space="preserve">
          <source>Considers missing headers as generated files and adds them to the dependencies.</source>
          <target state="translated">누락 된 헤더를 생성 된 파일로 간주하여 종속 항목에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0ea7b95eab5fbd65070ee5e58e3789c399ad441a" translate="yes" xml:space="preserve">
          <source>Consistency</source>
          <target state="translated">Consistency</target>
        </trans-unit>
        <trans-unit id="2416d42d8d26094930f52fe782ef8c3d55df4f05" translate="yes" xml:space="preserve">
          <source>Consistency checking between MIBs</source>
          <target state="translated">MIB 간 일관성 검사</target>
        </trans-unit>
        <trans-unit id="e0b3cee1e82b80ed946d9b0b76f2ee5162f5b5c9" translate="yes" xml:space="preserve">
          <source>Const ::= AtomConst | FunSpec | MFA</source>
          <target state="translated">Const :: = AtomConst | FunSpec | MFA</target>
        </trans-unit>
        <trans-unit id="5cfb1e6566be91ced8a40ddff4da8a615174e201" translate="yes" xml:space="preserve">
          <source>Constant ::= Call | Const</source>
          <target state="translated">상수 :: = 전화 | 콘 스트</target>
        </trans-unit>
        <trans-unit id="1bafe97bb00638010937d06443d9bc18d9b3329f" translate="yes" xml:space="preserve">
          <source>Constant ::= {&lt;code&gt;const&lt;/code&gt;, term()}</source>
          <target state="translated">상수 :: = { &lt;code&gt;const&lt;/code&gt; , term ()}</target>
        </trans-unit>
        <trans-unit id="221ceea8aad6c96db9f85e13a30e3778298ff5d5" translate="yes" xml:space="preserve">
          <source>Constant Erlang terms (also called &lt;strong&gt;literals&lt;/strong&gt;) are kept in constant pools; each loaded module has its own pool. The following function does not build the tuple every time it is called (only to have it discarded the next time the garbage collector was run), but the tuple is located in the module's constant pool:</source>
          <target state="translated">상수 Erlang 용어 ( &lt;strong&gt;리터럴&lt;/strong&gt; 이라고도 함 )는 상수 풀에 보관됩니다. 로드 된 각 모듈에는 자체 풀이 있습니다. 다음 함수는 호출 될 때마다 튜플을 빌드하지 않지만 (다음에 가비지 콜렉터가 실행될 때 버려야 만) 튜플은 모듈의 상수 풀에 있습니다.</target>
        </trans-unit>
        <trans-unit id="18f2cafbf9301a8d594f4c411a820d1a97052f9d" translate="yes" xml:space="preserve">
          <source>Constant Pool</source>
          <target state="translated">상수 풀</target>
        </trans-unit>
        <trans-unit id="0f386d7e7881b32fa39cb7b62bdb15c0f3a4c0e1" translate="yes" xml:space="preserve">
          <source>Constants</source>
          <target state="translated">Constants</target>
        </trans-unit>
        <trans-unit id="e20076a802d4d6fed29c34dfbbd095f1a4303bb6" translate="yes" xml:space="preserve">
          <source>Constants (atoms, integer, floats, lists, tuples, records, binaries, and maps)</source>
          <target state="translated">상수 (원자, 정수, 부동 소수점, 목록, 튜플, 레코드, 바이너리 및 맵)</target>
        </trans-unit>
        <trans-unit id="b9002264e3b8be0e5a771c041655682c3c04890d" translate="yes" xml:space="preserve">
          <source>Constants ::= Consts | Consts &lt;code&gt;:&lt;/code&gt; Type | RegExpr</source>
          <target state="translated">상수 :: = 상수 | Consts &lt;code&gt;:&lt;/code&gt; 유형 | 정규식</target>
        </trans-unit>
        <trans-unit id="34f461426e164418878dde5aeb8fb12763014553" translate="yes" xml:space="preserve">
          <source>Constants can well replace term &lt;code&gt;node&lt;/code&gt; also, but this still has a declarative value, mainly when used in combination with &lt;code&gt;NodeRefs == all_nodes&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;#types&quot;&gt;Types&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">상수는 &lt;code&gt;node&lt;/code&gt; 라는 용어를 대체 할 수도 있지만, 이는 주로 &lt;code&gt;NodeRefs == all_nodes&lt;/code&gt; 와 함께 사용될 때 선언적 값을 갖습니다 ( &lt;code&gt;&lt;a href=&quot;#types&quot;&gt;Types&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="21be61b96cffe6ca7b1165136773aecc5eaa2360" translate="yes" xml:space="preserve">
          <source>Constants make the test specification term &lt;code&gt;alias&lt;/code&gt;, in previous versions of &lt;code&gt;Common Test&lt;/code&gt;, redundant. This term is deprecated but remains supported in upcoming &lt;code&gt;Common Test&lt;/code&gt; releases. Replacing &lt;code&gt;alias&lt;/code&gt; terms with &lt;code&gt;define&lt;/code&gt; is strongly recommended though. An example of such replacement follows:</source>
          <target state="translated">상수 는 이전 버전의 &lt;code&gt;Common Test&lt;/code&gt; 에서 테스트 스펙 용어를 &lt;code&gt;alias&lt;/code&gt; 만듭니다 . 이 용어는 더 이상 사용되지 않지만 향후 &lt;code&gt;Common Test&lt;/code&gt; 릴리스 에서 계속 지원 됩니다. 교체 &lt;code&gt;alias&lt;/code&gt; 으로 용어를 &lt;code&gt;define&lt;/code&gt; 강력하지만 권장합니다. 이러한 교체의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a5e37085481b760804cbc7b5cc4fd93c4883fa7" translate="yes" xml:space="preserve">
          <source>Construct a megaco_receive_handle record from user config</source>
          <target state="translated">사용자 설정에서 megaco_receive_handle 레코드 생성</target>
        </trans-unit>
        <trans-unit id="729a559814639c65233d1bc9939910a711214293" translate="yes" xml:space="preserve">
          <source>Construct a megaco_receive_handle record.</source>
          <target state="translated">megaco_receive_handle 레코드를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="080d00f2a1b4ab0493444768788667c25f4a433b" translate="yes" xml:space="preserve">
          <source>Constructing a new map is done by letting an expression &lt;code&gt;K&lt;/code&gt; be associated with another expression &lt;code&gt;V&lt;/code&gt;:</source>
          <target state="translated">새로운 맵 구성은 표현식 &lt;code&gt;K&lt;/code&gt; 를 다른 표현식 &lt;code&gt;V&lt;/code&gt; 와 연관시켜 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="5e0cb8439a00ff66a080d006db256cf4251bb30c" translate="yes" xml:space="preserve">
          <source>Constructing new instructions on the right side</source>
          <target state="translated">오른쪽에 새 지침 구성</target>
        </trans-unit>
        <trans-unit id="6f9ebd028f2b393c1489cd50c343fd65cf6291a5" translate="yes" xml:space="preserve">
          <source>Constructs a new binary by replacing the parts in &lt;code&gt;Subject&lt;/code&gt; matching &lt;code&gt;Pattern&lt;/code&gt; with the content of &lt;code&gt;Replacement&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Subject&lt;/code&gt; 일치 &lt;code&gt;Pattern&lt;/code&gt; 의 파트 를 &lt;code&gt;Replacement&lt;/code&gt; 의 컨텐츠 로 바꾸어 새 바이너리를 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="e29f3b3c5fb6da2bad84eb33811c5a8e702e13db" translate="yes" xml:space="preserve">
          <source>Constructs an abstract list skeleton. The result has type &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;. If &lt;code&gt;List&lt;/code&gt; is a nonempty list &lt;code&gt;[E1, ..., En]&lt;/code&gt;, the result has type &lt;code&gt;list&lt;/code&gt; and represents either &quot;&lt;code&gt;[E1, ..., En]&lt;/code&gt;&quot;, if &lt;code&gt;Tail&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;, or otherwise &quot;&lt;code&gt;[E1, ..., En | Tail]&lt;/code&gt;&quot;. If &lt;code&gt;List&lt;/code&gt; is the empty list, &lt;code&gt;Tail&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;none&lt;/code&gt;, and in that case the result has type &lt;code&gt;nil&lt;/code&gt; and represents &quot;&lt;code&gt;[]&lt;/code&gt;&quot; (see &lt;code&gt;&lt;a href=&quot;#nil-0&quot;&gt;nil/0&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">추상리스트 스켈레톤을 구성합니다. 결과는 type &lt;code&gt;list&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 입니다. 경우 &lt;code&gt;List&lt;/code&gt; 비어 있지 않은 목록입니다 &lt;code&gt;[E1, ..., En]&lt;/code&gt; , 결과는 유형이 &lt;code&gt;list&lt;/code&gt; &quot;및 중 하나를 나타냅니다 &lt;code&gt;[E1, ..., En]&lt;/code&gt; 경우,&quot; &lt;code&gt;Tail&lt;/code&gt; 없는 &lt;code&gt;none&lt;/code&gt; , 또는 그렇지 않으면 &quot; &lt;code&gt;[E1, ..., En | Tail]&lt;/code&gt; &quot;. 경우 &lt;code&gt;List&lt;/code&gt; 빈리스트이며, &lt;code&gt;Tail&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 할 수없는 &lt;code&gt;none&lt;/code&gt; , 그 경우 그 결과는 형이 &lt;code&gt;nil&lt;/code&gt; 하고 &quot;대표 &lt;code&gt;[]&lt;/code&gt; &quot;(참조 &lt;code&gt;&lt;a href=&quot;#nil-0&quot;&gt;nil/0&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0c1bd0529d6b40d4b62e4277842d1853cd4eb139" translate="yes" xml:space="preserve">
          <source>Consts ::= Constant | &lt;code&gt;[&lt;/code&gt;Constant&lt;code&gt;,&lt;/code&gt; ...&lt;code&gt;]&lt;/code&gt; | &lt;code&gt;{&lt;/code&gt;Constant&lt;code&gt;,&lt;/code&gt; ...&lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">Consts :: = 상수 | &lt;code&gt;[&lt;/code&gt; 상수 &lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;]&lt;/code&gt; | &lt;code&gt;{&lt;/code&gt; 상수 &lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="39992774518c9fff46f13d958f364c2a177e12dd" translate="yes" xml:space="preserve">
          <source>Consumed by &lt;code&gt;&lt;a href=&quot;#next-1&quot;&gt;maps:next/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#filter-2&quot;&gt;maps:filter/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#fold-3&quot;&gt;maps:fold/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#map-2&quot;&gt;maps:map/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에 의해 소비 &lt;code&gt;&lt;a href=&quot;#next-1&quot;&gt;maps:next/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#filter-2&quot;&gt;maps:filter/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#fold-3&quot;&gt;maps:fold/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#map-2&quot;&gt;maps:map/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b920c3a03e725c9d61f35dce2d6a6eca4e7f8c8f" translate="yes" xml:space="preserve">
          <source>Consuming a URI containing percent-encoded triplets can take many steps. The following example shows how to handle an input URI that is not normalized and contains multiple percent-encoded triplets. First, the input &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_string&quot;&gt;uri_string()&lt;/a&gt;&lt;/code&gt; is to be parsed into a &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt;. The parsing only splits the URI into its components without doing any decoding:</source>
          <target state="translated">백분율로 인코딩 된 삼중점이 포함 된 URI를 사용하려면 여러 단계를 거쳐야합니다. 다음 예제는 정규화되지 않고 여러 퍼센트로 인코딩 된 트리플렛을 포함하는 입력 URI를 처리하는 방법을 보여줍니다. 첫째, 입력 &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_string&quot;&gt;uri_string()&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt; 으로 구문 분석됩니다 . 구문 분석은 디코딩을 수행하지 않고 URI를 구성 요소로만 분할합니다.</target>
        </trans-unit>
        <trans-unit id="0e2fed826e8d11841c46e6f1e7451ec0fc8a31bc" translate="yes" xml:space="preserve">
          <source>Contacts the &lt;code&gt;epmd&lt;/code&gt; listening on the specified TCP port number (default 4369). This can also be set using environment variable &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt;; see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 TCP 포트 번호에서 수신 대기 하는 &lt;code&gt;epmd&lt;/code&gt; 에 접속합니다 (기본값 4369). 환경 변수 &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; 를 사용하여 설정할 수도 있습니다 . &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d418a206c8b5fc2a7fb5cc7d0c97c6096d675e8" translate="yes" xml:space="preserve">
          <source>Contains a list of additional library directories that the code server searches for applications and adds to the code path; see &lt;code&gt;code(3)&lt;/code&gt;.</source>
          <target state="translated">코드 서버가 애플리케이션을 검색하고 코드 경로에 추가하는 추가 라이브러리 디렉토리 목록을 포함합니다. &lt;code&gt;code(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="20db3f99344de7dc045e4e80f4e3b33db4b93cd7" translate="yes" xml:space="preserve">
          <source>Contains a menu item for each open Debugger window. Selecting one of the items raises the corresponding window.</source>
          <target state="translated">열려있는 각 디버거 창의 메뉴 항목이 들어 있습니다. 항목 중 하나를 선택하면 해당 창이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="800cc7c747ed734c3bd2436ca1facd3a4a3339c0" translate="yes" xml:space="preserve">
          <source>Contains the function arguments passed to the NIF.</source>
          <target state="translated">NIF에 전달 된 함수 인수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8a6cf6761af3cc1e8f4d362dab65afa469817b97" translate="yes" xml:space="preserve">
          <source>Content = [Element]</source>
          <target state="translated">콘텐츠 = [요소]</target>
        </trans-unit>
        <trans-unit id="cc11b3a28fa30ae6d3d3ad1438824cbd5224ba5c" translate="yes" xml:space="preserve">
          <source>Context</source>
          <target state="translated">Context</target>
        </trans-unit>
        <trans-unit id="8c8c410b4730be3fa7570f8567cda07ab85717c1" translate="yes" xml:space="preserve">
          <source>Contexts with an internal state that should not be manipulated but passed between function calls.</source>
          <target state="translated">조작해서는 안되지만 함수 호출간에 전달되는 내부 상태가있는 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="4bc28ecdc9f36671383cecd55edcb0d089e248e6" translate="yes" xml:space="preserve">
          <source>Contextual errors - If API functions are used in the wrong context, the &lt;code&gt;Reason&lt;/code&gt; in the error tuple will be a descriptive atom. For instance if you try to call the function &lt;code&gt;last/[1,2]&lt;/code&gt; without first calling &lt;code&gt;select_count/[2,3]&lt;/code&gt; to associate a result set with the connection. If the ODBC-driver does not support some functions, or if you disabled some functionality for a connection and then try to use it.</source>
          <target state="translated">상황 별 오류-API 함수가 잘못된 상황에서 사용되는 경우 오류 튜플 의 &lt;code&gt;Reason&lt;/code&gt; 는 설명적인 원자가됩니다. 예를 들어 &lt;code&gt;select_count/[2,3]&lt;/code&gt; 을 먼저 호출하지 않고 &lt;code&gt;last/[1,2]&lt;/code&gt; 함수를 호출하려고 하면 결과 세트를 연결과 연관시킵니다. ODBC 드라이버가 일부 기능을 지원하지 않거나 연결에 대해 일부 기능을 비활성화 한 경우 사용을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="070764532b4de17830b5b69712f55feaff04ff9a" translate="yes" xml:space="preserve">
          <source>Continuation = (&lt;code&gt;&lt;a href=&quot;#type-syntaxTree&quot;&gt;syntaxTree()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-context&quot;&gt;context()&lt;/a&gt;&lt;/code&gt;) -&amp;gt; &lt;code&gt;&lt;a href=&quot;prettypr#type-document&quot;&gt;prettypr:document()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">계속 = ( &lt;code&gt;&lt;a href=&quot;#type-syntaxTree&quot;&gt;syntaxTree()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#type-context&quot;&gt;context()&lt;/a&gt;&lt;/code&gt; )-&amp;gt; &lt;code&gt;&lt;a href=&quot;prettypr#type-document&quot;&gt;prettypr:document()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e03e8eebfab40a4fd9be2718ad485476abef0bd3" translate="yes" xml:space="preserve">
          <source>Continuation returned by &lt;code&gt;open/1,2&lt;/code&gt; or &lt;code&gt;chunk/1,2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;open/1,2&lt;/code&gt; 또는 &lt;code&gt;chunk/1,2&lt;/code&gt; 에서 계속이 반환되었습니다 .</target>
        </trans-unit>
        <trans-unit id="091fbe1ad605666c6170536967f53980c001530f" translate="yes" xml:space="preserve">
          <source>Continue the SSL/TLS handshake possiby with new, additional or changed options.</source>
          <target state="translated">새로운 추가 옵션 또는 변경된 옵션으로 SSL / TLS 핸드 셰이크 가능성을 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="c36cec59175b4924eb232c04762cff854c28eb3b" translate="yes" xml:space="preserve">
          <source>Continue the TLS handshake possiby with new, additional or changed options.</source>
          <target state="translated">새로운, 추가 또는 변경된 옵션으로 TLS 핸드 셰이크 가능성을 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="f105f8dee43358db799a59af5e9759b95ef60124" translate="yes" xml:space="preserve">
          <source>Continue the traversal and accumulate &lt;code&gt;Val&lt;/code&gt;. The following function is supplied to collect all objects of a table in a list:</source>
          <target state="translated">순회를 계속하고 &lt;code&gt;Val&lt;/code&gt; 을 축적하십시오 . 테이블의 모든 객체를 목록으로 수집하기 위해 다음 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="fec4067a3f18b3c51fe634a426bc57ca6d7ece02" translate="yes" xml:space="preserve">
          <source>Continue to perform the traversal. For example, the following function can be used to print the contents of a table:</source>
          <target state="translated">순회를 계속 수행하십시오. 예를 들어, 다음 기능을 사용하여 테이블의 내용을 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c63ee0550edcb4c377c408f4d3f3eb757e2e5c77" translate="yes" xml:space="preserve">
          <source>Continues a match started with &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt;. The next chunk of the size specified in the initial &lt;code&gt;match/3&lt;/code&gt; call is returned together with a new &lt;code&gt;Continuation&lt;/code&gt;, which can be used in subsequent calls to this function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt; 로 시작된 경기를 계속합니다 . 초기 &lt;code&gt;match/3&lt;/code&gt; 호출에 지정된 크기의 다음 청크가 새로운 &lt;code&gt;Continuation&lt;/code&gt; 과 함께 반환되며, 이 함수는이 함수에 대한 후속 호출에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="221675e363c83fa1b19e54f0bc32768b67b07030" translate="yes" xml:space="preserve">
          <source>Continues a match started with &lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt;. The next chunk of the size specified in the initial &lt;code&gt;match_object/3&lt;/code&gt; call is returned together with a new &lt;code&gt;Continuation&lt;/code&gt;, which can be used in subsequent calls to this function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt; 로 시작된 일치를 계속합니다 . 초기 &lt;code&gt;match_object/3&lt;/code&gt; 호출에 지정된 크기의 다음 청크가 새로운 &lt;code&gt;Continuation&lt;/code&gt; 과 함께 반환되며, 이 함수는이 함수에 대한 후속 호출에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73c4a5596193700b0e1ff38275cce559943a7265" translate="yes" xml:space="preserve">
          <source>Continues a match started with &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt;. The next chunk of the size specified in the initial &lt;code&gt;select/3&lt;/code&gt; call is returned together with a new &lt;code&gt;Continuation&lt;/code&gt;, which can be used in subsequent calls to this function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; 로 시작된 경기를 계속합니다 . 초기 &lt;code&gt;select/3&lt;/code&gt; 호출에 지정된 크기의 다음 청크가 새로운 &lt;code&gt;Continuation&lt;/code&gt; 과 함께 반환되며, 이 함수는 이후에이 함수를 호출 할 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0fa645328109d154f1b0ff83c174bc21403d328" translate="yes" xml:space="preserve">
          <source>Continues a match started with &lt;code&gt;&lt;a href=&quot;#select_reverse-3&quot;&gt; select_reverse/3&lt;/a&gt;&lt;/code&gt;. For tables of type &lt;code&gt;ordered_set&lt;/code&gt;, the traversal of the table continues to objects with keys earlier in the Erlang term order. The returned list also contains objects with keys in reverse order. For all other table types, the behavior is exactly that of &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#select_reverse-3&quot;&gt; select_reverse/3&lt;/a&gt;&lt;/code&gt; 로 시작된 일치를 계속합니다 . &lt;code&gt;ordered_set&lt;/code&gt; 유형의 테이블의 경우 테이블의 순회는 Erlang 용어 순서의 앞부분에있는 키가있는 개체로 계속됩니다. 반환 된 목록에는 역순으로 키가있는 객체도 포함됩니다. 다른 모든 테이블 유형의 경우 동작은 정확히 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 의 동작입니다 .</target>
        </trans-unit>
        <trans-unit id="058b95d57ca8bcafbb27b235c4372981f494e185" translate="yes" xml:space="preserve">
          <source>Continues a match started with &lt;code&gt;&lt;a href=&quot;#select_reverse-3&quot;&gt;select_reverse/3&lt;/a&gt;&lt;/code&gt;. For tables of type &lt;code&gt;ordered_set&lt;/code&gt;, the traversal of the table continues to objects with keys earlier in the Erlang term order. The returned list also contains objects with keys in reverse order. For all other table types, the behavior is exactly that of &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#select_reverse-3&quot;&gt;select_reverse/3&lt;/a&gt;&lt;/code&gt; 로 시작된 일치를 계속합니다 . &lt;code&gt;ordered_set&lt;/code&gt; 유형 의 테이블의 경우, 테이블 순회는 Erlang 용어 순서에서 이전에 키가있는 오브젝트를 계속합니다. 리턴 된리스트에는 키가있는 오브젝트도 역순으로 포함됩니다. 다른 모든 테이블 유형의 경우 동작은 정확히 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 의 동작입니다 .</target>
        </trans-unit>
        <trans-unit id="8990bdea87bba1599cb1fdcf1951a0e63de9aab9" translate="yes" xml:space="preserve">
          <source>Continues computing the adler32 checksum by combining the previous checksum, &lt;code&gt;OldAdler&lt;/code&gt;, with the checksum of &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">이전 체크섬 &lt;code&gt;OldAdler&lt;/code&gt; 와 &lt;code&gt;Data&lt;/code&gt; 체크섬을 결합하여 adler32 체크섬을 계속 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="4996c9d2c0f3507c722df9afeb51e0b92b87a37f" translate="yes" xml:space="preserve">
          <source>Continues computing the crc32 checksum by combining the previous checksum, &lt;code&gt;OldCrc&lt;/code&gt;, with the checksum of &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">이전 체크섬 &lt;code&gt;OldCrc&lt;/code&gt; 와 &lt;code&gt;Data&lt;/code&gt; 체크섬을 결합하여 crc32 체크섬 계산을 계속합니다 .</target>
        </trans-unit>
        <trans-unit id="da1ef0dedc7faef987b7a5a3deb0c768440cd306" translate="yes" xml:space="preserve">
          <source>Continues the execution until the current function returns.</source>
          <target state="translated">현재 함수가 반환 될 때까지 실행을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="b9a0121ae80323caf5e3871d3094c46759575a34" translate="yes" xml:space="preserve">
          <source>Continues the execution.</source>
          <target state="translated">실행을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="60ebcff772231040684a03eaac59ec0ef5b0efaf" translate="yes" xml:space="preserve">
          <source>Continuing the dialogue with the Erlang shell produces the following:</source>
          <target state="translated">Erlang 쉘과의 대화를 계속하면 다음이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="550a49346d51f6c69177d23de6582bd904a644a5" translate="yes" xml:space="preserve">
          <source>Continuing the example from the previous section, the three nodes are started, specifying the system configuration file:</source>
          <target state="translated">이전 섹션의 예제를 계속하여 시스템 구성 파일을 지정하여 세 개의 노드가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="154943d578744b27e5c0e12560a0ba0b4d4c5ec5" translate="yes" xml:space="preserve">
          <source>Contrary to the fact with &quot;handwritten&quot; match specifications, the &lt;code&gt;is_record&lt;/code&gt; guard works as in ordinary Erlang code.</source>
          <target state="translated">&quot;필기&quot;일치 스펙과는 &lt;code&gt;is_record&lt;/code&gt; guard는 일반적인 Erlang 코드에서와 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ea1d3df298ca84104dbf8b2f6f916c02f6f77c6e" translate="yes" xml:space="preserve">
          <source>Control</source>
          <target state="translated">Control</target>
        </trans-unit>
        <trans-unit id="046e85c2c64b10ec2f7a5a0972a793a917f581c6" translate="yes" xml:space="preserve">
          <source>Control A to control Z</source>
          <target state="translated">Z를 제어하기위한 A 제어</target>
        </trans-unit>
        <trans-unit id="bce115b0c925643288d6d66089149032ada8c603" translate="yes" xml:space="preserve">
          <source>Control characters</source>
          <target state="translated">제어 문자</target>
        </trans-unit>
        <trans-unit id="1bd11088990a2634cb50a4cfec1f5eac588c67e2" translate="yes" xml:space="preserve">
          <source>Control sequences, which have the general format &lt;code&gt;~*FMC&lt;/code&gt;, where:</source>
          <target state="translated">&lt;code&gt;~*FMC&lt;/code&gt; 일반 형식의 제어 순서. 여기서,</target>
        </trans-unit>
        <trans-unit id="ffca644d69cdda7bca9ab35919dc344a16cd88cb" translate="yes" xml:space="preserve">
          <source>Control the timer that a driver can use. The timer has the emulator call the &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt; timeout&lt;/a&gt;&lt;/code&gt; entry function after a specified time. Only one timer is available for each driver instance.</source>
          <target state="translated">운전자가 사용할 수있는 타이머를 제어합니다. 타이머는 지정된 시간 후에 에뮬레이터가 &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt; timeout&lt;/a&gt;&lt;/code&gt; 항목 함수를 호출하도록 합니다. 각 드라이버 인스턴스에 대해 하나의 타이머 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d30fd30f66df6d80482e65684b05e8c7c4bc0bb4" translate="yes" xml:space="preserve">
          <source>Control the timer that a driver can use. The timer has the emulator call the &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt; entry function after a specified time. Only one timer is available for each driver instance.</source>
          <target state="translated">드라이버가 사용할 수있는 타이머를 제어하십시오. 타이머는 지정된 시간이 지나면 에뮬레이터에서 &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt; 입력 기능을 호출합니다 . 각 드라이버 인스턴스마다 하나의 타이머 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eeaa2647da0732597913d53570b365738ee8b070" translate="yes" xml:space="preserve">
          <source>Controlling Bursts of Log Requests</source>
          <target state="translated">로그 요청 버스트 제어</target>
        </trans-unit>
        <trans-unit id="5f8185b4b9e44a4d0b11e748fbfb331ea2dacd6c" translate="yes" xml:space="preserve">
          <source>Controlling the Discrepancies Reported by Dialyzer</source>
          <target state="translated">Dialyzer가보고 한 불일치 제어</target>
        </trans-unit>
        <trans-unit id="3304568e9e0e1543499ce0803d55dd51136c2a1c" translate="yes" xml:space="preserve">
          <source>ControllingEntity :: port() | pid()}</source>
          <target state="translated">ControllingEntity :: 포트 () | pid ()}</target>
        </trans-unit>
        <trans-unit id="1d39ae8d696d2ab79619e780f95f15abc4711971" translate="yes" xml:space="preserve">
          <source>Controls how many reports &lt;code&gt;rb_server&lt;/code&gt; is to read at startup. This option is useful, as the directory can contain a large amount of reports. If this option is specified, the &lt;code&gt;MaxNoOfReports&lt;/code&gt; latest reports are read. Default is &lt;code&gt;all&lt;/code&gt;.</source>
          <target state="translated">시작시 &lt;code&gt;rb_server&lt;/code&gt; 가 읽을 보고서 수를 제어합니다 . 이 옵션은 디렉토리에 많은 양의 보고서가 포함될 수 있으므로 유용합니다. 이 옵션을 지정하면 &lt;code&gt;MaxNoOfReports&lt;/code&gt; 최신 보고서를 읽습니다. 기본값은 &lt;code&gt;all&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1d569f69f912af29157becf380c027c33c514e56" translate="yes" xml:space="preserve">
          <source>Controls if and how schedulers are bound to logical processors.</source>
          <target state="translated">스케줄러가 논리 프로세서에 바인딩되는지 여부와 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="c4c206d13c1cf477fffe7e0fbace2e00e092dbe0" translate="yes" xml:space="preserve">
          <source>Controls the level of debug printouts. Default is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">디버그 출력 레벨을 제어합니다. 기본값은 &lt;code&gt;none&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f467f08eaae850725a566433bcae52e439e5302a" translate="yes" xml:space="preserve">
          <source>Controls the number of log files written before older files are reused. Defaults to 5, minimum is 2, maximum is 1000.</source>
          <target state="translated">이전 파일을 재사용하기 전에 기록 된 로그 파일 수를 제어합니다. 기본값은 5, 최소값은 2, 최대 값은 1000입니다.</target>
        </trans-unit>
        <trans-unit id="2caaa1a4bcd099e84cf653002bba67518b149f50" translate="yes" xml:space="preserve">
          <source>Controls what kind of reports &lt;code&gt;rb_server&lt;/code&gt; is to read at startup. &lt;code&gt;ReportType&lt;/code&gt; is a supported type, &lt;code&gt;all&lt;/code&gt;, or a list of supported types. Default is &lt;code&gt;all&lt;/code&gt;.</source>
          <target state="translated">시작시 &lt;code&gt;rb_server&lt;/code&gt; 가 읽을 보고서 종류를 제어합니다 . &lt;code&gt;ReportType&lt;/code&gt; 은 지원되는 유형, &lt;code&gt;all&lt;/code&gt; 또는 지원되는 유형 목록입니다. 기본값은 &lt;code&gt;all&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="78f7ae24acbeb3e89d74388b0c043f4636b4e000" translate="yes" xml:space="preserve">
          <source>Controls what types of files to be compressed. Defaults to &lt;code&gt;all&lt;/code&gt;. The following values of &lt;code&gt;What&lt;/code&gt; are allowed:</source>
          <target state="translated">압축 할 파일 형식을 제어합니다. 기본값은 &lt;code&gt;all&lt;/code&gt; 입니다. 다음과 같은 값을 &lt;code&gt;What&lt;/code&gt; 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3fcba1873e0dd51f27a814aa230b6082f568ea52" translate="yes" xml:space="preserve">
          <source>Controls what types of files to be uncompressed. Defaults to &lt;code&gt;[&quot;.Z&quot;, &quot;.zip&quot;, &quot;.zoo&quot;, &quot;.arc&quot;, &quot;.lzh&quot;, &quot;.arj&quot;]&lt;/code&gt;. The following values of &lt;code&gt;What&lt;/code&gt; are allowed:</source>
          <target state="translated">압축 해제 할 파일 형식을 제어합니다. 기본값은 &lt;code&gt;[&quot;.Z&quot;, &quot;.zip&quot;, &quot;.zoo&quot;, &quot;.arc&quot;, &quot;.lzh&quot;, &quot;.arj&quot;]&lt;/code&gt; 입니다. 다음과 같은 값을 &lt;code&gt;What&lt;/code&gt; 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="72d4d021ee27a02ab04e242eb179eea92a205773" translate="yes" xml:space="preserve">
          <source>Controls whether to behave as a namespace conformant XML parser, 'false' (default) to not otherwise 'true'.</source>
          <target state="translated">네임 스페이스를 준수하는 XML 파서로 작동할지 여부를 'false'(기본값)가 아닌 경우 'true'로 제어합니다.</target>
        </trans-unit>
        <trans-unit id="014f53bfb51da0f31d7ad874005aae30ff2fdae7" translate="yes" xml:space="preserve">
          <source>Controls whether to process as a validating XML parser: 'off' (default) no validation, or validation 'dtd' by DTD or 'schema' by XML Schema. 'false' and 'true' options are obsolete (i.e. they may be removed in a future release), if used 'false' equals 'off' and 'true' equals 'dtd'.</source>
          <target state="translated">유효성 검증 XML 구문 분석기로 처리 할 것인지 여부를 제어합니다. 'off'(기본값) 유효성 검증 없음 또는 DTD에 의한 'dtd'또는 XML 스키마에 의한 'schema'. 'false'와 'true'는 'off', 'true'는 'dtd'와 같은 경우 'false'와 'true'옵션은 더 이상 사용되지 않습니다 (즉, 이후 릴리스에서 제거 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="a3bb7bd3cd29a5c3a6c03c82349c51e51bf95ff6" translate="yes" xml:space="preserve">
          <source>Controls which features to reject. This is mostly useful for the server as it can restrict the use of certain TFTP options or read/write access.</source>
          <target state="translated">거부 할 기능을 제어합니다. 이는 특정 TFTP 옵션 또는 읽기 / 쓰기 액세스 사용을 제한 할 수 있으므로 서버에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1c4be7e6e4f92b537985118ffae61f13674d390a" translate="yes" xml:space="preserve">
          <source>Convenience functions</source>
          <target state="translated">편의 기능</target>
        </trans-unit>
        <trans-unit id="5c1d5aa10fc30b8ff720235b29bc6f6835f69529" translate="yes" xml:space="preserve">
          <source>Convenience functions for microstate accounting</source>
          <target state="translated">소액 회계에 대한 편의 기능</target>
        </trans-unit>
        <trans-unit id="8ce25c173c335f61eac029ac12bf1102e9bcacfb" translate="yes" xml:space="preserve">
          <source>Convenience functions for some common name lookup functions.</source>
          <target state="translated">일부 일반적인 이름 조회 기능을위한 편의 기능.</target>
        </trans-unit>
        <trans-unit id="697e08358094ab2a49005b63006ea40b28418bea" translate="yes" xml:space="preserve">
          <source>Convenient to be used from the command line (erl -s et_viewer).</source>
          <target state="translated">명령 줄 (erl -s et_viewer)에서 사용하기 편리합니다.</target>
        </trans-unit>
        <trans-unit id="82972fa0f197d3cff3b3cec5ebfaa62f25d5f57a" translate="yes" xml:space="preserve">
          <source>Conventions Used in This Document</source>
          <target state="translated">이 문서에 사용 된 규칙</target>
        </trans-unit>
        <trans-unit id="8d2687667dee08113bf89108622393aba24f20fa" translate="yes" xml:space="preserve">
          <source>Conversion of data between C and Erlang formats</source>
          <target state="translated">C와 Erlang 형식 간 데이터 변환</target>
        </trans-unit>
        <trans-unit id="a7637a6e621da70105c089476553bfc5d74a542a" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;Raw Trace Data&lt;/code&gt; into an appropriate &lt;code&gt;Event&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Raw Trace Data&lt;/code&gt; 를 적절한 &lt;code&gt;Event&lt;/code&gt; 로 변환</target>
        </trans-unit>
        <trans-unit id="9fdde520c3a3d433579d6c33b3e490f3ec80c4b5" translate="yes" xml:space="preserve">
          <source>Convert a &lt;code&gt;RefURI&lt;/code&gt; reference that might be relative to a given base URI into the parsed components of the reference's target, which can then be recomposed to form the target URI.</source>
          <target state="translated">주어진 기본 URI에 상대적 일 수 있는 &lt;code&gt;RefURI&lt;/code&gt; 참조를 참조 대상의 구문 분석 된 구성 요소로 변환 한 다음 재구성하여 대상 URI를 형성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99a05219f8c5c7b0532f80113a0dad96f501d271" translate="yes" xml:space="preserve">
          <source>Convert a log message on report form to &lt;code&gt;{Format, Args}&lt;/code&gt;. This is the default report callback used by &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt; logger_formatter(3)&lt;/a&gt;&lt;/code&gt; when no custom report callback is found. See section &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; in the Kernel User's Guide for information about report callbacks and valid forms of log messages.</source>
          <target state="translated">보고서 양식의 로그 메시지를 &lt;code&gt;{Format, Args}&lt;/code&gt; 변환합니다 . 이것은 사용자 정의 보고서 콜백을 찾을 수 없을 때 &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt; logger_formatter(3)&lt;/a&gt;&lt;/code&gt; 사용하는 기본 보고서 콜백 입니다. 보고서 콜백 및 유효한 형식의 로그 메시지에 대한 정보는 커널 사용자 가이드의 &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e08b6dbc72e0b9830476f0a00a81ef9d8b25c7b" translate="yes" xml:space="preserve">
          <source>Convert a log message on report form to &lt;code&gt;{Format, Args}&lt;/code&gt;. This is the default report callback used by &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter&lt;/a&gt;&lt;/code&gt; when no custom report callback is found. See section &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; in the Kernel User's Guide for information about report callbacks and valid forms of log messages.</source>
          <target state="translated">보고서 양식의 로그 메시지를 &lt;code&gt;{Format, Args}&lt;/code&gt; . 사용자 정의 보고서 콜백이 없을 때 &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter&lt;/a&gt;&lt;/code&gt; 에서 사용하는 기본 보고서 콜백 입니다. 보고서 콜백 및 유효한 형식의 로그 메시지에 대한 정보는 커널 사용자 안내서의 &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f555788b20b5f7be0fc65347cd28b0e5580c6e4" translate="yes" xml:space="preserve">
          <source>Convert a token tag to a string</source>
          <target state="translated">토큰 태그를 문자열로 변환</target>
        </trans-unit>
        <trans-unit id="044a64115586f4d31170517f8714ccd4f18c3c87" translate="yes" xml:space="preserve">
          <source>Convert an IPv4 address to an IPv4-mapped IPv6 address or the reverse. When converting from an IPv6 address all but the 2 low words are ignored so this function also works on some other types of addresses than IPv4-mapped.</source>
          <target state="translated">IPv4 주소를 IPv4로 매핑 된 IPv6 주소로 또는 그 반대로 변환하십시오. IPv6 주소에서 변환 할 때 2 개의 하위 단어를 제외한 모든 단어는 무시되므로이 기능은 IPv4 매핑 이외의 다른 유형의 주소에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="85648e18f68f2ea31b9073f5d647f354e9027d9e" translate="yes" xml:space="preserve">
          <source>Convert binary representation, of an integer, to an Erlang integer.</source>
          <target state="translated">정수의 이진 표현을 Erlang 정수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="19f5c5b5e2440fd1432aaad4d1dccfb67de8582b" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;&lt;a href=&quot;#type-erl_cipher_suite&quot;&gt;erl_cipher_suite()&lt;/a&gt;&lt;/code&gt; to OpenSSL name string.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-erl_cipher_suite&quot;&gt;erl_cipher_suite()&lt;/a&gt;&lt;/code&gt; 를 OpenSSL 이름 문자열로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="00d1f5a857dbd91b22c2e606f74ae73b3d9ca632" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;&lt;a href=&quot;#type-erl_cipher_suite&quot;&gt;erl_cipher_suite()&lt;/a&gt;&lt;/code&gt; to RFC name string.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-erl_cipher_suite&quot;&gt;erl_cipher_suite()&lt;/a&gt;&lt;/code&gt; 를 RFC 이름 문자열로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="12bd127af4ad25815294c36888f6e3b3cb5271a2" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;Key&lt;/code&gt; to an OBJECT IDENTIFIER.</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; 를 객체 식별자로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="64acc9e991da9583e9d8988fd1ae350af1f7d94a" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;Path&lt;/code&gt; to a form accepted by the command shell and native applications on the current platform. On Windows, forward slashes are converted to backward slashes. On all platforms, the name is normalized as done by &lt;code&gt;&lt;a href=&quot;#join-1&quot;&gt;join/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Path&lt;/code&gt; 를 현재 플랫폼의 명령 쉘 및 기본 애플리케이션이 승인 한 양식으로 변환 합니다. Windows에서는 슬래시가 백 슬래시로 변환됩니다. 모든 플랫폼에서 이름은 &lt;code&gt;&lt;a href=&quot;#join-1&quot;&gt;join/1&lt;/a&gt;&lt;/code&gt; 에 의해 수행 된대로 정규화됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea3719a7fe934bac8263241169003d73b077c876" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;String&lt;/code&gt; to a case-agnostic comparable string. Function &lt;code&gt;casefold/1&lt;/code&gt; is preferred over &lt;code&gt;lowercase/1&lt;/code&gt; when two strings are to be compared for equality. See also &lt;code&gt;&lt;a href=&quot;#equal-4&quot;&gt;equal/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 을 대소 문자를 구분하지 않는 문자열 로 변환 합니다. 기능 &lt;code&gt;casefold/1&lt;/code&gt; 이상이 바람직하다 &lt;code&gt;lowercase/1&lt;/code&gt; 개의 문자열 어떤지를 비교하는 경우. &lt;code&gt;&lt;a href=&quot;#equal-4&quot;&gt;equal/4&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="83e6c836c0fe9bf44d0723384551fd211532d6a7" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;String&lt;/code&gt; to a list of grapheme clusters.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 을 grapheme 클러스터 목록으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="d925e32023288904ae94a121d00ca3faaf1f0cb6" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;String&lt;/code&gt; to lowercase.</source>
          <target state="translated">변환 &lt;code&gt;String&lt;/code&gt; 소문자로.</target>
        </trans-unit>
        <trans-unit id="64e823d13feb3b6235edac36b29ebd1b351753fe" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;String&lt;/code&gt; to titlecase.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 을 titlecase로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="40712f79e161abafd2f0cece5db1aa7f56d35ac2" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;String&lt;/code&gt; to uppercase.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 을 대문자로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="814be0b57ea4927c8c3826c53afee5e64f538f9e" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;Subject&lt;/code&gt; to a list of &lt;code&gt;byte()&lt;/code&gt;s, each representing the value of one byte. &lt;code&gt;part()&lt;/code&gt; denotes which part of the &lt;code&gt;binary()&lt;/code&gt; to convert.</source>
          <target state="translated">&lt;code&gt;Subject&lt;/code&gt; 를 &lt;code&gt;byte()&lt;/code&gt; 리스트로 변환 합니다. 각리스트 는 1 바이트의 값을 나타냅니다. &lt;code&gt;part()&lt;/code&gt; 는 &lt;code&gt;binary()&lt;/code&gt; 에서 변환 할 부분을 ​​나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="84357bb46ef942f3222928aff9a548ada141350b" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt; to pid &lt;code&gt;&amp;lt;X.Y.Z&amp;gt;&lt;/code&gt;. This function is only to be used when debugging.</source>
          <target state="translated">변환 &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;Y&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; PID에 &lt;code&gt;&amp;lt;X.Y.Z&amp;gt;&lt;/code&gt; . 이 기능은 디버깅 할 때만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e870de6673fb58678c90b76e38c40fdef81ef7e8" translate="yes" xml:space="preserve">
          <source>Converts Universal Time Coordinated (UTC) date and time to local date and time in the form &lt;code&gt;{{Year, Month, Day}, {Hour, Minute, Second}}&lt;/code&gt; if supported by the underlying OS. Otherwise no conversion is done, and &lt;code&gt;Universaltime&lt;/code&gt; is returned. Example:</source>
          <target state="translated">기본 OS에서 지원하는 경우 UTC (협정 세계시) 날짜 및 시간을 &lt;code&gt;{{Year, Month, Day}, {Hour, Minute, Second}}&lt;/code&gt; 형식으로 현지 날짜 및 시간으로 변환합니다 . 그렇지 않으면 변환이 수행되지 않으며 &lt;code&gt;Universaltime&lt;/code&gt; 이 반환됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="dfd120e608567bf8e0e047df635cd48870a704de" translate="yes" xml:space="preserve">
          <source>Converts a DateAndTime list to a list of possible universal time(s). The universal time value on the same format as defined in calendar(3).</source>
          <target state="translated">DateAndTime 목록을 가능한 표준시 목록으로 변환합니다. calendar (3)에 정의 된 형식과 동일한 형식의 표준시입니다.</target>
        </trans-unit>
        <trans-unit id="be2ab7a898419e8c5bc5fb6864e946862fab27d5" translate="yes" xml:space="preserve">
          <source>Converts a DateAndTime list to a printable string, according to the DISPLAY-HINT definition in RFC2579, with the extension that it also allows the values &quot;hours from UTC&quot; = 14 together with &quot;minutes from UTC&quot; = 0.</source>
          <target state="translated">RFC2579의 DISPLAY-HINT 정의에 따라 DateAndTime 목록을 인쇄 가능한 문자열로 변환합니다. 확장자는 &quot;UTC에서 시간&quot;= 14와 함께 &quot;분에서 UTC&quot;= 0으로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="6e6041bd2c7a5e4ff13a4f7ea74a578cac2bcdd0" translate="yes" xml:space="preserve">
          <source>Converts a DateAndTime list to a printable string, according to the DISPLAY-HINT definition in RFC2579.</source>
          <target state="translated">RFC2579의 DISPLAY-HINT 정의에 따라 DateAndTime 목록을 인쇄 가능한 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="df82c9aad820e9aeb421a06ce9d86abf62090da6" translate="yes" xml:space="preserve">
          <source>Converts a POSIX error code to a string (by calling &lt;code&gt;erl_posix_msg:message/1&lt;/code&gt;).</source>
          <target state="translated">POSIX 오류 코드를 문자열로 변환합니다 ( &lt;code&gt;erl_posix_msg:message/1&lt;/code&gt; 을 호출 하여 ).</target>
        </trans-unit>
        <trans-unit id="7cb36a1d5c42c93d73e9a9490af62b196a3459ce" translate="yes" xml:space="preserve">
          <source>Converts a dictionary to a list representation.</source>
          <target state="translated">사전을 목록 표현으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="5145233388e4e63192922244ccdc8aad08c100c4" translate="yes" xml:space="preserve">
          <source>Converts a line in an Apache-like configuration file to an &lt;code&gt;{Option, Value}&lt;/code&gt; tuple. Some more complex configuration options, such as &lt;code&gt;directory&lt;/code&gt; and &lt;code&gt;security_directory&lt;/code&gt;, create an accumulator. This function only needs clauses for the options implemented by this particular callback module.</source>
          <target state="translated">Apache와 같은 구성 파일의 행을 &lt;code&gt;{Option, Value}&lt;/code&gt; 튜플로 변환합니다. &lt;code&gt;directory&lt;/code&gt; 및 &lt;code&gt;security_directory&lt;/code&gt; 와 같은 좀 더 복잡한 구성 옵션 은 누산기를 만듭니다. 이 함수는이 특정 콜백 모듈에 의해 구현 된 옵션에 대한 절만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1ba2baaacb5bd1fa86bcae22233808d6f9af2ca7" translate="yes" xml:space="preserve">
          <source>Converts a list to an extendible array. &lt;code&gt;Default&lt;/code&gt; is used as the value for uninitialized entries of the array. If &lt;code&gt;List&lt;/code&gt; is not a proper list, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">목록을 확장 가능한 배열로 변환합니다. &lt;code&gt;Default&lt;/code&gt; 은 배열의 초기화되지 않은 항목에 대한 값으로 사용됩니다. &lt;code&gt;List&lt;/code&gt; 가 올바른 목록 이 아닌 경우 reason &lt;code&gt;badarg&lt;/code&gt; 로 호출에 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="46ccd780115ddb3db3a4fceec0e82dd6e0b6fc95" translate="yes" xml:space="preserve">
          <source>Converts a local time value to a list of possible DateAndTime list(s). The local time value on the same format as defined in calendar(3).</source>
          <target state="translated">현지 시간 값을 가능한 DateAndTime 목록으로 변환합니다. calendar (3)에 정의 된 것과 동일한 형식의 현지 시간 값입니다.</target>
        </trans-unit>
        <trans-unit id="0677e1933e311ee3ab43091b45e003180be5b30d" translate="yes" xml:space="preserve">
          <source>Converts a port handle to the Erlang term format, usable in &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt; erl_drv_output_term&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#erl_drv_send_term&quot;&gt; erl_drv_send_term&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">포트 핸들을 &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt; erl_drv_output_term&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#erl_drv_send_term&quot;&gt; erl_drv_send_term&lt;/a&gt;&lt;/code&gt; 에서 사용할 수있는 Erlang 용어 형식으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="1ed8f6dfcb33426ca4e1a7205c23417d3a9d60fa" translate="yes" xml:space="preserve">
          <source>Converts a port handle to the Erlang term format, usable in &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt;erl_drv_output_term&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#erl_drv_send_term&quot;&gt;erl_drv_send_term&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">포트 핸들을 &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt;erl_drv_output_term&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#erl_drv_send_term&quot;&gt;erl_drv_send_term&lt;/a&gt;&lt;/code&gt; 에서 사용 가능한 Erlang 용어 형식으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="f1537e7dd396d1f3ae28bd863e00e7d4f2a0ff80" translate="yes" xml:space="preserve">
          <source>Converts a positive integer to the smallest possible representation in a binary digit representation, either big endian or little endian.</source>
          <target state="translated">양의 정수를 이진 숫자 표현 (빅 엔디안 또는 리틀 엔디안)에서 가능한 가장 작은 표현으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4b06d2c3db2372af5cb08f262a3a235fead48580" translate="yes" xml:space="preserve">
          <source>Converts a possibly deep list filename consisting of characters and atoms into the corresponding flat string filename.</source>
          <target state="translated">문자와 원자로 구성된 가능한 깊은 목록 파일 이름을 해당 플랫 문자열 파일 이름으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="bcdf5ec8404937f0cc26b604615b645a3d632e2c" translate="yes" xml:space="preserve">
          <source>Converts a possibly deep list of characters and binaries into a Normalized Form of canonical equivalent Composed characters according to the Unicode standard.</source>
          <target state="translated">가능한 깊은 문자 및 이진 목록을 유니 코드 표준에 따라 정규화 된 동등한 형식의 정규화 된 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="25cde6c5eb02ad4f574bba02ec1c6f1c1e5ac62f" translate="yes" xml:space="preserve">
          <source>Converts a possibly deep list of characters and binaries into a Normalized Form of canonical equivalent Decomposed characters according to the Unicode standard.</source>
          <target state="translated">가능한 깊은 문자 및 이진 목록을 유니 코드 표준에 따라 정규화 된 동등한 형식의 분해 된 문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3756e2cde9505923edd4d4e14aa5e042f713b23b" translate="yes" xml:space="preserve">
          <source>Converts a possibly deep list of characters and binaries into a Normalized Form of compatibly equivalent Composed characters according to the Unicode standard.</source>
          <target state="translated">가능한 심도 깊은 문자 및 이진 목록을 유니 코드 표준에 따라 호환되는 동등한 문자의 정규화 된 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="530b1c8ab020feea5c4599c3a34122f44f338da2" translate="yes" xml:space="preserve">
          <source>Converts a possibly deep list of characters and binaries into a Normalized Form of compatibly equivalent Decomposed characters according to the Unicode standard.</source>
          <target state="translated">가능한 깊은 문자 및 이진 목록을 유니 코드 표준에 따라 비슷한 수준의 분해 된 문자로 표준화 된 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="eea7568b698b464020aabc3712d814408bd4a0f7" translate="yes" xml:space="preserve">
          <source>Converts a possibly deep list of integers and binaries into a list of integers representing Unicode characters. The binaries in the input can have characters encoded as one of the following:</source>
          <target state="translated">가능한 정수 및 이진 목록을 유니 코드 문자를 나타내는 정수 목록으로 변환합니다. 입력의 바이너리에는 다음 중 하나로 인코딩 된 문자가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24b7abb99fbb61c37725003b7ae6ea6832706f64" translate="yes" xml:space="preserve">
          <source>Converts a relative &lt;code&gt;Filename&lt;/code&gt; and returns an absolute name. No attempt is made to create the shortest absolute name, as this can give incorrect results on file systems that allow links.</source>
          <target state="translated">상대 &lt;code&gt;Filename&lt;/code&gt; 변환하고 절대 이름을 반환합니다. 링크를 허용하는 파일 시스템에서 잘못된 결과를 얻을 수 있으므로 가장 짧은 절대 이름을 작성하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="671a1aeac87b27d23dd6ee2e34e272472de95a3a" translate="yes" xml:space="preserve">
          <source>Converts a specified number of seconds into days, hours, minutes, and seconds. &lt;code&gt;Time&lt;/code&gt; is always non-negative, but &lt;code&gt;Days&lt;/code&gt; is negative if argument &lt;code&gt;Seconds&lt;/code&gt; is.</source>
          <target state="translated">지정된 초 수를 일, 시간, 분 및 초로 변환합니다. &lt;code&gt;Time&lt;/code&gt; 은 항상 음수가 아니지만 인수 &lt;code&gt;Seconds&lt;/code&gt; 가 있으면 &lt;code&gt;Days&lt;/code&gt; 는 음수 입니다.</target>
        </trans-unit>
        <trans-unit id="ed3af2f954d658c30bda990c05b304fc42cc2658" translate="yes" xml:space="preserve">
          <source>Converts a specified system time into local date and time.</source>
          <target state="translated">지정된 시스템 시간을 현지 날짜 및 시간으로 변환합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
