<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="0f9944b699387d7c11ea7cd1be3bab23ba4afdef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.appup&lt;/code&gt; file contains one single Erlang term, which defines the instructions used to upgrade or downgrade the application. The file has the following syntax:</source>
          <target state="translated">&lt;code&gt;.appup&lt;/code&gt; 의 파일을 업그레이드하거나 응용 프로그램을 다운 그레이드하는 데 사용되는 지침을 정의하는 하나 개의 얼랑 용어가 포함되어 있습니다. 파일의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a4e2f387f9c84aa65d3380a5a44029b602ea3fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.erlang.cookie&lt;/code&gt; file is to contain a line with the same atom. For example, on Linux or UNIX, in the OS shell:</source>
          <target state="translated">&lt;code&gt;.erlang.cookie&lt;/code&gt; 의 파일이 동일한 원자와 함께 광고를 포함한다. 예를 들어 Linux 또는 UNIX의 OS 셸에서 :</target>
        </trans-unit>
        <trans-unit id="0032fcf48e0da685e59294f0a4f697a2db8dcacb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.funcs&lt;/code&gt; file would look like:</source>
          <target state="translated">&lt;code&gt;.funcs&lt;/code&gt; 의 파일과 같을 것이다 :</target>
        </trans-unit>
        <trans-unit id="14e7547174b37977afa693aeffb001d289cd5a55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.hrl&lt;/code&gt; files are generated with &lt;code&gt;snmpc:mib_to_hrl/1&lt;/code&gt;. Include these files in your code as in the following example:</source>
          <target state="translated">&lt;code&gt;.hrl&lt;/code&gt; 파일이 생성됩니다 &lt;code&gt;snmpc:mib_to_hrl/1&lt;/code&gt; . 다음 예제와 같이 이러한 파일을 코드에 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="3f3c52adfe9451ed557d5cb72636a16ce9b8cff5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.rel&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;.rel&lt;/code&gt; 의 파일</target>
        </trans-unit>
        <trans-unit id="f61412bcc5809a8e7db35485d4bc2ee4c582bd3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.rel&lt;/code&gt; file contains information about the release: its name, version, and which ERTS and application versions it uses.</source>
          <target state="translated">&lt;code&gt;.rel&lt;/code&gt; 의 이름, 버전, 어떤 ERTS 및 응용 프로그램 버전이 사용 : 파일이 릴리스에 대한 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fba0dc5cd4e50a75950facea5ebefcde4b2c40d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.rel&lt;/code&gt; file contains one single Erlang term, which is called a &lt;strong&gt;release specification&lt;/strong&gt;. The file has the following syntax:</source>
          <target state="translated">&lt;code&gt;.rel&lt;/code&gt; 의 파일은이라고 하나 개 얼랑 용어가 포함되어 &lt;strong&gt;출시 사양&lt;/strong&gt; . 파일의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9be75095f9fcc28e6742d9c5c6b665ebdc21fd1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.rel&lt;/code&gt; file must also contain &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;stdlib&lt;/code&gt;, and &lt;code&gt;sasl&lt;/code&gt;, as these applications are required by &lt;code&gt;ch_app&lt;/code&gt;. The file is called &lt;code&gt;ch_rel-1.rel&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;.rel&lt;/code&gt; 의 파일도 있어야합니다 &lt;code&gt;kernel&lt;/code&gt; , &lt;code&gt;stdlib&lt;/code&gt; 및 &lt;code&gt;sasl&lt;/code&gt; 이러한 응용 프로그램이 요구하는대로, &lt;code&gt;ch_app&lt;/code&gt; . 파일 이름은 &lt;code&gt;ch_rel-1.rel&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="13be72d295c9d3a74b0ba266a8b6d753044e4f9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.script&lt;/code&gt; file is generated by &lt;code&gt;systools&lt;/code&gt; from a &lt;code&gt;.rel&lt;/code&gt; file and from &lt;code&gt;.app&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;.script&lt;/code&gt; 파일에 의해 생성되는 &lt;code&gt;systools&lt;/code&gt; A로부터 &lt;code&gt;.rel&lt;/code&gt; 의 파일에서 &lt;code&gt;.app&lt;/code&gt; 파일입니다.</target>
        </trans-unit>
        <trans-unit id="8952d3b159688281512664b4559315ca46a6b2ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; in which the resolved process id is stored.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; 가 있는 해결 프로세스 ID는 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="7f0ba8ce42f3241f6f1e8ce8e3ec88bd285be952" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#ErlNifPort&quot;&gt;ErlNifPort&lt;/a&gt;&lt;/code&gt; in which the resolved port id is stored.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#ErlNifPort&quot;&gt;ErlNifPort&lt;/a&gt;&lt;/code&gt; 가 있는 해결 포트 ID가 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="9be61e44d94622615ce4101938ee713afd7cdab2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;default time warp mode&lt;/a&gt;&lt;/code&gt; has the same behavior as before, and the old API still works. Thus, you are not required to change anything unless you want to. However, &lt;strong&gt;you are strongly encouraged to use the new API&lt;/strong&gt; instead of the old API based on &lt;code&gt;&lt;a href=&quot;erlang#now-0&quot;&gt;erlang:now/0&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;erlang:now/0&lt;/code&gt; is deprecated, as it is and will be a scalability bottleneck.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;default time warp mode&lt;/a&gt;&lt;/code&gt; 이전과 동일한 동작을 가지고 있으며, 기존의 API는 여전히 작동합니다. 따라서 원치 않는 한 아무것도 변경하지 않아도됩니다. 그러나 &lt;code&gt;&lt;a href=&quot;erlang#now-0&quot;&gt;erlang:now/0&lt;/a&gt;&lt;/code&gt; 기반의 기존 API 대신 &lt;strong&gt;새 API를 사용하는 것이 좋습니다&lt;/strong&gt; . &lt;code&gt;erlang:now/0&lt;/code&gt; 은 확장 성 병목 상태이므로 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18bf0f08971899dc4f16a1b00f5aad47c098d502" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt;&lt;code&gt;postpone&lt;/code&gt; is designed to model selective receives. A selective receive implicitly postpones any not received events, but the &lt;code&gt;postpone&lt;/code&gt; state transition action explicitly postpones one received event.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt; &lt;code&gt;postpone&lt;/code&gt; 모델 선택적으로 수신하도록 설계되었습니다. 선택적 수신은 수신되지 않은 이벤트를 암시 적으로 연기하지만 &lt;code&gt;postpone&lt;/code&gt; 상태 전환 조치는 하나의 수신 이벤트를 명시 적으로 연기합니다.</target>
        </trans-unit>
        <trans-unit id="2e521122544eb6fa9ab0cd68ed9751d9d365e33f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; of Erlang monotonic time heavily depends on the following:</source>
          <target state="translated">Erlang 단조 시간 의 &lt;code&gt;&lt;a href=&quot;#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; 는 다음에 크게 좌우됩니다.</target>
        </trans-unit>
        <trans-unit id="da959f4f913bd754095c0cffc4af1e4cec02fe00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt;&lt;code&gt;postpone&lt;/code&gt; is designed to model selective receives. A selective receive implicitly postpones any not received events, but the &lt;code&gt;postpone&lt;/code&gt;&lt;strong&gt;transition action&lt;/strong&gt; explicitly postpones one received event.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; &lt;code&gt;postpone&lt;/code&gt; 모델 선택을 수신하도록 설계된다. 선택적 수신은 수신되지 않은 이벤트를 암시 적으로 연기하지만 &lt;code&gt;postpone&lt;/code&gt; &lt;strong&gt;전환 조치&lt;/strong&gt; 는 수신 된 이벤트 하나를 명시 적으로 연기합니다. &lt;strong&gt;&lt;/strong&gt; &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee853e7e00e08008dc7e059fac73729f774dbe00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#enif_consume_timeslice&quot;&gt; enif_consume_timeslice()&lt;/a&gt;&lt;/code&gt; function can be used to inform the runtime system about the length of the NIF call. It is typically always to be used unless the NIF executes very fast.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_consume_timeslice&quot;&gt; enif_consume_timeslice()&lt;/a&gt;&lt;/code&gt; 함수가 호출 NIF의 길이에 대해 런타임 시스템에 통보 할 수있다. NIF가 매우 빠르게 실행되지 않는 한 일반적으로 항상 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6f631a391a9754e49e6ee1bde4ff6f90ac52a87f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#enif_consume_timeslice&quot;&gt;enif_consume_timeslice()&lt;/a&gt;&lt;/code&gt; function can be used to inform the runtime system about the length of the NIF call. It is typically always to be used unless the NIF executes very fast.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_consume_timeslice&quot;&gt;enif_consume_timeslice()&lt;/a&gt;&lt;/code&gt; 함수가 호출 NIF의 길이에 대해 런타임 시스템에 통보 할 수있다. NIF가 매우 빠르게 실행되지 않는 한 일반적으로 항상 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="42203200dce5d30a841bfbad273ab03cca628668" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#header&quot;&gt;header()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#packet&quot;&gt;packet()&lt;/a&gt;&lt;/code&gt; records below are defined in diameter.hrl, which can be included as follows.</source>
          <target state="translated">아래의 &lt;code&gt;&lt;a href=&quot;#header&quot;&gt;header()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#packet&quot;&gt;packet()&lt;/a&gt;&lt;/code&gt; 레코드는 diameter.hrl로 정의되며 다음과 같이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5443a5673cfdeb62b70cfaa66a1a4d05ea2c10ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#interpret&quot;&gt;Interpret Modules window&lt;/a&gt;&lt;/code&gt; is displayed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#interpret&quot;&gt;Interpret Modules window&lt;/a&gt;&lt;/code&gt; 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="64917e182873d825bb4118b082544cb5020d55ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#is_tree-1&quot;&gt;is_tree/1&lt;/a&gt;&lt;/code&gt; test is not completely foolproof. For a few special node types (e.g. &lt;code&gt;arity_qualifier&lt;/code&gt;), if such a node occurs in a context where it is not expected, it will be left unchanged as a non-reverted subtree of the result. This can only happen if &lt;code&gt;Tree&lt;/code&gt; does not actually represent legal Erlang code.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#is_tree-1&quot;&gt;is_tree/1&lt;/a&gt;&lt;/code&gt; 테스트가 완전히 고장이 아닙니다. 몇 가지 특수 노드 유형 (예 : &lt;code&gt;arity_qualifier&lt;/code&gt; )의 경우, 그러한 노드가 예상되지 않은 컨텍스트에서 발생하면 결과의 되 돌리지 않은 서브 트리로 변경되지 않습니다. &lt;code&gt;Tree&lt;/code&gt; 가 실제로 올바른 Erlang 코드를 나타내지 않는 경우에만 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8bdddf2d9e89b5afec27570549313f0a00dfb66c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor window&lt;/a&gt;&lt;/code&gt; is displayed with information about all debugged processes, interpreted modules, and selected options. Initially there are normally no debugged processes. First, it must be specified which modules that are to be &lt;strong&gt;debugged&lt;/strong&gt; (also called &lt;strong&gt;interpreted&lt;/strong&gt;). Proceed as follows:</source>
          <target state="translated">모든 디버그 된 프로세스, 해석 된 모듈 및 선택한 옵션에 대한 정보가 있는 &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor window&lt;/a&gt;&lt;/code&gt; 표시됩니다. 처음에는 일반적으로 디버깅 된 프로세스가 없습니다. 먼저 &lt;strong&gt;디버깅&lt;/strong&gt; 할 모듈을 지정해야합니다 ( &lt;strong&gt;interpret&lt;/strong&gt; 이라고도 함 ). 다음과 같이 진행하십시오 :</target>
        </trans-unit>
        <trans-unit id="d1371003c4109f45bb7c590d9e6bfcf741d3783e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;native&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; at the time when current Erlang runtime system instance started.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;native&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; 시간에 현재 얼랑 런타임 시스템 인스턴스를 시작했을 때.</target>
        </trans-unit>
        <trans-unit id="c54a199fd4640b0c1f2d1a7d7f234a5d11ebf160" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#regexp_syntax&quot;&gt;regular expression&lt;/a&gt;&lt;/code&gt; syntax and semantics resemble that of Perl.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#regexp_syntax&quot;&gt;regular expression&lt;/a&gt;&lt;/code&gt; 구문과 의미는 펄의 유사.</target>
        </trans-unit>
        <trans-unit id="86910d8a99b113804f6c41ebe30ba830eeca44e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; can insert events using the &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;&lt;strong&gt;transition actions&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;&lt;code&gt;next_event&lt;/code&gt; and such an event is inserted in the event queue as the next to call the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; with. That is, as if it is the oldest incoming event. A dedicated &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;internal&lt;/code&gt; can be used for such events making them impossible to mistake for external events.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 사용하여 이벤트 삽입 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;&lt;strong&gt;transition actions&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; &lt;code&gt;next_event&lt;/code&gt; 과 같은 이벤트가 호출 다음과 같은 이벤트 큐에 삽입 된 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 함께합니다. 즉, 가장 오래된 수신 이벤트 인 것처럼 보입니다. 이러한 이벤트 에는 전용 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;internal&lt;/code&gt; 를 사용하여 외부 이벤트로 착각 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ddaf5a8cfd6684f5a32a7cfde1c55113cf46f155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; may return &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;&lt;strong&gt;transition actions&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;gen_statem&lt;/code&gt; to execute during the &lt;strong&gt;state transition&lt;/strong&gt;, for example to reply to a &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;gen_statem:call/2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 반환 할 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;&lt;strong&gt;transition actions&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 위한 &lt;code&gt;gen_statem&lt;/code&gt; 가 동안 실행 &lt;strong&gt;상태 천이&lt;/strong&gt; 예에 회신하기위한 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;gen_statem:call/2,3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7246167f3c09c6525874f60b11ba89db7e2744c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; can insert events using the &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;next_event&lt;/code&gt; and such an event is inserted as the next to present to the state callback. That is, as if it is the oldest incoming event. A dedicated &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;internal&lt;/code&gt; can be used for such events making them impossible to mistake for external events.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 은 USING 이벤트를 삽입 할 수있는 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;next_event&lt;/code&gt; 를 이러한 이벤트는 상태 콜백 현재까지 다음과 같이 삽입된다. 즉, 가장 오래된 수신 이벤트 인 것처럼. 이러한 이벤트에 전용 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;internal&lt;/code&gt; 를 사용하면 외부 이벤트로 착각 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8dc397f4aad495e70f783e4e9f18314a11b4699a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; are executed when entering the first &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; just as for a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, except that the action &lt;code&gt;postpone&lt;/code&gt; is forced to &lt;code&gt;false&lt;/code&gt; since there is no event to postpone.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; 처음 입력 할 때 실행되는 &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 단지에 관해서 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 작업이 점을 제외하고 &lt;code&gt;postpone&lt;/code&gt; 에 강제 &lt;code&gt;false&lt;/code&gt; 연기 할 이벤트가 없기 때문이다.</target>
        </trans-unit>
        <trans-unit id="d79b4de0faec73ea8a56c3d33b4728d0d0f13117" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; are executed when entering the first &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; just as for a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;, except that the action &lt;code&gt;postpone&lt;/code&gt; is forced to &lt;code&gt;false&lt;/code&gt; since there is no event to postpone.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; 처음 입력 할 때 실행되는 &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 단지에 관해서 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 작업이 점을 제외하고 &lt;code&gt;postpone&lt;/code&gt; 에 강제 &lt;code&gt;false&lt;/code&gt; 연기 할 이벤트가 없기 때문이다.</target>
        </trans-unit>
        <trans-unit id="4b95289b0c26b39ec2e6bba34c2ea61ee391b999" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec-option&lt;/a&gt;&lt;/code&gt; has existed for a long time but has not previously been documented. The old definition and behaviour are retained but obey the rules 1-6 above if conflicting. The old and undocumented style should not be used in new programs.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec-option&lt;/a&gt;&lt;/code&gt; 오랜 시간 동안 존재했지만 이전에 문서화되지 않았습니다. 이전의 정의와 행동은 유지되지만 상충되는 경우 위의 규칙 1-6을 따릅니다. 이전 및 문서화되지 않은 스타일은 새 프로그램에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="99afc1abdda369a0914949188ce7fb06901f6f8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec_spec&lt;/a&gt;&lt;/code&gt;&lt;code&gt;fun()&lt;/code&gt; is called with the same number of parameters as the arity of the fun, and the result is returned to the client. Shell-requests are not affected, they follow the &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell_spec&lt;/a&gt;&lt;/code&gt;'s value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec_spec&lt;/a&gt;&lt;/code&gt; &lt;code&gt;fun()&lt;/code&gt; 재미의 인수에 대응으로 같은 수의 매개 변수로 호출하고, 그 결과를 클라이언트에 반환됩니다. 쉘 요청은 영향을받지 않으며 &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell_spec&lt;/a&gt;&lt;/code&gt; 의 값 을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="04249803fd25f8d18a129af7ec7559589758bac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-host_accepting_client_options&quot;&gt;host_accepting_client_options()&lt;/a&gt;&lt;/code&gt; are associated with this list of keys.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-host_accepting_client_options&quot;&gt;host_accepting_client_options()&lt;/a&gt;&lt;/code&gt; 키의 목록과 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c47299082b86fea81f7b73b85c3b481aabd9d033" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-server_id&quot;&gt;server_id()&lt;/a&gt;&lt;/code&gt; or an associated &lt;code&gt;&lt;a href=&quot;ct#type-target_name&quot;&gt;ct:target_name()&lt;/a&gt;&lt;/code&gt; can then be passed to the aforementioned functions to use the referenced configuration.</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;#type-server_id&quot;&gt;server_id()&lt;/a&gt;&lt;/code&gt; 또는 관련 &lt;code&gt;&lt;a href=&quot;ct#type-target_name&quot;&gt;ct:target_name()&lt;/a&gt;&lt;/code&gt; 을 앞서 언급 한 함수에 전달하여 참조 된 구성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e395a27eee95c6082f8cf61222aaf962540cea2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-server_id&quot;&gt;server_id()&lt;/a&gt;&lt;/code&gt; or an associated &lt;code&gt;&lt;a href=&quot;ct#type-target_name&quot;&gt;ct:target_name()&lt;/a&gt;&lt;/code&gt; must then be used in calls to &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;#type-server_id&quot;&gt;server_id()&lt;/a&gt;&lt;/code&gt; 또는 연관된 &lt;code&gt;&lt;a href=&quot;ct#type-target_name&quot;&gt;ct:target_name()&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 호출에서 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e3dc033ce6bd037856bac83ebd4f39855340ec51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time_unit()&lt;/a&gt;&lt;/code&gt; type also consist of the following &lt;strong&gt;deprecated&lt;/strong&gt; symbolic time units:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time_unit()&lt;/a&gt;&lt;/code&gt; 유형은 다음과 같이 구성 &lt;strong&gt;되지&lt;/strong&gt; 상징적 인 시간 단위 :</target>
        </trans-unit>
        <trans-unit id="88d76a69dffe86852b03f6f2771d64a235602ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; is expected to know if reloading is demanded before creating a monitor for loading.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 다시로드로드에 대한 모니터를 작성하기 전에 요구되는 알고 것으로 예상된다.</target>
        </trans-unit>
        <trans-unit id="6529c6f67bbc8e3a2934d327ad30e40ae74a06cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;crypto#next_iv-2&quot;&gt;next_iv/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;crypto#next_iv-3&quot;&gt;next_iv/3&lt;/a&gt;&lt;/code&gt; is not needed since the &lt;code&gt;crypto_init&lt;/code&gt; and &lt;code&gt;crypto_update&lt;/code&gt; includes this functionality.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;crypto#next_iv-2&quot;&gt;next_iv/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;crypto#next_iv-3&quot;&gt;next_iv/3&lt;/a&gt;&lt;/code&gt; 때문에 불필요 &lt;code&gt;crypto_init&lt;/code&gt; 및 &lt;code&gt;crypto_update&lt;/code&gt; 가 이 기능을 포함한다.</target>
        </trans-unit>
        <trans-unit id="4ef4e16c6d6043c0d934f6a3edee0c7cc5aa2fe6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; module provides the main interface for writing test cases. This includes for example, the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; 모듈은 테스트 케이스 작성을위한 주요 인터페이스를 제공합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="24d2428c5253a289420ac3c56a797aad5738f051" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct#log-1&quot;&gt;log/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; function prints a string to the test case log file. The &lt;code&gt;&lt;a href=&quot;ct#print-1&quot;&gt;print/1,2,3,4&lt;/a&gt;&lt;/code&gt; function prints the string to screen. The &lt;code&gt;&lt;a href=&quot;ct#pal-1&quot;&gt;pal/1,2,3,4&lt;/a&gt;&lt;/code&gt; function prints the same string both to file and screen. The functions are described in module &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct#log-1&quot;&gt;log/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; 기능은 테스트 케이스 로그 파일에 문자열을 출력합니다. &lt;code&gt;&lt;a href=&quot;ct#print-1&quot;&gt;print/1,2,3,4&lt;/a&gt;&lt;/code&gt; 기능은 화면에 문자열을 출력합니다. &lt;code&gt;&lt;a href=&quot;ct#pal-1&quot;&gt;pal/1,2,3,4&lt;/a&gt;&lt;/code&gt; 기능은 모두 파일을 화면에 동일한 문자열을 인쇄합니다. 기능은 모듈 &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f487c24dcce56661b796ae49d9fa184c1120f87f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct_property_test&quot;&gt;ct_property_test&lt;/a&gt;&lt;/code&gt; module does the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct_property_test&quot;&gt;ct_property_test&lt;/a&gt;&lt;/code&gt; 모듈은 다음을 수행합니다</target>
        </trans-unit>
        <trans-unit id="7520b5a1282410b50e8ce82d773253694bcb5f8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct_property_test#present_result-4&quot;&gt;ct_property_test:present_result/4&lt;/a&gt;&lt;/code&gt; is a help function for printing some statistics in the CommonTest log file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct_property_test#present_result-4&quot;&gt;ct_property_test:present_result/4&lt;/a&gt;&lt;/code&gt; CommonTest 로그 파일의 통계를 인쇄하기위한 도움말 기능입니다.</target>
        </trans-unit>
        <trans-unit id="2225a95d59e4a2a00a916261ffc2ac6e972545a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; program can be used for running tests from the OS command line, for example, as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 의 다음 프로그램은, 예를 들면, OS의 명령 라인에서 테스트를 실행하기 위해 사용될 수있다 :</target>
        </trans-unit>
        <trans-unit id="45351661ad4006c4669c2ebdd26490749b02b241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;erl_format#erl_match&quot;&gt;erl_format:erl_match&lt;/a&gt;&lt;/code&gt; function performs pattern matching. It takes a pattern and a term and tries to match them. As a side effect any unbound variables in the pattern will be bound. In the following example, a pattern is created with a variable &lt;code&gt;Age&lt;/code&gt;, which is included at two positions in the tuple. The pattern match is performed as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erl_format#erl_match&quot;&gt;erl_format:erl_match&lt;/a&gt;&lt;/code&gt; 기능 수행 패턴 매칭. 패턴과 용어를 사용하여 일치 시키려고합니다. 부작용으로 패턴의 언 바운드 변수가 바인딩됩니다. 다음 예제에서는 변수 &lt;code&gt;Age&lt;/code&gt; 를 사용하여 패턴이 만들어지며 튜플의 두 위치에 포함됩니다. 패턴 일치는 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="f58e8b7ebcca47b5fa5b9e432d29b5c35a2acf4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt; callback, which is used a lot in this implementation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 이 구현에 많이 사용되는 콜백.</target>
        </trans-unit>
        <trans-unit id="5d913aee0ec20f5c99548c0d67120c8b7390405c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; callback, which is used a lot in this implementation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 이 구현에 많이 사용되는 콜백.</target>
        </trans-unit>
        <trans-unit id="5df35aa6c58680e6606845e3cb0a4b184a4d606d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;SSH Connection Protocol&lt;/a&gt;&lt;/code&gt; is used by clients and servers, that is, SSH channels, to communicate over the SSH connection. The API functions in this module send SSH Connection Protocol events, which are received as messages by the remote channel handling the remote channel. The Erlang format of thoose messages is (see also &lt;code&gt;&lt;a href=&quot;#type-event&quot;&gt;below&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;SSH Connection Protocol&lt;/a&gt;&lt;/code&gt; ssh 연결을 통해 통신하는 클라이언트와 서버이며, SSH 채널에 의해 사용된다. 이 모듈의 API 함수는 원격 채널을 처리하는 원격 채널에서 메시지로 수신하는 SSH 연결 프로토콜 이벤트를 보냅니다. thoose 메시지의 Erlang 형식은 &lt;code&gt;&lt;a href=&quot;#type-event&quot;&gt;below&lt;/a&gt;&lt;/code&gt; ( 아래 참조 ).</target>
        </trans-unit>
        <trans-unit id="e04d20c0a21a342accdbeea00bdc89554c9bbc2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;SSH Connection Protocol&lt;/a&gt;&lt;/code&gt; is used by clients and servers, that is, SSH channels, to communicate over the SSH connection. The API functions in this module send SSH Connection Protocol events, which are received as messages by the remote channel. If the receiving channel is an Erlang process, the messages have the format &lt;code&gt;{ssh_cm, connection_ref(), ssh_event_msg()}&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; behavior is used to implement the channel process, these messages are handled by &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt;handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;SSH Connection Protocol&lt;/a&gt;&lt;/code&gt; ssh 연결을 통해 통신하는 클라이언트와 서버이며, SSH 채널에 의해 사용된다. 이 모듈의 API 기능은 SSH 연결 프로토콜 이벤트를 전송하며 이는 원격 채널에서 메시지로 수신됩니다. 수신 채널이 Erlang 프로세스 인 경우 메시지의 형식은 &lt;code&gt;{ssh_cm, connection_ref(), ssh_event_msg()}&lt;/code&gt; 입니다. &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; 작동이 채널 프로세스를 구현하는 데 사용되는 경우 이러한 메시지는 &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt;handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt; 에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb9446bc2906454d7543c5cf2f665a89704ad38a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_process.h#L1021&quot;&gt;high-watermark&lt;/a&gt;&lt;/code&gt; is placed where the previous garbage collection (described in &lt;code&gt;&lt;a href=&quot;#Overview&quot;&gt;Overview&lt;/a&gt;&lt;/code&gt;) ended and we have introduced a new area called the old heap. When doing the normal garbage collection pass, any term that is located below the high-watermark is copied to the old &lt;strong&gt;to space&lt;/strong&gt; instead of the young.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_process.h#L1021&quot;&gt;high-watermark&lt;/a&gt;&lt;/code&gt; (에 기술 이전 가비지 컬렉션 곳에 배치 &lt;code&gt;&lt;a href=&quot;#Overview&quot;&gt;Overview&lt;/a&gt;&lt;/code&gt; ) 끝나고 우리는 이전 힙라는 새로운 영역을 도입했습니다. 일반 가비지 컬렉션 패스를 수행 할 때 최고 수위 표시 아래에있는 모든 용어가 젊은이 대신 오래된 &lt;strong&gt;공간에&lt;/strong&gt; 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="bcd1b00c890947931beb8fe9dcb1f1a330520a4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/global.h#L1452-L1465&quot;&gt;`erts_is_literal`&lt;/a&gt;&lt;/code&gt; check works differently on different architectures and operating systems.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/global.h#L1452-L1465&quot;&gt;`erts_is_literal`&lt;/a&gt;&lt;/code&gt; 의 검사는 다른 아키텍처와 운영 체제에서 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="29f892246d7df69546254cbfcc798654f3646997" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125&quot;&gt;RFC 6125&lt;/a&gt;&lt;/code&gt; defines</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125&quot;&gt;RFC 6125&lt;/a&gt;&lt;/code&gt; 을 정의</target>
        </trans-unit>
        <trans-unit id="7dcb6a1e5d8b3f03deff03d3241d42eac28f4c9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;mod_alias&quot;&gt;mod_alias&lt;/a&gt;&lt;/code&gt; module makes it possible to map different parts of the host file system into the document tree, that is, creates aliases and redirections.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mod_alias&quot;&gt;mod_alias&lt;/a&gt;&lt;/code&gt; 가의 모듈은 가능하다 별칭과 리디렉션을 만들고 문서 트리로 호스트 파일 시스템의 다른 부분을 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcc4b78316a4143698c35ef4043e086c3252f889" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;mod_auth&quot;&gt;mod_auth(3)&lt;/a&gt;&lt;/code&gt; module provides for basic user authentication using textual files, Dets databases as well as Mnesia databases.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mod_auth&quot;&gt;mod_auth(3)&lt;/a&gt;&lt;/code&gt; 모듈은 텍스트 파일, Dets 데이터베이스뿐만 아니라 Mnesia 데이터베이스를 사용하여 기본 사용자 인증을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="461a1eaddbc542451f83c2ca184fe0b61bd2923e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt; module implements the Erlang Server Interface (ESI) providing a tight and efficient interface to the execution of Erlang functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt; 모듈은 Erlang 서버 인터페이스 (ESI)를 구현하여 Erlang 함수 실행을 위한 강력 하고 효율적인 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="451822a0390939c5b7aa871766fbf59707a840eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;mod_security&quot;&gt;mod_security&lt;/a&gt;&lt;/code&gt; module serves as a filter for authenticated requests handled in &lt;code&gt;&lt;a href=&quot;mod_auth&quot;&gt;mod_auth(3)&lt;/a&gt;&lt;/code&gt;. It provides a possibility to restrict users from access for a specified amount of time if they fail to authenticate several times. It logs failed authentication as well as blocking of users, and it calls a configurable callback module when the events occur.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mod_security&quot;&gt;mod_security&lt;/a&gt;&lt;/code&gt; 와의 인증 요청에 대한 필터에서 처리 모듈로 제공 &lt;code&gt;&lt;a href=&quot;mod_auth&quot;&gt;mod_auth(3)&lt;/a&gt;&lt;/code&gt; . 사용자가 여러 번 인증에 실패하면 지정된 시간 동안 사용자의 액세스를 제한 할 수 있습니다. 인증 실패 및 사용자 차단을 기록하고 이벤트가 발생하면 구성 가능한 콜백 모듈을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="cca463bd9735d9ae37813de52272ea12a3c25d3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run program&lt;/a&gt;&lt;/code&gt; for an overview of available start flags (as most flags have a corresponding configuration term)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run program&lt;/a&gt;&lt;/code&gt; 가능한 시작 플래그의 개요 (대부분의 플래그는 해당 구성 용어를 가지고)</target>
        </trans-unit>
        <trans-unit id="41608b3a764923c262561e0c2d97e667f71e82d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_runprogram&lt;/a&gt;&lt;/code&gt; for an overview of available start flags (as most flags have a corresponding configuration term)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_runprogram&lt;/a&gt;&lt;/code&gt; 가능한 시작 플래그의 개요 (대부분의 플래그는 해당 구성 용어를 가지고)</target>
        </trans-unit>
        <trans-unit id="3f97cdf73ff78f958f92c1082d9981899a202f74" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ssh_file#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt; option must be a directory containing a host key file and it defaults to &lt;code&gt;/etc/ssh&lt;/code&gt;. For details, see Section Configuration Files in &lt;code&gt;ssh(6)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh_file#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt; 의 옵션은 호스트 키 파일이 들어있는 디렉토리하고 기본값으로합니다 &lt;code&gt;/etc/ssh&lt;/code&gt; . 자세한 내용은 &lt;code&gt;ssh(6)&lt;/code&gt; 섹션 구성 파일을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c2bdaafc19f8eda6fa7e095397c6b638b7731c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; module can be used for debugging a supervisor bridge.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; 모듈 감독자 다리 디버깅을 위해 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="1915b4761876d96adb7cfdaf20279417ba58c6b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;tftp#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; function starts a daemon process listening for UDP packets on a port. When it receives a request for read or write, it spawns a temporary server process handling the transfer.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;tftp#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; 함수는 UDP 포트 패킷의 데몬 프로세스 듣기 시작한다. 읽기 또는 쓰기 요청을 받으면 전송을 처리하는 임시 서버 프로세스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="34bf65dbe208c89793330cc690692124bc99f1eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt; multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt; multi-time warp mode&lt;/a&gt;&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="8e817126baaf83dd2177ff4d3961b1bf92117ec3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="7d9a2bc15a65c27354714aedd36bc465c988bc11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt; no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt; no time warp mode&lt;/a&gt;&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bac6d07dd79fabf515998a51c2c8ccd52cb9e6e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e6a0707134722e646e7cc1eaf4404ec443d34378" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt; single time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt; single time warp mode&lt;/a&gt;&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="11b934f9948e4845a2b33851b5932f94d59f1d45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="40c216921e0f08c2b36308cbbb132054a41492aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;users_guide&quot;&gt;CRYPTO User's Guide&lt;/a&gt;&lt;/code&gt; has more information on FIPS, Engines and Algorithm Details like key lengths.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;users_guide&quot;&gt;CRYPTO User's Guide&lt;/a&gt;&lt;/code&gt; 키 길이와 같은 FIPS, 엔진 및 알고리즘 세부 사항에 대한 자세한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="842d1fd61ccfd8c7f0a3b2ea51238f75d1a39f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;users_guide&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; has examples and a &lt;code&gt;&lt;a href=&quot;using_ssh&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; section.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;users_guide&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 에는 예제와 &lt;code&gt;&lt;a href=&quot;using_ssh&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; 섹션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7213ba1d558f14b69b4e8a3edef214d04ef9e98a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?Q&lt;/code&gt; macros turn the quoted code fragments into ASTs, and lifts metavariables such as &lt;code&gt;_@Tuple&lt;/code&gt; and &lt;code&gt;_@Number&lt;/code&gt; to the level of your Erlang code, so you can use the corresponding Erlang variables &lt;code&gt;Tuple&lt;/code&gt; and &lt;code&gt;Number&lt;/code&gt; directly. This is the most straightforward way to use Merl, and in many cases it's all you need.</source>
          <target state="translated">&lt;code&gt;?Q&lt;/code&gt; 매크로하는 AST에 인용 된 코드 조각을 설정하고, 리프트 등 metavariables &lt;code&gt;_@Tuple&lt;/code&gt; 및 &lt;code&gt;_@Number&lt;/code&gt; 당신이 해당 얼랑 변수를 사용할 수 있도록, 당신의 얼랑 코드의 수준으로 &lt;code&gt;Tuple&lt;/code&gt; 및 &lt;code&gt;Number&lt;/code&gt; 직접. 이것은 Merl을 사용하는 가장 간단한 방법이며 많은 경우에 필요한 전부입니다.</target>
        </trans-unit>
        <trans-unit id="15c579f9adfb6704c3bcff309334cae348b5e5b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?assert(Expression)&lt;/code&gt; macro will evaluate &lt;code&gt;Expression&lt;/code&gt;, and if that does not evaluate to &lt;code&gt;true&lt;/code&gt;, it will throw an exception; otherwise it just returns &lt;code&gt;ok&lt;/code&gt;. In the above example, the test will thus fail if the call to &lt;code&gt;length&lt;/code&gt; does not return 3.</source>
          <target state="translated">&lt;code&gt;?assert(Expression)&lt;/code&gt; 매크로 평가합니다 &lt;code&gt;Expression&lt;/code&gt; , 그리고 그로 평가하지 않는 경우 &lt;code&gt;true&lt;/code&gt; , 그것은 예외가 발생합니다; 그렇지 않으면 그냥 &lt;code&gt;ok&lt;/code&gt; 반환합니다 . 위 예제에서 &lt;code&gt;length&lt;/code&gt; 호출이 3을 반환하지 않으면 테스트가 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="824fe9ddd06f6c4a1a05c0b0fcb9265f7a7b2017" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ASN.1&lt;/code&gt; application provides the following two separate user interfaces:</source>
          <target state="translated">&lt;code&gt;ASN.1&lt;/code&gt; 의 애플리케이션은 다음의 두 개의 분리 된 사용자 인터페이스를 제공한다 :</target>
        </trans-unit>
        <trans-unit id="ad1896e2fd3770f39ede02112fb63bbac81b7df1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Address&lt;/code&gt; field is the second element.</source>
          <target state="translated">&lt;code&gt;Address&lt;/code&gt; 필드는 두 번째 요소입니다.</target>
        </trans-unit>
        <trans-unit id="90bfd70e3f20f8f506d98edda14b178d797720e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AlgorithmId&lt;/code&gt; is the signature OID from a certificate or a certificate revocation list.</source>
          <target state="translated">&lt;code&gt;AlgorithmId&lt;/code&gt; 은 인증서 또는 인증서 해지 목록에서 서명 OID입니다.</target>
        </trans-unit>
        <trans-unit id="e284c989131372b49e03051b62849870dd521425" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BIT STRING&lt;/code&gt; type is decoded to &quot;compact notation&quot;. &lt;strong&gt;This option is not recommended for new code.&lt;/strong&gt; This option cannot be combined with the option &lt;code&gt;maps&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BIT STRING&lt;/code&gt; 형식은 &quot;소형 표기&quot;로 디코딩됩니다. &lt;strong&gt;이 옵션은 새 코드에는 권장되지 않습니다. &lt;/strong&gt;이 옵션은 옵션 &lt;code&gt;maps&lt;/code&gt; 과 결합 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d727373c971108a708085cfa309ebdb4fa5bc28b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BIT STRING&lt;/code&gt; type is decoded to the legacy format, that is, a list of zeroes and ones. &lt;strong&gt;This option is not recommended for new code.&lt;/strong&gt; This option cannot be combined with the option &lt;code&gt;maps&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BIT STRING&lt;/code&gt; 유형은 0과의 목록입니다 레거시 포맷 디코딩된다. &lt;strong&gt;이 옵션은 새 코드에는 권장되지 않습니다. &lt;/strong&gt;이 옵션은 옵션 &lt;code&gt;maps&lt;/code&gt; 과 결합 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3c84e077a6dbf3c771cfd255a8a9895e6702d3a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Bitstring&lt;/code&gt; variable can consist of any number of bits, for example, 0, 1, 8, 11, 17, 42, and so on. This is because the default &lt;code&gt;unit&lt;/code&gt; for bitstrings is 1.</source>
          <target state="translated">&lt;code&gt;Bitstring&lt;/code&gt; 변수는 예컨대, 0, 1, 8, 11, 17, 42 등, 임의의 수의 비트들로 구성 될 수있다. 비트 열의 기본 &lt;code&gt;unit&lt;/code&gt; 는 1 이기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="94a1488efe62c17d8ba98c01afd1b232f7321a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Block&lt;/code&gt; argument indicates if the log should be blocked during conversion. This could be usefull when converting large logs (when otherwise the log could wrap during conversion). Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Block&lt;/code&gt; 로그 변환시 차단해야하는 경우 인수를 나타냅니다. 큰 로그를 변환 할 때 유용합니다 (그렇지 않으면 변환 중에 로그가 랩핑 될 수있는 경우). 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4ab5f211e8f18fd1c4ca859d11a5d3fcd218d631" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Block&lt;/code&gt; option indicates if the log should be blocked during conversion. This could be usefull when converting large logs (when otherwise the log could wrap during conversion). Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Block&lt;/code&gt; 로그 변환시 차단해야하는 경우 옵션을 나타냅니다. 큰 로그를 변환 할 때 유용합니다 (그렇지 않으면 변환 중에 로그가 랩핑 될 수있는 경우). 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9c2a775047eba8dcca0470291f62d589146470f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BufSz&lt;/code&gt; argument basically defines the size of the receive buffer. By setting the value to zero (0), the configured size (setopt with &lt;code&gt;Level&lt;/code&gt; = &lt;code&gt;otp&lt;/code&gt; and &lt;code&gt;Key&lt;/code&gt; = &lt;code&gt;rcvbuf&lt;/code&gt;) is used.</source>
          <target state="translated">&lt;code&gt;BufSz&lt;/code&gt; 의 인수는 기본적으로 크기가 수신 버퍼 정의합니다. 영 (0)의 값이 설정된 사이즈 (SETOPT으로 설정함으로써 &lt;code&gt;Level&lt;/code&gt; = &lt;code&gt;otp&lt;/code&gt; 및 &lt;code&gt;Key&lt;/code&gt; = &lt;code&gt;rcvbuf&lt;/code&gt; ) 이용된다.</target>
        </trans-unit>
        <trans-unit id="2acfbefe2ee37310ba387213e5e15aa6901a988c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Callback&lt;/code&gt; module should contain hook functions for all tags present in the data structure. A hook function must have the following format:</source>
          <target state="translated">&lt;code&gt;Callback&lt;/code&gt; 모든 태그 데이터 구조에 존재위한 모듈은 후크 함수를 포함한다. 후크 기능은 다음 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="883390db9451e13b3d5a5f85d744ec9ca06a2b24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CallbackMode&lt;/code&gt; is either just &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback_mode()&lt;/a&gt;&lt;/code&gt; or a list containing &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback_mode()&lt;/a&gt;&lt;/code&gt; and possibly the atom &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CallbackMode&lt;/code&gt; 는 하나 그냥 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback_mode()&lt;/a&gt;&lt;/code&gt; 또는 목록 함유 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback_mode()&lt;/a&gt;&lt;/code&gt; 및 가능한 원자 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="e7a580d51d45e0183e4b31ffec1224002d11cfbe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CharSpec&lt;/code&gt;&lt;code&gt;eof&lt;/code&gt; signals end of file. &lt;code&gt;LeftOverChars&lt;/code&gt; then takes the value &lt;code&gt;eof&lt;/code&gt; as well.</source>
          <target state="translated">&lt;code&gt;CharSpec&lt;/code&gt; &lt;code&gt;eof&lt;/code&gt; 신호는 파일의 끝. &lt;code&gt;LeftOverChars&lt;/code&gt; 다음 LeftOverChars 는 &lt;code&gt;eof&lt;/code&gt; 값도 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="64d980b4c7c9584d2e8b4e055ab6694f99c89599" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ChildSpecs&lt;/code&gt; variable in the return value from &lt;code&gt;init/1&lt;/code&gt; is a list of &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;child specifications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ChildSpecs&lt;/code&gt; 의 반환 값의 변수 &lt;code&gt;init/1&lt;/code&gt; 의 목록 &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;child specifications&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5232c85e790e4f73652dc642ce50e6888594555" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ChunkSize&lt;/code&gt; defines the size of the &lt;code&gt;PlainBin&lt;/code&gt;s that &lt;code&gt;EncodeFun&lt;/code&gt; is applied to. If the &lt;code&gt;ChunkSize&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;, the size of the &lt;code&gt;PlainBin&lt;/code&gt;s varies, because this is intended for stream crypto, whereas a fixed &lt;code&gt;ChunkSize&lt;/code&gt; is intended for block crypto. &lt;code&gt;ChunkSize&lt;/code&gt;s can be changed in the return from the &lt;code&gt;EncryptFun&lt;/code&gt; or &lt;code&gt;DecryptFun&lt;/code&gt;. The value can be changed between &lt;code&gt;pos_integer()&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ChunkSize&lt;/code&gt; 의 크기 정의 &lt;code&gt;PlainBin&lt;/code&gt; 의 그 &lt;code&gt;EncodeFun&lt;/code&gt; 에 적용됩니다. 경우] &lt;code&gt;ChunkSize&lt;/code&gt; 되는 &lt;code&gt;undefined&lt;/code&gt; 의 크기 &lt;code&gt;PlainBin&lt;/code&gt; 이것은 고정 된 반면, 스트림 암호화를 대상으로하기 때문에 S 다양 &lt;code&gt;ChunkSize&lt;/code&gt; 블록 암호화를 위해 의도된다. &lt;code&gt;ChunkSize&lt;/code&gt; 는 &lt;code&gt;EncryptFun&lt;/code&gt; 또는 &lt;code&gt;DecryptFun&lt;/code&gt; 에서 반환 될 때 변경 될 수 있습니다 . &lt;code&gt;pos_integer()&lt;/code&gt; 와 &lt;code&gt;undefined&lt;/code&gt; 사이에서 값을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8a7a9966f0b85d64cc4feece108959a21b830fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Collector&lt;/code&gt; API does also allow you to save the collected &lt;code&gt;Events&lt;/code&gt; to file and later load them in a later session.</source>
          <target state="translated">&lt;code&gt;Collector&lt;/code&gt; API는 또한 수집 된 저장할 수 않는 &lt;code&gt;Events&lt;/code&gt; 파일을 나중에 나중에 세션을로드합니다.</target>
        </trans-unit>
        <trans-unit id="fceb8c2c1f65a97284385a3f23405d68267725fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Collector&lt;/code&gt; automatically registers itself to listen for trace &lt;code&gt;Events&lt;/code&gt;, so all you have to do is enable them.</source>
          <target state="translated">&lt;code&gt;Collector&lt;/code&gt; 자동으로 추적을 수신에 자신을 등록 &lt;code&gt;Events&lt;/code&gt; 당신이해야 할 모든이를 가능하게하므로,.</target>
        </trans-unit>
        <trans-unit id="ec20677889045987c82a0d9f6c4d053fcf85822c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Collector&lt;/code&gt; manages a key/value based dictionary, where the filters are stored. Updates of the dictionary is propagated to all subscribing processes. When a &lt;code&gt;Viewer&lt;/code&gt; is started it is registered as a subscriber of dictionary updates.</source>
          <target state="translated">&lt;code&gt;Collector&lt;/code&gt; 필터가 저장되는 키 / 값 기반 사전을 관리합니다. 사전 업데이트가 모든 구독 프로세스에 전파됩니다. &lt;code&gt;Viewer&lt;/code&gt; 가 시작 되면 사전 업데이트의 구독자로 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="e368c10bff22300d3fab811f6f50a4674a69667b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; Framework Log page includes links to the Pre- and Post Test I/O Log. In this log, &lt;code&gt;Common Test&lt;/code&gt; saves printouts made with &lt;code&gt;ct:log/1,2,3,4,5&lt;/code&gt; and &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt;, as well as captured system error- and progress reports, which take place before, and after, the test run. Examples of this are printouts from a CT hook init- or terminate function, or progress reports generated when an OTP application is started from a CT hook init function. Another example is an error report generated because of a failure when an external application is stopped from a CT hook terminate function. All information in these examples ends up in the Pre- and Post Test I/O Log. For more information on how to synchronize test runs with external user applications, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#synchronizing&quot;&gt;Synchronizing&lt;/a&gt;&lt;/code&gt; in section Common Test Hooks.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 프레임 워크 로그 페이지는 사전 및 사후 테스트 I / O 로그에 대한 링크가 포함되어 있습니다. 이 로그에서 &lt;code&gt;Common Test&lt;/code&gt; 는 &lt;code&gt;ct:log/1,2,3,4,5&lt;/code&gt; 및 &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt; 로 작성된 인쇄물을 저장합니다테스트 실행 전후에 발생한 시스템 오류 및 진행률 보고서를 캡처 할 수 있습니다. 예는 CT 후크 초기화 또는 종료 기능에서 출력되거나 OTP 응용 프로그램이 CT 후크 초기화 기능에서 시작될 때 생성 된 진행 보고서입니다. 또 다른 예는 외부 애플리케이션이 CT 후크 종료 기능에서 중지 될 때 실패로 인해 생성 된 오류 보고서입니다. 이 예제의 모든 정보는 사전 및 사후 테스트 I / O 로그에 있습니다. 테스트 실행을 외부 사용자 애플리케이션과 동기화하는 방법에 대한 자세한 정보는 공통 테스트 후크 섹션의 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#synchronizing&quot;&gt;Synchronizing&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b15f94344ef9977a91750baa9dddf1dbad0746d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; Master API is exported by module &lt;code&gt;&lt;a href=&quot;ct_master&quot;&gt;ct_master&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 마스터 API는 모듈 내 보낸 &lt;code&gt;&lt;a href=&quot;ct_master&quot;&gt;ct_master&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1eb6fe3660c4d65491500f6426215f629639619" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; Master server runs on one dedicated Erlang node and uses distributed Erlang to communicate with any number of &lt;code&gt;Common Test&lt;/code&gt; test nodes, each hosting a regular &lt;code&gt;Common Test&lt;/code&gt; server. Test specifications are used as input to specify what to test on which test nodes, using what configuration.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 마스터 서버 하나 개의 전용 얼랑 노드에서 실행 및 사용은 임의의 수와 통신 할 수 얼랑 분산 &lt;code&gt;Common Test&lt;/code&gt; 테스트 노드, 각 호스팅 일반 &lt;code&gt;Common Test&lt;/code&gt; 서버. 테스트 스펙은 어떤 구성을 사용하여 어떤 테스트 노드에서 테스트 할 대상을 지정하는 입력으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d910e14beb83938480f0c5db0900211c5bc5ac30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; Master server writes progress information to HTML log files similarly to the regular &lt;code&gt;Common Test&lt;/code&gt; server. The logs contain test statistics and links to the log files written by each independent &lt;code&gt;Common Test&lt;/code&gt; server.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 마스터 서버는 유사하게 일반에 HTML 로그 파일에 진행 정보를 기록 &lt;code&gt;Common Test&lt;/code&gt; 서버. 로그에는 테스트 통계 및 각 독립 &lt;code&gt;Common Test&lt;/code&gt; 서버가 작성한 로그 파일에 대한 링크가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="4e124139583e4b5d8918f07bb2c0c03bd8d6c703" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; application also includes other modules named &lt;code&gt;ct_&amp;lt;component&amp;gt;&lt;/code&gt;, which provide various support, mainly simplified use of communication protocols such as RPC, SNMP, FTP, Telnet, and others.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 애플리케이션 명명 된 다른 모듈 포함 &lt;code&gt;ct_&amp;lt;component&amp;gt;&lt;/code&gt; 다양한 지원 등 RPC, SNMP, FTP, 텔넷 등과 같은 통신 프로토콜의 간략화 주로 사용을 제공한다.</target>
        </trans-unit>
        <trans-unit id="03a84fce685f88578ce41de6a729049cb8fac0fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; application is installed with the Erlang/OTP system. No extra installation step is required to start using &lt;code&gt;Common Test&lt;/code&gt; through the &lt;code&gt;ct_run&lt;/code&gt; executable program, and/or the interface functions in the &lt;code&gt;ct&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 응용 프로그램은 얼랑 / OTP 시스템에 설치됩니다. &lt;code&gt;ct_run&lt;/code&gt; 실행 프로그램 및 / 또는 &lt;code&gt;ct&lt;/code&gt; 모듈 의 인터페이스 기능을 통해 &lt;code&gt;Common Test&lt;/code&gt; 사용을 시작하기 위해 추가 설치 단계가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="78a22725d0c7f0f676d4ba2a90661e795ebb56c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; framework is a tool that supports implementation and automated execution of test cases to any types of target systems. &lt;code&gt;Common Test&lt;/code&gt; is the main tool being used in all testing- and verification activities that are part of Erlang/OTP system development and maintenance.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 프레임 워크 구현 및 대상 시스템의 유형 테스트 케이스의 자동 실행을 지원하는 도구입니다. &lt;code&gt;Common Test&lt;/code&gt; 는 Erlang / OTP 시스템 개발 및 유지 관리의 일부인 모든 테스트 및 검증 활동에 사용되는 주요 도구입니다.</target>
        </trans-unit>
        <trans-unit id="18e9917f7eb0c975fe2d0bf461322b555cc56962" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; framework is an environment for implementing and performing automatic and semi-automatic execution of test cases.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 워크 구현 및 테스트 케이스 자동 및 반자동 실행을 수행하는 환경이다.</target>
        </trans-unit>
        <trans-unit id="c32a30ee7b6005326d0a472ffa1a54f5ce95df96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; framework provides a high-level operator interface for testing, providing the following features:</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 프레임 워크는 다음과 같은 기능을 테스트하는 제공하는 높은 수준의 운영자 인터페이스를 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="ad9b65cad13beffef2e82d575de6699dcf88a08a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; test server requires that the test suite defines and exports the following mandatory or optional callback functions:</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 테스트 서버가 요구하는 테스트 스위트를 정의하고 수출 다음과 같은 필수 또는 선택적 콜백 기능 :</target>
        </trans-unit>
        <trans-unit id="b3f5974325a1f6adb2e7a53fd6b80b396429c849" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Company&lt;/code&gt; database is now initialized and contains data.</source>
          <target state="translated">&lt;code&gt;Company&lt;/code&gt; 데이터베이스는 이제 초기화와 데이터를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="84399fbfc3c32ddc0958865c1bc7e66e07f291b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Company&lt;/code&gt; database, introduced in &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt;, has three tables that store records (&lt;code&gt;employee&lt;/code&gt;, &lt;code&gt;dept&lt;/code&gt;, &lt;code&gt;project&lt;/code&gt;), and three tables that store relationships (&lt;code&gt;manager&lt;/code&gt;, &lt;code&gt;at_dep&lt;/code&gt;, &lt;code&gt;in_proj&lt;/code&gt;). This is a normalized data model, which has some advantages over a non-normalized data model.</source>
          <target state="translated">&lt;code&gt;Company&lt;/code&gt; 에 도입 데이터베이스, &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; , 세 개의 테이블이 저장하는 기록 ( &lt;code&gt;employee&lt;/code&gt; , &lt;code&gt;dept&lt;/code&gt; , &lt;code&gt;project&lt;/code&gt; ), 그리고 세 개의 표를 저장하는 관계 ( &lt;code&gt;manager&lt;/code&gt; , &lt;code&gt;at_dep&lt;/code&gt; , &lt;code&gt;in_proj&lt;/code&gt; ). 이것은 정규화 된 데이터 모델이며 비정규 화 된 데이터 모델에 비해 몇 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b4167561d4c9786e75acf722fa5255d76e1f375" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ControlMessage&lt;/code&gt; is a tuple, where the first element indicates which distributed operation it encodes:</source>
          <target state="translated">&lt;code&gt;ControlMessage&lt;/code&gt; 는 첫번째 요소가 분산되는 인코딩 동작을 나타내는 튜플이다 :</target>
        </trans-unit>
        <trans-unit id="a9bce474e15518f3622f365b9755866898515b9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CtrlSz&lt;/code&gt; argument basically defines the size of the receive buffer for the control messages. By setting the value to zero (0), the configured size (setopt with &lt;code&gt;Level&lt;/code&gt; = &lt;code&gt;otp&lt;/code&gt;) is used.</source>
          <target state="translated">&lt;code&gt;CtrlSz&lt;/code&gt; 의 인수는 기본적으로 크기가 제어 메시지를 수신 버퍼 정의합니다. 영 (0)의 값이 설정된 사이즈 (SETOPT으로 설정함으로써 &lt;code&gt;Level&lt;/code&gt; = &lt;code&gt;otp&lt;/code&gt; ) 이용된다.</target>
        </trans-unit>
        <trans-unit id="b53e02a747463b517e8ec15e14ceddfb049c6d05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DAT&lt;/code&gt; files must always be opened with option &lt;code&gt;{repair, false}&lt;/code&gt;. This ensures that these files are not automatically repaired. Without this option, the database can become inconsistent, because &lt;code&gt;Mnesia&lt;/code&gt; can believe that the files were properly closed. For information about configuration parameter &lt;code&gt;auto_repair&lt;/code&gt;, see the Reference Manual.</source>
          <target state="translated">&lt;code&gt;DAT&lt;/code&gt; 의 파일은 항상 옵션을 열어야합니다 &lt;code&gt;{repair, false}&lt;/code&gt; . 이렇게하면 이러한 파일이 자동으로 복구되지 않습니다. 이 옵션을 사용하지 않으면 &lt;code&gt;Mnesia&lt;/code&gt; 가 파일이 올바르게 닫 혔음 을 믿을 수 있으므로 데이터베이스가 일치하지 않을 수 있습니다. 구성 매개 변수 &lt;code&gt;auto_repair&lt;/code&gt; 에 대한 정보 는 참조 매뉴얼을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5873af1928aed9c59ec2db4bf69bcbdd1c33d63f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Data&lt;/code&gt; received can be a &lt;code&gt;binary()&lt;/code&gt; or a &lt;code&gt;list()&lt;/code&gt; of bytes (integers in the range 0 through 255) depending on the socket mode, or an SCTP event.</source>
          <target state="translated">수신 된 &lt;code&gt;Data&lt;/code&gt; 는 소켓 모드 또는 SCTP 이벤트에 따라 &lt;code&gt;binary()&lt;/code&gt; 또는 바이트 &lt;code&gt;list()&lt;/code&gt; 0-255 범위의 정수) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69f5b6911daa714868434e1a90189319187674c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DbgExtra&lt;/code&gt; options are described in section &lt;code&gt;&lt;a href=&quot;#debug_flags&quot;&gt;DbgExtra Options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DbgExtra&lt;/code&gt; 의 옵션이 절에서 설명하는 &lt;code&gt;&lt;a href=&quot;#debug_flags&quot;&gt;DbgExtra Options&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16f5677b6ef24617d1e07a7aa94edc055731eaee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DiscoHandler&lt;/code&gt; module is used during the discovery process. See &lt;code&gt;&lt;a href=&quot;snmpa_discovery_handler&quot;&gt;discovery handler&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">&lt;code&gt;DiscoHandler&lt;/code&gt; 의 모듈은 검색 프로세스 동안 사용된다. 자세한 정보는 &lt;code&gt;&lt;a href=&quot;snmpa_discovery_handler&quot;&gt;discovery handler&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="510046e751218ed5f95a1059673c4d8fbf2a7fa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dst&lt;/code&gt; map is updated with new channel values. The syntax for updating an existing key with a new value is with the &lt;code&gt;:=&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;Dst&lt;/code&gt; 지도는 새로운 채널 값으로 업데이트됩니다. 기존 키를 새로운 값으로 업데이트하는 구문은 &lt;code&gt;:=&lt;/code&gt; 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="30f4f4e3c2c9185266f65e6f7d9040faa980d49a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; term type is used for passing a term encoded with the &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt;, that is, a term that has been encoded by &lt;code&gt;&lt;a href=&quot;erlang#term_to_binary-2&quot;&gt; erlang:term_to_binary&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;erl_interface:ei(3)&lt;/code&gt;, and so on. For example, if &lt;code&gt;binp&lt;/code&gt; is a pointer to an &lt;code&gt;ErlDrvBinary&lt;/code&gt; that contains term &lt;code&gt;{17, 4711}&lt;/code&gt; encoded with the &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt;, and you want to wrap it in a two-tuple with the tag &lt;code&gt;my_tag&lt;/code&gt;, that is, &lt;code&gt;{my_tag, {17, 4711}}&lt;/code&gt;, you can do as follows:</source>
          <target state="translated">&lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; 의 용어 유형으로 인코딩되는 용어 전달에 사용되는 &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt; 이다 의해 부호화 된 용어 &lt;code&gt;&lt;a href=&quot;erlang#term_to_binary-2&quot;&gt; erlang:term_to_binary&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;erl_interface:ei(3)&lt;/code&gt; 등을. 예를 들어, &lt;code&gt;binp&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt; 인코딩 된 &lt;code&gt;{17, 4711}&lt;/code&gt; 이라는 용어를 포함 하는 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 에 대한 포인터 이고 &lt;code&gt;my_tag&lt;/code&gt; 태그 ( 즉, &lt;code&gt;{my_tag, {17, 4711}}&lt;/code&gt; , 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0e5af70acd62ed71f0140803a094eed25236db0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; term type is used for passing a term encoded with the &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt;, that is, a term that has been encoded by &lt;code&gt;&lt;a href=&quot;erlang#term_to_binary-2&quot;&gt;erlang:term_to_binary&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;erl_interface:ei(3)&lt;/code&gt;, and so on. For example, if &lt;code&gt;binp&lt;/code&gt; is a pointer to an &lt;code&gt;ErlDrvBinary&lt;/code&gt; that contains term &lt;code&gt;{17, 4711}&lt;/code&gt; encoded with the &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt;, and you want to wrap it in a two-tuple with the tag &lt;code&gt;my_tag&lt;/code&gt;, that is, &lt;code&gt;{my_tag, {17, 4711}}&lt;/code&gt;, you can do as follows:</source>
          <target state="translated">&lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; 의 용어 유형으로 인코딩되는 용어 전달에 사용되는 &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt; 이다 의해 부호화 된 용어 &lt;code&gt;&lt;a href=&quot;erlang#term_to_binary-2&quot;&gt;erlang:term_to_binary&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;erl_interface:ei(3)&lt;/code&gt; 등을. 예를 들어, &lt;code&gt;binp&lt;/code&gt; 에 대한 포인터입니다 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 용어가 들어 &lt;code&gt;{17, 4711}&lt;/code&gt; 로 인코딩 된 &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt; , 당신은 태그와 두 튜플에 포장 할 &lt;code&gt;my_tag&lt;/code&gt; 이며, &lt;code&gt;{my_tag, {17, 4711}}&lt;/code&gt; 이면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c0ac01302ce56a5538e783afbe86c0e3ca92aac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; term is a way to construct strings. It works differently from how &lt;code&gt;ERL_DRV_STRING&lt;/code&gt; works. &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; builds a string list in reverse order (as opposed to how &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; works), concatenating the strings added to a list. The tail must be specified before &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; 의 용어는 문자열을 구성하는 방법입니다. &lt;code&gt;ERL_DRV_STRING&lt;/code&gt; 의 작동 방식과 다르게 작동합니다. &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; 는 목록에 추가 된 문자열을 연결하여 문자열 목록을 역순으로 작성합니다 ( &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; 작동 방식과 반대 ). 꼬리는 &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; 전에 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7fe5603a0b688982ee095c5b6eb8b3abf301f57c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_DRV_UINT&lt;/code&gt;, &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt;, and &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; term types were introduced in ERTS 5.6.</source>
          <target state="translated">&lt;code&gt;ERL_DRV_UINT&lt;/code&gt; , &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; 및 &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; 의 용어 유형은 ERTS 5.6에 소개되었다.</target>
        </trans-unit>
        <trans-unit id="78c7a39595ca5fe9252d32999a603c6e910dd570" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_FLAGS&lt;/code&gt; environment variable can be used to store the complicated parameters in:</source>
          <target state="translated">&lt;code&gt;ERL_FLAGS&lt;/code&gt; 의 환경 변수에 복잡한 매개 변수를 저장하는 데 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0a3584a359b0427b176ceaff9674304e574ffce0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Emakefile&lt;/code&gt; (if it exists) in the current directory is searched for compiler options for each module. If a given module does not exist in &lt;code&gt;Emakefile&lt;/code&gt; or if &lt;code&gt;Emakefile&lt;/code&gt; does not exist, the module is still compiled.</source>
          <target state="translated">현재 디렉토리 의 &lt;code&gt;Emakefile&lt;/code&gt; (있는 경우)에서 각 모듈의 컴파일러 옵션을 검색합니다. 지정된 모듈이 &lt;code&gt;Emakefile&lt;/code&gt; 에 없거나 &lt;code&gt;Emakefile&lt;/code&gt; 이없는 경우 모듈은 여전히 ​​컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="da28c7ffe618c58fd36df47a840c22abe8ebdbed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Encoding&lt;/code&gt; says how the characters in the request are represented. We want to store the characters as lists in the ETS table, so we convert them to lists using function &lt;code&gt;unicode:characters_to_list/2&lt;/code&gt;. The conversion function conveniently accepts the encoding types &lt;code&gt;unicode&lt;/code&gt; and &lt;code&gt;latin1&lt;/code&gt;, so we can use &lt;code&gt;Encoding&lt;/code&gt; directly.</source>
          <target state="translated">&lt;code&gt;Encoding&lt;/code&gt; 요청의 문자를 표현하는 방법을 말한다. 문자를 ETS 테이블에 목록으로 저장하려고하므로 &lt;code&gt;unicode:characters_to_list/2&lt;/code&gt; 함수를 사용하여 문자 를 목록으로 변환합니다 . 변환 함수는 &lt;code&gt;unicode&lt;/code&gt; 및 &lt;code&gt;latin1&lt;/code&gt; 인코딩 유형을 편리하게 받아들이 므로 &lt;code&gt;Encoding&lt;/code&gt; 을 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3c694d3baa325d31ca5ef434295459f7fd84d35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErlDrvBinary&lt;/code&gt; structure is a binary, as sent between the emulator and the driver. All binaries are reference counted; when &lt;code&gt;driver_binary_free&lt;/code&gt; is called, the reference count is decremented, when it reaches zero, the binary is deallocated. &lt;code&gt;orig_size&lt;/code&gt; is the binary size and &lt;code&gt;orig_bytes&lt;/code&gt; is the buffer. &lt;code&gt;ErlDrvBinary&lt;/code&gt; has not a fixed size, its size is &lt;code&gt;orig_size + 2 * sizeof(int)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ErlDrvBinary&lt;/code&gt; 에뮬레이터와 드라이버 사이에서 전송로 구조는 바이너리이다. 모든 바이너리는 참조 카운트됩니다. 경우 &lt;code&gt;driver_binary_free&lt;/code&gt; 가 호출, 기준 카운트가 0이되면, 이진가 해제되어, 감소된다. &lt;code&gt;orig_size&lt;/code&gt; 는 이진 크기이고 &lt;code&gt;orig_bytes&lt;/code&gt; 는 버퍼입니다. &lt;code&gt;ErlDrvBinary&lt;/code&gt; 의 크기는 고정되어 있지 않으며 크기는 &lt;code&gt;orig_size + 2 * sizeof(int)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c86b87f3b0b95eba095182c55f0fcc45cc6647fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErlDrvNowData&lt;/code&gt; structure holds a time stamp consisting of three values measured from some arbitrary point in the past. The three structure members are:</source>
          <target state="translated">&lt;code&gt;ErlDrvNowData&lt;/code&gt; 의 구조는 과거에 어떤 임의의 지점에서 측정 한 세 값으로 이루어지는 타임 스탬프를 보유하고있다. 세 가지 구조 멤버는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c525691955a7766948a2ab00688137550480556" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; structure is used for storage of information about the Erlang runtime system. &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt; writes the system information when passed a reference to a &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; structure. The fields in the structure are as follows:</source>
          <target state="translated">&lt;code&gt;ErlDrvSysInfo&lt;/code&gt; 의 구조 얼랑 런타임 시스템에 대한 정보의 저장을 위해 사용된다. &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; 구조에 대한 참조를 전달할 때 시스템 정보를 기록합니다 . 구조의 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="89f846aa2a9d3bbb835eaa5c58e3ac257c0f2247" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; structure is used for storage of information about the Erlang runtime system. &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; writes the system information when passed a reference to a &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; structure. The fields in the structure are as follows:</source>
          <target state="translated">&lt;code&gt;ErlDrvSysInfo&lt;/code&gt; 의 구조 얼랑 런타임 시스템에 대한 정보의 저장을 위해 사용된다. &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; 구조에 대한 참조를 전달할 때 시스템 정보를 기록합니다 . 구조의 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a097b8521d625c64b18dfa0ef6d0bb28ad84fb42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Erl_Interface&lt;/code&gt; library contains functions that help you integrate programs written in C and Erlang. The functions in &lt;code&gt;Erl_Interface&lt;/code&gt; support the following:</source>
          <target state="translated">&lt;code&gt;Erl_Interface&lt;/code&gt; 의 라이브러리는 C와 얼랑로 작성된 프로그램을 통합 할 수 있도록 기능이 포함되어 있습니다. &lt;code&gt;Erl_Interface&lt;/code&gt; 의 기능 은 다음을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6e029ea371407136acd36ef3f94ae9b566be79a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Erl_Interface&lt;/code&gt; library supports this activity. It has several C functions that create and manipulate Erlang data structures. The following example shows how to create and encode an Erlang tuple &lt;code&gt;{tobbe,3928}&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Erl_Interface&lt;/code&gt; 의 라이브러리는이 활동을 지원합니다. Erlang 데이터 구조를 만들고 조작하는 여러 C 함수가 있습니다. 다음 예제는 Erlang 튜플 &lt;code&gt;{tobbe,3928}&lt;/code&gt; 을 만들고 인코딩하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="c0bb8f936d4589865a80fe604ad9b594bedb70df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Erl_Interface&lt;/code&gt; library supports this activity. It has several C functions that create and manipulate Erlang data structures. The library also contains an encode and a decode function. The following example shows how to create and encode an Erlang tuple &lt;code&gt;{tobbe,3928}&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Erl_Interface&lt;/code&gt; 의 라이브러리는이 활동을 지원합니다. Erlang 데이터 구조를 작성하고 조작하는 여러 C 함수가 있습니다. 라이브러리에는 인코딩 및 디코딩 기능도 포함되어 있습니다. 다음 예제는 Erlang 튜플 &lt;code&gt;{tobbe,3928}&lt;/code&gt; 을 만들고 인코딩하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="57a4e297c09c6f1e5049ba6a6a04c4f9715c1746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorDesc&lt;/code&gt; returned is an opaque value to be passed further on to function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;. For more control over the operation, use the &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; interface.</source>
          <target state="translated">반환 된 &lt;code&gt;ErrorDesc&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 함수에 추가로 전달 될 불투명 한 값 입니다. 조작을 더 제어하려면 &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; 인터페이스를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a7a560a95e6aefba3bb607f84b70fa45da9fcef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorInfo&lt;/code&gt; mentioned earlier is the standard &lt;code&gt;ErrorInfo&lt;/code&gt; structure, which is returned from all I/O modules. It has the following format:</source>
          <target state="translated">&lt;code&gt;ErrorInfo&lt;/code&gt; 앞서 언급 한 표준 &lt;code&gt;ErrorInfo&lt;/code&gt; 모든 I / O 모듈로부터 리턴 구조. 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="46cd6a74f6ad42247387aa8b77c1e43606850bb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorInfo&lt;/code&gt; mentioned in this module is the standard &lt;code&gt;ErrorInfo&lt;/code&gt; structure that is returned from all I/O modules. It has the following format:</source>
          <target state="translated">&lt;code&gt;ErrorInfo&lt;/code&gt; 이 모듈에서 언급 된 표준 &lt;code&gt;ErrorInfo&lt;/code&gt; 모든 I / O 모듈로부터 리턴 구조. 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="93b9c6c6a8848b5cb82997ba3624a2f0fabf1b76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Event Records&lt;/code&gt; in the Ets table are ordered by their timestamp. Which timestamp that should be used is controlled via the &lt;code&gt;event_order&lt;/code&gt; parameter. Default is &lt;code&gt;trace_ts&lt;/code&gt; which means the time when the trace data was generated. &lt;code&gt;event_ts&lt;/code&gt; means the time when the trace data was parsed (transformed into an &lt;code&gt;Event Record&lt;/code&gt;).</source>
          <target state="translated">Ets 테이블 의 &lt;code&gt;Event Records&lt;/code&gt; 는 타임 스탬프별로 정렬됩니다. 사용해야하는 타임 스탬프는 &lt;code&gt;event_order&lt;/code&gt; 매개 변수 를 통해 제어됩니다 . 기본값은 &lt;code&gt;trace_ts&lt;/code&gt; 이며 추적 데이터가 생성 된 시간을 의미합니다. &lt;code&gt;event_ts&lt;/code&gt; 는 추적 데이터가 구문 분석 된 ( &lt;code&gt;Event Record&lt;/code&gt; 로 변환 된) 시간을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="78b79ae16c44e1321dea0365d3ec779b8f949891" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Event Tracer (ET)&lt;/code&gt; uses named filters in various contexts. An Event Trace filter is an &lt;code&gt;Erlang fun&lt;/code&gt; that takes some trace data as input and returns a possibly modified version of it:</source>
          <target state="translated">&lt;code&gt;Event Tracer (ET)&lt;/code&gt; 다양한 상황에서 필터를 이름을 사용합니다. 이벤트 추적 필터는 일부 추적 데이터를 입력으로 사용하고 가능한 수정 된 버전을 리턴 하는 &lt;code&gt;Erlang fun&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="272a43aecd37d28c1a13622b7271bed26dc65387" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Event Tracer (ET)&lt;/code&gt; uses the built-in trace mechanism in Erlang and provides tools for collection and graphical viewing of trace data.</source>
          <target state="translated">&lt;code&gt;Event Tracer (ET)&lt;/code&gt; 수집 및 추적 데이터의 그래픽보기를 위해 얼랑에 추적 장치 내장 및 제공 도구를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7b3f5424185756e71f4988bcc6cd871d1c3dd01e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expire&lt;/code&gt; time indicates for how long the request is valid (after which the manager is free to delete it).</source>
          <target state="translated">&lt;code&gt;Expire&lt;/code&gt; 시간 (이후 관리자가 삭제 무료입니다) 요청의 유효 기간에 대한 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="39bea9e5ae5bbc7a2dffd8b8ca100b554fe6e7ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Extra&lt;/code&gt; parameter is specified when adding the filter via &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt; logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Extra&lt;/code&gt; 파라미터로 필터를 추가 할 때 지정 &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt; logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e6c34cadce8690c6e2555787337ac8b727e225e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Extra&lt;/code&gt; parameter is specified when adding the filter via &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Extra&lt;/code&gt; 파라미터로 필터를 추가 할 때 지정 &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="727df65f2f4d2a5696a95b4aebc0f85f3f6e4431" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Extra&lt;/code&gt; parameter to the &lt;code&gt;domain/2&lt;/code&gt; function is specified when adding the filter via &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt; logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;domain/2&lt;/code&gt; 함수에 대한 &lt;code&gt;Extra&lt;/code&gt; 매개 변수 는 &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt; logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; 를 통해 필터를 추가 할 때 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="229acf43839cafb043149ab1533fb570fa7aafb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Extra&lt;/code&gt; parameter to the &lt;code&gt;domain/2&lt;/code&gt; function is specified when adding the filter via &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;domain/2&lt;/code&gt; 함수에 대한 &lt;code&gt;Extra&lt;/code&gt; 매개 변수 는 &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; 를 통해 필터를 추가 할 때 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="52e94c11f02389a5bccbbedf86c2e899b3c665d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraArgument&lt;/code&gt; parameter is the empty list. For example, when the agent receives a get-request for the &lt;code&gt;ipAdr&lt;/code&gt; variable, a call will be made to &lt;code&gt;ip_access(get)&lt;/code&gt;. The value returned by this function is the answer to the get-request.</source>
          <target state="translated">&lt;code&gt;ExtraArgument&lt;/code&gt; 의 매개 변수는 빈 목록입니다. 예를 들어, 에이전트가 &lt;code&gt;ipAdr&lt;/code&gt; 변수에 대한 get-request를 받으면 &lt;code&gt;ip_access(get)&lt;/code&gt; 가 호출됩니다 . 이 함수에 의해 반환되는 값은 get-request에 대한 답변입니다.</target>
        </trans-unit>
        <trans-unit id="fb7a37656b5be6c6e17b2389894ea550dae8ed86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraInfo&lt;/code&gt; argument is passed on from the &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;ExtraInfo&lt;/code&gt; 를의 인수는에서 전달되는 &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="f30e53e02c0d2cd4e451fab992fbc868cf17c42e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraInfo&lt;/code&gt; argument is passed on to the callback functions of the &lt;code&gt;DiscoHandler&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ExtraInfo&lt;/code&gt; 를의 인수는의 콜백 함수에 전달됩니다 &lt;code&gt;DiscoHandler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="289abc6fff4535554475e47566270dcbf6237037" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Freeze&lt;/code&gt; button starts/stops the redrawing of the graph. &lt;code&gt;Reset&lt;/code&gt; moves the graph to the middle of the window and resets all graph settings to default, with the exception of deleted nodes.</source>
          <target state="translated">&lt;code&gt;Freeze&lt;/code&gt; 버튼 착공 / 그래프의 재기록을 멈춘다. &lt;code&gt;Reset&lt;/code&gt; 은 그래프를 창 가운데로 이동하고 삭제 된 노드를 제외하고 모든 그래프 설정을 기본값으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="0da0ebb6c63a989a7a4138310af5788ea3268e7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fun&lt;/code&gt; is called when the tar function wants to do a low-level operation, like writing a block to a file. The &lt;code&gt;Fun&lt;/code&gt; is called as &lt;code&gt;Fun(Op, {UserData,Parameters...})&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is the operation name, &lt;code&gt;UserData&lt;/code&gt; is the term passed as the first argument to &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;Parameters...&lt;/code&gt; are the data added by the tar function to be passed down to the storage handling function.</source>
          <target state="translated">&lt;code&gt;Fun&lt;/code&gt; 타르 기능이 파일에 블록을 기록처럼 낮은 수준의 작업을 할 경우에 불려갑니다. &lt;code&gt;Fun&lt;/code&gt; 라고한다 &lt;code&gt;Fun(Op, {UserData,Parameters...})&lt;/code&gt; , &lt;code&gt;Op&lt;/code&gt; 연산 이름은이 &lt;code&gt;UserData&lt;/code&gt; 를은 으로 첫 번째 인수로서 건네 용어 &lt;code&gt;init/1&lt;/code&gt; 과 &lt;code&gt;Parameters...&lt;/code&gt; 데이터가 추가되고 저장 처리 기능으로 전달되는 tar 함수.</target>
        </trans-unit>
        <trans-unit id="bb27036c1560c4a25ff7bd106092a75ea724c349" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fun&lt;/code&gt; is called when the tar function wants to do a low-level operation, like writing a block to a file. The &lt;code&gt;Fun&lt;/code&gt; is called as &lt;code&gt;Fun(Op, {UserPrivate,Parameters...})&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is the operation name, &lt;code&gt;UserPrivate&lt;/code&gt; is the term passed as the first argument to &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;Parameters...&lt;/code&gt; are the data added by the tar function to be passed down to the storage handling function.</source>
          <target state="translated">&lt;code&gt;Fun&lt;/code&gt; 타르 기능이 파일에 블록을 기록처럼 낮은 수준의 작업을 할 경우에 불려갑니다. &lt;code&gt;Fun&lt;/code&gt; 라고한다 &lt;code&gt;Fun(Op, {UserPrivate,Parameters...})&lt;/code&gt; , &lt;code&gt;Op&lt;/code&gt; 연산 이름은이 &lt;code&gt;UserPrivate&lt;/code&gt; 가 에 첫 번째 인수로서 건네 용어 &lt;code&gt;init/1&lt;/code&gt; 과 &lt;code&gt;Parameters...&lt;/code&gt; 데이터가 추가되고 tar 함수는 저장 처리 기능으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5d186993003ed1ccd81976e2681cc3264ce79a2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fun&lt;/code&gt; is the definition of what to do when the different storage operations functions are to be called from the higher tar handling functions (such as &lt;code&gt;add/3&lt;/code&gt;, &lt;code&gt;add/4&lt;/code&gt;, and &lt;code&gt;close/1&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Fun&lt;/code&gt; 다른 스토리지 동작 기능 함수 처리 높은 타르로부터 호출 될 때 수행 할 작업의 정의 (예로서 &lt;code&gt;add/3&lt;/code&gt; , &lt;code&gt;add/4&lt;/code&gt; 및 &lt;code&gt;close/1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ca0ec970a34ee33c7f128926a1e15f48a39b7957" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fun&lt;/code&gt; must return a new accumulator, which is passed to the next call. &lt;code&gt;foldl/3&lt;/code&gt; returns the final accumulator value. &lt;code&gt;Acc0&lt;/code&gt; is returned if the archive is empty. It is not necessary to iterate over all files in the archive. The iteration can be ended prematurely in a controlled manner by throwing an exception.</source>
          <target state="translated">&lt;code&gt;Fun&lt;/code&gt; 다음 호출에 전달되는 새로운 축적을 반환해야합니다. &lt;code&gt;foldl/3&lt;/code&gt; 는 최종 누산기 값을 반환합니다. 아카이브가 비어 있으면 &lt;code&gt;Acc0&lt;/code&gt; 이 반환됩니다. 아카이브의 모든 파일을 반복 할 필요는 없습니다. 예외를 발생시켜 제어 된 방식으로 반복을 조기에 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="387a945d1ef3c3c3d8058c83966af63af2d4d8ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Guard&lt;/code&gt; section can also contain logic and arithmetic operations, which are written with the same syntax as the guard tests (prefix notation), so that the following guard test written in Erlang:</source>
          <target state="translated">&lt;code&gt;Guard&lt;/code&gt; 섹션은 다음 보호 시험 얼랑에 기록되도록, 로직 및 보호 시험 (접두사 표기)와 같은 구문 기록 연산을 포함 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="0ed2562e6fd2d312da06422aef22e77ebef5ba9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Guard&lt;/code&gt;s are constructed as tuples, where the first element is the test name and the remaining elements are the test parameters. To check for a specific type (say a list) of the element bound to the match variable &lt;code&gt;'$1'&lt;/code&gt;, one would write the test as &lt;code&gt;{is_list, '$1'}&lt;/code&gt;. If the test fails, the object in the table does not match and the next &lt;code&gt;MatchFunction&lt;/code&gt; (if any) is tried. Most guard tests present in Erlang can be used, but only the new versions prefixed &lt;code&gt;is_&lt;/code&gt; are allowed (&lt;code&gt;is_float&lt;/code&gt;, &lt;code&gt;is_atom&lt;/code&gt;, and so on).</source>
          <target state="translated">&lt;code&gt;Guard&lt;/code&gt; 들 첫 번째 요소는 시험 이름이고 나머지 요소는 테스트 파라미터이다 튜플로 구성된다. 일치 변수 &lt;code&gt;'$1'&lt;/code&gt; 바인딩 된 요소의 특정 유형 (예 : 목록)을 확인하기 위해 테스트를 &lt;code&gt;{is_list, '$1'}&lt;/code&gt; 합니다. 테스트가 실패하면 테이블의 오브젝트가 일치하지 않고 다음 &lt;code&gt;MatchFunction&lt;/code&gt; (있는 경우)이 시도됩니다. 얼랑에 존재하는 대부분의 가드 검사는 사용할 수 있지만 새로운 버전은 접두사 &lt;code&gt;is_&lt;/code&gt; (허용 &lt;code&gt;is_float&lt;/code&gt; , &lt;code&gt;is_atom&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="3de2a50d3651924af28c65d29b6c75e407eb8165" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HTTP&lt;/code&gt; version of the request, that is, &quot;HTTP/0.9&quot;, &quot;HTTP/1.0&quot;, or &quot;HTTP/1.1&quot;.</source>
          <target state="translated">요청 의 &lt;code&gt;HTTP&lt;/code&gt; 버전, 즉 &quot;HTTP / 0.9&quot;, &quot;HTTP / 1.0&quot;또는 &quot;HTTP / 1.1&quot;</target>
        </trans-unit>
        <trans-unit id="462a5eb6a4e1b7237b73c6e94eed8c647d921612" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HostName&lt;/code&gt; will also be used in the hostname verification of the peer certificate using &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HostName&lt;/code&gt; 도 사용 피어 인증서의 호스트 이름 검증에 사용됩니다 &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fe5414d8d8a859939f8d4935fe18c2a11ba8b69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Id&lt;/code&gt; identifies a CTH instance uniquely. If two CTHs return the same &lt;code&gt;Id&lt;/code&gt;, the second CTH is ignored and subsequent calls to the CTH are only made to the first instance. For details, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#installing&quot;&gt;Installing a CTH&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">&lt;code&gt;Id&lt;/code&gt; 고유 CTH 인스턴스를 식별합니다. 두 개의 CTH가 동일한 &lt;code&gt;Id&lt;/code&gt; 를 리턴하면 두 번째 CTH는 무시되고 CTH에 대한 후속 호출은 첫 번째 인스턴스에만 수행됩니다. 자세한 내용 은 사용 설명서의 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#installing&quot;&gt;Installing a CTH&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c260809e9afd9c349ba39adc0e706099bd4227f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InclNodes&lt;/code&gt; argument to &lt;code&gt;run/3&lt;/code&gt; is a list of node names. Function &lt;code&gt;run/3&lt;/code&gt; runs the tests in &lt;code&gt;TestSpecs&lt;/code&gt; just like &lt;code&gt;run/1&lt;/code&gt;, but also takes any test in &lt;code&gt;TestSpecs&lt;/code&gt;, which is not explicitly tagged with a particular node name, and execute it on the nodes listed in &lt;code&gt;InclNodes&lt;/code&gt;. By using &lt;code&gt;run/3&lt;/code&gt; this way, any test specification can be used, with or without node information, in a large-scale test environment.</source>
          <target state="translated">&lt;code&gt;run/3&lt;/code&gt; 의 &lt;code&gt;InclNodes&lt;/code&gt; 인수 는 노드 이름 목록입니다. &lt;code&gt;run/3&lt;/code&gt; 함수 는 &lt;code&gt;run/1&lt;/code&gt; 과 같이 &lt;code&gt;TestSpecs&lt;/code&gt; 에서 테스트를 실행 하지만 &lt;code&gt;TestSpecs&lt;/code&gt; 에서 테스트를 수행합니다. TestSpecs 에서는 특정 노드 이름으로 명시 적으로 태그가 지정되지 않은 상태에서 &lt;code&gt;InclNodes&lt;/code&gt; 에 나열된 노드에서 테스트를 실행합니다 . 사용하여 &lt;code&gt;run/3&lt;/code&gt; 이런 식으로, 어떤 테스트 사양은 대규모 테스트 환경에서, 또는 노드 정보없이 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="728f2fde5e1be51dec6dbadf7fd8bb23ae8a8436" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InfoTuple&lt;/code&gt;s with the following items are part of the result:</source>
          <target state="translated">다음 항목이 포함 된 &lt;code&gt;InfoTuple&lt;/code&gt; 은 결과의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="18a616360c14e89869b3ee8a191e8982efcb7c70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InitFun&lt;/code&gt; is applied once prior to any other &lt;code&gt;crypto&lt;/code&gt; operation. The returned &lt;code&gt;CryptoState&lt;/code&gt; is then folded into repeated applications of the &lt;code&gt;EncryptFun&lt;/code&gt; or &lt;code&gt;DecryptFun&lt;/code&gt;. The binary returned from those funs are sent further to the remote SFTP server. Finally, if doing encryption, the &lt;code&gt;CloseFun&lt;/code&gt; is applied to the last piece of data. The &lt;code&gt;CloseFun&lt;/code&gt; is responsible for padding (if needed) and encryption of that last piece.</source>
          <target state="translated">&lt;code&gt;InitFun&lt;/code&gt; 는 임의의 다른 이전에 한번 적용되는 &lt;code&gt;crypto&lt;/code&gt; 동작. 리턴 된 &lt;code&gt;CryptoState&lt;/code&gt; 는 &lt;code&gt;EncryptFun&lt;/code&gt; 또는 &lt;code&gt;DecryptFun&lt;/code&gt; 의 반복 된 애플리케이션으로 접 힙니다 . 해당 기능에서 반환 된 바이너리는 원격 SFTP 서버로 더 전송됩니다. 마지막으로 암호화를 수행하면 &lt;code&gt;CloseFun&lt;/code&gt; 이 마지막 데이터에 적용됩니다. &lt;code&gt;CloseFun&lt;/code&gt; 은 마지막 부분의 패딩 (필요한 경우) 및 암호화에 대한 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f831068a66059cf58bd10807a62c5026adc8c387" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Install&lt;/code&gt; script should currently be invoked as follows in the directory where it resides (the top directory):</source>
          <target state="translated">&lt;code&gt;Install&lt;/code&gt; 는 (상위 디렉토리)에있는 디렉토리에 다음과 같이 스크립트는 현재 호출해야합니다 :</target>
        </trans-unit>
        <trans-unit id="151c25d0c87229840b1a357c4265bc6b194406ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Install&lt;/code&gt; script used when installing Erlang/OTP requires common Unix tools such as &lt;code&gt;sed&lt;/code&gt; to be present in your &lt;code&gt;$PATH&lt;/code&gt;. If your target system does not have such tools, you need to run the &lt;code&gt;Install&lt;/code&gt; script on your build machine before packaging Erlang/OTP. The &lt;code&gt;Install&lt;/code&gt; script should currently be invoked as follows in the directory where it resides (the top directory):</source>
          <target state="translated">&lt;code&gt;Install&lt;/code&gt; 얼랑 / OTP를 설치할 때 사용되는 스크립트와 같은 일반적인 유닉스 도구를 필요로 &lt;code&gt;sed&lt;/code&gt; 당신에 존재하는 &lt;code&gt;$PATH&lt;/code&gt; . 대상 시스템에 이러한 도구가없는 경우 Erlang / OTP를 패키징하기 전에 빌드 시스템 에서 &lt;code&gt;Install&lt;/code&gt; 스크립트 를 실행해야합니다 . &lt;code&gt;Install&lt;/code&gt; 는 (상위 디렉토리)에있는 디렉토리에 다음과 같이 스크립트는 현재 호출해야합니다 :</target>
        </trans-unit>
        <trans-unit id="63ceadf10aefd8db61da0846c16f50dd4c57bf68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Issuer&lt;/code&gt; argument contains the issuer name of the certificate to be checked. Normally the returned CRL should be issued by this issuer, except if the &lt;code&gt;cRLIssuer&lt;/code&gt; field of &lt;code&gt;DistributionPoint&lt;/code&gt; has a value, in which case that value should be used instead.</source>
          <target state="translated">&lt;code&gt;Issuer&lt;/code&gt; 인수는 인증서 발급자의 이름을 확인하기 위해 포함되어 있습니다. 일반적으로 반환 된 CRL은 &lt;code&gt;DistributionPoint&lt;/code&gt; 의 &lt;code&gt;cRLIssuer&lt;/code&gt; 필드에 값이있는 경우를 제외하고이 발행자가 발행해야합니다.이 경우 해당 값을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1df86fa6a13d4782f56f4b70368193619f74ccce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JCL&lt;/code&gt; commands have the following meaning:</source>
          <target state="translated">&lt;code&gt;JCL&lt;/code&gt; 의 명령은 다음과 같은 의미를 갖는다 :</target>
        </trans-unit>
        <trans-unit id="eb0d6b265bbd8a2ede63c784c4e76e0b9b25a09c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LANG&lt;/code&gt; or &lt;code&gt;LC_CTYPE&lt;/code&gt; setting are to be consistent with what the terminal is capable of. There is no portable way for Erlang to ask the terminal about its UTF-8 capacity, we have to rely on the language and character type settings.</source>
          <target state="translated">&lt;code&gt;LANG&lt;/code&gt; 또는 &lt;code&gt;LC_CTYPE&lt;/code&gt; 의 설정은 단말이 가능한 것과 일치한다. Erlang이 터미널에 UTF-8 용량을 물어볼 수있는 휴대용 방법은 없습니다. 언어 및 문자 유형 설정에 의존해야합니다.</target>
        </trans-unit>
        <trans-unit id="6dcd5eb8b8d30040b44118c19bb40f40ac2fd675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Lin&lt;/code&gt; (&lt;code&gt;LLin&lt;/code&gt;, &lt;code&gt;XLin&lt;/code&gt;) operator assigns the lines where calls (local calls, external calls) are made. The &lt;code&gt;ELin&lt;/code&gt; operator assigns to each call (From, To), for which it is defined, every line L such that there is a chain of calls from From to To beginning with a call on line L.</source>
          <target state="translated">&lt;code&gt;Lin&lt;/code&gt; ( &lt;code&gt;LLin&lt;/code&gt; , &lt;code&gt;XLin&lt;/code&gt; ) 연산자 양수인 전화 (지역 전화, 외부 호출)에 만들어지는 선. &lt;code&gt;ELin&lt;/code&gt; 값이 정의되는 (에,에서) 각각의 호출로부터 내지 L. 라인의 통화로 시작 호출 체인이되도록 각 라인 L에 대입 연산자</target>
        </trans-unit>
        <trans-unit id="ddd6ecd801eba0297210dd779a386d2f9b34f307" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ListOfExtraArguments&lt;/code&gt; can be used to write generic functions. This list is appended to the standard arguments for each function. Consider two read-only variables for a device, &lt;code&gt;ipAdr&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; with object identifiers 1.1.23.4 and 1.1.7 respectively. To access these variables, one could implement the two Erlang functions &lt;code&gt;ip_access&lt;/code&gt; and &lt;code&gt;name_access&lt;/code&gt;, which will be in the MIB. The functions could be specified in a text file as follows:</source>
          <target state="translated">&lt;code&gt;ListOfExtraArguments&lt;/code&gt; 는 일반적인 함수를 작성하는 데 사용할 수 있습니다. 이 목록은 각 함수의 표준 인수에 추가됩니다. 개체 식별자가 각각 1.1.23.4 및 1.1.7 인 장치에 대해 &lt;code&gt;ipAdr&lt;/code&gt; 및 &lt;code&gt;name&lt;/code&gt; 이라는 두 가지 읽기 전용 변수를 고려하십시오 . 이러한 변수에 액세스하기 위해 MIB에 있는 두 개의 Erlang 함수 &lt;code&gt;ip_access&lt;/code&gt; 및 &lt;code&gt;name_access&lt;/code&gt; 를 구현할 수 있습니다. 함수는 텍스트 파일에서 다음과 같이 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1503197789ab51916ae2782b9a6115c1230e790" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Listen&lt;/code&gt; argument will be the same as the &lt;code&gt;Listen&lt;/code&gt; handle part of the return value of the &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; callback above. &lt;code&gt;accept/1&lt;/code&gt; is called only once when the distribution protocol is started.</source>
          <target state="translated">&lt;code&gt;Listen&lt;/code&gt; (가)로 인수가 동일합니다 &lt;code&gt;Listen&lt;/code&gt; 의 반환 값의 손잡이 부분 &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; 위의 콜백을. 분배 프로토콜이 시작될 때 &lt;code&gt;accept/1&lt;/code&gt; 이 한 번만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="431a15a498450f82a9cfae588ffa70427314b380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LoadOrder&lt;/code&gt; priority is by default &lt;code&gt;0&lt;/code&gt; (zero) but can be set to any integer. The tables with the highest &lt;code&gt;LoadOrder&lt;/code&gt; priority are loaded first at startup.</source>
          <target state="translated">&lt;code&gt;LoadOrder&lt;/code&gt; 의 우선 순위는 디폴트로 &lt;code&gt;0&lt;/code&gt; (영)하지만, 정수로 설정할 수 있습니다. &lt;code&gt;LoadOrder&lt;/code&gt; 우선 순위가 가장 높은 테이블이 시작시 먼저로드됩니다.</target>
        </trans-unit>
        <trans-unit id="c0d1ccb772696ffcb0ff02e3e38d3edd067a8070" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Low&lt;/code&gt; limit is automatically adjusted to the same as &lt;code&gt;High&lt;/code&gt; if it is set larger then &lt;code&gt;High&lt;/code&gt;. Valid range of values for &lt;code&gt;Low&lt;/code&gt; and &lt;code&gt;High&lt;/code&gt; is &lt;code&gt;[1, (1 bsl (8*erlang:system_info(wordsize)))-2]&lt;/code&gt;. If the atom &lt;code&gt;disabled&lt;/code&gt; is passed, the port message queue will never enter the busy state.</source>
          <target state="translated">&lt;code&gt;Low&lt;/code&gt; 한계는 자동으로 동일하게 조정 &lt;code&gt;High&lt;/code&gt; 그 다음 큰 설정되어있는 경우 &lt;code&gt;High&lt;/code&gt; . &lt;code&gt;Low&lt;/code&gt; 및 &lt;code&gt;High&lt;/code&gt; 값의 유효한 범위 는 &lt;code&gt;[1, (1 bsl (8*erlang:system_info(wordsize)))-2]&lt;/code&gt; 입니다. &lt;code&gt;disabled&lt;/code&gt; 된 원자가 전달되면 포트 메시지 큐는 사용 중 상태가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ca11762016f06296699f63500e41a8f8017d459" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Low&lt;/code&gt; limit is automatically adjusted to the same as &lt;code&gt;High&lt;/code&gt; if it is set larger then &lt;code&gt;High&lt;/code&gt;. Valid range of values for &lt;code&gt;Low&lt;/code&gt; and &lt;code&gt;High&lt;/code&gt; is &lt;code&gt;[1, (1 bsl (8*erlang:system_info(wordsize)))-2]&lt;/code&gt;. If the atom &lt;code&gt;disabled&lt;/code&gt; is passed, the port will never enter the busy state.</source>
          <target state="translated">&lt;code&gt;Low&lt;/code&gt; 한계는 자동으로 동일하게 조정 &lt;code&gt;High&lt;/code&gt; 그 다음 큰 설정되어있는 경우 &lt;code&gt;High&lt;/code&gt; . &lt;code&gt;Low&lt;/code&gt; 및 &lt;code&gt;High&lt;/code&gt; 값의 유효한 범위 는 &lt;code&gt;[1, (1 bsl (8*erlang:system_info(wordsize)))-2]&lt;/code&gt; 입니다. &lt;code&gt;disabled&lt;/code&gt; 된 원자가 전달되면 포트는 사용 중 상태가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ca1036527f7b7c9ab7ab8a36cae20db5fe67ec0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MEDIA-GATEWAY-CONTROL&lt;/code&gt; configuration was as follows:</source>
          <target state="translated">&lt;code&gt;MEDIA-GATEWAY-CONTROL&lt;/code&gt; 는 다음과 같이 구성되었다 :</target>
        </trans-unit>
        <trans-unit id="d517f2a191b0a2929a426e74c5d9977a2a92791e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MIB.Object&lt;/code&gt; syntax is not implemented (since all objects must be unique anyway).</source>
          <target state="translated">&lt;code&gt;MIB.Object&lt;/code&gt; 의 (모든 개체에 고유 어쨌든해야하기 때문에) 구문은 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="431d9a802a4fe9bcef002e403293ba1753c616e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mac&lt;/code&gt; result will have a default length depending on the &lt;code&gt;Type&lt;/code&gt; and &lt;code&gt;SubType&lt;/code&gt;. To set a shorter length, use &lt;code&gt;&lt;a href=&quot;#macN-4&quot;&gt;macN/4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#macN-5&quot;&gt;macN/5&lt;/a&gt;&lt;/code&gt; instead. The default length is documented in &lt;code&gt;&lt;a href=&quot;algorithm_details#message-authentication-codes--macs-&quot;&gt;Algorithm Details&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">&lt;code&gt;Mac&lt;/code&gt; 결과에 따라 기본 길이를해야합니다 &lt;code&gt;Type&lt;/code&gt; 및 &lt;code&gt;SubType&lt;/code&gt; . 더 짧은 길이를 설정하려면 대신 &lt;code&gt;&lt;a href=&quot;#macN-4&quot;&gt;macN/4&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#macN-5&quot;&gt;macN/5&lt;/a&gt;&lt;/code&gt; 를 사용하십시오. 기본 길이는 사용자 가이드의 &lt;code&gt;&lt;a href=&quot;algorithm_details#message-authentication-codes--macs-&quot;&gt;Algorithm Details&lt;/a&gt;&lt;/code&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b5dc880ea5414559476926c86f0abfef7e6942b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Makefile&lt;/code&gt; for building the emulator currently defines the following symbols by using the &lt;code&gt;-D&lt;/code&gt; option on the command line for &lt;strong&gt;beam_makeops&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;Makefile&lt;/code&gt; 에뮬레이터를 구축하기위한 현재 사용하여 다음과 같은 기호를 정의 &lt;code&gt;-D&lt;/code&gt; 에 대한 명령 행 옵션 &lt;strong&gt;beam_makeops을&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="636dca28dbd87863b36f206b257464a2e654c483" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Max Carrier size&lt;/code&gt; column shows the maximum value seen by observer since the last node change or since the start of the application, i.e. switching nodes will reset the max column. Values are sampled so higher values may have existed than what is shown.</source>
          <target state="translated">&lt;code&gt;Max Carrier size&lt;/code&gt; 칼럼 쇼 마지막 노드 변화 이후 또는 프로그램의 시작 이후, 관찰자가 볼의 최대 값, 즉 스위칭 노드는 최대 열을 재설정한다. 값이 샘플링되어 표시된 값보다 높은 값이 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc6e05d560929a4a9cfa001cecdf62f1726f815c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mnesia&lt;/code&gt; programmer cannot prioritize one particular transaction to execute before other transactions that are waiting to execute. As a result, the &lt;code&gt;Mnesia&lt;/code&gt; DBMS transaction system is not suitable for hard real-time applications. However, &lt;code&gt;Mnesia&lt;/code&gt; contains other features that have real-time properties.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 의 프로그래머는 실행 대기중인 다른 트랜잭션 전에 실행 한 특정 거래의 우선 순위를 할 수 없다. 결과적으로 &lt;code&gt;Mnesia&lt;/code&gt; DBMS 트랜잭션 시스템은 하드 실시간 애플리케이션에는 적합하지 않습니다. 그러나 &lt;code&gt;Mnesia&lt;/code&gt; 에는 실시간 속성이있는 다른 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2398df613eed0972c6702e33c30169f57db4a6c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mnesia&lt;/code&gt; record identifiers (&lt;code&gt;{Tab, Key}&lt;/code&gt;) can also be used as references. In this case, attribute &lt;code&gt;dept&lt;/code&gt; would be set to value &lt;code&gt;{dept, 'B/SFR'}&lt;/code&gt; instead of &lt;code&gt;'B/SFR'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 의 기록 식별자 ( &lt;code&gt;{Tab, Key}&lt;/code&gt; )도 참조로 사용할 수 있습니다. 이 경우, 속성 &lt;code&gt;dept&lt;/code&gt; 값으로 설정된다 &lt;code&gt;{dept, 'B/SFR'}&lt;/code&gt; 대신 &lt;code&gt;'B/SFR'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90246ca10a3686ec4547ee9155bf07c76827f547" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mnesia&lt;/code&gt; transaction system facilitates the construction of reliable, distributed systems by providing the following important properties:</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 의 거래 시스템은 다음과 같은 중요한 특성을 제공하여 신뢰성, 분산 시스템의 구축을 용이 :</target>
        </trans-unit>
        <trans-unit id="05c05e9d6716d8728951521a8360d9cad3bf485c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mnesia&lt;/code&gt; transactions have four important properties, called &lt;strong&gt;A&lt;/strong&gt;tomicity, &lt;strong&gt;C&lt;/strong&gt;onsistency, &lt;strong&gt;I&lt;/strong&gt;solation, and &lt;strong&gt;D&lt;/strong&gt;urability (ACID). These properties are described in the following sections.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 의 거래는 네 가지 중요한 속성이라고해야 &lt;strong&gt;의&lt;/strong&gt; tomicity, &lt;strong&gt;C의&lt;/strong&gt; onsistency, &lt;strong&gt;I의&lt;/strong&gt; solation 및 &lt;strong&gt;D의&lt;/strong&gt; 가능성에 의한 (ACID)를. 이러한 속성은 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="34969f65d94bd140bef4861a2be0633f1edd4059" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Module:callback_mode()&lt;/code&gt; function may also return a list containing the callback mode and the atom &lt;code&gt;state_enter&lt;/code&gt; in which case &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;State Enter Calls&lt;/a&gt;&lt;/code&gt; are activated for the callback mode.</source>
          <target state="translated">&lt;code&gt;Module:callback_mode()&lt;/code&gt; 함수는 콜백 모드와 원자 함유리스트 반환 할 &lt;code&gt;state_enter&lt;/code&gt; 경우있는 &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;State Enter Calls&lt;/a&gt;&lt;/code&gt; 콜백 모드가 활성화된다.</target>
        </trans-unit>
        <trans-unit id="40a0e269f3ccc50144dceff290b7ec1e5d3d30c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Msg&lt;/code&gt; is either the binary &quot;plain text&quot; data or it is the hashed value of &quot;plain text&quot;, that is, the digest.</source>
          <target state="translated">&lt;code&gt;Msg&lt;/code&gt; 하나 바이너리 &quot;일반 텍스트&quot;데이터 또는 그것은 즉, 소화 &quot;일반 텍스트&quot;의 해시 값입니다.</target>
        </trans-unit>
        <trans-unit id="aa7575828f011f723e11b39b2169db4b9db4b1aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Msg&lt;/code&gt; is either the binary &quot;plain text&quot; data to be signed or it is the hashed value of &quot;plain text&quot;, that is, the digest.</source>
          <target state="translated">&lt;code&gt;Msg&lt;/code&gt; 하나 서명 할 수있는 바이너리 &quot;일반 텍스트&quot;데이터 또는 그것은 즉, 소화 &quot;일반 텍스트&quot;의 해시 값입니다.</target>
        </trans-unit>
        <trans-unit id="caed8c29d6ad9904a92815ee1e45441de9aec981" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Path&lt;/code&gt; parameters have exactly the same meaning as when calling the plain function &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 과 &lt;code&gt;Path&lt;/code&gt; 매개 변수는 일반 함수를 호출 할 때와 정확히 같은 의미가 &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27916491cb8658a94525ccdce76cf8ccb4103b9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Name&lt;/code&gt; field is the first element of the tuple.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 필드는 튜플의 첫 번째 요소입니다.</target>
        </trans-unit>
        <trans-unit id="771b9f2fcc80d7e7468afb27c626f330320484ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Name&lt;/code&gt; is &lt;code&gt;&quot;sftp&quot;&lt;/code&gt; and &lt;code&gt;CbMod&lt;/code&gt; is the name of the Erlang module implementing the subsystem using the &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; (replaces ssh_daemon_channel) behaviour.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 이다 &lt;code&gt;&quot;sftp&quot;&lt;/code&gt; 와 &lt;code&gt;CbMod&lt;/code&gt; 는 사용하여 서브 시스템 구현 얼랑 모듈의 이름입니다 &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; (을 대체 ssh_daemon_channel) 동작을.</target>
        </trans-unit>
        <trans-unit id="3ca819160319b409a2f4c421438e5784e6c81c13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Name&lt;/code&gt; specified is to correspond to the filename of the dynamically loadable object file residing in the directory specified as &lt;code&gt;Path&lt;/code&gt;, but &lt;strong&gt;without&lt;/strong&gt; the extension (that is, &lt;code&gt;.so&lt;/code&gt;). The driver name provided in the driver initialization routine must correspond with the filename, in much the same way as Erlang module names correspond to the names of the &lt;code&gt;.beam&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 으로 지정된 디렉토리에있는 동적으로로드 가능한 오브젝트 파일의 파일 이름에 해당하는 지정된 &lt;code&gt;Path&lt;/code&gt; ,하지만 &lt;strong&gt;하지 않고&lt;/strong&gt; (즉, 확장 &lt;code&gt;.so&lt;/code&gt; ). 드라이버 초기화 루틴에서 제공되는 드라이버 이름은 파일 이름과 일치해야합니다. Erlang 모듈 이름이 &lt;code&gt;.beam&lt;/code&gt; 파일 이름과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="a8577668ea7b4d3a7d25c6ddf13c9da38e01e030" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NegotiationTimeout&lt;/code&gt; is in milli-seconds. The default value is &lt;code&gt;infinity&lt;/code&gt;. For connection timeout, use the option &lt;code&gt;&lt;a href=&quot;#type-connect_timeout_client_option&quot;&gt;connect_timeout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NegotiationTimeout&lt;/code&gt; 는 밀리 초입니다. 기본값은 &lt;code&gt;infinity&lt;/code&gt; 입니다. 연결 시간 종료의 경우 &lt;code&gt;&lt;a href=&quot;#type-connect_timeout_client_option&quot;&gt;connect_timeout&lt;/a&gt;&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="25cf803e685b877b848b6e92d88b9c3e6c3210a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; is an important type and it is widely used within different standards to identify various objects uniquely. Dubuisson: ASN.1 - Communication Between Heterogeneous Systems includes an easy-to-understand description of the use of &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 중요한 형태이며 널리 유일하게 다양한 개체를 식별하기 위해 다른 표준 내에서 사용된다. Dubuisson : ASN.1-이기종 시스템 간 통신에는 &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 사용에 대한 이해하기 쉬운 설명이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d89a49f90db529d1a87ec8ebe643fd609dd3d3b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; value is simply a tuple with the consecutive values, which must be integers.</source>
          <target state="translated">&lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 값은 단순히 정수이어야 연속 값을 가진 튜플이다.</target>
        </trans-unit>
        <trans-unit id="a30b8da746d4069e2cdb144e9b76560cd1897c56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Old API&lt;/code&gt; is now deprecated and has also been &lt;code&gt;&lt;a href=&quot;scheduled_for_removal#otp-24&quot;&gt;scheduled for removal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Old API&lt;/code&gt; 이제 사용되지 않으며 또한되었다 &lt;code&gt;&lt;a href=&quot;scheduled_for_removal#otp-24&quot;&gt;scheduled for removal&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b07c15aa636f0544d2756cdbf51bdac039857354" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Old API&lt;/code&gt; will be removed as of OTP 24. The support was formally deprecated as of OTP 23.</source>
          <target state="translated">&lt;code&gt;Old API&lt;/code&gt; 지원이 공식적으로 OTP (23)로 사용되지 않습니다 OTP (24)로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="291813bf4581fd45b017cff8a605850835e5740d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Operation&lt;/code&gt; can be &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;is_set_ok&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, or &lt;code&gt;undo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Operation&lt;/code&gt; 할 수 있습니다 &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;delete&lt;/code&gt; , &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;is_set_ok&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; 또는 &lt;code&gt;undo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0de93bd973f344208a44803393d2336ed72a592" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Operation&lt;/code&gt; can be &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;is_set_ok&lt;/code&gt;, &lt;code&gt;undo&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Operation&lt;/code&gt; 할 수 있습니다 &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;delete&lt;/code&gt; , &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;is_set_ok&lt;/code&gt; , &lt;code&gt;undo&lt;/code&gt; 또는 &lt;code&gt;set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9dd3e602f768fecc29440b2334d159be22f01871" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Opts&lt;/code&gt; argument is intended for &quot;other&quot; options. The supported option(s) are described below:</source>
          <target state="translated">&lt;code&gt;Opts&lt;/code&gt; 인수는 &quot;기타&quot;옵션을위한 것입니다. 지원되는 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="98288c1e55f84bdd812985a5fd086264e78ad4f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Opts&lt;/code&gt; argument is intended for providing extra information for the open call:</source>
          <target state="translated">&lt;code&gt;Opts&lt;/code&gt; 인수는 공모에 대한 추가 정보를 제공하기위한 것입니다 :</target>
        </trans-unit>
        <trans-unit id="1c435f50eeeff168b9ba4f24d7c44a547a62546d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Opts&lt;/code&gt; defaults to &lt;code&gt;[]&lt;/code&gt; when only the &lt;code&gt;Module&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;Opts&lt;/code&gt; 기본값은 &lt;code&gt;[]&lt;/code&gt; 는 경우에만 &lt;code&gt;Module&lt;/code&gt; 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="fb29cec4d8746b25b30ed76f21784b67fd7d4bbc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Phone&lt;/code&gt; field is the third element.</source>
          <target state="translated">&lt;code&gt;Phone&lt;/code&gt; 필드는 세 번째 요소입니다.</target>
        </trans-unit>
        <trans-unit id="9a36c74c23cadea74c3943787187639b86600b99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pid&lt;/code&gt; is the process handling the supervision of the SNMP manager start. When the manager has started a completion message will be sent to the client from this process: &lt;code&gt;{snmpm_started, Pid}&lt;/code&gt;. If the SNMP manager was not started in time, a timeout message will be sent to the client: &lt;code&gt;{snmpm_start_timeout, Pid}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; SNMP 관리자 시작의 감독을 처리하는 과정입니다. 관리자가 시작되면 &lt;code&gt;{snmpm_started, Pid}&lt;/code&gt; 프로세스에서 완료 메시지가 클라이언트로 전송됩니다 . SNMP 관리자가 제 시간에 시작되지 않은 경우 시간 종료 메시지가 클라이언트로 전송됩니다 : &lt;code&gt;{snmpm_start_timeout, Pid}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b30293a63b2a3b26c593085f1e5a77514ed0092c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PingTO&lt;/code&gt; time specifies the between a successful ping (or start) and the time when a &lt;code&gt;&lt;a href=&quot;snmp_manager_netif#im_ping&quot;&gt;ping&lt;/a&gt;&lt;/code&gt; message is to be sent to the net-if process (basically the time between ping:s).</source>
          <target state="translated">&lt;code&gt;PingTO&lt;/code&gt; 의 성공적인 핑 사이의 시간 지정 (시작 또는)과 시간 &lt;code&gt;&lt;a href=&quot;snmp_manager_netif#im_ping&quot;&gt;ping&lt;/a&gt;&lt;/code&gt; (:의 핑 (ping) 사이의 기본적 시간) 메시지가이 순-경우 공정드립니다.</target>
        </trans-unit>
        <trans-unit id="523184d1586b2a64475008cf790d421779a2a4e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PongTO&lt;/code&gt; time specifies how long time the net-if process has to respond to a ping message, with a &lt;code&gt;&lt;a href=&quot;snmp_manager_netif#om_pong&quot;&gt;pong&lt;/a&gt;&lt;/code&gt; message. It starts counting when the ping message has been sent.</source>
          <target state="translated">&lt;code&gt;PongTO&lt;/code&gt; 의 시간을 지정하는 시간을 시간 순-경우 프로세스가와, 핑 메시지에 응답하는 &lt;code&gt;&lt;a href=&quot;snmp_manager_netif#om_pong&quot;&gt;pong&lt;/a&gt;&lt;/code&gt; 메시지. 핑 메시지가 전송되면 계산을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="5ad1ec7b826ce17efed8a480d14fb2c2d7c83c24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ProtocolVersion&lt;/code&gt; version is the version actually encoded in the reply message.</source>
          <target state="translated">&lt;code&gt;ProtocolVersion&lt;/code&gt; 의 버전은 실제로 응답 메시지로 인코딩 된 버전입니다.</target>
        </trans-unit>
        <trans-unit id="cc15bf57b674de665a3aa4e09be58f12e93f6528" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RELATIVE-OID&lt;/code&gt; type for relative object identifiers is fully supported.</source>
          <target state="translated">&lt;code&gt;RELATIVE-OID&lt;/code&gt; 상대 객체 식별자에 대한 유형을 완벽하게 지원한다.</target>
        </trans-unit>
        <trans-unit id="500392beab058916677f3be61233265c489d27bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reason&lt;/code&gt; parameter in the &lt;code&gt;&lt;a href=&quot;snmpm_user#handle_error&quot;&gt;handle_error&lt;/a&gt;&lt;/code&gt; user callback function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;snmpm_user#handle_error&quot;&gt;handle_error&lt;/a&gt;&lt;/code&gt; 사용자 콜백 함수 의 &lt;code&gt;Reason&lt;/code&gt; 매개 변수 .</target>
        </trans-unit>
        <trans-unit id="6b9fce90dd7e0310098f64ad13d29f2262c2551d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reason&lt;/code&gt; returned value if any of the sync/async get/get-next/set/get-bulk functions returns &lt;code&gt;{error, Reason}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Reason&lt;/code&gt; 값을 반환하는 경우 동기화의 / 비동기 GET / GET-다음 / 설정 / 얻을 벌크 기능 반환 &lt;code&gt;{error, Reason}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1adaa6337c0136bccefb9d645f47ac7a3dea29f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReplyData&lt;/code&gt; defaults to &lt;code&gt;megaco:lookup(ConnHandle, reply_data)&lt;/code&gt;, but may be explicitly overridden by a &lt;code&gt;megaco:cast/3&lt;/code&gt; option in order to forward info about the calling context of the originating process.</source>
          <target state="translated">&lt;code&gt;ReplyData&lt;/code&gt; 의 기본값 &lt;code&gt;megaco:lookup(ConnHandle, reply_data)&lt;/code&gt; 하지만,이 명시 적으로 오버라이드 (override) 할 수 &lt;code&gt;megaco:cast/3&lt;/code&gt; 옵션 위해 원래 프로세스의 호출 컨텍스트에 대한 앞으로 정보에.</target>
        </trans-unit>
        <trans-unit id="5dcd8c369c6500e932ff1e1629f6fafbdc39108e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Request-Line&lt;/code&gt; as defined in&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;&quot;GET /cgi-bin/find.pl?person=jocke HTTP/1.0&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Request-Line&lt;/code&gt; 에 정의 된 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; , 예를 들어, &lt;code&gt;&quot;GET /cgi-bin/find.pl?person=jocke HTTP/1.0&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="560f996f8e0b32b35d673e574bfba7c7f5732599" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Request-URI&lt;/code&gt; as defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;&quot;/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Request-URI&lt;/code&gt; 에 기재된 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; , 예를 들면, &lt;code&gt;&quot;/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09cc862e08384f6496c068b1ef00d8543bcd2fea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Request&lt;/code&gt; element can in itself contain many &lt;code&gt;Request&lt;/code&gt;s by using the following format:</source>
          <target state="translated">&lt;code&gt;Request&lt;/code&gt; 자체 요소 캔 많은 포함 &lt;code&gt;Request&lt;/code&gt; 은 다음 형식을 사용하여들 :</target>
        </trans-unit>
        <trans-unit id="df3736ae6d527f6dc758c7bc44a6f372a5715a61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Root directory&lt;/code&gt; can be edited by selecting the line where the path of the root directory is displayed and clicking the right mouse button. Choose edit in the menu that pops up.</source>
          <target state="translated">&lt;code&gt;Root directory&lt;/code&gt; 루트 디렉토리의 경로가 표시되는 선을 선택하고 마우스 오른쪽 버튼을 클릭하여 편집 할 수 있습니다. 팝업 메뉴에서 편집을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="84770d839ef4e410e85af06b8af1e00bd08e41e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RowIndex&lt;/code&gt; argument may refer to an existing row or a non-existing row, or it may be unspecified. The &lt;code&gt;Cols&lt;/code&gt; list may refer to inaccessible columns or non-existing columns. For each column in the &lt;code&gt;Cols&lt;/code&gt; list, the corresponding next instance is determined, and the last part of its OBJECT IDENTIFIER and its value is returned.</source>
          <target state="translated">&lt;code&gt;RowIndex&lt;/code&gt; 인수는 기존 행하거나 존재하지 않는 행을 참조 할 수 있거나, 지정 될 수있다. &lt;code&gt;Cols&lt;/code&gt; 목록에 액세스 할 열 또는 존재하지 않는 열을 참조 할 수 있습니다. &lt;code&gt;Cols&lt;/code&gt; 목록의 각 열에 대해 해당하는 다음 인스턴스가 결정되고 OBJECT IDENTIFIER 및 해당 값의 마지막 부분이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b8d86bbb9ebe74c2dccf692588c950366f9986be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SecurityCallbackModule&lt;/code&gt; is a user-written module that can receive events from the &lt;code&gt;mod_security&lt;/code&gt; Erlang web server API module. This module only exports the functions event/[4,5] which are described here.</source>
          <target state="translated">&lt;code&gt;SecurityCallbackModule&lt;/code&gt; 은 로부터 이벤트를 수신 할 수있는 사용자가 작성한 모듈 &lt;code&gt;mod_security&lt;/code&gt; 얼랑 웹 서버 API 모듈을. 이 모듈은 여기에 설명 된 event / [4,5] 기능 만 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="6af65a9600faa054b3af4ac9bf04b32c2eda0702" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SeqCnt&lt;/code&gt; values in the filenames are all in the range &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;WrapCnt&lt;/code&gt; with a gap in the circular sequence. The gap is needed to find the end of the trace.</source>
          <target state="translated">파일 이름 의 &lt;code&gt;SeqCnt&lt;/code&gt; 값은 모두 원형 시퀀스에 간격이있는 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;WrapCnt&lt;/code&gt; 범위 입니다. 추적의 끝을 찾으려면 간격이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c2214d4ed634c1087714e34b7518b2efdc6127b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Size&lt;/code&gt; or the &lt;code&gt;TypeSpecifier&lt;/code&gt;, or both, can be omitted. Thus, the following variants are allowed:</source>
          <target state="translated">&lt;code&gt;Size&lt;/code&gt; 또는 &lt;code&gt;TypeSpecifier&lt;/code&gt; , 또는 둘 모두를 생략 할 수있다. 따라서 다음과 같은 변형이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="4401af203194a6b8a2b7ece91e21c535b2bfb4cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Size&lt;/code&gt; part of the segment multiplied by the unit in &lt;code&gt;TypeSpecifierList&lt;/code&gt; (described later) gives the number of bits for the segment. In construction, &lt;code&gt;Size&lt;/code&gt; is any expression that evaluates to an integer. In matching, &lt;code&gt;Size&lt;/code&gt; must be a constant expression or a variable.</source>
          <target state="translated">세그먼트 의 &lt;code&gt;Size&lt;/code&gt; 부분에 &lt;code&gt;TypeSpecifierList&lt;/code&gt; 의 단위 (나중에 설명)를 곱한 값은 세그먼트 의 비트 수를 나타냅니다. 구성에서 &lt;code&gt;Size&lt;/code&gt; 는 정수로 평가되는 표현식입니다. 일치하는 &lt;code&gt;Size&lt;/code&gt; 는 상수 표현식 또는 변수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="fa124ccd13ea8b5e4811fb40dda4e89bf8e0ab6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Socket&lt;/code&gt; shall be in passive mode ({active, false}) before calling this function or else the behavior of this function is undefined.</source>
          <target state="translated">&lt;code&gt;Socket&lt;/code&gt; 정의되지이 함수 또는 다른 함수의 동작을 호출하기 전에 수동 모드 ({활성 거짓})로한다.</target>
        </trans-unit>
        <trans-unit id="71d2c0146fa0a8ad0d23a9f16dafb29d093033b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;State0&lt;/code&gt; is the State value originally from a MAC init function, that is &lt;code&gt;&lt;a href=&quot;#mac_init-2&quot;&gt;mac_init/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#mac_init-3&quot;&gt;mac_init/3&lt;/a&gt;&lt;/code&gt; or a previous call of &lt;code&gt;mac_update/2&lt;/code&gt;. The value &lt;code&gt;State0&lt;/code&gt; is returned unchanged by the function as &lt;code&gt;State&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;State0&lt;/code&gt; 이다 원래 MAC 초기화 기능의 상태 값이다 &lt;code&gt;&lt;a href=&quot;#mac_init-2&quot;&gt;mac_init/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#mac_init-3&quot;&gt;mac_init/3&lt;/a&gt;&lt;/code&gt; 또는 이전 통화 &lt;code&gt;mac_update/2&lt;/code&gt; . &lt;code&gt;State0&lt;/code&gt; 값 은 &lt;code&gt;State&lt;/code&gt; 로 함수에 의해 변경되지 않고 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a112d3244fe07cff9e8f015a14975b38bd7df44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StatisticsSpec&lt;/code&gt; is a list of the tuples:</source>
          <target state="translated">&lt;code&gt;StatisticsSpec&lt;/code&gt; 는 튜플의 목록입니다 :</target>
        </trans-unit>
        <trans-unit id="7eae7e5127eb1df08b89e0018b0917cb18f30c43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SupFlags&lt;/code&gt; variable in the return value from &lt;code&gt;init/1&lt;/code&gt; represents the &lt;code&gt;&lt;a href=&quot;#flags&quot;&gt;supervisor flags&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SupFlags&lt;/code&gt; 의 반환 값에 변수 &lt;code&gt;init/1&lt;/code&gt; 대표 &lt;code&gt;&lt;a href=&quot;#flags&quot;&gt;supervisor flags&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b2315a984f49c0998e8d5af6001ef3acd45c41f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TEST&lt;/code&gt; macro can also be used to override the &lt;code&gt;NOTEST&lt;/code&gt; macro. If &lt;code&gt;TEST&lt;/code&gt; is defined &lt;strong&gt;before&lt;/strong&gt; the EUnit header file is included (even if &lt;code&gt;NOTEST&lt;/code&gt; is also defined), then the code will be compiled with EUnit enabled.</source>
          <target state="translated">&lt;code&gt;TEST&lt;/code&gt; 매크로도 무시할 수 있습니다 &lt;code&gt;NOTEST&lt;/code&gt; 매크로. 경우 &lt;code&gt;TEST&lt;/code&gt; 가 정의 &lt;strong&gt;되기 전에&lt;/strong&gt; EUNIT 헤더 파일이 포함되어 있습니다 (경우에도 &lt;code&gt;NOTEST&lt;/code&gt; 이 또한 정의), 다음 코드를 사용할 수 EUNIT로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="838665ed4c5367a2b5c2a4be4ad60949587a0665" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TarDescriptor&lt;/code&gt; term is not a file descriptor. You are advised not to rely on the specific contents of this term, as it can change in future Erlang/OTP releases when more features are added to this module.</source>
          <target state="translated">&lt;code&gt;TarDescriptor&lt;/code&gt; 의 용어는 파일 기술자가 아니다. 이 모듈에 더 많은 기능이 추가되면 향후 Erlang / OTP 릴리스에서 변경 될 수 있으므로이 용어의 특정 내용에 의존하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="465bc37c25caf4b34efb2c4086ab264294ebb922" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TarDescriptor&lt;/code&gt; term is not a file descriptor. You are advised not to rely on the specific contents of this term, as it can change in future Erlang/OTP releases when more features are added to this module..</source>
          <target state="translated">&lt;code&gt;TarDescriptor&lt;/code&gt; 의 용어는 파일 기술자가 아니다. 이 모듈에 더 많은 기능이 추가되면 향후 Erlang / OTP 릴리스에서 변경 될 수 있으므로이 용어의 특정 내용에 의존하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0454f0125983aa193be8922f905a4526ad0af9b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Timeout&lt;/code&gt; is the time the request is valid. The value has to be greater then zero.</source>
          <target state="translated">&lt;code&gt;Timeout&lt;/code&gt; 요청이 유효한 시간입니다. 값은 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="7d17ac7ee8e9756a5bbf3de834214c031df9a61a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Timeout&lt;/code&gt; parameter is for the actual tls upgrade (phase 2) while the timeout in &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;eldap:open/2&lt;/a&gt;&lt;/code&gt; is used for the initial negotiation about upgrade (phase 1).</source>
          <target state="translated">&lt;code&gt;Timeout&lt;/code&gt; 실제 TLS가 시간 초과 동안 (단계 2) 업그레이드를위한 파라미터는 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;eldap:open/2&lt;/a&gt;&lt;/code&gt; 업그레이드 (단계 1)에 대한 초기 협상에 이용된다.</target>
        </trans-unit>
        <trans-unit id="2880ac4f009b868dac04469b39959fc855b2bc2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Timeout&lt;/code&gt; value in milliseconds sets an upper time limit for all &lt;code&gt;call&lt;/code&gt; operations to complete.</source>
          <target state="translated">&lt;code&gt;Timeout&lt;/code&gt; (밀리 초) 값은 모두 상위 시간 제한 설정 &lt;code&gt;call&lt;/code&gt; 을 완료하려면 작업을.</target>
        </trans-unit>
        <trans-unit id="7e76487200ab118ffd183bce3e76d073d0b42eca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Trace Pattern&lt;/code&gt; is basically a tuple of a &lt;code&gt;module&lt;/code&gt; and a &lt;code&gt;detail level&lt;/code&gt; (either an integer or the atom max for full detail). In most cases the &lt;code&gt;Trace Pattern&lt;/code&gt;&lt;code&gt;{et,max}&lt;/code&gt; does suffice. But if you do not want any runtime dependency of &lt;code&gt;et&lt;/code&gt; you can implement your own &lt;code&gt;trace_me/5&lt;/code&gt; function in some module and refer to that module in the &lt;code&gt;Trace Pattern&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Trace Pattern&lt;/code&gt; 기본적의 튜플 &lt;code&gt;module&lt;/code&gt; 및 &lt;code&gt;detail level&lt;/code&gt; (정수 또는 전체 디테일 원자 중 최대). 대부분의 경우 &lt;code&gt;Trace Pattern&lt;/code&gt; &lt;code&gt;{et,max}&lt;/code&gt; 로 충분합니다. 그러나 &lt;code&gt;et&lt;/code&gt; 의 런타임 종속성을 원하지 않으면 일부 모듈에서 자체 &lt;code&gt;trace_me/5&lt;/code&gt; 함수를 구현 하고 해당 &lt;code&gt;Trace Pattern&lt;/code&gt; 에서 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7f49e5bd7c0b07a911f5147dffd68a5a99e4dbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TraceStartOption&lt;/code&gt; is any option allowed for &lt;code&gt;trace/1&lt;/code&gt;. The options &lt;code&gt;[start, {procs, [self() | PidList]} | OptList]&lt;/code&gt; are given to &lt;code&gt;trace/1&lt;/code&gt;, where &lt;code&gt;OptList&lt;/code&gt; is &lt;code&gt;OptionList&lt;/code&gt; with &lt;code&gt;continue&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;{procs, _}&lt;/code&gt; options removed.</source>
          <target state="translated">&lt;code&gt;TraceStartOption&lt;/code&gt; 은 허용 모든 옵션 &lt;code&gt;trace/1&lt;/code&gt; . 옵션 &lt;code&gt;[start, {procs, [self() | PidList]} | OptList]&lt;/code&gt; 는 &lt;code&gt;trace/1&lt;/code&gt; 에 제공되며, 여기서 &lt;code&gt;OptList&lt;/code&gt; 는 &lt;code&gt;continue&lt;/code&gt; , &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;{procs, _}&lt;/code&gt; 옵션이 제거 된 &lt;code&gt;OptionList&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="d2aed641ea18d80129eeabfddfeb6dc4dea97713" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TraceTag&lt;/code&gt;&lt;code&gt;seq_trace&lt;/code&gt; is handled slightly differently. There is no &lt;code&gt;Tracee&lt;/code&gt; for &lt;code&gt;seq_trace&lt;/code&gt;, instead the &lt;code&gt;Label&lt;/code&gt; associated with the &lt;code&gt;seq_trace&lt;/code&gt; event is specified.</source>
          <target state="translated">&lt;code&gt;TraceTag&lt;/code&gt; 의 &lt;code&gt;seq_trace&lt;/code&gt; 는 약간 다르게 처리됩니다. &lt;code&gt;seq_trace&lt;/code&gt; 에 대한 &lt;code&gt;Tracee&lt;/code&gt; 가 없으며 &lt;code&gt;seq_trace&lt;/code&gt; 이벤트 와 연관된 &lt;code&gt;Label&lt;/code&gt; 이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="0e7aee8b9587689f8640e087123cb9269b76c67d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TypeSpecifierList&lt;/code&gt; is a list of type specifiers separated by hyphens.</source>
          <target state="translated">&lt;code&gt;TypeSpecifierList&lt;/code&gt; 은 하이픈으로 구분 타입 지시자의 목록이다.</target>
        </trans-unit>
        <trans-unit id="cf30b67e2b9d6eefe96e2a44b56b701c3a71843b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Value&lt;/code&gt; part is any expression, when used in binary construction. Used in binary matching, the &lt;code&gt;Value&lt;/code&gt; part must be a literal or a variable. For more information about the &lt;code&gt;Value&lt;/code&gt; part, see &lt;code&gt;&lt;a href=&quot;#Constructing%20Binaries%20and%20Bitstrings&quot;&gt;Constructing Binaries and Bitstrings&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Matching%20Binaries&quot;&gt;Matching Binaries&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Value&lt;/code&gt; 진 건설에 사용하면 부분은 어떤 식입니다. 이진 일치에 사용되는 &lt;code&gt;Value&lt;/code&gt; 부분은 리터럴 또는 변수 여야합니다. &lt;code&gt;Value&lt;/code&gt; 부분 에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#Constructing%20Binaries%20and%20Bitstrings&quot;&gt;Constructing Binaries and Bitstrings&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#Matching%20Binaries&quot;&gt;Matching Binaries&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="db41e1083994609150ba03a58467ce1564f93559" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Viewer&lt;/code&gt; will automatically pull events from the &lt;code&gt;Collector&lt;/code&gt; and display them on the screen.</source>
          <target state="translated">&lt;code&gt;Viewer&lt;/code&gt; 자동으로 이벤트를 끌어 &lt;code&gt;Collector&lt;/code&gt; 하고 화면에 표시.</target>
        </trans-unit>
        <trans-unit id="8afb3e18be8e7e2fb56c7adc4a8999ad88a05635" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Viewer&lt;/code&gt; will by default create a &lt;code&gt;Collector&lt;/code&gt; for you. With a few options and some configuration settings you can start collecting &lt;code&gt;Events&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Viewer&lt;/code&gt; 기본적으로 생성됩니다 &lt;code&gt;Collector&lt;/code&gt; 당신을 위해. 몇 가지 옵션과 일부 구성 설정으로 &lt;code&gt;Events&lt;/code&gt; 수집을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12a1a53435b86d328cae136152477d1bdb078001" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;XXL&lt;/code&gt; operator is defined for the interpretation of any of the LineOp operators applied to a set of function calls. The result is that of replacing the function call with a line numbered function call, that is, each of the two functions of the call is replaced by a pair of the function and the line where the function is defined. The effect of the &lt;code&gt;XXL&lt;/code&gt; operator can be undone by the LineOp operators. For instance, &lt;code&gt;(Lin)&amp;nbsp;(XXL)&amp;nbsp;(Lin)&amp;nbsp;E&lt;/code&gt; is equivalent to &lt;code&gt;(Lin)&amp;nbsp;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;XXL&lt;/code&gt; 연산자는 함수 호출들의 세트에인가 LineOp 사업자 임의의 해석에 대해 정의된다. 그 결과 함수 호출을 행 번호가 매겨진 함수 호출로 교체 한 것입니다. 즉, 호출의 두 함수 각각은 함수 쌍과 함수가 정의 된 행으로 대체됩니다. LineOp 연산자 는 &lt;code&gt;XXL&lt;/code&gt; 연산자 의 효과를 취소 할 수 있습니다. 예를 들어, &lt;code&gt;(Lin)&amp;nbsp;(XXL)&amp;nbsp;(Lin)&amp;nbsp;E&lt;/code&gt; 동일하다 &lt;code&gt;(Lin)&amp;nbsp;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="773f8eacbf90d517d7610d94842c0bab01a3934c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ZipHandle&lt;/code&gt; is closed if the process that originally opened the archive dies.</source>
          <target state="translated">&lt;code&gt;ZipHandle&lt;/code&gt; 는 과정 원래 아카이브 다이를 열었다 경우 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="557e22236c78cd7d079417146126bba5baaa6036" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[&amp;lt;&amp;lt;&quot;First bytes&quot;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;&quot;Second bytes&quot;&amp;gt;&amp;gt;]&lt;/code&gt; could of course have been one single binary: &lt;code&gt;&amp;lt;&amp;lt;&quot;First bytesSecond bytes&quot;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">물론 &lt;code&gt;[&amp;lt;&amp;lt;&quot;First bytes&quot;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;&quot;Second bytes&quot;&amp;gt;&amp;gt;]&lt;/code&gt; 는 하나의 단일 바이너리 일 수 있습니다 : &lt;code&gt;&amp;lt;&amp;lt;&quot;First bytesSecond bytes&quot;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a10f4396b335e787b9182ce75a8ccae749ae857" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_test&lt;/code&gt; macro takes any expression (the &quot;body&quot;) as argument, and places it within a fun-expression (along with some extra information). The body can be any kind of test expression, just like the body of a simple test function.</source>
          <target state="translated">&lt;code&gt;_test&lt;/code&gt; 매크로는 인자로 표현식 (이하 &quot;몸&quot;)를 취하고, (몇 가지 추가 정보와 함께) 재미있는 표현 내에 배치합니다. 본문은 간단한 테스트 함수의 본문과 마찬가지로 모든 종류의 테스트 표현이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21e2f2fedc48b32638d6fb2b72fe74559f091a86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;accept&lt;/code&gt; call does &lt;strong&gt;not&lt;/strong&gt; have to be issued from the socket owner process. Using version 5.5.3 and higher of the emulator, multiple simultaneous accept calls can be issued from different processes, which allows for a pool of acceptor processes handling incoming connections.</source>
          <target state="translated">&lt;code&gt;accept&lt;/code&gt; 호출 않습니다 &lt;strong&gt;되지&lt;/strong&gt; 소켓 소유자 과정에서 발행되어야한다. 버전 5.5.3 이상의 에뮬레이터를 사용하면 여러 프로세스에서 여러 동시 수락 호출을 발행 할 수 있으므로 들어오는 연결을 처리하는 수락 자 프로세스 풀이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="118d34eb87604b965b95931c52d7927f1d1dca61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;addr&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; arguments are both input and output arguments. When called &lt;code&gt;addr&lt;/code&gt; points to an address structure of lenght &lt;code&gt;*len&lt;/code&gt; containing information on how to bind the socket. Uppon return this callback should have updated the structure referred by &lt;code&gt;addr&lt;/code&gt; with information on how the socket actually was bound. &lt;code&gt;*len&lt;/code&gt; should be updated to reflect the size of &lt;code&gt;*addr&lt;/code&gt; updated. &lt;code&gt;backlog&lt;/code&gt; identifies the size of the backlog for the listen socket.</source>
          <target state="translated">&lt;code&gt;addr&lt;/code&gt; 과 &lt;code&gt;len&lt;/code&gt; 인수는 입력 및 출력 인자이다. 호출 될 때 &lt;code&gt;addr&lt;/code&gt; 는 소켓을 바인딩하는 방법에 대한 정보를 포함하는 lenght &lt;code&gt;*len&lt;/code&gt; 의 주소 구조를 가리 킵니다 . Uppon return이 콜백은 소켓이 실제로 바인딩 된 방법에 대한 정보 로 &lt;code&gt;addr&lt;/code&gt; 가 참조하는 구조를 업데이트해야합니다 . &lt;code&gt;*len&lt;/code&gt; 은 업데이트 된 &lt;code&gt;*addr&lt;/code&gt; 의 크기를 반영하도록 업데이트되어야합니다 . &lt;code&gt;backlog&lt;/code&gt; 는 청취 소켓의 백 로그 크기를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="d5a0f81704a04cf2f958a3cb5b26d7a07f57fb43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;addr&lt;/code&gt; argument of the &lt;code&gt;listen&lt;/code&gt;, &lt;code&gt;accept&lt;/code&gt;, and &lt;code&gt;connect&lt;/code&gt; callbacks refer to appropriate address structure for currently used protocol. Currently &lt;code&gt;ei&lt;/code&gt; only supports IPv4. That is, at this time &lt;code&gt;addr&lt;/code&gt; always points to a &lt;code&gt;struct sockaddr_in&lt;/code&gt; structure.</source>
          <target state="translated">&lt;code&gt;listen&lt;/code&gt; , &lt;code&gt;accept&lt;/code&gt; 및 &lt;code&gt;connect&lt;/code&gt; 콜백 의 &lt;code&gt;addr&lt;/code&gt; 인수는 현재 사용되는 프로토콜에 대한 적절한 주소 구조를 참조합니다. 현재 &lt;code&gt;ei&lt;/code&gt; 는 IPv4 만 지원합니다. 즉, 이때 &lt;code&gt;addr&lt;/code&gt; 은 항상 &lt;code&gt;struct sockaddr_in&lt;/code&gt; 구조를 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="b97c48085c09e86337df00a4b0a18e9e9f983484" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;apread/4&lt;/code&gt; function reads from a specified position, combining the &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#aread-3&quot;&gt;aread/3&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;apread/4&lt;/code&gt; 의 함수를 조합 한, 소정 위치로부터 판독 &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#aread-3&quot;&gt;aread/3&lt;/a&gt;&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="6e1ba830557bf0975fcfe18ee483f0f3bec5d278" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;apwrite/4&lt;/code&gt; function writes to a specified position, combining the &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#awrite-3&quot;&gt;awrite/3&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;apwrite/4&lt;/code&gt; 의 함수를 조합 한, 소정 위치에 기록 &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#awrite-3&quot;&gt;awrite/3&lt;/a&gt;&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="00d3c3634428cbc77b5aceea9f983ec649758967" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert&lt;/code&gt; macro can be used anywhere in a program, not just in unit tests, to check pre/postconditions and invariants. For example:</source>
          <target state="translated">&lt;code&gt;assert&lt;/code&gt; 매크로는 사전 / 사후 및 불변을 확인뿐만 아니라 단위 테스트에서 프로그램에 사용 어디서나 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="108ceadd98496de12d8902f0058bac96f4aa9204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async_data&lt;/code&gt; is passed to the &lt;code&gt;do_perm&lt;/code&gt; function. We do not use a &lt;code&gt;async_free&lt;/code&gt; function (the last argument to &lt;code&gt;driver_async&lt;/code&gt;), it is only used if the task is cancelled programmatically.</source>
          <target state="translated">&lt;code&gt;async_data&lt;/code&gt; 은 받는 사람 전달 &lt;code&gt;do_perm&lt;/code&gt; 의 기능. &lt;code&gt;async_free&lt;/code&gt; 함수 ( &lt;code&gt;driver_async&lt;/code&gt; 의 마지막 인수 ) 는 사용하지 않으며 , 프로그래밍 방식으로 작업이 취소 된 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4cd04a38dd6fcdc2cd251ae665b899f10977e42f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async_data&lt;/code&gt; is the argument to the functions &lt;code&gt;async_invoke&lt;/code&gt; and &lt;code&gt;async_free&lt;/code&gt;. It is typically a pointer to a structure containing a pipe or event that can be used to signal that the async operation completed. The data is to be freed in &lt;code&gt;async_free&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;async_data&lt;/code&gt; 는 기능에 대한 인수입니다 &lt;code&gt;async_invoke&lt;/code&gt; 및 &lt;code&gt;async_free&lt;/code&gt; . 일반적으로 비동기 작업이 완료되었음을 알리는 데 사용할 수있는 파이프 또는 이벤트를 포함하는 구조에 대한 포인터입니다. 데이터는 &lt;code&gt;async_free&lt;/code&gt; 에 해제됩니다 .</target>
        </trans-unit>
        <trans-unit id="10c62ebaa7dc721acc77acfe725a467db8e1f296" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;atom()&lt;/code&gt; value is formed from the sftp error codes in the protocol-level responses as defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-secsh-filexfer-13#page-49&quot;&gt;draft-ietf-secsh-filexfer-13&lt;/a&gt;&lt;/code&gt; section 9.1. The codes are named as &lt;code&gt;SSH_FX_*&lt;/code&gt; which are transformed into lowercase of the star-part. E.g. the error code &lt;code&gt;SSH_FX_NO_SUCH_FILE&lt;/code&gt; will cause the &lt;code&gt;reason()&lt;/code&gt; to be &lt;code&gt;no_such_file&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;atom()&lt;/code&gt; 에서 정의 된 값은 프로토콜 수준에 대응 SFTP 오류 코드로 형성된다 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-secsh-filexfer-13#page-49&quot;&gt;draft-ietf-secsh-filexfer-13&lt;/a&gt;&lt;/code&gt; 9.1. 코드 이름은 &lt;code&gt;SSH_FX_*&lt;/code&gt; 로 지정되며 별표 부분의 소문자로 변환됩니다. 예를 들어 오류 코드 &lt;code&gt;SSH_FX_NO_SUCH_FILE&lt;/code&gt; 로 인해 &lt;code&gt;reason()&lt;/code&gt; 이 &lt;code&gt;no_such_file&lt;/code&gt; 이 됩니다.</target>
        </trans-unit>
        <trans-unit id="61c5f2724e8a89f933cb80bf3b2eb6cc8b3b6977" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;avg1/0&lt;/code&gt;, &lt;code&gt;avg5/0&lt;/code&gt;, and &lt;code&gt;avg15/0&lt;/code&gt; functions can be used for retrieving system load values, and the &lt;code&gt;util/0&lt;/code&gt; and &lt;code&gt;util/1&lt;/code&gt; functions can be used for retrieving CPU utilization values.</source>
          <target state="translated">&lt;code&gt;avg1/0&lt;/code&gt; , &lt;code&gt;avg5/0&lt;/code&gt; 및 &lt;code&gt;avg15/0&lt;/code&gt; 함수는 시스템 부하 값을 검색에 이용 될 수 &lt;code&gt;util/0&lt;/code&gt; 및 &lt;code&gt;util/1&lt;/code&gt; 기능은 CPU 사용률 값을 검색하는 데 사용된다.</target>
        </trans-unit>
        <trans-unit id="a43d2dcf5e0e967eda5efa53bd70665dc5d59efa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;blog()&lt;/code&gt; functions can also be used for internally formatted logs, but in this case they must be called with binaries constructed with calls to &lt;code&gt;term_to_binary/1&lt;/code&gt;. There is no check to ensure this, it is entirely the responsibility of the caller. If these functions are called with binaries that do not correspond to Erlang terms, the &lt;code&gt;&lt;a href=&quot;#chunk-2&quot;&gt;chunk/2,3&lt;/a&gt;&lt;/code&gt; and automatic repair functions fail. The corresponding terms (not the binaries) are returned when &lt;code&gt;chunk/2,3&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;blog()&lt;/code&gt; 함수는 내부적으로 포맷 된 로그를 사용할 수 있지만,이 경우 그들은 호출로 구성 바이너리로 호출 할 필요가 &lt;code&gt;term_to_binary/1&lt;/code&gt; . 이를 확인하기위한 점검은 없으며, 전적으로 호출자의 책임입니다. Erlang 용어와 일치하지 않는 이진으로 이러한 함수를 호출하면 &lt;code&gt;&lt;a href=&quot;#chunk-2&quot;&gt;chunk/2,3&lt;/a&gt;&lt;/code&gt; 및 자동 복구 기능이 실패합니다. &lt;code&gt;chunk/2,3&lt;/code&gt; 을 호출 하면 해당 항 (2 진이 아님)이 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="c6a9390501bbca6818af22e2d682ca803f60bdab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;c&lt;/code&gt; operand can encode any literal value, including NIL. The &lt;code&gt;n&lt;/code&gt; operand only works for NIL. If we have the generic instruction &lt;code&gt;{move,nil,{x,1}}&lt;/code&gt;, the loader will translate it to &lt;code&gt;move_nx 1&lt;/code&gt; because &lt;code&gt;move n x&lt;/code&gt; is more specific. &lt;code&gt;move_nx&lt;/code&gt; could be slightly faster or smaller (depending on the architecture), because the &lt;code&gt;[]&lt;/code&gt; is not stored explicitly as an operand.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 피연산자는 NIL 포함 리터럴 값을 인코딩 할 수있다. &lt;code&gt;n&lt;/code&gt; 개의 피연산자는 NIL 작동합니다. 일반 명령어 &lt;code&gt;{move,nil,{x,1}}&lt;/code&gt; 이있는 경우 , &lt;code&gt;move n x&lt;/code&gt; 가 더 구체적 이기 때문에 로더가이를 &lt;code&gt;move_nx 1&lt;/code&gt; 로 변환합니다 . &lt;code&gt;[]&lt;/code&gt; 는 피연산자로 명시 적으로 저장되지 않기 때문에 &lt;code&gt;move_nx&lt;/code&gt; 는 약간 더 빠르거나 더 작을 수 있습니다 (아키텍처에 따라 다름) .</target>
        </trans-unit>
        <trans-unit id="9287c794d6838f0d9c560c6cf16a390d870948c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call()&lt;/code&gt; function only returns if the applied function successfully returned without raising any uncaught exceptions, the operation did not time out, and no failures occurred. In all other cases an exception is raised. The following exceptions, listed by exception class, can currently be raised by &lt;code&gt;erpc:call()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;call()&lt;/code&gt; 적용된 기능이 성공적으로 어떤 캐치되지 않는 예외를 발생시키지 않고 반환하는 경우 함수는 반환 작업이 시간 초과하지 않았다, 어떤 오류가 발생하지 않았다. 다른 모든 경우에는 예외가 발생합니다. 예외 클래스별로 나열된 다음 예외는 현재 &lt;code&gt;erpc:call()&lt;/code&gt; 의해 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="725661331a506e2dce5360076476c39f4c67eeff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call&lt;/code&gt; operation for this specific node raised an exception of class &lt;code&gt;Class&lt;/code&gt; with exception reason &lt;code&gt;ExceptionReason&lt;/code&gt;. These corresponds the the exceptions that &lt;code&gt;&lt;a href=&quot;#call-5&quot;&gt;erpc:call/5&lt;/a&gt;&lt;/code&gt; can raise.</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; 이 특정 노드에 대한 작업은 클래스의 예외가 제기 &lt;code&gt;Class&lt;/code&gt; 예외 이유 &lt;code&gt;ExceptionReason&lt;/code&gt; 을 . 이는 &lt;code&gt;&lt;a href=&quot;#call-5&quot;&gt;erpc:call/5&lt;/a&gt;&lt;/code&gt; 에서 발생할 수 있는 예외에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="3190218027bddfcb10c66d83569c4e030fe8e281" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call&lt;/code&gt; operation for this specific node returned &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; 이 특정 노드에 대한 작업이 반환 &lt;code&gt;Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20c4b6b511dd79e662208e902c57d062a8c73aa4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call_ext&lt;/code&gt; instruction can be used to call functions written in Erlang as well as BIFs (or more properly called SNIFs). The &lt;code&gt;u$is_bif&lt;/code&gt; constraint will match if the operand refers to a BIF (that is, if it is listed in the file &lt;code&gt;bif.tab&lt;/code&gt;). Note that &lt;code&gt;u$is_bif&lt;/code&gt; should only be applied to operands that are known to contain an index to the import table chunk in the BEAM file (such operands have the type &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;e&lt;/code&gt; in the corresponding specific instruction). If applied to other &lt;code&gt;u&lt;/code&gt; operands, it will at best return a nonsense result.</source>
          <target state="translated">&lt;code&gt;call_ext&lt;/code&gt; 의 명령은 얼랑뿐만 아니라 BIFS (이상 제대로이라고 SNIFs)를 작성 호출 기능을 사용할 수 있습니다. &lt;code&gt;u$is_bif&lt;/code&gt; 피연산자가 (이 파일에 나열되어있는 경우, 인 BIF을 참조하는 경우 제약 조건이 일치 &lt;code&gt;bif.tab&lt;/code&gt; ). 유의 &lt;code&gt;u$is_bif&lt;/code&gt; 만 BEAM 파일의 임포트 테이블 청크에 대한 인덱스 (예 피연산자 타입이 포함 알려진 피연산자에 적용되어야 &lt;code&gt;b&lt;/code&gt; 또는 &lt;code&gt;e&lt;/code&gt; 해당 특정 지시하여). 다른 &lt;code&gt;u&lt;/code&gt; 피연산자에 적용하면 기껏해야 말도 안되는 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="37d74f76daa8e51f123951ddaf373680517fc012" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;channel_callback&lt;/code&gt; is the module that implements the &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; (replaces ssh_daemon_channel) behaviour in the daemon. See the section &lt;code&gt;&lt;a href=&quot;using_ssh#usersguide_creating_a_subsystem&quot;&gt;Creating a Subsystem&lt;/a&gt;&lt;/code&gt; in the User's Guide for more information and an example.</source>
          <target state="translated">&lt;code&gt;channel_callback&lt;/code&gt; 는 모듈입니다 구현하는 &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; 데몬에서 (을 대체의 ssh_daemon_channel) 행동. 자세한 정보와 예제는 사용자 안내서에서 &lt;code&gt;&lt;a href=&quot;using_ssh#usersguide_creating_a_subsystem&quot;&gt;Creating a Subsystem&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8493f2b264f76e709a289fe048f59895e05cdc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chmod&lt;/code&gt; above makes the &lt;code&gt;.erlang.cookie&lt;/code&gt; file accessible only by the owner of the file. This is a requirement.</source>
          <target state="translated">위 의 &lt;code&gt;chmod&lt;/code&gt; 는 &lt;code&gt;.erlang.cookie&lt;/code&gt; 파일을 파일 소유자 만 액세스 할 수있게합니다. 이것은 요구 사항입니다.</target>
        </trans-unit>
        <trans-unit id="067ed8257f3ed48d1dd77d1c82e5f73c03791be2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;client_directory&lt;/code&gt; in the directory structure of the master nodes must be specified.</source>
          <target state="translated">&lt;code&gt;client_directory&lt;/code&gt; 마스터 노드의 디렉토리 구조를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="97ad2677bec8a2ec1b2eaf275491aa26823e6cdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;clients&lt;/code&gt; directory is to have one subdirectory per supported client node. The name of each client directory is to be the name of the corresponding client node. As a minimum, each client directory is to contain the &lt;code&gt;bin&lt;/code&gt; and &lt;code&gt;releases&lt;/code&gt; subdirectories. These directories are used to store information about installed releases and to appoint the current release to the client. The &lt;code&gt;$ROOT&lt;/code&gt; directory thus contains the following:</source>
          <target state="translated">&lt;code&gt;clients&lt;/code&gt; 디렉토리는 지원되는 클라이언트 노드 당 하나 개의 하위 디렉토리를하는 것입니다. 각 클라이언트 디렉토리의 이름은 해당 클라이언트 노드의 이름입니다. 최소한 각 클라이언트 디렉토리는 포함하는 &lt;code&gt;bin&lt;/code&gt; 과 &lt;code&gt;releases&lt;/code&gt; 하위 디렉토리를. 이 디렉토리는 설치된 릴리스에 대한 정보를 저장하고 현재 릴리스를 클라이언트에 지정하는 데 사용됩니다. 따라서 &lt;code&gt;$ROOT&lt;/code&gt; 디렉토리에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fef0ac1b98cce64ffd1d82b4509565a3e18b84ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;code_change&lt;/code&gt; method must also be implemented.</source>
          <target state="translated">&lt;code&gt;code_change&lt;/code&gt; 의 방법은 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="dfba9577e3cba70bb212c1548338d8d33c8f09a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combined&lt;/code&gt; format is one line looking like this: &lt;code&gt;remotehost rfc931 authuser [date] &quot;request&quot; status bytes &quot;referer&quot; &quot;user_agent&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;combined&lt;/code&gt; 형식은 다음 과 같은 한 줄입니다. &lt;code&gt;remotehost rfc931 authuser [date] &quot;request&quot; status bytes &quot;referer&quot; &quot;user_agent&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="630925a2786b7b59d8f4c833942afd22d020f670" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compatibility_only_hash()&lt;/code&gt; algorithms are recommended only for compatibility with existing applications.</source>
          <target state="translated">&lt;code&gt;compatibility_only_hash()&lt;/code&gt; 알고리즘은 기존 응용 프로그램과의 호환성을 위해 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="1b60f349fe6a82d8f3ab2d525a727ef964290939" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;complex&lt;/code&gt; process does the following:</source>
          <target state="translated">&lt;code&gt;complex&lt;/code&gt; 프로세스는 다음과 같은 작업을 수행합니다</target>
        </trans-unit>
        <trans-unit id="ceca332ed5fece3a22bbc2b65250bbdfb9575097" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;complex&lt;/code&gt; process performs the following:</source>
          <target state="translated">&lt;code&gt;complex&lt;/code&gt; 프로세스는 다음을 수행합니다 :</target>
        </trans-unit>
        <trans-unit id="0e88a24bce8d7b2a409cde6bc42dab540256c0b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compressed&lt;/code&gt; and &lt;code&gt;cooked&lt;/code&gt; flags are invalid when passing a file descriptor with &lt;code&gt;{file,Fd}&lt;/code&gt;. The file is assumed to have been opened with the appropriate flags.</source>
          <target state="translated">&lt;code&gt;compressed&lt;/code&gt; 및 &lt;code&gt;cooked&lt;/code&gt; 에 파일 기술자를 전달할 때 플래그가 잘못 &lt;code&gt;{file,Fd}&lt;/code&gt; . 파일은 적절한 플래그로 열린 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="45da19705e860c5554e30ca96214a35258f720dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compressed&lt;/code&gt; and &lt;code&gt;cooked&lt;/code&gt; flags are invalid when passing a file descriptor with &lt;code&gt;{file,Fd}&lt;/code&gt;. The file must already be opened with the appropriate flags.</source>
          <target state="translated">&lt;code&gt;compressed&lt;/code&gt; 및 &lt;code&gt;cooked&lt;/code&gt; 에 파일 기술자를 전달할 때 플래그가 잘못 &lt;code&gt;{file,Fd}&lt;/code&gt; . 적절한 플래그를 사용하여 파일이 이미 열려 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3748b6dda37726d1886cb8a28dacde2fa7798fe9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;config&lt;/code&gt; macro is defined in &lt;code&gt;ct.hrl&lt;/code&gt;. This macro is to be used to retrieve information from the &lt;code&gt;Config&lt;/code&gt; variable sent to all test cases. It is used with two arguments; the first is the name of the configuration variable to retrieve, the second is the &lt;code&gt;Config&lt;/code&gt; variable supplied to the test case.</source>
          <target state="translated">&lt;code&gt;config&lt;/code&gt; 매크로에 정의되어 &lt;code&gt;ct.hrl&lt;/code&gt; . 이 매크로는 모든 테스트 사례로 전송 된 &lt;code&gt;Config&lt;/code&gt; 변수 에서 정보를 검색하는 데 사용됩니다 . 두 개의 인수와 함께 사용됩니다. 첫 번째는 검색 할 구성 변수의 이름이고 두 번째는 테스트 케이스에 제공된 &lt;code&gt;Config&lt;/code&gt; 변수입니다.</target>
        </trans-unit>
        <trans-unit id="3402fd646c2b066512d58aeec8dd8cb2dfa256aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;configure&lt;/code&gt; script will issue a warning when a default value is used. When a variable has been set, no warning will be issued.</source>
          <target state="translated">&lt;code&gt;configure&lt;/code&gt; 기본값을 사용하는 경우 스크립트는 경고를 발행합니다. 변수가 설정되면 경고가 발행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6288c90b6c5e2f3d2b468cb02b51d6affc24bf92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;configure&lt;/code&gt; scripts are generated by invoking &lt;code&gt;./otp_build autoconf&lt;/code&gt; in the &lt;code&gt;$ERL_TOP&lt;/code&gt; directory. The &lt;code&gt;configure&lt;/code&gt; scripts also have to be regenerated when a &lt;code&gt;configure.in&lt;/code&gt; or &lt;code&gt;aclocal.m4&lt;/code&gt; file has been modified. Note that when checking out a branch a &lt;code&gt;configure.in&lt;/code&gt; or &lt;code&gt;aclocal.m4&lt;/code&gt; file may change content, and you may therefore have to regenerate the &lt;code&gt;configure&lt;/code&gt; scripts when checking out a branch. Regenerated &lt;code&gt;configure&lt;/code&gt; scripts imply that you have to run &lt;code&gt;configure&lt;/code&gt; and build again.</source>
          <target state="translated">&lt;code&gt;configure&lt;/code&gt; 스크립트 호출에 의해 생성되는 &lt;code&gt;./otp_build autoconf&lt;/code&gt; 에 &lt;code&gt;$ERL_TOP&lt;/code&gt; 디렉토리. &lt;code&gt;configure&lt;/code&gt; 스크립트는 또한 때 다시 생성 할 필요가 &lt;code&gt;configure.in&lt;/code&gt; 또는 &lt;code&gt;aclocal.m4&lt;/code&gt; 의 파일이 수정되었습니다. 분기를 체크 아웃 할 때 &lt;code&gt;configure.in&lt;/code&gt; 또는 &lt;code&gt;aclocal.m4&lt;/code&gt; 파일이 내용을 변경할 수 있으므로 분기를 체크 아웃 할 때 &lt;code&gt;configure&lt;/code&gt; 스크립트 를 다시 생성해야 할 수도 있습니다 . 재생성 된 &lt;code&gt;configure&lt;/code&gt; 스크립트는 &lt;code&gt;configure&lt;/code&gt; 를 실행 하고 다시 빌드 해야 함을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="208c163b5d9b18adfd658c53d3afa3ceb105c168" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connect&lt;/code&gt; function looks a bit different too. We connect using the asynchronous &lt;code&gt;PQconnectStart&lt;/code&gt; function. After the connection is started, we retrieve the socket for the connection with &lt;code&gt;PQsocket&lt;/code&gt;. This socket is used with the &lt;code&gt;driver_select&lt;/code&gt; function to wait for connection. When the socket is ready for input or for output, the &lt;code&gt;ready_io&lt;/code&gt; function is called.</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; 기능도 조금 다른 보인다. 비동기 &lt;code&gt;PQconnectStart&lt;/code&gt; 기능을 사용하여 연결 합니다. 연결이 시작되면 &lt;code&gt;PQsocket&lt;/code&gt; 과의 연결을위한 소켓을 검색합니다 . 이 소켓은 &lt;code&gt;driver_select&lt;/code&gt; 함수 와 함께 사용하여 연결을 기다립니다. 소켓이 입력 또는 출력 준비가되면 &lt;code&gt;ready_io&lt;/code&gt; 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="72241940e6969f3882cb2063d805e933d9f13162" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;console&lt;/code&gt; option is &lt;strong&gt;not&lt;/strong&gt; intended for production. It is &lt;strong&gt;only&lt;/strong&gt; a convenient way to debug Erlang services during development.</source>
          <target state="translated">&lt;code&gt;console&lt;/code&gt; 옵션이되어 &lt;strong&gt;있지&lt;/strong&gt; 생산을위한 것. 그것은입니다 &lt;strong&gt;만&lt;/strong&gt; 개발하는 동안 얼랑 서비스를 디버깅 할 수있는 편리한 방법.</target>
        </trans-unit>
        <trans-unit id="09d03cd7b2afda946d29b4dfa4871ca45c957a3b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;content&lt;/code&gt; field of the top element is a list of records that shows the structure and data of the document. If it is a simple document like:</source>
          <target state="translated">상단 요소 의 &lt;code&gt;content&lt;/code&gt; 필드는 문서의 구조와 데이터를 보여주는 레코드 목록입니다. 다음과 같은 간단한 문서 인 경우 :</target>
        </trans-unit>
        <trans-unit id="838c0fd05d2d1deb4094b06de0e616a5af7c6e8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;continue&lt;/code&gt; option inhibits the call to &lt;code&gt;trace(stop)&lt;/code&gt; and leaves it up to the caller to stop tracing at a suitable time.</source>
          <target state="translated">는 &lt;code&gt;continue&lt;/code&gt; 옵션 억제를 호출 &lt;code&gt;trace(stop)&lt;/code&gt; 적절한 시간에 추적을 중지 발신자와 잎을 위로.</target>
        </trans-unit>
        <trans-unit id="5e5e4cf83680d9fc0726d1fa4e444a1ac9be072e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;control&lt;/code&gt; entry is called from the emulator when the Erlang code calls &lt;code&gt;port_control/3&lt;/code&gt;, to do the actual work. We have defined a simple set of commands: &lt;code&gt;connect&lt;/code&gt; to log in to the database, &lt;code&gt;disconnect&lt;/code&gt; to log out, and &lt;code&gt;select&lt;/code&gt; to send a SQL-query and get the result. All results are returned through &lt;code&gt;rbuf&lt;/code&gt;. The library &lt;code&gt;ei&lt;/code&gt; in &lt;code&gt;erl_interface&lt;/code&gt; is used to encode data in binary term format. The result is returned to the emulator as binary terms, so &lt;code&gt;binary_to_term&lt;/code&gt; is called in Erlang to convert the result to term form.</source>
          <target state="translated">&lt;code&gt;control&lt;/code&gt; 얼랭 코드를 호출 할 때 항목은 에뮬레이터에서 호출 &lt;code&gt;port_control/3&lt;/code&gt; 실제 작업을 수행. : 우리는 명령의 간단한 세트 정의 &lt;code&gt;connect&lt;/code&gt; 데이터베이스에 로그인 할 수 &lt;code&gt;disconnect&lt;/code&gt; 로그 아웃하고 &lt;code&gt;select&lt;/code&gt; 하여 SQL 쿼리를 전송하고 결과를 얻을 수 있습니다. 모든 결과는 &lt;code&gt;rbuf&lt;/code&gt; 를 통해 반환됩니다 . &lt;code&gt;erl_interface&lt;/code&gt; 의 라이브러리 &lt;code&gt;ei&lt;/code&gt; 는 이진 용어 형식으로 데이터를 인코딩하는 데 사용됩니다. 결과는 이진 용어로 에뮬레이터에 반환되므로 Erlang에서 &lt;code&gt;binary_to_term&lt;/code&gt; 을 호출하여 결과를 용어 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="26bab11093554a028ef86c3afb6f974cfc496b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;convert_to_c&lt;/code&gt; function is the same as before, but here it is used as a fun:</source>
          <target state="translated">&lt;code&gt;convert_to_c&lt;/code&gt; 기능은 이전과 동일하지만, 여기가 재미로 사용된다 :</target>
        </trans-unit>
        <trans-unit id="77c0725ecb5968616addeb9bf220dfefe059032f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cprof&lt;/code&gt; module is used to profile a program to find out how many times different functions are called. Breakpoints similar to local call trace, but containing a counter, are used to minimise runtime performance impact.</source>
          <target state="translated">&lt;code&gt;cprof&lt;/code&gt; 의 모듈은 다른 기능을 호출하는 방법을 여러 번 찾아 프로그램을 프로파일 링하는 데 사용됩니다. 로컬 호출 추적과 유사하지만 카운터를 포함하는 중단 점은 런타임 성능 영향을 최소화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9716455d32bb78ba694b642a2f677996c5c94a39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crypto&lt;/code&gt; mode option is applied to the generated stream of bytes prior to sending them to the SFTP server. This is intended for encryption but can be used for other purposes.</source>
          <target state="translated">&lt;code&gt;crypto&lt;/code&gt; 모드 옵션은 SFTP 서버로 전송하기 전에 바이트 생성 된 스트림에 적용됩니다. 이것은 암호화 용이지만 다른 목적으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fae5817bafe1b274a413d2d8be87f3d34ec23f9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crypto&lt;/code&gt; mode option is explained in the data types section above, see &lt;code&gt;&lt;a href=&quot;#Crypto%20operations%20for%20open_tar&quot;&gt;Crypto operations for open_tar&lt;/a&gt;&lt;/code&gt;. Encryption is assumed if the &lt;code&gt;Mode&lt;/code&gt; contains &lt;code&gt;write&lt;/code&gt;, and decryption if the &lt;code&gt;Mode&lt;/code&gt; contains &lt;code&gt;read&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;crypto&lt;/code&gt; 모드 옵션은 상기 데이터 유형 섹션에 설명 참조 &lt;code&gt;&lt;a href=&quot;#Crypto%20operations%20for%20open_tar&quot;&gt;Crypto operations for open_tar&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;Mode&lt;/code&gt; 에 &lt;code&gt;write&lt;/code&gt; 가 포함 된 경우 암호화가 가정 되고 &lt;code&gt;Mode&lt;/code&gt; 에 &lt;code&gt;read&lt;/code&gt; 가 포함 된 경우 해독 이 가정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e5cee4c61a0a375534a2fba35a2573413a78af60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crypto_init&lt;/code&gt; initialies an internal cipher state, and one or more calls of &lt;code&gt;crypto_update&lt;/code&gt; does the acual encryption or decryption. Note that AEAD ciphers can't be handled this way due to their nature.</source>
          <target state="translated">&lt;code&gt;crypto_init&lt;/code&gt; 는 내부 암호화 상태를 initialies, 그리고 하나 개 이상의 통화 &lt;code&gt;crypto_update&lt;/code&gt; 는 acual 암호화 또는 암호 해독을 수행합니다. AEAD 암호는 특성상 이러한 방식으로 처리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="7b046fe6dab519074b82c93250ff16e0a704aba7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crypto_one_time_aead&lt;/code&gt; functions are for the ciphers of mode &lt;code&gt;ccm&lt;/code&gt; or &lt;code&gt;gcm&lt;/code&gt;, and for the cipher &lt;code&gt;chacha20-poly1305&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;crypto_one_time_aead&lt;/code&gt; 기능 모드의 암호위한 &lt;code&gt;ccm&lt;/code&gt; 또는 &lt;code&gt;gcm&lt;/code&gt; 및 암호 용 &lt;code&gt;chacha20-poly1305&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1ea90a542fdde5c9bfa793410f97e64b38fc90e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cryptolib_padding&lt;/code&gt; are paddings that may be present in the underlying cryptolib linked to the Erlang/OTP crypto app.</source>
          <target state="translated">&lt;code&gt;cryptolib_padding&lt;/code&gt; 는 얼랭 / OTP 암호화 응용 프로그램에 링크 된 기본 cryptolib에 존재할 수있는 패딩입니다.</target>
        </trans-unit>
        <trans-unit id="f05085fc1befe3aa6ba53fe6204755e8c7f0ad8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ct_hooks&lt;/code&gt; statement must look as follows:</source>
          <target state="translated">&lt;code&gt;ct_hooks&lt;/code&gt; 에 다음과 같이 문 찾아야합니다 :</target>
        </trans-unit>
        <trans-unit id="195e3e1b4f16da2ed99752167d29e762d1e2035f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ct_run&lt;/code&gt; program is automatically installed with Erlang/OTP and the &lt;code&gt;Common Test&lt;/code&gt; application (for more information, see section &lt;code&gt;&lt;a href=&quot;install_chapter&quot;&gt;Installation&lt;/a&gt;&lt;/code&gt; in the User's Guide). The program accepts different start flags. Some flags trigger &lt;code&gt;ct_run&lt;/code&gt; to start &lt;code&gt;Common Test&lt;/code&gt; and pass on data to it. Some flags start an Erlang node prepared for running &lt;code&gt;Common Test&lt;/code&gt; in a particular mode.</source>
          <target state="translated">&lt;code&gt;ct_run&lt;/code&gt; 의 프로그램이 자동으로 얼랑 / OTP와 함께 설치되는 &lt;code&gt;Common Test&lt;/code&gt; (섹션 참조 자세한 내용은 응용 프로그램 &lt;code&gt;&lt;a href=&quot;install_chapter&quot;&gt;Installation&lt;/a&gt;&lt;/code&gt; 사용자 설명서 참조). 프로그램은 다른 시작 플래그를 허용합니다. 일부 플래그는 &lt;code&gt;ct_run&lt;/code&gt; 을 트리거 하여 &lt;code&gt;Common Test&lt;/code&gt; 를 시작 하고 데이터를 전달합니다. 일부 플래그 는 특정 모드에서 &lt;code&gt;Common Test&lt;/code&gt; 를 실행할 준비가 된 Erlang 노드를 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="0bead0eeaff46c7e466e0712fc0054654e293c43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ct_run&lt;/code&gt; program sets the exit status before shutting down. The following values are defined:</source>
          <target state="translated">&lt;code&gt;ct_run&lt;/code&gt; 의 프로그램이 종료하기 전에 종료 상태를 설정합니다. 다음과 같은 값이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="5e688bf44ef358ec92d20ce42ff6bf380d1fb9a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cth_conn_log&lt;/code&gt; hook performs unformatted logging of Telnet data to a separate text file. All Telnet communication is captured and printed, including any data sent from the server. The link to this text file is located at the top of the test case HTML log.</source>
          <target state="translated">&lt;code&gt;cth_conn_log&lt;/code&gt; 후크 수행 별도의 텍스트 파일로 텔넷 데이터 로깅 형식화. 서버에서 전송 된 모든 데이터를 포함하여 모든 Telnet 통신이 캡처 및 인쇄됩니다. 이 텍스트 파일에 대한 링크는 테스트 케이스 HTML 로그의 맨 위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a68179b6708f261780e3204a93ccf67ebff3b412" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg&lt;/code&gt; module is primarily targeted towards tracing through the &lt;code&gt;erlang:trace/3&lt;/code&gt; function. It is sometimes desired to trace messages in a more delicate way, which can be done with the help of the &lt;code&gt;seq_trace&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;dbg&lt;/code&gt; 모듈은 주로 통해 추적 대상으로되는 &lt;code&gt;erlang:trace/3&lt;/code&gt; 기능. &lt;code&gt;seq_trace&lt;/code&gt; 모듈 을 사용하여보다 정교한 방식으로 메시지를 추적하는 것이 바람직한 경우가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ec06ab24b2bef8a81af6b12d4353768a1844399" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg&lt;/code&gt; server keeps a list of nodes where tracing should be performed. Whenever a &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; call or a &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; call is made, it is executed for all nodes in this list including the local node (except for &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; with a specific &lt;code&gt;pid()&lt;/code&gt; or &lt;code&gt;port()&lt;/code&gt; as first argument, in which case the command is executed only on the node where the designated process or port resides).</source>
          <target state="translated">&lt;code&gt;dbg&lt;/code&gt; 서버는 추적이 수행되어야 노드의 목록을 유지합니다. &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 호출 또는 &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; 호출이 수행 될 때마다 로컬 노드 ( 특정 &lt;code&gt;pid()&lt;/code&gt; 또는 &lt;code&gt;port()&lt;/code&gt; 를 첫 번째 인수로 사용하는 &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; 제외)를 포함하여이 목록의 모든 노드에 대해 실행 됩니다. 지정된 명령이나 포트가있는 노드에서만 명령이 실행됩니다).</target>
        </trans-unit>
        <trans-unit id="c217008a9ef77e9f7c9c82997e3edae1e2b0a1c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg&lt;/code&gt; variants of match specifications have an imperative approach to the match specification body, the ETS dialect has not. The fun body for &lt;code&gt;ets:fun2ms/1&lt;/code&gt; returns the result without side effects. As matching (&lt;code&gt;=&lt;/code&gt;) in the body of the match specifications is not allowed (for performance reasons) the only thing left, more or less, is term construction.</source>
          <target state="translated">일치 사양 의 &lt;code&gt;dbg&lt;/code&gt; 변형에는 일치 사양 본문에 대한 필수 접근 방식이 있지만 ETS 언어는 그렇지 않습니다. &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 의 fun body는 부작용없이 결과를 반환합니다. 일치 스펙 본문에서 일치 ( &lt;code&gt;=&lt;/code&gt; )가 허용되지 않기 때문에 (성능상의 이유로) 남은 것은 용어 구성입니다.</target>
        </trans-unit>
        <trans-unit id="8b1d45e514e2b4bb0f72c0e576b456b901110516" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;debug_info&lt;/code&gt; option ensures that the BEAM file contains debug information, which makes it possible to find unused local functions.</source>
          <target state="translated">&lt;code&gt;debug_info&lt;/code&gt; 의 옵션 보장 BEAM 파일은 가능한 사용하지 않는 지역의 기능을 찾을 수 있도록 디버그 정보를 포함하고있다.</target>
        </trans-unit>
        <trans-unit id="f272f87848e9520c4164ada69cea273706e63692" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;debug_info&lt;/code&gt; parameter controls whether the debug information in the beam file should be kept (&lt;code&gt;keep&lt;/code&gt;) or stripped &lt;code&gt;strip&lt;/code&gt; when the file is copied to the target system.</source>
          <target state="translated">&lt;code&gt;debug_info&lt;/code&gt; 의 빔 파일에 디버그 정보 (보관되어야 하는지를 제어 파라미터 &lt;code&gt;keep&lt;/code&gt; ) 또는 박리 &lt;code&gt;strip&lt;/code&gt; 파일을 타겟 시스템으로 복사 할 때.</target>
        </trans-unit>
        <trans-unit id="6fb823bf619fb63ef67310a79ad7a561ee4d0a34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete&lt;/code&gt; function does not delete the table from the database since unloading an MIB does not necessarily mean that the table should be destroyed.</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; 기능은 반드시 테이블이 파괴되어야한다는 것을 의미하지 않는 MIB을 언로드하기 때문에 데이터베이스에서 테이블을 삭제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bb6d436299249f5caa30b07b29030812a609536" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete&lt;/code&gt; function does not delete the variable from the database.</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; 기능은 데이터베이스에서 변수를 삭제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7056e5309dbe8cb35a67254e724ea1561fd3590e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete&lt;/code&gt; operation is considered successful if the element was not present in the table. Hence all attempts to check that the element is present in the Ets/Mnesia table before deletion are unnecessary. Here follows an example for Ets tables:</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; 요소가 테이블에 존재 아니었다면 작업이 성공적으로 간주됩니다. 따라서 삭제하기 전에 요소가 Ets / Mnesia 테이블에 있는지 확인하려는 모든 시도는 필요하지 않습니다. 다음은 Ets 테이블의 예입니다.</target>
        </trans-unit>
        <trans-unit id="9843826cc8a81d332dd5ca58dc2e4d273cfa0a51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dh_der&lt;/code&gt; option is not supported by TLS 1.3. Use the &lt;code&gt;supported_groups&lt;/code&gt; option instead.</source>
          <target state="translated">&lt;code&gt;dh_der&lt;/code&gt; 의 옵션은 TLS 1.3을 지원하지 않습니다. 대신 &lt;code&gt;supported_groups&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d506578ec68dd2a9fa7f8cceed364aba6b39394" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dh_file&lt;/code&gt; option is not supported by TLS 1.3. Use the &lt;code&gt;supported_groups&lt;/code&gt; option instead.</source>
          <target state="translated">&lt;code&gt;dh_file&lt;/code&gt; 의 옵션은 TLS 1.3을 지원하지 않습니다. 대신 &lt;code&gt;supported_groups&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ec29833516e95ca8c52bcd06ca0329b6a9912b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;disc_copies&lt;/code&gt; tables are stored on disk with &lt;code&gt;.DCL&lt;/code&gt; and &lt;code&gt;.DCD&lt;/code&gt; files, which are standard &lt;code&gt;disk_log&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;disc_copies&lt;/code&gt; 의 테이블과 디스크에 저장된 &lt;code&gt;.DCL&lt;/code&gt; 및 &lt;code&gt;.DCD&lt;/code&gt; 표준 파일, &lt;code&gt;disk_log&lt;/code&gt; 의 파일입니다.</target>
        </trans-unit>
        <trans-unit id="0566aa9127b7a16298ed02e87fbca3df443437c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;disk_log&lt;/code&gt; module does not report errors to the &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; module. It is up to the caller to decide whether to employ the error logger. Function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; can be used to produce readable messages from error replies. However, information events are sent to the error logger in two situations, namely when a log is repaired, or when a file is missing while reading chunks.</source>
          <target state="translated">&lt;code&gt;disk_log&lt;/code&gt; 모듈은 오류를보고하지 않습니다 &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; 의 모듈. 오류 로거의 사용 여부를 결정하는 것은 호출자의 책임입니다. &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 오류 응답에서 읽을 수있는 메시지를 생성 할 수 있습니다. 그러나 정보 이벤트는 두 가지 상황, 즉 로그가 복구되거나 청크를 읽는 동안 파일이 누락 된 경우 오류 로거로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="cfcfef3897d14b434ad165428853c39b5f2890f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dist_util:handshake_we_started/1&lt;/code&gt; and &lt;code&gt;dist_util:handshake_other_started/1&lt;/code&gt; functions takes a &lt;code&gt;#hs_data{}&lt;/code&gt; record as argument. There are quite a lot of fields in this record that you need to set. The record is defined in &lt;code&gt;kernel/include/dist_util.hrl&lt;/code&gt;. Not documented fields should not be set, i.e., should be left as &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dist_util:handshake_we_started/1&lt;/code&gt; 및 &lt;code&gt;dist_util:handshake_other_started/1&lt;/code&gt; 기능은 얻어 &lt;code&gt;#hs_data{}&lt;/code&gt; 인수로 기록. 이 레코드에는 설정해야 할 필드가 많이 있습니다. 레코드는 &lt;code&gt;kernel/include/dist_util.hrl&lt;/code&gt; 에 정의되어 있습니다. 문서화되지 않은 필드는 설정하지 않아야합니다. 즉, &lt;code&gt;undefined&lt;/code&gt; 로 두어야합니다 .</target>
        </trans-unit>
        <trans-unit id="83c7e0ed34c372831d8c8f2866d0a4d8b8af47d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do_select&lt;/code&gt; function initiates a select, and returns if there is no immediate error. The result is returned when &lt;code&gt;ready_io&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;do_select&lt;/code&gt; 의 즉각적인 오류가없는 경우 함수는 선택 시작하고 돌아갑니다. &lt;code&gt;ready_io&lt;/code&gt; 가 호출 되면 결과가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e898d68f399dcaad71bedb473b4e1db27a86822" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;driver_entry&lt;/code&gt; structure is a C struct that all Erlang drivers define. It contains entry points for the Erlang driver, which are called by the Erlang emulator when Erlang code accesses the driver.</source>
          <target state="translated">&lt;code&gt;driver_entry&lt;/code&gt; 의 구조는 모든 얼랑 드라이버를 정의하는 C 구조체이다. Erlang 코드가 드라이버에 액세스 할 때 Erlang 에뮬레이터가 호출하는 Erlang 드라이버의 진입 점을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e2f343471e0cd9e732eb94fa594ad01445d525d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;entity-Body&lt;/code&gt; as defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt;, for example, data sent from a CGI script using the POST method.</source>
          <target state="translated">&lt;code&gt;entity-Body&lt;/code&gt; 에서 정의한 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; 는 , 예를 들어, 데이터는 POST 방법을 사용하여 CGI 스크립트로부터 전송.</target>
        </trans-unit>
        <trans-unit id="8485e195c6ca973415a83d30d66c767c905bacbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;epmd&lt;/code&gt; daemon accepts messages from both the local host and remote hosts. However, only the query commands are answered (and acted upon) if the query comes from a remote host. It is always an error to try to register a node name if the client is not a process on the same host as the &lt;code&gt;epmd&lt;/code&gt; instance is running on. Such requests are considered hostile and the connection is closed immediately.</source>
          <target state="translated">&lt;code&gt;epmd&lt;/code&gt; 데몬은 로컬 호스트와 원격 호스트 모두에서 메시지를 받아들입니다. 그러나 쿼리가 원격 호스트에서 온 경우 쿼리 명령 만 응답 (및 조치)됩니다. 클라이언트가 &lt;code&gt;epmd&lt;/code&gt; 인스턴스가 실행중인 동일한 호스트에서 프로세스가 아닌 경우 노드 이름을 등록하려고하면 항상 오류 입니다. 이러한 요청은 적대적인 것으로 간주되며 연결이 즉시 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="1a8cdcc41303bad80d1836231fd657575e8b7da9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erl&lt;/code&gt; program starts an Erlang runtime system. The exact details (for example, whether &lt;code&gt;erl&lt;/code&gt; is a script or a program and which other programs it calls) are system-dependent.</source>
          <target state="translated">&lt;code&gt;erl&lt;/code&gt; 프로그램은 얼랑 런타임 시스템을 시작합니다. 정확한 세부 사항 (예 : &lt;code&gt;erl&lt;/code&gt; 이 스크립트 또는 프로그램 인지 여부 및 호출하는 기타 프로그램)은 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="23033c746a70348dcd7ee413398f764a041fafc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erl_boot_server&lt;/code&gt; can read regular files and files in archives. See &lt;code&gt;&lt;a href=&quot;code&quot;&gt;code(3)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;erl_prim_loader(3)&lt;/code&gt; in ERTS.</source>
          <target state="translated">&lt;code&gt;erl_boot_server&lt;/code&gt; 은 보관소에 일반 파일 및 파일을 읽을 수 있습니다. ERTS의 &lt;code&gt;&lt;a href=&quot;code&quot;&gt;code(3)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;erl_prim_loader(3)&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc1db4ac366acb55e5dbd23b870fee87dcf6984d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erl_prim_loader&lt;/code&gt; module interprets the following command-line flags:</source>
          <target state="translated">&lt;code&gt;erl_prim_loader&lt;/code&gt; 의 모듈은 다음과 같은 명령 줄 플래그를 해석합니다 :</target>
        </trans-unit>
        <trans-unit id="a9f75e2ebb8bacf1be148858ac754ee91aff0b2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlang:processes/1&lt;/code&gt; and &lt;code&gt;erlang:port/1&lt;/code&gt; BIFs iterate over the tables and return corresponding identifiers. These BIF should return a consistent snapshot of the table content during some time when the BIF is executing. In order to implement this we use locking in a strange way. We use an &quot;inverted rwlock&quot;.</source>
          <target state="translated">&lt;code&gt;erlang:processes/1&lt;/code&gt; 및 &lt;code&gt;erlang:port/1&lt;/code&gt; BIFS 이블 반복 대응 식별자를 반환한다. 이러한 BIF는 BIF가 실행되는 동안 테이블 콘텐츠의 일관된 스냅 샷을 반환해야합니다. 이를 구현하기 위해 우리는 이상한 방식으로 잠금을 사용합니다. 우리는 &quot;inverted rwlock&quot;을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9c8443a325361f346c54c5b5b79ecfd176dc3cc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlang:timestamp()&lt;/code&gt; BIF is equivalent to:</source>
          <target state="translated">&lt;code&gt;erlang:timestamp()&lt;/code&gt; BIF는 동등하다 :</target>
        </trans-unit>
        <trans-unit id="674c071fef1bb6c50be069bf2fac5cfa5b02ddff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlc&lt;/code&gt; commands can be used to compile SNMP MIBs. Example:</source>
          <target state="translated">&lt;code&gt;erlc&lt;/code&gt; 의 명령은 SNMP MIB를 컴파일하는 데 사용할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="62bad1fda35fe8631456e7f852e564c8e9c8e268" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlc&lt;/code&gt; program provides a common way to run all compilers in the Erlang system. Depending on the extension of each input file, &lt;code&gt;erlc&lt;/code&gt; invokes the appropriate compiler. Regardless of which compiler is used, the same flags are used to provide parameters, such as include paths and output directory.</source>
          <target state="translated">&lt;code&gt;erlc&lt;/code&gt; 프로그램은 얼랑 시스템의 모든 컴파일러를 실행하는 일반적인 방법을 제공합니다. 각 입력 파일의 확장자에 따라 &lt;code&gt;erlc&lt;/code&gt; 는 적절한 컴파일러를 호출합니다. 사용되는 컴파일러에 관계없이 동일한 경로를 사용하여 경로 및 출력 디렉토리 포함과 같은 매개 변수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="04a181b53380c41c65d2013dd7fbc831073b3697" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlc&lt;/code&gt; program provides an even better way to compile modules from the shell, see the &lt;code&gt;erlc(1)&lt;/code&gt; manual page in ERTS. It understands a number of flags that can be used to define macros, add search paths for include files, and more.</source>
          <target state="translated">&lt;code&gt;erlc&lt;/code&gt; 의 프로그램은 참조 셀에서 모듈을 컴파일 할 수있는 더 나은 방법을 제공합니다 &lt;code&gt;erlc(1)&lt;/code&gt; ERTS의 매뉴얼 페이지를. 매크로를 정의하고 포함 파일에 대한 검색 경로를 추가하는 데 사용할 수있는 많은 플래그를 이해합니다.</target>
        </trans-unit>
        <trans-unit id="8ef81ea9999fef9d6386667fd464ac528873e195" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erpc&lt;/code&gt; operation failed due to some system limit being reached. This typically due to failure to create a process on the remote node &lt;code&gt;Node&lt;/code&gt;, but can be other things as well.</source>
          <target state="translated">&lt;code&gt;erpc&lt;/code&gt; 의 일부 시스템의 한계로 인해 실패한 작업에 도달된다. 이는 일반적으로 원격 노드 &lt;code&gt;Node&lt;/code&gt; 에서 프로세스를 생성하지 못했기 때문에 발생 하지만 다른 문제 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef05a4f26d361fa5f7db9630f59b90887dc5e15f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erpc&lt;/code&gt; operation failed. The following &lt;code&gt;ERpcErrorReason&lt;/code&gt;s are the most common ones:</source>
          <target state="translated">&lt;code&gt;erpc&lt;/code&gt; 의 작업이 실패했습니다. 다음 &lt;code&gt;ERpcErrorReason&lt;/code&gt; 이 가장 일반적인 것입니다.</target>
        </trans-unit>
        <trans-unit id="ecee252d04d93f7d74c1c1a56f12a612505d489e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erpc&lt;/code&gt; operation timed out. The function may or may not be applied.</source>
          <target state="translated">&lt;code&gt;erpc&lt;/code&gt; 의 작업 시간이 초과되었습니다. 기능이 적용되거나 적용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd3c7d4f5dac617c7aad52a992257a0165d9e724" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error_logger&lt;/code&gt; API still exists, but should only be used by legacy code. It will be removed in a later release.</source>
          <target state="translated">&lt;code&gt;error_logger&lt;/code&gt; 의 API는 여전히 존재하지만 레거시 코드에 의해 사용되어야한다. 이후 릴리스에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="cecfe06c35cc22d6fbeab34699c031b77ba0b013" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error_logger_format_depth&lt;/code&gt; variable is &lt;code&gt; deprecated&lt;/code&gt; since the &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt; was introduced in Erlang/OTP 21.0. The variable, and this function, are kept for backwards compatibility since they still might be used by legacy report handlers.</source>
          <target state="translated">&lt;code&gt;error_logger_format_depth&lt;/code&gt; 의 변수입니다 &lt;code&gt; deprecated&lt;/code&gt; 이후 &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt; 얼랑 / OTP 21.0 년에 도입되었다. 변수와이 함수는 레거시 보고서 처리기에서 계속 사용할 수 있으므로 이전 버전과의 호환성을 위해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d68556b2eb1fae2f09bd4af885781dca52da64d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error_logger_format_depth&lt;/code&gt; variable is &lt;code&gt;deprecated&lt;/code&gt; since the &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt; was introduced in Erlang/OTP 21.0. The variable, and this function, are kept for backwards compatibility since they still might be used by legacy report handlers.</source>
          <target state="translated">&lt;code&gt;error_logger_format_depth&lt;/code&gt; 의 변수입니다 &lt;code&gt;deprecated&lt;/code&gt; 이후 &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt; 얼랑 / OTP 21.0 년에 도입되었다. 변수 및이 함수는 레거시 보고서 처리기에서 여전히 사용될 수 있으므로 이전 버전과의 호환성을 위해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="7c78dbc6e06eb7032ca1037abf4bb7cf984ec4a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erts_alloc_config(3)&lt;/code&gt; tool can be used to aid creation of an &lt;code&gt;erts_alloc&lt;/code&gt; configuration that is suitable for a limited number of runtime scenarios.</source>
          <target state="translated">&lt;code&gt;erts_alloc_config(3)&lt;/code&gt; 공구는 생성 돕기 위해 사용될 수있다 &lt;code&gt;erts_alloc&lt;/code&gt; 의 런타임 시나리오 제한된 수의 적합한 구성.</target>
        </trans-unit>
        <trans-unit id="6d445f376d6f420d187f6eefce3f926292a91d52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;et&lt;/code&gt; module is not like other modules. It contains a function called &lt;code&gt;et:trace_me/5&lt;/code&gt;. Which is a function that does not do any useful stuff at all. Its sole purpose is to be a function that is easy to trace. A call to it may be something like:</source>
          <target state="translated">&lt;code&gt;et&lt;/code&gt; 모듈은 다른 모듈과 같지 않다. &lt;code&gt;et:trace_me/5&lt;/code&gt; 라는 함수를 포함합니다 . 유용한 기능을 전혀 수행하지 않는 기능입니다. 그것의 유일한 목적은 추적하기 쉬운 기능입니다. 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bed59c1de102975ce15ed3e675ac3119209f047d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;etags&lt;/code&gt; program of fairly modern versions of Emacs and XEmacs has native support for Erlang. To check if your version does include this support, issue the command &lt;code&gt;etags --help&lt;/code&gt; at a the command line prompt. At the end of the help text there is a list of supported languages. Unless Erlang is a member of this list I suggest that you should upgrade to a newer version of Emacs.</source>
          <target state="translated">&lt;code&gt;etags&lt;/code&gt; 매우 현대 이맥스 버전과 이맥스의 프로그램은 얼랑에 대한 기본 지원합니다. 버전에이 지원이 포함되어 있는지 확인하려면 명령 행 프롬프트에서 &lt;code&gt;etags --help&lt;/code&gt; 명령을 실행하십시오. 도움말 텍스트 끝에 지원되는 언어 목록이 있습니다. Erlang이이 목록에 속하지 않으면 최신 버전의 Emacs로 업그레이드하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="47e6f553b59c8cd440ae6bcf427e51798ed42721" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;etags&lt;/code&gt; utility can also read a list of files from its standard input by supplying a single dash in place of the file names. This feature is useful when a project consists of a large number of files. The standard UNIX command &lt;code&gt;find&lt;/code&gt; can be used to generate the list of files, e.g:</source>
          <target state="translated">&lt;code&gt;etags&lt;/code&gt; 유틸리티는 파일 이름 대신에 단일 대시를 제공하여 표준 입력에서 파일 목록을 읽을 수 있습니다. 이 기능은 프로젝트가 많은 파일로 구성된 경우에 유용합니다. 표준 UNIX 명령 &lt;code&gt;find&lt;/code&gt; 를 사용하여 파일 목록을 생성 할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="e41a30417c9eb9b7fd9125a0948a761a185309da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ets:select/2&lt;/code&gt; call conceptually looks like this in the resulting code:</source>
          <target state="translated">&lt;code&gt;ets:select/2&lt;/code&gt; 호출은 개념적 결과 코드에 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="c0a28f71fbf02463cf528426b0591cc67a7a02b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;example_drv_start&lt;/code&gt;, is the only function that is called with a handle to the port instance, so this must be saved. It is customary to use an allocated driver-defined structure for this one, and to pass a pointer back as a reference.</source>
          <target state="translated">&lt;code&gt;example_drv_start&lt;/code&gt; 는 포트 인스턴스에 대한 핸들로 호출되는 전용 기능입니다, 그래서 이것은 저장해야합니다. 이를 위해 할당 된 드라이버 정의 구조를 사용하고 포인터를 참조로 다시 전달하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="d0356d1c5d4e8ef894f1ca0204010b1f0f916038" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extended_errors&lt;/code&gt; option enables extended ODBC error information when an operation fails. Rather than returning &lt;code&gt;{error, Reason}&lt;/code&gt;, the failing function will reutrn &lt;code&gt;{error, {ODBCErrorCode, NativeErrorCode, Reason}}&lt;/code&gt;. Note that this information is probably of little use when writing database-independent code, but can be of assistance in providing more sophisticated error handling when dealing with a known underlying database.</source>
          <target state="translated">&lt;code&gt;extended_errors&lt;/code&gt; 의 작업이 실패 할 때 옵션은 ODBC 오류 정보를 확장 할 수 있습니다. 보다 오히려 복귀 &lt;code&gt;{error, Reason}&lt;/code&gt; , 실패한 기능 reutrn 것 &lt;code&gt;{error, {ODBCErrorCode, NativeErrorCode, Reason}}&lt;/code&gt; . 이 정보는 데이터베이스 독립 코드를 작성할 때 거의 사용되지 않지만 알려진 기본 데이터베이스를 처리 할 때보다 정교한 오류 처리를 제공하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c59051a0d238b0abf7c9e7050c91b5361d579937" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extra&lt;/code&gt; info is not normally interpreted by the agent, instead it is passed through to the &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;net-if&lt;/a&gt;&lt;/code&gt; process. It is up to the implementor of that process to make use of this data.</source>
          <target state="translated">&lt;code&gt;extra&lt;/code&gt; 정보는 일반적으로 통해 대신이 전달되는 에이전트에 의해 해석되지 않습니다 &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;net-if&lt;/a&gt;&lt;/code&gt; 공정. 이 데이터를 사용하는 것은 해당 프로세스의 구현 자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="57ed5e1b23df723cf600bd41057a5b61adc0bf3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;family&lt;/code&gt; field can only have the (above) specified values (and not all the values of socket:domain()).</source>
          <target state="translated">&lt;code&gt;family&lt;/code&gt; 필드 만 (위) 지정된 값을 가질 수있다 (그리고 모든 소켓의 값 : 도메인 ()).</target>
        </trans-unit>
        <trans-unit id="9363097de66681822e14d18a16cae53b07a71b33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; module accepts raw filenames as input. &lt;code&gt;open_port({spawn_executable, ...} ...)&lt;/code&gt; also accepts them. As mentioned earlier, the arguments specified in the option list to &lt;code&gt;open_port({spawn_executable, ...} ...)&lt;/code&gt; undergo the same conversion as the filenames, meaning that the executable is provided with arguments in UTF-8 as well. This translation is avoided consistently with how the filenames are treated, by giving the argument as a binary.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 모듈은 입력 원시 파일명을 받아 들인다. &lt;code&gt;open_port({spawn_executable, ...} ...)&lt;/code&gt; 도 허용합니다. 앞에서 언급했듯이 옵션 목록에 &lt;code&gt;open_port({spawn_executable, ...} ...)&lt;/code&gt; 지정된 인수 는 파일 이름과 동일한 변환을 거치므로 실행 파일에도 UTF-8의 인수가 제공됩니다. 이 변환은 인수를 2 진으로 제공하여 파일 이름이 처리되는 방식과 일관되게 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56811d8968fc7cff92a38ee6c1b86759f5455dad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; module already spread's tags, so there is noo need to manually call these function to get user tags spread to the efile driver through that module.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 이 이미 모듈 확산의 태그, 수동으로 해당 모듈을 통해 efile 드라이버로 사용자 태그의 확산을 얻기 위해이 함수를 호출에 NOO 필요가있다.</target>
        </trans-unit>
        <trans-unit id="d1888f67852ce013eb515b48a1f7e3f5fb2b5677" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foo&lt;/code&gt; table is replicated on the two nodes &lt;code&gt;N1&lt;/code&gt; and &lt;code&gt;N2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 테이블은 두 개의 노드에 복제 &lt;code&gt;N1&lt;/code&gt; 과 &lt;code&gt;N2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58cb0b27674de03ef7e6aa8a782a3f05022f6202" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fprof&lt;/code&gt; module uses tracing to collect profiling data, hence there is no need for special compilation of any module to be profiled. When it starts tracing, &lt;code&gt;fprof&lt;/code&gt; will erase all previous tracing in the node and set the necessary trace flags on the profiling target processes as well as local call trace on all functions in all loaded modules and all modules to be loaded. &lt;code&gt;fprof&lt;/code&gt; erases all tracing in the node when it stops tracing.</source>
          <target state="translated">&lt;code&gt;fprof&lt;/code&gt; 의 추적 모듈 사용은 따라서 프로파일 링 할 모든 모듈의 특별한 컴파일 필요가 없다, 프로파일 링 데이터를 수집합니다. 추적을 시작하면 &lt;code&gt;fprof&lt;/code&gt; 는 노드에서 이전의 모든 추적을 지우고 프로파일 링 대상 프로세스에서 필요한 추적 플래그와로드 된 모든 모듈 및로드 할 모든 모듈의 모든 함수에 대한 로컬 호출 추적을 설정합니다. &lt;code&gt;fprof&lt;/code&gt; 는 추적을 중지하면 노드의 모든 추적을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="2499ac11d982c28fc125b257bd3bdd2fea444c7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fqdn_fun&lt;/code&gt; extracts hostnames (Fully Qualified Domain Names) from uri_id or other ReferenceIDs that are not pre-defined in the public_key function. Suppose you have some URI with a very special protocol-part: &lt;code&gt;myspecial://example.com&quot;&lt;/code&gt;. Since this a non-standard URI there will be no hostname extracted for matching CN-names in the &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fqdn_fun&lt;/code&gt; 의 PUBLIC_KEY 기능에 미리 정의되지 않은 다른 uri_id있는 referenceIds 추출물 호스트 이름 (완전한 도메인 이름). 매우 특별한 protocol-part : &lt;code&gt;myspecial://example.com&quot;&lt;/code&gt; 이있는 URI가 있다고 가정하십시오 . 이것은 비표준 URI이므로 &lt;code&gt;Subject&lt;/code&gt; 에서 CN 이름과 일치하는 호스트 이름이 추출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="122806faca6d67fa7fa167376a0e47c2c49bcb48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;to&lt;/code&gt;, and &lt;code&gt;message&lt;/code&gt; parameters are exactly what they sound like. &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; are visualized in the &lt;code&gt;Viewer&lt;/code&gt; as &quot;lifelines&quot;, with the message passing from one to the other. If &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; are the same value, then it is displayed next to the lifeline as an &quot;action&quot;. The &lt;code&gt;extra_stuff&lt;/code&gt;value is simply data that you can attach that will be displayed when someone actually clicks on the action or message in the &lt;code&gt;Viewer&lt;/code&gt; window.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; , &lt;code&gt;to&lt;/code&gt; , 그리고 &lt;code&gt;message&lt;/code&gt; 매개 변수는이 같은 소리 정확히입니다. &lt;code&gt;from&lt;/code&gt; 및 &lt;code&gt;to&lt;/code&gt; 메시지 가 &lt;code&gt;Viewer&lt;/code&gt; 에서 &quot;라이프 라인&quot;으로 표시되고 메시지가 서로 전달됩니다. 경우 &lt;code&gt;from&lt;/code&gt; 와 &lt;code&gt;to&lt;/code&gt; 같은 값이며, 다음은 &quot;조치&quot;로 옆 생명선에 표시됩니다. &lt;code&gt;extra_stuff&lt;/code&gt; 의 값은 단순히 누군가가 실제로에서 작업 또는 메시지를 클릭 할 때 표시됩니다 당신이 첨부 할 수있는 데이터입니다 &lt;code&gt;Viewer&lt;/code&gt; 창을여십시오.</target>
        </trans-unit>
        <trans-unit id="87548be67a9ff93c1ef1ff4d3cbb19180b6403f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ftp&lt;/code&gt; module normally accesses the tar file on disk using the &lt;code&gt;file&lt;/code&gt; module. When other needs arise, you can define your own low-level Erlang functions to perform the writing and reading on the storage media; use function &lt;code&gt;&lt;a href=&quot;#init-3&quot;&gt;init/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ftp&lt;/code&gt; 모듈은 일반적으로 사용하여 디스크에 tar 파일에 액세스 &lt;code&gt;file&lt;/code&gt; 모듈을. 다른 요구가 발생할 경우 저장 매체에서 쓰기 및 읽기를 수행하기 위해 자체 저수준 Erlang 기능을 정의 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;#init-3&quot;&gt;init/3&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="97a262c9e6ae8c813f3758420838640077d62040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fun()&lt;/code&gt; in the exec option could take up to three arguments (&lt;code&gt;Cmd&lt;/code&gt;, &lt;code&gt;User&lt;/code&gt; and &lt;code&gt;ClientAddress&lt;/code&gt;). See the &lt;code&gt;&lt;a href=&quot;ssh#type-exec_daemon_option&quot;&gt;exec_daemon_option()&lt;/a&gt;&lt;/code&gt; for the details.</source>
          <target state="translated">exec 옵션 의 &lt;code&gt;fun()&lt;/code&gt; 은 최대 3 개의 인수 ( &lt;code&gt;Cmd&lt;/code&gt; , &lt;code&gt;User&lt;/code&gt; 및 &lt;code&gt;ClientAddress&lt;/code&gt; )를 사용할 수 있습니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;ssh#type-exec_daemon_option&quot;&gt;exec_daemon_option()&lt;/a&gt;&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="601051b0fdf8cf4c5f5015c05c1f7676f5366f6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fun()&lt;/code&gt; is very restricted, it can take only a single parameter (the parameter list to match), a sole variable or a list. It needs to use the &lt;code&gt;is_&lt;/code&gt;XXX guard tests and one cannot use language constructs that have no representation in a match_spec (like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;receive&lt;/code&gt; etc). The return value from the fun will be the return value of the resulting match_spec.</source>
          <target state="translated">&lt;code&gt;fun()&lt;/code&gt; 매우 그것은 단지 하나의 매개 변수 (일치하는 매개 변수 목록), 단독 변수 또는 목록을 취할 수 제한됩니다. &lt;code&gt;is_&lt;/code&gt; XXX guard 테스트 를 사용해야하며 match_spec에 표현이없는 언어 구문 ( &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;case&lt;/code&gt; , &lt;code&gt;receive&lt;/code&gt; 등)을 사용할 수 없습니다 . fun의 반환 값은 결과 match_spec의 반환 값입니다.</target>
        </trans-unit>
        <trans-unit id="000806ecedbeddab2e6bf12ee5fe07ca1e33c2e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fun/2&lt;/code&gt; in this option replaces the default host name matching rules. The fun should return a boolean to tell if the Reference ID and Presented ID matches or not. The fun can also return a third value, the atom &lt;code&gt;default&lt;/code&gt;, if the default matching rules shall apply. This makes it possible to augment the tests with a special case:</source>
          <target state="translated">이 옵션 의 &lt;code&gt;fun/2&lt;/code&gt; 는 기본 호스트 이름 일치 규칙을 대체합니다. 재미는 참조 ID와 제시된 ID가 일치하는지 여부를 알리기 위해 부울을 반환해야합니다. 기본 일치 규칙이 적용되는 경우 재미는 세 번째 값인 원자 &lt;code&gt;default&lt;/code&gt; 반환 할 수도 있습니다. 이를 통해 특별한 경우에 테스트를 보강 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f52884fca2fcf6439eaac6506d404d211516c579" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;functions&lt;/code&gt; filter shows each function as a vertical line in the sequence diagram. A function calling itself is shown as an activity within a function, and all other function calls are shown as interactions between functions.</source>
          <target state="translated">&lt;code&gt;functions&lt;/code&gt; 필터는 시퀀스 다이어그램의 수직 라인과 같은 각 기능을 나타낸다. 함수 호출 자체는 함수 내의 활동으로 표시되며 다른 모든 함수 호출은 함수 간의 상호 작용으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3f981dcbf4ac48552e64e421603989d6797ca936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;garbage_collect&lt;/code&gt; pseudo function has not got an OWN time of zero like &lt;code&gt;suspend&lt;/code&gt;, instead it is equal to the ACC time.</source>
          <target state="translated">&lt;code&gt;garbage_collect&lt;/code&gt; 의 의사 기능과 같은 제로의 자신의 시간을 가지고하지 않은 &lt;code&gt;suspend&lt;/code&gt; 대신은 ACC 시간과 동일하다.</target>
        </trans-unit>
        <trans-unit id="65be8dbec39cb8799bd4b2ae3b3d10e864f2a323" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_event&lt;/code&gt; process can go into hibernation (see &lt;code&gt; erlang:hibernate/3&lt;/code&gt;) if a callback function in a handler module specifies &lt;code&gt;hibernate&lt;/code&gt; in its return value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each event handled by a busy event manager.</source>
          <target state="translated">&lt;code&gt;gen_event&lt;/code&gt; 의 절전 모드에 들어갈 수있는 프로세스 (참조 &lt;code&gt; erlang:hibernate/3&lt;/code&gt; 핸들러 모듈 지정에 콜백 함수 경우) &lt;code&gt;hibernate&lt;/code&gt; 의 리턴 값. 이는 서버가 오랫동안 유휴 상태 일 것으로 예상되는 경우 유용 할 수 있습니다. 그러나 최대 절전 모드는 최소한 두 개의 가비지 수집 (최대 절전 모드 및 깨어 난 직후)을 의미하고 바쁜 이벤트 관리자가 처리하는 각 이벤트간에 수행 할 작업이 아니므로이 기능을주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="044322659b6e8af2be19d4c036e45080be4df433" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_event&lt;/code&gt; process can go into hibernation (see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;) if a callback function in a handler module specifies &lt;code&gt;hibernate&lt;/code&gt; in its return value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each event handled by a busy event manager.</source>
          <target state="translated">&lt;code&gt;gen_event&lt;/code&gt; 의 절전 모드에 들어갈 수있는 프로세스 (참조 &lt;code&gt;erlang:hibernate/3&lt;/code&gt; 핸들러 모듈 지정에 콜백 함수 경우) &lt;code&gt;hibernate&lt;/code&gt; 의 리턴 값. 서버가 오랫동안 유휴 상태 일 것으로 예상되는 경우 유용 할 수 있습니다. 그러나 최대 절전 모드는 최대 두 개의 가비지 콜렉션 (최대 절전 모드 및 깨어 난 직후)을 의미하므로 바쁜 이벤트 관리자가 처리하는 각 이벤트간에 수행하려는 작업이 아니므로이 기능을주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f841b959e8263c246a84615eb245e9aa9e79a66a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt; Module:handle_call/3&lt;/a&gt;&lt;/code&gt; to handle the request.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; 의 프로세스를 호출 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt; Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 요청을 처리 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26a989bcc28ed3e808b806405714b19049fd235b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; to initialize. To ensure a synchronized startup procedure, &lt;code&gt;start_link/3,4&lt;/code&gt; does not return until &lt;code&gt;Module:init/1&lt;/code&gt; has returned.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; 의 프로세스를 호출 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 초기화 할 수 있습니다. 동기화 된 시작 절차를 보장하기 위해 &lt;code&gt;start_link/3,4&lt;/code&gt; 는 &lt;code&gt;Module:init/1&lt;/code&gt; 이 반환 될 때까지 반환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d7490f34408e79e925356758b66c95f52679a6c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process can go into hibernation (see &lt;code&gt; erlang:hibernate/3&lt;/code&gt;) if a callback function specifies &lt;code&gt;'hibernate'&lt;/code&gt; instead of a time-out value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each call to a busy server.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; 의 절전 모드에 들어갈 수있는 프로세스 (참조 &lt;code&gt; erlang:hibernate/3&lt;/code&gt; 콜백 함수를 나타내는 경우에) &lt;code&gt;'hibernate'&lt;/code&gt; 대신에 타임 아웃 값. 이는 서버가 오랫동안 유휴 상태 일 것으로 예상되는 경우 유용 할 수 있습니다. 그러나 최대 절전 모드는 최소 두 개의 가비지 수집 (최대 절전 모드 일 때와 깨어 난 직후)을 의미하고 바쁜 서버에 대한 각 호출 사이에 수행 할 작업이 아니므로이 기능을주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fa0125aacc8a9ef2d0db488477563acd091e114f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process can go into hibernation (see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;) if a callback function specifies &lt;code&gt;'hibernate'&lt;/code&gt; instead of a time-out value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each call to a busy server.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; 의 절전 모드에 들어갈 수있는 프로세스 (참조 &lt;code&gt;erlang:hibernate/3&lt;/code&gt; 콜백 함수를 나타내는 경우에) &lt;code&gt;'hibernate'&lt;/code&gt; 대신에 타임 아웃 값. 서버가 오랫동안 유휴 상태 일 것으로 예상되는 경우 유용 할 수 있습니다. 그러나 최대 절전 모드는 최대 두 개의 가비지 콜렉션 (최대 절전 모드 및 깨어 난 직후)을 의미하므로 사용중인 서버에 대한 각 호출간에 수행하려는 작업이 아니므로이 기능을주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="93b11bb8bc3cc58fae8df0b4cde4e2b1b7508719" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process has been set to trap exit signals.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; 의 처리가 종료 트랩 신호로 설정되었다.</target>
        </trans-unit>
        <trans-unit id="1a0a8f650014835d8fac6303db526f6a6997059c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process terminates abnormally and logs an error. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;terminate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; 의 프로세스가 비정상적으로 종료되고 오류를 기록합니다. &lt;code&gt;Opt&lt;/code&gt; 가 원자 &lt;code&gt;terminate&lt;/code&gt; 설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="a177f7b03da7ce677026ac74a7f1eaf2f38ab48b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; behavior can if this is enabled, regardless of callback mode, automatically &lt;code&gt;call the state callback&lt;/code&gt; with special arguments whenever the state changes so you can write state enter actions near the rest of the state transition rules. It typically looks like this:</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 에 이 옵션을 사용하는 경우 동작에 관계없이 콜백 모드, 자동 수 &lt;code&gt;call the state callback&lt;/code&gt; 이 상태를 쓸 수 있도록 상태 변경은 상태 전이 규칙의 나머지 부분에 가까운 동작을 입력 할 때마다 특별한 인수를. 일반적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bed0fd34af6e417a5ed2971b378b4cefa2ed46b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; behavior supports two callback modes:</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 의 동작은 두 개의 콜백 모드를 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="0853cf94b65372cd43a3f0b5a15fa90c0eef1c14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; behaviour can if this is enabled, regardless of &lt;strong&gt;callback mode&lt;/strong&gt;, automatically &lt;code&gt; call the state callback &lt;/code&gt; with special arguments whenever the state changes so you can write state enter actions near the rest of the &lt;strong&gt;state transition&lt;/strong&gt; rules. It typically looks like this:</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 에 이 옵션을 사용하는 경우 동작에 상관없이 할 수 &lt;strong&gt;콜백 모드&lt;/strong&gt; , 자동 &lt;code&gt; call the state callback &lt;/code&gt; 이 상태를 쓸 수 있도록 상태 변화가 나머지에 가까운 작업을 입력 할 때마다 특별한 인수와 &lt;strong&gt;상태 전이&lt;/strong&gt; 규칙을. 일반적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9bfee8de64aaf220d4aeed1c41aab972dbfcbf33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; behaviour supports two &lt;strong&gt;callback modes&lt;/strong&gt;:</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 의 동작이 개 지원 &lt;strong&gt;콜백 모드&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="202063559580002e499e6f482887a341d2fb543d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; calls the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;{call,From}&lt;/code&gt; and event content &lt;code&gt;Request&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 가 부르는 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;{call,From}&lt;/code&gt; 및 이벤트 콘텐츠 &lt;code&gt;Request&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb6f22901bf82daa00ca3a8e82f1d85e746f57f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; does a &lt;strong&gt;state transition&lt;/strong&gt; to &lt;code&gt;NextState&lt;/code&gt; (which can be the same as the current state), sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;. If &lt;code&gt;NextState =/= CurrentState&lt;/code&gt; the &lt;strong&gt;state transition&lt;/strong&gt; is a &lt;strong&gt;state change&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 는 않는 &lt;strong&gt;상태 천이&lt;/strong&gt; 에 대한 &lt;code&gt;NextState&lt;/code&gt; (현재 상태와 동일 할 수있다)을 설정 &lt;code&gt;NewData&lt;/code&gt; , 모든 실행 &lt;code&gt;Actions&lt;/code&gt; . 경우 &lt;code&gt;NextState =/= CurrentState&lt;/code&gt; &lt;strong&gt;상태 천이&lt;/strong&gt; A는 &lt;strong&gt;상태 변화&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="17680806ff10db88faa8089ccb57cda1bbf46d1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; does a state transition to &lt;code&gt;NextState&lt;/code&gt; (which can be the same as the current state), sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 는 로 상태 천이하지 &lt;code&gt;NextState&lt;/code&gt; (현재 상태와 동일 할 수있다)을 설정 &lt;code&gt;NewData&lt;/code&gt; , 모든 실행 &lt;code&gt;Actions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b1ba800b2bd8eddab3c29205a82310973e51fec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; does a state transition to &lt;code&gt;State&lt;/code&gt;, which has to be the current state, sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 가 에 대한 상태 전이 않는 &lt;code&gt;State&lt;/code&gt; 현재 상태이어야한다, 설정 &lt;code&gt;NewData&lt;/code&gt; , 모든 실행 &lt;code&gt;Actions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3869ef62f08e2a10aa5bf3ec284cea8fd875bec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; engine can automatically make a specialized call to the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; whenever a new state is entered; see &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter()&lt;/a&gt;&lt;/code&gt;. This is for writing code common to all state entries. Another way to do it is to explicitly insert an event at the &lt;strong&gt;state transition&lt;/strong&gt;, and/or to use a dedicated &lt;strong&gt;state transition&lt;/strong&gt; function, but that is something you will have to remember at every &lt;strong&gt;state transition&lt;/strong&gt; to the state(s) that need it.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 의 엔진은 자동으로 전문 호출 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 새로운 상태가 입력 될 때마다; &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter()&lt;/a&gt;&lt;/code&gt; 참조하십시오 . 이것은 모든 상태 항목에 공통적 인 코드를 작성하기위한 것입니다. 이를 수행하는 또 다른 방법은 &lt;strong&gt;상태 전환에&lt;/strong&gt; 이벤트를 명시 적으로 삽입 하거나 전용 &lt;strong&gt;상태 전환&lt;/strong&gt; 함수 를 사용하는 것입니다 . 그러나 이는 &lt;strong&gt;상태 전환&lt;/strong&gt; 이 필요한 &lt;strong&gt;상태로 전환&lt;/strong&gt; 될 때마다 기억 해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ff91dbdb67dc0752a1cb136935a70afdac9c712" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; engine can automatically make a specialized call to the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; whenever a new state is entered; see &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter()&lt;/a&gt;&lt;/code&gt;. This is for writing code common to all state entries. Another way to do it is to insert an event at the state transition, and/or to use a dedicated state transition function, but that is something you will have to remember at every state transition to the state(s) that need it.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 의 엔진은 자동으로 전문 호출 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 새로운 상태가 입력 될 때마다; &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter()&lt;/a&gt;&lt;/code&gt; 참조하십시오 . 모든 상태 항목에 공통적 인 코드를 작성하기위한 것입니다. 이를 수행하는 또 다른 방법은 상태 전이에서 이벤트를 삽입하거나 전용 상태 전이 기능을 사용하는 것입니다. 그러나 모든 상태 전이에서 필요한 상태로 전환 할 때 기억해야합니다.</target>
        </trans-unit>
        <trans-unit id="298787bc0880c606f6d382d6ec4eea28eb66cd16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; engine will find out the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt; &lt;strong&gt;callback mode&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; of &lt;code&gt;NewModule&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt; NewModule:callback_mode/0 &lt;/a&gt;&lt;/code&gt; before the next &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 의 엔진은 발견 할 것이다 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt; &lt;strong&gt;callback mode&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;NewModule&lt;/code&gt; 를 호출하여 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt; NewModule:callback_mode/0 &lt;/a&gt;&lt;/code&gt; 다음 이전 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; . &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="609a55f5722ed6b61803cc1734f944814dbce653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; enqueues incoming events in order of arrival and presents these to the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; in that order. The state callback can postpone an event so it is not retried in the current state. After a state change the queue restarts with the postponed events.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 는 받는 도착 선물이 순서대로 들어오는 이벤트를 큐에 넣 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 순서입니다. 상태 콜백은 현재 상태에서 재 시도되지 않도록 이벤트를 연기 할 수 있습니다. 상태 변경 후 연기 된 이벤트와 함께 큐가 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="63345530db17175adac9ec3a019543d210266d03" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; event queue model is sufficient to emulate the normal process message queue with selective receive. Postponing an event corresponds to not matching it in a receive statement, and changing states corresponds to entering a new receive statement.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 이벤트 큐 모델 선택 수신하여 정상 프로세스 메시지 큐를 에뮬레이트하기에 충분하다. 이벤트 연기는 receive 문에서 이벤트와 일치하지 않는 것에 해당하며 상태 변경은 새 receive 문 입력에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="641237d979ff0a2d03c26c3ad66f07cb507fd0a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; has been set to trap exit signals.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 는 트랩 출구 신호로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="154bbf6641ffd5663c5aefea121dd325520717a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; is globally registered in &lt;code&gt;global&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 는 전 세계적으로 등록 된 &lt;code&gt;global&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67b6a4a7c1fd3b7590f8afba5f3bf9c9be4abb6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; is locally registered on another node.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 는 로컬 다른 노드에 등록된다.</target>
        </trans-unit>
        <trans-unit id="85f1bfb26c1bebdbfe3ea8eee17c7ba7fcaa85f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; is locally registered.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 는 로컬로 등록된다.</target>
        </trans-unit>
        <trans-unit id="dff17e2a1fe994c2de42244386fbbe29172ce5a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; is registered in an alternative process registry. The registry callback module &lt;code&gt;RegMod&lt;/code&gt; is to export functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is the same as &lt;code&gt;{global,GlobalName}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 는 다른 프로세스 레지스트리에 등록됩니다. 레지스트리 콜백 모듈 &lt;code&gt;RegMod&lt;/code&gt; 는 &lt;code&gt;global&lt;/code&gt; 에서 해당 함수처럼 동작하는 &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , &lt;code&gt;whereis_name/1&lt;/code&gt; 및 &lt;code&gt;send/2&lt;/code&gt; 함수를 내보내는 것 입니다. 따라서 &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; 은 &lt;code&gt;{global,GlobalName}&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f744ffe4f5b7b57ef92ebf70203f5d38f475257a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; keeps the current state and data, or does a state transition to the current state if you like, and executes all &lt;code&gt;Actions&lt;/code&gt;. This is the same as &lt;code&gt;{repeat_state,CurrentData,Actions}&lt;/code&gt;. If the &lt;code&gt;gen_statem&lt;/code&gt; runs with &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, the state enter call is repeated, see type &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;repeat_state_and_data&lt;/code&gt; is the same as &lt;code&gt;keep_state_and_data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 는 현재 상태와 데이터를 유지, 또는 당신이 좋아하는 경우에 현재의 상태로 상태 전이를 수행하고, 모든 실행 &lt;code&gt;Actions&lt;/code&gt; . 이것은 &lt;code&gt;{repeat_state,CurrentData,Actions}&lt;/code&gt; 와 동일 합니다. 는 IF &lt;code&gt;gen_statem&lt;/code&gt; 의 와 실행 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; , 상태는, 호출이 반복 입력 타입 참조 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; , 그렇지 않으면, &lt;code&gt;repeat_state_and_data&lt;/code&gt; 은 동일하다 &lt;code&gt;keep_state_and_data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d475ad84f6e39a68e71be16a98a5f4760d76809d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; keeps the current state or does a state transition to the current state if you like, keeps the current server data, and executes all &lt;code&gt;Actions&lt;/code&gt;. This is the same as &lt;code&gt;{next_state,CurrentState,CurrentData,Actions}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 은 현재 상태를 유지하거나 만약 당신이 좋아하면, 현재의 상태로 상태 전이를 수행, 현재 서버의 데이터를 유지하고, 모든 실행 &lt;code&gt;Actions&lt;/code&gt; . &lt;code&gt;{next_state,CurrentState,CurrentData,Actions}&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="6668d570fa47d65dc6496ac8a7e26666fa0a0e00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; keeps the current state, or does a state transition to the current state if you like, sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;. If the &lt;code&gt;gen_statem&lt;/code&gt; runs with &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, the state enter call is repeated, see type &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;repeat_state&lt;/code&gt; is the same as &lt;code&gt;keep_state&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 은 현재 상태를 유지, 또는 당신이 좋아하는 경우에 현재의 상태로 상태 전이를 수행, 설정 &lt;code&gt;NewData&lt;/code&gt; , 모든 실행 &lt;code&gt;Actions&lt;/code&gt; . 는 IF &lt;code&gt;gen_statem&lt;/code&gt; 의 와 실행 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; , 상태는, 호출이 반복 입력 타입 참조 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;repeat_state&lt;/code&gt; 과 동일 &lt;code&gt;keep_state&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d700edd0442a4b2cb750903fd91d19af04ce58f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; keeps the current state, or does a state transition to the current state if you like, sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;. This is the same as &lt;code&gt;{next_state,CurrentState,NewData,Actions}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 은 현재 상태를 유지, 또는 당신이 좋아하는 경우에 현재의 상태로 상태 전이를 수행, 설정 &lt;code&gt;NewData&lt;/code&gt; , 모든 실행 &lt;code&gt;Actions&lt;/code&gt; . &lt;code&gt;{next_state,CurrentState,NewData,Actions}&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="8501d306024ff238059935aefd0de35838afe886" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; to initialize the server. To ensure a synchronized startup procedure, &lt;code&gt;start_link/3,4&lt;/code&gt; does not return until &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; has returned.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 의 프로세스를 호출 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 서버를 초기화 할 수 있습니다. 동기화 된 시작 절차를 보장하기 위해 &lt;code&gt;start_link/3,4&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 이 반환 될 때까지 반환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="238d457fbc3808fc222aef2d6327199e92b50362" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; process can go into hibernation; see &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;. It is done when a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; specifies &lt;code&gt;hibernate&lt;/code&gt; in the returned &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; list. This feature can be useful to reclaim process heap memory while the server is expected to be idle for a long time. However, use this feature with care, as hibernation can be too costly to use after every event; see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 의 최대 절전 모드로 갈 수있는 공정; &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 . &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 이 반환 된 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; 목록 에서 &lt;code&gt;hibernate&lt;/code&gt; 를 지정할 때 수행됩니다 . 이 기능은 서버가 오랫동안 유휴 상태 일 것으로 예상되는 동안 프로세스 힙 메모리를 회수하는 데 유용 할 수 있습니다. 그러나 최대 절전 모드는 모든 이벤트 후에 사용하기에는 비용이 너무 많이들 수 있으므로이 기능을주의해서 사용하십시오. &lt;code&gt;erlang:hibernate/3&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a3de78075e1ead85abb08c9961b0132a2121787" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; process can go into hibernation; see &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;. It is done when a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; specifies &lt;code&gt;hibernate&lt;/code&gt; in the returned &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; list. This feature can be useful to reclaim process heap memory while the server is expected to be idle for a long time. However, use this feature with care, as hibernation can be too costly to use after every event; see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 의 최대 절전 모드로 갈 수있는 공정; &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 . &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 이 리턴 된 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; 목록 에서 &lt;code&gt;hibernate&lt;/code&gt; 를 지정 하면 완료됩니다 . 이 기능은 서버가 오랫동안 유휴 상태 인 동안 프로세스 힙 메모리를 회수하는 데 유용 할 수 있습니다. 그러나 최대 절전 모드는 모든 이벤트 후에 사용하기에는 너무 많은 비용이들 수 있으므로이 기능을주의해서 사용하십시오. &lt;code&gt;erlang:hibernate/3&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="881ead844dbebfad51980a814a9a4905aa6bf4c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; terminates abnormally and logs an error. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;terminate&lt;/code&gt; for this case.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 가 비정상적으로 종료하고 오류를 기록합니다. 이 경우에는 &lt;code&gt;Opt&lt;/code&gt; 가 원자 &lt;code&gt;terminate&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="98d014159aa311c58e42eb49a30b95ce56872c5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get-bulk&lt;/code&gt; operation for transferring large amounts of data.</source>
          <target state="translated">&lt;code&gt;get-bulk&lt;/code&gt; 많은 양의 데이터를 전송하기위한 작업.</target>
        </trans-unit>
        <trans-unit id="ca7aa99a53f77bb03e023a14cb8a5dfa322719fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;realm&lt;/code&gt; filters cause the Destination-Host and Destination-Realm AVPs to be extracted from the outgoing request, assuming it to be a record- or list-valued &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_codec#message&quot;&gt;diameter_codec:message()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;, and assuming at most one of each AVP. If this is not the case then the &lt;code&gt;{host|realm, &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;}&lt;/code&gt; filters must be used to achieve the desired result. An empty &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; (which should not be typical) matches all hosts/realms for the purposes of filtering.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; 및 &lt;code&gt;realm&lt;/code&gt; 목적지 호스트 및 목적지 - 영역의 AVPs 원인 필터 발신 요구로부터 추출 그것이 기록 - 또는 목록 값으로 가정 할 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_codec#message&quot;&gt;diameter_codec:message()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; , 각 AVP 많아야 하나 가정. 그렇지 않은 경우 원하는 결과를 얻으려면 &lt;code&gt;{host|realm, &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;}&lt;/code&gt; 필터를 사용해야합니다. 비어있는 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; (일반적이어서는 안 됨)는 필터링을 위해 모든 호스트 / 영역과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1384604d97fc2fad058cb0b49328402f702a9c11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;host&lt;/code&gt; was successfully decoded but the path contains at least one character with non-UTF-8 encoding. In order to be able to decode this, you have to make assumptions about the encoding used in these triplets. The most obvious choice is</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; 성공적으로 디코딩되지만 경로 않는 UTF-8 인코딩 적어도 하나의 문자가 포함되었다. 이것을 디코딩 할 수 있으려면이 트리플렛에 사용되는 인코딩에 대해 가정해야합니다. 가장 확실한 선택은</target>
        </trans-unit>
        <trans-unit id="6d366d9713f6b9c72596126187499371839fd52b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i&lt;/code&gt; module provides short forms for some of the functions used by the graphical Debugger and some of the functions in module &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;, the Erlang interpreter.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 모듈은 그래픽 디버거에 의해 사용되는 일부 기능 및 모듈의 기능 중 일부에 대한 단문 제공 &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; , 얼랑 인터프리터.</target>
        </trans-unit>
        <trans-unit id="d1d8b2c5a7a92df360a05d4f0b328a8a9dec2469" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i_fast_element/2&lt;/code&gt; instruction is faster because the tuple is already an untagged integer. It also knows that the index is at least 1, so it does not have to test for that. The &lt;code&gt;i_element/4&lt;/code&gt; instruction will have to fetch the index from a register, test that it is an integer, and untag the integer.</source>
          <target state="translated">&lt;code&gt;i_fast_element/2&lt;/code&gt; 튜플 이미 태그가 지정되지 않은 정수이기 때문에 명령이 빠릅니다. 또한 인덱스가 1 이상임을 알고 있으므로이를 테스트 할 필요가 없습니다. &lt;code&gt;i_element/4&lt;/code&gt; 명령은 정수인지 테스트 및 언 태그 정수, 레지스터에서 인덱스를 가져올 것이다.</target>
        </trans-unit>
        <trans-unit id="ffe8d3c73461c97195740001f84500385e3636a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i_increment&lt;/code&gt; instruction is implemented like this:</source>
          <target state="translated">&lt;code&gt;i_increment&lt;/code&gt; 명령은 다음과 같이 구현됩니다 :</target>
        </trans-unit>
        <trans-unit id="56dd7d3b9f60436a9a9021776dba220b9a35a843" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; header represents the number of unique identifiers under a class when the option &lt;code&gt;{combine, true}&lt;/code&gt; is used (which is on by default). It will otherwise show the specific identifier. The &lt;code&gt;db_tab&lt;/code&gt; listing shows 722287 unique locks, it is one for each ets-table created and Mnesia creates one for each transaction.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 헤더는 옵션 클래스에서 고유 식별자의 수를 나타냅니다 &lt;code&gt;{combine, true}&lt;/code&gt; (기본적으로 설정되어 있습니다) 사용됩니다. 그렇지 않으면 특정 식별자가 표시됩니다. &lt;code&gt;db_tab&lt;/code&gt; 쇼에게 722,287 독특한 잠금 목록, 그것은 만든 각 ETS-테이블 하나입니다 Mnesia는 각 거래에 대해 하나 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0fc657f0d7c1adea0e37abaf50e5955d09748ddb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; key is mandatory.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 키는 필수입니다.</target>
        </trans-unit>
        <trans-unit id="543a86a9dbb014f2154dac485e637aa4987d5f47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index()&lt;/code&gt; type denotes an snmp index structure.</source>
          <target state="translated">&lt;code&gt;index()&lt;/code&gt; 유형은 SNMP의 인덱스 구조를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="9e43b2120ef1641713607a20d5663b50e4bfd154" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;info&lt;/code&gt; field of a &lt;code&gt;&lt;a href=&quot;#service_event&quot;&gt;service_event()&lt;/a&gt;&lt;/code&gt; record. Can have one of the following types.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#service_event&quot;&gt;service_event()&lt;/a&gt;&lt;/code&gt; 레코드 의 &lt;code&gt;info&lt;/code&gt; 필드 다음 유형 중 하나를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a3e0c6a3b85d7da20be620618cd94e4069d8c32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;info&lt;/code&gt; functions return information as a list of pairs {Tag, term()} in some order about the state and the &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; of an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;info&lt;/code&gt; 기능 쌍 상태에 대한 어떤 순서로 {태그, 용어 ()}와 목록 등의 정보를 반환 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe1b7238dd78cc738fd7a6138cfed66a0946104d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init:get_arguments()&lt;/code&gt; call verifies that the correct arguments are supplied to the emulator.</source>
          <target state="translated">&lt;code&gt;init:get_arguments()&lt;/code&gt; 올바른 인수가 에뮬레이터에 공급되는 통화 확인합니다.</target>
        </trans-unit>
        <trans-unit id="de26f216cc9cb8c745717da43fc15ae4239618cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init&lt;/code&gt; module interprets the following command-line flags:</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; 모듈 해석 다음 명령 줄 플래그 :</target>
        </trans-unit>
        <trans-unit id="9159e5b3d2da59b16c5905eba93189ce3aa15286" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init&lt;/code&gt; process itself interprets some of these flags, the &lt;strong&gt;init flags&lt;/strong&gt;. It also stores any remaining flags, the &lt;strong&gt;user flags&lt;/strong&gt;. The latter can be retrieved by calling &lt;code&gt;init:get_argument/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; 과정 자체는 이러한 플래그 중 일부는 해석 &lt;strong&gt;초기화하기 플래그&lt;/strong&gt; . 또한 나머지 플래그 인 &lt;strong&gt;사용자 플래그&lt;/strong&gt; 도 저장합니다 . 후자는 &lt;code&gt;init:get_argument/1&lt;/code&gt; 을 호출하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="808f537737de60102eb2d48a20a77f05a231d51c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init_fun()&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;#type-tar_crypto_spec&quot;&gt;tar_crypto_spec&lt;/a&gt;&lt;/code&gt; is applied once prior to any other &lt;code&gt;crypto&lt;/code&gt; operation. The intention is that this function initiates the encryption or decryption for example by calling &lt;code&gt;crypto:crypto_init/4&lt;/code&gt; or similar. The &lt;code&gt;crypto_state()&lt;/code&gt; is the state such a function may return.</source>
          <target state="translated">&lt;code&gt;init_fun()&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;#type-tar_crypto_spec&quot;&gt;tar_crypto_spec&lt;/a&gt;&lt;/code&gt; 는 임의의 다른 이전에 한번 적용되는 &lt;code&gt;crypto&lt;/code&gt; 동작. 의도는이 함수가 예를 들어 &lt;code&gt;crypto:crypto_init/4&lt;/code&gt; 또는 유사한 호출을 통해 암호화 또는 복호화를 시작하는 것 입니다. &lt;code&gt;crypto_state()&lt;/code&gt; 이러한 기능이 반환 될 상태이다.</target>
        </trans-unit>
        <trans-unit id="a00463fc2a7f182be0da0183c5213eee9fd19f70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;insert_emp/3&lt;/code&gt; arguments are as follows:</source>
          <target state="translated">&lt;code&gt;insert_emp/3&lt;/code&gt; 다음과 같이 인수는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="35e63d83642fa80f496dd6056b90a430ea6b3ddf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;io&lt;/code&gt; module has been extended along with the actual I/O protocol to handle Unicode data. This means that many functions require binaries to be in UTF-8, and there are modifiers to format control sequences to allow for output of Unicode strings.</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; 모듈은 유니 코드 데이터를 처리하기위한 실제 I / O 프로토콜에 따라 연장되고있다. 이것은 많은 함수들이 바이너리가 UTF-8이어야한다는 것을 의미하며, 유니 코드 문자열의 출력을 허용하기 위해 제어 시퀀스를 포맷팅하기위한 수정자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="abc6624cbf5af8be037d2670ec76b72f4b7f1113" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ip&lt;/code&gt; Reference ID takes an &lt;code&gt;inet:ip_address()&lt;/code&gt; or an ip address in string format (E.g &quot;10.0.1.1&quot; or &quot;1234::5678:9012&quot;) as second element.</source>
          <target state="translated">&lt;code&gt;ip&lt;/code&gt; 기준 ID가 얻어 &lt;code&gt;inet:ip_address()&lt;/code&gt; 또는 문자열 포맷 (예 : &quot;10.0.1.1&quot;또는 &quot;1234 : 5678 : 9012 ')의 IP 주소 등을 제 소자.</target>
        </trans-unit>
        <trans-unit id="a7ee8c582d46917ec81790ab0ac53e2589a28393" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;is_set_ok&lt;/code&gt; function checks that a row which is to be modified or deleted exists, and that a row which is to be created does not exist.</source>
          <target state="translated">&lt;code&gt;is_set_ok&lt;/code&gt; 의 기능 검사 수정 또는 삭제하고자하는 행이 존재하는 것으로하고, 형성되어야 할 행이 존재하지 않음.</target>
        </trans-unit>
        <trans-unit id="3f824fe79494e6524fbde8189315044778985916" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jer&lt;/code&gt; encoding rules (ITU-T X.697) are experimental in OTP 22. There is support for a subset of the X.697 standard, for example there is no support for:</source>
          <target state="translated">&lt;code&gt;jer&lt;/code&gt; 부호화 규칙 (ITU-T X.697)는 X.697 표준의 서브 세트에 대한 지원이있다 OTP 22에서 실험, 예를 들면 대한 지원이 없습니다</target>
        </trans-unit>
        <trans-unit id="ff7f1bbdc59c16a06c62efdccc8b7854b7407424" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key()&lt;/code&gt; type correlates to the &lt;code&gt;key_types()&lt;/code&gt; type. If the &lt;code&gt;key_types()&lt;/code&gt; is a single atom, the corresponding &lt;code&gt;key()&lt;/code&gt; is a single type as well, but if the &lt;code&gt;key_types()&lt;/code&gt; is a tuple, &lt;code&gt;key&lt;/code&gt; must be a tuple of the same size.</source>
          <target state="translated">&lt;code&gt;key()&lt;/code&gt; 받는 유형의 상관 관계 &lt;code&gt;key_types()&lt;/code&gt; 형입니다. 경우] &lt;code&gt;key_types()&lt;/code&gt; 단일 원자이고, 해당 &lt;code&gt;key()&lt;/code&gt; 뿐만 아니라 하나의 형태이지만, 경우 &lt;code&gt;key_types()&lt;/code&gt; 튜플이고, &lt;code&gt;key&lt;/code&gt; 크기가 같은 튜플이어야한다.</target>
        </trans-unit>
        <trans-unit id="5cac72dd809c7185a7dcb83183f4f89c08277c85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key_types()&lt;/code&gt; type defines the types of the SNMP INDEX columns for the table. If the table has one single INDEX column, this type should be a single atom, but if the table has multiple INDEX columns, it should be a tuple with atoms.</source>
          <target state="translated">&lt;code&gt;key_types()&lt;/code&gt; 유형은 테이블에 대한 SNMP INDEX 컬럼의 유형을 정의합니다. 테이블에 단일 INDEX 열이있는 경우이 유형은 단일 원자 여야하지만 테이블에 여러 INDEX 열이있는 경우 원자가있는 튜플이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a81df154de4b4c4f859872829034600f9ab7e463" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key_types()&lt;/code&gt; type is used when creating the index structure, and the &lt;code&gt;key()&lt;/code&gt; type is used when inserting and deleting items from the structure.</source>
          <target state="translated">&lt;code&gt;key_types()&lt;/code&gt; 인덱스 구조를 생성 할 때 입력이 사용되고, &lt;code&gt;key()&lt;/code&gt; 삽입 한 구조의 항목 유형을 삭제할 때 사용된다.</target>
        </trans-unit>
        <trans-unit id="555d2dccfadbf0b7e5219e84813fd3bd45eaaf5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keypos&lt;/code&gt; of the table dumped to file, which is used when loading the table again.</source>
          <target state="translated">테이블 의 키 &lt;code&gt;keypos&lt;/code&gt; 는 파일에 덤프되어 테이블을 다시로드 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f7afe180cd162bc0e597b4a20726157b5ac4e0bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;killproc&lt;/code&gt; procedure is not to be removed. The purpose is here to move from run level 3 (multi-user mode with networking resources) to run level 2 (multi-user mode without such resources), in which Erlang is not to run.</source>
          <target state="translated">&lt;code&gt;killproc&lt;/code&gt; 의 절차는 제거 할 수 없습니다. Erlang이 실행되지 않는 실행 레벨 3 (네트워킹 자원이있는 다중 사용자 모드)에서 실행 레벨 2 (이러한 자원이없는 다중 사용자 모드)로 이동하는 것이 목적입니다.</target>
        </trans-unit>
        <trans-unit id="03c484e3840400c5a5e9dd6a195fc19b5d1faa2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; component is a term which identifies all events belonging to the same sequential trace. If several sequential traces can be active simultaneously, &lt;code&gt;label&lt;/code&gt; is used to identify the separate traces. Default is 0.</source>
          <target state="translated">&lt;code&gt;label&lt;/code&gt; 구성 요소는 동일한 연속 추적에 속하는 모든 이벤트를 식별하는 용어입니다. 여러 순차 추적을 동시에 활성화 할 수있는 경우 &lt;code&gt;label&lt;/code&gt; 을 사용하여 개별 추적을 식별합니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="8ada4b47638c77da9291a9bd47140e9b15fe504a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest_free&lt;/code&gt; and &lt;code&gt;number_of_free&lt;/code&gt; tags are currently only returned on a VxWorks system.</source>
          <target state="translated">&lt;code&gt;largest_free&lt;/code&gt; 및 &lt;code&gt;number_of_free&lt;/code&gt; 태그는 현재 만 Vx 웍스 시스템에 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="47c985889700e94be33eba8b924bf9a3dfed0540" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lcnt&lt;/code&gt; module is used to profile the internal ethread locks in the Erlang Runtime System. With &lt;code&gt;lcnt&lt;/code&gt; enabled, internal counters in the runtime system are updated each time a lock is taken. The counters stores information about the number of acquisition tries and the number of collisions that has occurred during the acquisition tries. The counters also record the waiting time a lock has caused for a blocked thread when a collision has occurred.</source>
          <target state="translated">&lt;code&gt;lcnt&lt;/code&gt; 의 모듈 얼랑 런타임 시스템의 내부 ETHREAD 잠금 프로파일 사용된다. 함께 &lt;code&gt;lcnt&lt;/code&gt; 이 활성화 런타임 시스템 내부 카운터는 잠금이 수행 될 때마다 업데이트됩니다. 카운터에는 획득 시도 횟수 및 획득 시도 중에 발생한 충돌 횟수에 대한 정보가 저장됩니다. 카운터는 충돌이 발생할 때 차단 된 스레드에 대해 잠금이 발생한 대기 시간도 기록합니다.</target>
        </trans-unit>
        <trans-unit id="b187fc5e5c5e9c948af3fd95dc59f5d10e6fe566" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;list_in&lt;/code&gt; term must belong to environment &lt;code&gt;env&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;list_in&lt;/code&gt; 의 용어는 환경에 속해야합니다 &lt;code&gt;env&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2831975c1bbe04314d3d0e20134569769f4c8e7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;log_mf_h&lt;/code&gt; handler writes all reports to a report logging directory, which is specified when configuring the SASL application.</source>
          <target state="translated">&lt;code&gt;log_mf_h&lt;/code&gt; 의 핸들러는 SASL 응용 프로그램을 구성 할 때 지정 보고서 로깅 디렉토리로 모든 보고서를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="c42c9a83ba0cfd927135745afcf8a51d16e0e657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;map_in&lt;/code&gt; term must belong to environment &lt;code&gt;env&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map_in&lt;/code&gt; 의 용어는 환경에 속해야합니다 &lt;code&gt;env&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4596e3e12adaafb27a37675223c89e5e8290b48e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;match_fun&lt;/code&gt; takes two arguments and returns either &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;. The value &lt;code&gt;default&lt;/code&gt; will invoke the default match function.</source>
          <target state="translated">&lt;code&gt;match_fun&lt;/code&gt; 는 두 개의 인수 및 반환 소요 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;default&lt;/code&gt; . 값 &lt;code&gt;default&lt;/code&gt; 기본 match 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="8b940d5eaace9d3d7a8384b7f450246290a324ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;max_path_length&lt;/code&gt; is the maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if &lt;code&gt;max_path_length&lt;/code&gt; is 0, the PEER must be signed by the trusted ROOT-CA directly, if it is 1, the path can be PEER, CA, ROOT-CA, if it is 2, the path can be PEER, CA, CA, ROOT-CA, and so on.</source>
          <target state="translated">&lt;code&gt;max_path_length&lt;/code&gt; 는 유효한 인증 경로에서 피어 인증서를 따를 수 자기 발행이 아닌 중간 인증서의 최대 수입니다. 따라서 &lt;code&gt;max_path_length&lt;/code&gt; 가 0이면 신뢰할 수있는 ROOT-CA가 PEER에 직접 서명해야합니다. 1 인 경우 경로는 PEER, CA, ROOT-CA 일 수 있습니다. 2 인 경우 경로는 PEER, CA, CA, ROOT-CA 등</target>
        </trans-unit>
        <trans-unit id="38b7f85ec648548ce222a27921a129e6b78760bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mib_to_hrl&lt;/code&gt; generator can be invoked from the OS command line by using the command &lt;code&gt;erlc&lt;/code&gt;. &lt;code&gt;erlc&lt;/code&gt; recognizes the extension &lt;code&gt;.bin&lt;/code&gt;, and invokes this function for files with that extension.</source>
          <target state="translated">&lt;code&gt;mib_to_hrl&lt;/code&gt; 의 발생기는 명령을 사용하여 OS 명령 라인에서 호출 할 수 &lt;code&gt;erlc&lt;/code&gt; 를 . &lt;code&gt;erlc&lt;/code&gt; 는 확장자 &lt;code&gt;.bin&lt;/code&gt; 을 인식하고 해당 확장자를 가진 파일에 대해이 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="8c1d578ccfe04ced0a4858e6e98da0fd19d29b4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mods_and_procs&lt;/code&gt; and &lt;code&gt;funcs_and_procs&lt;/code&gt; filters are equivalent to the &lt;code&gt;modules&lt;/code&gt; and &lt;code&gt;functions&lt;/code&gt; filters respectively, except that each module or function can have many vertical lines, one for each process it resides on.</source>
          <target state="translated">&lt;code&gt;mods_and_procs&lt;/code&gt; 및 &lt;code&gt;funcs_and_procs&lt;/code&gt; 의 필터는 동등한 &lt;code&gt;modules&lt;/code&gt; 및 &lt;code&gt;functions&lt;/code&gt; 각 모듈 또는 기능이 다양한 수직선이 상주하는 각 공정을 가질 수 있다는 것을 제외하고는, 각각의 필터.</target>
        </trans-unit>
        <trans-unit id="629670db402f7cde732ec01282578c7159f3daad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; option makes it possible for the user to provide their own callback module. The &lt;code&gt;receive_message/4&lt;/code&gt; or &lt;code&gt;process_received_message/4&lt;/code&gt; functions of this module is called when a new message is received (which one depends on the size of the message; small - receive_message, large - process_received_message). Default value is &lt;strong&gt;megaco&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 옵션은 가능한 사용자가 자신의 콜백 모듈을 제공 할 수 있습니다. 이 모듈 의 &lt;code&gt;receive_message/4&lt;/code&gt; 또는 &lt;code&gt;process_received_message/4&lt;/code&gt; 함수는 새 메시지가 수신 될 때 호출됩니다 (메시지의 크기에 따라 다릅니다. small-receive_message, large-process_received_message). 기본값은 &lt;strong&gt;megaco&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4039dc8c38a872b706a72298a0693bdeed53b2b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; option makes it possible for the user to provide their own callback module. The functions &lt;code&gt;receive_message/4&lt;/code&gt; or &lt;code&gt;process_received_message/4&lt;/code&gt; of this module is called when a new message is received (which one depends on the size of the message; small - receive_message, large - process_received_message). Default value is &lt;strong&gt;megaco&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 옵션은 가능한 사용자가 자신의 콜백 모듈을 제공 할 수 있습니다. 이 모듈의 &lt;code&gt;receive_message/4&lt;/code&gt; 또는 &lt;code&gt;process_received_message/4&lt;/code&gt; 함수 는 새 메시지가 수신 될 때 호출됩니다 (메시지 크기에 따라 다릅니다. small-receive_message, large-process_received_message). 기본값은 &lt;strong&gt;megaco&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1fa747bd68db4bc817397fca349049b0c0c2bdc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module_info/0&lt;/code&gt; function in each module, returns a list of &lt;code&gt;{Key,Value}&lt;/code&gt; tuples with information about the module. Currently, the list contain tuples with the following &lt;code&gt;Key&lt;/code&gt;s: &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;attributes&lt;/code&gt;, &lt;code&gt;compile&lt;/code&gt;, &lt;code&gt;exports&lt;/code&gt;, &lt;code&gt;md5&lt;/code&gt; and &lt;code&gt;native&lt;/code&gt;. The order and number of tuples may change without prior notice.</source>
          <target state="translated">각 모듈 의 &lt;code&gt;module_info/0&lt;/code&gt; 함수는 모듈에 대한 정보와 함께 &lt;code&gt;{Key,Value}&lt;/code&gt; 튜플 목록을 리턴 합니다. 현재 목록은 다음과 튜플 포함 &lt;code&gt;Key&lt;/code&gt; : S &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;attributes&lt;/code&gt; , &lt;code&gt;compile&lt;/code&gt; , &lt;code&gt;exports&lt;/code&gt; , &lt;code&gt;md5&lt;/code&gt; 및 &lt;code&gt;native&lt;/code&gt; . 튜플의 순서와 수는 사전 통지없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13c3af4d94c692779fc270d51ec8836243a76c6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;modules&lt;/code&gt; filter shows each module as a vertical line in the sequence diagram. External function calls/returns are shown as interactions between modules, and internal function calls/returns are shown as activities within a module.</source>
          <target state="translated">는 &lt;code&gt;modules&lt;/code&gt; 필터 프로그램을 시퀀스 다이어그램 수직선 각 모듈. 외부 함수 호출 / 반환은 모듈 간의 상호 작용으로 표시되고 내부 함수 호출 / 반환은 모듈 내 활동으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="220a661131b4c202e09615fa7794089d54019aa4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;modules&lt;/code&gt; key is optional. If it is not given, it defaults to &lt;code&gt;[M]&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; comes from the child's start &lt;code&gt;{M,F,A}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;modules&lt;/code&gt; 키는 선택 사항입니다. 지정하지 않으면 기본값은 &lt;code&gt;[M]&lt;/code&gt; 이며, 여기서 &lt;code&gt;M&lt;/code&gt; 은 자녀의 시작 &lt;code&gt;{M,F,A}&lt;/code&gt; 에서옵니다 .</target>
        </trans-unit>
        <trans-unit id="3890e0d50c45d6e12a18dbc1aec19b335349f526" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;modules&lt;/code&gt; key is optional. If it is not specified, it defaults to &lt;code&gt;[M]&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; comes from the child's start &lt;code&gt;{M,F,A}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;modules&lt;/code&gt; 키는 선택 사항입니다. 지정되지 않은 경우 기본값은 &lt;code&gt;[M]&lt;/code&gt; 이며 여기서 &lt;code&gt;M&lt;/code&gt; 은 자식의 시작 &lt;code&gt;{M,F,A}&lt;/code&gt; 에서옵니다 .</target>
        </trans-unit>
        <trans-unit id="b73b08f6879f5bf7ade5d9880f8cf1f512709fdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;native&lt;/code&gt; time unit is determined at runtime system start, and remains the same until the runtime system terminates. If a runtime system is stopped and then started again (even on the same machine), the &lt;code&gt;native&lt;/code&gt; time unit of the new runtime system instance can differ from the &lt;code&gt;native&lt;/code&gt; time unit of the old runtime system instance.</source>
          <target state="translated">&lt;code&gt;native&lt;/code&gt; 시간 단위는 런타임 시스템 시작시에 결정되고, 런타임 시스템이 종료 될 때까지 동일하게 유지된다. 런타임 시스템이 정지하고 (심지어 동일한 시스템에) 다시 시작하면, &lt;code&gt;native&lt;/code&gt; 새로운 런타임 시스템 인스턴스의 시간 단위는 다를 수 있습니다 &lt;code&gt;native&lt;/code&gt; 이전 런타임 시스템 인스턴스의 시간 단위.</target>
        </trans-unit>
        <trans-unit id="e77d232e74f552cf373975f9713b96716de00e8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;net_kernel&lt;/code&gt; process terminated.</source>
          <target state="translated">&lt;code&gt;net_kernel&lt;/code&gt; 의 프로세스가 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="33c94a1185ccb7943d79b55ac568ef3bf3963cc5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;net_ticktime&lt;/code&gt; changes must be initiated on all nodes in the network (with the same &lt;code&gt;NetTicktime&lt;/code&gt;) before the end of any transition period on any node; otherwise connections can erroneously be disconnected.</source>
          <target state="translated">&lt;code&gt;net_ticktime&lt;/code&gt; 의 변화가 (과 동일한 네트워크의 모든 노드에서 시작되어야 &lt;code&gt;NetTicktime&lt;/code&gt; 노드에서 임의의 천이 기간이 종료하기 전에); 그렇지 않으면 연결이 잘못 끊어 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88d35276b805d419b7b2b451eec9f43dfbe3fb9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;reuse&lt;/code&gt; options might seem convenient in a production system, but consider that the logs grow indefinitely during the system lifetime and cannot be truncated, except if the service is restarted.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 및 &lt;code&gt;reuse&lt;/code&gt; 옵션은 생산 시스템에 편리하게 보이지만, 로그는 서비스를 다시 시작하는 경우를 제외하고, 시스템 수명 기간 동안 무한정 성장하고 절단 될 수 없음을 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffcaa93ee15ba09c39cb246f4b83efb0388fde54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; function creates a new variable in the database with a default value as defined in the MIB, or a zero value (depending on the type).</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 기능은 MIB에 정의 된 바와 같은 디폴트 값 또는 0 값 (유형에 따라)와 데이터베이스에서 새로운 변수를 생성한다.</target>
        </trans-unit>
        <trans-unit id="2000d16d511f7d3865cad4dec402c68d50d75e6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; function creates the table if it does not exist, but only if the database is the SNMP internal db.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 존재하지 않는 경우 기능은 테이블을 생성하지만 경우에만 데이터베이스는 SNMP 내부 dB이다.</target>
        </trans-unit>
        <trans-unit id="2d170f32fbd322133bb3d50a0e41f54d86fe7d23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nteventlog&lt;/code&gt; module is used to implement &lt;code&gt;os_sup&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;nteventlog&quot;&gt;nteventlog(3)&lt;/a&gt;&lt;/code&gt;. Note that the start functions of &lt;code&gt;nteventlog&lt;/code&gt; does not need to be used, as in this case the process is started automatically as part of the OS_Mon supervision tree.</source>
          <target state="translated">&lt;code&gt;nteventlog&lt;/code&gt; 모듈을 구현하는 데 사용됩니다 &lt;code&gt;os_sup&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;nteventlog&quot;&gt;nteventlog(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 . &lt;code&gt;nteventlog&lt;/code&gt; 의 시작 기능은 사용할 필요가 없습니다.이 경우 프로세스는 OS_Mon 감독 트리의 일부로 자동으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="fe241cbaac0cb96b60c93ae96dc9889cf2b5f3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nteventlog&lt;/code&gt; module is used to implement &lt;code&gt;os_sup&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;nteventlog&quot;&gt;nteventlog(3)&lt;/a&gt;&lt;/code&gt;. Note that the start functions of &lt;code&gt;nteventlog&lt;/code&gt; does not need to be used, in this case the process is started automatically as part of the OS_Mon supervision tree.</source>
          <target state="translated">&lt;code&gt;nteventlog&lt;/code&gt; 모듈을 구현하는 데 사용됩니다 &lt;code&gt;os_sup&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;nteventlog&quot;&gt;nteventlog(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 . &lt;code&gt;nteventlog&lt;/code&gt; 의 시작 기능을 사용할 필요는 없습니다.이 경우 프로세스는 OS_Mon 감독 트리의 일부로 자동으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="e2bfdbeebfa5a9fe7cf75fe729c76e05070db8fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;obj&lt;/code&gt; argument is a pointer to the resource. The only allowed use for the resource in the destructor is to access its user data one final time. The destructor is guaranteed to be the last callback before the resource is deallocated.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 인수는 자원에 대한 포인터입니다. 소멸자의 리소스에 허용되는 유일한 용도는 마지막으로 사용자 데이터에 액세스하는 것입니다. 소멸자는 리소스 할당이 해제되기 전에 마지막 콜백이되도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="7ceb6922f1bc2b55a11a196aefd83fd27d2d6cd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;of&lt;/code&gt; operator returns &lt;code&gt;false&lt;/code&gt; if no chain of calls between the given constants can be found.</source>
          <target state="translated">&lt;code&gt;of&lt;/code&gt; 운영자는 반환 &lt;code&gt;false&lt;/code&gt; 주어진 상수 사이의 호출에는 체인이 발견되지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="edc8f1a9759344cda2be6a01281eb7cf8541e7d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;of&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, and &lt;code&gt;after&lt;/code&gt; sections are all optional, as long as there is at least a &lt;code&gt;catch&lt;/code&gt; or an &lt;code&gt;after&lt;/code&gt; section. So the following are valid &lt;code&gt;try&lt;/code&gt; expressions:</source>
          <target state="translated">&lt;code&gt;of&lt;/code&gt; , &lt;code&gt;catch&lt;/code&gt; , 그리고 &lt;code&gt;after&lt;/code&gt; 섹션은 한 적어도이있는 한, 모든 선택 사항 &lt;code&gt;catch&lt;/code&gt; 또는 &lt;code&gt;after&lt;/code&gt; 섹션. 따라서 다음은 유효한 &lt;code&gt;try&lt;/code&gt; 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="ebc057ad457a36d0493c7c4827deec0d89f9db4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;oid()&lt;/code&gt; type is used to represent an ASN.1 OBJECT IDENTIFIER.</source>
          <target state="translated">&lt;code&gt;oid()&lt;/code&gt; 유형은 ASN.1 객체 식별자를 나타내는 데 사용된다.</target>
        </trans-unit>
        <trans-unit id="c317ddfbc946c81f789ac77305cd9d495bd67257" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ordered_set&lt;/code&gt; works on the &lt;strong&gt;Erlang term order&lt;/strong&gt; and no defined order exists between an &lt;code&gt;integer()&lt;/code&gt; and a &lt;code&gt;float()&lt;/code&gt; that extends to the same value. Hence the key &lt;code&gt;1&lt;/code&gt; and the key &lt;code&gt;1.0&lt;/code&gt; are regarded as equal in an &lt;code&gt;ordered_set&lt;/code&gt; table.</source>
          <target state="translated">&lt;code&gt;ordered_set&lt;/code&gt; 온 작동 &lt;strong&gt;얼랑 용어 위해&lt;/strong&gt; 어떠한 정의 된 순서는 존재하지 사이 &lt;code&gt;integer()&lt;/code&gt; 및 &lt;code&gt;float()&lt;/code&gt; 와 동일한 값으로 연장한다. 따라서 키 &lt;code&gt;1&lt;/code&gt; 과 키 &lt;code&gt;1.0&lt;/code&gt; 은 &lt;code&gt;ordered_set&lt;/code&gt; 테이블 에서 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="23f84a949184c1de5bc030233161e9c4c0b92121" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;originating&lt;/code&gt; options effects discovery initiated by this agent.</source>
          <target state="translated">&lt;code&gt;originating&lt;/code&gt; 이 에이전트에 의해 시작 옵션 효과 발견.</target>
        </trans-unit>
        <trans-unit id="ccd973135b90cc097810c0c2b724141ea8487e4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;otp_patch_apply&lt;/code&gt; syntax:</source>
          <target state="translated">&lt;code&gt;otp_patch_apply&lt;/code&gt; 구문 :</target>
        </trans-unit>
        <trans-unit id="8bdd7004ea407fa82763663af39ba15a0e1f25f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;otp_patch_apply&lt;/code&gt; tool utilizes the &lt;code&gt;runtime_dependencies&lt;/code&gt; tag in the &lt;code&gt;application resource file&lt;/code&gt;. This information is used to determine if the patch can be installed in the given Erlang/OTP installation directory.</source>
          <target state="translated">&lt;code&gt;otp_patch_apply&lt;/code&gt; 도구는 사용 &lt;code&gt;runtime_dependencies&lt;/code&gt; 의 태그 &lt;code&gt;application resource file&lt;/code&gt; . 이 정보는 패치가 지정된 Erlang / OTP 설치 디렉토리에 설치 될 수 있는지 판별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8315d03358900e027c0447a981ac995840fffee4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;output&lt;/code&gt; function allocates the work area of the asynchronous function. As we use C++, we use a struct, and stuff the data in it. We must copy the original data, it is not valid after we have returned from the &lt;code&gt;output&lt;/code&gt; function, and the &lt;code&gt;do_perm&lt;/code&gt; function is called later, and from another thread. We return no data here, instead it is sent later from the &lt;code&gt;ready_async&lt;/code&gt; callback.</source>
          <target state="translated">&lt;code&gt;output&lt;/code&gt; 함수는 함수의 비동기 작업 영역을 할당한다. C ++을 사용할 때 구조체를 사용하고 그 안에 데이터를 넣습니다. 원래 데이터를 복사해야합니다. &lt;code&gt;output&lt;/code&gt; 함수 에서 리턴 된 후에는 유효하지 않으며 &lt;code&gt;do_perm&lt;/code&gt; 함수는 나중에 호출되며 다른 스레드에서 호출됩니다. 여기서는 데이터를 반환하지 않으며 대신 &lt;code&gt;ready_async&lt;/code&gt; 콜백 에서 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="71aa4ffe227f9aa33da51854c389c54a822efeef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parse&lt;/code&gt; format is an internal representation that can be passed to &lt;code&gt;&lt;a href=&quot;#flatten-1&quot;&gt;flatten/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#format-1&quot;&gt;format/1&lt;/a&gt;&lt;/code&gt;, while the &lt;code&gt;forms&lt;/code&gt; format can be passed to &lt;code&gt;compile:forms/2&lt;/code&gt;. The &lt;code&gt;erl&lt;/code&gt; and &lt;code&gt;hrl&lt;/code&gt; formats are returned as iolists.</source>
          <target state="translated">&lt;code&gt;parse&lt;/code&gt; 형식으로 전달 될 수있는 내부 표현 &lt;code&gt;&lt;a href=&quot;#flatten-1&quot;&gt;flatten/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#format-1&quot;&gt;format/1&lt;/a&gt;&lt;/code&gt; 그동안, &lt;code&gt;forms&lt;/code&gt; 형식으로 전달 될 수 &lt;code&gt;compile:forms/2&lt;/code&gt; . &lt;code&gt;erl&lt;/code&gt; 과 &lt;code&gt;hrl&lt;/code&gt; 형식 iolists로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9ac6e1b83188e6ba00253b80c4e4e283b31e07a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; option is used for pointing out the old version of all applications. (The new versions are already in the code path - assuming of course that the Erlang node on which this is executed is running the correct version of Erlang/OTP.)</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 옵션은 모든 응용 프로그램의 이전 버전을 지적하는 데 사용됩니다. (이 버전이 실행되는 Erlang 노드가 올바른 버전의 Erlang / OTP를 실행하고 있다고 가정하면 새 버전은 이미 코드 경로에 있습니다.)</target>
        </trans-unit>
        <trans-unit id="24e00a9507fa707a286aad7abe3e3cd07325080a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pending_driver&lt;/code&gt;&lt;code&gt;MonitorOption&lt;/code&gt; is by far the most useful. It must be used to ensure that the driver really is unloaded and the ports closed whenever option &lt;code&gt;kill_ports&lt;/code&gt; is used, or the driver can have been loaded with driver option &lt;code&gt;kill_ports&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pending_driver&lt;/code&gt; 의 &lt;code&gt;MonitorOption&lt;/code&gt; 는 지금까지 가장 유용한 것입니다. &lt;code&gt;kill_ports&lt;/code&gt; 옵션을 사용하거나 드라이버 옵션 &lt;code&gt;kill_ports&lt;/code&gt; 로 드라이버를로드 할 수있을 때마다 드라이버가 실제로 언로드되고 포트가 닫히 도록해야 합니다.</target>
        </trans-unit>
        <trans-unit id="7752015e6089336570fa00078221b8ccabc19aba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perf_counter&lt;/code&gt; time unit behaves much in the same way as the &lt;code&gt;native&lt;/code&gt; time unit. That is, it can differ between runtime restarts. To get values of this type, call &lt;code&gt; os:perf_counter/0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;perf_counter&lt;/code&gt; 의 시간 단위는 거의 같은 방식으로 동작 &lt;code&gt;native&lt;/code&gt; 시간 단위. 즉, 런타임 재시작간에 다를 수 있습니다. 이 유형의 값을 얻으려면 &lt;code&gt; os:perf_counter/0&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="f36e06928220660615452de6fef2258f5362fc89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perf_counter&lt;/code&gt; time unit behaves much in the same way as the &lt;code&gt;native&lt;/code&gt; time unit. That is, it can differ between runtime restarts. To get values of this type, call &lt;code&gt;os:perf_counter/0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;perf_counter&lt;/code&gt; 의 시간 단위는 거의 같은 방식으로 동작 &lt;code&gt;native&lt;/code&gt; 시간 단위. 즉, 런타임 재시작마다 다를 수 있습니다. 이 유형의 값을 얻으려면 &lt;code&gt;os:perf_counter/0&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b9f8d1ef7145eb704be87bd7e74e2fde38ff315" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg2&lt;/code&gt; module is deprecated as of OTP 23 and scheduled for removal in OTP 24. You are advised to replace the usage of &lt;code&gt;pg2&lt;/code&gt; with &lt;code&gt;pg&lt;/code&gt;. &lt;code&gt;pg&lt;/code&gt; has a similar API, but with an implementation that is more scalable. See the documentation of &lt;code&gt;pg&lt;/code&gt; for more information about differences.</source>
          <target state="translated">&lt;code&gt;pg2&lt;/code&gt; 모듈은 OTP (23)로 사용되지 않으며 당신의 사용을 대체하는 것이 좋다 OTP (24)에서 제거 될 예정이다 &lt;code&gt;pg2&lt;/code&gt; 함께 &lt;code&gt;pg&lt;/code&gt; . &lt;code&gt;pg&lt;/code&gt; 에는 유사한 API가 있지만 더 확장 가능한 구현이 있습니다. 차이점에 대한 자세한 내용은 &lt;code&gt;pg&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3ddb3f0153c3890640ae834ac81e6898f916068" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pid&lt;/code&gt; parameter is a pointer to a &lt;code&gt;erlang_pid&lt;/code&gt; that the function will update with the pid associated with the global name, if successful.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 매개 변수는 포인터이다 &lt;code&gt;erlang_pid&lt;/code&gt; 성공하면 함수가 글로벌 이름과 연관된 PID로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="8ff6f3b7d18bc68a03a8f098e3306bea8afa3388" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pread/3,4&lt;/code&gt; function reads from a specified position, combining the &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#read-3&quot;&gt;read/3,4&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;pread/3,4&lt;/code&gt; - 함수는 결합, 소정 위치로부터 판독 &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#read-3&quot;&gt;read/3,4&lt;/a&gt;&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="1d5e46480f01a8aa86737f226ba56bdcb171312f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prev&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; fields in the elements of the list contain the value of the pointer, a modification marker, and a deleted marker. Memory operations on these fields are done using atomic memory operations. When a thread has set the modification marker in a field, no-one except the thread that set the marker is allowed to modify the field. If multiple modification markers need to be set, we always begin with &lt;code&gt;next&lt;/code&gt; fields followed by &lt;code&gt;prev&lt;/code&gt; fields in the order following the actual pointers. This guarantees that no deadlocks will occur.</source>
          <target state="translated">&lt;code&gt;prev&lt;/code&gt; 및 &lt;code&gt;next&lt;/code&gt; 목록의 요소 필드는 포인터, 수정 마커 및 삭제 된 마커의 값을 포함합니다. 이러한 필드에 대한 메모리 작업은 원자 메모리 작업을 사용하여 수행됩니다. 스레드가 필드에 수정 마커를 설정 한 경우 마커를 설정 한 스레드를 제외하고는 아무도 필드를 수정할 수 없습니다. 여러 수정 마커 설정해야하는 경우, 우리는 항상 시작 &lt;code&gt;next&lt;/code&gt; 다음 필드 &lt;code&gt;prev&lt;/code&gt; 실제 포인터 다음 순서대로 필드. 이렇게하면 교착 상태가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ade504b785b0942df35eaf3b82afa6476a54cf7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;priv&lt;/code&gt; directory holds assets that the application needs during runtime. Executables should reside in &lt;code&gt;priv/bin&lt;/code&gt; and dynamically-linked libraries should reside in &lt;code&gt;priv/lib&lt;/code&gt;. Other assets are free to reside within the &lt;code&gt;priv&lt;/code&gt; directory but it is recommended it does so in a structured manner.</source>
          <target state="translated">&lt;code&gt;priv&lt;/code&gt; 디렉토리는 응용 프로그램을 실행하는 동안 필요로하는 자산을 보유하고 있습니다. 실행 파일은 &lt;code&gt;priv/bin&lt;/code&gt; 에 있어야 하고 동적으로 연결된 라이브러리는 &lt;code&gt;priv/lib&lt;/code&gt; 에 있어야합니다 . 다른 자산은 내 상주 자유롭게 &lt;code&gt;priv&lt;/code&gt; 디렉토리 있지만이 구조화 된 방식으로 그렇게하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6b2507225c4f70efae176a5a0a6b4b0633e1f261" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;priv&lt;/code&gt; directory holds assets that the application needs during runtime. Executables should reside in &lt;code&gt;priv/bin&lt;/code&gt; and dynamically-linked libraries should reside in &lt;code&gt;priv/lib&lt;/code&gt;. Other assets are free to reside within the &lt;code&gt;priv&lt;/code&gt; directory but it is recommended they do so in a structured manner.</source>
          <target state="translated">&lt;code&gt;priv&lt;/code&gt; 디렉토리는 응용 프로그램을 실행하는 동안 필요로하는 자산을 보유하고 있습니다. 실행 파일은 &lt;code&gt;priv/bin&lt;/code&gt; 에 있어야 하고 동적으로 연결된 라이브러리는 &lt;code&gt;priv/lib&lt;/code&gt; 에 있어야합니다 . 다른 자산은 &lt;code&gt;priv&lt;/code&gt; 디렉토리에 자유롭게 상주 할 수 있지만 구조화 된 방식으로하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a744587962b51e3c606263db57ff07f274e44a97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;processes&lt;/code&gt; filter is the only filter showing all trace messages from a trace log. Each vertical line in the sequence diagram represents a process. Erlang messages, spawn, and link/unlink are typical interactions between processes. Function calls, scheduling, and garbage collection, are typical activities within a process. &lt;code&gt;processes&lt;/code&gt; is the default filter.</source>
          <target state="translated">&lt;code&gt;processes&lt;/code&gt; 필터는 추적 로그에서 모든 추적 메시지를 보여주는 유일한 필터입니다. 시퀀스 다이어그램의 각 세로선은 프로세스를 나타냅니다. Erlang 메시지, 스폰 및 링크 / 링크 해제는 프로세스 간의 일반적인 상호 작용입니다. 함수 호출, 스케줄링 및 가비지 콜렉션은 프로세스 내의 일반적인 활동입니다. &lt;code&gt;processes&lt;/code&gt; 는 기본 필터입니다.</target>
        </trans-unit>
        <trans-unit id="3861f99e16c84fe5707ca3129e815480d2eca579" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pwrite/3,4&lt;/code&gt; function writes to a specified position, combining the &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#write-3&quot;&gt;write/3,4&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;pwrite/3,4&lt;/code&gt; 함수는 결합, 소정 위치에 기록 &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#write-3&quot;&gt;write/3,4&lt;/a&gt;&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="a4939b64de1d53ed04f7d5997288438bc45d2be8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qlc&lt;/code&gt; module evaluates this differently depending on the query handles &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt;. If, for example, &lt;code&gt;X2&lt;/code&gt; is matched against the key of a QLC table, the lookup join method traverses the objects of &lt;code&gt;QH2&lt;/code&gt; while looking up key values in the table. However, if not &lt;code&gt;X2&lt;/code&gt; or &lt;code&gt;Y2&lt;/code&gt; is matched against the key or an indexed position of a QLC table, the merge join method ensures that &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt; are both sorted on position 2 and next do the join by traversing the objects one by one.</source>
          <target state="translated">&lt;code&gt;qlc&lt;/code&gt; 모듈 평가하여이 다른 쿼리에 따라 핸들 &lt;code&gt;QH1&lt;/code&gt; 및 &lt;code&gt;QH2&lt;/code&gt; 을 . 예를 들어 &lt;code&gt;X2&lt;/code&gt; 가 QLC 테이블의 키와 일치하는 경우, 조회 조인 메소드 는 테이블에서 키 값을 찾는 동안 &lt;code&gt;QH2&lt;/code&gt; 의 오브젝트를 순회 합니다. 그러나 &lt;code&gt;X2&lt;/code&gt; 또는 &lt;code&gt;Y2&lt;/code&gt; 가 QLC 테이블의 키 또는 인덱싱 된 위치와 일치 하지 않으면 , 병합 조인 방법은 &lt;code&gt;QH1&lt;/code&gt; 및 &lt;code&gt;QH2&lt;/code&gt; 가 위치 2에서 정렬되고 다음으로 오브젝트를 하나씩 순회하여 결합을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7bdc283a4e0d387d9b4fe3c9cce9b3813bddfd9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qlc&lt;/code&gt; module supports fast join of two query handles. Fast join is possible if some position &lt;code&gt;P1&lt;/code&gt; of one query handler and some position &lt;code&gt;P2&lt;/code&gt; of another query handler are tested for equality. Two fast join methods are provided:</source>
          <target state="translated">&lt;code&gt;qlc&lt;/code&gt; 모듈을 지원하는 빠른 두 개의 쿼리 핸들의 결합. 일부 고속 위치한다면 가능 가입 &lt;code&gt;P1&lt;/code&gt; 한 쿼리 처리기 및 일부의 위치 &lt;code&gt;P2&lt;/code&gt; 다른 쿼리 핸들러가 어떤지를 시험한다. 두 가지 빠른 결합 방법이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4dc69ce9649099f1a16568929e4dca5a9ec4a8ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qlc&lt;/code&gt; module warns at compile time if a QLC combines query handles in such a way that more than one join is possible. That is, no query planner is provided that can select a good order between possible join operations. It is up to the user to order the joins by introducing query handles.</source>
          <target state="translated">&lt;code&gt;qlc&lt;/code&gt; 같은 방법 점에서 QLC 수확기 쿼리 핸들 많은 사람이 참여보다 가능한 경우 모듈은 컴파일시에 경고합니다. 즉, 가능한 조인 작업간에 적절한 순서를 선택할 수있는 쿼리 플래너가 제공되지 않습니다. 쿼리 핸들을 도입하여 조인을 주문하는 것은 사용자의 몫입니다.</target>
        </trans-unit>
        <trans-unit id="1ac4329d09995d8cc50dafbae48fcd60ee3ef172" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;re&lt;/code&gt; module allows for matching Unicode strings as a special option. As the library is centered on matching in binaries, the Unicode support is UTF-8-centered.</source>
          <target state="translated">&lt;code&gt;re&lt;/code&gt; 모듈은 특별한 옵션으로 유니 코드 문자열을 일치 수 있습니다. 라이브러리가 바이너리에서 일치하는 것을 중심으로하기 때문에 유니 코드 지원은 UTF-8 중심입니다.</target>
        </trans-unit>
        <trans-unit id="412cfcfb79171f8451db72dbfc6769aeeae48e5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read_ahead&lt;/code&gt; buffer is also highly used by function &lt;code&gt;read_line/1&lt;/code&gt; in &lt;code&gt;raw&lt;/code&gt; mode, therefore this option is recommended (for performance reasons) when accessing raw files using that function.</source>
          <target state="translated">&lt;code&gt;read_ahead&lt;/code&gt; 버퍼는 높은 기능에 의해 사용된다 &lt;code&gt;read_line/1&lt;/code&gt; 에서 &lt;code&gt;raw&lt;/code&gt; 그 함수를 사용하여 원시 파일을 액세스 할 때, 따라서이 옵션은 (성능의 이유로) 권장 모드.</target>
        </trans-unit>
        <trans-unit id="1d7e68fecfc79e8020cc09ac14cad9865216cb67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ready_io&lt;/code&gt; function is called when the socket we got from postgres is ready for input or output. Here we first check if we are connecting to the database. In that case, we check connection status and return OK if the connection is successful, or error if it is not. If the connection is not yet established, we simply return; &lt;code&gt;ready_io&lt;/code&gt; is called again.</source>
          <target state="translated">&lt;code&gt;ready_io&lt;/code&gt; 우리가 포스트 그레스에서 가져온 소켓의 입력 또는 출력을위한 준비가되면 함수가 호출됩니다. 먼저 데이터베이스에 연결되어 있는지 확인합니다. 이 경우 연결 상태를 확인하고 연결에 성공하면 확인을 반환하고 연결에 실패하면 오류를 반환합니다. 연결이 아직 설정되지 않은 경우 간단히 반환합니다. &lt;code&gt;ready_io&lt;/code&gt; 가 다시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c5f336c46236fef6d33a9737fecfbc45848cc85a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;receive&lt;/code&gt; construct is used to allow processes to wait for messages from other processes. It has the following format:</source>
          <target state="translated">&lt;code&gt;receive&lt;/code&gt; 구조는 프로세스가 다른 프로세스의 메시지를 기다릴 수 있도록하는 데 사용됩니다. 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37481113af1fc6bf67ec51a1b4573b5766d4940d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;receive&lt;/code&gt; expression can be augmented with a timeout:</source>
          <target state="translated">&lt;code&gt;receive&lt;/code&gt; 발현은 타임 아웃을 통해 확장 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="42725fa1b02c7390bf310c7b5f650def33047bd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;receiver&lt;/code&gt; will first be sent the &lt;code&gt;snmp_targets&lt;/code&gt; message, and then for each address in &lt;code&gt;Addresses&lt;/code&gt; list, one of the two &lt;code&gt;snmp_notification&lt;/code&gt; messages.</source>
          <target state="translated">&lt;code&gt;receiver&lt;/code&gt; 먼저 전송한다 &lt;code&gt;snmp_targets&lt;/code&gt; 의 각 주소에 대한 다음 메시지 및 &lt;code&gt;Addresses&lt;/code&gt; 리스트, 이들의 하나 &lt;code&gt;snmp_notification&lt;/code&gt; 된 메시지.</target>
        </trans-unit>
        <trans-unit id="d783190c30a4c184095fc9fe7326cabca7bed37e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refc&lt;/code&gt; field has been removed. The reference count of an &lt;code&gt;ErlDrvBinary&lt;/code&gt; is now stored elsewhere. The reference count of an &lt;code&gt;ErlDrvBinary&lt;/code&gt; can be accessed through &lt;code&gt;&lt;a href=&quot;#driver_binary_get_refc&quot;&gt; driver_binary_get_refc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#driver_binary_inc_refc&quot;&gt; driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_binary_dec_refc&quot;&gt; driver_binary_dec_refc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;refc&lt;/code&gt; 필드가 제거되었습니다. &lt;code&gt;ErlDrvBinary&lt;/code&gt; 의 참조 카운트 는 이제 다른 곳에 저장됩니다. &lt;code&gt;ErlDrvBinary&lt;/code&gt; 의 참조 횟수는 &lt;code&gt;&lt;a href=&quot;#driver_binary_get_refc&quot;&gt; driver_binary_get_refc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#driver_binary_inc_refc&quot;&gt; driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#driver_binary_dec_refc&quot;&gt; driver_binary_dec_refc&lt;/a&gt;&lt;/code&gt; 를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e35f7f5fad0e5d56316957219823696de6e6786c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refc&lt;/code&gt; field has been removed. The reference count of an &lt;code&gt;ErlDrvBinary&lt;/code&gt; is now stored elsewhere. The reference count of an &lt;code&gt;ErlDrvBinary&lt;/code&gt; can be accessed through &lt;code&gt;&lt;a href=&quot;#driver_binary_get_refc&quot;&gt;driver_binary_get_refc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#driver_binary_inc_refc&quot;&gt;driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_binary_dec_refc&quot;&gt;driver_binary_dec_refc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;refc&lt;/code&gt; 필드가 제거되었습니다. &lt;code&gt;ErlDrvBinary&lt;/code&gt; 의 참조 카운트 가 이제 다른 곳에 저장됩니다. &lt;code&gt;ErlDrvBinary&lt;/code&gt; 의 참조 카운트는 &lt;code&gt;&lt;a href=&quot;#driver_binary_get_refc&quot;&gt;driver_binary_get_refc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#driver_binary_inc_refc&quot;&gt;driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#driver_binary_dec_refc&quot;&gt;driver_binary_dec_refc&lt;/a&gt;&lt;/code&gt; 를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82f0b91245f77a3b886c273dd05b9767b42d775d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;registry&lt;/code&gt; functionality part of &lt;code&gt;erl_interface&lt;/code&gt; is as of &lt;code&gt;&lt;a href=&quot;deprecations#otp-23&quot;&gt;OTP 23 deprecated&lt;/a&gt;&lt;/code&gt; and will be removed in OTP 24.</source>
          <target state="translated">&lt;code&gt;registry&lt;/code&gt; 의 기능 부분 &lt;code&gt;erl_interface&lt;/code&gt; 는 현재의 인 &lt;code&gt;&lt;a href=&quot;deprecations#otp-23&quot;&gt;OTP 23 deprecated&lt;/a&gt;&lt;/code&gt; 및 OTP (24)에서 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="660ed54d5ac1fcd2169600b38b40bd925d66cf86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;release_handler&lt;/code&gt; copies these files to the &lt;code&gt;bin&lt;/code&gt; directory in the client directory at the master nodes whenever a new release is made permanent.</source>
          <target state="translated">&lt;code&gt;release_handler&lt;/code&gt; 복사 이러한 파일 &lt;code&gt;bin&lt;/code&gt; 새로운 버전을 영구적으로 될 때마다 마스터 노드에서 클라이언트 디렉토리에 디렉토리를.</target>
        </trans-unit>
        <trans-unit id="56830d582041a2d058cd8b9ca80ec725e5c3e287" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reload&lt;/code&gt; option can be either of the following:</source>
          <target state="translated">&lt;code&gt;reload&lt;/code&gt; 옵션 중 하나를 다음 중 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="207c0a4a6dd7d54555e6c470a0c170ec46378f8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;relup&lt;/code&gt; file contains instructions for how to upgrade to, or downgrade from, this version of the release.</source>
          <target state="translated">&lt;code&gt;relup&lt;/code&gt; 의 파일로 업그레이드하거나 릴리스 버전에서 다운 그레이드하는 방법에 대한 지침이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb051013f36a233ac41b404b8075c071558087a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;relup&lt;/code&gt; file contains one single Erlang term, which defines the instructions used to upgrade the release. The file has the following syntax:</source>
          <target state="translated">&lt;code&gt;relup&lt;/code&gt; 의 파일은 릴리스로 업그레이드하는 데 사용되는 지침을 정의하는 하나 개의 얼랑 용어가 포함되어 있습니다. 파일의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d56076bd8991e00d489d3da464bc1ef66915e244" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reply_timer&lt;/code&gt; eventually times out.</source>
          <target state="translated">&lt;code&gt;reply_timer&lt;/code&gt; 은 결국 시간 초과.</target>
        </trans-unit>
        <trans-unit id="3918ee266b06587588695e693fc72ac650418ae7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restart&lt;/code&gt; key is optional. If it is not given, the default value &lt;code&gt;permanent&lt;/code&gt; will be used.</source>
          <target state="translated">&lt;code&gt;restart&lt;/code&gt; 키는 선택 사항입니다. 지정하지 않으면 &lt;code&gt;permanent&lt;/code&gt; 기본값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa12db49496616557ec440b620daa191bf27cdc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restart&lt;/code&gt; key is optional. If it is not specified, it defaults to &lt;code&gt;permanent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;restart&lt;/code&gt; 키는 선택 사항입니다. 지정하지 않으면 기본값은 &lt;code&gt;permanent&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b6a92effc8d3efc4277861eec34f0f1caed07816" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restart_new_emulator&lt;/code&gt; instruction must always be the first instruction in a relup. If the relup is generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;, this is automatically ensured.</source>
          <target state="translated">&lt;code&gt;restart_new_emulator&lt;/code&gt; 의 명령은 항상 relup의 첫 번째 명령해야합니다. reltools가 &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; 에 의해 생성되면 자동으로 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="11d3f640ffec2cfdf0c8a6e928ab7cecff319eaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run_erl&lt;/code&gt; program is specific to Unix systems. This program redirects the standard input and standard output streams so that all output can be logged. It also lets the program &lt;code&gt;to_erl&lt;/code&gt; connect to the Erlang console, making it possible to monitor and debug an embedded system remotely.</source>
          <target state="translated">&lt;code&gt;run_erl&lt;/code&gt; 의 프로그램은 유닉스 시스템에만 적용됩니다. 이 프로그램은 모든 출력을 기록 할 수 있도록 표준 입력 및 표준 출력 스트림을 리디렉션합니다. 또한 프로그램 &lt;code&gt;to_erl&lt;/code&gt; 을 Erlang 콘솔에 연결하여 임베디드 시스템을 원격으로 모니터링하고 디버깅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="750c30ae5ba824b2f2aab4a171c99b419364a053" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;runtime_dependencies&lt;/code&gt; key was introduced in OTP 17.0. The type of its value might be subject to changes during the OTP 17 release.</source>
          <target state="translated">&lt;code&gt;runtime_dependencies&lt;/code&gt; 의 키는 OTP 17.0 년에 도입되었다. 해당 값의 유형은 OTP 17 릴리스 중에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0fc6c1e3ca6659e674892c5855367c57b82e3b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sasl&lt;/code&gt; application includes the example Erlang module &lt;code&gt;target_system.erl&lt;/code&gt;, which contains functions for creating and installing a target system. This module is used in the following examples. The source code of the module is listed in &lt;code&gt;&lt;a href=&quot;#listing%20of%20target%20system&quot;&gt; Listing of target_system.erl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sasl&lt;/code&gt; 애플리케이션은 예 얼랑 모듈 포함 &lt;code&gt;target_system.erl&lt;/code&gt; 만들고 타겟 시스템을 설치하기위한 기능을 포함. 이 모듈은 다음 예제에서 사용됩니다. 모듈의 소스 코드 &lt;code&gt;&lt;a href=&quot;#listing%20of%20target%20system&quot;&gt; Listing of target_system.erl&lt;/a&gt;&lt;/code&gt; 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="49d8491d2a1375817a9cf2b814c2646acf960284" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sasl&lt;/code&gt; application includes the example Erlang module &lt;code&gt;target_system.erl&lt;/code&gt;, which contains functions for creating and installing a target system. This module is used in the following examples. The source code of the module is listed in &lt;code&gt;&lt;a href=&quot;#listing%20of%20target%20system&quot;&gt;Listing of target_system.erl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sasl&lt;/code&gt; 애플리케이션은 예 얼랑 모듈 포함 &lt;code&gt;target_system.erl&lt;/code&gt; 만들고 타겟 시스템을 설치하기위한 기능을 포함. 이 모듈은 다음 예에서 사용됩니다. 모듈의 소스 코드 &lt;code&gt;&lt;a href=&quot;#listing%20of%20target%20system&quot;&gt;Listing of target_system.erl&lt;/a&gt;&lt;/code&gt; 나열되어 있습니다</target>
        </trans-unit>
        <trans-unit id="3906ed9fb14f8072e02da2d35e2b47f21b0a6292" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select&lt;/code&gt; expression matches all entries in table employee with the field &lt;code&gt;sex&lt;/code&gt; set to &lt;code&gt;female&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 표현식은 필드와 테이블 직원의 모든 항목과 일치 &lt;code&gt;sex&lt;/code&gt; 으로 설정 &lt;code&gt;female&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d221358022dcaa2231dd0fa112459ee9f7e4a5b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select_ref()&lt;/code&gt; is the same as was received in the &lt;code&gt;&lt;a href=&quot;socket#type-select_info&quot;&gt;SelectInfo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;select_ref()&lt;/code&gt; 에서 수신 된 것과 동일 &lt;code&gt;&lt;a href=&quot;socket#type-select_info&quot;&gt;SelectInfo&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f5c2c9e1f5cbdb80c6a7e6b52821b6b12fa676f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send&lt;/code&gt; and &lt;code&gt;'receive'&lt;/code&gt; flags enable tracing of all messages sent and received by the process/port. Trace patterns set with &lt;code&gt;tpe&lt;/code&gt; may limit traced messages based on the message content, the sender, and/or the receiver.</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; 및 &lt;code&gt;'receive'&lt;/code&gt; 플래그는 모든 메시지의 추적을하는 것은 전송 프로세스 / 포트에서 수신 할 수 있습니다. &lt;code&gt;tpe&lt;/code&gt; 로 설정된 추적 패턴 은 메시지 내용, 발신자 및 / 또는 수신자에 따라 추적 된 메시지를 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0233a943ab6f52106ec90bb0ab714ed2cd9deb4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send&lt;/code&gt; call does not accept a time-out option because time-outs on send is handled through socket option &lt;code&gt;send_timeout&lt;/code&gt;. The behavior of a send operation with no receiver is mainly defined by the underlying TCP stack and the network infrastructure. To write code that handles a hanging receiver that can eventually cause the sender to hang on a &lt;code&gt;send&lt;/code&gt; do like the following.</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; 전송에 시간 제한이 소켓 옵션을 통해 처리되기 때문에 통화 시간 제한 옵션을 허용하지 않습니다 &lt;code&gt;send_timeout&lt;/code&gt; . 수신기가없는 전송 작업의 동작은 주로 기본 TCP 스택과 네트워크 인프라에 의해 정의됩니다. 코드를 작성하려면 결국 보낸 사람이에 중단 될 수있는 매달려 수신기 처리하는 &lt;code&gt;send&lt;/code&gt; 다음과 같이 수행합니다.</target>
        </trans-unit>
        <trans-unit id="bdcf831f5f9a895f78c5ead8d39eb67c53d11a2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send_notification/6&lt;/code&gt; function is the most general version of the function. A &lt;code&gt;ContextName&lt;/code&gt; must be specified, from which the notification will be sent. If this parameter is not specified, the default context (&lt;code&gt;&quot;&quot;&lt;/code&gt;) is used.</source>
          <target state="translated">&lt;code&gt;send_notification/6&lt;/code&gt; 함수는 함수의 가장 일반적인 버전이다. &lt;code&gt;ContextName&lt;/code&gt; 는 알림이 전송됩니다되는, 지정해야합니다. 이 매개 변수를 지정하지 않으면 기본 컨텍스트 ( &lt;code&gt;&quot;&quot;&lt;/code&gt; )가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e10004941e2f7c2be1fb735798912ba806d773f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send_out_queue&lt;/code&gt; routine is as follows:</source>
          <target state="translated">&lt;code&gt;send_out_queue&lt;/code&gt; 다음과 같이 루틴은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="843b939f65952e899d6ea657ca1ebe102c72dbe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;server&lt;/code&gt; module corresponds, greatly simplified, to the Erlang/OTP behaviour &lt;code&gt;gen_server&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; 모듈의 대응은 크게 얼랑 / OTP 행동에, 간단하게 &lt;code&gt;gen_server&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eede287bf30328bbe010a8372b63b7607963a54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; commands modifies or adds an Erlang service, respectively. The simplest form of an &lt;code&gt;add&lt;/code&gt; command is without any options in which case all default values (described above) apply. The service name is mandatory.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 및 &lt;code&gt;add&lt;/code&gt; 각각 수정 명령 또는 얼랑 서비스를 추가합니다. &lt;code&gt;add&lt;/code&gt; 명령 의 가장 간단한 형식은 옵션이없는 경우 (위에서 설명한) 모든 기본값이 적용됩니다. 서비스 이름은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="7d5aec8c53556f4c4632141415f220fd68b8daa2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set&lt;/code&gt; function checks if it has enough information to make the row change its status from &lt;code&gt;notReady&lt;/code&gt; to &lt;code&gt;notInService&lt;/code&gt; (when a row has been been set to &lt;code&gt;createAndWait&lt;/code&gt;). If a row is set to &lt;code&gt;createAndWait&lt;/code&gt;, columns without a value are set to &lt;code&gt;noinit&lt;/code&gt;. If Mnesia is used, the set functionality is handled within a transaction.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 기능 검사는 행 상태에서 변경할 수 있도록하는 충분한 정보가 있으면 &lt;code&gt;notReady&lt;/code&gt; 을 에 &lt;code&gt;notInService&lt;/code&gt; 을 (a 행으로 설정되었을 때 &lt;code&gt;createAndWait&lt;/code&gt; ). 행이 &lt;code&gt;createAndWait&lt;/code&gt; 로 설정된 경우 값이없는 열은 &lt;code&gt;noinit&lt;/code&gt; 로 설정됩니다 . Mnesia를 사용하면 설정된 기능이 트랜잭션 내에서 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="dffce6a86883fb98a441ee618f3e33a10bd8dd89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set_on_spawn&lt;/code&gt; option will active call time tracing for all processes spawned by processes in the rootset. This is the default behaviour.</source>
          <target state="translated">&lt;code&gt;set_on_spawn&lt;/code&gt; 의 옵션은 활성 통화 시간 rootset의 프로세스에 의해 만들어지는 모든 프로세스에 대한 추적을 할 것이다. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="d7ea8237fdbb6c1e6e9cad779100829368078340" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shutdown&lt;/code&gt; key is optional. If it is not given, and the child is of type &lt;code&gt;worker&lt;/code&gt;, the default value &lt;code&gt;5000&lt;/code&gt; will be used; if the child is of type &lt;code&gt;supervisor&lt;/code&gt;, the default value &lt;code&gt;infinity&lt;/code&gt; will be used.</source>
          <target state="translated">&lt;code&gt;shutdown&lt;/code&gt; 키는 선택 사항입니다. 제공되지 않고 하위 유형이 &lt;code&gt;worker&lt;/code&gt; 인 경우 기본값 &lt;code&gt;5000&lt;/code&gt; 이 사용됩니다. 자식이 &lt;code&gt;supervisor&lt;/code&gt; 유형 인 경우 기본값 &lt;code&gt;infinity&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2cb49de51c4b23fb4081f3a3f48b32fd97395704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shutdown&lt;/code&gt; key is optional. If it is not specified, it defaults to &lt;code&gt;5000&lt;/code&gt; if the child is of type &lt;code&gt;worker&lt;/code&gt; and it defaults to &lt;code&gt;infinity&lt;/code&gt; if the child is of type &lt;code&gt;supervisor&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shutdown&lt;/code&gt; 키는 선택 사항입니다. 지정되지 않은 경우 하위 유형이 &lt;code&gt;worker&lt;/code&gt; 유형 인 경우 기본값은 &lt;code&gt;5000&lt;/code&gt; 이고 하위 유형이 &lt;code&gt;supervisor&lt;/code&gt; 유형 인 경우 기본값은 &lt;code&gt;infinity&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="38a6562eb72c50374e4148dda56f4f2798a51836" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;silent&lt;/code&gt; trace flag facilitates setting up a trace on many or even all processes in the system. The trace can then be activated and deactivated using the match specification function &lt;code&gt;{silent,Bool}&lt;/code&gt;, giving a high degree of control of which functions with which arguments that trigger the trace.</source>
          <target state="translated">&lt;code&gt;silent&lt;/code&gt; 추적 플래그는 시스템의 많은 또는 모든 프로세스에 대한 추적을 설정하는 용이하게합니다. 그런 다음 일치 스펙 함수 &lt;code&gt;{silent,Bool}&lt;/code&gt; 을 사용하여 추적을 활성화 및 비활성화하여 추적을 트리거하는 인수와 함께 어떤 기능을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57bdb45fe915c31143be502180221ee741783591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; field changed from signed to unsigned. This can cause problems for, for example, loop termination conditions or error conditions if you only change the types all over the place.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; 변경 필드는 부호에 서명했다. 예를 들어, 장소 전체에서 유형 만 변경하면 루프 종료 조건이나 오류 조건에 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="240a989a5bf707c990bcb78e115aed91f3f04714" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; field in &lt;code&gt;&lt;a href=&quot;#ErlIOVec&quot;&gt;ErlIOVec&lt;/a&gt;&lt;/code&gt; has been changed to &lt;code&gt;ErlDrvSizeT&lt;/code&gt; from &lt;code&gt;int&lt;/code&gt;. Check all code that use that field.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; 필드 &lt;code&gt;&lt;a href=&quot;#ErlIOVec&quot;&gt;ErlIOVec&lt;/a&gt;&lt;/code&gt; 이 변경되었습니다 &lt;code&gt;ErlDrvSizeT&lt;/code&gt; 에서 &lt;code&gt;int&lt;/code&gt; . 해당 필드를 사용하는 모든 코드를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a337f162f4c8e035168099f55089fef2894d81f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; directory could be useful to release for debugging purposes but is not required. The &lt;code&gt;include&lt;/code&gt; directory should only be released if the applications has public include files.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 디렉토리는 디버깅 목적으로하지만 필요하지 않습니다에 대한 해제하는 것이 유용 할 수 있습니다. &lt;code&gt;include&lt;/code&gt; 하는 응용 프로그램은 대중이 파일이 포함되어있는 경우 디렉토리는 공개되어야한다.</target>
        </trans-unit>
        <trans-unit id="fc13993adad718eae8701221afde4693b532449e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ssh&lt;/code&gt; application is an implementation of the SSH Transport, Connection and Authentication Layer Protocols in Erlang. It provides the following:</source>
          <target state="translated">&lt;code&gt;ssh&lt;/code&gt; 응용 프로그램은 전송 SSH, 얼랑에 연결 및 인증 계층 프로토콜의 구현이다. 다음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1b351d65a63d0aa90f08b7937079a25c6920290a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ssl_passive&lt;/code&gt; message is sent only when the socket is in &lt;code&gt;{active, N}&lt;/code&gt; mode and the counter dropped to 0. It indicates that the socket has transitioned to passive (&lt;code&gt;{active, false}&lt;/code&gt;) mode.</source>
          <target state="translated">&lt;code&gt;ssl_passive&lt;/code&gt; 메시지 소켓이있는 경우에만 전송된다 &lt;code&gt;{active, N}&lt;/code&gt; 이 소켓은 패시브 (로 천이했음을 표시 모드와 카운터는 0으로 떨어 &lt;code&gt;{active, false}&lt;/code&gt; ) 모드.</target>
        </trans-unit>
        <trans-unit id="8f65d2a2ea4f4fd44a5c098586ac285ac95cdefd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; commands communicates with the service manager for starting and stopping a service. The commands wait until the service is started or stopped. When disabling a service, it is not stopped, the disabled state does not take effect until the service is stopped. Enabling a service sets it in automatic mode, which is started at boot. This command cannot set the service to manual.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 시작하고 서비스를 중지에 대한 서비스 관리자와 명령을 전달한다. 서비스가 시작되거나 중지 될 때까지 명령이 대기합니다. 서비스를 비활성화하면 서비스가 중지되지 않으며 서비스가 중지 될 때까지 비활성화 된 상태가 적용됩니다. 서비스를 활성화하면 부팅시 시작되는 자동 모드로 설정됩니다. 이 명령은 서비스를 수동으로 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d1f3d732c30aec74a57c16dda04003bb1543c716" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; entry is called when the driver is opened as a port with &lt;code&gt;open_port/2&lt;/code&gt;. Here we allocate memory for a user data structure. This user data is passed every time the emulator calls us. First we store the driver handle, as it is needed in later calls. We allocate memory for the connection handle that is used by LibPQ. We also set the port to return allocated driver binaries, by setting flag &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt;, calling &lt;code&gt;set_port_control_flags&lt;/code&gt;. (This is because we do not know if our data will fit in the result buffer of &lt;code&gt;control&lt;/code&gt;, which has a default size, 64 bytes, set up by the emulator.)</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 드라이버가있는 포트로 열 때 항목이라고 &lt;code&gt;open_port/2&lt;/code&gt; . 여기서 우리는 사용자 데이터 구조를위한 메모리를 할당합니다. 이 사용자 데이터는 에뮬레이터가 호출 할 때마다 전달됩니다. 먼저 나중에 호출 할 때 필요하므로 드라이버 핸들을 저장합니다. LibPQ에서 사용하는 연결 핸들에 메모리를 할당합니다. 또한 플래그 &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt; 를 설정하고 &lt;code&gt;set_port_control_flags&lt;/code&gt; 를 호출 하여 할당 된 드라이버 바이너리를 반환하도록 포트를 설정했습니다 . (이는 데이터가 에뮬레이터에서 설정 한 기본 크기가 64 바이트 인 &lt;code&gt;control&lt;/code&gt; 의 결과 버퍼에 맞는지 알 수 없기 때문 입니다.)</target>
        </trans-unit>
        <trans-unit id="f756fe51eb87c21305c2536fa74b5434575da4c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; key is mandatory.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 키는 필수입니다.</target>
        </trans-unit>
        <trans-unit id="7a89df12694a55231dbe9df289731067f34bf0ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; program is called when the machine is started.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 기계가 시작될 때 프로그램이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="34d8bb2f8c095328e05b319382abf621840539e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; script is an example script on how to start up the Erlang system in embedded mode on Unix.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 스크립트는 유닉스에 포함 된 모드에서 얼랑 시스템을 시작하는 방법에 대한 예제 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="c9b5982012fe67cdfffd9b71b0eeb41c6d062f31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; script is to be edited accordingly.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 스크립트는 이에 따라 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31e73008fe878f9797af9d091c4fba4b24889e97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_disabled&lt;/code&gt; command operates on a service regardless of if it is enabled/disabled or started/stopped. It does this by first enabling it (regardless of if it is enabled or not), then starting it (if not already started), and then disabling it. The result is a disabled but started service, regardless of its earlier state. This is useful for starting services temporarily during a release upgrade. The difference between using &lt;code&gt;start_disabled&lt;/code&gt; and the sequence &lt;code&gt;enable&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt;, and &lt;code&gt;disable&lt;/code&gt; is that all other &lt;code&gt;erlsrv&lt;/code&gt; commands are locked out during the sequence of operations in &lt;code&gt;start_disable&lt;/code&gt;, making the operation atomic from an &lt;code&gt;erlsrv&lt;/code&gt; user's point of view.</source>
          <target state="translated">&lt;code&gt;start_disabled&lt;/code&gt; 명령 관계없이 활성화 / 비활성화 또는 시작되었는지의 서비스에서 작동 / 정지. 먼저 활성화 여부에 관계없이 활성화 한 다음 시작 (아직 시작하지 않은 경우) 한 다음 비활성화하여이를 수행합니다. 결과는 이전 상태에 관계없이 비활성화되었지만 서비스가 시작된 것입니다. 릴리스 업그레이드 중에 서비스를 임시로 시작하는 데 유용합니다. &lt;code&gt;start_disabled&lt;/code&gt; 사용 과 시퀀스 &lt;code&gt;enable&lt;/code&gt; , &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;disable&lt;/code&gt; 의 차이점은 start_disable 의 작업 순서 중에 다른 모든 &lt;code&gt;erlsrv&lt;/code&gt; 명령이 잠기 &lt;code&gt;start_disable&lt;/code&gt; 에서 작업을 &lt;code&gt;erlsrv&lt;/code&gt; 사용자의 관점.</target>
        </trans-unit>
        <trans-unit id="fc0272cbbd8f9392623927de4cb2fc5730b48880" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_erl&lt;/code&gt; program in its original form recognizes the following options:</source>
          <target state="translated">원래 형식 의 &lt;code&gt;start_erl&lt;/code&gt; 프로그램은 다음 옵션을 인식합니다.</target>
        </trans-unit>
        <trans-unit id="a046e5227b7bb73b869f5bee562322400ca78ede" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_erl&lt;/code&gt; program is specific to Windows NT/2000/XP (and later versions of Windows). Although there are programs with the same name on other platforms, their functionality is different.</source>
          <target state="translated">&lt;code&gt;start_erl&lt;/code&gt; 의 프로그램은 윈도우 NT / 2000 / XP (및 이후 버전의 Windows)에 따라 다릅니다. 다른 플랫폼에는 동일한 이름의 프로그램이 있지만 기능은 다릅니다.</target>
        </trans-unit>
        <trans-unit id="dbb5a322b443d443c9f79ed8f50a8ce9c3dd4066" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_erl&lt;/code&gt; shell script is normally not to be altered by the user.</source>
          <target state="translated">&lt;code&gt;start_erl&lt;/code&gt; 의 쉘 스크립트는 사용자에 의해 변경 될 수 일반적으로하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f114d80543f043efa956ef10b8b8d871f223052b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stop&lt;/code&gt; entry is called when the port is closed.</source>
          <target state="translated">&lt;code&gt;stop&lt;/code&gt; 포트를 닫을 때 항목이라고합니다.</target>
        </trans-unit>
        <trans-unit id="d04747a932902a65b42336d22f13d3d5bc78329f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strategy&lt;/code&gt; key is optional in this map. If it is not given, it defaults to &lt;code&gt;one_for_one&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strategy&lt;/code&gt; 핵심이지도에서 선택 사항입니다. 지정하지 않으면 기본값은 &lt;code&gt;one_for_one&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="677a0d7125364697331cecce3cb1b444380c3397" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;string()&lt;/code&gt; reason is the error information from the server in case of an exit-signal. If that information is empty, the reason is the exit signal name.</source>
          <target state="translated">&lt;code&gt;string()&lt;/code&gt; 이유는 이탈 신호의 경우에 상기 서버로부터 상기 에러 정보이다. 해당 정보가 비어있는 경우 이유는 종료 신호 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ac46c7648d961485339da72bde9519efe243649a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;string&lt;/code&gt; module works perfectly for Unicode strings and ISO Latin-1 strings, except the language-dependent functions &lt;code&gt;string:uppercase/1&lt;/code&gt; and &lt;code&gt;string:lowercase/1&lt;/code&gt;. These two functions can never function correctly for Unicode characters in their current form, as there are language and locale issues to consider when converting text between cases. Converting case in an international environment is a large subject not yet addressed in OTP.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 모듈은 언어 별 기능을 제외하고 유니 코드 문자열 및 ISO 라틴어 1 문자열을 완벽하게 작동 &lt;code&gt;string:uppercase/1&lt;/code&gt; 및 &lt;code&gt;string:lowercase/1&lt;/code&gt; . 이 두 함수는 텍스트를 변환 할 때 고려해야 할 언어 및 로캘 문제가 있으므로 현재 형식의 유니 코드 문자에 대해 올바르게 기능 할 수 없습니다. 국제 환경에서 사례를 변환하는 것은 아직 OTP에서 다루지 않은 큰 주제입니다.</target>
        </trans-unit>
        <trans-unit id="bbf0fa4cdfc9cb3b3a98e97fea86cc7766872258" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subsystem_name&lt;/code&gt; is the name that a client requests to start with for example &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;subsystem_name&lt;/code&gt; 는 클라이언트 요청이 예제를 위해 함께 시작하는 이름입니다 &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09767c0926afa55480ccd26075dea864841952af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;suspend&lt;/code&gt; pseudo function has got an OWN time of zero. This is to prevent the process total OWN time from including time in suspension. Whether suspend time is really ACC or OWN time is more of a philosophical question.</source>
          <target state="translated">는 &lt;code&gt;suspend&lt;/code&gt; 의사 함수가 0 인 자신의 시간을 가지고있다. 이는 프로세스 총 소유 시간이 일시 중단 시간을 포함하지 않도록하기위한 것입니다. 일시 중단 시간이 실제로 ACC인지 아니면 자신의 시간인지는 철학적 인 질문에 더 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="56fd6933946b063ca50f26b9fde4abf8abbc8167" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sys&lt;/code&gt; module has functions for simple debugging of processes implemented using behaviours. It also has functions that, together with functions in the &lt;code&gt;proc_lib&lt;/code&gt; module, can be used to implement a &lt;strong&gt;special process&lt;/strong&gt; that complies to the OTP design principles without using a standard behaviour. These functions can also be used to implement user-defined (non-standard) behaviours.</source>
          <target state="translated">&lt;code&gt;sys&lt;/code&gt; 모듈 동작을 사용하여 구현 프로세스의 단순한 디버깅 기능을 갖는다. 또한 &lt;code&gt;proc_lib&lt;/code&gt; 모듈의 함수와 함께 표준 동작을 사용하지 않고 OTP 설계 원칙을 준수 하는 &lt;strong&gt;특수 프로세스&lt;/strong&gt; 를 구현하는 데 사용할 수있는 함수가 있습니다. 이러한 기능은 사용자 정의 (비표준) 동작을 구현하는 데에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5f881a797bfc4fbe38f558b9ae2256b6de4f52c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sys&lt;/code&gt; module has functions for simple debugging of processes implemented using behaviours. The &lt;code&gt;code_lock&lt;/code&gt; example from &lt;code&gt;&lt;a href=&quot;statem#Example&quot;&gt;gen_statem Behaviour&lt;/a&gt;&lt;/code&gt; is used to illustrate this:</source>
          <target state="translated">&lt;code&gt;sys&lt;/code&gt; 모듈 동작을 사용하여 구현 프로세스의 단순한 디버깅 기능을 갖는다. &lt;code&gt;&lt;a href=&quot;statem#Example&quot;&gt;gen_statem Behaviour&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;code_lock&lt;/code&gt; 예제는 이를 설명하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d8d80e46d29a3b09620c79d01dfafc6546d08b34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; value is not complete. Some allocated memory that is to be part of this value is not.</source>
          <target state="translated">&lt;code&gt;system&lt;/code&gt; 값이 완료되지 않았습니다. 이 값의 일부가 될 일부 할당 된 메모리는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26e392c3cf2f0ef617cba237c6220075b3ea4b25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system_dir&lt;/code&gt; option must be a directory containing a host key file and it defaults to &lt;code&gt;/etc/ssh&lt;/code&gt;. For details, see Section Configuration Files in &lt;code&gt;ssh(6)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;system_dir&lt;/code&gt; 의 옵션은 호스트 키 파일이 들어있는 디렉토리하고 기본값으로합니다 &lt;code&gt;/etc/ssh&lt;/code&gt; . 자세한 내용은 &lt;code&gt;ssh(6)&lt;/code&gt; 구성 파일 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8dc4b52b4a1a8766ffe6fbf819d4319fd568e3cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;systools:make_tar/1,2&lt;/code&gt; function takes a &lt;code&gt;.rel&lt;/code&gt; file as input and creates a zipped tar file with the code for the specified applications, a &lt;strong&gt;release package&lt;/strong&gt;:</source>
          <target state="translated">&lt;code&gt;systools:make_tar/1,2&lt;/code&gt; 기능은 얻어 &lt;code&gt;.rel&lt;/code&gt; 의 파일을 입력으로하고, 지정된 애플리케이션 A에 대한 코드와 함께 압축 된 tar 파일 생성 &lt;strong&gt;릴리스 패키지&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="301c4b01094f4be3c122bd03d67de7a461179ba6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;table_info/2&lt;/code&gt; function takes two arguments. The first is the name of a Mnesia table. The second is one of the following keys:</source>
          <target state="translated">&lt;code&gt;table_info/2&lt;/code&gt; 함수는 두 개의 인수를 취합니다. 첫 번째는 Mnesia 테이블의 이름입니다. 두 번째는 다음 키 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="cc6490531af30f5ced0c442f4ca5f18223c8f2ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tag_receiver()&lt;/code&gt; will first be sent the &lt;code&gt;snmp_targets&lt;/code&gt; message, and then for each address in &lt;code&gt;Addresses&lt;/code&gt; list, one of the two &lt;code&gt;snmp_notification&lt;/code&gt; messages.</source>
          <target state="translated">&lt;code&gt;tag_receiver()&lt;/code&gt; 먼저 송신한다 &lt;code&gt;snmp_targets&lt;/code&gt; 의 각 주소에 대한 다음 메시지 및 &lt;code&gt;Addresses&lt;/code&gt; 리스트, 이들의 하나 &lt;code&gt;snmp_notification&lt;/code&gt; 된 메시지.</target>
        </trans-unit>
        <trans-unit id="05b2bd26a182333de1bd8075c792a7cf0885382c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;term&lt;/code&gt; structure contains the arity for a tuple or list, size for a binary, string, or atom. It contains a term if it is any of the following: integer, float, atom, pid, port, or ref.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; 구조는 바이너리 스트링, 또는 원자에 대한 터플 또는리스트 크기에 대한 인수에 대응를 포함한다. 정수, 부동 소수점, 원자, pid, 포트 또는 참조 중 하나 인 경우 용어를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="414ded4046829ee348e2029f26b1f968edf7170d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;terminating&lt;/code&gt; options effects discovery initiated by a manager.</source>
          <target state="translated">&lt;code&gt;terminating&lt;/code&gt; 관리자에 의해 시작 옵션 효과 발견.</target>
        </trans-unit>
        <trans-unit id="7e88c128d4034b8d31e143d58083f1b627d669f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; functions use the &lt;code&gt;*.asn1db&lt;/code&gt; files for all included modules. If they are located in a different directory than the current working directory, use the &lt;code&gt;include&lt;/code&gt; option to add paths. This is only needed when automatically generating values. For static values using &lt;code&gt;Value&lt;/code&gt; no options are needed.</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 기능은 사용 &lt;code&gt;*.asn1db&lt;/code&gt; 포함 된 모든 모듈 파일을. 이들이 현재 작업 디렉토리와 다른 디렉토리에있는 경우, &lt;code&gt;include&lt;/code&gt; 옵션을 사용하여 경로를 추가하십시오. 이것은 자동으로 값을 생성 할 때 필요합니다. 사용하지 않는 정적 값의 &lt;code&gt;Value&lt;/code&gt; 어떤 옵션이 필요하다.</target>
        </trans-unit>
        <trans-unit id="83b7e0837f597d64ddcc824925c5e1f6e2d7ce99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tftp&lt;/code&gt; application implements the following IETF standards:</source>
          <target state="translated">&lt;code&gt;tftp&lt;/code&gt; 응용 프로그램 구현 다음 IETF 표준 :</target>
        </trans-unit>
        <trans-unit id="6783b7d09b3f65f7bff4fe67aceb9dac10494244" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;time_unit/0&lt;/code&gt; type can be extended. To convert time values between time units, use &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt; erlang:convert_time_unit/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;time_unit/0&lt;/code&gt; 타입은 확장 할 수 있습니다. 시간 단위간에 시간 값을 변환하려면 &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt; erlang:convert_time_unit/3&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4bd16215e29bac88188ec05db9e000d6b25c2a4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;time_unit/0&lt;/code&gt; type can be extended. To convert time values between time units, use &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt;erlang:convert_time_unit/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;time_unit/0&lt;/code&gt; 타입은 확장 할 수 있습니다. 시간 단위 사이의 시간 값을 변환하려면 &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt;erlang:convert_time_unit/3&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d6b5da79accb971f070469104b62f5de13468c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; option in the &lt;code&gt;SearchOptions&lt;/code&gt; is for the ldap server, while the timeout in &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;eldap:open/2&lt;/a&gt;&lt;/code&gt; is used for each individual request in the search operation.</source>
          <target state="translated">&lt;code&gt;SearchOptions&lt;/code&gt; 의 &lt;code&gt;timeout&lt;/code&gt; 옵션 은 ldap 서버에 대한 것이고, &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;eldap:open/2&lt;/a&gt;&lt;/code&gt; 의 시간 초과 는 검색 작업의 각 개별 요청에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3469f460bad51d15abfb716bef8439dd19f5713d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;total&lt;/code&gt; value is supposed to be the total amount of memory dynamically allocated by the emulator. Shared libraries, the code of the emulator itself, and the emulator stacks are not supposed to be included. That is, the &lt;code&gt;total&lt;/code&gt; value is &lt;strong&gt;not&lt;/strong&gt; supposed to be equal to the total size of all pages mapped to the emulator.</source>
          <target state="translated">&lt;code&gt;total&lt;/code&gt; 값은 동적 에뮬레이터에 의해 할당 된 메모리의 총량 가정된다. 공유 라이브러리, 에뮬레이터 자체의 코드 및 에뮬레이터 스택은 포함되지 않아야합니다. 즉, &lt;code&gt;total&lt;/code&gt; 값이되어 &lt;strong&gt;있지&lt;/strong&gt; 에뮬레이터에 매핑 된 모든 페이지의 전체 크기와 동일해야하는데.</target>
        </trans-unit>
        <trans-unit id="855a90cd384864cf599ca9011960a53bac88f853" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;trim&lt;/code&gt; behavior corresponds exactly to the Perl default. &lt;code&gt;{parts,N}&lt;/code&gt;, where N is a positive integer, corresponds exactly to the Perl behavior with a positive numerical third parameter. The default behavior of &lt;code&gt;split/3&lt;/code&gt; corresponds to the Perl behavior when a negative integer is specified as the third parameter for the Perl routine.</source>
          <target state="translated">&lt;code&gt;trim&lt;/code&gt; 동작은 정확히 펄의 기본에 해당합니다. &lt;code&gt;{parts,N}&lt;/code&gt; (여기서 N은 양의 정수임)은 양의 세 번째 매개 변수를 사용하여 Perl 동작에 정확히 해당합니다. &lt;code&gt;split/3&lt;/code&gt; 의 기본 동작은 음수 정수가 Perl 루틴의 세 번째 매개 변수로 지정된 경우 Perl 동작에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="503ae720e5d8f3760c374c5a7724a46be581ffb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; expression can also be augmented with an &lt;code&gt;after&lt;/code&gt; section, intended to be used for cleanup with side effects:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 발현도 함께 증대 될 수 있습니다 &lt;code&gt;after&lt;/code&gt; 섹션 부작용 정리에 사용하기위한 것 :</target>
        </trans-unit>
        <trans-unit id="9aa8fddb846b9b7abd8af53c04dc022f8bbdb56d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; expression can have an &lt;code&gt;of&lt;/code&gt; section:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 표현은 할 수 &lt;code&gt;of&lt;/code&gt; 섹션 :</target>
        </trans-unit>
        <trans-unit id="1247ef97bc2a099c330eff988713e9a5888387df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tuple()&lt;/code&gt; reason are other errors like for example &lt;code&gt;{exit_status,1}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tuple()&lt;/code&gt; 이유는, 예를 들어 같은 다른 오류이다 &lt;code&gt;{exit_status,1}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="874e9960e26401a3b617a3b1e2c19da394373ec5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; key is optional. If it is not given, the default value &lt;code&gt;worker&lt;/code&gt; will be used.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 키는 선택 사항입니다. 지정하지 않으면 기본값 &lt;code&gt;worker&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6ce30d2f89579b051b36741023e812a759179d4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; key is optional. If it is not specified, it defaults to &lt;code&gt;worker&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 키는 선택 사항입니다. 지정하지 않으면 기본값은 &lt;code&gt;worker&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8ab52ef65eee07504a8c99112afca9e52efb72ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u$bif:Module:Name/Arity&lt;/code&gt; constraint tests whether the given operand refers to a specific BIF. Note that &lt;code&gt;Module:Name/Arity&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be an existing BIF defined in &lt;code&gt;bif.tab&lt;/code&gt;, or there will be a compilation error. It is useful when a call to a specific BIF should be replaced with an instruction as in this example:</source>
          <target state="translated">&lt;code&gt;u$bif:Module:Name/Arity&lt;/code&gt; 주어진 피연산자 특정의 BIF을 의미 제약 조건 검사 여부를 지정합니다. 참고 것을 &lt;code&gt;Module:Name/Arity&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 기존 BIF에 정의 될 &lt;code&gt;bif.tab&lt;/code&gt; , 또는 컴파일 오류가있을 것입니다. 다음 예에서와 같이 특정 BIF에 대한 호출을 명령어로 대체해야 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d8f2c733d5f2c3ff7dc2fecb9f7616099b07cea0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u$func:Module:Name/Arity&lt;/code&gt; will test whether the given operand is a a specific function. Here is an example:</source>
          <target state="translated">&lt;code&gt;u$func:Module:Name/Arity&lt;/code&gt; 주어진 피연산자가 AA 특정 기능이 있는지 여부를 테스트합니다. 다음은 그 예입니다.</target>
        </trans-unit>
        <trans-unit id="58e0ceadd09742f3e89a0e0c489abdb4b9f52d05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u$is_not_bif&lt;/code&gt; constraint matches if the operand does not refer to a BIF (not listed in &lt;code&gt;bif.tab&lt;/code&gt;). For example:</source>
          <target state="translated">&lt;code&gt;u$is_not_bif&lt;/code&gt; 피연산자가 BIF (에 나열되지 않은 참조하지 않는 경우 제약 일치 &lt;code&gt;bif.tab&lt;/code&gt; ). 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="c8f1c69ed96b83a679b6a1461cadd4cb592d2117" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uds_command&lt;/code&gt; routine is the routine called when an Erlang process sends data to the port. This routine handles all asynchronous commands when the port is in &lt;code&gt;command&lt;/code&gt; mode and the sending of all data when the port is in &lt;code&gt;data&lt;/code&gt; mode:</source>
          <target state="translated">&lt;code&gt;uds_command&lt;/code&gt; 의 루틴은 얼랑 프로세스가 포트로 데이터를 보낼 때 호출 루틴입니다. 이 루틴은 포트가 &lt;code&gt;command&lt;/code&gt; 모드 에있을 때 모든 비동기 명령을 처리 하고 포트가 &lt;code&gt;data&lt;/code&gt; 모드 에있을 때 모든 데이터를 전송 합니다.</target>
        </trans-unit>
        <trans-unit id="12d38078aadeb17f73f6143b46507ced220c8b0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uds_input&lt;/code&gt; routine handles other input events (like non-blocking &lt;code&gt;accept&lt;/code&gt;), but most importantly handle data arriving at the socket by calling &lt;code&gt;do_recv&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;uds_input&lt;/code&gt; 의 (비 차단과 같은 일상적인 핸들 다른 입력 이벤트 &lt;code&gt;accept&lt;/code&gt; 하지만, 가장 중요한 것은 호출하여 소켓에 도착하는 데이터를 처리) &lt;code&gt;do_recv&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="202a772c2bbbb0c73373b15e1d87ffd28aa29133" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uds_input&lt;/code&gt; routine is called when data is available on a file descriptor previously passed to the &lt;code&gt;driver_select&lt;/code&gt; routine. This occurs typically when a read command is issued and no data is available. The &lt;code&gt;do_recv&lt;/code&gt; routine is as follows:</source>
          <target state="translated">&lt;code&gt;uds_input&lt;/code&gt; 의 루틴은 데이터가 이전에 전달되는 파일 기술자로 볼 때 호출되는 &lt;code&gt;driver_select&lt;/code&gt; 의 일상. 일반적으로 읽기 명령이 발행되고 사용 가능한 데이터가 없을 때 발생합니다. &lt;code&gt;do_recv&lt;/code&gt; 의 다음과 같은 루틴은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="afe5ea4f80f83ad57ad0aad31e10486a4f2bf930" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uds_start&lt;/code&gt; routine is called when a port is opened from Erlang. In this case, we only allocate a structure and initialize it. Creating the actual socket is left to the &lt;code&gt;uds_command&lt;/code&gt; routine.</source>
          <target state="translated">&lt;code&gt;uds_start&lt;/code&gt; 의 포트가 얼랑에서 열릴 때 루틴 호출된다. 이 경우 구조 만 할당하고 초기화합니다. 실제 소켓 작성은 &lt;code&gt;uds_command&lt;/code&gt; 루틴 에 맡겨집니다 .</target>
        </trans-unit>
        <trans-unit id="8bfbb24810f0c5b15e0b6448d90f972fe31a6386" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;undo&lt;/code&gt; function does nothing.</source>
          <target state="translated">&lt;code&gt;undo&lt;/code&gt; 함수는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7969bdd4f7e8e8283016abfb83b747e28e6525e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unicode&lt;/code&gt; module is clearly Unicode-aware. It contains functions for conversion between different Unicode formats and some utilities for identifying byte order marks. Few programs handling Unicode data survive without this module.</source>
          <target state="translated">&lt;code&gt;unicode&lt;/code&gt; 모듈은 명확하게 유니 코드 인식이다. 여기에는 다른 유니 코드 형식과 바이트 순서 표시를 식별하기위한 일부 유틸리티 간 변환 기능이 포함되어 있습니다. 이 모듈 없이는 유니 코드 데이터를 처리하는 프로그램이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="45fc4ab31edeed78de6dcc133ce43fa458252958" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update&lt;/code&gt; function is an alternative for updating module data of recompiled modules.</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 함수 컴파일 모듈의 모듈 데이터를 업데이트하는 대안이다.</target>
        </trans-unit>
        <trans-unit id="e7a993cc2041a3a5e4126cbf7ea824172decdb48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update&lt;/code&gt; instruction must contain the tuple &lt;code&gt;{advanced,Extra}&lt;/code&gt;. The instruction makes the special process call the callback function &lt;code&gt;system_code_change/4&lt;/code&gt;, a function the user must implement. The term &lt;code&gt;Extra&lt;/code&gt;, in this case &lt;code&gt;[]&lt;/code&gt;, is passed as is to &lt;code&gt;system_code_change/4&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 명령은 튜플 있어야합니다 &lt;code&gt;{advanced,Extra}&lt;/code&gt; . 이 명령은 특수 프로세스가 콜백 함수 인 &lt;code&gt;system_code_change/4&lt;/code&gt; 를 호출하도록 합니다.이 함수는 사용자가 구현해야합니다. &lt;code&gt;Extra&lt;/code&gt; 라는 용어 는이 경우 &lt;code&gt;[]&lt;/code&gt; 로 &lt;code&gt;system_code_change/4&lt;/code&gt; 로 그대로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="55a52d1bdeacd91af756556ef9395d795b7ce705" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;user_args&lt;/code&gt; configuration parameter which may be used to extend the argument list of the callback functions. For example, the handle_connect function takes by default two arguments:</source>
          <target state="translated">&lt;code&gt;user_args&lt;/code&gt; 의 콜백 함수의 인수 목록을 확장하는데 사용될 수있다 구성 파라미터. 예를 들어 handle_connect 함수는 기본적으로 두 개의 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c15ed8631e7be541ad2f112cab6d63b078785dc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vacmAccessTable&lt;/code&gt; maps the &lt;code&gt;groupName&lt;/code&gt; (found in &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt;), &lt;code&gt;contextName&lt;/code&gt;, &lt;code&gt;securityModel&lt;/code&gt;, and &lt;code&gt;securityLevel&lt;/code&gt; to an MIB view for each type of operation (read, write, or notify). The MIB view is represented as a &lt;code&gt;viewName&lt;/code&gt;. The definition of the MIB view represented by the &lt;code&gt;viewName&lt;/code&gt; is found in the &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;vacmAccessTable&lt;/code&gt; 는 지도 &lt;code&gt;groupName&lt;/code&gt; 을 (검색된 &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt; ) &lt;code&gt;contextName&lt;/code&gt; , &lt;code&gt;securityModel&lt;/code&gt; 및 &lt;code&gt;securityLevel&lt;/code&gt; 동작의 각 유형 (기록을 판독 또는 통지)에 대한 MIB 뷰로. MIB보기는 &lt;code&gt;viewName&lt;/code&gt; 으로 표시됩니다 . &lt;code&gt;viewName&lt;/code&gt; 으로 표시되는 MIB보기의 정의 는 &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a70d16c49aee0ecab7697bd61b2b47a75fed9fc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vacmContextTable&lt;/code&gt; is a read-only table that lists all available contexts.</source>
          <target state="translated">&lt;code&gt;vacmContextTable&lt;/code&gt; 은 읽기 전용 테이블 그 목록을 사용할 수있는 모든 상황이다.</target>
        </trans-unit>
        <trans-unit id="ef9aac3e2a8987ec6dd80992e0534a1b71403af1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt; maps a &lt;code&gt;securityModel&lt;/code&gt; and a &lt;code&gt;securityName&lt;/code&gt; to a &lt;code&gt;groupName&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt; 는 매핑 &lt;code&gt;securityModel&lt;/code&gt; 과 &lt;code&gt;securityName&lt;/code&gt; A와 &lt;code&gt;groupName&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28801f1623b234b9de96cc740a98bd5f85c06c85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; is indexed by the &lt;code&gt;viewName&lt;/code&gt;, and defines which objects are included in the MIB view.</source>
          <target state="translated">&lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; 는 에 의해 인덱싱 &lt;code&gt;viewName&lt;/code&gt; 과 물체가 MIB 뷰에 포함되고, 정의한다.</target>
        </trans-unit>
        <trans-unit id="1870424a39adeddc9df6d1301607365bb578c850" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vfs&lt;/code&gt; layer of MacOS X enforces UTF-8 filenames in an aggressive way. Older versions did this by refusing to create non-UTF-8 conforming filenames, while newer versions replace offending bytes with the sequence &quot;%HH&quot;, where HH is the original character in hexadecimal notation. As Unicode translation is enabled by default on MacOS X, the only way to come up against this is to either start the VM with flag &lt;code&gt;+fnl&lt;/code&gt; or to use a raw filename in bytewise (&lt;code&gt;latin1&lt;/code&gt;) encoding. If using a raw filename, with a bytewise encoding containing characters from 127 through 255, to create a file, the file cannot be opened using the same name as the one used to create it. There is no remedy for this behavior, except keeping the filenames in the correct encoding.</source>
          <target state="translated">MacOS X 의 &lt;code&gt;vfs&lt;/code&gt; 레이어는 공격적인 방식으로 UTF-8 파일 이름을 적용합니다. 이전 버전은 UTF-8이 아닌 호환 파일 이름을 만드는 것을 거부함으로써이 작업을 수행했지만 최신 버전은 문제가되는 바이트를 시퀀스 &quot;% HH&quot;로 대체합니다. 여기서 HH는 16 진 표기법의 원래 문자입니다. MacOS X에서 유니 코드 변환이 기본적으로 활성화되어 있기 때문에이 문제를 &lt;code&gt;+fnl&lt;/code&gt; 있는 유일한 방법은 플래그 + fnl로 VM을 시작 하거나 원시 파일 이름을 바이트 단위 ( &lt;code&gt;latin1&lt;/code&gt; ) 인코딩으로 사용하는 것입니다. 127에서 255까지의 문자를 포함하는 바이트 단위 인코딩으로 원시 파일 이름을 사용하여 파일을 작성하는 경우 파일을 작성하는 데 사용 된 것과 동일한 이름으로 파일을 열 수 없습니다. 파일 이름을 올바른 인코딩으로 유지하는 것을 제외하고는이 동작에 대한 해결책이 없습니다.</target>
        </trans-unit>
        <trans-unit id="831df5545d1b1c7760cea7009d162230198cc0e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;werl&lt;/code&gt; window is in many ways modeled after the &lt;code&gt;xterm&lt;/code&gt; window present on other platforms, as the &lt;code&gt;xterm&lt;/code&gt; model fits well with line-oriented command-based interaction. This means that selecting text is line-oriented rather than rectangle-oriented.</source>
          <target state="translated">&lt;code&gt;werl&lt;/code&gt; 의 창은 모델로 여러 가지 방법에 &lt;code&gt;xterm&lt;/code&gt; 은 AS, 다른 플랫폼에서 창 현재 &lt;code&gt;xterm&lt;/code&gt; 모델 라인 지향 명령 기반 상호 작용과 잘 맞습니다. 즉, 텍스트 선택은 사각형이 아니라 선이됩니다.</target>
        </trans-unit>
        <trans-unit id="cb0a24e0ba3c71a8aad37252c9a038696dacac35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;whereis&lt;/code&gt; function-call verifies that the SSL application is started.</source>
          <target state="translated">&lt;code&gt;whereis&lt;/code&gt; 기능 - 통화를 검증은 SSL 응용 프로그램이 시작된다.</target>
        </trans-unit>
        <trans-unit id="e2ea2763aab3c4567e48b6fa3d1366d90dff0b7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write_concurrency&lt;/code&gt; option can be combined with the options &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt; read_concurrency&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#new_2_decentralized_counters&quot;&gt; decentralized_counters&lt;/a&gt;&lt;/code&gt;. You typically want to combine &lt;code&gt;write_concurrency&lt;/code&gt; with &lt;code&gt;read_concurrency&lt;/code&gt; when large concurrent read bursts and large concurrent write bursts are common; for more information, see option &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt; read_concurrency&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;decentralized_counters&lt;/code&gt; option is turned on by default for tables of type &lt;code&gt;ordered_set&lt;/code&gt; with the &lt;code&gt;write_concurrency&lt;/code&gt; option enabled, and the &lt;code&gt;decentralized_counters&lt;/code&gt; option is turned off by default for all other table types. For more information, see the documentation for the &lt;code&gt;&lt;a href=&quot;#new_2_decentralized_counters&quot;&gt; decentralized_counters&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;write_concurrency&lt;/code&gt; 의 옵션은 옵션과 결합 될 수 &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt; read_concurrency&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#new_2_decentralized_counters&quot;&gt; decentralized_counters&lt;/a&gt;&lt;/code&gt; . 일반적으로 큰 동시 읽기 버스트 및 큰 동시 쓰기 버스트가 일반적 일 때 &lt;code&gt;write_concurrency&lt;/code&gt; 와 &lt;code&gt;read_concurrency&lt;/code&gt; 를 결합하려고합니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt; read_concurrency&lt;/a&gt;&lt;/code&gt; 옵션을 참조하십시오 . &lt;code&gt;decentralized_counters&lt;/code&gt; 의 옵션은 유형의 테이블에 기본적으로 설정되어 &lt;code&gt;ordered_set&lt;/code&gt; 와 &lt;code&gt;write_concurrency&lt;/code&gt; 의 옵션이 활성화하고 &lt;code&gt;decentralized_counters&lt;/code&gt; 의 옵션은 다른 모든 테이블 유형에 대해 기본적으로 해제되어 있습니다. 자세한 내용은 다음 문서를 참조하십시오. &lt;code&gt;&lt;a href=&quot;#new_2_decentralized_counters&quot;&gt; decentralized_counters&lt;/a&gt;&lt;/code&gt; 옵션.</target>
        </trans-unit>
        <trans-unit id="a6d05af96ec0e7231d4e09ddd7a1fc622f5621cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{OtherRefId,term()}&lt;/code&gt; is defined by the user and is passed to the &lt;code&gt;match_fun&lt;/code&gt;, if defined. If the term in &lt;code&gt;OtherRefId&lt;/code&gt; is a binary, it will be converted to a string.</source>
          <target state="translated">&lt;code&gt;{OtherRefId,term()}&lt;/code&gt; 사용자에 의해 정의되며에 전달 &lt;code&gt;match_fun&lt;/code&gt; 정의 경우. &lt;code&gt;OtherRefId&lt;/code&gt; 의 용어 가 이진이면 문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="19e1b6293cd5c62e374c8457e4fbd9d95a253158" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{mod, {Module,StartArgs}}&lt;/code&gt; option must be included. This option is used to find the callback module &lt;code&gt;Module&lt;/code&gt; of the application. &lt;code&gt;StartArgs&lt;/code&gt; is ignored, as &lt;code&gt;Module:start/2&lt;/code&gt; is called only for the primary application.</source>
          <target state="translated">&lt;code&gt;{mod, {Module,StartArgs}}&lt;/code&gt; 옵션이 포함되어야합니다. 이 옵션은 응용 프로그램 의 콜백 모듈 &lt;code&gt;Module&lt;/code&gt; 을 찾는 데 사용됩니다 . 기본 애플리케이션에 대해서만 &lt;code&gt;Module:start/2&lt;/code&gt; 가 호출되므로 &lt;code&gt;StartArgs&lt;/code&gt; 는 무시 됩니다.</target>
        </trans-unit>
        <trans-unit id="4668f1fd645c2ffa2dba60de3db8016985e65bc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{ok,tut}&lt;/code&gt; means that the compilation is OK. If it says &quot;error&quot; it means that there is some mistake in the text that you entered. Additional error messages gives an idea to what is wrong so you can modify the text and then try to compile the program again.</source>
          <target state="translated">&lt;code&gt;{ok,tut}&lt;/code&gt; 컴파일이 확인되는 것을 의미한다. &quot;오류&quot;라고 표시되면 입력 한 텍스트에 오류가 있음을 의미합니다. 추가 오류 메시지는 무엇이 잘못되었는지에 대한 아이디어를 제공하므로 텍스트를 수정 한 다음 프로그램을 다시 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37c82dec6529acb72fb125b0bac4fda347c61081" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{packet, N}&lt;/code&gt; and &lt;code&gt;{line, L}&lt;/code&gt; settings are mutually exclusive.</source>
          <target state="translated">&lt;code&gt;{packet, N}&lt;/code&gt; 및 &lt;code&gt;{line, L}&lt;/code&gt; 의 설정은 서로 배타적이다.</target>
        </trans-unit>
        <trans-unit id="971d55e17028d3606b6c283922622f2c0932a483" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{port,PortNum}&lt;/code&gt; tuple is optional and if omitted, default Telnet port 23 is used. Also the &lt;code&gt;keep_alive&lt;/code&gt; tuple is optional, and the value defauls to &lt;code&gt;true&lt;/code&gt; (enabled).</source>
          <target state="translated">&lt;code&gt;{port,PortNum}&lt;/code&gt; 튜플는 선택 사항이며 생략하는 경우, 기본 텔넷 포트 (23)가 사용된다. 또한 &lt;code&gt;keep_alive&lt;/code&gt; 튜플은 선택 사항이며 값은 &lt;code&gt;true&lt;/code&gt; 로 설정됩니다 (활성화 됨).</target>
        </trans-unit>
        <trans-unit id="fa6ece2cc8b2e8dafa07d4e08292eb70bec23c2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{start_phases, [{Phase,PhaseArgs}]}&lt;/code&gt; option must be included, and the set of specified phases must be a subset of the set of phases specified for the primary application.</source>
          <target state="translated">&lt;code&gt;{start_phases, [{Phase,PhaseArgs}]}&lt;/code&gt; 옵션을 포함해야하며, 지정된 위상의 세트는 기본 애플리케이션에 대해 지정된 단계들의 세트의 서브 세트이어야한다.</target>
        </trans-unit>
        <trans-unit id="ff25bb9b46c77ee1bd1587510f1046fea71955a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;||&lt;/code&gt; &quot;such that&quot; and the arrow &lt;code&gt;&amp;lt;-&lt;/code&gt; is read as &quot;taken from&quot;.</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt; &quot;그런&quot;및 화살표 &lt;code&gt;&amp;lt;-&lt;/code&gt; 는 &quot;취득한&quot;것으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="8950a73316b6b3766c9706406f02f3f2dda35162" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;Cartesian_product&quot;&gt;Cartesian product&lt;/strong&gt; of two sets X and Y, denoted X &amp;times; Y, is the set {a : a = (x, y) for some x in X and for some y in Y}.</source>
          <target state="translated">X &amp;times; Y로 표시된 두 세트 X와 Y 의 &lt;strong id=&quot;Cartesian_product&quot;&gt;데카르트 곱은&lt;/strong&gt; X의 일부 x와 Y의 일부 y에 대한 집합 {a : a = (x, y)입니다.</target>
        </trans-unit>
        <trans-unit id="97f5043ae782de1e349c1f4e82a07bd359c0964c" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;converse&quot;&gt;converse&lt;/strong&gt; of R is the set {a : a = (y, x) for some (x, y) in R}.</source>
          <target state="translated">R 의 &lt;strong id=&quot;converse&quot;&gt;반대&lt;/strong&gt; 는 R의 일부 (x, y)에 대한 집합 {a : a = (y, x)입니다.</target>
        </trans-unit>
        <trans-unit id="c74f91b2df651d6f1d918e8b3fa79c423cad5e1b" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;difference&quot;&gt;difference&lt;/strong&gt; of two sets A and B is the set that contains all elements of A that do not belong to B.</source>
          <target state="translated">두 세트 A와 B 의 &lt;strong id=&quot;difference&quot;&gt;차이&lt;/strong&gt; 는 B에 속하지 않는 A의 모든 요소를 ​​포함하는 세트입니다.</target>
        </trans-unit>
        <trans-unit id="efd11e10dc9bffd3ce00966684d96fd8a122cb0d" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;domain&quot;&gt;domain&lt;/strong&gt; of R is the set {x : x R y for some y in Y}.</source>
          <target state="translated">R 의 &lt;strong id=&quot;domain&quot;&gt;도메인&lt;/strong&gt; 은 세트 {x : x R y in Y의 일부 y}입니다.</target>
        </trans-unit>
        <trans-unit id="377184fb47eff2618a884d3371438181861419a0" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;field&quot;&gt;field&lt;/strong&gt; of a relation R in X is the union of the domain of R and the range of R.</source>
          <target state="translated">X에서 관계 R 의 &lt;strong id=&quot;field&quot;&gt;필드&lt;/strong&gt; 는 R 도메인과 R 범위의 합집합입니다.</target>
        </trans-unit>
        <trans-unit id="1a9617de87db1af0121da59eba19d31a6b757eff" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;in_degree&quot;&gt;in-degree&lt;/strong&gt; of a vertex is the number of edges incident on that vertex.</source>
          <target state="translated">&lt;strong id=&quot;in_degree&quot;&gt;에서도&lt;/strong&gt; 정점의 정점은 그 가장자리에 입사하는 숫자이다.</target>
        </trans-unit>
        <trans-unit id="4c0e00f79ce45926299ee2f3508020fdf2f45df9" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;intersection&quot;&gt;intersection&lt;/strong&gt; of two sets A and B is the set that contains all elements of A that belong to B.</source>
          <target state="translated">두 세트 A와 B 의 &lt;strong id=&quot;intersection&quot;&gt;교집합&lt;/strong&gt; 은 B에 속하는 A의 모든 요소를 ​​포함하는 세트입니다.</target>
        </trans-unit>
        <trans-unit id="3f1d912f47b338c33084d89f0c15a5a316197ecb" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;intersection_n&quot;&gt;intersection&lt;/strong&gt; of a non-empty collection of sets is the set that contains all elements that belong to every set of the collection.</source>
          <target state="translated">비어 있지 않은 세트의 집합 의 &lt;strong id=&quot;intersection_n&quot;&gt;교차점&lt;/strong&gt; 은 모든 컬렉션 집합에 속하는 모든 요소를 ​​포함하는 집합입니다.</target>
        </trans-unit>
        <trans-unit id="429f2c89c9e807577354da0b8e15a8e248018d77" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;length&quot;&gt;length&lt;/strong&gt; of path P is k-1.</source>
          <target state="translated">경로 P 의 &lt;strong id=&quot;length&quot;&gt;길이&lt;/strong&gt; 는 k-1입니다.</target>
        </trans-unit>
        <trans-unit id="abc21b67f672b304bee1db7701b820f9b24de3c6" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;natural_join&quot;&gt;natural join&lt;/strong&gt; of an n-ary relation R and an m-ary relation S on coordinate i and j is defined to be the set {z : z = (x[1], ..., x[n], y[1], ..., y[j-1], y[j+1], ..., y[m]) for some (x[1], ..., x[n]) in R and for some (y[1], ..., y[m]) in S such that x[i] = y[j]}.</source>
          <target state="translated">좌표 i 및 j에서 n-ary 관계 R과 m-ary 관계 S 의 &lt;strong id=&quot;natural_join&quot;&gt;자연 결합&lt;/strong&gt; 은 집합 {z : z = (x [1], ..., x [n], y [ R에서 일부 (x [1], ..., x [n])에 대해 1], ..., y [j-1], y [j + 1], ..., y [m]) x [i] = y [j]}가되도록 S의 일부 (y [1], ..., y [m])에 대해.</target>
        </trans-unit>
        <trans-unit id="adf6489e3c93a13ca7fd19239f3939863c02f11d" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;out_degree&quot;&gt;out-degree&lt;/strong&gt; of a vertex is the number of edges emanating from that vertex.</source>
          <target state="translated">정점 의 &lt;strong id=&quot;out_degree&quot;&gt;바깥 쪽 정도&lt;/strong&gt; 는 해당 정점에서 나오는 가장자리 수입니다.</target>
        </trans-unit>
        <trans-unit id="7c6a3c4f02bedbb63c4000218f9eaa4b3029b656" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;projection&quot;&gt;projection&lt;/strong&gt; of an n-ary relation R onto coordinate i is the set {x[i] : (x[1], ..., x[i], ..., x[n]) in R for some x[j] in X[j], 1 &amp;lt;= j &amp;lt;= n and not i = j}. The projections of a binary relation R onto the first and second coordinates are the domain and the range of R, respectively.</source>
          <target state="translated">&lt;strong id=&quot;projection&quot;&gt;투영&lt;/strong&gt; 좌표 상에 n 진 관계 R의 i는 집합 {x는 [I] (X [1], ..., X [I], ..., X [N])에 대한 약간의 X R에 X [j]에서 [j], 1 &amp;lt;= j &amp;lt;= n이고 i = j} 아님. 제 1 및 제 2 좌표에 대한 이진 관계 R의 투영은 각각 도메인 및 R의 범위이다.</target>
        </trans-unit>
        <trans-unit id="928618861a3a7864fa16dc6571d48344039643c2" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;range&quot;&gt;range&lt;/strong&gt; of R is the set {y : x R y for some x in X}.</source>
          <target state="translated">R 의 &lt;strong id=&quot;range&quot;&gt;범위&lt;/strong&gt; 는 세트 {y : x R y in x in X}입니다.</target>
        </trans-unit>
        <trans-unit id="a0513ff69692a7179c5c24f4ad25a5aa23d84d71" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;restriction&quot;&gt;restriction&lt;/strong&gt; of R to A is the set S defined so that x S y if and only if there exists an element x in A such that x R y.</source>
          <target state="translated">R에 대한 A 의 &lt;strong id=&quot;restriction&quot;&gt;제한&lt;/strong&gt; 은 x에 해당하는 요소 x가 존재하는 경우에만 x S y가되도록 정의 된 세트 S이다.</target>
        </trans-unit>
        <trans-unit id="53dd8e97ddf5e81c0a22de5f228a88721f6ccc8d" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;symmetric_difference&quot;&gt;symmetric difference&lt;/strong&gt; of two sets is the set that contains those element that belong to either of the two sets, but not both.</source>
          <target state="translated">두 세트 의 &lt;strong id=&quot;symmetric_difference&quot;&gt;대칭 적 차이&lt;/strong&gt; 는 두 세트 중 하나에 속하는 요소를 포함하는 세트입니다.</target>
        </trans-unit>
        <trans-unit id="baf0cfcddb027f4d4f3dff2390047419348137ab" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;union&quot;&gt;union&lt;/strong&gt; of two sets A and B is the smallest set that contains all elements of A and all elements of B.</source>
          <target state="translated">두 세트 A와 B 의 &lt;strong id=&quot;union&quot;&gt;합집합&lt;/strong&gt; 은 A의 모든 요소와 B의 모든 요소를 ​​포함하는 가장 작은 세트입니다.</target>
        </trans-unit>
        <trans-unit id="81d4f87a2b598bff542bef7879776b07f0f811bb" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;union_n&quot;&gt;union&lt;/strong&gt; of a collection of sets is the smallest set that contains all the elements that belong to at least one set of the collection.</source>
          <target state="translated">집합 집합 의 &lt;strong id=&quot;union_n&quot;&gt;합집합&lt;/strong&gt; 은 하나 이상의 집합 집합에 속하는 모든 요소를 ​​포함하는 가장 작은 집합입니다.</target>
        </trans-unit>
        <trans-unit id="5d51e506fb7ebd09e0439b577c3665c859bbc0bf" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Auto Attach&lt;/strong&gt; boxes, &lt;strong&gt;Stack Trace&lt;/strong&gt; label, &lt;strong&gt;Back Trace Size&lt;/strong&gt; label, and &lt;strong&gt;Strings&lt;/strong&gt; box display some options set. For details about these options, see section &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;Options Menu&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;자동 부착&lt;/strong&gt; 상자, &lt;strong&gt;스택 추적&lt;/strong&gt; 라벨, &lt;strong&gt;역 추적 크기&lt;/strong&gt; 레이블 및 &lt;strong&gt;문자열&lt;/strong&gt; 상자 디스플레이 설정 몇 가지 옵션. 이러한 옵션에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;Options Menu&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="abcaf1a971590700133b8016539b636c71ba876f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Break&lt;/strong&gt;, &lt;strong&gt;Windows&lt;/strong&gt;, and &lt;strong&gt;Help&lt;/strong&gt; menus are the same as in the &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor Window&lt;/a&gt;&lt;/code&gt;, except that the &lt;strong&gt;Break&lt;/strong&gt; menu applies only to local breakpoints.</source>
          <target state="translated">&lt;strong&gt;브레이크&lt;/strong&gt; , &lt;strong&gt;윈도우&lt;/strong&gt; 및 &lt;strong&gt;도움말&lt;/strong&gt; 메뉴는에서와 동일 &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor Window&lt;/a&gt;&lt;/code&gt; 것을 제외하고, &lt;strong&gt;브레이크의&lt;/strong&gt; 메뉴는 현지 중단 점에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a10eb03f19350fbdf85025a9eab01c5153042f77" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Break&lt;/strong&gt;, &lt;strong&gt;Windows&lt;/strong&gt;, and &lt;strong&gt;Help&lt;/strong&gt; menus are the same as in the &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor Window&lt;/a&gt;&lt;/code&gt;, except that the &lt;strong&gt;Breaks&lt;/strong&gt; menu applies only to local breakpoints.</source>
          <target state="translated">&lt;strong&gt;브레이크&lt;/strong&gt; , &lt;strong&gt;윈도우&lt;/strong&gt; 및 &lt;strong&gt;도움말&lt;/strong&gt; 메뉴는에서와 동일 &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor Window&lt;/a&gt;&lt;/code&gt; 것을 제외하고, &lt;strong&gt;휴식의&lt;/strong&gt; 메뉴는 현지 중단 점에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="81208a589d29fcc1ae9246757bcbbd412aee1292" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Common Test Hook (CTH)&lt;/strong&gt; framework allows extensions of the default behavior of &lt;code&gt;Common Test&lt;/code&gt; by callbacks before and after all test suite calls. It is intended for advanced users of &lt;code&gt;Common Test&lt;/code&gt; who want to abstract out behavior that is common to multiple test suites.</source>
          <target state="translated">&lt;strong&gt;일반적인 테스트 훅 (CTH)&lt;/strong&gt; 프레임 워크의 기본 동작의 확장 할 수 있습니다 &lt;code&gt;Common Test&lt;/code&gt; 전에 모든 테스트 스위트 통화 후 콜백으로합니다. 여러 테스트 스위트에 공통적 인 동작을 추상화하려는 &lt;code&gt;Common Test&lt;/code&gt; 의 고급 사용자를위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="e6fc5c94241e7e52f12a5fd7bd3416eff9018efa" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Common Test Hook (CTH)&lt;/strong&gt; framework allows extensions of the default behavior of &lt;code&gt;Common Test&lt;/code&gt; using hooks before and after all test suite calls. CTHs allow advanced &lt;code&gt;Common Test&lt;/code&gt; users to abstract out behavior that is common to multiple test suites without littering all test suites with library calls. This can be used for logging, starting, and monitoring external systems, building C files needed by the tests, and so on.</source>
          <target state="translated">&lt;strong&gt;일반적인 테스트 훅 (CTH)&lt;/strong&gt; 프레임 워크의 기본 동작의 확장 할 수 있습니다 &lt;code&gt;Common Test&lt;/code&gt; 전에 모든 테스트 스위트 통화 후 후크를 사용합니다. CTH를 사용하면 고급 &lt;code&gt;Common Test&lt;/code&gt; 사용자는 모든 테스트 스위트를 라이브러리 호출로 어지럽히 지 않고 여러 테스트 스위트에 공통적 인 동작을 추출 할 수 있습니다. 이것은 외부 시스템의 로깅, 시작 및 모니터링, 테스트에 필요한 C 파일 작성 등에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03e6f71f473d365a318259d6ca0121e4f4c728af" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Common Test Property Testing Support (ct_property_test)&lt;/strong&gt; is an aid to run property based testing tools in Common Test test suites.</source>
          <target state="translated">&lt;strong&gt;일반적인 테스트 속성 테스트 지원 (ct_property_test)&lt;/strong&gt; 공통 시험 테스트 스위트에 테스트 도구를 기반으로 실행 속성에 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="18cdc049609d4e15a26ab891a990c31ae80de460" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;File&lt;/strong&gt; and &lt;strong&gt;Edit&lt;/strong&gt; menus are the same as in the &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process Window&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;파일&lt;/strong&gt; 및 &lt;strong&gt;편집&lt;/strong&gt; 메뉴는과 동일 &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process Window&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff4e15bb4c0b2061b264590ff96d04af89b93805" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;File&lt;/strong&gt; menu includes options to save the contents of the &lt;strong&gt;Log&lt;/strong&gt; window and the &lt;strong&gt;Warnings&lt;/strong&gt; window. Simply choose the options and enter the file to save the contents in.</source>
          <target state="translated">&lt;strong&gt;파일&lt;/strong&gt; 메뉴의 내용을 저장하는 옵션이 포함되어 &lt;strong&gt;로그&lt;/strong&gt; 창 및 &lt;strong&gt;경고&lt;/strong&gt; 창을여십시오. 옵션을 선택하고 파일을 입력하여 내용을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="370a6214852f8fdbb6373c8997912c0758173f20" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;File&lt;/strong&gt; window displays a listing of the current directory. Click your way to the directories/modules you want to add or type the correct path in the entry.</source>
          <target state="translated">&lt;strong&gt;파일&lt;/strong&gt; 창이 표시는 현재 디렉토리의 목록. 추가하려는 디렉토리 / 모듈로가는 길을 클릭하거나 항목에 올바른 경로를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="8e3940de2fcf0c6b61297d85ec453fc7187e592a" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;OTP design principles&lt;/strong&gt; define how to structure Erlang code in terms of processes, modules, and directories.</source>
          <target state="translated">&lt;strong&gt;OTP 설계 원칙은&lt;/strong&gt; 프로세스, 모듈 및 디렉토리의 측면에서 얼랑 코드를 구성하는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="ce6dbe8f8ec89aa3b4f8a5fbd8bce3df7dce0384" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;anonymous variable&lt;/strong&gt; is denoted by underscore (_) and can be used when a variable is required but its value can be ignored.</source>
          <target state="translated">&lt;strong&gt;익명 변수&lt;/strong&gt; 밑줄 (_)을 표시하고, 변수가 필요하지만, 그 값은 무시 될 수있을 때 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="a6798179458a851b9ebec479cdde3c475bff4cbb" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;application resource file&lt;/strong&gt; specifies the resources an application uses, and how the application is started. There must always be one application resource file called &lt;code&gt;Application.app&lt;/code&gt; for each application &lt;code&gt;Application&lt;/code&gt; in the system.</source>
          <target state="translated">&lt;strong&gt;응용 프로그램의 리소스 파일은&lt;/strong&gt; 응용 프로그램이 사용하는 자원을 지정하고, 응용 프로그램이 어떻게 시작됩니다. 시스템의 각 응용 &lt;code&gt;Application&lt;/code&gt; 응용 프로그램 마다 &lt;code&gt;Application.app&lt;/code&gt; 라는 응용 프로그램 리소스 파일이 항상 하나 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f6e14a23d7c2ef8d516ebeb71a889d63ab7e5e5f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;application upgrade file&lt;/strong&gt; defines how an application is upgraded or downgraded in a running system.</source>
          <target state="translated">&lt;strong&gt;응용 프로그램 업그레이드 파일의&lt;/strong&gt; 응용 프로그램 업그레이드 또는 실행중인 시스템에서 다운 그레이드하는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6724ecd893c2f90d64929956a749eae932ffa031" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;beam_makeops&lt;/strong&gt; Perl script is used at build-time by both the compiler and runtime system. Given a number of input files (all with the extension &lt;code&gt;.tab&lt;/code&gt;), it will generate source files used by the Erlang compiler and by the runtime system to load and execute BEAM instructions.</source>
          <target state="translated">는 &lt;strong&gt;beam_makeops&lt;/strong&gt; 펄 스크립트 컴파일러와 런타임 시스템을 모두 구축시에 사용된다. 많은 입력 파일 (확장자 &lt;code&gt;.tab&lt;/code&gt; )이 주어지면 Erlang 컴파일러와 런타임 시스템에서 BEAM 명령어를로드하고 실행하는 데 사용하는 소스 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2db57b7456855f2efbc5591cfd1f43a7d95e2566" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;boot script&lt;/strong&gt; describes how the Erlang runtime system is started. It contains instructions on which code to load and which processes and applications to start.</source>
          <target state="translated">&lt;strong&gt;부팅 스크립트는&lt;/strong&gt; 얼랭 런타임 시스템이 시작하는 방법에 대해 설명합니다. 로드 할 코드와 시작할 프로세스 및 응용 프로그램에 대한 지침이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c43e23aec0edb2b1553fbf3a42ab629ff93e0727" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback mode&lt;/strong&gt; is a property of the &lt;strong&gt;callback module&lt;/strong&gt; and is set at server start. It may be changed due to a code upgrade/downgrade, or when changing the &lt;strong&gt;callback module&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;콜백 모드&lt;/strong&gt; 의 속성입니다 &lt;strong&gt;콜백 모듈&lt;/strong&gt; 및 서버 시작시에 설정됩니다. 코드 업그레이드 / 다운 그레이드 또는 &lt;strong&gt;콜백 모듈&lt;/strong&gt; 변경시 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0117a440e83974bf851c56ecb41421105f272e12" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback mode&lt;/strong&gt; is selected by implementing a mandatory callback function &lt;code&gt; Module:callback_mode() &lt;/code&gt; that returns one of the &lt;strong&gt;callback modes&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;콜백 모드는&lt;/strong&gt; 필수 콜백 함수의 실행에 의해 선택된 &lt;code&gt; Module:callback_mode() &lt;/code&gt; 의 복귀 한 그 &lt;strong&gt;콜백 모드&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5741097334e8b8597284eb3550244c5de695e977" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback mode&lt;/strong&gt; is selected when starting the &lt;code&gt;gen_statem&lt;/code&gt; and after code change using the return value from &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;콜백 모드가&lt;/strong&gt; 개시 될 때 선택 &lt;code&gt;gen_statem&lt;/code&gt; 를 코드 변화 후에 반환 값을 사용 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b41a677df62f29884be14a8c6c25a7497c11480" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback mode&lt;/strong&gt; is selected with the return value from &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;콜백 모드&lt;/strong&gt; 의 리턴 값으로 선택 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5bffb738c6ff50eb3adeb56460c8af109c3f28df" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback mode&lt;/strong&gt;&lt;code&gt;handle_event_function&lt;/code&gt; enables using a non-atom state as described in section &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt;, for example, a complex state term like a tuple.</source>
          <target state="translated">&lt;strong&gt;콜백 모드 &lt;/strong&gt; &lt;code&gt;handle_event_function&lt;/code&gt; 이 섹션에 설명 된대로가 아닌 원자의 상태를 사용 가능 &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt; , 예를 들어, 투플 같은 복잡한 상태 용어.</target>
        </trans-unit>
        <trans-unit id="3427359c72c6325ce793c2593793b153f136ba5e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback module&lt;/strong&gt; can be changed for a running server using any of the &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt;transition actions&lt;/a&gt;&lt;/code&gt;&lt;code&gt;{change_callback_module, NewModule}&lt;/code&gt;, &lt;code&gt;{push_callback_module, NewModule}&lt;/code&gt; or &lt;code&gt;pop_callback_module&lt;/code&gt;. Note that this is a pretty esoteric thing to do... The origin for this feature is a protocol that after version negotiation branches off into quite different state machines depending on the protocol version. There</source>
          <target state="translated">&lt;strong&gt;콜백 모듈&lt;/strong&gt; 의 모든 사용하여 실행중인 서버에 변경 될 수 있습니다 &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt;transition actions&lt;/a&gt;&lt;/code&gt; &lt;code&gt;{change_callback_module, NewModule}&lt;/code&gt; , &lt;code&gt;{push_callback_module, NewModule}&lt;/code&gt; 또는 &lt;code&gt;pop_callback_module&lt;/code&gt; 을 . 이것은 매우 난해한 작업입니다.이 기능의 기원은 버전 협상 후 프로토콜 버전에 따라 매우 다른 상태 시스템으로 분기되는 프로토콜입니다. 그곳에</target>
        </trans-unit>
        <trans-unit id="61740187206076da0d0e88e42b8dcd3ef778c9b8" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback module&lt;/strong&gt; contains functions that implement the state machine. When an event occurs, the &lt;code&gt;gen_statem&lt;/code&gt; behaviour engine calls a function in the &lt;strong&gt;callback module&lt;/strong&gt; with the event, current state and server data. This function performs the actions for this event, and returns the new state and server data and also actions to be performed by the behaviour engine.</source>
          <target state="translated">&lt;strong&gt;콜백 모듈은&lt;/strong&gt; 상태 머신을 구현하는 기능이 포함되어 있습니다. 이벤트가 발생하면 &lt;code&gt;gen_statem&lt;/code&gt; 동작 엔진 은 이벤트, 현재 상태 및 서버 데이터와 함께 &lt;strong&gt;콜백 모듈&lt;/strong&gt; 의 함수를 호출합니다 . 이 함수는이 이벤트에 대한 작업을 수행하고 새 상태 및 서버 데이터와 동작 엔진에서 수행 할 작업을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="010c2dfc5017e7774d251ec3e8505c4cdafc0e30" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;detailed table events&lt;/strong&gt; are tuples like &lt;code&gt;{Oper, Table, Data, [OldRecs], ActivityId}&lt;/code&gt;, where:</source>
          <target state="translated">&lt;strong&gt;자세한 테이블 이벤트는&lt;/strong&gt; 같은 튜플이다 &lt;code&gt;{Oper, Table, Data, [OldRecs], ActivityId}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="790690408a0b723c21e944914ee3b6f33b9bfb5b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;dynamic node name&lt;/strong&gt; feature is supported from OTP 23. Both the temporary client node and the first connected peer node (supplying the dynamic node name) must be at least OTP 23 for it to work.</source>
          <target state="translated">&lt;strong&gt;동적 노드 이름&lt;/strong&gt; 기능은 OTP (23)에서 임시 클라이언트 노드와 (동적 노드 이름을 제공) 처음 연결된 피어 노드 작업에 대한 최소한 OTP (23)를해야 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="60cb531fb67c541100e62d6289d443a02cba5fa3" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;empty set&lt;/strong&gt; contains no elements.</source>
          <target state="translated">&lt;strong&gt;빈 세트&lt;/strong&gt; 에 요소가 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="529d8e8336cfdf10118ffc9b093a47018a9c6171" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;mstone2&lt;/strong&gt; is similar to the &lt;strong&gt;mstone1&lt;/strong&gt; tool, but in this case, each created process makes only &lt;strong&gt;one&lt;/strong&gt; run through the messages and then exits. A soon as a process exits, a new process (with the same config and messages) is created to takes its place. The number of messages processed in total is the mstone2(1) value.</source>
          <target state="translated">&lt;strong&gt;mstone2는&lt;/strong&gt; 받는 사람과 유사 &lt;strong&gt;mstone1의&lt;/strong&gt; 도구지만,이 경우 생성 된 각각의 프로세스는 만드는 &lt;strong&gt;하나의&lt;/strong&gt; 메시지와 다음 종료를 통해 실행. 프로세스가 종료 되 자마자 동일한 구성 및 메시지를 가진 새 프로세스가 생성됩니다. 총 처리 된 메시지 수는 mstone2 (1) 값입니다.</target>
        </trans-unit>
        <trans-unit id="b927187f56617f5aef02c9b312ff36f409a08649" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;ordered pair&lt;/strong&gt; of a and b, with first &lt;strong&gt;coordinate&lt;/strong&gt; a and second coordinate b, is denoted (a, b). An ordered pair is an &lt;strong&gt;ordered set&lt;/strong&gt; of two elements. In this module, ordered sets can contain one, two, or more elements, and parentheses are used to enclose the elements.</source>
          <target state="translated">제 1 &lt;strong&gt;좌표&lt;/strong&gt; a 및 제 2 좌표 b 를 갖는 &lt;strong&gt;순서화&lt;/strong&gt; 된 a 및 b의 &lt;strong&gt;쌍&lt;/strong&gt; 은 (a, b)로 표시된다. 순서 쌍은 순서가 &lt;strong&gt;지정된&lt;/strong&gt; 두 요소 &lt;strong&gt;집합&lt;/strong&gt; 입니다. 이 모듈에서 순서 집합은 하나, 둘 또는 그 이상의 요소를 포함 할 수 있으며 괄호는 요소를 묶는 데 사용됩니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c83c801cd635dbe318e9132115de7b55b1599720" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;receiver&lt;/strong&gt; is &lt;strong&gt;authoritative&lt;/strong&gt; for messages containing payload which expects a response (for example Get, GetNext, Get-Bulk, Set or Inform PDU).</source>
          <target state="translated">&lt;strong&gt;수신기&lt;/strong&gt; 이고 &lt;strong&gt;신뢰할&lt;/strong&gt; 응답 예상 함유 메시지 페이로드 (예를 얻기위한, GETNEXT는 벌크 - 위젯 설정 또는 PDU 알린다).</target>
        </trans-unit>
        <trans-unit id="ac92db4f0e00aaa89bb19e432441af806acad352" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;release handler&lt;/strong&gt; process belongs to the SASL application, which is responsible for &lt;strong&gt;release handling&lt;/strong&gt;, that is, unpacking, installation, and removal of release packages.</source>
          <target state="translated">&lt;strong&gt;릴리스 핸들러&lt;/strong&gt; 과정을 담당하는 SASL 응용 프로그램에 속하는 &lt;strong&gt;자료 처리&lt;/strong&gt; 풀고,이다, 설치 및 릴리스 패키지의 제거.</target>
        </trans-unit>
        <trans-unit id="91dc52a591c8ca51fdb38124dea4daf9b7e6ea32" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;release resource file&lt;/strong&gt; specifies which applications are included in a release (system) based on Erlang/OTP.</source>
          <target state="translated">&lt;strong&gt;릴리스 리소스 파일&lt;/strong&gt; 얼랑 / OTP에 기반 응용 프로그램 릴리스 (시스템)에 포함되어 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ad1a94e9c3dc7a7604b7beecc0ad4192b022ebdc" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;release upgrade file&lt;/strong&gt; describes how a release is upgraded in a running system.</source>
          <target state="translated">&lt;strong&gt;버전 업그레이드 파일은&lt;/strong&gt; 릴리스가 실행중인 시스템에서 업그레이드하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="df96a6a378319ab14151f9909dca99424881e367" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;sender&lt;/strong&gt; is &lt;strong&gt;authoritative&lt;/strong&gt; for messages containing payload which does &lt;strong&gt;not&lt;/strong&gt; expect a response (for example SNMPv2-Trap, Response or Report PDU).</source>
          <target state="translated">&lt;strong&gt;발신자&lt;/strong&gt; 이고 &lt;strong&gt;신뢰할&lt;/strong&gt; 않는 페이로드를 포함한 메시지 &lt;strong&gt;없다&lt;/strong&gt; (예 트랩은 SNMPv2 응답 또는 보고서 PDU를위한)에 대한 응답을 예상한다.</target>
        </trans-unit>
        <trans-unit id="4ac925cddc8d38d70b14e09284795baa1f665f91" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;simple table events&lt;/strong&gt; are tuples like &lt;code&gt;{Oper, Record, ActivityId}&lt;/code&gt;, where:</source>
          <target state="translated">&lt;strong&gt;간단한 테이블 이벤트는&lt;/strong&gt; 같은 튜플이다 &lt;code&gt;{Oper, Record, ActivityId}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c7623d1fa21054abc3e3ac53a4bbc8066dac8120" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;socket registry&lt;/strong&gt; is how we keep track of sockets. There are two functions that can be used for interaction: &lt;code&gt;&lt;a href=&quot;socket#number_of-0&quot;&gt;socket:number_of/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;socket#which_sockets-1&quot;&gt;socket:which_sockets/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;소켓 레지스트리는&lt;/strong&gt; 우리가 소켓을 추적하는 방법입니다. 상호 작용에 사용할 수있는 함수는 &lt;code&gt;&lt;a href=&quot;socket#number_of-0&quot;&gt;socket:number_of/0&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;socket#which_sockets-1&quot;&gt;socket:which_sockets/1&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e42f516326a33814c075d0ef2dd476acfd28000d" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;state callback&lt;/strong&gt; for a specific &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;gen_statem&lt;/code&gt; is the callback function that is called for all events in this state. It is selected depending on which &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; that the callback module defines with the callback function &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;상태 콜백&lt;/strong&gt; 특정에 대한 &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; A의 &lt;code&gt;gen_statem&lt;/code&gt; 은 이 상태에서 모든 이벤트에 대해 호출되는 콜백 함수입니다. 콜백 모듈이 콜백 함수 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 으로 정의 하는 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 에 따라 선택 됩니다.</target>
        </trans-unit>
        <trans-unit id="39642072ab882c38d48ac8e225ecf14ced26e9ee" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;state callback&lt;/strong&gt; is the callback function that handles an event in the current state, and which function that is depends on the &lt;strong&gt;callback mode&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;상태 콜백&lt;/strong&gt; 온 의존하다 함수 콜백 현재 상태에서 이벤트를 처리하는 기능, 및 &lt;strong&gt;콜백 모드&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="79b1ae1634c63df766310472c5f61e301e8fde51" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;state callback&lt;/strong&gt; return values are defined in the description of &lt;code&gt; Module:StateName/3 &lt;/code&gt; in the &lt;code&gt;gen_statem&lt;/code&gt; manual page, but here is a more readable list:</source>
          <target state="translated">&lt;strong&gt;상태 콜백&lt;/strong&gt; 반환 값의 설명에 정의되어 &lt;code&gt; Module:StateName/3 &lt;/code&gt; 에 &lt;code&gt;gen_statem&lt;/code&gt; 매뉴얼 페이지,하지만 여기에 더 읽기 목록입니다 :</target>
        </trans-unit>
        <trans-unit id="2fcc34c431d064d6d4c4085640be13ac8df36a55" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;system tracer&lt;/strong&gt; for sequential tracing is automatically initiated by &lt;code&gt;ttb&lt;/code&gt; when a trace port is started with &lt;code&gt;ttb:tracer/0,1,2&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;시스템 추적&lt;/strong&gt; 순차적 인 추적을위한이 자동으로 시작됩니다 &lt;code&gt;ttb&lt;/code&gt; 추적 포트가 시작되면 &lt;code&gt;ttb:tracer/0,1,2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c33df7c3d6f3cf265ee046f5bbcec06d7fee2046" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;unordered set&lt;/strong&gt; containing the elements a, b, and c is denoted {a, b, c}. This notation is not to be confused with tuples.</source>
          <target state="translated">&lt;strong&gt;순서화 세트&lt;/strong&gt; A, B 및 C로 표시되는 요소 {A, B, C를 함유}. 이 표기법은 튜플과 혼동되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="338f2ff3d932d37a0203031cf3c8ecd12e555100" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;xmerl&lt;/strong&gt; XML parser is able to parse XML documents according to the XML 1.0 standard. As default it performs well-formed parsing, (syntax checks and checks of well-formed constraints). Optionally one can also use xmerl as a validating parser, (validate according to referenced DTD and validating constraints). By means of for example the xmerl_xs module it is possible to transform the parsed result to other formats, e.g. text, HTML, XML etc.</source>
          <target state="translated">&lt;strong&gt;xmerl의&lt;/strong&gt; XML 파서는 XML 1.0 표준에 따라 구문 분석 XML 문서를 할 수 있습니다. 기본적으로 올바른 형식의 구문 분석 (구문 검사 및 올바른 형식의 제약 조건 검사)을 수행합니다. 선택적으로 xmerl을 유효성 검사 파서로 사용할 수도 있습니다 (참조 된 DTD 및 유효성 검사 제약 조건에 따라 유효성 검사). 예를 들어 xmerl_xs 모듈을 사용하면 구문 분석 된 결과를 다른 형식 (예 : 텍스트, HTML, XML 등)으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="639ddc138940995a6e19ca0db97584c255b5e3c9" translate="yes" xml:space="preserve">
          <source>The ACC time calculation is sometimes difficult to make correct, since it is difficult to define. This happens especially when a function occurs in several instances in the call stack, for example by calling itself perhaps through other functions and perhaps even non-tail recursively.</source>
          <target state="translated">ACC 시간 계산은 정의하기가 어렵 기 때문에 때때로 정확하기가 어렵습니다. 이것은 특히 호출 스택의 여러 인스턴스에서 함수가 발생할 때 발생합니다 (예 : 다른 함수를 통해 자체적으로 또는 비 꼬리 재귀 적으로 호출).</target>
        </trans-unit>
        <trans-unit id="57e2a8ffba28b7446bf70cbc1663f4839a28353c" translate="yes" xml:space="preserve">
          <source>The AND intersection of the list &lt;code&gt;L1&lt;/code&gt; and &lt;code&gt;L2&lt;/code&gt; is also easily defined:</source>
          <target state="translated">리스트 &lt;code&gt;L1&lt;/code&gt; 과 &lt;code&gt;L2&lt;/code&gt; 의 AND 교차점 도 쉽게 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="03c2705073fe9051dbc22438c110997b433d5384" translate="yes" xml:space="preserve">
          <source>The API for logging consists of a set of &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt;, and a set of functions on the form &lt;code&gt;logger:Level/1,2,3&lt;/code&gt;, which are all shortcuts for &lt;code&gt;&lt;a href=&quot;logger#log-2&quot;&gt; logger:log(Level,Arg1[,Arg2[,Arg3]])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로깅을위한 API는 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt; 세트 와 &lt;code&gt;logger:Level/1,2,3&lt;/code&gt; 형식의 함수 세트로 구성되며 , 모두 &lt;code&gt;&lt;a href=&quot;logger#log-2&quot;&gt; logger:log(Level,Arg1[,Arg2[,Arg3]])&lt;/a&gt;&lt;/code&gt; 바로 가기입니다 . .</target>
        </trans-unit>
        <trans-unit id="79ddb999f667f09a910e3689c6469b160527272a" translate="yes" xml:space="preserve">
          <source>The API for logging consists of a set of &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt;, and a set of functions on the form &lt;code&gt;logger:Level/1,2,3&lt;/code&gt;, which are all shortcuts for &lt;code&gt;&lt;a href=&quot;logger#log-2&quot;&gt;logger:log(Level,Arg1[,Arg2[,Arg3]])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로깅 용 API는 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt; 세트 와 &lt;code&gt;logger:Level/1,2,3&lt;/code&gt; 형식의 함수 세트로 구성되며 ,이 함수 는 모두 &lt;code&gt;&lt;a href=&quot;logger#log-2&quot;&gt;logger:log(Level,Arg1[,Arg2[,Arg3]])&lt;/a&gt;&lt;/code&gt; 바로 가기입니다 . .</target>
        </trans-unit>
        <trans-unit id="38e9019f75b372bc1c195496de6c985d2c8006d1" translate="yes" xml:space="preserve">
          <source>The API functions in &lt;code&gt;uri_string&lt;/code&gt; work on two basic data types &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_string&quot;&gt;uri_string()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_string&quot;&gt;uri_string()&lt;/a&gt;&lt;/code&gt; represents a standard URI, while &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt; is a wider datatype, that can represent URI components using &lt;code&gt;&lt;a href=&quot;unicode_usage#what-unicode-is&quot;&gt;Unicode&lt;/a&gt;&lt;/code&gt; characters. &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt; is a convenient choice for enabling operations such as producing standard compliant URIs out of components that have special or &lt;code&gt;&lt;a href=&quot;unicode_usage#what-unicode-is&quot;&gt;Unicode&lt;/a&gt;&lt;/code&gt; characters. It is easier to explain this by an example.</source>
          <target state="translated">&lt;code&gt;uri_string&lt;/code&gt; 의 API 함수는 uri_string &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_string&quot;&gt;uri_string()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt; 두 가지 기본 데이터 유형 에서 작동합니다 . &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_string&quot;&gt;uri_string()&lt;/a&gt;&lt;/code&gt; 은 표준 URI를 나타내고 &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;unicode_usage#what-unicode-is&quot;&gt;Unicode&lt;/a&gt;&lt;/code&gt; 문자를 사용하여 URI 구성 요소를 나타낼 수있는 더 넓은 데이터 유형 입니다. &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt; 은 특수 문자 또는 &lt;code&gt;&lt;a href=&quot;unicode_usage#what-unicode-is&quot;&gt;Unicode&lt;/a&gt;&lt;/code&gt; 문자 가있는 구성 요소에서 표준 준수 URI를 생성하는 등의 작업을 활성화하는 데 편리한 선택입니다 . 예를 들어 설명하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="9d41ee39dfc3d3300eef2e7cc4120a5fd8d4f83d" translate="yes" xml:space="preserve">
          <source>The API is simple:</source>
          <target state="translated">API는 간단합니다 :</target>
        </trans-unit>
        <trans-unit id="d4aca81b201537abe8dedf009dd68114d62d46d3" translate="yes" xml:space="preserve">
          <source>The API provided by Windows.</source>
          <target state="translated">Windows에서 제공하는 API.</target>
        </trans-unit>
        <trans-unit id="ea6764678e9074dc87171f45bcd4511b8aa2d4d8" translate="yes" xml:space="preserve">
          <source>The ASN.1 application provides the following:</source>
          <target state="translated">ASN.1 애플리케이션은 다음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9c1b6316b531e843db6912095bad2d7449901534" translate="yes" xml:space="preserve">
          <source>The ASN.1 code, the Erlang source code, and the generated &lt;code&gt;.hrl&lt;/code&gt; files for them are provided in the distribution and are placed in the directories &lt;code&gt;mibs&lt;/code&gt;, &lt;code&gt;src&lt;/code&gt;, and &lt;code&gt;include&lt;/code&gt;, respectively, in the &lt;code&gt;snmp&lt;/code&gt; application.</source>
          <target state="translated">의 ASN 코드, 얼랭 소스 코드 및 생성 된 &lt;code&gt;.hrl&lt;/code&gt; 의 그들을 위해 파일 배포에 제공되며, 디렉토리에 배치 &lt;code&gt;mibs&lt;/code&gt; , &lt;code&gt;src&lt;/code&gt; , 그리고 &lt;code&gt;include&lt;/code&gt; 에 각각 &lt;code&gt;snmp&lt;/code&gt; 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="c4c076a03aaf6d1e948523fb216ccde0cc05b7f7" translate="yes" xml:space="preserve">
          <source>The ASN.1 compiler can be started directly from the command line by the &lt;code&gt;erlc&lt;/code&gt; program. This is convenient when compiling many ASN.1 files from the command line or when using Makefiles. Some examples of how the &lt;code&gt;erlc&lt;/code&gt; command can be used to start the ASN.1 compiler:</source>
          <target state="translated">ASN.1 컴파일러는 &lt;code&gt;erlc&lt;/code&gt; 프로그램에 의해 명령 행에서 직접 시작할 수 있습니다 . 명령 줄에서 많은 ASN.1 파일을 컴파일하거나 Makefile을 사용할 때 편리합니다. &lt;code&gt;erlc&lt;/code&gt; 명령을 사용하여 ASN.1 컴파일러를 시작하는 방법에 대한 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="fb22058cd698b91ccb24c3e367daf392b4a590e1" translate="yes" xml:space="preserve">
          <source>The ASN.1 compiler takes an ASN.1 module as input and generates a corresponding Erlang module, which can encode and decode the specified data types. Alternatively, the compiler takes a specification module specifying all input modules, and generates a module with encode/decode functions. In addition, some generic functions can be used during development of applications that handles ASN.1 data (encoded as &lt;code&gt;BER&lt;/code&gt; or &lt;code&gt;PER&lt;/code&gt;).</source>
          <target state="translated">ASN.1 컴파일러는 ASN.1 모듈을 입력으로 받아서 해당 Erlang 모듈을 생성하여 지정된 데이터 유형을 인코딩하고 디코딩 할 수 있습니다. 또는 컴파일러는 모든 입력 모듈을 지정하는 사양 모듈을 가져 와서 인코딩 / 디코딩 기능이있는 모듈을 생성합니다. 또한 ASN.1 데이터를 처리하는 애플리케이션을 개발하는 동안 일부 일반 기능을 사용할 수 있습니다 ( &lt;code&gt;BER&lt;/code&gt; 또는 &lt;code&gt;PER&lt;/code&gt; 로 인코딩 됨 ).</target>
        </trans-unit>
        <trans-unit id="c60d4a11ddc52b500d299eda7e6852a95f2bae35" translate="yes" xml:space="preserve">
          <source>The ASN.1 specifications in the test were compiled with options &lt;code&gt;ber_bin, optimize, driver&lt;/code&gt; and &lt;code&gt;asn1config&lt;/code&gt;. Omitting option &lt;code&gt;driver&lt;/code&gt; gives higher values for &lt;code&gt;decode&lt;/code&gt; and &lt;code&gt;decode_part&lt;/code&gt;. These tests have not been rerun using NIFs, but are expected to perform about 5% better than the linked-in driver.</source>
          <target state="translated">테스트의 ASN.1 스펙은 &lt;code&gt;ber_bin, optimize, driver&lt;/code&gt; 및 &lt;code&gt;asn1config&lt;/code&gt; 옵션으로 컴파일 되었습니다 . 옵션 &lt;code&gt;driver&lt;/code&gt; 를 생략 하면 &lt;code&gt;decode&lt;/code&gt; 및 &lt;code&gt;decode_part&lt;/code&gt; 에 더 높은 값이 제공 됩니다. 이 테스트는 NIF를 사용하여 다시 실행되지 않았지만 링크 된 드라이버보다 약 5 % 더 나은 성능을 기대합니다.</target>
        </trans-unit>
        <trans-unit id="2f22980605315f568d967ab23f6f0f04c10f0db4" translate="yes" xml:space="preserve">
          <source>The ASN.1 to Erlang compiler does not determine the correct interpretation of each BER string octet value with different character strings. The application is responsible for interpretation of octets. Therefore, from the BER string point of view, octets are very similar to character strings and are compiled in the same way.</source>
          <target state="translated">ASN.1 대 Erlang 컴파일러는 서로 다른 문자열로 각 BER 문자열 옥텟 값의 올바른 해석을 결정하지 않습니다. 응용 프로그램은 옥텟의 해석을 담당합니다. 따라서 BER 문자열 관점에서 옥텟은 문자열과 매우 유사하며 동일한 방식으로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="e882c6bd57a43305a3640939f477df3d4ead459d" translate="yes" xml:space="preserve">
          <source>The ASN.1 type can be 'Certificate', 'OTPCertificate' or a subtype of either.</source>
          <target state="translated">ASN.1 유형은 'Certificate', 'OTPCertificate'또는 하위 유형 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7a7f7547a93bea8b589e07f519f153c18f157b7" translate="yes" xml:space="preserve">
          <source>The AVPs of the message. Ignored for an outgoing message if the &lt;code&gt;msg&lt;/code&gt; field is set to a value other than &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">메시지의 AVP &lt;code&gt;msg&lt;/code&gt; 필드가 &lt;code&gt;undefined&lt;/code&gt; 이외의 값으로 설정된 경우 발신 메시지에 대해 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="bbe283419a75e9a012fbd1970d31d2b4f451187c" translate="yes" xml:space="preserve">
          <source>The Adler checksum of the dictionary is returned.</source>
          <target state="translated">사전의 Adler 체크섬이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="396f5f5683edcca9c1f25e63c5cdd3210d9fa913" translate="yes" xml:space="preserve">
          <source>The Anti-Replay protection feature in stateless servers executes in the following steps when a new ClientHello is received:</source>
          <target state="translated">상태 비 저장 서버의 재생 방지 보호 기능은 새 ClientHello가 수신 될 때 다음 단계에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c87eb8ebe47038b4ccdd22aaa97c4f88f2c5c087" translate="yes" xml:space="preserve">
          <source>The Application Id is set in the Diameter Header of outgoing messages of the application, and the value in the header of an incoming message is used to identify the relevant dictionary module.</source>
          <target state="translated">애플리케이션 ID는 애플리케이션의 발신 메시지 직경 헤더에 설정되며 수신 메시지 헤더의 값은 관련 사전 모듈을 식별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f5de0091f6607fa5ed052b8880c8cef363f44808" translate="yes" xml:space="preserve">
          <source>The Audit Trail Log is managed by the network interface process. So, it is this process that has to do the actual changing of the type.</source>
          <target state="translated">감사 추적 로그는 네트워크 인터페이스 프로세스에 의해 관리됩니다. 따라서이 프로세스는 실제로 유형을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="4ffaae1f3e0b8fd90d36e73237642154e3434485" translate="yes" xml:space="preserve">
          <source>The Audit Trail Log is managed by the network interface process. So, it is this process that has to retrieve the actual log-type.</source>
          <target state="translated">감사 추적 로그는 네트워크 인터페이스 프로세스에 의해 관리됩니다. 따라서이 프로세스는 실제 로그 유형을 검색해야합니다.</target>
        </trans-unit>
        <trans-unit id="56bc2b11b64e2a80365e104579b5470c818d8f1f" translate="yes" xml:space="preserve">
          <source>The Audit Trail Log is managed by the network interface process. So, it is this process that has to return the actual log-type.</source>
          <target state="translated">감사 추적 로그는 네트워크 인터페이스 프로세스에 의해 관리됩니다. 따라서이 프로세스는 실제 로그 유형을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="5f534cf4748ee979b48f1dda16d8700a38a8db83" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;erlang:is_process_alive/1&lt;/code&gt; is the closest you can get to a process table lookup only. The BIF looks up the process corresponding to the process identifier passed as argument, and then checks if it is alive. By running multiple processes looping over this BIF checking the same process, we get a speedup between 20000-23000%. Conceptually this operation only involve read operations. In the implementation used in R16B also only read operation are performed, while the previous implementation need to lock structures in order to read the data, suffering from both lock contention and contention due to modifications of cache lines used by lock internal data structures and the reference counter on the process being looked up.</source>
          <target state="translated">BIF &lt;code&gt;erlang:is_process_alive/1&lt;/code&gt; 은 프로세스 테이블 조회에만 접근 할 수있는 가장 가까운 것입니다. BIF는 인수로 전달 된 프로세스 식별자에 해당하는 프로세스를 조회 한 다음 활성 상태인지 확인합니다. 동일한 프로세스를 검사하는이 BIF를 반복하는 여러 프로세스를 실행하면 20000-23000 % 사이의 속도가 향상됩니다. 개념적으로이 작업에는 읽기 작업 만 포함됩니다. R16B에서 사용되는 구현에서는 읽기 작업 만 수행되는 반면, 이전 구현에서는 잠금 내부 데이터 구조 및 참조에서 사용하는 캐시 라인의 수정으로 인해 잠금 경합 및 경합이 발생하는 데이터를 읽기 위해 구조를 잠글 필요가 있습니다. 조회중인 프로세스에 대한 카운터.</target>
        </trans-unit>
        <trans-unit id="fb9967052a764c3afae20ad96d6a28a3fa28a91f" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; can also add match specifications to a function. A match specification comprises a pattern that the function arguments must match, a guard expression that must evaluate to &lt;code&gt;true&lt;/code&gt;, and an action to be performed. The default action is to send a trace message. If the pattern does not match or the guard fails, the action is not executed.</source>
          <target state="translated">BIF &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; 은 함수에 일치 스펙을 추가 할 수도 있습니다. 일치 스펙은 함수 인수가 일치해야하는 패턴, &lt;code&gt;true&lt;/code&gt; 로 평가되어야하는 가드 표현식 및 수행 할 조치로 구성됩니다. 기본 조치는 추적 메시지를 보내는 것입니다. 패턴이 일치하지 않거나 가드가 실패하면 조치가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e87dd32697c643963810be073120b237d9b1c65" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;open_port/2&lt;/code&gt; is documented in the &lt;code&gt;erlang&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">BIF &lt;code&gt;open_port/2&lt;/code&gt; 는 ERTS 의 &lt;code&gt;erlang&lt;/code&gt; 매뉴얼 페이지에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="102d447ee7d66bcdc64a15b95caa727b7d5ec384" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;statistics(run_queue)&lt;/code&gt; is used for estimating future loads. It returns the length of the queue of ready to run processes in the Erlang runtime system.</source>
          <target state="translated">BIF &lt;code&gt;statistics(run_queue)&lt;/code&gt; 는 향후로드를 추정하는 데 사용됩니다. Erlang 런타임 시스템에서 프로세스를 실행할 준비가 된 대기열의 길이를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a6a407c55efe87e4b70f70a1f8c95515dc9b4791" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;throw(Any)&lt;/code&gt; can be used for non-local return from a function. It must be evaluated within a &lt;code&gt;catch&lt;/code&gt;, which returns the value &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">BIF &lt;code&gt;throw(Any)&lt;/code&gt; 는 함수에서 로컬이 아닌 리턴으로 사용될 수 있습니다. &lt;code&gt;catch&lt;/code&gt; 내에서 평가되어야하며 이는 &lt;code&gt;Any&lt;/code&gt; 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="30ca995f69db34040dadf8f4fb8f2daa8f294d98" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;whereis(RegisteredName)&lt;/code&gt; checks if a registered process of name &lt;code&gt;RegisteredName&lt;/code&gt; exists. If it exists, the pid of that process is returned. If it does not exist, the atom &lt;code&gt;undefined&lt;/code&gt; is returned.</source>
          <target state="translated">BIF &lt;code&gt;whereis(RegisteredName)&lt;/code&gt; 은 &lt;code&gt;RegisteredName&lt;/code&gt; 이라는 이름의 등록 된 프로세스가 존재 하는지 확인 합니다. 존재하는 경우 해당 프로세스의 pid가 리턴됩니다. 존재하지 않는 경우, 원자 &lt;code&gt;undefined&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="6cbf1adc0d75868cfd46589662e75f0f79ed5cbb" translate="yes" xml:space="preserve">
          <source>The Bindings area, displaying all variables bindings. If you click a variable name, the value is displayed in the Evaluator area. Double-click a variable name to open a window where the variable value can be edited. Notice however that pid, port, reference, or fun values cannot be edited unless they can be represented in the running system.</source>
          <target state="translated">모든 변수 바인딩을 표시하는 바인딩 영역. 변수 이름을 클릭하면 값이 평가자 영역에 표시됩니다. 변수 이름을 두 번 클릭하여 변수 값을 편집 할 수있는 창을 엽니 다. 그러나 pid, port, reference 또는 fun 값은 실행중인 시스템에 표시 될 수 없으면 편집 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b6c3c38656309049129434a8a3888567bd5d33d" translate="yes" xml:space="preserve">
          <source>The Button area, with buttons for quick access to frequently used functions in the &lt;strong&gt;Process&lt;/strong&gt; menu.</source>
          <target state="translated">&lt;strong&gt;프로세스&lt;/strong&gt; 메뉴 에서 자주 사용하는 기능에 빠르게 액세스 할 수있는 버튼이있는 버튼 영역 .</target>
        </trans-unit>
        <trans-unit id="ada22f32dd020105bdc39ab625188b5d539d360a" translate="yes" xml:space="preserve">
          <source>The C driver is a module that is compiled and linked into a shared library. It uses a driver structure and includes the header file &lt;code&gt;erl_driver.h&lt;/code&gt;.</source>
          <target state="translated">C 드라이버는 컴파일되어 공유 라이브러리에 연결된 모듈입니다. 드라이버 구조를 사용하며 헤더 파일 &lt;code&gt;erl_driver.h&lt;/code&gt; 를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="2a7c12f419c3e677f26c1d74131f78103f5ccbf9" translate="yes" xml:space="preserve">
          <source>The C node can act as a server or a client when setting up the Erlang-C communication. If it acts as a client, it connects to an Erlang node by calling &lt;code&gt;erl_connect()&lt;/code&gt;, which returns an open file descriptor at success:</source>
          <target state="translated">C 노드는 Erlang-C 통신을 설정할 때 서버 또는 클라이언트 역할을 할 수 있습니다. 클라이언트 역할을하는 경우 &lt;code&gt;erl_connect()&lt;/code&gt; 를 호출하여 Erlang 노드에 연결합니다. 그러면 성공시 열린 파일 디스크립터가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f778bcd020988cc52d7d8911bac363507b5bc1fe" translate="yes" xml:space="preserve">
          <source>The C node can receive a message from Erlang by calling &lt;code&gt;erl_receive msg()&lt;/code&gt;. This function reads data from the open file descriptor &lt;code&gt;fd&lt;/code&gt; into a buffer and puts the result in an &lt;code&gt;ErlMessage&lt;/code&gt; struct &lt;code&gt;emsg&lt;/code&gt;. &lt;code&gt;ErlMessage&lt;/code&gt; has a field &lt;code&gt;type&lt;/code&gt; defining what kind of data is received. In this case, the type of interest is &lt;code&gt;ERL_REG_SEND&lt;/code&gt; which indicates that Erlang sent a message to a registered process at the C node. The actual message, an &lt;code&gt;ETERM&lt;/code&gt;, is in the &lt;code&gt;msg&lt;/code&gt; field.</source>
          <target state="translated">C 노드는 &lt;code&gt;erl_receive msg()&lt;/code&gt; 호출하여 Erlang으로부터 메시지를 수신 할 수 있습니다 . 이 함수는 열린 파일 디스크립터 &lt;code&gt;fd&lt;/code&gt; 에서 데이터를 버퍼로 읽어 결과를 &lt;code&gt;ErlMessage&lt;/code&gt; 구조체 &lt;code&gt;emsg&lt;/code&gt; 에 넣습니다 . &lt;code&gt;ErlMessage&lt;/code&gt; 에는 수신되는 데이터 종류를 정의 하는 필드 &lt;code&gt;type&lt;/code&gt; 이 있습니다. 이 경우 관심 유형은 &lt;code&gt;ERL_REG_SEND&lt;/code&gt; 이며 Erlang은 C 노드에서 등록 된 프로세스로 Erlang이 메시지를 보냈 음 을 나타냅니다. 실제 메시지 &lt;code&gt;ETERM&lt;/code&gt; 은 &lt;code&gt;msg&lt;/code&gt; 필드에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec592580544dfa8a13cf79ebfaf21d822174fe76" translate="yes" xml:space="preserve">
          <source>The C-node identified by &lt;code&gt;ec&lt;/code&gt; must have been initialized and must have received a name prior to the call to &lt;code&gt;ei_make_pid()&lt;/code&gt;. Initialization of the C-node is done by a call to &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init()&lt;/a&gt;&lt;/code&gt; or friends. If the name is dynamically assigned from the peer node, the C-node also has to be connected.</source>
          <target state="translated">&lt;code&gt;ec&lt;/code&gt; 로 식별되는 C 노드는 초기화되어 있어야하며 &lt;code&gt;ei_make_pid()&lt;/code&gt; 호출하기 전에 이름을 받아야 합니다. C 노드의 초기화는 &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init()&lt;/a&gt;&lt;/code&gt; 또는 친구를 호출하여 수행됩니다 . 피어 노드에서 이름이 동적으로 할당되면 C 노드도 연결되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e13c2586709436dfbebc6149ffb9c1b130da4a2e" translate="yes" xml:space="preserve">
          <source>The C-node identified by &lt;code&gt;ec&lt;/code&gt; must have been initialized and must have received a name prior to the call to &lt;code&gt;ei_make_ref()&lt;/code&gt;. Initialization of the C-node is done by a call to &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init()&lt;/a&gt;&lt;/code&gt; or friends. If the name is dynamically assigned from the peer node, the C-node also has to be connected.</source>
          <target state="translated">&lt;code&gt;ec&lt;/code&gt; 로 식별되는 C 노드는 초기화되어 있어야하며 &lt;code&gt;ei_make_ref()&lt;/code&gt; 호출하기 전에 이름을 받아야 합니다. C 노드의 초기화는 &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init()&lt;/a&gt;&lt;/code&gt; 또는 친구를 호출하여 수행됩니다 . 피어 노드에서 이름이 동적으로 할당되면 C 노드도 연결되어야합니다.</target>
        </trans-unit>
        <trans-unit id="39af024e46f5af7c40347c42343f756bdbbc0a29" translate="yes" xml:space="preserve">
          <source>The C-node identified by &lt;code&gt;ec&lt;/code&gt; must have been initialized and must have received a name prior to the call to &lt;code&gt;ei_self()&lt;/code&gt;. Initialization of the C-node is done by a call to &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init()&lt;/a&gt;&lt;/code&gt; or friends. If the name is dynamically assigned from the peer node, the C-node also has to be connected.</source>
          <target state="translated">&lt;code&gt;ec&lt;/code&gt; 로 식별되는 C 노드는 초기화되어 있어야하며 &lt;code&gt;ei_self()&lt;/code&gt; 호출하기 전에 이름을 받아야 합니다. C 노드의 초기화는 &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init()&lt;/a&gt;&lt;/code&gt; 또는 친구를 호출하여 수행됩니다 . 피어 노드에서 이름이 동적으로 할당되면 C 노드도 연결되어야합니다.</target>
        </trans-unit>
        <trans-unit id="44cfee0b8169b38821cf004612b6024fa4504a22" translate="yes" xml:space="preserve">
          <source>The CA certificates specified for the connection will be used to construct the certificate chain validating the CRLs.</source>
          <target state="translated">연결에 지정된 CA 인증서는 CRL을 확인하는 인증서 체인을 구성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9b711437028a29fd162a39304f7e85e3b67e2c19" translate="yes" xml:space="preserve">
          <source>The CGI script response comprises a message header and a message body, separated by a blank line. The message header contains one or more header fields. The body can be empty.</source>
          <target state="translated">CGI 스크립트 응답은 공백으로 구분 된 메시지 헤더와 메시지 본문으로 구성됩니다. 메시지 헤더에는 하나 이상의 헤더 필드가 있습니다. 몸이 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c3c9d660d39101e158d800c72dc5b3c5f71e86f" translate="yes" xml:space="preserve">
          <source>The CNT column shows the total number of function calls that was found in the trace. In the ACC column is the total time of the trace from first timestamp to last. And in the OWN column is the sum of the execution time in functions found in the trace, not including called functions. In this case it is very close to the ACC time since the emulator had practically nothing else to do than to execute our test program.</source>
          <target state="translated">CNT 열에는 추적에서 찾은 총 함수 호출 수가 표시됩니다. ACC 열에서 첫 번째 타임 스탬프에서 마지막까지의 총 추적 시간입니다. 그리고 OWN 열에는 호출 된 함수를 포함하지 않고 추적에서 찾은 함수의 실행 시간 합계가 표시됩니다. 이 경우 에뮬레이터가 테스트 프로그램을 실행하는 것 외에는 할 일이 거의 없기 때문에 ACC 시간에 매우 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="0bca2724268527bcfe47363d53f453d381e52758" translate="yes" xml:space="preserve">
          <source>The CPU topology is used when binding schedulers to logical processors. If schedulers are already bound when the CPU topology is changed, the schedulers are sent a request to rebind according to the new CPU topology.</source>
          <target state="translated">CPU 토폴로지는 스케줄러를 논리 프로세서에 바인딩 할 때 사용됩니다. CPU 토폴로지가 변경 될 때 스케줄러가 이미 바인드 된 경우, 스케줄러는 새 CPU 토폴로지에 따라 리 바인드 요청을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="3e338f2c345acced3a85f3002b3cdda7b33768c1" translate="yes" xml:space="preserve">
          <source>The CPU utilization is defined as the sum of the percentage shares of the CPU cycles spent in all busy processor states (see &lt;code&gt;util/1&lt;/code&gt; below) in average on all CPUs.</source>
          <target state="translated">CPU 사용률은 모든 CPU에서 평균적으로 모든 사용 중인 프로세서 상태 (아래 &lt;code&gt;util/1&lt;/code&gt; 참조)에서 소비 된 CPU주기의 백분율 공유의 합계로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="aa86529ffc420dbda732a44a0aa8bd483c1ae653" translate="yes" xml:space="preserve">
          <source>The CRL entry extensions OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">CRL 항목 확장자 OID 이름 원자 및 해당 값 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="270f1611da531780d2eaa5897949ee887332e027" translate="yes" xml:space="preserve">
          <source>The CRL extensions OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">CRL 확장 OID 이름 원자 및 해당 값 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d9b7329cef621756a648262a641008c28933737d" translate="yes" xml:space="preserve">
          <source>The CRLs will be fetched from a local or external cache. See &lt;code&gt;ssl_crl_cache_api(3)&lt;/code&gt;.</source>
          <target state="translated">CRL은 로컬 또는 외부 캐시에서 가져옵니다. &lt;code&gt;ssl_crl_cache_api(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc03e6a9344836dc83866fc80ae58c6381b38386" translate="yes" xml:space="preserve">
          <source>The CRYPTO app has evolved during its lifetime. Since also the OpenSSL cryptolib has changed the API several times, there are parts of the CRYPTO app that uses a very old one internally and other parts that uses the latest one. The internal definitions of e.g cipher names was a bit hard to maintain.</source>
          <target state="translated">CRYPTO 앱은 평생 동안 진화했습니다. OpenSSL cryptolib도 API를 여러 번 변경했기 때문에 내부적으로 아주 오래된 것을 사용하는 CRYPTO 앱과 최신 것을 사용하는 다른 부분이 있습니다. 예를 들어 암호 이름의 내부 정의는 유지하기가 약간 어려웠습니다.</target>
        </trans-unit>
        <trans-unit id="f3d829d39e1e62045ec8647a09fccc7a51c77978" translate="yes" xml:space="preserve">
          <source>The CT hook functions can call any logging function in the &lt;code&gt;ct&lt;/code&gt; interface to print information to the log files, or to add comments in the suite overview page.</source>
          <target state="translated">CT 후크 기능은 &lt;code&gt;ct&lt;/code&gt; 인터페이스 에서 로깅 기능을 호출 하여 정보를 로그 파일에 인쇄하거나 제품군 개요 페이지에 주석을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ec67be87ba83be4a6a36f46cae0a249d6c031c6" translate="yes" xml:space="preserve">
          <source>The Call Graph is  represented by Erlang terms (the sets are lists), which is suitable for many analyses. But for analyses that look at chains of calls, a list representation is much too slow. Instead the representation offered by the &lt;code id=&quot;representation&quot;&gt;digraph&lt;/code&gt; module is used. The translation of the list representation of the Call Graph - or a subgraph thereof - to the &lt;code&gt;digraph&lt;/code&gt; representation does not come for free, so the language used for expressing queries to be described below has a special operator for this task and a possibility to save the &lt;code&gt;digraph&lt;/code&gt; representation for subsequent analyses.</source>
          <target state="translated">콜 그래프는 많은 분석에 적합한 Erlang 용어 (세트가 목록 임)로 표시됩니다. 그러나 호출 체인을 분석하는 분석의 경우 목록 표현이 너무 느립니다. 대신 &lt;code id=&quot;representation&quot;&gt;digraph&lt;/code&gt; 모듈에서 제공하는 표현 이 사용됩니다. 또는 그 서브 그래프 - - 통화 그래프의 목록 표현의 번역을받는 &lt;code&gt;digraph&lt;/code&gt; 쿼리를 표현에 사용되는 언어는 아래에 설명이 작업을위한 특별한 연산자와 저장 할 수있는 가능성이 될 수 있도록 표현은, 무료로 제공되지 않습니다 후속 분석을위한 &lt;code&gt;digraph&lt;/code&gt; 표현.</target>
        </trans-unit>
        <trans-unit id="bce56cac593ab0a42cef53b33869a05dc52b528e" translate="yes" xml:space="preserve">
          <source>The Code area, displaying the code being executed. The code is indented and each line is prefixed with its line number. If the process execution is stopped, the current line is marked with &lt;code&gt;--&amp;gt;&lt;/code&gt;. An existing break point at a line is marked with a stop symbol. In the example shown in the illustration, the execution stopped at line 6, before the execution of &lt;code&gt;fac/1&lt;/code&gt;.</source>
          <target state="translated">실행중인 코드를 표시하는 코드 영역 코드가 들여 쓰기되고 각 줄 앞에 줄 번호가 붙습니다. 프로세스 실행이 중지되면 현재 행은 &lt;code&gt;--&amp;gt;&lt;/code&gt; 로 표시됩니다 . 줄의 기존 중단 점에는 정지 기호가 표시됩니다. 그림에 표시된 예에서 &lt;code&gt;fac/1&lt;/code&gt; 실행 전에 6 행에서 실행이 중지되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3c4163ad4ae86ebef487e34acf3cb3b300872a11" translate="yes" xml:space="preserve">
          <source>The Common Message and Relay applications are the only applications that diameter itself has any specific knowledge of. The Common Message application is used for messages that diameter itself handles: CER/CEA, DWR/DWA and DPR/DPA. The Relay application is given special treatment with regard to encode/decode since the messages and AVPs it handles are not specifically defined.</source>
          <target state="translated">Common Message and Relay 응용 프로그램은 그 자체로 특정 지식을 가진 유일한 응용 프로그램입니다. 공통 메시지 응용 프로그램은 CER / CEA, DWR / DWA 및 DPR / DPA와 같이 자체적으로 처리되는 메시지에 사용됩니다. 메시지와 처리하는 AVP가 구체적으로 정의되어 있지 않기 때문에 릴레이 응용 프로그램에는 인코딩 / 디코딩과 관련하여 특별한 처리가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="314dbe1e2d1cb12d891485b91d81bb94162ddaf9" translate="yes" xml:space="preserve">
          <source>The Compliance column notes &lt;strong&gt;C&lt;/strong&gt; (Compliant) if the required functionality is implemented, &lt;strong&gt;PC&lt;/strong&gt; (Partially Compliant) if there are limitations, &lt;strong&gt;NC&lt;/strong&gt; (Not Compliant) if functionality is not implemented, or a dash if text is informational or only places requirements that must be met by the user's implementation.</source>
          <target state="translated">필수 기능이 구현 된 경우 규정 준수 열에 &lt;strong&gt;C&lt;/strong&gt; (규정 준수), 제한이있는 경우 &lt;strong&gt;PC&lt;/strong&gt; (부분적 준수), 기능이 구현되지 않은 경우 &lt;strong&gt;NC&lt;/strong&gt; (비준수) 또는 텍스트가 정보를 제공하거나 요구 사항 만 충족해야하는 경우 대시 사용자의 구현에 의해 충족됩니다.</target>
        </trans-unit>
        <trans-unit id="cb5797134c742f2284426627bbcaee9db9ff4f9b" translate="yes" xml:space="preserve">
          <source>The ControlPid may be the identity of a process residing on another Erlang node. This is useful when you want to distribute a user over several Erlang nodes. In such a case one of the nodes has the physical connection. When a user residing on one of the other nodes needs to send a request (with megaco:call/3 or megaco:cast/3), the message will encoded on the originating Erlang node, and then be forwarded to the node with the physical connection. When the reply arrives, it will be forwarded back to the originator. The distributed connection may explicitly be deactivated by a local call to megaco:disconnect/2 or implicitly when the physical connection is deactivated (with megaco:disconnect/2, killing the controlling process, halting the other node, ...).</source>
          <target state="translated">ControlPid는 다른 Erlang 노드에 상주하는 프로세스의 ID 일 수 있습니다. 이것은 여러 Erlang 노드에 사용자를 분배하려는 경우에 유용합니다. 이러한 경우 노드 중 하나가 물리적으로 연결되어 있습니다. 다른 노드 중 하나에 상주하는 사용자가 megaco : call / 3 또는 megaco : cast / 3로 요청을 보내야하는 경우, 메시지는 발신 Erlang 노드에서 인코딩 된 후 물리적 노드로 전달됩니다. 연결. 회신이 도착하면 발신자에게 다시 전달됩니다. 분산 연결은 megaco : disconnect / 2에 대한 로컬 호출에 의해 명시 적으로 비활성화되거나 물리적 연결이 비활성화 될 때 내재적으로 (megaco : disconnect / 2를 사용하여 제어 프로세스를 종료하고 다른 노드를 중지시키는 등) 내재적으로 비활성화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78df27997f59e3cf7a226f97555796fd4db3b167" translate="yes" xml:space="preserve">
          <source>The Crashdump Viewer is a WxWidgets based tool for browsing Erlang crashdumps.</source>
          <target state="translated">Crashdump Viewer는 Erlang 크래시 덤프를 찾아보기위한 WxWidgets 기반 도구입니다.</target>
        </trans-unit>
        <trans-unit id="e25b4f2128c61d45f1244bb1e42a65e6c254444f" translate="yes" xml:space="preserve">
          <source>The Cs (Surrogate) property applies only to characters in the range U+D800 to U+DFFF. Such characters are invalid in Unicode strings and so cannot be tested by PCRE. Perl does not support the Cs property.</source>
          <target state="translated">Cs (Surrogate) 속성은 U + D800에서 U + DFFF 범위의 문자에만 적용됩니다. 이러한 문자는 유니 코드 문자열에서 유효하지 않으므로 PCRE에서 테스트 할 수 없습니다. Perl은 Cs 속성을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d8b1e5940b411ae8301615a457804bfb0094984" translate="yes" xml:space="preserve">
          <source>The DER encoder omits the encoding for the same &lt;code&gt;BIT STRING&lt;/code&gt;:</source>
          <target state="translated">DER 인코더는 동일한 &lt;code&gt;BIT STRING&lt;/code&gt; 에 대한 인코딩을 생략합니다 .</target>
        </trans-unit>
        <trans-unit id="9e781b3302f49ad7b6f93f77b8bb63523e6ee75c" translate="yes" xml:space="preserve">
          <source>The DER-encoded Diffie-Hellman parameters. If specified, it overrides option &lt;code&gt;dhfile&lt;/code&gt;.</source>
          <target state="translated">DER로 인코딩 된 Diffie-Hellman 매개 변수. 지정된 경우 &lt;code&gt;dhfile&lt;/code&gt; 옵션을 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="b9e05b3ca4b742f1e879494bc5c683f33ec025ce" translate="yes" xml:space="preserve">
          <source>The DER-encoded trusted certificates. If this option is supplied it overrides option &lt;code&gt;cacertfile&lt;/code&gt;.</source>
          <target state="translated">DER로 인코딩 된 신뢰할 수있는 인증서입니다. 이 옵션이 제공되면 &lt;code&gt;cacertfile&lt;/code&gt; 옵션보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="1ba530c04cbce9e372b32aee5f085b4acb4f0137" translate="yes" xml:space="preserve">
          <source>The DER-encoded user's private key or a map refering to a crypto engine and its key reference that optionally can be password protected, seealso &lt;code&gt; crypto:engine_load/4 &lt;/code&gt; and &lt;code&gt; Crypto's Users Guide&lt;/code&gt;. If this option is supplied, it overrides option &lt;code&gt;keyfile&lt;/code&gt;.</source>
          <target state="translated">DER로 인코딩 된 사용자의 개인 키 또는 암호 엔진 및 선택적으로 암호로 보호 될 수있는 해당 키 참조를 참조하는 맵, &lt;code&gt; crypto:engine_load/4 &lt;/code&gt; 및 &lt;code&gt; Crypto's Users Guide&lt;/code&gt; . 이 옵션이 제공되면 &lt;code&gt;keyfile&lt;/code&gt; 옵션을 대체 합니다 .</target>
        </trans-unit>
        <trans-unit id="503452c36c49cb1fd0ea949662ea239d8f9105d2" translate="yes" xml:space="preserve">
          <source>The DER-encoded user's private key or a map refering to a crypto engine and its key reference that optionally can be password protected, seealso &lt;code&gt;crypto:engine_load/4&lt;/code&gt; and &lt;code&gt;Crypto's Users Guide&lt;/code&gt;. If this option is supplied, it overrides option &lt;code&gt;keyfile&lt;/code&gt;.</source>
          <target state="translated">DER로 인코딩 된 사용자의 개인 키 또는 암호 엔진 및 선택적으로 암호로 보호 할 수있는 키 참조를 나타내는 맵은 &lt;code&gt;crypto:engine_load/4&lt;/code&gt; 및 &lt;code&gt;Crypto's Users Guide&lt;/code&gt; . 이 옵션이 제공되면 &lt;code&gt;keyfile&lt;/code&gt; 옵션을 대체 합니다 .</target>
        </trans-unit>
        <trans-unit id="1412b8d79c31037e94ec8ee160cfa882f7bfb3fb" translate="yes" xml:space="preserve">
          <source>The DER-encoded users certificate. If this option is supplied, it overrides option &lt;code&gt;certfile&lt;/code&gt;.</source>
          <target state="translated">DER로 인코딩 된 사용자 인증서. 이 옵션이 제공되면 &lt;code&gt;certfile&lt;/code&gt; 옵션을 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="62d494bd359efefc011e29e6ca8af7b8607707f9" translate="yes" xml:space="preserve">
          <source>The DER-encoded users certificate. Note that the cert option may also be a list of DER-encoded certificates where the first one is the users certificate and the rest of the certificates constitutes the certificate chain. For maximum interoperability the certificates in the chain should be in the correct order, the chain will be sent as is to the peer. If chain certificates are not provided, certificates from &lt;code&gt;&lt;a href=&quot;#type-client_cacerts&quot;&gt;client_cacerts()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-server_cacerts&quot;&gt;server_cacerts()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#type-client_cafile&quot;&gt;client_cafile()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-server_cafile&quot;&gt;server_cafile()&lt;/a&gt;&lt;/code&gt; are used to construct the chain. If this option is supplied, it overrides option &lt;code&gt;certfile&lt;/code&gt;.</source>
          <target state="translated">DER로 인코딩 된 사용자 인증서입니다. cert 옵션은 첫 번째 인증서가 사용자 인증서이고 나머지 인증서가 인증서 체인을 구성하는 DER 인코딩 인증서 목록 일 수도 있습니다. 최대의 상호 운용성을 위해 체인의 인증서는 올바른 순서로 있어야하며 체인은있는 그대로 피어에 전송됩니다. 체인 인증서가 제공되지 않으면 &lt;code&gt;&lt;a href=&quot;#type-client_cacerts&quot;&gt;client_cacerts()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#type-server_cacerts&quot;&gt;server_cacerts()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#type-client_cafile&quot;&gt;client_cafile()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#type-server_cafile&quot;&gt;server_cafile()&lt;/a&gt;&lt;/code&gt; 인증서가 체인 을 구성하는 데 사용됩니다. 이 옵션이 제공되면 &lt;code&gt;certfile&lt;/code&gt; 옵션을 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="b00e40d2bc93d885d8856a1b65b6e1164cd7cb96" translate="yes" xml:space="preserve">
          <source>The Data Structures of the Distribution Driver</source>
          <target state="translated">배포 동인의 데이터 구조</target>
        </trans-unit>
        <trans-unit id="25f2f74a7edc47541dafb29c006cde23cd47d9fe" translate="yes" xml:space="preserve">
          <source>The Diameter header of the message. Can be (and typically should be) &lt;code&gt;undefined&lt;/code&gt; for an outgoing message in a non-relay application, in which case diameter provides appropriate values.</source>
          <target state="translated">메시지의 직경 헤더 릴레이가 아닌 응용 프로그램에서 발신 메시지에 대해 &lt;code&gt;undefined&lt;/code&gt; 않을 수 있으며 일반적으로 정의되지 않아야 합니다.이 경우 지름이 적절한 값을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5efc1791e653c1599eb1a85a25bc63fbc5f68900" translate="yes" xml:space="preserve">
          <source>The EPMD closes the socket when it has sent the information.</source>
          <target state="translated">EPMD는 정보를 보낼 때 소켓을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="e75f4961aac2a4105e4523a54d7cf3b30606ca91" translate="yes" xml:space="preserve">
          <source>The ERTS memory allocators manage memory blocks in two types of raw memory chunks. We call these chunks of raw memory &lt;strong&gt;carriers&lt;/strong&gt;. Single-block carriers which only contain one large block, and multi-block carriers which contain multiple blocks. A carrier is typically created using &lt;code&gt;mmap()&lt;/code&gt; on unix systems. However, how a carrier is created is of minor importance. An allocator instance typically manages a mixture of single- and multi-block carriers.</source>
          <target state="translated">ERTS 메모리 할당자는 두 가지 유형의 원시 메모리 청크에서 메모리 블록을 관리합니다. 이러한 덩어리를 원시 메모리 &lt;strong&gt;캐리어라고&lt;/strong&gt; 합니다. 하나의 큰 블록 만 포함하는 단일 블록 캐리어 및 여러 블록을 포함하는 다중 블록 캐리어. 캐리어는 일반적으로 유닉스 시스템에서 &lt;code&gt;mmap()&lt;/code&gt; 을 사용하여 생성 됩니다. 그러나 캐리어 생성 방법은 중요하지 않습니다. 할당 자 인스턴스는 일반적으로 단일 및 다중 블록 캐리어의 혼합을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="657accf9a74a7eb0b025905c51aa524bbb4f52c3" translate="yes" xml:space="preserve">
          <source>The ETS type of the dumped table (that is, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, &lt;code&gt;duplicate_bag&lt;/code&gt;, or &lt;code&gt;ordered_set&lt;/code&gt;). This type is used when loading the table again.</source>
          <target state="translated">덤프 된 테이블의 ETS 유형 (즉, &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; , &lt;code&gt;duplicate_bag&lt;/code&gt; 또는 &lt;code&gt;ordered_set&lt;/code&gt; ). 이 유형은 테이블을 다시로드 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="37bd9159078f20014405583883e1e7838b1f320f" translate="yes" xml:space="preserve">
          <source>The EUnit framework makes it extremely easy to write unit tests in Erlang. There are a few different ways of writing them, though, so we start with the simplest:</source>
          <target state="translated">EUnit 프레임 워크를 사용하면 Erlang에서 단위 테스트를 매우 쉽게 작성할 수 있습니다. 그러나 몇 가지 다른 방법으로 작성할 수 있으므로 가장 간단한 것으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="fa53810c7a30463d78bce3f01ea7ecca8bb2337e" translate="yes" xml:space="preserve">
          <source>The Edward curves &lt;code&gt;x25519&lt;/code&gt; and &lt;code&gt;x448&lt;/code&gt; are supported with OpenSSL 1.1.1 or later if not disabled by configuration.</source>
          <target state="translated">Edward 곡선 &lt;code&gt;x25519&lt;/code&gt; 및 &lt;code&gt;x448&lt;/code&gt; 은 구성에 의해 비활성화되지 않은 경우 OpenSSL 1.1.1 이상에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="25e6615a6259b426a5c1aa433aefd48dfe9f0730" translate="yes" xml:space="preserve">
          <source>The Election Process</source>
          <target state="translated">선거 과정</target>
        </trans-unit>
        <trans-unit id="d7e47fd1c3278cd7de4abd1246ff9d0b6caf0c35" translate="yes" xml:space="preserve">
          <source>The Encoding can be changed for a file &quot;on the fly&quot; by using function &lt;code&gt;io:setopts/2&lt;/code&gt;. So a file can be analyzed in latin1 encoding for, for example, a BOM, positioned beyond the BOM and then be set for the right encoding before further reading. For functions identifying BOMs, see module &lt;code&gt;unicode(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;io:setopts/2&lt;/code&gt; 함수를 사용하여 &quot;즉석에서&quot;파일의 인코딩을 변경할 수 있습니다 . 예를 들어 BOM과 같은 위치에 파일을 라틴 1 인코딩으로 분석 한 다음 BOM을 넘어서서 올바른 인코딩을 위해 파일을 설정할 수 있습니다. BOM을 식별하는 함수는 모듈 &lt;code&gt;unicode(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3ce07ca3d080f90844cafbb92cdb028293480a0" translate="yes" xml:space="preserve">
          <source>The Erlang &lt;strong&gt;error logger&lt;/strong&gt; is an event manager (see &lt;code&gt;OTP Design Principles&lt;/code&gt; and &lt;code&gt;gen_event(3)&lt;/code&gt;), registered as &lt;code&gt;error_logger&lt;/code&gt;.</source>
          <target state="translated">Erlang &lt;strong&gt;오류 로거&lt;/strong&gt; 는 &lt;code&gt;error_logger&lt;/code&gt; 로 등록 된 이벤트 관리자입니다 ( &lt;code&gt;OTP Design Principles&lt;/code&gt; 및 &lt;code&gt;gen_event(3)&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="a6cec8bd2bf7434e290f227203641824a28b2253" translate="yes" xml:space="preserve">
          <source>The Erlang API allows using arbitrary curve parameters, but in FIPS mode only those allowed by the Security Policy shall be used.</source>
          <target state="translated">Erlang API는 임의의 곡선 매개 변수를 사용할 수 있지만 FIPS 모드에서는 보안 정책에서 허용하는 매개 변수 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1e13d1897ff2db6a5ca229af1382794e443a1fe1" translate="yes" xml:space="preserve">
          <source>The Erlang API of the crypto application is identical regardless of building with or without FIPS support. However the nif code internally uses a different OpenSSL API.</source>
          <target state="translated">암호화 응용 프로그램의 Erlang API는 FIPS 지원 여부에 관계없이 동일합니다. 그러나 nif 코드는 내부적으로 다른 OpenSSL API를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="48490447d94b14d0abe2e04b21fbd8bf2b9b8cdb" translate="yes" xml:space="preserve">
          <source>The Erlang BIF &lt;code&gt;spawn&lt;/code&gt; is used to create a new process: &lt;code&gt;spawn(Module, Exported_Function, List of Arguments)&lt;/code&gt;. Consider the following module:</source>
          <target state="translated">Erlang BIF &lt;code&gt;spawn&lt;/code&gt; 은 새로운 프로세스를 생성하는데 사용됩니다 : &lt;code&gt;spawn(Module, Exported_Function, List of Arguments)&lt;/code&gt; . 다음 모듈을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="bc260aee970be8377de4dc3244ea906f03e3f766" translate="yes" xml:space="preserve">
          <source>The Erlang BIFs.</source>
          <target state="translated">얼랭 BIF.</target>
        </trans-unit>
        <trans-unit id="8938c14ae46ae4bc9fd254a9382eb3df9c381a7c" translate="yes" xml:space="preserve">
          <source>The Erlang Distribution protocol is not by itself secure and does not aim to be so. In order to get secure distribution the distributed nodes should be configured to use distribution over tls. See the &lt;code&gt; Using SSL for Erlang Distribution&lt;/code&gt; User's Guide for details on how to setup a secure distributed node.</source>
          <target state="translated">Erlang Distribution 프로토콜은 그 자체로 안전하지 않으며 그렇게하는 것을 목표로하지 않습니다. 안전한 배포를 위해 분산 노드는 TLS를 통한 배포를 사용하도록 구성되어야합니다. 참고 항목 &lt;code&gt; Using SSL for Erlang Distribution&lt;/code&gt; 설정하는 방법에 대한 보안 분산 노드에 대한 자세한 내용은 사용 설명서를.</target>
        </trans-unit>
        <trans-unit id="99fe49d5ed45f059cc301355028f8dfef080429d" translate="yes" xml:space="preserve">
          <source>The Erlang Distribution protocol is not by itself secure and does not aim to be so. In order to get secure distribution the distributed nodes should be configured to use distribution over tls. See the &lt;code&gt;Using SSL for Erlang Distribution&lt;/code&gt; User's Guide for details on how to setup a secure distributed node.</source>
          <target state="translated">Erlang Distribution 프로토콜은 그 자체로는 안전하지 않으며 그렇게 목표로하지 않습니다. 안전한 분배를 위해서는 분배 노드가 tls를 통한 분배를 사용하도록 구성되어야합니다. 참고 항목 &lt;code&gt;Using SSL for Erlang Distribution&lt;/code&gt; 설정하는 방법에 대한 보안 분산 노드에 대한 자세한 내용은 사용 설명서를.</target>
        </trans-unit>
        <trans-unit id="a40f7e40db92a7107a9e3a5cac4b4ab65b30339c" translate="yes" xml:space="preserve">
          <source>The Erlang Emulator</source>
          <target state="translated">얼랭 에뮬레이터</target>
        </trans-unit>
        <trans-unit id="99377f0e14b45ce54e27b19f84ce7e618a01753c" translate="yes" xml:space="preserve">
          <source>The Erlang I/O-system has been designed (or at least used) in a way where you expect any I/O server to handle any string data. That is, however, no longer the case when working with Unicode characters. The Erlang programmer must now know the capabilities of the device where the data ends up. Also, ports in Erlang are byte-oriented, so an arbitrary string of (Unicode) characters cannot be sent to a port without first converting it to an encoding of choice.</source>
          <target state="translated">Erlang I / O 시스템은 모든 I / O 서버가 문자열 데이터를 처리 할 수있는 방식으로 설계되었습니다. 그러나 유니 코드 문자로 작업 할 때는 더 이상 적용되지 않습니다. Erlang 프로그래머는 이제 데이터가있는 장치의 기능을 알아야합니다. 또한 Erlang의 포트는 바이트 지향이므로 임의의 (유니 코드) 문자 문자열을 먼저 선택한 인코딩으로 변환하지 않고 포트로 보낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="81cc438ebd93249f6378dd48a6614f5a8c1d4ea2" translate="yes" xml:space="preserve">
          <source>The Erlang ODBC application consists of both &lt;code&gt;Erlang&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; code. The &lt;code&gt;C&lt;/code&gt; code is delivered as a precompiled executable for windows, solaris and linux (SLES10) in the commercial build. In the open source distribution it is built the same way as all other application using configure and make. You may want to provide the the path to your ODBC libraries using --with-odbc=PATH.</source>
          <target state="translated">Erlang ODBC 응용 프로그램은 &lt;code&gt;Erlang&lt;/code&gt; 과 &lt;code&gt;C&lt;/code&gt; 코드 로 구성됩니다 . &lt;code&gt;C&lt;/code&gt; 의 코드는 상업 빌드 윈도우, 솔라리스 및 리눅스 (SLES10)에 대한 미리 컴파일 된 실행 파일로 제공됩니다. 오픈 소스 배포에서는 configure 및 make를 사용하는 다른 모든 응용 프로그램과 동일한 방식으로 빌드됩니다. --with-odbc = PATH를 사용하여 ODBC 라이브러리의 경로를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a4351bfa2f995c6bd330803859435f644586add" translate="yes" xml:space="preserve">
          <source>The Erlang ODBC application should run on all Unix dialects including Linux, Windows 2000, Windows XP and NT. But currently it is only tested for Solaris, Windows 2000, Windows XP and NT.</source>
          <target state="translated">Erlang ODBC 응용 프로그램은 Linux, Windows 2000, Windows XP 및 NT를 포함한 모든 Unix 언어에서 실행되어야합니다. 그러나 현재는 Solaris, Windows 2000, Windows XP 및 NT에 대해서만 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="c54f824f83f969a528f4d85db8ff3bf2b47f63fe" translate="yes" xml:space="preserve">
          <source>The Erlang ODBC application should work for any relational database that has an ODBC driver. But currently it is only regularly tested for &lt;code&gt;sqlserver&lt;/code&gt; and &lt;code&gt;postgres&lt;/code&gt;.</source>
          <target state="translated">Erlang ODBC 응용 프로그램은 ODBC 드라이버가있는 관계형 데이터베이스에서 작동해야합니다. 그러나 현재는 &lt;code&gt;sqlserver&lt;/code&gt; 및 &lt;code&gt;postgres&lt;/code&gt; 에 대해서만 정기적으로 테스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="7d474f74418b8768698a57fb6613d328b379dec3" translate="yes" xml:space="preserve">
          <source>The Erlang ODBC interface is in principal database independent, e.i. an erlang program using the interface could be run without changes towards different databases. But as SQL is used it is alas possible to write database dependent programs. Even though SQL is an ANSI-standard meant to be database independent, different databases have proprietary extensions to SQL defining their own data types. If you keep to the ANSI data types you will minimize the problem. But unfortunately there is no guarantee that all databases actually treats the ANSI data types equivalently. For instance an installation of &lt;code&gt;Oracle Enterprise release 8.0.5.0.0 for unix&lt;/code&gt; will accept that you create a table column with the ANSI data type &lt;code&gt;integer&lt;/code&gt;, but when retrieving values from this column the driver reports that it is of type &lt;code&gt;SQL_DECIMAL(0, 38)&lt;/code&gt; and not &lt;code&gt;SQL_INTEGER&lt;/code&gt; as you may have expected.</source>
          <target state="translated">Erlang ODBC 인터페이스는 주 데이터베이스에 독립적입니다. 즉, 인터페이스를 사용하는 erlang 프로그램은 다른 데이터베이스로 변경하지 않고도 실행될 수 있습니다. 그러나 SQL이 사용됨에 따라 데이터베이스 종속 프로그램을 작성할 수 있습니다. SQL은 데이터베이스와 무관 한 ANSI 표준이지만 다른 데이터베이스는 자체 데이터 형식을 정의하는 SQL에 대한 고유 한 확장명을 갖습니다. ANSI 데이터 형식을 유지하면 문제가 최소화됩니다. 그러나 불행히도 모든 데이터베이스가 실제로 ANSI 데이터 유형을 동등하게 취급한다는 보장은 없습니다. 예를 들어, &lt;code&gt;Oracle Enterprise release 8.0.5.0.0 for unix&lt;/code&gt; 설치 하면 ANSI 데이터 유형 &lt;code&gt;integer&lt;/code&gt; 를 사용하여 테이블 열을 작성할 수 있습니다.그러나이 열에서 값을 검색 할 때 드라이버 는 예상 한대로 &lt;code&gt;SQL_INTEGER&lt;/code&gt; 가 아닌 &lt;code&gt;SQL_DECIMAL(0, 38)&lt;/code&gt; 유형임을보고합니다 .</target>
        </trans-unit>
        <trans-unit id="56a64c0ae629896e0d315a11fe6e47437de08daf" translate="yes" xml:space="preserve">
          <source>The Erlang Port Mapper Daemon &lt;strong&gt;epmd&lt;/strong&gt; is automatically started at every host where an Erlang node is started. It is responsible for mapping the symbolic node names to machine addresses. See the &lt;code&gt;epmd(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">Erlang 포트 매퍼 데몬 &lt;strong&gt;epmd&lt;/strong&gt; 는 Erlang 노드가 시작된 모든 호스트에서 자동으로 시작됩니다. 심볼 노드 이름을 시스템 주소에 매핑합니다. ERTS 의 &lt;code&gt;epmd(1)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d980add9dd240554f189b1c3b37b65443fa21bb5" translate="yes" xml:space="preserve">
          <source>The Erlang Runtime System Application, ERTS, contains functionality necessary to run the Erlang system.</source>
          <target state="translated">ERTS (Erlang Runtime System Application)에는 Erlang 시스템을 실행하는 데 필요한 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec553e20bbac1faf44d07e9ebb7fae6ca5046122" translate="yes" xml:space="preserve">
          <source>The Erlang SSL application implements the SSL/TLS/DTLS protocol for the currently supported versions, see the &lt;code&gt;&lt;a href=&quot;ssl&quot;&gt;ssl(3)&lt;/a&gt;&lt;/code&gt; manual page.</source>
          <target state="translated">Erlang SSL 응용 프로그램은 현재 지원되는 버전에 대한 SSL / TLS / DTLS 프로토콜을 구현합니다. &lt;code&gt;&lt;a href=&quot;ssl&quot;&gt;ssl(3)&lt;/a&gt;&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6ca09abc1780869abd79ed38a1d8065b44531491" translate="yes" xml:space="preserve">
          <source>The Erlang SSL application implements the TLS/DTLS protocol for the currently supported versions, see the &lt;code&gt;&lt;a href=&quot;ssl&quot;&gt;ssl(3)&lt;/a&gt;&lt;/code&gt; manual page.</source>
          <target state="translated">Erlang SSL 애플리케이션은 현재 지원되는 버전에 대해 TLS / DTLS 프로토콜을 구현합니다. &lt;code&gt;&lt;a href=&quot;ssl&quot;&gt;ssl(3)&lt;/a&gt;&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0c184aeafc9a6a8c3c28dfd4fc9896eddb1e7172" translate="yes" xml:space="preserve">
          <source>The Erlang Token Scanner returns tokens with a subset of the following annotations, depending on the options:</source>
          <target state="translated">Erlang 토큰 스캐너는 옵션에 따라 다음 주석의 서브 세트가있는 토큰을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f44e036ac3f33332c9617d1ca93feead49accb2d" translate="yes" xml:space="preserve">
          <source>The Erlang VM uses a PCRE library where heap memory is used when regular expression match recursion occurs. This therefore limits the use of machine heap, not C stack.</source>
          <target state="translated">Erlang VM은 정규식 일치 재귀가 발생할 때 힙 메모리가 사용되는 PCRE 라이브러리를 사용합니다. 따라서 C 스택이 아닌 머신 힙 사용이 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="8d4936bbce5dce7c69c00ed9e6d923ffdcef1207" translate="yes" xml:space="preserve">
          <source>The Erlang archives are &lt;code&gt;ZIP&lt;/code&gt; files with extension &lt;code&gt;.ez&lt;/code&gt;. Erlang archives can also be enclosed in &lt;code&gt;escript&lt;/code&gt; files whose file extension is arbitrary.</source>
          <target state="translated">Erlang 아카이브는 확장자가 &lt;code&gt;.ez&lt;/code&gt; 인 &lt;code&gt;ZIP&lt;/code&gt; 파일입니다 . Erlang 아카이브는 파일 확장자가 임의 인 &lt;code&gt;escript&lt;/code&gt; 파일로 묶을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75458bb55fedfe4d27d190b85b2453fc10e6e94f" translate="yes" xml:space="preserve">
          <source>The Erlang code in the &quot;Erlang code.&quot; section is written into the output file directly after the module declaration and predefined exports declaration so it is possible to add extra exports, define imports and other attributes which are then visible in the whole file.</source>
          <target state="translated">&quot;Erlang 코드&quot;의 Erlang 코드 섹션은 모듈 선언 및 사전 정의 된 내보내기 선언 바로 다음에 출력 파일에 작성되므로 추가 내보내기를 추가하고 가져 오기 및 기타 속성을 정의하여 전체 파일에 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bada6b35e4702ac9e1f602bd85f459a9e5c8d11" translate="yes" xml:space="preserve">
          <source>The Erlang code is slightly different, as we do not return the result synchronously from &lt;code&gt;port_control&lt;/code&gt;, instead we get it from &lt;code&gt;driver_output&lt;/code&gt; as data in the message queue. The function &lt;code&gt;return_port_data&lt;/code&gt; above receives data from the port. As the data is in binary format, we use &lt;code&gt;binary_to_term/1&lt;/code&gt; to convert it to an Erlang term. Notice that the driver is opened in binary mode (&lt;code&gt;open_port/2&lt;/code&gt; is called with option &lt;code&gt;[binary]&lt;/code&gt;). This means that data sent from the driver to the emulator is sent as binaries. Without option &lt;code&gt;binary&lt;/code&gt;, they would have been lists of integers.</source>
          <target state="translated">Erlang 코드는 &lt;code&gt;port_control&lt;/code&gt; 에서 결과를 동 기적으로 반환하지 않기 때문에 약간 다릅니다. 대신 메시지 큐의 데이터로 &lt;code&gt;driver_output&lt;/code&gt; 에서 결과 를 얻습니다 . 위의 &lt;code&gt;return_port_data&lt;/code&gt; 함수 는 포트에서 데이터를 수신합니다. 데이터는 이진 형식이므로 &lt;code&gt;binary_to_term/1&lt;/code&gt; 을 사용하여 데이터 를 Erlang 용어로 변환합니다. 드라이버가 이진 모드로 열립니다 ( &lt;code&gt;open_port/2&lt;/code&gt; 는 &lt;code&gt;[binary]&lt;/code&gt; 옵션으로 호출 됨 ). 이것은 드라이버에서 에뮬레이터로 전송 된 데이터가 바이너리로 전송됨을 의미합니다. &lt;code&gt;binary&lt;/code&gt; 옵션이 없으면 정수 목록이됩니다.</target>
        </trans-unit>
        <trans-unit id="57d172985612cd6cd41a2f597d2b75bb27821e07" translate="yes" xml:space="preserve">
          <source>The Erlang code linter.</source>
          <target state="translated">얼랭 코드 린터.</target>
        </trans-unit>
        <trans-unit id="a5138a7c32b5f91b090191893db4bd11097e1026" translate="yes" xml:space="preserve">
          <source>The Erlang code preprocessor includes functions that are used by the &lt;code&gt;compile&lt;/code&gt; module to preprocess macros and include files before the parsing takes place.</source>
          <target state="translated">Erlang 코드 프리 프로세서에는 &lt;code&gt;compile&lt;/code&gt; 모듈에서 매크로를 사전 처리하고 구문 분석이 발생하기 전에 파일을 포함 시키는 데 사용되는 기능이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="392fc9728278e4892ea581cefb80f74c12d7912e" translate="yes" xml:space="preserve">
          <source>The Erlang crash dump had a major facelift in Erlang/OTP R9C. The information in this section is therefore not directly applicable for older dumps. However, if you use &lt;code&gt; crashdump_viewer(3)&lt;/code&gt; on older dumps, the crash dumps are translated into a format similar to this.</source>
          <target state="translated">Erlang 크래시 덤프는 Erlang / OTP R9C에서 큰 외관을 가졌습니다. 따라서이 섹션의 정보는 이전 덤프에 직접 적용되지 않습니다. 그러나 이전 덤프에서 &lt;code&gt; crashdump_viewer(3)&lt;/code&gt; 를 사용 하면 크래시 덤프가 이와 유사한 형식으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="5d403e45ee407cb0dd03528fe23bfb406bd2d6ae" translate="yes" xml:space="preserve">
          <source>The Erlang crash dump had a major facelift in Erlang/OTP R9C. The information in this section is therefore not directly applicable for older dumps. However, if you use &lt;code&gt;crashdump_viewer(3)&lt;/code&gt; on older dumps, the crash dumps are translated into a format similar to this.</source>
          <target state="translated">Erlang 크래시 덤프는 Erlang / OTP R9C에서 크게 개선되었습니다. 따라서이 섹션의 정보는 이전 덤프에는 직접 적용 할 수 없습니다. 그러나 이전 덤프에서 &lt;code&gt;crashdump_viewer(3)&lt;/code&gt; 를 사용 하면 충돌 덤프는 이와 유사한 형식으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="737305746ee3808d6e58fd2718a7d171052eb3a2" translate="yes" xml:space="preserve">
          <source>The Erlang crash dump is a readable text file, but it can be difficult to read. Using the Crashdump Viewer tool in the &lt;code&gt;Observer&lt;/code&gt; application simplifies the task. This is a wx-widget-based tool for browsing Erlang crash dumps.</source>
          <target state="translated">Erlang 크래시 덤프는 읽을 수있는 텍스트 파일이지만 읽기 어려울 수 있습니다. &lt;code&gt;Observer&lt;/code&gt; 애플리케이션 에서 Crashdump Viewer 도구를 사용하면 작업이 간소화됩니다. 이것은 Erlang 크래시 덤프를 찾아보기위한 wx-widget 기반 도구입니다.</target>
        </trans-unit>
        <trans-unit id="3019fbc7ca6a8b1745aa1cb4e5822a66509aa10a" translate="yes" xml:space="preserve">
          <source>The Erlang crashdump contains a listing of each living Erlang process in the system. The following fields can exist for a process:</source>
          <target state="translated">Erlang 크래시 덤프에는 시스템에 존재하는 각 Erlang 프로세스의 목록이 포함되어 있습니다. 프로세스에 대해 다음 필드가 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db00cf758cc1a463b96d0532ae1f4b69cef5510a" translate="yes" xml:space="preserve">
          <source>The Erlang distribution can in theory use almost any connection-based protocol as bearer. However, a module that implements the protocol-specific parts of the connection setup is needed. The default distribution module is &lt;code&gt;inet_tcp_dist&lt;/code&gt; in the Kernel application. When starting an Erlang node distributed, &lt;code&gt;net_kernel&lt;/code&gt; uses this module to set up listen ports and connections.</source>
          <target state="translated">Erlang 배포판은 이론적으로 거의 모든 연결 기반 프로토콜을 베어러로 사용할 수 있습니다. 그러나 연결 설정의 프로토콜 특정 부분을 구현하는 모듈이 필요합니다. 커널 응용 프로그램에서 기본 배포 모듈은 &lt;code&gt;inet_tcp_dist&lt;/code&gt; 입니다. Erlang 노드 분배를 시작할 때 &lt;code&gt;net_kernel&lt;/code&gt; 은이 모듈을 사용하여 청취 포트 및 연결을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="5c65eb0e7a3b5fcbd2b82941f0e7502510e7adf8" translate="yes" xml:space="preserve">
          <source>The Erlang driver thread API can be used in conjunction with the POSIX thread API on UN-ices and with the Windows native thread API on Windows. The Erlang driver thread API has the advantage of being portable, but there can exist situations where you want to use functionality from the POSIX thread API or the Windows native thread API.</source>
          <target state="translated">Erlang 드라이버 스레드 API는 UN-ices의 POSIX 스레드 API 및 Windows의 Windows 기본 스레드 API와 함께 사용할 수 있습니다. Erlang 드라이버 스레드 API는 이식 가능하다는 장점이 있지만 POSIX 스레드 API 또는 Windows 기본 스레드 API의 기능을 사용하려는 상황이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd35f4981de74aaf8658339a6b773ed029b97baf" translate="yes" xml:space="preserve">
          <source>The Erlang driver thread API only returns error codes when it is reasonable to recover from an error condition. If it is not reasonable to recover from an error condition, the whole runtime system is terminated. For example, if a create mutex operation fails, an error code is returned, but if a lock operation on a mutex fails, the whole runtime system is terminated.</source>
          <target state="translated">Erlang 드라이버 스레드 API는 오류 조건에서 복구하는 것이 합리적인 경우에만 오류 코드를 리턴합니다. 오류 조건에서 복구하는 것이 합리적이지 않으면 전체 런타임 시스템이 종료됩니다. 예를 들어, 뮤텍스 작성 조작이 실패하면 오류 코드가 리턴되지만 뮤텍스에 대한 잠금 조작이 실패하면 전체 런타임 시스템이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f886f4ca7d89492a5c1356ea054f392597b34344" translate="yes" xml:space="preserve">
          <source>The Erlang editing mode provides a command that knows about the Erlang comment structure and can be used to fill text paragraphs in comments. Ex:</source>
          <target state="translated">Erlang 편집 모드는 Erlang 주석 구조에 대해 알고 명령에서 텍스트 단락을 채우는 데 사용할 수있는 명령을 제공합니다. 전의:</target>
        </trans-unit>
        <trans-unit id="6381e25503c0fb716dfd00aadaa0608beadd9a69" translate="yes" xml:space="preserve">
          <source>The Erlang emulator is found by examining the registry keys for the emulator version specified in the release data file. The new emulator must be properly installed before the upgrade for this to work.</source>
          <target state="translated">Erlang 에뮬레이터는 릴리스 데이터 파일에 지정된 에뮬레이터 버전의 레지스트리 키를 검사하여 찾을 수 있습니다. 업그레이드하려면 새 에뮬레이터를 올바르게 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="6339e932f018732bcd165eb1f04f836a77855588" translate="yes" xml:space="preserve">
          <source>The Erlang emulator keeps track of a &lt;strong&gt;stack trace&lt;/strong&gt;, information about recent function calls. This information is used if an error occurs, for example:</source>
          <target state="translated">Erlang 에뮬레이터 는 최근 함수 호출에 대한 정보 인 &lt;strong&gt;스택 추적을 추적&lt;/strong&gt; 합니다. 이 정보는 오류가 발생하는 경우에 사용됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="17cd3f882b4ce1af8737a7262e13ec5ab23b1f5e" translate="yes" xml:space="preserve">
          <source>The Erlang emulator.</source>
          <target state="translated">얼랭 에뮬레이터.</target>
        </trans-unit>
        <trans-unit id="5714cdd55594ddeb51b48625444a53558a829eec" translate="yes" xml:space="preserve">
          <source>The Erlang external term format is a representation of an Erlang term as a sequence of bytes, that is, a binary. Conversion between the two representations is done using the following BIFs:</source>
          <target state="translated">Erlang 외부 용어 형식은 Erlang 용어를 바이트 시퀀스, 즉 이진으로 표현한 것입니다. 두 표현 간의 변환은 다음 BIF를 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="152d4b6905d9f607d0072156b089899f65fd52eb" translate="yes" xml:space="preserve">
          <source>The Erlang implementation is &quot;clever&quot; and minimizes the number of times each message is tested against the patterns in each &lt;code&gt;receive&lt;/code&gt;.</source>
          <target state="translated">얼랭 구현은 &quot;영리&quot;이며, 각 메시지는 각각의 패턴에 대해 테스트 횟수 최소화 &lt;code&gt;receive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79a0b3cf2e8db83679b557ee8aff89fcae6b1c98" translate="yes" xml:space="preserve">
          <source>The Erlang interpreter can also be accessed through the interface module &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 인터프리터는 인터페이스 모듈 &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int(3)&lt;/a&gt;&lt;/code&gt; 통해 액세스 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3ca39c39b895d99de154868388ab2c941551645" translate="yes" xml:space="preserve">
          <source>The Erlang interpreter provides mechanisms for breakpoints and stepwise execution of code. It is primarily intended to be used by Debugger, see the User's Guide and &lt;code&gt;&lt;a href=&quot;debugger&quot;&gt;debugger(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 인터프리터는 중단 점 및 단계별 코드 실행 메커니즘을 제공합니다. 주로 디버거에서 사용하도록 만들어졌습니다. 사용 설명서 및 &lt;code&gt;&lt;a href=&quot;debugger&quot;&gt;debugger(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bfe42365ca090c07c2f31a18aa82078cc7413a46" translate="yes" xml:space="preserve">
          <source>The Erlang language is described in the &lt;a href=&quot;doc/reference_manual/users_guide&quot;&gt;Erlang Reference Manual&lt;/a&gt;. An Erlang tutorial can be found in &lt;a href=&quot;doc/getting_started/users_guide&quot;&gt; Getting Started With Erlang&lt;/a&gt;.</source>
          <target state="translated">Erlang 언어는 &lt;a href=&quot;doc/reference_manual/users_guide&quot;&gt;Erlang Reference Manual에&lt;/a&gt; 설명되어 있습니다. Erlang 튜토리얼은 Erlang &lt;a href=&quot;doc/getting_started/users_guide&quot;&gt;시작하기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c86834683bf25d823843edf61397923bc0c7af5" translate="yes" xml:space="preserve">
          <source>The Erlang language specification puts no limits on the number of processes, length of atoms, and so on. However, for performance and memory saving reasons, there will always be limits in a practical implementation of the Erlang language and execution environment.</source>
          <target state="translated">Erlang 언어 사양은 프로세스 수, 원자 길이 등을 제한하지 않습니다. 그러나 성능 및 메모리 절약을 위해 Erlang 언어 및 실행 환경의 실제 구현에는 항상 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5868365d112b2d753afe38d0282d35341218fb05" translate="yes" xml:space="preserve">
          <source>The Erlang literal syntax for strings uses the &quot;\&quot; (backslash) character as an escape code. You need to escape backslashes in literal strings, both in your code and in the shell, with an extra backslash, that is, &quot;\\&quot;.</source>
          <target state="translated">문자열의 Erlang 리터럴 구문은 &quot;\&quot;(백 슬래시) 문자를 이스케이프 코드로 사용합니다. 코드와 셸에서 추가 백 슬래시 ( &quot;\\&quot;)를 사용하여 리터럴 문자열에서 백 슬래시를 이스케이프 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="7436c6776e46ff0b0c98637a1562d8d93f74d6d7" translate="yes" xml:space="preserve">
          <source>The Erlang meta interpreter.</source>
          <target state="translated">Erlang 메타 통역사.</target>
        </trans-unit>
        <trans-unit id="6dd0afebea808766c4e5ba67702ba9bcda564088" translate="yes" xml:space="preserve">
          <source>The Erlang mode does, of course, provide this feature. The layout used is based on the common use of the language.</source>
          <target state="translated">Erlang 모드는 물론이 기능을 제공합니다. 사용 된 레이아웃은 일반적인 언어 사용을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="e03b514fa1c315e1fd202d5ceb91d82531266ba5" translate="yes" xml:space="preserve">
          <source>The Erlang mode for the Emacs editor includes two &lt;code&gt;Common Test&lt;/code&gt; test suite templates, one with extensive information in the function headers, and one with minimal information. A test suite template provides a quick start for implementing a suite from scratch and gives a good overview of the available callback functions. The two templates follows:</source>
          <target state="translated">Emacs 편집기의 Erlang 모드에는 두 개의 &lt;code&gt;Common Test&lt;/code&gt; 테스트 템플리트가 포함되어 있습니다 . 하나는 기능 헤더에 광범위한 정보가 있고 하나는 최소한의 정보입니다. 테스트 스위트 템플릿은 스위트를 처음부터 빠르게 구현하기위한 빠른 시작을 제공하고 사용 가능한 콜백 함수에 대한 개요를 제공합니다. 두 가지 템플릿은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd1e16dd7e3186a437be6f5c58e6b98f95a1b6f2" translate="yes" xml:space="preserve">
          <source>The Erlang module can look as follows:</source>
          <target state="translated">Erlang 모듈은 다음과 같이 보일 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4e4823fe40646d231f25e1af4061079540646bbb" translate="yes" xml:space="preserve">
          <source>The Erlang nif library contains function for easily working with I/O vectors as used by the unix system call &lt;code&gt;writev&lt;/code&gt;. The I/O Queue is not thread safe, so some other synchronization mechanism has to be used.</source>
          <target state="translated">Erlang nif 라이브러리에는 unix 시스템 호출 &lt;code&gt;writev&lt;/code&gt; 에서 사용되는 I / O 벡터를 쉽게 사용할 수있는 기능이 있습니다 . I / O 큐는 스레드로부터 안전하지 않으므로 다른 동기화 메커니즘을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4fe4b7ddd1b6e3fddbfb0dc8eba68674fa92a0bc" translate="yes" xml:space="preserve">
          <source>The Erlang node is to be given the short name &lt;code&gt;e1&lt;/code&gt; and must be set to use the same magic cookie as the C node, &lt;code&gt;secretcookie&lt;/code&gt;:</source>
          <target state="translated">Erlang 노드에는 짧은 이름 &lt;code&gt;e1&lt;/code&gt; 이 주어져야하고 &lt;code&gt;secretcookie&lt;/code&gt; C 노드와 동일한 매직 쿠키를 사용하도록 설정되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b252e3e3ea1acfeb31712ba10c8bb1164cc7e6f7" translate="yes" xml:space="preserve">
          <source>The Erlang nodes have different cookies.</source>
          <target state="translated">Erlang 노드에는 다른 쿠키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dac1fcc04ff2d796878d2e221f0d3d0504eeff3" translate="yes" xml:space="preserve">
          <source>The Erlang parser.</source>
          <target state="translated">얼랭 파서.</target>
        </trans-unit>
        <trans-unit id="e3e1a66870ceefa4057accb399287057807ab241" translate="yes" xml:space="preserve">
          <source>The Erlang part of the asynchronous driver consists of the sample file &lt;code&gt;pg_async.erl&lt;/code&gt;.</source>
          <target state="translated">비동기 드라이버의 Erlang 부분은 샘플 파일 &lt;code&gt;pg_async.erl&lt;/code&gt; 로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="8a9c70ac47d5fb1df5bdc0c1579a6d354d215f36" translate="yes" xml:space="preserve">
          <source>The Erlang pretty printer.</source>
          <target state="translated">Erlang 프리티 프린터.</target>
        </trans-unit>
        <trans-unit id="8092d1a007430220494c776fea5b8d0105151629" translate="yes" xml:space="preserve">
          <source>The Erlang process creating a port is said to be the &lt;strong&gt;port owner&lt;/strong&gt;, or the &lt;strong&gt;connected process&lt;/strong&gt; of the port. All communication to and from the port must go through the port owner. If the port owner terminates, so does the port (and the external program, if it is written correctly).</source>
          <target state="translated">포트를 생성하는 Erlang 프로세스는 &lt;strong&gt;포트 소유자&lt;/strong&gt; 또는 &lt;strong&gt;포트&lt;/strong&gt; 의 &lt;strong&gt;연결된 프로세스&lt;/strong&gt; 라고합니다. 포트와의 모든 통신은 포트 소유자를 거쳐야합니다. 포트 소유자가 종료되면 포트 (및 외부 프로그램이 올바르게 작성된 경우)도 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="27d54a521c2a5287aa3d01d2b57bd9e14da9ddb9" translate="yes" xml:space="preserve">
          <source>The Erlang representation for &quot;BMPString&quot; and &quot;UniversalString&quot; is either a list of ASCII values or a list of quadruples. The quadruple representation associates to the Unicode standard representation of characters. The ASCII characters are all represented by quadruples beginning with three zeros like {0,0,0,65} for character 'A'. When decoding a value for these strings, the result is a list of quadruples, or integers when the value is an ASCII character.</source>
          <target state="translated">&quot;BMPString&quot;및 &quot;UniversalString&quot;에 대한 Erlang 표현은 ASCII 값 목록 또는 4 중 목록입니다. 4 중 표현은 문자의 유니 코드 표준 표현과 연관됩니다. ASCII 문자는 모두 문자 'A'에 대해 {0,0,0,65}와 같이 3 개의 0으로 시작하는 4 중으로 표시됩니다. 이러한 문자열의 값을 디코딩 할 때 결과는 사중 목록 또는 값이 ASCII 문자 인 경우 정수입니다.</target>
        </trans-unit>
        <trans-unit id="fd34b0812f3e91023a25d2d60c73c4062e69913a" translate="yes" xml:space="preserve">
          <source>The Erlang representation of an ASN.1 &lt;code&gt;INTEGER&lt;/code&gt; is an integer or an atom if a &lt;code&gt;Named Number List&lt;/code&gt; (see &lt;code&gt;T6&lt;/code&gt; in the previous list) is specified.</source>
          <target state="translated">ASN.1 &lt;code&gt;INTEGER&lt;/code&gt; 의 Erlang 표현은 &lt;code&gt;Named Number List&lt;/code&gt; ( 이전 목록의 &lt;code&gt;T6&lt;/code&gt; 참조 )이 지정된 경우 정수 또는 원자 입니다.</target>
        </trans-unit>
        <trans-unit id="6762086b168330d83da3710e72be56df1e3f3f82" translate="yes" xml:space="preserve">
          <source>The Erlang runtime system can use the complete 32-bit (or 64-bit) address space, but the operating system often limits a single process to use less than that.</source>
          <target state="translated">Erlang 런타임 시스템은 완전한 32 비트 (또는 64 비트) 주소 공간을 사용할 수 있지만 운영 체제는 종종 단일 프로세스가 그보다 적게 사용하도록 제한합니다.</target>
        </trans-unit>
        <trans-unit id="b825bf5f9dd97f4fdde610e1f993f6d1d34418b7" translate="yes" xml:space="preserve">
          <source>The Erlang runtime system requires that the contents of the script used to boot the system is a binary Erlang term. This function transforms the &lt;code&gt;File.script&lt;/code&gt; boot script to a binary term, which is stored in the &lt;code&gt;File.boot&lt;/code&gt; file.</source>
          <target state="translated">Erlang 런타임 시스템을 사용하려면 시스템을 부팅하는 데 사용되는 스크립트의 내용이 이진 Erlang 용어 여야합니다. 이 함수는 &lt;code&gt;File.script&lt;/code&gt; 부팅 스크립트를 이진 용어로 변환 하며이 용어는 &lt;code&gt;File.boot&lt;/code&gt; 파일에 저장 됩니다.</target>
        </trans-unit>
        <trans-unit id="a1ce0572c42ceec3f568ad1851dad4770b2b84b7" translate="yes" xml:space="preserve">
          <source>The Erlang runtime system uses a generational garbage collection scheme, using an &quot;old heap&quot; for data that has survived at least one garbage collection. When there is no more room on the old heap, a fullsweep garbage collection is done.</source>
          <target state="translated">Erlang 런타임 시스템은 최소한 하나의 가비지 콜렉션에서 살아남은 데이터에 &quot;오래된 힙&quot;을 사용하여 세대 가비지 콜렉션 체계를 사용합니다. 이전 힙에 공간이 더 이상 없으면 전체 스윕 가비지 콜렉션이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="1b5c1cc2b8bfec92e6852fd54565f25ead94806c" translate="yes" xml:space="preserve">
          <source>The Erlang runtime systems view of &lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt;. To retrieve it, call &lt;code&gt;&lt;a href=&quot;erlang#system_time-0&quot;&gt; erlang:system_time()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt; 의 Erlang 런타임 시스템보기 . 이를 검색하려면 &lt;code&gt;&lt;a href=&quot;erlang#system_time-0&quot;&gt; erlang:system_time()&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9d9f6b0df9097bbff53b037dc4f96145ca6dbd2" translate="yes" xml:space="preserve">
          <source>The Erlang runtime systems view of &lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt;. To retrieve it, call &lt;code&gt;&lt;a href=&quot;erlang#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt; 의 Erlang 런타임 시스템보기 . 그것을 검색하려면 &lt;code&gt;&lt;a href=&quot;erlang#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="175c0bd0d93fcd68af4b41f5bd3ed0c1384dfa2e" translate="yes" xml:space="preserve">
          <source>The Erlang scanner in the &lt;code&gt;io&lt;/code&gt; module can be used as a starting point when writing a new scanner. Study &lt;code&gt;yeccscan.erl&lt;/code&gt; in order to see how a filter can be added on top of &lt;code&gt;io:scan_erl_form/3&lt;/code&gt; to provide a scanner for Yecc that tokenizes grammar files before parsing them with the Yecc parser. A more general approach to scanner implementation is to use a scanner generator. A scanner generator in Erlang called &lt;code&gt;leex&lt;/code&gt; is under development.</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; 모듈 의 Erlang 스캐너 는 새 스캐너를 작성할 때 시작점으로 사용할 수 있습니다. &lt;code&gt;yeccscan.erl&lt;/code&gt; 을 연구 하여 &lt;code&gt;io:scan_erl_form/3&lt;/code&gt; 위에 필터를 추가 하여 Yecc 파서로 구문 분석하기 전에 문법 파일을 토큰 화하는 Yecc 용 스캐너를 제공하는 방법을 확인하십시오. 스캐너 구현에 대한보다 일반적인 방법은 스캐너 생성기를 사용하는 것입니다. Erlang의 &lt;code&gt;leex&lt;/code&gt; 라는 스캐너 생성기 가 개발 중입니다.</target>
        </trans-unit>
        <trans-unit id="37265f6197faced222d42e8a4148f58e5b966cea" translate="yes" xml:space="preserve">
          <source>The Erlang server interface is implemented by module &lt;code&gt;mod_esi&lt;/code&gt;.</source>
          <target state="translated">Erlang 서버 인터페이스는 &lt;code&gt;mod_esi&lt;/code&gt; 모듈로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa8c45ba50425e13e797fcc4854bc1fcf3424403" translate="yes" xml:space="preserve">
          <source>The Erlang shell available over SSH</source>
          <target state="translated">SSH를 통해 사용 가능한 Erlang 쉘</target>
        </trans-unit>
        <trans-unit id="fa1d76065068bd2589fcd099c8a0c8156db2a1c8" translate="yes" xml:space="preserve">
          <source>The Erlang shell understands the command &lt;code&gt;c(Module)&lt;/code&gt; which both compiles and loads &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">얼랑 쉘은 명령 이해 &lt;code&gt;c(Module)&lt;/code&gt; 컴파일 및로드 모두 &lt;code&gt;Module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5dceee96a25b9a8c7bf615c2130bf76584510ce" translate="yes" xml:space="preserve">
          <source>The Erlang shell.</source>
          <target state="translated">얼랭 쉘.</target>
        </trans-unit>
        <trans-unit id="a51205151ea58d8438ebe29c7d0e6218f72ff948" translate="yes" xml:space="preserve">
          <source>The Erlang source code has support for the UTF-8 encoding and bytewise encoding. The default in Erlang/OTP R16B was bytewise (&lt;code&gt;latin1&lt;/code&gt;) encoding. It was changed to UTF-8 in Erlang/OTP 17.0. You can control the encoding by a comment like the following in the beginning of the file:</source>
          <target state="translated">Erlang 소스 코드는 UTF-8 인코딩 및 바이트 단위 인코딩을 지원합니다. Erlang / OTP R16B의 기본값은 바이트 단위 ( &lt;code&gt;latin1&lt;/code&gt; ) 인코딩입니다. Erlang / OTP 17.0에서 UTF-8로 변경되었습니다. 파일 시작 부분에서 다음과 같은 주석으로 인코딩을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="469909cd3bb80b2a08960dcf0954a2e053c206c4" translate="yes" xml:space="preserve">
          <source>The Erlang source file &lt;code&gt;encoding&lt;/code&gt; is selected by a comment in one of the first two lines of the source file. The first string that matches the regular expression &lt;code&gt;coding\s*[:=]\s*([-a-zA-Z0-9])+&lt;/code&gt; selects the encoding. If the matching string is an invalid encoding, it is ignored. The valid encodings are &lt;code&gt;Latin-1&lt;/code&gt; and &lt;code&gt;UTF-8&lt;/code&gt;, where the case of the characters can be chosen freely.</source>
          <target state="translated">Erlang 소스 파일 &lt;code&gt;encoding&lt;/code&gt; 은 소스 파일 의 처음 두 줄 중 하나의 주석에 의해 선택됩니다. 정규식 &lt;code&gt;coding\s*[:=]\s*([-a-zA-Z0-9])+&lt;/code&gt; 과 일치하는 첫 번째 문자열 \ s * [: =] \ s * ([-a-zA-Z0-9]) + 는 인코딩을 선택합니다. 일치하는 문자열이 유효하지 않은 인코딩 인 경우 무시됩니다. 유효한 인코딩은 &lt;code&gt;Latin-1&lt;/code&gt; 및 &lt;code&gt;UTF-8&lt;/code&gt; 이며 문자의 경우 자유롭게 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7ddb53385af1f6753c8713a645cc1fc36907bac" translate="yes" xml:space="preserve">
          <source>The Erlang source file &lt;strong id=&quot;encoding&quot;&gt;encoding&lt;/strong&gt; is selected by a comment in one of the first two lines of the source file. The first string matching the regular expression &lt;code&gt;coding\s*[:=]\s*([-a-zA-Z0-9])+&lt;/code&gt; selects the encoding. If the matching string is not a valid encoding, it is ignored. The valid encodings are &lt;code&gt;Latin-1&lt;/code&gt; and &lt;code&gt;UTF-8&lt;/code&gt;, where the case of the characters can be chosen freely.</source>
          <target state="translated">Erlang 소스 파일 &lt;strong id=&quot;encoding&quot;&gt;인코딩&lt;/strong&gt; 은 소스 파일 의 처음 두 줄 중 하나의 주석에 의해 선택됩니다. 정규식 &lt;code&gt;coding\s*[:=]\s*([-a-zA-Z0-9])+&lt;/code&gt; 일치하는 첫 번째 문자열 은 인코딩을 선택합니다. 일치하는 문자열이 유효한 인코딩이 아닌 경우 무시됩니다. 유효한 인코딩은 &lt;code&gt;Latin-1&lt;/code&gt; 및 &lt;code&gt;UTF-8&lt;/code&gt; 이며 문자의 경우 자유롭게 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="978c7190f27ebbf14f966c1feadf6f5410de9629" translate="yes" xml:space="preserve">
          <source>The Erlang system must be started.</source>
          <target state="translated">Erlang 시스템을 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="c9941ae0e376a140dd219d96c5fea5aedb3770d4" translate="yes" xml:space="preserve">
          <source>The Erlang token scanner.</source>
          <target state="translated">Erlang 토큰 스캐너.</target>
        </trans-unit>
        <trans-unit id="a16c12a6b02ac800a11334f62d3a994378ac0165" translate="yes" xml:space="preserve">
          <source>The Erlang web server API data types are as follows:</source>
          <target state="translated">Erlang 웹 서버 API 데이터 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="682db584bdb9aa3dd1062d8f6e41de11a4e999fd" translate="yes" xml:space="preserve">
          <source>The Erlang/OTP SSH application is intended to be used in other applications as a library.</source>
          <target state="translated">Erlang / OTP SSH 애플리케이션은 다른 애플리케이션에서 라이브러리로 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="834fb47d95be27590d99f014c1a5220c8d723132" translate="yes" xml:space="preserve">
          <source>The Erlang/OTP SSH server after a succesful authentication</source>
          <target state="translated">성공적인 인증 후 Erlang / OTP SSH 서버</target>
        </trans-unit>
        <trans-unit id="1ce8792731cffaac51f7760932b74501269d8966" translate="yes" xml:space="preserve">
          <source>The Erlang/OTP SSH server checks the user name and password in the following order:</source>
          <target state="translated">Erlang / OTP SSH 서버는 다음 순서로 사용자 이름과 암호를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="65d28c591e7208c326a531484ecbb2f3de4814d0" translate="yes" xml:space="preserve">
          <source>The Evaluator area, where you can evaluate functions within the context of the debugged process, if that process execution is stopped.</source>
          <target state="translated">프로세스 실행이 중지 된 경우 디버그 된 프로세스의 컨텍스트 내에서 함수를 평가할 수있는 평가자 영역.</target>
        </trans-unit>
        <trans-unit id="b8f527b2c601f16975ba4c3206247d354cc52722" translate="yes" xml:space="preserve">
          <source>The FTP client always tries to use passive FTP mode and only resort to active FTP mode if this fails. This default behavior can be changed by start option &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">FTP 클라이언트는 항상 수동 FTP 모드를 사용하려고 시도하며 이것이 실패하면 활성 FTP 모드에만 의존합니다. 이 기본 동작은 시작 옵션 &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; 로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46eb4343e573b38e361697e41777d053a18c2fba" translate="yes" xml:space="preserve">
          <source>The FTP client can be started and stopped dynamically in runtime by calling the &lt;code&gt;ftp&lt;/code&gt; application API &lt;code&gt;ftp:start_service(ServiceConfig)&lt;/code&gt; and &lt;code&gt;ftp:stop_service(Pid)&lt;/code&gt;.</source>
          <target state="translated">FTP 클라이언트는 &lt;code&gt;ftp&lt;/code&gt; 애플리케이션 API &lt;code&gt;ftp:start_service(ServiceConfig)&lt;/code&gt; 및 &lt;code&gt;ftp:stop_service(Pid)&lt;/code&gt; 를 호출하여 런타임에 동적으로 시작 및 중지 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ff37cf016753285c00cfe38b14f6b9064cd0bb5" translate="yes" xml:space="preserve">
          <source>The Flex scanner is a Megaco scanner written as a linked in driver (in C). There are two ways to get this working:</source>
          <target state="translated">Flex 스캐너는 링크 된 드라이버 (C)로 작성된 Megaco 스캐너입니다. 이 작업을 수행하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bd0f2f59d01566729720bb338392aa95bc03bec" translate="yes" xml:space="preserve">
          <source>The Fragment ID is used to number the fragments in a sequence. The id starts at the total number of fragments and then decrements to 1 (which is the final fragment). So if a sequence consists of 3 fragments the fragment id in the starting header will be 3, and then fragments 2 and 1 are sent.</source>
          <target state="translated">조각 ID는 시퀀스에서 조각에 번호를 매기는 데 사용됩니다. id는 총 조각 수에서 시작하여 1 (마지막 조각)로 감소합니다. 따라서 시퀀스가 ​​3 개의 조각으로 구성된 경우 시작 헤더의 조각 ID는 3이되고 조각 2와 1이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="b6270c4ff6807ee1959a0d7d8287c7ee55db3319" translate="yes" xml:space="preserve">
          <source>The Fun can also be passed as an argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#activity-2&quot;&gt;mnesia:activity/2,3,4&lt;/a&gt;&lt;/code&gt;, which enables use of customized activity access callback modules. It can either be obtained directly by stating the module name as argument, or implicitly by use of configuration parameter &lt;code&gt;access_module&lt;/code&gt;. A customized callback module can be used for several purposes, such as providing triggers, integrity constraints, runtime statistics, or virtual tables.</source>
          <target state="translated">Fun은 또한 &lt;code&gt;&lt;a href=&quot;mnesia#activity-2&quot;&gt;mnesia:activity/2,3,4&lt;/a&gt;&lt;/code&gt; 함수에 인수로 전달 될 수 있으며 ,이를 통해 사용자 정의 된 활동 액세스 콜백 모듈을 사용할 수 있습니다. 모듈 이름을 인수로 지정하여 직접 &lt;code&gt;access_module&lt;/code&gt; 구성 매개 변수 access_module 을 사용하여 암시 적으로 가져올 수 있습니다. 사용자 지정 콜백 모듈은 트리거, 무결성 제약 조건, 런타임 통계 또는 가상 테이블 제공과 같은 여러 목적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0817c2658a9f234929df429f0abce5aa05ce329d" translate="yes" xml:space="preserve">
          <source>The Fun can also be passed as an argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#activity-4&quot;&gt;mnesia:activity/2,3,4&lt;/a&gt;&lt;/code&gt;, which enables use of customized activity access callback modules. It can either be obtained directly by stating the module name as argument, or implicitly by use of configuration parameter &lt;code&gt;access_module&lt;/code&gt;. A customized callback module can be used for several purposes, such as providing triggers, integrity constraints, runtime statistics, or virtual tables.</source>
          <target state="translated">Fun은 &lt;code&gt;&lt;a href=&quot;mnesia#activity-4&quot;&gt;mnesia:activity/2,3,4&lt;/a&gt;&lt;/code&gt; 함수에 대한 인수로 전달 될 수 있으며 ,이를 통해 사용자 정의 된 액티비티 액세스 콜백 모듈을 사용할 수 있습니다. 모듈 이름을 인수로 지정하거나 구성 매개 변수 &lt;code&gt;access_module&lt;/code&gt; 을 사용하여 암시 적으로 얻을 수 있습니다. 사용자 정의 된 콜백 모듈은 트리거, 무결성 제한 조건, 런타임 통계 또는 가상 테이블 제공과 같은 여러 목적으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="279188337fe7d9611837624292436a6f0c6df988" translate="yes" xml:space="preserve">
          <source>The GC_REGEXP definition</source>
          <target state="translated">GC_REGEXP 정의</target>
        </trans-unit>
        <trans-unit id="491576369b07d94c026adb9d94add3cd468dc1c6" translate="yes" xml:space="preserve">
          <source>The GUI main window is opened when Crashdump Viewer has loaded a crashdump. It contains a title bar, a menu bar, information tabs, and a status bar.</source>
          <target state="translated">Crashdump Viewer가 크래시 덤프를로드하면 GUI 기본 창이 열립니다. 제목 표시 줄, 메뉴 표시 줄, 정보 탭 및 상태 표시 줄이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="468c9cc0468cc5c92ee919e07070c915b671da34" translate="yes" xml:space="preserve">
          <source>The GetNext Operation operation should only be defined for tables since the agent can find the next instance of plain variables in the MIB and call the instrumentation with the &lt;code&gt;get&lt;/code&gt; operation.</source>
          <target state="translated">에이전트가 MIB에서 다음 일반 변수 인스턴스를 찾아 &lt;code&gt;get&lt;/code&gt; 조작으로 계측을 호출 할 수 있으므로 GetNext 조작 조작은 테이블에 대해서만 정의되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="ca4179f6bcde085d4b0d34f9240821a74141f758" translate="yes" xml:space="preserve">
          <source>The Gregorian calendar in this module is extended back to year 0. For a given date, the &lt;strong&gt;gregorian days&lt;/strong&gt; is the number of days up to and including the date specified. Similarly, the &lt;strong&gt;gregorian seconds&lt;/strong&gt; for a specified date and time is the number of seconds up to and including the specified date and time.</source>
          <target state="translated">이 모듈의 Gregorian 달력은 0 년으로 다시 확장됩니다. 주어진 날짜의 &lt;strong&gt;gregorian days&lt;/strong&gt; 는 지정된 날짜까지의 날짜 수입니다. 마찬가지로, 지정된 날짜 및 시간에 대한 &lt;strong&gt;그레고리 안 초&lt;/strong&gt; 는 지정된 날짜 및 시간을 포함하여 최대 초 수입니다.</target>
        </trans-unit>
        <trans-unit id="6a32364a7c7faf5d1cbacad811c6e3a642e6422e" translate="yes" xml:space="preserve">
          <source>The HTML overview log file is updated with test results.</source>
          <target state="translated">HTML 개요 로그 파일이 테스트 결과로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="7141eac40a2b0f12431f108b64d289e030f4933d" translate="yes" xml:space="preserve">
          <source>The HTML tags allowed in &lt;code&gt;application/erlang+html&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;application/erlang+html&lt;/code&gt; 에서 허용되는 HTML 태그 .</target>
        </trans-unit>
        <trans-unit id="aab4263cb8d1f32842025f35d2e34059d6bef33e" translate="yes" xml:space="preserve">
          <source>The HTML version of the test suite source code is not generated during the test run (and is consequently not available in the log file system).</source>
          <target state="translated">테스트 스위트 소스 코드의 HTML 버전은 테스트 실행 중에 생성되지 않으며 결과적으로 로그 파일 시스템에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e41fc71ae08f56427cd0499723a4d95a81e54bc2" translate="yes" xml:space="preserve">
          <source>The HTTP client and server are HTTP 1.1 compliant as defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">HTTP 클라이언트 및 서버는 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; 에 정의 된 대로 HTTP 1.1을 준수 합니다.</target>
        </trans-unit>
        <trans-unit id="0a3e013cebd4679eacc44ce278db16ae997e7553" translate="yes" xml:space="preserve">
          <source>The HTTP client default profile is started when the &lt;code&gt;Inets&lt;/code&gt; application is started and is then available to all processes on that Erlang node. Other profiles can also be started at application startup, or profiles can be started and stopped dynamically in runtime. Each client profile spawns a new process to handle each request, unless a persistent connection can be used with or without pipelining. The client adds a &lt;code&gt;host&lt;/code&gt; header and an empty &lt;code&gt;te&lt;/code&gt; header if there are no such headers present in the request.</source>
          <target state="translated">HTTP 클라이언트 기본 프로파일은 &lt;code&gt;Inets&lt;/code&gt; 애플리케이션 이 시작될 때 시작된 다음 해당 Erlang 노드의 모든 프로세스에서 사용할 수 있습니다. 응용 프로그램 시작시 다른 프로파일을 시작하거나 런타임에 프로파일을 동적으로 시작 및 중지 할 수도 있습니다. 파이프 라인을 사용하거나 사용하지 않고 지속적인 연결을 사용할 수없는 경우 각 클라이언트 프로파일은 각 요청을 처리하기 위해 새 프로세스를 생성합니다. 요청에 이러한 헤더가없는 경우 클라이언트는 &lt;code&gt;host&lt;/code&gt; 헤더와 빈 &lt;code&gt;te&lt;/code&gt; 헤더를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="7c7ba7538b9c9c0121b49c6ec91168734deba0dc" translate="yes" xml:space="preserve">
          <source>The HTTP server, also referred to as httpd, handles HTTP requests as described in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; with a few exceptions, such as gateway and proxy functionality. The server supports IPv6 as long as the underlying mechanisms also do so.</source>
          <target state="translated">httpd라고도하는 HTTP 서버 는 게이트웨이 및 프록시 기능과 같은 몇 가지 예외를 제외하고 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; 에 설명 된 대로 HTTP 요청을 처리 합니다. 기본 메커니즘이 지원하는 한 서버는 IPv6을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ed5f93e75e8af313b179c6713c54eb1bf37d9eef" translate="yes" xml:space="preserve">
          <source>The HTTP standard requires them to be case insensitive. Use this feature only if there is no other way to communicate with the server or for testing purpose. When this option is used, no headers are automatically added. All necessary headers must be provided by the user.</source>
          <target state="translated">HTTP 표준에서는 대소 문자를 구분하지 않아야합니다. 서버와 통신 할 다른 방법이 없거나 테스트 목적으로 만이 기능을 사용하십시오. 이 옵션을 사용하면 헤더가 자동으로 추가되지 않습니다. 필요한 모든 헤더는 사용자가 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="f2d85de81f5fcc8588a618440bb02e8ae50bca16" translate="yes" xml:space="preserve">
          <source>The HTTP status code returned to the client (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">HTTP 상태 코드가 클라이언트에 리턴되었습니다 ( &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aa0035abf3b99831613dc762c61fbb26c4588f4e" translate="yes" xml:space="preserve">
          <source>The Handshake in Detail</source>
          <target state="translated">자세한 악수</target>
        </trans-unit>
        <trans-unit id="1b82e39a63325ee5467a0018be1f905eeb2f7c52" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol. The packets are returned with the format according to &lt;code&gt;HttpPacket&lt;/code&gt; described earlier. A packet is either a request, a response, a header, or an end of header mark. Invalid lines are returned as &lt;code&gt;HttpError&lt;/code&gt;.</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜. 패킷은 앞에서 설명한 &lt;code&gt;HttpPacket&lt;/code&gt; 에 따른 형식으로 반환됩니다 . 패킷은 요청, 응답, 헤더 또는 헤더 마크의 끝입니다. 유효하지 않은 행은 &lt;code&gt;HttpError&lt;/code&gt; 로 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="3946370c047884fbf4c2f18670e43abd4a1961c1" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol. The packets are returned with the format according to &lt;code&gt;HttpPacket&lt;/code&gt; described in &lt;code&gt; erlang:decode_packet/3&lt;/code&gt; in ERTS. A socket in passive mode returns &lt;code&gt;{ok, HttpPacket}&lt;/code&gt; from &lt;code&gt;gen_tcp:recv&lt;/code&gt; while an active socket sends messages like &lt;code&gt;{http, Socket, HttpPacket}&lt;/code&gt;.</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜. 패킷은 ERTS의 &lt;code&gt; erlang:decode_packet/3&lt;/code&gt; 에 설명 된 &lt;code&gt;HttpPacket&lt;/code&gt; 에 따른 형식으로 반환됩니다 . 수동 모드의 소켓 은 &lt;code&gt;gen_tcp:recv&lt;/code&gt; 에서 &lt;code&gt;{ok, HttpPacket}&lt;/code&gt; 을 반환 하고 활성 소켓은 &lt;code&gt;{http, Socket, HttpPacket}&lt;/code&gt; 과 같은 메시지를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="169734960811a4c34c5ce86c1d456ff7cf230d3e" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol. The packets are returned with the format according to &lt;code&gt;HttpPacket&lt;/code&gt; described in &lt;code&gt;erlang:decode_packet/3&lt;/code&gt; in ERTS. A socket in passive mode returns &lt;code&gt;{ok, HttpPacket}&lt;/code&gt; from &lt;code&gt;gen_tcp:recv&lt;/code&gt; while an active socket sends messages like &lt;code&gt;{http, Socket, HttpPacket}&lt;/code&gt;.</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜. 패킷은 ERTS의 &lt;code&gt;erlang:decode_packet/3&lt;/code&gt; 에 설명 된 &lt;code&gt;HttpPacket&lt;/code&gt; 에 따른 형식으로 반환됩니다 . 패시브 모드의 소켓 은 &lt;code&gt;gen_tcp:recv&lt;/code&gt; 에서 &lt;code&gt;{ok, HttpPacket}&lt;/code&gt; 을 반환 하고 활성 소켓은 &lt;code&gt;{http, Socket, HttpPacket}&lt;/code&gt; 과 같은 메시지를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="0fdd97c77238f0d4bc1a4b8495b731166db58155" translate="yes" xml:space="preserve">
          <source>The I/O device used when Erlang is started with the &quot;-oldshell&quot; or &quot;-noshell&quot; flags is by default set to &lt;code&gt;latin1&lt;/code&gt; encoding, meaning that any characters &amp;gt; codepoint 255 are escaped and that input is expected to be plain 8-bit ISO Latin-1. If the encoding is changed to Unicode, input and output from the standard file descriptors are in UTF-8 (regardless of operating system).</source>
          <target state="translated">Erlang이 &quot;-oldshell&quot;또는 &quot;-noshell&quot;플래그로 시작될 때 사용되는 I / O 장치는 기본적으로 &lt;code&gt;latin1&lt;/code&gt; 인코딩 으로 설정됩니다 . 즉, 문자&amp;gt; 코드 포인트 255가 이스케이프되고 입력이 일반 8 비트 여야합니다. ISO 라틴어 -1. 인코딩이 유니 코드로 변경되면 표준 파일 디스크립터의 입력 및 출력은 UTF-8 (운영 체제와 상관없이)입니다.</target>
        </trans-unit>
        <trans-unit id="3a9ee44bfdadb9768492101f1c57f8171e2439fd" translate="yes" xml:space="preserve">
          <source>The I/O protocol in Erlang enables bi-directional communication between clients and servers.</source>
          <target state="translated">Erlang의 I / O 프로토콜은 클라이언트와 서버 간의 양방향 통신을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="da4b71eee53848cfe7e0ded6f806a23b361aa596" translate="yes" xml:space="preserve">
          <source>The I/O server can, for a list of requests, send any of the following valid results in the reply, depending on the requests in the list:</source>
          <target state="translated">I / O 서버는 요청 목록에 대해 목록의 요청에 따라 다음과 같은 유효한 결과를 응답으로 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bf03aa38e2e7b2e9d865676ed62c6ed1b166de9" translate="yes" xml:space="preserve">
          <source>The I/O server is a process that handles the requests and performs the requested task on, for example, an I/O device.</source>
          <target state="translated">I / O 서버는 요청을 처리하고 요청 된 작업 (예 : I / O 장치)을 수행하는 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="29324f42eeb70cb428190b9afb707250b51d08e0" translate="yes" xml:space="preserve">
          <source>The I/O server is to send one of the following as &lt;code&gt;Reply&lt;/code&gt;:</source>
          <target state="translated">I / O 서버는 다음 중 하나를 &lt;code&gt;Reply&lt;/code&gt; 으로 보내야합니다 .</target>
        </trans-unit>
        <trans-unit id="cffff6188b7c071be58063158f15f52414545611" translate="yes" xml:space="preserve">
          <source>The I/O server is to send the &lt;code&gt;Reply&lt;/code&gt; as:</source>
          <target state="translated">I / O 서버는 다음과 같이 &lt;code&gt;Reply&lt;/code&gt; 을 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="a68a34b093217c6e79f51f56360324a76a6607db" translate="yes" xml:space="preserve">
          <source>The I/O server replies to the client with an &lt;code&gt;io_reply&lt;/code&gt; tuple, where element &lt;code&gt;Reply&lt;/code&gt; is one of:</source>
          <target state="translated">I / O 서버는 &lt;code&gt;io_reply&lt;/code&gt; 튜플 을 사용하여 클라이언트에 응답합니다. 여기서 &lt;code&gt;Reply&lt;/code&gt; 요소 는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="d6984e80e5ec40501eed04b79f0e90cd3e1a039b" translate="yes" xml:space="preserve">
          <source>The I/O server replies:</source>
          <target state="translated">I / O 서버가 응답합니다 :</target>
        </trans-unit>
        <trans-unit id="615c499b56501d6b2d674044444c5cd252a3aa4d" translate="yes" xml:space="preserve">
          <source>The I/O vector used by the emulator and drivers is a list of binaries, with a &lt;code&gt;SysIOVec&lt;/code&gt; pointing to the buffers of the binaries. It is used in &lt;code&gt;driver_outputv&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;driver_entry#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; driver callback. Also, the driver queue is an &lt;code&gt;ErlIOVec&lt;/code&gt;.</source>
          <target state="translated">에뮬레이터와 드라이버에서 사용하는 I / O 벡터는 바이너리 목록이며 &lt;code&gt;SysIOVec&lt;/code&gt; 은 바이너리 버퍼를 가리 킵니다. 그것은에 사용 &lt;code&gt;driver_outputv&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;driver_entry#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; 의 드라이버 콜백. 또한 드라이버 큐는 &lt;code&gt;ErlIOVec&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="11486f73702f77793d0c501dded54bd9d9a0b366" translate="yes" xml:space="preserve">
          <source>The ID of the handler (which is &lt;code&gt;false&lt;/code&gt; if it was registered without an ID).</source>
          <target state="translated">핸들러의 ID입니다 ( ID없이 등록 된 경우 &lt;code&gt;false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5910e0f627e6ac1682f658faee394e4ef0132c80" translate="yes" xml:space="preserve">
          <source>The IDs contains normal fully qualified domain names like e.g &lt;code&gt;foo.example.com&lt;/code&gt;, but IP addresses are not recommended. The rfc describes why this is not recommended as well as security considerations about how to aquire the Reference IDs.</source>
          <target state="translated">ID에는 &lt;code&gt;foo.example.com&lt;/code&gt; 과 같은 정규화 된 정규 도메인 이름이 포함 되지만 IP 주소는 권장되지 않습니다. rfc는 이것이 권장되지 않는 이유와 참조 ID를 얻는 방법에 대한 보안 고려 사항을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ba43ecb0debcc2f97c4e2d5e92d1fb358277b19c" translate="yes" xml:space="preserve">
          <source>The IF() macro</source>
          <target state="translated">IF () 매크로</target>
        </trans-unit>
        <trans-unit id="b28f4dac9c4ee5d63c861a672e8fdeba64970c63" translate="yes" xml:space="preserve">
          <source>The IP addresses must be specified in the standard form (four decimal numbers separated by periods, for example, &lt;code&gt;&quot;150.236.20.74&quot;&lt;/code&gt;. Hosts names are not acceptable, but a broadcast address (preferably limited to the local network) is.</source>
          <target state="translated">IP 주소는 표준 형식으로 지정해야합니다 (예 : &lt;code&gt;&quot;150.236.20.74&quot;&lt;/code&gt; 와 같이 마침표로 구분 된 십진수 네 개) . 호스트 이름은 허용되지 않지만 브로드 캐스트 주소는 로컬 네트워크로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="8e52fe37494dbcf6555873254ea719776b067efd" translate="yes" xml:space="preserve">
          <source>The IP_ADJUSTMENT pre-bound variable</source>
          <target state="translated">IP_ADJUSTMENT 사전 바인딩 된 변수</target>
        </trans-unit>
        <trans-unit id="74be3487335549a3ba00af3a4220139041a986e4" translate="yes" xml:space="preserve">
          <source>The Inets services API.</source>
          <target state="translated">Inets 서비스 API.</target>
        </trans-unit>
        <trans-unit id="2bd655ea5793b54cfcef1365f007ad296dab65da" translate="yes" xml:space="preserve">
          <source>The Interpret Modules window is used for selecting which modules to interpret. Initially, the window displays the modules (&lt;code&gt;erl&lt;/code&gt; files) and subdirectories of the current working directory.</source>
          <target state="translated">모듈 해석 창은 해석 할 모듈을 선택하는 데 사용됩니다. 처음에는이 창 에 현재 작업 디렉토리 의 모듈 ( &lt;code&gt;erl&lt;/code&gt; 파일) 및 하위 디렉토리가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="46568e5f2d41b68efc3d2efed445ca9d877dd874" translate="yes" xml:space="preserve">
          <source>The Kernel application has all the code necessary to run the Erlang runtime system: file servers, code servers, and so on.</source>
          <target state="translated">커널 응용 프로그램에는 Erlang 런타임 시스템을 실행하는 데 필요한 모든 코드 (파일 서버, 코드 서버 등)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d2901750e4e178866aa29af00b9514d934b8cb3" translate="yes" xml:space="preserve">
          <source>The Kernel application is the first application started. It is mandatory in the sense that the minimal system based on Erlang/OTP consists of Kernel and STDLIB. Kernel contains the following functional areas:</source>
          <target state="translated">커널 응용 프로그램은 처음 시작된 응용 프로그램입니다. Erlang / OTP 기반의 최소 시스템은 Kernel과 STDLIB로 구성되어야합니다. 커널에는 다음과 같은 기능 영역이 있습니다.</target>
        </trans-unit>
        <trans-unit id="393233a88750cf4fe6f8a18919929901cb57f040" translate="yes" xml:space="preserve">
          <source>The Kernel configuration parameter &lt;code&gt;global_groups&lt;/code&gt; defines the global groups (see also &lt;code&gt;kernel(6)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">커널 구성 매개 변수 &lt;code&gt;global_groups&lt;/code&gt; 는 글로벌 그룹을 정의합니다 ( &lt;code&gt;kernel(6)&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="329d0e8d9e7fbac7a43bba657580181c6f878afc" translate="yes" xml:space="preserve">
          <source>The Kernel/STDLIB applications are damaged or the start script is damaged.</source>
          <target state="translated">커널 / STDLIB 응용 프로그램이 손상되었거나 시작 스크립트가 손상되었습니다.</target>
        </trans-unit>
        <trans-unit id="ce538f925bf84002c38fbd4dc502029a22341ac9" translate="yes" xml:space="preserve">
          <source>The Leex module should be considered experimental as it will be subject to changes in future releases.</source>
          <target state="translated">Leex 모듈은 향후 릴리스에서 변경 될 수 있으므로 실험적인 것으로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="c848076de058785ede6b2e785124e2cf00899a54" translate="yes" xml:space="preserve">
          <source>The Linux Trace Toolkit: next generation is an open source system software package for correlated tracing of the Linux kernel, user applications and libraries.</source>
          <target state="translated">Linux Trace Toolkit : 차세대는 Linux 커널, 사용자 애플리케이션 및 라이브러리의 상관 추적을위한 오픈 소스 시스템 소프트웨어 패키지입니다.</target>
        </trans-unit>
        <trans-unit id="9b5f802a372a8d9f81e47da8ffe942e03e117399" translate="yes" xml:space="preserve">
          <source>The Logger backend forwards log events from the API, first through a set of &lt;strong&gt;primary filters&lt;/strong&gt;, then through a set of secondary filters attached to each log handler. The secondary filters are in the following named &lt;strong&gt;handler filters&lt;/strong&gt;.</source>
          <target state="translated">로거 백엔드는 먼저 &lt;strong&gt;기본 필터&lt;/strong&gt; 세트를 통해 API에서 로그 이벤트를 전달한 다음 각 로그 핸들러에 첨부 된 보조 필터 세트를 통해 로그 이벤트를 전달 합니다. 보조 필터는 다음과 같은 명명 된 &lt;strong&gt;핸들러 필터에&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="30f7d257c062cf1d99aadf05acae5dcdc7db0748" translate="yes" xml:space="preserve">
          <source>The Logger proxy is an Erlang process which is part of the Kernel application's supervision tree. During startup, the proxy process registers itself as the &lt;code&gt;system_logger&lt;/code&gt;, meaning that log events produced by the emulator are sent to this process.</source>
          <target state="translated">Logger 프록시는 커널 애플리케이션의 감독 트리의 일부인 Erlang 프로세스입니다. 시작하는 동안 프록시 프로세스는 자신을 &lt;code&gt;system_logger&lt;/code&gt; 로 등록합니다 . 즉, 에뮬레이터에서 생성 된 로그 이벤트가이 프로세스로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="709c2b894a55cf0a9eb1d8fa9b54a57e464ba3b7" translate="yes" xml:space="preserve">
          <source>The M-bit on a component AVP of a Grouped AVP that does not set M is ignored: such AVPs are not regarded as erroneous at decode.</source>
          <target state="translated">M을 설정하지 않은 그룹화 된 AVP의 컴포넌트 AVP에있는 M- 비트는 무시됩니다. 이러한 AVP는 디코딩시 잘못된 것으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b932f03ca4571cac226370cd6a0c3fc9c9dd133c" translate="yes" xml:space="preserve">
          <source>The MBC area is called &lt;strong&gt;sa&lt;/strong&gt; as in super aligned and the SBC area is called &lt;strong&gt;sua&lt;/strong&gt; as in super un-aligned.</source>
          <target state="translated">MBC 영역은 수퍼 정렬에서와 같이 &lt;strong&gt;sa&lt;/strong&gt; 라고 하며 SBC 영역은 수퍼 비 정렬에서와 같이 &lt;strong&gt;sua&lt;/strong&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="6e65c3cb49c60d682bd3249d0c0dd54ec5a5739f" translate="yes" xml:space="preserve">
          <source>The MD5 Message-Digest Algorithm is &lt;strong&gt;not&lt;/strong&gt; considered safe for code-signing or software-integrity purposes.</source>
          <target state="translated">MD5 메시지 다이제스트 알고리즘은 코드 서명 또는 소프트웨어 무결성 목적으로 안전한 것으로 간주 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f776c349863aa954c934ed6333465e82a978b325" translate="yes" xml:space="preserve">
          <source>The MFA alternative makes it possible for Megaco to start and supervise a scanner written by the user (see &lt;code&gt;supervisor:start_child&lt;/code&gt; for an explanation of the parameters).</source>
          <target state="translated">MFA 대안은 Megaco가 사용자가 작성한 스캐너를 시작하고 감독 할 수있게합니다 ( 매개 변수에 대한 설명 은 &lt;code&gt;supervisor:start_child&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1def19a97ae2b0656b00af132fb7f372cb973f9f" translate="yes" xml:space="preserve">
          <source>The MG may explicitly invoke megaco:connect/4 and use a provisioned MID of the MGC as the RemoteMid.</source>
          <target state="translated">MG는 명시 적으로 megaco : connect / 4를 호출하고 MGC의 프로비저닝 된 MID를 RemoteMid로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9b9106067cc9059d7c61d3ebb7b2686b953f307" translate="yes" xml:space="preserve">
          <source>The MG may explicitly invoke megaco:connect/4 with the atom 'preliminary_mid' as a temporary MID of the MGC, send an intial message, the Service Change Request, to the MGC and then wait for an initial message, the Service Change Reply. When the reply arrives, the Megaco application will pick the MID of the MGC from the message header and automatically upgrade the connection to be a &quot;normal&quot; connection. By using this method of establishing the connection, the callback function UserMod:handle_connect/2 to be invoked twice. First with a ConnHandle with the remote_mid-field set to preliminary_mid, and then when the connection upgrade is done with the remote_mid-field set to the actual MID of the MGC.</source>
          <target state="translated">MG는 MGC의 임시 MID로서 원자 'preliminary_mid'와 함께 megaco : connect / 4를 명시 적으로 호출하고 초기 메시지 인 서비스 변경 요청을 MGC에 보낸 다음 초기 메시지 인 서비스 변경 응답을 기다릴 수 있습니다. 응답이 도착하면 Megaco 애플리케이션은 메시지 헤더에서 MGC의 MID를 선택하고 연결을 &quot;정상&quot;연결로 자동 업그레이드합니다. 이 연결 설정 방법을 사용하면 콜백 함수 UserMod : handle_connect / 2가 두 번 호출됩니다. 먼저 remote_mid-field가 preliminary_mid로 설정된 ConnHandle을 사용한 다음, remote_mid-field가 MGC의 실제 MID로 설정된 상태에서 연결 업그레이드가 완료된 경우.</target>
        </trans-unit>
        <trans-unit id="aea17cec43c433cc7d5df78c11e5155adf50c978" translate="yes" xml:space="preserve">
          <source>The MIB compiler can be invoked from the OS command line by using the command &lt;code&gt;erlc&lt;/code&gt;. &lt;code&gt;erlc&lt;/code&gt; recognizes the extension &lt;code&gt;.mib&lt;/code&gt;, and invokes the SNMP MIB compiler for files with that extension. The options &lt;code&gt;db&lt;/code&gt;, &lt;code&gt;group_check&lt;/code&gt;, &lt;code&gt;deprecated&lt;/code&gt;, &lt;code&gt;description&lt;/code&gt;, &lt;code&gt;verbosity&lt;/code&gt;, &lt;code&gt;imports&lt;/code&gt; and &lt;code&gt;module_identity&lt;/code&gt; have to be specified to &lt;code&gt;erlc&lt;/code&gt; using the syntax &lt;code&gt;+term&lt;/code&gt;. See &lt;code&gt;erlc(1)&lt;/code&gt; for details.</source>
          <target state="translated">&lt;code&gt;erlc&lt;/code&gt; 명령을 사용하여 OS 명령 행에서 MIB 컴파일러를 호출 할 수 있습니다 . &lt;code&gt;erlc&lt;/code&gt; 는 확장자 &lt;code&gt;.mib&lt;/code&gt; 를 인식하고 해당 확장자를 가진 파일에 대한 SNMP MIB 컴파일러를 호출합니다. 옵션 &lt;code&gt;db&lt;/code&gt; , &lt;code&gt;group_check&lt;/code&gt; , &lt;code&gt;deprecated&lt;/code&gt; , &lt;code&gt;description&lt;/code&gt; , &lt;code&gt;verbosity&lt;/code&gt; , &lt;code&gt;imports&lt;/code&gt; 및 &lt;code&gt;module_identity&lt;/code&gt; 는 구문 &lt;code&gt;+term&lt;/code&gt; 을 사용하여 &lt;code&gt;erlc&lt;/code&gt; 로 지정해야 합니다 . 자세한 내용은 &lt;code&gt;erlc(1)&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f4f52d6224012981f65b2f6681c14c8ab8b0bbf8" translate="yes" xml:space="preserve">
          <source>The MIB compiler is started with a call to &lt;code&gt;snmpc:compile(&amp;lt;mibname&amp;gt;).&lt;/code&gt; For example:</source>
          <target state="translated">&lt;code&gt;snmpc:compile(&amp;lt;mibname&amp;gt;).&lt;/code&gt; 호출하여 MIB 컴파일러를 시작 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="edd06159b7a6aba946136da4c7e4c2496fb5f976" translate="yes" xml:space="preserve">
          <source>The MIB compiler understands both SMIv1 and SMIv2 MIBs. It uses the &lt;code&gt;MODULE-IDENTITY&lt;/code&gt; statement to determine if the MIB is version 1 or 2.</source>
          <target state="translated">MIB 컴파일러는 SMIv1 및 SMIv2 MIB를 모두 이해합니다. 그것은 사용 &lt;code&gt;MODULE-IDENTITY&lt;/code&gt; 의 은 MIB 버전 1 또는 2 있는지 확인하기 위해 문을.</target>
        </trans-unit>
        <trans-unit id="f45016e5e003d17ae323b899458860dc734f4ec3" translate="yes" xml:space="preserve">
          <source>The MIB compiler understands both SMIv1 and SMIv2 MIBs. It uses the MODULE-IDENTITY statement to determinate if the MIB is written in SMI version 1 or 2.</source>
          <target state="translated">MIB 컴파일러는 SMIv1 및 SMIv2 MIB를 모두 이해합니다. MIB가 SMI 버전 1 또는 2로 작성되었는지 여부를 판별하기 위해 MODULE-IDENTITY 문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cd9d36a4d02e1cba5060187b622d24d58daaa77e" translate="yes" xml:space="preserve">
          <source>The MIB definition for the table looks as follows:</source>
          <target state="translated">테이블의 MIB 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3670a31f68beb5c49cf1fc0895f0360e583892d6" translate="yes" xml:space="preserve">
          <source>The MIB is specified in an adapted subset of the Abstract Syntax Notation One (ASN.1) language. This adapted subset is called the Structure of Management Information (SMI).</source>
          <target state="translated">MIB는 ASN.1 (Abstract Syntax Notation One) 언어의 적응 된 서브 세트로 지정됩니다. 이러한 적응 된 부분 집합을 SMI (Structure of Management Information)라고합니다.</target>
        </trans-unit>
        <trans-unit id="ddf38993bb21f6943082354919313abcba92be9e" translate="yes" xml:space="preserve">
          <source>The MIB must be written as a text file in SMIv1 or SMIv2 using an ASN.1 notation before it will be compiled. This text file must have the same name as the MIB, but with the suffix &lt;code&gt;.mib&lt;/code&gt;. This is necessary for handling the &lt;code&gt;IMPORT&lt;/code&gt; statement.</source>
          <target state="translated">MIB는 컴파일되기 전에 ASN.1 표기법을 사용하여 SMIv1 또는 SMIv2에서 텍스트 파일로 작성되어야합니다. 이 텍스트 파일은 MIB와 이름이 동일하지만 접미 부가 &lt;code&gt;.mib&lt;/code&gt; 여야합니다 . &lt;code&gt;IMPORT&lt;/code&gt; 문 을 처리하는 데 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="28b5820bae2b823215328a884121f24cdebd6ac9" translate="yes" xml:space="preserve">
          <source>The MIB table shown in the previous section can be compiled as follows:</source>
          <target state="translated">이전 섹션에 표시된 MIB 테이블은 다음과 같이 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ec9b6855efdcd50624fb2152240f9d6cfd37b82" translate="yes" xml:space="preserve">
          <source>The MIB used in this example is called EX1-MIB. It contains two objects, a variable with a name and a table with friends.</source>
          <target state="translated">이 예에서 사용 된 MIB를 EX1-MIB라고합니다. 여기에는 이름이있는 변수와 친구가있는 테이블이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2036f385fe7aec6b74107075c06d9fb946e725a" translate="yes" xml:space="preserve">
          <source>The Makefile rule generated by this option looks as follows:</source>
          <target state="translated">이 옵션으로 생성 된 Makefile 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b70e5f8f89b4686cb29a4a908b91ac8e282aa8a9" translate="yes" xml:space="preserve">
          <source>The Manager sends a request to the Agent.</source>
          <target state="translated">Manager는 요청을 에이전트로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="46da3a78459a2791fe81dd4c8585eaa2e4cc0ded" translate="yes" xml:space="preserve">
          <source>The Master Agent decodes the incoming UDP packet.</source>
          <target state="translated">마스터 에이전트는 들어오는 UDP 패킷을 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="373ff796c178ffe0a9fc192a5614c9c2aa28127a" translate="yes" xml:space="preserve">
          <source>The Master Agent determines which items in the request that should be processed here and which items should be forwarded to its subagent.</source>
          <target state="translated">마스터 에이전트는 요청에서 처리해야 할 항목과 하위 에이전트로 전달할 항목을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="efae611f18882de954fb6f64727d8f6c45904beb" translate="yes" xml:space="preserve">
          <source>The Megaco client (user) starts the flex scanner (load the driver).</source>
          <target state="translated">Megaco 클라이언트 (사용자)가 플렉스 스캐너를 시작합니다 (드라이버로드).</target>
        </trans-unit>
        <trans-unit id="74b78735e0be983743300743d7f123f781d14b1d" translate="yes" xml:space="preserve">
          <source>The Megaco mib is as of yet not standardized and our implementation is based on &lt;strong&gt;draft-ietf-megaco-mib-04.txt&lt;/strong&gt;. Almost all of the mib cannot easily be implemented by the megaco application. Instead these things should be implemented by a user (of the megaco application).</source>
          <target state="translated">Megaco mib는 아직 표준화되지 않았으며 구현은 &lt;strong&gt;draft-ietf-megaco-mib-04.txt&lt;/strong&gt; 기반입니다 . 거의 모든 mib는 megaco 응용 프로그램으로 쉽게 구현할 수 없습니다. 대신 이러한 것들은 megaco 응용 프로그램의 사용자가 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="69ce7f3a78e528729b8eeea0590643ad39f48cc1" translate="yes" xml:space="preserve">
          <source>The Megaco/H.248 application contains implementations for the two protocols specified by the Megaco/H.248 standard; UDP, see &lt;code&gt;&lt;a href=&quot;megaco_udp&quot;&gt;megaco_udp&lt;/a&gt;&lt;/code&gt;, and TCP/TPKT, see &lt;code&gt;&lt;a href=&quot;megaco_tcp&quot;&gt;megaco_tcp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Megaco / H.248 애플리케이션에는 Megaco / H.248 표준에 지정된 두 프로토콜에 대한 구현이 포함되어 있습니다. UDP, &lt;code&gt;&lt;a href=&quot;megaco_udp&quot;&gt;megaco_udp&lt;/a&gt;&lt;/code&gt; 및 TCP / TPKT, &lt;code&gt;&lt;a href=&quot;megaco_tcp&quot;&gt;megaco_tcp&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aad987e822802dc01bf9dc22e5bb8ea6068aa667" translate="yes" xml:space="preserve">
          <source>The Megaco/H.248 standard defines both a plain text encoding and a binary encoding (ASN.1 BER) and we have implemented encoders and decoders for both. We do in fact supply five different encoding/decoding modules.</source>
          <target state="translated">Megaco / H.248 표준은 일반 텍스트 인코딩과 이진 인코딩 (ASN.1 BER)을 모두 정의하며 두 가지 모두에 대해 인코더와 디코더를 구현했습니다. 우리는 실제로 5 개의 다른 인코딩 / 디코딩 모듈을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="aa06303bf449e60941f0fbd6f5db8a0257dfe140" translate="yes" xml:space="preserve">
          <source>The Megaco/H.248 standard defines both a plain text encoding and a binary encoding (ASN.1 BER) and we have implemented encoders and decoders for both. We do supply a bunch of different encoding/decoding modules and the user may in fact implement their own (like our erl_dist module). Using a non-standard encoding format has its obvious drawbacks, but may be useful in some configurations.</source>
          <target state="translated">Megaco / H.248 표준은 일반 텍스트 인코딩과 이진 인코딩 (ASN.1 BER)을 모두 정의하며 두 가지 모두에 대해 인코더와 디코더를 구현했습니다. 우리는 다양한 인코딩 / 디코딩 모듈을 제공하며 사용자는 실제로 우리의 erl_dist 모듈과 같이 자체적으로 구현할 수 있습니다. 비표준 인코딩 형식을 사용하면 단점이 있지만 일부 구성에서는 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e6da9c94911e5ddf6ca86f3b535349fffeec5ca" translate="yes" xml:space="preserve">
          <source>The Metadata field exists to allow languages, tools and libraries to add custom information to each entry. This EEP documents the following metadata keys:</source>
          <target state="translated">메타 데이터 필드는 언어, 도구 및 라이브러리가 각 항목에 사용자 정의 정보를 추가 할 수 있도록합니다. 이 EEP는 다음 메타 데이터 키를 문서화합니다.</target>
        </trans-unit>
        <trans-unit id="1180df526f481dbe5f0436fa1406c56c4711af67" translate="yes" xml:space="preserve">
          <source>The Mnesia DBMS can be used for storing data of SNMP tables. This means that an SNMP table can be implemented as a Mnesia table, and that a Mnesia table can be made visible via SNMP. This mapping is largely automated.</source>
          <target state="translated">Mnesia DBMS는 SNMP 테이블의 데이터를 저장하는 데 사용할 수 있습니다. 이는 SNMP 테이블이 Mnesia 테이블로 구현 될 수 있고 Mnesia 테이블이 SNMP를 통해 표시 될 수 있음을 의미합니다. 이 매핑은 대부분 자동화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a591b496e3da82473b635cc4b898494993b158a0" translate="yes" xml:space="preserve">
          <source>The Mnesia algorithm for table load can lead to a situation where a table cannot be loaded. This situation occurs when a node is started and Mnesia concludes, or suspects, that another copy of the table was active after this local copy became inactive because of a system crash.</source>
          <target state="translated">테이블로드에 대한 Mnesia 알고리즘은 테이블을로드 할 수없는 상황으로 이어질 수 있습니다. 이 상황은 노드가 시작되고 Mnesia가 시스템 충돌로 인해이 로컬 사본이 비활성화 된 후 테이블의 다른 사본이 활성화되었다고 결론을 내릴 때 또는 의심되는 경우에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5e84c0c6719410c924b39a7531b144a0635ce33f" translate="yes" xml:space="preserve">
          <source>The Mnesia application provides a heavy duty real-time distributed database.</source>
          <target state="translated">Mnesia 애플리케이션은 강력한 실시간 분산 데이터베이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4e31cb2dccdf565dc1ca8c735031043aeea8bc8e" translate="yes" xml:space="preserve">
          <source>The Mnesia directory is to be set to &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">Mnesia 디렉토리는 &lt;code&gt;M&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="87981337ff090edb8a09d20ade88cd56c81fc2fc" translate="yes" xml:space="preserve">
          <source>The Mnesia tables can be manipulated without using transactions. This has some serious disadvantages, but is considerably faster, as the transaction manager is not involved and no locks are set. A dirty operation does, however, guarantee a certain level of consistency, and the dirty operations cannot return garbled records. All dirty operations provide location transparency to the programmer, and a program does not have to be aware of the whereabouts of a certain table to function.</source>
          <target state="translated">Mnesia 테이블은 트랜잭션을 사용하지 않고 조작 할 수 있습니다. 이것은 몇 가지 심각한 단점이 있지만 트랜잭션 관리자가 관여하지 않고 잠금이 설정되지 않았기 때문에 상당히 빠릅니다. 그러나 더티 작업은 일정한 수준의 일관성을 보장하며 더티 작업은 잘못된 레코드를 반환 할 수 없습니다. 모든 더티 오퍼레이션은 프로그래머에게 위치 투명성을 제공하며 프로그램은 특정 테이블의 위치를 ​​인식 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="12555ca4fb4e5c73fcfb7a6b579630e086477989" translate="yes" xml:space="preserve">
          <source>The Module, Function and/or Arity parts of the tuple may be specified as the atom &lt;code&gt;'_'&lt;/code&gt; which is a &quot;wild-card&quot; matching all modules/functions/arities. Note, if the Module is specified as &lt;code&gt;'_'&lt;/code&gt;, the Function and Arity parts have to be specified as '_' too. The same holds for the Functions relation to the Arity.</source>
          <target state="translated">튜플의 모듈, 기능 및 / 또는 Arity 부분은 모든 모듈 / 기능 / arity와 일치하는 &quot;와일드 카드&quot;인 아톰 &lt;code&gt;'_'&lt;/code&gt; 로 지정할 수 있습니다 . 모듈이 &lt;code&gt;'_'&lt;/code&gt; 로 지정된 경우 기능 및 Arity 부분도 '_'로 지정되어야합니다. Arity와의 기능 관계도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="f0af3d5917bbe134a6abcdbbf9104dc4ecd4c736" translate="yes" xml:space="preserve">
          <source>The Monitor window is the main window of Debugger and displays the following:</source>
          <target state="translated">모니터 창은 디버거의 기본 창이며 다음을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="70b4cea5e362ae717c1192bf6736623910297884" translate="yes" xml:space="preserve">
          <source>The NETCONF client is also compliant with RFC 5277 NETCONF Event Notifications, which defines a mechanism for an asynchronous message notification delivery service for the NETCONF protocol.</source>
          <target state="translated">NETCONF 클라이언트는 RFCON 5277 NETCONF 이벤트 알림도 준수합니다.이 알림은 NETCONF 프로토콜에 대한 비동기 메시지 알림 전달 서비스의 메커니즘을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="99b3461576af86b2830e124486fcb6fbe5704dd5" translate="yes" xml:space="preserve">
          <source>The NETCONF client is compliant with RFC 4741 NETCONF Configuration Protocol and RFC 4742 Using the NETCONF Configuration Protocol over Secure SHell (SSH).</source>
          <target state="translated">NETCONF 클라이언트는 RF (SSH)를 통한 NETCONF 구성 프로토콜을 사용하여 RFC 4741 NETCONF 구성 프로토콜 및 RFC 4742를 준수합니다.</target>
        </trans-unit>
        <trans-unit id="ddf8604513f6b03eececb0b12edf6062d8892eb4" translate="yes" xml:space="preserve">
          <source>The NETCONF server uses &lt;code&gt;error_logger&lt;/code&gt; for logging of NETCONF traffic. A special purpose error handler is implemented in &lt;code&gt;ct_conn_log_h&lt;/code&gt;. To use this error handler, add the &lt;code&gt;cth_conn_log&lt;/code&gt; hook in the test suite, for example:</source>
          <target state="translated">NETCONF 서버는 NETCONF 트래픽 로깅에 &lt;code&gt;error_logger&lt;/code&gt; 를 사용 합니다. 특수 목적 오류 처리기는 &lt;code&gt;ct_conn_log_h&lt;/code&gt; 에 구현됩니다 . 이 오류 핸들러를 사용하려면 테스트 스위트에 &lt;code&gt;cth_conn_log&lt;/code&gt; 후크를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4e761f6142db929d9abebfe00caf12e6df69e08" translate="yes" xml:space="preserve">
          <source>The NEXT_INSTRUCTION is a pre-bound variable that is available in all instructions. It expands to the address of the next instruction.</source>
          <target state="translated">NEXT_INSTRUCTION은 모든 지침에서 사용할 수있는 사전 바인딩 된 변수입니다. 다음 명령어의 주소로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="0ee36acc539fb496464c93f96bb31d20de406968" translate="yes" xml:space="preserve">
          <source>The NEXT_INSTRUCTION pre-bound variable</source>
          <target state="translated">NEXT_INSTRUCTION 사전 바인딩 된 변수</target>
        </trans-unit>
        <trans-unit id="2d107278e1a70d51b4fdd7f40141f0fe34ee6756" translate="yes" xml:space="preserve">
          <source>The NIF library must be explicitly loaded by Erlang code in the same module.</source>
          <target state="translated">NIF 라이브러리는 동일한 모듈의 Erlang 코드에 의해 명시 적으로로드되어야합니다.</target>
        </trans-unit>
        <trans-unit id="41a4ad2b0dc5ffd6f13eaa47aa861d15ed3c8d0c" translate="yes" xml:space="preserve">
          <source>The NIFs of the module are compiled and linked into a shared library. Each NIF is implemented as a normal C function. The macro &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; together with an array of structures defines the names, arity, and function pointers of all the NIFs in the module. The header file &lt;code&gt;erl_nif.h&lt;/code&gt; must be included. As the library is a shared module, not a program, no main function is to be present.</source>
          <target state="translated">모듈의 NIF는 컴파일되어 공유 라이브러리에 링크됩니다. 각 NIF는 일반 C 함수로 구현됩니다. 매크로 &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; 는 배열 구조와 함께 모듈에있는 모든 NIF의 이름, 특성 및 함수 포인터를 정의합니다. 헤더 파일 &lt;code&gt;erl_nif.h&lt;/code&gt; 가 포함되어야합니다. 라이브러리는 프로그램이 아니라 공유 모듈이므로 주요 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="999daf79065332e5e6572460b7e99eb5b72cdc5f" translate="yes" xml:space="preserve">
          <source>The Network Interface (Net If) process delivers SNMP PDUs to a master agent, and receives SNMP PDUs from the master agent. The most common behaviour of a Net if process is that is receives bytes from a network, decodes them into an SNMP PDU, which it sends to a master agent. When the master agent has processed the PDU, it sends a response PDU to the Net if process, which encodes the PDU into bytes and transmits the bytes onto the network.</source>
          <target state="translated">네트워크 인터페이스 (Net If) 프로세스는 SNMP PDU를 마스터 에이전트에 전달하고 마스터 에이전트로부터 SNMP PDU를 수신합니다. Net if 프로세스의 가장 일반적인 동작은 네트워크에서 바이트를 수신하고이를 SNMP PDU로 디코딩하여 마스터 에이전트로 전송하는 것입니다. 마스터 에이전트가 PDU를 처리하면 응답 PDU를 Net if 프로세스로 전송하여 PDU를 바이트로 인코딩하고 바이트를 네트워크로 전송합니다.</target>
        </trans-unit>
        <trans-unit id="36f70502604dd2333d650c0bc04a8729a4f497af" translate="yes" xml:space="preserve">
          <source>The Network Interface (Net If) process delivers SNMP PDUs to the manager server, and receives SNMP PDUs from the manager server. The most common behaviour of a Net if process is that is receives request PDU from the manager server, encodes the PDU into bytes and transmits the bytes onto the network to an agent. When the reply from the agent is received by the Net if process, which it decodes into an SNMP PDU, which it sends to the manager server.</source>
          <target state="translated">네트워크 인터페이스 (Net If) 프로세스는 SNMP PDU를 관리자 서버로 전달하고 관리자 서버에서 SNMP PDU를 수신합니다. Net if 프로세스의 가장 일반적인 동작은 관리자 서버로부터 요청 PDU를 수신하고 PDU를 바이트로 인코딩하고 바이트를 네트워크로 에이전트로 전송하는 것입니다. 에이전트의 응답이 Net if 프로세스에 의해 수신되면 SNMP PDU로 디코딩되어 관리자 서버로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="fd402b6f90d216badbbd85762e2a8ddff6c71c0f" translate="yes" xml:space="preserve">
          <source>The Network Interface (Net if) process delivers SNMP PDUs to a master agent, and receives SNMP PDUs from the master agent. The most common behaviour of a Net if process is that is receives bytes from a network, decodes them into an SNMP PDU, which it sends to a master agent. When the master agent has processed the PDU, it sends a response PDU to the Net if process, which encodes the PDU into bytes and transmits the bytes onto the network.</source>
          <target state="translated">네트워크 인터페이스 (Net if) 프로세스는 SNMP PDU를 마스터 에이전트로 전달하고 마스터 에이전트로부터 SNMP PDU를 수신합니다. 프로세스가 네트워크에서 바이트를 수신하여 SNMP PDU로 디코딩하여 마스터 에이전트로 보내는 경우 Net의 가장 일반적인 동작입니다. 마스터 에이전트가 PDU를 처리하면 PDU를 바이트로 인코딩하고 바이트를 네트워크로 전송하는 응답 if PDU를 Net if 프로세스로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="976e6c5625eb166a7240dd083a2239c03ac8b8ec" translate="yes" xml:space="preserve">
          <source>The Network Interface (Net if) process delivers SNMP PDUs to the manager server, and receives SNMP PDUs from the manager server. The most common behaviour of a Net if process is that is receives request PDU from the manager server, encodes the PDU into bytes and transmits the bytes onto the network to an agent. When the reply from the agent is received by the Net if process, which it decodes into an SNMP PDU, which it sends to the manager server.</source>
          <target state="translated">네트워크 인터페이스 (Net if) 프로세스는 SNMP PDU를 관리자 서버로 전달하고 관리자 서버에서 SNMP PDU를받습니다. 프로세스가 관리자 서버로부터 요청 PDU를 수신하고 PDU를 바이트로 인코딩 한 후 바이트를 네트워크로 에이전트에게 전송하는 것이 가장 일반적인 경우 Net의 동작입니다. Net if 프로세스가 에이전트의 응답을 수신하면 SNMP PDU로 디코딩하여 관리자 서버로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="e3ad1933c4b353741e7d3dd411a4625d945e51b1" translate="yes" xml:space="preserve">
          <source>The OAM components, and some other OTP applications, define SNMP MIBs. These MIBs are written in SNMPv2 SMI syntax, as defined in RFC 1902. For convenience we also deliver the SNMPv1 SMI equivalent. All MIBs are designed to be v1/v2 compatible, that is, the v2 MIBs do not use any construct not available in v1.</source>
          <target state="translated">OAM 구성 요소 및 일부 다른 OTP 응용 프로그램은 SNMP MIB를 정의합니다. 이러한 MIB는 RFC 1902에 정의 된대로 SNMPv2 SMI 구문으로 작성되었습니다. 편의를 위해 SNMPv1 SMI도 제공합니다. 모든 MIB는 v1 / v2와 호환되도록 설계되었습니다. 즉, v2 MIB는 v1에서 사용할 수없는 구성을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a0dd4d53e9a9b356b53c2117149daa068221b0f" translate="yes" xml:space="preserve">
          <source>The OPERAND_POSITION() macro</source>
          <target state="translated">OPERAND_POSITION () 매크로</target>
        </trans-unit>
        <trans-unit id="dfa71a1f0f4b6ee0f7da7bee6b28148c4530dbc7" translate="yes" xml:space="preserve">
          <source>The OS failed to load the NIF library.</source>
          <target state="translated">OS가 NIF 라이브러리를로드하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="0c8abadcc360635740ed383e0bd4f397be705277" translate="yes" xml:space="preserve">
          <source>The OTP SSH app can be configurated by a large amount of</source>
          <target state="translated">OTP SSH 앱은 많은 양으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c43c2d0328ac7bd67f0bc31e296a2b1639ba6e7" translate="yes" xml:space="preserve">
          <source>The OTP mibs are stored in the &lt;code&gt;$OTP_ROOT/lib/otp_mibs/mibs/&lt;/code&gt; directory. They are defined in SNMPv2 SMI syntax. An SNMPv1 version of the mib is delivered in the &lt;code&gt;mibs/v1&lt;/code&gt; directory. The compiled MIB is located under &lt;code&gt;priv/mibs&lt;/code&gt;, and the generated &lt;code&gt;.hrl&lt;/code&gt; file under the &lt;code&gt;include&lt;/code&gt; directory. To compile a MIB that IMPORTS a MIB in the OTP_Mibs application, give the option &lt;code&gt;{il, [&quot;otp_mibs/priv/mibs&quot;]}&lt;/code&gt; to the MIB compiler.</source>
          <target state="translated">OTP &lt;code&gt;$OTP_ROOT/lib/otp_mibs/mibs/&lt;/code&gt; 은 $ OTP_ROOT / lib / otp_mibs / mibs / 디렉토리에 저장됩니다. 이들은 SNMPv2 SMI 구문으로 정의됩니다. mib의 SNMPv1 버전은 &lt;code&gt;mibs/v1&lt;/code&gt; 디렉토리에 제공됩니다. 컴파일 된 MIB는 &lt;code&gt;priv/mibs&lt;/code&gt; 아래에 &lt;code&gt;include&lt;/code&gt; 생성 된 &lt;code&gt;.hrl&lt;/code&gt; 파일은 include 디렉토리 아래에 있습니다 . OTP_Mibs 애플리케이션에서 MIB를 가져 오는 MIB를 컴파일하려면 옵션 &lt;code&gt;{il, [&quot;otp_mibs/priv/mibs&quot;]}&lt;/code&gt; 을 MIB 컴파일러에 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="ef0289a2a348b65c119233c8ade03f223f5c8802" translate="yes" xml:space="preserve">
          <source>The OTP release that the currently executing ERTS application is part of, as an integer. For details, see &lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt;. This macro was introduced in OTP release 21.</source>
          <target state="translated">현재 실행중인 ERTS 애플리케이션의 일부인 OTP 릴리스는 정수입니다. 자세한 내용은 &lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt; 참조하십시오 . 이 매크로는 OTP 릴리스 21에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="16e1639b18798e91125ecf1f057060589779b23c" translate="yes" xml:space="preserve">
          <source>The OTP-MIB mib represents information about Erlang nodes such as node name, number of running processes, virtual machine version etc. If the MIB should be used in a system, it should be loaded into an SNMP agent by using the API function &lt;code&gt;otp_mib:load/1&lt;/code&gt;.</source>
          <target state="translated">OTP-MIB mib는 노드 이름, 실행중인 프로세스 수, 가상 머신 버전 등과 같은 Erlang 노드에 대한 정보를 나타냅니다. MIB를 시스템에서 사용해야하는 경우 API 기능 &lt;code&gt;otp_mib:load/1&lt;/code&gt; 사용하여 SNMP 에이전트에로드해야합니다 . 로드 / 1 .</target>
        </trans-unit>
        <trans-unit id="1d079c6127c093fd0bf885dc8ec3e524eee2389b" translate="yes" xml:space="preserve">
          <source>The OTP-REG mib defines the unique OTP subtree of object identifiers under the Ericsson subtree. Under the OTP subtree several object identifiers are defined. This module is typically included by OTP applications defining their own mibs, or ASN.1 modules in general, that require unique object identifiers under the OTP subtree.</source>
          <target state="translated">OTP-REG mib는 Ericsson 하위 트리 아래에서 객체 식별자의 고유 한 OTP 하위 트리를 정의합니다. OTP 하위 트리 아래에 여러 개체 식별자가 정의되어 있습니다. 이 모듈은 일반적으로 OTP 하위 트리 아래에 고유 한 객체 식별자가 필요한 자체 MIB 또는 일반적으로 ASN.1 모듈을 정의하는 OTP 응용 프로그램에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7e4e2e6abc0df4b67e259520ad92410685d1db8d" translate="yes" xml:space="preserve">
          <source>The OTP-SNMPEA-MIB was used in earlier versions of the agent, before standard MIBs existed for access control, MIB views, and trap target specification. All objects in this MIB are now obsolete.</source>
          <target state="translated">OTP-SNMPEA-MIB는 표준 MIB가 액세스 제어, MIB보기 및 트랩 대상 스펙을 위해 존재하기 전에 에이전트의 이전 버전에서 사용되었습니다. 이 MIB의 모든 객체는 이제 폐기되었습니다.</target>
        </trans-unit>
        <trans-unit id="dfdf456ec73d4195574c470386dbc5ef95b5e4be" translate="yes" xml:space="preserve">
          <source>The OTP-TC mib provides the textual convention datatype &lt;code&gt;OwnerString&lt;/code&gt;.</source>
          <target state="translated">OTP-TC mib는 텍스트 규칙 데이터 유형 &lt;code&gt;OwnerString&lt;/code&gt; 을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="bdfd28142322083a6af658ff0e91ac0a22fe94e4" translate="yes" xml:space="preserve">
          <source>The OTP/SSH application first calls this function in the callback module, and then the old &lt;code&gt;Module:add_host_key/3&lt;/code&gt; for compatibilty.</source>
          <target state="translated">OTP / SSH 애플리케이션은 먼저 콜백 모듈에서이 함수를 호출 한 다음 호환성 을 위해 이전 &lt;code&gt;Module:add_host_key/3&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="22c83f8d2349d1be9c18b485bc1cd6600dd20f64" translate="yes" xml:space="preserve">
          <source>The OTP/SSH application first calls this function in the callback module, and then the old &lt;code&gt;Module:is_host_key/4&lt;/code&gt; for compatibilty.</source>
          <target state="translated">OTP / SSH 애플리케이션은 먼저 콜백 모듈에서이 함수를 호출 한 다음 호환성 을 위해 이전 &lt;code&gt;Module:is_host_key/4&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="370c0fa4230350b45a2bed8b159298418299327c" translate="yes" xml:space="preserve">
          <source>The Observer application is a container including the following tools for tracing and investigation of distributed systems:</source>
          <target state="translated">옵저버 애플리케이션은 분산 시스템의 추적 및 조사를위한 다음 도구를 포함하는 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="e53532ab978b0a1e5f72db0836d60dcb2627de7d" translate="yes" xml:space="preserve">
          <source>The Observer application is available on the trace control node.</source>
          <target state="translated">관찰자 애플리케이션은 추적 제어 노드에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="acca74abfba6c1293f4de6924079a0d77446f3db" translate="yes" xml:space="preserve">
          <source>The Observer application might not always be available on the node to be traced (in the following called the &quot;traced node&quot;). However, Trace Tool Builder can still be run from another node (in the following called the &quot;trace control node&quot;) as long as the following is fulfilled:</source>
          <target state="translated">추적 할 노드에서 관찰자 응용 프로그램을 항상 사용할 수있는 것은 아닙니다 (이하 &quot;추적 노드&quot;라고 함). 그러나 다음을 충족하는 한 추적 도구 작성기를 다른 노드 (이하 &quot;추적 제어 노드&quot;)에서 계속 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40509725b1b94ac04bace7fdcf93e38e06d1990b" translate="yes" xml:space="preserve">
          <source>The Operation and Maintenance (OAM) support in OTP consists of a generic model for management subsystems in OTP, and some components to be used in these subsystems. This section describes the model.</source>
          <target state="translated">OTP의 OAM (Operation and Maintenance) 지원은 OTP의 관리 서브 시스템 및이 서브 시스템에서 사용되는 일부 구성 요소에 대한 일반 모델로 구성됩니다. 이 섹션에서는 모델에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="808ca5db0eed6b5828cf7aea959f1c6d4f421b35" translate="yes" xml:space="preserve">
          <source>The P flag has been deprecated by RFC 6733.</source>
          <target state="translated">P 플래그는 RFC 6733에서 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="521a731b4b96b784ec12d6942621ae176f880a6a" translate="yes" xml:space="preserve">
          <source>The PCRE library sets a limit on how many times the internal match function can be called. Defaults to 10,000,000 in the library compiled for Erlang. If &lt;code&gt;{error, match_limit}&lt;/code&gt; is returned, the execution of the regular expression has reached this limit. This is normally to be regarded as a &lt;code&gt;nomatch&lt;/code&gt;, which is the default return value when this occurs, but by specifying &lt;code&gt;report_errors&lt;/code&gt;, you are informed when the match fails because of too many internal calls.</source>
          <target state="translated">PCRE 라이브러리는 내부 일치 함수를 호출 할 수있는 횟수를 제한합니다. Erlang 용으로 컴파일 된 라이브러리에서 기본값은 10,000,000입니다. 경우 &lt;code&gt;{error, match_limit}&lt;/code&gt; 반환되고, 정규 표현식의 실행이 한계에 도달했습니다. 이것은 일반적으로 &lt;code&gt;nomatch&lt;/code&gt; 로 간주되며, 이것이 발생할 때의 기본 반환 값이지만 &lt;code&gt;report_errors&lt;/code&gt; 를 지정 하면 내부 호출이 너무 많아서 일치가 실패하면 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="315aa4b073a3e51b4182d67ae5a99c3e8dd60122" translate="yes" xml:space="preserve">
          <source>The PCRE-specific options &lt;code&gt;dupnames&lt;/code&gt;, &lt;code&gt;ungreedy&lt;/code&gt;, and &lt;code&gt;extra&lt;/code&gt; can be changed in the same way as the Perl-compatible options by using the characters J, U, and X respectively.</source>
          <target state="translated">PCRE 특정 옵션 &lt;code&gt;dupnames&lt;/code&gt; , &lt;code&gt;ungreedy&lt;/code&gt; 및 &lt;code&gt;extra&lt;/code&gt; 는 각각 J, U 및 X 문자를 사용하여 Perl 호환 옵션과 동일한 방식으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b60700ebcda31fdb446fa71f372ef2af6d7bcce" translate="yes" xml:space="preserve">
          <source>The PLT is built using option &lt;code&gt;--build_plt&lt;/code&gt; to Dialyzer. The following command builds the recommended minimal PLT for Erlang/OTP:</source>
          <target state="translated">PLT는 &lt;code&gt;--build_plt&lt;/code&gt; to Dialyzer 옵션을 사용하여 빌드됩니다 . 다음 명령은 Erlang / OTP에 권장되는 최소 PLT를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="068bb5f6b3073467febaec97d8dca8e259a70b70" translate="yes" xml:space="preserve">
          <source>The PLT is extended to also include the files specified with &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-r&lt;/code&gt;. Use &lt;code&gt;--plt&lt;/code&gt; to specify which PLT to start from, and &lt;code&gt;--output_plt&lt;/code&gt; to specify where to put the PLT. Notice that the analysis possibly can include files from the PLT if they depend on the new files. This option only works for BEAM files.</source>
          <target state="translated">PLT는 &lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-r&lt;/code&gt; 로 지정된 파일도 포함하도록 확장되었습니다 . 사용 &lt;code&gt;--plt&lt;/code&gt; 을 부터 시작하는 PLT 지정하고 &lt;code&gt;--output_plt&lt;/code&gt; 곳 PLT를 넣어하는 지정할 수 있습니다. 새 파일에 의존하는 경우 PLT의 파일이 분석에 포함될 수 있습니다. 이 옵션은 BEAM 파일에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="060b8280a8288371c7c464debf7423fb50d4cb7c" translate="yes" xml:space="preserve">
          <source>The POSIX error codes are mostly come from the OS level socket interface, but this module may generate some appropriate POSIX codes.</source>
          <target state="translated">POSIX 오류 코드는 대부분 OS 레벨 소켓 인터페이스에서 발생하지만이 모듈은 적절한 POSIX 코드를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5ac14853a9b086e8f452912a23bfe90221af508" translate="yes" xml:space="preserve">
          <source>The Perl documentation states that it is probably useful only when combined with (?{}) or (??{}). Those are Perl features that are not present in PCRE.</source>
          <target state="translated">Perl 문서에는 (? {}) 또는 (?? {})와 결합 할 때만 유용 할 수 있다고 명시되어 있습니다. PCRE에는없는 Perl 기능입니다.</target>
        </trans-unit>
        <trans-unit id="7305fc245a21d67edcfb1e7040ab9604b3ab8839" translate="yes" xml:space="preserve">
          <source>The Port number of the Host.</source>
          <target state="translated">호스트의 포트 번호입니다.</target>
        </trans-unit>
        <trans-unit id="2d7076aca020633109c1bf0af701628b144f387d" translate="yes" xml:space="preserve">
          <source>The Port number of the host.</source>
          <target state="translated">호스트의 포트 번호입니다.</target>
        </trans-unit>
        <trans-unit id="05f38ed5f44cf6a58fcb55ac9b9ba9cb03970efa" translate="yes" xml:space="preserve">
          <source>The ProtocolVersion version is the version actually encoded in the reply message.</source>
          <target state="translated">ProtocolVersion 버전은 실제로 응답 메시지에 인코딩 된 버전입니다.</target>
        </trans-unit>
        <trans-unit id="544a356532db2cd2759e24c6723c4194d33f11f5" translate="yes" xml:space="preserve">
          <source>The Public Key application deals with public-key related file formats, digital signatures, and &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt; X-509 certificates&lt;/a&gt;&lt;/code&gt;. It is a library application that provides encode/decode, sign/verify, encrypt/decrypt, and similar functionality. It does not read or write files, it expects or returns file contents or partial file contents as binaries.</source>
          <target state="translated">공개 키 응용 프로그램은 공개 키 관련 파일 형식, 디지털 서명 및 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt; X-509 certificates&lt;/a&gt;&lt;/code&gt; 합니다. 인코딩 / 디코딩, 서명 / 확인, 암호화 / 복호화 및 유사한 기능을 제공하는 라이브러리 응용 프로그램입니다. 파일을 읽거나 쓰지 않고 파일 내용 또는 부분 파일 내용을 바이너리로 기대하거나 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7ebdf434e84c8ed49f35713ff4853c27de0d8e82" translate="yes" xml:space="preserve">
          <source>The Public Key decode- and encode-functions try to use the NIFs in the ASN.1 compilers runtime modules, if they can be found. Thus, to have the ASN1 application in the path of your system gives the best performance.</source>
          <target state="translated">공개 키 디코드 및 인코딩 함수는 ASN.1 컴파일러 런타임 모듈에서 NIF를 찾을 수 있으면이를 사용하려고합니다. 따라서 ASN1 응용 프로그램을 시스템 경로에두면 최상의 성능을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efe14f45b872852caa29e8e8cc7c7d6e2482faaf" translate="yes" xml:space="preserve">
          <source>The RFC 3539 watchdog state machine has transitioned into (&lt;code&gt;up&lt;/code&gt;) or out of (&lt;code&gt;down&lt;/code&gt;) the OKAY state. If a &lt;code&gt;#diameter_packet{}&lt;/code&gt; is present in an &lt;code&gt;up&lt;/code&gt; event then there has been a capabilities exchange on a newly established transport connection and the record contains the received CER or CEA.</source>
          <target state="translated">RFC 3539 워치 독 상태 머신이 OKAY 상태 로 전환 ( &lt;code&gt;up&lt;/code&gt; ) 또는 아웃 ( &lt;code&gt;down&lt;/code&gt; )되었습니다. 경우 &lt;code&gt;#diameter_packet{}&lt;/code&gt; 에 존재하는 &lt;code&gt;up&lt;/code&gt; 이벤트 다음 기능 신설 전송 연결 교환 레코드가 수신 CER 또는 CEA가 포함되고있다.</target>
        </trans-unit>
        <trans-unit id="dc64b0c1b30970fb85a8fe63a3336e6b7a09937b" translate="yes" xml:space="preserve">
          <source>The RFC 3539 watchdog timer. An integer value is interpreted as the RFC's TwInit in milliseconds, a jitter of &amp;plusmn; 2 seconds being added at each rearming of the timer to compute the RFC's Tw. An MFA is expected to return the RFC's Tw directly, with jitter applied, allowing the jitter calculation to be performed by the callback.</source>
          <target state="translated">RFC 3539 워치 독 타이머. 정수 값은 RFC의 TwInit (밀리 초)로 해석되며, RFC의 Tw를 계산하기 위해 타이머를 다시 연결할 때마다 &amp;plusmn; 2 초의 지터가 추가됩니다. MFA는 지터가 적용된 상태에서 RFC의 Tw를 직접 반환하므로 콜백에서 지터 계산을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcc9e80a4124e3a42a057c7e5dbba54abf671c72" translate="yes" xml:space="preserve">
          <source>The RFC states that if a certificate defines Reference IDs in a &lt;code&gt;Subject Alternate Name&lt;/code&gt; field, the &lt;code&gt;Subject&lt;/code&gt; field MUST NOT be used for host name checking, even if it contains valid CN names. Therefore only &lt;code&gt;kb.example.org&lt;/code&gt; and &lt;code&gt;https://www.example.org&lt;/code&gt; matches. The match fails both for &lt;code&gt;example.com&lt;/code&gt; and &lt;code&gt;foo.example.com&lt;/code&gt; becuase they are in the &lt;code&gt;Subject&lt;/code&gt; field which is not checked because the &lt;code&gt;Subject Alternate Name&lt;/code&gt; field is present.</source>
          <target state="translated">RFC는 인증서가 &lt;code&gt;Subject Alternate Name&lt;/code&gt; 필드 에 참조 ID를 정의하는 경우 &lt;code&gt;Subject&lt;/code&gt; 필드에 유효한 CN 이름이 포함되어 있어도 호스트 이름 확인에 사용해서는 안된다고 명시하고 있습니다. 따라서 &lt;code&gt;kb.example.org&lt;/code&gt; 및 &lt;code&gt;https://www.example.org&lt;/code&gt; 만 일치합니다. 경기는 모두 실패 &lt;code&gt;example.com&lt;/code&gt; 과 &lt;code&gt;foo.example.com&lt;/code&gt; 을 그들이에 becuase &lt;code&gt;Subject&lt;/code&gt; 때문에 선택하지 않은 필드 &lt;code&gt;Subject Alternate Name&lt;/code&gt; 필드가 존재합니다.</target>
        </trans-unit>
        <trans-unit id="e204403937648bc97742bc221c74abef96cbe2ca" translate="yes" xml:space="preserve">
          <source>The RSA options are experimental.</source>
          <target state="translated">RSA 옵션은 실험적입니다.</target>
        </trans-unit>
        <trans-unit id="8707a6b8a6bbf5e67f47a831acd5b638d6ca82c3" translate="yes" xml:space="preserve">
          <source>The Report Browser (RB) tool is used to browse and format error reports written by the error logger handler &lt;code&gt;log_mf_h&lt;/code&gt; in STDLIB.</source>
          <target state="translated">RB (보고서 브라우저) 도구는 &lt;code&gt;log_mf_h&lt;/code&gt; 의 오류 로거 핸들러 log_mf_h 에 의해 작성된 오류 보고서를 찾아보고 형식화하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e200f59605a43a83406a6a1c3aae57938231fe10" translate="yes" xml:space="preserve">
          <source>The Report Browser Tool</source>
          <target state="translated">보고서 브라우저 도구</target>
        </trans-unit>
        <trans-unit id="4692a2cbc9da1318b1c32468112fcf231936c7b1" translate="yes" xml:space="preserve">
          <source>The Runtime_Tools application is available on both the trace control node and the traced node.</source>
          <target state="translated">Runtime_Tools 애플리케이션은 추적 제어 노드와 추적 노드 모두에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3e6f6adc881738e4e882b8995898a6ee34ae6866" translate="yes" xml:space="preserve">
          <source>The SASL application introduces three types of reports:</source>
          <target state="translated">SASL 응용 프로그램에는 세 가지 유형의 보고서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a66565cf9194d0ac12d200f8341003bfd8ef9840" translate="yes" xml:space="preserve">
          <source>The SASL application provides support for:</source>
          <target state="translated">SASL 애플리케이션은 다음을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d6eac0a2617b8363f4e9ff21a3e5cf89ae6de35c" translate="yes" xml:space="preserve">
          <source>The SASL error logging concept described in this section is deprecated since Erlang/OTP 21.0, when the new &lt;code&gt;logging API&lt;/code&gt; was introduced.</source>
          <target state="translated">이 섹션에 설명 된 SASL 오류 로깅 개념은 새 &lt;code&gt;logging API&lt;/code&gt; 가 도입 되었을 때 Erlang / OTP 21.0부터 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="06f440d4cdd560b9a71ad7c9c8906b6fd30020a0" translate="yes" xml:space="preserve">
          <source>The SAX events that are sent to the user via the callback.</source>
          <target state="translated">콜백을 통해 사용자에게 전송되는 SAX 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="6c62591fcbde98f13b883726ae2b16d26e6fd6e4" translate="yes" xml:space="preserve">
          <source>The SMP emulator (introduced in R11B) takes advantage of a multi-core or multi-CPU computer by running several Erlang scheduler threads (typically, the same as the number of cores). Each scheduler thread schedules Erlang processes in the same way as the Erlang scheduler in the non-SMP emulator.</source>
          <target state="translated">R11B에 도입 된 SMP 에뮬레이터는 여러 Erlang 스케줄러 스레드 (일반적으로 코어 수와 동일)를 실행하여 멀티 코어 또는 멀티 CPU 컴퓨터를 활용합니다. 각 스케줄러 스레드는 비 SMP 에뮬레이터의 Erlang 스케줄러와 동일한 방식으로 Erlang 프로세스를 스케줄합니다.</target>
        </trans-unit>
        <trans-unit id="886a9eb3b2cede92a51b83a792de6e157b89118c" translate="yes" xml:space="preserve">
          <source>The SNMP agent system consists of one Master Agent and optional Sub-agents.</source>
          <target state="translated">SNMP 에이전트 시스템은 하나의 마스터 에이전트와 선택적 하위 에이전트로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7abe087b7edee22ce1a0361250a19799bdfe6153" translate="yes" xml:space="preserve">
          <source>The SNMP agent system consists of one Master Agent and optional sub-agents. The Master Agent can be seen as a special kind of sub-agent. It implements the core agent functionality, UDP packet processing, type checking, access control, trap distribution, and so on. From a user perspective, it is used as an ordinary sub-agent.</source>
          <target state="translated">SNMP 에이전트 시스템은 하나의 마스터 에이전트와 선택적 하위 에이전트로 구성됩니다. 마스터 에이전트는 특수한 종류의 하위 에이전트로 볼 수 있습니다. 핵심 에이전트 기능, UDP 패킷 처리, 유형 검사, 액세스 제어, 트랩 분배 등을 구현합니다. 사용자 관점에서 일반 하위 에이전트로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3265cc19f00c49d8349eff44b143ef435848cde4" translate="yes" xml:space="preserve">
          <source>The SNMP agent toolkit gets input from three different sources:</source>
          <target state="translated">SNMP 에이전트 툴킷은 세 가지 소스에서 입력을받습니다.</target>
        </trans-unit>
        <trans-unit id="516cef785b21f525314dd4769fb5d4a3d8e52b36" translate="yes" xml:space="preserve">
          <source>The SNMP application consists of several entities, of which the agent is one. This function starts the agent entity of the application.</source>
          <target state="translated">SNMP 응용 프로그램은 여러 엔티티로 구성되며 에이전트는 하나입니다. 이 기능은 응용 프로그램의 에이전트 엔티티를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="5a5e7e85ae81bf01406a4eba00ac814b17f5f063" translate="yes" xml:space="preserve">
          <source>The SNMP application consists of several entities, of which the manager is one. This function starts the manager entity of the application.</source>
          <target state="translated">SNMP 응용 프로그램은 여러 엔티티로 구성되며 관리자는 하나입니다. 이 기능은 응용 프로그램의 관리자 엔티티를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1c525a15cd833eca106834a5297df8dd9f3d8e99" translate="yes" xml:space="preserve">
          <source>The SNMP application should be used to start an SNMP agent. Then the API functions below can be used to load/unload the OTP-MIB into/from the agent. The instrumentation of the OTP-MIB uses Mnesia, hence Mnesia must be started prior to loading the OTP-MIB.</source>
          <target state="translated">SNMP 응용 프로그램을 사용하여 SNMP 에이전트를 시작해야합니다. 그런 다음 아래 API 기능을 사용하여 에이전트에 OTP-MIB를로드 / 언로드 할 수 있습니다. OTP-MIB의 계측에는 Mnesia가 사용되므로 OTP-MIB를로드하기 전에 Mnesia를 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="efcaf71f311ac8ed0a4c853a395724aa7b68ecca" translate="yes" xml:space="preserve">
          <source>The SNMP built-in database</source>
          <target state="translated">SNMP 내장 데이터베이스</target>
        </trans-unit>
        <trans-unit id="1f9b4daeb0c18439d5ab9d3febb86ba8cf3f41bc" translate="yes" xml:space="preserve">
          <source>The SNMP development tool provides an environment for rapid agent/manager prototyping and construction. With the following information provided, this tool is used to set up a running multi-lingual SNMP agent/manager:</source>
          <target state="translated">SNMP 개발 도구는 신속한 에이전트 / 관리자 프로토 타이핑 및 구성을위한 환경을 제공합니다. 다음 정보가 제공되면이 도구는 실행중인 다국어 SNMP 에이전트 / 관리자를 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4042139e11f084c5315473eee5bae69ee58a652c" translate="yes" xml:space="preserve">
          <source>The SNMP development toolkit contains the following parts:</source>
          <target state="translated">SNMP 개발 툴킷에는 다음과 같은 부분이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c676c0d7043a8420fb555224be79bdf5a57f0b38" translate="yes" xml:space="preserve">
          <source>The SNMP development toolkit works with all three versions of Standard Internet Management Framework; SNMPv1, SNMPv2 and SNMPv3. They all share the same basic structure and components. And they follow the same architecture.</source>
          <target state="translated">SNMP 개발 툴킷은 세 가지 버전의 Standard Internet Management Framework 모두에서 작동합니다. SNMPv1, SNMPv2 및 SNMPv3. 그것들은 모두 동일한 기본 구조와 구성 요소를 공유합니다. 그리고 그들은 같은 아키텍처를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="4c98874c0a92d51a9659461230a55d2c1a730338" translate="yes" xml:space="preserve">
          <source>The SNMP-COMMUNITY-MIB defines managed objects that is used for coexistence between SNMPv1 and SNMPv2c with SNMPv3. Specifically, it contains objects for mapping between community strings and version-independent SNMP message parameters. In addition, this MIB provides a mechanism for performing source address validation on incoming requests, and for selecting community strings based on target addresses for outgoing notifications.</source>
          <target state="translated">SNMP-COMMUNITY-MIB는 SNMPv1과 SNMPv2c와 SNMPv3의 공존에 사용되는 관리 객체를 정의합니다. 특히, 커뮤니티 문자열과 버전 독립적 SNMP 메시지 매개 변수 사이의 맵핑을위한 오브젝트를 포함합니다. 또한이 MIB는 수신 요청에서 소스 주소 유효성 검증을 수행하고 발신 알림의 대상 주소를 기반으로 커뮤니티 문자열을 선택하기위한 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8668c117c3657ad50b4bac1040aadc9d90558e41" translate="yes" xml:space="preserve">
          <source>The SNMP-FRAMEWORK-MIB and SNMP-MPD-MIB define additional read-only managed objects, which is used in the generic SNMP framework defined in RFC2271 and the generic message processing and dispatching module defined in RFC2272. They are generic in the sense that they are not tied to any specific SNMP version.</source>
          <target state="translated">SNMP-FRAMEWORK-MIB 및 SNMP-MPD-MIB는 RFC2271에 정의 된 일반 SNMP 프레임 워크 및 RFC2272에 정의 된 일반 메시지 처리 및 디스패치 모듈에서 사용되는 추가 읽기 전용 관리 객체를 정의합니다. 특정 SNMP 버전과 연결되어 있지 않다는 점에서 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="45b5b2d3e04821e69bc6b70c4958af997f02dac7" translate="yes" xml:space="preserve">
          <source>The SNMP-TARGET-MIB and SNMP-NOTIFICATION-MIB define managed objects for configuration of notification receivers. They are described in detail in RFC2273. Only a brief description is given here.</source>
          <target state="translated">SNMP-TARGET-MIB 및 SNMP-NOTIFICATION-MIB는 알림 수신자 구성을위한 관리 대상 객체를 정의합니다. RFC2273에 자세히 설명되어 있습니다. 여기에는 간단한 설명 만 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d8ba60d5c67646e6a39ec77ff47623898401ff5" translate="yes" xml:space="preserve">
          <source>The SNMP-USER-BASED-SM-MIB defines managed objects that is used for the User-Based Security Model.</source>
          <target state="translated">SNMP-USER-BASED-SM-MIB는 사용자 기반 보안 모델에 사용되는 관리 대상 개체를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="06a4a7a167128e9dfbd7bbf5787fec903cb71f3c" translate="yes" xml:space="preserve">
          <source>The SNMP-VIEW-BASED-ACM-MIB defines managed objects to control access to the the managed objects for the managers. The View Based Access Control Module (VACM) can be used with any SNMP version. However, if it is used with SNMPv1 or SNMPv2c, the SNMP-COMMUNITY-MIB defines additional objects to map community strings to VACM parameters.</source>
          <target state="translated">SNMP-VIEW-BASED-ACM-MIB는 관리 대상 개체를 정의하여 관리자의 관리 대상 개체에 대한 액세스를 제어합니다. VAM (View Based Access Control Module)은 모든 SNMP 버전과 함께 사용할 수 있습니다. 그러나 SNMPv1 또는 SNMPv2c와 함께 사용되는 경우 SNMP-COMMUNITY-MIB는 커뮤니티 문자열을 VACM 매개 변수에 맵핑하기 위해 추가 오브젝트를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="cf1237e4f8f3b9ace0c3f4bf9ded6dcb4f4634bb" translate="yes" xml:space="preserve">
          <source>The SNMPv3 specifications take a modular approach to SNMP. All modules are separated from each other, and can be extended or replaced individually. Examples of modules are Message definition, Security and Access Control. The main features of SNMPv3 are:</source>
          <target state="translated">SNMPv3 사양은 SNMP에 모듈 방식으로 접근합니다. 모든 모듈은 서로 분리되어 있으며 개별적으로 확장하거나 교체 할 수 있습니다. 모듈의 예로는 메시지 정의, 보안 및 액세스 제어가 있습니다. SNMPv3의 주요 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="49091ee8eff63f8735f82d85f410f0e974abd772" translate="yes" xml:space="preserve">
          <source>The SSH Authentication Protocol is a general-purpose user authentication protocol run over the SSH Transport Layer Protocol. The &lt;code&gt;ssh&lt;/code&gt; application supports user authentication as follows:</source>
          <target state="translated">SSH 인증 프로토콜은 SSH 전송 계층 프로토콜을 통해 실행되는 범용 사용자 인증 프로토콜입니다. &lt;code&gt;ssh&lt;/code&gt; 를 응용 프로그램이 지원하는 사용자 인증은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="7b0b1cec477594d6b882874c149d3fa88e25a3ad" translate="yes" xml:space="preserve">
          <source>The SSH Connection Protocol provides application-support services over the transport pipe, for example, channel multiplexing, flow control, remote program execution, signal propagation, and connection forwarding. Functions for handling the SSH Connection Protocol can be found in the module &lt;code&gt;&lt;a href=&quot;ssh_connection&quot;&gt;ssh_connection&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;ssh&lt;/code&gt;.</source>
          <target state="translated">SSH 연결 프로토콜은 전송 파이프를 통해 응용 프로그램 지원 서비스 (예 : 채널 멀티플렉싱, 흐름 제어, 원격 프로그램 실행, 신호 전파 및 연결 전달)를 제공합니다. SSH 연결 프로토콜을 처리하는 기능 은 &lt;code&gt;ssh&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;ssh_connection&quot;&gt;ssh_connection&lt;/a&gt;&lt;/code&gt; 모듈에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="509aa3afb50ca256dde1f08abd1d170febe86fc9" translate="yes" xml:space="preserve">
          <source>The SSH Transport Protocol is a secure, low-level transport. It provides strong encryption, cryptographic host authentication, and integrity protection. A minimum of Message Authentication Code (MAC) and encryption algorithms are supported. For details, see the &lt;code&gt;&lt;a href=&quot;ssh&quot;&gt;ssh(3)&lt;/a&gt;&lt;/code&gt; manual page in &lt;code&gt;ssh&lt;/code&gt;.</source>
          <target state="translated">SSH 전송 프로토콜은 안전한 저수준 전송입니다. 강력한 암호화, 암호화 호스트 인증 및 무결성 보호 기능을 제공합니다. 최소 MAC (Message Authentication Code) 및 암호화 알고리즘이 지원됩니다. 자세한 내용은 참조 &lt;code&gt;&lt;a href=&quot;ssh&quot;&gt;ssh(3)&lt;/a&gt;&lt;/code&gt; 의 매뉴얼 페이지 &lt;code&gt;ssh&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="744c82a62e8aa358bae0f2bd9bcd0a7ad67c79e1" translate="yes" xml:space="preserve">
          <source>The SSH app's mechanism</source>
          <target state="translated">SSH 앱의 메커니즘</target>
        </trans-unit>
        <trans-unit id="6cafe9a62d6f03f5d4b28fc5be0a442441723104" translate="yes" xml:space="preserve">
          <source>The SSH protocol therefore has a special operation defined -</source>
          <target state="translated">따라서 SSH 프로토콜에는 특별한 작업이 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbf96a70f08f9bc454fcd92af00d3c4835a1fd09" translate="yes" xml:space="preserve">
          <source>The SSH server on UNIX/Linux/etc after a succesful authentication</source>
          <target state="translated">성공적인 인증 후 UNIX / Linux / etc의 SSH 서버</target>
        </trans-unit>
        <trans-unit id="24d33b22db4cc904f86f4d5db9025bf058eaf503" translate="yes" xml:space="preserve">
          <source>The SSL/TLS distribution options can be written into a file that is consulted when the node is started. This file name is then specified with the command line argument &lt;code&gt;-ssl_dist_optfile&lt;/code&gt;.</source>
          <target state="translated">SSL / TLS 분배 옵션은 노드가 시작될 때 참조되는 파일에 기록 될 수 있습니다. 그런 다음이 파일 이름은 명령 행 인수 &lt;code&gt;-ssl_dist_optfile&lt;/code&gt; 로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="a2ffdfd10003f355a79033be2fe1f79f1e9e6854" translate="yes" xml:space="preserve">
          <source>The Solaris (SunOS 5.x) messages are retrieved from the syslog daemon, &lt;code&gt;syslogd&lt;/code&gt;.</source>
          <target state="translated">Solaris (SunOS 5.x) 메시지는 syslog 데몬 인 &lt;code&gt;syslogd&lt;/code&gt; 에서 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="555d2ccf08ac60c2e06799bc61b70df2c88b6a2f" translate="yes" xml:space="preserve">
          <source>The Solaris (SunOS 5.x) messages are retrieved from the syslog-daemon, &lt;code&gt;syslogd&lt;/code&gt;.</source>
          <target state="translated">Solaris (SunOS 5.x) 메시지는 syslog-daemon &lt;code&gt;syslogd&lt;/code&gt; 에서 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="23097a6cf28465a184806bf15474a12dff162d12" translate="yes" xml:space="preserve">
          <source>The Standard Erlang Libraries application, &lt;strong&gt;STDLIB&lt;/strong&gt;, is mandatory in the sense that the minimal system based on Erlang/OTP consists of &lt;strong&gt;STDLIB&lt;/strong&gt; and &lt;strong&gt;Kernel&lt;/strong&gt;.</source>
          <target state="translated">표준 Erlang 라이브러리 어플리케이션 인 &lt;strong&gt;STDLIB&lt;/strong&gt; 는 Erlang / OTP 기반의 최소 시스템이 &lt;strong&gt;STDLIB&lt;/strong&gt; 및 &lt;strong&gt;Kernel&lt;/strong&gt; 로 구성된다는 점에서 필수적입니다 .</target>
        </trans-unit>
        <trans-unit id="5c2a74e481bb59b29d7198edb8d96d6f22f60622" translate="yes" xml:space="preserve">
          <source>The System Under Test (SUT) can consist of one or more target nodes. &lt;code&gt;Common Test&lt;/code&gt; contains a generic test server that, together with other test utilities, is used to perform test case execution. The tests can be started from a GUI, from the OS shell, or from an Erlang shell. &lt;strong&gt;Test suites&lt;/strong&gt; are files (Erlang modules) that contain the &lt;strong&gt;test cases&lt;/strong&gt; (Erlang functions) to be executed. &lt;strong&gt;Support modules&lt;/strong&gt; provide functions that the test cases use to do the tests.</source>
          <target state="translated">SUT (System Under Test)는 하나 이상의 대상 노드로 구성 될 수 있습니다. &lt;code&gt;Common Test&lt;/code&gt; 에는 다른 테스트 유틸리티와 함께 ​​테스트 케이스 실행을 수행하는 일반 테스트 서버가 포함되어 있습니다. 테스트는 GUI, OS 셸 또는 Erlang 셸에서 시작할 수 있습니다. &lt;strong&gt;테스트 스위트&lt;/strong&gt; 는 실행할 &lt;strong&gt;테스트 케이스&lt;/strong&gt; (Erlang 함수)를 포함하는 파일 (Erlang 모듈)입니다 . &lt;strong&gt;지원 모듈&lt;/strong&gt; 은 테스트 사례가 테스트를 수행하는 데 사용하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="eb87875630edf563277392030eee430765ee9a3b" translate="yes" xml:space="preserve">
          <source>The TCP/IP &lt;code&gt;epmd&lt;/code&gt; daemon only keeps track of the &lt;code&gt;Name&lt;/code&gt; (first) part of an Erlang node name. The &lt;code&gt;Host&lt;/code&gt; part (whatever is after the &lt;code&gt;@&lt;/code&gt;) is implicit in the node name where the &lt;code&gt;epmd&lt;/code&gt; daemon was contacted, as is the IP address where the Erlang node can be reached. Consistent and correct TCP naming services are therefore required for an Erlang network to function correctly.</source>
          <target state="translated">TCP / IP &lt;code&gt;epmd&lt;/code&gt; 데몬 은 Erlang 노드 이름 의 &lt;code&gt;Name&lt;/code&gt; (첫 번째) 부분 만 추적 합니다. &lt;code&gt;Host&lt;/code&gt; (후 뭐든 부 &lt;code&gt;@&lt;/code&gt; 는 )이 노드 이름에 내재적 인 &lt;code&gt;epmd&lt;/code&gt; 와 얼랑 노드가 도달 할 수있는 IP 어드레스이고, 데몬 접촉시켰다. 따라서 Erlang 네트워크가 올바르게 작동하려면 일관되고 올바른 TCP 이름 지정 서비스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="058df102c079061352735c937be80bdb1a45818f" translate="yes" xml:space="preserve">
          <source>The TCP/IP distribution uses a handshake that expects a connection-based protocol, that is, the protocol does not include any authentication after the handshake procedure.</source>
          <target state="translated">TCP / IP 배포는 연결 기반 프로토콜을 기대하는 핸드 셰이크를 사용합니다. 즉, 핸드 셰이크 절차 후에 프로토콜에 인증이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6657b1618f0a92c332d5f9a74326d92f2550bf02" translate="yes" xml:space="preserve">
          <source>The TCP_NODELAY option for the telnet socket is disabled (set to &lt;code&gt;false&lt;/code&gt;) per default</source>
          <target state="translated">텔넷 소켓의 TCP_NODELAY 옵션 은 기본적으로 비활성화되어 있습니다 ( &lt;code&gt;false&lt;/code&gt; 로 설정 됨 )</target>
        </trans-unit>
        <trans-unit id="27af0d178d9d81560da76e1bb5028c47f5e6d47a" translate="yes" xml:space="preserve">
          <source>The TFTP port where the daemon listens. Defaults is the standardized number 69. On the server side, it can sometimes make sense to set it to 0, meaning that the daemon just picks a free port (which one is returned by function &lt;code&gt;info/1&lt;/code&gt;).</source>
          <target state="translated">데몬이 수신하는 TFTP 포트입니다. 기본값은 표준화 된 숫자 69입니다. 서버 측에서는 때때로 0으로 설정하는 것이 합리적 일 수 있습니다. 즉, 데몬은 사용 가능한 포트 (기능 &lt;code&gt;info/1&lt;/code&gt; 의해 리턴 된 포트) 만 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="1d58f1eb861475088c58d8cf25b2227f3e09eb03" translate="yes" xml:space="preserve">
          <source>The TLS 1.3 protocol does not provide inherent protection for replay of 0-RTT data but describes mechanisms that SHOULD be implemented by compliant server implementations. The implementation of TLS 1.3 in the SSL application employs all standard methods to prevent potential threats.</source>
          <target state="translated">TLS 1.3 프로토콜은 0-RTT 데이터 재생에 대한 고유 한 보호를 제공하지 않지만 준수 서버 구현에 의해 구현되어야하는 메커니즘을 설명합니다. SSL 애플리케이션의 TLS 1.3 구현은 잠재적 인 위협을 방지하기 위해 모든 표준 방법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="efab23f28e335395659c14ebcb8051f53a7632c5" translate="yes" xml:space="preserve">
          <source>The TLS distribution options can be written into a file that is consulted when the node is started. This file name is then specified with the command line argument &lt;code&gt;-ssl_dist_optfile&lt;/code&gt;.</source>
          <target state="translated">TLS 분배 옵션은 노드가 시작될 때 참조되는 파일에 기록 될 수 있습니다. 이 파일 이름은 명령 줄 인수 &lt;code&gt;-ssl_dist_optfile&lt;/code&gt; 로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="75ccd2ece5259566f90ebb1a8f2c68746b4c7b93" translate="yes" xml:space="preserve">
          <source>The TLS/DTLS handshake protocol and data transfer is run on top of the TLS/DTLS Record Protocol, which uses a keyed-hash Message Authenticity Code (MAC), or a Hash-based MAC (HMAC), to protect the message data integrity. From the TLS RFC: &quot;A Message Authentication Code is a one-way hash computed from a message and some secret data. It is difficult to forge without knowing the secret data. Its purpose is to detect if the message has been altered.&quot;</source>
          <target state="translated">TLS / DTLS 핸드 셰이크 프로토콜 및 데이터 전송은 메시지 데이터 무결성을 보호하기 위해 키 해시 MAC (메시지 인증 코드) 또는 HMAC (해시 기반 MAC)를 사용하는 TLS / DTLS 레코드 프로토콜 위에서 실행됩니다. . TLS RFC에서 : &quot;메시지 인증 코드는 메시지와 일부 비밀 데이터에서 계산 된 단방향 해시입니다. 비밀 데이터를 몰라도 위조하기가 어렵습니다. 메시지의 변경 여부를 감지하는 것입니다.&quot;</target>
        </trans-unit>
        <trans-unit id="ecf685e6c13939907b870d82ee6d0c05ec6e094e" translate="yes" xml:space="preserve">
          <source>The Text Based Trace Facility</source>
          <target state="translated">텍스트 기반 추적 기능</target>
        </trans-unit>
        <trans-unit id="e8fd67f45550805b41375cc84bc114e897e3206a" translate="yes" xml:space="preserve">
          <source>The Trace Tool Builder, &lt;code&gt;ttb&lt;/code&gt;, is a base for building trace tools for distributed systems.</source>
          <target state="translated">추적 도구 작성기 ( &lt;code&gt;ttb&lt;/code&gt; )는 분산 시스템 의 추적 도구를 작성 하기위한 기반입니다.</target>
        </trans-unit>
        <trans-unit id="64d22e790fe528bf704a212bc1e1c0da643a949f" translate="yes" xml:space="preserve">
          <source>The Trace area also displays Back Trace, a summary of the current function calls on the stack.</source>
          <target state="translated">추적 영역에는 스택의 현재 함수 호출에 대한 요약 인 역 추적도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b692df8320088d88e275d851ad60786d4e949a1f" translate="yes" xml:space="preserve">
          <source>The Trace area, which displays a trace output for the process.</source>
          <target state="translated">프로세스의 추적 출력을 표시하는 추적 영역.</target>
        </trans-unit>
        <trans-unit id="1b50d3d2fc04c4411539dfbb6e62512f2efa0130" translate="yes" xml:space="preserve">
          <source>The Trivial File Transfer Protocol or TFTP is a very simple protocol used to transfer files.</source>
          <target state="translated">TFTP (Trivial File Transfer Protocol)는 파일을 전송하는 데 사용되는 매우 간단한 프로토콜입니다.</target>
        </trans-unit>
        <trans-unit id="bf89156ef59750c4bb77ca15635b355ebce24e10" translate="yes" xml:space="preserve">
          <source>The Types are:</source>
          <target state="translated">유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a2becef736618dd80aea9ed87dc6889b0431226f" translate="yes" xml:space="preserve">
          <source>The URI parser tries all possible combinations to interpret the input and fails at the last attempt when it encounters the colon character &lt;code&gt;&quot;:&quot;&lt;/code&gt;. Note, that the inital fault occurs when the parser attempts to interpret the character &lt;code&gt;&quot;&amp;ouml;&quot;&lt;/code&gt; and after a failure back-tracks to the point where it has another possible parsing alternative.</source>
          <target state="translated">URI 구문 분석기는 입력을 해석하기 위해 가능한 모든 조합을 시도하고 콜론 문자 &lt;code&gt;&quot;:&quot;&lt;/code&gt; 를 만나면 마지막 시도에서 실패합니다 . 파서가 문자 &lt;code&gt;&quot;&amp;ouml;&quot;&lt;/code&gt; 를 해석하려고 시도 하고 실패 후 다른 가능한 구문 분석 대안이있는 지점으로 역 추적 할 때 초기 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="2ea556d1f13405f24d60defd343780b8d63e1882" translate="yes" xml:space="preserve">
          <source>The URL the client was on before requesting the URL (if it could not be determined, a minus sign is placed in this field).</source>
          <target state="translated">URL을 요청하기 전에 클라이언트가 있었던 URL (알 수없는 경우이 필드에 빼기 부호가 표시됨)</target>
        </trans-unit>
        <trans-unit id="2cd23bacb56d43630d70d816af467c37a05ab674" translate="yes" xml:space="preserve">
          <source>The UTF-8 variants were introduced in Erlang/OTP R16 and the string returned by &lt;code&gt;ERL_ATOM_PTR(atom)&lt;/code&gt; was not &lt;code&gt;NULL&lt;/code&gt;-terminated on older releases.</source>
          <target state="translated">UTF-8 변형은 Erlang / OTP R16에 도입되었으며 &lt;code&gt;ERL_ATOM_PTR(atom)&lt;/code&gt; 에 의해 리턴 된 문자열 은 이전 릴리스에서 &lt;code&gt;NULL&lt;/code&gt; 로 종료되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="c76d8253124bd005c5e7c3968606bd5eebfe787e" translate="yes" xml:space="preserve">
          <source>The Unexpected I/O Log</source>
          <target state="translated">예기치 않은 I / O 로그</target>
        </trans-unit>
        <trans-unit id="615107616ab4a2ac637d22a3e97ccf0d1ff89d56" translate="yes" xml:space="preserve">
          <source>The Unicode characters need to be processed by the Erlang program, which is why library functions must be able to handle them. In some cases functionality has been added to already existing interfaces (as the &lt;code&gt;string&lt;/code&gt; module now can handle strings with any code points). In some cases new functionality or options have been added (as in the &lt;code&gt;io&lt;/code&gt; module, the file handling, the &lt;code&gt;unicode&lt;/code&gt; module, and the bit syntax). Today most modules in Kernel and STDLIB, as well as the VM are Unicode-aware.</source>
          <target state="translated">유니 코드 문자는 Erlang 프로그램에 의해 처리되어야하므로 라이브러리 함수가이를 처리 할 수 ​​있어야합니다. 경우에 따라 기존 인터페이스에 기능이 추가되었습니다 ( &lt;code&gt;string&lt;/code&gt; 모듈은 이제 모든 코드 포인트로 문자열을 처리 할 수 ​​있음). 경우에 따라 새로운 기능 또는 옵션이 추가되었습니다 ( &lt;code&gt;io&lt;/code&gt; 모듈, 파일 처리, &lt;code&gt;unicode&lt;/code&gt; 모듈 및 비트 구문). 오늘날 커널과 STDLIB의 대부분의 모듈과 VM은 유니 코드를 인식합니다.</target>
        </trans-unit>
        <trans-unit id="d8a64b00a37fa70a62423e7afa68917e078e3bbf" translate="yes" xml:space="preserve">
          <source>The Unicode file naming support was introduced in Erlang/OTP R14B01. A VM operating in Unicode filename translation mode can work with files having names in any language or character set (as long as it is supported by the underlying operating system and file system). The Unicode character list is used to denote filenames or directory names. If the file system content is listed, you also get Unicode lists as return value. The support lies in the Kernel and STDLIB modules, which is why most applications (that do not explicitly require the filenames to be in the ISO Latin-1 range) benefit from the Unicode support without change.</source>
          <target state="translated">유니 코드 파일 명명 지원은 Erlang / OTP R14B01에서 도입되었습니다. 유니 코드 파일 이름 변환 모드로 작동하는 VM은 기본 운영 체제 및 파일 시스템에서 지원하는 한 모든 언어 또는 문자 집합의 이름을 가진 파일을 사용할 수 있습니다. 유니 코드 문자 목록은 파일 이름 또는 디렉토리 이름을 나타내는 데 사용됩니다. 파일 시스템 내용이 나열되면 유니 코드 목록도 반환 값으로 가져옵니다. 지원은 커널 및 STDLIB 모듈에 있으며, 따라서 파일 이름이 ISO Latin-1 범위에 있지 않아도되는 대부분의 응용 프로그램은 변경없이 유니 코드 지원을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e08532eda1cbb1ea06bfac649530b3d005afb89" translate="yes" xml:space="preserve">
          <source>The Unicode string is returned as a Unicode list, which is recognized as such, as the Erlang shell uses the Unicode encoding (and is started with all Unicode characters considered printable). The Unicode list is valid input to function &lt;code&gt;io:put_chars/2&lt;/code&gt;, so data can be output on any Unicode-capable device. If the device is a terminal, characters are output in format &lt;code&gt;\x{&lt;/code&gt;H...&lt;code&gt;}&lt;/code&gt; if encoding is &lt;code&gt;latin1&lt;/code&gt;. Otherwise in UTF-8 (for the non-interactive terminal: &quot;oldshell&quot; or &quot;noshell&quot;) or whatever is suitable to show the character properly (for an interactive terminal: the regular shell).</source>
          <target state="translated">Erlang 쉘이 유니 코드 인코딩을 사용하고 인쇄 가능한 것으로 간주되는 모든 유니 코드 문자로 시작되므로 유니 코드 문자열은 유니 코드 목록으로 리턴됩니다. 유니 코드 목록은 &lt;code&gt;io:put_chars/2&lt;/code&gt; 기능에 유효한 입력 이므로 모든 유니 코드 가능 장치에서 데이터를 출력 할 수 있습니다. 장치가 단말기 인 경우 인코딩이 &lt;code&gt;latin1&lt;/code&gt; 인 경우 문자는 &lt;code&gt;\x{&lt;/code&gt; H ... &lt;code&gt;}&lt;/code&gt; 형식으로 출력됩니다 . 그렇지 않으면 UTF-8 (비 대화식 터미널의 경우 : &quot;oldshell&quot;또는 &quot;noshell&quot;) 또는 문자를 올바르게 표시하기에 적합한 모든 것 (대화식 터미널의 경우 : 일반 쉘).</target>
        </trans-unit>
        <trans-unit id="917f1b5ccc007e44df82f5ad9e8e418e0762f6b0" translate="yes" xml:space="preserve">
          <source>The Unicode support is controlled by both command-line switches, some standard environment variables, and the OTP version you are using. Most options affect mainly how Unicode data is displayed, not the functionality of the APIs in the standard libraries. This means that Erlang programs usually do not need to concern themselves with these options, they are more for the development environment. An Erlang program can be written so that it works well regardless of the type of system or the Unicode options that are in effect.</source>
          <target state="translated">유니 코드 지원은 명령 줄 스위치, 일부 표준 환경 변수 및 사용중인 OTP 버전에 의해 제어됩니다. 대부분의 옵션은 표준 라이브러리의 API 기능이 아니라 주로 유니 코드 데이터가 표시되는 방식에 영향을줍니다. 즉, Erlang 프로그램은 일반적으로 이러한 옵션에 신경 쓸 필요가 없으며 개발 환경에 더 적합합니다. Erlang 프로그램은 시스템의 유형이나 유효한 유니 코드 옵션에 관계없이 잘 작동하도록 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e4f13026f64ec5f7cdd6285c03d5258bacc1cd2" translate="yes" xml:space="preserve">
          <source>The Unicode translation modifier &lt;code&gt;t&lt;/code&gt; specifies how to treat characters outside the Latin-1 range of codepoints, in atoms, strings, and binaries. For example, printing an atom containing a character &amp;gt; 255:</source>
          <target state="translated">유니 코드 변환 수정 자 &lt;code&gt;t&lt;/code&gt; 는 라틴 -1 범위의 코드 포인트 외부, 원자, 문자열 및 이진에서 문자를 처리하는 방법을 지정합니다. 예를 들어,&amp;gt; 255자를 포함하는 원자 인쇄 :</target>
        </trans-unit>
        <trans-unit id="e24a7d795c65b90caaa133aaf71048aad49fb98e" translate="yes" xml:space="preserve">
          <source>The Unicode translation modifier works as with &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="translated">유니 코드 번역 수정자는 &lt;code&gt;s&lt;/code&gt; 와 같이 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="b61b21ce88bdc4622a6b58534472bd97a7d6b6d9" translate="yes" xml:space="preserve">
          <source>The Unix &lt;code&gt;DISPLAY&lt;/code&gt; environment variable is to be set to the display of the master node.</source>
          <target state="translated">Unix &lt;code&gt;DISPLAY&lt;/code&gt; 환경 변수는 마스터 노드의 표시로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7580a1c9657bbaca0bea72d41a48c1a2c9f178ef" translate="yes" xml:space="preserve">
          <source>The VM performs tail call optimization, which does not add new entries to the stacktrace, and also limits stacktraces to a certain depth. Furthermore, compiler options, optimizations and future changes may add or remove stacktrace entries, causing any code that expects the stacktrace to be in a certain order or contain specific items to fail.</source>
          <target state="translated">VM은 꼬리 추적 최적화를 수행하여 스택 추적에 새 항목을 추가하지 않으며 스택 추적을 특정 깊이로 제한합니다. 또한 컴파일러 옵션, 최적화 및 향후 변경으로 인해 스택 추적 항목이 추가되거나 제거되어 스택 추적이 특정 순서로 있거나 특정 항목이 포함되어있을 것으로 예상되는 코드가 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36921b8c054120393af51df837412dde5ebe77c2" translate="yes" xml:space="preserve">
          <source>The VM with SMP support makes quite a heavy use of atomic memory operations. An implementation providing native atomic memory operations is therefore very important when building Erlang/OTP. By default the VM will refuse to build if native atomic memory operations are not available.</source>
          <target state="translated">SMP를 지원하는 VM은 원자 메모리 작업을 상당히 많이 사용합니다. 따라서 Erlang / OTP를 빌드 할 때 기본 원자 메모리 작업을 제공하는 구현이 매우 중요합니다. 기본 원자 메모리 작업을 사용할 수없는 경우 VM은 기본적으로 빌드를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="883c00fb93b6833f40d7fa937a519315da18d85d" translate="yes" xml:space="preserve">
          <source>The View Module window displays the contents of an interpreted module and makes it possible to set breakpoints.</source>
          <target state="translated">모듈보기 창에는 해석 된 모듈의 내용이 표시되며 중단 점을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="818a2a38b6d37966404b0037603dc28865b80d3d" translate="yes" xml:space="preserve">
          <source>The Windows messages are retrieved from the eventlog file.</source>
          <target state="translated">Windows 메시지는 eventlog 파일에서 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="1ef81693a27626a4d31fec58f2301060476cd06b" translate="yes" xml:space="preserve">
          <source>The Windows system is rebooted whenever the emulator stops (a more simple form of watchdog). This can be useful for less critical systems, otherwise use the heart functionality to accomplish this.</source>
          <target state="translated">에뮬레이터가 중지 될 때마다 Windows 시스템이 재부팅됩니다 (보다 간단한 형태의 워치 독). 이것은 덜 중요한 시스템에 유용 할 수 있습니다. 그렇지 않으면 심장 기능을 사용하여이를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="66afd9d96a38a37c4f7f94ff1bd05dfee703afea" translate="yes" xml:space="preserve">
          <source>The XML version shown earlier can also be used, but it is to be explicitly specified that the &lt;code&gt;ct_config_xml&lt;/code&gt; callback module is to be used by &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">앞에서 설명한 XML 버전도 사용할 수 있지만 &lt;code&gt;Common Test&lt;/code&gt; 가 &lt;code&gt;ct_config_xml&lt;/code&gt; 콜백 모듈 을 사용하도록 명시 적으로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="252a4b864e9fb6b863b0c8c232185b5a96bbfa1c" translate="yes" xml:space="preserve">
          <source>The \A, \Z, and \z assertions differ from the traditional circumflex and dollar (described in the next section) in that they only ever match at the very start and end of the subject string, whatever options are set. Thus, they are independent of multiline mode. These three assertions are not affected by options &lt;code&gt;notbol&lt;/code&gt; or &lt;code&gt;noteol&lt;/code&gt;, which affect only the behavior of the circumflex and dollar metacharacters. However, if argument &lt;code&gt;startoffset&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; is non-zero, indicating that matching is to start at a point other than the beginning of the subject, \A can never match. The difference between \Z and \z is that \Z matches before a newline at the end of the string and at the very end, while \z matches only at the end.</source>
          <target state="translated">\ A, \ Z 및 \ z 주장은 옵션 설정에 관계없이 주제 문자열의 맨 처음과 끝에서만 일치한다는 점에서 전통적인 곡절 곡사 및 달러 (다음 섹션에서 설명)와 다릅니다. 따라서 여러 줄 모드와 독립적입니다. 이 세 가지 주장은 곡절 및 달러 메타 문자의 동작에만 영향을주는 &lt;code&gt;notbol&lt;/code&gt; 또는 &lt;code&gt;noteol&lt;/code&gt; 옵션의 영향을받지 않습니다 . 그러나 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 의 인수 &lt;code&gt;startoffset&lt;/code&gt; 이 0이 아닌 경우 일치가 주제의 시작 이외의 지점에서 시작됨을 표시하면 \ A는 절대 일치 할 수 없습니다. \ Z와 \ z의 차이점은 \ Z는 문자열의 끝과 끝에서 개행 이전과 일치하지만 \ z는 끝에서만 일치한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="943d4453f30bb5749d0c52004563365b21bda38a" translate="yes" xml:space="preserve">
          <source>The \C escape sequence</source>
          <target state="translated">\ C 이스케이프 시퀀스</target>
        </trans-unit>
        <trans-unit id="4f34ba1108b5cb6716129944fbf4f4329a0a6235" translate="yes" xml:space="preserve">
          <source>The \C escape sequence is best avoided. However, one way of using it that avoids the problem of malformed UTF characters is to use a lookahead to check the length of the next character, as in the following pattern, which can be used with a UTF-8 string (ignore whitespace and line breaks):</source>
          <target state="translated">\ C 이스케이프 시퀀스는 피하는 것이 가장 좋습니다. 그러나 잘못된 UTF 문자의 문제점을 피하는 그것을 사용하는 한 가지 방법은 다음 패턴에서와 같이 lookahead를 사용하여 다음 문자의 길이를 확인하는 것입니다. 휴식) :</target>
        </trans-unit>
        <trans-unit id="c3ea67e0b67cb019dc5aaa8e95c03b5cb7572754" translate="yes" xml:space="preserve">
          <source>The \G assertion is true only when the current matching position is at the start point of the match, as specified by argument &lt;code&gt;startoffset&lt;/code&gt; of &lt;code&gt;run/3&lt;/code&gt;. It differs from \A when the value of &lt;code&gt;startoffset&lt;/code&gt; is non-zero. By calling &lt;code&gt;run/3&lt;/code&gt; multiple times with appropriate arguments, you can mimic the Perl option &lt;code&gt;/g&lt;/code&gt;, and it is in this kind of implementation where \G can be useful.</source>
          <target state="translated">현재 매칭 위치가 인수로 지정된, 경기의 시작 지점 인 경우에만 \ G의 주장은 사실이다 &lt;code&gt;startoffset&lt;/code&gt; 의 &lt;code&gt;run/3&lt;/code&gt; . &lt;code&gt;startoffset&lt;/code&gt; 값이 0이 아닌 경우 \ A와 다릅니다 . 적절한 인수로 &lt;code&gt;run/3&lt;/code&gt; 을 여러 번 호출 하면 Perl 옵션 &lt;code&gt;/g&lt;/code&gt; 를 모방 할 수 있으며 이는 \ G가 유용 할 수있는 이런 종류의 구현에 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f7f1b350c6833ef257bc14bd5940d6dff8095f3" translate="yes" xml:space="preserve">
          <source>The \Q...\E sequence is recognized both inside and outside character classes. An isolated \E that is not preceded by \Q is ignored. If \Q is not followed by \E later in the pattern, the literal interpretation continues to the end of the pattern (that is, \E is assumed at the end). If the isolated \Q is inside a character class, this causes an error, as the character class is not terminated.</source>
          <target state="translated">\ Q ... \ E 시퀀스는 내부 및 외부 문자 클래스 모두에서 인식됩니다. 앞에 \ Q가없는 격리 된 \ E는 무시됩니다. \ Q 다음에 패턴에서 나중에 \ E가 없으면 리터럴 해석은 패턴의 끝까지 계속됩니다 (즉, \ E는 끝에서 가정 됨). 분리 된 \ Q가 문자 클래스 안에 있으면 문자 클래스가 종료되지 않으므로 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="14658b1c2056da1457d1137feae50fbf03cef97b" translate="yes" xml:space="preserve">
          <source>The \R escape sequence</source>
          <target state="translated">\ R 이스케이프 시퀀스</target>
        </trans-unit>
        <trans-unit id="4253fcd6879a11eec01b435167179d5e15f76711" translate="yes" xml:space="preserve">
          <source>The \X escape matches any number of Unicode characters that form an &quot;extended grapheme cluster&quot;, and treats the sequence as an atomic group (see below). Up to and including release 8.31, PCRE matched an earlier, simpler definition that was equivalent to &lt;code&gt;(?&amp;gt;\PM\pM*)&lt;/code&gt;. That is, it matched a character without the &quot;mark&quot; property, followed by zero or more characters with the &quot;mark&quot; property. Characters with the &quot;mark&quot; property are typically non-spacing accents that affect the preceding character.</source>
          <target state="translated">\ X 이스케이프는 &quot;확장 grapheme 클러스터&quot;를 형성하는 임의의 유니 코드 문자와 일치하며 시퀀스를 원자 그룹으로 취급합니다 (아래 참조). 릴리스 8.31까지 PCRE는 &lt;code&gt;(?&amp;gt;\PM\pM*)&lt;/code&gt; 와 동일한 이전의 더 단순한 정의와 일치했습니다 . 즉, &quot;mark&quot;속성이없는 문자와 &quot;mark&quot;속성이있는 문자가 0 개 이상 일치합니다. &quot;mark&quot;속성을 가진 문자는 일반적으로 앞의 문자에 영향을주는 비 간격 악센트입니다.</target>
        </trans-unit>
        <trans-unit id="fe0ff3b7597c9ca177e61f2b7394c84224900254" translate="yes" xml:space="preserve">
          <source>The \X escape sequence</source>
          <target state="translated">\ X 이스케이프 시퀀스</target>
        </trans-unit>
        <trans-unit id="1a667df5d1564a7cf0ddb2cbecc475bdb5eb483f" translate="yes" xml:space="preserve">
          <source>The \c facility was designed for use with ASCII characters, but with the extension to Unicode it is even less useful than it once was.</source>
          <target state="translated">\ c 기능은 ASCII 문자와 함께 사용하도록 설계되었지만 유니 코드로 확장하면 그 어느 때보 다 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="269d02430fd6e138cda2800d0af71fa652dd1cf5" translate="yes" xml:space="preserve">
          <source>The ability to globally register names is a central concept in the programming of distributed Erlang systems. In this module, the equivalent of the &lt;code&gt;register/2&lt;/code&gt; and &lt;code&gt;whereis/1&lt;/code&gt; BIFs (for local name registration) are provided, but for a network of Erlang nodes. A registered name is an alias for a process identifier (pid). The global name server monitors globally registered pids. If a process terminates, the name is also globally unregistered.</source>
          <target state="translated">전역 적으로 이름을 등록하는 기능은 분산 Erlang 시스템 프로그래밍의 핵심 개념입니다. 이 모듈에서는 Erlang 노드 네트워크를 위해 &lt;code&gt;register/2&lt;/code&gt; 및 &lt;code&gt;whereis/1&lt;/code&gt; BIF (로컬 이름 등록 용)가 제공됩니다. 등록 된 이름은 프로세스 식별자 (pid)의 별칭입니다. 글로벌 이름 서버는 글로벌로 등록 된 pid를 모니터링합니다. 프로세스가 종료되면 이름도 전체적으로 등록 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="2cc8577a293410d9b2b2308f91ef8c7aeb7972a3" translate="yes" xml:space="preserve">
          <source>The ability to have nested transaction with identical semantics as top-level transaction makes it easier to write library functions that manipulate &lt;code&gt;Mnesia&lt;/code&gt; tables.</source>
          <target state="translated">최상위 트랜잭션과 동일한 의미로 중첩 된 트랜잭션을 가질 수 &lt;code&gt;Mnesia&lt;/code&gt; 테이블 을 조작하는 라이브러리 함수를보다 쉽게 ​​작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d3f3d904255147f868f9a9b898334b0ed05f68e" translate="yes" xml:space="preserve">
          <source>The ability to prepare several modules in parallel is not currently used as almost all code loading is serialized by the code_server process. The BIF interface is however prepared for this.</source>
          <target state="translated">거의 모든 코드 로딩이 code_server 프로세스에 의해 직렬화되므로 여러 모듈을 병렬로 준비하는 기능은 현재 사용되지 않습니다. 그러나 BIF 인터페이스는이를 위해 준비되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="89a04008ab968f22c43827dcb1f3ef8218af459a" translate="yes" xml:space="preserve">
          <source>The ability to reconfigure the system without stopping or suspending it.</source>
          <target state="translated">시스템을 중지하거나 일시 중단하지 않고 재구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="129e9c30a42ceaac73e62bd0dcc82cdd40af7c03" translate="yes" xml:space="preserve">
          <source>The above commands give a bit more information than the exact answers, but adequate information when manually searching for answers to these questions.</source>
          <target state="translated">위의 명령은 정확한 답변보다 약간 더 많은 정보를 제공하지만 이러한 질문에 대한 답변을 수동으로 검색 할 때는 적절한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f248f43bea4cac68bcba54c041edea09e4c2df08" translate="yes" xml:space="preserve">
          <source>The above described implementation more or less minimizes the comunication needed before we can increment the global counter. The amount of communication in the system due to the thread progress functionality however also depend on the frequency with which managed threads call &lt;code&gt;erts_thr_progress_update()&lt;/code&gt;. Today each scheduler thread calls &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; more or less each time an Erlang process is scheduled out. One way of further reducing communication due to the thread progress functionality is to only call &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; every second, or third time an Erlang process is scheduled out, or even less frequently than that. However, by doing updates of thread progress less frequently all operations depending on the thread progress functionality will also take a longer time.</source>
          <target state="translated">위에서 설명한 구현은 글로벌 카운터를 증가시키기 전에 필요한 통신을 다소 최소화합니다. 그러나 스레드 진행 기능으로 인한 시스템의 통신량은 관리 스레드가 &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; 호출하는 빈도에 따라 달라집니다 . 오늘날 각 스케줄러 스레드 는 Erlang 프로세스가 예약 될 때마다 &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; 호출 합니다. 스레드 진행 기능으로 인해 통신을 더욱 줄이는 한 가지 방법은 &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; 만 호출하는 것입니다.매초 또는 세 번 Erlang 프로세스가 예정되어 있거나 그보다 더 적은 빈도입니다. 그러나 스레드 진행률 업데이트를 덜 자주 수행하면 스레드 진행률 기능에 따라 모든 작업이 더 오래 걸립니다.</target>
        </trans-unit>
        <trans-unit id="eaa2af3e34f5b33ee6c40efa2f89e63edd11857b" translate="yes" xml:space="preserve">
          <source>The above describes how it works if the configuration parameter &lt;code&gt;&lt;a href=&quot;#memsup_improved_system_memory_data&quot;&gt;memsup_improved_system_memory_data&lt;/a&gt;&lt;/code&gt; has been set to &lt;code&gt;false&lt;/code&gt; which currently also is the default behavior. If the configuration parameter is set to &lt;code&gt;true&lt;/code&gt; the behavior is slightly changed:</source>
          <target state="translated">위는 구성 매개 변수 &lt;code&gt;&lt;a href=&quot;#memsup_improved_system_memory_data&quot;&gt;memsup_improved_system_memory_data&lt;/a&gt;&lt;/code&gt; 가 현재 기본 동작이기도 한 &lt;code&gt;false&lt;/code&gt; 로 설정된 경우 작동 방식을 설명합니다 . 구성 매개 변수가 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 동작이 약간 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="45b0784fdfa3b2b86ccd9506530ebe25156cc75c" translate="yes" xml:space="preserve">
          <source>The above domains are used for logs originating from Erlang/OTP. D1 specifies that the log event comes from Erlang/OTP in general, and D2 indicates that the log event is a so called &lt;code&gt;&lt;a href=&quot;logger_chapter#sasl_reports&quot;&gt;SASL report&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">위의 도메인은 Erlang / OTP에서 생성 된 로그에 사용됩니다. D1은 로그 이벤트가 일반적으로 Erlang / OTP에서 발생하도록 지정하고 D2는 로그 이벤트가 이른바 &lt;code&gt;&lt;a href=&quot;logger_chapter#sasl_reports&quot;&gt;SASL report&lt;/a&gt;&lt;/code&gt; 임을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="4ad528c9654cb6b91e6a15396b85e360c22694a9" translate="yes" xml:space="preserve">
          <source>The above function specification uses multiple occurrences of the same type variable. That provides more type information than the following function specification, where the type variables are missing:</source>
          <target state="translated">위의 함수 스펙은 동일한 유형 변수가 여러 번 사용됩니다. 유형 변수가없는 다음 함수 스펙보다 많은 유형 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6b3999c12af345ea4567453a651d6ad765544220" translate="yes" xml:space="preserve">
          <source>The above line will create a &lt;code&gt;TAGS&lt;/code&gt; file covering all the Erlang source files in the current directory, and in the subdirectories below.</source>
          <target state="translated">위의 행은 현재 디렉토리와 아래의 서브 디렉토리에있는 모든 Erlang 소스 파일을 포함 하는 &lt;code&gt;TAGS&lt;/code&gt; 파일을 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="e341eaf056f6757aa8744bf39e8ccfa82e2460c2" translate="yes" xml:space="preserve">
          <source>The above problem can also be solved as follows:</source>
          <target state="translated">위의 문제는 다음과 같이 해결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="492aee09cf585dc36dd1c47f1f73ebd941b86f64" translate="yes" xml:space="preserve">
          <source>The above publications can be found at &lt;code&gt;&lt;a href=&quot;http://www.ietf.org&quot;&gt;IETF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">위의 간행물은 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org&quot;&gt;IETF&lt;/a&gt;&lt;/code&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5dbb531e49f3781328d131d1418c3fc6c34074de" translate="yes" xml:space="preserve">
          <source>The above requirements makes the private task data structure a rather complex data structure. It has a queue of unprocessed tasks, and a busy queue. The busy queue contains blocked tasks corresponding to &lt;code&gt;command&lt;/code&gt; signals, and tasks with dependencies to such tasks. The busy queue is accompanied by a table over blocked tasks based on sender with a references into last task in the busy queue from a specific sender. This since we need check for dependencies when new tasks are processed in the queue of unprocessed tasks. When a new task is processed that needs to be blocked it isn't enqueued at the end of the busy queue, but instead directly after the last task with the same sender. This in order to easily be able to detect when we have tasks that no longer have any dependencies to tasks corresponding to &lt;code&gt;command&lt;/code&gt; signals which should be moved out of the busy queue. When the port executes, it switches between processing tasks from the busy queue, and processing directly from the unprocessed queue based on its busy state. When processing directly from the unprocessed queue it might, of course, have to move a task into the busy queue instead of executing it.</source>
          <target state="translated">위의 요구 사항은 개인 작업 데이터 구조를 다소 복잡한 데이터 구조로 만듭니다. 처리되지 않은 작업 대기열과 바쁜 대기열이 있습니다. 사용 중 대기열에는 &lt;code&gt;command&lt;/code&gt; 신호에 해당하는 차단 된 작업 과 이러한 작업에 종속 된 작업이 포함됩니다. 사용 중 대기열에는 특정 발신자의 사용 중 대기열에있는 마지막 작업에 대한 참조가있는 발신자를 기반으로 차단 된 작업에 대한 테이블이 함께 제공됩니다. 이는 처리되지 않은 작업의 대기열에서 새 작업이 처리 될 때 종속성을 확인해야하기 때문입니다. 차단해야하는 새 작업이 처리되면 사용중인 대기열의 끝에서 대기열에 포함되지 않고 대신 동일한 보낸 사람이있는 마지막 작업 바로 뒤에 추가됩니다. 이는 다음과 같은 작업에 더 이상 종속성이없는 작업이있을 때 쉽게 감지 할 수 있습니다. &lt;code&gt;command&lt;/code&gt; 중인 대기열에서 이동해야하는 명령 신호. 포트가 실행되면 사용 중 대기열의 처리 작업과 사용 중 상태에 따라 처리되지 않은 대기열의 직접 처리간에 전환됩니다. 처리되지 않은 대기열에서 직접 처리 할 때 당연히 작업을 실행하는 대신 사용중인 대기열로 이동해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d1f97ecba7e65750e03299b0da63791177dd464" translate="yes" xml:space="preserve">
          <source>The above return value and output after the call to &lt;code&gt;release_handler:install_release/1&lt;/code&gt; means that the &lt;code&gt;release_handler&lt;/code&gt; has restarted the node by using &lt;code&gt;heart&lt;/code&gt;. This is always done when the upgrade involves a change of the applications ERTS, Kernel, STDLIB, or SASL. For more information, see &lt;code&gt;&lt;a href=&quot;upgrade&quot;&gt; Upgrade when Erlang/OTP has Changed&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;release_handler:install_release/1&lt;/code&gt; 호출 후 위의 반환 값과 출력 은 &lt;code&gt;release_handler&lt;/code&gt; 가 &lt;code&gt;heart&lt;/code&gt; 를 사용하여 노드를 다시 시작 했음을 의미합니다 . 업그레이드에 ERTS, Kernel, STDLIB 또는 SASL 응용 프로그램 변경이 포함 된 경우 항상 수행됩니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;upgrade&quot;&gt; Upgrade when Erlang/OTP has Changed&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="425de3e4a3c3f31918aace8062226e8cca18ed8a" translate="yes" xml:space="preserve">
          <source>The above return value and output after the call to &lt;code&gt;release_handler:install_release/1&lt;/code&gt; means that the &lt;code&gt;release_handler&lt;/code&gt; has restarted the node by using &lt;code&gt;heart&lt;/code&gt;. This is always done when the upgrade involves a change of the applications ERTS, Kernel, STDLIB, or SASL. For more information, see &lt;code&gt;&lt;a href=&quot;upgrade&quot;&gt;Upgrade when Erlang/OTP has Changed&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;release_handler:install_release/1&lt;/code&gt; 에 대한 호출 후 위의 리턴 값 및 출력 은 &lt;code&gt;release_handler&lt;/code&gt; 가 &lt;code&gt;heart&lt;/code&gt; 를 사용하여 노드를 다시 시작 했음을 의미합니다 . 업그레이드에는 응용 프로그램 ERTS, 커널, STDLIB 또는 SASL의 변경이 포함되는 경우 항상 수행됩니다. 자세한 정보 &lt;code&gt;&lt;a href=&quot;upgrade&quot;&gt;Upgrade when Erlang/OTP has Changed&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7341074eb758fc408da665455635aa8abe3e6546" translate="yes" xml:space="preserve">
          <source>The above sequence did only describe adding a new breakpoint. We do basically the same sequence to update the settings of an existing breakpoint except step 2,3 and 6 can be skipped as it has already been done.</source>
          <target state="translated">위의 시퀀스는 새 중단 점 추가 만 설명했습니다. 기본적으로 기존 중단 점의 설정을 업데이트하기 위해 동일한 순서를 수행합니다. 단, 2,3 및 6 단계는 이미 수행되었으므로 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6d29da5725e5abb5aa97c7b81d06a71c4261fa3" translate="yes" xml:space="preserve">
          <source>The above slogan is one of the more common reasons for Erlang to terminate. For unknown reasons the Erlang Run-Time System failed to allocate memory to use. When this happens a crash dump is generated that contains information about the state of the system as it ran out of memory. Use the &lt;code&gt;crashdump_viewer&lt;/code&gt; to get a view of the memory is being used. Look for processes with large heaps or many messages, large ets tables, etc.</source>
          <target state="translated">위의 슬로건은 Erlang이 종료되는 가장 일반적인 이유 중 하나입니다. 알 수없는 이유로 Erlang 런타임 시스템이 사용할 메모리를 할당하지 못했습니다. 이 경우 메모리 부족으로 인한 시스템 상태에 대한 정보가 포함 된 크래시 덤프가 생성됩니다. &lt;code&gt;crashdump_viewer&lt;/code&gt; 를 사용하여 사용 중인 메모리를 확인하십시오. 큰 힙이나 많은 메시지, 큰 ets 테이블 등이있는 프로세스를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="782b35684c4c327f6b3806c4707f7ff71cfb9ed8" translate="yes" xml:space="preserve">
          <source>The above slogan is one of the more common reasons for Erlang to terminate. For unknown reasons the Erlang Run-Time System failed to allocate memory to use. When this happens a crash dump is generated that contains information about the state of the system as it ran out of mmeory. Use the &lt;code&gt;crashdump_viewer&lt;/code&gt; to get a view of the memory is being used. Look for processes with large heaps or many messages, large ets tables, etc.</source>
          <target state="translated">위의 슬로건은 Erlang이 종료하는 가장 일반적인 이유 중 하나입니다. 알 수없는 이유로 Erlang 런타임 시스템이 사용할 메모리를 할당하지 못했습니다. 이러한 상황이 발생하면 시스템 메모리가 부족한 상태에 대한 정보가 포함 된 크래시 덤프가 생성됩니다. &lt;code&gt;crashdump_viewer&lt;/code&gt; 를 사용하여 사용 중인 메모리를 확인하십시오. 큰 힙 또는 많은 메시지, 큰 ets 테이블 등이있는 프로세스를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="a934d4536371eb6354c38319c0a6fa99eadfdfc1" translate="yes" xml:space="preserve">
          <source>The absence of warnings does not mean that there are no remaining errors in the code.</source>
          <target state="translated">경고가 없다고해서 코드에 남아있는 오류가 없음을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="52e22f3960de9276ce93c1885ad7150854270f91" translate="yes" xml:space="preserve">
          <source>The absolute path of directory &lt;code&gt;chat_server/ebin&lt;/code&gt; is here passed to the code server. This is essential because relative paths are stored by the code server as relative, and &lt;code&gt;Common Test&lt;/code&gt; changes the current working directory of ERTS during the test run.</source>
          <target state="translated">&lt;code&gt;chat_server/ebin&lt;/code&gt; 디렉토리의 절대 경로 는 여기서 코드 서버로 전달됩니다. 상대 경로는 코드 서버에 의해 상대 경로로 저장되므로 &lt;code&gt;Common Test&lt;/code&gt; 는 테스트 실행 중에 ERTS의 현재 작업 디렉토리를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="30fdf1cb46294b863f8e4eaed5259c72435c637c" translate="yes" xml:space="preserve">
          <source>The absolute point in time, the timer is set to expire on, must be in the interval &lt;code&gt;[&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt; erlang:system_info(start_time)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_end_time&quot;&gt; erlang:system_info(end_time)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;]&lt;/code&gt;. If a relative time is specified, the &lt;code&gt;Time&lt;/code&gt; value is not allowed to be negative.</source>
          <target state="translated">타이머가 만료되도록 설정되는 절대 시점은 &lt;code&gt;[&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt; erlang:system_info(start_time)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_end_time&quot;&gt; erlang:system_info(end_time)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; 간격에 있어야합니다 . 상대 시간이 지정되면 &lt;code&gt;Time&lt;/code&gt; 값은 음수가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5539aa6980c3b1d4dc664f3e80f8e7768512fe3a" translate="yes" xml:space="preserve">
          <source>The absolute point in time, the timer is set to expire on, must be in the interval &lt;code&gt;[&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt;erlang:system_info(start_time)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_end_time&quot;&gt;erlang:system_info(end_time)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;]&lt;/code&gt;. If a relative time is specified, the &lt;code&gt;Time&lt;/code&gt; value is not allowed to be negative.</source>
          <target state="translated">타이머가 만료되도록 설정된 절대 시간은 &lt;code&gt;[&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt;erlang:system_info(start_time)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_end_time&quot;&gt;erlang:system_info(end_time)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; 간격에 있어야합니다 . 상대 시간이 지정되면 &lt;code&gt;Time&lt;/code&gt; 값은 음수가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e18029dc4fbc0a03d56e79bb7184953e3744a063" translate="yes" xml:space="preserve">
          <source>The abstract layer (defined in &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt;) is nicely structured and the node types are context-independent. The layer makes it possible to transparently attach source-code comments and user annotations to nodes of the tree. Using the abstract layer makes applications less sensitive to changes in the &lt;code&gt;erl_parse(3)&lt;/code&gt; data structures, only requiring the &lt;code&gt;erl_syntax&lt;/code&gt; module to be up-to-date.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; 에 정의 된 추상 계층 은 훌륭하게 구조화되어 있으며 노드 유형은 컨텍스트 독립적입니다. 이 계층을 통해 소스 코드 주석과 사용자 주석을 트리의 노드에 투명하게 연결할 수 있습니다. 추상 계층을 사용하면 응용 프로그램이 &lt;code&gt;erl_parse(3)&lt;/code&gt; 데이터 구조의 변경에 덜 민감 &lt;code&gt;erl_syntax&lt;/code&gt; 모듈 만 최신 상태로 유지하면됩니다.</target>
        </trans-unit>
        <trans-unit id="56d4f99e44e9cb3cc0a8743c790ec2277cddaac6" translate="yes" xml:space="preserve">
          <source>The accepted socket inherits the options set for &lt;code&gt;ListenSocket&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt; listen/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">승인 된 소켓 은 &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt; listen/2&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;ListenSocket&lt;/code&gt; 에 대해 설정된 옵션을 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="4ebbf813506aec9cb5b7febd24547c187a92185e" translate="yes" xml:space="preserve">
          <source>The accepted socket inherits the options set for &lt;code&gt;ListenSocket&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">허용 된 소켓 은 &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;ListenSocket&lt;/code&gt; 에 설정된 옵션을 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="f6c1f48a70d3a03fcd08b9ecaf840df566c82062" translate="yes" xml:space="preserve">
          <source>The ack_action() is either:</source>
          <target state="translated">ack_action ()은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="4df5499b046a3caa5c00b3bf34cda3b59c95dee6" translate="yes" xml:space="preserve">
          <source>The ack_data() argument to this function is the Erlang term returned by handle_trans_request/3.</source>
          <target state="translated">이 함수에 대한 ack_data () 인수는 handle_trans_request / 3에 의해 리턴 된 Erlang 용어입니다.</target>
        </trans-unit>
        <trans-unit id="573fc48700bb83712fa26ae3db5f4a997f5bdf7a" translate="yes" xml:space="preserve">
          <source>The action to take when the Erlang emulator stops unexpectedly. Default is to ignore.</source>
          <target state="translated">Erlang 에뮬레이터가 예기치 않게 중지 될 때 수행 할 조치입니다. 기본값은 무시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0321983ca2ab7b420ed8780bad63ee4e244c660a" translate="yes" xml:space="preserve">
          <source>The actual behavior of compiled match specifications when recreated from external format has changed and may change in future releases, but this interface remains for backward compatibility. See &lt;code&gt;&lt;a href=&quot;#is_compiled_ms-1&quot;&gt;is_compiled_ms/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">외부 형식에서 다시 만들 때 컴파일 된 일치 사양의 실제 동작이 변경되었으며 향후 릴리스에서 변경 될 수 있지만이 인터페이스는 이전 버전과의 호환성을 위해 유지됩니다. &lt;code&gt;&lt;a href=&quot;#is_compiled_ms-1&quot;&gt;is_compiled_ms/1&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40fdcbc6206b95ef9655638b626a5128e3d5dc2c" translate="yes" xml:space="preserve">
          <source>The actual encoded messages have been collected in one directory per encoding type, containing one file per encoded message.</source>
          <target state="translated">실제 인코딩 된 메시지는 인코딩 된 메시지 당 하나의 파일을 포함하여 인코딩 유형 당 하나의 디렉토리에 수집되었습니다.</target>
        </trans-unit>
        <trans-unit id="1c694608beedd90d5cb7943b28c1a84362940fa0" translate="yes" xml:space="preserve">
          <source>The actual encryption or decryption is done by &lt;code&gt;&lt;a href=&quot;crypto#crypto_update-2&quot;&gt;crypto_update/2&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;crypto#crypto_dyn_iv_update-3&quot;&gt;crypto_dyn_iv_update/3&lt;/a&gt;&lt;/code&gt; ).</source>
          <target state="translated">실제 암호화 또는 복호화는 &lt;code&gt;&lt;a href=&quot;crypto#crypto_update-2&quot;&gt;crypto_update/2&lt;/a&gt;&lt;/code&gt; (또는 &lt;code&gt;&lt;a href=&quot;crypto#crypto_dyn_iv_update-3&quot;&gt;crypto_dyn_iv_update/3&lt;/a&gt;&lt;/code&gt; )에 의해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7fed2c92bea1fa55e85c9f8695c1f69a2c7262b" translate="yes" xml:space="preserve">
          <source>The actual implementation of instructions are also defined in &lt;code&gt;.tab&lt;/code&gt; files processed by &lt;strong&gt;beam_makeops&lt;/strong&gt;. For practical reasons, instruction definitions are stored in several files, at the time of writing in the following files:</source>
          <target state="translated">실제 지침 구현은 &lt;strong&gt;beam_makeops에서&lt;/strong&gt; 처리하는 &lt;code&gt;.tab&lt;/code&gt; 파일 에도 정의되어 있습니다 . 실용적인 이유로 명령어 정의는 다음 파일에 기록 할 때 여러 파일에 저장됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bbf119f15e4a3e4c9e43ba3da03845ee142277be" translate="yes" xml:space="preserve">
          <source>The actual message returned by the RPC server is a 2-tuple &lt;code&gt;{rex,Reply}&lt;/code&gt;. If you use &lt;code&gt;erl_rpc_from()&lt;/code&gt; in your code, this is the message you will need to parse. If you use &lt;code&gt;erl_rpc()&lt;/code&gt;, the tuple itself is parsed for you, and the message returned to your program is the Erlang term containing &lt;code&gt;Reply&lt;/code&gt; only. Replies to RPC requests are always &lt;code&gt;ERL_SEND&lt;/code&gt; messages.</source>
          <target state="translated">RPC 서버가 리턴 한 실제 메시지는 2- 튜플 &lt;code&gt;{rex,Reply}&lt;/code&gt; 입니다. 코드에서 &lt;code&gt;erl_rpc_from()&lt;/code&gt; 을 사용 하면 구문 분석해야 할 메시지입니다. &lt;code&gt;erl_rpc()&lt;/code&gt; 를 사용 하면 튜플 자체가 구문 분석되며 프로그램으로 리턴되는 메시지는 &lt;code&gt;Reply&lt;/code&gt; 만 포함하는 Erlang 용어 입니다. RPC 요청에 대한 회신은 항상 &lt;code&gt;ERL_SEND&lt;/code&gt; 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="3f712073d78ceb80ba4691c57506456b575aeca2" translate="yes" xml:space="preserve">
          <source>The actual number of fragments</source>
          <target state="translated">실제 조각 수</target>
        </trans-unit>
        <trans-unit id="605930eb2c9eb4fbbdc869cc2d2017c67143a7b6" translate="yes" xml:space="preserve">
          <source>The actual padding is performed by &lt;code&gt;&lt;a href=&quot;crypto#crypto_final-1&quot;&gt;crypto_final/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">실제 패딩은 &lt;code&gt;&lt;a href=&quot;crypto#crypto_final-1&quot;&gt;crypto_final/1&lt;/a&gt;&lt;/code&gt; 에 의해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="4322cef184ec5aecf9faa18423df4ee550bc1ca0" translate="yes" xml:space="preserve">
          <source>The actual supervision of execution times is in itself a CPU intensive activity. A message is written on the trace file for every function call that is made by the profiled code.</source>
          <target state="translated">실행 시간의 실제 감독 자체는 CPU를 많이 사용하는 활동입니다. 프로파일 된 코드로 작성된 모든 함수 호출에 대해 추적 파일에 메시지가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="d6518471a4a1665322d5954e6611844bc734d8cd" translate="yes" xml:space="preserve">
          <source>The actual supported algorithms and features depends on their availability in the actual libcrypto used. See the &lt;code&gt;crypto (App)&lt;/code&gt; about dependencies.</source>
          <target state="translated">실제 지원되는 알고리즘 및 기능은 사용 된 실제 libcrypto에서의 가용성에 따라 다릅니다. 종속성에 대한 &lt;code&gt;crypto (App)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="95a53d335d6385335f1d9907f4b8a879470a71f4" translate="yes" xml:space="preserve">
          <source>The actual supported named curves could be checked by examining the list returned by &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(curves)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">실제로 지원되는 명명 된 곡선은 &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(curves)&lt;/a&gt;&lt;/code&gt; 반환 된 목록을 검사하여 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d3571545f798bc55c8050de98e521a38384a9d2" translate="yes" xml:space="preserve">
          <source>The actual timer time.</source>
          <target state="translated">실제 타이머 시간</target>
        </trans-unit>
        <trans-unit id="27345ee3cabb8f446fd8fd55e223fda324b5bab0" translate="yes" xml:space="preserve">
          <source>The actual value is the quoted atom &lt;code&gt;'NULL'&lt;/code&gt;.</source>
          <target state="translated">실제 값은 인용 된 원자 &lt;code&gt;'NULL'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c72f4263f7e8c1e5785af3ae16a212b694d638c6" translate="yes" xml:space="preserve">
          <source>The address and port of the other end of the connection.</source>
          <target state="translated">연결의 다른 쪽 끝의 주소와 포트</target>
        </trans-unit>
        <trans-unit id="5ae3afdabf8d69b7f030903f34729a4d0a97bc17" translate="yes" xml:space="preserve">
          <source>The address must be the IP address and cannot be the hostname.</source>
          <target state="translated">주소는 IP 주소 여야하며 호스트 이름이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="45c66a6604fd97ae44d5625424f5836d3c3179c8" translate="yes" xml:space="preserve">
          <source>The address of the fun's code when HiPE is enabled.</source>
          <target state="translated">HiPE가 활성화 된 경우 펀 코드의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="7ddf5f9487a859a28b6ed4d37dd3d9bebe9f2f6a" translate="yes" xml:space="preserve">
          <source>The address of the fun's code.</source>
          <target state="translated">재미있는 코드의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="7e8bf572fd0f0bc243c5923805f5fb20ef2fe37e" translate="yes" xml:space="preserve">
          <source>The address specified in &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;send&lt;/a&gt;&lt;/code&gt; overwrites the primary peer address</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;send&lt;/a&gt;&lt;/code&gt; 에 지정된 주소 가 기본 피어 주소를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="ba449fc5f30a23d575fa4c4396e275fa504dce46" translate="yes" xml:space="preserve">
          <source>The adjustment of system time could have been made smother than using a time warp approach, but we think that would be a bad choice. As we can express and measure time that is not connected to calendar time by the use of Erlang monotonic time, it is better to expose the change in Erlang system time immediately. This as the Erlang applications executing on the system can react on the change in system time as soon as possible. This is also more or less exactly how most operating systems handle this (OS monotonic time and OS system time). By adjusting system time smoothly, we would just hide the fact that system time changed and make it harder for the Erlang applications to react to the change in a sensible way.</source>
          <target state="translated">시스템 시간 조정은 타임 워프 방식을 사용하는 것보다 질식 할 수 있었지만 우리는 이것이 잘못된 선택이라고 생각합니다. Erlang 단조 시간을 사용하여 달력 시간에 연결되지 않은 시간을 표현하고 측정 할 수 있으므로 Erlang 시스템 시간의 변경 사항을 즉시 노출하는 것이 좋습니다. 이는 시스템에서 실행되는 Erlang 애플리케이션이 시스템 시간의 변화에 ​​최대한 빨리 반응 할 수 있기 때문입니다. 이는 대부분의 운영 체제에서이를 처리하는 방식 (OS 단조 시간 및 OS 시스템 시간)과 거의 비슷합니다. 시스템 시간을 매끄럽게 조정하면 시스템 시간이 변경되었다는 사실을 숨기고 Erlang 애플리케이션이 합리적인 방식으로 변경에 반응하기가 더 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="5f9472dc1436a5862ca0454404828318f9e56d1f" translate="yes" xml:space="preserve">
          <source>The advantage of using an extensible (agent/manager) toolkit is to remove details such as type-checking, access rights, Protocol Data Unit (PDU), encoding, decoding, and trap distribution from the programmer, who only has to write the instrumentation functions, which implement the MIBs. The &lt;code&gt;get-next&lt;/code&gt; function only has to be implemented for tables, and not for every variable in the global naming tree. This information can be deduced from the ASN.1 file.</source>
          <target state="translated">확장 가능한 (에이전트 / 관리자) 툴킷을 사용하면 유형 검사, 액세스 권한, PDU (Protocol Data Unit), 인코딩, 디코딩 및 트랩 배포와 같은 세부 정보를 계측기에서 작성해야하는 프로그래머에서 제거 할 수 있습니다. MIB를 구현하는 함수. &lt;code&gt;get-next&lt;/code&gt; 기능은 테이블, 그리고 글로벌 명명 트리에서 모든 변수에 대해 구현되어야한다. 이 정보는 ASN.1 파일에서 추론 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fe8e4ddaca688413966f57d082a8c9a7e076fe3" translate="yes" xml:space="preserve">
          <source>The advantages of separating the table coordinator from the SNMP tool are:</source>
          <target state="translated">테이블 코디네이터를 SNMP 도구에서 분리하면 다음과 같은 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e3ed41d7fd39c63d6b7f432ea91d01107779b41" translate="yes" xml:space="preserve">
          <source>The affected tables are write-locked during the restoration. However, regardless of the lock conflicts caused by this, the applications can continue to do their work while the restoration is being performed. The restoration is performed as one single transaction.</source>
          <target state="translated">영향을받는 테이블은 복원 중에 쓰기 잠금됩니다. 그러나 이로 인한 잠금 충돌에 관계없이 복원이 수행되는 동안 응용 프로그램이 계속 작업을 수행 할 수 있습니다. 복원은 하나의 단일 트랜잭션으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="eeb577e64047dee54287b4297431d9c8f5676c03" translate="yes" xml:space="preserve">
          <source>The age is defined in milliseconds.</source>
          <target state="translated">나이는 밀리 초로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e7020aa85de45cdbfd0f6571b7cc03a6fded1bbd" translate="yes" xml:space="preserve">
          <source>The agent and manager uses (application) configuration parameters to find out where these directories are located. The parameters should be defined in an Erlang system configuration file. The following configuration parameters are defined for the SNMP application:</source>
          <target state="translated">에이전트 및 관리자는 (응용 프로그램) 구성 매개 변수를 사용하여 이러한 디렉토리의 위치를 ​​찾습니다. 매개 변수는 Erlang 시스템 구성 파일에서 정의해야합니다. SNMP 응용 프로그램에 대해 다음 구성 매개 변수가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="532498afa1ab407c6e18b6c76c06f1a8f9021335" translate="yes" xml:space="preserve">
          <source>The agent can be configured to be multi-threaded, to process one incoming request at a time, or to have a request limit enabled (this can be used for load control or to limit the effect of DoS attacks). If it is multi-threaded, read requests (&lt;code&gt;get&lt;/code&gt;, &lt;code&gt;get-next&lt;/code&gt; and &lt;code&gt;get-bulk&lt;/code&gt;) and traps are processed in parallel with each other and &lt;code&gt;set&lt;/code&gt; requests. However, all &lt;code&gt;set&lt;/code&gt; requests are serialized, which means that if the agent is waiting for the application to complete a complicated write operation, it will not process any new write requests until this operation is finished. It processes read requests and sends traps, concurrently. The reason for not handle write requests in parallel is that a complex locking mechanism would be needed even in the simplest cases. Even with the scheme described above, the user must be careful not to violate that the &lt;code&gt;set&lt;/code&gt; requests are atoms. If this is hard to do, do not use the multi-threaded feature.</source>
          <target state="translated">에이전트는 다중 스레드로 구성하거나 한 번에 하나의 들어오는 요청을 처리하거나 요청 제한을 활성화하도록 구성 할 수 있습니다 (로드 제어에 사용되거나 DoS 공격의 영향을 제한하는 데 사용될 수 있음). 다중 스레드 인 경우 읽기 요청 ( &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;get-next&lt;/code&gt; 및 &lt;code&gt;get-bulk&lt;/code&gt; ) 및 트랩은 서로 병렬로 처리되고 요청을 &lt;code&gt;set&lt;/code&gt; 합니다. 그러나 모든 &lt;code&gt;set&lt;/code&gt; 요청이 직렬화됩니다. 즉, 에이전트가 애플리케이션이 복잡한 쓰기 조작을 완료하기를 기다리는 경우이 조작이 완료 될 때까지 새 쓰기 요청을 처리하지 않습니다. 읽기 요청을 처리하고 동시에 트랩을 보냅니다. 쓰기 요청을 병렬로 처리하지 않는 이유는 가장 간단한 경우에도 복잡한 잠금 메커니즘이 필요하기 때문입니다. 위에서 설명한 체계를 사용하더라도 사용자는 &lt;code&gt;set&lt;/code&gt; 요청이 원자 임을 위반하지 않도록주의해야합니다 . 이것이 어려운 경우에는 멀티 스레드 기능을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1765275ae72c3c73846eb96f701861af075a2ade" translate="yes" xml:space="preserve">
          <source>The agent can both perform and respond to discovery.</source>
          <target state="translated">에이전트는 감지를 수행하고 응답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fab26e9897ff23218adb34fca8afc8ac6df806b" translate="yes" xml:space="preserve">
          <source>The agent can spontaneously send a notification, for example, an alarm, to the manager.</source>
          <target state="translated">상담원은 자발적으로 경보와 같은 알림을 관리자에게 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d42efd7983ea3f540eeeb3f75427cd0a119a5f44" translate="yes" xml:space="preserve">
          <source>The agent communication is established through a UNIX domain socket. By default, the socket path will be fetched from the &lt;code&gt;SSH_AUTH_SOCK&lt;/code&gt; enviroment variable, which is the default socket path in the agent implementation of &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에이전트 통신은 UNIX 도메인 소켓을 통해 설정됩니다. 기본적 으로 소켓 경로는 &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt; 의 에이전트 구현에서 기본 소켓 경로 인 &lt;code&gt;SSH_AUTH_SOCK&lt;/code&gt; 환경 변수 에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="88e6c01b1d22bf1009d4f112f5ef241f146f87bc" translate="yes" xml:space="preserve">
          <source>The agent does not check complex ranges specified for INTEGER objects. In these cases it just checks that the value lies within the minimum and maximum values specified. For example, if the range is specified as &lt;code&gt;1..10 | 12..20&lt;/code&gt; the agent would let 11 through, but not 0 or 21. The instrumentation functions must check the complex ranges itself.</source>
          <target state="translated">에이전트는 INTEGER 오브젝트에 지정된 복합 범위를 확인하지 않습니다. 이 경우 값이 지정된 최소값과 최대 값 내에 있는지 확인합니다. 예를 들어, 범위가 1로 지정된 경우 &lt;code&gt;1..10 | 12..20&lt;/code&gt; 상담원은 11 또는 11을 통과 시키지만 계측 기능은 복소수 범위 자체를 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="821394aba5a85ee9b738eccc0b641e5e87f98f1d" translate="yes" xml:space="preserve">
          <source>The agent information should be stored in a file called &lt;code&gt;agent.conf&lt;/code&gt;.</source>
          <target state="translated">에이전트 정보는 &lt;code&gt;agent.conf&lt;/code&gt; 파일에 저장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7d5c2b0ecab378b92db71d78b459615c0be2b937" translate="yes" xml:space="preserve">
          <source>The agent is an entity that executes within a &lt;strong&gt;Network Element (NE)&lt;/strong&gt;. In OTP, the NE can be a distributed system, meaning that the distributed system is managed as one entity. Of course, the agent can be configured to be able to run on one of several nodes, making it a distributed OTP application.</source>
          <target state="translated">에이전트는 &lt;strong&gt;네트워크 요소 (NE)&lt;/strong&gt; 내에서 실행되는 엔티티입니다 . OTP에서 NE는 분산 시스템 일 수 있으며 이는 분산 시스템이 하나의 엔티티로 관리됨을 의미합니다. 물론 에이전트는 여러 노드 중 하나에서 실행될 수 있도록 구성하여 분산 OTP 응용 프로그램으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3d395baa2a805befd96447c7ba7e7fb38c483ae" translate="yes" xml:space="preserve">
          <source>The agent is configured with the configuration tool, using default suggestions for everything but the manager node.</source>
          <target state="translated">에이전트는 관리자 노드 이외의 모든 것에 대한 기본 제안을 사용하여 구성 도구로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="bafc8c1a76725000dfff5c337a6c7efd569cd586" translate="yes" xml:space="preserve">
          <source>The agent is highly fault tolerant. If the manager gets an unexpected response from the agent, it is possible that some instrumentation function has returned an erroneous value. The agent will not crash even if the instrumentation does. It should be noted that if an instrumentation function enters an infinite loop, the agent will also be blocked forever. The supervisor ,or the application, specifies how to restart the agent.</source>
          <target state="translated">에이전트는 내결함성이 있습니다. 관리자가 에이전트로부터 예기치 않은 응답을받는 경우 일부 계측 기능이 잘못된 값을 반환했을 수 있습니다. 계측이 수행 되더라도 에이전트가 중단되지 않습니다. 인스 트루먼 테이션 기능이 무한 루프에 들어가면 에이전트도 영원히 차단됩니다. 수퍼바이저 또는 응용 프로그램은 에이전트를 다시 시작하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2c7ad18cc20a9d278d188273b0ceb93f154abb8c" translate="yes" xml:space="preserve">
          <source>The agent receives a request and maps it to calls to one or more instrumentation functions. These functions perform operations on the resources to implement the semantics associated with the MO.</source>
          <target state="translated">에이전트는 요청을 받아서 하나 이상의 계측 기능에 대한 호출에 매핑합니다. 이 함수는 리소스에 대한 작업을 수행하여 MO와 관련된 의미를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5394a28e8aa26b89d2b8f393dd3cca2d7c380d89" translate="yes" xml:space="preserve">
          <source>The agent responds to discovery autonomously, without interaction by the user.</source>
          <target state="translated">에이전트는 사용자의 상호 작용없이 자동으로 검색에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="ebd412ca77c13dc418b2ee47def2c221adc4c0fa" translate="yes" xml:space="preserve">
          <source>The agent started is called &lt;code&gt;snmp_master_agent&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#load_mibs-1&quot;&gt;ct_snmp:load_mibs/1&lt;/a&gt;&lt;/code&gt; to load MIBs into the agent.</source>
          <target state="translated">시작된 에이전트는 &lt;code&gt;snmp_master_agent&lt;/code&gt; 입니다. 사용 &lt;code&gt;&lt;a href=&quot;#load_mibs-1&quot;&gt;ct_snmp:load_mibs/1&lt;/a&gt;&lt;/code&gt; 에이전트에 MIB를로드합니다.</target>
        </trans-unit>
        <trans-unit id="35fefa07539d964d08302d135b6a045a731feaec" translate="yes" xml:space="preserve">
          <source>The agent stores the values in an internal volatile database, which is based on the standard module &lt;code&gt;ets&lt;/code&gt;. However, it is possible to let the MIB compiler generate functions which use an internal, persistent database, or the Mnesia DBMS. Refer to the Mnesia User Guide and the Reference Manual, section SNMP, module &lt;code&gt;snmp_generic&lt;/code&gt; for more information.</source>
          <target state="translated">에이전트는 표준 &lt;code&gt;ets&lt;/code&gt; 기반의 휘발성 데이터베이스에 값을 저장합니다 . 그러나 MIB 컴파일러가 내부, 영구 데이터베이스 또는 Mnesia DBMS를 사용하는 함수를 생성하도록 할 수 있습니다. 자세한 내용은 Mnesia 사용 설명서 및 참조 설명서 섹션 SNMP, &lt;code&gt;snmp_generic&lt;/code&gt; 모듈 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="88cd9d752952f90596dc3746023ba01fb085191a" translate="yes" xml:space="preserve">
          <source>The agent will never generate the &lt;code&gt;wrongEncoding&lt;/code&gt; error. If a variable binding is erroneous encoded, the &lt;code&gt;asn1ParseError&lt;/code&gt; counter will be incremented.</source>
          <target state="translated">에이전트는 &lt;code&gt;wrongEncoding&lt;/code&gt; 오류를 생성하지 않습니다 . 변수 바인딩이 잘못 인코딩 된 경우 &lt;code&gt;asn1ParseError&lt;/code&gt; 카운터가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="31dc2849b5514caeb8ae4f58e7cc8579c0d02b0d" translate="yes" xml:space="preserve">
          <source>The alarm handler is part of the SASL application.</source>
          <target state="translated">알람 처리기는 SASL 응용 프로그램의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="f225b02b835111c249a55da204c91a4c1ca4bd60" translate="yes" xml:space="preserve">
          <source>The alarm handler process is a &lt;code&gt;gen_event&lt;/code&gt; event manager process that receives alarms in the system. This process is not intended to be a complete alarm handler. It defines a place to which alarms can be sent. One simple event handler is installed in the alarm handler at startup, but users are encouraged to write and install their own handlers.</source>
          <target state="translated">알람 핸들러 프로세스는 시스템에서 알람을 수신 하는 &lt;code&gt;gen_event&lt;/code&gt; 이벤트 관리자 프로세스입니다. 이 프로세스는 완전한 알람 핸들러가 아닙니다. 알람을 보낼 수있는 장소를 정의합니다. 시작시 하나의 간단한 이벤트 핸들러가 알람 핸들러에 설치되지만 사용자는 자체 핸들러를 작성하고 설치하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9a1c34ac82f222f7bf20fdb60c9c70070554269a" translate="yes" xml:space="preserve">
          <source>The alarms are cleared automatically when the alarm cause is no longer valid.</source>
          <target state="translated">알람 원인이 더 이상 유효하지 않으면 알람이 자동으로 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="986d3b30b24eb7709dfdc0693fd6abc2a7ec4e8c" translate="yes" xml:space="preserve">
          <source>The algorithm for updating &lt;code&gt;Serial&lt;/code&gt; can be described as follows:</source>
          <target state="translated">&lt;code&gt;Serial&lt;/code&gt; 업데이트 알고리즘은 다음과 같이 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dd9a185b05bfc6c5aca5b3488aeb8d588a949ea" translate="yes" xml:space="preserve">
          <source>The algorithm for wich the fun should implement the special matching rules</source>
          <target state="translated">재미를위한 알고리즘은 특별한 매칭 규칙을 구현해야합니다</target>
        </trans-unit>
        <trans-unit id="7bb19b504df5c1a9303c7a6f511b1fc2dc8c9766" translate="yes" xml:space="preserve">
          <source>The algorithm in &lt;code&gt;ssh_hostkey_fingerprint/1&lt;/code&gt; is md5 to be compatible with older ssh-keygen commands. The string from the second variant is prepended by the algorithm name in uppercase as in newer ssh-keygen commands.</source>
          <target state="translated">&lt;code&gt;ssh_hostkey_fingerprint/1&lt;/code&gt; 의 알고리즘 은 md5이며 이전 ssh-keygen 명령과 호환됩니다. 두 번째 변형의 문자열 앞에는 최신 ssh-keygen 명령에서와 같이 알고리즘 이름이 대문자로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b2f989a67b5ca0281a96030c126b7a3d77ef6b31" translate="yes" xml:space="preserve">
          <source>The algorithm is a modification of the version attributed to Richard A. O'Keefe in the standard Prolog library.</source>
          <target state="translated">이 알고리즘은 표준 프롤로그 라이브러리에서 Richard A. O'Keefe의 버전을 수정 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7f680b0d6e8d6f4e75e82db44978468dc45a6e99" translate="yes" xml:space="preserve">
          <source>The algorithm is the same as for send above.</source>
          <target state="translated">알고리즘은 위의 보내기와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="230091aa46aa0a9b37e9fd8c10519ddfe76dd814" translate="yes" xml:space="preserve">
          <source>The algorithm that is used to draw a graph with as few crossed links as possible is called force graph. A force graph consists of nodes and directed links between nodes. Each node is associated with a repulsive force that pushes nodes away from each other. This force can be adjusted with the left slider or with the mouse wheel. Each link is associated with an attractive force that pulls the nodes nearer to each other. This force can be adjusted with the right slider. If this force becomes too strong, the graph will be unstable. The third parameter that can be adjusted is the length of the links. It is adjusted with the middle slider.</source>
          <target state="translated">교차 링크가 가능한 적은 그래프를 그리는 데 사용되는 알고리즘을 힘 그래프라고합니다. 힘 그래프는 노드와 노드 간 직접 링크로 구성됩니다. 각 노드는 노드를 서로 멀어지게하는 반발력과 관련이 있습니다. 이 힘은 왼쪽 슬라이더 나 마우스 휠로 조정할 수 있습니다. 각 링크는 노드를 서로 더 가까이 끌어 당기는 인력과 관련이 있습니다. 이 힘은 오른쪽 슬라이더로 조정할 수 있습니다. 이 힘이 너무 강해지면 그래프가 불안정 해집니다. 조정할 수있는 세 번째 매개 변수는 링크 길이입니다. 중간 슬라이더로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="e0be3089ed3cdab42290e47bafffab640f5507bb" translate="yes" xml:space="preserve">
          <source>The algorithms should be in the preferred order. Selected signature algorithm can restrict which hash functions that may be selected. Default support for {md5, rsa} removed in ssl-8.0</source>
          <target state="translated">알고리즘은 선호하는 순서로되어 있어야합니다. 선택된 서명 알고리즘은 선택할 수있는 해시 함수를 제한 할 수 있습니다. SSL-8.0에서 {md5, rsa}에 대한 기본 지원이 제거되었습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
