<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="d09be805d2731441552cb1761a72f29b924b8a7a" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_postcomments(set_precomments(Target, get_precomments(Source)), get_postcomments(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;set_postcomments(set_precomments(Target, get_precomments(Source)), get_postcomments(Source))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="698437d5693811f218a0125173a54360a31fae26" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_precomments(Node, get_precomments(Node) ++ Comments)&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;set_precomments(Node, get_precomments(Node) ++ Comments)&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="94f64f74f43a14a0fd5a71cca82d5190660bfa22" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_precomments(set_postcomments(Node, []), [])&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;set_precomments(set_postcomments(Node, []), [])&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="c2cbae916b385a433641891fb2f65cb175003a34" translate="yes" xml:space="preserve">
          <source>Note: changing this value (and passing the resulting context to a continuation function) does not affect the normal formatting, but may affect user-defined behaviour in hook functions.</source>
          <target state="translated">참고 :이 값을 변경하고 결과 컨텍스트를 연속 함수에 전달하면 일반적인 형식에는 영향을 미치지 않지만 후크 함수의 사용자 정의 동작에는 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0e024adb668e3f8ad63658f3c7b61203ba9e048" translate="yes" xml:space="preserve">
          <source>Note: if &lt;code&gt;Node&lt;/code&gt; represents &quot;&lt;code&gt;M:F(...)&lt;/code&gt;&quot;, then the result is the subtree representing &quot;&lt;code&gt;M:F&lt;/code&gt;&quot;.</source>
          <target state="translated">참고 : &lt;code&gt;Node&lt;/code&gt; 가 &quot; &lt;code&gt;M:F(...)&lt;/code&gt; &quot;를 나타내는 경우 결과는 &quot; &lt;code&gt;M:F&lt;/code&gt; &quot;를 나타내는 하위 트리 입니다.</target>
        </trans-unit>
        <trans-unit id="e950ce0b15b865ad70b6df0b8b6e16fd534c8751" translate="yes" xml:space="preserve">
          <source>Note: if &lt;code&gt;Node&lt;/code&gt; represents &quot;&lt;code&gt;fun N/A&lt;/code&gt;&quot; or &quot;&lt;code&gt;fun M:N/A&lt;/code&gt;&quot;, then the result is the subtree representing &quot;&lt;code&gt;N/A&lt;/code&gt;&quot; or &quot;&lt;code&gt;M:N/A&lt;/code&gt;&quot;, respectively.</source>
          <target state="translated">참고 : &lt;code&gt;Node&lt;/code&gt; 가 &quot; &lt;code&gt;fun N/A&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;fun M:N/A&lt;/code&gt; &quot;를 나타내는 경우 결과는 각각 &quot; &lt;code&gt;N/A&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;M:N/A&lt;/code&gt; &quot;를 나타내는 하위 트리 입니다.</target>
        </trans-unit>
        <trans-unit id="024d798779fd03b9f02b44baf68e6e4bf1a905f4" translate="yes" xml:space="preserve">
          <source>Note: in &lt;code&gt;list(Elements, none)&lt;/code&gt;, the &quot;nil&quot; list terminator is implicit and has no associated information (see &lt;code&gt;&lt;a href=&quot;#get_attrs-1&quot;&gt;get_attrs/1&lt;/a&gt;&lt;/code&gt;), while in the seemingly equivalent &lt;code&gt;list(Elements, Tail)&lt;/code&gt; when &lt;code&gt;Tail&lt;/code&gt; has type &lt;code&gt;nil&lt;/code&gt;, the list terminator subtree &lt;code&gt;Tail&lt;/code&gt; may have attached attributes such as position, comments, and annotations, which will be preserved in the result.</source>
          <target state="translated">참고 :에서 &lt;code&gt;list(Elements, none)&lt;/code&gt; 은 &quot;전무&quot;목록 종결 암시하고 아무 관련 정보가 없습니다 (참조 &lt;code&gt;&lt;a href=&quot;#get_attrs-1&quot;&gt;get_attrs/1&lt;/a&gt;&lt;/code&gt; ), 동안 겉으로는 동등한 &lt;code&gt;list(Elements, Tail)&lt;/code&gt; 때 &lt;code&gt;Tail&lt;/code&gt; 형이 &lt;code&gt;nil&lt;/code&gt; 목록 종결을, 하위 트리 &lt;code&gt;Tail&lt;/code&gt; 에는 위치, 주석 및 주석과 같은 속성이 첨부되어있을 수 있으며 결과에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="c912d0741e6afe02446fe862b8225b8a23da14f4" translate="yes" xml:space="preserve">
          <source>Note: no checking is done whether the character sequence represents a proper variable name, i.e., whether or not its first character is an uppercase Erlang character, or whether it does not contain control characters, whitespace, etc.</source>
          <target state="translated">참고 : 문자 시퀀스가 ​​올바른 변수 이름을 나타내는 지 여부, 즉 첫 문자가 대문자 Erlang 문자인지 여부 또는 제어 문자, 공백 등을 포함하지 않는지 여부는 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e16037ad2fddc6752207e81b2d23a2a536d6ff8" translate="yes" xml:space="preserve">
          <source>Note: not all literals are leaf nodes, and vice versa. E.g., tuples with nonzero arity and nonempty lists may be literals, but are not leaf nodes. Variables, on the other hand, are leaf nodes but not literals.</source>
          <target state="translated">참고 : 모든 리터럴이 리프 노드는 아니며 그 반대도 마찬가지입니다. 예를 들어, 0이 아닌 arity 및 비어 있지 않은 목록을 가진 튜플은 리터럴 일 수 있지만 리프 노드는 아닙니다. 반면에 변수는 리프 노드이지만 리터럴은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e19a5f5e7535dfc22dce9d8f5ad97ff942d5f69e" translate="yes" xml:space="preserve">
          <source>Note: the literal corresponding to a particular character value is not uniquely defined. E.g., the character &quot;&lt;code&gt;a&lt;/code&gt;&quot; can be written both as &quot;&lt;code&gt;$a&lt;/code&gt;&quot; and &quot;&lt;code&gt;$\141&lt;/code&gt;&quot;, and a Tab character can be written as &quot;&lt;code&gt;$\11&lt;/code&gt;&quot;, &quot;&lt;code&gt;$\011&lt;/code&gt;&quot; or &quot;&lt;code&gt;$\t&lt;/code&gt;&quot;.</source>
          <target state="translated">참고 : 특정 문자 값에 해당하는 리터럴은 고유하게 정의되지 않습니다. 예를 들어, 문자 &quot; &lt;code&gt;a&lt;/code&gt; &quot;는 &quot; &lt;code&gt;$a&lt;/code&gt; &quot;및 &quot; &lt;code&gt;$\141&lt;/code&gt; &quot;로 작성 될 수 있고 탭 문자는 &quot; &lt;code&gt;$\11&lt;/code&gt; &quot;, &quot; &lt;code&gt;$\011&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;$\t&lt;/code&gt; &quot; 로 작성 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6afc7eae3d94cce8a805b8208b70b9cbd6d1fee0" translate="yes" xml:space="preserve">
          <source>Note: the resulting list can contain more than one tuple &lt;code&gt;{ShortName, Name}&lt;/code&gt; for the same &lt;code&gt;ShortName&lt;/code&gt;, possibly with different values for &lt;code&gt;Name&lt;/code&gt;, depending on the given list.</source>
          <target state="translated">참고 : 결과 목록에는 동일한 &lt;code&gt;ShortName&lt;/code&gt; 에 대해 둘 이상의 튜플 &lt;code&gt;{ShortName, Name}&lt;/code&gt; 포함될 수 있으며 주어진 목록에 따라 &lt;code&gt;Name&lt;/code&gt; 에 대해 다른 값이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e12fe9dbfa6c36c26ca8159eaa9cc67ee440fdd9" translate="yes" xml:space="preserve">
          <source>Note: the return value is &lt;code&gt;ok&lt;/code&gt; instead of &lt;code&gt;success&lt;/code&gt; unlike in other functions in this module. This is a fault that was introduced so long ago that any change would break a large number of existing software.</source>
          <target state="translated">참고 : 이 모듈의 다른 기능과 달리 반환 값은 &lt;code&gt;success&lt;/code&gt; 대신 &lt;code&gt;ok&lt;/code&gt; 습니다 . 이것은 오래 전에 도입 된 결함으로, 모든 변경으로 인해 기존 소프트웨어가 많이 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17b17be20c7e8e9810e58ea4c73486c73bfc67e7" translate="yes" xml:space="preserve">
          <source>Note: the text returned by the formatting function will be split automatically into separate comment lines at each line break. No extra work is needed.</source>
          <target state="translated">참고 : 서식 지정 기능에 의해 반환되는 텍스트는 각 줄 바꿈에서 자동으로 별도의 주석 줄로 분할됩니다. 추가 작업이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="41856edf3415d1e90c206e87cfe950bc7df0afeb" translate="yes" xml:space="preserve">
          <source>Note: these macros introduce a run-time dependency on the EUnit library code, if compiled with testing enabled.</source>
          <target state="translated">참고 :이 매크로는 테스트를 사용하여 컴파일 된 경우 EUnit 라이브러리 코드에 런타임 종속성을 도입합니다.</target>
        </trans-unit>
        <trans-unit id="58d78502c9d35d74b9f564b739de13ccb2a77f56" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(list_elements(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;length(list_elements(Node))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="97dc47a811817d58377be776d262e5b3c05f6cf1" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(tuple_elements(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;length(tuple_elements(Node))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="4666d61b1ebe44a455ff212df8dfe43d5e4150ff" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_ann(Node, [Annotation | get_ann(Node)])&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;set_ann(Node, [Annotation | get_ann(Node)])&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="cdbc84877e38d50c218ad5207d2faecbe10b2060" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_ann(Target, get_ann(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;set_ann(Target, get_ann(Source))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="a5386e79b58eda950a5274a7a0af8b6cfc746999" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_attrs(Target, get_attrs(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;set_attrs(Target, get_attrs(Source))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="27b141a49bc96901cfd1d105a64d4c5f5a09eca3" translate="yes" xml:space="preserve">
          <source>Note: this is retained only for backwards compatibility with existing parsers and tools.</source>
          <target state="translated">참고 : 기존 파서 및 도구와의 하위 호환성을 위해서만 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="9a585e3e15766522c8abd82fcb5ff8e1c6cca19e" translate="yes" xml:space="preserve">
          <source>Note: this is simply a way of grouping source code forms as a single syntax tree, usually in order to form an Erlang module definition.</source>
          <target state="translated">참고 : 이것은 일반적으로 Erlang 모듈 정의를 형성하기 위해 소스 코드 양식을 단일 구문 트리로 그룹화하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7a43199c7c25f11800016e7472f3564571a0c7b8" translate="yes" xml:space="preserve">
          <source>Note: this is supported only for backwards compatibility with existing parsers and tools.</source>
          <target state="translated">참고 : 기존 파서 및 도구와의 호환성을 위해서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="36d78a208c85e4ee9fbb30023fe1b73f1f6b5ac7" translate="yes" xml:space="preserve">
          <source>Notes: Floating documents appear to work well, but are currently less general than you might wish, losing effect when embedded in certain contexts. It is possible to nest floating-operators (even with different priorities), but the effects may be difficult to predict. In any case, note that the way the algorithm reorders floating documents amounts to a &quot;bubblesort&quot;, so don't expect it to be able to sort large sequences of floating documents quickly.</source>
          <target state="translated">참고 : 플로팅 문서는 잘 작동하는 것처럼 보이지만 현재는 원하는 것보다 덜 일반적이므로 특정 컨텍스트에 포함되면 효과가 손실됩니다. 부동 연산자 (우선 순위가 다른 경우에도)를 중첩 할 수 있지만 효과를 예측하기 어려울 수 있습니다. 어쨌든 알고리즘이 플로팅 문서의 순서를 재정렬하는 방식은 &quot;버블 레트 (bubblesort)&quot;이므로 대량의 플로팅 문서 시퀀스를 빠르게 정렬 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="661b94995b5e8bdcfda9b5f651e69fddc51ef9bc" translate="yes" xml:space="preserve">
          <source>Notes: If a file contains too exotic definitions or uses of macros, it will not be possible to read it without preprocessing. Furthermore, Igor does not currently try to sort out multiple inclusions of the same file, or redefinitions of the same macro name. Therefore, when preprocessing is turned off, it may become necessary to edit the resulting source code, removing such re-inclusions and redefinitions.</source>
          <target state="translated">참고 : 파일에 너무 이색적인 정의 나 매크로 사용이 포함 된 경우 사전 처리없이 파일을 읽을 수 없습니다. 또한 Igor는 현재 동일한 파일을 여러 개 포함하거나 동일한 매크로 이름을 재정의하려고 시도하지 않습니다. 따라서 전처리를 끄면 결과 소스 코드를 편집하여 이러한 재 포함 및 재정의를 제거해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="15f88e626a7699794907797465138c59374fcbea" translate="yes" xml:space="preserve">
          <source>Notes: if &lt;code&gt;Arguments&lt;/code&gt; is the empty list, the result will thus represent &quot;&lt;code&gt;?Name()&lt;/code&gt;&quot;, including a pair of matching parentheses.</source>
          <target state="translated">참고 : &lt;code&gt;Arguments&lt;/code&gt; 가 빈 목록 인 경우 결과는 일치하는 괄호 쌍을 포함하여 &quot; &lt;code&gt;?Name()&lt;/code&gt; &quot; 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="99a1f1cf872f6e0e707f9c22cb3a2c5254119532" translate="yes" xml:space="preserve">
          <source>Nothing is removed from the queue by this function, that must be done with &lt;code&gt;&lt;a href=&quot;#driver_deq&quot;&gt;driver_deq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수에 의해 큐에서 아무것도 제거되지 &lt;code&gt;&lt;a href=&quot;#driver_deq&quot;&gt;driver_deq&lt;/a&gt;&lt;/code&gt; 로 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f4188a869e9e87b711a06e4a4b3f28fd00e2f8ef" translate="yes" xml:space="preserve">
          <source>Nothing is removed from the queue by this function, that must be done with &lt;code&gt;&lt;a href=&quot;#enif_ioq_deq&quot;&gt;enif_ioq_deq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수에 의해 큐에서 아무것도 제거되지 &lt;code&gt;&lt;a href=&quot;#enif_ioq_deq&quot;&gt;enif_ioq_deq&lt;/a&gt;&lt;/code&gt; 로 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="65c645e6dc76f281bf44b4e98033d1a25ed3e13d" translate="yes" xml:space="preserve">
          <source>Notice also that &quot;&lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot; is interpreted as &quot;&lt;code&gt;B =&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot; which is a syntax error. The correct way is to write a space after '=': &quot;&lt;code&gt;B= &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&quot;을 알 &lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; ''로 해석 &lt;code&gt;B =&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; 문법 에러이다.&quot; 올바른 방법은 '='뒤에 공백을 쓰는 것입니다 : &quot; &lt;code&gt;B= &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e7821e854de5de8a4aacee0ff97239e9645aa44" translate="yes" xml:space="preserve">
          <source>Notice also that byte-oriented data is simplest sent using the ISO Latin-1 encoding.</source>
          <target state="translated">바이트 지향 데이터는 ISO Latin-1 인코딩을 사용하여 가장 간단하게 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="8a4c53d6a09620002b97e1f8172f87b851fbd7a6" translate="yes" xml:space="preserve">
          <source>Notice also that the transient type is of little practical use, because when a supervision tree terminates, the reason is set to &lt;code&gt;shutdown&lt;/code&gt;, not &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">또한 감시 트리가 종료되면 이유가 &lt;code&gt;normal&lt;/code&gt; 아니라 &lt;code&gt;shutdown&lt;/code&gt; 로 설정되므로 과도 유형은 거의 실용적이지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ed33ac880989d641a4eeb80431d2338e759148c9" translate="yes" xml:space="preserve">
          <source>Notice also that when testing the program from the shell, the input is spread over two lines as the line was too long.</source>
          <target state="translated">또한 쉘에서 프로그램을 테스트 할 때 라인이 너무 길어서 입력이 두 라인으로 분산됩니다.</target>
        </trans-unit>
        <trans-unit id="831cedf2104bac2a5f0cad0d085a43c104fcbad7" translate="yes" xml:space="preserve">
          <source>Notice also that ~p is used instead of ~w in &lt;code&gt;io:format&lt;/code&gt;. To quote the manual: &quot;~p Writes the data with standard syntax in the same way as ~w, but breaks terms whose printed representation is longer than one line into many lines and indents each line sensibly. It also tries to detect lists of printable characters and to output these as strings&quot;.</source>
          <target state="translated">또한 &lt;code&gt;io:format&lt;/code&gt; 에서 ~ w 대신 ~ p가 사용됩니다 . 매뉴얼을 인용하려면 : &quot;~ p ~ w와 같은 방식으로 표준 구문으로 데이터를 쓰지만 인쇄 된 표현이 한 줄보다 긴 용어를 여러 줄로 나누고 각 줄을 현명하게 들여 쓰기합니다. 또한 인쇄 가능한 목록을 감지하려고합니다. 문자와 문자열로 출력합니다. &quot;</target>
        </trans-unit>
        <trans-unit id="c8bc316625e4c64bc96adbb50df0038f6cc5d2e3" translate="yes" xml:space="preserve">
          <source>Notice how the operator &quot;!&quot; is used to send messages. The syntax of &quot;!&quot; is:</source>
          <target state="translated">연산자 &quot;!&quot;에 주목하십시오. 메시지를 보내는 데 사용됩니다. &quot;!&quot;의 문법 입니다 :</target>
        </trans-unit>
        <trans-unit id="2981906ecbb99640904a52c6a3186e8def191ed9" translate="yes" xml:space="preserve">
          <source>Notice how to write the &lt;code&gt;server&lt;/code&gt; function so that it calls itself, through &lt;code&gt;server(User_List)&lt;/code&gt;, and thus creates a loop. The Erlang compiler is &quot;clever&quot; and optimizes the code so that this really is a sort of loop and not a proper function call. But this only works if there is no code after the call. Otherwise, the compiler expects the call to return and make a proper function call. This would result in the process getting bigger and bigger for every loop.</source>
          <target state="translated">&lt;code&gt;server(User_List)&lt;/code&gt; 통해 &lt;code&gt;server&lt;/code&gt; 함수를 호출 하여 루프 를 작성하도록 서버 함수 를 작성하는 방법에 주목하십시오 . Erlang 컴파일러는 &quot;영리한&quot;코드이며 코드를 최적화하여 이것이 실제로 함수 호출이 아닌 일종의 루프가되도록합니다. 그러나 이것은 호출 후 코드가없는 경우에만 작동합니다. 그렇지 않으면, 컴파일러는 호출이 리턴되어 적절한 함수 호출을 기대합니다. 결과적으로 모든 루프마다 프로세스가 점점 커집니다.</target>
        </trans-unit>
        <trans-unit id="5b3e78ade17b6e0804c28534fc7f4b91db6f6042" translate="yes" xml:space="preserve">
          <source>Notice in the second example that the duplicate name only occurs once in the returned list, and that the list is in alphabetical order regardless of where the names are positioned in the regular expression. The order of the names is the same as the order of captured subexpressions if &lt;code&gt;{capture, all_names}&lt;/code&gt; is specified as an option to &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;. You can therefore create a name-to-value mapping from the result of &lt;code&gt;run/3&lt;/code&gt; like this:</source>
          <target state="translated">두 번째 예에서 중복 된 이름은 반환 된 목록에서 한 번만 발생하며 정규식에서 이름의 위치에 관계없이 목록이 알파벳 순서로 표시됩니다. &lt;code&gt;{capture, all_names}&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 옵션으로 지정된 경우 이름의 순서는 캡처 된 하위 표현식의 순서와 동일 합니다 . 따라서 &lt;code&gt;run/3&lt;/code&gt; 의 결과에서 다음 과 같이 이름-값 맵핑을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="686ddcda1c61a1ea244a057dd0d0172fe3f99230" translate="yes" xml:space="preserve">
          <source>Notice on line 16 that 5 inches is converted to centimeters and back again and reassuringly get back to the original value. That is, the argument to a function can be the result of another function. Consider how line 16 (above) works. The argument given to the function &lt;code&gt;{inch,5}&lt;/code&gt; is first matched against the first head clause of &lt;code&gt;convert_length&lt;/code&gt;, that is, &lt;code&gt;convert_length({centimeter,X})&lt;/code&gt;. It can be seen that &lt;code&gt;{centimeter,X}&lt;/code&gt; does not match &lt;code&gt;{inch,5}&lt;/code&gt; (the head is the bit before the &quot;-&amp;gt;&quot;). This having failed, let us try the head of the next clause that is, &lt;code&gt;convert_length({inch,Y})&lt;/code&gt;. This matches, and &lt;code&gt;Y&lt;/code&gt; gets the value 5.</source>
          <target state="translated">16 행에서 5 인치가 센티미터로 변환되었다가 다시 되돌아오고 안심하고 원래 값으로 돌아갑니다. 즉, 함수에 대한 인수는 다른 함수의 결과 일 수 있습니다. 16 행 (위)의 작동 방식을 고려하십시오. &lt;code&gt;{inch,5}&lt;/code&gt; 함수에 제공된 인수 는 먼저 &lt;code&gt;convert_length&lt;/code&gt; 의 첫 번째 head 절 , 즉 &lt;code&gt;convert_length({centimeter,X})&lt;/code&gt; 와 일치합니다 . &lt;code&gt;{centimeter,X}&lt;/code&gt; 가 &lt;code&gt;{inch,5}&lt;/code&gt; 와 일치하지 않는 것을 볼 수 있습니다 (머리는 &quot;-&amp;gt;&quot;앞의 비트입니다). 이것에 실패했습니다. 다음 절인 &lt;code&gt;convert_length({inch,Y})&lt;/code&gt; 의 헤드를 사용해 봅시다 . 이것은 일치하고 &lt;code&gt;Y&lt;/code&gt; 는 값 5를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="faf1518cd916f83fdab368cf16163b784374daaa" translate="yes" xml:space="preserve">
          <source>Notice that &quot;&lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot; will be interpreted as &quot;&lt;code&gt;B =&amp;lt; &amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot;, which is a syntax error. The correct way to write the expression is: &lt;code&gt;B = &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&quot;알 &lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; ''로 해석한다 &lt;code&gt;B =&amp;lt; &amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; &quot;구문 오류이다. 표현식을 작성하는 올바른 방법은 &lt;code&gt;B = &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4e48d2b215215558347b575f3ecbab79091a73b6" translate="yes" xml:space="preserve">
          <source>Notice that (*COMMIT) at the start of a pattern is not the same as an anchor, unless the PCRE start-of-match optimizations are turned off, as shown in the following example:</source>
          <target state="translated">다음 예와 같이 PCRE 일치 시작 최적화가 해제되어 있지 않으면 패턴 시작시 (* COMMIT)은 앵커와 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7645c19f8cada682b7b2ac8e343c6026994bf018" translate="yes" xml:space="preserve">
          <source>Notice that (*SKIP:NAME) searches only for names set by (*MARK:NAME). It ignores names that are set by (*PRUNE:NAME) or (*THEN:NAME).</source>
          <target state="translated">(* SKIP : NAME)은 (* MARK : NAME)에서 설정 한 이름 만 검색합니다. (* PRUNE : NAME) 또는 (* THEN : NAME)으로 설정된 이름은 무시합니다.</target>
        </trans-unit>
        <trans-unit id="3adcc07be0a21a37482a3bd3976227349972956b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;-relaxed_command_check&lt;/code&gt; is specified when starting the daemon that is to accept killing when it has live nodes registered. When running &lt;code&gt;epmd&lt;/code&gt; interactively, &lt;code&gt;-relaxed_command_check&lt;/code&gt; has no effect. A daemon that is started without relaxed command checking must be killed using, for example, signals or some other OS-specific method if it has active clients registered.</source>
          <target state="translated">것을 알 수 &lt;code&gt;-relaxed_command_check&lt;/code&gt; 이 이 등록 라이브 노드가있을 때 죽이는 동의하는 것입니다 데몬을 시작할 때 지정됩니다. &lt;code&gt;epmd&lt;/code&gt; 를 대화식으로 실행할 때는 &lt;code&gt;-relaxed_command_check&lt;/code&gt; 가 적용되지 않습니다. 완화 된 명령 검사없이 시작된 데몬은 활성 클라이언트가 등록 된 경우 신호 또는 기타 OS 특정 방법 등을 사용하여 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="147f5f00692828642c9cf73812c37af283058699" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;&lt;a href=&quot;erl_ext_dist#overall_format&quot;&gt;the version number is omitted from the terms that follow a distribution header&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">통지 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#overall_format&quot;&gt;the version number is omitted from the terms that follow a distribution header&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8218b491a4b3c0c5eb8370427f8e63bc8b619227" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;ActiveSuspendCount&lt;/code&gt; and &lt;code&gt;OutstandingSuspendCount&lt;/code&gt; are not the total suspend count on &lt;code&gt;Suspendee&lt;/code&gt;, only the parts contributed by &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">것을 알 수 &lt;code&gt;ActiveSuspendCount&lt;/code&gt; 및 &lt;code&gt;OutstandingSuspendCount&lt;/code&gt; 가 총 아니다 의지 중단 &lt;code&gt;Suspendee&lt;/code&gt; 는 , 부분 만은 기부 &lt;code&gt;Pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cd2f7d7216ad16040d03dfe0cd8ffeaa41f5fc9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;ErlNifBinary&lt;/code&gt; is a semi-opaque type and you are only allowed to read fields &lt;code&gt;size&lt;/code&gt; and &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">공지 사항이 &lt;code&gt;ErlNifBinary&lt;/code&gt; 는 반 불투명 한 유형이고 당신은 단지 필드 읽을 수 있습니다 &lt;code&gt;size&lt;/code&gt; 와 &lt;code&gt;data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6fa80e962aa12707d897541b088fcd511a7fff9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Filename&lt;/code&gt; can be either a list or a binary.</source>
          <target state="translated">통지 &lt;code&gt;Filename&lt;/code&gt; 목록 또는 이진 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f14731d9c3c6fd3730587d810464f8a2d56ecc47" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Tracee&lt;/code&gt; must refer to a process currently or previously existing on the same node as the caller of &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; resides on. The special &lt;code&gt;Tracee&lt;/code&gt; atom &lt;code&gt;all&lt;/code&gt; denotes all processes that currently are traced in the node.</source>
          <target state="translated">것을 알 수 &lt;code&gt;Tracee&lt;/code&gt; 은 현재 또는 이전의 호출자와 동일한 노드에 존재하는 프로세스를 참조해야합니다 &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; 상주에. 특수 &lt;code&gt;Tracee&lt;/code&gt; 의 원자는 &lt;code&gt;all&lt;/code&gt; 현재 노드에서 추적 된 모든 프로세스를 의미한다.</target>
        </trans-unit>
        <trans-unit id="e39772795b303f493c5e1f6ecf427eea0b844a7b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;[$\r,$\n]&lt;/code&gt; is one grapheme cluster according to the Unicode Standard.</source>
          <target state="translated">공지 사항 것을 &lt;code&gt;[$\r,$\n]&lt;/code&gt; 유니 코드 표준에 따라 하나 개의 그래 핀 클러스터입니다.</target>
        </trans-unit>
        <trans-unit id="6aa2d6619dffc8bd3c3adb06ec4c9073939311ad" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;[$\r,$\n]&lt;/code&gt; is one grapheme cluster.</source>
          <target state="translated">공지 사항 것을 &lt;code&gt;[$\r,$\n]&lt;/code&gt; 하나 개의 자소 클러스터입니다.</target>
        </trans-unit>
        <trans-unit id="08897008ae2f97db9924c5cfdccc065044d13435" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;bind_address&lt;/code&gt; must be the IP address reported by function &lt;code&gt;info&lt;/code&gt; and cannot be the hostname that is allowed when putting in &lt;code&gt;bind_address&lt;/code&gt;.</source>
          <target state="translated">통지 &lt;code&gt;bind_address&lt;/code&gt; 가 IP 주소이어야 기능에 의해보고 된 &lt;code&gt;info&lt;/code&gt; 와 퍼팅 할 때 허용되는 호스트 이름이 될 수 없습니다 &lt;code&gt;bind_address&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0c830556293b9a7bbf702aa85452de5ebbaf366" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;catch&lt;/code&gt; has low precedence and catch subexpressions often needs to be enclosed in a block expression or in parentheses:</source>
          <target state="translated">공지 사항 것을 &lt;code&gt;catch&lt;/code&gt; 낮은 우선 순위와 종종 블록 식 또는 괄호로 묶어야 할 필요가 캐치 표현식을 가지고 :</target>
        </trans-unit>
        <trans-unit id="bb283657c8b33fada586a3cb80cefd9a6fce3dd1" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;enif_open_resource_type&lt;/code&gt; is only allowed to be called in the two callbacks &lt;code&gt;&lt;a href=&quot;#load&quot;&gt;load&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#upgrade&quot;&gt;upgrade&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">것을 알 수 &lt;code&gt;enif_open_resource_type&lt;/code&gt; 은 단지 두 개의 콜백 호출 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;#load&quot;&gt;load&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#upgrade&quot;&gt;upgrade&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1773f52a457c6794f4a7d066fbfe3f05c2a765e3" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;erlsrv&lt;/code&gt; is not a general service utility for Windows, but designed for embedded Erlang systems.</source>
          <target state="translated">것을 알 수 &lt;code&gt;erlsrv&lt;/code&gt; 는 Windows 용 일반 서비스 유틸리티가 아니라 임베디드 얼랑 시스템 용으로 설계.</target>
        </trans-unit>
        <trans-unit id="6e432f3e9c9e76ab03e11cf1eee130a983560aaa" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;file:read_link/1&lt;/code&gt; always returns an error if the link points to an invalid filename.</source>
          <target state="translated">것을 알 수 &lt;code&gt;file:read_link/1&lt;/code&gt; 항상 링크가 가리키는 경우 잘못된 파일 이름에 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2b5eb19b7b6106c9b1640932097ed40e803eee2b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;level&lt;/code&gt; and &lt;code&gt;filters&lt;/code&gt; are obeyed by Logger itself before forwarding the log events to each handler, while &lt;code&gt;formatter&lt;/code&gt; and all handler specific options are left to the handler implementation.</source>
          <target state="translated">공지 사항 그 &lt;code&gt;level&lt;/code&gt; 과 &lt;code&gt;filters&lt;/code&gt; 동안, 각 처리기에 로그 이벤트를 전달하기 전에 로거 자체 순종하는 &lt;code&gt;formatter&lt;/code&gt; 모든 핸들러 특정 옵션이 핸들러 구현에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd581a406752603573ad8774cbe10adf7b5ab0d3" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;n3&lt;/code&gt; and &lt;code&gt;creation&lt;/code&gt; are limited in precision, so only the low 18 and 2 bits of these numbers are used.</source>
          <target state="translated">알 &lt;code&gt;n3&lt;/code&gt; 및 &lt;code&gt;creation&lt;/code&gt; 정밀도로 한정되므로, 단지 낮은 수치 18이 2 비트가 사용된다.</target>
        </trans-unit>
        <trans-unit id="5034ccb8d85a6d7fd7e77e33c704f31bb33968e9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;creation&lt;/code&gt; are limited in precision, so only the low 18 and 2 bits of these numbers are used.</source>
          <target state="translated">알 &lt;code&gt;number&lt;/code&gt; 및 &lt;code&gt;creation&lt;/code&gt; 정밀 이러한 번호 18, 2 비트가 사용되는 정도로 단지 낮은 제한된다.</target>
        </trans-unit>
        <trans-unit id="8f334a2a965ad63c5f73db11176f314492958179" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;relative_product([R1],&amp;nbsp;R2)&lt;/code&gt; is different from &lt;code&gt;relative_product(R1,&amp;nbsp;R2)&lt;/code&gt;; the list of one element is not identified with the element itself.</source>
          <target state="translated">공지 것을 &lt;code&gt;relative_product([R1],&amp;nbsp;R2)&lt;/code&gt; 상이한 &lt;code&gt;relative_product(R1,&amp;nbsp;R2)&lt;/code&gt; ; 하나의 요소 목록은 요소 자체로 식별되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3688c0644193c1e6416001dafdd6919064e11078" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;stdin&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are for buffered input/output and must &lt;strong&gt;not&lt;/strong&gt; be used for the communication with Erlang.</source>
          <target state="translated">공지 것으로 &lt;code&gt;stdin&lt;/code&gt; 와 &lt;code&gt;stdout&lt;/code&gt; 버퍼, 입력 / 출력하고 있어야 &lt;strong&gt;하지&lt;/strong&gt; 얼랑과 통신에 이용 될 수있다.</target>
        </trans-unit>
        <trans-unit id="bc49c747fe59c837c18160b1da219cb9bb69f688" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;tut9:test_if(33,33)&lt;/code&gt; does not cause any condition to succeed. This leads to the run time error &lt;code&gt;if_clause&lt;/code&gt;, here nicely formatted by the shell. See &lt;code&gt;Guard Sequences&lt;/code&gt; for details of the many guard tests available.</source>
          <target state="translated">것을 알 수 &lt;code&gt;tut9:test_if(33,33)&lt;/code&gt; 어떤 조건이 성공을 발생하지 않습니다. 이로 인해 런타임 오류 &lt;code&gt;if_clause&lt;/code&gt; 가 발생 하는데 , 여기서는 쉘에 의해 형식화됩니다. 사용 가능한 많은 가드 테스트에 대한 자세한 내용은 &lt;code&gt;Guard Sequences&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4a0e079c5d305d9ddb09850abdc7996b675aca1" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;{active, true}&lt;/code&gt; mode provides no flow control; a fast sender can easily overflow the receiver with incoming messages. The same is true for &lt;code&gt;{active, N}&lt;/code&gt; mode, while the message count is greater than zero.</source>
          <target state="translated">공지 사항 그게 &lt;code&gt;{active, true}&lt;/code&gt; 모드는 어떤 흐름 제어를 제공하지 않는다; 빠른 발신자는 수신 메시지로 수신자를 쉽게 넘칠 수 있습니다. &lt;code&gt;{active, N}&lt;/code&gt; 모드 의 경우에도 마찬가지이며 메시지 수가 0보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="1da54ccbef9166436330bfc6fd162fc86bc65127" translate="yes" xml:space="preserve">
          <source>Notice that Mnesia can be connected to other nodes than those returned in &lt;code&gt;ReturnValue&lt;/code&gt;.</source>
          <target state="translated">Mnesia는 &lt;code&gt;ReturnValue&lt;/code&gt; 에 반환 된 노드 이외의 다른 노드에 연결될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca1604ae3c36200717b82378dacc675667bae387" translate="yes" xml:space="preserve">
          <source>Notice that USM users are needed for SNMPv3 configuration and are not to be confused with users.</source>
          <target state="translated">USM 사용자는 SNMPv3 구성에 필요하며 사용자와 혼동해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2103331cf1bc333f91a2382aff0f9f89c72945ce" translate="yes" xml:space="preserve">
          <source>Notice that UTF-8 is &lt;strong&gt;not&lt;/strong&gt; compatible with bytewise representation for code points from 128 through 255, so an ISO Latin-1 bytewise representation is generally incompatible with UTF-8.</source>
          <target state="translated">UTF-8은 128에서 255까지의 코드 포인트에 대한 바이트 단위 표현과 호환 &lt;strong&gt;되지 않으므로&lt;/strong&gt; ISO Latin-1 바이트 단위 표현은 일반적으로 UTF-8과 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a6c1827f210e0e7a2b7f47b6b3a1bd1a9af4a39" translate="yes" xml:space="preserve">
          <source>Notice that \g{...} (Perl syntax) and \g&amp;lt;...&amp;gt; (Oniguruma syntax) are &lt;strong&gt;not&lt;/strong&gt; synonymous. The former is a back reference; the latter is a subroutine call.</source>
          <target state="translated">\ g {...} (Perl 구문) 및 \ g &amp;lt;...&amp;gt; (Oniguruma 구문)은 동의어 가 &lt;strong&gt;아닙니다&lt;/strong&gt; . 전자는 역 참조이다. 후자는 서브 루틴 호출입니다.</target>
        </trans-unit>
        <trans-unit id="8de6476a9a9e34e743ca7bda411e9e36e779275d" translate="yes" xml:space="preserve">
          <source>Notice that a &lt;code&gt;gen_server&lt;/code&gt; process does not trap exit signals automatically, this must be explicitly initiated in the callback module.</source>
          <target state="translated">공지 사항이 있음을 &lt;code&gt;gen_server&lt;/code&gt; 의 과정이 아닌 트랩 출구 신호를 자동으로 수행이 명시 적으로 콜백 모듈에서 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="c8c968975fc7502f69e3fa5a0ebf2c3346e29c96" translate="yes" xml:space="preserve">
          <source>Notice that a &lt;code&gt;gen_statem&lt;/code&gt; does not trap exit signals automatically, this must be explicitly initiated in the callback module (by calling &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt;.</source>
          <target state="translated">공지는 것을 &lt;code&gt;gen_statem&lt;/code&gt; 가 되지 트랩 출구 신호를 자동으로 수행이 명시 적으로 호출하여 (콜백 모듈에서 시작되어야합니다 &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="755428447f434586578dae042ae0cabd4f3e660d" translate="yes" xml:space="preserve">
          <source>Notice that a conditional subpattern is not considered as having two alternatives, as only one is ever used. That is, the | character in a conditional subpattern has a different meaning. Ignoring whitespace, consider:</source>
          <target state="translated">조건부 하위 패턴은 하나만 사용되므로 두 가지 대안이있는 것으로 간주되지 않습니다. 즉, | 조건부 하위 패턴의 문자는 다른 의미를 갖습니다. 공백을 무시하고 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="88df944878b2dfd57638c11c5f3a67b0b37ab5eb" translate="yes" xml:space="preserve">
          <source>Notice that a driver binary has an internal reference counter. This means that calling &lt;code&gt;driver_free_binary&lt;/code&gt;, it may not actually dispose of it. If it is sent to the emulator, it can be referenced there.</source>
          <target state="translated">드라이버 바이너리에는 내부 참조 카운터가 있습니다. 이것은 &lt;code&gt;driver_free_binary&lt;/code&gt; 호출 하면 실제로 처리하지 않을 수 있습니다. 에뮬레이터로 보내지면 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e57d3be6f96e69f222e396adc45b370579e57d1d" translate="yes" xml:space="preserve">
          <source>Notice that a faked CPU topology that does not reflect how the real CPU topology looks like is likely to decrease the performance of the runtime system.</source>
          <target state="translated">실제 CPU 토폴로지의 모양을 반영하지 않는 가짜 CPU 토폴로지는 런타임 시스템의 성능을 저하시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="760aec758f8e9eb253ec969db2ad5ac99a17c5c4" translate="yes" xml:space="preserve">
          <source>Notice that a possessive quantifier can be used with an entire group, for example:</source>
          <target state="translated">소유 그룹화는 전체 그룹과 함께 사용할 수 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="dbbbc01405d36730105f83c66e9de97063c42e08" translate="yes" xml:space="preserve">
          <source>Notice that a runtime system using shared reader groups benefits from &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;binding schedulers to logical processors&lt;/a&gt;&lt;/code&gt;, as the reader groups are distributed better between schedulers.</source>
          <target state="translated">리더 그룹이 스케줄러간에 더 잘 분배되므로 공유 리더 그룹을 사용하는 런타임 시스템은 &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;binding schedulers to logical processors&lt;/a&gt;&lt;/code&gt; 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b74f7fd747ff5bbe77c7879d54040bcdfa2b336e" translate="yes" xml:space="preserve">
          <source>Notice that a scheduler can also be busy even if the OS has scheduled out the scheduler thread.</source>
          <target state="translated">OS가 스케줄러 스레드를 스케줄 한 경우에도 스케줄러가 사용 중일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fb44615a33547638a4835f2bb25ba9f7f738524" translate="yes" xml:space="preserve">
          <source>Notice that all child processes implemented using the standard OTP behavior modules automatically adhere to the shutdown protocol.</source>
          <target state="translated">표준 OTP 동작 모듈을 사용하여 구현 된 모든 하위 프로세스는 자동으로 종료 프로토콜을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="022007469674875a658f3171e3ee5f06bc52c5ff" translate="yes" xml:space="preserve">
          <source>Notice that all eight levels can occur in the heading, not only &lt;code&gt;ERROR&lt;/code&gt;, &lt;code&gt;WARNING&lt;/code&gt; or &lt;code&gt;INFO&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; produces. And microseconds are added at the end of the timestamp.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; 가 생성하는 것처럼 &lt;code&gt;ERROR&lt;/code&gt; , &lt;code&gt;WARNING&lt;/code&gt; 또는 &lt;code&gt;INFO&lt;/code&gt; 뿐만 아니라 8 가지 레벨 모두 제목에서 발생할 수 있습니다 . 타임 스탬프 끝에 마이크로 초가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a99f104a56eef6a6e79ebf5f27128ede71470917" translate="yes" xml:space="preserve">
          <source>Notice that all records in the last fragment must be moved to another fragment, as the entire fragment is deleted.</source>
          <target state="translated">전체 조각이 삭제되므로 마지막 조각의 모든 레코드를 다른 조각으로 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="43d4ab77c71efe5ed63400db11c28f943feb8544" translate="yes" xml:space="preserve">
          <source>Notice that all the output is received on gollum. This is because the I/O system finds out where the process is spawned from and sends all output there.</source>
          <target state="translated">모든 출력물은 골룸에서 수신됩니다. 이는 I / O 시스템이 프로세스가 생성 된 위치를 찾아서 모든 출력을 전송하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="afcf6c07d5d0261b9d60900ac2418148455d55af" translate="yes" xml:space="preserve">
          <source>Notice that although a user has requested schedulers to be bound, they can silently have failed to bind. To inspect the scheduler bindings, call &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용자가 스케줄러를 바인드하도록 요청했지만 자동으로 바인드하지 못했습니다. 스케줄러 바인딩을 검사하려면 &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5737b0ee42e7396b1279449506400af6d4d0399" translate="yes" xml:space="preserve">
          <source>Notice that although the keyword &lt;code&gt;catch&lt;/code&gt; is used in the &lt;code&gt;try&lt;/code&gt; expression, there is not a &lt;code&gt;catch&lt;/code&gt; expression within the &lt;code&gt;try&lt;/code&gt; expression.</source>
          <target state="translated">키워드 있지만 것을 알 &lt;code&gt;catch&lt;/code&gt; 에 사용되는 &lt;code&gt;try&lt;/code&gt; 표현하는이없는 &lt;code&gt;catch&lt;/code&gt; 내에서 표현 &lt;code&gt;try&lt;/code&gt; 표현.</target>
        </trans-unit>
        <trans-unit id="994f867c355c6f90c5d005f5efe72e6205d3566f" translate="yes" xml:space="preserve">
          <source>Notice that an application can always be stopped explicitly by calling &lt;code&gt;stop/1&lt;/code&gt;. Regardless of the type of the application, no other applications are affected.</source>
          <target state="translated">&lt;code&gt;stop/1&lt;/code&gt; 을 호출하여 응용 프로그램을 항상 명시 적으로 중지 할 수 있습니다 . 응용 프로그램 유형에 관계없이 다른 응용 프로그램은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da2ab21694a90b36239b6620bd78657b3c952a69" translate="yes" xml:space="preserve">
          <source>Notice that an event manager &lt;strong&gt;does&lt;/strong&gt; trap exit signals automatically.</source>
          <target state="translated">이벤트 관리자 &lt;strong&gt;는&lt;/strong&gt; 종료 신호를 자동으로 트랩합니다.</target>
        </trans-unit>
        <trans-unit id="49dfb54eadef728066f7af6aab3f97cecf7b3fb1" translate="yes" xml:space="preserve">
          <source>Notice that an exiting port exists, but is not open.</source>
          <target state="translated">종료 포트가 있지만 열려 있지 않은지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e9791862f66b81843f5294813c5a3786cc4d5cd0" translate="yes" xml:space="preserve">
          <source>Notice that an exiting process exists, but is not alive. That is, &lt;code&gt;is_process_alive/1&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; for an exiting process, but its process identifier is part of the result returned from &lt;code&gt;processes/0&lt;/code&gt;.</source>
          <target state="translated">종료 프로세스가 존재하지만 활성 상태가 아닙니다. 즉, &lt;code&gt;is_process_alive/1&lt;/code&gt; 은 종료 프로세스에 대해 &lt;code&gt;false&lt;/code&gt; 를 리턴 하지만 프로세스 ID는 &lt;code&gt;processes/0&lt;/code&gt; 에서 리턴 된 결과의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="e30baa54b514ae9385a376058a73878724a1d09c" translate="yes" xml:space="preserve">
          <source>Notice that any modifying operations, that is, &lt;code&gt;mnesia:write&lt;/code&gt; or &lt;code&gt;mnesia:delete&lt;/code&gt;, that are done between the &lt;code&gt;mnesia:select/4&lt;/code&gt; and &lt;code&gt;mnesia:select/1&lt;/code&gt; calls are not visible in the result.</source>
          <target state="translated">&lt;code&gt;mnesia:select/4&lt;/code&gt; 및 &lt;code&gt;mnesia:select/1&lt;/code&gt; 호출 사이에서 수행되는 수정 조작 (즉, &lt;code&gt;mnesia:write&lt;/code&gt; 또는 &lt;code&gt;mnesia:delete&lt;/code&gt; ) 은 결과에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96c91a61c3b4aa6acc5afde73b1f0c373cd23ed1" translate="yes" xml:space="preserve">
          <source>Notice that any process can close a port using &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; as if it itself was the port owner, but the reply always goes to the port owner.</source>
          <target state="translated">모든 프로세스는 &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; 사용하여 포트를 닫을 수 있습니다 . {PortOwner, close} 자체는 포트 소유자 인 것처럼 보이지만 응답은 항상 포트 소유자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d4cc8e9c5e1271318aa4ada63b47a96351832036" translate="yes" xml:space="preserve">
          <source>Notice that any process can send to a port using &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; as if it itself was the port owner.</source>
          <target state="translated">모든 프로세스는 &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; 사용하여 포트로 보낼 수 있습니다 . 마치 포트 소유자 인 것처럼 {PortOwner, {command, Data}} .</target>
        </trans-unit>
        <trans-unit id="1824595a1c80b7075f5376bc1cd1c936c8d424db" translate="yes" xml:space="preserve">
          <source>Notice that any process can set the port owner using &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; as if it itself was the port owner, but the reply always goes to the port owner.</source>
          <target state="translated">모든 프로세스는 &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; 사용하여 포트 소유자를 설정할 수 있습니다 . {PortOwner, {connect, Pid}} 는 마치 포트 소유자 인 것처럼 응답하지만 항상 포트 소유자에게 응답이 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="a98b3f3c42ef6f33bfe8a7e8fccfe1473542b5f7" translate="yes" xml:space="preserve">
          <source>Notice that any tuple stored in the table must have at least &lt;code&gt;Pos&lt;/code&gt; number of elements.</source>
          <target state="translated">테이블에 저장된 튜플에는 최소한 &lt;code&gt;Pos&lt;/code&gt; 수의 요소 가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="dd5de2485d7d394ae933d91e2e848ae72df0affa" translate="yes" xml:space="preserve">
          <source>Notice that as a driver binary is shared by the driver and the emulator. A binary received from the emulator or sent to the emulator must not be changed by the driver.</source>
          <target state="translated">드라이버 바이너리는 드라이버와 에뮬레이터에서 공유합니다. 에뮬레이터에서 받거나 에뮬레이터로 보낸 이진은 드라이버가 변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f889fc9740aed7e3095d419001ad1fb0ce64b212" translate="yes" xml:space="preserve">
          <source>Notice that as this is &lt;code&gt;server_transfer/5&lt;/code&gt;, it is not the same as the previous function &lt;code&gt;server_transfer/4&lt;/code&gt;. Another &lt;code&gt;keysearch&lt;/code&gt; is done on &lt;code&gt;User_List&lt;/code&gt; to find the pid of the client corresponding to fred:</source>
          <target state="translated">이것이 &lt;code&gt;server_transfer/5&lt;/code&gt; 이므로 이전 함수 &lt;code&gt;server_transfer/4&lt;/code&gt; 와 같지 않습니다 . fred에 해당하는 클라이언트의 pid를 찾기 위해 &lt;code&gt;User_List&lt;/code&gt; 에서 다른 키 &lt;code&gt;keysearch&lt;/code&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="8fe86ce5fa59a3562a829573aaf5b3dfd2379e17" translate="yes" xml:space="preserve">
          <source>Notice that bit string patterns cannot be nested.</source>
          <target state="translated">비트 문자열 패턴은 중첩 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="aa80432fca6a469445d85d7dfaebe88b1a98b7f2" translate="yes" xml:space="preserve">
          <source>Notice that by passing the &lt;code&gt;positive&lt;/code&gt; modifier you will get heap allocated integers (bignums) quicker.</source>
          <target state="translated">&lt;code&gt;positive&lt;/code&gt; 수정자를 전달하면 힙 할당 정수 (큰 숫자)가 더 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="6a919935e37a99f7e411ad64d7426c9cc07d3818" translate="yes" xml:space="preserve">
          <source>Notice that calling (nesting) &lt;code&gt;mnesia:[a]sync_dirty&lt;/code&gt; inside a transaction-context inherits the transaction semantics.</source>
          <target state="translated">트랜잭션 컨텍스트 내에서 &lt;code&gt;mnesia:[a]sync_dirty&lt;/code&gt; 를 호출 (중첩) 하면 트랜잭션 시맨틱이 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="28de43964f8d0b0f5ebe0eeea1c37e096ff9f1e4" translate="yes" xml:space="preserve">
          <source>Notice that calling (nesting) a &lt;code&gt;mnesia:ets&lt;/code&gt; inside a transaction-context inherits the transaction semantics.</source>
          <target state="translated">트랜잭션 컨텍스트 내에서 &lt;code&gt;mnesia:ets&lt;/code&gt; 를 호출 (중첩) 하면 트랜잭션 시맨틱이 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="ccdf30109e045224354b9a92051a3710e7da0269" translate="yes" xml:space="preserve">
          <source>Notice that calling &lt;code&gt;complex2:foo/1&lt;/code&gt; and &lt;code&gt;complex2:bar/1&lt;/code&gt; results in the tuple &lt;code&gt;{foo,X}&lt;/code&gt; or &lt;code&gt;{bar,Y}&lt;/code&gt; being sent to the &lt;code&gt;complex&lt;/code&gt; process, which codes them as binaries and sends them to the port. This means that the C program must be able to handle these two tuples.</source>
          <target state="translated">&lt;code&gt;complex2:foo/1&lt;/code&gt; 및 &lt;code&gt;complex2:bar/1&lt;/code&gt; 을 호출 하면 튜플 &lt;code&gt;{foo,X}&lt;/code&gt; 또는 &lt;code&gt;{bar,Y}&lt;/code&gt; 가 &lt;code&gt;complex&lt;/code&gt; 프로세스 로 전송 되어 이진으로 코딩되어 포트로 전송됩니다. 이것은 C 프로그램이이 두 튜플을 처리 할 수 ​​있어야한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f66f156315ef693448711da956208a1b9d370baa" translate="yes" xml:space="preserve">
          <source>Notice that calling this function when supervising many childrens under low memory conditions can cause an out of memory exception.</source>
          <target state="translated">메모리 부족 상태에서 많은 어린이를 감독 할 때이 기능을 호출하면 메모리 부족 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36d8020652ba123cb254176a43a2c994dabfe6c7" translate="yes" xml:space="preserve">
          <source>Notice that chunked encoding can add headers so that there are more headers in the &lt;code&gt;stream_end&lt;/code&gt; message than in &lt;code&gt;stream_start&lt;/code&gt;. When streaming to a file and the request is asynchronous, the message &lt;code&gt;{http, {RequestId, saved_to_file}}&lt;/code&gt; is sent.</source>
          <target state="translated">청크 인코딩은 &lt;code&gt;stream_start&lt;/code&gt; 메시지보다 &lt;code&gt;stream_end&lt;/code&gt; 메시지 에 더 많은 헤더가 있도록 헤더를 추가 할 수 있습니다 . 파일로 스트리밍하고 요청이 비동기 인 경우 &lt;code&gt;{http, {RequestId, saved_to_file}}&lt;/code&gt; 가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="8eacfb231646f67a84dd48c38b3252b46ba678d6" translate="yes" xml:space="preserve">
          <source>Notice that currently &lt;code&gt;ordered_set&lt;/code&gt; is not supported for &lt;code&gt;disc_only_copies&lt;/code&gt; tables.</source>
          <target state="translated">현재 &lt;code&gt;ordered_set&lt;/code&gt; 은 &lt;code&gt;disc_only_copies&lt;/code&gt; 테이블에 대해 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b6f86d7c1e62cac7ff19af2ed505338d552e40c3" translate="yes" xml:space="preserve">
          <source>Notice that currently &lt;code&gt;ordered_set&lt;/code&gt; is not supported for &lt;code&gt;disc_only_copies&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;ordered_set&lt;/code&gt; 은 &lt;code&gt;disc_only_copies&lt;/code&gt; 에 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c1ba106fc749c03f0e8e929a856488e3fe0469ca" translate="yes" xml:space="preserve">
          <source>Notice that default option &lt;code&gt;{active, true}&lt;/code&gt; cannot be changed, for internal reasons.</source>
          <target state="translated">내부 옵션으로 기본 옵션 &lt;code&gt;{active, true}&lt;/code&gt; 를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f9c5bb258ea4f52af5df09054ae473cf25538fc1" translate="yes" xml:space="preserve">
          <source>Notice that distribution sockets disable the use of &lt;code&gt;high_msgq_watermark&lt;/code&gt; and &lt;code&gt;low_msgq_watermark&lt;/code&gt;. Instead they use the &lt;code&gt;distribution buffer busy limit&lt;/code&gt;, which is a similar feature.</source>
          <target state="translated">분배 소켓은 &lt;code&gt;high_msgq_watermark&lt;/code&gt; 및 &lt;code&gt;low_msgq_watermark&lt;/code&gt; 사용을 비활성화합니다 . 대신 그들은 유사한 기능인 &lt;code&gt;distribution buffer busy limit&lt;/code&gt; 사용 제한 을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="8e359baa81f7be3463d30d7e81f74f0d6daa7f44" translate="yes" xml:space="preserve">
          <source>Notice that distribution sockets disable the use of &lt;code&gt;high_msgq_watermark&lt;/code&gt; and &lt;code&gt;low_msgq_watermark&lt;/code&gt;. Instead use the &lt;code&gt;distribution buffer busy limit&lt;/code&gt;, which is a similar feature.</source>
          <target state="translated">분배 소켓은 &lt;code&gt;high_msgq_watermark&lt;/code&gt; 및 &lt;code&gt;low_msgq_watermark&lt;/code&gt; 사용을 비활성화합니다 . 대신 유사한 기능인 &lt;code&gt;distribution buffer busy limit&lt;/code&gt; 사용 제한을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d5e701c93b303b29d937ac4bace336c512ed95b" translate="yes" xml:space="preserve">
          <source>Notice that each of the assertions is applied independently at the same point in the subject string. First there is a check that the previous three characters are all digits, and then there is a check that the same three characters are not &quot;999&quot;. This pattern does &lt;strong&gt;not&lt;/strong&gt; match &quot;foo&quot; preceded by six characters, the first of which are digits and the last three of which are not &quot;999&quot;. For example, it does not match &quot;123abcfoo&quot;. A pattern to do that is the following:</source>
          <target state="translated">각 어설 션은 제목 문자열의 동일한 지점에서 독립적으로 적용됩니다. 먼저 앞의 세 문자가 모두 숫자인지 확인한 다음 동일한 세 문자가 &quot;999&quot;가 아닌지 확인합니다. 이 패턴은 않습니다 &lt;strong&gt;하지&lt;/strong&gt; &quot;999&quot;하지 여섯 개 자리 중 첫 번째의 문자, 그리고 마지막 세 앞에 &quot;foo는&quot;일치합니다. 예를 들어 &quot;123abcfoo&quot;와 일치하지 않습니다. 이를 수행하는 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5c69517c533a13ffb06612150fd12d6557f1bab" translate="yes" xml:space="preserve">
          <source>Notice that emptying the call stack means that any surrounding &lt;code&gt;catch&lt;/code&gt; is removed and must be re-inserted after hibernation. One effect of this is that processes started using &lt;code&gt;proc_lib&lt;/code&gt; (also indirectly, such as &lt;code&gt;gen_server&lt;/code&gt; processes), are to use &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt; instead, to ensure that the exception handler continues to work when the process wakes up.</source>
          <target state="translated">콜 스택을 비우면 주변 &lt;code&gt;catch&lt;/code&gt; 를 제거하고 최대 절전 모드 후에 다시 삽입해야합니다. 이것의 한 가지 효과는 &lt;code&gt;proc_lib&lt;/code&gt; 를 사용하여 시작된 프로세스 ( &lt;code&gt;gen_server&lt;/code&gt; 프로세스 와 같은 간접 프로세스)가 &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt; 를 대신 사용하여 프로세스가 깨어 났을 때 예외 처리기가 계속 작동하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c5a1bb27af980314db81c1b30e32509a27fc50e5" translate="yes" xml:space="preserve">
          <source>Notice that error handling is omitted from the code:</source>
          <target state="translated">코드에서 오류 처리가 생략되었습니다.</target>
        </trans-unit>
        <trans-unit id="ac90f95ed355ecf5e134f5c94815fdaaf2216766" translate="yes" xml:space="preserve">
          <source>Notice that every guard test has the same source form as some expression, and is represented in the same way as the corresponding expression.</source>
          <target state="translated">모든 가드 테스트는 일부 표현식과 동일한 소스 형식을 가지며 해당 표현식과 동일한 방식으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="12ac9f06be5d0c942954f11af7bd16a9c92f71af" translate="yes" xml:space="preserve">
          <source>Notice that every pattern has the same source form as some expression, and is represented in the same way as the corresponding expression.</source>
          <target state="translated">모든 패턴은 일부 표현식과 동일한 소스 형식을 가지며 해당 표현식과 동일한 방식으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="22d44122084b22fa6c5e4d72f866f1a0cdc53879" translate="yes" xml:space="preserve">
          <source>Notice that for SCTP sockets this function returns only one of the socket addresses. Function &lt;code&gt;&lt;a href=&quot;#socknames-1&quot;&gt;socknames/1,2&lt;/a&gt;&lt;/code&gt; returns all.</source>
          <target state="translated">SCTP 소켓의 경우이 함수는 소켓 주소 중 하나만 반환합니다. 기능 &lt;code&gt;&lt;a href=&quot;#socknames-1&quot;&gt;socknames/1,2&lt;/a&gt;&lt;/code&gt; 반환을 모두.</target>
        </trans-unit>
        <trans-unit id="3eea76ec53bc50101ada93a2881a73a66d999f61" translate="yes" xml:space="preserve">
          <source>Notice that for SCTP sockets, this function returns only one of the peer addresses of the socket. Function &lt;code&gt;&lt;a href=&quot;#peernames-1&quot;&gt;peernames/1,2&lt;/a&gt;&lt;/code&gt; returns all.</source>
          <target state="translated">SCTP 소켓의 경우이 함수는 소켓의 피어 주소 중 하나만 반환합니다. 함수 &lt;code&gt;&lt;a href=&quot;#peernames-1&quot;&gt;peernames/1,2&lt;/a&gt;&lt;/code&gt; 는 모두를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8b549a78c27b0039d4ff0cb9fa34e52e88f8ae6e" translate="yes" xml:space="preserve">
          <source>Notice that for any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process is assumed to terminate because of an error and an error report is issued using &lt;code&gt;logger(3)&lt;/code&gt;.</source>
          <target state="translated">이외의 다른 이유로 통지 &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;shutdown&lt;/code&gt; , 또는 &lt;code&gt;{shutdown,Term}&lt;/code&gt; 는 &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스가 오류로 인해 종료 가정 및 오류 보고서를 사용하여 발행 &lt;code&gt;logger(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f2fde3695426d831d6f9a88359f21930dd08692" translate="yes" xml:space="preserve">
          <source>Notice that for any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; is assumed to terminate because of an error and an error report is issued using &lt;code&gt;logger(3)&lt;/code&gt;.</source>
          <target state="translated">이외의 다른 이유로 통지 &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;shutdown&lt;/code&gt; , 또는 &lt;code&gt;{shutdown,Term}&lt;/code&gt; 의 &lt;code&gt;gen_statem&lt;/code&gt; 이 오류로 인해 종료 가정 및 오류 보고서를 사용하여 발행 &lt;code&gt;logger(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6c994ab42bf95f015c8131e40fece01289a1526" translate="yes" xml:space="preserve">
          <source>Notice that for best performance, &lt;code&gt;select&lt;/code&gt; is to be used before any modifying operations are done on that table in the same transaction. That is, do not use &lt;code&gt;mnesia:write&lt;/code&gt; or &lt;code&gt;mnesia:delete&lt;/code&gt; before a &lt;code&gt;mnesia:select&lt;/code&gt;. For efficiency, &lt;code&gt;NObjects&lt;/code&gt; is a recommendation only and the result can contain anything from an empty list to all available results.</source>
          <target state="translated">최상의 성능을 얻으려면 동일한 트랜잭션의 해당 테이블에서 수정 작업을 수행하기 전에 &lt;code&gt;select&lt;/code&gt; 가 사용됩니다. 즉, &lt;code&gt;mnesia:select&lt;/code&gt; 전에 &lt;code&gt;mnesia:write&lt;/code&gt; 또는 &lt;code&gt;mnesia:delete&lt;/code&gt; 를 사용하지 마십시오 . 효율성을 위해 &lt;code&gt;NObjects&lt;/code&gt; 는 권장 사항 일 뿐이며 결과는 빈 목록에서 사용 가능한 모든 결과에 이르기까지 모든 것을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="575b65587388a5c28bf652744375022398c20ce2" translate="yes" xml:space="preserve">
          <source>Notice that for best performance, &lt;code&gt;select&lt;/code&gt; is to be used before any modifying operations are done on that table in the same transaction. That is, do not use &lt;code&gt;write&lt;/code&gt; or &lt;code&gt;delete&lt;/code&gt; before a &lt;code&gt;select&lt;/code&gt;.</source>
          <target state="translated">최상의 성능을 얻으려면 동일한 트랜잭션의 해당 테이블에서 수정 작업을 수행하기 전에 &lt;code&gt;select&lt;/code&gt; 가 사용됩니다. 즉, &lt;code&gt;select&lt;/code&gt; 전에 &lt;code&gt;write&lt;/code&gt; 또는 &lt;code&gt;delete&lt;/code&gt; 를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="a8e4ee50b8c86a9d97d28e810a76ef00e7ee22cf" translate="yes" xml:space="preserve">
          <source>Notice that for table type &lt;code&gt;ordered_set&lt;/code&gt;, &lt;code&gt;safe_fixtable/2&lt;/code&gt; is not necessary, as calls to &lt;code&gt;first/1&lt;/code&gt; and &lt;code&gt;next/2&lt;/code&gt; always succeed.</source>
          <target state="translated">공지 사항 테이블 유형에 대한 것을 &lt;code&gt;ordered_set&lt;/code&gt; , &lt;code&gt;safe_fixtable/2&lt;/code&gt; 호출로 필요하지 않습니다 &lt;code&gt;first/1&lt;/code&gt; 와 &lt;code&gt;next/2&lt;/code&gt; 항상 성공.</target>
        </trans-unit>
        <trans-unit id="fadf7fb473798e1c8fbe8d738e7d7fba94595b7d" translate="yes" xml:space="preserve">
          <source>Notice that for temporary children, the child specification is automatically deleted when the child terminates; thus, it is not possible to restart such children.</source>
          <target state="translated">임시 하위의 경우 하위가 종료되면 하위 스펙이 자동으로 삭제됩니다. 따라서 해당 하위를 다시 시작할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b8f8d69fc55404a3f5202b0589ebb12fa1fbadb2" translate="yes" xml:space="preserve">
          <source>Notice that function &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefold/1&lt;/a&gt;&lt;/code&gt; should be used when converting a string to be tested for equality.</source>
          <target state="translated">테스트 할 문자열을 동일하게 변환 할 때는 &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefold/1&lt;/a&gt;&lt;/code&gt; 함수를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="405372cbb8689b7bb9d46fd60b33792430970cfc" translate="yes" xml:space="preserve">
          <source>Notice that function &lt;code&gt;&lt;a href=&quot;ttb#start_trace-4&quot;&gt;ttb:start_trace/4&lt;/a&gt;&lt;/code&gt; can be used as help as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ttb#start_trace-4&quot;&gt;ttb:start_trace/4&lt;/a&gt;&lt;/code&gt; 함수 는 다음과 같이 도움말로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de0bcaa7532bb6bae36e73c3763ba087654d90d2" translate="yes" xml:space="preserve">
          <source>Notice that functions &lt;code&gt;chunk/2,3&lt;/code&gt;, &lt;code&gt;bchunk/2,3&lt;/code&gt;, and &lt;code&gt;chunk_step/3&lt;/code&gt; do not affect any value returned by &lt;code&gt;info/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;chunk/2,3&lt;/code&gt; , &lt;code&gt;bchunk/2,3&lt;/code&gt; 및 &lt;code&gt;chunk_step/3&lt;/code&gt; 함수 는 &lt;code&gt;info/1&lt;/code&gt; 에 의해 리턴 된 값에 영향을주지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="da3a6b0a2ad8ae3b2ff383a08f0cdcfac8ef3282" translate="yes" xml:space="preserve">
          <source>Notice that if &lt;code&gt;init_per_suite&lt;/code&gt; and &lt;code&gt;end_per_suite&lt;/code&gt; do not exist in the suite, &lt;code&gt;Common Test&lt;/code&gt; calls dummy functions (with the same names) instead, so that output generated by hook functions can be saved to the log files for these dummies. For details, see &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#manipulating&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">주의 경우 것으로 &lt;code&gt;init_per_suite&lt;/code&gt; 하고 &lt;code&gt;end_per_suite&lt;/code&gt; 제품군에 존재하지 않는, &lt;code&gt;Common Test&lt;/code&gt; 후크 기능에 의해 생성 된 출력하는이 인형의 로그 파일에 저장 될 수 있도록, 대신에 (같은 이름) 더미 함수를 호출합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#manipulating&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aee52a26c1c7778ed0141e880006af8c079abe71" translate="yes" xml:space="preserve">
          <source>Notice that if &lt;code&gt;parallel_login&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, only one client at a time can be in the authentication phase.</source>
          <target state="translated">경우 통지 &lt;code&gt;parallel_login&lt;/code&gt; 이 있다 &lt;code&gt;false&lt;/code&gt; , 한 번에 하나의 클라이언트가 인증 단계에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2ae74861195afaaaecbb5004aa3195b54b0af5d" translate="yes" xml:space="preserve">
          <source>Notice that if a &quot;technically built in function&quot; (that is, a function not written in Erlang) is traced, the &lt;code&gt;caller&lt;/code&gt; function sometimes returns the atom &lt;code&gt;undefined&lt;/code&gt;. The calling Erlang function is not available during such calls.</source>
          <target state="translated">&quot;기술적으로 내장 된 함수&quot;(즉, Erlang으로 작성되지 않은 함수)가 추적되면 &lt;code&gt;caller&lt;/code&gt; 함수는 때때로 원자 &lt;code&gt;undefined&lt;/code&gt; 를 리턴합니다 . 이러한 호출 중에는 호출 Erlang 기능을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f92e3c3fb0383592cf170b7659be5a996f925ab5" translate="yes" xml:space="preserve">
          <source>Notice that if changing the configuration of the handler in runtime, the &lt;code&gt;type&lt;/code&gt; parameter must not be modified.</source>
          <target state="translated">런타임에서 핸들러 구성을 변경하는 경우 &lt;code&gt;type&lt;/code&gt; 매개 변수를 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="08ce68141a0a8640f5e5838bc1d59c39e01b55c0" translate="yes" xml:space="preserve">
          <source>Notice that if option &lt;code&gt;delayed_write&lt;/code&gt; was used when opening the file, &lt;code&gt;close/1&lt;/code&gt; can return an old write error and not even try to close the file. See &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일을 열 때 &lt;code&gt;delayed_write&lt;/code&gt; 옵션 이 사용 된 경우 &lt;code&gt;close/1&lt;/code&gt; 은 오래된 쓰기 오류를 반환하고 파일을 닫으려고 시도 할 수 없습니다. &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f698c6b4cd9ababf8d72ba0d6e493d5ad2e7229c" translate="yes" xml:space="preserve">
          <source>Notice that if the files &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; and &lt;code&gt;syslog.conf.OTP&lt;/code&gt; are not in directory &lt;code&gt;/etc&lt;/code&gt;, the file path in the second and third command must be modified.</source>
          <target state="translated">&lt;code&gt;syslog.conf.ORIG&lt;/code&gt; 및 &lt;code&gt;syslog.conf.OTP&lt;/code&gt; 파일 이 &lt;code&gt;/etc&lt;/code&gt; 디렉토리에 없으면 두 번째 및 세 번째 명령의 파일 경로를 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="245b52374d4b97b1ff0d2029d95aaa06dad4396b" translate="yes" xml:space="preserve">
          <source>Notice that if the original property term is to be preserved in the result when expanded, it must be included in the expansion list. The inserted terms are not expanded recursively. If &lt;code&gt;Expansions&lt;/code&gt; contains more than one property with the same key, only the first occurrence is used.</source>
          <target state="translated">확장시 원래 속성 용어가 결과에 유지되는 경우 확장 목록에 포함되어야합니다. 삽입 된 항은 재귀 적으로 확장되지 않습니다. &lt;code&gt;Expansions&lt;/code&gt; 에 동일한 키를 가진 둘 이상의 특성이 포함 된 경우 첫 번째 항목 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bc08705bf71174fc6daf6d3117f962a241235e84" translate="yes" xml:space="preserve">
          <source>Notice that if you restore to a non-empty registry, objects in the table overwrite objects in the registry with the same keys. Also, the &lt;strong&gt;entire&lt;/strong&gt; contents of the registry is marked as unmodified after the restore, including any modified objects that were not overwritten by the restore operation. This may not be your intention.</source>
          <target state="translated">비어 있지 않은 레지스트리로 복원하면 테이블의 오브젝트가 동일한 키로 레지스트리의 오브젝트를 겹쳐 씁니다. 또한 복원 작업으로 덮어 쓰지 않은 수정 된 개체를 포함하여 복원 후 레지스트리 의 &lt;strong&gt;전체&lt;/strong&gt; 내용이 수정되지 않은 것으로 표시됩니다. 이것은 당신의 의도가 아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="aef1c34d22b7f466e6132c1e85ef582f650007b8" translate="yes" xml:space="preserve">
          <source>Notice that if you store binary objects that are context-dependent (for example, containing pointers or open file descriptors), they lose their meaning if they are backed up to a &lt;code&gt;Mnesia&lt;/code&gt; table and later restored in a different context.</source>
          <target state="translated">컨텍스트에 의존하는 (예 : 포인터 또는 열린 파일 디스크립터 포함) 이진 오브젝트를 저장하는 경우 &lt;code&gt;Mnesia&lt;/code&gt; 테이블에 백업 된 후 나중에 다른 컨텍스트에서 복원 되면 의미가 없어집니다 .</target>
        </trans-unit>
        <trans-unit id="c04eebf0253a2b09b02af48ec92f831c4ed73813" translate="yes" xml:space="preserve">
          <source>Notice that ignoring the return value from this function would result in an &lt;strong&gt;unreliable&lt;/strong&gt; message passing, which is contradictory to the Erlang programming model. The message is &lt;strong&gt;not&lt;/strong&gt; sent if this function returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 함수의 반환 값을 무시하면 &lt;strong&gt;신뢰할 수없는&lt;/strong&gt; 메시지가 전달되어 Erlang 프로그래밍 모델과 모순됩니다. 이 함수가 &lt;code&gt;false&lt;/code&gt; 를 반환하면 메시지가 전송 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8e0a7d0fec338c74c62f26d54f900722acf0e30d" translate="yes" xml:space="preserve">
          <source>Notice that in &lt;code&gt;ordered_set&lt;/code&gt; tables, the records are ordered per fragment, and the order is undefined in results returned by &lt;code&gt;select&lt;/code&gt; and &lt;code&gt;match_object&lt;/code&gt;, as well as &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;prev&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;.</source>
          <target state="translated">에 통지 &lt;code&gt;ordered_set&lt;/code&gt; 테이블, 레코드가 조각 당 정렬 및 순서에 의해 반환 된 결과에 정의되어 있지 않습니다 &lt;code&gt;select&lt;/code&gt; 하고 &lt;code&gt;match_object&lt;/code&gt; 뿐만 아니라, &lt;code&gt;first&lt;/code&gt; , &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;prev&lt;/code&gt; 및 &lt;code&gt;last&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e87353c4be156a71ce7f89688b213b459834c505" translate="yes" xml:space="preserve">
          <source>Notice that in some cases, standard output of a command when called from another program (for example, &lt;code&gt;os:cmd/1&lt;/code&gt;) can differ, compared with the standard output of the command when called directly from an OS command shell.</source>
          <target state="translated">경우에 따라 다른 프로그램에서 호출 될 때 명령의 표준 출력 (예 &lt;code&gt;os:cmd/1&lt;/code&gt; )이 OS 명령 쉘에서 직접 호출 될 때 명령의 표준 출력과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3295423e0e8171c99eb1e9345ef25427a5a63801" translate="yes" xml:space="preserve">
          <source>Notice that in this unanchored example, the mark is retained from the match attempt that started at letter &quot;X&quot; in the subject. Subsequent match attempts starting at &quot;P&quot; and then with an empty string do not get as far as the (*MARK) item, nevertheless do not reset it.</source>
          <target state="translated">이 고정되지 않은 예에서, 마크는 주제에서 문자 &quot;X&quot;에서 시작된 일치 시도에서 유지됩니다. &quot;P&quot;로 시작한 다음 빈 문자열을 가진 후속 일치 시도는 (* MARK) 항목까지 도달하지 않지만 재설정하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="9cc48f18a5b25966f4b54af3d4aabec2ba6f3d99" translate="yes" xml:space="preserve">
          <source>Notice that it did not write &quot;hello&quot; three times and then &quot;goodbye&quot; three times. Instead, the first process wrote a &quot;hello&quot;, the second a &quot;goodbye&quot;, the first another &quot;hello&quot; and so forth. But where did the &amp;lt;0.63.0&amp;gt; come from? The return value of a function is the return value of the last &quot;thing&quot; in the function. The last thing in the function &lt;code&gt;start&lt;/code&gt; is</source>
          <target state="translated">&quot;hello&quot;를 세 번 쓴 다음 &quot;byebye&quot;를 세 번 쓰지 않았습니다. 대신, 첫 번째 프로세스는 &quot;hello&quot;, 두 번째 프로세스는 &quot;goodbye&quot;, 첫 번째 프로세스는 &quot;hello&quot;등을 작성했습니다. 그러나 &amp;lt;0.63.0&amp;gt;은 어디에서 왔습니까? 함수의 반환 값은 함수에서 마지막 &quot;thing&quot;의 반환 값입니다. 함수 &lt;code&gt;start&lt;/code&gt; 에서 마지막 은</target>
        </trans-unit>
        <trans-unit id="cf4175703ac6e9fdbe15e5acca7f10693ec63c07" translate="yes" xml:space="preserve">
          <source>Notice that it is also required to expand the &lt;code&gt;-export&lt;/code&gt; line with the information that there is another function &lt;code&gt;mult&lt;/code&gt; with two arguments.</source>
          <target state="translated">또한 두 개의 인수가있는 다른 함수 &lt;code&gt;mult&lt;/code&gt; 가 있다는 정보로 &lt;code&gt;-export&lt;/code&gt; 행 을 확장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a1a5ba2084c75a9789fb8664c66476603427348b" translate="yes" xml:space="preserve">
          <source>Notice that it is always the &lt;code&gt;merge_tests&lt;/code&gt; setting in the source specification that is used when joined with other specifications. Say, for example, that a source specification A, with tests TA1 and TA2, has &lt;code&gt;{merge_tests,false}&lt;/code&gt; set, and that it includes another specification, B, with tests TB1 and TB2, that has &lt;code&gt;{merge_tests,true}&lt;/code&gt; set. The result is that the test series &lt;code&gt;TA1,TA2,merge(TB1,TB2)&lt;/code&gt; is executed. The opposite &lt;code&gt;merge_tests&lt;/code&gt; settings would result in the test series &lt;code&gt;merge(merge(TA1,TA2),TB1,TB2)&lt;/code&gt;.</source>
          <target state="translated">다른 스펙과 결합 될 때 사용되는 소스 스펙의 항상 &lt;code&gt;merge_tests&lt;/code&gt; 설정입니다. 예를 들어, 테스트 TA1 및 TA2를 사용하는 소스 스펙 A에는 &lt;code&gt;{merge_tests,false}&lt;/code&gt; 가 설정되어 있고 다른 스펙 B에는 테스트 TB1 및 TB2가 있고 &lt;code&gt;{merge_tests,true}&lt;/code&gt; 가 설정되어 있다고 가정하십시오 . 결과 테스트 &lt;code&gt;TA1,TA2,merge(TB1,TB2)&lt;/code&gt; 가 실행됩니다. 반대의 &lt;code&gt;merge_tests&lt;/code&gt; 설정은 테스트 시리즈 &lt;code&gt;merge(merge(TA1,TA2),TB1,TB2)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="24bcac8813bad82252a8da44008063c6a9939ca8" translate="yes" xml:space="preserve">
          <source>Notice that it is more than ten times more efficient to read records dirty than within a transaction.</source>
          <target state="translated">트랜잭션 내에서보다 더티 레코드를 읽는 것이 10 배 이상 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="5fc580601d400a238482271cf80a8768aa43f791" translate="yes" xml:space="preserve">
          <source>Notice that it is normally the set of auto-imported BIFs that are referred to when talking about 'BIFs'.</source>
          <target state="translated">일반적으로 'BIF'에 대해 이야기 할 때 참조되는 자동 가져 오기 BIF 세트입니다.</target>
        </trans-unit>
        <trans-unit id="f48367941ecb417ce39721c36cb2f46ca431113b" translate="yes" xml:space="preserve">
          <source>Notice that it is up to the runtime system to determine if and how to use this information. Implementations on some platforms can use other means to determine consumed CPU time. Lengthy NIFs should regardless of this frequently call &lt;code&gt;enif_consume_timeslice&lt;/code&gt; to determine if it is allowed to continue execution.</source>
          <target state="translated">이 정보의 사용 여부와 방법을 결정하는 것은 런타임 시스템에 달려 있습니다. 일부 플랫폼에서의 구현은 다른 수단을 사용하여 소비 된 CPU 시간을 결정할 수 있습니다. 긴 NIF는이 문제와 상관없이 &lt;code&gt;enif_consume_timeslice&lt;/code&gt; 를 자주 호출 하여 실행을 계속할 수 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab3955ab8e83d7f2bb7bc498f1bd619814955ca0" translate="yes" xml:space="preserve">
          <source>Notice that it is up to the runtime system to determine if and how to use this information. Implementations on some platforms can use other means to determine the consumed fraction of the time-slice. Lengthy driver callbacks should, regardless of this, frequently call this function to determine if it is allowed to continue execution or not.</source>
          <target state="translated">이 정보의 사용 여부와 방법을 결정하는 것은 런타임 시스템에 달려 있습니다. 일부 플랫폼에서의 구현은 다른 방법을 사용하여 시간 분할의 소비 된 부분을 결정할 수 있습니다. 이에 관계없이 긴 드라이버 콜백은이 함수를 자주 호출하여 실행을 계속할 수 있는지 여부를 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e2ef46263bde688553324aea18d9c6d620ba48f" translate="yes" xml:space="preserve">
          <source>Notice that lists are encoded as strings if they consist entirely of integers in the range 0..255. This function do not decode such strings, use &lt;code&gt;ei_decode_string()&lt;/code&gt; instead.</source>
          <target state="translated">목록이 0..255 범위의 정수로만 구성된 경우 목록은 문자열로 인코딩됩니다. 이 함수는 그러한 문자열을 해독하지 않습니다 . 대신 &lt;code&gt;ei_decode_string()&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c29a9c8eeda96edcc7c5ce99dcb3efa7b2a52727" translate="yes" xml:space="preserve">
          <source>Notice that message &lt;code&gt;trace_delivered&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; imply that trace messages have been delivered. Instead it implies that all trace messages that &lt;strong&gt;are to be delivered&lt;/strong&gt; have been delivered. It is not an error if &lt;code&gt;Tracee&lt;/code&gt; is not, and has not been traced by someone, but if this is the case, &lt;strong&gt;no&lt;/strong&gt; trace messages have been delivered when the &lt;code&gt;trace_delivered&lt;/code&gt; message arrives.</source>
          <target state="translated">메시지 통지 &lt;code&gt;trace_delivered&lt;/code&gt; 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 트레이스 메시지를 의미가 전달되었다. 대신 &lt;strong&gt;배달 될&lt;/strong&gt; 모든 추적 메시지 가 배달되었음을 나타냅니다. &lt;code&gt;Tracee&lt;/code&gt; 가 아니고 누군가가 추적하지 않은 경우 오류 가 아니지만,이 경우 &lt;code&gt;trace_delivered&lt;/code&gt; 메시지가 도착할 때 추적 메시지가 전달 &lt;strong&gt;되지&lt;/strong&gt; 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="013198e22f586360fbbdabe6dcc8ff964ca7ded8" translate="yes" xml:space="preserve">
          <source>Notice that most type test BIFs have older equivalents, without the &lt;code&gt;is_&lt;/code&gt; prefix. These old BIFs are retained for backwards compatibility only and are not to be used in new code. They are also only allowed at top level. For example, they are not allowed in Boolean expressions in guards.</source>
          <target state="translated">대부분의 유형 테스트 BIF에는 &lt;code&gt;is_&lt;/code&gt; 접두사가 없는 이전 버전이 있습니다. 이러한 이전 BIF는 이전 버전과의 호환성을 위해서만 유지되며 새 코드에는 사용되지 않습니다. 또한 최상위 수준에서만 허용됩니다. 예를 들어, 가드의 부울 표현식에서는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8a03c035117d8088ab8da75706b1955d4613585" translate="yes" xml:space="preserve">
          <source>Notice that multiple &quot;*&quot; characters are allowed (as in Unix wildcards, but opposed to Windows/DOS wildcards).</source>
          <target state="translated">유닉스 와일드 카드에서와 같이 여러 개의 &quot;*&quot;문자가 허용되지만 Windows / DOS 와일드 카드와는 반대입니다.</target>
        </trans-unit>
        <trans-unit id="54221071699f0442ffc1867adb1c29b6517f290f" translate="yes" xml:space="preserve">
          <source>Notice that negative integer and float literals do not occur as such; they are parsed as an application of the unary negation operator.</source>
          <target state="translated">음의 정수 및 부동 리터럴은 그대로 발생하지 않습니다. 단항 부정 연산자의 응용 프로그램으로 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="f22111bba803b0601fab83f0c4714a0a75aa87f8" translate="yes" xml:space="preserve">
          <source>Notice that no bounds checking is done on the buffer. It is the caller's responsibility to ensure that the buffer is large enough to hold the encoded terms. You can either use a static buffer that is large enough to hold the terms you expect to need in your program, or use &lt;code&gt;erl_term_len()&lt;/code&gt; to determine the exact requirements for a given term.</source>
          <target state="translated">버퍼에 대한 경계 검사가 수행되지 않습니다. 버퍼가 인코딩 된 용어를 보유 할만큼 충분히 큰지 확인하는 것은 호출자의 책임입니다. 프로그램에서 필요로하는 용어를 보유하기에 충분히 큰 정적 버퍼를 사용하거나 &lt;code&gt;erl_term_len()&lt;/code&gt; 을 사용하여 주어진 용어에 대한 정확한 요구 사항을 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68f6c800f695bdd5313479dc773780ed9ac1eaba" translate="yes" xml:space="preserve">
          <source>Notice that no deleted objects are removed from a fixed table until it has been released. If a process fixes a table but never releases it, the memory used by the deleted objects is never freed. The performance of operations on the table also degrades significantly.</source>
          <target state="translated">삭제 된 개체는 고정 테이블에서 해제 될 때까지 제거되지 않습니다. 프로세스가 테이블을 수정하지만 테이블을 해제하지 않으면 삭제 된 개체가 사용한 메모리가 해제되지 않습니다. 테이블에서 작업 성능도 크게 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="27077c84801a08f27f5df1e48d210573f24a2d7b" translate="yes" xml:space="preserve">
          <source>Notice that no disc operations are performed when a program executes write operations to these replicas. However, if permanent RAM replicas are required, the following alternatives are available:</source>
          <target state="translated">프로그램이 이러한 복제본에 대한 쓰기 작업을 실행할 때는 디스크 작업이 수행되지 않습니다. 그러나 영구 RAM 복제본이 필요한 경우 다음 대안을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a597a819e1aa34d827c71c03375ea201eae9bbe" translate="yes" xml:space="preserve">
          <source>Notice that not all implementations support all these &lt;code&gt;Item&lt;/code&gt;s.</source>
          <target state="translated">모든 구현이 이러한 모든 &lt;code&gt;Item&lt;/code&gt; 을 지원하는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="4b0bf74963177cf020fa41c6b9891ab9f9dfa55b" translate="yes" xml:space="preserve">
          <source>Notice that octal values &amp;gt;= 100 that are specified using this syntax must not be introduced by a leading zero, as no more than three octal digits are ever read.</source>
          <target state="translated">이 구문을 사용하여 지정된 8 진수 값&amp;gt; = 100은 3 자리 이하의 8 진수를 읽지 않기 때문에 선행 0으로 시작해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="52b3caa006e96a4c992643ceef9a790dd9eaf91b" translate="yes" xml:space="preserve">
          <source>Notice that offsets are counted in bytes, not in characters. If the file is opened using some other &lt;code&gt;encoding&lt;/code&gt; than &lt;code&gt;latin1&lt;/code&gt;, one byte does not correspond to one character. Positioning in such a file can only be done to known character boundaries. That is, to a position earlier retrieved by getting a current position, to the beginning/end of the file or to some other position &lt;strong&gt;known&lt;/strong&gt; to be on a correct character boundary by some other means (typically beyond a byte order mark in the file, which has a known byte-size).</source>
          <target state="translated">오프셋은 문자가 아닌 바이트 단위로 계산됩니다. &lt;code&gt;latin1&lt;/code&gt; 이외의 다른 &lt;code&gt;encoding&lt;/code&gt; 사용하여 파일을 열면 한 바이트가 한 문자에 해당하지 않습니다. 이러한 파일에서의 위치 지정은 알려진 문자 경계로만 수행 할 수 있습니다. 즉, 현재 위치를 가져 와서 파일의 시작 / 끝 또는 다른 방법으로 올바른 문자 경계에있는 &lt;strong&gt;것으로 알려진&lt;/strong&gt; 다른 위치 (일반적으로 파일의 바이트 순서 표시를 넘어서서 검색된 위치 , 알려진 바이트 크기를 가짐).&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bf27ace1c7a3c2d0e720b1879eb1095858231ab1" translate="yes" xml:space="preserve">
          <source>Notice that on Windows, this flag is only applicable for &lt;code&gt;werl&lt;/code&gt;, not &lt;code&gt;erl&lt;/code&gt; (&lt;code&gt;oldshell&lt;/code&gt;). Notice also that &lt;code&gt;Ctrl-Break&lt;/code&gt; is used instead of &lt;code&gt;Ctrl-C&lt;/code&gt; on Windows.</source>
          <target state="translated">Windows에서이 플래그는 &lt;code&gt;erl&lt;/code&gt; ( &lt;code&gt;oldshell&lt;/code&gt; )이 아닌 &lt;code&gt;werl&lt;/code&gt; 에만 적용됩니다 . 것 또한주의 &lt;code&gt;Ctrl-Break&lt;/code&gt; 대신 사용 &lt;code&gt;Ctrl-C&lt;/code&gt; 를 Windows에서.</target>
        </trans-unit>
        <trans-unit id="32a6701d594a7f27b24d59d66fe69bc778606ca3" translate="yes" xml:space="preserve">
          <source>Notice that on some systems (such as VxWorks), a failed node is not detected by this mechanism, as the operating system does not automatically close descriptors that were left open when the node failed. If a node has failed in this way, &lt;code&gt;epmd&lt;/code&gt; prevents you from registering a new node with the old name, as it thinks that the old name is still in use. In this case, you must unregister the name explicitly:</source>
          <target state="translated">일부 시스템 (예 : VxWorks)에서는 운영 체제가 노드 장애시 열린 상태로 남아있는 설명자를 자동으로 닫지 않으므로이 메커니즘에서 장애가 발생한 노드를 감지하지 못합니다. 이런 방식으로 노드가 실패한 경우, &lt;code&gt;epmd&lt;/code&gt; 는 이전 이름이 여전히 사용중인 것으로 생각하여 이전 이름으로 새 노드를 등록하지 못하게합니다. 이 경우 이름을 명시 적으로 등록 취소해야합니다.</target>
        </trans-unit>
        <trans-unit id="43e1e5b7dc6da1a31388b14df1d6f6d64c3c0721" translate="yes" xml:space="preserve">
          <source>Notice that once &lt;code&gt;enif_make_resource&lt;/code&gt; creates the term to return to Erlang, the code can choose to either keep its own native pointer to the allocated struct and release it later, or release it immediately and rely only on the garbage collector to deallocate the resource object eventually when it collects the term.</source>
          <target state="translated">공지 사항 일단 것을 &lt;code&gt;enif_make_resource&lt;/code&gt; 가 얼랑로 돌아갑니다 용어를 생성, 코드 중 하나를 할당 된 구조체에 자신의 네이티브 포인터를 유지하고 나중에 해제, 또는 즉시 해제하도록 선택할 때 결국 자원 객체를 할당 해제 만 가비지 컬렉터에 의존 할 수 용어를 수집합니다.</target>
        </trans-unit>
        <trans-unit id="c711aa1c3890b7bd6065da8da6bc10f65058ad93" translate="yes" xml:space="preserve">
          <source>Notice that only nodes with disc are to be included in &lt;code&gt;DiscNodes&lt;/code&gt;. Disc-less nodes, that is, nodes where all tables including the schema only resides in RAM, must not be included.</source>
          <target state="translated">디스크가있는 노드 만 &lt;code&gt;DiscNodes&lt;/code&gt; 에 포함됩니다 . 디스크가없는 노드, 즉 스키마를 포함한 모든 테이블이 RAM에만 상주하는 노드는 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="67651cee75d5ac445a33e918dbfa7e4e883f716f" translate="yes" xml:space="preserve">
          <source>Notice that only one timer exists on each driver instance; setting a new timer replaces an older one.</source>
          <target state="translated">각 드라이버 인스턴스에는 하나의 타이머 만 있습니다. 새 타이머를 설정하면 이전 타이머가 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="29d795d009d1ea7a8a290d1e73a04d2744f2a646" translate="yes" xml:space="preserve">
          <source>Notice that only schedulers online can be bound to logical processors.</source>
          <target state="translated">온라인 스케줄러 만 논리 프로세서에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f799abe642c8ae36124dcf7f5ee9ae1710bfa1f7" translate="yes" xml:space="preserve">
          <source>Notice that only tables of a certain format can be restored, that is, those that have been created and backed up to with &lt;code&gt;ei_reg_dump()&lt;/code&gt;. If the registry was not empty before the operation, the contents of the table are added to the contents of the registry. If the table contains objects with the same keys as those already in the registry, the registry objects are overwritten with the new values. If the registry contains objects that were not in the table, they are unchanged by this operation.</source>
          <target state="translated">특정 형식의 테이블, 즉 &lt;code&gt;ei_reg_dump()&lt;/code&gt; 로 작성 및 백업 된 테이블 만 복원 할 수 있습니다 . 조작 전에 레지스트리가 비어 있지 않은 경우, 테이블의 내용이 레지스트리의 내용에 추가됩니다. 테이블에 이미 레지스트리에있는 것과 동일한 키를 가진 개체가 포함되어 있으면 레지스트리 개체를 새 값으로 덮어 씁니다. 레지스트리에 테이블에없는 오브젝트가 있으면이 조작으로 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23b04cc5100e31a53261bbb900a051cd16d9ea99" translate="yes" xml:space="preserve">
          <source>Notice that only the channel is closed. The connection is still up and can handle other channels:</source>
          <target state="translated">채널 만 닫혀 있습니다. 연결은 여전히 ​​작동 중이며 다른 채널을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="b15082a81f1a1a6e64b2d55298a12d9faa42eee1" translate="yes" xml:space="preserve">
          <source>Notice that only the lexicographical SNMP ordering is implemented in Mnesia, not the actual SNMP monitoring.</source>
          <target state="translated">사전 SNMP 순서 만 Mnesia에서 구현되며 실제 SNMP 모니터링은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a5838dc3537f85f38eb4149ebbfa4d4cafe73f75" translate="yes" xml:space="preserve">
          <source>Notice that parameter &lt;code&gt;Assoc&lt;/code&gt; is by the &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; defined to be ignored for one-to-one style sockets. For one-to-many style sockets, the special value &lt;code&gt;0&lt;/code&gt; is defined to mean that the returned addresses must be without any particular association. How different SCTP implementations interpret this varies somewhat.</source>
          <target state="translated">&lt;code&gt;Assoc&lt;/code&gt; 매개 변수 는 일대일 스타일 소켓에 대해 무시되도록 정의 된 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; 에 의한 것입니다. 일대 다 스타일 소켓의 경우 특수 값 &lt;code&gt;0&lt;/code&gt; 은 반환 된 주소에 특별한 연관이 없어야 함을 의미합니다. 다른 SCTP 구현이이를 해석하는 방법은 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d0d1f865bec9fd2105dd8d15020f4e5d9157f2b3" translate="yes" xml:space="preserve">
          <source>Notice that parameter &lt;code&gt;Assoc&lt;/code&gt; is by the &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; defined to be ignored for one-to-one style sockets. What the special value &lt;code&gt;0&lt;/code&gt; means, hence its behavior for one-to-many style sockets, is unfortunately undefined.</source>
          <target state="translated">&lt;code&gt;Assoc&lt;/code&gt; 매개 변수 는 일대일 스타일 소켓에 대해 무시되도록 정의 된 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; 에 의한 것입니다. 특수 값 &lt;code&gt;0&lt;/code&gt; 이 의미하는 바, 일대 다 스타일 소켓에 대한 동작은 불행히도 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ced3b5e4f7be44b8431fee61dd5559644b2a227" translate="yes" xml:space="preserve">
          <source>Notice that postponing buttons from the &lt;code&gt;open&lt;/code&gt; state to the &lt;code&gt;locked&lt;/code&gt; state feels like a strange thing to do for a code lock, but it at least illustrates event postponing.</source>
          <target state="translated">&lt;code&gt;open&lt;/code&gt; 상태에서 &lt;code&gt;locked&lt;/code&gt; 상태로 연기하는 버튼은 코드 잠금에 대해 이상한 일처럼 느껴지지만 적어도 이벤트 연기를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1c4f96f83f897de68ba3692f859901f16bc8520d" translate="yes" xml:space="preserve">
          <source>Notice that purging the code means that any processes lingering in old code for the module are killed without warning. For more information, see &lt;code&gt;code/3&lt;/code&gt;.</source>
          <target state="translated">코드를 제거한다는 것은 모듈의 기존 코드에 남아있는 모든 프로세스가 경고없이 종료됨을 의미합니다. 자세한 정보는 &lt;code&gt;code/3&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c423ca269e9c8da0681587c3e65b43e4f6fcac32" translate="yes" xml:space="preserve">
          <source>Notice that relaxed command checking must enabled for the &lt;code&gt;epmd&lt;/code&gt; daemon contacted. When running &lt;code&gt;epmd&lt;/code&gt; interactively, &lt;code&gt;-relaxed_command_check&lt;/code&gt; has no effect.</source>
          <target state="translated">연락 된 &lt;code&gt;epmd&lt;/code&gt; 데몬에 대해 완화 된 명령 검사를 활성화해야합니다 . &lt;code&gt;epmd&lt;/code&gt; 를 대화식으로 실행할 때는 &lt;code&gt;-relaxed_command_check&lt;/code&gt; 가 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9c86576f8186edb080a192562941feff98f7212" translate="yes" xml:space="preserve">
          <source>Notice that request for multiple parts of a document report a size of zero to the log file.</source>
          <target state="translated">문서의 여러 부분에 대한 요청은 크기가 0 인 로그 파일에보고됩니다.</target>
        </trans-unit>
        <trans-unit id="4443c6286a90c15343a889185dfe1fff15bfc5fd" translate="yes" xml:space="preserve">
          <source>Notice that settings saved by Erlang/OTP R16B01 or later cannot be read by Erlang/OTP R16B or earlier.</source>
          <target state="translated">Erlang / OTP R16B01 이상에서 저장 한 설정은 Erlang / OTP R16B 이전 버전에서는 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="649ed4989f050a560c2834e24c160ce1f14f0aab" translate="yes" xml:space="preserve">
          <source>Notice that since variables starting with an underscore are not anonymous, this matches:</source>
          <target state="translated">밑줄로 시작하는 변수는 익명이 아니므로 다음과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d7a8cf550209c24a879718ffa59fcc7fbdaebab0" translate="yes" xml:space="preserve">
          <source>Notice that some system-internal events can also be received. Therefore a catch-all clause last in the definition of the event handler callback function &lt;code&gt;Module:handle_event/2&lt;/code&gt; is necessary. This also applies for &lt;code&gt;Module:handle_info/2&lt;/code&gt;, as the event handler must also take care of some system-internal messages.</source>
          <target state="translated">일부 시스템 내부 이벤트도 수신 할 수 있습니다. 따라서 이벤트 핸들러 콜백 함수 &lt;code&gt;Module:handle_event/2&lt;/code&gt; 의 정의에서 마지막에 catch-all 절이 필요합니다. 이벤트 핸들러도 일부 시스템 내부 메시지를 처리해야하므로 이는 &lt;code&gt;Module:handle_info/2&lt;/code&gt; 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4523f125f7da0a280c62ef57a22e6c4002553475" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;bin_opt_info&lt;/code&gt; is not meant to be a permanent option added to your &lt;code&gt;Makefile&lt;/code&gt;s, because all messages that it generates cannot be eliminated. Therefore, passing the option through the environment is in most cases the most practical approach.</source>
          <target state="translated">것을 알 수 &lt;code&gt;bin_opt_info&lt;/code&gt; 을 의미하지 않는다 당신에 추가 영구적 인 옵션이 될 수 있습니다 &lt;code&gt;Makefile&lt;/code&gt; 모든 메시지 있기 때문에 제거 할 수없는 생성하는,의. 따라서 환경을 통해 옵션을 전달하는 것이 대부분의 경우 가장 실용적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="9f25de8ce6849112886fde44cc358ca27b801415" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;get_until&lt;/code&gt; request allows for a function with the data specified as always being a list. Also, the return value data from such a function can be of any type (as is indeed the case when an &lt;code&gt;io:fread/2,3&lt;/code&gt; request is sent to an I/O server). The client must be prepared for data received as answers to those requests to be in various forms. However, the I/O server is to convert the results to binaries whenever possible (that is, when the function supplied to &lt;code&gt;get_until&lt;/code&gt; returns a list). This is done in the example in section &lt;code&gt;&lt;a href=&quot;#example_io_server&quot;&gt;An Annotated and Working Example I/O Server&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">을 주목하는 것이 &lt;code&gt;get_until&lt;/code&gt; 요청은 항상리스트로서 지정된 데이터와 기능을 허용합니다. 또한 이러한 함수의 반환 값 데이터는 모든 유형이 될 수 있습니다 (실제로 &lt;code&gt;io:fread/2,3&lt;/code&gt; 요청이 I / O 서버로 전송되는 경우). 클라이언트는 다양한 형태의 요청에 대한 응답으로 수신 된 데이터를 준비해야합니다. 그러나 I / O 서버는 가능한 경우 (즉, &lt;code&gt;get_until&lt;/code&gt; 에 제공된 함수 가 목록을 리턴 할 때) 결과를 2 진으로 변환해야합니다 . 이것은 &lt;code&gt;&lt;a href=&quot;#example_io_server&quot;&gt;An Annotated and Working Example I/O Server&lt;/a&gt;&lt;/code&gt; 섹션 의 예제에서 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="869fe53220efffa9f2648be8687be1af3cac2f73" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;pid()&lt;/code&gt; of the I/O server is not explicitly present in tuple &lt;code&gt;io_reply&lt;/code&gt;. The reply can be sent from any process, not necessarily the actual I/O server.</source>
          <target state="translated">I / O 서버 의 &lt;code&gt;pid()&lt;/code&gt; 는 &lt;code&gt;io_reply&lt;/code&gt; 명시 적으로 존재하지 않습니다 . 응답은 실제 I / O 서버 일 필요는없는 모든 프로세스에서 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9bf7bd1d2a63adf57d1dd61e3e2c636ef718d87" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;start_link&lt;/code&gt; functions of the different behavior modules fulfill the above requirements.</source>
          <target state="translated">다른 비헤이비어 모듈 의 &lt;code&gt;start_link&lt;/code&gt; 함수는 위의 요구 사항을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="438a7860299a64ed5669574b6efede437e192860" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; message can be the result of the link, but can also be the result of &lt;code&gt;Id&lt;/code&gt; calling &lt;code&gt;exit/2&lt;/code&gt;. Therefore, it &lt;strong&gt;can&lt;/strong&gt; be appropriate to clean up the message queue when trapping exits after the call to &lt;code&gt;unlink(Id)&lt;/code&gt;, as follows:</source>
          <target state="translated">공지는 것을 &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; 메시지가 링크의 결과 일 수있다,뿐만 아니라의 결과 일 수있다 &lt;code&gt;Id&lt;/code&gt; 호출 &lt;code&gt;exit/2&lt;/code&gt; . 따라서 다음과 같이 &lt;code&gt;unlink(Id)&lt;/code&gt; 호출 후 트래핑이 종료 될 때 메시지 큐를 정리하는 것이 적절할 &lt;strong&gt;수&lt;/strong&gt; 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7d3b1ac2fe8c40d5c296cb9508ac5b63294a0ef" translate="yes" xml:space="preserve">
          <source>Notice that the BOM for UTF-8 is seldom used, and it is really not a &lt;strong&gt;byte order&lt;/strong&gt; mark. There are obviously no byte order issues with UTF-8, so the BOM is only there to differentiate UTF-8 encoding from other UTF formats.</source>
          <target state="translated">UTF-8 용 BOM은 거의 사용되지 않으며 실제로 &lt;strong&gt;바이트 순서&lt;/strong&gt; 표시가 아닙니다 . UTF-8에는 바이트 순서 문제가 없으므로 BOM은 UTF-8 인코딩을 다른 UTF 형식과 구별하기 위해서만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="60ba36aa64236926d8fc38d4a0caadafb0e955a8" translate="yes" xml:space="preserve">
          <source>Notice that the C program is in a &lt;code&gt;while&lt;/code&gt;-loop, checking for the return value of &lt;code&gt;read_cmd/1&lt;/code&gt;. This is because the C program must detect when the port closes and terminates.</source>
          <target state="translated">C 프로그램은 &lt;code&gt;while&lt;/code&gt; - loop에 있으며 &lt;code&gt;read_cmd/1&lt;/code&gt; 의 반환 값을 확인합니다 . C 프로그램은 포트가 닫히고 종료되는 시점을 감지해야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a63c691118a268393e4b6c047b61976f9f09e5f5" translate="yes" xml:space="preserve">
          <source>Notice that the Kernel variable &lt;code&gt;inetrc&lt;/code&gt; overrides this environment variable.</source>
          <target state="translated">커널 변수 &lt;code&gt;inetrc&lt;/code&gt; 가이 환경 변수를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="998c3bd807afb787e85df818d68896568ab1dac7" translate="yes" xml:space="preserve">
          <source>Notice that the above handler does not have any overload protection, and all log events are printed directly from the client process.</source>
          <target state="translated">위 핸들러에는 과부하 보호 기능이 없으며 모든 로그 이벤트는 클라이언트 프로세스에서 직접 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="5b06b14e5057923df74530d889d86c130c4599fb" translate="yes" xml:space="preserve">
          <source>Notice that the above specification does not restrict the input and output type in any way. These types can be constrained by guard-like subtype constraints and provide bounded quantification:</source>
          <target state="translated">위의 사양은 입력 및 출력 유형을 제한하지 않습니다. 이러한 유형은 보호 유형의 하위 유형 제약 조건으로 제한 될 수 있으며 제한된 수량을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ffeb1c6cbb53bd413a17d7e4afa253b27c7a4334" translate="yes" xml:space="preserve">
          <source>Notice that the apparently similar pattern</source>
          <target state="translated">명백하게 유사한 패턴</target>
        </trans-unit>
        <trans-unit id="1865e3416dbeb17876187856aa08e4b5f4f9fd78" translate="yes" xml:space="preserve">
          <source>Notice that the application version specifies a source code version. One more, indirect, requirement is that the installed binary application of the specified version is built so that it is compatible with the rest of the system.</source>
          <target state="translated">응용 프로그램 버전은 소스 코드 버전을 지정합니다. 간접적 인 요구 사항 중 하나는 지정된 버전의 설치된 이진 응용 프로그램이 나머지 시스템과 호환되도록 빌드해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="12430644918a731bc0331cb307bf4502fd57f823" translate="yes" xml:space="preserve">
          <source>Notice that the argument is a list with exactly one, two, or three arguments. &lt;code&gt;NameType&lt;/code&gt; defaults to &lt;code&gt;longnames&lt;/code&gt; and &lt;code&gt;Ticktime&lt;/code&gt; to &lt;code&gt;15000&lt;/code&gt;.</source>
          <target state="translated">인수는 정확히 하나, 둘 또는 세 개의 인수가있는 목록입니다. &lt;code&gt;NameType&lt;/code&gt; 의 기본값은 &lt;code&gt;longnames&lt;/code&gt; 이고 &lt;code&gt;Ticktime&lt;/code&gt; 은 &lt;code&gt;15000&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4e51fbbc05a639063fcd094a483d069e3e71d424" translate="yes" xml:space="preserve">
          <source>Notice that the behavior of this function for an SCTP one-to-many style socket is not defined by the &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SCTP 일대 다 스타일 소켓에 대한이 기능의 동작은 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; 의해 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2695495d90a21bfbc215e48f946c97c1557c57eb" translate="yes" xml:space="preserve">
          <source>Notice that the compiler does not generate encode/decode functions for parameterized types, only for the instances of the parameterized types. Therefore, if a file contains the types &lt;code&gt;General{}&lt;/code&gt;, &lt;code&gt;T1&lt;/code&gt;, and &lt;code&gt;T2&lt;/code&gt; as in the previous example, encode/decode functions are only generated for &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 매개 변수화 된 형식의 인스턴스에 대해서만 매개 변수화 된 형식에 대한 인코딩 / 디코딩 함수를 생성하지 않습니다. 따라서 파일 에 이전 예제에서 와 같이 &lt;code&gt;General{}&lt;/code&gt; , &lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; 유형이 포함 된 경우 인코딩 / 디코딩 기능은 &lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; 에 대해서만 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4bdb273ffa02e13186dc2814d4167dbf9f7eac3" translate="yes" xml:space="preserve">
          <source>Notice that the current key is stored in the driver, and can be invalid (for example, if the key has been removed).</source>
          <target state="translated">현재 키는 드라이버에 저장되며 유효하지 않을 수 있습니다 (예 : 키가 제거 된 경우).</target>
        </trans-unit>
        <trans-unit id="3425e12704f1ae2e3dac5bdc4405aa18192ba618" translate="yes" xml:space="preserve">
          <source>Notice that the default options for TCP/IP sockets can be changed with the Kernel configuration parameters mentioned in the beginning of this manual page.</source>
          <target state="translated">TCP / IP 소켓의 기본 옵션은이 매뉴얼 페이지의 시작 부분에 언급 된 커널 구성 매개 변수를 사용하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8735534cfeef989ea973a36967fd6073321a2a23" translate="yes" xml:space="preserve">
          <source>Notice that the definition of type &lt;code&gt;SET OF&lt;/code&gt; implies that the order of the components is undefined, but in practice there is no difference between &lt;code&gt;SET OF&lt;/code&gt; and &lt;code&gt;SEQUENCE OF&lt;/code&gt;. The ASN.1 compiler for Erlang does not randomize the order of the &lt;code&gt;SET OF&lt;/code&gt; components before encoding.</source>
          <target state="translated">&lt;code&gt;SET OF&lt;/code&gt; 유형의 정의 는 구성 요소의 순서가 정의되지 않았 음을 의미하지만 실제로 &lt;code&gt;SET OF&lt;/code&gt; 와 &lt;code&gt;SEQUENCE OF&lt;/code&gt; 사이에는 차이가 없습니다 . Erlang의 ASN.1 컴파일러는 인코딩 전에 &lt;code&gt;SET OF&lt;/code&gt; 구성 요소 의 순서를 무작위 화하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="85ee2b1beef42dfc51c38d1bdc5c48413f6418d8" translate="yes" xml:space="preserve">
          <source>Notice that the end of this type of comment is a literal newline sequence in the pattern; escape sequences that happen to represent a newline do not count. For example, consider the following pattern when &lt;code&gt;extended&lt;/code&gt; is set, and the default newline convention is in force:</source>
          <target state="translated">이 유형의 주석의 끝은 패턴에서 리터럴 개행 순서입니다. 줄 바꿈을 나타내는 이스케이프 시퀀스는 계산되지 않습니다. 예를 들어, &lt;code&gt;extended&lt;/code&gt; 이 설정되고 기본 줄 바꾸기 규칙이 적용되는 경우 다음 패턴을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="59c9761a4423dc8ba33d258174c0d7deb92180da" translate="yes" xml:space="preserve">
          <source>Notice that the file encoding options specified when opening a file has nothing to do with the filename encoding convention. You can very well open files containing data encoded in UTF-8, but having filenames in bytewise (&lt;code&gt;latin1&lt;/code&gt;) encoding or conversely.</source>
          <target state="translated">파일을 열 때 지정된 파일 인코딩 옵션은 파일 이름 인코딩 규칙과 관련이 없습니다. UTF-8로 인코딩 된 데이터를 포함하지만 파일 이름을 바이트 단위 ( &lt;code&gt;latin1&lt;/code&gt; ) 인코딩으로 또는 반대로 반대로 파일을 열 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54b730627c759c2237c6a38f6ac21fcf1d73b83e" translate="yes" xml:space="preserve">
          <source>Notice that the filesystem containing the virtual machine executable (&lt;code&gt;beam.smp&lt;/code&gt; in the example) must be local, mounted without flag &lt;code&gt;nosetuid&lt;/code&gt;, support extended attributes, and the kernel must support file capabilities. All this runs out of the box on at least Ubuntu 12.04 LTS, except that SCTP sockets appear to not support network namespaces.</source>
          <target state="translated">가상 머신 실행 파일 ( 예 : &lt;code&gt;beam.smp&lt;/code&gt; ) 을 포함하는 파일 시스템 은 로컬이어야하고 플래그 &lt;code&gt;nosetuid&lt;/code&gt; 없이 마운트되고 확장 된 속성을 지원하며 커널은 파일 기능을 지원해야합니다. SCTP 소켓이 네트워크 네임 스페이스를 지원하지 않는 것 외에는이 모든 것이 최소한 우분투 12.04 LTS에서 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="856dd98224a317941549fceec575ed693a862a3b" translate="yes" xml:space="preserve">
          <source>Notice that the function &lt;code&gt;add_frag/2&lt;/code&gt; is started one time for each of the other fragments (except number 1) as a part of the table creation procedure.</source>
          <target state="translated">&lt;code&gt;add_frag/2&lt;/code&gt; 함수 는 테이블 작성 프로 시저의 일부로 다른 각 프래그먼트 (번호 1 제외)에 대해 한 번 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="71fbea88394343530b7ae5da050f337473550603" translate="yes" xml:space="preserve">
          <source>Notice that the function can return &lt;code&gt;true&lt;/code&gt; for a module that in fact is not interpretable in the case where the module is marked as sticky or resides in a directory marked as sticky. The reason is that this is not discovered until the interpreter tries to load the module.</source>
          <target state="translated">모듈이 sticky로 표시되거나 sticky로 표시된 디렉토리에있는 경우 실제로 해석 할 수 없는 모듈에 대해 함수가 &lt;code&gt;true&lt;/code&gt; 를 리턴 할 수 있습니다 . 그 이유는 인터프리터가 모듈을로드하려고 시도 할 때까지 감지되지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fc5ff5fc0775ca18d960b27958c2c310603beba9" translate="yes" xml:space="preserve">
          <source>Notice that the functions below perform an RPC using an open file descriptor provided by the caller. This file descriptor must not be used for other traffic during the global operation, as the function can then receive unexpected data and fail.</source>
          <target state="translated">아래 함수는 호출자가 제공 한 열린 파일 설명자를 사용하여 RPC를 수행합니다. 함수가 예상치 못한 데이터를 수신하고 실패 할 수 있으므로 글로벌 조작 중에 다른 트래픽에이 파일 디스크립터를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6344e9ae1d5d7f5e3378303250cff912dbc2282d" translate="yes" xml:space="preserve">
          <source>Notice that the history of the last trace is always available in file &lt;code&gt;ttb_last_config&lt;/code&gt;.</source>
          <target state="translated">마지막 추적의 히스토리는 항상 &lt;code&gt;ttb_last_config&lt;/code&gt; 파일에서 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="9b4c212a61f0bb3f68fad2d68b59100bb913758e" translate="yes" xml:space="preserve">
          <source>Notice that the information returned is highly implementation-dependent and can be changed or removed at any time without prior notice. It was initially intended as a tool when developing new allocators, but as it can be of interest for others it has been briefly documented.</source>
          <target state="translated">반환 된 정보는 구현에 따라 크게 달라지며 사전 통지없이 언제든지 변경하거나 제거 할 수 있습니다. 처음에는 새로운 할당자를 개발할 때 도구로 사용되었지만 다른 사람들이 관심을 가질 수 있도록 간략하게 문서화되었습니다.</target>
        </trans-unit>
        <trans-unit id="5eec770c656034420f67e24636825b21ba0fb080" translate="yes" xml:space="preserve">
          <source>Notice that the integer value is only used internally in Logger. In the API, you must always use the atom. To compare the severity of two log levels, use &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt;logger:compare_levels/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">정수 값은 로거에서 내부적으로 만 사용됩니다. API에서는 항상 원자를 사용해야합니다. 두 로그 레벨의 심각도를 비교하려면 &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt;logger:compare_levels/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="913c6778d3ce72fc842456abadbdcd4a41900bd7" translate="yes" xml:space="preserve">
          <source>Notice that the last created atom is shown first.</source>
          <target state="translated">마지막으로 생성 된 원자가 먼저 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e6ee884138fcccc998b14a68323c7c49e44297a2" translate="yes" xml:space="preserve">
          <source>Notice that the last element in the &lt;code&gt;Request&lt;/code&gt; tuple (&lt;code&gt;[$\n]&lt;/code&gt;) is appended to the argument list when the function is called. The function is to be called like &lt;code&gt;apply(Module, Function, [ State, Data | ExtraArgs ])&lt;/code&gt; by the I/O server.</source>
          <target state="translated">&lt;code&gt;Request&lt;/code&gt; 튜플 의 마지막 요소 ( &lt;code&gt;[$\n]&lt;/code&gt; )는 함수가 호출 될 때 인수 목록에 추가됩니다. 이 함수는 I / O 서버에 의해 &lt;code&gt;apply(Module, Function, [ State, Data | ExtraArgs ])&lt;/code&gt; 와 같이 호출 됩니다 .</target>
        </trans-unit>
        <trans-unit id="65e13b0553b24c92ba77e668391c89bbfe7c5f62" translate="yes" xml:space="preserve">
          <source>Notice that the last part is &quot;ang&quot;, not &quot;an&quot;, as splitting was specified into two parts, and the splitting stops when enough parts are given, which is why the result differs from that of &lt;code&gt;trim&lt;/code&gt;.</source>
          <target state="translated">분할이 두 부분으로 지정되었으므로 마지막 부분은 &quot;an&quot;이 아니라 &quot;ang&quot;이며, 충분한 부분이 주어지면 분할이 중지되므로 결과가 &lt;code&gt;trim&lt;/code&gt; 의 결과와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="0b0de072daf08ddb3bed5b003d16bec94ec3f838" translate="yes" xml:space="preserve">
          <source>Notice that the match context in &lt;code&gt;my_binary_to_list/1&lt;/code&gt; was discarded when the entire binary had been traversed. What happens if the iteration stops before it has reached the end of the binary? Will the optimization still work?</source>
          <target state="translated">전체 바이너리가 순회되면 &lt;code&gt;my_binary_to_list/1&lt;/code&gt; 의 일치 컨텍스트 가 삭제되었습니다. 이진의 끝에 도달하기 전에 반복이 중지되면 어떻게됩니까? 최적화가 여전히 작동합니까?</target>
        </trans-unit>
        <trans-unit id="2d19f8166370c4661429c3cee25b80ade4ba9fb7" translate="yes" xml:space="preserve">
          <source>Notice that the order of objects returned is unspecified. In particular, the order in which objects were inserted is not reflected.</source>
          <target state="translated">반환 된 객체의 순서는 지정되어 있지 않습니다. 특히 개체가 삽입 된 순서는 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90ee8d6704f5ea8a8da9ff5e648eb8db8d5bce43" translate="yes" xml:space="preserve">
          <source>Notice that the program resides in the emulator's &lt;code&gt;bin&lt;/code&gt; directory, not in the &lt;code&gt;bin&lt;/code&gt; directory directly under the Erlang root. The reasons for this are the subtle problem of upgrading the emulator on a running system, where a new version of the runtime system should not need to overwrite existing (and probably used) executables.</source>
          <target state="translated">공지 사항이 에뮬레이터에서 프로그램이 상주 &lt;code&gt;bin&lt;/code&gt; 디렉토리가 아닌에서 &lt;code&gt;bin&lt;/code&gt; 직접 얼랑 루트 아래의 디렉토리. 그 이유는 실행중인 시스템에서 에뮬레이터를 업그레이드하는 데 미묘한 문제가 있기 때문입니다. 여기서 새 버전의 런타임 시스템은 기존 (및 아마도 사용 된) 실행 파일을 덮어 쓸 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="78b612195b425463060bd89b2b5fb48b2b6bc32f" translate="yes" xml:space="preserve">
          <source>Notice that the program runs slower if the data is located on a remote node.</source>
          <target state="translated">데이터가 원격 노드에있는 경우 프로그램이 느리게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7527eddb37622ef5514d8dac4dc37568ecec15bd" translate="yes" xml:space="preserve">
          <source>Notice that the range &lt;code&gt;0..Range-1&lt;/code&gt; is different from the range of &lt;code&gt;phash/2&lt;/code&gt;, which is &lt;code&gt;1..Range&lt;/code&gt;.</source>
          <target state="translated">범위 알 &lt;code&gt;0..Range-1&lt;/code&gt; 의 범위에서 다른 &lt;code&gt;phash/2&lt;/code&gt; 이고, &lt;code&gt;1..Range&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f5b1145658a0a3e84e5b5e128d226a353a792a5" translate="yes" xml:space="preserve">
          <source>Notice that the record name is the table name even when &lt;code&gt;record_name&lt;/code&gt; has another setting.</source>
          <target state="translated">&lt;code&gt;record_name&lt;/code&gt; 에 다른 설정이있는 경우에도 레코드 이름은 테이블 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="f556bad20e55c532b765ee625a5af6afc2bd2580" translate="yes" xml:space="preserve">
          <source>Notice that the regular expression must match the complete version string, so this example works for, for example, &lt;code&gt;2.1.1&lt;/code&gt;, but not for &lt;code&gt;2.1.1.1&lt;/code&gt;.</source>
          <target state="translated">정규식은 전체 버전 문자열과 일치해야 &lt;code&gt;2.1.1.1&lt;/code&gt; 예제는 예를 들어 &lt;code&gt;2.1.1&lt;/code&gt; 에서는 작동하지만 2.1.1.1 에서는 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4eea6a747947fcb8f655a220c818e740e96ba5d5" translate="yes" xml:space="preserve">
          <source>Notice that the same caveats apply as for &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt; 과 동일한 경고가 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="fe10cacd28855d9196c579eb8146305f91e16641" translate="yes" xml:space="preserve">
          <source>Notice that the sequences \A, \Z, and \z can be used to match the start and end of the subject in both modes. If all branches of a pattern start with \A, it is always anchored, regardless if &lt;code&gt;multiline&lt;/code&gt; is set.</source>
          <target state="translated">\ A, \ Z 및 \ z 시퀀스를 사용하여 두 모드에서 피사체의 시작과 끝을 일치시킬 수 있습니다. \ A를 패턴 시작의 모든 지점 경우에는 관계없이 항상 경우, 고정되어 &lt;code&gt;multiline&lt;/code&gt; 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6724f506b54877b36a23e88d5de227a00d37732a" translate="yes" xml:space="preserve">
          <source>Notice that the shorthand for &lt;code&gt;list()&lt;/code&gt;, that is, the list of elements of unknown type, is &lt;code&gt;[_]&lt;/code&gt; (or &lt;code&gt;[any()]&lt;/code&gt;), not &lt;code&gt;[]&lt;/code&gt;. The notation &lt;code&gt;[]&lt;/code&gt; specifies the singleton type for the empty list.</source>
          <target state="translated">&lt;code&gt;list()&lt;/code&gt; 의 약자 , 즉 알 수없는 유형의 요소 목록은 &lt;code&gt;[]&lt;/code&gt; 가 아닌 [ &lt;code&gt;[_]&lt;/code&gt; (또는 &lt;code&gt;[any()]&lt;/code&gt; ) 입니다. &lt;code&gt;[]&lt;/code&gt; 표기법 은 빈 목록의 싱글 톤 유형을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="73dac804c8d0ac669ce6f4344962d4b5c34961af" translate="yes" xml:space="preserve">
          <source>Notice that the space management data structures kept in RAM, the buddy system, is also written to the disk. This can take some time if the table is fragmented.</source>
          <target state="translated">버디 시스템 인 RAM에 보관 된 공간 관리 데이터 구조도 디스크에 기록됩니다. 테이블이 조각난 경우 시간이 다소 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30f0e9479e312465b9ff5d6f711d535a3e0101b4" translate="yes" xml:space="preserve">
          <source>Notice that the sum of these values is &lt;strong&gt;not&lt;/strong&gt; the total amount of memory allocated by the emulator. Some values are part of other values, and some memory areas are not part of the result. For information about the total amount of memory allocated by the emulator, see &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0,1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 값의 합계 는 에뮬레이터에서 할당 한 총 메모리 양 이 &lt;strong&gt;아닙니다&lt;/strong&gt; . 일부 값은 다른 값의 일부이고 일부 메모리 영역은 결과의 일부가 아닙니다. 에뮬레이터에서 할당 한 총 메모리 양에 대한 정보는 &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0,1&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5abbe6d966c5fc1edc96d1f28f1436c4958c4e8" translate="yes" xml:space="preserve">
          <source>Notice that the syntactic representation of &lt;code&gt;map()&lt;/code&gt; is &lt;code&gt;#{any() =&amp;gt; any()}&lt;/code&gt; (or &lt;code&gt;#{_ =&amp;gt; _}&lt;/code&gt;), not &lt;code&gt;#{}&lt;/code&gt;. The notation &lt;code&gt;#{}&lt;/code&gt; specifies the singleton type for the empty map.</source>
          <target state="translated">공지의 것을 표현 구문 &lt;code&gt;map()&lt;/code&gt; 이다 &lt;code&gt;#{any() =&amp;gt; any()}&lt;/code&gt; (또는 &lt;code&gt;#{_ =&amp;gt; _}&lt;/code&gt; )하지 &lt;code&gt;#{}&lt;/code&gt; . &lt;code&gt;#{}&lt;/code&gt; 표기법 은 빈 맵의 싱글 톤 유형을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d2c453c4a61a93e0e17811bf7efe3b048abd12f0" translate="yes" xml:space="preserve">
          <source>Notice that the template is here the same as for &lt;code&gt;single_line=false&lt;/code&gt;, but the resulting log entry differs in that there is only one line after the heading:</source>
          <target state="translated">여기서 템플릿은 &lt;code&gt;single_line=false&lt;/code&gt; 와 동일 하지만 결과 로그 항목은 제목 다음에 한 줄만 있다는 점에서 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1a0dfecdaad1fda603fa4229f911e862d71765b6" translate="yes" xml:space="preserve">
          <source>Notice that the time order of object insertions is preserved; the first object inserted with the specified key is the first in the resulting list, and so on.</source>
          <target state="translated">개체 삽입의 시간 순서가 유지됩니다. 지정된 키로 삽입 된 첫 번째 개체는 결과 목록에서 첫 번째 개체입니다.</target>
        </trans-unit>
        <trans-unit id="6f7067f925d0363a33444938455ac91fcd09edfb" translate="yes" xml:space="preserve">
          <source>Notice that the use of an &lt;code&gt;.inetrc&lt;/code&gt; file, which was supported in earlier Erlang/OTP versions, is now obsolete.</source>
          <target state="translated">이전 Erlang / OTP 버전에서 지원되었던 &lt;code&gt;.inetrc&lt;/code&gt; 파일 사용 은 이제 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b338a89eefab229871069c1f47956c10a1d50274" translate="yes" xml:space="preserve">
          <source>Notice that the value fed into the selective decode functions must be a binary.</source>
          <target state="translated">선택적 디코드 기능에 공급되는 값은 2 진이어야합니다.</target>
        </trans-unit>
        <trans-unit id="787fd319d83681555c07f1a96ca590fc08523120" translate="yes" xml:space="preserve">
          <source>Notice that there is no &quot;;&quot; before &lt;code&gt;end&lt;/code&gt;. Conditions do the same as guards, that is, tests that succeed or fail. Erlang starts at the top and tests until it finds a condition that succeeds. Then it evaluates (performs) the action following the condition and ignores all other conditions and actions before the &lt;code&gt;end&lt;/code&gt;. If no condition matches, a run-time failure occurs. A condition that always succeeds is the atom &lt;code&gt;true&lt;/code&gt;. This is often used last in an &lt;code&gt;if&lt;/code&gt;, meaning, do the action following the &lt;code&gt;true&lt;/code&gt; if all other conditions have failed.</source>
          <target state="translated">&quot;;&quot;가 없습니다. &lt;code&gt;end&lt;/code&gt; 전에 . 조건은 가드, 즉 성공 또는 실패 테스트와 동일합니다. Erlang은 맨 위에서 시작하여 성공한 조건을 찾을 때까지 테스트합니다. 그런 다음 조건에 따라 동작을 평가 (수행)하고 &lt;code&gt;end&lt;/code&gt; 다른 모든 조건과 동작은 무시합니다 . 조건이 일치하지 않으면 런타임 오류가 발생합니다. 항상 성공하는 조건은 원자 &lt;code&gt;true&lt;/code&gt; 입니다. 다른 조건이 모두 실패한 경우 &lt;code&gt;true&lt;/code&gt; 뒤에있는 조치를 수행 하는 &lt;code&gt;if&lt;/code&gt; 가 종종 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c7902b9db4b62c4e9204bea0b7582aa107cd80a6" translate="yes" xml:space="preserve">
          <source>Notice that there is no &quot;condition variable wait with time-out&quot; in the Erlang driver thread API. This because of issues with &lt;code&gt;pthread_cond_timedwait&lt;/code&gt;. When the system clock suddenly is changed, it is not always guaranteed that you will wake up from the call as expected. An Erlang runtime system must be able to cope with sudden changes of the system clock. Therefore, we have omitted it from the Erlang driver thread API. In the Erlang driver case, time-outs can and are to be handled with the timer functionality of the Erlang driver API.</source>
          <target state="translated">Erlang 드라이버 스레드 API에는 &quot;시간 초과시 조건 변수 대기&quot;가 없습니다. 이것은 &lt;code&gt;pthread_cond_timedwait&lt;/code&gt; 와 관련된 문제 때문입니다 . 시스템 시계가 갑자기 변경 될 때 항상 예상대로 전화가 깨어나는 것은 아닙니다. Erlang 런타임 시스템은 시스템 클럭의 갑작스러운 변화에 대처할 수 있어야합니다. 따라서 Erlang 드라이버 스레드 API에서 생략했습니다. Erlang 드라이버의 경우 시간 초과는 Erlang 드라이버 API의 타이머 기능으로 처리 할 수 ​​있으며 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="bceb9f4f6a6abdf1446e121be361b43261feb62c" translate="yes" xml:space="preserve">
          <source>Notice that there is no automatic garbage collection for tables. Even if there are no references to a table from any process, it is not automatically destroyed unless the owner process terminates. To destroy a table explicitly, use function &lt;code&gt;&lt;a href=&quot;#delete-1&quot;&gt;delete/1&lt;/a&gt;&lt;/code&gt;. The default owner is the process that created the table. To transfer table ownership at process termination, use option &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; or call &lt;code&gt;&lt;a href=&quot;#give_away-3&quot;&gt;give_away/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테이블에 대한 자동 가비지 콜렉션이 없습니다. 프로세스에서 테이블에 대한 참조가 없더라도 소유자 프로세스가 종료되지 않으면 자동으로 소멸되지 않습니다. 테이블을 명시 적으로 제거하려면 &lt;code&gt;&lt;a href=&quot;#delete-1&quot;&gt;delete/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 . 기본 소유자는 테이블을 생성 한 프로세스입니다. 프로세스 종료시 테이블 소유권을 이전하려면 옵션 &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; 사용 하거나 &lt;code&gt;&lt;a href=&quot;#give_away-3&quot;&gt;give_away/3&lt;/a&gt;&lt;/code&gt; 를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8bab5c018b3dd7779861d18a2de3b850779eed22" translate="yes" xml:space="preserve">
          <source>Notice that these results are highly implementation-specific and can change in a future release.</source>
          <target state="translated">이러한 결과는 구현에 따라 다르며 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="869e22e1f3c3acbe1295f4e3f5e543c0967d43d9" translate="yes" xml:space="preserve">
          <source>Notice that these values are not guaranteed to be the exact time spent in each state. This is because of various optimisation done to keep the overhead as small as possible.</source>
          <target state="translated">이 값이 각 주에서 소비 된 정확한 시간임을 보장하지는 않습니다. 오버 헤드를 가능한 작게 유지하기 위해 다양한 최적화가 수행 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1b2a4c91cbe5e730d179e66ad334733cf9b2f315" translate="yes" xml:space="preserve">
          <source>Notice that this can cause the message queue to overflow, as there is no way to throttle the sender in this case (no flow control).</source>
          <target state="translated">이 경우 발신자를 조절할 수있는 방법이 없으므로 (흐름 제어 없음) 메시지 대기열이 오버플로 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65c845a0c39116c9a8667488291653cb120ecdb8" translate="yes" xml:space="preserve">
          <source>Notice that this code never uses &lt;code&gt;ets:match/2&lt;/code&gt; but instead uses the &lt;code&gt;ets:lookup/2&lt;/code&gt; call. The &lt;code&gt;lists:map/2&lt;/code&gt; call is only used to traverse the &lt;code&gt;idno&lt;/code&gt;s matching the name &quot;Bryan&quot; in the table; thus the number of lookups in the master table is minimized.</source>
          <target state="translated">이 코드는 &lt;code&gt;ets:match/2&lt;/code&gt; 를 사용하지 않고 대신 &lt;code&gt;ets:lookup/2&lt;/code&gt; 호출을 사용합니다. &lt;code&gt;lists:map/2&lt;/code&gt; 호출만을 통과하는 데 사용됩니다 &lt;code&gt;idno&lt;/code&gt; 의 표에 이름이 &quot;브라이언&quot;를 일치; 따라서 마스터 테이블의 조회 수가 최소화됩니다.</target>
        </trans-unit>
        <trans-unit id="642ed222441e7d274dce20239475afe796aa6f92" translate="yes" xml:space="preserve">
          <source>Notice that this does not in any way tell how characters are to be put on the I/O device or handled by the I/O server. Different I/O servers can handle the characters however they want, this only tells the I/O server which format the data is expected to have. In the &lt;code&gt;Module&lt;/code&gt;/&lt;code&gt;Function&lt;/code&gt;/&lt;code&gt;Args&lt;/code&gt; case, &lt;code&gt;Encoding&lt;/code&gt; tells which format the designated function produces.</source>
          <target state="translated">이것은 어떤 식 으로든 I / O 장치에 문자를 넣거나 I / O 서버에서 처리하는 방법을 나타내지 않습니다. 다른 I / O 서버는 원하는 문자를 처리 할 수 ​​있지만 이는 데이터가 어떤 형식으로 예상되는지 I / O 서버에만 알려줍니다. 에서 &lt;code&gt;Module&lt;/code&gt; / &lt;code&gt;Function&lt;/code&gt; / &lt;code&gt;Args&lt;/code&gt; 경우, &lt;code&gt;Encoding&lt;/code&gt; 지정된 함수를 생성하는 포맷 말한다.</target>
        </trans-unit>
        <trans-unit id="349cea6fe5b002efa6f13c8a0b6d61002518bac7" translate="yes" xml:space="preserve">
          <source>Notice that this function can also be called as a part of a code upgrade procedure. Therefore, the function is not to have any side effects. For more information about code upgrade of supervisors, see section &lt;code&gt;Changing a Supervisor&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">이 기능은 코드 업그레이드 절차의 일부로 호출 될 수도 있습니다. 따라서이 기능은 부작용이 없어야합니다. 수퍼바이저의 코드 업그레이드에 대한 자세한 내용은 OTP 디자인 원칙에서 &lt;code&gt;Changing a Supervisor&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5a602977aaafafa43a23557b7310cdf92b1e9ad" translate="yes" xml:space="preserve">
          <source>Notice that this function does not affect option &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; of the table. A table owner can, for example, set &lt;code&gt;heir&lt;/code&gt; to itself, give the table away, and then get it back if the receiver terminates.</source>
          <target state="translated">이 함수는 테이블의 옵션 &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; 에는 영향을 미치지 않습니다 . 예를 들어, 테이블 소유자는 &lt;code&gt;heir&lt;/code&gt; 를 자체로 설정 하고 테이블을 제공 한 다음 수신자가 종료되면 다시 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cb54426795679095e8a29fd043a79047773a14e" translate="yes" xml:space="preserve">
          <source>Notice that this function does not manipulate the Logger configuration directly, meaning that if the default Logger handler is already logging to a file, this function can potentially cause logging to a second file.</source>
          <target state="translated">이 함수는 로거 구성을 직접 조작하지 않습니다. 즉, 기본 로거 핸들러가 이미 파일에 로깅중인 경우이 기능으로 인해 두 번째 파일에 로깅이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b7b1e720e05da028ebe3dc53213402e40544038" translate="yes" xml:space="preserve">
          <source>Notice that this function is &lt;strong&gt;not&lt;/strong&gt; thread-safe, not even when the emulator with SMP support is used.</source>
          <target state="translated">이 함수는 것을주의 &lt;strong&gt;하지&lt;/strong&gt; 스레드 안전은 SMP를 지원하는 에뮬레이터를 사용하지 경우에도.</target>
        </trans-unit>
        <trans-unit id="8447f5b25cdb8a2cfab1f25034c52ae944a2138b" translate="yes" xml:space="preserve">
          <source>Notice that this function is located in the &lt;code&gt;Erl_Interface&lt;/code&gt; library.</source>
          <target state="translated">이 함수는 &lt;code&gt;Erl_Interface&lt;/code&gt; 라이브러리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="47ba6495ef0d28a812199229a1ffda8befe21e10" translate="yes" xml:space="preserve">
          <source>Notice that this function must only be used to connect to newly started RAM nodes (N.D.R.S.N.) with an empty schema. If, for example, this function is used after the network has been partitioned, it can lead to inconsistent tables.</source>
          <target state="translated">이 함수는 빈 스키마를 사용하여 새로 시작된 RAM 노드 (NDRSN)에 연결하는 데만 사용해야합니다. 예를 들어, 네트워크가 분할 된 후이 기능을 사용하면 테이블이 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a0080e2dd941529f19011486ca16886c12b3f0d" translate="yes" xml:space="preserve">
          <source>Notice that this identifier on occations has been called &quot;name&quot;. As far as possible, the terms &quot;identifier&quot; or &quot;id&quot; are now used but to keep backward compatibility, some occurences of &quot;name&quot; can still be found, for example in error messages.</source>
          <target state="translated">occations에서이 식별자는 &quot;name&quot;이라고합니다. 가능한 한 &quot;식별자&quot;또는 &quot;id&quot;라는 용어가 사용되었지만 이전 버전과의 호환성을 유지하기 위해 오류 메시지에서 &quot;name&quot;이라는 일부 항목이 여전히 발견 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d730d26eb5bc6c258ec3f4a85decab69ff65e557" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;strong&gt;not&lt;/strong&gt; equivalent to reversing the result list of a &lt;code&gt;select/3&lt;/code&gt; call, as the result list is not only reversed, but also contains the last &lt;code&gt;Limit&lt;/code&gt; matching objects in the table, not the first.</source>
          <target state="translated">이 것을주의 &lt;strong&gt;하지&lt;/strong&gt; a의 결과 목록 반전에 해당 &lt;code&gt;select/3&lt;/code&gt; 도 결과 목록은 반전되지 않기 때문에, 전화를하지만, 마지막 포함 &lt;code&gt;Limit&lt;/code&gt; , 첫 번째가 아닌 테이블에 일치하는 객체.</target>
        </trans-unit>
        <trans-unit id="70914725ae02a1a2e612f1b985dfda4ff43284f0" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;strong&gt;not&lt;/strong&gt; guaranteed for Kernel versions before 2.11.4.</source>
          <target state="translated">2.11.4 이전의 커널 버전에서는 이것이 보장 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7dcda89d0c9ebc603749979d693cfd0901ccfd8f" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;strong&gt;not&lt;/strong&gt; guaranteed for Kernel versions before 2.13.</source>
          <target state="translated">2.13 이전의 커널 버전에서는 이것이 보장 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ebcfa6b14e436143f912db1c4d94b897ad5c396b" translate="yes" xml:space="preserve">
          <source>Notice that this is a snapshot of what the entries are exactly when the crash dump is starting to be generated. Therefore they are most likely different (and more telling) than the entries for the same processes found in the &lt;strong&gt;=proc&lt;/strong&gt; section. If there is no currently running process, only the &lt;strong&gt;Current Process&lt;/strong&gt; entry is shown.</source>
          <target state="translated">이는 크래시 덤프가 생성되기 시작할 때 항목이 정확히 무엇인지에 대한 스냅 샷입니다. 따라서 그것들은 &lt;strong&gt;= proc&lt;/strong&gt; 섹션 에있는 동일한 프로세스에 대한 항목과 다를 수 있습니다. 현재 실행중인 프로세스가없는 경우 &lt;strong&gt;현재 프로세스&lt;/strong&gt; 항목 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6b5fe898d5908bd62ba390154dbda59785193315" translate="yes" xml:space="preserve">
          <source>Notice that this list was so long that it did not fit on one line. This does not matter, Erlang allows line breaks at all &quot;sensible places&quot; but not, for example, in the middle of atoms, integers, and others.</source>
          <target state="translated">이 목록은 너무 길어서 한 줄에 맞지 않습니다. 이것은 중요하지 않습니다. Erlang은 모든 &quot;감지 가능한 장소&quot;에서 줄 바꿈을 허용하지만 예를 들어 원자, 정수 등의 중간에서는 줄 바꿈을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bed5f26c2d951298be832ad680fbfcde5f6d0366" translate="yes" xml:space="preserve">
          <source>Notice that this only affects &lt;strong&gt;heuristic&lt;/strong&gt; interpretation of lists and binaries on output. For example, the &lt;code&gt;~ts&lt;/code&gt; format sequence always outputs a valid list of characters, regardless of the &lt;code&gt;+pc&lt;/code&gt; setting, as the programmer has explicitly requested string output.</source>
          <target state="translated">이는 출력에서 목록 및 이진의 &lt;strong&gt;휴리스틱&lt;/strong&gt; 해석 에만 영향을줍니다 . 예를 들어, &lt;code&gt;~ts&lt;/code&gt; 형식 순서 는 프로그래머가 명시 적으로 문자열 출력을 요청 &lt;code&gt;+pc&lt;/code&gt; 설정에 관계없이 항상 유효한 문자 목록을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="06bbb7eb9157769ac232caf919df5223a21c5714" translate="yes" xml:space="preserve">
          <source>Notice that this option does not change any guarantees about &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomicity and isolation&lt;/a&gt;&lt;/code&gt;. Functions that makes such promises over many objects (like &lt;code&gt;&lt;a href=&quot;#insert-2&quot;&gt;insert/2&lt;/a&gt;&lt;/code&gt;) gain less (or nothing) from this option.</source>
          <target state="translated">이 옵션은 &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomicity and isolation&lt;/a&gt;&lt;/code&gt; 에 대한 보증을 변경하지 않습니다 . &lt;code&gt;&lt;a href=&quot;#insert-2&quot;&gt;insert/2&lt;/a&gt;&lt;/code&gt; 와 같은 많은 객체에 대한 그러한 약속을 만드는 함수 는이 옵션에서 덜 얻거나 아무것도 얻지 못합니다.</target>
        </trans-unit>
        <trans-unit id="621939df6e7634c47047d2e081590d78eaf11831" translate="yes" xml:space="preserve">
          <source>Notice that this part ends with a &quot;.&quot; saying that there are no more parts of this function.</source>
          <target state="translated">이 부분은 &quot;.&quot;로 끝납니다. 이 기능에는 더 이상 부분이 없다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="e6c419f8334737f0ba7bd3fd865a876302c62640" translate="yes" xml:space="preserve">
          <source>Notice that this part ends with a semicolon &quot;;&quot; that indicates that there is more of the function &lt;code&gt;fac&amp;gt;&lt;/code&gt; to come.</source>
          <target state="translated">이 부분은 세미콜론 &quot;;&quot;으로 끝납니다. 이는 앞으로 더 많은 기능 &lt;code&gt;fac&amp;gt;&lt;/code&gt; 이 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="846082f1f38f9d35784642322c9bebfb5b6dff1c" translate="yes" xml:space="preserve">
          <source>Notice that this state diagram does not specify how to handle a button event in the state &lt;code&gt;open&lt;/code&gt;. So, you need to read in some side notes, that is, here: that unspecified events shall be postponed (handled in some later state). Also, the state diagram does not show that the &lt;code&gt;code_length/0&lt;/code&gt; call must be handled in every state.</source>
          <target state="translated">이 상태 다이어그램은 &lt;code&gt;open&lt;/code&gt; 상태에서 버튼 이벤트를 처리하는 방법을 지정하지 않습니다 . 따라서 몇 가지 참고 사항, 즉 여기에서 읽어야합니다. 지정되지 않은 이벤트는 연기됩니다 (나중에 처리). 또한 상태 다이어그램은 &lt;code&gt;code_length/0&lt;/code&gt; 호출이 모든 상태에서 처리되어야 한다는 것을 보여주지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6d7cfe9a38358e1080d2e905013781b2b4b7296d" translate="yes" xml:space="preserve">
          <source>Notice that type &lt;code&gt;ordered_set&lt;/code&gt; in Ets is not yet provided by Dets, neither is the limited support for concurrent updates that makes a sequence of &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; calls safe to use on fixed ETS tables. Both these features may be provided by Dets in a future release of Erlang/OTP. Until then, the Mnesia application (or some user-implemented method for locking) must be used to implement safe concurrency. Currently, no Erlang/OTP library has support for ordered disk-based term storage.</source>
          <target state="translated">Ets에서 &lt;code&gt;ordered_set&lt;/code&gt; 유형 은 아직 Dets에서 제공하지 않으며, 고정 된 ETS 테이블에서 사용하기 위해 &lt;code&gt;first&lt;/code&gt; 및 &lt;code&gt;next&lt;/code&gt; 호출 시퀀스를 안전하게 만드는 동시 업데이트에 대한 제한적인 지원도 아닙니다 . Erlang / OTP의 차기 릴리스에서 Dets가이 두 기능을 모두 제공 할 수 있습니다. 그때까지 안전한 동시성을 구현하려면 Mnesia 응용 프로그램 (또는 일부 사용자 구현 잠금 방법)을 사용해야합니다. 현재 Erlang / OTP 라이브러리는 주문 된 디스크 기반 용어 저장소를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="49a7a915aea8e9d41179a8ea113e08f2ef1a2887" translate="yes" xml:space="preserve">
          <source>Notice that we only return data (with &lt;code&gt;driver_output&lt;/code&gt;) if there is an error here, otherwise we wait for the connection to be completed, in which case our &lt;code&gt;ready_io&lt;/code&gt; function is called.</source>
          <target state="translated">여기에 오류가있는 경우 데이터 ( &lt;code&gt;driver_output&lt;/code&gt; 포함 ) 만 반환합니다 . 그렇지 않으면 연결이 완료 될 때까지 기다립니다.이 경우 &lt;code&gt;ready_io&lt;/code&gt; 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f51f3b121bba411146620bcda978e5f491550a29" translate="yes" xml:space="preserve">
          <source>Notice that when calling a local function, there is a difference between using the implicitly or fully qualified function name. The latter always refers to the latest version of the module. See &lt;code&gt;&lt;a href=&quot;code_loading&quot;&gt;Compilation and Code Loading&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions#eval&quot;&gt;Function Evaluation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로컬 함수를 호출 할 때 내재적 또는 완전한 함수 이름을 사용하는 것에는 차이가 있습니다. 후자는 항상 최신 버전의 모듈을 나타냅니다. &lt;code&gt;&lt;a href=&quot;code_loading&quot;&gt;Compilation and Code Loading&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions#eval&quot;&gt;Function Evaluation&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f8b34f22954b45969704565ba857ede0360296a" translate="yes" xml:space="preserve">
          <source>Notice that when changing the configuration of the handler in runtime, the disk_log options (&lt;code&gt;file&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;max_no_files&lt;/code&gt;, &lt;code&gt;max_no_bytes&lt;/code&gt;) must not be modified.</source>
          <target state="translated">런타임에서 핸들러 구성을 변경할 때 disk_log 옵션 ( &lt;code&gt;file&lt;/code&gt; , &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;max_no_files&lt;/code&gt; , &lt;code&gt;max_no_bytes&lt;/code&gt; )을 수정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="290de7804d4ece9b07b182bd6263d67e874d7ab3" translate="yes" xml:space="preserve">
          <source>Notice that when manipulating the PLT, no warnings are emitted. To turn on warnings during (re)analysis of the PLT, use option &lt;code&gt;--get_warnings&lt;/code&gt;.</source>
          <target state="translated">PLT를 조작 할 때 경고가 발생하지 않습니다. PLT를 재분석하는 동안 경고를 설정하려면 &lt;code&gt;--get_warnings&lt;/code&gt; 옵션을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="45a6c9cf395e353cb2306cbfdb89cfe2d26435a1" translate="yes" xml:space="preserve">
          <source>Notice that when multiple event handlers are invoked, it is sufficient that one single event handler returns a &lt;code&gt;hibernate&lt;/code&gt; request for the whole event manager to go into hibernation.</source>
          <target state="translated">여러 이벤트 핸들러가 호출되면 하나의 단일 이벤트 핸들러가 전체 이벤트 관리자가 최대 절전 모드로 전환하기위한 &lt;code&gt;hibernate&lt;/code&gt; 요청을 리턴하는 것으로 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="f33a5a292b9691e53af0ea35251a90bd5b70c0ab" translate="yes" xml:space="preserve">
          <source>Notice that when the restart strategy is &lt;code&gt;simple_one_for_one&lt;/code&gt;, the list of child specifications must be a list with one child specification only. (The child specification identifier is ignored.) No child process is then started during the initialization phase, but all children are assumed to be started dynamically using &lt;code&gt;&lt;a href=&quot;#start_child-2&quot;&gt;start_child/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">재시작 전략이 &lt;code&gt;simple_one_for_one&lt;/code&gt; 인 경우 하위 스펙 목록은 하나의 하위 스펙 만있는 목록이어야합니다. (자식 지정 식별자는 무시됩니다.) 초기화 단계에서 자식 프로세스가 시작되지 않지만 &lt;code&gt;&lt;a href=&quot;#start_child-2&quot;&gt;start_child/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 모든 자식이 동적으로 시작된 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="9634bd19d38caf45acf63a0abbac721e5ae1181a" translate="yes" xml:space="preserve">
          <source>Notice that you do not have to worry about the order you assign values to the various parts of the records when you create it. The advantage of using records is that by placing their definitions in header files you can conveniently define interfaces that are easy to change. For example, if you want to add a new field to the record, you only have to change the code where the new field is used and not at every place the record is referred to. If you leave out a field when creating a record, it gets the value of the atom &lt;code&gt;undefined&lt;/code&gt;. (*manual*)</source>
          <target state="translated">레코드를 작성할 때 값을 레코드의 여러 부분에 지정하는 순서에 대해 걱정할 필요가 없습니다. 레코드를 사용하면 헤더 파일에 정의를 배치하여 변경하기 쉬운 인터페이스를 편리하게 정의 할 수 있다는 장점이 있습니다. 예를 들어, 레코드에 새 필드를 추가하려면 레코드가 참조되는 모든 위치가 아니라 새 필드가 사용되는 코드 만 변경하면됩니다. 레코드를 만들 때 필드를 제외하면 atom 값이 &lt;code&gt;undefined&lt;/code&gt; 로 설정 됩니다. (*설명서*)</target>
        </trans-unit>
        <trans-unit id="11459bdda73f31f4f445b7c1dd521d4fd85a0493" translate="yes" xml:space="preserve">
          <source>Notice that, as shown in this example, two or more adjacent separator characters in &lt;code&gt;String&lt;/code&gt; are treated as one. That is, there are no empty strings in the resulting list of tokens.</source>
          <target state="translated">이 예에 표시된 것처럼 &lt;code&gt;String&lt;/code&gt; 에서 두 개 이상의 인접한 구분 기호 문자는 하나로 취급됩니다. 즉, 결과 토큰 목록에 빈 문자열이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e5f78a295d4a14f6cc590b49dc6f1d0455cd3aab" translate="yes" xml:space="preserve">
          <source>Notice that, as shown in this example, two or more adjacent separator graphemes clusters in &lt;code&gt;String&lt;/code&gt; are treated as one. That is, there are no empty strings in the resulting list of lexemes. See also &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt; which returns empty strings.</source>
          <target state="translated">이 예제에서 볼 수 있듯이 &lt;code&gt;String&lt;/code&gt; 에서 두 개 이상의 인접한 구분자 그래 핀 클러스터는 하나로 취급됩니다. 즉, 결과 룩셈부르크 목록에 빈 문자열이 없습니다. 빈 문자열을 반환하는 &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="400b0bdc7183dd864f7a333eda26b469890b40f9" translate="yes" xml:space="preserve">
          <source>Notice that, for example, using a string literal as in &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;&amp;gt;&amp;gt;&lt;/code&gt; is syntactic sugar for &lt;code&gt;&amp;lt;&amp;lt;$a,$b,$c&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;&amp;gt;&amp;gt;&lt;/code&gt; 에서와 같이 문자열 리터럴을 사용하면 &lt;code&gt;&amp;lt;&amp;lt;$a,$b,$c&amp;gt;&amp;gt;&lt;/code&gt; 구문 설탕입니다 .</target>
        </trans-unit>
        <trans-unit id="87029cbee6aaa0d9b300e7ad0b9486370e279d2c" translate="yes" xml:space="preserve">
          <source>Notice that, using the binary syntax in Erlang, the driver application can match the header directly from the binary, so the header can be put in the binary, and &lt;code&gt;hlen&lt;/code&gt; can be set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Erlang의 이진 구문을 사용하면 드라이버 응용 프로그램이 이진의 헤더를 직접 일치시킬 수 있으므로 이진에 헤더를 넣고 &lt;code&gt;hlen&lt;/code&gt; 을 &lt;code&gt;0&lt;/code&gt; 으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7da0c41f09ad9eda092e8aa0b243d52520a156af" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;--&lt;/code&gt; delimiter in the second case.</source>
          <target state="translated">통지 &lt;code&gt;--&lt;/code&gt; 두 번째 경우에서 구분 기호를.</target>
        </trans-unit>
        <trans-unit id="0a1c8d08a9994e288f56b821c9bf285da6f45d73" translate="yes" xml:space="preserve">
          <source>Notice the following:</source>
          <target state="translated">다음을 주목하십시오 :</target>
        </trans-unit>
        <trans-unit id="d17e22e8a0b70553ac1713fc5aa1e39228341be7" translate="yes" xml:space="preserve">
          <source>Notice the introduction of decimals (floating point numbers) without any explanation. Hopefully you can cope with that.</source>
          <target state="translated">아무런 설명없이 소수 (부동 소수점 숫자)가 표시됩니다. 잘하면 당신은 그것에 대처할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b22b470f990ba70d08ad30ea4441dbab4491e4f1" translate="yes" xml:space="preserve">
          <source>Notice the subtle difference between &lt;strong&gt;matching&lt;/strong&gt; and &lt;strong&gt;comparing equal&lt;/strong&gt;, which is demonstrated by table types &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;ordered_set&lt;/code&gt;:</source>
          <target state="translated">간의 미묘한 차이에 주목 &lt;strong&gt;매칭&lt;/strong&gt; 과 &lt;strong&gt;동일한 비교를&lt;/strong&gt; 테이블 형식에 의해 증명되고, &lt;code&gt;set&lt;/code&gt; 및 &lt;code&gt;ordered_set&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e087413bca56723a464e980cdc7148c95c96c9f5" translate="yes" xml:space="preserve">
          <source>Notice the tags &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;, which are used in the cover specification file and in the call to &lt;code&gt;ct_cover:cross_cover_analyse/2&lt;/code&gt;. The purpose of these is only to map the modules specified in the cover specification to the log directory specified in the call to the analyze function. The tag name has no meaning beyond this.</source>
          <target state="translated">표지 스펙 파일 및 &lt;code&gt;ct_cover:cross_cover_analyse/2&lt;/code&gt; 호출에서 사용되는 태그 &lt;code&gt;s1&lt;/code&gt; 및 &lt;code&gt;s2&lt;/code&gt; 를 확인하십시오 . 이것의 목적은 표지 스펙에 지정된 모듈을 분석 함수 호출에 지정된 로그 디렉토리에 맵핑하는 것입니다. 태그 이름은이 이상의 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7bb5bf565c03d21576042d149b51f71aca7f2ad7" translate="yes" xml:space="preserve">
          <source>Notice the use of brackets, the multiplication operator &quot;*&quot;, and the division operator &quot;/&quot;, as in normal arithmetic (see &lt;code&gt;Expressions&lt;/code&gt;).</source>
          <target state="translated">일반 산술에서와 같이 대괄호, 곱셈 연산자 &quot;*&quot;및 나누기 연산자 &quot;/&quot;가 사용됩니다 ( &lt;code&gt;Expressions&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1979d8b27f27698155a9b9f97c8dffec78cf1316" translate="yes" xml:space="preserve">
          <source>Notice there is no &quot;;&quot; before the &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">&quot;;&quot;가 없습니다. &lt;code&gt;end&lt;/code&gt; 전에 .</target>
        </trans-unit>
        <trans-unit id="b65c33941f0cec9bcc2027c063047fa6bab510b7" translate="yes" xml:space="preserve">
          <source>Notice, however, that the PCRE interpretation of \G, as the start of the current match, is subtly different from Perl, which defines it as the end of the previous match. In Perl, these can be different when the previously matched string was empty. As PCRE does only one match at a time, it cannot reproduce this behavior.</source>
          <target state="translated">그러나 현재 일치의 시작 인 \ G의 PCRE 해석은 이전 일치의 끝으로 정의하는 Perl과 미묘하게 다릅니다. Perl에서는 이전에 일치 한 문자열이 비어있을 때 이것들이 다를 수 있습니다. PCRE는 한 번에 하나의 일치 만 수행하므로이 동작을 재현 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="37be39660f9e3a6ee200e243af96a9c97d0d2344" translate="yes" xml:space="preserve">
          <source>Notifications are defined in SMIv1 with the TRAP-TYPE macro in the definition of an MIB (see RFC1215). The corresponding macro in SMIv2 is NOTIFICATION-TYPE. When an application decides to send a notification, it calls one of the following functions:</source>
          <target state="translated">알림은 MIB 정의에서 TRAP-TYPE 매크로를 사용하여 SMIv1에 정의됩니다 (RFC1215 참조). SMIv2의 해당 매크로는 NOTIFICATION-TYPE입니다. 응용 프로그램에서 알림을 보내려고하면 다음 기능 중 하나를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="ac878d4197ecf46f67e006f7c94c70eec1e149de" translate="yes" xml:space="preserve">
          <source>Notifications/traps from an agent is delivered to the user that did the registration.</source>
          <target state="translated">에이전트의 알림 / 트랩이 등록을 수행 한 사용자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="317ade20c16481c20d662a3475f005419790a5e3" translate="yes" xml:space="preserve">
          <source>Notifies when the driver is reloaded (or loaded if loading is underway). It only makes sense to monitor drivers that are in the process of being loaded or reloaded. A future driver name for loading cannot be monitored. That only results in a &lt;code&gt;DOWN&lt;/code&gt; message sent immediately. Monitoring for loading is therefore most useful when triggered by function &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt;, where the monitor is created &lt;strong&gt;because&lt;/strong&gt; the driver is in such a pending state.</source>
          <target state="translated">드라이버가 다시로드되거나로드가 진행중인 경우로드됩니다. 로드 또는 재로드중인 드라이버를 모니터링하는 것이 좋습니다. 로드 할 향후 드라이버 이름은 모니터링 할 수 없습니다. 그러면 &lt;code&gt;DOWN&lt;/code&gt; 메시지 만 즉시 전송됩니다. 따라서로드 모니터링은 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 함수에 의해 트리거 될 때 가장 유용합니다 . 여기서 드라이버는 보류 상태에 &lt;strong&gt;있기 때문에&lt;/strong&gt; 모니터가 작성 됩니다.</target>
        </trans-unit>
        <trans-unit id="819549857bd0aea6faaa47a0d86a011bee67d2a5" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;A&lt;/code&gt; has generated a digest and its own challenge. Those are sent together in a package to &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;A&lt;/code&gt; 는 다이제스트와 자체 도전을 생성했습니다. 그것들은 패키지로 &lt;code&gt;B&lt;/code&gt; 로 함께 보내집니다 :</target>
        </trans-unit>
        <trans-unit id="70500b06f7a8c7563bdbdac912b202c3e8bf3468" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;complex1:foo/1&lt;/code&gt; and &lt;code&gt;complex1:bar/1&lt;/code&gt; can be implemented. Both send a message to the &lt;code&gt;complex&lt;/code&gt; process and receive the following replies:</source>
          <target state="translated">이제 &lt;code&gt;complex1:foo/1&lt;/code&gt; 및 &lt;code&gt;complex1:bar/1&lt;/code&gt; 을 구현할 수 있습니다. 둘 다 &lt;code&gt;complex&lt;/code&gt; 프로세스에 메시지를 보내고 다음과 같은 응답을받습니다.</target>
        </trans-unit>
        <trans-unit id="afe7e60fc725dac4a8db204c6383ede32658e8ba" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;complex5:foo/1&lt;/code&gt; and &lt;code&gt;complex5:bar/1&lt;/code&gt; can be implemented. Both send a message to the &lt;code&gt;complex&lt;/code&gt; process and receive the following reply:</source>
          <target state="translated">이제 &lt;code&gt;complex5:foo/1&lt;/code&gt; 및 &lt;code&gt;complex5:bar/1&lt;/code&gt; 을 구현할 수 있습니다. 둘 다 &lt;code&gt;complex&lt;/code&gt; 프로세스에 메시지를 보내고 다음과 같은 응답을받습니다.</target>
        </trans-unit>
        <trans-unit id="1d972f3ac97809e6ef3b16135443e10b7f75eb60" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;format_temps(Rest)&lt;/code&gt; is called with the rest of the list as an argument. This way of doing things is similar to the loop constructs in other languages. (Yes, this is recursion, but do not let that worry you.) So the same &lt;code&gt;format_temps&lt;/code&gt; function is called again, this time &lt;code&gt;City&lt;/code&gt; gets the value &lt;code&gt;{cape_town,{f,70}}&lt;/code&gt; and the same procedure is repeated as before. This is done until the list becomes empty, that is [], which causes the first clause &lt;code&gt;format_temps([])&lt;/code&gt; to match. This simply returns (results in) the atom &lt;code&gt;ok&lt;/code&gt;, so the program ends.</source>
          <target state="translated">이제 &lt;code&gt;format_temps(Rest)&lt;/code&gt; 가 나머지 목록과 함께 인수로 호출됩니다. 이 작업 방식은 다른 언어의 루프 구문과 유사합니다. (예, 이것은 재귀이지만 걱정하지 마십시오.) 동일한 &lt;code&gt;format_temps&lt;/code&gt; 함수가 다시 호출됩니다. 이번에는 &lt;code&gt;City&lt;/code&gt; 가 &lt;code&gt;{cape_town,{f,70}}&lt;/code&gt; 값을 가져오고 이전과 동일한 절차가 반복됩니다. 이것은 목록이 비워 질 때까지, 즉 []이며, 이는 첫 번째 절 &lt;code&gt;format_temps([])&lt;/code&gt; 가 일치하게합니다. 이것은 단순히 atom &lt;code&gt;ok&lt;/code&gt; 를 리턴 (결과) 하므로 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f056c1e349914f861b0ec8d256143b66ef033fa2" translate="yes" xml:space="preserve">
          <source>Now Peter logs on at c1@bilbo:</source>
          <target state="translated">이제 Peter는 c1 @ bilbo에 로그온합니다.</target>
        </trans-unit>
        <trans-unit id="3ad12f32c3c04aabc045c91300983e1a4fd664c4" translate="yes" xml:space="preserve">
          <source>Now Peter sends Fred a message:</source>
          <target state="translated">이제 Peter는 Fred에게 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="229ad98b8db4a57370d88832d5c57bc6f3753fe1" translate="yes" xml:space="preserve">
          <source>Now a function has to be added to find the cities with the maximum and minimum temperatures. The following program is not the most efficient way of doing this as you walk through the list of cities four times. But it is better to first strive for clarity and correctness and to make programs efficient only if needed.</source>
          <target state="translated">이제 최대 및 최소 온도의 도시를 찾기위한 기능을 추가해야합니다. 다음 프로그램은 도시 목록을 네 번 걸을 때 가장 효율적인 방법은 아닙니다. 그러나 명확성과 정확성을 위해 먼저 노력하고 필요한 경우에만 프로그램을 효율적으로 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b4bcc5baaf2e6bf86762a62f818283a767c38c4d" translate="yes" xml:space="preserve">
          <source>Now an &lt;code&gt;ETERM&lt;/code&gt; struct that represents the integer result can be constructed using the function &lt;code&gt;erl_mk_int()&lt;/code&gt; from &lt;code&gt;erl_eterm&lt;/code&gt;. The function &lt;code&gt;erl_format()&lt;/code&gt; from the module &lt;code&gt;erl_format&lt;/code&gt; can also be used:</source>
          <target state="translated">이제 &lt;code&gt;ETERM&lt;/code&gt; 의 정수 결과를 나타내는 구조체는 기능하여 구성 될 수 &lt;code&gt;erl_mk_int()&lt;/code&gt; 에서 &lt;code&gt;erl_eterm&lt;/code&gt; 를 . 함수 &lt;code&gt;erl_format()&lt;/code&gt; 모듈에서 &lt;code&gt;erl_format&lt;/code&gt; 가 또한 사용될 수있다 :</target>
        </trans-unit>
        <trans-unit id="0d18575f2f97b95d7041b4a039a472881d09e334" translate="yes" xml:space="preserve">
          <source>Now an example of the ping pong example using links to terminate &quot;pong&quot;:</source>
          <target state="translated">이제 &quot;pong&quot;을 종료하기 위해 링크를 사용하는 핑퐁 예제의 예 :</target>
        </trans-unit>
        <trans-unit id="b5cee5cfc515b6296349cc8ee7e0cb8ec6901dca" translate="yes" xml:space="preserve">
          <source>Now an example of this when working with lists - reversing the order of a list:</source>
          <target state="translated">이제리스트로 작업 할 때리스트의 순서를 반대로 바꾸는 예가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="df7fd43be1dfcb89d9363916c80f74e8a91feb79" translate="yes" xml:space="preserve">
          <source>Now assume that the interpretation of &lt;code&gt;Expression&lt;/code&gt; is a set of calls. If the named type is more general than the expression type, say &lt;code&gt;Mod&lt;/code&gt; and &lt;code&gt;Fun&lt;/code&gt; respectively, then the interpretation of the cast expression is the set of calls (M1, M2) such that the interpretation of the expression contains a call from some function of M1 to some function of M2. If the named type is more special than the expression type, say &lt;code&gt;Fun&lt;/code&gt; and &lt;code&gt;Mod&lt;/code&gt;, then the interpretation is the set of all function calls (F1, F2) such that the interpretation of the expression contains a call (M1, M2) and F1 is a function of M1 and F2 is a function of M2 (in &lt;code&gt;modules&lt;/code&gt; mode, there are no functions calls, so a cast to &lt;code&gt;Fun&lt;/code&gt; always yields an empty set). Again, the conversions to and from applications and releases work analogously.</source>
          <target state="translated">이제 &lt;code&gt;Expression&lt;/code&gt; 의 해석이 일련의 호출 이라고 가정 합니다. 명명 된 유형이 표현식 유형보다 일반인 경우 (예 : &lt;code&gt;Mod&lt;/code&gt; 및 &lt;code&gt;Fun&lt;/code&gt; ) , 캐스트 표현식의 해석은 호출 해석 (M1, M2)으로, 표현식 해석에 M1의 일부 함수의 호출이 포함됩니다. M2의 일부 기능에. 명명 된 유형이 표현식 유형보다 더 특수한 경우 ( &lt;code&gt;Fun&lt;/code&gt; 및 &lt;code&gt;Mod&lt;/code&gt; ) , 해석은 모든 함수 호출 (F1, F2)의 집합이므로 표현식 해석에는 호출 (M1, M2)이 포함되고 F1은 M1 및 F2의 함수는 M2의 함수입니다 ( &lt;code&gt;modules&lt;/code&gt; 모드에서는 함수 호출이 없으므로 캐스트 &lt;code&gt;Fun&lt;/code&gt; 항상 빈 세트를 산출합니다). 다시 말하지만, 응용 프로그램과 릴리스 간의 변환은 유사하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d27e97cc64e73bbb29e8593d9319f121ee940fec" translate="yes" xml:space="preserve">
          <source>Now back to the ping pong example.</source>
          <target state="translated">이제 탁구 예제로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="e1c4d378028d5d21080c935ee35d85591b2310e0" translate="yes" xml:space="preserve">
          <source>Now change directory into the base directory and set the &lt;code&gt;$ERL_TOP&lt;/code&gt; variable.</source>
          <target state="translated">이제 디렉토리를 기본 디렉토리로 변경하고 &lt;code&gt;$ERL_TOP&lt;/code&gt; 변수를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="8740487b8c6e4f56dfebcaaf8cf6bd3325bab300" translate="yes" xml:space="preserve">
          <source>Now for a larger example to consolidate what you have learnt so far. Assume that you have a list of temperature readings from a number of cities in the world. Some of them are in Celsius and some in Fahrenheit (as in the previous list). First let us convert them all to Celsius, then let us print the data neatly.</source>
          <target state="translated">지금까지 배운 내용을 통합하는 더 큰 예를 들어 보겠습니다. 세계 여러 도시의 온도 측정 값 목록이 있다고 가정합니다. 그들 중 일부는 섭씨에 있고 일부는 화씨에 있습니다 (이전 목록에서와 같이). 먼저 모두 섭씨로 변환 한 다음 데이터를 깔끔하게 인쇄하겠습니다.</target>
        </trans-unit>
        <trans-unit id="960dcce598e07679e1563922d8c8ce1be7e2353e" translate="yes" xml:space="preserve">
          <source>Now for a larger example with a simple &quot;messenger&quot;. The messenger is a program that allows users to log in on different nodes and send simple messages to each other.</source>
          <target state="translated">이제 간단한 &quot;메신저&quot;가있는 더 큰 예를 들어 보겠습니다. 메신저는 사용자가 다른 노드에 로그인하여 서로에게 간단한 메시지를 보낼 수있는 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="8f9a8082924a3a55b208b60dc3c2a35c271485ed" translate="yes" xml:space="preserve">
          <source>Now for a more complicated example, the factorial of a number. For example, the factorial of 4 is 4 * 3 * 2 * 1, which equals 24.</source>
          <target state="translated">더 복잡한 예를 들어, 숫자의 계승. 예를 들어, 계승 4는 4 * 3 * 2 * 1이며 24와 같습니다.</target>
        </trans-unit>
        <trans-unit id="85b87f3295c00771011c50c29b24763361547f32" translate="yes" xml:space="preserve">
          <source>Now let us get back to the cities and temperatures, but take a more structured approach this time. First let us convert the whole list to Celsius as follows:</source>
          <target state="translated">이제 도시와 온도로 돌아가 보도록하겠습니다. 이번에는보다 체계적인 접근 방식을 취하십시오. 먼저 다음과 같이 전체 목록을 섭씨로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="f815262fb97682c5acd6fb931562748d09976dd2" translate="yes" xml:space="preserve">
          <source>Now let us get back to the first two lines of the code. Erlang programs are written in files. Each file contains an Erlang &lt;strong&gt;module&lt;/strong&gt;. The first line of code in the module is the module name (see &lt;code&gt;Modules&lt;/code&gt;):</source>
          <target state="translated">이제 코드의 처음 두 줄로 돌아가 봅시다. Erlang 프로그램은 파일로 작성됩니다. 각 파일에는 Erlang &lt;strong&gt;모듈이&lt;/strong&gt; 포함되어 있습니다 . 모듈의 첫 번째 코드 행은 모듈 이름입니다 ( &lt;code&gt;Modules&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0937bc21f5c355b7556a59cf5f4dbd1a5ec043f5" translate="yes" xml:space="preserve">
          <source>Now let us look at the process &quot;ping&quot;. Recall that it was started by executing:</source>
          <target state="translated">이제 &quot;ping&quot;프로세스를 보자. 다음을 실행하여 시작되었음을 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="0930d4eadca76ecb3a8d6bfa6d074f842ec248fa" translate="yes" xml:space="preserve">
          <source>Now run the program:</source>
          <target state="translated">이제 프로그램을 실행하십시오 :</target>
        </trans-unit>
        <trans-unit id="55eb0e0626fb4ef4258288a934f71110a41abd31" translate="yes" xml:space="preserve">
          <source>Now the &quot;pong&quot; process on gollum is started:</source>
          <target state="translated">이제 골룸의 &quot;퐁&quot;프로세스가 시작되었습니다.</target>
        </trans-unit>
        <trans-unit id="5f18e66183fccf43dd04a3319e9abe480c44266d" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;relup&lt;/code&gt; file can be generated:</source>
          <target state="translated">이제 &lt;code&gt;relup&lt;/code&gt; 파일을 생성 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="419ad4c19e6962a17e264cf0565e8680fba59965" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;tut2&lt;/code&gt; program is hardly good programming style. Consider:</source>
          <target state="translated">이제 &lt;code&gt;tut2&lt;/code&gt; 프로그램은 좋은 프로그래밍 스타일이 아닙니다. 치다:</target>
        </trans-unit>
        <trans-unit id="034e7984504e96eaaa52341007b573729c1bfa18" translate="yes" xml:space="preserve">
          <source>Now the C node can be initiated. If short node names are used, this is done by calling &lt;code&gt;erl_connect_init()&lt;/code&gt;:</source>
          <target state="translated">이제 C 노드를 시작할 수 있습니다. 짧은 노드 이름을 사용하는 경우 &lt;code&gt;erl_connect_init()&lt;/code&gt; 를 호출하여 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="cdf6ba8b610923726e867dc5eac6994fcbdfa5a4" translate="yes" xml:space="preserve">
          <source>Now the C node server can accept connections from Erlang nodes:</source>
          <target state="translated">이제 C 노드 서버는 Erlang 노드의 연결을 수락 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3630e70ae8e40d246b34002925292898bb67186e" translate="yes" xml:space="preserve">
          <source>Now we come to something more interesting:</source>
          <target state="translated">이제 우리는 더 흥미로운 것을 보게되었습니다 :</target>
        </trans-unit>
        <trans-unit id="790582ffcd379351fda4ad80a8805b29abc3d15b" translate="yes" xml:space="preserve">
          <source>Now we have a target system that can be started in various ways. We start it as a &lt;strong&gt;basic target system&lt;/strong&gt; by invoking:</source>
          <target state="translated">이제 다양한 방법으로 시작할 수있는 대상 시스템이 있습니다. 다음 을 호출 하여 &lt;strong&gt;기본 대상 시스템&lt;/strong&gt; 으로 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="07e2005a0a6deb7487edffb7259d4bbae161649b" translate="yes" xml:space="preserve">
          <source>Now we look at another interesting pseudo function, &lt;code&gt;garbage_collect&lt;/code&gt;:</source>
          <target state="translated">이제 또 다른 흥미로운 의사 함수 인 &lt;code&gt;garbage_collect&lt;/code&gt; 를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="7baae9db7349907407d97b8497ef107b8eef0dbb" translate="yes" xml:space="preserve">
          <source>Now we want to read data from the table. Function &lt;code&gt;get_until/5&lt;/code&gt; reads data and applies the function until it says that it is done. The result is sent back to the client:</source>
          <target state="translated">이제 테이블에서 데이터를 읽고 싶습니다. 기능 &lt;code&gt;get_until/5&lt;/code&gt; 는 데이터를 읽고 그것이 완료 있다고 때까지 기능을 적용합니다. 결과는 클라이언트로 다시 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="841ad6881ed808c0b00a3ce8e4425eac2fdd57ad" translate="yes" xml:space="preserve">
          <source>Now when the list is converted, a function to print it is added:</source>
          <target state="translated">이제 목록이 변환되면이를 인쇄하는 기능이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f946da2eb954f3f3431f7eaa1a17198b4a4bcad5" translate="yes" xml:space="preserve">
          <source>Now you are set up for some Unicode input and output. The simplest thing to do is to enter a string in the shell:</source>
          <target state="translated">이제 일부 유니 코드 입력 및 출력을 설정했습니다. 가장 간단한 방법은 쉘에 문자열을 입력하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4101ddb4b1ba4c623fe01975aae255730951fb95" translate="yes" xml:space="preserve">
          <source>Now you can check which erlc you have by writing &lt;code&gt;type erlc&lt;/code&gt; in your shell. It should reside in &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt; or &lt;code&gt;$ERL_TOP/erts/etc/win32/msys_tools&lt;/code&gt;.</source>
          <target state="translated">이제 쉘에 &lt;code&gt;type erlc&lt;/code&gt; 을 작성하여 사용중인 erlc를 확인할 수 있습니다 . 그것은에 있어야 &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt; 또는 &lt;code&gt;$ERL_TOP/erts/etc/win32/msys_tools&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6fd06da4ec350e2c1cd2afa53dc7213e2209fc9" translate="yes" xml:space="preserve">
          <source>Now you will have a file called &lt;code&gt;otp_win32_21.exe&lt;/code&gt; or &lt;code&gt;otp_win64_21.exe&lt;/code&gt; in the &lt;code&gt;&amp;lt;installation directory&amp;gt;&lt;/code&gt;, i.e. &lt;code&gt;$ERL_TOP/release/win32&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;&amp;lt;installation directory&amp;gt;&lt;/code&gt; 에 &lt;code&gt;otp_win32_21.exe&lt;/code&gt; 또는 &lt;code&gt;otp_win64_21.exe&lt;/code&gt; 파일이 있습니다 ( 예 : &lt;code&gt;$ERL_TOP/release/win32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="716d0540851d08f95b750091b9b63ae2e0b978fa" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;fact(0)&lt;/code&gt; is called, and the function clauses are scanned sequentially again. First, the pattern &lt;code&gt;N&lt;/code&gt; is matched against 0. The matching succeeds, but the guard (&lt;code&gt;N&amp;gt;0&lt;/code&gt;) is false. Second, the pattern 0 is matched against 0. The matching succeeds and the body is evaluated:</source>
          <target state="translated">이제 &lt;code&gt;fact(0)&lt;/code&gt; 이 호출되고 함수 절이 순차적으로 다시 스캔됩니다. 먼저, 패턴 &lt;code&gt;N&lt;/code&gt; 이 0과 일치합니다. 일치는 성공하지만 가드 ( &lt;code&gt;N&amp;gt;0&lt;/code&gt; )는 false입니다. 둘째, 패턴 0이 0과 일치합니다. 일치가 성공하고 본문이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="98445b1d7f9952b03aea3c602d6261fd2d8aa394" translate="yes" xml:space="preserve">
          <source>Now, back to the example where we wanted to make the output more arranged. With the template:</source>
          <target state="translated">이제 출력을 더 정렬하려는 예제로 돌아갑니다. 템플릿으로 :</target>
        </trans-unit>
        <trans-unit id="0ccacd93bad121d635d3ee2cf04a4a93d66d91bb" translate="yes" xml:space="preserve">
          <source>Now, imagine that as &lt;code&gt;m1&lt;/code&gt; is a library module, it is also often used by system &lt;code&gt;s2&lt;/code&gt;. Test run &lt;code&gt;s2&lt;/code&gt; does not specifically test &lt;code&gt;m1&lt;/code&gt;, but it can still be interesting to see which parts of &lt;code&gt;m1&lt;/code&gt; that are covered by the &lt;code&gt;s2&lt;/code&gt; tests. To do this, &lt;code&gt;m1&lt;/code&gt; can be included also in the cover specification of &lt;code&gt;s2&lt;/code&gt; as follows:</source>
          <target state="translated">이제 &lt;code&gt;m1&lt;/code&gt; 이 라이브러리 모듈이므로 시스템 &lt;code&gt;s2&lt;/code&gt; 에서도 종종 사용 된다고 상상해보십시오 . 테스트 실행 &lt;code&gt;s2&lt;/code&gt; 는 &lt;code&gt;m1&lt;/code&gt; 을 구체적으로 테스트하지는 않지만 &lt;code&gt;s2&lt;/code&gt; 테스트에 포함되는 &lt;code&gt;m1&lt;/code&gt; 의 어떤 부분을 보는 것이 여전히 흥미로울 수 있습니다 . 이를 위해 &lt;code&gt;m1&lt;/code&gt; 은 다음과 같이 &lt;code&gt;s2&lt;/code&gt; 의 커버 사양에도 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33cc55d98c68e73ea0d743377235f62740c45f57" translate="yes" xml:space="preserve">
          <source>Now, such a call to &lt;code&gt;monitor&lt;/code&gt; will instead succeed and a monitor is created. But the monitor will only supervise the connection. That is, a &lt;code&gt;{'DOWN', _, process, _, noconnection}&lt;/code&gt; is the only message that may be received, as the primitive node have no way of reporting the status of the monitored process.</source>
          <target state="translated">이제 이러한 &lt;code&gt;monitor&lt;/code&gt; 호출이 성공하고 모니터가 작성됩니다. 그러나 모니터는 연결 만 감독합니다. 즉, 기본 노드가 모니터 된 프로세스의 상태를보고 할 방법이 없으므로 &lt;code&gt;{'DOWN', _, process, _, noconnection}&lt;/code&gt; 만이 수신 될 수있는 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="815213b4b20368b41071811d96af96cae0ecf6af" translate="yes" xml:space="preserve">
          <source>Now, the fold and the map can be done at the same time:</source>
          <target state="translated">이제 접기와지도를 동시에 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bd172c2b14d17bdd3e0bc285216399b7bf359fd" translate="yes" xml:space="preserve">
          <source>Nowadays, the compiler rewrites list comprehensions into an ordinary recursive function. Using a tail-recursive function with a reverse at the end would be still faster. Or would it? That leads us to the myth that tail-recursive functions are faster than body-recursive functions.</source>
          <target state="translated">오늘날 컴파일러는 목록 이해를 일반적인 재귀 함수로 다시 작성합니다. 끝에서 반대 방향으로 꼬리 재귀 함수를 사용하면 여전히 빠릅니다. 아니면? 그것은 꼬리 재귀 함수가 신체 재귀 함수보다 빠르다는 신화로 우리를 안내합니다.</target>
        </trans-unit>
        <trans-unit id="b2b91a3dd3c62a3480c6550b4ca1758c4ca00cfd" translate="yes" xml:space="preserve">
          <source>Nullary callback function &lt;code&gt;PostFun&lt;/code&gt; is called once after the table was last read. The return value, which is caught, is ignored. If &lt;code&gt;PreFun&lt;/code&gt; has been called for a table, &lt;code&gt;PostFun&lt;/code&gt; is guaranteed to be called for that table, even if the evaluation of the query fails for some reason.</source>
          <target state="translated">테이블을 마지막으로 읽은 후 Nullary 콜백 함수 &lt;code&gt;PostFun&lt;/code&gt; 이 한 번 호출됩니다. 잡힌 리턴 값은 무시됩니다. 경우 &lt;code&gt;PreFun&lt;/code&gt; 이 테이블에 대해 호출 된, &lt;code&gt;PostFun&lt;/code&gt; 는 쿼리의 평가는 어떤 이유로 실패하는 경우에도, 해당 테이블에 대한 호출 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="f11c0821f05eac62af0f028d86dc3849bfa606ca" translate="yes" xml:space="preserve">
          <source>Nullsoft NSIS installer system. You need this to build the self installing package. It's a free open source installer that's much nicer to use than the commercial Wise and Install shield installers. This is the installer we use for commercial releases as well.</source>
          <target state="translated">Nullsoft NSIS 설치 시스템. 자체 설치 패키지를 빌드하려면 이것이 필요합니다. 상용 Wise and Install shield 설치 프로그램보다 사용하기 훨씬 좋은 무료 오픈 소스 설치 프로그램입니다. 이것은 상용 릴리스에도 사용되는 설치 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="576c424c360acfd1497ea21294f140f3cec38c19" translate="yes" xml:space="preserve">
          <source>Number ::= - same as non-negative Erlang integers -</source>
          <target state="translated">숫자 :: =-음이 아닌 Erlang 정수와 동일-</target>
        </trans-unit>
        <trans-unit id="436ff201e33fbebe2f89621894a2abd1c168a9b3" translate="yes" xml:space="preserve">
          <source>Number of acquisitions of this lock.</source>
          <target state="translated">이 잠금 획득 수</target>
        </trans-unit>
        <trans-unit id="156e52de6b6c52ca3695d88a4c555445a9d76e09" translate="yes" xml:space="preserve">
          <source>Number of arguments to a function or fun</source>
          <target state="translated">함수 또는 재미에 대한 인수 수</target>
        </trans-unit>
        <trans-unit id="ed917e86d9f18f03dbcccf6e65ab949d58ed88b7" translate="yes" xml:space="preserve">
          <source>Number of bytes received by the socket.</source>
          <target state="translated">소켓이 수신 한 바이트 수</target>
        </trans-unit>
        <trans-unit id="42046ff77420f4d17e7571e95bf522b706d2b214" translate="yes" xml:space="preserve">
          <source>Number of bytes sent from the socket.</source>
          <target state="translated">소켓에서 보낸 바이트 수</target>
        </trans-unit>
        <trans-unit id="abaddc1ab230437389138952dc901cca420ce997" translate="yes" xml:space="preserve">
          <source>Number of calls from exported functions.</source>
          <target state="translated">내 보낸 함수의 호출 수</target>
        </trans-unit>
        <trans-unit id="b6dc3a193a64eb663d8300e32005cd15708c2213" translate="yes" xml:space="preserve">
          <source>Number of collisions when a thread tried to acquire this lock. This is when a trylock is EBUSY, a write try on read held rw_lock, a try read on write held rw_lock, a thread tries to lock an already locked lock. (Internal states supervises this).</source>
          <target state="translated">스레드가이 잠금을 획득하려고 시도했을 때의 충돌 수 이것은 trylock이 EBUSY, 읽기 보류 rw_lock에 대한 쓰기 시도, 쓰기 보류 rw_lock에 대한 시도 읽기, 스레드가 이미 잠긴 잠금을 잠그려고 시도하는 경우입니다. (내부 국가가이를 감독합니다).</target>
        </trans-unit>
        <trans-unit id="b5befc3bf1ef58e74135162c0668ade7be2434a8" translate="yes" xml:space="preserve">
          <source>Number of data chunks pending receipt</source>
          <target state="translated">수신 보류중인 데이터 청크 수</target>
        </trans-unit>
        <trans-unit id="1788092af3b8a586296aa9df2406a866bfcd033f" translate="yes" xml:space="preserve">
          <source>Number of inbound streams</source>
          <target state="translated">인바운드 스트림 수</target>
        </trans-unit>
        <trans-unit id="0d39785385699f304d2bb821ff68b08bc05cf178" translate="yes" xml:space="preserve">
          <source>Number of lines (processes) to display.</source>
          <target state="translated">표시 할 라인 (프로세스) 수입니다.</target>
        </trans-unit>
        <trans-unit id="c7246b6b50502576f0a38d8a27451c68c1a94bf1" translate="yes" xml:space="preserve">
          <source>Number of links to the file (this is always 1 for file systems that have no concept of links).</source>
          <target state="translated">파일에 대한 링크 수 (링크 개념이없는 파일 시스템의 경우 항상 1 임)</target>
        </trans-unit>
        <trans-unit id="86b7d74929b08d37a5d6bbdc6ce558fa981b1e22" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which a transport connection is terminated following an incoming DPR if the peer does not close the connection.</source>
          <target state="translated">피어가 연결을 닫지 않은 경우 들어오는 DPR 후에 전송 연결이 종료 된 후 경과 된 시간 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="ad84b78a0ee803a8e44abc5c45068c551a8be685" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which a transport connection is terminated following an outgoing DPR if DPA is not received.</source>
          <target state="translated">DPA가 수신되지 않은 경우 발신 DPR에 이어 전송 연결이 종료 된 후 경과 된 시간 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="d143428966dbf2e9b35f53fde260f63542ea0ceb" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which a transport process having an established transport connection will be terminated if the expected capabilities exchange message (CER or CEA) is not received from the peer. For a connecting transport, the timing of connection attempts is governed by &lt;code&gt;&lt;a href=&quot;#connect_timer&quot;&gt;connect_timer&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#watchdog_timer&quot;&gt;watchdog_timer&lt;/a&gt;&lt;/code&gt; expiry. For a listening transport, the peer determines the timing.</source>
          <target state="translated">예상 된 기능 교환 메시지 (CER 또는 CEA)가 피어로부터 수신되지 않으면 전송 연결이 설정된 전송 프로세스가 종료 된 후의 시간 (밀리 초)입니다. 연결 전송의 경우 연결 시도 타이밍은 &lt;code&gt;&lt;a href=&quot;#connect_timer&quot;&gt;connect_timer&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#watchdog_timer&quot;&gt;watchdog_timer&lt;/a&gt;&lt;/code&gt; 만료 에 의해 결정됩니다 . 수신 전송의 경우 피어는 타이밍을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="2a4f3d8f10ea95abb768e6ff37dcd2d263075314" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which the request should timeout. Defaults to 5000.</source>
          <target state="translated">요청이 시간 초과되어야하는 시간 (밀리 초)입니다. 기본값은 5000입니다.</target>
        </trans-unit>
        <trans-unit id="4d5f53d55e482f8b255f961e8335b47ecc984cf9" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which the transport process is terminated if DPA has not been received. Defaults to the value of &lt;code&gt;&lt;a href=&quot;#dpa_timeout&quot;&gt;dpa_timeout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">DPA를받지 못한 경우 전송 프로세스가 종료 된 후 경과 된 시간 (밀리 초)입니다. 기본값은 &lt;code&gt;&lt;a href=&quot;#dpa_timeout&quot;&gt;dpa_timeout&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b185f82b1b5bfaa8854d705b869060e9935cb3a" translate="yes" xml:space="preserve">
          <source>Number of milliseconds left until the message would have been sent.</source>
          <target state="translated">메시지가 전송 될 때까지 남은 시간 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="1d3a9ba15cb753485b84a2ad953f8633c6b1bd33" translate="yes" xml:space="preserve">
          <source>Number of outbound streams</source>
          <target state="translated">아웃 바운드 스트림 수</target>
        </trans-unit>
        <trans-unit id="7cc577409a125b78cfe2310bff5b33c90e99d779" translate="yes" xml:space="preserve">
          <source>Number of packets received by the socket.</source>
          <target state="translated">소켓이 수신 한 패킷 수</target>
        </trans-unit>
        <trans-unit id="6cc46ab9febecbfd1c32816e8e1c042fb0b2037b" translate="yes" xml:space="preserve">
          <source>Number of packets sent from the socket.</source>
          <target state="translated">소켓에서 보낸 패킷 수</target>
        </trans-unit>
        <trans-unit id="0b905814d3355622795966fbb7336f35dc784aab" translate="yes" xml:space="preserve">
          <source>Number of transport processes to start. For a listening transport, determines the size of the pool of accepting transport processes, a larger number being desirable for processing multiple concurrent peer connection attempts. For a connecting transport, determines the number of connections to the peer in question that will be attempted to be establshed: the &lt;code&gt;&lt;a href=&quot;#service_opt&quot;&gt;service_opt()&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;restrict_connections&lt;/code&gt; should also be configured on the service in question to allow multiple connections to the same peer.</source>
          <target state="translated">시작할 전송 프로세스 수 수신 전송의 경우 전송 프로세스 허용 풀의 크기를 결정합니다. 다수의 동시 피어 연결 시도를 처리하는 데 더 많은 수가 바람직합니다. 연결 전송의 경우, 재설정하려는 해당 피어에 대한 연결 수를 판별하십시오 . 동일한 피어에 대한 다중 연결을 허용하려면 해당 서비스에서 &lt;code&gt;&lt;a href=&quot;#service_opt&quot;&gt;service_opt()&lt;/a&gt;&lt;/code&gt; : &lt;code&gt;restrict_connections&lt;/code&gt; 도 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="66bc96661d8742ae05329a683dcb3f84683507cc" translate="yes" xml:space="preserve">
          <source>Number of unacked data chunks</source>
          <target state="translated">언락 된 데이터 청크 수</target>
        </trans-unit>
        <trans-unit id="0b1af9772e5bb4a2a3309eeb320fd315552f0cb5" translate="yes" xml:space="preserve">
          <source>NumberOfAtomCacheRefs/2+1 | 0</source>
          <target state="translated">NumberOfAtomCacheRefs / 2 + 1 | 0</target>
        </trans-unit>
        <trans-unit id="742119a1b0ee0bffbdb7123efbae98b4d4cf4508" translate="yes" xml:space="preserve">
          <source>ODBC Data Type</source>
          <target state="translated">ODBC 데이터 타입</target>
        </trans-unit>
        <trans-unit id="a10c3f25c81a857c7ec7c54210e6931745d9810e" translate="yes" xml:space="preserve">
          <source>OPTIONAL</source>
          <target state="translated">OPTIONAL</target>
        </trans-unit>
        <trans-unit id="fe255781a97feef0174934e6b7b818e19746a2b3" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">선택 과목; 이 함수가 정의되면 &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; 도 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7020f99e2ebb79e7dec7703e4dde7e6f7d3ab62" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_suite-1&quot;&gt;end_per_suite/1&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">선택 과목; 이 함수가 정의되면 &lt;code&gt;&lt;a href=&quot;#Module:end_per_suite-1&quot;&gt;end_per_suite/1&lt;/a&gt;&lt;/code&gt; 도 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb2b3bf247d98944fbe75b41c4379902fac4c0ed" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">선택 과목; 이 함수가 정의되면 &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt; 도 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="811daf24de9dd5fef2b06f207387f6fa44818576" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">선택 과목; 이 함수가 정의되면 &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt; 도 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="09f3a1ee83f65c6b4212698c759ac143edb39e85" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">선택 과목; 이 함수가 정의되면 &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; 도 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="da40ab1589249e13637d8f194c28172da2bf88bf" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">선택 과목; 이 함수가 정의되면 &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; 도 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="34d5721686b9afbeb78f01e3fc667ce57e89931f" translate="yes" xml:space="preserve">
          <source>OS X (Darwin)</source>
          <target state="translated">OS X (다윈)</target>
        </trans-unit>
        <trans-unit id="70a99f3723b01cca80b99d24bb0c2a412b59bf1d" translate="yes" xml:space="preserve">
          <source>OS X 10.6.x / Snow Leopard, OS X 10.7.x / Lion and probably newer versions.</source>
          <target state="translated">OS X 10.6.x / Snow Leopard, OS X 10.7.x / Lion 및 아마도 최신 버전 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="337dc1124caacdd89c2450e56842d52c3f0e6fad" translate="yes" xml:space="preserve">
          <source>OS X/Darwin: Darwin 9.8.0 in 32-bit mode should work.</source>
          <target state="translated">OS X / Darwin : 32 비트 모드의 Darwin 9.8.0이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="164a0c0837ae1b007b5e17a0056a34ade5f8ce3b" translate="yes" xml:space="preserve">
          <source>OS messages are formatted as a tuple &lt;code&gt;{Time, Category, Facility, Severity, Message}&lt;/code&gt;:</source>
          <target state="translated">OS 메시지는 튜플 &lt;code&gt;{Time, Category, Facility, Severity, Message}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d1d16f43b9dc83cb0dfdf26c6b908a0323be7d3" translate="yes" xml:space="preserve">
          <source>OS system time can also be retreived by &lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;system_time/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#system_time-1&quot;&gt;system_time/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;system_time/0&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#system_time-1&quot;&gt;system_time/1&lt;/a&gt;&lt;/code&gt; 로 OS 시스템 시간을 검색 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="253b34ed7414f8bd95bdcad3ec3b4eb61f4c6738" translate="yes" xml:space="preserve">
          <source>OS system time must be correct when the user finalizes the time offset.</source>
          <target state="translated">사용자가 시간 오프셋을 완료하면 OS 시스템 시간이 정확해야합니다.</target>
        </trans-unit>
        <trans-unit id="eb8e226d4cd37fd7c5b423ed6b5c26f687955027" translate="yes" xml:space="preserve">
          <source>OTP also supports changing the internal state of behaviour processes, see &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">OTP는 또한 내부 동작 프로세스 상태 변경을 지원합니다 (내부 상태 &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="4d6221b6a86032737a577d124bf2adb0a2907b66" translate="yes" xml:space="preserve">
          <source>OTP and (in consequence) the Mnesia database.</source>
          <target state="translated">OTP 및 결과적으로 Mnesia 데이터베이스.</target>
        </trans-unit>
        <trans-unit id="8f1f0506b65365d10c75cb9d39c0d18910b4731c" translate="yes" xml:space="preserve">
          <source>OTP of a specific version is a set of applications of specific versions. The application versions identified by an OTP version corresponds to application versions that have been tested together by the Erlang/OTP team at Ericsson AB. An OTP system can, however, be put together with applications from different OTP versions. Such a combination of application versions has not been tested by the Erlang/OTP team. It is therefore &lt;strong&gt;always preferred to use OTP applications from one single OTP version&lt;/strong&gt;.</source>
          <target state="translated">특정 버전의 OTP는 특정 버전의 응용 프로그램 집합입니다. OTP 버전으로 식별 된 응용 프로그램 버전은 Ericsson AB의 Erlang / OTP 팀이 함께 테스트 한 응용 프로그램 버전에 해당합니다. 그러나 OTP 시스템은 다른 OTP 버전의 응용 프로그램과 함께 사용할 수 있습니다. 이러한 응용 프로그램 버전 조합은 Erlang / OTP 팀에서 테스트하지 않았습니다. 따라서 &lt;strong&gt;항상 하나의 단일 OTP 버전에서 OTP 응용 프로그램을 사용하는 것이 좋습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2611693947bb5144c4c4a537a229fe14dfc567db" translate="yes" xml:space="preserve">
          <source>OTP start script example for Unix.</source>
          <target state="translated">유닉스 용 OTP 시작 스크립트 예제.</target>
        </trans-unit>
        <trans-unit id="44ed97d7d2bc021f13ae4421351ee910df8ab6f2" translate="yes" xml:space="preserve">
          <source>OTP supports a set of &lt;strong&gt;release handling instructions&lt;/strong&gt; that are used when creating &lt;code&gt;.appup&lt;/code&gt; files. The release handler understands a subset of these, the &lt;strong&gt;low-level&lt;/strong&gt; instructions. To make it easier for the user, there are also a number of &lt;strong&gt;high-level&lt;/strong&gt; instructions, which are translated to low-level instructions by &lt;code&gt;systools:make_relup&lt;/code&gt;.</source>
          <target state="translated">OTP는 &lt;code&gt;.appup&lt;/code&gt; 파일을 만들 때 사용되는 일련의 &lt;strong&gt;릴리스 처리 지침&lt;/strong&gt; 을 지원 합니다. 릴리스 핸들러는 하위 &lt;strong&gt;레벨&lt;/strong&gt; 명령어 인 이러한 하위 세트를 이해합니다 . 사용자가 쉽게 사용할 수 있도록 &lt;code&gt;systools:make_relup&lt;/code&gt; 에 의해 하위 수준의 명령어로 번역되는 여러 가지 &lt;strong&gt;고급 수준의&lt;/strong&gt; 명령어도 있습니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ab311b5a61d5450520dde937fd634cbc9976caf" translate="yes" xml:space="preserve">
          <source>OTP thus provides no support for changing residence modules except in the case of &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;special processes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">따라서 OTP는 &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;special processes&lt;/a&gt;&lt;/code&gt; 의 경우를 제외하고 거주 모듈 변경을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="15c4e1f1a4334a82cc1247671dd99e92e6bbd166" translate="yes" xml:space="preserve">
          <source>OTP/Crypto requires that the user provides two or three items of information about the key. The application used by the user is usually on a higher level, for example in &lt;code&gt;SSL&lt;/code&gt;. If using the crypto application directly, it is required that:</source>
          <target state="translated">OTP / Crypto에서는 사용자가 키에 대한 두세 가지 정보 항목을 제공해야합니다. 사용자가 사용하는 응용 프로그램은 일반적으로 &lt;code&gt;SSL&lt;/code&gt; 과 같이 더 높은 수준에 있습니다. 암호화 애플리케이션을 직접 사용하는 경우 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e00f6c999c0a17c02e9b5c79025ff5ac5261cb4a" translate="yes" xml:space="preserve">
          <source>Object identifier, a tuple of integers as generated by the &lt;code&gt;ASN.1&lt;/code&gt; compiler.</source>
          <target state="translated">&lt;code&gt;ASN.1&lt;/code&gt; 컴파일러에 의해 생성 된 정수의 터플 인 객체 식별자 .</target>
        </trans-unit>
        <trans-unit id="d389e1fd4f8140b1a2e4262dca91df97551e6b3f" translate="yes" xml:space="preserve">
          <source>Object-based programming with &lt;code&gt;Mnesia&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 를 사용한 객체 기반 프로그래밍</target>
        </trans-unit>
        <trans-unit id="e9756e31b402ef2beef3722149ad80b87a0cb1c1" translate="yes" xml:space="preserve">
          <source>Objects are stored and retrieved through set and get functions. The following example shows how to store integers, floats, strings, and arbitrary binary objects:</source>
          <target state="translated">객체는 set 및 get 함수를 통해 저장 및 검색됩니다. 다음 예제는 정수, 부동 소수점, 문자열 및 임의의 이진 객체를 저장하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="13dfd2b8ca88ce5b44fe927b518926c1e0325e95" translate="yes" xml:space="preserve">
          <source>Objects can be removed from the registry:</source>
          <target state="translated">레지스트리에서 객체를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5b9dd639a75a9d87bd4d53f043c544fbedd0e4c" translate="yes" xml:space="preserve">
          <source>Observe that E2 may differ from E if for instance there are default values defined in &lt;code&gt;my_XML_Schema.xsd&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;my_XML_Schema.xsd&lt;/code&gt; 에 기본값이 정의되어 있으면 E2가 E와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb56c5f19fbe9c5d32b08c312c11052dd5b634b7" translate="yes" xml:space="preserve">
          <source>Observe that the 'TerminationId' record is not used in the internal form. It has been replaced with a megaco_term_id record (defined in &quot;megaco/include/megaco.hrl&quot;).</source>
          <target state="translated">'TerminationId'레코드가 내부 형식으로 사용되지 않는지 확인하십시오. &quot;megaco / include / megaco.hrl&quot;에 정의 된 megaco_term_id 레코드로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="0bd7b307bc7f8afe70fed7a42de3d9fbb7b82fbb" translate="yes" xml:space="preserve">
          <source>Observe that white space: each space, tab or line feed, between mark-up results in an xmlText record.</source>
          <target state="translated">xmlText 레코드의 마크 업 결과 사이의 공백, 탭 또는 줄 바꿈을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ab7e64c97fc5b12d3a53c3eaa9ee4e2f13560916" translate="yes" xml:space="preserve">
          <source>Observer</source>
          <target state="translated">Observer</target>
        </trans-unit>
        <trans-unit id="92d3bdde80720a307b847a6b8a1080bcd444b6aa" translate="yes" xml:space="preserve">
          <source>Observer is a graphical tool for observing the characteristics of Erlang systems. Observer displays system information, application supervisor trees, process information, ETS tables, Mnesia tables and contains a front end for Erlang tracing.</source>
          <target state="translated">관찰자는 Erlang 시스템의 특성을 관찰하기위한 그래픽 도구입니다. Observer는 시스템 정보, 응용 프로그램 감독자 트리, 프로세스 정보, ETS 테이블, Mnesia 테이블을 표시하며 Erlang 추적을위한 프론트 엔드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="28cd1180f301b3154359b73583ee4c15ce0124d5" translate="yes" xml:space="preserve">
          <source>Observer is a graphical tool for observing the characteristics of Erlang systems. The tool Observer displays system information, application supervisor trees, process information, ETS tables, Mnesia tables, and contains a front end for Erlang tracing with module &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">관찰자는 Erlang 시스템의 특성을 관찰하기위한 그래픽 도구입니다. 도구 Observer는 시스템 정보, 응용 프로그램 감독자 트리, 프로세스 정보, ETS 테이블, Mnesia 테이블을 표시하고 &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt; 모듈을 사용한 Erlang 추적을위한 프론트 엔드를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="828b44c38dbd9a16becde3e71362fe411c4b2d3c" translate="yes" xml:space="preserve">
          <source>Obsolete flag without any effect and common misspelling for &lt;code&gt;-setcookie&lt;/code&gt;. Use &lt;code&gt;-setcookie&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;-setcookie&lt;/code&gt; 에 대한 효과와 일반적인 철자가없는 오래된 플래그 입니다. 대신 &lt;code&gt;-setcookie&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8219545b990a3e898482be1f33bdc7f5472c0ab" translate="yes" xml:space="preserve">
          <source>Obviously, PCRE cannot support the interpolation of Perl code. Instead, it supports special syntax for recursion of the entire pattern, and for individual subpattern recursion. After its introduction in PCRE and Python, this kind of recursion was later introduced into Perl at release 5.10.</source>
          <target state="translated">분명히 PCRE는 Perl 코드의 보간을 지원할 수 없습니다. 대신, 전체 패턴의 재귀 및 개별 하위 패턴 재귀에 대한 특수 구문을 지원합니다. PCRE 및 Python에서 소개 된 후 이러한 종류의 재귀는 나중에 릴리스 5.10에서 Perl에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="b15614a1ab393e5aeea9a1c392c3fa0e2e84f379" translate="yes" xml:space="preserve">
          <source>Obviously, that code does not work if the original order of the list is important. If the order of the list must be preserved, do as follows:</source>
          <target state="translated">목록의 원래 순서가 중요한 경우에는 해당 코드가 작동하지 않습니다. 목록의 순서를 유지해야하는 경우 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="8e8dc61a9436adab84db0adcc2c88c413a482fca" translate="yes" xml:space="preserve">
          <source>Of ECDSA keys, only the Normally an RSA, DSA or ECDSA public key, but handling of other public keys can be added.</source>
          <target state="translated">ECDSA 키 중에서 일반적으로 RSA, DSA 또는 ECDSA 공개 키만 있지만 다른 공개 키 처리를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf5975c0e8398e81740d7e6c9235666c7fc797c5" translate="yes" xml:space="preserve">
          <source>Off: Normal black and white display.</source>
          <target state="translated">꺼짐 : 일반 흑백 디스플레이.</target>
        </trans-unit>
        <trans-unit id="5e3b98e05dad157bd1a4bd5b9b0d226314cec835" translate="yes" xml:space="preserve">
          <source>Offline support - &lt;code&gt;systools&lt;/code&gt; for generating scripts and building release packages</source>
          <target state="translated">오프라인 지원- 스크립트 생성 및 릴리스 패키지 작성을위한 &lt;code&gt;systools&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f14b6c908a17fd970288025ad39d8151e0e31dda" translate="yes" xml:space="preserve">
          <source>Offset from the current position.</source>
          <target state="translated">현재 위치에서 오프셋.</target>
        </trans-unit>
        <trans-unit id="48274bc06ce68fdb7834b5006c17db38cfd5bca3" translate="yes" xml:space="preserve">
          <source>Offset from the end of file.</source>
          <target state="translated">파일 끝에서 오프셋.</target>
        </trans-unit>
        <trans-unit id="c21c3314a2e6470603bd3c8f84047cb484b50ba5" translate="yes" xml:space="preserve">
          <source>Ogham</source>
          <target state="translated">Ogham</target>
        </trans-unit>
        <trans-unit id="b9c65c4bca9e4ad28b61b07b9af83fd8c0fb84c8" translate="yes" xml:space="preserve">
          <source>Ogham space mark</source>
          <target state="translated">오검 스페이스 마크</target>
        </trans-unit>
        <trans-unit id="5f8e3c9a997d8c6ac6d8e0cee37f365cfccbf2c1" translate="yes" xml:space="preserve">
          <source>Ol_Chiki</source>
          <target state="translated">Ol_Chiki</target>
        </trans-unit>
        <trans-unit id="9ae910bfed0c2daf647c1a19f49b4a126bc16739" translate="yes" xml:space="preserve">
          <source>Old drivers (compiled with an &lt;code&gt;erl_driver.h&lt;/code&gt; from an ERTS version earlier than 5.9) must be updated and have to use the extended interface (with &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">5.9 이전의 ERTS 버전에서 &lt;code&gt;erl_driver.h&lt;/code&gt; 로 컴파일 된 이전 드라이버 는 업데이트되어야하며 확장 인터페이스 ( &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; ) 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="157d75488b894d1cda756fa16127123d4d8b2331" translate="yes" xml:space="preserve">
          <source>OldBindType</source>
          <target state="translated">OldBindType</target>
        </trans-unit>
        <trans-unit id="7f70150bb048b630bda877379e329b1cba4ccf5d" translate="yes" xml:space="preserve">
          <source>OldBlockState</source>
          <target state="translated">OldBlockState</target>
        </trans-unit>
        <trans-unit id="dc265f2b8ca2bd1379067a84bcb36eee5f10c186" translate="yes" xml:space="preserve">
          <source>OldBoolean</source>
          <target state="translated">OldBoolean</target>
        </trans-unit>
        <trans-unit id="787f17ec93244a470977d9765b05c214ad524302" translate="yes" xml:space="preserve">
          <source>OldCpuTopology</source>
          <target state="translated">OldCpuTopology</target>
        </trans-unit>
        <trans-unit id="05284679f579d778eb76c6cb35f0adb51c1143c0" translate="yes" xml:space="preserve">
          <source>OldDirtyCPUSchedulersOnline</source>
          <target state="translated">OldDirtyCPUSchedulersOnline</target>
        </trans-unit>
        <trans-unit id="a1967122f5b0089c8c148736f325420c2e6e602a" translate="yes" xml:space="preserve">
          <source>OldMaxHeapSize</source>
          <target state="translated">OldMaxHeapSize</target>
        </trans-unit>
        <trans-unit id="44bb9d52af1c27b72d85ec222d49edbefed7f191" translate="yes" xml:space="preserve">
          <source>OldMinBinVHeapSize</source>
          <target state="translated">OldMinBinVHeapSize</target>
        </trans-unit>
        <trans-unit id="f03c39aabd48a51861a01442c2abd764c60f8791" translate="yes" xml:space="preserve">
          <source>OldMinHeapSize</source>
          <target state="translated">OldMinHeapSize</target>
        </trans-unit>
        <trans-unit id="a2eedd11d2145f39f33a241d59529adc2aae480c" translate="yes" xml:space="preserve">
          <source>OldSchedulersOnline</source>
          <target state="translated">OldSchedulersOnline</target>
        </trans-unit>
        <trans-unit id="145ae46273aca133d92d9931894007faba8a6122" translate="yes" xml:space="preserve">
          <source>OldState</source>
          <target state="translated">OldState</target>
        </trans-unit>
        <trans-unit id="d31721795f21dfce26688a7f8239a17ca4259705" translate="yes" xml:space="preserve">
          <source>Old_Italic</source>
          <target state="translated">Old_Italic</target>
        </trans-unit>
        <trans-unit id="2c0a6c802c2e969dfccf2fc785162a6f2b61c2bf" translate="yes" xml:space="preserve">
          <source>Old_North_Arabian</source>
          <target state="translated">Old_North_Arabian</target>
        </trans-unit>
        <trans-unit id="18fae1f67a0f3b95f77e39e31f33b8e9c0d5f5cb" translate="yes" xml:space="preserve">
          <source>Old_Permic</source>
          <target state="translated">Old_Permic</target>
        </trans-unit>
        <trans-unit id="40f6b23336b20230fad65810979b94941509719d" translate="yes" xml:space="preserve">
          <source>Old_Persian</source>
          <target state="translated">Old_Persian</target>
        </trans-unit>
        <trans-unit id="338432c6b8828a6dc79884aa878e0a2867c42479" translate="yes" xml:space="preserve">
          <source>Old_South_Arabian</source>
          <target state="translated">Old_South_Arabian</target>
        </trans-unit>
        <trans-unit id="3641abb7a588932eef54e644e9d1dff8f948abbf" translate="yes" xml:space="preserve">
          <source>Old_Turkic</source>
          <target state="translated">Old_Turkic</target>
        </trans-unit>
        <trans-unit id="3c4dff48e0bc069d363085bc649284833fa87dbe" translate="yes" xml:space="preserve">
          <source>Omit the &lt;code&gt;options&lt;/code&gt; and &lt;code&gt;source&lt;/code&gt; tuples in the list returned by &lt;code&gt;Module:module_info(compile)&lt;/code&gt;. This option will make it easier to achieve reproducible builds.</source>
          <target state="translated">&lt;code&gt;Module:module_info(compile)&lt;/code&gt; 리턴 한 목록에서 &lt;code&gt;options&lt;/code&gt; 및 &lt;code&gt;source&lt;/code&gt; 튜플을 생략하십시오 . 이 옵션을 사용하면 재현 가능한 빌드를보다 쉽게 ​​수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1489713bac73f4571aa2114bb6a0e8bece846ba" translate="yes" xml:space="preserve">
          <source>Omits line number information to produce a slightly smaller output file.</source>
          <target state="translated">줄 번호 정보를 생략하여 약간 더 작은 출력 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ece5ff7a95f46bc465af7ccdd8565b862f2ad117" translate="yes" xml:space="preserve">
          <source>Omitted fields then get the value of evaluating &lt;code&gt;ExprL&lt;/code&gt; instead of their default values. This feature is primarily intended to be used to create patterns for ETS and Mnesia match functions.</source>
          <target state="translated">생략 된 필드 는 기본값 대신 &lt;code&gt;ExprL&lt;/code&gt; 을 평가하는 값을 얻습니다 . 이 기능은 주로 ETS 및 Mnesia 일치 기능에 대한 패턴을 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="837ccb981f94461d47fadaa07a7f5c5a91558bf2" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures: -134217729 &amp;lt; i &amp;lt; 134217728 (28 bits).</source>
          <target state="translated">32 비트 아키텍처 : -134217729 &amp;lt;i &amp;lt;134217728 (28 비트).</target>
        </trans-unit>
        <trans-unit id="07aa96ddf4a255f77698c1f72e8dbbc6f7d0ac40" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures: 4 words.</source>
          <target state="translated">32 비트 아키텍처 : 4 워드</target>
        </trans-unit>
        <trans-unit id="0aaea3805ba5a1657f963cc5531935c14dbff051" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures: 5 words for a reference from the current local node + 7 words for a reference from another node.</source>
          <target state="translated">32 비트 아키텍처 : 현재 로컬 노드에서 참조하는 5 워드 + 다른 노드에서 참조하는 7 워드</target>
        </trans-unit>
        <trans-unit id="7773ad37cb673ee9b7860d0d4b67f31e39b62273" translate="yes" xml:space="preserve">
          <source>On 64-bit architectures: -576460752303423489 &amp;lt; i &amp;lt; 576460752303423488 (60 bits).</source>
          <target state="translated">64 비트 아키텍처 : -576460752303423489 &amp;lt;i &amp;lt;576460752303423488 (60 비트).</target>
        </trans-unit>
        <trans-unit id="ccffdbcaffb960350b1f03947273d32a77218dd0" translate="yes" xml:space="preserve">
          <source>On 64-bit architectures: 3 words.</source>
          <target state="translated">64 비트 아키텍처 : 3 워드</target>
        </trans-unit>
        <trans-unit id="f4432adb4e3eddcf803da55fd62c8256f8c01dca" translate="yes" xml:space="preserve">
          <source>On 64-bit architectures: 4 words for a reference from the current local node + 6 words for a reference from another node.</source>
          <target state="translated">64 비트 아키텍처 : 현재 로컬 노드에서 참조하는 4 워드 + 다른 노드에서 참조하는 6 워드</target>
        </trans-unit>
        <trans-unit id="883c639f7255c347e035338f052f0ec88dae56ed" translate="yes" xml:space="preserve">
          <source>On C-nodes, &lt;code&gt;erl_interface&lt;/code&gt; has support for registry tables. These tables reside in RAM on the C-node, but can also be dumped into Mnesia tables. By default, the dumping of registry tables through &lt;code&gt;erl_interface&lt;/code&gt; causes a corresponding Mnesia table to be created with &lt;code&gt;mnesia_registry:create_table/1&lt;/code&gt;, if necessary.</source>
          <target state="translated">C- 노드에서 &lt;code&gt;erl_interface&lt;/code&gt; 는 레지스트리 테이블을 지원합니다. 이 테이블은 C 노드의 RAM에 있지만 Mnesia 테이블로 덤프 할 수도 있습니다. 기본적으로 &lt;code&gt;erl_interface&lt;/code&gt; 를 통해 레지스트리 테이블을 덤프 하면 필요한 경우 &lt;code&gt;mnesia_registry:create_table/1&lt;/code&gt; 로 해당 Mnesia 테이블이 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="53c351034515d0f74abb562de89183321dc3361d" translate="yes" xml:space="preserve">
          <source>On Darwin:</source>
          <target state="translated">다윈에서 :</target>
        </trans-unit>
        <trans-unit id="452d25bd3843cd164bb696cf08ee12ab9733accf" translate="yes" xml:space="preserve">
          <source>On Linux or UNIX you can safely ignore this and simply create a file called &lt;code&gt;.erlang.cookie&lt;/code&gt; in the directory you get to after executing the command &lt;code&gt;cd&lt;/code&gt; without any argument.</source>
          <target state="translated">Linux 또는 UNIX에서는이를 무시하고 인수없이 &lt;code&gt;cd&lt;/code&gt; 명령을 실행 한 후 얻는 디렉토리에 &lt;code&gt;.erlang.cookie&lt;/code&gt; 라는 파일을 작성하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="07b320892e617ecd19e1d9117dbdaedf7a5983f2" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt;.</source>
          <target state="translated">Linux : os 환경 변수 &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; 을 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="6c57c64ae3b58fcb5970a5f623f9d3c0f6952789" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt;.</source>
          <target state="translated">Linux : os 환경 변수 &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt; 를 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="99ba5d0f7bf487770a0030a3221eab9acf0e29cb" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt;.</source>
          <target state="translated">Linux : os 환경 변수 &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 을 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="53587ca09ddf330890e10222f1f28d673e022a4f" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt;.</source>
          <target state="translated">Linux : os 환경 변수 &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; 를 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="d2fc503485c3bbe6875742c0c55de66f8b01c934" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_DATA_HOME&lt;/code&gt;.</source>
          <target state="translated">Linux : os 환경 변수 &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; 을 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="0127285f8943bba8fbcf06e2c56b836011b620f8" translate="yes" xml:space="preserve">
          <source>On UNIX, the release handler tells the &lt;code&gt;heart&lt;/code&gt; program which command to use to reboot the system. The environment variable &lt;code&gt;HEART_COMMAND&lt;/code&gt;, normally used by the &lt;code&gt;heart&lt;/code&gt; program, is ignored in this case. The command instead defaults to &lt;code&gt;$ROOT/bin/start&lt;/code&gt;. Another command can be set by using the SASL configuration parameter &lt;code&gt;start_prg&lt;/code&gt;, see the &lt;code&gt;sasl(6)&lt;/code&gt; manual page.</source>
          <target state="translated">UNIX에서 릴리스 핸들러는 시스템을 재부팅하는 데 사용할 명령을 &lt;code&gt;heart&lt;/code&gt; 프로그램에 알려줍니다 . 이 경우 일반적으로 &lt;code&gt;heart&lt;/code&gt; 프로그램에서 사용하는 환경 변수 &lt;code&gt;HEART_COMMAND&lt;/code&gt; 는 무시됩니다. 대신이 명령의 기본값은 &lt;code&gt;$ROOT/bin/start&lt;/code&gt; 입니다. SASL 구성 매개 변수 &lt;code&gt;start_prg&lt;/code&gt; 를 사용하여 다른 명령을 설정할 수 있습니다 . &lt;code&gt;sasl(6)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9712a16713ddd036d7484cde8377ae9fea3bea13" translate="yes" xml:space="preserve">
          <source>On Ubuntu this can be installed via &lt;code&gt;aptitude&lt;/code&gt;:</source>
          <target state="translated">우분투에서는 &lt;code&gt;aptitude&lt;/code&gt; 를 통해 설치할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="945f7eb32fc020ed4cd606f8c4ad2c5835f8ead0" translate="yes" xml:space="preserve">
          <source>On Unix platforms, other bits than those listed above may be set.</source>
          <target state="translated">Unix 플랫폼에서는 위에 나열된 것 이외의 다른 비트가 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbea9d064da3b38737aba3e1e6b3c867dfe36620" translate="yes" xml:space="preserve">
          <source>On Unix platforms, the environment is set using UTF-8 encoding if Unicode filename translation is in effect. On Windows, the environment is set using wide character interfaces.</source>
          <target state="translated">Unix 플랫폼에서 유니 코드 파일 이름 변환이 적용되는 경우 환경은 UTF-8 인코딩을 사용하여 설정됩니다. Windows에서 환경은 와이드 문자 인터페이스를 사용하여 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="864179103393e4079015a89879456910e0840ba4" translate="yes" xml:space="preserve">
          <source>On Unix systems, the Erlang runtime will interpret two types of signals.</source>
          <target state="translated">Unix 시스템에서 Erlang 런타임은 두 가지 유형의 신호를 해석합니다.</target>
        </trans-unit>
        <trans-unit id="42f4a0b9ff2bf60e97136e578acd75fee6a21d57" translate="yes" xml:space="preserve">
          <source>On Unix the &lt;code&gt;event&lt;/code&gt; is a pipe or socket handle (or something that the &lt;code&gt;select&lt;/code&gt; system call understands).</source>
          <target state="translated">Unix에서 &lt;code&gt;event&lt;/code&gt; 는 파이프 또는 소켓 핸들 (또는 &lt;code&gt;select&lt;/code&gt; 시스템 호출이 이해하는 것)입니다.</target>
        </trans-unit>
        <trans-unit id="89488e0941b289b30ca17db0724ef6eb3f8cddfc" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;code&gt;Osname&lt;/code&gt; has the same value as &lt;code&gt;uname -s&lt;/code&gt; returns, but in lower case. For example, on Solaris 1 and 2, it is &lt;code&gt;sunos&lt;/code&gt;.</source>
          <target state="translated">Unix에서 &lt;code&gt;Osname&lt;/code&gt; 은 &lt;code&gt;uname -s&lt;/code&gt; 반환 값과 같은 값을 갖지만 소문자 는 다릅니다 . 예를 들어, Solaris 1 및 2에서 &lt;code&gt;sunos&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6f9abb41d788d59d3b3b9428af793da0ceb8018a" translate="yes" xml:space="preserve">
          <source>On Unix, any value specified for this field is ignored (the &quot;ctime&quot; for the file is set to the current time). On Windows, this field is the new creation time to set for the file.</source>
          <target state="translated">Unix에서이 필드에 지정된 값은 무시됩니다 (파일의 &quot;ctime&quot;은 현재 시간으로 설정 됨). Windows에서이 필드는 파일에 설정할 새로운 작성 시간입니다.</target>
        </trans-unit>
        <trans-unit id="2f21108f8f59c58399736174f45da9282d8305fe" translate="yes" xml:space="preserve">
          <source>On Unix-like operating systems, parameters are expected to be UTF-8 without translation if Unicode filenames are enabled.</source>
          <target state="translated">유닉스 계열 운영 체제에서 유니 코드 파일 이름이 활성화 된 경우 매개 변수는 변환없이 UTF-8이 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="624724bf76a78b8d09ce52016c5a6eefce217dcc" translate="yes" xml:space="preserve">
          <source>On Unix-like operating systems, the terminal is to be able to handle UTF-8 on input and output (this is done by, for example, modern versions of XTerm, KDE Konsole, and the Gnome terminal) and your locale settings must be proper. As an example, a &lt;code&gt;LANG&lt;/code&gt; environment variable can be set as follows:</source>
          <target state="translated">Unix와 유사한 운영 체제에서 터미널은 입력 및 출력에서 ​​UTF-8을 처리 할 수 ​​있어야하며 (예 : 최신 버전의 XTerm, KDE Konsole 및 Gnome 터미널에 의해 수행됨) 로케일 설정은 다음과 같아야합니다. 적절한. 예를 들어, &lt;code&gt;LANG&lt;/code&gt; 환경 변수는 다음과 같이 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3343aa00325e17effeba793420c23aae68f68a75" translate="yes" xml:space="preserve">
          <source>On Windows XP, select &lt;strong&gt;Control Panel&lt;/strong&gt; &amp;gt; &lt;strong&gt;Regional and Language Options&lt;/strong&gt;, select tab &lt;strong&gt;Language&lt;/strong&gt;, and click button &lt;strong&gt;Details...&lt;/strong&gt; in the square named &lt;strong&gt;Text Services and Input Languages&lt;/strong&gt;.</source>
          <target state="translated">윈도우 XP에서 선택 &lt;strong&gt;제어판&lt;/strong&gt; &amp;gt; &lt;strong&gt;국가 및 언어 옵션을&lt;/strong&gt; 탭 선택 &lt;strong&gt;언어&lt;/strong&gt; , 버튼 클릭 &lt;strong&gt;... 세부 정보&lt;/strong&gt; 광장라는 이름의 &lt;strong&gt;텍스트 서비스 및 입력 언어&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7bdd9c7b68e080175354bdf3fad784b9f495039c" translate="yes" xml:space="preserve">
          <source>On Windows platforms, Erlang searches the system registry rather than looks for configuration files when started in long name distributed mode.</source>
          <target state="translated">Windows 플랫폼에서 Erlang은 긴 이름 분산 모드로 시작할 때 구성 파일을 찾는 대신 시스템 레지스트리를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="e26d25aabbde72aeec251ac7d6d7e8b7d5ff65e1" translate="yes" xml:space="preserve">
          <source>On Windows systems the home directory is the directory pointed out by the environment variable $HOME - you may need to set this.</source>
          <target state="translated">Windows 시스템에서 홈 디렉토리는 환경 변수 $ HOME에 의해 지정된 디렉토리입니다.이를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5c1eb5371b5194cdf64f66156f192b541e886e24" translate="yes" xml:space="preserve">
          <source>On Windows the &lt;code&gt;event&lt;/code&gt; is an &lt;code&gt;Event&lt;/code&gt; or &lt;code&gt;Semaphore&lt;/code&gt; (or something that the &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; API function understands). (Some trickery in the emulator allows more than the built-in limit of 64 &lt;code&gt;Events&lt;/code&gt; to be used.)</source>
          <target state="translated">Windows에서 &lt;code&gt;event&lt;/code&gt; 는 &lt;code&gt;Event&lt;/code&gt; 또는 &lt;code&gt;Semaphore&lt;/code&gt; (또는 &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; API 함수가 이해하는 것)입니다. (에뮬레이터의 일부 트릭은 64 개 이상의 &lt;code&gt;Events&lt;/code&gt; 제한을 사용할 수있게합니다.)</target>
        </trans-unit>
        <trans-unit id="07f408912d4e25cbe3e69c344bbf252be7275718" translate="yes" xml:space="preserve">
          <source>On Windows the default value is set to &lt;code&gt;8196&lt;/code&gt; because the normal OS limitations are set higher than most machines can handle.</source>
          <target state="translated">Windows에서는 일반 OS 제한이 대부분의 시스템이 처리 할 수있는 것보다 높게 설정되어 있기 때문에 기본값은 &lt;code&gt;8196&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="818c5818d712a93bb76a90d8f6ce9237479e8047" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;Osname&lt;/code&gt; is &lt;code&gt;nt&lt;/code&gt;.</source>
          <target state="translated">Windows에서 &lt;code&gt;Osname&lt;/code&gt; 은 &lt;code&gt;nt&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="08a45149384450c4928eab3da298a998b5209ee6" translate="yes" xml:space="preserve">
          <source>On Windows, proper operation requires that a suitable font is installed and selected for the Erlang application to use. If no suitable font is available on your system, try installing the &lt;code&gt;&lt;a href=&quot;http://dejavu-fonts.org&quot;&gt;DejaVu fonts&lt;/a&gt;&lt;/code&gt;, which are freely available, and then select that font in the Erlang shell application.</source>
          <target state="translated">Windows에서 올바른 작동을 위해서는 Erlang 응용 프로그램에서 사용할 적절한 글꼴을 설치하고 선택해야합니다. 시스템에 적합한 글꼴이없는 경우 무료로 제공되는 &lt;code&gt;&lt;a href=&quot;http://dejavu-fonts.org&quot;&gt;DejaVu fonts&lt;/a&gt;&lt;/code&gt; 설치 한 다음 Erlang 쉘 응용 프로그램에서 해당 글꼴을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="73a6c028854ad01eefd9a69b170bcc32b5780e1c" translate="yes" xml:space="preserve">
          <source>On Windows, the data is fetched from different OS API functions, so the &lt;code&gt;Netmask&lt;/code&gt; and &lt;code&gt;Broadaddr&lt;/code&gt; values can be calculated, just as some &lt;code&gt;Flag&lt;/code&gt; values. Report flagrant bugs.</source>
          <target state="translated">Windows에서는 다른 OS API 함수에서 데이터를 가져 오기 때문에 일부 &lt;code&gt;Flag&lt;/code&gt; 값 과 &lt;code&gt;Broadaddr&lt;/code&gt; &lt;code&gt;Netmask&lt;/code&gt; 및 Broadaddr 값을 계산할 수 있습니다 . 악의적 인 버그보고</target>
        </trans-unit>
        <trans-unit id="0e5200c5fc7e9186939f4793a54da361f708e107" translate="yes" xml:space="preserve">
          <source>On Windows, the preferred way to start the Erlang system for interactive use is as follows:</source>
          <target state="translated">Windows에서 대화식 사용을 위해 Erlang 시스템을 시작하는 기본 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e3c787c6250b0d27168a0579a029fe138a257fab" translate="yes" xml:space="preserve">
          <source>On Windows, use semi-colon as separator.</source>
          <target state="translated">Windows에서는 세미콜론을 구분 기호로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">Windows에서 :</target>
        </trans-unit>
        <trans-unit id="91de63a646561418f6b7e070668224cb4764e75e" translate="yes" xml:space="preserve">
          <source>On a Unix system you can view the manual pages from the command line using</source>
          <target state="translated">유닉스 시스템에서는 다음을 사용하여 명령 행에서 매뉴얼 페이지를 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="3c1e7fbc1efc10479b9f342b1427cfdbfeabd446" translate="yes" xml:space="preserve">
          <source>On a Unix-like system, &lt;code&gt;ERL_LIBS&lt;/code&gt; can be set to the following</source>
          <target state="translated">유닉스 계열 시스템에서 &lt;code&gt;ERL_LIBS&lt;/code&gt; 는 다음과 같이 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a74d3fb56059df82993a50e11000b4ec43a6e044" translate="yes" xml:space="preserve">
          <source>On a conceptual level starting a database connection using the Erlang ODBC API is a basic client server application. The client process uses the API to start and communicate with the server process that manages the connection. The strategy of the Erlang ODBC application is that programming faults in the application itself will cause the connection process to terminate abnormally.(When a process terminates abnormally its supervisor will log relevant error reports.) Calls to API functions during or after termination of the connection process, will return &lt;code&gt;{error, connection_closed}&lt;/code&gt;. Contextual errors on the other hand will not terminate the connection it will only return &lt;code&gt;{error, Reason}&lt;/code&gt; to the client, where &lt;code&gt;Reason&lt;/code&gt; may be any erlang term.</source>
          <target state="translated">개념적인 수준에서 Erlang ODBC API를 사용하여 데이터베이스 연결을 시작하는 것은 기본 클라이언트 서버 애플리케이션입니다. 클라이언트 프로세스는 API를 사용하여 연결을 관리하는 서버 프로세스를 시작하고 통신합니다. Erlang ODBC 응용 프로그램의 전략은 응용 프로그램 자체의 프로그래밍 오류로 인해 연결 프로세스가 비정상적으로 종료되는 것입니다 (프로세스가 비정상적으로 종료되면 관리자가 관련 오류 보고서를 기록합니다). 연결 종료 중 또는 종료 후 API 함수 호출 프로세스는 &lt;code&gt;{error, connection_closed}&lt;/code&gt; 반환 합니다. 반면 상황에 따른 오류는 연결을 종료하지 않으며 &lt;code&gt;{error, Reason}&lt;/code&gt; 만 클라이언트에게 반환 합니다. 여기서 &lt;code&gt;Reason&lt;/code&gt; 은 잘못된 용어 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d392ddbe029a1a10ad20de9a806356a9c906b21" translate="yes" xml:space="preserve">
          <source>On a file, a term is represented by a header and a binary. Two options define the format of terms on files:</source>
          <target state="translated">파일에서 용어는 헤더와 이진으로 표시됩니다. 두 가지 옵션은 파일에서 용어의 형식을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0a1100e7bfb6397c36a4da859d5dfb1b68d51802" translate="yes" xml:space="preserve">
          <source>On a single core system or if it's a non-reentrant scanner, a single port is created. On a multi-core system with a reentrant scanner, several ports will be created (one for each scheduler).</source>
          <target state="translated">단일 코어 시스템 또는 재진입 할 ​​수없는 스캐너 인 경우 단일 포트가 작성됩니다. 재진입 스캐너가있는 멀티 코어 시스템에서는 여러 개의 포트가 작성됩니다 (각 스케줄러마다 하나씩).</target>
        </trans-unit>
        <trans-unit id="b61c13a696c2951dde75411aaee46764defe2d53" translate="yes" xml:space="preserve">
          <source>On a system where release handling is used, this is always to be set to &lt;code&gt;ignore&lt;/code&gt;. Use &lt;code&gt;heart&lt;/code&gt; to restart the service on failure instead.</source>
          <target state="translated">릴리스 처리가 사용되는 시스템에서는 항상 &lt;code&gt;ignore&lt;/code&gt; 로 설정해야 합니다. 대신 실패시 서비스를 다시 시작 하려면 &lt;code&gt;heart&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca5dabff07309a8980fe16e2ce2d9b17947978e9" translate="yes" xml:space="preserve">
          <source>On a system without OS monotonic time, Erlang monotonic time guarantees monotonicity, but cannot give other guarantees. The frequency adjustments made to Erlang monotonic time depend on the time warp mode used.</source>
          <target state="translated">OS 단조 시간이없는 시스템에서 Erlang 단조 시간은 단 조성을 보장하지만 다른 보장은 제공 할 수 없습니다. Erlang 단조 시간에 대한 주파수 조정은 사용 된 시간 왜곡 모드에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c10079e3d3b4af33197f73508809dcf8be943c1b" translate="yes" xml:space="preserve">
          <source>On an embedded system it is not uncommon that the system has no power supply, not even a battery, when it is shut off. The system clock on such a system is typically way off when the system boots. If &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used, and the Erlang runtime system is started before OS system time has been corrected, Erlang system time can be wrong for a long time, centuries or even longer.</source>
          <target state="translated">내장형 시스템에서는 시스템을 종료 할 때 시스템에 배터리가 아닌 전원 공급 장치가없는 경우가 드물지 않습니다. 이러한 시스템의 시스템 클럭은 일반적으로 시스템 부팅시 꺼집니다. 경우 &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; 사용되지 않으며, OS의 시스템 시간이 수정되기 전에 얼랑 런타임 시스템이 시작될 때, 얼랑 시스템 시간은 긴 시간, 세기 또는 이상 잘못 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94848f950b79b2c5a62062642414a0d81b6809e5" translate="yes" xml:space="preserve">
          <source>On an embedded system, the &lt;code&gt;erlsrv&lt;/code&gt; module is to be used to install the Erlang process as a Windows system service. This service can start after Windows NT has booted.</source>
          <target state="translated">임베디드 시스템에서 &lt;code&gt;erlsrv&lt;/code&gt; 모듈은 Erlang 프로세스를 Windows 시스템 서비스로 설치하는 데 사용됩니다. 이 서비스는 Windows NT가 부팅 된 후에 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6e74b9f0f9fc530f5a5a031fbc8a47d65641b3d" translate="yes" xml:space="preserve">
          <source>On application (&lt;code&gt;app&lt;/code&gt;) level, the following options are supported:</source>
          <target state="translated">애플리케이션 ( &lt;code&gt;app&lt;/code&gt; ) 레벨에서 다음 옵션이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8c2c100f87c410005b9664bcf1790490ce2930c4" translate="yes" xml:space="preserve">
          <source>On application (&lt;code&gt;escript&lt;/code&gt;) level, the following options are supported:</source>
          <target state="translated">응용 프로그램 ( &lt;code&gt;escript&lt;/code&gt; ) 레벨에서 다음 옵션이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1f2ca7be500feda1d827cc1f5458cea971c16dda" translate="yes" xml:space="preserve">
          <source>On builds without &lt;code&gt;crypto&lt;/code&gt;, &lt;code&gt;ssl&lt;/code&gt; and &lt;code&gt;ssh&lt;/code&gt; there is a failed test case for undefined functions. Verify that the failed test case log only shows calls to skipped applications.</source>
          <target state="translated">&lt;code&gt;crypto&lt;/code&gt; , &lt;code&gt;ssl&lt;/code&gt; 및 &lt;code&gt;ssh&lt;/code&gt; 가 없는 빌드 에서는 정의되지 않은 함수에 대한 테스트 케이스가 실패했습니다. 실패한 테스트 사례 로그에 건너 뛴 응용 프로그램에 대한 호출 만 표시되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7b33a0aa47e36eff9a9acf946284dbd48855b743" translate="yes" xml:space="preserve">
          <source>On each Erlang node, a process can be set as the &lt;strong&gt;system tracer&lt;/strong&gt;. This process will receive trace messages each time a message with a trace token is sent or received (if the trace token flag &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;'receive'&lt;/code&gt; is set). The system tracer can then print each trace event, write it to a file, or whatever suitable.</source>
          <target state="translated">각 Erlang 노드에서 프로세스를 &lt;strong&gt;시스템 추적 프로그램&lt;/strong&gt; 으로 설정할 수 있습니다 . 이 프로세스는 추적 토큰이있는 메시지가 전송되거나 수신 될 때마다 (추적 토큰 플래그 &lt;code&gt;send&lt;/code&gt; 또는 &lt;code&gt;'receive'&lt;/code&gt; 이 설정된 경우) 추적 메시지를 수신 합니다. 그런 다음 시스템 추적 프로그램은 각 추적 이벤트를 인쇄하거나 파일에 쓰거나 적절한 항목으로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aa1503e3bb1ca6d6b1d5db02a4ead78c2138817" translate="yes" xml:space="preserve">
          <source>On encode, an OctetString() IPv4 address is parsed in the usual x.x.x.x format while an IPv6 address is parsed in any of the formats specified by section 2.2 of RFC 2373, &quot;Text Representation of Addresses&quot;. An IPv4 tuple() has length 4 and contains values of type 0..255. An IPv6 tuple() has length 8 and contains values of type 0..65535. The tuple representation is used on decode.</source>
          <target state="translated">인코딩시 OctetString () IPv4 주소는 일반적인 xxxx 형식으로 구문 분석되는 반면 IPv6 주소는 RFC 2373, &quot;주소의 텍스트 표현&quot;섹션 2.2에 지정된 형식으로 구문 분석됩니다. IPv4 tuple ()은 길이가 4이며 0..255 유형의 값을 포함합니다. IPv6 tuple ()은 길이가 8이며 0..65535 유형의 값을 포함합니다. 튜플 표현은 디코딩에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5d15ad498425526235871ebf68fcb9399fdea277" translate="yes" xml:space="preserve">
          <source>On encode, an OctetString() can be specified as an iolist(), excessively large floats (in absolute value) are equivalent to &lt;code&gt;infinity&lt;/code&gt; or &lt;code&gt;'-infinity'&lt;/code&gt; and excessively large integers result in encode failure. The records for grouped AVPs are as discussed in the previous section.</source>
          <target state="translated">인코딩시 OctetString ()을 iolist ()로 지정할 수 있으며, 너무 큰 부동 소수점 (절대 값)은 &lt;code&gt;infinity&lt;/code&gt; 또는 &lt;code&gt;'-infinity'&lt;/code&gt; 하며 지나치게 큰 정수는 인코딩 실패를 초래합니다. 그룹화 된 AVP에 대한 레코드는 이전 섹션에서 설명한대로입니다.</target>
        </trans-unit>
        <trans-unit id="c7844a2c02e87c5568f9be53b564891e2298588d" translate="yes" xml:space="preserve">
          <source>On encode, fields port, transport and protocol default to 3868, sctp and diameter respectively. The grammar of an OctetString-valued DiameterURI() is as specified in section 4.3 of RFC 6733. The record representation is used on decode.</source>
          <target state="translated">인코딩시 필드 포트, ​​전송 및 프로토콜의 기본값은 각각 3868, sctp 및 직경입니다. OctetString 값의 DiameterURI ()의 문법은 RFC 6733의 섹션 4.3에 지정되어 있습니다. 레코드 표현은 디코드에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d66c2d9ea2e818fe35630d0324d41a67f4905d83" translate="yes" xml:space="preserve">
          <source>On encode, values can be specified using the macros defined in a dictionary's hrl file.</source>
          <target state="translated">인코딩시, 사전의 hrl 파일에 정의 된 매크로를 사용하여 값을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="731614e2c441caf07c5c36a9a260f1d7987a91b7" translate="yes" xml:space="preserve">
          <source>On encountering character #, &lt;code&gt;pcre_compile()&lt;/code&gt; skips along, looking for a newline in the pattern. The sequence \n is still literal at this stage, so it does not terminate the comment. Only a character with code value 0x0a (the default newline) does so.</source>
          <target state="translated">문자 #가 발생하면 &lt;code&gt;pcre_compile()&lt;/code&gt; 건너 뛰면서 패턴에서 줄 바꿈을 찾습니다. 이 단계에서 \ n 시퀀스는 여전히 문자 그대로이므로 주석을 종료하지 않습니다. 코드 값이 0x0a (기본 줄 바꿈) 인 문자 만 그렇게합니다.</target>
        </trans-unit>
        <trans-unit id="6046ea4ed169ee86943dd8f909d8a57065f20fd4" translate="yes" xml:space="preserve">
          <source>On failure, that is, no such environment variable was found, a value &amp;lt; &lt;code&gt;0&lt;/code&gt; is returned. When the size of the &lt;code&gt;value&lt;/code&gt; buffer is too small, a value &amp;gt; &lt;code&gt;0&lt;/code&gt; is returned and &lt;code&gt;*value_size&lt;/code&gt; has been set to the buffer size needed.</source>
          <target state="translated">실패시, 즉 그러한 환경 변수를 찾지 못하면 값 &amp;lt; &lt;code&gt;0&lt;/code&gt; 이 리턴됩니다. &lt;code&gt;value&lt;/code&gt; 버퍼 의 크기 가 너무 작 으면 값&amp;gt; &lt;code&gt;0&lt;/code&gt; 이 리턴되고 &lt;code&gt;*value_size&lt;/code&gt; 가 필요한 버퍼 크기로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="e7d6dfc6c6549f9a2bde9d0b09efa932ae04ee7b" translate="yes" xml:space="preserve">
          <source>On gollum:</source>
          <target state="translated">골룸에서 :</target>
        </trans-unit>
        <trans-unit id="2fb361775fa49f574bf571176cefd50d9c38320a" translate="yes" xml:space="preserve">
          <source>On kosken (on a Linux/UNIX system):</source>
          <target state="translated">kosken (Linux / UNIX 시스템)에서 :</target>
        </trans-unit>
        <trans-unit id="254bbc8618baf4df2c0d1ded28631159588b541c" translate="yes" xml:space="preserve">
          <source>On line 1-10 the OS headers needed for the driver are included. As this driver is written for Solaris, we know that the header &lt;code&gt;uio.h&lt;/code&gt; exists. So the preprocessor variable &lt;code&gt;HAVE_UIO_H&lt;/code&gt; can be defined before &lt;code&gt;erl_driver.h&lt;/code&gt; is included on line 12. The definition of &lt;code&gt;HAVE_UIO_H&lt;/code&gt; will make the I/O vectors used in Erlang's driver queues to correspond to the operating systems ditto, which is very convenient.</source>
          <target state="translated">1-10 행에는 드라이버에 필요한 OS 헤더가 포함되어 있습니다. 이 드라이버는 Solaris 용으로 작성 &lt;code&gt;uio.h&lt;/code&gt; 헤더 가 존재 한다는 것을 알고 있습니다. 따라서 &lt;code&gt;erl_driver.h&lt;/code&gt; 가 12 행에 포함 되기 전에 전 처리기 변수 &lt;code&gt;HAVE_UIO_H&lt;/code&gt; 를 정의 할 수 있습니다 . &lt;code&gt;HAVE_UIO_H&lt;/code&gt; 의 정의는 Erlang의 드라이버 대기열에 사용 된 I / O 벡터가 운영 체제 ditto에 해당하도록 만들므로 매우 편리합니다.</target>
        </trans-unit>
        <trans-unit id="233d0459679e240e1a43d6003a0eed16b1b6db16" translate="yes" xml:space="preserve">
          <source>On line 16-23 the different callback functions are declared (&quot;forward declarations&quot;).</source>
          <target state="translated">16-23 행에서 다른 콜백 함수가 선언됩니다 ( &quot;전달 선언&quot;).</target>
        </trans-unit>
        <trans-unit id="1829525dba56c919f35e7fe241f7a7f27d37779d" translate="yes" xml:space="preserve">
          <source>On line 4-8 is handled the case where the port is in &lt;code&gt;data&lt;/code&gt; mode or &lt;code&gt;intermediate&lt;/code&gt; mode and the remaining routine handles the different commands. The routine uses the &lt;code&gt;driver_failure_posix()&lt;/code&gt; routine to report errors (see, for example, line 15). Notice that the failure routines make a call to the &lt;code&gt;uds_stop&lt;/code&gt; routine, which will remove the internal port data. The handle (and the casted handle &lt;code&gt;ud&lt;/code&gt;) is therefore &lt;strong&gt;invalid pointers&lt;/strong&gt; after a &lt;code&gt;driver_failure&lt;/code&gt; call and we should &lt;strong&gt;return immediately&lt;/strong&gt;. The runtime system will send exit signals to all linked processes.</source>
          <target state="translated">라인 4-8은 포트가 &lt;code&gt;data&lt;/code&gt; 모드 또는 &lt;code&gt;intermediate&lt;/code&gt; 모드에 있고 나머지 루틴이 다른 명령을 처리하는 경우에 처리됩니다. 이 루틴은 &lt;code&gt;driver_failure_posix()&lt;/code&gt; 루틴을 사용하여 오류를보고합니다 (예 : 15 행 참조). 실패 루틴은 &lt;code&gt;uds_stop&lt;/code&gt; 루틴을 호출 하여 내부 포트 데이터를 제거합니다. 따라서 handle (및 casted handle &lt;code&gt;ud&lt;/code&gt; )은 &lt;code&gt;driver_failure&lt;/code&gt; 호출 후 &lt;strong&gt;유효하지 않은 포인터&lt;/strong&gt; 이므로 &lt;strong&gt;즉시 리턴&lt;/strong&gt; 해야 &lt;strong&gt;합니다&lt;/strong&gt; . 런타임 시스템은 모든 연결된 프로세스에 종료 신호를 보냅니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0784da7963dd222dfcf8b747a5d57b72650b03dc" translate="yes" xml:space="preserve">
          <source>On linux the memory available to the emulator is &lt;code&gt;cached_memory&lt;/code&gt; and &lt;code&gt;buffered_memory&lt;/code&gt; in addition to &lt;code&gt;free_memory&lt;/code&gt;.</source>
          <target state="translated">리눅스에 에뮬레이터에서 사용할 수있는 메모리입니다 &lt;code&gt;cached_memory&lt;/code&gt; 및 &lt;code&gt;buffered_memory&lt;/code&gt; 에 추가 &lt;code&gt;free_memory&lt;/code&gt; 은 .</target>
        </trans-unit>
        <trans-unit id="9d908b49426b880b5a485931417759cde36bd6fa" translate="yes" xml:space="preserve">
          <source>On many platforms, the OS supports only status codes 0-255. A too large status code is truncated by clearing the high bits.</source>
          <target state="translated">많은 플랫폼에서 OS는 상태 코드 0-255 만 지원합니다. 높은 비트를 지우면 너무 큰 상태 코드가 잘립니다.</target>
        </trans-unit>
        <trans-unit id="01e5aeaef327e8644ba3de200b1361c56477bc67" translate="yes" xml:space="preserve">
          <source>On module (&lt;code&gt;mod&lt;/code&gt;) level, the following options are supported:</source>
          <target state="translated">모듈 ( &lt;code&gt;mod&lt;/code&gt; ) 레벨에서는 다음 옵션이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="625fa204254a0a02e9def2bcc01ac2eefa5a78a4" translate="yes" xml:space="preserve">
          <source>On most platforms this option must be set on the socket before associating it to an address. It is therefore only reasonable to specify it when creating the socket and not to use it when calling function (&lt;code&gt;&lt;a href=&quot;#setopts-2&quot;&gt;setopts/2&lt;/a&gt;&lt;/code&gt;) containing this description.</source>
          <target state="translated">대부분의 플랫폼에서이 옵션은 소켓을 주소에 연결하기 전에 소켓에서 설정해야합니다. 따라서 소켓을 작성할 때 소켓을 지정 하고이 설명이 포함 된 함수 ( &lt;code&gt;&lt;a href=&quot;#setopts-2&quot;&gt;setopts/2&lt;/a&gt;&lt;/code&gt; )를 호출 할 때는 소켓을 지정하지 않는 것이 합리적 입니다.</target>
        </trans-unit>
        <trans-unit id="83547004e7613d3d63f0a97fcec4dde6aca4cb59" translate="yes" xml:space="preserve">
          <source>On one of the two nodes:</source>
          <target state="translated">두 노드 중 하나에서 :</target>
        </trans-unit>
        <trans-unit id="cc0bc87e9803dd29ab16d01f2771141460043748" translate="yes" xml:space="preserve">
          <source>On operating systems with mandatory Unicode filenames, this means that you more easily conform to the filenames of other (non-Erlang) applications. You can also process filenames that, at least on Windows, were inaccessible (because of having names that could not be represented in ISO Latin-1). Also, you avoid creating incomprehensible filenames on MacOS X, as the &lt;code&gt;vfs&lt;/code&gt; layer of the operating system accepts all your filenames as UTF-8 does not rewrite them.</source>
          <target state="translated">필수 유니 코드 파일 이름이있는 운영 체제에서 이는 다른 (비 Erlang) 응용 프로그램의 파일 이름을보다 쉽게 ​​준수 함을 의미합니다. ISO 라틴어 1로 표현할 수없는 이름이 있기 때문에 적어도 Windows에서는 액세스 할 수없는 파일 이름을 처리 할 수도 있습니다. 또한 운영 체제 의 &lt;code&gt;vfs&lt;/code&gt; 계층은 UTF-8이 파일 이름을 다시 쓰지 않으므로 모든 파일 이름을 허용 하므로 MacOS X에서 이해할 수없는 파일 이름을 작성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c01b078903bea1781dc2ed9488460d3b352c3b71" translate="yes" xml:space="preserve">
          <source>On operating systems with transparent naming (for example, all Unix systems except MacOS X), default is &lt;code&gt;utf8&lt;/code&gt; if the terminal supports UTF-8, otherwise &lt;code&gt;latin1&lt;/code&gt;. The default can be overridden using &lt;code&gt;+fnl&lt;/code&gt; (to force &lt;code&gt;latin1&lt;/code&gt; mode) or &lt;code&gt;+fnu&lt;/code&gt; (to force &lt;code&gt;utf8&lt;/code&gt; mode) when starting &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">투명한 이름을 가진 운영 체제 (예 : MacOS X를 제외한 모든 Unix 시스템) 에서 터미널이 UTF-8을 지원하면 기본값은 &lt;code&gt;utf8&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;latin1&lt;/code&gt; 입니다. 기본값은 사용 오버라이드 (override) 할 수 있습니다 &lt;code&gt;+fnl&lt;/code&gt; (강제 &lt;code&gt;latin1&lt;/code&gt; 모드) 또는 &lt;code&gt;+fnu&lt;/code&gt; (힘에 &lt;code&gt;utf8&lt;/code&gt; 시작시 모드) &lt;code&gt;erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bd025a43addf4cf8a811c722598b09ff48bc9cb" translate="yes" xml:space="preserve">
          <source>On operating systems with transparent naming, files can be inconsistently named, for example, some files are encoded in UTF-8 while others are encoded in ISO Latin-1. The concept of &lt;strong&gt;raw filenames&lt;/strong&gt; is introduced to handle file systems with inconsistent naming when running in &lt;code&gt;utf8&lt;/code&gt; mode.</source>
          <target state="translated">투명한 이름을 가진 운영 체제에서 파일 이름이 일치하지 않을 수 있습니다. 예를 들어 일부 파일은 UTF-8로 인코딩되고 다른 파일은 ISO Latin-1로 인코딩됩니다. &lt;strong&gt;원시 파일 이름&lt;/strong&gt; 의 개념은 &lt;code&gt;utf8&lt;/code&gt; 모드 에서 실행할 때 이름이 일치하지 않는 파일 시스템을 처리하기 위해 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e0eed5fde65bb7a382758dcc51496a31ac264639" translate="yes" xml:space="preserve">
          <source>On other supported systems, see &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Configuring&quot;&gt;Advanced Configure&lt;/a&gt;&lt;/code&gt; on how to enable HiPE.</source>
          <target state="translated">지원되는 다른 시스템에서는 HiPE를 활성화하는 방법에 대한 &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Configuring&quot;&gt;Advanced Configure&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="553a2be33582dd908d9294011101091577e2f096" translate="yes" xml:space="preserve">
          <source>On platforms supporting it, enables the POSIX &lt;code&gt;O_SYNC&lt;/code&gt; synchronous I/O flag or its platform-dependent equivalent (for example, &lt;code&gt;FILE_FLAG_WRITE_THROUGH&lt;/code&gt; on Windows) so that writes to the file block until the data is physically written to disk. However, be aware that the exact semantics of this flag differ from platform to platform. For example, none of Linux or Windows guarantees that all file metadata are also written before the call returns. For precise semantics, check the details of your platform documentation. On platforms with no support for POSIX &lt;code&gt;O_SYNC&lt;/code&gt; or equivalent, use of the &lt;code&gt;sync&lt;/code&gt; flag causes &lt;code&gt;open&lt;/code&gt; to return &lt;code&gt;{error, enotsup}&lt;/code&gt;.</source>
          <target state="translated">이를 지원하는 플랫폼에서 POSIX &lt;code&gt;O_SYNC&lt;/code&gt; 동기 I / O 플래그 또는 이와 동등한 플랫폼 종속 (예 : Windows의 &lt;code&gt;FILE_FLAG_WRITE_THROUGH&lt;/code&gt; )을 활성화하여 데이터가 실제로 디스크에 기록 될 때까지 파일 블록에 기록합니다. 그러나이 플래그의 정확한 의미는 플랫폼마다 다릅니다. 예를 들어, Linux 또는 Windows는 호출이 리턴되기 전에 모든 파일 메타 데이터도 기록되도록 보장하지 않습니다. 정확한 의미를 위해서는 플랫폼 설명서의 세부 정보를 확인하십시오. POSIX &lt;code&gt;O_SYNC&lt;/code&gt; 또는 이와 동등한 기능을 지원하지 않는 플랫폼 에서 &lt;code&gt;sync&lt;/code&gt; 플래그를 사용하면 &lt;code&gt;open&lt;/code&gt; 이 &lt;code&gt;{error, enotsup}&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="d150b84d58ca2e7d5f356e3aff31a3d84da95bdf" translate="yes" xml:space="preserve">
          <source>On some operating systems &lt;strong&gt;syslog&lt;/strong&gt; will be used for error reporting when &lt;code&gt;epmd&lt;/code&gt; runs as a daemon. To enable the error logging, you must edit the /etc/syslog.conf file and add an entry:</source>
          <target state="translated">일부 운영 체제에서는 &lt;code&gt;epmd&lt;/code&gt; 가 데몬으로 실행될 때 &lt;strong&gt;syslog&lt;/strong&gt; 가 오류보고에 사용 됩니다. 오류 로깅을 활성화하려면 /etc/syslog.conf 파일을 편집하고 항목을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="47544928855d61173caf643cd7bfa90a251b1e29" translate="yes" xml:space="preserve">
          <source>On some platforms Perl may behave strangely if certain locales are set. If you get errors when building, try setting the LANG variable:</source>
          <target state="translated">일부 플랫폼에서 특정 로케일이 설정되면 Perl이 이상하게 작동 할 수 있습니다. 빌드 할 때 오류가 발생하면 LANG 변수를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="4a78afab7d6e8dd2e7a981b5139d692992694b9a" translate="yes" xml:space="preserve">
          <source>On some platforms, the only allowed value for this option is &lt;code&gt;true&lt;/code&gt;, for example, OpenBSD and Windows. Trying to set this option to &lt;code&gt;false&lt;/code&gt;, when creating the socket, fails in this case.</source>
          <target state="translated">일부 플랫폼에서이 옵션에 허용되는 유일한 값은 &lt;code&gt;true&lt;/code&gt; 입니다 (예 : OpenBSD 및 Windows). 이 경우 소켓을 만들 때이 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정하려고 하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="36908e6d72c2b03311eb938d2432a12b5ab335ef" translate="yes" xml:space="preserve">
          <source>On some platforms, this function might have no effect.</source>
          <target state="translated">일부 플랫폼에서는이 기능이 적용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e64396927ca10116aa5e806980b90b12fcdc017" translate="yes" xml:space="preserve">
          <source>On some systems it can be necessary to link with some more libraries (for example, &lt;code&gt;libnsl.a&lt;/code&gt; and &lt;code&gt;libsocket.a&lt;/code&gt; on Solaris, or &lt;code&gt;wsock32.lib&lt;/code&gt; on Windows) to use the communication facilities of &lt;code&gt;Erl_Interface&lt;/code&gt;.</source>
          <target state="translated">일부 시스템에서는 &lt;code&gt;libnsl.a&lt;/code&gt; 의 통신 기능을 사용하기 위해 더 많은 라이브러리 (예 : Solaris의 libnsl.a 및 &lt;code&gt;libsocket.a&lt;/code&gt; 또는 Windows의 &lt;code&gt;wsock32.lib&lt;/code&gt; )와 &lt;code&gt;Erl_Interface&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="bb868b4886e090c126e2950aab6d84ed7dcb16dc" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;0&lt;/code&gt; is returned and &lt;code&gt;obuf&lt;/code&gt; is initialized to contain table statistics, otherwise &lt;code&gt;-1&lt;/code&gt; is returned.</source>
          <target state="translated">성공하면 &lt;code&gt;0&lt;/code&gt; 이 리턴되고 &lt;code&gt;obuf&lt;/code&gt; 는 테이블 통계를 포함하도록 초기화되고, 그렇지 않으면 &lt;code&gt;-1&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b55c599082e06de776c0bd626fd828b706a34179" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;0&lt;/code&gt; is returned, the value of the environment variable has been written to the &lt;code&gt;value&lt;/code&gt; buffer, and &lt;code&gt;*value_size&lt;/code&gt; contains the string length (excluding the terminating &lt;code&gt;NULL&lt;/code&gt; character) of the value written to the &lt;code&gt;value&lt;/code&gt; buffer.</source>
          <target state="translated">성공시, &lt;code&gt;0&lt;/code&gt; 은 환경 변수의 값이 기록 된, 리턴 &lt;code&gt;value&lt;/code&gt; 버퍼 및 &lt;code&gt;*value_size&lt;/code&gt; 은 (종단을 제외한 문자열 길이를 포함 &lt;code&gt;NULL&lt;/code&gt; 을 받는 기록 된 값의 특성) &lt;code&gt;value&lt;/code&gt; 버퍼.</target>
        </trans-unit>
        <trans-unit id="eddebcdb76f9fab8ab2298752db267fa58432d28" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;conp&lt;/code&gt; is filled in with the address and node name of the connecting client and a file descriptor is returned. On failure, &lt;code&gt;ERL_ERROR&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">성공하면 &lt;code&gt;conp&lt;/code&gt; 가 연결 클라이언트의 주소와 노드 이름으로 채워지고 파일 설명자가 반환됩니다. 실패하면 &lt;code&gt;ERL_ERROR&lt;/code&gt; 가 리턴되고 &lt;code&gt;erl_errno&lt;/code&gt; 가 &lt;code&gt;EIO&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0bc86d5b291cc284bbc0ca0e72d47d0adc2e32d6" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;v&lt;/code&gt; (and &lt;code&gt;size&lt;/code&gt; if the object is binary) is initialized with the value associated with &lt;code&gt;key&lt;/code&gt;, and the function returns &lt;code&gt;EI_INT&lt;/code&gt;, &lt;code&gt;EI_FLT&lt;/code&gt;, &lt;code&gt;EI_STR&lt;/code&gt;, or &lt;code&gt;EI_BIN&lt;/code&gt;, indicating the type of object. On failure, &lt;code&gt;-1&lt;/code&gt; is returned and the arguments are not updated.</source>
          <target state="translated">성공하면 &lt;code&gt;v&lt;/code&gt; (및 오브젝트가 이진 인 경우 &lt;code&gt;size&lt;/code&gt; )가 &lt;code&gt;key&lt;/code&gt; 와 연관된 값으로 초기화되고 함수는 오브젝트 유형을 나타내는 &lt;code&gt;EI_INT&lt;/code&gt; , &lt;code&gt;EI_FLT&lt;/code&gt; , &lt;code&gt;EI_STR&lt;/code&gt; 또는 &lt;code&gt;EI_BIN&lt;/code&gt; 을 리턴 합니다. 실패하면 &lt;code&gt;-1&lt;/code&gt; 이 리턴되고 인수는 갱신되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="969e908d49a7fbc3a7e280f38ab4f55f6067faf3" translate="yes" xml:space="preserve">
          <source>On success, a descriptor connecting the calling process to EPMD is returned. On failure, &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to:</source>
          <target state="translated">성공하면 호출 프로세스를 EPMD에 연결하는 설명자가 반환됩니다. 실패하면 &lt;code&gt;-1&lt;/code&gt; 이 리턴되고 &lt;code&gt;erl_errno&lt;/code&gt; 가 다음으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2aec08e035ff2227fedf237e8aaf81890b198c99" translate="yes" xml:space="preserve">
          <source>On success, sets &lt;code&gt;*key&lt;/code&gt; and &lt;code&gt;*value&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; if the iterator is positioned at head (before first entry) or tail (beyond last entry).</source>
          <target state="translated">성공하면 &lt;code&gt;*key&lt;/code&gt; 및 &lt;code&gt;*value&lt;/code&gt; 를 설정 하고 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 반복자가 head (첫 번째 항목 이전) 또는 tail (마지막 항목 이외)에 위치한 경우 &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="7ef0a43f7b72b72b522ca36cd55aa1e746822b9f" translate="yes" xml:space="preserve">
          <source>On success, sets &lt;code&gt;*pid&lt;/code&gt; to the local process registered with &lt;code&gt;name&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;name&lt;/code&gt; is not a registered process, or is not an atom, &lt;code&gt;false&lt;/code&gt; is returned and &lt;code&gt;*pid&lt;/code&gt; is unchanged.</source>
          <target state="translated">성공하면 &lt;code&gt;*pid&lt;/code&gt; 를 &lt;code&gt;name&lt;/code&gt; 으로 등록 된 로컬 프로세스로 설정 하고 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 경우 &lt;code&gt;name&lt;/code&gt; 등록 프로세스 없거나 원자 아니다 &lt;code&gt;false&lt;/code&gt; 리턴되고 &lt;code&gt;*pid&lt;/code&gt; 변하지 않는다.</target>
        </trans-unit>
        <trans-unit id="073e4acf139e5d3ba364bb27e432c64851509f50" translate="yes" xml:space="preserve">
          <source>On success, sets &lt;code&gt;*port&lt;/code&gt; to the port registered with &lt;code&gt;name&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;name&lt;/code&gt; is not a registered port, or is not an atom, &lt;code&gt;false&lt;/code&gt; is returned and &lt;code&gt;*port&lt;/code&gt; is unchanged.</source>
          <target state="translated">성공하면 &lt;code&gt;*port&lt;/code&gt; 를 &lt;code&gt;name&lt;/code&gt; 으로 등록 된 포트 로 설정 하고 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 경우 &lt;code&gt;name&lt;/code&gt; 등록 포트 없거나 원자 아니다 &lt;code&gt;false&lt;/code&gt; 리턴되고 &lt;code&gt;*port&lt;/code&gt; 변하지 않는다.</target>
        </trans-unit>
        <trans-unit id="939344767976749cae972a1349799f2c2eaf12ef" translate="yes" xml:space="preserve">
          <source>On success, stores the resulting term at &lt;code&gt;*term&lt;/code&gt; and returns the number of bytes read. Returns &lt;code&gt;0&lt;/code&gt; if decoding fails or if &lt;code&gt;opts&lt;/code&gt; is invalid.</source>
          <target state="translated">성공하면 결과 용어를 &lt;code&gt;*term&lt;/code&gt; 에 저장하고 읽은 바이트 수를 리턴합니다. 디코딩이 실패하거나 &lt;code&gt;opts&lt;/code&gt; 가 유효하지 않은 경우 &lt;code&gt;0&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="c4c049046abd946d86db876a1e3d6ab44c243545" translate="yes" xml:space="preserve">
          <source>On success, the function returns &lt;code&gt;ERL_MSG&lt;/code&gt; and the &lt;code&gt;Emsg&lt;/code&gt; struct is initialized as described above, or &lt;code&gt;ERL_TICK&lt;/code&gt;, in which case no message is returned. On failure, the function returns &lt;code&gt;ERL_ERROR&lt;/code&gt; and sets &lt;code&gt;erl_errno&lt;/code&gt; to one of:</source>
          <target state="translated">성공하면 함수는 &lt;code&gt;ERL_MSG&lt;/code&gt; 를 리턴 하고 &lt;code&gt;Emsg&lt;/code&gt; 구조체는 위에서 설명한대로 초기화되거나 &lt;code&gt;ERL_TICK&lt;/code&gt; 이며이 경우 메시지가 리턴되지 않습니다. 실패하면 함수는 &lt;code&gt;ERL_ERROR&lt;/code&gt; 를 리턴 하고 &lt;code&gt;erl_errno&lt;/code&gt; 를 다음 중 하나로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="629b14be4c544ff9f65dc57b340e61cbbb39aafa" translate="yes" xml:space="preserve">
          <source>On success, the function returns &lt;code&gt;ok&lt;/code&gt;. On failure, the function returns an opaque error, except the &lt;code&gt;pending_process&lt;/code&gt; error described earlier. The opaque errors are to be translated into human readable form by function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;ok&lt;/code&gt; 를 반환합니다 . 실패시 함수는 앞에서 설명한 &lt;code&gt;pending_process&lt;/code&gt; 오류를 제외하고 불투명 한 오류를 반환합니다 . 불투명 한 오류는 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 함수에 의해 사람이 읽을 수있는 형태로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5f40438c31e5fae2d92b0ab21e0ba8037f1d866" translate="yes" xml:space="preserve">
          <source>On success, the function returns &lt;code&gt;ok&lt;/code&gt;. On failure, the return value is &lt;code&gt;{error,ErrorDesc}&lt;/code&gt;, where &lt;code&gt;ErrorDesc&lt;/code&gt; is an opaque term to be translated into human readable form by function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;ok&lt;/code&gt; 를 반환합니다 . 실패한 경우 리턴 값은 &lt;code&gt;{error,ErrorDesc}&lt;/code&gt; 이며 여기서 &lt;code&gt;ErrorDesc&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 함수에 의해 사람이 읽을 수있는 형식으로 변환되는 불투명 한 용어 입니다.</target>
        </trans-unit>
        <trans-unit id="9434e82ca19ea4e7015799cf03a1286d4e4d6516" translate="yes" xml:space="preserve">
          <source>On success, the function returns a descriptor connecting the calling process to EPMD. On failure, &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">성공하면이 함수는 호출 프로세스를 EPMD에 연결하는 설명자를 반환합니다. 실패하면 &lt;code&gt;-1&lt;/code&gt; 이 리턴되고 &lt;code&gt;erl_errno&lt;/code&gt; 가 &lt;code&gt;EIO&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="a4a5876f3c7f9a8dde05d398be614c4d3bae58d6" translate="yes" xml:space="preserve">
          <source>On success, the function returns a pointer to the resource type and &lt;code&gt;*tried&lt;/code&gt; is set to either &lt;code&gt;ERL_NIF_RT_CREATE&lt;/code&gt; or &lt;code&gt;ERL_NIF_RT_TAKEOVER&lt;/code&gt; to indicate what was done. On failure, returns &lt;code&gt;NULL&lt;/code&gt; and sets &lt;code&gt;*tried&lt;/code&gt; to &lt;code&gt;flags&lt;/code&gt;. It is allowed to set &lt;code&gt;tried&lt;/code&gt; to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">성공하면 함수는 자원 유형에 대한 포인터를 리턴하고 &lt;code&gt;*tried&lt;/code&gt; 는 수행 된 작업을 표시하기 위해 &lt;code&gt;ERL_NIF_RT_CREATE&lt;/code&gt; 또는 &lt;code&gt;ERL_NIF_RT_TAKEOVER&lt;/code&gt; 로 설정 됩니다. 실패하면 &lt;code&gt;NULL&lt;/code&gt; 을 리턴 하고 &lt;code&gt;*tried&lt;/code&gt; 를 &lt;code&gt;flags&lt;/code&gt; 로 설정 합니다 . &lt;code&gt;tried&lt;/code&gt; 를 &lt;code&gt;NULL&lt;/code&gt; 로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fed20a53218971de1395aaff5c9c60036d53fb8" translate="yes" xml:space="preserve">
          <source>On success, the function returns an Erlang pid containing the address of the specified name, and the node is initialized to the node name where &lt;code&gt;name&lt;/code&gt; is found. On failure, &lt;code&gt;NULL&lt;/code&gt; is returned and &lt;code&gt;node&lt;/code&gt; is not modified.</source>
          <target state="translated">성공하면 함수는 지정된 이름의 주소를 포함하는 Erlang pid를 리턴하고 노드는 &lt;code&gt;name&lt;/code&gt; 이 있는 노드 이름으로 초기화 됩니다. 실패하면 &lt;code&gt;NULL&lt;/code&gt; 이 리턴되고 &lt;code&gt;node&lt;/code&gt; 가 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="337efc03ad89d708d3afb77816250b7b6e5ac95d" translate="yes" xml:space="preserve">
          <source>On success, the function returns an array of strings, each containing a single registered name, and sets &lt;code&gt;count&lt;/code&gt; to the number of names found. The array is terminated by a single &lt;code&gt;NULL&lt;/code&gt; pointer. On failure, the function returns &lt;code&gt;NULL&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; is not modified.</source>
          <target state="translated">성공하면이 함수는 각각 등록 된 단일 이름을 포함하는 문자열 배열을 반환하고 &lt;code&gt;count&lt;/code&gt; 를 찾은 이름 수로 설정합니다 . 배열은 단일 &lt;code&gt;NULL&lt;/code&gt; 포인터로 종료됩니다 . 실패하면 함수는 &lt;code&gt;NULL&lt;/code&gt; 을 리턴 하고 &lt;code&gt;count&lt;/code&gt; 는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4272e6f5e6ca873a7a08ed89c16a8a80ef49afd" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt; and indicates its length in &lt;code&gt;size&lt;/code&gt;. If the object is not found or if it is not a binary object, &lt;code&gt;NULL&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;NULL&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;key&lt;/code&gt; 와 관련된 값을 반환 하고 길이를 &lt;code&gt;size&lt;/code&gt; 로 나타냅니다 . 오브젝트가 없거나 2 진 오브젝트가 아닌 경우 &lt;code&gt;NULL&lt;/code&gt; 이 리턴됩니다. 대역 내 오류보고와 관련된 문제를 방지하려면 (즉, &lt;code&gt;NULL&lt;/code&gt; 과 유효한 결과를 구분할 수없는 경우)보다 일반적인 함수 &lt;code&gt;ei_reg_getval()&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="05d5be1ae587938fb787490f4e22f1def9a340ce" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt;. If the object is not found or if it is not a floating point object, &lt;code&gt;-1.0&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;-1.0&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;key&lt;/code&gt; 와 관련된 값을 반환합니다 . 객체가 없거나 부동 소수점 객체가 아닌 경우 &lt;code&gt;-1.0&lt;/code&gt; 이 반환됩니다. 대역 내 오류보고와 관련된 문제를 피하려면 (즉, &lt;code&gt;-1.0&lt;/code&gt; 과 유효한 결과를 구별 할 수없는 경우)보다 일반적인 함수 &lt;code&gt;ei_reg_getval()&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b3820a5ea0fe718970e9f3bbe04885da2999ec49" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt;. If the object is not found or if it is not a string, &lt;code&gt;NULL&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;NULL&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;key&lt;/code&gt; 와 관련된 값을 반환합니다 . 오브젝트가 없거나 문자열이 아닌 경우 &lt;code&gt;NULL&lt;/code&gt; 이 리턴됩니다. 대역 내 오류보고와 관련된 문제를 방지하려면 (즉, &lt;code&gt;NULL&lt;/code&gt; 과 유효한 결과를 구분할 수없는 경우)보다 일반적인 함수 &lt;code&gt;ei_reg_getval()&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f63666e52d190298b2a061e3c8a1ed17bebbd73f" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt;. If the object is not found or if it is not an integer object, &lt;code&gt;-1&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;-1&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;key&lt;/code&gt; 와 관련된 값을 반환합니다 . 오브젝트가 없거나 정수 오브젝트가 아닌 경우 &lt;code&gt;-1&lt;/code&gt; 이 리턴됩니다. 대역 내 오류보고 (즉, &lt;code&gt;-1&lt;/code&gt; 과 유효한 결과를 구별 할 수없는 경우)와 관련된 문제를 피하려면 보다 일반적인 함수 &lt;code&gt;ei_reg_getval()&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="826f3f3c68edb8d6a8417ffe459589634fbc1144" translate="yes" xml:space="preserve">
          <source>On success, the functions return &lt;code&gt;ERL_MSG&lt;/code&gt; and the &lt;code&gt;msg&lt;/code&gt; struct is initialized. &lt;code&gt;erlang_msg&lt;/code&gt; is defined as follows:</source>
          <target state="translated">성공하면 함수는 &lt;code&gt;ERL_MSG&lt;/code&gt; 를 반환 하고 &lt;code&gt;msg&lt;/code&gt; 구조체가 초기화됩니다. &lt;code&gt;erlang_msg&lt;/code&gt; 는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="2e36d3c841193235e57c861682cf6d25481358db" translate="yes" xml:space="preserve">
          <source>On success, the message is placed in the specified buffer and the function returns the number of bytes actually read. On failure, the function returns &lt;code&gt;ERL_ERROR&lt;/code&gt; and sets &lt;code&gt;erl_errno&lt;/code&gt; to one of the following:</source>
          <target state="translated">성공하면 메시지가 지정된 버퍼에 배치되고 함수는 실제로 읽은 바이트 수를 리턴합니다. 실패하면 함수는 &lt;code&gt;ERL_ERROR&lt;/code&gt; 를 리턴 하고 &lt;code&gt;erl_errno&lt;/code&gt; 를 다음 중 하나로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="5b25bb3efb4ee6e26cac0f259c10a630574681e4" translate="yes" xml:space="preserve">
          <source>On success, the message is placed in the specified buffer and the function returns the number of bytes actually read. On failure, the function returns a negative value and sets &lt;code&gt;erl_errno&lt;/code&gt; to one of:</source>
          <target state="translated">성공하면 메시지가 지정된 버퍼에 배치되고 함수는 실제로 읽은 바이트 수를 리턴합니다. 실패하면 함수는 음수 값을 리턴하고 &lt;code&gt;erl_errno&lt;/code&gt; 를 다음 중 하나로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="772f9d0d6c197237442ca0a6e490f7b7f2ebb396" translate="yes" xml:space="preserve">
          <source>On success, the registry is resized, all contents rehashed, and &lt;code&gt;0&lt;/code&gt; is returned. On failure, the registry is left unchanged and &lt;code&gt;-1&lt;/code&gt; is returned.</source>
          <target state="translated">성공하면 레지스트리 크기가 조정되고 모든 내용 이 다시 해시되고 &lt;code&gt;0&lt;/code&gt; 이 반환됩니다. 실패하면 레지스트리가 변경되지 않고 &lt;code&gt;-1&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b55ff64c65276715f5cf5ac620e52f2b4c69380a" translate="yes" xml:space="preserve">
          <source>On systems that support OS signals, it is also possible to stop the runtime system and generate a crash dump by sending the &lt;code&gt;SIGUSR1&lt;/code&gt; signal.</source>
          <target state="translated">OS 신호를 지원하는 시스템에서는 &lt;code&gt;SIGUSR1&lt;/code&gt; 신호 를 전송하여 런타임 시스템을 중지하고 크래시 덤프를 생성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8295dab59d105fcadee920c83d7a0087818d1ff8" translate="yes" xml:space="preserve">
          <source>On tab &lt;strong&gt;Internal Tables&lt;/strong&gt; you can from the left-hand menu select &lt;strong&gt;Hash Tables&lt;/strong&gt;, &lt;strong&gt;Index Tables&lt;/strong&gt;, or &lt;strong&gt;Internal ETS Tables&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;내부 테이블&lt;/strong&gt; 탭 에서 왼쪽 메뉴에서 &lt;strong&gt;해시 테이블&lt;/strong&gt; , &lt;strong&gt;인덱스 테이블&lt;/strong&gt; 또는 &lt;strong&gt;내부 ETS 테이블을&lt;/strong&gt; 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2fcf0646802d9dc8e8b2dc7ce9d29177a614ac1" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;Code&lt;/code&gt; page the Erlang source code is displayed. It is possible to search forwards and backwards for text in the module. Enter a regular expression in the &lt;code&gt;Find&lt;/code&gt; field and press enter. It is also possible to go to a certain line in the module. The &lt;code&gt;Back&lt;/code&gt; button can be used to go back to the previous position.</source>
          <target state="translated">온 &lt;code&gt;Code&lt;/code&gt; 페이지 얼랑 소스 코드가 표시됩니다. 모듈에서 텍스트를 앞뒤로 검색 할 수 있습니다. &lt;code&gt;Find&lt;/code&gt; 필드에 정규식을 입력하고 Enter를 누르십시오. 모듈의 특정 줄로 이동할 수도 있습니다. &lt;code&gt;Back&lt;/code&gt; 버튼은 이전 위치로 돌아 가야하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f72d7009505c0a635de5a33f1a164f62ac37178" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;erl&lt;/code&gt; command line you can specify options that the SSL/TLS distribution adds when creating a socket.</source>
          <target state="translated">온 &lt;code&gt;erl&lt;/code&gt; 소켓을 만들 때 SSL / TLS 분포를 추가하는 명령 줄 당신은 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58dd19bfb0b41f363c09999a6e4ad4b9c8bdfec9" translate="yes" xml:space="preserve">
          <source>On the C side, it is necessary to write functions for receiving and sending data with 2 byte length indicators from/to Erlang. By default, the C program is to read from standard input (file descriptor 0) and write to standard output (file descriptor 1). Examples of such functions, &lt;code&gt;read_cmd/1&lt;/code&gt; and &lt;code&gt;write_cmd/2&lt;/code&gt;, follows:</source>
          <target state="translated">C 측에서는 Erlang과 2 바이트 길이 표시기가있는 데이터를 송수신하기위한 기능을 작성해야합니다. 기본적으로 C 프로그램은 표준 입력 (파일 설명자 0)에서 읽고 표준 출력 (파일 설명자 1)에 씁니다. 이러한 함수의 예는 &lt;code&gt;read_cmd/1&lt;/code&gt; 및 &lt;code&gt;write_cmd/2&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="b62b54f6f16d351431e8df23105f4a3d3614069f" translate="yes" xml:space="preserve">
          <source>On the client side, function &lt;code&gt;&lt;a href=&quot;tftp#read_file-3&quot;&gt;read_file/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;tftp#write_file-3&quot;&gt;write_file/3&lt;/a&gt;&lt;/code&gt; spawn a temporary client process establishing contact with a TFTP daemon and perform the file transfer.</source>
          <target state="translated">클라이언트 측에서 &lt;code&gt;&lt;a href=&quot;tftp#read_file-3&quot;&gt;read_file/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;tftp#write_file-3&quot;&gt;write_file/3&lt;/a&gt;&lt;/code&gt; 함수 는 TFTP 데몬과의 연결을 설정하는 임시 클라이언트 프로세스를 생성하고 파일 전송을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="de8d284e24c9173448479649ca3673e3b9453805" translate="yes" xml:space="preserve">
          <source>On the client side, the callback interaction is the same, but it starts and ends a bit differently. It starts with a call to &lt;code&gt;prepare/5&lt;/code&gt; with the same arguments as &lt;code&gt;open/5&lt;/code&gt; takes. &lt;code&gt;prepare/5&lt;/code&gt; is expected to validate the TFTP options suggested by the user and to return the subset of them that it accepts. Then the options are sent to the server, which performs the same TFTP option negotiation procedure. The options that are accepted by the server are forwarded to function &lt;code&gt;open/5&lt;/code&gt; on the client side. On the client side, function &lt;code&gt;open/5&lt;/code&gt; must accept all option as-is or reject the transfer. Then the callback interaction follows the same pattern as described for the server side. When the last block is encountered in &lt;code&gt;read/1&lt;/code&gt; or &lt;code&gt;write/2&lt;/code&gt;, the returned state is forwarded to the user and returned from &lt;code&gt;read_file&lt;/code&gt;/3 or &lt;code&gt;write_file/3&lt;/code&gt;.</source>
          <target state="translated">클라이언트 쪽에서는 콜백 상호 작용이 동일하지만 약간 다르게 시작하고 끝납니다. &lt;code&gt;open/5&lt;/code&gt; 와 동일한 인수로 &lt;code&gt;prepare/5&lt;/code&gt; 를 준비 하는 호출로 시작 합니다. &lt;code&gt;prepare/5&lt;/code&gt; 는 사용자가 제안한 TFTP 옵션의 유효성을 검사하고 승인 된 해당 서브 세트를 반환합니다. 그런 다음 옵션이 서버로 전송되어 동일한 TFTP 옵션 협상 절차를 수행합니다. 서버가 승인 한 옵션 은 클라이언트 측에서 &lt;code&gt;open/5&lt;/code&gt; 기능을 수행하도록 전달됩니다 . 클라이언트 측에서 기능 &lt;code&gt;open/5&lt;/code&gt; 는 모든 옵션을 그대로 승인하거나 전송을 거부해야합니다. 그런 다음 콜백 상호 작용은 서버 측에서 설명한 것과 동일한 패턴을 따릅니다. 마지막 블록이 발견 될 때 &lt;code&gt;read/1&lt;/code&gt; 또는 &lt;code&gt;write/2&lt;/code&gt; 이면 리턴 된 상태가 사용자에게 전달되고 &lt;code&gt;read_file&lt;/code&gt; / 3 또는 &lt;code&gt;write_file/3&lt;/code&gt; 에서 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="5fb24826c266fe2b7d30c2585ff68e6ee2e2233f" translate="yes" xml:space="preserve">
          <source>On the client side, where the &lt;code&gt;open/5&lt;/code&gt; call has been preceded by a call to &lt;code&gt;prepare/5&lt;/code&gt;, all options must be accepted or rejected.</source>
          <target state="translated">&lt;code&gt;open/5&lt;/code&gt; 통화에 앞서 &lt;code&gt;prepare/5&lt;/code&gt; 를 준비 하는 통화가 있는 클라이언트 측에서는 모든 옵션을 승인하거나 거부해야합니다.</target>
        </trans-unit>
        <trans-unit id="30bc1d9225132fab91da41cb1dc8196b10d81a6f" translate="yes" xml:space="preserve">
          <source>On the destination side the transport service waits for messages. Each message is forwarded to the Megaco application via the megaco:receive_message/4 callback function. The transport service may or may not provide means for blocking and unblocking the reception of the incoming messages.</source>
          <target state="translated">대상 측에서 전송 서비스는 메시지를 기다립니다. 각 메시지는 megaco : receive_message / 4 콜백 함수를 통해 Megaco 애플리케이션으로 전달됩니다. 전송 서비스는 수신 메시지의 수신을 차단 및 차단 해제하기위한 수단을 제공하거나 제공하지 않을 수있다.</target>
        </trans-unit>
        <trans-unit id="8d08ce8dca231cb0c413cc427e0f7b3615dc40e4" translate="yes" xml:space="preserve">
          <source>On the library page it is possible to control which sources the tool will use. The page is organized as a tree which can be expanded and collapsed by clicking on the little symbol in the beginning of the expandable/collapsible lines.</source>
          <target state="translated">라이브러리 페이지에서 도구가 사용할 소스를 제어 할 수 있습니다. 페이지는 트리로 구성되며 확장 / 축소 가능한 행의 시작 부분에있는 작은 기호를 클릭하여 확장 및 축소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="359fa7aa2c051b4488b5e4f004a78d6117f975d2" translate="yes" xml:space="preserve">
          <source>On the node &lt;code&gt;a@gin&lt;/code&gt;:</source>
          <target state="translated">노드 &lt;code&gt;a@gin&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4dcf5e92ec7cf6d33837ea0dba4f2cf9a86307f9" translate="yes" xml:space="preserve">
          <source>On the node &lt;code&gt;b@skeppet&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;b@skeppet&lt;/code&gt; 노드에서 :</target>
        </trans-unit>
        <trans-unit id="504dd890d20c855491af2a80a9207cca701308e3" translate="yes" xml:space="preserve">
          <source>On the node &lt;code&gt;stack&lt;/code&gt; there's an Erlang node &lt;code&gt;ant@stack&lt;/code&gt;, in the shell, type the following:</source>
          <target state="translated">노드 &lt;code&gt;stack&lt;/code&gt; 에는 Erlang 노드 &lt;code&gt;ant@stack&lt;/code&gt; 이 있고 쉘에 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="72075800ddf3add147be6be68bd87c4adad1f4d0" translate="yes" xml:space="preserve">
          <source>On the node where the application is started, there is a transaction coordinator process. If the transaction is distributed, there is also a transaction participant process on all the other nodes where commit-work needs to be performed.</source>
          <target state="translated">응용 프로그램이 시작된 노드에는 트랜잭션 조정자 프로세스가 있습니다. 트랜잭션이 분배되면 확약 작업을 수행해야하는 다른 모든 노드에도 트랜잭션 참여자 프로세스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="30fba55f8fe9ca566a03374554f0601d38f82b56" translate="yes" xml:space="preserve">
          <source>On the other hand it worth mentioning that at least all cipher suites that would rely on non-validated algorithms are automatically disabled in FIPS mode.</source>
          <target state="translated">반면, 유효성이 검증되지 않은 알고리즘에 의존하는 적어도 모든 암호 스위트는 FIPS 모드에서 자동으로 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="3d6f6cddc5dd538a25571ab6dae15764b54f7d33" translate="yes" xml:space="preserve">
          <source>On the other hand,</source>
          <target state="translated">반면에</target>
        </trans-unit>
        <trans-unit id="79d5245ba64d69949e15fc6366d11aa934acec96" translate="yes" xml:space="preserve">
          <source>On the receiving side the transport module receives the message and forwards it to the protocol engine, which decodes it and invokes user callback functions for each transaction. When a user has handled its action requests, it simply returns a list of action replies (or a message error) and the protocol engine uses the encoding module and transport module to compose and forward the message to the originating user.</source>
          <target state="translated">수신 측에서 전송 모듈은 메시지를 수신하여이를 프로토콜 엔진으로 전달합니다. 프로토콜 엔진은이를 해독하고 각 트랜잭션에 대한 사용자 콜백 기능을 호출합니다. 사용자가 작업 요청을 처리하면 작업 응답 목록 (또는 메시지 오류) 만 반환하고 프로토콜 엔진은 인코딩 모듈과 전송 모듈을 사용하여 메시지를 작성하여 사용자에게 전달합니다.</target>
        </trans-unit>
        <trans-unit id="eb2efe7a16721a2ea4eaaca280d15198cd82819c" translate="yes" xml:space="preserve">
          <source>On the server side, the callback interaction starts with a call to &lt;code&gt;open/5&lt;/code&gt; with the registered initial callback state. &lt;code&gt;open/5&lt;/code&gt; is expected to open the (virtual) file. Then either function &lt;code&gt;read/1&lt;/code&gt; or &lt;code&gt;write/2&lt;/code&gt; is invoked repeatedly, once per transferred block. At each function call, the state returned from the previous call is obtained. When the last block is encountered, function &lt;code&gt;read/1&lt;/code&gt; or &lt;code&gt;write/2&lt;/code&gt; is expected to close the (virtual) file and return its last state. Function &lt;code&gt;abort/3&lt;/code&gt; is only used in error situations. Function &lt;code&gt;prepare/5&lt;/code&gt; is not used on the server side.</source>
          <target state="translated">서버 측에서 콜백 상호 작용 은 등록 된 초기 콜백 상태 에서 &lt;code&gt;open/5&lt;/code&gt; 호출로 시작합니다 . &lt;code&gt;open/5&lt;/code&gt; 는 (가상) 파일을 열 것으로 예상됩니다. 그런 다음 전송 된 블록 당 한 번 함수 &lt;code&gt;read/1&lt;/code&gt; 또는 &lt;code&gt;write/2&lt;/code&gt; 가 반복적으로 호출됩니다. 각 함수 호출에서 이전 호출에서 리턴 된 상태가 확보됩니다. 마지막 블록이 발견되면 함수 &lt;code&gt;read/1&lt;/code&gt; 또는 &lt;code&gt;write/2&lt;/code&gt; 는 (가상) 파일을 닫고 마지막 상태를 리턴해야합니다. 기능 &lt;code&gt;abort/3&lt;/code&gt; 은 오류 상황에서만 사용됩니다. 서버 쪽에서는 기능 &lt;code&gt;prepare/5&lt;/code&gt; 가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f688e5da429c0dc3dd18d9eb9bf400ae2b1e54a" translate="yes" xml:space="preserve">
          <source>On the server side, where there is no preceding &lt;code&gt;prepare/5&lt;/code&gt; call, no new options can be added, but those present in &lt;code&gt;SuggestedOptions&lt;/code&gt; can be omitted or replaced with new values in &lt;code&gt;AcceptedOptions&lt;/code&gt;.</source>
          <target state="translated">사전 &lt;code&gt;prepare/5&lt;/code&gt; 호출 이없는 서버 측에서는 새 옵션을 추가 할 수 없지만 &lt;code&gt;SuggestedOptions&lt;/code&gt; 에 있는 옵션을 생략하거나 &lt;code&gt;AcceptedOptions&lt;/code&gt; 에서 새 값으로 바꿀 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d544406993542a47ac30874abf36e8f76938251" translate="yes" xml:space="preserve">
          <source>On the system settings page it is possible to control some global settings that are used as defaults for all applications. Set the &lt;code&gt;Application inclusion policy&lt;/code&gt; to &lt;code&gt;include&lt;/code&gt; to include all applications that are not explicitly excluded. See &lt;code&gt;incl_cond&lt;/code&gt; (application inclusion) and &lt;code&gt;mod_cond&lt;/code&gt; (module inclusion) in the reference manual for the module &lt;code&gt;reltool&lt;/code&gt; for more info.</source>
          <target state="translated">시스템 설정 페이지에서 모든 응용 프로그램의 기본값으로 사용되는 일부 전역 설정을 제어 할 수 있습니다. 명시 적으로 제외되지 않은 모든 응용 프로그램 을 &lt;code&gt;include&lt;/code&gt; 하도록 &lt;code&gt;Application inclusion policy&lt;/code&gt; 을 설정하십시오 . 자세한 내용 은 모듈 &lt;code&gt;reltool&lt;/code&gt; 의 참조 설명서에서 &lt;code&gt;incl_cond&lt;/code&gt; (응용 프로그램 포함) 및 &lt;code&gt;mod_cond&lt;/code&gt; (모듈 포함)를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="200db783be88f8550d4a8913f57876ec9c489e2e" translate="yes" xml:space="preserve">
          <source>On the third line (or second line depending on the presence of the Emacs directive), arguments can be specified to the emulator, for example:</source>
          <target state="translated">세 번째 줄 (또는 Emacs 지시문의 존재 여부에 따라 두 번째 줄)에서 인수는 에뮬레이터에 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="919203571b510b75243e5425885ce5fd82bf64cd" translate="yes" xml:space="preserve">
          <source>On time-out, the test run is aborted when the current test job is finished. If &lt;code&gt;skip_rest&lt;/code&gt; is provided, the remaining test cases in the current test job are skipped (described later).</source>
          <target state="translated">제한 시간이 초과되면 현재 테스트 작업이 완료되면 테스트 실행이 중단됩니다. 경우 &lt;code&gt;skip_rest&lt;/code&gt; 가 제공되고, 현재의 검사 작업의 나머지 테스트 케이스 (후술) 스킵된다.</target>
        </trans-unit>
        <trans-unit id="94d0fdbeb40f8b7248647cabbfc52c99b7c568d4" translate="yes" xml:space="preserve">
          <source>On unix you can view the manual pages in emacs. In order to find the manual pages, the variable `erlang-root-dir' should be bound to the name of the directory containing the Erlang installation. The name should not include the final slash. Practically, you should add a line on the following form to your ~/.emacs,</source>
          <target state="translated">유닉스에서는 매뉴얼 페이지를 emacs에서 볼 수 있습니다. 매뉴얼 페이지를 찾으려면 변수 'erlang-root-dir'이 Erlang 설치를 포함하는 디렉토리의 이름에 바인딩되어야합니다. 이름에는 마지막 슬래시가 포함되지 않아야합니다. 실제로 다음 형식으로 ~ / .emacs에 줄을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="730b25cb05ff67e83ca2df0e26ea964cf618b32a" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; has returned, it is guaranteed that no &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; message, because of the monitor, will be placed in the caller message queue in the future. However, a &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; message can have been placed in the caller message queue before the call. It is therefore usually advisable to remove such a &lt;code&gt;'DOWN'&lt;/code&gt; message from the message queue after monitoring has been stopped. &lt;code&gt;&lt;a href=&quot;#demonitor-2&quot;&gt;demonitor(MonitorRef, [flush])&lt;/a&gt;&lt;/code&gt; can be used instead of &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; if this cleanup is wanted.</source>
          <target state="translated">&lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; 가 반환 되면 모니터 때문에 &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; 메시지가 향후 발신자 메시지 큐에 배치되지 않습니다. 그러나 &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; 메시지는 호출 전에 호출자 메시지 큐에 배치 될 수 있습니다. 따라서 일반적으로 모니터링이 중지 된 후 메시지 큐에서 이러한 &lt;code&gt;'DOWN'&lt;/code&gt; 메시지 를 제거하는 것이 좋습니다 . 이 정리를 원하면 &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;#demonitor-2&quot;&gt;demonitor(MonitorRef, [flush])&lt;/a&gt;&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8eb33ed8277cd53945b8bd1336967ae012eaa432" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;unlink(Id)&lt;/code&gt; has returned, it is guaranteed that the link between the caller and the entity referred to by &lt;code&gt;Id&lt;/code&gt; has no effect on the caller in the future (unless the link is setup again). If the caller is trapping exits, an &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; message from the link can have been placed in the caller's message queue before the call.</source>
          <target state="translated">일단 &lt;code&gt;unlink(Id)&lt;/code&gt; 돌아왔다, 발신자와 개체 사이의 링크가 참조하는 것을 보장 &lt;code&gt;Id&lt;/code&gt; (링크 설정을 다시하지 않는 한) 미래의 호출에 영향을주지 않습니다. 발신자가 트래핑을 종료하는 경우 링크 의 &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; 메시지가 호출 전에 호출자의 메시지 큐에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2da2fd243f88b2358a1e72df5b1691b330413f0" translate="yes" xml:space="preserve">
          <source>Once a port data lock has been created, it must be locked during all operations on the driver queue of the &lt;code&gt;port&lt;/code&gt;.</source>
          <target state="translated">포트 데이터 잠금이 생성되면, 그것은의 드라이버 큐에있는 모든 작업을 수행하는 동안 잠 가야합니다 &lt;code&gt;port&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="472161e0880a728a8d14ba236e81c941cac5bdc2" translate="yes" xml:space="preserve">
          <source>Once loaded, a NIF library is persistent. It will not be unloaded until the module code version that it belongs to is purged.</source>
          <target state="translated">일단로드되면 NIF 라이브러리는 영구적입니다. 해당 모듈 코드 버전이 제거 될 때까지 언로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ae5090c73eef20a1901a4262fb628566dc03086" translate="yes" xml:space="preserve">
          <source>Once read, this file produces the same configuration variables as the following text file:</source>
          <target state="translated">읽은 후에이 파일은 다음 텍스트 파일과 동일한 구성 변수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2874f79a41ab6a4167b9cad282ba54a8323fe29c" translate="yes" xml:space="preserve">
          <source>Once the CTH is installed into a certain test run it remains there until its scope is expired. The scope of a CTH depends on when it is installed, see the following table. Function &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; is called at the beginning of the scope and function &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:terminate-1&quot;&gt;terminate/1&lt;/a&gt;&lt;/code&gt; is called when the scope ends.</source>
          <target state="translated">CTH가 특정 테스트 실행에 설치되면 범위가 만료 될 때까지 그대로 유지됩니다. CTH의 범위는 설치시기에 따라 다릅니다. 다음 표를 참조하십시오. 범위의 시작 부분에서 함수 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; 가 호출되고 범위가 종료되면 함수 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:terminate-1&quot;&gt;terminate/1&lt;/a&gt;&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f3e0d89fa4414f90c8258d08a4cc02467fbf1279" translate="yes" xml:space="preserve">
          <source>Once the appropriate modules are interpreted, breakpoints can be set at relevant locations in the source code. Breakpoints are specified on a line basis. When a process reaches a breakpoint, it stops and waits for commands (&lt;strong&gt;Step&lt;/strong&gt;, &lt;strong&gt;Skip&lt;/strong&gt;, &lt;strong&gt;Continue&lt;/strong&gt; ...) from the user.</source>
          <target state="translated">적절한 모듈이 해석되면 소스 코드의 관련 위치에 중단 점을 설정할 수 있습니다. 중단 점은 라인 단위로 지정됩니다. 프로세스가 중단 점에 도달하면 프로세스가 중지되고 사용자의 명령 ( &lt;strong&gt;Step&lt;/strong&gt; , &lt;strong&gt;Skip&lt;/strong&gt; , &lt;strong&gt;Continue&lt;/strong&gt; ...)을 기다립니다 .</target>
        </trans-unit>
        <trans-unit id="706354aec2cc6d6f0642591cdb86cf2c478e223c" translate="yes" xml:space="preserve">
          <source>Once the data is collected to the server it can be filtered, sorted and printed in many different ways.</source>
          <target state="translated">데이터가 서버에 수집되면 다양한 방법으로 필터링, 정렬 및 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac354611c2ceba110708f663296284723c689ebb" translate="yes" xml:space="preserve">
          <source>Once the port data lock has been created, every access to data associated with the port data lock must be done while the port data lock is locked. The port data lock is locked and unlocked by &lt;code&gt;&lt;a href=&quot;#driver_pdl_lock&quot;&gt;driver_pdl_lock&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_pdl_unlock&quot;&gt;driver_pdl_unlock&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">포트 데이터 잠금이 작성되면 포트 데이터 잠금이 잠겨있는 동안 포트 데이터 잠금과 연관된 데이터에 대한 모든 액세스가 수행되어야합니다. 포트 데이터 잠금 잠금 및 잠금 해제가 &lt;code&gt;&lt;a href=&quot;#driver_pdl_lock&quot;&gt;driver_pdl_lock&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#driver_pdl_unlock&quot;&gt;driver_pdl_unlock&lt;/a&gt;&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="d4566776ad00ac441fb67a63e43838839e8da21d" translate="yes" xml:space="preserve">
          <source>Once the system is built, you might want to change it. Having a test release in some nice directory might be useful, but you can also run Erlang from within the source tree. The target &lt;code&gt;local_setup&lt;/code&gt;, makes the program &lt;code&gt;$ERL_TOP/bin/erl.exe&lt;/code&gt; usable and it also uses all the OTP libraries in the source tree.</source>
          <target state="translated">시스템이 구축되면 시스템을 변경할 수 있습니다. 멋진 디렉토리에 테스트 릴리스가 있으면 유용 할 수 있지만 소스 트리 내에서 Erlang을 실행할 수도 있습니다. 대상 &lt;code&gt;local_setup&lt;/code&gt; 은 &lt;code&gt;$ERL_TOP/bin/erl.exe&lt;/code&gt; 프로그램을 사용 가능하게하며 소스 트리의 모든 OTP 라이브러리도 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ad8f7b7317e234e5165d7fda5e02abbb7d93475a" translate="yes" xml:space="preserve">
          <source>Once you have a lock counting enabled VM the module &lt;code&gt;lcnt&lt;/code&gt; can be used. The module is intended to be used from the current running nodes shell. To access remote nodes use &lt;code&gt;lcnt:clear(Node)&lt;/code&gt; and &lt;code&gt;lcnt:collect(Node)&lt;/code&gt;.</source>
          <target state="translated">잠금 계산이 활성화 된 VM이 있으면 &lt;code&gt;lcnt&lt;/code&gt; 모듈을 사용할 수 있습니다. 이 모듈은 현재 실행중인 노드 셸에서 사용하도록 설계되었습니다. 원격 노드에 액세스하려면 &lt;code&gt;lcnt:clear(Node)&lt;/code&gt; 및 &lt;code&gt;lcnt:collect(Node)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe6fa81042f05838c7c931d240a87fc23ec1e33e" translate="yes" xml:space="preserve">
          <source>Once you have chosen the modules or directories you want to analyze, click the &lt;strong&gt;Run&lt;/strong&gt; button to start the analysis. If you for some reason want to stop the analysis while it is running, click the &lt;strong&gt;Stop&lt;/strong&gt; button.</source>
          <target state="translated">분석하려는 모듈 또는 디렉토리를 선택한 후 &lt;strong&gt;실행&lt;/strong&gt; 단추를 클릭 하여 분석을 시작하십시오. 어떤 이유로 분석이 실행되는 동안 분석을 &lt;strong&gt;중지&lt;/strong&gt; 하려면 &lt;strong&gt;중지&lt;/strong&gt; 단추를 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1866013abe7a3a8a91c1626525b2105bdb78c26" translate="yes" xml:space="preserve">
          <source>One MIB can communicate with many applications.</source>
          <target state="translated">하나의 MIB가 많은 응용 프로그램과 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7314739d088633c38ec313d94ecdc0d77f14a5ba" translate="yes" xml:space="preserve">
          <source>One can get an approximation of the &lt;code&gt;native&lt;/code&gt; time unit by calling &lt;code&gt;erlang:convert_time_unit(1, second, native)&lt;/code&gt;. The result equals the number of whole &lt;code&gt;native&lt;/code&gt; time units per second. If the number of &lt;code&gt;native&lt;/code&gt; time units per second does not add up to a whole number, the result is rounded downwards.</source>
          <target state="translated">&lt;code&gt;erlang:convert_time_unit(1, second, native)&lt;/code&gt; 를 호출 하여 &lt;code&gt;native&lt;/code&gt; 시간 단위 의 근사값을 얻을 수 있습니다 . 결과는 초당 전체 &lt;code&gt;native&lt;/code&gt; 시간 단위 수와 같습니다 . 수있는 경우 &lt;code&gt;native&lt;/code&gt; 초당 시간 단위는 정수로 추가하지 않습니다, 결과는 둥근 아래입니다.</target>
        </trans-unit>
        <trans-unit id="0c004d9fe4418301daaece7534ddb42246eb9542" translate="yes" xml:space="preserve">
          <source>One entry per allocator. See &lt;code&gt;Allocator&lt;/code&gt; in section &quot;How to Interpret the Erlang Crash Dumps&quot; in ERTS.</source>
          <target state="translated">할당 자당 하나의 항목. ERTS의 &quot;Erlang 크래시 덤프 해석 방법&quot;섹션의 &lt;code&gt;Allocator&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5ae873b8dbf85d90619c54d5534f4bb29cc5b20" translate="yes" xml:space="preserve">
          <source>One example for this is to pre-process incoming data, for example decrypting chunks or collecting characters up to a line break.</source>
          <target state="translated">이에 대한 한 가지 예는 청크를 해독하거나 줄 바꿈까지 문자를 수집하는 등 수신 데이터를 사전 처리하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a14d428a902184f6d393d8bd6140890e2ae77f4b" translate="yes" xml:space="preserve">
          <source>One exception is pattern matching of binaries. The compiler does not rearrange clauses that match binaries. Placing the clause that matches against the empty binary &lt;strong&gt;last&lt;/strong&gt; is usually slightly faster than placing it &lt;strong&gt;first&lt;/strong&gt;.</source>
          <target state="translated">바이너리의 패턴 일치는 예외입니다. 컴파일러는 이진과 일치하는 절을 재 배열하지 않습니다. 빈 바이너리와 &lt;strong&gt;마지막으로&lt;/strong&gt; 일치하는 절을 배치하는 것이 일반적으로 &lt;strong&gt;먼저&lt;/strong&gt; 배치하는 것보다 약간 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="7d94c70dc04626571d8ea05626b35349d3398b38" translate="yes" xml:space="preserve">
          <source>One for finite-state machines (&lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; like), which requires the state to be an atom and uses that state as the name of the current callback function</source>
          <target state="translated">유한 상태 머신 용 ( &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; 과 유사), 상태는 원자 여야하며 해당 상태를 현재 콜백 함수의 이름으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3770c544733aa5fb6e0292ae22987354af0a4e69" translate="yes" xml:space="preserve">
          <source>One group that &lt;code&gt;Common Test&lt;/code&gt; is to ignore and pass on directly to the emulator (those following &lt;code&gt;-erl_args&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 그룹 중 하나 는 무시하고 에뮬레이터에 직접 전달하는 것입니다 ( &lt;code&gt;-erl_args&lt;/code&gt; 다음에 오는 그룹 ).</target>
        </trans-unit>
        <trans-unit id="d6a260162de88ba81cc22f21bd78e10fba85db33" translate="yes" xml:space="preserve">
          <source>One group that &lt;code&gt;Common Test&lt;/code&gt; is to process (those preceding &lt;code&gt;-erl_args&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 가 처리 할 하나의 그룹 (앞의 &lt;code&gt;-erl_args&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="614890ec6bea0b6110430c451657204a01ec779e" translate="yes" xml:space="preserve">
          <source>One line from the file is returned, including the trailing LF, but with CRLF sequences replaced by a single LF (see above).</source>
          <target state="translated">후행 LF를 포함하여 파일에서 한 줄이 반환되지만 CRLF 시퀀스가 ​​단일 LF로 대체됩니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="cdb5ea69a08925e346c04bb8f306808dfae21189" translate="yes" xml:space="preserve">
          <source>One log file, &lt;code&gt;run_erl.log&lt;/code&gt;, which logs progress and warnings from the &lt;code&gt;run_erl&lt;/code&gt; program itself.</source>
          <target state="translated">&lt;code&gt;run_erl&lt;/code&gt; 프로그램 자체 의 진행 및 경고를 기록하는 하나의 로그 파일 &lt;code&gt;run_erl.log&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19cc7e16964b3af0e44bb854d9aa8967052724d4" translate="yes" xml:space="preserve">
          <source>One may also convert arbitrary data to XML. So it for instance is easy to make it readable by humans. In this case you first create xmerl data structures out of your data, then transform it to XML.</source>
          <target state="translated">임의의 데이터를 XML로 변환 할 수도 있습니다. 예를 들어 사람이 쉽게 읽을 수 있습니다. 이 경우 먼저 데이터에서 xmerl 데이터 구조를 작성한 다음 XML로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="d6d6f92b8658a1866e9d8146c603570466b38bb9" translate="yes" xml:space="preserve">
          <source>One network RPC (two messages) to acquire the write lock</source>
          <target state="translated">쓰기 잠금을 획득하기위한 네트워크 RPC 1 개 (메시지 2 개)</target>
        </trans-unit>
        <trans-unit id="00a56ba397ce141f9962051dd004c70978ba6dd8" translate="yes" xml:space="preserve">
          <source>One nice thing with the &lt;code&gt;trace_pattern&lt;/code&gt; is that it provides a very simple way of minimizing the amount of generated trace data by allowing you to explicitly control the detail level of the tracing. As you may have seen the &lt;code&gt;et_viewer&lt;/code&gt; have a slider called &lt;code&gt;&quot;Detail Level&quot;&lt;/code&gt; that allows you to control the detail level of the trace &lt;code&gt;Events&lt;/code&gt; displayed in the &lt;code&gt;Viewer&lt;/code&gt;. On the other hand if you set a low detail level in the &lt;code&gt;trace_pattern&lt;/code&gt;, lots of the trace data will never be generated and thus not sent over the socket to the trace client and stored in the &lt;code&gt;Collector&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;trace_pattern&lt;/code&gt; 의 한 가지 좋은 점 은 추적의 세부 사항 레벨을 명시 적으로 제어 할 수있게하여 생성 된 추적 데이터의 양을 최소화하는 매우 간단한 방법을 제공한다는 것입니다. &lt;code&gt;et_viewer&lt;/code&gt; 본 것처럼 et_viewer 에는 &lt;code&gt;&quot;Detail Level&quot;&lt;/code&gt; 이라는 슬라이더 가있어 &lt;code&gt;Viewer&lt;/code&gt; 에 표시되는 추적 &lt;code&gt;Events&lt;/code&gt; 의 세부 수준을 제어 할 수 있습니다 . 반면에 &lt;code&gt;trace_pattern&lt;/code&gt; 에서 낮은 세부 수준을 설정하면 많은 추적 데이터가 생성되지 않으므로 소켓을 통해 추적 클라이언트로 전송되지 않고 &lt;code&gt;Collector&lt;/code&gt; 저장되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4529738d7c5d95ab24a59e21df7882f76ad41b01" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&quot;Error&quot;&lt;/code&gt;, &lt;code&gt;&quot;Warning&quot;&lt;/code&gt;, &lt;code&gt;&quot;Informational&quot;&lt;/code&gt;, &lt;code&gt;&quot;Audit_Success&quot;&lt;/code&gt;, &lt;code&gt;&quot;Audit_Faulure&quot;&lt;/code&gt; or, in case of a currently unknown Windows NT version &lt;code&gt;&quot;Severity_Unknown&quot;&lt;/code&gt;.</source>
          <target state="translated">하나의 &lt;code&gt;&quot;Error&quot;&lt;/code&gt; , &lt;code&gt;&quot;Warning&quot;&lt;/code&gt; , &lt;code&gt;&quot;Informational&quot;&lt;/code&gt; , &lt;code&gt;&quot;Audit_Success&quot;&lt;/code&gt; , &lt;code&gt;&quot;Audit_Faulure&quot;&lt;/code&gt; 현재 알 수없는 Windows NT 버전의 경우 또는, &lt;code&gt;&quot;Severity_Unknown&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1a6b0b2d35c017b6e03a9c4a65c9d58e6870f08" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_event&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt; for this case.</source>
          <target state="translated">&lt;code&gt;gen_event&lt;/code&gt; 상태 를 얻기 위해 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 중 하나 가 호출됩니다 . 이 경우에는 &lt;code&gt;Opt&lt;/code&gt; 가 원자 &lt;code&gt;normal&lt;/code&gt; 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="7da5bbc0da1569bb676eb4407e53fc819a024b48" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_server&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; 상태 를 얻기 위해 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 중 하나 가 호출됩니다 . &lt;code&gt;Opt&lt;/code&gt; 가 원자 &lt;code&gt;normal&lt;/code&gt; 로 설정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="eb296f4b0ca5c3593de75916329b44424ed9130b" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_statem&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt; for this case.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 상태 를 얻기 위해 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 중 하나 가 호출됩니다 . 이 경우에는 &lt;code&gt;Opt&lt;/code&gt; 가 원자 &lt;code&gt;normal&lt;/code&gt; 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="fdb44fc1b32a8df8e66016b4df34ca5e01e3c2a5" translate="yes" xml:space="preserve">
          <source>One of the &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;SCTP Socket Options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#options&quot;&gt;SCTP Socket Options&lt;/a&gt;&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="56827b36a41cbbd74b980c5f475d1ddd1caffbc8" translate="yes" xml:space="preserve">
          <source>One of the UTF-encodings, which is specified as parameter &lt;code&gt;InEncoding&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;InEncoding&lt;/code&gt; 으로 지정된 UTF 인코딩 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="bf5094e20e8e0457a5a8f2279ba88b4ba2472732" translate="yes" xml:space="preserve">
          <source>One of the kernel processes could not start. This is probably because of faulty arguments (like errors in a &lt;code&gt;-config&lt;/code&gt; argument) or faulty configuration files. Check that all files are in their correct location and that the configuration files (if any) are not damaged. Usually messages are also written to the controlling terminal and/or the error log explaining what is wrong.</source>
          <target state="translated">커널 프로세스 중 하나를 시작할 수 없습니다. 이는 인수가 잘못 되었거나 ( &lt;code&gt;-config&lt;/code&gt; 인수의 오류와 같은 ) 구성 파일 이 잘못 되었기 때문일 수 있습니다. 모든 파일이 올바른 위치에 있고 구성 파일 (있는 경우)이 손상되지 않았는지 확인하십시오. 일반적으로 메시지는 제어 터미널 및 / 또는 잘못된 내용을 설명하는 오류 로그에도 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="0841995ee62550fe5206c50f4fb1982a4e801b20" translate="yes" xml:space="preserve">
          <source>One of the main reasons for using Erlang instead of other functional languages is Erlang's ability to handle concurrency and distributed programming. By concurrency is meant programs that can handle several threads of execution at the same time. For example, modern operating systems allow you to use a word processor, a spreadsheet, a mail client, and a print job all running at the same time. Each processor (CPU) in the system is probably only handling one thread (or job) at a time, but it swaps between the jobs at such a rate that it gives the illusion of running them all at the same time. It is easy to create parallel threads of execution in an Erlang program and to allow these threads to communicate with each other. In Erlang, each thread of execution is called a &lt;strong&gt;process&lt;/strong&gt;.</source>
          <target state="translated">다른 기능 언어 대신 Erlang을 사용하는 주된 이유 중 하나는 동시성 및 분산 프로그래밍을 처리 할 수있는 Erlang의 기능입니다. 동시성은 여러 실행 스레드를 동시에 처리 할 수있는 프로그램을 의미합니다. 예를 들어 최신 운영 체제에서는 워드 프로세서, 스프레드 시트, 메일 클라이언트 및 인쇄 작업을 모두 동시에 실행할 수 있습니다. 시스템의 각 프로세서 (CPU)는 한 번에 하나의 스레드 (또는 작업) 만 처리 할 수 ​​있지만 동시에 모든 작업을 실행한다는 착각을주는 속도로 작업간에 교환합니다. Erlang 프로그램에서 병렬 실행 스레드를 작성하고 이들 스레드가 서로 통신 할 수 있습니다. Erlang에서는 각 실행 스레드를 &lt;strong&gt;프로세스&lt;/strong&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="f9c1395f01aa6569ad6f5518bd05795ed28e86fb" translate="yes" xml:space="preserve">
          <source>One of the things you can specify is where Erlang/OTP should be installed. By default Erlang/OTP will be installed in &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt;. To keep the same structure but install in a different place, &lt;code&gt;&amp;lt;Dir&amp;gt;&lt;/code&gt; say, use the &lt;code&gt;--prefix&lt;/code&gt; argument like this: &lt;code&gt;./configure --prefix=&amp;lt;Dir&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">지정할 수있는 것 중 하나는 Erlang / OTP가 설치되는 위치입니다. 기본적으로 Erlang / OTP는 &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt; 에 설치 됩니다. 동일한 구조를 유지하지만 다른 위치에 설치하려면, &lt;code&gt;&amp;lt;Dir&amp;gt;&lt;/code&gt; 말의 사용 &lt;code&gt;--prefix&lt;/code&gt; 이 같은 인수 &lt;code&gt;./configure --prefix=&amp;lt;Dir&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1eeb7842fcafd703c9e0619139450ba12ea61a05" translate="yes" xml:space="preserve">
          <source>One of the tuples is &lt;code&gt;{timeout, GcTime}&lt;/code&gt;, where &lt;code&gt;GcTime&lt;/code&gt; is the time for the garbage collection in milliseconds. The other tuples are tagged with &lt;code&gt;heap_size&lt;/code&gt;, &lt;code&gt;heap_block_size&lt;/code&gt;, &lt;code&gt;stack_size&lt;/code&gt;, &lt;code&gt;mbuf_size&lt;/code&gt;, &lt;code&gt;old_heap_size&lt;/code&gt;, and &lt;code&gt;old_heap_block_size&lt;/code&gt;. These tuples are explained in the description of trace message &lt;code&gt;&lt;a href=&quot;#gc_minor_start&quot;&gt;gc_minor_start&lt;/a&gt;&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;). New tuples can be added, and the order of the tuples in the &lt;code&gt;Info&lt;/code&gt; list can be changed at any time without prior notice.</source>
          <target state="translated">튜플 중 하나는 &lt;code&gt;{timeout, GcTime}&lt;/code&gt; . 여기서 &lt;code&gt;GcTime&lt;/code&gt; 은 가비지 콜렉션 시간 (밀리 초)입니다. 다른 튜플에는 &lt;code&gt;heap_size&lt;/code&gt; , &lt;code&gt;heap_block_size&lt;/code&gt; , &lt;code&gt;stack_size&lt;/code&gt; , &lt;code&gt;mbuf_size&lt;/code&gt; , &lt;code&gt;old_heap_size&lt;/code&gt; 및 &lt;code&gt;old_heap_block_size&lt;/code&gt; 태그가 지정됩니다 . 이 튜플은 추적 메시지 &lt;code&gt;&lt;a href=&quot;#gc_minor_start&quot;&gt;gc_minor_start&lt;/a&gt;&lt;/code&gt; 의 설명에 설명되어 있습니다 ( &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; 참조 ). 새 튜플을 추가 할 수 있으며 &lt;code&gt;Info&lt;/code&gt; 목록 의 튜플 순서는 언제든지 사전 통지없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69a9014859b12f37b0519806ad1834d826c6c31a" translate="yes" xml:space="preserve">
          <source>One of these MIBs is always loaded. If only SNMPv1 is used, STANDARD-MIB is loaded, otherwise SNMPv2-MIB is loaded.</source>
          <target state="translated">이러한 MIB 중 하나가 항상로드됩니다. SNMPv1 만 사용하면 STANDARD-MIB가로드되고, 그렇지 않으면 SNMPv2-MIB가로드됩니다.</target>
        </trans-unit>
        <trans-unit id="7e580959901caa525ce54698db0283f68f4a7825" translate="yes" xml:space="preserve">
          <source>One option is available:</source>
          <target state="translated">하나의 옵션을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6ff4f2ec7cb45924fc22a9581c0d12e7c6a17439" translate="yes" xml:space="preserve">
          <source>One or more records have possibly been deleted. All records with the key &lt;code&gt;Key&lt;/code&gt; in the table &lt;code&gt;Tab&lt;/code&gt; have been deleted.</source>
          <target state="translated">하나 이상의 레코드가 삭제되었을 수 있습니다. 테이블 &lt;code&gt;Tab&lt;/code&gt; 에서 키 &lt;code&gt;Key&lt;/code&gt; 가있는 모든 레코드 가 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="6fa66ab663063997cdb9c048f7104f3433cd5c89" translate="yes" xml:space="preserve">
          <source>One or more selective decode functions can be described in a configuration file. Use the following notation:</source>
          <target state="translated">하나 이상의 선택적 디코딩 기능이 구성 파일에 설명 될 수 있습니다. 다음 표기법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2e8538d4b29bcc1590b46f99d089134dbfb209ae" translate="yes" xml:space="preserve">
          <source>One possible use of this function is to compute a fixed layout for a document, which can then be included as part of a larger document. For example:</source>
          <target state="translated">이 기능을 사용할 수있는 한 가지 방법은 문서의 고정 레이아웃을 계산 한 다음 더 큰 문서의 일부로 포함시킬 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f814b315540a519172775a3b2360fd1f8b22e518" translate="yes" xml:space="preserve">
          <source>One process can block multi-scheduling and normal multi-scheduling multiple times. If a process has blocked multiple times, it must unblock exactly as many times as it has blocked before it has released its multi-scheduling block. If a process that has blocked multi-scheduling or normal multi-scheduling exits, it automatically releases its blocking of multi-scheduling and normal multi-scheduling.</source>
          <target state="translated">하나의 프로세스는 다중 예약 및 일반 다중 예약을 여러 번 차단할 수 있습니다. 프로세스가 여러 번 차단 된 경우 다중 예약 블록을 해제하기 전에 차단 된 횟수만큼 정확하게 차단을 해제해야합니다. 다중 예약 또는 일반 다중 예약을 차단 한 프로세스가 종료되면 자동으로 다중 예약 및 일반 다중 예약 차단이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="4e1d0d9b681492f79f0f0d77d94d063833656c4e" translate="yes" xml:space="preserve">
          <source>One reason to use this is when you have a state item that when changed should cancel the &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;State Time-Out&lt;/a&gt;&lt;/code&gt;, or one that affects the event handling in combination with postponing events. We will go for the latter and complicate the previous example by introducing a configurable lock button (this is the state item in question), which in the &lt;code&gt;open&lt;/code&gt; state immediately locks the door, and an API function &lt;code&gt;set_lock_button/1&lt;/code&gt; to set the lock button.</source>
          <target state="translated">이것을 사용하는 한 가지 이유는 변경 될 때 &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;State Time-Out&lt;/a&gt;&lt;/code&gt; 을 취소해야하는 상태 항목이 있거나 연기 된 이벤트와 함께 이벤트 처리에 영향을주는 것입니다. 우리는 후자에 대해 구성 가능한 잠금 버튼 (이것은 문제의 상태 항목 임)을 &lt;code&gt;open&lt;/code&gt; 이전 예제를 복잡하게 할 것입니다.이 상태는 열린 상태에서 즉시 문을 잠그고 API 함수 &lt;code&gt;set_lock_button/1&lt;/code&gt; 은 잠금 버튼을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c6a0ffbab932f1acb483f5ff3812f8940806157e" translate="yes" xml:space="preserve">
          <source>One slight difference is that &lt;code&gt;length(L)&lt;/code&gt; fails if &lt;code&gt;L&lt;/code&gt; is an improper list, while the pattern in the second code fragment accepts an improper list.</source>
          <target state="translated">&lt;code&gt;L&lt;/code&gt; 이 부적절한 목록 인 경우 &lt;code&gt;length(L)&lt;/code&gt; 가 실패하는 반면, 두 번째 코드 조각의 패턴은 부적절한 목록을 허용 한다는 점에서 약간의 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="131ac9dcf4813fc8eef42652b85941c718619c49" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to make the snmp application a distributed Erlang application, and that means, the agent may be configured to run on one of several nodes. If the node where it runs goes down, another node restarts the agent. This is called &lt;strong&gt;failover&lt;/strong&gt;. When the node starts again, it may &lt;strong&gt;takeover&lt;/strong&gt; the application. This solution to the problem adds another problem. Generally, the new node has another IP address than the first one, which may cause problems in the communication between the SNMP managers and the agent.</source>
          <target state="translated">이 문제점에 대한 한 가지 해결책은 snmp 애플리케이션을 분산 Erlang 애플리케이션으로 만드는 것입니다. 즉, 에이전트가 여러 노드 중 하나에서 실행되도록 구성 될 수 있습니다. 실행중인 노드가 다운되면 다른 노드가 에이전트를 다시 시작합니다. 이를 &lt;strong&gt;장애 조치&lt;/strong&gt; 라고 합니다. 노드가 다시 시작되면 응용 프로그램을 &lt;strong&gt;인계&lt;/strong&gt; 할 수 있습니다 . 이 문제에 대한 해결책은 또 다른 문제를 추가합니다. 일반적으로 새 노드는 첫 번째 노드와 다른 IP 주소를 가지므로 SNMP 관리자와 에이전트 간의 통신에 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ae865e27e4e371daac0c98d141254785bdec512" translate="yes" xml:space="preserve">
          <source>One use for this function is to return compact alternative state representations to avoid having large state terms printed in log files. Another use is to hide sensitive data from being written to the error log.</source>
          <target state="translated">이 기능의 한 가지 용도는 로그 파일에 큰 상태 용어가 인쇄되지 않도록 간단한 대체 상태 표현을 반환하는 것입니다. 또 다른 용도는 민감한 데이터가 오류 로그에 기록되지 않도록 숨기는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2344ac8a5a53008ccbf114aa5bb4b2144babab77" translate="yes" xml:space="preserve">
          <source>One use for this function is to return compact alternative state representations to avoid that large state terms are printed in log files.</source>
          <target state="translated">이 함수의 사용 중 하나는 큰 상태 용어가 로그 파일에 인쇄되지 않도록 간단한 대체 상태 표현을 반환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ecf62d4adfa3a80a6880d79089f74bc1229726c5" translate="yes" xml:space="preserve">
          <source>One valid &lt;code&gt;Item&lt;/code&gt; for events exists:</source>
          <target state="translated">이벤트에 유효한 &lt;code&gt;Item&lt;/code&gt; 하나 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0530e4915fd69c53963bcd7d20091d18ef6b916a" translate="yes" xml:space="preserve">
          <source>One without restriction on the state data type that uses one callback function for all states</source>
          <target state="translated">모든 상태에 대해 하나의 콜백 함수를 사용하는 상태 데이터 유형에 제한이없는 것</target>
        </trans-unit>
        <trans-unit id="6fbd38dfe616170f1b6def311df7bb7a510f025b" translate="yes" xml:space="preserve">
          <source>Online support - &lt;code&gt;release_handler&lt;/code&gt; for unpacking and installing release packages</source>
          <target state="translated">온라인 지원- 릴리스 패키지의 포장 풀기 및 설치를위한 &lt;code&gt;release_handler&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85e8ca2afe642fa985ec03b77e6580554e8210e3" translate="yes" xml:space="preserve">
          <source>Only a subset of all &lt;code&gt;erts_alloc&lt;/code&gt; flags can be changed at run time. This subset is currently only the flag &lt;code&gt;sbct&lt;/code&gt;.</source>
          <target state="translated">런타임시 모든 &lt;code&gt;erts_alloc&lt;/code&gt; 플래그 의 서브 세트 만 변경할 수 있습니다. 이 서브 세트는 현재 플래그 &lt;code&gt;sbct&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8fc50435c4f101d7fcbdd1178cc4fb637fb7e775" translate="yes" xml:space="preserve">
          <source>Only a subset of the function clauses are show above. The full set of valid combinations of input parameters is as follows:</source>
          <target state="translated">함수 절의 하위 집합 만 위에 표시됩니다. 입력 매개 변수의 유효한 전체 조합은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a71b05d84131dd4964afd0db7b460b38e844ff2b" translate="yes" xml:space="preserve">
          <source>Only actual parameters with other than default values are returned, for example not directives that specify other sources for configuration parameters nor directives that clear parameters.</source>
          <target state="translated">구성 매개 변수의 다른 소스를 지정하는 지시문이나 매개 변수를 지우는 지시문이 아닌 기본값 이외의 실제 매개 변수 만 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="143811c603bbe64ab0e87b64c4ca39d3733d06c3" translate="yes" xml:space="preserve">
          <source>Only allowed after an &lt;code&gt;if&lt;/code&gt; or another &lt;code&gt;elif&lt;/code&gt; directive. If the preceding &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;elif&lt;/code&gt; directives do not evaluate to true, and the &lt;code&gt;Condition&lt;/code&gt; evaluates to true, the lines following the &lt;code&gt;elif&lt;/code&gt; are evaluated instead.</source>
          <target state="translated">만 이후에 허용 된 &lt;code&gt;if&lt;/code&gt; 또는 다른 &lt;code&gt;elif&lt;/code&gt; 지시어. 앞의 &lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;elif&lt;/code&gt; 지시문이 true로 평가되지 않고 &lt;code&gt;Condition&lt;/code&gt; 이 true 로 평가 되면, &lt;code&gt;elif&lt;/code&gt; 다음의 행 이 대신 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="6e65766f3d400fa0c4ec2ec7f3b23a8557087a78" translate="yes" xml:space="preserve">
          <source>Only allowed after an &lt;code&gt;ifdef&lt;/code&gt; or &lt;code&gt;ifndef&lt;/code&gt; directive. If that condition is false, the lines following &lt;code&gt;else&lt;/code&gt; are evaluated instead.</source>
          <target state="translated">&lt;code&gt;ifdef&lt;/code&gt; 또는 &lt;code&gt;ifndef&lt;/code&gt; 지시문 이후에만 허용 됩니다. 그 조건이 거짓 인 경우, 다음과 같은 라인 &lt;code&gt;else&lt;/code&gt; 대신 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="03727b1fe9878a4627e85a8cbe80d475296b011b" translate="yes" xml:space="preserve">
          <source>Only allowed for connection-oriented sockets.</source>
          <target state="translated">연결 지향 소켓에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="1a32ac3b85acdfc340d76cd1ade965319d5c1792" translate="yes" xml:space="preserve">
          <source>Only binaries and allocations made by NIFs and drivers are tagged by default, but this can be configured an a per-allocator basis with the &lt;code&gt;+M&amp;lt;S&amp;gt;atags&lt;/code&gt; emulator option.</source>
          <target state="translated">NIF와 드라이버가 만든 바이너리와 할당 만 기본적으로 태그가 지정되지만 &lt;code&gt;+M&amp;lt;S&amp;gt;atags&lt;/code&gt; 에뮬레이터 옵션을 사용하여 할당 자 단위로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5ee0b816fb973da72fef21bb99316a4666d0fe2" translate="yes" xml:space="preserve">
          <source>Only explicit connection set-ups are used.</source>
          <target state="translated">명시 적 연결 설정 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="965fd205ec4a5be006cc4bdca91e080bb904b491" translate="yes" xml:space="preserve">
          <source>Only files with exactly these extensions are compressed.</source>
          <target state="translated">이러한 확장자를 가진 파일 만 압축됩니다.</target>
        </trans-unit>
        <trans-unit id="d800e233c81231deb85380be879f6765bb0a09d1" translate="yes" xml:space="preserve">
          <source>Only if a shell script or &lt;code&gt;.bat&lt;/code&gt; file is executed, the appropriate command interpreter is invoked implicitly, but there is still no command-argument expansion or implicit &lt;code&gt;PATH&lt;/code&gt; search.</source>
          <target state="translated">쉘 스크립트 또는 &lt;code&gt;.bat&lt;/code&gt; 파일이 실행되는 경우에만 적절한 명령 인터프리터가 내재적으로 호출되지만 여전히 명령 인수 확장 또는 내재적 &lt;code&gt;PATH&lt;/code&gt; 검색은 없습니다.</target>
        </trans-unit>
        <trans-unit id="6e308954fb7661938a56cab2015555144c20f290" translate="yes" xml:space="preserve">
          <source>Only if a string contains code points &amp;lt; 256, can it be directly converted to a binary by using, for example, &lt;code&gt;erlang:iolist_to_binary/1&lt;/code&gt; or can be sent directly to a port. If the string contains Unicode characters &amp;gt; 255, an encoding must be decided upon and the string is to be converted to a binary in the preferred encoding using &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt;. Strings are not generally lists of bytes, as they were before Erlang/OTP R13, they are lists of characters. Characters are not generally bytes, they are Unicode code points.</source>
          <target state="translated">문자열에 코드 포인트 &amp;lt;256이 포함 된 경우에만 예를 들어 &lt;code&gt;erlang:iolist_to_binary/1&lt;/code&gt; 을 사용하여 이진으로 직접 변환 하거나 포트로 직접 보낼 수 있습니다. 문자열에 유니 코드 문자&amp;gt; 255가 포함 된 경우 인코딩을 결정해야하며 &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt; 을 사용하여 선호하는 인코딩에서 문자열을 이진으로 변환해야합니다 . 문자열은 일반적으로 Erlang / OTP R13 이전의 바이트 목록이 아니며 문자 목록입니다. 문자는 일반적으로 바이트가 아니며 유니 코드 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="660019367304634239f33b92fdff61cb41611c83" translate="yes" xml:space="preserve">
          <source>Only if the server is in the confirmed commit phase, the configuration is restored to its state before entering the confirmed commit phase. Otherwise, no configuration rollback is performed.</source>
          <target state="translated">서버가 확정 커밋 단계에있는 경우에만 확인 커밋 단계에 들어가기 전에 구성이 해당 상태로 복원됩니다. 그렇지 않으면 구성 롤백이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cbd2fd09cd558a21021b0e71892ab5c5ffaa9a70" translate="yes" xml:space="preserve">
          <source>Only matters for matching and when the type is &lt;code&gt;integer&lt;/code&gt;. The default is &lt;code&gt;unsigned&lt;/code&gt;.</source>
          <target state="translated">일치 및 유형이 &lt;code&gt;integer&lt;/code&gt; 일 때만 중요합니다 . 기본값은 &lt;code&gt;unsigned&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2ac47075244f080582d68564475ba1c72e44655e" translate="yes" xml:space="preserve">
          <source>Only modules compiled with option &lt;code&gt;debug_info&lt;/code&gt; set can be interpreted. Non-interpretable modules are displayed within parenthesis in the Interpret Modules window.</source>
          <target state="translated">옵션 &lt;code&gt;debug_info&lt;/code&gt; 세트로 컴파일 된 모듈 만 해석 할 수 있습니다. 해석 할 수없는 모듈은 해석 모듈 창에서 괄호 안에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2d63c1fd79def5aea280eb8e5551a9a4f8acf4ef" translate="yes" xml:space="preserve">
          <source>Only on 64-bit halfword emulator. The total amount of memory allocated in low memory areas that are restricted to &amp;lt; 4 GB, although the system can have more memory.</source>
          <target state="translated">64 비트 하프 워드 에뮬레이터에서만. 시스템에 더 많은 메모리가있을 수 있지만 4GB 미만으로 제한되는 메모리 부족 영역에 할당 된 총 메모리 양입니다.</target>
        </trans-unit>
        <trans-unit id="f8b4dc2954832ab8284b54f1deee60e8ee9f12e3" translate="yes" xml:space="preserve">
          <source>Only one &lt;code&gt;MonitorOption&lt;/code&gt; can be specified. It is one of the following:</source>
          <target state="translated">하나의 &lt;code&gt;MonitorOption&lt;/code&gt; 만 지정할 수 있습니다. 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="d1d25510eb44623309c6a466f80982b971e3a79b" translate="yes" xml:space="preserve">
          <source>Only one entry of this type is allowed.</source>
          <target state="translated">이 유형의 항목은 하나만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="2f8db1c5a163c86ad59a6d1922863061872c37b3" translate="yes" xml:space="preserve">
          <source>Only one table is loaded by &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt;. Since committed transactions can have caused updates in several tables, the tables can become inconsistent because of the forced load.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; 의해 하나의 테이블 만로드됩니다 . 커밋 된 트랜잭션으로 인해 여러 테이블에서 업데이트가 발생할 수 있으므로 강제로드로 인해 테이블이 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e92ee7eb3618038b399f136fb76be40e18e1bc01" translate="yes" xml:space="preserve">
          <source>Only some default values have been presented here. For information about the currently used settings and the current status of the allocators, see &lt;code&gt;erlang:system_info(allocator)&lt;/code&gt; and &lt;code&gt;erlang:system_info({allocator, Alloc})&lt;/code&gt;.</source>
          <target state="translated">여기에는 일부 기본값 만 제시되어 있습니다. 현재 사용 된 설정 및 할당 자의 현재 상태에 대한 정보는 &lt;code&gt;erlang:system_info(allocator)&lt;/code&gt; 및 &lt;code&gt;erlang:system_info({allocator, Alloc})&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39e55a508bb5366d1ba41f1b8cc19d785d5f6e26" translate="yes" xml:space="preserve">
          <source>Only supported if ERTS was compiled with zlib &amp;gt;= 1.2.8.</source>
          <target state="translated">ERTS가 zlib&amp;gt; = 1.2.8로 컴파일 된 경우에만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1405eb7cb56be68779595f26b14d02a57896c6d6" translate="yes" xml:space="preserve">
          <source>Only the DEFLATE (zlib-compression) and the STORE (uncompressed data) zip methods are supported.</source>
          <target state="translated">DEFLATE (zlib-compression) 및 STORE (압축되지 않은 데이터) zip 메소드 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="be533a124805e79fe90a76852bcb557c73fc2e89" translate="yes" xml:space="preserve">
          <source>Only the Erlang process that opened the file can use it.</source>
          <target state="translated">파일을 연 Erlang 프로세스 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eff26c5132f4e18c3af8859f76e7ae06eef0123a" translate="yes" xml:space="preserve">
          <source>Only the currently connected job can 'talk' to the shell.</source>
          <target state="translated">현재 연결된 작업 만 쉘과 '대화'할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a03597ea953bd3b370af7ca4b5066ffbc33977b3" translate="yes" xml:space="preserve">
          <source>Only the first captured subpattern, which is always the complete matching part of the subject. All explicitly captured subpatterns are discarded.</source>
          <target state="translated">첫 번째 캡처 된 하위 패턴 만 항상 주제와 완전히 일치하는 부분입니다. 명시 적으로 캡처 된 모든 하위 패턴은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="b70de51c32ae79e58749256bc1925f2b5088935f" translate="yes" xml:space="preserve">
          <source>Only the following metacharacters are recognized in character classes:</source>
          <target state="translated">문자 클래스에서는 다음 메타 문자 만 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="f8c7ec7f774783186ec033a3872a8ed95ec657d5" translate="yes" xml:space="preserve">
          <source>Only the owner process can read or write to the table.</source>
          <target state="translated">소유자 프로세스 만 테이블을 읽거나 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae72d9870b541f6e2a7d88226bfd5d4e90663a8e" translate="yes" xml:space="preserve">
          <source>Only the process registered as distribution controller for the distribution channel identified by &lt;code&gt;DHandle&lt;/code&gt; is allowed to call this function unless an alternate input handler process has been registered using &lt;code&gt;&lt;a href=&quot;erlang#dist_ctrl_input_handler-2&quot;&gt;erlang:dist_ctrl_input_handler(DHandle, InputHandler)&lt;/a&gt;&lt;/code&gt;. If an alternate input handler has been registered, only the registered input handler process is allowed to call this function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#dist_ctrl_input_handler-2&quot;&gt;erlang:dist_ctrl_input_handler(DHandle, InputHandler)&lt;/a&gt;&lt;/code&gt; 사용하여 대체 입력 핸들러 프로세스를 등록하지 않은 경우 &lt;code&gt;DHandle&lt;/code&gt; 로 식별 된 분배 채널에 분배 컨트롤러로 등록 된 프로세스 만이 함수를 호출 할 수 있습니다. 대체 입력 핸들러가 등록 된 경우 등록 된 입력 핸들러 프로세스 만이 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0120f9c54ff86c06696b34a4219af2378345acdb" translate="yes" xml:space="preserve">
          <source>Only the process registered as distribution controller for the distribution channel identified by &lt;code&gt;DHandle&lt;/code&gt; is allowed to call this function.</source>
          <target state="translated">&lt;code&gt;DHandle&lt;/code&gt; 이 식별 한 분배 채널에 분배 제어기로 등록 된 프로세스 만이 기능을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff7ef46b3f7713cb10f8c8f5e86db36f63612540" translate="yes" xml:space="preserve">
          <source>Only the specified part is searched. Return values still have offsets from the beginning of &lt;code&gt;Subject&lt;/code&gt;. A negative &lt;code&gt;Length&lt;/code&gt; is allowed as described in section Data Types in this manual.</source>
          <target state="translated">지정된 부분 만 검색합니다. 반환 값에는 여전히 &lt;code&gt;Subject&lt;/code&gt; 의 시작 부분부터 오프셋이 있습니다 . 이 매뉴얼의 데이터 유형 섹션에 설명 된대로 음의 &lt;code&gt;Length&lt;/code&gt; 가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="92b1c560a3c609b6630ba6369a93d7159051e3e5" translate="yes" xml:space="preserve">
          <source>Only these exact character sequences are recognized. A sequence such as [a[:&amp;lt;:]b] provokes error for an unrecognized POSIX class name. This support is not compatible with Perl. It is provided to help migrations from other environments, and is best not used in any new patterns. Note that \b matches at the start and the end of a word (see &quot;Simple assertions&quot; above), and in a Perl-style pattern the preceding or following character normally shows which is wanted, without the need for the assertions that are used above in order to give exactly the POSIX behaviour.</source>
          <target state="translated">이 정확한 문자 시퀀스 만 인식됩니다. [a [: &amp;lt;:] b]와 같은 시퀀스는 인식 할 수없는 POSIX 클래스 이름에 대한 오류를 유발합니다. 이 지원은 Perl과 호환되지 않습니다. 다른 환경에서 마이그레이션하는 데 도움이되며 새로운 패턴에는 사용하지 않는 것이 가장 좋습니다. \ b는 단어의 시작과 끝에서 일치하며 (위의 &quot;단순 어설 션&quot;참조) Perl 스타일 패턴에서 앞 또는 다음 문자는 일반적으로 사용되는 어설 션없이 원하는 것을 보여줍니다. POSIX 동작을 정확하게하기 위해</target>
        </trans-unit>
        <trans-unit id="17d1fba9658ded214a434ab7601d513e4c6c5aaf" translate="yes" xml:space="preserve">
          <source>Only total</source>
          <target state="translated">총계</target>
        </trans-unit>
        <trans-unit id="b466165e837dbf10eadb47e4bc9b893d7bb50387" translate="yes" xml:space="preserve">
          <source>Only trace messages from a specific process &lt;code&gt;Pid&lt;/code&gt;:</source>
          <target state="translated">특정 프로세스 &lt;code&gt;Pid&lt;/code&gt; 의 메시지 만 추적하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5bfc32b55921a00a28f4c0d1a74dc4ff5f9f2ba" translate="yes" xml:space="preserve">
          <source>Only trace messages from other nodes:</source>
          <target state="translated">다른 노드의 메시지 만 추적하십시오.</target>
        </trans-unit>
        <trans-unit id="78247ecb104811399c3277cdd7d4c731768a72b0" translate="yes" xml:space="preserve">
          <source>Only trace messages matching &lt;code&gt;{reply, _}&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;{reply, _}&lt;/code&gt; 과) 일치하는 추적 메시지 만</target>
        </trans-unit>
        <trans-unit id="7666550505039a9e83e909935389e4f3ca8ed6d8" translate="yes" xml:space="preserve">
          <source>Only trace messages sent to other nodes:</source>
          <target state="translated">다른 노드로 전송 된 추적 메시지 만 :</target>
        </trans-unit>
        <trans-unit id="550dd65f9f1635f5b26d39adb415360c2a92434a" translate="yes" xml:space="preserve">
          <source>Only trace messages sent to the sender itself:</source>
          <target state="translated">발신자 자신에게 보낸 추적 메시지 만 :</target>
        </trans-unit>
        <trans-unit id="2500bda55ee606fa893cbad9220ec886375e6705" translate="yes" xml:space="preserve">
          <source>Only trace messages to a specific process &lt;code&gt;Pid&lt;/code&gt;:</source>
          <target state="translated">특정 프로세스 &lt;code&gt;Pid&lt;/code&gt; 로만 메시지를 추적하십시오 .</target>
        </trans-unit>
        <trans-unit id="42b574e1ef29bfa437b36acb9027769673eb223a" translate="yes" xml:space="preserve">
          <source>Only two arguments, of which one must be &lt;code&gt;true&lt;/code&gt; and the other &lt;code&gt;false&lt;/code&gt; to return &lt;code&gt;true&lt;/code&gt;; otherwise &lt;code&gt;'xor'&lt;/code&gt; returns false.</source>
          <target state="translated">단지 두 개의 인수, 하나가되어야합니다있는 &lt;code&gt;true&lt;/code&gt; 과 다른 &lt;code&gt;false&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;'xor'&lt;/code&gt; 는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a84b39b2c86b869fad86343fd9fef89839964e4b" translate="yes" xml:space="preserve">
          <source>Only use these flags if you are sure what you are doing. Unsuitable settings can cause serious performance degradation and even a system crash at any time during operation.</source>
          <target state="translated">무엇을하고 있는지 확실하다면이 플래그 만 사용하십시오. 부적절한 설정은 작동 중 언제라도 심각한 성능 저하 및 시스템 충돌을 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d7818114df4175719fb624ea7ed7fe90002e953" translate="yes" xml:space="preserve">
          <source>Only used during handshake phase.</source>
          <target state="translated">핸드 셰이크 단계에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="63f8061fc22c121f41217cd28e783b48e49934d5" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt; and &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;. It allows the standard input and output (file descriptors 0 and 1) of the spawned (Unix) process for communication with Erlang.</source>
          <target state="translated">&lt;code&gt;{spawn, Command}&lt;/code&gt; 및 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 에만 유효합니다 . Erlang과의 통신을 위해 생성 된 (Unix) 프로세스의 표준 입력 및 출력 (파일 설명자 0 및 1)을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="18c2212e127b0c910798dbbf1d59d9d69e12fd4b" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt; and &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;. The external program starts using &lt;code&gt;Dir&lt;/code&gt; as its working directory. &lt;code&gt;Dir&lt;/code&gt; must be a string.</source>
          <target state="translated">&lt;code&gt;{spawn, Command}&lt;/code&gt; 및 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 에만 유효합니다 . 외부 프로그램은 &lt;code&gt;Dir&lt;/code&gt; 을 작업 디렉토리로 사용하기 시작합니다 . &lt;code&gt;Dir&lt;/code&gt; 은 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="65484a01cf9bd6e1a83ae6b606310e1c69ff32cf" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt;, and &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;. The environment of the started process is extended using the environment specifications in &lt;code&gt;Env&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{spawn, Command}&lt;/code&gt; 및 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 에만 유효합니다 . 시작된 프로세스의 환경은 &lt;code&gt;Env&lt;/code&gt; 의 환경 스펙을 사용하여 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="bfc9b2e1dea6a04ba983a9e94d3b648b00ca026f" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt;, where &lt;code&gt;Command&lt;/code&gt; refers to an external program, and for &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{spawn, Command}&lt;/code&gt; 에만 유효합니다 . 여기서 &lt;code&gt;Command&lt;/code&gt; 는 외부 프로그램 및 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 냅니다.</target>
        </trans-unit>
        <trans-unit id="ec0538decd2a683ac3d4fc85b7551d506a0ba696" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; and explicitly specifies the program name argument when running an executable. This can in some circumstances, on some OSs, be desirable. How the program responds to this is highly system-dependent and no specific effect is guaranteed.</source>
          <target state="translated">&lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 에만 유효 하며 실행 파일을 실행할 때 프로그램 이름 인수를 명시 적으로 지정합니다. 상황에 따라 일부 OS에서는 바람직 할 수 있습니다. 프로그램이 이에 응답하는 방식은 시스템에 따라 다르며 특정 효과는 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94d77dba770e4fddcd3e5b235704abc55a41a06f" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; and specifies arguments to the executable. Each argument is specified as a separate string and (on Unix) eventually ends up as one element each in the argument vector. On other platforms, a similar behavior is mimicked.</source>
          <target state="translated">&lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 에만 유효 하며 실행 파일에 인수를 지정합니다. 각 인수는 별도의 문자열로 지정되며 (유닉스에서) 결국 인수 벡터에서 하나의 요소로 끝납니다. 다른 플랫폼에서도 유사한 동작이 모방됩니다.</target>
        </trans-unit>
        <trans-unit id="0a16a27763d86648c52acb4eb9a028a14f39f822" translate="yes" xml:space="preserve">
          <source>Only valid for character devices on Unix. In all other cases, this field is zero.</source>
          <target state="translated">Unix의 문자 장치에만 유효합니다. 다른 모든 경우에는이 필드가 0입니다.</target>
        </trans-unit>
        <trans-unit id="ecb3f031c9ac0eb9d790e14595d3fd9dd2d8d7c2" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt;bchunk/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt;bchunk/2&lt;/a&gt;&lt;/code&gt; 가 사용하는 불투명 연속체 .</target>
        </trans-unit>
        <trans-unit id="58a550d32afdec41a5ce24c62d98873272eb328a" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt; 에서 사용되는 불투명 연속체 .</target>
        </trans-unit>
        <trans-unit id="296b6181394c8bc2ef4aa069b7cdea56b08954fb" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용하여 불투명 연속 &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2dfa868a6d8928ac7bb58be05cada3f714825ced" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#select_reverse-1&quot;&gt;select_reverse/1,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1,3&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1,3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#select_reverse-1&quot;&gt;select_reverse/1,3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1,3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1,3&lt;/a&gt;&lt;/code&gt; 에서 사용되는 불투명 연속체 .</target>
        </trans-unit>
        <trans-unit id="403f4b382799774e589923264bc2680b24377bd7" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; 에서 사용되는 불투명 연속체 .</target>
        </trans-unit>
        <trans-unit id="0fd3a4cc67ebb2e2dcfc37bc089269155adc35e9" translate="yes" xml:space="preserve">
          <source>Opaque data type containing a compiled regular expression. &lt;code&gt;mp()&lt;/code&gt; is guaranteed to be a tuple() having the atom &lt;code&gt;re_pattern&lt;/code&gt; as its first element, to allow for matching in guards. The arity of the tuple or the content of the other fields can change in future Erlang/OTP releases.</source>
          <target state="translated">컴파일 된 정규식을 포함하는 불투명 한 데이터 유형. &lt;code&gt;mp()&lt;/code&gt; 는 첫 번째 요소로 원자 &lt;code&gt;re_pattern&lt;/code&gt; 을 갖는 tuple () 임을 보장하여 가드에서 일치시킬 수 있습니다. 튜플의 arity 또는 다른 필드의 내용은 향후 Erlang / OTP 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23206d19a217e18d8ba3621938088efa39a69154" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a channel inside a connection.</source>
          <target state="translated">연결 내부의 채널을 나타내는 불투명 한 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="10ef7cb1f64bbdc10f27d8dc1ce5e8006717e4e1" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a compiled search pattern. Guaranteed to be a &lt;code&gt;tuple()&lt;/code&gt; to allow programs to distinguish it from non-precompiled search patterns.</source>
          <target state="translated">컴파일 된 검색 패턴을 나타내는 불투명 한 데이터 유형입니다. 프로그램이 사전 컴파일되지 않은 검색 패턴과 구별 할 수 있도록 하는 &lt;code&gt;tuple()&lt;/code&gt; 임을 보장합니다 .</target>
        </trans-unit>
        <trans-unit id="11a89fac909edd47d58426bf26b171a05bcc5425" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a connection between a client and a server (daemon).</source>
          <target state="translated">클라이언트와 서버 (데몬) 간의 연결을 나타내는 불투명 한 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="620b0b7f87aa05da3ff0439d717021eb8fe8e602" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a daemon.</source>
          <target state="translated">데몬을 나타내는 불투명 한 데이터 형식입니다.</target>
        </trans-unit>
        <trans-unit id="3857ec812333e693713ca05fedf452c8c2760e48" translate="yes" xml:space="preserve">
          <source>Opaque reference for a connection to a NETCONF server or a NETCONF session.</source>
          <target state="translated">NETCONF 서버 또는 NETCONF 세션 연결에 대한 불투명 한 참조.</target>
        </trans-unit>
        <trans-unit id="1ad02c5216bfba2278b495045671c8cc585c4d19" translate="yes" xml:space="preserve">
          <source>Opaque send handle whose contents is internal for the send module. May be any term.</source>
          <target state="translated">내용이 보내기 모듈 내부에있는 불투명 한 보내기 핸들. 임의의 용어 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="107ba6e41ccc6092a0776c13b1c83f0f2e14171a" translate="yes" xml:space="preserve">
          <source>Opaque types that define experimental options that are not to be used in products.</source>
          <target state="translated">제품에 사용되지 않는 실험 옵션을 정의하는 불투명 한 유형.</target>
        </trans-unit>
        <trans-unit id="3550457d3cea02f68e91830d6b92589beceb0ac2" translate="yes" xml:space="preserve">
          <source>Open Database Connectivity (ODBC) is a Microsoft standard for accessing relational databases that has become widely used. The ODBC standard provides a c-level application programming interface (API) for database access. It uses Structured Query Language (SQL) as its database access language.</source>
          <target state="translated">ODBC (Open Database Connectivity)는 널리 사용되는 관계형 데이터베이스에 액세스하기위한 Microsoft 표준입니다. ODBC 표준은 데이터베이스 액세스를위한 c 레벨 API (응용 프로그래밍 인터페이스)를 제공합니다. 데이터베이스 액세스 언어로 SQL (Structured Query Language)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8082c8186bf5acfdb929e31ffd3d59546e0c666b" translate="yes" xml:space="preserve">
          <source>Open an SSH connection to a named NETCONF server.</source>
          <target state="translated">명명 된 NETCONF 서버에 대한 SSH 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="ee2771cae64f2d66b96c7d0fdeb3a995d3b00a84" translate="yes" xml:space="preserve">
          <source>Open files and sockets</source>
          <target state="translated">파일 및 소켓 열기</target>
        </trans-unit>
        <trans-unit id="c2f3ad251a3411a0d3096b7d62ceb15282d3c92b" translate="yes" xml:space="preserve">
          <source>Open ports</source>
          <target state="translated">열린 포트</target>
        </trans-unit>
        <trans-unit id="d5d9049df9a69941f4ebda406f0f9058d7b67428" translate="yes" xml:space="preserve">
          <source>Open punctuation</source>
          <target state="translated">구두점 열기</target>
        </trans-unit>
        <trans-unit id="0f83435c5ff89a01a4392cfcdc0fce03d20e7bcf" translate="yes" xml:space="preserve">
          <source>OpenSSH public-key format looks as follows:</source>
          <target state="translated">OpenSSH 공개 키 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="78a8e32789179af6e9a1ec19eccc362f6f09476e" translate="yes" xml:space="preserve">
          <source>OpenSSL -- The opensource toolkit for Secure Socket Layer and Transport Layer Security. Required for building the application &lt;code&gt;crypto&lt;/code&gt;. Further, &lt;code&gt;ssl&lt;/code&gt; and &lt;code&gt;ssh&lt;/code&gt; require a working crypto application and will also be skipped if OpenSSL is missing. The &lt;code&gt;public_key&lt;/code&gt; application is available without &lt;code&gt;crypto&lt;/code&gt;, but the functionality will be very limited.</source>
          <target state="translated">OpenSSL-SSL (Secure Socket Layer) 및 전송 계층 보안을위한 오픈 소스 툴킷. 응용 프로그램 &lt;code&gt;crypto&lt;/code&gt; 를 구축하는 데 필요합니다 . 또한 &lt;code&gt;ssl&lt;/code&gt; 및 &lt;code&gt;ssh&lt;/code&gt; 에는 작동하는 암호화 응용 프로그램이 필요하며 OpenSSL이 없으면 건너 뜁니다. &lt;code&gt;public_key&lt;/code&gt; 응용 프로그램없이 사용할 수 있습니다 &lt;code&gt;crypto&lt;/code&gt; ,하지만 기능은 매우 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="f9ba88f6151c1d4c39311034d5740f6813c1bb3d" translate="yes" xml:space="preserve">
          <source>OpenSSL can be built to provide FIPS 140-2 validated cryptographic services. It is not the OpenSSL application that is validated, but a special software component called the OpenSSL FIPS Object Module. However applications do not use this Object Module directly, but through the regular API of the OpenSSL library.</source>
          <target state="translated">FIPS 140-2 인증 암호화 서비스를 제공하기 위해 OpenSSL을 구축 할 수 있습니다. 검증 된 응용 프로그램은 OpenSSL 응용 프로그램이 아니라 OpenSSL FIPS Object Module이라는 특수 소프트웨어 구성 요소입니다. 그러나 애플리케이션은이 오브젝트 모듈을 직접 사용하지 않고 OpenSSL 라이브러리의 일반 API를 통해 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ec75c958bae528f688b7acd8013d185972516f61" translate="yes" xml:space="preserve">
          <source>OpenSSL exposes an Engine API, which makes it possible to plug in alternative implementations for some or all of the cryptographic operations implemented by OpenSSL. When configured appropriately, OpenSSL calls the engine's implementation of these operations instead of its own.</source>
          <target state="translated">OpenSSL은 엔진 API를 제공하므로 OpenSSL에 의해 구현 된 일부 또는 모든 암호화 작업에 대한 대체 구현을 플러그인 할 수 있습니다. 적절하게 구성되면 OpenSSL은 엔진 대신 이러한 작업의 엔진 구현을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="23dcb6e17a0724721b52791ead27b1179856c026" translate="yes" xml:space="preserve">
          <source>OpenSSL handles these corner cases in FIPS mode, however the Erlang crypto and ssl applications are not prepared for them and therefore you are limited to TLS 1.2 in FIPS mode.</source>
          <target state="translated">OpenSSL은 FIPS 모드에서 이러한 경우를 처리하지만 Erlang 암호화 및 ssl 애플리케이션은이를 준비하지 않으므로 FIPS 모드에서는 TLS 1.2로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="3a24b8124364457504f3d77d3e37c9aa2f092c8b" translate="yes" xml:space="preserve">
          <source>OpenSSL. This is if you want the SSL and crypto applications to compile (and run). There are prebuilt binaries, which you can just download and install, available here:</source>
          <target state="translated">OpenSSL. SSL 및 암호화 응용 프로그램을 컴파일 (및 실행)하려는 경우입니다. 미리 빌드 된 바이너리가 있으며 여기에서 다운로드하여 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc37c058118702102358b15e5a9279ede7fb88f0" translate="yes" xml:space="preserve">
          <source>OpenSource users can ask questions and share experiences on the &lt;a href=&quot;http://www.erlang.org/static/doc/mailinglist.html&quot;&gt; Erlang questions mailing list&lt;/a&gt;.</source>
          <target state="translated">오픈 소스 사용자는 &lt;a href=&quot;http://www.erlang.org/static/doc/mailinglist.html&quot;&gt;Erlang 질문 메일 링리스트&lt;/a&gt; 에서 질문을하고 경험을 공유 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f59aad599af06a50017bc066f13ce93de0675e4" translate="yes" xml:space="preserve">
          <source>Opening a connection to the SUT</source>
          <target state="translated">SUT에 대한 연결 열기</target>
        </trans-unit>
        <trans-unit id="16d19c8e7f51506cd01c5e4f542d05b716cdf852" translate="yes" xml:space="preserve">
          <source>Opening files with option &lt;code&gt;encoding&lt;/code&gt; is convenient when writing or reading text files in a known encoding.</source>
          <target state="translated">알려진 인코딩으로 텍스트 파일을 쓰거나 읽을 때 옵션 &lt;code&gt;encoding&lt;/code&gt; 파일을 여는 것이 편리합니다.</target>
        </trans-unit>
        <trans-unit id="67011158e86d9fe5da95333d965bcbbe99127074" translate="yes" xml:space="preserve">
          <source>Opening parentheses are counted from left to right (starting from 1) to obtain numbers for the capturing subpatterns. For example, if the string &quot;the red king&quot; is matched against the following pattern, the captured substrings are &quot;red king&quot;, &quot;red&quot;, and &quot;king&quot;, and are numbered 1, 2, and 3, respectively:</source>
          <target state="translated">여는 괄호는 왼쪽에서 오른쪽으로 계산되어 (1부터 시작) 캡처 하위 패턴의 숫자를 얻습니다. 예를 들어, 문자열 &quot;red king&quot;이 다음 패턴과 일치하면 캡처 된 하위 문자열은 &quot;red king&quot;, &quot;red&quot;및 &quot;king&quot;이며 각각 1, 2 및 3으로 번호가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="75588bb57f0a2ad5ebe6ca42cc40d8c3b6d3dc26" translate="yes" xml:space="preserve">
          <source>Opening square bracket (only when it can be interpreted as introducing a Posix class name, or for a special compatibility feature; see the next two sections)</source>
          <target state="translated">대괄호 열기 (Posix 클래스 이름을 소개하거나 특수한 호환성 기능으로 해석 될 수있는 경우에만 다음 두 섹션 참조)</target>
        </trans-unit>
        <trans-unit id="0a4914a57f284d13929c087c4e60d213c9577e76" translate="yes" xml:space="preserve">
          <source>Opens (creates) a registry, which initially is empty. To close the registry later, use &lt;code&gt;ei_reg_close()&lt;/code&gt;.</source>
          <target state="translated">처음에는 비어있는 레지스트리를 엽니 다 (만들기). 나중에 레지스트리를 닫으려면 &lt;code&gt;ei_reg_close()&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b46d26782974b469a2ae782f58aa207429f253c" translate="yes" xml:space="preserve">
          <source>Opens a &lt;code&gt;&lt;a href=&quot;#view&quot;&gt;View Module window&lt;/a&gt;&lt;/code&gt;, displaying the contents of the selected module.</source>
          <target state="translated">선택한 모듈의 내용을 표시하는 &lt;code&gt;&lt;a href=&quot;#view&quot;&gt;View Module window&lt;/a&gt;&lt;/code&gt; 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="22a4c7bdc761516d54977e6e3c2f08e31666a769" translate="yes" xml:space="preserve">
          <source>Opens a NETCONF session and exchanges &lt;code&gt;hello&lt;/code&gt; messages.</source>
          <target state="translated">NETCONF 세션을 열고 &lt;code&gt;hello&lt;/code&gt; 메시지를 교환 합니다.</target>
        </trans-unit>
        <trans-unit id="fc2106dbbf5f859efe242b4f2863fc622702b3ed" translate="yes" xml:space="preserve">
          <source>Opens a NETCONF session as a channel on the given SSH connection, and exchanges hello messages with the server.</source>
          <target state="translated">주어진 SSH 연결에서 NETCONF 세션을 채널로 열고 서버와 hello 메시지를 교환합니다.</target>
        </trans-unit>
        <trans-unit id="01cccde2b149248e69a585d60c61c3d13087127c" translate="yes" xml:space="preserve">
          <source>Opens a NETCONF session, but does not send &lt;code&gt;hello&lt;/code&gt;.</source>
          <target state="translated">NETCONF 세션을 열지 만 &lt;code&gt;hello&lt;/code&gt; 를 보내지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e0e8afe49dad7508484506ff701e53d0d8fc26e0" translate="yes" xml:space="preserve">
          <source>Opens a Telnet connection to the specified target host.</source>
          <target state="translated">지정된 대상 호스트에 대한 Telnet 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="863e973e6a31c9261a3ac1a5ee27b4c5d6dfcd10" translate="yes" xml:space="preserve">
          <source>Opens a channel for an SSH session.</source>
          <target state="translated">SSH 세션을위한 채널을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="f4b954e8567f661fe6c4ddf769bdcc65e25fa9df" translate="yes" xml:space="preserve">
          <source>Opens a channel for an SSH session. The channel id returned from this function is the id used as input to the other functions in this module.</source>
          <target state="translated">SSH 세션을위한 채널을 엽니 다. 이 기능에서 반환 된 채널 ID는이 모듈의 다른 기능에 대한 입력으로 사용되는 ID입니다.</target>
        </trans-unit>
        <trans-unit id="84e8a4380a15d0e1019641a8397c044a4caf2ec5" translate="yes" xml:space="preserve">
          <source>Opens a connection to the database. The connection is associated with the process that created it and can only be accessed through it. This function may spawn new processes to handle the connection. These processes will terminate if the process that created the connection dies or if you call disconnect/1.</source>
          <target state="translated">데이터베이스에 대한 연결을 엽니 다. 연결은 연결을 만든 프로세스와 연결되며 연결을 통해서만 액세스 할 수 있습니다. 이 함수는 연결을 처리하기 위해 새로운 프로세스를 생성 할 수 있습니다. 연결을 만든 프로세스가 종료되거나 disconnect / 1을 호출하면 이러한 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="8a2ca3ab2e6a54c904b5fe348aa46db48f2f0c68" translate="yes" xml:space="preserve">
          <source>Opens a detailed information window on the selected process, including the following:</source>
          <target state="translated">다음을 포함하여 선택한 프로세스에 대한 자세한 정보 창을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="f750e93585a93a3a78ed2d040624e4bedee5783b" translate="yes" xml:space="preserve">
          <source>Opens a file for preprocessing.</source>
          <target state="translated">전처리를 위해 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="0dae8080316d196c81e5e5bd698fc2b46c3bd578" translate="yes" xml:space="preserve">
          <source>Opens a file for read or write access.</source>
          <target state="translated">읽기 또는 쓰기 액세스를 위해 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="05853d805e8d0a64be6bd32197c1efe7fc8affff" translate="yes" xml:space="preserve">
          <source>Opens a file on the server and returns a handle, which can be used for reading or writing.</source>
          <target state="translated">서버에서 파일을 열고 읽기 또는 쓰기에 사용할 수있는 핸들을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c8cba523b51510605036808e563faed86bad7a34" translate="yes" xml:space="preserve">
          <source>Opens a handle to a directory on the server. The handle can be used for reading directory contents.</source>
          <target state="translated">서버의 디렉토리에 대한 핸들을 엽니 다. 핸들은 디렉토리 내용을 읽는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="582c61865473eb0cf103ce22b094eb7d48793963" translate="yes" xml:space="preserve">
          <source>Opens a handle to a tar file on the server, associated with &lt;code&gt;ChannelPid&lt;/code&gt;. The handle can be used for remote tar creation and extraction, as defined by the &lt;code&gt;erl_tar:init/3&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;ChannelPid&lt;/code&gt; 와 연관된 서버의 tar 파일에 대한 핸들을 엽니 다 . 핸들은 &lt;code&gt;erl_tar:init/3&lt;/code&gt; 함수에 정의 된대로 원격 tar 작성 및 추출에 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="38a016da939f8a64a311d0439e65d9ca62d7e550" translate="yes" xml:space="preserve">
          <source>Opens a named NETCONF session and exchanges &lt;code&gt;hello&lt;/code&gt; messages.</source>
          <target state="translated">명명 된 NETCONF 세션을 열고 &lt;code&gt;hello&lt;/code&gt; 메시지를 교환 합니다.</target>
        </trans-unit>
        <trans-unit id="6c86f8db1e9c8781949e8303c056c061130288be" translate="yes" xml:space="preserve">
          <source>Opens a named NETCONF session, but does not send &lt;code&gt;hello&lt;/code&gt;.</source>
          <target state="translated">명명 된 NETCONF 세션을 열지 만 &lt;code&gt;hello&lt;/code&gt; 를 보내지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ae78d453fdc1ed67800d13633ccdbf6892076735" translate="yes" xml:space="preserve">
          <source>Opens a table. An empty Dets table is created if no file exists.</source>
          <target state="translated">테이블을 엽니 다. 파일이 없으면 비어있는 Dets 테이블이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="5b10027bd172d07f8eae36a418eb12d0559fcafd" translate="yes" xml:space="preserve">
          <source>Opens a trace port on each node to be traced. By default, trace messages are written to binary files on remote nodes (the binary trace log).</source>
          <target state="translated">추적 할 각 노드에서 추적 포트를 엽니 다. 기본적으로 추적 메시지는 원격 노드의 이진 파일 (이진 추적 로그)에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="6a5ff76be69758b5b422a1d897ebb9c5f931b8de" translate="yes" xml:space="preserve">
          <source>Opens a zip archive, and reads and saves its directory. This means that later reading files from the archive is faster than unzipping files one at a time with &lt;code&gt;&lt;a href=&quot;#unzip-1&quot;&gt;unzip/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Zip 아카이브를 열고 디렉토리를 읽고 저장합니다. 이는 나중에 압축 파일을 읽는 것이 &lt;code&gt;&lt;a href=&quot;#unzip-1&quot;&gt;unzip/1,2&lt;/a&gt;&lt;/code&gt; 로 한 번에 하나씩 파일을 압축 해제 하는 것보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="cfb9d8cc25812a80fcde10dfb14baff5e93d3d89" translate="yes" xml:space="preserve">
          <source>Opens a zlib stream.</source>
          <target state="translated">zlib 스트림을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="cf71532877f9185120e6ff70251b83955022ad68" translate="yes" xml:space="preserve">
          <source>Opens an FTP connection and fetches a file from the remote host.</source>
          <target state="translated">FTP 연결을 열고 원격 호스트에서 파일을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0edbf2d8cf836a0928dd1ee04359d15b3360a7a1" translate="yes" xml:space="preserve">
          <source>Opens an FTP connection and sends a file to the remote host.</source>
          <target state="translated">FTP 연결을 열고 파일을 원격 호스트로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="34a1d5c3e19d27c4c884a326dd68b7ad28a75ae7" translate="yes" xml:space="preserve">
          <source>Opens an FTP connection to the specified node.</source>
          <target state="translated">지정된 노드에 대한 FTP 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="375e952b3e4358b9086c82fb4e035f4c2d220eed" translate="yes" xml:space="preserve">
          <source>Opens an SSH connection to a NETCONF server.</source>
          <target state="translated">NETCONF 서버에 대한 SSH 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="a16d2119745f4d905dfff9790116b88f38df60dd" translate="yes" xml:space="preserve">
          <source>Opens an SSH or SFTP connection using the information associated with &lt;code&gt;KeyOrName&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;KeyOrName&lt;/code&gt; 과 관련된 정보를 사용하여 SSH 또는 SFTP 연결을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="39bf3429a9eb17df337807274369a2a1485631e4" translate="yes" xml:space="preserve">
          <source>Opens an TLS/DTLS connection to &lt;code&gt;Host&lt;/code&gt;, &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Host&lt;/code&gt; , &lt;code&gt;Port&lt;/code&gt; 에 대한 TLS / DTLS 연결을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="62effb5551d902e97d0967400f135108af21c88b" translate="yes" xml:space="preserve">
          <source>Opens an existing resource type and takes over ownership of all its instances. The supplied destructor &lt;code&gt;dtor&lt;/code&gt; is called both for existing instances and new instances not yet created by the calling NIF library.</source>
          <target state="translated">기존 자원 유형을 열고 모든 인스턴스의 소유권을 인수합니다. 제공된 소멸자 &lt;code&gt;dtor&lt;/code&gt; 는 기존 인스턴스와 호출 NIF 라이브러리에 의해 아직 작성되지 않은 새 인스턴스 모두에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9f30c59ec922ffa7f6658907dc759edc40afdb39" translate="yes" xml:space="preserve">
          <source>Opens an existing table. If the table is not properly closed, it is repaired. The returned reference is to be used as the table name. This function is most useful for debugging purposes.</source>
          <target state="translated">기존 테이블을 엽니 다. 테이블이 제대로 닫히지 않으면 복구됩니다. 리턴 된 참조는 테이블 이름으로 사용됩니다. 이 기능은 디버깅 목적으로 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6191fa62fa9a2d5758147014b1cebb180f7936ed" translate="yes" xml:space="preserve">
          <source>Opens an interactive Windows console window for the Erlang shell of the service. Automatically disables the &lt;code&gt;StopAction&lt;/code&gt;. A service started with an interactive console window does not survive logouts. &lt;code&gt;OnFail&lt;/code&gt; actions do not work with debug consoles either.</source>
          <target state="translated">서비스의 Erlang 쉘에 대한 대화식 Windows 콘솔 창을 엽니 다. &lt;code&gt;StopAction&lt;/code&gt; 을 자동으로 비활성화합니다 . 대화식 콘솔 창으로 시작한 서비스는 로그 아웃 후에도 지속되지 않습니다. &lt;code&gt;OnFail&lt;/code&gt; 작업은 디버그 콘솔에서도 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b42e9b24605e4d337c32c2f54025481d238a9f0" translate="yes" xml:space="preserve">
          <source>Opens file &lt;code&gt;File&lt;/code&gt; in the mode determined by &lt;code&gt;Modes&lt;/code&gt;, which can contain one or more of the following options:</source>
          <target state="translated">다음 옵션 중 하나 이상을 포함 할 수있는 &lt;code&gt;Modes&lt;/code&gt; 에 의해 결정된 모드에서 파일 &lt;code&gt;File&lt;/code&gt; 을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="f1f250fc2e30dcf740ba52a6778d1bf170664542" translate="yes" xml:space="preserve">
          <source>Opens log file &lt;code&gt;Filename&lt;/code&gt;. Returns &lt;code&gt;ok&lt;/code&gt; if successful, or &lt;code&gt;{error, allready_have_logfile}&lt;/code&gt; if logging to file is already enabled, or an error tuple if another error occurred (for example, if &lt;code&gt;Filename&lt;/code&gt; cannot be opened). The file is opened with encoding UTF-8.</source>
          <target state="translated">로그 파일 &lt;code&gt;Filename&lt;/code&gt; 을 엽니 다 . 성공한 경우 &lt;code&gt;ok&lt;/code&gt; 를 반환 하거나 &lt;code&gt;{error, allready_have_logfile}&lt;/code&gt; 파일에 로깅이 이미 활성화 된 경우 {error, allready_have_logfile} 또는 다른 오류가 발생한 경우 (예 : &lt;code&gt;Filename&lt;/code&gt; 을 열 수없는 경우) 오류 튜플을 반환 합니다. 파일은 UTF-8 인코딩으로 열립니다.</target>
        </trans-unit>
        <trans-unit id="515b021c218ccf64dc87cfd2e6aafb2c71875e7c" translate="yes" xml:space="preserve">
          <source>Opens the &lt;code&gt;&lt;a href=&quot;#interpret&quot;&gt;Interpret Modules window&lt;/a&gt;&lt;/code&gt;, where new modules to be interpreted can be specified.</source>
          <target state="translated">해석 할 새 모듈을 지정할 수있는 모듈 &lt;code&gt;&lt;a href=&quot;#interpret&quot;&gt;Interpret Modules window&lt;/a&gt;&lt;/code&gt; 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="9b4d52c05a1dfa015184d5b6d02092d14d75b8e3" translate="yes" xml:space="preserve">
          <source>Opens the registry for reading or writing. The current key is the root (&lt;code&gt;HKEY_CLASSES_ROOT&lt;/code&gt;). Flag &lt;code&gt;read&lt;/code&gt; in the mode list can be omitted.</source>
          <target state="translated">읽거나 쓸 레지스트리를 엽니 다. 현재 키는 루트 ( &lt;code&gt;HKEY_CLASSES_ROOT&lt;/code&gt; )입니다. 모드리스트에서 &lt;code&gt;read&lt;/code&gt; 플래그 는 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3844a6955eb1488c222cb350aad910d634debf0b" translate="yes" xml:space="preserve">
          <source>Operating system interface</source>
          <target state="translated">운영 체제 인터페이스</target>
        </trans-unit>
        <trans-unit id="6ba10933377bd765bd39421a74f86a9f5033cd62" translate="yes" xml:space="preserve">
          <source>Operating system-specific functions.</source>
          <target state="translated">운영 체제 별 기능.</target>
        </trans-unit>
        <trans-unit id="430d32076eb256f0fb1db5fd1333254c368ef1ba" translate="yes" xml:space="preserve">
          <source>Operation</source>
          <target state="translated">Operation</target>
        </trans-unit>
        <trans-unit id="3c9639c2c52d47e5befdf848b84975f48bd5f879" translate="yes" xml:space="preserve">
          <source>Operation &lt;code&gt;&lt;a href=&quot;#kill_session-2&quot;&gt;kill_session/2,3&lt;/a&gt;&lt;/code&gt; can be used to force the release of a lock owned by another NETCONF session. How this is achieved by the server side is implementation-specific.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#kill_session-2&quot;&gt;kill_session/2,3&lt;/a&gt;&lt;/code&gt; 조작을 사용하여 다른 NETCONF 세션이 소유 한 잠금을 강제로 해제 할 수 있습니다. 서버 측에서이를 달성하는 방법은 구현별로 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2fd85be02fe70099570593767a6ed02c554cee82" translate="yes" xml:space="preserve">
          <source>Operations on finite sets and relations represented as sets</source>
          <target state="translated">유한 집합 및 집합으로 표현 된 관계에 대한 작업</target>
        </trans-unit>
        <trans-unit id="d721e6bae341c96a244ef5325ee7783da8aa05da" translate="yes" xml:space="preserve">
          <source>Operator precedence in falling priority:</source>
          <target state="translated">우선 순위가 떨어지는 운영자 우선 순위 :</target>
        </trans-unit>
        <trans-unit id="9ac3210fbaf7aa51089439b718a4799d5b27c2af" translate="yes" xml:space="preserve">
          <source>Option (&lt;code&gt;option()&lt;/code&gt;) details:</source>
          <target state="translated">옵션 ( &lt;code&gt;option()&lt;/code&gt; ) 세부 사항 :</target>
        </trans-unit>
        <trans-unit id="7bc4e2bf65691f392e0c6aef8849b96e3503d3f9" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;+d&lt;/code&gt; instructs the emulator to produce only a core dump and no crash dump if an internal error is detected.</source>
          <target state="translated">Option &lt;code&gt;+d&lt;/code&gt; 는 내부 오류가 감지되면 에뮬레이터에 코어 덤프 만 생성하고 크래시 덤프는 생성하지 않도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="617924dbd7f61aaccfafefec23e2e5c27276a861" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;Encoding&lt;/code&gt; is used for selecting which integer lists to be considered as strings. The default is to use the encoding returned by function &lt;code&gt;&lt;a href=&quot;epp#default_encoding-0&quot;&gt;epp:default_encoding/0&lt;/a&gt;&lt;/code&gt;. Value &lt;code&gt;none&lt;/code&gt; means that no integer lists are considered as strings. &lt;code&gt;encoding_func()&lt;/code&gt; is called with one integer of a list at a time; if it returns &lt;code&gt;true&lt;/code&gt; for every integer, the list is considered a string.</source>
          <target state="translated">옵션 &lt;code&gt;Encoding&lt;/code&gt; 은 문자열로 간주 할 정수 목록을 선택하는 데 사용됩니다. 디폴트는 &lt;code&gt;&lt;a href=&quot;epp#default_encoding-0&quot;&gt;epp:default_encoding/0&lt;/a&gt;&lt;/code&gt; 함수가 리턴 한 인코딩을 사용하는 것 입니다. 값 &lt;code&gt;none&lt;/code&gt; 은 정수 목록이 문자열로 간주되지 않음을 의미합니다. &lt;code&gt;encoding_func()&lt;/code&gt; 는 한 번에 하나의 정수 목록으로 호출됩니다. 모든 정수에 대해 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 목록이 문자열로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="03b58ec642c1d6975a7cca9e9e0680f47eecc590" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;Format&lt;/code&gt; determines the function that is applied to binaries to create the terms to be sorted. Defaults to &lt;code&gt;binary_term&lt;/code&gt;, which is equivalent to &lt;code&gt;fun&amp;nbsp;binary_to_term/1&lt;/code&gt;. Value &lt;code&gt;binary&lt;/code&gt; is equivalent to &lt;code&gt;fun(X) -&amp;gt; X end&lt;/code&gt;, which means that the binaries are sorted as they are. This is the fastest format. If &lt;code&gt;Format&lt;/code&gt; is &lt;code&gt;term&lt;/code&gt;, &lt;code&gt;io:read/2&lt;/code&gt; is called to read terms. In that case, only the default value of option &lt;code&gt;header&lt;/code&gt; is allowed.</source>
          <target state="translated">옵션 &lt;code&gt;Format&lt;/code&gt; 은 정렬 할 용어를 만들기 위해 이진에 적용되는 기능을 결정합니다. 기본적으로 &lt;code&gt;binary_term&lt;/code&gt; 이며 &lt;code&gt;fun&amp;nbsp;binary_to_term/1&lt;/code&gt; 과 같습니다 . &lt;code&gt;binary&lt;/code&gt; 값 은 &lt;code&gt;fun(X) -&amp;gt; X end&lt;/code&gt; 와 같습니다. 즉, 이진은 그대로 정렬됩니다. 가장 빠른 형식입니다. 경우 &lt;code&gt;Format&lt;/code&gt; 인 &lt;code&gt;term&lt;/code&gt; , &lt;code&gt;io:read/2&lt;/code&gt; 약관을 읽어하기 위해 호출됩니다. 이 경우 옵션 &lt;code&gt;header&lt;/code&gt; 의 기본값 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="515640376a1e84c5e88279e98275326333b1e883" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;Line&lt;/code&gt; is the line to be assigned to each node of &lt;code&gt;AbsTerm&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;Line&lt;/code&gt; 은 &lt;code&gt;AbsTerm&lt;/code&gt; 의 각 노드에 할당 될 라인 입니다.</target>
        </trans-unit>
        <trans-unit id="ba8fe57baa6137f1e318cb3833968d8989a57f43" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;accept&lt;/code&gt; specifies remote addresses for a listening transport and is not valid for a connecting transport. If specified, a remote address that does not match one of the specified addresses causes the association to be aborted. Multiple &lt;code&gt;accept&lt;/code&gt; options can be specified. A string-valued &lt;code&gt;Match&lt;/code&gt; that does not parse as an address is interpreted as a regular expression.</source>
          <target state="translated">&lt;code&gt;accept&lt;/code&gt; 옵션 은 수신 전송에 대한 원격 주소를 지정하며 연결 ​​전송에 유효하지 않습니다. 지정된 경우 지정된 주소 중 하나와 일치하지 않는 원격 주소로 인해 연결이 중단됩니다. 여러 &lt;code&gt;accept&lt;/code&gt; 옵션을 지정할 수 있습니다. 주소로 구문 분석하지 않는 문자열 값 &lt;code&gt;Match&lt;/code&gt; 는 정규식으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="37bd8dc1b650be1a6635cb23b4502d2226d11576" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;accept&lt;/code&gt; specifies remote addresses for a listening transport and is not valid for a connecting transport. If specified, a remote address that does not match one of the specified addresses causes the connection to be aborted. Multiple &lt;code&gt;accept&lt;/code&gt; options can be specified. A string-valued &lt;code&gt;Match&lt;/code&gt; that does not parse as an address is interpreted as a regular expression.</source>
          <target state="translated">&lt;code&gt;accept&lt;/code&gt; 옵션 은 수신 전송에 대한 원격 주소를 지정하며 연결 ​​전송에 유효하지 않습니다. 지정된 경우 지정된 주소 중 하나와 일치하지 않는 원격 주소로 인해 연결이 중단됩니다. 여러 &lt;code&gt;accept&lt;/code&gt; 옵션을 지정할 수 있습니다. 주소로 구문 분석하지 않는 문자열 값 &lt;code&gt;Match&lt;/code&gt; 는 정규식으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="1f55894395584bb9a3e02eafbec27ef2e407d6b9" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;allow_passive_connect&lt;/code&gt; is used internally and is seldom needed in applications where the network topology and the Kernel options in effect are known in advance.</source>
          <target state="translated">&lt;code&gt;allow_passive_connect&lt;/code&gt; 옵션 은 내부적으로 사용되며 네트워크 토폴로지와 커널 옵션이 미리 알려진 응용 프로그램에는 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a76c912018b3dd2b854bd85ee5b0c4b94ebb022" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;c&lt;/code&gt; makes &lt;code&gt;Ctrl-C&lt;/code&gt; interrupt the current shell instead of invoking the emulator break handler. Option &lt;code&gt;d&lt;/code&gt; (same as specifying &lt;code&gt;+B&lt;/code&gt; without an extra option) disables the break handler. Option &lt;code&gt;i&lt;/code&gt; makes the emulator ignore any break signal.</source>
          <target state="translated">옵션 &lt;code&gt;c&lt;/code&gt; 는 에뮬레이터 브레이크 핸들러를 호출하는 대신 &lt;code&gt;Ctrl-C&lt;/code&gt; 가 현재 쉘을 인터럽트하도록합니다. 옵션 &lt;code&gt;d&lt;/code&gt; ( 추가 옵션없이 &lt;code&gt;+B&lt;/code&gt; 를 지정하는 것과 동일 )는 중단 처리기를 비활성화합니다. 옵션 &lt;code&gt;i&lt;/code&gt; 는 에뮬레이터가 브레이크 신호를 무시하게합니다.</target>
        </trans-unit>
        <trans-unit id="326d67c6dd06e800f8ccc7205a53b4bad41af409" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;cache&lt;/code&gt; has no effect if it is known that the QLC is to be evaluated at most once. This is always true for the top-most QLC and also for the list expression of the first generator in a list of qualifiers. Notice that in the presence of side effects in filters or callback functions, the answers to QLCs can be affected by option &lt;code&gt;cache&lt;/code&gt;.</source>
          <target state="translated">QLC가 최대 한 번 평가되는 것으로 알려진 경우 옵션 &lt;code&gt;cache&lt;/code&gt; 는 적용되지 않습니다. 이는 최상위 QLC와 규정 자 목록에서 첫 번째 생성기의 목록 표현식에도 항상 해당됩니다. 필터 또는 콜백 함수에 부작용이있는 경우 QLC에 대한 응답은 옵션 &lt;code&gt;cache&lt;/code&gt; 영향을받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7d8de2a211bf879bd6b340617eed0c81c43b5ad" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;cache_all&lt;/code&gt; can be set to &lt;code&gt;ets&lt;/code&gt; or &lt;code&gt;list&lt;/code&gt; when evaluating a query. It adds a &lt;code&gt;cache&lt;/code&gt; or &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; option to every list expression except QLC tables and lists on all levels of the query. This can be used for testing if caching would improve efficiency at all. If the answer is yes, further testing is needed to pinpoint the generators that are to be cached.</source>
          <target state="translated">쿼리를 평가할 때 &lt;code&gt;cache_all&lt;/code&gt; 옵션 을 &lt;code&gt;ets&lt;/code&gt; 또는 &lt;code&gt;list&lt;/code&gt; 로 설정할 수 있습니다 . 그것은 추가 &lt;code&gt;cache&lt;/code&gt; 또는 &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; 쿼리의 모든 수준에 QLC 테이블 및 목록을 제외한 모든 목록 발현에 옵션을 선택합니다. 캐싱이 효율성을 향상시키는 지 여부를 테스트하는 데 사용할 수 있습니다. 대답이 예인 경우, 캐시 할 생성기를 정확히 찾아 내기 위해 추가 테스트가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8f4c8cddaf80a90f873230e5b6a5e7a3ad8af338" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;compile_source&lt;/code&gt; only affects the result if the escript contains &lt;code&gt;source&lt;/code&gt; code. In this case the Erlang code is automatically compiled and &lt;code&gt;{source, BeamCode}&lt;/code&gt; is returned instead of &lt;code&gt;{source, SourceCode}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;compile_source&lt;/code&gt; 옵션 은 escript에 &lt;code&gt;source&lt;/code&gt; 코드 가 포함 된 경우에만 결과에 영향을줍니다 . 이 경우 Erlang 코드가 자동으로 컴파일되고 &lt;code&gt;{source, SourceCode}&lt;/code&gt; 대신 &lt;code&gt;{source, BeamCode}&lt;/code&gt; 가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="4ac2c8d2a46b7ed6d2b62afd37f0558c267adb74" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;debug_info&lt;/code&gt; can be specified to the Compiler (see &lt;code&gt;compile(3)&lt;/code&gt;) to have debug information, such as &lt;code&gt;Erlang Abstract Format&lt;/code&gt;, stored in the &lt;code&gt;debug_info&lt;/code&gt; chunk. Tools such as Debugger and Xref require the debug information to be included.</source>
          <target state="translated">&lt;code&gt;Erlang Abstract Format&lt;/code&gt; 과 같은 디버그 정보 가 &lt;code&gt;debug_info&lt;/code&gt; 청크에 저장 되도록 &lt;code&gt;debug_info&lt;/code&gt; 옵션을 컴파일러에 지정할 수 있습니다 ( &lt;code&gt;compile(3)&lt;/code&gt; 참조 ) . 디버거 및 외부 참조와 같은 도구에는 디버그 정보가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="bceef863ec9665aec5cef62d9d27d0ce6ab12ecb" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;debug_info&lt;/code&gt; causes &lt;strong&gt;debug information&lt;/strong&gt; or &lt;strong&gt;abstract code&lt;/strong&gt; to be added to the &lt;code&gt;.beam&lt;/code&gt; file. This increases the file size and makes it possible to reconstruct the source code. It is therefore recommended not to include debug information in code aimed for target systems.</source>
          <target state="translated">&lt;code&gt;debug_info&lt;/code&gt; 옵션을 사용 하면 &lt;strong&gt;디버그 정보&lt;/strong&gt; 또는 &lt;strong&gt;추상 코드&lt;/strong&gt; 가 &lt;code&gt;.beam&lt;/code&gt; 파일에 추가 됩니다. 파일 크기가 커지고 소스 코드를 재구성 할 수 있습니다. 따라서 대상 시스템을 대상으로하는 코드에 디버그 정보를 포함하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="769f8dc6e95ee290900e92345b3ad7fa81275ab3" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;extended_info&lt;/code&gt; specifies what extra information is written to the table dump:</source>
          <target state="translated">&lt;code&gt;extended_info&lt;/code&gt; 옵션 은 테이블 덤프에 기록되는 추가 정보를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="7392a715b1ab5247b835edd88a64118c85b3ed71" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;format&lt;/code&gt; also determines what is written to the sorted output file: if &lt;code&gt;Format&lt;/code&gt; is &lt;code&gt;term&lt;/code&gt;, then &lt;code&gt;io:format/3&lt;/code&gt; is called to write each term, otherwise the binary prefixed by a header is written. Notice that the binary written is the same binary that was read; the results of applying function &lt;code&gt;Format&lt;/code&gt; are thrown away when the terms have been sorted. Reading and writing terms using the &lt;code&gt;io&lt;/code&gt; module is much slower than reading and writing binaries.</source>
          <target state="translated">옵션 &lt;code&gt;format&lt;/code&gt; 은 정렬 된 출력 파일에 기록되는 내용도 결정합니다. &lt;code&gt;Format&lt;/code&gt; 이 &lt;code&gt;term&lt;/code&gt; 인 경우 &lt;code&gt;io:format/3&lt;/code&gt; 이 호출되어 각 용어를 쓰며, 그렇지 않으면 머리글이 앞에 붙은 이진이 쓰여집니다. 작성된 바이너리는 읽은 바이너리와 동일합니다. 용어가 정렬되면 함수 &lt;code&gt;Format&lt;/code&gt; 적용 결과가 삭제 됩니다. &lt;code&gt;io&lt;/code&gt; 모듈을 사용하여 단어를 읽고 쓰는 것이 바이너리를 읽고 쓰는 것보다 훨씬 느립니다.</target>
        </trans-unit>
        <trans-unit id="c6b86819a94a42b6a35f9a5c83dd920e56cafa28" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;fragment_timer&lt;/code&gt; specifies the timeout, in milliseconds, of a timer used to flush messages from the incoming byte stream even if the number of bytes indicated in the Message Length field of its Diameter Header have not yet been accumulated: such a message is received over the transport interface after two successive timeouts without the reception of additional bytes. Defaults to 1000.</source>
          <target state="translated">&lt;code&gt;fragment_timer&lt;/code&gt; 옵션 은 지름 헤더의 메시지 길이 필드에 표시된 바이트 수가 아직 누적되지 않은 경우에도 수신 바이트 스트림에서 메시지를 플러시하는 데 사용되는 타이머의 시간 초과 (밀리 초)를 지정합니다. 이러한 메시지는 추가 바이트를 수신하지 않고 두 번의 연속 시간 초과 후 전송 인터페이스. 기본값은 1000입니다.</target>
        </trans-unit>
        <trans-unit id="ed047187b33ff5a36de976c2d7f174208794b18a" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;fullsweep_after&lt;/code&gt; makes it possible to specify the maximum number of generational collections before forcing a fullsweep, even if there is room on the old heap. Setting the number to zero disables the general collection algorithm, that is, all live data is copied at every garbage collection.</source>
          <target state="translated">&lt;code&gt;fullsweep_after&lt;/code&gt; 옵션 을 사용하면 이전 힙에 공간이 있어도 전체 스위프를 수행하기 전에 최대 세대 콜렉션 수를 지정할 수 있습니다. 숫자를 0으로 설정하면 일반 수집 알고리즘이 비활성화됩니다. 즉, 모든 라이브 데이터가 모든 가비지 수집에서 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="ecaf25cf5459dfb31ebf85a2facfaa8a1ab4324e" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;hosts&lt;/code&gt; has no effect if &lt;code&gt;log_type&lt;/code&gt; is set to &lt;code&gt;html&lt;/code&gt; or &lt;code&gt;silent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;log_type&lt;/code&gt; 이 &lt;code&gt;html&lt;/code&gt; 또는 &lt;code&gt;silent&lt;/code&gt; 로 설정된 경우 옵션 &lt;code&gt;hosts&lt;/code&gt; 는 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="64143a1b2e482aa0e161fd7b97567d3f14883e09" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;in_comment_only&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; by default, which is correct for Erlang source files. If set to &lt;code&gt;false&lt;/code&gt;, the encoding string does not necessarily have to occur in a comment.</source>
          <target state="translated">&lt;code&gt;in_comment_only&lt;/code&gt; 옵션 은 기본적으로 &lt;code&gt;true&lt;/code&gt; 이며 Erlang 소스 파일에 적합합니다. &lt;code&gt;false&lt;/code&gt; 로 설정 되면 인코딩 문자열이 주석에서 반드시 발생할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ebc5aecdab80e23de01ab20e75171559f54d5713" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;inet6&lt;/code&gt; has no effect on this function. You probably want to use &lt;code&gt;Type = a | aaaa&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;inet6&lt;/code&gt; 옵션 은이 기능에 영향을 미치지 않습니다. 아마도 &lt;code&gt;Type = a | aaaa&lt;/code&gt; 대신에.</target>
        </trans-unit>
        <trans-unit id="8ca5f10fb139927f4989778fe340ba3f7bdbce64" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;ipv6_host_with_bracket&lt;/code&gt; deals with how to parse IPv6 addresses. For details, see argument &lt;code&gt;Options&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;#request-4&quot;&gt;request/[4,5]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;ipv6_host_with_bracket&lt;/code&gt; 은 IPv6 주소를 구문 분석하는 방법을 다룹니다. 자세한 내용 은 &lt;code&gt;&lt;a href=&quot;#request-4&quot;&gt;request/[4,5]&lt;/a&gt;&lt;/code&gt; 인수 &lt;code&gt;Options&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29e3299985763e8c1fce58b82fc31709b15fd60b" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;join&lt;/code&gt; can be used to force the &lt;code&gt;qlc&lt;/code&gt; module to use a certain join method. For the rest of this section it is assumed that the excessively slow join method called &quot;nested loop&quot; has been chosen:</source>
          <target state="translated">&lt;code&gt;qlc&lt;/code&gt; 모듈이 특정 결합 방법을 사용 하도록 옵션 &lt;code&gt;join&lt;/code&gt; 사용할 수 있습니다 . 이 섹션의 나머지 부분에서는 &quot;중첩 루프&quot;라는 과도하게 느린 조인 방법이 선택되었다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="895c90440d351c3b981bbc05eca735daa09f36b0" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;join&lt;/code&gt; does not imply that the test terms are merged, only that all tests are executed in one single test run.</source>
          <target state="translated">옵션 &lt;code&gt;join&lt;/code&gt; 은 테스트 용어가 병합됨을 의미하지 않으며 모든 테스트가 단일 테스트 실행으로 실행된다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="176adb220c5fcd1ac1d87552301af2b1ded87f73" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;line_length&lt;/code&gt; also applies to &lt;code&gt;http*&lt;/code&gt; packet types as an alias for option &lt;code&gt;packet_size&lt;/code&gt; if &lt;code&gt;packet_size&lt;/code&gt; itself is not set. This use is only intended for backward compatibility.</source>
          <target state="translated">옵션 &lt;code&gt;line_length&lt;/code&gt; 는 또한 적용 &lt;code&gt;http*&lt;/code&gt; 옵션에 대한 별칭으로 패킷 유형 &lt;code&gt;packet_size&lt;/code&gt; 경우 &lt;code&gt;packet_size&lt;/code&gt; 자체가 설정되어 있지 않습니다. 이 사용은 이전 버전과의 호환성을 위해서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ab41e9f6eb5eab4065b30a808546e5a4a2b51e9" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;message_cb&lt;/code&gt; specifies a callback that is invoked on incoming and outgoing messages, that can be used to implement flow control. It is applied to two arguments: an atom indicating the reason for the callback (&lt;code&gt;send&lt;/code&gt;, &lt;code&gt;recv&lt;/code&gt;, or &lt;code&gt;ack&lt;/code&gt; after a completed send), and the message in question (binary() on &lt;code&gt;recv&lt;/code&gt;, binary() or diameter_packet record on &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;ack&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt; on &lt;code&gt;ack&lt;/code&gt; when an incoming request has been discarded). It should return a list of actions and a new callback as tail; eg. &lt;code&gt;[fun cb/3, State]&lt;/code&gt;. Valid actions are the atoms &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;recv&lt;/code&gt;, to cause a following message-valued action to be sent/received, a message to send/receive (binary() or diameter_packet record), or a boolean() to enable/disable reading on the socket. More than one &lt;code&gt;send&lt;/code&gt;/&lt;code&gt;recv&lt;/code&gt;/message sequence can be returned from the same callback, and an initial &lt;code&gt;send&lt;/code&gt;/&lt;code&gt;recv&lt;/code&gt; can be omitted if the same as the value passed as the callback's first argument. Reading is initially enabled, and returning &lt;code&gt;false&lt;/code&gt; does not imply there cannot be subsequent &lt;code&gt;recv&lt;/code&gt; callbacks since messages may already have been read. An empty tail is equivalent to the prevailing callback. Defaults to a callback equivalent to &lt;code&gt;fun(ack, _) -&amp;gt; []; (_, Msg) -&amp;gt; [Msg] end&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;message_cb&lt;/code&gt; 옵션 은 플로우 제어를 구현하는 데 사용할 수있는 수신 및 발신 메시지에서 호출되는 콜백을 지정합니다. 콜백의 이유를 나타내는 아톰 ( &lt;code&gt;send&lt;/code&gt; , &lt;code&gt;recv&lt;/code&gt; 또는 send 완료 후 &lt;code&gt;ack&lt;/code&gt; )과 해당 메시지 ( &lt;code&gt;recv&lt;/code&gt; , binary ()의 binary (), &lt;code&gt;send&lt;/code&gt; 또는 &lt;code&gt;ack&lt;/code&gt; 의 diameter_packet 레코드)에 적용됩니다. 또는 &lt;code&gt;false&lt;/code&gt; 에 &lt;code&gt;ack&lt;/code&gt; 수신 요청)가 폐기되었을 때. 액션 목록과 새로운 콜백을 테일로 반환해야합니다. 예. &lt;code&gt;[fun cb/3, State]&lt;/code&gt; . 유효한 조치는 원자 &lt;code&gt;send&lt;/code&gt; 또는 &lt;code&gt;recv&lt;/code&gt; 다음의 메시지 값 동작을 보내거나 받으려면, 소켓에서 읽기를 활성화 / 비활성화하는 보내기 / 받기 (binary () 또는 diameter_packet 레코드) 또는 boolean () 메시지를 보내십시오. 동일한 콜백에서 둘 이상의 &lt;code&gt;send&lt;/code&gt; / &lt;code&gt;recv&lt;/code&gt; / message 시퀀스를 리턴 할 수 있으며 콜백의 첫 번째 인수로 전달 된 값과 동일한 경우 초기 &lt;code&gt;send&lt;/code&gt; / &lt;code&gt;recv&lt;/code&gt; 를 생략 할 수 있습니다. 읽기는 처음에 활성화되어 있으며 &lt;code&gt;false&lt;/code&gt; 를 반환 한다고해서 메시지를 이미 읽었을 수 있으므로 이후의 &lt;code&gt;recv&lt;/code&gt; 콜백 이있을 수 없습니다 . 빈 꼬리는 일반적인 콜백과 같습니다. 기본적으로 &lt;code&gt;fun(ack, _) -&amp;gt; []; (_, Msg) -&amp;gt; [Msg] end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8d5b9882df46cf953f258565ab460a21016ddc5" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;monitor&lt;/code&gt; is not supported by &lt;code&gt;spawn_opt/5&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;spawn_opt/5&lt;/code&gt; 는 옵션 &lt;code&gt;monitor&lt;/code&gt; 를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="058fcf7970e7469cb0bc642aad1ff0a1a179cc45" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;multicast_ttl&lt;/code&gt; changes the time-to-live (TTL) for outgoing multicast datagrams to control the scope of the multicasts.</source>
          <target state="translated">&lt;code&gt;multicast_ttl&lt;/code&gt; 옵션 은 발신 멀티 캐스트 데이터 그램에 대한 TTL (Time-to-Live)을 변경하여 멀티 캐스트 범위를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="369ac162beffd61017f1f26b4498fc999c7935c0" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;packet&lt;/code&gt; determines how/if an incoming message is packaged into a diameter_packet record. If &lt;code&gt;false&lt;/code&gt; then messages are received as binary(). If &lt;code&gt;true&lt;/code&gt; then as a record with the binary() message in the &lt;code&gt;bin&lt;/code&gt; field and a &lt;code&gt;{stream, Id}&lt;/code&gt; tuple in the &lt;code&gt;transport_data&lt;/code&gt; field, where &lt;code&gt;Id&lt;/code&gt; is the identifier of the inbound stream the message was received on. If &lt;code&gt;raw&lt;/code&gt; then as a record with the received ancillary sctp_sndrcvinfo record in the &lt;code&gt;transport_data&lt;/code&gt; field. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;packet&lt;/code&gt; 은 들어오는 메시지가 diameter_packet 레코드로 패키지되는 방법 / 경우를 결정합니다. 경우 &lt;code&gt;false&lt;/code&gt; 다음 메시지를 바이너리로 수신 (). &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;bin&lt;/code&gt; 필드 의 binary () 메시지 와 &lt;code&gt;transport_data&lt;/code&gt; 필드 의 &lt;code&gt;{stream, Id}&lt;/code&gt; 튜플이 있는 레코드로 , 여기서 &lt;code&gt;Id&lt;/code&gt; 는 메시지가 수신 된 인바운드 스트림의 ID입니다. 만약 &lt;code&gt;raw&lt;/code&gt; 에서 수신 보조 sctp_sndrcvinfo 레코드와 같이 레코드 다음 &lt;code&gt;transport_data&lt;/code&gt; 의 필드. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0baa94c523937f7abe156cc0676d6a21aa0601f3" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;pending_driver&lt;/code&gt; is of little use, but is present for completeness, as it is well defined which reload options that can give rise to which delays. However, it can be a good idea to use the same &lt;code&gt;MonitorOption&lt;/code&gt; as the &lt;code&gt;ReloadOption&lt;/code&gt;, if present.</source>
          <target state="translated">&lt;code&gt;pending_driver&lt;/code&gt; 옵션 은 거의 사용되지 않지만 어느 지연을 야기 할 수있는 재로드 옵션이 잘 정의되어 있으므로 완전성을 나타냅니다. 그러나 같은 사용하는 좋은 아이디어가 될 수 &lt;code&gt;MonitorOption&lt;/code&gt; 을 은 AS &lt;code&gt;ReloadOption&lt;/code&gt; (있는 경우).</target>
        </trans-unit>
        <trans-unit id="f5cff995931880f38d32793bedddc8696fd39abc" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;persistent&lt;/code&gt; can be set to &lt;code&gt;true&lt;/code&gt; to guarantee that parameters set with &lt;code&gt;set_env/4&lt;/code&gt; are not overridden by those defined in the application resource file on load. This means that persistent values will stick after the application is loaded and also on application reload.</source>
          <target state="translated">&lt;code&gt;set_env/4&lt;/code&gt; 로 설정된 매개 변수 가로드시 응용 프로그램 자원 파일에 정의 된 매개 변수로 대체되지 않도록 옵션 &lt;code&gt;persistent&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정할 수 있습니다 . 이는 애플리케이션이로드 된 후 및 애플리케이션을 다시로드 할 때 지속적 값이 유지됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9c0c34736e937a0d6bddb3baef2d644165d26b6e" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;progress&lt;/code&gt; is intended to be used by applications that want to create some type of progress report, such as a progress bar in a GUI. Default for the progress option is &lt;code&gt;ignore&lt;/code&gt;, that is, the option is not used. When the progress option is specified, the following happens when &lt;code&gt;ftp:send/[3,4]&lt;/code&gt; or &lt;code&gt;ftp:recv/[3,4]&lt;/code&gt; are called:</source>
          <target state="translated">옵션 &lt;code&gt;progress&lt;/code&gt; 은 GUI의 진행률 표시 줄과 같은 일부 유형의 진행률 보고서를 생성하려는 응용 프로그램에서 사용하기위한 것입니다. progress 옵션의 기본값은 &lt;code&gt;ignore&lt;/code&gt; 입니다 . 즉, 옵션이 사용되지 않습니다. progress 옵션이 지정되면 &lt;code&gt;ftp:send/[3,4]&lt;/code&gt; 또는 &lt;code&gt;ftp:recv/[3,4]&lt;/code&gt; 가 호출 될 때 다음이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="121fc2ac086a7c8d8d3e29d994b8f84bb924c24b" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;read_concurrency&lt;/code&gt; can be combined with option &lt;code&gt;&lt;a href=&quot;#new_2_write_concurrency&quot;&gt;write_concurrency&lt;/a&gt;&lt;/code&gt;. You typically want to combine these when large concurrent read bursts and large concurrent write bursts are common.</source>
          <target state="translated">옵션 &lt;code&gt;read_concurrency&lt;/code&gt; 는 옵션과 결합 될 수 &lt;code&gt;&lt;a href=&quot;#new_2_write_concurrency&quot;&gt;write_concurrency&lt;/a&gt;&lt;/code&gt; . 일반적으로 큰 동시 읽기 버스트와 큰 동시 쓰기 버스트가 공통 인 경우 이들을 결합하려고합니다.</target>
        </trans-unit>
        <trans-unit id="ce25f3241dc3da9e62005bbb6632271b6187acc5" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;repair&lt;/code&gt; is ignored if the table is already open.</source>
          <target state="translated">테이블이 이미 열려 있으면 옵션 &lt;code&gt;repair&lt;/code&gt; 가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="cebc9a26a2692e09f8edba6efb06adb14bf3202b" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;report_errors&lt;/code&gt; adds the possibility that an error tuple is returned. The tuple either indicates a matching error (&lt;code&gt;match_limit&lt;/code&gt; or &lt;code&gt;match_limit_recursion&lt;/code&gt;), or a compilation error, where the error tuple has the format &lt;code&gt;{error, {compile, CompileErr}}&lt;/code&gt;. Notice that if option &lt;code&gt;report_errors&lt;/code&gt; is not specified, the function never returns error tuples, but reports compilation errors as a &lt;code&gt;badarg&lt;/code&gt; exception and failed matches because of exceeded match limits simply as &lt;code&gt;nomatch&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;report_errors&lt;/code&gt; 옵션 은 오류 튜플이 반환 될 가능성을 추가합니다. 튜플은 일치하는 오류 ( &lt;code&gt;match_limit&lt;/code&gt; 또는 &lt;code&gt;match_limit_recursion&lt;/code&gt; ) 또는 오류 튜플의 형식이 &lt;code&gt;{error, {compile, CompileErr}}&lt;/code&gt; . &lt;code&gt;report_errors&lt;/code&gt; 옵션을 지정 하지 않으면 이 함수는 오류 튜플을 반환하지 않지만 컴파일 오류를 &lt;code&gt;badarg&lt;/code&gt; 예외 로보고 하고 일치 한계를 단순히 &lt;code&gt;nomatch&lt;/code&gt; 로 초과했기 때문에 일치하지 않은 것으로 보고 합니다.</target>
        </trans-unit>
        <trans-unit id="4fc492ec1e8bbd2f982156bf23c1f5fcad8e8282" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;sender&lt;/code&gt; specifies whether or not to use a dedicated process for sending outgoing messages, which avoids the possibility of send blocking reception. Defaults to &lt;code&gt;false&lt;/code&gt;. If set to &lt;code&gt;true&lt;/code&gt; then a &lt;code&gt;message_cb&lt;/code&gt; that avoids the possibility of messages being queued in the sender process without bound should be configured.</source>
          <target state="translated">&lt;code&gt;sender&lt;/code&gt; 옵션은 발신 메시지 전송을위한 전용 프로세스를 사용할지 여부를 지정하여 송신 차단 수신 가능성을 방지합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. &lt;code&gt;true&lt;/code&gt; 로 설정 되면 송신자 프로세스에서 메시지가 바인드되지 않고 대기 할 가능성을 피하는 &lt;code&gt;message_cb&lt;/code&gt; 를 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="50b59aee750b8ace41d580c775edcd5cf8326a92" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;ssl_options&lt;/code&gt; must be specified for a transport that should support TLS: a value of &lt;code&gt;true&lt;/code&gt; results in a TLS handshake immediately upon connection establishment while &lt;code&gt;list()&lt;/code&gt; specifies options to be passed to &lt;code&gt;ssl:connect/2&lt;/code&gt; or &lt;code&gt;ssl:ssl_accept/2&lt;/code&gt; after capabilities exchange if TLS is negotiated.</source>
          <target state="translated">TLS를 지원해야하는 전송에 옵션 &lt;code&gt;ssl_options&lt;/code&gt; 를 지정해야합니다. &lt;code&gt;true&lt;/code&gt; 값은 연결 설정 즉시 TLS 핸드 셰이크를 발생시키는 반면 &lt;code&gt;list()&lt;/code&gt; 기능 교환 후 &lt;code&gt;ssl:connect/2&lt;/code&gt; 또는 &lt;code&gt;ssl:ssl_accept/2&lt;/code&gt; 에 전달 될 옵션을 지정 합니다. TLS가 협상 된 경우</target>
        </trans-unit>
        <trans-unit id="eb0b2c00845747ebfd6a57dac944c8489e34fe1d" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;timeout&lt;/code&gt; (milliseconds) is used when setting up the SSH connection and when waiting for the &lt;code&gt;hello&lt;/code&gt; message from the server. It is not used for any other purposes during the lifetime of the connection.</source>
          <target state="translated">SSH 연결을 설정 하고 서버에서 &lt;code&gt;hello&lt;/code&gt; 메시지를 기다릴 때 옵션 &lt;code&gt;timeout&lt;/code&gt; (밀리 초)가 사용됩니다 . 연결 수명 동안 다른 용도로는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="afc7cede7fbac62c14c694ddc0b6eec6bf4a0ae3" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;timeout&lt;/code&gt; (milliseconds) is used when setting up the SSH connection. It is not used for any other purposes during the lifetime of the connection.</source>
          <target state="translated">SSH 연결을 설정할 때 옵션 &lt;code&gt;timeout&lt;/code&gt; (밀리 초)가 사용됩니다. 연결 수명 동안 다른 용도로는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33648c8e4866da798d09c425a4d8d5d74a5e0058" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;timeout&lt;/code&gt; specifies how long the client must wait for prompt. If the time expires, the function returns &lt;code&gt;{error,timeout}&lt;/code&gt;. For information about the default value for the command timeout, see the &lt;code&gt;&lt;a href=&quot;#Default_values&quot;&gt;list of default values&lt;/a&gt;&lt;/code&gt; in the beginning of this module.</source>
          <target state="translated">옵션 &lt;code&gt;timeout&lt;/code&gt; 는 클라이언트가 프롬프트를 기다려야하는 시간을 지정합니다. 시간이 만료되면 함수는 &lt;code&gt;{error,timeout}&lt;/code&gt; 을 반환합니다 . 명령 시간 종료 기본값에 대한 정보 는이 모듈의 시작 부분에있는 &lt;code&gt;&lt;a href=&quot;#Default_values&quot;&gt;list of default values&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c0719ab2fd2367d9658fdeb70a32aaa618f2e49" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;unicode&lt;/code&gt; is an alias for &lt;code&gt;utf8&lt;/code&gt;, as this is the preferred encoding for Unicode characters in binaries. &lt;code&gt;utf16&lt;/code&gt; is an alias for &lt;code&gt;{utf16,big}&lt;/code&gt; and &lt;code&gt;utf32&lt;/code&gt; is an alias for &lt;code&gt;{utf32,big}&lt;/code&gt;. The atoms &lt;code&gt;big&lt;/code&gt; and &lt;code&gt;little&lt;/code&gt; denote big- or little-endian encoding.</source>
          <target state="translated">&lt;code&gt;unicode&lt;/code&gt; 옵션 은 바이너리의 유니 코드 문자에 대해 선호되는 인코딩이므로 &lt;code&gt;utf8&lt;/code&gt; 의 별명입니다 . &lt;code&gt;utf16&lt;/code&gt; 은 &lt;code&gt;{utf16,big}&lt;/code&gt; 의 별명 이고 &lt;code&gt;utf32&lt;/code&gt; 는 &lt;code&gt;{utf32,big}&lt;/code&gt; 의 별명입니다 . 원자 &lt;code&gt;big&lt;/code&gt; 및 &lt;code&gt;little&lt;/code&gt; 나타낸다 BIG-또는 리틀 엔디안 인코딩.</target>
        </trans-unit>
        <trans-unit id="dd54ba2652e6caa2fdc53e186c7711e64ef49755" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;unordered&lt;/code&gt; specifies whether or not to use unordered delivery, integer &lt;code&gt;N&lt;/code&gt; being equivalent to &lt;code&gt;N =&amp;lt; OS&lt;/code&gt;, where &lt;code&gt;OS&lt;/code&gt; is the number of outbound streams negotiated on the association in question. Regardless of configuration, sending is ordered on stream 0 until reception of a second incoming message, to ensure that a peer receives capabilities exchange messages before any other. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unordered&lt;/code&gt; 옵션은 비 순차 전달을 사용할지 여부를 지정합니다. 정수 &lt;code&gt;N&lt;/code&gt; 은 &lt;code&gt;N =&amp;lt; OS&lt;/code&gt; 와 같습니다. 여기서 &lt;code&gt;OS&lt;/code&gt; 는 해당 연관에 대해 협상 된 아웃 바운드 스트림의 수입니다. 구성에 관계없이, 피어는 두 번째 수신 메시지를 수신 할 때까지 스트림 0에서 순서가 정해져 피어가 다른 것보다 먼저 메시지를 교환 할 수있는 기능을 수신 할 수 있습니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9437b2aaf317ba6723d7637ccb49bca377c204e5" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;variables&lt;/code&gt; can be used to specify an installation directory other than &lt;code&gt;$ROOT/lib&lt;/code&gt; for some of the applications. If a variable &lt;code&gt;{VarName,Prefix}&lt;/code&gt; is specified and an application is found in a directory &lt;code&gt;Prefix/Rest/App[-Vsn]/ebin&lt;/code&gt;, this application gets the path &lt;code&gt;VarName/Rest/App-Vsn/ebin&lt;/code&gt; in the boot script. If an application is found in a directory &lt;code&gt;Prefix/Rest&lt;/code&gt;, the path is &lt;code&gt;VarName/Rest/App-Vsn/ebin&lt;/code&gt;. When starting Erlang, all variables &lt;code&gt;VarName&lt;/code&gt; are given values using command-line flag &lt;code&gt;boot_var&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;variables&lt;/code&gt; 는 일부 응용 프로그램에 대해 &lt;code&gt;$ROOT/lib&lt;/code&gt; 이외의 설치 디렉토리를 지정하는 데 사용될 수 있습니다 . 변수 &lt;code&gt;{VarName,Prefix}&lt;/code&gt; 가 지정되고 응용 프로그램이 &lt;code&gt;Prefix/Rest/App[-Vsn]/ebin&lt;/code&gt; ,이 응용 프로그램은 부트 스크립트에서 &lt;code&gt;VarName/Rest/App-Vsn/ebin&lt;/code&gt; 경로를 가져옵니다 . 응용 프로그램이 &lt;code&gt;Prefix/Rest&lt;/code&gt; 디렉토리에있는 경우 경로는 &lt;code&gt;VarName/Rest/App-Vsn/ebin&lt;/code&gt; 입니다. Erlang을 시작할 때 모든 변수 &lt;code&gt;VarName&lt;/code&gt; 에는 명령 행 플래그 &lt;code&gt;boot_var&lt;/code&gt; 를 사용하여 값이 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="3fe4cb46f323a7c472497777738ff73ebf76a2c2" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;variables&lt;/code&gt; can be used to specify an installation directory other than &lt;code&gt;lib&lt;/code&gt; for some of the applications. If variable &lt;code&gt;{VarName,Prefix}&lt;/code&gt; is specified and an application is found in directory &lt;code&gt;Prefix/Rest/App[-Vsn]/ebin&lt;/code&gt;, this application is packed into a separate &lt;code&gt;VarName.tar.gz&lt;/code&gt; file as &lt;code&gt;Rest/App-Vsn/ebin&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;variables&lt;/code&gt; 를 사용하여 일부 응용 프로그램에 대해 &lt;code&gt;lib&lt;/code&gt; 이외의 설치 디렉토리를 지정할 수 있습니다 . 변수 &lt;code&gt;{VarName,Prefix}&lt;/code&gt; 가 지정되고 애플리케이션이 &lt;code&gt;Prefix/Rest/App[-Vsn]/ebin&lt;/code&gt; 에있는 경우이 애플리케이션은 별도의 &lt;code&gt;VarName.tar.gz&lt;/code&gt; 파일에 &lt;code&gt;Rest/App-Vsn/ebin&lt;/code&gt; 으로 압축 됩니다.</target>
        </trans-unit>
        <trans-unit id="a5d38b5eca75c6ce7a8a86d89951c54beea09b28" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;verbose&lt;/code&gt; (or rather &lt;code&gt;{verbose,true}&lt;/code&gt;) causes diagnostics printout through &lt;code&gt;io:format/2&lt;/code&gt; of queries, replies retransmissions, and so on, similar to from utilities, such as &lt;code&gt;dig&lt;/code&gt; and &lt;code&gt;nslookup&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;verbose&lt;/code&gt; (또는 오히려 &lt;code&gt;{verbose,true}&lt;/code&gt; )는 &lt;code&gt;io:format/2&lt;/code&gt; 쿼리를 통해 진단 결과를 출력하고 , 재발송 등에 응답하며, &lt;code&gt;dig&lt;/code&gt; 및 &lt;code&gt;nslookup&lt;/code&gt; 과 같은 유틸리티에서와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="3a9444c4853f083de328fc1ee9ccc9ae214b7bd7" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;verbose&lt;/code&gt; can be added to get information about the generated files:</source>
          <target state="translated">생성 된 파일에 대한 정보를 얻기 위해 옵션 &lt;code&gt;verbose&lt;/code&gt; 를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72dc8b34cd621366e301671b30bbc40e7b1100a0" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;write_concurrency&lt;/code&gt; can be combined with option &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt;read_concurrency&lt;/a&gt;&lt;/code&gt;. You typically want to combine these when large concurrent read bursts and large concurrent write bursts are common; for more information, see option &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt;read_concurrency&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;write_concurrency&lt;/code&gt; 는 옵션과 결합 될 수 &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt;read_concurrency&lt;/a&gt;&lt;/code&gt; . 일반적으로 큰 동시 읽기 버스트와 큰 동시 쓰기 버스트가 공통 인 경우 이들을 결합하려고합니다. 자세한 정보는 &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt;read_concurrency&lt;/a&gt;&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a9faea62aad9078a0a76ca4af9ddb6c33c84d32" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt; can be used to cache the answers to a QLC. The answers are stored in one ETS table for each cached QLC. When a cached QLC is evaluated again, answers are fetched from the table without any further computations. Therefore, when all answers to a cached QLC have been found, the ETS tables used for caching answers to the qualifiers of the QLC can be emptied. Option &lt;code&gt;cache&lt;/code&gt; is equivalent to &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt; 를 사용하여 QLC에 대한 답변을 캐시 할 수 있습니다. 답변은 캐시 된 각 QLC에 대해 하나의 ETS 테이블에 저장됩니다. 캐시 된 QLC가 다시 평가되면 추가 계산없이 테이블에서 답변을 가져옵니다. 따라서 캐시 된 QLC에 대한 모든 응답을 찾으면 QLC의 규정 자에 대한 응답을 캐싱하는 데 사용되는 ETS 테이블을 비울 수 있습니다. 옵션 &lt;code&gt;cache&lt;/code&gt; 는 &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f0b3ecf3fceaf01bc2ca34bef8c3c517c967e629" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; can be used to cache the answers to a QLC like &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt;. The difference is that the answers are kept in a list (on the process heap). If the answers would occupy more than a certain amount of RAM memory, a temporary file is used for storing the answers. Option &lt;code&gt;max_list_size&lt;/code&gt; sets the limit in bytes and the temporary file is put on the directory set by option &lt;code&gt;tmpdir&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; 옵션을 사용하여 &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt; 와 같은 QLC에 대한 답변을 캐시 할 수 있습니다 . 차이점은 답변이 프로세스 힙의 목록에 유지된다는 것입니다. 응답이 특정 양의 RAM 메모리보다 많은 공간을 차지하는 경우 임시 파일을 사용하여 응답을 저장합니다. &lt;code&gt;max_list_size&lt;/code&gt; 옵션 은 바이트 단위로 한계를 설정하고 임시 파일은 &lt;code&gt;tmpdir&lt;/code&gt; 옵션으로 설정된 디렉토리에 놓 입니다.</target>
        </trans-unit>
        <trans-unit id="c363b0b99cf0b9f17d626eea478292453b3a04e0" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; offers the possibility to store the answers in a list on the process heap. This has the potential of being faster than ETS tables, as there is no need to copy answers from the table. However, it can often result in slower evaluation because of more garbage collections of the process heap and increased RAM memory consumption because of larger heaps. Another drawback with cache lists is that if the list size exceeds a limit, a temporary file is used. Reading the answers from a file is much slower than copying them from an ETS table. But if the available RAM memory is scarce, setting the &lt;code&gt;&lt;a href=&quot;#max_list_size&quot;&gt;limit&lt;/a&gt;&lt;/code&gt; to some low value is an alternative.</source>
          <target state="translated">옵션 &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; 는 프로세스 힙의 목록에 답변을 저장할 수있는 가능성을 제공합니다. 테이블에서 응답을 복사 할 필요가 없으므로 ETS 테이블보다 빠를 가능성이 있습니다. 그러나 프로세스 힙의 가비지 콜렉션이 많고 힙이 클수록 RAM 메모리 소비가 증가하여 평가 속도가 느려질 수 있습니다. 캐시 목록의 또 다른 단점은 목록 크기가 제한을 초과하면 임시 파일이 사용된다는 것입니다. 파일에서 답을 읽는 것이 ETS 테이블에서 복사하는 것보다 훨씬 느립니다. 그러나 사용 가능한 RAM 메모리가 부족한 경우 &lt;code&gt;&lt;a href=&quot;#max_list_size&quot;&gt;limit&lt;/a&gt;&lt;/code&gt; 을 일부 낮은 값으로 설정하는 것이 대안입니다.</target>
        </trans-unit>
        <trans-unit id="78277a7753947f4b67c1f00cd1efea245ef61134" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{exit_on_close, false}&lt;/code&gt; is useful if the peer has done a shutdown on the write side.</source>
          <target state="translated">피어가 쓰기 측에서 종료를 수행 한 경우 옵션 &lt;code&gt;{exit_on_close, false}&lt;/code&gt; 가 유용합니다.</target>
        </trans-unit>
        <trans-unit id="06b017310b210415f4e3f5ffc5d41bfadc6c3b12" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{join,&amp;nbsp;Join}&lt;/code&gt; can be used to ensure that a certain join method is used:</source>
          <target state="translated">&lt;code&gt;{join,&amp;nbsp;Join}&lt;/code&gt; 옵션을 사용하여 특정 결합 방법이 사용되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30fedae2cf205df5ff8623315cf8962b5f1bff95" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{lookup,&amp;nbsp;true}&lt;/code&gt; can be used to ensure that the &lt;code&gt;qlc&lt;/code&gt; module looks up constants in some QLC table. If there are more than one QLC table among the list expressions of the generators, constants must be looked up in at least one of the tables. The evaluation of the query fails if there are no constants to look up. This option is useful when it would be unacceptable to traverse all objects in some table. Setting option &lt;code&gt;lookup&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; ensures that no constants are looked up (&lt;code&gt;{max_lookup,&amp;nbsp;0}&lt;/code&gt; has the same effect). Defaults to &lt;code&gt;any&lt;/code&gt;, which means that constants are looked up whenever possible.</source>
          <target state="translated">&lt;code&gt;qlc&lt;/code&gt; 모듈이 일부 QLC 테이블에서 상수를 &lt;code&gt;{lookup,&amp;nbsp;true}&lt;/code&gt; 옵션을 사용할 수 있습니다 . 생성기의 목록 표현식 중에 둘 이상의 QLC 테이블이있는 경우, 하나 이상의 테이블에서 상수를 찾아야합니다. 조회 할 상수가 없으면 조회 평가에 실패합니다. 이 옵션은 일부 테이블의 모든 객체를 통과 할 수없는 경우에 유용합니다. 옵션 &lt;code&gt;lookup&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정 하면 상수가 조회 되지 않습니다 ( &lt;code&gt;{max_lookup,&amp;nbsp;0}&lt;/code&gt; 의 효과는 동일 함). 기본값은 &lt;code&gt;any&lt;/code&gt; 로 , 가능할 때마다 상수를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="e9c6fcc69606cfd5e227d68821d1d1d7a8fea3e4" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{minor_version, Version}&lt;/code&gt; can be used to control some encoding details. This option was introduced in Erlang/OTP R11B-4. The valid values for &lt;code&gt;Version&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;{minor_version, Version}&lt;/code&gt; 옵션을 사용하여 일부 인코딩 세부 사항을 제어 할 수 있습니다. 이 옵션은 Erlang / OTP R11B-4에서 도입되었습니다. &lt;code&gt;Version&lt;/code&gt; 의 유효한 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe3131626c8fb97f4a37a0360d9d266a8a597be3" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{minor_version, Version}&lt;/code&gt; specifies how floats are encoded. For a detailed description, see &lt;code&gt;&lt;a href=&quot;#term_to_binary-2&quot;&gt;term_to_binary/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{minor_version, Version}&lt;/code&gt; 옵션 은 부동 소수점을 인코딩하는 방법을 지정합니다. 자세한 설명은 &lt;code&gt;&lt;a href=&quot;#term_to_binary-2&quot;&gt;term_to_binary/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="524c17823f60e5f4fb7f4313f11efaa80a725ce7" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{shell, ShellType}&lt;/code&gt; allows making &lt;code&gt;ttb&lt;/code&gt; operation similar to &lt;code&gt;dbg&lt;/code&gt;. Using &lt;code&gt;{shell, true}&lt;/code&gt; displays all trace messages in the shell before storing them. &lt;code&gt;{shell, only}&lt;/code&gt; additionally disables message storage (making the tool to behave exactly like &lt;code&gt;dbg&lt;/code&gt;). This is allowed only with IP trace ports (&lt;code&gt;{trace, {local, File}}&lt;/code&gt;).</source>
          <target state="translated">옵션 &lt;code&gt;{shell, ShellType}&lt;/code&gt; 사용하면 &lt;code&gt;dbg&lt;/code&gt; 와 비슷한 &lt;code&gt;ttb&lt;/code&gt; 작업을 수행 할 수 있습니다 . &lt;code&gt;{shell, true}&lt;/code&gt; 사용하면 저장하기 전에 모든 추적 메시지가 쉘에 표시됩니다. &lt;code&gt;{shell, only}&lt;/code&gt; 메시지 저장 기능을 추가로 비활성화합니다 (도구가 &lt;code&gt;dbg&lt;/code&gt; 와 똑같이 동작하게 함 ). 이는 IP 추적 포트 ( &lt;code&gt;{trace, {local, File}}&lt;/code&gt; ) 에서만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ef42e9a1232f5a9ba117da4d9479739de508ecd1" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt; can be used to remove duplicate answers to a QLC. The unique answers are stored in one ETS table for each QLC. The table is emptied every time it is known that there are no more answers to the QLC. Option &lt;code&gt;unique&lt;/code&gt; is equivalent to &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt;. If option &lt;code&gt;unique&lt;/code&gt; is combined with option &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt;, two ETS tables are used, but the full answers are stored in one table only. If option &lt;code&gt;unique&lt;/code&gt; is combined with option &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt;, the answers are sorted twice using &lt;code&gt;&lt;a href=&quot;#keysort-3&quot;&gt;keysort/3&lt;/a&gt;&lt;/code&gt;; once to remove duplicates and once to restore the order.</source>
          <target state="translated">옵션 &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt; 를 사용하여 QLC에 대한 중복 답변을 제거 할 수 있습니다. 고유 한 답변은 각 QLC에 대해 하나의 ETS 테이블에 저장됩니다. QLC에 대한 응답이 더 이상 없음을 알 때마다 테이블이 비워집니다. 옵션 &lt;code&gt;unique&lt;/code&gt; 는 &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt; 와 같습니다 . 옵션 경우 &lt;code&gt;unique&lt;/code&gt; 옵션과 결합 &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt; , 두 ETS 테이블이 사용되지만, 전체 응답은 단 하나 개의 테이블에 저장됩니다. 옵션 경우 &lt;code&gt;unique&lt;/code&gt; 옵션과 결합 &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; , 답변을 사용하여 두 번 분류되어 &lt;code&gt;&lt;a href=&quot;#keysort-3&quot;&gt;keysort/3&lt;/a&gt;&lt;/code&gt; ; 한 번은 중복을 제거하고 한 번은 주문을 복원합니다.</target>
        </trans-unit>
        <trans-unit id="d03fe843ff69bab217c2db04a4de76a5997a0834" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{var_tar,VarTar}&lt;/code&gt; can be used to specify if and where a separate package is to be stored. In this option &lt;code&gt;VarTar&lt;/code&gt; is one of the following:</source>
          <target state="translated">&lt;code&gt;{var_tar,VarTar}&lt;/code&gt; 옵션을 사용하여 별도의 패키지를 저장할 위치와 위치를 지정할 수 있습니다. 이 옵션에서 &lt;code&gt;VarTar&lt;/code&gt; 는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="035817bcba72e336831559d60aeb6facccf9b64f" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Close&lt;/strong&gt; executes &lt;code&gt;erlang:port_close/1&lt;/code&gt; on the port under the mouse pointer.</source>
          <target state="translated">옵션 &lt;strong&gt;닫기&lt;/strong&gt; 는 마우스 포인터 아래의 포트에서 &lt;code&gt;erlang:port_close/1&lt;/code&gt; 을 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="35e926c6fbc3d99b909d12d014b384bd4c783eb2" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Kill process&lt;/strong&gt; brutally kills the processes under the mouse pointer by sending an exit signal with reason &lt;code&gt;kill&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;strong&gt;Kill process&lt;/strong&gt; 는 reason &lt;code&gt;kill&lt;/code&gt; 과 함께 종료 신호를 보내 마우스 포인터 아래의 &lt;strong&gt;프로세스를&lt;/strong&gt; 잔인하게 종료 합니다.</target>
        </trans-unit>
        <trans-unit id="70321865963caf3c8ea1efe0081cc07fb0b639e6" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Port info&lt;/strong&gt; opens a detailed information window for the port under the mouse pointer. In addition to the information above, it also shows links and monitors.</source>
          <target state="translated">옵션 &lt;strong&gt;포트 정보&lt;/strong&gt; 는 마우스 포인터 아래에 포트에 대한 자세한 정보 창을 엽니 다. 위의 정보 외에도 링크 및 모니터도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7d65b0f04dbfd40d29f90c9cb3594f974e725b28" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Process info&lt;/strong&gt; opens a detailed information window on the process under the mouse pointer, including the following:</source>
          <target state="translated">옵션 &lt;strong&gt;프로세스 정보&lt;/strong&gt; 는 다음을 포함하여 마우스 포인터 아래의 프로세스에 대한 자세한 정보 창을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="99160977b4d7a39a2a6e97003b66bdad996bc6ed" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Trace selected ports by name&lt;/strong&gt; adds the registered name of the port to tab &lt;strong&gt;Trace Overview&lt;/strong&gt;. This can be useful when tracing is done on many nodes, as ports with that name are then traced on all traced nodes.</source>
          <target state="translated">옵션 &lt;strong&gt;이름으로 선택한 포트 추적은 포트&lt;/strong&gt; 의 등록 된 이름을 탭 &lt;strong&gt;개요에 추가&lt;/strong&gt; 합니다. 이 이름을 가진 포트가 모든 추적 노드에서 추적되므로 많은 노드에서 추적을 수행 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b6c236e8cdc6b5cda5c55b97f093a7e3cd6785f" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Trace selected ports&lt;/strong&gt; adds the selected port identifiers, and the nodes that the ports reside on, to tab &lt;strong&gt;Trace Overview&lt;/strong&gt;.</source>
          <target state="translated">옵션 &lt;strong&gt;선택된 포트 추적&lt;/strong&gt; 은 선택된 포트 식별자와 포트가있는 노드를 &lt;strong&gt;추적 개요&lt;/strong&gt; 탭에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="ac9ff1921b3900c17896467fd0d99ce466117b8b" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Trace selected processes by name&lt;/strong&gt; adds the registered name of the processes. This can be useful when tracing is done on many nodes, as processes with that name are then traced on all traced nodes.</source>
          <target state="translated">옵션 &lt;strong&gt;이름으로 선택한 프로세스 추적&lt;/strong&gt; 은 등록 된 &lt;strong&gt;프로세스 이름을&lt;/strong&gt; 추가합니다. 이 이름을 가진 프로세스가 모든 추적 노드에서 추적되므로 많은 노드에서 추적을 수행 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f5a98945509d3374dcec511a2237bb11d72c5e8" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Trace selected processes&lt;/strong&gt; adds the selected process identifiers to tab &lt;strong&gt;Trace Overview&lt;/strong&gt; plus the node that the processes reside on.</source>
          <target state="translated">&lt;strong&gt;선택된 프로세스 추적&lt;/strong&gt; 옵션 은 선택된 프로세스 식별자를 &lt;strong&gt;추적 개요&lt;/strong&gt; 탭 과 프로세스가있는 노드에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="bbcdc0d51603836feb28f7c0f6ebeff6083e909a" translate="yes" xml:space="preserve">
          <source>Option can be an empty list. Otherwise, see possible &lt;strong&gt;POSIX&lt;/strong&gt; names in Section 8 in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt; RFC 4254&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">옵션은 빈 목록 일 수 있습니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt; RFC 4254&lt;/a&gt;&lt;/code&gt; 의 섹션 8에서 가능한 &lt;strong&gt;POSIX&lt;/strong&gt; 이름을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed343dc73ff17a12eae43c4c8abcaf085a15af89" translate="yes" xml:space="preserve">
          <source>Option description:</source>
          <target state="translated">옵션 설명 :</target>
        </trans-unit>
        <trans-unit id="842a1436ee68919d09edec512df7b86300e0f790" translate="yes" xml:space="preserve">
          <source>Option for the request to be synchronous or asynchronous.</source>
          <target state="translated">요청이 동기식이거나 비동기식 인 옵션.</target>
        </trans-unit>
        <trans-unit id="1293048f15d31bf84b0b730a9b1782f9b01e778a" translate="yes" xml:space="preserve">
          <source>Option list, required but not used.</source>
          <target state="translated">필수이지만 사용되지 않은 옵션 목록.</target>
        </trans-unit>
        <trans-unit id="462548ed78075584c1554197ff33d7cd930b932f" translate="yes" xml:space="preserve">
          <source>Option passed to &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;. Has one of the following types.</source>
          <target state="translated">옵션이 &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; 로 전달되었습니다 . 다음 유형 중 하나가 있습니다.</target>
        </trans-unit>
        <trans-unit id="23707ebafb992d8dfae9b58a9ba61d8c8fd2c70a" translate="yes" xml:space="preserve">
          <source>Option passed to &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt;. Can be any &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#capability&quot;&gt;capability()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; as well as the following.</source>
          <target state="translated">옵션이 &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; 로 전달되었습니다 . 다음과 같은 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#capability&quot;&gt;capability()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c6c4102d4dfec3b1aa41117e0e344046c58a151" translate="yes" xml:space="preserve">
          <source>Optional</source>
          <target state="translated">Optional</target>
        </trans-unit>
        <trans-unit id="4d4b2106cdcb3604717e69731f6481a51f9daa36" translate="yes" xml:space="preserve">
          <source>Optional Header Elements</source>
          <target state="translated">선택적 헤더 요소</target>
        </trans-unit>
        <trans-unit id="dfbb34787505eab01012f74ede55769d7b2752c8" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;code id=&quot;hook_function&quot;&gt;HookFunction&lt;/code&gt;, shown in the functions described in this module, defines a function that is called when an unknown form occurs where there is to be a valid expression. If &lt;code&gt;HookFunction&lt;/code&gt; is equal to &lt;code&gt;none&lt;/code&gt;, there is no hook function.</source>
          <target state="translated">이 모듈에 설명 된 함수에 표시된 선택적 인수 &lt;code id=&quot;hook_function&quot;&gt;HookFunction&lt;/code&gt; 은 유효한 표현식이있는 곳에서 알 수없는 양식이 발생할 때 호출되는 함수를 정의합니다. 경우 &lt;code&gt;HookFunction&lt;/code&gt; 가 같은지 &lt;code&gt;none&lt;/code&gt; 어떠한 후크 함수가 없다.</target>
        </trans-unit>
        <trans-unit id="276de84647d247405111dca217abe17bdd0364d3" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;code&gt;NumberOfAnswers&lt;/code&gt; determines the maximum number of answers returned. Defaults to &lt;code&gt;10&lt;/code&gt;. If less than the requested number of answers is returned, subsequent calls to &lt;code&gt;next_answers&lt;/code&gt; return &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;code&gt;NumberOfAnswers&lt;/code&gt; 는 반환되는 최대 답변 수를 결정합니다. 기본값은 &lt;code&gt;10&lt;/code&gt; 입니다. 요청 된 수보다 적은 수의 응답이 반환되면 &lt;code&gt;next_answers&lt;/code&gt; 에 대한 후속 호출이 &lt;code&gt;[]&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="8e155301399a6f11bab8a0f03e661dc264bf4113" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;code&gt;Timeout&lt;/code&gt; specifies a time-out in milliseconds. The default value is &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;code&gt;Timeout&lt;/code&gt; 은 시간 초과를 밀리 초로 지정합니다. 기본값은 &lt;code&gt;infinity&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cc160da129ae196cb0bc016f6e6b2dc9018a93f1" translate="yes" xml:space="preserve">
          <source>Optional disc. The schema can reside on disc or in RAM. If the schema is found on disc, Mnesia starts as a disc-based node and the storage type of the schema table is &lt;code&gt;disc_copies&lt;/code&gt;. If no schema is found on disc, Mnesia starts as a disc-less node and the storage type of the schema table is &lt;code&gt;ram_copies&lt;/code&gt;. Default value for the application parameter is &lt;code&gt;opt_disc&lt;/code&gt;.</source>
          <target state="translated">옵션 디스크. 스키마는 디스크 나 RAM에있을 수 있습니다. 디스크에 스키마가있는 경우 Mnesia는 디스크 기반 노드로 시작하며 스키마 테이블의 스토리지 유형은 &lt;code&gt;disc_copies&lt;/code&gt; 입니다. 디스크에 스키마가 없으면 Mnesia는 디스크없는 노드로 시작하며 스키마 테이블의 스토리지 유형은 &lt;code&gt;ram_copies&lt;/code&gt; 입니다. 애플리케이션 매개 변수의 기본값은 &lt;code&gt;opt_disc&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="08766916e383f04d3e4dd8436f435e4ff78d676e" translate="yes" xml:space="preserve">
          <source>Optional disc. The schema can reside on either disc or RAM. If the schema is found on disc, &lt;code&gt;Mnesia&lt;/code&gt; starts as a disc-full node (the storage type of the schema table is disc_copies). If no schema is found on disc, &lt;code&gt;Mnesia&lt;/code&gt; starts as a disc-less node (the storage type of the schema table is &lt;code&gt;ram_copies&lt;/code&gt;). The default for the application parameter is &lt;code&gt;opt_disc&lt;/code&gt;.</source>
          <target state="translated">옵션 디스크. 스키마는 디스크 또는 RAM에있을 수 있습니다. 디스크에서 스키마가 발견되면 &lt;code&gt;Mnesia&lt;/code&gt; 는 디스크가 가득 찬 노드로 시작합니다 (스키마 테이블의 스토리지 유형은 disc_copies입니다). 디스크에 스키마가 없으면 &lt;code&gt;Mnesia&lt;/code&gt; 는 디스크가없는 노드로 시작합니다 (스키마 테이블의 스토리지 유형은 &lt;code&gt;ram_copies&lt;/code&gt; 입니다 ). 애플리케이션 매개 변수의 기본값은 &lt;code&gt;opt_disc&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="85dd2f62ecb3fc58781f23223662bb5750bb8b07" translate="yes" xml:space="preserve">
          <source>Optional fields are to be omitted from the map if they have no value:</source>
          <target state="translated">선택적 필드는 값이없는 경우 맵에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="f7ff2e1b639664116012253b69978817d7cb9d18" translate="yes" xml:space="preserve">
          <source>Optional parameter that indicates which stream of event is of interest. If not present, events in the default NETCONF stream are sent.</source>
          <target state="translated">관심있는 이벤트 스트림을 나타내는 선택적 매개 변수입니다. 존재하지 않으면 기본 NETCONF 스트림의 이벤트가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="9f20bc591a797de16d0e389435598756b6d01a90" translate="yes" xml:space="preserve">
          <source>Optional parameter that indicates which subset of all possible events is of interest. The parameter format is the same as that of the filter parameter in the NETCONF protocol operations. If not present, all events not precluded by other parameters are sent.</source>
          <target state="translated">관심있는 모든 가능한 이벤트의 서브 세트를 나타내는 선택적 매개 변수입니다. 매개 변수 형식은 NETCONF 프로토콜 조작에서 필터 매개 변수의 형식과 동일합니다. 존재하지 않으면 다른 매개 변수에 의해 제외되지 않은 모든 이벤트가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="91c8bbcc154e216bf161a4cea2cf2921f55e3375" translate="yes" xml:space="preserve">
          <source>Optional parameter used to trigger the replay feature and indicate that the replay is to start at the time specified. If &lt;code&gt;StartTime&lt;/code&gt; is not present, this is not a replay subscription.</source>
          <target state="translated">재생 기능을 트리거하고 지정된 시간에 재생이 시작됨을 나타내는 데 사용되는 선택적 매개 변수입니다. 경우 &lt;code&gt;StartTime&lt;/code&gt; 존재하지 않는, 이것은 재생 가입하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b62c08c67213d147aac035093ce60b242c49707" translate="yes" xml:space="preserve">
          <source>Optional parameter used with the optional replay feature to indicate the newest notifications of interest. If &lt;code&gt;StopTime&lt;/code&gt; is not present, the notifications continues until the subscription is terminated.</source>
          <target state="translated">선택적 재생 기능과 함께 사용되는 선택적 매개 변수는 최신 관심 알림을 나타냅니다. 경우 &lt;code&gt;StopTime&lt;/code&gt; 이 존재하지 않는 가입이 종료 될 때까지 알림이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="a4149a55fc8e55fc8490190fca6fd327f9a538b3" translate="yes" xml:space="preserve">
          <source>Optional.</source>
          <target state="translated">Optional.</target>
        </trans-unit>
        <trans-unit id="e8af255ca8f0d30288a7d242bda54e97c39eddd8" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;&quot;&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c3e770d9ae3be1592b6bb4e71a2a0b4d02b632c8" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;&quot;agentEngine&quot;&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;&quot;agentEngine&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f444f3a32fb5864a64535a82d40b191fe3d8f92a" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;&quot;ct_test&quot;&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;&quot;ct_test&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d86ff1cf1753eeb2712d25027e36b3bfeeb878b3" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;&quot;mgrEngine&quot;&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;&quot;mgrEngine&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3a5be38a4ec672fa5fc505b1d3938e2c4805690c" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;4000&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;4000&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3d818395035fabb022c90708c6cc84ee8b4b5af1" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;484&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;484&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eb016daeda5d1c2dc4395fae5d7f67d4983388a1" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;5000&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;5000&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a91274ea47ca456c7c73bd65eabdba098688b45e" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;[v2]&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;[v2]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9145bb534991daf57f7701301bbf91899e9dd502" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c1862eeb7c8ff53d3ad48a0810e5755cdc2bd4c3" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;localhost&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;localhost&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="56e30788f63a5934b2591e0b2064ad81f73c70ba" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;none&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="50d0a6ed5f07cbf3535d40a94c01a427fc76812c" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;trap&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;trap&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="81e97dcaaa41ca3300b210af9cb347aabd6782bc" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e7a5e868b1b2f32a86b5bd642dcb3afd6a406ab2" translate="yes" xml:space="preserve">
          <source>Optional. SNMPv3 only.</source>
          <target state="translated">선택 과목. SNMPv3에만 해당합니다.</target>
        </trans-unit>
        <trans-unit id="e29d2e9b1f6270c8f759be9d98bdcc632686ece6" translate="yes" xml:space="preserve">
          <source>Optional. Specifies a file name relative to the release directory (that is, the subdirectory of &amp;lt;release root&amp;gt; where the &lt;code&gt;.boot&lt;/code&gt; file and others are located). The contents of this file is appended to the command line when Erlang is started. This makes it easy to start the emulator with different options for different releases.</source>
          <target state="translated">선택 과목. 릴리스 디렉토리를 기준으로 파일 이름을 지정합니다 (즉, &lt;code&gt;.boot&lt;/code&gt; 파일 및 기타 파일이 있는 &amp;lt;release root&amp;gt;의 하위 디렉토리 ). 이 파일의 내용은 Erlang이 시작될 때 명령 행에 추가됩니다. 따라서 릴리스마다 다른 옵션으로 에뮬레이터를 쉽게 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b0c96e71650acccc82db9e27a628d2721580904" translate="yes" xml:space="preserve">
          <source>Optional. Specifies another data file than &lt;code&gt;start_erl.data&lt;/code&gt; in the &amp;lt;release root&amp;gt;. It is specified relative to the &amp;lt;release root&amp;gt; or absolute (including drive letter, and so on). This option is used by the release handler during upgrade and is not to be used during normal operation. Normally the release data file is not to be named differently.</source>
          <target state="translated">선택 과목. &amp;lt;release root&amp;gt;에서 &lt;code&gt;start_erl.data&lt;/code&gt; 이외의 다른 데이터 파일을 지정합니다 . &amp;lt;릴리즈 루트&amp;gt; 또는 절대 값 (드라이브 문자 등 포함)에 대해 지정됩니다. 이 옵션은 업그레이드 중에 릴리스 핸들러에서 사용되며 정상 작동 중에는 사용되지 않습니다. 일반적으로 릴리스 데이터 파일의 이름은 달라야합니다.</target>
        </trans-unit>
        <trans-unit id="6e896a68b07b1ca3cf93595378b5e6e78183b5ae" translate="yes" xml:space="preserve">
          <source>Optional. Specifies what &lt;code&gt;start_erl.data&lt;/code&gt; file to use.</source>
          <target state="translated">선택 과목. 사용할 &lt;code&gt;start_erl.data&lt;/code&gt; 파일을 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="8dfb648c156e19ccfde0a8a75080225f82a66290" translate="yes" xml:space="preserve">
          <source>Optional: a list of</source>
          <target state="translated">선택 사항 :</target>
        </trans-unit>
        <trans-unit id="40298ed5ccf236464308dd175b962b82475a2522" translate="yes" xml:space="preserve">
          <source>Optional: one or more</source>
          <target state="translated">선택 사항 : 하나 이상</target>
        </trans-unit>
        <trans-unit id="c38ca1d794e5db4040d672952825698f938f1b2b" translate="yes" xml:space="preserve">
          <source>Optionally an associated condition. A condition is a tuple &lt;code&gt;{Module,Name}&lt;/code&gt;. When the breakpoint is reached, &lt;code&gt;Module:Name(Bindings)&lt;/code&gt; is called. If it evaluates to &lt;code&gt;true&lt;/code&gt;, execution stops. If it evaluates to &lt;code&gt;false&lt;/code&gt;, the breakpoint is ignored. &lt;code&gt;Bindings&lt;/code&gt; contains the current variable bindings. To retrieve the value for a specified variable, use &lt;code&gt;get_binding&lt;/code&gt;.</source>
          <target state="translated">선택적으로 관련 조건. 조건은 튜플 &lt;code&gt;{Module,Name}&lt;/code&gt; 입니다. 중단 점에 도달하면 &lt;code&gt;Module:Name(Bindings)&lt;/code&gt; 이 호출됩니다. &lt;code&gt;true&lt;/code&gt; 로 평가 되면 실행이 중지됩니다. &lt;code&gt;false&lt;/code&gt; 로 평가 되면 중단 점이 무시됩니다. &lt;code&gt;Bindings&lt;/code&gt; 은 현재 변수 바인딩을 포함합니다. 지정된 변수의 값을 검색하려면 &lt;code&gt;get_binding&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a4282aaa4b303055b863e5204685bc1397a847f" translate="yes" xml:space="preserve">
          <source>Optionally invoked for a time consuming transaction request</source>
          <target state="translated">시간 소모적 인 트랜잭션 요청에 대해 선택적으로 호출</target>
        </trans-unit>
        <trans-unit id="c6c8e1e5181e25bac7195f77b91e7ea903739f23" translate="yes" xml:space="preserve">
          <source>Optionally invoked for a transaction acknowledgement</source>
          <target state="translated">트랜잭션 승인을 위해 선택적으로 호출</target>
        </trans-unit>
        <trans-unit id="a5f2278c7ee5f9556ced2e826a1b917355402ad3" translate="yes" xml:space="preserve">
          <source>Optionally invoked for a transaction reply</source>
          <target state="translated">트랜잭션 응답을 위해 선택적으로 호출</target>
        </trans-unit>
        <trans-unit id="da6a3730bb2085f8ebf92b6273cda1787e65e75e" translate="yes" xml:space="preserve">
          <source>Optionally specifies how captured substrings are to be returned. If omitted, the default of &lt;code&gt;index&lt;/code&gt; is used.</source>
          <target state="translated">선택적으로 캡처 된 하위 문자열이 리턴되는 방법을 지정합니다. 생략하면 &lt;code&gt;index&lt;/code&gt; 의 기본값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="9749013cefa7f03d17b664b15412b1588b737407" translate="yes" xml:space="preserve">
          <source>Options (&lt;code&gt;Opt&lt;/code&gt;s):</source>
          <target state="translated">옵션 ( &lt;code&gt;Opt&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="2a71724fb98cff6a19705fe029e03eebb720115b" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;-P&lt;/code&gt;, &lt;code&gt;-E&lt;/code&gt;, and &lt;code&gt;-S&lt;/code&gt; are equivalent to &lt;code&gt;+'P'&lt;/code&gt;, &lt;code&gt;+'E'&lt;/code&gt;, and &lt;code&gt;+'S'&lt;/code&gt;, except that it is not necessary to include the single quotes to protect them from the shell.</source>
          <target state="translated">옵션 &lt;code&gt;-P&lt;/code&gt; , &lt;code&gt;-E&lt;/code&gt; 및 &lt;code&gt;-S&lt;/code&gt; 는 &lt;code&gt;+'P'&lt;/code&gt; , &lt;code&gt;+'E'&lt;/code&gt; 및 &lt;code&gt;+'S'&lt;/code&gt; 와 동일합니다. 단, 따옴표를 포함하여 쉘에서 보호 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="e0366a9ebac5c17541c6d26640b461361c80a4a4" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;Username&lt;/code&gt; and &lt;code&gt;Password&lt;/code&gt; are used to log on to the remote host &lt;code&gt;Host&lt;/code&gt;. &lt;code&gt;Username&lt;/code&gt;, if omitted, defaults to the current username. &lt;code&gt;Password&lt;/code&gt; is empty by default.</source>
          <target state="translated">옵션 &lt;code&gt;Username&lt;/code&gt; 및 &lt;code&gt;Password&lt;/code&gt; 는 원격 호스트 &lt;code&gt;Host&lt;/code&gt; 에 로그온하는 데 사용됩니다 . &lt;code&gt;Username&lt;/code&gt; 이 생략되면 기본값은 현재 사용자 이름입니다. &lt;code&gt;Password&lt;/code&gt; 는 기본적으로 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dcd58b0792b2c9e9c3b6819e8f16b982914d604" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;binary&lt;/code&gt; and &lt;code&gt;encoding&lt;/code&gt; are common for all I/O servers in OTP, while &lt;code&gt;echo&lt;/code&gt; and &lt;code&gt;expand&lt;/code&gt; are valid only for this I/O server. Option &lt;code&gt;unicode&lt;/code&gt; notifies how characters are put on the physical I/O device, that is, if the terminal itself is Unicode-aware. It does not affect how characters are sent in the I/O protocol, where each request contains encoding information for the provided or returned data.</source>
          <target state="translated">&lt;code&gt;binary&lt;/code&gt; 및 &lt;code&gt;encoding&lt;/code&gt; 옵션 은 OTP의 모든 I / O 서버에 공통이며 &lt;code&gt;echo&lt;/code&gt; 및 &lt;code&gt;expand&lt;/code&gt; 은이 I / O 서버에만 유효합니다. 옵션 &lt;code&gt;unicode&lt;/code&gt; 는 문자가 물리적 I / O 장치에 배치되는 방법, 즉 터미널 자체가 유니 코드를 인식하는 경우를 알려줍니다. I / O 프로토콜에서 문자를 보내는 방법에는 영향을 미치지 않으며, 각 요청에는 제공된 또는 반환 된 데이터에 대한 인코딩 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8ff02c5f14ce17a7d5799eee0ac8c1ea2bf12c76" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;cache&lt;/code&gt; and &lt;code&gt;unique&lt;/code&gt; apply not only to the QLC itself but also to the results of looking up constants, running match specifications, and joining handles.</source>
          <target state="translated">옵션 &lt;code&gt;cache&lt;/code&gt; 및 &lt;code&gt;unique&lt;/code&gt; 는 QLC 자체뿐만 아니라 상수 조회, 일치 스펙 실행 및 핸들 결합의 결과에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9580f262070eeecb51ff008fdc6585d927dbc1f8" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;global&lt;/code&gt; and &lt;code&gt;{scope, part()}&lt;/code&gt; work as for &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt;. The return type is always a &lt;code&gt;binary()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt; 및 &lt;code&gt;{scope, part()}&lt;/code&gt; 옵션 은 &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt; 과 동일하게 작동 합니다. 반환 유형은 항상 &lt;code&gt;binary()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="51c09aef080d57e48a07185acafc8ce6ebec94f6" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;message_cb&lt;/code&gt; and &lt;code&gt;sender&lt;/code&gt; have semantics identical to those documented in &lt;code&gt;&lt;a href=&quot;diameter_tcp#sender&quot;&gt;diameter_tcp(3)&lt;/a&gt;&lt;/code&gt;, but with the message argument to a &lt;code&gt;recv&lt;/code&gt; callback being as directed by the &lt;code&gt;packet&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;message_cb&lt;/code&gt; 및 &lt;code&gt;sender&lt;/code&gt; 옵션 은 &lt;code&gt;&lt;a href=&quot;diameter_tcp#sender&quot;&gt;diameter_tcp(3)&lt;/a&gt;&lt;/code&gt; 설명 된 것과 동일한 의미를 갖지만 &lt;code&gt;recv&lt;/code&gt; 콜백에 대한 메시지 인수 는 &lt;code&gt;packet&lt;/code&gt; 옵션에 의해 지시됩니다 .</target>
        </trans-unit>
        <trans-unit id="e61d32b3cca20de20d192710649075d0fa3c950e" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;raddr&lt;/code&gt; and &lt;code&gt;rport&lt;/code&gt; specify the remote address and port for a connecting transport and are not valid for a listening transport.</source>
          <target state="translated">&lt;code&gt;raddr&lt;/code&gt; 및 &lt;code&gt;rport&lt;/code&gt; 옵션 은 연결 전송의 원격 주소와 포트를 지정하며 수신 전송에는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9f19d6b068a72ffa150ad3783e561ce5a572f10" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;raddr&lt;/code&gt; and &lt;code&gt;rport&lt;/code&gt; specify the remote address and port for a connecting transport and not valid for a listening transport: the former is required while latter defaults to 3868 if unspecified. Multiple &lt;code&gt;raddr&lt;/code&gt; options can be specified, in which case the connecting transport in question attempts each in sequence until an association is established.</source>
          <target state="translated">&lt;code&gt;raddr&lt;/code&gt; 및 &lt;code&gt;rport&lt;/code&gt; 옵션 은 연결 전송에 대한 원격 주소와 포트를 지정하며 수신 전송에는 유효하지 않습니다. 전자는 필수이며 후자는 지정되지 않은 경우 기본값은 3868입니다. 여러 &lt;code&gt;raddr&lt;/code&gt; 옵션을 지정할 수 있으며,이 경우 해당 연결 전송은 연결이 설정 될 때까지 각각 순서대로 시도합니다.</target>
        </trans-unit>
        <trans-unit id="ffb596bacd291beb9c0f85faa25b79b4527311a4" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;repeat&lt;/code&gt; and &lt;code&gt;sequence&lt;/code&gt; can be combined to match a sequence multiple times.</source>
          <target state="translated">&lt;code&gt;repeat&lt;/code&gt; 옵션 과 &lt;code&gt;sequence&lt;/code&gt; 옵션을 조합하여 시퀀스를 여러 번 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e81a184b61cbd5436906125ea2fd1369abbf5985" translate="yes" xml:space="preserve">
          <source>Options allow to customize the behaviour of the scanner. See also &lt;code&gt;tutorial&lt;/code&gt; on customization functions.</source>
          <target state="translated">옵션을 통해 스캐너의 동작을 사용자 정의 할 수 있습니다. 사용자 정의 기능에 대한 &lt;code&gt;tutorial&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d1df937b910b748dfde76ee563a39943f8c8982a" translate="yes" xml:space="preserve">
          <source>Options allow to customize the behaviour of the validation.</source>
          <target state="translated">옵션을 통해 유효성 검사 동작을 사용자 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d2339a2a5eabae774a416fb2e29a52c85a83319" translate="yes" xml:space="preserve">
          <source>Options allows to customize the behaviour of the XPath scanner.</source>
          <target state="translated">옵션을 사용하면 XPath 스캐너의 동작을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ffa2c48bad8b2b21cb7fd3c0cdc61a21bc9b14c" translate="yes" xml:space="preserve">
          <source>Options are processed in the order they occur in the list, that is, later options have higher precedence.</source>
          <target state="translated">옵션은 목록에서 발생하는 순서대로 처리됩니다. 즉, 나중에 옵션이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="5257320eb8c67ae70e398e048755a4a432e71e80" translate="yes" xml:space="preserve">
          <source>Options available to &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; when sending an outgoing Diameter request. Has one of the following types.</source>
          <target state="translated">나가는 지름 요청을 보낼 때 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 할 수있는 옵션 . 다음 유형 중 하나가 있습니다.</target>
        </trans-unit>
        <trans-unit id="43baa3cfdab8fbfb50fe057ed27dea4648766c66" translate="yes" xml:space="preserve">
          <source>Options can be set to make the release package include source code and the ERTS binary as well.</source>
          <target state="translated">릴리스 패키지에 소스 코드와 ERTS 바이너리도 포함되도록 옵션을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19f6806cc859d20b910b98cdb91856f7d205c282" translate="yes" xml:space="preserve">
          <source>Options defining a Diameter application. Has one of the following types.</source>
          <target state="translated">직경 응용 프로그램을 정의하는 옵션. 다음 유형 중 하나가 있습니다.</target>
        </trans-unit>
        <trans-unit id="85fa7bc47c34fb7d169b6cba28b8680c98650d6d" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;&lt;a href=&quot;#cmd-2&quot;&gt;os:cmd/2&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#cmd-2&quot;&gt;os:cmd/2&lt;/a&gt;&lt;/code&gt; 에 대한 옵션</target>
        </trans-unit>
        <trans-unit id="c747f7830167fa762f894dbecb9703a094daa7ee" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;clients&lt;/a&gt;&lt;/code&gt;. The individual options are further explained below or by following the hyperlinks.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;clients&lt;/a&gt;&lt;/code&gt; 위한 옵션 . 개별 옵션에 대해서는 아래 또는 하이퍼 링크를 통해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7a1ffff775190d7efc280e2ad290e1f4ea5665b9" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;&lt;a href=&quot;#daemon-1&quot;&gt;daemons&lt;/a&gt;&lt;/code&gt;. The individual options are further explained below or by following the hyperlinks.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#daemon-1&quot;&gt;daemons&lt;/a&gt;&lt;/code&gt; 옵션 . 개별 옵션에 대해서는 아래 또는 하이퍼 링크를 통해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="eb4d9d68b8a4bdc7b530015f01b070a24bbaaaae" translate="yes" xml:space="preserve">
          <source>Options for ROOT, Intermediate and Peer certs</source>
          <target state="translated">루트, 중급 및 피어 인증서에 대한 옵션</target>
        </trans-unit>
        <trans-unit id="271cee05e17a96561b06a7392bd67ac3d4ab26c5" translate="yes" xml:space="preserve">
          <source>Options in the environment variable EUNIT are also included last in the option list, i.e., have lower precedence than those in &lt;code&gt;Options&lt;/code&gt;.</source>
          <target state="translated">환경 변수 EUNIT의 옵션도 옵션 목록의 마지막에 포함됩니다 (즉, &lt;code&gt;Options&lt;/code&gt; 의 옵션 보다 우선 순위가 낮음) .</target>
        </trans-unit>
        <trans-unit id="2d595c0adb932691342148a1f5ccb473e844d862" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;erlang:spawn_opt/2&lt;/code&gt; when spawning a process for an incoming Diameter request. Options &lt;code&gt;monitor&lt;/code&gt; and &lt;code&gt;link&lt;/code&gt; are ignored.</source>
          <target state="translated">들어오는 직경 요청에 대한 프로세스를 생성 할 때 옵션이 &lt;code&gt;erlang:spawn_opt/2&lt;/code&gt; 로 전달되었습니다 . 옵션 &lt;code&gt;monitor&lt;/code&gt; 및 &lt;code&gt;link&lt;/code&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="fb6adb442fc6700a7d845b5b6f08d580352873cb" translate="yes" xml:space="preserve">
          <source>Options preceding &lt;code&gt;-erl_args&lt;/code&gt; that &lt;code&gt;Common Test&lt;/code&gt; does not recognize are also passed on to the emulator untouched. By &lt;code&gt;-erl_args&lt;/code&gt; the user can specify flags with the same name, but with different destinations, on the &lt;code&gt;ct_run&lt;/code&gt; command line.</source>
          <target state="translated">위의 옵션 &lt;code&gt;-erl_args&lt;/code&gt; 것이 &lt;code&gt;Common Test&lt;/code&gt; 도 그대로 에뮬레이터에 전달되어 인식하지 않습니다. 에 의해 &lt;code&gt;-erl_args&lt;/code&gt; 사용자는하지만, 서로 다른 목적지로, 같은 이름의 플래그를 지정할 수 있습니다 &lt;code&gt;ct_run&lt;/code&gt; 의 명령 행.</target>
        </trans-unit>
        <trans-unit id="ff1becd31ec7dd72ea26d9a9fd1b56a0ae87b96b" translate="yes" xml:space="preserve">
          <source>Options provided to &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/[3,4]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/[3,4]&lt;/a&gt;&lt;/code&gt; 에 제공되는 옵션 .</target>
        </trans-unit>
        <trans-unit id="be2f1fd15114f1dab339629da4d391e98859a026" translate="yes" xml:space="preserve">
          <source>Options provided to &lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2,3&lt;/a&gt;&lt;/code&gt; 에 제공되는 옵션 .</target>
        </trans-unit>
        <trans-unit id="34209f6f492a2966caf548e5cb61a33749ede09a" translate="yes" xml:space="preserve">
          <source>Options that can be given to the &lt;code&gt;cth_conn_log&lt;/code&gt; hook, which is used for logging of NETCONF and Telnet connections. See &lt;code&gt;&lt;a href=&quot;ct_netconfc#Logging&quot;&gt;ct_netconfc&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ct_telnet#Logging&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; for description and examples of how to use this hook.</source>
          <target state="translated">NETCONF 및 Telnet 연결 로깅에 사용되는 &lt;code&gt;cth_conn_log&lt;/code&gt; 후크에 제공 될 수있는 옵션 . 이 후크를 사용하는 방법에 대한 설명과 예는 &lt;code&gt;&lt;a href=&quot;ct_netconfc#Logging&quot;&gt;ct_netconfc&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ct_telnet#Logging&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="228dffd69b4e3c0e126c643a9f0b0e320c2b02c8" translate="yes" xml:space="preserve">
          <source>Options that can be used when starting a &lt;code&gt;gen_statem&lt;/code&gt; server through, for example, &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3&lt;/a&gt;&lt;/code&gt; 를 통해 gen_statem 서버를 시작할 때 사용할 수있는 옵션입니다 .</target>
        </trans-unit>
        <trans-unit id="d6e5101586b632aaf8a368594dc5123cd9322755" translate="yes" xml:space="preserve">
          <source>Options to configure a &lt;code&gt;ErlNifIOQueue&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ErlNifIOQueue&lt;/code&gt; 를 구성하는 옵션 .</target>
        </trans-unit>
        <trans-unit id="23d20f728be4aacef3be89090ba5883ef7e28da2" translate="yes" xml:space="preserve">
          <source>Options used for setting up an SSH connection to a NETCONF server.</source>
          <target state="translated">NETCONF 서버에 대한 SSH 연결을 설정하는 데 사용되는 옵션.</target>
        </trans-unit>
        <trans-unit id="910207f354e542f3e522ad9da85b70501659257e" translate="yes" xml:space="preserve">
          <source>Options used to customize the behaviour of the parser. Possible options are:</source>
          <target state="translated">파서의 동작을 사용자 정의하는 데 사용되는 옵션. 가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bdd0b506837a990803d8edf137f2934329835748" translate="yes" xml:space="preserve">
          <source>Options:</source>
          <target state="translated">Options:</target>
        </trans-unit>
        <trans-unit id="6d118f8e941d56db78406a33fb3a53aed05d43fb" translate="yes" xml:space="preserve">
          <source>Options: see &lt;code&gt;&lt;a href=&quot;#parse_file-2&quot;&gt;parse_file/2&lt;/a&gt;&lt;/code&gt;. Note however that for &lt;code&gt;quick_parse_file/2&lt;/code&gt;, the option &lt;code&gt;no_fail&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; by default.</source>
          <target state="translated">옵션은 다음을 참조하십시오 &lt;code&gt;&lt;a href=&quot;#parse_file-2&quot;&gt;parse_file/2&lt;/a&gt;&lt;/code&gt; 를 . 그러나 &lt;code&gt;quick_parse_file/2&lt;/code&gt; 의 경우 &lt;code&gt;no_fail&lt;/code&gt; 옵션 은 기본적으로 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b12501090de711d45f4f134407e2f3085fb7dedb" translate="yes" xml:space="preserve">
          <source>Opts :: [&lt;code&gt;&lt;a href=&quot;#type-debug_opt&quot;&gt;debug_opt()&lt;/a&gt;&lt;/code&gt; | &lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;hibernate_after_opt()&lt;/a&gt;&lt;/code&gt;],</source>
          <target state="translated">옵션 :: [ &lt;code&gt;&lt;a href=&quot;#type-debug_opt&quot;&gt;debug_opt()&lt;/a&gt;&lt;/code&gt; | &lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;hibernate_after_opt()&lt;/a&gt;&lt;/code&gt; ],</target>
        </trans-unit>
        <trans-unit id="9ef1aeb0b64bab0b8696b0aebb6c7bffc58deff9" translate="yes" xml:space="preserve">
          <source>Opts :: [&lt;code&gt;&lt;a href=&quot;#type-start_opt&quot;&gt;start_opt()&lt;/a&gt;&lt;/code&gt;]) -&amp;gt;</source>
          <target state="translated">옵션 :: [ &lt;code&gt;&lt;a href=&quot;#type-start_opt&quot;&gt;start_opt()&lt;/a&gt;&lt;/code&gt; ])-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9ddc3f14766efb56c4d34a9542fe728065e02b6b" translate="yes" xml:space="preserve">
          <source>Or - if building a 64bit version:</source>
          <target state="translated">또는 64 비트 버전을 빌드하는 경우 :</target>
        </trans-unit>
        <trans-unit id="5326c62b422be5d15a751d74a2dc4fcf60deb938" translate="yes" xml:space="preserve">
          <source>Or calls the following if the process is to terminate:</source>
          <target state="translated">또는 프로세스가 종료 될 경우 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="ba69cd0427a638368d97eab4ad9466aab5343d29" translate="yes" xml:space="preserve">
          <source>Or perhaps in combination with constants:</source>
          <target state="translated">또는 상수와 함께 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="01433e00bc9b318bce7a3cc505bdb311b1e7b75c" translate="yes" xml:space="preserve">
          <source>Or resulting in the next clause being tested in function heads and case expressions.</source>
          <target state="translated">또는 함수 절과 대소 문자 표현에서 다음 절을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="0045ed6a97a1146a04c393e163018af002e6d4f9" translate="yes" xml:space="preserve">
          <source>Or what happens if the server goes down in the middle of sending a message, leaving the sending client hanging forever in the &lt;code&gt;await_result&lt;/code&gt; function?</source>
          <target state="translated">또는 메시지를 보내는 도중에 서버가 다운되어 보내는 클라이언트가 &lt;code&gt;await_result&lt;/code&gt; 함수에 영원히 매달려 있으면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="66e4dcf09aeb43d320a42f1b4be9f68e9c1bc539" translate="yes" xml:space="preserve">
          <source>Oracle Java SE JDK -- The Java Development Kit (Standard Edition). Required for building the application &lt;code&gt;jinterface&lt;/code&gt;. At least version 1.6.0 of the JDK is required.</source>
          <target state="translated">Oracle Java SE JDK-Java 개발 키트 (Standard Edition). 응용 프로그램 &lt;code&gt;jinterface&lt;/code&gt; 를 빌드하는 데 필요합니다 . JDK 버전 1.6.0 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d2f0ae466f7c5d340f95e5db43c368a9a3b0bc8a" translate="yes" xml:space="preserve">
          <source>Orders &lt;code&gt;Common Test&lt;/code&gt; to repeat execution of the cases in the group a given number of times, or until any, or all, cases fail or succeed.</source>
          <target state="translated">주어진 횟수만큼, 또는 일부 또는 전부가 실패하거나 성공할 때까지 그룹에서 사례 실행을 반복하도록 &lt;code&gt;Common Test&lt;/code&gt; 를 주문 합니다.</target>
        </trans-unit>
        <trans-unit id="5112607d3f38b5535b071c81b4e3ced527521a31" translate="yes" xml:space="preserve">
          <source>Orders a generic server to exit with the specified &lt;code&gt;Reason&lt;/code&gt; and waits for it to terminate. The &lt;code&gt;gen_server&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; before exiting.</source>
          <target state="translated">지정된 &lt;code&gt;Reason&lt;/code&gt; 를 사용하여 일반 서버를 종료하도록 명령하고 종료 될 때까지 기다립니다. &lt;code&gt;gen_server&lt;/code&gt; 의 과정은 호출 &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; 종료하기 전에.</target>
        </trans-unit>
        <trans-unit id="54d7ea1c4f89a8a332559591ee4debf050cee229" translate="yes" xml:space="preserve">
          <source>Orders event manager &lt;code&gt;EventMgrRef&lt;/code&gt; to exit with the specifies &lt;code&gt;Reason&lt;/code&gt; and waits for it to terminate. Before terminating, &lt;code&gt;gen_event&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate(stop,...)&lt;/a&gt;&lt;/code&gt; for each installed event handler.</source>
          <target state="translated">이벤트 관리자 &lt;code&gt;EventMgrRef&lt;/code&gt; 가 지정된 &lt;code&gt;Reason&lt;/code&gt; 를 사용하여 종료하도록 명령 하고 종료를 기다립니다. 종료하기 전에 &lt;code&gt;gen_event&lt;/code&gt; 는 설치된 각 이벤트 핸들러에 대해 &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate(stop,...)&lt;/a&gt;&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="a3f48e6002fbd3799add791dc0a450399f2f90c2" translate="yes" xml:space="preserve">
          <source>Orders the &lt;code&gt;gen_statem&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;ServerRef&lt;/a&gt;&lt;/code&gt; to exit with the specified &lt;code&gt;Reason&lt;/code&gt; and waits for it to terminate. The &lt;code&gt;gen_statem&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; before exiting.</source>
          <target state="translated">순서 붙이고 &lt;code&gt;gen_statem&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;ServerRef&lt;/a&gt;&lt;/code&gt; 지정된와 출구 &lt;code&gt;Reason&lt;/code&gt; 와이 종료 할 때까지 기다립니다. &lt;code&gt;gen_statem&lt;/code&gt; 는 호출 &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; 종료하기 전에.</target>
        </trans-unit>
        <trans-unit id="21b34b1ca6772cefd2286c0a8bd7c2c47fffae8f" translate="yes" xml:space="preserve">
          <source>Orders the process to exit with the specified &lt;code&gt;Reason&lt;/code&gt; and waits for it to terminate.</source>
          <target state="translated">주문 지정된와 출구 공정 &lt;code&gt;Reason&lt;/code&gt; 와이 종료 할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="a61c180dee133a0d4fb6e99797fd60387a9fa2b3" translate="yes" xml:space="preserve">
          <source>Orders the process to terminate with the specified &lt;code&gt;Reason&lt;/code&gt;. The termination is done asynchronously, so it is not guaranteed that the process is terminated when the function returns.</source>
          <target state="translated">프로세스를 지정된 &lt;code&gt;Reason&lt;/code&gt; 종료하도록 명령합니다 . 종료는 비동기 적으로 수행되므로 함수가 리턴 될 때 프로세스가 종료되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ccb8dd4b62075b726550209fcb7d0f2adb744793" translate="yes" xml:space="preserve">
          <source>Ordinary characters that must match the next input character.</source>
          <target state="translated">다음 입력 문자와 일치해야하는 일반 문자</target>
        </trans-unit>
        <trans-unit id="e33058c8aca144db86ea897b7f2317a8d1c1af9d" translate="yes" xml:space="preserve">
          <source>Origin-Host AVP</source>
          <target state="translated">오리진 호스트 AVP</target>
        </trans-unit>
        <trans-unit id="66ca57643d2d91ab73b0b3763337e2fec53749fc" translate="yes" xml:space="preserve">
          <source>Origin-Realm AVP</source>
          <target state="translated">원산지 AVP</target>
        </trans-unit>
        <trans-unit id="236ee85d9ea34d47b8bad24ef64b77e613147f6c" translate="yes" xml:space="preserve">
          <source>Origin-State-Id AVP</source>
          <target state="translated">원산지 상태 ID AVP</target>
        </trans-unit>
        <trans-unit id="8a2b322ac24d0d94010349833607bcb6c362fc2e" translate="yes" xml:space="preserve">
          <source>Origin-State-Id is optional but, if configured, will be included in outgoing CER/CEA and DWR/DWA messages. Setting a value of &lt;code&gt;0&lt;/code&gt; (zero) is equivalent to not setting a value, as documented in RFC 6733. The function &lt;code&gt;&lt;a href=&quot;#origin_state_id-0&quot;&gt;origin_state_id/0&lt;/a&gt;&lt;/code&gt; can be used as to retrieve a value that is computed when the diameter application is started.</source>
          <target state="translated">Origin-State-Id는 선택 사항이지만 구성된 경우 발신 CER / CEA 및 DWR / DWA 메시지에 포함됩니다. RFC 6733에 설명 된대로 값을 &lt;code&gt;0&lt;/code&gt; 으로 설정하는 것은 값을 설정하지 않는 것과 같습니다. &lt;code&gt;&lt;a href=&quot;#origin_state_id-0&quot;&gt;origin_state_id/0&lt;/a&gt;&lt;/code&gt; 함수 는 직경 응용 프로그램이 시작될 때 계산되는 값을 검색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2f0776017330240cb474fc09a019aea6a403d19" translate="yes" xml:space="preserve">
          <source>Originating a Request</source>
          <target state="translated">요청 시작</target>
        </trans-unit>
        <trans-unit id="c10643b85fbfbd4fbb63e61c52588993e2ffbfa5" translate="yes" xml:space="preserve">
          <source>Oriya</source>
          <target state="translated">Oriya</target>
        </trans-unit>
        <trans-unit id="42cb2600c161bf7bf85310fb50b63266488059bf" translate="yes" xml:space="preserve">
          <source>Osmanya</source>
          <target state="translated">Osmanya</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="e5f5f875b3d15fa11fe3de5896a4e66d7c090218" translate="yes" xml:space="preserve">
          <source>Other (rare) error condition, such as &lt;code&gt;{error, estale}&lt;/code&gt; if reading from an NFS file system.</source>
          <target state="translated">NFS 파일 시스템에서 읽을 경우 &lt;code&gt;{error, estale}&lt;/code&gt; 와 같은 기타 (드문) 오류 조건 .</target>
        </trans-unit>
        <trans-unit id="03965c1e12674420b58d4f32742d1467e2298c0b" translate="yes" xml:space="preserve">
          <source>Other ASN.1 types and values can differ much from these figures. It is therefore important that you, in every case where you intend to use either of these decodes, perform some tests that show if you will benefit your purpose.</source>
          <target state="translated">다른 ASN.1 유형과 값은이 수치와 크게 다를 수 있습니다. 따라서이 디코드 중 하나를 사용하려는 모든 경우에 목적에 도움이 될지 보여주는 몇 가지 테스트를 수행하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="c1385ef92fd62e1027c2fed35303a7d7f5d9ee0f" translate="yes" xml:space="preserve">
          <source>Other Flags</source>
          <target state="translated">다른 깃발</target>
        </trans-unit>
        <trans-unit id="db5a9e63db2cdafd4d9a58a4d1e203908f440948" translate="yes" xml:space="preserve">
          <source>Other PCRE-specific options can be set by the application when the compiling or matching functions are called. Sometimes the pattern can contain special leading sequences, such as (*CRLF), to override what the application has set or what has been defaulted. Details are provided in section &lt;code&gt;&lt;a href=&quot;#newline_sequences&quot;&gt;Newline Sequences&lt;/a&gt;&lt;/code&gt; earlier.</source>
          <target state="translated">컴파일 또는 일치 함수가 호출 될 때 응용 프로그램에서 다른 PCRE 특정 옵션을 설정할 수 있습니다. 경우에 따라 패턴에는 (* CRLF)와 같은 특수 선행 시퀀스가 ​​포함되어 응용 프로그램에서 설정 한 내용이나 기본값을 무시할 수 있습니다. 자세한 내용은 이전 &lt;code&gt;&lt;a href=&quot;#newline_sequences&quot;&gt;Newline Sequences&lt;/a&gt;&lt;/code&gt; 섹션에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="d244aac16bfbb22cf74ea0c33f98a68a4cf6d192" translate="yes" xml:space="preserve">
          <source>Other Tools</source>
          <target state="translated">다른 도구들</target>
        </trans-unit>
        <trans-unit id="302303d7df48684e7df86411d56b9659af7d97fb" translate="yes" xml:space="preserve">
          <source>Other Unicode encodings than integers representing code points or UTF-8 in binaries are referred to as &quot;external encodings&quot;. The ISO Latin-1 encoding is in binaries and lists referred to as latin1-encoding.</source>
          <target state="translated">바이너리에서 코드 포인트 또는 UTF-8을 나타내는 정수 이외의 다른 유니 코드 인코딩을 &quot;외부 인코딩&quot;이라고합니다. ISO Latin-1 인코딩은 바이너리로되어 있으며 latin1-encoding이라고합니다.</target>
        </trans-unit>
        <trans-unit id="ed0cea3720246c22c3a30bbc4492b0bc7ca1703c" translate="yes" xml:space="preserve">
          <source>Other addresses are possible, for example Linux implements &quot;Abstract Addresses&quot;. See the documentation for Unix Domain Sockets on your system, normally &lt;code&gt;unix&lt;/code&gt; in manual section 7.</source>
          <target state="translated">다른 주소들도 가능하다. 예를 들어 리눅스는 &quot;Abstract Addresses&quot;를 구현한다. 시스템의 Unix Domain Sockets 설명서 , 일반적으로 매뉴얼 섹션 7에서 &lt;code&gt;unix&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dd29435e6c5d5cb295da7f257e1e953a855af66c" translate="yes" xml:space="preserve">
          <source>Other applications like ssl/tls or https might have options that are passed down to the &lt;code&gt;public_key:pkix_verify_hostname&lt;/code&gt;. You will probably not have to call it directly</source>
          <target state="translated">ssl / tls 또는 https와 같은 다른 애플리케이션에는 &lt;code&gt;public_key:pkix_verify_hostname&lt;/code&gt; 으로 전달되는 옵션이있을 수 있습니다 . 당신은 아마 그것을 직접 호출 할 필요가 없습니다</target>
        </trans-unit>
        <trans-unit id="88b1b43caa29bc1ae4d1876c05734a9c8181e624" translate="yes" xml:space="preserve">
          <source>Other characters represent themselves. Only filenames that have exactly the same character in the same position match. Matching is case-sensitive, for example, &quot;a&quot; does not match &quot;A&quot;.</source>
          <target state="translated">다른 문자는 자신을 나타냅니다. 동일한 위치에서 문자가 정확히 동일한 파일 이름 만 일치합니다. 일치는 대소 문자를 구분합니다. 예를 들어 &quot;a&quot;는 &quot;A&quot;와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14464638b9e33ce4c0d8ac32a7485fa9028da73b" translate="yes" xml:space="preserve">
          <source>Other combinations, such as &lt;code&gt;{Module,'_',Arity}&lt;/code&gt;, are not allowed. Local functions match wildcards only if option &lt;code&gt;local&lt;/code&gt; is in &lt;code&gt;FlagList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{Module,'_',Arity}&lt;/code&gt; 와 같은 다른 조합 은 허용되지 않습니다. local 함수 는 &lt;code&gt;local&lt;/code&gt; 옵션 이 &lt;code&gt;FlagList&lt;/code&gt; 에있는 경우에만 와일드 카드와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="885f57e5d13595e0ee4f423a6b4d92f55b55a565" translate="yes" xml:space="preserve">
          <source>Other configuration parameters exist, to be used for customizing the overload protection behaviour. The same parameters are used both in the standard handler and the disk_log handler, and are documented in the &lt;code&gt;&lt;a href=&quot;logger_chapter#overload_protection&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">과부하 보호 동작을 사용자 정의하는 데 사용되는 다른 구성 매개 변수가 있습니다. 표준 핸들러와 disk_log 핸들러 모두에서 동일한 매개 변수가 사용되며 &lt;code&gt;&lt;a href=&quot;logger_chapter#overload_protection&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd2063ac325b87a9381eab00b4e9d208668c9217" translate="yes" xml:space="preserve">
          <source>Other constants (terms and bound variables), all regarded as false</source>
          <target state="translated">다른 상수 (용어 및 바운드 변수) (모두 거짓으로 간주 됨)</target>
        </trans-unit>
        <trans-unit id="c3ac4deb2089a1f649e5fdba0cc491bef7b16555" translate="yes" xml:space="preserve">
          <source>Other directories in the development environment may be needed. If source code from languages other than Erlang is used, for instance C-code for NIFs, that code should be placed in a separate directory. By convention it is recommended to prefix such directories with the language name, for example &lt;code&gt;c_src&lt;/code&gt; for C, &lt;code&gt;java_src&lt;/code&gt; for Java or &lt;code&gt;go_src&lt;/code&gt; for Go. Directories with &lt;code&gt;_src&lt;/code&gt; suffix indicates that it is a part of the application and the compilation step. The final build artifacts should target the &lt;code&gt;priv/lib&lt;/code&gt; or &lt;code&gt;priv/bin&lt;/code&gt; directories.</source>
          <target state="translated">개발 환경의 다른 디렉토리가 필요할 수 있습니다. Erlang 이외의 언어로 작성된 소스 코드 (예 : NIF의 C 코드)를 사용하는 경우 해당 코드는 별도의 디렉토리에 배치해야합니다. 관례는 예를 들어, 언어 이름과 같은 디렉토리를 접두사하는 것이 좋습니다 &lt;code&gt;c_src&lt;/code&gt; C를 들어, &lt;code&gt;java_src&lt;/code&gt; 자바 또는 &lt;code&gt;go_src&lt;/code&gt; 이동합니다. &lt;code&gt;_src&lt;/code&gt; 접미사가있는 디렉토리는 이것이 응용 프로그램 및 컴파일 단계의 일부임을 나타냅니다. 최종 빌드 아티팩트는 &lt;code&gt;priv/lib&lt;/code&gt; 또는 &lt;code&gt;priv/bin&lt;/code&gt; 디렉토리를 대상으로해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ae9077b452914a72240410cfd78d06125441adc8" translate="yes" xml:space="preserve">
          <source>Other errors than these can occur, as the &lt;code&gt;erlang:halt/1&lt;/code&gt; BIF can generate any message. If the message is not generated by the BIF and does not occur in the list above, it can be because of an error in the emulator. There can however be unusual messages, not mentioned here, which are still connected to an application failure. There is much more information available, so a thorough reading of the crash dump can reveal the crash reason. The size of processes, the number of ETS tables, and the Erlang data on each process stack can be useful to find the problem.</source>
          <target state="translated">&lt;code&gt;erlang:halt/1&lt;/code&gt; BIF가 모든 메시지를 생성 할 수 있으므로 이들 이외의 다른 오류가 발생할 수 있습니다 . 메시지가 BIF에 의해 생성되지 않고 위 목록에 나타나지 않으면 에뮬레이터의 오류 때문일 수 있습니다. 그러나 여기에 언급되지 않은 비정상적인 메시지가 여전히있을 수 있으며 여전히 응용 프로그램 오류와 연결되어 있습니다. 사용 가능한 정보가 훨씬 많으므로 크래시 덤프를 자세히 읽으면 크래시 원인을 알 수 있습니다. 각 프로세스 스택의 프로세스 크기, ETS 테이블 수 및 Erlang 데이터는 문제를 찾는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b60efd3d69d9ecb24af68e74d348360a07b5ed6b" translate="yes" xml:space="preserve">
          <source>Other features:</source>
          <target state="translated">다른 기능들:</target>
        </trans-unit>
        <trans-unit id="a58b6dc215a18ea443d12708103eda9efd5d5635" translate="yes" xml:space="preserve">
          <source>Other fields are rarely used. For complete information, see &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions for SCTP&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 필드는 거의 사용되지 않습니다. 자세한 정보는 &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions for SCTP&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbd6de3d10f2fc66f49e8c1b345f9c0059ed9ba5" translate="yes" xml:space="preserve">
          <source>Other functions that create sets are &lt;code&gt;&lt;a href=&quot;#from_external-2&quot;&gt;from_external/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#from_sets-1&quot;&gt;from_sets/1&lt;/a&gt;&lt;/code&gt;. Special cases of &lt;code&gt;from_term/2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#a_function-1&quot;&gt;a_function/1,2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#empty_set-0&quot;&gt;empty_set/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#family-1&quot;&gt;family/1,2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#relation-1&quot;&gt;relation/1,2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#set-1&quot;&gt;set/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">세트를 작성하는 다른 함수는 &lt;code&gt;&lt;a href=&quot;#from_external-2&quot;&gt;from_external/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#from_sets-1&quot;&gt;from_sets/1&lt;/a&gt;&lt;/code&gt; 입니다. &lt;code&gt;from_term/2&lt;/code&gt; 의 특수한 경우 는 &lt;code&gt;&lt;a href=&quot;#a_function-1&quot;&gt;a_function/1,2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#empty_set-0&quot;&gt;empty_set/0&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#family-1&quot;&gt;family/1,2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#relation-1&quot;&gt;relation/1,2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#set-1&quot;&gt;set/1,2&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4d8b80772e0f8b1d872444ba18ad7b48f4cc4cfe" translate="yes" xml:space="preserve">
          <source>Other letter</source>
          <target state="translated">다른 편지</target>
        </trans-unit>
        <trans-unit id="1e25df6c3ebdcf4ee11a121bc16f17e603a8b7df" translate="yes" xml:space="preserve">
          <source>Other match specs activates tracing of calls to &lt;code&gt;et:trace_me/4,5&lt;/code&gt; accordingly with &lt;code&gt;erlang:trace_pattern/2&lt;/code&gt;.</source>
          <target state="translated">다른 일치 스펙 은 &lt;code&gt;erlang:trace_pattern/2&lt;/code&gt; 에 따라 &lt;code&gt;et:trace_me/4,5&lt;/code&gt; 에 대한 호출 추적을 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="51ca0c2d75fe6310043838d9fb791594049c226f" translate="yes" xml:space="preserve">
          <source>Other modules can provide a nullary &lt;code&gt;TraverseFun&lt;/code&gt;. An example is &lt;code&gt;gb_table:table/1&lt;/code&gt; in section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 모듈은 null &lt;code&gt;TraverseFun&lt;/code&gt; 을 제공 할 수 있습니다 . 예제는 &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; 섹션의 &lt;code&gt;gb_table:table/1&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="3022c490a2bd62676beabc0c1b504084140a7de5" translate="yes" xml:space="preserve">
          <source>Other number</source>
          <target state="translated">다른 번호</target>
        </trans-unit>
        <trans-unit id="97bd01729246532af9de85d0c3ab1ddb360d5a4e" translate="yes" xml:space="preserve">
          <source>Other options are:</source>
          <target state="translated">다른 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="599ffbd6e95e9102a19874cfc765e0666e6a5f25" translate="yes" xml:space="preserve">
          <source>Other options:</source>
          <target state="translated">다른 옵션:</target>
        </trans-unit>
        <trans-unit id="997739492917d646490ffd1fec1419fa6e98b907" translate="yes" xml:space="preserve">
          <source>Other priorities than &lt;code&gt;normal&lt;/code&gt; are normally not needed. When other priorities are used, use them with care, &lt;strong&gt;especially&lt;/strong&gt; priority &lt;code&gt;high&lt;/code&gt;. A process on priority &lt;code&gt;high&lt;/code&gt; is only to perform work for short periods. Busy looping for long periods in a &lt;code&gt;high&lt;/code&gt; priority process causes most likely problems, as important OTP servers run on priority &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">이외의 우선 순위 &lt;code&gt;normal&lt;/code&gt; 일반적으로 필요하지 않습니다. 다른 우선 순위를 사용할 때는 &lt;strong&gt;특히&lt;/strong&gt; 우선 순위가 &lt;code&gt;high&lt;/code&gt; 주의해서 사용하십시오 . 우선 순위가 &lt;code&gt;high&lt;/code&gt; 프로세스 는 단기간 동안 작업을 수행하는 것입니다. 중요한 OTP 서버가 우선 순위가 &lt;code&gt;normal&lt;/code&gt; 실행되기 &lt;code&gt;high&lt;/code&gt; 우선 순위 가 높은 프로세스 에서 장시간의 바쁜 루핑은 문제가 발생할 가능성이 높습니다 .</target>
        </trans-unit>
        <trans-unit id="8dea56314c50bfb058a315994e322b37ac05f071" translate="yes" xml:space="preserve">
          <source>Other processes can read the digraph (default).</source>
          <target state="translated">다른 프로세스는이 그래프를 읽을 수 있습니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="20bc18ec4477d52890b4d5aac0d2cbc92eb389a4" translate="yes" xml:space="preserve">
          <source>Other punctuation</source>
          <target state="translated">다른 구두점</target>
        </trans-unit>
        <trans-unit id="ec9bcce7656bc224a64ce97ba2b5bd792aeb6391" translate="yes" xml:space="preserve">
          <source>Other requirements:</source>
          <target state="translated">다른 요구 사항 :</target>
        </trans-unit>
        <trans-unit id="e28544fd56893780941b6044efc20d476e8af135" translate="yes" xml:space="preserve">
          <source>Other states do not normally occur in the output from &lt;code&gt;connect/*&lt;/code&gt;. Rather, they can occur in &lt;code&gt;#sctp_assoc_change{}&lt;/code&gt; events received instead of data in &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; calls. All of them indicate losing the association because of various error conditions, and are listed here for the sake of completeness:</source>
          <target state="translated">다른 상태는 일반적으로 &lt;code&gt;connect/*&lt;/code&gt; 의 출력에서 ​​발생하지 않습니다 . 오히려 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; 호출 의 데이터 대신 수신 된 &lt;code&gt;#sctp_assoc_change{}&lt;/code&gt; 이벤트 에서 발생할 수 있습니다 . 그들 모두는 다양한 오류 조건으로 인해 연결이 끊어 졌음을 나타내며 완전성을 위해 여기에 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="d0a8ec65432412d24f9c042216a5db6173548a99" translate="yes" xml:space="preserve">
          <source>Other symbol</source>
          <target state="translated">다른 상징</target>
        </trans-unit>
        <trans-unit id="577365eaf2b9f85de95baced848e1cc288b22cd3" translate="yes" xml:space="preserve">
          <source>Other table access than reading, such as calling &lt;code&gt;InfoFun&lt;/code&gt;, is assumed to be OK at any time.</source>
          <target state="translated">&lt;code&gt;InfoFun&lt;/code&gt; 호출과 같은 읽기 이외의 다른 테이블 액세스는 언제든지 정상인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="24654f0b470cc0982d088fd0b8978733097cbe87" translate="yes" xml:space="preserve">
          <source>Other tuples than the ones defined are ignored.</source>
          <target state="translated">정의 된 것 이외의 다른 튜플은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="15363bfb92322f3fe6ad2718148dd35e33fdb154" translate="yes" xml:space="preserve">
          <source>Other types can be read, and are returned as binaries.</source>
          <target state="translated">다른 유형을 읽을 수 있으며 이진으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cdedf43490cc2ff1da81cd679f5229c3c1cc0879" translate="yes" xml:space="preserve">
          <source>Other types cannot be added or changed.</source>
          <target state="translated">다른 유형은 추가하거나 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="70e28792612da22154d851b53e24c945311f74a0" translate="yes" xml:space="preserve">
          <source>Other useful function(s) for debugging the agent are:</source>
          <target state="translated">에이전트 디버깅에 유용한 다른 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ebc4c4dd4036621515140929b889184c451a256" translate="yes" xml:space="preserve">
          <source>Other useful information can be found at our GitHub wiki:</source>
          <target state="translated">다른 유용한 정보는 GitHub 위키에서 찾을 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="198dd873fca5b5131fb3a9224056b4006b7b1428" translate="yes" xml:space="preserve">
          <source>Otherwise all options valid for function &lt;code&gt;compile/2&lt;/code&gt; are also allowed. Options allowed both for compilation and execution of a match, namely &lt;code&gt;anchored&lt;/code&gt; and &lt;code&gt;{newline, NLSpec}&lt;/code&gt;, affect both the compilation and execution if present together with a non-precompiled regular expression.</source>
          <target state="translated">그렇지 않으면 함수 &lt;code&gt;compile/2&lt;/code&gt; 에 유효한 모든 옵션 도 허용됩니다. &lt;code&gt;anchored&lt;/code&gt; 및 &lt;code&gt;{newline, NLSpec}&lt;/code&gt; 과 같이 일치 컴파일 및 실행에 허용되는 옵션은 사전 컴파일되지 않은 정규식과 함께있는 경우 컴파일 및 실행에 모두 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="e30cc24dff4a8e4fd3505b91e8729e2519c09a8a" translate="yes" xml:space="preserve">
          <source>Otherwise an &lt;code&gt;undef&lt;/code&gt; exception is raised.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;undef&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="75ef1eb055dcb5b6ca421038e624721c946bf1b2" translate="yes" xml:space="preserve">
          <source>Otherwise recreates the exported seed and returns the state. See also &lt;code&gt;&lt;a href=&quot;#export_seed-0&quot;&gt;export_seed/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면 내 보낸 시드를 다시 작성하고 상태를 리턴합니다. &lt;code&gt;&lt;a href=&quot;#export_seed-0&quot;&gt;export_seed/0&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b75f15a942afae834871232ccf0ba77e7558f01c" translate="yes" xml:space="preserve">
          <source>Otherwise recreates the exported seed in the process dictionary, and returns the state. See also &lt;code&gt;&lt;a href=&quot;#export_seed-0&quot;&gt;export_seed/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면 프로세스 사전에서 내 보낸 시드를 다시 작성하고 상태를 리턴합니다. &lt;code&gt;&lt;a href=&quot;#export_seed-0&quot;&gt;export_seed/0&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d87b5659173c759cef0ab46aa4a7fb80d00cb3c5" translate="yes" xml:space="preserve">
          <source>Otherwise the &lt;code&gt;gen_statem&lt;/code&gt; goes into &lt;code&gt;receive&lt;/code&gt; or hibernation (if &lt;code&gt;&lt;a href=&quot;#type-hibernate&quot;&gt;hibernate()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;) to wait for the next message. In hibernation the next non-system event awakens the &lt;code&gt;gen_statem&lt;/code&gt;, or rather the next incoming message awakens the &lt;code&gt;gen_statem&lt;/code&gt;, but if it is a system event it goes right back into hibernation. When a new message arrives the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; is called with the corresponding event, and we start again from the top of this sequence.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;gen_statem&lt;/code&gt; 은 다음 메시지를 기다리기 위해 &lt;code&gt;receive&lt;/code&gt; 또는 최대 절전 모드 ( &lt;code&gt;&lt;a href=&quot;#type-hibernate&quot;&gt;hibernate()&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 )로 들어갑니다. 최대 절전 모드에서는 다음 비 시스템 이벤트가 &lt;code&gt;gen_statem&lt;/code&gt; 을 깨우 거나 다음 수신 메시지가 &lt;code&gt;gen_statem&lt;/code&gt; 깨우지 만 시스템 이벤트 인 경우 다시 최대 절전 모드로 돌아갑니다. 새로운 메시지가 도착하면 해당 이벤트와 함께 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 이 호출 되고이 시퀀스의 맨 처음부터 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="ca5bba34991dc2c836a13ba5d708caac9b079155" translate="yes" xml:space="preserve">
          <source>Otherwise the same as &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;Server = Server_or_Actions&lt;/code&gt; and &lt;code&gt;Actions = []&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;Server = Server_or_Actions&lt;/code&gt; 및 &lt;code&gt;Actions = []&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="7a3e409482e92d7312335dbbdf06b6be17b9baa1" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;Name&lt;/code&gt; is to be a filename.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;Name&lt;/code&gt; 은 파일 이름 이됩니다.</target>
        </trans-unit>
        <trans-unit id="00aeea6c12722cc94d58e2f90a9872f32740085b" translate="yes" xml:space="preserve">
          <source>Otherwise, end the cluster.</source>
          <target state="translated">그렇지 않으면 클러스터를 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="721932d781d83d618f6a74c5ad3eea7a7cd92826" translate="yes" xml:space="preserve">
          <source>Otherwise, if function &lt;code&gt;'$handle_undefined_function'/2&lt;/code&gt; is exported, it is called as &lt;code&gt;'$handle_undefined_function'(&lt;/code&gt;Function, Args).</source>
          <target state="translated">그렇지 않으면, 함수 &lt;code&gt;'$handle_undefined_function'/2&lt;/code&gt; 가 내보내 &lt;code&gt;'$handle_undefined_function'(&lt;/code&gt; Function, Args)이라고합니다.</target>
        </trans-unit>
        <trans-unit id="bd45978f4d37112b76326ff6ee1522682525ecd5" translate="yes" xml:space="preserve">
          <source>Otherwise, if the calling process is trapping exits, and/or &lt;code&gt;PidOrPort&lt;/code&gt; is remote, &lt;code&gt;link/1&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, but an exit signal with reason &lt;code&gt;noproc&lt;/code&gt; is sent to the calling process.</source>
          <target state="translated">그렇지 않으면, 호출 프로세스가 종료를 트래핑하고 /하거나 &lt;code&gt;PidOrPort&lt;/code&gt; 가 원격 인 경우, &lt;code&gt;link/1&lt;/code&gt; 은 &lt;code&gt;true&lt;/code&gt; 를 리턴 하지만, &lt;code&gt;noproc&lt;/code&gt; 이 있는 종료 신호가 호출 프로세스로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="da43d3db522f1f4c7c74271266d895bb136efa89" translate="yes" xml:space="preserve">
          <source>Otherwise, it returns, if possible, the value of &lt;code&gt;apply(Fun, Args)&lt;/code&gt; after an attempt is made to autoload &lt;code&gt;Module&lt;/code&gt;. If this is not possible, the call fails with exit reason &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면 가능하면 &lt;code&gt;Module&lt;/code&gt; 자동로드 시도 후 &lt;code&gt;apply(Fun, Args)&lt;/code&gt; 값을 리턴합니다 . 이것이 가능하지 않은 경우 종료 이유 &lt;code&gt;undef&lt;/code&gt; 로 호출이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="cacbdaf48917ea52fc8e545a2f82b0aa7f975a90" translate="yes" xml:space="preserve">
          <source>Otherwise, the &lt;code&gt;gen_server&lt;/code&gt; process terminates immediately.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;gen_server&lt;/code&gt; 프로세스가 즉시 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="94d92e282ea81d3ea91c85388ba278cc5356a549" translate="yes" xml:space="preserve">
          <source>Otherwise, the &lt;code&gt;gen_statem&lt;/code&gt; is immediately terminated.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;gen_statem&lt;/code&gt; 이 즉시 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4310db4b8648fe0dc2ce19712dff695071b2d572" translate="yes" xml:space="preserve">
          <source>Otherwise, this option (&lt;code&gt;timeout&lt;/code&gt;) is used as the negotiation timeout only and there is no connection timeout set</source>
          <target state="translated">그렇지 않으면이 옵션 ( &lt;code&gt;timeout&lt;/code&gt; )이 협상 제한 시간으로 만 사용되며 연결 제한 시간이 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="6fc1fe0597f841fdd158f43b025edbb7cffcfe68" translate="yes" xml:space="preserve">
          <source>Our driver data is also extended, we keep track of the socket used for communication with postgres, and also the port, which is needed when we send data to the port with &lt;code&gt;driver_output&lt;/code&gt;. We have a flag &lt;code&gt;connecting&lt;/code&gt; to tell whether the driver is waiting for a connection or waiting for the result of a query. (This is needed, as the entry &lt;code&gt;ready_io&lt;/code&gt; is called both when connecting and when there is a query result.)</source>
          <target state="translated">드라이버 데이터도 확장되어 postgres와 통신하는 데 사용되는 소켓과 &lt;code&gt;driver_output&lt;/code&gt; 을 사용하여 포트로 데이터를 보낼 때 필요한 포트를 추적 합니다. 드라이버가 &lt;code&gt;connecting&lt;/code&gt; 을 기다리고 있는지 또는 쿼리 결과를 기다리고 있는지 알려주기 위해 연결 하는 플래그 가 있습니다. ( 연결할 때와 쿼리 결과가있을 때 &lt;code&gt;ready_io&lt;/code&gt; 항목 이 모두 호출 되므로 이는 필수 입니다.)</target>
        </trans-unit>
        <trans-unit id="6438f58ef6f89d7bd274993ab31926c276b0cdc6" translate="yes" xml:space="preserve">
          <source>Our new release, &quot;SECOND&quot;, is now the current release, but we can also see that our &quot;FIRST&quot; release is still permanent. This means that if the node would be restarted now, it would come up running the &quot;FIRST&quot; release again.</source>
          <target state="translated">새 릴리스 인 &quot;SECOND&quot;가 현재 릴리스이지만 &quot;FIRST&quot;릴리스가 여전히 영구적임을 알 수 있습니다. 즉, 노드가 지금 다시 시작되면 &quot;FIRST&quot;릴리스를 다시 실행하게됩니다.</target>
        </trans-unit>
        <trans-unit id="867b0a717a764649cafbff4174c1ab32b19f1745" translate="yes" xml:space="preserve">
          <source>Outbound binary encoding in binaries</source>
          <target state="translated">바이너리의 아웃 바운드 바이너리 인코딩</target>
        </trans-unit>
        <trans-unit id="59cc61305ef8bc0545ffbb32a894c83964c825a0" translate="yes" xml:space="preserve">
          <source>Outbound percent-encoding in lists and binaries</source>
          <target state="translated">목록 및 이진의 아웃 바운드 백분율 인코딩</target>
        </trans-unit>
        <trans-unit id="f6e7d5a9598d3a265926a82b01d7b1deec941696" translate="yes" xml:space="preserve">
          <source>Outgoing reply messages will be segmented as needed (see &lt;code&gt;max_pdu_size&lt;/code&gt; below). Segment messages are sent all at once (i.e. no acknowledgement awaited before sending the next segment).</source>
          <target state="translated">발신 응답 메시지는 필요에 따라 분류됩니다 (아래 &lt;code&gt;max_pdu_size&lt;/code&gt; 참조). 세그먼트 메시지는 한 번에 모두 전송됩니다 (즉, 다음 세그먼트를 보내기 전에 승인이 대기하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="db1552aa4fc51b4e7d46fa43321f568f6c953efb" translate="yes" xml:space="preserve">
          <source>Outgoing reply messages will be segmented as needed (see &lt;code&gt;max_pdu_size&lt;/code&gt; below). This value, K, indicate the outstanding window, i.e. how many segments can be outstanding (not acknowledged) at any given time.</source>
          <target state="translated">발신 응답 메시지는 필요에 따라 분류됩니다 (아래 &lt;code&gt;max_pdu_size&lt;/code&gt; 참조). 이 값 K는 미해결 기간, 즉 주어진 시간에 미해결 될 수있는 세그먼트 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="685ad21255174c3fd01ff63b9cc3a546c7bc9ee3" translate="yes" xml:space="preserve">
          <source>Output messages are sent without packet lengths. A user-defined protocol must be used between the Erlang process and the external object.</source>
          <target state="translated">출력 메시지는 패킷 길이없이 전송됩니다. Erlang 프로세스와 외부 개체간에 사용자 정의 프로토콜을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1940195f61826f0bf71c04e3e654bd8f616a6a5b" translate="yes" xml:space="preserve">
          <source>Outputs information from parsing the input file and generating the internal tables.</source>
          <target state="translated">입력 파일을 구문 분석하고 내부 테이블을 생성하여 정보를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="73c0f26b2a7bd194530650de5672dbbf0d19179d" translate="yes" xml:space="preserve">
          <source>Outputs the message &lt;code&gt;Text&lt;/code&gt; (which can be a plain string, an IO-list, or just an atom). The result is always &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">메시지 &lt;code&gt;Text&lt;/code&gt; (일반 문자열, IO- 목록 또는 원자 일 수 있음)를 출력합니다. 결과는 항상 &lt;code&gt;ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47cdda9f06afdf9eb8f93de49e9252c88f5dc624" translate="yes" xml:space="preserve">
          <source>Outside a character class, a backslash followed by a digit &amp;gt; 0 (and possibly further digits) is a back reference to a capturing subpattern earlier (that is, to its left) in the pattern, provided there have been that many previous capturing left parentheses.</source>
          <target state="translated">문자 클래스 외부에서 백 슬래시 다음에 숫자&amp;gt; 0 (및 추가 숫자)이 오는 경우 패턴에서 이전의 캡처 하위 패턴 (즉, 왼쪽)에 대한 역 참조입니다. .</target>
        </trans-unit>
        <trans-unit id="cd6a3b6581f40f67d6587389bf34b0d7ce3534cd" translate="yes" xml:space="preserve">
          <source>Outside a character class, a dot in the pattern matches any character in the subject string except (by default) a character that signifies the end of a line.</source>
          <target state="translated">문자 클래스 외부에서 패턴의 점은 기본적으로 줄의 끝을 나타내는 문자를 제외하고 제목 문자열의 모든 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="81930bbe14ad5ca39d3f1c5a979f1ece61d2de2e" translate="yes" xml:space="preserve">
          <source>Outside a character class, by default, the escape sequence \R matches any Unicode newline sequence. In non-UTF-8 mode, \R is equivalent to the following:</source>
          <target state="translated">문자 클래스 외부에서 기본적으로 이스케이프 시퀀스 \ R은 모든 유니 코드 개행 시퀀스와 일치합니다. 비 UTF-8 모드에서 \ R은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85b61b9dbc2dcc77797a3d987698e978f37365fe" translate="yes" xml:space="preserve">
          <source>Outside a character class, in the default matching mode, the circumflex character is an assertion that is true only if the current matching point is at the start of the subject string. If argument &lt;code&gt;startoffset&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; is non-zero, circumflex can never match if option &lt;code&gt;multiline&lt;/code&gt; is unset. Inside a character class, circumflex has an entirely different meaning (see below).</source>
          <target state="translated">문자 클래스 외부의 기본 일치 모드에서 곡절 문자는 현재 일치 지점이 제목 문자열의 시작 부분에있는 경우에만 적용되는 어설 션입니다. &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 의 인수 &lt;code&gt;startoffset&lt;/code&gt; 이 0이 아니면 옵션 &lt;code&gt;multiline&lt;/code&gt; 이 설정되지 않은 경우 circumflex는 절대 일치하지 않습니다 . 캐릭터 클래스 내에서 곡절 반경은 완전히 다른 의미를 갖습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="96066ed4fc24874155ae3f2d4ec23afe749bc90e" translate="yes" xml:space="preserve">
          <source>Outside a character class, the escape sequence \C matches any data unit, regardless if a UTF mode is set. One data unit is one byte. Unlike a dot, \C always matches line-ending characters. The feature is provided in Perl to match individual bytes in UTF-8 mode, but it is unclear how it can usefully be used. As \C breaks up characters into individual data units, matching one unit with \C in a UTF mode means that the remaining string can start with a malformed UTF character. This has undefined results, as PCRE assumes that it deals with valid UTF strings.</source>
          <target state="translated">문자 클래스 외부에서 이스케이프 시퀀스 \ C는 UTF 모드가 설정되어 있는지 여부에 관계없이 모든 데이터 단위와 일치합니다. 하나의 데이터 단위는 1 바이트입니다. 점과 달리 \ C는 항상 줄 끝 문자와 일치합니다. 이 기능은 UTF-8 모드에서 개별 바이트와 일치하도록 Perl에 제공되지만 유용하게 사용할 수있는 방법은 확실하지 않습니다. \ C는 문자를 개별 데이터 단위로 나누므로 UTF 모드에서 하나의 단위를 \ C와 일치 시키면 나머지 문자열이 잘못된 UTF 문자로 시작할 수 있습니다. PCRE가 유효한 UTF 문자열을 처리한다고 가정하므로 정의되지 않은 결과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d06e3f0473ed837ae5eabca58e86d752a67b3e6e" translate="yes" xml:space="preserve">
          <source>Over time, as the Framework has evolved from SNMPv1 , through SNMPv2, to SNMPv3 the definitions of each of these architectural components have become richer and more clearly defined, but the fundamental architecture has remained consistent.</source>
          <target state="translated">프레임 워크가 SNMPv1에서 SNMPv2를 통해 SNMPv3으로 발전함에 따라 시간이 지남에 따라 이러한 각 아키텍처 구성 요소의 정의가 더욱 풍부하고 명확하게 정의되었지만 기본 아키텍처는 일관되게 유지되었습니다.</target>
        </trans-unit>
        <trans-unit id="cef9305d1dcaaa55a42c6722272e0c832cae51ee" translate="yes" xml:space="preserve">
          <source>Overload protection</source>
          <target state="translated">과부하 보호</target>
        </trans-unit>
        <trans-unit id="1024473923480d46de1a6ce534031a4fb8bf2fe9" translate="yes" xml:space="preserve">
          <source>Overload protection activated on one node does not affect other nodes, where the tracing continues as normal. &lt;code&gt;ttb:stop/0,1&lt;/code&gt; fetches data from all clients, including everything collected before the activation of overload protection.</source>
          <target state="translated">한 노드에서 활성화 된 과부하 보호는 추적이 정상적으로 계속되는 다른 노드에는 영향을 미치지 않습니다. &lt;code&gt;ttb:stop/0,1&lt;/code&gt; 은 과부하 보호를 활성화하기 전에 수집 된 모든 것을 포함하여 모든 클라이언트에서 데이터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9872bf40547ca2f3f14680ffa0287ececed0c74a" translate="yes" xml:space="preserve">
          <source>Override protocol version when sending a message by adding the item &lt;code&gt;{protocol_version, integer()}&lt;/code&gt; to the Options. See &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;cast&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{protocol_version, integer()}&lt;/code&gt; 을 옵션 에 추가하여 메시지를 보낼 때 프로토콜 버전을 대체 하십시오. &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;cast&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="07d3d194fae83d351901e71d428409c25c0a3d51" translate="yes" xml:space="preserve">
          <source>Override the default, which is to analyze BEAM files, and analyze starting from Erlang source code instead.</source>
          <target state="translated">BEAM 파일을 분석하는 기본 설정을 대체하고 대신 Erlang 소스 코드에서 시작하여 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="15565d57245d3503a665b06bb1ebc90f34652149" translate="yes" xml:space="preserve">
          <source>Overrides any value set by function &lt;code&gt;&lt;a href=&quot;#set_options-1&quot;&gt;set_options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#set_options-1&quot;&gt;set_options&lt;/a&gt;&lt;/code&gt; 함수로 설정된 값을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="e903860e59ffb2ebea40577767dba45a92e0e0e5" translate="yes" xml:space="preserve">
          <source>Overrides the default definition of a newline in the subject string, which is LF (ASCII 10) in Erlang.</source>
          <target state="translated">제목 문자열에서 줄 바꿈의 기본 정의 인 Erlang의 LF (ASCII 10)를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="2178a71f4d4796adf7ebfc54ce9d2c304cda5e26" translate="yes" xml:space="preserve">
          <source>Overrides which callback module is used. Defaults to &lt;code&gt;inet_sctp&lt;/code&gt; for IPv4 and &lt;code&gt;inet6_sctp&lt;/code&gt; for IPv6.</source>
          <target state="translated">사용되는 콜백 모듈을 재정의합니다. IPv4의 경우 기본값은 &lt;code&gt;inet_sctp&lt;/code&gt; 이고 IPv6의 경우 &lt;code&gt;inet6_sctp&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9febcfe22539c2d72353741f4a91ee3eee5e5d0a" translate="yes" xml:space="preserve">
          <source>Overrides which callback module is used. Defaults to &lt;code&gt;inet_tcp&lt;/code&gt; for IPv4 and &lt;code&gt;inet6_tcp&lt;/code&gt; for IPv6.</source>
          <target state="translated">사용되는 콜백 모듈을 재정의합니다. IPv4의 경우 기본값은 &lt;code&gt;inet_tcp&lt;/code&gt; 이고 IPv6의 경우 &lt;code&gt;inet6_tcp&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fb4575b7495ce7d57228d043087de6f17605a208" translate="yes" xml:space="preserve">
          <source>Overrides which callback module is used. Defaults to &lt;code&gt;inet_udp&lt;/code&gt; for IPv4 and &lt;code&gt;inet6_udp&lt;/code&gt; for IPv6.</source>
          <target state="translated">사용되는 콜백 모듈을 재정의합니다. IPv4의 경우 기본값은 &lt;code&gt;inet_udp&lt;/code&gt; 이고 IPv6의 경우 &lt;code&gt;inet6_udp&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d263dc838fe87831b80976b412672c3d8e02db11" translate="yes" xml:space="preserve">
          <source>Owners can subscribe to &lt;strong&gt;notifications&lt;/strong&gt;, messages of the form &lt;code&gt;{disk_log, Node, Log, Info}&lt;/code&gt;, which are sent from the disk log process when certain events occur, see the functions and in particular the &lt;code&gt;open/1&lt;/code&gt; option &lt;code&gt;&lt;a href=&quot;#notify&quot;&gt;notify&lt;/a&gt;&lt;/code&gt;. A log can have many owners, but a process cannot own a log more than once. However, the same process can open the log as a user more than once.</source>
          <target state="translated">소유자는 특정 이벤트가 발생할 때 디스크 로그 프로세스에서 전송되는 &lt;code&gt;{disk_log, Node, Log, Info}&lt;/code&gt; 형식의 메시지 인 &lt;strong&gt;알림에&lt;/strong&gt; 가입 할 수 있습니다 . 기능 및 특히 &lt;code&gt;open/1&lt;/code&gt; 옵션 &lt;code&gt;&lt;a href=&quot;#notify&quot;&gt;notify&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 . 로그에는 많은 소유자가있을 수 있지만 프로세스는 로그를 두 번 이상 소유 할 수 없습니다. 그러나 동일한 프로세스에서 사용자로 로그를 두 번 이상 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bf7d16b62f8d7d4458289a41b07f8e9ce785647" translate="yes" xml:space="preserve">
          <source>Owners subscribing to notifications are notified of an error with an &lt;code&gt;error_status&lt;/code&gt; message if the error reason tag is &lt;code&gt;invalid_header&lt;/code&gt; or &lt;code&gt;file_error&lt;/code&gt;.</source>
          <target state="translated">오류 이유 태그가 &lt;code&gt;invalid_header&lt;/code&gt; 또는 &lt;code&gt;file_error&lt;/code&gt; 인 경우 알림을 구독하는 소유자에게 &lt;code&gt;error_status&lt;/code&gt; 메시지 와 함께 오류가 통지 됩니다.</target>
        </trans-unit>
        <trans-unit id="47ddeec7968a11b2b2f13154dd59f134a92d672e" translate="yes" xml:space="preserve">
          <source>Owners subscribing to notifications normally receive a &lt;code&gt;wrap&lt;/code&gt; message, but if an error occurs with a reason tag of &lt;code&gt;invalid_header&lt;/code&gt; or &lt;code&gt;file_error&lt;/code&gt;, an &lt;code&gt;error_status&lt;/code&gt; message is sent.</source>
          <target state="translated">알림을 구독하는 소유자는 일반적으로 &lt;code&gt;wrap&lt;/code&gt; 메시지를 수신 하지만 &lt;code&gt;invalid_header&lt;/code&gt; 또는 &lt;code&gt;file_error&lt;/code&gt; 이유 태그로 오류가 발생 하면 &lt;code&gt;error_status&lt;/code&gt; 메시지가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="ea5a85a9a6040f17a47f7ba2c861df0d45af862d" translate="yes" xml:space="preserve">
          <source>Owners subscribing to notifications receive a &lt;code&gt;truncate&lt;/code&gt; message.</source>
          <target state="translated">알림을 구독하는 소유자는 &lt;code&gt;truncate&lt;/code&gt; 메시지를 받습니다 .</target>
        </trans-unit>
        <trans-unit id="69f83710cbb8ab650339dad71d8d01aeb1346e48" translate="yes" xml:space="preserve">
          <source>Owners subscribing to notifications receive message &lt;code&gt;read_only&lt;/code&gt;, &lt;code&gt;blocked_log&lt;/code&gt;, or &lt;code&gt;format_external&lt;/code&gt; if the item cannot be written on the log, and possibly one of the messages &lt;code&gt;wrap&lt;/code&gt;, &lt;code&gt;full&lt;/code&gt;, or &lt;code&gt;error_status&lt;/code&gt; if an item is written on the log. Message &lt;code&gt;error_status&lt;/code&gt; is sent if something is wrong with the header function or if a file error occurs.</source>
          <target state="translated">알림을 구독하는 소유자 는 항목을 로그에 쓸 수없는 경우 &lt;code&gt;read_only&lt;/code&gt; , &lt;code&gt;blocked_log&lt;/code&gt; 또는 &lt;code&gt;format_external&lt;/code&gt; 메시지 를 받고 , 항목이 로그에 기록되면 &lt;code&gt;wrap&lt;/code&gt; , &lt;code&gt;full&lt;/code&gt; 또는 &lt;code&gt;error_status&lt;/code&gt; 메시지 중 하나를 받을 수 있습니다. 헤더 기능에 문제가 있거나 파일 오류가 발생하면 &lt;code&gt;error_status&lt;/code&gt; 메시지 가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="fc53f78ca51a5c5588dc259bf4af7ddf544cabda" translate="yes" xml:space="preserve">
          <source>Owners subscribing to notifications receive message &lt;code&gt;read_only&lt;/code&gt;, &lt;code&gt;blocked_log&lt;/code&gt;, or &lt;code&gt;format_external&lt;/code&gt; if the items cannot be written on the log, and possibly one or more of the messages &lt;code&gt;wrap&lt;/code&gt;, &lt;code&gt;full&lt;/code&gt;, and &lt;code&gt;error_status&lt;/code&gt; if items are written on the log. Message &lt;code&gt;error_status&lt;/code&gt; is sent if something is wrong with the header function or if a file error occurs.</source>
          <target state="translated">알림을 구독하는 소유자 는 항목을 로그에 쓸 수없는 경우 &lt;code&gt;read_only&lt;/code&gt; , &lt;code&gt;blocked_log&lt;/code&gt; 또는 &lt;code&gt;format_external&lt;/code&gt; 메시지 를 받고 , 항목이 로그에 기록되면 하나 이상의 메시지 &lt;code&gt;wrap&lt;/code&gt; , &lt;code&gt;full&lt;/code&gt; 및 &lt;code&gt;error_status&lt;/code&gt; 를 받습니다. 헤더 기능에 문제가 있거나 파일 오류가 발생하면 &lt;code&gt;error_status&lt;/code&gt; 메시지 가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="36f780fdbda5b2b2ce85c9ebb57086d1880ae757" translate="yes" xml:space="preserve">
          <source>PC</source>
          <target state="translated">PC</target>
        </trans-unit>
        <trans-unit id="d561f41a3e664cc0a8835732d97f931d41f72800" translate="yes" xml:space="preserve">
          <source>PCRE (and Perl) also recognize the Posix syntax [.ch.] and [=ch=] where &quot;ch&quot; is a &quot;collating element&quot;, but these are not supported, and an error is given if they are encountered.</source>
          <target state="translated">PCRE (및 Perl)도 Posix 구문 [.ch.] 및 [= ch =]를 인식합니다. 여기서 &quot;ch&quot;는 &quot;collating element&quot;이지만 지원되지 않으며 오류가 발생하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c7e1a3a2c06dd5d35852b8fd7f58b67f48a9a787" translate="yes" xml:space="preserve">
          <source>PCRE contains some optimizations that are used to speed up matching by running some checks at the start of each match attempt. For example, it can know the minimum length of matching subject, or that a particular character must be present. When one of these optimizations bypasses the running of a match, any included backtracking verbs are not processed. processed. You can suppress the start-of-match optimizations by setting option &lt;code&gt;no_start_optimize&lt;/code&gt; when calling &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;, or by starting the pattern with (*NO_START_OPT).</source>
          <target state="translated">PCRE에는 각 일치 시도가 시작될 때 일부 검사를 실행하여 일치 속도를 높이는 데 사용되는 일부 최적화가 포함되어 있습니다. 예를 들어, 일치하는 주제의 최소 길이를 알거나 특정 문자가 있어야 함을 알 수 있습니다. 이러한 최적화 중 하나가 일치하는 실행을 무시하면 포함 된 모든 역 추적 동사가 처리되지 않습니다. 가공. &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 를 호출 할 때 &lt;code&gt;no_start_optimize&lt;/code&gt; 옵션을 설정 하거나 (* NO_START_OPT)로 패턴을 시작하여 일치 시작 최적화를 억제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b299ec8de52cb755bee6ddf20ed30414c507680c" translate="yes" xml:space="preserve">
          <source>PCRE differs from Perl in its handling of backtracking verbs in repeated groups. For example, consider:</source>
          <target state="translated">PCRE는 반복 그룹에서 역 추적 동사를 처리한다는 점에서 Perl과 다릅니다. 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3cc508b88f2a03ca5b89b7762b1f20cd8e196650" translate="yes" xml:space="preserve">
          <source>PCRE does not allow \C to appear in lookbehind assertions (described below) in a UTF mode, as this would make it impossible to calculate the length of the lookbehind.</source>
          <target state="translated">PCRE는 \ C가 UTF 모드에서 lookbehind 어설 션 (아래 설명 참조)에 표시되지 않도록하여 lookbehind의 길이를 계산할 수 없게합니다.</target>
        </trans-unit>
        <trans-unit id="1cbd2b65949cf73edf1658ac5a4fd6ddc42bd83c" translate="yes" xml:space="preserve">
          <source>PCRE has an optimization that automatically &quot;possessifies&quot; certain simple pattern constructs. For example, the sequence A+B is treated as A++B, as there is no point in backtracking into a sequence of A:s when B must follow.</source>
          <target state="translated">PCRE에는 특정 간단한 패턴 구성을 자동으로 &quot;포지션&quot;하는 최적화 기능이 있습니다. 예를 들어, 시퀀스 A + B는 B가 따라야 할 때 A : s 시퀀스로 역 추적 할 지점이 없으므로 A ++ B로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="f0fc58f08622bddb7678d55039d7a59b7bc48042" translate="yes" xml:space="preserve">
          <source>PCRE supports an extension to Oniguruma: if a number is preceded by a plus or minus sign, it is taken as a relative reference, for example:</source>
          <target state="translated">PCRE는 Oniguruma에 대한 확장을 지원합니다. 숫자 앞에 더하기 또는 빼기 부호가 오는 경우 상대 참조로 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dec962e9c5b1c207185027f300491448a37e5072" translate="yes" xml:space="preserve">
          <source>PCRE supports five conventions for indicating line breaks in strings: a single CR (carriage return) character, a single LF (line feed) character, the two-character sequence CRLF, any of the three preceding, and any Unicode newline sequence.</source>
          <target state="translated">PCRE는 문자열에서 줄 바꿈을 표시하기위한 단일 CR (캐리지 리턴) 문자, 단일 LF (줄 바꿈) 문자, 두 문자 시퀀스 CRLF, 앞의 세 가지 문자 및 유니 코드 줄 바꿈 시퀀스의 다섯 가지 규칙을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="fa87f3aabeb31ade442c9f5f35c180a263350233" translate="yes" xml:space="preserve">
          <source>PEM files, used by ssl API-functions, are cached. The cache is regularly checked to see if any cache entries should be invalidated, however this function provides a way to unconditionally clear the whole cache.</source>
          <target state="translated">ssl API 기능에서 사용되는 PEM 파일이 캐시됩니다. 캐시 항목을 무효화해야하는지 확인하기 위해 캐시를 정기적으로 점검하지만이 기능을 사용하면 전체 캐시를 무조건 지울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cd905f009accd2df9f1ab5f8a17d5b5c38872a6" translate="yes" xml:space="preserve">
          <source>Package the installation in &lt;code&gt;&amp;lt;RELEASE_DIR&amp;gt;&lt;/code&gt;, place it wherever you want on your target machine, and run the &lt;code&gt;Install&lt;/code&gt; script on your target machine:</source>
          <target state="translated">&lt;code&gt;&amp;lt;RELEASE_DIR&amp;gt;&lt;/code&gt; 에 설치를 패키지하고 대상 시스템에서 원하는 위치에 배치 한 후 대상 시스템에서 &lt;code&gt;Install&lt;/code&gt; 스크립트를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2b5d604d7f06e3d1f95fc5dc804a3221b871852" translate="yes" xml:space="preserve">
          <source>Packed Encoding Rules (PER), both the aligned and unaligned variant</source>
          <target state="translated">정렬 된 변형과 정렬되지 않은 변형 모두 팩형 인코딩 규칙 (PER)</target>
        </trans-unit>
        <trans-unit id="e71a71de422305a16e28853d413eeb1fe6adaa8c" translate="yes" xml:space="preserve">
          <source>Packets can be sent to the returned socket &lt;code&gt;Socket&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt;. Packets sent from the peer are delivered as messages (unless &lt;code&gt;{active, false}&lt;/code&gt; is specified in the option list for the listening socket, in which case packets are retrieved by calling &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 반환 된 소켓 &lt;code&gt;Socket&lt;/code&gt; 에 패킷을 보낼 수 있습니다 . 피어에서 보낸 패킷은 메시지로 전달됩니다 ( 리스닝 소켓의 옵션 목록에 &lt;code&gt;{active, false}&lt;/code&gt; 가 지정 되지 않은 경우 &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 패킷을 검색하는 경우 ).</target>
        </trans-unit>
        <trans-unit id="999e0ae2fd1b7fad6eb65fd1659da2a1e9675393" translate="yes" xml:space="preserve">
          <source>Packets can be sent to the returned socket &lt;code&gt;Socket&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt;. Packets sent from the peer are delivered as messages:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 반환 된 소켓 &lt;code&gt;Socket&lt;/code&gt; 에 패킷을 보낼 수 있습니다 . 피어에서 보낸 패킷은 메시지로 배달됩니다.</target>
        </trans-unit>
        <trans-unit id="a9cbdaa25497050f647df52257a52127df4c6dcd" translate="yes" xml:space="preserve">
          <source>Packets consist of a header specifying the number of bytes in the packet, followed by that number of bytes. The header length can be one, two, or four bytes, and containing an unsigned integer in big-endian byte order. Each send operation generates the header, and the header is stripped off on each receive operation.</source>
          <target state="translated">패킷은 패킷의 바이트 수를 지정하는 헤더와 그 바이트 수로 구성됩니다. 헤더 길이는 1, 2 또는 4 바이트 일 수 있으며 빅 엔디안 바이트 순서로 부호없는 정수를 포함합니다. 각 전송 작업은 헤더를 생성하고 각 수신 작업에서 헤더가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="d0d592f83333abf860b4699c427f31bf34be37ff" translate="yes" xml:space="preserve">
          <source>Packets consist of a header specifying the number of bytes in the packet, followed by that number of bytes. The length of the header can be one, two, or four bytes; the order of the bytes is big-endian. The header is stripped off when the packet is returned.</source>
          <target state="translated">패킷은 패킷의 바이트 수를 지정하는 헤더와 그 바이트 수로 구성됩니다. 헤더의 길이는 1, 2 또는 4 바이트 일 수 있습니다. 바이트의 순서는 빅 엔디안입니다. 패킷이 반환되면 헤더가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b9b4528e2d3cf117ea52177114c90e71d60519dc" translate="yes" xml:space="preserve">
          <source>Pads &lt;code&gt;String&lt;/code&gt; to &lt;code&gt;Length&lt;/code&gt; with grapheme cluster &lt;code&gt;Char&lt;/code&gt;. &lt;code&gt;Dir&lt;/code&gt;, which can be &lt;code&gt;leading&lt;/code&gt;, &lt;code&gt;trailing&lt;/code&gt;, or &lt;code&gt;both&lt;/code&gt;, indicates where the padding should be added.</source>
          <target state="translated">패드 &lt;code&gt;String&lt;/code&gt; 에 &lt;code&gt;Length&lt;/code&gt; 그래 핀 클러스터 &lt;code&gt;Char&lt;/code&gt; . &lt;code&gt;leading&lt;/code&gt; , &lt;code&gt;trailing&lt;/code&gt; 또는 &lt;code&gt;both&lt;/code&gt; 수있는 &lt;code&gt;Dir&lt;/code&gt; 은 패딩을 추가 할 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="62bfbd510157d2b2d32934302b71a771f9fb8488" translate="yes" xml:space="preserve">
          <source>Pahawh_Hmong</source>
          <target state="translated">Pahawh_Hmong</target>
        </trans-unit>
        <trans-unit id="ea98d285a450c2d86578176798a994d47e81c69f" translate="yes" xml:space="preserve">
          <source>Palmyrene</source>
          <target state="translated">Palmyrene</target>
        </trans-unit>
        <trans-unit id="eb7595283333290680efe8f59bad4f5efb16ee78" translate="yes" xml:space="preserve">
          <source>Paragraph separator</source>
          <target state="translated">단락 구분자</target>
        </trans-unit>
        <trans-unit id="ea1f90af11a63290665889dc8c71bcb46ef20ff7" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;ArgL&lt;/code&gt; is a list of the following options:</source>
          <target state="translated">매개 변수 &lt;code&gt;ArgL&lt;/code&gt; 은 다음 옵션의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="481ff685beef8edc87c1c25cefdedd5dd3072163" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;FlagList&lt;/code&gt; is a list of options. The following are the valid options:</source>
          <target state="translated">Parameter &lt;code&gt;FlagList&lt;/code&gt; 는 옵션 목록입니다. 유효한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb58c9f9f7662428e1102cf73d06277b9a9f8408" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;Item&lt;/code&gt; specifies which driver to monitor (the driver name) and which state change to monitor. The parameter is a tuple of arity two whose first element is the driver name and second element is one of the following:</source>
          <target state="translated">매개 변수 &lt;code&gt;Item&lt;/code&gt; 은 모니터링 할 드라이버 (드라이버 이름) 및 모니터링 할 상태 변경을 지정합니다. 이 매개 변수는 첫 번째 요소가 드라이버 이름이고 두 번째 요소가 다음 중 하나 인 arity 2의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="ffc2bcb064cabdbae071c079e72742a961a53078" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;MgrAgentConfName&lt;/code&gt; in the functions is to be a name you allocate in your test suite using a &lt;code&gt;require&lt;/code&gt; statement. Example (where &lt;code&gt;MgrAgentConfName = snmp_mgr_agent&lt;/code&gt;):</source>
          <target state="translated">함수의 &lt;code&gt;MgrAgentConfName&lt;/code&gt; 매개 변수 는 &lt;code&gt;require&lt;/code&gt; 문을 사용하여 테스트 스위트에 할당 한 이름 입니다. 예 (여기서 &lt;code&gt;MgrAgentConfName = snmp_mgr_agent&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="67a9b163fdabde30f306efc624573ddbed00e72a" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;Options&lt;/code&gt; is a list of atoms that specifies table type, access rights, key position, and whether the table is named. Default values are used for omitted options. This means that not specifying any options (&lt;code&gt;[]&lt;/code&gt;) is the same as specifying &lt;code&gt;[set, protected, {keypos,1}, {heir,none}, {write_concurrency,false}, {read_concurrency,false}]&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;Options&lt;/code&gt; 은 테이블 유형, 액세스 권한, 키 위치 및 테이블 이름 지정 여부를 지정하는 원자 목록입니다. 생략 된 옵션에는 기본값이 사용됩니다. 이는 옵션 ( &lt;code&gt;[]&lt;/code&gt; )을 지정하지 않으면 &lt;code&gt;[set, protected, {keypos,1}, {heir,none}, {write_concurrency,false}, {read_concurrency,false}]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d795107fbe2f795cba5a352dc3d9eb7ed96b4b2" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;UserPrivate&lt;/code&gt; is typically the result of opening a low-level structure like a file descriptor or an SFTP channel id. The different &lt;code&gt;Fun&lt;/code&gt; clauses operate on that very term.</source>
          <target state="translated">매개 변수 &lt;code&gt;UserPrivate&lt;/code&gt; 는 일반적으로 파일 디스크립터 또는 SFTP 채널 ID와 같은 저수준 구조를 연 결과입니다. 다른 &lt;code&gt;Fun&lt;/code&gt; 절은 바로 그 용어에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="178879c4f36263f5398b5fe0c1d2b17ffe37778c" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;buf&lt;/code&gt; points to the data to send, and &lt;code&gt;len&lt;/code&gt; is the number of bytes.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 매개 변수 는 전송할 데이터를 가리키며 &lt;code&gt;len&lt;/code&gt; 은 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="8c3b0a66603387ab483d713b83c217fa59d3b555" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;event&lt;/code&gt; identifies an OS-specific event object. On Unix systems, the functions &lt;code&gt;select&lt;/code&gt;/&lt;code&gt;poll&lt;/code&gt; are used. The event object must be a socket or pipe (or other object that &lt;code&gt;select&lt;/code&gt;/&lt;code&gt;poll&lt;/code&gt; can use). On Windows, the Win32 API function &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; is used. This places other restrictions on the event object; see the Win32 SDK documentation.</source>
          <target state="translated">매개 변수 &lt;code&gt;event&lt;/code&gt; 는 OS 특정 이벤트 객체를 식별합니다. 유닉스 시스템에서는 &lt;code&gt;select&lt;/code&gt; / &lt;code&gt;poll&lt;/code&gt; 기능 이 사용됩니다. 이벤트 오브젝트는 소켓 또는 파이프 여야합니다 (또는 &lt;code&gt;select&lt;/code&gt; / &lt;code&gt;poll&lt;/code&gt; 할 수있는 다른 오브젝트 ). Windows에서는 Win32 API 함수 &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; 가 사용됩니다. 이로 인해 이벤트 객체에 다른 제한이 적용됩니다. Win32 SDK 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="164ddca5ff1565ca4f9e0ee9934496e78da5103a" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;extra_db_nodes&lt;/code&gt; can also be used on disc based nodes.</source>
          <target state="translated">디스크 기반 노드에서 &lt;code&gt;extra_db_nodes&lt;/code&gt; 매개 변수를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="19911242e8e159e23d1389d3ca9b289be8023784" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;group_names_or_paths&lt;/code&gt; specifies one or more group names and/or one or more group paths. At startup, &lt;code&gt;Common Test&lt;/code&gt; searches for matching groups in the group definitions tree (that is, the list returned from &lt;code&gt;Suite:groups/0&lt;/code&gt;; for details, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;group_names_or_paths&lt;/code&gt; 는 하나 이상의 그룹 이름 및 / 또는 하나 이상의 그룹 경로를 지정합니다. &lt;code&gt;Common Test&lt;/code&gt; 는 시작시 그룹 정의 트리에서 일치하는 그룹 (즉, &lt;code&gt;Suite:groups/0&lt;/code&gt; 에서 리턴 된 목록)을 검색합니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1db4151b626c494895a3303e3e9dc15c541574a3" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;mode&lt;/code&gt; is a bitwise OR combination of &lt;code&gt;ERL_DRV_READ&lt;/code&gt;, &lt;code&gt;ERL_DRV_WRITE&lt;/code&gt;, and &lt;code&gt;ERL_DRV_USE&lt;/code&gt;. The first two specify whether to wait for read events and/or write events. A fired read event calls &lt;code&gt;&lt;a href=&quot;driver_entry#ready_input&quot;&gt;ready_input&lt;/a&gt;&lt;/code&gt; and a fired write event calls &lt;code&gt;&lt;a href=&quot;driver_entry#ready_output&quot;&gt;ready_output&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;mode&lt;/code&gt; 는 &lt;code&gt;ERL_DRV_READ&lt;/code&gt; , &lt;code&gt;ERL_DRV_WRITE&lt;/code&gt; 및 &lt;code&gt;ERL_DRV_USE&lt;/code&gt; 의 비트 단위 OR 조합입니다 . 처음 두 개는 이벤트 읽기 및 / 또는 쓰기 이벤트 대기 여부를 지정합니다. 발생 된 읽기 이벤트는 &lt;code&gt;&lt;a href=&quot;driver_entry#ready_input&quot;&gt;ready_input&lt;/a&gt;&lt;/code&gt; 을 호출 하고 발생 된 쓰기 이벤트는 &lt;code&gt;&lt;a href=&quot;driver_entry#ready_output&quot;&gt;ready_output&lt;/a&gt;&lt;/code&gt; 을 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="24b7e614b3fb7661e3c4bfa669cf966c8e65b191" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;offset&lt;/code&gt; is an offset into the binary and &lt;code&gt;len&lt;/code&gt; is the number of bytes to send.</source>
          <target state="translated">매개 변수 &lt;code&gt;offset&lt;/code&gt; 은 이진에 대한 오프셋이며 &lt;code&gt;len&lt;/code&gt; 은 보낼 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="2c09fe112bbeb4630f395aac2bcdfe148aca5521" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;on&lt;/code&gt; is to be &lt;code&gt;1&lt;/code&gt; for setting events and &lt;code&gt;0&lt;/code&gt; for clearing them.</source>
          <target state="translated">이벤트 설정의 경우 매개 변수 &lt;code&gt;on&lt;/code&gt; 은 &lt;code&gt;1&lt;/code&gt; 이고 , 지우 려면 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f74566537c8d9ce233e9f86c48184e78edfc96b6" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;port&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; an ordinary port handle, but a port handle converted using &lt;code&gt;&lt;a href=&quot;#driver_mk_port&quot;&gt;driver_mk_port&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;port&lt;/code&gt; 입니다 &lt;strong&gt;하지&lt;/strong&gt; 일반 포트 핸들,하지만 포트 핸들을 사용하여 변환 &lt;code&gt;&lt;a href=&quot;#driver_mk_port&quot;&gt;driver_mk_port&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="31842056db03aa395dd407bca74bccb68a5a26bb" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;process&lt;/code&gt; is to be the return value of an earlier call to &lt;code&gt;&lt;a href=&quot;#driver_caller&quot;&gt;driver_caller&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#driver_connected&quot;&gt;driver_connected&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">매개 변수 &lt;code&gt;process&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#driver_caller&quot;&gt;driver_caller&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#driver_connected&quot;&gt;driver_connected&lt;/a&gt;&lt;/code&gt; 호출 에 대한 이전 호출의 리턴 값입니다 .</target>
        </trans-unit>
        <trans-unit id="66a261af649e0d1c255cd39045bb5e13b9ca6186" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;skip&lt;/code&gt; is a number of bytes to skip of the &lt;code&gt;ev&lt;/code&gt; vector from the head.</source>
          <target state="translated">매개 변수 &lt;code&gt;skip&lt;/code&gt; 은 헤드에서 &lt;code&gt;ev&lt;/code&gt; 벡터 를 건너 뛸 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="64e4fb00a7835e330447d940e7db2ce15d43c569" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;term&lt;/code&gt; points to an array of &lt;code&gt;ErlDrvTermData&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; elements. This array contains terms described in the driver term format. Every term consists of 1-4 elements in the array. The first term has a term type and then arguments. Parameter &lt;code&gt;port&lt;/code&gt; specifies the sending port.</source>
          <target state="translated">매개 변수 &lt;code&gt;term&lt;/code&gt; 는 &lt;code&gt;n&lt;/code&gt; 개의 요소 가있는 &lt;code&gt;ErlDrvTermData&lt;/code&gt; 의 배열을 가리 킵니다 . 이 배열은 드라이버 용어 형식으로 설명 된 용어를 포함합니다. 모든 용어는 배열에서 1-4 개의 요소로 구성됩니다. 첫 번째 용어에는 용어 유형과 인수가 있습니다. 파라미터 &lt;code&gt;port&lt;/code&gt; 는 송신 포트를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="619a12371bd91db45106e0947981ba34d3c2bd49" translate="yes" xml:space="preserve">
          <source>Parameterization, which is defined in X.683, can be used when defining types, values, value sets, classes, objects, or object sets. A part of a definition can be supplied as a parameter. For example, if a &lt;code&gt;Type&lt;/code&gt; is used in a definition with a certain purpose, you want the type name to express the intention. This can be done with parameterization.</source>
          <target state="translated">X.683에 정의 된 매개 변수화는 유형, 값, 값 세트, 클래스, 오브젝트 또는 오브젝트 세트를 정의 할 때 사용할 수 있습니다. 정의의 일부를 매개 변수로 제공 할 수 있습니다. 예를 들어, 특정 목적으로 정의에 &lt;code&gt;Type&lt;/code&gt; 을 사용하는 경우 유형 이름에 의도를 표시하려고합니다. 이것은 매개 변수화로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3001577f3d424b071c234b5e5a77e2c797ba8919" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;port&lt;/code&gt;, &lt;code&gt;term&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; work as in &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt;erl_drv_output_term&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; , &lt;code&gt;term&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 매개 변수 는 &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt;erl_drv_output_term&lt;/a&gt;&lt;/code&gt; 에서 와 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="aa047ce05d4bbf51547604b5fd791b6e5ce4e1a0" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;term&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; work as in &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt;erl_drv_output_term&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 매개 변수 는 &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt;erl_drv_output_term&lt;/a&gt;&lt;/code&gt; 에서 와 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="52408a3808b8f3d07d1e351897f44c8601912f48" translate="yes" xml:space="preserve">
          <source>Parameters to be used to call public_key:generate_key/1, to generate a key, or an existing key. Defaults to generating an ECDSA key. Note this could fail if Erlang/OTP is compiled with a very old cryptolib.</source>
          <target state="translated">키 또는 기존 키를 생성하기 위해 public_key : generate_key / 1을 호출하는 데 사용되는 매개 변수입니다. ECDSA 키 생성이 기본값입니다. Erlang / OTP가 매우 오래된 암호로 컴파일 된 경우 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f544c8871ad84d3b8d3ea9af03500476893103ea" translate="yes" xml:space="preserve">
          <source>Parentheses are used for grouping, either to make an expression more readable or to override the default precedence of operators:</source>
          <target state="translated">괄호는 표현식을보다 읽기 쉽게 만들거나 연산자의 기본 우선 순위를 재정의하기 위해 그룹화에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a38e57cb166c131b67e7c17a52a16571f7e59fb9" translate="yes" xml:space="preserve">
          <source>Parenthesized expressions are useful to override &lt;code&gt;&lt;a href=&quot;#prec&quot;&gt;operator precedences&lt;/a&gt;&lt;/code&gt;, for example, in arithmetic expressions:</source>
          <target state="translated">괄호로 묶은 표현식은 &lt;code&gt;&lt;a href=&quot;#prec&quot;&gt;operator precedences&lt;/a&gt;&lt;/code&gt; 를 재정의하는 데 유용합니다 ( 예 : 산술 표현식).</target>
        </trans-unit>
        <trans-unit id="1ec3038821c8e34cb4ca25c92efd7b368a0d8e5a" translate="yes" xml:space="preserve">
          <source>Parse a stream containing an XML document.</source>
          <target state="translated">XML 문서를 포함하는 스트림을 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="8217aea2b6b930a773bd2a30eafc88abe67c2fba" translate="yes" xml:space="preserve">
          <source>Parse file containing an XML document</source>
          <target state="translated">XML 문서를 포함하는 파싱 파일</target>
        </trans-unit>
        <trans-unit id="5a6136b4aa579fcfcffcc46e0f8f8eb6d5603d86" translate="yes" xml:space="preserve">
          <source>Parse file containing an XML document as a stream, DOM style. Wrapper for a call to the XML parser &lt;code&gt;xmerl_scan&lt;/code&gt; with a &lt;code&gt;continuation_fun&lt;/code&gt; for handling streams of XML data. Note that the &lt;code&gt;continuation_fun&lt;/code&gt;, &lt;code&gt;acc_fun&lt;/code&gt;, &lt;code&gt;fetch_fun&lt;/code&gt;, &lt;code&gt;rules&lt;/code&gt; and &lt;code&gt;close_fun&lt;/code&gt; options cannot be user defined using this parser.</source>
          <target state="translated">XML 문서를 스트림, DOM 스타일로 포함하는 파일을 구문 분석하십시오. XML 데이터 스트림을 처리하기위한 &lt;code&gt;continuation_fun&lt;/code&gt; 을 사용하여 XML 구문 분석기 &lt;code&gt;xmerl_scan&lt;/code&gt; 을 호출하기위한 랩퍼 . 있습니다 &lt;code&gt;continuation_fun&lt;/code&gt; , &lt;code&gt;acc_fun&lt;/code&gt; , &lt;code&gt;fetch_fun&lt;/code&gt; , &lt;code&gt;rules&lt;/code&gt; 및 &lt;code&gt;close_fun&lt;/code&gt; 의 옵션이 파서를 사용하여 사용자 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="674e40f858960e6e4df14fbdc24544779fa454b2" translate="yes" xml:space="preserve">
          <source>Parse file containing an XML document as a stream, SAX style. Wrapper for a call to the XML parser &lt;code&gt;xmerl_scan&lt;/code&gt; with a &lt;code&gt;continuation_fun&lt;/code&gt; for handling streams of XML data. Note that the &lt;code&gt;continuation_fun&lt;/code&gt;, &lt;code&gt;acc_fun&lt;/code&gt;, &lt;code&gt;fetch_fun&lt;/code&gt;, &lt;code&gt;rules&lt;/code&gt;, &lt;code&gt;hook_fun&lt;/code&gt;, &lt;code&gt;close_fun&lt;/code&gt; and &lt;code&gt;user_state&lt;/code&gt; options cannot be user defined using this parser.</source>
          <target state="translated">XML 문서를 스트림, SAX 스타일로 포함하는 파일을 구문 분석하십시오. XML 데이터 스트림을 처리하기위한 &lt;code&gt;continuation_fun&lt;/code&gt; 을 사용하여 XML 구문 분석기 &lt;code&gt;xmerl_scan&lt;/code&gt; 을 호출하기위한 랩퍼 . 있습니다 &lt;code&gt;continuation_fun&lt;/code&gt; , &lt;code&gt;acc_fun&lt;/code&gt; , &lt;code&gt;fetch_fun&lt;/code&gt; , &lt;code&gt;rules&lt;/code&gt; , &lt;code&gt;hook_fun&lt;/code&gt; , &lt;code&gt;close_fun&lt;/code&gt; 및 &lt;code&gt;user_state&lt;/code&gt; 옵션이 파서를 사용하여 사용자 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fc9ee985dfae362f5f4036d5f83dc0f5fe590d74" translate="yes" xml:space="preserve">
          <source>Parse file containing an XML document, SAX style. Wrapper for a call to the XML parser &lt;code&gt;xmerl_scan&lt;/code&gt; with a &lt;code&gt;hook_fun&lt;/code&gt; for using xmerl export functionality directly after an entity is parsed.</source>
          <target state="translated">XML 문서, SAX 스타일을 포함하는 파일을 구문 분석하십시오. 엔티티를 구문 분석 한 후 직접 xmerl 내보내기 기능을 사용하기 위해 &lt;code&gt;hook_fun&lt;/code&gt; 을 사용하여 XML 구문 분석기 &lt;code&gt;xmerl_scan&lt;/code&gt; 을 호출하기위한 랩퍼 .</target>
        </trans-unit>
        <trans-unit id="a7e66c978a3bc50b34f2f8f441cb5d45be8ce70b" translate="yes" xml:space="preserve">
          <source>Parse file containing an XML document. This functions uses a default continuation function to read the file in blocks.</source>
          <target state="translated">XML 문서를 포함하는 파일을 구문 분석하십시오. 이 기능은 기본 연속 기능을 사용하여 파일을 블록 단위로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="c11cdcc0a2531ae96dc218c56c12636fa75bf6fe" translate="yes" xml:space="preserve">
          <source>Parse string containing an XML document</source>
          <target state="translated">XML 문서를 포함하는 구문 분석 문자열</target>
        </trans-unit>
        <trans-unit id="6b19e7fcfb29d25095c7a452b5d973ecb668a8f0" translate="yes" xml:space="preserve">
          <source>Parse text and substitute meta-variables.</source>
          <target state="translated">텍스트를 구문 분석하고 메타 변수를 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="f3059059775d564c176b513311505460d999325b" translate="yes" xml:space="preserve">
          <source>Parse text and substitute meta-variables. Takes an initial scanner starting position as first argument.</source>
          <target state="translated">텍스트를 구문 분석하고 메타 변수를 대체하십시오. 최초 스캐너 시작 위치를 첫 번째 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="995f08395199c28811d1c157ebeb410cdf5f6a52" translate="yes" xml:space="preserve">
          <source>Parse text.</source>
          <target state="translated">텍스트를 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="6f88d437ec32b29a09b77bb3c60dda1a500d3d76" translate="yes" xml:space="preserve">
          <source>Parse text. Takes an initial scanner starting position as first argument.</source>
          <target state="translated">텍스트를 구문 분석하십시오. 최초 스캐너 시작 위치를 첫 번째 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2db8f8fef89f426d3dbefc3cc3581aafe79f6ce1" translate="yes" xml:space="preserve">
          <source>Parse the given test specification files and return the tests to run and skip.</source>
          <target state="translated">제공된 테스트 스펙 파일을 구문 분석하고 테스트를 실행하여 건너 뛰십시오.</target>
        </trans-unit>
        <trans-unit id="2163966b8b6a50fd1cf0cca656abeddf8dd5cc71" translate="yes" xml:space="preserve">
          <source>Parse transform for merl.</source>
          <target state="translated">merl에 대한 구문 분석 변환</target>
        </trans-unit>
        <trans-unit id="16b406d744c815ddcee583e6e5df09f0720355fa" translate="yes" xml:space="preserve">
          <source>Parse transform for merl. Enables the use of automatic metavariables and using quasi-quotes in matches and case switches. Also optimizes calls to functions in &lt;code&gt;merl&lt;/code&gt; by partially evaluating them, turning strings to templates, etc., at compile-time.</source>
          <target state="translated">merl에 대한 구문 분석 변환 자동 메타 변수를 사용하고 일치 및 대소 문자 전환에 준 따옴표를 사용할 수 있습니다. 또한 컴파일 타임에 부분적으로 평가하고 문자열을 템플릿으로 바꾸는 등의 방법으로 &lt;code&gt;merl&lt;/code&gt; 함수 호출을 최적화합니다 .</target>
        </trans-unit>
        <trans-unit id="1a936ecbdaa0108bef18e5866e06c3f267270543" translate="yes" xml:space="preserve">
          <source>Parse transformations are used if a programmer wants to use Erlang syntax, but with different semantics. The original Erlang code is then transformed into other Erlang code.</source>
          <target state="translated">프로그래머가 Erlang 구문을 사용하려고하지만 의미가 다른 경우 구문 분석 변환이 사용됩니다. 그런 다음 원래 Erlang 코드는 다른 Erlang 코드로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e2baf70db7b7c168b6c27755c6350a0d8b3a3116" translate="yes" xml:space="preserve">
          <source>Parse transformations are used when a programmer wants to use Erlang syntax but with different semantics. The original Erlang code is then transformed into other Erlang code.</source>
          <target state="translated">프로그래머가 Erlang 구문을 사용하고 싶지만 의미가 다른 경우 구문 분석 변환이 사용됩니다. 그런 다음 원래 Erlang 코드는 다른 Erlang 코드로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="b27625b152a11d3756ff7a956cb8d71acc5d561c" translate="yes" xml:space="preserve">
          <source>Parse trees for Erlang expression, see section &lt;code&gt;The Abstract Format&lt;/code&gt; in the ERTS User's Guide.</source>
          <target state="translated">Erlang 표현식의 구문 분석 트리는 ERTS 사용 설명서의 &lt;code&gt;The Abstract Format&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b485e40955067baa97180fef7a23873d2bbfac9" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;Tokens&lt;/code&gt; as if it was a form. Returns one of the following:</source>
          <target state="translated">&lt;code&gt;Tokens&lt;/code&gt; 을 양식 인 것처럼 구문 분석 합니다. 다음 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="40605f235bf487ac5cc36c28815be60cb52740c7" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;Tokens&lt;/code&gt; as if it was a list of expressions. Returns one of the following:</source>
          <target state="translated">표현식 목록 인 것처럼 &lt;code&gt;Tokens&lt;/code&gt; 을 구문 분석 합니다. 다음 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f5e90d2f7ca99ca3b5931aed84bb2db57dbbc833" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;Tokens&lt;/code&gt; as if it was a term. Returns one of the following:</source>
          <target state="translated">용어 인 것처럼 &lt;code&gt;Tokens&lt;/code&gt; 을 구문 분석합니다 . 다음 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="86ede94d84471001f5bfaece799d5f9fa59c6b81" translate="yes" xml:space="preserve">
          <source>Parses a URI. If no scheme defaults are provided, the value of the &lt;code&gt;&lt;a href=&quot;#scheme_defaults&quot;&gt;scheme_defaults&lt;/a&gt;&lt;/code&gt; function is used.</source>
          <target state="translated">URI를 구문 분석합니다. 구성표 기본값을 제공하지 않으면 &lt;code&gt;&lt;a href=&quot;#scheme_defaults&quot;&gt;scheme_defaults&lt;/a&gt;&lt;/code&gt; 함수 의 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="22aeb59a17ed90dfcd4e4d9f7b96872d034caad8" translate="yes" xml:space="preserve">
          <source>Parses a digit map body</source>
          <target state="translated">숫자 맵 본문을 구문 분석합니다</target>
        </trans-unit>
        <trans-unit id="dd0ff0f3941a66c29a5874954a99087c88f42111" translate="yes" xml:space="preserve">
          <source>Parses a digit map body, represented as a list of characters, into a list of state transitions suited to be evaluated by megaco:eval_digit_map/1,2.</source>
          <target state="translated">문자 목록으로 표시되는 숫자 맵 본문을 megaco : eval_digit_map / 1,2에서 평가하기에 적합한 상태 전이 목록으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="f9c79f9646018440e3ebc591b18276096ccfad27" translate="yes" xml:space="preserve">
          <source>Parses an &lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt;ip_address()&lt;/a&gt;&lt;/code&gt; and returns an IPv4 or IPv6 address string.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt;ip_address()&lt;/a&gt;&lt;/code&gt; 구문 분석하고 IPv4 또는 IPv6 주소 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b6c5f3cfcbd29b09ebd5d2c45e4555d696f66e8a" translate="yes" xml:space="preserve">
          <source>Parses an &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; compliant &lt;code&gt;uri_string()&lt;/code&gt; into a &lt;code&gt;uri_map()&lt;/code&gt;, that holds the parsed components of the &lt;code&gt;URI&lt;/code&gt;. If parsing fails, an error tuple is returned.</source>
          <target state="translated">구문 분석 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; 을 준수 &lt;code&gt;uri_string()&lt;/code&gt; 에 &lt;code&gt;uri_map()&lt;/code&gt; 의 구문 분석 된 구성 요소를 보유하고, &lt;code&gt;URI&lt;/code&gt; 를 . 구문 분석에 실패하면 오류 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e34be64e7e0d26bd52b330f13bd6dd5de7306b80" translate="yes" xml:space="preserve">
          <source>Parses an IPv4 address string and returns an &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt;. Accepts a shortened IPv4 address string.</source>
          <target state="translated">IPv4 주소 문자열을 구문 분석하고 &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt; 반환합니다 . 단축 된 IPv4 주소 문자열을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="18cc80d670fa4d4c9b9ad5cf24a3ddc556aaf953" translate="yes" xml:space="preserve">
          <source>Parses an IPv4 address string containing four fields, that is, &lt;strong&gt;not&lt;/strong&gt; shortened, and returns an &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">단축 &lt;strong&gt;되지 않은&lt;/strong&gt; 네 개의 필드를 포함하는 IPv4 주소 문자열을 구문 분석하고 &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c579f7b626178d3c420a2e9643120d9f2832584e" translate="yes" xml:space="preserve">
          <source>Parses an IPv4 or IPv6 address string and returns an &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt;. Accepts a shortened IPv4 address string.</source>
          <target state="translated">IPv4 또는 IPv6 주소 문자열을 구문 분석하고 &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt; 리턴합니다 . 단축 된 IPv4 주소 문자열을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="5aa7dda9589a835953ec88f83cdf4c9c4edfbf77" translate="yes" xml:space="preserve">
          <source>Parses an IPv4 or IPv6 address string and returns an &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt;. Does &lt;strong&gt;not&lt;/strong&gt; accept a shortened IPv4 address string.</source>
          <target state="translated">IPv4 또는 IPv6 주소 문자열을 구문 분석하고 &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt; 리턴합니다 . 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 단축 IPv4 주소 문자열을 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="4b1a2097f959aec277e56d7b2f09d960c163d98b" translate="yes" xml:space="preserve">
          <source>Parses an IPv6 address string and returns an &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt;. Does &lt;strong&gt;not&lt;/strong&gt; accept IPv4 addresses.</source>
          <target state="translated">IPv6 주소 문자열을 구문 분석하고 &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt; 반환합니다 . 않습니다 &lt;strong&gt;하지&lt;/strong&gt; IPv4 주소를 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="eac51ea7e0934384fa0112eeeaf88c4ebab04633" translate="yes" xml:space="preserve">
          <source>Parses an IPv6 address string and returns an &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt;. If an IPv4 address string is specified, an IPv4-mapped IPv6 address is returned.</source>
          <target state="translated">IPv6 주소 문자열을 구문 분석하고 &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt; 반환합니다 . IPv4 주소 문자열을 지정하면 IPv4 매핑 된 IPv6 주소가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bf75044e156126d255e07b08533855db07ce584c" translate="yes" xml:space="preserve">
          <source>Parses an escript and extracts its sections. This is the reverse of &lt;code id=&quot;extract_2&quot;&gt;&lt;a href=&quot;#create_2&quot;&gt;create/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">escript를 구문 분석하고 해당 섹션을 추출합니다. 이것은 &lt;code id=&quot;extract_2&quot;&gt;&lt;a href=&quot;#create_2&quot;&gt;create/2&lt;/a&gt;&lt;/code&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="bdec3f2af87f1d33ee6b97ffa74db142958cd9e8" translate="yes" xml:space="preserve">
          <source>Parses the printout from an SQL table and returns a list of tuples.</source>
          <target state="translated">SQL 테이블에서 출력물을 구문 분석하고 튜플 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f5365bc5f3e468cf2148385f40bff58f883061be" translate="yes" xml:space="preserve">
          <source>Parsing URIs into its components and returing a map</source>
          <target state="translated">URI를 구성 요소로 구문 분석하고 맵을 다시 작성</target>
        </trans-unit>
        <trans-unit id="c8eb7f630b2224852a36c9237667bd9e0484c53a" translate="yes" xml:space="preserve">
          <source>Parsing and serializing non-UTF-8 form-urlencoded query strings are also supported (&lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html50/&quot;&gt;HTML 5.0&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">비 UTF-8 형식으로 인코딩 된 쿼리 문자열 구문 분석 및 직렬화도 지원됩니다 ( &lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html50/&quot;&gt;HTML 5.0&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="394ec0942f3b3fee9fe7ee73fb59ad007a74829f" translate="yes" xml:space="preserve">
          <source>Parsing of test specifications for &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">에 대한 시험 사양의 구문 분석 &lt;code&gt;Common Test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="546554c2840e61b82ab7aeb7ea63ff6baaa80832" translate="yes" xml:space="preserve">
          <source>Parsing of test specifications for Common Test.</source>
          <target state="translated">공통 테스트에 대한 테스트 사양 구문 분석</target>
        </trans-unit>
        <trans-unit id="9769719e65a84af80528eb749196580978ee6445" translate="yes" xml:space="preserve">
          <source>Part of a match specification list cannot be changed directly. If a function has a match specification, it can be replaced with a new one. To change an existing match specification, use the BIF &lt;code&gt;&lt;a href=&quot;#trace_info-2&quot;&gt;erlang:trace_info/2&lt;/a&gt;&lt;/code&gt; to retrieve the existing match specification.</source>
          <target state="translated">일치 사양 목록의 일부는 직접 변경할 수 없습니다. 기능이 일치 스펙을 갖는 경우 새 기능으로 대체 할 수 있습니다. 기존 일치 스펙을 변경하려면 BIF &lt;code&gt;&lt;a href=&quot;#trace_info-2&quot;&gt;erlang:trace_info/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 기존 일치 스펙을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="bf0d342d4ce21f38adfd95210e15a51046211865" translate="yes" xml:space="preserve">
          <source>Part of a pattern within square brackets is called a &quot;character class&quot;. The following are the only metacharacters in a character class:</source>
          <target state="translated">대괄호 안에있는 패턴의 일부를 &quot;문자 클래스&quot;라고합니다. 다음은 문자 클래스에서 유일한 메타 문자입니다.</target>
        </trans-unit>
        <trans-unit id="3bcb9ea04e25a8921a95bf6ab1089af46b847ca3" translate="yes" xml:space="preserve">
          <source>Partitions &lt;code&gt;List&lt;/code&gt; into a list of sublists and a remainder. &lt;code&gt;Lists&lt;/code&gt; contains one sublist for each key in &lt;code&gt;Keys&lt;/code&gt;, in the corresponding order. The relative order of the elements in each sublist is preserved from the original &lt;code&gt;List&lt;/code&gt;. &lt;code&gt;Rest&lt;/code&gt; contains the elements in &lt;code&gt;List&lt;/code&gt; that are not associated with any of the specified keys, also with their original relative order preserved.</source>
          <target state="translated">파티션 &lt;code&gt;List&lt;/code&gt; 을 하위 목록과 나머지 목록 으로 나눕니다. &lt;code&gt;Lists&lt;/code&gt; 는 &lt;code&gt;Keys&lt;/code&gt; 의 각 키에 대해 하나의 하위 목록을 해당 순서대로 포함합니다. 각 하위 &lt;code&gt;List&lt;/code&gt; 에있는 요소의 상대적 순서는 원래 List 에서 유지됩니다 . &lt;code&gt;Rest&lt;/code&gt; 는 지정된 키와 연관되지 않은 원래 요소 순서와 함께 &lt;code&gt;List&lt;/code&gt; 의 요소를 포함합니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
