<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="b159af3f46722bc08fb303932f585dbf455dbca5" translate="yes" xml:space="preserve">
          <source>Handle to a connection to a NETCONF server as returned by &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1,2&lt;/a&gt;&lt;/code&gt;, or to a session as returned by &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1-3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#only_open-1&quot;&gt;only_open/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1,2&lt;/a&gt;&lt;/code&gt; 에서 반환 된 NETCONF 서버에 대한 연결 또는 &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1-3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#only_open-1&quot;&gt;only_open/1,2&lt;/a&gt;&lt;/code&gt; 에서 반환 된 세션 에 대한 연결을 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="87b5cbd72ade701ab78a0c66eea3cc365bc59eac" translate="yes" xml:space="preserve">
          <source>Handle to the &lt;code&gt;epp&lt;/code&gt; server.</source>
          <target state="translated">&lt;code&gt;epp&lt;/code&gt; 서버를 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="e52aaa094b5e8a1137aac218cd0a979749732ffd" translate="yes" xml:space="preserve">
          <source>Handler Callback Functions</source>
          <target state="translated">핸들러 콜백 함수</target>
        </trans-unit>
        <trans-unit id="200f27a9fd62c17ba568575a28f8cc78a29e0aa9" translate="yes" xml:space="preserve">
          <source>Handler configuration data for Logger. The following default values apply:</source>
          <target state="translated">로거에 대한 핸들러 구성 데이터 다음과 같은 기본값이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e767bf13ab13407d576b285180deba35039b9c4c" translate="yes" xml:space="preserve">
          <source>Handler filters are added with &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; and removed with &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt; logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt;. They can also be specified directly in the configuration when adding a handler with &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt; logger:add_handler/3&lt;/a&gt;&lt;/code&gt; or via the Kernel configuration parameter &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">핸들러 필터는 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; 로 추가 되고 &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt; logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt; 로 제거됩니다 . &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt; logger:add_handler/3&lt;/a&gt;&lt;/code&gt; 또는 Kernel 구성 매개 변수 &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt; 를 통해 핸들러를 추가 할 때 구성에서 직접 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e4e5ac3ff721d07867e9b05c8337ed55ee393d3" translate="yes" xml:space="preserve">
          <source>Handler filters are added with &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; and removed with &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt;logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt;. They can also be specified directly in the configuration when adding a handler with &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt; or via the Kernel configuration parameter &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">핸들러 필터는 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; 로 추가 되고 &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt;logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt; 로 제거됩니다 . &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt; 또는 처리기 구성 매개 변수 &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt; 를 통해 핸들러를 추가 할 때 구성에서 직접 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a19df29c14bb59d2df47c78d5601e95477f6e53a" translate="yes" xml:space="preserve">
          <source>Handler filters are specified when adding the handler, or added or removed during runtime with &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt; logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">핸들러 필터는 핸들러를 추가 할 때 지정되거나 런타임 중에 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt; logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 각각 추가 또는 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="bfa2c83d2d8b95dd0f46137f7539ec6164e318e2" translate="yes" xml:space="preserve">
          <source>Handler filters are specified when adding the handler, or added or removed during runtime with &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt;logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">핸들러 필터는 핸들러를 추가 할 때 지정되거나 런타임 중에 각각 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt;logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt; 로 추가 또는 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="f0065b00d67594d8a62cb8fb9796876e1d8da5ac" translate="yes" xml:space="preserve">
          <source>Handler specific configuration data is inserted by the handler callback itself, in a sub structure associated with the field named &lt;code&gt;config&lt;/code&gt;.</source>
          <target state="translated">핸들러 특정 구성 데이터는 핸들러 콜백 자체에 의해 &lt;code&gt;config&lt;/code&gt; 필드와 연관된 서브 구조에 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="17e94ab879668328c0d7f838700deffb10d37fcd" translate="yes" xml:space="preserve">
          <source>Handler specific configuration data is inserted by the handler callback itself, in a sub structure associated with the field named &lt;code&gt;config&lt;/code&gt;. See the &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3)&lt;/a&gt;&lt;/code&gt; manual pages for information about the specifc configuration for these handlers.</source>
          <target state="translated">핸들러 특정 구성 데이터는 핸들러 콜백 자체에 의해 &lt;code&gt;config&lt;/code&gt; 라는 필드와 연관된 하위 구조에 삽입됩니다 . 이러한 핸들러의 특정 구성에 대한 정보 는 &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3)&lt;/a&gt;&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e9a11f027cd6db3a106cb106c781e7e6546c3308" translate="yes" xml:space="preserve">
          <source>Handler specific configuration, that is, configuration data related to a specific handler implementation.</source>
          <target state="translated">핸들러 특정 구성, 즉 특정 핸들러 구현과 관련된 구성 데이터</target>
        </trans-unit>
        <trans-unit id="8dd3565abe30287cdd82dbf04dfe72c3a01322cc" translate="yes" xml:space="preserve">
          <source>Handles SSH Connection Protocol messages that may need service-specific attention. For details, see &lt;code&gt;&lt;a href=&quot;ssh_connection&quot;&gt;ssh_connection:event()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">서비스 별주의가 필요한 SSH 연결 프로토콜 메시지를 처리합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;ssh_connection&quot;&gt;ssh_connection:event()&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="351ea12c7488865cb104522ed06fb519daaf6841" translate="yes" xml:space="preserve">
          <source>Handles SSH Connection Protocol messages that may need service-specific attention. For details, see &lt;code&gt;&lt;a href=&quot;ssh_connection#type-event&quot;&gt;ssh_connection:event()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">서비스 별주의가 필요할 수있는 SSH 연결 프로토콜 메시지를 처리합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;ssh_connection#type-event&quot;&gt;ssh_connection:event()&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="88c94d64476ed5597f8322dfbff2cf130463d724" translate="yes" xml:space="preserve">
          <source>Handles messages from Erlang. The messages can either be plain data to be sent or more subtle instructions to the driver. This function is here mostly for data pumping.</source>
          <target state="translated">Erlang의 메시지를 처리합니다. 메시지는 평범한 데이터이거나 드라이버에게 더 미묘한 명령 일 수 있습니다. 이 기능은 주로 데이터 펌핑을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="921a347faf64cd8a16325d957876e1c04d6d75e2" translate="yes" xml:space="preserve">
          <source>Handles messages sent by calling &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/[2,3]&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/[2,3]&lt;/a&gt;&lt;/code&gt; 를 호출 하여 보낸 메시지를 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="f1b9f0ea31717ef2e1c8cb50a77717454cf70a8b" translate="yes" xml:space="preserve">
          <source>Handles messages sent by calling &lt;code&gt;cast/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cast/2&lt;/code&gt; 를 호출하여 보낸 메시지를 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="26b904f520d22bb388f5046965390b894bfa3594" translate="yes" xml:space="preserve">
          <source>Handles other messages than SSH Connection Protocol, call, or cast messages sent to the channel.</source>
          <target state="translated">채널에 전송 된 SSH 연결 프로토콜, 통화 또는 전송 메시지 이외의 다른 메시지를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="2fd2edfd14e358bb3197eb296e3226354fa0bcbd" translate="yes" xml:space="preserve">
          <source>Handles storing of scanner information when parsing.</source>
          <target state="translated">구문 분석시 스캐너 정보 저장을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="9787eca8b55e04c46475fed50a4b8ca6fa155b36" translate="yes" xml:space="preserve">
          <source>Handles the OTP-MIB</source>
          <target state="translated">OTP-MIB 처리</target>
        </trans-unit>
        <trans-unit id="a6c4fd9a67f6ff85d671fb367281d35a7948d754" translate="yes" xml:space="preserve">
          <source>Handling any other memory management</source>
          <target state="translated">다른 메모리 관리 처리</target>
        </trans-unit>
        <trans-unit id="8aef8f3753bae4ea18f0ce0e73cebcd5d20ccb5d" translate="yes" xml:space="preserve">
          <source>Handling instruction with variable number of operands</source>
          <target state="translated">다양한 수의 피연산자로 명령 처리</target>
        </trans-unit>
        <trans-unit id="b341e45d0db6d71ec15e4a0de6c3934aeec4ccd4" translate="yes" xml:space="preserve">
          <source>Handling of binary data (binaries / bit syntax).</source>
          <target state="translated">이진 데이터 (이진 / 비트 구문) 처리</target>
        </trans-unit>
        <trans-unit id="a2823aadf112ce5f5e68f202feabf8215b84b288" translate="yes" xml:space="preserve">
          <source>Handling of configuration files specifying data related to the System Under Test (SUT) (and any other variable data)</source>
          <target state="translated">테스트 대상 시스템 (SUT)과 관련된 데이터 (및 기타 변수 데이터)를 지정하는 구성 파일 처리</target>
        </trans-unit>
        <trans-unit id="33fefddaf63d1b186bf16cc5d6c16046d15037f4" translate="yes" xml:space="preserve">
          <source>Handshake, interchange node name, and authenticate (2)</source>
          <target state="translated">핸드 셰이크, 교환 노드 이름 및 인증 (2)</target>
        </trans-unit>
        <trans-unit id="c51f6db8fb76d17c47c7e717ca4c6c5f2b5b4133" translate="yes" xml:space="preserve">
          <source>Handy shortcuts for common tracing settings.</source>
          <target state="translated">일반적인 추적 설정을위한 편리한 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="bd7d4b95fcd93ad906141f781368bc43c7c7f10a" translate="yes" xml:space="preserve">
          <source>Hangul</source>
          <target state="translated">Hangul</target>
        </trans-unit>
        <trans-unit id="ed413af43425a39818253cc0c5de7394d4a39735" translate="yes" xml:space="preserve">
          <source>Hanunoo</source>
          <target state="translated">Hanunoo</target>
        </trans-unit>
        <trans-unit id="de7ed76e4bc7658794475e0cb1788bf730fb9c21" translate="yes" xml:space="preserve">
          <source>Hard links are not supported on this platform.</source>
          <target state="translated">이 플랫폼에서는 하드 링크가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e7bcf0ff0ecf672bee67708eac571eebae762e22" translate="yes" xml:space="preserve">
          <source>Hard real-time systems.</source>
          <target state="translated">하드 실시간 시스템.</target>
        </trans-unit>
        <trans-unit id="df63d1ff1b01b407251d0ded52b5cebe7b3b5ed8" translate="yes" xml:space="preserve">
          <source>Hardware Watchdog</source>
          <target state="translated">하드웨어 감시</target>
        </trans-unit>
        <trans-unit id="65bebc8f73cff6923a62cf86dbdad6dcd9f3de59" translate="yes" xml:space="preserve">
          <source>Hardware memory barriers or memory fences are instructions that can be used to enforce order between memory accesses. Different hardware architectures provide different memory barriers. Lock free algorithms need to use memory barriers in order to ensure that memory accesses are not reordered in such ways that the algorithm breaks down. Memory barriers are also expensive instructions, so you typically want to minimize the use of these instructions.</source>
          <target state="translated">하드웨어 메모리 장벽 또는 메모리 펜스는 메모리 액세스 사이에 순서를 적용하는 데 사용할 수있는 명령입니다. 다른 하드웨어 아키텍처는 다른 메모리 장벽을 제공합니다. 잠금 해제 알고리즘은 알고리즘이 무너지는 방식으로 메모리 액세스가 재정렬되지 않도록 메모리 장벽을 사용해야합니다. 메모리 장벽도 비용이 많이 드는 명령어이므로 일반적으로 이러한 명령어의 사용을 최소화하려고합니다.</target>
        </trans-unit>
        <trans-unit id="f66d0faec5f252a3b8add8ab78a2b77dfef38ca3" translate="yes" xml:space="preserve">
          <source>Hash algorithm to be used for signing the certificate together with the key option. Defaults to sha that is sha1.</source>
          <target state="translated">키 옵션과 함께 인증서 서명에 사용되는 해시 알고리즘. sha1의 기본값은 sha1입니다.</target>
        </trans-unit>
        <trans-unit id="c1abd7377d4f44f416003defcad46c11c4076434" translate="yes" xml:space="preserve">
          <source>Hash functions - &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf&quot;&gt; Secure Hash Standard&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1321.txt&quot;&gt; The MD5 Message Digest Algorithm (RFC 1321)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1320.txt&quot;&gt;The MD4 Message Digest Algorithm (RFC 1320)&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">해시 함수- &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf&quot;&gt; Secure Hash Standard&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1321.txt&quot;&gt; The MD5 Message Digest Algorithm (RFC 1321)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1320.txt&quot;&gt;The MD4 Message Digest Algorithm (RFC 1320)&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36646a9df5be6ffe4361209dc14cd9eabb8a54c1" translate="yes" xml:space="preserve">
          <source>Hash tables for Erlang terms (ETS).</source>
          <target state="translated">Erlang 용어 (ETS)에 대한 해시 테이블.</target>
        </trans-unit>
        <trans-unit id="66d9fc0e303c1db9ac127804366374bdb8ad808d" translate="yes" xml:space="preserve">
          <source>Hashes &lt;code&gt;term&lt;/code&gt; according to the specified &lt;code&gt;&lt;a href=&quot;#ErlNifHash&quot;&gt;ErlNifHash&lt;/a&gt;&lt;/code&gt;&lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;#ErlNifHash&quot;&gt;ErlNifHash&lt;/a&gt;&lt;/code&gt; &lt;code&gt;type&lt;/code&gt; 에 따라 &lt;code&gt;term&lt;/code&gt; 해시 합니다 .</target>
        </trans-unit>
        <trans-unit id="93e30adaf0176847ba666855ceca8fa26f1db0ad" translate="yes" xml:space="preserve">
          <source>Having the source code in UTF-8 also allows you to write string literals, function names, and atoms containing Unicode characters with code points &amp;gt; 255. Module names, application names, and node names are still restricted to the ISO Latin-1 range. Binary literals, where you use type &lt;code&gt;/utf8&lt;/code&gt;, can also be expressed using Unicode characters &amp;gt; 255. Having module names or application names using characters other than 7-bit ASCII can cause trouble on operating systems with inconsistent file naming schemes, and can hurt portability, so it is not recommended.</source>
          <target state="translated">UTF-8로 소스 코드를 사용하면 코드 포인트가 255보다 큰 유니 코드 문자를 포함하는 문자열 리터럴, 함수 이름 및 원자를 작성할 수 있습니다. 모듈 이름, 응용 프로그램 이름 및 노드 이름은 여전히 ​​ISO Latin-1 범위로 제한됩니다. &lt;code&gt;/utf8&lt;/code&gt; 유형을 사용하는 이진 리터럴 은 유니 코드 문자&amp;gt; 255를 사용하여 표현할 수도 있습니다. 7 비트 ASCII 이외의 문자를 사용하는 모듈 이름 또는 응용 프로그램 이름을 사용하면 파일 이름 지정 체계가 일치하지 않는 운영 체제에서 문제가 발생하여 이식성이 손상 될 수 있습니다. 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f670bf76875dd0a7bbc3b0854cf6973e8fd4fce" translate="yes" xml:space="preserve">
          <source>Having to generate extra random bits for small numbers costs a little performance. This function is about 20% slower than the regular &lt;code&gt;&lt;a href=&quot;#uniform_s-1&quot;&gt;uniform_s/1&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">적은 수의 추가 임의 비트를 생성해야하는 경우 약간의 성능이 필요합니다. 이 기능은 일반 &lt;code&gt;&lt;a href=&quot;#uniform_s-1&quot;&gt;uniform_s/1&lt;/a&gt;&lt;/code&gt; 보다 약 20 % 느립니다.</target>
        </trans-unit>
        <trans-unit id="c4449e9b5eb52175eb4e08b8a7330653b852def9" translate="yes" xml:space="preserve">
          <source>Header elements: Module, Author - These commands insert lines on the form &lt;code&gt;-module(&lt;/code&gt;xxx&lt;code&gt;).&lt;/code&gt; and &lt;code&gt;-author('my@home').&lt;/code&gt;. They can be used directly, but are also used as part of the full headers described below.</source>
          <target state="translated">헤더 요소 : Module, &lt;code&gt;-module(&lt;/code&gt; 이 명령은 -module ( xxx &lt;code&gt;).&lt;/code&gt; 양식에 행을 삽입합니다 . 및 &lt;code&gt;-author('my@home').&lt;/code&gt; . 그것들은 직접 사용될 수 있지만 아래에 설명 된 전체 헤더의 일부로도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a6fe09edcf76c414cb39902b06a907d362c636fc" translate="yes" xml:space="preserve">
          <source>Header file for configuration data</source>
          <target state="translated">구성 데이터의 헤더 파일</target>
        </trans-unit>
        <trans-unit id="a12c4113e1bb8f1f4886664bda35d4aa27d7be74" translate="yes" xml:space="preserve">
          <source>Heading for a hidden node. A hidden node is the same as a visible node, except that it is started with the &lt;code&gt;&quot;-hidden&quot;&lt;/code&gt; flag. States the channel number for the node.</source>
          <target state="translated">숨겨진 노드로 향합니다. 숨겨진 노드는 &lt;code&gt;&quot;-hidden&quot;&lt;/code&gt; 플래그로 시작한다는 점을 제외하고는 보이는 노드와 동일합니다 . 노드의 채널 번호를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fed55dc039cca5dcc6f8b46a4f4ace2200d528da" translate="yes" xml:space="preserve">
          <source>Heading for a node that was connected to the crashed node earlier. References (that is, process or port identifiers) to the not connected node existed at the time of the crash. States the channel number for the node.</source>
          <target state="translated">이전에 충돌 한 노드에 연결된 노드로 향합니다. 연결되지 않은 노드에 대한 참조 (프로세스 또는 포트 식별자)는 충돌시 존재했습니다. 노드의 채널 번호를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="952129998156402241d678235a6162ddb355874b" translate="yes" xml:space="preserve">
          <source>Heading for a visible node, that is, an alive node with a connection to the node that crashed. States the channel number for the node.</source>
          <target state="translated">보이는 노드, 즉 충돌 한 노드에 연결되어있는 활성 노드로 향합니다. 노드의 채널 번호를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c243e47447e24ffdd605f179f0a2cab8a40d6b7a" translate="yes" xml:space="preserve">
          <source>Heading.</source>
          <target state="translated">Heading.</target>
        </trans-unit>
        <trans-unit id="4fa5946d7c0314c7ba622549aa822d84deddf1a7" translate="yes" xml:space="preserve">
          <source>Heading. States the module name.</source>
          <target state="translated">표제. 모듈 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="150c7cf2786a06b4ea8a7aed067ae6ad9d638983" translate="yes" xml:space="preserve">
          <source>Heading. States the process identifier.</source>
          <target state="translated">표제. 프로세스 식별자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7145dfcf409c4e094b7363fa76ac09665f29cbd7" translate="yes" xml:space="preserve">
          <source>Heading. States the scheduler identifier.</source>
          <target state="translated">표제. 스케줄러 식별자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="05a03b6ce3444cc92f49fde9b3239e70eade9242" translate="yes" xml:space="preserve">
          <source>Heading. States the table owner (a process identifier).</source>
          <target state="translated">표제. 테이블 소유자 (프로세스 식별자)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="410899dc76f34f1fabf6ebe98f9e99757d1588a0" translate="yes" xml:space="preserve">
          <source>Heading. States the timer owner (a process identifier), that is, the process to receive the message when the timer expires.</source>
          <target state="translated">표제. 타이머 소유자 (프로세스 식별자), 즉 타이머가 만료 될 때 메시지를 수신하는 프로세스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c2d66ec52324213cab485604b51c2b78378fa0a7" translate="yes" xml:space="preserve">
          <source>Heap binaries are small binaries, up to 64 bytes, and are stored directly on the process heap. They are copied when the process is garbage-collected and when they are sent as a message. They do not require any special handling by the garbage collector.</source>
          <target state="translated">힙 바이너리는 최대 64 바이트의 작은 바이너리이며 프로세스 힙에 직접 저장됩니다. 프로세스가 가비지 수집되고 메시지로 전송 될 때 복사됩니다. 가비지 수집기에서는 특별한 처리가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21e21ed9381d58c024ca753fbeee40b36f3a6b32" translate="yes" xml:space="preserve">
          <source>Heartbeat interval, in milliseconds</source>
          <target state="translated">하트 비트 간격 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="4106d21c7ff6614f8b1f5e63e9c6e5e9cdc9e04e" translate="yes" xml:space="preserve">
          <source>Heartbeat monitoring of an Erlang runtime system.</source>
          <target state="translated">Erlang 런타임 시스템의 하트 비트 모니터링.</target>
        </trans-unit>
        <trans-unit id="348d00693e12bc983bd092677b90434b5a4d869e" translate="yes" xml:space="preserve">
          <source>Hebrew</source>
          <target state="translated">Hebrew</target>
        </trans-unit>
        <trans-unit id="c933a30976c11ef549273b016b878d75f830e3f9" translate="yes" xml:space="preserve">
          <source>HelloRetryRequest</source>
          <target state="translated">HelloRetryRequest</target>
        </trans-unit>
        <trans-unit id="268bfdeda15e6e6a18f731bf9369b4adf0706327" translate="yes" xml:space="preserve">
          <source>Help Menu</source>
          <target state="translated">도움말 메뉴</target>
        </trans-unit>
        <trans-unit id="d62999fd30064fd05e82c60b2a94d7ce3e73892c" translate="yes" xml:space="preserve">
          <source>Hence, 1996 is a leap year, 1900 is not, but 2000 is.</source>
          <target state="translated">따라서 1996 년은 윤년이며 1900 년은 아니지만 2000 년입니다.</target>
        </trans-unit>
        <trans-unit id="e085c6d848b4c5dcb06ae3d79bc98bb5ed8aaaab" translate="yes" xml:space="preserve">
          <source>Hence, the argument entered as input is doubled as follows:</source>
          <target state="translated">따라서 입력으로 입력 된 인수는 다음과 같이 두 배가됩니다.</target>
        </trans-unit>
        <trans-unit id="42595144f616321737f8b5e7f141df36f0ea93d3" translate="yes" xml:space="preserve">
          <source>Hence, the previous list comprehension demonstrates the formation of the list &lt;code&gt;E#employee.name&lt;/code&gt; such that &lt;code&gt;E&lt;/code&gt; is taken from the table of employees, and attribute &lt;code&gt;sex&lt;/code&gt; of each record is equal to the atom &lt;code&gt;female&lt;/code&gt;.</source>
          <target state="translated">따라서, 이전 지능형리스트는리스트의 형성을 보여 &lt;code&gt;E#employee.name&lt;/code&gt; 있도록 &lt;code&gt;E&lt;/code&gt; 는 직원의 표에서 촬영을하고, 속성 &lt;code&gt;sex&lt;/code&gt; 각 레코드는 원자 같다 &lt;code&gt;female&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0305883084fd7655771a803404eb6b396bb82e43" translate="yes" xml:space="preserve">
          <source>Hence, when a disc-less node needs to find the schema definitions from a remote node on the network, this information must be supplied through application parameter &lt;code&gt;-mnesia extra_db_nodes NodeList&lt;/code&gt;. Without this configuration parameter set, &lt;code&gt;Mnesia&lt;/code&gt; starts as a single node system. Also, the function &lt;code&gt;&lt;a href=&quot;mnesia#change_config-2&quot;&gt;mnesia:change_config/2&lt;/a&gt;&lt;/code&gt; can be used to assign a value to &lt;code&gt;extra_db_nodes&lt;/code&gt; and force a connection after &lt;code&gt;Mnesia&lt;/code&gt; has been started, that is, &lt;code&gt;mnesia:change_config(extra_db_nodes, NodeList)&lt;/code&gt;.</source>
          <target state="translated">따라서 디스크없는 노드가 네트워크의 원격 노드에서 스키마 정의를 찾아야하는 경우이 정보는 애플리케이션 매개 변수 &lt;code&gt;-mnesia extra_db_nodes NodeList&lt;/code&gt; 를 통해 제공해야합니다 . 이 구성 매개 변수를 설정하지 않으면 &lt;code&gt;Mnesia&lt;/code&gt; 는 단일 노드 시스템으로 시작합니다. 또한 &lt;code&gt;&lt;a href=&quot;mnesia#change_config-2&quot;&gt;mnesia:change_config/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 &lt;code&gt;extra_db_nodes&lt;/code&gt; 에 값을 지정하고 &lt;code&gt;Mnesia&lt;/code&gt; 가 시작된 후 , 즉 &lt;code&gt;mnesia:change_config(extra_db_nodes, NodeList)&lt;/code&gt; 연결을 강제 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f9a6ade28837bafcd59b3b5f9e9096aa0c39c5a" translate="yes" xml:space="preserve">
          <source>Here (?(R) is the start of a conditional subpattern, with two different alternatives for the recursive and non-recursive cases. Item (?R) is the actual recursive call.</source>
          <target state="translated">여기서 (? (R)은 조건부 하위 패턴의 시작으로, 재귀 및 비 재귀 사례에 대한 두 가지 다른 대안이 있습니다. 항목 (? R)은 실제 재귀 호출입니다.</target>
        </trans-unit>
        <trans-unit id="95eada3e2f0063def4189cbe7e1ac07f33e51ad4" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&quot;mysystem&quot;&lt;/code&gt; is the base release and &lt;code&gt;&quot;mysystem2&quot;&lt;/code&gt; is the release to upgrade to.</source>
          <target state="translated">여기서 &lt;code&gt;&quot;mysystem&quot;&lt;/code&gt; 은 기본 릴리스이고 &lt;code&gt;&quot;mysystem2&quot;&lt;/code&gt; 는 업그레이드 할 릴리스입니다.</target>
        </trans-unit>
        <trans-unit id="c3ae7fc887a9fc509a0c94f1f548abf5e88538b2" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;+W w&lt;/code&gt; and &lt;code&gt;+R 9&lt;/code&gt; are emulator flags. &lt;code&gt;-s my_init&lt;/code&gt; is an init flag, interpreted by &lt;code&gt;init&lt;/code&gt;. &lt;code&gt;-sname arnie&lt;/code&gt; is a user flag, stored by &lt;code&gt;init&lt;/code&gt;. It is read by Kernel and causes the Erlang runtime system to become distributed. Finally, everything after &lt;code&gt;-extra&lt;/code&gt; (that is, &lt;code&gt;+bertie&lt;/code&gt;) is considered as plain arguments.</source>
          <target state="translated">여기서 &lt;code&gt;+W w&lt;/code&gt; 및 &lt;code&gt;+R 9&lt;/code&gt; 는 에뮬레이터 플래그입니다. &lt;code&gt;-s my_init&lt;/code&gt; 는 init로 해석되는 &lt;code&gt;init&lt;/code&gt; 플래그 입니다. &lt;code&gt;-sname arnie&lt;/code&gt; 는 &lt;code&gt;init&lt;/code&gt; 에 의해 저장된 사용자 플래그 입니다. 커널에 의해 읽히고 Erlang 런타임 시스템이 분배됩니다. 마지막으로 &lt;code&gt;-extra&lt;/code&gt; 뒤의 모든 것 (즉, &lt;code&gt;+bertie&lt;/code&gt; )은 일반 인수로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="18878a7a47d8170e6d38bdbab2ec1dd97fe93f48" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Binary&lt;/code&gt; is an Erlang binary that contains the encoded data. (If option &lt;code&gt;legacy_erlang_types&lt;/code&gt; has been given, only the binary is returned.)</source>
          <target state="translated">여기서 &lt;code&gt;Binary&lt;/code&gt; 부호화 데이터를 포함하는 얼랑 이진이다. &lt;code&gt;legacy_erlang_types&lt;/code&gt; 옵션 이 제공된 경우 바이너리 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="37df4c092f43bb499bc403c1f4e4f375ce537f8f" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;BytesForOpenType&lt;/code&gt; is a list of bytes constituting the encoding of the &quot;unknown&quot; &lt;code&gt;CHOICE&lt;/code&gt; alternative.</source>
          <target state="translated">여기서 &lt;code&gt;BytesForOpenType&lt;/code&gt; 은 &quot;알 수없는&quot; &lt;code&gt;CHOICE&lt;/code&gt; 대안 의 인코딩을 구성하는 바이트 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="46f5f684a77da256af5aa4d76e5b9497068275f5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Fd&lt;/code&gt; was specified to function &lt;code&gt;init/3&lt;/code&gt; as:</source>
          <target state="translated">여기서 &lt;code&gt;Fd&lt;/code&gt; 는 다음과 같이 &lt;code&gt;init/3&lt;/code&gt; 기능을하도록 지정 되었습니다.</target>
        </trans-unit>
        <trans-unit id="54d075fd5d42e82f879a36d53b74d7b98bbbfc33" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;M0&lt;/code&gt; is any map. It follows that &lt;code&gt;M1 .. M4&lt;/code&gt; are maps as well.</source>
          <target state="translated">여기서 &lt;code&gt;M0&lt;/code&gt; 은 모든 맵입니다. 다음은 &lt;code&gt;M1 .. M4&lt;/code&gt; 도 맵입니다.</target>
        </trans-unit>
        <trans-unit id="5980443888fa1217e79c3bb79e1e66f80464dd29" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;M&lt;/code&gt; is a term of type map and &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are any expression.</source>
          <target state="translated">여기서 &lt;code&gt;M&lt;/code&gt; 은 map 유형의 용어이고 &lt;code&gt;K&lt;/code&gt; 와 &lt;code&gt;V&lt;/code&gt; 는 모든 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="b1f20246edf736a721e4d108cf1124970da81a07" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;M&lt;/code&gt; is a term of type map, &lt;code&gt;V&lt;/code&gt; is an expression and &lt;code&gt;K&lt;/code&gt; is an expression that evaluates to an existing key in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;M&lt;/code&gt; 은 map 유형의 용어이고, &lt;code&gt;V&lt;/code&gt; 는 표현식이고 &lt;code&gt;K&lt;/code&gt; 는 &lt;code&gt;M&lt;/code&gt; 의 기존 키로 평가되는 표현식입니다 .</target>
        </trans-unit>
        <trans-unit id="0698d19c4d4c3905620eb9ca2f7560cc47809caa" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;M&lt;/code&gt; is any map. The key &lt;code&gt;K&lt;/code&gt; must be a &lt;code&gt;&lt;a href=&quot;#guard_expressions&quot;&gt;guard expression&lt;/a&gt;&lt;/code&gt;, with all variables already bound. &lt;code&gt;V&lt;/code&gt; can be any pattern with either bound or unbound variables.</source>
          <target state="translated">여기 &lt;code&gt;M&lt;/code&gt; 은 모든지도입니다. 키 &lt;code&gt;K&lt;/code&gt; 는 모든 변수가 이미 바인딩 된 &lt;code&gt;&lt;a href=&quot;#guard_expressions&quot;&gt;guard expression&lt;/a&gt;&lt;/code&gt; 이어야합니다 . &lt;code&gt;V&lt;/code&gt; 는 바인딩되거나 바인딩되지 않은 변수가있는 모든 패턴 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6105a70c4b87b25ae269fb373351faa4cb7f203" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;M&lt;/code&gt; is any map. The key &lt;code&gt;K&lt;/code&gt; must be an expression with bound variables or literals. &lt;code&gt;V&lt;/code&gt; can be any pattern with either bound or unbound variables.</source>
          <target state="translated">여기 &lt;code&gt;M&lt;/code&gt; 은 모든지도입니다. 키 &lt;code&gt;K&lt;/code&gt; 는 바운드 변수 또는 리터럴이있는 표현식이어야합니다. &lt;code&gt;V&lt;/code&gt; 는 바운드 또는 언 바운드 변수가있는 패턴 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfa51aff5e200195c56f9fac50cfa48993ce7499" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Node&lt;/code&gt; is the old node.</source>
          <target state="translated">여기서 &lt;code&gt;Node&lt;/code&gt; 는 이전 노드입니다.</target>
        </trans-unit>
        <trans-unit id="40663b6a0bc17a6c5bb5be7fc0a8ec85eb9e5df4" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Node&lt;/code&gt; is the terminated node.</source>
          <target state="translated">여기서 &lt;code&gt;Node&lt;/code&gt; 는 종료 된 노드입니다.</target>
        </trans-unit>
        <trans-unit id="3f0cf7c1aa3a9460f5702ed6ce4797a96c09937c" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Sz&lt;/code&gt; is bound to the value in the first byte of the binary. &lt;code&gt;Sz&lt;/code&gt; is then used at the number of bytes to match out as a binary.</source>
          <target state="translated">여기서 &lt;code&gt;Sz&lt;/code&gt; 는 바이너리의 첫 번째 바이트 값에 바인딩됩니다. 그런 다음 &lt;code&gt;Sz&lt;/code&gt; 는 바이너리로 일치시킬 바이트 수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3f5a7de11b2a0f9a883784c833a5e64495abf297" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Sz&lt;/code&gt; is the combined size of the header and the payload, so we will need to subtract one byte to get the size of the payload.</source>
          <target state="translated">여기서 &lt;code&gt;Sz&lt;/code&gt; 는 헤더와 페이로드의 결합 된 크기이므로 페이로드의 크기를 얻으려면 1 바이트를 빼야합니다.</target>
        </trans-unit>
        <trans-unit id="2aa26917569777b811a459c8edac3b1f6928d1a9" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;X&lt;/code&gt; gets the value &lt;code&gt;paris&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt;&lt;code&gt;{f,28}&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;X&lt;/code&gt; 는 &lt;code&gt;paris&lt;/code&gt; 및 &lt;code&gt;Y&lt;/code&gt; &lt;code&gt;{f,28}&lt;/code&gt; 값을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="0491a2d3210236bc79073f011f175603cf95e651" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;bin&lt;/code&gt; is a driver binary of length at least 50 and &lt;code&gt;drvport&lt;/code&gt; is a port handle. Notice that &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; comes after the elements of the list, likewise &lt;code&gt;ERL_DRV_TUPLE&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;bin&lt;/code&gt; 은 길이가 50 이상인 드라이버 바이너리이며 &lt;code&gt;drvport&lt;/code&gt; 는 포트 핸들입니다. 공지 사항 것을 &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; 이 목록 마찬가지로 요소 뒤에 오는 &lt;code&gt;ERL_DRV_TUPLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03614fcdf5fd8628354c2dc566e6863e0b8468ca" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;format_temps/1&lt;/code&gt; calls &lt;code&gt;convert_list_to_c/1&lt;/code&gt;. &lt;code&gt;convert_list_to_c/1&lt;/code&gt; takes off the head of the &lt;code&gt;List_of_cities&lt;/code&gt;, converts it to Celsius if needed. The | operator is used to add the (maybe) converted to the converted rest of the list:</source>
          <target state="translated">여기서 &lt;code&gt;format_temps/1&lt;/code&gt; 은 &lt;code&gt;convert_list_to_c/1&lt;/code&gt; 을 호출합니다 . &lt;code&gt;convert_list_to_c/1&lt;/code&gt; 은 &lt;code&gt;List_of_cities&lt;/code&gt; 의 헤드를 가져 와서 필요한 경우 Celsius로 변환합니다. | 연산자는 변환 된 나머지 목록으로 변환 된 (아마도)을 추가하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0d41f0b5f278025a79f179eb50cbcf1d17def2de" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;kb.example.org&lt;/code&gt; serves any protocol while &lt;code&gt;www.example.org&lt;/code&gt; presents a secure web server.</source>
          <target state="translated">여기서 &lt;code&gt;kb.example.org&lt;/code&gt; 는 모든 프로토콜을 제공하는 반면 &lt;code&gt;www.example.org&lt;/code&gt; 는 보안 웹 서버를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f36f1eb025a53a1dc6cfb7f8014034366d975093" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;pipe_name&lt;/code&gt; defaults to &lt;code&gt;/tmp/erlang.pipe.N&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;pipe_name&lt;/code&gt; 의 기본값은 &lt;code&gt;/tmp/erlang.pipe.N&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="445ee2128dde70c3cdab895146aba251b7587bf5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;ref&lt;/code&gt; is a &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; the corresponding &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_opt&quot;&gt;transport_opt()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; list passed to &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;watchdog&lt;/code&gt; entry shows the state of a connection's RFC 3539 watchdog state machine. The &lt;code&gt;peer&lt;/code&gt; entry identifies the &lt;code&gt;&lt;code&gt;diameter_app:peer_ref()&lt;/code&gt;&lt;/code&gt; for which there will have been &lt;code&gt;peer_up/3&lt;/code&gt; callbacks for the Diameter applications identified by the &lt;code&gt;apps&lt;/code&gt; entry, &lt;code&gt;common&lt;/code&gt; being the &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#application_alias&quot;&gt;application_alias()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;. The &lt;code&gt;caps&lt;/code&gt; entry identifies the capabilities sent by the local node and received from the peer during capabilities exchange. The &lt;code&gt;port&lt;/code&gt; entry displays socket-level information about the transport connection. The &lt;code&gt;statistics&lt;/code&gt; entry presents Diameter-level counters, an entry like &lt;code&gt;{{{0,280,1},recv},2}&lt;/code&gt; saying that the client has received 2 DWR messages: &lt;code&gt;{0,280,1} = {Application_Id, Command_Code, R_Flag}&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;ref&lt;/code&gt; 는 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 및 해당 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_opt&quot;&gt;transport_opt()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 목록이 &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; 에 전달 된 &lt;code&gt;options&lt;/code&gt; 입니다. &lt;code&gt;watchdog&lt;/code&gt; 항목 쇼 연결의 RFC 3539 감시 상태 머신의 상태. &lt;code&gt;peer&lt;/code&gt; 항목 식별이 &lt;code&gt;&lt;code&gt;diameter_app:peer_ref()&lt;/code&gt;&lt;/code&gt; 하는이 있었다 것 &lt;code&gt;peer_up/3&lt;/code&gt; 에 의해 확인 된 직경 애플리케이션을위한 콜백 &lt;code&gt;apps&lt;/code&gt; , 항목 &lt;code&gt;common&lt;/code&gt; 되는 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#application_alias&quot;&gt;application_alias()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; . &lt;code&gt;caps&lt;/code&gt; 항목은 로컬 노드에서 전송하고 기능 교환 중에 피어에서 수신 한 기능을 식별합니다. &lt;code&gt;port&lt;/code&gt; 항목 표시 소켓 수준의 전송 연결에 대한 정보를 표시합니다. &lt;code&gt;statistics&lt;/code&gt; 항목 선물 직경 레벨 카운터, 같은 항목 &lt;code&gt;{{{0,280,1},recv},2}&lt;/code&gt; 클라이언트가 2 DWR 메시지를 받았다고 말 : &lt;code&gt;{0,280,1} = {Application_Id, Command_Code, R_Flag}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff06bab188b6989420caf73f4bedde0091d8f752" translate="yes" xml:space="preserve">
          <source>Here a &lt;code&gt;TestDir&lt;/code&gt; can be used to point out the path to a &lt;code&gt;Suite&lt;/code&gt;. Option &lt;code&gt;testcase&lt;/code&gt; corresponds to option &lt;code&gt;-case&lt;/code&gt; in program &lt;code&gt;ct_run&lt;/code&gt;. Configuration files specified in &lt;code&gt;Opts&lt;/code&gt; are installed automatically at startup.</source>
          <target state="translated">여기서 &lt;code&gt;TestDir&lt;/code&gt; 을 사용하여 &lt;code&gt;Suite&lt;/code&gt; 경로를 가리킬 수 있습니다 . 옵션 &lt;code&gt;testcase&lt;/code&gt; 옵션에 해당이 &lt;code&gt;-case&lt;/code&gt; 프로그램에 &lt;code&gt;ct_run&lt;/code&gt; . 에 지정된 구성 파일 &lt;code&gt;Opts&lt;/code&gt; 시작시 자동으로 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="1d215e0a4d1f50aa10db8d5770d81f093532091e" translate="yes" xml:space="preserve">
          <source>Here a system configuration with an MG and MGC residing in one Erlang node each is outlined:</source>
          <target state="translated">여기에 하나의 Erlang 노드에 상주하는 MG 및 MGC를 사용한 시스템 구성이 간략하게 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="98f9cd42bd3f2f651c624dd6456d93b42bb7d908" translate="yes" xml:space="preserve">
          <source>Here also the path to the &lt;code&gt;pea-1.0&lt;/code&gt; ebin directory is provided.</source>
          <target state="translated">&lt;code&gt;pea-1.0&lt;/code&gt; ebin 디렉토리 의 경로도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="37285c244117c11d8428f0cbdceb6d27dd880c01" translate="yes" xml:space="preserve">
          <source>Here are a few suggestions for how to avoid deadlock:</source>
          <target state="translated">교착 상태를 피하는 방법에 대한 몇 가지 제안은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="922875c8c4eca4e656e135b3c76a4d89fd7a3552" translate="yes" xml:space="preserve">
          <source>Here are all type letters that are allowed on the left side of a transformation rule.</source>
          <target state="translated">다음은 변환 규칙의 왼쪽에 허용되는 모든 유형 문자입니다.</target>
        </trans-unit>
        <trans-unit id="64246a03dadd5871d19e3c38c5d243139b6de281" translate="yes" xml:space="preserve">
          <source>Here d is any number of decimal digits. However, the value of the setting must be less than the value set by the caller of &lt;code&gt;run/3&lt;/code&gt; for it to have any effect. That is, the pattern writer can lower the limit set by the programmer, but not raise it. If there is more than one setting of one of these limits, the lower value is used.</source>
          <target state="translated">여기에서 d는 임의의 십진수입니다. 그러나 설정 값은 &lt;code&gt;run/3&lt;/code&gt; 호출자가 설정 한 값보다 작아야 효과가 있습니다. 즉, 패턴 작성기는 프로그래머가 설정 한 한계를 낮출 수는 있지만 올릴 수는 없습니다. 이러한 한계 중 하나의 설정이 둘 이상인 경우 더 낮은 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="50c6e27284216f0fe5f85c8a2e068c1f3dc4d9db" translate="yes" xml:space="preserve">
          <source>Here each &lt;code&gt;ValueI&lt;/code&gt; is the default value for &lt;code&gt;FieldI&lt;/code&gt;.</source>
          <target state="translated">다음은 각 &lt;code&gt;ValueI&lt;/code&gt; 은 기본값입니다 &lt;code&gt;FieldI&lt;/code&gt; 은 .</target>
        </trans-unit>
        <trans-unit id="42052c3c2c41c15b35977cf7cbb047bcba82e64f" translate="yes" xml:space="preserve">
          <source>Here follows a client side example, divide into several steps for readability.</source>
          <target state="translated">다음은 클라이언트 측 예제를 따르며 가독성을 위해 여러 단계로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="9cbca54b367e1a4f6983365c6ace0c9e807f6a44" translate="yes" xml:space="preserve">
          <source>Here follows a description of the variables that are defined.</source>
          <target state="translated">다음은 정의 된 변수에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="4292ce9c08f629230d2ca9c9a4b58e4451d521bd" translate="yes" xml:space="preserve">
          <source>Here follows a series of examples ranging from simple to more complex.</source>
          <target state="translated">다음은 간단한 것에서 더 복잡한 것까지의 일련의 예제를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="7de541520f50013aebeb6484b87ccc69628a3a4f" translate="yes" xml:space="preserve">
          <source>Here follows a simple example of turning a gen_fsm into a &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt;. The example comes from the previous Users Guide for &lt;code&gt;gen_fsm&lt;/code&gt;</source>
          <target state="translated">여기에 gen_fsm 회전의 간단한 예는 다음 &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt; 를 . 이 예제는 이전 &lt;code&gt;gen_fsm&lt;/code&gt; 사용자 안내서에서 발췌 한 것입니다</target>
        </trans-unit>
        <trans-unit id="056d3b9258e32cd2a4368560fe9287c17631f021" translate="yes" xml:space="preserve">
          <source>Here follows a simple test specification example:</source>
          <target state="translated">다음은 간단한 테스트 사양 예입니다.</target>
        </trans-unit>
        <trans-unit id="d1a5f798f4fca1457852fb5ded06b31390f422db" translate="yes" xml:space="preserve">
          <source>Here follows a summary of the settings affecting Unicode:</source>
          <target state="translated">다음은 유니 코드에 영향을주는 설정에 대한 요약입니다.</target>
        </trans-unit>
        <trans-unit id="e3b0266f7e1ec5f16aeffe2f3cad390ea2d7f486" translate="yes" xml:space="preserve">
          <source>Here follows all types that are allowed to be used in operands for instructions being constructed on the right side of a transformation rule.</source>
          <target state="translated">다음은 변환 규칙의 오른쪽에 생성되는 명령어의 피연산자에서 사용할 수있는 모든 유형을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="36f3b865fe0de9bfe34af31066b4e1fd4775070c" translate="yes" xml:space="preserve">
          <source>Here follows an example of a text message to give a feeling of the difference between the pretty and compact versions of text messages. First the pretty printed, well indented version with long keywords:</source>
          <target state="translated">다음은 문자 메시지의 예와 컴팩트 버전 사이의 차이를 느끼기위한 문자 메시지의 예입니다. 먼저 긴 키워드로 잘 인쇄되고 들여 쓰기 된 버전입니다.</target>
        </trans-unit>
        <trans-unit id="7f638f5d7f0c6d062a7666cb5822d5e70a90f9fb" translate="yes" xml:space="preserve">
          <source>Here follows an example of a text message to give a feeling of the difference between the pretty and compact versions of text messages. First the pretty, well indented version with long keywords:</source>
          <target state="translated">다음은 문자 메시지의 예와 컴팩트 버전 사이의 차이를 느끼기위한 문자 메시지의 예입니다. 먼저 긴 키워드가 포함 된 예쁘고 들여 쓰기 된 버전입니다.</target>
        </trans-unit>
        <trans-unit id="63d190124d61370d24019073f53f96c2b39b3a1c" translate="yes" xml:space="preserve">
          <source>Here follows some questions that you might have after reading this section with corresponding tips and links to the answers:</source>
          <target state="translated">다음은이 섹션을 읽은 후 해당 팁과 답변 링크를 통해 얻을 수있는 몇 가지 질문입니다.</target>
        </trans-unit>
        <trans-unit id="bbd3c491062bf2c5eaa657373046fe305f85357c" translate="yes" xml:space="preserve">
          <source>Here follows the details of what exactly is returned.</source>
          <target state="translated">정확히 반환되는 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="df5e0247c5bebffe1acdce6f9b2820393133d959" translate="yes" xml:space="preserve">
          <source>Here follows the function of the old API. These functions only work on a list of Latin-1 characters.</source>
          <target state="translated">이전 API의 기능은 다음과 같습니다. 이 기능은 라틴 -1 문자 목록에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1e03b2fb11709d9ee5694c2236ecb3d219a8b412" translate="yes" xml:space="preserve">
          <source>Here follows the general configuration terms that are allowed in a cover specification file:</source>
          <target state="translated">다음은 표지 사양 파일에서 허용되는 일반 구성 용어입니다.</target>
        </trans-unit>
        <trans-unit id="e7402642ba6204e4b5e86065a76f140fdda43cbe" translate="yes" xml:space="preserve">
          <source>Here follows the type letters that more or less directly corresponds to the types for generic instructions.</source>
          <target state="translated">다음은 일반 명령어의 유형에 어느 정도 직접적으로 해당하는 유형 문자입니다.</target>
        </trans-unit>
        <trans-unit id="ce3bb36613c3cfade2e1099d8162ab6ab7c75926" translate="yes" xml:space="preserve">
          <source>Here follows type definitions that are used by more than one function in the ODBC API.</source>
          <target state="translated">다음은 ODBC API에서 둘 이상의 함수가 사용하는 유형 정의입니다.</target>
        </trans-unit>
        <trans-unit id="4cdd0b6622fc9da41960fdfdea1968c18c462ed7" translate="yes" xml:space="preserve">
          <source>Here is a bit more complex calculation:</source>
          <target state="translated">좀 더 복잡한 계산은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f4538b53d8767dd2d98b8e1093b19420fc4852f6" translate="yes" xml:space="preserve">
          <source>Here is a complete example. The &lt;code&gt;new_map&lt;/code&gt; instruction is defined like this:</source>
          <target state="translated">다음은 완전한 예입니다. &lt;code&gt;new_map&lt;/code&gt; 명령은 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="d349cc2e55bbdec82aca8231149986fa8cec97cd" translate="yes" xml:space="preserve">
          <source>Here is a function call as &lt;code&gt;convert_to_celsius({moscow,{c,-10}})&lt;/code&gt; as the argument to the function &lt;code&gt;print_temp&lt;/code&gt;. When function calls are &lt;strong&gt;nested&lt;/strong&gt; like this, they execute (evaluate) from the inside out. That is, first &lt;code&gt;convert_to_celsius({moscow,{c,-10}})&lt;/code&gt; is evaluated, which gives the value &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; as the temperature is already in Celsius. Then &lt;code&gt;print_temp({moscow,{c,-10}})&lt;/code&gt; is evaluated. The function &lt;code&gt;convert_to_celsius&lt;/code&gt; works in a similar way to the &lt;code&gt;convert_length&lt;/code&gt; function in the previous example.</source>
          <target state="translated">다음은 &lt;code&gt;print_temp&lt;/code&gt; 함수의 인수 로 &lt;code&gt;convert_to_celsius({moscow,{c,-10}})&lt;/code&gt; 라는 함수 호출 입니다. 함수 호출이 이와 같이 &lt;strong&gt;중첩&lt;/strong&gt; 되면 내부에서 외부로 실행 (평가)됩니다. 즉, 먼저 &lt;code&gt;convert_to_celsius({moscow,{c,-10}})&lt;/code&gt; 를 평가 하여 온도가 이미 섭씨 온도이므로 &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; 값을 제공합니다 . 그런 다음 &lt;code&gt;print_temp({moscow,{c,-10}})&lt;/code&gt; 가 평가됩니다. 함수 &lt;code&gt;convert_to_celsius&lt;/code&gt; 을 받는 유사한 방식으로 작동 &lt;code&gt;convert_length&lt;/code&gt; 의 앞의 예에서 기능.</target>
        </trans-unit>
        <trans-unit id="7b73ef99e7403f3927ff26a039c6e2a2236690f9" translate="yes" xml:space="preserve">
          <source>Here is a list of some of the MIBs defined in the OTP system:</source>
          <target state="translated">다음은 OTP 시스템에 정의 된 일부 MIB 목록입니다.</target>
        </trans-unit>
        <trans-unit id="22821c0d8cd96a6861d0a1d65f8c0f8148458395" translate="yes" xml:space="preserve">
          <source>Here is a more complete sequence that contains both adding, updating and removing breakpoints.</source>
          <target state="translated">다음은 중단 점 추가, 업데이트 및 제거를 모두 포함하는보다 완전한 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="f72c798b29ccb529841e5627093d7a56fd4814a8" translate="yes" xml:space="preserve">
          <source>Here is an example how the reserved virtual address space for literals can be raised to 2 GB (2048 MB):</source>
          <target state="translated">다음은 리터럴 용으로 예약 된 가상 주소 공간을 2GB (2048MB)로 늘릴 수있는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="ba858455c144cf3056c405c091e7501e673c5076" translate="yes" xml:space="preserve">
          <source>Here is an example of a suitable expression sequence:</source>
          <target state="translated">다음은 적절한 발현 시퀀스의 예입니다.</target>
        </trans-unit>
        <trans-unit id="00e38b026becd87996568d41fcc3b8f1d79752be" translate="yes" xml:space="preserve">
          <source>Here is an example of this option:</source>
          <target state="translated">이 옵션의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f74118ff53b9ac72b1f1d3c138c82f074dbcd87" translate="yes" xml:space="preserve">
          <source>Here is an example showing how values can be specified:</source>
          <target state="translated">다음은 값을 지정하는 방법을 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="b09da04e514cbcbfa274d3aa81a9da1bf964eb8e" translate="yes" xml:space="preserve">
          <source>Here is an example that shows how to count how many times each instruction is executed:</source>
          <target state="translated">다음은 각 명령어가 실행되는 횟수를 계산하는 방법을 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="e17a454a258af8149a5983e38860d0dd63592107" translate="yes" xml:space="preserve">
          <source>Here is an example. The config-file has the following contents:</source>
          <target state="translated">여기에 예가 있습니다. 구성 파일에는 다음 내용이 있습니다.</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">다음은 그 예입니다.</target>
        </trans-unit>
        <trans-unit id="82a08ca8184b592a01eaaa55a20f8527f4cca1b8" translate="yes" xml:space="preserve">
          <source>Here is an overview what has been done so far:</source>
          <target state="translated">지금까지 수행 한 작업에 대한 개요는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="368746ba7f8d7397bdc8b79dac1f30fb770a5d1c" translate="yes" xml:space="preserve">
          <source>Here is defined a function that doubles the value of a number and assigned this function to a variable. Thus &lt;code&gt;Xf(5)&lt;/code&gt; returns value 10. Two useful functions when working with lists are &lt;code&gt;foreach&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt;, which are defined as follows:</source>
          <target state="translated">여기에 숫자 값을 두 배로 늘리고이 함수를 변수에 할당하는 함수가 정의되어 있습니다. 따라서 &lt;code&gt;Xf(5)&lt;/code&gt; 는 값 10을 리턴합니다.리스트 작업시 유용한 두 가지 함수는 &lt;code&gt;foreach&lt;/code&gt; 및 &lt;code&gt;map&lt;/code&gt; 이며 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="7ce731a790a4205763d05d03b9cf196ef4e9261e" translate="yes" xml:space="preserve">
          <source>Here is how to accomplish the state time-out in the previous example by instead using a generic time-out named for example &lt;code&gt;open&lt;/code&gt;:</source>
          <target state="translated">다음은 예를 들어 &lt;code&gt;open&lt;/code&gt; 이라는 일반적인 시간 제한을 사용하여 이전 예제에서 상태 시간 초과를 달성하는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="a0d2cc3be9345b9bae90d4c70bae158e4ffa9f78" translate="yes" xml:space="preserve">
          <source>Here is how to accomplish the state time-out in the previous example by instead using an Erlang Timer:</source>
          <target state="translated">다음은 Erlang Timer를 사용하여 이전 예제에서 상태 시간 초과를 달성하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="eaf5ed4c0dabc7f41cc89c5f4a3aa5a863561e75" translate="yes" xml:space="preserve">
          <source>Here is only considered the case when Erlang/OTP is running on a UNIX system.</source>
          <target state="translated">여기서는 Erlang / OTP가 UNIX 시스템에서 실행될 때만 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="5522fd885b43a2eff23d532ec8cfc36c8effcd85" translate="yes" xml:space="preserve">
          <source>Here is the definition of &lt;code&gt;deallocate_return/1&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;deallocate_return/1&lt;/code&gt; 의 정의는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5f17fc708829cfc6fb00458e5b09fdb85b5ef940" translate="yes" xml:space="preserve">
          <source>Here is the ping pong example modified to run on two separate nodes:</source>
          <target state="translated">다음은 두 개의 개별 노드에서 실행되도록 수정 된 핑퐁 예제입니다.</target>
        </trans-unit>
        <trans-unit id="36bfcb0b8532e087fad81f46e3b585565729333b" translate="yes" xml:space="preserve">
          <source>Here keys &lt;code&gt;K1 .. Kn&lt;/code&gt; are any expressions with literals or bound variables. If all key expressions evalute successfully and all keys exist in map &lt;code&gt;M&lt;/code&gt;, all variables in &lt;code&gt;V1 .. Vn&lt;/code&gt; is matched to the associated values of their respective keys.</source>
          <target state="translated">여기서 키 &lt;code&gt;K1 .. Kn&lt;/code&gt; 은 리터럴 또는 바운드 변수가있는 표현식입니다. 모든 키 표현식이 성공적으로 평가되고 모든 키가 맵 &lt;code&gt;M&lt;/code&gt; 에 있으면 &lt;code&gt;V1 .. Vn&lt;/code&gt; 모든 변수가 해당 키의 관련 값과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="274b953d352c36df895d0e17f80b41429f1a2865" translate="yes" xml:space="preserve">
          <source>Here keys &lt;code&gt;K1 .. Kn&lt;/code&gt; are any expressions with literals or bound variables. If all keys exist in map &lt;code&gt;M&lt;/code&gt;, all variables in &lt;code&gt;V1 .. Vn&lt;/code&gt; is matched to the associated values of their respective keys.</source>
          <target state="translated">여기서 키 &lt;code&gt;K1 .. Kn&lt;/code&gt; 은 리터럴 또는 바운드 변수가있는 표현식입니다. 모든 키가 맵 &lt;code&gt;M&lt;/code&gt; 에 존재하는 경우 &lt;code&gt;V1 .. Vn&lt;/code&gt; 모든 변수는 해당 키의 연관된 값과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="69f329541992e8d01a4e5a912d3401c2919e27cf" translate="yes" xml:space="preserve">
          <source>Here more than one list is built. In each iteration step a new list is created that is one element longer than the new previous list.</source>
          <target state="translated">여기에 하나 이상의 목록이 작성됩니다. 각 반복 단계에서 새 이전 목록보다 하나의 요소보다 긴 새 목록이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="4207694f60edbd73e98081488a51ba1699a0f859" translate="yes" xml:space="preserve">
          <source>Here only the Kernel and STDLIB applications are started, that is, the system is started as an ordinary development system. Only two files are needed for all this to work:</source>
          <target state="translated">여기서는 커널 및 STDLIB 애플리케이션 만 시작됩니다. 즉, 시스템은 일반 개발 시스템으로 시작됩니다. 이 모든 것이 작동하려면 두 개의 파일 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1a01cbab019a5244984e7111de8ade2f66f53c2f" translate="yes" xml:space="preserve">
          <source>Here some initialization is done, &lt;code&gt;start&lt;/code&gt; is called from &lt;code&gt;open_port&lt;/code&gt;. The data will be passed to &lt;code&gt;control&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;.</source>
          <target state="translated">여기서 초기화가 완료되면 &lt;code&gt;open_port&lt;/code&gt; 에서 &lt;code&gt;start&lt;/code&gt; 가 호출됩니다 . 데이터는 &lt;code&gt;control&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="0dd38392b306d639490f3bfdab336a2923914d6c" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;is_eq_exact&lt;/code&gt; instruction is replaced with a specialized instruction that only compares literals, but only if the first operand is a register and the second operand is a literal.</source>
          <target state="translated">여기서 &lt;code&gt;is_eq_exact&lt;/code&gt; 명령어는 리터럴 만 비교하는 특수 명령어로 대체되지만 첫 번째 피연산자가 레지스터이고 두 번째 피연산자가 리터럴 인 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8285a3adddfb3c22982d47841765517ced8bef67" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;start/0&lt;/code&gt; function,</source>
          <target state="translated">여기 &lt;code&gt;start/0&lt;/code&gt; 함수</target>
        </trans-unit>
        <trans-unit id="6d1513bbb3276cbd3a38ec95089202ddef094a3d" translate="yes" xml:space="preserve">
          <source>Here the Ti's are atoms (the name of the type) and the Ai's are their arguments</source>
          <target state="translated">여기서 Ti는 원자 (타입의 이름)이고 Ai는 그들의 인수입니다</target>
        </trans-unit>
        <trans-unit id="9acec98c2e5c443462282bed38bd34c514085f2c" translate="yes" xml:space="preserve">
          <source>Here the call to the GC BIF &lt;code&gt;'+'/2&lt;/code&gt; will be replaced with the instruction &lt;code&gt;gen_plus/5&lt;/code&gt;. Note that the same name as used in the C source code must be used for the BIF, which in this case is &lt;code&gt;splus&lt;/code&gt;. It is defined like this in &lt;code&gt;bit.tab&lt;/code&gt;:</source>
          <target state="translated">여기서 GC BIF &lt;code&gt;'+'/2&lt;/code&gt; 에 대한 호출 은 &lt;code&gt;gen_plus/5&lt;/code&gt; 명령어로 대체됩니다 . C 소스 코드에 사용 된 것과 동일한 이름을 BIF에 사용해야합니다 . 이 경우에는 &lt;code&gt;splus&lt;/code&gt; 입니다. &lt;code&gt;bit.tab&lt;/code&gt; 에서 다음과 같이 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b79b4c75297735efc429805d3857e3fd989ff1f" translate="yes" xml:space="preserve">
          <source>Here the concept of an &lt;strong&gt;anonymous variable&lt;/strong&gt; &quot;_&quot; is introduced. This is simply shorthand for a variable that gets a value, but the value is ignored. This can be used anywhere suitable, not just in funs. &lt;code&gt;Temp1 &amp;lt; Temp2&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;Temp1&lt;/code&gt; is less than &lt;code&gt;Temp2&lt;/code&gt;.</source>
          <target state="translated">여기에 &lt;strong&gt;익명 변수&lt;/strong&gt; &quot;_&quot; 의 개념 이 소개됩니다. 이것은 값을 얻는 변수의 줄임말이지만 값은 무시됩니다. 이것은 재미뿐만 아니라 적절한 곳에서 사용할 수 있습니다. &lt;code&gt;Temp1 &amp;lt; Temp2&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;Temp1&lt;/code&gt; 적은보다 &lt;code&gt;Temp2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af3c6eb665702670ccab0184a2424627dfa000a9" translate="yes" xml:space="preserve">
          <source>Here the empty binary (&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;) represents the unassigned subpattern. In the &lt;code&gt;binary&lt;/code&gt; case, some information about the matching is therefore lost, as &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; can also be an empty string captured.</source>
          <target state="translated">여기서 빈 바이너리 ( &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; )는 할당되지 않은 하위 패턴을 나타냅니다. 에서 &lt;code&gt;binary&lt;/code&gt; 로하는 경우, 상기 매칭에 대한 정보는 따라서 소실된다 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 는 또한 캡처 빈 스트링 일 수있다.</target>
        </trans-unit>
        <trans-unit id="1abd874c2e02ed54ed46fd6eb351fd6b4434ff43" translate="yes" xml:space="preserve">
          <source>Here the file I/O server returns all available options for a file, which are the expected ones, &lt;code&gt;encoding&lt;/code&gt; and &lt;code&gt;binary&lt;/code&gt;. However, the standard shell has some more options:</source>
          <target state="translated">여기에서 파일 I / O 서버는 파일에 사용할 수있는 모든 옵션 ( &lt;code&gt;encoding&lt;/code&gt; 및 &lt;code&gt;binary&lt;/code&gt; 반환합니다 . 그러나 표준 쉘에는 몇 가지 옵션이 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6b28a4e54bbbd54cef63a1e3115ada96bc39316" translate="yes" xml:space="preserve">
          <source>Here the function &lt;code&gt;fac&amp;gt;&lt;/code&gt; in module &lt;code&gt;tut1&lt;/code&gt; is called with argument &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;tut1&lt;/code&gt; 모듈의 &lt;code&gt;fac&amp;gt;&lt;/code&gt; 함수 는 인수 &lt;code&gt;4&lt;/code&gt; 로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="e0d195818a01c51c6fa746b1e3cba1a090681218" translate="yes" xml:space="preserve">
          <source>Here the key to be retrieved is constructed from an expression:</source>
          <target state="translated">여기에서 검색 할 키는 표현식에서 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="76e0ad7418ef3374cc17d038856a722ae97d8a0c" translate="yes" xml:space="preserve">
          <source>Here the regular expression first matched the &quot;l&quot;, causing &quot;Er&quot; to be the first part in the result. When the regular expression matched, the (only) subexpression was bound to the &quot;l&quot;, so the &quot;l&quot; is inserted in the group together with &quot;Er&quot;. The next match is of the &quot;n&quot;, making &quot;a&quot; the next part to be returned. As the subexpression is bound to substring &quot;n&quot; in this case, the &quot;n&quot; is inserted into this group. The last group consists of the remaining string, as no more matches are found.</source>
          <target state="translated">여기서 정규 표현식은 먼저 &quot;l&quot;과 일치하여 결과에서 &quot;Er&quot;이 첫 번째 부분이되었습니다. 정규식이 일치하면 (전용) 하위 표현식이 &quot;l&quot;에 바인딩되어 있으므로 &quot;Er&quot;과 함께 그룹에 &quot;l&quot;이 삽입됩니다. 다음 일치는 &quot;n&quot;과 일치하여 &quot;a&quot;를 다음에 리턴 할 부분으로 만듭니다. 이 경우 하위 표현식이 하위 문자열 &quot;n&quot;에 바인딩되므로 &quot;n&quot;이이 그룹에 삽입됩니다. 더 이상 일치하는 항목이 없으므로 마지막 그룹은 나머지 문자열로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="1da2c5952d714e65a29c19457fda0a08e5b2194a" translate="yes" xml:space="preserve">
          <source>Here the return value correspondingly points out all of the string, beginning at index 0, and it is 10 characters long:</source>
          <target state="translated">여기에서 반환 값은 인덱스 0에서 시작하여 모든 문자열을 나타내며 길이는 10 자입니다.</target>
        </trans-unit>
        <trans-unit id="8a03dce83b236db4e1a3d7678c31aea14b2cf2d3" translate="yes" xml:space="preserve">
          <source>Here the second operand of &lt;code&gt;move&lt;/code&gt; is constrained to be X register 1.</source>
          <target state="translated">여기서 &lt;code&gt;move&lt;/code&gt; 의 두 번째 피연산자는 X 레지스터 1로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="8588926d91ef055e0e752b5cc02d17b611653864" translate="yes" xml:space="preserve">
          <source>Here the shell detects lists containing printable characters or binaries containing printable characters in bytewise or UTF-8 encoding. But what is a printable character? One view is that anything the Unicode standard thinks is printable, is also printable according to the heuristic detection. The result is then that almost any list of integers are deemed a string, and all sorts of characters are printed, maybe also characters that your terminal lacks in its font set (resulting in some unappreciated generic output). Another way is to keep it backward compatible so that only the ISO Latin-1 character set is used to detect a string. A third way is to let the user decide exactly what Unicode ranges that are to be viewed as characters.</source>
          <target state="translated">여기서 쉘은 인쇄 가능한 문자가 포함 된 목록 또는 인쇄 가능한 문자가 포함 된 이진 또는 바이트 단위 또는 UTF-8 인코딩으로 된 목록을 감지합니다. 그러나 인쇄 가능한 문자는 무엇입니까? 한 가지 관점은 유니 코드 표준이 인쇄 가능하다고 생각하는 것은 휴리스틱 감지에 따라 인쇄 가능하다는 것입니다. 결과적으로 거의 모든 정수 목록이 문자열로 간주되고 모든 종류의 문자가 인쇄됩니다. 어쩌면 터미널에 글꼴 세트에 부족한 문자가있을 수도 있습니다 (일부 이해할 수없는 일반 출력). 다른 방법은 ISO Latin-1 문자 세트 만 문자열을 감지하는 데 사용되도록 이전 버전과의 호환성을 유지하는 것입니다. 세 번째 방법은 사용자가 문자로 볼 유니 코드 범위를 정확하게 결정하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="74160bc743886e5a3198a381b4d2136a5e539152" translate="yes" xml:space="preserve">
          <source>Here the signature and message in the last example is verifyed using the public key. The public key is stored in an engine, only to exemplify that it is possible. The public key could of course be handled openly as usual.</source>
          <target state="translated">여기서 마지막 예의 서명과 메시지는 공개 키를 사용하여 확인됩니다. 퍼블릭 키는 엔진에 저장되어 있으며 가능한 것으로 보여줍니다. 공개 키는 물론 평소와 같이 공개적으로 처리 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2d4f1fdcedde1498c2f363b018c87e4697de1db" translate="yes" xml:space="preserve">
          <source>Here the user flag &lt;code&gt;-myflag 1&lt;/code&gt; is passed to and stored by the &lt;code&gt;init&lt;/code&gt; process. It is a user-defined flag, presumably used by some user-defined application.</source>
          <target state="translated">여기서 사용자 플래그 &lt;code&gt;-myflag 1&lt;/code&gt; 은 &lt;code&gt;init&lt;/code&gt; 프로세스로 전달되어 저장됩니다 . 사용자 정의 플래그이며, 일부 사용자 정의 응용 프로그램에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="402b80a6663c605b1c8ebefde4ea19bbe39ddf28" translate="yes" xml:space="preserve">
          <source>Here we also handle the mode (&lt;code&gt;binary&lt;/code&gt; or &lt;code&gt;list&lt;/code&gt;) that can be set by request &lt;code&gt;setopts&lt;/code&gt;. By default, all OTP I/O servers send data back to the client as lists, but switching mode to &lt;code&gt;binary&lt;/code&gt; can increase efficiency if the I/O server handles it in an appropriate way. The implementation of &lt;code&gt;get_until&lt;/code&gt; is difficult to get efficient, as the supplied function is defined to take lists as arguments, but &lt;code&gt;get_chars&lt;/code&gt; and &lt;code&gt;get_line&lt;/code&gt; can be optimized for binary mode. However, this example does not optimize anything.</source>
          <target state="translated">여기서 요청 &lt;code&gt;setopts&lt;/code&gt; 로 설정할 수있는 모드 ( &lt;code&gt;binary&lt;/code&gt; 또는 &lt;code&gt;list&lt;/code&gt; ) 도 처리합니다 . 기본적으로 모든 OTP I / O 서버는 데이터를 목록으로 클라이언트에 다시 전송하지만 I / O 서버가 적절한 방식으로 처리하는 경우 모드를 &lt;code&gt;binary&lt;/code&gt; 전환 하면 효율성이 향상 될 수 있습니다. 제공된 함수가 목록을 인수로 사용하도록 정의 &lt;code&gt;get_until&lt;/code&gt; 때문에 get_until 의 구현은 효율적이지 않습니다. 그러나 &lt;code&gt;get_chars&lt;/code&gt; 및 &lt;code&gt;get_line&lt;/code&gt; 은 2 진 모드에 대해 최적화 될 수 있습니다. 그러나이 예제는 아무것도 최적화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="713d45f85233ed9eece81ff1efd22a57b2efbd58" translate="yes" xml:space="preserve">
          <source>Here we check the result from postgres. If it is data, we encode it as lists of lists with column data. Everything from postgres is C strings, so we use &lt;code&gt;ei_x_encode_string&lt;/code&gt; to send the result as strings to Erlang. (The head of the list contains the column names.)</source>
          <target state="translated">postgres의 결과를 확인합니다. 데이터 인 경우 열 데이터가있는 목록 목록으로 인코딩합니다. postgres의 모든 것은 C 문자열이므로 &lt;code&gt;ei_x_encode_string&lt;/code&gt; 을 사용 하여 결과를 문자열로 Erlang에 보냅니다. (목록의 머리글에는 열 이름이 포함되어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="8cf9c63e747cf336dd3ef22dd8cb27c624c36fc6" translate="yes" xml:space="preserve">
          <source>Here we create an archive script containing both Erlang code and Beam code, then we iterate over all files in the archive and collect their contents and some information about them:</source>
          <target state="translated">여기에서 Erlang 코드와 Beam 코드가 모두 포함 된 아카이브 스크립트를 생성 한 다음 아카이브의 모든 파일을 반복하고 해당 컨텐츠와 파일에 대한 정보를 수집합니다.</target>
        </trans-unit>
        <trans-unit id="1a6714f5fe50c9a6bae77694ae3f43b0dac16cb9" translate="yes" xml:space="preserve">
          <source>Here we create file named &lt;code&gt;TAGS&lt;/code&gt; placed it in the directory &lt;code&gt;../projectdir&lt;/code&gt;. The file contains information about the functions, records, and macro definitions of the three files.</source>
          <target state="translated">여기서 &lt;code&gt;TAGS&lt;/code&gt; 라는 파일을 생성 하여 &lt;code&gt;../projectdir&lt;/code&gt; 디렉토리에 배치합니다 . 이 파일에는 세 파일의 기능, 레코드 및 매크로 정의에 대한 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9874d5ad87ce020d9aa6aeca71513d4b4236fc2e" translate="yes" xml:space="preserve">
          <source>Here we have cheated a little by more or less only implementing &lt;code&gt;get_until&lt;/code&gt; and using internal helpers to implement &lt;code&gt;get_chars&lt;/code&gt; and &lt;code&gt;get_line&lt;/code&gt;. In production code, this can be inefficient, but that depends on the frequency of the different requests. Before we start implementing functions &lt;code&gt;put_chars/2&lt;/code&gt; and &lt;code&gt;get_until/5&lt;/code&gt;, we examine the few remaining requests:</source>
          <target state="translated">여기서 우리는 &lt;code&gt;get_until&lt;/code&gt; 을 구현하고 &lt;code&gt;get_chars&lt;/code&gt; 와 &lt;code&gt;get_line&lt;/code&gt; 을 구현하기 위해 내부 헬퍼를 사용하여 조금만 부정했습니다 . 프로덕션 코드에서 이것은 비효율적 일 수 있지만 이는 다른 요청의 빈도에 따라 다릅니다. &lt;code&gt;put_chars/2&lt;/code&gt; 및 &lt;code&gt;get_until/5&lt;/code&gt; 함수 구현을 시작하기 전에 몇 가지 나머지 요청을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="6510718f8630e547e008ebde09d2abc7f3c89e66" translate="yes" xml:space="preserve">
          <source>Here we see that no function distinguishes itself considerably, which is very normal.</source>
          <target state="translated">여기서 우리는 어떤 기능도 그 자체를 크게 구별하지 않는 것을 보았습니다. 이는 매우 정상적인 것입니다.</target>
        </trans-unit>
        <trans-unit id="465ac4aff2d9132b9905c273ca86662ca9c4c44b" translate="yes" xml:space="preserve">
          <source>Here we will show how &lt;code&gt;i_increment&lt;/code&gt; can be implemented as a combined instruction. We will show each individual fragment first, and then show how to connect them together. First we will need a variable that we can store the value fetched from the register in:</source>
          <target state="translated">여기서는 &lt;code&gt;i_increment&lt;/code&gt; 가 결합 된 명령어로 구현되는 방법을 보여줍니다 . 먼저 각 개별 조각을 보여준 다음 서로 연결하는 방법을 보여줍니다. 먼저 레지스터에서 가져온 값을 저장할 수있는 변수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="eaf2aac2ad0fe378997e3d3e60e43ee8d81edf6f" translate="yes" xml:space="preserve">
          <source>Here you see the use of &lt;code&gt;|&lt;/code&gt; to get the first two elements from the list. If you try to get more elements from the list than there are elements in the list, an error is returned. Notice also the special case of the list with no elements, []:</source>
          <target state="translated">여기에서 &lt;code&gt;|&lt;/code&gt; 목록에서 처음 두 요소를 가져옵니다. 목록에 요소가있는 것보다 많은 요소를 목록에서 가져 오려고하면 오류가 반환됩니다. [] 요소가없는 목록의 특별한 경우도 주목하십시오.</target>
        </trans-unit>
        <trans-unit id="08b89fd2c7d9c7d70984a33c283c54baceee4244" translate="yes" xml:space="preserve">
          <source>Here's another example:</source>
          <target state="translated">또 다른 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7996ce3c70bc2e6c31030c0947978923388510ef" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are any expressions and &lt;code&gt;M0&lt;/code&gt; through &lt;code&gt;M4&lt;/code&gt; are the resulting map terms.</source>
          <target state="translated">여기서 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 는 &lt;code&gt;M0&lt;/code&gt; 에서 &lt;code&gt;M4&lt;/code&gt; 는 결과 맵 용어입니다.</target>
        </trans-unit>
        <trans-unit id="c7c0f63e6feeafed42e889764b5df7fa6ae6b07c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Arguments&lt;/code&gt; is a list of zero or more arguments. The &lt;code&gt;-callback&lt;/code&gt; attribute is to be preferred since the extra type information can be used by tools to produce documentation or find discrepancies.</source>
          <target state="translated">여기서 &lt;code&gt;Arguments&lt;/code&gt; 는 0 개 이상의 인수 목록입니다. &lt;code&gt;-callback&lt;/code&gt; 속성은 별도의 유형 정보는 문서를 작성하거나 불일치를 찾는 도구에서 사용 할 수 있기 때문에 선호된다.</target>
        </trans-unit>
        <trans-unit id="2f63ec204ef51669a64a9412596d13bb3d314da9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Bin&lt;/code&gt; is bound and the elements are bound or unbound, as in any match.</source>
          <target state="translated">여기서 &lt;code&gt;Bin&lt;/code&gt; 은 바인딩되고 요소는 바인딩과 마찬가지로 바인딩되거나 바인딩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="973cdf584bee5b3aebaf02a66418e8e39a601f3c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Expr&lt;/code&gt; is an arbitrary expression, and each &lt;code&gt;Qualifier&lt;/code&gt; is either a generator or a filter.</source>
          <target state="translated">여기서 &lt;code&gt;Expr&lt;/code&gt; 은 임의의 표현이며 각 &lt;code&gt;Qualifier&lt;/code&gt; 는 생성기 또는 필터입니다.</target>
        </trans-unit>
        <trans-unit id="bfa551fd993d5a7e252540038e550aefce8b5242" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Fd&lt;/code&gt; is the file descriptor for the destination file, or the atom &lt;code&gt;standard_io&lt;/code&gt;. &lt;code&gt;_TraceInfo&lt;/code&gt; contains information from the trace information file (see section &lt;code&gt;&lt;a href=&quot;#trace_info&quot;&gt;Trace Information and File .ti&lt;/a&gt;&lt;/code&gt;). &lt;code&gt;State&lt;/code&gt; is a state variable for the format handler fun. The initial value of variable &lt;code&gt;State&lt;/code&gt; is specified with the handler option, for example:</source>
          <target state="translated">여기서 &lt;code&gt;Fd&lt;/code&gt; 는 대상 파일의 파일 설명자 또는 atom &lt;code&gt;standard_io&lt;/code&gt; 입니다. &lt;code&gt;_TraceInfo&lt;/code&gt; 는 추적 정보 파일의 정보를 포함합니다 ( &lt;code&gt;&lt;a href=&quot;#trace_info&quot;&gt;Trace Information and File .ti&lt;/a&gt;&lt;/code&gt; 섹션 참조 ). &lt;code&gt;State&lt;/code&gt; 는 형식 핸들러 fun에 대한 상태 변수입니다. 변수 &lt;code&gt;State&lt;/code&gt; 의 초기 값은 다음 과 같이 핸들러 옵션으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="034cc33bbe80f01fd04e26b576b575b1176dd3da" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;File&lt;/code&gt; is used as the new variable instead of &lt;code&gt;X&lt;/code&gt;. This is not so wise because code in the fun body cannot refer to the variable &lt;code&gt;File&lt;/code&gt;, which is defined outside of the fun. Compiling this example gives the following diagnostic:</source>
          <target state="translated">여기서 &lt;code&gt;File&lt;/code&gt; 은 &lt;code&gt;X&lt;/code&gt; 대신 새 변수로 사용됩니다 . 펀 바디의 코드가 펀 외부에 정의 된 변수 &lt;code&gt;File&lt;/code&gt; 을 참조 할 수 없기 때문에 그렇게 현명하지 않습니다 . 이 예제를 컴파일하면 다음과 같은 진단이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5adef5db9dcd73f5eebe767f23b82b503f930844" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;S1LogDir&lt;/code&gt; and &lt;code&gt;S2LogDir&lt;/code&gt; are the directories named &lt;code&gt;&amp;lt;TestName&amp;gt;.logs&lt;/code&gt; for each test respectively.</source>
          <target state="translated">여기서 &lt;code&gt;S1LogDir&lt;/code&gt; 및 &lt;code&gt;S2LogDir&lt;/code&gt; 은 각각의 테스트에 대한 &lt;code&gt;&amp;lt;TestName&amp;gt;.logs&lt;/code&gt; 디렉토리 입니다.</target>
        </trans-unit>
        <trans-unit id="eb55d7bcff03863047df1e0e245a8ad25b9600d1" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;conn_types&lt;/code&gt; specifies SSH, Telnet, FTP, RPC, and/or SNMP.</source>
          <target state="translated">여기서 &lt;code&gt;conn_types&lt;/code&gt; 는 SSH, Telnet, FTP, RPC 및 / 또는 SNMP를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4daf6d3bc463f7669637809f88efe649c2ac2625" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;demo()&lt;/code&gt; evaluates to &lt;code&gt;&quot;Robert&quot;&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;demo()&lt;/code&gt; 는 &lt;code&gt;&quot;Robert&quot;&lt;/code&gt; 로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="3fefc36dd07702f1db04b9023b0ea8fdf578263c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;init&lt;/code&gt; does not need any input data and ignores its argument. For &lt;code&gt;terminal_logger&lt;/code&gt;, the internal state is not used. For &lt;code&gt;file_logger&lt;/code&gt;, the internal state is used to save the open file descriptor.</source>
          <target state="translated">여기서 &lt;code&gt;init&lt;/code&gt; 는 입력 데이터가 필요하지 않으며 인수를 무시합니다. 들면 &lt;code&gt;terminal_logger&lt;/code&gt; , 내부 상태는 사용되지 않는다. 들어 &lt;code&gt;file_logger&lt;/code&gt; , 내부 상태는 열린 파일 디스크립터를 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aba5e0fd19010e47f153b1c0f6d8f4209d232205" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;tuplep&lt;/code&gt; points to an &lt;code&gt;ETERM&lt;/code&gt; struct representing a tuple with two elements; the function name (atom) and the argument (integer). Using the function &lt;code&gt;erl_element()&lt;/code&gt; from &lt;code&gt;erl_eterm&lt;/code&gt;, these elements can be extracted, but they must also be declared as pointers to an &lt;code&gt;ETERM&lt;/code&gt; struct:</source>
          <target state="translated">여기서, &lt;code&gt;tuplep&lt;/code&gt; 의 포인트 &lt;code&gt;ETERM&lt;/code&gt; 의 두 요소 튜플을 나타내는 구조체; 함수 이름 (아톰) 및 인수 (정수) 기능 사용 &lt;code&gt;erl_element()&lt;/code&gt; 에서 &lt;code&gt;erl_eterm&lt;/code&gt; 을 이러한 요소를 추출 할 수 있지만, 또한 포인터로 선언해야 &lt;code&gt;ETERM&lt;/code&gt; 의 구조체 :</target>
        </trans-unit>
        <trans-unit id="3c764964387488a9567355a791b642a791153d46" translate="yes" xml:space="preserve">
          <source>Here, the communication with C is hidden in the implementation of &lt;code&gt;complex.erl&lt;/code&gt;. In the following sections, it is shown how this module can be implemented using the different interoperability mechanisms.</source>
          <target state="translated">여기서 &lt;code&gt;complex.erl&lt;/code&gt; 구현에서 C와의 통신은 숨겨져 있습니다. 다음 섹션에서는 다양한 상호 운용성 메커니즘을 사용하여이 모듈을 구현하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a9363a371565a254c5f940c661f77bc4aea0306a" translate="yes" xml:space="preserve">
          <source>Here, the data type &lt;code&gt;'IssuingDistributionPoint'&lt;/code&gt; is represented as the following Erlang record:</source>
          <target state="translated">여기에서 데이터 유형 &lt;code&gt;'IssuingDistributionPoint'&lt;/code&gt; 는 다음 Erlang 레코드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="27fe64fbf8e84fafc5f91f9a5e3d6acc46a097cf" translate="yes" xml:space="preserve">
          <source>Here, the directive &lt;code&gt;on_load&lt;/code&gt; is used to get function &lt;code&gt;init&lt;/code&gt; to be automatically called when the module is loaded. If &lt;code&gt;init&lt;/code&gt; returns anything other than &lt;code&gt;ok&lt;/code&gt;, such when the loading of the NIF library fails in this example, the module is unloaded and calls to functions within it, fail.</source>
          <target state="translated">여기서 &lt;code&gt;on_load&lt;/code&gt; 지시문 은 모듈이로드 될 때 함수 &lt;code&gt;init&lt;/code&gt; 가 자동으로 호출되도록 하는 데 사용됩니다 . 경우 &lt;code&gt;init&lt;/code&gt; 이외의 반환 아무것도 &lt;code&gt;ok&lt;/code&gt; 의 NIF 라이브러리의 로딩이 예에서 실패 할 때 같은 모듈이 언로드 전화를 걸고 그 안에 기능에 실패.</target>
        </trans-unit>
        <trans-unit id="6256ecd948c793aa1993c3c12236863caa0abcfe" translate="yes" xml:space="preserve">
          <source>Here, the handler also provides for dynamically reloading of configuration variables. If &lt;code&gt;&lt;a href=&quot;ct#reload_config-1&quot;&gt;ct:reload_config(localtime)&lt;/a&gt;&lt;/code&gt; is called from the test case function, all variables loaded with &lt;code&gt;config_driver:read_config/1&lt;/code&gt; are updated with their latest values, and the new value for variable &lt;code&gt;localtime&lt;/code&gt; is returned.</source>
          <target state="translated">여기서 핸들러는 구성 변수를 동적으로 다시로드 할 수도 있습니다. 경우 &lt;code&gt;&lt;a href=&quot;ct#reload_config-1&quot;&gt;ct:reload_config(localtime)&lt;/a&gt;&lt;/code&gt; 테스트 케이스로부터 함수 호출, 모든 변수는로드 &lt;code&gt;config_driver:read_config/1&lt;/code&gt; 최신의 값으로 갱신하고, 변수에 대한 새로운 값 &lt;code&gt;localtime&lt;/code&gt; 반환된다.</target>
        </trans-unit>
        <trans-unit id="e9736652812b2b809017435f7a09559dc888bc0b" translate="yes" xml:space="preserve">
          <source>Here, the same test run as in the previous examples are executed (and possibly repeated). However, when the time-out occurs, after 1 hour, &lt;code&gt;Common Test&lt;/code&gt; finishes the entire test run before stopping (that is, both &lt;code&gt;to1&lt;/code&gt; and &lt;code&gt;to2&lt;/code&gt; are always executed in the same test run).</source>
          <target state="translated">여기에서는 이전 예제와 동일한 테스트 실행이 실행됩니다 (가능한 경우 반복 될 수 있음). 그러나 시간 종료가 발생하면 1 시간 후에 &lt;code&gt;Common Test&lt;/code&gt; 는 중지하기 전에 전체 테스트 실행을 완료합니다 (즉, &lt;code&gt;to1&lt;/code&gt; 과 &lt;code&gt;to2&lt;/code&gt; 는 항상 동일한 테스트 실행에서 실행 됨).</target>
        </trans-unit>
        <trans-unit id="3cf47ffc88aa174995add08f4cbe16924d5664a9" translate="yes" xml:space="preserve">
          <source>Here, the same tests as in Example 1 are run, but with flag &lt;code&gt;force_stop&lt;/code&gt; set to &lt;code&gt;skip_rest&lt;/code&gt;. If time-out occurs while executing tests in directory &lt;code&gt;to1&lt;/code&gt;, the remaining test cases in &lt;code&gt;to1&lt;/code&gt; are skipped and the test is aborted without running the tests in &lt;code&gt;to2&lt;/code&gt; another time. If time-out occurs while executing tests in directory &lt;code&gt;to2&lt;/code&gt;, the remaining test cases in &lt;code&gt;to2&lt;/code&gt; are skipped and the test is aborted.</source>
          <target state="translated">여기서는 예제 1과 동일한 테스트가 실행되지만 &lt;code&gt;force_stop&lt;/code&gt; 플래그 가 &lt;code&gt;skip_rest&lt;/code&gt; 로 설정되었습니다 . 디렉토리에서 테스트 실행 중에 타임 아웃이 발생하면 &lt;code&gt;to1&lt;/code&gt; , 나머지 테스트 케이스 &lt;code&gt;to1&lt;/code&gt; 생략하며 테스트에서 테스트를 실행하지 않고 중단 &lt;code&gt;to2&lt;/code&gt; 다른 시간. 디렉토리에서 테스트 실행 중에 타임 아웃이 발생하면 &lt;code&gt;to2&lt;/code&gt; , 나머지 테스트 케이스 &lt;code&gt;to2&lt;/code&gt; 스킵되어 시험이 중단된다.</target>
        </trans-unit>
        <trans-unit id="8725eccd38a40d0e24f360a6bca5f39b565b9081" translate="yes" xml:space="preserve">
          <source>Here, the segment corresponding to the &lt;code&gt;Opts&lt;/code&gt; variable has a &lt;strong&gt;type modifier&lt;/strong&gt;, specifying that &lt;code&gt;Opts&lt;/code&gt; is to bind to a binary. All other variables have the default type equal to unsigned integer.</source>
          <target state="translated">여기에서 &lt;code&gt;Opts&lt;/code&gt; 변수에 해당하는 세그먼트 에는 &lt;strong&gt;유형 수정자가&lt;/strong&gt; 있으며 &lt;code&gt;Opts&lt;/code&gt; 가 이진에 바인딩되도록 지정 합니다 . 다른 모든 변수는 기본 유형이 부호없는 정수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="38c740b102d15d34f934831a4b2e6f07729ae300" translate="yes" xml:space="preserve">
          <source>Here, the suites in test directory &lt;code&gt;to1&lt;/code&gt;, followed by the suites in &lt;code&gt;to2&lt;/code&gt;, are executed in one test run. A time-out event occurs after 10 minutes. As long as there is time left, &lt;code&gt;Common Test&lt;/code&gt; repeats the test run (that is, starting over with test &lt;code&gt;to1&lt;/code&gt;). After time-out, &lt;code&gt;Common Test&lt;/code&gt; stops when the current job is finished (because of flag &lt;code&gt;force_stop&lt;/code&gt;). As a result, the specified test run can be aborted after test &lt;code&gt;to1&lt;/code&gt; and before test &lt;code&gt;to2&lt;/code&gt;.</source>
          <target state="translated">여기서 테스트 디렉토리 &lt;code&gt;to1&lt;/code&gt; 의 스위트와 &lt;code&gt;to2&lt;/code&gt; 의 스위트 는 한 번의 테스트 실행으로 실행됩니다. 시간 초과 이벤트는 10 분 후에 발생합니다. 남은 시간이 있으면 &lt;code&gt;Common Test&lt;/code&gt; 는 테스트 실행을 반복합니다 (즉, test &lt;code&gt;to1&lt;/code&gt; 로 시작 ). 시간 종료 후 현재 작업이 완료되면 (플래그 &lt;code&gt;force_stop&lt;/code&gt; 때문에) &lt;code&gt;Common Test&lt;/code&gt; 가 중지됩니다 . 그 결과, 지정된 테스트 실행은 테스트 후 중단 할 수 &lt;code&gt;to1&lt;/code&gt; 및 테스트하기 전에 &lt;code&gt;to2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f1fe1239da690637d154f58466f31d750de5a7b" translate="yes" xml:space="preserve">
          <source>Here, the test run, including both the &lt;code&gt;to1&lt;/code&gt; and the &lt;code&gt;to2&lt;/code&gt; test, is repeated five times.</source>
          <target state="translated">여기서는 &lt;code&gt;to1&lt;/code&gt; 및 &lt;code&gt;to2&lt;/code&gt; 테스트를 포함한 테스트 실행 이 5 회 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="52a7e5fe849b80f2c39e4eb11c178f9187a0c7ff" translate="yes" xml:space="preserve">
          <source>Here, the tests specified by &quot;ts1&quot; run first, then the tests specified by &quot;ts2&quot;, and finally the tests specified by both &quot;ts3&quot; and &quot;ts4&quot;.</source>
          <target state="translated">여기서 &quot;ts1&quot;로 지정된 테스트가 먼저 실행 된 다음 &quot;ts2&quot;로 지정된 테스트가 완료되고 마지막으로 &quot;ts3&quot;및 &quot;ts4&quot;가 지정된 테스트가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="872d6af667b9983eb38e96eba5f3443d21c88017" translate="yes" xml:space="preserve">
          <source>Here, the variable &lt;code&gt;X&lt;/code&gt;, defined in the head of the fun, is a new variable. The variable &lt;code&gt;Stream&lt;/code&gt;, which is used within the fun, gets its value from the &lt;code&gt;file:open&lt;/code&gt; line.</source>
          <target state="translated">여기서 재미의 머리 부분에 정의 된 변수 &lt;code&gt;X&lt;/code&gt; 는 새로운 변수입니다. fun 내에서 사용되는 변수 &lt;code&gt;Stream&lt;/code&gt; 은 &lt;code&gt;file:open&lt;/code&gt; 줄 에서 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="7e0c04fa994ff203608b787f3eac3297ddf1fb91" translate="yes" xml:space="preserve">
          <source>Here, white text is used instead of the default black for &lt;code&gt;div.error&lt;/code&gt; printouts (and no other attribute settings for &lt;code&gt;pre&lt;/code&gt; are affected).</source>
          <target state="translated">여기에서 &lt;code&gt;div.error&lt;/code&gt; 출력에 기본 검정 대신 흰색 텍스트가 사용됩니다 ( &lt;code&gt;pre&lt;/code&gt; 에 대한 다른 속성 설정 은 영향을받지 않음).</target>
        </trans-unit>
        <trans-unit id="714626a23a6977a3ba1a4332c0cb63aa0f04303b" translate="yes" xml:space="preserve">
          <source>Here,&lt;code&gt;ERL_NIF_INIT&lt;/code&gt; has the following arguments:</source>
          <target state="translated">여기서, &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; 는 다음 인수가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a1e31a79ba26a76d28a87c7ed0407b897f88b5e6" translate="yes" xml:space="preserve">
          <source>Here:</source>
          <target state="translated">Here:</target>
        </trans-unit>
        <trans-unit id="ad89343a3d3c4ba891ac4b0730bfade95df05420" translate="yes" xml:space="preserve">
          <source>Heuristic Identification of UTF-8</source>
          <target state="translated">UTF-8의 휴리스틱 식별</target>
        </trans-unit>
        <trans-unit id="6d3b73d033962cbf0bbbb6396f3106e5fadd47c5" translate="yes" xml:space="preserve">
          <source>Heuristic String Detection</source>
          <target state="translated">휴리스틱 문자열 감지</target>
        </trans-unit>
        <trans-unit id="9e6e39c49e52c38684133449dae27a843c8c9f66" translate="yes" xml:space="preserve">
          <source>Hexadecimal digits</source>
          <target state="translated">16 진수</target>
        </trans-unit>
        <trans-unit id="01a101ab62a2560ab10ccb525aa4aba316d01a17" translate="yes" xml:space="preserve">
          <source>HiPE is automatically enabled on the following systems:</source>
          <target state="translated">HiPE는 다음 시스템에서 자동으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="49e76954bbaf300a103840561af720f16c024018" translate="yes" xml:space="preserve">
          <source>HiPE supports the following system configurations:</source>
          <target state="translated">HiPE는 다음 시스템 구성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c5263066d763fc26b746c69fd8481a0f61325e1a" translate="yes" xml:space="preserve">
          <source>Hide menu:</source>
          <target state="translated">메뉴 숨기기 :</target>
        </trans-unit>
        <trans-unit id="a02b1f8d870b852383550616297df9f10e5bc8ba" translate="yes" xml:space="preserve">
          <source>High fault tolerance</source>
          <target state="translated">높은 내결함성</target>
        </trans-unit>
        <trans-unit id="fb49d95db3dc9749450850f23cb259dfa334590a" translate="yes" xml:space="preserve">
          <source>High-Level Instructions</source>
          <target state="translated">고급 지침</target>
        </trans-unit>
        <trans-unit id="e5a92cb9a3146c86050022c2169e16055f62bf41" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt; resolution&lt;/a&gt;&lt;/code&gt; of current OS monotonic time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt; accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt; precision&lt;/a&gt;&lt;/code&gt; aligns with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;.</source>
          <target state="translated">현재 OS 단조로운 시간 소스의 가능한 최고 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt; resolution&lt;/a&gt;&lt;/code&gt; 초당 부품 수). OS에서 해상도 정보를 검색 할 수없는 경우 &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; 은 &lt;code&gt;Function&lt;/code&gt; s 반환 값 의 시간 단위 해상도로 설정됩니다 . 즉, 실제 해상도는 &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; 보다 낮을 수 있습니다 . 해상도는 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt; accuracy&lt;/a&gt;&lt;/code&gt; 나 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt; precision&lt;/a&gt;&lt;/code&gt; 가 해상도와 일치 하는지 여부 에 대해 아무 말도하지 않습니다 . 그러나 정밀도가 &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; 보다 낫지 않다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7116b5f034f81df6881fb6c021d526c89a62a5d" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt; resolution&lt;/a&gt;&lt;/code&gt; of current OS system time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt; accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt; precision&lt;/a&gt;&lt;/code&gt; do align with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;.</source>
          <target state="translated">현재 OS 시스템 시간 소스의 가능한 최고 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt; resolution&lt;/a&gt;&lt;/code&gt; 초당 부품). OS에서 해상도 정보를 검색 할 수없는 경우 &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; 은 &lt;code&gt;Function&lt;/code&gt; s 반환 값 의 시간 단위 해상도로 설정됩니다 . 즉, 실제 해상도는 &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; 보다 낮을 수 있습니다 . 해상도는 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt; accuracy&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt; precision&lt;/a&gt;&lt;/code&gt; 가 해상도와 일치 하는지 여부 에 대해 아무 말도하지 않습니다 . 그러나 정밀도가 &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; 보다 낫지 않다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="322a5670551101a31a0c53538057253089ee212f" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; of current OS monotonic time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; aligns with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;.</source>
          <target state="translated">현재 OS 단조 시간 소스의 초당 가능한 최고 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; . OS에서 해상도 정보를 검색 할 수없는 경우 &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; 은 &lt;code&gt;Function&lt;/code&gt; 반환 값 의 시간 단위 해상도로 설정됩니다 . 즉, 실제 해상도는 &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; 보다 낮을 수 있습니다 . 해상도는 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; 가 해상도와 정렬 되는지 여부 에 대해 아무 것도 말하지 않습니다 . 그러나 정밀도가 &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; 보다 좋지 않다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="fab9cfbcb573ef66eead85a0dd57991922c30f3e" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; of current OS system time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; do align with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;.</source>
          <target state="translated">현재 OS 시스템 시간 원본의 초당 가능한 최고 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; . OS에서 해상도 정보를 검색 할 수없는 경우 &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; 은 &lt;code&gt;Function&lt;/code&gt; 반환 값 의 시간 단위 해상도로 설정됩니다 . 즉, 실제 해상도는 &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; 보다 낮을 수 있습니다 . 해상도는 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; 가 해상도와 일치 하는지 여부 에 대해 아무 것도 말하지 않습니다 . 그러나 정밀도가 &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; 보다 좋지 않다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba1d0a643c81d860412a884b89435cac1cf023d7" translate="yes" xml:space="preserve">
          <source>Hiragana</source>
          <target state="translated">Hiragana</target>
        </trans-unit>
        <trans-unit id="b5e5ac0463ba83ccbf0cfb19cb8721b646cc77b2" translate="yes" xml:space="preserve">
          <source>Hmac functions - &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2104.txt&quot;&gt; Keyed-Hashing for Message Authentication (RFC 2104) &lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Hmac 기능- &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2104.txt&quot;&gt; Keyed-Hashing for Message Authentication (RFC 2104) &lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70f8bb9a8a5393ef080507a89e4b98d139000d65" translate="yes" xml:space="preserve">
          <source>Home</source>
          <target state="translated">Home</target>
        </trans-unit>
        <trans-unit id="e62704259a03fb1bde2c8d41669196ad51d0310c" translate="yes" xml:space="preserve">
          <source>Hook option &lt;code&gt;log_type&lt;/code&gt; can be used to change the &lt;code&gt;cth_conn_log&lt;/code&gt; behavior. The default value of this option is &lt;code&gt;raw&lt;/code&gt;, which results in the behavior described above. If the value is set to &lt;code&gt;html&lt;/code&gt;, all Telnet communication is printed to the test case HTML log instead.</source>
          <target state="translated">후크 옵션 &lt;code&gt;log_type&lt;/code&gt; 을 사용하여 &lt;code&gt;cth_conn_log&lt;/code&gt; 동작 을 변경할 수 있습니다 . 이 옵션의 기본값은 &lt;code&gt;raw&lt;/code&gt; 이며 위에서 설명한 동작이 발생합니다. 값이 &lt;code&gt;html&lt;/code&gt; 로 설정 되면 모든 Telnet 통신이 대신 테스트 케이스 HTML 로그에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="e16590a1a84c1baec0f43c0dcc1d470ab6fb6020" translate="yes" xml:space="preserve">
          <source>Hook option &lt;code&gt;log_type&lt;/code&gt; specifies the type of logging:</source>
          <target state="translated">후크 옵션 &lt;code&gt;log_type&lt;/code&gt; 은 로깅 유형을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2b7ba976df46f73b2bc0332579201ada04d174eb" translate="yes" xml:space="preserve">
          <source>Hook options specified in a configuration file overwrite any hard-coded hook options in the test suite.</source>
          <target state="translated">구성 파일에 지정된 후크 옵션은 테스트 스위트의 하드 코드 된 후크 옵션을 겹쳐 씁니다.</target>
        </trans-unit>
        <trans-unit id="e5130a72c3ee4bac41361eafe24a09e720b6ee4d" translate="yes" xml:space="preserve">
          <source>Hook options specified in a configuration file overwrite the hard-coded hook options in the test suite.</source>
          <target state="translated">구성 파일에 지정된 후크 옵션은 테스트 스위트의 하드 코드 된 후크 옵션을 겹쳐 씁니다.</target>
        </trans-unit>
        <trans-unit id="5699a47d64ec5afff9a00f44aa11f36f6b5577a8" translate="yes" xml:space="preserve">
          <source>Hop-by-Hop and End-to-End Identifiers are set by diameter when sending outgoing requests.</source>
          <target state="translated">홉별 및 엔드-투-엔드 식별자는 발신 요청을 보낼 때 직경으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b856160c3f11849f763958bfca750f4da4f8b030" translate="yes" xml:space="preserve">
          <source>Horizontal tab (HT)</source>
          <target state="translated">가로 탭 (HT)</target>
        </trans-unit>
        <trans-unit id="de7f8e30d370dbed377d6f3ec1e0f3638d8f7cd7" translate="yes" xml:space="preserve">
          <source>Host :: string(),</source>
          <target state="translated">호스트 :: string (),</target>
        </trans-unit>
        <trans-unit id="288369442ce4af9ee861578e5997944104806d11" translate="yes" xml:space="preserve">
          <source>Host = &lt;code&gt;string() | ip_address()&lt;/code&gt;</source>
          <target state="translated">호스트 = &lt;code&gt;string() | ip_address()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0506d8d8a9c994a9c2061822e71fa219eaa60fb" translate="yes" xml:space="preserve">
          <source>Host is not found, FTP server is not found, or connection is rejected by FTP server.</source>
          <target state="translated">호스트를 찾을 수 없거나 FTP 서버를 찾을 수 없거나 FTP 서버에서 연결을 거부했습니다.</target>
        </trans-unit>
        <trans-unit id="19cf18d3bb45fb6c52bc7c972db763badac874f9" translate="yes" xml:space="preserve">
          <source>Host key algorithm.</source>
          <target state="translated">호스트 키 알고리즘.</target>
        </trans-unit>
        <trans-unit id="072282c1e2f294945717832e050c84248cb48a99" translate="yes" xml:space="preserve">
          <source>Host key(s)</source>
          <target state="translated">호스트 키</target>
        </trans-unit>
        <trans-unit id="addc5b9c7be01cab649badaad9fe245dd85b99a6" translate="yes" xml:space="preserve">
          <source>Host public key(s)</source>
          <target state="translated">호스트 공개 키</target>
        </trans-unit>
        <trans-unit id="8dea1bfa3d5f782d439b94a2dc9e26fd4b92b4b3" translate="yes" xml:space="preserve">
          <source>Host,</source>
          <target state="translated">Host,</target>
        </trans-unit>
        <trans-unit id="22d5d7183ae1bff52681fe92c469a1efdf2db570" translate="yes" xml:space="preserve">
          <source>Host-IP-Address AVP</source>
          <target state="translated">호스트 IP 주소 AVP</target>
        </trans-unit>
        <trans-unit id="1db3d3092adcf5851af85b54fd2dcaa3d13b20b7" translate="yes" xml:space="preserve">
          <source>Hostname extraction</source>
          <target state="translated">호스트 이름 추출</target>
        </trans-unit>
        <trans-unit id="cc902a2f4f94e0590cff3fb32bacd18c59026842" translate="yes" xml:space="preserve">
          <source>Hostname is the result of calling net_adm:localhost() in the Erlang node where this funcion is called.</source>
          <target state="translated">호스트 이름은이 기능이 호출 된 Erlang 노드에서 net_adm : localhost ()를 호출 한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="e41e038a1831d791d3fb46209bc95e438998e2ba" translate="yes" xml:space="preserve">
          <source>Hostname of the node, &lt;code&gt;host&lt;/code&gt;</source>
          <target state="translated">노드의 호스트 이름, &lt;code&gt;host&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="abd2f083d046f4cdd3824b5ac6815216f33f9d44" translate="yes" xml:space="preserve">
          <source>Hostnames and host addresses</source>
          <target state="translated">호스트 이름 및 호스트 주소</target>
        </trans-unit>
        <trans-unit id="acf387fac0d70500029ecc75aef45e78a2439ddf" translate="yes" xml:space="preserve">
          <source>How categories can be mapped to CSS tags is documented in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#html_stylesheet&quot;&gt;HTML Style Sheets&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analyzing Results.</source>
          <target state="translated">카테고리를 CSS 태그에 매핑하는 방법은 테스트 실행 및 결과 분석 섹션의 &lt;code&gt;&lt;a href=&quot;run_test_chapter#html_stylesheet&quot;&gt;HTML Style Sheets&lt;/a&gt;&lt;/code&gt; 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4591aaae8b0152f47a2818f3eda6105fd1deb44b" translate="yes" xml:space="preserve">
          <source>How code is compiled and loaded is not a language issue, but is system-dependent. This section describes compilation and code loading in Erlang/OTP with references to relevant parts of the documentation.</source>
          <target state="translated">코드를 컴파일하고로드하는 방법은 언어 문제가 아니라 시스템에 따라 다릅니다. 이 섹션에서는 Erlang / OTP에서의 컴파일 및 코드 로딩에 대해 문서의 관련 부분을 참조하여 설명합니다.</target>
        </trans-unit>
        <trans-unit id="15c87cc7450111c7682bfcb2fe07b8147a9660ab" translate="yes" xml:space="preserve">
          <source>How long Erlang needs to be inactive before output is preceded with a time stamp. Defaults to &lt;code&gt;RUN_ERL_LOG_ALIVE_MINUTES div 3&lt;/code&gt;, minimum is 1.</source>
          <target state="translated">출력에 타임 스탬프가 표시되기 전에 Erlang을 비활성화해야하는 시간. 기본값은 &lt;code&gt;RUN_ERL_LOG_ALIVE_MINUTES div 3&lt;/code&gt; 이며 최소값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="f7148ef82d3951a0ef8aeff5732b56bd65e5d5a7" translate="yes" xml:space="preserve">
          <source>How long to wait for output (in minutes) before writing an &quot;ALIVE&quot; message to the log. Defaults to 15, minimum is 1.</source>
          <target state="translated">&quot;ALIVE&quot;메시지를 로그에 기록하기 전에 출력을 기다리는 시간 (분). 기본값은 15이며 최소값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="1a8eccc781fb3d6e08ed9cc46cafd132607b31bb" translate="yes" xml:space="preserve">
          <source>How many bytes that are read (received) from the socket, used in similar ways as &lt;code&gt;sent&lt;/code&gt;.</source>
          <target state="translated">소켓에서 읽거나받은 바이트 수는 &lt;code&gt;sent&lt;/code&gt; 와 비슷한 방식으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2063d1711356aa5cf80622e43bafe411dc016ccf" translate="yes" xml:space="preserve">
          <source>How many bytes that have been sent over the socket. This can wrap, but that is no problem for the distribution, as the Erlang distribution is only interested in if this value has changed. (The Erlang &lt;code&gt;net_kernel&lt;/code&gt;&lt;code&gt;ticker&lt;/code&gt; uses this value by calling the driver to fetch it, which is done through the &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt; routine.)</source>
          <target state="translated">소켓을 통해 전송 된 바이트 수입니다. 이것은 래핑 될 수 있지만, Erlang 배포는이 값이 변경된 경우에만 관심이 있기 때문에 배포에는 문제가되지 않습니다. (Erlang &lt;code&gt;net_kernel&lt;/code&gt; &lt;code&gt;ticker&lt;/code&gt; 는 드라이버를 호출하여 가져 오는 방식으로이 값을 사용합니다. 이는 &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 루틴을 통해 수행됩니다 .)</target>
        </trans-unit>
        <trans-unit id="29f341bd6607eedd11420fecb92a331dcfda1889" translate="yes" xml:space="preserve">
          <source>How many bytes that have been sent over the socket. This can wrap, but that is no problem for the distribution, as the Erlang distribution is only interested in if this value has changed. (The Erlang &lt;code&gt;net_kernel&lt;/code&gt;&lt;code&gt;ticker&lt;/code&gt; uses this value by calling the driver to fetch it, which is done through the &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; routine.)</source>
          <target state="translated">소켓을 통해 전송 된 바이트 수 이것은 랩핑 할 수 있지만 Erlang 분포는이 값이 변경된 경우에만 관심이 있으므로 분포에는 문제가되지 않습니다. (Erlang &lt;code&gt;net_kernel&lt;/code&gt; &lt;code&gt;ticker&lt;/code&gt; 는 드라이버를 호출하여이 값을 사용하여 가져옵니다. &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 루틴을 통해 수행됩니다 .)</target>
        </trans-unit>
        <trans-unit id="7f7085d139029fad5626d71df4a69c37165c0004" translate="yes" xml:space="preserve">
          <source>How schedulers are bound matters. For example, in situations when there are fewer running processes than schedulers online, the runtime system tries to migrate processes to schedulers with low scheduler identifiers. The more the schedulers are spread over the hardware, the more resources are available to the runtime system in such situations.</source>
          <target state="translated">스케줄러가 바운드되는 방식 예를 들어, 온라인으로 스케줄러보다 실행중인 프로세스 수가 적은 상황에서 런타임 시스템은 프로세스를 스케줄러 ID가 낮은 스케줄러로 마이그레이션하려고합니다. 스케줄러가 하드웨어에 더 많이 퍼질수록 그러한 상황에서 런타임 시스템에 더 많은 자원을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22fb0d06b90905c411643c4b8d63177262432872" translate="yes" xml:space="preserve">
          <source>How the different levels of configuration &quot;interfer&quot; with this, see the section &lt;code&gt;&lt;a href=&quot;configurations#algorithm-configuration&quot;&gt;Algorithm Configuration&lt;/a&gt;&lt;/code&gt; in the chapter &lt;code&gt;&lt;a href=&quot;configurations&quot;&gt;Configuration in SSH&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다양한 수준의 구성이이를 &quot;간섭&quot;하는 방법 &lt;code&gt;&lt;a href=&quot;configurations&quot;&gt;Configuration in SSH&lt;/a&gt;&lt;/code&gt; 장에서 &lt;code&gt;&lt;a href=&quot;configurations#algorithm-configuration&quot;&gt;Algorithm Configuration&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="20136af8c4b0c2e0978139eaccb368f03d6d08f3" translate="yes" xml:space="preserve">
          <source>How to Build a Debug Enabled Erlang RunTime System</source>
          <target state="translated">디버그 가능 Erlang 런타임 시스템을 빌드하는 방법</target>
        </trans-unit>
        <trans-unit id="d0e7345d074a8ac083420a87f267a9efe5441d6f" translate="yes" xml:space="preserve">
          <source>How to Work with the New API</source>
          <target state="translated">새 API로 작업하는 방법</target>
        </trans-unit>
        <trans-unit id="1c9e65c5426cc2af60f611bbcd0bef6a2d2545ba" translate="yes" xml:space="preserve">
          <source>How to communicate with the outside world and software written in other languages (ports); this is described in &lt;code&gt; Interoperability Tutorial&lt;/code&gt;.</source>
          <target state="translated">외부 세계 및 다른 언어 (포트)로 작성된 소프트웨어와 통신하는 방법 이것은 &lt;code&gt; Interoperability Tutorial&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4c1dadaae2a29663af54cb6cd0c08758049e535" translate="yes" xml:space="preserve">
          <source>How to communicate with the outside world and software written in other languages (ports); this is described in &lt;code&gt;Interoperability Tutorial&lt;/code&gt;.</source>
          <target state="translated">외부 세계와 통신하는 방법 및 다른 언어로 작성된 소프트웨어 (포트) 이 내용은 &lt;code&gt;Interoperability Tutorial&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5c10a361408710884679a3441fc66b438898423" translate="yes" xml:space="preserve">
          <source>How to deal with errors in the Message Length field of the Diameter Header in an incoming message. An error in this context is that the length is not at least 20 bytes (the length of a Header), is not a multiple of 4 (a valid length) or is not the length of the message in question, as received over the transport interface documented in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">수신 메시지에서 직경 헤더의 메시지 길이 필드에서 오류를 처리하는 방법 이 컨텍스트에서 오류는 전송을 통해 수신 된 길이가 20 바이트 이상 (헤더 길이) 이상, 4의 배수 (유효한 길이) 또는 해당 메시지의 길이가 아니라는 것입니다. 인터페이스는 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccbdf00e07b9b9e2844d8c343abd36e9a64cbb60" translate="yes" xml:space="preserve">
          <source>How to install a release in a target environment is described in the section about target systems in Section 2 System Principles.</source>
          <target state="translated">대상 환경에 릴리스를 설치하는 방법은 섹션 2 시스템 원칙의 대상 시스템에 대한 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8aa9d6c524adcbf7e604a1f12ced88b214a5951" translate="yes" xml:space="preserve">
          <source>How to program applications is described in &lt;code&gt;&lt;a href=&quot;applications&quot;&gt;Applications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">어떻게 프로그램 응용 프로그램에 설명되어 &lt;code&gt;&lt;a href=&quot;applications&quot;&gt;Applications&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="276dc4ca7f730347d6af07741689ad055269eecd" translate="yes" xml:space="preserve">
          <source>How to program releases is described in &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">어떻게 프로그램 릴리스에 설명되어있다 &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b4b3d991be0d0efdd7895d65ece3d2af255f1d4" translate="yes" xml:space="preserve">
          <source>How to send a trap by sending the &lt;code&gt;fTrap&lt;/code&gt; from the master agent is shown in this section. The master agent has the MIB &lt;code&gt;EX1-MIB&lt;/code&gt; loaded, where the trap is defined. This trap specifies that two variables should be sent along with the trap, &lt;code&gt;myName&lt;/code&gt; and &lt;code&gt;fIndex&lt;/code&gt;. &lt;code&gt;fIndex&lt;/code&gt; is a table column, so we must provide its value and the index for the row in the call to &lt;code&gt;snmpa:send_trap/4&lt;/code&gt;. In the example below, we assume that the row in question is indexed by 2 (the row with &lt;code&gt;fIndex&lt;/code&gt; 2).</source>
          <target state="translated">이 섹션에는 마스터 에이전트에서 &lt;code&gt;fTrap&lt;/code&gt; 을 전송하여 트랩을 보내는 방법 이 나와 있습니다. 마스터 에이전트에는 트랩이 정의 된 MIB &lt;code&gt;EX1-MIB&lt;/code&gt; 가로 드되어 있습니다. 이 트랩은 &lt;code&gt;myName&lt;/code&gt; 및 &lt;code&gt;fIndex&lt;/code&gt; 트랩과 함께 두 변수를 보내도록 지정합니다 . &lt;code&gt;fIndex&lt;/code&gt; 는 테이블 열이므로 &lt;code&gt;snmpa:send_trap/4&lt;/code&gt; 호출에서 행의 값과 색인을 제공해야합니다 . 아래 예에서는 문제의 행이 2 ( &lt;code&gt;fIndex&lt;/code&gt; 2 인 행)로 색인화되었다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="cd51a27fca892f8fff8444cd28b8146e7bbe5364" translate="yes" xml:space="preserve">
          <source>How to start and stop the code for the application, that is, the supervision tree, is described by two callback functions:</source>
          <target state="translated">애플리케이션의 코드, 즉 감독 트리를 시작 및 중지하는 방법은 다음 두 가지 콜백 함수로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="41bdc386e84c42a60e9c78fd7063eb79494fd670" translate="yes" xml:space="preserve">
          <source>How to write &lt;code&gt;d&lt;/code&gt; programs or &lt;code&gt;systemtap&lt;/code&gt; scripts can be learned from books and from a lot of pages on the Internet. This manual page does not include any documentation about using the dynamic trace tools of respective platform. The &lt;code&gt;examples&lt;/code&gt; directory of the &lt;code&gt;runtime_tools&lt;/code&gt; application however contains comprehensive examples of both &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;systemtap&lt;/code&gt; programs that will help you get started. Another source of information is the &lt;code&gt;&lt;a href=&quot;dtrace&quot;&gt;dtrace&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;systemtap&lt;/a&gt;&lt;/code&gt; chapters in the Runtime Tools Users' Guide.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 프로그램이나 &lt;code&gt;systemtap&lt;/code&gt; 스크립트 를 작성하는 방법 은 책과 인터넷의 많은 페이지에서 배울 수 있습니다. 이 매뉴얼 페이지에는 각 플랫폼의 동적 추적 도구 사용에 대한 설명서가 포함되어 있지 않습니다. 그러나 &lt;code&gt;runtime_tools&lt;/code&gt; 애플리케이션 의 &lt;code&gt;examples&lt;/code&gt; 디렉토리 에는 시작하는 데 도움이되는 &lt;code&gt;d&lt;/code&gt; 및 &lt;code&gt;systemtap&lt;/code&gt; 프로그램 의 포괄적 인 예제가 포함되어 있습니다 . 다른 정보 소스는 런타임 도구 사용자 안내서 의 &lt;code&gt;&lt;a href=&quot;dtrace&quot;&gt;dtrace&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;systemtap&lt;/a&gt;&lt;/code&gt; 장입니다.</target>
        </trans-unit>
        <trans-unit id="0838c6817793504aa13c17409bac1788b9b01886" translate="yes" xml:space="preserve">
          <source>However, NTP is not fail-safe. The NTP server can be unavailable, &lt;code&gt;ntp.conf&lt;/code&gt; can be wrongly configured, or your computer can sometimes be disconnected from Internet. Furthermore, you can have a user (or even system administrator) who thinks the correct way to handle Daylight Saving Time is to adjust the clock one hour two times a year (which is the incorrect way to do it). To complicate things further, this user fetched your software from Internet and has not considered what the correct time is as perceived by a computer. The user does not care about keeping the wall clock in sync with the correct time. The user expects your program to have unlimited knowledge about the time.</source>
          <target state="translated">그러나 NTP는 안전하지 않습니다. NTP 서버를 사용할 수 없거나 &lt;code&gt;ntp.conf&lt;/code&gt; 가 잘못 구성되었거나 컴퓨터와 인터넷 연결이 끊길 수 있습니다. 또한 일광 절약 시간을 처리하는 올바른 방법을 생각하는 사용자 (또는 시스템 관리자)에게 1 년에 두 번 1 시간 씩 시계를 조정하는 것 (잘못된 방법)이있을 수 있습니다. 더 복잡하게하기 위해이 사용자는 인터넷에서 소프트웨어를 가져 왔으며 컴퓨터에서 정확한 시간을 인식하지 못했습니다. 사용자는 벽시계를 정확한 시간과 동기화하는 데 신경 쓰지 않습니다. 사용자는 프로그램이 시간에 대해 무제한 지식을 갖기를 기대합니다.</target>
        </trans-unit>
        <trans-unit id="1d1ccf19c7bc531f33d5809c585dc1826e4637e4" translate="yes" xml:space="preserve">
          <source>However, a node started in this way refuses to talk to other nodes, as no TLS parameters are supplied (see the next section).</source>
          <target state="translated">그러나이 방법으로 시작된 노드는 TLS 매개 변수가 제공되지 않으므로 다른 노드와의 통신을 거부합니다 (다음 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="b227076a401b39e896ee55916a33ca73c07f48da" translate="yes" xml:space="preserve">
          <source>However, bit strings that are not whole bytes are not allowed, so a UTF character must be split along 8-bit boundaries to ever be decoded.</source>
          <target state="translated">그러나 전체 바이트가 아닌 비트 문자열은 허용되지 않으므로 UTF 문자를 8 비트 경계를 따라 분할하여 디코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="8ea8d93f3410c8633f2cc78f1bbe03d8844b4ed7" translate="yes" xml:space="preserve">
          <source>However, certificates can also be decoded using &lt;code&gt;pkix_decode_cert/2&lt;/code&gt;, which can customize and recursively decode standard parts of a certificate:</source>
          <target state="translated">그러나 &lt;code&gt;pkix_decode_cert/2&lt;/code&gt; 를 사용하여 인증서를 디코딩 할 수도 있습니다 .이 인증서는 인증서의 표준 부분을 사용자 정의하고 재귀 적으로 디코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c4ccce2e74bd8ac8ec245b1dfb747183f0ffc13" translate="yes" xml:space="preserve">
          <source>However, escaping other non-alphanumeric characters does no harm.</source>
          <target state="translated">그러나 영숫자가 아닌 다른 문자를 이스케이프 처리해도 아무런 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="46e5131246ec14a5499a18be55e9b7179d7c9b66" translate="yes" xml:space="preserve">
          <source>However, for a value of type &lt;code&gt;SET OF&lt;/code&gt;, the DER encoding format requires the elements to be sent in ascending order of their encoding, which implies an expensive sorting procedure in runtime. Therefore it is recommended to use &lt;code&gt;SEQUENCE OF&lt;/code&gt; instead of &lt;code&gt;SET OF&lt;/code&gt; if possible.</source>
          <target state="translated">그러나 &lt;code&gt;SET OF&lt;/code&gt; 유형의 값 의 경우, DER 인코딩 형식은 요소를 인코딩의 오름차순으로 전송해야하므로 런타임시 고가의 정렬 절차를 의미합니다. 따라서 가능하면 &lt;code&gt;SET OF&lt;/code&gt; 대신 &lt;code&gt;SEQUENCE OF&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="bc244468b711f7696ac604f858e8d4fc9b46e19b" translate="yes" xml:space="preserve">
          <source>However, here you will find some examples of how to use and to what you can use xmerl. A detailed description of the user interface can be found in the reference manual.</source>
          <target state="translated">그러나 여기에는 사용 방법과 xmerl 사용 방법에 대한 몇 가지 예가 있습니다. 사용자 인터페이스에 대한 자세한 설명은 참조 매뉴얼을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0b9d56ea76c3544f39f6889a33eb80d1c637ad55" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;cp1&lt;/code&gt; also restarts, the function &lt;code&gt;application:takeover/2&lt;/code&gt; moves &lt;code&gt;myapp&lt;/code&gt; to &lt;code&gt;cp1&lt;/code&gt;, as &lt;code&gt;cp1&lt;/code&gt; has a higher priority than &lt;code&gt;cp3&lt;/code&gt; for this application. In this case, &lt;code&gt;Module:start({takeover, cp3@cave}, StartArgs)&lt;/code&gt; is executed at &lt;code&gt;cp1&lt;/code&gt; to start the application.</source>
          <target state="translated">그러나, &lt;code&gt;cp1&lt;/code&gt; 또한 재시작 기능 &lt;code&gt;application:takeover/2&lt;/code&gt; 를 이동 &lt;code&gt;myapp&lt;/code&gt; 행 &lt;code&gt;cp1&lt;/code&gt; 같은 &lt;code&gt;cp1&lt;/code&gt; 보다 높은 우선 순위를 갖는다 &lt;code&gt;cp3&lt;/code&gt; 이 애플리케이션한다. 이 경우 응용 프로그램을 시작하기 위해 &lt;code&gt;Module:start({takeover, cp3@cave}, StartArgs)&lt;/code&gt; 가 &lt;code&gt;cp1&lt;/code&gt; 에서 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="d56d68a6f8912b74bb9d4335dc57800fe8ebb077" translate="yes" xml:space="preserve">
          <source>However, if a quantifier is followed by a question mark, it ceases to be greedy, and instead matches the minimum number of times possible, so the following pattern does the right thing with the C comments:</source>
          <target state="translated">그러나 수량 자 뒤에 물음표가 있으면 욕심이 멈추고 대신 가능한 최소 횟수와 일치하므로 다음 패턴이 C 주석과 함께 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="263a65ad8dda64685d084610e95a9d4761d42dff" translate="yes" xml:space="preserve">
          <source>However, if another process has the driver loaded, calling &lt;code&gt;reload_driver&lt;/code&gt; returns error code &lt;code&gt;pending_process&lt;/code&gt;. As stated earlier, the recommended design is to not allow other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; than the &quot;driver reloader&quot; to demand loading of the driver in question.</source>
          <target state="translated">그러나 다른 프로세스에 드라이버가로드 된 경우 &lt;code&gt;reload_driver&lt;/code&gt; 를 호출 하면 오류 코드 &lt;code&gt;pending_process&lt;/code&gt; 가 리턴 됩니다 . 앞에서 언급했듯이 권장 설계는 &quot;드라이버 리 로더&quot;이외의 다른 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가 해당 드라이버로드를 요구 하지 않도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fdd9ab210aada3daba577507d301fd6bfe3e97ab" translate="yes" xml:space="preserve">
          <source>However, if the decimal number following the backslash is &amp;lt; 10, it is always taken as a back reference, and causes an error only if there are not that many capturing left parentheses in the entire pattern. That is, the parentheses that are referenced do need not be to the left of the reference for numbers &amp;lt; 10. A &quot;forward back reference&quot; of this type can make sense when a repetition is involved and the subpattern to the right has participated in an earlier iteration.</source>
          <target state="translated">그러나 백 슬래시 다음의 10 진수가 &amp;lt;10이면 항상 역 참조로 간주되며 전체 패턴에 캡처 된 왼쪽 괄호가 많지 않은 경우에만 오류가 발생합니다. 즉, 참조되는 괄호는 숫자 &amp;lt;10에 대한 참조의 왼쪽에있을 필요는 없습니다.이 유형의 &quot;앞뒤 참조&quot;는 반복이 포함되고 오른쪽의 하위 패턴이 초기 반복.</target>
        </trans-unit>
        <trans-unit id="2a812868f08ecc593ae34f24cb42a6aa95624434" translate="yes" xml:space="preserve">
          <source>However, if the first pattern does not match, the second pattern is tested. If this matches, the message is removed from the queue and the actions corresponding to the second pattern are executed. If the second pattern does not match, the third is tried and so on until there are no more patterns to test. If there are no more patterns to test, the first message is kept in the queue and the second message is tried instead. If this matches any pattern, the appropriate actions are executed and the second message is removed from the queue (keeping the first message and any other messages in the queue). If the second message does not match, the third message is tried, and so on, until the end of the queue is reached. If the end of the queue is reached, the process blocks (stops execution) and waits until a new message is received and this procedure is repeated.</source>
          <target state="translated">그러나 첫 번째 패턴이 일치하지 않으면 두 번째 패턴이 테스트됩니다. 일치하면 메시지가 큐에서 제거되고 두 번째 패턴에 해당하는 조치가 실행됩니다. 두 번째 패턴이 일치하지 않으면 테스트 할 패턴이 더 이상 없을 때까지 세 번째 패턴이 시도됩니다. 테스트 할 패턴이 더 이상 없으면 첫 번째 메시지가 큐에 보관되고 두 번째 메시지가 대신 시도됩니다. 이 패턴과 일치하면 적절한 조치가 실행되고 두 번째 메시지가 큐에서 제거됩니다 (첫 번째 메시지와 다른 메시지는 큐에 유지). 두 번째 메시지가 일치하지 않으면 큐의 끝에 도달 할 때까지 세 번째 메시지가 시도됩니다. 큐의 끝에 도달하면프로세스는 실행을 차단 (실행 중지)하고 새 메시지가 수신되고이 절차가 반복 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="24786ae2162520de2c90e9e1d62681cc611c7770" translate="yes" xml:space="preserve">
          <source>However, if the input &lt;code&gt;Data&lt;/code&gt; is a pure binary, the third part of the error tuple is guaranteed to be a binary as well.</source>
          <target state="translated">그러나 입력 &lt;code&gt;Data&lt;/code&gt; 가 순수 이진이면 오류 튜플의 세 번째 부분도 이진이어야합니다.</target>
        </trans-unit>
        <trans-unit id="16d0a6fc945512ce80fc9d4797b016ad95bcce03" translate="yes" xml:space="preserve">
          <source>However, if the table is created with an explicit record name as argument, as shown in the following example, subscriber records can be stored in both of the tables regardless of the table names:</source>
          <target state="translated">그러나 다음 예제와 같이 테이블이 명시 적 레코드 이름으로 인수로 작성되면 테이블 이름에 관계없이 구독자 레코드를 두 테이블 모두에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b7421b4ed5e29d178756408b1fb811393c80202" translate="yes" xml:space="preserve">
          <source>However, if this is done and a &lt;code&gt;relup&lt;/code&gt; file is generated, not only would it contain instructions for restarting (that is, removing and adding) &lt;code&gt;prim_app&lt;/code&gt;, it would also contain instructions for starting &lt;code&gt;ch_app&lt;/code&gt; (and stopping it, in the case of downgrade). This is because &lt;code&gt;ch_app&lt;/code&gt; is included in the new &lt;code&gt;.rel&lt;/code&gt; file, but not in the old one.</source>
          <target state="translated">이 작업이 완료되고 경우, &lt;code&gt;relup&lt;/code&gt; 의 파일이 생성뿐만 아니라 그것은 (제거 및 추가하고있다) 다시 시작하기위한 지침 포함됩니다 &lt;code&gt;prim_app&lt;/code&gt; 를 , 그것도 시작하기위한 지침 포함됩니다 &lt;code&gt;ch_app&lt;/code&gt; 를 (다운 그레이드의 경우이를 중지를) . &lt;code&gt;ch_app&lt;/code&gt; 가 새 &lt;code&gt;.rel&lt;/code&gt; 파일 에는 포함되어 있지만 이전 파일 에는 포함되어 있지 않기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="88d142963f00e274bf0e73a5e3da8dd76b986238" translate="yes" xml:space="preserve">
          <source>However, if you invoke the &lt;code&gt;escript&lt;/code&gt; as follows, the contents of the first line do not matter, but it cannot contain Erlang code as it will be ignored:</source>
          <target state="translated">그러나 다음과 같이 &lt;code&gt;escript&lt;/code&gt; 를 호출하면 첫 번째 줄의 내용은 중요하지 않지만 무시되므로 Erlang 코드를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="671dba1e8a971cf15a413c5af3f46c832eef8168" translate="yes" xml:space="preserve">
          <source>However, if you invoke the &lt;code&gt;escript&lt;/code&gt; as follows, the contents of the first line does not matter, but it cannot contain Erlang code as it will be ignored:</source>
          <target state="translated">그러나 다음과 같이 &lt;code&gt;escript&lt;/code&gt; 를 호출하면 첫 번째 행의 내용은 중요하지 않지만 무시되는 Erlang 코드는 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7c6cbfad60b53ec8d8298796a95d996bcb875534" translate="yes" xml:space="preserve">
          <source>However, if you just want to change it for the current session you can also do that.</source>
          <target state="translated">그러나 현재 세션에 대해 변경하려는 경우에도 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="733932a016243e1521c912130b4ad01ef9fa9412" translate="yes" xml:space="preserve">
          <source>However, it can also be convenient to replace variables in within a &lt;code&gt;sys.config&lt;/code&gt; on the target after unpacking but before running the release. If you have a &lt;code&gt;sys.config.src&lt;/code&gt; it will be included and is not required to be a valid Erlang term file like &lt;code&gt;sys.config&lt;/code&gt;. Before running the release you must have a valid &lt;code&gt;sys.config&lt;/code&gt; in the same directory, so using &lt;code&gt;sys.config.src&lt;/code&gt; requires having some tool to populate what is needed and write &lt;code&gt;sys.config&lt;/code&gt; to disk before booting the release.</source>
          <target state="translated">그러나 압축을 푼 후 릴리스를 실행하기 전에 대상 의 &lt;code&gt;sys.config&lt;/code&gt; 내에서 변수를 바꾸는 것이 편리 할 수도 있습니다 . 당신이있는 경우 &lt;code&gt;sys.config.src&lt;/code&gt; 을 가 포함됩니다와 같은 유효한 얼랑 용어 파일이 될 필요는 없습니다 &lt;code&gt;sys.config&lt;/code&gt; . 릴리스를 실행하기 전에 동일한 디렉토리에 유효한 &lt;code&gt;sys.config&lt;/code&gt; 가 있어야 하므로 &lt;code&gt;sys.config.src&lt;/code&gt; 를 사용 하려면 릴리스를 부팅하기 전에 필요한 것을 채우고 &lt;code&gt;sys.config&lt;/code&gt; 를 디스크에 쓸 수있는 도구가 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="e2548bff9e540af4d0fb0d83f010b390353ac3c3" translate="yes" xml:space="preserve">
          <source>However, it is acceptable to PCRE if rewritten to use two top-level branches:</source>
          <target state="translated">그러나 두 개의 최상위 분기를 사용하도록 다시 작성된 경우 PCRE를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb5d7ab90418502bf4a66c357b3062b87e79e461" translate="yes" xml:space="preserve">
          <source>However, it is up to the tools that process the specifications to choose whether to take this extra information into account or not.</source>
          <target state="translated">그러나이 추가 정보를 고려할지 여부를 선택하는 것은 사양을 처리하는 도구에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfce5f1fc516ae2dd7d55f261e0b8f21a3259164" translate="yes" xml:space="preserve">
          <source>However, more dot-separated parts than this can exist. The dot-separated parts consist of non-negative integers. If all parts less significant than &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; equals &lt;code&gt;0&lt;/code&gt;, they are omitted. The three normal parts &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; are changed as follows:</source>
          <target state="translated">그러나 이보다 점으로 구분 된 부분이 더 존재할 수 있습니다. 점으로 구분 된 부분은 음이 아닌 정수로 구성됩니다. &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; 보다 덜 중요한 모든 부분 이 &lt;code&gt;0&lt;/code&gt; 이면 생략됩니다. 세 가지 일반 부품 &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; 는 다음과 같이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="7df44a8a1e1ba914a7e56b28dc0791a84d52cf6e" translate="yes" xml:space="preserve">
          <source>However, no expansion is done in the following call because &lt;code&gt;{foo, false}&lt;/code&gt; shadows &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">그러나 &lt;code&gt;{foo, false}&lt;/code&gt; shadows &lt;code&gt;foo&lt;/code&gt; 때문에 다음 호출에서 확장이 수행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8d572d552eed7e268241fcd56330d5bd074e5ab5" translate="yes" xml:space="preserve">
          <source>However, notice that there is a risk that the database can be left in an inconsistent state if dirty operations are used to update it. Dirty operations are only to be used for performance reasons when it is absolutely necessary.</source>
          <target state="translated">그러나 더티 작업을 사용하여 데이터베이스를 업데이트하는 경우 데이터베이스가 일관성이없는 상태로 유지 될 위험이 있습니다. 더티 오퍼레이션은 반드시 필요한 성능상의 이유로 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a529ad494df4a251bbb90b6a1eb0a32b4600b075" translate="yes" xml:space="preserve">
          <source>However, that simple behaviour can be modified in numerous ways. For example, the Net if process can apply some kind of encrypting/decrypting scheme on the bytes or act as a proxy filter, which sends some packets to a proxy agent and some packets to the master agent.</source>
          <target state="translated">그러나 간단한 동작은 여러 가지 방법으로 수정할 수 있습니다. 예를 들어, Net if 프로세스는 바이트에 일종의 암호화 / 암호 해독 체계를 적용하거나 프록시 필터로 작동하여 일부 패킷을 프록시 에이전트로 보내고 일부 패킷을 마스터 에이전트로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="d14e5363806cde8cb157cc5a01dc9d77816a23da" translate="yes" xml:space="preserve">
          <source>However, that simple behaviour can be modified in numerous ways. For example, the Net if process can apply some kind of encrypting/decrypting scheme on the bytes.</source>
          <target state="translated">그러나 간단한 동작은 여러 가지 방법으로 수정할 수 있습니다. 예를 들어, Net if 프로세스는 바이트에 일종의 암호화 / 암호 해독 체계를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb8e8fcb075fb17e39be5eb5b27fd3315e7094ac" translate="yes" xml:space="preserve">
          <source>However, there are some cases where the optimization cannot be used. When .* is inside capturing parentheses that are the subject of a back reference elsewhere in the pattern, a match at the start can fail where a later one succeeds. Consider, for example:</source>
          <target state="translated">그러나 최적화를 사용할 수없는 경우가 있습니다. . *가 패턴의 다른 곳에서 역 참조의 주제 인 캡처 괄호 안에 있으면 시작시 일치가 실패 할 수 있습니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="fa09d853f290abccb9c6e1093393c3c7791a824e" translate="yes" xml:space="preserve">
          <source>However, there is an exception. Within a macro definition, a line that starts with whitespace followed by &lt;code&gt;//|&lt;/code&gt; is treated specially. The rest of the line is assumed to contain directives to control code generation.</source>
          <target state="translated">그러나 예외가 있습니다. 매크로 정의 내에서 공백으로 시작하는 줄과 &lt;code&gt;//|&lt;/code&gt; 특별히 취급됩니다. 나머지 줄에는 코드 생성을 제어하는 ​​지시문이 포함되어 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c4528e70959d30b530219f34dfc215c6d0cefc18" translate="yes" xml:space="preserve">
          <source>However, this feature of delaying thread progress from unmanaged threads should preferably be used as little as possible, since heavy use of it will cause contention on the reference counter cache lines. The functionality is however very useful in code which normally only executes in managed threads, but which may under some infrequent circumstances be executed in other threads.</source>
          <target state="translated">그러나 관리되지 않는 스레드에서 스레드 진행을 지연시키는이 기능은 가능한 한 적게 사용하는 것이 좋습니다. 그 기능을 많이 사용하면 참조 카운터 캐시 라인에서 경합이 발생하기 때문입니다. 그러나이 기능은 일반적으로 관리되는 스레드에서만 실행되지만 드물게 다른 스레드에서 실행될 수있는 코드에서는 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="eb1d42158bbcefd3e41b94056683aaeb566a73aa" translate="yes" xml:space="preserve">
          <source>However, this procedure can be time-consuming, the shortcut function &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; loads all the tables from disc at a faster rate. The function forces tables to be loaded from disc regardless of the network situation.</source>
          <target state="translated">그러나이 절차는 시간이 오래 걸릴 수 있습니다. 바로 가기 기능 &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; 은 디스크에서 모든 테이블을 더 빠른 속도로로드합니다. 이 기능은 네트워크 상황에 관계없이 디스크에서 테이블을 강제로로드합니다.</target>
        </trans-unit>
        <trans-unit id="7ec657f07edbe2adca75ca4efe20bdbbe6a76973" translate="yes" xml:space="preserve">
          <source>However, to avoid that old (pre R14) code changed its behavior when compiled with OTP version R14A or later, the following restriction applies: If you override the name of a BIF that was auto-imported in OTP versions prior to R14A (ERTS version 5.8) and have an implicitly qualified call to that function in your code, you either need to explicitly remove the auto-import using a compiler directive, or replace the call with a fully qualified function call. Otherwise you get a compilation error. See the following example:</source>
          <target state="translated">그러나 이전 (R14 이전) 코드가 OTP 버전 R14A 이상으로 컴파일 될 때 동작이 변경되지 않도록하기 위해 다음 제한 사항이 적용됩니다. R14A 이전의 OTP 버전 (ERTS 버전)에서 자동으로 가져온 BIF의 이름을 대체하는 경우 5.8) 코드에서 해당 함수를 암시 적으로 정규 호출하면 컴파일러 지시문을 사용하여 자동 가져 오기를 명시 적으로 제거하거나 해당 함수를 정규 함수 호출로 바꿔야합니다. 그렇지 않으면 컴파일 오류가 발생합니다. 다음 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0d770aae36addee1e6eb41cd37aaf79237dbd85a" translate="yes" xml:space="preserve">
          <source>However, what reservation of physical memory actually means highly depends on the operating system, and how it is configured. For example, different memory overcommit settings on Linux drastically change the behaviour.</source>
          <target state="translated">그러나 실제 메모리 예약이 실제로 의미하는 바는 운영 체제와 구성 방법에 따라 다릅니다. 예를 들어 Linux의 다른 메모리 오버 커밋 설정은 동작을 크게 변경합니다.</target>
        </trans-unit>
        <trans-unit id="75b9c43d3cdd19de7c3638848d794e6192e00af7" translate="yes" xml:space="preserve">
          <source>However, when using, for example, IA5String (which closely resembles ASCII), byte 65 (in decimal notation) &lt;strong&gt;means&lt;/strong&gt; character 'A'.</source>
          <target state="translated">그러나 예를 들어 IA5String (ASCII와 매우 유사한)을 사용할 때 바이트 65 (10 진수 표기법) &lt;strong&gt;는&lt;/strong&gt; 문자 'A'를 &lt;strong&gt;의미&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8f5f28cc9ea54e0ce758adaa70edd19d2c7df7a4" translate="yes" xml:space="preserve">
          <source>Http client service start/stop</source>
          <target state="translated">HTTP 클라이언트 서비스 시작 / 중지</target>
        </trans-unit>
        <trans-unit id="2a4e8cc587ce6e7e113504c978e34c1e185e42f2" translate="yes" xml:space="preserve">
          <source>Http data types</source>
          <target state="translated">Http 데이터 형식</target>
        </trans-unit>
        <trans-unit id="421eac8e9d0f0d4fccaca857739a0c79fd890424" translate="yes" xml:space="preserve">
          <source>Hyphen (only where it can be interpreted as specifying a range)</source>
          <target state="translated">하이픈 (범위를 지정하는 것으로 해석 될 수있는 경우에만)</target>
        </trans-unit>
        <trans-unit id="df1da1414681b4aaf7b9dd8c935cd29628d37ea7" translate="yes" xml:space="preserve">
          <source>Hyphens are allowed in SMIv2 (a pragmatic approach). The reason for this is that according to SMIv2, hyphens are allowed for objects converted from SMIv1, but not for others. This is impossible to check for the compiler.</source>
          <target state="translated">하이픈은 SMIv2 (실용적인 접근 방식)에서 허용됩니다. 그 이유는 SMIv2에 따르면 SMIv1에서 변환 된 객체에는 하이픈이 허용되지만 다른 것에는 하이픈이 허용되지 않기 때문입니다. 컴파일러를 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c5bc42a4cab12cb2ea8fc597fa696281af9382e3" translate="yes" xml:space="preserve">
          <source>I will only present the most important functions in the API here.</source>
          <target state="translated">여기서는 API에서 가장 중요한 기능 만 소개하겠습니다.</target>
        </trans-unit>
        <trans-unit id="317126fec2c76144e4651e497f8a410a786df087" translate="yes" xml:space="preserve">
          <source>I/O error.</source>
          <target state="translated">I / O 오류</target>
        </trans-unit>
        <trans-unit id="629b47de797063a0b6b561c862c608954c3da6aa" translate="yes" xml:space="preserve">
          <source>I/O from a function called in an Erlang ssh daemon</source>
          <target state="translated">Erlang ssh 데몬에서 호출 된 함수의 I / O</target>
        </trans-unit>
        <trans-unit id="7e0868350648287b8190bf9c980b2ea9c46ef7d5" translate="yes" xml:space="preserve">
          <source>I/O is by far the most problematic area for Unicode. A file is an entity where bytes are stored, and the lore of programming has been to treat characters and bytes as interchangeable. With Unicode characters, you must decide on an encoding when you want to store the data in a file. In Erlang, you can open a text file with an encoding option, so that you can read characters from it rather than bytes, but you can also open a file for bytewise I/O.</source>
          <target state="translated">I / O는 유니 코드에서 가장 문제가되는 영역입니다. 파일은 바이트가 저장되는 엔터티이며 프로그래밍은 문자와 바이트를 상호 교환 가능한 것으로 취급해야합니다. 유니 코드 문자를 사용하면 파일에 데이터를 저장하려는 경우 인코딩을 결정해야합니다. Erlang에서는 인코딩 옵션을 사용하여 텍스트 파일을 열어서 바이트가 아닌 문자를 읽을 수 있지만 바이트 단위 I / O를 위해 파일을 열 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fb1f4a96f553bd9d56bd14c304eff4f10d68c9d" translate="yes" xml:space="preserve">
          <source>I/O library functions.</source>
          <target state="translated">I / O 라이브러리 기능.</target>
        </trans-unit>
        <trans-unit id="e689b6630f1d0a364819fdd2b5731bcddd521358" translate="yes" xml:space="preserve">
          <source>I/O servers behave a little differently. The I/O servers connected to terminals (or &lt;code&gt;stdout&lt;/code&gt;) can usually cope with Unicode data regardless of the encoding option. This is convenient when one expects a modern environment but do not want to crash when writing to an archaic terminal or pipe.</source>
          <target state="translated">I / O 서버는 약간 다르게 동작합니다. 터미널 (또는 &lt;code&gt;stdout&lt;/code&gt; )에 연결된 I / O 서버 는 일반적으로 인코딩 옵션에 관계없이 유니 코드 데이터를 처리 할 수 ​​있습니다. 이것은 현대적인 환경을 기대하지만 구식 터미널이나 파이프에 쓸 때 충돌하지 않으려는 경우에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="2b536593017ca7fbb86fdac576736ff840ff5f41" translate="yes" xml:space="preserve">
          <source>I/O signals may however be aborted. This could be solved by letting the port specific scheduling lock also protect the private task data structure, but then the port very frequently would have to fight with others enqueueing new tasks. In order to handle this while keeping the private task data structure lock free, we use a similar &quot;non aggressive&quot; approach as we use when handling processes that gets suspended while in the run queue. Instead of removing the aborted port task, we just mark it as aborted using an atomic memory operation. When a task is selected for execution, we first verify that it has not been aborted. If aborted we, just drop the task.</source>
          <target state="translated">그러나 I / O 신호는 중단 될 수 있습니다. 이는 포트 별 스케줄링 잠금이 개인 작업 데이터 구조를 보호하도록함으로써 해결할 수 있지만, 포트는 새로운 작업을 대기열에 추가하는 다른 사람들과 매우 자주 싸워야합니다. 개인 작업 데이터 구조 잠금을 해제하면서이를 처리하기 위해 실행 대기열에있는 동안 일시 중단되는 프로세스를 처리 할 때 사용하는 것과 유사한 &quot;비 공격적&quot;접근 방식을 사용합니다. 중단 된 포트 작업을 제거하는 대신 원자 메모리 작업을 사용하여 중단 된 것으로 표시합니다. 실행할 작업을 선택하면 먼저 작업이 중단되지 않았는지 확인합니다. 우리가 중단 되었다면 그냥 그 일을 버리십시오.</target>
        </trans-unit>
        <trans-unit id="8fc86a2ee6eb5947817dfe748e38a27770d8f566" translate="yes" xml:space="preserve">
          <source>I/O-servers throughout the system can handle Unicode data and have options for converting data upon output or input to/from the device. As shown earlier, the &lt;code&gt;shell&lt;/code&gt; module has support for Unicode terminals and the &lt;code&gt;file&lt;/code&gt; module allows for translation to and from various Unicode formats on disk.</source>
          <target state="translated">시스템 전체의 I / O 서버는 유니 코드 데이터를 처리 할 수 ​​있으며 장치에 대한 출력 또는 입력시 데이터를 변환하는 옵션이 있습니다. 앞에서 설명한 것처럼 &lt;code&gt;shell&lt;/code&gt; 모듈은 유니 코드 터미널을 지원하며 &lt;code&gt;file&lt;/code&gt; 모듈은 디스크의 다양한 유니 코드 형식과의 변환을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="bcfd9b9aeb407171a7e2324b4088b3abd516b2fd" translate="yes" xml:space="preserve">
          <source>IANA Considerations</source>
          <target state="translated">IANA 고려 사항</target>
        </trans-unit>
        <trans-unit id="3e38df6d2fac16695ca12a7c20a2020653e3dafb" translate="yes" xml:space="preserve">
          <source>IC (Erlang IDL Compiler) is an interface generator that, given an IDL interface specification, automatically generates stub code in Erlang, C, or Java. See the IC User's Guide and IC Reference Manual.</source>
          <target state="translated">IC (Erlang IDL Compiler)는 IDL 인터페이스 사양이 지정된 경우 Erlang, C 또는 Java로 스텁 코드를 자동으로 생성하는 인터페이스 생성기입니다. IC 사용 설명서 및 IC 참조 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0bf03f10d1813cb5d0b794bb41322a916930011c" translate="yes" xml:space="preserve">
          <source>IC file. It runs the IDL compiler.</source>
          <target state="translated">IC 파일. IDL 컴파일러를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="881271d3bb93e752931432a69d275e6c5c697b27" translate="yes" xml:space="preserve">
          <source>IDEA cipher suites are not supported as they have become deprecated by the TLS 1.2 specification so it is not motivated to implement them.</source>
          <target state="translated">IDEA 암호화 제품군은 TLS 1.2 사양에서 더 이상 사용되지 않으므로 지원되지 않으므로 구현할 동기가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c51d7c7db41d3c06e8b204e1bc79bfc7925a9210" translate="yes" xml:space="preserve">
          <source>IETF - which calls the protocol Megaco</source>
          <target state="translated">IETF-프로토콜 Megaco를 호출</target>
        </trans-unit>
        <trans-unit id="7d26936a60ddb99baf38e0efb1e3118fc3bedbec" translate="yes" xml:space="preserve">
          <source>IG (Interface Generator) automatically generated code for port or socket communication between an Erlang program and a C program, given a C header file with certain keywords.</source>
          <target state="translated">IG (Interface Generator)는 특정 키워드가있는 C 헤더 파일이있는 경우 Erlang 프로그램과 C 프로그램 간의 포트 또는 소켓 통신을위한 코드를 자동으로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="02cd32b9b05d3968d24a31f2968a004c733872e9" translate="yes" xml:space="preserve">
          <source>IG - Removed from Erlang/OTP R6B.</source>
          <target state="translated">IG-Erlang / OTP R6B에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="67d2109a8b5d8e4bb7b9df8f8ac917b156dee2f0" translate="yes" xml:space="preserve">
          <source>IIOP (CORBA)</source>
          <target state="translated">IIOP (코르 바)</target>
        </trans-unit>
        <trans-unit id="e11de130ad140b3de05ef1e6704f79955721f5c1" translate="yes" xml:space="preserve">
          <source>INTEGER, INT, SMALLINT</source>
          <target state="translated">정수, INT, SMALLINT</target>
        </trans-unit>
        <trans-unit id="46a2b346d175bbcf022a9a889eb0d86d5bfeb44a" translate="yes" xml:space="preserve">
          <source>IOString</source>
          <target state="translated">IOString</target>
        </trans-unit>
        <trans-unit id="d191822111684cb0a3235f7ff4be7401211b5c9d" translate="yes" xml:space="preserve">
          <source>IP address, &lt;code&gt;addr&lt;/code&gt;</source>
          <target state="translated">IP 주소, &lt;code&gt;addr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c4e4f4977f53cb13c9e71db88ccd9dabd0d8c68" translate="yes" xml:space="preserve">
          <source>IP v4 address and nodename.</source>
          <target state="translated">IP v4 주소 및 노드 이름.</target>
        </trans-unit>
        <trans-unit id="a762fd412e63e6cdda70621754e625a105c877a8" translate="yes" xml:space="preserve">
          <source>IP v4 address.</source>
          <target state="translated">IP v4 주소.</target>
        </trans-unit>
        <trans-unit id="5b376f791ddb908dfa5eec43b3c5893ba79b006b" translate="yes" xml:space="preserve">
          <source>IP version to use when the host address is specified as &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">호스트 주소가 &lt;code&gt;any&lt;/code&gt; 로 지정 될 때 사용할 IP 버전 .</target>
        </trans-unit>
        <trans-unit id="96a0cbf4fd8e6bbadf81a2623591ae93a5fab7c6" translate="yes" xml:space="preserve">
          <source>IPsec is transparent to diameter.</source>
          <target state="translated">IPsec은 직경에 투명합니다.</target>
        </trans-unit>
        <trans-unit id="18ab43ebeda307979a5cae1e044580f0b576b6b9" translate="yes" xml:space="preserve">
          <source>ISO Latin-1 (0-255, one character per byte). Here, case parameter &lt;code&gt;InEncoding&lt;/code&gt; is to be specified as &lt;code&gt;latin1&lt;/code&gt;.</source>
          <target state="translated">ISO Latin-1 (0-255, 바이트 당 하나의 문자). 여기에서 케이스 매개 변수 &lt;code&gt;InEncoding&lt;/code&gt; 은 &lt;code&gt;latin1&lt;/code&gt; 으로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d5e544629e4d17007bac72590a9cae9dd3b4b775" translate="yes" xml:space="preserve">
          <source>ITU - which calls the protocol H.248</source>
          <target state="translated">ITU-프로토콜 H.248을 호출</target>
        </trans-unit>
        <trans-unit id="c633b237421559cb6821152c0d77a40227baef6f" translate="yes" xml:space="preserve">
          <source>Id of the &lt;code&gt;ssh&lt;/code&gt; channel as returned by &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/2,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/2,4&lt;/a&gt;&lt;/code&gt; 에서 반환 한 &lt;code&gt;ssh&lt;/code&gt; 채널의 ID입니다 .</target>
        </trans-unit>
        <trans-unit id="eee9bf2e79695b73d87e005e3af0acf3c8bf8e02" translate="yes" xml:space="preserve">
          <source>Ideally, your code only contains the first type of efficient code. If that turns out to be too slow, profile the application to find out where the performance bottlenecks are and optimize only the bottlenecks. Let other code stay as clean as possible.</source>
          <target state="translated">이상적으로 코드에는 첫 번째 유형의 효율적인 코드 만 포함됩니다. 속도가 너무 느리면 응용 프로그램을 프로파일 링하여 성능 병목 현상의 위치를 ​​찾고 병목 현상 만 최적화하십시오. 다른 코드는 최대한 깨끗하게 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="c30e59972c073691c1e830409d7104410fccdf7c" translate="yes" xml:space="preserve">
          <source>Identified processor states may be different on different operating systems and may change between different versions of &lt;code&gt;cpu_sup&lt;/code&gt; on the same operating system. The sum of the percentage shares of the CPU cycles spent in all busy and all non-busy processor states will always add up to 100%, though.</source>
          <target state="translated">식별 된 프로세서 상태는 운영 체제마다 다를 수 있으며 동일한 운영 체제에서 서로 다른 &lt;code&gt;cpu_sup&lt;/code&gt; 버전간에 변경 될 수 있습니다 . 그러나 모든 사용 중 및 모든 비 사용 중 프로세서 상태에서 소비 된 CPU 사이클의 백분율 공유의 합계는 항상 최대 100 %가됩니다.</target>
        </trans-unit>
        <trans-unit id="b46580854e82988aa9e6377bc948b9ced562fe4b" translate="yes" xml:space="preserve">
          <source>Identifiers.</source>
          <target state="translated">Identifiers.</target>
        </trans-unit>
        <trans-unit id="c4b828ddf628f41cc4d390c6deaa0302ac12c3dd" translate="yes" xml:space="preserve">
          <source>Identifies a TLS session.</source>
          <target state="translated">TLS 세션을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="75bb32d0a7ac84997a35ee28f73ca250b15a818d" translate="yes" xml:space="preserve">
          <source>Identifies a counter array returned from &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt; 에서 반환 된 카운터 배열을 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="99d9be73f1ae427426eb7dad6ec17364635870b5" translate="yes" xml:space="preserve">
          <source>Identifies an atomic array returned from &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt; 에서 반환 된 원자 배열을 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="cc1aea5ef7b08c4fe2e094b55f89ec9a27cc6266" translate="yes" xml:space="preserve">
          <source>Identifies and returns the type of Erlang term encoded in a buffer. It skips a trailing &lt;strong&gt;magic&lt;/strong&gt; identifier.</source>
          <target state="translated">버퍼로 인코딩 된 Erlang 용어의 유형을 식별하고 리턴합니다. 후행 &lt;strong&gt;매직&lt;/strong&gt; 식별자를 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="d4286448984448b29096cfc37d85e421cb0b828a" translate="yes" xml:space="preserve">
          <source>Identifies the file system where the file is located. In Windows, the number indicates a drive as follows: 0 means A:, 1 means B:, and so on.</source>
          <target state="translated">파일이있는 파일 시스템을 식별합니다. Windows에서 숫자는 다음과 같이 드라이브를 나타냅니다. 0은 A :를 의미하고 1은 B :를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a78e241d75b4386f5966c1f03850bc25044aab1e" translate="yes" xml:space="preserve">
          <source>Identifies the key to be used. The format depends on the loaded engine. It is passed to the &lt;code&gt;ENGINE_load_(private|public)_key&lt;/code&gt; functions in libcrypto.</source>
          <target state="translated">사용할 키를 식별합니다. 형식은로드 된 엔진에 따라 다릅니다. libcrypto 의 &lt;code&gt;ENGINE_load_(private|public)_key&lt;/code&gt; 함수로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="5c6a3f5a562e2ce595bdeeb857c4ae74f4eb3a1c" translate="yes" xml:space="preserve">
          <source>Identifies what information to sort by.</source>
          <target state="translated">정렬 할 정보를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="4c35819884b50461c098d94e30fb5a14c994b48c" translate="yes" xml:space="preserve">
          <source>Identifying capturing parentheses by number is simple, but it can be hard to keep track of the numbers in complicated regular expressions. Also, if an expression is modified, the numbers can change. To help with this difficulty, PCRE supports the naming of subpatterns. This feature was not added to Perl until release 5.10. Python had the feature earlier, and PCRE introduced it at release 4.0, using the Python syntax. PCRE now supports both the Perl and the Python syntax. Perl allows identically numbered subpatterns to have different names, but PCRE does not.</source>
          <target state="translated">숫자로 괄호를 식별하는 것은 간단하지만 복잡한 정규식에서 숫자를 추적하기가 어려울 수 있습니다. 또한 표현식이 수정되면 숫자가 변경 될 수 있습니다. 이 어려움을 돕기 위해 PCRE는 하위 패턴의 이름 지정을 지원합니다. 이 기능은 릴리스 5.10까지 Perl에 추가되지 않았습니다. Python은 이전에 기능을 가지고 있었고 PCRE는 Python 구문을 사용하여 릴리스 4.0에서 기능을 도입했습니다. PCRE는 이제 Perl과 Python 구문을 모두 지원합니다. Perl은 동일한 번호의 서브 패턴이 다른 이름을 가질 수 있도록하지만 PCRE는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86dd18440c1a33a5adeeb3446934c0824c7a25f8" translate="yes" xml:space="preserve">
          <source>Identity of connection or session configuration in a configuration file.</source>
          <target state="translated">구성 파일의 연결 또는 세션 구성 ID입니다.</target>
        </trans-unit>
        <trans-unit id="dee66e066bf8a35e6b819408cf3275f475346209" translate="yes" xml:space="preserve">
          <source>Ideographic space</source>
          <target state="translated">표의 문자 공간</target>
        </trans-unit>
        <trans-unit id="772dd6d712cea08023a9c33b5e08bad4fba86f2b" translate="yes" xml:space="preserve">
          <source>Idle.</source>
          <target state="translated">Idle.</target>
        </trans-unit>
        <trans-unit id="d71d2a6296b765e49d14ea0b96f03799b0b788cf" translate="yes" xml:space="preserve">
          <source>If (*ACCEPT) is inside capturing parentheses, the data so far is captured. For example, the following matches &quot;AB&quot;, &quot;AAD&quot;, or &quot;ACD&quot;. When it matches &quot;AB&quot;, &quot;B&quot; is captured by the outer parentheses.</source>
          <target state="translated">(* ACCEPT)가 캡처 괄호 안에 있으면 지금까지의 데이터가 캡처됩니다. 예를 들어 다음은 &quot;AB&quot;, &quot;AAD&quot;또는 &quot;ACD&quot;와 일치합니다. &quot;AB&quot;와 일치하면 외부 괄호로 &quot;B&quot;가 캡처됩니다.</target>
        </trans-unit>
        <trans-unit id="17049b973641f08ec5c309099cc30f3f32903038" translate="yes" xml:space="preserve">
          <source>If (*COMMIT) is the only backtracking verb that is encountered, once it has been passed, &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; is committed to find a match at the current starting point, or not at all, for example:</source>
          <target state="translated">(* COMMIT)이 발생하는 유일한 역 추적 동사 인 경우 일단 통과되면 &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; 은 현재 시작점에서 일치하는 것을 찾거나 전혀 찾지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f0f3a8fd87c3eaeb73231280dec7eb243d5903c" translate="yes" xml:space="preserve">
          <source>If +MMscrpm is set to true, which is default, the initial allocation will reserve physical memory for the entire super carrier. This can be used by users that want to ensure a certain &lt;strong&gt;minimum&lt;/strong&gt; amount of physical memory for the VM.</source>
          <target state="translated">+ MMscrpm이 기본값 인 true로 설정되면 초기 할당은 전체 수퍼 캐리어에 대한 물리적 메모리를 예약합니다. 이는 VM에 대해 &lt;strong&gt;최소한&lt;/strong&gt; 의 물리적 메모리 양 을 확보하려는 사용자가 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40ba26284bd6bedd0128033397652d534ba6ab6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt; file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;latin1&lt;/code&gt;, no translation of path names is done.</source>
          <target state="translated">경우 &lt;code&gt; file:native_name_encoding/0&lt;/code&gt; 반환 &lt;code&gt;latin1&lt;/code&gt; 에 , 경로 이름의 번역이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66bd65b9d1cb2983119740d6067afd32e3a7d58b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt; file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;utf8&lt;/code&gt;, path names are encoded in UTF-8 when creating tar files, and path names are assumed to be encoded in UTF-8 when extracting tar files.</source>
          <target state="translated">경우 &lt;code&gt; file:native_name_encoding/0&lt;/code&gt; 반환 &lt;code&gt;utf8&lt;/code&gt; , tar 파일을 생성 할 때 경로 이름은 UTF-8 인코딩 및 경로 이름은 tar 파일을 추출 할 때 UTF-8로 인코딩 된 것으로 가정한다.</target>
        </trans-unit>
        <trans-unit id="d780bbcc021b00d62054ba34ee21d203ad8580fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;schedule&quot;&lt;/code&gt; is known to the &lt;code&gt;global&lt;/code&gt; module in &lt;code&gt;Kernel&lt;/code&gt;, an Erlang pid is returned that can be used to send messages to the schedule service. Also, &lt;code&gt;node&lt;/code&gt; is initialized to contain the name of the node where the service is registered, so that you can make a connection to it by simply passing the variable to &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;schedule&quot;&lt;/code&gt; 이 &lt;code&gt;Kernel&lt;/code&gt; 의 &lt;code&gt;global&lt;/code&gt; 모듈에 알려진 경우 , 스케줄 서비스에 메시지를 보내는 데 사용할 수있는 Erlang pid가 리턴됩니다. 또한 &lt;code&gt;node&lt;/code&gt; 는 서비스가 등록 된 노드의 이름을 포함하도록 초기화되므로 변수를 &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt; 에 전달하여 간단히 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1dd779b7143c0739432543164284fa524cccd2f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;schedule&quot;&lt;/code&gt; is known to the &lt;code&gt;global&lt;/code&gt; module in &lt;code&gt;Kernel&lt;/code&gt;, an Erlang pid is written to the_pid. This pid that can be used to send messages to the schedule service. Also, &lt;code&gt;node&lt;/code&gt; is initialized to contain the name of the node where the service is registered, so that you can make a connection to it by simply passing the variable to &lt;code&gt;&lt;a href=&quot;ei_connect&quot;&gt;ei_connect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&quot;schedule&quot;&lt;/code&gt; 받는 알려진 &lt;code&gt;global&lt;/code&gt; 에서 모듈 &lt;code&gt;Kernel&lt;/code&gt; , 얼랑 PID는 the_pid에 기록됩니다. 일정 서비스에 메시지를 보내는 데 사용할 수있는이 pid입니다. 또한 &lt;code&gt;node&lt;/code&gt; 는 서비스가 등록 된 노드의 이름을 포함하도록 초기화되므로 변수를 &lt;code&gt;&lt;a href=&quot;ei_connect&quot;&gt;ei_connect&lt;/a&gt;&lt;/code&gt; 에 전달하기 만하면 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e26772d0fb234e217566d6d19fae8939ae23412" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt; &lt;strong&gt;callback mode&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle_event_function&lt;/code&gt; is used, all events are handled in &lt;code&gt;Module:handle_event/4&lt;/code&gt; and we can (but do not have to) use an event-centered approach where we first branch depending on event and then depending on state:</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt; &lt;strong&gt;callback mode&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; &lt;code&gt;handle_event_function&lt;/code&gt; 가 사용되는 모든 이벤트가 처리됩니다 &lt;code&gt;Module:handle_event/4&lt;/code&gt; 우리가 처음 지점 상태에 따라 다음 이벤트에 따라와 이벤트 중심의 접근 방식을 사용하고 우리는 (그러나이없는) 수 : &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6005483687ef9ab80b3590fb0cf13631ca631c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Mode&lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle_event_function&lt;/code&gt; is used, all events are handled in &lt;code&gt;Module:handle_event/4&lt;/code&gt; and we can (but do not have to) use an event-centered approach where we first branch depending on event and then depending on state:</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Mode&lt;/a&gt;&lt;/code&gt; &lt;code&gt;handle_event_function&lt;/code&gt; 가 사용되는 모든 이벤트가 처리됩니다 &lt;code&gt;Module:handle_event/4&lt;/code&gt; 우리가 처음 지점 상태에 따라 다음 이벤트에 따라와 이벤트 중심의 접근 방식을 사용하고 우리는 (그러나이없는) 수 :</target>
        </trans-unit>
        <trans-unit id="bebc3f9361919a37bdadad08140e7c6cde4d32d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; does not return such a list, no &lt;strong&gt;state enter calls&lt;/strong&gt; are done.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 등의 목록을 반환하지 않습니다, 어떤 &lt;strong&gt;상태에 통화가 입력되지&lt;/strong&gt; 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ca5cadc65f5f231df3ce6310110d1f4f33d8f4c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; does not return such a list, no state enter calls are done.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 등의 목록을 반환하지 않습니다, 어떤 상태에 통화가 완료 입력합니다.</target>
        </trans-unit>
        <trans-unit id="f1ede23ffb5bebc5707015ac6f688b4dfda3fb06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; returns a list containing &lt;code&gt;state_enter&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; engine will, at every &lt;strong&gt;state change&lt;/strong&gt;, call the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; with arguments &lt;code&gt;(enter, OldState, Data)&lt;/code&gt; or &lt;code&gt;(enter, OldState, State, Data)&lt;/code&gt;, depending on the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;. This may look like an event but is really a call performed after the previous &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; returned and before any event is delivered to the new &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt;. Such a call can be repeated by returning a &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state &lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state_and_data &lt;/a&gt;&lt;/code&gt; tuple from the &lt;strong&gt;state callback&lt;/strong&gt;.</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 반환이 포함 된 목록 &lt;code&gt;state_enter&lt;/code&gt; 을 의 &lt;code&gt;gen_statem&lt;/code&gt; 의 엔진은 모든에서 할 &lt;strong&gt;상태 변경&lt;/strong&gt; , 부르는 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 인수 &lt;code&gt;(enter, OldState, Data)&lt;/code&gt; 또는 &lt;code&gt;(enter, OldState, State, Data)&lt;/code&gt; 에 따라 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; . 이것은 이벤트처럼 보일 수 있지만 실제로는 이전 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 반환 된 후 그리고 이벤트가 새로운 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 전달되기 전에 수행 되는 &lt;strong&gt;호출&lt;/strong&gt; 입니다. &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 . 이러한 호출은 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state &lt;/a&gt;&lt;/code&gt; 를 리턴하여 반복 될 수 있습니다.또는 &lt;strong&gt;상태 콜백&lt;/strong&gt; 에서 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state_and_data &lt;/a&gt;&lt;/code&gt; 튜플 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="acdd1ca7763b0bdfa6212efd72aad6a1d16e6bec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; returns a list containing &lt;code&gt;state_enter&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; engine will, at every state change, call the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; with arguments &lt;code&gt;(enter, OldState, Data)&lt;/code&gt;. This may look like an event but is really a call performed after the previous state callback returned and before any event is delivered to the new state callback. See &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt;. Such a call can be repeated by returning a &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; tuple from the state callback.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 반환이 포함 된 목록 &lt;code&gt;state_enter&lt;/code&gt; 을 의 &lt;code&gt;gen_statem&lt;/code&gt; 의 엔진은 모든 상태 변화에의 호출 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 인수를 &lt;code&gt;(enter, OldState, Data)&lt;/code&gt; . 이것은 이벤트처럼 보이지만 실제로는 이전 상태 콜백이 반환 된 후 이벤트가 새 상태 콜백으로 전달되기 전에 수행되는 호출입니다. &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 . 이러한 콜은 상태 콜백으로부터 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; 튜플을 반환함으로써 반복 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c28ef58b982d1f354c9c1bb974e90b1d95e0f6b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;Module:code_change/4&lt;/a&gt;&lt;/code&gt; should transform the state, it is regarded as a state rename and not a &lt;strong&gt;state change&lt;/strong&gt;, which will not cause a &lt;strong&gt;state enter call&lt;/strong&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;Module:code_change/4&lt;/a&gt;&lt;/code&gt; 상태를 변환한다, 이것은 상태 바꾸기 아닌 것으로 간주되는 &lt;strong&gt;상태가 변경&lt;/strong&gt; 되지 원인이되며, &lt;strong&gt;상태 호를 입력&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d69858e99b09a6a2285a4ba103a8f8d3c928ade9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;Module:code_change/4&lt;/a&gt;&lt;/code&gt; should transform the state, it is regarded as a state rename and not a state change, which will not cause a state enter call.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;Module:code_change/4&lt;/a&gt;&lt;/code&gt; 상태를 변환한다 그것이없는 상태의 원인 호를 입력하는 상태를 바꾸고 있지 상태 변화로 간주된다.</target>
        </trans-unit>
        <trans-unit id="c3e9d1ef03578b7d4de76213b44cdc398818f9bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the current event is postponed.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; , 현재의 이벤트가 연기한다.</target>
        </trans-unit>
        <trans-unit id="af5f4ef54abaee17eded82e21fef9696e20a28ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt; &lt;strong&gt;state enter calls&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; are used, and either it is the initial state or one of the callback results &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state_and_data &lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state_and_data &lt;/a&gt;&lt;/code&gt; is used the &lt;code&gt;gen_statem&lt;/code&gt; engine calls the current state callback with arguments &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, State, Data)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, State, State, Data)&lt;/a&gt;&lt;/code&gt; (depending on &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;) and when it returns starts again from the top of this sequence.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt; &lt;strong&gt;state enter calls&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; 사용되며, 하나는 초기 상태 또는 콜백 결과 중 하나입니다 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state_and_data &lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state_and_data &lt;/a&gt;&lt;/code&gt; 가 사용 된입니다 &lt;code&gt;gen_statem&lt;/code&gt; 의 엔진이 인수를 사용하여 현재 상태 콜백 호출 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, State, Data)&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, State, State, Data)&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 에 따라 다름 ) 및 반환시이 시퀀스의 맨 위에서 다시 시작됩니다. &lt;strong&gt;&lt;/strong&gt; &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd474c164e6c98dd34c39ad22b25553a62777256" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt; &lt;strong&gt;state enter calls&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; are used, and the state changes the &lt;code&gt;gen_statem&lt;/code&gt; engine calls the new state callback with arguments &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, Data)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, State, Data)&lt;/a&gt;&lt;/code&gt; (depending on &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;) and when it returns starts again from the top of this sequence.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt; &lt;strong&gt;state enter calls&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; 사용되며, 상태가 변경 &lt;code&gt;gen_statem&lt;/code&gt; 의 엔진이 인수를 사용하여 새로운 상태 콜백 호출 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, Data)&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, State, Data)&lt;/a&gt;&lt;/code&gt; (에 따라 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; )과는 다시 시작을 반환 할 때 이 시퀀스의 맨 위에서. &lt;strong&gt;&lt;/strong&gt; &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e210051c1bffc48ec6b9fc364560332e7094f3fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; are used, and either: the state changes, it is the initial state, or one of the callback results &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; is used; the &lt;code&gt;gen_statem&lt;/code&gt; calls the new state callback with arguments &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, Data)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 을 사용하고 하나되어 상태 변화를, 그것은 초기 상태, 또는 콜백 결과 중 하나는 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; 가 사용된다 &lt;code&gt;gen_statem&lt;/code&gt; 는 인수를 사용하여 새로운 상태 콜백을 호출 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, Data)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16fb9d916c4a4fe6d38e2fad03d1c0057e0a3ba9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;release_handling#sys&quot;&gt;release handling&lt;/a&gt;&lt;/code&gt; is used, exactly one system configuration file is to be used and that file is to be called &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;release_handling#sys&quot;&gt;release handling&lt;/a&gt;&lt;/code&gt; 사용되며, 정확히 하나 개의 시스템 구성 파일이 사용되어야하며, 해당 파일을 호출하는 것입니다 &lt;code&gt;sys.config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51507c4f6a07b6ee28c5c354867983982dadbd0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Abs&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; an absolute timer is started, and if it is &lt;code&gt;false&lt;/code&gt; a relative, which is the default. See &lt;code&gt; erlang:start_timer/4 &lt;/code&gt; for details.</source>
          <target state="translated">경우 &lt;code&gt;Abs&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; 절대 타이머가 시작되며,이 경우 &lt;code&gt;false&lt;/code&gt; 기본 인 상대를. 자세한 내용은 &lt;code&gt; erlang:start_timer/4 &lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f6115cbb4f02f28f406dcce7ea93217a4c99b305" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Abs&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; an absolute timer is started, and if it is &lt;code&gt;false&lt;/code&gt; a relative, which is the default. See &lt;code&gt;erlang:start_timer/4&lt;/code&gt; for details.</source>
          <target state="translated">경우 &lt;code&gt;Abs&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; 절대 타이머가 시작되며,이 경우 &lt;code&gt;false&lt;/code&gt; 기본 인 상대를. 자세한 내용은 &lt;code&gt;erlang:start_timer/4&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d0a20b01d494121fa23ac0f013c356e2645f0690" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ActiveSuspendCount =/= 0&lt;/code&gt;, &lt;code&gt;Suspendee&lt;/code&gt; is currently in the suspended state.</source>
          <target state="translated">경우 &lt;code&gt;ActiveSuspendCount =/= 0&lt;/code&gt; , &lt;code&gt;Suspendee&lt;/code&gt; 은 일시 중단 된 상태로 현재.</target>
        </trans-unit>
        <trans-unit id="10d7f30204e89013efcda3ea67f9618ecad92260" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Alg&lt;/code&gt; is &lt;code&gt;crypto&lt;/code&gt; this function behaves exactly like &lt;code&gt;&lt;a href=&quot;#rand_seed_s-0&quot;&gt;rand_seed_s/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Alg&lt;/code&gt; 이다 &lt;code&gt;crypto&lt;/code&gt; 이 기능이 정확히처럼 동작 &lt;code&gt;&lt;a href=&quot;#rand_seed_s-0&quot;&gt;rand_seed_s/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3833f82acaa575d2a76a8a6ea669ec6336dec8e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Alg&lt;/code&gt; is &lt;code&gt;crypto_cache&lt;/code&gt; this function fetches random data with OpenSSL's &lt;code&gt;RAND_bytes&lt;/code&gt; and caches it for speed using an internal word size of 56 bits that makes calculations fast on 64 bit machines.</source>
          <target state="translated">경우 &lt;code&gt;Alg&lt;/code&gt; 이다 &lt;code&gt;crypto_cache&lt;/code&gt; 를 이 기능은 OpenSSL의 랜덤 데이터 페치 &lt;code&gt;RAND_bytes&lt;/code&gt; 64 개 비트 시스템에 빠르게 계산하게하는 56 비트의 내부 워드 크기를 사용하여 속도를 캐시.</target>
        </trans-unit>
        <trans-unit id="81e735d9039bbf6127ac283e19b140ef66799a72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Asn1Type&lt;/code&gt; is &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt;, &lt;code&gt;Entity&lt;/code&gt; must be either an &lt;code&gt;rsa_public_key()&lt;/code&gt;, &lt;code&gt;dsa_public_key()&lt;/code&gt; or an &lt;code&gt;ec_public_key()&lt;/code&gt; and this function creates the appropriate &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; entry.</source>
          <target state="translated">경우 &lt;code&gt;Asn1Type&lt;/code&gt; 가 있다 &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; , &lt;code&gt;Entity&lt;/code&gt; 의 어느 쪽인가이어야 &lt;code&gt;rsa_public_key()&lt;/code&gt; , &lt;code&gt;dsa_public_key()&lt;/code&gt; 또는 &lt;code&gt;ec_public_key()&lt;/code&gt; ,이 함수는 해당 생성 &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; 항목.</target>
        </trans-unit>
        <trans-unit id="540115359cf8a83ae29b77cf40e5db9ee30403e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Asn1module&lt;/code&gt; is a filename without extension, first &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; is assumed, then &lt;code&gt;&quot;.asn&quot;&lt;/code&gt;, and finally &lt;code&gt;&quot;.py&quot;&lt;/code&gt; (to be compatible with the old ASN.1 compiler). &lt;code&gt;Asn1module&lt;/code&gt; can be a full pathname (relative or absolute) including filename with (or without) extension.</source>
          <target state="translated">&lt;code&gt;Asn1module&lt;/code&gt; 이 확장명이없는 파일 이름 인 경우 먼저 &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; , &lt;code&gt;&quot;.asn&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;.py&quot;&lt;/code&gt; (이전 ASN.1 컴파일러와 호환 가능)로 가정합니다. &lt;code&gt;Asn1module&lt;/code&gt; 은 파일 이름을 포함하거나 포함하지 않는 파일 이름을 포함하여 전체 경로 이름 (상대적 또는 절대적) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fdaeedafeeda6ab32c9d50b3c97381ca731e512" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bin&lt;/code&gt; does not contain the entire packet, &lt;code&gt;{more,Length}&lt;/code&gt; is returned. &lt;code&gt;Length&lt;/code&gt; is either the expected &lt;strong&gt;total size&lt;/strong&gt; of the packet, or &lt;code&gt;undefined&lt;/code&gt; if the expected packet size is unknown. &lt;code&gt;decode_packet&lt;/code&gt; can then be called again with more data added.</source>
          <target state="translated">경우 &lt;code&gt;Bin&lt;/code&gt; 전체 패킷을 포함하지 않는, &lt;code&gt;{more,Length}&lt;/code&gt; 반환됩니다. &lt;code&gt;Length&lt;/code&gt; 는 패킷 의 예상 &lt;strong&gt;총 크기&lt;/strong&gt; 이거나 예상 패킷 크기를 알 수없는 경우 &lt;code&gt;undefined&lt;/code&gt; . 그런 다음 더 많은 데이터를 추가하여 &lt;code&gt;decode_packet&lt;/code&gt; 을 다시 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f95f96eeb6722b14446ed74c5ef5dfae744b890d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BinRel1&lt;/code&gt; is omitted, the relation of equality between the elements of the &lt;code&gt;&lt;a href=&quot;#Cartesian_product_tuple&quot;&gt;Cartesian product&lt;/a&gt;&lt;/code&gt; of the ranges of R[i], range R[1] &amp;times; ... &amp;times; range R[n], is used instead (intuitively, nothing is &quot;lost&quot;).</source>
          <target state="translated">경우 &lt;code&gt;BinRel1&lt;/code&gt; 가 생략되면, 요소가 등가의 관계 &lt;code&gt;&lt;a href=&quot;#Cartesian_product_tuple&quot;&gt;Cartesian product&lt;/a&gt;&lt;/code&gt; R [i]를, 거리 R [1] &amp;times; ... &amp;times; 범위 R [N]의 범위가 &quot;직관적 아무것도 없다 (대신 사용 잃어버린&quot;).</target>
        </trans-unit>
        <trans-unit id="ab7b5f7a351be014914684701b08694a59a8d0bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Binaries&lt;/code&gt; is not a flat list of binaries, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">&lt;code&gt;Binaries&lt;/code&gt; 가 플랫 바이너리 목록이 아닌 경우 &lt;code&gt;badarg&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aec03c703d777c73a4a57e3a4befcb0a209f3691" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Binary&lt;/code&gt; contains the object code for module &lt;code&gt;Module&lt;/code&gt;, this BIF loads that object code. If the code for module &lt;code&gt;Module&lt;/code&gt; already exists, all export references are replaced so they point to the newly loaded code. The previously loaded code is kept in the system as old code, as there can still be processes executing that code.</source>
          <target state="translated">경우 &lt;code&gt;Binary&lt;/code&gt; 모듈의 오브젝트 코드가 포함되어 &lt;code&gt;Module&lt;/code&gt; , 오브젝트 코드이 BIF로드. 모듈 &lt;code&gt;Module&lt;/code&gt; 에 대한 코드가 이미 존재하면 모든 내보내기 참조가 교체되어 새로로드 된 코드를 가리 킵니다. 이전에로드 된 코드는 해당 코드를 실행하는 프로세스가 여전히있을 수 있으므로 이전 코드로 시스템에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="bf1ea3c8c99142091a2f51c1e81be7adb284b19c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BlockState =:= block&lt;/code&gt;, multi-scheduling is blocked. That is, one and only one scheduler thread will execute. If &lt;code&gt;BlockState =:= unblock&lt;/code&gt; and no one else blocks multi-scheduling, and this process has blocked only once, multi-scheduling is unblocked.</source>
          <target state="translated">경우 &lt;code&gt;BlockState =:= block&lt;/code&gt; 다중 스케줄링은 차단된다. 즉, 하나의 스케줄러 스레드 만 실행됩니다. 경우 &lt;code&gt;BlockState =:= unblock&lt;/code&gt; 아무도 다른 블록 멀티 스케줄링,이 프로세스는 한 번 차단했습니다, 멀티 스케줄링은 차단 해제입니다.</target>
        </trans-unit>
        <trans-unit id="39adb796c018ce57c270103c3c52ab7a2219f00b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BlockState =:= block_normal&lt;/code&gt;, normal multi-scheduling is blocked. That is, only one normal scheduler thread will execute, but multiple dirty schedulers can execute. If &lt;code&gt;BlockState =:= unblock_normal&lt;/code&gt; and no one else blocks normal multi-scheduling, and this process has blocked only once, normal multi-scheduling is unblocked.</source>
          <target state="translated">경우 &lt;code&gt;BlockState =:= block_normal&lt;/code&gt; , 일반 다중 스케줄링이 차단됩니다. 즉, 하나의 일반 스케줄러 스레드 만 실행되지만 여러 개의 더티 스케줄러가 실행될 수 있습니다. 경우 &lt;code&gt;BlockState =:= unblock_normal&lt;/code&gt; 아무도 다른 블록 일반 멀티 스케줄링,이 과정은 한 번만 차단했습니다, 일반 다중 스케줄링은 차단 해제입니다.</target>
        </trans-unit>
        <trans-unit id="4eabdce3dc316d89d6448638269f7e3485875fb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Body&lt;/code&gt; is returned and equal to &lt;code&gt;{Fun,Arg}&lt;/code&gt;, the web server tries &lt;code&gt;apply/2&lt;/code&gt; on &lt;code&gt;Fun&lt;/code&gt; with &lt;code&gt;Arg&lt;/code&gt; as argument. The web server expects that the fun either returns a list &lt;code&gt;(Body)&lt;/code&gt; that is an HTTP repsonse, or the atom &lt;code&gt;sent&lt;/code&gt; if the HTTP response is sent back to the client. If &lt;code&gt;close&lt;/code&gt; is returned from the fun, something has gone wrong and the server signals this to the client by closing the connection.</source>
          <target state="translated">경우 &lt;code&gt;Body&lt;/code&gt; 돌려 같다 &lt;code&gt;{Fun,Arg}&lt;/code&gt; , 웹 서버 시도는 &lt;code&gt;apply/2&lt;/code&gt; 에 &lt;code&gt;Fun&lt;/code&gt; 와 &lt;code&gt;Arg&lt;/code&gt; 인수로. 웹 서버는 fun 이 HTTP 응답 인 목록 &lt;code&gt;(Body)&lt;/code&gt; 을 반환 하거나 HTTP 응답이 클라이언트에 다시 &lt;code&gt;sent&lt;/code&gt; 되면 원자 를 반환 할 것으로 예상합니다 . fun에서 &lt;code&gt;close&lt;/code&gt; 가 반환 되면 문제가 발생한 것이므로 서버는 연결을 닫아 클라이언트에게이를 알립니다.</target>
        </trans-unit>
        <trans-unit id="501ba76048afe6c06b0d19442d6fa569952e8089" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bool&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default value), &lt;code&gt;rb&lt;/code&gt; prints an error message to &lt;code&gt;stdout&lt;/code&gt; for every bad report it encounters, but the logging process is never ended. All printable reports are written. If logging to file is enabled, &lt;code&gt;rb&lt;/code&gt; prints &lt;code&gt;* UNPRINTABLE REPORT *&lt;/code&gt; in the log file at the location of an unprintable report.</source>
          <target state="translated">경우 &lt;code&gt;Bool&lt;/code&gt; 있다 &lt;code&gt;false&lt;/code&gt; (기본값), &lt;code&gt;rb&lt;/code&gt; 에 에러 메시지를 출력 &lt;code&gt;stdout&lt;/code&gt; 이 발생하는 모든 나쁜 보고서에 대한,하지만 로깅 프로세스가 종료되지 않습니다. 인쇄 가능한 모든 보고서가 작성됩니다. 파일에 로깅을 사용하는 경우, &lt;code&gt;rb&lt;/code&gt; 인쇄는 &lt;code&gt;* UNPRINTABLE REPORT *&lt;/code&gt; 인쇄 할 수없는 보고서의 위치에서 로그 파일을.</target>
        </trans-unit>
        <trans-unit id="adf90318c831c61cd69b483b3f045a3d3bf9c68f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bool&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;rb&lt;/code&gt; stops logging (and prints an error message to &lt;code&gt;stdout&lt;/code&gt;) if it encounters a badly formatted report. If logging to file is enabled, an error message is appended to the log file as well.</source>
          <target state="translated">경우 &lt;code&gt;Bool&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;rb&lt;/code&gt; 로깅을 중지 (과에 에러 메시지를 출력 &lt;code&gt;stdout&lt;/code&gt; ) 그것은 잘못된 형식의 보고서가 발생합니다. 파일에 로깅이 활성화되면 오류 메시지도 로그 파일에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f4e4245f2e5400c897f04314650c4ae5a083dc43" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Boolean == true&lt;/code&gt;, option &lt;code&gt;TCP_NODELAY&lt;/code&gt; is turned on for the socket, which means that also small amounts of data are sent immediately.</source>
          <target state="translated">&lt;code&gt;Boolean == true&lt;/code&gt; 인 경우 소켓에 대해 &lt;code&gt;TCP_NODELAY&lt;/code&gt; 옵션 이 설정되어 있으므로 소량의 데이터도 즉시 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="694f121851d48acf6a07239b2f70a6b720fe0aa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Boolean == true&lt;/code&gt;, the corresponding option is turned on for the socket, which means that small amounts of data are accumulated until a full MSS-worth of data is available or this option is turned off.</source>
          <target state="translated">경우 &lt;code&gt;Boolean == true&lt;/code&gt; , 해당 옵션은 데이터의 전체 MSS 가치를 사용할 경우, 또는이 옵션이 해제 될 때까지 적은 양의 데이터가 축적되는 것을 의미 소켓을 위해 켜집니다.</target>
        </trans-unit>
        <trans-unit id="81aeea37b05ee5c673682e9fcc0d5b3b90b2fd57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Button&lt;/code&gt; is a top type and it is needed to exclude component &lt;code&gt;number&lt;/code&gt; from decode, &lt;code&gt;Type_List&lt;/code&gt; in the instruction in the configuration file is &lt;code&gt;['Button',[{number,undecoded}]]&lt;/code&gt;. If you call the decode function &lt;code&gt;decode_Button_exclusive&lt;/code&gt;, &lt;code&gt;Decode_Instruction&lt;/code&gt; is &lt;code&gt;{decode_Button_exclusive,['Button',[{number,undecoded}]]}&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Button&lt;/code&gt; 상부 형이며 구성은 배제하기 위해 필요한 &lt;code&gt;number&lt;/code&gt; 디코드에서 &lt;code&gt;Type_List&lt;/code&gt; 구성 파일에 지시가 &lt;code&gt;['Button',[{number,undecoded}]]&lt;/code&gt; . 당신이 디코드 함수를 호출 할 경우 &lt;code&gt;decode_Button_exclusive&lt;/code&gt; 을 , &lt;code&gt;Decode_Instruction&lt;/code&gt; 이 있다 &lt;code&gt;{decode_Button_exclusive,['Button',[{number,undecoded}]]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0a8d1dadfc486d1483799d20461767cefd8ed40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Common Test&lt;/code&gt; Master fails initially to connect to any of the test nodes specified in a test specification or in the &lt;code&gt;InclNodes&lt;/code&gt; list, the operator is prompted with the option to either start over again (after manually checking the status of the nodes in question), to run without the missing nodes, or to abort the operation.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; Master가 처음에 테스트 스펙 또는 &lt;code&gt;InclNodes&lt;/code&gt; 목록 에 지정된 테스트 노드에 연결하는 데 실패한 경우 , 운영자는 해당 노드의 상태를 수동으로 확인한 후 다시 시작하는 옵션이 프롬프트됩니다. 누락 된 노드없이 실행하거나 작업을 중단합니다.</target>
        </trans-unit>
        <trans-unit id="7f9aad828bfbe4d21e5a879fcef15f035543f64c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;CurrentIndentation&lt;/code&gt; is negative, there are no line breaks and only a space is used as a separator.</source>
          <target state="translated">경우 &lt;code&gt;CurrentIndentation&lt;/code&gt; 가 음수, 아무 개행없는 유일한 공간이 세퍼레이터로 사용된다.</target>
        </trans-unit>
        <trans-unit id="5c9db23221c4effc6df13f53f295b1b05c8bade4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Data&lt;/code&gt; is an invalid I/O list.</source>
          <target state="translated">경우 &lt;code&gt;Data&lt;/code&gt; 잘못된 I / O 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d49ad8995eb2ed767b688b2071df0c58e2d5482e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dates&lt;/code&gt; has the form &lt;code&gt;{DateTo, to}&lt;/code&gt;, reports that occurred before &lt;code&gt;DateTo&lt;/code&gt; are displayed.</source>
          <target state="translated">경우 &lt;code&gt;Dates&lt;/code&gt; 양식을 가지고 &lt;code&gt;{DateTo, to}&lt;/code&gt; , 이전에 발생한 보고서 &lt;code&gt;DateTo&lt;/code&gt; 가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9a74df3b45fff783ce83be5e48dd039ecedaba02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dest&lt;/code&gt; is a &lt;code&gt;pid()&lt;/code&gt;, it must be a &lt;code&gt;pid()&lt;/code&gt; of a process created on the current runtime system instance. This process has either terminated or not. If &lt;code&gt;Dest&lt;/code&gt; is an &lt;code&gt;atom()&lt;/code&gt;, it is interpreted as the name of a locally registered process. The process referred to by the name is looked up at the time of timer expiration. No error is returned if the name does not refer to a process.</source>
          <target state="translated">경우 &lt;code&gt;Dest&lt;/code&gt; A는 &lt;code&gt;pid()&lt;/code&gt; , 그것은해야합니다 &lt;code&gt;pid()&lt;/code&gt; 현재 런타임 시스템 인스턴스에 생성 프로세스의. 이 프로세스는 종료되었거나 종료되지 않았습니다. 경우 &lt;code&gt;Dest&lt;/code&gt; 인 &lt;code&gt;atom()&lt;/code&gt; , 그것은 로컬로 등록 프로세스의 이름으로 해석된다. 이름으로 언급 된 프로세스는 타이머 만료시 조회됩니다. 이름이 프로세스를 참조하지 않으면 오류가 리턴되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="815563aae4c2a11f4a34513e2da4caef9eb431be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dest&lt;/code&gt; is a &lt;code&gt;pid()&lt;/code&gt;, the timer is automatically canceled if the process referred to by the &lt;code&gt;pid()&lt;/code&gt; is not alive, or if the process exits. This feature was introduced in ERTS 5.4.11. Notice that timers are not automatically canceled when &lt;code&gt;Dest&lt;/code&gt; is an &lt;code&gt;atom()&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Dest&lt;/code&gt; A는 &lt;code&gt;pid()&lt;/code&gt; 타이머가 자동으로 프로세스에 의해 참조이 취소됩니다 &lt;code&gt;pid()&lt;/code&gt; 살아 아니거나 프로세스가 종료되는 경우. 이 기능은 ERTS 5.4.11에서 도입되었습니다. &lt;code&gt;Dest&lt;/code&gt; 가 &lt;code&gt;atom()&lt;/code&gt; 경우 타이머가 자동으로 취소되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="444e6101a0cf1c543819e121052f438f584a1b39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Destination&lt;/code&gt; refers to a filename, it is opened with &lt;code&gt;write&lt;/code&gt; mode prepended to the mode list before the copy, and closed when done.</source>
          <target state="translated">경우 &lt;code&gt;Destination&lt;/code&gt; 파일 이름을 의미, 그것은 열립니다 &lt;code&gt;write&lt;/code&gt; 복사하기 전에 모드 목록 앞에 추가 모드, 완료되면 마감했다.</target>
        </trans-unit>
        <trans-unit id="4f4e05199aa0bb385a948469feaaa5b970e7e3f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dir&lt;/code&gt; does not exist</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 이없는 경우</target>
        </trans-unit>
        <trans-unit id="ee2b254fd6abe2a90dfea4382f11c9cb30169e97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Distributed == default&lt;/code&gt;, the value for the application in the Kernel configuration parameter &lt;code&gt;distributed&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;Distributed == default&lt;/code&gt; 인 경우 , Kernel 구성 매개 변수 &lt;code&gt;distributed&lt;/code&gt; 의 응용 프로그램 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="49d3ece08d6530837a1ab0ddc7b321c040846a53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Distributed == {Application,[Time,]Nodes}&lt;/code&gt;, the application becomes distributed. The argument overrides the value for the application in the Kernel configuration parameter &lt;code&gt;distributed&lt;/code&gt;. &lt;code&gt;Application&lt;/code&gt; must be the application name (same as in the first argument). If a node crashes and &lt;code&gt;Time&lt;/code&gt; is specified, the application controller waits for &lt;code&gt;Time&lt;/code&gt; milliseconds before attempting to restart the application on another node. If &lt;code&gt;Time&lt;/code&gt; is not specified, it defaults to &lt;code&gt;0&lt;/code&gt; and the application is restarted immediately.</source>
          <target state="translated">경우 &lt;code&gt;Distributed == {Application,[Time,]Nodes}&lt;/code&gt; , 응용 프로그램이 배포된다. 인수는 &lt;code&gt;distributed&lt;/code&gt; 커널 구성 매개 변수의 응용 프로그램 값을 대체합니다 . &lt;code&gt;Application&lt;/code&gt; 은 응용 프로그램 이름이어야합니다 (첫 번째 인수와 동일). 노드가 충돌하고 &lt;code&gt;Time&lt;/code&gt; 이 지정된 경우 응용 프로그램 제어기는 다른 노드에서 응용 프로그램을 다시 시작하기 전에 &lt;code&gt;Time&lt;/code&gt; 밀리 초) 동안 대기 합니다. 경우 &lt;code&gt;Time&lt;/code&gt; 지정되지 않은, 그것은 기본값은 &lt;code&gt;0&lt;/code&gt; 과 응용 프로그램이 즉시 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="4152fae1a454be09c28651bdb166f8066323431a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, lists of integers &lt;code&gt;0..255&lt;/code&gt; or binaries containing plain bytes are sent back to the client when possible. If &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;unicode&lt;/code&gt;, lists with integers in the whole Unicode range or binaries encoded in UTF-8 are sent to the client. The user-supplied function always sees lists of integers, never binaries, but the list can contain numbers &amp;gt; 255 if &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;unicode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Encoding&lt;/code&gt; 이 &lt;code&gt;latin1&lt;/code&gt; 인 경우 정수 바이트 &lt;code&gt;0..255&lt;/code&gt; 또는 일반 바이트를 포함하는 이진 목록은 가능한 경우 클라이언트로 다시 전송됩니다. &lt;code&gt;Encoding&lt;/code&gt; 이 &lt;code&gt;unicode&lt;/code&gt; 인 경우 전체 유니 코드 범위의 정수 목록 또는 UTF-8로 인코딩 된 이진은 클라이언트로 전송됩니다. 사용자 제공 함수는 항상 정수 목록을 보지만 절대 이진은 아니지만 &lt;code&gt;Encoding&lt;/code&gt; 이 &lt;code&gt;unicode&lt;/code&gt; 인 경우 목록에 숫자&amp;gt; 255가 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="795ff54ae5d53c3fcba2e08602c3c1f2e9df291a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End == close&lt;/code&gt;, data is returned to the caller when the channel is closed by the server. If a time-out occurs before this happens, the function returns &lt;code&gt;{timeout,Data}&lt;/code&gt; (where &lt;code&gt;Data&lt;/code&gt; is the data received so far).</source>
          <target state="translated">경우 &lt;code&gt;End == close&lt;/code&gt; 채널이 서버에 의해 폐쇄 될 때, 데이터는 호출자에게 반환된다. 이 시간이 초과되기 전에 &lt;code&gt;{timeout,Data}&lt;/code&gt; 가 발생하면 함수는 {timeout, Data}를 리턴합니다 (여기서 &lt;code&gt;Data&lt;/code&gt; 는 지금까지 수신 된 데이터 임).</target>
        </trans-unit>
        <trans-unit id="4c405ae6dd72ff067086a677208e5abd694be786" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End == timeout&lt;/code&gt;, a time-out is expected and &lt;code&gt;{ok,Data}&lt;/code&gt; is returned both in the case of a time-out and when the channel is closed.</source>
          <target state="translated">경우 &lt;code&gt;End == timeout&lt;/code&gt; , 시간 제한이 예상되며, &lt;code&gt;{ok,Data}&lt;/code&gt; 타임 아웃의 경우 모두 반환되고 채널이 닫힐 때.</target>
        </trans-unit>
        <trans-unit id="9a4d4ab4678c1a0d9f4a6cd0d0cd26eccd4b8374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End&lt;/code&gt; is a fun, this fun is called with one argument, the data value in a received &lt;code&gt;ssh_cm&lt;/code&gt; message (see &lt;code&gt;ssh_connection(3)&lt;/code&gt;. The fun is to return either &lt;code&gt;true&lt;/code&gt; to end the receiving operation (and have the so far collected data returned) or &lt;code&gt;false&lt;/code&gt; to wait for more data from the server. Even if a fun is supplied, the function returns immediately if the server closes the channel).</source>
          <target state="translated">경우 &lt;code&gt;End&lt;/code&gt; 재미있는이다,이 재미는 하나 개의 인수, 수신의 데이터 값이라고 &lt;code&gt;ssh_cm&lt;/code&gt; 의 메시지 (참조 &lt;code&gt;ssh_connection(3)&lt;/code&gt; . 재미 중 하나를 반환하는 것입니다 &lt;code&gt;true&lt;/code&gt; 반환 지금까지 수집 된 데이터를 수신 동작을 종료 (그리고 가지고 ) 또는 &lt;code&gt;false&lt;/code&gt; 는 서버에서 더 많은 데이터를 기다립니다. 재미가 제공 되더라도 서버가 채널을 닫으면 즉시 함수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="91045bcf979078e315cc68ac468e5a360ddec33a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EnumTypeName&lt;/code&gt; does not exist in the ASN.1 specification, the compilation stops with an error code.</source>
          <target state="translated">경우 &lt;code&gt;EnumTypeName&lt;/code&gt; 이 정보를 ASN 사양에 존재하지 않는, 컴파일은 오류 코드가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="bd759ced4b466f7b939196360d08509e4b762583" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={global,GlobalName}&lt;/code&gt;, the event manager is registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt; global:register_name/2&lt;/code&gt;. If no name is provided, the event manager is not registered.</source>
          <target state="translated">경우 &lt;code&gt;EventMgrName={global,GlobalName}&lt;/code&gt; 이벤트 매니저는 세계적으로 등록 &lt;code&gt;GlobalName&lt;/code&gt; 사용 &lt;code&gt; global:register_name/2&lt;/code&gt; . 이름이 제공되지 않으면 이벤트 관리자가 등록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6ac5b0475b7a71717a3a976c82dd686c7a2b338" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={global,GlobalName}&lt;/code&gt;, the event manager is registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;. If no name is provided, the event manager is not registered.</source>
          <target state="translated">경우 &lt;code&gt;EventMgrName={global,GlobalName}&lt;/code&gt; 이벤트 매니저는 세계적으로 등록 &lt;code&gt;GlobalName&lt;/code&gt; 사용 &lt;code&gt;global:register_name/2&lt;/code&gt; . 이름이 제공되지 않으면 이벤트 관리자가 등록되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="145008a8fe8d11833ffba04465b46c305eac398a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={local,Name}&lt;/code&gt;, the event manager is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;EventMgrName={local,Name}&lt;/code&gt; , 이벤트 매니저는 로컬로 등록 된 &lt;code&gt;Name&lt;/code&gt; 사용 &lt;code&gt;register/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1d48cb710ca1d3e34d2637a454ccf4af2333759" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={via,Module,ViaName}&lt;/code&gt;, the event manager registers with the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback is to export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave as the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">경우 &lt;code&gt;EventMgrName={via,Module,ViaName}&lt;/code&gt; 레지스트리와 이벤트 관리자 레지스터에 의해 표현 &lt;code&gt;Module&lt;/code&gt; . &lt;code&gt;Module&lt;/code&gt; 콜백 함수 내보내이다 &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , &lt;code&gt;whereis_name/1&lt;/code&gt; , 및 &lt;code&gt;send/2&lt;/code&gt; 에 대응하는 기능으로 동작하도록하며, &lt;code&gt;global&lt;/code&gt; . 따라서 &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; 은 유효한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="9ad87f8334c21e8f203f8f813c8a18649ff573f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventType&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt;, the caller waits for a reply. The reply can be sent from this or from any other &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; by returning with &lt;code&gt;{reply,From,Reply}&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt;, in &lt;code&gt;&lt;a href=&quot;#type-reply_action&quot;&gt;Replies&lt;/a&gt;&lt;/code&gt;, or by calling &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply(From, Reply)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;EventType&lt;/code&gt; 있다 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; , 응답 전화를 건 기다립니다. 응답은 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#type-reply_action&quot;&gt;Replies&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;{reply,From,Reply}&lt;/code&gt; 로 반환 하거나 &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply(From, Reply)&lt;/a&gt;&lt;/code&gt; 호출 하여이 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 이나 다른 &lt;strong&gt;상태 콜백&lt;/strong&gt; 에서 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e635b8f737737ba5a05f0c993e3dfac9ac242c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventType&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt;, the caller waits for a reply. The reply can be sent from this or from any other &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; by returning with &lt;code&gt;{reply,From,Reply}&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt;, in &lt;code&gt;&lt;a href=&quot;#type-reply_action&quot;&gt;Replies&lt;/a&gt;&lt;/code&gt;, or by calling &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply(From, Reply)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;EventType&lt;/code&gt; 있다 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; , 응답 전화를 건 기다립니다. 회신이 또는 다른에서 보낼 수있는 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 으로 반환하여 &lt;code&gt;{reply,From,Reply}&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;#type-reply_action&quot;&gt;Replies&lt;/a&gt;&lt;/code&gt; 또는 호출하여 &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply(From, Reply)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83ef91cec4b18110476efaead7f796da1eca29a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Expr1&lt;/code&gt; evaluates to a name, but this name is not registered, a &lt;code&gt;badarg&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">경우 &lt;code&gt;Expr1&lt;/code&gt; 이름으로 평가하지만,이 이름이 등록되지 않은하는 &lt;code&gt;badarg&lt;/code&gt; 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="abad608745399cb2e4372968eab18b8ca631a3c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ExprF&lt;/code&gt; is an atom, the function is said to be called by using the &lt;strong&gt;implicitly qualified function name&lt;/strong&gt;. If the function &lt;code&gt;ExprF&lt;/code&gt; is locally defined, it is called. Alternatively, if &lt;code&gt;ExprF&lt;/code&gt; is explicitly imported from the &lt;code&gt;M&lt;/code&gt; module, &lt;code&gt;M:ExprF(Expr1,...,ExprN)&lt;/code&gt; is called. If &lt;code&gt;ExprF&lt;/code&gt; is neither declared locally nor explicitly imported, &lt;code&gt;ExprF&lt;/code&gt; must be the name of an automatically imported BIF.</source>
          <target state="translated">경우 &lt;code&gt;ExprF&lt;/code&gt; 가 원자이고, 함수는 사용하여 호출 할 수 있다고 &lt;strong&gt;암시 정규화 함수 이름&lt;/strong&gt; . &lt;code&gt;ExprF&lt;/code&gt; 함수 가 로컬로 정의 된 경우 호출됩니다. 또는 &lt;code&gt;M&lt;/code&gt; 모듈 에서 &lt;code&gt;ExprF&lt;/code&gt; 를 명시 적으로 가져 오는 경우 &lt;code&gt;M:ExprF(Expr1,...,ExprN)&lt;/code&gt; 이 호출됩니다. 경우 &lt;code&gt;ExprF&lt;/code&gt; 이 둘 로컬로 선언되지도 명시 적으로 가져, &lt;code&gt;ExprF&lt;/code&gt; 은 자동으로 수입 BIF의 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="292de33996b21603ce18c953090ce4d3bb28c1aa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;log&lt;/code&gt;, the matching events are allowed. If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;stop&lt;/code&gt;, the matching events are stopped.</source>
          <target state="translated">경우 &lt;code&gt;Extra&lt;/code&gt; IS는 &lt;code&gt;log&lt;/code&gt; , 일치하는 이벤트가 허용됩니다. 경우 &lt;code&gt;Extra&lt;/code&gt; 이다 &lt;code&gt;stop&lt;/code&gt; , 일치하는 이벤트가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="0c63a514bfa0d0eec024a84c5585b4db685eb8d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;log&lt;/code&gt;, the progress reports are allowed. If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;stop&lt;/code&gt;, the progress reports are stopped.</source>
          <target state="translated">경우 &lt;code&gt;Extra&lt;/code&gt; IS는 &lt;code&gt;log&lt;/code&gt; , 진행 보고서는 사용할 수 있습니다. 경우 &lt;code&gt;Extra&lt;/code&gt; 이다 &lt;code&gt;stop&lt;/code&gt; , 진행 보고서는 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="676697b8c810137bc5f3cbd3dba9cf47ed56934a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;P&lt;/code&gt;, or &lt;code&gt;Pad&lt;/code&gt; is a &lt;code&gt;*&lt;/code&gt; character, the next argument in &lt;code&gt;Data&lt;/code&gt; is used as the value. For example:</source>
          <target state="translated">경우 &lt;code&gt;F&lt;/code&gt; , &lt;code&gt;P&lt;/code&gt; , 또는 &lt;code&gt;Pad&lt;/code&gt; A는 &lt;code&gt;*&lt;/code&gt; 문자의 다음 인수 &lt;code&gt;Data&lt;/code&gt; 값으로 사용된다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="58d27e8ccd9fb7397c53540d079879af93136abc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FIPS_mode_set&lt;/code&gt; returns &lt;code&gt;no&lt;/code&gt; the OpenSSL library is not FIPS enabled and crypto won't support FIPS mode either.</source>
          <target state="translated">경우 &lt;code&gt;FIPS_mode_set&lt;/code&gt; 가 반환 &lt;code&gt;no&lt;/code&gt; 에는 OpenSSL 라이브러리를 사용할 수 없습니다 FIPS되지 않고 암호화 지원 모드 중 하나를 FIPS하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03e0cd5df5f6d73de87e5cdb82e5a381f90cc69f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is equal to the index set of &lt;code&gt;Family1&lt;/code&gt;, and &lt;code&gt;Family3&lt;/code&gt;[i] is the difference between &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i] if &lt;code&gt;Family2&lt;/code&gt; maps i, otherwise &lt;code&gt;Family1[i]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; 및 &lt;code&gt;Family2&lt;/code&gt; 가 있는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; 다음 &lt;code&gt;Family3&lt;/code&gt; 은 인덱스 세트의 인덱스 집합 같다고 가정 등이다 &lt;code&gt;Family1&lt;/code&gt; 및 &lt;code&gt;Family3&lt;/code&gt; 가 [I] 사이의 차이이다 &lt;code&gt;Family1&lt;/code&gt; [I] 및 &lt;code&gt;Family2&lt;/code&gt; [I] 경우 &lt;code&gt;Family2&lt;/code&gt; 는 달리, I 매핑 &lt;code&gt;Family1[i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="707694b53f4e6ff34f03b06100b8fc3bb1a63a00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is the intersection of &lt;code&gt;Family1&lt;/code&gt;:s and &lt;code&gt;Family2&lt;/code&gt;:s index sets, and &lt;code&gt;Family3&lt;/code&gt;[i] is the intersection of &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i].</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; 및 &lt;code&gt;Family2&lt;/code&gt; 가 있는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;Family3&lt;/code&gt; 는 인덱스 집합의 교집합 가족 등이다 &lt;code&gt;Family1&lt;/code&gt; : S 및 &lt;code&gt;Family2&lt;/code&gt; 의 인덱스 집합 및 : &lt;code&gt;Family3&lt;/code&gt; [I]가 교차로 인 &lt;code&gt;Family1&lt;/code&gt; [I] 및 &lt;code&gt;Family2&lt;/code&gt; [I].</target>
        </trans-unit>
        <trans-unit id="c3481789d9f11af86121200c69343c46693c383d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is the union of &lt;code&gt;Family1&lt;/code&gt;:s and &lt;code&gt;Family2&lt;/code&gt;:s index sets, and &lt;code&gt;Family3&lt;/code&gt;[i] is the union of &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i] if both map i, otherwise &lt;code&gt;Family1&lt;/code&gt;[i] or &lt;code&gt;Family2&lt;/code&gt;[i].</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; 및 &lt;code&gt;Family2&lt;/code&gt; 가 있는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; 다음 &lt;code&gt;Family3&lt;/code&gt; 은 인덱스 세트의 결합이라고 가정 등이다 &lt;code&gt;Family1&lt;/code&gt; S와 : &lt;code&gt;Family2&lt;/code&gt; 의 인덱스 집합 및 : &lt;code&gt;Family3&lt;/code&gt; 은 [I]는의 조합이다 &lt;code&gt;Family1&lt;/code&gt; [I] 및 &lt;code&gt;Family2&lt;/code&gt; [I] 만약 둘 다 맵 i, 그렇지 않으면 &lt;code&gt;Family1&lt;/code&gt; [i] 또는 &lt;code&gt;Family2&lt;/code&gt; [i].</target>
        </trans-unit>
        <trans-unit id="901cb0563eae4ae927b85e3235bb204abe3eeb2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#domain&quot;&gt;domain&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1[i]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; 는 A는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;Family1&lt;/code&gt; [I] 모든 I의 인덱스 세트에 대한 이진 관계이다 &lt;code&gt;Family1&lt;/code&gt; 다음 &lt;code&gt;Family2&lt;/code&gt; 은 동일한 인덱스 세트와 가족 &lt;code&gt;Family1&lt;/code&gt; 되도록 &lt;code&gt;Family2&lt;/code&gt; [I]는이다 &lt;code&gt;&lt;a href=&quot;#domain&quot;&gt;domain&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;Family1[i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10edd17f93cf8b662a14cd64ee029b216f69998c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#field&quot;&gt;field&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; 는 A는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;Family1&lt;/code&gt; [I] 모든 I의 인덱스 세트에 대한 이진 관계이다 &lt;code&gt;Family1&lt;/code&gt; 다음 &lt;code&gt;Family2&lt;/code&gt; 은 동일한 인덱스 세트와 가족 &lt;code&gt;Family1&lt;/code&gt; 되도록 &lt;code&gt;Family2&lt;/code&gt; [I]는이다 &lt;code&gt;&lt;a href=&quot;#field&quot;&gt;field&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;Family1&lt;/code&gt; 은 [I] .</target>
        </trans-unit>
        <trans-unit id="603f807d85acd930990c4dcffafa135bbe46960c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#range&quot;&gt;range&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; 는 A는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;Family1&lt;/code&gt; [I] 모든 I의 인덱스 세트에 대한 이진 관계이다 &lt;code&gt;Family1&lt;/code&gt; 다음 &lt;code&gt;Family2&lt;/code&gt; 은 동일한 인덱스 세트와 가족 &lt;code&gt;Family1&lt;/code&gt; 되도록 &lt;code&gt;Family2&lt;/code&gt; [I]는 인 &lt;code&gt;&lt;a href=&quot;#range&quot;&gt;range&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;Family1&lt;/code&gt; 은 [I] .</target>
        </trans-unit>
        <trans-unit id="df7eb7122ac171a82f2f5b7eabda31d098834629" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a set of sets for each i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#union_n&quot;&gt;union&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; 는 A는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;Family1&lt;/code&gt; [I]은 I의 인덱스 세트에서의 각각의 세트의 집합 &lt;code&gt;Family1&lt;/code&gt; 다음 &lt;code&gt;Family2&lt;/code&gt; 은 동일한 인덱스 세트와 가족 &lt;code&gt;Family1&lt;/code&gt; 되도록 &lt;code&gt;Family2&lt;/code&gt; [I]는 인 &lt;code&gt;&lt;a href=&quot;#union_n&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;Family1&lt;/code&gt; 는 [I ].</target>
        </trans-unit>
        <trans-unit id="9f6dbbe306d7fe1ab285e45f10bed30dc90b32b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a set of sets for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#intersection_n&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; 는 A는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;Family1&lt;/code&gt; [I] 모든 I의 인덱스 세트에 대한 세트의 집합 &lt;code&gt;Family1&lt;/code&gt; 는 다음 &lt;code&gt;Family2&lt;/code&gt; 은 동일한 인덱스 세트와 가족 &lt;code&gt;Family1&lt;/code&gt; 되도록 &lt;code&gt;Family2&lt;/code&gt; [I]는이다 &lt;code&gt;&lt;a href=&quot;#intersection_n&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;Family1&lt;/code&gt; [내가 ].</target>
        </trans-unit>
        <trans-unit id="6513fd3da5029f77ec7aae42fce09531984adc2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#restriction&quot;&gt;restriction&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt; to those elements i of the index set for which &lt;code&gt;Fun&lt;/code&gt; applied to &lt;code&gt;Family1&lt;/code&gt;[i] returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;Fun&lt;/code&gt; is a tuple &lt;code&gt;{external,&amp;nbsp;Fun2}&lt;/code&gt;, then &lt;code&gt;Fun2&lt;/code&gt; is applied to the &lt;code&gt;&lt;a href=&quot;#external_set&quot;&gt;external set&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i], otherwise &lt;code&gt;Fun&lt;/code&gt; is applied to &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; 는 A는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 다음 &lt;code&gt;Family2&lt;/code&gt; 은 은 IS &lt;code&gt;&lt;a href=&quot;#restriction&quot;&gt;restriction&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;Family1&lt;/code&gt; 하는 I 인덱스 집합의 해당 요소에 &lt;code&gt;Fun&lt;/code&gt; 인가 &lt;code&gt;Family1&lt;/code&gt; [I] 복귀 &lt;code&gt;true&lt;/code&gt; . 경우 &lt;code&gt;Fun&lt;/code&gt; 튜플 &lt;code&gt;{external,&amp;nbsp;Fun2}&lt;/code&gt; 다음 &lt;code&gt;Fun2&lt;/code&gt; 에가 에인가되는 &lt;code&gt;&lt;a href=&quot;#external_set&quot;&gt;external set&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;Family1&lt;/code&gt; [I], 그렇지 &lt;code&gt;Fun&lt;/code&gt; 에인가 &lt;code&gt;Family1&lt;/code&gt; [I].</target>
        </trans-unit>
        <trans-unit id="0036be6edcb9af44b23cf453b297b5ff3815e4ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the result of calling &lt;code&gt;SetFun&lt;/code&gt; with &lt;code&gt;Family1&lt;/code&gt;[i] as argument.</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; 는 A는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 다음 &lt;code&gt;Family2&lt;/code&gt; 은 동일한 인덱스 세트와 가족 &lt;code&gt;Family1&lt;/code&gt; 되도록 &lt;code&gt;Family2&lt;/code&gt; [I]이 호출의 결과 &lt;code&gt;SetFun&lt;/code&gt; 와 &lt;code&gt;Family1&lt;/code&gt; 인수 [I]가.</target>
        </trans-unit>
        <trans-unit id="a3ed4a237eeb2ac6e0edeeca8e08129966f3f00f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt;[i] is an empty set for some i, the process exits with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; [I]은 몇 가지 내가하는과 프로세스가 종료에 대해 빈 집합입니다 &lt;code&gt;badarg&lt;/code&gt; 의 메시지.</target>
        </trans-unit>
        <trans-unit id="15ab50a2f9b83c85c1bf92e12df53a14b6fa72a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;BinRel&lt;/code&gt; is the binary relation containing all pairs (i, x) such that i belongs to the index set of &lt;code&gt;Family&lt;/code&gt; and x belongs to &lt;code&gt;Family&lt;/code&gt;[i].</source>
          <target state="translated">경우 &lt;code&gt;Family&lt;/code&gt; A는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 다음 &lt;code&gt;BinRel&lt;/code&gt; 는 난의 인덱스 집합에 속하도록 모든 쌍 (I, X)를 함유하는 바이너리 관계이다 &lt;code&gt;Family&lt;/code&gt; 및 X에 속하는 &lt;code&gt;Family&lt;/code&gt; [I]가.</target>
        </trans-unit>
        <trans-unit id="8cca7739eb38698717638b6eb6af393def280970" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;File&lt;/code&gt; is not specified, a file dialog is opened where the crashdump can be selected.</source>
          <target state="translated">경우 &lt;code&gt;File&lt;/code&gt; 지정되지 않은 크래시 덤프를 선택 할 수있는, 파일 대화 상자가 열립니다.</target>
        </trans-unit>
        <trans-unit id="64e8f8682c5f33b6a09cda03b8458e6523b8dd31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileName&lt;/code&gt; cannot be run, an error exception is raised, with the POSIX error code as the reason. The error reason can differ between OSs. Typically the error &lt;code&gt;enoent&lt;/code&gt; is raised when an attempt is made to run a program that is not found and &lt;code&gt;eacces&lt;/code&gt; is raised when the specified file is not executable.</source>
          <target state="translated">&lt;code&gt;FileName&lt;/code&gt; 을 실행할 수없는 경우 POSIX 오류 코드를 이유로 오류 예외가 발생합니다. 오류 이유는 OS마다 다를 수 있습니다. 일반적으로 오류 &lt;code&gt;enoent&lt;/code&gt; 시도가 발견되지 않고 프로그램을 실행하려고 할 때 발생 &lt;code&gt;eacces&lt;/code&gt; 지정된 파일이 실행되지 않을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d64f4daf12cc430f6c5ecc07bc1247a82079bedd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileName&lt;/code&gt; has a suffix that indicates an object file (&lt;code&gt;.beam&lt;/code&gt;), EUnit will try to reload the module from the specified file and test it. Otherwise, the file is assumed to be a text file containing test specifications, which will be read using the standard library function &lt;code&gt;file:path_consult/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FileName&lt;/code&gt; 에 객체 파일 ( &lt;code&gt;.beam&lt;/code&gt; ) 을 나타내는 접미사가있는 경우 EUnit은 지정된 파일에서 모듈을 다시로드하여 테스트합니다. 그렇지 않은 경우, 파일은 테스트 라이브러리를 포함하는 텍스트 파일 인 것으로 간주되며 표준 라이브러리 함수 &lt;code&gt;file:path_consult/2&lt;/code&gt; 사용하여 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="f69d9680f0ea2ac6663d58bccc19bea7f9110950" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileNameOrIODev&lt;/code&gt; is a &lt;code&gt;string()&lt;/code&gt;, &lt;code&gt;make_config/1&lt;/code&gt; will use &lt;code&gt;FileNameOrIODev&lt;/code&gt; as a filename. A file named &lt;code&gt;FileNameOrIODev&lt;/code&gt; is created and the configuration will be written to that file. If &lt;code&gt;FileNameOrIODev&lt;/code&gt; is an &lt;code&gt;io_device()&lt;/code&gt; (see the documentation of the module &lt;code&gt;io&lt;/code&gt;), the configuration will be written to the io device.</source>
          <target state="translated">경우 &lt;code&gt;FileNameOrIODev&lt;/code&gt; 는 A는 &lt;code&gt;string()&lt;/code&gt; , &lt;code&gt;make_config/1&lt;/code&gt; 사용 &lt;code&gt;FileNameOrIODev&lt;/code&gt; 을 파일 이름으로. &lt;code&gt;FileNameOrIODev&lt;/code&gt; 라는 파일 이 작성되고 구성이 해당 파일에 작성됩니다. 경우 &lt;code&gt;FileNameOrIODev&lt;/code&gt; 가 이다 &lt;code&gt;io_device()&lt;/code&gt; (모듈의 참조 문서 &lt;code&gt;io&lt;/code&gt; 구성은 입출력 장치에 기록 될 것이다).</target>
        </trans-unit>
        <trans-unit id="abe7ea2e6f95f6e74b291e53017c69e3872b70e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Filename&lt;/code&gt; is not a symbolic link, this function returns exactly the same result as &lt;code&gt;read_file_info/1&lt;/code&gt;. On platforms that do not support symbolic links, this function is always equivalent to &lt;code&gt;read_file_info/1&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Filename&lt;/code&gt; 기호 링크, 바로이 함수가 반환 같은 결과하지 &lt;code&gt;read_file_info/1&lt;/code&gt; . 심볼릭 링크를 지원하지 않는 플랫폼에서이 기능은 항상 &lt;code&gt;read_file_info/1&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="abb890f105737b8f693a0a5c7d392809221b9ef6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fix&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, table &lt;code&gt;Name&lt;/code&gt; is fixed (once more) by the calling process, otherwise the table is released. The table is also released when a fixing process terminates.</source>
          <target state="translated">경우 &lt;code&gt;Fix&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 테이블 &lt;code&gt;Name&lt;/code&gt; , 그렇지 않으면 테이블이 출시, 호출 프로세스에 의해 (한 번 더) 고정됩니다. 고정 프로세스가 종료되면 테이블도 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="35e7f62cf2a411f7548edbc78f5bda5268f86881" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;get&lt;/code&gt;, a list of all logged events is returned.</source>
          <target state="translated">&lt;code&gt;Flag&lt;/code&gt; 가 &lt;code&gt;get&lt;/code&gt; 인 경우 , 기록 된 모든 이벤트 목록이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="381028fa2c7469ac85a20d5087b1b0fd8afdf82e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;print&lt;/code&gt;, the logged events are printed to &lt;code&gt;standard_io&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Flag&lt;/code&gt; 입니다 &lt;code&gt;print&lt;/code&gt; , 기록 된 이벤트가 인쇄됩니다 &lt;code&gt;standard_io&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b722fce5cc319fa08cae29348ebef98f92c444d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, a new subscription is started. If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, all previous subscriptions started with the same &lt;code&gt;Options&lt;/code&gt; are stopped. Two option lists are considered the same if they contain the same set of options.</source>
          <target state="translated">경우 &lt;code&gt;Flag&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , 새 구독이 시작됩니다. &lt;code&gt;Flag&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 동일한 &lt;code&gt;Options&lt;/code&gt; 시작된 모든 이전 구독 이 중지됩니다. 두 옵션 목록에 동일한 옵션 집합이 포함 된 경우 두 옵션 목록은 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7ca78e84b760984f52335bac15cc8a1e618b6c52" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flags = all&lt;/code&gt;, all possible flags are set.</source>
          <target state="translated">경우 &lt;code&gt;Flags = all&lt;/code&gt; , 모든 가능한 플래그가 셋 (Set)됩니다.</target>
        </trans-unit>
        <trans-unit id="2613d68b6d252e8fa327001ad657894c48452d47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;finish&lt;/code&gt;, pending input is processed, pending output is flushed, and &lt;code&gt;deflate/3&lt;/code&gt; returns. Afterwards the only possible operations on the stream are &lt;code&gt;&lt;a href=&quot;#deflateReset-1&quot;&gt;deflateReset/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#deflateEnd-1&quot;&gt;deflateEnd/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Flush&lt;/code&gt; 로 설정 &lt;code&gt;finish&lt;/code&gt; 보류 입력 보류 출력 플러시 처리, 및 &lt;code&gt;deflate/3&lt;/code&gt; 복귀한다. 이후 스트림에서 유일하게 가능한 조작은 &lt;code&gt;&lt;a href=&quot;#deflateReset-1&quot;&gt;deflateReset/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#deflateEnd-1&quot;&gt;deflateEnd/1&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9a28ee970d5c9d1771957ed2098a6a9bd614a23c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;full&lt;/code&gt;, all output is flushed as with &lt;code&gt;sync&lt;/code&gt;, and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if random access is desired. Using &lt;code&gt;full&lt;/code&gt; too often can seriously degrade the compression.</source>
          <target state="translated">&lt;code&gt;Flush&lt;/code&gt; 가 &lt;code&gt;full&lt;/code&gt; 로 설정 되면 &lt;code&gt;sync&lt;/code&gt; 와 같이 모든 출력이 플러시되고 이전 압축 데이터가 손상되었거나 임의 액세스가 필요한 경우 압축 해제 상태가이 지점부터 다시 시작될 수 있도록 압축 상태가 재설정됩니다. 사용하여 &lt;code&gt;full&lt;/code&gt; 너무 자주하는 것은 심각한 압축 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b162b87236f918abd12b2632484cedd86b7642d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;sync&lt;/code&gt;, all pending output is flushed to the output buffer and the output is aligned on a byte boundary, so that the decompressor can get all input data available so far. Flushing can degrade compression for some compression algorithms; thus, use it only when necessary.</source>
          <target state="translated">&lt;code&gt;Flush&lt;/code&gt; 가 &lt;code&gt;sync&lt;/code&gt; 로 설정 되면 보류중인 모든 출력이 출력 버퍼로 플러시되고 출력이 바이트 경계로 정렬되므로 압축 해제 기는 지금까지 사용 가능한 모든 입력 데이터를 얻을 수 있습니다. 플러싱은 일부 압축 알고리즘의 압축을 저하시킬 수 있습니다. 따라서 필요할 때만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3748c496d0aee0e31ef9623ffe6c9c459e673128" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Force = true&lt;/code&gt; then the agent will continue attempting to load each mib even after failing to load a previous mib. Use with care.</source>
          <target state="translated">&lt;code&gt;Force = true&lt;/code&gt; 경우 에이전트는 이전 mib를로드하지 못한 후에도 각 mib를 계속로드하려고 시도합니다. 주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2cad12b8139e1623aaeb8a5ccd722b61cea66f96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Force = true&lt;/code&gt; then the agent will continue attempting to unload each mib even after failing to unload a previous mib. Use with care.</source>
          <target state="translated">경우 &lt;code&gt;Force = true&lt;/code&gt; 다음 에이전트는 심지어 이전 MIB를 언로드 실패한 후 각 MIB을 언로드하려고 할 것입니다. 주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7d0a736a5ea9ae64f8bc28b164008b5e41f8db91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler = get_et_handler()&lt;/code&gt;, &lt;code&gt;et_viewer&lt;/code&gt; in application ET is used for presenting the trace log graphically. &lt;code&gt;ttb&lt;/code&gt; provides a few different filters that can be selected from menu &lt;strong&gt;Filters and scaling&lt;/strong&gt; in the &lt;code&gt;et_viewer&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;FormatHandler = get_et_handler()&lt;/code&gt; , &lt;code&gt;et_viewer&lt;/code&gt; 응용 프로그램 ET의 그래픽 추적 로그를 제시하는 데 사용됩니다. &lt;code&gt;ttb&lt;/code&gt; 메뉴에서 선택할 수있는 몇 가지 필터 제공 &lt;strong&gt;필터 및 확장&lt;/strong&gt; 에 &lt;code&gt;et_viewer&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="754c4ebe3c963dad574555e13a437f625208b390" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler = {Function,InitialState}&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt; is called for each trace message.</source>
          <target state="translated">경우 &lt;code&gt;FormatHandler = {Function,InitialState}&lt;/code&gt; , &lt;code&gt;Function&lt;/code&gt; 각 추적 메시지라고합니다.</target>
        </trans-unit>
        <trans-unit id="e464e53752a8478fcd48d7d7806a6c052a202fab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler&lt;/code&gt; is not specified, a default handler is used presenting each trace message as a text line.</source>
          <target state="translated">경우 &lt;code&gt;FormatHandler&lt;/code&gt; 가 지정되지 않은, 기본 핸들러는 텍스트 라인으로 각 추적 메시지를 제시 사용된다.</target>
        </trans-unit>
        <trans-unit id="52add321b909cb81e422136ee5da910496779dbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Forms&lt;/code&gt; is a syntax tree of some other type than &lt;code&gt;form_list&lt;/code&gt;, the comments will be inserted directly using &lt;code&gt;recomment_tree/2&lt;/code&gt;, and any comments left over from that process are added as postcomments on the result.</source>
          <target state="translated">경우 &lt;code&gt;Forms&lt;/code&gt; 이외에 다른 유형의 구문 트리입니다 &lt;code&gt;form_list&lt;/code&gt; 가 , 의견을 사용하여 직접 삽입됩니다 &lt;code&gt;recomment_tree/2&lt;/code&gt; 및 의견은 결과에 postcomments로 추가되는 과정에서 남은.</target>
        </trans-unit>
        <trans-unit id="c4eba9b5275105788875dd801e1636ad9a4cb30f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun(Item)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;Item&lt;/code&gt; is copied to the result queue. If it returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;Item&lt;/code&gt; is not copied. If it returns a list, the list elements are inserted instead of &lt;code&gt;Item&lt;/code&gt; in the result queue.</source>
          <target state="translated">경우 &lt;code&gt;Fun(Item)&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;Item&lt;/code&gt; 결과 큐에 복사됩니다. &lt;code&gt;false&lt;/code&gt; 를 반환 하면 &lt;code&gt;Item&lt;/code&gt; 이 복사되지 않습니다. 목록을 반환 하면 결과 큐 에 &lt;code&gt;Item&lt;/code&gt; 대신 목록 요소가 삽입 됩니다.</target>
        </trans-unit>
        <trans-unit id="366fc356581d7fe3b943ae954f2a4d6cf716ab8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is a local fun, &lt;code&gt;Module&lt;/code&gt; is the module in which the fun is defined.</source>
          <target state="translated">하면 &lt;code&gt;Fun&lt;/code&gt; 로컬 재미는, &lt;code&gt;Module&lt;/code&gt; 재미가 정의 된 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="1842cf53be67683035afaacc37fa7bea8be6bb1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is a local fun, &lt;code&gt;Name&lt;/code&gt; is the name of the local function that implements the fun. (This name was generated by the compiler, and is only of informational use. As it is a local function, it cannot be called directly.) If no code is currently loaded for the fun, &lt;code&gt;[]&lt;/code&gt; is returned instead of an atom.</source>
          <target state="translated">하면 &lt;code&gt;Fun&lt;/code&gt; 로컬 재미이고, &lt;code&gt;Name&lt;/code&gt; 로컬 기능을 구현하는 재미의 이름입니다. (이 이름은 컴파일러에 의해 생성되었으며 정보 용으로 만 사용됩니다. 로컬 함수이므로 직접 호출 할 수 없습니다.) 현재 재미를 위해로드 된 코드가 없으면 원자 대신 &lt;code&gt;[]&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5f28f2ecd1a2a78b09a1a1bba86bfe7cd1e5abac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is an external fun, &lt;code&gt;Module&lt;/code&gt; is the module that the fun refers to.</source>
          <target state="translated">하면 &lt;code&gt;Fun&lt;/code&gt; 외부 재미는, &lt;code&gt;Module&lt;/code&gt; 재미가 참조하는 모듈이다.</target>
        </trans-unit>
        <trans-unit id="7a891fa1f8c1fc67f4bfac48d75e87475a7bea29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is an external fun, &lt;code&gt;Name&lt;/code&gt; is the name of the exported function that the fun refers to.</source>
          <target state="translated">하면 &lt;code&gt;Fun&lt;/code&gt; 외부 재미이고, &lt;code&gt;Name&lt;/code&gt; 재미가 참조하는 내 보낸 함수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c30588de4c7f0612e073a3883c335ac9373ebde3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Function&lt;/code&gt; inserts objects into the table, or another process inserts objects into the table, those objects &lt;strong&gt;can&lt;/strong&gt; (depending on key ordering) be included in the traversal.</source>
          <target state="translated">경우 &lt;code&gt;Function&lt;/code&gt; 삽입이 테이블에 객체, 또는 다른 프로세스에 삽입이 테이블에 개체를 해당 개체 &lt;strong&gt;수&lt;/strong&gt; (키 순서에 따라)가 통과에 포함.</target>
        </trans-unit>
        <trans-unit id="8903d3c31d338fd3102b10a98c169c7def053e70" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;HandlerId&lt;/code&gt; is &lt;code&gt;default&lt;/code&gt;, then this entry modifies the default handler, equivalent to calling</source>
          <target state="translated">경우 &lt;code&gt;HandlerId&lt;/code&gt; 입니다 &lt;code&gt;default&lt;/code&gt; 호출하는 것과,이 항목의 수정 기본 핸들러,</target>
        </trans-unit>
        <trans-unit id="900d11629569ab220c3331823293a0c6bc8ed798" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;How == read&lt;/code&gt; or there is no outgoing data buffered in the &lt;code&gt;Socket&lt;/code&gt; port, the socket is shut down immediately and any error encountered is returned in &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;How == read&lt;/code&gt; 나에 버퍼링 더 나가는 데이터가없는 &lt;code&gt;Socket&lt;/code&gt; 포트 소켓이 즉시 종료 및 발견 된 모든 오류가 반환됩니다 &lt;code&gt;Reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c71e7f1f85187ddc4b81962dde74a95d9e96b0d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;How&lt;/code&gt; is not one of the documented alternatives.</source>
          <target state="translated">경우 &lt;code&gt;How&lt;/code&gt; 문서화 된 대안 중 하나가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="37742d0df7de57a88343a93bbae5c582e200b4bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;I&lt;/code&gt; is not a non-negative integer, or if the array has fixed size and &lt;code&gt;I&lt;/code&gt; is larger than the maximum index, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;; compare &lt;code&gt;&lt;a href=&quot;#set-3&quot;&gt;set/3&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;I&lt;/code&gt; 는 음이 아닌 정수가 아니거나 배열 크기를 고정하고있는 경우 &lt;code&gt;I&lt;/code&gt; 가 최대 인덱스보다 큰 경우, 호출 실패 원인 &lt;code&gt;badarg&lt;/code&gt; ; &lt;code&gt;&lt;a href=&quot;#set-3&quot;&gt;set/3&lt;/a&gt;&lt;/code&gt; 비교</target>
        </trans-unit>
        <trans-unit id="b40958d947f1e3e1dfb64d8ec37bb529fd8c2ab3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IV = &amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;, no IV is used. This is intended for ciphers without an IV (nounce). See &lt;code&gt;&lt;a href=&quot;#crypto_init-3&quot;&gt;crypto_init/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;IV = &amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; , IV가 더 사용되지 않는다. 이것은 IV (nounce)가없는 암호를위한 것입니다. &lt;code&gt;&lt;a href=&quot;#crypto_init-3&quot;&gt;crypto_init/3&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="17757dd0369fed1b521cdc06c576ee0641e25d48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IV = undefined&lt;/code&gt;, the IV must be added by calls to &lt;code&gt;&lt;a href=&quot;crypto#crypto_dyn_iv_update-3&quot;&gt;crypto_dyn_iv_update/3&lt;/a&gt;&lt;/code&gt;. This is intended for cases where the IV (nounce) need to be changed for each encryption and decryption. See &lt;code&gt;&lt;a href=&quot;#crypto_dyn_iv_init-3&quot;&gt;crypto_dyn_iv_init/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;IV = undefined&lt;/code&gt; 의 IV는 호출하여 추가해야 &lt;code&gt;&lt;a href=&quot;crypto#crypto_dyn_iv_update-3&quot;&gt;crypto_dyn_iv_update/3&lt;/a&gt;&lt;/code&gt; . 이는 각 암호화 및 복호화에 대해 IV (nounce)를 변경해야하는 경우를위한 것입니다. &lt;code&gt;&lt;a href=&quot;#crypto_dyn_iv_init-3&quot;&gt;crypto_dyn_iv_init/3&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="192de0c6fdc2dc6ed90c9948b113d350638c9ee6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IgnoreCase&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; the function does &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt; casefolding&lt;/a&gt;&lt;/code&gt; on the fly before the equality test.</source>
          <target state="translated">경우 &lt;code&gt;IgnoreCase&lt;/code&gt; 를이 입니다 &lt;code&gt;true&lt;/code&gt; 함수는 않습니다 &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt; casefolding&lt;/a&gt;&lt;/code&gt; 평등 시험 전에 즉시.</target>
        </trans-unit>
        <trans-unit id="ff9833c3a956d76bfddbabd05552d4c92a4ea96e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IgnoreCase&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; the function does &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefolding&lt;/a&gt;&lt;/code&gt; on the fly before the equality test.</source>
          <target state="translated">경우 &lt;code&gt;IgnoreCase&lt;/code&gt; 를이 입니다 &lt;code&gt;true&lt;/code&gt; 함수는 않습니다 &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefolding&lt;/a&gt;&lt;/code&gt; 평등 시험 전에 즉시.</target>
        </trans-unit>
        <trans-unit id="816e7270d9b2f0ac993fa2ef79b1a16b6e25ce74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, an error occurs whenever an integer &amp;gt; 255 is found in the lists.</source>
          <target state="translated">경우 &lt;code&gt;InEncoding&lt;/code&gt; 가 인 &lt;code&gt;latin1&lt;/code&gt; 정수&amp;gt; 255 목록에서 발견 될 때마다, 오류가 발생한다.</target>
        </trans-unit>
        <trans-unit id="4425120ccc2526ec06a49a423343d05e8207c756" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, binaries are always valid as long as they contain whole bytes, as each byte falls into the valid ISO Latin-1 range.</source>
          <target state="translated">&lt;code&gt;InEncoding&lt;/code&gt; 이 &lt;code&gt;latin1&lt;/code&gt; 인 경우 각 바이트가 유효한 ISO Latin-1 범위에 속하므로 바이너리는 전체 바이트를 포함하는 한 항상 유효합니다.</target>
        </trans-unit>
        <trans-unit id="ff1d0ed37f6966c578d637dcaf03e020ca40d09f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, parameter &lt;code&gt;Data&lt;/code&gt; corresponds to the &lt;code&gt;iodata()&lt;/code&gt; type, but for &lt;code&gt;unicode&lt;/code&gt;, parameter &lt;code&gt;Data&lt;/code&gt; can contain integers &amp;gt; 255 (Unicode characters beyond the ISO Latin-1 range), which makes it invalid as &lt;code&gt;iodata()&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;InEncoding&lt;/code&gt; 가 인 &lt;code&gt;latin1&lt;/code&gt; 파라미터 &lt;code&gt;Data&lt;/code&gt; 에 해당합니다 &lt;code&gt;iodata()&lt;/code&gt; 형이지만위한 &lt;code&gt;unicode&lt;/code&gt; 파라미터 &lt;code&gt;Data&lt;/code&gt; 정수&amp;gt; 255 (는 ISO 라틴 1 벗어난 유니 코드 문자)를 포함 할 수 있으며,이 무효하게되는 &lt;code&gt;iodata()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84c8391d802fddc5ccbafb2a99174fde559e23a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is of a Unicode type, an error occurs whenever either of the following is found:</source>
          <target state="translated">경우 &lt;code&gt;InEncoding&lt;/code&gt; 는 유니 코드 유형 인 다음 중 하나가 발견 될 때마다 오류가 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="476e00e23216a072f0d4f2055cfb67b48c128bef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is one of the UTF types, the bytes in any binaries must be valid in that encoding.</source>
          <target state="translated">경우 &lt;code&gt;InEncoding&lt;/code&gt; 이 가 UTF 유형 중 하나입니다, 어떤 바이너리 바이트는 인코딩 유효해야합니다.</target>
        </trans-unit>
        <trans-unit id="22f3829c6bb886763ec35ffd0a67a42f39f5713e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Incr =:= 0&lt;/code&gt; and &lt;code&gt;From =/= To&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;Incr =:= 0&lt;/code&gt; 및 &lt;code&gt;From =/= To&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12b35d113bc1f0b8b177b00f244bbbf3e4ac06f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IpPort&lt;/code&gt; is omitted &lt;code&gt;162&lt;/code&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;IpPort&lt;/code&gt; 은 생략한다 &lt;code&gt;162&lt;/code&gt; 사용한다.</target>
        </trans-unit>
        <trans-unit id="57bfc33f769c9b0a788a08b107a1cedbd213bce1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IsDst == true&lt;/code&gt;, &lt;code&gt;Localtime&lt;/code&gt; is during Daylight Saving Time, if &lt;code&gt;IsDst == false&lt;/code&gt; it is not. If &lt;code&gt;IsDst == undefined&lt;/code&gt;, the underlying OS can guess, which is the same as calling &lt;code&gt;erlang:localtime_to_universaltime(Localtime)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;IsDst == true&lt;/code&gt; , &lt;code&gt;Localtime&lt;/code&gt; 일광 절약 시간 동안이며, 경우 &lt;code&gt;IsDst == false&lt;/code&gt; 이 아니다. 경우 &lt;code&gt;IsDst == undefined&lt;/code&gt; , 기본 OS는 호출과 같은 어떤 추측 할 &lt;code&gt;erlang:localtime_to_universaltime(Localtime)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1d88ab1af3b32ccae8c47bc290fd76139417148" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Item&lt;/code&gt; is an invalid item.</source>
          <target state="translated">&lt;code&gt;Item&lt;/code&gt; 이 잘못된 항목 인 경우</target>
        </trans-unit>
        <trans-unit id="0ff6e5e0312fb6570b28f21e065635f71bd160e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ItemList&lt;/code&gt; is specified, the result is &lt;code&gt;InfoTupleList&lt;/code&gt;. The &lt;code&gt;InfoTuple&lt;/code&gt;s in &lt;code&gt;InfoTupleList&lt;/code&gt; are included with the corresponding &lt;code&gt;Item&lt;/code&gt;s in the same order as the &lt;code&gt;Item&lt;/code&gt;s were included in &lt;code&gt;ItemList&lt;/code&gt;. Valid &lt;code&gt;Item&lt;/code&gt;s can be included multiple times in &lt;code&gt;ItemList&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;ItemList&lt;/code&gt; 지정되면, 결과는 &lt;code&gt;InfoTupleList&lt;/code&gt; . &lt;code&gt;InfoTuple&lt;/code&gt; 에서의 &lt;code&gt;InfoTupleList&lt;/code&gt; 는 대응 포함 된 &lt;code&gt;Item&lt;/code&gt; 은 AS 동일한 순서의 &lt;code&gt;Item&lt;/code&gt; 에 포함 된 S &lt;code&gt;ItemList&lt;/code&gt; . 유효한 &lt;code&gt;Item&lt;/code&gt; 은 &lt;code&gt;ItemList&lt;/code&gt; 에 여러 번 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af422b91ec82e2dd9338132983b67650395edbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Key&lt;/code&gt; do not exists, a new record is created with value &lt;code&gt;Incr&lt;/code&gt; if it is larger than 0, otherwise it is set to 0.</source>
          <target state="translated">경우 &lt;code&gt;Key&lt;/code&gt; 하지 존재하지, 새로운 기록이 값으로 생성됩니다 &lt;code&gt;Incr&lt;/code&gt; 이 0보다 큰 경우, 그렇지 않으면 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c41410c8bc0b6250bb7c2a4f58129afe15bfcff0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Key&lt;/code&gt; does not exist, a new record is created with value &lt;code&gt;Incr&lt;/code&gt; if it is larger than 0, otherwise it is set to 0.</source>
          <target state="translated">경우 &lt;code&gt;Key&lt;/code&gt; 존재하지 않는, 새로운 기록이 값으로 생성됩니다 &lt;code&gt;Incr&lt;/code&gt; 이 0보다 큰 경우, 그렇지 않으면 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6283720a87b385d954928cf8467ee97a261a260e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Key&lt;/code&gt; exists in &lt;code&gt;Map1&lt;/code&gt;, the old associated value is replaced by value &lt;code&gt;Value&lt;/code&gt;. The function returns a new map &lt;code&gt;Map2&lt;/code&gt; containing the new associated value.</source>
          <target state="translated">경우 &lt;code&gt;Key&lt;/code&gt; 존재 &lt;code&gt;Map1&lt;/code&gt; 이전 관련 값은 값으로 대체됩니다 &lt;code&gt;Value&lt;/code&gt; . 이 함수는 새로운 관련 값이 포함 된 새 맵 &lt;code&gt;Map2&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1dc230226eb63b450b632e9c874a80bd2fe8c24b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;KeyOrName&lt;/code&gt; is a configured &lt;code&gt;server_id()&lt;/code&gt; or a &lt;code&gt;target_name()&lt;/code&gt; associated with such an Id, then the options for this server are fetched from the configuration file.</source>
          <target state="translated">경우 &lt;code&gt;KeyOrName&lt;/code&gt; 가 구성된 것이다 &lt;code&gt;server_id()&lt;/code&gt; 또는 &lt;code&gt;target_name()&lt;/code&gt; 와 같은 ID와 연관된가,이 서버에 대한 옵션은 구성 파일로부터 페치된다.</target>
        </trans-unit>
        <trans-unit id="caeb4bb064b11f2b7bb8eeb778050c5ea54186c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LinkTo&lt;/code&gt; is a pid, it becomes an owner of the log. If &lt;code&gt;LinkTo&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;, the log records that it is used anonymously by some process by incrementing the &lt;code&gt;users&lt;/code&gt; counter. By default, the process that calls &lt;code&gt;open/1&lt;/code&gt; owns the log.</source>
          <target state="translated">경우 &lt;code&gt;LinkTo&lt;/code&gt; PID를이, 그것은 로그의 소유자가됩니다. 경우 &lt;code&gt;LinkTo&lt;/code&gt; 없는 &lt;code&gt;none&lt;/code&gt; ,가 증가하여 일부 프로세스에 의해 익명으로 사용하는 로그 레코드 &lt;code&gt;users&lt;/code&gt; 카운터. 기본적으로 &lt;code&gt;open/1&lt;/code&gt; 을 호출하는 프로세스 는 로그를 소유합니다.</target>
        </trans-unit>
        <trans-unit id="9888882ab2a6e6b491af7cf81626c46b51b8c093" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ListOfBinRels&lt;/code&gt; is a non-empty list [R[1], ..., R[n]] of binary relations and &lt;code&gt;BinRel1&lt;/code&gt; is a binary relation, then &lt;code&gt;BinRel2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#tuple_relative_product&quot;&gt;relative product&lt;/a&gt;&lt;/code&gt; of the ordered set (R[i], ..., R[n]) and &lt;code&gt;BinRel1&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;ListOfBinRels&lt;/code&gt; 가 비어 목록 [R [1], ..., R [N] 이진 관계의 &lt;code&gt;BinRel1&lt;/code&gt; 는 이진 관계이다 후 &lt;code&gt;BinRel2&lt;/code&gt; 이 는 IS &lt;code&gt;&lt;a href=&quot;#tuple_relative_product&quot;&gt;relative product&lt;/a&gt;&lt;/code&gt; [I] 순서화 세트 (R의이. .., R [n]) 및 &lt;code&gt;BinRel1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6668fcef53284c1666f849594130ecb9a9e9189" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Loader&lt;/code&gt; is something else, the user-supplied &lt;code&gt;Loader&lt;/code&gt; port program is started.</source>
          <target state="translated">&lt;code&gt;Loader&lt;/code&gt; 가 다른 것이라면 , 사용자 제공 &lt;code&gt;Loader&lt;/code&gt; 포트 프로그램이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="4902233d819e3e7d17b192cdb14eea6c3a8ffc0d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a binary, &lt;code&gt;tftp_binary&lt;/code&gt; is used as callback module. The binary is transferred block by block and the number of transferred bytes is returned in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;LocalFilename&lt;/code&gt; 은 바이너리이며, &lt;code&gt;tftp_binary&lt;/code&gt; 는 콜백 모듈로 사용된다. 이진은 블록 단위로 전송되며 전송 된 바이트 수는 &lt;code&gt;LastCallbackState&lt;/code&gt; 에 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="514092af0b1076e970f978d5d6c41dea98a0f33d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are no registered callback modules, &lt;code&gt;tftp_file&lt;/code&gt; is used as callback module. It reads the file named &lt;code&gt;LocalFilename&lt;/code&gt; block by block and returns the number of transferred bytes in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;LocalFilename&lt;/code&gt; 는 문자열이며, 등록 된 콜백 모듈이없는, &lt;code&gt;tftp_file&lt;/code&gt; 는 콜백 모듈로서 사용된다. &lt;code&gt;LocalFilename&lt;/code&gt; 이라는 파일을 블록별로 읽고 &lt;code&gt;LastCallbackState&lt;/code&gt; 에서 전송 된 바이트 수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="172a77adcec95a2025499b6cae24513646d7c3be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are no registered callback modules, &lt;code&gt;tftp_file&lt;/code&gt; is used as callback module. It writes each transferred block to the file named &lt;code&gt;LocalFilename&lt;/code&gt; and returns the number of transferred bytes in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;LocalFilename&lt;/code&gt; 는 문자열이며, 등록 된 콜백 모듈이없는, &lt;code&gt;tftp_file&lt;/code&gt; 는 콜백 모듈로서 사용된다. 전송 된 각 블록을 &lt;code&gt;LocalFilename&lt;/code&gt; 파일 에 &lt;code&gt;LastCallbackState&lt;/code&gt; 에서 전송 된 바이트 수를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="fd17776ebe8291ef5b56762e6914f21f0e371fb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are registered callback modules, &lt;code&gt;LocalFilename&lt;/code&gt; is tested against the regexps of these and the callback module corresponding to the first match is used, or an error tuple is returned if no matching regexp is found.</source>
          <target state="translated">경우 &lt;code&gt;LocalFilename&lt;/code&gt; 이 문자열이 등록 된 콜백 모듈이 있으며, &lt;code&gt;LocalFilename&lt;/code&gt; 는 이들 및 제 매치에 대응하는 콜백 모듈 regexps '에 대해 테스트되어 사용되거나 일치하는 정규 표현식이 발견되지 않는 경우 오류 튜플이 반환된다.</target>
        </trans-unit>
        <trans-unit id="e10f4bb7329e24a46f5a2fd1d389f1d3eaa1ef41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is the atom &lt;code&gt;binary&lt;/code&gt;, &lt;code&gt;tftp_binary&lt;/code&gt; is used as callback module. It concatenates all transferred blocks and returns them as one single binary in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;LocalFilename&lt;/code&gt; 는 원자 인 &lt;code&gt;binary&lt;/code&gt; , &lt;code&gt;tftp_binary&lt;/code&gt; 는 콜백 모듈로서 사용된다. 전송 된 모든 블록을 연결하고 &lt;code&gt;LastCallbackState&lt;/code&gt; 에서 단일 바이너리로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="29f45f2e11d4c10074cfecd5aefc75c9eeb1e623" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;M&lt;/code&gt; is not of type map, an exception of type &lt;code&gt;badmap&lt;/code&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; 이 map 유형이 아닌 경우 , &lt;code&gt;badmap&lt;/code&gt; 유형의 예외 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="687a37c16da4f8deeaf271a8bf79963858a6f256" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MaxUsed &amp;lt; MinUsed&lt;/code&gt; in a key exchange, it will fail with a disconnect.</source>
          <target state="translated">키 교환에서 &lt;code&gt;MaxUsed &amp;lt; MinUsed&lt;/code&gt; 이면 연결 끊김으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="7c02225a551052905fddcfce82626e17b4c75202" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Message&lt;/code&gt; does not correspond to the response, the atom &lt;code&gt;no_response&lt;/code&gt; is returned. If &lt;code&gt;Message&lt;/code&gt; corresponds to the response, the &lt;code&gt;call&lt;/code&gt; operation is completed and either the result is returned as &lt;code&gt;{response, Result}&lt;/code&gt; where &lt;code&gt;Result&lt;/code&gt; corresponds to the value returned from the applied function or an exception is raised. The exceptions that can be raised corresponds to the same exceptions as can be raised by &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;erpc:call/4&lt;/a&gt;&lt;/code&gt;. That is, no &lt;code&gt;{erpc, timeout}&lt;/code&gt;&lt;code&gt;error&lt;/code&gt; exception can be raised. &lt;code&gt;erpc:check_response()&lt;/code&gt; will fail with an &lt;code&gt;{erpc, badarg}&lt;/code&gt; exception if/when an invalid &lt;code&gt;RequestId&lt;/code&gt; is detected.</source>
          <target state="translated">경우 &lt;code&gt;Message&lt;/code&gt; 응답에 해당하지 않는, 원자 &lt;code&gt;no_response&lt;/code&gt; 반환됩니다. 경우 &lt;code&gt;Message&lt;/code&gt; 의 응답에 대응하는 상기 &lt;code&gt;call&lt;/code&gt; 동작이 완료되고, 하나 결과가 반환된다 &lt;code&gt;{response, Result}&lt;/code&gt; 어디에 &lt;code&gt;Result&lt;/code&gt; 인가 함수 또는 예외로부터 반환 된 값에 대응이 상승한다. 발생할 수있는 예외는 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;erpc:call/4&lt;/a&gt;&lt;/code&gt; 에서 발생할 수있는 것과 동일한 예외에 해당합니다 . 즉, &lt;code&gt;{erpc, timeout}&lt;/code&gt; &lt;code&gt;error&lt;/code&gt; 예외가 발생할 수 없습니다. &lt;code&gt;erpc:check_response()&lt;/code&gt; 가 &lt;code&gt;{erpc, badarg}&lt;/code&gt; 예외 와 함께 실패 합니다. &lt;code&gt;RequestId&lt;/code&gt; 가 감지되었습니다.</target>
        </trans-unit>
        <trans-unit id="fec574cad80dd815a39ff074fa450bce09ec6bf3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Minutes&lt;/code&gt; is set to &lt;code&gt;infinity&lt;/code&gt;, no rekeying will ever occur due to that max time has passed. Setting &lt;code&gt;Bytes&lt;/code&gt; to &lt;code&gt;infinity&lt;/code&gt; will inhibit rekeying after a certain amount of data has been transferred. If the option value is set to &lt;code&gt;{infinity, infinity}&lt;/code&gt;, no rekeying will be initiated. Note that rekeying initiated by the peer will still be performed.</source>
          <target state="translated">&lt;code&gt;Minutes&lt;/code&gt; 가 &lt;code&gt;infinity&lt;/code&gt; 로 설정 되면 최대 시간이 지났기 때문에 다시 키잉이 발생하지 않습니다. &lt;code&gt;Bytes&lt;/code&gt; 를 &lt;code&gt;infinity&lt;/code&gt; 설정 하면 특정 양의 데이터가 전송 된 후 키 재 지정이 금지됩니다. 옵션 값이 &lt;code&gt;{infinity, infinity}&lt;/code&gt; 되면 키 변경이 시작되지 않습니다. 피어가 시작한 키 다시 입력은 여전히 ​​수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a9f8b097c0197afbf6ad454085a81f83c68dd174" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects an inconsistent transaction decision, an &lt;code&gt;{inconsistent_database, bad_decision, Node}&lt;/code&gt; system event is generated to give the application a chance to install a fallback or other appropriate measures to resolve the inconsistency. The default behavior of the &lt;code&gt;Mnesia&lt;/code&gt; event handler is the same as if the database became inconsistent as a result of partitioned network (as described earlier).</source>
          <target state="translated">경우 &lt;code&gt;Mnesia&lt;/code&gt; 가 일치하지 않는 트랜잭션 결정 감지 &lt;code&gt;{inconsistent_database, bad_decision, Node}&lt;/code&gt; 시스템 이벤트는 응용 프로그램을 대체 또는 불일치를 해결하기위한 다른 적절한 조치를 설치할 수있는 기회를 제공하기 위해 생성된다. &lt;code&gt;Mnesia&lt;/code&gt; 이벤트 핸들러 의 기본 동작은 앞에서 설명한대로 파티션 된 네트워크의 결과로 데이터베이스가 일치하지 않는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ca626a4154bdde85262a0b351b9ffb8e56064dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects at startup that both the local node and another node received &lt;code&gt;mnesia_down&lt;/code&gt; from each other, &lt;code&gt;Mnesia&lt;/code&gt; generates an &lt;code&gt;{inconsistent_database, starting_partitioned_network, Node}&lt;/code&gt; system event and acts as described in the previous item.</source>
          <target state="translated">경우 &lt;code&gt;Mnesia&lt;/code&gt; 는 로컬 노드와 다른 노드 모두받은 시작할 검출 &lt;code&gt;mnesia_down&lt;/code&gt; 서로, &lt;code&gt;Mnesia&lt;/code&gt; 는 생성 &lt;code&gt;{inconsistent_database, starting_partitioned_network, Node}&lt;/code&gt; 시스템 이벤트를 이전에 기재된 바와 같이 작용한다.</target>
        </trans-unit>
        <trans-unit id="8a5aa5b6bb0338ccad2dd9a24afe157f5c87240b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects that a file has not been properly closed, possibly as a result of a power failure, it tries to repair the bad file in a similar manner. Data can be lost, but &lt;code&gt;Mnesia&lt;/code&gt; can be restarted even if the data is inconsistent. Configuration parameter &lt;code&gt;-mnesia auto_repair &amp;lt;bool&amp;gt;&lt;/code&gt; can be used to control the behavior of &lt;code&gt;Mnesia&lt;/code&gt; at startup. If &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; has the value &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;Mnesia&lt;/code&gt; tries to repair the file. If &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; has the value &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;Mnesia&lt;/code&gt; does not restart if it detects a suspect file. This configuration parameter affects the repair behavior of log files, &lt;code&gt;DAT&lt;/code&gt; files, and the default backup media.</source>
          <target state="translated">경우 &lt;code&gt;Mnesia&lt;/code&gt; 이 파일이 제대로 가능성이 정전의 결과로 폐쇄되지 않았 음을 감지, 그것은 유사한 방식으로 나쁜 파일을 복구하려고합니다. 데이터가 손실 될 수 있지만 데이터가 일치하지 않더라도 &lt;code&gt;Mnesia&lt;/code&gt; 를 다시 시작할 수 있습니다. 구성 매개 변수 &lt;code&gt;-mnesia auto_repair &amp;lt;bool&amp;gt;&lt;/code&gt; 을 사용하여 시작시 &lt;code&gt;Mnesia&lt;/code&gt; 의 동작을 제어 할 수 있습니다 . 경우 &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; 값이 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;Mnesia&lt;/code&gt; 은 파일을 복구하려고 시도합니다. 경우 &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; 값이 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;Mnesia&lt;/code&gt; 은 이 용의자 파일을 감지하면 다시 시작하지 않습니다. 이 구성 매개 변수는 로그 파일 &lt;code&gt;DAT&lt;/code&gt; 의 복구 동작에 영향을줍니다. 파일 및 기본 백업 미디어.</target>
        </trans-unit>
        <trans-unit id="29d3fae27e18aeedb269f53e1a8f041e114e54d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; has not started on some of the nodes that are involved in the transaction &lt;strong&gt;and&lt;/strong&gt; neither the local node nor any of the already running nodes know the outcome of the transaction, &lt;code&gt;Mnesia&lt;/code&gt; waits for one, by default. In the worst case scenario, all other involved nodes must start before &lt;code&gt;Mnesia&lt;/code&gt; can make the correct decision about the transaction and finish its startup.</source>
          <target state="translated">경우 &lt;code&gt;Mnesia&lt;/code&gt; 이 거래에 참여하는 일부 노드에서 시작되지 &lt;strong&gt;및&lt;/strong&gt; 로컬 노드 나 이미 실행중인 노드 중 어느 것도 트랜잭션의 결과를 알고, &lt;code&gt;Mnesia&lt;/code&gt; 은 기본적으로 일을 기다립니다. 최악의 시나리오에서는 &lt;code&gt;Mnesia&lt;/code&gt; 가 트랜잭션에 대한 올바른 결정을 내리고 시작을 완료 하기 전에 다른 모든 관련 노드를 시작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dd38ec2de0e096904bd79c96261fe3dfca545808" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; malfunctions, system information is dumped to file &lt;code&gt;MnesiaCore.Node.When&lt;/code&gt;. The type of system information contained in this file can also be generated with the function &lt;code&gt;mnesia_lib:coredump()&lt;/code&gt;. If a &lt;code&gt;Mnesia&lt;/code&gt; system behaves strangely, it is recommended that a &lt;code&gt;Mnesia&lt;/code&gt; core dump file is included in the bug report.</source>
          <target state="translated">경우 &lt;code&gt;Mnesia&lt;/code&gt; 의 고장, 시스템 정보를 파일로 덤프됩니다 &lt;code&gt;MnesiaCore.Node.When&lt;/code&gt; 을 . 이 파일에 포함 된 시스템 정보 유형은 &lt;code&gt;mnesia_lib:coredump()&lt;/code&gt; 함수를 사용하여 생성 할 수도 있습니다 . 경우 &lt;code&gt;Mnesia&lt;/code&gt; 의 시스템이 이상하게 작동,하는 것이 좋습니다 &lt;code&gt;Mnesia&lt;/code&gt; 코어 덤프 파일이 버그 리포트에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="78d126042be1f1bd5d152bedd102bc2c27a70a3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module2:init/1&lt;/code&gt; returns a correct value, this function returns &lt;code&gt;ok&lt;/code&gt;. If &lt;code&gt;Module2:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt; or returns an unexpected value &lt;code&gt;Term&lt;/code&gt;, this function returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively.</source>
          <target state="translated">만약 &lt;code&gt;Module2:init/1&lt;/code&gt; 반환 올바른 값이 함수의 반환 &lt;code&gt;ok&lt;/code&gt; . 경우 &lt;code&gt;Module2:init/1&lt;/code&gt; 실패 &lt;code&gt;Reason&lt;/code&gt; 또는 리턴 값 예기치 &lt;code&gt;Term&lt;/code&gt; 이 함수 리턴 &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; 또는 &lt;code&gt;{error,Term}&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="2800f17b5a7a3294a30bce9d692cce033e777bbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails or returns an error tuple or an incorrect value, this function returns &lt;code&gt;{error,Errorr}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is a term with information about the error, and the supervisor bridge terminates with reason &lt;code&gt;Error&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Module:init/1&lt;/code&gt; 실패하거나 반환 오류 튜플 또는 잘못된 값이 함수가 반환 &lt;code&gt;{error,Errorr}&lt;/code&gt; , &lt;code&gt;Error&lt;/code&gt; 오류에 대한 정보와 용어이며, 이유와 감독자 브리지 종료 &lt;code&gt;Error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd9e3be966d4953b313f0b3139d9921bb88d0b55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails or returns an incorrect value, this function returns &lt;code&gt;{error,Term}&lt;/code&gt;, where &lt;code&gt;Term&lt;/code&gt; is a term with information about the error, and the supervisor terminates with reason &lt;code&gt;Term&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Module:init/1&lt;/code&gt; 잘못된 값이 함수가 반환 실패하거나 반환 &lt;code&gt;{error,Term}&lt;/code&gt; , &lt;code&gt;Term&lt;/code&gt; 오류에 대한 정보와 용어이며, 이유와 감독자 종료 &lt;code&gt;Term&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06a79b06d12276baeba24803b1a67f3a90f7af4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt;, the function returns &lt;code&gt;{error,Reason}&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;{stop,Reason}&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;, the process is terminated and the function returns &lt;code&gt;{error,Reason}&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;, respectively.</source>
          <target state="translated">만약 &lt;code&gt;Module:init/1&lt;/code&gt; 실패 &lt;code&gt;Reason&lt;/code&gt; , 함수가 반환 &lt;code&gt;{error,Reason}&lt;/code&gt; . 경우 &lt;code&gt;Module:init/1&lt;/code&gt; 복귀 &lt;code&gt;{stop,Reason}&lt;/code&gt; 또는 &lt;code&gt;ignore&lt;/code&gt; , 처리를 종료하고, 함수 반환 &lt;code&gt;{error,Reason}&lt;/code&gt; 또는 &lt;code&gt;ignore&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="08a85009b7d63daa3876ac0bbe64563be6e4667a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt;, this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{stop,Reason}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt;, the process is terminated and this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">경우 &lt;code&gt;Module:init/1&lt;/code&gt; 실패 &lt;code&gt;Reason&lt;/code&gt; ,이 함수가 반환 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; . 경우 &lt;code&gt;Module:init/1&lt;/code&gt; 복귀 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{stop,Reason}&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt; , 처리를 종료하고,이 함수가 리턴 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="b964744cac9c86474eba0929df72fddd8367b88f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;ignore&lt;/code&gt;, this function returns &lt;code&gt;ignore&lt;/code&gt; as well and the supervisor bridge terminates with reason &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Module:init/1&lt;/code&gt; 반환 &lt;code&gt;ignore&lt;/code&gt; ,이 함수가 반환은 &lt;code&gt;ignore&lt;/code&gt; 뿐만 아니라 이성과 감독자 브리지 종료 &lt;code&gt;normal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e2bd739756c272b047be065f7e266ff83f96304" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;ignore&lt;/code&gt;, this function returns &lt;code&gt;ignore&lt;/code&gt; as well, and the supervisor terminates with reason &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Module:init/1&lt;/code&gt; 반환 &lt;code&gt;ignore&lt;/code&gt; ,이 함수가 반환은 &lt;code&gt;ignore&lt;/code&gt; 뿐만 아니라, 이성과 수퍼바이저 종료 &lt;code&gt;normal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0a0e47ea971ab5cb4ee104b3ddf1785be6b28da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns a correct value indicating successful completion, the event manager adds the event handler and this function returns &lt;code&gt;ok&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt; or returns &lt;code&gt;{error,Reason}&lt;/code&gt;, the event handler is ignored and this function returns &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; or &lt;code&gt;{error,Reason}&lt;/code&gt;, respectively.</source>
          <target state="translated">경우 &lt;code&gt;Module:init/1&lt;/code&gt; 반환 성공적인 완료를 나타내는 정확한 값을, 이벤트 관리자는 이벤트 핸들러이 함수가 반환의 추가 &lt;code&gt;ok&lt;/code&gt; . 경우 &lt;code&gt;Module:init/1&lt;/code&gt; 실패 &lt;code&gt;Reason&lt;/code&gt; 또는 반환 &lt;code&gt;{error,Reason}&lt;/code&gt; , 이벤트 핸들러가 무시되고이 함수가 반환 &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; 또는 &lt;code&gt;{error,Reason}&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="09a967e619be6af84ec5d9fcc2d540f2231d235c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:on_tc_fail/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:on_tc_fail(TestName, Reason, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">경우 &lt;code&gt;Module:on_tc_fail/4&lt;/code&gt; 내보낼 수 없습니다, common_test 호출을 시도합니다 &lt;code&gt;Module:on_tc_fail(TestName, Reason, CTHState)&lt;/code&gt; 대신. 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="dd0d2fb7d1f38864cd0e105f7caff1a473b3f495" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:on_tc_skip/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:on_tc_skip(TestName, Reason, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">경우 &lt;code&gt;Module:on_tc_skip/4&lt;/code&gt; 내보낼 수 없습니다, common_test 호출을 시도합니다 &lt;code&gt;Module:on_tc_skip(TestName, Reason, CTHState)&lt;/code&gt; 대신. 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6e0f9d357b53cd19411dbd2755262448109533a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_end_per_group/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_end_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">경우 &lt;code&gt;Module:post_end_per_group/5&lt;/code&gt; 내보낼 수 없습니다, common_test 호출을 시도합니다 &lt;code&gt;Module:post_end_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; 대신. 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c30a59478d9813033d5db1ba6eb7b720e1f8a281" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_end_per_testcase/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_end_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">경우 &lt;code&gt;Module:post_end_per_testcase/5&lt;/code&gt; 내보낼 수 없습니다, common_test 호출을 시도합니다 &lt;code&gt;Module:post_end_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; 대신. 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="8b31af596bd3564305ac89780dcd5037ca72eed4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_init_per_group/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_init_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">경우 &lt;code&gt;Module:post_init_per_group/5&lt;/code&gt; 내보낼 수 없습니다, common_test 호출을 시도합니다 &lt;code&gt;Module:post_init_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; 대신. 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="3389cc7f2c4854aa000a5dc7cbbbd118b6386a3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_init_per_testcase/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_init_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">경우 &lt;code&gt;Module:post_init_per_testcase/5&lt;/code&gt; 내보낼 수 없습니다, common_test 호출을 시도합니다 &lt;code&gt;Module:post_init_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; 대신. 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="fa0c6abab53f3a1832ad70236445abe23313c949" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_end_per_group/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_end_per_group(GroupName, EndData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">경우 &lt;code&gt;Module:pre_end_per_group/4&lt;/code&gt; 내보낼 수 없습니다, common_test 호출을 시도합니다 &lt;code&gt;Module:pre_end_per_group(GroupName, EndData, CTHState)&lt;/code&gt; 대신. 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="4220e81587ad22a96ae86a7cc023800c3211a2ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_end_per_testcase/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_end_per_testcase(TestcaseName, EndData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">경우 &lt;code&gt;Module:pre_end_per_testcase/4&lt;/code&gt; 내보낼 수 없습니다, common_test 호출을 시도합니다 &lt;code&gt;Module:pre_end_per_testcase(TestcaseName, EndData, CTHState)&lt;/code&gt; 대신. 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="827b0497b91b5175e901d63a74e9ca29d1d28466" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_init_per_group/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_init_per_group(GroupName, InitData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">경우 &lt;code&gt;Module:pre_init_per_group/4&lt;/code&gt; 내보낼 수 없습니다, common_test 호출을 시도합니다 &lt;code&gt;Module:pre_init_per_group(GroupName, InitData, CTHState)&lt;/code&gt; 대신. 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="547d2d680c102fd734e63aee60c0764a91aca79d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_init_per_testcase/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_init_per_testcase(TestcaseName, InitData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">경우 &lt;code&gt;Module:pre_init_per_testcase/4&lt;/code&gt; 내보낼 수 없습니다, common_test 호출을 시도합니다 &lt;code&gt;Module:pre_init_per_testcase(TestcaseName, InitData, CTHState)&lt;/code&gt; 대신. 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="21fb0625232bdf7d33e9683b493cf013dd5244be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is an atom and is not the path of a source file, then the code path is searched to locate the object file for the module and extract its original compiler options and source path. If the source file is not found in the original location, &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt;filelib:find_source/1&lt;/a&gt;&lt;/code&gt; is used to search for it relative to the directory of the object file.</source>
          <target state="translated">경우 &lt;code&gt;Module&lt;/code&gt; 원자이고, 소스 파일의 경로가 아닌, 다음의 코드로 모듈의 오브젝트 파일을 찾아 원래 컴파일러 옵션과 소스 경로를 추출하기 위해 검색된다. 소스 파일이 원래 위치에없는 경우 &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt;filelib:find_source/1&lt;/a&gt;&lt;/code&gt; 을 사용하여 오브젝트 파일의 디렉토리를 기준으로 해당 파일을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="2f35893e15d66156fbf46d4e4af24041aed07f45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is interpreted, the interpreter is invoked and the return value of the interpreted &lt;code&gt;Fun(Arg1,.., ArgN)&lt;/code&gt; call is returned.</source>
          <target state="translated">경우 &lt;code&gt;Module&lt;/code&gt; 해석됩니다 인터프리터가 호출되고 해석의 반환 값 &lt;code&gt;Fun(Arg1,.., ArgN)&lt;/code&gt; 호출이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="67c2474f76236eb774fc89b2d1d56a6f0f7c3f57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded and the object file exists and contains the same code.</source>
          <target state="translated">경우 &lt;code&gt;Module&lt;/code&gt; 로드되고 오브젝트 파일이 존재하고 같은 코드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e3e08e194bdd0bde8a181db6a7f4ea876ef7dfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but does not have native code</source>
          <target state="translated">경우 &lt;code&gt;Module&lt;/code&gt; 로드하지만하지 않습니다 네이티브 코드를</target>
        </trans-unit>
        <trans-unit id="6ed685bf101eabc82b65e519e9da522892714f39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but no corresponding object file can be found in the code path.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 이로드되었지만 코드 경로에서 해당 오브젝트 파일을 찾을 수없는 경우</target>
        </trans-unit>
        <trans-unit id="a3d8ad064c879fd2b635248fe4428064d2c2287b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but the object file contains code with a different MD5 checksum.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 이로드되었지만 오브젝트 파일에 다른 MD5 체크섬이있는 코드가 포함 된 경우 .</target>
        </trans-unit>
        <trans-unit id="0d66cbf854873559817431ac8657e00f31894e65" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not Cover compiled, the function returns &lt;code&gt;{error,{not_cover_compiled,Module}}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 이 Cover 컴파일되지 않은 경우 함수는 &lt;code&gt;{error,{not_cover_compiled,Module}}&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="35affc64e4462796f41658b1b89a47205a5418f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not an atom.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 이 원자가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="28eaadbc7b4906a161654ae8a696f70005c80dff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not currently loaded.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 이 현재로드되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="2f4aff325466dff627c5e688d76bc4df8a1246e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not given, data for all Cover compiled or earlier imported modules is exported.</source>
          <target state="translated">경우 &lt;code&gt;Module&lt;/code&gt; 제공되지 않으며, 모든 커버 컴파일 또는 이전 수입 모듈에 대한 데이터를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="4388daad92dd73ddcb6294d3f0538fdaca71514b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not loaded</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 이로드되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="3de1d5c36e26d7596ce7561b07882f4daa22a030" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is the name of a loaded module that has native code loaded</source>
          <target state="translated">경우 &lt;code&gt;Module&lt;/code&gt; 네이티브 코드가로드로드 된 모듈의 이름입니다</target>
        </trans-unit>
        <trans-unit id="dc068e6c6fb49a84acb5b9f82ce4f1b82380c161" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is an atom (one module), the return will be &lt;code&gt;Answer&lt;/code&gt;, else the return will be a list, &lt;code&gt;{result,Ok,Fail}&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Modules&lt;/code&gt; 원자 (하나 개의 모듈)이며, 반환 될 것이다 &lt;code&gt;Answer&lt;/code&gt; 다른 리턴이리스트 것, &lt;code&gt;{result,Ok,Fail}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2129780e47085f58784cab38168e42cd913f8b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is an atom (one module), the return will be &lt;code&gt;OneResult&lt;/code&gt;, else the return will be &lt;code&gt;{result,Ok,Fail}&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Modules&lt;/code&gt; 원자 (하나 개의 모듈)은 상기 복귀 할 것이다 &lt;code&gt;OneResult&lt;/code&gt; 다른 반환 될 것이다 &lt;code&gt;{result,Ok,Fail}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c5660afecaaa6ae9b7c2e1dd31118d79f4a48c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is not given, all modules that have data in the cover data table, are analysed. Note that this includes both cover compiled modules and imported modules.</source>
          <target state="translated">경우에 &lt;code&gt;Modules&lt;/code&gt; 주어지지 커버 데이터 테이블의 데이터가 모든 모듈은 분석된다. 여기에는 커버 컴파일 된 모듈과 가져온 모듈이 모두 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8a375b70a231e530df5647867765137b186f5486" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules=dynamic&lt;/code&gt;, which is the case for event managers, the event manager process informs the release handler about the list of currently installed event handlers (&lt;code&gt;gen_event&lt;/code&gt;), and it is checked if the module name is in this list instead.</source>
          <target state="translated">경우 &lt;code&gt;Modules=dynamic&lt;/code&gt; 이벤트 매니저의 경우, 이벤트 매니저 프로세스 정보 용 현재 설치된 이벤트 핸들러 (목록에 대한 분리 처리기 &lt;code&gt;gen_event&lt;/code&gt; 는 모듈 이름 대신에이리스트에있는 경우)을 체크한다.</target>
        </trans-unit>
        <trans-unit id="e8cecedc28fd848e48458244703056a1ac1a339f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorPid&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;code&gt;MonitorPid&lt;/code&gt; 가없는 경우</target>
        </trans-unit>
        <trans-unit id="373a002dc9620bdf865a5b5e6f260b3dd1f5301f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorPid&lt;/code&gt; is not a local process.</source>
          <target state="translated">&lt;code&gt;MonitorPid&lt;/code&gt; 가 로컬 프로세스가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="89660705a87398108d22c38f81698b872c41d667" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorRef&lt;/code&gt; is a reference that the calling process obtained by calling &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt;, this monitoring is turned off. If the monitoring is already turned off, nothing happens.</source>
          <target state="translated">경우 &lt;code&gt;MonitorRef&lt;/code&gt; 가 호출 프로세스를 호출하여 얻은 기준 인 &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt; 이 모니터링은 턴 오프된다. 모니터링이 이미 꺼져 있으면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4fd962484b4478493735ba1be0d09ca7b30e44ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; &amp;lt; &lt;code&gt;0&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">경우 &lt;code&gt;N&lt;/code&gt; &amp;lt; &lt;code&gt;0&lt;/code&gt; 하는 &lt;code&gt;badarg&lt;/code&gt; 의 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="790d7222607fd455375f3a15db7f9612e76c7d20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; = 0, call saving is disabled for the process, which is the default. Whenever the size of the call saving list is set, its contents are reset.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; = 0 인 경우 프로세스에 대해 통화 저장이 비활성화됩니다 (기본값). 통화 저장 목록의 크기가 설정 될 때마다 그 내용이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="917defb768e26d53c01d843240d1452bda349978" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; (an alias name for &lt;code&gt;Key&lt;/code&gt;) is used to identify the connection, this name can be used as connection reference for subsequent calls. Only one open connection at a time associated with &lt;code&gt;Name&lt;/code&gt; is possible. If &lt;code&gt;Key&lt;/code&gt; is used, the returned handle must be used for subsequent calls (multiple connections can be opened using the configuration data specified by &lt;code&gt;Key&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;Name&lt;/code&gt; (별칭 이름 &lt;code&gt;Key&lt;/code&gt; ) 연결을 식별하는 데 사용됩니다,이 이름은 후속 호출에 대한 연결 참조로 사용할 수 있습니다. &lt;code&gt;Name&lt;/code&gt; 과 관련된 한 번에 하나의 열린 연결 만 가능합니다. &lt;code&gt;Key&lt;/code&gt; 가 사용되는 경우 , 후속 호출에 리턴 된 핸들을 사용해야합니다 ( &lt;code&gt;Key&lt;/code&gt; 에 지정된 구성 데이터를 사용하여 다중 연결을 열 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="656dd80cf80ca49ab5d3f335d4b4b338f312a58e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is also the name of one of the input modules, the code from that module will occur at the top of the resulting code, and no extra &quot;header&quot; comments will be added. In other words, the look of that module will be preserved.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 이 입력 모듈 중 하나의 이름 인 경우 해당 모듈의 코드가 결과 코드 상단에 표시되며 추가 &quot;헤더&quot;주석이 추가되지 않습니다. 즉, 해당 모듈의 모양이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="ce802579fca60cdc1ea685ad322c443678165ff7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is an &lt;code&gt;ip_address()&lt;/code&gt;, the domain name to query for is generated as the standard reverse &lt;code&gt;&quot;.IN-ADDR.ARPA.&quot;&lt;/code&gt; name for an IPv4 address, or the &lt;code&gt;&quot;.IP6.ARPA.&quot;&lt;/code&gt; name for an IPv6 address. In this case, you most probably want to use &lt;code&gt;Class = in&lt;/code&gt; and &lt;code&gt;Type = ptr&lt;/code&gt;, but it is not done automatically.</source>
          <target state="translated">경우 &lt;code&gt;Name&lt;/code&gt; 입니다 &lt;code&gt;ip_address()&lt;/code&gt; , 표준 역으로 생성을위한 쿼리 도메인 이름 &lt;code&gt;&quot;.IN-ADDR.ARPA.&quot;&lt;/code&gt; IPv4 주소의 이름 또는 &lt;code&gt;&quot;.IP6.ARPA.&quot;&lt;/code&gt; IPv6 주소의 이름입니다. 이 경우 &lt;code&gt;Class = in&lt;/code&gt; 및 &lt;code&gt;Type = ptr&lt;/code&gt; 을 사용하려고 하지만 자동으로 수행되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8688d593066763d843262dfe2006d94c1dcdd01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is found, message &lt;code&gt;Msg&lt;/code&gt; is sent to the corresponding pid. The pid is also the return value of the function. If the name is not found, the function returns &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Name&lt;/code&gt; 발견, 메시지 &lt;code&gt;Msg&lt;/code&gt; 해당 PID로 전송됩니다. pid는 함수의 반환 값이기도합니다. 이름을 찾지 못하면이 함수는 &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="77e52354c073c213988ffe84ec279249d3ad68b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is found, the corresponding pid is returned. If the name is not found, the function returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Name&lt;/code&gt; 발견, 해당 PID가 반환됩니다. 이름을 찾지 못하면 함수는 &lt;code&gt;undefined&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b00a3532b853c4357137d1d6716fd7be18c249ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not a globally registered name, the calling function exits with reason &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 이 전역 적으로 등록 된 이름이 아닌 경우 호출 함수는 &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt; 이유로 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="db414ecce81f54e0e73f62d5d1f1d7174a6bde93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not a symbolic link, this function returns the same result as &lt;code&gt;read_file_info/1&lt;/code&gt;. On platforms that do not support symbolic links, this function is always equivalent to &lt;code&gt;read_file_info/1&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Name&lt;/code&gt; 심볼릭 링크 아니라,이 기능은 동일한 결과를 반환 &lt;code&gt;read_file_info/1&lt;/code&gt; . 심볼릭 링크를 지원하지 않는 플랫폼에서이 기능은 항상 &lt;code&gt;read_file_info/1&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8984feb7e9675020b1675cc50fa02225487141b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not found</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 찾을 수없는 경우</target>
        </trans-unit>
        <trans-unit id="83d7d8a185c6a27fcabc1c06a33f11f825598937" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is set to &lt;strong&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/strong&gt; the node will be started in a special mode optimized to be the temporary client of another node. When enabled the node will request a &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_NAME_ME&quot;&gt;dynamic node name&lt;/a&gt;&lt;/code&gt; from the first node it connects to. In addition these distribution settings will be set:</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 이 &lt;strong&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/strong&gt; 로 설정된 경우 노드는 다른 노드의 임시 클라이언트로 최적화 된 특수 모드에서 시작됩니다. 활성화되면 노드는 연결되는 첫 번째 노드에서 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_NAME_ME&quot;&gt;dynamic node name&lt;/a&gt;&lt;/code&gt; 을 요청합니다 . 또한 다음 배포 설정이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3d520edb0115ce9349b43d81a86232f4def5a898" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; or &lt;code&gt;Dir&lt;/code&gt; is invalid</source>
          <target state="translated">경우 &lt;code&gt;Name&lt;/code&gt; 또는 &lt;code&gt;Dir&lt;/code&gt; 유효하지 않습니다</target>
        </trans-unit>
        <trans-unit id="f315d1f10b092b6fd3887d5883429c8b05c69dd6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NetTicktime &amp;lt; PreviousNetTicktime&lt;/code&gt;, the &lt;code&gt;net_ticktime&lt;/code&gt; change is done at the end of the transition period; otherwise at the beginning. During the transition period, &lt;code&gt;net_kernel&lt;/code&gt; ensures that there is outgoing traffic on all connections at least every &lt;code&gt;MTTI&lt;/code&gt; millisecond.</source>
          <target state="translated">경우 &lt;code&gt;NetTicktime &amp;lt; PreviousNetTicktime&lt;/code&gt; 상기 &lt;code&gt;net_ticktime&lt;/code&gt; 변화 천이 기간의 종료에서 수행되고; 그렇지 않으면 처음에. 전환 기간 동안 &lt;code&gt;net_kernel&lt;/code&gt; 은 모든 연결에서 적어도 &lt;code&gt;MTTI&lt;/code&gt; 밀리 초 마다 나가는 트래픽이 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="3470b5ebd8e369aa1cfb7ac34ffa140b95c20443" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NewVsn&lt;/code&gt; is installed with option &lt;code&gt;{update_paths,true}&lt;/code&gt;, then &lt;code&gt;code:lib_dir(myapp)&lt;/code&gt; returns &lt;code&gt;/home/user/myapp-1.0&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;NewVsn&lt;/code&gt; 가 옵션으로 설치되어 &lt;code&gt;{update_paths,true}&lt;/code&gt; , 다음 &lt;code&gt;code:lib_dir(myapp)&lt;/code&gt; 를 반환 &lt;code&gt;/home/user/myapp-1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7547eeec41488135afba55363382ea4a68e45c3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NextState =/= State&lt;/code&gt; the state machine changes to a new state. A &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;state enter call&lt;/a&gt;&lt;/code&gt; is performed if enabled and all &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed events&lt;/a&gt;&lt;/code&gt; are retried.</source>
          <target state="translated">경우 &lt;code&gt;NextState =/= State&lt;/code&gt; 상태 기계는 새로운 상태로 변경됩니다. 활성화 된 &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;state enter call&lt;/a&gt;&lt;/code&gt; 이 수행되고 &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed events&lt;/a&gt;&lt;/code&gt; 모든 이벤트 가 재 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="985454129fa65531f94519e19f8ec9b0b8e0bac3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NextState =/= State&lt;/code&gt; this is a &lt;strong&gt;state change&lt;/strong&gt; so the extra things &lt;code&gt;gen_statem&lt;/code&gt; does are: the event queue is restarted from the oldest &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed event&lt;/a&gt;&lt;/code&gt;, any current &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;state time-out&lt;/a&gt;&lt;/code&gt; is cancelled, and a &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;state enter call&lt;/a&gt;&lt;/code&gt; is performed, if enabled.</source>
          <target state="translated">경우 &lt;code&gt;NextState =/= State&lt;/code&gt; 이것은이다 &lt;strong&gt;상태 변화&lt;/strong&gt; 여분의 것, 그래서 &lt;code&gt;gen_statem&lt;/code&gt; 수행은 다음과 같습니다 이벤트 큐는 가장 오래된에서 다시 시작 &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed event&lt;/a&gt;&lt;/code&gt; , 어떤 현재 &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;state time-out&lt;/a&gt;&lt;/code&gt; 취소되고, &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;state enter call&lt;/a&gt;&lt;/code&gt; 활성화 된 경우, 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="192634e65d22edbbba862eb9814d7d7d08c39bad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; fails or does not exist, the message &lt;code&gt;{nodedown, Node}&lt;/code&gt; is delivered to the process. If a process has made two calls to &lt;code&gt;monitor_node(Node, true)&lt;/code&gt; and &lt;code&gt;Node&lt;/code&gt; terminates, two &lt;code&gt;nodedown&lt;/code&gt; messages are delivered to the process. If there is no connection to &lt;code&gt;Node&lt;/code&gt;, an attempt is made to create one. If this fails, a &lt;code&gt;nodedown&lt;/code&gt; message is delivered.</source>
          <target state="translated">경우 &lt;code&gt;Node&lt;/code&gt; 실패하거나 존재하지 않는 메시지 &lt;code&gt;{nodedown, Node}&lt;/code&gt; 프로세스에 전달된다. 프로세스가 &lt;code&gt;monitor_node(Node, true)&lt;/code&gt; 를 두 번 호출 하고 &lt;code&gt;Node&lt;/code&gt; 종료되면 두 개의 노드 &lt;code&gt;nodedown&lt;/code&gt; 메시지가 프로세스에 전달됩니다. &lt;code&gt;Node&lt;/code&gt; 에 연결되지 않은 경우 Node 를 작성하려고 시도합니다. 이것이 실패하면 &lt;code&gt;nodedown&lt;/code&gt; 메시지가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="68714d151c87dc360bf98fc14620b6c335f0dd18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; is &lt;code&gt;new&lt;/code&gt; the &lt;code&gt;Options&lt;/code&gt; will then also be added to kernel configration parameters &lt;code&gt;inet_dist_listen_options&lt;/code&gt; and &lt;code&gt;inet_dist_connect_options&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Node&lt;/code&gt; 있습니다 &lt;code&gt;new&lt;/code&gt; &lt;code&gt;Options&lt;/code&gt; 다음 또한 configration 매개 변수 커널에 추가됩니다 &lt;code&gt;inet_dist_listen_options&lt;/code&gt; 및 &lt;code&gt;inet_dist_connect_options&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="9a374c5564c071bca33b827b4d05f4d121d56e78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; is a connected node the return value is the same as from &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts(Sock, Options)&lt;/a&gt;&lt;/code&gt; where &lt;code&gt;Sock&lt;/code&gt; is the distribution socket for &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Node&lt;/code&gt; 연결된 노드가 반환 값은에서와 동일합니다 &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts(Sock, Options)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;Sock&lt;/code&gt; 에 대한 배포 소켓입니다 &lt;code&gt;Node&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a745393bc7f4f706da8daca8a06958d92906e5a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NodeRefs&lt;/code&gt; has the value &lt;code&gt;all_nodes&lt;/code&gt;, the operation or test is performed on all specified test nodes. (Declaring a term without a &lt;code&gt;NodeRefs&lt;/code&gt; element has the same effect). If &lt;code&gt;NodeRefs&lt;/code&gt; has the value &lt;code&gt;master&lt;/code&gt;, the operation is only performed on the &lt;code&gt;Common Test&lt;/code&gt; Master node (namely set the log directory or install an event handler).</source>
          <target state="translated">경우 &lt;code&gt;NodeRefs&lt;/code&gt; 이 값이 &lt;code&gt;all_nodes&lt;/code&gt; 을 , 작동 또는 시험은 지정된 모든 테스트 노드에서 수행됩니다. ( &lt;code&gt;NodeRefs&lt;/code&gt; 요소가 없는 용어를 선언 해도 같은 효과가 있습니다). 경우 &lt;code&gt;NodeRefs&lt;/code&gt; 이 값이 &lt;code&gt;master&lt;/code&gt; , 동작 만 수행되는 &lt;code&gt;Common Test&lt;/code&gt; 마스터 노드 (즉, 로그 디렉토리를 설정하거나 이벤트 처리기를 설치합니다).</target>
        </trans-unit>
        <trans-unit id="0a2bb885a5c6676f0b55789e9e3cebe681cef1a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Nodename&lt;/code&gt; is the local node, the error reason &lt;code&gt;cant_add_local_node&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;Nodename&lt;/code&gt; 로컬 노드 오류 이유 &lt;code&gt;cant_add_local_node&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="88f13b4b4a78ad3eb8641157bd00453fceefb7e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Norm&lt;/code&gt; is not &lt;code&gt;none&lt;/code&gt; the function applies normalization on the fly before the equality test. There are four available normalization forms: &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt; nfc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfd_list-1&quot;&gt; nfd&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkc_list-1&quot;&gt; nfkc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkd_list-1&quot;&gt; nfkd&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Norm&lt;/code&gt; 되지 않습니다 &lt;code&gt;none&lt;/code&gt; 이 함수는 평등 시험 전에 즉시 정상화를 적용합니다. 사용 가능한 정규화 형식에는 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt; nfc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfd_list-1&quot;&gt; nfd&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkc_list-1&quot;&gt; nfkc&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkd_list-1&quot;&gt; nfkd&lt;/a&gt;&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cd44685473bdc36e9c30c5fd35ef39651321ff3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Norm&lt;/code&gt; is not &lt;code&gt;none&lt;/code&gt; the function applies normalization on the fly before the equality test. There are four available normalization forms: &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt;nfc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfd_list-1&quot;&gt;nfd&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkc_list-1&quot;&gt;nfkc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkd_list-1&quot;&gt;nfkd&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Norm&lt;/code&gt; 되지 않습니다 &lt;code&gt;none&lt;/code&gt; 이 함수는 평등 시험 전에 즉시 정상화를 적용합니다. &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt;nfc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfd_list-1&quot;&gt;nfd&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkc_list-1&quot;&gt;nfkc&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkd_list-1&quot;&gt;nfkd&lt;/a&gt;&lt;/code&gt; 의 네 가지 정규화 형식이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2e6781b735fbde5662ff5d701d6df3c8fc8b882" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ObjectOrObjects&lt;/code&gt; is a list, the function checks &lt;strong&gt;every&lt;/strong&gt; key before inserting anything. Nothing is inserted unless &lt;strong&gt;all&lt;/strong&gt; keys present in the list are absent from the table. Like &lt;code&gt;insert/2&lt;/code&gt;, the entire operation is guaranteed to be &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;ObjectOrObjects&lt;/code&gt; 는 목록, 기능 검사입니다 &lt;strong&gt;모든&lt;/strong&gt; 키 아무것도 삽입하기 전에이. 목록에 존재하는 &lt;strong&gt;모든&lt;/strong&gt; 키가 테이블에없는 경우가 아니면 삽입되지 않습니다. &lt;code&gt;insert/2&lt;/code&gt; 와 마찬가지로 전체 작업은 &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea049099ad2942c413fff09669264ab1e5dd87b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Operation&lt;/code&gt; cannot fit in a 32-bit integer.</source>
          <target state="translated">&lt;code&gt;Operation&lt;/code&gt; 이 32 비트 정수에 맞지 않는 경우</target>
        </trans-unit>
        <trans-unit id="9a2af5fb3189d023dbe0c347471fbf3afbf37fe5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Operation&lt;/code&gt; does not fit in a 32-bit integer.</source>
          <target state="translated">&lt;code&gt;Operation&lt;/code&gt; 이 32 비트 정수에 맞지 않는 경우</target>
        </trans-unit>
        <trans-unit id="2ef59a44cc7221066ae352f1c66be399d1a45ac8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Opt&lt;/code&gt; is any atom, it is interpreted as &lt;code&gt;{Opt,true}&lt;/code&gt; unless the atom string starts with &lt;code&gt;&quot;no&quot;&lt;/code&gt;, making the interpretation &lt;code&gt;{Opt,false}&lt;/code&gt;. For example, &lt;code&gt;usevc&lt;/code&gt; is an alias for &lt;code&gt;{usevc,true}&lt;/code&gt; and &lt;code&gt;nousevc&lt;/code&gt; is an alias for &lt;code&gt;{usevc,false}&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Opt&lt;/code&gt; 어떤 원자, 그것은으로 해석됩니다 &lt;code&gt;{Opt,true}&lt;/code&gt; 과 원자 문자열 시작하지 않는 한 &lt;code&gt;&quot;no&quot;&lt;/code&gt; 를 해석하고, &lt;code&gt;{Opt,false}&lt;/code&gt; . 예를 들어, &lt;code&gt;usevc&lt;/code&gt; 는 &lt;code&gt;{usevc,true}&lt;/code&gt; 의 별명 이고 &lt;code&gt;nousevc&lt;/code&gt; 는 &lt;code&gt;{usevc,false}&lt;/code&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="31127aa2062d718c77d7a07ba00f404218c5e042" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptList&lt;/code&gt; is not a proper list of valid &lt;code&gt;Opt&lt;/code&gt;s.</source>
          <target state="translated">경우 &lt;code&gt;OptList&lt;/code&gt; 은 유효한의 적절한 목록이 아닙니다 &lt;code&gt;Opt&lt;/code&gt; 의.</target>
        </trans-unit>
        <trans-unit id="7b4363da74d53cb9c45989d6ac83b5d6bbd19064" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptParams&lt;/code&gt; is not given, the default value &lt;code&gt;[]&lt;/code&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;OptParams&lt;/code&gt; 이 제공되지 않으며, 기본값은 &lt;code&gt;[]&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="a510b4980f05110bb42f2051f210307d0b27183c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Option&lt;/code&gt; is an invalid option.</source>
          <target state="translated">&lt;code&gt;Option&lt;/code&gt; 이 유효하지 않은 옵션 인 경우</target>
        </trans-unit>
        <trans-unit id="12e88c8f64ffe2e4621e2429aa9df040b6734c5f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is an invalid list of options.</source>
          <target state="translated">&lt;code&gt;OptionList&lt;/code&gt; 가 유효하지 않은 옵션 목록 인 경우</target>
        </trans-unit>
        <trans-unit id="28172abefdf60c0ffbe1b8a62b1fc04dc23fb874" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is an invalid option list.</source>
          <target state="translated">&lt;code&gt;OptionList&lt;/code&gt; 가 유효하지 않은 옵션 목록 인 경우</target>
        </trans-unit>
        <trans-unit id="93bbd7b2e7d83031f59c92a0c8ccb1cc60d19148" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is not a list.</source>
          <target state="translated">&lt;code&gt;OptionList&lt;/code&gt; 가 목록이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="47de326f53be67167a635f5060809e5db271ba9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;, the function behaves as &lt;code&gt;&lt;a href=&quot;#float_to_list-1&quot;&gt; float_to_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Options&lt;/code&gt; 이다 &lt;code&gt;[]&lt;/code&gt; 로서 기능 동작합니다 &lt;code&gt;&lt;a href=&quot;#float_to_list-1&quot;&gt; float_to_list/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6133e7ac28cc0038bd62a0b0ae71e4da87c1eca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;, the function behaves as &lt;code&gt;&lt;a href=&quot;#float_to_list-1&quot;&gt;float_to_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Options&lt;/code&gt; 이다 &lt;code&gt;[]&lt;/code&gt; 로서 기능 동작합니다 &lt;code&gt;&lt;a href=&quot;#float_to_list-1&quot;&gt;float_to_list/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7730b5d34ec1da622c3e568e7e8a64ba1d2bd89" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is a list, this is equivalent to &lt;code&gt;new([{size, Size} | Options]&lt;/code&gt;, otherwise it is equivalent to &lt;code&gt;new([{size, Size} | [Options]]&lt;/code&gt;. However, using this function directly is more efficient.</source>
          <target state="translated">&lt;code&gt;Options&lt;/code&gt; 이 목록 인 경우 &lt;code&gt;new([{size, Size} | Options]&lt;/code&gt; 와 동일하지만 그렇지 않으면 &lt;code&gt;new([{size, Size} | [Options]]&lt;/code&gt; 하지만이 함수를 직접 사용하는 것이 더 효율적입니다 .</target>
        </trans-unit>
        <trans-unit id="9fde3e06c0c33f9a7645abc8b6b8f5e2ebe7f59a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is not &lt;code&gt;[]&lt;/code&gt;, the format is as follows:</source>
          <target state="translated">&lt;code&gt;Options&lt;/code&gt; 가 &lt;code&gt;[]&lt;/code&gt; 가 아닌 경우 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30be8f5cb2762ca72a34cc75e497114c5814d418" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Opts&lt;/code&gt; is not specified or if it is &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;ConfigFile&lt;/code&gt; is deleted and a new file is created. If &lt;code&gt;Opts = [append]&lt;/code&gt;, &lt;code&gt;ConfigFile&lt;/code&gt; is not deleted. The new information is appended at the end of the file.</source>
          <target state="translated">경우 &lt;code&gt;Opts&lt;/code&gt; 지정하거나 경우되지 &lt;code&gt;[]&lt;/code&gt; , &lt;code&gt;ConfigFile&lt;/code&gt; 대 삭제되고 새로운 파일이 만들어집니다. 경우 &lt;code&gt;Opts = [append]&lt;/code&gt; , &lt;code&gt;ConfigFile&lt;/code&gt; 대 삭제되지 않는다. 새로운 정보는 파일 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="373e624d641069009ec67c8a54cd85bd2a2d72ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Out&lt;/code&gt; is specified, &lt;code&gt;FormatHandler&lt;/code&gt; gets the file descriptor to &lt;code&gt;Out&lt;/code&gt; as the first parameter.</source>
          <target state="translated">경우 &lt;code&gt;Out&lt;/code&gt; 지정되어, &lt;code&gt;FormatHandler&lt;/code&gt; 는 에 파일 기술자 가져 &lt;code&gt;Out&lt;/code&gt; 첫 번째 매개 변수로합니다.</target>
        </trans-unit>
        <trans-unit id="fad332308463a8263339bd3390b05cbefc19f3b2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OutstandingSuspendCount =/= 0&lt;/code&gt;, option &lt;code&gt;asynchronous&lt;/code&gt; of &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; has been used and the suspendee has not yet been suspended by &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;OutstandingSuspendCount =/= 0&lt;/code&gt; , 옵션 &lt;code&gt;asynchronous&lt;/code&gt; 의 &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; 사용되었으며 suspendee 아직에 의해 중단되지 &lt;code&gt;Pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bbfc8cfc7a6d48dbab3e59b020a0ba36f02f8cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Path&lt;/code&gt; is a directory, &lt;code&gt;default_index/2&lt;/code&gt;, it starts searching for resources or files that are specified in the config directive &lt;code&gt;DirectoryIndex&lt;/code&gt;. If an appropriate resource or file is found, it is appended to the end of &lt;code&gt;Path&lt;/code&gt; and then returned. &lt;code&gt;Path&lt;/code&gt; is returned unaltered if no appropriate file is found or if &lt;code&gt;Path&lt;/code&gt; is not a directory. &lt;code&gt;config_db()&lt;/code&gt; is the server config file in ETS table format as described in &lt;code&gt;&lt;a href=&quot;http_server&quot;&gt;Inets User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Path&lt;/code&gt; 디렉토리입니다, &lt;code&gt;default_index/2&lt;/code&gt; , 그것은 설정 지시어에 지정된 자원이나 파일 검색을 시작 &lt;code&gt;DirectoryIndex&lt;/code&gt; 에 . 적절한 리소스 나 파일이 발견되면 &lt;code&gt;Path&lt;/code&gt; 끝에 추가 된 다음 반환됩니다. &lt;code&gt;Path&lt;/code&gt; 에는 해당 파일이 발견되지 않은 경우 변경되지 않은 반환되는 경우 또는 &lt;code&gt;Path&lt;/code&gt; 디렉토리가 아니다. &lt;code&gt;config_db()&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;http_server&quot;&gt;Inets User's Guide&lt;/a&gt;&lt;/code&gt; 설명 된대로 ETS 테이블 형식의 서버 구성 파일입니다 .</target>
        </trans-unit>
        <trans-unit id="beefd85af55dff03d967de6fd4d575f5153ffe35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pattern1&lt;/code&gt; and &lt;code&gt;Pattern2&lt;/code&gt; are valid patterns, the following is also a valid pattern:</source>
          <target state="translated">경우 &lt;code&gt;Pattern1&lt;/code&gt; 과 &lt;code&gt;Pattern2&lt;/code&gt; 유효한 패턴은, 다음도 유효한 패턴입니다 :</target>
        </trans-unit>
        <trans-unit id="92bd28fe3699fc72ccf1ee88565e6cbd3a896278" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pattern&lt;/code&gt; is not a binary or a flat proper list of binaries with length &amp;gt; 0, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 이 2 진이거나 길이가 0보다 &lt;code&gt;badarg&lt;/code&gt; 적절한 바이너리 목록이 아닌 경우 잘못된 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e7fc7f98492ea4c007c2957660a86f1f0df53bcd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid2&lt;/code&gt; does not exist, the 'DOWN' message is sent immediately with &lt;code&gt;Reason&lt;/code&gt; set to &lt;code&gt;noproc&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Pid2&lt;/code&gt; 존재하지 않는의 'DOWN'메시지가 즉시 전송됩니다 &lt;code&gt;Reason&lt;/code&gt; 로 설정 &lt;code&gt;noproc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4791446d4ac7a4577450d1706f57f608bc60d37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid2&lt;/code&gt; terminates with exit reason &lt;code&gt;Reason&lt;/code&gt;, a 'DOWN' message is sent to &lt;code&gt;Pid1&lt;/code&gt;:</source>
          <target state="translated">경우 &lt;code&gt;Pid2&lt;/code&gt; 종료 이유와 함께 종료 &lt;code&gt;Reason&lt;/code&gt; 하는 'DOWN'메시지가 전송됩니다 &lt;code&gt;Pid1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c802432eb292a24b574add89af76bf12c415ea21" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; equals &lt;code&gt;self()&lt;/code&gt;, and no &lt;code&gt;async&lt;/code&gt; option has been passed, the garbage collection is performed at once, that is, the same as calling &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt; garbage_collect/0&lt;/a&gt;&lt;/code&gt;. Otherwise a request for garbage collection is sent to the process identified by &lt;code&gt;Pid&lt;/code&gt;, and will be handled when appropriate. If no &lt;code&gt;async&lt;/code&gt; option has been passed, the caller blocks until &lt;code&gt;GCResult&lt;/code&gt; is available and can be returned.</source>
          <target state="translated">경우 &lt;code&gt;Pid&lt;/code&gt; 동일 &lt;code&gt;self()&lt;/code&gt; , 어떤 &lt;code&gt;async&lt;/code&gt; 옵션이 통과되지 않은, 가비지 컬렉션, 호출하는 것과 동일하다, 한 번에 수행 &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt; garbage_collect/0&lt;/a&gt;&lt;/code&gt; . 그렇지 않으면 가비지 컬렉션에 대한 요청이 &lt;code&gt;Pid&lt;/code&gt; 로 식별 된 프로세스로 전송되고 적절한 때 처리됩니다. &lt;code&gt;async&lt;/code&gt; 옵션이 전달 되지 않은 경우 호출자 는 &lt;code&gt;GCResult&lt;/code&gt; 를 사용할 수 있고 반환 될 수있을 때까지 차단 됩니다.</target>
        </trans-unit>
        <trans-unit id="0d4ad4270f00a30d3a004edfbf6bb0907bb89e24" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; equals &lt;code&gt;self()&lt;/code&gt;, and no &lt;code&gt;async&lt;/code&gt; option has been passed, the garbage collection is performed at once, that is, the same as calling &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt;. Otherwise a request for garbage collection is sent to the process identified by &lt;code&gt;Pid&lt;/code&gt;, and will be handled when appropriate. If no &lt;code&gt;async&lt;/code&gt; option has been passed, the caller blocks until &lt;code&gt;GCResult&lt;/code&gt; is available and can be returned.</source>
          <target state="translated">경우 &lt;code&gt;Pid&lt;/code&gt; 동일 &lt;code&gt;self()&lt;/code&gt; , 어떤 &lt;code&gt;async&lt;/code&gt; 옵션이 통과되지 않은, 가비지 컬렉션, 호출하는 것과 동일하다, 한 번에 수행 &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt; . 그렇지 않으면 가비지 수집 요청이 &lt;code&gt;Pid&lt;/code&gt; 로 식별 된 프로세스로 전송되고 적절한 경우 처리됩니다. &lt;code&gt;async&lt;/code&gt; 옵션이 전달 되지 않은 경우 호출자 는 &lt;code&gt;GCResult&lt;/code&gt; 가 사용 가능하고 리턴 될 때까지 차단 합니다.</target>
        </trans-unit>
        <trans-unit id="e39d7c1dcb4424a9d8e01705e3e21bd11e62c069" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; equals &lt;code&gt;self()&lt;/code&gt;, and no &lt;code&gt;async&lt;/code&gt; option has been passed, the operation is performed at once. Otherwise a request for the operation is sent to the process identified by &lt;code&gt;Pid&lt;/code&gt;, and is handled when appropriate. If no &lt;code&gt;async&lt;/code&gt; option has been passed, the caller blocks until &lt;code&gt;CheckResult&lt;/code&gt; is available and can be returned.</source>
          <target state="translated">경우 &lt;code&gt;Pid&lt;/code&gt; 동일 &lt;code&gt;self()&lt;/code&gt; , 어떤 &lt;code&gt;async&lt;/code&gt; 옵션이 통과되지 않은, 동작을 한 번에 수행됩니다. 그렇지 않으면 작업에 대한 요청이 &lt;code&gt;Pid&lt;/code&gt; 로 식별 된 프로세스로 전송되고 적절한 경우 처리됩니다. &lt;code&gt;async&lt;/code&gt; 옵션이 전달 되지 않으면 호출자 는 &lt;code&gt;CheckResult&lt;/code&gt; 가 사용 가능하고 리턴 될 때까지 차단 합니다.</target>
        </trans-unit>
        <trans-unit id="9a5e58475adf385dca728b097c7c732d60714c40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is an I/O device, that is, a pid returned from &lt;code&gt;open/2&lt;/code&gt;, this function returns the filename, or rather:</source>
          <target state="translated">경우 &lt;code&gt;Pid&lt;/code&gt; ,에서 반환 된 PID 인 I / O 장치입니다 &lt;code&gt;open/2&lt;/code&gt; ,이 기능은 파일 이름을 반환하거나 오히려 :</target>
        </trans-unit>
        <trans-unit id="2c88872158412481d4632dbb6c4d0828fafd3ef7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not a local process.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 가 로컬 프로세스가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="0c4258af24e0c809dc0bd9d32eeea697ff1e2cb3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not a node local process identifier.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 가 노드 로컬 프로세스 식별자가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="a85548fa2767eaff370c38aaf90f8964627aa367" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not trapping exits, &lt;code&gt;Pid&lt;/code&gt; itself exits with exit reason &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Pid&lt;/code&gt; 종료 트래핑되지, &lt;code&gt;Pid&lt;/code&gt; 자체가 종료 이유와 함께 종료 &lt;code&gt;Reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="981b0f8c411a07f7ef682ac79981f9ce74ca69e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is trapping exits, the exit signal is transformed into a message &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; and delivered to the message queue of &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 가 엑시트를 트래핑하는 경우 엑시트 신호는 &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; 메시지로 변환되어 &lt;code&gt;Pid&lt;/code&gt; 의 메시지 큐로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="946409162988d6dc1aff5bb11d67c23349fa4844" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PidOrPort&lt;/code&gt; does not exist and checking it is cheap, a &lt;code&gt;noproc&lt;/code&gt; error is raised. Currently, checking is cheap if the &lt;code&gt;PidOrPort&lt;/code&gt; is local and the caller does not trap exits (see &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2 &lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;PidOrPort&lt;/code&gt; 이 존재하지 않고 확인이 저렴하는 &lt;code&gt;noproc&lt;/code&gt; 의 오류가 발생합니다. 현재 &lt;code&gt;PidOrPort&lt;/code&gt; 가 로컬이고 호출자가 종료를 트랩하지 않는 경우 검사 비용이 저렴합니다 ( &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2 &lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e139aa51e35a6da6edcc143ed04c057990132602" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PidOrPort&lt;/code&gt; does not exist, the behavior of the BIF depends on if the calling process is trapping exits or not (see &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;PidOrPort&lt;/code&gt; 가 존재하지 않는 경우 BIF의 동작은 호출 프로세스가 종료를 트래핑하는지 여부에 따라 다릅니다 ( &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="266b9e9cd253c4e1b334cac8528b2a62708531c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PidOrPort&lt;/code&gt; is not an existing local process or port.</source>
          <target state="translated">&lt;code&gt;PidOrPort&lt;/code&gt; 가 기존 로컬 프로세스 또는 포트가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="ea3c1727e46c2f29d355231a14b993fe9ee7f045" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port == 0&lt;/code&gt;, the underlying OS assigns a free UDP port, use &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; to retrieve it.</source>
          <target state="translated">경우 &lt;code&gt;Port == 0&lt;/code&gt; , 기본 OS의 양수인 무료 UDP 포트를 사용 &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; 을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7fa31d4ca670522aa140145b3a60537cc2e5b54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port == 0&lt;/code&gt;, the underlying OS assigns an available port number, use &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; to retrieve it.</source>
          <target state="translated">경우 &lt;code&gt;Port == 0&lt;/code&gt; , 기본 OS의 양수인 사용 가능한 포트 번호를 사용 &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; 을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb219559d25b9731f030a5d6d757dbdd7db890b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port&lt;/code&gt; is not an identifier of an open port, or the registered name of an open port. If the calling process was previously linked to the closed port, identified by &lt;code&gt;Port&lt;/code&gt;, the exit signal from the port is guaranteed to be delivered before this &lt;code&gt;badarg&lt;/code&gt; exception occurs.</source>
          <target state="translated">경우 &lt;code&gt;Port&lt;/code&gt; 열려있는 포트의 식별자, 또는 열린 포트의 등록 된 이름이 아닙니다. 호출 프로세스가 이전에 &lt;code&gt;Port&lt;/code&gt; 로 식별 된 닫힌 포트에 링크 된 경우, 이 &lt;code&gt;badarg&lt;/code&gt; 예외가 발생 하기 전에 포트의 종료 신호가 전달되도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="0702a363d6583ab49124103adeca84fa54bd565c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port&lt;/code&gt; is not an open port or the registered name of an open port.</source>
          <target state="translated">&lt;code&gt;Port&lt;/code&gt; 가 열린 포트 또는 열린 포트의 등록 된 이름이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="ad97fac62d783a4932985f8dd89585d539b9ba38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PosLen&lt;/code&gt; in any way references outside the binary, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">경우 &lt;code&gt;PosLen&lt;/code&gt; 이 진 밖에서 어떤 식 으로든 참조에서는, &lt;code&gt;badarg&lt;/code&gt; 의 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5fa9284a8e57969389fe13ab25086a491ce7496c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is the prefix of &lt;code&gt;String&lt;/code&gt;, removes it and returns the remainder of &lt;code&gt;String&lt;/code&gt;, otherwise returns &lt;code&gt;nomatch&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Prefix&lt;/code&gt; 가 &lt;code&gt;String&lt;/code&gt; 의 접두사 인 경우 접두사를 제거하고 나머지 &lt;code&gt;String&lt;/code&gt; 을 반환하고 , 그렇지 않으면 &lt;code&gt;nomatch&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f4e6b8924461855959440e4adc224de1af86a752" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;QH2&lt;/code&gt; is a call to the function for &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt;, as defined in section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;gb_table:table/1&lt;/code&gt;, the iterator for the gb-tree is initiated for each answer to &lt;code&gt;QH1&lt;/code&gt;. The objects of the gb-tree are then returned one by one. This is probably the most efficient way of traversing the table in that case, as it takes minimal computational power to get the following object. But if &lt;code&gt;QH2&lt;/code&gt; is not a table but a more complicated QLC, it can be more efficient to use some RAM memory for collecting the answers in a cache, particularly if there are only a few answers. It must then be assumed that evaluating &lt;code&gt;QH2&lt;/code&gt; has no side effects so that the meaning of the query does not change if &lt;code&gt;QH2&lt;/code&gt; is evaluated only once. One way of caching the answers is to evaluate &lt;code&gt;QH2&lt;/code&gt; first of all and substitute the list of answers for &lt;code&gt;QH2&lt;/code&gt; in the query. Another way is to use option &lt;code&gt;cache&lt;/code&gt;. It is expressed like this:</source>
          <target state="translated">경우 &lt;code&gt;QH2&lt;/code&gt; 을 위한 함수 호출이다 &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt; 섹션에 정의 &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; 다음 &lt;code&gt;gb_table:table/1&lt;/code&gt; 은 GB-트리 반복기는 각 응답에 대한 개시 &lt;code&gt;QH1&lt;/code&gt; . 그런 다음 gb-tree의 객체가 하나씩 반환됩니다. 다음과 같은 객체를 얻는 데 최소한의 계산 능력이 필요하기 때문에이 경우 테이블을 순회하는 가장 효율적인 방법 일 것입니다. 그러나 &lt;code&gt;QH2&lt;/code&gt; 가 테이블이 아니라 더 복잡한 QLC 인 경우, 특히 응답이 적은 경우 캐시에서 응답을 수집하기 위해 일부 RAM 메모리를 사용하는 것이 더 효율적일 수 있습니다. 그러면 &lt;code&gt;QH2&lt;/code&gt; 를 평가하는 것으로 가정해야합니다 &lt;code&gt;QH2&lt;/code&gt; 가 한 번만 평가되는 경우 쿼리의 의미가 변경되지 않도록 부작용이 없습니다 . 답변을 캐싱하는 한 가지 방법은 우선 &lt;code&gt;QH2&lt;/code&gt; 를 평가 하고 쿼리에서 &lt;code&gt;QH2&lt;/code&gt; 에 대한 답변 목록을 대체하는 것 입니다. 또 다른 방법은 옵션 &lt;code&gt;cache&lt;/code&gt; 를 사용하는 것 입니다. 다음과 같이 표현됩니다 :</target>
        </trans-unit>
        <trans-unit id="491d904b6ae249fbebb7daf8bc786e22605cc650" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Reason&lt;/code&gt; is the atom &lt;code&gt;kill&lt;/code&gt;, that is, if &lt;code&gt;exit(Pid, kill)&lt;/code&gt; is called, an untrappable exit signal is sent to &lt;code&gt;Pid&lt;/code&gt;, which unconditionally exits with exit reason &lt;code&gt;killed&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Reason&lt;/code&gt; 원자이다 &lt;code&gt;kill&lt;/code&gt; 입니다, 경우 &lt;code&gt;exit(Pid, kill)&lt;/code&gt; 라고하며, untrappable 종료 신호로 전송 &lt;code&gt;Pid&lt;/code&gt; 종료 이유 무조건 종료가, &lt;code&gt;killed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35fbbe7923611fc3677c5eb123690517ee7e8658" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Reason&lt;/code&gt; is the atom &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;Pid&lt;/code&gt; does not exit. If it is trapping exits, the exit signal is transformed into a message &lt;code&gt;{'EXIT', From, normal}&lt;/code&gt; and delivered to its message queue.</source>
          <target state="translated">경우 &lt;code&gt;Reason&lt;/code&gt; 원자입니다 &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;Pid&lt;/code&gt; 종료하지 않습니다. 엑시트를 트래핑하는 중이면 엑시트 신호는 &lt;code&gt;{'EXIT', From, normal}&lt;/code&gt; 메시지로 변환되어 해당 메시지 큐로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="cd196dac154540858e61e812e21e07f3f0b754dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Receiver&lt;/code&gt; has the value &lt;code&gt;{Tag, Recv}&lt;/code&gt;, the delivery is done according to &lt;code&gt;Recv&lt;/code&gt;:</source>
          <target state="translated">경우 &lt;code&gt;Receiver&lt;/code&gt; 값이 &lt;code&gt;{Tag, Recv}&lt;/code&gt; , 인도가에 따라 수행되고 &lt;code&gt;Recv&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="868986f0a85c44f9afa64f0b61bdc67eb57beed0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Receiver&lt;/code&gt; is a &lt;code&gt;notification_delivery_info()&lt;/code&gt; record, then the information about the notification delivery will be delivered to the &lt;code&gt;receiver&lt;/code&gt; via the callback functions defined by the &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; behaviour according to the content of the &lt;code&gt;notification_delivery_info()&lt;/code&gt; record.</source>
          <target state="translated">경우 &lt;code&gt;Receiver&lt;/code&gt; A는 &lt;code&gt;notification_delivery_info()&lt;/code&gt; 다음 알림 전달에 관한 정보가 전달 될 것이다 기록 &lt;code&gt;receiver&lt;/code&gt; 에 의해 정의 된 콜백 함수를 통하여 &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; 에서 의 내용에 따라 동작 &lt;code&gt;notification_delivery_info()&lt;/code&gt; 레코드.</target>
        </trans-unit>
        <trans-unit id="508d6986d5eeb87f61b9a5f9d5b4f17fa77bcfb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RegName&lt;/code&gt; is already in use.</source>
          <target state="translated">&lt;code&gt;RegName&lt;/code&gt; 이 이미 사용중인 경우</target>
        </trans-unit>
        <trans-unit id="ae95dfac53a373131ac9010b1c1e1134c4182f90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RegName&lt;/code&gt; is the atom &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;RegName&lt;/code&gt; 가 인 원자 &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0f5e564e5fd5ab3c1d7b8ad071d580aac2f45e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Repair&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the current log file is repaired, if needed. As the restoration is initiated, a message is output on the error log. If &lt;code&gt;false&lt;/code&gt; is specified, no automatic repair is attempted. Instead, the tuple &lt;code&gt;{error, {need_repair, Log}}&lt;/code&gt; is returned if an attempt is made to open a corrupt log file. If &lt;code&gt;truncate&lt;/code&gt; is specified, the log file becomes truncated, creating an empty log. Defaults to &lt;code&gt;true&lt;/code&gt;, which has no effect on logs opened in read-only mode.</source>
          <target state="translated">경우 &lt;code&gt;Repair&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; 필요한 경우, 현재 로그 파일이 복구됩니다. 복원이 시작되면 오류 로그에 메시지가 출력됩니다. 경우 &lt;code&gt;false&lt;/code&gt; 지정된 경우에는 자동 복구가 시도되지 않습니다. 대신 손상된 로그 파일을 열려고 시도 하면 튜플 &lt;code&gt;{error, {need_repair, Log}}&lt;/code&gt; 이 반환됩니다. 경우 &lt;code&gt;truncate&lt;/code&gt; 지정된 로그 파일이 비어있는 로그를 생성, 절단된다. 기본값은 &lt;code&gt;true&lt;/code&gt; 로 , 읽기 전용 모드로 열린 로그에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fba0a2d131df8af1eeb91211c8b8a8dde41e75fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Report&lt;/code&gt; is a map, it is converted to a key-value list before formatting as such.</source>
          <target state="translated">경우 &lt;code&gt;Report&lt;/code&gt; 지도입니다, 그것은 같은 포맷하기 전에 키 - 값 목록으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="15d8d66582408c3486d2e25500d0a72b68b8cb9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ReqId&lt;/code&gt; is less then 0, it means that this information was not available to the manager (that info was never retrieved before the message was discarded).</source>
          <target state="translated">경우 &lt;code&gt;ReqId&lt;/code&gt; 0보다 작은, 그것은이 정보 (즉, 정보가 메시지가 삭제되기 전에 검색되지 않았다) 관리자에 사용할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0dee047b2dfd5610136ab93118e486cde7422df3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; &amp;gt; 0, the packet only consists of &lt;code&gt;[119, Result]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Result&lt;/code&gt; &amp;gt; 0, 패킷 만 구성 &lt;code&gt;[119, Result]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c802495174a415d0a94a21a32d111d68231fb125" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, a timer corresponding to &lt;code&gt;TimerRef&lt;/code&gt; could not be found. This because the timer had expired, or been canceled, or because &lt;code&gt;TimerRef&lt;/code&gt; never has corresponded to a timer. Even if the timer has expired, it does not tell you whether or not the time-out message has arrived at its destination yet.</source>
          <target state="translated">&lt;code&gt;Result&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 &lt;code&gt;TimerRef&lt;/code&gt; 에 해당하는 타이머를 찾을 수 없습니다. 타이머가 만료되었거나 취소되었거나 &lt;code&gt;TimerRef&lt;/code&gt; 가 타이머에 해당하지 않기 때문 입니다. 타이머가 만료 된 경우에도 타임 아웃 메시지가 목적지에 도착했는지 여부를 알려주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0a8cfe624c240dfdb507f48e9d219914e2f948e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, a timer corresponding to &lt;code&gt;TimerRef&lt;/code&gt; could not be found. This can be either because the timer had expired, already had been canceled, or because &lt;code&gt;TimerRef&lt;/code&gt; never corresponded to a timer. Even if the timer had expired, it does not tell you if the time-out message has arrived at its destination yet.</source>
          <target state="translated">&lt;code&gt;Result&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 &lt;code&gt;TimerRef&lt;/code&gt; 에 해당하는 타이머를 찾을 수 없습니다. 타이머가 만료되었거나 이미 취소되었거나 &lt;code&gt;TimerRef&lt;/code&gt; 가 타이머와 일치하지 않았기 때문일 수 있습니다. 타이머가 만료 된 경우에도 타임 아웃 메시지가 목적지에 도착했는지 알려주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd4390894559b806475261afd409260099fb0615" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is an integer, it represents the time in milliseconds left until the canceled timer would have expired.</source>
          <target state="translated">경우 &lt;code&gt;Result&lt;/code&gt; 정수, 그것은 취소 된 타이머가 만료 할 때까지 남은 시간 (밀리 초)을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8b2e483082bcb6a7c95be17d5564ab01e1806263" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is an integer, it represents the time in milliseconds left until the timer expires.</source>
          <target state="translated">경우 &lt;code&gt;Result&lt;/code&gt; 정수, 그것은 타이머가 만료 될 때까지 남은 시간 (밀리 초)을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="996c07f00aef0bf25f1adad8d4b5c2f0b7da6aa8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Rules&lt;/code&gt; is left out or is an empty list, the default system rules are used. See also the Kernel application parameter &lt;code&gt;source_search_rules&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Rules&lt;/code&gt; 왼쪽으로 또는 빈 목록입니다, 기본 시스템 규칙이 사용됩니다. 커널 애플리케이션 매개 변수 &lt;code&gt;source_search_rules&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="914c10ab17b1be80fb703c7a051a9650d90020cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Schedulers&lt;/code&gt; or &lt;code&gt;SchedulersOnline&lt;/code&gt; is specified as a negative number, the value is subtracted from the default number of logical processors configured or logical processors available, respectively.</source>
          <target state="translated">경우 &lt;code&gt;Schedulers&lt;/code&gt; 또는 &lt;code&gt;SchedulersOnline&lt;/code&gt; 가 음수로 지정된 값은 각각 구성된 논리 프로세서 나 논리 프로세서의 기본 번호는 가능한 감산된다.</target>
        </trans-unit>
        <trans-unit id="1d347e571bfea9b8b89077684381b3f15fcd946f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Scope&lt;/code&gt; of the operation is &lt;code&gt;local&lt;/code&gt;, the fallback is only installed on the local node.</source>
          <target state="translated">경우 &lt;code&gt;Scope&lt;/code&gt; 작업의이 &lt;code&gt;local&lt;/code&gt; , 대체는 로컬 노드에 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="998a85ab406edc34895d37ac87304bcc5cc05937" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Server&lt;/code&gt; is &lt;code&gt;self()&lt;/code&gt; an anonymous server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start[_link]/3&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Server&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; a named server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start[_link]/4&lt;/a&gt;&lt;/code&gt;. However, the &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; name must have been registered accordingly &lt;strong&gt;before&lt;/strong&gt; this function is called.</source>
          <target state="translated">경우 &lt;code&gt;Server&lt;/code&gt; 입니다 &lt;code&gt;self()&lt;/code&gt; 익명 서버는 단지 사용하는 경우로 만들어집니다 &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start[_link]/3&lt;/a&gt;&lt;/code&gt; . 경우 &lt;code&gt;Server&lt;/code&gt; A는 &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; 명명 된 서버는 단지 사용하는 경우와 같이 생성된다 &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start[_link]/4&lt;/a&gt;&lt;/code&gt; . 그러나이 함수를 호출 &lt;strong&gt;하기 전에 &lt;/strong&gt; &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; 이름 이 적절히 등록되어 있어야합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c6410f6c768335757d34c90fcb80d9e00d2828e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Server&lt;/code&gt; is &lt;code&gt;self()&lt;/code&gt; an anonymous server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start[_link|_monitor]/3&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Server&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; a named server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start[_link|_monitor]/4&lt;/a&gt;&lt;/code&gt;. However, the &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; name must have been registered accordingly &lt;strong&gt;before&lt;/strong&gt; this function is called.</source>
          <target state="translated">경우 &lt;code&gt;Server&lt;/code&gt; 입니다 &lt;code&gt;self()&lt;/code&gt; 익명 서버는 단지 사용하는 경우로 만들어집니다 &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start[_link|_monitor]/3&lt;/a&gt;&lt;/code&gt; . 경우 &lt;code&gt;Server&lt;/code&gt; A는 &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; 명명 된 서버는 단지 사용하는 경우로 만들어집니다 &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start[_link|_monitor]/4&lt;/a&gt;&lt;/code&gt; . 그러나이 함수가 호출 &lt;strong&gt;되기 전에 &lt;/strong&gt; &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; 이름 이 적절하게 등록되어 있어야합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e26e129826cd4fdc57a94f1e90b9b33f3e22dc0a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={global,GlobalName}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process id registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt; global:register_name/2&lt;/code&gt; If no name is provided, the &lt;code&gt;gen_server&lt;/code&gt; process is not registered.</source>
          <target state="translated">경우 &lt;code&gt;ServerName={global,GlobalName}&lt;/code&gt; 상기 &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스 ID로 전체적으로 등록 &lt;code&gt;GlobalName&lt;/code&gt; 하여 &lt;code&gt; global:register_name/2&lt;/code&gt; 이름이 제공되지 않을 경우를 상기 &lt;code&gt;gen_server&lt;/code&gt; 의 처리는 등록되지 않는다.</target>
        </trans-unit>
        <trans-unit id="49ccf350dd38e4a46c92e05cf1457282aa2a2b57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={global,GlobalName}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process id registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt; If no name is provided, the &lt;code&gt;gen_server&lt;/code&gt; process is not registered.</source>
          <target state="translated">경우 &lt;code&gt;ServerName={global,GlobalName}&lt;/code&gt; 상기 &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스 ID로 전체적으로 등록 &lt;code&gt;GlobalName&lt;/code&gt; 하여 &lt;code&gt;global:register_name/2&lt;/code&gt; 이름이 제공되지 않을 경우를 상기 &lt;code&gt;gen_server&lt;/code&gt; 의 처리는 등록되지 않는다.</target>
        </trans-unit>
        <trans-unit id="c99d7d2ec0751d55a79f6c64ef86b68f3b33366c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={local,Name}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;ServerName={local,Name}&lt;/code&gt; 상기 &lt;code&gt;gen_server&lt;/code&gt; 된 프로세스는 로컬로 등록 된 &lt;code&gt;Name&lt;/code&gt; 사용 &lt;code&gt;register/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4471e49d4ac17a2da6d90db02e958498fd4eca78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={via,Module,ViaName}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process registers with the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback is to export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">경우 &lt;code&gt;ServerName={via,Module,ViaName}&lt;/code&gt; 는 &lt;code&gt;gen_server&lt;/code&gt; 의 레지스트리와 프로세스 레지스터로 표시 &lt;code&gt;Module&lt;/code&gt; . &lt;code&gt;Module&lt;/code&gt; 콜백 함수 내보내이다 &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , &lt;code&gt;whereis_name/1&lt;/code&gt; , 및 &lt;code&gt;send/2&lt;/code&gt; 에 대응하는 기능처럼 동작한다, &lt;code&gt;global&lt;/code&gt; . 따라서 &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; 은 유효한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="1a7d3d4777e0d9530a017faf5e5e71aeba400cf2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Server_or_Actions&lt;/code&gt; is a &lt;code&gt;list()&lt;/code&gt;, the same as &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; except that no &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; must have been registered and &lt;code&gt;Actions = Server_or_Actions&lt;/code&gt;. This creates an anonymous server.</source>
          <target state="translated">경우 &lt;code&gt;Server_or_Actions&lt;/code&gt; 는 A는 &lt;code&gt;list()&lt;/code&gt; 와 동일한 &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; 없는 것을 제외 &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; 등록되어 있지 않은해야하고 &lt;code&gt;Actions = Server_or_Actions&lt;/code&gt; . 이것은 익명 서버를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0cc5ba33de3003e688f8911d6e6894d616033d12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SetFun&lt;/code&gt; is a number i &amp;gt;= 1 and &lt;code&gt;Set1&lt;/code&gt; is a relation, then the returned set is the &lt;code&gt;&lt;a href=&quot;#projection&quot;&gt;projection&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Set1&lt;/code&gt; onto coordinate i.</source>
          <target state="translated">경우 &lt;code&gt;SetFun&lt;/code&gt; 는 숫자 I&amp;gt; = 1이며 &lt;code&gt;Set1&lt;/code&gt; 과는 , 릴레이션이다 후 리턴 세트가 인 &lt;code&gt;&lt;a href=&quot;#projection&quot;&gt;projection&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;Set1&lt;/code&gt; I 좌표 상.</target>
        </trans-unit>
        <trans-unit id="fa9d9044e1d8e367fe63682c042ce5ba7e21718e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is a ordinary &lt;code&gt;socket()&lt;/code&gt;: upgrades a &lt;code&gt;gen_tcp&lt;/code&gt;, or equivalent, socket to an SSL socket, that is, performs the SSL/TLS server-side handshake and returns a TLS socket.</source>
          <target state="translated">경우 &lt;code&gt;Socket&lt;/code&gt; 평범 &lt;code&gt;socket()&lt;/code&gt; 하십시오 업그레이드 &lt;code&gt;gen_tcp&lt;/code&gt; , 수행하는 SSL / TLS 서버 측 악수 리턴한다 TLS 소켓 인 SSL 소켓에, 또는 이에 상응하는, 소켓.</target>
        </trans-unit>
        <trans-unit id="3a8532805c883f6bbdef2dbf1ab5fafde57ede65" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is a ordinary &lt;code&gt;socket()&lt;/code&gt;: upgrades a &lt;code&gt;gen_tcp&lt;/code&gt;, or equivalent, socket to an SSL socket, that is, performs the TLS server-side handshake and returns a TLS socket.</source>
          <target state="translated">경우 &lt;code&gt;Socket&lt;/code&gt; 평범 &lt;code&gt;socket()&lt;/code&gt; 하십시오 업그레이드 &lt;code&gt;gen_tcp&lt;/code&gt; 인 SSL 소켓, 수행하는 TLS 서버 측 악수 리턴한다 TLS 소켓 또는 이와 동등한, 소켓.</target>
        </trans-unit>
        <trans-unit id="f51cfa021b587914b8d535a367aab8a9c4e3a8b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;#type-sslsocket&quot;&gt; sslsocket() &lt;/a&gt;&lt;/code&gt;: provides extra TLS/DTLS options to those specified in &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; and then performs the TLS/DTLS handshake. Returns a new TLS/DTLS socket if the handshake is successful.</source>
          <target state="translated">경우 &lt;code&gt;Socket&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;#type-sslsocket&quot;&gt; sslsocket() &lt;/a&gt;&lt;/code&gt; : / 추가 TLS를 제공에 지정된 것과 옵션 DTLS &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; 다음 TLS / DTLS 핸드 셰이크를 수행합니다. 핸드 셰이크가 성공하면 새 TLS / DTLS 소켓을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="da7fd7fd2a8598b74434eb489d432414fe4daa4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is an &lt;code&gt;sslsocket()&lt;/code&gt;: provides extra SSL/TLS/DTLS options to those specified in &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; and then performs the SSL/TLS/DTLS handshake. Returns a new TLS/DTLS socket if the handshake is successful.</source>
          <target state="translated">경우 &lt;code&gt;Socket&lt;/code&gt; 입니다 &lt;code&gt;sslsocket()&lt;/code&gt; : 추가 SSL은 / TLS / DTLS의에 지정된 것과 옵션 제공 &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; 다음과는 SSL / TLS / DTLS 악수를 수행합니다. 핸드 셰이크가 성공하면 새 TLS / DTLS 소켓을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4841c9f7a71e862586a5146811fbbbda9e0a5d0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; refers to a filename, it is opened with &lt;code&gt;read&lt;/code&gt; mode prepended to the mode list before the copy, and closed when done.</source>
          <target state="translated">&lt;code&gt;Source&lt;/code&gt; 가 파일 이름을 참조하는 경우 , 복사하기 전에 모드 목록 앞에 &lt;code&gt;read&lt;/code&gt; 모드 가있는 상태로 열리고 완료되면 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="b32d5c9aabdee11f000c96e5dc5cd00d32eea8d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SpecsIn=[Spec1,Spec2,...]&lt;/code&gt;, separate tests will be created per specification. If &lt;code&gt;SpecsIn=[[Spec1,Spec2,...]]&lt;/code&gt;, all specifications will be merge into one test.</source>
          <target state="translated">경우 &lt;code&gt;SpecsIn=[Spec1,Spec2,...]&lt;/code&gt; , 분리 시험 사양에 따라 생성된다. 경우 &lt;code&gt;SpecsIn=[[Spec1,Spec2,...]]&lt;/code&gt; , 모든 사양은 하나 개의 테스트에 병합 될 것이다.</target>
        </trans-unit>
        <trans-unit id="64318942ad99e2a283846e85b41c1a1a90a245d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Streams&lt;/code&gt; is an empty list, &lt;strong&gt;all&lt;/strong&gt; streams are requested by sending the following filter:</source>
          <target state="translated">경우 &lt;code&gt;Streams&lt;/code&gt; 빈 목록입니다, &lt;strong&gt;모든&lt;/strong&gt; 스트림은 다음 필터를 보내 주시기 바랍니다 :</target>
        </trans-unit>
        <trans-unit id="5a57f3a703460decb9f940e7b918e0ac60764ffe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={global,Name}&lt;/code&gt;, the supervisor bridge is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt; global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;SupBridgeName={global,Name}&lt;/code&gt; , 감독자 다리로 전 세계적으로 등록 된 &lt;code&gt;Name&lt;/code&gt; 사용 &lt;code&gt; global:register_name/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0bddbecc2df41f591669985046f32e7a92f59d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={global,Name}&lt;/code&gt;, the supervisor bridge is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;SupBridgeName={global,Name}&lt;/code&gt; , 감독자 다리로 전 세계적으로 등록 된 &lt;code&gt;Name&lt;/code&gt; 사용 &lt;code&gt;global:register_name/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55b58db32cac80b6fba959bc6eb9beb456afa271" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={local,Name}&lt;/code&gt;, the supervisor bridge is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;SupBridgeName={local,Name}&lt;/code&gt; 감독자 다리 같이 국부적으로 등록 된 &lt;code&gt;Name&lt;/code&gt; 사용 &lt;code&gt;register/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72424d21ee1e4f64401815083aa13a425812c98c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={via,Module,Name}&lt;/code&gt;, the supervisor bridge is registered as &lt;code&gt;Name&lt;/code&gt; using a registry represented by Module. The &lt;code&gt;Module&lt;/code&gt; callback is to export functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">경우 &lt;code&gt;SupBridgeName={via,Module,Name}&lt;/code&gt; , 감독자 다리로 등록 된 &lt;code&gt;Name&lt;/code&gt; 모듈로 표시되는 레지스트리를 사용. &lt;code&gt;Module&lt;/code&gt; 수출 함수가 콜백입니다 &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , 및 &lt;code&gt;send/2&lt;/code&gt; 에서 해당 기능처럼 행동 할 수있는, &lt;code&gt;global&lt;/code&gt; . 따라서 &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; 은 유효한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="e6570ba727a9a3893fd9a3d0b799b833bf1451e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={global,Name}&lt;/code&gt;, the supervisor is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt; global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;SupName={global,Name}&lt;/code&gt; , 감독자는 다음과 같이 전 세계적으로 등록 된 &lt;code&gt;Name&lt;/code&gt; 사용 &lt;code&gt; global:register_name/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e7b2fcdf9c47fb2dceee651299ffa41113ce50c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={global,Name}&lt;/code&gt;, the supervisor is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;SupName={global,Name}&lt;/code&gt; , 감독자는 다음과 같이 전 세계적으로 등록 된 &lt;code&gt;Name&lt;/code&gt; 사용 &lt;code&gt;global:register_name/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a94898f62db8e0366c9e39384d40e7b1aeef50e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={local,Name}&lt;/code&gt;, the supervisor is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;SupName={local,Name}&lt;/code&gt; 감독자가 로컬로 등록 된 &lt;code&gt;Name&lt;/code&gt; 사용 &lt;code&gt;register/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="302a4ec0f93e1a3b85f4525fc68100cb7ea134fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={via,Module,Name}&lt;/code&gt;, the supervisor is registered as &lt;code&gt;Name&lt;/code&gt; using the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback must export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which must behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,Name}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">경우 &lt;code&gt;SupName={via,Module,Name}&lt;/code&gt; , 감독자는 다음과 같이 등록 된 &lt;code&gt;Name&lt;/code&gt; 으로 표시 레지스트리 사용하여 &lt;code&gt;Module&lt;/code&gt; . &lt;code&gt;Module&lt;/code&gt; 기능을 내 보내야합니다 콜백 &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , 및 &lt;code&gt;send/2&lt;/code&gt; 에서 해당 기능처럼 행동해야하며, &lt;code&gt;global&lt;/code&gt; . 따라서 &lt;code&gt;{via,global,Name}&lt;/code&gt; 은 유효한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="e19abc8d0154d9b15c235deec3229c13afe0bfd1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Suspendee&lt;/code&gt; is not a process identifier.</source>
          <target state="translated">&lt;code&gt;Suspendee&lt;/code&gt; 가 프로세스 식별자가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="c9f3eb71690e00c625f528d1a166e4c2803c3742" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Term&lt;/code&gt; and &lt;code&gt;Pattern&lt;/code&gt; can be matched, the function returns a non-zero value and binds any unbound variables in &lt;code&gt;Pattern&lt;/code&gt;. If &lt;code&gt;Term&lt;/code&gt; and &lt;code&gt;Pattern&lt;/code&gt; do not match, &lt;code&gt;0&lt;/code&gt; is returned. For example:</source>
          <target state="translated">경우 &lt;code&gt;Term&lt;/code&gt; 및 &lt;code&gt;Pattern&lt;/code&gt; 매칭 될 수있는 기능은 비 - 제로 값 및 바인드 어떤 결합되지 않은 변수 반환 &lt;code&gt;Pattern&lt;/code&gt; . 경우 &lt;code&gt;Term&lt;/code&gt; 과 &lt;code&gt;Pattern&lt;/code&gt; 일치하지 않는, &lt;code&gt;0&lt;/code&gt; 이 반환됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c379e61ba098c472d84880da68787d8cf49e4a92" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is &lt;code&gt;infinity&lt;/code&gt;, no timer is started, as it never would expire anyway.</source>
          <target state="translated">경우 &lt;code&gt;Time&lt;/code&gt; 입니다 &lt;code&gt;infinity&lt;/code&gt; 어쨌든 만료되지 못했네으로, 더 타이머가 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="361b493363d47b76898e36a3b534cb11d8d0b1ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is relative and &lt;code&gt;0&lt;/code&gt; no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event, but after already queued events.</source>
          <target state="translated">경우 &lt;code&gt;Time&lt;/code&gt; 상대적이며 &lt;code&gt;0&lt;/code&gt; 에는 타이머가 실제로 시작되지 않으며, 대신 시간 제한 이벤트는 아직 외부 이벤트를 받았지만, 이후 이미 이벤트를 대기하지 전에 처리됩니다 수 있도록 대기열에.</target>
        </trans-unit>
        <trans-unit id="53be15db077d9f7386a9212d414b5bbc5efc8b98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is relative and &lt;code&gt;0&lt;/code&gt; no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event.</source>
          <target state="translated">&lt;code&gt;Time&lt;/code&gt; 이 상대적이고 &lt;code&gt;0&lt;/code&gt; 으로 타이머가 실제로 시작되지 않은 경우, 시간 종료 이벤트가 큐에 대기되어 아직 외부 이벤트를 수신하지 전에 처리되도록합니다.</target>
        </trans-unit>
        <trans-unit id="576d56f7b80afa9316129970fc76da4c8c90a6b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is specified as an integer, this function waits for &lt;code&gt;Time&lt;/code&gt; milliseconds for the new process to call &lt;code&gt;init_ack&lt;/code&gt;, or &lt;code&gt;Ret = {error, timeout}&lt;/code&gt; will be returned, and the process is killed.</source>
          <target state="translated">경우 &lt;code&gt;Time&lt;/code&gt; 정수로 지정되어,이 기능의 대기 &lt;code&gt;Time&lt;/code&gt; 새로운 프로세스 (밀리 초) 호출 할 &lt;code&gt;init_ack&lt;/code&gt; , 또는 &lt;code&gt;Ret = {error, timeout}&lt;/code&gt; 반환되며, 프로세스가 살해된다.</target>
        </trans-unit>
        <trans-unit id="df42bd176e1545f79c00a2e65e652086e9d32d4d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is specified as an integer, this function waits for &lt;code&gt;Time&lt;/code&gt; milliseconds for the new process to call &lt;code&gt;init_ack&lt;/code&gt;, or &lt;code&gt;{error, timeout}&lt;/code&gt; is returned, and the process is killed.</source>
          <target state="translated">경우 &lt;code&gt;Time&lt;/code&gt; 정수로 지정되어,이 기능의 대기 &lt;code&gt;Time&lt;/code&gt; 새로운 프로세스 (밀리 초) 호출 할 &lt;code&gt;init_ack&lt;/code&gt; , 또는 &lt;code&gt;{error, timeout}&lt;/code&gt; 반환되고, 프로세스가 살해된다.</target>
        </trans-unit>
        <trans-unit id="4be60462090656e0a73c06a85dd1300e3f12ecfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Timeout&lt;/code&gt; is set to an integer value in milliseconds, Mnesia forces &quot;heavyweight transactions&quot; to be finished, even if the outcome of the transaction for the moment is unclear. After &lt;code&gt;Timeout&lt;/code&gt; milliseconds, Mnesia commits or terminates the transaction and continues with the startup. This can lead to a situation where the transaction is committed on some nodes and terminated on other nodes. If the transaction is a schema transaction, the inconsistency can be fatal.</source>
          <target state="translated">경우 &lt;code&gt;Timeout&lt;/code&gt; 밀리 초 단위의 정수 값으로 설정되고, Mnesia 힘 &quot;헤비급 거래는&quot;현재의 트랜잭션의 결과가 불분명 한 경우에도, 완료한다. &lt;code&gt;Timeout&lt;/code&gt; 밀리 초 후에 Mnesia는 트랜잭션을 커밋 또는 종료하고 시작을 계속합니다. 이로 인해 일부 노드에서 트랜잭션이 커밋되고 다른 노드에서 트랜잭션이 종료 될 수 있습니다. 트랜잭션이 스키마 트랜잭션 인 경우 불일치가 치명적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="714a8fc4e60ac83febb0eba6e2e43aa29c1e43cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;To &amp;gt; From - Incr&lt;/code&gt; and &lt;code&gt;Incr &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">받는 &lt;code&gt;To &amp;gt; From - Incr&lt;/code&gt; 및 &lt;code&gt;Incr &amp;lt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="116f28b654e1b2114f084ce63da092181669b950" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;To &amp;lt; From - Incr&lt;/code&gt; and &lt;code&gt;Incr &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;To &amp;lt; From - Incr&lt;/code&gt; 와 &lt;code&gt;Incr &amp;gt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54f93f73769a89bfaa867aaa2f8894d3965b6413" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TupleOfBinRels&lt;/code&gt; is a non-empty tuple {R[1], ..., R[n]} of binary relations and &lt;code&gt;BinRel1&lt;/code&gt; is a binary relation, then &lt;code&gt;BinRel2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#multiple_relative_product&quot;&gt;multiple relative product&lt;/a&gt;&lt;/code&gt; of the ordered set (R[i], ..., R[n]) and &lt;code&gt;BinRel1&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;TupleOfBinRels&lt;/code&gt; 가 {R [1], ..., R [N]} 이진 관계 비어 튜플이고 &lt;code&gt;BinRel1&lt;/code&gt; 는 이진 관계이다 후 &lt;code&gt;BinRel2&lt;/code&gt; 은 은 IS &lt;code&gt;&lt;a href=&quot;#multiple_relative_product&quot;&gt;multiple relative product&lt;/a&gt;&lt;/code&gt; 순서화 세트 (R은, [I] ..., R [n]) 및 &lt;code&gt;BinRel1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c970d03f8f213aa54cea6a63852543e1427736a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = load&lt;/code&gt;, the application is only loaded.</source>
          <target state="translated">경우 &lt;code&gt;Type = load&lt;/code&gt; 응용 프로그램은로드됩니다.</target>
        </trans-unit>
        <trans-unit id="ef46ddc91155f5582e897510a78e384c324f3ca3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = none&lt;/code&gt;, the application is not loaded and not started, although the code for its modules is loaded.</source>
          <target state="translated">&lt;code&gt;Type = none&lt;/code&gt; 인 경우 해당 모듈의 코드가로드되었지만 응용 프로그램이로드되지 않고 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee9c99386deae4cad26ab6d667423f3c8e7d9d82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = permanent | transient | temporary&lt;/code&gt;, the application is loaded and started in the corresponding way, see &lt;code&gt;application(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type = permanent | transient | temporary&lt;/code&gt; 경우 | 과도 | 임시 응용 프로그램이로드되고 시작 대응하는 방식으로 참조되는 &lt;code&gt;application(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80d0f32ad447a0f124722ae3ffd089ea15b0187a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;file&lt;/code&gt;, the client reads all trace messages stored in the file named &lt;code&gt;Filename&lt;/code&gt; or specified by &lt;code&gt;WrapFilesSpec&lt;/code&gt; (must be the same as used when creating the trace, see trace_port/2) and let's the default handler function format the messages on the console. This is one way to interpret the data stored in a file by the file trace port driver.</source>
          <target state="translated">경우 &lt;code&gt;Type&lt;/code&gt; 이다 &lt;code&gt;file&lt;/code&gt; , 클라이언트라는 이름의 파일에 저장된 모든 추적 메시지를 읽고 &lt;code&gt;Filename&lt;/code&gt; 또는 지정된 &lt;code&gt;WrapFilesSpec&lt;/code&gt; 를 콘솔 및하자의 기본 핸들러 함수 형식 메시지 (같은 추적을 만들 때 사용되는, trace_port / 2 참조를해야합니다) . 파일 추적 포트 드라이버가 파일에 저장된 데이터를 해석하는 한 가지 방법입니다.</target>
        </trans-unit>
        <trans-unit id="a4858c659d369e53d254b355df46af5fbf4c16d3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;follow_file&lt;/code&gt;, the client behaves as in the &lt;code&gt;file&lt;/code&gt; case, but keeps trying to read (and process) more data from the file until stopped by &lt;code&gt;&lt;a href=&quot;#stop_trace_client-1&quot;&gt;stop_trace_client/1&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;WrapFilesSpec&lt;/code&gt; is not allowed as second argument for this &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Type&lt;/code&gt; 이다 &lt;code&gt;follow_file&lt;/code&gt; , 클라이언트 상기와 같이 동작합니다 &lt;code&gt;file&lt;/code&gt; 의 경우,하지만 의해 중단 될 때까지 파일에서 더 많은 데이터를 읽고 (공정)하려고 계속 &lt;code&gt;&lt;a href=&quot;#stop_trace_client-1&quot;&gt;stop_trace_client/1&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;WrapFilesSpec&lt;/code&gt; 은이 &lt;code&gt;Type&lt;/code&gt; 의 두 번째 인수로 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="180a1fd075134b1e3a57e62da41207ab78634934" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;ip&lt;/code&gt;, the client connects to the TCP/IP port &lt;code&gt;PortNumber&lt;/code&gt; on the host &lt;code&gt;Hostname&lt;/code&gt;, from where it reads trace messages until the TCP/IP connection is closed. If no &lt;code&gt;Hostname&lt;/code&gt; is specified, the local host is assumed.</source>
          <target state="translated">경우 &lt;code&gt;Type&lt;/code&gt; 입니다 &lt;code&gt;ip&lt;/code&gt; 의 TCP / IP 포트로 클라이언트 커넥트 &lt;code&gt;PortNumber&lt;/code&gt; 이 호스트의 &lt;code&gt;Hostname&lt;/code&gt; 이 추적 메시지를 읽는 경우, TCP / IP 연결이 닫힐 때까지에서. &lt;code&gt;Hostname&lt;/code&gt; 을 지정 하지 않으면 로컬 호스트로 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="e7f9b8934106158303967177ea69d38323fb0f5a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;port&lt;/code&gt;, then the second parameter should be a &lt;strong&gt;fun&lt;/strong&gt; which takes no arguments and returns a newly opened trace port when called. Such a &lt;strong&gt;fun&lt;/strong&gt; is preferably generated by calling &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Type&lt;/code&gt; 입니다 &lt;code&gt;port&lt;/code&gt; , 다음 두 번째 매개 변수는해야 &lt;strong&gt;재미&lt;/strong&gt; 인수를 취하지 않고 호출시에 새롭게 문을 연 추적 포트를 반환합니다. 이러한 &lt;strong&gt;재미&lt;/strong&gt; 는 바람직하게 &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="dcff9f93e9e05e724456b0bced8193fb3bde0690" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;process&lt;/code&gt;, a message handler function can be specified (&lt;code&gt;HandlerSpec&lt;/code&gt;). The handler function, which should be a &lt;code&gt;fun&lt;/code&gt; taking two arguments, will be called for each trace message, with the first argument containing the message as it is and the second argument containing the return value from the last invocation of the fun. The initial value of the second parameter is specified in the &lt;code&gt;InitialData&lt;/code&gt; part of the &lt;code&gt;HandlerSpec&lt;/code&gt;. The &lt;code&gt;HandlerFun&lt;/code&gt; may choose any appropriate action to take when invoked, and can save a state for the next invocation by returning it.</source>
          <target state="translated">경우 &lt;code&gt;Type&lt;/code&gt; 이다 &lt;code&gt;process&lt;/code&gt; , 메시지 핸들러 함수는 (지정할 수 있습니다 &lt;code&gt;HandlerSpec&lt;/code&gt; 을 ). 핸들러 함수는 두 개의 인수를 갖는 &lt;code&gt;fun&lt;/code&gt; 여야하는 각 추적 메시지에 대해 호출되며 첫 번째 인수는 메시지를 그대로 포함하고 두 번째 인수는 마지막 호출의 리턴 값을 포함합니다. 두 번째 매개 변수의 초기 값은 &lt;code&gt;HandlerSpec&lt;/code&gt; 의 &lt;code&gt;InitialData&lt;/code&gt; 부분에 지정됩니다 . &lt;code&gt;HandlerFun&lt;/code&gt; 는 호출 할 때 수행 할 적절한 조치를 선택할 수 있습니다, 그것을 반환하여 다음의 호출에 대한 상태를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4b1b3641b22ef8f8d51a93d3b2d1b2337213cb2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;public_key&lt;/code&gt; the binary can be either an RFC4716 public key or an OpenSSH public key.</source>
          <target state="translated">경우 &lt;code&gt;Type&lt;/code&gt; 입니다 &lt;code&gt;public_key&lt;/code&gt; 바이너리는 RFC4716 공개 키 또는 OpenSSH의 공개 키가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25a5ca48186c13c4c06e74ef1db2027011e4bcd7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;table&lt;/code&gt;, the object to match against is to be a tuple. The function then returns &lt;code&gt;{ok,Result,[],Warnings}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is what would have been the result in a real &lt;code&gt;ets:select/2&lt;/code&gt; call, or &lt;code&gt;false&lt;/code&gt; if the match specification does not match the object tuple.</source>
          <target state="translated">경우 &lt;code&gt;Type&lt;/code&gt; 이다 &lt;code&gt;table&lt;/code&gt; , 반대 일치하는 객체는 튜플이 될 것입니다. 그런 다음이 함수는 &lt;code&gt;{ok,Result,[],Warnings}&lt;/code&gt; 를 반환합니다 . 여기서 &lt;code&gt;Result&lt;/code&gt; 는 실제 &lt;code&gt;ets:select/2&lt;/code&gt; 호출 에서 결과 가되었던 것입니다 . 일치 사양이 객체 튜플과 일치하지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="79b1b01424133793a9f87e15e6618830f393c840" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;trace&lt;/code&gt;, the object to match against is to be a list. The function returns &lt;code&gt;{ok, Result, Flags, Warnings}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is one of the following:</source>
          <target state="translated">경우 &lt;code&gt;Type&lt;/code&gt; 입니다 &lt;code&gt;trace&lt;/code&gt; ,에 일치하는 객체 목록이 될 것입니다. 이 함수는 &lt;code&gt;{ok, Result, Flags, Warnings}&lt;/code&gt; 반환합니다 . 여기서 &lt;code&gt;Result&lt;/code&gt; 는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="55c96c3e31c21901d76762cfc3c55a1a75e182d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is not one of the memory types listed in the description of &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Type&lt;/code&gt; 에 대한 설명에 나와있는 메모리 타입 중 하나가 아닌 &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f09015d085c4ba86f35f77e160ea74ab1cc97841" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[]&lt;/code&gt; is returned, no OS monotonic time is available. The list contains two-tuples with &lt;code&gt;Key&lt;/code&gt;s as first element, and &lt;code&gt;Value&lt;/code&gt;s as second element. The order of these tuples is undefined. The following tuples can be part of the list, but more tuples can be introduced in the future:</source>
          <target state="translated">경우 &lt;code&gt;[]&lt;/code&gt; 반환, 어떤 OS 단조 시간을 사용할 수 없습니다. 리스트에는 &lt;code&gt;Key&lt;/code&gt; 가 첫 번째 요소이고 &lt;code&gt;Value&lt;/code&gt; 가 두 번째 요소 인 두 개의 튜플이 포함 됩니다. 이 튜플의 순서는 정의되어 있지 않습니다. 다음 튜플이 목록에 포함될 수 있지만 앞으로 더 많은 튜플이 도입 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dab6e7436a7ad654f072804193938c789548d28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[node()]&lt;/code&gt; then a connection is rejected if another already exists on any of the specified nodes. Types &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;node&lt;/code&gt;, &lt;code&gt;nodes&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; are equivalent to &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;[node()]&lt;/code&gt;, &lt;code&gt;[node()|nodes()]&lt;/code&gt; and the evaluated value respectively, evaluation of each expression taking place whenever a new connection is to be established. Note that &lt;code&gt;false&lt;/code&gt; allows an unlimited number of connections to be established with the same peer.</source>
          <target state="translated">경우 &lt;code&gt;[node()]&lt;/code&gt; 또 이미 지정된 노드의에 존재하는 경우 다음 연결이 거부됩니다. 유형 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;node&lt;/code&gt; , &lt;code&gt;nodes&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 동등 &lt;code&gt;[]&lt;/code&gt; 는 , &lt;code&gt;[node()]&lt;/code&gt; , &lt;code&gt;[node()|nodes()]&lt;/code&gt; 와 평가 값이 각각 발생하는 각 식의 평가는 새로운 연결을 할 때마다 설립. 참고 &lt;code&gt;false&lt;/code&gt; 연결의 수를 제한은 동일한 피어 설립한다.</target>
        </trans-unit>
        <trans-unit id="295d7333eb893d35be93e144e1767e5d9b639f90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;active&lt;/code&gt; is specified as an integer &lt;code&gt;N&lt;/code&gt; in the range -32768 to 32767 (inclusive), that number is added to the socket's counting of data messages to be delivered to the controlling process. If the result of the addition is negative, the count is set to &lt;code&gt;0&lt;/code&gt;. Once the count reaches &lt;code&gt;0&lt;/code&gt;, either through the delivery of messages or by being explicitly set with &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt;, the socket mode is automatically reset to passive (&lt;code&gt;{active, false}&lt;/code&gt;). When a socket in this active mode transitions to passive mode, the message &lt;code&gt;{sctp_passive, Socket}&lt;/code&gt; is sent to the controlling process to notify it that if it wants to receive more data messages from the socket, it must call &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; to set the socket back into an active mode.</source>
          <target state="translated">&lt;code&gt;active&lt;/code&gt; 가 -32768 ~ 32767 (포함) 범위 의 정수 &lt;code&gt;N&lt;/code&gt; 으로 지정된 경우 해당 번호는 제어 프로세스로 전달 될 소켓의 데이터 메시지 계수에 추가됩니다. 더하기 결과가 음수이면 카운트는 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 메시지 전달을 통해 또는 &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; 로 명시 적으로 설정 하여 카운트가 &lt;code&gt;0&lt;/code&gt; 에 도달 하면 소켓 모드는 자동으로 수동 ( &lt;code&gt;{active, false}&lt;/code&gt; ) 으로 재설정됩니다 . 이 활성 모드의 소켓이 수동 모드로 전환되면 &lt;code&gt;{sctp_passive, Socket}&lt;/code&gt; 메시지 가 제어 프로세스로 전송되어 소켓에서 더 많은 데이터 메시지를 수신하려면 호출해야 함을 알려줍니다. &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; 소켓을 다시 활성 모드로 설정하려면 inet : setopts / 2 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="03b183ed01691db59614d150f25d033d938031cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alloc&lt;/code&gt; succeeds, &lt;code&gt;dealloc&lt;/code&gt; is also executed. If &lt;code&gt;alloc&lt;/code&gt; fails however, &lt;code&gt;dealloc&lt;/code&gt; is not executed but marked as &lt;code&gt;SKIPPED&lt;/code&gt; in the HTML log. &lt;code&gt;get_resource_status&lt;/code&gt; runs no matter what happens to the &lt;code&gt;alloc_and_dealloc&lt;/code&gt; cases.</source>
          <target state="translated">경우 &lt;code&gt;alloc&lt;/code&gt; 성공 &lt;code&gt;dealloc&lt;/code&gt; 또한 실행된다. 그러나 &lt;code&gt;alloc&lt;/code&gt; 이 실패하면 &lt;code&gt;dealloc&lt;/code&gt; 이 실행되지 않지만 HTML 로그에서 &lt;code&gt;SKIPPED&lt;/code&gt; 로 표시됩니다 . &lt;code&gt;get_resource_status&lt;/code&gt; 는 &lt;code&gt;alloc_and_dealloc&lt;/code&gt; 경우에 관계없이 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="352b5321f6cc2147596cc6f32fa64b28aba14c20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;answer_3xxx&lt;/code&gt; then requests are answered without a &lt;code&gt;handle_request/3&lt;/code&gt; callback taking place. If &lt;code&gt;answer&lt;/code&gt; then even 5xxx errors are answered without a callback unless the connection in question has configured the RFC 3588 common dictionary as noted below. If &lt;code&gt;callback&lt;/code&gt; then a &lt;code&gt;handle_request/3&lt;/code&gt; callback always takes place and its return value determines the answer sent to the peer, if any.</source>
          <target state="translated">&lt;code&gt;answer_3xxx&lt;/code&gt; 인 경우 handle_request &lt;code&gt;handle_request/3&lt;/code&gt; 콜백 없이 요청에 응답 합니다. &lt;code&gt;answer&lt;/code&gt; 하면 해당 연결이 RFC 3588 공통 사전을 아래와 같이 구성하지 않는 한 콜백없이 5xxx 오류도 응답됩니다. 경우 &lt;code&gt;callback&lt;/code&gt; 다음 &lt;code&gt;handle_request/3&lt;/code&gt; 콜백 항상 발생하고있는 경우 반환 값은, 피어에 송신 답을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="cdb44b71a12e090bedfcba4386a9f7329590c298" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;audit_trail_log&lt;/code&gt; specifies that logging should take place, this parameter &lt;strong&gt;must&lt;/strong&gt; be defined.</source>
          <target state="translated">경우 &lt;code&gt;audit_trail_log&lt;/code&gt; 의 지정 로깅이 수행해야한다는,이 매개 변수가 &lt;strong&gt;있어야&lt;/strong&gt; 정의 될 수있다.</target>
        </trans-unit>
        <trans-unit id="5c3452c6586d61bda15fc59fe771d58878ac0b8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;auto_ack&lt;/code&gt; is true, then if &lt;code&gt;trans_ack&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, ack's will be sent immediately. If &lt;code&gt;trans_ack&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then ack's will instead be sent to the transaction sender process for accumulation and later sending (see &lt;code&gt;trans_ack_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxsize&lt;/code&gt;, &lt;code&gt;trans_ack_maxcount&lt;/code&gt; and &lt;code&gt;trans_timer&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;auto_ack&lt;/code&gt; 는 사실, 다음 경우 &lt;code&gt;trans_ack&lt;/code&gt; 이 있다 &lt;code&gt;false&lt;/code&gt; , ACK의 즉시 전송됩니다. 경우 &lt;code&gt;trans_ack&lt;/code&gt; 이 있다 &lt;code&gt;true&lt;/code&gt; , 다음의 대신 축적 이상 (참조 보내기위한 거래 보낸 사람 처리로 전송됩니다 ACK &lt;code&gt;trans_ack_maxcount&lt;/code&gt; , &lt;code&gt;trans_req_maxcount&lt;/code&gt; , &lt;code&gt;trans_req_maxsize&lt;/code&gt; , &lt;code&gt;trans_ack_maxcount&lt;/code&gt; 및 &lt;code&gt;trans_timer&lt;/code&gt; 을 ).</target>
        </trans-unit>
        <trans-unit id="7f3ff30c8bf2c3590c81efa740a7d601076daf88" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;callback&lt;/code&gt; then errors result in a &lt;code&gt;handle_answer/4&lt;/code&gt; callback in the same fashion as for &lt;code&gt;handle_request/3&lt;/code&gt;, with errors communicated in the &lt;code&gt;errors&lt;/code&gt; field of the &lt;code&gt;#diameter_packet{}&lt;/code&gt; passed to the callback. If &lt;code&gt;report&lt;/code&gt; then an answer containing errors is discarded without a callback and a warning report is written to the log. If &lt;code&gt;discard&lt;/code&gt; then an answer containing errors is silently discarded without a callback. In both the &lt;code&gt;report&lt;/code&gt; and &lt;code&gt;discard&lt;/code&gt; cases the return value for the &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; invocation in question is as if a callback had taken place and returned &lt;code&gt;{error, failure}&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;callback&lt;/code&gt; 후 오류가 발생할 &lt;code&gt;handle_answer/4&lt;/code&gt; 와 동일한 방식으로서 속 콜백 &lt;code&gt;handle_request/3&lt;/code&gt; 에서 통신 에러와, &lt;code&gt;errors&lt;/code&gt; 의 필드 &lt;code&gt;#diameter_packet{}&lt;/code&gt; 콜백으로 전달. &lt;code&gt;report&lt;/code&gt; 경우 오류가 포함 된 답변이 콜백없이 삭제되고 경고 보고서가 로그에 작성됩니다. &lt;code&gt;discard&lt;/code&gt; 하면 오류가 포함 된 답변이 콜백없이 자동으로 삭제됩니다. &lt;code&gt;report&lt;/code&gt; 및 &lt;code&gt;discard&lt;/code&gt; 사례 모두에서 해당 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 호출에 대한 리턴 값 은 콜백이 발생하여 &lt;code&gt;{error, failure}&lt;/code&gt; 리턴 한 것과 같습니다..</target>
        </trans-unit>
        <trans-unit id="62c065b9fb27488b0e771951e56438f1b6383335" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch4&lt;/code&gt; is part of the application &lt;code&gt;sp_app&lt;/code&gt; and a new version of the module is to be loaded when upgrading from version &quot;1&quot; to &quot;2&quot; of this application, &lt;code&gt;sp_app.appup&lt;/code&gt; can look as follows:</source>
          <target state="translated">경우 &lt;code&gt;ch4&lt;/code&gt; 있는 응용 프로그램의 일부 &lt;code&gt;sp_app&lt;/code&gt; 및 모듈의 새 버전은 버전 &quot;1&quot;에서이 응용 프로그램의 &quot;2&quot;로 업그레이드가 될 때로드 될 &lt;code&gt;sp_app.appup&lt;/code&gt; 이 같은 다음 볼 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="704192b50b25e6b4c8a4a69ec853e8732712c9f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cp1&lt;/code&gt; goes down, the system checks which one of the other nodes, &lt;code&gt;cp2&lt;/code&gt; or &lt;code&gt;cp3&lt;/code&gt;, has the least number of running applications, but waits for 5 seconds for &lt;code&gt;cp1&lt;/code&gt; to restart. If &lt;code&gt;cp1&lt;/code&gt; does not restart and &lt;code&gt;cp2&lt;/code&gt; runs fewer applications than &lt;code&gt;cp3&lt;/code&gt;, &lt;code&gt;myapp&lt;/code&gt; is restarted on &lt;code&gt;cp2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;cp1&lt;/code&gt; 다운되면, 시스템의 다른 노드 중 하나를 확인 &lt;code&gt;cp2&lt;/code&gt; 또는 &lt;code&gt;cp3&lt;/code&gt; , 실행중인 응용 프로그램의 최소 수를 가지고 있지만, 5 초 동안 대기 &lt;code&gt;cp1&lt;/code&gt; 다시 시작합니다. 경우 &lt;code&gt;cp1&lt;/code&gt; 다시 시작하지 않고 &lt;code&gt;cp2&lt;/code&gt; 보다 적은 수의 응용 프로그램을 실행 &lt;code&gt;cp3&lt;/code&gt; , &lt;code&gt;myapp&lt;/code&gt; 와는 에서 다시 시작 &lt;code&gt;cp2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b17771800350279f555431c07bc7909375d85a40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ct_run&lt;/code&gt; is called with option &lt;code&gt;-help&lt;/code&gt;, it prints all valid start flags to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ct_run&lt;/code&gt; 이 &lt;code&gt;-help&lt;/code&gt; 옵션과 함께 호출 되면 유효한 모든 시작 플래그를 &lt;code&gt;stdout&lt;/code&gt; 에 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="8d7ad1711ae125314f622ecddd1f476bedaa098f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;drop_mode_qlen&lt;/code&gt; is set to the same value as &lt;code&gt;flush_qlen&lt;/code&gt;, drop mode is disabled and can never occur.</source>
          <target state="translated">경우 &lt;code&gt;drop_mode_qlen&lt;/code&gt; 가 같은 값으로 설정 &lt;code&gt;flush_qlen&lt;/code&gt; , 드롭 모드를 사용할 수 없습니다 발생할 수 없다.</target>
        </trans-unit>
        <trans-unit id="c399745e103b947fe1a2d216d913038686b47941" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ei_set_compat_rel(21)&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; called then a connected emulator will send bit strings and export funs correctly encoded. The functions &lt;code&gt;&lt;a href=&quot;#ei_decode_bitstring&quot;&gt;ei_decode_bitstring&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#ei_decode_fun&quot;&gt;ei_decode_fun&lt;/a&gt;&lt;/code&gt; has to be used to decode such terms. Calling &lt;code&gt;ei_set_compat_rel(21)&lt;/code&gt; should only be done as a workaround to keep an old implementation alive, which expects to receive the undocumented tuple formats for bit strings and/or export funs.</source>
          <target state="translated">경우 &lt;code&gt;ei_set_compat_rel(21)&lt;/code&gt; 되어 &lt;strong&gt;있지&lt;/strong&gt; 를 호출 해 연결된 에뮬레이터가 제대로 인코딩 된 비트 문자열과 수출 funs입니다 보내드립니다. 이러한 용어를 디코딩하려면 &lt;code&gt;&lt;a href=&quot;#ei_decode_bitstring&quot;&gt;ei_decode_bitstring&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#ei_decode_fun&quot;&gt;ei_decode_fun&lt;/a&gt;&lt;/code&gt; 함수를 사용해야 합니다. &lt;code&gt;ei_set_compat_rel(21)&lt;/code&gt; 호출 은 비트 문자열 및 / 또는 내보내기 재미에 대해 문서화되지 않은 튜플 형식을 수신 할 것으로 예상되는 이전 구현을 유지하기위한 해결 방법으로 만 수행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="173618b78a011b048e525d9c552841f6185552f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_call/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;enabled_call/3&lt;/code&gt; 가 정의되어 있지 않으면 대신 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="585b6dae1b75f75f6d17ff008d7c715232f527c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_garbage_collection/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;enabled_garbage_collection/3&lt;/code&gt; 이 정의되지 않은 경우 대신 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6b7353e255834b234c18ea03d27108e34a19f8a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_ports/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;enabled_ports/3&lt;/code&gt; 가 정의되어 있지 않으면 대신 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7d175b45d5ebd8073a81917e2e671529596546a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_procs/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;enabled_procs/3&lt;/code&gt; 가 정의되어 있지 않으면 대신 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0ebe9ceea886c3c6d1719971aa43295e9c7ed38b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_receive/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;enabled_receive/3&lt;/code&gt; 가 정의되지 않은 경우 대신 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="10f4f080f33a6c7add14620c4ce363f7b8950eec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_running_ports/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;enabled_running_ports/3&lt;/code&gt; 가 정의되지 않은 경우 대신 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1c4a84bb3f76762c65d3520facf2a72bcfc1f2ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_running_procs/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;enabled_running_procs/3&lt;/code&gt; 가 정의되지 않은 경우 대신 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b251834b95dc454e5654dddcf65d7d5d05abbdf9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_send/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;enabled_send/3&lt;/code&gt; 가 정의되어 있지 않으면 대신 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="48960527f8e8df817720dc59ec79a9e715127fc2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;encoding&lt;/code&gt; is set to something else than &lt;code&gt;latin1&lt;/code&gt;, the &lt;code&gt;read_line/1&lt;/code&gt; call fails if the data contains characters larger than 255, why module &lt;code&gt;io(3)&lt;/code&gt; is to be preferred when reading such a file.</source>
          <target state="translated">경우 &lt;code&gt;encoding&lt;/code&gt; 다른 이상의 값으로 설정된다 &lt;code&gt;latin1&lt;/code&gt; 상기 &lt;code&gt;read_line/1&lt;/code&gt; 통화 데이터가 255보다 큰 문자가 포함 된 경우 실패 이유 모듈 &lt;code&gt;io(3)&lt;/code&gt; 등의 파일을 읽는 경우에 선호된다.</target>
        </trans-unit>
        <trans-unit id="02ece68d22a0388d64a0607adb76ac441dd5ca33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;epmd&lt;/code&gt; is to be used for node discovery, you typically want to use the (unfortunately undocumented) &lt;code&gt;erl_epmd&lt;/code&gt; module (part of the &lt;code&gt;kernel&lt;/code&gt; application) in order to register the listen port with &lt;code&gt;epmd&lt;/code&gt; and retrieve &lt;code&gt;Creation&lt;/code&gt; to use.</source>
          <target state="translated">경우 &lt;code&gt;epmd&lt;/code&gt; 노드 탐색에 사용되는, 당신은 일반적으로 (불행하게도 문서화) 사용하려는 &lt;code&gt;erl_epmd&lt;/code&gt; 모듈 (의 일부 &lt;code&gt;kernel&lt;/code&gt; (가)와 포트들을 등록하기 위해 응용 프로그램) &lt;code&gt;epmd&lt;/code&gt; 하고 검색 &lt;code&gt;Creation&lt;/code&gt; 사용.</target>
        </trans-unit>
        <trans-unit id="c86ec487c7e02fab4d117367477d9817cdcbd441" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;epmd&lt;/code&gt; is to be used for node discovery, you typically want to use the &lt;code&gt;erl_epmd&lt;/code&gt; module (part of the &lt;code&gt;kernel&lt;/code&gt; application) in order to register the listen port with &lt;code&gt;epmd&lt;/code&gt; and retrieve &lt;code&gt;Creation&lt;/code&gt; to use.</source>
          <target state="translated">경우 &lt;code&gt;epmd&lt;/code&gt; 노드 탐색에 사용되는, 당신은 일반적으로 사용하려는 &lt;code&gt;erl_epmd&lt;/code&gt; 모듈 (의 일부 &lt;code&gt;kernel&lt;/code&gt; (가)와 포트들을 등록하기 위해 응용 프로그램) &lt;code&gt;epmd&lt;/code&gt; 하고 검색 &lt;code&gt;Creation&lt;/code&gt; 사용.</target>
        </trans-unit>
        <trans-unit id="e48eb5a7215dde7b0dc8037cba2427a3618b189d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;erl_script_nocache&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the server adds HTTP header fields preventing proxies from caching the page. This is generally a good idea for dynamic content, as the content often varies between each request. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;erl_script_nocache&lt;/code&gt; 가 설정되어 &lt;code&gt;true&lt;/code&gt; , 서버는 페이지 캐싱 프록시를 방지 HTTP 헤더 필드를 추가합니다. 콘텐츠는 각 요청마다 다를 수 있으므로 일반적으로 동적 콘텐츠에 좋습니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="74b3b9e997b2f242f5469345dd4b6f37734c75d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;erl_script_timeout&lt;/code&gt; sets the time in seconds the server waits between each chunk of data to be delivered through &lt;code&gt;mod_esi:deliver/2&lt;/code&gt;. Default is &lt;code&gt;15&lt;/code&gt;. This is only relevant for scripts that use the erl scheme.</source>
          <target state="translated">경우 &lt;code&gt;erl_script_timeout&lt;/code&gt; 는 데이터 청크의 각각의 서버는 대기를 통해 전달되는 시간 (초)으로 설정 &lt;code&gt;mod_esi:deliver/2&lt;/code&gt; . 기본값은 &lt;code&gt;15&lt;/code&gt; 입니다. 이것은 erl 체계를 사용하는 스크립트에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="642c708a719a284794b6696e0acb8a429739f8e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;error_logger&lt;/code&gt; is not defined in the map, the system default is used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either the option &lt;code&gt;&lt;a href=&quot;erl#+hmaxel&quot;&gt;+hmaxel&lt;/a&gt;&lt;/code&gt; int &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt; erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;error_logger&lt;/code&gt; 이 맵에 정의되지 않은 시스템 기본값이 사용됩니다. 기본 시스템 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. &lt;code&gt;&lt;a href=&quot;erl#+hmaxel&quot;&gt;+hmaxel&lt;/a&gt;&lt;/code&gt; int &lt;code&gt;erl(1)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt; erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt; 옵션으로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7c49f84d1938c55d129db8f559247ec6ced174b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;error_logger&lt;/code&gt; is not defined in the map, the system default is used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either the option &lt;code&gt;&lt;a href=&quot;erl#+hmaxel&quot;&gt;+hmaxel&lt;/a&gt;&lt;/code&gt; int &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;error_logger&lt;/code&gt; 이 맵에 정의되지 않은 시스템 기본값이 사용됩니다. 기본 시스템 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. &lt;code&gt;&lt;a href=&quot;erl#+hmaxel&quot;&gt;+hmaxel&lt;/a&gt;&lt;/code&gt; int &lt;code&gt;erl(1)&lt;/code&gt; 옵션 또는 &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt; 옵션으로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1f0b5e86017500297a623ccd787481972405c5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ev&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, all ones that is &lt;code&gt;-1&lt;/code&gt; type cast to &lt;code&gt;ErlDrvSizeT&lt;/code&gt; are returned.</source>
          <target state="translated">&lt;code&gt;ev&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 인 경우 &lt;code&gt;-1&lt;/code&gt; 유형 인 &lt;code&gt;ErlDrvSizeT&lt;/code&gt; 로 캐스트 된 모든 것이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="20a523dc7e77a84691bbad3e5ffc300c86d69172" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exit&lt;/code&gt; then the transport process in question exits. If &lt;code&gt;handle&lt;/code&gt; then the message is processed as usual, a resulting &lt;code&gt;handle_request/3&lt;/code&gt; or &lt;code&gt;handle_answer/4&lt;/code&gt; callback (if one takes place) indicating the &lt;code&gt;5015&lt;/code&gt; error (DIAMETER_INVALID_MESSAGE_LENGTH). If &lt;code&gt;discard&lt;/code&gt; then the message in question is silently discarded.</source>
          <target state="translated">만약 &lt;code&gt;exit&lt;/code&gt; 후 질문 종료에 전송 프로세스. 경우에 &lt;code&gt;handle&lt;/code&gt; 있는 메시지가 생성 평소대로 처리된다 &lt;code&gt;handle_request/3&lt;/code&gt; 또는 &lt;code&gt;handle_answer/4&lt;/code&gt; (하나가 발생하는 경우)를 나타내는 콜백 &lt;code&gt;5015&lt;/code&gt; 에러 (DIAMETER_INVALID_MESSAGE_LENGTH 참조). 경우 &lt;code&gt;discard&lt;/code&gt; 후 해당 메시지가 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="ca99bf6a729fabb69715993d01ee3f7329b5f3f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;extra&lt;/code&gt; is specified in &lt;code&gt;Options&lt;/code&gt;, the return value is &lt;code&gt;{ok, Epp, Extra}&lt;/code&gt; instead of &lt;code&gt;{ok, Epp}&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;extra&lt;/code&gt; 에 지정된 &lt;code&gt;Options&lt;/code&gt; , 반환 값은 &lt;code&gt;{ok, Epp, Extra}&lt;/code&gt; 대신 &lt;code&gt;{ok, Epp}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="621b05f8dd3dbf24d54370fe9dfbe14fc856ec52" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;extra&lt;/code&gt; is specified in &lt;code&gt;Options&lt;/code&gt;, the return value is &lt;code&gt;{ok, [Form], Extra}&lt;/code&gt; instead of &lt;code&gt;{ok, [Form]}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Options&lt;/code&gt; 에 &lt;code&gt;extra&lt;/code&gt; 가 지정된 경우 반환 값은 &lt;code&gt;{ok, [Form], Extra}&lt;/code&gt; 대신 {ok, [Form], Extra &lt;code&gt;{ok, [Form]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b3047d3a672144cba0e123255c2c3997f12bb72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; (passive mode, the default), the caller must do an explicit &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; call to retrieve the available data from the socket.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 인 경우 (수동 모드, 기본값) 호출자는 소켓에서 사용 가능한 데이터를 검색하기 위해 명시 적 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; 호출을 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="56e3643f360d9383768007f097296d7135ef22f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; then peers are not shared. If &lt;code&gt;[node()]&lt;/code&gt; then peers are shared with the specified list of nodes. If &lt;code&gt;eval()&lt;/code&gt; then peers are shared with the nodes returned by the specified function, evaluated whenever a peer connection becomes available or a remote service requests information about local connections. The value &lt;code&gt;true&lt;/code&gt; is equivalent to &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt;. The value &lt;code&gt;node()&lt;/code&gt; in a list is ignored, so a collection of services can all be configured to share with the same list of nodes.</source>
          <target state="translated">경우 &lt;code&gt;false&lt;/code&gt; 후 동료가 공유되지 않습니다. 경우 &lt;code&gt;[node()]&lt;/code&gt; 다음 동료는 노드의 지정된 목록과 함께 공유됩니다. 경우 &lt;code&gt;eval()&lt;/code&gt; 다음 동료 평가 지정된 함수에 의해 반환 된 노드와 공유하는 피어 연결을 사용할 수있게 또는 로컬 연결에 대한 원격 서비스 요청 정보를 때마다. &lt;code&gt;true&lt;/code&gt; 값 은 &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt; 과 같습니다 . 목록의 &lt;code&gt;node()&lt;/code&gt; 값 은 무시되므로 서비스 모음을 모두 동일한 노드 목록과 공유하도록 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61331cf5138ed4df60722b0902d831feeb5514c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; then remote peers are not used. If &lt;code&gt;[node()]&lt;/code&gt; then only peers from the specified list of nodes are used. If &lt;code&gt;eval()&lt;/code&gt; then only peers returned by the specified function are used, evaluated whenever a remote service communicates information about an available peer connection. The value &lt;code&gt;true&lt;/code&gt; is equivalent to &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt;. The value &lt;code&gt;node()&lt;/code&gt; in a list is ignored.</source>
          <target state="translated">경우 &lt;code&gt;false&lt;/code&gt; 다음 원격 동료가 사용되지 않습니다. 경우 &lt;code&gt;[node()]&lt;/code&gt; 다음 노드의 지정된 목록에서 유일한 동료가 사용된다. 경우 &lt;code&gt;eval()&lt;/code&gt; 만 지정된 함수에 의해 반환 동료가 사용되는 원격 서비스가 가능한 피어 연결에 대한 정보를 전달 할 때마다 평가했다. &lt;code&gt;true&lt;/code&gt; 값 은 &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt; 과 같습니다 . 목록 의 값 &lt;code&gt;node()&lt;/code&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="515f5f660b2b6a5321a3301134d45702f7c8d34e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, disables the client to connect to the server if any user interaction is needed, such as accepting the server to be added to the &lt;code&gt;known_hosts&lt;/code&gt; file, or supplying a password.</source>
          <target state="translated">경우 &lt;code&gt;false&lt;/code&gt; , 사용자와의 상호 작용이 예에 추가 할 서버 수용성으로, 필요한 경우, 서버에 접속하는 클라이언트 비활성화 &lt;code&gt;known_hosts&lt;/code&gt; 파일 또는 암호를 제공.</target>
        </trans-unit>
        <trans-unit id="2f21ed8efde9cbba7a84e9561d2bee32978fafa7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, the key is not saved and the key will still be unknown at the next access of the same host.</source>
          <target state="translated">경우 &lt;code&gt;false&lt;/code&gt; , 키가 저장되지 않고, 키는 여전히 같은 호스트의 다음 액세스에 알 수있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="6c171a334054ea3d178b695378164bb4717dbc73" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;latin1&lt;/code&gt;, no translation of path names is done.</source>
          <target state="translated">경우 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 반환 &lt;code&gt;latin1&lt;/code&gt; 에 , 경로 이름의 번역이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="174e5b29f214dbcb97eabc33b079cdd65ed3ff4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;utf8&lt;/code&gt;, path names are encoded in UTF-8 when creating tar files, and path names are assumed to be encoded in UTF-8 when extracting tar files.</source>
          <target state="translated">경우 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 반환 &lt;code&gt;utf8&lt;/code&gt; , tar 파일을 생성 할 때 경로 이름은 UTF-8 인코딩 및 경로 이름은 tar 파일을 추출 할 때 UTF-8로 인코딩 된 것으로 가정한다.</target>
        </trans-unit>
        <trans-unit id="53f00d54c4cf2784d07f86c8a1f69d22126e8edd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;final&lt;/code&gt; is returned, the time offset was already in the final state. This either because another &lt;code&gt;erlang:system_flag(time_offset, finalize)&lt;/code&gt; call or because &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;final&lt;/code&gt; 반환되고, 오프셋 시간은 최종 상태에서 이미 있었다. 다른 &lt;code&gt;erlang:system_flag(time_offset, finalize)&lt;/code&gt; 호출 또는 &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; 가 사용 되지 않았기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="7d84ff72a66a5f1dc4702c44281724bb233b3cbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, the backup includes only those objects that have been created, modified, or deleted since the last backup or restore (that is, an incremental backup). After the backup, any objects that were marked dirty are now clean, and any objects that had been marked for deletion are deleted.</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 입니다 &lt;code&gt;0&lt;/code&gt; 백업은 (증분 백업입니다) 생성, 수정, 또는 삭제 된 마지막 백업 이후 또는 복원 된 개체 만이 포함되어 있습니다. 백업 후 더티로 표시된 모든 개체가 이제 정리되고 삭제로 표시된 모든 개체가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="1b22e611455eedf00229374381cf3ded5d86286d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;EI_BIN&lt;/code&gt;, a fifth argument &lt;code&gt;int *size&lt;/code&gt; is required, so that the size of the object can be returned.</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 입니다 &lt;code&gt;EI_BIN&lt;/code&gt; , 다섯 번째 인수 &lt;code&gt;int *size&lt;/code&gt; 필요하며, 개체의 크기를 반환 할 수 있습니다 그래서.</target>
        </trans-unit>
        <trans-unit id="5d03c462ed0e1501d3ca648701da33656f727855" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;EI_BIN&lt;/code&gt;, a fifth argument &lt;code&gt;size&lt;/code&gt; is required, indicating the size in bytes of the object pointed to by &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 입니다 &lt;code&gt;EI_BIN&lt;/code&gt; , 다섯 번째 인수 &lt;code&gt;size&lt;/code&gt; 가 가리키는 객체의 크기를 바이트 단위로 나타내는 필요 &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef97c9cebbac0fa5b4a15003e98bfbe9b002c14c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hibernate&lt;/code&gt; is specified instead of a time-out value, the process goes into hibernation when waiting for the next message to arrive (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt; proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;hibernate&lt;/code&gt; 대신 시간 제한 값의 지정된 다음 메시지가 (호출하여 도착하기를 기다릴 때, 프로세스가 최대 절전 모드로 전환 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt; proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="07a12847c8010acaf74585bb590e3d2d2892d7bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hibernate&lt;/code&gt; is specified instead of a time-out value, the process goes into hibernation when waiting for the next message to arrive (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;hibernate&lt;/code&gt; 대신 시간 제한 값의 지정된 다음 메시지가 (호출하여 도착하기를 기다릴 때, 프로세스가 최대 절전 모드로 전환 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4370781db47a41ab4e7732b376aa87b3dd2e229d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indent_opt&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; (default), line breaks are inserted in types, contracts, and Erlang code to improve readability.</source>
          <target state="translated">&lt;code&gt;indent_opt&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; (기본값) 로 설정 되면 가독성을 높이기 위해 유형, 계약 및 Erlang 코드에 줄 바꿈이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="81060f399c0748631583d69217b03e975ffd94c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_group&lt;/code&gt; is skipped, this function is called after &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_group-5&quot;&gt;post_init_per_group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;init_per_group&lt;/code&gt; 가 생략되어,이 기능은 이후라고 &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_group-5&quot;&gt;post_init_per_group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a09af08638c9468193e1b25b2f9c1bcc8d0b0d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; exists, it is called initially before the test cases are executed. It typically contains initializations common for all test cases in the suite, which are only to be performed once. &lt;code&gt;init_per_suite&lt;/code&gt; is recommended for setting up and verifying state and environment on the System Under Test (SUT) or the &lt;code&gt;Common Test&lt;/code&gt; host node, or both, so that the test cases in the suite executes correctly. The following are examples of initial configuration operations:</source>
          <target state="translated">경우 &lt;code&gt;init_per_suite&lt;/code&gt; 이 존재하는 테스트 케이스를 실행하기 전에, 그것은 처음이라고합니다. 일반적으로 제품군의 모든 테스트 사례에 공통적 인 초기화가 포함되며 한 번만 수행됩니다. 스위트의 테스트 케이스가 올바르게 실행되도록 &lt;code&gt;init_per_suite&lt;/code&gt; 는 테스트 대상 시스템 (SUT) 또는 &lt;code&gt;Common Test&lt;/code&gt; 호스트 노드 또는 둘 다에서 상태 및 환경을 설정하고 확인하는 데 권장 됩니다. 다음은 초기 구성 작업의 예입니다.</target>
        </trans-unit>
        <trans-unit id="e3cc6a46f9d6f7424ecfecec26999fd0b60da6a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; fails, all test cases in the test suite are skipped automatically (so called &lt;strong&gt;auto skipped&lt;/strong&gt;), including &lt;code&gt;end_per_suite&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;init_per_suite&lt;/code&gt; 는 실패, 테스트 스위트의 모든 테스트 케이스 (소위 자동으로 건너 뜁니다 &lt;strong&gt;자동 생략&lt;/strong&gt; 포함) &lt;code&gt;end_per_suite&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="894e342a0e85afde6f3b96340c645a2b4dd22b1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; fails, this function is called after &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init_per_suite&lt;/code&gt; 가 실패 하면 post_init_per_suite 후에이 함수가 호출 &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfe02f751dfef43151df61c0738ad37b3fb27d99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; crashes (called &lt;strong&gt;auto skipped&lt;/strong&gt;).</source>
          <target state="translated">&lt;code&gt;init_per_testcase&lt;/code&gt; 가 충돌하는 경우 ( &lt;strong&gt;auto skipped&lt;/strong&gt; 라고 함 )</target>
        </trans-unit>
        <trans-unit id="7150a88f54c0b7881134625da98b5bed12371c8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; crashes, or returns &lt;code&gt;{skip,Reason}&lt;/code&gt; or &lt;code&gt;{fail,Reason}&lt;/code&gt;, function &lt;code&gt;end_per_testcase&lt;/code&gt; is not called.</source>
          <target state="translated">경우 &lt;code&gt;init_per_testcase&lt;/code&gt; 충돌, 또는 반환 &lt;code&gt;{skip,Reason}&lt;/code&gt; 또는 &lt;code&gt;{fail,Reason}&lt;/code&gt; , 기능 &lt;code&gt;end_per_testcase&lt;/code&gt; 가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89e72fa5ab521b91a322a6c022357a5ac272ea72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; exists, it is called before each test case in the suite. It typically contains initialization that must be done for each test case (analog to &lt;code&gt;init_per_suite&lt;/code&gt; for the suite).</source>
          <target state="translated">경우 &lt;code&gt;init_per_testcase&lt;/code&gt; 이 존재, 그것은 제품군의 각 테스트 케이스 전에 호출된다. 일반적으로 각 테스트 사례에 대해 수행해야하는 초기화가 포함됩니다 ( 스위트의 &lt;code&gt;init_per_suite&lt;/code&gt; 에 대한 아날로그 분석 ).</target>
        </trans-unit>
        <trans-unit id="72f622c1b041a5f9b4ffb1e9a77eb43b9ec5d211" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; returns a tuple &lt;code&gt;{skip,Reason}&lt;/code&gt; (called &lt;strong&gt;user skipped&lt;/strong&gt;).</source>
          <target state="translated">경우 &lt;code&gt;init_per_testcase&lt;/code&gt; 는 튜플 반환 &lt;code&gt;{skip,Reason}&lt;/code&gt; (전화 &lt;strong&gt;사용자는 생략&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="d395c2bde7c4e5cd016e96c83e2790c6164bde6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ip_access&lt;/code&gt; and &lt;code&gt;name_access&lt;/code&gt; are implemented similarly, we could write a &lt;code&gt;generic_access&lt;/code&gt; function using the &lt;code&gt;ListOfExtraArguments&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ip_access&lt;/code&gt; 와 &lt;code&gt;name_access&lt;/code&gt; 가 비슷하게 구현 되면 ListOfExtraArguments를 사용하여 &lt;code&gt;generic_access&lt;/code&gt; 함수를 &lt;code&gt;ListOfExtraArguments&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab359c8b6df991113724100b5a067f71b56dbab9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keysearch&lt;/code&gt; returns the atom &lt;code&gt;false&lt;/code&gt;, some error has occurred and the server sends back the message:</source>
          <target state="translated">경우 &lt;code&gt;keysearch&lt;/code&gt; 는 원자 반환 &lt;code&gt;false&lt;/code&gt; 일부 오류가 발생하여 서버가 다시 메시지를 보냅니다 :</target>
        </trans-unit>
        <trans-unit id="471dd07d8c17d433b665f7f28142ddb0c9a5ccb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keysearch&lt;/code&gt; returns:</source>
          <target state="translated">키 &lt;code&gt;keysearch&lt;/code&gt; 반환되는 경우 :</target>
        </trans-unit>
        <trans-unit id="1a3183f931de40dbb6f7631f18d3f43161a10688" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;kill&lt;/code&gt; is not defined in the map, the system default will be used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either option &lt;code&gt;&lt;a href=&quot;erl#+hmaxk&quot;&gt;+hmaxk&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt; erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;kill&lt;/code&gt; 맵에 정의되지 않은 시스템 기본값이 사용됩니다. 기본 시스템 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. 그것은 두 가지 옵션을 변경할 수 있습니다 &lt;code&gt;&lt;a href=&quot;erl#+hmaxk&quot;&gt;+hmaxk&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;erl(1)&lt;/code&gt; , 또는 &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt; erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8473687ede2e043c5626f2dc6d081f3c7f8c834a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;kill&lt;/code&gt; is not defined in the map, the system default will be used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either option &lt;code&gt;&lt;a href=&quot;erl#+hmaxk&quot;&gt;+hmaxk&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;kill&lt;/code&gt; 맵에 정의되지 않은 시스템 기본값이 사용됩니다. 기본 시스템 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. 그것은 두 가지 옵션을 변경할 수 있습니다 &lt;code&gt;&lt;a href=&quot;erl#+hmaxk&quot;&gt;+hmaxk&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;erl(1)&lt;/code&gt; , 또는 &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bce3cc2e82b9a6fd5502ccdd6aead42b567ec06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;local&lt;/code&gt; is specified as argument, Debugger interprets code only at the current node. If &lt;code&gt;global&lt;/code&gt; is specified as argument, Debugger interprets code at all known nodes, this is the default.</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; 이 인수로 지정된 경우 디버거는 현재 노드에서만 코드를 해석합니다. &lt;code&gt;global&lt;/code&gt; 이 인수로 지정된 경우 디버거는 알려진 모든 노드에서 코드를 해석하며 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="f7b7e2ac7280eca021f5062e79e83b7222745d33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m:fact/1&lt;/code&gt; is called with a negative number as argument, no clause head matches. A &lt;code&gt;function_clause&lt;/code&gt; runtime error occurs.</source>
          <target state="translated">경우 &lt;code&gt;m:fact/1&lt;/code&gt; 인수없이 절 머리 일치와 같은 음의 번호로 호출된다. &lt;code&gt;function_clause&lt;/code&gt; 의 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="78902773cd5b20b28d3f472a6d23e48932225627" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;master&lt;/code&gt;, one master agent is started. Otherwise, no agents are started.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 인 경우 하나의 마스터 에이전트가 시작됩니다. 그렇지 않으면 에이전트가 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ababfa264cf2c0471a517629bda5d420f24412f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maximum&lt;/code&gt; is passed as &lt;code&gt;Type&lt;/code&gt; and the emulator is not run in instrumented mode.</source>
          <target state="translated">경우 &lt;code&gt;maximum&lt;/code&gt; 로 전달 &lt;code&gt;Type&lt;/code&gt; 및 에뮬레이터 계측 모드에서 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb16ce380eb14a73a96ecf98dda7ccaebbde8485" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mon&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, a successful call stores the identity of the monitor in the &lt;code&gt;&lt;a href=&quot;#ErlNifMonitor&quot;&gt;ErlNifMonitor&lt;/a&gt;&lt;/code&gt; struct pointed to by &lt;code&gt;mon&lt;/code&gt;. This identifier is used to refer to the monitor for later removal with &lt;code&gt;&lt;a href=&quot;#enif_demonitor_process&quot;&gt;enif_demonitor_process&lt;/a&gt;&lt;/code&gt; or compare with &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt;enif_compare_monitors&lt;/a&gt;&lt;/code&gt;. A monitor is automatically removed when it triggers or when the resource is deallocated.</source>
          <target state="translated">&lt;code&gt;mon&lt;/code&gt; 이 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 , 성공적인 호출은 &lt;code&gt;mon&lt;/code&gt; 이 가리키는 &lt;code&gt;&lt;a href=&quot;#ErlNifMonitor&quot;&gt;ErlNifMonitor&lt;/a&gt;&lt;/code&gt; 구조체에 모니터 ID를 저장합니다 . 이 식별자는 나중에 &lt;code&gt;&lt;a href=&quot;#enif_demonitor_process&quot;&gt;enif_demonitor_process&lt;/a&gt;&lt;/code&gt; 로 제거하기 위해 모니터를 참조 하거나 enif_compare_monitors 와 비교하는 &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt;enif_compare_monitors&lt;/a&gt;&lt;/code&gt; 됩니다. 모니터는 트리거되거나 자원이 할당 해제 될 때 자동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="e7557ef34e7c482b82151565597fe49987e4f520" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg_env&lt;/code&gt; is set to &lt;code&gt;NULL&lt;/code&gt;, the &lt;code&gt;msg&lt;/code&gt; term is copied and the original term and its environment is still valid after the call.</source>
          <target state="translated">경우 &lt;code&gt;msg_env&lt;/code&gt; 가 설정되어 &lt;code&gt;NULL&lt;/code&gt; 의 &lt;code&gt;msg&lt;/code&gt; 용어는 복사되고 원래의 용어와 그 환경은 여전히 호출 후 유효합니다.</target>
        </trans-unit>
        <trans-unit id="3324f7db747bf81fb1767f13442861504e9e2dd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;myapp&lt;/code&gt; is running at &lt;code&gt;cp3&lt;/code&gt;, and if &lt;code&gt;cp2&lt;/code&gt; now restarts, it does not restart &lt;code&gt;myapp&lt;/code&gt;, as the order between the &lt;code&gt;cp2&lt;/code&gt; and &lt;code&gt;cp3&lt;/code&gt; nodes is undefined.</source>
          <target state="translated">경우 &lt;code&gt;myapp&lt;/code&gt; 실행되고 &lt;code&gt;cp3&lt;/code&gt; , 그리고 경우 &lt;code&gt;cp2&lt;/code&gt; 지금 다시 시작, 그것은 다시 시작하지 않습니다 &lt;code&gt;myapp&lt;/code&gt; 와를 사이의 순서로, &lt;code&gt;cp2&lt;/code&gt; 와 &lt;code&gt;cp3&lt;/code&gt; 노드가 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="410c990db3f3097c54b66efc65b17fbe9e2bad60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nc&lt;/code&gt; is the current number of multiblock carriers (the main multiblock carrier excluded) managed by an allocator, the size of the next &lt;code&gt;mseg_alloc&lt;/code&gt; multiblock carrier allocated by this allocator is roughly &lt;code&gt;smbcs+nc*(lmbcs-smbcs)/mbcgs&lt;/code&gt; when &lt;code&gt;nc &amp;lt;= mbcgs&lt;/code&gt;, and &lt;code&gt;lmbcs&lt;/code&gt; when &lt;code&gt;nc &amp;gt; mbcgs&lt;/code&gt;. If the value of parameter &lt;code&gt;sbct&lt;/code&gt; is larger than the value of parameter &lt;code&gt;lmbcs&lt;/code&gt;, the allocator may have to create multiblock carriers that are larger than the value of parameter &lt;code&gt;lmbcs&lt;/code&gt;, though. Singleblock carriers allocated through &lt;code&gt;mseg_alloc&lt;/code&gt; are sized to whole pages.</source>
          <target state="translated">경우 &lt;code&gt;nc&lt;/code&gt; 할당 자에 의해 관리되는 다중 블록 캐리어 (제외 주 - 블록 캐리어)의 현재 수는, 다음의 크기 &lt;code&gt;mseg_alloc&lt;/code&gt; 의 이 할당에 의해 할당 된 다중 블록 캐리어 대충 &lt;code&gt;smbcs+nc*(lmbcs-smbcs)/mbcgs&lt;/code&gt; 때 &lt;code&gt;nc &amp;lt;= mbcgs&lt;/code&gt; 및 &lt;code&gt;lmbcs&lt;/code&gt; &lt;code&gt;nc &amp;gt; mbcgs&lt;/code&gt; . 파라미터의 값 경우 &lt;code&gt;sbct&lt;/code&gt; 이 파라미터의 값보다 큰 &lt;code&gt;lmbcs&lt;/code&gt; 상기 할당 파라미터의 값보다 큰 캐리어 - 블록 생성 할 수도 &lt;code&gt;lmbcs&lt;/code&gt; 을 하지만. 를 통해 할당 Singleblock 사업자 &lt;code&gt;mseg_alloc&lt;/code&gt; 는 전체 페이지 크기가된다.</target>
        </trans-unit>
        <trans-unit id="00a9d4efd00c94ba68d6320fea95c0909f36f665" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;no_repeat&lt;/code&gt; is set as value, the repeated file sync operation is disabled, and it is the operating system settings that determine how quickly or slowly data is written to disk. The user can also call the &lt;code&gt;&lt;a href=&quot;logger_std_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; function to perform a file sync.</source>
          <target state="translated">경우 &lt;code&gt;no_repeat&lt;/code&gt; 이 값으로 설정되어, 반복 된 파일 동기화 작업이 불가능, 그것은 디스크에 기록됩니다 얼마나 빨리 또는 느리게 데이터를 결정하는 운영 체제 설정입니다. 사용자는 &lt;code&gt;&lt;a href=&quot;logger_std_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; 함수를 호출하여 파일 동기화를 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf5fe50553f5c7b137deba5f80790419102c9acc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;no_repeat&lt;/code&gt; is set as value, the repeated sync operation is disabled. The user can also call the &lt;code&gt;&lt;a href=&quot;logger_disk_log_h#filesync-1&quot;&gt;filesync/1 &lt;/a&gt;&lt;/code&gt; function to perform a disk_log sync.</source>
          <target state="translated">경우 &lt;code&gt;no_repeat&lt;/code&gt; 는 값으로 설정되고, 반복적 동기 동작은 불가능하다. 사용자는 또한 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h#filesync-1&quot;&gt;filesync/1 &lt;/a&gt;&lt;/code&gt; 함수를 호출하여 disk_log 동기화를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="960e9f5afba10edf0b60921b0e8e69fa2c34179d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;no_repeat&lt;/code&gt; is set as value, the repeated sync operation is disabled. The user can also call the &lt;code&gt;&lt;a href=&quot;logger_disk_log_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; function to perform a disk_log sync.</source>
          <target state="translated">경우 &lt;code&gt;no_repeat&lt;/code&gt; 는 값으로 설정되고, 반복적 동기 동작은 불가능하다. 사용자는 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; 함수를 호출하여 disk_log 동기화를 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a26d7bcc04c3b56013d1be0c1072c79ecbf5d9d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;node&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, it is a pointer to a buffer where the function can fill in the name of the node where &lt;code&gt;name&lt;/code&gt; is found. &lt;code&gt;node&lt;/code&gt; can be passed directly to &lt;code&gt;ei_connect()&lt;/code&gt; if necessary.</source>
          <target state="translated">경우 &lt;code&gt;node&lt;/code&gt; 아닌 &lt;code&gt;NULL&lt;/code&gt; ,이 기능은 노드의 이름을 입력 할 수있는 버퍼에 대한 포인터 &lt;code&gt;name&lt;/code&gt; 발견된다. &lt;code&gt;node&lt;/code&gt; 는 필요한 경우 &lt;code&gt;ei_connect()&lt;/code&gt; 직접 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92fc938fa7cba74ec1f9bb43ffd7daba5627a4cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;node&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, it is a pointer to a buffer where the function can fill in the name of the node where &lt;code&gt;name&lt;/code&gt; is found. &lt;code&gt;node&lt;/code&gt; can be passed directly to &lt;code&gt;erl_connect()&lt;/code&gt; if necessary.</source>
          <target state="translated">&lt;code&gt;node&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 , &lt;code&gt;name&lt;/code&gt; 이 발견 된 노드의 이름을 함수가 채울 수있는 버퍼에 대한 포인터 입니다. 필요한 경우 &lt;code&gt;node&lt;/code&gt; 를 &lt;code&gt;erl_connect()&lt;/code&gt; 직접 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8bcb0ecfc7e63283704c689b708fb3722abb28bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;once&lt;/code&gt;, only one message is automatically placed in the message queue, and after that the mode is automatically reset to passive. This provides flow control and the possibility for the receiver to listen for its incoming SCTP data interleaved with other inter-process messages.</source>
          <target state="translated">경우 &lt;code&gt;once&lt;/code&gt; , 하나의 메시지가 자동으로 메시지 큐에 저장하고, 수동 모드를 자동으로 리셋되어 이후. 이것은 흐름 제어를 제공하고 수신기가 다른 프로세스 간 메시지와 인터리브 된 들어오는 SCTP 데이터를 수신 할 수있는 가능성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ef8342250cfaa0e36ec9bd08880c6f82e62cfce4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this function must be called &lt;strong&gt;after&lt;/strong&gt; OS_Mon/&lt;code&gt;os_sup&lt;/code&gt; is stopped. &lt;code&gt;Dir&lt;/code&gt; defines the directory which contains the backup copy and the Erlang specific configuration files for &lt;code&gt;syslogd&lt;/code&gt;, and a named pipe to receive the messages from &lt;code&gt;syslogd&lt;/code&gt;. Defaults to &lt;code&gt;&quot;/etc&quot;&lt;/code&gt;. &lt;code&gt;Conf&lt;/code&gt; defines the full name of the configuration file for &lt;code&gt;syslogd&lt;/code&gt;. Default is &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;os_sup_enable&lt;/code&gt; 이 있다 &lt;code&gt;true&lt;/code&gt; ,이 함수를 호출해야합니다 &lt;strong&gt;후&lt;/strong&gt; OS_Mon / &lt;code&gt;os_sup&lt;/code&gt; 가 중지됩니다. &lt;code&gt;Dir&lt;/code&gt; 백업 사본 및 대한 얼랑 특정 구성 파일이 들어있는 디렉토리를 정의 &lt;code&gt;syslogd&lt;/code&gt; 를 , 그리고에서 메시지를 수신 할 수있는 명명 된 파이프 &lt;code&gt;syslogd&lt;/code&gt; . 기본값은 &lt;code&gt;&quot;/etc&quot;&lt;/code&gt; 입니다. &lt;code&gt;Conf&lt;/code&gt; 는 &lt;code&gt;syslogd&lt;/code&gt; 구성 파일의 전체 이름을 정의합니다 . 기본값은 &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7a700fd6dad9f4c64ccd4666632fae200f7d79bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this function must be called &lt;strong&gt;before&lt;/strong&gt; OS_Mon/&lt;code&gt;os_sup&lt;/code&gt; is started. &lt;code&gt;Dir&lt;/code&gt; defines the directory which contains the backup copy and the Erlang specific configuration files for &lt;code&gt;syslogd&lt;/code&gt;, and a named pipe to receive the messages from &lt;code&gt;syslogd&lt;/code&gt;. Defaults to &lt;code&gt;&quot;/etc&quot;&lt;/code&gt;. &lt;code&gt;Conf&lt;/code&gt; defines the full name of the configuration file for &lt;code&gt;syslogd&lt;/code&gt;. Default is &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os_sup_enable&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우 OS_Mon / &lt;code&gt;os_sup&lt;/code&gt; 을 시작 &lt;strong&gt;하기&lt;/strong&gt; 전에이 함수를 호출해야합니다 . &lt;code&gt;Dir&lt;/code&gt; 백업 사본 및 대한 얼랑 특정 구성 파일이 들어있는 디렉토리를 정의 &lt;code&gt;syslogd&lt;/code&gt; 를 , 그리고에서 메시지를 수신 할 수있는 명명 된 파이프 &lt;code&gt;syslogd&lt;/code&gt; . 기본값은 &lt;code&gt;&quot;/etc&quot;&lt;/code&gt; 입니다. &lt;code&gt;Conf&lt;/code&gt; 는 &lt;code&gt;syslogd&lt;/code&gt; 구성 파일의 전체 이름을 정의합니다 . 기본값은 &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="77f7d7d94477bf710f75a97f120cb44318c86bb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;preliminary&lt;/code&gt; is returned, finalization was performed and the time offset is now final.</source>
          <target state="translated">경우 &lt;code&gt;preliminary&lt;/code&gt; 반환되고, 마무리 수행 및 오프셋 시간은 최종되었다.</target>
        </trans-unit>
        <trans-unit id="68ca185ba5a790749853b97ac87472bb69e0f79b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;raw&lt;/code&gt; is not found in the list, it is added.</source>
          <target state="translated">경우 &lt;code&gt;raw&lt;/code&gt; 목록에없는, 그것은 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="31a44d264c5bd3a087ba168aa0cf5ef541ffc19d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read/2&lt;/code&gt; calls are for sizes not significantly less than, or even greater than &lt;code&gt;Size&lt;/code&gt; bytes, no performance gain can be expected.</source>
          <target state="translated">경우 &lt;code&gt;read/2&lt;/code&gt; 통화가되지 크게 미만, 또는보다 큰 크기에 관한 &lt;code&gt;Size&lt;/code&gt; 바이트, 더 성능 향상은 기대할 수 없다.</target>
        </trans-unit>
        <trans-unit id="3f7ab732c2a40901f7be417a921a39c57a4d5b7c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read&lt;/code&gt; is specified, only get requests are logged.</source>
          <target state="translated">경우 &lt;code&gt;read&lt;/code&gt; 지정된 경우에만 요청이 기록됩니다 얻는다.</target>
        </trans-unit>
        <trans-unit id="3b544ab09dc82eacf7049bd88c54823547cf046b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read&lt;/code&gt; is specified, only received messages are logged.</source>
          <target state="translated">경우 &lt;code&gt;read&lt;/code&gt; 지정 만받은 메시지가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="4b7ba5f30d6fa892ea1037782ff4251339643dcf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_concurrency&lt;/code&gt; was enabled for the table.</source>
          <target state="translated">테이블에 대해 &lt;code&gt;read_concurrency&lt;/code&gt; 가 활성화 된 경우</target>
        </trans-unit>
        <trans-unit id="b29a25b884982cf8d002411e5810c5627d5ba822" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_write&lt;/code&gt;, all requests are logged.</source>
          <target state="translated">&lt;code&gt;read_write&lt;/code&gt; 인 경우 모든 요청이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="015bb54da55bcc930a4cbf6d43e9056cf7cdedf5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_write&lt;/code&gt;, both outgoing and incoming messages are logged.</source>
          <target state="translated">경우 &lt;code&gt;read_write&lt;/code&gt; , 모두 발신 및 수신 메시지가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="b1376e2f35266b87691b21e50d6085d572b9fcbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;registered_name&lt;/code&gt; is part of &lt;code&gt;ItemList&lt;/code&gt; and the process has no name registered, a &lt;code&gt;{registered_name, []}&lt;/code&gt;, &lt;code&gt;InfoTuple&lt;/code&gt;&lt;strong&gt;will&lt;/strong&gt; be included in the resulting &lt;code&gt;InfoTupleList&lt;/code&gt;. This behavior is different when a single &lt;code&gt;Item =:= registered_name&lt;/code&gt; is specified, and when &lt;code&gt;process_info/1&lt;/code&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;registered_name&lt;/code&gt; 은 의 일부 &lt;code&gt;ItemList&lt;/code&gt; 프로세스가 등록 된 이름이없는하는 &lt;code&gt;{registered_name, []}&lt;/code&gt; , &lt;code&gt;InfoTuple&lt;/code&gt; 는&lt;strong&gt;것이다&lt;/strong&gt; 결과에 포함 &lt;code&gt;InfoTupleList&lt;/code&gt; . 단일 &lt;code&gt;Item =:= registered_name&lt;/code&gt; 을 지정하고 &lt;code&gt;process_info/1&lt;/code&gt; 을 사용 하는 경우이 동작이 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="1c5b2b100f53895b2b8688baa94d7b9678f28feb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;remove_handler&lt;/code&gt; is returned, the event handler is deleted by calling &lt;code&gt;Module:terminate(remove_handler,State)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;remove_handler&lt;/code&gt; 가 반환되는 이벤트 핸들러를 호출하여 삭제 &lt;code&gt;Module:terminate(remove_handler,State)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="068df812b1be7a5c6fb7ba1d84c59687bbec92c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;script_nocache&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the HTTP server by default adds the header fields necessary to prevent proxies from caching the page. Generally this is preferred. Default to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;script_nocache&lt;/code&gt; 가 설정되어 &lt;code&gt;true&lt;/code&gt; , 기본적으로 HTTP 서버는 헤더 페이지를 캐싱 프록시를 방지하기 위해 필요한 필드를 추가합니다. 일반적으로 이것이 바람직하다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d372c1d474f731f0f4b202ab8bda7211457e68a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;set_env/4&lt;/code&gt; is called before the application is loaded, the application environment values specified in file &lt;code&gt;Application.app&lt;/code&gt; override the ones previously set. This is also true for application reloads.</source>
          <target state="translated">응용 프로그램이로드되기 전에 &lt;code&gt;set_env/4&lt;/code&gt; 가 호출 되면 &lt;code&gt;Application.app&lt;/code&gt; 파일에 지정된 응용 프로그램 환경 값 이 이전에 설정된 값 보다 우선합니다. 응용 프로그램을 다시로드 할 때도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="82d435019a14ecf65737ecf3db3bfd456332513c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, the size of the head is placed there.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 , 헤드의 크기가 거기에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="4feb70b4204ade06d5e528b8d52ed62d294cf47b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stop&lt;/code&gt; is returned, the log event is immediately discarded. If the filter is primary, no handler filters or callbacks are called. If it is a handler filter, the corresponding handler callback is not called, but the log event is forwarded to filters attached to the next handler, if any.</source>
          <target state="translated">경우 &lt;code&gt;stop&lt;/code&gt; 반환되면, 로그 이벤트는 즉시 삭제됩니다. 필터가 1 차인 경우 핸들러 필터 또는 콜백이 호출되지 않습니다. 핸들러 필터 인 경우 해당 핸들러 콜백이 호출되지 않지만 다음 이벤트 (있는 경우)에 첨부 된 필터로 로그 이벤트가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4b0fd3902aab568d673cab668aeb876afecb3d16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sync_mode_qlen&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;, all log events are handled synchronously. That is, asynchronous logging is disabled.</source>
          <target state="translated">경우 &lt;code&gt;sync_mode_qlen&lt;/code&gt; 가 설정되어 &lt;code&gt;0&lt;/code&gt; , 모든 로그 이벤트는 동 기적으로 처리됩니다. 즉, 비동기 로깅이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="fe26b781dc9f18c574b4f5cea83e1dc7a0898036" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sync_mode_qlen&lt;/code&gt; is set to the same value as &lt;code&gt;drop_mode_qlen&lt;/code&gt;, synchronous mode is disabled. That is, the handler always runs in asynchronous mode, unless dropping or flushing is invoked.</source>
          <target state="translated">경우 &lt;code&gt;sync_mode_qlen&lt;/code&gt; 가 동일한 값으로 설정된다 &lt;code&gt;drop_mode_qlen&lt;/code&gt; 동기 모드를 사용할 수 없습니다. 즉, 삭제 또는 플러시가 호출되지 않으면 핸들러는 항상 비동기 모드로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="df2d416ddedf4f1525642d418b4917eca16a89fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; identifies a node local port, this function initializes the port variable &lt;code&gt;*port_id&lt;/code&gt; from it and returns &lt;code&gt;true&lt;/code&gt;. Otherwise returns &lt;code&gt;false&lt;/code&gt;. No check is done to see if the port is alive.</source>
          <target state="translated">경우 &lt;code&gt;term&lt;/code&gt; 식별 노드 로컬 포트,이 기능은 포트 변수 초기화 &lt;code&gt;*port_id&lt;/code&gt; 그것을 반환에서 &lt;code&gt;true&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 포트가 활성 상태인지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb931f96868f0894c3ee44964627cb220396fbd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; is a tuple, this function sets &lt;code&gt;*array&lt;/code&gt; to point to an array containing the elements of the tuple, and sets &lt;code&gt;*arity&lt;/code&gt; to the number of elements. Notice that the array is read-only and &lt;code&gt;(*array)[N-1]&lt;/code&gt; is the Nth element of the tuple. &lt;code&gt;*array&lt;/code&gt; is undefined if the arity of the tuple is zero.</source>
          <target state="translated">경우 &lt;code&gt;term&lt;/code&gt; 튜플은이 함수 세트 &lt;code&gt;*array&lt;/code&gt; 튜플의 요소들을 포함하는 배열 포인트를 세트하고 &lt;code&gt;*arity&lt;/code&gt; 요소들의 수. 배열은 읽기 전용이며 &lt;code&gt;(*array)[N-1]&lt;/code&gt; 은 튜플의 N 번째 요소입니다. 튜플의 arity가 0이면 &lt;code&gt;*array&lt;/code&gt; 은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99ce7d95b89f5e150dfbf95c1a3d757a096ea716" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; is the pid of a node local process, this function initializes the pid variable &lt;code&gt;*pid&lt;/code&gt; from it and returns &lt;code&gt;true&lt;/code&gt;. Otherwise returns &lt;code&gt;false&lt;/code&gt;. No check is done to see if the process is alive.</source>
          <target state="translated">경우 &lt;code&gt;term&lt;/code&gt; 노드 로컬 프로세스의 PID입니다,이 기능은 PID 변수가 초기화 &lt;code&gt;*pid&lt;/code&gt; 그것을 반환에서 &lt;code&gt;true&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 프로세스가 활성 상태인지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="335749543c3f3f2a3a67c44896ae9fd2f2a9abbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;throw/1&lt;/code&gt; is not evaluated within a catch, a &lt;code&gt;nocatch&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">경우에 &lt;code&gt;throw/1&lt;/code&gt; 캐치 내에서 평가되지 않습니다하는 &lt;code&gt;nocatch&lt;/code&gt; 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2871fa0784bdb523b8ad094e354b3376cbc7c2d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; is not set, the default values specified by &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;Module:suite/0&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;Module:group/1&lt;/a&gt;&lt;/code&gt;) are used.</source>
          <target state="translated">&lt;code&gt;timetrap&lt;/code&gt; 또는 &lt;code&gt;require&lt;/code&gt; 가 설정되지 않은 경우 &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;Module:suite/0&lt;/a&gt;&lt;/code&gt; (또는 &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;Module:group/1&lt;/a&gt;&lt;/code&gt; )에 지정된 기본값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="531f47b8f34afb9e971187a621871b405723e46a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; is not set, the default values specified by &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt;) are used.</source>
          <target state="translated">&lt;code&gt;timetrap&lt;/code&gt; 또는 &lt;code&gt;require&lt;/code&gt; 가 설정되지 않은 경우 &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; (또는 &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; )에 의해 지정된 기본값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="976ebeb2288ae33fa6c9a2ec2a28980aa636376c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;, or both, is not set specifically for a particular test case, default values specified by function &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; are used.</source>
          <target state="translated">경우 &lt;code&gt;timetrap&lt;/code&gt; 또는 &lt;code&gt;require&lt;/code&gt; , 또는 둘 다, 특정 테스트 케이스에 대해 구체적으로 설정되지 않은 디폴트 값 함수에 의해 특정 &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="f5b1ebc718d9766e9f004a96387fa62f22f383b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;, or both, is not set specifically for a particular test case, default values specified by function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; are used.</source>
          <target state="translated">경우 &lt;code&gt;timetrap&lt;/code&gt; 또는 &lt;code&gt;require&lt;/code&gt; , 또는 둘 다, 특정 테스트 케이스에 대해 구체적으로 설정되지 않은 디폴트 값 함수에 의해 특정 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="744ac3e017c02db9473330a8d4a2dec44a7e8e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_call/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;trace_call/5&lt;/code&gt; 가 정의되어 있지 않으면 대신 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9e1c20b572719c3331469687919f2defd8437750" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_garbage_collection/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;trace_garbage_collection/5&lt;/code&gt; 가 정의되지 않은 경우 대신 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b6da64932aab510304a9e86727b1e2bcbdfe8f0b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_ports/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;trace_ports/5&lt;/code&gt; 가 정의되어 있지 않으면 대신 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="50d620a56eb39b36411e41b4bc5a97c7bbafbd69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_procs/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">경우 &lt;code&gt;trace_procs/5&lt;/code&gt; 가 정의되어 있지, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 대신이라고합니다.</target>
        </trans-unit>
        <trans-unit id="9603bcd32c947b80ea34517cb4f3a01b71d378ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_receive/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;trace_receive/5&lt;/code&gt; 가 정의되어 있지 않으면 대신 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="df75f373657f0f91332cb47e91e892abb9c113a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_running_ports/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;trace_running_ports/5&lt;/code&gt; 가 정의되지 않은 경우 대신 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5559d0a97110b67775d63df3a3e94529bc745fe9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_running_procs/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;trace_running_procs/5&lt;/code&gt; 가 정의되지 않은 경우 대신 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="93b8b767ba992ffc91ebcedb4793839177d0df72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_send/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;trace_send/5&lt;/code&gt; 가 정의되지 않은 경우 대신 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="901bf723e7561c2418b0b1c71d7584f891124177" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trans_req&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then request(s) will be sent immediately (in its own message).</source>
          <target state="translated">경우 &lt;code&gt;trans_req&lt;/code&gt; 이 있다 &lt;code&gt;false&lt;/code&gt; , 다음 요청 (들)은 (자신의 메시지)를 즉시 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="680ea9ebc8cd511dd23a5a2d9935ba441ee109e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trans_req&lt;/code&gt; is true, then request(s) will instead be sent to the transaction sender process for accumulation and later sending (see &lt;code&gt;trans_ack_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxsize&lt;/code&gt;, &lt;code&gt;trans_ack_maxcount&lt;/code&gt; and &lt;code&gt;trans_timer&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;trans_req&lt;/code&gt; 는 사실, 다음 요청 (들) 대신에 축적 이상 (참조 보내기위한 거래 보낸 사람 처리로 전송됩니다 &lt;code&gt;trans_ack_maxcount&lt;/code&gt; , &lt;code&gt;trans_req_maxcount&lt;/code&gt; , &lt;code&gt;trans_req_maxsize&lt;/code&gt; , &lt;code&gt;trans_ack_maxcount&lt;/code&gt; 및 &lt;code&gt;trans_timer&lt;/code&gt; 을 ).</target>
        </trans-unit>
        <trans-unit id="287b344c66382cf8b1edce4da0960025c7e9b57c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; (default), the server sends a cookie extension in its HelloRetryRequest messages.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; (기본값), 서버는 HelloRetryRequest 메시지에 쿠키 확장을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="e70881a85aca398937951a4668c24337f4bc60ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; (full active mode) there is no flow control.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; (전체 활성 모드)에는 흐름 제어가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e48e65bf83526cb9dd2dcc5eaa66577b4aa53e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; (full active mode), the pending data or events are sent to the owning process.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; (전체 활성 모드), 대기중인 데이터 나 이벤트가 소유하는 프로세스로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="25420436cf7ea356d88467267bb54e499c6238b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; (or &lt;code&gt;extended&lt;/code&gt;), the agent is multi-threaded, with one thread for each get request.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; (또는 &lt;code&gt;extended&lt;/code&gt; ), 에이전트는 각 GET 요청에 대한 하나 개의 스레드와 멀티 스레드.</target>
        </trans-unit>
        <trans-unit id="f6d949864e0ff9ac2295f12de502f8af44fe5554" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; the configuration files are re-read during start-up, and the contents of the configuration database ignored. Thus, if &lt;code&gt;true&lt;/code&gt;, changes to the configuration database are lost upon reboot of the agent.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 시작 중에 구성 파일을 다시 읽고 구성 데이터베이스의 내용을 무시합니다. 따라서 &lt;code&gt;true&lt;/code&gt; 인 경우 에이전트를 재부팅 할 때 구성 데이터베이스에 대한 변경 사항이 유실됩니다.</target>
        </trans-unit>
        <trans-unit id="5742f9a48f2a77c8abfa93b7448bf87101200ba9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, hibernates the &lt;code&gt;gen_statem&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; before going into &lt;code&gt;receive&lt;/code&gt; to wait for a new external event.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 새 외부 이벤트를 기다리기 위해 &lt;code&gt;receive&lt;/code&gt; 하기 전에 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; 를 호출 하여 &lt;code&gt;gen_statem&lt;/code&gt; 을 동면합니다 .</target>
        </trans-unit>
        <trans-unit id="1c34bbe208e229e88b9cf884fe83c6e4487267fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, induces an error on an attempt to send a message larger than the current PMTU size (which would require fragmentation/reassembling). Notice that message fragmentation does not affect the logical atomicity of its delivery; this option is provided for performance reasons only.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , (재 조립 / 조각을 필요로) 현재의 PMTU 크기보다 큰 메시지를 보낼하려는 시도에 오류를 유도한다. 메시지 조각화는 배달의 논리적 원자성에 영향을 미치지 않습니다. 이 옵션은 성능상의 이유로 만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="14dea9808b1f89c089706dd845be50b4ae8f0440" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, net_if binds to the IP address. If &lt;code&gt;false&lt;/code&gt;, net_if listens on any IP address on the host where it is running.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 net_if는 IP 주소에 바인딩됩니다. &lt;code&gt;false&lt;/code&gt; 인 경우 net_if는 실행중인 호스트의 모든 IP 주소를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="1a887d631ac5987f669427d5f352faeefbf326b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, net_if does not specify that the IP and port address should be reusable. If &lt;code&gt;false&lt;/code&gt;, the address is set to reusable.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 net_if는 IP 및 포트 주소를 재사용 할 수 있도록 지정하지 않습니다. 경우 &lt;code&gt;false&lt;/code&gt; 주소는 재사용로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f8ccef0dc480afe24c0ff21ece83c8c3800b5e39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, postpones the current event and retries it after a &lt;strong&gt;state change&lt;/strong&gt; (&lt;code&gt;NextState =/= State&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; 하는 후 현재 이벤트와 시도를 연기 &lt;strong&gt;상태 변경&lt;/strong&gt; ( &lt;code&gt;NextState =/= State&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5cd4ac0f7d30d624066e424ed5179bc26eafc35f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, postpones the current event and retries it when the state changes (&lt;code&gt;NextState =/= State&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 현재 이벤트를 연기하고 상태가 변경 될 때 ( &lt;code&gt;NextState =/= State&lt;/code&gt; ) 다시 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="520af4aded931229fa7189fca614aa3fa7995a83" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the agent is multi-threaded, with one thread for each get request.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 에이전트는 각 GET 요청에 대한 하나 개의 스레드와 멀티 스레드입니다.</target>
        </trans-unit>
        <trans-unit id="89015f594d36423a0e641bd12c827ea801ee5cfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the client does not print anything on authorization.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 클라이언트는 인증에 아무것도 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23b8e026fd6aadff53ba83122b74ea4391419aca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the client saves an accepted host key to avoid the accept question the next time the same host is connected. If the option &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; is not present, the key is saved in the file &quot;known_hosts&quot;. See option &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; for the location of that file.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 클라이언트는이 문제를 동일한 호스트가 연결되어 다음 번에 동의 피하기 위해 허용 호스트 키를 저장합니다. &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; 옵션 이 없으면 &quot;known_hosts&quot;파일에 키가 저장됩니다. 해당 파일의 위치는 &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="95c8aecfc16da9f44601b813f0d7e51d5bf0f4a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the client saves an accepted host key to avoid the accept question the next time the same host is connected. If the option &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; is not present, the key is saved in the file &quot;known_hosts&quot;. See option &lt;code&gt;&lt;a href=&quot;ssh_file#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; for the location of that file.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 클라이언트는이 문제를 동일한 호스트가 연결되어 다음 번에 동의 피하기 위해 허용 호스트 키를 저장합니다. &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; 옵션 이 없으면 &quot;known_hosts&quot;파일에 키가 저장됩니다. 해당 파일의 위치는 &lt;code&gt;&lt;a href=&quot;ssh_file#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b356ac942be95783b518ac898149e69ff7f29e06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the execution time and reductions are accumulated.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 실행 시간 및 감소가 축적된다.</target>
        </trans-unit>
        <trans-unit id="a2c9b567f4306cd17d762c08a52cc878115d08b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the log owners are notified when certain log events occur. Defaults to &lt;code&gt;false&lt;/code&gt;. The owners are sent one of the following messages when an event occurs:</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; 특정 로그 이벤트가 발생할 때, 로그 소유자에게 통지된다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. 이벤트가 발생하면 소유자에게 다음 메시지 중 하나가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="dac3885367e9c29a28f95ee9e91f474fd1b0d8a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, this makes &lt;code&gt;epp_dodger&lt;/code&gt; replace any program forms that could not be parsed with nodes of type &lt;code&gt;text&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;erl_syntax#text-1&quot;&gt;erl_syntax:text/1&lt;/a&gt;&lt;/code&gt;), representing the raw token sequence of the form, instead of reporting a parse error. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; ,이 차종 &lt;code&gt;epp_dodger&lt;/code&gt; 타입의 노드로 해석 할 수 없었던 어떤 프로그램 형태의 대체 &lt;code&gt;text&lt;/code&gt; (참조 &lt;code&gt;&lt;a href=&quot;erl_syntax#text-1&quot;&gt;erl_syntax:text/1&lt;/a&gt;&lt;/code&gt; 양식의 원시 토큰 시퀀스를 나타내는 대신의 구문 분석 오류를보고). 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="05b7850adc53f90dafb4ed1b3efc538359d746ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true|once|N&lt;/code&gt; (active modes) received data or events are sent to the owning process. See &lt;code&gt;&lt;a href=&quot;#open-0&quot;&gt;open/0..2&lt;/a&gt;&lt;/code&gt; for the message format.</source>
          <target state="translated">경우 &lt;code&gt;true|once|N&lt;/code&gt; (활성 모드) 데이터를 수신하거나 이벤트가 소유하는 프로세스로 전송됩니다. 메시지 형식 은 &lt;code&gt;&lt;a href=&quot;#open-0&quot;&gt;open/0..2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d40234d0ab231968f3d6203cda0f55c4df8e790c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;u&lt;/code&gt; is used as subsystem identifier (that is, &lt;code&gt;&amp;lt;S&amp;gt; = u&lt;/code&gt;), all allocators based on &lt;code&gt;alloc_util&lt;/code&gt; are effected. If &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;I&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt; is used as subsystem identifier, only the specific allocator identifier is effected.</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; 가 서브 시스템 식별자로 사용되는 경우 (즉, &lt;code&gt;&amp;lt;S&amp;gt; = u&lt;/code&gt; ) &lt;code&gt;alloc_util&lt;/code&gt; 을 기반으로하는 모든 할당 자가 적용 됩니다. 경우 &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;D&lt;/code&gt; , &lt;code&gt;E&lt;/code&gt; , &lt;code&gt;F&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; 는 , &lt;code&gt;L&lt;/code&gt; 는 , &lt;code&gt;R&lt;/code&gt; 은 , &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; 는 서브 식별자로서 사용되는, 단지 특정 할당 식별자 이루어진다.</target>
        </trans-unit>
        <trans-unit id="78d87db40121a7b6b4e4f2f28996811db47d8d7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;u&lt;/code&gt; is used as subsystem identifier (that is, &lt;code&gt;&amp;lt;S&amp;gt; = u&lt;/code&gt;), all allocators based on &lt;code&gt;alloc_util&lt;/code&gt; are effected. If &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, or &lt;code&gt;T&lt;/code&gt; is used as subsystem identifier, only the specific allocator identifier is effected.</source>
          <target state="translated">경우 &lt;code&gt;u&lt;/code&gt; 는 서브 식별자로서 사용된다 (즉, &lt;code&gt;&amp;lt;S&amp;gt; = u&lt;/code&gt; )에 기초하여 모든 할당 자 &lt;code&gt;alloc_util&lt;/code&gt; 가 수행된다. 경우 &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;D&lt;/code&gt; , &lt;code&gt;E&lt;/code&gt; , &lt;code&gt;F&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; , 또는 &lt;code&gt;T&lt;/code&gt; 는 서브 식별자 이루어진다 식별자만을 특정 할당로서 사용된다.</target>
        </trans-unit>
        <trans-unit id="784b625fc8171fa4983940bde7848ec14a3e23bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;volatile&lt;/code&gt; is returned, the time offset cannot be finalized because &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;volatile&lt;/code&gt; 반환되기 때문에, 오프셋 시간을 확정 할 수없는 &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="20c03db910bef2b3379b92930db1f3ebc527788d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write&lt;/code&gt; is specified, only sent messages are logged.</source>
          <target state="translated">경우 &lt;code&gt;write&lt;/code&gt; 지정된 경우에만 보낸 메시지가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="a95ad12798c19a97f99824236c8f188c8076b6b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write&lt;/code&gt; is specified, only set requests are logged.</source>
          <target state="translated">경우 &lt;code&gt;write&lt;/code&gt; 지정된 경우에만 설정 요청이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="b0db310b8af51df282663eafc88eec4c7003919f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write_concurrency&lt;/code&gt; was enabled for the table.</source>
          <target state="translated">테이블에 대해 &lt;code&gt;write_concurrency&lt;/code&gt; 가 활성화 된 경우</target>
        </trans-unit>
        <trans-unit id="d130e60ef67783037417bccce56bcf5768c8e099" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{continue_after_restart,OtherVsn,Descr}&lt;/code&gt; is returned, the emulator is restarted before the upgrade instructions are executed. This occurs if the emulator or any of the applications Kernel, STDLIB, or SASL are updated. The new emulator version and these core applications execute after the restart. For all other applications the old versions are started and the upgrade is performed as normal by executing the upgrade instructions.</source>
          <target state="translated">경우 &lt;code&gt;{continue_after_restart,OtherVsn,Descr}&lt;/code&gt; 반환, 에뮬레이터를 다시 시작 업그레이드 명령이 실행되기 전에. 에뮬레이터 또는 응용 프로그램 커널, STDLIB 또는 SASL이 업데이트 된 경우에 발생합니다. 새로운 에뮬레이터 버전과 이러한 핵심 응용 프로그램은 재시작 후 실행됩니다. 다른 모든 응용 프로그램의 경우 이전 버전이 시작되고 업그레이드 지침을 실행하여 업그레이드가 정상적으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="320cf62f527c030692a3479a90eabc62ad79a175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{eof, Endline}&lt;/code&gt; is returned immediately, the call to &lt;code&gt;parse_and_scan/1&lt;/code&gt; returns &lt;code&gt;{ok, eof}&lt;/code&gt;. If &lt;code&gt;{eof, Endline}&lt;/code&gt; is returned before the parser expects end of input, &lt;code&gt;parse_and_scan/1&lt;/code&gt; will, of course, return an error message (see above). Otherwise &lt;code&gt;{ok, Result}&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;{eof, Endline}&lt;/code&gt; 즉시 반환, 호출합니다 &lt;code&gt;parse_and_scan/1&lt;/code&gt; 수익을 &lt;code&gt;{ok, eof}&lt;/code&gt; . 경우 &lt;code&gt;{eof, Endline}&lt;/code&gt; 기대하는 입력 끝 파서, 반환 전에 &lt;code&gt;parse_and_scan/1&lt;/code&gt; 은 물론, (상기 참조) 에러 메시지를 리턴한다. 그렇지 않으면 &lt;code&gt;{ok, Result}&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="dedb9788552103a1f455c74f781f00865ba7c935" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{merge_tests,true}&lt;/code&gt; is set in the source specification (which is the default setting), terms in joined specifications are merged with terms in the source specification (according to the description of &lt;code&gt;merge_tests&lt;/code&gt; earlier).</source>
          <target state="translated">소스 사양 (기본 설정)에 &lt;code&gt;{merge_tests,true}&lt;/code&gt; 가 설정되어 있으면 결합 사양의 용어가 소스 사양의 용어와 병합됩니다 ( 이전 &lt;code&gt;merge_tests&lt;/code&gt; 의 설명에 따름 ).</target>
        </trans-unit>
        <trans-unit id="e19028ea4203966a6e00632a19c4871950b28ef8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{noreply,NewState}&lt;/code&gt; is returned, &lt;code&gt;{noreply,NewState,Timeout}&lt;/code&gt;, or &lt;code&gt;{noreply,NewState,hibernate}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process continues executing with &lt;code&gt;NewState&lt;/code&gt;. Any reply to &lt;code&gt;From&lt;/code&gt; must be specified explicitly using &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;{noreply,NewState}&lt;/code&gt; 를 반환한다 &lt;code&gt;{noreply,NewState,Timeout}&lt;/code&gt; 또는 &lt;code&gt;{noreply,NewState,hibernate}&lt;/code&gt; 상기 &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스로 계속 실행 &lt;code&gt;NewState&lt;/code&gt; . &lt;code&gt;From&lt;/code&gt; 에 대한 회신은 &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 명시 적으로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e61ed5c3d675fd060bf7a5ba0b7669c540660308" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; is returned, the event manager also goes into hibernation (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt; proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;), waiting for the next event to occur. It is sufficient that one of the event handlers return &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; for the whole event manager process to hibernate.</source>
          <target state="translated">경우 &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; 반환, 이벤트 매니저는 (호출하여 최대 절전 모드로 전환 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt; proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ), 다음 이벤트가 발생하는 대기. 이벤트 핸들러 중 하나가 전체 이벤트 관리자 프로세스를 최대 절전 모드로 전환하기 위해 &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; 를 반환하는 것으로 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="e1637361f321011df9f0024cdad416df7e559bbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; is returned, the event manager also goes into hibernation (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;), waiting for the next event to occur. It is sufficient that one of the event handlers return &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; for the whole event manager process to hibernate.</source>
          <target state="translated">경우 &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; 반환, 이벤트 매니저는 (호출하여 최대 절전 모드로 전환 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ), 다음 이벤트가 발생하는 대기. 전체 이벤트 관리자 프로세스가 최대 절전 모드로 전환 되도록 이벤트 핸들러 중 하나가 &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; 를 리턴하는 것으로 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="7bf6373c4c4feb0b7b12ba83feca28174cdeeb31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,NewState}&lt;/code&gt; or &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; is returned, the event handler remains in the event manager with the possible updated internal state &lt;code&gt;NewState&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;{ok,NewState}&lt;/code&gt; 또는 &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; 반환, 가능한 업데이트 된 내부 상태와 이벤트 관리자의 이벤트 핸들러 남아 &lt;code&gt;NewState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="622b2b9487b410e4b5c3a44646686c10053b1e31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; is returned, the event manager goes into hibernation (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;), waiting for the next event to occur.</source>
          <target state="translated">경우 &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; 반환, 이벤트 매니저 (호출하여 최대 절전 모드로 전환 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; , 다음 이벤트가 발생하는 대기).</target>
        </trans-unit>
        <trans-unit id="4733cd19b2819c31e3b9d228b0a9153e3ac1bda9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{reply,Reply,NewState}&lt;/code&gt; is returned, &lt;code&gt;{reply,Reply,NewState,Timeout}&lt;/code&gt; or &lt;code&gt;{reply,Reply,NewState,hibernate}&lt;/code&gt;, &lt;code&gt;Reply&lt;/code&gt; is given back to &lt;code&gt;From&lt;/code&gt; as the return value of &lt;code&gt;call/2,3&lt;/code&gt; or included in the return value of &lt;code&gt;multi_call/2,3,4&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; process then continues executing with the possibly updated internal state &lt;code&gt;NewState&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;{reply,Reply,NewState}&lt;/code&gt; 반환됩니다 &lt;code&gt;{reply,Reply,NewState,Timeout}&lt;/code&gt; 또는 &lt;code&gt;{reply,Reply,NewState,hibernate}&lt;/code&gt; , &lt;code&gt;Reply&lt;/code&gt; 다시 주어진다 &lt;code&gt;From&lt;/code&gt; 의 반환 값으로 &lt;code&gt;call/2,3&lt;/code&gt; 또는에 포함 의 반환 값 &lt;code&gt;multi_call/2,3,4&lt;/code&gt; . &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스는 다음 업데이트 가능한 내부 상태와 실행을 계속 &lt;code&gt;NewState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf8d1c1849381a9a2934c0c67001278a230ee2f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{save_calls,N}&lt;/code&gt; has been set for the process, no function calls are saved to the call saving list. (The call saving list is not cleared. Also, send, receive, and time-out events are still added to the list.)</source>
          <target state="translated">경우 &lt;code&gt;{save_calls,N}&lt;/code&gt; 이 과정 설정되어있는, 어떤 함수 호출은 전화 저장 목록에 저장되지 않습니다. 통화 저장 목록은 지워지지 않습니다. 또한 보내기, 받기 및 시간 초과 이벤트가 여전히 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="bfb24986f0a70731e0b63f3291fa396e2f3c519f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; is specified in the options such that &lt;code&gt;Start&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, &lt;code&gt;Start + Length&lt;/code&gt; &amp;lt; 0 or &lt;code&gt;Start + Length&lt;/code&gt; is &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">경우 &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; 되도록 옵션에 지정된 &lt;code&gt;Start&lt;/code&gt; &amp;gt; 크기 &lt;code&gt;Subject&lt;/code&gt; , &lt;code&gt;Start + Length&lt;/code&gt; &amp;lt;0 또는 &lt;code&gt;Start + Length&lt;/code&gt; 이다&amp;gt;의 크기 &lt;code&gt;Subject&lt;/code&gt; 하는 &lt;code&gt;badarg&lt;/code&gt; 의 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="de6994202966362118bb8cacc9efab5d034d0b7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; is specified in the options such that &lt;code&gt;Start&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;lt; 0 or &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">경우 &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; 되도록 옵션에 지정된 &lt;code&gt;Start&lt;/code&gt; &amp;gt;의 크기 &lt;code&gt;Subject&lt;/code&gt; , &lt;code&gt;Start&lt;/code&gt; +의 &lt;code&gt;Length&lt;/code&gt; &amp;lt;0 또는 &lt;code&gt;Start&lt;/code&gt; +의 &lt;code&gt;Length&lt;/code&gt; &amp;gt; 크기 &lt;code&gt;Subject&lt;/code&gt; 하는 &lt;code&gt;badarg&lt;/code&gt; 의 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="22f0dd2e07f51ba0bec6f71cc1bb3b006093d94a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip, Reason}&lt;/code&gt; is returned, all test cases in the group are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the group.</source>
          <target state="translated">경우 &lt;code&gt;{skip, Reason}&lt;/code&gt; 반환, 그룹의 모든 테스트 케이스는 생략하고 &lt;code&gt;Reason&lt;/code&gt; 그룹에 대한 개요 로그에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="9167afbdea5d3a67e5f541cf0e5e6e2773017130" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip, Reason}&lt;/code&gt; is returned, all test cases in the module are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed on the HTML result page.</source>
          <target state="translated">경우 &lt;code&gt;{skip, Reason}&lt;/code&gt; 반환되는 모듈의 모든 테스트 케이스는 생략하고 &lt;code&gt;Reason&lt;/code&gt; 는 HTML 결과 페이지에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="8e478cc8acb7bdb77b1dae6158305c98359cc9ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip, Reason}&lt;/code&gt; is returned, all test cases in the suite are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="translated">경우 &lt;code&gt;{skip, Reason}&lt;/code&gt; 반환, 스위트의 모든 테스트 케이스는 생략하고 &lt;code&gt;Reason&lt;/code&gt; 제품군에 대한 개요 로그에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="3e08b34f61f1a4d3777b205be5de380bc841d230" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip, Reason}&lt;/code&gt; is returned, the test case is skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="translated">경우 &lt;code&gt;{skip, Reason}&lt;/code&gt; 반환, 테스트 케이스는 건너 뛰고 &lt;code&gt;Reason&lt;/code&gt; 제품군에 대한 개요 로그에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="2eb02f05292552a7ce9695f8e039ca2486be0efc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the group are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the group.</source>
          <target state="translated">경우 &lt;code&gt;{skip,Reason}&lt;/code&gt; 반환, 그룹의 모든 테스트 케이스는 생략하고 &lt;code&gt;Reason&lt;/code&gt; 그룹에 대한 개요 로그에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="07c6e6c33ab904cab102b2ef7313020f30f3b33b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the module are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed on the HTML result page.</source>
          <target state="translated">경우 &lt;code&gt;{skip,Reason}&lt;/code&gt; 반환되는 모듈의 모든 테스트 케이스는 생략하고 &lt;code&gt;Reason&lt;/code&gt; 는 HTML 결과 페이지에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="7176131e2ab61dc6ca1a310323b87e804a6b01fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the suite are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="translated">경우 &lt;code&gt;{skip,Reason}&lt;/code&gt; 반환, 스위트의 모든 테스트 케이스는 생략하고 &lt;code&gt;Reason&lt;/code&gt; 제품군에 대한 개요 로그에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="1d2a5b747d22c7eede603eddd2e58170ad2ad7b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, the test case is skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="translated">경우 &lt;code&gt;{skip,Reason}&lt;/code&gt; 반환, 테스트 케이스는 건너 뛰고 &lt;code&gt;Reason&lt;/code&gt; 제품군에 대한 개요 로그에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="43c5190e594ca77d2bcd9761108619b8160ca730" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{stop,Reason,NewState}&lt;/code&gt; is returned, any reply to &lt;code&gt;From&lt;/code&gt; must be specified explicitly using &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; process then calls &lt;code&gt;Module:terminate(Reason,NewState)&lt;/code&gt; and terminates.</source>
          <target state="translated">경우 &lt;code&gt;{stop,Reason,NewState}&lt;/code&gt; 반환됩니다에 대한 응답 &lt;code&gt;From&lt;/code&gt; 사용하여 명시 적으로 지정해야합니다 &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스는 호출 &lt;code&gt;Module:terminate(Reason,NewState)&lt;/code&gt; 및 종료합니다.</target>
        </trans-unit>
        <trans-unit id="555db6a996a08647cb4789219558187a695b3e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{stop,Reason,Reply,NewState}&lt;/code&gt; is returned, &lt;code&gt;Reply&lt;/code&gt; is given back to &lt;code&gt;From&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;{stop,Reason,Reply,NewState}&lt;/code&gt; 반환, &lt;code&gt;Reply&lt;/code&gt; 되돌아 주어진다 &lt;code&gt;From&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f07068ef6474408f3b2f01c567a6aa9dc31fae9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{swap_handler,Args1,NewState,Handler2,Args2}&lt;/code&gt; is returned, the event handler is replaced by &lt;code&gt;Handler2&lt;/code&gt; by first calling &lt;code&gt;Module:terminate(Args1,NewState)&lt;/code&gt; and then &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt;, where &lt;code&gt;Term&lt;/code&gt; is the return value of &lt;code&gt;Module:terminate/2&lt;/code&gt;. For more information, see &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;{swap_handler,Args1,NewState,Handler2,Args2}&lt;/code&gt; , 이벤트 핸들러에 의해 대체된다 반환 &lt;code&gt;Handler2&lt;/code&gt; 제 호출하여 &lt;code&gt;Module:terminate(Args1,NewState)&lt;/code&gt; 후 &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt; 여기서 &lt;code&gt;Term&lt;/code&gt; 인 &lt;code&gt;Module:terminate/2&lt;/code&gt; 의 반환 값 . 자세한 정보는 &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54e845975dbb16c88ec10ada23488e780175ae56" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;any&lt;/strong&gt; of the &lt;strong&gt;other&lt;/strong&gt; callback functions crashes (exit, throw or a plain crash) or return an invalid result (if a valid return has been specified), this function is called. The purpose is to allow the user handle this error (for instance to issue an error report).</source>
          <target state="translated">경우 &lt;strong&gt;어떤&lt;/strong&gt; 의 &lt;strong&gt;다른&lt;/strong&gt; 콜백 기능 (종료, 던지거나 일반 충돌) 충돌 또는 (유효한 수익이 지정된 경우) 잘못된 결과를 반환,이 함수가 호출됩니다. 사용자가이 오류를 처리 할 수 ​​있도록하는 것이 목적입니다 (예 : 오류 보고서 발행).</target>
        </trans-unit>
        <trans-unit id="937ff2e79e3364cc35a718607a325fdce946f46d" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;false&lt;/strong&gt;, megaco messages are sent using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/2&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;strong&gt;false&lt;/strong&gt; 인 경우 mega_ 메시지는 &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 전송 됩니다.</target>
        </trans-unit>
        <trans-unit id="9a26b3170e7ada86a34e6bf52ec13abf6a58d809" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;false&lt;/strong&gt;, megaco messages are sent using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;strong&gt;false&lt;/strong&gt; 인 경우 mega_ 메시지는 &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 전송 됩니다.</target>
        </trans-unit>
        <trans-unit id="d618248269dc3ffbf51a67242f81007c8e747d1d" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;true&lt;/strong&gt;, megaco message &lt;strong&gt;re-sends&lt;/strong&gt; are made using the &lt;code&gt;&lt;a href=&quot;megaco_transport#resend_message&quot;&gt;resend_message&lt;/a&gt;&lt;/code&gt; function. The initial message send is still done using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">경우 &lt;strong&gt;사실&lt;/strong&gt; , MEGACO 메시지 &lt;strong&gt;를 다시 보냅니다&lt;/strong&gt; 사용하여 만든 &lt;code&gt;&lt;a href=&quot;megaco_transport#resend_message&quot;&gt;resend_message&lt;/a&gt;&lt;/code&gt; 기능을. &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 초기 메시지 전송이 여전히 수행 됩니다.</target>
        </trans-unit>
        <trans-unit id="6705ceafbe769b2ce43385b2299973a524847817" translate="yes" xml:space="preserve">
          <source>If A and B are matched, but there is a failure in C, matching does not backtrack into A; instead it moves to the next alternative, that is, D. However, if the subpattern containing (*THEN) is given an alternative, it behaves differently:</source>
          <target state="translated">A와 B가 일치하지만 C에 오류가 있으면 일치는 A로 역 추적되지 않습니다. 대신 다음 대안, 즉 D로 이동합니다. 그러나 (* THEN)을 포함하는 서브 패턴에 대안이 주어지면 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c0f5376ef787219224d7bfc3d76505fad1f25c03" translate="yes" xml:space="preserve">
          <source>If A is a subset of X, the &lt;strong id=&quot;image&quot;&gt;image&lt;/strong&gt; of A under R is the set {y : x R y for some x in A}. If B is a subset of Y, the &lt;strong id=&quot;inverse_image&quot;&gt;inverse image&lt;/strong&gt; of B is the set {x : x R y for some y in B}.</source>
          <target state="translated">A가 X의 부분 집합 인 경우 R 아래의 A &lt;strong id=&quot;image&quot;&gt;이미지&lt;/strong&gt; 는 A의 일부 x에 대한 {y : x R y 세트입니다. B가 Y의 부분 집합 인 경우 B의 &lt;strong id=&quot;inverse_image&quot;&gt;역상&lt;/strong&gt; 은 B의 일부 y에 대해 {x : x R y 세트입니다.</target>
        </trans-unit>
        <trans-unit id="f6a630d6f8d7caebea5102271394fdcd67b18c9d" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K := V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_exact,ANNO,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="translated">A가 연관 &lt;code&gt;K := V&lt;/code&gt; 이면 Rep (A) = &lt;code&gt;{map_field_exact,ANNO,Rep(K),Rep(V)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c7b4fe5ddbf9a00d696a1d76a1917c8c5d2aeb3e" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K := V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_exact,LINE,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="translated">A가 연관 &lt;code&gt;K := V&lt;/code&gt; 인 경우 Rep (A) = &lt;code&gt;{map_field_exact,LINE,Rep(K),Rep(V)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="75688e538d64827729b81c8f7409b54e266cd7bd" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_assoc,ANNO,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="translated">A가 연관 &lt;code&gt;K =&amp;gt; V&lt;/code&gt; 이면 Rep (A) = &lt;code&gt;{map_field_assoc,ANNO,Rep(K),Rep(V)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="930fd81e91ccd105d16e4034de1e01640fca7bc6" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_assoc,LINE,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="translated">A가 연관 &lt;code&gt;K =&amp;gt; V&lt;/code&gt; 인 경우 Rep (A) = &lt;code&gt;{map_field_assoc,LINE,Rep(K),Rep(V)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="25f2fa0920ecae328194e2e5f0d6947b2fdf2b8f" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K := V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,ANNO,map_field_exact,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="translated">A가 연관 유형 &lt;code&gt;K := V&lt;/code&gt; 이고 여기서 &lt;code&gt;K&lt;/code&gt; 와 &lt;code&gt;V&lt;/code&gt; 는 유형이면 Rep (A) = &lt;code&gt;{type,ANNO,map_field_exact,[Rep(K),Rep(V)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4e632ebc019048443e5c38c3f2b726fe623c1461" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K := V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,LINE,map_field_exact,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="translated">A가 연관 유형 &lt;code&gt;K := V&lt;/code&gt; 이며 여기서 &lt;code&gt;K&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 가 유형 인 경우 Rep (A) = &lt;code&gt;{type,LINE,map_field_exact,[Rep(K),Rep(V)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fd7d66e8b109f42cf2b8b90dae2cc67fe469adfa" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,ANNO,map_field_assoc,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="translated">A가 연관 유형 &lt;code&gt;K =&amp;gt; V&lt;/code&gt; 이고 여기서 &lt;code&gt;K&lt;/code&gt; 와 &lt;code&gt;V&lt;/code&gt; 는 유형이면 Rep (A) = &lt;code&gt;{type,ANNO,map_field_assoc,[Rep(K),Rep(V)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fe916dba3dfcc9f9ef483ef2b2560b99a4239b84" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,LINE,map_field_assoc,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="translated">A가 연관 유형 &lt;code&gt;K =&amp;gt; V&lt;/code&gt; 이며 여기서 &lt;code&gt;K&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 가 유형 인 경우 Rep (A) = &lt;code&gt;{type,LINE,map_field_assoc,[Rep(K),Rep(V)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a746c5a2ff985d711d5a7f13e4e14806e0e62f7d" translate="yes" xml:space="preserve">
          <source>If A matches but B fails, the backtrack to (*COMMIT) causes the entire match to fail. However, if A and B match, but C fails, the backtrack to (*THEN) causes the next alternative (ABD) to be tried. This behavior is consistent, but is not always the same as in Perl. It means that if two or more backtracking verbs appear in succession, the last of them has no effect. Consider the following example:</source>
          <target state="translated">A와 일치하지만 B는 실패하면 (* COMMIT)으로의 역 추적이 전체 일치를 실패시킵니다. 그러나 A와 B가 일치하지만 C가 실패하면 역 추적 (* THEN)으로 인해 다음 대체 (ABD)가 시도됩니다. 이 동작은 일관되지만 항상 Perl과 동일하지는 않습니다. 그것은 두 개 이상의 역 추적 동사가 연속적으로 나타나면 마지막 동사는 효과가 없다는 것을 의미합니다. 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="5ec09bef075c491da05310ae82ca09d506f563c0" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep(P)],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">C가 케이스 절 &lt;code&gt;P -&amp;gt; B&lt;/code&gt; 이고 여기서 &lt;code&gt;P&lt;/code&gt; 는 패턴이고 &lt;code&gt;B&lt;/code&gt; 는 본문이면 Rep (C) = &lt;code&gt;{clause,ANNO,[Rep(P)],[],Rep(B)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c2a144a893fd5d00844284a1c4ab07c469c50d04" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep(P)],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">C가 케이스 절 &lt;code&gt;P -&amp;gt; B&lt;/code&gt; 인 경우, &lt;code&gt;P&lt;/code&gt; 는 패턴이고 &lt;code&gt;B&lt;/code&gt; 는 본문 인 경우 Rep (C) = &lt;code&gt;{clause,LINE,[Rep(P)],[],Rep(B)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0a5aa4f9266e04e273102dd79f1886cfeae24057" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep(P)],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt; 일 때 C가 case 절 P이면 , 여기서 &lt;code&gt;P&lt;/code&gt; 는 패턴이고, &lt;code&gt;Gs&lt;/code&gt; 는 가드 시퀀스이고, &lt;code&gt;B&lt;/code&gt; 는 본문이면 Rep (C) = &lt;code&gt;{clause,ANNO,[Rep(P)],Rep(Gs),Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1982d0d507cac2d94792ff43eb098cbb5c7b07ff" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep(P)],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt; (여기서 &lt;code&gt;P&lt;/code&gt; 는 패턴, &lt;code&gt;Gs&lt;/code&gt; 는 가드 시퀀스, &lt;code&gt;B&lt;/code&gt; 는 본문) 인 경우 C가 case 절인 경우 Rep (C) = &lt;code&gt;{clause,LINE,[Rep(P)],Rep(Gs),Rep(B)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3d659eda70c2e50509c30fcc418400a9aab3ac03" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({throw,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">C가 catch 절 &lt;code&gt;P -&amp;gt; B&lt;/code&gt; 이고 여기서 &lt;code&gt;P&lt;/code&gt; 는 패턴이고 &lt;code&gt;B&lt;/code&gt; 는 본문이면 Rep (C) = &lt;code&gt;{clause,ANNO,[Rep({throw,P,_})],[],Rep(B)}&lt;/code&gt; 즉, 명시 적 예외 클래스가 &lt;code&gt;throw&lt;/code&gt; 되고 명시 적 stacktrace 변수 &lt;code&gt;_&lt;/code&gt; 가 있거나없는 catch 절은 명시 적 예외 클래스가없고 명시 적 stacktrace 변수가없는 catch 절과 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5272c27438c02673801bf9383134101b74af201b" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">C가 catch 절 &lt;code&gt;P -&amp;gt; B&lt;/code&gt; 인 경우, 여기서 &lt;code&gt;P&lt;/code&gt; 는 패턴이고 &lt;code&gt;B&lt;/code&gt; 는 본문 인 경우 Rep (C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],[],Rep(B)}&lt;/code&gt; , 즉, 명시 적으로 예외 클래스와 캐치 절 &lt;code&gt;throw&lt;/code&gt; 및 또는 명시 적 스택 트레이스 변수없이 &lt;code&gt;_&lt;/code&gt; 는 명시 적으로 예외 클래스없이 명시 적 스택 트레이스 변수없이 캐치 절 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c311eaf58fab876bdc94780ac91685854b17771c" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({throw,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">&lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt; 일 때 C가 catch 절 P이면 , 여기서 &lt;code&gt;P&lt;/code&gt; 는 패턴이고, &lt;code&gt;Gs&lt;/code&gt; 는 가드 시퀀스이고, &lt;code&gt;B&lt;/code&gt; 는 본문이면 Rep (C) = &lt;code&gt;{clause,ANNO,[Rep({throw,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt; , 즉 명시 적 예외 클래스 &lt;code&gt;throw&lt;/code&gt; 가 있고 명시 적 스택 추적 변수 &lt;code&gt;_&lt;/code&gt; 가 있거나없는 catch 절은 명시 적 예외 클래스가없는 catch 절과 구별 될 수 없습니다. 명시적인 stacktrace 변수없이.</target>
        </trans-unit>
        <trans-unit id="66083733733867d178cfdf05fa2ebeeb26e587ba" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">&lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt; 일 때 C가 catch 절 P 인 경우 , 여기서 &lt;code&gt;P&lt;/code&gt; 는 패턴이고 &lt;code&gt;Gs&lt;/code&gt; 는 가드 시퀀스이고 &lt;code&gt;B&lt;/code&gt; 는 본문 인 경우 Rep (C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt; 이며, 명백한 예외 클래스와 캐치 절 &lt;code&gt;throw&lt;/code&gt; 와 함께 또는 명시 스택 트레이스 변수없이 &lt;code&gt;_&lt;/code&gt; 명백한 예외 클래스없이 캐치 절 구별 될 수없고 명시적인 스택 트레이스 변수없이</target>
        </trans-unit>
        <trans-unit id="8afa8db8880cd11a80b4f7cecb8f0640f10dde11" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({X,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">C가 catch 절 &lt;code&gt;X : P -&amp;gt; B&lt;/code&gt; 이고, 여기서 &lt;code&gt;X&lt;/code&gt; 는 원자 리터럴 또는 변수 패턴이고, &lt;code&gt;P&lt;/code&gt; 는 패턴이고 &lt;code&gt;B&lt;/code&gt; 는 본문이면 Rep (C) = &lt;code&gt;{clause,ANNO,[Rep({X,P,_})],[],Rep(B)}&lt;/code&gt; , 즉, 명시 적 예외 클래스가 있고 명시 적 stacktrace 변수 &lt;code&gt;_&lt;/code&gt; 가있는 catch 절은 명시 적 예외 클래스가 있고없는 catch 절과 구별 할 수 없습니다. 명시 적 stacktrace 변수.</target>
        </trans-unit>
        <trans-unit id="33763f19a17cfabb0fc3a9334e69f568d0598981" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">C가 catch 절 &lt;code&gt;X : P -&amp;gt; B&lt;/code&gt; 이며 여기서 &lt;code&gt;X&lt;/code&gt; 는 원자 리터럴 또는 변수 패턴이고 &lt;code&gt;P&lt;/code&gt; 는 패턴이고 &lt;code&gt;B&lt;/code&gt; 는 본문 인 경우 Rep (C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],[],Rep(B)}&lt;/code&gt; 즉, 명시 적 예외 클래스 및 명시 적 스택 추적 변수 &lt;code&gt;_&lt;/code&gt; 가있는 catch 절은 명시 적 예외 클래스가 있고 catch 예외가없는 catch 절과 구별 될 수 없습니다. 명시 적 스택 추적 변수</target>
        </trans-unit>
        <trans-unit id="43cc8aa87c6f7cf6d65593b565e96a75d05633ea" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({X,P,S})],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">C가 catch 절인 경우 &lt;code&gt;X : P : S -&amp;gt; B&lt;/code&gt; , 여기서 &lt;code&gt;X&lt;/code&gt; 는 원자 리터럴 또는 변수 패턴, &lt;code&gt;P&lt;/code&gt; 는 패턴, &lt;code&gt;S&lt;/code&gt; 는 변수, &lt;code&gt;B&lt;/code&gt; 는 본문, Rep (C) = &lt;code&gt;{clause,ANNO,[Rep({X,P,S})],[],Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54e98e1e13987f32a2240be5fce9eca6126a89ed" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">C가 catch 절인 &lt;code&gt;X : P : S -&amp;gt; B&lt;/code&gt; 여기서 &lt;code&gt;X&lt;/code&gt; 는 원자 리터럴 또는 변수 패턴, &lt;code&gt;P&lt;/code&gt; 는 패턴, &lt;code&gt;S&lt;/code&gt; 는 변수, &lt;code&gt;B&lt;/code&gt; 는 본문 인 경우 Rep (C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],[],Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a262d7341faa65ccb5ac93e7079518e8857e84b" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({X,P,S})],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">C가 catch 절인 경우 &lt;code&gt;X : P : S when Gs -&amp;gt; B&lt;/code&gt; , 여기서 &lt;code&gt;X&lt;/code&gt; 는 원자 리터럴 또는 변수 패턴, &lt;code&gt;P&lt;/code&gt; 는 패턴, &lt;code&gt;Gs&lt;/code&gt; 는 가드 시퀀스, &lt;code&gt;S&lt;/code&gt; 는 변수, &lt;code&gt;B&lt;/code&gt; 는 본문, then Rep (C) = &lt;code&gt;{clause,ANNO,[Rep({X,P,S})],Rep(Gs),Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ae0f4c55ba607c0c1ac95c07e874e6880664ec9" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">C가 catch 절 &lt;code&gt;X : P : S when Gs -&amp;gt; B&lt;/code&gt; 일 때 &lt;code&gt;X&lt;/code&gt; 는 원자 리터럴 또는 가변 패턴이고, &lt;code&gt;P&lt;/code&gt; 는 패턴, &lt;code&gt;Gs&lt;/code&gt; 는 가드 시퀀스, &lt;code&gt;S&lt;/code&gt; 는 변수, &lt;code&gt;B&lt;/code&gt; 는 본문입니다. Rep (C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],Rep(Gs),Rep(B)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b0e601c916b6ea0d1855c5d5324b1a12d0303cb8" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({X,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">C가 catch 절인 경우 &lt;code&gt;X : P when Gs -&amp;gt; B&lt;/code&gt; , 여기서 &lt;code&gt;X&lt;/code&gt; 는 원자 리터럴 또는 변수 패턴, &lt;code&gt;P&lt;/code&gt; 는 패턴, &lt;code&gt;Gs&lt;/code&gt; 는 보호 시퀀스, &lt;code&gt;B&lt;/code&gt; 는 본문, Rep (C) = &lt;code&gt;{clause,ANNO,[Rep({X,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt; , 즉, 명시 적 예외 클래스가 있고 명시 적 스택 추적 변수 &lt;code&gt;_&lt;/code&gt; 가 있는 catch 절은 다음과 구별 될 수 없습니다. 명시 적 예외 클래스가 있고 명시 적 stacktrace 변수가없는 catch 절.</target>
        </trans-unit>
        <trans-unit id="cd09edeb30671bd8912819376a2a0342249cf516" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">C가 catch 절 &lt;code&gt;X : P when Gs -&amp;gt; B&lt;/code&gt; 일 때 &lt;code&gt;X&lt;/code&gt; 는 원자 리터럴 또는 가변 패턴이고, &lt;code&gt;P&lt;/code&gt; 는 패턴이고, &lt;code&gt;Gs&lt;/code&gt; 는 가드 시퀀스이며, &lt;code&gt;B&lt;/code&gt; 는 본문이고 Rep (C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt; 즉, 명시 적 예외 클래스 및 명시 적 스택 추적 변수 &lt;code&gt;_&lt;/code&gt; 가 있는 catch 절을 구별 할 수 없습니다. 명시적인 예외 클래스가 있고 명시적인 stacktrace 변수가없는 catch 절</target>
        </trans-unit>
        <trans-unit id="4016717fdd4d5433989581c68c30070bb76884da" translate="yes" xml:space="preserve">
          <source>If C is a constraint &lt;code&gt;V :: T&lt;/code&gt;, where &lt;code&gt;V&lt;/code&gt; is a type variable and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(C) = &lt;code&gt;{type,ANNO,constraint,[{atom,ANNO,is_subtype},[Rep(V),Rep(T)]]}&lt;/code&gt;.</source>
          <target state="translated">C가 제약 조건 &lt;code&gt;V :: T&lt;/code&gt; 이고 여기서 &lt;code&gt;V&lt;/code&gt; 는 형식 변수이고 &lt;code&gt;T&lt;/code&gt; 는 형식 인 경우 Rep (C) = &lt;code&gt;{type,ANNO,constraint,[{atom,ANNO,is_subtype},[Rep(V),Rep(T)]]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df5fe92f62215d00d030e5a7bada64a7329d2d85" translate="yes" xml:space="preserve">
          <source>If C is a constraint &lt;code&gt;V :: T&lt;/code&gt;, where &lt;code&gt;V&lt;/code&gt; is a type variable and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(C) = &lt;code&gt;{type,LINE,constraint,[{atom,LINE,is_subtype},[Rep(V),Rep(T)]]}&lt;/code&gt;.</source>
          <target state="translated">C가 구속 조건 &lt;code&gt;V :: T&lt;/code&gt; 이고 여기서 &lt;code&gt;V&lt;/code&gt; 가 유형 변수이고 &lt;code&gt;T&lt;/code&gt; 가 유형이면 Rep (C) = &lt;code&gt;{type,LINE,constraint,[{atom,LINE,is_subtype},[Rep(V),Rep(T)]]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8d2da59f190a64375cc2ab954899e9cace4a77f" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,Rep(Ps),[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">C가 함수 절 &lt;code&gt;( Ps ) -&amp;gt; B&lt;/code&gt; 이고 여기서 &lt;code&gt;Ps&lt;/code&gt; 는 패턴 시퀀스이고 &lt;code&gt;B&lt;/code&gt; 는 본문이면 Rep (C) = &lt;code&gt;{clause,ANNO,Rep(Ps),[],Rep(B)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="17326d4fa4e4dd923f6996f5fc5f5d27a9e90bfb" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,Rep(Ps),[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">C가 함수 절 &lt;code&gt;( Ps ) -&amp;gt; B&lt;/code&gt; 인 경우, 여기서 &lt;code&gt;Ps&lt;/code&gt; 는 패턴 순서이고 &lt;code&gt;B&lt;/code&gt; 는 본문 인 경우 Rep (C) = &lt;code&gt;{clause,LINE,Rep(Ps),[],Rep(B)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cbc0eacd6cf64ab7e1b6a5aa346f15af4ee37ac3" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,Rep(Ps),Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;( Ps ) when Gs -&amp;gt; B&lt;/code&gt; 일 때 C가 함수 절 (Ps)이면 , 여기서 &lt;code&gt;Ps&lt;/code&gt; 는 패턴 시퀀스이고, &lt;code&gt;Gs&lt;/code&gt; 는 가드 시퀀스이고 &lt;code&gt;B&lt;/code&gt; 는 본문이면 Rep (C) = &lt;code&gt;{clause,ANNO,Rep(Ps),Rep(Gs),Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b58b02b2d6778f5c78bfa5c91aec26b39e9b26e2" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,Rep(Ps),Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;( Ps ) when Gs -&amp;gt; B&lt;/code&gt; 일 때 C가 함수 절 (Ps) 인 경우 , 여기서 &lt;code&gt;Ps&lt;/code&gt; 는 패턴 시퀀스이고, &lt;code&gt;Gs&lt;/code&gt; 는 가드 시퀀스이고 &lt;code&gt;B&lt;/code&gt; 는 바디 인 경우 Rep (C) = &lt;code&gt;{clause,LINE,Rep(Ps),Rep(Gs),Rep(B)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0b2834d93e535442b365d66608e72b7dd5d9a7b0" translate="yes" xml:space="preserve">
          <source>If C is an if clause &lt;code&gt;Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">C가 if 절 &lt;code&gt;Gs -&amp;gt; B&lt;/code&gt; 이고 &lt;code&gt;Gs&lt;/code&gt; 는 보호 시퀀스이고 &lt;code&gt;B&lt;/code&gt; 는 본문이면 Rep (C) = &lt;code&gt;{clause,ANNO,[],Rep(Gs),Rep(B)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bac3b590133c72b3e697e259f15ddfcb5136d5c1" translate="yes" xml:space="preserve">
          <source>If C is an if clause &lt;code&gt;Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">C가 if 절 &lt;code&gt;Gs -&amp;gt; B&lt;/code&gt; 이고 여기서 &lt;code&gt;Gs&lt;/code&gt; 가드 시퀀스이고 &lt;code&gt;B&lt;/code&gt; 가 본문 인 경우 Rep (C) = &lt;code&gt;{clause,LINE,[],Rep(Gs),Rep(B)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0cbfab94d790c9f8ddb1d5350bddeee9c6d6348c" translate="yes" xml:space="preserve">
          <source>If CPU topology information is unavailable.</source>
          <target state="translated">CPU 토폴로지 정보를 사용할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="a5c3ae58fb5f8a860fea2ef9b561020e0407c0fd" translate="yes" xml:space="preserve">
          <source>If D is a module declaration consisting of the forms &lt;code&gt;F_1&lt;/code&gt;, ..., &lt;code&gt;F_k&lt;/code&gt;, then Rep(D) = &lt;code&gt;[Rep(F_1), ..., Rep(F_k)]&lt;/code&gt;.</source>
          <target state="translated">D가 &lt;code&gt;F_1&lt;/code&gt; , ..., &lt;code&gt;F_k&lt;/code&gt; 형식으로 구성된 모듈 선언 이면 Rep (D) = &lt;code&gt;[Rep(F_1), ..., Rep(F_k)]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a30963b62350996a8d59e8d3d4f4343c158ae7a4" translate="yes" xml:space="preserve">
          <source>If E is a bitstring comprehension &lt;code&gt;&amp;lt;&amp;lt;E_0 || Q_1, ..., Q_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{bc,ANNO,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="translated">E가 비트 &lt;code&gt;&amp;lt;&amp;lt;E_0 || Q_1, ..., Q_k&amp;gt;&amp;gt;&lt;/code&gt; 이해력 인 경우 &amp;lt;&amp;lt; E_0 || Q_1, ..., Q_k &amp;gt;&amp;gt; , 여기서 각 &lt;code&gt;Q_i&lt;/code&gt; 는 한정자이고 Rep (E) = &lt;code&gt;{bc,ANNO,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt; 입니다. Rep (Q)에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="385f7db6a01f80887d7150e7f3e7bdd257de0fb5" translate="yes" xml:space="preserve">
          <source>If E is a bitstring comprehension &lt;code&gt;&amp;lt;&amp;lt;E_0 || Q_1, ..., Q_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{bc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="translated">E가 비트 스트링 &lt;code&gt;&amp;lt;&amp;lt;E_0 || Q_1, ..., Q_k&amp;gt;&amp;gt;&lt;/code&gt; 경우 &amp;lt;&amp;lt; E_0 || Q_1, ..., Q_k &amp;gt;&amp;gt; . 여기서 각 &lt;code&gt;Q_i&lt;/code&gt; 는 한정자이며 Rep (E) = &lt;code&gt;{bc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt; 입니다. 담당자 (Q)에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a215b35bfabec03f705356b11df781d76fe9bda6" translate="yes" xml:space="preserve">
          <source>If E is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(E) = &lt;code&gt;{bin,ANNO,[{bin_element,ANNO,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,ANNO,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">E가 비트 &lt;code&gt;&amp;lt;&amp;lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; 생성자 &amp;lt;&amp;lt; E_1 : Size_1 / TSL_1, ..., E_k : Size_k / TSL_k &amp;gt;&amp;gt; 인 경우, 여기서 각 &lt;code&gt;Size_i&lt;/code&gt; 는 표현식이고 각 &lt;code&gt;TSL_i&lt;/code&gt; 는 유형 특정 목록 인 경우 Rep (E) = &lt;code&gt;{bin,ANNO,[{bin_element,ANNO,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,ANNO,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; . Rep (TSL)에 대해서는 아래를 참조하십시오. 생략 된 &lt;code&gt;Size_i&lt;/code&gt; 는 &lt;code&gt;default&lt;/code&gt; 표시됩니다 . 생략 된 &lt;code&gt;TSL_i&lt;/code&gt; 는 &lt;code&gt;default&lt;/code&gt; 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a58b032de54c4d5d1f61a79ea10904e5176012ef" translate="yes" xml:space="preserve">
          <source>If E is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(E) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">E가 비트 스트링 생성자 &lt;code&gt;&amp;lt;&amp;lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; 이면 여기서 각 &lt;code&gt;Size_i&lt;/code&gt; 는 표현식이고 각 &lt;code&gt;TSL_i&lt;/code&gt; 는 유형별 목록입니다. Rep (E) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; . 담당자 (TSL)는 아래를 참조하십시오. 생략 된 &lt;code&gt;Size_i&lt;/code&gt; 는 &lt;code&gt;default&lt;/code&gt; 표시됩니다 . 생략 된 &lt;code&gt;TSL_i&lt;/code&gt; 는 &lt;code&gt;default&lt;/code&gt; 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="def0fd07bd4ff6d50e1223eca9053d3fa095d182" translate="yes" xml:space="preserve">
          <source>If E is a block expression &lt;code&gt;begin B end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{block,ANNO,Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">E가 블록 표현식이면 &lt;code&gt;begin B end&lt;/code&gt; 이고 &lt;code&gt;B&lt;/code&gt; 는 본문이면 Rep (E) = &lt;code&gt;{block,ANNO,Rep(B)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ff0400ff578820209af4c6bca75270b191887cfe" translate="yes" xml:space="preserve">
          <source>If E is a block expression &lt;code&gt;begin B end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{block,LINE,Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">E가 블록 표현식 인 경우 &lt;code&gt;begin B end&lt;/code&gt; , 여기서 &lt;code&gt;B&lt;/code&gt; 는 바디 인 경우 Rep (E) = &lt;code&gt;{block,LINE,Rep(B)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e9d8af3f74254d265168f6c22c16d0838a1ea340" translate="yes" xml:space="preserve">
          <source>If E is a case expression &lt;code&gt;case E_0 of Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where &lt;code&gt;E_0&lt;/code&gt; is an expression and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'case',ANNO,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="translated">E가 케이스 표현식 인 &lt;code&gt;case E_0 of Cc_1 ; ... ; Cc_k end&lt;/code&gt; , 여기서 &lt;code&gt;E_0&lt;/code&gt; 은 표현식이고 각 &lt;code&gt;Cc_i&lt;/code&gt; 는 case 절인 경우 Rep (E) = &lt;code&gt;{'case',ANNO,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d61d85721a2f8e94ee818ecc0cbe514b22d9b6e5" translate="yes" xml:space="preserve">
          <source>If E is a case expression &lt;code&gt;case E_0 of Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where &lt;code&gt;E_0&lt;/code&gt; is an expression and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="translated">E가 &lt;code&gt;case E_0 of Cc_1 ; ... ; Cc_k end&lt;/code&gt; 케이스 표현식 케이스 E_0이면; ...; Cc_k end , 여기서 &lt;code&gt;E_0&lt;/code&gt; 은 표현식이고 각 &lt;code&gt;Cc_i&lt;/code&gt; 는 케이스 절입니다. 그런 다음 Rep (E) = &lt;code&gt;{'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="096069597c0301e2331f3c9eeb4ba8c6fe89359b" translate="yes" xml:space="preserve">
          <source>If E is a catch expression &lt;code&gt;catch E_0&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'catch',ANNO,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">E가 catch 표현식 &lt;code&gt;catch E_0&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{'catch',ANNO,Rep(E_0)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="20926c71a541ebeeb5a5ce9236741b97b74ee9ee" translate="yes" xml:space="preserve">
          <source>If E is a catch expression &lt;code&gt;catch E_0&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'catch',LINE,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">E가 catch 표현식 &lt;code&gt;catch E_0&lt;/code&gt; 인 경우 Rep (E) = &lt;code&gt;{'catch',LINE,Rep(E_0)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0b58d732e6eb44c8650ef6ea1ab56a5738fed639" translate="yes" xml:space="preserve">
          <source>If E is a cons skeleton &lt;code&gt;[E_h | E_t]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{cons,ANNO,Rep(E_h),Rep(E_t)}&lt;/code&gt;.</source>
          <target state="translated">E가 단점 스켈레톤 &lt;code&gt;[E_h | E_t]&lt;/code&gt; , Rep (E) = &lt;code&gt;{cons,ANNO,Rep(E_h),Rep(E_t)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d685232ba5f2805f2661aa4dca2a66de454be03" translate="yes" xml:space="preserve">
          <source>If E is a cons skeleton &lt;code&gt;[E_h | E_t]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{cons,LINE,Rep(E_h),Rep(E_t)}&lt;/code&gt;.</source>
          <target state="translated">E가 단점 뼈대 인 경우 &lt;code&gt;[E_h | E_t]&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{cons,LINE,Rep(E_h),Rep(E_t)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fd154a4579d9aa67e94aa4c762704930a595e132" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Fc_1 ; ... ; Fc_k end&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{'fun',ANNO,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}&lt;/code&gt;.</source>
          <target state="translated">E가 fun 표현 &lt;code&gt;fun Fc_1 ; ... ; Fc_k end&lt;/code&gt; , 여기서 각 &lt;code&gt;Fc_i&lt;/code&gt; 는 함수 절이면 Rep (E) = &lt;code&gt;{'fun',ANNO,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00326b0fd36dc640e6ce203654ecdb5f5319afc6" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Fc_1 ; ... ; Fc_k end&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{'fun',LINE,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}&lt;/code&gt;.</source>
          <target state="translated">E가 재미있는 표현 &lt;code&gt;fun Fc_1 ; ... ; Fc_k end&lt;/code&gt; , 여기서 각 &lt;code&gt;Fc_i&lt;/code&gt; 는 함수 절이고 Rep (E) = &lt;code&gt;{'fun',LINE,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b930f9fc614875b26b77fcef08cb18fabcffa755" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Module:Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',ANNO,{function,Rep(Module),Rep(Name),Rep(Arity)}}&lt;/code&gt;. (Before Erlang/OTP R15: Rep(E) = &lt;code&gt;{'fun',ANNO,{function,Module,Name,Arity}}&lt;/code&gt;.)</source>
          <target state="translated">E가 재미있는 식 &lt;code&gt;fun Module:Name/Arity&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{'fun',ANNO,{function,Rep(Module),Rep(Name),Rep(Arity)}}&lt;/code&gt; 입니다. (Erlang / OTP R15 이전 : Rep (E) = &lt;code&gt;{'fun',ANNO,{function,Module,Name,Arity}}&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="25e7ad524342503c66fff38de3f9fd9620fdced2" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Module:Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',LINE,{function,Rep(Module),Rep(Name),Rep(Arity)}}&lt;/code&gt;. (Before Erlang/OTP R15: Rep(E) = &lt;code&gt;{'fun',LINE,{function,Module,Name,Arity}}&lt;/code&gt;.)</source>
          <target state="translated">E가 재미있는 표현 &lt;code&gt;fun Module:Name/Arity&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{'fun',LINE,{function,Rep(Module),Rep(Name),Rep(Arity)}}&lt;/code&gt; 입니다. (Erlang / OTP R15 이전 : Rep (E) = &lt;code&gt;{'fun',LINE,{function,Module,Name,Arity}}&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="21dea75946b388b1e954dab71b395d65115fda11" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name Fc_1 ; ... ; Name Fc_k end&lt;/code&gt;, where &lt;code&gt;Name&lt;/code&gt; is a variable and each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{named_fun,ANNO,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="translated">E가 재미있는 표현 &lt;code&gt;fun Name Fc_1 ; ... ; Name Fc_k end&lt;/code&gt; . 여기서 &lt;code&gt;Name&lt;/code&gt; 은 변수이고 각 &lt;code&gt;Fc_i&lt;/code&gt; 는 함수 절인 경우 Rep (E) = &lt;code&gt;{named_fun,ANNO,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="508f3673ffdf47d28232744927849cd0723a0e7f" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name Fc_1 ; ... ; Name Fc_k end&lt;/code&gt;, where &lt;code&gt;Name&lt;/code&gt; is a variable and each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{named_fun,LINE,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="translated">E가 재미있는 표현 &lt;code&gt;fun Name Fc_1 ; ... ; Name Fc_k end&lt;/code&gt; . 여기서 &lt;code&gt;Name&lt;/code&gt; 은 변수이고 각 &lt;code&gt;Fc_i&lt;/code&gt; 는 함수 절입니다. 그런 다음 Rep (E) = &lt;code&gt;{named_fun,LINE,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c48f719d2f5c29bf4ca1a282cd70942bcc783e8f" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',ANNO,{function,Name,Arity}}&lt;/code&gt;.</source>
          <target state="translated">E가 재미있는 표현 &lt;code&gt;fun Name/Arity&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{'fun',ANNO,{function,Name,Arity}}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8c55128cd4494aabe3305a25ed372470c6cb1e94" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',LINE,{function,Name,Arity}}&lt;/code&gt;.</source>
          <target state="translated">E가 재미있는 표현식 &lt;code&gt;fun Name/Arity&lt;/code&gt; 인 경우 Rep (E) = &lt;code&gt;{'fun',LINE,{function,Name,Arity}}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a222846ccb959514cd088c00700755704ce4b70c" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,ANNO,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">E가 함수 호출 &lt;code&gt;E_0(E_1, ..., E_k)&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{call,ANNO,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ae431171a9a508e70cab829bfde9130d74f3b08a" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,LINE,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">E가 함수 호출 &lt;code&gt;E_0(E_1, ..., E_k)&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{call,LINE,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b051c7315ab5f877f6f8d1a3fcb5d7352c32d165" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_m:E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,ANNO,{remote,ANNO,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">E가 함수 호출 &lt;code&gt;E_m:E_0(E_1, ..., E_k)&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{call,ANNO,{remote,ANNO,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a930c4f44f20684a46e411dc14a24535a2814f3b" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_m:E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">E가 함수 호출 &lt;code&gt;E_m:E_0(E_1, ..., E_k)&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ad4dbd16a1df7767e8ca6eb37d1f31ac1e007d69" translate="yes" xml:space="preserve">
          <source>If E is a list comprehension &lt;code&gt;[E_0 || Q_1, ..., Q_k]&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{lc,ANNO,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="translated">E가 목록 이해력 &lt;code&gt;[E_0 || Q_1, ..., Q_k]&lt;/code&gt; , 여기서 각 &lt;code&gt;Q_i&lt;/code&gt; 는 한정자이면 Rep (E) = &lt;code&gt;{lc,ANNO,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt; . Rep (Q)에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d0a9ba22f768bf25ed619e9861b8a15d7cd9192c" translate="yes" xml:space="preserve">
          <source>If E is a list comprehension &lt;code&gt;[E_0 || Q_1, ..., Q_k]&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{lc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="translated">E가 목록 &lt;code&gt;[E_0 || Q_1, ..., Q_k]&lt;/code&gt; 경우 [E_0 || Q_1, ..., Q_k] . 여기서 각 &lt;code&gt;Q_i&lt;/code&gt; 는 한정자이며 Rep (E) = &lt;code&gt;{lc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt; 입니다. 담당자 (Q)에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e8512e6de961ae7de3dc6cd02be5dfd7477d76f7" translate="yes" xml:space="preserve">
          <source>If E is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,ANNO,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">E가 맵 생성 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; 이고 여기서 각 &lt;code&gt;A_i&lt;/code&gt; 는 연관 &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{map,ANNO,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Rep (A)에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="39c06772c585b4d5e9af41e11c7fa823e87a3781" translate="yes" xml:space="preserve">
          <source>If E is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">E가 맵 작성 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; 인 경우 각 &lt;code&gt;A_i&lt;/code&gt; 는 연관 &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; 이고 Rep (E) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . 담당자 (A)는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="237f2587bea6e744a08e9b787c8ee8a08e4fc754" translate="yes" xml:space="preserve">
          <source>If E is a map update &lt;code&gt;E_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; or &lt;code&gt;E_i_1 := E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,ANNO,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">E가 맵 업데이트 &lt;code&gt;E_0#{A_1, ..., A_k}&lt;/code&gt; 이고 여기서 각 &lt;code&gt;A_i&lt;/code&gt; 는 연관 &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; 또는 &lt;code&gt;E_i_1 := E_i_2&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{map,ANNO,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Rep (A)에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="800dae600f3ee86ffec1de1f210ed80d17fd2b9b" translate="yes" xml:space="preserve">
          <source>If E is a map update &lt;code&gt;E_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; or &lt;code&gt;E_i_1 := E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,LINE,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">E가 맵 업데이트 &lt;code&gt;E_0#{A_1, ..., A_k}&lt;/code&gt; 인 경우, 각 &lt;code&gt;A_i&lt;/code&gt; 는 연관 &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; 또는 &lt;code&gt;E_i_1 := E_i_2&lt;/code&gt; 인 경우 Rep (E) = &lt;code&gt;{map,LINE,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . 담당자 (A)는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4f62176ee9725e6dd7a1d357a9791afa6d505171" translate="yes" xml:space="preserve">
          <source>If E is a match operator expression &lt;code&gt;P = E_0&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, then Rep(E) = &lt;code&gt;{match,ANNO,Rep(P),Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">E가 일치 연산자 표현식 &lt;code&gt;P = E_0&lt;/code&gt; 이고 여기서 &lt;code&gt;P&lt;/code&gt; 는 패턴이면 Rep (E) = &lt;code&gt;{match,ANNO,Rep(P),Rep(E_0)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="98ecb06f9387738ad9c4608934528d6d6501def9" translate="yes" xml:space="preserve">
          <source>If E is a match operator expression &lt;code&gt;P = E_0&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, then Rep(E) = &lt;code&gt;{match,LINE,Rep(P),Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">E가 일치 연산자 표현식 &lt;code&gt;P = E_0&lt;/code&gt; 이면 여기서 &lt;code&gt;P&lt;/code&gt; 는 패턴이며 Rep (E) = &lt;code&gt;{match,LINE,Rep(P),Rep(E_0)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="690ad831c8e62316c71be505eb989a5f5da834db" translate="yes" xml:space="preserve">
          <source>If E is a parenthesized expression &lt;code&gt;( E_0 )&lt;/code&gt;, then Rep(E) = &lt;code&gt;Rep(E_0)&lt;/code&gt;, that is, parenthesized expressions cannot be distinguished from their bodies.</source>
          <target state="translated">E가 괄호로 묶인 표현식 &lt;code&gt;( E_0 )&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;Rep(E_0)&lt;/code&gt; . 즉, 괄호로 묶은 표현식은 해당 본문과 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="eb97a9c72be1a3ec039d3b19e59af460c1f9597f" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k after E_0 -&amp;gt; B_t end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, &lt;code&gt;E_0&lt;/code&gt; is an expression, and &lt;code&gt;B_t&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{'receive',ANNO,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}&lt;/code&gt;.</source>
          <target state="translated">E가 수신 표현식 &lt;code&gt;receive Cc_1 ; ... ; Cc_k after E_0 -&amp;gt; B_t end&lt;/code&gt; , 여기서 각 &lt;code&gt;Cc_i&lt;/code&gt; 는 case 절이고, &lt;code&gt;E_0&lt;/code&gt; 은 표현식이고, &lt;code&gt;B_t&lt;/code&gt; 는 본문이며, Rep (E) = &lt;code&gt;{'receive',ANNO,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03e50f32be6fa18564dc0f97ac6d17895199c4c5" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k after E_0 -&amp;gt; B_t end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, &lt;code&gt;E_0&lt;/code&gt; is an expression, and &lt;code&gt;B_t&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}&lt;/code&gt;.</source>
          <target state="translated">E가 수신 표현식 인 경우 &lt;code&gt;receive Cc_1 ; ... ; Cc_k after E_0 -&amp;gt; B_t end&lt;/code&gt; . 여기서 각 &lt;code&gt;Cc_i&lt;/code&gt; 는 케이스 절이고, &lt;code&gt;E_0&lt;/code&gt; 은 표현식이고 &lt;code&gt;B_t&lt;/code&gt; 는 본문이며 Rep (E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="62607bd086692a7a4e73a9a4340bedc98933a8ce" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'receive',ANNO,[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="translated">E가 수신 표현식 &lt;code&gt;receive Cc_1 ; ... ; Cc_k end&lt;/code&gt; , 여기서 각 &lt;code&gt;Cc_i&lt;/code&gt; 는 case 절이면 Rep (E) = &lt;code&gt;{'receive',ANNO,[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="81d96409c6d75213915ef6028c674bf71b947761" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="translated">E가 수신 표현식 인 경우 &lt;code&gt;receive Cc_1 ; ... ; Cc_k end&lt;/code&gt; , 여기서 각 &lt;code&gt;Cc_i&lt;/code&gt; 는 케이스 절이고 Rep (E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8db402d6b9bfaaf27c4221b6ecb8f7a3438ef10d" translate="yes" xml:space="preserve">
          <source>If E is a record creation &lt;code&gt;#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(E) = &lt;code&gt;{record,ANNO,Name,[{record_field,ANNO,Rep(Field_1),Rep(E_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="translated">E가 레코드 생성 &lt;code&gt;#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt; 이고 여기서 각 &lt;code&gt;Field_i&lt;/code&gt; 는 원자 또는 &lt;code&gt;_&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{record,ANNO,Name,[{record_field,ANNO,Rep(Field_1),Rep(E_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="769c6455ce5fde46b459e44a8ec3bffa7196d158" translate="yes" xml:space="preserve">
          <source>If E is a record creation &lt;code&gt;#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(E) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="translated">E가 레코드 작성 &lt;code&gt;#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt; 인 경우, 각 &lt;code&gt;Field_i&lt;/code&gt; 가 원자 또는 &lt;code&gt;_&lt;/code&gt; 인 경우 Rep (E) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b95681bf643b3e4b28c35faa965a19ee4fda5ac" translate="yes" xml:space="preserve">
          <source>If E is a record field access &lt;code&gt;E_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_field,ANNO,Rep(E_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">E가 레코드 필드 인 경우 &lt;code&gt;E_0#Name.Field&lt;/code&gt; 에 액세스 합니다. 여기서 &lt;code&gt;Field&lt;/code&gt; 는 원자이면 Rep (E) = &lt;code&gt;{record_field,ANNO,Rep(E_0),Name,Rep(Field)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="571a72b7ca82dcb7bd3dbc0550c43c731464ee91" translate="yes" xml:space="preserve">
          <source>If E is a record field access &lt;code&gt;E_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_field,LINE,Rep(E_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">E가 레코드 필드 인 경우 &lt;code&gt;E_0#Name.Field&lt;/code&gt; 에 액세스 하십시오 ( 여기서 &lt;code&gt;Field&lt;/code&gt; 는 원 자임). Rep (E) = &lt;code&gt;{record_field,LINE,Rep(E_0),Name,Rep(Field)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bd0016f76592cf4abfa2e2b7e0edf19c3c161d6e" translate="yes" xml:space="preserve">
          <source>If E is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_index,ANNO,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">E가 레코드 필드 인덱스 &lt;code&gt;#Name.Field&lt;/code&gt; 이고 여기서 &lt;code&gt;Field&lt;/code&gt; 는 원자이면 Rep (E) = &lt;code&gt;{record_index,ANNO,Name,Rep(Field)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="41585c3fb51f7eca9a3e6945efca3d137bddef8d" translate="yes" xml:space="preserve">
          <source>If E is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">E가 레코드 필드 인덱스 &lt;code&gt;#Name.Field&lt;/code&gt; 인 경우, 여기서 &lt;code&gt;Field&lt;/code&gt; 는 원자 인 경우 Rep (E) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c0e1680739b87d61cf8de240ccb43c2b9ea6736a" translate="yes" xml:space="preserve">
          <source>If E is a record update &lt;code&gt;E_0#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record,ANNO,Rep(E_0),Name,[{record_field,ANNO,Rep(Field_1),Rep(E_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="translated">E가 레코드 업데이트 &lt;code&gt;E_0#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt; 이면 각 &lt;code&gt;Field_i&lt;/code&gt; 가 원자이면 Rep (E) = &lt;code&gt;{record,ANNO,Rep(E_0),Name,[{record_field,ANNO,Rep(Field_1),Rep(E_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c141b24fbc5240a27271026022f8b84cc1c46ec" translate="yes" xml:space="preserve">
          <source>If E is a record update &lt;code&gt;E_0#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record,LINE,Rep(E_0),Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="translated">E가 레코드 업데이트 &lt;code&gt;E_0#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt; 인 경우, 각 &lt;code&gt;Field_i&lt;/code&gt; 는 원자 인 경우 Rep (E) = &lt;code&gt;{record,LINE,Rep(E_0),Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1790d1e53e6feb25e42b2594447e491760461bcd" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">E가 시도 발현 경우 &lt;code&gt;try B after A end&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;A&lt;/code&gt; 는 다음 체이며, 담당자는 (E) = &lt;code&gt;{'try',ANNO,Rep(B),[],[],Rep(A)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5433ba0e7386d18ba29df013a33a3bd71eec1de4" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">E가 try 표현식 인 경우 &lt;code&gt;try B after A end&lt;/code&gt; . 여기서 &lt;code&gt;B&lt;/code&gt; 와 &lt;code&gt;A&lt;/code&gt; 는 body 인 경우 Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[],[],Rep(A)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="66db70f66ec2e1c9cfff251e52d9d4fb44005444" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">E가 try 표현식이면 &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k after A end&lt;/code&gt; , 여기서 &lt;code&gt;B&lt;/code&gt; 와 &lt;code&gt;A&lt;/code&gt; 는 본문이고 각 &lt;code&gt;Tc_i&lt;/code&gt; 는 catch 절이면 Rep (E) = &lt;code&gt;{'try',ANNO,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb0c9fd33084b3aa2b6298f495d8933521120111" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">E가 try 식이면 &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k after A end&lt;/code&gt; , 여기서 &lt;code&gt;B&lt;/code&gt; 와 &lt;code&gt;A&lt;/code&gt; 는 본문이고 각 &lt;code&gt;Tc_i&lt;/code&gt; 는 catch 절이며 Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="527f66fe559f2313ab4c9f07440149b4724a0e36" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}&lt;/code&gt;.</source>
          <target state="translated">E가 try 표현식이면 &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k end&lt;/code&gt; . 여기서 &lt;code&gt;B&lt;/code&gt; 는 본문이고 각 &lt;code&gt;Tc_i&lt;/code&gt; 는 catch 절입니다. Rep (E) = &lt;code&gt;{'try',ANNO,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0174ae0ac371a20fa8346b5c98865a86bb0973f" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}&lt;/code&gt;.</source>
          <target state="translated">E가 try 식이면 &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k end&lt;/code&gt; , 여기서 &lt;code&gt;B&lt;/code&gt; 는 본문이고 각 &lt;code&gt;Tc_i&lt;/code&gt; 는 catch 절입니다. 그런 다음 Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c97756483607f476bd044cc105daba38c615ff16" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">E가 try 식 &lt;code&gt;try B of Cc_1 ; ... ; Cc_k after A end&lt;/code&gt; , 여기서 &lt;code&gt;B&lt;/code&gt; 와 &lt;code&gt;A&lt;/code&gt; 는 본문이고 각 &lt;code&gt;Cc_i&lt;/code&gt; 는 case 절인 경우 Rep (E) = &lt;code&gt;{'try',ANNO,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17896fd4f3f657c1acca030c3b7c2477fd7ea070" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">E가 try 표현식 &lt;code&gt;try B of Cc_1 ; ... ; Cc_k after A end&lt;/code&gt; , 여기서 &lt;code&gt;B&lt;/code&gt; 와 &lt;code&gt;A&lt;/code&gt; 는 본문이고 각 &lt;code&gt;Cc_i&lt;/code&gt; 는 케이스 절이며 Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ed9f5ca2ce8dc840d927013fd593a6e43685c6fc" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">E가 try 식 &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end&lt;/code&gt; , 여기서 &lt;code&gt;B&lt;/code&gt; 와 &lt;code&gt;A&lt;/code&gt; 는 본문이고, 각 &lt;code&gt;Cc_i&lt;/code&gt; 는 case 절이고, 각 &lt;code&gt;Tc_j&lt;/code&gt; 는 catch 절입니다. Rep (E) = &lt;code&gt;{'try',ANNO,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f8fa527e6b0ee33c16b21df17493bd713be90d3" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">E가 try 표현식 &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end&lt;/code&gt; , 여기서 &lt;code&gt;B&lt;/code&gt; 와 &lt;code&gt;A&lt;/code&gt; 는 본문이고 각 &lt;code&gt;Cc_i&lt;/code&gt; 는 case 절이고 각 &lt;code&gt;Tc_j&lt;/code&gt; 는 catch 절이며 Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="87716dd0d35ab489a52485d5fff86ee7a86034f5" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}&lt;/code&gt;.</source>
          <target state="translated">E가 try 식 &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end&lt;/code&gt; , 여기서 &lt;code&gt;B&lt;/code&gt; 는 본문이고, 각 &lt;code&gt;Cc_i&lt;/code&gt; 는 case 절이고, 각 &lt;code&gt;Tc_j&lt;/code&gt; 는 catch 절입니다. Rep (E) = &lt;code&gt;{'try',ANNO,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32741bd8aaa39a55dc66b9c017671086d64dc49f" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}&lt;/code&gt;.</source>
          <target state="translated">E가 try 표현식 &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end&lt;/code&gt; (여기서 &lt;code&gt;B&lt;/code&gt; 는 본문이고 각 &lt;code&gt;Cc_i&lt;/code&gt; 는 case 절이고 각 &lt;code&gt;Tc_j&lt;/code&gt; 는 catch 절입니다. 그런 다음 Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a7a0dff10ecd15daa7bf8f1e4f2c478633f53be" translate="yes" xml:space="preserve">
          <source>If E is a tuple skeleton &lt;code&gt;{E_1, ..., E_k}&lt;/code&gt;, then Rep(E) = &lt;code&gt;{tuple,ANNO,[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">E가 튜플 뼈대 &lt;code&gt;{E_1, ..., E_k}&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{tuple,ANNO,[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ff91a87e5952e2ad6d9b444216166d09d3ca77eb" translate="yes" xml:space="preserve">
          <source>If E is a tuple skeleton &lt;code&gt;{E_1, ..., E_k}&lt;/code&gt;, then Rep(E) = &lt;code&gt;{tuple,LINE,[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">E가 튜플 스켈레톤 &lt;code&gt;{E_1, ..., E_k}&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{tuple,LINE,[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4d73c4b24d215a5b14fa705cf6b8fc7f04eaa159" translate="yes" xml:space="preserve">
          <source>If E is a variable &lt;code&gt;V&lt;/code&gt;, then Rep(E) = &lt;code&gt;{var,ANNO,A}&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">E가 변수 &lt;code&gt;V&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{var,ANNO,A}&lt;/code&gt; 이며 여기서 &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;V&lt;/code&gt; 와 동일한 문자로 구성된 인쇄 이름을 가진 원자입니다 .</target>
        </trans-unit>
        <trans-unit id="1cebb18271309572b378e6bac693d831da6a5de6" translate="yes" xml:space="preserve">
          <source>If E is a variable &lt;code&gt;V&lt;/code&gt;, then Rep(E) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">E가 변수 &lt;code&gt;V&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{var,LINE,A}&lt;/code&gt; 입니다 . 여기서 &lt;code&gt;A&lt;/code&gt; 는 인쇄 이름이 &lt;code&gt;V&lt;/code&gt; 와 동일한 문자로 구성된 원자입니다 .</target>
        </trans-unit>
        <trans-unit id="5399bc470d1e24b61c04135abc6ec1c48ce12a53" translate="yes" xml:space="preserve">
          <source>If E is an atomic literal &lt;code&gt;L&lt;/code&gt;, then Rep(E) = Rep(L).</source>
          <target state="translated">E가 원자 리터럴 &lt;code&gt;L&lt;/code&gt; 인 경우 Rep (E) = Rep (L)입니다.</target>
        </trans-unit>
        <trans-unit id="704415f6ec0f5288d1cf6770b2ca8548cffab4c3" translate="yes" xml:space="preserve">
          <source>If E is an if expression &lt;code&gt;if Ic_1 ; ... ; Ic_k end&lt;/code&gt;, where each &lt;code&gt;Ic_i&lt;/code&gt; is an if clause, then Rep(E) = &lt;code&gt;{'if',ANNO,[Rep(Ic_1), ..., Rep(Ic_k)]}&lt;/code&gt;.</source>
          <target state="translated">E가 if 표현식 &lt;code&gt;if Ic_1 ; ... ; Ic_k end&lt;/code&gt; , 여기서 각 &lt;code&gt;Ic_i&lt;/code&gt; 는 if 절이면 Rep (E) = &lt;code&gt;{'if',ANNO,[Rep(Ic_1), ..., Rep(Ic_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="591459a3195bdb1721ecc29118a41cd9ecf5ad76" translate="yes" xml:space="preserve">
          <source>If E is an if expression &lt;code&gt;if Ic_1 ; ... ; Ic_k end&lt;/code&gt;, where each &lt;code&gt;Ic_i&lt;/code&gt; is an if clause, then Rep(E) = &lt;code&gt;{'if',LINE,[Rep(Ic_1), ..., Rep(Ic_k)]}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;if Ic_1 ; ... ; Ic_k end&lt;/code&gt; 경우 E가 if 표현식 이면; ...; Ic_k end , 여기서 각 &lt;code&gt;Ic_i&lt;/code&gt; 는 if 절이고 Rep (E) = &lt;code&gt;{'if',LINE,[Rep(Ic_1), ..., Rep(Ic_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a540b17ecf127991c06127bf562cd9b622f73fd8" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;E_1 Op E_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(E) = &lt;code&gt;{op,ANNO,Op,Rep(E_1),Rep(E_2)}&lt;/code&gt;.</source>
          <target state="translated">E가 연산자 표현식 &lt;code&gt;E_1 Op E_2&lt;/code&gt; 이고 여기서 &lt;code&gt;Op&lt;/code&gt; 는 일치 연산자 &lt;code&gt;=&lt;/code&gt; 이외의 이항 연산자 이면 Rep (E) = &lt;code&gt;{op,ANNO,Op,Rep(E_1),Rep(E_2)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="74042cb0d91ea528b8846bce8407c4c94e7828f3" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;E_1 Op E_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(E) = &lt;code&gt;{op,LINE,Op,Rep(E_1),Rep(E_2)}&lt;/code&gt;.</source>
          <target state="translated">E가 연산자 표현식 &lt;code&gt;E_1 Op E_2&lt;/code&gt; 인 경우, &lt;code&gt;Op&lt;/code&gt; 는 match operator &lt;code&gt;=&lt;/code&gt; 이외의 2 진 연산자 인 경우 Rep (E) = &lt;code&gt;{op,LINE,Op,Rep(E_1),Rep(E_2)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6ae3a7a50482463c878cd3a4535e569c8a10c045" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;Op E_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(E) = &lt;code&gt;{op,ANNO,Op,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">E가 연산자 표현식 &lt;code&gt;Op E_0&lt;/code&gt; 이고 여기서 &lt;code&gt;Op&lt;/code&gt; 는 단항 연산자이면 Rep (E) = &lt;code&gt;{op,ANNO,Op,Rep(E_0)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="22209cbc466369d61322ba8f94065874c289f3f5" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;Op E_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(E) = &lt;code&gt;{op,LINE,Op,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">E가 연산자 표현식 &lt;code&gt;Op E_0&lt;/code&gt; 인 경우, &lt;code&gt;Op&lt;/code&gt; 는 단항 연산자 인 경우 Rep (E) = &lt;code&gt;{op,LINE,Op,Rep(E_0)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0dd90da6de4013d8fcdf427618cebc1de03b8894" translate="yes" xml:space="preserve">
          <source>If E is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{nil,ANNO}&lt;/code&gt;.</source>
          <target state="translated">E가 nil이면 &lt;code&gt;[]&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{nil,ANNO}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aecc39e30213c6bf99c4212c4aeafe719ce7ed08" translate="yes" xml:space="preserve">
          <source>If E is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{nil,LINE}&lt;/code&gt;.</source>
          <target state="translated">E가 nil이면 &lt;code&gt;[]&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{nil,LINE}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e80045470a896b7cf38c6a0866ea3eab2424863f" translate="yes" xml:space="preserve">
          <source>If Erlang is started in long name distributed mode, it needs to get the domain name from somewhere and reads system &lt;code&gt;inet&lt;/code&gt; configuration files for this information. Any hosts and resolver information found is also recorded, but not used as long as Erlang is configured for native lookups. The information becomes useful if the lookup method is changed to &lt;code&gt;'file'&lt;/code&gt; or &lt;code&gt;'dns'&lt;/code&gt;, see below.</source>
          <target state="translated">Erlang이 긴 이름 분산 모드로 시작된 경우 어딘가에서 도메인 이름을 가져 &lt;code&gt;inet&lt;/code&gt; 정보에 대한 시스템 inet 구성 파일을 읽습니다 . 찾은 모든 호스트 및 확인자 정보도 기록되지만 Erlang이 기본 조회를 위해 구성된 경우에는 사용되지 않습니다. 조회 방법이 &lt;code&gt;'file'&lt;/code&gt; 또는 &lt;code&gt;'dns'&lt;/code&gt; 로 변경되면이 정보가 유용 해집니다 ( 아래 참조).</target>
        </trans-unit>
        <trans-unit id="8ba99b579cb5dc5d83148e021817ebf4a31439e9" translate="yes" xml:space="preserve">
          <source>If Erlang sends, for example, the list &lt;code&gt;[$a,$b,$c]&lt;/code&gt; to the port, the &lt;code&gt;bufflen&lt;/code&gt; variable is &lt;code&gt;3&lt;/code&gt; and the &lt;code&gt;buff&lt;/code&gt; variable contains &lt;code&gt;{'a','b','c'}&lt;/code&gt; (no &lt;code&gt;NULL&lt;/code&gt; termination). Usually the first byte is used as an opcode, which is the case in this driver too (at least when the port is in &lt;code&gt;command&lt;/code&gt; mode). The opcodes are defined as follows:</source>
          <target state="translated">Erlang이 예를 들어 목록 &lt;code&gt;[$a,$b,$c]&lt;/code&gt; 를 포트로 &lt;code&gt;bufflen&lt;/code&gt; , &lt;code&gt;buff&lt;/code&gt; 변수 는 &lt;code&gt;3&lt;/code&gt; 이고 버프 변수는 &lt;code&gt;{'a','b','c'}&lt;/code&gt; 를 포함합니다 ( &lt;code&gt;NULL&lt;/code&gt; 종료 없음) ). 일반적으로 첫 번째 바이트는 opcode로 사용되며,이 드라이버에서도 마찬가지입니다 (적어도 포트가 &lt;code&gt;command&lt;/code&gt; 모드 인 경우). opcode는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d4fecac2cf10df2e039ce3e4f4d5fa9aa6b7bf2b" translate="yes" xml:space="preserve">
          <source>If F is a function declaration &lt;code&gt;Name Fc_1 ; ... ; Name Fc_k&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause with a pattern sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{function,ANNO,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="translated">F가 함수 선언 &lt;code&gt;Name Fc_1 ; ... ; Name Fc_k&lt;/code&gt; . 여기서 각 &lt;code&gt;Fc_i&lt;/code&gt; 는 동일한 길이 &lt;code&gt;Arity&lt;/code&gt; 의 패턴 시퀀스가있는 함수 절이고 Rep (F) = &lt;code&gt;{function,ANNO,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="914c013be868be9b46633a3fae8ef36377ee34a1" translate="yes" xml:space="preserve">
          <source>If F is a function declaration &lt;code&gt;Name Fc_1 ; ... ; Name Fc_k&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause with a pattern sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{function,LINE,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="translated">F가 함수 선언 인 경우 &lt;code&gt;Name Fc_1 ; ... ; Name Fc_k&lt;/code&gt; , 여기서 각 &lt;code&gt;Fc_i&lt;/code&gt; 는 길이가 같은 &lt;code&gt;Arity&lt;/code&gt; 의 패턴 시퀀스를 가진 함수 절이며 Rep (F) = &lt;code&gt;{function,LINE,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92b2fdf009166615e68068377c093d1265169847" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-Spec Name Ft_1; ...; Ft_k&lt;/code&gt;, where &lt;code&gt;Spec&lt;/code&gt; is either the atom &lt;code&gt;spec&lt;/code&gt; or the atom &lt;code&gt;callback&lt;/code&gt;, and each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="translated">F가 함수 사양 인 경우 &lt;code&gt;-Spec Name Ft_1; ...; Ft_k&lt;/code&gt; , 여기서 &lt;code&gt;Spec&lt;/code&gt; 은 원자 &lt;code&gt;spec&lt;/code&gt; 또는 원자 &lt;code&gt;callback&lt;/code&gt; 이고 각 &lt;code&gt;Ft_i&lt;/code&gt; 는 &lt;code&gt;Arity&lt;/code&gt; 길이가 동일한 인수 시퀀스를 사용하여 제약이있을 수있는 함수 유형 인 경우 Rep (F) = &lt;code&gt;{attribute,ANNO,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="839e0427c2712f13a30277505b79b3f3678e27bc" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-Spec Name Ft_1; ...; Ft_k&lt;/code&gt;, where &lt;code&gt;Spec&lt;/code&gt; is either the atom &lt;code&gt;spec&lt;/code&gt; or the atom &lt;code&gt;callback&lt;/code&gt;, and each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,Line,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="translated">F가 함수 스펙 인 경우 &lt;code&gt;-Spec Name Ft_1; ...; Ft_k&lt;/code&gt; (여기서 &lt;code&gt;Spec&lt;/code&gt; 은 atom &lt;code&gt;spec&lt;/code&gt; 또는 atom &lt;code&gt;callback&lt;/code&gt; 이며 각 &lt;code&gt;Ft_i&lt;/code&gt; 는 길이가 &lt;code&gt;Arity&lt;/code&gt; 인 인수 시퀀스가있는 제한적인 함수 유형입니다. 그런 다음 Rep (F) = &lt;code&gt;{attribute,Line,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d7b133a685e1078d511adc4d4a4c0155cfdea6af" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-spec Mod:Name Ft_1; ...; Ft_k&lt;/code&gt;, where each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="translated">F가 함수 사양 인 경우 &lt;code&gt;-spec Mod:Name Ft_1; ...; Ft_k&lt;/code&gt; 각각 &lt;code&gt;Ft_i&lt;/code&gt; 가 동일한 길이의 인자 서열과 아마도 제한된 함수 타입 &lt;code&gt;Arity&lt;/code&gt; 하고 담당자 (F) = &lt;code&gt;{attribute,ANNO,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17271a999b9344b2a590ac6ed7fcd19ea7837c3a" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-spec Mod:Name Ft_1; ...; Ft_k&lt;/code&gt;, where each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,Line,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="translated">F가 함수 스펙 인 경우 &lt;code&gt;-spec Mod:Name Ft_1; ...; Ft_k&lt;/code&gt; , 여기서 각 &lt;code&gt;Ft_i&lt;/code&gt; 는 길이가 &lt;code&gt;Arity&lt;/code&gt; 인 인수 시퀀스가있는 제한적인 함수 유형이며 Rep (F) = &lt;code&gt;{attribute,Line,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fa68f807198b22105fc44214b7d3c63162ade67" translate="yes" xml:space="preserve">
          <source>If F is a record declaration &lt;code&gt;-record(Name,{V_1, ..., V_k})&lt;/code&gt;, where each &lt;code&gt;V_i&lt;/code&gt; is a record field, then Rep(F) = &lt;code&gt;{attribute,ANNO,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;. For Rep(V), see below.</source>
          <target state="translated">F가 레코드 선언 &lt;code&gt;-record(Name,{V_1, ..., V_k})&lt;/code&gt; 이고 각 &lt;code&gt;V_i&lt;/code&gt; 가 레코드 필드이면 Rep (F) = &lt;code&gt;{attribute,ANNO,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt; . Rep (V)는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fd91f9ee512189a9782c72f858106c81c42eb39a" translate="yes" xml:space="preserve">
          <source>If F is a record declaration &lt;code&gt;-record(Name,{V_1, ..., V_k})&lt;/code&gt;, where each &lt;code&gt;V_i&lt;/code&gt; is a record field, then Rep(F) = &lt;code&gt;{attribute,LINE,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;. For Rep(V), see below.</source>
          <target state="translated">F가 레코드 선언 &lt;code&gt;-record(Name,{V_1, ..., V_k})&lt;/code&gt; 이고 여기서 각 &lt;code&gt;V_i&lt;/code&gt; 가 레코드 필드 인 경우 Rep (F) = &lt;code&gt;{attribute,LINE,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt; 입니다. Rep (V)에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="25adb05f207dd769bbafb0f578b65f641a0a7794" translate="yes" xml:space="preserve">
          <source>If F is a record field type &lt;code&gt;Name :: Type&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{type,ANNO,field_type,[Rep(Name),Rep(Type)]}&lt;/code&gt;.</source>
          <target state="translated">F가 레코드 필드 유형 &lt;code&gt;Name :: Type&lt;/code&gt; 이고 여기서 &lt;code&gt;Type&lt;/code&gt; 은 유형이면 Rep (F) = &lt;code&gt;{type,ANNO,field_type,[Rep(Name),Rep(Type)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eab32c665244fb293fe17fe26c52469e41031dd4" translate="yes" xml:space="preserve">
          <source>If F is a record field type &lt;code&gt;Name :: Type&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{type,LINE,field_type,[Rep(Name),Rep(Type)]}&lt;/code&gt;.</source>
          <target state="translated">F가 레코드 필드 유형 &lt;code&gt;Name :: Type&lt;/code&gt; 인 경우, &lt;code&gt;Type&lt;/code&gt; 은 유형 인 경우 Rep (F) = &lt;code&gt;{type,LINE,field_type,[Rep(Name),Rep(Type)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6239a9176ea881407034a190550ff59286863ce7" translate="yes" xml:space="preserve">
          <source>If F is a type declaration &lt;code&gt;-Type Name(V_1, ..., V_k) :: T&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is either the atom &lt;code&gt;type&lt;/code&gt; or the atom &lt;code&gt;opaque&lt;/code&gt;, each &lt;code&gt;V_i&lt;/code&gt; is a type variable, and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{attribute,ANNO,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;.</source>
          <target state="translated">F가 유형 선언 &lt;code&gt;-Type Name(V_1, ..., V_k) :: T&lt;/code&gt; 이고 여기서 &lt;code&gt;Type&lt;/code&gt; 은 원자 &lt;code&gt;type&lt;/code&gt; 이거나 원자 &lt;code&gt;opaque&lt;/code&gt; 이면 각 &lt;code&gt;V_i&lt;/code&gt; 는 유형 변수이고 &lt;code&gt;T&lt;/code&gt; 는 유형 인 경우 Rep ( F) = &lt;code&gt;{attribute,ANNO,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31cc499e6743611a48be1c32ba0e0814b6fa811f" translate="yes" xml:space="preserve">
          <source>If F is a type declaration &lt;code&gt;-Type Name(V_1, ..., V_k) :: T&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is either the atom &lt;code&gt;type&lt;/code&gt; or the atom &lt;code&gt;opaque&lt;/code&gt;, each &lt;code&gt;V_i&lt;/code&gt; is a variable, and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{attribute,LINE,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;.</source>
          <target state="translated">F가 유형 선언 &lt;code&gt;-Type Name(V_1, ..., V_k) :: T&lt;/code&gt; 인 경우, 여기서 &lt;code&gt;Type&lt;/code&gt; 은 원자 &lt;code&gt;type&lt;/code&gt; 이거나 &lt;code&gt;opaque&lt;/code&gt; 경우 각 &lt;code&gt;V_i&lt;/code&gt; 는 변수이고 &lt;code&gt;T&lt;/code&gt; 는 유형이고 Rep (F ) = &lt;code&gt;{attribute,LINE,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="18b64b9b51dd41ff649ef5c26db0f7f069a7d35d" translate="yes" xml:space="preserve">
          <source>If F is a wild attribute &lt;code&gt;-A(T)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,A,T}&lt;/code&gt;.</source>
          <target state="translated">F가 와일드 속성 &lt;code&gt;-A(T)&lt;/code&gt; 이면 Rep (F) = &lt;code&gt;{attribute,ANNO,A,T}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c81677bfb1fe791cbe449f2226181f612e7d5741" translate="yes" xml:space="preserve">
          <source>If F is a wild attribute &lt;code&gt;-A(T)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,A,T}&lt;/code&gt;.</source>
          <target state="translated">F가 와일드 속성 &lt;code&gt;-A(T)&lt;/code&gt; 인 경우 Rep (F) = &lt;code&gt;{attribute,LINE,A,T}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b1d2d6dc97c9b7259053b20eb74732ea1141eebd" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-export([Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}&lt;/code&gt;.</source>
          <target state="translated">F가 속성 &lt;code&gt;-export([Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt; 이면 Rep (F) = &lt;code&gt;{attribute,ANNO,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c092236a8dd4b964a8de640c01239a90a1e7a1ac" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-export([Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}&lt;/code&gt;.</source>
          <target state="translated">F가 &lt;code&gt;-export([Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt; &lt;code&gt;{attribute,LINE,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}&lt;/code&gt; 경우 Rep (F) = {attribute, LINE, export, [{Fun_1, A_1}, ..., {Fun_k, A_k}]} .</target>
        </trans-unit>
        <trans-unit id="c034270eafab2ed7bcecacf02af15e5097193b1d" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-file(File,Line)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,file,{File,Line}}&lt;/code&gt;.</source>
          <target state="translated">F가 속성 &lt;code&gt;-file(File,Line)&lt;/code&gt; 이면 Rep (F) = &lt;code&gt;{attribute,ANNO,file,{File,Line}}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a3859e84d13f06a07d526a9d0610934ed80fd58d" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-file(File,Line)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,file,{File,Line}}&lt;/code&gt;.</source>
          <target state="translated">F가 속성 &lt;code&gt;-file(File,Line)&lt;/code&gt; 인 경우 Rep (F) = &lt;code&gt;{attribute,LINE,file,{File,Line}}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fc2d15becf26ad2d7caf42380a72b2c27da43c41" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}&lt;/code&gt;.</source>
          <target state="translated">F가 &lt;code&gt;-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt; &lt;code&gt;{attribute,ANNO,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}&lt;/code&gt; 이면 Rep (F) = {attribute, ANNO, import, {Mod, [{Fun_1, A_1}, .. . {Fun_k, A_k}]}} .</target>
        </trans-unit>
        <trans-unit id="2bb3ff8ec37dad7da6fb624ff1aa1f2defef3f1c" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}&lt;/code&gt;.</source>
          <target state="translated">F가 &lt;code&gt;-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt; &lt;code&gt;{attribute,LINE,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}&lt;/code&gt; 경우 Rep (F) = {attribute, LINE, import, {Mod, [{Fun_1, A_1}, .. ., {Fun_k, A_k}]}} .</target>
        </trans-unit>
        <trans-unit id="eb3ea6219e1cb69bee47ba7d3c0d07637a4dae6e" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-module(Mod)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,module,Mod}&lt;/code&gt;.</source>
          <target state="translated">F가 속성 &lt;code&gt;-module(Mod)&lt;/code&gt; 이면 Rep (F) = &lt;code&gt;{attribute,ANNO,module,Mod}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="740887309045a225d9cb600109651a0966db65e3" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-module(Mod)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,module,Mod}&lt;/code&gt;.</source>
          <target state="translated">F가 속성 &lt;code&gt;-module(Mod)&lt;/code&gt; 인 경우 Rep (F) = &lt;code&gt;{attribute,LINE,module,Mod}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dc8b8c5e56eae2112a18d51dd6a9fcb8af749ac2" translate="yes" xml:space="preserve">
          <source>If Ft is a constrained function type &lt;code&gt;Ft_1 when Fc&lt;/code&gt;, where &lt;code&gt;Ft_1&lt;/code&gt; is a function type and &lt;code&gt;Fc&lt;/code&gt; is a function constraint, then Rep(T) = &lt;code&gt;{type,ANNO,bounded_fun,[Rep(Ft_1),Rep(Fc)]}&lt;/code&gt;. For Rep(Fc), see below.</source>
          <target state="translated">&lt;code&gt;Ft_1 when Fc&lt;/code&gt; 일 때 Ft가 제약 된 함수 유형 Ft_1이면 , 여기서 &lt;code&gt;Ft_1&lt;/code&gt; 은 함수 유형이고 &lt;code&gt;Fc&lt;/code&gt; 는 함수 제약 조건이면 Rep (T) = &lt;code&gt;{type,ANNO,bounded_fun,[Rep(Ft_1),Rep(Fc)]}&lt;/code&gt; 입니다. Rep (Fc)에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="be0d9740980dc9bb7d3b497c88ac52e3e4ae32a4" translate="yes" xml:space="preserve">
          <source>If Ft is a constrained function type &lt;code&gt;Ft_1 when Fc&lt;/code&gt;, where &lt;code&gt;Ft_1&lt;/code&gt; is a function type and &lt;code&gt;Fc&lt;/code&gt; is a function constraint, then Rep(T) = &lt;code&gt;{type,LINE,bounded_fun,[Rep(Ft_1),Rep(Fc)]}&lt;/code&gt;. For Rep(Fc), see below.</source>
          <target state="translated">&lt;code&gt;Ft_1 when Fc&lt;/code&gt; 일 때 Ft가 제한된 함수 유형 Ft_1이면 &lt;code&gt;Ft_1&lt;/code&gt; 은 함수 유형이고 &lt;code&gt;Fc&lt;/code&gt; 는 함수 제약 조건 인 경우 Rep (T) = &lt;code&gt;{type,LINE,bounded_fun,[Rep(Ft_1),Rep(Fc)]}&lt;/code&gt; 입니다. 담당자 (Fc)에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="addf4ad1342821174bcf34191602826b5ec30735" translate="yes" xml:space="preserve">
          <source>If Ft is a function type &lt;code&gt;(T_1, ..., T_n) -&amp;gt; T_0&lt;/code&gt;, where each &lt;code&gt;T_i&lt;/code&gt; is a type, then Rep(Ft) = &lt;code&gt;{type,ANNO,'fun',[{type,ANNO,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">Ft가 함수 유형 &lt;code&gt;(T_1, ..., T_n) -&amp;gt; T_0&lt;/code&gt; 이고 각 &lt;code&gt;T_i&lt;/code&gt; 가 유형이면 Rep (Ft) = &lt;code&gt;{type,ANNO,'fun',[{type,ANNO,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad272ac4cee50fc07993902e12ff74bb1a162f57" translate="yes" xml:space="preserve">
          <source>If Ft is a function type &lt;code&gt;(T_1, ..., T_n) -&amp;gt; T_0&lt;/code&gt;, where each &lt;code&gt;T_i&lt;/code&gt; is a type, then Rep(Ft) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">Ft가 함수 유형 &lt;code&gt;(T_1, ..., T_n) -&amp;gt; T_0&lt;/code&gt; 이면 각 &lt;code&gt;T_i&lt;/code&gt; 는 유형 인 경우 Rep (Ft) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="956fa8f47f1bcedade9724b256d1fe2c59b770a8" translate="yes" xml:space="preserve">
          <source>If G is a directed graph, it holds that the vertices and edges of G are the same as the vertices and edges of &lt;code&gt;family_to_digraph(digraph_to_family(G))&lt;/code&gt;.</source>
          <target state="translated">G가 유향 그래프 인 경우 G의 꼭짓점과 가장자리가 &lt;code&gt;family_to_digraph(digraph_to_family(G))&lt;/code&gt; 의 꼭짓점과 가장자리와 동일하다는 것이 유지 됩니다.</target>
        </trans-unit>
        <trans-unit id="02f41904356cb27048a5f981f0ab30233861e22f" translate="yes" xml:space="preserve">
          <source>If Gt is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is a guard test and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(Gt) = &lt;code&gt;{bin,ANNO,[{bin_element,ANNO,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,ANNO,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see above. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">Gt가 비트 &lt;code&gt;&amp;lt;&amp;lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; 생성자 &amp;lt;&amp;lt; Gt_1 : Size_1 / TSL_1, ..., Gt_k : Size_k / TSL_k &amp;gt;&amp;gt; 이면 각 &lt;code&gt;Size_i&lt;/code&gt; 는 가드 테스트이고 각 &lt;code&gt;TSL_i&lt;/code&gt; 는 유형 특정 목록 인 경우 Rep (Gt) = &lt;code&gt;{bin,ANNO,[{bin_element,ANNO,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,ANNO,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; . Rep (TSL)에 대해서는 위를 참조하십시오. 생략 된 &lt;code&gt;Size_i&lt;/code&gt; 는 &lt;code&gt;default&lt;/code&gt; 표시됩니다 . 생략 된 &lt;code&gt;TSL_i&lt;/code&gt; 는 &lt;code&gt;default&lt;/code&gt; 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7c4c1f8a634a58d8cf6efc770bf44b8e01c62ed" translate="yes" xml:space="preserve">
          <source>If Gt is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is a guard test and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(Gt) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see above. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">Gt가 비트 스트링 생성자 &lt;code&gt;&amp;lt;&amp;lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; 인 경우, 각 &lt;code&gt;Size_i&lt;/code&gt; 는 가드 테스트이고 각 &lt;code&gt;TSL_i&lt;/code&gt; 는 유형 지정자 목록 인 경우 Rep (Gt) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; . 담당자 (TSL)는 위를 참조하십시오. 생략 된 &lt;code&gt;Size_i&lt;/code&gt; 는 &lt;code&gt;default&lt;/code&gt; 표시됩니다 . 생략 된 &lt;code&gt;TSL_i&lt;/code&gt; 는 &lt;code&gt;default&lt;/code&gt; 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="cd4e2d2654420d08ff75e569801e0f82ea1d8e67" translate="yes" xml:space="preserve">
          <source>If Gt is a cons skeleton &lt;code&gt;[Gt_h | Gt_t]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{cons,ANNO,Rep(Gt_h),Rep(Gt_t)}&lt;/code&gt;.</source>
          <target state="translated">Gt가 단점 스켈레톤 인 경우 &lt;code&gt;[Gt_h | Gt_t]&lt;/code&gt; , Rep (Gt) = &lt;code&gt;{cons,ANNO,Rep(Gt_h),Rep(Gt_t)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84104d736902648592238a7aed481c0fca8a1b02" translate="yes" xml:space="preserve">
          <source>If Gt is a cons skeleton &lt;code&gt;[Gt_h | Gt_t]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{cons,LINE,Rep(Gt_h),Rep(Gt_t)}&lt;/code&gt;.</source>
          <target state="translated">Gt가 단점 뼈대 인 경우 &lt;code&gt;[Gt_h | Gt_t]&lt;/code&gt; 이면 Rep (Gt) = &lt;code&gt;{cons,LINE,Rep(Gt_h),Rep(Gt_t)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="67aa27e3b255c0b23af7ede9fa213ab9884fe39f" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{call,ANNO,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">Gt가 함수 호출 &lt;code&gt;A(Gt_1, ..., Gt_k)&lt;/code&gt; 이고 여기서 &lt;code&gt;A&lt;/code&gt; 는 원자이면 Rep (Gt) = &lt;code&gt;{call,ANNO,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="155c34327c1aac1242765939018d40572e3ece41" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{call,LINE,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">Gt가 함수 호출 &lt;code&gt;A(Gt_1, ..., Gt_k)&lt;/code&gt; 이면 &lt;code&gt;A&lt;/code&gt; 는 원자 인 경우 Rep (Gt) = &lt;code&gt;{call,LINE,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62b6a664574ec6785fbcee63137675fde7e8ef5d" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A_m:A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A_m&lt;/code&gt; is the atom &lt;code&gt;erlang&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is an atom or an operator, then Rep(Gt) = &lt;code&gt;{call,ANNO,{remote,ANNO,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">Gt가 함수 인 경우 &lt;code&gt;A_m:A(Gt_1, ..., Gt_k)&lt;/code&gt; 호출 합니다. 여기서 &lt;code&gt;A_m&lt;/code&gt; 은 원자 &lt;code&gt;erlang&lt;/code&gt; 이고 &lt;code&gt;A&lt;/code&gt; 는 원자 또는 연산자입니다. Rep (Gt) = &lt;code&gt;{call,ANNO,{remote,ANNO,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fe106be5e00c62f004b81ec1a1e00fa0b616f14" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A_m:A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A_m&lt;/code&gt; is the atom &lt;code&gt;erlang&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is an atom or an operator, then Rep(Gt) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">GT는 함수 호출이면 &lt;code&gt;A_m:A(Gt_1, ..., Gt_k)&lt;/code&gt; , &lt;code&gt;A_m&lt;/code&gt; 가 원자이다 &lt;code&gt;erlang&lt;/code&gt; 및 &lt;code&gt;A&lt;/code&gt; 는 원자 또는 조작자 후 담당자 (Gt의)이다 = &lt;code&gt;{call,LINE,{remote,LINE,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8aef2cea48fdeba80e26c88e7eef4d4b0dc0be26" translate="yes" xml:space="preserve">
          <source>If Gt is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,ANNO,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="translated">Gt가 맵 생성 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; 이고 여기서 각 &lt;code&gt;A_i&lt;/code&gt; 는 연결 &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; 이면 Rep (Gt) = &lt;code&gt;{map,ANNO,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Rep (A)에 대해서는 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="da3cc863263c90fe7c570740ba4eda5e38a4f773" translate="yes" xml:space="preserve">
          <source>If Gt is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="translated">Gt가 맵 작성 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; 인 경우, 각 &lt;code&gt;A_i&lt;/code&gt; 는 연관 &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; 인 경우 Rep (Gt) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . 담당자 (A)에 대해서는 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9d73cdb5044edf8f644c77dc585bc5cd5213ffd6" translate="yes" xml:space="preserve">
          <source>If Gt is a map update &lt;code&gt;Gt_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; or &lt;code&gt;Gt_i_1 := Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,ANNO,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="translated">Gt가 맵 업데이트 &lt;code&gt;Gt_0#{A_1, ..., A_k}&lt;/code&gt; 이고 여기서 각 &lt;code&gt;A_i&lt;/code&gt; 는 연관 &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; 또는 &lt;code&gt;Gt_i_1 := Gt_i_2&lt;/code&gt; 이면 Rep (Gt) = &lt;code&gt;{map,ANNO,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Rep (A)에 대해서는 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8b68b45a396309326113e63efb931d56c934f4e8" translate="yes" xml:space="preserve">
          <source>If Gt is a map update &lt;code&gt;Gt_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; or &lt;code&gt;Gt_i_1 := Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,LINE,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="translated">Gt가 맵 업데이트 &lt;code&gt;Gt_0#{A_1, ..., A_k}&lt;/code&gt; 인 경우, 각 &lt;code&gt;A_i&lt;/code&gt; 는 연관 &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; 또는 &lt;code&gt;Gt_i_1 := Gt_i_2&lt;/code&gt; 이면 Rep (Gt) = &lt;code&gt;{map,LINE,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . 담당자 (A)에 대해서는 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c71638db3891d8e47094eaea5193942aba235460" translate="yes" xml:space="preserve">
          <source>If Gt is a parenthesized guard test &lt;code&gt;( Gt_0 )&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;Rep(Gt_0)&lt;/code&gt;, that is, parenthesized guard tests cannot be distinguished from their bodies.</source>
          <target state="translated">Gt가 괄호로 묶인 가드 테스트 &lt;code&gt;( Gt_0 )&lt;/code&gt; 이면 Rep (Gt) = &lt;code&gt;Rep(Gt_0)&lt;/code&gt; 즉, 괄호로 묶은 가드 테스트는 해당 본문과 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5515e293f7cbca6cd1b4d86301ecc8fcc5ad59f4" translate="yes" xml:space="preserve">
          <source>If Gt is a record creation &lt;code&gt;#Name{Field_1=Gt_1, ..., Field_k=Gt_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{record,ANNO,Name,[{record_field,ANNO,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(Gt_k)}]}&lt;/code&gt;.</source>
          <target state="translated">Gt가 레코드 생성 &lt;code&gt;#Name{Field_1=Gt_1, ..., Field_k=Gt_k}&lt;/code&gt; 이면 각 &lt;code&gt;Field_i&lt;/code&gt; 는 원자 또는 &lt;code&gt;_&lt;/code&gt; 이면 Rep (Gt) = &lt;code&gt;{record,ANNO,Name,[{record_field,ANNO,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(Gt_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95bc9c3e2bbe4154125f8e83e7d1dec9ccf69c3a" translate="yes" xml:space="preserve">
          <source>If Gt is a record creation &lt;code&gt;#Name{Field_1=Gt_1, ..., Field_k=Gt_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(Gt_k)}]}&lt;/code&gt;.</source>
          <target state="translated">Gt가 레코드 작성 &lt;code&gt;#Name{Field_1=Gt_1, ..., Field_k=Gt_k}&lt;/code&gt; 인 경우, 각 &lt;code&gt;Field_i&lt;/code&gt; 가 원자 또는 &lt;code&gt;_&lt;/code&gt; 인 경우 Rep (Gt) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(Gt_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d8c3bdf875936951f6be38abd9a234defb4a787" translate="yes" xml:space="preserve">
          <source>If Gt is a record field access &lt;code&gt;Gt_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_field,ANNO,Rep(Gt_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">Gt가 레코드 필드 인 경우 &lt;code&gt;Gt_0#Name.Field&lt;/code&gt; 에 액세스 합니다. 여기서 &lt;code&gt;Field&lt;/code&gt; 는 원자이면 Rep (Gt) = &lt;code&gt;{record_field,ANNO,Rep(Gt_0),Name,Rep(Field)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7f5219d21b74d303638f0d998d1a523861cfd8ed" translate="yes" xml:space="preserve">
          <source>If Gt is a record field access &lt;code&gt;Gt_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_field,LINE,Rep(Gt_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">GT는이 기록 필드 액세스이면 &lt;code&gt;Gt_0#Name.Field&lt;/code&gt; , &lt;code&gt;Field&lt;/code&gt; 다음 원자, 담당자 (GT는) =이다 &lt;code&gt;{record_field,LINE,Rep(Gt_0),Name,Rep(Field)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ddc523ac11939b47b6ea5667d89b0cf0cbb87da" translate="yes" xml:space="preserve">
          <source>If Gt is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_index,ANNO,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">Gt가 레코드 필드 인덱스 &lt;code&gt;#Name.Field&lt;/code&gt; 이고 여기서 &lt;code&gt;Field&lt;/code&gt; 는 원자이면 Rep (Gt) = &lt;code&gt;{record_index,ANNO,Name,Rep(Field)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a706262c44fbdd9118d527a47e94cc7e8f43cf92" translate="yes" xml:space="preserve">
          <source>If Gt is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">Gt가 레코드 필드 인덱스 &lt;code&gt;#Name.Field&lt;/code&gt; 이고 여기서 &lt;code&gt;Field&lt;/code&gt; 가 원자 인 경우 Rep (Gt) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="91b1ff08bce1f7be5c86e93bf7b896dcee2bcdda" translate="yes" xml:space="preserve">
          <source>If Gt is a tuple skeleton &lt;code&gt;{Gt_1, ..., Gt_k}&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{tuple,ANNO,[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">Gt가 튜플 스켈레톤 &lt;code&gt;{Gt_1, ..., Gt_k}&lt;/code&gt; 이면 Rep (Gt) = &lt;code&gt;{tuple,ANNO,[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f481667ce91658bcad558a1af4b78b60f7692744" translate="yes" xml:space="preserve">
          <source>If Gt is a tuple skeleton &lt;code&gt;{Gt_1, ..., Gt_k}&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{tuple,LINE,[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">Gt가 튜플 스켈레톤 &lt;code&gt;{Gt_1, ..., Gt_k}&lt;/code&gt; 인 경우 Rep (Gt) = &lt;code&gt;{tuple,LINE,[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="86ba6ce0ad44989a3f9fca3540904be2d98eb9da" translate="yes" xml:space="preserve">
          <source>If Gt is a variable pattern &lt;code&gt;V&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{var,ANNO,A}&lt;/code&gt;, where A is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">Gt가 가변 패턴 &lt;code&gt;V&lt;/code&gt; 이면 Rep (Gt) = &lt;code&gt;{var,ANNO,A}&lt;/code&gt; 이며, 여기서 A는 &lt;code&gt;V&lt;/code&gt; 와 동일한 문자로 구성된 인쇄 이름을 가진 원자입니다 .</target>
        </trans-unit>
        <trans-unit id="f06988b89d180cb11b8982908198902c04bcea42" translate="yes" xml:space="preserve">
          <source>If Gt is a variable pattern &lt;code&gt;V&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where A is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">Gt가 가변 패턴 &lt;code&gt;V&lt;/code&gt; 이면 Rep (Gt) = &lt;code&gt;{var,LINE,A}&lt;/code&gt; 입니다 . 여기서 A는 인쇄 이름이 &lt;code&gt;V&lt;/code&gt; 와 동일한 문자로 구성된 원자입니다 .</target>
        </trans-unit>
        <trans-unit id="1b80b2b10f76759502fc592d77587e295e44b6d5" translate="yes" xml:space="preserve">
          <source>If Gt is an atomic literal &lt;code&gt;L&lt;/code&gt;, then Rep(Gt) = Rep(L).</source>
          <target state="translated">Gt가 원자 리터럴 &lt;code&gt;L&lt;/code&gt; 이면 Rep (Gt) = Rep (L)입니다.</target>
        </trans-unit>
        <trans-unit id="30bbb65a3435cb7a0b644ba508d8ad7e2aebd344" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Gt_1 Op Gt_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{op,ANNO,Op,Rep(Gt_1),Rep(Gt_2)}&lt;/code&gt;.</source>
          <target state="translated">Gt가 연산자 보호 테스트 &lt;code&gt;Gt_1 Op Gt_2&lt;/code&gt; 이고 여기서 &lt;code&gt;Op&lt;/code&gt; 는 일치 연산자 &lt;code&gt;=&lt;/code&gt; 이외의 이항 연산자 이면 Rep (Gt) = &lt;code&gt;{op,ANNO,Op,Rep(Gt_1),Rep(Gt_2)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d8ecca50d53c2df91c648c581d109d377a56d333" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Gt_1 Op Gt_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_1),Rep(Gt_2)}&lt;/code&gt;.</source>
          <target state="translated">Gt가 운영자 가드 테스트 &lt;code&gt;Gt_1 Op Gt_2&lt;/code&gt; 인 경우 &lt;code&gt;Op&lt;/code&gt; 는 match operator &lt;code&gt;=&lt;/code&gt; 이외의 이진 연산자 인 경우 Rep (Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_1),Rep(Gt_2)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1590398d554a502b9031594d26d2e7f3c303dfca" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Op Gt_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(Gt) = &lt;code&gt;{op,ANNO,Op,Rep(Gt_0)}&lt;/code&gt;.</source>
          <target state="translated">Gt가 작업자 보호 테스트 &lt;code&gt;Op Gt_0&lt;/code&gt; 이고 여기서 &lt;code&gt;Op&lt;/code&gt; 는 단항 연산자 인 경우 Rep (Gt) = &lt;code&gt;{op,ANNO,Op,Rep(Gt_0)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="59964cf24a3c6e579aace4b47998306937171209" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Op Gt_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_0)}&lt;/code&gt;.</source>
          <target state="translated">Gt가 운영자 가드 테스트 &lt;code&gt;Op Gt_0&lt;/code&gt; 이면 &lt;code&gt;Op&lt;/code&gt; 는 단항 연산자 인 경우 Rep (Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_0)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2bba2b902d7d011a3e4c35fe4e116ae49fd9a8a3" translate="yes" xml:space="preserve">
          <source>If Gt is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{nil,ANNO}&lt;/code&gt;.</source>
          <target state="translated">Gt가 nil, &lt;code&gt;[]&lt;/code&gt; 이면 Rep (Gt) = &lt;code&gt;{nil,ANNO}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="498668c1ce816a52c1e11cee91561fc3f7281cec" translate="yes" xml:space="preserve">
          <source>If Gt is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{nil,LINE}&lt;/code&gt;.</source>
          <target state="translated">Gt가 nil이면 &lt;code&gt;[]&lt;/code&gt; 이면 Rep (Gt) = &lt;code&gt;{nil,LINE}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fb631647ead2cb8b76c4ec1b07f1f0c70bf1b1d6" translate="yes" xml:space="preserve">
          <source>If L is a character literal, then Rep(L) = &lt;code&gt;{char,ANNO,L}&lt;/code&gt;.</source>
          <target state="translated">L이 문자 리터럴이면 Rep (L) = &lt;code&gt;{char,ANNO,L}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8d91f44fbe3739ece99b11544ff08c06f7058b62" translate="yes" xml:space="preserve">
          <source>If L is a character literal, then Rep(L) = &lt;code&gt;{char,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">L이 문자 리터럴 인 경우 Rep (L) = &lt;code&gt;{char,LINE,L}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="893eb2ba60965c09a51b1e49cb8017e58a360073" translate="yes" xml:space="preserve">
          <source>If L is a float literal, then Rep(L) = &lt;code&gt;{float,ANNO,L}&lt;/code&gt;.</source>
          <target state="translated">L이 부동 소수점 리터럴이면 Rep (L) = &lt;code&gt;{float,ANNO,L}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1a70af53d75e256462e24f2a854c77741b9fe2a6" translate="yes" xml:space="preserve">
          <source>If L is a float literal, then Rep(L) = &lt;code&gt;{float,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">L이 부동 리터럴 인 경우 Rep (L) = &lt;code&gt;{float,LINE,L}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b31cf2c573d35c24a7c01f8fb6b6ee646806df21" translate="yes" xml:space="preserve">
          <source>If L is a string literal consisting of the characters &lt;code&gt;C_1&lt;/code&gt;, ..., &lt;code&gt;C_k&lt;/code&gt;, then Rep(L) = &lt;code&gt;{string,ANNO,[C_1, ..., C_k]}&lt;/code&gt;.</source>
          <target state="translated">L이 &lt;code&gt;C_1&lt;/code&gt; , ..., &lt;code&gt;C_k&lt;/code&gt; 문자로 구성된 문자열 리터럴 이면 Rep (L) = &lt;code&gt;{string,ANNO,[C_1, ..., C_k]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bc4e7443f3bff9431f378dad125819933dd7b906" translate="yes" xml:space="preserve">
          <source>If L is a string literal consisting of the characters &lt;code&gt;C_1&lt;/code&gt;, ..., &lt;code&gt;C_k&lt;/code&gt;, then Rep(L) = &lt;code&gt;{string,LINE,[C_1, ..., C_k]}&lt;/code&gt;.</source>
          <target state="translated">L이 &lt;code&gt;C_1&lt;/code&gt; , ..., &lt;code&gt;C_k&lt;/code&gt; 문자로 구성된 문자열 리터럴 인 경우 Rep (L) = &lt;code&gt;{string,LINE,[C_1, ..., C_k]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="46dc6ddf19639701de194e194ca59776f621ce0b" translate="yes" xml:space="preserve">
          <source>If L is an atom literal, then Rep(L) = &lt;code&gt;{atom,ANNO,L}&lt;/code&gt;.</source>
          <target state="translated">L이 원자 리터럴이면 Rep (L) = &lt;code&gt;{atom,ANNO,L}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c151061397c80cc4494386daf911cd7cd3768421" translate="yes" xml:space="preserve">
          <source>If L is an atom literal, then Rep(L) = &lt;code&gt;{atom,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">L이 원자 리터럴 인 경우 Rep (L) = &lt;code&gt;{atom,LINE,L}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9daa1db636bdb57e06f2782f31b76d4535249681" translate="yes" xml:space="preserve">
          <source>If L is an integer literal, then Rep(L) = &lt;code&gt;{integer,ANNO,L}&lt;/code&gt;.</source>
          <target state="translated">L이 정수 리터럴이면 Rep (L) = &lt;code&gt;{integer,ANNO,L}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="009d689b146fb6ed54f2471e1d09e781555b973a" translate="yes" xml:space="preserve">
          <source>If L is an integer literal, then Rep(L) = &lt;code&gt;{integer,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">L이 정수 리터럴 인 경우 Rep (L) = &lt;code&gt;{integer,LINE,L}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="84cceee508e21c83ef5e5c68f567b7df3c0d24d4" translate="yes" xml:space="preserve">
          <source>If Mnesia is down on the local node, the function returns those other &lt;code&gt;db_nodes&lt;/code&gt; and &lt;code&gt;extra_db_nodes&lt;/code&gt; that for the moment are operational.</source>
          <target state="translated">Mnesia가 로컬 노드에서 작동 중지되면이 함수는 현재 작동 &lt;code&gt;extra_db_nodes&lt;/code&gt; 다른 &lt;code&gt;db_nodes&lt;/code&gt; 및 extra_db_nodes 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="d2c7cf7bb11840eda288723b23ff4cc867a91195" translate="yes" xml:space="preserve">
          <source>If Mnesia is started, the function returns those nodes that Mnesia on the local node is fully connected to. Only those nodes that Mnesia has exchanged schema information with are included as &lt;code&gt;running_db_nodes&lt;/code&gt;. After the merge of schemas, the local Mnesia system is fully operable and applications can perform access of remote replicas. Before the schema merge, Mnesia only operates locally. Sometimes there are more nodes included in the &lt;code&gt;running_db_nodes&lt;/code&gt; list than all &lt;code&gt;db_nodes&lt;/code&gt; and &lt;code&gt;extra_db_nodes&lt;/code&gt; together.</source>
          <target state="translated">Mnesia가 시작되면이 함수는 로컬 노드의 Mnesia가 완전히 연결된 노드를 반환합니다. Mnesia가 스키마 정보를 교환 한 노드 만 &lt;code&gt;running_db_nodes&lt;/code&gt; 로 포함됩니다 . 스키마를 병합 한 후에는 로컬 Mnesia 시스템이 완전히 작동하며 응용 프로그램이 원격 복제본에 대한 액세스를 수행 할 수 있습니다. 스키마 병합 전에 Mnesia는 로컬에서만 작동합니다. 때로는 &lt;code&gt;running_db_nodes&lt;/code&gt; 목록에 모든 &lt;code&gt;db_nodes&lt;/code&gt; 및 &lt;code&gt;extra_db_nodes&lt;/code&gt; 보다 더 많은 노드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e5a20f661013e882b9b593b517c8c9ba753d645" translate="yes" xml:space="preserve">
          <source>If Mnesia is used as storage method, Mnesia must be started before the HTTP server. The first time Mnesia is started, the schema and the tables must be created before Mnesia is started. A simple example of a module with two functions that creates and start Mnesia is provided here. Function &lt;code&gt;first_start/0&lt;/code&gt; is to be used the first time. It creates the schema and the tables. &lt;code&gt;start/0&lt;/code&gt; is to be used in consecutive startups. &lt;code&gt;start/0&lt;/code&gt; starts Mnesia and waits for the tables to be initiated. This function must only be used when the schema and the tables are already created.</source>
          <target state="translated">Mnesia를 저장 방법으로 사용하는 경우 HTTP 서버보다 먼저 Mnesia를 시작해야합니다. Mnesia를 처음 시작하면 Mnesia를 시작하기 전에 스키마와 테이블을 작성해야합니다. Mnesia를 생성하고 시작하는 두 가지 기능을 가진 모듈의 간단한 예가 여기에 제공됩니다. &lt;code&gt;first_start/0&lt;/code&gt; 기능 이 처음으로 사용됩니다. 스키마와 테이블을 만듭니다. &lt;code&gt;start/0&lt;/code&gt; 은 연속적인 시작에 사용됩니다. &lt;code&gt;start/0&lt;/code&gt; 은 Mnesia를 시작하고 테이블이 시작되기를 기다립니다. 이 함수는 스키마와 테이블이 이미 작성된 경우에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a0ff6de34e690fd37142329b3d2414f3154795bb" translate="yes" xml:space="preserve">
          <source>If P is a bitstring pattern &lt;code&gt;&amp;lt;&amp;lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression that can be evaluated to an integer, and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(P) = &lt;code&gt;{bin,ANNO,[{bin_element,ANNO,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,ANNO,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">P가 비트 스트링 패턴 &lt;code&gt;&amp;lt;&amp;lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; 이면, 여기서 각 &lt;code&gt;Size_i&lt;/code&gt; 는 정수로 평가할 수있는 표현식이고 각 &lt;code&gt;TSL_i&lt;/code&gt; 는 유형 지정자 목록입니다. 담당자 (P) = &lt;code&gt;{bin,ANNO,[{bin_element,ANNO,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,ANNO,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; . Rep (TSL)에 대해서는 아래를 참조하십시오. 생략 된 &lt;code&gt;Size_i&lt;/code&gt; 는 &lt;code&gt;default&lt;/code&gt; 표시됩니다 . 생략 된 &lt;code&gt;TSL_i&lt;/code&gt; 는 &lt;code&gt;default&lt;/code&gt; 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f34211f341486b630397795df16c3df17f3d92d3" translate="yes" xml:space="preserve">
          <source>If P is a bitstring pattern &lt;code&gt;&amp;lt;&amp;lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression that can be evaluated to an integer, and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(P) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">P가 비트 스트링 패턴 &lt;code&gt;&amp;lt;&amp;lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; 인 경우, 각 &lt;code&gt;Size_i&lt;/code&gt; 는 정수로 평가할 수있는 표현식이고 각 &lt;code&gt;TSL_i&lt;/code&gt; 는 유형별리스트입니다. 담당자 (P) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; . 담당자 (TSL)는 아래를 참조하십시오. 생략 된 &lt;code&gt;Size_i&lt;/code&gt; 는 &lt;code&gt;default&lt;/code&gt; 표시됩니다 . 생략 된 &lt;code&gt;TSL_i&lt;/code&gt; 는 &lt;code&gt;default&lt;/code&gt; 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="d37994ece6f75def5d9f7facc328a7886d4a88b5" translate="yes" xml:space="preserve">
          <source>If P is a compound pattern &lt;code&gt;P_1 = P_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{match,ANNO,Rep(P_1),Rep(P_2)}&lt;/code&gt;.</source>
          <target state="translated">P가 복합 패턴 &lt;code&gt;P_1 = P_2&lt;/code&gt; 이면 Rep (P) = &lt;code&gt;{match,ANNO,Rep(P_1),Rep(P_2)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c8c2a2980c64258557d34be973ca8c30e59cc6bc" translate="yes" xml:space="preserve">
          <source>If P is a compound pattern &lt;code&gt;P_1 = P_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{match,LINE,Rep(P_1),Rep(P_2)}&lt;/code&gt;.</source>
          <target state="translated">P가 복합 패턴 &lt;code&gt;P_1 = P_2&lt;/code&gt; 인 경우 Rep (P) = &lt;code&gt;{match,LINE,Rep(P_1),Rep(P_2)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3c6ccb3b7440efc69c50224b64f913af2ed5a932" translate="yes" xml:space="preserve">
          <source>If P is a cons pattern &lt;code&gt;[P_h | P_t]&lt;/code&gt;, then Rep(P) = &lt;code&gt;{cons,ANNO,Rep(P_h),Rep(P_t)}&lt;/code&gt;.</source>
          <target state="translated">P가 단점 패턴 인 경우 &lt;code&gt;[P_h | P_t]&lt;/code&gt; , Rep (P) = &lt;code&gt;{cons,ANNO,Rep(P_h),Rep(P_t)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b3a96a126f33c33dfd4bad3afe04a55374bef41" translate="yes" xml:space="preserve">
          <source>If P is a cons pattern &lt;code&gt;[P_h | P_t]&lt;/code&gt;, then Rep(P) = &lt;code&gt;{cons,LINE,Rep(P_h),Rep(P_t)}&lt;/code&gt;.</source>
          <target state="translated">P가 단점 패턴 인 경우 &lt;code&gt;[P_h | P_t]&lt;/code&gt; 이면 Rep (P) = &lt;code&gt;{cons,LINE,Rep(P_h),Rep(P_t)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fc2c7ec165d91dd1b0c944a7cacc79a36a649770" translate="yes" xml:space="preserve">
          <source>If P is a map pattern &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;P_i_1 := P_i_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{map,ANNO,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">P가 맵 패턴 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; 이고 여기서 각 &lt;code&gt;A_i&lt;/code&gt; 는 연관 &lt;code&gt;P_i_1 := P_i_2&lt;/code&gt; 이면 Rep (P) = &lt;code&gt;{map,ANNO,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Rep (A)에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cd5a1996d5cee5775413b66baffcba7cfd424d8b" translate="yes" xml:space="preserve">
          <source>If P is a map pattern &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;P_i_1 := P_i_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">P가 맵 패턴 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; 인 경우, 각 &lt;code&gt;A_i&lt;/code&gt; 는 연관 &lt;code&gt;P_i_1 := P_i_2&lt;/code&gt; 이고 Rep (P) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . 담당자 (A)는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="19737da2fe03d867999d377974efb452c080feda" translate="yes" xml:space="preserve">
          <source>If P is a nil pattern &lt;code&gt;[]&lt;/code&gt;, then Rep(P) = &lt;code&gt;{nil,ANNO}&lt;/code&gt;.</source>
          <target state="translated">P가 nil 패턴 &lt;code&gt;[]&lt;/code&gt; 이면 Rep (P) = &lt;code&gt;{nil,ANNO}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c7fbdc51ae228be4fbd8c6e7c0ddb45260e0acb0" translate="yes" xml:space="preserve">
          <source>If P is a nil pattern &lt;code&gt;[]&lt;/code&gt;, then Rep(P) = &lt;code&gt;{nil,LINE}&lt;/code&gt;.</source>
          <target state="translated">P가 nil 패턴 &lt;code&gt;[]&lt;/code&gt; 인 경우 Rep (P) = &lt;code&gt;{nil,LINE}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="72a84ce197dfd951db7868fea8973a6459407137" translate="yes" xml:space="preserve">
          <source>If P is a parenthesized pattern &lt;code&gt;( P_0 )&lt;/code&gt;, then Rep(P) = &lt;code&gt;Rep(P_0)&lt;/code&gt;, that is, parenthesized patterns cannot be distinguished from their bodies.</source>
          <target state="translated">P가 괄호로 묶인 패턴 &lt;code&gt;( P_0 )&lt;/code&gt; 이면 Rep (P) = &lt;code&gt;Rep(P_0)&lt;/code&gt; , 즉 괄호로 묶인 패턴은 해당 본문과 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dfc926eeb885550b2057f5eaa3e598f075f5fb9c" translate="yes" xml:space="preserve">
          <source>If P is a record field index pattern &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(P) = &lt;code&gt;{record_index,ANNO,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">P가 레코드 필드 인덱스 패턴 &lt;code&gt;#Name.Field&lt;/code&gt; 이고 여기서 &lt;code&gt;Field&lt;/code&gt; 는 원자이면 Rep (P) = &lt;code&gt;{record_index,ANNO,Name,Rep(Field)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d6dae07160d27f4934f31cae5e6b4f2d04d1afc9" translate="yes" xml:space="preserve">
          <source>If P is a record field index pattern &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(P) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">P가 레코드 필드 인덱스 패턴 &lt;code&gt;#Name.Field&lt;/code&gt; 인 경우, 여기서 &lt;code&gt;Field&lt;/code&gt; 는 원자 인 경우 Rep (P) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7a6a33479e55d6adf6c5f304da26c896bfab008d" translate="yes" xml:space="preserve">
          <source>If P is a record pattern &lt;code&gt;#Name{Field_1=P_1, ..., Field_k=P_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(P) = &lt;code&gt;{record,ANNO,Name,[{record_field,ANNO,Rep(Field_1),Rep(P_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(P_k)}]}&lt;/code&gt;.</source>
          <target state="translated">P가 레코드 패턴 &lt;code&gt;#Name{Field_1=P_1, ..., Field_k=P_k}&lt;/code&gt; 이고 여기서 각 &lt;code&gt;Field_i&lt;/code&gt; 는 원자 또는 &lt;code&gt;_&lt;/code&gt; 이면 Rep (P) = &lt;code&gt;{record,ANNO,Name,[{record_field,ANNO,Rep(Field_1),Rep(P_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(P_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c817b814455c0bbd5e19cc0a1e27a932ad7ae3e" translate="yes" xml:space="preserve">
          <source>If P is a record pattern &lt;code&gt;#Name{Field_1=P_1, ..., Field_k=P_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(P) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(P_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(P_k)}]}&lt;/code&gt;.</source>
          <target state="translated">P가 레코드 패턴 &lt;code&gt;#Name{Field_1=P_1, ..., Field_k=P_k}&lt;/code&gt; 인 경우, 각 &lt;code&gt;Field_i&lt;/code&gt; 가 원자 또는 &lt;code&gt;_&lt;/code&gt; 인 경우 Rep (P) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(P_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(P_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75542af568a4e6fd74ec30069d26212ef35f7d03" translate="yes" xml:space="preserve">
          <source>If P is a tuple pattern &lt;code&gt;{P_1, ..., P_k}&lt;/code&gt;, then Rep(P) = &lt;code&gt;{tuple,ANNO,[Rep(P_1), ..., Rep(P_k)]}&lt;/code&gt;.</source>
          <target state="translated">P가 튜플 패턴 &lt;code&gt;{P_1, ..., P_k}&lt;/code&gt; 이면 Rep (P) = &lt;code&gt;{tuple,ANNO,[Rep(P_1), ..., Rep(P_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="26f2ebd069093962c3169272794269248d2ef02b" translate="yes" xml:space="preserve">
          <source>If P is a tuple pattern &lt;code&gt;{P_1, ..., P_k}&lt;/code&gt;, then Rep(P) = &lt;code&gt;{tuple,LINE,[Rep(P_1), ..., Rep(P_k)]}&lt;/code&gt;.</source>
          <target state="translated">P가 튜플 패턴 &lt;code&gt;{P_1, ..., P_k}&lt;/code&gt; 인 경우 Rep (P) = &lt;code&gt;{tuple,LINE,[Rep(P_1), ..., Rep(P_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e2f93073cfd79739d9e631820436bac79686fc83" translate="yes" xml:space="preserve">
          <source>If P is a universal pattern &lt;code&gt;_&lt;/code&gt;, then Rep(P) = &lt;code&gt;{var,ANNO,'_'}&lt;/code&gt;.</source>
          <target state="translated">P가 범용 패턴 &lt;code&gt;_&lt;/code&gt; 이면 Rep (P) = &lt;code&gt;{var,ANNO,'_'}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1673a195237ed41e2323e9fba0581f25f4bc7a6c" translate="yes" xml:space="preserve">
          <source>If P is a universal pattern &lt;code&gt;_&lt;/code&gt;, then Rep(P) = &lt;code&gt;{var,LINE,'_'}&lt;/code&gt;.</source>
          <target state="translated">P가 범용 패턴 &lt;code&gt;_&lt;/code&gt; 이면 Rep (P) = &lt;code&gt;{var,LINE,'_'}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3149c3832edd80b313902a9d154c6d727e573468" translate="yes" xml:space="preserve">
          <source>If P is a variable pattern &lt;code&gt;V&lt;/code&gt;, then Rep(P) = &lt;code&gt;{var,ANNO,A}&lt;/code&gt;, where A is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">P가 가변 패턴 &lt;code&gt;V&lt;/code&gt; 이면 Rep (P) = &lt;code&gt;{var,ANNO,A}&lt;/code&gt; 이며, 여기서 A는 &lt;code&gt;V&lt;/code&gt; 와 동일한 문자로 구성된 인쇄 이름을 가진 원자입니다 .</target>
        </trans-unit>
        <trans-unit id="374e95854b4ce10a9075d7ca4749ba4604e1f66b" translate="yes" xml:space="preserve">
          <source>If P is a variable pattern &lt;code&gt;V&lt;/code&gt;, then Rep(P) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where A is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">P가 가변 패턴 &lt;code&gt;V&lt;/code&gt; 이면 Rep (P) = &lt;code&gt;{var,LINE,A}&lt;/code&gt; 입니다 . 여기서 A는 인쇄 이름이 &lt;code&gt;V&lt;/code&gt; 와 동일한 문자로 구성된 원자입니다 .</target>
        </trans-unit>
        <trans-unit id="037087e53a14f2b5880a3446fa475c0011fde7f9" translate="yes" xml:space="preserve">
          <source>If P is an atomic literal &lt;code&gt;L&lt;/code&gt;, then Rep(P) = Rep(L).</source>
          <target state="translated">P가 원자 리터럴 &lt;code&gt;L&lt;/code&gt; 인 경우 Rep (P) = Rep (L)입니다.</target>
        </trans-unit>
        <trans-unit id="faca9ab114984c50875ddef7ab3151e741e59fdd" translate="yes" xml:space="preserve">
          <source>If P is an operator pattern &lt;code&gt;Op P_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator (this is an occurrence of an expression that can be evaluated to a number at compile time), then Rep(P) = &lt;code&gt;{op,ANNO,Op,Rep(P_0)}&lt;/code&gt;.</source>
          <target state="translated">P가 연산자 패턴 &lt;code&gt;Op P_0&lt;/code&gt; 이고 여기서 &lt;code&gt;Op&lt;/code&gt; 는 단항 연산자 (컴파일 시간에 숫자로 평가 될 수있는 표현식의 발생)이면 Rep (P) = &lt;code&gt;{op,ANNO,Op,Rep(P_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3611eec9cbc1948d638f692cb3c204535c40a243" translate="yes" xml:space="preserve">
          <source>If P is an operator pattern &lt;code&gt;Op P_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator (this is an occurrence of an expression that can be evaluated to a number at compile time), then Rep(P) = &lt;code&gt;{op,LINE,Op,Rep(P_0)}&lt;/code&gt;.</source>
          <target state="translated">P가 연산자 패턴 &lt;code&gt;Op P_0&lt;/code&gt; 이면 &lt;code&gt;Op&lt;/code&gt; 는 단항 연산자 (컴파일시 숫자로 평가할 수있는 표현식의 발생) 인 경우 Rep (P) = &lt;code&gt;{op,LINE,Op,Rep(P_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e5c0b3f1ae8df31dec63b9c72633bdc64593894" translate="yes" xml:space="preserve">
          <source>If P is an operator pattern &lt;code&gt;P_1 Op P_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator (this is either an occurrence of &lt;code&gt;++&lt;/code&gt; applied to a literal string or character list, or an occurrence of an expression that can be evaluated to a number at compile time), then Rep(P) = &lt;code&gt;{op,ANNO,Op,Rep(P_1),Rep(P_2)}&lt;/code&gt;.</source>
          <target state="translated">P가 연산자 패턴 인 경우 &lt;code&gt;P_1 Op P_2&lt;/code&gt; , 여기서 &lt;code&gt;Op&lt;/code&gt; 는 이항 연산자 ( 리터럴 문자열 또는 문자 목록에 적용된 &lt;code&gt;++&lt;/code&gt; 발생 또는 컴파일 타임에 숫자로 평가 될 수있는 표현식 발생) ), Rep (P) = &lt;code&gt;{op,ANNO,Op,Rep(P_1),Rep(P_2)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c20d57a29a11d3b725da4217b551d072cb2d9645" translate="yes" xml:space="preserve">
          <source>If P is an operator pattern &lt;code&gt;P_1 Op P_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator (this is either an occurrence of &lt;code&gt;++&lt;/code&gt; applied to a literal string or character list, or an occurrence of an expression that can be evaluated to a number at compile time), then Rep(P) = &lt;code&gt;{op,LINE,Op,Rep(P_1),Rep(P_2)}&lt;/code&gt;.</source>
          <target state="translated">P가 연산자 패턴 &lt;code&gt;P_1 Op P_2&lt;/code&gt; 인 경우, &lt;code&gt;Op&lt;/code&gt; 는 2 진 연산자입니다 (이것은 리터럴 문자열 또는 문자 목록에 적용된 &lt;code&gt;++&lt;/code&gt; 발생 또는 컴파일시 숫자로 평가 될 수있는 표현식 발생입니다) )를 입력 한 다음 Rep (P) = &lt;code&gt;{op,LINE,Op,Rep(P_1),Rep(P_2)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3a50d35a985d1c4853945f370a6dcaf95a405ff8" translate="yes" xml:space="preserve">
          <source>If PER encoding is wanted:</source>
          <target state="translated">PER 인코딩이 필요한 경우 :</target>
        </trans-unit>
        <trans-unit id="8e69f891849831d14d1ae17a1a43b56f2f0e1d17" translate="yes" xml:space="preserve">
          <source>If Ps is a sequence of patterns &lt;code&gt;P_1, ..., P_k&lt;/code&gt;, then Rep(Ps) = &lt;code&gt;[Rep(P_1), ..., Rep(P_k)]&lt;/code&gt;. Such sequences occur as the list of arguments to a function or fun.</source>
          <target state="translated">Ps가 일련의 패턴 &lt;code&gt;P_1, ..., P_k&lt;/code&gt; 이면 Rep (Ps) = &lt;code&gt;[Rep(P_1), ..., Rep(P_k)]&lt;/code&gt; 입니다. 이러한 시퀀스는 함수 또는 재미에 대한 인수 목록으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ad13e93659ed632a16cc4f4903f37ddc1132e280" translate="yes" xml:space="preserve">
          <source>If Q is a bitstring generator &lt;code&gt;P &amp;lt;= E&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;{b_generate,ANNO,Rep(P),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">Q가 비트 스트링 생성기 &lt;code&gt;P &amp;lt;= E&lt;/code&gt; 이고 여기서 &lt;code&gt;P&lt;/code&gt; 는 패턴이고 &lt;code&gt;E&lt;/code&gt; 는 표현식이면 Rep (Q) = &lt;code&gt;{b_generate,ANNO,Rep(P),Rep(E)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="db3d9c3be41ff91340aed17068892205b8e19bdf" translate="yes" xml:space="preserve">
          <source>If Q is a bitstring generator &lt;code&gt;P &amp;lt;= E&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;{b_generate,LINE,Rep(P),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">Q가 비트 스트링 생성기 &lt;code&gt;P &amp;lt;= E&lt;/code&gt; 이고 여기서 &lt;code&gt;P&lt;/code&gt; 는 패턴이고 &lt;code&gt;E&lt;/code&gt; 는 표현식 인 경우 Rep (Q) = &lt;code&gt;{b_generate,LINE,Rep(P),Rep(E)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="50623f16fe5c165b35f76e12f8a3d6ba87d05b14" translate="yes" xml:space="preserve">
          <source>If Q is a filter &lt;code&gt;E&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;Rep(E)&lt;/code&gt;.</source>
          <target state="translated">Q가 필터 &lt;code&gt;E&lt;/code&gt; 이고 여기서 &lt;code&gt;E&lt;/code&gt; 가 표현식이면 Rep (Q) = &lt;code&gt;Rep(E)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="809f12ef8c3064b918954c279d0a931407f3434e" translate="yes" xml:space="preserve">
          <source>If Q is a generator &lt;code&gt;P &amp;lt;- E&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;{generate,ANNO,Rep(P),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">Q가 생성기 &lt;code&gt;P &amp;lt;- E&lt;/code&gt; 이고 여기서 &lt;code&gt;P&lt;/code&gt; 는 패턴이고 &lt;code&gt;E&lt;/code&gt; 는 표현식이면 Rep (Q) = &lt;code&gt;{generate,ANNO,Rep(P),Rep(E)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0ed7ef1b4d4a36ddad7dd7fceafbd179ffb47f54" translate="yes" xml:space="preserve">
          <source>If Q is a generator &lt;code&gt;P &amp;lt;- E&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;{generate,LINE,Rep(P),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">Q가 제너레이터 &lt;code&gt;P &amp;lt;- E&lt;/code&gt; 이며, 여기서 &lt;code&gt;P&lt;/code&gt; 는 패턴이고 &lt;code&gt;E&lt;/code&gt; 는 표현식 인 경우 Rep (Q) = &lt;code&gt;{generate,LINE,Rep(P),Rep(E)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cee5bb555da8992e2b4f0f92c76f0e2b4698cbd0" translate="yes" xml:space="preserve">
          <source>If R is a relation from X to Y, and S is a relation from Y to Z, the &lt;strong id=&quot;relative_product&quot;&gt;relative product&lt;/strong&gt; of R and S is the relation T from X to Z defined so that x T z if and only if there exists an element y in Y such that x R y and y S z.</source>
          <target state="translated">R이 X와 Y의 관계이고 S가 Y와 Z 의 관계인 경우 R과 S 의 &lt;strong id=&quot;relative_product&quot;&gt;상대 곱은&lt;/strong&gt; x와 Z의 관계 T가 정의되어 있으므로 요소 y가있는 경우에만 x T z x R y 및 y S z와 같은 Y에서.</target>
        </trans-unit>
        <trans-unit id="618098342145de14043b9d049d0e27a0dbe8a5ba" translate="yes" xml:space="preserve">
          <source>If R is a relation in X, and if S is defined so that x S y if x R y and not x = y, then S is the &lt;strong id=&quot;strict_relation&quot;&gt;strict&lt;/strong&gt; relation corresponding to R. Conversely, if S is a relation in X, and if R is defined so that x R y if x S y or x = y, then R is the &lt;strong id=&quot;weak_relation&quot;&gt;weak&lt;/strong&gt; relation corresponding to S.</source>
          <target state="translated">R이 X의 관계이고 S가 x = y가 아닌 x R y 인 경우 x S y가 정의되어 있으면 S는 R에 해당하는 &lt;strong id=&quot;strict_relation&quot;&gt;엄격한&lt;/strong&gt; 관계입니다. 반대로 S가 X의 관계인 경우 R은 x S y 또는 x = y 인 경우 x R y가되도록 정의되며, R은 S에 해당하는 &lt;strong id=&quot;weak_relation&quot;&gt;약한&lt;/strong&gt; 관계입니다.</target>
        </trans-unit>
        <trans-unit id="6577b63edebfaf6cb114810862f5d1c1f7536b21" translate="yes" xml:space="preserve">
          <source>If R is an equivalence relation in X, and x is an element of X, the &lt;strong id=&quot;equivalence_class&quot;&gt;equivalence class&lt;/strong&gt; of x with respect to R is the set of all those elements y of X for which x R y holds. The equivalence classes constitute a partitioning of X. Conversely, if C is a partition of X, the relation that holds for any two elements of X if they belong to the same equivalence class, is an equivalence relation induced by the partition C.</source>
          <target state="translated">R이 X에서 동등성 관계이고 x가 X의 요소 인 경우, R에 대한 x 의 &lt;strong id=&quot;equivalence_class&quot;&gt;동등성 클래스&lt;/strong&gt; 는 x R y가 보유하는 X의 모든 요소 y의 세트입니다. 동등성 클래스는 X의 파티셔닝을 구성합니다. 반대로, C가 X의 파티션 인 경우, X가 동일한 동등성 클래스에 속하는 경우 X의 두 요소에 대해 유지되는 관계는 파티션 C에 의해 유발 된 동등성 관계입니다.</target>
        </trans-unit>
        <trans-unit id="83162ddd20e00fa4a162cbcf127d9c0721481053" translate="yes" xml:space="preserve">
          <source>If R is an equivalence relation in X, the &lt;strong id=&quot;canonical_map&quot;&gt;canonical map&lt;/strong&gt; is the function that maps every element of X onto its equivalence class.</source>
          <target state="translated">R이 X에서 동등성 관계인 경우 &lt;strong id=&quot;canonical_map&quot;&gt;표준 맵&lt;/strong&gt; 은 X의 모든 요소를 ​​해당 동등성 클래스에 맵핑하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="2e3f4abb96f981c697c50aab79cfafffa5fa7e98" translate="yes" xml:space="preserve">
          <source>If S is a restriction of R to A, then R is an &lt;strong id=&quot;extension&quot;&gt;extension&lt;/strong&gt; of S to X.</source>
          <target state="translated">S가 R에서 A 로의 제한 인 경우 R은 S에서 X 로의 &lt;strong id=&quot;extension&quot;&gt;확장&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="59bb1dc7653278e89c3f5020133ebdcc7761c491" translate="yes" xml:space="preserve">
          <source>If S is an element (T, X) of Sets, then T is a &lt;strong id=&quot;valid_type&quot;&gt;valid type&lt;/strong&gt; of X, T is the type of S, and X is the external set of S. &lt;code&gt;&lt;a href=&quot;#from_term-2&quot;&gt;from_term/2&lt;/a&gt;&lt;/code&gt; creates a set from a type and an Erlang term turned into an external set.</source>
          <target state="translated">S가 세트의 요소 (T, X) 인 경우 T는 &lt;strong id=&quot;valid_type&quot;&gt;유효한&lt;/strong&gt; X &lt;strong id=&quot;valid_type&quot;&gt;유형&lt;/strong&gt; , T는 S 유형, X는 외부 S 세트입니다. &lt;code&gt;&lt;a href=&quot;#from_term-2&quot;&gt;from_term/2&lt;/a&gt;&lt;/code&gt; 는 유형에서 세트를 작성하고 Erlang 용어는 외부 집합으로 바뀌었다.</target>
        </trans-unit>
        <trans-unit id="d08abf342530f661d47c0b2d46fbf1f0e30add56" translate="yes" xml:space="preserve">
          <source>If SASL is not included as an application in the &lt;code&gt;.rel&lt;/code&gt; file, a warning is issued because such a release cannot be used in an upgrade. To turn off this warning, add option &lt;code&gt;no_warn_sasl&lt;/code&gt;.</source>
          <target state="translated">SASL이 &lt;code&gt;.rel&lt;/code&gt; 파일에 응용 프로그램으로 포함되어 있지 않으면 해당 릴리스를 업그레이드에 사용할 수 없으므로 경고가 표시됩니다. 이 경고를 끄려면 &lt;code&gt;no_warn_sasl&lt;/code&gt; 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d446165493e24efa50be7a65b22a36a79836aa6" translate="yes" xml:space="preserve">
          <source>If SNMPv3 is used, these MIBs are loaded by default.</source>
          <target state="translated">SNMPv3을 사용하는 경우 이러한 MIB가 기본적으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="99d068911d44f519900efdb97e0ebd14d390453e" translate="yes" xml:space="preserve">
          <source>If SetFun is specified as a fun, the fun is applied to each element of the given set and the return value is assumed to be a set.</source>
          <target state="translated">SetFun을 fun로 지정하면 지정된 세트의 각 요소에 fun이 적용되고 리턴 값은 세트로 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="e3976f1f032e302393b8bb08320950e629b9d555" translate="yes" xml:space="preserve">
          <source>If SetFun is specified as a tuple &lt;code&gt;{external, Fun}&lt;/code&gt;, Fun is applied to the external set of each element of the given set and the return value is assumed to be an external set. Selecting the elements of an unordered set as external sets and assembling a new unordered set from a list of external sets is in the present implementation more efficient than modifying each element as a set. However, this optimization can only be used when the elements of the unordered set are atomic or ordered sets. It must also be the case that the type of the elements matches some clause of Fun (the type of the created set is the result of applying Fun to the type of the given set), and that Fun does nothing but selecting, duplicating, or rearranging parts of the elements.</source>
          <target state="translated">SetFun이 튜플 &lt;code&gt;{external, Fun}&lt;/code&gt; 로 지정되면 지정된 세트의 각 요소의 외부 세트에 Fun이 적용되고 리턴 값은 외부 세트 인 것으로 가정됩니다. 비 순차 세트의 요소를 외부 세트로 선택하고 외부 세트의리스트로부터 새로운 비 순차 세트를 조립하는 것이 본 구현에서 각 요소를 세트로 수정하는 것보다 더 효율적이다. 그러나이 최적화는 비 순차 세트의 요소가 원자 또는 순서 세트 인 경우에만 사용할 수 있습니다. 또한 요소 유형이 Fun의 일부 절 (작성된 세트의 유형이 지정된 세트의 유형에 Fun을 적용한 결과 임)과 일치하고 Fun이 선택, 복제 또는 요소의 일부를 재정렬.</target>
        </trans-unit>
        <trans-unit id="43c0a8b3ea81788001f690f7e87c84083499ae45" translate="yes" xml:space="preserve">
          <source>If T is &lt;code&gt;( T_0 )&lt;/code&gt;, then Rep(T) = &lt;code&gt;Rep(T_0)&lt;/code&gt;, that is, parenthesized types cannot be distinguished from their bodies.</source>
          <target state="translated">T가 &lt;code&gt;( T_0 )&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;Rep(T_0)&lt;/code&gt; . 즉, 괄호로 묶은 유형은 해당 본문과 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3fe813c684b65a78f678a4bec68aa5f263202a79" translate="yes" xml:space="preserve">
          <source>If T is a bitstring type &lt;code&gt;&amp;lt;&amp;lt;_:M,_:_*N&amp;gt;&amp;gt;&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; are singleton integer types, then Rep(T) = &lt;code&gt;{type,ANNO,binary,[Rep(M),Rep(N)]}&lt;/code&gt;.</source>
          <target state="translated">T가 비트 스트링 유형 &lt;code&gt;&amp;lt;&amp;lt;_:M,_:_*N&amp;gt;&amp;gt;&lt;/code&gt; 이고 여기서 &lt;code&gt;M&lt;/code&gt; 과 &lt;code&gt;N&lt;/code&gt; 은 단일 정수 유형이면 Rep (T) = &lt;code&gt;{type,ANNO,binary,[Rep(M),Rep(N)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54d59bcb751b787399eaa6216688da1c771a3508" translate="yes" xml:space="preserve">
          <source>If T is a bitstring type &lt;code&gt;&amp;lt;&amp;lt;_:M,_:_*N&amp;gt;&amp;gt;&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; are singleton integer types, then Rep(T) = &lt;code&gt;{type,LINE,binary,[Rep(M),Rep(N)]}&lt;/code&gt;.</source>
          <target state="translated">T가 비트 열 유형 &lt;code&gt;&amp;lt;&amp;lt;_:M,_:_*N&amp;gt;&amp;gt;&lt;/code&gt; 이고 여기서 &lt;code&gt;M&lt;/code&gt; 과 &lt;code&gt;N&lt;/code&gt; 이 단일 정수 유형 인 경우 Rep (T) = &lt;code&gt;{type,LINE,binary,[Rep(M),Rep(N)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f85dadf01e8f30907411f8ced0faf82947f6804" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun((...) -&amp;gt; T_0)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,'fun',[{type,ANNO,any},Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">T가 &lt;code&gt;fun((...) -&amp;gt; T_0)&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{type,ANNO,'fun',[{type,ANNO,any},Rep(T_0)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2bb0862754ffb06068ede8dc817a72eb1519add3" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun((...) -&amp;gt; T_0)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,any},Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">T가 재미있는 유형 &lt;code&gt;fun((...) -&amp;gt; T_0)&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,any},Rep(T_0)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a390f10fcd8d8a36def467725d4dda00982dd986" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,'fun',[]}&lt;/code&gt;.</source>
          <target state="translated">T가 &lt;code&gt;fun()&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{type,ANNO,'fun',[]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7f9d5b99a9c22d7dc1e1078c45173c119d328720" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,'fun',[]}&lt;/code&gt;.</source>
          <target state="translated">T가 재미있는 유형 &lt;code&gt;fun()&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{type,LINE,'fun',[]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2b7630c752d5e9079868a01fb10ba5440be40003" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun(Ft)&lt;/code&gt;, where &lt;code&gt;Ft&lt;/code&gt; is a function type, then Rep(T) = &lt;code&gt;Rep(Ft)&lt;/code&gt;. For Rep(Ft), see below.</source>
          <target state="translated">T가 fun type &lt;code&gt;fun(Ft)&lt;/code&gt; 이면 &lt;code&gt;Ft&lt;/code&gt; 가 함수 유형이면 Rep (T) = &lt;code&gt;Rep(Ft)&lt;/code&gt; 입니다. Rep (Ft)에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
